{
  "metadata": {
    "timestamp": 1736709696840,
    "page": 69,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjcw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "martanne/vis",
      "stars": 4295,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".builds",
          "type": "tree",
          "content": null
        },
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.0986328125,
          "content": "ignore:\n - \"dependency\"\n - \"test\"\n\ncomment: off\n\ncoverage:\n  status:\n    project: off\n    patch: off\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1865234375,
          "content": "root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\nindent_style = tab\n\n[*.md]\nindent_size = 4\nindent_style = space\ntrim_trailing_whitespace = false\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.13671875,
          "content": "/config.h\n/config.mk\n/dependency\n/obj\n/vis\n/vis-menu\n/vis-single\n/vis-single-payload.inc\n/vis-digraph\n*.css\n*.gcda\n*.gcno\n*.gcov\n*.html\n*.d\n"
        },
        {
          "name": ".luacheckrc",
          "type": "blob",
          "size": 0.2109375,
          "content": "-- std = \"min\"\nglobals = { \"vis\" }\ninclude_files = { \"lua/*.lua\", \"lua/**/*.lua\", \"test/lua/*.lua\" }\nexclude_files = { \"lua/lexer.lua\", \"lua/lexers/**\", \"test/lua/visrc.lua\" }\nfiles[\"test/lua\"] = { std = \"+busted\" }\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 15.4853515625,
          "content": "## [0.9] - 2024-05-01\n\nThis release has been long in the works but its time now. There\nhave been many additions and bugfixes since 0.8. In particular\nchanges to the Lua API have made it easier to extend `vis` in all\nsorts of ways that were previously difficult or impossible. As\nalways the appreciation towards contributors new and old can not\nbe understated; thanks goes out to everyone for their efforts!\n\nA summary of changes follows:\n\n### Core\n\n- Compare non-existing files by name and existing files by inode\n- Do tilde expansion only for the tilde character at the beginning of the pattern.\n- Add word wrapping via breakat and wrapcolumn options\n- Add ansi escaping values and theming keyword for dimmed text\n- Allow statusbar to disabled\n- Default theme was changed to one that uses the terminal colors directly.\n\n### Lua\n\n- filetype: support filetype detection via hashbang\n- filetype: many new file extensions are covered\n- Resync the lexers with Scintillua\n- Implement Selection:remove()\n- Allow underscore (_) in command names\n- Allow nil in vis:pipe() File and Range parameters\n- Add fullscreen param to vis_pipe_collect() and vis:pipe()\n- Access and set all available editor options\n- Implementation of the non-blocking process running Lua API\n- Make expandtab and tabwidth options window-local\n- Drop redrawtime option\n- Add a Lua constant for UI_STYLE_LEXER_MAX\n- Report viewport as lines in addition to bytes\n- Add `win:style_pos()` for styling a specific window cell.\n- Add `UI_DRAW` event for last minute changes to the drawn window.\n- Report viewport dimensions\n\n### Misc\n\n- Add a basic .editorconfig file\n- Don't set _FORTIFY_SOURCE in configure\n- Many documentation improvements.\n- Make vis-open and vis-complete more POSIX compliant\n- vis-clipboard: clean up bashisms and make shellcheck happy.\n- vis-clipboard: add support for wayclip\n- vis-open: allow to show files vertically\n\n### Bugfixes\n\n- fix warning by dealing with error value from fchdir in text-io.c\n- text-io: close \"cwd\" in all cases\n- vis-complete: Fix commandline options handling\n- vis-clipboard: make xsel honor --selection\n- wl-paste and wl-copy should not add \\n to the end of the clipboard.\n- fix a bug with using regex to close windows (i.e. `:X/re/q`)\n- Limit to lines within range for inner text objects\n- vis-clipboard: don't fail when sel is primary on unsupported platforms\n- fix { moving back too much if cursor is at start of a line\n- Print keybindings containing space correctly in help window\n- Prevent flickering in curses\n- vis-menu: try to preserve valid Unicode points\n- lua: make sure lpeg is in fact optional\n- vis-single: respect TMPDIR\n- lua: fail when mapping a key to an invalid handler type\n- vis_pipe: correctly return non-zero exit status\n- view: skip empty cells before applying a style\n- sam: reject invalid ranges for cmd_extract (\"x\"/\"y\")\n- Fix upper/lower case conversions with `gU` and `gu`.\n- lua: complete-word: use internal regex for splitting words\n- Theme application was refactored and should be more consistent now.\n\n### Deprecation Notices\n\nThe option names `show-spaces`, `show-tabs`, `show-newlines`,\n`show-eof`, and `change-256colors` are all deprecated and will be\nremoved for the next release, use the name without the `-` instead\n(e.g. showeof). This was done to avoid inconsistencies between the\nlua option names and the `:set option` names.\n\nThe complete changelog can be viewed using `git log v0.8..v0.9`.\n\n## [0.8] - 2022-11-01\n\nThis is a release of vis as it has been for more than a year\nbefore some development started up again. We're releasing this\nversion to get a stable 'old' release out there which should\nstill contain a number of bugfixes compared to 0.7.\n\n- build: add git based version information back\n- lexers: fix bug in bash lexer for last here-doc\n- vis: make O implementation independent of mapping\n- fix typos in comments\n- lua: fix luacheck warnings\n- vis: rename to/till motion internals\n- vis: implement multiline to/till motions\n- vis-lua: provide file.permission property\n- Mention pkg-config in README\n- lexers/strace: improve comments, field names and syscall\n  results\n- lexers/git-rebase: also highlight break command\n- filetype: Set \"bash\" for APKBUILD and .ebuild.\n- filetype: Detect make shebang for \"makefile\".\n- Adding .sv extension to verilog syntax highlighter\n- build: update alpine in docker build to version 3.13\n- sam: only skip the last empty match if it follows a newline\n- sam: produce empty match at the end of looped range\n- test: update\n- gitignore: remove vim specific swap files\n- sam: tweak handling of zero length matches in y commands\n- sam: simplify trailing match handling for x/y commands\n- vis: correctly close pipe connected to stdin of external\n  process\n- add lua5.4 in configure script\n- vis: Add readline Ctrl+A/E bindings\n- ci: verify codecov script before using it\n- ci: verify coverity scan script before using it\n- filetype: Set \"groovy\" for Jenkinsfile\n\n\n## [0.7.1] README: x/freenode/c/libera/ - 2022-05-03\n\n- Update the README to point to irc.libera.chat after the great\n  migration of 2021.\n\n\n## [0.7] vis version 0.7 - 2020-12-08\n\nThis is mostly a bug fix release with\n[fixes for a few cases of undefined behavior](https://www.brain-dump.org/blog/finding-undefined-behavior-in-c-code/)\nand preliminary work for experimentation with different\n[core text management data structures](https://www.brain-dump.org/blog/rethinking-vis-text-management-data-structure/)\nand\n[general editor architecture](https://www.brain-dump.org/blog/vis-to-server-or-not/).\n\n- fix UB in core text management data structure\n- text refactoring, splitting out reusable text iterator and I/O\n  components\n- new `*at()` variants taking directory descriptor for file\n  load/save API\n- more efficient initial file read, avoiding spurious syscalls\n  and copy\n- text API cleanups, const correctness improvements\n- increased test coverage for core text data structure\n- support for Lua 5.4\n- Lua API improvements: `vis.mark`, `vis.register`,\n  `vis.win.file.modified` and support for terminal CSI events\n- NetBSD support\n- new `:set ignorecase` option to search case independently\n- new visual mode mapping `<C-a>` to select all matching\n  selections\n- fix mappings involving non-leading `<C-c>`\n- minor file detection fixes for racket, node.js modules,\n  Typescript and liliypond\n- new lexers for Zig, meson build system, Mikrotik RouterOS\n  scripts, Gemini\n- improved inner word text object and its use for `<C-n>` in\n  normal mode\n- improved `<C-n>` behavior in visual mode\n- removed `ie`, `ae` inner/outer entire text object, use `:`, as\n  shorthand for `:0,$`.\n- removed pariwise selection combinators `z>`, `z<`, `z-`, `z+`,\n  `z&`, `z|`\n- remove `~` as alias for `g~`\n- use `~` instead of `!` for selection complement\n- remove special key and window related aliases\n- `vis-open(1)` adds a trailing slash to indicate folders\n- add primary clipboard support to `vis-clipboard(1)`\n- support wayland clipboard using `wl-clipboard(1)`\n- new Makefile targets: `distclean`, `testclean`\n\n\n## [0.6] vis version 0.6 - 2020-06-07\n\n- bounded time syntax highlighting using the `:set redrawtime`\n  option\n- support optional count for sam's text commands e.g. `:i3/-/`\n- make `<C-n>` in visual mode match next occurence of existing\n  selection\n- warn when attempting to write to an existing file\n- improved file change detection based on inode instead of path\n  information\n- fix file saves with modifications in file pre-save events\n- fix save on file systems without `fsync(2)` support on\n  directory descriptors\n- do not unlink `file~` when saving `file`\n- introduce distinct `vis-menu(1)` exit codes\n- modify Lua package.path to include <plugin>/init.lua\n- performance improvements for the HTML, XML and YAML lexers\n- new Julia and Elm lexers, better defaults for standard text\n  lexer\n- support optional exit status in `:q` and `:qall` commands\n- better temporary file creation using `mkstemp(2)`\n- performance improvements in highlight matching parentheses\n- improved behavior of `^` and `$` in searches and looping\n  commands\n- improved search wrap around behavior\n- new `:set layout` option to specify window orientation\n- improved filetype detection by matching known filenames exactly\n- support DragonFly BSD in configure script\n- better manual page, fixed warnings\n- removed `gp`, `gP`, `gq`\n- implement `g~`, `gu` and `gU` using `tr(1)`, they are no longer\n  operators\n- removed `v` and `V` in operator pending mode\n- avoid crash if `$TERM` is unset\n- keep selections after `:>` command\n- normalize selections after `:` command execution\n- show pending input queue content in status bar\n- make `r<Enter>` insert a new line\n- new `:set loadmethod` option, valid values are `read`, `mmap`\n  or `auto`\n- always apply `:|` command to existing selections\n- fix terminal UI on serial console\n- various code cleanups, removal of VLA\n- <Escape> resets count, if applicable\n- fix `:X` and `:Y` commands which were interchanged\n- don't strip executables by default, provide install-strip\n  target\n\n\n## [0.5] vis version 0.5 - 2018-03-25\n\n- Fix for a buffer overflow when dealing with invalid/incomplete\n  Unicode sequences which caused an infinite loop/crash. With\n  default compilation flags this should not be exploitable, but\n  opening a malicious file would lose all unsaved changes.\n- Fix color support in ncurses 6.1\n- New default 256 color theme: zenburn. It should hopefully work\n  better with the default color palette.\n- Updated Docker based builds (`make docker`) to use latest\n  Alpine Linux packages to produce a statically linked,\n  self-contained binary.\n- Take symbolic keys into account when evaluating key prefixes\n  (`ci<` is not a prefix of `ci<Tab>`).\n- Improved paragraph text objects.\n- Reset count after handling ,\n- Lexer updates for Clojure, Scheme, ASM, Pony, PHP, Python,\n  Erlang, xs and ReasonML.\n- Correct handling of `g/^$/` construct to match empty lines in\n  commands like:\n\n    x g/^$/ d\n\n- `<C-v><Enter>` now inserts `\\r` rather than `\\n`, this\n  currently also affects `r<Enter>` which might not be desirable.\n- Fix command prompt malfunction triggered by special cursor position.\n- Configure script can be interrupted.\n- Removed `!` operator, use `:|`\n- Ignore `SIGQUIT`\n- `vis-open(1)` fixes\n\n\n## [0.4] vis version 0.4 - 2017-07-23\n\n- Selections as core editing primitives. Cursors have been superseded by singleton selections. Overlapping selections are now merged. This change is also reflected in the exposed Lua API (for which still no stability guarantee is given).\n\n- Selections can be saved into marks on which set operations can be performed:\n\n  `m` save selections\\\n  `M` restore selections\\\n  `|` set union\\\n  `&` set intersection\\\n  `\\` set minus\\\n  `!` set complement\\\n  `z|` pairwise union\\\n  `z&` pairwise intersection\\\n  `z+` pairwise combine, choose longer\\\n  `z-` pairwise combine, choose shorter\\\n  `z<` pairwise combine, choose leftmost\\\n  `z>` pairwise combine, choose rightmost\n\n  Marks are specified using `'{mark}` analogous to `\"{register}`.\n\n- Jump list based on marks:\n\n  `g<` jump backward\\\n  `g>` jump forward\\\n  `gs` save currently active selections\n\n- New register `#` to insert the current selection number.\n- Drop special handling of `\\r\\n` line endings. `\\r` will be\n  displayed as `^M`. Enter will always insert `\\n`.\n- Fix Unicode regex search with libtre backend.\n- New count specifiers for sam's `g` and `v` commands to\n  keep/drop selections based on their index.\n- On macOS saving files larger than INT_MAX bytes should work.\n- New `:set show-eof` to toggle the display of end of file markers ~\n  as before it is enabled by default.\n- Double leading slashes of paths are stripped.\n- Improved `:<` command implementation to only use a pipe when\n  necessary.\n- New lexers for Myrddin and `strace(1)`, updates for Elixir, Perl\n  and Forth.\n- Fix compilation for GNU Hurd. The vis package is now built for\n  all supported Debian architectures.\n- Improve job control of forked processes. SIGINT is now properly\n  delivered to child processes.\n- Commands given a huge count can now be interrupted using `.`\n- This is implemented in cooperative fashion, meaning a single\n  long running operation can still not be interrupted.\n- More efficient line wise motions based on optimized\n  `mem{r,}chr(3)` libc functions.\n- Optionally support vim compatible n/N search direction.\n- Reproducible, statically linked, self contained binary built\n  using the Alpine Docker image. The idea being that it is a\n  single file which can be copied to any Linux >= 2.6 system to\n  provide a usable editor. It has an embedded tar archive which\n  contains the required Lua support files which are extracted to\n  a temporary directory using libuntar.\n- Preliminary C API documentation found at: http://vis.rtfd.io\n- Updated manual page.\n- Various code cleanups.\n\nCheck the git log for further details.\n\nThe release tarball is signed with [OpenBSD's signify\ntool](http://man.openbsd.org/signify), the signature\n\n    untrusted comment: verify with vis.pub\n    RWRbDa94LCndL/v7m45zQw4saMKs5AsnTKBsvvFujZbAi9CIhlyiz0fihaWYbHkWDO957Csn5yJvecac+iUxX7arQ5IxZ4XRcQE=\n\ncan be verified using the following public key:\n\n    untrusted comment: vis editor signify public key\n    RWRbDa94LCndLy4pUdO6h1PmS1ooHOGb7p84OfQIR7+hFlZwuAXUdQ5J\n\n\n## [0.3] vis version 0.3 - 2017-03-26\n\nMost notable changes include:\n\n- support for sam's structural regular expression based command language\n- various bug fixes related to multiple cursor/selection support. New\n  functionality to navigate among cursors (`<C-u>`, `<C-d>`), align\n  (`<Tab>`, `<S-Tab>`), rotate (`+`, `-`), trim (`\\`) or drop\n  (`<C-c>`, `<C-l>`) selections.\n- improved Lua API, featuring a new event subscription mechanism and the\n  possibility to define custom operators, motions, text-objects, `:set`\n  options and more. Notice however that at this point no API stability\n  guarantee is provided.\\\n  You might have to update your `visrc.lua` configuration file, check the\n  Documentation for details:\n  http://martanne.github.io/vis/doc/\n- new standalone tools vis-menu (`:o .`), vis-digraph (`<C-k>`) and\n  vis-complete (`<C-k>`) for a simple file open dialog, digraph support\n  and word completion, respectively.\n- multiple bug fixes for vi(m) functionality, including improved count\n  and repeat handling as well as better cursor positioning, `cw`, shift,\n  join and autoindent implementation.\n- new key mapping processing based on longest unique match\n- optional libtre based regex backend for more memory efficient\n  forward searches\n- respect umask when creating new files, previously they were only\n  read/writable by the current user. Also `fsync(2)` destination\n  directory after `rename(2)` when performing an atomic save operation.\n- new `:set` options to configure the used shell, escape\n  delay, file save method and context to consider for syntax\n  highlighting\n- True color support in lexer themes, in case the terminal\n  supports color palette changes\n- minimal built-in `:help [pattern]` command\n- incorporated upstream changes to LPeg based lexers used for syntax\n  highlighting from the Scintillua project\n- new set of manual pages in mdoc format\n- experimental raw vt100 UI backend for resource constraint environments\n- various code cleanups and bug fixes reported by static analysis, runtime\n  interpretation and fuzzing tools\n\nCheck the git log for further details.\n\nThe release tarball is signed with [OpenBSD's signify\ntool](http://man.openbsd.org/signify), the signature can be\nverified using the following public key:\n\n    untrusted comment: vis editor signify public key\n    RWRbDa94LCndLy4pUdO6h1PmS1ooHOGb7p84OfQIR7+hFlZwuAXUdQ5J\n\n## [0.2] vis version 0.2 - 2016-03-25\n\nno changelog, 240 commits between v0.1 and v0.2 tags.\n\n## [0.1] vis version 0.1 - 2015-12-31\n\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.978515625,
          "content": "# Run 'make docker' to build a statically linked vis executable!\nFROM i386/alpine:3.21\nRUN apk update && apk add --upgrade --no-cache \\\n\tacl-dev \\\n\tacl-static \\\n\tca-certificates \\\n\tfortify-headers \\\n\tgcc \\\n\tlibtermkey-dev \\\n\tlua5.3-dev \\\n\tlua5.3-lpeg \\\n\tlua-lpeg-dev \\\n\tmake \\\n\tmusl-dev \\\n\tncurses-dev \\\n\tncurses-static \\\n\ttar \\\n\twget \\\n\txz \\\n\txz-dev \\\n\txz-static\nRUN sed -i 's/Libs: /Libs: -L${INSTALL_CMOD} /' /usr/lib/pkgconfig/lua5.3.pc\nRUN mv /usr/lib/lua/5.3/lpeg.a /usr/lib/lua/5.3/liblpeg.a\nRUN sed -i 's/-ltermkey/-ltermkey -lunibilium/' /usr/lib/pkgconfig/termkey.pc\n# TODO contribute a proper libuntar package to Alpine\nRUN mkdir -p /build\nWORKDIR /build\nRUN wget https://github.com/martanne/libuntar/tarball/7c7247b442b021588f6deba78b60ef3b05ab1e0c -O libuntar.tar.gz && \\\n\ttar xf libuntar.tar.gz && cd *-libuntar-* && \\\n\tmake && \\\n\tmkdir -p /usr/local/include && \\\n\tcp lib/libuntar.h /usr/local/include && \\\n\tcp lib/libuntar.a /usr/local/lib && \\\n\trm -rf /build/*libuntar*\nCMD [\"/bin/sh\"]\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 3.6162109375,
          "content": "include Makefile\n\nLIBTERMKEY = libtermkey-0.22\nLIBTERMKEY_SHA256 = 6945bd3c4aaa83da83d80a045c5563da4edd7d0374c62c0d35aec09eb3014600\n\nLIBLUA = lua-5.3.4\nLIBLUA_SHA256 = f681aa518233bc407e23acf0f5887c884f17436f000d453b2491a9f11a52400c\n#LIBLUA = lua-5.2.4\n#LIBLUA_SHA256 = b9e2e4aad6789b3b63a056d442f7b39f0ecfca3ae0f1fc0ae4e9614401b69f4b\n#LIBLUA = lua-5.1.5\n#LIBLUA_SHA256 = 2640fc56a795f29d28ef15e13c34a47e223960b0240e8cb0a82d9b0738695333\n\nLIBLPEG = lpeg-1.0.2\nLIBLPEG_SHA256 = 48d66576051b6c78388faad09b70493093264588fcd0f258ddaab1cdd4a15ffe\n\nSRCDIR = $(realpath $(dir $(firstword $(MAKEFILE_LIST))))\n\nDEPS_ROOT = $(SRCDIR)/dependency/install\nDEPS_PREFIX = $(DEPS_ROOT)/usr\nDEPS_BIN = $(DEPS_PREFIX)/bin\nDEPS_LIB = $(DEPS_PREFIX)/lib\nDEPS_INC = $(DEPS_PREFIX)/include\n\ndependency/build:\n\tmkdir -p \"$@\"\n\ndependency/sources:\n\tmkdir -p \"$@\"\n\n# LIBTERMKEY\n\ndependency/sources/libtermkey-%: | dependency/sources\n\twget -c -O $@.part http://www.leonerd.org.uk/code/libtermkey/$(LIBTERMKEY).tar.gz\n\tmv $@.part $@\n\t[ -z $(LIBTERMKEY_SHA256) ] || (echo '$(LIBTERMKEY_SHA256)  $@' | sha256sum -c)\n\ndependency/build/libtermkey-extract: dependency/sources/$(LIBTERMKEY).tar.gz | dependency/build\n\ttar xzf $< -C $(dir $@)\n\ttouch $@\n\ndependency/build/libtermkey-build: dependency/build/libtermkey-extract\n\t# TODO no sane way to avoid pkg-config and specify LDFLAGS?\n\tsed -i 's/LDFLAGS+=-lncurses$$/LDFLAGS+=-lncursesw/g' $(dir $<)/$(LIBTERMKEY)/Makefile\n\t$(MAKE) -C $(dir $<)/$(LIBTERMKEY) PREFIX=/usr termkey.h libtermkey.la\n\ttouch $@\n\ndependency/build/libtermkey-install: dependency/build/libtermkey-build\n\t$(MAKE) -C $(dir $<)/$(LIBTERMKEY) PREFIX=/usr DESTDIR=$(DEPS_ROOT) install-inc install-lib\n\ttouch $@\n\n# LIBLUA\n\ndependency/sources/lua-%.tar.gz: | dependency/sources\n\twget -c -O $@.part http://www.lua.org/ftp/$(LIBLUA).tar.gz\n\tmv $@.part $@\n\t[ -z $(LIBLUA_SHA256) ] || (echo '$(LIBLUA_SHA256)  $@' | sha256sum -c)\n\ndependency/build/liblua-extract: dependency/sources/$(LIBLUA).tar.gz | dependency/build\n\ttar xzf $< -C $(dir $@)\n\ttouch $@\n\ndependency/build/liblua-build: dependency/build/liblua-extract\n\t$(MAKE) -C $(dir $<)/$(LIBLUA)/src all CC=$(CC) MYCFLAGS=\"-DLUA_COMPAT_5_1 -DLUA_COMPAT_5_2 -DLUA_COMPAT_ALL -DLUA_USE_POSIX -DLUA_USE_DLOPEN -fPIC\" MYLIBS=\"-Wl,-E -ldl -lm\"\n\t#$(MAKE) -C $(dir $<)/$(LIBLUA) posix CC=$(CC)\n\ttouch $@\n\ndependency/build/liblua-install: dependency/build/liblua-build\n\t$(MAKE) -C $(dir $<)/$(LIBLUA) INSTALL_TOP=$(DEPS_PREFIX) install\n\ttouch $@\n\n# LIBLPEG\n\ndependency/sources/lpeg-%: | dependency/sources\n\twget -c -O $@.part http://www.inf.puc-rio.br/~roberto/lpeg/$(LIBLPEG).tar.gz\n\tmv $@.part $@\n\t[ -z $(LIBLPEG_SHA256) ] || (echo '$(LIBLPEG_SHA256)  $@' | sha256sum -c)\n\ndependency/build/liblpeg-extract: dependency/sources/$(LIBLPEG).tar.gz | dependency/build\n\ttar xzf $< -C $(dir $@)\n\ttouch $@\n\ndependency/build/liblpeg-build: dependency/build/liblpeg-extract dependency/build/liblua-extract\n\t# creating a shared object fails in Cygwin, we do not need it thus ignore the error\n\tcd $(dir $<)/$(LIBLPEG) && $(MAKE) LUADIR=\"../$(LIBLUA)/src\" || true\n\tcd $(dir $<)/$(LIBLPEG) && ar rcu liblpeg.a lpvm.o lpcap.o lptree.o lpcode.o lpprint.o && ranlib liblpeg.a\n\ttouch $@\n\ndependency/build/liblpeg-install: dependency/build/liblpeg-build\n\tcd $(dir $<)/$(LIBLPEG) && cp liblpeg.a $(DEPS_LIB)\n\ttouch $@\n\ndependency/build/local: dependency/build/libtermkey-install dependency/build/liblua-install dependency/build/liblpeg-install\n\ttouch $@\n\nlocal: clean\n\t./configure --environment-only\n\t$(MAKE) dependency/build/local\n\t./configure CFLAGS=\"-I$(DEPS_INC)\" LDFLAGS=\"-L$(DEPS_LIB)\" LD_LIBRARY_PATH=\"$(DEPS_LIB)\"\n\t$(MAKE)\n\t@echo Run with: LD_LIBRARY_PATH=$(DEPS_LIB) ./vis\n\n.PHONY: local\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.8427734375,
          "content": "vis as a whole is licensed under the following standard ISC license:\n\n Copyright © 2014-2020 Marc André Tanner, et al.\n\n Permission to use, copy, modify, and/or distribute this software for any\n purpose with or without fee is hereby granted, provided that the above\n copyright notice and this permission notice appear in all copies.\n\n THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nPortions of this software are derived from third-party works licensed\nunder terms compatible with the above ISC license:\n\n - ./configure is based on the corresponding script from the musl libc\n   project and is MIT licensed\n\n - map.[ch] originate from the Comprehensive C Archive Network strmap\n   module and are public domain / CC0 licensed\n\n - libutf.[ch] originate from libutf a port of Plan 9's Unicode library\n   to Unix and are MIT licensed\n\n - sam.[ch] is heavily inspired (and partially based upon) the X11\n   version of Rob Pike's sam text editor originally written for Plan 9\n   and distributed under an ISC-like license\n\n - lua/lexers/* the LPeg based lexers used for syntax highlighting are\n   imported from the Scintillua project licensed under the MIT license\n\nCheck the individual source files for more specific copyright information.\n\nDetails on authorship of individual files can be found in the git version\ncontrol history of the project. The omission of copyright and license\ncomments in each file is in the interest of source tree size.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 6.455078125,
          "content": "-include config.mk\n\nREGEX_SRC ?= text-regex.c\n\nSRC = array.c \\\n\tbuffer.c \\\n\tevent-basic.c \\\n\tlibutf.c \\\n\tmain.c \\\n\tmap.c \\\n\tsam.c \\\n\ttext-common.c \\\n\ttext-io.c \\\n\ttext-iterator.c \\\n\ttext-motions.c \\\n\ttext-objects.c \\\n\ttext-util.c \\\n\ttext.c \\\n\tui-terminal.c \\\n\tview.c \\\n\tvis-lua.c \\\n\tvis-marks.c \\\n\tvis-modes.c \\\n\tvis-motions.c \\\n\tvis-operators.c \\\n\tvis-prompt.c \\\n\tvis-registers.c \\\n\tvis-subprocess.c \\\n\tvis-text-objects.c \\\n\tvis.c \\\n\t$(REGEX_SRC)\nOBJ = $(SRC:%.c=obj/%.o)\n\nELF = vis vis-menu vis-digraph\nEXECUTABLES = $(ELF) vis-clipboard vis-complete vis-open\n\nMANUALS = $(EXECUTABLES:=.1)\n\nDOCUMENTATION = LICENSE README.md\n\nVERSION = $(shell git describe --always --dirty 2>/dev/null || echo \"v0.9-git\")\n\nCONFIG_HELP ?= 1\nCONFIG_CURSES ?= 1\nCONFIG_LUA ?= 1\nCONFIG_LPEG ?= 0\nCONFIG_TRE ?= 0\nCONFIG_ACL ?= 0\nCONFIG_SELINUX ?= 0\n\nCFLAGS_STD ?= -std=c99 -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700 -DNDEBUG -MMD\nCFLAGS_STD += -DVERSION=\\\"${VERSION}\\\"\nLDFLAGS_STD ?= -lc\n\nCFLAGS_LIBC ?= -DHAVE_MEMRCHR=0\n\nCFLAGS_VIS = $(CFLAGS_AUTO) $(CFLAGS_TERMKEY) $(CFLAGS_CURSES) $(CFLAGS_ACL) \\\n\t$(CFLAGS_SELINUX) $(CFLAGS_TRE) $(CFLAGS_LUA) $(CFLAGS_LPEG) $(CFLAGS_STD) \\\n\t$(CFLAGS_LIBC)\n\nCFLAGS_VIS += -DVIS_PATH=\\\"${SHAREPREFIX}/vis\\\"\nCFLAGS_VIS += -DCONFIG_HELP=${CONFIG_HELP}\nCFLAGS_VIS += -DCONFIG_CURSES=${CONFIG_CURSES}\nCFLAGS_VIS += -DCONFIG_LUA=${CONFIG_LUA}\nCFLAGS_VIS += -DCONFIG_LPEG=${CONFIG_LPEG}\nCFLAGS_VIS += -DCONFIG_TRE=${CONFIG_TRE}\nCFLAGS_VIS += -DCONFIG_SELINUX=${CONFIG_SELINUX}\nCFLAGS_VIS += -DCONFIG_ACL=${CONFIG_ACL}\n\nLDFLAGS_VIS = $(LDFLAGS_AUTO) $(LDFLAGS_TERMKEY) $(LDFLAGS_CURSES) $(LDFLAGS_ACL) \\\n\t$(LDFLAGS_SELINUX) $(LDFLAGS_TRE) $(LDFLAGS_LUA) $(LDFLAGS_LPEG) $(LDFLAGS_STD)\n\nSTRIP?=strip\nTAR?=tar\nDOCKER?=docker\n\nall: $(ELF)\n\nconfig.h:\n\tcp config.def.h config.h\n\nconfig.mk:\n\t@touch $@\n\nobj/.tstamp:\n\tmkdir obj\n\ttouch obj/.tstamp\n\nobj/main.o: config.h\n\n$(OBJ): config.mk obj/.tstamp\n\t${CC} ${CFLAGS} ${CFLAGS_VIS} ${CFLAGS_EXTRA} -o $@ -c $(@:obj/%.o=%.c)\n\n-include obj/*.d\n\nvis: ${OBJ}\n\t${CC} -o $@ ${OBJ} ${LDFLAGS} ${LDFLAGS_VIS} ${LDFLAGS_EXTRA}\n\nvis-menu: vis-menu.c\n\t${CC} ${CFLAGS} ${CFLAGS_AUTO} ${CFLAGS_STD} ${CFLAGS_EXTRA} $< ${LDFLAGS} ${LDFLAGS_STD} ${LDFLAGS_AUTO} ${LDFLAGS_EXTRA} -o $@\n\nvis-digraph: vis-digraph.c\n\t${CC} ${CFLAGS} ${CFLAGS_AUTO} ${CFLAGS_STD} ${CFLAGS_EXTRA} $< ${LDFLAGS} ${LDFLAGS_STD} ${LDFLAGS_AUTO} ${LDFLAGS_EXTRA} -o $@\n\nvis-single-payload.inc: $(EXECUTABLES) lua/*\n\tfor e in $(ELF); do \\\n\t\t${STRIP} \"$$e\"; \\\n\tdone\n\techo '#ifndef VIS_SINGLE_PAYLOAD_H' > $@\n\techo '#define VIS_SINGLE_PAYLOAD_H' >> $@\n\techo 'static unsigned char vis_single_payload[] = {' >> $@\n\t$(TAR) --mtime='2014-07-15 01:23Z' --owner=0 --group=0 --numeric-owner --mode='a+rX-w' -c \\\n\t\t$(EXECUTABLES) $$(find lua -name '*.lua' | LC_ALL=C sort) | xz -T 1 | \\\n\t\tod -t x1 -A n -v | sed 's/\\([0-9a-f]\\{2\\}\\)/0x\\1,/g' >> $@\n\techo '};' >> $@\n\techo '#endif' >> $@\n\nvis-single: vis-single.c vis-single-payload.inc\n\t${CC} ${CFLAGS} ${CFLAGS_AUTO} ${CFLAGS_STD} ${CFLAGS_EXTRA} $< ${LDFLAGS} ${LDFLAGS_STD} ${LDFLAGS_AUTO} -luntar -llzma -o $@\n\t${STRIP} $@\n\ndocker-kill:\n\t-$(DOCKER) kill vis && $(DOCKER) wait vis\n\ndocker: docker-kill clean\n\t$(DOCKER) build -t vis .\n\t$(DOCKER) run --rm -d --name vis vis tail -f /dev/null\n\t$(DOCKER) exec vis apk update\n\t$(DOCKER) exec vis apk upgrade\n\t$(DOCKER) cp . vis:/build/vis\n\t$(DOCKER) exec -w /build/vis vis ./configure CC='cc --static' \\\n\t\t--enable-acl \\\n\t\t--enable-lua \\\n\t\t--enable-lpeg-static\n\t$(DOCKER) exec -w /build/vis vis make VERSION=\"$(VERSION)\" clean vis-single\n\t$(DOCKER) cp vis:/build/vis/vis-single vis\n\t$(DOCKER) kill vis\n\ndocker-clean: docker-kill clean\n\t-$(DOCKER) image rm vis\n\ndebug: clean\n\t@$(MAKE) CFLAGS_EXTRA='${CFLAGS_EXTRA} ${CFLAGS_DEBUG}'\n\nprofile: clean\n\t@$(MAKE) CFLAGS_AUTO='' LDFLAGS_AUTO='' CFLAGS_EXTRA='-pg -O2'\n\ncoverage: clean\n\t@$(MAKE) CFLAGS_EXTRA='--coverage' LDFLAGS_EXTRA='--coverage'\n\ntest:\n\t@$(MAKE) -C test\n\ntestclean:\n\t@echo cleaning the test artifacts\n\t[ ! -e test/Makefile ] || $(MAKE) -C test clean\n\nclean:\n\t@echo cleaning\n\t@rm -rf obj\n\t@rm -f $(ELF) vis-single vis-single-payload.inc vis-*.tar.gz *.gcov *.gcda *.gcno *.d\n\ndistclean: clean testclean\n\t@echo cleaning build configuration\n\t@rm -f config.h config.mk\n\ndist: distclean\n\t@echo creating dist tarball\n\t@git archive --prefix=vis-${VERSION}/ -o vis-${VERSION}.tar.gz HEAD\n\nman:\n\t@for m in ${MANUALS}; do \\\n\t\techo \"Generating $$m\"; \\\n\t\tsed -e \"s/VERSION/${VERSION}/\" \"man/$$m\" | mandoc -W warning -T utf8 -T html -O man=%N.%S.html -O style=mandoc.css 1> \"man/$$m.html\" || true; \\\n\tdone\n\nluadoc:\n\t@cd lua/doc && ldoc . && sed -e \"s/RELEASE/${VERSION}/\" -i index.html\n\nluadoc-all:\n\t@cd lua/doc && ldoc -a . && sed -e \"s/RELEASE/${VERSION}/\" -i index.html\n\nluacheck:\n\t@luacheck --config .luacheckrc lua test/lua | less -RFX\n\ninstall: $(ELF)\n\t@echo installing executable files to ${DESTDIR}${PREFIX}/bin\n\t@mkdir -p ${DESTDIR}${PREFIX}/bin\n\t@for e in ${EXECUTABLES}; do \\\n\t\tcp -f \"$$e\" ${DESTDIR}${PREFIX}/bin && \\\n\t\tchmod 755 ${DESTDIR}${PREFIX}/bin/\"$$e\"; \\\n\tdone\n\t@test ${CONFIG_LUA} -eq 0 || { \\\n\t\techo installing support files to ${DESTDIR}${SHAREPREFIX}/vis; \\\n\t\tmkdir -p ${DESTDIR}${SHAREPREFIX}/vis; \\\n\t\tcp -r lua/* ${DESTDIR}${SHAREPREFIX}/vis; \\\n\t\trm -rf \"${DESTDIR}${SHAREPREFIX}/vis/doc\"; \\\n\t}\n\t@echo installing documentation to ${DESTDIR}${DOCPREFIX}/vis\n\t@mkdir -p ${DESTDIR}${DOCPREFIX}/vis\n\t@for d in ${DOCUMENTATION}; do \\\n\t\tcp \"$$d\" ${DESTDIR}${DOCPREFIX}/vis && \\\n\t\tchmod 644 \"${DESTDIR}${DOCPREFIX}/vis/$$d\"; \\\n\tdone\n\t@echo installing manual pages to ${DESTDIR}${MANPREFIX}/man1\n\t@mkdir -p ${DESTDIR}${MANPREFIX}/man1\n\t@for m in ${MANUALS}; do \\\n\t\tsed -e \"s/VERSION/${VERSION}/\" < \"man/$$m\" >  \"${DESTDIR}${MANPREFIX}/man1/$$m\" && \\\n\t\tchmod 644 \"${DESTDIR}${MANPREFIX}/man1/$$m\"; \\\n\tdone\n\ninstall-strip: install\n\t@echo stripping executables\n\t@for e in $(ELF); do \\\n\t\t${STRIP} ${DESTDIR}${PREFIX}/bin/\"$$e\"; \\\n\tdone\n\nuninstall:\n\t@echo removing executable file from ${DESTDIR}${PREFIX}/bin\n\t@for e in ${EXECUTABLES}; do \\\n\t\trm -f ${DESTDIR}${PREFIX}/bin/\"$$e\"; \\\n\tdone\n\t@echo removing documentation from ${DESTDIR}${DOCPREFIX}/vis\n\t@for d in ${DOCUMENTATION}; do \\\n\t\trm -f ${DESTDIR}${DOCPREFIX}/vis/\"$$d\"; \\\n\tdone\n\t@echo removing manual pages from ${DESTDIR}${MANPREFIX}/man1\n\t@for m in ${MANUALS}; do \\\n\t\trm -f ${DESTDIR}${MANPREFIX}/man1/\"$$m\"; \\\n\tdone\n\t@echo removing support files from ${DESTDIR}${SHAREPREFIX}/vis\n\t@rm -rf ${DESTDIR}${SHAREPREFIX}/vis\n\n.PHONY: all clean testclean dist distclean install install-strip uninstall debug profile coverage test test-update luadoc luadoc-all luacheck man docker-kill docker docker-clean\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.00390625,
          "content": "# Vis - Combining Modal Editing with Structural Regular Expressions\n\n[![Development discussion](https://img.shields.io/badge/email-~martanne%2Fdevel-black?logo=sourcehut)](https://lists.sr.ht/~martanne/devel)\n[![builds.sr.ht status](https://builds.sr.ht/~martanne/vis/commits.svg)](https://builds.sr.ht/~martanne/vis/commits?)\n[![Coverity Scan Build Status](https://scan.coverity.com/projects/3939/badge.svg)](https://scan.coverity.com/projects/3939)\n[![codecov](https://codecov.io/gh/martanne/vis/branch/master/graph/badge.svg)](https://codecov.io/gh/martanne/vis)\n[![Documentation Status](https://readthedocs.org/projects/vis/badge/?version=master)](http://vis.readthedocs.io/en/master/?badge=master)\n[![#vis-editor on libera](https://img.shields.io/badge/IRC-%23vis--editor-blue?logo=libera.chat)](ircs://irc.libera.chat:6697/vis-editor)\n\nVis aims to be a modern, legacy-free, simple yet efficient editor,\ncombining the strengths of both vi(m) and sam.\n\nIt extends vi's modal editing with built-in support for multiple\ncursors/selections and combines it with [sam's](http://sam.cat-v.org/)\n[structural regular expression](http://doc.cat-v.org/bell_labs/structural_regexps/)\nbased [command language](http://doc.cat-v.org/bell_labs/sam_lang_tutorial/).\n\nA universal editor, it has decent Unicode support and should cope with arbitrary\nfiles, including large, binary or single-line ones.\n\nEfficient syntax highlighting is provided using\n[Parsing Expression Grammars](https://en.wikipedia.org/wiki/Parsing_expression_grammar),\nwhich can be conveniently expressed using [Lua](http://www.lua.org/)\nin the form of [LPeg](http://www.inf.puc-rio.br/~roberto/lpeg/).\n\nThe editor core is written in a reasonable amount of clean (your mileage\nmay vary), modern and legacy-free C code, enabling it to run in\nresource-constrained environments. The implementation should be easy to hack on\nand encourages experimentation. There is also a Lua API for in-process\nextensions.\n\nVis strives to be *simple* and focuses on its core task: efficient text\nmanagement. Clipboard and digraph handling as well as a fuzzy file open\ndialog are all provided by independent utilities. There exist plans to use\na client/server architecture, delegating window management to your windowing\nsystem or favorite terminal multiplexer.\n\nThe intention is *not* to be bug-for-bug compatible with vi(m). Instead,  \nwe aim to provide more powerful editing features based on an elegant design\nand clean implementation.\n\n[![vis demo](https://asciinema.org/a/41361.png)](https://asciinema.org/a/41361)\n\nBuild instructions\n------------------\n\nIn order to build vis you will need a\n[C99](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)\ncompiler, a [POSIX.1-2008](http://pubs.opengroup.org/onlinepubs/9699919799/)\ncompatible environment as well as:\n\n * [libtermkey](http://www.leonerd.org.uk/code/libtermkey/)\n * [curses](https://en.wikipedia.org/wiki/Curses_(programming_library)) (recommended)\n * [Lua](http://www.lua.org/) >= 5.2 (optional)\n * [LPeg](http://www.inf.puc-rio.br/~roberto/lpeg/) >= 0.12\n   (optional runtime dependency required for syntax highlighting)\n * [TRE](http://laurikari.net/tre/) (optional for more memory efficient regex search)\n\nAssuming these dependencies are met, execute:\n\n    $ ./configure && make && sudo make install\n\nBy default the `configure` script will try to auto detect support for\nLua using `pkg-config(1)`. See `configure --help` for a list of supported\noptions. You can also manually tweak the generated `config.mk` file.\n\nOr simply use one of the\n[distribution provided packages](https://github.com/martanne/vis/wiki/Distribution-Packages).\n\nDocumentation\n-------------\n\nEnd user documentation can be found in the\n[`vis(1)` manual page](http://martanne.github.io/vis/man/vis.1.html)\nand the [Wiki](https://github.com/martanne/vis/wiki). Read the\n[FAQ](https://github.com/martanne/vis/wiki/FAQ) for common questions.\nLearn about some differences compared to\n[`sam(1)`](https://github.com/martanne/vis/wiki/Differences-from-Sam) and\n[`vim(1)`](https://github.com/martanne/vis/wiki/Differences-from-Vi(m)),\nrespectively.\n\n[C API](https://vis.readthedocs.io/) as well as [Lua API](http://martanne.github.io/vis/doc/)\ndocumentation is also available.\n\nNon Goals\n---------\n\n  Some features which will *not* be implemented:\n\n   - tabs / multiple workspaces / advanced window management\n   - file and directory browser\n   - support for file archives (tar, zip, ...)\n   - support for network protocols (ftp, http, ssh ...)\n   - encryption\n   - compression\n   - GUIs (neither x11, motif, gtk, win32 ...) although the codebase\n     should make it easy to add them\n   - VimL\n   - right-to-left text\n   - ex mode, we have more elegant structural regexp\n   - diff mode\n   - vimgrep\n   - internal spell checker\n   - lots of compile time configurable features / `#ifdef` mess\n\nHow to help?\n------------\n\nThere are plenty of ways to contribute, below are a few ideas:\n\n * Artwork\n    - [Color Themes](https://github.com/martanne/vis/wiki/Themes)\n    - [Name](https://github.com/martanne/vis/issues/338) +\n      [Logo](https://github.com/martanne/vis/issues/328)\n    - Homepage?\n * Documentation\n    - [Manual Pages](https://github.com/martanne/vis/wiki/Developer-Overview#manual-pages)\n    - Improve `:help` output\n * Lua\n    - [API Documentation](https://github.com/martanne/vis/wiki/Developer-Overview#api-documentation)\n      and Examples\n    - [Unit Tests](https://github.com/martanne/vis-test/tree/master/lua)\n    - [Plugin Development](https://github.com/martanne/vis/wiki/Plugins)\n    - [API Design](https://github.com/martanne/vis/issues/292)\n * [Testing Infrastructure](https://github.com/martanne/vis-test)\n * [Distribution Packaging](https://github.com/martanne/vis/wiki/Distribution-Packages)\n * [Core Editor Design](https://github.com/martanne/vis/issues?q=is%3Aopen+is%3Aissue+label%3Adesign)\n\nCheckout the [Developer Overview](https://github.com/martanne/vis/wiki/Developer-Overview)\nto get started and do not hesitate to ask question in the `#vis-editor`\nIRC channel on libera ([join via your browser](https://web.libera.chat/#vis-editor)).\n"
        },
        {
          "name": "array.c",
          "type": "blob",
          "size": 3.2177734375,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"array.h\"\n#include \"util.h\"\n\n#define ARRAY_SIZE 16\n\nvoid array_init(Array *arr) {\n\tarray_init_sized(arr, sizeof(void*));\n}\n\nvoid array_init_from(Array *arr, const Array *from) {\n\tarray_init_sized(arr, from->elem_size);\n}\n\nvoid array_init_sized(Array *arr, size_t elem_size) {\n\tmemset(arr, 0, sizeof *arr);\n\tarr->elem_size = elem_size;\n}\n\nbool array_reserve(Array *arr, size_t count) {\n\tif (count < ARRAY_SIZE)\n\t\tcount = ARRAY_SIZE;\n\tif (arr->count < count) {\n\t\tcount = MAX(count, arr->count*2);\n\t\tchar *items = realloc(arr->items, count * arr->elem_size);\n\t\tif (!items)\n\t\t\treturn false;\n\t\tarr->count = count;\n\t\tarr->items = items;\n\t}\n\treturn true;\n}\n\nvoid array_release(Array *arr) {\n\tif (!arr)\n\t\treturn;\n\tfree(arr->items);\n\tarray_init_sized(arr, arr->elem_size);\n}\n\nvoid array_release_full(Array *arr) {\n\tif (!arr)\n\t\treturn;\n\tfor (size_t i = 0; i < arr->len; i++)\n\t\tfree(array_get_ptr(arr, i));\n\tarray_release(arr);\n}\n\nvoid array_clear(Array *arr) {\n\tarr->len = 0;\n\tif (arr->items)\n\t\tmemset(arr->items, 0, arr->count * arr->elem_size);\n}\n\nvoid *array_get(const Array *arr, size_t idx) {\n\tif (idx >= arr->len) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn arr->items + (idx * arr->elem_size);\n}\n\nvoid *array_get_ptr(const Array *arr, size_t idx) {\n\tif (arr->elem_size != sizeof(void*)) {\n\t\terrno = ENOTSUP;\n\t\treturn NULL;\n\t}\n\tvoid **ptr = array_get(arr, idx);\n\treturn ptr ? *ptr : NULL;\n}\n\nbool array_set(Array *arr, size_t idx, void *item) {\n\tif (idx >= arr->len) {\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\tif (item)\n\t\tmemcpy(arr->items + (idx * arr->elem_size), item, arr->elem_size);\n\telse\n\t\tmemset(arr->items + (idx * arr->elem_size), 0, arr->elem_size);\n\treturn true;\n}\n\nbool array_set_ptr(Array *arr, size_t idx, void *item) {\n\tif (arr->elem_size != sizeof(void*)) {\n\t\terrno = ENOTSUP;\n\t\treturn false;\n\t}\n\treturn array_set(arr, idx, &item);\n}\n\nbool array_add(Array *arr, void *item) {\n\tif (!array_reserve(arr, arr->len+1))\n\t\treturn false;\n\tif (!array_set(arr, arr->len++, item)) {\n\t\tarr->len--;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool array_add_ptr(Array *arr, void *item) {\n\tif (!array_reserve(arr, arr->len+1))\n\t\treturn false;\n\tif (!array_set_ptr(arr, arr->len++, item)) {\n\t\tarr->len--;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool array_remove(Array *arr, size_t idx) {\n\tif (idx >= arr->len) {\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\tchar *dest = arr->items + idx * arr->elem_size;\n\tchar *src = arr->items + (idx + 1) * arr->elem_size;\n\tmemmove(dest, src, (arr->len - idx - 1) * arr->elem_size);\n\tarr->len--;\n\treturn true;\n}\n\nbool array_truncate(Array *arr, size_t len) {\n\tif (len <= arr->len) {\n\t\tarr->len = len;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool array_resize(Array *arr, size_t len) {\n\tif (len <= arr->count) {\n\t\tarr->len = len;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid array_sort(Array *arr, int (*compar)(const void*, const void*)) {\n\tif (arr->items)\n\t\tqsort(arr->items, arr->len, arr->elem_size, compar);\n}\n\nbool array_push(Array *arr, void *item) {\n\treturn array_add(arr, item);\n}\n\nvoid *array_pop(Array *arr) {\n\tvoid *item = array_peek(arr);\n\tif (!item)\n\t\treturn NULL;\n\tarr->len--;\n\treturn item;\n}\n\nvoid *array_peek(const Array *arr) {\n\tif (arr->len == 0)\n\t\treturn NULL;\n\treturn array_get(arr, arr->len - 1);\n}\n"
        },
        {
          "name": "array.h",
          "type": "blob",
          "size": 4.0029296875,
          "content": "#ifndef ARRAY_H\n#define ARRAY_H\n\n#include <stddef.h>\n#include <stdbool.h>\n\n/**\n * @file\n *\n * A dynamically growing array, there exist two typical ways to use it:\n *\n *  1. To hold pointers to externally allocated memory regions.\n *\n *     Use `array_init` for initialization, an element has the size of a\n *     pointer. Use the functions suffixed with ``_ptr`` to manage your\n *     pointers. The cleanup function `array_release_full` must only be\n *     used with this type of array.\n *\n *  2. To hold arbitrary sized objects.\n *\n *     Use `array_init_sized` to specify the size of a single element.\n *     Use the regular (i.e. without the ``_ptr`` suffix) functions to\n *     manage your objects. Functions like `array_add` and `array_set`\n *     will copy the object into the array, `array_get` will return a\n *     pointer to the object stored within the array.\n */\n/** A dynamically growing array. */\ntypedef struct {\n\tchar *items;      /** Data pointer, NULL if empty. */\n\tsize_t elem_size; /** Size of one array element. */\n\tsize_t len;       /** Number of currently stored items. */\n\tsize_t count;     /** Maximal capacity of the array. */\n} Array;\n\n/**\n * Initialize an Array object to store pointers.\n * @rst\n * .. note:: Is equivalent to ``array_init_sized(arr, sizeof(void*))``.\n * @endrst\n */\nvoid array_init(Array*);\n/**\n * Initialize an Array object to store arbitrarily sized objects.\n */\nvoid array_init_sized(Array*, size_t elem_size);\n/** Initialize Array by using the same element size as in ``from``. */\nvoid array_init_from(Array*, const Array *from);\n/** Release storage space. Reinitializes Array object. */\nvoid array_release(Array*);\n/**\n * Release storage space and call `free(3)` for each stored pointer.\n * @rst\n * .. warning:: Assumes array elements to be pointers.\n * @endrst\n */\nvoid array_release_full(Array*);\n/** Empty array, keep allocated memory. */\nvoid array_clear(Array*);\n/** Reserve memory to store at least ``count`` elements. */\nbool array_reserve(Array*, size_t count);\n/**\n * Get array element.\n * @rst\n * .. warning:: Returns a pointer to the allocated array region.\n *              Operations which might cause reallocations (e.g. the insertion\n *              of new elements) might invalidate the pointer.\n * @endrst\n */\nvoid *array_get(const Array*, size_t idx);\n/**\n * Set array element.\n * @rst\n * .. note:: Copies the ``item`` into the Array. If ``item`` is ``NULL``\n *           the corresponding memory region will be cleared.\n * @endrst\n */\nbool array_set(Array*, size_t idx, void *item);\n/** Dereference pointer stored in array element. */\nvoid *array_get_ptr(const Array*, size_t idx);\n/** Store the address to which ``item`` points to into the array. */\nbool array_set_ptr(Array*, size_t idx, void *item);\n/** Add element to the end of the array. */\nbool array_add(Array*, void *item);\n/** Add pointer to the end of the array. */\nbool array_add_ptr(Array*, void *item);\n/**\n * Remove an element by index.\n * @rst\n * .. note:: Might not shrink underlying memory region.\n * @endrst\n */\nbool array_remove(Array*, size_t idx);\n/** Remove all elements with index greater or equal to ``length``, keep allocated memory. */\nbool array_truncate(Array*, size_t length);\n/**\n * Change length.\n * @rst\n * .. note:: Has to be less or equal than the capacity.\n *           Newly accessible elements preserve their previous values.\n * @endrst\n */\nbool array_resize(Array*, size_t length);\n/**\n * Sort array, the comparision function works as for `qsort(3)`.\n */\nvoid array_sort(Array*, int (*compar)(const void*, const void*));\n/**\n * Push item onto the top of the stack.\n * @rst\n * .. note:: Is equivalent to ``array_add(arr, item)``.\n * @endrst\n */\nbool array_push(Array*, void *item);\n/**\n * Get and remove item at the top of the stack.\n * @rst\n * .. warning:: The same ownership rules as for ``array_get`` apply.\n * @endrst\n */\nvoid *array_pop(Array*);\n/**\n * Get item at the top of the stack without removing it.\n * @rst\n * .. warning:: The same ownership rules as for ``array_get`` apply.\n * @endrst\n */\nvoid *array_peek(const Array*);\n\n#endif\n"
        },
        {
          "name": "buffer.c",
          "type": "blob",
          "size": 3.7392578125,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"buffer.h\"\n#include \"util.h\"\n\n#ifndef BUFFER_SIZE\n#define BUFFER_SIZE 1024\n#endif\n\nbool buffer_reserve(Buffer *buf, size_t size) {\n\t/* ensure minimal buffer size, to avoid repeated realloc(3) calls */\n\tif (size < BUFFER_SIZE)\n\t\tsize = BUFFER_SIZE;\n\tif (buf->size < size) {\n\t\tsize = MAX(size, buf->size*2);\n\t\tchar *data = realloc(buf->data, size);\n\t\tif (!data)\n\t\t\treturn false;\n\t\tbuf->size = size;\n\t\tbuf->data = data;\n\t}\n\treturn true;\n}\n\nbool buffer_grow(Buffer *buf, size_t len) {\n\tsize_t size;\n\tif (!addu(buf->len, len, &size))\n\t\treturn false;\n\treturn buffer_reserve(buf, size);\n}\n\nbool buffer_terminate(Buffer *buf) {\n\treturn !buf->data || buf->len == 0 || buf->data[buf->len-1] == '\\0' ||\n\t        buffer_append(buf, \"\\0\", 1);\n}\n\nvoid buffer_release(Buffer *buf) {\n\tif (!buf)\n\t\treturn;\n\tfree(buf->data);\n\t*buf = (Buffer){0};\n}\n\nbool buffer_put(Buffer *buf, const void *data, size_t len) {\n\tif (!buffer_reserve(buf, len))\n\t\treturn false;\n\tmemmove(buf->data, data, len);\n\tbuf->len = len;\n\treturn true;\n}\n\nbool buffer_put0(Buffer *buf, const char *data) {\n\treturn buffer_put(buf, data, strlen(data)+1);\n}\n\nbool buffer_remove(Buffer *buf, size_t pos, size_t len) {\n\tsize_t end;\n\tif (len == 0)\n\t\treturn true;\n\tif (!addu(pos, len, &end) || end > buf->len)\n\t\treturn false;\n\tmemmove(buf->data + pos, buf->data + pos + len, buf->len - pos - len);\n\tbuf->len -= len;\n\treturn true;\n}\n\nbool buffer_insert(Buffer *buf, size_t pos, const void *data, size_t len) {\n\tif (pos > buf->len)\n\t\treturn false;\n\tif (len == 0)\n\t\treturn true;\n\tif (!buffer_grow(buf, len))\n\t\treturn false;\n\tsize_t move = buf->len - pos;\n\tif (move > 0)\n\t\tmemmove(buf->data + pos + len, buf->data + pos, move);\n\tmemcpy(buf->data + pos, data, len);\n\tbuf->len += len;\n\treturn true;\n}\n\nbool buffer_insert0(Buffer *buf, size_t pos, const char *data) {\n\tif (pos == 0)\n\t\treturn buffer_prepend0(buf, data);\n\tif (pos == buf->len)\n\t\treturn buffer_append0(buf, data);\n\treturn buffer_insert(buf, pos, data, strlen(data));\n}\n\nbool buffer_append(Buffer *buf, const void *data, size_t len) {\n\treturn buffer_insert(buf, buf->len, data, len);\n}\n\nbool buffer_append0(Buffer *buf, const char *data) {\n\tsize_t nul = (buf->len > 0 && buf->data[buf->len-1] == '\\0') ? 1 : 0;\n\tbuf->len -= nul;\n\tbool ret = buffer_append(buf, data, strlen(data)+1);\n\tif (!ret)\n\t\tbuf->len += nul;\n\treturn ret;\n}\n\nbool buffer_prepend(Buffer *buf, const void *data, size_t len) {\n\treturn buffer_insert(buf, 0, data, len);\n}\n\nbool buffer_prepend0(Buffer *buf, const char *data) {\n\treturn buffer_prepend(buf, data, strlen(data) + (buf->len == 0));\n}\n\nstatic bool buffer_vappendf(Buffer *buf, const char *fmt, va_list ap) {\n\tva_list ap_save;\n\tva_copy(ap_save, ap);\n\tint len = vsnprintf(NULL, 0, fmt, ap);\n\tif (len == -1 || !buffer_grow(buf, len+1)) {\n\t\tva_end(ap_save);\n\t\treturn false;\n\t}\n\tsize_t nul = (buf->len > 0 && buf->data[buf->len-1] == '\\0') ? 1 : 0;\n\tbuf->len -= nul;\n\tbool ret = vsnprintf(buf->data+buf->len, len+1, fmt, ap_save) == len;\n\tbuf->len += ret ? (size_t)len+1 : nul;\n\tva_end(ap_save);\n\treturn ret;\n}\n\nbool buffer_appendf(Buffer *buf, const char *fmt, ...) {\n\tva_list ap;\n\tva_start(ap, fmt);\n\tbool ret = buffer_vappendf(buf, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nbool buffer_printf(Buffer *buf, const char *fmt, ...) {\n\tbuf->len = 0;\n\tva_list ap;\n\tva_start(ap, fmt);\n\tbool ret = buffer_vappendf(buf, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nsize_t buffer_length0(Buffer *buf) {\n\tsize_t len = buf->len;\n\tif (len > 0 && buf->data[len-1] == '\\0')\n\t\tlen--;\n\treturn len;\n}\n\nconst char *buffer_content0(Buffer *buf) {\n\tif (buf->len == 0 || !buffer_terminate(buf))\n\t\treturn \"\";\n\treturn buf->data;\n}\n\nssize_t read_into_buffer(void *context, char *data, size_t len) {\n\tbuffer_append(context, data, len);\n\treturn len;\n}\n"
        },
        {
          "name": "buffer.h",
          "type": "blob",
          "size": 2.455078125,
          "content": "#ifndef BUFFER_H\n#define BUFFER_H\n\n#include <stddef.h>\n#include <stdbool.h>\n#include \"text.h\"\n\n/**\n * @file\n * A dynamically growing buffer storing arbitrary data.\n * @rst\n * .. note:: Used for Register, *not* Text content.\n * @endrst\n */\n\n/** A dynamically growing buffer storing arbitrary data. */\ntypedef struct {\n\tchar *data;    /**< Data pointer, ``NULL`` if empty. */\n\tsize_t len;    /**< Current length of data. */\n\tsize_t size;   /**< Maximal capacity of the buffer. */\n} Buffer;\n\n/** Release all resources, reinitialize buffer. */\nvoid buffer_release(Buffer*);\n/** Reserve space to store at least ``size`` bytes.*/\nbool buffer_reserve(Buffer*, size_t size);\n/** Reserve space for at least ``len`` *more* bytes. */\nbool buffer_grow(Buffer*, size_t len);\n/** If buffer is non-empty, make sure it is ``NUL`` terminated. */\nbool buffer_terminate(Buffer*);\n/** Set buffer content, growing the buffer as needed. */\nbool buffer_put(Buffer*, const void *data, size_t len);\n/** Set buffer content to ``NUL`` terminated data. */\nbool buffer_put0(Buffer*, const char *data);\n/** Remove ``len`` bytes starting at ``pos``. */\nbool buffer_remove(Buffer*, size_t pos, size_t len);\n/** Insert ``len`` bytes of ``data`` at ``pos``. */\nbool buffer_insert(Buffer*, size_t pos, const void *data, size_t len);\n/** Insert NUL-terminated data at pos. */\nbool buffer_insert0(Buffer*, size_t pos, const char *data);\n/** Append further content to the end. */\nbool buffer_append(Buffer*, const void *data, size_t len);\n/** Append NUL-terminated data. */\nbool buffer_append0(Buffer*, const char *data);\n/** Insert ``len`` bytes of ``data`` at the start. */\nbool buffer_prepend(Buffer*, const void *data, size_t len);\n/** Insert NUL-terminated data at the start. */\nbool buffer_prepend0(Buffer*, const char *data);\n/** Set formatted buffer content, ensures NUL termination on success. */\nbool buffer_printf(Buffer*, const char *fmt, ...) __attribute__((format(printf, 2, 3)));\n/** Append formatted buffer content, ensures NUL termination on success. */\nbool buffer_appendf(Buffer*, const char *fmt, ...) __attribute__((format(printf, 2, 3)));\n/** Return length of a buffer without trailing NUL byte. */\nsize_t buffer_length0(Buffer*);\n/**\n * Get pointer to buffer data.\n * Guaranteed to return a NUL terminated string even if buffer is empty.\n */\nconst char *buffer_content0(Buffer*);\n\n/** ``read(3p)`` like interface for reading into a Buffer (``context``) */\nssize_t read_into_buffer(void *context, char *data, size_t len);\n\n#endif\n"
        },
        {
          "name": "config.def.h",
          "type": "blob",
          "size": 20.880859375,
          "content": "/* Configure your desired default key bindings. */\n\n#define ALIAS(name) .alias = name,\n#define ACTION(id) .action = &vis_action[VIS_ACTION_##id],\n\nstatic const char *keymaps[] = {\n\tNULL\n};\n\nstatic const KeyBinding bindings_basic[] = {\n\t{ \"<C-z>\",              ACTION(EDITOR_SUSPEND)                      },\n\t{ \"<Down>\",             ACTION(CURSOR_LINE_DOWN)                    },\n\t{ \"<End>\",              ACTION(CURSOR_LINE_END)                     },\n\t{ \"<Home>\",             ACTION(CURSOR_LINE_BEGIN)                   },\n\t{ \"<Left>\",             ACTION(CURSOR_CHAR_PREV)                    },\n\t{ \"<PageDown>\",         ACTION(WINDOW_PAGE_DOWN)                    },\n\t{ \"<PageUp>\",           ACTION(WINDOW_PAGE_UP)                      },\n\t{ \"<Right>\",            ACTION(CURSOR_CHAR_NEXT)                    },\n\t{ \"<S-Left>\",           ACTION(CURSOR_LONGWORD_START_PREV)          },\n\t{ \"<S-PageDown>\",       ACTION(WINDOW_HALFPAGE_DOWN)                },\n\t{ \"<S-PageUp>\",         ACTION(WINDOW_HALFPAGE_UP)                  },\n\t{ \"<S-Right>\",          ACTION(CURSOR_LONGWORD_START_NEXT)          },\n\t{ \"<Up>\",               ACTION(CURSOR_LINE_UP)                      },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_motions[] = {\n\t{ \"g|\",                 ACTION(CURSOR_COLUMN)                       },\n\t{ \"[{\",                 ACTION(CURSOR_BLOCK_START)                  },\n\t{ \"]}\",                 ACTION(CURSOR_BLOCK_END)                    },\n\t{ \"[(\",                 ACTION(CURSOR_PARENTHESIS_START)            },\n\t{ \"])\",                 ACTION(CURSOR_PARENTHESIS_END)              },\n\t{ \"$\",                  ACTION(CURSOR_LINE_END)                     },\n\t{ \"^\",                  ACTION(CURSOR_LINE_START)                   },\n\t{ \"}\",                  ACTION(CURSOR_PARAGRAPH_NEXT)               },\n\t{ \"{\",                  ACTION(CURSOR_PARAGRAPH_PREV)               },\n\t{ \"%\",                  ACTION(CURSOR_PERCENT)                      },\n\t{ \"#\",                  ACTION(CURSOR_SEARCH_WORD_BACKWARD)         },\n\t{ \"*\",                  ACTION(CURSOR_SEARCH_WORD_FORWARD)          },\n\t{ \")\",                  ACTION(CURSOR_SENTENCE_NEXT)                },\n\t{ \"(\",                  ACTION(CURSOR_SENTENCE_PREV)                },\n\t{ \"?\",                  ACTION(PROMPT_SEARCH_BACKWARD)              },\n\t{ \"/\",                  ACTION(PROMPT_SEARCH_FORWARD)               },\n\t{ \";\",                  ACTION(TOTILL_REPEAT)                       },\n\t{ \",\",                  ACTION(TOTILL_REVERSE)                      },\n\t{ \"+\",                  ALIAS(\"j^\")                                 },\n\t{ \"-\",                  ALIAS(\"k^\")                                 },\n\t{ \"B\",                  ACTION(CURSOR_LONGWORD_START_PREV)          },\n\t{ \"b\",                  ACTION(CURSOR_WORD_START_PREV)              },\n\t{ \"E\",                  ACTION(CURSOR_LONGWORD_END_NEXT)            },\n\t{ \"e\",                  ACTION(CURSOR_WORD_END_NEXT)                },\n\t{ \"F\",                  ACTION(TO_LINE_LEFT)                        },\n\t{ \"f\",                  ACTION(TO_LINE_RIGHT)                       },\n\t{ \"go\",                 ACTION(CURSOR_BYTE)                         },\n\t{ \"gH\",                 ACTION(CURSOR_BYTE_LEFT)                    },\n\t{ \"gL\",                 ACTION(CURSOR_BYTE_RIGHT)                   },\n\t{ \"gh\",                 ACTION(CURSOR_CODEPOINT_PREV)               },\n\t{ \"gl\",                 ACTION(CURSOR_CODEPOINT_NEXT)               },\n\t{ \"g0\",                 ACTION(CURSOR_SCREEN_LINE_BEGIN)            },\n\t{ \"g_\",                 ACTION(CURSOR_LINE_FINISH)                  },\n\t{ \"G\",                  ACTION(CURSOR_LINE_LAST)                    },\n\t{ \"g$\",                 ACTION(CURSOR_SCREEN_LINE_END)              },\n\t{ \"gE\",                 ACTION(CURSOR_LONGWORD_END_PREV)            },\n\t{ \"ge\",                 ACTION(CURSOR_WORD_END_PREV)                },\n\t{ \"gg\",                 ACTION(CURSOR_LINE_FIRST)                   },\n\t{ \"gj\",                 ACTION(CURSOR_SCREEN_LINE_DOWN)             },\n\t{ \"gk\",                 ACTION(CURSOR_SCREEN_LINE_UP)               },\n\t{ \"gm\",                 ACTION(CURSOR_SCREEN_LINE_MIDDLE)           },\n\t{ \"h\",                  ACTION(CURSOR_CHAR_PREV)                    },\n\t{ \"H\",                  ACTION(CURSOR_WINDOW_LINE_TOP)              },\n\t{ \"j\",                  ACTION(CURSOR_LINE_DOWN)                    },\n\t{ \"k\",                  ACTION(CURSOR_LINE_UP)                      },\n\t{ \"l\",                  ACTION(CURSOR_CHAR_NEXT)                    },\n\t{ \"L\",                  ACTION(CURSOR_WINDOW_LINE_BOTTOM)           },\n\t{ \"M\",                  ACTION(CURSOR_WINDOW_LINE_MIDDLE)           },\n\t{ \"n\",                  ACTION(CURSOR_SEARCH_REPEAT_FORWARD)        },\n\t{ \"N\",                  ACTION(CURSOR_SEARCH_REPEAT_BACKWARD)       },\n\t{ \"T\",                  ACTION(TILL_LINE_LEFT)                      },\n\t{ \"t\",                  ACTION(TILL_LINE_RIGHT)                     },\n\t{ \"W\",                  ACTION(CURSOR_LONGWORD_START_NEXT)          },\n\t{ \"w\",                  ACTION(CURSOR_WORD_START_NEXT)              },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_textobjects[] = {\n\t{ \"a<\",                 ACTION(TEXT_OBJECT_ANGLE_BRACKET_OUTER)     },\n\t{ \"a`\",                 ACTION(TEXT_OBJECT_BACKTICK_OUTER)          },\n\t{ \"a{\",                 ACTION(TEXT_OBJECT_CURLY_BRACKET_OUTER)     },\n\t{ \"a(\",                 ACTION(TEXT_OBJECT_PARENTHESIS_OUTER)       },\n\t{ \"a\\\"\",                ACTION(TEXT_OBJECT_QUOTE_OUTER)             },\n\t{ \"a\\'\",                ACTION(TEXT_OBJECT_SINGLE_QUOTE_OUTER)      },\n\t{ \"a[\",                 ACTION(TEXT_OBJECT_SQUARE_BRACKET_OUTER)    },\n\t{ \"a>\",                 ALIAS(\"a<\")                                 },\n\t{ \"a)\",                 ALIAS(\"a(\")                                 },\n\t{ \"a]\",                 ALIAS(\"a[\")                                 },\n\t{ \"a}\",                 ALIAS(\"a{\")                                 },\n\t{ \"ab\",                 ALIAS(\"a(\")                                 },\n\t{ \"aB\",                 ALIAS(\"a{\")                                 },\n\t{ \"al\",                 ACTION(TEXT_OBJECT_LINE_OUTER)              },\n\t{ \"ap\",                 ACTION(TEXT_OBJECT_PARAGRAPH_OUTER)         },\n\t{ \"as\",                 ACTION(TEXT_OBJECT_SENTENCE)                },\n\t{ \"a<Tab>\",             ACTION(TEXT_OBJECT_INDENTATION)             },\n\t{ \"aW\",                 ACTION(TEXT_OBJECT_LONGWORD_OUTER)          },\n\t{ \"aw\",                 ACTION(TEXT_OBJECT_WORD_OUTER)              },\n\t{ \"gN\",                 ACTION(TEXT_OBJECT_SEARCH_BACKWARD)         },\n\t{ \"gn\",                 ACTION(TEXT_OBJECT_SEARCH_FORWARD)          },\n\t{ \"i<\",                 ACTION(TEXT_OBJECT_ANGLE_BRACKET_INNER)     },\n\t{ \"i`\",                 ACTION(TEXT_OBJECT_BACKTICK_INNER)          },\n\t{ \"i{\",                 ACTION(TEXT_OBJECT_CURLY_BRACKET_INNER)     },\n\t{ \"i(\",                 ACTION(TEXT_OBJECT_PARENTHESIS_INNER)       },\n\t{ \"i\\\"\",                ACTION(TEXT_OBJECT_QUOTE_INNER)             },\n\t{ \"i\\'\",                ACTION(TEXT_OBJECT_SINGLE_QUOTE_INNER)      },\n\t{ \"i[\",                 ACTION(TEXT_OBJECT_SQUARE_BRACKET_INNER)    },\n\t{ \"i>\",                 ALIAS(\"i<\")                                 },\n\t{ \"i)\",                 ALIAS(\"i(\")                                 },\n\t{ \"i]\",                 ALIAS(\"i[\")                                 },\n\t{ \"i}\",                 ALIAS(\"i{\")                                 },\n\t{ \"ib\",                 ALIAS(\"i(\")                                 },\n\t{ \"iB\",                 ALIAS(\"i{\")                                 },\n\t{ \"il\",                 ACTION(TEXT_OBJECT_LINE_INNER)              },\n\t{ \"ip\",                 ACTION(TEXT_OBJECT_PARAGRAPH)               },\n\t{ \"is\",                 ACTION(TEXT_OBJECT_SENTENCE)                },\n\t{ \"i<Tab>\",             ACTION(TEXT_OBJECT_INDENTATION)             },\n\t{ \"iW\",                 ACTION(TEXT_OBJECT_LONGWORD_INNER)          },\n\t{ \"iw\",                 ACTION(TEXT_OBJECT_WORD_INNER)              },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_selections[] = {\n\t{ \"m\",                  ACTION(SELECTIONS_SAVE)                     },\n\t{ \"M\",                  ACTION(SELECTIONS_RESTORE)                  },\n\t{ \"|\",                  ACTION(SELECTIONS_UNION)                    },\n\t{ \"&\",                  ACTION(SELECTIONS_INTERSECT)                },\n\t{ \"~\",                  ACTION(SELECTIONS_COMPLEMENT)               },\n\t{ \"\\\\\",                 ACTION(SELECTIONS_MINUS)                    },\n\t{ \"_\",                  ACTION(SELECTIONS_TRIM)                     },\n\t{ \"<S-Tab>\",            ACTION(SELECTIONS_ALIGN_INDENT_RIGHT)       },\n\t{ \"<Tab>\",              ACTION(SELECTIONS_ALIGN_INDENT_LEFT)        },\n\t{ \"g<\",                 ACTION(JUMPLIST_PREV)                       },\n\t{ \"gs\",                 ACTION(JUMPLIST_SAVE)                       },\n\t{ \"g>\",                 ACTION(JUMPLIST_NEXT)                       },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_operators[] = {\n\t{ \"0\",                  ACTION(COUNT)                               },\n\t{ \"1\",                  ACTION(COUNT)                               },\n\t{ \"2\",                  ACTION(COUNT)                               },\n\t{ \"3\",                  ACTION(COUNT)                               },\n\t{ \"4\",                  ACTION(COUNT)                               },\n\t{ \"5\",                  ACTION(COUNT)                               },\n\t{ \"6\",                  ACTION(COUNT)                               },\n\t{ \"7\",                  ACTION(COUNT)                               },\n\t{ \"8\",                  ACTION(COUNT)                               },\n\t{ \"9\",                  ACTION(COUNT)                               },\n\t{ \"=\",                  ALIAS(\":|fmt<Enter>\")                       },\n\t{ \"<\",                  ACTION(OPERATOR_SHIFT_LEFT)                 },\n\t{ \">\",                  ACTION(OPERATOR_SHIFT_RIGHT)                },\n\t{ \"\\\"\",                 ACTION(REGISTER)                            },\n\t{ \"'\",                  ACTION(MARK)                                },\n\t{ \"c\",                  ACTION(OPERATOR_CHANGE)                     },\n\t{ \"d\",                  ACTION(OPERATOR_DELETE)                     },\n\t{ \"g~\",                 ALIAS(\":|tr '[:lower:][:upper:]' '[:upper:][:lower:]'<Enter>\") },\n\t{ \"gu\",                 ALIAS(\":|awk '{printf \\\"%s\\\", tolower($0)}'<Enter>\")},\n\t{ \"gU\",                 ALIAS(\":|awk '{printf \\\"%s\\\", toupper($0)}'<Enter>\")},\n\t{ \"p\",                  ACTION(PUT_AFTER)                           },\n\t{ \"P\",                  ACTION(PUT_BEFORE)                          },\n\t{ \"y\",                  ACTION(OPERATOR_YANK)                       },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_normal[] = {\n\t{ \"a\",                  ACTION(APPEND_CHAR_NEXT)                    },\n\t{ \"A\",                  ACTION(APPEND_LINE_END)                     },\n\t{ \"@\",                  ACTION(MACRO_REPLAY)                        },\n\t{ \":\",                  ACTION(PROMPT_SHOW)                         },\n\t{ \".\",                  ACTION(REPEAT)                              },\n\t{ \"C\",                  ALIAS(\"c$\")                                 },\n\t{ \"<C-b>\",              ALIAS(\"<PageUp>\")                           },\n\t{ \"<C-c>\",              ACTION(SELECTIONS_REMOVE_COLUMN)            },\n\t{ \"<C-d>\",              ACTION(SELECTIONS_NEXT)                     },\n\t{ \"<C-e>\",              ACTION(WINDOW_SLIDE_UP)                     },\n\t{ \"<C-f>\",              ALIAS(\"<PageDown>\")                         },\n\t{ \"<C-j>\",              ACTION(SELECTIONS_NEW_LINE_BELOW)           },\n\t{ \"<C-k>\",              ACTION(SELECTIONS_NEW_LINE_ABOVE)           },\n\t{ \"<C-l>\",              ACTION(SELECTIONS_REMOVE_COLUMN_EXCEPT)     },\n\t{ \"<C-n>\",              ALIAS(\"viw\")                                },\n\t{ \"<C-p>\",              ACTION(SELECTIONS_REMOVE_LAST)              },\n\t{ \"<C-r>\",              ACTION(REDO)                                },\n\t{ \"<C-u>\",              ACTION(SELECTIONS_PREV)                     },\n\t{ \"<C-w>c\",             ALIAS(\":q<Enter>\")                          },\n\t{ \"<C-w>h\",             ALIAS(\"<C-w>k\")                             },\n\t{ \"<C-w>j\",             ACTION(WINDOW_NEXT)                         },\n\t{ \"<C-w>k\",             ACTION(WINDOW_PREV)                         },\n\t{ \"<C-w>l\",             ALIAS(\"<C-w>j\")                             },\n\t{ \"<C-w>n\",             ALIAS(\":open<Enter>\")                       },\n\t{ \"<C-w>s\",             ALIAS(\":split<Enter>\")                      },\n\t{ \"<C-w>v\",             ALIAS(\":vsplit<Enter>\")                     },\n\t{ \"<C-y>\",              ACTION(WINDOW_SLIDE_DOWN)                   },\n\t{ \"D\",                  ALIAS(\"d$\")                                 },\n\t{ \"<Escape>\",           ACTION(MODE_NORMAL_ESCAPE)                  },\n\t{ \"<F1>\",               ALIAS(\":help<Enter>\")                       },\n\t{ \"ga\",                 ACTION(UNICODE_INFO)                        },\n\t{ \"g8\",                 ACTION(UTF8_INFO)                           },\n\t{ \"g-\",                 ACTION(EARLIER)                             },\n\t{ \"g+\",                 ACTION(LATER)                               },\n\t{ \"gn\",                 ALIAS(\"vgn\")                                },\n\t{ \"gN\",                 ALIAS(\"vgN\")                                },\n\t{ \"gv\",                 ALIAS(\"v'^M\")                               },\n\t{ \"I\",                  ACTION(INSERT_LINE_START)                   },\n\t{ \"i\",                  ACTION(MODE_INSERT)                         },\n\t{ \"J\",                  ACTION(JOIN_LINES)                          },\n\t{ \"gJ\",                 ACTION(JOIN_LINES_TRIM)                     },\n\t{ \"<M-C-j>\",            ACTION(SELECTIONS_NEW_LINE_BELOW_LAST)      },\n\t{ \"<M-C-k>\",            ACTION(SELECTIONS_NEW_LINE_ABOVE_FIRST)     },\n\t{ \"O\",                  ACTION(OPEN_LINE_ABOVE)                     },\n\t{ \"o\",                  ACTION(OPEN_LINE_BELOW)                     },\n\t{ \"q\",                  ACTION(MACRO_RECORD)                        },\n\t{ \"R\",                  ACTION(MODE_REPLACE)                        },\n\t{ \"r\",                  ACTION(REPLACE_CHAR)                        },\n\t{ \"S\",                  ALIAS(\"^c$\")                                },\n\t{ \"s\",                  ALIAS(\"cl\")                                 },\n\t{ \"<Tab>\",              ACTION(SELECTIONS_ALIGN)                    },\n\t{ \"u\",                  ACTION(UNDO)                                },\n\t{ \"v\",                  ACTION(MODE_VISUAL)                         },\n\t{ \"V\",                  ACTION(MODE_VISUAL_LINE)                    },\n\t{ \"x\",                  ACTION(DELETE_CHAR_NEXT)                    },\n\t{ \"X\",                  ALIAS(\"dh\")                                 },\n\t{ \"Y\",                  ALIAS(\"y$\")                                 },\n\t{ \"zb\",                 ACTION(WINDOW_REDRAW_BOTTOM)                },\n\t{ \"ZQ\",                 ALIAS(\":q!<Enter>\")                         },\n\t{ \"zt\",                 ACTION(WINDOW_REDRAW_TOP)                   },\n\t{ \"zz\",                 ACTION(WINDOW_REDRAW_CENTER)                },\n\t{ \"ZZ\",                 ALIAS(\":wq<Enter>\")                         },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_visual[] = {\n\t{ \"A\",                  ACTION(SELECTIONS_NEW_LINES_END)            },\n\t{ \"@\",                  ACTION(MACRO_REPLAY)                        },\n\t{ \":\",                  ACTION(PROMPT_SHOW)                         },\n\t{ \"-\",                  ACTION(SELECTIONS_ROTATE_LEFT)              },\n\t{ \"+\",                  ACTION(SELECTIONS_ROTATE_RIGHT)             },\n\t{ \"<\",                  ALIAS(\"<vis-operator-shift-left>gv\")        },\n\t{ \">\",                  ALIAS(\"<vis-operator-shift-right>gv\")       },\n\t{ \"<C-a>\",              ACTION(SELECTIONS_NEW_MATCH_ALL)            },\n\t{ \"<C-b>\",              ALIAS(\"<PageUp>\")                           },\n\t{ \"<C-c>\",              ACTION(SELECTIONS_REMOVE_COLUMN)            },\n\t{ \"<C-d>\",              ACTION(SELECTIONS_NEXT)                     },\n\t{ \"<C-f>\",              ALIAS(\"<PageDown>\")                         },\n\t{ \"<C-j>\",              ALIAS(\"<C-d>\")                              },\n\t{ \"<C-k>\",              ALIAS(\"<C-u>\")                              },\n\t{ \"<C-l>\",              ACTION(SELECTIONS_REMOVE_COLUMN_EXCEPT)     },\n\t{ \"<C-n>\",              ACTION(SELECTIONS_NEW_MATCH_NEXT)           },\n\t{ \"<C-p>\",              ACTION(SELECTIONS_REMOVE_LAST)              },\n\t{ \"<C-u>\",              ACTION(SELECTIONS_PREV)                     },\n\t{ \"<C-x>\",              ACTION(SELECTIONS_NEW_MATCH_SKIP)           },\n\t{ \"<Escape>\",           ACTION(MODE_VISUAL_ESCAPE)                  },\n\t{ \"I\",                  ACTION(SELECTIONS_NEW_LINES_BEGIN)          },\n\t{ \"J\",                  ACTION(JOIN_LINES)                          },\n\t{ \"gJ\",                 ACTION(JOIN_LINES_TRIM)                     },\n\t{ \"o\",                  ACTION(SELECTION_FLIP)                      },\n\t{ \"q\",                  ACTION(MACRO_RECORD)                        },\n\t{ \"r\",                  ACTION(REPLACE_CHAR)                        },\n\t{ \"s\",                  ALIAS(\"c\")                                  },\n\t{ \"u\",                  ALIAS(\"gu<Escape>\")                         },\n\t{ \"U\",                  ALIAS(\"gU<Escape>\")                         },\n\t{ \"V\",                  ACTION(MODE_VISUAL_LINE)                    },\n\t{ \"v\",                  ALIAS(\"<Escape>\")                           },\n\t{ \"x\",                  ALIAS(\"d\")                                  },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_visual_line[] = {\n\t{ \"v\",                  ACTION(MODE_VISUAL)                         },\n\t{ \"V\",                  ACTION(MODE_NORMAL)                         },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_readline[] = {\n\t{ \"<Backspace>\",        ACTION(DELETE_CHAR_PREV)                    },\n\t{ \"<C-c>\",              ALIAS(\"<Escape>\")                           },\n\t{ \"<C-d>\",              ACTION(DELETE_CHAR_NEXT)                    },\n\t{ \"<C-h>\",              ALIAS(\"<Backspace>\")                        },\n\t{ \"<C-u>\",              ACTION(DELETE_LINE_BEGIN)                   },\n\t{ \"<C-v>\",              ACTION(INSERT_VERBATIM)                     },\n\t{ \"<C-w>\",              ACTION(DELETE_WORD_PREV)                    },\n\t{ \"<C-e>\",              ACTION(CURSOR_LINE_END)                     },\n\t{ \"<C-a>\",              ACTION(CURSOR_LINE_START)                   },\n\t{ \"<Delete>\",           ACTION(DELETE_CHAR_NEXT)                    },\n\t{ \"<Escape>\",           ACTION(MODE_NORMAL)                         },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_insert[] = {\n\t{ \"<C-d>\",              ALIAS(\"<vis-operator-shift-left><vis-operator-shift-left>\") },\n\t{ \"<C-i>\",              ALIAS(\"<Tab>\")                              },\n\t{ \"<C-j>\",              ALIAS(\"<vis-insert-verbatim>u000a\")         },\n\t{ \"<C-m>\",              ALIAS(\"<Enter>\")                            },\n\t{ \"<C-r>\",              ACTION(INSERT_REGISTER)                     },\n\t{ \"<C-t>\",              ALIAS(\"<vis-operator-shift-right><vis-operator-shift-right>\") },\n\t{ \"<C-x><C-e>\",         ACTION(WINDOW_SLIDE_UP)                     },\n\t{ \"<C-x><C-y>\",         ACTION(WINDOW_SLIDE_DOWN)                   },\n\t{ \"<Enter>\",            ACTION(INSERT_NEWLINE)                      },\n\t{ \"<Escape>\",           ACTION(MODE_NORMAL)                         },\n\t{ \"<S-Tab>\",            ACTION(SELECTIONS_ALIGN_INDENT_LEFT)        },\n\t{ \"<Tab>\",              ACTION(INSERT_TAB)                          },\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\nstatic const KeyBinding bindings_replace[] = {\n\t{ 0 /* empty last element, array terminator */                      },\n};\n\n/* For each mode we list a all key bindings, if a key is bound in more than\n * one array the first definition is used and further ones are ignored. */\nstatic const KeyBinding **default_bindings[] = {\n\t[VIS_MODE_OPERATOR_PENDING] = (const KeyBinding*[]){\n\t\tbindings_operators,\n\t\tbindings_textobjects,\n\t\tbindings_motions,\n\t\tbindings_basic,\n\t\tNULL,\n\t},\n\t[VIS_MODE_NORMAL] = (const KeyBinding*[]){\n\t\tbindings_normal,\n\t\tbindings_selections,\n\t\tbindings_operators,\n\t\tbindings_motions,\n\t\tbindings_basic,\n\t\tNULL,\n\t},\n\t[VIS_MODE_VISUAL] = (const KeyBinding*[]){\n\t\tbindings_visual,\n\t\tbindings_selections,\n\t\tbindings_textobjects,\n\t\tbindings_operators,\n\t\tbindings_motions,\n\t\tbindings_basic,\n\t\tNULL,\n\t},\n\t[VIS_MODE_VISUAL_LINE] = (const KeyBinding*[]){\n\t\tbindings_visual_line,\n\t\tNULL,\n\t},\n\t[VIS_MODE_INSERT] = (const KeyBinding*[]){\n\t\tbindings_insert,\n\t\tbindings_readline,\n\t\tbindings_basic,\n\t\tNULL,\n\t},\n\t[VIS_MODE_REPLACE] = (const KeyBinding*[]){\n\t\tbindings_replace,\n\t\tNULL,\n\t},\n};\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 15.5712890625,
          "content": "#!/bin/sh\n# Based on the configure script from musl libc, MIT licensed\n\nusage () {\ncat <<EOF\nUsage: $0 [OPTION]... [VAR=VALUE]...\n\nTo assign environment variables (e.g., CC, CFLAGS...), specify them as\nVAR=VALUE.  See below for descriptions of some of the useful variables.\n\nDefaults for the options are specified in brackets.\n\nConfiguration:\n  --srcdir=DIR            source directory [detected]\n\nInstallation directories:\n  --prefix=PREFIX         main installation prefix [/usr/local]\n  --exec-prefix=EPREFIX   installation prefix for executable files [PREFIX]\n\nFine tuning of the installation directories:\n  --bindir=DIR            user executables [EPREFIX/bin]\n  --sharedir=DIR          share directories [PREFIX/share]\n  --docdir=DIR            misc. documentation [PREFIX/share/doc]\n  --mandir=DIR            man pages [PREFIX/share/man]\n\nOptional features:\n  --enable-curses         build with Curses terminal output [yes]\n  --enable-lua            build with Lua support [auto]\n  --enable-lpeg-static    build with LPeg static linking [auto]\n  --enable-tre            build with TRE regex support [auto]\n  --enable-selinux        build with SELinux support [auto]\n  --enable-acl            build with POSIX ACL support [auto]\n  --enable-help           build with built-in help texts [yes]\n\nSome influential environment variables:\n  CC                      C compiler command [detected]\n  CFLAGS                  C compiler flags [-Os -pipe ...]\n  LDFLAGS                 Linker flags\n\nUse these variables to override the choices made by configure.\n\nEOF\nexit 0\n}\n\n# Helper functions\n\nquote () {\ntr '\\n' ' ' <<EOF | grep '^[-[:alnum:]_=,./:]* $' >/dev/null 2>&1 && { echo \"$1\" ; return 0 ; }\n$1\nEOF\nprintf %s\\\\n \"$1\" | sed -e \"s/'/'\\\\\\\\''/g\" -e \"1s/^/'/\" -e \"\\$s/\\$/'/\" -e \"s#^'\\([-[:alnum:]_,./:]*\\)=\\(.*\\)\\$#\\1='\\2#\"\n}\necho () { printf \"%s\\n\" \"$*\" ; }\nfail () { echo \"$*\" ; exit 1 ; }\nfnmatch () { eval \"case \\\"\\$2\\\" in $1) return 0 ;; *) return 1 ;; esac\" ; }\ncmdexists () { type \"$1\" >/dev/null 2>&1 ; }\ntrycc () { test -z \"$CC\" && cmdexists \"$1\" && CC=$1 ; }\n\nstripdir () {\nwhile eval \"fnmatch '*/' \\\"\\${$1}\\\"\" ; do eval \"$1=\\${$1%/}\" ; done\n}\n\ntrycppif () {\nprintf \"checking preprocessor condition %s... \" \"$1\"\necho \"typedef int x;\" > \"$tmpc\"\necho \"#if $1\" >> \"$tmpc\"\necho \"#error yes\" >> \"$tmpc\"\necho \"#endif\" >> \"$tmpc\"\nif $CC $2 -c -o \"$tmpo\" \"$tmpc\" >/dev/null 2>&1 ; then\nprintf \"false\\n\"\nreturn 1\nelse\nprintf \"true\\n\"\nreturn 0\nfi\n}\n\ntryflag () {\nprintf \"checking whether compiler accepts %s... \" \"$2\"\necho \"typedef int x;\" > \"$tmpc\"\nif $CC $CFLAGS_TRY $2 -c -o \"$tmpo\" \"$tmpc\" >/dev/null 2>&1 ; then\nprintf \"yes\\n\"\neval \"$1=\\\"\\${$1} \\$2\\\"\"\neval \"$1=\\${$1# }\"\nreturn 0\nelse\nprintf \"no\\n\"\nreturn 1\nfi\n}\n\ntryldflag () {\nprintf \"checking whether linker accepts %s... \" \"$2\"\necho \"typedef int x;\" > \"$tmpc\"\nif $CC $LDFLAGS_TRY -nostdlib -shared \"$2\" -o \"$tmpo\" \"$tmpc\" >/dev/null 2>&1 ; then\nprintf \"yes\\n\"\neval \"$1=\\\"\\${$1} \\$2\\\"\"\neval \"$1=\\${$1# }\"\nreturn 0\nelse\nprintf \"no\\n\"\nreturn 1\nfi\n}\n\n# Beginning of actual script\n\nCFLAGS_AUTO=\nCFLAGS_TRY=\nLDFLAGS_AUTO=\nLDFLAGS_TRY=\nSRCDIR=\nPREFIX=/usr/local\nEXEC_PREFIX='$(PREFIX)'\nBINDIR='$(EXEC_PREFIX)/bin'\nSHAREDIR='$(PREFIX)/share'\nDOCDIR='$(PREFIX)/share/doc'\nMANDIR='$(PREFIX)/share/man'\n\nhelp=yes\ncurses=yes\nlua=auto\nlpeg=auto\ntre=auto\nselinux=auto\nacl=auto\n\nfor arg ; do\ncase \"$arg\" in\n--help|-h) usage ;;\n--srcdir=*) SRCDIR=${arg#*=} ;;\n--prefix=*) PREFIX=${arg#*=} ;;\n--exec-prefix=*) EXEC_PREFIX=${arg#*=} ;;\n--bindir=*) BINDIR=${arg#*=} ;;\n--sharedir=*) SHAREDIR=${arg#*=} ;;\n--docdir=*) DOCDIR=${arg#*=} ;;\n--mandir=*) MANDIR=${arg#*=} ;;\n--environment-only) environmentonly=yes ;;\n--enable-help|--enable-help=yes) help=yes ;;\n--disable-help|--enable-help=no) help=no ;;\n--enable-curses|--enable-curses=yes) curses=yes ;;\n--disable-curses|--enable-curses=no) curses=no ;;\n--enable-lua|--enable-lua=yes) lua=yes ;;\n--disable-lua|--enable-lua=no) lua=no ;;\n--enable-lpeg-static|--enable-lpeg-static=yes) lpeg=yes ;;\n--disable-lpeg-static|--enable-lpeg-static=no) lpeg=no ;;\n--enable-tre|--enable-tre=yes) tre=yes ;;\n--disable-tre|--enable-tre=no) tre=no ;;\n--enable-selinux|--enable-selinux=yes) selinux=yes ;;\n--disable-selinux|--enable-selinux=no) selinux=no ;;\n--enable-acl|--enable-acl=yes) acl=yes ;;\n--disable-acl|--enable-acl=no) acl=no ;;\n--enable-*|--disable-*|--with-*|--without-*|--*dir=*|--build=*) ;;\n-* ) echo \"$0: unknown option $arg\" ;;\nCC=*) CC=${arg#*=} ;;\nCFLAGS=*) CFLAGS=${arg#*=} ;;\nCPPFLAGS=*) CPPFLAGS=${arg#*=} ;;\nLDFLAGS=*) LDFLAGS=${arg#*=} ;;\n*=*) ;;\n*) ;;\nesac\ndone\n\nfor i in SRCDIR PREFIX EXEC_PREFIX BINDIR SHAREDIR DOCDIR MANDIR ; do\nstripdir $i\ndone\n\n#\n# Get the source dir for out-of-tree builds\n#\nif test -z \"$SRCDIR\" ; then\nSRCDIR=\"${0%/configure}\"\nstripdir SRCDIR\nfi\nabs_builddir=\"$(pwd)\" || fail \"$0: cannot determine working directory\"\nabs_srcdir=\"$(cd $SRCDIR && pwd)\" || fail \"$0: invalid source directory $SRCDIR\"\ntest \"$abs_srcdir\" = \"$abs_builddir\" && SRCDIR=.\ntest \"$SRCDIR\" != \".\" -a -f Makefile -a ! -h Makefile && fail \"$0: Makefile already exists in the working directory\"\n\n#\n# Get a temp filename we can use\n#\ni=0\nset -C\nwhile : ; do i=$(($i+1))\ntmpc=\"./conf$$-$PPID-$i.c\"\ntmpo=\"./conf$$-$PPID-$i.o\"\n2>|/dev/null > \"$tmpc\" && break\ntest \"$i\" -gt 50 && fail \"$0: cannot create temporary file $tmpc\"\ndone\nset +C\ntrap 'rm -f \"$tmpc\" \"$tmpo\"' EXIT QUIT TERM HUP\ntrap 'rm -f \"$tmpc\" \"$tmpo\" && echo && fail \"$0: interrupted\"' INT\n\n#\n# Find a C compiler to use\n#\nprintf \"checking for C compiler... \"\ntrycc cc\ntrycc gcc\ntrycc clang\nprintf \"%s\\n\" \"$CC\"\ntest -n \"$CC\" || { echo \"$0: cannot find a C compiler\" ; exit 1 ; }\n\nprintf \"checking whether C compiler works... \"\necho \"typedef int x;\" > \"$tmpc\"\nif output=$($CC $CPPFLAGS $CFLAGS -c -o \"$tmpo\" \"$tmpc\" 2>&1) ; then\nprintf \"yes\\n\"\nelse\nprintf \"no; compiler output follows:\\n%s\\n\" \"$output\"\nexit 1\nfi\n\n#\n# Figure out options to force errors on unknown flags.\n#\ntryflag   CFLAGS_TRY  -Werror=unknown-warning-option\ntryflag   CFLAGS_TRY  -Werror=unused-command-line-argument\ntryldflag LDFLAGS_TRY -Werror=unknown-warning-option\ntryldflag LDFLAGS_TRY -Werror=unused-command-line-argument\n\nCFLAGS_STD=\"-std=c99 -U_XOPEN_SOURCE -D_XOPEN_SOURCE=700 -DNDEBUG -MMD\"\nLDFLAGS_STD=\"-lc\"\n\nOS=$(uname)\n\ncase \"$OS\" in\nFreeBSD|DragonFly) CFLAGS_STD=\"$CFLAGS_STD -D_BSD_SOURCE -D__BSD_VISIBLE=1\" ;;\nNetBSD)  CFLAGS_STD=\"$CFLAGS_STD -D_NETBSD_SOURCE\" ;;\n*BSD)    CFLAGS_STD=\"$CFLAGS_STD -D_BSD_SOURCE\" ;;\nDarwin)  CFLAGS_STD=\"$CFLAGS_STD -D_DARWIN_C_SOURCE\" ;;\nAIX)     CFLAGS_STD=\"$CFLAGS_STD -D_ALL_SOURCE\" ;;\nesac\n\ntryflag CFLAGS -Wall\ntryflag CFLAGS -pipe\n\n# Try flags to optimize binary size\ntryflag CFLAGS -O2\ntryflag CFLAGS -ffunction-sections\ntryflag CFLAGS -fdata-sections\ntryldflag LDFLAGS_AUTO -Wl,--gc-sections\n\n# Try hardening flags\ntryflag CFLAGS -fPIE\ntryflag CFLAGS_AUTO -fstack-protector-all\ntryldflag LDFLAGS -Wl,-z,now\ntryldflag LDFLAGS -Wl,-z,relro\ntryldflag LDFLAGS_AUTO -pie\n\nprintf \"creating config.mk... \"\n\ncmdline=$(quote \"$0\")\nfor i ; do cmdline=\"$cmdline $(quote \"$i\")\" ; done\n\nexec 3>&1 1>config.mk\n\ncat << EOF\n# This version of config.mk was generated by:\n# $cmdline\n# Any changes made here will be lost if configure is re-run\nSRCDIR = $SRCDIR\nPREFIX = $PREFIX\nEXEC_PREFIX = $EXEC_PREFIX\nBINDIR = $BINDIR\nDOCPREFIX = $DOCDIR\nMANPREFIX = $MANDIR\nSHAREPREFIX = $SHAREDIR\nCC = $CC\nCFLAGS = $CFLAGS\nLDFLAGS = $LDFLAGS\nCFLAGS_STD = $CFLAGS_STD\nLDFLAGS_STD = $LDFLAGS_STD\nCFLAGS_AUTO = $CFLAGS_AUTO\nLDFLAGS_AUTO = $LDFLAGS_AUTO\nCFLAGS_DEBUG = -U_FORTIFY_SOURCE -UNDEBUG -O0 -g3 -ggdb -Wall -Wextra -pedantic -Wno-missing-field-initializers -Wno-unused-parameter\nEOF\nexec 1>&3 3>&-\n\nprintf \"done\\n\"\n\nif test \"$environmentonly\" = \"yes\"; then\n\texit 0\nfi\n\nhave_pkgconfig=no\nprintf \"checking for pkg-config... \"\ncmdexists pkg-config && have_pkgconfig=yes\nprintf \"%s\\n\" \"$have_pkgconfig\"\n\nif test \"$help\" = \"yes\" ; then\n\tCONFIG_HELP=1\nelse\n\tCONFIG_HELP=0\nfi\n\nCONFIG_CURSES=0\n\nif test \"$curses\" != \"no\" ; then\n\n\tprintf \"checking for libcurses...\\n\"\n\ncat > \"$tmpc\" <<EOF\n#include <curses.h>\n\nint main(int argc, char *argv[]) {\n\tinitscr();\n\tendwin();\n\treturn 0;\n}\nEOF\n\n\tfor libcurses in ncursesw ncurses curses; do\n\t\tprintf \" checking for %s... \" \"$libcurses\"\n\n\t\tif test \"$have_pkgconfig\" = \"yes\" ; then\n\t\t\tCFLAGS_CURSES=$(pkg-config --cflags $libcurses 2>/dev/null)\n\t\t\tLDFLAGS_CURSES=$(pkg-config --libs $libcurses 2>/dev/null)\n\t\t\tif test $? -eq 0 && $CC $CFLAGS $CFLAGS_CURSES \"$tmpc\" \\\n\t\t\t\t$LDFLAGS $LDFLAGS_CURSES -o \"$tmpo\" >/dev/null 2>&1 ; then\n\t\t\t\tCONFIG_CURSES=1\n\t\t\t\tprintf \"yes\\n\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tfi\n\n\t\tCFLAGS_CURSES=\"\"\n\t\tLDFLAGS_CURSES=\"-l$libcurses\"\n\n\t\tif $CC $CFLAGS $CFLAGS_CURSES \"$tmpc\" \\\n\t\t\t$LDFLAGS $LDFLAGS_CURSES -o \"$tmpo\" >/dev/null 2>&1 ; then\n\t\t\tCONFIG_CURSES=1\n\t\t\tprintf \"yes\\n\"\n\t\t\tbreak\n\t\telse\n\t\t\tCFLAGS_CURSES=\"\"\n\t\t\tLDFLAGS_CURSES=\"\"\n\t\t\tprintf \"no\\n\"\n\t\tfi\n\tdone\n\n\ttest \"$curses\" = \"yes\" -a $CONFIG_CURSES -ne 1 && fail \"$0: cannot find libcurses\"\nfi\n\n# libtermkey is a mandatory dependency\n\nprintf \"checking for libtermkey... \"\ncat > \"$tmpc\" <<EOF\n#include <termkey.h>\n\nint main(int argc, char *argv[]) {\n\tTERMKEY_CHECK_VERSION;\n\treturn 0;\n}\nEOF\n\nif test \"$have_pkgconfig\" = \"yes\" ; then\n\tCFLAGS_TERMKEY=$(pkg-config --cflags termkey 2>/dev/null)\n\tLDFLAGS_TERMKEY=$(pkg-config --libs termkey 2>/dev/null)\nfi\n\nif test -z \"$LDFLAGS_TERMKEY\"; then\n\tCFLAGS_TERMKEY=\"\"\n\tLDFLAGS_TERMKEY=\"-ltermkey\"\nfi\n\nif $CC $CFLAGS $CFLAGS_TERMKEY \"$tmpc\" $LDFLAGS $LDFLAGS_TERMKEY $LDFLAGS_CURSES \\\n\t-o \"$tmpo\" >/dev/null 2>&1; then\n\tprintf \"%s\\n\" \"yes\"\nelse\n\tprintf \"%s\\n\" \"no\"\n\tfail \"$0: cannot find libtermkey\"\nfi\n\nCONFIG_TRE=0\nREGEX_SRC=text-regex.c\n\nif test \"$tre\" != \"no\" ; then\n\n\tprintf \"checking for libtre... \"\n\ncat > \"$tmpc\" <<EOF\n#include <stddef.h>\n#include <tre/tre.h>\n\nint main() {\n\tregex_t preg;\n\ttre_str_source *source = NULL;\n\tregmatch_t pmatch[1];\n\ttre_regcomp(&preg, \"\\0\", REG_EXTENDED);\n\ttre_reguexec(&preg, source, 1, pmatch, 0);\n\ttre_regfree(&preg);\n\treturn 0;\n}\nEOF\n\n\tif test \"$have_pkgconfig\" = \"yes\" ; then\n\t\tCFLAGS_TRE=$(pkg-config --cflags tre 2>/dev/null)\n\t\tLDFLAGS_TRE=$(pkg-config --libs tre 2>/dev/null)\n\tfi\n\n\tif test -z \"$LDFLAGS_TRE\"; then\n\t\tCFLAGS_TRE=\"\"\n\t\tLDFLAGS_TRE=\"-ltre\"\n\tfi\n\n\tif $CC $CFLAGS $CFLAGS_TRE \"$tmpc\" \\\n\t\t$LDFLAGS $LDFLAGS_TRE -o \"$tmpo\" >/dev/null 2>&1; then\n\t\tCONFIG_TRE=1\n\t\tREGEX_SRC=text-regex-tre.c\n\t\tprintf \"%s\\n\" \"yes\"\n\telse\n\t\tprintf \"%s\\n\" \"no\"\n\t\tCFLAGS_TRE=\"\"\n\t\tLDFLAGS_TRE=\"\"\n\t\ttest \"$tre\" = \"yes\" && fail \"$0: cannot find libtre\"\n\tfi\nfi\n\nCONFIG_LUA=0\n\n# enabling builtin lpeg requires lua support\ntest \"$lpeg\" = \"yes\" -a \"$lua\" = \"no\" && fail \"$0: need lua support for built-in lpeg\"\ntest \"$lpeg\" = \"yes\" && lua=yes\n\nif test \"$lua\" != \"no\" ; then\n\n\tprintf \"checking for liblua >= 5.2 ...\\n\"\n\ncat > \"$tmpc\" <<EOF\n#include <lua.h>\n#include <lualib.h>\n#include <lauxlib.h>\n\n#if LUA_VERSION_NUM < 502\n#error \"Need at least Lua 5.2\"\n#endif\n\nint main(int argc, char *argv[]) {\n\tlua_State *L = luaL_newstate();\n\tluaL_openlibs(L);\n\tlua_close(L);\n\treturn 0;\n}\nEOF\n\n\tfor liblua in lua lua5.4 lua5.3 lua5.2 lua-5.4 lua-5.3 lua-5.2 lua54 lua53 lua52; do\n\t\tprintf \" checking for %s... \" \"$liblua\"\n\n\t\tif test \"$have_pkgconfig\" = \"yes\" ; then\n\t\t\tCFLAGS_LUA=$(pkg-config --cflags $liblua 2>/dev/null)\n\t\t\tLDFLAGS_LUA=$(pkg-config --libs $liblua 2>/dev/null)\n\t\t\tif test $? -eq 0 && $CC $CFLAGS $CFLAGS_LUA \"$tmpc\" \\\n\t\t\t\t$LDFLAGS $LDFLAGS_LUA -o \"$tmpo\" >/dev/null 2>&1 ; then\n\t\t\t\tCONFIG_LUA=1\n\t\t\t\tprintf \"yes\\n\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tfi\n\n\t\tCFLAGS_LUA=\"\"\n\t\tLDFLAGS_LUA=\"-l$liblua -lm -ldl\"\n\n\t\tif $CC $CFLAGS $CFLAGS_LUA \"$tmpc\" \\\n\t\t\t$LDFLAGS $LDFLAGS_LUA -o \"$tmpo\" >/dev/null 2>&1 ; then\n\t\t\tCONFIG_LUA=1\n\t\t\tprintf \"yes\\n\"\n\t\t\tbreak\n\t\telse\n\t\t\tprintf \"no\\n\"\n\t\t\tCFLAGS_LUA=\"\"\n\t\t\tLDFLAGS_LUA=\"\"\n\t\tfi\n\tdone\n\n\ttest \"$lua\" = \"yes\" -a $CONFIG_LUA -ne 1 && fail \"$0: cannot find liblua\"\n\n\tif test $CONFIG_LUA -eq 1; then\n\t\tCFLAGS_LUA=\"$CFLAGS_LUA -DLUA_COMPAT_5_1 -DLUA_COMPAT_5_2 -DLUA_COMPAT_5_3 -DLUA_COMPAT_ALL\"\n\tfi\nfi\n\nCONFIG_LPEG=0\n\nif test $CONFIG_LUA -eq 1 -a \"$lpeg\" != \"no\" ; then\n\n\tprintf \"checking for Lua statically linked liblpeg...\\n\"\n\ncat > \"$tmpc\" <<EOF\n#include <lua.h>\n#include <lualib.h>\n#include <lauxlib.h>\n\nint main(int argc, char *argv[]) {\n\tlua_State *L = luaL_newstate();\n\tluaL_openlibs(L);\n\textern int luaopen_lpeg(lua_State *L);\n\tlua_getglobal(L, \"package\");\n\tlua_getfield(L, -1, \"preload\");\n\tlua_pushcfunction(L, luaopen_lpeg);\n\tlua_setfield(L, -2, \"lpeg\");\n\tlua_pop(L, 2);\n\tlua_close(L);\n\treturn 0;\n}\nEOF\n\n\tfor liblpeg in lpeg lua5.4-lpeg lua5.3-lpeg lua5.2-lpeg; do\n\t\tprintf \" checking for static %s... \" \"$liblpeg\"\n\n\t\tif test \"$have_pkgconfig\" = \"yes\" ; then\n\t\t\tCFLAGS_LPEG=$(pkg-config --cflags $liblpeg 2>/dev/null)\n\t\t\tLDFLAGS_LPEG=$(pkg-config --libs $liblpeg 2>/dev/null)\n\t\t\tif test $? -eq 0 && $CC $CFLAGS $CFLAGS_LUA $CFLAGS_LPEG \"$tmpc\" \\\n\t\t\t\t$LDFLAGS $LDFLAGS_LUA $LDFLAGS_LPEG -o \"$tmpo\" >/dev/null 2>&1 ; then\n\t\t\t\tCONFIG_LPEG=1\n\t\t\t\tprintf \"yes\\n\"\n\t\t\t\tbreak\n\t\t\tfi\n\t\tfi\n\n\t\tCFLAGS_LPEG=\"\"\n\t\tLDFLAGS_LPEG=\"-l$liblpeg\"\n\n\t\tif $CC $CFLAGS $CFLAGS_LUA $CFLAGS_LPEG \"$tmpc\" \\\n\t\t\t$LDFLAGS $LDFLAGS_LUA $LDFLAGS_LPEG -o \"$tmpo\" >/dev/null 2>&1 ; then\n\t\t\tCONFIG_LPEG=1\n\t\t\tprintf \"yes\\n\"\n\t\t\tbreak\n\t\telse\n\t\t\tprintf \"no\\n\"\n\t\t\tCFLAGS_LPEG=\"\"\n\t\t\tLDFLAGS_LPEG=\"\"\n\t\tfi\n\tdone\n\n\ttest \"$lpeg\" = \"yes\" -a $CONFIG_LPEG -ne 1 && fail \"$0: cannot find liblpeg\"\nfi\n\nCONFIG_ACL=0\n\nif test \"$OS\" = \"Linux\" -a \"$acl\" != \"no\"; then\n\tprintf \"checking for libacl... \"\n\ncat > \"$tmpc\" <<EOF\n#include <sys/types.h>\n#include <sys/acl.h>\n\nint main(int argc, char *argv[]) {\n\tacl_t acl = acl_get_fd(0);\n\treturn 0;\n}\nEOF\n\n\tif test \"$have_pkgconfig\" = \"yes\" ; then\n\t\tCFLAGS_ACL=$(pkg-config --cflags acl 2>/dev/null)\n\t\tLDFLAGS_ACL=$(pkg-config --libs acl 2>/dev/null)\n\tfi\n\n\tif test -z \"$LDFLAGS_ACL\"; then\n\t\tCFLAGS_ACL=\"\"\n\t\tLDFLAGS_ACL=\"-lacl\"\n\tfi\n\n\tif $CC $CFLAGS $CFLAGS_ACL \"$tmpc\" \\\n\t\t$LDFLAGS $LDFLAGS_ACL -o \"$tmpo\" >/dev/null 2>&1; then\n\t\tCONFIG_ACL=1\n\t\tprintf \"%s\\n\" \"yes\"\n\telse\n\t\tprintf \"%s\\n\" \"no\"\n\t\tCFLAGS_ACL=\"\"\n\t\tLDFLAGS_ACL=\"\"\n\t\ttest \"$acl\" = \"yes\" && fail \"$0: cannot find libacl\"\n\tfi\nfi\n\nCONFIG_SELINUX=0\n\nif test \"$OS\" = \"Linux\" -a \"$selinux\" != \"no\"; then\n\tprintf \"checking for libselinux... \"\n\ncat > \"$tmpc\" <<EOF\n#include <selinux/selinux.h>\n\nint main(int argc, char *argv[]) {\n\treturn is_selinux_enabled();\n}\nEOF\n\n\tif test \"$have_pkgconfig\" = \"yes\" ; then\n\t\tCFLAGS_SELINUX=$(pkg-config --cflags selinux 2>/dev/null)\n\t\tLDFLAGS_SELINUX=$(pkg-config --libs selinux 2>/dev/null)\n\tfi\n\n\tif test -z \"$LDFLAGS_SELINUX\"; then\n\t\tCFLAGS_SELINUX=\"\"\n\t\tLDFLAGS_SELINUX=\"-lselinux\"\n\tfi\n\n\tif $CC $CFLAGS $CFLAGS_SELINUX \"$tmpc\" \\\n\t\t$LDFLAGS $LDFLAGS_SELINUX -o \"$tmpo\" >/dev/null 2>&1; then\n\t\tCONFIG_SELINUX=1\n\t\tprintf \"%s\\n\" \"yes\"\n\telse\n\t\tprintf \"%s\\n\" \"no\"\n\t\tCFLAGS_SELINUX=\"\"\n\t\tLDFLAGS_SELINUX=\"\"\n\t\ttest \"$selinux\" = \"yes\" && fail \"$0: cannot find libselinux\"\n\tfi\nfi\n\nprintf \"checking for memrchr... \"\n\ncat > \"$tmpc\" <<EOF\n#define _GNU_SOURCE\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n        return !memrchr(\"\\n\", '\\n', 1);\n}\nEOF\n\nif $CC $CFLAGS $CFLAGS_STD \"$tmpc\" $LDFLAGS -o \"$tmpo\" >/dev/null 2>&1; then\n\tHAVE_MEMRCHR=1\n\tprintf \"%s\\n\" \"yes\"\nelse\n\tHAVE_MEMRCHR=0\n\tprintf \"%s\\n\" \"no\"\nfi\n\nprintf \"completing config.mk... \"\n\nexec 3>&1 1>>config.mk\n\ncat << EOF\nCONFIG_HELP = $CONFIG_HELP\nCFLAGS_TERMKEY = $CFLAGS_TERMKEY\nLDFLAGS_TERMKEY = $LDFLAGS_TERMKEY\nCONFIG_CURSES = $CONFIG_CURSES\nCFLAGS_CURSES = $CFLAGS_CURSES\nLDFLAGS_CURSES = $LDFLAGS_CURSES\nREGEX_SRC = $REGEX_SRC\nCONFIG_TRE = $CONFIG_TRE\nCFLAGS_TRE = $CFLAGS_TRE\nLDFLAGS_TRE = $LDFLAGS_TRE\nCONFIG_LUA = $CONFIG_LUA\nCFLAGS_LUA = $CFLAGS_LUA\nLDFLAGS_LUA = $LDFLAGS_LUA\nCONFIG_LPEG = $CONFIG_LPEG\nCFLAGS_LPEG = $CFLAGS_LPEG\nLDFLAGS_LPEG = $LDFLAGS_LPEG\nCONFIG_ACL = $CONFIG_ACL\nCFLAGS_ACL = $CFLAGS_ACL\nLDFLAGS_ACL = $LDFLAGS_ACL\nCONFIG_SELINUX = $CONFIG_SELINUX\nCFLAGS_SELINUX = $CFLAGS_SELINUX\nLDFLAGS_SELINUX = $LDFLAGS_SELINUX\nCFLAGS_LIBC = -DHAVE_MEMRCHR=$HAVE_MEMRCHR\nEOF\nexec 1>&3 3>&-\n\ntest \"$SRCDIR\" = \".\" || ln -sf $SRCDIR/Makefile .\n\nprintf \"done\\n\"\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "event-basic.c",
          "type": "blob",
          "size": 0.2822265625,
          "content": "#include <stdarg.h>\n\n#include \"vis-core.h\"\n\n#if !CONFIG_LUA\nbool vis_event_emit(Vis *vis, enum VisEvents id, ...) {\n\tva_list ap;\n\tva_start(ap, id);\n\n\tif (id == VIS_EVENT_WIN_STATUS) {\n\t\tWin *win = va_arg(ap, Win*);\n\t\twindow_status_update(vis, win);\n\t}\n\n\tva_end(ap);\n\treturn true;\n}\n#endif\n"
        },
        {
          "name": "libutf.c",
          "type": "blob",
          "size": 1.2216796875,
          "content": "/* libutf8 © 2012-2015 Connor Lane Smith <cls@lubutu.com> */\n#include \"libutf.h\"\n#include \"util.h\"\n\nint\nrunelen(Rune r)\n{\n\tif(r <= 0x7F)\n\t\treturn 1;\n\telse if(r <= 0x07FF)\n\t\treturn 2;\n\telse if(r <= 0xD7FF)\n\t\treturn 3;\n\telse if(r <= 0xDFFF)\n\t\treturn 0; /* surrogate character */\n\telse if(r <= 0xFFFD)\n\t\treturn 3;\n\telse if(r <= 0xFFFF)\n\t\treturn 0; /* illegal character */\n\telse if(r <= Runemax)\n\t\treturn 4;\n\telse\n\t\treturn 0; /* rune too large */\n}\n\nint\nrunetochar(char *s, const Rune *p)\n{\n\tRune r = *p;\n\n\tswitch(runelen(r)) {\n\tcase 1: /* 0aaaaaaa */\n\t\ts[0] = r;\n\t\treturn 1;\n\tcase 2: /* 00000aaa aabbbbbb */\n\t\ts[0] = 0xC0 | ((r & 0x0007C0) >>  6); /* 110aaaaa */\n\t\ts[1] = 0x80 |  (r & 0x00003F);        /* 10bbbbbb */\n\t\treturn 2;\n\tcase 3: /* aaaabbbb bbcccccc */\n\t\ts[0] = 0xE0 | ((r & 0x00F000) >> 12); /* 1110aaaa */\n\t\ts[1] = 0x80 | ((r & 0x000FC0) >>  6); /* 10bbbbbb */\n\t\ts[2] = 0x80 |  (r & 0x00003F);        /* 10cccccc */\n\t\treturn 3;\n\tcase 4: /* 000aaabb bbbbcccc ccdddddd */\n\t\ts[0] = 0xF0 | ((r & 0x1C0000) >> 18); /* 11110aaa */\n\t\ts[1] = 0x80 | ((r & 0x03F000) >> 12); /* 10bbbbbb */\n\t\ts[2] = 0x80 | ((r & 0x000FC0) >>  6); /* 10cccccc */\n\t\ts[3] = 0x80 |  (r & 0x00003F);        /* 10dddddd */\n\t\treturn 4;\n\tdefault:\n\t\treturn 0; /* error */\n\t}\n}\n"
        },
        {
          "name": "libutf.h",
          "type": "blob",
          "size": 0.654296875,
          "content": "#ifndef LIBUTF_H\n#define LIBUTF_H\n\n/* libutf8 © 2012-2015 Connor Lane Smith <cls@lubutu.com> */\n#include <stddef.h>\n#include <stdint.h>\n\n#if __STDC_VERSION__ >= 201112L\n#include <uchar.h>\n#ifdef __STDC_UTF_32__\n#define RUNE_C INT32_C\ntypedef char32_t Rune;\n#endif\n#endif\n\n#ifndef RUNE_C\n#ifdef INT32_C\n#define RUNE_C INT32_C\ntypedef uint_least32_t Rune;\n#else\n#define RUNE_C(x) x##L\ntypedef unsigned long Rune;\n#endif\n#endif\n\n#define UTFmax 4 /* maximum bytes per rune */\n\n#define Runeself 0x80             /* rune and utf are equal (<) */\n#define Runemax  RUNE_C(0x10FFFF) /* maximum rune value */\n\nint runelen(Rune r);\nint runetochar(char *s, const Rune *p);\n\n#endif\n"
        },
        {
          "name": "lua",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 70.119140625,
          "content": "#include <signal.h>\n#include <limits.h>\n#include <string.h>\n#include <stdio.h>\n#include <wchar.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"ui.h\"\n#include \"vis.h\"\n#include \"vis-lua.h\"\n#include \"text-util.h\"\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"util.h\"\n#include \"libutf.h\"\n#include \"array.h\"\n#include \"buffer.h\"\n\n#define PAGE      INT_MAX\n#define PAGE_HALF (INT_MAX-1)\n\n/** functions to be called from keybindings */\n/* ignore key, do nothing */\nstatic const char *nop(Vis*, const char *keys, const Arg *arg);\n/* record/replay macro indicated by keys */\nstatic const char *macro_record(Vis*, const char *keys, const Arg *arg);\nstatic const char *macro_replay(Vis*, const char *keys, const Arg *arg);\n/* temporarily suspend the editor and return to the shell, type 'fg' to get back */\nstatic const char *suspend(Vis*, const char *keys, const Arg *arg);\n/* reset count if set, otherwise remove all but the primary selection */\nstatic const char *normalmode_escape(Vis*, const char *keys, const Arg *arg);\n/* reset count if set, otherwise switch to normal mode */\nstatic const char *visualmode_escape(Vis*, const char *keys, const Arg *arg);\n/* switch to mode indicated by arg->i */\nstatic const char *switchmode(Vis*, const char *keys, const Arg *arg);\n/* switch to insert mode after performing movement indicated by arg->i */\nstatic const char *insertmode(Vis*, const char *keys, const Arg *arg);\n/* switch to replace mode after performing movement indicated by arg->i */\nstatic const char *replacemode(Vis*, const char *keys, const Arg *arg);\n/* add a new line either before or after the one where the cursor currently is */\nstatic const char *openline(Vis*, const char *keys, const Arg *arg);\n/* join lines from current cursor position to movement indicated by arg */\nstatic const char *join(Vis*, const char *keys, const Arg *arg);\n/* perform last action i.e. action_prev again */\nstatic const char *repeat(Vis*, const char *keys, const Arg *arg);\n/* replace character at cursor with one from keys */\nstatic const char *replace(Vis*, const char *keys, const Arg *arg);\n/* create a new cursor on the previous (arg->i < 0) or next (arg->i > 0) line */\nstatic const char *selections_new(Vis*, const char *keys, const Arg *arg);\n/* try to align all selections on the same column */\nstatic const char *selections_align(Vis*, const char *keys, const Arg *arg);\n/* try to align all selections by inserting the correct amount of white spaces */\nstatic const char *selections_align_indent(Vis*, const char *keys, const Arg *arg);\n/* remove all but the primary cursor and their selections */\nstatic const char *selections_clear(Vis*, const char *keys, const Arg *arg);\n/* remove the least recently added selection */\nstatic const char *selections_remove(Vis*, const char *keys, const Arg *arg);\n/* remove count (or arg->i)-th selection column */\nstatic const char *selections_remove_column(Vis*, const char *keys, const Arg *arg);\n/* remove all but the count (or arg->i)-th selection column */\nstatic const char *selections_remove_column_except(Vis*, const char *keys, const Arg *arg);\n/* move to the previous (arg->i < 0) or next (arg->i > 0) selection */\nstatic const char *selections_navigate(Vis*, const char *keys, const Arg *arg);\n/* select the next region matching the current selection */\nstatic const char *selections_match_next(Vis*, const char *keys, const Arg *arg);\n/* clear current selection but select next match */\nstatic const char *selections_match_skip(Vis*, const char *keys, const Arg *arg);\n/* rotate selection content count times left (arg->i < 0) or right (arg->i > 0) */\nstatic const char *selections_rotate(Vis*, const char *keys, const Arg *arg);\n/* remove leading and trailing white spaces from selections */\nstatic const char *selections_trim(Vis*, const char *keys, const Arg *arg);\n/* save active selections to mark */\nstatic const char *selections_save(Vis*, const char *keys, const Arg *arg);\n/* restore selections from mark */\nstatic const char *selections_restore(Vis*, const char *keys, const Arg *arg);\n/* union selections from mark */\nstatic const char *selections_union(Vis*, const char *keys, const Arg *arg);\n/* intersect selections from mark */\nstatic const char *selections_intersect(Vis*, const char *keys, const Arg *arg);\n/* perform complement of current active selections */\nstatic const char *selections_complement(Vis*, const char *keys, const Arg *arg);\n/* subtract selections from mark */\nstatic const char *selections_minus(Vis*, const char *keys, const Arg *arg);\n/* adjust current used count according to keys */\nstatic const char *count(Vis*, const char *keys, const Arg *arg);\n/* move to the count-th line or if not given either to the first (arg->i < 0)\n *  or last (arg->i > 0) line of file */\nstatic const char *gotoline(Vis*, const char *keys, const Arg *arg);\n/* make the current action use the operator indicated by arg->i */\nstatic const char *operator(Vis*, const char *keys, const Arg *arg);\n/* blocks to read a key and performs movement indicated by arg->i which\n * should be one of VIS_MOVE_{TO,TILL}_{,LINE}_{RIGHT,LEFT}*/\nstatic const char *movement_key(Vis*, const char *keys, const Arg *arg);\n/* perform the movement as indicated by arg->i */\nstatic const char *movement(Vis*, const char *keys, const Arg *arg);\n/* let the current operator affect the range indicated by the text object arg->i */\nstatic const char *textobj(Vis*, const char *keys, const Arg *arg);\n/* move to the other end of selected text */\nstatic const char *selection_end(Vis*, const char *keys, const Arg *arg);\n/* use register indicated by keys for the current operator */\nstatic const char *reg(Vis*, const char *keys, const Arg *arg);\n/* use mark indicated by keys for the current action */\nstatic const char *mark(Vis*, const char *keys, const Arg *arg);\n/* {un,re}do last action, redraw window */\nstatic const char *undo(Vis*, const char *keys, const Arg *arg);\nstatic const char *redo(Vis*, const char *keys, const Arg *arg);\n/* earlier, later action chronologically, redraw window */\nstatic const char *earlier(Vis*, const char *keys, const Arg *arg);\nstatic const char *later(Vis*, const char *keys, const Arg *arg);\n/* delete from the current cursor position to the end of\n * movement as indicated by arg->i */\nstatic const char *delete(Vis*, const char *keys, const Arg *arg);\n/* insert register content indicated by keys at current cursor position */\nstatic const char *insert_register(Vis*, const char *keys, const Arg *arg);\n/* show a user prompt to get input with title arg->s */\nstatic const char *prompt_show(Vis*, const char *keys, const Arg *arg);\n/* blocks to read 3 consecutive digits and inserts the corresponding byte value */\nstatic const char *insert_verbatim(Vis*, const char *keys, const Arg *arg);\n/* scroll window content according to arg->i which can be either PAGE, PAGE_HALF,\n * or an arbitrary number of lines. a multiplier overrides what is given in arg->i.\n * negative values scroll back, positive forward. */\nstatic const char *wscroll(Vis*, const char *keys, const Arg *arg);\n/* similar to scroll, but do only move window content not cursor position */\nstatic const char *wslide(Vis*, const char *keys, const Arg *arg);\n/* call editor function as indicated by arg->f */\nstatic const char *call(Vis*, const char *keys, const Arg *arg);\n/* call window function as indicated by arg->w */\nstatic const char *window(Vis*, const char *keys, const Arg *arg);\n/* show info about Unicode character at cursor position */\nstatic const char *unicode_info(Vis*, const char *keys, const Arg *arg);\n/* either go to count % of file or to matching item */\nstatic const char *percent(Vis*, const char *keys, const Arg *arg);\n/* navigate jumplist next (arg->i > 0), prev (arg->i < 0), save (arg->i = 0) */\nstatic const char *jumplist(Vis*, const char *keys, const Arg *arg);\n\nenum {\n\tVIS_ACTION_EDITOR_SUSPEND,\n\tVIS_ACTION_CURSOR_CHAR_PREV,\n\tVIS_ACTION_CURSOR_CHAR_NEXT,\n\tVIS_ACTION_CURSOR_LINE_CHAR_PREV,\n\tVIS_ACTION_CURSOR_LINE_CHAR_NEXT,\n\tVIS_ACTION_CURSOR_CODEPOINT_PREV,\n\tVIS_ACTION_CURSOR_CODEPOINT_NEXT,\n\tVIS_ACTION_CURSOR_WORD_START_PREV,\n\tVIS_ACTION_CURSOR_WORD_START_NEXT,\n\tVIS_ACTION_CURSOR_WORD_END_PREV,\n\tVIS_ACTION_CURSOR_WORD_END_NEXT,\n\tVIS_ACTION_CURSOR_LONGWORD_START_PREV,\n\tVIS_ACTION_CURSOR_LONGWORD_START_NEXT,\n\tVIS_ACTION_CURSOR_LONGWORD_END_PREV,\n\tVIS_ACTION_CURSOR_LONGWORD_END_NEXT,\n\tVIS_ACTION_CURSOR_LINE_UP,\n\tVIS_ACTION_CURSOR_LINE_DOWN,\n\tVIS_ACTION_CURSOR_LINE_START,\n\tVIS_ACTION_CURSOR_LINE_FINISH,\n\tVIS_ACTION_CURSOR_LINE_BEGIN,\n\tVIS_ACTION_CURSOR_LINE_END,\n\tVIS_ACTION_CURSOR_SCREEN_LINE_UP,\n\tVIS_ACTION_CURSOR_SCREEN_LINE_DOWN,\n\tVIS_ACTION_CURSOR_SCREEN_LINE_BEGIN,\n\tVIS_ACTION_CURSOR_SCREEN_LINE_MIDDLE,\n\tVIS_ACTION_CURSOR_SCREEN_LINE_END,\n\tVIS_ACTION_CURSOR_PERCENT,\n\tVIS_ACTION_CURSOR_BYTE,\n\tVIS_ACTION_CURSOR_BYTE_LEFT,\n\tVIS_ACTION_CURSOR_BYTE_RIGHT,\n\tVIS_ACTION_CURSOR_PARAGRAPH_PREV,\n\tVIS_ACTION_CURSOR_PARAGRAPH_NEXT,\n\tVIS_ACTION_CURSOR_SENTENCE_PREV,\n\tVIS_ACTION_CURSOR_SENTENCE_NEXT,\n\tVIS_ACTION_CURSOR_BLOCK_START,\n\tVIS_ACTION_CURSOR_BLOCK_END,\n\tVIS_ACTION_CURSOR_PARENTHESIS_START,\n\tVIS_ACTION_CURSOR_PARENTHESIS_END,\n\tVIS_ACTION_CURSOR_COLUMN,\n\tVIS_ACTION_CURSOR_LINE_FIRST,\n\tVIS_ACTION_CURSOR_LINE_LAST,\n\tVIS_ACTION_CURSOR_WINDOW_LINE_TOP,\n\tVIS_ACTION_CURSOR_WINDOW_LINE_MIDDLE,\n\tVIS_ACTION_CURSOR_WINDOW_LINE_BOTTOM,\n\tVIS_ACTION_CURSOR_SEARCH_REPEAT_FORWARD,\n\tVIS_ACTION_CURSOR_SEARCH_REPEAT_BACKWARD,\n\tVIS_ACTION_CURSOR_SEARCH_REPEAT,\n\tVIS_ACTION_CURSOR_SEARCH_REPEAT_REVERSE,\n\tVIS_ACTION_CURSOR_SEARCH_WORD_FORWARD,\n\tVIS_ACTION_CURSOR_SEARCH_WORD_BACKWARD,\n\tVIS_ACTION_WINDOW_PAGE_UP,\n\tVIS_ACTION_WINDOW_PAGE_DOWN,\n\tVIS_ACTION_WINDOW_HALFPAGE_UP,\n\tVIS_ACTION_WINDOW_HALFPAGE_DOWN,\n\tVIS_ACTION_MODE_NORMAL,\n\tVIS_ACTION_MODE_NORMAL_ESCAPE,\n\tVIS_ACTION_MODE_VISUAL,\n\tVIS_ACTION_MODE_VISUAL_ESCAPE,\n\tVIS_ACTION_MODE_VISUAL_LINE,\n\tVIS_ACTION_MODE_INSERT,\n\tVIS_ACTION_MODE_REPLACE,\n\tVIS_ACTION_DELETE_CHAR_PREV,\n\tVIS_ACTION_DELETE_CHAR_NEXT,\n\tVIS_ACTION_DELETE_LINE_BEGIN,\n\tVIS_ACTION_DELETE_WORD_PREV,\n\tVIS_ACTION_JUMPLIST_PREV,\n\tVIS_ACTION_JUMPLIST_NEXT,\n\tVIS_ACTION_JUMPLIST_SAVE,\n\tVIS_ACTION_UNDO,\n\tVIS_ACTION_REDO,\n\tVIS_ACTION_EARLIER,\n\tVIS_ACTION_LATER,\n\tVIS_ACTION_MACRO_RECORD,\n\tVIS_ACTION_MACRO_REPLAY,\n\tVIS_ACTION_MARK,\n\tVIS_ACTION_REDRAW,\n\tVIS_ACTION_REPLACE_CHAR,\n\tVIS_ACTION_TOTILL_REPEAT,\n\tVIS_ACTION_TOTILL_REVERSE,\n\tVIS_ACTION_PROMPT_SEARCH_FORWARD,\n\tVIS_ACTION_PROMPT_SEARCH_BACKWARD,\n\tVIS_ACTION_TILL_LEFT,\n\tVIS_ACTION_TILL_RIGHT,\n\tVIS_ACTION_TILL_LINE_LEFT,\n\tVIS_ACTION_TILL_LINE_RIGHT,\n\tVIS_ACTION_TO_LEFT,\n\tVIS_ACTION_TO_RIGHT,\n\tVIS_ACTION_TO_LINE_LEFT,\n\tVIS_ACTION_TO_LINE_RIGHT,\n\tVIS_ACTION_REGISTER,\n\tVIS_ACTION_OPERATOR_CHANGE,\n\tVIS_ACTION_OPERATOR_DELETE,\n\tVIS_ACTION_OPERATOR_YANK,\n\tVIS_ACTION_OPERATOR_SHIFT_LEFT,\n\tVIS_ACTION_OPERATOR_SHIFT_RIGHT,\n\tVIS_ACTION_COUNT,\n\tVIS_ACTION_INSERT_NEWLINE,\n\tVIS_ACTION_INSERT_TAB,\n\tVIS_ACTION_INSERT_VERBATIM,\n\tVIS_ACTION_INSERT_REGISTER,\n\tVIS_ACTION_WINDOW_NEXT,\n\tVIS_ACTION_WINDOW_PREV,\n\tVIS_ACTION_APPEND_CHAR_NEXT,\n\tVIS_ACTION_APPEND_LINE_END,\n\tVIS_ACTION_INSERT_LINE_START,\n\tVIS_ACTION_OPEN_LINE_ABOVE,\n\tVIS_ACTION_OPEN_LINE_BELOW,\n\tVIS_ACTION_JOIN_LINES,\n\tVIS_ACTION_JOIN_LINES_TRIM,\n\tVIS_ACTION_PROMPT_SHOW,\n\tVIS_ACTION_REPEAT,\n\tVIS_ACTION_SELECTION_FLIP,\n\tVIS_ACTION_WINDOW_REDRAW_TOP,\n\tVIS_ACTION_WINDOW_REDRAW_CENTER,\n\tVIS_ACTION_WINDOW_REDRAW_BOTTOM,\n\tVIS_ACTION_WINDOW_SLIDE_UP,\n\tVIS_ACTION_WINDOW_SLIDE_DOWN,\n\tVIS_ACTION_PUT_AFTER,\n\tVIS_ACTION_PUT_BEFORE,\n\tVIS_ACTION_SELECTIONS_NEW_LINE_ABOVE,\n\tVIS_ACTION_SELECTIONS_NEW_LINE_ABOVE_FIRST,\n\tVIS_ACTION_SELECTIONS_NEW_LINE_BELOW,\n\tVIS_ACTION_SELECTIONS_NEW_LINE_BELOW_LAST,\n\tVIS_ACTION_SELECTIONS_NEW_LINES_BEGIN,\n\tVIS_ACTION_SELECTIONS_NEW_LINES_END,\n\tVIS_ACTION_SELECTIONS_NEW_MATCH_ALL,\n\tVIS_ACTION_SELECTIONS_NEW_MATCH_NEXT,\n\tVIS_ACTION_SELECTIONS_NEW_MATCH_SKIP,\n\tVIS_ACTION_SELECTIONS_ALIGN,\n\tVIS_ACTION_SELECTIONS_ALIGN_INDENT_LEFT,\n\tVIS_ACTION_SELECTIONS_ALIGN_INDENT_RIGHT,\n\tVIS_ACTION_SELECTIONS_REMOVE_ALL,\n\tVIS_ACTION_SELECTIONS_REMOVE_LAST,\n\tVIS_ACTION_SELECTIONS_REMOVE_COLUMN,\n\tVIS_ACTION_SELECTIONS_REMOVE_COLUMN_EXCEPT,\n\tVIS_ACTION_SELECTIONS_PREV,\n\tVIS_ACTION_SELECTIONS_NEXT,\n\tVIS_ACTION_SELECTIONS_ROTATE_LEFT,\n\tVIS_ACTION_SELECTIONS_ROTATE_RIGHT,\n\tVIS_ACTION_SELECTIONS_TRIM,\n\tVIS_ACTION_SELECTIONS_SAVE,\n\tVIS_ACTION_SELECTIONS_RESTORE,\n\tVIS_ACTION_SELECTIONS_UNION,\n\tVIS_ACTION_SELECTIONS_INTERSECT,\n\tVIS_ACTION_SELECTIONS_COMPLEMENT,\n\tVIS_ACTION_SELECTIONS_MINUS,\n\tVIS_ACTION_TEXT_OBJECT_WORD_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_WORD_INNER,\n\tVIS_ACTION_TEXT_OBJECT_LONGWORD_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_LONGWORD_INNER,\n\tVIS_ACTION_TEXT_OBJECT_SENTENCE,\n\tVIS_ACTION_TEXT_OBJECT_PARAGRAPH,\n\tVIS_ACTION_TEXT_OBJECT_PARAGRAPH_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_SQUARE_BRACKET_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_SQUARE_BRACKET_INNER,\n\tVIS_ACTION_TEXT_OBJECT_PARENTHESIS_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_PARENTHESIS_INNER,\n\tVIS_ACTION_TEXT_OBJECT_ANGLE_BRACKET_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_ANGLE_BRACKET_INNER,\n\tVIS_ACTION_TEXT_OBJECT_CURLY_BRACKET_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_CURLY_BRACKET_INNER,\n\tVIS_ACTION_TEXT_OBJECT_QUOTE_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_QUOTE_INNER,\n\tVIS_ACTION_TEXT_OBJECT_SINGLE_QUOTE_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_SINGLE_QUOTE_INNER,\n\tVIS_ACTION_TEXT_OBJECT_BACKTICK_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_BACKTICK_INNER,\n\tVIS_ACTION_TEXT_OBJECT_LINE_OUTER,\n\tVIS_ACTION_TEXT_OBJECT_LINE_INNER,\n\tVIS_ACTION_TEXT_OBJECT_INDENTATION,\n\tVIS_ACTION_TEXT_OBJECT_SEARCH_FORWARD,\n\tVIS_ACTION_TEXT_OBJECT_SEARCH_BACKWARD,\n\tVIS_ACTION_UNICODE_INFO,\n\tVIS_ACTION_UTF8_INFO,\n\tVIS_ACTION_NOP,\n};\n\nstatic const KeyAction vis_action[] = {\n\t[VIS_ACTION_EDITOR_SUSPEND] = {\n\t\t\"vis-suspend\",\n\t\tVIS_HELP(\"Suspend the editor\")\n\t\tsuspend,\n\t},\n\t[VIS_ACTION_CURSOR_CHAR_PREV] = {\n\t\t\"vis-motion-char-prev\",\n\t\tVIS_HELP(\"Move cursor left, to the previous character\")\n\t\tmovement, { .i = VIS_MOVE_CHAR_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_CHAR_NEXT] = {\n\t\t\"vis-motion-char-next\",\n\t\tVIS_HELP(\"Move cursor right, to the next character\")\n\t\tmovement, { .i = VIS_MOVE_CHAR_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_CHAR_PREV] = {\n\t\t\"vis-motion-line-char-prev\",\n\t\tVIS_HELP(\"Move cursor left, to the previous character on the same line\")\n\t\tmovement, { .i = VIS_MOVE_LINE_CHAR_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_CHAR_NEXT] = {\n\t\t\"vis-motion-line-char-next\",\n\t\tVIS_HELP(\"Move cursor right, to the next character on the same line\")\n\t\tmovement, { .i = VIS_MOVE_LINE_CHAR_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_CODEPOINT_PREV] = {\n\t\t\"vis-motion-codepoint-prev\",\n\t\tVIS_HELP(\"Move to the previous Unicode codepoint\")\n\t\tmovement, { .i = VIS_MOVE_CODEPOINT_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_CODEPOINT_NEXT] = {\n\t\t\"vis-motion-codepoint-next\",\n\t\tVIS_HELP(\"Move to the next Unicode codepoint\")\n\t\tmovement, { .i = VIS_MOVE_CODEPOINT_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_WORD_START_PREV] = {\n\t\t\"vis-motion-word-start-prev\",\n\t\tVIS_HELP(\"Move cursor words backwards\")\n\t\tmovement, { .i = VIS_MOVE_WORD_START_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_WORD_START_NEXT] = {\n\t\t\"vis-motion-word-start-next\",\n\t\tVIS_HELP(\"Move cursor words forwards\")\n\t\tmovement, { .i = VIS_MOVE_WORD_START_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_WORD_END_PREV] = {\n\t\t\"vis-motion-word-end-prev\",\n\t\tVIS_HELP(\"Move cursor backwards to the end of word\")\n\t\tmovement, { .i = VIS_MOVE_WORD_END_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_WORD_END_NEXT] = {\n\t\t\"vis-motion-word-end-next\",\n\t\tVIS_HELP(\"Move cursor forward to the end of word\")\n\t\tmovement, { .i = VIS_MOVE_WORD_END_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_LONGWORD_START_PREV] = {\n\t\t\"vis-motion-bigword-start-prev\",\n\t\tVIS_HELP(\"Move cursor WORDS backwards\")\n\t\tmovement, { .i = VIS_MOVE_LONGWORD_START_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_LONGWORD_START_NEXT] = {\n\t\t\"vis-motion-bigword-start-next\",\n\t\tVIS_HELP(\"Move cursor WORDS forwards\")\n\t\tmovement, { .i = VIS_MOVE_LONGWORD_START_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_LONGWORD_END_PREV] = {\n\t\t\"vis-motion-bigword-end-prev\",\n\t\tVIS_HELP(\"Move cursor backwards to the end of WORD\")\n\t\tmovement, { .i = VIS_MOVE_LONGWORD_END_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_LONGWORD_END_NEXT] = {\n\t\t\"vis-motion-bigword-end-next\",\n\t\tVIS_HELP(\"Move cursor forward to the end of WORD\")\n\t\tmovement, { .i = VIS_MOVE_LONGWORD_END_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_UP] = {\n\t\t\"vis-motion-line-up\",\n\t\tVIS_HELP(\"Move cursor line upwards\")\n\t\tmovement, { .i = VIS_MOVE_LINE_UP }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_DOWN] = {\n\t\t\"vis-motion-line-down\",\n\t\tVIS_HELP(\"Move cursor line downwards\")\n\t\tmovement, { .i = VIS_MOVE_LINE_DOWN }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_START] = {\n\t\t\"vis-motion-line-start\",\n\t\tVIS_HELP(\"Move cursor to first non-blank character of the line\")\n\t\tmovement, { .i = VIS_MOVE_LINE_START }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_FINISH] = {\n\t\t\"vis-motion-line-finish\",\n\t\tVIS_HELP(\"Move cursor to last non-blank character of the line\")\n\t\tmovement, { .i = VIS_MOVE_LINE_FINISH }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_BEGIN] = {\n\t\t\"vis-motion-line-begin\",\n\t\tVIS_HELP(\"Move cursor to first character of the line\")\n\t\tmovement, { .i = VIS_MOVE_LINE_BEGIN }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_END] = {\n\t\t\"vis-motion-line-end\",\n\t\tVIS_HELP(\"Move cursor to end of the line\")\n\t\tmovement, { .i = VIS_MOVE_LINE_END }\n\t},\n\t[VIS_ACTION_CURSOR_SCREEN_LINE_UP] = {\n\t\t\"vis-motion-screenline-up\",\n\t\tVIS_HELP(\"Move cursor screen/display line upwards\")\n\t\tmovement, { .i = VIS_MOVE_SCREEN_LINE_UP }\n\t},\n\t[VIS_ACTION_CURSOR_SCREEN_LINE_DOWN] = {\n\t\t\"vis-motion-screenline-down\",\n\t\tVIS_HELP(\"Move cursor screen/display line downwards\")\n\t\tmovement, { .i = VIS_MOVE_SCREEN_LINE_DOWN }\n\t},\n\t[VIS_ACTION_CURSOR_SCREEN_LINE_BEGIN] = {\n\t\t\"vis-motion-screenline-begin\",\n\t\tVIS_HELP(\"Move cursor to beginning of screen/display line\")\n\t\tmovement, { .i = VIS_MOVE_SCREEN_LINE_BEGIN }\n\t},\n\t[VIS_ACTION_CURSOR_SCREEN_LINE_MIDDLE] = {\n\t\t\"vis-motion-screenline-middle\",\n\t\tVIS_HELP(\"Move cursor to middle of screen/display line\")\n\t\tmovement, { .i = VIS_MOVE_SCREEN_LINE_MIDDLE }\n\t},\n\t[VIS_ACTION_CURSOR_SCREEN_LINE_END] = {\n\t\t\"vis-motion-screenline-end\",\n\t\tVIS_HELP(\"Move cursor to end of screen/display line\")\n\t\tmovement, { .i = VIS_MOVE_SCREEN_LINE_END }\n\t},\n\t[VIS_ACTION_CURSOR_PERCENT] = {\n\t\t\"vis-motion-percent\",\n\t\tVIS_HELP(\"Move to count % of file or matching item\")\n\t\tpercent\n\t},\n\t[VIS_ACTION_CURSOR_BYTE] = {\n\t\t\"vis-motion-byte\",\n\t\tVIS_HELP(\"Move to absolute byte position\")\n\t\tmovement, { .i = VIS_MOVE_BYTE }\n\t},\n\t[VIS_ACTION_CURSOR_BYTE_LEFT] = {\n\t\t\"vis-motion-byte-left\",\n\t\tVIS_HELP(\"Move count bytes to the left\")\n\t\tmovement, { .i = VIS_MOVE_BYTE_LEFT }\n\t},\n\t[VIS_ACTION_CURSOR_BYTE_RIGHT] = {\n\t\t\"vis-motion-byte-right\",\n\t\tVIS_HELP(\"Move count bytes to the right\")\n\t\tmovement, { .i = VIS_MOVE_BYTE_RIGHT }\n\t},\n\t[VIS_ACTION_CURSOR_PARAGRAPH_PREV] = {\n\t\t\"vis-motion-paragraph-prev\",\n\t\tVIS_HELP(\"Move cursor paragraph backward\")\n\t\tmovement, { .i = VIS_MOVE_PARAGRAPH_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_PARAGRAPH_NEXT] = {\n\t\t\"vis-motion-paragraph-next\",\n\t\tVIS_HELP(\"Move cursor paragraph forward\")\n\t\tmovement, { .i = VIS_MOVE_PARAGRAPH_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_SENTENCE_PREV] = {\n\t\t\"vis-motion-sentence-prev\",\n\t\tVIS_HELP(\"Move cursor sentence backward\")\n\t\tmovement, { .i = VIS_MOVE_SENTENCE_PREV }\n\t},\n\t[VIS_ACTION_CURSOR_SENTENCE_NEXT] = {\n\t\t\"vis-motion-sentence-next\",\n\t\tVIS_HELP(\"Move cursor sentence forward\")\n\t\tmovement, { .i = VIS_MOVE_SENTENCE_NEXT }\n\t},\n\t[VIS_ACTION_CURSOR_BLOCK_START] = {\n\t\t\"vis-motion-block-start\",\n\t\tVIS_HELP(\"Move cursor to the opening curly brace in a block\")\n\t\tmovement, { .i = VIS_MOVE_BLOCK_START }\n\t},\n\t[VIS_ACTION_CURSOR_BLOCK_END] = {\n\t\t\"vis-motion-block-end\",\n\t\tVIS_HELP(\"Move cursor to the closing curly brace in a block\")\n\t\tmovement, { .i = VIS_MOVE_BLOCK_END }\n\t},\n\t[VIS_ACTION_CURSOR_PARENTHESIS_START] = {\n\t\t\"vis-motion-parenthesis-start\",\n\t\tVIS_HELP(\"Move cursor to the opening parenthesis inside a pair of parentheses\")\n\t\tmovement, { .i = VIS_MOVE_PARENTHESIS_START }\n\t},\n\t[VIS_ACTION_CURSOR_PARENTHESIS_END] = {\n\t\t\"vis-motion-parenthesis-end\",\n\t\tVIS_HELP(\"Move cursor to the closing parenthesis inside a pair of parentheses\")\n\t\tmovement, { .i = VIS_MOVE_PARENTHESIS_END }\n\t},\n\t[VIS_ACTION_CURSOR_COLUMN] = {\n\t\t\"vis-motion-column\",\n\t\tVIS_HELP(\"Move cursor to given column of current line\")\n\t\tmovement, { .i = VIS_MOVE_COLUMN }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_FIRST] = {\n\t\t\"vis-motion-line-first\",\n\t\tVIS_HELP(\"Move cursor to given line (defaults to first)\")\n\t\tgotoline, { .i = -1 }\n\t},\n\t[VIS_ACTION_CURSOR_LINE_LAST] = {\n\t\t\"vis-motion-line-last\",\n\t\tVIS_HELP(\"Move cursor to given line (defaults to last)\")\n\t\tgotoline, { .i = +1 }\n\t},\n\t[VIS_ACTION_CURSOR_WINDOW_LINE_TOP] = {\n\t\t\"vis-motion-window-line-top\",\n\t\tVIS_HELP(\"Move cursor to top line of the window\")\n\t\tmovement, { .i = VIS_MOVE_WINDOW_LINE_TOP }\n\t},\n\t[VIS_ACTION_CURSOR_WINDOW_LINE_MIDDLE] = {\n\t\t\"vis-motion-window-line-middle\",\n\t\tVIS_HELP(\"Move cursor to middle line of the window\")\n\t\tmovement, { .i = VIS_MOVE_WINDOW_LINE_MIDDLE }\n\t},\n\t[VIS_ACTION_CURSOR_WINDOW_LINE_BOTTOM] = {\n\t\t\"vis-motion-window-line-bottom\",\n\t\tVIS_HELP(\"Move cursor to bottom line of the window\")\n\t\tmovement, { .i = VIS_MOVE_WINDOW_LINE_BOTTOM }\n\t},\n\t[VIS_ACTION_CURSOR_SEARCH_REPEAT_FORWARD] = {\n\t\t\"vis-motion-search-repeat-forward\",\n\t\tVIS_HELP(\"Move cursor to next match in forward direction\")\n\t\tmovement, { .i = VIS_MOVE_SEARCH_REPEAT_FORWARD }\n\t},\n\t[VIS_ACTION_CURSOR_SEARCH_REPEAT_BACKWARD] = {\n\t\t\"vis-motion-search-repeat-backward\",\n\t\tVIS_HELP(\"Move cursor to previous match in backward direction\")\n\t\tmovement, { .i = VIS_MOVE_SEARCH_REPEAT_BACKWARD }\n\t},\n\t[VIS_ACTION_CURSOR_SEARCH_REPEAT] = {\n\t\t\"vis-motion-search-repeat\",\n\t\tVIS_HELP(\"Move cursor to next match\")\n\t\tmovement, { .i = VIS_MOVE_SEARCH_REPEAT }\n\t},\n\t[VIS_ACTION_CURSOR_SEARCH_REPEAT_REVERSE] = {\n\t\t\"vis-motion-search-repeat-reverse\",\n\t\tVIS_HELP(\"Move cursor to next match in opposite direction\")\n\t\tmovement, { .i = VIS_MOVE_SEARCH_REPEAT_REVERSE }\n\t},\n\t[VIS_ACTION_CURSOR_SEARCH_WORD_FORWARD] = {\n\t\t\"vis-motion-search-word-forward\",\n\t\tVIS_HELP(\"Move cursor to next occurrence of the word under cursor\")\n\t\tmovement, { .i = VIS_MOVE_SEARCH_WORD_FORWARD }\n\t},\n\t[VIS_ACTION_CURSOR_SEARCH_WORD_BACKWARD] = {\n\t\t\"vis-motion-search-word-backward\",\n\t\tVIS_HELP(\"Move cursor to previous occurrence of the word under cursor\")\n\t\tmovement, { .i = VIS_MOVE_SEARCH_WORD_BACKWARD }\n\t},\n\t[VIS_ACTION_WINDOW_PAGE_UP] = {\n\t\t\"vis-window-page-up\",\n\t\tVIS_HELP(\"Scroll window pages backwards (upwards)\")\n\t\twscroll, { .i = -PAGE }\n\t},\n\t[VIS_ACTION_WINDOW_HALFPAGE_UP] = {\n\t\t\"vis-window-halfpage-up\",\n\t\tVIS_HELP(\"Scroll window half pages backwards (upwards)\")\n\t\twscroll, { .i = -PAGE_HALF }\n\t},\n\t[VIS_ACTION_WINDOW_PAGE_DOWN] = {\n\t\t\"vis-window-page-down\",\n\t\tVIS_HELP(\"Scroll window pages forwards (downwards)\")\n\t\twscroll, { .i = +PAGE }\n\t},\n\t[VIS_ACTION_WINDOW_HALFPAGE_DOWN] = {\n\t\t\"vis-window-halfpage-down\",\n\t\tVIS_HELP(\"Scroll window half pages forwards (downwards)\")\n\t\twscroll, { .i = +PAGE_HALF }\n\t},\n\t[VIS_ACTION_MODE_NORMAL] = {\n\t\t\"vis-mode-normal\",\n\t\tVIS_HELP(\"Enter normal mode\")\n\t\tswitchmode, { .i = VIS_MODE_NORMAL }\n\t},\n\t[VIS_ACTION_MODE_NORMAL_ESCAPE] = {\n\t\t\"vis-mode-normal-escape\",\n\t\tVIS_HELP(\"Reset count or remove all non-primary selections\")\n\t\tnormalmode_escape,\n\t},\n\t[VIS_ACTION_MODE_VISUAL] = {\n\t\t\"vis-mode-visual-charwise\",\n\t\tVIS_HELP(\"Enter characterwise visual mode\")\n\t\tswitchmode, { .i = VIS_MODE_VISUAL }\n\t},\n\t[VIS_ACTION_MODE_VISUAL_ESCAPE] = {\n\t\t\"vis-mode-visual-escape\",\n\t\tVIS_HELP(\"Reset count or switch to normal mode\")\n\t\tvisualmode_escape,\n\t},\n\t[VIS_ACTION_MODE_VISUAL_LINE] = {\n\t\t\"vis-mode-visual-linewise\",\n\t\tVIS_HELP(\"Enter linewise visual mode\")\n\t\tswitchmode, { .i = VIS_MODE_VISUAL_LINE }\n\t},\n\t[VIS_ACTION_MODE_INSERT] = {\n\t\t\"vis-mode-insert\",\n\t\tVIS_HELP(\"Enter insert mode\")\n\t\tinsertmode, { .i = VIS_MOVE_NOP }\n\t},\n\t[VIS_ACTION_MODE_REPLACE] = {\n\t\t\"vis-mode-replace\",\n\t\tVIS_HELP(\"Enter replace mode\")\n\t\treplacemode, { .i = VIS_MOVE_NOP }\n\t},\n\t[VIS_ACTION_DELETE_CHAR_PREV] = {\n\t\t\"vis-delete-char-prev\",\n\t\tVIS_HELP(\"Delete the previous character\")\n\t\tdelete, { .i = VIS_MOVE_CHAR_PREV }\n\t},\n\t[VIS_ACTION_DELETE_CHAR_NEXT] = {\n\t\t\"vis-delete-char-next\",\n\t\tVIS_HELP(\"Delete the next character\")\n\t\tdelete, { .i = VIS_MOVE_CHAR_NEXT }\n\t},\n\t[VIS_ACTION_DELETE_LINE_BEGIN] = {\n\t\t\"vis-delete-line-begin\",\n\t\tVIS_HELP(\"Delete until the start of the current line\")\n\t\tdelete, { .i = VIS_MOVE_LINE_BEGIN }\n\t},\n\t[VIS_ACTION_DELETE_WORD_PREV] = {\n\t\t\"vis-delete-word-prev\",\n\t\tVIS_HELP(\"Delete the previous WORD\")\n\t\tdelete, { .i = VIS_MOVE_WORD_START_PREV }\n\t},\n\t[VIS_ACTION_JUMPLIST_PREV] = {\n\t\t\"vis-jumplist-prev\",\n\t\tVIS_HELP(\"Go to older cursor position in jump list\")\n\t\tjumplist, { .i = -1 }\n\t},\n\t[VIS_ACTION_JUMPLIST_NEXT] = {\n\t\t\"vis-jumplist-next\",\n\t\tVIS_HELP(\"Go to newer cursor position in jump list\")\n\t\tjumplist, { .i = +1 }\n\t},\n\t[VIS_ACTION_JUMPLIST_SAVE] = {\n\t\t\"vis-jumplist-save\",\n\t\tVIS_HELP(\"Save current selections in jump list\")\n\t\tjumplist, { .i = 0 }\n\t},\n\t[VIS_ACTION_UNDO] = {\n\t\t\"vis-undo\",\n\t\tVIS_HELP(\"Undo last change\")\n\t\tundo,\n\t},\n\t[VIS_ACTION_REDO] = {\n\t\t\"vis-redo\",\n\t\tVIS_HELP(\"Redo last change\")\n\t\tredo,\n\t},\n\t[VIS_ACTION_EARLIER] = {\n\t\t\"vis-earlier\",\n\t\tVIS_HELP(\"Goto older text state\")\n\t\tearlier,\n\t},\n\t[VIS_ACTION_LATER] = {\n\t\t\"vis-later\",\n\t\tVIS_HELP(\"Goto newer text state\")\n\t\tlater,\n\t},\n\t[VIS_ACTION_MACRO_RECORD] = {\n\t\t\"vis-macro-record\",\n\t\tVIS_HELP(\"Record macro into given register\")\n\t\tmacro_record,\n\t},\n\t[VIS_ACTION_MACRO_REPLAY] = {\n\t\t\"vis-macro-replay\",\n\t\tVIS_HELP(\"Replay macro, execute the content of the given register\")\n\t\tmacro_replay,\n\t},\n\t[VIS_ACTION_MARK] = {\n\t\t\"vis-mark\",\n\t\tVIS_HELP(\"Use given mark for next action\")\n\t\tmark,\n\t},\n\t[VIS_ACTION_REDRAW] = {\n\t\t\"vis-redraw\",\n\t\tVIS_HELP(\"Redraw current editor content\")\n\t\tcall, { .f = vis_redraw }\n\t},\n\t[VIS_ACTION_REPLACE_CHAR] = {\n\t\t\"vis-replace-char\",\n\t\tVIS_HELP(\"Replace the character under the cursor\")\n\t\treplace,\n\t},\n\t[VIS_ACTION_TOTILL_REPEAT] = {\n\t\t\"vis-motion-totill-repeat\",\n\t\tVIS_HELP(\"Repeat latest to/till motion\")\n\t\tmovement, { .i = VIS_MOVE_TOTILL_REPEAT }\n\t},\n\t[VIS_ACTION_TOTILL_REVERSE] = {\n\t\t\"vis-motion-totill-reverse\",\n\t\tVIS_HELP(\"Repeat latest to/till motion but in opposite direction\")\n\t\tmovement, { .i = VIS_MOVE_TOTILL_REVERSE }\n\t},\n\t[VIS_ACTION_PROMPT_SEARCH_FORWARD] = {\n\t\t\"vis-search-forward\",\n\t\tVIS_HELP(\"Search forward\")\n\t\tprompt_show, { .s = \"/\" }\n\t},\n\t[VIS_ACTION_PROMPT_SEARCH_BACKWARD] = {\n\t\t\"vis-search-backward\",\n\t\tVIS_HELP(\"Search backward\")\n\t\tprompt_show, { .s = \"?\" }\n\t},\n\t[VIS_ACTION_TILL_LEFT] = {\n\t\t\"vis-motion-till-left\",\n\t\tVIS_HELP(\"Till after the occurrence of character to the left\")\n\t\tmovement_key, { .i = VIS_MOVE_TILL_LEFT }\n\t},\n\t[VIS_ACTION_TILL_RIGHT] = {\n\t\t\"vis-motion-till-right\",\n\t\tVIS_HELP(\"Till before the occurrence of character to the right\")\n\t\tmovement_key, { .i = VIS_MOVE_TILL_RIGHT }\n\t},\n\t[VIS_ACTION_TILL_LINE_LEFT] = {\n\t\t\"vis-motion-till-line-left\",\n\t\tVIS_HELP(\"Till after the occurrence of character to the left on the current line\")\n\t\tmovement_key, { .i = VIS_MOVE_TILL_LINE_LEFT }\n\t},\n\t[VIS_ACTION_TILL_LINE_RIGHT] = {\n\t\t\"vis-motion-till-line-right\",\n\t\tVIS_HELP(\"Till before the occurrence of character to the right on the current line\")\n\t\tmovement_key, { .i = VIS_MOVE_TILL_LINE_RIGHT }\n\t},\n\t[VIS_ACTION_TO_LEFT] = {\n\t\t\"vis-motion-to-left\",\n\t\tVIS_HELP(\"To the first occurrence of character to the left\")\n\t\tmovement_key, { .i = VIS_MOVE_TO_LEFT }\n\t},\n\t[VIS_ACTION_TO_RIGHT] = {\n\t\t\"vis-motion-to-right\",\n\t\tVIS_HELP(\"To the first occurrence of character to the right\")\n\t\tmovement_key, { .i = VIS_MOVE_TO_RIGHT }\n\t},\n\t[VIS_ACTION_TO_LINE_LEFT] = {\n\t\t\"vis-motion-to-line-left\",\n\t\tVIS_HELP(\"To the first occurrence of character to the left on the current line\")\n\t\tmovement_key, { .i = VIS_MOVE_TO_LINE_LEFT }\n\t},\n\t[VIS_ACTION_TO_LINE_RIGHT] = {\n\t\t\"vis-motion-to-line-right\",\n\t\tVIS_HELP(\"To the first occurrence of character to the right on the current line\")\n\t\tmovement_key, { .i = VIS_MOVE_TO_LINE_RIGHT }\n\t},\n\t[VIS_ACTION_REGISTER] = {\n\t\t\"vis-register\",\n\t\tVIS_HELP(\"Use given register for next operator\")\n\t\treg,\n\t},\n\t[VIS_ACTION_OPERATOR_CHANGE] = {\n\t\t\"vis-operator-change\",\n\t\tVIS_HELP(\"Change operator\")\n\t\toperator, { .i = VIS_OP_CHANGE }\n\t},\n\t[VIS_ACTION_OPERATOR_DELETE] = {\n\t\t\"vis-operator-delete\",\n\t\tVIS_HELP(\"Delete operator\")\n\t\toperator, { .i = VIS_OP_DELETE }\n\t},\n\t[VIS_ACTION_OPERATOR_YANK] = {\n\t\t\"vis-operator-yank\",\n\t\tVIS_HELP(\"Yank operator\")\n\t\toperator, { .i = VIS_OP_YANK }\n\t},\n\t[VIS_ACTION_OPERATOR_SHIFT_LEFT] = {\n\t\t\"vis-operator-shift-left\",\n\t\tVIS_HELP(\"Shift left operator\")\n\t\toperator, { .i = VIS_OP_SHIFT_LEFT }\n\t},\n\t[VIS_ACTION_OPERATOR_SHIFT_RIGHT] = {\n\t\t\"vis-operator-shift-right\",\n\t\tVIS_HELP(\"Shift right operator\")\n\t\toperator, { .i = VIS_OP_SHIFT_RIGHT }\n\t},\n\t[VIS_ACTION_COUNT] = {\n\t\t\"vis-count\",\n\t\tVIS_HELP(\"Count specifier\")\n\t\tcount,\n\t},\n\t[VIS_ACTION_INSERT_NEWLINE] = {\n\t\t\"vis-insert-newline\",\n\t\tVIS_HELP(\"Insert a line break (depending on file type)\")\n\t\tcall, { .f = vis_insert_nl }\n\t},\n\t[VIS_ACTION_INSERT_TAB] = {\n\t\t\"vis-insert-tab\",\n\t\tVIS_HELP(\"Insert a tab (might be converted to spaces)\")\n\t\tcall, { .f = vis_insert_tab }\n\t},\n\t[VIS_ACTION_INSERT_VERBATIM] = {\n\t\t\"vis-insert-verbatim\",\n\t\tVIS_HELP(\"Insert Unicode character based on code point\")\n\t\tinsert_verbatim,\n\t},\n\t[VIS_ACTION_INSERT_REGISTER] = {\n\t\t\"vis-insert-register\",\n\t\tVIS_HELP(\"Insert specified register content\")\n\t\tinsert_register,\n\t},\n\t[VIS_ACTION_WINDOW_NEXT] = {\n\t\t\"vis-window-next\",\n\t\tVIS_HELP(\"Focus next window\")\n\t\tcall, { .f = vis_window_next }\n\t},\n\t[VIS_ACTION_WINDOW_PREV] = {\n\t\t\"vis-window-prev\",\n\t\tVIS_HELP(\"Focus previous window\")\n\t\tcall, { .f = vis_window_prev }\n\t},\n\t[VIS_ACTION_APPEND_CHAR_NEXT] = {\n\t\t\"vis-append-char-next\",\n\t\tVIS_HELP(\"Append text after the cursor\")\n\t\tinsertmode, { .i = VIS_MOVE_LINE_CHAR_NEXT }\n\t},\n\t[VIS_ACTION_APPEND_LINE_END] = {\n\t\t\"vis-append-line-end\",\n\t\tVIS_HELP(\"Append text after the end of the line\")\n\t\tinsertmode, { .i = VIS_MOVE_LINE_END },\n\t},\n\t[VIS_ACTION_INSERT_LINE_START] = {\n\t\t\"vis-insert-line-start\",\n\t\tVIS_HELP(\"Insert text before the first non-blank in the line\")\n\t\tinsertmode, { .i = VIS_MOVE_LINE_START },\n\t},\n\t[VIS_ACTION_OPEN_LINE_ABOVE] = {\n\t\t\"vis-open-line-above\",\n\t\tVIS_HELP(\"Begin a new line above the cursor\")\n\t\topenline, { .i = -1 }\n\t},\n\t[VIS_ACTION_OPEN_LINE_BELOW] = {\n\t\t\"vis-open-line-below\",\n\t\tVIS_HELP(\"Begin a new line below the cursor\")\n\t\topenline, { .i = +1 }\n\t},\n\t[VIS_ACTION_JOIN_LINES] = {\n\t\t\"vis-join-lines\",\n\t\tVIS_HELP(\"Join selected lines\")\n\t\tjoin, { .s = \" \" }\n\t},\n\t[VIS_ACTION_JOIN_LINES_TRIM] = {\n\t\t\"vis-join-lines-trim\",\n\t\tVIS_HELP(\"Join selected lines, remove white space\")\n\t\tjoin, { .s = \"\" }\n\t},\n\t[VIS_ACTION_PROMPT_SHOW] = {\n\t\t\"vis-prompt-show\",\n\t\tVIS_HELP(\"Show editor command line prompt\")\n\t\tprompt_show, { .s = \":\" }\n\t},\n\t[VIS_ACTION_REPEAT] = {\n\t\t\"vis-repeat\",\n\t\tVIS_HELP(\"Repeat latest editor command\")\n\t\trepeat\n\t},\n\t[VIS_ACTION_SELECTION_FLIP] = {\n\t\t\"vis-selection-flip\",\n\t\tVIS_HELP(\"Flip selection, move cursor to other end\")\n\t\tselection_end,\n\t},\n\t[VIS_ACTION_WINDOW_REDRAW_TOP] = {\n\t\t\"vis-window-redraw-top\",\n\t\tVIS_HELP(\"Redraw cursor line at the top of the window\")\n\t\twindow, { .w = view_redraw_top }\n\t},\n\t[VIS_ACTION_WINDOW_REDRAW_CENTER] = {\n\t\t\"vis-window-redraw-center\",\n\t\tVIS_HELP(\"Redraw cursor line at the center of the window\")\n\t\twindow, { .w = view_redraw_center }\n\t},\n\t[VIS_ACTION_WINDOW_REDRAW_BOTTOM] = {\n\t\t\"vis-window-redraw-bottom\",\n\t\tVIS_HELP(\"Redraw cursor line at the bottom of the window\")\n\t\twindow, { .w = view_redraw_bottom }\n\t},\n\t[VIS_ACTION_WINDOW_SLIDE_UP] = {\n\t\t\"vis-window-slide-up\",\n\t\tVIS_HELP(\"Slide window content upwards\")\n\t\twslide, { .i = -1 }\n\t},\n\t[VIS_ACTION_WINDOW_SLIDE_DOWN] = {\n\t\t\"vis-window-slide-down\",\n\t\tVIS_HELP(\"Slide window content downwards\")\n\t\twslide, { .i = +1 }\n\t},\n\t[VIS_ACTION_PUT_AFTER] = {\n\t\t\"vis-put-after\",\n\t\tVIS_HELP(\"Put text after the cursor\")\n\t\toperator, { .i = VIS_OP_PUT_AFTER }\n\t},\n\t[VIS_ACTION_PUT_BEFORE] = {\n\t\t\"vis-put-before\",\n\t\tVIS_HELP(\"Put text before the cursor\")\n\t\toperator, { .i = VIS_OP_PUT_BEFORE }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_LINE_ABOVE] = {\n\t\t\"vis-selection-new-lines-above\",\n\t\tVIS_HELP(\"Create a new selection on the line above\")\n\t\tselections_new, { .i = -1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_LINE_ABOVE_FIRST] = {\n\t\t\"vis-selection-new-lines-above-first\",\n\t\tVIS_HELP(\"Create a new selection on the line above the first selection\")\n\t\tselections_new, { .i = INT_MIN }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_LINE_BELOW] = {\n\t\t\"vis-selection-new-lines-below\",\n\t\tVIS_HELP(\"Create a new selection on the line below\")\n\t\tselections_new, { .i = +1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_LINE_BELOW_LAST] = {\n\t\t\"vis-selection-new-lines-below-last\",\n\t\tVIS_HELP(\"Create a new selection on the line below the last selection\")\n\t\tselections_new, { .i = INT_MAX }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_LINES_BEGIN] = {\n\t\t\"vis-selection-new-lines-begin\",\n\t\tVIS_HELP(\"Create a new selection at the start of every line covered by selection\")\n\t\toperator, { .i = VIS_OP_CURSOR_SOL }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_LINES_END] = {\n\t\t\"vis-selection-new-lines-end\",\n\t\tVIS_HELP(\"Create a new selection at the end of every line covered by selection\")\n\t\toperator, { .i = VIS_OP_CURSOR_EOL }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_MATCH_ALL] = {\n\t\t\"vis-selection-new-match-all\",\n\t\tVIS_HELP(\"Select all regions matching the current selection\")\n\t\tselections_match_next, { .b = true }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_MATCH_NEXT] = {\n\t\t\"vis-selection-new-match-next\",\n\t\tVIS_HELP(\"Select the next region matching the current selection\")\n\t\tselections_match_next,\n\t},\n\t[VIS_ACTION_SELECTIONS_NEW_MATCH_SKIP] = {\n\t\t\"vis-selection-new-match-skip\",\n\t\tVIS_HELP(\"Clear current selection, but select next match\")\n\t\tselections_match_skip,\n\t},\n\t[VIS_ACTION_SELECTIONS_ALIGN] = {\n\t\t\"vis-selections-align\",\n\t\tVIS_HELP(\"Try to align all selections on the same column\")\n\t\tselections_align,\n\t},\n\t[VIS_ACTION_SELECTIONS_ALIGN_INDENT_LEFT] = {\n\t\t\"vis-selections-align-indent-left\",\n\t\tVIS_HELP(\"Left-align all selections by inserting spaces\")\n\t\tselections_align_indent, { .i = -1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_ALIGN_INDENT_RIGHT] = {\n\t\t\"vis-selections-align-indent-right\",\n\t\tVIS_HELP(\"Right-align all selections by inserting spaces\")\n\t\tselections_align_indent, { .i = +1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_REMOVE_ALL] = {\n\t\t\"vis-selections-remove-all\",\n\t\tVIS_HELP(\"Remove all but the primary selection\")\n\t\tselections_clear,\n\t},\n\t[VIS_ACTION_SELECTIONS_REMOVE_LAST] = {\n\t\t\"vis-selections-remove-last\",\n\t\tVIS_HELP(\"Remove primary selection\")\n\t\tselections_remove,\n\t},\n\t[VIS_ACTION_SELECTIONS_REMOVE_COLUMN] = {\n\t\t\"vis-selections-remove-column\",\n\t\tVIS_HELP(\"Remove count selection column\")\n\t\tselections_remove_column, { .i = 1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_REMOVE_COLUMN_EXCEPT] = {\n\t\t\"vis-selections-remove-column-except\",\n\t\tVIS_HELP(\"Remove all but the count selection column\")\n\t\tselections_remove_column_except, { .i = 1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_PREV] = {\n\t\t\"vis-selection-prev\",\n\t\tVIS_HELP(\"Move to the previous selection\")\n\t\tselections_navigate, { .i = -PAGE_HALF }\n\t},\n\t[VIS_ACTION_SELECTIONS_NEXT] = {\n\t\t\"vis-selection-next\",\n\t\tVIS_HELP(\"Move to the next selection\")\n\t\tselections_navigate, { .i = +PAGE_HALF }\n\t},\n\t[VIS_ACTION_SELECTIONS_ROTATE_LEFT] = {\n\t\t\"vis-selections-rotate-left\",\n\t\tVIS_HELP(\"Rotate selections left\")\n\t\tselections_rotate, { .i = -1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_ROTATE_RIGHT] = {\n\t\t\"vis-selections-rotate-right\",\n\t\tVIS_HELP(\"Rotate selections right\")\n\t\tselections_rotate, { .i = +1 }\n\t},\n\t[VIS_ACTION_SELECTIONS_TRIM] = {\n\t\t\"vis-selections-trim\",\n\t\tVIS_HELP(\"Remove leading and trailing white space from selections\")\n\t\tselections_trim\n\t},\n\t[VIS_ACTION_SELECTIONS_SAVE] = {\n\t\t\"vis-selections-save\",\n\t\tVIS_HELP(\"Save currently active selections to mark\")\n\t\tselections_save\n\t},\n\t[VIS_ACTION_SELECTIONS_RESTORE] = {\n\t\t\"vis-selections-restore\",\n\t\tVIS_HELP(\"Restore selections from mark\")\n\t\tselections_restore\n\t},\n\t[VIS_ACTION_SELECTIONS_UNION] = {\n\t\t\"vis-selections-union\",\n\t\tVIS_HELP(\"Add selections from mark\")\n\t\tselections_union\n\t},\n\t[VIS_ACTION_SELECTIONS_INTERSECT] = {\n\t\t\"vis-selections-intersect\",\n\t\tVIS_HELP(\"Intersect with selections from mark\")\n\t\tselections_intersect\n\t},\n\t[VIS_ACTION_SELECTIONS_COMPLEMENT] = {\n\t\t\"vis-selections-complement\",\n\t\tVIS_HELP(\"Complement selections\")\n\t\tselections_complement\n\t},\n\t[VIS_ACTION_SELECTIONS_MINUS] = {\n\t\t\"vis-selections-minus\",\n\t\tVIS_HELP(\"Subtract selections from mark\")\n\t\tselections_minus\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_WORD_OUTER] = {\n\t\t\"vis-textobject-word-outer\",\n\t\tVIS_HELP(\"A word leading and trailing whitespace included\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_WORD }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_WORD_INNER] = {\n\t\t\"vis-textobject-word-inner\",\n\t\tVIS_HELP(\"A word leading and trailing whitespace excluded\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_WORD }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_LONGWORD_OUTER] = {\n\t\t\"vis-textobject-bigword-outer\",\n\t\tVIS_HELP(\"A WORD leading and trailing whitespace included\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_LONGWORD }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_LONGWORD_INNER] = {\n\t\t\"vis-textobject-bigword-inner\",\n\t\tVIS_HELP(\"A WORD leading and trailing whitespace excluded\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_LONGWORD }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SENTENCE] = {\n\t\t\"vis-textobject-sentence\",\n\t\tVIS_HELP(\"A sentence\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_SENTENCE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_PARAGRAPH] = {\n\t\t\"vis-textobject-paragraph\",\n\t\tVIS_HELP(\"A paragraph\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_PARAGRAPH }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_PARAGRAPH_OUTER] = {\n\t\t\"vis-textobject-paragraph-outer\",\n\t\tVIS_HELP(\"A paragraph (outer variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_PARAGRAPH_OUTER }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SQUARE_BRACKET_OUTER] = {\n\t\t\"vis-textobject-square-bracket-outer\",\n\t\tVIS_HELP(\"[] block (outer variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_SQUARE_BRACKET }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SQUARE_BRACKET_INNER] = {\n\t\t\"vis-textobject-square-bracket-inner\",\n\t\tVIS_HELP(\"[] block (inner variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_SQUARE_BRACKET }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_PARENTHESIS_OUTER] = {\n\t\t\"vis-textobject-parenthesis-outer\",\n\t\tVIS_HELP(\"() block (outer variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_PARENTHESIS }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_PARENTHESIS_INNER] = {\n\t\t\"vis-textobject-parenthesis-inner\",\n\t\tVIS_HELP(\"() block (inner variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_PARENTHESIS }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_ANGLE_BRACKET_OUTER] = {\n\t\t\"vis-textobject-angle-bracket-outer\",\n\t\tVIS_HELP(\"<> block (outer variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_ANGLE_BRACKET }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_ANGLE_BRACKET_INNER] = {\n\t\t\"vis-textobject-angle-bracket-inner\",\n\t\tVIS_HELP(\"<> block (inner variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_ANGLE_BRACKET }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_CURLY_BRACKET_OUTER] = {\n\t\t\"vis-textobject-curly-bracket-outer\",\n\t\tVIS_HELP(\"{} block (outer variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_CURLY_BRACKET }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_CURLY_BRACKET_INNER] = {\n\t\t\"vis-textobject-curly-bracket-inner\",\n\t\tVIS_HELP(\"{} block (inner variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_CURLY_BRACKET }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_QUOTE_OUTER] = {\n\t\t\"vis-textobject-quote-outer\",\n\t\tVIS_HELP(\"A quoted string, including the quotation marks\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_QUOTE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_QUOTE_INNER] = {\n\t\t\"vis-textobject-quote-inner\",\n\t\tVIS_HELP(\"A quoted string, excluding the quotation marks\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_QUOTE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SINGLE_QUOTE_OUTER] = {\n\t\t\"vis-textobject-single-quote-outer\",\n\t\tVIS_HELP(\"A single quoted string, including the quotation marks\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_SINGLE_QUOTE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SINGLE_QUOTE_INNER] = {\n\t\t\"vis-textobject-single-quote-inner\",\n\t\tVIS_HELP(\"A single quoted string, excluding the quotation marks\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_SINGLE_QUOTE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_BACKTICK_OUTER] = {\n\t\t\"vis-textobject-backtick-outer\",\n\t\tVIS_HELP(\"A backtick delimited string (outer variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_BACKTICK }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_BACKTICK_INNER] = {\n\t\t\"vis-textobject-backtick-inner\",\n\t\tVIS_HELP(\"A backtick delimited string (inner variant)\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_BACKTICK }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_LINE_OUTER] = {\n\t\t\"vis-textobject-line-outer\",\n\t\tVIS_HELP(\"The whole line\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_OUTER_LINE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_LINE_INNER] = {\n\t\t\"vis-textobject-line-inner\",\n\t\tVIS_HELP(\"The whole line, excluding leading and trailing whitespace\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INNER_LINE }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_INDENTATION] = {\n\t\t\"vis-textobject-indentation\",\n\t\tVIS_HELP(\"All adjacent lines with the same indentation level as the current one\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_INDENTATION }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SEARCH_FORWARD] = {\n\t\t\"vis-textobject-search-forward\",\n\t\tVIS_HELP(\"The next search match in forward direction\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_SEARCH_FORWARD }\n\t},\n\t[VIS_ACTION_TEXT_OBJECT_SEARCH_BACKWARD] = {\n\t\t\"vis-textobject-search-backward\",\n\t\tVIS_HELP(\"The next search match in backward direction\")\n\t\ttextobj, { .i = VIS_TEXTOBJECT_SEARCH_BACKWARD }\n\t},\n\t[VIS_ACTION_UNICODE_INFO] = {\n\t\t\"vis-unicode-info\",\n\t\tVIS_HELP(\"Show Unicode codepoint(s) of character under cursor\")\n\t\tunicode_info, { .i = VIS_ACTION_UNICODE_INFO  }\n\t},\n\t[VIS_ACTION_UTF8_INFO] = {\n\t\t\"vis-utf8-info\",\n\t\tVIS_HELP(\"Show UTF-8 encoded codepoint(s) of character under cursor\")\n\t\tunicode_info, { .i = VIS_ACTION_UTF8_INFO }\n\t},\n\t[VIS_ACTION_NOP] = {\n\t\t\"vis-nop\",\n\t\tVIS_HELP(\"Ignore key, do nothing\")\n\t\tnop,\n\t},\n};\n\n#include \"config.h\"\n\n/** key bindings functions */\n\nstatic const char *nop(Vis *vis, const char *keys, const Arg *arg) {\n\treturn keys;\n}\n\nstatic const char *macro_record(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!vis_macro_record_stop(vis)) {\n\t\tif (!keys[0])\n\t\t\treturn NULL;\n\t\tconst char *next = vis_keys_next(vis, keys);\n\t\tif (next - keys > 1)\n\t\t\treturn next;\n\t\tenum VisRegister reg = vis_register_from(vis, keys[0]);\n\t\tvis_macro_record(vis, reg);\n\t\tkeys++;\n\t}\n\tvis_draw(vis);\n\treturn keys;\n}\n\nstatic const char *macro_replay(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!keys[0])\n\t\treturn NULL;\n\tconst char *next = vis_keys_next(vis, keys);\n\tif (next - keys > 1)\n\t\treturn next;\n\tenum VisRegister reg = vis_register_from(vis, keys[0]);\n\tvis_macro_replay(vis, reg);\n\treturn keys+1;\n}\n\nstatic const char *suspend(Vis *vis, const char *keys, const Arg *arg) {\n\tui_terminal_suspend(&vis->ui);\n\treturn keys;\n}\n\nstatic const char *repeat(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_repeat(vis);\n\treturn keys;\n}\n\nstatic const char *selections_new(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tbool anchored = view_selections_primary_get(view)->anchored;\n\tVisCountIterator it = vis_count_iterator_get(vis, 1);\n\twhile (vis_count_iterator_next(&it)) {\n\t\tSelection *sel = NULL;\n\t\tswitch (arg->i) {\n\t\tcase -1:\n\t\tcase +1:\n\t\t\tsel = view_selections_primary_get(view);\n\t\t\tbreak;\n\t\tcase INT_MIN:\n\t\t\tsel = view_selections(view);\n\t\t\tbreak;\n\t\tcase INT_MAX:\n\t\t\tfor (Selection *s = view_selections(view); s; s = view_selections_next(s))\n\t\t\t\tsel = s;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!sel)\n\t\t\treturn keys;\n\n\t\tsize_t oldpos = view_cursors_pos(sel);\n\t\tif (arg->i > 0)\n\t\t\tview_line_down(sel);\n\t\telse if (arg->i < 0)\n\t\t\tview_line_up(sel);\n\t\tsize_t newpos = view_cursors_pos(sel);\n\t\tview_cursors_to(sel, oldpos);\n\t\tSelection *sel_new = view_selections_new(view, newpos);\n\t\tif (!sel_new) {\n\t\t\tif (arg->i == -1)\n\t\t\t\tsel_new = view_selections_prev(sel);\n\t\t\telse if (arg->i == +1)\n\t\t\t\tsel_new = view_selections_next(sel);\n\t\t}\n\t\tif (sel_new) {\n\t\t\tview_selections_primary_set(sel_new);\n\t\t\tsel_new->anchored = anchored;\n\t\t}\n\t}\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *selections_align(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tText *txt = vis_text(vis);\n\tint mincol = INT_MAX;\n\tfor (Selection *s = view_selections(view); s; s = view_selections_next(s)) {\n\t\tif (!s->line)\n\t\t\tcontinue;\n\t\tif (s->col >= 0 && s->col < mincol)\n\t\t\tmincol = s->col;\n\t}\n\tfor (Selection *s = view_selections(view); s; s = view_selections_next(s)) {\n\t\tif (view_cursors_cell_set(s, mincol) == -1) {\n\t\t\tsize_t pos = view_cursors_pos(s);\n\t\t\tsize_t col = text_line_width_set(txt, pos, mincol);\n\t\t\tview_cursors_to(s, col);\n\t\t}\n\t}\n\treturn keys;\n}\n\nstatic const char *selections_align_indent(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tText *txt = vis_text(vis);\n\tbool left_align = arg->i < 0;\n\tint columns = view_selections_column_count(view);\n\n\tfor (int i = 0; i < columns; i++) {\n\t\tint mincol = INT_MAX, maxcol = 0;\n\t\tfor (Selection *s = view_selections_column(view, i); s; s = view_selections_column_next(s, i)) {\n\t\t\tFilerange sel = view_selections_get(s);\n\t\t\tsize_t pos = left_align ? sel.start : sel.end;\n\t\t\tint col = text_line_width_get(txt, pos);\n\t\t\tif (col < mincol)\n\t\t\t\tmincol = col;\n\t\t\tif (col > maxcol)\n\t\t\t\tmaxcol = col;\n\t\t}\n\n\t\tsize_t len = maxcol - mincol;\n\t\tchar *buf = malloc(len+1);\n\t\tif (!buf)\n\t\t\treturn keys;\n\t\tmemset(buf, ' ', len);\n\n\t\tfor (Selection *s = view_selections_column(view, i); s; s = view_selections_column_next(s, i)) {\n\t\t\tFilerange sel = view_selections_get(s);\n\t\t\tsize_t pos = left_align ? sel.start : sel.end;\n\t\t\tsize_t ipos = sel.start;\n\t\t\tint col = text_line_width_get(txt, pos);\n\t\t\tif (col < maxcol) {\n\t\t\t\tsize_t off = maxcol - col;\n\t\t\t\tif (off <= len)\n\t\t\t\t\ttext_insert(txt, ipos, buf, off);\n\t\t\t}\n\t\t}\n\n\t\tfree(buf);\n\t}\n\n\tview_draw(view);\n\treturn keys;\n}\n\nstatic const char *selections_clear(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tif (view->selection_count > 1)\n\t\tview_selections_dispose_all(view);\n\telse\n\t\tview_selection_clear(view_selections_primary_get(view));\n\treturn keys;\n}\n\nstatic Selection *selection_new(View *view, Filerange *r, bool isprimary) {\n\tText *txt = view->text;\n\tsize_t pos = text_char_prev(txt, r->end);\n\tSelection *s = view_selections_new(view, pos);\n\tif (!s)\n\t\treturn NULL;\n\tview_selections_set(s, r);\n\ts->anchored = true;\n\tif (isprimary)\n\t\tview_selections_primary_set(s);\n\treturn s;\n}\n\nstatic const char *selections_match_next(Vis *vis, const char *keys, const Arg *arg) {\n\tText *txt = vis_text(vis);\n\tView *view = vis_view(vis);\n\tSelection *s = view_selections_primary_get(view);\n\tFilerange sel = view_selections_get(s);\n\tif (!text_range_valid(&sel))\n\t\treturn keys;\n\n\tstatic bool match_word;\n\n\tif (view->selection_count == 1) {\n\t\tFilerange word = text_object_word(txt, view_cursors_pos(s));\n\t\tmatch_word = text_range_equal(&sel, &word);\n\t}\n\n\tFilerange (*find_next)(Text *, size_t, const char *) = text_object_word_find_next;\n\tFilerange (*find_prev)(Text *, size_t, const char *) = text_object_word_find_prev;\n\tif (!match_word) {\n\t\tfind_next = text_object_find_next;\n\t\tfind_prev = text_object_find_prev;\n\t}\n\n\tchar *buf = text_bytes_alloc0(txt, sel.start, text_range_size(&sel));\n\tif (!buf)\n\t\treturn keys;\n\n\tbool match_all = arg->b;\n\tFilerange primary = sel;\n\n\tfor (;;) {\n\t\tsel = find_next(txt, sel.end, buf);\n\t\tif (!text_range_valid(&sel))\n\t\t\tbreak;\n\t\tif (selection_new(view, &sel, !match_all) && !match_all)\n\t\t\tgoto out;\n\t}\n\n\tsel = primary;\n\n\tfor (;;) {\n\t\tsel = find_prev(txt, sel.start, buf);\n\t\tif (!text_range_valid(&sel))\n\t\t\tbreak;\n\t\tif (selection_new(view, &sel, !match_all) && !match_all)\n\t\t\tbreak;\n\t}\n\nout:\n\tfree(buf);\n\treturn keys;\n}\n\nstatic const char *selections_match_skip(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tSelection *sel = view_selections_primary_get(view);\n\tkeys = selections_match_next(vis, keys, arg);\n\tif (sel != view_selections_primary_get(view))\n\t\tview_selections_dispose(sel);\n\treturn keys;\n}\n\nstatic const char *selections_remove(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tview_selections_dispose(view_selections_primary_get(view));\n\tview_cursors_to(view->selection, view_cursor_get(view));\n\treturn keys;\n}\n\nstatic const char *selections_remove_column(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tint max = view_selections_column_count(view);\n\tint column = VIS_COUNT_DEFAULT(vis->action.count, arg->i) - 1;\n\tif (column >= max)\n\t\tcolumn = max - 1;\n\tif (view->selection_count == 1) {\n\t\tvis_keys_feed(vis, \"<Escape>\");\n\t\treturn keys;\n\t}\n\n\tfor (Selection *s = view_selections_column(view, column), *next; s; s = next) {\n\t\tnext = view_selections_column_next(s, column);\n\t\tview_selections_dispose(s);\n\t}\n\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *selections_remove_column_except(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tint max = view_selections_column_count(view);\n\tint column = VIS_COUNT_DEFAULT(vis->action.count, arg->i) - 1;\n\tif (column >= max)\n\t\tcolumn = max - 1;\n\tif (view->selection_count == 1) {\n\t\tvis_redraw(vis);\n\t\treturn keys;\n\t}\n\n\tSelection *sel = view_selections(view);\n\tSelection *col = view_selections_column(view, column);\n\tfor (Selection *next; sel; sel = next) {\n\t\tnext = view_selections_next(sel);\n\t\tif (sel == col)\n\t\t\tcol = view_selections_column_next(col, column);\n\t\telse\n\t\t\tview_selections_dispose(sel);\n\t}\n\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *selections_navigate(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tif (view->selection_count == 1)\n\t\treturn wscroll(vis, keys, arg);\n\tSelection *s = view_selections_primary_get(view);\n\tVisCountIterator it = vis_count_iterator_get(vis, 1);\n\twhile (vis_count_iterator_next(&it)) {\n\t\tif (arg->i > 0) {\n\t\t\ts = view_selections_next(s);\n\t\t\tif (!s)\n\t\t\t\ts = view_selections(view);\n\t\t} else {\n\t\t\ts = view_selections_prev(s);\n\t\t\tif (!s) {\n\t\t\t\ts = view_selections(view);\n\t\t\t\tfor (Selection *n = s; n; n = view_selections_next(n))\n\t\t\t\t\ts = n;\n\t\t\t}\n\t\t}\n\t}\n\tview_selections_primary_set(s);\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *selections_rotate(Vis *vis, const char *keys, const Arg *arg) {\n\n\ttypedef struct {\n\t\tSelection *sel;\n\t\tchar *data;\n\t\tsize_t len;\n\t} Rotate;\n\n\tArray arr;\n\tText *txt = vis_text(vis);\n\tView *view = vis_view(vis);\n\tint columns = view_selections_column_count(view);\n\tint selections = columns == 1 ? view->selection_count : columns;\n\tint count = VIS_COUNT_DEFAULT(vis->action.count, 1);\n\tarray_init_sized(&arr, sizeof(Rotate));\n\tif (!array_reserve(&arr, selections))\n\t\treturn keys;\n\tsize_t line = 0;\n\n\tfor (Selection *s = view_selections(view), *next; s; s = next) {\n\t\tnext = view_selections_next(s);\n\t\tsize_t line_next = 0;\n\n\t\tFilerange sel = view_selections_get(s);\n\t\tRotate rot;\n\t\trot.sel = s;\n\t\trot.len = text_range_size(&sel);\n\t\tif ((rot.data = malloc(rot.len)))\n\t\t\trot.len = text_bytes_get(txt, sel.start, rot.len, rot.data);\n\t\telse\n\t\t\trot.len = 0;\n\t\tarray_add(&arr, &rot);\n\n\t\tif (!line)\n\t\t\tline = text_lineno_by_pos(txt, view_cursors_pos(s));\n\t\tif (next)\n\t\t\tline_next = text_lineno_by_pos(txt, view_cursors_pos(next));\n\t\tif (!next || (columns > 1 && line != line_next)) {\n\t\t\tsize_t len = arr.len;\n\t\t\tsize_t off = arg->i > 0 ? count % len : len - (count % len);\n\t\t\tfor (size_t i = 0; i < len; i++) {\n\t\t\t\tsize_t j = (i + off) % len;\n\t\t\t\tRotate *oldrot = array_get(&arr, i);\n\t\t\t\tRotate *newrot = array_get(&arr, j);\n\t\t\t\tif (!oldrot || !newrot || oldrot == newrot)\n\t\t\t\t\tcontinue;\n\t\t\t\tFilerange newsel = view_selections_get(newrot->sel);\n\t\t\t\tif (!text_range_valid(&newsel))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!text_delete_range(txt, &newsel))\n\t\t\t\t\tcontinue;\n\t\t\t\tif (!text_insert(txt, newsel.start, oldrot->data, oldrot->len))\n\t\t\t\t\tcontinue;\n\t\t\t\tnewsel.end = newsel.start + oldrot->len;\n\t\t\t\tview_selections_set(newrot->sel, &newsel);\n\t\t\t\tfree(oldrot->data);\n\t\t\t}\n\t\t\tarray_clear(&arr);\n\t\t}\n\t\tline = line_next;\n\t}\n\n\tarray_release(&arr);\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *selections_trim(Vis *vis, const char *keys, const Arg *arg) {\n\tText *txt = vis_text(vis);\n\tView *view = vis_view(vis);\n\tfor (Selection *s = view_selections(view), *next; s; s = next) {\n\t\tnext = view_selections_next(s);\n\t\tFilerange sel = view_selections_get(s);\n\t\tif (!text_range_valid(&sel))\n\t\t\tcontinue;\n\t\tfor (char b; sel.start < sel.end && text_byte_get(txt, sel.end-1, &b)\n\t\t\t&& isspace((unsigned char)b); sel.end--);\n\t\tfor (char b; sel.start <= sel.end && text_byte_get(txt, sel.start, &b)\n\t\t\t&& isspace((unsigned char)b); sel.start++);\n\t\tif (sel.start < sel.end) {\n\t\t\tview_selections_set(s, &sel);\n\t\t} else if (!view_selections_dispose(s)) {\n\t\t\tvis_mode_switch(vis, VIS_MODE_NORMAL);\n\t\t}\n\t}\n\treturn keys;\n}\n\nstatic void selections_set(Vis *vis, View *view, Array *sel) {\n\tenum VisMode mode = vis->mode->id;\n\tbool anchored = mode == VIS_MODE_VISUAL || mode == VIS_MODE_VISUAL_LINE;\n\tview_selections_set_all(view, sel, anchored);\n\tif (!anchored)\n\t\tview_selections_clear_all(view);\n}\n\nstatic const char *selections_save(Vis *vis, const char *keys, const Arg *arg) {\n\tWin *win = vis->win;\n\tView *view = vis_view(vis);\n\tenum VisMark mark = vis_mark_used(vis);\n\tArray sel = view_selections_get_all(view);\n\tvis_mark_set(win, mark, &sel);\n\tarray_release(&sel);\n\tvis_cancel(vis);\n\treturn keys;\n}\n\nstatic const char *selections_restore(Vis *vis, const char *keys, const Arg *arg) {\n\tWin *win = vis->win;\n\tView *view = vis_view(vis);\n\tenum VisMark mark = vis_mark_used(vis);\n\tArray sel = vis_mark_get(win, mark);\n\tselections_set(vis, view, &sel);\n\tarray_release(&sel);\n\tvis_cancel(vis);\n\treturn keys;\n}\n\nstatic const char *selections_union(Vis *vis, const char *keys, const Arg *arg) {\n\tWin *win = vis->win;\n\tView *view = vis_view(vis);\n\tenum VisMark mark = vis_mark_used(vis);\n\tArray a = vis_mark_get(win, mark);\n\tArray b = view_selections_get_all(view);\n\tArray sel;\n\tarray_init_from(&sel, &a);\n\n\tsize_t i = 0, j = 0;\n\tFilerange *r1 = array_get(&a, i), *r2 = array_get(&b, j), cur = text_range_empty();\n\twhile (r1 || r2) {\n\t\tif (r1 && text_range_overlap(r1, &cur)) {\n\t\t\tcur = text_range_union(r1, &cur);\n\t\t\tr1 = array_get(&a, ++i);\n\t\t} else if (r2 && text_range_overlap(r2, &cur)) {\n\t\t\tcur = text_range_union(r2, &cur);\n\t\t\tr2 = array_get(&b, ++j);\n\t\t} else {\n\t\t\tif (text_range_valid(&cur))\n\t\t\t\tarray_add(&sel, &cur);\n\t\t\tif (!r1) {\n\t\t\t\tcur = *r2;\n\t\t\t\tr2 = array_get(&b, ++j);\n\t\t\t} else if (!r2) {\n\t\t\t\tcur = *r1;\n\t\t\t\tr1 = array_get(&a, ++i);\n\t\t\t} else {\n\t\t\t\tif (r1->start < r2->start) {\n\t\t\t\t\tcur = *r1;\n\t\t\t\t\tr1 = array_get(&a, ++i);\n\t\t\t\t} else {\n\t\t\t\t\tcur = *r2;\n\t\t\t\t\tr2 = array_get(&b, ++j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (text_range_valid(&cur))\n\t\tarray_add(&sel, &cur);\n\n\tselections_set(vis, view, &sel);\n\tvis_cancel(vis);\n\n\tarray_release(&a);\n\tarray_release(&b);\n\tarray_release(&sel);\n\n\treturn keys;\n}\n\nstatic void intersect(Array *ret, Array *a, Array *b) {\n\tsize_t i = 0, j = 0;\n\tFilerange *r1 = array_get(a, i), *r2 = array_get(b, j);\n\twhile (r1 && r2) {\n\t\tif (text_range_overlap(r1, r2)) {\n\t\t\tFilerange new = text_range_intersect(r1, r2);\n\t\t\tarray_add(ret, &new);\n\t\t}\n\t\tif (r1->end < r2->end)\n\t\t\tr1 = array_get(a, ++i);\n\t\telse\n\t\t\tr2 = array_get(b, ++j);\n\t}\n}\n\nstatic const char *selections_intersect(Vis *vis, const char *keys, const Arg *arg) {\n\tWin *win = vis->win;\n\tView *view = vis_view(vis);\n\tenum VisMark mark = vis_mark_used(vis);\n\tArray a = vis_mark_get(win, mark);\n\tArray b = view_selections_get_all(view);\n\tArray sel;\n\tarray_init_from(&sel, &a);\n\n\tintersect(&sel, &a, &b);\n\tselections_set(vis, view, &sel);\n\tvis_cancel(vis);\n\n\tarray_release(&a);\n\tarray_release(&b);\n\tarray_release(&sel);\n\n\treturn keys;\n}\n\nstatic void complement(Array *ret, Array *a, Filerange *universe) {\n\tsize_t pos = universe->start;\n\tfor (size_t i = 0, len = a->len; i < len; i++) {\n\t\tFilerange *r = array_get(a, i);\n\t\tif (pos < r->start) {\n\t\t\tFilerange new = text_range_new(pos, r->start);\n\t\t\tarray_add(ret, &new);\n\t\t}\n\t\tpos = r->end;\n\t}\n\tif (pos < universe->end) {\n\t\tFilerange new = text_range_new(pos, universe->end);\n\t\tarray_add(ret, &new);\n\t}\n}\n\nstatic const char *selections_complement(Vis *vis, const char *keys, const Arg *arg) {\n\tText *txt = vis_text(vis);\n\tView *view = vis_view(vis);\n\tFilerange universe = text_object_entire(txt, 0);\n\tArray a = view_selections_get_all(view);\n\tArray sel;\n\tarray_init_from(&sel, &a);\n\n\tcomplement(&sel, &a, &universe);\n\n\tselections_set(vis, view, &sel);\n\tarray_release(&a);\n\tarray_release(&sel);\n\treturn keys;\n}\n\nstatic const char *selections_minus(Vis *vis, const char *keys, const Arg *arg) {\n\tText *txt = vis_text(vis);\n\tWin *win = vis->win;\n\tView *view = vis_view(vis);\n\tenum VisMark mark = vis_mark_used(vis);\n\tArray a = view_selections_get_all(view);\n\tArray b = vis_mark_get(win, mark);\n\tArray sel;\n\tarray_init_from(&sel, &a);\n\tArray b_complement;\n\tarray_init_from(&b_complement, &b);\n\n\tFilerange universe = text_object_entire(txt, 0);\n\tcomplement(&b_complement, &b, &universe);\n\tintersect(&sel, &a, &b_complement);\n\n\tselections_set(vis, view, &sel);\n\tvis_cancel(vis);\n\n\tarray_release(&a);\n\tarray_release(&b);\n\tarray_release(&b_complement);\n\tarray_release(&sel);\n\n\treturn keys;\n}\n\nstatic const char *replace(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!keys[0]) {\n\t\tvis_keymap_disable(vis);\n\t\treturn NULL;\n\t}\n\n\tconst char *next = vis_keys_next(vis, keys);\n\tif (!next)\n\t\treturn NULL;\n\n\tchar replacement[UTFmax+1];\n\tif (!vis_keys_utf8(vis, keys, replacement))\n\t\treturn next;\n\n\tif (replacement[0] == 0x1b) /* <Escape> */\n\t\treturn next;\n\n\tvis_operator(vis, VIS_OP_REPLACE, replacement);\n\tif (vis->mode->id == VIS_MODE_OPERATOR_PENDING)\n\t\tvis_motion(vis, VIS_MOVE_CHAR_NEXT);\n\treturn next;\n}\n\nstatic const char *count(Vis *vis, const char *keys, const Arg *arg) {\n\tint digit = keys[-1] - '0';\n\tint count = VIS_COUNT_DEFAULT(vis->action.count, 0);\n\tif (0 <= digit && digit <= 9) {\n\t\tif (digit == 0 && count == 0)\n\t\t\tvis_motion(vis, VIS_MOVE_LINE_BEGIN);\n\t\telse\n\t\t\tvis->action.count = VIS_COUNT_NORMALIZE(count * 10 + digit);\n\t}\n\treturn keys;\n}\n\nstatic const char *gotoline(Vis *vis, const char *keys, const Arg *arg) {\n\tif (vis->action.count != VIS_COUNT_UNKNOWN)\n\t\tvis_motion(vis, VIS_MOVE_LINE);\n\telse if (arg->i < 0)\n\t\tvis_motion(vis, VIS_MOVE_FILE_BEGIN);\n\telse\n\t\tvis_motion(vis, VIS_MOVE_FILE_END);\n\treturn keys;\n}\n\nstatic const char *operator(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_operator(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *movement_key(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!keys[0]) {\n\t\tvis_keymap_disable(vis);\n\t\treturn NULL;\n\t}\n\n\tconst char *next = vis_keys_next(vis, keys);\n\tif (!next)\n\t\treturn NULL;\n\tchar utf8[UTFmax+1];\n\tif (vis_keys_utf8(vis, keys, utf8))\n\t\tvis_motion(vis, arg->i, utf8);\n\treturn next;\n}\n\nstatic const char *movement(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_motion(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *textobj(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_textobject(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *selection_end(Vis *vis, const char *keys, const Arg *arg) {\n\tfor (Selection *s = view_selections(vis_view(vis)); s; s = view_selections_next(s))\n\t\tview_selections_flip(s);\n\treturn keys;\n}\n\nstatic const char *reg(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!keys[0])\n\t\treturn NULL;\n\tconst char *next = vis_keys_next(vis, keys);\n\tif (next - keys > 1)\n\t\treturn next;\n\tenum VisRegister reg = vis_register_from(vis, keys[0]);\n\tvis_register(vis, reg);\n\treturn keys+1;\n}\n\nstatic const char *mark(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!keys[0])\n\t\treturn NULL;\n\tconst char *next = vis_keys_next(vis, keys);\n\tif (next - keys > 1)\n\t\treturn next;\n\tenum VisMark mark = vis_mark_from(vis, keys[0]);\n\tvis_mark(vis, mark);\n\treturn keys+1;\n}\n\nstatic const char *undo(Vis *vis, const char *keys, const Arg *arg) {\n\tsize_t pos = text_undo(vis_text(vis));\n\tif (pos != EPOS) {\n\t\tView *view = vis_view(vis);\n\t\tif (view->selection_count == 1)\n\t\t\tview_cursors_to(view->selection, pos);\n\t\t/* redraw all windows in case some display the same file */\n\t\tvis_draw(vis);\n\t}\n\treturn keys;\n}\n\nstatic const char *redo(Vis *vis, const char *keys, const Arg *arg) {\n\tsize_t pos = text_redo(vis_text(vis));\n\tif (pos != EPOS) {\n\t\tView *view = vis_view(vis);\n\t\tif (view->selection_count == 1)\n\t\t\tview_cursors_to(view->selection, pos);\n\t\t/* redraw all windows in case some display the same file */\n\t\tvis_draw(vis);\n\t}\n\treturn keys;\n}\n\nstatic const char *earlier(Vis *vis, const char *keys, const Arg *arg) {\n\tsize_t pos = EPOS;\n\tVisCountIterator it = vis_count_iterator_get(vis, 1);\n\twhile (vis_count_iterator_next(&it))\n\t\tpos = text_earlier(vis_text(vis));\n\tif (pos != EPOS) {\n\t\tview_cursors_to(vis_view(vis)->selection, pos);\n\t\t/* redraw all windows in case some display the same file */\n\t\tvis_draw(vis);\n\t}\n\treturn keys;\n}\n\nstatic const char *later(Vis *vis, const char *keys, const Arg *arg) {\n\tsize_t pos = EPOS;\n\tVisCountIterator it = vis_count_iterator_get(vis, 1);\n\twhile (vis_count_iterator_next(&it))\n\t\tpos = text_later(vis_text(vis));\n\tif (pos != EPOS) {\n\t\tview_cursors_to(vis_view(vis)->selection, pos);\n\t\t/* redraw all windows in case some display the same file */\n\t\tvis_draw(vis);\n\t}\n\treturn keys;\n}\n\nstatic const char *delete(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_operator(vis, VIS_OP_DELETE);\n\tvis_motion(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *insert_register(Vis *vis, const char *keys, const Arg *arg) {\n\tif (!keys[0])\n\t\treturn NULL;\n\tconst char *next = vis_keys_next(vis, keys);\n\tif (next - keys > 1)\n\t\treturn next;\n\tenum VisRegister reg = vis_register_from(vis, keys[0]);\n\tif (reg != VIS_REG_INVALID) {\n\t\tvis_register(vis, reg);\n\t\tvis_operator(vis, VIS_OP_PUT_BEFORE_END);\n\t}\n\treturn keys+1;\n}\n\nstatic const char *prompt_show(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_prompt_show(vis, arg->s);\n\treturn keys;\n}\n\nstatic const char *insert_verbatim(Vis *vis, const char *keys, const Arg *arg) {\n\tRune rune = 0;\n\tchar buf[4], type = keys[0];\n\tconst char *data = NULL;\n\tint len = 0, count = 0, base = 0;\n\tswitch (type) {\n\tcase '\\0':\n\t\treturn NULL;\n\tcase 'o':\n\tcase 'O':\n\t\tcount = 3;\n\t\tbase = 8;\n\t\tbreak;\n\tcase 'U':\n\t\tcount = 4;\n\t\t/* fall through */\n\tcase 'u':\n\t\tcount += 4;\n\t\tbase = 16;\n\t\tbreak;\n\tcase 'x':\n\tcase 'X':\n\t\tcount = 2;\n\t\tbase = 16;\n\t\tbreak;\n\tdefault:\n\t\tif ('0' <= type && type <= '9') {\n\t\t\trune = type - '0';\n\t\t\tcount = 2;\n\t\t\tbase = 10;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (base) {\n\t\tfor (keys++; keys[0] && count > 0; keys++, count--) {\n\t\t\tint v = 0;\n\t\t\tif (base == 8 && '0' <= keys[0] && keys[0] <= '7') {\n\t\t\t\tv = keys[0] - '0';\n\t\t\t} else if ((base == 10 || base == 16) && '0' <= keys[0] && keys[0] <= '9') {\n\t\t\t\tv = keys[0] - '0';\n\t\t\t} else if (base == 16 && 'a' <= keys[0] && keys[0] <= 'f') {\n\t\t\t\tv = 10 + keys[0] - 'a';\n\t\t\t} else if (base == 16 && 'A' <= keys[0] && keys[0] <= 'F') {\n\t\t\t\tv = 10 + keys[0] - 'A';\n\t\t\t} else {\n\t\t\t\tcount = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trune = rune * base + v;\n\t\t}\n\n\t\tif (count > 0)\n\t\t\treturn NULL;\n\t\tif (type == 'u' || type == 'U') {\n\t\t\tlen = runetochar(buf, &rune);\n\t\t} else {\n\t\t\tbuf[0] = rune;\n\t\t\tlen = 1;\n\t\t}\n\n\t\tdata = buf;\n\t} else {\n\t\tconst char *next = vis_keys_next(vis, keys);\n\t\tif (!next)\n\t\t\treturn NULL;\n\t\tif ((rune = vis_keys_codepoint(vis, keys)) != (Rune)-1) {\n\t\t\tlen = runetochar(buf, &rune);\n\t\t\tif (buf[0] == '\\n')\n\t\t\t\tbuf[0] = '\\r';\n\t\t\tdata = buf;\n\t\t} else {\n\t\t\tvis_info_show(vis, \"Unknown key\");\n\t\t}\n\t\tkeys = next;\n\t}\n\n\tif (len > 0)\n\t\tvis_insert_key(vis, data, len);\n\treturn keys;\n}\n\nstatic const char *wscroll(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tint count = vis->action.count;\n\tswitch (arg->i) {\n\tcase -PAGE:\n\t\tview_scroll_page_up(view);\n\t\tbreak;\n\tcase +PAGE:\n\t\tview_scroll_page_down(view);\n\t\tbreak;\n\tcase -PAGE_HALF:\n\t\tview_scroll_halfpage_up(view);\n\t\tbreak;\n\tcase +PAGE_HALF:\n\t\tview_scroll_halfpage_down(view);\n\t\tbreak;\n\tdefault:\n\t\tif (count == VIS_COUNT_UNKNOWN)\n\t\t\tcount = arg->i < 0 ? -arg->i : arg->i;\n\t\tif (arg->i < 0)\n\t\t\tview_scroll_up(view, count);\n\t\telse\n\t\t\tview_scroll_down(view, count);\n\t\tbreak;\n\t}\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *wslide(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tint count = vis->action.count;\n\tif (count == VIS_COUNT_UNKNOWN)\n\t\tcount = arg->i < 0 ? -arg->i : arg->i;\n\tif (arg->i >= 0)\n\t\tview_slide_down(view, count);\n\telse\n\t\tview_slide_up(view, count);\n\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *call(Vis *vis, const char *keys, const Arg *arg) {\n\targ->f(vis);\n\treturn keys;\n}\n\nstatic const char *window(Vis *vis, const char *keys, const Arg *arg) {\n\targ->w(vis_view(vis));\n\treturn keys;\n}\n\nstatic const char *openline(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_operator(vis, VIS_OP_MODESWITCH, VIS_MODE_INSERT);\n\tif (arg->i > 0) {\n\t\tvis_motion(vis, VIS_MOVE_LINE_END);\n\t\tvis_keys_feed(vis, \"<Enter>\");\n\t} else {\n\t\tif (vis->autoindent) {\n\t\t\tvis_motion(vis, VIS_MOVE_LINE_START);\n\t\t\tvis_keys_feed(vis, \"<vis-motion-line-start>\");\n\t\t} else {\n\t\t\tvis_motion(vis, VIS_MOVE_LINE_BEGIN);\n\t\t\tvis_keys_feed(vis, \"<vis-motion-line-begin>\");\n\t\t}\n\t\tvis_keys_feed(vis, \"<Enter><vis-motion-line-up>\");\n\t}\n\treturn keys;\n}\n\nstatic const char *join(Vis *vis, const char *keys, const Arg *arg) {\n\tbool normal = (vis->mode->id == VIS_MODE_NORMAL);\n\tvis_operator(vis, VIS_OP_JOIN, arg->s);\n\tif (normal) {\n\t\tvis->action.count = VIS_COUNT_DEFAULT(vis->action.count, 0);\n\t\tif (vis->action.count > 0)\n\t\t\tvis->action.count -= 1;\n\t\tvis_motion(vis, VIS_MOVE_LINE_NEXT);\n\t}\n\treturn keys;\n}\n\nstatic const char *normalmode_escape(Vis *vis, const char *keys, const Arg *arg) {\n\tif (vis->action.count == VIS_COUNT_UNKNOWN)\n\t\tselections_clear(vis, keys, arg);\n\telse\n\t\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *visualmode_escape(Vis *vis, const char *keys, const Arg *arg) {\n\tif (vis->action.count == VIS_COUNT_UNKNOWN)\n\t\tvis_mode_switch(vis, VIS_MODE_NORMAL);\n\telse\n\t\tvis->action.count = VIS_COUNT_UNKNOWN;\n\treturn keys;\n}\n\nstatic const char *switchmode(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_mode_switch(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *insertmode(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_operator(vis, VIS_OP_MODESWITCH, VIS_MODE_INSERT);\n\tvis_motion(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *replacemode(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_operator(vis, VIS_OP_MODESWITCH, VIS_MODE_REPLACE);\n\tvis_motion(vis, arg->i);\n\treturn keys;\n}\n\nstatic const char *unicode_info(Vis *vis, const char *keys, const Arg *arg) {\n\tView *view = vis_view(vis);\n\tText *txt = vis_text(vis);\n\tsize_t start = view_cursor_get(view);\n\tsize_t end = text_char_next(txt, start);\n\tchar *grapheme = text_bytes_alloc0(txt, start, end-start), *codepoint = grapheme;\n\tif (!grapheme)\n\t\treturn keys;\n\tBuffer info = {0};\n\tmbstate_t ps = {0};\n\tIterator it = text_iterator_get(txt, start);\n\tfor (size_t pos = start; it.pos < end; pos = it.pos) {\n\t\tif (!text_iterator_codepoint_next(&it, NULL)) {\n\t\t\tvis_info_show(vis, \"Failed to parse code point\");\n\t\t\tgoto err;\n\t\t}\n\t\tsize_t len = it.pos - pos;\n\t\twchar_t wc = 0xFFFD;\n\t\tsize_t res = mbrtowc(&wc, codepoint, len, &ps);\n\t\tbool combining = false;\n\t\tif (res != (size_t)-1 && res != (size_t)-2)\n\t\t\tcombining = (wc != L'\\0' && wcwidth(wc) == 0);\n\t\tunsigned char ch = *codepoint;\n\t\tif (ch < 128 && !isprint(ch))\n\t\t\tbuffer_appendf(&info, \"<^%c> \", ch == 127 ? '?' : ch + 64);\n\t\telse\n\t\t\tbuffer_appendf(&info, \"<%s%.*s> \", combining ? \" \" : \"\", (int)len, codepoint);\n\t\tif (arg->i == VIS_ACTION_UNICODE_INFO) {\n\t\t\tbuffer_appendf(&info, \"U+%04\"PRIX32\" \", (uint32_t)wc);\n\t\t} else {\n\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\tbuffer_appendf(&info, \"%02x \", (uint8_t)codepoint[i]);\n\t\t}\n\t\tcodepoint += len;\n\t}\n\tvis_info_show(vis, \"%s\", buffer_content0(&info));\nerr:\n\tfree(grapheme);\n\tbuffer_release(&info);\n\treturn keys;\n}\n\nstatic const char *percent(Vis *vis, const char *keys, const Arg *arg) {\n\tif (vis->action.count == VIS_COUNT_UNKNOWN)\n\t\tvis_motion(vis, VIS_MOVE_BRACKET_MATCH);\n\telse\n\t\tvis_motion(vis, VIS_MOVE_PERCENT);\n\treturn keys;\n}\n\nstatic const char *jumplist(Vis *vis, const char *keys, const Arg *arg) {\n\tif (arg->i < 0)\n\t\tvis_jumplist_prev(vis);\n\telse if (arg->i > 0)\n\t\tvis_jumplist_next(vis);\n\telse\n\t\tvis_jumplist_save(vis);\n\treturn keys;\n}\n\nstatic Vis *vis;\n\nstatic void signal_handler(int signum, siginfo_t *siginfo, void *context) {\n\tvis_signal_handler(vis, signum, siginfo, context);\n}\n\nint main(int argc, char *argv[]) {\n\tfor (int i = 1; i < argc; i++) {\n\t\tif (argv[i][0] != '-') {\n\t\t\tcontinue;\n\t\t} else if (strcmp(argv[i], \"-\") == 0) {\n\t\t\tcontinue;\n\t\t} else if (strcmp(argv[i], \"--\") == 0) {\n\t\t\tbreak;\n\t\t} else if (strcmp(argv[i], \"-v\") == 0) {\n\t\t\tprintf(\"vis %s%s%s%s%s%s%s\\n\", VERSION,\n\t\t\t       CONFIG_CURSES  ? \" +curses\"  : \"\",\n\t\t\t       CONFIG_LUA     ? \" +lua\"     : \"\",\n\t\t\t       CONFIG_LPEG    ? \" +lpeg\"    : \"\",\n\t\t\t       CONFIG_TRE     ? \" +tre\"     : \"\",\n\t\t\t       CONFIG_ACL     ? \" +acl\"     : \"\",\n\t\t\t       CONFIG_SELINUX ? \" +selinux\" : \"\");\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfprintf(stderr, \"Unknown command option: %s\\n\", argv[i]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvis = vis_new();\n\tif (!vis)\n\t\treturn EXIT_FAILURE;\n\n\tvis_event_emit(vis, VIS_EVENT_INIT);\n\n\tfor (int i = 0; i < LENGTH(vis_action); i++) {\n\t\tconst KeyAction *action = &vis_action[i];\n\t\tif (!vis_action_register(vis, action))\n\t\t\tvis_die(vis, \"Could not register action: %s\\n\", action->name);\n\t}\n\n\tfor (int i = 0; i < LENGTH(default_bindings); i++) {\n\t\tfor (const KeyBinding **binding = default_bindings[i]; binding && *binding; binding++) {\n\t\t\tfor (const KeyBinding *kb = *binding; kb->key; kb++) {\n\t\t\t\tvis_mode_map(vis, i, false, kb->key, kb);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (const char **k = keymaps; k[0]; k += 2)\n\t\tvis_keymap_add(vis, k[0], k[1]);\n\n\t/* install signal handlers etc. */\n\tstruct sigaction sa;\n\tmemset(&sa, 0, sizeof sa);\n\tsigfillset(&sa.sa_mask);\n\tsa.sa_flags = SA_SIGINFO;\n\tsa.sa_sigaction = signal_handler;\n\tif (sigaction(SIGBUS, &sa, NULL) == -1 ||\n\t    sigaction(SIGINT, &sa, NULL) == -1 ||\n\t    sigaction(SIGCONT, &sa, NULL) == -1 ||\n\t    sigaction(SIGWINCH, &sa, NULL) == -1 ||\n\t    sigaction(SIGTERM, &sa, NULL) == -1 ||\n\t    sigaction(SIGHUP, &sa, NULL) == -1) {\n\t\tvis_die(vis, \"Failed to set signal handler: %s\\n\", strerror(errno));\n\t}\n\n\tsa.sa_handler = SIG_IGN;\n\tif (sigaction(SIGPIPE, &sa, NULL) == -1 || sigaction(SIGQUIT, &sa, NULL) == -1)\n\t\tvis_die(vis, \"Failed to ignore signals\\n\");\n\n\tsigset_t blockset;\n\tsigemptyset(&blockset);\n\tsigaddset(&blockset, SIGBUS);\n\tsigaddset(&blockset, SIGCONT);\n\tsigaddset(&blockset, SIGWINCH);\n\tsigaddset(&blockset, SIGTERM);\n\tsigaddset(&blockset, SIGHUP);\n\tif (sigprocmask(SIG_BLOCK, &blockset, NULL) == -1)\n\t\tvis_die(vis, \"Failed to block signals\\n\");\n\n\tchar *cmd = NULL;\n\tbool end_of_options = false, win_created = false;\n\n\tfor (int i = 1; i < argc; i++) {\n\t\tif (argv[i][0] == '-' && !end_of_options) {\n\t\t\tif (strcmp(argv[i], \"-\") == 0) {\n\t\t\t\tif (!vis_window_new_fd(vis, STDOUT_FILENO))\n\t\t\t\t\tvis_die(vis, \"Can not create empty buffer\\n\");\n\t\t\t\tssize_t len = 0;\n\t\t\t\tchar buf[PIPE_BUF];\n\t\t\t\tText *txt = vis_text(vis);\n\t\t\t\twhile ((len = read(STDIN_FILENO, buf, sizeof buf)) > 0)\n\t\t\t\t\ttext_insert(txt, text_size(txt), buf, len);\n\t\t\t\tif (len == -1)\n\t\t\t\t\tvis_die(vis, \"Can not read from stdin\\n\");\n\t\t\t\ttext_snapshot(txt);\n\t\t\t\tint fd = open(\"/dev/tty\", O_RDWR);\n\t\t\t\tif (fd == -1)\n\t\t\t\t\tvis_die(vis, \"Can not reopen stdin\\n\");\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t} else if (strcmp(argv[i], \"--\") == 0) {\n\t\t\t\tend_of_options = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (argv[i][0] == '+' && !end_of_options) {\n\t\t\tcmd = argv[i] + (argv[i][1] == '/' || argv[i][1] == '?');\n\t\t\tcontinue;\n\t\t} else if (!vis_window_new(vis, argv[i])) {\n\t\t\tvis_die(vis, \"Can not load '%s': %s\\n\", argv[i], strerror(errno));\n\t\t}\n\t\twin_created = true;\n\t\tif (cmd) {\n\t\t\tvis_prompt_cmd(vis, cmd);\n\t\t\tcmd = NULL;\n\t\t}\n\t}\n\n\tif (!vis->win && !win_created) {\n\t\tif (!vis_window_new(vis, NULL))\n\t\t\tvis_die(vis, \"Can not create empty buffer\\n\");\n\t\tif (cmd)\n\t\t\tvis_prompt_cmd(vis, cmd);\n\t}\n\n\tint status = vis_run(vis);\n\tvis_free(vis);\n\treturn status;\n}\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "map.c",
          "type": "blob",
          "size": 6.9208984375,
          "content": "/* Crit-bit tree based map which supports lookups based on unique\n * prefixes as well as ordered iteration.\n *\n * Based on public domain code from Rusty Russel, Adam Langley\n * and D. J. Bernstein.\n *\n * Further information about the data structure can be found at:\n *  http://cr.yp.to/critbit.html\n *  http://github.com/agl/critbit\n *  http://ccodearchive.net/info/strmap.html\n */\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <inttypes.h>\n#include \"map.h\"\n\ntypedef struct Node Node;\n\nstruct Map {     /* struct holding either an item with value v and key u.s or an internal node */\n\tunion {\n\t\tNode *n;\n\t\tconst char *s;\n\t} u;\n\tvoid *v; /* value stored in the map, if non NULL u.s holds the corresponding key */\n};\n\nstruct Node {\n\tMap child[2];    /* These point to strings or nodes. */\n\tsize_t byte_num; /* The byte number where first bit differs. */\n\tuint8_t bit_num; /* The bit where these children differ. */\n};\n\n/* Closest key to this in a non-empty map. */\nstatic Map *closest(Map *n, const char *key)\n{\n\tsize_t len = strlen(key);\n\tconst uint8_t *bytes = (const uint8_t *)key;\n\n\t/* Anything with NULL value is an internal node. */\n\twhile (!n->v) {\n\t\tuint8_t direction = 0;\n\n\t\tif (n->u.n->byte_num < len) {\n\t\t\tuint8_t c = bytes[n->u.n->byte_num];\n\t\t\tdirection = (c >> n->u.n->bit_num) & 1;\n\t\t}\n\t\tn = &n->u.n->child[direction];\n\t}\n\treturn n;\n}\n\nvoid *map_get(const Map *map, const char *key)\n{\n\t/* Not empty map? */\n\tif (map->u.n) {\n\t\tMap *n = closest((Map *)map, key);\n\t\tif (strcmp(key, n->u.s) == 0)\n\t\t\treturn n->v;\n\t}\n\treturn NULL;\n}\n\nvoid *map_closest(const Map *map, const char *prefix)\n{\n\terrno = 0;\n\tvoid *v = map_get(map, prefix);\n\tif (v)\n\t\treturn v;\n\tconst Map *m = map_prefix(map, prefix);\n\tif (map_empty(m))\n\t\terrno = ENOENT;\n\treturn m->v;\n}\n\nbool map_contains(const Map *map, const char *prefix)\n{\n\treturn !map_empty(map_prefix(map, prefix));\n}\n\nbool map_put(Map *map, const char *k, const void *value)\n{\n\tsize_t len = strlen(k);\n\tconst uint8_t *bytes = (const uint8_t *)k;\n\tMap *n;\n\tNode *newn;\n\tsize_t byte_num;\n\tuint8_t bit_num, new_dir;\n\tchar *key;\n\n\tif (!value) {\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tif (!(key = strdup(k))) {\n\t\terrno = ENOMEM;\n\t\treturn false;\n\t}\n\n\t/* Empty map? */\n\tif (!map->u.n) {\n\t\tmap->u.s = key;\n\t\tmap->v = (void *)value;\n\t\treturn true;\n\t}\n\n\t/* Find closest existing key. */\n\tn = closest(map, key);\n\n\t/* Find where they differ. */\n\tfor (byte_num = 0; n->u.s[byte_num] == key[byte_num]; byte_num++) {\n\t\tif (key[byte_num] == '\\0') {\n\t\t\t/* All identical! */\n\t\t\tfree(key);\n\t\t\terrno = EEXIST;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/* Find which bit differs */\n\tuint8_t diff = (uint8_t)n->u.s[byte_num] ^ bytes[byte_num];\n\t/* TODO: bit_num = 31 - __builtin_clz(diff); ? */\n\tfor (bit_num = 0; diff >>= 1; bit_num++);\n\n\t/* Which direction do we go at this bit? */\n\tnew_dir = ((bytes[byte_num]) >> bit_num) & 1;\n\n\t/* Allocate new node. */\n\tnewn = malloc(sizeof(*newn));\n\tif (!newn) {\n\t\tfree(key);\n\t\terrno = ENOMEM;\n\t\treturn false;\n\t}\n\tnewn->byte_num = byte_num;\n\tnewn->bit_num = bit_num;\n\tnewn->child[new_dir].v = (void *)value;\n\tnewn->child[new_dir].u.s = key;\n\n\t/* Find where to insert: not closest, but first which differs! */\n\tn = map;\n\twhile (!n->v) {\n\t\tuint8_t direction = 0;\n\n\t\tif (n->u.n->byte_num > byte_num)\n\t\t\tbreak;\n\t\t/* Subtle: bit numbers are \"backwards\" for comparison */\n\t\tif (n->u.n->byte_num == byte_num && n->u.n->bit_num < bit_num)\n\t\t\tbreak;\n\n\t\tif (n->u.n->byte_num < len) {\n\t\t\tuint8_t c = bytes[n->u.n->byte_num];\n\t\t\tdirection = (c >> n->u.n->bit_num) & 1;\n\t\t}\n\t\tn = &n->u.n->child[direction];\n\t}\n\n\tnewn->child[!new_dir] = *n;\n\tn->u.n = newn;\n\tn->v = NULL;\n\treturn true;\n}\n\nvoid *map_delete(Map *map, const char *key)\n{\n\tsize_t len = strlen(key);\n\tconst uint8_t *bytes = (const uint8_t *)key;\n\tMap *parent = NULL, *n;\n\tvoid *value = NULL;\n\tuint8_t direction;\n\n\t/* Empty map? */\n\tif (!map->u.n) {\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\n\t/* Find closest, but keep track of parent. */\n\tn = map;\n\t/* Anything with NULL value is a node. */\n\twhile (!n->v) {\n\t\tuint8_t c = 0;\n\n\t\tparent = n;\n\t\tif (n->u.n->byte_num < len) {\n\t\t\tc = bytes[n->u.n->byte_num];\n\t\t\tdirection = (c >> n->u.n->bit_num) & 1;\n\t\t} else {\n\t\t\tdirection = 0;\n\t\t}\n\t\tn = &n->u.n->child[direction];\n\t}\n\n\t/* Did we find it? */\n\tif (strcmp(key, n->u.s)) {\n\t\terrno = ENOENT;\n\t\treturn NULL;\n\t}\n\n\tfree((char*)n->u.s);\n\tvalue = n->v;\n\n\tif (!parent) {\n\t\t/* We deleted last node. */\n\t\tmap->u.n = NULL;\n\t} else {\n\t\tNode *old = parent->u.n;\n\t\t/* Raise other node to parent. */\n\t\t*parent = old->child[!direction];\n\t\tfree(old);\n\t}\n\n\treturn value;\n}\n\nstatic bool iterate(Map n, bool (*handle)(const char *, void *, void *), const void *data)\n{\n\tif (n.v)\n\t\treturn handle(n.u.s, n.v, (void *)data);\n\n\treturn iterate(n.u.n->child[0], handle, data)\n\t\t&& iterate(n.u.n->child[1], handle, data);\n}\n\nvoid map_iterate(const Map *map, bool (*handle)(const char *, void *, void *), const void *data)\n{\n\t/* Empty map? */\n\tif (!map->u.n)\n\t\treturn;\n\n\titerate(*map, handle, data);\n}\n\ntypedef struct {\n\tconst char *key;\n\tvoid *value;\n} KeyValue;\n\nstatic bool first(const char *key, void *value, void *data)\n{\n\tKeyValue *kv = data;\n\tkv->key = key;\n\tkv->value = value;\n\treturn false;\n}\n\nvoid *map_first(const Map *map, const char **key)\n{\n\tKeyValue kv = { 0 };\n\tmap_iterate(map, first, &kv);\n\tif (key && kv.key)\n\t\t*key = kv.key;\n\treturn kv.value;\n}\n\nconst Map *map_prefix(const Map *map, const char *prefix)\n{\n\tconst Map *n, *top;\n\tsize_t len = strlen(prefix);\n\tconst uint8_t *bytes = (const uint8_t *)prefix;\n\n\t/* Empty map -> return empty map. */\n\tif (!map->u.n)\n\t\treturn map;\n\n\ttop = n = map;\n\n\t/* We walk to find the top, but keep going to check prefix matches. */\n\twhile (!n->v) {\n\t\tuint8_t c = 0, direction;\n\n\t\tif (n->u.n->byte_num < len)\n\t\t\tc = bytes[n->u.n->byte_num];\n\n\t\tdirection = (c >> n->u.n->bit_num) & 1;\n\t\tn = &n->u.n->child[direction];\n\t\tif (c)\n\t\t\ttop = n;\n\t}\n\n\tif (strncmp(n->u.s, prefix, len)) {\n\t\t/* Convenient return for prefixes which do not appear in map. */\n\t\tstatic const Map empty_map;\n\t\treturn &empty_map;\n\t}\n\n\treturn top;\n}\n\nstatic void clear(Map n)\n{\n\tif (!n.v) {\n\t\tclear(n.u.n->child[0]);\n\t\tclear(n.u.n->child[1]);\n\t\tfree(n.u.n);\n\t} else {\n\t\tfree((char*)n.u.s);\n\t}\n}\n\nvoid map_clear(Map *map)\n{\n\tif (map->u.n)\n\t\tclear(*map);\n\tmap->u.n = NULL;\n\tmap->v = NULL;\n}\n\nstatic bool copy(Map *dest, Map n)\n{\n\tif (!n.v) {\n\t\treturn copy(dest, n.u.n->child[0]) &&\n\t\t       copy(dest, n.u.n->child[1]);\n\t} else {\n\t\tif (!map_put(dest, n.u.s, n.v) && map_get(dest, n.u.s) != n.v) {\n\t\t\tmap_delete(dest, n.u.s);\n\t\t\treturn map_put(dest, n.u.s, n.v);\n\t\t}\n\t\treturn true;\n\t}\n}\n\nbool map_copy(Map *dest, Map *src)\n{\n\tif (!src || !src->u.n)\n\t\treturn true;\n\n\treturn copy(dest, *src);\n}\n\nbool map_empty(const Map *map)\n{\n\treturn map->u.n == NULL;\n}\n\nMap *map_new(void)\n{\n\treturn calloc(1, sizeof(Map));\n}\n\nvoid map_free(Map *map)\n{\n\tif (!map)\n\t\treturn;\n\tmap_clear(map);\n\tfree(map);\n}\n\nstatic bool free_elem(const char *key, void *value, void *data)\n{\n\tfree(value);\n\treturn true;\n}\n\nvoid map_free_full(Map *map)\n{\n\tif (!map)\n\t\treturn;\n\tmap_iterate(map, free_elem, NULL);\n\tmap_free(map);\n}\n"
        },
        {
          "name": "map.h",
          "type": "blob",
          "size": 2.4814453125,
          "content": "#ifndef MAP_H\n#define MAP_H\n\n#include <stdbool.h>\n\n/**\n * @file\n * Crit-bit tree based map which supports unique prefix queries and\n * ordered iteration.\n */\n\n/** Opaque map type. */\ntypedef struct Map Map;\n\n/** Allocate a new map. */\nMap *map_new(void);\n/** Lookup a value, returns ``NULL`` if not found. */\nvoid *map_get(const Map*, const char *key);\n/**\n * Get first element of the map, or ``NULL`` if empty.\n * @param key Updated with the key of the first element.\n */\nvoid *map_first(const Map*, const char **key);\n/**\n * Lookup element by unique prefix match.\n * @param prefix The prefix to search for.\n * @return The corresponding value, if the given prefix is unique.\n *         Otherwise ``NULL``. If no such prefix exists, then ``errno``\n *         is set to ``ENOENT``.\n */\nvoid *map_closest(const Map*, const char *prefix);\n/**\n * Check whether the map contains the given prefix.\n * whether it can be extended to match a key of a map element.\n */\nbool map_contains(const Map*, const char *prefix);\n/**\n * Store a key value pair in the map.\n * @return False if we run out of memory (``errno = ENOMEM``), or if the key\n *         already appears in the map (``errno = EEXIST``).\n */\nbool map_put(Map*, const char *key, const void *value);\n/**\n * Remove a map element.\n * @return The removed entry or ``NULL`` if no such element exists.\n */\nvoid *map_delete(Map*, const char *key);\n/** Copy all entries from ``src`` into ``dest``, overwrites existing entries in ``dest``. */\nbool map_copy(Map *dest, Map *src);\n/**\n * Ordered iteration over a map.\n * Invokes the passed callback for every map entry.\n * If ``handle`` returns false, the iteration will stop.\n * @param handle A function invoked for ever map element.\n * @param data A context pointer, passed as last argument to ``handle``.\n */\nvoid map_iterate(const Map*, bool (*handle)(const char *key, void *value, void *data), const void *data);\n/**\n * Get a sub map matching a prefix.\n * @rst\n * .. warning:: This returns a pointer into the original map.\n *              Do not alter the map while using the return value.\n * @endrst\n */\nconst Map *map_prefix(const Map*, const char *prefix);\n/** Test whether the map is empty (contains no elements). */\nbool map_empty(const Map*);\n/** Empty the map. */\nvoid map_clear(Map*);\n/** Release all memory associated with this map. */\nvoid map_free(Map*);\n/**\n * Call `free(3)` for every map element, then free the map itself.\n * @rst\n * .. warning:: Assumes map elements to be pointers.\n * @endrst\n */\nvoid map_free_full(Map*);\n\n#endif\n"
        },
        {
          "name": "sam.c",
          "type": "blob",
          "size": 52.0205078125,
          "content": "/*\n * Heavily inspired (and partially based upon) the X11 version of\n * Rob Pike's sam text editor originally written for Plan 9.\n *\n *  Copyright © 2016-2020 Marc André Tanner <mat at brain-dump.org>\n *  Copyright © 1998 by Lucent Technologies\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose without fee is hereby granted, provided that this entire notice\n * is included in all copies of any software which is or includes a copy\n * or modification of this software and in all copies of the supporting\n * documentation for such software.\n *\n * THIS SOFTWARE IS BEING PROVIDED \"AS IS\", WITHOUT ANY EXPRESS OR IMPLIED\n * WARRANTY. IN PARTICULAR, NEITHER THE AUTHORS NOR LUCENT TECHNOLOGIES MAKE ANY\n * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY\n * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.\n */\n#include <string.h>\n#include <strings.h>\n#include <stdio.h>\n#include <ctype.h>\n#include <errno.h>\n#include <unistd.h>\n#include <limits.h>\n#include <fcntl.h>\n#include \"sam.h\"\n#include \"vis-core.h\"\n#include \"buffer.h\"\n#include \"text.h\"\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"text-regex.h\"\n#include \"util.h\"\n\n#define MAX_ARGV 8\n\ntypedef struct Address Address;\ntypedef struct Command Command;\ntypedef struct CommandDef CommandDef;\n\nstruct Change {\n\tenum ChangeType {\n\t\tTRANSCRIPT_INSERT = 1 << 0,\n\t\tTRANSCRIPT_DELETE = 1 << 1,\n\t\tTRANSCRIPT_CHANGE = TRANSCRIPT_INSERT|TRANSCRIPT_DELETE,\n\t} type;\n\tWin *win;          /* window in which changed file is being displayed */\n\tSelection *sel;    /* selection associated with this change, might be NULL */\n\tFilerange range;   /* inserts are denoted by zero sized range (same start/end) */\n\tconst char *data;  /* will be free(3)-ed after transcript has been processed */\n\tsize_t len;        /* size in bytes of the chunk pointed to by data */\n\tChange *next;      /* modification position increase monotonically */\n\tint count;         /* how often should data be inserted? */\n};\n\nstruct Address {\n\tchar type;      /* # (char) l (line) g (goto line) / ? . $ + - , ; % ' */\n\tRegex *regex;   /* NULL denotes default for x, y, X, and Y commands */\n\tsize_t number;  /* line or character number */\n\tAddress *left;  /* left hand side of a compound address , ; */\n\tAddress *right; /* either right hand side of a compound address or next address */\n};\n\ntypedef struct {\n\tint start, end; /* interval [n,m] */\n\tbool mod;       /* % every n-th match, implies n == m */\n} Count;\n\nstruct Command {\n\tconst char *argv[MAX_ARGV];/* [0]=cmd-name, [1..MAX_ARGV-2]=arguments, last element always NULL */\n\tAddress *address;         /* range of text for command */\n\tRegex *regex;             /* regex to match, used by x, y, g, v, X, Y */\n\tconst CommandDef *cmddef; /* which command is this? */\n\tCount count;              /* command count, defaults to [0,+inf] */\n\tint iteration;            /* current command loop iteration */\n\tchar flags;               /* command specific flags */\n\tCommand *cmd;             /* target of x, y, g, v, X, Y, { */\n\tCommand *next;            /* next command in {} group */\n};\n\nstruct CommandDef {\n\tconst char *name;                    /* command name */\n\tVIS_HELP_DECL(const char *help;)     /* short, one-line help text */\n\tenum {\n\t\tCMD_NONE          = 0,       /* standalone command without any arguments */\n\t\tCMD_CMD           = 1 << 0,  /* does the command take a sub/target command? */\n\t\tCMD_REGEX         = 1 << 1,  /* regex after command? */\n\t\tCMD_REGEX_DEFAULT = 1 << 2,  /* is the regex optional i.e. can we use a default? */\n\t\tCMD_COUNT         = 1 << 3,  /* does the command support a count as in s2/../? */\n\t\tCMD_TEXT          = 1 << 4,  /* does the command need a text to insert? */\n\t\tCMD_ADDRESS_NONE  = 1 << 5,  /* is it an error to specify an address for the command? */\n\t\tCMD_ADDRESS_POS   = 1 << 6,  /* no address implies an empty range at current cursor position */\n\t\tCMD_ADDRESS_LINE  = 1 << 7,  /* if no address is given, use the current line */\n\t\tCMD_ADDRESS_AFTER = 1 << 8,  /* if no address is given, begin at the start of the next line */\n\t\tCMD_ADDRESS_ALL   = 1 << 9,  /* if no address is given, apply to whole file (independent of #cursors) */\n\t\tCMD_ADDRESS_ALL_1CURSOR = 1 << 10, /* if no address is given and only 1 cursor exists, apply to whole file */\n\t\tCMD_SHELL         = 1 << 11, /* command needs a shell command as argument */\n\t\tCMD_FORCE         = 1 << 12, /* can the command be forced with ! */\n\t\tCMD_ARGV          = 1 << 13, /* whether shell like argument splitting is desired */\n\t\tCMD_ONCE          = 1 << 14, /* command should only be executed once, not for every selection */\n\t\tCMD_LOOP          = 1 << 15, /* a looping construct like `x`, `y` */\n\t\tCMD_GROUP         = 1 << 16, /* a command group { ... } */\n\t\tCMD_DESTRUCTIVE   = 1 << 17, /* command potentially destroys window */\n\t} flags;\n\tconst char *defcmd;                  /* name of a default target command */\n\tbool (*func)(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*); /* command implementation */\n};\n\n/* sam commands */\nstatic bool cmd_insert(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_append(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_change(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_delete(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_guard(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_extract(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_select(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_print(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_files(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_pipein(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_pipeout(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_filter(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_launch(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_substitute(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_write(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_read(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_edit(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_quit(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_cd(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\n/* vi(m) commands */\nstatic bool cmd_set(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_open(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_qall(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_split(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_vsplit(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_new(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_vnew(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_wq(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_earlier_later(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_help(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_map(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_unmap(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_langmap(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\nstatic bool cmd_user(Vis*, Win*, Command*, const char *argv[], Selection*, Filerange*);\n\nstatic const CommandDef cmds[] = {\n\t//      name            help\n\t//      flags, default command, implementation\n\t{\n\t\t\"a\",            VIS_HELP(\"Append text after range\")\n\t\tCMD_TEXT, NULL, cmd_append\n\t}, {\n\t\t\"c\",            VIS_HELP(\"Change text in range\")\n\t\tCMD_TEXT, NULL, cmd_change\n\t}, {\n\t\t\"d\",            VIS_HELP(\"Delete text in range\")\n\t\tCMD_NONE, NULL, cmd_delete\n\t}, {\n\t\t\"g\",            VIS_HELP(\"If range contains regexp, run command\")\n\t\tCMD_COUNT|CMD_REGEX|CMD_CMD, \"p\", cmd_guard\n\t}, {\n\t\t\"i\",            VIS_HELP(\"Insert text before range\")\n\t\tCMD_TEXT, NULL, cmd_insert\n\t}, {\n\t\t\"p\",            VIS_HELP(\"Create selection covering range\")\n\t\tCMD_NONE, NULL, cmd_print\n\t}, {\n\t\t\"s\",            VIS_HELP(\"Substitute: use x/pattern/ c/replacement/ instead\")\n\t\tCMD_SHELL|CMD_ADDRESS_LINE, NULL, cmd_substitute\n\t}, {\n\t\t\"v\",            VIS_HELP(\"If range does not contain regexp, run command\")\n\t\tCMD_COUNT|CMD_REGEX|CMD_CMD, \"p\", cmd_guard\n\t}, {\n\t\t\"x\",            VIS_HELP(\"Set range and run command on each match\")\n\t\tCMD_CMD|CMD_REGEX|CMD_REGEX_DEFAULT|CMD_ADDRESS_ALL_1CURSOR|CMD_LOOP, \"p\", cmd_extract\n\t}, {\n\t\t\"y\",            VIS_HELP(\"As `x` but select unmatched text\")\n\t\tCMD_CMD|CMD_REGEX|CMD_ADDRESS_ALL_1CURSOR|CMD_LOOP, \"p\", cmd_extract\n\t}, {\n\t\t\"X\",            VIS_HELP(\"Run command on files whose name matches\")\n\t\tCMD_CMD|CMD_REGEX|CMD_REGEX_DEFAULT|CMD_ADDRESS_NONE|CMD_ONCE, NULL, cmd_files\n\t}, {\n\t\t\"Y\",            VIS_HELP(\"As `X` but select unmatched files\")\n\t\tCMD_CMD|CMD_REGEX|CMD_ADDRESS_NONE|CMD_ONCE, NULL, cmd_files\n\t}, {\n\t\t\">\",            VIS_HELP(\"Send range to stdin of command\")\n\t\tCMD_SHELL|CMD_ADDRESS_LINE, NULL, cmd_pipeout\n\t}, {\n\t\t\"<\",            VIS_HELP(\"Replace range by stdout of command\")\n\t\tCMD_SHELL|CMD_ADDRESS_POS, NULL, cmd_pipein\n\t}, {\n\t\t\"|\",            VIS_HELP(\"Pipe range through command\")\n\t\tCMD_SHELL, NULL, cmd_filter\n\t}, {\n\t\t\"!\",            VIS_HELP(\"Run the command\")\n\t\tCMD_SHELL|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_launch\n\t}, {\n\t\t\"w\",            VIS_HELP(\"Write range to named file\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_ALL, NULL, cmd_write\n\t}, {\n\t\t\"r\",            VIS_HELP(\"Replace range by contents of file\")\n\t\tCMD_ARGV|CMD_ADDRESS_AFTER, NULL, cmd_read\n\t}, {\n\t\t\"{\",            VIS_HELP(\"Start of command group\")\n\t\tCMD_GROUP, NULL, NULL\n\t}, {\n\t\t\"}\",            VIS_HELP(\"End of command group\" )\n\t\tCMD_NONE, NULL, NULL\n\t}, {\n\t\t\"e\",            VIS_HELP(\"Edit file\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_NONE|CMD_DESTRUCTIVE, NULL, cmd_edit\n\t}, {\n\t\t\"q\",            VIS_HELP(\"Quit the current window\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_NONE|CMD_DESTRUCTIVE, NULL, cmd_quit\n\t}, {\n\t\t\"cd\",           VIS_HELP(\"Change directory\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_cd\n\t},\n\t/* vi(m) related commands */\n\t{\n\t\t\"help\",         VIS_HELP(\"Show this help\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_help\n\t}, {\n\t\t\"map\",          VIS_HELP(\"Map key binding `:map <mode> <lhs> <rhs>`\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_map\n\t}, {\n\t\t\"map-window\",   VIS_HELP(\"As `map` but window local\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_map\n\t}, {\n\t\t\"unmap\",        VIS_HELP(\"Unmap key binding `:unmap <mode> <lhs>`\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_unmap\n\t}, {\n\t\t\"unmap-window\", VIS_HELP(\"As `unmap` but window local\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_unmap\n\t}, {\n\t\t\"langmap\",      VIS_HELP(\"Map keyboard layout `:langmap <locale-keys> <latin-keys>`\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_langmap\n\t}, {\n\t\t\"new\",          VIS_HELP(\"Create new window\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_new\n\t}, {\n\t\t\"open\",         VIS_HELP(\"Open file\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_open\n\t}, {\n\t\t\"qall\",         VIS_HELP(\"Exit vis\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_NONE|CMD_DESTRUCTIVE, NULL, cmd_qall\n\t}, {\n\t\t\"set\",          VIS_HELP(\"Set option\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_set\n\t}, {\n\t\t\"split\",        VIS_HELP(\"Horizontally split window\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_split\n\t}, {\n\t\t\"vnew\",         VIS_HELP(\"As `:new` but split vertically\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_vnew\n\t}, {\n\t\t\"vsplit\",       VIS_HELP(\"Vertically split window\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_vsplit\n\t}, {\n\t\t\"wq\",           VIS_HELP(\"Write file and quit\")\n\t\tCMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_ALL|CMD_DESTRUCTIVE, NULL, cmd_wq\n\t}, {\n\t\t\"earlier\",      VIS_HELP(\"Go to older text state\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_earlier_later\n\t}, {\n\t\t\"later\",        VIS_HELP(\"Go to newer text state\")\n\t\tCMD_ARGV|CMD_ONCE|CMD_ADDRESS_NONE, NULL, cmd_earlier_later\n\t},\n\t{ NULL, VIS_HELP(NULL) CMD_NONE, NULL, NULL },\n};\n\nstatic const CommandDef cmddef_select = {\n\tNULL, VIS_HELP(NULL) CMD_NONE, NULL, cmd_select\n};\n\n/* :set command options */\ntypedef struct {\n\tconst char *names[3];            /* name and optional alias */\n\tenum VisOption flags;            /* option type, etc. */\n\tVIS_HELP_DECL(const char *help;) /* short, one line help text */\n\tVisOptionFunction *func;         /* option handler, NULL for builtins */\n\tvoid *context;                   /* context passed to option handler function */\n} OptionDef;\n\nenum {\n\tOPTION_SHELL,\n\tOPTION_ESCDELAY,\n\tOPTION_AUTOINDENT,\n\tOPTION_EXPANDTAB,\n\tOPTION_TABWIDTH,\n\tOPTION_SHOW_SPACES,\n\tOPTION_SHOW_TABS,\n\tOPTION_SHOW_NEWLINES,\n\tOPTION_SHOW_EOF,\n\tOPTION_STATUSBAR,\n\tOPTION_NUMBER,\n\tOPTION_NUMBER_RELATIVE,\n\tOPTION_CURSOR_LINE,\n\tOPTION_COLOR_COLUMN,\n\tOPTION_SAVE_METHOD,\n\tOPTION_LOAD_METHOD,\n\tOPTION_CHANGE_256COLORS,\n\tOPTION_LAYOUT,\n\tOPTION_IGNORECASE,\n\tOPTION_BREAKAT,\n\tOPTION_WRAP_COLUMN,\n};\n\nstatic const OptionDef options[] = {\n\t[OPTION_SHELL] = {\n\t\t{ \"shell\" },\n\t\tVIS_OPTION_TYPE_STRING,\n\t\tVIS_HELP(\"Shell to use for external commands (default: $SHELL, /etc/passwd, /bin/sh)\")\n\t},\n\t[OPTION_ESCDELAY] = {\n\t\t{ \"escdelay\" },\n\t\tVIS_OPTION_TYPE_NUMBER,\n\t\tVIS_HELP(\"Milliseconds to wait to distinguish <Escape> from terminal escape sequences\")\n\t},\n\t[OPTION_AUTOINDENT] = {\n\t\t{ \"autoindent\", \"ai\" },\n\t\tVIS_OPTION_TYPE_BOOL,\n\t\tVIS_HELP(\"Copy leading white space from previous line\")\n\t},\n\t[OPTION_EXPANDTAB] = {\n\t\t{ \"expandtab\", \"et\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Replace entered <Tab> with `tabwidth` spaces\")\n\t},\n\t[OPTION_TABWIDTH] = {\n\t\t{ \"tabwidth\", \"tw\" },\n\t\tVIS_OPTION_TYPE_NUMBER|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Number of spaces to display (and insert if `expandtab` is enabled) for a tab\")\n\t},\n\t[OPTION_SHOW_SPACES] = {\n\t\t{ \"showspaces\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display replacement symbol instead of a space\")\n\t},\n\t[OPTION_SHOW_TABS] = {\n\t\t{ \"showtabs\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display replacement symbol for tabs\")\n\t},\n\t[OPTION_SHOW_NEWLINES] = {\n\t\t{ \"shownewlines\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display replacement symbol for newlines\")\n\t},\n\t[OPTION_SHOW_EOF] = {\n\t\t{ \"showeof\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display replacement symbol for lines after the end of the file\")\n\t},\n\t[OPTION_STATUSBAR] = {\n\t\t{ \"statusbar\", \"sb\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display status bar\")\n\t},\n\t[OPTION_NUMBER] = {\n\t\t{ \"numbers\", \"nu\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display absolute line numbers\")\n\t},\n\t[OPTION_NUMBER_RELATIVE] = {\n\t\t{ \"relativenumbers\", \"rnu\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Display relative line numbers\")\n\t},\n\t[OPTION_CURSOR_LINE] = {\n\t\t{ \"cursorline\", \"cul\" },\n\t\tVIS_OPTION_TYPE_BOOL|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Highlight current cursor line\")\n\t},\n\t[OPTION_COLOR_COLUMN] = {\n\t\t{ \"colorcolumn\", \"cc\" },\n\t\tVIS_OPTION_TYPE_NUMBER|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Highlight a fixed column\")\n\t},\n\t[OPTION_SAVE_METHOD] = {\n\t\t{ \"savemethod\" },\n\t\tVIS_OPTION_TYPE_STRING|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Save method to use for current file 'auto', 'atomic' or 'inplace'\")\n\t},\n\t[OPTION_LOAD_METHOD] = {\n\t\t{ \"loadmethod\" },\n\t\tVIS_OPTION_TYPE_STRING,\n\t\tVIS_HELP(\"How to load existing files 'auto', 'read' or 'mmap'\")\n\t},\n\t[OPTION_CHANGE_256COLORS] = {\n\t\t{ \"change256colors\" },\n\t\tVIS_OPTION_TYPE_BOOL,\n\t\tVIS_HELP(\"Change 256 color palette to support 24bit colors\")\n\t},\n\t[OPTION_LAYOUT] = {\n\t\t{ \"layout\" },\n\t\tVIS_OPTION_TYPE_STRING,\n\t\tVIS_HELP(\"Vertical or horizontal window layout\")\n\t},\n\t[OPTION_IGNORECASE] = {\n\t\t{ \"ignorecase\", \"ic\" },\n\t\tVIS_OPTION_TYPE_BOOL,\n\t\tVIS_HELP(\"Ignore case when searching\")\n\t},\n\t[OPTION_BREAKAT] = {\n\t\t{ \"breakat\", \"brk\" },\n\t\tVIS_OPTION_TYPE_STRING|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Characters which might cause a word wrap\")\n\t},\n\t[OPTION_WRAP_COLUMN] = {\n\t\t{ \"wrapcolumn\", \"wc\" },\n\t\tVIS_OPTION_TYPE_NUMBER|VIS_OPTION_NEED_WINDOW,\n\t\tVIS_HELP(\"Wrap lines at minimum of window width and wrapcolumn\")\n\t},\n};\n\nbool sam_init(Vis *vis) {\n\tif (!(vis->cmds = map_new()))\n\t\treturn false;\n\tbool ret = true;\n\tfor (const CommandDef *cmd = cmds; cmd && cmd->name; cmd++)\n\t\tret &= map_put(vis->cmds, cmd->name, cmd);\n\n\tif (!(vis->options = map_new()))\n\t\treturn false;\n\tfor (int i = 0; i < LENGTH(options); i++) {\n\t\tfor (const char *const *name = options[i].names; *name; name++)\n\t\t\tret &= map_put(vis->options, *name, &options[i]);\n\t}\n\n\treturn ret;\n}\n\nconst char *sam_error(enum SamError err) {\n\tstatic const char *error_msg[] = {\n\t\t[SAM_ERR_OK]              = \"Success\",\n\t\t[SAM_ERR_MEMORY]          = \"Out of memory\",\n\t\t[SAM_ERR_ADDRESS]         = \"Bad address\",\n\t\t[SAM_ERR_NO_ADDRESS]      = \"Command takes no address\",\n\t\t[SAM_ERR_UNMATCHED_BRACE] = \"Unmatched `}'\",\n\t\t[SAM_ERR_REGEX]           = \"Bad regular expression\",\n\t\t[SAM_ERR_TEXT]            = \"Bad text\",\n\t\t[SAM_ERR_SHELL]           = \"Shell command expected\",\n\t\t[SAM_ERR_COMMAND]         = \"Unknown command\",\n\t\t[SAM_ERR_EXECUTE]         = \"Error executing command\",\n\t\t[SAM_ERR_NEWLINE]         = \"Newline expected\",\n\t\t[SAM_ERR_MARK]            = \"Invalid mark\",\n\t\t[SAM_ERR_CONFLICT]        = \"Conflicting changes\",\n\t\t[SAM_ERR_WRITE_CONFLICT]  = \"Can not write while changing\",\n\t\t[SAM_ERR_LOOP_INVALID_CMD]  = \"Destructive command in looping construct\",\n\t\t[SAM_ERR_GROUP_INVALID_CMD] = \"Destructive command in group\",\n\t\t[SAM_ERR_COUNT]           = \"Invalid count\",\n\t};\n\n\tsize_t idx = err;\n\treturn idx < LENGTH(error_msg) ? error_msg[idx] : NULL;\n}\n\nstatic void change_free(Change *c) {\n\tif (!c)\n\t\treturn;\n\tfree((char*)c->data);\n\tfree(c);\n}\n\nstatic Change *change_new(Transcript *t, enum ChangeType type, Filerange *range, Win *win, Selection *sel) {\n\tif (!text_range_valid(range))\n\t\treturn NULL;\n\tChange **prev, *next;\n\tif (t->latest && t->latest->range.end <= range->start) {\n\t\tprev = &t->latest->next;\n\t\tnext = t->latest->next;\n\t} else {\n\t\tprev = &t->changes;\n\t\tnext = t->changes;\n\t}\n\twhile (next && next->range.end <= range->start) {\n\t\tprev = &next->next;\n\t\tnext = next->next;\n\t}\n\tif (next && next->range.start < range->end) {\n\t\tt->error = SAM_ERR_CONFLICT;\n\t\treturn NULL;\n\t}\n\tChange *new = calloc(1, sizeof *new);\n\tif (new) {\n\t\tnew->type = type;\n\t\tnew->range = *range;\n\t\tnew->sel = sel;\n\t\tnew->win = win;\n\t\tnew->next = next;\n\t\t*prev = new;\n\t\tt->latest = new;\n\t}\n\treturn new;\n}\n\nstatic void sam_transcript_init(Transcript *t) {\n\tmemset(t, 0, sizeof *t);\n}\n\nstatic bool sam_transcript_error(Transcript *t, enum SamError error) {\n\tif (t->changes)\n\t\tt->error = error;\n\treturn t->error;\n}\n\nstatic void sam_transcript_free(Transcript *t) {\n\tfor (Change *c = t->changes, *next; c; c = next) {\n\t\tnext = c->next;\n\t\tchange_free(c);\n\t}\n}\n\nstatic bool sam_insert(Win *win, Selection *sel, size_t pos, const char *data, size_t len, int count) {\n\tFilerange range = text_range_new(pos, pos);\n\tChange *c = change_new(&win->file->transcript, TRANSCRIPT_INSERT, &range, win, sel);\n\tif (c) {\n\t\tc->data = data;\n\t\tc->len = len;\n\t\tc->count = count;\n\t}\n\treturn c;\n}\n\nstatic bool sam_delete(Win *win, Selection *sel, Filerange *range) {\n\treturn change_new(&win->file->transcript, TRANSCRIPT_DELETE, range, win, sel);\n}\n\nstatic bool sam_change(Win *win, Selection *sel, Filerange *range, const char *data, size_t len, int count) {\n\tChange *c = change_new(&win->file->transcript, TRANSCRIPT_CHANGE, range, win, sel);\n\tif (c) {\n\t\tc->data = data;\n\t\tc->len = len;\n\t\tc->count = count;\n\t}\n\treturn c;\n}\n\nstatic Address *address_new(void) {\n\tAddress *addr = calloc(1, sizeof *addr);\n\tif (addr)\n\t\taddr->number = EPOS;\n\treturn addr;\n}\n\nstatic void address_free(Address *addr) {\n\tif (!addr)\n\t\treturn;\n\ttext_regex_free(addr->regex);\n\taddress_free(addr->left);\n\taddress_free(addr->right);\n\tfree(addr);\n}\n\nstatic void skip_spaces(const char **s) {\n\twhile (**s == ' ' || **s == '\\t')\n\t\t(*s)++;\n}\n\nstatic char *parse_until(const char **s, const char *until, const char *escchars, int type){\n\tBuffer buf = {0};\n\tsize_t len = strlen(until);\n\tbool escaped = false;\n\n\tfor (; **s && (!memchr(until, **s, len) || escaped); (*s)++) {\n\t\tif (type != CMD_SHELL && !escaped && **s == '\\\\') {\n\t\t\tescaped = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar c = **s;\n\n\t\tif (escaped) {\n\t\t\tescaped = false;\n\t\t\tif (c == '\\n')\n\t\t\t\tcontinue;\n\t\t\tif (c == 'n') {\n\t\t\t\tc = '\\n';\n\t\t\t} else if (c == 't') {\n\t\t\t\tc = '\\t';\n\t\t\t} else if (type != CMD_REGEX && type != CMD_TEXT && c == '\\\\') {\n\t\t\t\t// ignore one of the back slashes\n\t\t\t} else {\n\t\t\t\tbool delim = memchr(until, c, len);\n\t\t\t\tbool esc = escchars && memchr(escchars, c, strlen(escchars));\n\t\t\t\tif (!delim && !esc)\n\t\t\t\t\tbuffer_append(&buf, \"\\\\\", 1);\n\t\t\t}\n\t\t}\n\n\t\tif (!buffer_append(&buf, &c, 1)) {\n\t\t\tbuffer_release(&buf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbuffer_terminate(&buf);\n\n\treturn buf.data;\n}\n\nstatic char *parse_delimited(const char **s, int type) {\n\tchar delim[2] = { **s, '\\0' };\n\tif (!delim[0] || isspace((unsigned char)delim[0]))\n\t\treturn NULL;\n\t(*s)++;\n\tchar *chunk = parse_until(s, delim, NULL, type);\n\tif (**s == delim[0])\n\t\t(*s)++;\n\treturn chunk;\n}\n\nstatic int parse_number(const char **s) {\n\tchar *end = NULL;\n\tint number = strtoull(*s, &end, 10);\n\tif (end == *s)\n\t\treturn 0;\n\t*s = end;\n\treturn number;\n}\n\nstatic char *parse_text(const char **s, Count *count) {\n\tskip_spaces(s);\n\tconst char *before = *s;\n\tcount->start = parse_number(s);\n\tif (*s == before)\n\t\tcount->start = 1;\n\tif (**s != '\\n') {\n\t\tbefore = *s;\n\t\tchar *text = parse_delimited(s, CMD_TEXT);\n\t\treturn (!text && *s != before) ? strdup(\"\") : text;\n\t}\n\n\tBuffer buf = {0};\n\tconst char *start = *s + 1;\n\tbool dot = false;\n\n\tfor ((*s)++; **s && (!dot || **s != '\\n'); (*s)++)\n\t\tdot = (**s == '.');\n\n\tif (!dot || !buffer_put(&buf, start, *s - start - 1) ||\n\t    !buffer_append(&buf, \"\\0\", 1)) {\n\t\tbuffer_release(&buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf.data;\n}\n\nstatic char *parse_shellcmd(Vis *vis, const char **s) {\n\tskip_spaces(s);\n\tchar *cmd = parse_until(s, \"\\n\", NULL, false);\n\tif (!cmd) {\n\t\tconst char *last_cmd = register_get(vis, &vis->registers[VIS_REG_SHELL], NULL);\n\t\treturn last_cmd ? strdup(last_cmd) : NULL;\n\t}\n\tregister_put0(vis, &vis->registers[VIS_REG_SHELL], cmd);\n\treturn cmd;\n}\n\nstatic void parse_argv(const char **s, const char *argv[], size_t maxarg) {\n\tfor (size_t i = 0; i < maxarg; i++) {\n\t\tskip_spaces(s);\n\t\tif (**s == '\"' || **s == '\\'')\n\t\t\targv[i] = parse_delimited(s, CMD_ARGV);\n\t\telse\n\t\t\targv[i] = parse_until(s, \" \\t\\n\", \"\\'\\\"\", CMD_ARGV);\n\t}\n}\n\nstatic bool valid_cmdname(const char *s) {\n\tunsigned char c = (unsigned char)*s;\n\treturn c && !isspace(c) && !isdigit(c) && (!ispunct(c) || c == '_' || (c == '-' && valid_cmdname(s+1)));\n}\n\nstatic char *parse_cmdname(const char **s) {\n\tBuffer buf = {0};\n\n\tskip_spaces(s);\n\twhile (valid_cmdname(*s))\n\t\tbuffer_append(&buf, (*s)++, 1);\n\n\tbuffer_terminate(&buf);\n\n\treturn buf.data;\n}\n\nstatic Regex *parse_regex(Vis *vis, const char **s) {\n\tconst char *before = *s;\n\tchar *pattern = parse_delimited(s, CMD_REGEX);\n\tif (!pattern && *s == before)\n\t\treturn NULL;\n\tRegex *regex = vis_regex(vis, pattern);\n\tfree(pattern);\n\treturn regex;\n}\n\nstatic enum SamError parse_count(const char **s, Count *count) {\n\tcount->mod = **s == '%';\n\n\tif (count->mod) {\n\t\t(*s)++;\n\t\tint n = parse_number(s);\n\t\tif (!n)\n\t\t\treturn SAM_ERR_COUNT;\n\t\tcount->start = n;\n\t\tcount->end = n;\n\t\treturn SAM_ERR_OK;\n\t}\n\n\tconst char *before = *s;\n\tif (!(count->start = parse_number(s)) && *s != before)\n\t\treturn SAM_ERR_COUNT;\n\tif (**s != ',') {\n\t\tcount->end = count->start ? count->start : INT_MAX;\n\t\treturn SAM_ERR_OK;\n\t} else {\n\t\t(*s)++;\n\t}\n\tbefore = *s;\n\tif (!(count->end = parse_number(s)) && *s != before)\n\t\treturn SAM_ERR_COUNT;\n\tif (!count->end)\n\t\tcount->end = INT_MAX;\n\treturn SAM_ERR_OK;\n}\n\nstatic Address *address_parse_simple(Vis *vis, const char **s, enum SamError *err) {\n\n\tskip_spaces(s);\n\n\tAddress addr = {\n\t\t.type = **s,\n\t\t.regex = NULL,\n\t\t.number = EPOS,\n\t\t.left = NULL,\n\t\t.right = NULL,\n\t};\n\n\tswitch (addr.type) {\n\tcase '#': /* character #n */\n\t\t(*s)++;\n\t\taddr.number = parse_number(s);\n\t\tbreak;\n\tcase '0': case '1': case '2': case '3': case '4': /* line n */\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\taddr.type = 'l';\n\t\taddr.number = parse_number(s);\n\t\tbreak;\n\tcase '\\'':\n\t\t(*s)++;\n\t\tif ((addr.number = vis_mark_from(vis, **s)) == VIS_MARK_INVALID) {\n\t\t\t*err = SAM_ERR_MARK;\n\t\t\treturn NULL;\n\t\t}\n\t\t(*s)++;\n\t\tbreak;\n\tcase '/': /* regexp forwards */\n\tcase '?': /* regexp backwards */\n\t\taddr.regex = parse_regex(vis, s);\n\t\tif (!addr.regex) {\n\t\t\t*err = SAM_ERR_REGEX;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase '$': /* end of file */\n\tcase '.':\n\tcase '+':\n\tcase '-':\n\tcase '%':\n\t\t(*s)++;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tif ((addr.right = address_parse_simple(vis, s, err))) {\n\t\tswitch (addr.right->type) {\n\t\tcase '.':\n\t\tcase '$':\n\t\t\treturn NULL;\n\t\tcase '#':\n\t\tcase 'l':\n\t\tcase '/':\n\t\tcase '?':\n\t\t\tif (addr.type != '+' && addr.type != '-') {\n\t\t\t\tAddress *plus = address_new();\n\t\t\t\tif (!plus) {\n\t\t\t\t\taddress_free(addr.right);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tplus->type = '+';\n\t\t\t\tplus->right = addr.right;\n\t\t\t\taddr.right = plus;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tAddress *ret = address_new();\n\tif (!ret) {\n\t\taddress_free(addr.right);\n\t\treturn NULL;\n\t}\n\t*ret = addr;\n\treturn ret;\n}\n\nstatic Address *address_parse_compound(Vis *vis, const char **s, enum SamError *err) {\n\tAddress addr = { 0 }, *left = address_parse_simple(vis, s, err), *right = NULL;\n\tskip_spaces(s);\n\taddr.type = **s;\n\tswitch (addr.type) {\n\tcase ',': /* a1,a2 */\n\tcase ';': /* a1;a2 */\n\t\t(*s)++;\n\t\tright = address_parse_compound(vis, s, err);\n\t\tif (right && (right->type == ',' || right->type == ';') && !right->left) {\n\t\t\t*err = SAM_ERR_ADDRESS;\n\t\t\tgoto fail;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn left;\n\t}\n\n\taddr.left = left;\n\taddr.right = right;\n\n\tAddress *ret = address_new();\n\tif (ret) {\n\t\t*ret = addr;\n\t\treturn ret;\n\t}\n\nfail:\n\taddress_free(left);\n\taddress_free(right);\n\treturn NULL;\n}\n\nstatic Command *command_new(const char *name) {\n\tCommand *cmd = calloc(1, sizeof(Command));\n\tif (!cmd)\n\t\treturn NULL;\n\tif (name && !(cmd->argv[0] = strdup(name))) {\n\t\tfree(cmd);\n\t\treturn NULL;\n\t}\n\treturn cmd;\n}\n\nstatic void command_free(Command *cmd) {\n\tif (!cmd)\n\t\treturn;\n\n\tfor (Command *c = cmd->cmd, *next; c; c = next) {\n\t\tnext = c->next;\n\t\tcommand_free(c);\n\t}\n\n\tfor (const char **args = cmd->argv; *args; args++)\n\t\tfree((void*)*args);\n\taddress_free(cmd->address);\n\ttext_regex_free(cmd->regex);\n\tfree(cmd);\n}\n\nstatic const CommandDef *command_lookup(Vis *vis, const char *name) {\n\treturn map_closest(vis->cmds, name);\n}\n\nstatic Command *command_parse(Vis *vis, const char **s, enum SamError *err) {\n\tif (!**s) {\n\t\t*err = SAM_ERR_COMMAND;\n\t\treturn NULL;\n\t}\n\tCommand *cmd = command_new(NULL);\n\tif (!cmd)\n\t\treturn NULL;\n\n\tcmd->address = address_parse_compound(vis, s, err);\n\tskip_spaces(s);\n\n\tcmd->argv[0] = parse_cmdname(s);\n\n\tif (!cmd->argv[0]) {\n\t\tchar name[2] = { **s ? **s : 'p', '\\0' };\n\t\tif (**s)\n\t\t\t(*s)++;\n\t\tif (!(cmd->argv[0] = strdup(name)))\n\t\t\tgoto fail;\n\t}\n\n\tconst CommandDef *cmddef = command_lookup(vis, cmd->argv[0]);\n\tif (!cmddef) {\n\t\t*err = SAM_ERR_COMMAND;\n\t\tgoto fail;\n\t}\n\n\tcmd->cmddef = cmddef;\n\n\tif (strcmp(cmd->argv[0], \"{\") == 0) {\n\t\tCommand *prev = NULL, *next;\n\t\tint level = vis->nesting_level++;\n\t\tdo {\n\t\t\twhile (**s == ' ' || **s == '\\t' || **s == '\\n')\n\t\t\t\t(*s)++;\n\t\t\tnext = command_parse(vis, s, err);\n\t\t\tif (*err)\n\t\t\t\tgoto fail;\n\t\t\tif (prev)\n\t\t\t\tprev->next = next;\n\t\t\telse\n\t\t\t\tcmd->cmd = next;\n\t\t} while ((prev = next));\n\t\tif (level != vis->nesting_level) {\n\t\t\t*err = SAM_ERR_UNMATCHED_BRACE;\n\t\t\tgoto fail;\n\t\t}\n\t} else if (strcmp(cmd->argv[0], \"}\") == 0) {\n\t\tif (vis->nesting_level-- == 0) {\n\t\t\t*err = SAM_ERR_UNMATCHED_BRACE;\n\t\t\tgoto fail;\n\t\t}\n\t\tcommand_free(cmd);\n\t\treturn NULL;\n\t}\n\n\tif (cmddef->flags & CMD_ADDRESS_NONE && cmd->address) {\n\t\t*err = SAM_ERR_NO_ADDRESS;\n\t\tgoto fail;\n\t}\n\n\tif (cmddef->flags & CMD_FORCE && **s == '!') {\n\t\tcmd->flags = '!';\n\t\t(*s)++;\n\t}\n\n\tif ((cmddef->flags & CMD_COUNT) && (*err = parse_count(s, &cmd->count)))\n\t\tgoto fail;\n\n\tif (cmddef->flags & CMD_REGEX) {\n\t\tif ((cmddef->flags & CMD_REGEX_DEFAULT) && (!**s || **s == ' ')) {\n\t\t\tskip_spaces(s);\n\t\t} else {\n\t\t\tconst char *before = *s;\n\t\t\tcmd->regex = parse_regex(vis, s);\n\t\t\tif (!cmd->regex && (*s != before || !(cmddef->flags & CMD_COUNT))) {\n\t\t\t\t*err = SAM_ERR_REGEX;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cmddef->flags & CMD_SHELL && !(cmd->argv[1] = parse_shellcmd(vis, s))) {\n\t\t*err = SAM_ERR_SHELL;\n\t\tgoto fail;\n\t}\n\n\tif (cmddef->flags & CMD_TEXT && !(cmd->argv[1] = parse_text(s, &cmd->count))) {\n\t\t*err = SAM_ERR_TEXT;\n\t\tgoto fail;\n\t}\n\n\tif (cmddef->flags & CMD_ARGV) {\n\t\tparse_argv(s, &cmd->argv[1], MAX_ARGV-2);\n\t\tcmd->argv[MAX_ARGV-1] = NULL;\n\t}\n\n\tif (cmddef->flags & CMD_CMD) {\n\t\tskip_spaces(s);\n\t\tif (cmddef->defcmd && (**s == '\\n' || **s == '}' || **s == '\\0')) {\n\t\t\tif (**s == '\\n')\n\t\t\t\t(*s)++;\n\t\t\tif (!(cmd->cmd = command_new(cmddef->defcmd)))\n\t\t\t\tgoto fail;\n\t\t\tcmd->cmd->cmddef = command_lookup(vis, cmddef->defcmd);\n\t\t} else {\n\t\t\tif (!(cmd->cmd = command_parse(vis, s, err)))\n\t\t\t\tgoto fail;\n\t\t\tif (strcmp(cmd->argv[0], \"X\") == 0 || strcmp(cmd->argv[0], \"Y\") == 0) {\n\t\t\t\tCommand *sel = command_new(\"select\");\n\t\t\t\tif (!sel)\n\t\t\t\t\tgoto fail;\n\t\t\t\tsel->cmd = cmd->cmd;\n\t\t\t\tsel->cmddef = &cmddef_select;\n\t\t\t\tcmd->cmd = sel;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn cmd;\nfail:\n\tcommand_free(cmd);\n\treturn NULL;\n}\n\nstatic Command *sam_parse(Vis *vis, const char *cmd, enum SamError *err) {\n\tvis->nesting_level = 0;\n\tconst char **s = &cmd;\n\tCommand *c = command_parse(vis, s, err);\n\tif (!c)\n\t\treturn NULL;\n\twhile (**s == ' ' || **s == '\\t' || **s == '\\n')\n\t\t(*s)++;\n\tif (**s) {\n\t\t*err = SAM_ERR_NEWLINE;\n\t\tcommand_free(c);\n\t\treturn NULL;\n\t}\n\n\tCommand *sel = command_new(\"select\");\n\tif (!sel) {\n\t\tcommand_free(c);\n\t\treturn NULL;\n\t}\n\tsel->cmd = c;\n\tsel->cmddef = &cmddef_select;\n\treturn sel;\n}\n\nstatic Filerange address_line_evaluate(Address *addr, File *file, Filerange *range, int sign) {\n\tText *txt = file->text;\n\tsize_t offset = addr->number != EPOS ? addr->number : 1;\n\tsize_t start = range->start, end = range->end, line;\n\tif (sign > 0) {\n\t\tchar c;\n\t\tif (start < end && text_byte_get(txt, end-1, &c) && c == '\\n')\n\t\t\tend--;\n\t\tline = text_lineno_by_pos(txt, end);\n\t\tline = text_pos_by_lineno(txt, line + offset);\n\t} else if (sign < 0) {\n\t\tline = text_lineno_by_pos(txt, start);\n\t\tline = offset < line ? text_pos_by_lineno(txt, line - offset) : 0;\n\t} else {\n\t\tif (addr->number == 0)\n\t\t\treturn text_range_new(0, 0);\n\t\tline = text_pos_by_lineno(txt, addr->number);\n\t}\n\n\tif (addr->type == 'g')\n\t\treturn text_range_new(line, line);\n\telse\n\t\treturn text_range_new(line, text_line_next(txt, line));\n}\n\nstatic Filerange address_evaluate(Address *addr, File *file, Selection *sel, Filerange *range, int sign) {\n\tFilerange ret = text_range_empty();\n\n\tdo {\n\t\tswitch (addr->type) {\n\t\tcase '#':\n\t\t\tif (sign > 0)\n\t\t\t\tret.start = ret.end = range->end + addr->number;\n\t\t\telse if (sign < 0)\n\t\t\t\tret.start = ret.end = range->start - addr->number;\n\t\t\telse\n\t\t\t\tret = text_range_new(addr->number, addr->number);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'g':\n\t\t\tret = address_line_evaluate(addr, file, range, sign);\n\t\t\tbreak;\n\t\tcase '\\'':\n\t\t{\n\t\t\tsize_t pos = EPOS;\n\t\t\tArray *marks = &file->marks[addr->number];\n\t\t\tsize_t idx = sel ? view_selections_number(sel) : 0;\n\t\t\tSelectionRegion *sr = array_get(marks, idx);\n\t\t\tif (sr)\n\t\t\t\tpos = text_mark_get(file->text, sr->cursor);\n\t\t\tret = text_range_new(pos, pos);\n\t\t\tbreak;\n\t\t}\n\t\tcase '?':\n\t\t\tsign = sign == 0 ? -1 : -sign;\n\t\t\t/* fall through */\n\t\tcase '/':\n\t\t\tif (sign >= 0)\n\t\t\t\tret = text_object_search_forward(file->text, range->end, addr->regex);\n\t\t\telse\n\t\t\t\tret = text_object_search_backward(file->text, range->start, addr->regex);\n\t\t\tbreak;\n\t\tcase '$':\n\t\t{\n\t\t\tsize_t size = text_size(file->text);\n\t\t\tret = text_range_new(size, size);\n\t\t\tbreak;\n\t\t}\n\t\tcase '.':\n\t\t\tret = *range;\n\t\t\tbreak;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\tsign = addr->type == '+' ? +1 : -1;\n\t\t\tif (!addr->right || addr->right->type == '+' || addr->right->type == '-')\n\t\t\t\tret = address_line_evaluate(addr, file, range, sign);\n\t\t\tbreak;\n\t\tcase ',':\n\t\tcase ';':\n\t\t{\n\t\t\tFilerange left, right;\n\t\t\tif (addr->left)\n\t\t\t\tleft = address_evaluate(addr->left, file, sel, range, 0);\n\t\t\telse\n\t\t\t\tleft = text_range_new(0, 0);\n\n\t\t\tif (addr->type == ';')\n\t\t\t\trange = &left;\n\n\t\t\tif (addr->right) {\n\t\t\t\tright = address_evaluate(addr->right, file, sel, range, 0);\n\t\t\t} else {\n\t\t\t\tsize_t size = text_size(file->text);\n\t\t\t\tright = text_range_new(size, size);\n\t\t\t}\n\t\t\t/* TODO: enforce strict ordering? */\n\t\t\treturn text_range_union(&left, &right);\n\t\t}\n\t\tcase '%':\n\t\t\treturn text_range_new(0, text_size(file->text));\n\t\t}\n\t\tif (text_range_valid(&ret))\n\t\t\trange = &ret;\n\t} while ((addr = addr->right));\n\n\treturn ret;\n}\n\nstatic bool count_evaluate(Command *cmd) {\n\tCount *count = &cmd->count;\n\tif (count->mod)\n\t\treturn count->start ? cmd->iteration % count->start == 0 : true;\n\treturn count->start <= cmd->iteration && cmd->iteration <= count->end;\n}\n\nstatic bool sam_execute(Vis *vis, Win *win, Command *cmd, Selection *sel, Filerange *range) {\n\tbool ret = true;\n\tif (cmd->address && win)\n\t\t*range = address_evaluate(cmd->address, win->file, sel, range, 0);\n\n\tcmd->iteration++;\n\tswitch (cmd->argv[0][0]) {\n\tcase '{':\n\t{\n\t\tfor (Command *c = cmd->cmd; c && ret; c = c->next)\n\t\t\tret &= sam_execute(vis, win, c, NULL, range);\n\t\tview_selections_dispose_force(sel);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = cmd->cmddef->func(vis, win, cmd, cmd->argv, sel, range);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic enum SamError validate(Command *cmd, bool loop, bool group) {\n\tif (cmd->cmddef->flags & CMD_DESTRUCTIVE) {\n\t\tif (loop)\n\t\t\treturn SAM_ERR_LOOP_INVALID_CMD;\n\t\tif (group)\n\t\t\treturn SAM_ERR_GROUP_INVALID_CMD;\n\t}\n\n\tgroup |= (cmd->cmddef->flags & CMD_GROUP);\n\tloop  |= (cmd->cmddef->flags & CMD_LOOP);\n\tfor (Command *c = cmd->cmd; c; c = c->next) {\n\t\tenum SamError err = validate(c, loop, group);\n\t\tif (err != SAM_ERR_OK)\n\t\t\treturn err;\n\t}\n\treturn SAM_ERR_OK;\n}\n\nstatic enum SamError command_validate(Command *cmd) {\n\treturn validate(cmd, false, false);\n}\n\nstatic bool count_negative(Command *cmd) {\n\tif (cmd->count.start < 0 || cmd->count.end < 0)\n\t\treturn true;\n\tfor (Command *c = cmd->cmd; c; c = c->next) {\n\t\tif (c->cmddef->func != cmd_extract && c->cmddef->func != cmd_select) {\n\t\t\tif (count_negative(c))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic void count_init(Command *cmd, int max) {\n\tCount *count = &cmd->count;\n\tcmd->iteration = 0;\n\tif (count->start < 0)\n\t\tcount->start += max;\n\tif (count->end < 0)\n\t\tcount->end += max;\n\tfor (Command *c = cmd->cmd; c; c = c->next) {\n\t\tif (c->cmddef->func != cmd_extract && c->cmddef->func != cmd_select)\n\t\t\tcount_init(c, max);\n\t}\n}\n\nenum SamError sam_cmd(Vis *vis, const char *s) {\n\tenum SamError err = SAM_ERR_OK;\n\tif (!s)\n\t\treturn err;\n\n\tCommand *cmd = sam_parse(vis, s, &err);\n\tif (!cmd) {\n\t\tif (err == SAM_ERR_OK)\n\t\t\terr = SAM_ERR_MEMORY;\n\t\treturn err;\n\t}\n\n\terr = command_validate(cmd);\n\tif (err != SAM_ERR_OK) {\n\t\tcommand_free(cmd);\n\t\treturn err;\n\t}\n\n\tfor (File *file = vis->files; file; file = file->next) {\n\t\tif (file->internal)\n\t\t\tcontinue;\n\t\tsam_transcript_init(&file->transcript);\n\t}\n\n\tbool visual = vis->mode->visual;\n\tsize_t primary_pos = vis->win ? view_cursor_get(&vis->win->view) : EPOS;\n\tFilerange range = text_range_empty();\n\tsam_execute(vis, vis->win, cmd, NULL, &range);\n\n\tfor (File *file = vis->files; file; file = file->next) {\n\t\tif (file->internal)\n\t\t\tcontinue;\n\t\tTranscript *t = &file->transcript;\n\t\tif (t->error != SAM_ERR_OK) {\n\t\t\terr = t->error;\n\t\t\tsam_transcript_free(t);\n\t\t\tcontinue;\n\t\t}\n\t\tvis_file_snapshot(vis, file);\n\t\tptrdiff_t delta = 0;\n\t\tfor (Change *c = t->changes; c; c = c->next) {\n\t\t\tc->range.start += delta;\n\t\t\tc->range.end += delta;\n\t\t\tif (c->type & TRANSCRIPT_DELETE) {\n\t\t\t\ttext_delete_range(file->text, &c->range);\n\t\t\t\tdelta -= text_range_size(&c->range);\n\t\t\t\tif (c->sel && c->type == TRANSCRIPT_DELETE) {\n\t\t\t\t\tif (visual)\n\t\t\t\t\t\tview_selections_dispose_force(c->sel);\n\t\t\t\t\telse\n\t\t\t\t\t\tview_cursors_to(c->sel, c->range.start);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c->type & TRANSCRIPT_INSERT) {\n\t\t\t\tfor (int i = 0; i < c->count; i++) {\n\t\t\t\t\ttext_insert(file->text, c->range.start, c->data, c->len);\n\t\t\t\t\tdelta += c->len;\n\t\t\t\t}\n\t\t\t\tFilerange r = text_range_new(c->range.start,\n\t\t\t\t                             c->range.start + c->len * c->count);\n\t\t\t\tif (c->sel) {\n\t\t\t\t\tif (visual) {\n\t\t\t\t\t\tview_selections_set(c->sel, &r);\n\t\t\t\t\t\tc->sel->anchored = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (memchr(c->data, '\\n', c->len))\n\t\t\t\t\t\t\tview_cursors_to(c->sel, r.start);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tview_cursors_to(c->sel, r.end);\n\t\t\t\t\t}\n\t\t\t\t} else if (visual) {\n\t\t\t\t\tSelection *sel = view_selections_new(&c->win->view, r.start);\n\t\t\t\t\tif (sel) {\n\t\t\t\t\t\tview_selections_set(sel, &r);\n\t\t\t\t\t\tsel->anchored = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsam_transcript_free(&file->transcript);\n\t\tvis_file_snapshot(vis, file);\n\t}\n\n\tfor (Win *win = vis->windows; win; win = win->next)\n\t\tview_selections_normalize(&win->view);\n\n\tif (vis->win) {\n\t\tif (primary_pos != EPOS && view_selection_disposed(&vis->win->view))\n\t\t\tview_cursors_to(vis->win->view.selection, primary_pos);\n\t\tview_selections_primary_set(view_selections(&vis->win->view));\n\t\tvis_jumplist_save(vis);\n\t\tbool completed = true;\n\t\tfor (Selection *s = view_selections(&vis->win->view); s; s = view_selections_next(s)) {\n\t\t\tif (s->anchored) {\n\t\t\t\tcompleted = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvis_mode_switch(vis, completed ? VIS_MODE_NORMAL : VIS_MODE_VISUAL);\n\t}\n\tcommand_free(cmd);\n\treturn err;\n}\n\n/* process text input, substitute register content for backreferences etc. */\nBuffer text(Vis *vis, const char *text) {\n\tBuffer buf = {0};\n\tfor (size_t len = strcspn(text, \"\\\\&\"); *text; len = strcspn(++text, \"\\\\&\")) {\n\t\tbuffer_append(&buf, text, len);\n\t\ttext += len;\n\t\tenum VisRegister regid = VIS_REG_INVALID;\n\t\tswitch (text[0]) {\n\t\tcase '&':\n\t\t\tregid = VIS_REG_AMPERSAND;\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif ('1' <= text[1] && text[1] <= '9') {\n\t\t\t\tregid = VIS_REG_1 + text[1] - '1';\n\t\t\t\ttext++;\n\t\t\t} else if (text[1] == '\\\\' || text[1] == '&') {\n\t\t\t\ttext++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tgoto out;\n\t\t}\n\n\t\tconst char *data;\n\t\tsize_t reglen = 0;\n\t\tif (regid != VIS_REG_INVALID) {\n\t\t\tdata = register_get(vis, &vis->registers[regid], &reglen);\n\t\t} else {\n\t\t\tdata = text;\n\t\t\treglen = 1;\n\t\t}\n\t\tbuffer_append(&buf, data, reglen);\n\t}\nout:\n\treturn buf;\n}\n\nstatic bool cmd_insert(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tBuffer buf = text(vis, argv[1]);\n\tbool ret = sam_insert(win, sel, range->start, buf.data, buf.len, cmd->count.start);\n\tif (!ret)\n\t\tfree(buf.data);\n\treturn ret;\n}\n\nstatic bool cmd_append(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tBuffer buf = text(vis, argv[1]);\n\tbool ret = sam_insert(win, sel, range->end, buf.data, buf.len, cmd->count.start);\n\tif (!ret)\n\t\tfree(buf.data);\n\treturn ret;\n}\n\nstatic bool cmd_change(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tBuffer buf = text(vis, argv[1]);\n\tbool ret = sam_change(win, sel, range, buf.data, buf.len, cmd->count.start);\n\tif (!ret)\n\t\tfree(buf.data);\n\treturn ret;\n}\n\nstatic bool cmd_delete(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\treturn win && sam_delete(win, sel, range);\n}\n\nstatic bool cmd_guard(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tbool match = false;\n\tRegexMatch captures[1];\n\tsize_t len = text_range_size(range);\n\tif (!cmd->regex)\n\t\tmatch = true;\n\telse if (!text_search_range_forward(win->file->text, range->start, len, cmd->regex, 1, captures, 0))\n\t\tmatch = captures[0].start < range->end;\n\tif ((count_evaluate(cmd) && match) ^ (argv[0][0] == 'v'))\n\t\treturn sam_execute(vis, win, cmd->cmd, sel, range);\n\tview_selections_dispose_force(sel);\n\treturn true;\n}\n\nstatic int extract(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range, bool simulate) {\n\tbool ret = true;\n\tint count = 0;\n\tText *txt = win->file->text;\n\n\tif (cmd->regex) {\n\t\tsize_t start = range->start, end = range->end;\n\t\tsize_t last_start = argv[0][0] == 'x' ? EPOS : start;\n\t\tsize_t nsub = 1 + text_regex_nsub(cmd->regex);\n\t\tif (nsub > MAX_REGEX_SUB)\n\t\t\tnsub = MAX_REGEX_SUB;\n\t\tRegexMatch match[MAX_REGEX_SUB];\n\t\twhile (start <= end) {\n\t\t\tchar c;\n\t\t\tint flags = start > range->start &&\n\t\t\t            text_byte_get(txt, start - 1, &c) && c != '\\n' ?\n\t\t\t            REG_NOTBOL : 0;\n\t\t\tbool found = !text_search_range_forward(txt, start, end - start,\n\t\t\t                                        cmd->regex, nsub, match,\n\t\t\t                                        flags);\n\t\t\tFilerange r = text_range_empty();\n\t\t\tif (found) {\n\t\t\t\tif (argv[0][0] == 'x')\n\t\t\t\t\tr = text_range_new(match[0].start, match[0].end);\n\t\t\t\telse\n\t\t\t\t\tr = text_range_new(last_start, match[0].start);\n\t\t\t\tif (match[0].start == match[0].end) {\n\t\t\t\t\tif (last_start == match[0].start) {\n\t\t\t\t\t\tstart++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t/* in Plan 9's regexp library ^ matches the beginning\n\t\t\t\t\t * of a line, however in POSIX with REG_NEWLINE ^\n\t\t\t\t\t * matches the zero-length string immediately after a\n\t\t\t\t\t * newline. Try filtering out the last such match at EOF.\n\t\t\t\t\t */\n\t\t\t\t\tif (end == match[0].start && start > range->start &&\n\t\t\t\t\t    text_byte_get(txt, end-1, &c) && c == '\\n')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tstart = match[0].end + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstart = match[0].end;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (argv[0][0] == 'y')\n\t\t\t\t\tr = text_range_new(start, end);\n\t\t\t\tstart = end + 1;\n\t\t\t}\n\n\t\t\tif (text_range_valid(&r)) {\n\t\t\t\tif (found) {\n\t\t\t\t\tfor (size_t i = 0; i < nsub; i++) {\n\t\t\t\t\t\tRegister *reg = &vis->registers[VIS_REG_AMPERSAND+i];\n\t\t\t\t\t\tregister_put_range(vis, reg, txt, &match[i]);\n\t\t\t\t\t}\n\t\t\t\t\tlast_start = match[0].end;\n\t\t\t\t} else {\n\t\t\t\t\tlast_start = start;\n\t\t\t\t}\n\t\t\t\tif (simulate)\n\t\t\t\t\tcount++;\n\t\t\t\telse\n\t\t\t\t\tret &= sam_execute(vis, win, cmd->cmd, NULL, &r);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsize_t start = range->start, end = range->end;\n\t\twhile (start < end) {\n\t\t\tsize_t next = text_line_next(txt, start);\n\t\t\tif (next > end)\n\t\t\t\tnext = end;\n\t\t\tFilerange r = text_range_new(start, next);\n\t\t\tif (start == next || !text_range_valid(&r))\n\t\t\t\tbreak;\n\t\t\tif (simulate)\n\t\t\t\tcount++;\n\t\t\telse\n\t\t\t\tret &= sam_execute(vis, win, cmd->cmd, NULL, &r);\n\t\t\tstart = next;\n\t\t}\n\t}\n\n\tif (!simulate)\n\t\tview_selections_dispose_force(sel);\n\treturn simulate ? count : ret;\n}\n\nstatic bool cmd_extract(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win || !text_range_valid(range))\n\t\treturn false;\n\tint matches = 0;\n\tif (count_negative(cmd->cmd))\n\t\tmatches = extract(vis, win, cmd, argv, sel, range, true);\n\tcount_init(cmd->cmd, matches+1);\n\treturn extract(vis, win, cmd, argv, sel, range, false);\n}\n\nstatic bool cmd_select(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tFilerange r = text_range_empty();\n\tif (!win)\n\t\treturn sam_execute(vis, NULL, cmd->cmd, NULL, &r);\n\tbool ret = true;\n\tView *view = &win->view;\n\tText *txt = win->file->text;\n\tbool multiple_cursors = view->selection_count > 1;\n\tSelection *primary = view_selections_primary_get(view);\n\n\tif (vis->mode->visual)\n\t\tcount_init(cmd->cmd, view->selection_count + 1);\n\n\tfor (Selection *s = view_selections(view), *next; s && ret; s = next) {\n\t\tnext = view_selections_next(s);\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tif (vis->mode->visual) {\n\t\t\tr = view_selections_get(s);\n\t\t} else if (cmd->cmd->address) {\n\t\t\t/* convert a single line range to a goto line motion */\n\t\t\tif (!multiple_cursors && cmd->cmd->cmddef->func == cmd_print) {\n\t\t\t\tAddress *addr = cmd->cmd->address;\n\t\t\t\tswitch (addr->type) {\n\t\t\t\tcase '+':\n\t\t\t\tcase '-':\n\t\t\t\t\taddr = addr->right;\n\t\t\t\t\t/* fall through */\n\t\t\t\tcase 'l':\n\t\t\t\t\tif (addr && addr->type == 'l' && !addr->right)\n\t\t\t\t\t\taddr->type = 'g';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = text_range_new(pos, pos);\n\t\t} else if (cmd->cmd->cmddef->flags & CMD_ADDRESS_POS) {\n\t\t\tr = text_range_new(pos, pos);\n\t\t} else if (cmd->cmd->cmddef->flags & CMD_ADDRESS_LINE) {\n\t\t\tr = text_object_line(txt, pos);\n\t\t} else if (cmd->cmd->cmddef->flags & CMD_ADDRESS_AFTER) {\n\t\t\tsize_t next_line = text_line_next(txt, pos);\n\t\t\tr = text_range_new(next_line, next_line);\n\t\t} else if (cmd->cmd->cmddef->flags & CMD_ADDRESS_ALL) {\n\t\t\tr = text_range_new(0, text_size(txt));\n\t\t} else if (!multiple_cursors && (cmd->cmd->cmddef->flags & CMD_ADDRESS_ALL_1CURSOR)) {\n\t\t\tr = text_range_new(0, text_size(txt));\n\t\t} else {\n\t\t\tr = text_range_new(pos, text_char_next(txt, pos));\n\t\t}\n\t\tif (!text_range_valid(&r))\n\t\t\tr = text_range_new(0, 0);\n\t\tret &= sam_execute(vis, win, cmd->cmd, s, &r);\n\t\tif (cmd->cmd->cmddef->flags & CMD_ONCE)\n\t\t\tbreak;\n\t}\n\n\tif (vis->win && &vis->win->view == view && primary != view_selections_primary_get(view))\n\t\tview_selections_primary_set(view_selections(view));\n\treturn ret;\n}\n\nstatic bool cmd_print(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win || !text_range_valid(range))\n\t\treturn false;\n\tif (!sel)\n\t\tsel = view_selections_new_force(&win->view, range->start);\n\tif (!sel)\n\t\treturn false;\n\tif (range->start != range->end) {\n\t\tview_selections_set(sel, range);\n\t\tsel->anchored = true;\n\t} else {\n\t\tview_cursors_to(sel, range->start);\n\t\tview_selection_clear(sel);\n\t}\n\treturn true;\n}\n\nstatic bool cmd_files(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tbool ret = true;\n\tfor (Win *wn, *w = vis->windows; w; w = wn) {\n\t\t/* w can get freed by sam_execute() so store w->next early */\n\t\twn = w->next;\n\t\tif (w->file->internal)\n\t\t\tcontinue;\n\t\tbool match = !cmd->regex ||\n\t\t             (w->file->name && text_regex_match(cmd->regex, w->file->name, 0) == 0);\n\t\tif (match ^ (argv[0][0] == 'Y')) {\n\t\t\tFilerange def = text_range_new(0, 0);\n\t\t\tret &= sam_execute(vis, w, cmd->cmd, NULL, &def);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic bool cmd_substitute(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tvis_info_show(vis, \"Use :x/pattern/ c/replacement/ instead\");\n\treturn false;\n}\n\n/* cmd_write stores win->file's contents end emits pre/post events.\n * If the range r covers the whole file, it is updated to account for\n * potential file's text mutation by a FILE_SAVE_PRE callback.\n */\nstatic bool cmd_write(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *r) {\n\tif (!win)\n\t\treturn false;\n\n\tFile *file = win->file;\n\tif (sam_transcript_error(&file->transcript, SAM_ERR_WRITE_CONFLICT))\n\t\treturn false;\n\n\tText *text = file->text;\n\tFilerange range_all = text_range_new(0, text_size(text));\n\tbool write_entire_file = text_range_equal(r, &range_all);\n\n\tconst char *filename = argv[1];\n\tif (!filename)\n\t\tfilename = file->name;\n\tif (!filename) {\n\t\tif (file->fd == -1) {\n\t\t\tvis_info_show(vis, \"Filename expected\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!strchr(argv[0], 'q')) {\n\t\t\tvis_info_show(vis, \"No filename given, use 'wq' to write to stdout\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!vis_event_emit(vis, VIS_EVENT_FILE_SAVE_PRE, file, (char*)NULL) && cmd->flags != '!') {\n\t\t\tvis_info_show(vis, \"Rejected write to stdout by pre-save hook\");\n\t\t\treturn false;\n\t\t}\n\t\t/* a pre-save hook may have changed the text; need to re-take the range */\n\t\tif (write_entire_file)\n\t\t\t*r = text_range_new(0, text_size(text));\n\n\t\tbool visual = vis->mode->visual;\n\n\t\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\t\tFilerange range = visual ? view_selections_get(s) : *r;\n\t\t\tssize_t written = text_write_range(text, &range, file->fd);\n\t\t\tif (written == -1 || (size_t)written != text_range_size(&range)) {\n\t\t\t\tvis_info_show(vis, \"Can not write to stdout\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!visual)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* make sure the file is marked as saved i.e. not modified */\n\t\ttext_save(text, NULL);\n\t\tvis_event_emit(vis, VIS_EVENT_FILE_SAVE_POST, file, (char*)NULL);\n\t\treturn true;\n\t}\n\n\tif (!argv[1] && cmd->flags != '!') {\n\t\tif (vis->mode->visual) {\n\t\t\tvis_info_show(vis, \"WARNING: file will be reduced to active selection\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!write_entire_file) {\n\t\t\tvis_info_show(vis, \"WARNING: file will be reduced to provided range\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfor (const char **name = argv[1] ? &argv[1] : (const char*[]){ filename, NULL }; *name; name++) {\n\n\t\tchar *path = absolute_path(*name);\n\t\tif (!path)\n\t\t\treturn false;\n\n\t\tstruct stat meta;\n\t\tbool existing_file = !stat(path, &meta);\n\t\tbool same_file = existing_file && file->name &&\n\t\t                 file->stat.st_dev == meta.st_dev && file->stat.st_ino == meta.st_ino;\n\n\t\tif (cmd->flags != '!') {\n\t\t\tif (same_file && file->stat.st_mtime && file->stat.st_mtime < meta.st_mtime) {\n\t\t\t\tvis_info_show(vis, \"WARNING: file has been changed since reading it\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (existing_file && !same_file) {\n\t\t\t\tvis_info_show(vis, \"WARNING: file exists\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (!vis_event_emit(vis, VIS_EVENT_FILE_SAVE_PRE, file, path) && cmd->flags != '!') {\n\t\t\tvis_info_show(vis, \"Rejected write to `%s' by pre-save hook\", path);\n\t\t\tgoto err;\n\t\t}\n\t\t/* a pre-save hook may have changed the text; need to re-take the range */\n\t\tif (write_entire_file)\n\t\t\t*r = text_range_new(0, text_size(text));\n\n\t\tTextSave *ctx = text_save_begin(text, AT_FDCWD, path, file->save_method);\n\t\tif (!ctx) {\n\t\t\tconst char *msg = errno ? strerror(errno) : \"try changing `:set savemethod`\";\n\t\t\tvis_info_show(vis, \"Can't write `%s': %s\", path, msg);\n\t\t\tgoto err;\n\t\t}\n\n\t\tbool failure = false;\n\t\tbool visual = vis->mode->visual;\n\n\t\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\t\tFilerange range = visual ? view_selections_get(s) : *r;\n\t\t\tssize_t written = text_save_write_range(ctx, &range);\n\t\t\tfailure = (written == -1 || (size_t)written != text_range_size(&range));\n\t\t\tif (failure) {\n\t\t\t\ttext_save_cancel(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!visual)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (failure || !text_save_commit(ctx)) {\n\t\t\tvis_info_show(vis, \"Can't write `%s': %s\", path, strerror(errno));\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (!file->name) {\n\t\t\tfile_name_set(file, path);\n\t\t\tsame_file = true;\n\t\t}\n\t\tif (same_file || (!existing_file && strcmp(file->name, path) == 0))\n\t\t\tfile->stat = text_stat(text);\n\t\tvis_event_emit(vis, VIS_EVENT_FILE_SAVE_POST, file, path);\n\t\tfree(path);\n\t\tcontinue;\n\n\terr:\n\t\tfree(path);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool cmd_filter(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\n\tBuffer bufout = {0}, buferr = {0};\n\n\tint status = vis_pipe(vis, win->file, range, &argv[1], &bufout, read_into_buffer, &buferr,\n\t                      read_into_buffer, false);\n\n\tif (vis->interrupted) {\n\t\tvis_info_show(vis, \"Command cancelled\");\n\t} else if (status == 0) {\n\t\tchar *data  = bufout.data;\n\t\tbufout.data = 0;\n\t\tif (!sam_change(win, sel, range, data, bufout.len, 1))\n\t\t\tfree(data);\n\t} else {\n\t\tvis_info_show(vis, \"Command failed %s\", buffer_content0(&buferr));\n\t}\n\n\tbuffer_release(&bufout);\n\tbuffer_release(&buferr);\n\n\treturn !vis->interrupted && status == 0;\n}\n\nstatic bool cmd_launch(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tFilerange invalid = text_range_new(sel ? view_cursors_pos(sel) : range->start, EPOS);\n\treturn cmd_filter(vis, win, cmd, argv, sel, &invalid);\n}\n\nstatic bool cmd_pipein(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tFilerange filter_range = text_range_new(range->end, range->end);\n\tbool ret = cmd_filter(vis, win, cmd, argv, sel, &filter_range);\n\tif (ret)\n\t\tret = sam_delete(win, NULL, range);\n\treturn ret;\n}\n\nstatic bool cmd_pipeout(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tBuffer buferr = {0};\n\n\tint status = vis_pipe(vis, win->file, range, (const char*[]){ argv[1], NULL }, NULL, NULL,\n\t                      &buferr, read_into_buffer, false);\n\n\tif (vis->interrupted)\n\t\tvis_info_show(vis, \"Command cancelled\");\n\telse if (status != 0)\n\t\tvis_info_show(vis, \"Command failed %s\", buffer_content0(&buferr));\n\n\tbuffer_release(&buferr);\n\n\treturn !vis->interrupted && status == 0;\n}\n\nstatic bool cmd_cd(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tconst char *dir = argv[1];\n\tif (!dir)\n\t\tdir = getenv(\"HOME\");\n\treturn dir && chdir(dir) == 0;\n}\n\n#include \"vis-cmds.c\"\n"
        },
        {
          "name": "sam.h",
          "type": "blob",
          "size": 0.494140625,
          "content": "#ifndef SAM_H\n#define SAM_H\n\n#include \"vis.h\"\n\nenum SamError {\n\tSAM_ERR_OK,\n\tSAM_ERR_MEMORY,\n\tSAM_ERR_ADDRESS,\n\tSAM_ERR_NO_ADDRESS,\n\tSAM_ERR_UNMATCHED_BRACE,\n\tSAM_ERR_REGEX,\n\tSAM_ERR_TEXT,\n\tSAM_ERR_SHELL,\n\tSAM_ERR_COMMAND,\n\tSAM_ERR_EXECUTE,\n\tSAM_ERR_NEWLINE,\n\tSAM_ERR_MARK,\n\tSAM_ERR_CONFLICT,\n\tSAM_ERR_WRITE_CONFLICT,\n\tSAM_ERR_LOOP_INVALID_CMD,\n\tSAM_ERR_GROUP_INVALID_CMD,\n\tSAM_ERR_COUNT,\n};\n\nbool sam_init(Vis*);\nenum SamError sam_cmd(Vis*, const char *cmd);\nconst char *sam_error(enum SamError);\n\n#endif\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        },
        {
          "name": "text-common.c",
          "type": "blob",
          "size": 1.6240234375,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include \"text.h\"\n\nstatic bool text_vprintf(Text *txt, size_t pos, const char *format, va_list ap) {\n\tva_list ap_save;\n\tva_copy(ap_save, ap);\n\tint len = vsnprintf(NULL, 0, format, ap);\n\tif (len == -1) {\n\t\tva_end(ap_save);\n\t\treturn false;\n\t}\n\tchar *buf = malloc(len+1);\n\tbool ret = buf && (vsnprintf(buf, len+1, format, ap_save) == len) && text_insert(txt, pos, buf, len);\n\tfree(buf);\n\tva_end(ap_save);\n\treturn ret;\n}\n\nbool text_appendf(Text *txt, const char *format, ...) {\n\tva_list ap;\n\tva_start(ap, format);\n\tbool ret = text_vprintf(txt, text_size(txt), format, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nbool text_printf(Text *txt, size_t pos, const char *format, ...) {\n\tva_list ap;\n\tva_start(ap, format);\n\tbool ret = text_vprintf(txt, pos, format, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nbool text_byte_get(const Text *txt, size_t pos, char *byte) {\n\treturn text_bytes_get(txt, pos, 1, byte);\n}\n\nsize_t text_bytes_get(const Text *txt, size_t pos, size_t len, char *buf) {\n\tif (!buf)\n\t\treturn 0;\n\tchar *cur = buf;\n\tsize_t rem = len;\n\tfor (Iterator it = text_iterator_get(txt, pos);\n\t     text_iterator_valid(&it);\n\t     text_iterator_next(&it)) {\n\t\tif (rem == 0)\n\t\t\tbreak;\n\t\tsize_t piece_len = it.end - it.text;\n\t\tif (piece_len > rem)\n\t\t\tpiece_len = rem;\n\t\tif (piece_len) {\n\t\t\tmemcpy(cur, it.text, piece_len);\n\t\t\tcur += piece_len;\n\t\t\trem -= piece_len;\n\t\t}\n\t}\n\treturn len - rem;\n}\n\nchar *text_bytes_alloc0(const Text *txt, size_t pos, size_t len) {\n\tif (len == SIZE_MAX)\n\t\treturn NULL;\n\tchar *buf = malloc(len+1);\n\tif (!buf)\n\t\treturn NULL;\n\tlen = text_bytes_get(txt, pos, len, buf);\n\tbuf[len] = '\\0';\n\treturn buf;\n}\n"
        },
        {
          "name": "text-internal.h",
          "type": "blob",
          "size": 1.2548828125,
          "content": "#ifndef TEXT_INTERNAL\n#define TEXT_INTERNAL\n\n#include <stdbool.h>\n#include <stddef.h>\n#include \"text.h\"\n\n/* Block holding the file content, either readonly mmap(2)-ed from the original\n * file or heap allocated to store the modifications.\n */\ntypedef struct {\n\tsize_t size;               /* maximal capacity */\n\tsize_t len;                /* current used length / insertion position */\n\tchar *data;                /* actual data */\n\tenum {                     /* type of allocation */\n\t\tBLOCK_TYPE_MMAP_ORIG, /* mmap(2)-ed from an external file */\n\t\tBLOCK_TYPE_MMAP,      /* mmap(2)-ed from a temporary file only known to this process */\n\t\tBLOCK_TYPE_MALLOC,    /* heap allocated block using malloc(3) */\n\t} type;\n} Block;\n\nBlock *block_alloc(size_t size);\nBlock *block_read(size_t size, int fd);\nBlock *block_mmap(size_t size, int fd, off_t offset);\nBlock *block_load(int dirfd, const char *filename, enum TextLoadMethod method, struct stat *info);\nvoid block_free(Block*);\nbool block_capacity(Block*, size_t len);\nconst char *block_append(Block*, const char *data, size_t len);\nbool block_insert(Block*, size_t pos, const char *data, size_t len);\nbool block_delete(Block*, size_t pos, size_t len);\n\nBlock *text_block_mmaped(Text*);\nvoid text_saved(Text*, struct stat *meta);\n\n#endif\n"
        },
        {
          "name": "text-io.c",
          "type": "blob",
          "size": 14.08203125,
          "content": "#include <fcntl.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <libgen.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/mman.h>\n#if CONFIG_ACL\n#include <sys/acl.h>\n#endif\n#if CONFIG_SELINUX\n#include <selinux/selinux.h>\n#endif\n\n#include \"text.h\"\n#include \"text-internal.h\"\n#include \"text-util.h\"\n#include \"util.h\"\n\nstruct TextSave {                  /* used to hold context between text_save_{begin,commit} calls */\n\tText *txt;                 /* text to operate on */\n\tchar *filename;            /* filename to save to as given to text_save_begin */\n\tchar *tmpname;             /* temporary name used for atomic rename(2) */\n\tint fd;                    /* file descriptor to write data to using text_save_write */\n\tint dirfd;                 /* directory file descriptor, relative to which we save */\n\tenum TextSaveMethod type;  /* method used to save file */\n};\n\n/* Allocate blocks holding the actual file content in chunks of size: */\n#ifndef BLOCK_SIZE\n#define BLOCK_SIZE (1 << 20)\n#endif\n/* Files smaller than this value are copied on load, larger ones are mmap(2)-ed\n * directly. Hence the former can be truncated, while doing so on the latter\n * results in havoc. */\n#define BLOCK_MMAP_SIZE (1 << 26)\n\n/* allocate a new block of MAX(size, BLOCK_SIZE) bytes */\nBlock *block_alloc(size_t size) {\n\tBlock *blk = calloc(1, sizeof *blk);\n\tif (!blk)\n\t\treturn NULL;\n\tif (BLOCK_SIZE > size)\n\t\tsize = BLOCK_SIZE;\n\tif (!(blk->data = malloc(size))) {\n\t\tfree(blk);\n\t\treturn NULL;\n\t}\n\tblk->type = BLOCK_TYPE_MALLOC;\n\tblk->size = size;\n\treturn blk;\n}\n\nBlock *block_read(size_t size, int fd) {\n\tBlock *blk = block_alloc(size);\n\tif (!blk)\n\t\treturn NULL;\n\tchar *data = blk->data;\n\tsize_t rem = size;\n\twhile (rem > 0) {\n\t\tssize_t len = read(fd, data, rem);\n\t\tif (len == -1) {\n\t\t\tblock_free(blk);\n\t\t\treturn NULL;\n\t\t} else if (len == 0) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\tdata += len;\n\t\t\trem -= len;\n\t\t}\n\t}\n\tblk->len = size - rem;\n\treturn blk;\n}\n\nBlock *block_mmap(size_t size, int fd, off_t offset) {\n\tBlock *blk = calloc(1, sizeof *blk);\n\tif (!blk)\n\t\treturn NULL;\n\tif (size) {\n\t\tblk->data = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, offset);\n\t\tif (blk->data == MAP_FAILED) {\n\t\t\tfree(blk);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tblk->type = BLOCK_TYPE_MMAP_ORIG;\n\tblk->size = size;\n\tblk->len = size;\n\treturn blk;\n}\n\nBlock *block_load(int dirfd, const char *filename, enum TextLoadMethod method, struct stat *info) {\n\tBlock *block = NULL;\n\tint fd = openat(dirfd, filename, O_RDONLY);\n\tif (fd == -1)\n\t\tgoto out;\n\tif (fstat(fd, info) == -1)\n\t\tgoto out;\n\tif (!S_ISREG(info->st_mode)) {\n\t\terrno = S_ISDIR(info->st_mode) ? EISDIR : ENOTSUP;\n\t\tgoto out;\n\t}\n\n\t// XXX: use lseek(fd, 0, SEEK_END); instead?\n\tsize_t size = info->st_size;\n\tif (size == 0)\n\t\tgoto out;\n\tif (method == TEXT_LOAD_READ || (method == TEXT_LOAD_AUTO && size < BLOCK_MMAP_SIZE))\n\t\tblock = block_read(size, fd);\n\telse\n\t\tblock = block_mmap(size, fd, 0);\nout:\n\tif (fd != -1)\n\t\tclose(fd);\n\treturn block;\n}\n\nvoid block_free(Block *blk) {\n\tif (!blk)\n\t\treturn;\n\tif (blk->type == BLOCK_TYPE_MALLOC)\n\t\tfree(blk->data);\n\telse if ((blk->type == BLOCK_TYPE_MMAP_ORIG || blk->type == BLOCK_TYPE_MMAP) && blk->data)\n\t\tmunmap(blk->data, blk->size);\n\tfree(blk);\n}\n\n/* check whether block has enough free space to store len bytes */\nbool block_capacity(Block *blk, size_t len) {\n\treturn blk->size - blk->len >= len;\n}\n\n/* append data to block, assumes there is enough space available */\nconst char *block_append(Block *blk, const char *data, size_t len) {\n\tchar *dest = memcpy(blk->data + blk->len, data, len);\n\tblk->len += len;\n\treturn dest;\n}\n\n/* insert data into block at an arbitrary position, this should only be used with\n * data of the most recently created piece. */\nbool block_insert(Block *blk, size_t pos, const char *data, size_t len) {\n\tif (pos > blk->len || !block_capacity(blk, len))\n\t\treturn false;\n\tif (blk->len == pos)\n\t\treturn block_append(blk, data, len);\n\tchar *insert = blk->data + pos;\n\tmemmove(insert + len, insert, blk->len - pos);\n\tmemcpy(insert, data, len);\n\tblk->len += len;\n\treturn true;\n}\n\n/* delete data from a block at an arbitrary position, this should only be used with\n * data of the most recently created piece. */\nbool block_delete(Block *blk, size_t pos, size_t len) {\n\tsize_t end;\n\tif (!addu(pos, len, &end) || end > blk->len)\n\t\treturn false;\n\tif (blk->len == pos) {\n\t\tblk->len -= len;\n\t\treturn true;\n\t}\n\tchar *delete = blk->data + pos;\n\tmemmove(delete, delete + len, blk->len - pos - len);\n\tblk->len -= len;\n\treturn true;\n}\n\nText *text_load(const char *filename) {\n\treturn text_load_method(filename, TEXT_LOAD_AUTO);\n}\n\nText *text_loadat(int dirfd, const char *filename) {\n\treturn text_loadat_method(dirfd, filename, TEXT_LOAD_AUTO);\n}\n\nText *text_load_method(const char *filename, enum TextLoadMethod method) {\n\treturn text_loadat_method(AT_FDCWD, filename, method);\n}\n\nssize_t write_all(int fd, const char *buf, size_t count) {\n\tsize_t rem = count;\n\twhile (rem > 0) {\n\t\tssize_t written = write(fd, buf, rem > INT_MAX ? INT_MAX : rem);\n\t\tif (written < 0) {\n\t\t\tif (errno == EAGAIN || errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\t} else if (written == 0) {\n\t\t\tbreak;\n\t\t}\n\t\trem -= written;\n\t\tbuf += written;\n\t}\n\treturn count - rem;\n}\n\nstatic bool preserve_acl(int src, int dest) {\n#if CONFIG_ACL\n\tacl_t acl = acl_get_fd(src);\n\tif (!acl)\n\t\treturn errno == ENOTSUP ? true : false;\n\tif (acl_set_fd(dest, acl) == -1) {\n\t\tacl_free(acl);\n\t\treturn false;\n\t}\n\tacl_free(acl);\n#endif /* CONFIG_ACL */\n\treturn true;\n}\n\nstatic bool preserve_selinux_context(int src, int dest) {\n#if CONFIG_SELINUX\n\tchar *context = NULL;\n\tif (!is_selinux_enabled())\n\t\treturn true;\n\tif (fgetfilecon(src, &context) == -1)\n\t\treturn errno == ENOTSUP ? true : false;\n\tif (fsetfilecon(dest, context) == -1) {\n\t\tfreecon(context);\n\t\treturn false;\n\t}\n\tfreecon(context);\n#endif /* CONFIG_SELINUX */\n\treturn true;\n}\n\nstatic int mkstempat(int dirfd, char *template) {\n\tif (dirfd == AT_FDCWD)\n\t\treturn mkstemp(template);\n\t// FIXME: not thread safe\n\tint fd = -1;\n\tint cwd = open(\".\", O_RDONLY|O_DIRECTORY);\n\tif (cwd == -1)\n\t\tgoto err;\n\tif (fchdir(dirfd) == -1)\n\t\tgoto err;\n\tfd = mkstemp(template);\nerr:\n\tif (cwd != -1) {\n\t\tint ret = fchdir(cwd);\n\t\tclose(cwd);\n\t\tif (ret != 0)\n\t\t  return -1;\n\t}\n\treturn fd;\n}\n\n/* Create a new file named `.filename.vis.XXXXXX` (where `XXXXXX` is a\n * randomly generated, unique suffix) and try to preserve all important\n * meta data. After the file content has been written to this temporary\n * file, text_save_commit_atomic will atomically move it to  its final\n * (possibly already existing) destination using rename(2).\n *\n * This approach does not work if:\n *\n *   - the file is a symbolic link\n *   - the file is a hard link\n *   - file ownership can not be preserved\n *   - file group can not be preserved\n *   - directory permissions do not allow creation of a new file\n *   - POSIX ACL can not be preserved (if enabled)\n *   - SELinux security context can not be preserved (if enabled)\n */\nstatic bool text_save_begin_atomic(TextSave *ctx) {\n\tint oldfd, saved_errno;\n\tif ((oldfd = openat(ctx->dirfd, ctx->filename, O_RDONLY)) == -1 && errno != ENOENT)\n\t\tgoto err;\n\tstruct stat oldmeta = { 0 };\n\tif (oldfd != -1 && fstatat(ctx->dirfd, ctx->filename, &oldmeta, AT_SYMLINK_NOFOLLOW) == -1)\n\t\tgoto err;\n\tif (oldfd != -1) {\n\t\tif (S_ISLNK(oldmeta.st_mode)) /* symbolic link */\n\t\t\tgoto err;\n\t\tif (oldmeta.st_nlink > 1) /* hard link */\n\t\t\tgoto err;\n\t}\n\n\tchar suffix[] = \".vis.XXXXXX\";\n\tsize_t len = strlen(ctx->filename) + sizeof(\"./.\") + sizeof(suffix);\n\tchar *dir = strdup(ctx->filename);\n\tchar *base = strdup(ctx->filename);\n\n\tif (!(ctx->tmpname = malloc(len)) || !dir || !base) {\n\t\tfree(dir);\n\t\tfree(base);\n\t\tgoto err;\n\t}\n\n\tsnprintf(ctx->tmpname, len, \"%s/.%s%s\", dirname(dir), basename(base), suffix);\n\tfree(dir);\n\tfree(base);\n\n\tif ((ctx->fd = mkstempat(ctx->dirfd, ctx->tmpname)) == -1)\n\t\tgoto err;\n\n\tif (oldfd == -1) {\n\t\tmode_t mask = umask(0);\n\t\tumask(mask);\n\t\tif (fchmod(ctx->fd, 0666 & ~mask) == -1)\n\t\t\tgoto err;\n\t} else {\n\t\tif (fchmod(ctx->fd, oldmeta.st_mode) == -1)\n\t\t\tgoto err;\n\t\tif (!preserve_acl(oldfd, ctx->fd) || !preserve_selinux_context(oldfd, ctx->fd))\n\t\t\tgoto err;\n\t\t/* change owner if necessary */\n\t\tif (oldmeta.st_uid != getuid() && fchown(ctx->fd, oldmeta.st_uid, (uid_t)-1) == -1)\n\t\t\tgoto err;\n\t\t/* change group if necessary, in case of failure some editors reset\n\t\t * the group permissions to the same as for others */\n\t\tif (oldmeta.st_gid != getgid() && fchown(ctx->fd, (uid_t)-1, oldmeta.st_gid) == -1)\n\t\t\tgoto err;\n\t\tclose(oldfd);\n\t}\n\n\tctx->type = TEXT_SAVE_ATOMIC;\n\treturn true;\nerr:\n\tsaved_errno = errno;\n\tif (oldfd != -1)\n\t\tclose(oldfd);\n\tif (ctx->fd != -1)\n\t\tclose(ctx->fd);\n\tctx->fd = -1;\n\tfree(ctx->tmpname);\n\tctx->tmpname = NULL;\n\terrno = saved_errno;\n\treturn false;\n}\n\nstatic bool text_save_commit_atomic(TextSave *ctx) {\n\tif (fsync(ctx->fd) == -1)\n\t\treturn false;\n\n\tstruct stat meta = { 0 };\n\tif (fstat(ctx->fd, &meta) == -1)\n\t\treturn false;\n\n\tbool close_failed = (close(ctx->fd) == -1);\n\tctx->fd = -1;\n\tif (close_failed)\n\t\treturn false;\n\n\tif (renameat(ctx->dirfd, ctx->tmpname, ctx->dirfd, ctx->filename) == -1)\n\t\treturn false;\n\n\tfree(ctx->tmpname);\n\tctx->tmpname = NULL;\n\n\tint dir = openat(ctx->dirfd, dirname(ctx->filename), O_DIRECTORY|O_RDONLY);\n\tif (dir == -1)\n\t\treturn false;\n\n\tif (fsync(dir) == -1 && errno != EINVAL) {\n\t\tclose(dir);\n\t\treturn false;\n\t}\n\n\tif (close(dir) == -1)\n\t\treturn false;\n\n\ttext_saved(ctx->txt, &meta);\n\treturn true;\n}\n\nstatic bool text_save_begin_inplace(TextSave *ctx) {\n\tText *txt = ctx->txt;\n\tstruct stat now = { 0 };\n\tint newfd = -1, saved_errno;\n\tif ((ctx->fd = openat(ctx->dirfd, ctx->filename, O_CREAT|O_WRONLY, 0666)) == -1)\n\t\tgoto err;\n\tif (fstat(ctx->fd, &now) == -1)\n\t\tgoto err;\n\tstruct stat loaded = text_stat(txt);\n\tBlock *block = text_block_mmaped(txt);\n\tif (block && now.st_dev == loaded.st_dev && now.st_ino == loaded.st_ino) {\n\t\t/* The file we are going to overwrite is currently mmap-ed from\n\t\t * text_load, therefore we copy the mmap-ed block to a temporary\n\t\t * file and remap it at the same position such that all pointers\n\t\t * from the various pieces are still valid.\n\t\t */\n\t\tsize_t size = block->size;\n\t\tchar tmpname[32] = \"/tmp/vis-XXXXXX\";\n\t\tnewfd = mkstemp(tmpname);\n\t\tif (newfd == -1)\n\t\t\tgoto err;\n\t\tif (unlink(tmpname) == -1)\n\t\t\tgoto err;\n\t\tssize_t written = write_all(newfd, block->data, size);\n\t\tif (written == -1 || (size_t)written != size)\n\t\t\tgoto err;\n\t\tvoid *data = mmap(block->data, size, PROT_READ, MAP_SHARED|MAP_FIXED, newfd, 0);\n\t\tif (data == MAP_FAILED)\n\t\t\tgoto err;\n\t\tbool close_failed = (close(newfd) == -1);\n\t\tnewfd = -1;\n\t\tif (close_failed)\n\t\t\tgoto err;\n\t\tblock->type = BLOCK_TYPE_MMAP;\n\t}\n\t/* overwrite the existing file content, if something goes wrong\n\t * here we are screwed, TODO: make a backup before? */\n\tif (ftruncate(ctx->fd, 0) == -1)\n\t\tgoto err;\n\tctx->type = TEXT_SAVE_INPLACE;\n\treturn true;\nerr:\n\tsaved_errno = errno;\n\tif (newfd != -1)\n\t\tclose(newfd);\n\tif (ctx->fd != -1)\n\t\tclose(ctx->fd);\n\tctx->fd = -1;\n\terrno = saved_errno;\n\treturn false;\n}\n\nstatic bool text_save_commit_inplace(TextSave *ctx) {\n\tif (fsync(ctx->fd) == -1)\n\t\treturn false;\n\tstruct stat meta = { 0 };\n\tif (fstat(ctx->fd, &meta) == -1)\n\t\treturn false;\n\tif (close(ctx->fd) == -1)\n\t\treturn false;\n\ttext_saved(ctx->txt, &meta);\n\treturn true;\n}\n\nTextSave *text_save_begin(Text *txt, int dirfd, const char *filename, enum TextSaveMethod type) {\n\tif (!filename)\n\t\treturn NULL;\n\tTextSave *ctx = calloc(1, sizeof *ctx);\n\tif (!ctx)\n\t\treturn NULL;\n\tctx->txt = txt;\n\tctx->fd = -1;\n\tctx->dirfd = dirfd;\n\tif (!(ctx->filename = strdup(filename)))\n\t\tgoto err;\n\terrno = 0;\n\tif ((type == TEXT_SAVE_AUTO || type == TEXT_SAVE_ATOMIC) && text_save_begin_atomic(ctx))\n\t\treturn ctx;\n\tif (errno == ENOSPC)\n\t\tgoto err;\n\tif ((type == TEXT_SAVE_AUTO || type == TEXT_SAVE_INPLACE) && text_save_begin_inplace(ctx))\n\t\treturn ctx;\nerr:\n\ttext_save_cancel(ctx);\n\treturn NULL;\n}\n\nbool text_save_commit(TextSave *ctx) {\n\tif (!ctx)\n\t\treturn true;\n\tbool ret;\n\tswitch (ctx->type) {\n\tcase TEXT_SAVE_ATOMIC:\n\t\tret = text_save_commit_atomic(ctx);\n\t\tbreak;\n\tcase TEXT_SAVE_INPLACE:\n\t\tret = text_save_commit_inplace(ctx);\n\t\tbreak;\n\tdefault:\n\t\tret = false;\n\t\tbreak;\n\t}\n\n\ttext_save_cancel(ctx);\n\treturn ret;\n}\n\nvoid text_save_cancel(TextSave *ctx) {\n\tif (!ctx)\n\t\treturn;\n\tint saved_errno = errno;\n\tif (ctx->fd != -1)\n\t\tclose(ctx->fd);\n\tif (ctx->tmpname && ctx->tmpname[0])\n\t\tunlinkat(ctx->dirfd, ctx->tmpname, 0);\n\tfree(ctx->tmpname);\n\tfree(ctx->filename);\n\tfree(ctx);\n\terrno = saved_errno;\n}\n\n/* First try to save the file atomically using rename(2) if this does not\n * work overwrite the file in place. However if something goes wrong during\n * this overwrite the original file is permanently damaged.\n */\nbool text_save(Text *txt, const char *filename) {\n\treturn text_saveat(txt, AT_FDCWD, filename);\n}\n\nbool text_saveat(Text *txt, int dirfd, const char *filename) {\n\treturn text_saveat_method(txt, dirfd, filename, TEXT_SAVE_AUTO);\n}\n\nbool text_save_method(Text *txt, const char *filename, enum TextSaveMethod method) {\n\treturn text_saveat_method(txt, AT_FDCWD, filename, method);\n}\n\nbool text_saveat_method(Text *txt, int dirfd, const char *filename, enum TextSaveMethod method) {\n\tif (!filename) {\n\t\ttext_saved(txt, NULL);\n\t\treturn true;\n\t}\n\tTextSave *ctx = text_save_begin(txt, dirfd, filename, method);\n\tif (!ctx)\n\t\treturn false;\n\tFilerange range = (Filerange){ .start = 0, .end = text_size(txt) };\n\tssize_t written = text_save_write_range(ctx, &range);\n\tif (written == -1 || (size_t)written != text_range_size(&range)) {\n\t\ttext_save_cancel(ctx);\n\t\treturn false;\n\t}\n\treturn text_save_commit(ctx);\n}\n\nssize_t text_save_write_range(TextSave *ctx, const Filerange *range) {\n\treturn text_write_range(ctx->txt, range, ctx->fd);\n}\n\nssize_t text_write(const Text *txt, int fd) {\n\tFilerange r = (Filerange){ .start = 0, .end = text_size(txt) };\n\treturn text_write_range(txt, &r, fd);\n}\n\nssize_t text_write_range(const Text *txt, const Filerange *range, int fd) {\n\tsize_t size = text_range_size(range), rem = size;\n\tfor (Iterator it = text_iterator_get(txt, range->start);\n\t     rem > 0 && text_iterator_valid(&it);\n\t     text_iterator_next(&it)) {\n\t\tsize_t prem = it.end - it.text;\n\t\tif (prem > rem)\n\t\t\tprem = rem;\n\t\tssize_t written = write_all(fd, it.text, prem);\n\t\tif (written == -1)\n\t\t\treturn -1;\n\t\trem -= written;\n\t\tif ((size_t)written != prem)\n\t\t\tbreak;\n\t}\n\treturn size - rem;\n}\n"
        },
        {
          "name": "text-iterator.c",
          "type": "blob",
          "size": 3.6123046875,
          "content": "#ifndef _GNU_SOURCE\n#define _GNU_SOURCE /* memrchr(3) is non-standard */\n#endif\n#include <limits.h>\n#include <stddef.h>\n#include <errno.h>\n#include <wchar.h>\n#include <string.h>\n#include \"text.h\"\n#include \"util.h\"\n\nbool text_iterator_byte_get(const Iterator *it, char *b) {\n\tif (text_iterator_valid(it)) {\n\t\tconst Text *txt = text_iterator_text(it);\n\t\tif (it->start <= it->text && it->text < it->end) {\n\t\t\t*b = *it->text;\n\t\t\treturn true;\n\t\t} else if (it->pos == text_size(txt)) {\n\t\t\t*b = '\\0';\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool text_iterator_byte_next(Iterator *it, char *b) {\n\tif (!text_iterator_has_next(it))\n\t\treturn false;\n\tbool eof = true;\n\tif (it->text != it->end) {\n\t\tit->text++;\n\t\tit->pos++;\n\t\teof = false;\n\t} else if (!text_iterator_has_prev(it)) {\n\t\teof = false;\n\t}\n\n\twhile (it->text == it->end) {\n\t\tif (!text_iterator_next(it)) {\n\t\t\tif (eof)\n\t\t\t\treturn false;\n\t\t\tif (b)\n\t\t\t\t*b = '\\0';\n\t\t\treturn text_iterator_prev(it);\n\t\t}\n\t}\n\n\tif (b)\n\t\t*b = *it->text;\n\treturn true;\n}\n\nbool text_iterator_byte_prev(Iterator *it, char *b) {\n\tif (!text_iterator_has_prev(it))\n\t\treturn false;\n\tbool eof = !text_iterator_has_next(it);\n\twhile (it->text == it->start) {\n\t\tif (!text_iterator_prev(it)) {\n\t\t\tif (!eof)\n\t\t\t\treturn false;\n\t\t\tif (b)\n\t\t\t\t*b = '\\0';\n\t\t\treturn text_iterator_next(it);\n\t\t}\n\t}\n\n\t--it->text;\n\t--it->pos;\n\n\tif (b)\n\t\t*b = *it->text;\n\treturn true;\n}\n\nbool text_iterator_byte_find_prev(Iterator *it, char b) {\n\twhile (it->text) {\n\t\tconst char *match = memrchr(it->start, b, it->text - it->start);\n\t\tif (match) {\n\t\t\tit->pos -= it->text - match;\n\t\t\tit->text = match;\n\t\t\treturn true;\n\t\t}\n\t\ttext_iterator_prev(it);\n\t}\n\ttext_iterator_next(it);\n\treturn false;\n}\n\nbool text_iterator_byte_find_next(Iterator *it, char b) {\n\twhile (it->text) {\n\t\tconst char *match = memchr(it->text, b, it->end - it->text);\n\t\tif (match) {\n\t\t\tit->pos += match - it->text;\n\t\t\tit->text = match;\n\t\t\treturn true;\n\t\t}\n\t\ttext_iterator_next(it);\n\t}\n\ttext_iterator_prev(it);\n\treturn false;\n}\n\nbool text_iterator_codepoint_next(Iterator *it, char *c) {\n\twhile (text_iterator_byte_next(it, NULL)) {\n\t\tif (ISUTF8(*it->text)) {\n\t\t\tif (c)\n\t\t\t\t*c = *it->text;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool text_iterator_codepoint_prev(Iterator *it, char *c) {\n\twhile (text_iterator_byte_prev(it, NULL)) {\n\t\tif (ISUTF8(*it->text)) {\n\t\t\tif (c)\n\t\t\t\t*c = *it->text;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool text_iterator_char_next(Iterator *it, char *c) {\n\tif (!text_iterator_codepoint_next(it, c))\n\t\treturn false;\n\tmbstate_t ps = { 0 };\n\tconst Text *txt = text_iterator_text(it);\n\tfor (;;) {\n\t\tchar buf[MB_LEN_MAX];\n\t\tsize_t len = text_bytes_get(txt, it->pos, sizeof buf, buf);\n\t\twchar_t wc;\n\t\tsize_t wclen = mbrtowc(&wc, buf, len, &ps);\n\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\treturn true;\n\t\t} else if (wclen == (size_t)-2) {\n\t\t\treturn false;\n\t\t} else if (wclen == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tint width = wcwidth(wc);\n\t\t\tif (width != 0)\n\t\t\t\treturn true;\n\t\t\tif (!text_iterator_codepoint_next(it, c))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool text_iterator_char_prev(Iterator *it, char *c) {\n\tif (!text_iterator_codepoint_prev(it, c))\n\t\treturn false;\n\tconst Text *txt = text_iterator_text(it);\n\tfor (;;) {\n\t\tchar buf[MB_LEN_MAX];\n\t\tsize_t len = text_bytes_get(txt, it->pos, sizeof buf, buf);\n\t\twchar_t wc;\n\t\tmbstate_t ps = { 0 };\n\t\tsize_t wclen = mbrtowc(&wc, buf, len, &ps);\n\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\treturn true;\n\t\t} else if (wclen == (size_t)-2) {\n\t\t\treturn false;\n\t\t} else if (wclen == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tint width = wcwidth(wc);\n\t\t\tif (width != 0)\n\t\t\t\treturn true;\n\t\t\tif (!text_iterator_codepoint_prev(it, c))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n"
        },
        {
          "name": "text-motions.c",
          "type": "blob",
          "size": 17.7119140625,
          "content": "#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <wchar.h>\n#include <errno.h>\n#include <limits.h>\n#include \"text-motions.h\"\n#include \"text-util.h\"\n#include \"util.h\"\n#include \"text-objects.h\"\n\n#define blank(c) ((c) == ' ' || (c) == '\\t')\n#define space(c) (isspace((unsigned char)c))\n#define boundary(c) (isboundary((unsigned char)c))\n\n// TODO: specify this per file type?\nint is_word_boundary(int c) {\n\treturn ISASCII(c) && !(('0' <= c && c <= '9') ||\n\t         ('a' <= c && c <= 'z') ||\n\t         ('A' <= c && c <= 'Z') || c == '_');\n}\n\nsize_t text_begin(Text *txt, size_t pos) {\n\treturn 0;\n}\n\nsize_t text_end(Text *txt, size_t pos) {\n\treturn text_size(txt);\n}\n\nsize_t text_char_next(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\ttext_iterator_char_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_char_prev(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\ttext_iterator_char_prev(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_codepoint_next(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\ttext_iterator_codepoint_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_codepoint_prev(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\ttext_iterator_codepoint_prev(&it, NULL);\n\treturn it.pos;\n}\n\nstatic size_t find_next(Text *txt, size_t pos, const char *s, bool line) {\n\tif (!s)\n\t\treturn pos;\n\tsize_t len = strlen(s), matched = 0;\n\tIterator it = text_iterator_get(txt, pos), sit;\n\tfor (char c; matched < len && text_iterator_byte_get(&it, &c); ) {\n\t\tif (c == s[matched]) {\n\t\t\tif (matched == 0)\n\t\t\t\tsit = it;\n\t\t\tmatched++;\n\t\t} else if (matched > 0) {\n\t\t\tit = sit;\n\t\t\tmatched = 0;\n\t\t}\n\t\ttext_iterator_byte_next(&it, NULL);\n\t\tif (line && c == '\\n')\n\t\t\tbreak;\n\t}\n\treturn matched == len ? it.pos - len : pos;\n}\n\nsize_t text_find_next(Text *txt, size_t pos, const char *s) {\n\treturn find_next(txt, pos, s, false);\n}\n\nsize_t text_line_find_next(Text *txt, size_t pos, const char *s) {\n\treturn find_next(txt, pos, s, true);\n}\n\nstatic size_t find_prev(Text *txt, size_t pos, const char *s, bool line) {\n\tif (!s)\n\t\treturn pos;\n\tsize_t len = strlen(s), matched = len - 1;\n\tIterator it = text_iterator_get(txt, pos), sit;\n\tif (len == 0)\n\t\treturn pos;\n\tfor (char c; text_iterator_byte_prev(&it, &c); ) {\n\t\tif (c == s[matched]) {\n\t\t\tif (matched == 0)\n\t\t\t\treturn it.pos;\n\t\t\tif (matched == len - 1)\n\t\t\t\tsit = it;\n\t\t\tmatched--;\n\t\t} else if (matched < len - 1) {\n\t\t\tit = sit;\n\t\t\tmatched = len - 1;\n\t\t}\n\t\tif (line && c == '\\n')\n\t\t\tbreak;\n\t}\n\treturn pos;\n}\n\nsize_t text_find_prev(Text *txt, size_t pos, const char *s) {\n\treturn find_prev(txt, pos, s, false);\n}\n\nsize_t text_line_find_prev(Text *txt, size_t pos, const char *s) {\n\treturn find_prev(txt, pos, s, true);\n}\n\nsize_t text_line_prev(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\ttext_iterator_byte_find_prev(&it, '\\n');\n\treturn it.pos;\n}\n\nsize_t text_line_begin(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\treturn text_iterator_byte_find_prev(&it, '\\n') ? it.pos+1 : it.pos;\n}\n\nsize_t text_line_start(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, text_line_begin(txt, pos));\n\twhile (text_iterator_byte_get(&it, &c) && blank(c))\n\t\ttext_iterator_byte_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_line_finish(Text *txt, size_t pos) {\n\tchar c;\n\tsize_t end = text_line_end(txt, pos);\n\tIterator it = text_iterator_get(txt, end);\n\tif (!text_iterator_byte_prev(&it, &c) || c == '\\n')\n\t\treturn end;\n\twhile (blank(c) && text_iterator_byte_prev(&it, &c));\n\treturn it.pos + (c == '\\n');\n}\n\nsize_t text_line_end(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\ttext_iterator_byte_find_next(&it, '\\n');\n\treturn it.pos;\n}\n\nsize_t text_line_next(Text *txt, size_t pos) {\n\tIterator it = text_iterator_get(txt, pos);\n\tif (text_iterator_byte_find_next(&it, '\\n'))\n\t\ttext_iterator_byte_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_line_offset(Text *txt, size_t pos, size_t off) {\n\tchar c;\n\tsize_t bol = text_line_begin(txt, pos);\n\tIterator it = text_iterator_get(txt, bol);\n\twhile (off-- > 0 && text_iterator_byte_get(&it, &c) && c != '\\n')\n\t\ttext_iterator_byte_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_line_char_set(Text *txt, size_t pos, int count) {\n\tchar c;\n\tsize_t bol = text_line_begin(txt, pos);\n\tIterator it = text_iterator_get(txt, bol);\n\tif (text_iterator_byte_get(&it, &c) && c != '\\n')\n\t\twhile (count-- > 0 && text_iterator_char_next(&it, &c) && c != '\\n');\n\treturn it.pos;\n}\n\nint text_line_char_get(Text *txt, size_t pos) {\n\tchar c;\n\tint count = 0;\n\tsize_t bol = text_line_begin(txt, pos);\n\tIterator it = text_iterator_get(txt, bol);\n\tif (text_iterator_byte_get(&it, &c) && c != '\\n') {\n\t\twhile (it.pos < pos && c != '\\n' && text_iterator_char_next(&it, &c))\n\t\t\tcount++;\n\t}\n\treturn count;\n}\n\nint text_line_width_get(Text *txt, size_t pos) {\n\tint width = 0;\n\tmbstate_t ps = { 0 };\n\tsize_t bol = text_line_begin(txt, pos);\n\tIterator it = text_iterator_get(txt, bol);\n\n\twhile (it.pos < pos) {\n\t\tchar buf[MB_LEN_MAX];\n\t\tsize_t len = text_bytes_get(txt, it.pos, sizeof buf, buf);\n\t\tif (len == 0 || buf[0] == '\\n')\n\t\t\tbreak;\n\t\twchar_t wc;\n\t\tsize_t wclen = mbrtowc(&wc, buf, len, &ps);\n\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\tps = (mbstate_t){0};\n\t\t\t/* assume a replacement symbol will be displayed */\n\t\t\twidth++;\n\t\t} else if (wclen == (size_t)-2) {\n\t\t\t/* do nothing, advance to next character */\n\t\t} else if (wclen == 0) {\n\t\t\t/* assume NUL byte will be displayed as ^@ */\n\t\t\twidth += 2;\n\t\t} else if (buf[0] == '\\t') {\n\t\t\twidth++;\n\t\t} else {\n\t\t\tint w = wcwidth(wc);\n\t\t\tif (w == -1)\n\t\t\t\tw = 2; /* assume non-printable will be displayed as ^{char} */\n\t\t\twidth += w;\n\t\t}\n\n\t\tif (!text_iterator_codepoint_next(&it, NULL))\n\t\t\tbreak;\n\t}\n\n\treturn width;\n}\n\nsize_t text_line_width_set(Text *txt, size_t pos, int width) {\n\tint cur_width = 0;\n\tmbstate_t ps = { 0 };\n\tsize_t bol = text_line_begin(txt, pos);\n\tIterator it = text_iterator_get(txt, bol);\n\n\tfor (;;) {\n\t\tchar buf[MB_LEN_MAX];\n\t\tsize_t len = text_bytes_get(txt, it.pos, sizeof buf, buf);\n\t\tif (len == 0 || buf[0] == '\\n')\n\t\t\tbreak;\n\t\twchar_t wc;\n\t\tsize_t wclen = mbrtowc(&wc, buf, len, &ps);\n\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\tps = (mbstate_t){0};\n\t\t\t/* assume a replacement symbol will be displayed */\n\t\t\tcur_width++;\n\t\t} else if (wclen == (size_t)-2) {\n\t\t\t/* do nothing, advance to next character */\n\t\t} else if (wclen == 0) {\n\t\t\t/* assume NUL byte will be displayed as ^@ */\n\t\t\tcur_width += 2;\n\t\t} else if (buf[0] == '\\t') {\n\t\t\tcur_width++;\n\t\t} else {\n\t\t\tint w = wcwidth(wc);\n\t\t\tif (w == -1)\n\t\t\t\tw = 2; /* assume non-printable will be displayed as ^{char} */\n\t\t\tcur_width += w;\n\t\t}\n\n\t\tif (cur_width >= width || !text_iterator_codepoint_next(&it, NULL))\n\t\t\tbreak;\n\t}\n\n\treturn it.pos;\n}\n\nsize_t text_line_char_next(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &c) || c == '\\n')\n\t\treturn pos;\n\ttext_iterator_char_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_line_char_prev(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_char_prev(&it, &c) || c == '\\n')\n\t\treturn pos;\n\treturn it.pos;\n}\n\nsize_t text_line_up(Text *txt, size_t pos) {\n\tint width = text_line_width_get(txt, pos);\n\tsize_t prev = text_line_prev(txt, pos);\n\treturn text_line_width_set(txt, prev, width);\n}\n\nsize_t text_line_down(Text *txt, size_t pos) {\n\tint width = text_line_width_get(txt, pos);\n\tsize_t next = text_line_next(txt, pos);\n\tif (next == text_size(txt))\n\t\treturn pos;\n\treturn text_line_width_set(txt, next, width);\n}\n\nsize_t text_range_line_first(Text *txt, Filerange *r) {\n\tif (!text_range_valid(r))\n\t\treturn EPOS;\n\treturn r->start;\n}\n\nsize_t text_range_line_last(Text *txt, Filerange *r) {\n\tif (!text_range_valid(r))\n\t\treturn EPOS;\n\tsize_t pos = text_line_begin(txt, r->end);\n\tif (pos == r->end) {\n\t\t/* range ends at a begin of a line, skip last line ending */\n\t\tpos = text_line_prev(txt, pos);\n\t\tpos = text_line_begin(txt, pos);\n\t}\n\treturn r->start <= pos ? pos : r->start;\n}\n\nsize_t text_range_line_next(Text *txt, Filerange *r, size_t pos) {\n\tif (!text_range_contains(r, pos))\n\t\treturn EPOS;\n\tsize_t newpos = text_line_next(txt, pos);\n\treturn newpos != pos && newpos < r->end ? newpos : EPOS;\n}\n\nsize_t text_range_line_prev(Text *txt, Filerange *r, size_t pos) {\n\tif (!text_range_contains(r, pos))\n\t\treturn EPOS;\n\tsize_t newpos = text_line_begin(txt, text_line_prev(txt, pos));\n\treturn newpos != pos && r->start <= newpos ? newpos : EPOS;\n}\n\nsize_t text_customword_start_next(Text *txt, size_t pos, int (*isboundary)(int)) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn pos;\n\tif (boundary(c))\n\t\twhile (boundary(c) && !space(c) && text_iterator_char_next(&it, &c));\n\telse\n\t\twhile (!boundary(c) && text_iterator_char_next(&it, &c));\n\twhile (space(c) && text_iterator_char_next(&it, &c));\n\treturn it.pos;\n}\n\nsize_t text_customword_start_prev(Text *txt, size_t pos, int (*isboundary)(int)) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_char_prev(&it, &c) && space(c));\n\tif (boundary(c))\n\t\tdo pos = it.pos; while (text_iterator_char_prev(&it, &c) && boundary(c) && !space(c));\n\telse\n\t\tdo pos = it.pos; while (text_iterator_char_prev(&it, &c) && !boundary(c));\n\treturn pos;\n}\n\nsize_t text_customword_end_next(Text *txt, size_t pos, int (*isboundary)(int)) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_char_next(&it, &c) && space(c));\n\tif (boundary(c))\n\t\tdo pos = it.pos; while (text_iterator_char_next(&it, &c) && boundary(c) && !space(c));\n\telse\n\t\tdo pos = it.pos; while (text_iterator_char_next(&it, &c) && !isboundary(c));\n\treturn pos;\n}\n\nsize_t text_customword_end_prev(Text *txt, size_t pos, int (*isboundary)(int)) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn pos;\n\tif (boundary(c))\n\t\twhile (boundary(c) && !space(c) && text_iterator_char_prev(&it, &c));\n\telse\n\t\twhile (!boundary(c) && text_iterator_char_prev(&it, &c));\n\twhile (space(c) && text_iterator_char_prev(&it, &c));\n\treturn it.pos;\n}\n\nsize_t text_longword_end_next(Text *txt, size_t pos) {\n\treturn text_customword_end_next(txt, pos, isspace);\n}\n\nsize_t text_longword_end_prev(Text *txt, size_t pos) {\n\treturn text_customword_end_prev(txt, pos, isspace);\n}\n\nsize_t text_longword_start_next(Text *txt, size_t pos) {\n\treturn text_customword_start_next(txt, pos, isspace);\n}\n\nsize_t text_longword_start_prev(Text *txt, size_t pos) {\n\treturn text_customword_start_prev(txt, pos, isspace);\n}\n\nsize_t text_word_end_next(Text *txt, size_t pos) {\n\treturn text_customword_end_next(txt, pos, is_word_boundary);\n}\n\nsize_t text_word_end_prev(Text *txt, size_t pos) {\n\treturn text_customword_end_prev(txt, pos, is_word_boundary);\n}\n\nsize_t text_word_start_next(Text *txt, size_t pos) {\n\treturn text_customword_start_next(txt, pos, is_word_boundary);\n}\n\nsize_t text_word_start_prev(Text *txt, size_t pos) {\n\treturn text_customword_start_prev(txt, pos, is_word_boundary);\n}\n\nsize_t text_sentence_next(Text *txt, size_t pos) {\n\tchar c, prev = 'X';\n\tIterator it = text_iterator_get(txt, pos), rev = it;\n\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn pos;\n\n\twhile (text_iterator_byte_get(&rev, &prev) && space(prev))\n\t\ttext_iterator_byte_prev(&rev, NULL);\n\tprev = rev.pos == 0 ? '.' : prev; /* simulate punctuation at BOF */\n\n\tdo {\n\t\tif ((prev == '.' || prev == '?' || prev == '!') && space(c)) {\n\t\t\tdo text_iterator_byte_next(&it, NULL);\n\t\t\twhile (text_iterator_byte_get(&it, &c) && space(c));\n\t\t\treturn it.pos;\n\t\t}\n\t\tprev = c;\n\t} while (text_iterator_byte_next(&it, &c));\n\treturn it.pos;\n}\n\nsize_t text_sentence_prev(Text *txt, size_t pos) {\n\tchar c, prev = 'X';\n\tbool content = false;\n\tIterator it = text_iterator_get(txt, pos);\n\n\twhile (it.pos != 0 && text_iterator_byte_prev(&it, &c)) {\n\t\tif (content && space(prev) && (c == '.' || c == '?' || c == '!')) {\n\t\t\tdo text_iterator_byte_next(&it, NULL);\n\t\t\twhile (text_iterator_byte_get(&it, &c) && space(c));\n\t\t\treturn it.pos;\n\t\t}\n\t\tcontent |= !space(c);\n\t\tprev = c;\n\t} /* The loop only ends on hitting BOF or error */\n\tif (content) /* starting pos was after first sentence in file => find that sentences start */\n\t\twhile (text_iterator_byte_get(&it, &c) && space(c))\n\t\t\ttext_iterator_byte_next(&it, NULL);\n\treturn it.pos;\n}\n\nsize_t text_paragraph_next(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\n\twhile (text_iterator_byte_get(&it, &c) && (c == '\\n' || blank(c)))\n\t\ttext_iterator_char_next(&it, NULL);\n\treturn text_line_blank_next(txt, it.pos);\n}\n\nsize_t text_paragraph_prev(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\n\twhile (text_iterator_byte_get(&it, &c) && (c == '\\n' || blank(c)))\n\t\ttext_iterator_char_prev(&it, NULL);\n\treturn text_line_blank_prev(txt, it.pos);\n}\n\nsize_t text_line_empty_next(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_byte_find_next(&it, '\\n')) {\n\t\tif (text_iterator_byte_next(&it, &c) && c == '\\n')\n\t\t\treturn it.pos;\n\t}\n\treturn it.pos;\n}\n\nsize_t text_line_empty_prev(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_byte_find_prev(&it, '\\n')) {\n\t\tif (text_iterator_byte_prev(&it, &c) && c == '\\n')\n\t\t\treturn it.pos + 1;\n\t}\n\treturn it.pos;\n}\n\nsize_t text_line_blank_next(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_byte_find_next(&it, '\\n')) {\n\t\tsize_t n = it.pos;\n\t\twhile (text_iterator_byte_next(&it, &c) && blank(c));\n\t\tif (c == '\\n')\n\t\t\treturn n + 1;\n\t}\n\treturn it.pos;\n}\n\nsize_t text_line_blank_prev(Text *txt, size_t pos) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_byte_find_prev(&it, '\\n')) {\n\t\twhile (text_iterator_byte_prev(&it, &c) && blank(c));\n\t\tif (c == '\\n')\n\t\t\treturn it.pos + 1;\n\t}\n\treturn it.pos;\n}\n\nsize_t text_block_start(Text *txt, size_t pos) {\n\tFilerange r = text_object_curly_bracket(txt, pos-1);\n\treturn text_range_valid(&r) ? r.start-1 : pos;\n}\n\nsize_t text_block_end(Text *txt, size_t pos) {\n\tFilerange r = text_object_curly_bracket(txt, pos+1);\n\treturn text_range_valid(&r) ? r.end : pos;\n}\n\nsize_t text_parenthesis_start(Text *txt, size_t pos) {\n\tFilerange r = text_object_parenthesis(txt, pos-1);\n\treturn text_range_valid(&r) ? r.start-1 : pos;\n}\n\nsize_t text_parenthesis_end(Text *txt, size_t pos) {\n\tFilerange r = text_object_parenthesis(txt, pos+1);\n\treturn text_range_valid(&r) ? r.end : pos;\n}\n\nsize_t text_bracket_match(Text *txt, size_t pos, const Filerange *limits) {\n\treturn text_bracket_match_symbol(txt, pos, NULL, limits);\n}\n\nstatic size_t match_symbol(Text *txt, size_t pos, char search, int direction, const Filerange *limits) {\n\tchar c, current;\n\tint count = 1;\n\tbool instring = false;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &current))\n\t\treturn pos;\n\tif (direction >= 0) { /* forward search */\n\t\twhile (text_iterator_byte_next(&it, &c)) {\n\t\t\tif (limits && it.pos >= limits->end)\n\t\t\t\tbreak;\n\t\t\tif (c != current && c == '\"')\n\t\t\t\tinstring = !instring;\n\t\t\tif (!instring) {\n\t\t\t\tif (c == search && --count == 0)\n\t\t\t\t\treturn it.pos;\n\t\t\t\telse if (c == current)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t} else { /* backwards */\n\t\twhile (text_iterator_byte_prev(&it, &c)) {\n\t\t\tif (limits && it.pos < limits->start)\n\t\t\t\tbreak;\n\t\t\tif (c != current && c == '\"')\n\t\t\t\tinstring = !instring;\n\t\t\tif (!instring) {\n\t\t\t\tif (c == search && --count == 0)\n\t\t\t\t\treturn it.pos;\n\t\t\t\telse if (c == current)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pos; /* no match found */\n}\n\nsize_t text_bracket_match_symbol(Text *txt, size_t pos, const char *symbols, const Filerange *limits) {\n\tint direction;\n\tchar search, current, c;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &current))\n\t\treturn pos;\n\tif (symbols && !memchr(symbols, current, strlen(symbols)))\n\t\treturn pos;\n\tswitch (current) {\n\tcase '(': search = ')'; direction =  1; break;\n\tcase ')': search = '('; direction = -1; break;\n\tcase '{': search = '}'; direction =  1; break;\n\tcase '}': search = '{'; direction = -1; break;\n\tcase '[': search = ']'; direction =  1; break;\n\tcase ']': search = '['; direction = -1; break;\n\tcase '<': search = '>'; direction =  1; break;\n\tcase '>': search = '<'; direction = -1; break;\n\tcase '\"':\n\tcase '`':\n\tcase '\\'':\n\t{\n\t\t/* prefer matches on the same line */\n\t\tsize_t fw = match_symbol(txt, pos, current, +1, limits);\n\t\tsize_t bw = match_symbol(txt, pos, current, -1, limits);\n\t\tif (fw == pos)\n\t\t\treturn bw;\n\t\tif (bw == pos)\n\t\t\treturn fw;\n\t\tsize_t line = text_lineno_by_pos(txt, pos);\n\t\tsize_t line_fw = text_lineno_by_pos(txt, fw);\n\t\tsize_t line_bw = text_lineno_by_pos(txt, bw);\n\t\tif (line != line_fw)\n\t\t\treturn bw;\n\t\tif (line != line_bw)\n\t\t\treturn fw;\n\t\tdirection = +1;\n\t\tif (text_iterator_byte_next(&it, &c)) {\n\t\t\t/* if a single or double quote is followed by\n\t\t\t * a special character, search backwards */\n\t\t\tchar special[] = \" \\t\\n)}]>.,:;\";\n\t\t\tif (memchr(special, c, sizeof(special)))\n\t\t\t\tdirection = -1;\n\t\t}\n\t\treturn direction >= 0 ? fw : bw;\n\t}\n\tdefault:\n\t\treturn pos;\n\t}\n\n\treturn match_symbol(txt, pos, search, direction, limits);\n}\n\nsize_t text_search_forward(Text *txt, size_t pos, Regex *regex) {\n\tsize_t start = pos + 1;\n\tsize_t end = text_size(txt);\n\tRegexMatch match[1];\n\tchar c;\n\tint flags = text_byte_get(txt, pos, &c) && c == '\\n' ? 0 : REG_NOTBOL;\n\tbool found = start < end && !text_search_range_forward(txt, start, end - start, regex, 1, match, flags);\n\n\tif (!found) {\n\t\tstart = 0;\n\t\tfound = !text_search_range_forward(txt, start, end - start, regex, 1, match, 0);\n\t}\n\n\treturn found ? match[0].start : pos;\n}\n\nsize_t text_search_backward(Text *txt, size_t pos, Regex *regex) {\n\tsize_t start = 0;\n\tsize_t end = pos;\n\tRegexMatch match[1];\n\tbool found = !text_search_range_backward(txt, start, end, regex, 1, match, REG_NOTEOL);\n\n\tif (!found) {\n\t\tend = text_size(txt);\n\t\tfound = !text_search_range_backward(txt, start, end - start, regex, 1, match, 0);\n\t}\n\n\treturn found ? match[0].start : pos;\n}\n"
        },
        {
          "name": "text-motions.h",
          "type": "blob",
          "size": 5.83203125,
          "content": "#ifndef TEXT_MOTIONS_H\n#define TEXT_MOTIONS_H\n\n/* these functions all take a position in bytes from the start of the file,\n * perform a certain movement and return the new position. If the movement\n * is not possible the original position is returned unchanged. */\n\n#include <stddef.h>\n#include \"text.h\"\n#include \"text-regex.h\"\n\nsize_t text_begin(Text*, size_t pos);\nsize_t text_end(Text*, size_t pos);\n\n/* char refers to a grapheme (might skip over multiple Unicode codepoints) */\nsize_t text_char_next(Text*, size_t pos);\nsize_t text_char_prev(Text*, size_t pos);\n\nsize_t text_codepoint_next(Text*, size_t pos);\nsize_t text_codepoint_prev(Text*, size_t pos);\n\n/* find the given substring either in forward or backward direction.\n * does not wrap around at file start / end. If no match is found return\n * original position */\nsize_t text_find_next(Text*, size_t pos, const char *s);\nsize_t text_find_prev(Text*, size_t pos, const char *s);\n/* same as above but limit searched range to the line containing pos */\nsize_t text_line_find_next(Text*, size_t pos, const char *s);\nsize_t text_line_find_prev(Text*, size_t pos, const char *s);\n\n/*    begin            finish    next\n *    v                v         v\n *  \\n      I am a line!       \\n\n *  ^       ^                  ^\n *  prev    start              end\n */\nsize_t text_line_prev(Text*, size_t pos);\nsize_t text_line_begin(Text*, size_t pos);\nsize_t text_line_start(Text*, size_t pos);\nsize_t text_line_finish(Text*, size_t pos);\nsize_t text_line_end(Text*, size_t pos);\nsize_t text_line_next(Text*, size_t pos);\nsize_t text_line_offset(Text*, size_t pos, size_t off);\n/* get grapheme count of the line upto `pos' */\nint text_line_char_get(Text*, size_t pos);\n/* get position of the `count' grapheme in the line containing `pos' */\nsize_t text_line_char_set(Text*, size_t pos, int count);\n/* get display width of line upto `pos' */\nint text_line_width_get(Text*, size_t pos);\n/* get position of character being displayed at `width' in line containing `pos' */\nsize_t text_line_width_set(Text*, size_t pos, int width);\n/* move to the next/previous grapheme on the same line */\nsize_t text_line_char_next(Text*, size_t pos);\nsize_t text_line_char_prev(Text*, size_t pos);\n/* move to the next/previous empty line */\nsize_t text_line_empty_next(Text*, size_t pos);\nsize_t text_line_empty_prev(Text*, size_t pos);\n/* move to start of next/previous blank line */\nsize_t text_line_blank_next(Text*, size_t pos);\nsize_t text_line_blank_prev(Text*, size_t pos);\n/* move to same offset in previous/next line */\nsize_t text_line_up(Text*, size_t pos);\nsize_t text_line_down(Text*, size_t pos);\n/* functions to iterate over all line beginnings in a given range */\nsize_t text_range_line_first(Text*, Filerange*);\nsize_t text_range_line_last(Text*, Filerange*);\nsize_t text_range_line_next(Text*, Filerange*, size_t pos);\nsize_t text_range_line_prev(Text*, Filerange*, size_t pos);\n/*\n * A longword consists of a sequence of non-blank characters, separated with\n * white space. TODO?: An empty line is also considered to be a word.\n * This is equivalent to a WORD in vim terminology.\n */\nsize_t text_longword_end_next(Text*, size_t pos);\nsize_t text_longword_end_prev(Text*, size_t pos);\nsize_t text_longword_start_next(Text*, size_t pos);\nsize_t text_longword_start_prev(Text*, size_t pos);\n/*\n * A word consists of a sequence of letters, digits and underscores, or a\n * sequence of other non-blank characters, separated with white space.\n * TODO?: An empty line is also considered to be a word.\n * This is equivalent to a word (lowercase) in vim terminology.\n */\nsize_t text_word_end_next(Text*, size_t pos);\nsize_t text_word_end_prev(Text*, size_t pos);\nsize_t text_word_start_next(Text*, size_t pos);\nsize_t text_word_start_prev(Text*, size_t pos);\n/*\n * More general versions of the above, define your own word boundaries.\n */\nsize_t text_customword_start_next(Text*, size_t pos, int (*isboundary)(int));\nsize_t text_customword_start_prev(Text*, size_t pos, int (*isboundary)(int));\nsize_t text_customword_end_next(Text*, size_t pos, int (*isboundary)(int));\nsize_t text_customword_end_prev(Text*, size_t pos, int (*isboundary)(int));\n/* TODO: implement the following semantics\n * A sentence is defined as ending at a '.', '!' or '?' followed by either the\n * end of a line, or by a space or tab.  Any number of closing ')', ']', '\"'\n * and ''' characters may appear after the '.', '!' or '?' before the spaces,\n * tabs or end of line.  A paragraph and section boundary is also a sentence\n * boundary.\n */\nsize_t text_sentence_next(Text*, size_t pos);\nsize_t text_sentence_prev(Text*, size_t pos);\n/* TODO: implement the following semantics\n * A paragraph begins after each empty line. A section boundary is also a\n * paragraph boundary. Note that a blank line (only containing white space)\n * is NOT a paragraph boundary.\n */\nsize_t text_paragraph_next(Text*, size_t pos);\nsize_t text_paragraph_prev(Text*, size_t pos);\n/* A section begins after a form-feed in the first column.\nsize_t text_section_next(Text*, size_t pos);\nsize_t text_section_prev(Text*, size_t pos);\n*/\nsize_t text_block_start(Text*, size_t pos);\nsize_t text_block_end(Text*, size_t pos);\nsize_t text_parenthesis_start(Text*, size_t pos);\nsize_t text_parenthesis_end(Text*, size_t pos);\n/* search corresponding '(', ')', '{', '}', '[', ']', '>', '<', '\"', ''' */\nsize_t text_bracket_match(Text*, size_t pos, const Filerange *limits);\n/* same as above but explicitly specify symbols to match */\nsize_t text_bracket_match_symbol(Text*, size_t pos, const char *symbols, const Filerange *limits);\n\n/* search the given regex pattern in either forward or backward direction,\n * starting from pos. Does wrap around if no match was found. */\nsize_t text_search_forward(Text *txt, size_t pos, Regex *regex);\nsize_t text_search_backward(Text *txt, size_t pos, Regex *regex);\n\n/* is c a special symbol delimiting a word? */\nint is_word_boundary(int c);\n\n#endif\n"
        },
        {
          "name": "text-objects.c",
          "type": "blob",
          "size": 11.3017578125,
          "content": "#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"text-util.h\"\n#include \"util.h\"\n\n#define blank(c) ((c) == ' ' || (c) == '\\t')\n#define space(c) (isspace((unsigned char)c))\n#define boundary(c) (isboundary((unsigned char)c))\n\nFilerange text_object_entire(Text *txt, size_t pos) {\n\treturn text_range_new(0, text_size(txt));\n}\n\nstatic Filerange text_object_customword(Text *txt, size_t pos, int (*isboundary)(int)) {\n\tFilerange r;\n\tchar c, prev = '0', next = '0';\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn text_range_empty();\n\tif (pos > 0 && text_iterator_byte_prev(&it, &prev))\n\t\ttext_iterator_byte_next(&it, NULL);\n\ttext_iterator_byte_next(&it, &next);\n\tif (space(c)) {\n\t\tr.start = text_char_next(txt, text_customword_end_prev(txt, pos, isboundary));\n\t\tr.end = text_customword_start_next(txt, pos, isboundary);\n\t} else if (boundary(c)) {\n\t\tif (boundary(prev) && !space(prev))\n\t\t\tr.start = text_customword_start_prev(txt, pos, isboundary);\n\t\telse\n\t\t\tr.start = pos;\n\n\t\tif (boundary(next) && !space(next))\n\t\t\tr.end = text_char_next(txt, text_customword_end_next(txt, pos, isboundary));\n\t\telse\n\t\t\tr.end = text_char_next(txt, pos);\n\t} else {\n\t\tif (boundary(prev))\n\t\t\tr.start = pos;\n\t\telse\n\t\t\tr.start = text_customword_start_prev(txt, pos, isboundary);\n\n\t\tif (boundary(next))\n\t\t\tr.end = text_char_next(txt, pos);\n\t\telse\n\t\t\tr.end = text_char_next(txt, text_customword_end_next(txt, pos, isboundary));\n\t}\n\n\treturn r;\n}\n\nFilerange text_object_word(Text *txt, size_t pos) {\n\treturn text_object_customword(txt, pos, is_word_boundary);\n}\n\nFilerange text_object_longword(Text *txt, size_t pos) {\n\treturn text_object_customword(txt, pos, isspace);\n}\n\nstatic Filerange text_object_customword_outer(Text *txt, size_t pos, int (*isboundary)(int)) {\n\tFilerange r;\n\tchar c, prev = '0', next = '0';\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn text_range_empty();\n\tif (pos > 0 && text_iterator_byte_prev(&it, &prev))\n\t\ttext_iterator_byte_next(&it, NULL);\n\ttext_iterator_byte_next(&it, &next);\n\tif (space(c)) {\n\t\t/* middle of two words, include leading white space */\n\t\tr.start = text_char_next(txt, text_customword_end_prev(txt, pos, isboundary));\n\t\tr.end = text_char_next(txt, text_customword_end_next(txt, pos, isboundary));\n\t} else if (boundary(prev) && boundary(next)) {\n\t\tif (boundary(c)) {\n\t\t\tr.start = text_char_next(txt, text_customword_end_prev(txt, pos, isboundary));\n\t\t\tr.end = text_word_start_next(txt, text_customword_end_next(txt, pos, isboundary));\n\t\t} else {\n\t\t\t/* on a single character */\n\t\t\tr.start = pos;\n\t\t\tr.end = text_customword_start_next(txt, pos, isboundary);\n\t\t}\n\t} else if (boundary(prev)) {\n\t\t/* at start of a word */\n\t\tr.start = pos;\n\t\tr.end = text_customword_start_next(txt, text_customword_end_next(txt, pos, isboundary), isboundary);\n\t} else if (boundary(next)) {\n\t\t/* at end of a word */\n\t\tr.start = text_customword_start_prev(txt, pos, isboundary);\n\t\tr.end = text_customword_start_next(txt, pos, isboundary);\n\t} else {\n\t\t/* in the middle of a word */\n\t\tr.start = text_customword_start_prev(txt, pos, isboundary);\n\t\tr.end = text_customword_start_next(txt, text_customword_end_next(txt, pos, isboundary), isboundary);\n\t}\n\n\treturn r;\n}\n\nFilerange text_object_longword_outer(Text *txt, size_t pos) {\n\treturn text_object_customword_outer(txt, pos, isspace);\n}\n\nFilerange text_object_word_outer(Text *txt, size_t pos) {\n\treturn text_object_customword_outer(txt, pos, is_word_boundary);\n}\n\nFilerange text_object_word_find_next(Text *txt, size_t pos, const char *word) {\n\tsize_t len = strlen(word);\n\tfor (;;) {\n\t\tsize_t match_pos = text_find_next(txt, pos, word);\n\t\tif (match_pos != pos) {\n\t\t\tFilerange match_word = text_object_word(txt, match_pos);\n\t\t\tif (text_range_size(&match_word) == len)\n\t\t\t\treturn match_word;\n\t\t\tpos = match_word.end;\n\t\t} else {\n\t\t\treturn text_range_empty();\n\t\t}\n\t}\n}\n\nFilerange text_object_word_find_prev(Text *txt, size_t pos, const char *word) {\n\tsize_t len = strlen(word);\n\tfor (;;) {\n\t\tsize_t match_pos = text_find_prev(txt, pos, word);\n\t\tif (match_pos != pos) {\n\t\t\tFilerange match_word = text_object_word(txt, match_pos);\n\t\t\tif (text_range_size(&match_word) == len)\n\t\t\t\treturn match_word;\n\t\t\tpos = match_pos;\n\t\t} else {\n\t\t\treturn text_range_empty();\n\t\t}\n\t}\n}\n\nFilerange text_object_find_next(Text *txt, size_t pos, const char *search) {\n\tsize_t start = text_find_next(txt, pos, search);\n\tif (start == pos)\n\t\treturn text_range_empty();\n\treturn text_range_new(start, start+strlen(search));\n}\n\nFilerange text_object_find_prev(Text *txt, size_t pos, const char *search) {\n\tsize_t start = text_find_prev(txt, pos, search);\n\tif (start == pos)\n\t\treturn text_range_empty();\n\treturn text_range_new(start, start+strlen(search));\n}\n\nFilerange text_object_line(Text *txt, size_t pos) {\n\tFilerange r;\n\tr.start = text_line_begin(txt, pos);\n\tr.end = text_line_next(txt, pos);\n\treturn r;\n}\n\nFilerange text_object_line_inner(Text *txt, size_t pos) {\n\tFilerange r = text_object_line(txt, pos);\n\treturn text_range_inner(txt, &r);\n}\n\nFilerange text_object_sentence(Text *txt, size_t pos) {\n\tFilerange r;\n\tr.start = text_sentence_prev(txt, pos);\n\tr.end = text_sentence_next(txt, pos);\n\treturn r;\n}\n\nstatic bool text_line_blank(Text *txt, size_t pos) {\n\tchar c;\n\tbool b = true;\n\tIterator it = text_iterator_get(txt, text_line_begin(txt, pos));\n\twhile (text_iterator_byte_get(&it, &c) && c != '\\n' && (b = blank(c)))\n\t\ttext_iterator_char_next(&it, NULL);\n\treturn b;\n}\n\nFilerange text_object_paragraph(Text *txt, size_t pos) {\n\tchar c;\n\tFilerange r;\n\tif (text_line_blank(txt, pos)) {\n\t\tIterator it = text_iterator_get(txt, pos), rit = it;\n\t\twhile (text_iterator_byte_get(&rit, &c) && (c == '\\n' || blank(c)))\n\t\t\ttext_iterator_byte_prev(&rit, NULL);\n\t\tif (c == '\\n' || blank(c))\n\t\t\tr.start = rit.pos;\n\t\telse\n\t\t\tr.start = text_line_next(txt, rit.pos);\n\t\twhile (text_iterator_byte_get(&it, &c) && (c == '\\n' || blank(c)))\n\t\t\ttext_iterator_byte_next(&it, NULL);\n\t\tif (it.pos == text_size(txt))\n\t\t\tr.end = rit.pos;\n\t\telse\n\t\t\tr.end = text_line_begin(txt, it.pos);\n\t} else {\n\t\tr.start = text_line_blank_prev(txt, pos);\n\t\tif (r.start > 0 || (text_byte_get(txt, r.start, &c) && c == '\\n'))\n\t\t\tr.start = text_line_next(txt, r.start);\n\t\tr.end = text_line_blank_next(txt, pos);\n\t}\n\treturn r;\n}\n\nFilerange text_object_paragraph_outer(Text *txt, size_t pos) {\n\tFilerange p1 = text_object_paragraph(txt, pos);\n\tFilerange p2 = text_object_paragraph(txt, p1.end);\n\treturn text_range_union(&p1, &p2);\n}\n\nstatic Filerange text_object_bracket(Text *txt, size_t pos, char type) {\n\tchar c, open, close;\n\tint opened = 1, closed = 1;\n\tFilerange r = text_range_empty();\n\n\tswitch (type) {\n\tcase '(':  case ')': open = '(';  close = ')';  break;\n\tcase '{':  case '}': open = '{';  close = '}';  break;\n\tcase '[':  case ']': open = '[';  close = ']';  break;\n\tcase '<':  case '>': open = '<';  close = '>';  break;\n\tcase '\"':            open = '\"';  close = '\"';  break;\n\tcase '`':            open = '`';  close = '`';  break;\n\tcase '\\'':           open = '\\''; close = '\\''; break;\n\tdefault: return r;\n\t}\n\n\tIterator it = text_iterator_get(txt, pos);\n\n\tif (open == close && text_iterator_byte_get(&it, &c) && (c == '\"' || c == '`' || c == '\\'')) {\n\t\tsize_t match = text_bracket_match(txt, pos, NULL);\n\t\tr.start = MIN(pos, match) + 1;\n\t\tr.end = MAX(pos, match);\n\t\treturn r;\n\t}\n\n\twhile (text_iterator_byte_get(&it, &c)) {\n\t\tif (c == open && --opened == 0) {\n\t\t\tr.start = it.pos + 1;\n\t\t\tbreak;\n\t\t} else if (c == close && it.pos != pos) {\n\t\t\topened++;\n\t\t}\n\t\ttext_iterator_byte_prev(&it, NULL);\n\t}\n\n\tit = text_iterator_get(txt, pos);\n\twhile (text_iterator_byte_get(&it, &c)) {\n\t\tif (c == close && --closed == 0) {\n\t\t\tr.end = it.pos;\n\t\t\tbreak;\n\t\t} else if (c == open && it.pos != pos) {\n\t\t\tclosed++;\n\t\t}\n\t\ttext_iterator_byte_next(&it, NULL);\n\t}\n\n\tif (!text_range_valid(&r))\n\t\treturn text_range_empty();\n\treturn r;\n}\n\nFilerange text_object_square_bracket(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, ']');\n}\n\nFilerange text_object_curly_bracket(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, '}');\n}\n\nFilerange text_object_angle_bracket(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, '>');\n}\n\nFilerange text_object_parenthesis(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, ')');\n}\n\nFilerange text_object_quote(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, '\"');\n}\n\nFilerange text_object_single_quote(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, '\\'');\n}\n\nFilerange text_object_backtick(Text *txt, size_t pos) {\n\treturn text_object_bracket(txt, pos, '`');\n}\n\nFilerange text_object_search_forward(Text *txt, size_t pos, Regex *regex) {\n\tsize_t start = pos;\n\tsize_t end = text_size(txt);\n\tRegexMatch match[1];\n\tbool found = start < end && !text_search_range_forward(txt, start, end - start, regex, 1, match, 0);\n\tif (found)\n\t\treturn text_range_new(match[0].start, match[0].end);\n\treturn text_range_empty();\n}\n\nFilerange text_object_search_backward(Text *txt, size_t pos, Regex *regex) {\n\tsize_t start = 0;\n\tsize_t end = pos;\n\tRegexMatch match[1];\n\tbool found = !text_search_range_backward(txt, start, end, regex, 1, match, 0);\n\tif (found)\n\t\treturn text_range_new(match[0].start, match[0].end);\n\treturn text_range_empty();\n}\n\nFilerange text_object_indentation(Text *txt, size_t pos) {\n\tchar c;\n\tsize_t bol = text_line_begin(txt, pos);\n\tsize_t sol = text_line_start(txt, bol);\n\tsize_t start = bol;\n\tsize_t end = text_line_next(txt, bol);\n\tsize_t line_indent = sol - bol;\n\tbool line_empty = text_byte_get(txt, bol, &c) && c == '\\n';\n\n\tchar *buf = text_bytes_alloc0(txt, bol, line_indent);\n\tchar *tmp = malloc(line_indent);\n\n\tif (!buf || !tmp) {\n\t\tfree(buf);\n\t\tfree(tmp);\n\t\treturn text_range_empty();\n\t}\n\n\twhile ((bol = text_line_begin(txt, text_line_prev(txt, start))) != start) {\n\t\tsol = text_line_start(txt, bol);\n\t\tsize_t indent = sol - bol;\n\t\tif (indent < line_indent)\n\t\t\tbreak;\n\t\tbool empty = text_byte_get(txt, bol, &c) && c == '\\n';\n\t\tif (line_empty && !empty)\n\t\t\tbreak;\n\t\tif (line_indent == 0 && empty)\n\t\t\tbreak;\n\t\ttext_bytes_get(txt, bol, line_indent, tmp);\n\t\tif (memcmp(buf, tmp, line_indent))\n\t\t\tbreak;\n\t\tstart = bol;\n\t}\n\n\tdo {\n\t\tbol = end;\n\t\tsol = text_line_start(txt, bol);\n\t\tsize_t indent = sol - bol;\n\t\tif (indent < line_indent)\n\t\t\tbreak;\n\t\tbool empty = text_byte_get(txt, bol, &c) && c == '\\n';\n\t\tif (line_empty && !empty)\n\t\t\tbreak;\n\t\tif (line_indent == 0 && empty)\n\t\t\tbreak;\n\t\ttext_bytes_get(txt, bol, line_indent, tmp);\n\t\tif (memcmp(buf, tmp, line_indent))\n\t\t\tbreak;\n\t\tend = text_line_next(txt, bol);\n\t} while (bol != end);\n\n\tfree(buf);\n\tfree(tmp);\n\treturn text_range_new(start, end);\n}\n\nFilerange text_range_linewise(Text *txt, Filerange *rin) {\n\tFilerange rout = *rin;\n\trout.start = text_line_begin(txt, rin->start);\n\tif (rin->end != text_line_begin(txt, rin->end))\n\t\trout.end = text_line_next(txt, rin->end);\n\treturn rout;\n}\n\nbool text_range_is_linewise(Text *txt, Filerange *r) {\n\treturn text_range_size(r) > 0 &&\n\t       r->start == text_line_begin(txt, r->start) &&\n\t       r->end == text_line_begin(txt, r->end);\n}\n\nFilerange text_range_inner(Text *txt, Filerange *rin) {\n\tchar c;\n\tFilerange r = *rin;\n\tIterator it = text_iterator_get(txt, rin->start);\n\twhile (text_iterator_byte_get(&it, &c) && space(c))\n\t\ttext_iterator_byte_next(&it, NULL);\n\tr.start = it.pos;\n\tit = text_iterator_get(txt, rin->end);\n\tdo r.end = it.pos; while (text_iterator_byte_prev(&it, &c) && space(c));\n\treturn r;\n}\n"
        },
        {
          "name": "text-objects.h",
          "type": "blob",
          "size": 2.7021484375,
          "content": "#ifndef TEXT_OBJECTS_H\n#define TEXT_OBJECTS_H\n\n/* these functions all take a file position. If this position is part of the\n * respective text-object, a corresponding range is returned. If there is no\n * such text-object at the given location, an empty range is returned.\n */\n\n#include <stddef.h>\n#include \"text.h\"\n\n/* return range covering the entire text */\nFilerange text_object_entire(Text*, size_t pos);\n/* word which happens to be at pos without any neighbouring white spaces */\nFilerange text_object_word(Text*, size_t pos);\n/* includes trailing white spaces. If at pos happens to be a white space\n * include all neighbouring leading white spaces and the following word. */\nFilerange text_object_word_outer(Text*, size_t pos);\n/* find next occurrence of `word' (as word not substring) in forward/backward direction */\nFilerange text_object_word_find_next(Text*, size_t pos, const char *word);\nFilerange text_object_word_find_prev(Text*, size_t pos, const char *word);\n/* find next occurrence of a literal string (not regex) in forward/backward direction */\nFilerange text_object_find_next(Text *txt, size_t pos, const char *search);\nFilerange text_object_find_prev(Text *txt, size_t pos, const char *search);\n/* same semantics as above but for a longword (i.e. delimited by white spaces) */\nFilerange text_object_longword(Text*, size_t pos);\nFilerange text_object_longword_outer(Text*, size_t pos);\n\nFilerange text_object_line(Text*, size_t pos);\nFilerange text_object_line_inner(Text*, size_t pos);\nFilerange text_object_sentence(Text*, size_t pos);\nFilerange text_object_paragraph(Text*, size_t pos);\nFilerange text_object_paragraph_outer(Text*, size_t pos);\n\n/* these are inner text objects i.e. the delimiters themself are not\n * included in the range */\nFilerange text_object_square_bracket(Text*, size_t pos);\nFilerange text_object_curly_bracket(Text*, size_t pos);\nFilerange text_object_angle_bracket(Text*, size_t pos);\nFilerange text_object_parenthesis(Text*, size_t pos);\nFilerange text_object_quote(Text*, size_t pos);\nFilerange text_object_single_quote(Text*, size_t pos);\nFilerange text_object_backtick(Text*, size_t pos);\n/* match a search term in either forward or backward direction */\nFilerange text_object_search_forward(Text*, size_t pos, Regex*);\nFilerange text_object_search_backward(Text*, size_t pos, Regex*);\n/* match all lines with same indentation level as the current one */\nFilerange text_object_indentation(Text*, size_t pos);\n\n/* extend a range to cover whole lines */\nFilerange text_range_linewise(Text*, Filerange*);\n/* trim leading and trailing white spaces from range */\nFilerange text_range_inner(Text*, Filerange*);\n/* test whether a given range covers whole lines */\nbool text_range_is_linewise(Text*, Filerange*);\n\n#endif\n"
        },
        {
          "name": "text-regex-tre.c",
          "type": "blob",
          "size": 3.7431640625,
          "content": "#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n#include <errno.h>\n\n#include \"text-regex.h\"\n#include \"text-motions.h\"\n\nstruct Regex {\n\tregex_t regex;\n\ttre_str_source str_source;\n\tText *text;\n\tIterator it;\n\tsize_t end;\n};\n\nsize_t text_regex_nsub(Regex *r) {\n       if (!r)\n               return 0;\n       return r->regex.re_nsub;\n}\n\nstatic int str_next_char(tre_char_t *c, unsigned int *pos_add, void *context) {\n\tRegex *r = context;\n\tIterator *it = &r->it;\n\tif (TRE_WCHAR) {\n\t\tmbstate_t ps = { 0 };\n\t\tbool eof = false;\n\t\tsize_t start = it->pos;\n\t\tfor (;;) {\n\t\t\tif (it->pos >= r->end) {\n\t\t\t\teof = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize_t rem = r->end - it->pos;\n\t\t\tsize_t plen = it->end - it->text;\n\t\t\tsize_t len = rem < plen ? rem : plen;\n\t\t\tsize_t wclen = mbrtowc(c, it->text, len, &ps);\n\t\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\t\tps = (mbstate_t){0};\n\t\t\t\t*c = L'\\0';\n\t\t\t\ttext_iterator_codepoint_next(it, NULL);\n\t\t\t\tbreak;\n\t\t\t} else if (wclen == (size_t)-2) {\n\t\t\t\tif (!text_iterator_next(it)) {\n\t\t\t\t\teof = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (wclen == 0) {\n\t\t\t\ttext_iterator_byte_next(it, NULL);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (wclen < plen) {\n\t\t\t\t\tit->text += wclen;\n\t\t\t\t\tit->pos += wclen;\n\t\t\t\t} else {\n\t\t\t\t\ttext_iterator_next(it);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (eof) {\n\t\t\t*c = L'\\0';\n\t\t\t*pos_add = 1;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\t*pos_add = it->pos - start;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t*pos_add = 1;\n\t\tif (it->pos < r->end && text_iterator_byte_get(it, (char*)c)) {\n\t\t\ttext_iterator_byte_next(it, NULL);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\t*c = '\\0';\n\t\t\treturn 1;\n\t\t}\n\t}\n}\n\nstatic void str_rewind(size_t pos, void *context) {\n\tRegex *r = context;\n\tr->it = text_iterator_get(r->text, pos);\n}\n\nstatic int str_compare(size_t pos1, size_t pos2, size_t len, void *context) {\n\tRegex *r = context;\n\tint ret = 1;\n\tvoid *buf1 = malloc(len), *buf2 = malloc(len);\n\tif (!buf1 || !buf2)\n\t\tgoto err;\n\ttext_bytes_get(r->text, pos1, len, buf1);\n\ttext_bytes_get(r->text, pos2, len, buf2);\n\tret = memcmp(buf1, buf2, len);\nerr:\n\tfree(buf1);\n\tfree(buf2);\n\treturn ret;\n}\n\nRegex *text_regex_new(void) {\n\tRegex *r = calloc(1, sizeof(*r));\n\tif (!r)\n\t\treturn NULL;\n\tr->str_source = (tre_str_source) {\n\t\t.get_next_char = str_next_char,\n\t\t.rewind = str_rewind,\n\t\t.compare = str_compare,\n\t\t.context = r,\n\t};\n\treturn r;\n}\n\nvoid text_regex_free(Regex *r) {\n\tif (!r)\n\t\treturn;\n\ttre_regfree(&r->regex);\n\tfree(r);\n}\n\nint text_regex_compile(Regex *regex, const char *string, int cflags) {\n\tint r = tre_regcomp(&regex->regex, string, cflags);\n\tif (r)\n\t\ttre_regcomp(&regex->regex, \"\\0\\0\", 0);\n\treturn r;\n}\n\nint text_regex_match(Regex *r, const char *data, int eflags) {\n\treturn tre_regexec(&r->regex, data, 0, NULL, eflags);\n}\n\nint text_search_range_forward(Text *txt, size_t pos, size_t len, Regex *r, size_t nmatch, RegexMatch pmatch[], int eflags) {\n\tr->text = txt;\n\tr->it = text_iterator_get(txt, pos);\n\tr->end = pos+len;\n\n\tregmatch_t match[MAX_REGEX_SUB];\n\tint ret = tre_reguexec(&r->regex, &r->str_source, nmatch, match, eflags);\n\tif (!ret) {\n\t\tfor (size_t i = 0; i < nmatch; i++) {\n\t\t\tpmatch[i].start = match[i].rm_so == -1 ? EPOS : pos + match[i].rm_so;\n\t\t\tpmatch[i].end = match[i].rm_eo == -1 ? EPOS : pos + match[i].rm_eo;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint text_search_range_backward(Text *txt, size_t pos, size_t len, Regex *r, size_t nmatch, RegexMatch pmatch[], int eflags) {\n\tint ret = REG_NOMATCH;\n\tsize_t end = pos + len;\n\n\twhile (pos < end && !text_search_range_forward(txt, pos, len, r, nmatch, pmatch, eflags)) {\n\t\tret = 0;\n\t\t// FIXME: assumes nmatch >= 1\n\t\tsize_t next = pmatch[0].end;\n\t\tif (next == pos) {\n\t\t\tnext = text_line_next(txt, pos);\n\t\t\tif (next == pos)\n\t\t\t\tbreak;\n\t\t}\n\t\tpos = next;\n\t\tlen = end - pos;\n\n\t\tchar c;\n\t\tif (text_byte_get(txt, pos-1, &c) && c == '\\n')\n\t\t\teflags &= ~REG_NOTBOL;\n\t\telse\n\t\t\teflags |= REG_NOTBOL;\n\t}\n\n\treturn ret;\n}\n"
        },
        {
          "name": "text-regex.c",
          "type": "blob",
          "size": 2.625,
          "content": "#include <stdlib.h>\n#include <string.h>\n\n#include \"text-regex.h\"\n\nstruct Regex {\n\tregex_t regex;\n};\n\nRegex *text_regex_new(void) {\n\tRegex *r = calloc(1, sizeof(Regex));\n\tif (!r)\n\t\treturn NULL;\n\tregcomp(&r->regex, \"\\0\\0\", 0); /* this should not match anything */\n\treturn r;\n}\n\nint text_regex_compile(Regex *regex, const char *string, int cflags) {\n\tint r = regcomp(&regex->regex, string, cflags);\n\tif (r)\n\t\tregcomp(&regex->regex, \"\\0\\0\", 0);\n\treturn r;\n}\n\nsize_t text_regex_nsub(Regex *r) {\n\tif (!r)\n\t\treturn 0;\n\treturn r->regex.re_nsub;\n}\n\nvoid text_regex_free(Regex *r) {\n\tif (!r)\n\t\treturn;\n\tregfree(&r->regex);\n\tfree(r);\n}\n\nint text_regex_match(Regex *r, const char *data, int eflags) {\n\treturn regexec(&r->regex, data, 0, NULL, eflags);\n}\n\nint text_search_range_forward(Text *txt, size_t pos, size_t len, Regex *r, size_t nmatch, RegexMatch pmatch[], int eflags) {\n\tchar *buf = text_bytes_alloc0(txt, pos, len);\n\tif (!buf)\n\t\treturn REG_NOMATCH;\n\tchar *cur = buf, *end = buf + len;\n\tint ret = REG_NOMATCH;\n\tregmatch_t match[MAX_REGEX_SUB];\n\tfor (size_t junk = len; len > 0; len -= junk, pos += junk) {\n\t\tret = regexec(&r->regex, cur, nmatch, match, eflags);\n\t\tif (!ret) {\n\t\t\tfor (size_t i = 0; i < nmatch; i++) {\n\t\t\t\tpmatch[i].start = match[i].rm_so == -1 ? EPOS : pos + match[i].rm_so;\n\t\t\t\tpmatch[i].end = match[i].rm_eo == -1 ? EPOS : pos + match[i].rm_eo;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tchar *next = memchr(cur, 0, len);\n\t\tif (!next)\n\t\t\tbreak;\n\t\twhile (!*next && next != end)\n\t\t\tnext++;\n\t\tjunk = next - cur;\n\t\tcur = next;\n\t}\n\tfree(buf);\n\treturn ret;\n}\n\nint text_search_range_backward(Text *txt, size_t pos, size_t len, Regex *r, size_t nmatch, RegexMatch pmatch[], int eflags) {\n\tchar *buf = text_bytes_alloc0(txt, pos, len);\n\tif (!buf)\n\t\treturn REG_NOMATCH;\n\tchar *cur = buf, *end = buf + len;\n\tint ret = REG_NOMATCH;\n\tregmatch_t match[MAX_REGEX_SUB];\n\tfor (size_t junk = len; len > 0; len -= junk, pos += junk) {\n\t\tchar *next;\n\t\tif (!regexec(&r->regex, cur, nmatch, match, eflags)) {\n\t\t\tret = 0;\n\t\t\tfor (size_t i = 0; i < nmatch; i++) {\n\t\t\t\tpmatch[i].start = match[i].rm_so == -1 ? EPOS : pos + match[i].rm_so;\n\t\t\t\tpmatch[i].end = match[i].rm_eo == -1 ? EPOS : pos + match[i].rm_eo;\n\t\t\t}\n\n\t\t\tif (match[0].rm_so == 0 && match[0].rm_eo == 0) {\n\t\t\t\t/* empty match at the beginning of cur, advance to next line */\n\t\t\t\tnext = strchr(cur, '\\n');\n\t\t\t\tif (!next)\n\t\t\t\t\tbreak;\n\t\t\t\tnext++;\n\t\t\t} else {\n\t\t\t\tnext = cur + match[0].rm_eo;\n\t\t\t}\n\t\t} else {\n\t\t\tnext = memchr(cur, 0, len);\n\t\t\tif (!next)\n\t\t\t\tbreak;\n\t\t\twhile (!*next && next != end)\n\t\t\t\tnext++;\n\t\t}\n\t\tjunk = next - cur;\n\t\tcur = next;\n\t\tif (cur[-1] == '\\n')\n\t\t\teflags &= ~REG_NOTBOL;\n\t\telse\n\t\t\teflags |= REG_NOTBOL;\n\t}\n\tfree(buf);\n\treturn ret;\n}\n"
        },
        {
          "name": "text-regex.h",
          "type": "blob",
          "size": 0.7041015625,
          "content": "#ifndef TEXT_REGEX_H\n#define TEXT_REGEX_H\n\n/* make the REG_* constants available */\n#if CONFIG_TRE\n#include <tre/tre.h>\n#else\n#include <regex.h>\n#endif\n#include \"text.h\"\n\n#define MAX_REGEX_SUB 10\n\ntypedef struct Regex Regex;\ntypedef Filerange RegexMatch;\n\nRegex *text_regex_new(void);\nint text_regex_compile(Regex*, const char *pattern, int cflags);\nsize_t text_regex_nsub(Regex*);\nvoid text_regex_free(Regex*);\nint text_regex_match(Regex*, const char *data, int eflags);\nint text_search_range_forward(Text*, size_t pos, size_t len, Regex *r, size_t nmatch, RegexMatch pmatch[], int eflags);\nint text_search_range_backward(Text*, size_t pos, size_t len, Regex *r, size_t nmatch, RegexMatch pmatch[], int eflags);\n\n#endif\n"
        },
        {
          "name": "text-util.c",
          "type": "blob",
          "size": 2.7900390625,
          "content": "#include \"text-util.h\"\n#include \"util.h\"\n#include <wchar.h>\n#include <errno.h>\n#include <stdlib.h>\n\nbool text_range_valid(const Filerange *r) {\n\treturn r->start != EPOS && r->end != EPOS && r->start <= r->end;\n}\n\nsize_t text_range_size(const Filerange *r) {\n\treturn text_range_valid(r) ? r->end - r->start : 0;\n}\n\nFilerange text_range_empty(void) {\n\treturn (Filerange){ .start = EPOS, .end = EPOS };\n}\n\nFilerange text_range_union(const Filerange *r1, const Filerange *r2) {\n\tif (!text_range_valid(r1))\n\t\treturn *r2;\n\tif (!text_range_valid(r2))\n\t\treturn *r1;\n\treturn (Filerange) {\n\t\t.start = MIN(r1->start, r2->start),\n\t\t.end = MAX(r1->end, r2->end),\n\t};\n}\n\nFilerange text_range_intersect(const Filerange *r1, const Filerange *r2) {\n\tif (!text_range_overlap(r1, r2))\n\t\treturn text_range_empty();\n\treturn text_range_new(MAX(r1->start, r2->start), MIN(r1->end, r2->end));\n}\n\nFilerange text_range_new(size_t a, size_t b) {\n\treturn (Filerange) {\n\t\t.start = MIN(a, b),\n\t\t.end = MAX(a, b),\n\t};\n}\n\nbool text_range_equal(const Filerange *r1, const Filerange *r2) {\n\tif (!text_range_valid(r1) && !text_range_valid(r2))\n\t\treturn true;\n\treturn r1->start == r2->start && r1->end == r2->end;\n}\n\nbool text_range_overlap(const Filerange *r1, const Filerange *r2) {\n\tif (!text_range_valid(r1) || !text_range_valid(r2))\n\t\treturn false;\n\treturn r1->start < r2->end && r2->start < r1->end;\n}\n\nbool text_range_contains(const Filerange *r, size_t pos) {\n\treturn text_range_valid(r) && r->start <= pos && pos <= r->end;\n}\n\nint text_char_count(const char *data, size_t len) {\n\tint count = 0;\n\tmbstate_t ps = { 0 };\n\twhile (len > 0) {\n\t\twchar_t wc;\n\t\tsize_t wclen = mbrtowc(&wc, data, len, &ps);\n\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\tps = (mbstate_t){0};\n\t\t\tcount++;\n\t\t\twhile (!ISUTF8(*data))\n\t\t\t\tdata++, len--;\n\t\t} else if (wclen == (size_t)-2) {\n\t\t\tbreak;\n                } else if (wclen == 0) {\n\t\t\tcount++;\n\t\t\tdata++;\n\t\t\tlen--;\n\t\t} else {\n\t\t\tint width = wcwidth(wc);\n\t\t\tif (width != 0)\n\t\t\t\tcount++;\n\t\t\tdata += wclen;\n\t\t\tlen -= wclen;\n                }\n\t}\n\treturn count;\n}\n\nint text_string_width(const char *data, size_t len) {\n\n\tint width = 0;\n\tmbstate_t ps = { 0 };\n\tconst char *s = data;\n\n\twhile (len > 0) {\n\t\twchar_t wc;\n\t\tsize_t wclen = mbrtowc(&wc, s, len, &ps);\n\t\tif (wclen == (size_t)-1 && errno == EILSEQ) {\n\t\t\tps = (mbstate_t){0};\n\t\t\t/* assume a replacement symbol will be displayed */\n\t\t\twidth++;\n\t\t\twclen = 1;\n\t\t} else if (wclen == (size_t)-2) {\n\t\t\t/* do nothing, advance to next character */\n\t\t\twclen = 1;\n\t\t} else if (wclen == 0) {\n\t\t\t/* assume NUL byte will be displayed as ^@ */\n\t\t\twidth += 2;\n\t\t\twclen = 1;\n\t\t} else if (wc == L'\\t') {\n\t\t\twidth++;\n\t\t\twclen = 1;\n\t\t} else {\n\t\t\tint w = wcwidth(wc);\n\t\t\tif (w == -1)\n\t\t\t\tw = 2; /* assume non-printable will be displayed as ^{char} */\n\t\t\twidth += w;\n\t\t}\n\t\tlen -= wclen;\n\t\ts += wclen;\n\t}\n\n\treturn width;\n}\n"
        },
        {
          "name": "text-util.h",
          "type": "blob",
          "size": 1.20703125,
          "content": "#ifndef TEXT_UTIL_H\n#define TEXT_UTIL_H\n\n#include <stdbool.h>\n#include <stddef.h>\n#include \"text.h\"\n\n/* test whether the given range is valid (start <= end) */\nbool text_range_valid(const Filerange*);\n/* get the size of the range (end-start) or zero if invalid */\nsize_t text_range_size(const Filerange*);\n/* create an empty / invalid range of size zero */\nFilerange text_range_empty(void);\n/* merge two ranges into a new one which contains both of them */\nFilerange text_range_union(const Filerange*, const Filerange*);\n/* get intersection of two ranges */\nFilerange text_range_intersect(const Filerange*, const Filerange*);\n/* create new range [min(a,b), max(a,b)] */\nFilerange text_range_new(size_t a, size_t b);\n/* test whether two ranges are equal */\nbool text_range_equal(const Filerange*, const Filerange*);\n/* test whether two ranges overlap */\nbool text_range_overlap(const Filerange*, const Filerange*);\n/* test whether a given position is within a certain range */\nbool text_range_contains(const Filerange*, size_t pos);\n/* count the number of graphemes in data */\nint text_char_count(const char *data, size_t len);\n/* get the approximate display width of data */\nint text_string_width(const char *data, size_t len);\n\n#endif\n"
        },
        {
          "name": "text.c",
          "type": "blob",
          "size": 27.533203125,
          "content": "#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <wchar.h>\n#include <stdint.h>\n#include <libgen.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n\n#include \"text.h\"\n#include \"text-util.h\"\n#include \"text-motions.h\"\n#include \"util.h\"\n#include \"array.h\"\n#include \"text-internal.h\"\n\n/* A piece holds a reference (but doesn't itself store) a certain amount of data.\n * All active pieces chained together form the whole content of the document.\n * At the beginning there exists only one piece, spanning the whole document.\n * Upon insertion/deletion new pieces will be created to represent the changes.\n * Generally pieces are never destroyed, but kept around to perform undo/redo\n * operations.\n */\nstruct Piece {\n\tText *text;             /* text to which this piece belongs */\n\tPiece *prev, *next;     /* pointers to the logical predecessor/successor */\n\tPiece *global_prev;     /* double linked list in order of allocation, */\n\tPiece *global_next;     /* used to free individual pieces */\n\tconst char *data;       /* pointer into a Block holding the data */\n\tsize_t len;             /* the length in number of bytes of the data */\n};\n\n/* used to transform a global position (byte offset starting from the beginning\n * of the text) into an offset relative to a piece.\n */\ntypedef struct {\n\tPiece *piece;           /* piece holding the location */\n\tsize_t off;             /* offset into the piece in bytes */\n} Location;\n\n/* A Span holds a certain range of pieces. Changes to the document are always\n * performed by swapping out an existing span with a new one.\n */\ntypedef struct {\n\tPiece *start, *end;     /* start/end of the span */\n\tsize_t len;             /* the sum of the lengths of the pieces which form this span */\n} Span;\n\n/* A Change keeps all needed information to redo/undo an insertion/deletion. */\ntypedef struct Change Change;\nstruct Change {\n\tSpan old;               /* all pieces which are being modified/swapped out by the change */\n\tSpan new;               /* all pieces which are introduced/swapped in by the change */\n\tsize_t pos;             /* absolute position at which the change occurred */\n\tChange *next;           /* next change which is part of the same revision */\n\tChange *prev;           /* previous change which is part of the same revision */\n};\n\n/* A Revision is a list of Changes which are used to undo/redo all modifications\n * since the last snapshot operation. Revisions are stored in a directed graph structure.\n */\ntypedef struct Revision Revision;\nstruct Revision {\n\tChange *change;         /* the most recent change */\n\tRevision *next;         /* the next (child) revision in the undo tree */\n\tRevision *prev;         /* the previous (parent) revision in the undo tree */\n\tRevision *earlier;      /* the previous Revision, chronologically */\n\tRevision *later;        /* the next Revision, chronologically */\n\ttime_t time;            /* when the first change of this revision was performed */\n\tsize_t seq;             /* a unique, strictly increasing identifier */\n};\n\ntypedef struct {\n\tsize_t pos;             /* position in bytes from start of file */\n\tsize_t lineno;          /* line number in file i.e. number of '\\n' in [0, pos) */\n} LineCache;\n\n/* The main struct holding all information of a given file */\nstruct Text {\n\tArray blocks;           /* blocks which hold text content */\n\tPiece *pieces;          /* all pieces which have been allocated, used to free them */\n\tPiece *cache;           /* most recently modified piece */\n\tPiece begin, end;       /* sentinel nodes which always exists but don't hold any data */\n\tRevision *history;        /* undo tree */\n\tRevision *current_revision; /* revision holding all file changes until a snapshot is performed */\n\tRevision *last_revision;    /* the last revision added to the tree, chronologically */\n\tRevision *saved_revision;   /* the last revision at the time of the save operation */\n\tsize_t size;            /* current file content size in bytes */\n\tstruct stat info;       /* stat as probed at load time */\n\tLineCache lines;        /* mapping between absolute pos in bytes and logical line breaks */\n};\n\n/* block management */\nstatic const char *block_store(Text*, const char *data, size_t len);\n/* cache layer */\nstatic void cache_piece(Text *txt, Piece *p);\nstatic bool cache_contains(Text *txt, Piece *p);\nstatic bool cache_insert(Text *txt, Piece *p, size_t off, const char *data, size_t len);\nstatic bool cache_delete(Text *txt, Piece *p, size_t off, size_t len);\n/* piece management */\nstatic Piece *piece_alloc(Text *txt);\nstatic void piece_free(Piece *p);\nstatic void piece_init(Piece *p, Piece *prev, Piece *next, const char *data, size_t len);\nstatic Location piece_get_intern(Text *txt, size_t pos);\nstatic Location piece_get_extern(const Text *txt, size_t pos);\n/* span management */\nstatic void span_init(Span *span, Piece *start, Piece *end);\nstatic void span_swap(Text *txt, Span *old, Span *new);\n/* change management */\nstatic Change *change_alloc(Text *txt, size_t pos);\nstatic void change_free(Change *c);\n/* revision management */\nstatic Revision *revision_alloc(Text *txt);\nstatic void revision_free(Revision *rev);\n/* logical line counting cache */\nstatic void lineno_cache_invalidate(LineCache *cache);\nstatic size_t lines_skip_forward(Text *txt, size_t pos, size_t lines, size_t *lines_skipped);\nstatic size_t lines_count(Text *txt, size_t pos, size_t len);\n\n/* stores the given data in a block, allocates a new one if necessary. Returns\n * a pointer to the storage location or NULL if allocation failed. */\nstatic const char *block_store(Text *txt, const char *data, size_t len) {\n\tBlock *blk = array_get_ptr(&txt->blocks, txt->blocks.len - 1);\n\tif (!blk || !block_capacity(blk, len)) {\n\t\tblk = block_alloc(len);\n\t\tif (!blk)\n\t\t\treturn NULL;\n\t\tif (!array_add_ptr(&txt->blocks, blk)) {\n\t\t\tblock_free(blk);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn block_append(blk, data, len);\n}\n\n/* cache the given piece if it is the most recently changed one */\nstatic void cache_piece(Text *txt, Piece *p) {\n\tBlock *blk = array_get_ptr(&txt->blocks, txt->blocks.len - 1);\n\tif (!blk || p->data < blk->data || p->data + p->len != blk->data + blk->len)\n\t\treturn;\n\ttxt->cache = p;\n}\n\n/* check whether the given piece was the most recently modified one */\nstatic bool cache_contains(Text *txt, Piece *p) {\n\tBlock *blk = array_get_ptr(&txt->blocks, txt->blocks.len - 1);\n\tRevision *rev = txt->current_revision;\n\tif (!blk || !txt->cache || txt->cache != p || !rev || !rev->change)\n\t\treturn false;\n\n\tPiece *start = rev->change->new.start;\n\tPiece *end = rev->change->new.end;\n\tbool found = false;\n\tfor (Piece *cur = start; !found; cur = cur->next) {\n\t\tif (cur == p)\n\t\t\tfound = true;\n\t\tif (cur == end)\n\t\t\tbreak;\n\t}\n\n\treturn found && p->data + p->len == blk->data + blk->len;\n}\n\n/* try to insert a chunk of data at a given piece offset. The insertion is only\n * performed if the piece is the most recently changed one. The length of the\n * piece, the span containing it and the whole text is adjusted accordingly */\nstatic bool cache_insert(Text *txt, Piece *p, size_t off, const char *data, size_t len) {\n\tif (!cache_contains(txt, p))\n\t\treturn false;\n\tBlock *blk = array_get_ptr(&txt->blocks, txt->blocks.len - 1);\n\tsize_t bufpos = p->data + off - blk->data;\n\tif (!block_insert(blk, bufpos, data, len))\n\t\treturn false;\n\tp->len += len;\n\ttxt->current_revision->change->new.len += len;\n\ttxt->size += len;\n\treturn true;\n}\n\n/* try to delete a chunk of data at a given piece offset. The deletion is only\n * performed if the piece is the most recently changed one and the whole\n * affected range lies within it. The length of the piece, the span containing it\n * and the whole text is adjusted accordingly */\nstatic bool cache_delete(Text *txt, Piece *p, size_t off, size_t len) {\n\tif (!cache_contains(txt, p))\n\t\treturn false;\n\tBlock *blk = array_get_ptr(&txt->blocks, txt->blocks.len - 1);\n\tsize_t end;\n\tsize_t bufpos = p->data + off - blk->data;\n\tif (!addu(off, len, &end) || end > p->len || !block_delete(blk, bufpos, len))\n\t\treturn false;\n\tp->len -= len;\n\ttxt->current_revision->change->new.len -= len;\n\ttxt->size -= len;\n\treturn true;\n}\n\n/* initialize a span and calculate its length */\nstatic void span_init(Span *span, Piece *start, Piece *end) {\n\tsize_t len = 0;\n\tspan->start = start;\n\tspan->end = end;\n\tfor (Piece *p = start; p; p = p->next) {\n\t\tlen += p->len;\n\t\tif (p == end)\n\t\t\tbreak;\n\t}\n\tspan->len = len;\n}\n\n/* swap out an old span and replace it with a new one.\n *\n *  - if old is an empty span do not remove anything, just insert the new one\n *  - if new is an empty span do not insert anything, just remove the old one\n *\n * adjusts the document size accordingly.\n */\nstatic void span_swap(Text *txt, Span *old, Span *new) {\n\tif (old->len == 0 && new->len == 0) {\n\t\treturn;\n\t} else if (old->len == 0) {\n\t\t/* insert new span */\n\t\tnew->start->prev->next = new->start;\n\t\tnew->end->next->prev = new->end;\n\t} else if (new->len == 0) {\n\t\t/* delete old span */\n\t\told->start->prev->next = old->end->next;\n\t\told->end->next->prev = old->start->prev;\n\t} else {\n\t\t/* replace old with new */\n\t\told->start->prev->next = new->start;\n\t\told->end->next->prev = new->end;\n\t}\n\ttxt->size -= old->len;\n\ttxt->size += new->len;\n}\n\n/* Allocate a new revision and place it in the revision graph.\n * All further changes will be associated with this revision. */\nstatic Revision *revision_alloc(Text *txt) {\n\tRevision *rev = calloc(1, sizeof *rev);\n\tif (!rev)\n\t\treturn NULL;\n\trev->time = time(NULL);\n\ttxt->current_revision = rev;\n\n\t/* set sequence number */\n\tif (!txt->last_revision)\n\t\trev->seq = 0;\n\telse\n\t\trev->seq = txt->last_revision->seq + 1;\n\n\t/* set earlier, later pointers */\n\tif (txt->last_revision)\n\t\ttxt->last_revision->later = rev;\n\trev->earlier = txt->last_revision;\n\n\tif (!txt->history) {\n\t\ttxt->history = rev;\n\t\treturn rev;\n\t}\n\n\t/* set prev, next pointers */\n\trev->prev = txt->history;\n\ttxt->history->next = rev;\n\ttxt->history = rev;\n\treturn rev;\n}\n\nstatic void revision_free(Revision *rev) {\n\tif (!rev)\n\t\treturn;\n\tfor (Change *next, *c = rev->change; c; c = next) {\n\t\tnext = c->next;\n\t\tchange_free(c);\n\t}\n\tfree(rev);\n}\n\nstatic Piece *piece_alloc(Text *txt) {\n\tPiece *p = calloc(1, sizeof *p);\n\tif (!p)\n\t\treturn NULL;\n\tp->text = txt;\n\tp->global_next = txt->pieces;\n\tif (txt->pieces)\n\t\ttxt->pieces->global_prev = p;\n\ttxt->pieces = p;\n\treturn p;\n}\n\nstatic void piece_free(Piece *p) {\n\tif (!p)\n\t\treturn;\n\tif (p->global_prev)\n\t\tp->global_prev->global_next = p->global_next;\n\tif (p->global_next)\n\t\tp->global_next->global_prev = p->global_prev;\n\tif (p->text->pieces == p)\n\t\tp->text->pieces = p->global_next;\n\tif (p->text->cache == p)\n\t\tp->text->cache = NULL;\n\tfree(p);\n}\n\nstatic void piece_init(Piece *p, Piece *prev, Piece *next, const char *data, size_t len) {\n\tp->prev = prev;\n\tp->next = next;\n\tp->data = data;\n\tp->len = len;\n}\n\n/* returns the piece holding the text at byte offset pos. If pos happens to\n * be at a piece boundary i.e. the first byte of a piece then the previous piece\n * to the left is returned with an offset of piece->len. This is convenient for\n * modifications to the piece chain where both pieces (the returned one and the\n * one following it) are needed, but unsuitable as a public interface.\n *\n * in particular if pos is zero, the begin sentinel piece is returned.\n */\nstatic Location piece_get_intern(Text *txt, size_t pos) {\n\tsize_t cur = 0;\n\tfor (Piece *p = &txt->begin; p->next; p = p->next) {\n\t\tif (cur <= pos && pos <= cur + p->len)\n\t\t\treturn (Location){ .piece = p, .off = pos - cur };\n\t\tcur += p->len;\n\t}\n\n\treturn (Location){ 0 };\n}\n\n/* similar to piece_get_intern but usable as a public API. Returns the piece\n * holding the text at byte offset pos. Never returns a sentinel piece.\n * it pos is the end of file (== text_size()) and the file is not empty then\n * the last piece holding data is returned.\n */\nstatic Location piece_get_extern(const Text *txt, size_t pos) {\n\tsize_t cur = 0;\n\tPiece *p;\n\n\tfor (p = txt->begin.next; p->next; p = p->next) {\n\t\tif (cur <= pos && pos < cur + p->len)\n\t\t\treturn (Location){ .piece = p, .off = pos - cur };\n\t\tcur += p->len;\n\t}\n\n\tif (cur == pos)\n\t\treturn (Location){ .piece = p->prev, .off = p->prev->len };\n\n\treturn (Location){ 0 };\n}\n\n/* allocate a new change, associate it with current revision or a newly\n * allocated one if none exists. */\nstatic Change *change_alloc(Text *txt, size_t pos) {\n\tRevision *rev = txt->current_revision;\n\tif (!rev) {\n\t\trev = revision_alloc(txt);\n\t\tif (!rev)\n\t\t\treturn NULL;\n\t}\n\tChange *c = calloc(1, sizeof *c);\n\tif (!c)\n\t\treturn NULL;\n\tc->pos = pos;\n\tc->next = rev->change;\n\tif (rev->change)\n\t\trev->change->prev = c;\n\trev->change = c;\n\treturn c;\n}\n\nstatic void change_free(Change *c) {\n\tif (!c)\n\t\treturn;\n\t/* only free the new part of the span, the old one is still in use */\n\tif (c->new.start != c->new.end)\n\t\tpiece_free(c->new.end);\n\tpiece_free(c->new.start);\n\tfree(c);\n}\n\n/* When inserting new data there are 2 cases to consider.\n *\n *  - in the first the insertion point falls into the middle of an existing\n *    piece which is replaced by three new pieces:\n *\n *      /-+ --> +---------------+ --> +-\\\n *      | |     | existing text |     | |\n *      \\-+ <-- +---------------+ <-- +-/\n *                         ^\n *                         Insertion point for \"demo \"\n *\n *      /-+ --> +---------+ --> +-----+ --> +-----+ --> +-\\\n *      | |     | existing|     |demo |     |text |     | |\n *      \\-+ <-- +---------+ <-- +-----+ <-- +-----+ <-- +-/\n *\n *  - the second case deals with an insertion point at a piece boundary:\n *\n *      /-+ --> +---------------+ --> +-\\\n *      | |     | existing text |     | |\n *      \\-+ <-- +---------------+ <-- +-/\n *            ^\n *            Insertion point for \"short\"\n *\n *      /-+ --> +-----+ --> +---------------+ --> +-\\\n *      | |     |short|     | existing text |     | |\n *      \\-+ <-- +-----+ <-- +---------------+ <-- +-/\n */\nbool text_insert(Text *txt, size_t pos, const char *data, size_t len) {\n\tif (len == 0)\n\t\treturn true;\n\tif (pos > txt->size)\n\t\treturn false;\n\tif (pos < txt->lines.pos)\n\t\tlineno_cache_invalidate(&txt->lines);\n\n\tLocation loc = piece_get_intern(txt, pos);\n\tPiece *p = loc.piece;\n\tif (!p)\n\t\treturn false;\n\tsize_t off = loc.off;\n\tif (cache_insert(txt, p, off, data, len))\n\t\treturn true;\n\n\tChange *c = change_alloc(txt, pos);\n\tif (!c)\n\t\treturn false;\n\n\tif (!(data = block_store(txt, data, len)))\n\t\treturn false;\n\n\tPiece *new = NULL;\n\n\tif (off == p->len) {\n\t\t/* insert between two existing pieces, hence there is nothing to\n\t\t * remove, just add a new piece holding the extra text */\n\t\tif (!(new = piece_alloc(txt)))\n\t\t\treturn false;\n\t\tpiece_init(new, p, p->next, data, len);\n\t\tspan_init(&c->new, new, new);\n\t\tspan_init(&c->old, NULL, NULL);\n\t} else {\n\t\t/* insert into middle of an existing piece, therefore split the old\n\t\t * piece. That is we have 3 new pieces one containing the content\n\t\t * before the insertion point then one holding the newly inserted\n\t\t * text and one holding the content after the insertion point.\n\t\t */\n\t\tPiece *before = piece_alloc(txt);\n\t\tnew = piece_alloc(txt);\n\t\tPiece *after = piece_alloc(txt);\n\t\tif (!before || !new || !after)\n\t\t\treturn false;\n\t\tpiece_init(before, p->prev, new, p->data, off);\n\t\tpiece_init(new, before, after, data, len);\n\t\tpiece_init(after, new, p->next, p->data + off, p->len - off);\n\n\t\tspan_init(&c->new, before, after);\n\t\tspan_init(&c->old, p, p);\n\t}\n\n\tcache_piece(txt, new);\n\tspan_swap(txt, &c->old, &c->new);\n\treturn true;\n}\n\nstatic size_t revision_undo(Text *txt, Revision *rev) {\n\tsize_t pos = EPOS;\n\tfor (Change *c = rev->change; c; c = c->next) {\n\t\tspan_swap(txt, &c->new, &c->old);\n\t\tpos = c->pos;\n\t}\n\treturn pos;\n}\n\nstatic size_t revision_redo(Text *txt, Revision *rev) {\n\tsize_t pos = EPOS;\n\tChange *c = rev->change;\n\twhile (c->next)\n\t\tc = c->next;\n\tfor ( ; c; c = c->prev) {\n\t\tspan_swap(txt, &c->old, &c->new);\n\t\tpos = c->pos;\n\t\tif (c->new.len > c->old.len)\n\t\t\tpos += c->new.len - c->old.len;\n\t}\n\treturn pos;\n}\n\nsize_t text_undo(Text *txt) {\n\tsize_t pos = EPOS;\n\t/* taking rev snapshot makes sure that txt->current_revision is reset */\n\ttext_snapshot(txt);\n\tRevision *rev = txt->history->prev;\n\tif (!rev)\n\t\treturn pos;\n\tpos = revision_undo(txt, txt->history);\n\ttxt->history = rev;\n\tlineno_cache_invalidate(&txt->lines);\n\treturn pos;\n}\n\nsize_t text_redo(Text *txt) {\n\tsize_t pos = EPOS;\n\t/* taking a snapshot makes sure that txt->current_revision is reset */\n\ttext_snapshot(txt);\n\tRevision *rev = txt->history->next;\n\tif (!rev)\n\t\treturn pos;\n\tpos = revision_redo(txt, rev);\n\ttxt->history = rev;\n\tlineno_cache_invalidate(&txt->lines);\n\treturn pos;\n}\n\nstatic bool history_change_branch(Revision *rev) {\n\tbool changed = false;\n\twhile (rev->prev) {\n\t\tif (rev->prev->next != rev) {\n\t\t\trev->prev->next = rev;\n\t\t\tchanged = true;\n\t\t}\n\t\trev = rev->prev;\n\t}\n\treturn changed;\n}\n\nstatic size_t history_traverse_to(Text *txt, Revision *rev) {\n\tsize_t pos = EPOS;\n\tif (!rev)\n\t\treturn pos;\n\tbool changed = history_change_branch(rev);\n\tif (!changed) {\n\t\tif (rev->seq == txt->history->seq) {\n\t\t\treturn txt->lines.pos;\n\t\t} else if (rev->seq > txt->history->seq) {\n\t\t\twhile (txt->history != rev)\n\t\t\t\tpos = text_redo(txt);\n\t\t\treturn pos;\n\t\t} else if (rev->seq < txt->history->seq) {\n\t\t\twhile (txt->history != rev)\n\t\t\t\tpos = text_undo(txt);\n\t\t\treturn pos;\n\t\t}\n\t} else {\n\t\twhile (txt->history->prev && txt->history->prev->next == txt->history)\n\t\t\ttext_undo(txt);\n\t\tpos = text_undo(txt);\n\t\twhile (txt->history != rev)\n\t\t\tpos = text_redo(txt);\n\t\treturn pos;\n\t}\n\treturn pos;\n}\n\nsize_t text_earlier(Text *txt) {\n\treturn history_traverse_to(txt, txt->history->earlier);\n}\n\nsize_t text_later(Text *txt) {\n\treturn history_traverse_to(txt, txt->history->later);\n}\n\nsize_t text_restore(Text *txt, time_t time) {\n\tRevision *rev = txt->history;\n\twhile (time < rev->time && rev->earlier)\n\t\trev = rev->earlier;\n\twhile (time > rev->time && rev->later)\n\t\trev = rev->later;\n\ttime_t diff = labs(rev->time - time);\n\tif (rev->earlier && rev->earlier != txt->history && labs(rev->earlier->time - time) < diff)\n\t\trev = rev->earlier;\n\tif (rev->later && rev->later != txt->history && labs(rev->later->time - time) < diff)\n\t\trev = rev->later;\n\treturn history_traverse_to(txt, rev);\n}\n\ntime_t text_state(const Text *txt) {\n\treturn txt->history->time;\n}\n\nText *text_loadat_method(int dirfd, const char *filename, enum TextLoadMethod method) {\n\tText *txt = calloc(1, sizeof *txt);\n\tif (!txt)\n\t\treturn NULL;\n\tPiece *p = piece_alloc(txt);\n\tif (!p)\n\t\tgoto out;\n\tBlock *block = NULL;\n\tarray_init(&txt->blocks);\n\tlineno_cache_invalidate(&txt->lines);\n\tif (filename) {\n\t\terrno = 0;\n\t\tblock = block_load(dirfd, filename, method, &txt->info);\n\t\tif (!block && errno)\n\t\t\tgoto out;\n\t\tif (block && !array_add_ptr(&txt->blocks, block)) {\n\t\t\tblock_free(block);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!block)\n\t\tpiece_init(p, &txt->begin, &txt->end, \"\\0\", 0);\n\telse\n\t\tpiece_init(p, &txt->begin, &txt->end, block->data, block->len);\n\n\tpiece_init(&txt->begin, NULL, p, NULL, 0);\n\tpiece_init(&txt->end, p, NULL, NULL, 0);\n\ttxt->size = p->len;\n\t/* write an empty revision */\n\tchange_alloc(txt, EPOS);\n\ttext_snapshot(txt);\n\ttxt->saved_revision = txt->history;\n\n\treturn txt;\nout:\n\ttext_free(txt);\n\treturn NULL;\n}\n\nstruct stat text_stat(const Text *txt) {\n\treturn txt->info;\n}\n\nvoid text_saved(Text *txt, struct stat *meta) {\n\tif (meta)\n\t\ttxt->info = *meta;\n\ttxt->saved_revision = txt->history;\n\ttext_snapshot(txt);\n}\n\nBlock *text_block_mmaped(Text *txt) {\n\tBlock *block = array_get_ptr(&txt->blocks, 0);\n\tif (block && block->type == BLOCK_TYPE_MMAP_ORIG && block->size)\n\t\treturn block;\n\treturn NULL;\n}\n\n/* A delete operation can either start/stop midway through a piece or at\n * a boundary. In the former case a new piece is created to represent the\n * remaining text before/after the modification point.\n *\n *      /-+ --> +---------+ --> +-----+ --> +-----+ --> +-\\\n *      | |     | existing|     |demo |     |text |     | |\n *      \\-+ <-- +---------+ <-- +-----+ <-- +-----+ <-- +-/\n *                   ^                         ^\n *                   |------ delete range -----|\n *\n *      /-+ --> +----+ --> +--+ --> +-\\\n *      | |     | exi|     |t |     | |\n *      \\-+ <-- +----+ <-- +--+ <-- +-/\n */\nbool text_delete(Text *txt, size_t pos, size_t len) {\n\tif (len == 0)\n\t\treturn true;\n\tsize_t pos_end;\n\tif (!addu(pos, len, &pos_end) || pos_end > txt->size)\n\t\treturn false;\n\tif (pos < txt->lines.pos)\n\t\tlineno_cache_invalidate(&txt->lines);\n\n\tLocation loc = piece_get_intern(txt, pos);\n\tPiece *p = loc.piece;\n\tif (!p)\n\t\treturn false;\n\tsize_t off = loc.off;\n\tif (cache_delete(txt, p, off, len))\n\t\treturn true;\n\tChange *c = change_alloc(txt, pos);\n\tif (!c)\n\t\treturn false;\n\n\tbool midway_start = false, midway_end = false; /* split pieces? */\n\tPiece *before, *after; /* unmodified pieces before/after deletion point */\n\tPiece *start, *end;    /* span which is removed */\n\tsize_t cur;            /* how much has already been deleted */\n\n\tif (off == p->len) {\n\t\t/* deletion starts at a piece boundary */\n\t\tcur = 0;\n\t\tbefore = p;\n\t\tstart = p->next;\n\t} else {\n\t\t/* deletion starts midway through a piece */\n\t\tmidway_start = true;\n\t\tcur = p->len - off;\n\t\tstart = p;\n\t\tbefore = piece_alloc(txt);\n\t\tif (!before)\n\t\t\treturn false;\n\t}\n\n\t/* skip all pieces which fall into deletion range */\n\twhile (cur < len) {\n\t\tp = p->next;\n\t\tcur += p->len;\n\t}\n\n\tif (cur == len) {\n\t\t/* deletion stops at a piece boundary */\n\t\tend = p;\n\t\tafter = p->next;\n\t} else {\n\t\t/* cur > len: deletion stops midway through a piece */\n\t\tmidway_end = true;\n\t\tend = p;\n\t\tafter = piece_alloc(txt);\n\t\tif (!after)\n\t\t\treturn false;\n\t\tpiece_init(after, before, p->next, p->data + p->len - (cur - len), cur - len);\n\t}\n\n\tif (midway_start) {\n\t\t/* we finally know which piece follows our newly allocated before piece */\n\t\tpiece_init(before, start->prev, after, start->data, off);\n\t}\n\n\tPiece *new_start = NULL, *new_end = NULL;\n\tif (midway_start) {\n\t\tnew_start = before;\n\t\tif (!midway_end)\n\t\t\tnew_end = before;\n\t}\n\tif (midway_end) {\n\t\tif (!midway_start)\n\t\t\tnew_start = after;\n\t\tnew_end = after;\n\t}\n\n\tspan_init(&c->new, new_start, new_end);\n\tspan_init(&c->old, start, end);\n\tspan_swap(txt, &c->old, &c->new);\n\treturn true;\n}\n\nbool text_delete_range(Text *txt, const Filerange *r) {\n\tif (!text_range_valid(r))\n\t\treturn false;\n\treturn text_delete(txt, r->start, text_range_size(r));\n}\n\n/* preserve the current text content such that it can be restored by\n * means of undo/redo operations */\nbool text_snapshot(Text *txt) {\n\tif (txt->current_revision)\n\t\ttxt->last_revision = txt->current_revision;\n\ttxt->current_revision = NULL;\n\ttxt->cache = NULL;\n\treturn true;\n}\n\n\nvoid text_free(Text *txt) {\n\tif (!txt)\n\t\treturn;\n\n\t// free history\n\tRevision *hist = txt->history;\n\twhile (hist && hist->prev)\n\t\thist = hist->prev;\n\twhile (hist) {\n\t\tRevision *later = hist->later;\n\t\trevision_free(hist);\n\t\thist = later;\n\t}\n\n\tfor (Piece *next, *p = txt->pieces; p; p = next) {\n\t\tnext = p->global_next;\n\t\tpiece_free(p);\n\t}\n\n\tfor (size_t i = 0, len = txt->blocks.len; i < len; i++)\n\t\tblock_free(array_get_ptr(&txt->blocks, i));\n\tarray_release(&txt->blocks);\n\n\tfree(txt);\n}\n\nbool text_modified(const Text *txt) {\n\treturn txt->saved_revision != txt->history;\n}\n\nbool text_mmaped(const Text *txt, const char *ptr) {\n\tuintptr_t addr = (uintptr_t)ptr;\n\tfor (size_t i = 0, len = txt->blocks.len; i < len; i++) {\n\t\tBlock *blk = array_get_ptr(&txt->blocks, i);\n\t\tif ((blk->type == BLOCK_TYPE_MMAP_ORIG || blk->type == BLOCK_TYPE_MMAP) &&\n\t\t    (uintptr_t)(blk->data) <= addr && addr < (uintptr_t)(blk->data + blk->size))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool iterator_init(Iterator *it, size_t pos, Piece *p, size_t off) {\n\t*it = (Iterator){\n\t\t.pos = pos,\n\t\t.piece = p,\n\t\t.start = p ? p->data : NULL,\n\t\t.end = p && p->data ? p->data + p->len : NULL,\n\t\t.text = p && p->data ? p->data + off : NULL,\n\t};\n\treturn text_iterator_valid(it);\n}\n\nbool text_iterator_init(const Text *txt, Iterator *it, size_t pos) {\n\tLocation loc = piece_get_extern(txt, pos);\n\treturn iterator_init(it, pos, loc.piece, loc.off);\n}\n\nIterator text_iterator_get(const Text *txt, size_t pos) {\n\tIterator it;\n\ttext_iterator_init(txt, &it, pos);\n\treturn it;\n}\n\nbool text_iterator_next(Iterator *it) {\n\tsize_t rem = it->end - it->text;\n\treturn iterator_init(it, it->pos+rem, it->piece ? it->piece->next : NULL, 0);\n}\n\nbool text_iterator_prev(Iterator *it) {\n\tsize_t off = it->text - it->start;\n\tsize_t len = it->piece && it->piece->prev ? it->piece->prev->len : 0;\n\treturn iterator_init(it, it->pos-off, it->piece ? it->piece->prev : NULL, len);\n}\n\nconst Text *text_iterator_text(const Iterator *it) {\n\treturn it->piece ? it->piece->text : NULL;\n}\n\nbool text_iterator_valid(const Iterator *it) {\n\t/* filter out sentinel nodes */\n\treturn it->piece && it->piece->text;\n}\n\nbool text_iterator_has_next(const Iterator *it) {\n\treturn it->piece && it->piece->next;\n}\n\nbool text_iterator_has_prev(const Iterator *it) {\n\treturn it->piece && it->piece->prev;\n}\n\nsize_t text_size(const Text *txt) {\n\treturn txt->size;\n}\n\n/* count the number of new lines '\\n' in range [pos, pos+len) */\nstatic size_t lines_count(Text *txt, size_t pos, size_t len) {\n\tsize_t lines = 0;\n\tfor (Iterator it = text_iterator_get(txt, pos);\n\t     text_iterator_valid(&it);\n\t     text_iterator_next(&it)) {\n\t\tconst char *start = it.text;\n\t\twhile (len > 0 && start < it.end) {\n\t\t\tsize_t n = MIN(len, (size_t)(it.end - start));\n\t\t\tconst char *end = memchr(start, '\\n', n);\n\t\t\tif (!end) {\n\t\t\t\tlen -= n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlines++;\n\t\t\tlen -= end - start + 1;\n\t\t\tstart = end + 1;\n\t\t}\n\n\t\tif (len == 0)\n\t\t\tbreak;\n\t}\n\treturn lines;\n}\n\n/* skip n lines forward and return position afterwards */\nstatic size_t lines_skip_forward(Text *txt, size_t pos, size_t lines, size_t *lines_skipped) {\n\tsize_t lines_old = lines;\n\tfor (Iterator it = text_iterator_get(txt, pos);\n\t     text_iterator_valid(&it);\n\t     text_iterator_next(&it)) {\n\t\tconst char *start = it.text;\n\t\twhile (lines > 0 && start < it.end) {\n\t\t\tsize_t n = it.end - start;\n\t\t\tconst char *end = memchr(start, '\\n', n);\n\t\t\tif (!end) {\n\t\t\t\tpos += n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos += end - start + 1;\n\t\t\tstart = end + 1;\n\t\t\tlines--;\n\t\t}\n\n\t\tif (lines == 0)\n\t\t\tbreak;\n\t}\n\tif (lines_skipped)\n\t\t*lines_skipped = lines_old - lines;\n\treturn pos;\n}\n\nstatic void lineno_cache_invalidate(LineCache *cache) {\n\tcache->pos = 0;\n\tcache->lineno = 1;\n}\n\nsize_t text_pos_by_lineno(Text *txt, size_t lineno) {\n\tsize_t lines_skipped;\n\tLineCache *cache = &txt->lines;\n\tif (lineno <= 1)\n\t\treturn 0;\n\tif (lineno > cache->lineno) {\n\t\tcache->pos = lines_skip_forward(txt, cache->pos, lineno - cache->lineno, &lines_skipped);\n\t\tcache->lineno += lines_skipped;\n\t} else if (lineno < cache->lineno) {\n\t#if 0\n\t\t// TODO does it make sense to scan memory backwards here?\n\t\tsize_t diff = cache->lineno - lineno;\n\t\tif (diff < lineno) {\n\t\t\tlines_skip_backward(txt, cache->pos, diff);\n\t\t} else\n\t#endif\n\t\tcache->pos = lines_skip_forward(txt, 0, lineno - 1, &lines_skipped);\n\t\tcache->lineno = lines_skipped + 1;\n\t}\n\treturn cache->lineno == lineno ? cache->pos : EPOS;\n}\n\nsize_t text_lineno_by_pos(Text *txt, size_t pos) {\n\tLineCache *cache = &txt->lines;\n\tif (pos > txt->size)\n\t\tpos = txt->size;\n\tif (pos < cache->pos) {\n\t\tsize_t diff = cache->pos - pos;\n\t\tif (diff < pos)\n\t\t\tcache->lineno -= lines_count(txt, pos, diff);\n\t\telse\n\t\t\tcache->lineno = lines_count(txt, 0, pos) + 1;\n\t} else if (pos > cache->pos) {\n\t\tcache->lineno += lines_count(txt, cache->pos, pos - cache->pos);\n\t}\n\tcache->pos = text_line_begin(txt, pos);\n\treturn cache->lineno;\n}\n\nMark text_mark_set(Text *txt, size_t pos) {\n\tif (pos == txt->size)\n\t\treturn (Mark)&txt->end;\n\tLocation loc = piece_get_extern(txt, pos);\n\tif (!loc.piece)\n\t\treturn EMARK;\n\treturn (Mark)(loc.piece->data + loc.off);\n}\n\nsize_t text_mark_get(const Text *txt, Mark mark) {\n\tsize_t cur = 0;\n\n\tif (mark == EMARK)\n\t\treturn EPOS;\n\tif (mark == (Mark)&txt->end)\n\t\treturn txt->size;\n\n\tfor (Piece *p = txt->begin.next; p->next; p = p->next) {\n\t\tMark start = (Mark)(p->data);\n\t\tMark end = start + p->len;\n\t\tif (start <= mark && mark < end)\n\t\t\treturn cur + (mark - start);\n\t\tcur += p->len;\n\t}\n\n\treturn EPOS;\n}\n"
        },
        {
          "name": "text.h",
          "type": "blob",
          "size": 11.921875,
          "content": "#ifndef TEXT_H\n#define TEXT_H\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <time.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n/** A mark. */\ntypedef uintptr_t Mark;\n\n/** An invalid mark, lookup of which will yield ``EPOS``. */\n#define EMARK ((Mark)0)\n/** An invalid position. */\n#define EPOS ((size_t)-1)\n\n/** A range. */\ntypedef struct {\n\tsize_t start;  /**< Absolute byte position. */\n\tsize_t end;    /**< Absolute byte position. */\n} Filerange;\n\n/**\n * Text object storing the buffer content being edited.\n */\ntypedef struct Text Text;\ntypedef struct Piece Piece;\ntypedef struct TextSave TextSave;\n\n/** A contiguous part of the text. */\ntypedef struct {\n\tconst char *data; /**< Content, might not be NUL-terminated. */\n\tsize_t len;       /**< Length in bytes. */\n} TextString;\n\n/**\n * Iterator used to navigate the buffer content.\n *\n * Captures the position within a Piece.\n *\n * @rst\n * .. warning:: Any change to the Text will invalidate the iterator state.\n * .. note:: Should be treated as an opaque type.\n * @endrst\n */\ntypedef struct {\n\tconst char *start;  /**< Start of the piece data. */\n\tconst char *end;    /**< End of piece data. Addressable range is ``[start, end)``. */\n\tconst char *text;   /**< Current position within piece. Invariant ``start <= text < end`` holds. */\n\tconst Piece *piece; /**< Internal state of current piece. */\n\tsize_t pos;         /**< Absolute position in bytes from start of buffer. */\n} Iterator;\n\n/**\n * @defgroup load\n * @{\n */\n/**\n * Method used to load existing file content.\n */\nenum TextLoadMethod {\n\t/** Automatically chose best option. */\n\tTEXT_LOAD_AUTO,\n\t/**\n\t * Read file content and copy it to an in-memory buffer.\n\t * Subsequent changes to the underlying file will have no\n\t * effect on this text instance.\n\t *\n\t * @rst\n\t * .. note:: Load time is linear in the file size.\n\t * @endrst\n\t */\n\tTEXT_LOAD_READ,\n\t/**\n\t * Memory map the file from disk. Use file system / virtual memory\n\t * subsystem as a caching layer.\n\t * @rst\n\t * .. note:: Load time is (almost) independent of the file size.\n\t * .. warning:: Inplace modifications of the underlying file\n\t *              will be reflected in the current text content.\n\t *              In particular, truncation will raise ``SIGBUS``\n\t *              and result in data loss.\n\t * @endrst\n\t */\n\tTEXT_LOAD_MMAP,\n};\n/**\n * Create a text instance populated with the given file content.\n *\n * @rst\n * .. note:: Equivalent to ``text_load_method(filename, TEXT_LOAD_AUTO)``.\n * @endrst\n */\nText *text_load(const char *filename);\nText *text_loadat(int dirfd, const char *filename);\n/**\n * Create a text instance populated with the given file content.\n *\n * @param filename The name of the file to load, if ``NULL`` an empty text is created.\n * @param method How the file content should be loaded.\n * @return The new Text object or ``NULL`` in case of an error.\n * @rst\n * .. note:: When attempting to load a non-regular file, ``errno`` will be set to:\n *\n *    - ``EISDIR`` for a directory.\n *    - ``ENOTSUP`` otherwise.\n * @endrst\n */\nText *text_load_method(const char *filename, enum TextLoadMethod);\nText *text_loadat_method(int dirfd, const char *filename, enum TextLoadMethod);\n/** Release all resources associated with this text instance. */\nvoid text_free(Text*);\n/**\n * @}\n * @defgroup state\n * @{\n */\n/** Return the size in bytes of the whole text. */\nsize_t text_size(const Text*);\n/**\n * Get file information at time of load or last save, whichever happened more\n * recently.\n * @rst\n * .. note:: If an empty text instance was created using ``text_load(NULL)``\n *           and it has not yet been saved, an all zero ``struct stat`` will\n *           be returned.\n * @endrst\n * @return See ``stat(2)`` for details.\n */\nstruct stat text_stat(const Text*);\n/** Query whether the text contains any unsaved modifications. */\nbool text_modified(const Text*);\n/**\n * @}\n * @defgroup modify\n * @{\n */\n/**\n * Insert data at the given byte position.\n *\n * @param pos The absolute byte position.\n * @param data The data to insert.\n * @param len The length of the data in bytes.\n * @return Whether the insertion succeeded.\n */\nbool text_insert(Text*, size_t pos, const char *data, size_t len);\n/**\n * Delete data at given byte position.\n *\n * @param pos The absolute byte position.\n * @param len The number of bytes to delete, starting from ``pos``.\n * @return Whether the deletion succeeded.\n */\nbool text_delete(Text*, size_t pos, size_t len);\nbool text_delete_range(Text*, const Filerange*);\nbool text_printf(Text*, size_t pos, const char *format, ...) __attribute__((format(printf, 3, 4)));\nbool text_appendf(Text*, const char *format, ...) __attribute__((format(printf, 2, 3)));\n/**\n * @}\n * @defgroup history\n * @{\n */\n/**\n * Create a text snapshot, that is a vertex in the history graph.\n */\nbool text_snapshot(Text*);\n/**\n * Revert to previous snapshot along the main branch.\n * @rst\n * .. note:: Takes an implicit snapshot.\n * @endrst\n * @return The position of the first change or ``EPOS``, if already at the\n *         oldest state i.e. there was nothing to undo.\n */\nsize_t text_undo(Text*);\n/**\n * Reapply an older change along the main branch.\n * @rst\n * .. note:: Takes an implicit snapshot.\n * @endrst\n * @return The position of the first change or ``EPOS``, if already at the\n *         newest state i.e. there was nothing to redo.\n */\nsize_t text_redo(Text*);\nsize_t text_earlier(Text*);\nsize_t text_later(Text*);\n/**\n * Restore the text to the state closest to the time given\n */\nsize_t text_restore(Text*, time_t);\n/**\n * Get creation time of current state.\n * @rst\n * .. note:: TODO: This is currently not the same as the time of the last snapshot.\n * @endrst\n */\ntime_t text_state(const Text*);\n/**\n * @}\n * @defgroup lines\n * @{\n */\nsize_t text_pos_by_lineno(Text*, size_t lineno);\nsize_t text_lineno_by_pos(Text*, size_t pos);\n\n/**\n * @}\n * @defgroup access\n * @{\n */\n/**\n * Get byte stored at ``pos``.\n * @param pos The absolute position.\n * @param byte Destination address to store the byte.\n * @return Whether ``pos`` was valid and ``byte`` updated accordingly.\n * @rst\n * .. note:: Unlike :c:func:`text_iterator_byte_get()` this function does not\n *           return an artificial NUL byte at EOF.\n * @endrst\n */\nbool text_byte_get(const Text*, size_t pos, char *byte);\n/**\n * Store at most ``len`` bytes starting from ``pos`` into ``buf``.\n * @param pos The absolute starting position.\n * @param len The length in bytes.\n * @param buf The destination buffer.\n * @return The number of bytes (``<= len``) stored at ``buf``.\n * @rst\n * .. warning:: ``buf`` will not be NUL terminated.\n * @endrst\n */\nsize_t text_bytes_get(const Text*, size_t pos, size_t len, char *buf);\n/**\n * Fetch text range into newly allocate memory region.\n * @param pos The absolute starting position.\n * @param len The length in bytes.\n * @return A contiguous NUL terminated buffer holding the requested range, or\n *         ``NULL`` in error case.\n * @rst\n * .. warning:: The returned pointer must be freed by the caller.\n * @endrst\n */\nchar *text_bytes_alloc0(const Text*, size_t pos, size_t len);\n/**\n * @}\n * @defgroup iterator\n * @{\n */\nIterator text_iterator_get(const Text*, size_t pos);\nbool text_iterator_init(const Text*, Iterator*, size_t pos);\nconst Text *text_iterator_text(const Iterator*);\nbool text_iterator_valid(const Iterator*);\nbool text_iterator_has_next(const Iterator*);\nbool text_iterator_has_prev(const Iterator*);\nbool text_iterator_next(Iterator*);\nbool text_iterator_prev(Iterator*);\n/**\n * @}\n * @defgroup iterator_byte\n * @{\n */\nbool text_iterator_byte_get(const Iterator*, char *b);\nbool text_iterator_byte_prev(Iterator*, char *b);\nbool text_iterator_byte_next(Iterator*, char *b);\nbool text_iterator_byte_find_prev(Iterator*, char b);\nbool text_iterator_byte_find_next(Iterator*, char b);\n/**\n * @}\n * @defgroup iterator_code\n * @{\n */\nbool text_iterator_codepoint_next(Iterator *it, char *c);\nbool text_iterator_codepoint_prev(Iterator *it, char *c);\n/**\n * @}\n * @defgroup iterator_char\n * @{\n */\nbool text_iterator_char_next(Iterator*, char *c);\nbool text_iterator_char_prev(Iterator*, char *c);\n/**\n * @}\n * @defgroup mark\n * @{\n */\n/**\n * Set a mark.\n * @rst\n * .. note:: Setting a mark to ``text_size`` will always return the\n *           current text size upon lookup.\n * @endrst\n * @param pos The position at which to store the mark.\n * @return The mark or ``EMARK`` if an invalid position was given.\n */\nMark text_mark_set(Text*, size_t pos);\n/**\n * Lookup a mark.\n * @param mark The mark to look up.\n * @return The byte position or ``EPOS`` for an invalid mark.\n */\nsize_t text_mark_get(const Text*, Mark);\n/**\n * @}\n * @defgroup save\n * @{\n */\n/**\n * Method used to save the text.\n */\nenum TextSaveMethod {\n\t/** Automatically chose best option. */\n\tTEXT_SAVE_AUTO,\n\t/**\n\t * Save file atomically using ``rename(2)``.\n\t *\n\t * Creates a temporary file, restores all important meta data,\n\t * before moving it atomically to its final (possibly already\n\t * existing) destination using ``rename(2)``. For new files,\n\t * permissions are set to ``0666 & ~umask``.\n\t *\n\t * @rst\n\t * .. warning:: This approach does not work if:\n\t *\n\t *   - The file is a symbolic link.\n\t *   - The file is a hard link.\n\t *   - File ownership can not be preserved.\n\t *   - File group can not be preserved.\n\t *   - Directory permissions do not allow creation of a new file.\n\t *   - POSIX ACL can not be preserved (if enabled).\n\t *   - SELinux security context can not be preserved (if enabled).\n\t * @endrst\n\t */\n\tTEXT_SAVE_ATOMIC,\n\t/**\n\t * Overwrite file in place.\n\t * @rst\n\t * .. warning:: I/O failure might cause data loss.\n\t * @endrst\n\t */\n\tTEXT_SAVE_INPLACE,\n};\n\n/**\n * Save the whole text to the given file name.\n *\n * @rst\n * .. note:: Equivalent to ``text_save_method(filename, TEXT_SAVE_AUTO)``.\n * @endrst\n */\nbool text_save(Text*, const char *filename);\nbool text_saveat(Text*, int dirfd, const char *filename);\n/**\n * Save the whole text to the given file name, using the specified method.\n */\nbool text_save_method(Text*, const char *filename, enum TextSaveMethod);\nbool text_saveat_method(Text*, int dirfd, const char *filename, enum TextSaveMethod);\n\n/**\n * Setup a sequence of write operations.\n *\n * The returned ``TextSave`` pointer can be used to write multiple, possibly\n * non-contiguous, file ranges.\n * @rst\n * .. warning:: For every call to ``text_save_begin`` there must be exactly\n *              one matching call to either ``text_save_commit`` or\n *              ``text_save_cancel`` to release the underlying resources.\n * @endrst\n */\nTextSave *text_save_begin(Text*, int dirfd, const char *filename, enum TextSaveMethod);\n/**\n * Write file range.\n * @return The number of bytes written or ``-1`` in case of an error.\n */\nssize_t text_save_write_range(TextSave*, const Filerange*);\n/**\n * Commit changes to disk.\n * @return Whether changes have been saved.\n * @rst\n * .. note:: Releases the underlying resources and frees the given ``TextSave``\n *           pointer which must no longer be used.\n * @endrst\n */\nbool text_save_commit(TextSave*);\n/**\n * Abort a save operation.\n * @rst\n * .. note:: Does not guarantee to undo the previous writes (they might have been\n *           performed in-place). However, it releases the underlying resources and\n *           frees the given ``TextSave`` pointer which must no longer be used.\n * @endrst\n */\nvoid text_save_cancel(TextSave*);\n/**\n * Write whole text content to file descriptor.\n * @return The number of bytes written or ``-1`` in case of an error.\n */\nssize_t text_write(const Text*, int fd);\n/**\n * Write file range to file descriptor.\n * @return The number of bytes written or ``-1`` in case of an error.\n */\nssize_t text_write_range(const Text*, const Filerange*, int fd);\n/**\n * @}\n * @defgroup misc\n * @{\n */\n/**\n * Check whether ``ptr`` is part of a memory mapped region associated with\n * this text instance.\n */\nbool text_mmaped(const Text*, const char *ptr);\n\n/**\n * Write complete buffer to file descriptor.\n * @return The number of bytes written or ``-1`` in case of an error.\n */\nssize_t write_all(int fd, const char *buf, size_t count);\n/** @} */\n\n#endif\n"
        },
        {
          "name": "ui-terminal-curses.c",
          "type": "blob",
          "size": 7.5234375,
          "content": "/* This file is included from ui-terminal.c */\n#include <stdio.h>\n#include <curses.h>\n\n#define UI_TERMKEY_FLAGS (TERMKEY_FLAG_UTF8|TERMKEY_FLAG_NOTERMIOS)\n\n#define CELL_COLOR_BLACK   COLOR_BLACK\n#define CELL_COLOR_RED     COLOR_RED\n#define CELL_COLOR_GREEN   COLOR_GREEN\n#define CELL_COLOR_YELLOW  COLOR_YELLOW\n#define CELL_COLOR_BLUE    COLOR_BLUE\n#define CELL_COLOR_MAGENTA COLOR_MAGENTA\n#define CELL_COLOR_CYAN    COLOR_CYAN\n#define CELL_COLOR_WHITE   COLOR_WHITE\n#define CELL_COLOR_DEFAULT (-1)\n\n#ifndef A_ITALIC\n#define A_ITALIC A_NORMAL\n#endif\n#define CELL_ATTR_NORMAL    A_NORMAL\n#define CELL_ATTR_UNDERLINE A_UNDERLINE\n#define CELL_ATTR_REVERSE   A_REVERSE\n#define CELL_ATTR_BLINK     A_BLINK\n#define CELL_ATTR_BOLD      A_BOLD\n#define CELL_ATTR_ITALIC    A_ITALIC\n#define CELL_ATTR_DIM       A_DIM\n\n#ifdef NCURSES_VERSION\n# ifndef NCURSES_EXT_COLORS\n#  define NCURSES_EXT_COLORS 0\n# endif\n# if !NCURSES_EXT_COLORS\n#  define MAX_COLOR_PAIRS MIN(COLOR_PAIRS, 256)\n# endif\n#endif\n#ifndef MAX_COLOR_PAIRS\n# define MAX_COLOR_PAIRS COLOR_PAIRS\n#endif\n\n#define MAX_COLOR_CLOBBER 240\n\nstatic int change_colors = -1;\nstatic short default_fg = -1;\nstatic short default_bg = -1;\n\nstatic inline bool cell_color_equal(CellColor c1, CellColor c2) {\n\treturn c1 == c2;\n}\n\n/* Calculate r,g,b components of one of the standard upper 240 colors */\nstatic void get_6cube_rgb(unsigned int n, int *r, int *g, int *b)\n{\n\tif (n < 16) {\n\t\treturn;\n\t} else if (n < 232) {\n\t\tn -= 16;\n\t\t*r = (n / 36) ? (n / 36) * 40 + 55 : 0;\n\t\t*g = ((n / 6) % 6) ? ((n / 6) % 6) * 40 + 55 : 0;\n\t\t*b = (n % 6) ? (n % 6) * 40 + 55 : 0;\n\t} else if (n < 256) {\n\t\tn -= 232;\n\t\t*r = n * 10 + 8;\n\t\t*g = n * 10 + 8;\n\t\t*b = n * 10 + 8;\n\t}\n}\n\n/* Reset color palette to default values using OSC 104 */\nstatic void undo_palette(void)\n{\n\tfputs(\"\\033]104;\\a\", stderr);\n\tfflush(stderr);\n}\n\n/* Work out the nearest color from the 256 color set, or perhaps exactly. */\nstatic CellColor color_rgb(Ui *ui, uint8_t r, uint8_t g, uint8_t b)\n{\n\tstatic short color_clobber_idx = 0;\n\tstatic uint32_t clobbering_colors[MAX_COLOR_CLOBBER];\n\n\tif (change_colors == -1)\n\t\tchange_colors = ui->vis->change_colors && can_change_color() && COLORS >= 256;\n\tif (change_colors) {\n\t\tuint32_t hexrep = (r << 16) | (g << 8) | b;\n\t\tfor (short i = 0; i < MAX_COLOR_CLOBBER; ++i) {\n\t\t\tif (clobbering_colors[i] == hexrep)\n\t\t\t\treturn i + 16;\n\t\t\telse if (!clobbering_colors[i])\n\t\t\t\tbreak;\n\t\t}\n\n\t\tshort i = color_clobber_idx;\n\t\tclobbering_colors[i] = hexrep;\n\t\tinit_color(i + 16, (r * 1000) / 0xff, (g * 1000) / 0xff,\n\t\t           (b * 1000) / 0xff);\n\n\t\t/* in the unlikely case a user requests this many colors, reuse old slots */\n\t\tif (++color_clobber_idx >= MAX_COLOR_CLOBBER)\n\t\t\tcolor_clobber_idx = 0;\n\n\t\treturn i + 16;\n\t}\n\n\tstatic const unsigned char color_256_to_16[256] = {\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n\t\t 0,  4,  4,  4, 12, 12,  2,  6,  4,  4, 12, 12,  2,  2,  6,  4,\n\t\t12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10,\n\t\t10, 10, 10, 14,  1,  5,  4,  4, 12, 12,  3,  8,  4,  4, 12, 12,\n\t\t 2,  2,  6,  4, 12, 12,  2,  2,  2,  6, 12, 12, 10, 10, 10, 10,\n\t\t14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  5,  4, 12, 12,  1,  1,\n\t\t 5,  4, 12, 12,  3,  3,  8,  4, 12, 12,  2,  2,  2,  6, 12, 12,\n\t\t10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,  1,  1,  1,  5,\n\t\t12, 12,  1,  1,  1,  5, 12, 12,  1,  1,  1,  5, 12, 12,  3,  3,\n\t\t 3,  7, 12, 12, 10, 10, 10, 10, 14, 12, 10, 10, 10, 10, 10, 14,\n\t\t 9,  9,  9,  9, 13, 12,  9,  9,  9,  9, 13, 12,  9,  9,  9,  9,\n\t\t13, 12,  9,  9,  9,  9, 13, 12, 11, 11, 11, 11,  7, 12, 10, 10,\n\t\t10, 10, 10, 14,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,\n\t\t 9,  9,  9,  9,  9, 13,  9,  9,  9,  9,  9, 13,  9,  9,  9,  9,\n\t\t 9, 13, 11, 11, 11, 11, 11, 15,  0,  0,  0,  0,  0,  0,  8,  8,\n\t\t 8,  8,  8,  8,  7,  7,  7,  7,  7,  7, 15, 15, 15, 15, 15, 15\n\t};\n\n\tint i = 0;\n\tif ((!r || (r - 55) % 40 == 0) &&\n\t    (!g || (g - 55) % 40 == 0) &&\n\t    (!b || (b - 55) % 40 == 0)) {\n\t\ti = 16;\n\t\ti += r ? ((r - 55) / 40) * 36 : 0;\n\t\ti += g ? ((g - 55) / 40) * 6 : 0;\n\t\ti += g ? ((b - 55) / 40) : 0;\n\t} else if (r == g && g == b && (r - 8) % 10 == 0 && r < 239) {\n\t\ti = 232 + ((r - 8) / 10);\n\t} else {\n\t\tunsigned lowest = UINT_MAX;\n\t\tfor (int j = 16; j < 256; ++j) {\n\t\t\tint jr = 0, jg = 0, jb = 0;\n\t\t\tget_6cube_rgb(j, &jr, &jg, &jb);\n\t\t\tint dr = jr - r;\n\t\t\tint dg = jg - g;\n\t\t\tint db = jb - b;\n\t\t\tunsigned int distance = dr * dr + dg * dg + db * db;\n\t\t\tif (distance < lowest) {\n\t\t\t\tlowest = distance;\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (COLORS <= 16)\n\t\treturn color_256_to_16[i];\n\treturn i;\n}\n\nstatic CellColor color_terminal(Ui *ui, uint8_t index) {\n\treturn index;\n}\n\nstatic inline unsigned int color_pair_hash(short fg, short bg) {\n\tif (fg == CELL_COLOR_DEFAULT)\n\t\tfg = COLORS;\n\tif (bg == CELL_COLOR_DEFAULT)\n\t\tbg = COLORS + 1;\n\treturn fg * (COLORS + 2) + bg;\n}\n\nstatic short color_pair_get(short fg, short bg) {\n\tstatic bool has_default_colors;\n\tstatic short *color2palette;\n\tstatic short color_pairs_max, color_pair_current;\n\n\tif (!color2palette) {\n\t\tpair_content(0, &default_fg, &default_bg);\n\t\thas_default_colors = (use_default_colors() == OK);\n\t\tcolor_pairs_max = MIN(MAX_COLOR_PAIRS, SHRT_MAX);\n\t\tif (COLORS)\n\t\t\tcolor2palette = calloc((COLORS + 2) * (COLORS + 2), sizeof(short));\n\t}\n\n\tif (fg >= COLORS)\n\t\tfg = default_fg;\n\tif (bg >= COLORS)\n\t\tbg = default_bg;\n\n\tif (!has_default_colors) {\n\t\tif (fg == -1)\n\t\t\tfg = default_fg;\n\t\tif (bg == -1)\n\t\t\tbg = default_bg;\n\t}\n\n\tif (!color2palette)\n\t\treturn 0;\n\n\tunsigned int index = color_pair_hash(fg, bg);\n\tif (color2palette[index] == 0) {\n\t\tshort oldfg, oldbg;\n\t\tif (++color_pair_current >= color_pairs_max)\n\t\t\tcolor_pair_current = 1;\n\t\tpair_content(color_pair_current, &oldfg, &oldbg);\n\t\tunsigned int old_index = color_pair_hash(oldfg, oldbg);\n\t\tif (init_pair(color_pair_current, fg, bg) == OK) {\n\t\t\tcolor2palette[old_index] = 0;\n\t\t\tcolor2palette[index] = color_pair_current;\n\t\t}\n\t}\n\n\treturn color2palette[index];\n}\n\nstatic inline attr_t style_to_attr(CellStyle *style) {\n\treturn style->attr | COLOR_PAIR(color_pair_get(style->fg, style->bg));\n}\n\nstatic void ui_term_backend_blit(Ui *tui) {\n\tint w = tui->width, h = tui->height;\n\tCell *cell = tui->cells;\n\tfor (int y = 0; y < h; y++) {\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tattrset(style_to_attr(&cell->style));\n\t\t\tmvaddstr(y, x, cell->data);\n\t\t\tcell++;\n\t\t}\n\t}\n\twnoutrefresh(stdscr);\n\tif (tui->doupdate)\n\t\tdoupdate();\n}\n\nstatic void ui_term_backend_clear(Ui *tui) {\n\tclear();\n}\n\nstatic bool ui_term_backend_resize(Ui *tui, int width, int height) {\n\treturn resizeterm(height, width) == OK &&\n\t       wresize(stdscr, height, width) == OK;\n}\n\nstatic void ui_term_backend_save(Ui *tui, bool fscr) {\n\tcurs_set(1);\n\tif (fscr) {\n\t\tdef_prog_mode();\n\t\tendwin();\n\t} else {\n\t\treset_shell_mode();\n\t}\n}\n\nstatic void ui_term_backend_restore(Ui *tui) {\n\treset_prog_mode();\n\twclear(stdscr);\n\tcurs_set(0);\n}\n\nint ui_terminal_colors(void) {\n\treturn COLORS;\n}\n\nstatic bool ui_term_backend_init(Ui *tui, char *term) {\n\tif (!newterm(term, stderr, stdin)) {\n\t\tsnprintf(tui->info, sizeof(tui->info), \"Warning: unknown term `%s'\", term);\n\t\tif (!newterm(strstr(term, \"-256color\") ? \"xterm-256color\" : \"xterm\", stderr, stdin))\n\t\t\treturn false;\n\t}\n\tstart_color();\n\tuse_default_colors();\n\tcbreak();\n\tnoecho();\n\tnonl();\n\tkeypad(stdscr, TRUE);\n\tmeta(stdscr, TRUE);\n\tcurs_set(0);\n\treturn true;\n}\n\nstatic bool ui_backend_init(Ui *ui) {\n\treturn true;\n}\n\nvoid ui_terminal_resume(Ui *term) { }\n\nstatic void ui_term_backend_suspend(Ui *term) {\n\tif (change_colors == 1)\n\t\tundo_palette();\n}\n\nstatic void ui_term_backend_free(Ui *term) {\n\tui_term_backend_suspend(term);\n\tendwin();\n}\n\nstatic bool is_default_color(CellColor c) {\n\treturn c == CELL_COLOR_DEFAULT;\n}\n"
        },
        {
          "name": "ui-terminal-vt100.c",
          "type": "blob",
          "size": 6.158203125,
          "content": "/* This file is included from ui-terminal.c\n *\n * The goal is *not* to reimplement curses. Instead we aim to provide the\n * simplest possible drawing backend for VT-100 compatible terminals.\n * This is useful for debugging and fuzzing purposes as well as for environments\n * with no curses support.\n *\n * Currently no attempt is made to optimize terminal output. The amount of\n * flickering will depend on the smartness of your terminal emulator.\n *\n * The following terminal escape sequences are used:\n *\n *  - CSI ? 1049 h             Save cursor and use Alternate Screen Buffer (DECSET)\n *  - CSI ? 1049 l             Use Normal Screen Buffer and restore cursor (DECRST)\n *  - CSI ? 25 l               Hide Cursor (DECTCEM)\n *  - CSI ? 25 h               Show Cursor (DECTCEM)\n *  - CSI 2 J                  Erase in Display (ED)\n *  - CSI row ; column H       Cursor Position (CUP)\n *  - CSI ... m                Character Attributes (SGR)\n *    - CSI 0 m                     Normal\n *    - CSI 1 m                     Bold\n *    - CSI 3 m                     Italicized\n *    - CSI 4 m                     Underlined\n *    - CSI 5 m                     Blink\n *    - CSI 7 m                     Inverse\n *    - CSI 22 m                    Normal (not bold)\n *    - CSI 23 m                    Not italicized\n *    - CSI 24 m                    Not underlined\n *    - CSI 25 m                    Not blinking\n *    - CSI 27 m                    Not inverse\n *    - CSI 30-37,39                Set foreground color\n *    - CSI 38 ; 2 ; R ; G ; B m    Set RGB foreground color\n *    - CSI 40-47,49                Set background color\n *    - CSI 48 ; 2 ; R ; G ; B m    Set RGB background color\n *\n * See http://invisible-island.net/xterm/ctlseqs/ctlseqs.txt\n * for further information.\n */\n#include \"buffer.h\"\n\n#define UI_TERMKEY_FLAGS TERMKEY_FLAG_UTF8\n\n#define CELL_COLOR_BLACK   { .index = 0 }\n#define CELL_COLOR_RED     { .index = 1 }\n#define CELL_COLOR_GREEN   { .index = 2 }\n#define CELL_COLOR_YELLOW  { .index = 3 }\n#define CELL_COLOR_BLUE    { .index = 4 }\n#define CELL_COLOR_MAGENTA { .index = 5 }\n#define CELL_COLOR_CYAN    { .index = 6 }\n#define CELL_COLOR_WHITE   { .index = 7 }\n#define CELL_COLOR_DEFAULT { .index = 9 }\n\n#define CELL_ATTR_NORMAL    0\n#define CELL_ATTR_UNDERLINE (1 << 0)\n#define CELL_ATTR_REVERSE   (1 << 1)\n#define CELL_ATTR_BLINK     (1 << 2)\n#define CELL_ATTR_BOLD      (1 << 3)\n#define CELL_ATTR_ITALIC    (1 << 4)\n#define CELL_ATTR_DIM       (1 << 5)\n\nstatic inline bool cell_color_equal(CellColor c1, CellColor c2) {\n\tif (c1.index != (uint8_t)-1 || c2.index != (uint8_t)-1)\n\t\treturn c1.index == c2.index;\n\treturn c1.r == c2.r && c1.g == c2.g && c1.b == c2.b;\n}\n\nstatic CellColor color_rgb(Ui *ui, uint8_t r, uint8_t g, uint8_t b) {\n\treturn (CellColor){ .r = r, .g = g, .b = b, .index = (uint8_t)-1 };\n}\n\nstatic CellColor color_terminal(Ui *ui, uint8_t index) {\n\treturn (CellColor){ .r = 0, .g = 0, .b = 0, .index = index };\n}\n\n\nstatic void output(const char *data, size_t len) {\n\twrite(STDERR_FILENO, data, len);\n}\n\nstatic void output_literal(const char *data) {\n\toutput(data, strlen(data));\n}\n\nstatic void screen_alternate(bool alternate) {\n\toutput_literal(alternate ? \"\\x1b[?1049h\" : \"\\x1b[0m\" \"\\x1b[?1049l\" \"\\x1b[0m\" );\n}\n\nstatic void cursor_visible(bool visible) {\n\toutput_literal(visible ? \"\\x1b[?25h\" : \"\\x1b[?25l\");\n}\n\nstatic void ui_term_backend_blit(Ui *tui) {\n\tBuffer *buf = tui->ctx;\n\tbuf->len    = 0;\n\tCellAttr attr = CELL_ATTR_NORMAL;\n\tCellColor fg = CELL_COLOR_DEFAULT, bg = CELL_COLOR_DEFAULT;\n\tint w = tui->width, h = tui->height;\n\tCell *cell = tui->cells;\n\t/* reposition cursor, erase screen, reset attributes */\n\tbuffer_append0(buf, \"\\x1b[H\" \"\\x1b[J\" \"\\x1b[0m\");\n\tfor (int y = 0; y < h; y++) {\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tCellStyle *style = &cell->style;\n\t\t\tif (style->attr != attr) {\n\n\t\t\t\tstatic const struct {\n\t\t\t\t\tCellAttr attr;\n\t\t\t\t\tchar on[4], off[4];\n\t\t\t\t} cell_attrs[] = {\n\t\t\t\t\t{ CELL_ATTR_BOLD, \"1\", \"22\" },\n\t\t\t\t\t{ CELL_ATTR_DIM, \"2\", \"22\" },\n\t\t\t\t\t{ CELL_ATTR_ITALIC, \"3\", \"23\" },\n\t\t\t\t\t{ CELL_ATTR_UNDERLINE, \"4\", \"24\" },\n\t\t\t\t\t{ CELL_ATTR_BLINK, \"5\", \"25\" },\n\t\t\t\t\t{ CELL_ATTR_REVERSE, \"7\", \"27\" },\n\t\t\t\t};\n\n\t\t\t\tfor (size_t i = 0; i < LENGTH(cell_attrs); i++) {\n\t\t\t\t\tCellAttr a = cell_attrs[i].attr;\n\t\t\t\t\tif ((style->attr & a) == (attr & a))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tbuffer_appendf(buf, \"\\x1b[%sm\",\n\t\t\t\t\t               style->attr & a ?\n\t\t\t\t\t               cell_attrs[i].on :\n\t\t\t\t\t               cell_attrs[i].off);\n\t\t\t\t}\n\n\t\t\t\tattr = style->attr;\n\t\t\t}\n\n\t\t\tif (!cell_color_equal(fg, style->fg)) {\n\t\t\t\tfg = style->fg;\n\t\t\t\tif (fg.index != (uint8_t)-1) {\n\t\t\t\t\tbuffer_appendf(buf, \"\\x1b[%dm\", 30 + fg.index);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer_appendf(buf, \"\\x1b[38;2;%d;%d;%dm\",\n\t\t\t\t\t               fg.r, fg.g, fg.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!cell_color_equal(bg, style->bg)) {\n\t\t\t\tbg = style->bg;\n\t\t\t\tif (bg.index != (uint8_t)-1) {\n\t\t\t\t\tbuffer_appendf(buf, \"\\x1b[%dm\", 40 + bg.index);\n\t\t\t\t} else {\n\t\t\t\t\tbuffer_appendf(buf, \"\\x1b[48;2;%d;%d;%dm\",\n\t\t\t\t\t               bg.r, bg.g, bg.b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbuffer_append0(buf, cell->data);\n\t\t\tcell++;\n\t\t}\n\t}\n\toutput(buf->data, buffer_length0(buf));\n}\n\nstatic void ui_term_backend_clear(Ui *tui) { }\n\nstatic bool ui_term_backend_resize(Ui *tui, int width, int height) {\n\treturn true;\n}\n\nstatic void ui_term_backend_save(Ui *tui, bool fscr) {\n\tcursor_visible(true);\n}\n\nstatic void ui_term_backend_restore(Ui *tui) {\n\tcursor_visible(false);\n}\n\nint ui_terminal_colors(void) {\n\tchar *term = getenv(\"TERM\");\n\treturn (term && strstr(term, \"-256color\")) ? 256 : 16;\n}\n\nstatic void ui_term_backend_suspend(Ui *tui) {\n\tif (!tui->termkey) return;\n\ttermkey_stop(tui->termkey);\n\tcursor_visible(true);\n\tscreen_alternate(false);\n}\n\nvoid ui_terminal_resume(Ui *tui) {\n\tscreen_alternate(true);\n\tcursor_visible(false);\n\ttermkey_start(tui->termkey);\n}\n\nstatic bool ui_term_backend_init(Ui *tui, char *term) {\n\tui_terminal_resume(tui);\n\treturn true;\n}\n\nstatic bool ui_backend_init(Ui *ui) {\n\tBuffer *buf = calloc(1, sizeof(Buffer));\n\tif (!buf)\n\t\treturn false;\n\tui->ctx = buf;\n\treturn true;\n}\n\nstatic void ui_term_backend_free(Ui *tui) {\n\tBuffer *buf = tui->ctx;\n\tui_term_backend_suspend(tui);\n\tbuffer_release(buf);\n\tfree(buf);\n}\n\nstatic bool is_default_color(CellColor c) {\n\treturn c.index == ((CellColor) CELL_COLOR_DEFAULT).index;\n}\n"
        },
        {
          "name": "ui-terminal.c",
          "type": "blob",
          "size": 16.49609375,
          "content": "#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <limits.h>\n#include <ctype.h>\n#include <locale.h>\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <termios.h>\n#include <errno.h>\n\n#include \"vis.h\"\n#include \"vis-core.h\"\n#include \"text.h\"\n#include \"util.h\"\n#include \"text-util.h\"\n\n#ifndef DEBUG_UI\n#define DEBUG_UI 0\n#endif\n\n#if DEBUG_UI\n#define debug(...) do { printf(__VA_ARGS__); fflush(stdout); } while (0)\n#else\n#define debug(...) do { } while (0)\n#endif\n\n#if CONFIG_CURSES\n#include \"ui-terminal-curses.c\"\n#else\n#include \"ui-terminal-vt100.c\"\n#endif\n\n/* helper macro for handling UiTerm.cells */\n#define CELL_AT_POS(UI, X, Y) (((UI)->cells) + (X) + ((Y) * (UI)->width));\n\n#define CELL_STYLE_DEFAULT (CellStyle){.fg = CELL_COLOR_DEFAULT, .bg = CELL_COLOR_DEFAULT, .attr = CELL_ATTR_NORMAL}\n\nstatic bool is_default_fg(CellColor c) {\n\treturn is_default_color(c);\n}\n\nstatic bool is_default_bg(CellColor c) {\n\treturn is_default_color(c);\n}\n\nvoid ui_die(Ui *tui, const char *msg, va_list ap) {\n\tui_terminal_free(tui);\n\tif (tui->termkey)\n\t\ttermkey_stop(tui->termkey);\n\tvfprintf(stderr, msg, ap);\n\texit(EXIT_FAILURE);\n}\n\nstatic void ui_die_msg(Ui *ui, const char *msg, ...) {\n\tva_list ap;\n\tva_start(ap, msg);\n\tui_die(ui, msg, ap);\n\tva_end(ap);\n}\n\nstatic void ui_window_resize(Win *win, int width, int height) {\n\tdebug(\"ui-win-resize[%s]: %dx%d\\n\", win->file->name ? win->file->name : \"noname\", width, height);\n\tbool status = win->options & UI_OPTION_STATUSBAR;\n\twin->width  = width;\n\twin->height = height;\n\tview_resize(&win->view, width - win->sidebar_width, status ? height - 1 : height);\n}\n\nstatic void ui_window_move(Win *win, int x, int y) {\n\tdebug(\"ui-win-move[%s]: (%d, %d)\\n\", win->file->name ? win->file->name : \"noname\", x, y);\n\twin->x = x;\n\twin->y = y;\n}\n\nstatic bool color_fromstring(Ui *ui, CellColor *color, const char *s)\n{\n\tif (!s)\n\t\treturn false;\n\tif (*s == '#' && strlen(s) == 7) {\n\t\tconst char *cp;\n\t\tunsigned char r, g, b;\n\t\tfor (cp = s + 1; isxdigit((unsigned char)*cp); cp++);\n\t\tif (*cp != '\\0')\n\t\t\treturn false;\n\t\tint n = sscanf(s + 1, \"%2hhx%2hhx%2hhx\", &r, &g, &b);\n\t\tif (n != 3)\n\t\t\treturn false;\n\t\t*color = color_rgb(ui, r, g, b);\n\t\treturn true;\n\t} else if ('0' <= *s && *s <= '9') {\n\t\tint index = atoi(s);\n\t\tif (index <= 0 || index > 255)\n\t\t\treturn false;\n\t\t*color = color_terminal(ui, index);\n\t\treturn true;\n\t}\n\n\tstatic const struct {\n\t\tconst char *name;\n\t\tCellColor color;\n\t} color_names[] = {\n\t\t{ \"black\",   CELL_COLOR_BLACK   },\n\t\t{ \"red\",     CELL_COLOR_RED     },\n\t\t{ \"green\",   CELL_COLOR_GREEN   },\n\t\t{ \"yellow\",  CELL_COLOR_YELLOW  },\n\t\t{ \"blue\",    CELL_COLOR_BLUE    },\n\t\t{ \"magenta\", CELL_COLOR_MAGENTA },\n\t\t{ \"cyan\",    CELL_COLOR_CYAN    },\n\t\t{ \"white\",   CELL_COLOR_WHITE   },\n\t\t{ \"default\", CELL_COLOR_DEFAULT },\n\t};\n\n\tfor (size_t i = 0; i < LENGTH(color_names); i++) {\n\t\tif (strcasecmp(color_names[i].name, s) == 0) {\n\t\t\t*color = color_names[i].color;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool ui_style_define(Win *win, int id, const char *style) {\n\tUi *tui = &win->vis->ui;\n\tif (id >= UI_STYLE_MAX)\n\t\treturn false;\n\tif (!style)\n\t\treturn true;\n\n\tCellStyle cell_style = CELL_STYLE_DEFAULT;\n\tchar *style_copy = strdup(style), *option = style_copy;\n\twhile (option) {\n\t\twhile (*option == ' ')\n\t\t\toption++;\n\t\tchar *next = strchr(option, ',');\n\t\tif (next)\n\t\t\t*next++ = '\\0';\n\t\tchar *value = strchr(option, ':');\n\t\tif (value)\n\t\t\tfor (*value++ = '\\0'; *value == ' '; value++);\n\t\tif (!strcasecmp(option, \"reverse\")) {\n\t\t\tcell_style.attr |= CELL_ATTR_REVERSE;\n\t\t} else if (!strcasecmp(option, \"notreverse\")) {\n\t\t\tcell_style.attr &= CELL_ATTR_REVERSE;\n\t\t} else if (!strcasecmp(option, \"bold\")) {\n\t\t\tcell_style.attr |= CELL_ATTR_BOLD;\n\t\t} else if (!strcasecmp(option, \"notbold\")) {\n\t\t\tcell_style.attr &= ~CELL_ATTR_BOLD;\n\t\t} else if (!strcasecmp(option, \"dim\")) {\n\t\t\tcell_style.attr |= CELL_ATTR_DIM;\n\t\t} else if (!strcasecmp(option, \"notdim\")) {\n\t\t\tcell_style.attr &= ~CELL_ATTR_DIM;\n\t\t} else if (!strcasecmp(option, \"italics\")) {\n\t\t\tcell_style.attr |= CELL_ATTR_ITALIC;\n\t\t} else if (!strcasecmp(option, \"notitalics\")) {\n\t\t\tcell_style.attr &= ~CELL_ATTR_ITALIC;\n\t\t} else if (!strcasecmp(option, \"underlined\")) {\n\t\t\tcell_style.attr |= CELL_ATTR_UNDERLINE;\n\t\t} else if (!strcasecmp(option, \"notunderlined\")) {\n\t\t\tcell_style.attr &= ~CELL_ATTR_UNDERLINE;\n\t\t} else if (!strcasecmp(option, \"blink\")) {\n\t\t\tcell_style.attr |= CELL_ATTR_BLINK;\n\t\t} else if (!strcasecmp(option, \"notblink\")) {\n\t\t\tcell_style.attr &= ~CELL_ATTR_BLINK;\n\t\t} else if (!strcasecmp(option, \"fore\")) {\n\t\t\tcolor_fromstring(&win->vis->ui, &cell_style.fg, value);\n\t\t} else if (!strcasecmp(option, \"back\")) {\n\t\t\tcolor_fromstring(&win->vis->ui, &cell_style.bg, value);\n\t\t}\n\t\toption = next;\n\t}\n\ttui->styles[win->id * UI_STYLE_MAX + id] = cell_style;\n\tfree(style_copy);\n\treturn true;\n}\n\nstatic void ui_draw_line(Ui *tui, int x, int y, char c, enum UiStyle style_id) {\n\tif (x < 0 || x >= tui->width || y < 0 || y >= tui->height)\n\t\treturn;\n\tCellStyle style = tui->styles[style_id];\n\tCell *cells = tui->cells + y * tui->width;\n\twhile (x < tui->width) {\n\t\tcells[x].data[0] = c;\n\t\tcells[x].data[1] = '\\0';\n\t\tcells[x].style = style;\n\t\tx++;\n\t}\n}\n\nstatic void ui_draw_string(Ui *tui, int x, int y, const char *str, int win_id, enum UiStyle style_id) {\n\tdebug(\"draw-string: [%d][%d]\\n\", y, x);\n\tif (x < 0 || x >= tui->width || y < 0 || y >= tui->height)\n\t\treturn;\n\n\t/* NOTE: the style that style_id refers to may contain unset values; we need to properly\n\t * clear the cell first then go through ui_window_style_set to get the correct style */\n\tCellStyle default_style = tui->styles[UI_STYLE_MAX * win_id + UI_STYLE_DEFAULT];\n\t// FIXME: does not handle double width characters etc, share code with view.c?\n\tCell *cells = tui->cells + y * tui->width;\n\tconst size_t cell_size = sizeof(cells[0].data)-1;\n\tfor (const char *next = str; *str && x < tui->width; str = next) {\n\t\tdo next++; while (!ISUTF8(*next));\n\t\tsize_t len = next - str;\n\t\tif (!len)\n\t\t\tbreak;\n\t\tlen = MIN(len, cell_size);\n\t\tstrncpy(cells[x].data, str, len);\n\t\tcells[x].data[len] = '\\0';\n\t\tcells[x].style = default_style;\n\t\tui_window_style_set(tui, win_id, cells + x++, style_id);\n\t}\n}\n\nstatic void ui_window_draw(Win *win) {\n\tUi *ui = &win->vis->ui;\n\tView *view = &win->view;\n\tconst Line *line = win->view.topline;\n\n\tbool status  = win->options & UI_OPTION_STATUSBAR;\n\tbool nu      = win->options & UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\tbool rnu     = win->options & UI_OPTION_LINE_NUMBERS_RELATIVE;\n\tbool sidebar = nu || rnu;\n\n\tint width = win->width, height = win->height;\n\tint sidebar_width = sidebar ? snprintf(NULL, 0, \"%zd \", line->lineno + height - 2) : 0;\n\tif (sidebar_width != win->sidebar_width) {\n\t\tview_resize(view, width - sidebar_width, status ? height - 1 : height);\n\t\twin->sidebar_width = sidebar_width;\n\t}\n\tvis_window_draw(win);\n\n\tSelection *sel = view_selections_primary_get(view);\n\tsize_t prev_lineno = 0, cursor_lineno = sel->line->lineno;\n\tchar buf[(sizeof(size_t) * CHAR_BIT + 2) / 3 + 1 + 1];\n\tint x = win->x, y = win->y;\n\tint view_width = view->width;\n\tCell *cells = ui->cells + y * ui->width;\n\tif (x + sidebar_width + view_width > ui->width)\n\t\tview_width = ui->width - x - sidebar_width;\n\tfor (const Line *l = line; l; l = l->next, y++) {\n\t\tif (sidebar) {\n\t\t\tif (!l->lineno || !l->len || l->lineno == prev_lineno) {\n\t\t\t\tmemset(buf, ' ', sizeof(buf));\n\t\t\t\tbuf[sidebar_width] = '\\0';\n\t\t\t} else {\n\t\t\t\tsize_t number = l->lineno;\n\t\t\t\tif (rnu) {\n\t\t\t\t\tnumber = (win->options & UI_OPTION_LARGE_FILE) ? 0 : l->lineno;\n\t\t\t\t\tif (l->lineno > cursor_lineno)\n\t\t\t\t\t\tnumber = l->lineno - cursor_lineno;\n\t\t\t\t\telse if (l->lineno < cursor_lineno)\n\t\t\t\t\t\tnumber = cursor_lineno - l->lineno;\n\t\t\t\t}\n\t\t\t\tsnprintf(buf, sizeof buf, \"%*zu \", sidebar_width-1, number);\n\t\t\t}\n\t\t\tui_draw_string(ui, x, y, buf, win->id,\n\t\t\t\t       (l->lineno == cursor_lineno) ? UI_STYLE_LINENUMBER_CURSOR :\n\t\t\t\t                                      UI_STYLE_LINENUMBER);\n\t\t\tprev_lineno = l->lineno;\n\t\t}\n\t\tdebug(\"draw-window: [%d][%d] ... cells[%d][%d]\\n\", y, x+sidebar_width, y, view_width);\n\t\tmemcpy(cells + x + sidebar_width, l->cells, sizeof(Cell) * view_width);\n\t\tcells += ui->width;\n\t}\n}\n\nvoid ui_window_style_set(Ui *tui, int win_id, Cell *cell, enum UiStyle id) {\n\tCellStyle set = tui->styles[win_id * UI_STYLE_MAX + id];\n\n\tif (id != UI_STYLE_DEFAULT) {\n\t\tset.fg = is_default_fg(set.fg)? cell->style.fg : set.fg;\n\t\tset.bg = is_default_bg(set.bg)? cell->style.bg : set.bg;\n\t\tset.attr = cell->style.attr | set.attr;\n\t}\n\n\tcell->style = set;\n}\n\nbool ui_window_style_set_pos(Win *win, int x, int y, enum UiStyle id) {\n\tUi *tui = &win->vis->ui;\n\tif (x < 0 || y < 0 || y >= win->height || x >= win->width) {\n\t\treturn false;\n\t}\n\tCell *cell = CELL_AT_POS(tui, win->x + x, win->y + y)\n\tui_window_style_set(tui, win->id, cell, id);\n\treturn true;\n}\n\nvoid ui_window_status(Win *win, const char *status) {\n\tif (!(win->options & UI_OPTION_STATUSBAR))\n\t\treturn;\n\tUi *ui = &win->vis->ui;\n\tenum UiStyle style = ui->selwin == win ? UI_STYLE_STATUS_FOCUSED : UI_STYLE_STATUS;\n\tui_draw_string(ui, win->x, win->y + win->height - 1, status, win->id, style);\n}\n\nvoid ui_arrange(Ui *tui, enum UiLayout layout) {\n\tdebug(\"ui-arrange\\n\");\n\ttui->layout = layout;\n\tint n = 0, m = !!tui->info[0], x = 0, y = 0;\n\tfor (Win *win = tui->windows; win; win = win->next) {\n\t\tif (win->options & UI_OPTION_ONELINE)\n\t\t\tm++;\n\t\telse\n\t\t\tn++;\n\t}\n\tint max_height = tui->height - m;\n\tint width = (tui->width / MAX(1, n)) - 1;\n\tint height = max_height / MAX(1, n);\n\tfor (Win *win = tui->windows; win; win = win->next) {\n\t\tif (win->options & UI_OPTION_ONELINE)\n\t\t\tcontinue;\n\t\tn--;\n\t\tif (layout == UI_LAYOUT_HORIZONTAL) {\n\t\t\tint h = n ? height : max_height - y;\n\t\t\tui_window_resize(win, tui->width, h);\n\t\t\tui_window_move(win, x, y);\n\t\t\ty += h;\n\t\t} else {\n\t\t\tint w = n ? width : tui->width - x;\n\t\t\tui_window_resize(win, w, max_height);\n\t\t\tui_window_move(win, x, y);\n\t\t\tx += w;\n\t\t\tif (n) {\n\t\t\t\tCell *cells = tui->cells;\n\t\t\t\tfor (int i = 0; i < max_height; i++) {\n\t\t\t\t\tstrcpy(cells[x].data,\"│\");\n\t\t\t\t\tcells[x].style = tui->styles[UI_STYLE_SEPARATOR];\n\t\t\t\t\tcells += tui->width;\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (layout == UI_LAYOUT_VERTICAL)\n\t\ty = max_height;\n\n\tfor (Win *win = tui->windows; win; win = win->next) {\n\t\tif (!(win->options & UI_OPTION_ONELINE))\n\t\t\tcontinue;\n\t\tui_window_resize(win, tui->width, 1);\n\t\tui_window_move(win, 0, y++);\n\t}\n}\n\nvoid ui_draw(Ui *tui) {\n\tdebug(\"ui-draw\\n\");\n\tui_arrange(tui, tui->layout);\n\tfor (Win *win = tui->windows; win; win = win->next)\n\t\tui_window_draw(win);\n\tif (tui->info[0])\n\t\tui_draw_string(tui, 0, tui->height-1, tui->info, 0, UI_STYLE_INFO);\n\tvis_event_emit(tui->vis, VIS_EVENT_UI_DRAW);\n\tui_term_backend_blit(tui);\n}\n\nvoid ui_redraw(Ui *tui) {\n\tui_term_backend_clear(tui);\n\tfor (Win *win = tui->windows; win; win = win->next)\n\t\twin->view.need_update = true;\n}\n\nvoid ui_resize(Ui *tui) {\n\tstruct winsize ws;\n\tint width = 80, height = 24;\n\n\tif (ioctl(STDERR_FILENO, TIOCGWINSZ, &ws) != -1) {\n\t\tif (ws.ws_col > 0)\n\t\t\twidth = ws.ws_col;\n\t\tif (ws.ws_row > 0)\n\t\t\theight = ws.ws_row;\n\t}\n\n\twidth  = MIN(width,  UI_MAX_WIDTH);\n\theight = MIN(height, UI_MAX_HEIGHT);\n\tif (!ui_term_backend_resize(tui, width, height))\n\t\treturn;\n\n\tsize_t size = width*height*sizeof(Cell);\n\tif (size > tui->cells_size) {\n\t\tCell *cells = realloc(tui->cells, size);\n\t\tif (!cells)\n\t\t\treturn;\n\t\tmemset((char*)cells+tui->cells_size, 0, size - tui->cells_size);\n\t\ttui->cells_size = size;\n\t\ttui->cells = cells;\n\t}\n\ttui->width = width;\n\ttui->height = height;\n}\n\nvoid ui_window_release(Ui *tui, Win *win) {\n\tif (!win)\n\t\treturn;\n\tif (tui->windows == win)\n\t\ttui->windows = win->next;\n\tif (tui->selwin == win)\n\t\ttui->selwin = NULL;\n\ttui->ids &= ~(1UL << win->id);\n}\n\nvoid ui_window_focus(Win *new) {\n\tWin *old = new->vis->ui.selwin;\n\tif (new->options & UI_OPTION_STATUSBAR)\n\t\tnew->vis->ui.selwin = new;\n\tif (old)\n\t\told->view.need_update = true;\n\tnew->view.need_update = true;\n}\n\nvoid ui_window_options_set(Win *win, enum UiOption options) {\n\twin->options = options;\n\tif (options & UI_OPTION_ONELINE) {\n\t\t/* move the new window to the end of the list */\n\t\tUi *tui = &win->vis->ui;\n\t\tWin *last = tui->windows;\n\t\twhile (last->next)\n\t\t\tlast = last->next;\n\t\tif (last != win) {\n\t\t\tif (tui->windows == win)\n\t\t\t\ttui->windows = win->next;\n\t\t\tlast->next = win;\n\t\t}\n\t}\n\tui_draw(&win->vis->ui);\n}\n\nvoid ui_window_swap(Win *a, Win *b) {\n\tif (a == b || !a || !b)\n\t\treturn;\n\tUi *tui = &a->vis->ui;\n\tif (tui->windows == a)\n\t\ttui->windows = b;\n\telse if (tui->windows == b)\n\t\ttui->windows = a;\n\tif (tui->selwin == a)\n\t\tui_window_focus(b);\n\telse if (tui->selwin == b)\n\t\tui_window_focus(a);\n}\n\nbool ui_window_init(Ui *tui, Win *w, enum UiOption options) {\n\t/* get rightmost zero bit, i.e. highest available id */\n\tsize_t bit = ~tui->ids & (tui->ids + 1);\n\tsize_t id = 0;\n\tfor (size_t tmp = bit; tmp >>= 1; id++);\n\tif (id >= sizeof(size_t) * 8)\n\t\treturn NULL;\n\tsize_t styles_size = (id + 1) * UI_STYLE_MAX * sizeof(CellStyle);\n\tif (styles_size > tui->styles_size) {\n\t\tCellStyle *styles = realloc(tui->styles, styles_size);\n\t\tif (!styles)\n\t\t\treturn NULL;\n\t\ttui->styles = styles;\n\t\ttui->styles_size = styles_size;\n\t}\n\n\ttui->ids |= bit;\n\tw->id = id;\n\n\tCellStyle *styles = &tui->styles[w->id * UI_STYLE_MAX];\n\tfor (int i = 0; i < UI_STYLE_MAX; i++) {\n\t\tstyles[i] = CELL_STYLE_DEFAULT;\n\t}\n\n\tstyles[UI_STYLE_CURSOR].attr |= CELL_ATTR_REVERSE;\n\tstyles[UI_STYLE_CURSOR_PRIMARY].attr |= CELL_ATTR_REVERSE|CELL_ATTR_BLINK;\n\tstyles[UI_STYLE_SELECTION].attr |= CELL_ATTR_REVERSE;\n\tstyles[UI_STYLE_COLOR_COLUMN].attr |= CELL_ATTR_REVERSE;\n\tstyles[UI_STYLE_STATUS].attr |= CELL_ATTR_REVERSE;\n\tstyles[UI_STYLE_STATUS_FOCUSED].attr |= CELL_ATTR_REVERSE|CELL_ATTR_BOLD;\n\tstyles[UI_STYLE_INFO].attr |= CELL_ATTR_BOLD;\n\n\tif (tui->windows)\n\t\ttui->windows->prev = w->prev;\n\ttui->windows = w;\n\n\tif (text_size(w->file->text) > UI_LARGE_FILE_SIZE) {\n\t\toptions |= UI_OPTION_LARGE_FILE;\n\t\toptions &= ~UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\t}\n\n\twin_options_set(w, options);\n\n\treturn true;\n}\n\nvoid ui_info_show(Ui *tui, const char *msg, va_list ap) {\n\tui_draw_line(tui, 0, tui->height-1, ' ', UI_STYLE_INFO);\n\tvsnprintf(tui->info, sizeof(tui->info), msg, ap);\n}\n\nvoid ui_info_hide(Ui *tui) {\n\tif (tui->info[0])\n\t\ttui->info[0] = '\\0';\n}\n\nstatic TermKey *ui_termkey_new(int fd) {\n\tTermKey *termkey = termkey_new(fd, UI_TERMKEY_FLAGS);\n\tif (termkey)\n\t\ttermkey_set_canonflags(termkey, TERMKEY_CANON_DELBS);\n\treturn termkey;\n}\n\nstatic TermKey *ui_termkey_reopen(Ui *ui, int fd) {\n\tint tty = open(\"/dev/tty\", O_RDWR);\n\tif (tty == -1)\n\t\treturn NULL;\n\tif (tty != fd && dup2(tty, fd) == -1) {\n\t\tclose(tty);\n\t\treturn NULL;\n\t}\n\tclose(tty);\n\treturn ui_termkey_new(fd);\n}\n\nvoid ui_terminal_suspend(Ui *tui) {\n\tui_term_backend_suspend(tui);\n\tkill(0, SIGTSTP);\n}\n\nbool ui_getkey(Ui *tui, TermKeyKey *key) {\n\tTermKeyResult ret = termkey_getkey(tui->termkey, key);\n\n\tif (ret == TERMKEY_RES_EOF) {\n\t\ttermkey_destroy(tui->termkey);\n\t\terrno = 0;\n\t\tif (!(tui->termkey = ui_termkey_reopen(tui, STDIN_FILENO)))\n\t\t\tui_die_msg(tui, \"Failed to re-open stdin as /dev/tty: %s\\n\", errno != 0 ? strerror(errno) : \"\");\n\t\treturn false;\n\t}\n\n\tif (ret == TERMKEY_RES_AGAIN) {\n\t\tstruct pollfd fd;\n\t\tfd.fd = STDIN_FILENO;\n\t\tfd.events = POLLIN;\n\t\tif (poll(&fd, 1, termkey_get_waittime(tui->termkey)) == 0)\n\t\t\tret = termkey_getkey_force(tui->termkey, key);\n\t}\n\n\treturn ret == TERMKEY_RES_KEY;\n}\n\nvoid ui_terminal_save(Ui *tui, bool fscr) {\n\tui_term_backend_save(tui, fscr);\n\ttermkey_stop(tui->termkey);\n}\n\nvoid ui_terminal_restore(Ui *tui) {\n\ttermkey_start(tui->termkey);\n\tui_term_backend_restore(tui);\n}\n\nbool ui_init(Ui *tui, Vis *vis) {\n\ttui->vis = vis;\n\n\tsetlocale(LC_CTYPE, \"\");\n\n\tchar *term = getenv(\"TERM\");\n\tif (!term) {\n\t\tterm = \"xterm\";\n\t\tsetenv(\"TERM\", term, 1);\n\t}\n\n\terrno = 0;\n\tif (!(tui->termkey = ui_termkey_new(STDIN_FILENO))) {\n\t\t/* work around libtermkey bug which fails if stdin is /dev/null */\n\t\tif (errno == EBADF) {\n\t\t\terrno = 0;\n\t\t\tif (!(tui->termkey = ui_termkey_reopen(tui, STDIN_FILENO)) && errno == ENXIO)\n\t\t\t\ttui->termkey = termkey_new_abstract(term, UI_TERMKEY_FLAGS);\n\t\t}\n\t\tif (!tui->termkey)\n\t\t\tgoto err;\n\t}\n\n\tif (!ui_term_backend_init(tui, term))\n\t\tgoto err;\n\tui_resize(tui);\n\treturn true;\nerr:\n\tui_die_msg(tui, \"Failed to start curses interface: %s\\n\", errno != 0 ? strerror(errno) : \"\");\n\treturn false;\n}\n\nbool ui_terminal_init(Ui *tui) {\n\tsize_t styles_size = UI_STYLE_MAX * sizeof(CellStyle);\n\tCellStyle *styles = calloc(1, styles_size);\n\tif (!styles)\n\t\treturn false;\n\tif (!ui_backend_init(tui)) {\n\t\tfree(styles);\n\t\treturn false;\n\t}\n\ttui->styles_size = styles_size;\n\ttui->styles = styles;\n\ttui->doupdate = true;\n\treturn true;\n}\n\nvoid ui_terminal_free(Ui *tui) {\n\tif (!tui)\n\t\treturn;\n\twhile (tui->windows)\n\t\tui_window_release(tui, tui->windows);\n\tui_term_backend_free(tui);\n\tif (tui->termkey)\n\t\ttermkey_destroy(tui->termkey);\n\tfree(tui->cells);\n\tfree(tui->styles);\n}\n"
        },
        {
          "name": "ui.h",
          "type": "blob",
          "size": 4.357421875,
          "content": "#ifndef UI_H\n#define UI_H\n\n#include <stdbool.h>\n#include <stdarg.h>\n#include <termkey.h>\n\n/* enable large file optimization for files larger than: */\n#define UI_LARGE_FILE_SIZE (1 << 25)\n/* enable large file optimization for files containing lines longer than: */\n#define UI_LARGE_FILE_LINE_SIZE (1 << 16)\n\n#define UI_MAX_WIDTH  1024\n#define UI_MAX_HEIGHT 1024\n\nenum UiLayout {\n\tUI_LAYOUT_HORIZONTAL,\n\tUI_LAYOUT_VERTICAL,\n};\n\nenum UiOption {\n\tUI_OPTION_NONE = 0,\n\tUI_OPTION_LINE_NUMBERS_ABSOLUTE = 1 << 0,\n\tUI_OPTION_LINE_NUMBERS_RELATIVE = 1 << 1,\n\tUI_OPTION_SYMBOL_SPACE = 1 << 2,\n\tUI_OPTION_SYMBOL_TAB = 1 << 3,\n\tUI_OPTION_SYMBOL_TAB_FILL = 1 << 4,\n\tUI_OPTION_SYMBOL_EOL = 1 << 5,\n\tUI_OPTION_SYMBOL_EOF = 1 << 6,\n\tUI_OPTION_CURSOR_LINE = 1 << 7,\n\tUI_OPTION_STATUSBAR = 1 << 8,\n\tUI_OPTION_ONELINE = 1 << 9,\n\tUI_OPTION_LARGE_FILE = 1 << 10,\n};\n\nenum UiStyle {\n\tUI_STYLE_LEXER_MAX = 64,\n\tUI_STYLE_DEFAULT,\n\tUI_STYLE_CURSOR,\n\tUI_STYLE_CURSOR_PRIMARY,\n\tUI_STYLE_CURSOR_LINE,\n\tUI_STYLE_SELECTION,\n\tUI_STYLE_LINENUMBER,\n\tUI_STYLE_LINENUMBER_CURSOR,\n\tUI_STYLE_COLOR_COLUMN,\n\tUI_STYLE_STATUS,\n\tUI_STYLE_STATUS_FOCUSED,\n\tUI_STYLE_SEPARATOR,\n\tUI_STYLE_INFO,\n\tUI_STYLE_EOF,\n\tUI_STYLE_MAX,\n};\n\n#if CONFIG_CURSES\ntypedef uint64_t CellAttr;\ntypedef short CellColor;\n#else\ntypedef uint8_t CellAttr;\ntypedef struct {\n\tuint8_t r, g, b;\n\tuint8_t index;\n} CellColor;\n#endif\n\ntypedef struct {\n\tCellAttr attr;\n\tCellColor fg, bg;\n} CellStyle;\n\ntypedef struct {\n\tchar data[16];      /* utf8 encoded character displayed in this cell (might be more than\n\t                       one Unicode codepoint. might also not be the same as in the\n\t                       underlying text, for example tabs get expanded */\n\tsize_t len;         /* number of bytes the character displayed in this cell uses, for\n\t                       characters which use more than 1 column to display, their length\n\t                       is stored in the leftmost cell whereas all following cells\n\t                       occupied by the same character have a length of 0. */\n\tint width;          /* display width i.e. number of columns occupied by this character */\n\tCellStyle style;    /* colors and attributes used to display this cell */\n} Cell;\n\nstruct Win;\nstruct Vis;\ntypedef struct {\n\tstruct Vis *vis;          /* editor instance to which this ui belongs */\n\tstruct Win *windows;      /* all windows managed by this ui */\n\tstruct Win *selwin;       /* the currently selected layout */\n\tchar info[UI_MAX_WIDTH];  /* info message displayed at the bottom of the screen */\n\tint width, height;        /* terminal dimensions available for all windows */\n\tenum UiLayout layout;     /* whether windows are displayed horizontally or vertically */\n\tTermKey *termkey;         /* libtermkey instance to handle keyboard input (stdin or /dev/tty) */\n\tsize_t ids;               /* bit mask of in use window ids */\n\tsize_t styles_size;       /* #bytes allocated for styles array */\n\tCellStyle *styles;        /* each window has UI_STYLE_MAX different style definitions */\n\tsize_t cells_size;        /* #bytes allocated for 2D grid (grows only) */\n\tCell *cells;              /* 2D grid of cells, at least as large as current terminal size */\n\tbool doupdate;            /* Whether to update the screen after refreshing contents */\n\tvoid *ctx;                /* Any additional data needed by the backend */\n} Ui;\n\n#include \"view.h\"\n#include \"vis.h\"\n#include \"text.h\"\n\nbool ui_terminal_init(Ui*);\nint  ui_terminal_colors(void);\nvoid ui_terminal_free(Ui*);\nvoid ui_terminal_restore(Ui*);\nvoid ui_terminal_resume(Ui*);\nvoid ui_terminal_save(Ui*, bool fscr);\nvoid ui_terminal_suspend(Ui*);\n\n__attribute__((noreturn)) void ui_die(Ui *, const char *, va_list);\nbool ui_init(Ui *, Vis *);\nvoid ui_arrange(Ui*, enum UiLayout);\nvoid ui_draw(Ui*);\nvoid ui_info_hide(Ui *);\nvoid ui_info_show(Ui *, const char *, va_list);\nvoid ui_redraw(Ui*);\nvoid ui_resize(Ui*);\n\nbool ui_window_init(Ui *, Win *, enum UiOption);\nvoid ui_window_focus(Win *);\n/* removes a window from the list of open windows */\nvoid ui_window_release(Ui *, Win *);\nvoid ui_window_swap(Win *, Win *);\n\nbool ui_getkey(Ui *, TermKeyKey *);\n\nbool ui_style_define(Win *win, int id, const char *style);\nbool ui_window_style_set_pos(Win *win, int x, int y, enum UiStyle id);\nvoid ui_window_style_set(Ui *ui, int win_id, Cell *cell, enum UiStyle id);\n\nvoid ui_window_options_set(Win *win, enum UiOption options);\nvoid ui_window_status(Win *win, const char *status);\n\n#endif\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 0.9404296875,
          "content": "#ifndef UTIL_H\n#define UTIL_H\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#define LENGTH(x)  ((int)(sizeof (x) / sizeof *(x)))\n#define MIN(a, b)  ((a) > (b) ? (b) : (a))\n#define MAX(a, b)  ((a) < (b) ? (b) : (a))\n\n/* is c the start of a utf8 sequence? */\n#define ISUTF8(c)   (((c)&0xC0)!=0x80)\n#define ISASCII(ch) ((unsigned char)ch < 0x80)\n\n#if GCC_VERSION>=5004000 || CLANG_VERSION>=4000000\n#define addu __builtin_add_overflow\n#else\nstatic inline bool addu(size_t a, size_t b, size_t *c) {\n\tif (SIZE_MAX - a < b)\n\t\treturn false;\n\t*c = a + b;\n\treturn true;\n}\n#endif\n\n#if !HAVE_MEMRCHR\n/* MIT licensed implementation from musl libc */\nstatic void *memrchr(const void *m, int c, size_t n)\n{\n\tconst unsigned char *s = m;\n\tc = (unsigned char)c;\n\twhile (n--) if (s[n]==c) return (void *)(s+n);\n\treturn 0;\n}\n#endif\n\n/* Needed for building on GNU Hurd */\n\n#ifndef PIPE_BUF\n#define PIPE_BUF 4096\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#endif /* UTIL_H */\n"
        },
        {
          "name": "view.c",
          "type": "blob",
          "size": 35.744140625,
          "content": "#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n\n#include \"vis-core.h\"\n#include \"view.h\"\n#include \"text.h\"\n#include \"text-motions.h\"\n#include \"text-util.h\"\n#include \"util.h\"\n\n/* A selection is made up of two marks named cursor and anchor.\n * While the anchor remains fixed the cursor mark follows cursor motions.\n * For a selection (indicated by []), the marks (^) are placed as follows:\n *\n *     [some text]              [!]\n *      ^       ^                ^\n *                               ^\n *\n * That is the marks point to the *start* of the first and last character\n * of the selection. In particular for a single character selection (as\n * depicted on the right above) both marks point to the same location.\n *\n * The view_selections_{get,set} functions take care of adding/removing\n * the necessary offset for the last character.\n */\n\nstatic const char *symbols_none[] = {\n\t[SYNTAX_SYMBOL_SPACE]    = \" \",\n\t[SYNTAX_SYMBOL_TAB]      = \" \",\n\t[SYNTAX_SYMBOL_TAB_FILL] = \" \",\n\t[SYNTAX_SYMBOL_EOL]      = \" \",\n\t[SYNTAX_SYMBOL_EOF]      = \" \",\n};\n\nstatic const char *symbols_default[] = {\n\t[SYNTAX_SYMBOL_SPACE]    = \"·\", /* Middle Dot U+00B7 */\n\t[SYNTAX_SYMBOL_TAB]      = \"›\", /* Single Right-Pointing Angle Quotation Mark U+203A */\n\t[SYNTAX_SYMBOL_TAB_FILL] = \" \",\n\t[SYNTAX_SYMBOL_EOL]      = \"↵\", /* Downwards Arrow with Corner Leftwards U+21B5 */\n\t[SYNTAX_SYMBOL_EOF]      = \"~\",\n};\n\nstatic Cell cell_blank = { .width = 0, .len = 0, .data = \" \", };\n\n/* move visible viewport n-lines up/down, redraws the view but does not change\n * cursor position which becomes invalid and should be corrected by calling\n * view_cursors_to. the return value indicates whether the visible area changed.\n */\nstatic bool view_viewport_up(View *view, int n);\nstatic bool view_viewport_down(View *view, int n);\n\nstatic void view_clear(View *view);\nstatic bool view_add_cell(View *view, const Cell *cell);\nstatic bool view_addch(View *view, Cell *cell);\nstatic void selection_free(Selection*);\n/* set/move current cursor position to a given (line, column) pair */\nstatic size_t cursor_set(Selection*, Line *line, int col);\n\nvoid window_status_update(Vis *vis, Win *win) {\n\tchar left_parts[4][255] = { \"\", \"\", \"\", \"\" };\n\tchar right_parts[4][32] = { \"\", \"\", \"\", \"\" };\n\tchar left[sizeof(left_parts)+LENGTH(left_parts)*8];\n\tchar right[sizeof(right_parts)+LENGTH(right_parts)*8];\n\tchar status[sizeof(left)+sizeof(right)+1];\n\tsize_t left_count = 0;\n\tsize_t right_count = 0;\n\n\tView *view = &win->view;\n\tFile *file = win->file;\n\tText *txt = file->text;\n\tint width = win->width;\n\tenum UiOption options = win->options;\n\tbool focused = vis->win == win;\n\tconst char *filename = file_name_get(file);\n\tconst char *mode = vis->mode->status;\n\n\tif (focused && mode)\n\t\tstrcpy(left_parts[left_count++], mode);\n\n\tsnprintf(left_parts[left_count++], sizeof(left_parts[0]), \"%s%s%s\",\n\t         filename ? filename : \"[No Name]\",\n\t         text_modified(txt) ? \" [+]\" : \"\",\n\t         vis_macro_recording(vis) ? \" @\": \"\");\n\n\tint count = vis->action.count;\n\tconst char *keys = buffer_content0(&vis->input_queue);\n\tif (keys && keys[0])\n\t\tsnprintf(right_parts[right_count++], sizeof(right_parts[0]), \"%s\", keys);\n\telse if (count != VIS_COUNT_UNKNOWN)\n\t\tsnprintf(right_parts[right_count++], sizeof(right_parts[0]), \"%d\", count);\n\n\tint sel_count = view->selection_count;\n\tif (sel_count > 1) {\n\t\tSelection *s = view_selections_primary_get(view);\n\t\tint sel_number = view_selections_number(s) + 1;\n\t\tsnprintf(right_parts[right_count++], sizeof(right_parts[0]),\n\t\t         \"%d/%d\", sel_number, sel_count);\n\t}\n\n\tsize_t size = text_size(txt);\n\tsize_t pos = view_cursor_get(view);\n\tsize_t percent = 0;\n\tif (size > 0) {\n\t\tdouble tmp = ((double)pos/(double)size)*100;\n\t\tpercent = (size_t)(tmp+1);\n\t}\n\tsnprintf(right_parts[right_count++], sizeof(right_parts[0]),\n\t         \"%zu%%\", percent);\n\n\tif (!(options & UI_OPTION_LARGE_FILE)) {\n\t\tSelection *sel = view_selections_primary_get(&win->view);\n\t\tsize_t line = view_cursors_line(sel);\n\t\tsize_t col = view_cursors_col(sel);\n\t\tif (col > UI_LARGE_FILE_LINE_SIZE) {\n\t\t\toptions |= UI_OPTION_LARGE_FILE;\n\t\t\twin_options_set(win, options);\n\t\t}\n\t\tsnprintf(right_parts[right_count++], sizeof(right_parts[0]),\n\t\t         \"%zu, %zu\", line, col);\n\t}\n\n\tint left_len = snprintf(left, sizeof(left), \" %s%s%s%s%s%s%s\",\n\t         left_parts[0],\n\t         left_parts[1][0] ? \" » \" : \"\",\n\t         left_parts[1],\n\t         left_parts[2][0] ? \" » \" : \"\",\n\t         left_parts[2],\n\t         left_parts[3][0] ? \" » \" : \"\",\n\t         left_parts[3]);\n\n\tint right_len = snprintf(right, sizeof(right), \"%s%s%s%s%s%s%s \",\n\t         right_parts[0],\n\t         right_parts[1][0] ? \" « \" : \"\",\n\t         right_parts[1],\n\t         right_parts[2][0] ? \" « \" : \"\",\n\t         right_parts[2],\n\t         right_parts[3][0] ? \" « \" : \"\",\n\t         right_parts[3]);\n\n\tif (left_len < 0 || right_len < 0)\n\t\treturn;\n\tint left_width = text_string_width(left, left_len);\n\tint right_width = text_string_width(right, right_len);\n\n\tint spaces = width - left_width - right_width;\n\tif (spaces < 1)\n\t\tspaces = 1;\n\n\tsnprintf(status, sizeof(status), \"%s%*s%s\", left, spaces, \" \", right);\n\tui_window_status(win, status);\n}\n\nvoid view_tabwidth_set(View *view, int tabwidth) {\n\tif (tabwidth < 1 || tabwidth > 8)\n\t\treturn;\n\tview->tabwidth = tabwidth;\n\tview_draw(view);\n}\n\n/* reset internal view data structures (cell matrix, line offsets etc.) */\nstatic void view_clear(View *view) {\n\tmemset(view->lines, 0, view->lines_size);\n\tif (view->start != view->start_last) {\n\t\tif (view->start == 0)\n\t\t\tview->start_mark = EMARK;\n\t\telse\n\t\t\tview->start_mark = text_mark_set(view->text, view->start);\n\t} else {\n\t\tsize_t start;\n\t\tif (view->start_mark == EMARK)\n\t\t\tstart = 0;\n\t\telse\n\t\t\tstart = text_mark_get(view->text, view->start_mark);\n\t\tif (start != EPOS)\n\t\t\tview->start = start;\n\t}\n\n\tview->start_last = view->start;\n\tview->topline = view->lines;\n\tview->topline->lineno = view->large_file ? 1 : text_lineno_by_pos(view->text, view->start);\n\tview->lastline = view->topline;\n\n\tsize_t line_size = sizeof(Line) + view->width*sizeof(Cell);\n\tsize_t end = view->height * line_size;\n\tLine *prev = NULL;\n\tfor (size_t i = 0; i < end; i += line_size) {\n\t\tLine *line = (Line*)(((char*)view->lines) + i);\n\t\tline->prev = prev;\n\t\tif (prev)\n\t\t\tprev->next = line;\n\t\tprev = line;\n\t}\n\tview->bottomline = prev ? prev : view->topline;\n\tview->bottomline->next = NULL;\n\tview->line = view->topline;\n\tview->col = 0;\n\tview->wrapcol = 0;\n\tview->prevch_breakat = false;\n\n\t/* FIXME: awful garbage that only exists because every\n\t * struct in this program is an interdependent hellscape */\n\tWin *win = (Win *)((char *)view - offsetof(Win, view));\n\tui_window_style_set(&win->vis->ui, win->id, &cell_blank, UI_STYLE_DEFAULT);\n}\n\nstatic int view_max_text_width(const View *view) {\n\tif (view->wrapcolumn > 0)\n\t\treturn MIN(view->wrapcolumn, view->width);\n\treturn view->width;\n}\n\nstatic void view_wrap_line(View *view) {\n\tLine *wrapped_line = view->line;\n\tint col = view->col;\n\tint wrapcol = (view->wrapcol > 0) ? view->wrapcol : view->col;\n\n\tview->line = view->line->next;\n\tview->col = 0;\n\tview->wrapcol = 0;\n\n\tif (view->line) {\n\t\tview->line->lineno = wrapped_line->lineno;\n\t\t/* move extra cells to the next line */\n\t\tfor (int i = wrapcol; i < col; ++i) {\n\t\t\tconst Cell *cell = &wrapped_line->cells[i];\n\t\t\tview->line->width += cell->width;\n\t\t\tview->line->len += cell->len;\n\t\t\tview->line->cells[view->col++] = *cell;\n\t\t}\n\t}\n\n\t/* clear remaining cells on line */\n\tfor (int i = wrapcol; i < view->width; ++i) {\n\t\tif (i < col) {\n\t\t\twrapped_line->width -= wrapped_line->cells[i].width;\n\t\t\twrapped_line->len -= wrapped_line->cells[i].len;\n\t\t}\n\t\twrapped_line->cells[i] = cell_blank;\n\t}\n}\n\nstatic bool view_add_cell(View *view, const Cell *cell) {\n\t/* if the terminal is resized to a single (ASCII) char an out\n\t * of bounds write could be performed for a wide char. this can\n\t * be caught by iterating through the lines with view_wrap_line()\n\t * until no lines remain. usually 0 or 1 iterations.\n\t */\n\twhile (view->col + cell->width > view_max_text_width(view)) {\n\t\tview_wrap_line(view);\n\t\tif (!view->line)\n\t\t\treturn false;\n\t}\n\n\tview->line->width += cell->width;\n\tview->line->len += cell->len;\n\tview->line->cells[view->col++] = *cell;\n\t/* set cells of a character which uses multiple columns */\n\tfor (int i = 1; i < cell->width; i++)\n\t\tview->line->cells[view->col++] = (Cell){0};\n\treturn true;\n}\n\nstatic bool view_expand_tab(View *view, Cell *cell) {\n\tcell->width = 1;\n\n\tint displayed_width = view->tabwidth - (view->col % view->tabwidth);\n\tfor (int w = 0; w < displayed_width; ++w) {\n\t\tint t = (w == 0) ? SYNTAX_SYMBOL_TAB : SYNTAX_SYMBOL_TAB_FILL;\n\t\tconst char *symbol = view->symbols[t];\n\t\tstrncpy(cell->data, symbol, sizeof(cell->data) - 1);\n\t\tcell->len = (w == 0) ? 1 : 0;\n\n\t\tif (!view_add_cell(view, cell))\n\t\t\treturn false;\n\t}\n\n\tcell->len = 1;\n\treturn true;\n}\n\nstatic bool view_expand_newline(View *view, Cell *cell) {\n\tsize_t lineno = view->line->lineno;\n\tconst char *symbol = view->symbols[SYNTAX_SYMBOL_EOL];\n\n\tstrncpy(cell->data, symbol, sizeof(cell->data) - 1);\n\tcell->width = 1;\n\tif (!view_add_cell(view, cell))\n\t\treturn false;\n\n\tview->wrapcol = 0;\n\tview_wrap_line(view);\n\tif (view->line)\n\t\tview->line->lineno = lineno + 1;\n\treturn true;\n}\n\n/* try to add another character to the view, return whether there was space left */\nstatic bool view_addch(View *view, Cell *cell) {\n\tif (!view->line)\n\t\treturn false;\n\n\tbool ch_breakat = (cell->data[0] != 0) && strstr(view->breakat, cell->data);\n\tif (view->prevch_breakat && !ch_breakat) {\n\t\t/* this is a good place to wrap line if needed */\n\t\tview->wrapcol = view->col;\n\t}\n\tview->prevch_breakat = ch_breakat;\n\tcell->style = cell_blank.style;\n\n\tunsigned char ch = (unsigned char)cell->data[0];\n\tswitch (ch) {\n\tcase '\\t':\n\t\treturn view_expand_tab(view, cell);\n\tcase '\\n':\n\t\treturn view_expand_newline(view, cell);\n\tcase ' ': {\n\t\tconst char *symbol = view->symbols[SYNTAX_SYMBOL_SPACE];\n\t\tstrncpy(cell->data, symbol, sizeof(cell->data) - 1);\n\t\treturn view_add_cell(view, cell);\n\t}}\n\n\tif (ch < 128 && !isprint(ch)) {\n\t\t/* non-printable ascii char, represent it as ^(char + 64) */\n\t\t*cell = (Cell) {\n\t\t\t.data = { '^', ch == 127 ? '?' : ch + 64, '\\0' },\n\t\t\t.len = 1,\n\t\t\t.width = 2,\n\t\t\t.style = cell->style,\n\t\t};\n\t}\n\treturn view_add_cell(view, cell);\n}\n\nstatic void cursor_to(Selection *s, size_t pos) {\n\tText *txt = s->view->text;\n\ts->cursor = text_mark_set(txt, pos);\n\tif (!s->anchored)\n\t\ts->anchor = s->cursor;\n\tif (pos != s->pos)\n\t\ts->lastcol = 0;\n\ts->pos = pos;\n\tif (!view_coord_get(s->view, pos, &s->line, &s->row, &s->col)) {\n\t\tif (s->view->selection == s) {\n\t\t\ts->line = s->view->topline;\n\t\t\ts->row = 0;\n\t\t\ts->col = 0;\n\t\t}\n\t\treturn;\n\t}\n\t// TODO: minimize number of redraws\n\tview_draw(s->view);\n}\n\nbool view_coord_get(View *view, size_t pos, Line **retline, int *retrow, int *retcol) {\n\tint row = 0, col = 0;\n\tsize_t cur = view->start;\n\tLine *line = view->topline;\n\n\tif (pos < view->start || pos > view->end) {\n\t\tif (retline) *retline = NULL;\n\t\tif (retrow) *retrow = -1;\n\t\tif (retcol) *retcol = -1;\n\t\treturn false;\n\t}\n\n\twhile (line && line != view->lastline && cur < pos) {\n\t\tif (cur + line->len > pos)\n\t\t\tbreak;\n\t\tcur += line->len;\n\t\tline = line->next;\n\t\trow++;\n\t}\n\n\tif (line) {\n\t\tint max_col = MIN(view->width, line->width);\n\t\twhile (cur < pos && col < max_col) {\n\t\t\tcur += line->cells[col].len;\n\t\t\t/* skip over columns occupied by the same character */\n\t\t\twhile (++col < max_col && line->cells[col].len == 0);\n\t\t}\n\t} else {\n\t\tline = view->bottomline;\n\t\trow = view->height - 1;\n\t}\n\n\tif (retline) *retline = line;\n\tif (retrow) *retrow = row;\n\tif (retcol) *retcol = col;\n\treturn true;\n}\n\n/* redraw the complete with data starting from view->start bytes into the file.\n * stop once the screen is full, update view->end, view->lastline */\nvoid view_draw(View *view) {\n\tview_clear(view);\n\t/* read a screenful of text considering each character as 4-byte UTF character*/\n\tconst size_t size = view->width * view->height * 4;\n\t/* current buffer to work with */\n\tchar *text = view->textbuf;\n\t/* remaining bytes to process in buffer */\n\tsize_t rem = text_bytes_get(view->text, view->start, size, text);\n\t/* NUL terminate text section */\n\ttext[rem] = '\\0';\n\t/* absolute position of character currently being added to display */\n\tsize_t pos = view->start;\n\t/* current position into buffer from which to interpret a character */\n\tchar *cur = text;\n\t/* start from known multibyte state */\n\tmbstate_t mbstate = { 0 };\n\n\tCell cell = { .data = \"\", .len = 0, .width = 0, }, prev_cell = cell;\n\n\twhile (rem > 0) {\n\n\t\t/* current 'parsed' character' */\n\t\twchar_t wchar;\n\n\t\tsize_t len = mbrtowc(&wchar, cur, rem, &mbstate);\n\t\tif (len == (size_t)-1 && errno == EILSEQ) {\n\t\t\t/* ok, we encountered an invalid multibyte sequence,\n\t\t\t * replace it with the Unicode Replacement Character\n\t\t\t * (FFFD) and skip until the start of the next utf8 char */\n\t\t\tmbstate = (mbstate_t){0};\n\t\t\tfor (len = 1; rem > len && !ISUTF8(cur[len]); len++);\n\t\t\tcell = (Cell){ .data = \"\\xEF\\xBF\\xBD\", .len = len, .width = 1 };\n\t\t} else if (len == (size_t)-2) {\n\t\t\t/* not enough bytes available to convert to a\n\t\t\t * wide character. Advance file position and read\n\t\t\t * another junk into buffer.\n\t\t\t */\n\t\t\trem = text_bytes_get(view->text, pos+prev_cell.len, size, text);\n\t\t\ttext[rem] = '\\0';\n\t\t\tcur = text;\n\t\t\tcontinue;\n\t\t} else if (len == 0) {\n\t\t\t/* NUL byte encountered, store it and continue */\n\t\t\tcell = (Cell){ .data = \"\\x00\", .len = 1, .width = 2 };\n\t\t} else {\n\t\t\tif (len >= sizeof(cell.data))\n\t\t\t\tlen = sizeof(cell.data)-1;\n\t\t\tfor (size_t i = 0; i < len; i++)\n\t\t\t\tcell.data[i] = cur[i];\n\t\t\tcell.data[len] = '\\0';\n\t\t\tcell.len = len;\n\t\t\tcell.width = wcwidth(wchar);\n\t\t\tif (cell.width == -1)\n\t\t\t\tcell.width = 1;\n\t\t}\n\n\t\tif (cell.width == 0) {\n\t\t\tstrncat(prev_cell.data, cell.data, sizeof(prev_cell.data)-strlen(prev_cell.data)-1);\n\t\t\tprev_cell.len += cell.len;\n\t\t} else {\n\t\t\tif (prev_cell.len && !view_addch(view, &prev_cell))\n\t\t\t\tbreak;\n\t\t\tpos += prev_cell.len;\n\t\t\tprev_cell = cell;\n\t\t}\n\n \t\trem -= cell.len;\n\t\tcur += cell.len;\n\n\t\tmemset(&cell, 0, sizeof cell);\n\t}\n\n\tif (prev_cell.len && view_addch(view, &prev_cell))\n\t\tpos += prev_cell.len;\n\n\t/* set end of viewing region */\n\tview->end = pos;\n\tif (view->line) {\n\t\tbool eof = view->end == text_size(view->text);\n\t\tif (view->line->len == 0 && eof && view->line->prev)\n\t\t\tview->lastline = view->line->prev;\n\t\telse\n\t\t\tview->lastline = view->line;\n\t} else {\n\t\tview->lastline = view->bottomline;\n\t}\n\n\t/* clear remaining of line, important to show cursor at end of file */\n\tif (view->line) {\n\t\tfor (int x = view->col; x < view->width; x++)\n\t\t\tview->line->cells[x] = cell_blank;\n\t}\n\n\t/* resync position of cursors within visible area */\n\tfor (Selection *s = view->selections; s; s = s->next) {\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tif (!view_coord_get(view, pos, &s->line, &s->row, &s->col) &&\n\t\t    s == view->selection) {\n\t\t\ts->line = view->topline;\n\t\t\ts->row = 0;\n\t\t\ts->col = 0;\n\t\t}\n\t}\n\n\tview->need_update = true;\n}\n\nbool view_update(View *view) {\n\tif (!view->need_update)\n\t\treturn false;\n\tfor (Line *l = view->lastline->next; l; l = l->next) {\n\t\tfor (int x = 0; x < view->width; x++)\n\t\t\tl->cells[x] = cell_blank;\n\t}\n\tview->need_update = false;\n\treturn true;\n}\n\nbool view_resize(View *view, int width, int height) {\n\tif (width <= 0)\n\t\twidth = 1;\n\tif (height <= 0)\n\t\theight = 1;\n\tif (view->width == width && view->height == height) {\n\t\tview->need_update = true;\n\t\treturn true;\n\t}\n\tchar *textbuf = malloc(width * height * 4 + 1);\n\tif (!textbuf)\n\t\treturn false;\n\tsize_t lines_size = height*(sizeof(Line) + width*sizeof(Cell));\n\tif (lines_size > view->lines_size) {\n\t\tLine *lines = realloc(view->lines, lines_size);\n\t\tif (!lines) {\n\t\t\tfree(textbuf);\n\t\t\treturn false;\n\t\t}\n\t\tview->lines = lines;\n\t\tview->lines_size = lines_size;\n\t}\n\tfree(view->textbuf);\n\tview->textbuf = textbuf;\n\tview->width = width;\n\tview->height = height;\n\tmemset(view->lines, 0, view->lines_size);\n\tview_draw(view);\n\treturn true;\n}\n\nvoid view_free(View *view) {\n\tif (!view)\n\t\treturn;\n\twhile (view->selections)\n\t\tselection_free(view->selections);\n\tfree(view->textbuf);\n\tfree(view->lines);\n\tfree(view->breakat);\n}\n\nvoid view_reload(View *view, Text *text) {\n\tview->text = text;\n\tview_selections_clear_all(view);\n\tview_cursors_to(view->selection, 0);\n}\n\nbool view_init(Win *win, Text *text) {\n\tView *view = &win->view;\n\tif (!text)\n\t\treturn false;\n\n\tview->text = text;\n\tview->tabwidth = 8;\n\tview->breakat = strdup(\"\");\n\tview->wrapcolumn = 0;\n\twin_options_set(win, 0);\n\n\tif (!view->breakat ||\n\t    !view_selections_new(view, 0) ||\n\t    !view_resize(view, 1, 1))\n\t{\n\t\treturn false;\n\t}\n\n\tview_cursors_to(view->selection, 0);\n\treturn true;\n}\n\nstatic size_t cursor_set(Selection *sel, Line *line, int col) {\n\tint row = 0;\n\tView *view = sel->view;\n\tsize_t pos = view->start;\n\t/* get row number and file offset at start of the given line */\n\tfor (Line *l = view->topline; l && l != line; l = l->next) {\n\t\tpos += l->len;\n\t\trow++;\n\t}\n\n\t/* for characters which use more than 1 column, make sure we are on the left most */\n\twhile (col > 0 && line->cells[col].len == 0)\n\t\tcol--;\n\t/* calculate offset within the line */\n\tfor (int i = 0; i < col; i++)\n\t\tpos += line->cells[i].len;\n\n\tsel->col = col;\n\tsel->row = row;\n\tsel->line = line;\n\n\tcursor_to(sel, pos);\n\n\treturn pos;\n}\n\nstatic bool view_viewport_down(View *view, int n) {\n\tLine *line;\n\tif (view->end >= text_size(view->text))\n\t\treturn false;\n\tif (n >= view->height) {\n\t\tview->start = view->end;\n\t} else {\n\t\tfor (line = view->topline; line && n > 0; line = line->next, n--)\n\t\t\tview->start += line->len;\n\t}\n\tview_draw(view);\n\treturn true;\n}\n\nstatic bool view_viewport_up(View *view, int n) {\n\t/* scrolling up is somewhat tricky because we do not yet know where\n\t * the lines start, therefore scan backwards but stop at a reasonable\n\t * maximum in case we are dealing with a file without any newlines\n\t */\n\tif (view->start == 0)\n\t\treturn false;\n\tsize_t max = view->width * view->height;\n\tchar c;\n\tIterator it = text_iterator_get(view->text, view->start - 1);\n\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn false;\n\tsize_t off = 0;\n\t/* skip newlines immediately before display area */\n\tif (c == '\\n' && text_iterator_byte_prev(&it, &c))\n\t\toff++;\n\tdo {\n\t\tif (c == '\\n' && --n == 0)\n\t\t\tbreak;\n\t\tif (++off > max)\n\t\t\tbreak;\n\t} while (text_iterator_byte_prev(&it, &c));\n\tview->start -= MIN(view->start, off);\n\tview_draw(view);\n\treturn true;\n}\n\nvoid view_redraw_top(View *view) {\n\tLine *line = view->selection->line;\n\tfor (Line *cur = view->topline; cur && cur != line; cur = cur->next)\n\t\tview->start += cur->len;\n\tview_draw(view);\n\t/* FIXME: does this logic make sense */\n\tview_cursors_to(view->selection, view->selection->pos);\n}\n\nvoid view_redraw_center(View *view) {\n\tint center = view->height / 2;\n\tsize_t pos = view->selection->pos;\n\tfor (int i = 0; i < 2; i++) {\n\t\tint linenr = 0;\n\t\tLine *line = view->selection->line;\n\t\tfor (Line *cur = view->topline; cur && cur != line; cur = cur->next)\n\t\t\tlinenr++;\n\t\tif (linenr < center) {\n\t\t\tview_slide_down(view, center - linenr);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (Line *cur = view->topline; cur && cur != line && linenr > center; cur = cur->next) {\n\t\t\tview->start += cur->len;\n\t\t\tlinenr--;\n\t\t}\n\t\tbreak;\n\t}\n\tview_draw(view);\n\tview_cursors_to(view->selection, pos);\n}\n\nvoid view_redraw_bottom(View *view) {\n\tsize_t pos = view->selection->pos;\n\tview_viewport_up(view, view->height);\n\twhile (pos >= view->end && view_viewport_down(view, 1));\n\tcursor_to(view->selection, pos);\n}\n\nsize_t view_slide_up(View *view, int lines) {\n\tSelection *sel = view->selection;\n\tif (view_viewport_down(view, lines)) {\n\t\tif (sel->line == view->topline)\n\t\t\tcursor_set(sel, view->topline, sel->col);\n\t\telse\n\t\t\tview_cursors_to(view->selection, sel->pos);\n\t} else {\n\t\tview_screenline_down(sel);\n\t}\n\treturn sel->pos;\n}\n\nsize_t view_slide_down(View *view, int lines) {\n\tSelection *sel = view->selection;\n\tbool lastline = sel->line == view->lastline;\n\tsize_t col = sel->col;\n\tif (view_viewport_up(view, lines)) {\n\t\tif (lastline)\n\t\t\tcursor_set(sel, view->lastline, col);\n\t\telse\n\t\t\tview_cursors_to(view->selection, sel->pos);\n\t} else {\n\t\tview_screenline_up(sel);\n\t}\n\treturn sel->pos;\n}\n\nsize_t view_scroll_up(View *view, int lines) {\n\tSelection *sel = view->selection;\n\tif (view_viewport_up(view, lines)) {\n\t\tLine *line = sel->line < view->lastline ? sel->line : view->lastline;\n\t\tcursor_set(sel, line, view->selection->col);\n\t} else {\n\t\tview_cursors_to(view->selection, 0);\n\t}\n\treturn sel->pos;\n}\n\nsize_t view_scroll_page_up(View *view) {\n\tSelection *sel = view->selection;\n\tif (view->start == 0) {\n\t\tview_cursors_to(view->selection, 0);\n\t} else {\n\t\tview_cursors_to(view->selection, view->start-1);\n\t\tview_redraw_bottom(view);\n\t\tview_screenline_begin(sel);\n\t}\n\treturn sel->pos;\n}\n\nsize_t view_scroll_page_down(View *view) {\n\tview_scroll_down(view, view->height);\n\treturn view_screenline_begin(view->selection);\n}\n\nsize_t view_scroll_halfpage_up(View *view) {\n\tSelection *sel = view->selection;\n\tif (view->start == 0) {\n\t\tview_cursors_to(view->selection, 0);\n\t} else {\n\t\tview_cursors_to(view->selection, view->start-1);\n\t\tview_redraw_center(view);\n\t\tview_screenline_begin(sel);\n\t}\n\treturn sel->pos;\n}\n\nsize_t view_scroll_halfpage_down(View *view) {\n\tsize_t end = view->end;\n\tsize_t pos = view_scroll_down(view, view->height/2);\n\tif (pos < text_size(view->text))\n\t\tview_cursors_to(view->selection, end);\n\treturn view->selection->pos;\n}\n\nsize_t view_scroll_down(View *view, int lines) {\n\tSelection *sel = view->selection;\n\tif (view_viewport_down(view, lines)) {\n\t\tLine *line = sel->line > view->topline ? sel->line : view->topline;\n\t\tcursor_set(sel, line, sel->col);\n\t} else {\n\t\tview_cursors_to(view->selection, text_size(view->text));\n\t}\n\treturn sel->pos;\n}\n\nsize_t view_line_up(Selection *sel) {\n\tView *view = sel->view;\n\tint lastcol = sel->lastcol;\n\tif (!lastcol)\n\t\tlastcol = sel->col;\n\tsize_t pos = text_line_up(sel->view->text, sel->pos);\n\tbool offscreen = view->selection == sel && pos < view->start;\n\tview_cursors_to(sel, pos);\n\tif (offscreen)\n\t\tview_redraw_top(view);\n\tif (sel->line)\n\t\tcursor_set(sel, sel->line, lastcol);\n\tsel->lastcol = lastcol;\n\treturn sel->pos;\n}\n\nsize_t view_line_down(Selection *sel) {\n\tView *view = sel->view;\n\tint lastcol = sel->lastcol;\n\tif (!lastcol)\n\t\tlastcol = sel->col;\n\tsize_t pos = text_line_down(sel->view->text, sel->pos);\n\tbool offscreen = view->selection == sel && pos > view->end;\n\tview_cursors_to(sel, pos);\n\tif (offscreen)\n\t\tview_redraw_bottom(view);\n\tif (sel->line)\n\t\tcursor_set(sel, sel->line, lastcol);\n\tsel->lastcol = lastcol;\n\treturn sel->pos;\n}\n\nsize_t view_screenline_up(Selection *sel) {\n\tif (!sel->line)\n\t\treturn view_line_up(sel);\n\tint lastcol = sel->lastcol;\n\tif (!lastcol)\n\t\tlastcol = sel->col;\n\tif (!sel->line->prev)\n\t\tview_scroll_up(sel->view, 1);\n\tif (sel->line->prev)\n\t\tcursor_set(sel, sel->line->prev, lastcol);\n\tsel->lastcol = lastcol;\n\treturn sel->pos;\n}\n\nsize_t view_screenline_down(Selection *sel) {\n\tif (!sel->line)\n\t\treturn view_line_down(sel);\n\tint lastcol = sel->lastcol;\n\tif (!lastcol)\n\t\tlastcol = sel->col;\n\tif (!sel->line->next && sel->line == sel->view->bottomline)\n\t\tview_scroll_down(sel->view, 1);\n\tif (sel->line->next)\n\t\tcursor_set(sel, sel->line->next, lastcol);\n\tsel->lastcol = lastcol;\n\treturn sel->pos;\n}\n\nsize_t view_screenline_begin(Selection *sel) {\n\tif (!sel->line)\n\t\treturn sel->pos;\n\treturn cursor_set(sel, sel->line, 0);\n}\n\nsize_t view_screenline_middle(Selection *sel) {\n\tif (!sel->line)\n\t\treturn sel->pos;\n\treturn cursor_set(sel, sel->line, sel->line->width / 2);\n}\n\nsize_t view_screenline_end(Selection *sel) {\n\tif (!sel->line)\n\t\treturn sel->pos;\n\tint col = sel->line->width - 1;\n\treturn cursor_set(sel, sel->line, col >= 0 ? col : 0);\n}\n\nsize_t view_cursor_get(View *view) {\n\treturn view_cursors_pos(view->selection);\n}\n\nvoid view_scroll_to(View *view, size_t pos) {\n\tview_cursors_scroll_to(view->selection, pos);\n}\n\nvoid win_options_set(Win *win, enum UiOption options) {\n\tconst int mapping[] = {\n\t\t[SYNTAX_SYMBOL_SPACE]    = UI_OPTION_SYMBOL_SPACE,\n\t\t[SYNTAX_SYMBOL_TAB]      = UI_OPTION_SYMBOL_TAB,\n\t\t[SYNTAX_SYMBOL_TAB_FILL] = UI_OPTION_SYMBOL_TAB_FILL,\n\t\t[SYNTAX_SYMBOL_EOL]      = UI_OPTION_SYMBOL_EOL,\n\t\t[SYNTAX_SYMBOL_EOF]      = UI_OPTION_SYMBOL_EOF,\n\t};\n\n\tfor (int i = 0; i < LENGTH(mapping); i++) {\n\t\twin->view.symbols[i] = (options & mapping[i]) ? symbols_default[i] :\n\t\t\tsymbols_none[i];\n\t}\n\n\tif (options & UI_OPTION_LINE_NUMBERS_ABSOLUTE)\n\t\toptions &= ~UI_OPTION_LARGE_FILE;\n\n\twin->view.large_file = (options & UI_OPTION_LARGE_FILE);\n\n\tui_window_options_set(win, options);\n}\n\nbool view_breakat_set(View *view, const char *breakat) {\n\tchar *copy = strdup(breakat);\n\tif (!copy)\n\t\treturn false;\n\tfree(view->breakat);\n\tview->breakat = copy;\n\treturn true;\n}\n\nsize_t view_screenline_goto(View *view, int n) {\n\tsize_t pos = view->start;\n\tfor (Line *line = view->topline; --n > 0 && line != view->lastline; line = line->next)\n\t\tpos += line->len;\n\treturn pos;\n}\n\nstatic Selection *selections_new(View *view, size_t pos, bool force) {\n\tif (pos > text_size(view->text))\n\t\treturn NULL;\n\tSelection *s = calloc(1, sizeof(*s));\n\tif (!s)\n\t\treturn NULL;\n\ts->view = view;\n\ts->generation = view->selection_generation;\n\tif (!view->selections) {\n\t\tview->selection = s;\n\t\tview->selection_latest = s;\n\t\tview->selections = s;\n\t\tview->selection_count = 1;\n\t\treturn s;\n\t}\n\n\tSelection *prev = NULL, *next = NULL;\n\tSelection *latest = view->selection_latest ? view->selection_latest : view->selection;\n\tsize_t cur = view_cursors_pos(latest);\n\tif (pos == cur) {\n\t\tprev = latest;\n\t\tnext = prev->next;\n\t} else if (pos > cur) {\n\t\tprev = latest;\n\t\tfor (next = prev->next; next; prev = next, next = next->next) {\n\t\t\tcur = view_cursors_pos(next);\n\t\t\tif (pos <= cur)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (pos < cur) {\n\t\tnext = latest;\n\t\tfor (prev = next->prev; prev; next = prev, prev = prev->prev) {\n\t\t\tcur = view_cursors_pos(prev);\n\t\t\tif (pos >= cur)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pos == cur && !force)\n\t\tgoto err;\n\n\tfor (Selection *after = next; after; after = after->next)\n\t\tafter->number++;\n\n\ts->prev = prev;\n\ts->next = next;\n\tif (next)\n\t\tnext->prev = s;\n\tif (prev) {\n\t\tprev->next = s;\n\t\ts->number = prev->number + 1;\n\t} else {\n\t\tview->selections = s;\n\t}\n\tview->selection_latest = s;\n\tview->selection_count++;\n\tview_selections_dispose(view->selection_dead);\n\tview_cursors_to(s, pos);\n\treturn s;\nerr:\n\tfree(s);\n\treturn NULL;\n}\n\nSelection *view_selections_new(View *view, size_t pos) {\n\treturn selections_new(view, pos, false);\n}\n\nSelection *view_selections_new_force(View *view, size_t pos) {\n\treturn selections_new(view, pos, true);\n}\n\nint view_selections_number(Selection *sel) {\n\treturn sel->number;\n}\n\nint view_selections_column_count(View *view) {\n\tText *txt = view->text;\n\tint cpl_max = 0, cpl = 0; /* cursors per line */\n\tsize_t line_prev = 0;\n\tfor (Selection *sel = view->selections; sel; sel = sel->next) {\n\t\tsize_t pos = view_cursors_pos(sel);\n\t\tsize_t line = text_lineno_by_pos(txt, pos);\n\t\tif (line == line_prev)\n\t\t\tcpl++;\n\t\telse\n\t\t\tcpl = 1;\n\t\tline_prev = line;\n\t\tif (cpl > cpl_max)\n\t\t\tcpl_max = cpl;\n\t}\n\treturn cpl_max;\n}\n\nstatic Selection *selections_column_next(View *view, Selection *sel, int column) {\n\tsize_t line_cur = 0;\n\tint column_cur = 0;\n\tText *txt = view->text;\n\tif (sel) {\n\t\tsize_t pos = view_cursors_pos(sel);\n\t\tline_cur = text_lineno_by_pos(txt, pos);\n\t\tcolumn_cur = INT_MIN;\n\t} else {\n\t\tsel = view->selections;\n\t}\n\n\tfor (; sel; sel = sel->next) {\n\t\tsize_t pos = view_cursors_pos(sel);\n\t\tsize_t line = text_lineno_by_pos(txt, pos);\n\t\tif (line != line_cur) {\n\t\t\tline_cur = line;\n\t\t\tcolumn_cur = 0;\n\t\t} else {\n\t\t\tcolumn_cur++;\n\t\t}\n\t\tif (column == column_cur)\n\t\t\treturn sel;\n\t}\n\treturn NULL;\n}\n\nSelection *view_selections_column(View *view, int column) {\n\treturn selections_column_next(view, NULL, column);\n}\n\nSelection *view_selections_column_next(Selection *sel, int column) {\n\treturn selections_column_next(sel->view, sel, column);\n}\n\nstatic void selection_free(Selection *s) {\n\tif (!s)\n\t\treturn;\n\tfor (Selection *after = s->next; after; after = after->next)\n\t\tafter->number--;\n\tif (s->prev)\n\t\ts->prev->next = s->next;\n\tif (s->next)\n\t\ts->next->prev = s->prev;\n\tif (s->view->selections == s)\n\t\ts->view->selections = s->next;\n\tif (s->view->selection == s)\n\t\ts->view->selection = s->next ? s->next : s->prev;\n\tif (s->view->selection_dead == s)\n\t\ts->view->selection_dead = NULL;\n\tif (s->view->selection_latest == s)\n\t\ts->view->selection_latest = s->prev ? s->prev : s->next;\n\ts->view->selection_count--;\n\tfree(s);\n}\n\nbool view_selections_dispose(Selection *sel) {\n\tif (!sel)\n\t\treturn true;\n\tView *view = sel->view;\n\tif (!view->selections || !view->selections->next)\n\t\treturn false;\n\tselection_free(sel);\n\tview_selections_primary_set(view->selection);\n\treturn true;\n}\n\nbool view_selections_dispose_force(Selection *sel) {\n\tif (view_selections_dispose(sel))\n\t\treturn true;\n\tView *view = sel->view;\n\tif (view->selection_dead)\n\t\treturn false;\n\tview_selection_clear(sel);\n\tview->selection_dead = sel;\n\treturn true;\n}\n\nSelection *view_selection_disposed(View *view) {\n\tSelection *sel = view->selection_dead;\n\tview->selection_dead = NULL;\n\treturn sel;\n}\n\nSelection *view_selections(View *view) {\n\tview->selection_generation++;\n\treturn view->selections;\n}\n\nSelection *view_selections_primary_get(View *view) {\n\tview->selection_generation++;\n\treturn view->selection;\n}\n\nvoid view_selections_primary_set(Selection *s) {\n\tif (!s)\n\t\treturn;\n\ts->view->selection = s;\n\tMark anchor = s->anchor;\n\tview_cursors_to(s, view_cursors_pos(s));\n\ts->anchor = anchor;\n}\n\nSelection *view_selections_prev(Selection *s) {\n\tView *view = s->view;\n\tfor (s = s->prev; s; s = s->prev) {\n\t\tif (s->generation != view->selection_generation)\n\t\t\treturn s;\n\t}\n\tview->selection_generation++;\n\treturn NULL;\n}\n\nSelection *view_selections_next(Selection *s) {\n\tView *view = s->view;\n\tfor (s = s->next; s; s = s->next) {\n\t\tif (s->generation != view->selection_generation)\n\t\t\treturn s;\n\t}\n\tview->selection_generation++;\n\treturn NULL;\n}\n\nsize_t view_cursors_pos(Selection *s) {\n\treturn text_mark_get(s->view->text, s->cursor);\n}\n\nsize_t view_cursors_line(Selection *s) {\n\tsize_t pos = view_cursors_pos(s);\n\treturn text_lineno_by_pos(s->view->text, pos);\n}\n\nsize_t view_cursors_col(Selection *s) {\n\tsize_t pos = view_cursors_pos(s);\n\treturn text_line_char_get(s->view->text, pos) + 1;\n}\n\nint view_cursors_cell_set(Selection *s, int cell) {\n\tif (!s->line || cell < 0)\n\t\treturn -1;\n\tcursor_set(s, s->line, cell);\n\treturn s->col;\n}\n\nvoid view_cursors_scroll_to(Selection *s, size_t pos) {\n\tView *view = s->view;\n\tif (view->selection == s) {\n\t\tview_draw(view);\n\t\twhile (pos < view->start && view_viewport_up(view, 1));\n\t\twhile (pos > view->end && view_viewport_down(view, 1));\n\t}\n\tview_cursors_to(s, pos);\n}\n\nvoid view_cursors_to(Selection *s, size_t pos) {\n\tView *view = s->view;\n\tif (pos == EPOS)\n\t\treturn;\n\tsize_t size = text_size(view->text);\n\tif (pos > size)\n\t\tpos = size;\n\tif (s->view->selection == s) {\n\t\t/* make sure we redraw changes to the very first character of the window */\n\t\tif (view->start == pos)\n\t\t\tview->start_last = 0;\n\n\t\tif (view->end == pos && view->lastline == view->bottomline) {\n\t\t\tview->start += view->topline->len;\n\t\t\tview_draw(view);\n\t\t}\n\n\t\tif (pos < view->start || pos > view->end) {\n\t\t\tview->start = pos;\n\t\t\tview_viewport_up(view, view->height / 2);\n\t\t}\n\n\t\tif (pos <= view->start || pos > view->end) {\n\t\t\tview->start = text_line_begin(view->text, pos);\n\t\t\tview_draw(view);\n\t\t}\n\n\t\tif (pos <= view->start || pos > view->end) {\n\t\t\tview->start = pos;\n\t\t\tview_draw(view);\n\t\t}\n\t}\n\n\tcursor_to(s, pos);\n}\n\nvoid view_cursors_place(Selection *s, size_t line, size_t col) {\n\tText *txt = s->view->text;\n\tsize_t pos = text_pos_by_lineno(txt, line);\n\tpos = text_line_char_set(txt, pos, col > 0 ? col-1 : col);\n\tview_cursors_to(s, pos);\n}\n\nvoid view_selection_clear(Selection *s) {\n\ts->anchored = false;\n\ts->anchor = s->cursor;\n\ts->view->need_update = true;\n}\n\nvoid view_selections_flip(Selection *s) {\n\tMark temp = s->anchor;\n\ts->anchor = s->cursor;\n\ts->cursor = temp;\n\tview_cursors_to(s, text_mark_get(s->view->text, s->cursor));\n}\n\nvoid view_selections_clear_all(View *view) {\n\tfor (Selection *s = view->selections; s; s = s->next)\n\t\tview_selection_clear(s);\n\tview_draw(view);\n}\n\nvoid view_selections_dispose_all(View *view) {\n\tSelection *last = view->selections;\n\twhile (last->next)\n\t\tlast = last->next;\n\tfor (Selection *s = last, *prev; s; s = prev) {\n\t\tprev = s->prev;\n\t\tif (s != view->selection)\n\t\t\tselection_free(s);\n\t}\n\tview_draw(view);\n}\n\nFilerange view_selections_get(Selection *s) {\n\tif (!s)\n\t\treturn text_range_empty();\n\tText *txt = s->view->text;\n\tsize_t anchor = text_mark_get(txt, s->anchor);\n\tsize_t cursor = text_mark_get(txt, s->cursor);\n\tFilerange sel = text_range_new(anchor, cursor);\n\tif (text_range_valid(&sel))\n\t\tsel.end = text_char_next(txt, sel.end);\n\treturn sel;\n}\n\nbool view_selections_set(Selection *s, const Filerange *r) {\n\tText *txt = s->view->text;\n\tsize_t max = text_size(txt);\n\tif (!text_range_valid(r) || r->start >= max)\n\t\treturn false;\n\tsize_t anchor = text_mark_get(txt, s->anchor);\n\tsize_t cursor = text_mark_get(txt, s->cursor);\n\tbool left_extending = anchor != EPOS && anchor > cursor;\n\tsize_t end = r->end > max ? max : r->end;\n\tif (r->start != end)\n\t\tend = text_char_prev(txt, end);\n\tview_cursors_to(s, left_extending ? r->start : end);\n\ts->anchor = text_mark_set(txt, left_extending ? end : r->start);\n\treturn true;\n}\n\nFilerange view_regions_restore(View *view, SelectionRegion *s) {\n\tText *txt = view->text;\n\tsize_t anchor = text_mark_get(txt, s->anchor);\n\tsize_t cursor = text_mark_get(txt, s->cursor);\n\tFilerange sel = text_range_new(anchor, cursor);\n\tif (text_range_valid(&sel))\n\t\tsel.end = text_char_next(txt, sel.end);\n\treturn sel;\n}\n\nbool view_regions_save(View *view, Filerange *r, SelectionRegion *s) {\n\tText *txt = view->text;\n\tsize_t max = text_size(txt);\n\tif (!text_range_valid(r) || r->start >= max)\n\t\treturn false;\n\tsize_t end = r->end > max ? max : r->end;\n\tif (r->start != end)\n\t\tend = text_char_prev(txt, end);\n\ts->anchor = text_mark_set(txt, r->start);\n\ts->cursor = text_mark_set(txt, end);\n\treturn true;\n}\n\nvoid view_selections_set_all(View *view, Array *arr, bool anchored) {\n\tSelection *s;\n\tFilerange *r;\n\tsize_t i = 0;\n\tfor (s = view->selections; s; s = s->next) {\n\t\tif (!(r = array_get(arr, i++)) || !view_selections_set(s, r)) {\n\t\t\tfor (Selection *next; s; s = next) {\n\t\t\t\tnext = view_selections_next(s);\n\t\t\t\tif (i == 1 && s == view->selection)\n\t\t\t\t\tview_selection_clear(s);\n\t\t\t\telse\n\t\t\t\t\tview_selections_dispose(s);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\ts->anchored = anchored;\n\t}\n\twhile ((r = array_get(arr, i++))) {\n\t\ts = view_selections_new_force(view, r->start);\n\t\tif (!s || !view_selections_set(s, r))\n\t\t\tbreak;\n\t\ts->anchored = anchored;\n\t}\n\tview_selections_primary_set(view->selections);\n}\n\nArray view_selections_get_all(View *view) {\n\tArray arr;\n\tarray_init_sized(&arr, sizeof(Filerange));\n\tif (!array_reserve(&arr, view->selection_count))\n\t\treturn arr;\n\tfor (Selection *s = view->selections; s; s = s->next) {\n\t\tFilerange r = view_selections_get(s);\n\t\tif (text_range_valid(&r))\n\t\t\tarray_add(&arr, &r);\n\t}\n\treturn arr;\n}\n\nvoid view_selections_normalize(View *view) {\n\tSelection *prev = NULL;\n\tFilerange range_prev = text_range_empty();\n\tfor (Selection *s = view->selections, *next; s; s = next) {\n\t\tnext = s->next;\n\t\tFilerange range = view_selections_get(s);\n\t\tif (!text_range_valid(&range)) {\n\t\t\tview_selections_dispose(s);\n\t\t} else if (prev && text_range_overlap(&range_prev, &range)) {\n\t\t\trange_prev = text_range_union(&range_prev, &range);\n\t\t\tview_selections_dispose(s);\n\t\t} else {\n\t\t\tif (prev)\n\t\t\t\tview_selections_set(prev, &range_prev);\n\t\t\trange_prev = range;\n\t\t\tprev = s;\n\t\t}\n\t}\n\tif (prev)\n\t\tview_selections_set(prev, &range_prev);\n}\n\nvoid win_style(Win *win, enum UiStyle style, size_t start, size_t end) {\n\tView *view = &win->view;\n\tif (end < view->start || start > view->end)\n\t\treturn;\n\n\tsize_t pos = view->start;\n\tLine *line = view->topline;\n\n\t/* skip lines before range to be styled */\n\twhile (line && pos + line->len <= start) {\n\t\tpos += line->len;\n\t\tline = line->next;\n\t}\n\n\tif (!line)\n\t\treturn;\n\n\tint col = 0, width = view->width;\n\n\t/* skip columns before range to be styled */\n\twhile (pos < start && col < width)\n\t\tpos += line->cells[col++].len;\n\n\t/* skip empty columns */\n\twhile (!line->cells[col].len && col < width)\n\t\tcol++;\n\n\tdo {\n\t\twhile (pos <= end && col < width) {\n\t\t\tpos += line->cells[col].len;\n\t\t\tui_window_style_set(&win->vis->ui, win->id, &line->cells[col++], style);\n\t\t}\n\t\tcol = 0;\n\t} while (pos <= end && (line = line->next));\n}\n"
        },
        {
          "name": "view.h",
          "type": "blob",
          "size": 11.6845703125,
          "content": "#ifndef VIEW_H\n#define VIEW_H\n\n#include <stddef.h>\n#include <stdbool.h>\n\n#include \"ui.h\"\n#include \"text.h\"\n#include \"array.h\"\n\nenum {\n\tSYNTAX_SYMBOL_SPACE,\n\tSYNTAX_SYMBOL_TAB,\n\tSYNTAX_SYMBOL_TAB_FILL,\n\tSYNTAX_SYMBOL_EOL,\n\tSYNTAX_SYMBOL_EOF,\n\tSYNTAX_SYMBOL_LAST,\n};\n\ntypedef struct {\n\tMark anchor;\n\tMark cursor;\n} SelectionRegion;\n\ntypedef struct Line Line;\nstruct Line {               /* a line on the screen, *not* in the file */\n\tLine *prev, *next;  /* pointer to neighbouring screen lines */\n\tsize_t len;         /* line length in terms of bytes */\n\tsize_t lineno;      /* line number from start of file */\n\tint width;          /* zero based position of last used column cell */\n\tCell cells[];       /* win->width cells storing information about the displayed characters */\n};\n\nstruct View;\ntypedef struct Selection {\n\tMark cursor;            /* other selection endpoint where it changes */\n\tMark anchor;            /* position where the selection was created */\n\tbool anchored;          /* whether anchor remains fixed */\n\tsize_t pos;             /* in bytes from the start of the file */\n\tint row, col;           /* in terms of zero based screen coordinates */\n\tint lastcol;            /* remembered column used when moving across lines */\n\tLine *line;             /* screen line on which cursor currently resides */\n\tint generation;         /* used to filter out newly created cursors during iteration */\n\tint number;             /* how many cursors are located before this one */\n\tstruct View *view;      /* associated view to which this cursor belongs */\n\tstruct Selection *prev, *next; /* previous/next cursors ordered by location at creation time */\n} Selection;\n\ntypedef struct View {\n\tText *text;         /* underlying text management */\n\tchar *textbuf;      /* scratch buffer used for drawing */\n\tint width, height;  /* size of display area */\n\tsize_t start, end;  /* currently displayed area [start, end] in bytes from the start of the file */\n\tsize_t start_last;  /* previously used start of visible area, used to update the mark */\n\tMark start_mark;    /* mark to keep track of the start of the visible area */\n\tsize_t lines_size;  /* number of allocated bytes for lines (grows only) */\n\tLine *lines;        /* view->height number of lines representing view content */\n\tLine *topline;      /* top of the view, first line currently shown */\n\tLine *lastline;     /* last currently used line, always <= bottomline */\n\tLine *bottomline;   /* bottom of view, might be unused if lastline < bottomline */\n\tSelection *selection;    /* primary selection, always placed within the visible viewport */\n\tSelection *selection_latest; /* most recently created cursor */\n\tSelection *selection_dead;   /* primary cursor which was disposed, will be removed when another cursor is created */\n\tint selection_count;   /* how many cursors do currently exist */\n\tLine *line;         /* used while drawing view content, line where next char will be drawn */\n\tint col;            /* used while drawing view content, column where next char will be drawn */\n\tconst char *symbols[SYNTAX_SYMBOL_LAST]; /* symbols to use for white spaces etc */\n\tint tabwidth;       /* how many spaces should be used to display a tab character */\n\tSelection *selections;    /* all cursors currently active */\n\tint selection_generation; /* used to filter out newly created cursors during iteration */\n\tbool need_update;   /* whether view has been redrawn */\n\tbool large_file;    /* optimize for displaying large files */\n\tint colorcolumn;\n\tchar *breakat;  /* characters which might cause a word wrap */\n\tint wrapcolumn; /* wrap lines at minimum of window width and wrapcolumn (if != 0) */\n\tint wrapcol;    /* used while drawing view content, column where word wrap might happen */\n\tbool prevch_breakat; /* used while drawing view content, previous char is part of breakat */\n} View;\n\n/**\n * @defgroup view_life\n * @{\n */\nbool view_init(struct Win*, Text*);\nvoid view_free(View*);\nvoid view_reload(View*, Text*);\n/**\n * @}\n * @defgroup view_viewport\n * @{\n */\n/** Get the currently displayed text range. */\n#define VIEW_VIEWPORT_GET(v) (Filerange){ .start = v.start, .end = v.end }\n/**\n * Get window coordinate of text position.\n * @param pos The position to query.\n * @param line Will be updated with screen line on which ``pos`` resides.\n * @param row Will be updated with zero based window row on which ``pos`` resides.\n * @param col Will be updated with zero based window column on which ``pos`` resides.\n * @return Whether ``pos`` is visible. If not, the pointer arguments are left unmodified.\n */\nbool view_coord_get(View*, size_t pos, Line **line, int *row, int *col);\n/** Get position at the start of the ``n``-th window line, counting from 1. */\nsize_t view_screenline_goto(View*, int n);\nsize_t view_slide_up(View*, int lines);\nsize_t view_slide_down(View*, int lines);\nsize_t view_scroll_up(View*, int lines);\nsize_t view_scroll_down(View*, int lines);\nsize_t view_scroll_page_up(View*);\nsize_t view_scroll_page_down(View*);\nsize_t view_scroll_halfpage_up(View*);\nsize_t view_scroll_halfpage_down(View*);\nvoid view_redraw_top(View*);\nvoid view_redraw_center(View*);\nvoid view_redraw_bottom(View*);\nvoid view_scroll_to(View*, size_t pos);\n/**\n * @}\n * @defgroup view_size\n * @{\n */\nbool view_resize(View*, int width, int height);\n/**\n * @}\n * @defgroup view_draw\n * @{\n */\nvoid view_draw(View*);\nbool view_update(View*);\n\n/**\n * @}\n * @defgroup view_selnew\n * @{\n */\n/**\n * Create a new singleton selection at the given position.\n * @rst\n * .. note:: New selections are created non-anchored.\n * .. warning:: Fails if position is already covered by a selection.\n * @endrst\n */\nSelection *view_selections_new(View*, size_t pos);\n/**\n * Create a new selection even if position is already covered by an\n * existing selection.\n * @rst\n * .. note:: This should only be used if the old selection is eventually\n *           disposed.\n * @endrst\n */\nSelection *view_selections_new_force(View*, size_t pos);\n/**\n * Dispose an existing selection.\n * @rst\n * .. warning:: Not applicable for the last existing selection.\n * @endrst\n */\nbool view_selections_dispose(Selection*);\n/**\n * Forcefully dispose an existing selection.\n *\n * If called for the last existing selection, it will be reduced and\n * marked for destruction. As soon as a new selection is created this one\n * will be disposed.\n */\nbool view_selections_dispose_force(Selection*);\n/**\n * Query state of primary selection.\n *\n * If the primary selection was marked for destruction, return it and\n * clear destruction flag.\n */\nSelection *view_selection_disposed(View*);\n/** Dispose all but the primary selection. */\nvoid view_selections_dispose_all(View*);\n/** Dispose all invalid and merge all overlapping selections. */\nvoid view_selections_normalize(View*);\n/**\n * Replace currently active selections.\n * @param array The array of ``Filerange`` objects.\n * @param anchored Whether *all* selection should be anchored.\n */\nvoid view_selections_set_all(View*, Array*, bool anchored);\n/** Get array containing a ``Fileranges`` for each selection. */\nArray view_selections_get_all(View*);\n/**\n * @}\n * @defgroup view_navigate\n * @{\n */\nSelection *view_selections_primary_get(View*);\nvoid view_selections_primary_set(Selection*);\n/** Get first selection. */\nSelection *view_selections(View*);\n/** Get immediate predecessor of selection. */\nSelection *view_selections_prev(Selection*);\n/** Get immediate successor of selection. */\nSelection *view_selections_next(Selection*);\n/**\n * Get selection index.\n * @rst\n * .. note:: Is always in range ``[0, count-1]``.\n * .. warning: The relative order is determined during creation and assumed\n *             to remain the same.\n * @endrst\n */\nint view_selections_number(Selection*);\n/** Get maximal number of selections on a single line. */\nint view_selections_column_count(View*);\n/**\n * Starting from the start of the text, get the `column`-th selection on a line.\n * @param column The zero based column index.\n */\nSelection *view_selections_column(View*, int column);\n/**\n * Get the next `column`-th selection on a line.\n * @param column The zero based column index.\n */\nSelection *view_selections_column_next(Selection*, int column);\n/**\n * @}\n * @defgroup view_cover\n * @{\n */\n/** Get an inclusive range of the selection cover. */\nFilerange view_selections_get(Selection*);\n/** Set selection cover. Updates both cursor and anchor. */\nbool view_selections_set(Selection*, const Filerange*);\n/**\n * Reduce selection to character currently covered by the cursor.\n * @rst\n * .. note:: Sets selection to non-anchored mode.\n * @endrst\n */\nvoid view_selection_clear(Selection*);\n/** Reduce *all* currently active selections. */\nvoid view_selections_clear_all(View*);\n/**\n * Flip selection orientation. Swap cursor and anchor.\n * @rst\n * .. note:: Has no effect on singleton selections.\n * @endrst\n */\nvoid view_selections_flip(Selection*);\n/**\n * @}\n * @defgroup view_props\n * @{\n */\n/** Get position of selection cursor. */\nsize_t view_cursors_pos(Selection*);\n/** Get 1-based line number of selection cursor. */\nsize_t view_cursors_line(Selection*);\n/**\n * Get 1-based column of selection cursor.\n * @rst\n * .. note:: Counts the number of graphemes on the logical line up to the cursor\n *           position.\n * @endrst\n */\nsize_t view_cursors_col(Selection*);\n/**\n * @}\n * @defgroup view_place\n * @{\n */\n/**\n * Place cursor of selection at `pos`.\n * @rst\n * .. note:: If the selection is not anchored, both selection endpoints\n *           will be adjusted to form a singleton selection covering one\n *           character starting at `pos`. Otherwise only the selection\n *           cursor will be changed while the anchor remains fixed.\n *\n *           If primary position was not visible before, we attempt to show\n *           the surrounding context. The viewport will be adjusted such\n *           that the line holding the primary cursor is shown in the middle\n *           of the window.\n * @endrst\n */\nvoid view_cursors_to(Selection*, size_t pos);\n/**\n * Adjusts window viewport until the requested position becomes visible.\n * @rst\n * .. note:: For all but the primary selection this is equivalent to\n *           ``view_selection_to``.\n * .. warning:: Repeatedly redraws the window content. Should only be used for\n *              short distances between current cursor position and destination.\n * @endrst\n */\nvoid view_cursors_scroll_to(Selection*, size_t pos);\n/**\n * Place cursor on given (line, column) pair.\n * @param line the 1-based line number\n * @param col the 1 based column\n * @rst\n * .. note:: Except for the different addressing format this is equivalent to\n *           `view_selection_to`.\n * @endrst\n */\nvoid view_cursors_place(Selection*, size_t line, size_t col);\n/**\n * Place selection cursor on zero based window cell index.\n * @rst\n * .. warning:: Fails if the selection cursor is currently not visible.\n * @endrst\n */\nint view_cursors_cell_set(Selection*, int cell);\n/**\n * @}\n * @defgroup view_motions\n * @{\n */\nsize_t view_line_down(Selection*);\nsize_t view_line_up(Selection*);\nsize_t view_screenline_down(Selection*);\nsize_t view_screenline_up(Selection*);\nsize_t view_screenline_begin(Selection*);\nsize_t view_screenline_middle(Selection*);\nsize_t view_screenline_end(Selection*);\n/**\n * @}\n * @defgroup view_primary\n * @{\n */\n/** Get cursor position of primary selection. */\nsize_t view_cursor_get(View*);\n/**\n * @}\n * @defgroup view_save\n * @{\n */\nFilerange view_regions_restore(View*, SelectionRegion*);\nbool view_regions_save(View*, Filerange*, SelectionRegion*);\n/**\n * @}\n * @defgroup view_style\n * @{\n */\nvoid win_options_set(struct Win *, enum UiOption);\nbool view_breakat_set(View*, const char *breakat);\n\n/** Set how many spaces are used to display a tab `\\t` character. */\nvoid view_tabwidth_set(View*, int tabwidth);\n/** Apply a style to a text range. */\nvoid win_style(struct Win*, enum UiStyle, size_t start, size_t end);\n\n/** @} */\n\n#endif\n"
        },
        {
          "name": "vis-clipboard",
          "type": "blob",
          "size": 2.845703125,
          "content": "#!/bin/sh\n# Copyright (C) 2016 Richard Burke, ISC licensed\n# shellcheck disable=SC2317\nset -e\n\nvc_fatal() {\n\techo \"$@\" >&2\n\texit 1\n}\n\nvc_usage() {\n\tvc_fatal \"Usage: $(basename \"$0\") [--selection sel] [--usable|--copy|--paste]\n\nCopy/paste clipboard interface with support on all provided platforms.\n\nOptions:\n    --copy       copy text from standard input\n    --paste      paste text to standard output\n    --usable     silently exit with a status code indicating if a supported\n                 clipboard implementation was found\n    --selection  take input from sel. valid options: clipboard, primary\"\n}\n\nvc_determine_command() {\n\tif [ -n \"$WAYLAND_DISPLAY\" ]; then\n\t\tfor c in wl-copy wl-paste; do\n\t\t\tif command -v \"$c\" >/dev/null 2>&1; then\n\t\t\t\techo \"wlclipboard\"\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\n\t\tfor c in waycopy waypaste; do\n\t\t\tif command -v \"$c\" >/dev/null 2>&1; then\n\t\t\t\techo \"wayclip\"\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\n\tif [ -n \"$DISPLAY\" ]; then\n\t\tfor c in xclip xsel; do\n\t\t\tif command -v \"$c\" >/dev/null 2>&1; then\n\t\t\t\techo \"$c\"\n\t\t\t\treturn 0\n\t\t\tfi\n\t\tdone\n\tfi\n\n\tif command -v pbcopy >/dev/null 2>&1; then\n\t\techo 'mac'\n\t\treturn 0\n\tfi\n\n\tif [ -c /dev/clipboard ]; then\n\t\techo 'cygwin'\n\t\treturn 0\n\tfi\n\n\treturn 1\n}\n\nvc_usable() {\n\tif vc_determine_command >/dev/null 2>&1; then\n\t\texit 0\n\tfi\n\n\texit 1\n}\n\nvc_copy() {\n\tCOPY_CMD=\"$(vc_determine_command 2>/dev/null)\"\n\n\t# shellcheck disable=SC2181\n\tif [ $? -ne 0 ] || [ -z \"$COPY_CMD\" ]; then\n\t\tvc_fatal 'System clipboard not supported'\n\tfi\n\n\t\"vc_${COPY_CMD}_copy\"\n\n\texit $?\n}\n\nvc_paste() {\n\tPASTE_CMD=\"$(vc_determine_command 2>/dev/null)\"\n\n\t# shellcheck disable=SC2181\n\tif [ $? -ne 0 ] || [ -z \"$PASTE_CMD\" ]; then\n\t\tvc_fatal 'System clipboard not supported'\n\tfi\n\n\t\"vc_${PASTE_CMD}_paste\"\n\n\texit $?\n}\n\nvc_wlclipboard_copy() {\n\tif [ \"$sel\" = \"primary\" ]; then\n\t\twl-copy --primary -t TEXT 2>/dev/null\n\telse\n\t\twl-copy -t TEXT 2>/dev/null\n\tfi\n}\n\nvc_wlclipboard_paste() {\n\tif [ \"$sel\" = \"primary\" ]; then\n\t\twl-paste --no-newline --primary -t text\n\telse\n\t\twl-paste --no-newline -t text\n\tfi\n}\n\nvc_wayclip_copy() {\n\tif [ \"$sel\" = \"primary\" ]; then\n\t\twaycopy -p\n\telse\n\t\twaycopy\n\tfi\n}\n\nvc_wayclip_paste() {\n\tif [ \"$sel\" = \"primary\" ]; then\n\t\twaypaste -p\n\telse\n\t\twaypaste\n\tfi\n}\n\nvc_xsel_copy() {\n\txsel --\"$sel\" -i\n}\n\nvc_xsel_paste() {\n\txsel --\"$sel\" -o\n}\n\nvc_xclip_copy() {\n\txclip -selection \"$sel\" -i >/dev/null 2>&1\n}\n\nvc_xclip_paste() {\n\txclip -selection \"$sel\" -o\n}\n\nvc_mac_copy() {\n\tpbcopy\n}\n\nvc_mac_paste() {\n\tpbpaste\n}\n\nvc_cygwin_copy() {\n\tcat >/dev/clipboard\n}\n\nvc_cygwin_paste() {\n\tcat /dev/clipboard\n}\n\nwhile [ $# -gt 0 ]; do\n\tcase \"$1\" in\n\t\t--usable) fn=vc_usable;;\n\t\t--copy) fn=vc_copy;;\n\t\t--paste) fn=vc_paste;;\n\t\t--selection)\n\t\t\tshift\n\t\t\tif [ \"$1\" != \"clipboard\" ] && [ \"$1\" != \"primary\" ]; then\n\t\t\t\tvc_fatal \"Invalid selection: $1\\nValid options are 'clipboard' or 'primary'\"\n\t\t\tfi\n\t\t\tsel=\"$1\";;\n\t\t*) vc_usage;;\n\tesac\n\tshift\ndone\n\nsel=${sel:-\"clipboard\"} $fn\n\nvc_usage\n"
        },
        {
          "name": "vis-cmds.c",
          "type": "blob",
          "size": 26.2568359375,
          "content": "/* this file is included from sam.c */\n\n#include <termkey.h>\n#include \"vis-lua.h\"\n\n// FIXME: avoid this redirection?\ntypedef struct {\n\tCommandDef def;\n\tVisCommandFunction *func;\n\tvoid *data;\n} CmdUser;\n\nstatic void cmdfree(CmdUser *cmd) {\n\tif (!cmd)\n\t\treturn;\n\tfree((char*)cmd->def.name);\n\tfree(VIS_HELP_USE((char*)cmd->def.help));\n\tfree(cmd);\n}\n\nbool vis_cmd_register(Vis *vis, const char *name, const char *help, void *data, VisCommandFunction *func) {\n\tif (!name)\n\t\treturn false;\n\tif (!vis->usercmds && !(vis->usercmds = map_new()))\n\t\treturn false;\n\tCmdUser *cmd = calloc(1, sizeof *cmd);\n\tif (!cmd)\n\t\treturn false;\n\tif (!(cmd->def.name = strdup(name)))\n\t\tgoto err;\n#if CONFIG_HELP\n\tif (help && !(cmd->def.help = strdup(help)))\n\t\tgoto err;\n#endif\n\tcmd->def.flags = CMD_ARGV|CMD_FORCE|CMD_ONCE|CMD_ADDRESS_ALL;\n\tcmd->def.func = cmd_user;\n\tcmd->func = func;\n\tcmd->data = data;\n\tif (!map_put(vis->cmds, name, &cmd->def))\n\t\tgoto err;\n\tif (!map_put(vis->usercmds, name, cmd)) {\n\t\tmap_delete(vis->cmds, name);\n\t\tgoto err;\n\t}\n\treturn true;\nerr:\n\tcmdfree(cmd);\n\treturn false;\n}\n\nbool vis_cmd_unregister(Vis *vis, const char *name) {\n\tif (!name)\n\t\treturn true;\n\tCmdUser *cmd = map_get(vis->usercmds, name);\n\tif (!cmd)\n\t\treturn false;\n\tif (!map_delete(vis->cmds, name))\n\t\treturn false;\n\tif (!map_delete(vis->usercmds, name))\n\t\treturn false;\n\tcmdfree(cmd);\n\treturn true;\n}\n\nstatic void option_free(OptionDef *opt) {\n\tif (!opt)\n\t\treturn;\n\tfor (size_t i = 0; i < LENGTH(options); i++) {\n\t\tif (opt == &options[i])\n\t\t\treturn;\n\t}\n\n\tfor (const char **name = opt->names; *name; name++)\n\t\tfree((char*)*name);\n\tfree(VIS_HELP_USE((char*)opt->help));\n\tfree(opt);\n}\n\nbool vis_option_register(Vis *vis, const char *names[], enum VisOption flags,\n                         VisOptionFunction *func, void *context, const char *help) {\n\n\tif (!names || !names[0])\n\t\treturn false;\n\n\tfor (const char **name = names; *name; name++) {\n\t\tif (map_get(vis->options, *name))\n\t\t\treturn false;\n\t}\n\tOptionDef *opt = calloc(1, sizeof *opt);\n\tif (!opt)\n\t\treturn false;\n\tfor (size_t i = 0; i < LENGTH(opt->names)-1 && names[i]; i++) {\n\t\tif (!(opt->names[i] = strdup(names[i])))\n\t\t\tgoto err;\n\t}\n\topt->flags = flags;\n\topt->func = func;\n\topt->context = context;\n#if CONFIG_HELP\n\tif (help && !(opt->help = strdup(help)))\n\t\tgoto err;\n#endif\n\tfor (const char **name = names; *name; name++)\n\t\tmap_put(vis->options, *name, opt);\n\treturn true;\nerr:\n\toption_free(opt);\n\treturn false;\n}\n\nbool vis_option_unregister(Vis *vis, const char *name) {\n\tOptionDef *opt = map_get(vis->options, name);\n\tif (!opt)\n\t\treturn false;\n\tfor (const char **alias = opt->names; *alias; alias++) {\n\t\tif (!map_delete(vis->options, *alias))\n\t\t\treturn false;\n\t}\n\toption_free(opt);\n\treturn true;\n}\n\nstatic bool cmd_user(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tCmdUser *user = map_get(vis->usercmds, argv[0]);\n\treturn user && user->func(vis, win, user->data, cmd->flags == '!', argv, sel, range);\n}\n\nvoid vis_shell_set(Vis *vis, const char *new_shell) {\n\tchar *shell =  strdup(new_shell);\n\tif (!shell) {\n\t\tvis_info_show(vis, \"Failed to change shell\");\n\t} else {\n\t\tfree(vis->shell);\n\t\tvis->shell = shell;\n\t}\n}\n\n/* parse human-readable boolean value in s. If successful, store the result in\n * outval and return true. Else return false and leave outval alone. */\nstatic bool parse_bool(const char *s, bool *outval) {\n\tfor (const char **t = (const char*[]){\"1\", \"true\", \"yes\", \"on\", NULL}; *t; t++) {\n\t\tif (!strcasecmp(s, *t)) {\n\t\t\t*outval = true;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (const char **f = (const char*[]){\"0\", \"false\", \"no\", \"off\", NULL}; *f; f++) {\n\t\tif (!strcasecmp(s, *f)) {\n\t\t\t*outval = false;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool cmd_set(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\n\tif (!argv[1] || !argv[1][0] || argv[3]) {\n\t\tvis_info_show(vis, \"Expecting: set option [value]\");\n\t\treturn false;\n\t}\n\n\tchar name[256];\n\tstrncpy(name, argv[1], sizeof(name)-1);\n\tchar *lastchar = &name[strlen(name)-1];\n\tbool toggle = (*lastchar == '!');\n\tif (toggle)\n\t\t*lastchar = '\\0';\n\n\tOptionDef *opt = map_closest(vis->options, name);\n\tif (!opt) {\n\t\tvis_info_show(vis, \"Unknown option: `%s'\", name);\n\t\treturn false;\n\t}\n\n\tif (opt->flags & VIS_OPTION_DEPRECATED && strcmp(opt->context, name) == 0)\n\t\tvis_info_show(vis, \"%s is deprecated and will be removed in the next release\", name);\n\n\tif (!win && (opt->flags & VIS_OPTION_NEED_WINDOW)) {\n\t\tvis_info_show(vis, \"Need active window for `:set %s'\", name);\n\t\treturn false;\n\t}\n\n\tif (toggle) {\n\t\tif (!(opt->flags & VIS_OPTION_TYPE_BOOL)) {\n\t\t\tvis_info_show(vis, \"Only boolean options can be toggled\");\n\t\t\treturn false;\n\t\t}\n\t\tif (argv[2]) {\n\t\t\tvis_info_show(vis, \"Can not specify option value when toggling\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tArg arg;\n\tif (opt->flags & VIS_OPTION_TYPE_STRING) {\n\t\tif (!(opt->flags & VIS_OPTION_VALUE_OPTIONAL) && !argv[2]) {\n\t\t\tvis_info_show(vis, \"Expecting string option value\");\n\t\t\treturn false;\n\t\t}\n\t\targ.s = argv[2];\n\t} else if (opt->flags & VIS_OPTION_TYPE_BOOL) {\n\t\tif (!argv[2]) {\n\t\t\targ.b = !toggle;\n\t\t} else if (!parse_bool(argv[2], &arg.b)) {\n\t\t\tvis_info_show(vis, \"Expecting boolean option value not: `%s'\", argv[2]);\n\t\t\treturn false;\n\t\t}\n\t} else if (opt->flags & VIS_OPTION_TYPE_NUMBER) {\n\t\tif (!argv[2]) {\n\t\t\tvis_info_show(vis, \"Expecting number\");\n\t\t\treturn false;\n\t\t}\n\t\tchar *ep;\n\t\terrno = 0;\n\t\tlong lval = strtol(argv[2], &ep, 10);\n\t\tif (argv[2][0] == '\\0' || *ep != '\\0') {\n\t\t\tvis_info_show(vis, \"Invalid number\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((errno == ERANGE && (lval == LONG_MAX || lval == LONG_MIN)) ||\n\t\t    (lval > INT_MAX || lval < INT_MIN)) {\n\t\t\tvis_info_show(vis, \"Number overflow\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lval < 0) {\n\t\t\tvis_info_show(vis, \"Expecting positive number\");\n\t\t\treturn false;\n\t\t}\n\t\targ.i = lval;\n\t} else {\n\t\treturn false;\n\t}\n\n\tsize_t opt_index = 0;\n\tfor (; opt_index < LENGTH(options); opt_index++) {\n\t\tif (opt == &options[opt_index])\n\t\t\tbreak;\n\t}\n\n\tswitch (opt_index) {\n\tcase OPTION_SHELL:\n\t\tvis_shell_set(vis, arg.s);\n\t\tbreak;\n\tcase OPTION_ESCDELAY:\n\t{\n\t\ttermkey_set_waittime(vis->ui.termkey, arg.i);\n\t\tbreak;\n\t}\n\tcase OPTION_EXPANDTAB:\n\t\tvis->win->expandtab = toggle ? !vis->win->expandtab : arg.b;\n\t\tbreak;\n\tcase OPTION_AUTOINDENT:\n\t\tvis->autoindent = toggle ? !vis->autoindent : arg.b;\n\t\tbreak;\n\tcase OPTION_TABWIDTH:\n\t\tview_tabwidth_set(&vis->win->view, arg.i);\n\t\tbreak;\n\tcase OPTION_SHOW_SPACES:\n\tcase OPTION_SHOW_TABS:\n\tcase OPTION_SHOW_NEWLINES:\n\tcase OPTION_SHOW_EOF:\n\tcase OPTION_STATUSBAR:\n\t{\n\t\tconst int values[] = {\n\t\t\t[OPTION_SHOW_SPACES] = UI_OPTION_SYMBOL_SPACE,\n\t\t\t[OPTION_SHOW_TABS] = UI_OPTION_SYMBOL_TAB|UI_OPTION_SYMBOL_TAB_FILL,\n\t\t\t[OPTION_SHOW_NEWLINES] = UI_OPTION_SYMBOL_EOL,\n\t\t\t[OPTION_SHOW_EOF] = UI_OPTION_SYMBOL_EOF,\n\t\t\t[OPTION_STATUSBAR] = UI_OPTION_STATUSBAR,\n\t\t};\n\t\tint flags = win->options;\n\t\tif (arg.b || (toggle && !(flags & values[opt_index])))\n\t\t\tflags |= values[opt_index];\n\t\telse\n\t\t\tflags &= ~values[opt_index];\n\t\twin_options_set(win, flags);\n\t\tbreak;\n\t}\n\tcase OPTION_NUMBER: {\n\t\tenum UiOption opt = win->options;\n\t\tif (arg.b || (toggle && !(opt & UI_OPTION_LINE_NUMBERS_ABSOLUTE))) {\n\t\t\topt &= ~UI_OPTION_LINE_NUMBERS_RELATIVE;\n\t\t\topt |=  UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\t\t} else {\n\t\t\topt &= ~UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\t\t}\n\t\twin_options_set(win, opt);\n\t\tbreak;\n\t}\n\tcase OPTION_NUMBER_RELATIVE: {\n\t\tenum UiOption opt = win->options;\n\t\tif (arg.b || (toggle && !(opt & UI_OPTION_LINE_NUMBERS_RELATIVE))) {\n\t\t\topt &= ~UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\t\t\topt |=  UI_OPTION_LINE_NUMBERS_RELATIVE;\n\t\t} else {\n\t\t\topt &= ~UI_OPTION_LINE_NUMBERS_RELATIVE;\n\t\t}\n\t\twin_options_set(win, opt);\n\t\tbreak;\n\t}\n\tcase OPTION_CURSOR_LINE: {\n\t\tenum UiOption opt = win->options;\n\t\tif (arg.b || (toggle && !(opt & UI_OPTION_CURSOR_LINE)))\n\t\t\topt |= UI_OPTION_CURSOR_LINE;\n\t\telse\n\t\t\topt &= ~UI_OPTION_CURSOR_LINE;\n\t\twin_options_set(win, opt);\n\t\tbreak;\n\t}\n\tcase OPTION_COLOR_COLUMN:\n\t\tif (arg.i >= 0)\n\t\t\twin->view.colorcolumn = arg.i;\n\t\tbreak;\n\tcase OPTION_SAVE_METHOD:\n\t\tif (strcmp(\"auto\", arg.s) == 0) {\n\t\t\twin->file->save_method = TEXT_SAVE_AUTO;\n\t\t} else if (strcmp(\"atomic\", arg.s) == 0) {\n\t\t\twin->file->save_method = TEXT_SAVE_ATOMIC;\n\t\t} else if (strcmp(\"inplace\", arg.s) == 0) {\n\t\t\twin->file->save_method = TEXT_SAVE_INPLACE;\n\t\t} else {\n\t\t\tvis_info_show(vis, \"Invalid save method `%s', expected \"\n\t\t\t              \"'auto', 'atomic' or 'inplace'\", arg.s);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase OPTION_LOAD_METHOD:\n\t\tif (strcmp(\"auto\", arg.s) == 0) {\n\t\t\tvis->load_method = TEXT_LOAD_AUTO;\n\t\t} else if (strcmp(\"read\", arg.s) == 0) {\n\t\t\tvis->load_method = TEXT_LOAD_READ;\n\t\t} else if (strcmp(\"mmap\", arg.s) == 0) {\n\t\t\tvis->load_method = TEXT_LOAD_MMAP;\n\t\t} else {\n\t\t\tvis_info_show(vis, \"Invalid load method `%s', expected \"\n\t\t\t              \"'auto', 'read' or 'mmap'\", arg.s);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase OPTION_CHANGE_256COLORS:\n\t\tvis->change_colors = toggle ? !vis->change_colors : arg.b;\n\t\tbreak;\n\tcase OPTION_LAYOUT: {\n\t\tenum UiLayout layout;\n\t\tif (strcmp(\"h\", arg.s) == 0) {\n\t\t\tlayout = UI_LAYOUT_HORIZONTAL;\n\t\t} else if (strcmp(\"v\", arg.s) == 0) {\n\t\t\tlayout = UI_LAYOUT_VERTICAL;\n\t\t} else {\n\t\t\tvis_info_show(vis, \"Invalid layout `%s', expected 'h' or 'v'\", arg.s);\n\t\t\treturn false;\n\t\t}\n\t\tui_arrange(&vis->ui, layout);\n\t\tbreak;\n\t}\n\tcase OPTION_IGNORECASE:\n\t\tvis->ignorecase = toggle ? !vis->ignorecase : arg.b;\n\t\tbreak;\n\tcase OPTION_BREAKAT:\n\t\tif (!view_breakat_set(&win->view, arg.s)) {\n\t\t\tvis_info_show(vis, \"Failed to set breakat\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase OPTION_WRAP_COLUMN:\n\t\tif (arg.i >= 0)\n\t\t\twin->view.wrapcolumn = arg.i;\n\t\tbreak;\n\tdefault:\n\t\tif (!opt->func)\n\t\t\treturn false;\n\t\treturn opt->func(vis, win, opt->context, toggle, opt->flags, name, &arg);\n\t}\n\n\treturn true;\n}\n\nstatic bool is_file_pattern(const char *pattern) {\n\tif (!pattern)\n\t\treturn false;\n\tstruct stat meta;\n\tif (stat(pattern, &meta) == 0 && S_ISDIR(meta.st_mode))\n\t\treturn true;\n\t/* tilde expansion is defined only for the tilde at the\n\t   beginning of the pattern. */\n\tif (pattern[0] == '~')\n\t\treturn true;\n\tfor (char special[] = \"*?[{$\", *s = special; *s; s++) {\n\t\tif (strchr(pattern, *s))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic const char *file_open_dialog(Vis *vis, const char *pattern) {\n\tstatic char name[PATH_MAX];\n\tname[0] = '\\0';\n\n\tif (!is_file_pattern(pattern))\n\t\treturn pattern;\n\n\tBuffer bufcmd = {0}, bufout = {0}, buferr = {0};\n\n\tif (!buffer_put0(&bufcmd, VIS_OPEN \" \") || !buffer_append0(&bufcmd, pattern ? pattern : \"\"))\n\t\treturn NULL;\n\n\tFilerange empty = text_range_new(0,0);\n\tint status = vis_pipe(vis, vis->win->file, &empty,\n\t\t(const char*[]){ buffer_content0(&bufcmd), NULL },\n\t\t&bufout, read_into_buffer, &buferr, read_into_buffer, false);\n\n\tif (status == 0)\n\t\tstrncpy(name, buffer_content0(&bufout), sizeof(name)-1);\n\telse if (status != 1)\n\t\tvis_info_show(vis, \"Command failed %s\", buffer_content0(&buferr));\n\n\tbuffer_release(&bufcmd);\n\tbuffer_release(&bufout);\n\tbuffer_release(&buferr);\n\n\tfor (char *end = name+strlen(name)-1; end >= name && isspace((unsigned char)*end); end--)\n\t\t*end = '\\0';\n\n\treturn name[0] ? name : NULL;\n}\n\nstatic bool openfiles(Vis *vis, const char **files) {\n\tfor (; *files; files++) {\n\t\tconst char *file = file_open_dialog(vis, *files);\n\t\tif (!file)\n\t\t\treturn false;\n\t\terrno = 0;\n\t\tif (!vis_window_new(vis, file)) {\n\t\t\tvis_info_show(vis, \"Could not open `%s' %s\", file,\n\t\t\t                 errno ? strerror(errno) : \"\");\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic bool cmd_open(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!argv[1])\n\t\treturn vis_window_new(vis, NULL);\n\treturn openfiles(vis, &argv[1]);\n}\n\nstatic void info_unsaved_changes(Vis *vis) {\n\tvis_info_show(vis, \"No write since last change (add ! to override)\");\n}\n\nstatic bool cmd_edit(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (argv[2]) {\n\t\tvis_info_show(vis, \"Only 1 filename allowed\");\n\t\treturn false;\n\t}\n\tWin *oldwin = win;\n\tif (!oldwin)\n\t\treturn false;\n\tif (cmd->flags != '!' && !vis_window_closable(oldwin)) {\n\t\tinfo_unsaved_changes(vis);\n\t\treturn false;\n\t}\n\tif (!argv[1]) {\n\t\tif (oldwin->file->refcount > 1) {\n\t\t\tvis_info_show(vis, \"Can not reload file being opened multiple times\");\n\t\t\treturn false;\n\t\t}\n\t\treturn vis_window_reload(oldwin);\n\t}\n\tif (!openfiles(vis, &argv[1]))\n\t\treturn false;\n\tif (vis->win != oldwin) {\n\t\tWin *newwin = vis->win;\n\t\tvis_window_swap(oldwin, newwin);\n\t\tvis_window_close(oldwin);\n\t\tvis_window_focus(newwin);\n\t}\n\treturn vis->win != oldwin;\n}\n\nstatic bool cmd_read(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tbool ret = false;\n\tconst size_t first_file = 3;\n\tconst char *args[MAX_ARGV] = { argv[0], \"cat\", \"--\" };\n\tconst char **name = argv[1] ? &argv[1] : (const char*[]){ \".\", NULL };\n\tfor (size_t i = first_file; *name && i < LENGTH(args)-1; name++, i++) {\n\t\tconst char *file = file_open_dialog(vis, *name);\n\t\tif (!file || !(args[i] = strdup(file)))\n\t\t\tgoto err;\n\t}\n\targs[LENGTH(args)-1] = NULL;\n\tret = cmd_pipein(vis, win, cmd, args, sel, range);\nerr:\n\tfor (size_t i = first_file; i < LENGTH(args); i++)\n\t\tfree((char*)args[i]);\n\treturn ret;\n}\n\nstatic bool has_windows(Vis *vis) {\n\tfor (Win *win = vis->windows; win; win = win->next) {\n\t\tif (!win->file->internal)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool cmd_quit(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (cmd->flags != '!' && !vis_window_closable(win)) {\n\t\tinfo_unsaved_changes(vis);\n\t\treturn false;\n\t}\n\tvis_window_close(win);\n\tif (!has_windows(vis))\n\t\tvis_exit(vis, argv[1] ? atoi(argv[1]) : EXIT_SUCCESS);\n\treturn true;\n}\n\nstatic bool cmd_qall(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tfor (Win *next, *win = vis->windows; win; win = next) {\n\t\tnext = win->next;\n\t\tif (!win->file->internal && (!text_modified(win->file->text) || cmd->flags == '!'))\n\t\t\tvis_window_close(win);\n\t}\n\tif (!has_windows(vis)) {\n\t\tvis_exit(vis, argv[1] ? atoi(argv[1]) : EXIT_SUCCESS);\n\t\treturn true;\n\t} else {\n\t\tinfo_unsaved_changes(vis);\n\t\treturn false;\n\t}\n}\n\nstatic bool cmd_split(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tenum UiOption options = win->options;\n\tui_arrange(&vis->ui, UI_LAYOUT_HORIZONTAL);\n\tif (!argv[1])\n\t\treturn vis_window_split(win);\n\tbool ret = openfiles(vis, &argv[1]);\n\tif (ret)\n\t\twin_options_set(vis->win, options);\n\treturn ret;\n}\n\nstatic bool cmd_vsplit(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tenum UiOption options = win->options;\n\tui_arrange(&vis->ui, UI_LAYOUT_VERTICAL);\n\tif (!argv[1])\n\t\treturn vis_window_split(win);\n\tbool ret = openfiles(vis, &argv[1]);\n\tif (ret)\n\t\twin_options_set(vis->win, options);\n\treturn ret;\n}\n\nstatic bool cmd_new(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tui_arrange(&vis->ui, UI_LAYOUT_HORIZONTAL);\n\treturn vis_window_new(vis, NULL);\n}\n\nstatic bool cmd_vnew(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tui_arrange(&vis->ui, UI_LAYOUT_VERTICAL);\n\treturn vis_window_new(vis, NULL);\n}\n\nstatic bool cmd_wq(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tFile *file = win->file;\n\tbool unmodified = file->fd == -1 && !file->name && !text_modified(file->text);\n\tif (unmodified || cmd_write(vis, win, cmd, argv, sel, range))\n\t\treturn cmd_quit(vis, win, cmd, (const char*[]){argv[0], NULL}, sel, range);\n\treturn false;\n}\n\nstatic bool cmd_earlier_later(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!win)\n\t\treturn false;\n\tText *txt = win->file->text;\n\tchar *unit = \"\";\n\tlong count = 1;\n\tsize_t pos = EPOS;\n\tif (argv[1]) {\n\t\terrno = 0;\n\t\tcount = strtol(argv[1], &unit, 10);\n\t\tif (errno || unit == argv[1] || count < 0) {\n\t\t\tvis_info_show(vis, \"Invalid number\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (*unit) {\n\t\t\twhile (*unit && isspace((unsigned char)*unit))\n\t\t\t\tunit++;\n\t\t\tswitch (*unit) {\n\t\t\tcase 'd': count *= 24; /* fall through */\n\t\t\tcase 'h': count *= 60; /* fall through */\n\t\t\tcase 'm': count *= 60; /* fall through */\n\t\t\tcase 's': break;\n\t\t\tdefault:\n\t\t\t\tvis_info_show(vis, \"Unknown time specifier (use: s,m,h or d)\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (argv[0][0] == 'e')\n\t\t\t\tcount = -count; /* earlier, move back in time */\n\n\t\t\tpos = text_restore(txt, text_state(txt) + count);\n\t\t}\n\t}\n\n\tif (!*unit) {\n\t\tVisCountIterator it = vis_count_iterator_init(vis, count);\n\t\twhile (vis_count_iterator_next(&it)) {\n\t\t\tif (argv[0][0] == 'e')\n\t\t\t\tpos = text_earlier(txt);\n\t\t\telse\n\t\t\t\tpos = text_later(txt);\n\t\t}\n\t}\n\n\tstruct tm tm;\n\ttime_t state = text_state(txt);\n\tchar buf[32];\n\tstrftime(buf, sizeof buf, \"State from %H:%M\", localtime_r(&state, &tm));\n\tvis_info_show(vis, \"%s\", buf);\n\n\treturn pos != EPOS;\n}\n\nstatic int space_replace(char *dest, const char *src, size_t dlen) {\n\tint invisiblebytes = 0;\n\tsize_t i, size = LENGTH(\"␣\") - 1;\n\tfor (i = 0; *src && i < dlen; src++) {\n\t\tif (*src == ' ' && i < dlen - size - 1) {\n\t\t\tmemcpy(&dest[i], \"␣\", size);\n\t\t\ti += size;\n\t\t\tinvisiblebytes += size - 1;\n\t\t} else {\n\t\t\tdest[i] = *src;\n\t\t\ti++;\n\t\t}\n\t}\n\tdest[i] = '\\0';\n\treturn invisiblebytes;\n}\n\nstatic bool print_keylayout(const char *key, void *value, void *data) {\n\tchar buf[64];\n\tint invisiblebytes = space_replace(buf, key, sizeof(buf));\n\treturn text_appendf(data, \"  %-*s\\t%s\\n\", 18+invisiblebytes, buf, (char*)value);\n}\n\nstatic bool print_keybinding(const char *key, void *value, void *data) {\n\tKeyBinding *binding = value;\n\tconst char *desc = binding->alias;\n\tif (!desc && binding->action)\n\t\tdesc = VIS_HELP_USE(binding->action->help);\n\tchar buf[64];\n\tint invisiblebytes = space_replace(buf, key, sizeof(buf));\n\treturn text_appendf(data, \"  %-*s\\t%s\\n\", 18+invisiblebytes, buf, desc ? desc : \"\");\n}\n\nstatic void print_mode(Mode *mode, Text *txt) {\n\tif (!map_empty(mode->bindings))\n\t\ttext_appendf(txt, \"\\n %s\\n\\n\", mode->name);\n\tmap_iterate(mode->bindings, print_keybinding, txt);\n}\n\nstatic bool print_action(const char *key, void *value, void *data) {\n\tconst char *help = VIS_HELP_USE(((KeyAction*)value)->help);\n\treturn text_appendf(data, \"  %-30s\\t%s\\n\", key, help ? help : \"\");\n}\n\nstatic bool print_cmd(const char *key, void *value, void *data) {\n\tCommandDef *cmd = value;\n\tconst char *help = VIS_HELP_USE(cmd->help);\n\tchar usage[256];\n\tsnprintf(usage, sizeof usage, \"%s%s%s%s%s%s%s\",\n\t         cmd->name,\n\t         (cmd->flags & CMD_FORCE) ? \"[!]\" : \"\",\n\t         (cmd->flags & CMD_TEXT) ? \"/text/\" : \"\",\n\t         (cmd->flags & CMD_REGEX) ? \"/regexp/\" : \"\",\n\t         (cmd->flags & CMD_CMD) ? \" command\" : \"\",\n\t         (cmd->flags & CMD_SHELL) ? (!strcmp(cmd->name, \"s\") ? \"/regexp/text/\" : \" shell-command\") : \"\",\n\t         (cmd->flags & CMD_ARGV) ? \" [args...]\" : \"\");\n\treturn text_appendf(data, \"  %-30s %s\\n\", usage, help ? help : \"\");\n}\n\nstatic bool print_option(const char *key, void *value, void *txt) {\n\tchar desc[256];\n\tconst OptionDef *opt = value;\n\tconst char *help = VIS_HELP_USE(opt->help);\n\tif (strcmp(key, opt->names[0]))\n\t\treturn true;\n\tsnprintf(desc, sizeof desc, \"%s%s%s%s%s\",\n\t         opt->names[0],\n\t         opt->names[1] ? \"|\" : \"\",\n\t         opt->names[1] ? opt->names[1] : \"\",\n\t         opt->flags & VIS_OPTION_TYPE_BOOL ? \" on|off\" : \"\",\n\t         opt->flags & VIS_OPTION_TYPE_NUMBER ? \" nn\" : \"\");\n\treturn text_appendf(txt, \"  %-30s %s\\n\", desc, help ? help : \"\");\n}\n\nstatic void print_symbolic_keys(Vis *vis, Text *txt) {\n\tstatic const int keys[] = {\n\t\tTERMKEY_SYM_BACKSPACE,\n\t\tTERMKEY_SYM_TAB,\n\t\tTERMKEY_SYM_ENTER,\n\t\tTERMKEY_SYM_ESCAPE,\n\t\t//TERMKEY_SYM_SPACE,\n\t\tTERMKEY_SYM_DEL,\n\t\tTERMKEY_SYM_UP,\n\t\tTERMKEY_SYM_DOWN,\n\t\tTERMKEY_SYM_LEFT,\n\t\tTERMKEY_SYM_RIGHT,\n\t\tTERMKEY_SYM_BEGIN,\n\t\tTERMKEY_SYM_FIND,\n\t\tTERMKEY_SYM_INSERT,\n\t\tTERMKEY_SYM_DELETE,\n\t\tTERMKEY_SYM_SELECT,\n\t\tTERMKEY_SYM_PAGEUP,\n\t\tTERMKEY_SYM_PAGEDOWN,\n\t\tTERMKEY_SYM_HOME,\n\t\tTERMKEY_SYM_END,\n\t\tTERMKEY_SYM_CANCEL,\n\t\tTERMKEY_SYM_CLEAR,\n\t\tTERMKEY_SYM_CLOSE,\n\t\tTERMKEY_SYM_COMMAND,\n\t\tTERMKEY_SYM_COPY,\n\t\tTERMKEY_SYM_EXIT,\n\t\tTERMKEY_SYM_HELP,\n\t\tTERMKEY_SYM_MARK,\n\t\tTERMKEY_SYM_MESSAGE,\n\t\tTERMKEY_SYM_MOVE,\n\t\tTERMKEY_SYM_OPEN,\n\t\tTERMKEY_SYM_OPTIONS,\n\t\tTERMKEY_SYM_PRINT,\n\t\tTERMKEY_SYM_REDO,\n\t\tTERMKEY_SYM_REFERENCE,\n\t\tTERMKEY_SYM_REFRESH,\n\t\tTERMKEY_SYM_REPLACE,\n\t\tTERMKEY_SYM_RESTART,\n\t\tTERMKEY_SYM_RESUME,\n\t\tTERMKEY_SYM_SAVE,\n\t\tTERMKEY_SYM_SUSPEND,\n\t\tTERMKEY_SYM_UNDO,\n\t\tTERMKEY_SYM_KP0,\n\t\tTERMKEY_SYM_KP1,\n\t\tTERMKEY_SYM_KP2,\n\t\tTERMKEY_SYM_KP3,\n\t\tTERMKEY_SYM_KP4,\n\t\tTERMKEY_SYM_KP5,\n\t\tTERMKEY_SYM_KP6,\n\t\tTERMKEY_SYM_KP7,\n\t\tTERMKEY_SYM_KP8,\n\t\tTERMKEY_SYM_KP9,\n\t\tTERMKEY_SYM_KPENTER,\n\t\tTERMKEY_SYM_KPPLUS,\n\t\tTERMKEY_SYM_KPMINUS,\n\t\tTERMKEY_SYM_KPMULT,\n\t\tTERMKEY_SYM_KPDIV,\n\t\tTERMKEY_SYM_KPCOMMA,\n\t\tTERMKEY_SYM_KPPERIOD,\n\t\tTERMKEY_SYM_KPEQUALS,\n\t};\n\n\tTermKey *termkey = vis->ui.termkey;\n\ttext_appendf(txt, \"  ␣ (a literal \\\" \\\" space symbol must be used to refer to <Space>)\\n\");\n\tfor (size_t i = 0; i < LENGTH(keys); i++) {\n\t\ttext_appendf(txt, \"  <%s>\\n\", termkey_get_keyname(termkey, keys[i]));\n\t}\n}\n\nstatic bool cmd_help(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tif (!vis_window_new(vis, NULL))\n\t\treturn false;\n\n\tText *txt = vis->win->file->text;\n\n\ttext_appendf(txt, \"vis %s (PID: %ld)\\n\\n\", VERSION, (long)getpid());\n\n\ttext_appendf(txt, \" Modes\\n\\n\");\n\tfor (int i = 0; i < LENGTH(vis_modes); i++) {\n\t\tMode *mode = &vis_modes[i];\n\t\tif (mode->help)\n\t\t\ttext_appendf(txt, \"  %-18s\\t%s\\n\", mode->name, mode->help);\n\t}\n\n\tif (!map_empty(vis->keymap)) {\n\t\ttext_appendf(txt, \"\\n Layout specific mappings (affects all modes except INSERT/REPLACE)\\n\\n\");\n\t\tmap_iterate(vis->keymap, print_keylayout, txt);\n\t}\n\n\tprint_mode(&vis_modes[VIS_MODE_NORMAL], txt);\n\tprint_mode(&vis_modes[VIS_MODE_OPERATOR_PENDING], txt);\n\tprint_mode(&vis_modes[VIS_MODE_VISUAL], txt);\n\tprint_mode(&vis_modes[VIS_MODE_INSERT], txt);\n\n\ttext_appendf(txt, \"\\n :-Commands\\n\\n\");\n\tmap_iterate(vis->cmds, print_cmd, txt);\n\n\ttext_appendf(txt, \"\\n Marks\\n\\n\");\n\ttext_appendf(txt, \"  a-z General purpose marks\\n\");\n\tfor (size_t i = 0; i < LENGTH(vis_marks); i++) {\n\t\tconst char *help = VIS_HELP_USE(vis_marks[i].help);\n\t\ttext_appendf(txt, \"  %c   %s\\n\", vis_marks[i].name, help ? help : \"\");\n\t}\n\n\ttext_appendf(txt, \"\\n Registers\\n\\n\");\n\ttext_appendf(txt, \"  a-z General purpose registers\\n\");\n\ttext_appendf(txt, \"  A-Z Append to corresponding general purpose register\\n\");\n\tfor (size_t i = 0; i < LENGTH(vis_registers); i++) {\n\t\tconst char *help = VIS_HELP_USE(vis_registers[i].help);\n\t\ttext_appendf(txt, \"  %c   %s\\n\", vis_registers[i].name, help ? help : \"\");\n\t}\n\n\ttext_appendf(txt, \"\\n :set command options\\n\\n\");\n\tmap_iterate(vis->options, print_option, txt);\n\n\ttext_appendf(txt, \"\\n Key binding actions\\n\\n\");\n\tmap_iterate(vis->actions, print_action, txt);\n\n\ttext_appendf(txt, \"\\n Symbolic keys usable for key bindings \"\n\t\t\"(prefix with C-, S-, and M- for Ctrl, Shift and Alt respectively)\\n\\n\");\n\tprint_symbolic_keys(vis, txt);\n\n\tchar *paths[] = { NULL, NULL };\n\tchar *paths_description[] = {\n\t\t\"Lua paths used to load runtime files (? will be replaced by filename):\",\n\t\t\"Lua paths used to load C libraries (? will be replaced by filename):\",\n\t};\n\n\tif (vis_lua_paths_get(vis, &paths[0], &paths[1])) {\n\t\tfor (size_t i = 0; i < LENGTH(paths); i++) {\n\t\t\ttext_appendf(txt, \"\\n %s\\n\\n\", paths_description[i]);\n\t\t\tfor (char *elem = paths[i], *next; elem; elem = next) {\n\t\t\t\tif ((next = strstr(elem, \";\")))\n\t\t\t\t\t*next++ = '\\0';\n\t\t\t\tif (*elem)\n\t\t\t\t\ttext_appendf(txt, \"  %s\\n\", elem);\n\t\t\t}\n\t\t\tfree(paths[i]);\n\t\t}\n\t}\n\n\ttext_appendf(txt, \"\\n Compile time configuration\\n\\n\");\n\n\tconst struct {\n\t\tconst char *name;\n\t\tbool enabled;\n\t} configs[] = {\n\t\t{ \"Curses support: \", CONFIG_CURSES },\n\t\t{ \"Lua support: \", CONFIG_LUA },\n\t\t{ \"Lua LPeg statically built-in: \", CONFIG_LPEG },\n\t\t{ \"TRE based regex support: \", CONFIG_TRE },\n\t\t{ \"POSIX ACL support: \", CONFIG_ACL },\n\t\t{ \"SELinux support: \", CONFIG_SELINUX },\n\t};\n\n\tfor (size_t i = 0; i < LENGTH(configs); i++)\n\t\ttext_appendf(txt, \"  %-32s\\t%s\\n\", configs[i].name, configs[i].enabled ? \"yes\" : \"no\");\n\n\ttext_save(txt, NULL);\n\tview_cursors_to(vis->win->view.selection, 0);\n\n\tif (argv[1])\n\t\tvis_motion(vis, VIS_MOVE_SEARCH_FORWARD, argv[1]);\n\treturn true;\n}\n\nstatic bool cmd_langmap(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tconst char *nonlatin = argv[1];\n\tconst char *latin = argv[2];\n\tbool mapped = true;\n\n\tif (!latin || !nonlatin) {\n\t\tvis_info_show(vis, \"usage: langmap <non-latin keys> <latin keys>\");\n\t\treturn false;\n\t}\n\n\twhile (*latin && *nonlatin) {\n\t\tsize_t i = 0, j = 0;\n\t\tchar latin_key[8], nonlatin_key[8];\n\t\tdo {\n\t\t\tif (i < sizeof(latin_key)-1)\n\t\t\t\tlatin_key[i++] = *latin;\n\t\t\tlatin++;\n\t\t} while (!ISUTF8(*latin));\n\t\tdo {\n\t\t\tif (j < sizeof(nonlatin_key)-1)\n\t\t\t\tnonlatin_key[j++] = *nonlatin;\n\t\t\tnonlatin++;\n\t\t} while (!ISUTF8(*nonlatin));\n\t\tlatin_key[i] = '\\0';\n\t\tnonlatin_key[j] = '\\0';\n\t\tmapped &= vis_keymap_add(vis, nonlatin_key, strdup(latin_key));\n\t}\n\n\treturn mapped;\n}\n\nstatic bool cmd_map(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tbool mapped = false;\n\tbool local = strstr(argv[0], \"-\") != NULL;\n\tenum VisMode mode = vis_mode_from(vis, argv[1]);\n\n\tif (local && !win) {\n\t\tvis_info_show(vis, \"Invalid window for :%s\", argv[0]);\n\t\treturn false;\n\t}\n\n\tif (mode == VIS_MODE_INVALID || !argv[2] || !argv[3]) {\n\t\tvis_info_show(vis, \"usage: %s mode lhs rhs\", argv[0]);\n\t\treturn false;\n\t}\n\n\tconst char *lhs = argv[2];\n\tKeyBinding *binding = vis_binding_new(vis);\n\tif (!binding || !(binding->alias = strdup(argv[3])))\n\t\tgoto err;\n\n\tif (local)\n\t\tmapped = vis_window_mode_map(win, mode, cmd->flags == '!', lhs, binding);\n\telse\n\t\tmapped = vis_mode_map(vis, mode, cmd->flags == '!', lhs, binding);\n\nerr:\n\tif (!mapped) {\n\t\tvis_info_show(vis, \"Failed to map `%s' in %s mode%s\", lhs, argv[1],\n\t\t              cmd->flags != '!' ? \", mapping already exists, \"\n\t\t              \"override with `!'\" : \"\");\n\t\tvis_binding_free(vis, binding);\n\t}\n\treturn mapped;\n}\n\nstatic bool cmd_unmap(Vis *vis, Win *win, Command *cmd, const char *argv[], Selection *sel, Filerange *range) {\n\tbool unmapped = false;\n\tbool local = strstr(argv[0], \"-\") != NULL;\n\tenum VisMode mode = vis_mode_from(vis, argv[1]);\n\tconst char *lhs = argv[2];\n\n\tif (local && !win) {\n\t\tvis_info_show(vis, \"Invalid window for :%s\", argv[0]);\n\t\treturn false;\n\t}\n\n\tif (mode == VIS_MODE_INVALID || !lhs) {\n\t\tvis_info_show(vis, \"usage: %s mode lhs\", argv[0]);\n\t\treturn false;\n\t}\n\n\tif (local)\n\t\tunmapped = vis_window_mode_unmap(win, mode, lhs);\n\telse\n\t\tunmapped = vis_mode_unmap(vis, mode, lhs);\n\tif (!unmapped)\n\t\tvis_info_show(vis, \"Failed to unmap `%s' in %s mode\", lhs, argv[1]);\n\treturn unmapped;\n}\n"
        },
        {
          "name": "vis-complete",
          "type": "blob",
          "size": 1.68359375,
          "content": "#!/bin/sh\nset -e\n\nfatal() {\n\techo \"$@\" >&2\n\texit 1\n}\n\nusage() {\n\tfatal \"Usage: $(basename \"$0\") [--file|--word] [--] pattern\n\nInteractively complete file or word\n\nOptions:\n    --file   expand pattern into a list of matching file names (default)\n    --word   apply pattern to a list of words from standard input\n    pattern  pattern to be completed\"\n}\n\nbasic_regex_quote() { printf \"%s\" \"$1\" | sed 's|[\\\\.*^$[]|\\\\&|g'; }\nglob_quote () { printf \"%s\" \"$1\" | sed 's|[\\\\?*[]]|\\\\&|g'; }\n\nCOMPLETE_WORD=0\nFIND_FILE_LIMIT=\"${FIND_FILE_LIMIT:-1000}\"\n\nwhile [ $# -gt 0 ]; do\n\tcase \"$1\" in\n\t--file)\n\t\tCOMPLETE_WORD=0\n\t\tshift\n\t\t;;\n\t--word)\n\t\tCOMPLETE_WORD=1\n\t\tshift\n\t\t;;\n\t--)\n\t\tshift\n\t\tbreak\n\t\t;;\n\t-*|'')\n\t\tusage\n\t\t;;\n\t*)\n\t\tbreak\n\t\t;;\n\tesac\ndone\n\n[ \"$#\" -lt 1 ] && usage\n\nPATTERN=\"$1\"\n\nif [ $COMPLETE_WORD = 1 ]; then\n\t# shellcheck disable=SC1003\n\ttr -s '\\t {}()[],<>%^&.\\\\' '\\n' |\n\t\tgrep \"^$(basic_regex_quote \"$PATTERN\").\" |\n\t\tsort -u\nelse\n\t# Expand to absolute path because of the -path option below.\n\t# shellcheck disable=SC2088\n\tcase $PATTERN in\n\t\t/*)\n\t\t\tXPATTERN=\"$PATTERN\"\n\t\t\t;;\n\t\t'~'|'~/'*)\n\t\t\tXPATTERN=\"$HOME$(echo \"$PATTERN\" | tail -c +2)\"\n\t\t\t;;\n\t\t*)\n\t\t\tXPATTERN=\"$PWD/$PATTERN\"\n\t\t\t;;\n\tesac\n\n\t# The first path condition rules out paths that start with \".\" unless\n\t# they start with \"..\". That way, hidden paths should stay hidden, but\n\t# non-normalised paths should still show up.\n\tfind \"$(dirname \"$XPATTERN\")\" \\\n\t\t-name '.*' -prune \\\n\t\t-o \\( \\\n\t\t\t! -name '.*' \\\n\t\t\t-a -path \"$(glob_quote \"$XPATTERN\")*\" \\\n\t\t\t-print \\\n\t\t\\) 2>/dev/null |\n\t\thead -n \"$FIND_FILE_LIMIT\" |\n\t\tsort |\n\t\tsed \"s|^$(dirname \"$XPATTERN\")/||\"\nfi |\n\tvis-menu -b |\n\tsed \"s|^$(basename \"$PATTERN\")$(echo \"$PATTERN\" | tail -c 2 | grep -F /)||\" |\n\ttr -d '\\n'\n"
        },
        {
          "name": "vis-core.h",
          "type": "blob",
          "size": 13.7890625,
          "content": "#ifndef VIS_CORE_H\n#define VIS_CORE_H\n\n#include <setjmp.h>\n#include \"vis.h\"\n#include \"sam.h\"\n#include \"vis-lua.h\"\n#include \"text.h\"\n#include \"text-util.h\"\n#include \"map.h\"\n#include \"array.h\"\n#include \"buffer.h\"\n#include \"util.h\"\n\n/* a mode contains a set of key bindings which are currently valid.\n *\n * each mode can specify one parent mode which is consulted if a given key\n * is not found in the current mode. hence the modes form a tree which is\n * searched from the current mode up towards the root mode until a valid binding\n * is found.\n *\n * if no binding is found, mode->input(...) is called and the user entered\n * keys are passed as argument. this is used to change the document content.\n */\ntypedef struct Mode Mode;\nstruct Mode {\n\tenum VisMode id;\n\tMode *parent;                       /* if no match is found in this mode, search will continue there */\n\tMap *bindings;\n\tconst char *name;                   /* descriptive, user facing name of the mode */\n\tconst char *status;                 /* name displayed in the window status bar */\n\tconst char *help;                   /* short description used by :help */\n\tvoid (*enter)(Vis*, Mode *old);           /* called right before the mode becomes active */\n\tvoid (*leave)(Vis*, Mode *new);           /* called right before the mode becomes inactive */\n\tvoid (*input)(Vis*, const char*, size_t); /* called whenever a key is not found in this mode and all its parent modes */\n\tvoid (*idle)(Vis*);                 /* called whenever a certain idle time i.e. without any user input elapsed */\n\ttime_t idle_timeout;                /* idle time in seconds after which the registered function will be called */\n\tbool visual;                        /* whether text selection is possible in this mode */\n};\n\ntypedef struct {\n\tArray values;\n\tbool linewise; /* place register content on a new line when inserting? */\n\tbool append;\n\tenum {\n\t\tREGISTER_NORMAL,\n\t\tREGISTER_NUMBER,\n\t\tREGISTER_BLACKHOLE,\n\t\tREGISTER_CLIPBOARD,\n\t} type;\n} Register;\n\nstruct OperatorContext {\n\tint count;        /* how many times should the command be executed? */\n\tRegister *reg;    /* always non-NULL, set to a default register */\n\tsize_t reg_slot;  /* register slot to use */\n\tFilerange range;  /* which part of the file should be affected by the operator */\n\tsize_t pos;       /* at which byte from the start of the file should the operation start? */\n\tsize_t newpos;    /* new position after motion or EPOS if none given */\n\tbool linewise;    /* should the changes always affect whole lines? */\n\tconst Arg *arg;   /* arbitrary arguments */\n\tvoid *context;    /* used by user-registered operators */\n};\n\ntypedef struct {\n\t/* operator logic, returns new cursor position, if EPOS\n\t * the cursor is disposed (except if it is the primary one) */\n\tVisOperatorFunction *func;\n\tvoid *context;\n} Operator;\n\ntypedef struct { /* Motion implementation, takes a cursor position and returns a new one */\n\t/* TODO: merge types / use union to save space */\n\tsize_t (*cur)(Selection*);\n\tsize_t (*txt)(Text*, size_t pos);\n\tsize_t (*file)(Vis*, File*, Selection*);\n\tsize_t (*vis)(Vis*, Text*, size_t pos);\n\tsize_t (*view)(Vis*, View*);\n\tsize_t (*win)(Vis*, Win*, size_t pos);\n\tsize_t (*user)(Vis*, Win*, void*, size_t pos);\n\tenum {\n\t\tLINEWISE  = VIS_MOTIONTYPE_LINEWISE,  /* should the covered range be extended to whole lines? */\n\t\tCHARWISE  = VIS_MOTIONTYPE_CHARWISE,  /* scrolls window content until position is visible */\n\t\tINCLUSIVE = 1 << 2,  /* should new position be included in operator range? */\n\t\tLINEWISE_INCLUSIVE = 1 << 3,  /* inclusive, but only if motion is linewise? */\n\t\tIDEMPOTENT = 1 << 4, /* does the returned position remain the same if called multiple times? */\n\t\tJUMP = 1 << 5, /* should the resulting position of the motion be recorded in the jump list? */\n\t\tCOUNT_EXACT = 1 << 6, /* fail (keep initial position) if count can not be satisfied exactly */\n\t} type;\n\tvoid *data;\n} Movement;\n\ntypedef struct {\n\t/* gets a cursor position and returns a file range (or text_range_empty())\n\t * representing the text object containing the position. */\n\tFilerange (*txt)(Text*, size_t pos);\n\tFilerange (*vis)(Vis*, Text*, size_t pos);\n\tFilerange (*user)(Vis*, Win*, void *data, size_t pos);\n\tenum {\n\t\tTEXTOBJECT_DELIMITED_INNER = 1 << 0, /* single byte delimited, inner variant */\n\t\tTEXTOBJECT_DELIMITED_OUTER = 1 << 1, /* single byte delimited, outer variant */\n\t\tTEXTOBJECT_NON_CONTIGUOUS  = 1 << 2, /* multiple applications yield a split range */\n\t\tTEXTOBJECT_EXTEND_FORWARD  = 1 << 3, /* multiple applications extend towards the end of file (default) */\n\t\tTEXTOBJECT_EXTEND_BACKWARD = 1 << 4, /* multiple applications extend towards the begin of file */\n\t} type;\n\tvoid *data;\n} TextObject;\n\n/* a macro is just a sequence of symbolic keys as received from ui->getkey */\ntypedef Buffer Macro;\n#define macro_release buffer_release\n#define macro_append buffer_append0\n\ntypedef struct {             /** collects all information until an operator is executed */\n\tint count;\n\tenum VisMode mode;\n\tenum VisMotionType type;\n\tconst Operator *op;\n\tconst Movement *movement;\n\tconst TextObject *textobj;\n\tconst Macro *macro;\n\tRegister *reg;\n\tenum VisMark mark;\n\tArg arg;\n} Action;\n\ntypedef struct Change Change;\ntypedef struct {\n\tChange *changes;      /* all changes in monotonically increasing file position */\n\tChange *latest;       /* most recent change */\n\tenum SamError error;  /* non-zero in case something went wrong */\n} Transcript;\n\ntypedef struct {\n\tArray prev;\n\tArray next;\n\tsize_t max;\n} MarkList;\n\nstruct File { /* shared state among windows displaying the same file */\n\tText *text;                      /* data structure holding the file content */\n\tconst char *name;                /* file name used when loading/saving */\n\tvolatile sig_atomic_t truncated; /* whether the underlying memory mapped region became invalid (SIGBUS) */\n\tint fd;                          /* output file descriptor associated with this file or -1 if loaded by file name */\n\tbool internal;                   /* whether it is an internal file (e.g. used for the prompt) */\n\tstruct stat stat;                /* filesystem information when loaded/saved, used to detect changes outside the editor */\n\tint refcount;                    /* how many windows are displaying this file? (always >= 1) */\n\tArray marks[VIS_MARK_INVALID];   /* marks which are shared across windows */\n\tenum TextSaveMethod save_method; /* whether the file is saved using rename(2) or overwritten */\n\tTranscript transcript;           /* keeps track of changes performed by sam commands */\n\tFile *next, *prev;\n};\n\nstruct Win {\n\tint id;                 /* unique identifier for this window */\n\tint width, height;      /* window dimension including status bar */\n\tint x, y;               /* window position */\n\tint sidebar_width;      /* width of the sidebar showing line numbers etc. */\n\tenum UiOption options;  /* display settings for this window */\n\tView view;              /* currently displayed part of underlying text */\n\tbool expandtab;         /* whether typed tabs should be converted to spaces in this window*/\n\tVis *vis;               /* editor instance to which this window belongs */\n\tFile *file;             /* file being displayed in this window */\n\tMarkList jumplist;      /* LRU jump management */\n\tArray saved_selections; /* register used to store selections */\n\tMode modes[VIS_MODE_INVALID]; /* overlay mods used for per window key bindings */\n\tWin *parent;            /* window which was active when showing the command prompt */\n\tMode *parent_mode;      /* mode which was active when showing the command prompt */\n\tWin *prev, *next;       /* neighbouring windows */\n};\n\nstruct Vis {\n\tFile *files;                         /* all files currently managed by this editor instance */\n\tFile *command_file;                  /* special internal file used to store :-command prompt */\n\tFile *search_file;                   /* special internal file used to store /,? search prompt */\n\tFile *error_file;                    /* special internal file used to store lua error messages */\n\tWin *windows;                        /* all windows currently managed by this editor instance */\n\tWin *win;                            /* currently active/focused window */\n\tWin *message_window;                 /* special window to display multi line messages */\n\tUi ui;                               /* user interface responsible for visual appearance */\n\tRegister registers[VIS_REG_INVALID]; /* registers used for text manipulations yank/put etc. and macros */\n\tMacro *recording, *last_recording;   /* currently (if non NULL) and least recently recorded macro */\n\tconst Macro *replaying;              /* macro currently being replayed */\n\tMacro *macro_operator;               /* special macro used to repeat certain operators */\n\tMode *mode_before_prompt;            /* user mode which was active before entering prompt */\n\tchar search_char[8];                 /* last used character to search for via 'f', 'F', 't', 'T' */\n\tint last_totill;                     /* last to/till movement used for ';' and ',' */\n\tint search_direction;                /* used for `n` and `N` */\n\tbool autoindent;                     /* whether indentation should be copied from previous line on newline */\n\tbool change_colors;                  /* whether to adjust 256 color palette for true colors */\n\tchar *shell;                         /* shell used to launch external commands */\n\tMap *cmds;                           /* \":\"-commands, used for unique prefix queries */\n\tMap *usercmds;                       /* user registered \":\"-commands */\n\tMap *options;                        /* \":set\"-options */\n\tMap *keymap;                         /* key translation before any bindings are matched */\n\tbool keymap_disabled;                /* ignore key map for next key press, gets automatically re-enabled */\n\tchar key[VIS_KEY_LENGTH_MAX];        /* last pressed key as reported from the UI */\n\tchar key_current[VIS_KEY_LENGTH_MAX];/* current key being processed by the input queue */\n\tchar key_prev[VIS_KEY_LENGTH_MAX];   /* previous key which was processed by the input queue */\n\tBuffer input_queue;                  /* holds pending input keys */\n\tbool errorhandler;                   /* whether we are currently in an error handler, used to avoid recursion */\n\tAction action;                       /* current action which is in progress */\n\tAction action_prev;                  /* last operator action used by the repeat (dot) command */\n\tMode *mode;                          /* currently active mode, used to search for keybindings */\n\tMode *mode_prev;                     /* previously active user mode */\n\tint nesting_level;                   /* parsing state to hold keep track of { } nesting level */\n\tvolatile bool running;               /* exit main loop once this becomes false */\n\tint exit_status;                     /* exit status when terminating main loop */\n\tvolatile sig_atomic_t interrupted;   /* abort command (SIGINT occurred) */\n\tvolatile sig_atomic_t sigbus;        /* one of the memory mapped regions became unavailable (SIGBUS) */\n\tvolatile sig_atomic_t need_resize;   /* need to resize UI (SIGWINCH occurred) */\n\tvolatile sig_atomic_t resume;        /* need to resume UI (SIGCONT occurred) */\n\tvolatile sig_atomic_t terminate;     /* need to terminate we were being killed by SIGTERM */\n\tsigjmp_buf sigbus_jmpbuf;            /* used to jump back to a known good state in the mainloop after (SIGBUS) */\n\tMap *actions;                        /* registered editor actions / special keys commands */\n\tArray actions_user;                  /* dynamically allocated editor actions */\n\tlua_State *lua;                      /* lua context used for syntax highlighting */\n\tenum TextLoadMethod load_method;     /* how existing files should be loaded */\n\tArray operators;\n\tArray motions;\n\tArray textobjects;\n\tArray bindings;\n\tbool ignorecase;                     /* whether to ignore case when searching */\n};\n\nenum VisEvents {\n\tVIS_EVENT_INIT,\n\tVIS_EVENT_START,\n\tVIS_EVENT_QUIT,\n\tVIS_EVENT_FILE_OPEN,\n\tVIS_EVENT_FILE_SAVE_PRE,\n\tVIS_EVENT_FILE_SAVE_POST,\n\tVIS_EVENT_FILE_CLOSE,\n\tVIS_EVENT_WIN_OPEN,\n\tVIS_EVENT_WIN_CLOSE,\n\tVIS_EVENT_WIN_HIGHLIGHT,\n\tVIS_EVENT_WIN_STATUS,\n\tVIS_EVENT_TERM_CSI,\n\tVIS_EVENT_UI_DRAW,\n};\n\nbool vis_event_emit(Vis*, enum VisEvents, ...);\n\ntypedef struct {\n\tchar name;\n\tVIS_HELP_DECL(const char *help;)\n} MarkDef;\n\ntypedef MarkDef RegisterDef;\n\n/** stuff used by several of the vis-* files */\n\nextern Mode vis_modes[VIS_MODE_INVALID];\nextern const Movement vis_motions[VIS_MOVE_INVALID];\nextern const Operator vis_operators[VIS_OP_INVALID];\nextern const TextObject vis_textobjects[VIS_TEXTOBJECT_INVALID];\nextern const MarkDef vis_marks[VIS_MARK_a];\nextern const RegisterDef vis_registers[VIS_REG_a];\n\nvoid macro_operator_stop(Vis *vis);\nvoid macro_operator_record(Vis *vis);\n\nvoid vis_do(Vis *vis);\nvoid action_reset(Action*);\nsize_t vis_text_insert_nl(Vis*, Text*, size_t pos);\n\nMode *mode_get(Vis*, enum VisMode);\nvoid mode_set(Vis *vis, Mode *new_mode);\nMacro *macro_get(Vis *vis, enum VisRegister);\n\nWin *window_new_file(Vis*, File*, enum UiOption);\nvoid window_selection_save(Win *win);\nvoid window_status_update(Vis *vis, Win *win);\n\nchar *absolute_path(const char *path);\n\nconst char *file_name_get(File*);\nvoid file_name_set(File*, const char *name);\n\nbool register_init(Register*);\nvoid register_release(Register*);\n\nvoid mark_init(Array*);\nvoid mark_release(Array*);\n\nvoid marklist_init(MarkList*, size_t max);\nvoid marklist_release(MarkList*);\n\nconst char *register_get(Vis*, Register*, size_t *len);\nconst char *register_slot_get(Vis*, Register*, size_t slot, size_t *len);\n\nbool register_put0(Vis*, Register*, const char *data);\nbool register_put(Vis*, Register*, const char *data, size_t len);\nbool register_slot_put(Vis*, Register*, size_t slot, const char *data, size_t len);\n\nbool register_put_range(Vis*, Register*, Text*, Filerange*);\nbool register_slot_put_range(Vis*, Register*, size_t slot, Text*, Filerange*);\n\nsize_t vis_register_count(Vis*, Register*);\nbool register_resize(Register*, size_t count);\n\n#endif\n"
        },
        {
          "name": "vis-digraph.c",
          "type": "blob",
          "size": 96.322265625,
          "content": "#include <errno.h>\n#include <termios.h>\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <wchar.h>\n\n#define MAX_DIGRAPH_LENGTH 7\n\ntypedef struct {\n\tconst char name[MAX_DIGRAPH_LENGTH+1];\n\tconst wchar_t rune;\n\tconst char *description;\n} Digraph;\n\nstatic const Digraph digraphs[] = {\n\t/* generated from https://tools.ietf.org/rfc/rfc1345.txt */\n\t{ \"SP\", 0x0020, \"SPACE\" },\n\t{ \"! \", 0x0021, \"EXCLAMATION MARK\" },\n\t{ \"\\\" \", 0x0022, \"QUOTATION MARK\" },\n\t{ \"Nb\", 0x0023, \"NUMBER SIGN\" },\n\t{ \"DO\", 0x0024, \"DOLLAR SIGN\" },\n\t{ \"% \", 0x0025, \"PERCENT SIGN\" },\n\t{ \"& \", 0x0026, \"AMPERSAND\" },\n\t{ \"' \", 0x0027, \"APOSTROPHE\" },\n\t{ \"( \", 0x0028, \"LEFT PARENTHESIS\" },\n\t{ \") \", 0x0029, \"RIGHT PARENTHESIS\" },\n\t{ \"* \", 0x002a, \"ASTERISK\" },\n\t{ \"+ \", 0x002b, \"PLUS SIGN\" },\n\t{ \", \", 0x002c, \"COMMA\" },\n\t{ \"- \", 0x002d, \"HYPHEN-MINUS\" },\n\t{ \". \", 0x002e, \"FULL STOP\" },\n\t{ \"/ \", 0x002f, \"SOLIDUS\" },\n\t{ \"0 \", 0x0030, \"DIGIT ZERO\" },\n\t{ \"1 \", 0x0031, \"DIGIT ONE\" },\n\t{ \"2 \", 0x0032, \"DIGIT TWO\" },\n\t{ \"3 \", 0x0033, \"DIGIT THREE\" },\n\t{ \"4 \", 0x0034, \"DIGIT FOUR\" },\n\t{ \"5 \", 0x0035, \"DIGIT FIVE\" },\n\t{ \"6 \", 0x0036, \"DIGIT SIX\" },\n\t{ \"7 \", 0x0037, \"DIGIT SEVEN\" },\n\t{ \"8 \", 0x0038, \"DIGIT EIGHT\" },\n\t{ \"9 \", 0x0039, \"DIGIT NINE\" },\n\t{ \": \", 0x003a, \"COLON\" },\n\t{ \"; \", 0x003b, \"SEMICOLON\" },\n\t{ \"< \", 0x003c, \"LESS-THAN SIGN\" },\n\t{ \"= \", 0x003d, \"EQUALS SIGN\" },\n\t{ \"> \", 0x003e, \"GREATER-THAN SIGN\" },\n\t{ \"? \", 0x003f, \"QUESTION MARK\" },\n\t{ \"At\", 0x0040, \"COMMERCIAL AT\" },\n\t{ \"A \", 0x0041, \"LATIN CAPITAL LETTER A\" },\n\t{ \"B \", 0x0042, \"LATIN CAPITAL LETTER B\" },\n\t{ \"C \", 0x0043, \"LATIN CAPITAL LETTER C\" },\n\t{ \"D \", 0x0044, \"LATIN CAPITAL LETTER D\" },\n\t{ \"E \", 0x0045, \"LATIN CAPITAL LETTER E\" },\n\t{ \"F \", 0x0046, \"LATIN CAPITAL LETTER F\" },\n\t{ \"G \", 0x0047, \"LATIN CAPITAL LETTER G\" },\n\t{ \"H \", 0x0048, \"LATIN CAPITAL LETTER H\" },\n\t{ \"I \", 0x0049, \"LATIN CAPITAL LETTER I\" },\n\t{ \"J \", 0x004a, \"LATIN CAPITAL LETTER J\" },\n\t{ \"K \", 0x004b, \"LATIN CAPITAL LETTER K\" },\n\t{ \"L \", 0x004c, \"LATIN CAPITAL LETTER L\" },\n\t{ \"M \", 0x004d, \"LATIN CAPITAL LETTER M\" },\n\t{ \"N \", 0x004e, \"LATIN CAPITAL LETTER N\" },\n\t{ \"O \", 0x004f, \"LATIN CAPITAL LETTER O\" },\n\t{ \"P \", 0x0050, \"LATIN CAPITAL LETTER P\" },\n\t{ \"Q \", 0x0051, \"LATIN CAPITAL LETTER Q\" },\n\t{ \"R \", 0x0052, \"LATIN CAPITAL LETTER R\" },\n\t{ \"S \", 0x0053, \"LATIN CAPITAL LETTER S\" },\n\t{ \"T \", 0x0054, \"LATIN CAPITAL LETTER T\" },\n\t{ \"U \", 0x0055, \"LATIN CAPITAL LETTER U\" },\n\t{ \"V \", 0x0056, \"LATIN CAPITAL LETTER V\" },\n\t{ \"W \", 0x0057, \"LATIN CAPITAL LETTER W\" },\n\t{ \"X \", 0x0058, \"LATIN CAPITAL LETTER X\" },\n\t{ \"Y \", 0x0059, \"LATIN CAPITAL LETTER Y\" },\n\t{ \"Z \", 0x005a, \"LATIN CAPITAL LETTER Z\" },\n\t{ \"<(\", 0x005b, \"LEFT SQUARE BRACKET\" },\n\t{ \"//\", 0x005c, \"REVERSE SOLIDUS\" },\n\t{ \")>\", 0x005d, \"RIGHT SQUARE BRACKET\" },\n\t{ \"'>\", 0x005e, \"CIRCUMFLEX ACCENT\" },\n\t{ \"_ \", 0x005f, \"LOW LINE\" },\n\t{ \"'!\", 0x0060, \"GRAVE ACCENT\" },\n\t{ \"a \", 0x0061, \"LATIN SMALL LETTER A\" },\n\t{ \"b \", 0x0062, \"LATIN SMALL LETTER B\" },\n\t{ \"c \", 0x0063, \"LATIN SMALL LETTER C\" },\n\t{ \"d \", 0x0064, \"LATIN SMALL LETTER D\" },\n\t{ \"e \", 0x0065, \"LATIN SMALL LETTER E\" },\n\t{ \"f \", 0x0066, \"LATIN SMALL LETTER F\" },\n\t{ \"g \", 0x0067, \"LATIN SMALL LETTER G\" },\n\t{ \"h \", 0x0068, \"LATIN SMALL LETTER H\" },\n\t{ \"i \", 0x0069, \"LATIN SMALL LETTER I\" },\n\t{ \"j \", 0x006a, \"LATIN SMALL LETTER J\" },\n\t{ \"k \", 0x006b, \"LATIN SMALL LETTER K\" },\n\t{ \"l \", 0x006c, \"LATIN SMALL LETTER L\" },\n\t{ \"m \", 0x006d, \"LATIN SMALL LETTER M\" },\n\t{ \"n \", 0x006e, \"LATIN SMALL LETTER N\" },\n\t{ \"o \", 0x006f, \"LATIN SMALL LETTER O\" },\n\t{ \"p \", 0x0070, \"LATIN SMALL LETTER P\" },\n\t{ \"q \", 0x0071, \"LATIN SMALL LETTER Q\" },\n\t{ \"r \", 0x0072, \"LATIN SMALL LETTER R\" },\n\t{ \"s \", 0x0073, \"LATIN SMALL LETTER S\" },\n\t{ \"t \", 0x0074, \"LATIN SMALL LETTER T\" },\n\t{ \"u \", 0x0075, \"LATIN SMALL LETTER U\" },\n\t{ \"v \", 0x0076, \"LATIN SMALL LETTER V\" },\n\t{ \"w \", 0x0077, \"LATIN SMALL LETTER W\" },\n\t{ \"x \", 0x0078, \"LATIN SMALL LETTER X\" },\n\t{ \"y \", 0x0079, \"LATIN SMALL LETTER Y\" },\n\t{ \"z \", 0x007a, \"LATIN SMALL LETTER Z\" },\n\t{ \"(!\", 0x007b, \"LEFT CURLY BRACKET\" },\n\t{ \"!!\", 0x007c, \"VERTICAL LINE\" },\n\t{ \"!)\", 0x007d, \"RIGHT CURLY BRACKET\" },\n\t{ \"'?\", 0x007e, \"TILDE\" },\n\t{ \"NS\", 0x00a0, \"NO-BREAK SPACE\" },\n\t{ \"!I\", 0x00a1, \"INVERTED EXCLAMATION MARK\" },\n\t{ \"Ct\", 0x00a2, \"CENT SIGN\" },\n\t{ \"Pd\", 0x00a3, \"POUND SIGN\" },\n\t{ \"Cu\", 0x00a4, \"CURRENCY SIGN\" },\n\t{ \"Ye\", 0x00a5, \"YEN SIGN\" },\n\t{ \"BB\", 0x00a6, \"BROKEN BAR\" },\n\t{ \"SE\", 0x00a7, \"SECTION SIGN\" },\n\t{ \"':\", 0x00a8, \"DIAERESIS\" },\n\t{ \"Co\", 0x00a9, \"COPYRIGHT SIGN\" },\n\t{ \"-a\", 0x00aa, \"FEMININE ORDINAL INDICATOR\" },\n\t{ \"<<\", 0x00ab, \"LEFT-POINTING DOUBLE ANGLE QUOTATION MARK\" },\n\t{ \"NO\", 0x00ac, \"NOT SIGN\" },\n\t{ \"--\", 0x00ad, \"SOFT HYPHEN\" },\n\t{ \"Rg\", 0x00ae, \"REGISTERED SIGN\" },\n\t{ \"'m\", 0x00af, \"MACRON\" },\n\t{ \"DG\", 0x00b0, \"DEGREE SIGN\" },\n\t{ \"+-\", 0x00b1, \"PLUS-MINUS SIGN\" },\n\t{ \"2S\", 0x00b2, \"SUPERSCRIPT TWO\" },\n\t{ \"3S\", 0x00b3, \"SUPERSCRIPT THREE\" },\n\t{ \"''\", 0x00b4, \"ACUTE ACCENT\" },\n\t{ \"My\", 0x00b5, \"MICRO SIGN\" },\n\t{ \"PI\", 0x00b6, \"PILCROW SIGN\" },\n\t{ \".M\", 0x00b7, \"MIDDLE DOT\" },\n\t{ \"',\", 0x00b8, \"CEDILLA\" },\n\t{ \"1S\", 0x00b9, \"SUPERSCRIPT ONE\" },\n\t{ \"-o\", 0x00ba, \"MASCULINE ORDINAL INDICATOR\" },\n\t{ \">>\", 0x00bb, \"RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK\" },\n\t{ \"14\", 0x00bc, \"VULGAR FRACTION ONE QUARTER\" },\n\t{ \"12\", 0x00bd, \"VULGAR FRACTION ONE HALF\" },\n\t{ \"34\", 0x00be, \"VULGAR FRACTION THREE QUARTERS\" },\n\t{ \"?I\", 0x00bf, \"INVERTED QUESTION MARK\" },\n\t{ \"A!\", 0x00c0, \"LATIN CAPITAL LETTER A WITH GRAVE\" },\n\t{ \"A'\", 0x00c1, \"LATIN CAPITAL LETTER A WITH ACUTE\" },\n\t{ \"A>\", 0x00c2, \"LATIN CAPITAL LETTER A WITH CIRCUMFLEX\" },\n\t{ \"A?\", 0x00c3, \"LATIN CAPITAL LETTER A WITH TILDE\" },\n\t{ \"A:\", 0x00c4, \"LATIN CAPITAL LETTER A WITH DIAERESIS\" },\n\t{ \"AA\", 0x00c5, \"LATIN CAPITAL LETTER A WITH RING ABOVE\" },\n\t{ \"AE\", 0x00c6, \"LATIN CAPITAL LETTER AE\" },\n\t{ \"C,\", 0x00c7, \"LATIN CAPITAL LETTER C WITH CEDILLA\" },\n\t{ \"E!\", 0x00c8, \"LATIN CAPITAL LETTER E WITH GRAVE\" },\n\t{ \"E'\", 0x00c9, \"LATIN CAPITAL LETTER E WITH ACUTE\" },\n\t{ \"E>\", 0x00ca, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX\" },\n\t{ \"E:\", 0x00cb, \"LATIN CAPITAL LETTER E WITH DIAERESIS\" },\n\t{ \"I!\", 0x00cc, \"LATIN CAPITAL LETTER I WITH GRAVE\" },\n\t{ \"I'\", 0x00cd, \"LATIN CAPITAL LETTER I WITH ACUTE\" },\n\t{ \"I>\", 0x00ce, \"LATIN CAPITAL LETTER I WITH CIRCUMFLEX\" },\n\t{ \"I:\", 0x00cf, \"LATIN CAPITAL LETTER I WITH DIAERESIS\" },\n\t{ \"D-\", 0x00d0, \"LATIN CAPITAL LETTER ETH (Icelandic)\" },\n\t{ \"N?\", 0x00d1, \"LATIN CAPITAL LETTER N WITH TILDE\" },\n\t{ \"O!\", 0x00d2, \"LATIN CAPITAL LETTER O WITH GRAVE\" },\n\t{ \"O'\", 0x00d3, \"LATIN CAPITAL LETTER O WITH ACUTE\" },\n\t{ \"O>\", 0x00d4, \"LATIN CAPITAL LETTER O WITH CIRCUMFLEX\" },\n\t{ \"O?\", 0x00d5, \"LATIN CAPITAL LETTER O WITH TILDE\" },\n\t{ \"O:\", 0x00d6, \"LATIN CAPITAL LETTER O WITH DIAERESIS\" },\n\t{ \"*X\", 0x00d7, \"MULTIPLICATION SIGN\" },\n\t{ \"O/\", 0x00d8, \"LATIN CAPITAL LETTER O WITH STROKE\" },\n\t{ \"U!\", 0x00d9, \"LATIN CAPITAL LETTER U WITH GRAVE\" },\n\t{ \"U'\", 0x00da, \"LATIN CAPITAL LETTER U WITH ACUTE\" },\n\t{ \"U>\", 0x00db, \"LATIN CAPITAL LETTER U WITH CIRCUMFLEX\" },\n\t{ \"U:\", 0x00dc, \"LATIN CAPITAL LETTER U WITH DIAERESIS\" },\n\t{ \"Y'\", 0x00dd, \"LATIN CAPITAL LETTER Y WITH ACUTE\" },\n\t{ \"TH\", 0x00de, \"LATIN CAPITAL LETTER THORN (Icelandic)\" },\n\t{ \"ss\", 0x00df, \"LATIN SMALL LETTER SHARP S (German)\" },\n\t{ \"a!\", 0x00e0, \"LATIN SMALL LETTER A WITH GRAVE\" },\n\t{ \"a'\", 0x00e1, \"LATIN SMALL LETTER A WITH ACUTE\" },\n\t{ \"a>\", 0x00e2, \"LATIN SMALL LETTER A WITH CIRCUMFLEX\" },\n\t{ \"a?\", 0x00e3, \"LATIN SMALL LETTER A WITH TILDE\" },\n\t{ \"a:\", 0x00e4, \"LATIN SMALL LETTER A WITH DIAERESIS\" },\n\t{ \"aa\", 0x00e5, \"LATIN SMALL LETTER A WITH RING ABOVE\" },\n\t{ \"ae\", 0x00e6, \"LATIN SMALL LETTER AE\" },\n\t{ \"c,\", 0x00e7, \"LATIN SMALL LETTER C WITH CEDILLA\" },\n\t{ \"e!\", 0x00e8, \"LATIN SMALL LETTER E WITH GRAVE\" },\n\t{ \"e'\", 0x00e9, \"LATIN SMALL LETTER E WITH ACUTE\" },\n\t{ \"e>\", 0x00ea, \"LATIN SMALL LETTER E WITH CIRCUMFLEX\" },\n\t{ \"e:\", 0x00eb, \"LATIN SMALL LETTER E WITH DIAERESIS\" },\n\t{ \"i!\", 0x00ec, \"LATIN SMALL LETTER I WITH GRAVE\" },\n\t{ \"i'\", 0x00ed, \"LATIN SMALL LETTER I WITH ACUTE\" },\n\t{ \"i>\", 0x00ee, \"LATIN SMALL LETTER I WITH CIRCUMFLEX\" },\n\t{ \"i:\", 0x00ef, \"LATIN SMALL LETTER I WITH DIAERESIS\" },\n\t{ \"d-\", 0x00f0, \"LATIN SMALL LETTER ETH (Icelandic)\" },\n\t{ \"n?\", 0x00f1, \"LATIN SMALL LETTER N WITH TILDE\" },\n\t{ \"o!\", 0x00f2, \"LATIN SMALL LETTER O WITH GRAVE\" },\n\t{ \"o'\", 0x00f3, \"LATIN SMALL LETTER O WITH ACUTE\" },\n\t{ \"o>\", 0x00f4, \"LATIN SMALL LETTER O WITH CIRCUMFLEX\" },\n\t{ \"o?\", 0x00f5, \"LATIN SMALL LETTER O WITH TILDE\" },\n\t{ \"o:\", 0x00f6, \"LATIN SMALL LETTER O WITH DIAERESIS\" },\n\t{ \"-:\", 0x00f7, \"DIVISION SIGN\" },\n\t{ \"o/\", 0x00f8, \"LATIN SMALL LETTER O WITH STROKE\" },\n\t{ \"u!\", 0x00f9, \"LATIN SMALL LETTER U WITH GRAVE\" },\n\t{ \"u'\", 0x00fa, \"LATIN SMALL LETTER U WITH ACUTE\" },\n\t{ \"u>\", 0x00fb, \"LATIN SMALL LETTER U WITH CIRCUMFLEX\" },\n\t{ \"u:\", 0x00fc, \"LATIN SMALL LETTER U WITH DIAERESIS\" },\n\t{ \"y'\", 0x00fd, \"LATIN SMALL LETTER Y WITH ACUTE\" },\n\t{ \"th\", 0x00fe, \"LATIN SMALL LETTER THORN (Icelandic)\" },\n\t{ \"y:\", 0x00ff, \"LATIN SMALL LETTER Y WITH DIAERESIS\" },\n\t{ \"A-\", 0x0100, \"LATIN CAPITAL LETTER A WITH MACRON\" },\n\t{ \"a-\", 0x0101, \"LATIN SMALL LETTER A WITH MACRON\" },\n\t{ \"A(\", 0x0102, \"LATIN CAPITAL LETTER A WITH BREVE\" },\n\t{ \"a(\", 0x0103, \"LATIN SMALL LETTER A WITH BREVE\" },\n\t{ \"A;\", 0x0104, \"LATIN CAPITAL LETTER A WITH OGONEK\" },\n\t{ \"a;\", 0x0105, \"LATIN SMALL LETTER A WITH OGONEK\" },\n\t{ \"C'\", 0x0106, \"LATIN CAPITAL LETTER C WITH ACUTE\" },\n\t{ \"c'\", 0x0107, \"LATIN SMALL LETTER C WITH ACUTE\" },\n\t{ \"C>\", 0x0108, \"LATIN CAPITAL LETTER C WITH CIRCUMFLEX\" },\n\t{ \"c>\", 0x0109, \"LATIN SMALL LETTER C WITH CIRCUMFLEX\" },\n\t{ \"C.\", 0x010a, \"LATIN CAPITAL LETTER C WITH DOT ABOVE\" },\n\t{ \"c.\", 0x010b, \"LATIN SMALL LETTER C WITH DOT ABOVE\" },\n\t{ \"C<\", 0x010c, \"LATIN CAPITAL LETTER C WITH CARON\" },\n\t{ \"c<\", 0x010d, \"LATIN SMALL LETTER C WITH CARON\" },\n\t{ \"D<\", 0x010e, \"LATIN CAPITAL LETTER D WITH CARON\" },\n\t{ \"d<\", 0x010f, \"LATIN SMALL LETTER D WITH CARON\" },\n\t{ \"D/\", 0x0110, \"LATIN CAPITAL LETTER D WITH STROKE\" },\n\t{ \"d/\", 0x0111, \"LATIN SMALL LETTER D WITH STROKE\" },\n\t{ \"E-\", 0x0112, \"LATIN CAPITAL LETTER E WITH MACRON\" },\n\t{ \"e-\", 0x0113, \"LATIN SMALL LETTER E WITH MACRON\" },\n\t{ \"E(\", 0x0114, \"LATIN CAPITAL LETTER E WITH BREVE\" },\n\t{ \"e(\", 0x0115, \"LATIN SMALL LETTER E WITH BREVE\" },\n\t{ \"E.\", 0x0116, \"LATIN CAPITAL LETTER E WITH DOT ABOVE\" },\n\t{ \"e.\", 0x0117, \"LATIN SMALL LETTER E WITH DOT ABOVE\" },\n\t{ \"E;\", 0x0118, \"LATIN CAPITAL LETTER E WITH OGONEK\" },\n\t{ \"e;\", 0x0119, \"LATIN SMALL LETTER E WITH OGONEK\" },\n\t{ \"E<\", 0x011a, \"LATIN CAPITAL LETTER E WITH CARON\" },\n\t{ \"e<\", 0x011b, \"LATIN SMALL LETTER E WITH CARON\" },\n\t{ \"G>\", 0x011c, \"LATIN CAPITAL LETTER G WITH CIRCUMFLEX\" },\n\t{ \"g>\", 0x011d, \"LATIN SMALL LETTER G WITH CIRCUMFLEX\" },\n\t{ \"G(\", 0x011e, \"LATIN CAPITAL LETTER G WITH BREVE\" },\n\t{ \"g(\", 0x011f, \"LATIN SMALL LETTER G WITH BREVE\" },\n\t{ \"G.\", 0x0120, \"LATIN CAPITAL LETTER G WITH DOT ABOVE\" },\n\t{ \"g.\", 0x0121, \"LATIN SMALL LETTER G WITH DOT ABOVE\" },\n\t{ \"G,\", 0x0122, \"LATIN CAPITAL LETTER G WITH CEDILLA\" },\n\t{ \"g,\", 0x0123, \"LATIN SMALL LETTER G WITH CEDILLA\" },\n\t{ \"H>\", 0x0124, \"LATIN CAPITAL LETTER H WITH CIRCUMFLEX\" },\n\t{ \"h>\", 0x0125, \"LATIN SMALL LETTER H WITH CIRCUMFLEX\" },\n\t{ \"H/\", 0x0126, \"LATIN CAPITAL LETTER H WITH STROKE\" },\n\t{ \"h/\", 0x0127, \"LATIN SMALL LETTER H WITH STROKE\" },\n\t{ \"I?\", 0x0128, \"LATIN CAPITAL LETTER I WITH TILDE\" },\n\t{ \"i?\", 0x0129, \"LATIN SMALL LETTER I WITH TILDE\" },\n\t{ \"I-\", 0x012a, \"LATIN CAPITAL LETTER I WITH MACRON\" },\n\t{ \"i-\", 0x012b, \"LATIN SMALL LETTER I WITH MACRON\" },\n\t{ \"I(\", 0x012c, \"LATIN CAPITAL LETTER I WITH BREVE\" },\n\t{ \"i(\", 0x012d, \"LATIN SMALL LETTER I WITH BREVE\" },\n\t{ \"I;\", 0x012e, \"LATIN CAPITAL LETTER I WITH OGONEK\" },\n\t{ \"i;\", 0x012f, \"LATIN SMALL LETTER I WITH OGONEK\" },\n\t{ \"I.\", 0x0130, \"LATIN CAPITAL LETTER I WITH DOT ABOVE\" },\n\t{ \"i.\", 0x0131, \"LATIN SMALL LETTER I DOTLESS\" },\n\t{ \"IJ\", 0x0132, \"LATIN CAPITAL LIGATURE IJ\" },\n\t{ \"ij\", 0x0133, \"LATIN SMALL LIGATURE IJ\" },\n\t{ \"J>\", 0x0134, \"LATIN CAPITAL LETTER J WITH CIRCUMFLEX\" },\n\t{ \"j>\", 0x0135, \"LATIN SMALL LETTER J WITH CIRCUMFLEX\" },\n\t{ \"K,\", 0x0136, \"LATIN CAPITAL LETTER K WITH CEDILLA\" },\n\t{ \"k,\", 0x0137, \"LATIN SMALL LETTER K WITH CEDILLA\" },\n\t{ \"kk\", 0x0138, \"LATIN SMALL LETTER KRA (Greenlandic)\" },\n\t{ \"L'\", 0x0139, \"LATIN CAPITAL LETTER L WITH ACUTE\" },\n\t{ \"l'\", 0x013a, \"LATIN SMALL LETTER L WITH ACUTE\" },\n\t{ \"L,\", 0x013b, \"LATIN CAPITAL LETTER L WITH CEDILLA\" },\n\t{ \"l,\", 0x013c, \"LATIN SMALL LETTER L WITH CEDILLA\" },\n\t{ \"L<\", 0x013d, \"LATIN CAPITAL LETTER L WITH CARON\" },\n\t{ \"l<\", 0x013e, \"LATIN SMALL LETTER L WITH CARON\" },\n\t{ \"L.\", 0x013f, \"LATIN CAPITAL LETTER L WITH MIDDLE DOT\" },\n\t{ \"l.\", 0x0140, \"LATIN SMALL LETTER L WITH MIDDLE DOT\" },\n\t{ \"L/\", 0x0141, \"LATIN CAPITAL LETTER L WITH STROKE\" },\n\t{ \"l/\", 0x0142, \"LATIN SMALL LETTER L WITH STROKE\" },\n\t{ \"N'\", 0x0143, \"LATIN CAPITAL LETTER N WITH ACUTE\" },\n\t{ \"n'\", 0x0144, \"LATIN SMALL LETTER N WITH ACUTE\" },\n\t{ \"N,\", 0x0145, \"LATIN CAPITAL LETTER N WITH CEDILLA\" },\n\t{ \"n,\", 0x0146, \"LATIN SMALL LETTER N WITH CEDILLA\" },\n\t{ \"N<\", 0x0147, \"LATIN CAPITAL LETTER N WITH CARON\" },\n\t{ \"n<\", 0x0148, \"LATIN SMALL LETTER N WITH CARON\" },\n\t{ \"'n\", 0x0149, \"LATIN SMALL LETTER N PRECEDED BY APOSTROPHE\" },\n\t{ \"NG\", 0x014a, \"LATIN CAPITAL LETTER ENG (Lappish)\" },\n\t{ \"ng\", 0x014b, \"LATIN SMALL LETTER ENG (Lappish)\" },\n\t{ \"O-\", 0x014c, \"LATIN CAPITAL LETTER O WITH MACRON\" },\n\t{ \"o-\", 0x014d, \"LATIN SMALL LETTER O WITH MACRON\" },\n\t{ \"O(\", 0x014e, \"LATIN CAPITAL LETTER O WITH BREVE\" },\n\t{ \"o(\", 0x014f, \"LATIN SMALL LETTER O WITH BREVE\" },\n\t{ \"O\\\"\", 0x0150, \"LATIN CAPITAL LETTER O WITH DOUBLE ACUTE\" },\n\t{ \"o\\\"\", 0x0151, \"LATIN SMALL LETTER O WITH DOUBLE ACUTE\" },\n\t{ \"OE\", 0x0152, \"LATIN CAPITAL LIGATURE OE\" },\n\t{ \"oe\", 0x0153, \"LATIN SMALL LIGATURE OE\" },\n\t{ \"R'\", 0x0154, \"LATIN CAPITAL LETTER R WITH ACUTE\" },\n\t{ \"r'\", 0x0155, \"LATIN SMALL LETTER R WITH ACUTE\" },\n\t{ \"R,\", 0x0156, \"LATIN CAPITAL LETTER R WITH CEDILLA\" },\n\t{ \"r,\", 0x0157, \"LATIN SMALL LETTER R WITH CEDILLA\" },\n\t{ \"R<\", 0x0158, \"LATIN CAPITAL LETTER R WITH CARON\" },\n\t{ \"r<\", 0x0159, \"LATIN SMALL LETTER R WITH CARON\" },\n\t{ \"S'\", 0x015a, \"LATIN CAPITAL LETTER S WITH ACUTE\" },\n\t{ \"s'\", 0x015b, \"LATIN SMALL LETTER S WITH ACUTE\" },\n\t{ \"S>\", 0x015c, \"LATIN CAPITAL LETTER S WITH CIRCUMFLEX\" },\n\t{ \"s>\", 0x015d, \"LATIN SMALL LETTER S WITH CIRCUMFLEX\" },\n\t{ \"S,\", 0x015e, \"LATIN CAPITAL LETTER S WITH CEDILLA\" },\n\t{ \"s,\", 0x015f, \"LATIN SMALL LETTER S WITH CEDILLA\" },\n\t{ \"S<\", 0x0160, \"LATIN CAPITAL LETTER S WITH CARON\" },\n\t{ \"s<\", 0x0161, \"LATIN SMALL LETTER S WITH CARON\" },\n\t{ \"T,\", 0x0162, \"LATIN CAPITAL LETTER T WITH CEDILLA\" },\n\t{ \"t,\", 0x0163, \"LATIN SMALL LETTER T WITH CEDILLA\" },\n\t{ \"T<\", 0x0164, \"LATIN CAPITAL LETTER T WITH CARON\" },\n\t{ \"t<\", 0x0165, \"LATIN SMALL LETTER T WITH CARON\" },\n\t{ \"T/\", 0x0166, \"LATIN CAPITAL LETTER T WITH STROKE\" },\n\t{ \"t/\", 0x0167, \"LATIN SMALL LETTER T WITH STROKE\" },\n\t{ \"U?\", 0x0168, \"LATIN CAPITAL LETTER U WITH TILDE\" },\n\t{ \"u?\", 0x0169, \"LATIN SMALL LETTER U WITH TILDE\" },\n\t{ \"U-\", 0x016a, \"LATIN CAPITAL LETTER U WITH MACRON\" },\n\t{ \"u-\", 0x016b, \"LATIN SMALL LETTER U WITH MACRON\" },\n\t{ \"U(\", 0x016c, \"LATIN CAPITAL LETTER U WITH BREVE\" },\n\t{ \"u(\", 0x016d, \"LATIN SMALL LETTER U WITH BREVE\" },\n\t{ \"U0\", 0x016e, \"LATIN CAPITAL LETTER U WITH RING ABOVE\" },\n\t{ \"u0\", 0x016f, \"LATIN SMALL LETTER U WITH RING ABOVE\" },\n\t{ \"U\\\"\", 0x0170, \"LATIN CAPITAL LETTER U WITH DOUBLE ACUTE\" },\n\t{ \"u\\\"\", 0x0171, \"LATIN SMALL LETTER U WITH DOUBLE ACUTE\" },\n\t{ \"U;\", 0x0172, \"LATIN CAPITAL LETTER U WITH OGONEK\" },\n\t{ \"u;\", 0x0173, \"LATIN SMALL LETTER U WITH OGONEK\" },\n\t{ \"W>\", 0x0174, \"LATIN CAPITAL LETTER W WITH CIRCUMFLEX\" },\n\t{ \"w>\", 0x0175, \"LATIN SMALL LETTER W WITH CIRCUMFLEX\" },\n\t{ \"Y>\", 0x0176, \"LATIN CAPITAL LETTER Y WITH CIRCUMFLEX\" },\n\t{ \"y>\", 0x0177, \"LATIN SMALL LETTER Y WITH CIRCUMFLEX\" },\n\t{ \"Y:\", 0x0178, \"LATIN CAPITAL LETTER Y WITH DIAERESIS\" },\n\t{ \"Z'\", 0x0179, \"LATIN CAPITAL LETTER Z WITH ACUTE\" },\n\t{ \"z'\", 0x017a, \"LATIN SMALL LETTER Z WITH ACUTE\" },\n\t{ \"Z.\", 0x017b, \"LATIN CAPITAL LETTER Z WITH DOT ABOVE\" },\n\t{ \"z.\", 0x017c, \"LATIN SMALL LETTER Z WITH DOT ABOVE\" },\n\t{ \"Z<\", 0x017d, \"LATIN CAPITAL LETTER Z WITH CARON\" },\n\t{ \"z<\", 0x017e, \"LATIN SMALL LETTER Z WITH CARON\" },\n\t{ \"O9\", 0x01a0, \"LATIN CAPITAL LETTER O WITH HORN\" },\n\t{ \"o9\", 0x01a1, \"LATIN SMALL LETTER O WITH HORN\" },\n\t{ \"OI\", 0x01a2, \"LATIN CAPITAL LETTER OI\" },\n\t{ \"oi\", 0x01a3, \"LATIN SMALL LETTER OI\" },\n\t{ \"yr\", 0x01a6, \"LATIN LETTER YR\" },\n\t{ \"U9\", 0x01af, \"LATIN CAPITAL LETTER U WITH HORN\" },\n\t{ \"u9\", 0x01b0, \"LATIN SMALL LETTER U WITH HORN\" },\n\t{ \"Z/\", 0x01b5, \"LATIN CAPITAL LETTER Z WITH STROKE\" },\n\t{ \"z/\", 0x01b6, \"LATIN SMALL LETTER Z WITH STROKE\" },\n\t{ \"ED\", 0x01b7, \"LATIN CAPITAL LETTER EZH\" },\n\t{ \"A<\", 0x01cd, \"LATIN CAPITAL LETTER A WITH CARON\" },\n\t{ \"a<\", 0x01ce, \"LATIN SMALL LETTER A WITH CARON\" },\n\t{ \"I<\", 0x01cf, \"LATIN CAPITAL LETTER I WITH CARON\" },\n\t{ \"i<\", 0x01d0, \"LATIN SMALL LETTER I WITH CARON\" },\n\t{ \"O<\", 0x01d1, \"LATIN CAPITAL LETTER O WITH CARON\" },\n\t{ \"o<\", 0x01d2, \"LATIN SMALL LETTER O WITH CARON\" },\n\t{ \"U<\", 0x01d3, \"LATIN CAPITAL LETTER U WITH CARON\" },\n\t{ \"u<\", 0x01d4, \"LATIN SMALL LETTER U WITH CARON\" },\n\t{ \"U:-\", 0x01d5, \"LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON\" },\n\t{ \"u:-\", 0x01d6, \"LATIN SMALL LETTER U WITH DIAERESIS AND MACRON\" },\n\t{ \"U:'\", 0x01d7, \"LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE\" },\n\t{ \"u:'\", 0x01d8, \"LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE\" },\n\t{ \"U:<\", 0x01d9, \"LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON\" },\n\t{ \"u:<\", 0x01da, \"LATIN SMALL LETTER U WITH DIAERESIS AND CARON\" },\n\t{ \"U:!\", 0x01db, \"LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE\" },\n\t{ \"u:!\", 0x01dc, \"LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE\" },\n\t{ \"A1\", 0x01de, \"LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON\" },\n\t{ \"a1\", 0x01df, \"LATIN SMALL LETTER A WITH DIAERESIS AND MACRON\" },\n\t{ \"A7\", 0x01e0, \"LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON\" },\n\t{ \"a7\", 0x01e1, \"LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON\" },\n\t{ \"A3\", 0x01e2, \"LATIN CAPITAL LETTER AE WITH MACRON\" },\n\t{ \"a3\", 0x01e3, \"LATIN SMALL LETTER AE WITH MACRON\" },\n\t{ \"G/\", 0x01e4, \"LATIN CAPITAL LETTER G WITH STROKE\" },\n\t{ \"g/\", 0x01e5, \"LATIN SMALL LETTER G WITH STROKE\" },\n\t{ \"G<\", 0x01e6, \"LATIN CAPITAL LETTER G WITH CARON\" },\n\t{ \"g<\", 0x01e7, \"LATIN SMALL LETTER G WITH CARON\" },\n\t{ \"K<\", 0x01e8, \"LATIN CAPITAL LETTER K WITH CARON\" },\n\t{ \"k<\", 0x01e9, \"LATIN SMALL LETTER K WITH CARON\" },\n\t{ \"O;\", 0x01ea, \"LATIN CAPITAL LETTER O WITH OGONEK\" },\n\t{ \"o;\", 0x01eb, \"LATIN SMALL LETTER O WITH OGONEK\" },\n\t{ \"O1\", 0x01ec, \"LATIN CAPITAL LETTER O WITH OGONEK AND MACRON\" },\n\t{ \"o1\", 0x01ed, \"LATIN SMALL LETTER O WITH OGONEK AND MACRON\" },\n\t{ \"EZ\", 0x01ee, \"LATIN CAPITAL LETTER EZH WITH CARON\" },\n\t{ \"ez\", 0x01ef, \"LATIN SMALL LETTER EZH WITH CARON\" },\n\t{ \"j<\", 0x01f0, \"LATIN SMALL LETTER J WITH CARON\" },\n\t{ \"G'\", 0x01f4, \"LATIN CAPITAL LETTER G WITH ACUTE\" },\n\t{ \"g'\", 0x01f5, \"LATIN SMALL LETTER G WITH ACUTE\" },\n\t{ \"AA'\", 0x01fa, \"LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE\" },\n\t{ \"aa'\", 0x01fb, \"LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE\" },\n\t{ \"AE'\", 0x01fc, \"LATIN CAPITAL LETTER AE WITH ACUTE\" },\n\t{ \"ae'\", 0x01fd, \"LATIN SMALL LETTER AE WITH ACUTE\" },\n\t{ \"O/'\", 0x01fe, \"LATIN CAPITAL LETTER O WITH STROKE AND ACUTE\" },\n\t{ \"o/'\", 0x01ff, \"LATIN SMALL LETTER O WITH STROKE AND ACUTE\" },\n\t{ \";S\", 0x02bf, \"MODIFIER LETTER LEFT HALF RING\" },\n\t{ \"'<\", 0x02c7, \"CARON\" },\n\t{ \"'(\", 0x02d8, \"BREVE\" },\n\t{ \"'.\", 0x02d9, \"DOT ABOVE\" },\n\t{ \"'0\", 0x02da, \"RING ABOVE\" },\n\t{ \"';\", 0x02db, \"OGONEK\" },\n\t{ \"'\\\"\", 0x02dd, \"DOUBLE ACUTE ACCENT\" },\n\t{ \"A%\", 0x0386, \"GREEK CAPITAL LETTER ALPHA WITH ACUTE\" },\n\t{ \"E%\", 0x0388, \"GREEK CAPITAL LETTER EPSILON WITH ACUTE\" },\n\t{ \"Y%\", 0x0389, \"GREEK CAPITAL LETTER ETA WITH ACUTE\" },\n\t{ \"I%\", 0x038a, \"GREEK CAPITAL LETTER IOTA WITH ACUTE\" },\n\t{ \"O%\", 0x038c, \"GREEK CAPITAL LETTER OMICRON WITH ACUTE\" },\n\t{ \"U%\", 0x038e, \"GREEK CAPITAL LETTER UPSILON WITH ACUTE\" },\n\t{ \"W%\", 0x038f, \"GREEK CAPITAL LETTER OMEGA WITH ACUTE\" },\n\t{ \"i3\", 0x0390, \"GREEK SMALL LETTER IOTA WITH ACUTE AND DIAERESIS\" },\n\t{ \"A*\", 0x0391, \"GREEK CAPITAL LETTER ALPHA\" },\n\t{ \"B*\", 0x0392, \"GREEK CAPITAL LETTER BETA\" },\n\t{ \"G*\", 0x0393, \"GREEK CAPITAL LETTER GAMMA\" },\n\t{ \"D*\", 0x0394, \"GREEK CAPITAL LETTER DELTA\" },\n\t{ \"E*\", 0x0395, \"GREEK CAPITAL LETTER EPSILON\" },\n\t{ \"Z*\", 0x0396, \"GREEK CAPITAL LETTER ZETA\" },\n\t{ \"Y*\", 0x0397, \"GREEK CAPITAL LETTER ETA\" },\n\t{ \"H*\", 0x0398, \"GREEK CAPITAL LETTER THETA\" },\n\t{ \"I*\", 0x0399, \"GREEK CAPITAL LETTER IOTA\" },\n\t{ \"K*\", 0x039a, \"GREEK CAPITAL LETTER KAPPA\" },\n\t{ \"L*\", 0x039b, \"GREEK CAPITAL LETTER LAMDA\" },\n\t{ \"M*\", 0x039c, \"GREEK CAPITAL LETTER MU\" },\n\t{ \"N*\", 0x039d, \"GREEK CAPITAL LETTER NU\" },\n\t{ \"C*\", 0x039e, \"GREEK CAPITAL LETTER XI\" },\n\t{ \"O*\", 0x039f, \"GREEK CAPITAL LETTER OMICRON\" },\n\t{ \"P*\", 0x03a0, \"GREEK CAPITAL LETTER PI\" },\n\t{ \"R*\", 0x03a1, \"GREEK CAPITAL LETTER RHO\" },\n\t{ \"S*\", 0x03a3, \"GREEK CAPITAL LETTER SIGMA\" },\n\t{ \"T*\", 0x03a4, \"GREEK CAPITAL LETTER TAU\" },\n\t{ \"U*\", 0x03a5, \"GREEK CAPITAL LETTER UPSILON\" },\n\t{ \"F*\", 0x03a6, \"GREEK CAPITAL LETTER PHI\" },\n\t{ \"X*\", 0x03a7, \"GREEK CAPITAL LETTER CHI\" },\n\t{ \"Q*\", 0x03a8, \"GREEK CAPITAL LETTER PSI\" },\n\t{ \"W*\", 0x03a9, \"GREEK CAPITAL LETTER OMEGA\" },\n\t{ \"J*\", 0x03aa, \"GREEK CAPITAL LETTER IOTA WITH DIAERESIS\" },\n\t{ \"V*\", 0x03ab, \"GREEK CAPITAL LETTER UPSILON WITH DIAERESIS\" },\n\t{ \"a%\", 0x03ac, \"GREEK SMALL LETTER ALPHA WITH ACUTE\" },\n\t{ \"e%\", 0x03ad, \"GREEK SMALL LETTER EPSILON WITH ACUTE\" },\n\t{ \"y%\", 0x03ae, \"GREEK SMALL LETTER ETA WITH ACUTE\" },\n\t{ \"i%\", 0x03af, \"GREEK SMALL LETTER IOTA WITH ACUTE\" },\n\t{ \"u3\", 0x03b0, \"GREEK SMALL LETTER UPSILON WITH ACUTE AND DIAERESIS\" },\n\t{ \"a*\", 0x03b1, \"GREEK SMALL LETTER ALPHA\" },\n\t{ \"b*\", 0x03b2, \"GREEK SMALL LETTER BETA\" },\n\t{ \"g*\", 0x03b3, \"GREEK SMALL LETTER GAMMA\" },\n\t{ \"d*\", 0x03b4, \"GREEK SMALL LETTER DELTA\" },\n\t{ \"e*\", 0x03b5, \"GREEK SMALL LETTER EPSILON\" },\n\t{ \"z*\", 0x03b6, \"GREEK SMALL LETTER ZETA\" },\n\t{ \"y*\", 0x03b7, \"GREEK SMALL LETTER ETA\" },\n\t{ \"h*\", 0x03b8, \"GREEK SMALL LETTER THETA\" },\n\t{ \"i*\", 0x03b9, \"GREEK SMALL LETTER IOTA\" },\n\t{ \"k*\", 0x03ba, \"GREEK SMALL LETTER KAPPA\" },\n\t{ \"l*\", 0x03bb, \"GREEK SMALL LETTER LAMDA\" },\n\t{ \"m*\", 0x03bc, \"GREEK SMALL LETTER MU\" },\n\t{ \"n*\", 0x03bd, \"GREEK SMALL LETTER NU\" },\n\t{ \"c*\", 0x03be, \"GREEK SMALL LETTER XI\" },\n\t{ \"o*\", 0x03bf, \"GREEK SMALL LETTER OMICRON\" },\n\t{ \"p*\", 0x03c0, \"GREEK SMALL LETTER PI\" },\n\t{ \"r*\", 0x03c1, \"GREEK SMALL LETTER RHO\" },\n\t{ \"*s\", 0x03c2, \"GREEK SMALL LETTER FINAL SIGMA\" },\n\t{ \"s*\", 0x03c3, \"GREEK SMALL LETTER SIGMA\" },\n\t{ \"t*\", 0x03c4, \"GREEK SMALL LETTER TAU\" },\n\t{ \"u*\", 0x03c5, \"GREEK SMALL LETTER UPSILON\" },\n\t{ \"f*\", 0x03c6, \"GREEK SMALL LETTER PHI\" },\n\t{ \"x*\", 0x03c7, \"GREEK SMALL LETTER CHI\" },\n\t{ \"q*\", 0x03c8, \"GREEK SMALL LETTER PSI\" },\n\t{ \"w*\", 0x03c9, \"GREEK SMALL LETTER OMEGA\" },\n\t{ \"j*\", 0x03ca, \"GREEK SMALL LETTER IOTA WITH DIAERESIS\" },\n\t{ \"v*\", 0x03cb, \"GREEK SMALL LETTER UPSILON WITH DIAERESIS\" },\n\t{ \"o%\", 0x03cc, \"GREEK SMALL LETTER OMICRON WITH ACUTE\" },\n\t{ \"u%\", 0x03cd, \"GREEK SMALL LETTER UPSILON WITH ACUTE\" },\n\t{ \"w%\", 0x03ce, \"GREEK SMALL LETTER OMEGA WITH ACUTE\" },\n\t{ \"'G\", 0x03d8, \"GREEK NUMERAL SIGN\" },\n\t{ \",G\", 0x03d9, \"GREEK LOWER NUMERAL SIGN\" },\n\t{ \"T3\", 0x03da, \"GREEK CAPITAL LETTER STIGMA\" },\n\t{ \"t3\", 0x03db, \"GREEK SMALL LETTER STIGMA\" },\n\t{ \"M3\", 0x03dc, \"GREEK CAPITAL LETTER DIGAMMA\" },\n\t{ \"m3\", 0x03dd, \"GREEK SMALL LETTER DIGAMMA\" },\n\t{ \"K3\", 0x03de, \"GREEK CAPITAL LETTER KOPPA\" },\n\t{ \"k3\", 0x03df, \"GREEK SMALL LETTER KOPPA\" },\n\t{ \"P3\", 0x03e0, \"GREEK CAPITAL LETTER SAMPI\" },\n\t{ \"p3\", 0x03e1, \"GREEK SMALL LETTER SAMPI\" },\n\t{ \"'%\", 0x03f4, \"ACUTE ACCENT AND DIAERESIS (Tonos and Dialytika)\" },\n\t{ \"j3\", 0x03f5, \"GREEK IOTA BELOW\" },\n\t{ \"IO\", 0x0401, \"CYRILLIC CAPITAL LETTER IO\" },\n\t{ \"D%\", 0x0402, \"CYRILLIC CAPITAL LETTER DJE (Serbocroatian)\" },\n\t{ \"G%\", 0x0403, \"CYRILLIC CAPITAL LETTER GJE (Macedonian)\" },\n\t{ \"IE\", 0x0404, \"CYRILLIC CAPITAL LETTER UKRAINIAN IE\" },\n\t{ \"DS\", 0x0405, \"CYRILLIC CAPITAL LETTER DZE (Macedonian)\" },\n\t{ \"II\", 0x0406, \"CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I\" },\n\t{ \"YI\", 0x0407, \"CYRILLIC CAPITAL LETTER YI (Ukrainian)\" },\n\t{ \"J%\", 0x0408, \"CYRILLIC CAPITAL LETTER JE\" },\n\t{ \"LJ\", 0x0409, \"CYRILLIC CAPITAL LETTER LJE\" },\n\t{ \"NJ\", 0x040a, \"CYRILLIC CAPITAL LETTER NJE\" },\n\t{ \"Ts\", 0x040b, \"CYRILLIC CAPITAL LETTER TSHE (Serbocroatian)\" },\n\t{ \"KJ\", 0x040c, \"CYRILLIC CAPITAL LETTER KJE (Macedonian)\" },\n\t{ \"V%\", 0x040e, \"CYRILLIC CAPITAL LETTER SHORT U (Byelorussian)\" },\n\t{ \"DZ\", 0x040f, \"CYRILLIC CAPITAL LETTER DZHE\" },\n\t{ \"A=\", 0x0410, \"CYRILLIC CAPITAL LETTER A\" },\n\t{ \"B=\", 0x0411, \"CYRILLIC CAPITAL LETTER BE\" },\n\t{ \"V=\", 0x0412, \"CYRILLIC CAPITAL LETTER VE\" },\n\t{ \"G=\", 0x0413, \"CYRILLIC CAPITAL LETTER GHE\" },\n\t{ \"D=\", 0x0414, \"CYRILLIC CAPITAL LETTER DE\" },\n\t{ \"E=\", 0x0415, \"CYRILLIC CAPITAL LETTER IE\" },\n\t{ \"Z%\", 0x0416, \"CYRILLIC CAPITAL LETTER ZHE\" },\n\t{ \"Z=\", 0x0417, \"CYRILLIC CAPITAL LETTER ZE\" },\n\t{ \"I=\", 0x0418, \"CYRILLIC CAPITAL LETTER I\" },\n\t{ \"J=\", 0x0419, \"CYRILLIC CAPITAL LETTER SHORT I\" },\n\t{ \"K=\", 0x041a, \"CYRILLIC CAPITAL LETTER KA\" },\n\t{ \"L=\", 0x041b, \"CYRILLIC CAPITAL LETTER EL\" },\n\t{ \"M=\", 0x041c, \"CYRILLIC CAPITAL LETTER EM\" },\n\t{ \"N=\", 0x041d, \"CYRILLIC CAPITAL LETTER EN\" },\n\t{ \"O=\", 0x041e, \"CYRILLIC CAPITAL LETTER O\" },\n\t{ \"P=\", 0x041f, \"CYRILLIC CAPITAL LETTER PE\" },\n\t{ \"R=\", 0x0420, \"CYRILLIC CAPITAL LETTER ER\" },\n\t{ \"S=\", 0x0421, \"CYRILLIC CAPITAL LETTER ES\" },\n\t{ \"T=\", 0x0422, \"CYRILLIC CAPITAL LETTER TE\" },\n\t{ \"U=\", 0x0423, \"CYRILLIC CAPITAL LETTER U\" },\n\t{ \"F=\", 0x0424, \"CYRILLIC CAPITAL LETTER EF\" },\n\t{ \"H=\", 0x0425, \"CYRILLIC CAPITAL LETTER HA\" },\n\t{ \"C=\", 0x0426, \"CYRILLIC CAPITAL LETTER TSE\" },\n\t{ \"C%\", 0x0427, \"CYRILLIC CAPITAL LETTER CHE\" },\n\t{ \"S%\", 0x0428, \"CYRILLIC CAPITAL LETTER SHA\" },\n\t{ \"Sc\", 0x0429, \"CYRILLIC CAPITAL LETTER SHCHA\" },\n\t{ \"=\\\"\", 0x042a, \"CYRILLIC CAPITAL LETTER HARD SIGN\" },\n\t{ \"Y=\", 0x042b, \"CYRILLIC CAPITAL LETTER YERU\" },\n\t{ \"%\\\"\", 0x042c, \"CYRILLIC CAPITAL LETTER SOFT SIGN\" },\n\t{ \"JE\", 0x042d, \"CYRILLIC CAPITAL LETTER E\" },\n\t{ \"JU\", 0x042e, \"CYRILLIC CAPITAL LETTER YU\" },\n\t{ \"JA\", 0x042f, \"CYRILLIC CAPITAL LETTER YA\" },\n\t{ \"a=\", 0x0430, \"CYRILLIC SMALL LETTER A\" },\n\t{ \"b=\", 0x0431, \"CYRILLIC SMALL LETTER BE\" },\n\t{ \"v=\", 0x0432, \"CYRILLIC SMALL LETTER VE\" },\n\t{ \"g=\", 0x0433, \"CYRILLIC SMALL LETTER GHE\" },\n\t{ \"d=\", 0x0434, \"CYRILLIC SMALL LETTER DE\" },\n\t{ \"e=\", 0x0435, \"CYRILLIC SMALL LETTER IE\" },\n\t{ \"z%\", 0x0436, \"CYRILLIC SMALL LETTER ZHE\" },\n\t{ \"z=\", 0x0437, \"CYRILLIC SMALL LETTER ZE\" },\n\t{ \"i=\", 0x0438, \"CYRILLIC SMALL LETTER I\" },\n\t{ \"j=\", 0x0439, \"CYRILLIC SMALL LETTER SHORT I\" },\n\t{ \"k=\", 0x043a, \"CYRILLIC SMALL LETTER KA\" },\n\t{ \"l=\", 0x043b, \"CYRILLIC SMALL LETTER EL\" },\n\t{ \"m=\", 0x043c, \"CYRILLIC SMALL LETTER EM\" },\n\t{ \"n=\", 0x043d, \"CYRILLIC SMALL LETTER EN\" },\n\t{ \"o=\", 0x043e, \"CYRILLIC SMALL LETTER O\" },\n\t{ \"p=\", 0x043f, \"CYRILLIC SMALL LETTER PE\" },\n\t{ \"r=\", 0x0440, \"CYRILLIC SMALL LETTER ER\" },\n\t{ \"s=\", 0x0441, \"CYRILLIC SMALL LETTER ES\" },\n\t{ \"t=\", 0x0442, \"CYRILLIC SMALL LETTER TE\" },\n\t{ \"u=\", 0x0443, \"CYRILLIC SMALL LETTER U\" },\n\t{ \"f=\", 0x0444, \"CYRILLIC SMALL LETTER EF\" },\n\t{ \"h=\", 0x0445, \"CYRILLIC SMALL LETTER HA\" },\n\t{ \"c=\", 0x0446, \"CYRILLIC SMALL LETTER TSE\" },\n\t{ \"c%\", 0x0447, \"CYRILLIC SMALL LETTER CHE\" },\n\t{ \"s%\", 0x0448, \"CYRILLIC SMALL LETTER SHA\" },\n\t{ \"sc\", 0x0449, \"CYRILLIC SMALL LETTER SHCHA\" },\n\t{ \"='\", 0x044a, \"CYRILLIC SMALL LETTER HARD SIGN\" },\n\t{ \"y=\", 0x044b, \"CYRILLIC SMALL LETTER YERU\" },\n\t{ \"%'\", 0x044c, \"CYRILLIC SMALL LETTER SOFT SIGN\" },\n\t{ \"je\", 0x044d, \"CYRILLIC SMALL LETTER E\" },\n\t{ \"ju\", 0x044e, \"CYRILLIC SMALL LETTER YU\" },\n\t{ \"ja\", 0x044f, \"CYRILLIC SMALL LETTER YA\" },\n\t{ \"io\", 0x0451, \"CYRILLIC SMALL LETTER IO\" },\n\t{ \"d%\", 0x0452, \"CYRILLIC SMALL LETTER DJE (Serbocroatian)\" },\n\t{ \"g%\", 0x0453, \"CYRILLIC SMALL LETTER GJE (Macedonian)\" },\n\t{ \"ie\", 0x0454, \"CYRILLIC SMALL LETTER UKRAINIAN IE\" },\n\t{ \"ds\", 0x0455, \"CYRILLIC SMALL LETTER DZE (Macedonian)\" },\n\t{ \"ii\", 0x0456, \"CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I\" },\n\t{ \"yi\", 0x0457, \"CYRILLIC SMALL LETTER YI (Ukrainian)\" },\n\t{ \"j%\", 0x0458, \"CYRILLIC SMALL LETTER JE\" },\n\t{ \"lj\", 0x0459, \"CYRILLIC SMALL LETTER LJE\" },\n\t{ \"nj\", 0x045a, \"CYRILLIC SMALL LETTER NJE\" },\n\t{ \"ts\", 0x045b, \"CYRILLIC SMALL LETTER TSHE (Serbocroatian)\" },\n\t{ \"kj\", 0x045c, \"CYRILLIC SMALL LETTER KJE (Macedonian)\" },\n\t{ \"v%\", 0x045e, \"CYRILLIC SMALL LETTER SHORT U (Byelorussian)\" },\n\t{ \"dz\", 0x045f, \"CYRILLIC SMALL LETTER DZHE\" },\n\t{ \"Y3\", 0x0462, \"CYRILLIC CAPITAL LETTER YAT\" },\n\t{ \"y3\", 0x0463, \"CYRILLIC SMALL LETTER YAT\" },\n\t{ \"O3\", 0x046a, \"CYRILLIC CAPITAL LETTER BIG YUS\" },\n\t{ \"o3\", 0x046b, \"CYRILLIC SMALL LETTER BIG YUS\" },\n\t{ \"F3\", 0x0472, \"CYRILLIC CAPITAL LETTER FITA\" },\n\t{ \"f3\", 0x0473, \"CYRILLIC SMALL LETTER FITA\" },\n\t{ \"V3\", 0x0474, \"CYRILLIC CAPITAL LETTER IZHITSA\" },\n\t{ \"v3\", 0x0475, \"CYRILLIC SMALL LETTER IZHITSA\" },\n\t{ \"C3\", 0x0480, \"CYRILLIC CAPITAL LETTER KOPPA\" },\n\t{ \"c3\", 0x0481, \"CYRILLIC SMALL LETTER KOPPA\" },\n\t{ \"G3\", 0x0490, \"CYRILLIC CAPITAL LETTER GHE WITH UPTURN\" },\n\t{ \"g3\", 0x0491, \"CYRILLIC SMALL LETTER GHE WITH UPTURN\" },\n\t{ \"A+\", 0x05d0, \"HEBREW LETTER ALEF\" },\n\t{ \"B+\", 0x05d1, \"HEBREW LETTER BET\" },\n\t{ \"G+\", 0x05d2, \"HEBREW LETTER GIMEL\" },\n\t{ \"D+\", 0x05d3, \"HEBREW LETTER DALET\" },\n\t{ \"H+\", 0x05d4, \"HEBREW LETTER HE\" },\n\t{ \"W+\", 0x05d5, \"HEBREW LETTER VAV\" },\n\t{ \"Z+\", 0x05d6, \"HEBREW LETTER ZAYIN\" },\n\t{ \"X+\", 0x05d7, \"HEBREW LETTER HET\" },\n\t{ \"Tj\", 0x05d8, \"HEBREW LETTER TET\" },\n\t{ \"J+\", 0x05d9, \"HEBREW LETTER YOD\" },\n\t{ \"K%\", 0x05da, \"HEBREW LETTER FINAL KAF\" },\n\t{ \"K+\", 0x05db, \"HEBREW LETTER KAF\" },\n\t{ \"L+\", 0x05dc, \"HEBREW LETTER LAMED\" },\n\t{ \"M%\", 0x05dd, \"HEBREW LETTER FINAL MEM\" },\n\t{ \"M+\", 0x05de, \"HEBREW LETTER MEM\" },\n\t{ \"N%\", 0x05df, \"HEBREW LETTER FINAL NUN\" },\n\t{ \"N+\", 0x05e0, \"HEBREW LETTER NUN\" },\n\t{ \"S+\", 0x05e1, \"HEBREW LETTER SAMEKH\" },\n\t{ \"E+\", 0x05e2, \"HEBREW LETTER AYIN\" },\n\t{ \"P%\", 0x05e3, \"HEBREW LETTER FINAL PE\" },\n\t{ \"P+\", 0x05e4, \"HEBREW LETTER PE\" },\n\t{ \"Zj\", 0x05e5, \"HEBREW LETTER FINAL TSADI\" },\n\t{ \"ZJ\", 0x05e6, \"HEBREW LETTER TSADI\" },\n\t{ \"Q+\", 0x05e7, \"HEBREW LETTER QOF\" },\n\t{ \"R+\", 0x05e8, \"HEBREW LETTER RESH\" },\n\t{ \"Sh\", 0x05e9, \"HEBREW LETTER SHIN\" },\n\t{ \"T+\", 0x05ea, \"HEBREW LETTER TAV\" },\n\t{ \",+\", 0x060c, \"ARABIC COMMA\" },\n\t{ \";+\", 0x061b, \"ARABIC SEMICOLON\" },\n\t{ \"?+\", 0x061f, \"ARABIC QUESTION MARK\" },\n\t{ \"H'\", 0x0621, \"ARABIC LETTER HAMZA\" },\n\t{ \"aM\", 0x0622, \"ARABIC LETTER ALEF WITH MADDA ABOVE\" },\n\t{ \"aH\", 0x0623, \"ARABIC LETTER ALEF WITH HAMZA ABOVE\" },\n\t{ \"wH\", 0x0624, \"ARABIC LETTER WAW WITH HAMZA ABOVE\" },\n\t{ \"ah\", 0x0625, \"ARABIC LETTER ALEF WITH HAMZA BELOW\" },\n\t{ \"yH\", 0x0626, \"ARABIC LETTER YEH WITH HAMZA ABOVE\" },\n\t{ \"a+\", 0x0627, \"ARABIC LETTER ALEF\" },\n\t{ \"b+\", 0x0628, \"ARABIC LETTER BEH\" },\n\t{ \"tm\", 0x0629, \"ARABIC LETTER TEH MARBUTA\" },\n\t{ \"t+\", 0x062a, \"ARABIC LETTER TEH\" },\n\t{ \"tk\", 0x062b, \"ARABIC LETTER THEH\" },\n\t{ \"g+\", 0x062c, \"ARABIC LETTER JEEM\" },\n\t{ \"hk\", 0x062d, \"ARABIC LETTER HAH\" },\n\t{ \"x+\", 0x062e, \"ARABIC LETTER KHAH\" },\n\t{ \"d+\", 0x062f, \"ARABIC LETTER DAL\" },\n\t{ \"dk\", 0x0630, \"ARABIC LETTER THAL\" },\n\t{ \"r+\", 0x0631, \"ARABIC LETTER REH\" },\n\t{ \"z+\", 0x0632, \"ARABIC LETTER ZAIN\" },\n\t{ \"s+\", 0x0633, \"ARABIC LETTER SEEN\" },\n\t{ \"sn\", 0x0634, \"ARABIC LETTER SHEEN\" },\n\t{ \"c+\", 0x0635, \"ARABIC LETTER SAD\" },\n\t{ \"dd\", 0x0636, \"ARABIC LETTER DAD\" },\n\t{ \"tj\", 0x0637, \"ARABIC LETTER TAH\" },\n\t{ \"zH\", 0x0638, \"ARABIC LETTER ZAH\" },\n\t{ \"e+\", 0x0639, \"ARABIC LETTER AIN\" },\n\t{ \"i+\", 0x063a, \"ARABIC LETTER GHAIN\" },\n\t{ \"++\", 0x0640, \"ARABIC TATWEEL\" },\n\t{ \"f+\", 0x0641, \"ARABIC LETTER FEH\" },\n\t{ \"q+\", 0x0642, \"ARABIC LETTER QAF\" },\n\t{ \"k+\", 0x0643, \"ARABIC LETTER KAF\" },\n\t{ \"l+\", 0x0644, \"ARABIC LETTER LAM\" },\n\t{ \"m+\", 0x0645, \"ARABIC LETTER MEEM\" },\n\t{ \"n+\", 0x0646, \"ARABIC LETTER NOON\" },\n\t{ \"h+\", 0x0647, \"ARABIC LETTER HEH\" },\n\t{ \"w+\", 0x0648, \"ARABIC LETTER WAW\" },\n\t{ \"j+\", 0x0649, \"ARABIC LETTER ALEF MAKSURA\" },\n\t{ \"y+\", 0x064a, \"ARABIC LETTER YEH\" },\n\t{ \":+\", 0x064b, \"ARABIC FATHATAN\" },\n\t{ \"\\\"+\", 0x064c, \"ARABIC DAMMATAN\" },\n\t{ \"=+\", 0x064d, \"ARABIC KASRATAN\" },\n\t{ \"/+\", 0x064e, \"ARABIC FATHA\" },\n\t{ \"'+\", 0x064f, \"ARABIC DAMMA\" },\n\t{ \"1+\", 0x0650, \"ARABIC KASRA\" },\n\t{ \"3+\", 0x0651, \"ARABIC SHADDA\" },\n\t{ \"0+\", 0x0652, \"ARABIC SUKUN\" },\n\t{ \"aS\", 0x0670, \"SUPERSCRIPT ARABIC LETTER ALEF\" },\n\t{ \"p+\", 0x067e, \"ARABIC LETTER PEH\" },\n\t{ \"v+\", 0x06a4, \"ARABIC LETTER VEH\" },\n\t{ \"gf\", 0x06af, \"ARABIC LETTER GAF\" },\n\t{ \"0a\", 0x06f0, \"EASTERN ARABIC-INDIC DIGIT ZERO\" },\n\t{ \"1a\", 0x06f1, \"EASTERN ARABIC-INDIC DIGIT ONE\" },\n\t{ \"2a\", 0x06f2, \"EASTERN ARABIC-INDIC DIGIT TWO\" },\n\t{ \"3a\", 0x06f3, \"EASTERN ARABIC-INDIC DIGIT THREE\" },\n\t{ \"4a\", 0x06f4, \"EASTERN ARABIC-INDIC DIGIT FOUR\" },\n\t{ \"5a\", 0x06f5, \"EASTERN ARABIC-INDIC DIGIT FIVE\" },\n\t{ \"6a\", 0x06f6, \"EASTERN ARABIC-INDIC DIGIT SIX\" },\n\t{ \"7a\", 0x06f7, \"EASTERN ARABIC-INDIC DIGIT SEVEN\" },\n\t{ \"8a\", 0x06f8, \"EASTERN ARABIC-INDIC DIGIT EIGHT\" },\n\t{ \"9a\", 0x06f9, \"EASTERN ARABIC-INDIC DIGIT NINE\" },\n\t{ \"A-0\", 0x1e00, \"LATIN CAPITAL LETTER A WITH RING BELOW\" },\n\t{ \"a-0\", 0x1e01, \"LATIN SMALL LETTER A WITH RING BELOW\" },\n\t{ \"B.\", 0x1e02, \"LATIN CAPITAL LETTER B WITH DOT ABOVE\" },\n\t{ \"b.\", 0x1e03, \"LATIN SMALL LETTER B WITH DOT ABOVE\" },\n\t{ \"B-.\", 0x1e04, \"LATIN CAPITAL LETTER B WITH DOT BELOW\" },\n\t{ \"b-.\", 0x1e05, \"LATIN SMALL LETTER B WITH DOT BELOW\" },\n\t{ \"B_\", 0x1e06, \"LATIN CAPITAL LETTER B WITH LINE BELOW\" },\n\t{ \"b_\", 0x1e07, \"LATIN SMALL LETTER B WITH LINE BELOW\" },\n\t{ \"C,'\", 0x1e08, \"LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE\" },\n\t{ \"c,'\", 0x1e09, \"LATIN SMALL LETTER C WITH CEDILLA AND ACUTE\" },\n\t{ \"D.\", 0x1e0a, \"LATIN CAPITAL LETTER D WITH DOT ABOVE\" },\n\t{ \"d.\", 0x1e0b, \"LATIN SMALL LETTER D WITH DOT ABOVE\" },\n\t{ \"D-.\", 0x1e0c, \"LATIN CAPITAL LETTER D WITH DOT BELOW\" },\n\t{ \"d-.\", 0x1e0d, \"LATIN SMALL LETTER D WITH DOT BELOW\" },\n\t{ \"D_\", 0x1e0e, \"LATIN CAPITAL LETTER D WITH LINE BELOW\" },\n\t{ \"d_\", 0x1e0f, \"LATIN SMALL LETTER D WITH LINE BELOW\" },\n\t{ \"D,\", 0x1e10, \"LATIN CAPITAL LETTER D WITH CEDILLA\" },\n\t{ \"d,\", 0x1e11, \"LATIN SMALL LETTER D WITH CEDILLA\" },\n\t{ \"D->\", 0x1e12, \"LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW\" },\n\t{ \"d->\", 0x1e13, \"LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW\" },\n\t{ \"E-!\", 0x1e14, \"LATIN CAPITAL LETTER E WITH MACRON AND GRAVE\" },\n\t{ \"e-!\", 0x1e15, \"LATIN SMALL LETTER E WITH MACRON AND GRAVE\" },\n\t{ \"E-'\", 0x1e16, \"LATIN CAPITAL LETTER E WITH MACRON AND ACUTE\" },\n\t{ \"e-'\", 0x1e17, \"LATIN SMALL LETTER E WITH MACRON AND ACUTE\" },\n\t{ \"E->\", 0x1e18, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW\" },\n\t{ \"e->\", 0x1e19, \"LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW\" },\n\t{ \"E-?\", 0x1e1a, \"LATIN CAPITAL LETTER E WITH TILDE BELOW\" },\n\t{ \"e-?\", 0x1e1b, \"LATIN SMALL LETTER E WITH TILDE BELOW\" },\n\t{ \"E,(\", 0x1e1c, \"LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE\" },\n\t{ \"e,(\", 0x1e1d, \"LATIN SMALL LETTER E WITH CEDILLA AND BREVE\" },\n\t{ \"F.\", 0x1e1e, \"LATIN CAPITAL LETTER F WITH DOT ABOVE\" },\n\t{ \"f.\", 0x1e1f, \"LATIN SMALL LETTER F WITH DOT ABOVE\" },\n\t{ \"G-\", 0x1e20, \"LATIN CAPITAL LETTER G WITH MACRON\" },\n\t{ \"g-\", 0x1e21, \"LATIN SMALL LETTER G WITH MACRON\" },\n\t{ \"H.\", 0x1e22, \"LATIN CAPITAL LETTER H WITH DOT ABOVE\" },\n\t{ \"h.\", 0x1e23, \"LATIN SMALL LETTER H WITH DOT ABOVE\" },\n\t{ \"H-.\", 0x1e24, \"LATIN CAPITAL LETTER H WITH DOT BELOW\" },\n\t{ \"h-.\", 0x1e25, \"LATIN SMALL LETTER H WITH DOT BELOW\" },\n\t{ \"H:\", 0x1e26, \"LATIN CAPITAL LETTER H WITH DIAERESIS\" },\n\t{ \"h:\", 0x1e27, \"LATIN SMALL LETTER H WITH DIAERESIS\" },\n\t{ \"H,\", 0x1e28, \"LATIN CAPITAL LETTER H WITH CEDILLA\" },\n\t{ \"h,\", 0x1e29, \"LATIN SMALL LETTER H WITH CEDILLA\" },\n\t{ \"H-(\", 0x1e2a, \"LATIN CAPITAL LETTER H WITH BREVE BELOW\" },\n\t{ \"h-(\", 0x1e2b, \"LATIN SMALL LETTER H WITH BREVE BELOW\" },\n\t{ \"I-?\", 0x1e2c, \"LATIN CAPITAL LETTER I WITH TILDE BELOW\" },\n\t{ \"i-?\", 0x1e2d, \"LATIN SMALL LETTER I WITH TILDE BELOW\" },\n\t{ \"I:'\", 0x1e2e, \"LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE\" },\n\t{ \"i:'\", 0x1e2f, \"LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE\" },\n\t{ \"K'\", 0x1e30, \"LATIN CAPITAL LETTER K WITH ACUTE\" },\n\t{ \"k'\", 0x1e31, \"LATIN SMALL LETTER K WITH ACUTE\" },\n\t{ \"K-.\", 0x1e32, \"LATIN CAPITAL LETTER K WITH DOT BELOW\" },\n\t{ \"k-.\", 0x1e33, \"LATIN SMALL LETTER K WITH DOT BELOW\" },\n\t{ \"K_\", 0x1e34, \"LATIN CAPITAL LETTER K WITH LINE BELOW\" },\n\t{ \"k_\", 0x1e35, \"LATIN SMALL LETTER K WITH LINE BELOW\" },\n\t{ \"L-.\", 0x1e36, \"LATIN CAPITAL LETTER L WITH DOT BELOW\" },\n\t{ \"l-.\", 0x1e37, \"LATIN SMALL LETTER L WITH DOT BELOW\" },\n\t{ \"L--.\", 0x1e38, \"LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON\" },\n\t{ \"l--.\", 0x1e39, \"LATIN SMALL LETTER L WITH DOT BELOW AND MACRON\" },\n\t{ \"L_\", 0x1e3a, \"LATIN CAPITAL LETTER L WITH LINE BELOW\" },\n\t{ \"l_\", 0x1e3b, \"LATIN SMALL LETTER L WITH LINE BELOW\" },\n\t{ \"L->\", 0x1e3c, \"LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW\" },\n\t{ \"l->\", 0x1e3d, \"LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW\" },\n\t{ \"M'\", 0x1e3e, \"LATIN CAPITAL LETTER M WITH ACUTE\" },\n\t{ \"m'\", 0x1e3f, \"LATIN SMALL LETTER M WITH ACUTE\" },\n\t{ \"M.\", 0x1e40, \"LATIN CAPITAL LETTER M WITH DOT ABOVE\" },\n\t{ \"m.\", 0x1e41, \"LATIN SMALL LETTER M WITH DOT ABOVE\" },\n\t{ \"M-.\", 0x1e42, \"LATIN CAPITAL LETTER M WITH DOT BELOW\" },\n\t{ \"m-.\", 0x1e43, \"LATIN SMALL LETTER M WITH DOT BELOW\" },\n\t{ \"N.\", 0x1e44, \"LATIN CAPITAL LETTER N WITH DOT ABOVE\" },\n\t{ \"n.\", 0x1e45, \"LATIN SMALL LETTER N WITH DOT ABOVE\" },\n\t{ \"N-.\", 0x1e46, \"LATIN CAPITAL LETTER N WITH DOT BELOW\" },\n\t{ \"n-.\", 0x1e47, \"LATIN SMALL LETTER N WITH DOT BELOW\" },\n\t{ \"N_\", 0x1e48, \"LATIN CAPITAL LETTER N WITH LINE BELOW\" },\n\t{ \"n_\", 0x1e49, \"LATIN SMALL LETTER N WITH LINE BELOW\" },\n\t{ \"N->\", 0x1e4a, \"LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW\" },\n\t{ \"N->\", 0x1e4b, \"LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW\" },\n\t{ \"O?'\", 0x1e4c, \"LATIN CAPITAL LETTER O WITH TILDE AND ACUTE\" },\n\t{ \"o?'\", 0x1e4d, \"LATIN SMALL LETTER O WITH TILDE AND ACUTE\" },\n\t{ \"O?:\", 0x1e4e, \"LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS\" },\n\t{ \"o?:\", 0x1e4f, \"LATIN SMALL LETTER O WITH TILDE AND DIAERESIS\" },\n\t{ \"O-!\", 0x1e50, \"LATIN CAPITAL LETTER O WITH MACRON AND GRAVE\" },\n\t{ \"o-!\", 0x1e51, \"LATIN SMALL LETTER O WITH MACRON AND GRAVE\" },\n\t{ \"O-'\", 0x1e52, \"LATIN CAPITAL LETTER O WITH MACRON AND ACUTE\" },\n\t{ \"o-'\", 0x1e53, \"LATIN SMALL LETTER O WITH MACRON AND ACUTE\" },\n\t{ \"P'\", 0x1e54, \"LATIN CAPITAL LETTER P WITH ACUTE\" },\n\t{ \"p'\", 0x1e55, \"LATIN SMALL LETTER P WITH ACUTE\" },\n\t{ \"P.\", 0x1e56, \"LATIN CAPITAL LETTER P WITH DOT ABOVE\" },\n\t{ \"p.\", 0x1e57, \"LATIN SMALL LETTER P WITH DOT ABOVE\" },\n\t{ \"R.\", 0x1e58, \"LATIN CAPITAL LETTER R WITH DOT ABOVE\" },\n\t{ \"r.\", 0x1e59, \"LATIN SMALL LETTER R WITH DOT ABOVE\" },\n\t{ \"R-.\", 0x1e5a, \"LATIN CAPITAL LETTER R WITH DOT BELOW\" },\n\t{ \"r-.\", 0x1e5b, \"LATIN SMALL LETTER R WITH DOT BELOW\" },\n\t{ \"R--.\", 0x1e5c, \"LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON\" },\n\t{ \"r--.\", 0x1e5d, \"LATIN SMALL LETTER R WITH DOT BELOW AND MACRON\" },\n\t{ \"R_\", 0x1e5e, \"LATIN CAPITAL LETTER R WITH LINE BELOW\" },\n\t{ \"r_\", 0x1e5f, \"LATIN SMALL LETTER R WITH LINE BELOW\" },\n\t{ \"S.\", 0x1e60, \"LATIN CAPITAL LETTER S WITH DOT ABOVE\" },\n\t{ \"s.\", 0x1e61, \"LATIN SMALL LETTER S WITH DOT ABOVE\" },\n\t{ \"S-.\", 0x1e62, \"LATIN CAPITAL LETTER S WITH DOT BELOW\" },\n\t{ \"s-.\", 0x1e63, \"LATIN SMALL LETTER S WITH DOT BELOW\" },\n\t{ \"S'.\", 0x1e64, \"LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE\" },\n\t{ \"s'.\", 0x1e65, \"LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE\" },\n\t{ \"S<.\", 0x1e66, \"LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE\" },\n\t{ \"s<.\", 0x1e67, \"LATIN SMALL LETTER S WITH CARON AND DOT ABOVE\" },\n\t{ \"S.-.\", 0x1e68, \"LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE\" },\n\t{ \"S.-.\", 0x1e69, \"LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE\" },\n\t{ \"T.\", 0x1e6a, \"LATIN CAPITAL LETTER T WITH DOT ABOVE\" },\n\t{ \"t.\", 0x1e6b, \"LATIN SMALL LETTER T WITH DOT ABOVE\" },\n\t{ \"T-.\", 0x1e6c, \"LATIN CAPITAL LETTER T WITH DOT BELOW\" },\n\t{ \"t-.\", 0x1e6d, \"LATIN SMALL LETTER T WITH DOT BELOW\" },\n\t{ \"T_\", 0x1e6e, \"LATIN CAPITAL LETTER T WITH LINE BELOW\" },\n\t{ \"t_\", 0x1e6f, \"LATIN SMALL LETTER T WITH LINE BELOW\" },\n\t{ \"T->\", 0x1e70, \"LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW\" },\n\t{ \"t->\", 0x1e71, \"LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW\" },\n\t{ \"U--:\", 0x1e72, \"LATIN CAPITAL LETTER U WITH DIAERESIS BELOW\" },\n\t{ \"u--:\", 0x1e73, \"LATIN SMALL LETTER U WITH DIAERESIS BELOW\" },\n\t{ \"U-?\", 0x1e74, \"LATIN CAPITAL LETTER U WITH TILDE BELOW\" },\n\t{ \"u-?\", 0x1e75, \"LATIN SMALL LETTER U WITH TILDE BELOW\" },\n\t{ \"U->\", 0x1e76, \"LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW\" },\n\t{ \"u->\", 0x1e77, \"LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW\" },\n\t{ \"U?'\", 0x1e78, \"LATIN CAPITAL LETTER U WITH TILDE AND ACUTE\" },\n\t{ \"u?'\", 0x1e79, \"LATIN SMALL LETTER U WITH TILDE AND ACUTE\" },\n\t{ \"U-:\", 0x1e7a, \"LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS\" },\n\t{ \"u-:\", 0x1e7b, \"LATIN SMALL LETTER U WITH MACRON AND DIAERESIS\" },\n\t{ \"V?\", 0x1e7c, \"LATIN CAPITAL LETTER V WITH TILDE\" },\n\t{ \"v?\", 0x1e7d, \"LATIN SMALL LETTER V WITH TILDE\" },\n\t{ \"V-.\", 0x1e7e, \"LATIN CAPITAL LETTER V WITH DOT BELOW\" },\n\t{ \"v-.\", 0x1e7f, \"LATIN SMALL LETTER V WITH DOT BELOW\" },\n\t{ \"W!\", 0x1e80, \"LATIN CAPITAL LETTER W WITH GRAVE\" },\n\t{ \"w!\", 0x1e81, \"LATIN SMALL LETTER W WITH GRAVE\" },\n\t{ \"W'\", 0x1e82, \"LATIN CAPITAL LETTER W WITH ACUTE\" },\n\t{ \"w'\", 0x1e83, \"LATIN SMALL LETTER W WITH ACUTE\" },\n\t{ \"W:\", 0x1e84, \"LATIN CAPITAL LETTER W WITH DIAERESIS\" },\n\t{ \"w:\", 0x1e85, \"LATIN SMALL LETTER W WITH DIAERESIS\" },\n\t{ \"W.\", 0x1e86, \"LATIN CAPITAL LETTER W WITH DOT ABOVE\" },\n\t{ \"w.\", 0x1e87, \"LATIN SMALL LETTER W WITH DOT ABOVE\" },\n\t{ \"W-.\", 0x1e88, \"LATIN CAPITAL LETTER W WITH DOT BELOW\" },\n\t{ \"w-.\", 0x1e89, \"LATIN SMALL LETTER W WITH DOT BELOW\" },\n\t{ \"X.\", 0x1e8a, \"LATIN CAPITAL LETTER X WITH DOT ABOVE\" },\n\t{ \"x.\", 0x1e8b, \"LATIN SMALL LETTER X WITH DOT ABOVE\" },\n\t{ \"X:\", 0x1e8c, \"LATIN CAPITAL LETTER X WITH DIAERESIS\" },\n\t{ \"x:\", 0x1e8d, \"LATIN SMALL LETTER X WITH DIAERESIS\" },\n\t{ \"Y.\", 0x1e8e, \"LATIN CAPITAL LETTER Y WITH DOT ABOVE\" },\n\t{ \"y.\", 0x1e8f, \"LATIN SMALL LETTER Y WITH DOT ABOVE\" },\n\t{ \"Z>\", 0x1e90, \"LATIN CAPITAL LETTER Z WITH CIRCUMFLEX\" },\n\t{ \"z>\", 0x1e91, \"LATIN SMALL LETTER Z WITH CIRCUMFLEX\" },\n\t{ \"Z-.\", 0x1e92, \"LATIN CAPITAL LETTER Z WITH DOT BELOW\" },\n\t{ \"z-.\", 0x1e93, \"LATIN SMALL LETTER Z WITH DOT BELOW\" },\n\t{ \"Z_\", 0x1e94, \"LATIN CAPITAL LETTER Z WITH LINE BELOW\" },\n\t{ \"z_\", 0x1e95, \"LATIN SMALL LETTER Z WITH LINE BELOW\" },\n\t{ \"h_\", 0x1e96, \"LATIN SMALL LETTER H WITH LINE BELOW\" },\n\t{ \"t:\", 0x1e97, \"LATIN SMALL LETTER T WITH DIAERESIS\" },\n\t{ \"w0\", 0x1e98, \"LATIN SMALL LETTER W WITH RING ABOVE\" },\n\t{ \"y0\", 0x1e99, \"LATIN SMALL LETTER Y WITH RING ABOVE\" },\n\t{ \"A-.\", 0x1ea0, \"LATIN CAPITAL LETTER A WITH DOT BELOW\" },\n\t{ \"a-.\", 0x1ea1, \"LATIN SMALL LETTER A WITH DOT BELOW\" },\n\t{ \"A2\", 0x1ea2, \"LATIN CAPITAL LETTER A WITH HOOK ABOVE\" },\n\t{ \"a2\", 0x1ea3, \"LATIN SMALL LETTER A WITH HOOK ABOVE\" },\n\t{ \"A>'\", 0x1ea4, \"LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE\" },\n\t{ \"a>'\", 0x1ea5, \"LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE\" },\n\t{ \"A>!\", 0x1ea6, \"LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE\" },\n\t{ \"a>!\", 0x1ea7, \"LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE\" },\n\t{ \"A>2\", 0x1ea8, \"LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE\" },\n\t{ \"a>2\", 0x1ea9, \"LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE\" },\n\t{ \"A>?\", 0x1eaa, \"LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE\" },\n\t{ \"a>?\", 0x1eab, \"LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE\" },\n\t{ \"A>-.\", 0x1eac, \"LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW\" },\n\t{ \"a>-.\", 0x1ead, \"LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW\" },\n\t{ \"A('\", 0x1eae, \"LATIN CAPITAL LETTER A WITH BREVE AND ACUTE\" },\n\t{ \"a('\", 0x1eaf, \"LATIN SMALL LETTER A WITH BREVE AND ACUTE\" },\n\t{ \"A(!\", 0x1eb0, \"LATIN CAPITAL LETTER A WITH BREVE AND GRAVE\" },\n\t{ \"a(!\", 0x1eb1, \"LATIN SMALL LETTER A WITH BREVE AND GRAVE\" },\n\t{ \"A(2\", 0x1eb2, \"LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE\" },\n\t{ \"a(2\", 0x1eb3, \"LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE\" },\n\t{ \"A(?\", 0x1eb4, \"LATIN CAPITAL LETTER A WITH BREVE AND TILDE\" },\n\t{ \"a(?\", 0x1eb5, \"LATIN SMALL LETTER A WITH BREVE AND TILDE\" },\n\t{ \"A(-.\", 0x1eb6, \"LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW\" },\n\t{ \"a(-.\", 0x1eb7, \"LATIN SMALL LETTER A WITH BREVE AND DOT BELOW\" },\n\t{ \"E-.\", 0x1eb8, \"LATIN CAPITAL LETTER E WITH DOT BELOW\" },\n\t{ \"e-.\", 0x1eb9, \"LATIN SMALL LETTER E WITH DOT BELOW\" },\n\t{ \"E2\", 0x1eba, \"LATIN CAPITAL LETTER E WITH HOOK ABOVE\" },\n\t{ \"e2\", 0x1ebb, \"LATIN SMALL LETTER E WITH HOOK ABOVE\" },\n\t{ \"E?\", 0x1ebc, \"LATIN CAPITAL LETTER E WITH TILDE\" },\n\t{ \"e?\", 0x1ebd, \"LATIN SMALL LETTER E WITH TILDE\" },\n\t{ \"E>'\", 0x1ebe, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE\" },\n\t{ \"e>'\", 0x1ebf, \"LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE\" },\n\t{ \"E>!\", 0x1ec0, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE\" },\n\t{ \"e>!\", 0x1ec1, \"LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE\" },\n\t{ \"E>2\", 0x1ec2, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE\" },\n\t{ \"e>2\", 0x1ec3, \"LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE\" },\n\t{ \"E>?\", 0x1ec4, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE\" },\n\t{ \"e>?\", 0x1ec5, \"LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE\" },\n\t{ \"E>-.\", 0x1ec6, \"LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW\" },\n\t{ \"e>-.\", 0x1ec7, \"LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW\" },\n\t{ \"I2\", 0x1ec8, \"LATIN CAPITAL LETTER I WITH HOOK ABOVE\" },\n\t{ \"i2\", 0x1ec9, \"LATIN SMALL LETTER I WITH HOOK ABOVE\" },\n\t{ \"I-.\", 0x1eca, \"LATIN CAPITAL LETTER I WITH DOT BELOW\" },\n\t{ \"i-.\", 0x1ecb, \"LATIN SMALL LETTER I WITH DOT BELOW\" },\n\t{ \"O-.\", 0x1ecc, \"LATIN CAPITAL LETTER O WITH DOT BELOW\" },\n\t{ \"o-.\", 0x1ecd, \"LATIN SMALL LETTER O WITH DOT BELOW\" },\n\t{ \"O2\", 0x1ece, \"LATIN CAPITAL LETTER O WITH HOOK ABOVE\" },\n\t{ \"o2\", 0x1ecf, \"LATIN SMALL LETTER O WITH HOOK ABOVE\" },\n\t{ \"O>'\", 0x1ed0, \"LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE\" },\n\t{ \"o>'\", 0x1ed1, \"LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE\" },\n\t{ \"O>!\", 0x1ed2, \"LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE\" },\n\t{ \"o>!\", 0x1ed3, \"LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE\" },\n\t{ \"O>2\", 0x1ed4, \"LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE\" },\n\t{ \"o>2\", 0x1ed5, \"LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE\" },\n\t{ \"O>?\", 0x1ed6, \"LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE\" },\n\t{ \"o>?\", 0x1ed7, \"LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE\" },\n\t{ \"O>-.\", 0x1ed8, \"LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW\" },\n\t{ \"o>-.\", 0x1ed9, \"LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW\" },\n\t{ \"O9'\", 0x1eda, \"LATIN CAPITAL LETTER O WITH HORN AND ACUTE\" },\n\t{ \"o9'\", 0x1edb, \"LATIN SMALL LETTER O WITH HORN AND ACUTE\" },\n\t{ \"O9!\", 0x1edc, \"LATIN CAPITAL LETTER O WITH HORN AND GRAVE\" },\n\t{ \"o9!\", 0x1edd, \"LATIN SMALL LETTER O WITH HORN AND GRAVE\" },\n\t{ \"O92\", 0x1ede, \"LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE\" },\n\t{ \"o92\", 0x1edf, \"LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE\" },\n\t{ \"O9?\", 0x1ee0, \"LATIN CAPITAL LETTER O WITH HORN AND TILDE\" },\n\t{ \"o9?\", 0x1ee1, \"LATIN SMALL LETTER O WITH HORN AND TILDE\" },\n\t{ \"O9-.\", 0x1ee2, \"LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW\" },\n\t{ \"o9-.\", 0x1ee3, \"LATIN SMALL LETTER O WITH HORN AND DOT BELOW\" },\n\t{ \"U-.\", 0x1ee4, \"LATIN CAPITAL LETTER U WITH DOT BELOW\" },\n\t{ \"u-.\", 0x1ee5, \"LATIN SMALL LETTER U WITH DOT BELOW\" },\n\t{ \"U2\", 0x1ee6, \"LATIN CAPITAL LETTER U WITH HOOK ABOVE\" },\n\t{ \"u2\", 0x1ee7, \"LATIN SMALL LETTER U WITH HOOK ABOVE\" },\n\t{ \"U9'\", 0x1ee8, \"LATIN CAPITAL LETTER U WITH HORN AND ACUTE\" },\n\t{ \"u9'\", 0x1ee9, \"LATIN SMALL LETTER U WITH HORN AND ACUTE\" },\n\t{ \"U9!\", 0x1eea, \"LATIN CAPITAL LETTER U WITH HORN AND GRAVE\" },\n\t{ \"u9!\", 0x1eeb, \"LATIN SMALL LETTER U WITH HORN AND GRAVE\" },\n\t{ \"U92\", 0x1eec, \"LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE\" },\n\t{ \"u92\", 0x1eed, \"LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE\" },\n\t{ \"U9?\", 0x1eee, \"LATIN CAPITAL LETTER U WITH HORN AND TILDE\" },\n\t{ \"u9?\", 0x1eef, \"LATIN SMALL LETTER U WITH HORN AND TILDE\" },\n\t{ \"U9-.\", 0x1ef0, \"LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW\" },\n\t{ \"u9-.\", 0x1ef1, \"LATIN SMALL LETTER U WITH HORN AND DOT BELOW\" },\n\t{ \"Y!\", 0x1ef2, \"LATIN CAPITAL LETTER Y WITH GRAVE\" },\n\t{ \"y!\", 0x1ef3, \"LATIN SMALL LETTER Y WITH GRAVE\" },\n\t{ \"Y-.\", 0x1ef4, \"LATIN CAPITAL LETTER Y WITH DOT BELOW\" },\n\t{ \"y-.\", 0x1ef5, \"LATIN SMALL LETTER Y WITH DOT BELOW\" },\n\t{ \"Y2\", 0x1ef6, \"LATIN CAPITAL LETTER Y WITH HOOK ABOVE\" },\n\t{ \"y2\", 0x1ef7, \"LATIN SMALL LETTER Y WITH HOOK ABOVE\" },\n\t{ \"Y?\", 0x1ef8, \"LATIN CAPITAL LETTER Y WITH TILDE\" },\n\t{ \"y?\", 0x1ef9, \"LATIN SMALL LETTER Y WITH TILDE\" },\n\t{ \";'\", 0x1f00, \"GREEK DASIA AND ACUTE ACCENT\" },\n\t{ \",'\", 0x1f01, \"GREEK PSILI AND ACUTE ACCENT\" },\n\t{ \";!\", 0x1f02, \"GREEK DASIA AND VARIA\" },\n\t{ \",!\", 0x1f03, \"GREEK PSILI AND VARIA\" },\n\t{ \"?;\", 0x1f04, \"GREEK DASIA AND PERISPOMENI\" },\n\t{ \"?,\", 0x1f05, \"GREEK PSILI AND PERISPOMENI\" },\n\t{ \"!:\", 0x1f06, \"GREEK DIAERESIS AND VARIA\" },\n\t{ \"?:\", 0x1f07, \"GREEK DIAERESIS AND PERISPOMENI\" },\n\t{ \"1N\", 0x2002, \"EN SPACE\" },\n\t{ \"1M\", 0x2003, \"EM SPACE\" },\n\t{ \"3M\", 0x2004, \"THREE-PER-EM SPACE\" },\n\t{ \"4M\", 0x2005, \"FOUR-PER-EM SPACE\" },\n\t{ \"6M\", 0x2006, \"SIX-PER-EM SPACE\" },\n\t{ \"1T\", 0x2009, \"THIN SPACE\" },\n\t{ \"1H\", 0x200a, \"HAIR SPACE\" },\n\t{ \"-1\", 0x2010, \"HYPHEN\" },\n\t{ \"-N\", 0x2013, \"EN DASH\" },\n\t{ \"-M\", 0x2014, \"EM DASH\" },\n\t{ \"-3\", 0x2015, \"HORIZONTAL BAR\" },\n\t{ \"!2\", 0x2016, \"DOUBLE VERTICAL LINE\" },\n\t{ \"=2\", 0x2017, \"DOUBLE LOW LINE\" },\n\t{ \"'6\", 0x2018, \"LEFT SINGLE QUOTATION MARK\" },\n\t{ \"'9\", 0x2019, \"RIGHT SINGLE QUOTATION MARK\" },\n\t{ \".9\", 0x201a, \"SINGLE LOW-9 QUOTATION MARK\" },\n\t{ \"9'\", 0x201b, \"SINGLE HIGH-REVERSED-9 QUOTATION MARK\" },\n\t{ \"\\\"6\", 0x201c, \"LEFT DOUBLE QUOTATION MARK\" },\n\t{ \"\\\"9\", 0x201d, \"RIGHT DOUBLE QUOTATION MARK\" },\n\t{ \":9\", 0x201e, \"DOUBLE LOW-9 QUOTATION MARK\" },\n\t{ \"9\\\"\", 0x201f, \"DOUBLE HIGH-REVERSED-9 QUOTATION MARK\" },\n\t{ \"/-\", 0x2020, \"DAGGER\" },\n\t{ \"/=\", 0x2021, \"DOUBLE DAGGER\" },\n\t{ \"..\", 0x2025, \"TWO DOT LEADER\" },\n\t{ \"%0\", 0x2030, \"PER MILLE SIGN\" },\n\t{ \"1'\", 0x2032, \"PRIME\" },\n\t{ \"2'\", 0x2033, \"DOUBLE PRIME\" },\n\t{ \"3'\", 0x2034, \"TRIPLE PRIME\" },\n\t{ \"1\\\"\", 0x2035, \"REVERSED PRIME\" },\n\t{ \"2\\\"\", 0x2036, \"REVERSED DOUBLE PRIME\" },\n\t{ \"3\\\"\", 0x2037, \"REVERSED TRIPLE PRIME\" },\n\t{ \"Ca\", 0x2038, \"CARET\" },\n\t{ \"<1\", 0x2039, \"SINGLE LEFT-POINTING ANGLE QUOTATION MARK\" },\n\t{ \">1\", 0x203a, \"SINGLE RIGHT-POINTING ANGLE QUOTATION MARK\" },\n\t{ \":X\", 0x203b, \"REFERENCE MARK\" },\n\t{ \"!*2\", 0x203c, \"DOUBLE EXCLAMATION MARK\" },\n\t{ \"'-\", 0x203e, \"OVERLINE\" },\n\t{ \"/f\", 0x2044, \"FRACTION SLASH\" },\n\t{ \"0S\", 0x2070, \"SUPERSCRIPT DIGIT ZERO\" },\n\t{ \"4S\", 0x2074, \"SUPERSCRIPT DIGIT FOUR\" },\n\t{ \"5S\", 0x2075, \"SUPERSCRIPT DIGIT FIVE\" },\n\t{ \"6S\", 0x2076, \"SUPERSCRIPT DIGIT SIX\" },\n\t{ \"7S\", 0x2077, \"SUPERSCRIPT DIGIT SEVEN\" },\n\t{ \"8S\", 0x2078, \"SUPERSCRIPT DIGIT EIGHT\" },\n\t{ \"9S\", 0x2079, \"SUPERSCRIPT DIGIT NINE\" },\n\t{ \"+S\", 0x207a, \"SUPERSCRIPT PLUS SIGN\" },\n\t{ \"-S\", 0x207b, \"SUPERSCRIPT MINUS\" },\n\t{ \"=S\", 0x207c, \"SUPERSCRIPT EQUALS SIGN\" },\n\t{ \"(S\", 0x207d, \"SUPERSCRIPT LEFT PARENTHESIS\" },\n\t{ \")S\", 0x207e, \"SUPERSCRIPT RIGHT PARENTHESIS\" },\n\t{ \"nS\", 0x207f, \"SUPERSCRIPT LATIN SMALL LETTER N\" },\n\t{ \"0s\", 0x2080, \"SUBSCRIPT DIGIT ZERO\" },\n\t{ \"1s\", 0x2081, \"SUBSCRIPT DIGIT ONE\" },\n\t{ \"2s\", 0x2082, \"SUBSCRIPT DIGIT TWO\" },\n\t{ \"3s\", 0x2083, \"SUBSCRIPT DIGIT THREE\" },\n\t{ \"4s\", 0x2084, \"SUBSCRIPT DIGIT FOUR\" },\n\t{ \"5s\", 0x2085, \"SUBSCRIPT DIGIT FIVE\" },\n\t{ \"6s\", 0x2086, \"SUBSCRIPT DIGIT SIX\" },\n\t{ \"7s\", 0x2087, \"SUBSCRIPT DIGIT SEVEN\" },\n\t{ \"8s\", 0x2088, \"SUBSCRIPT DIGIT EIGHT\" },\n\t{ \"9s\", 0x2089, \"SUBSCRIPT DIGIT NINE\" },\n\t{ \"+s\", 0x208a, \"SUBSCRIPT PLUS SIGN\" },\n\t{ \"-s\", 0x208b, \"SUBSCRIPT MINUS\" },\n\t{ \"=s\", 0x208c, \"SUBSCRIPT EQUALS SIGN\" },\n\t{ \"(s\", 0x208d, \"SUBSCRIPT LEFT PARENTHESIS\" },\n\t{ \")s\", 0x208e, \"SUBSCRIPT RIGHT PARENTHESIS\" },\n\t{ \"Li\", 0x20a4, \"LIRA SIGN\" },\n\t{ \"Pt\", 0x20a7, \"PESETA SIGN\" },\n\t{ \"W=\", 0x20a9, \"WON SIGN\" },\n\t{ \"oC\", 0x2103, \"DEGREE CENTIGRADE\" },\n\t{ \"co\", 0x2105, \"CARE OF\" },\n\t{ \"oF\", 0x2109, \"DEGREE FAHRENHEIT\" },\n\t{ \"N0\", 0x2116, \"NUMERO SIGN\" },\n\t{ \"PO\", 0x2117, \"SOUND RECORDING COPYRIGHT\" },\n\t{ \"Rx\", 0x211e, \"PRESCRIPTION TAKE\" },\n\t{ \"SM\", 0x2120, \"SERVICE MARK\" },\n\t{ \"TM\", 0x2122, \"TRADE MARK SIGN\" },\n\t{ \"Om\", 0x2126, \"OHM SIGN\" },\n\t{ \"AO\", 0x212b, \"ANGSTROEM SIGN\" },\n\t{ \"13\", 0x2153, \"VULGAR FRACTION ONE THIRD\" },\n\t{ \"23\", 0x2154, \"VULGAR FRACTION TWO THIRDS\" },\n\t{ \"15\", 0x2155, \"VULGAR FRACTION ONE FIFTH\" },\n\t{ \"25\", 0x2156, \"VULGAR FRACTION TWO FIFTHS\" },\n\t{ \"35\", 0x2157, \"VULGAR FRACTION THREE FIFTHS\" },\n\t{ \"45\", 0x2158, \"VULGAR FRACTION FOUR FIFTHS\" },\n\t{ \"16\", 0x2159, \"VULGAR FRACTION ONE SIXTH\" },\n\t{ \"56\", 0x215a, \"VULGAR FRACTION FIVE SIXTHS\" },\n\t{ \"18\", 0x215b, \"VULGAR FRACTION ONE EIGHTH\" },\n\t{ \"38\", 0x215c, \"VULGAR FRACTION THREE EIGHTHS\" },\n\t{ \"58\", 0x215d, \"VULGAR FRACTION FIVE EIGHTHS\" },\n\t{ \"78\", 0x215e, \"VULGAR FRACTION SEVEN EIGHTHS\" },\n\t{ \"1R\", 0x2160, \"ROMAN NUMERAL ONE\" },\n\t{ \"2R\", 0x2161, \"ROMAN NUMERAL TWO\" },\n\t{ \"3R\", 0x2162, \"ROMAN NUMERAL THREE\" },\n\t{ \"4R\", 0x2163, \"ROMAN NUMERAL FOUR\" },\n\t{ \"5R\", 0x2164, \"ROMAN NUMERAL FIVE\" },\n\t{ \"6R\", 0x2165, \"ROMAN NUMERAL SIX\" },\n\t{ \"7R\", 0x2166, \"ROMAN NUMERAL SEVEN\" },\n\t{ \"8R\", 0x2167, \"ROMAN NUMERAL EIGHT\" },\n\t{ \"9R\", 0x2168, \"ROMAN NUMERAL NINE\" },\n\t{ \"aR\", 0x2169, \"ROMAN NUMERAL TEN\" },\n\t{ \"bR\", 0x216a, \"ROMAN NUMERAL ELEVEN\" },\n\t{ \"cR\", 0x216b, \"ROMAN NUMERAL TWELVE\" },\n\t{ \"50R\", 0x216c, \"ROMAN NUMERAL FIFTY\" },\n\t{ \"100R\", 0x216d, \"ROMAN NUMERAL ONE HUNDRED\" },\n\t{ \"500R\", 0x216e, \"ROMAN NUMERAL FIVE HUNDRED\" },\n\t{ \"1000R\", 0x216f, \"ROMAN NUMERAL ONE THOUSAND\" },\n\t{ \"1r\", 0x2170, \"SMALL ROMAN NUMERAL ONE\" },\n\t{ \"2r\", 0x2171, \"SMALL ROMAN NUMERAL TWO\" },\n\t{ \"3r\", 0x2172, \"SMALL ROMAN NUMERAL THREE\" },\n\t{ \"4r\", 0x2173, \"SMALL ROMAN NUMERAL FOUR\" },\n\t{ \"5r\", 0x2174, \"SMALL ROMAN NUMERAL FIVE\" },\n\t{ \"6r\", 0x2175, \"SMALL ROMAN NUMERAL SIX\" },\n\t{ \"7r\", 0x2176, \"SMALL ROMAN NUMERAL SEVEN\" },\n\t{ \"8r\", 0x2177, \"SMALL ROMAN NUMERAL EIGHT\" },\n\t{ \"9r\", 0x2178, \"SMALL ROMAN NUMERAL NINE\" },\n\t{ \"ar\", 0x2179, \"SMALL ROMAN NUMERAL TEN\" },\n\t{ \"br\", 0x217a, \"SMALL ROMAN NUMERAL ELEVEN\" },\n\t{ \"cr\", 0x217b, \"SMALL ROMAN NUMERAL TWELVE\" },\n\t{ \"50r\", 0x217c, \"SMALL ROMAN NUMERAL FIFTY\" },\n\t{ \"100r\", 0x217d, \"SMALL ROMAN NUMERAL ONE HUNDRED\" },\n\t{ \"500r\", 0x217e, \"SMALL ROMAN NUMERAL FIVE HUNDRED\" },\n\t{ \"1000r\", 0x217f, \"SMALL ROMAN NUMERAL ONE THOUSAND\" },\n\t{ \"1000RCD\", 0x2180, \"ROMAN NUMERAL ONE THOUSAND C D\" },\n\t{ \"5000R\", 0x2181, \"ROMAN NUMERAL FIVE THOUSAND\" },\n\t{ \"10000R\", 0x2182, \"ROMAN NUMERAL TEN THOUSAND\" },\n\t{ \"<-\", 0x2190, \"LEFTWARDS ARROW\" },\n\t{ \"-!\", 0x2191, \"UPWARDS ARROW\" },\n\t{ \"->\", 0x2192, \"RIGHTWARDS ARROW\" },\n\t{ \"-v\", 0x2193, \"DOWNWARDS ARROW\" },\n\t{ \"<>\", 0x2194, \"LEFT RIGHT ARROW\" },\n\t{ \"UD\", 0x2195, \"UP DOWN ARROW\" },\n\t{ \"<!!\", 0x2196, \"NORTH WEST ARROW\" },\n\t{ \"//>\", 0x2197, \"NORTH EAST ARROW\" },\n\t{ \"!!>\", 0x2198, \"SOUTH EAST ARROW\" },\n\t{ \"<//\", 0x2199, \"SOUTH WEST ARROW\" },\n\t{ \"<=\", 0x21d0, \"LEFTWARDS DOUBLE ARROW\" },\n\t{ \"=>\", 0x21d2, \"RIGHTWARDS DOUBLE ARROW\" },\n\t{ \"==\", 0x21d4, \"LEFT RIGHT DOUBLE ARROW\" },\n\t{ \"FA\", 0x2200, \"FOR ALL\" },\n\t{ \"dP\", 0x2202, \"PARTIAL DIFFERENTIAL\" },\n\t{ \"TE\", 0x2203, \"THERE EXISTS\" },\n\t{ \"/0\", 0x2205, \"EMPTY SET\" },\n\t{ \"DE\", 0x2206, \"INCREMENT\" },\n\t{ \"NB\", 0x2207, \"NABLA\" },\n\t{ \"(-\", 0x2208, \"ELEMENT OF\" },\n\t{ \"-)\", 0x220b, \"CONTAINS AS MEMBER\" },\n\t{ \"*P\", 0x220f, \"N-ARY PRODUCT\" },\n\t{ \"+Z\", 0x2211, \"N-ARY SUMMATION\" },\n\t{ \"-2\", 0x2212, \"MINUS SIGN\" },\n\t{ \"-+\", 0x2213, \"MINUS-OR-PLUS SIGN\" },\n\t{ \"*-\", 0x2217, \"ASTERISK OPERATOR\" },\n\t{ \"Ob\", 0x2218, \"RING OPERATOR\" },\n\t{ \"Sb\", 0x2219, \"BULLET OPERATOR\" },\n\t{ \"RT\", 0x221a, \"SQUARE ROOT\" },\n\t{ \"0(\", 0x221d, \"PROPORTIONAL TO\" },\n\t{ \"00\", 0x221e, \"INFINITY\" },\n\t{ \"-L\", 0x221f, \"RIGHT ANGLE\" },\n\t{ \"-V\", 0x2220, \"ANGLE\" },\n\t{ \"PP\", 0x2225, \"PARALLEL TO\" },\n\t{ \"AN\", 0x2227, \"LOGICAL AND\" },\n\t{ \"OR\", 0x2228, \"LOGICAL OR\" },\n\t{ \"(U\", 0x2229, \"INTERSECTION\" },\n\t{ \")U\", 0x222a, \"UNION\" },\n\t{ \"In\", 0x222b, \"INTEGRAL\" },\n\t{ \"DI\", 0x222c, \"DOUBLE INTEGRAL\" },\n\t{ \"Io\", 0x222e, \"CONTOUR INTEGRAL\" },\n\t{ \".:\", 0x2234, \"THEREFORE\" },\n\t{ \":.\", 0x2235, \"BECAUSE\" },\n\t{ \":R\", 0x2236, \"RATIO\" },\n\t{ \"::\", 0x2237, \"PROPORTION\" },\n\t{ \"?1\", 0x223c, \"TILDE OPERATOR\" },\n\t{ \"CG\", 0x223e, \"INVERTED LAZY S\" },\n\t{ \"?-\", 0x2243, \"ASYMPTOTICALLY EQUAL TO\" },\n\t{ \"?=\", 0x2245, \"APPROXIMATELY EQUAL TO\" },\n\t{ \"?2\", 0x2248, \"ALMOST EQUAL TO\" },\n\t{ \"=?\", 0x224c, \"ALL EQUAL TO\" },\n\t{ \"HI\", 0x2253, \"IMAGE OF OR APPROXIMATELY EQUAL TO\" },\n\t{ \"!=\", 0x2260, \"NOT EQUAL TO\" },\n\t{ \"=3\", 0x2261, \"IDENTICAL TO\" },\n\t{ \"=<\", 0x2264, \"LESS-THAN OR EQUAL TO\" },\n\t{ \">=\", 0x2265, \"GREATER-THAN OR EQUAL TO\" },\n\t{ \"<*\", 0x226a, \"MUCH LESS-THAN\" },\n\t{ \"*>\", 0x226b, \"MUCH GREATER-THAN\" },\n\t{ \"!<\", 0x226e, \"NOT LESS-THAN\" },\n\t{ \"!>\", 0x226f, \"NOT GREATER-THAN\" },\n\t{ \"(C\", 0x2282, \"SUBSET OF\" },\n\t{ \")C\", 0x2283, \"SUPERSET OF\" },\n\t{ \"(_\", 0x2286, \"SUBSET OF OR EQUAL TO\" },\n\t{ \")_\", 0x2287, \"SUPERSET OF OR EQUAL TO\" },\n\t{ \"0.\", 0x2299, \"CIRCLED DOT OPERATOR\" },\n\t{ \"02\", 0x229a, \"CIRCLED RING OPERATOR\" },\n\t{ \"-T\", 0x22a5, \"UP TACK\" },\n\t{ \".P\", 0x22c5, \"DOT OPERATOR\" },\n\t{ \":3\", 0x22ee, \"VERTICAL ELLIPSIS\" },\n\t{ \".3\", 0x22ef, \"MIDLINE HORIZONTAL ELLIPSIS\" },\n\t{ \"Eh\", 0x2302, \"HOUSE\" },\n\t{ \"<7\", 0x2308, \"LEFT CEILING\" },\n\t{ \">7\", 0x2309, \"RIGHT CEILING\" },\n\t{ \"7<\", 0x230a, \"LEFT FLOOR\" },\n\t{ \"7>\", 0x230b, \"RIGHT FLOOR\" },\n\t{ \"NI\", 0x2310, \"REVERSED NOT SIGN\" },\n\t{ \"(A\", 0x2312, \"ARC\" },\n\t{ \"TR\", 0x2315, \"TELEPHONE RECORDER\" },\n\t{ \"Iu\", 0x2320, \"TOP HALF INTEGRAL\" },\n\t{ \"Il\", 0x2321, \"BOTTOM HALF INTEGRAL\" },\n\t{ \"</\", 0x2329, \"LEFT-POINTING ANGLE BRACKET\" },\n\t{ \"/>\", 0x232a, \"RIGHT-POINTING ANGLE BRACKET\" },\n\t{ \"Vs\", 0x2423, \"OPEN BOX\" },\n\t{ \"1h\", 0x2440, \"OCR HOOK\" },\n\t{ \"3h\", 0x2441, \"OCR CHAIR\" },\n\t{ \"2h\", 0x2442, \"OCR FORK\" },\n\t{ \"4h\", 0x2443, \"OCR INVERTED FORK\" },\n\t{ \"1j\", 0x2446, \"OCR BRANCH BANK IDENTIFICATION\" },\n\t{ \"2j\", 0x2447, \"OCR AMOUNT OF CHECK\" },\n\t{ \"3j\", 0x2448, \"OCR DASH\" },\n\t{ \"4j\", 0x2449, \"OCR CUSTOMER ACCOUNT NUMBER\" },\n\t{ \"1-o\", 0x2460, \"CIRCLED DIGIT ONE\" },\n\t{ \"2-o\", 0x2461, \"CIRCLED DIGIT TWO\" },\n\t{ \"3-o\", 0x2462, \"CIRCLED DIGIT THREE\" },\n\t{ \"4-o\", 0x2463, \"CIRCLED DIGIT FOUR\" },\n\t{ \"5-o\", 0x2464, \"CIRCLED DIGIT FIVE\" },\n\t{ \"6-o\", 0x2465, \"CIRCLED DIGIT SIX\" },\n\t{ \"7-o\", 0x2466, \"CIRCLED DIGIT SEVEN\" },\n\t{ \"8-o\", 0x2467, \"CIRCLED DIGIT EIGHT\" },\n\t{ \"9-o\", 0x2468, \"CIRCLED DIGIT NINE\" },\n\t{ \"10-o\", 0x2469, \"CIRCLED NUMBER TEN\" },\n\t{ \"11-o\", 0x246a, \"CIRCLED NUMBER ELEVEN\" },\n\t{ \"12-o\", 0x246b, \"CIRCLED NUMBER TWELVE\" },\n\t{ \"13-o\", 0x246c, \"CIRCLED NUMBER THIRTEEN\" },\n\t{ \"14-o\", 0x246d, \"CIRCLED NUMBER FOURTEEN\" },\n\t{ \"15-o\", 0x246e, \"CIRCLED NUMBER FIFTEEN\" },\n\t{ \"16-o\", 0x246f, \"CIRCLED NUMBER SIXTEEN\" },\n\t{ \"17-o\", 0x2470, \"CIRCLED NUMBER SEVENTEEN\" },\n\t{ \"18-o\", 0x2471, \"CIRCLED NUMBER EIGHTEEN\" },\n\t{ \"19-o\", 0x2472, \"CIRCLED NUMBER NINETEEN\" },\n\t{ \"20-o\", 0x2473, \"CIRCLED NUMBER TWENTY\" },\n\t{ \"(1)\", 0x2474, \"PARENTHESIZED DIGIT ONE\" },\n\t{ \"(2)\", 0x2475, \"PARENTHESIZED DIGIT TWO\" },\n\t{ \"(3)\", 0x2476, \"PARENTHESIZED DIGIT THREE\" },\n\t{ \"(4)\", 0x2477, \"PARENTHESIZED DIGIT FOUR\" },\n\t{ \"(5)\", 0x2478, \"PARENTHESIZED DIGIT FIVE\" },\n\t{ \"(6)\", 0x2479, \"PARENTHESIZED DIGIT SIX\" },\n\t{ \"(7)\", 0x247a, \"PARENTHESIZED DIGIT SEVEN\" },\n\t{ \"(8)\", 0x247b, \"PARENTHESIZED DIGIT EIGHT\" },\n\t{ \"(9)\", 0x247c, \"PARENTHESIZED DIGIT NINE\" },\n\t{ \"(10)\", 0x247d, \"PARENTHESIZED NUMBER TEN\" },\n\t{ \"(11)\", 0x247e, \"PARENTHESIZED NUMBER ELEVEN\" },\n\t{ \"(12)\", 0x247f, \"PARENTHESIZED NUMBER TWELVE\" },\n\t{ \"(13)\", 0x2480, \"PARENTHESIZED NUMBER THIRTEEN\" },\n\t{ \"(14)\", 0x2481, \"PARENTHESIZED NUMBER FOURTEEN\" },\n\t{ \"(15)\", 0x2482, \"PARENTHESIZED NUMBER FIFTEEN\" },\n\t{ \"(16)\", 0x2483, \"PARENTHESIZED NUMBER SIXTEEN\" },\n\t{ \"(17)\", 0x2484, \"PARENTHESIZED NUMBER SEVENTEEN\" },\n\t{ \"(18)\", 0x2485, \"PARENTHESIZED NUMBER EIGHTEEN\" },\n\t{ \"(19)\", 0x2486, \"PARENTHESIZED NUMBER NINETEEN\" },\n\t{ \"(20)\", 0x2487, \"PARENTHESIZED NUMBER TWENTY\" },\n\t{ \"1.\", 0x2488, \"DIGIT ONE FULL STOP\" },\n\t{ \"2.\", 0x2489, \"DIGIT TWO FULL STOP\" },\n\t{ \"3.\", 0x248a, \"DIGIT THREE FULL STOP\" },\n\t{ \"4.\", 0x248b, \"DIGIT FOUR FULL STOP\" },\n\t{ \"5.\", 0x248c, \"DIGIT FIVE FULL STOP\" },\n\t{ \"6.\", 0x248d, \"DIGIT SIX FULL STOP\" },\n\t{ \"7.\", 0x248e, \"DIGIT SEVEN FULL STOP\" },\n\t{ \"8.\", 0x248f, \"DIGIT EIGHT FULL STOP\" },\n\t{ \"9.\", 0x2490, \"DIGIT NINE FULL STOP\" },\n\t{ \"10.\", 0x2491, \"NUMBER TEN FULL STOP\" },\n\t{ \"11.\", 0x2492, \"NUMBER ELEVEN FULL STOP\" },\n\t{ \"12.\", 0x2493, \"NUMBER TWELVE FULL STOP\" },\n\t{ \"13.\", 0x2494, \"NUMBER THIRTEEN FULL STOP\" },\n\t{ \"14.\", 0x2495, \"NUMBER FOURTEEN FULL STOP\" },\n\t{ \"15.\", 0x2496, \"NUMBER FIFTEEN FULL STOP\" },\n\t{ \"16.\", 0x2497, \"NUMBER SIXTEEN FULL STOP\" },\n\t{ \"17.\", 0x2498, \"NUMBER SEVENTEEN FULL STOP\" },\n\t{ \"18.\", 0x2499, \"NUMBER EIGHTEEN FULL STOP\" },\n\t{ \"19.\", 0x249a, \"NUMBER NINETEEN FULL STOP\" },\n\t{ \"20.\", 0x249b, \"NUMBER TWENTY FULL STOP\" },\n\t{ \"(a)\", 0x249c, \"PARENTHESIZED LATIN SMALL LETTER A\" },\n\t{ \"(b)\", 0x249d, \"PARENTHESIZED LATIN SMALL LETTER B\" },\n\t{ \"(c)\", 0x249e, \"PARENTHESIZED LATIN SMALL LETTER C\" },\n\t{ \"(d)\", 0x249f, \"PARENTHESIZED LATIN SMALL LETTER D\" },\n\t{ \"(e)\", 0x24a0, \"PARENTHESIZED LATIN SMALL LETTER E\" },\n\t{ \"(f)\", 0x24a1, \"PARENTHESIZED LATIN SMALL LETTER F\" },\n\t{ \"(g)\", 0x24a2, \"PARENTHESIZED LATIN SMALL LETTER G\" },\n\t{ \"(h)\", 0x24a3, \"PARENTHESIZED LATIN SMALL LETTER H\" },\n\t{ \"(i)\", 0x24a4, \"PARENTHESIZED LATIN SMALL LETTER I\" },\n\t{ \"(j)\", 0x24a5, \"PARENTHESIZED LATIN SMALL LETTER J\" },\n\t{ \"(k)\", 0x24a6, \"PARENTHESIZED LATIN SMALL LETTER K\" },\n\t{ \"(l)\", 0x24a7, \"PARENTHESIZED LATIN SMALL LETTER L\" },\n\t{ \"(m)\", 0x24a8, \"PARENTHESIZED LATIN SMALL LETTER M\" },\n\t{ \"(n)\", 0x24a9, \"PARENTHESIZED LATIN SMALL LETTER N\" },\n\t{ \"(o)\", 0x24aa, \"PARENTHESIZED LATIN SMALL LETTER O\" },\n\t{ \"(p)\", 0x24ab, \"PARENTHESIZED LATIN SMALL LETTER P\" },\n\t{ \"(q)\", 0x24ac, \"PARENTHESIZED LATIN SMALL LETTER Q\" },\n\t{ \"(r)\", 0x24ad, \"PARENTHESIZED LATIN SMALL LETTER R\" },\n\t{ \"(s)\", 0x24ae, \"PARENTHESIZED LATIN SMALL LETTER S\" },\n\t{ \"(t)\", 0x24af, \"PARENTHESIZED LATIN SMALL LETTER T\" },\n\t{ \"(u)\", 0x24b0, \"PARENTHESIZED LATIN SMALL LETTER U\" },\n\t{ \"(v)\", 0x24b1, \"PARENTHESIZED LATIN SMALL LETTER V\" },\n\t{ \"(w)\", 0x24b2, \"PARENTHESIZED LATIN SMALL LETTER W\" },\n\t{ \"(x)\", 0x24b3, \"PARENTHESIZED LATIN SMALL LETTER X\" },\n\t{ \"(y)\", 0x24b4, \"PARENTHESIZED LATIN SMALL LETTER Y\" },\n\t{ \"(z)\", 0x24b5, \"PARENTHESIZED LATIN SMALL LETTER Z\" },\n\t{ \"A-o\", 0x24b6, \"CIRCLED LATIN CAPITAL LETTER A\" },\n\t{ \"B-o\", 0x24b7, \"CIRCLED LATIN CAPITAL LETTER B\" },\n\t{ \"C-o\", 0x24b8, \"CIRCLED LATIN CAPITAL LETTER C\" },\n\t{ \"D-o\", 0x24b9, \"CIRCLED LATIN CAPITAL LETTER D\" },\n\t{ \"E-o\", 0x24ba, \"CIRCLED LATIN CAPITAL LETTER E\" },\n\t{ \"F-o\", 0x24bb, \"CIRCLED LATIN CAPITAL LETTER F\" },\n\t{ \"G-o\", 0x24bc, \"CIRCLED LATIN CAPITAL LETTER G\" },\n\t{ \"H-o\", 0x24bd, \"CIRCLED LATIN CAPITAL LETTER H\" },\n\t{ \"I-o\", 0x24be, \"CIRCLED LATIN CAPITAL LETTER I\" },\n\t{ \"J-o\", 0x24bf, \"CIRCLED LATIN CAPITAL LETTER J\" },\n\t{ \"K-o\", 0x24c0, \"CIRCLED LATIN CAPITAL LETTER K\" },\n\t{ \"L-o\", 0x24c1, \"CIRCLED LATIN CAPITAL LETTER L\" },\n\t{ \"M-o\", 0x24c2, \"CIRCLED LATIN CAPITAL LETTER M\" },\n\t{ \"N-o\", 0x24c3, \"CIRCLED LATIN CAPITAL LETTER N\" },\n\t{ \"O-o\", 0x24c4, \"CIRCLED LATIN CAPITAL LETTER O\" },\n\t{ \"P-o\", 0x24c5, \"CIRCLED LATIN CAPITAL LETTER P\" },\n\t{ \"Q-o\", 0x24c6, \"CIRCLED LATIN CAPITAL LETTER Q\" },\n\t{ \"R-o\", 0x24c7, \"CIRCLED LATIN CAPITAL LETTER R\" },\n\t{ \"S-o\", 0x24c8, \"CIRCLED LATIN CAPITAL LETTER S\" },\n\t{ \"T-o\", 0x24c9, \"CIRCLED LATIN CAPITAL LETTER T\" },\n\t{ \"U-o\", 0x24ca, \"CIRCLED LATIN CAPITAL LETTER U\" },\n\t{ \"V-o\", 0x24cb, \"CIRCLED LATIN CAPITAL LETTER V\" },\n\t{ \"W-o\", 0x24cc, \"CIRCLED LATIN CAPITAL LETTER W\" },\n\t{ \"X-o\", 0x24cd, \"CIRCLED LATIN CAPITAL LETTER X\" },\n\t{ \"Y-o\", 0x24ce, \"CIRCLED LATIN CAPITAL LETTER Y\" },\n\t{ \"Z-o\", 0x24cf, \"CIRCLED LATIN CAPITAL LETTER Z\" },\n\t{ \"a-o\", 0x24d0, \"CIRCLED LATIN SMALL LETTER A\" },\n\t{ \"b-o\", 0x24d1, \"CIRCLED LATIN SMALL LETTER B\" },\n\t{ \"c-o\", 0x24d2, \"CIRCLED LATIN SMALL LETTER C\" },\n\t{ \"d-o\", 0x24d3, \"CIRCLED LATIN SMALL LETTER D\" },\n\t{ \"e-o\", 0x24d4, \"CIRCLED LATIN SMALL LETTER E\" },\n\t{ \"f-o\", 0x24d5, \"CIRCLED LATIN SMALL LETTER F\" },\n\t{ \"g-o\", 0x24d6, \"CIRCLED LATIN SMALL LETTER G\" },\n\t{ \"h-o\", 0x24d7, \"CIRCLED LATIN SMALL LETTER H\" },\n\t{ \"i-o\", 0x24d8, \"CIRCLED LATIN SMALL LETTER I\" },\n\t{ \"j-o\", 0x24d9, \"CIRCLED LATIN SMALL LETTER J\" },\n\t{ \"k-o\", 0x24da, \"CIRCLED LATIN SMALL LETTER K\" },\n\t{ \"l-o\", 0x24db, \"CIRCLED LATIN SMALL LETTER L\" },\n\t{ \"m-o\", 0x24dc, \"CIRCLED LATIN SMALL LETTER M\" },\n\t{ \"n-o\", 0x24dd, \"CIRCLED LATIN SMALL LETTER N\" },\n\t{ \"o-o\", 0x24de, \"CIRCLED LATIN SMALL LETTER O\" },\n\t{ \"p-o\", 0x24df, \"CIRCLED LATIN SMALL LETTER P\" },\n\t{ \"q-o\", 0x24e0, \"CIRCLED LATIN SMALL LETTER Q\" },\n\t{ \"r-o\", 0x24e1, \"CIRCLED LATIN SMALL LETTER R\" },\n\t{ \"s-o\", 0x24e2, \"CIRCLED LATIN SMALL LETTER S\" },\n\t{ \"t-o\", 0x24e3, \"CIRCLED LATIN SMALL LETTER T\" },\n\t{ \"u-o\", 0x24e4, \"CIRCLED LATIN SMALL LETTER U\" },\n\t{ \"v-o\", 0x24e5, \"CIRCLED LATIN SMALL LETTER V\" },\n\t{ \"w-o\", 0x24e6, \"CIRCLED LATIN SMALL LETTER W\" },\n\t{ \"x-o\", 0x24e7, \"CIRCLED LATIN SMALL LETTER X\" },\n\t{ \"y-o\", 0x24e8, \"CIRCLED LATIN SMALL LETTER Y\" },\n\t{ \"z-o\", 0x24e9, \"CIRCLED LATIN SMALL LETTER Z\" },\n\t{ \"0-o\", 0x24ea, \"CIRCLED DIGIT ZERO\" },\n\t{ \"hh\", 0x2500, \"BOX DRAWINGS LIGHT HORIZONTAL\" },\n\t{ \"HH\", 0x2501, \"BOX DRAWINGS HEAVY HORIZONTAL\" },\n\t{ \"vv\", 0x2502, \"BOX DRAWINGS LIGHT VERTICAL\" },\n\t{ \"VV\", 0x2503, \"BOX DRAWINGS HEAVY VERTICAL\" },\n\t{ \"3-\", 0x2504, \"BOX DRAWINGS LIGHT TRIPLE DASH HORIZONTAL\" },\n\t{ \"3_\", 0x2505, \"BOX DRAWINGS HEAVY TRIPLE DASH HORIZONTAL\" },\n\t{ \"3!\", 0x2506, \"BOX DRAWINGS LIGHT TRIPLE DASH VERTICAL\" },\n\t{ \"3/\", 0x2507, \"BOX DRAWINGS HEAVY TRIPLE DASH VERTICAL\" },\n\t{ \"4-\", 0x2508, \"BOX DRAWINGS LIGHT QUADRUPLE DASH HORIZONTAL\" },\n\t{ \"4_\", 0x2509, \"BOX DRAWINGS HEAVY QUADRUPLE DASH HORIZONTAL\" },\n\t{ \"4!\", 0x250a, \"BOX DRAWINGS LIGHT QUADRUPLE DASH VERTICAL\" },\n\t{ \"4/\", 0x250b, \"BOX DRAWINGS HEAVY QUADRUPLE DASH VERTICAL\" },\n\t{ \"dr\", 0x250c, \"BOX DRAWINGS LIGHT DOWN AND RIGHT\" },\n\t{ \"dR\", 0x250d, \"BOX DRAWINGS DOWN LIGHT AND RIGHT HEAVY\" },\n\t{ \"Dr\", 0x250e, \"BOX DRAWINGS DOWN HEAVY AND RIGHT LIGHT\" },\n\t{ \"DR\", 0x250f, \"BOX DRAWINGS HEAVY DOWN AND RIGHT\" },\n\t{ \"dl\", 0x2510, \"BOX DRAWINGS LIGHT DOWN AND LEFT\" },\n\t{ \"dL\", 0x2511, \"BOX DRAWINGS DOWN LIGHT AND LEFT HEAVY\" },\n\t{ \"Dl\", 0x2512, \"BOX DRAWINGS DOWN HEAVY AND LEFT LIGHT\" },\n\t{ \"LD\", 0x2513, \"BOX DRAWINGS HEAVY DOWN AND LEFT\" },\n\t{ \"ur\", 0x2514, \"BOX DRAWINGS LIGHT UP AND RIGHT\" },\n\t{ \"uR\", 0x2515, \"BOX DRAWINGS UP LIGHT AND RIGHT HEAVY\" },\n\t{ \"Ur\", 0x2516, \"BOX DRAWINGS UP HEAVY AND RIGHT LIGHT\" },\n\t{ \"UR\", 0x2517, \"BOX DRAWINGS HEAVY UP AND RIGHT\" },\n\t{ \"ul\", 0x2518, \"BOX DRAWINGS LIGHT UP AND LEFT\" },\n\t{ \"uL\", 0x2519, \"BOX DRAWINGS UP LIGHT AND LEFT HEAVY\" },\n\t{ \"Ul\", 0x251a, \"BOX DRAWINGS UP HEAVY AND LEFT LIGHT\" },\n\t{ \"UL\", 0x251b, \"BOX DRAWINGS HEAVY UP AND LEFT\" },\n\t{ \"vr\", 0x251c, \"BOX DRAWINGS LIGHT VERTICAL AND RIGHT\" },\n\t{ \"vR\", 0x251d, \"BOX DRAWINGS VERTICAL LIGHT AND RIGHT HEAVY\" },\n\t{ \"Udr\", 0x251e, \"BOX DRAWINGS UP HEAVY AND RIGHT DOWN LIGHT\" },\n\t{ \"uDr\", 0x251f, \"BOX DRAWINGS DOWN HEAVY AND RIGHT UP LIGHT\" },\n\t{ \"Vr\", 0x2520, \"BOX DRAWINGS VERTICAL HEAVY AND RIGHT LIGHT\" },\n\t{ \"UdR\", 0x2521, \"BOX DRAWINGS DOWN LIGHT AND RIGHT UP HEAVY\" },\n\t{ \"uDR\", 0x2522, \"BOX DRAWINGS UP LIGHT AND RIGHT DOWN HEAVY\" },\n\t{ \"VR\", 0x2523, \"BOX DRAWINGS HEAVY VERTICAL AND RIGHT\" },\n\t{ \"vl\", 0x2524, \"BOX DRAWINGS LIGHT VERTICAL AND LEFT\" },\n\t{ \"vL\", 0x2525, \"BOX DRAWINGS VERTICAL LIGHT AND LEFT HEAVY\" },\n\t{ \"Udl\", 0x2526, \"BOX DRAWINGS UP HEAVY AND LEFT DOWN LIGHT\" },\n\t{ \"uDl\", 0x2527, \"BOX DRAWINGS DOWN HEAVY AND LEFT UP LIGHT\" },\n\t{ \"Vl\", 0x2528, \"BOX DRAWINGS VERTICAL HEAVY AND LEFT LIGHT\" },\n\t{ \"UdL\", 0x2529, \"BOX DRAWINGS DOWN LIGHT AND LEFT UP HEAVY\" },\n\t{ \"uDL\", 0x252a, \"BOX DRAWINGS UP LIGHT AND LEFT DOWN HEAVY\" },\n\t{ \"VL\", 0x252b, \"BOX DRAWINGS HEAVY VERTICAL AND LEFT\" },\n\t{ \"dh\", 0x252c, \"BOX DRAWINGS LIGHT DOWN AND HORIZONTAL\" },\n\t{ \"dLr\", 0x252d, \"BOX DRAWINGS LEFT HEAVY AND RIGHT DOWN LIGHT\" },\n\t{ \"dlR\", 0x252e, \"BOX DRAWINGS RIGHT HEAVY AND LEFT DOWN LIGHT\" },\n\t{ \"dH\", 0x252f, \"BOX DRAWINGS DOWN LIGHT AND HORIZONTAL HEAVY\" },\n\t{ \"Dh\", 0x2530, \"BOX DRAWINGS DOWN HEAVY AND HORIZONTAL LIGHT\" },\n\t{ \"DLr\", 0x2531, \"BOX DRAWINGS RIGHT LIGHT AND LEFT DOWN HEAVY\" },\n\t{ \"DlR\", 0x2532, \"BOX DRAWINGS LEFT LIGHT AND RIGHT DOWN HEAVY\" },\n\t{ \"DH\", 0x2533, \"BOX DRAWINGS HEAVY DOWN AND HORIZONTAL\" },\n\t{ \"uh\", 0x2534, \"BOX DRAWINGS LIGHT UP AND HORIZONTAL\" },\n\t{ \"uLr\", 0x2535, \"BOX DRAWINGS LEFT HEAVY AND RIGHT UP LIGHT\" },\n\t{ \"ulR\", 0x2536, \"BOX DRAWINGS RIGHT HEAVY AND LEFT UP LIGHT\" },\n\t{ \"uH\", 0x2537, \"BOX DRAWINGS UP LIGHT AND HORIZONTAL HEAVY\" },\n\t{ \"Uh\", 0x2538, \"BOX DRAWINGS UP HEAVY AND HORIZONTAL LIGHT\" },\n\t{ \"ULr\", 0x2539, \"BOX DRAWINGS RIGHT LIGHT AND LEFT UP HEAVY\" },\n\t{ \"UlR\", 0x253a, \"BOX DRAWINGS LEFT LIGHT AND RIGHT UP HEAVY\" },\n\t{ \"UH\", 0x253b, \"BOX DRAWINGS HEAVY UP AND HORIZONTAL\" },\n\t{ \"vh\", 0x253c, \"BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL\" },\n\t{ \"vLr\", 0x253d, \"BOX DRAWINGS LEFT HEAVY AND RIGHT VERTICAL LIGHT\" },\n\t{ \"vlR\", 0x253e, \"BOX DRAWINGS RIGHT HEAVY AND LEFT VERTICAL LIGHT\" },\n\t{ \"vH\", 0x253f, \"BOX DRAWINGS VERTICAL LIGHT AND HORIZONTAL HEAVY\" },\n\t{ \"Udh\", 0x2540, \"BOX DRAWINGS UP HEAVY AND DOWN HORIZONTAL LIGHT\" },\n\t{ \"uDh\", 0x2541, \"BOX DRAWINGS DOWN HEAVY AND UP HORIZONTAL LIGHT\" },\n\t{ \"Vh\", 0x2542, \"BOX DRAWINGS VERTICAL HEAVY AND HORIZONTAL LIGHT\" },\n\t{ \"UdLr\", 0x2543, \"BOX DRAWINGS LEFT UP HEAVY AND RIGHT DOWN LIGHT\" },\n\t{ \"UdlR\", 0x2544, \"BOX DRAWINGS RIGHT UP HEAVY AND LEFT DOWN LIGHT\" },\n\t{ \"uDLr\", 0x2545, \"BOX DRAWINGS LEFT DOWN HEAVY AND RIGHT UP LIGHT\" },\n\t{ \"uDlR\", 0x2546, \"BOX DRAWINGS RIGHT DOWN HEAVY AND LEFT UP LIGHT\" },\n\t{ \"UdH\", 0x2547, \"BOX DRAWINGS DOWN LIGHT AND UP HORIZONTAL HEAVY\" },\n\t{ \"uDH\", 0x2548, \"BOX DRAWINGS UP LIGHT AND DOWN HORIZONTAL HEAVY\" },\n\t{ \"VLr\", 0x2549, \"BOX DRAWINGS RIGHT LIGHT AND LEFT VERTICAL HEAVY\" },\n\t{ \"VlR\", 0x254a, \"BOX DRAWINGS LEFT LIGHT AND RIGHT VERTICAL HEAVY\" },\n\t{ \"VH\", 0x254b, \"BOX DRAWINGS HEAVY VERTICAL AND HORIZONTAL\" },\n\t{ \"FD\", 0x2571, \"BOX DRAWINGS LIGHT DIAGONAL UPPER RIGHT TO LOWER LEFT\" },\n\t{ \"BD\", 0x2572, \"BOX DRAWINGS LIGHT DIAGONAL UPPER LEFT TO LOWER RIGHT\" },\n\t{ \"TB\", 0x2580, \"UPPER HALF BLOCK\" },\n\t{ \"LB\", 0x2584, \"LOWER HALF BLOCK\" },\n\t{ \"FB\", 0x2588, \"FULL BLOCK\" },\n\t{ \"lB\", 0x258c, \"LEFT HALF BLOCK\" },\n\t{ \"RB\", 0x2590, \"RIGHT HALF BLOCK\" },\n\t{ \".S\", 0x2591, \"LIGHT SHADE\" },\n\t{ \":S\", 0x2592, \"MEDIUM SHADE\" },\n\t{ \"?S\", 0x2593, \"DARK SHADE\" },\n\t{ \"fS\", 0x25a0, \"BLACK SQUARE\" },\n\t{ \"OS\", 0x25a1, \"WHITE SQUARE\" },\n\t{ \"RO\", 0x25a2, \"WHITE SQUARE WITH ROUNDED CORNERS\" },\n\t{ \"Rr\", 0x25a3, \"WHITE SQUARE CONTAINING BLACK SMALL SQUARE\" },\n\t{ \"RF\", 0x25a4, \"SQUARE WITH HORIZONTAL FILL\" },\n\t{ \"RY\", 0x25a5, \"SQUARE WITH VERTICAL FILL\" },\n\t{ \"RH\", 0x25a6, \"SQUARE WITH ORTHOGONAL CROSSHATCH FILL\" },\n\t{ \"RZ\", 0x25a7, \"SQUARE WITH UPPER LEFT TO LOWER RIGHT FILL\" },\n\t{ \"RK\", 0x25a8, \"SQUARE WITH UPPER RIGHT TO LOWER LEFT FILL\" },\n\t{ \"RX\", 0x25a9, \"SQUARE WITH DIAGONAL CROSSHATCH FILL\" },\n\t{ \"sB\", 0x25aa, \"BLACK SMALL SQUARE\" },\n\t{ \"SR\", 0x25ac, \"BLACK RECTANGLE\" },\n\t{ \"Or\", 0x25ad, \"WHITE RECTANGLE\" },\n\t{ \"UT\", 0x25b2, \"BLACK UP-POINTING TRIANGLE\" },\n\t{ \"uT\", 0x25b3, \"WHITE UP-POINTING TRIANGLE\" },\n\t{ \"PR\", 0x25b6, \"BLACK RIGHT-POINTING TRIANGLE\" },\n\t{ \"Tr\", 0x25b7, \"WHITE RIGHT-POINTING TRIANGLE\" },\n\t{ \"Dt\", 0x25bc, \"BLACK DOWN-POINTING TRIANGLE\" },\n\t{ \"dT\", 0x25bd, \"WHITE DOWN-POINTING TRIANGLE\" },\n\t{ \"PL\", 0x25c0, \"BLACK LEFT-POINTING TRIANGLE\" },\n\t{ \"Tl\", 0x25c1, \"WHITE LEFT-POINTING TRIANGLE\" },\n\t{ \"Db\", 0x25c6, \"BLACK DIAMOND\" },\n\t{ \"Dw\", 0x25c7, \"WHITE DIAMOND\" },\n\t{ \"LZ\", 0x25ca, \"LOZENGE\" },\n\t{ \"0m\", 0x25cb, \"WHITE CIRCLE\" },\n\t{ \"0o\", 0x25ce, \"BULLSEYE\" },\n\t{ \"0M\", 0x25cf, \"BLACK CIRCLE\" },\n\t{ \"0L\", 0x25d0, \"CIRCLE WITH LEFT HALF BLACK\" },\n\t{ \"0R\", 0x25d1, \"CIRCLE WITH RIGHT HALF BLACK\" },\n\t{ \"Sn\", 0x25d8, \"INVERSE BULLET\" },\n\t{ \"Ic\", 0x25d9, \"INVERSE WHITE CIRCLE\" },\n\t{ \"Fd\", 0x25e2, \"BLACK LOWER RIGHT TRIANGLE\" },\n\t{ \"Bd\", 0x25e3, \"BLACK LOWER LEFT TRIANGLE\" },\n\t{ \"*2\", 0x2605, \"BLACK STAR\" },\n\t{ \"*1\", 0x2606, \"WHITE STAR\" },\n\t{ \"TEL\", 0x260e, \"BLACK TELEPHONE\" },\n\t{ \"tel\", 0x260f, \"WHITE TELEPHONE\" },\n\t{ \"<H\", 0x261c, \"WHITE LEFT POINTING INDEX\" },\n\t{ \">H\", 0x261e, \"WHITE RIGHT POINTING INDEX\" },\n\t{ \"0u\", 0x263a, \"WHITE SMILING FACE\" },\n\t{ \"0U\", 0x263b, \"BLACK SMILING FACE\" },\n\t{ \"SU\", 0x263c, \"WHITE SUN WITH RAYS\" },\n\t{ \"Fm\", 0x2640, \"FEMALE SIGN\" },\n\t{ \"Ml\", 0x2642, \"MALE SIGN\" },\n\t{ \"cS\", 0x2660, \"BLACK SPADE SUIT\" },\n\t{ \"cH\", 0x2661, \"WHITE HEART SUIT\" },\n\t{ \"cD\", 0x2662, \"WHITE DIAMOND SUIT\" },\n\t{ \"cC\", 0x2663, \"BLACK CLUB SUIT\" },\n\t{ \"cS-\", 0x2664, \"WHITE SPADE SUIT\" },\n\t{ \"cH-\", 0x2665, \"BLACK HEART SUIT\" },\n\t{ \"cD-\", 0x2666, \"BLACK DIAMOND SUIT\" },\n\t{ \"cC-\", 0x2667, \"WHITE CLUB SUIT\" },\n\t{ \"Md\", 0x2669, \"QUARTER NOTE\" },\n\t{ \"M8\", 0x266a, \"EIGHTH NOTE\" },\n\t{ \"M2\", 0x266b, \"BARRED EIGHTH NOTES\" },\n\t{ \"M16\", 0x266c, \"BARRED SIXTEENTH NOTES\" },\n\t{ \"Mb\", 0x266d, \"MUSIC FLAT SIGN\" },\n\t{ \"Mx\", 0x266e, \"MUSIC NATURAL SIGN\" },\n\t{ \"MX\", 0x266f, \"MUSIC SHARP SIGN\" },\n\t{ \"OK\", 0x2713, \"CHECK MARK\" },\n\t{ \"XX\", 0x2717, \"BALLOT X\" },\n\t{ \"-X\", 0x2720, \"MALTESE CROSS\" },\n\t{ \"IS\", 0x3000, \"IDEOGRAPHIC SPACE\" },\n\t{ \",_\", 0x3001, \"IDEOGRAPHIC COMMA\" },\n\t{ \"._\", 0x3002, \"IDEOGRAPHIC PERIOD\" },\n\t{ \"+\\\"\", 0x3003, \"DITTO MARK\" },\n\t{ \"+_\", 0x3004, \"IDEOGRAPHIC DITTO MARK\" },\n\t{ \"*_\", 0x3005, \"IDEOGRAPHIC ITERATION MARK\" },\n\t{ \";_\", 0x3006, \"IDEOGRAPHIC CLOSING MARK\" },\n\t{ \"0_\", 0x3007, \"IDEOGRAPHIC NUMBER ZERO\" },\n\t{ \"<+\", 0x300a, \"LEFT DOUBLE ANGLE BRACKET\" },\n\t{ \">+\", 0x300b, \"RIGHT DOUBLE ANGLE BRACKET\" },\n\t{ \"<'\", 0x300c, \"LEFT CORNER BRACKET\" },\n\t{ \">'\", 0x300d, \"RIGHT CORNER BRACKET\" },\n\t{ \"<\\\"\", 0x300e, \"LEFT WHITE CORNER BRACKET\" },\n\t{ \">\\\"\", 0x300f, \"RIGHT WHITE CORNER BRACKET\" },\n\t{ \"(\\\"\", 0x3010, \"LEFT BLACK LENTICULAR BRACKET\" },\n\t{ \")\\\"\", 0x3011, \"RIGHT BLACK LENTICULAR BRACKET\" },\n\t{ \"=T\", 0x3012, \"POSTAL MARK\" },\n\t{ \"=_\", 0x3013, \"GETA MARK\" },\n\t{ \"('\", 0x3014, \"LEFT TORTOISE SHELL BRACKET\" },\n\t{ \")'\", 0x3015, \"RIGHT TORTOISE SHELL BRACKET\" },\n\t{ \"(I\", 0x3016, \"LEFT WHITE LENTICULAR BRACKET\" },\n\t{ \")I\", 0x3017, \"RIGHT WHITE LENTICULAR BRACKET\" },\n\t{ \"-?\", 0x301c, \"WAVE DASH\" },\n\t{ \"=T:)\", 0x3020, \"POSTAL MARK FACE\" },\n\t{ \"A5\", 0x3041, \"HIRAGANA LETTER SMALL A\" },\n\t{ \"a5\", 0x3042, \"HIRAGANA LETTER A\" },\n\t{ \"I5\", 0x3043, \"HIRAGANA LETTER SMALL I\" },\n\t{ \"i5\", 0x3044, \"HIRAGANA LETTER I\" },\n\t{ \"U5\", 0x3045, \"HIRAGANA LETTER SMALL U\" },\n\t{ \"u5\", 0x3046, \"HIRAGANA LETTER U\" },\n\t{ \"E5\", 0x3047, \"HIRAGANA LETTER SMALL E\" },\n\t{ \"e5\", 0x3048, \"HIRAGANA LETTER E\" },\n\t{ \"O5\", 0x3049, \"HIRAGANA LETTER SMALL O\" },\n\t{ \"o5\", 0x304a, \"HIRAGANA LETTER O\" },\n\t{ \"ka\", 0x304b, \"HIRAGANA LETTER KA\" },\n\t{ \"ga\", 0x304c, \"HIRAGANA LETTER GA\" },\n\t{ \"ki\", 0x304d, \"HIRAGANA LETTER KI\" },\n\t{ \"gi\", 0x304e, \"HIRAGANA LETTER GI\" },\n\t{ \"ku\", 0x304f, \"HIRAGANA LETTER KU\" },\n\t{ \"gu\", 0x3050, \"HIRAGANA LETTER GU\" },\n\t{ \"ke\", 0x3051, \"HIRAGANA LETTER KE\" },\n\t{ \"ge\", 0x3052, \"HIRAGANA LETTER GE\" },\n\t{ \"ko\", 0x3053, \"HIRAGANA LETTER KO\" },\n\t{ \"go\", 0x3054, \"HIRAGANA LETTER GO\" },\n\t{ \"sa\", 0x3055, \"HIRAGANA LETTER SA\" },\n\t{ \"za\", 0x3056, \"HIRAGANA LETTER ZA\" },\n\t{ \"si\", 0x3057, \"HIRAGANA LETTER SI\" },\n\t{ \"zi\", 0x3058, \"HIRAGANA LETTER ZI\" },\n\t{ \"su\", 0x3059, \"HIRAGANA LETTER SU\" },\n\t{ \"zu\", 0x305a, \"HIRAGANA LETTER ZU\" },\n\t{ \"se\", 0x305b, \"HIRAGANA LETTER SE\" },\n\t{ \"ze\", 0x305c, \"HIRAGANA LETTER ZE\" },\n\t{ \"so\", 0x305d, \"HIRAGANA LETTER SO\" },\n\t{ \"zo\", 0x305e, \"HIRAGANA LETTER ZO\" },\n\t{ \"ta\", 0x305f, \"HIRAGANA LETTER TA\" },\n\t{ \"da\", 0x3060, \"HIRAGANA LETTER DA\" },\n\t{ \"ti\", 0x3061, \"HIRAGANA LETTER TI\" },\n\t{ \"di\", 0x3062, \"HIRAGANA LETTER DI\" },\n\t{ \"tU\", 0x3063, \"HIRAGANA LETTER SMALL TU\" },\n\t{ \"tu\", 0x3064, \"HIRAGANA LETTER TU\" },\n\t{ \"du\", 0x3065, \"HIRAGANA LETTER DU\" },\n\t{ \"te\", 0x3066, \"HIRAGANA LETTER TE\" },\n\t{ \"de\", 0x3067, \"HIRAGANA LETTER DE\" },\n\t{ \"to\", 0x3068, \"HIRAGANA LETTER TO\" },\n\t{ \"do\", 0x3069, \"HIRAGANA LETTER DO\" },\n\t{ \"na\", 0x306a, \"HIRAGANA LETTER NA\" },\n\t{ \"ni\", 0x306b, \"HIRAGANA LETTER NI\" },\n\t{ \"nu\", 0x306c, \"HIRAGANA LETTER NU\" },\n\t{ \"ne\", 0x306d, \"HIRAGANA LETTER NE\" },\n\t{ \"no\", 0x306e, \"HIRAGANA LETTER NO\" },\n\t{ \"ha\", 0x306f, \"HIRAGANA LETTER HA\" },\n\t{ \"ba\", 0x3070, \"HIRAGANA LETTER BA\" },\n\t{ \"pa\", 0x3071, \"HIRAGANA LETTER PA\" },\n\t{ \"hi\", 0x3072, \"HIRAGANA LETTER HI\" },\n\t{ \"bi\", 0x3073, \"HIRAGANA LETTER BI\" },\n\t{ \"pi\", 0x3074, \"HIRAGANA LETTER PI\" },\n\t{ \"hu\", 0x3075, \"HIRAGANA LETTER HU\" },\n\t{ \"bu\", 0x3076, \"HIRAGANA LETTER BU\" },\n\t{ \"pu\", 0x3077, \"HIRAGANA LETTER PU\" },\n\t{ \"he\", 0x3078, \"HIRAGANA LETTER HE\" },\n\t{ \"be\", 0x3079, \"HIRAGANA LETTER BE\" },\n\t{ \"pe\", 0x307a, \"HIRAGANA LETTER PE\" },\n\t{ \"ho\", 0x307b, \"HIRAGANA LETTER HO\" },\n\t{ \"bo\", 0x307c, \"HIRAGANA LETTER BO\" },\n\t{ \"po\", 0x307d, \"HIRAGANA LETTER PO\" },\n\t{ \"ma\", 0x307e, \"HIRAGANA LETTER MA\" },\n\t{ \"mi\", 0x307f, \"HIRAGANA LETTER MI\" },\n\t{ \"mu\", 0x3080, \"HIRAGANA LETTER MU\" },\n\t{ \"me\", 0x3081, \"HIRAGANA LETTER ME\" },\n\t{ \"mo\", 0x3082, \"HIRAGANA LETTER MO\" },\n\t{ \"yA\", 0x3083, \"HIRAGANA LETTER SMALL YA\" },\n\t{ \"ya\", 0x3084, \"HIRAGANA LETTER YA\" },\n\t{ \"yU\", 0x3085, \"HIRAGANA LETTER SMALL YU\" },\n\t{ \"yu\", 0x3086, \"HIRAGANA LETTER YU\" },\n\t{ \"yO\", 0x3087, \"HIRAGANA LETTER SMALL YO\" },\n\t{ \"yo\", 0x3088, \"HIRAGANA LETTER YO\" },\n\t{ \"ra\", 0x3089, \"HIRAGANA LETTER RA\" },\n\t{ \"ri\", 0x308a, \"HIRAGANA LETTER RI\" },\n\t{ \"ru\", 0x308b, \"HIRAGANA LETTER RU\" },\n\t{ \"re\", 0x308c, \"HIRAGANA LETTER RE\" },\n\t{ \"ro\", 0x308d, \"HIRAGANA LETTER RO\" },\n\t{ \"wA\", 0x308e, \"HIRAGANA LETTER SMALL WA\" },\n\t{ \"wa\", 0x308f, \"HIRAGANA LETTER WA\" },\n\t{ \"wi\", 0x3090, \"HIRAGANA LETTER WI\" },\n\t{ \"we\", 0x3091, \"HIRAGANA LETTER WE\" },\n\t{ \"wo\", 0x3092, \"HIRAGANA LETTER WO\" },\n\t{ \"n5\", 0x3093, \"HIRAGANA LETTER N\" },\n\t{ \"vu\", 0x3094, \"HIRAGANA LETTER VU\" },\n\t{ \"\\\"5\", 0x309b, \"KATAKANA-HIRAGANA VOICED SOUND MARK\" },\n\t{ \"05\", 0x309c, \"KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK\" },\n\t{ \"*5\", 0x309d, \"HIRAGANA ITERATION MARK\" },\n\t{ \"+5\", 0x309e, \"HIRAGANA VOICED ITERATION MARK\" },\n\t{ \"a6\", 0x30a1, \"KATAKANA LETTER SMALL A\" },\n\t{ \"A6\", 0x30a2, \"KATAKANA LETTER A\" },\n\t{ \"i6\", 0x30a3, \"KATAKANA LETTER SMALL I\" },\n\t{ \"I6\", 0x30a4, \"KATAKANA LETTER I\" },\n\t{ \"u6\", 0x30a5, \"KATAKANA LETTER SMALL U\" },\n\t{ \"U6\", 0x30a6, \"KATAKANA LETTER U\" },\n\t{ \"e6\", 0x30a7, \"KATAKANA LETTER SMALL E\" },\n\t{ \"E6\", 0x30a8, \"KATAKANA LETTER E\" },\n\t{ \"o6\", 0x30a9, \"KATAKANA LETTER SMALL O\" },\n\t{ \"O6\", 0x30aa, \"KATAKANA LETTER O\" },\n\t{ \"Ka\", 0x30ab, \"KATAKANA LETTER KA\" },\n\t{ \"Ga\", 0x30ac, \"KATAKANA LETTER GA\" },\n\t{ \"Ki\", 0x30ad, \"KATAKANA LETTER KI\" },\n\t{ \"Gi\", 0x30ae, \"KATAKANA LETTER GI\" },\n\t{ \"Ku\", 0x30af, \"KATAKANA LETTER KU\" },\n\t{ \"Gu\", 0x30b0, \"KATAKANA LETTER GU\" },\n\t{ \"Ke\", 0x30b1, \"KATAKANA LETTER KE\" },\n\t{ \"Ge\", 0x30b2, \"KATAKANA LETTER GE\" },\n\t{ \"Ko\", 0x30b3, \"KATAKANA LETTER KO\" },\n\t{ \"Go\", 0x30b4, \"KATAKANA LETTER GO\" },\n\t{ \"Sa\", 0x30b5, \"KATAKANA LETTER SA\" },\n\t{ \"Za\", 0x30b6, \"KATAKANA LETTER ZA\" },\n\t{ \"Si\", 0x30b7, \"KATAKANA LETTER SI\" },\n\t{ \"Zi\", 0x30b8, \"KATAKANA LETTER ZI\" },\n\t{ \"Su\", 0x30b9, \"KATAKANA LETTER SU\" },\n\t{ \"Zu\", 0x30ba, \"KATAKANA LETTER ZU\" },\n\t{ \"Se\", 0x30bb, \"KATAKANA LETTER SE\" },\n\t{ \"Ze\", 0x30bc, \"KATAKANA LETTER ZE\" },\n\t{ \"So\", 0x30bd, \"KATAKANA LETTER SO\" },\n\t{ \"Zo\", 0x30be, \"KATAKANA LETTER ZO\" },\n\t{ \"Ta\", 0x30bf, \"KATAKANA LETTER TA\" },\n\t{ \"Da\", 0x30c0, \"KATAKANA LETTER DA\" },\n\t{ \"Ti\", 0x30c1, \"KATAKANA LETTER TI\" },\n\t{ \"Di\", 0x30c2, \"KATAKANA LETTER DI\" },\n\t{ \"TU\", 0x30c3, \"KATAKANA LETTER SMALL TU\" },\n\t{ \"Tu\", 0x30c4, \"KATAKANA LETTER TU\" },\n\t{ \"Du\", 0x30c5, \"KATAKANA LETTER DU\" },\n\t{ \"Te\", 0x30c6, \"KATAKANA LETTER TE\" },\n\t{ \"De\", 0x30c7, \"KATAKANA LETTER DE\" },\n\t{ \"To\", 0x30c8, \"KATAKANA LETTER TO\" },\n\t{ \"Do\", 0x30c9, \"KATAKANA LETTER DO\" },\n\t{ \"Na\", 0x30ca, \"KATAKANA LETTER NA\" },\n\t{ \"Ni\", 0x30cb, \"KATAKANA LETTER NI\" },\n\t{ \"Nu\", 0x30cc, \"KATAKANA LETTER NU\" },\n\t{ \"Ne\", 0x30cd, \"KATAKANA LETTER NE\" },\n\t{ \"No\", 0x30ce, \"KATAKANA LETTER NO\" },\n\t{ \"Ha\", 0x30cf, \"KATAKANA LETTER HA\" },\n\t{ \"Ba\", 0x30d0, \"KATAKANA LETTER BA\" },\n\t{ \"Pa\", 0x30d1, \"KATAKANA LETTER PA\" },\n\t{ \"Hi\", 0x30d2, \"KATAKANA LETTER HI\" },\n\t{ \"Bi\", 0x30d3, \"KATAKANA LETTER BI\" },\n\t{ \"Pi\", 0x30d4, \"KATAKANA LETTER PI\" },\n\t{ \"Hu\", 0x30d5, \"KATAKANA LETTER HU\" },\n\t{ \"Bu\", 0x30d6, \"KATAKANA LETTER BU\" },\n\t{ \"Pu\", 0x30d7, \"KATAKANA LETTER PU\" },\n\t{ \"He\", 0x30d8, \"KATAKANA LETTER HE\" },\n\t{ \"Be\", 0x30d9, \"KATAKANA LETTER BE\" },\n\t{ \"Pe\", 0x30da, \"KATAKANA LETTER PE\" },\n\t{ \"Ho\", 0x30db, \"KATAKANA LETTER HO\" },\n\t{ \"Bo\", 0x30dc, \"KATAKANA LETTER BO\" },\n\t{ \"Po\", 0x30dd, \"KATAKANA LETTER PO\" },\n\t{ \"Ma\", 0x30de, \"KATAKANA LETTER MA\" },\n\t{ \"Mi\", 0x30df, \"KATAKANA LETTER MI\" },\n\t{ \"Mu\", 0x30e0, \"KATAKANA LETTER MU\" },\n\t{ \"Me\", 0x30e1, \"KATAKANA LETTER ME\" },\n\t{ \"Mo\", 0x30e2, \"KATAKANA LETTER MO\" },\n\t{ \"YA\", 0x30e3, \"KATAKANA LETTER SMALL YA\" },\n\t{ \"Ya\", 0x30e4, \"KATAKANA LETTER YA\" },\n\t{ \"YU\", 0x30e5, \"KATAKANA LETTER SMALL YU\" },\n\t{ \"Yu\", 0x30e6, \"KATAKANA LETTER YU\" },\n\t{ \"YO\", 0x30e7, \"KATAKANA LETTER SMALL YO\" },\n\t{ \"Yo\", 0x30e8, \"KATAKANA LETTER YO\" },\n\t{ \"Ra\", 0x30e9, \"KATAKANA LETTER RA\" },\n\t{ \"Ri\", 0x30ea, \"KATAKANA LETTER RI\" },\n\t{ \"Ru\", 0x30eb, \"KATAKANA LETTER RU\" },\n\t{ \"Re\", 0x30ec, \"KATAKANA LETTER RE\" },\n\t{ \"Ro\", 0x30ed, \"KATAKANA LETTER RO\" },\n\t{ \"WA\", 0x30ee, \"KATAKANA LETTER SMALL WA\" },\n\t{ \"Wa\", 0x30ef, \"KATAKANA LETTER WA\" },\n\t{ \"Wi\", 0x30f0, \"KATAKANA LETTER WI\" },\n\t{ \"We\", 0x30f1, \"KATAKANA LETTER WE\" },\n\t{ \"Wo\", 0x30f2, \"KATAKANA LETTER WO\" },\n\t{ \"N6\", 0x30f3, \"KATAKANA LETTER N\" },\n\t{ \"Vu\", 0x30f4, \"KATAKANA LETTER VU\" },\n\t{ \"KA\", 0x30f5, \"KATAKANA LETTER SMALL KA\" },\n\t{ \"KE\", 0x30f6, \"KATAKANA LETTER SMALL KE\" },\n\t{ \"Va\", 0x30f7, \"KATAKANA LETTER VA\" },\n\t{ \"Vi\", 0x30f8, \"KATAKANA LETTER VI\" },\n\t{ \"Ve\", 0x30f9, \"KATAKANA LETTER VE\" },\n\t{ \"Vo\", 0x30fa, \"KATAKANA LETTER VO\" },\n\t{ \".6\", 0x30fb, \"KATAKANA MIDDLE DOT\" },\n\t{ \"-6\", 0x30fc, \"KATAKANA-HIRAGANA PROLONGED SOUND MARK\" },\n\t{ \"*6\", 0x30fd, \"KATAKANA ITERATION MARK\" },\n\t{ \"+6\", 0x30fe, \"KATAKANA VOICED ITERATION MARK\" },\n\t{ \"b4\", 0x3105, \"BOPOMOFO LETTER B\" },\n\t{ \"p4\", 0x3106, \"BOPOMOFO LETTER P\" },\n\t{ \"m4\", 0x3107, \"BOPOMOFO LETTER M\" },\n\t{ \"f4\", 0x3108, \"BOPOMOFO LETTER F\" },\n\t{ \"d4\", 0x3109, \"BOPOMOFO LETTER D\" },\n\t{ \"t4\", 0x310a, \"BOPOMOFO LETTER T\" },\n\t{ \"n4\", 0x310b, \"BOPOMOFO LETTER N\" },\n\t{ \"l4\", 0x310c, \"BOPOMOFO LETTER L\" },\n\t{ \"g4\", 0x310d, \"BOPOMOFO LETTER G\" },\n\t{ \"k4\", 0x310e, \"BOPOMOFO LETTER K\" },\n\t{ \"h4\", 0x310f, \"BOPOMOFO LETTER H\" },\n\t{ \"j4\", 0x3110, \"BOPOMOFO LETTER J\" },\n\t{ \"q4\", 0x3111, \"BOPOMOFO LETTER Q\" },\n\t{ \"x4\", 0x3112, \"BOPOMOFO LETTER X\" },\n\t{ \"zh\", 0x3113, \"BOPOMOFO LETTER ZH\" },\n\t{ \"ch\", 0x3114, \"BOPOMOFO LETTER CH\" },\n\t{ \"sh\", 0x3115, \"BOPOMOFO LETTER SH\" },\n\t{ \"r4\", 0x3116, \"BOPOMOFO LETTER R\" },\n\t{ \"z4\", 0x3117, \"BOPOMOFO LETTER Z\" },\n\t{ \"c4\", 0x3118, \"BOPOMOFO LETTER C\" },\n\t{ \"s4\", 0x3119, \"BOPOMOFO LETTER S\" },\n\t{ \"a4\", 0x311a, \"BOPOMOFO LETTER A\" },\n\t{ \"o4\", 0x311b, \"BOPOMOFO LETTER O\" },\n\t{ \"e4\", 0x311c, \"BOPOMOFO LETTER E\" },\n\t{ \"eh4\", 0x311d, \"BOPOMOFO LETTER EH\" },\n\t{ \"ai\", 0x311e, \"BOPOMOFO LETTER AI\" },\n\t{ \"ei\", 0x311f, \"BOPOMOFO LETTER EI\" },\n\t{ \"au\", 0x3120, \"BOPOMOFO LETTER AU\" },\n\t{ \"ou\", 0x3121, \"BOPOMOFO LETTER OU\" },\n\t{ \"an\", 0x3122, \"BOPOMOFO LETTER AN\" },\n\t{ \"en\", 0x3123, \"BOPOMOFO LETTER EN\" },\n\t{ \"aN\", 0x3124, \"BOPOMOFO LETTER ANG\" },\n\t{ \"eN\", 0x3125, \"BOPOMOFO LETTER ENG\" },\n\t{ \"er\", 0x3126, \"BOPOMOFO LETTER ER\" },\n\t{ \"i4\", 0x3127, \"BOPOMOFO LETTER I\" },\n\t{ \"u4\", 0x3128, \"BOPOMOFO LETTER U\" },\n\t{ \"iu\", 0x3129, \"BOPOMOFO LETTER IU\" },\n\t{ \"v4\", 0x312a, \"BOPOMOFO LETTER V\" },\n\t{ \"nG\", 0x312b, \"BOPOMOFO LETTER NG\" },\n\t{ \"gn\", 0x312c, \"BOPOMOFO LETTER GN\" },\n\t{ \"(JU)\", 0x321c, \"PARENTHESIZED HANGUL JU\" },\n\t{ \"1c\", 0x3220, \"PARENTHESIZED IDEOGRAPH ONE\" },\n\t{ \"2c\", 0x3221, \"PARENTHESIZED IDEOGRAPH TWO\" },\n\t{ \"3c\", 0x3222, \"PARENTHESIZED IDEOGRAPH THREE\" },\n\t{ \"4c\", 0x3223, \"PARENTHESIZED IDEOGRAPH FOUR\" },\n\t{ \"5c\", 0x3224, \"PARENTHESIZED IDEOGRAPH FIVE\" },\n\t{ \"6c\", 0x3225, \"PARENTHESIZED IDEOGRAPH SIX\" },\n\t{ \"7c\", 0x3226, \"PARENTHESIZED IDEOGRAPH SEVEN\" },\n\t{ \"8c\", 0x3227, \"PARENTHESIZED IDEOGRAPH EIGHT\" },\n\t{ \"9c\", 0x3228, \"PARENTHESIZED IDEOGRAPH NINE\" },\n\t{ \"10c\", 0x3229, \"PARENTHESIZED IDEOGRAPH TEN\" },\n\t{ \"KSC\", 0x327f, \"KOREAN STANDARD SYMBOL\" },\n\t{ \"ff\", 0xfb00, \"LATIN SMALL LIGATURE FF\" },\n\t{ \"fi\", 0xfb01, \"LATIN SMALL LIGATURE FI\" },\n\t{ \"fl\", 0xfb02, \"LATIN SMALL LIGATURE FL\" },\n\t{ \"ffi\", 0xfb03, \"LATIN SMALL LIGATURE FFI\" },\n\t{ \"ffl\", 0xfb04, \"LATIN SMALL LIGATURE FFL\" },\n\t{ \"ft\", 0xfb05, \"LATIN SMALL LIGATURE FT\" },\n\t{ \"st\", 0xfb06, \"LATIN SMALL LIGATURE ST\" },\n\t{ \"3+;\", 0xfe7d, \"ARABIC SHADDA MEDIAL FORM\" },\n\t{ \"aM.\", 0xfe82, \"ARABIC LETTER ALEF WITH MADDA ABOVE FINAL FORM\" },\n\t{ \"aH.\", 0xfe84, \"ARABIC LETTER ALEF WITH HAMZA ABOVE FINAL FORM\" },\n\t{ \"a+-\", 0xfe8d, \"ARABIC LETTER ALEF ISOLATED FORM\" },\n\t{ \"a+.\", 0xfe8e, \"ARABIC LETTER ALEF FINAL FORM\" },\n\t{ \"b+-\", 0xfe8f, \"ARABIC LETTER BEH ISOLATED FORM\" },\n\t{ \"b+,\", 0xfe90, \"ARABIC LETTER BEH INITIAL FORM\" },\n\t{ \"b+;\", 0xfe91, \"ARABIC LETTER BEH MEDIAL FORM\" },\n\t{ \"b+.\", 0xfe92, \"ARABIC LETTER BEH FINAL FORM\" },\n\t{ \"tm-\", 0xfe93, \"ARABIC LETTER TEH MARBUTA ISOLATED FORM\" },\n\t{ \"tm.\", 0xfe94, \"ARABIC LETTER TEH MARBUTA FINAL FORM\" },\n\t{ \"t+-\", 0xfe95, \"ARABIC LETTER TEH ISOLATED FORM\" },\n\t{ \"t+,\", 0xfe96, \"ARABIC LETTER TEH INITIAL FORM\" },\n\t{ \"t+;\", 0xfe97, \"ARABIC LETTER TEH MEDIAL FORM\" },\n\t{ \"t+.\", 0xfe98, \"ARABIC LETTER TEH FINAL FORM\" },\n\t{ \"tk-\", 0xfe99, \"ARABIC LETTER THEH ISOLATED FORM\" },\n\t{ \"tk,\", 0xfe9a, \"ARABIC LETTER THEH INITIAL FORM\" },\n\t{ \"tk;\", 0xfe9b, \"ARABIC LETTER THEH MEDIAL FORM\" },\n\t{ \"tk.\", 0xfe9c, \"ARABIC LETTER THEH FINAL FORM\" },\n\t{ \"g+-\", 0xfe9d, \"ARABIC LETTER JEEM ISOLATED FORM\" },\n\t{ \"g+,\", 0xfe9e, \"ARABIC LETTER JEEM INITIAL FORM\" },\n\t{ \"g+;\", 0xfe9f, \"ARABIC LETTER JEEM MEDIAL FORM\" },\n\t{ \"g+.\", 0xfea0, \"ARABIC LETTER JEEM FINAL FORM\" },\n\t{ \"hk-\", 0xfea1, \"ARABIC LETTER HAH ISOLATED FORM\" },\n\t{ \"hk,\", 0xfea2, \"ARABIC LETTER HAH INITIAL FORM\" },\n\t{ \"hk;\", 0xfea3, \"ARABIC LETTER HAH MEDIAL FORM\" },\n\t{ \"hk.\", 0xfea4, \"ARABIC LETTER HAH FINAL FORM\" },\n\t{ \"x+-\", 0xfea5, \"ARABIC LETTER KHAH ISOLATED FORM\" },\n\t{ \"x+,\", 0xfea6, \"ARABIC LETTER KHAH INITIAL FORM\" },\n\t{ \"x+;\", 0xfea7, \"ARABIC LETTER KHAH MEDIAL FORM\" },\n\t{ \"x+.\", 0xfea8, \"ARABIC LETTER KHAH FINAL FORM\" },\n\t{ \"d+-\", 0xfea9, \"ARABIC LETTER DAL ISOLATED FORM\" },\n\t{ \"d+.\", 0xfeaa, \"ARABIC LETTER DAL FINAL FORM\" },\n\t{ \"dk-\", 0xfeab, \"ARABIC LETTER THAL ISOLATED FORM\" },\n\t{ \"dk.\", 0xfeac, \"ARABIC LETTER THAL FINAL FORM\" },\n\t{ \"r+-\", 0xfead, \"ARABIC LETTER REH ISOLATED FORM\" },\n\t{ \"r+.\", 0xfeae, \"ARABIC LETTER REH FINAL FORM\" },\n\t{ \"z+-\", 0xfeaf, \"ARABIC LETTER ZAIN ISOLATED FORM\" },\n\t{ \"z+.\", 0xfeb0, \"ARABIC LETTER ZAIN FINAL FORM\" },\n\t{ \"s+-\", 0xfeb1, \"ARABIC LETTER SEEN ISOLATED FORM\" },\n\t{ \"s+,\", 0xfeb2, \"ARABIC LETTER SEEN INITIAL FORM\" },\n\t{ \"s+;\", 0xfeb3, \"ARABIC LETTER SEEN MEDIAL FORM\" },\n\t{ \"s+.\", 0xfeb4, \"ARABIC LETTER SEEN FINAL FORM\" },\n\t{ \"sn-\", 0xfeb5, \"ARABIC LETTER SHEEN ISOLATED FORM\" },\n\t{ \"sn,\", 0xfeb6, \"ARABIC LETTER SHEEN INITIAL FORM\" },\n\t{ \"sn;\", 0xfeb7, \"ARABIC LETTER SHEEN MEDIAL FORM\" },\n\t{ \"sn.\", 0xfeb8, \"ARABIC LETTER SHEEN FINAL FORM\" },\n\t{ \"c+-\", 0xfeb9, \"ARABIC LETTER SAD ISOLATED FORM\" },\n\t{ \"c+,\", 0xfeba, \"ARABIC LETTER SAD INITIAL FORM\" },\n\t{ \"c+;\", 0xfebb, \"ARABIC LETTER SAD MEDIAL FORM\" },\n\t{ \"c+.\", 0xfebc, \"ARABIC LETTER SAD FINAL FORM\" },\n\t{ \"dd-\", 0xfebd, \"ARABIC LETTER DAD ISOLATED FORM\" },\n\t{ \"dd,\", 0xfebe, \"ARABIC LETTER DAD INITIAL FORM\" },\n\t{ \"dd;\", 0xfebf, \"ARABIC LETTER DAD MEDIAL FORM\" },\n\t{ \"dd.\", 0xfec0, \"ARABIC LETTER DAD FINAL FORM\" },\n\t{ \"tj-\", 0xfec1, \"ARABIC LETTER TAH ISOLATED FORM\" },\n\t{ \"tj,\", 0xfec2, \"ARABIC LETTER TAH INITIAL FORM\" },\n\t{ \"tj;\", 0xfec3, \"ARABIC LETTER TAH MEDIAL FORM\" },\n\t{ \"tj.\", 0xfec4, \"ARABIC LETTER TAH FINAL FORM\" },\n\t{ \"zH-\", 0xfec5, \"ARABIC LETTER ZAH ISOLATED FORM\" },\n\t{ \"zH,\", 0xfec6, \"ARABIC LETTER ZAH INITIAL FORM\" },\n\t{ \"zH;\", 0xfec7, \"ARABIC LETTER ZAH MEDIAL FORM\" },\n\t{ \"zH.\", 0xfec8, \"ARABIC LETTER ZAH FINAL FORM\" },\n\t{ \"e+-\", 0xfec9, \"ARABIC LETTER AIN ISOLATED FORM\" },\n\t{ \"e+,\", 0xfeca, \"ARABIC LETTER AIN INITIAL FORM\" },\n\t{ \"e+;\", 0xfecb, \"ARABIC LETTER AIN MEDIAL FORM\" },\n\t{ \"e+.\", 0xfecc, \"ARABIC LETTER AIN FINAL FORM\" },\n\t{ \"i+-\", 0xfecd, \"ARABIC LETTER GHAIN ISOLATED FORM\" },\n\t{ \"i+,\", 0xfece, \"ARABIC LETTER GHAIN INITIAL FORM\" },\n\t{ \"i+;\", 0xfecf, \"ARABIC LETTER GHAIN MEDIAL FORM\" },\n\t{ \"i+.\", 0xfed0, \"ARABIC LETTER GHAIN FINAL FORM\" },\n\t{ \"f+-\", 0xfed1, \"ARABIC LETTER FEH ISOLATED FORM\" },\n\t{ \"f+,\", 0xfed2, \"ARABIC LETTER FEH INITIAL FORM\" },\n\t{ \"f+;\", 0xfed3, \"ARABIC LETTER FEH MEDIAL FORM\" },\n\t{ \"f+.\", 0xfed4, \"ARABIC LETTER FEH FINAL FORM\" },\n\t{ \"q+-\", 0xfed5, \"ARABIC LETTER QAF ISOLATED FORM\" },\n\t{ \"q+,\", 0xfed6, \"ARABIC LETTER QAF INITIAL FORM\" },\n\t{ \"q+;\", 0xfed7, \"ARABIC LETTER QAF MEDIAL FORM\" },\n\t{ \"q+.\", 0xfed8, \"ARABIC LETTER QAF FINAL FORM\" },\n\t{ \"k+-\", 0xfed9, \"ARABIC LETTER KAF ISOLATED FORM\" },\n\t{ \"k+,\", 0xfeda, \"ARABIC LETTER KAF INITIAL FORM\" },\n\t{ \"k+;\", 0xfedb, \"ARABIC LETTER KAF MEDIAL FORM\" },\n\t{ \"k+.\", 0xfedc, \"ARABIC LETTER KAF FINAL FORM\" },\n\t{ \"l+-\", 0xfedd, \"ARABIC LETTER LAM ISOLATED FORM\" },\n\t{ \"l+,\", 0xfede, \"ARABIC LETTER LAM INITIAL FORM\" },\n\t{ \"l+;\", 0xfedf, \"ARABIC LETTER LAM MEDIAL FORM\" },\n\t{ \"l+.\", 0xfee0, \"ARABIC LETTER LAM FINAL FORM\" },\n\t{ \"m+-\", 0xfee1, \"ARABIC LETTER MEEM ISOLATED FORM\" },\n\t{ \"m+,\", 0xfee2, \"ARABIC LETTER MEEM INITIAL FORM\" },\n\t{ \"m+;\", 0xfee3, \"ARABIC LETTER MEEM MEDIAL FORM\" },\n\t{ \"m+.\", 0xfee4, \"ARABIC LETTER MEEM FINAL FORM\" },\n\t{ \"n+-\", 0xfee5, \"ARABIC LETTER NOON ISOLATED FORM\" },\n\t{ \"n+,\", 0xfee6, \"ARABIC LETTER NOON INITIAL FORM\" },\n\t{ \"n+;\", 0xfee7, \"ARABIC LETTER NOON MEDIAL FORM\" },\n\t{ \"n+.\", 0xfee8, \"ARABIC LETTER NOON FINAL FORM\" },\n\t{ \"h+-\", 0xfee9, \"ARABIC LETTER HEH ISOLATED FORM\" },\n\t{ \"h+,\", 0xfeea, \"ARABIC LETTER HEH INITIAL FORM\" },\n\t{ \"h+;\", 0xfeeb, \"ARABIC LETTER HEH MEDIAL FORM\" },\n\t{ \"h+.\", 0xfeec, \"ARABIC LETTER HEH FINAL FORM\" },\n\t{ \"w+-\", 0xfeed, \"ARABIC LETTER WAW ISOLATED FORM\" },\n\t{ \"w+.\", 0xfeee, \"ARABIC LETTER WAW FINAL FORM\" },\n\t{ \"j+-\", 0xfeef, \"ARABIC LETTER ALEF MAKSURA ISOLATED FORM\" },\n\t{ \"j+.\", 0xfef0, \"ARABIC LETTER ALEF MAKSURA FINAL FORM\" },\n\t{ \"y+-\", 0xfef1, \"ARABIC LETTER YEH ISOLATED FORM\" },\n\t{ \"y+,\", 0xfef2, \"ARABIC LETTER YEH INITIAL FORM\" },\n\t{ \"y+;\", 0xfef3, \"ARABIC LETTER YEH MEDIAL FORM\" },\n\t{ \"y+.\", 0xfef4, \"ARABIC LETTER YEH FINAL FORM\" },\n\t{ \"lM-\", 0xfef5, \"ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM\" },\n\t{ \"lM.\", 0xfef6, \"ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM\" },\n\t{ \"lH-\", 0xfef7, \"ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM\" },\n\t{ \"lH.\", 0xfef8, \"ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM\" },\n\t{ \"lh-\", 0xfef9, \"ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM\" },\n\t{ \"lh.\", 0xfefa, \"ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM\" },\n\t{ \"la-\", 0xfefb, \"ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM\" },\n\t{ \"la.\", 0xfefc, \"ARABIC LIGATURE LAM WITH ALEF FINAL FORM\" },\n\t{ \"NU\", 0x0000, \"NULL (NUL)\" },\n\t{ \"SH\", 0x0001, \"START OF HEADING (SOH)\" },\n\t{ \"SX\", 0x0002, \"START OF TEXT (STX)\" },\n\t{ \"EX\", 0x0003, \"END OF TEXT (ETX)\" },\n\t{ \"ET\", 0x0004, \"END OF TRANSMISSION (EOT)\" },\n\t{ \"EQ\", 0x0005, \"ENQUIRY (ENQ)\" },\n\t{ \"AK\", 0x0006, \"ACKNOWLEDGE (ACK)\" },\n\t{ \"BL\", 0x0007, \"BELL (BEL)\" },\n\t{ \"BS\", 0x0008, \"BACKSPACE (BS)\" },\n\t{ \"HT\", 0x0009, \"CHARACTER TABULATION (HT)\" },\n\t{ \"LF\", 0x000a, \"LINE FEED (LF)\" },\n\t{ \"VT\", 0x000b, \"LINE TABULATION (VT)\" },\n\t{ \"FF\", 0x000c, \"FORM FEED (FF)\" },\n\t{ \"CR\", 0x000d, \"CARRIAGE RETURN (CR)\" },\n\t{ \"SO\", 0x000e, \"SHIFT OUT (SO)\" },\n\t{ \"SI\", 0x000f, \"SHIFT IN (SI)\" },\n\t{ \"DL\", 0x0010, \"DATALINK ESCAPE (DLE)\" },\n\t{ \"D1\", 0x0011, \"DEVICE CONTROL ONE (DC1)\" },\n\t{ \"D2\", 0x0012, \"DEVICE CONTROL TWO (DC2)\" },\n\t{ \"D3\", 0x0013, \"DEVICE CONTROL THREE (DC3)\" },\n\t{ \"D4\", 0x0014, \"DEVICE CONTROL FOUR (DC4)\" },\n\t{ \"NK\", 0x0015, \"NEGATIVE ACKNOWLEDGE (NAK)\" },\n\t{ \"SY\", 0x0016, \"SYNCRONOUS IDLE (SYN)\" },\n\t{ \"EB\", 0x0017, \"END OF TRANSMISSION BLOCK (ETB)\" },\n\t{ \"CN\", 0x0018, \"CANCEL (CAN)\" },\n\t{ \"EM\", 0x0019, \"END OF MEDIUM (EM)\" },\n\t{ \"SB\", 0x001a, \"SUBSTITUTE (SUB)\" },\n\t{ \"EC\", 0x001b, \"ESCAPE (ESC)\" },\n\t{ \"FS\", 0x001c, \"FILE SEPARATOR (IS4)\" },\n\t{ \"GS\", 0x001d, \"GROUP SEPARATOR (IS3)\" },\n\t{ \"RS\", 0x001e, \"RECORD SEPARATOR (IS2)\" },\n\t{ \"US\", 0x001f, \"UNIT SEPARATOR (IS1)\" },\n\t{ \"DT\", 0x007f, \"DELETE (DEL)\" },\n\t{ \"PA\", 0x0080, \"PADDING CHARACTER (PAD)\" },\n\t{ \"HO\", 0x0081, \"HIGH OCTET PRESET (HOP)\" },\n\t{ \"BH\", 0x0082, \"BREAK PERMITTED HERE (BPH)\" },\n\t{ \"NH\", 0x0083, \"NO BREAK HERE (NBH)\" },\n\t{ \"IN\", 0x0084, \"INDEX (IND)\" },\n\t{ \"NL\", 0x0085, \"NEXT LINE (NEL)\" },\n\t{ \"SA\", 0x0086, \"START OF SELECTED AREA (SSA)\" },\n\t{ \"ES\", 0x0087, \"END OF SELECTED AREA (ESA)\" },\n\t{ \"HS\", 0x0088, \"CHARACTER TABULATION SET (HTS)\" },\n\t{ \"HJ\", 0x0089, \"CHARACTER TABULATION WITH JUSTIFICATION (HTJ)\" },\n\t{ \"VS\", 0x008a, \"LINE TABULATION SET (VTS)\" },\n\t{ \"PD\", 0x008b, \"PARTIAL LINE FORWARD (PLD)\" },\n\t{ \"PU\", 0x008c, \"PARTIAL LINE BACKWARD (PLU)\" },\n\t{ \"RI\", 0x008d, \"REVERSE LINE FEED (RI)\" },\n\t{ \"S2\", 0x008e, \"SINGLE-SHIFT TWO (SS2)\" },\n\t{ \"S3\", 0x008f, \"SINGLE-SHIFT THREE (SS3)\" },\n\t{ \"DC\", 0x0090, \"DEVICE CONTROL STRING (DCS)\" },\n\t{ \"P1\", 0x0091, \"PRIVATE USE ONE (PU1)\" },\n\t{ \"P2\", 0x0092, \"PRIVATE USE TWO (PU2)\" },\n\t{ \"TS\", 0x0093, \"SET TRANSMIT STATE (STS)\" },\n\t{ \"CC\", 0x0094, \"CANCEL CHARACTER (CCH)\" },\n\t{ \"MW\", 0x0095, \"MESSAGE WAITING (MW)\" },\n\t{ \"SG\", 0x0096, \"START OF GUARDED AREA (SPA)\" },\n\t{ \"EG\", 0x0097, \"END OF GUARDED AREA (EPA)\" },\n\t{ \"SS\", 0x0098, \"START OF STRING (SOS)\" },\n\t{ \"GC\", 0x0099, \"SINGLE GRAPHIC CHARACTER INTRODUCER (SGCI)\" },\n\t{ \"SC\", 0x009a, \"SINGLE CHARACTER INTRODUCER (SCI)\" },\n\t{ \"CI\", 0x009b, \"CONTROL SEQUENCE INTRODUCER (CSI)\" },\n\t{ \"ST\", 0x009c, \"STRING TERMINATOR (ST)\" },\n\t{ \"OC\", 0x009d, \"OPERATING SYSTEM COMMAND (OSC)\" },\n\t{ \"PM\", 0x009e, \"PRIVACY MESSAGE (PM)\" },\n\t{ \"AC\", 0x009f, \"APPLICATION PROGRAM COMMAND (APC)\" },\n\t{ \"  \", 0xe000, \"indicates unfinished (Mnemonic)\" },\n\t{ \"/c\", 0xe001, \"JOIN THIS LINE WITH NEXT LINE (Mnemonic)\" },\n\t{ \"UA\", 0xe002, \"Unit space A (ISO-IR-8-1 064)\" },\n\t{ \"UB\", 0xe003, \"Unit space B (ISO-IR-8-1 096)\" },\n\t{ \"\\\"3\", 0xe004, \"NON-SPACING UMLAUT (ISO-IR-38 201) (character part)\" },\n\t{ \"\\\"1\", 0xe005, \"NON-SPACING DIAERESIS WITH ACCENT (ISO-IR-70 192) (character part)\" },\n\t{ \"\\\"!\", 0xe006, \"NON-SPACING GRAVE ACCENT (ISO-IR-103 193) (character part)\" },\n\t{ \"\\\"'\", 0xe007, \"NON-SPACING ACUTE ACCENT (ISO-IR-103 194) (character part)\" },\n\t{ \"\\\">\", 0xe008, \"NON-SPACING CIRCUMFLEX ACCENT (ISO-IR-103 195) (character part)\" },\n\t{ \"\\\"?\", 0xe009, \"NON-SPACING TILDE (ISO-IR-103 196) (character part)\" },\n\t{ \"\\\"-\", 0xe00a, \"NON-SPACING MACRON (ISO-IR-103 197) (character part)\" },\n\t{ \"\\\"(\", 0xe00b, \"NON-SPACING BREVE (ISO-IR-103 198) (character part)\" },\n\t{ \"\\\".\", 0xe00c, \"NON-SPACING DOT ABOVE (ISO-IR-103 199) (character part)\" },\n\t{ \"\\\":\", 0xe00d, \"NON-SPACING DIAERESIS (ISO-IR-103 200) (character part)\" },\n\t{ \"\\\"0\", 0xe00e, \"NON-SPACING RING ABOVE (ISO-IR-103 202) (character part)\" },\n\t{ \"\\\"\\\"\", 0xe00f, \"NON-SPACING DOUBLE ACCUTE (ISO-IR-103 204) (character part)\" },\n\t{ \"\\\"<\", 0xe010, \"NON-SPACING CARON (ISO-IR-103 206) (character part)\" },\n\t{ \"\\\",\", 0xe011, \"NON-SPACING CEDILLA (ISO-IR-103 203) (character part)\" },\n\t{ \"\\\";\", 0xe012, \"NON-SPACING OGONEK (ISO-IR-103 206) (character part)\" },\n\t{ \"\\\"_\", 0xe013, \"NON-SPACING LOW LINE (ISO-IR-103 204) (character part)\" },\n\t{ \"\\\"=\", 0xe014, \"NON-SPACING DOUBLE LOW LINE (ISO-IR-38 217) (character part)\" },\n\t{ \"\\\"/\", 0xe015, \"NON-SPACING LONG SOLIDUS (ISO-IR-128 201) (character part)\" },\n\t{ \"\\\"i\", 0xe016, \"GREEK NON-SPACING IOTA BELOW (ISO-IR-55 39) (character part)\" },\n\t{ \"\\\"d\", 0xe017, \"GREEK NON-SPACING DASIA PNEUMATA (ISO-IR-55 38) (character part)\" },\n\t{ \"\\\"p\", 0xe018, \"GREEK NON-SPACING PSILI PNEUMATA (ISO-IR-55 37) (character part)\" },\n\t{ \";;\", 0xe019, \"GREEK DASIA PNEUMATA (ISO-IR-18 92)\" },\n\t{ \",,\", 0xe01a, \"GREEK PSILI PNEUMATA (ISO-IR-18 124)\" },\n\t{ \"b3\", 0xe01b, \"GREEK SMALL LETTER MIDDLE BETA (ISO-IR-18 99)\" },\n\t{ \"Ci\", 0xe01c, \"CIRCLE (ISO-IR-83 0294)\" },\n\t{ \"f(\", 0xe01d, \"FUNCTION SIGN (ISO-IR-143 221)\" },\n\t{ \"ed\", 0xe01e, \"LATIN SMALL LETTER EZH (ISO-IR-158 142)\" },\n\t{ \"am\", 0xe01f, \"ANTE MERIDIAM SIGN (ISO-IR-149 0267)\" },\n\t{ \"pm\", 0xe020, \"POST MERIDIAM SIGN (ISO-IR-149 0268)\" },\n\t{ \"Tel\", 0xe021, \"TEL COMPATIBILITY SIGN (ISO-IR-149 0269)\" },\n\t{ \"a+:\", 0xe022, \"ARABIC LETTER ALEF FINAL FORM COMPATIBILITY (IBM868 144)\" },\n\t{ \"Fl\", 0xe023, \"DUTCH GUILDER SIGN (IBM437 159)\" },\n\t{ \"GF\", 0xe024, \"GAMMA FUNCTION SIGN (ISO-10646-1DIS 032/032/037/122)\" },\n\t{ \">V\", 0xe025, \"RIGHTWARDS VECTOR ABOVE (ISO-10646-1DIS 032/032/038/046)\" },\n\t{ \"!*\", 0xe026, \"GREEK VARIA (ISO-10646-1DIS 032/032/042/164)\" },\n\t{ \"?*\", 0xe027, \"GREEK PERISPOMENI (ISO-10646-1DIS 032/032/042/165)\" },\n\t{ \"J<\", 0xe028, \"LATIN CAPITAL LETTER J WITH CARON (lowercase: 000/000/001/240)\" },\n\t{ \"\", 0, NULL },\n};\n\nstatic struct termios tio_old, tio_new;\n\n// return values: 0 (not found), 1 (found), -1 (prefix)\nstatic int lookup(const char *name, wchar_t *rune) {\n\tsize_t len = strlen(name);\n\tfor (const Digraph *d = digraphs; d->name[0]; d++) {\n\t\tif (strncmp(name, d->name, len) == 0) {\n\t\t\t*rune = d->rune;\n\t\t\treturn d->name[len] == '\\0' ? 1 : -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void setup(void) {\n\ttcgetattr(0, &tio_old);\n\ttio_new = tio_old;\n\ttio_new.c_iflag &= ~(BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);\n\ttio_new.c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);\n\ttio_new.c_cflag &= ~(CSIZE|PARENB);\n\ttio_new.c_cflag |= CS8;\n\ttio_new.c_cc[VMIN] = 1;\n\ttcsetattr(0, TCSANOW, &tio_new);\n}\n\nstatic void cleanup(void) {\n\ttcsetattr(0, TCSANOW, &tio_old);\n}\n\nstatic ssize_t readc(char *c) {\n\tfor (;;) {\n\t\tssize_t r = read(0, c, 1);\n\t\tif (r == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\treturn r;\n\t}\n}\n\n/* program exit status:\n *  0 -> success\n *  1 -> invalid\n *  2 -> prefix\n *  3 -> error\n */\nint main(int argc, char *argv[]) {\n\tsetlocale(LC_ALL, \"\");\n\n\tif (argc == 1) {\n\t\tfor (const Digraph *d = digraphs; d->name[0]; d++)\n\t\t\twprintf(L\"%s %lc %s\\n\", d->name, d->rune, d->description);\n\t\treturn 0;\n\t}\n\n\tif (strcmp(argv[1], \"-\") == 0) {\n\t\tsetup();\n\t\tchar name[MAX_DIGRAPH_LENGTH+1] = \"\";\n\t\tfor (size_t i = 0; i < sizeof(name)-1; i++) {\n\t\t\tssize_t r = readc(name+i);\n\t\t\tif (r == -1) {\n\t\t\t\tcleanup();\n\t\t\t\tfputs(\"I/O error\", stderr);\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\twchar_t rune;\n\t\t\tint l = lookup(name, &rune);\n\t\t\tif (l == 0 || (l == -1 && r == 0)) {\n\t\t\t\tcleanup();\n\t\t\t\tfprintf(stderr, \"Unknown digraph: `%s'\\n\", name);\n\t\t\t\treturn 1;\n\t\t\t} else if (l == 1) {\n\t\t\t\tcleanup();\n\t\t\t\tputwchar(rune);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcleanup();\n\t\treturn 1;\n\t}\n\n\twchar_t *runes = calloc(argc-1, sizeof(runes[0]));\n\tif (!runes) {\n\t\tperror(NULL);\n\t\treturn 1;\n\t}\n\n\tfor (int i = 1; i < argc; i++) {\n\t\tint l = lookup(argv[i], &runes[i-1]);\n\t\tif (l == 0) {\n\t\t\tfprintf(stderr, \"Unknown digraph: `%s'\\n\", argv[i]);\n\t\t\treturn 1;\n\t\t} else if (l == -1) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\n\tfor (int i = 0; i < argc-1; i++)\n\t\tputwchar(runes[i]);\n\treturn 0;\n}\n"
        },
        {
          "name": "vis-lua.c",
          "type": "blob",
          "size": 98.9931640625,
          "content": "/***\n * Lua Extension API for the [Vis Editor](https://github.com/martanne/vis).\n *\n * *WARNING:* there is no stability guarantee at this time, the API might\n * change without notice!\n *\n * This document might be out of date, run `make luadoc` to regenerate it.\n *\n * @module vis\n * @author Marc André Tanner\n * @license ISC\n * @release RELEASE\n */\n#include <stddef.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n#include <unistd.h>\n#include <libgen.h>\n#include <sys/types.h>\n#include <pwd.h>\n\n#include \"vis-lua.h\"\n#include \"vis-core.h\"\n#include \"text-motions.h\"\n#include \"util.h\"\n\n#ifndef VIS_PATH\n#define VIS_PATH \"/usr/local/share/vis\"\n#endif\n\n#define VIS_LUA_TYPE_VIS \"vis\"\n#define VIS_LUA_TYPE_WIN_OPTS \"winoptions\"\n#define VIS_LUA_TYPE_VIS_OPTS \"visoptions\"\n#define VIS_LUA_TYPE_FILE \"file\"\n#define VIS_LUA_TYPE_TEXT \"text\"\n#define VIS_LUA_TYPE_MARK \"mark\"\n#define VIS_LUA_TYPE_MARKS \"marks\"\n#define VIS_LUA_TYPE_WINDOW \"window\"\n#define VIS_LUA_TYPE_SELECTION \"selection\"\n#define VIS_LUA_TYPE_SELECTIONS \"selections\"\n#define VIS_LUA_TYPE_UI \"ui\"\n#define VIS_LUA_TYPE_REGISTERS \"registers\"\n#define VIS_LUA_TYPE_KEYACTION \"keyaction\"\n\n#ifndef DEBUG_LUA\n#define DEBUG_LUA 0\n#endif\n\n#if DEBUG_LUA\n#define debug(...) do { printf(__VA_ARGS__); fflush(stdout); } while (0)\n#else\n#define debug(...) do { } while (0)\n#endif\n\n\n#if !CONFIG_LUA\n\nbool vis_lua_path_add(Vis *vis, const char *path) { return true; }\nbool vis_lua_paths_get(Vis *vis, char **lpath, char **cpath) { return false; }\nvoid vis_lua_process_response(Vis *vis, const char *name,\n                              char *buffer, size_t len, ResponseType rtype) { }\n\n#else\n\n#if DEBUG_LUA\nstatic void stack_dump_entry(lua_State *L, int i) {\n\tint t = lua_type(L, i);\n\tswitch (t) {\n\tcase LUA_TNIL:\n\t\tprintf(\"nil\");\n\t\tbreak;\n\tcase LUA_TBOOLEAN:\n\t\tprintf(lua_toboolean(L, i) ? \"true\" : \"false\");\n\t\tbreak;\n\tcase LUA_TLIGHTUSERDATA:\n\t\tprintf(\"lightuserdata(%p)\", lua_touserdata(L, i));\n\t\tbreak;\n\tcase LUA_TNUMBER:\n\t\tprintf(\"%g\", lua_tonumber(L, i));\n\t\tbreak;\n\tcase LUA_TSTRING:\n\t\tprintf(\"`%s'\", lua_tostring(L, i));\n\t\tbreak;\n\tcase LUA_TTABLE:\n\t\tprintf(\"table[\");\n\t\tlua_pushnil(L); /* first key */\n\t\twhile (lua_next(L, i > 0 ? i : i - 1)) {\n\t\t\tstack_dump_entry(L, -2);\n\t\t\tprintf(\"=\");\n\t\t\tstack_dump_entry(L, -1);\n\t\t\tprintf(\",\");\n\t\t\tlua_pop(L, 1); /* remove value, keep key */\n\t\t}\n\t\tprintf(\"]\");\n\t\tbreak;\n\tcase LUA_TUSERDATA:\n\t\tprintf(\"userdata(%p)\", lua_touserdata(L, i));\n\t\tbreak;\n\tdefault:  /* other values */\n\t\tprintf(\"%s\", lua_typename(L, t));\n\t\tbreak;\n\t}\n}\n\nstatic void stack_dump(lua_State *L, const char *format, ...) {\n\tva_list ap;\n\tva_start(ap, format);\n\tvprintf(format, ap);\n\tva_end(ap);\n\tint top = lua_gettop(L);\n\tfor (int i = 1; i <= top; i++) {\n\t\tprintf(\"%d: \", i);\n\t\tstack_dump_entry(L, i);\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\\n\");\n\tfflush(stdout);\n}\n\n#endif\n\nstatic int panic_handler(lua_State *L) {\n\tvoid *ud = NULL;\n\tlua_getallocf(L, &ud);\n\tif (ud) {\n\t\tVis *vis = ud;\n\t\tvis->lua = NULL;\n\t\tconst char *msg = NULL;\n\t\tif (lua_type(L, -1) == LUA_TSTRING)\n\t\t\tmsg = lua_tostring(L, -1);\n\t\tvis_info_show(vis, \"Fatal Lua error: %s\", msg ? msg : \"unknown reason\");\n\t\tlua_close(L);\n\t\tif (vis->running)\n\t\t\tsiglongjmp(vis->sigbus_jmpbuf, 1);\n\t}\n\treturn 0;\n}\n\nstatic int error_handler(lua_State *L) {\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tif (vis->errorhandler)\n\t\treturn 1;\n\tvis->errorhandler = true;\n\tsize_t len;\n\tconst char *msg = lua_tostring(L, 1);\n\tif (msg)\n\t\tluaL_traceback(L, L, msg, 1);\n\tmsg = lua_tolstring(L, 1, &len);\n\tvis_message_show(vis, msg);\n\tvis->errorhandler = false;\n\treturn 1;\n}\n\nstatic int pcall(Vis *vis, lua_State *L, int nargs, int nresults) {\n\t/* insert a custom error function below all arguments */\n\tint msgh = lua_gettop(L) - nargs;\n\tlua_pushlightuserdata(L, vis);\n\tlua_pushcclosure(L, error_handler, 1);\n\tlua_insert(L, msgh);\n\tint ret = lua_pcall(L, nargs, nresults, msgh);\n\tlua_remove(L, msgh);\n\treturn ret;\n}\n\n/* expects a lua function at stack position `narg` and stores a\n * reference to it in the registry. The return value can be used\n * to look it up.\n *\n *   registry[\"vis.functions\"][(void*)(function)] = function\n */\nstatic const void *func_ref_new(lua_State *L, int narg) {\n\tconst void *addr = lua_topointer(L, narg);\n\tif (!lua_isfunction(L, narg) || !addr)\n\t\tluaL_argerror(L, narg, \"function expected\");\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.functions\");\n\tlua_pushlightuserdata(L, (void*)addr);\n\tlua_pushvalue(L, narg);\n\tlua_settable(L, -3);\n\tlua_pop(L, 1);\n\treturn addr;\n}\n\n/* retrieve function from registry and place it at the top of the stack */\nstatic bool func_ref_get(lua_State *L, const void *addr) {\n\tif (!addr)\n\t\treturn false;\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.functions\");\n\tlua_pushlightuserdata(L, (void*)addr);\n\tlua_gettable(L, -2);\n\tlua_remove(L, -2);\n\tif (!lua_isfunction(L, -1)) {\n\t\tlua_pop(L, 1);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n/* creates a new metatable for a given type and stores a mapping:\n *\n *   registry[\"vis.types\"][metatable] = type\n *\n * leaves the metatable at the top of the stack.\n */\nstatic void obj_type_new(lua_State *L, const char *type) {\n\tluaL_newmetatable(L, type);\n\tlua_getglobal(L, \"vis\");\n\tif (!lua_isnil(L, -1)) {\n\t\tlua_getfield(L, -1, \"types\");\n\t\tlua_pushvalue(L, -3);\n\t\tlua_setfield(L, -2, type);\n\t\tlua_pop(L, 1);\n\t}\n\tlua_pop(L, 1);\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.types\");\n\tlua_pushvalue(L, -2);\n\tlua_pushstring(L, type);\n\tlua_settable(L, -3);\n\tlua_pop(L, 1);\n}\n\n/* get type of userdatum at the top of the stack:\n *\n *   return registry[\"vis.types\"][getmetatable(userdata)]\n */\nconst char *obj_type_get(lua_State *L) {\n\tif (lua_isnil(L, -1))\n\t\treturn \"nil\";\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.types\");\n\tlua_getmetatable(L, -2);\n\tlua_gettable(L, -2);\n\t// XXX: in theory string might become invalid when popped from stack\n\tconst char *type = lua_tostring(L, -1);\n\tlua_pop(L, 2);\n\treturn type;\n}\n\nstatic void *obj_new(lua_State *L, size_t size, const char *type) {\n\tvoid *obj = lua_newuserdata(L, size);\n\tluaL_getmetatable(L, type);\n\tlua_setmetatable(L, -2);\n\tlua_newtable(L);\n\tlua_setuservalue(L, -2);\n\treturn obj;\n}\n\n/* returns registry[\"vis.objects\"][addr] if it is of correct type */\nstatic void *obj_ref_get(lua_State *L, void *addr, const char *type) {\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.objects\");\n\tlua_pushlightuserdata(L, addr);\n\tlua_gettable(L, -2);\n\tlua_remove(L, -2);\n\tif (lua_isnil(L, -1)) {\n\t\tdebug(\"get: vis.objects[%p] = nil\\n\", addr);\n\t\tlua_pop(L, 1);\n\t\treturn NULL;\n\t}\n\tif (DEBUG_LUA) {\n\t\tconst char *actual_type = obj_type_get(L);\n\t\tif (strcmp(type, actual_type) != 0)\n\t\t\tdebug(\"get: vis.objects[%p] = %s (BUG: expected %s)\\n\", addr, actual_type, type);\n\t\tvoid **handle = luaL_checkudata(L, -1, type);\n\t\tif (!handle)\n\t\t\tdebug(\"get: vis.objects[%p] = %s (BUG: invalid handle)\\n\", addr, type);\n\t\telse if (*handle != addr)\n\t\t\tdebug(\"get: vis.objects[%p] = %s (BUG: handle mismatch %p)\\n\", addr, type, *handle);\n\t}\n\t/* verify that obj is correct type then unmodify the stack */\n\tluaL_checkudata(L, -1, type);\n\tlua_pop(L, 1);\n\treturn addr;\n}\n\n/* expects a userdatum at the top of the stack and sets\n *\n *   registry[\"vis.objects\"][addr] = userdata\n */\nstatic void obj_ref_set(lua_State *L, void *addr) {\n\t//debug(\"set: vis.objects[%p] = %s\\n\", addr, obj_type_get(L));\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.objects\");\n\tlua_pushlightuserdata(L, addr);\n\tlua_pushvalue(L, -3);\n\tlua_settable(L, -3);\n\tlua_pop(L, 1);\n}\n\n/* invalidates an object reference\n *\n *   registry[\"vis.objects\"][addr] = nil\n */\nstatic void obj_ref_free(lua_State *L, void *addr) {\n\tif (DEBUG_LUA) {\n\t\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.objects\");\n\t\tlua_pushlightuserdata(L, addr);\n\t\tlua_gettable(L, -2);\n\t\tlua_remove(L, -2);\n\t\tif (lua_isnil(L, -1))\n\t\t\tdebug(\"free-unused: %p\\n\", addr);\n\t\telse\n\t\t\tdebug(\"free: vis.objects[%p] = %s\\n\", addr, obj_type_get(L));\n\t\tlua_pop(L, 1);\n\t}\n\tlua_pushnil(L);\n\tobj_ref_set(L, addr);\n}\n\n/* creates a new object reference of given type if it does not already exist in the registry:\n *\n *  if (registry[\"vis.types\"][metatable(registry[\"vis.objects\"][addr])] != type) {\n *      // XXX: should not happen\n *      registry[\"vis.objects\"][addr] = new_obj(addr, type)\n *  }\n *  return registry[\"vis.objects\"][addr];\n */\nstatic void *obj_ref_new(lua_State *L, void *addr, const char *type) {\n\tif (!addr) {\n\t\tlua_pushnil(L);\n\t\treturn NULL;\n\t}\n\tlua_getfield(L, LUA_REGISTRYINDEX, \"vis.objects\");\n\tlua_pushlightuserdata(L, addr);\n\tlua_gettable(L, -2);\n\tlua_remove(L, -2);\n\tconst char *old_type = obj_type_get(L);\n\tif (strcmp(type, old_type) == 0) {\n\t\tdebug(\"new: vis.objects[%p] = %s (returning existing object)\\n\", addr, old_type);\n\t\tvoid **handle = luaL_checkudata(L, -1, type);\n\t\tif (!handle)\n\t\t\tdebug(\"new: vis.objects[%p] = %s (BUG: invalid handle)\\n\", addr, old_type);\n\t\telse if (*handle != addr)\n\t\t\tdebug(\"new: vis.objects[%p] = %s (BUG: handle mismatch %p)\\n\", addr, old_type, *handle);\n\t\treturn addr;\n\t}\n\tif (!lua_isnil(L, -1))\n\t\tdebug(\"new: vis.objects[%p] = %s (WARNING: changing object type from %s)\\n\", addr, type, old_type);\n\telse\n\t\tdebug(\"new: vis.objects[%p] = %s (creating new object)\\n\", addr, type);\n\tlua_pop(L, 1);\n\tvoid **handle = obj_new(L, sizeof(addr), type);\n\tobj_ref_set(L, addr);\n\t*handle = addr;\n\treturn addr;\n}\n\n/* (type) check validity of object reference at stack location `idx' and retrieve it */\nstatic void *obj_ref_check(lua_State *L, int idx, const char *type) {\n\tvoid **addr = luaL_checkudata(L, idx, type);\n\tif (!obj_ref_get(L, *addr, type))\n\t\tluaL_argerror(L, idx, \"invalid object reference\");\n\treturn *addr;\n}\n\nstatic void *obj_ref_check_containerof(lua_State *L, int idx, const char *type, size_t offset) {\n\tvoid *obj = obj_ref_check(L, idx, type);\n\treturn obj ? ((char*)obj-offset) : obj;\n}\n\nstatic void *obj_lightref_new(lua_State *L, void *addr, const char *type) {\n\tif (!addr)\n\t\treturn NULL;\n\tvoid **handle = obj_new(L, sizeof(addr), type);\n\t*handle = addr;\n\treturn addr;\n}\n\nstatic void *obj_lightref_check(lua_State *L, int idx, const char *type) {\n\tvoid **addr = luaL_checkudata(L, idx, type);\n\treturn *addr;\n}\n\nstatic int index_common(lua_State *L) {\n\tlua_getmetatable(L, 1);\n\tlua_pushvalue(L, 2);\n\tlua_gettable(L, -2);\n\tif (lua_isnil(L, -1)) {\n\t\tlua_getuservalue(L, 1);\n\t\tlua_pushvalue(L, 2);\n\t\tlua_gettable(L, -2);\n\t}\n\treturn 1;\n}\n\nstatic int newindex_common(lua_State *L) {\n\tlua_getuservalue(L, 1);\n\tlua_pushvalue(L, 2);\n\tlua_pushvalue(L, 3);\n\tlua_settable(L, -3);\n\treturn 0;\n}\n\nstatic size_t getpos(lua_State *L, int narg) {\n\treturn lua_tounsigned(L, narg);\n}\n\nstatic size_t checkpos(lua_State *L, int narg) {\n\tlua_Number n = luaL_checknumber(L, narg);\n\t/* on most systems SIZE_MAX can't be represented in lua_Number.\n\t * using < avoids undefined behaviour when n == SIZE_MAX+1\n\t * which can be represented in lua_Number\n\t */\n\tif (n >= 0 && n < (lua_Number)SIZE_MAX && n == (size_t)n)\n\t\treturn n;\n\treturn luaL_argerror(L, narg, \"expected position, got number\");\n}\n\nstatic void pushpos(lua_State *L, size_t pos) {\n\tif (pos == EPOS)\n\t\tlua_pushnil(L);\n\telse\n\t\tlua_pushunsigned(L, pos);\n}\n\nstatic void pushrange(lua_State *L, Filerange *r) {\n\tif (!r || !text_range_valid(r)) {\n\t\tlua_pushnil(L);\n\t\treturn;\n\t}\n\tlua_createtable(L, 0, 2);\n\tlua_pushstring(L, \"start\");\n\tlua_pushunsigned(L, r->start);\n\tlua_settable(L, -3);\n\tlua_pushstring(L, \"finish\");\n\tlua_pushunsigned(L, r->end);\n\tlua_settable(L, -3);\n}\n\nstatic Filerange getrange(lua_State *L, int index) {\n\tFilerange range = text_range_empty();\n\tif (lua_istable(L, index)) {\n\t\tlua_getfield(L, index, \"start\");\n\t\trange.start = checkpos(L, -1);\n\t\tlua_pop(L, 1);\n\t\tlua_getfield(L, index, \"finish\");\n\t\trange.end = checkpos(L, -1);\n\t\tlua_pop(L, 1);\n\t} else {\n\t\trange.start = checkpos(L, index);\n\t\trange.end = range.start + checkpos(L, index+1);\n\t}\n\treturn range;\n}\n\nstatic const char *keymapping(Vis *vis, const char *keys, const Arg *arg) {\n\tlua_State *L = vis->lua;\n\tif (!func_ref_get(L, arg->v))\n\t\treturn keys;\n\tlua_pushstring(L, keys);\n\tif (pcall(vis, L, 1, 1) != 0)\n\t\treturn keys;\n\tif (lua_type(L, -1) != LUA_TNUMBER)\n\t\treturn keys; /* invalid or no return value, assume zero */\n\tlua_Number number = lua_tonumber(L, -1);\n\tlua_Integer integer = lua_tointeger(L, -1);\n\tif (number != integer)\n\t\treturn keys;\n\tif (integer < 0)\n\t\treturn NULL; /* need more input */\n\tsize_t len = integer;\n\tsize_t max = strlen(keys);\n\treturn (len <= max) ? keys+len : keys;\n}\n\n/***\n * The main editor object.\n * @type Vis\n */\n\n/***\n * Version information.\n * @tfield string VERSION\n * version information in `git describe` format, same as reported by `vis -v`.\n */\n/***\n * Lua API object types\n * @field types meta tables of userdata objects used for type checking\n * @local\n */\n/***\n * User interface.\n * @tfield Ui ui the user interface being used\n */\n/***\n * Mode constants.\n * @tfield modes modes\n */\n/***\n * Events.\n * @tfield events events\n */\n/***\n * Registers.\n * @field registers array to access the register by single letter name\n */\n/***\n * Scintillua lexer module.\n * @field lexers might be `nil` if module is not found\n */\n/***\n * LPeg lexer module.\n * @field lpeg might be `nil` if module is not found\n */\n/***\n * Current count.\n * @tfield int count the specified count for the current command or `nil` if none was given\n */\n\n/***\n * Create an iterator over all windows.\n * @function windows\n * @return the new iterator\n * @see win\n * @usage\n * for win in vis:windows() do\n * \t-- do something with win\n * end\n */\nstatic int windows_iter(lua_State *L);\nstatic int windows(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tWin **handle = lua_newuserdata(L, sizeof *handle), *next;\n\tfor (next = vis->windows; next && next->file->internal; next = next->next);\n\t*handle = next;\n\tlua_pushcclosure(L, windows_iter, 1);\n\treturn 1;\n}\n\nstatic int windows_iter(lua_State *L) {\n\tWin **handle = lua_touserdata(L, lua_upvalueindex(1));\n\tif (!*handle)\n\t\treturn 0;\n\tWin *win = obj_ref_new(L, *handle, VIS_LUA_TYPE_WINDOW), *next;\n\tif (win) {\n\t\tfor (next = win->next; next && next->file->internal; next = next->next);\n\t\t*handle = next;\n\t}\n\treturn 1;\n}\n\n/***\n * Create an iterator over all files.\n * @function files\n * @return the new iterator\n * @usage\n * for file in vis:files() do\n * \t-- do something with file\n * end\n */\nstatic int files_iter(lua_State *L);\nstatic int files(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tFile **handle = lua_newuserdata(L, sizeof *handle);\n\t*handle = vis->files;\n\tlua_pushcclosure(L, files_iter, 1);\n\treturn 1;\n}\n\nstatic int files_iter(lua_State *L) {\n\tFile **handle = lua_touserdata(L, lua_upvalueindex(1));\n\tif (!*handle)\n\t\treturn 0;\n\tFile *file = obj_ref_new(L, *handle, VIS_LUA_TYPE_FILE);\n\tif (file)\n\t\t*handle = file->next;\n\treturn 1;\n}\n\n/***\n * Create an iterator over all mark names.\n * @function mark_names\n * @return the new iterator\n * @usage\n * local marks = vis.win.marks\n * for name in vis:mark_names() do\n * \tlocal mark = marks[name]\n * \tfor i = 1, #mark do\n * \t\t-- do something with: name, mark[i].start, mark[i].finish\n * \tend\n * end\n */\nstatic int mark_names_iter(lua_State *L);\nstatic int mark_names(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tlua_pushlightuserdata(L, vis);\n\tenum VisMark *handle = lua_newuserdata(L, sizeof *handle);\n\t*handle = 0;\n\tlua_pushcclosure(L, mark_names_iter, 2);\n\treturn 1;\n}\n\nstatic int mark_names_iter(lua_State *L) {\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tenum VisMark *handle = lua_touserdata(L, lua_upvalueindex(2));\n\tchar mark = vis_mark_to(vis, *handle);\n\tif (mark) {\n\t\tlua_pushlstring(L, &mark, 1);\n\t\t(*handle)++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/***\n * Create an iterator over all register names.\n * @function register_names\n * @return the new iterator\n * @usage\n * for name in vis:register_names() do\n * \tlocal reg = vis.registers[name]\n * \tfor i = 1, #reg do\n * \t\t-- do something with register value reg[i]\n * \tend\n * end\n */\nstatic int register_names_iter(lua_State *L);\nstatic int register_names(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tlua_pushlightuserdata(L, vis);\n\tenum VisRegister *handle = lua_newuserdata(L, sizeof *handle);\n\t*handle = 0;\n\tlua_pushcclosure(L, register_names_iter, 2);\n\treturn 1;\n}\n\nstatic int register_names_iter(lua_State *L) {\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tenum VisRegister *handle = lua_touserdata(L, lua_upvalueindex(2));\n\tchar reg = vis_register_to(vis, *handle);\n\tif (reg) {\n\t\tlua_pushlstring(L, &reg, 1);\n\t\t(*handle)++;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/***\n * Execute a `:`-command.\n * @function command\n * @tparam string command the command to execute\n * @treturn bool whether the command succeeded\n * @usage\n * vis:command(\"set number\")\n */\nstatic int command(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *cmd = luaL_checkstring(L, 2);\n\tbool ret = vis_cmd(vis, cmd);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\n/***\n * Display a short message.\n *\n * The single line message will be displayed at the bottom of\n * the screen and automatically hidden once a key is pressed.\n *\n * @function info\n * @tparam string message the message to display\n */\nstatic int info(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *msg = luaL_checkstring(L, 2);\n\tvis_info_show(vis, \"%s\", msg);\n\treturn 0;\n}\n\n/***\n * Display a multi line message.\n *\n * Opens a new window and displays an arbitrarily long message.\n *\n * @function message\n * @tparam string message the message to display\n */\nstatic int message(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *msg = luaL_checkstring(L, 2);\n\tvis_message_show(vis, msg);\n\treturn 0;\n}\n\n/***\n * Register a Lua function as key action.\n * @function action_register\n * @tparam string name the name of the action, can be referred to in key bindings as `<name>` pseudo key\n * @tparam Function func the lua function implementing the key action (see @{keyhandler})\n * @tparam[opt] string help the single line help text as displayed in `:help`\n * @treturn KeyAction action the registered key action\n * @see Vis:map\n * @see Window:map\n */\nstatic int action_register(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *name = luaL_checkstring(L, 2);\n\tconst void *func = func_ref_new(L, 3);\n\tconst char *help = luaL_optstring(L, 4, NULL);\n\tKeyAction *action = vis_action_new(vis, name, help, keymapping, (Arg){ .v = func });\n\tif (!action)\n\t\tgoto err;\n\tif (!vis_action_register(vis, action))\n\t\tgoto err;\n\tobj_ref_new(L, action, VIS_LUA_TYPE_KEYACTION);\n\treturn 1;\nerr:\n\tvis_action_free(vis, action);\n\tlua_pushnil(L);\n\treturn 1;\n}\n\nstatic int keymap(lua_State *L, Vis *vis, Win *win) {\n\tint mode = luaL_checkint(L, 2);\n\tconst char *key = luaL_checkstring(L, 3);\n\tconst char *help = luaL_optstring(L, 5, NULL);\n\tKeyBinding *binding = vis_binding_new(vis);\n\tif (!binding)\n\t\tgoto err;\n\tif (lua_isstring(L, 4)) {\n\t\tconst char *alias = luaL_checkstring(L, 4);\n\t\tif (!(binding->alias = strdup(alias)))\n\t\t\tgoto err;\n\t} else if (lua_isfunction(L, 4)) {\n\t\tconst void *func = func_ref_new(L, 4);\n\t\tif (!(binding->action = vis_action_new(vis, NULL, help, keymapping, (Arg){ .v = func })))\n\t\t\tgoto err;\n\t} else if (lua_isuserdata(L, 4)) {\n\t\tbinding->action = obj_ref_check(L, 4, VIS_LUA_TYPE_KEYACTION);\n\t} else {\n\t\tgoto err;\n\t}\n\n\tif (win) {\n\t\tif (!vis_window_mode_map(win, mode, true, key, binding))\n\t\t\tgoto err;\n\t} else {\n\t\tif (!vis_mode_map(vis, mode, true, key, binding))\n\t\t\tgoto err;\n\t}\n\n\tlua_pushboolean(L, true);\n\treturn 1;\nerr:\n\tvis_binding_free(vis, binding);\n\tlua_pushboolean(L, false);\n\treturn 1;\n}\n\n/***\n * Map a key to a Lua function.\n *\n * Creates a new key mapping in a given mode.\n *\n * @function map\n * @tparam int mode the mode to which the mapping should be added\n * @tparam string key the key to map\n * @tparam function func the Lua function to handle the key mapping (see @{keyhandler})\n * @tparam[opt] string help the single line help text as displayed in `:help`\n * @treturn bool whether the mapping was successfully established\n * @see Window:map\n * @usage\n * vis:map(vis.modes.INSERT, \"<C-k>\", function(keys)\n * \tif #keys < 2 then\n * \t\treturn -1 -- need more input\n * \tend\n * \tlocal digraph = keys:sub(1, 2)\n * \tif digraph == \"l*\" then\n * \t\tvis:feedkeys('λ')\n * \t\treturn 2 -- consume 2 bytes of input\n * \tend\n * end, \"Insert digraph\")\n */\n/***\n * Setup a key alias.\n *\n * This is equivalent to `vis:command('map! mode key alias')`.\n *\n * Mappings are always recursive!\n * @function map\n * @tparam int mode the mode to which the mapping should be added\n * @tparam string key the key to map\n * @tparam string alias the key to map to\n * @treturn bool whether the mapping was successfully established\n * @see Window:map\n * @usage\n * vis:map(vis.modes.NORMAL, \"j\", \"k\")\n */\n/***\n * Map a key to a key action.\n *\n * @function map\n * @tparam int mode the mode to which the mapping should be added\n * @tparam string key the key to map\n * @param action the action to map\n * @treturn bool whether the mapping was successfully established\n * @see Window:map\n * @usage\n * local action = vis:action_register(\"info\", function()\n *   vis:info(\"Mapping works!\")\n * end, \"Info message help text\")\n * vis:map(vis.modes.NORMAL, \"gh\", action)\n * vis:map(vis.modes.NORMAL, \"gl\", action)\n */\nstatic int map(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\treturn keymap(L, vis, NULL);\n}\n\n/***\n * Unmap a global key binding.\n *\n * @function unmap\n * @tparam int mode the mode from which the mapping should be removed\n * @tparam string key the mapping to remove\n * @treturn bool whether the mapping was successfully removed\n * @see Window:unmap\n */\nstatic int keyunmap(lua_State *L, Vis *vis, Win *win) {\n\tenum VisMode mode = luaL_checkint(L, 2);\n\tconst char *key = luaL_checkstring(L, 3);\n\tbool ret;\n\tif (!win)\n\t\tret = vis_mode_unmap(vis, mode, key);\n\telse\n\t\tret = vis_window_mode_unmap(win, mode, key);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\nstatic int unmap(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\treturn keyunmap(L, vis, NULL);\n}\n\n/***\n * Get all currently active mappings of a mode.\n *\n * @function mappings\n * @tparam int mode the mode to query\n * @treturn table the active mappings and their associated help texts\n * @usage\n * local bindings = vis:mappings(vis.modes.NORMAL)\n * for key, help in pairs(bindings) do\n * \t-- do something\n * end\n * @see Vis:map\n */\nstatic bool binding_collect(const char *key, void *value, void *ctx) {\n\tlua_State *L = ctx;\n\tKeyBinding *binding = value;\n\tlua_getfield(L, -1, key);\n\tbool new = lua_isnil(L, -1);\n\tlua_pop(L, 1);\n\tif (new) {\n\t\tconst char *help = binding->alias ? binding->alias : VIS_HELP_USE(binding->action->help);\n\t\tlua_pushstring(L, help ? help : \"\");\n\t\tlua_setfield(L, -2, key);\n\t}\n\treturn true;\n}\n\nstatic int mappings(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tlua_newtable(L);\n\tfor (Mode *mode = mode_get(vis, luaL_checkint(L, 2)); mode; mode = mode->parent) {\n\t\tif (!mode->bindings)\n\t\t\tcontinue;\n\t\tmap_iterate(mode->bindings, binding_collect, vis->lua);\n\t}\n\treturn 1;\n}\n\n/***\n * Execute a motion.\n *\n * @function motion\n * @tparam int id the id of the motion to execute\n * @treturn bool whether the id was valid\n * @local\n */\nstatic int motion(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tenum VisMotion id = luaL_checkunsigned(L, 2);\n\t// TODO handle var args?\n\tlua_pushboolean(L, vis && vis_motion(vis, id));\n\treturn 1;\n}\n\nstatic size_t motion_lua(Vis *vis, Win *win, void *data, size_t pos) {\n\tlua_State *L = vis->lua;\n\tif (!L || !func_ref_get(L, data) || !obj_ref_new(L, win, VIS_LUA_TYPE_WINDOW))\n\t\treturn EPOS;\n\n\tlua_pushunsigned(L, pos);\n\tif (pcall(vis, L, 2, 1) != 0)\n\t\treturn EPOS;\n\treturn getpos(L, -1);\n}\n\n/***\n * Register a custom motion.\n *\n * @function motion_register\n * @tparam function motion the Lua function implementing the motion\n * @treturn int the associated motion id, or `-1` on failure\n * @see motion, motion_new\n * @local\n * @usage\n * -- custom motion advancing to the next byte\n * local id = vis:motion_register(function(win, pos)\n * \treturn pos+1\n * end)\n */\nstatic int motion_register(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst void *func = func_ref_new(L, 2);\n\tint id = vis_motion_register(vis, (void*)func, motion_lua);\n\tlua_pushinteger(L, id);\n\treturn 1;\n}\n\n/***\n * Execute an operator.\n *\n * @function operator\n * @tparam int id the id of the operator to execute\n * @treturn bool whether the id was valid\n * @local\n */\nstatic int operator(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tenum VisOperator id = luaL_checkunsigned(L, 2);\n\t// TODO handle var args?\n\tlua_pushboolean(L, vis && vis_operator(vis, id));\n\treturn 1;\n}\n\nstatic size_t operator_lua(Vis *vis, Text *text, OperatorContext *c) {\n\tlua_State *L = vis->lua;\n\tif (!L || !func_ref_get(L, c->context))\n\t\treturn EPOS;\n\tFile *file = vis->files;\n\twhile (file && (file->internal || file->text != text))\n\t\tfile = file->next;\n\tif (!file || !obj_ref_new(L, file, VIS_LUA_TYPE_FILE))\n\t\treturn EPOS;\n\tpushrange(L, &c->range);\n\tpushpos(L, c->pos);\n\tif (pcall(vis, L, 3, 1) != 0)\n\t\treturn EPOS;\n\treturn getpos(L, -1);\n}\n\n/***\n * Register a custom operator.\n *\n * @function operator_register\n * @tparam function operator the Lua function implementing the operator\n * @treturn int the associated operator id, or `-1` on failure\n * @see operator, operator_new\n * @local\n * @usage\n * -- custom operator replacing every 'a' with 'b'\n * local id = vis:operator_register(function(file, range, pos)\n * \tlocal data = file:content(range)\n * \tdata = data:gsub(\"a\", \"b\")\n * \tfile:delete(range)\n * \tfile:insert(range.start, data)\n * \treturn range.start -- new cursor location\n * end)\n */\nstatic int operator_register(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst void *func = func_ref_new(L, 2);\n\tint id = vis_operator_register(vis, operator_lua, (void*)func);\n\tlua_pushinteger(L, id);\n\treturn 1;\n}\n\n/***\n * Execute a text object.\n *\n * @function textobject\n * @tparam int id the id of the text object to execute\n * @treturn bool whether the id was valid\n * @see textobject_register, textobject_new\n * @local\n */\nstatic int textobject(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tenum VisTextObject id = luaL_checkunsigned(L, 2);\n\tlua_pushboolean(L, vis_textobject(vis, id));\n\treturn 1;\n}\n\nstatic Filerange textobject_lua(Vis *vis, Win *win, void *data, size_t pos) {\n\tlua_State *L = vis->lua;\n\tif (!L || !func_ref_get(L, data) || !obj_ref_new(L, win, VIS_LUA_TYPE_WINDOW))\n\t\treturn text_range_empty();\n\tlua_pushunsigned(L, pos);\n\tif (pcall(vis, L, 2, 2) != 0 || lua_isnil(L, -1))\n\t\treturn text_range_empty();\n\treturn text_range_new(getpos(L, -2), getpos(L, -1));\n}\n\n/***\n * Register a custom text object.\n *\n * @function textobject_register\n * @tparam function textobject the Lua function implementing the text object\n * @treturn int the associated text object id, or `-1` on failure\n * @see textobject, textobject_new\n * @local\n * @usage\n * -- custom text object covering the next byte\n * local id = vis:textobject_register(function(win, pos)\n * \treturn pos, pos+1\n * end)\n */\nstatic int textobject_register(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst void *func = func_ref_new(L, 2);\n\tint id = vis_textobject_register(vis, 0, (void*)func, textobject_lua);\n\tlua_pushinteger(L, id);\n\treturn 1;\n}\n\nstatic bool option_lua(Vis *vis, Win *win, void *context, bool toggle,\n                       enum VisOption flags, const char *name, Arg *value) {\n\tlua_State *L = vis->lua;\n\tif (!L || !func_ref_get(L, context))\n\t\treturn false;\n\tif (flags & VIS_OPTION_TYPE_BOOL)\n\t\tlua_pushboolean(L, value->b);\n\telse if (flags & VIS_OPTION_TYPE_STRING)\n\t\tlua_pushstring(L, value->s);\n\telse if (flags & VIS_OPTION_TYPE_NUMBER)\n\t\tlua_pushnumber(L, value->i);\n\telse\n\t\treturn false;\n\tlua_pushboolean(L, toggle);\n\treturn pcall(vis, L, 2, 2) == 0 && (!lua_isboolean(L, -1) || lua_toboolean(L, -1));\n}\n\n/***\n * Register a custom `:set` option.\n *\n * @function option_register\n * @tparam string name the option name\n * @tparam string type the option type (`bool`, `string` or `number`)\n * @tparam function handler the Lua function being called when the option is changed\n * @tparam[opt] string help the single line help text as displayed in `:help`\n * @treturn bool whether the option was successfully registered\n * @usage\n * vis:option_register(\"foo\", \"bool\", function(value, toggle)\n * \tif not vis.win then return false end\n * \tvis.win.foo = toggle and not vis.win.foo or value\n * \tvis:info(\"Option foo = \" .. tostring(vis.win.foo))\n * \treturn true\n * end, \"Foo enables superpowers\")\n */\nstatic int option_register(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *name = luaL_checkstring(L, 2);\n\tconst char *type = luaL_checkstring(L, 3);\n\tconst void *func = func_ref_new(L, 4);\n\tconst char *help = luaL_optstring(L, 5, NULL);\n\tconst char *names[] = { name, NULL };\n\tenum VisOption flags = 0;\n\tif (strcmp(type, \"string\") == 0)\n\t\tflags |= VIS_OPTION_TYPE_STRING;\n\telse if (strcmp(type, \"number\") == 0)\n\t\tflags |= VIS_OPTION_TYPE_NUMBER;\n\telse\n\t\tflags |= VIS_OPTION_TYPE_BOOL;\n\tbool ret = vis_option_register(vis, names, flags, option_lua, (void*)func, help);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\n/***\n * Unregister a `:set` option.\n *\n * @function option_unregister\n * @tparam string name the option name\n * @treturn bool whether the option was successfully unregistered\n */\nstatic int option_unregister(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *name = luaL_checkstring(L, 2);\n\tbool ret = vis_option_unregister(vis, name);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\nstatic bool command_lua(Vis *vis, Win *win, void *data, bool force, const char *argv[], Selection *sel, Filerange *range) {\n\tlua_State *L = vis->lua;\n\tif (!L || !func_ref_get(L, data))\n\t\treturn false;\n\tlua_newtable(L);\n\tfor (size_t i = 0; argv[i]; i++) {\n\t\tlua_pushunsigned(L, i);\n\t\tlua_pushstring(L, argv[i]);\n\t\tlua_settable(L, -3);\n\t}\n\tlua_pushboolean(L, force);\n\tif (!obj_ref_new(L, win, VIS_LUA_TYPE_WINDOW))\n\t\treturn false;\n\tif (!sel)\n\t\tsel = view_selections_primary_get(&win->view);\n\tif (!obj_lightref_new(L, sel, VIS_LUA_TYPE_SELECTION))\n\t\treturn false;\n\tpushrange(L, range);\n\tif (pcall(vis, L, 5, 1) != 0)\n\t\treturn false;\n\treturn lua_toboolean(L, -1);\n}\n\n/***\n * Register a custom `:`-command.\n *\n * @function command_register\n * @tparam string name the command name\n * @tparam function command the Lua function implementing the command\n * @tparam[opt] string help the single line help text as displayed in `:help`\n * @treturn bool whether the command has been successfully registered\n * @usage\n * vis:command_register(\"foo\", function(argv, force, win, selection, range)\n * \t for i,arg in ipairs(argv) do\n * \t\t print(i..\": \"..arg)\n * \t end\n * \t print(\"was command forced with ! \"..(force and \"yes\" or \"no\"))\n * \t print(win.file.name)\n * \t print(selection.pos)\n * \t print(range ~= nil and ('['..range.start..', '..range.finish..']') or \"invalid range\")\n * \t return true;\n * end)\n */\nstatic int command_register(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *name = luaL_checkstring(L, 2);\n\tconst void *func = func_ref_new(L, 3);\n\tconst char *help = luaL_optstring(L, 4, \"\");\n\tbool ret = vis_cmd_register(vis, name, help, (void*)func, command_lua);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\n/***\n * Push keys to input queue and interpret them.\n *\n * The keys are processed as if they were read from the keyboard.\n *\n * @function feedkeys\n * @tparam string keys the keys to interpret\n */\nstatic int feedkeys(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *keys = luaL_checkstring(L, 2);\n\tvis_keys_feed(vis, keys);\n\treturn 0;\n}\n\n/***\n * Insert keys at all cursor positions of active window.\n *\n * This function behaves as if the keys were entered in insert mode,\n * but in contrast to @{Vis:feedkeys} it bypasses the input queue,\n * meaning mappings do not apply and the keys will not be recorded in macros.\n *\n * @function insert\n * @tparam string keys the keys to insert\n * @see Vis:feedkeys\n */\nstatic int insert(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tsize_t len;\n\tconst char *keys = luaL_checklstring(L, 2, &len);\n\tvis_insert_key(vis, keys, len);\n\treturn 0;\n}\n\n/***\n * Replace keys at all cursor positions of active window.\n *\n * This function behaves as if the keys were entered in replace mode,\n * but in contrast to @{Vis:feedkeys} it bypasses the input queue,\n * meaning mappings do not apply and the keys will not be recorded in macros.\n *\n * @function replace\n * @tparam string keys the keys to insert\n * @see Vis:feedkeys\n */\nstatic int replace(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tsize_t len;\n\tconst char *keys = luaL_checklstring(L, 2, &len);\n\tvis_replace_key(vis, keys, len);\n\treturn 0;\n}\n\n/***\n * Terminate editor process.\n *\n * Termination happens upon the next iteration of the main event loop.\n * This means the calling Lua code will be executed further until it\n * eventually hands over control to the editor core. The exit status\n * of the most recent call is used.\n *\n * All unsaved changes will be lost!\n *\n * @function exit\n * @tparam int code the exit status returned to the operating system\n */\nstatic int exit_func(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tint code = luaL_checkint(L, 2);\n\tvis_exit(vis, code);\n\treturn 0;\n}\n\n/***\n * Pipe file range to external process and collect output.\n *\n * The editor core will be blocked while the external process is running.\n * File and Range can be omitted or nil to indicate empty input.\n *\n * @function pipe\n * @tparam[opt] File file the file to which the range applies\n * @tparam[opt] Range range the range to pipe\n * @tparam string command the command to execute\n * @tparam[opt] bool fullscreen whether command is a fullscreen program (e.g. curses based)\n * @treturn int code the exit status of the executed command\n * @treturn string stdout the data written to stdout\n * @treturn string stderr the data written to stderr\n */\n/***\n * Pipe a string to external process and collect output.\n *\n * The editor core will be blocked while the external process is running.\n *\n * @function pipe\n * @tparam string text the text written to the external command\n * @tparam string command the command to execute\n * @tparam[opt] bool fullscreen whether command is a fullscreen program (e.g. curses based)\n * @treturn int code the exit status of the executed command\n * @treturn string stdout the data written to stdout\n * @treturn string stderr the data written to stderr\n */\nstatic int pipe_func(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tint cmd_idx = 4;\n\tchar *out = NULL, *err = NULL;\n\tconst char *text = NULL;\n\tFile *file = vis->win ? vis->win->file : NULL;\n\tFilerange range = text_range_new(0, 0);\n\tif (lua_gettop(L) == 2) { // vis:pipe(cmd)\n\t\tcmd_idx = 2;\n\t} else if (lua_gettop(L) == 3) {\n\t\tif (lua_isboolean(L, 3)) { // vis:pipe(cmd, fullscreen)\n\t\t\tcmd_idx = 2;\n\t\t} else { // vis:pipe(text, cmd)\n\t\t\ttext = luaL_checkstring(L, 2);\n\t\t\tcmd_idx = 3;\n\t\t}\n\t} else if (lua_isboolean(L, 4)) { // vis:pipe(text, cmd, fullscreen)\n\t\ttext = luaL_checkstring(L, 2);\n\t\tcmd_idx = 3;\n\t} else if (!(lua_isnil(L, 2) && lua_isnil(L, 3))) { // vis:pipe(file, range, cmd, [fullscreen])\n\t\tfile = obj_ref_check(L, 2, VIS_LUA_TYPE_FILE);\n\t\trange = getrange(L, 3);\n\t}\n\tconst char *cmd = luaL_checkstring(L, cmd_idx);\n\tbool fullscreen = lua_isboolean(L, cmd_idx + 1) && lua_toboolean(L, cmd_idx + 1);\n\n\tif (!text && !file)\n\t\treturn luaL_error(L, \"vis:pipe(cmd = '%s'): win not open, file can't be nil\", cmd);\n\n\tint status;\n\tif (text)\n\t\tstatus = vis_pipe_buf_collect(vis, text, (const char*[]){ cmd, NULL }, &out, &err, fullscreen);\n\telse\n\t\tstatus = vis_pipe_collect(vis, file, &range, (const char*[]){ cmd, NULL }, &out, &err, fullscreen);\n\tlua_pushinteger(L, status);\n\tif (out)\n\t\tlua_pushstring(L, out);\n\telse\n\t\tlua_pushnil(L);\n\tfree(out);\n\tif (err)\n\t\tlua_pushstring(L, err);\n\telse\n\t\tlua_pushnil(L);\n\tfree(err);\n\tvis_draw(vis);\n\treturn 3;\n}\n\n/***\n * Redraw complete user interface.\n *\n * Will trigger redraw events, make sure to avoid recursive events.\n *\n * @function redraw\n */\nstatic int redraw(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tvis_redraw(vis);\n\treturn 0;\n}\n/***\n * Closes a stream returned by @{Vis:communicate}.\n *\n * @function close\n * @tparam io.file inputfd the stream to be closed\n * @treturn bool identical to @{io.close}\n */\nstatic int close_subprocess(lua_State *L) {\n\tluaL_Stream *file = luaL_checkudata(L, -1, \"FILE*\");\n\tint result = fclose(file->f);\n\tif (result == 0) {\n\t\tfile->f = NULL;\n\t\tfile->closef = NULL;\n\t}\n\treturn luaL_fileresult(L, result == 0, NULL);\n}\n/***\n * Open new process and return its input stream (stdin).\n * If the stream is closed (by calling the close method or by being removed by a garbage collector)\n * the spawned process will be killed by SIGTERM.\n * When the process will quit or will output anything to stdout or stderr,\n * the @{process_response} event will be fired.\n *\n * The editor core won't be blocked while the external process is running.\n *\n * @function communicate\n * @tparam string name the name of subprocess (to distinguish processes in the @{process_response} event)\n * @tparam string command the command to execute\n * @return the file handle to write data to the process, in case of error the return values are equivalent to @{io.open} error values.\n */\nstatic int communicate_func(lua_State *L) {\n\n\ttypedef struct {\n\t\t/* Lua stream structure for the process input stream */\n\t\tluaL_Stream stream;\n\t\tProcess *handler;\n\t} ProcessStream;\n\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tconst char *name = luaL_checkstring(L, 2);\n\tconst char *cmd = luaL_checkstring(L, 3);\n\tProcessStream *inputfd = (ProcessStream *)lua_newuserdata(L, sizeof(ProcessStream));\n\tluaL_setmetatable(L, LUA_FILEHANDLE);\n\tinputfd->handler = vis_process_communicate(vis, name, cmd, &(inputfd->stream.closef));\n\tif (inputfd->handler) {\n\t\tinputfd->stream.f = fdopen(inputfd->handler->inpfd, \"w\");\n\t\tinputfd->stream.closef = &close_subprocess;\n\t}\n\treturn inputfd->stream.f ? 1 : luaL_fileresult(L, 0, name);\n}\n/***\n * Currently active window.\n * @tfield Window win\n * @see windows\n */\n/***\n * Currently active mode.\n * @tfield modes mode\n */\n/***\n * Whether a macro is being recorded.\n * @tfield bool recording\n */\n/***\n * Currently unconsumed keys in the input queue.\n * @tfield string input_queue\n */\n/***\n * Register name in use.\n * @tfield string register\n */\n/***\n * Mark name in use.\n * @tfield string mark\n */\nstatic int vis_index(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"win\") == 0) {\n\t\t\tif (vis->win)\n\t\t\t\tobj_ref_new(L, vis->win, VIS_LUA_TYPE_WINDOW);\n\t\t\telse\n\t\t\t\tlua_pushnil(L);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"mode\") == 0) {\n\t\t\tlua_pushunsigned(L, vis->mode->id);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"input_queue\") == 0) {\n\t\t\tlua_pushstring(L, buffer_content0(&vis->input_queue));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"recording\") == 0) {\n\t\t\tlua_pushboolean(L, vis_macro_recording(vis));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"count\") == 0) {\n\t\t\tint count = vis->action.count;\n\t\t\tif (count == VIS_COUNT_UNKNOWN)\n\t\t\t\tlua_pushnil(L);\n\t\t\telse\n\t\t\t\tlua_pushunsigned(L, count);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"register\") == 0) {\n\t\t\tchar name = vis_register_to(vis, vis_register_used(vis));\n\t\t\tlua_pushlstring(L, &name, 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"registers\") == 0) {\n\t\t\tobj_ref_new(L, &vis->ui, VIS_LUA_TYPE_REGISTERS);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"mark\") == 0) {\n\t\t\tchar name = vis_mark_to(vis, vis_mark_used(vis));\n\t\t\tlua_pushlstring(L, &name, 1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"options\") == 0) {\n\t\t\tobj_ref_new(L, &vis->options, VIS_LUA_TYPE_VIS_OPTS);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"ui\") == 0) {\n\t\t\tobj_ref_new(L, &vis->ui, VIS_LUA_TYPE_UI);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn index_common(L);\n}\n\nstatic int vis_options_assign(Vis *vis, lua_State *L, const char *key, int next) {\n\tif (strcmp(key, \"autoindent\") == 0 || strcmp(key, \"ai\") == 0) {\n\t\tvis->autoindent = lua_toboolean(L, next);\n\t} else if (strcmp(key, \"changecolors\") == 0) {\n\t\tvis->change_colors = lua_toboolean(L, next);\n\t} else if (strcmp(key, \"escdelay\") == 0) {\n\t\ttermkey_set_waittime(vis->ui.termkey, luaL_checkint(L, next));\n\t} else if (strcmp(key, \"ignorecase\") == 0 || strcmp(key, \"ic\") == 0) {\n\t\tvis->ignorecase = lua_toboolean(L, next);\n\t} else if (strcmp(key, \"loadmethod\") == 0) {\n\t\tif (!lua_isstring(L, next))\n\t\t\treturn newindex_common(L);\n\t\tconst char *lm = lua_tostring(L, next);\n\t\tif (strcmp(lm, \"auto\") == 0)\n\t\t\tvis->load_method = TEXT_LOAD_AUTO;\n\t\telse if (strcmp(lm, \"read\") == 0)\n\t\t\tvis->load_method = TEXT_LOAD_READ;\n\t\telse if (strcmp(lm, \"mmap\") == 0)\n\t\t\tvis->load_method = TEXT_LOAD_MMAP;\n\t} else if (strcmp(key, \"shell\") == 0) {\n\t\tif (!lua_isstring(L, next))\n\t\t\treturn newindex_common(L);\n\t\tvis_shell_set(vis, lua_tostring(L, next));\n\t}\n\treturn 0;\n}\n\nstatic int vis_newindex(lua_State *L) {\n\tVis *vis = obj_ref_check(L, 1, \"vis\");\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"mode\") == 0) {\n\t\t\tenum VisMode mode = luaL_checkunsigned(L, 3);\n\t\t\tvis_mode_switch(vis, mode);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"count\") == 0) {\n\t\t\tint count;\n\t\t\tif (lua_isnil(L, 3))\n\t\t\t\tcount = VIS_COUNT_UNKNOWN;\n\t\t\telse\n\t\t\t\tcount = luaL_checkunsigned(L, 3);\n\t\t\tvis->action.count = count;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"win\") == 0) {\n\t\t\tvis_window_focus(obj_ref_check(L, 3, VIS_LUA_TYPE_WINDOW));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"register\") == 0) {\n\t\t\tconst char *name = luaL_checkstring(L, 3);\n\t\t\tif (strlen(name) == 1)\n\t\t\t\tvis_register(vis, vis_register_from(vis, name[0]));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"mark\") == 0) {\n\t\t\tconst char *name = luaL_checkstring(L, 3);\n\t\t\tif (strlen(name) == 1)\n\t\t\t\tvis_mark(vis, vis_mark_from(vis, name[0]));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"options\") == 0 && lua_istable(L, 3)) {\n\t\t\tint ret = 0;\n\t\t\t/* since we don't know which keys are in the table we push\n\t\t\t * a nil then use lua_next() to remove it and push the\n\t\t\t * table's key-value pairs to the stack. these can then be\n\t\t\t * used to assign options\n\t\t\t */\n\t\t\tlua_pushnil(L);\n\t\t\twhile (lua_next(L, 3)) {\n\t\t\t\tif (lua_isstring(L, 4))\n\t\t\t\t\tret += vis_options_assign(vis, L, lua_tostring(L, 4), 5);\n\t\t\t\telse\n\t\t\t\t\tret += newindex_common(L);\n\t\t\t\tlua_pop(L, 1);\n\t\t\t}\n\t\t\tlua_pop(L, 1);\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn newindex_common(L);\n}\n\nstatic const struct luaL_Reg vis_lua[] = {\n\t{ \"files\", files },\n\t{ \"windows\", windows },\n\t{ \"mark_names\", mark_names },\n\t{ \"register_names\", register_names },\n\t{ \"command\", command },\n\t{ \"info\", info },\n\t{ \"message\", message },\n\t{ \"map\", map },\n\t{ \"unmap\", unmap },\n\t{ \"mappings\", mappings },\n\t{ \"operator\", operator },\n\t{ \"operator_register\", operator_register },\n\t{ \"motion\", motion },\n\t{ \"motion_register\", motion_register },\n\t{ \"textobject\", textobject },\n\t{ \"textobject_register\", textobject_register },\n\t{ \"option_register\", option_register },\n\t{ \"option_unregister\", option_unregister },\n\t{ \"command_register\", command_register },\n\t{ \"feedkeys\", feedkeys },\n\t{ \"insert\", insert },\n\t{ \"replace\", replace },\n\t{ \"action_register\", action_register },\n\t{ \"exit\", exit_func },\n\t{ \"pipe\", pipe_func },\n\t{ \"redraw\", redraw },\n\t{ \"communicate\", communicate_func },\n\t{ \"__index\", vis_index },\n\t{ \"__newindex\", vis_newindex },\n\t{ NULL, NULL },\n};\n\n/***\n * Vis Options\n * @table options\n * @tfield[opt=false] boolean autoindent {ai}\n * @tfield[opt=false] boolean changecolors\n * @tfield[opt=50] int escdelay\n * @tfield[opt=false] boolean ignorecase {ic}\n * @tfield[opt=\"auto\"] string loadmethod `\"auto\"`, `\"read\"`, or `\"mmap\"`.\n * @tfield[opt=\"/bin/sh\"] string shell\n * @see Window.options\n */\n\nstatic int vis_options_index(lua_State *L) {\n\tVis *vis = obj_ref_check_containerof(L, 1, VIS_LUA_TYPE_VIS_OPTS, offsetof(Vis, options));\n\tif (!vis)\n\t\treturn -1;\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"autoindent\") == 0 || strcmp(key, \"ai\") == 0) {\n\t\t\tlua_pushboolean(L, vis->autoindent);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"changecolors\") == 0) {\n\t\t\tlua_pushboolean(L, vis->change_colors);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"escdelay\") == 0) {\n\t\t\tlua_pushunsigned(L, termkey_get_waittime(vis->ui.termkey));\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"ignorecase\") == 0 || strcmp(key, \"ic\") == 0) {\n\t\t\tlua_pushboolean(L, vis->ignorecase);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"loadmethod\") == 0) {\n\t\t\tswitch (vis->load_method) {\n\t\t\tcase TEXT_LOAD_AUTO:\n\t\t\t\tlua_pushstring(L, \"auto\");\n\t\t\t\tbreak;\n\t\t\tcase TEXT_LOAD_READ:\n\t\t\t\tlua_pushstring(L, \"read\");\n\t\t\t\tbreak;\n\t\t\tcase TEXT_LOAD_MMAP:\n\t\t\t\tlua_pushstring(L, \"mmap\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"shell\") == 0) {\n\t\t\tlua_pushstring(L, vis->shell);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn index_common(L);\n}\n\nstatic int vis_options_newindex(lua_State *L) {\n\tVis *vis = obj_ref_check_containerof(L, 1, VIS_LUA_TYPE_VIS_OPTS, offsetof(Vis, options));\n\tif (!vis)\n\t\treturn 0;\n\tif (lua_isstring(L, 2))\n\t\treturn vis_options_assign(vis, L, lua_tostring(L, 2), 3);\n\treturn newindex_common(L);\n}\n\nstatic const struct luaL_Reg vis_option_funcs[] = {\n\t{ \"__index\", vis_options_index },\n\t{ \"__newindex\", vis_options_newindex},\n\t{ NULL, NULL },\n};\n\n/***\n * The user interface.\n *\n * @type Ui\n */\n/***\n * Number of available colors.\n * @tfield int colors\n */\n/***\n * Current layout.\n * @tfield layouts layout current window layout.\n */\n\nstatic int ui_index(lua_State *L) {\n\tUi *ui = obj_ref_check(L, 1,  VIS_LUA_TYPE_UI);\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key  = lua_tostring(L, 2);\n\n\t\tif (strcmp(key, \"layout\") == 0) {\n\t\t\tlua_pushunsigned(L, ui->layout);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn index_common(L);\n}\n\nstatic int ui_newindex(lua_State *L) {\n\tUi *ui = obj_ref_check(L, 1,  VIS_LUA_TYPE_UI);\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key  = lua_tostring(L, 2);\n\n\t\tif (strcmp(key, \"layout\") == 0) {\n\t\t\tui_arrange(ui, luaL_checkint(L, 3));\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn newindex_common(L);\n}\n\nstatic const struct luaL_Reg ui_funcs[] = {\n\t{ \"__index\", ui_index },\n\t{ \"__newindex\", ui_newindex },\n\t{ NULL, NULL },\n};\n\nstatic int registers_index(lua_State *L) {\n\tlua_newtable(L);\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tconst char *symbol = luaL_checkstring(L, 2);\n\tif (strlen(symbol) != 1)\n\t\treturn 1;\n\tenum VisRegister reg = vis_register_from(vis, symbol[0]);\n\tif (reg >= VIS_REG_INVALID)\n\t\treturn 1;\n\tArray data = vis_register_get(vis, reg);\n\tfor (size_t i = 0, len = data.len; i < len; i++) {\n\t\tTextString *string = array_get(&data, i);\n\t\tlua_pushunsigned(L, i+1);\n\t\tlua_pushlstring(L, string->data, string->len);\n\t\tlua_settable(L, -3);\n\t}\n\tarray_release(&data);\n\treturn 1;\n}\n\nstatic int registers_newindex(lua_State *L) {\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tconst char *symbol = luaL_checkstring(L, 2);\n\tif (strlen(symbol) != 1)\n\t\treturn 0;\n\tenum VisRegister reg = vis_register_from(vis, symbol[0]);\n\tArray data;\n\tarray_init_sized(&data, sizeof(TextString));\n\n\tif (lua_istable(L, 3)) {\n\t\tlua_pushnil(L);\n\t\twhile (lua_next(L, 3)) {\n\t\t\tTextString string;\n\t\t\tstring.data = luaL_checklstring(L, -1, &string.len);\n\t\t\tarray_add(&data, &string);\n\t\t\tlua_pop(L, 1);\n\t\t}\n\t}\n\n\tvis_register_set(vis, reg, &data);\n\tarray_release(&data);\n\treturn 0;\n}\n\nstatic int registers_len(lua_State *L) {\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tlua_pushunsigned(L, LENGTH(vis->registers));\n\treturn 1;\n}\n\nstatic const struct luaL_Reg registers_funcs[] = {\n\t{ \"__index\", registers_index },\n\t{ \"__newindex\", registers_newindex },\n\t{ \"__len\", registers_len },\n\t{ NULL, NULL },\n};\n\n/***\n * A window object.\n * @type Window\n */\n\n/***\n * Viewport currently being displayed.\n * Changing these values will not move the viewport.\n * @table viewport\n * @tfield Range bytes file bytes, from 0, at the start and end of the viewport\n * @tfield Range lines file lines, from 1, at the top and bottom of the viewport\n * @tfield int height lines in viewport, accounting for window decoration\n * @tfield int width columns in viewport, accounting for window decoration\n */\n/***\n * The window width.\n * @tfield int width\n */\n/***\n * The window height.\n * @tfield int height\n */\n/***\n * The file being displayed in this window.\n * Changing the value to a file path will replace the current file with a new\n * one for the specified path.\n * @tfield File file\n */\n/***\n * The primary selection of this window.\n * @tfield Selection selection\n */\n/***\n * The selections of this window.\n * @tfield Array(Selection) selections\n */\n/***\n * Window marks.\n * Most of these marks are stored in the associated File object, meaning they\n * are the same in all windows displaying the same file.\n * @field marks array to access the marks of this window by single letter name\n * @see Vis:mark_names\n */\nstatic int window_index(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\n\t\tif (strcmp(key, \"viewport\") == 0) {\n\t\t\tFilerange b = VIEW_VIEWPORT_GET(win->view);\n\t\t\tFilerange l;\n\t\t\tl.start = win->view.topline->lineno;\n\t\t\tl.end   = win->view.lastline->lineno;\n\n\t\t\tlua_createtable(L, 0, 4);\n\t\t\tlua_pushstring(L, \"bytes\");\n\t\t\tpushrange(L, &b);\n\t\t\tlua_settable(L, -3);\n\t\t\tlua_pushstring(L, \"lines\");\n\t\t\tpushrange(L, &l);\n\t\t\tlua_settable(L, -3);\n\t\t\tlua_pushstring(L, \"width\");\n\t\t\tlua_pushunsigned(L, win->view.width);\n\t\t\tlua_settable(L, -3);\n\t\t\tlua_pushstring(L, \"height\");\n\t\t\tlua_pushunsigned(L, win->view.height);\n\t\t\tlua_settable(L, -3);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"width\") == 0) {\n\t\t\tlua_pushunsigned(L, win->width);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"height\") == 0) {\n\t\t\tlua_pushunsigned(L, win->height);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"file\") == 0) {\n\t\t\tobj_ref_new(L, win->file, VIS_LUA_TYPE_FILE);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"selection\") == 0) {\n\t\t\tSelection *sel = view_selections_primary_get(&win->view);\n\t\t\tobj_lightref_new(L, sel, VIS_LUA_TYPE_SELECTION);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"selections\") == 0) {\n\t\t\tobj_ref_new(L, &win->view, VIS_LUA_TYPE_SELECTIONS);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"marks\") == 0) {\n\t\t\tobj_ref_new(L, &win->saved_selections, VIS_LUA_TYPE_MARKS);\n\t\t\treturn 1;\n\t\t}\n\t\tif (strcmp(key, \"options\") == 0) {\n\t\t\tobj_ref_new(L, &win->view, VIS_LUA_TYPE_WIN_OPTS);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn index_common(L);\n}\n\nstatic int window_options_assign(Win *win, lua_State *L, const char *key, int next) {\n\tenum UiOption flags = win->options;\n\tif (strcmp(key, \"breakat\") == 0 || strcmp(key, \"brk\") == 0) {\n\t\tif (lua_isstring(L, next))\n\t\t\tview_breakat_set(&win->view, lua_tostring(L, next));\n\t} else if (strcmp(key, \"colorcolumn\") == 0 || strcmp(key, \"cc\") == 0) {\n\t\twin->view.colorcolumn = luaL_checkunsigned(L, next);\n\t} else if (strcmp(key, \"cursorline\") == 0 || strcmp(key, \"cul\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_CURSOR_LINE;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_CURSOR_LINE;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"numbers\") == 0 || strcmp(key, \"nu\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_LINE_NUMBERS_ABSOLUTE;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"relativenumbers\") == 0 || strcmp(key, \"rnu\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_LINE_NUMBERS_RELATIVE;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_LINE_NUMBERS_RELATIVE;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"showeof\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_SYMBOL_EOF;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_SYMBOL_EOF;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"shownewlines\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_SYMBOL_EOL;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_SYMBOL_EOL;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"showspaces\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_SYMBOL_SPACE;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_SYMBOL_SPACE;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"showtabs\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_SYMBOL_TAB;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_SYMBOL_TAB;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"statusbar\") == 0) {\n\t\tif (lua_toboolean(L, next))\n\t\t\tflags |= UI_OPTION_STATUSBAR;\n\t\telse\n\t\t\tflags &= ~UI_OPTION_STATUSBAR;\n\t\twin_options_set(win, flags);\n\t} else if (strcmp(key, \"wrapcolumn\") == 0 || strcmp(key, \"wc\") == 0) {\n\t\twin->view.wrapcolumn = luaL_checkunsigned(L, next);\n\t} else if (strcmp(key, \"tabwidth\") == 0 || strcmp(key, \"tw\") == 0) {\n\t\tview_tabwidth_set(&win->view, luaL_checkint(L, next));\n\t} else if (strcmp(key, \"expandtab\") == 0 || strcmp(key, \"et\") == 0) {\n\t\twin->expandtab = lua_toboolean(L, next);\n\t}\n\treturn 0;\n}\n\nstatic int window_newindex(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"options\") == 0 && lua_istable(L, 3)) {\n\t\t\tint ret = 0;\n\t\t\t/* since we don't know which keys are in the table we push\n\t\t\t * a nil then use lua_next() to remove it and push the\n\t\t\t * table's key-value pairs to the stack. these can then be\n\t\t\t * used to assign options\n\t\t\t */\n\t\t\tlua_pushnil(L);\n\t\t\twhile (lua_next(L, 3)) {\n\t\t\t\tif (lua_isstring(L, 4))\n\t\t\t\t\tret += window_options_assign(win, L, lua_tostring(L, 4), 5);\n\t\t\t\telse\n\t\t\t\t\tret += newindex_common(L);\n\t\t\t\tlua_pop(L, 1);\n\t\t\t}\n\t\t\tlua_pop(L, 1);\n\t\t\treturn ret;\n\t\t} else if (strcmp(key, \"file\") == 0 && lua_isstring(L, 3)) {\n\t\t\tconst char* filename = lua_tostring(L, 3);\n\t\t\tif (!vis_window_change_file(win, filename)) {\n\t\t\t\treturn luaL_argerror(L, 3, \"failed to open\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn newindex_common(L);\n}\n\nstatic int window_selections_iterator_next(lua_State *L) {\n\tSelection **handle = lua_touserdata(L, lua_upvalueindex(1));\n\tif (!*handle)\n\t\treturn 0;\n\tSelection *sel = obj_lightref_new(L, *handle, VIS_LUA_TYPE_SELECTION);\n\tif (!sel)\n\t\treturn 0;\n\t*handle = view_selections_next(sel);\n\treturn 1;\n}\n\n/***\n * Create an iterator over all selections of this window.\n * @function selections_iterator\n * @return the new iterator\n */\nstatic int window_selections_iterator(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tSelection **handle = lua_newuserdata(L, sizeof *handle);\n\t*handle = view_selections(&win->view);\n\tlua_pushcclosure(L, window_selections_iterator_next, 1);\n\treturn 1;\n}\n\n/***\n * Set up a window local key mapping.\n * The function signatures are the same as for @{Vis:map}.\n * @function map\n * @param ...\n * @see Vis:map\n */\nstatic int window_map(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\treturn keymap(L, win->vis, win);\n}\n\n/***\n * Remove a window local key mapping.\n * The function signature is the same as for @{Vis:unmap}.\n * @function unmap\n * @param ...\n * @see Vis:unmap\n */\nstatic int window_unmap(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\treturn keyunmap(L, win->vis, win);\n}\n\n/***\n * Define a display style.\n * @function style_define\n * @tparam int id the style id to use\n * @tparam string style the style definition\n * @treturn bool whether the style definition has been successfully\n *  associated with the given id\n * @see style\n * @usage\n * win:style_define(win.STYLE_DEFAULT, \"fore:red\")\n */\nstatic int window_style_define(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tenum UiStyle id = luaL_checkunsigned(L, 2);\n\tconst char *style = luaL_checkstring(L, 3);\n\tbool ret = ui_style_define(win, id, style);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\n/***\n * Style a window range.\n *\n * The style will be cleared after every window redraw.\n * @function style\n * @tparam int id the display style as registered with @{style_define}\n * @tparam int start the absolute file position in bytes\n * @tparam int finish the end position\n * @see style_define\n * @usage\n * win:style(win.STYLE_DEFAULT, 0, 10)\n */\nstatic int window_style(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tenum UiStyle style = luaL_checkunsigned(L, 2);\n\tsize_t start = checkpos(L, 3);\n\tsize_t end = checkpos(L, 4);\n\twin_style(win, style, start, end);\n\treturn 0;\n}\n\n/***\n * Style the single terminal cell at the given coordinates, relative to this window.\n *\n * Completely independent of the file buffer, and can be used to style UI elements,\n * such as the status bar.\n * The style will be cleared after every window redraw.\n * @function style_pos\n * @tparam int id display style registered with @{style_define}\n * @tparam int x 0-based x coordinate within Win, where (0,0) is the top left corner\n * @tparam int y See above\n * @treturn bool false if the coordinates would be outside the window's dimensions\n * @see style_define\n * @usage\n * win:style_pos(win.STYLE_COLOR_COLUMN, 0, win.height - 1)\n * -- Styles the first character of the status bar (or the last line, if disabled)\n */\nstatic int window_style_pos(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tenum UiStyle style = luaL_checkunsigned(L, 2);\n\tsize_t x = checkpos(L, 3);\n\tsize_t y = checkpos(L, 4);\n\tbool ret = ui_window_style_set_pos(win, (int)x, (int)y, style);\n\tlua_pushboolean(L, ret);\n\treturn 1;\n}\n\n/***\n * Set window status line.\n *\n * @function status\n * @tparam string left the left aligned part of the status line\n * @tparam[opt] string right the right aligned part of the status line\n */\nstatic int window_status(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tchar status[1024] = \"\";\n\tint width = win->width;\n\tconst char *left = luaL_checkstring(L, 2);\n\tconst char *right = luaL_optstring(L, 3, \"\");\n\tint left_width = text_string_width(left, strlen(left));\n\tint right_width = text_string_width(right, strlen(right));\n\tint spaces = width - left_width - right_width;\n\tif (spaces < 1)\n\t\tspaces = 1;\n\tsnprintf(status, sizeof(status)-1, \"%s%*s%s\", left, spaces, \" \", right);\n\tui_window_status(win, status);\n\treturn 0;\n}\n\n/***\n * Redraw window content.\n *\n * @function draw\n */\nstatic int window_draw(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tview_draw(&win->view);\n\treturn 0;\n}\n\n/***\n * Close window.\n *\n * After a successful call the Window reference becomes invalid and\n * must no longer be used. Attempting to close the last window will\n * always fail.\n *\n * @function close\n * @see exit\n * @tparam bool force whether unsaved changes should be discarded\n * @treturn bool whether the window was closed\n */\nstatic int window_close(lua_State *L) {\n\tWin *win = obj_ref_check(L, 1, VIS_LUA_TYPE_WINDOW);\n\tint count = 0;\n\tfor (Win *w = win->vis->windows; w; w = w->next) {\n\t\tif (!w->file->internal)\n\t\t\tcount++;\n\t}\n\tbool force = lua_isboolean(L, 2) && lua_toboolean(L, 2);\n\tbool close = count > 1 && (force || vis_window_closable(win));\n\tif (close)\n\t\tvis_window_close(win);\n\tlua_pushboolean(L, close);\n\treturn 1;\n}\n\nstatic const struct luaL_Reg window_funcs[] = {\n\t{ \"__index\", window_index },\n\t{ \"__newindex\", window_newindex },\n\t{ \"selections_iterator\", window_selections_iterator },\n\t{ \"map\", window_map },\n\t{ \"unmap\", window_unmap },\n\t{ \"style_define\", window_style_define },\n\t{ \"style\", window_style },\n\t{ \"style_pos\", window_style_pos },\n\t{ \"status\", window_status },\n\t{ \"draw\", window_draw },\n\t{ \"close\", window_close },\n\t{ NULL, NULL },\n};\n\n/***\n * Window Options\n * @table options\n * @tfield[opt=\"\"] string breakat {brk}\n * @tfield[opt=0] int colorcolumn {cc}\n * @tfield[opt=false] boolean cursorline {cul}\n * @tfield[opt=false] boolean expandtab {et}\n * @tfield[opt=false] boolean numbers {nu}\n * @tfield[opt=false] boolean relativenumbers {rnu}\n * @tfield[opt=true] boolean showeof\n * @tfield[opt=false] boolean shownewlines\n * @tfield[opt=false] boolean showspaces\n * @tfield[opt=false] boolean showtabs\n * @tfield[opt=true] boolean statusbar\n * @tfield[opt=8] int tabwidth {tw}\n * @tfield[opt=0] int wrapcolumn {wc}\n * @see Vis.options\n */\n\nstatic int window_options_index(lua_State *L) {\n\tWin *win = obj_ref_check_containerof(L, 1, VIS_LUA_TYPE_WIN_OPTS, offsetof(Win, view));\n\tif (!win)\n\t\treturn -1;\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"breakat\") == 0 || strcmp(key, \"brk\") == 0) {\n\t\t\tlua_pushstring(L, win->view.breakat);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"colorcolumn\") == 0 || strcmp(key, \"cc\") == 0) {\n\t\t\tlua_pushunsigned(L, win->view.colorcolumn);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"cursorline\") == 0 || strcmp(key, \"cul\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_CURSOR_LINE);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"expandtab\") == 0 || strcmp(key, \"et\") == 0) {\n\t\t\tlua_pushboolean(L, win->expandtab);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"numbers\") == 0 || strcmp(key, \"nu\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_LINE_NUMBERS_ABSOLUTE);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"relativenumbers\") == 0 || strcmp(key, \"rnu\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_LINE_NUMBERS_RELATIVE);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"showeof\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_SYMBOL_EOF);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"shownewlines\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_SYMBOL_EOL);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"showspaces\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_SYMBOL_SPACE);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"showtabs\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_SYMBOL_TAB);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"statusbar\") == 0) {\n\t\t\tlua_pushboolean(L, win->options & UI_OPTION_STATUSBAR);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"tabwidth\") == 0 || strcmp(key, \"tw\") == 0) {\n\t\t\tlua_pushinteger(L, win->view.tabwidth);\n\t\t\treturn 1;\n\t\t} else if (strcmp(key, \"wrapcolumn\") == 0 || strcmp(key, \"wc\") == 0) {\n\t\t\tlua_pushunsigned(L, win->view.wrapcolumn);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn index_common(L);\n}\n\nstatic int window_options_newindex(lua_State *L) {\n\tWin *win = obj_ref_check_containerof(L, 1, VIS_LUA_TYPE_WIN_OPTS, offsetof(Win, view));\n\tif (!win)\n\t\treturn 0;\n\tif (lua_isstring(L, 2))\n\t\treturn window_options_assign(win, L, lua_tostring(L, 2), 3);\n\treturn newindex_common(L);\n}\n\nstatic const struct luaL_Reg window_option_funcs[] = {\n\t{ \"__index\", window_options_index },\n\t{ \"__newindex\", window_options_newindex},\n\t{ NULL, NULL },\n};\n\nstatic int window_selections_index(lua_State *L) {\n\tView *view = obj_ref_check(L, 1, VIS_LUA_TYPE_SELECTIONS);\n\tsize_t index = luaL_checkunsigned(L, 2);\n\tsize_t count = view->selection_count;\n\tif (index == 0 || index > count)\n\t\tgoto err;\n\tfor (Selection *s = view_selections(view); s; s = view_selections_next(s)) {\n\t\tif (!--index) {\n\t\t\tobj_lightref_new(L, s, VIS_LUA_TYPE_SELECTION);\n\t\t\treturn 1;\n\t\t}\n\t}\nerr:\n\tlua_pushnil(L);\n\treturn 1;\n}\n\nstatic int window_selections_len(lua_State *L) {\n\tView *view = obj_ref_check(L, 1, VIS_LUA_TYPE_SELECTIONS);\n\tlua_pushunsigned(L, view->selection_count);\n\treturn 1;\n}\n\nstatic const struct luaL_Reg window_selections_funcs[] = {\n\t{ \"__index\", window_selections_index },\n\t{ \"__len\", window_selections_len },\n\t{ NULL, NULL },\n};\n\n/***\n * A selection object.\n *\n * A selection is a non-empty, directed range with two endpoints called\n * *cursor* and *anchor*. A selection can be anchored in which case\n * the anchor remains fixed while only the position of the cursor is\n * adjusted. For non-anchored selections both endpoints are updated. A\n * singleton selection covers one character on which both cursor and\n * anchor reside. There always exists a primary selection which remains\n * visible (i.e. changes to its position will adjust the viewport).\n *\n * The range covered by a selection is represented as an interval whose\n * endpoints are absolute byte offsets from the start of the file.\n * Valid addresses are within the closed interval `[0, file.size]`.\n *\n * Selections are currently implemented using character marks into\n * the underlying persistent\n * [text management data structure](https://github.com/martanne/vis/wiki/Text-management-using-a-piece-chain).\n *\n * This has a few consequences you should be aware of:\n *\n *  - A selection becomes invalid when the delimiting boundaries of the underlying\n *    text it is referencing is deleted:\n *\n *        -- leaves selection in an invalid state\n *        win.file:delete(win.selection.pos, 1)\n *        assert(win.selection.pos == nil)\n *\n *    Like a regular mark it will become valid again when the text is reverted\n *    to the state before the deletion.\n *\n *  - Inserts after the selection position (`> selection.pos`) will not affect the\n *    selection position.\n *\n *        local pos = win.selection.pos\n *        win.file:insert(pos+1, \"-\")\n *        assert(win.selection.pos == pos)\n *\n *  - Non-cached inserts before the selection position (`<= selection.pos`) will\n *    affect the mark and adjust the selection position by the number of bytes\n *    which were inserted.\n *\n *        local pos = win.selection.pos\n *        win.file:insert(pos, \"-\")\n *        assert(win.selection.pos == pos+1)\n *\n *  - Cached inserts before the selection position (`<= selection.pos`) will\n *    not affect the selection position because the underlying text is replaced\n *    inplace.\n *\n * For these reasons it is generally recommended to update the selection position\n * after a modification. The general procedure amounts to:\n *\n * 1. Read out the current selection position\n * 2. Perform text modifications\n * 3. Update the selection position\n *\n * This is what @{Vis:insert} and @{Vis:replace} do internally.\n *\n * @type Selection\n * @usage\n * local data = \"new text\"\n * local pos = win.selection.pos\n * win.file:insert(pos, data)\n * win.selection.pos = pos + #data\n */\n\n/***\n * The zero based byte position in the file.\n *\n * Might be `nil` if the selection is in an invalid state.\n * Setting this field will move the cursor endpoint of the\n * selection to the given position.\n * @tfield int pos\n */\n/***\n * The 1-based line the cursor of this selection resides on.\n *\n * @tfield int line\n * @see to\n */\n/***\n * The 1-based column position the cursor of this selection resides on.\n * @tfield int col\n * @see to\n */\n/***\n * The 1-based selection index.\n * @tfield int number\n */\n/***\n * The range covered by this selection.\n * @tfield Range range\n */\n/***\n * Whether this selection is anchored.\n * @tfield bool anchored\n */\nstatic int window_selection_index(lua_State *L) {\n\tSelection *sel = obj_lightref_check(L, 1, VIS_LUA_TYPE_SELECTION);\n\tif (!sel) {\n\t\tlua_pushnil(L);\n\t\treturn 1;\n\t}\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"pos\") == 0) {\n\t\t\tpushpos(L, view_cursors_pos(sel));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"line\") == 0) {\n\t\t\tlua_pushunsigned(L, view_cursors_line(sel));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"col\") == 0) {\n\t\t\tlua_pushunsigned(L, view_cursors_col(sel));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"number\") == 0) {\n\t\t\tlua_pushunsigned(L, view_selections_number(sel)+1);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"range\") == 0) {\n\t\t\tFilerange range = view_selections_get(sel);\n\t\t\tpushrange(L, &range);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"anchored\") == 0) {\n\t\t\tlua_pushboolean(L, sel->anchored);\n\t\t\treturn 1;\n\t\t}\n\n\t}\n\n\treturn index_common(L);\n}\n\nstatic int window_selection_newindex(lua_State *L) {\n\tSelection *sel = obj_lightref_check(L, 1, VIS_LUA_TYPE_SELECTION);\n\tif (!sel)\n\t\treturn 0;\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"pos\") == 0) {\n\t\t\tsize_t pos = checkpos(L, 3);\n\t\t\tview_cursors_to(sel, pos);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"range\") == 0) {\n\t\t\tFilerange range = getrange(L, 3);\n\t\t\tif (text_range_valid(&range)) {\n\t\t\t\tview_selections_set(sel, &range);\n\t\t\t\tsel->anchored = true;\n\t\t\t} else {\n\t\t\t\tview_selection_clear(sel);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"anchored\") == 0) {\n\t\t\tsel->anchored = lua_toboolean(L, 3);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn newindex_common(L);\n}\n\n/***\n * Move cursor of selection.\n * @function to\n * @tparam int line the 1-based line number\n * @tparam int col the 1-based column number\n */\nstatic int window_selection_to(lua_State *L) {\n\tSelection *sel = obj_lightref_check(L, 1, VIS_LUA_TYPE_SELECTION);\n\tif (sel) {\n\t\tsize_t line = checkpos(L, 2);\n\t\tsize_t col = checkpos(L, 3);\n\t\tview_cursors_place(sel, line, col);\n\t}\n\treturn 0;\n}\n\n/***\n * Remove selection.\n * @function remove\n */\nstatic int window_selection_remove(lua_State *L) {\n\tSelection *sel = obj_lightref_check(L, 1, VIS_LUA_TYPE_SELECTION);\n\tif (sel) {\n\t\tview_selections_dispose(sel);\n\t}\n\treturn 0;\n}\n\nstatic const struct luaL_Reg window_selection_funcs[] = {\n\t{ \"__index\", window_selection_index },\n\t{ \"__newindex\", window_selection_newindex },\n\t{ \"to\", window_selection_to },\n\t{ \"remove\", window_selection_remove },\n\t{ NULL, NULL },\n};\n\n/***\n * A file object.\n * @type File\n */\n/***\n * File name.\n * @tfield string name the file name relative to current working directory or `nil` if not yet named\n */\n/***\n * File path.\n * @tfield string path the absolute file path or `nil` if not yet named\n */\n/***\n * File content by logical lines.\n *\n * Assigning to array element `0` (`#lines+1`) will insert a new line at\n * the beginning (end) of the file.\n * @tfield Array(string) lines the file content accessible as 1-based array\n * @see content\n * @usage\n * local lines = vis.win.file.lines\n * for i=1, #lines do\n * \tlines[i] = i .. \": \" .. lines[i]\n * end\n */\n/***\n * File save method\n * @tfield[opt=\"auto\"] string savemethod `\"auto\"`, `\"atomic\"`, or `\"inplace\"`.\n */\n/***\n * File size in bytes.\n * @tfield int size the current file size in bytes\n */\n/***\n * File state.\n * @tfield bool modified whether the file contains unsaved changes\n */\n/***\n * File permission.\n * @tfield int permission the file permission bits as of the most recent load/save\n */\nstatic int file_index(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\t\tif (strcmp(key, \"name\") == 0) {\n\t\t\tlua_pushstring(L, file_name_get(file));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"path\") == 0) {\n\t\t\tlua_pushstring(L, file->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"lines\") == 0) {\n\t\t\tobj_ref_new(L, file->text, VIS_LUA_TYPE_TEXT);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"size\") == 0) {\n\t\t\tlua_pushunsigned(L, text_size(file->text));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"modified\") == 0) {\n\t\t\tlua_pushboolean(L, text_modified(file->text));\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"permission\") == 0) {\n\t\t\tstruct stat stat = text_stat(file->text);\n\t\t\tlua_pushunsigned(L, stat.st_mode & 0777);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (strcmp(key, \"savemethod\") == 0) {\n\t\t\tswitch (file->save_method) {\n\t\t\tcase TEXT_SAVE_AUTO:\n\t\t\t\tlua_pushstring(L, \"auto\");\n\t\t\t\tbreak;\n\t\t\tcase TEXT_SAVE_ATOMIC:\n\t\t\t\tlua_pushstring(L, \"atomic\");\n\t\t\t\tbreak;\n\t\t\tcase TEXT_SAVE_INPLACE:\n\t\t\t\tlua_pushstring(L, \"inplace\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn index_common(L);\n}\n\nstatic int file_newindex(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\n\tif (lua_isstring(L, 2)) {\n\t\tconst char *key = lua_tostring(L, 2);\n\n\t\tif (strcmp(key, \"modified\") == 0) {\n\t\t\tbool modified = lua_isboolean(L, 3) && lua_toboolean(L, 3);\n\t\t\tif (modified) {\n\t\t\t\ttext_insert(file->text, 0, \" \", 1);\n\t\t\t\ttext_delete(file->text, 0, 1);\n\t\t\t} else {\n\t\t\t\ttext_save(file->text, NULL);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (strcmp(key, \"savemethod\") == 0) {\n\t\t\tif (!lua_isstring(L, 3))\n\t\t\t\treturn newindex_common(L);\n\t\t\tconst char *sm = lua_tostring(L, 3);\n\t\t\tif (strcmp(sm, \"auto\") == 0)\n\t\t\t\tfile->save_method = TEXT_SAVE_AUTO;\n\t\t\telse if (strcmp(sm, \"atomic\") == 0)\n\t\t\t\tfile->save_method = TEXT_SAVE_ATOMIC;\n\t\t\telse if (strcmp(sm, \"inplace\") == 0)\n\t\t\t\tfile->save_method = TEXT_SAVE_INPLACE;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn newindex_common(L);\n}\n\n/***\n * Insert data at position.\n * @function insert\n * @tparam int pos the 0-based file position in bytes\n * @tparam string data the data to insert\n * @treturn bool whether the file content was successfully changed\n */\nstatic int file_insert(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tsize_t pos = checkpos(L, 2);\n\tsize_t len;\n\tluaL_checkstring(L, 3);\n\tconst char *data = lua_tolstring(L, 3, &len);\n\tlua_pushboolean(L, text_insert(file->text, pos, data, len));\n\treturn 1;\n}\n\n/***\n * Delete data at position.\n *\n * @function delete\n * @tparam int pos the 0-based file position in bytes\n * @tparam int len the length in bytes to delete\n * @treturn bool whether the file content was successfully changed\n */\n/***\n * Delete file range.\n *\n * @function delete\n * @tparam Range range the range to delete\n * @treturn bool whether the file content was successfully changed\n */\nstatic int file_delete(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tFilerange range = getrange(L, 2);\n\tlua_pushboolean(L, text_delete_range(file->text, &range));\n\treturn 1;\n}\n\n/***\n * Create an iterator over all lines of the file.\n *\n * For large files this is probably faster than @{lines}.\n * @function lines_iterator\n * @return the new iterator\n * @see lines\n * @usage\n * for line in file:lines_iterator() do\n * \t-- do something with line\n * end\n */\nstatic int file_lines_iterator_it(lua_State *L);\nstatic int file_lines_iterator(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tsize_t line = luaL_optunsigned(L, 2, 1);\n\tsize_t *pos = lua_newuserdata(L, sizeof *pos);\n\t*pos = text_pos_by_lineno(file->text, line);\n\tlua_pushcclosure(L, file_lines_iterator_it, 2);\n\treturn 1;\n}\n\nstatic int file_lines_iterator_it(lua_State *L) {\n\tFile *file = *(File**)lua_touserdata(L, lua_upvalueindex(1));\n\tsize_t *start = lua_touserdata(L, lua_upvalueindex(2));\n\tif (*start == text_size(file->text))\n\t\treturn 0;\n\tsize_t end = text_line_end(file->text, *start);\n\tsize_t len = end - *start;\n\tchar *buf = lua_newuserdata(L, len);\n\tif (!buf && len)\n\t\treturn 0;\n\tlen = text_bytes_get(file->text, *start, len, buf);\n\tlua_pushlstring(L, buf, len);\n\t*start = text_line_next(file->text, end);\n\treturn 1;\n}\n\n/***\n * Get file content of position and length.\n *\n * @function content\n * @tparam int pos the 0-based file position in bytes\n * @tparam int len the length in bytes to read\n * @treturn string the file content corresponding to the range\n * @see lines\n * @usage\n * local file = vis.win.file\n * local text = file:content(0, file.size)\n */\n/***\n * Get file content of range.\n *\n * @function content\n * @tparam Range range the range to read\n * @treturn string the file content corresponding to the range\n */\nstatic int file_content(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tFilerange range = getrange(L, 2);\n\tif (!text_range_valid(&range))\n\t\tgoto err;\n\tsize_t len = text_range_size(&range);\n\tchar *data = lua_newuserdata(L, len);\n\tif (!data)\n\t\tgoto err;\n\tlen = text_bytes_get(file->text, range.start, len, data);\n\tlua_pushlstring(L, data, len);\n\treturn 1;\nerr:\n\tlua_pushnil(L);\n\treturn 1;\n}\n\n/***\n * Set mark.\n * @function mark_set\n * @tparam int pos the position to set the mark to, must be in [0, file.size]\n * @treturn Mark mark the mark which can be looked up later\n */\nstatic int file_mark_set(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tsize_t pos = checkpos(L, 2);\n\tMark mark = text_mark_set(file->text, pos);\n\tif (mark)\n\t\tobj_lightref_new(L, (void*)mark, VIS_LUA_TYPE_MARK);\n\telse\n\t\tlua_pushnil(L);\n\treturn 1;\n}\n\n/***\n * Get position of mark.\n * @function mark_get\n * @tparam Mark mark the mark to look up\n * @treturn int pos the position of the mark, or `nil` if invalid\n */\nstatic int file_mark_get(lua_State *L) {\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tMark mark = (Mark)obj_lightref_check(L, 2, VIS_LUA_TYPE_MARK);\n\tsize_t pos = text_mark_get(file->text, mark);\n\tif (pos == EPOS)\n\t\tlua_pushnil(L);\n\telse\n\t\tlua_pushunsigned(L, pos);\n\treturn 1;\n}\n\n/***\n * Word text object.\n *\n * @function text_object_word\n * @tparam int pos the position which must be part of the word\n * @treturn Range range the range\n */\n\n/***\n * WORD text object.\n *\n * @function text_object_longword\n * @tparam int pos the position which must be part of the word\n * @treturn Range range the range\n */\n\nstatic int file_text_object(lua_State *L) {\n\tFilerange range = text_range_empty();\n\tFile *file = obj_ref_check(L, 1, VIS_LUA_TYPE_FILE);\n\tsize_t pos = checkpos(L, 2);\n\tsize_t idx = lua_tointeger(L, lua_upvalueindex(1));\n\tif (idx < LENGTH(vis_textobjects)) {\n\t\tconst TextObject *txtobj = &vis_textobjects[idx];\n\t\tif (txtobj->txt)\n\t\t\trange = txtobj->txt(file->text, pos);\n\t}\n\tpushrange(L, &range);\n\treturn 1;\n}\n\nstatic const struct luaL_Reg file_funcs[] = {\n\t{ \"__index\", file_index },\n\t{ \"__newindex\", file_newindex },\n\t{ \"insert\", file_insert },\n\t{ \"delete\", file_delete },\n\t{ \"lines_iterator\", file_lines_iterator },\n\t{ \"content\", file_content },\n\t{ \"mark_set\", file_mark_set },\n\t{ \"mark_get\", file_mark_get },\n\t{ NULL, NULL },\n};\n\nstatic int file_lines_index(lua_State *L) {\n\tText *txt = obj_ref_check(L, 1, VIS_LUA_TYPE_TEXT);\n\tsize_t line = luaL_checkunsigned(L, 2);\n\tsize_t start = text_pos_by_lineno(txt, line);\n\tsize_t end = text_line_end(txt, start);\n\tif (start != EPOS && end != EPOS) {\n\t\tsize_t size = end - start;\n\t\tchar *data = lua_newuserdata(L, size);\n\t\tif (!data && size)\n\t\t\tgoto err;\n\t\tsize = text_bytes_get(txt, start, size, data);\n\t\tlua_pushlstring(L, data, size);\n\t\treturn 1;\n\t}\nerr:\n\tlua_pushnil(L);\n\treturn 1;\n}\n\nstatic int file_lines_newindex(lua_State *L) {\n\tText *txt = obj_ref_check(L, 1, VIS_LUA_TYPE_TEXT);\n\tsize_t line = luaL_checkunsigned(L, 2);\n\tsize_t size;\n\tconst char *data = luaL_checklstring(L, 3, &size);\n\tif (line == 0) {\n\t\ttext_insert(txt, 0, data, size);\n\t\ttext_insert(txt, size, \"\\n\", 1);\n\t\treturn 0;\n\t}\n\tsize_t start = text_pos_by_lineno(txt, line);\n\tsize_t end = text_line_end(txt, start);\n\tif (start != EPOS && end != EPOS) {\n\t\ttext_delete(txt, start, end - start);\n\t\ttext_insert(txt, start, data, size);\n\t\tif (text_size(txt) == start + size)\n\t\t\ttext_insert(txt, text_size(txt), \"\\n\", 1);\n\t}\n\treturn 0;\n}\n\nstatic int file_lines_len(lua_State *L) {\n\tText *txt = obj_ref_check(L, 1, VIS_LUA_TYPE_TEXT);\n\tsize_t lines = 0;\n\tchar lastchar;\n\tsize_t size = text_size(txt);\n\tif (size > 0)\n\t\tlines = text_lineno_by_pos(txt, size);\n\tif (lines > 1 && text_byte_get(txt, size-1, &lastchar) && lastchar == '\\n')\n\t\tlines--;\n\tlua_pushunsigned(L, lines);\n\treturn 1;\n}\n\nstatic const struct luaL_Reg file_lines_funcs[] = {\n\t{ \"__index\", file_lines_index },\n\t{ \"__newindex\", file_lines_newindex },\n\t{ \"__len\", file_lines_len },\n\t{ NULL, NULL },\n};\n\nstatic int window_marks_index(lua_State *L) {\n\tlua_newtable(L);\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tWin *win = obj_ref_check_containerof(L, 1, VIS_LUA_TYPE_MARKS, offsetof(Win, saved_selections));\n\tif (!win)\n\t\treturn 1;\n\tconst char *symbol = luaL_checkstring(L, 2);\n\tif (strlen(symbol) != 1)\n\t\treturn 1;\n\tenum VisMark mark = vis_mark_from(vis, symbol[0]);\n\tif (mark == VIS_MARK_INVALID)\n\t\treturn 1;\n\n\tArray arr = vis_mark_get(win, mark);\n\tfor (size_t i = 0, len = arr.len; i < len; i++) {\n\t\tFilerange *range = array_get(&arr, i);\n\t\tlua_pushunsigned(L, i+1);\n\t\tpushrange(L, range);\n\t\tlua_settable(L, -3);\n\t}\n\tarray_release(&arr);\n\treturn 1;\n}\n\nstatic int window_marks_newindex(lua_State *L) {\n\tVis *vis = lua_touserdata(L, lua_upvalueindex(1));\n\tWin *win = obj_ref_check_containerof(L, 1, VIS_LUA_TYPE_MARKS, offsetof(Win, saved_selections));\n\tif (!win)\n\t\treturn 0;\n\tconst char *symbol = luaL_checkstring(L, 2);\n\tif (strlen(symbol) != 1)\n\t\treturn 0;\n\tenum VisMark mark = vis_mark_from(vis, symbol[0]);\n\tif (mark == VIS_MARK_INVALID)\n\t\treturn 0;\n\n\tArray ranges;\n\tarray_init_sized(&ranges, sizeof(Filerange));\n\n\tif (lua_istable(L, 3)) {\n\t\tlua_pushnil(L);\n\t\twhile (lua_next(L, 3)) {\n\t\t\tFilerange range = getrange(L, -1);\n\t\t\tif (text_range_valid(&range))\n\t\t\t\tarray_add(&ranges, &range);\n\t\t\tlua_pop(L, 1);\n\t\t}\n\t}\n\n\tvis_mark_set(win, mark, &ranges);\n\tarray_release(&ranges);\n\treturn 0;\n}\n\nstatic int window_marks_len(lua_State *L) {\n\tlua_pushunsigned(L, VIS_MARK_INVALID);\n\treturn 1;\n}\n\nstatic const struct luaL_Reg window_marks_funcs[] = {\n\t{ \"__index\", window_marks_index },\n\t{ \"__newindex\", window_marks_newindex },\n\t{ \"__len\", window_marks_len },\n\t{ NULL, NULL },\n};\n\n/***\n * A file range.\n *\n * For a valid range `start <= finish` holds.\n * An invalid range is represented as `nil`.\n * @type Range\n */\n/***\n * The beginning of the range.\n * @tfield int start\n */\n/***\n * The end of the range.\n * @tfield int finish\n */\n\n/***\n * Layouts.\n * @section Layouts\n */\n\n/***\n * Layout Constants.\n * @table layouts\n * @tfield int HORIZONTAL\n * @tfield int VERTICAL\n */\n\n/***\n * Modes.\n * @section Modes\n */\n\n/***\n * Mode constants.\n * @table modes\n * @tfield int NORMAL\n * @tfield int OPERATOR_PENDING\n * @tfield int INSERT\n * @tfield int REPLACE\n * @tfield int VISUAL\n * @tfield int VISUAL_LINE\n * @see Vis:map\n * @see Window:map\n */\n\n/***\n * Key Handling.\n *\n * This section describes the contract between the editor core and Lua\n * key handling functions mapped to symbolic keys using either @{Vis:map}\n * or @{Window:map}.\n *\n * @section Key_Handling\n */\n\n/***\n * Example of a key handling function.\n *\n * The keyhandler is invoked with the pending content of the input queue\n * given as argument. This might be the empty string if no further input\n * is available.\n *\n * The function is expected to return the number of *bytes* it has\n * consumed from the passed input keys. A negative return value is\n * interpreted as an indication that not enough input was available. The\n * function will be called again once the user has provided more input. A\n * missing return value (i.e. `nil`) is interpreted as zero, meaning\n * no further input was consumed but the function completed successfully.\n *\n * @function keyhandler\n * @tparam string keys the keys following the mapping\n * @treturn int the number of *bytes* being consumed by the function (see above)\n * @see Vis:action_register\n * @see Vis:map\n * @see Window:map\n * @usage\n * vis:map(vis.modes.INSERT, \"<C-k>\", function(keys)\n * \tif #keys < 2 then\n * \t\treturn -1 -- need more input\n * \tend\n * \tlocal digraph = keys:sub(1, 2)\n * \tif digraph == \"l*\" then\n * \t\tvis:feedkeys('λ')\n * \t\treturn 2 -- consume 2 bytes of input\n * \tend\n * end, \"Insert digraph\")\n */\n\n/***\n * Core Events.\n *\n * These events are invoked from the editor core.\n * The following functions are invoked if they are registered in the\n * `vis.events` table. Users scripts should generally use the [Events](#events)\n * mechanism instead which multiplexes these core events.\n *\n * @section Core_Events\n */\n\nstatic void vis_lua_event_get(lua_State *L, const char *name) {\n\tlua_getglobal(L, \"vis\");\n\tlua_getfield(L, -1, \"events\");\n\tif (lua_istable(L, -1)) {\n\t\tlua_getfield(L, -1, name);\n\t}\n\tlua_remove(L, -2);\n}\n\nstatic void vis_lua_event_call(Vis *vis, const char *name) {\n\tlua_State *L = vis->lua;\n\tvis_lua_event_get(L, name);\n\tif (lua_isfunction(L, -1))\n\t\tpcall(vis, L, 0, 0);\n\tlua_pop(L, 1);\n}\n\nstatic bool vis_lua_path_strip(Vis *vis) {\n\tlua_State *L = vis->lua;\n\tlua_getglobal(L, \"package\");\n\n\tfor (const char **var = (const char*[]){ \"path\", \"cpath\", NULL }; *var; var++) {\n\n\t\tlua_getfield(L, -1, *var);\n\t\tconst char *path = lua_tostring(L, -1);\n\t\tlua_pop(L, 1);\n\t\tif (!path)\n\t\t\treturn false;\n\n\t\tchar *copy = strdup(path), *stripped = calloc(1, strlen(path)+2);\n\t\tif (!copy || !stripped) {\n\t\t\tfree(copy);\n\t\t\tfree(stripped);\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (char *elem = copy, *stripped_elem = stripped, *next; elem; elem = next) {\n\t\t\tif ((next = strstr(elem, \";\")))\n\t\t\t\t*next++ = '\\0';\n\t\t\tif (strstr(elem, \"./\"))\n\t\t\t\tcontinue; /* skip relative path entries */\n\t\t\tstripped_elem += sprintf(stripped_elem, \"%s;\", elem);\n\t\t}\n\n\t\tlua_pushstring(L, stripped);\n\t\tlua_setfield(L, -2, *var);\n\n\t\tfree(copy);\n\t\tfree(stripped);\n\t}\n\n\tlua_pop(L, 1); /* package */\n\treturn true;\n}\n\nbool vis_lua_path_add(Vis *vis, const char *path) {\n\tlua_State *L = vis->lua;\n\tif (!L || !path)\n\t\treturn false;\n\tlua_getglobal(L, \"package\");\n\tlua_pushstring(L, path);\n\tlua_pushstring(L, \"/?.lua;\");\n\tlua_pushstring(L, path);\n\tlua_pushstring(L, \"/?/init.lua;\");\n\tlua_getfield(L, -5, \"path\");\n\tlua_concat(L, 5);\n\tlua_setfield(L, -2, \"path\");\n\tlua_pop(L, 1); /* package */\n\treturn true;\n}\n\nbool vis_lua_paths_get(Vis *vis, char **lpath, char **cpath) {\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn false;\n\tconst char *s;\n\tlua_getglobal(L, \"package\");\n\tlua_getfield(L, -1, \"path\");\n\ts = lua_tostring(L, -1);\n\t*lpath = s ? strdup(s) : NULL;\n\tlua_getfield(L, -2, \"cpath\");\n\ts = lua_tostring(L, -1);\n\t*cpath = s ? strdup(s) : NULL;\n\treturn true;\n}\n\nstatic bool package_exist(Vis *vis, lua_State *L, const char *name) {\n\tconst char lua[] =\n\t\t\"local name = ...\\n\"\n\t\t\"for _, searcher in ipairs(package.searchers or package.loaders) do\\n\"\n\t\t\t\"local loader = searcher(name)\\n\"\n\t\t\t\"if type(loader) == 'function' then\\n\"\n\t\t\t\t\"return true\\n\"\n\t\t\t\"end\\n\"\n\t\t\"end\\n\"\n\t\t\"return false\\n\";\n\tif (luaL_loadstring(L, lua) != LUA_OK)\n\t\treturn false;\n\tlua_pushstring(L, name);\n\t/* an error indicates package exists */\n\tbool ret = lua_pcall(L, 1, 1, 0) != LUA_OK || lua_toboolean(L, -1);\n\tlua_pop(L, 1);\n\treturn ret;\n}\n\nstatic void *alloc_lua(void *ud, void *ptr, size_t osize, size_t nsize) {\n\tif (nsize == 0) {\n\t\tfree(ptr);\n\t\treturn NULL;\n\t} else {\n\t\treturn realloc(ptr, nsize);\n\t}\n}\n\n/***\n * Editor initialization completed.\n * This event is emitted immediately after `visrc.lua` has been sourced, but\n * before any other events have occurred, in particular the command line arguments\n * have not yet been processed.\n *\n * Can be used to set *global* configuration options.\n * @function init\n */\nstatic void vis_lua_init(Vis *vis) {\n\tlua_State *L = lua_newstate(alloc_lua, vis);\n\tif (!L)\n\t\treturn;\n\tvis->lua = L;\n\tlua_atpanic(L, &panic_handler);\n\n\tluaL_openlibs(L);\n\n#if CONFIG_LPEG\n\textern int luaopen_lpeg(lua_State *L);\n\tlua_getglobal(L, \"package\");\n\tlua_getfield(L, -1, \"preload\");\n\tlua_pushcfunction(L, luaopen_lpeg);\n\tlua_setfield(L, -2, \"lpeg\");\n\tlua_pop(L, 2);\n#endif\n\n\t/* remove any relative paths from lua's default package.path */\n\tvis_lua_path_strip(vis);\n\n\t/* extends lua's package.path with:\n\t * - $VIS_PATH\n\t * - ./lua (relative path to the binary location)\n\t * - $XDG_CONFIG_HOME/vis (defaulting to $HOME/.config/vis)\n\t * - /etc/vis (for system-wide configuration provided by administrator)\n\t * - /usr/(local/)?share/vis (or whatever is specified during ./configure)\n\t * - package.path (standard lua search path)\n\t */\n\tchar path[PATH_MAX];\n\n\tvis_lua_path_add(vis, VIS_PATH);\n\n\t/* try to get users home directory */\n\tconst char *home = getenv(\"HOME\");\n\tif (!home || !*home) {\n\t\tstruct passwd *pw = getpwuid(getuid());\n\t\tif (pw)\n\t\t\thome = pw->pw_dir;\n\t}\n\n\tvis_lua_path_add(vis, \"/etc/vis\");\n\n\tconst char *xdg_config = getenv(\"XDG_CONFIG_HOME\");\n\tif (xdg_config) {\n\t\tsnprintf(path, sizeof path, \"%s/vis\", xdg_config);\n\t\tvis_lua_path_add(vis, path);\n\t} else if (home && *home) {\n\t\tsnprintf(path, sizeof path, \"%s/.config/vis\", home);\n\t\tvis_lua_path_add(vis, path);\n\t}\n\n\tssize_t len = readlink(\"/proc/self/exe\", path, sizeof(path)-1);\n\tif (len > 0) {\n\t\tpath[len] = '\\0';\n\t\t/* some idiotic dirname(3) implementations return pointers to statically\n\t\t * allocated memory, hence we use memmove to copy it back */\n\t\tchar *dir = dirname(path);\n\t\tif (dir) {\n\t\t\tsize_t len = strlen(dir)+1;\n\t\t\tif (len < sizeof(path) - sizeof(\"/lua\")) {\n\t\t\t\tmemmove(path, dir, len);\n\t\t\t\tstrcat(path, \"/lua\");\n\t\t\t\tvis_lua_path_add(vis, path);\n\t\t\t}\n\t\t}\n\t}\n\n\tvis_lua_path_add(vis, getenv(\"VIS_PATH\"));\n\n\t/* table in registry to lookup object type, stores metatable -> type mapping */\n\tlua_newtable(L);\n\tlua_setfield(L, LUA_REGISTRYINDEX, \"vis.types\");\n\t/* table in registry to track lifetimes of C objects */\n\tlua_newtable(L);\n\tlua_setfield(L, LUA_REGISTRYINDEX, \"vis.objects\");\n\t/* table in registry to store references to Lua functions */\n\tlua_newtable(L);\n\tlua_setfield(L, LUA_REGISTRYINDEX, \"vis.functions\");\n\t/* metatable used to type check user data */\n\tobj_type_new(L, VIS_LUA_TYPE_VIS);\n\tluaL_setfuncs(L, vis_lua, 0);\n\tlua_newtable(L);\n\tlua_setfield(L, -2, \"types\");\n\t/* create reference to main vis object, such that the further\n\t * calls to obj_type_new can register the type meta tables in\n\t * vis.types[name] */\n\tobj_ref_new(L, vis, \"vis\");\n\tlua_setglobal(L, \"vis\");\n\n\tobj_type_new(L, VIS_LUA_TYPE_FILE);\n\n\tconst struct {\n\t\tenum VisTextObject id;\n\t\tconst char *name;\n\t} textobjects[] = {\n\t\t{ VIS_TEXTOBJECT_INNER_WORD, \"text_object_word\" },\n\t\t{ VIS_TEXTOBJECT_INNER_LONGWORD, \"text_object_longword\" },\n\t};\n\n\tfor (size_t i = 0; i < LENGTH(textobjects); i++) {\n\t\tlua_pushunsigned(L, textobjects[i].id);\n\t\tlua_pushcclosure(L, file_text_object, 1);\n\t\tlua_setfield(L, -2, textobjects[i].name);\n\t}\n\n\tluaL_setfuncs(L, file_funcs, 0);\n\n\tobj_type_new(L, VIS_LUA_TYPE_TEXT);\n\tluaL_setfuncs(L, file_lines_funcs, 0);\n\tobj_type_new(L, VIS_LUA_TYPE_WINDOW);\n\tluaL_setfuncs(L, window_funcs, 0);\n\n\tconst struct {\n\t\tenum UiStyle id;\n\t\tconst char *name;\n\t} styles[] = {\n\t\t{ UI_STYLE_LEXER_MAX,         \"STYLE_LEXER_MAX\"         },\n\t\t{ UI_STYLE_DEFAULT,           \"STYLE_DEFAULT\"           },\n\t\t{ UI_STYLE_CURSOR,            \"STYLE_CURSOR\"            },\n\t\t{ UI_STYLE_CURSOR_PRIMARY,    \"STYLE_CURSOR_PRIMARY\"    },\n\t\t{ UI_STYLE_CURSOR_LINE,       \"STYLE_CURSOR_LINE\"       },\n\t\t{ UI_STYLE_SELECTION,         \"STYLE_SELECTION\"         },\n\t\t{ UI_STYLE_LINENUMBER,        \"STYLE_LINENUMBER\"        },\n\t\t{ UI_STYLE_LINENUMBER_CURSOR, \"STYLE_LINENUMBER_CURSOR\" },\n\t\t{ UI_STYLE_COLOR_COLUMN,      \"STYLE_COLOR_COLUMN\"      },\n\t\t{ UI_STYLE_STATUS,            \"STYLE_STATUS\"            },\n\t\t{ UI_STYLE_STATUS_FOCUSED,    \"STYLE_STATUS_FOCUSED\"    },\n\t\t{ UI_STYLE_SEPARATOR,         \"STYLE_SEPARATOR\"         },\n\t\t{ UI_STYLE_INFO,              \"STYLE_INFO\"              },\n\t\t{ UI_STYLE_EOF,               \"STYLE_EOF\"               },\n\t};\n\n\tfor (size_t i = 0; i < LENGTH(styles); i++) {\n\t\tlua_pushunsigned(L, styles[i].id);\n\t\tlua_setfield(L, -2, styles[i].name);\n\t}\n\n\tobj_type_new(L, VIS_LUA_TYPE_WIN_OPTS);\n\tluaL_setfuncs(L, window_option_funcs, 0);\n\n\tobj_type_new(L, VIS_LUA_TYPE_MARK);\n\tobj_type_new(L, VIS_LUA_TYPE_MARKS);\n\tlua_pushlightuserdata(L, vis);\n\tluaL_setfuncs(L, window_marks_funcs, 1);\n\n\tobj_type_new(L, VIS_LUA_TYPE_SELECTION);\n\tluaL_setfuncs(L, window_selection_funcs, 0);\n\tobj_type_new(L, VIS_LUA_TYPE_SELECTIONS);\n\tluaL_setfuncs(L, window_selections_funcs, 0);\n\n\tobj_type_new(L, VIS_LUA_TYPE_UI);\n\tluaL_setfuncs(L, ui_funcs, 0);\n\tlua_pushunsigned(L, ui_terminal_colors());\n\tlua_setfield(L, -2, \"colors\");\n\tlua_newtable(L);\n\tstatic const struct {\n\t\tenum UiLayout id;\n\t\tconst char *name;\n\t} layouts[] = {\n\t\t{ UI_LAYOUT_HORIZONTAL, \"HORIZONTAL\" },\n\t\t{ UI_LAYOUT_VERTICAL, \"VERTICAL\" },\n\t};\n\tfor (size_t i = 0; i <  LENGTH(layouts); i++) {\n\t\tlua_pushunsigned(L, layouts[i].id);\n\t\tlua_setfield(L, -2, layouts[i].name);\n\t}\n\tlua_setfield(L, -2, \"layouts\");\n\n\tobj_type_new(L, VIS_LUA_TYPE_REGISTERS);\n\tlua_pushlightuserdata(L, vis);\n\tluaL_setfuncs(L, registers_funcs, 1);\n\n\tobj_type_new(L, VIS_LUA_TYPE_KEYACTION);\n\n\tlua_getglobal(L, \"vis\");\n\tlua_getmetatable(L, -1);\n\n\tlua_pushstring(L, VERSION);\n\tlua_setfield(L, -2, \"VERSION\");\n\n\tlua_newtable(L);\n\tstatic const struct {\n\t\tenum VisMode id;\n\t\tconst char *name;\n\t} modes[] = {\n\t\t{ VIS_MODE_NORMAL,           \"NORMAL\"           },\n\t\t{ VIS_MODE_OPERATOR_PENDING, \"OPERATOR_PENDING\" },\n\t\t{ VIS_MODE_VISUAL,           \"VISUAL\"           },\n\t\t{ VIS_MODE_VISUAL_LINE,      \"VISUAL_LINE\"      },\n\t\t{ VIS_MODE_INSERT,           \"INSERT\"           },\n\t\t{ VIS_MODE_REPLACE,          \"REPLACE\"          },\n\t};\n\tfor (size_t i = 0; i < LENGTH(modes); i++) {\n\t\tlua_pushunsigned(L, modes[i].id);\n\t\tlua_setfield(L, -2, modes[i].name);\n\t}\n\tlua_setfield(L, -2, \"modes\");\n\n\tobj_type_new(L, VIS_LUA_TYPE_VIS_OPTS);\n\tluaL_setfuncs(L, vis_option_funcs, 0);\n\n\tif (!package_exist(vis, L, \"visrc\")) {\n\t\tvis_info_show(vis, \"WARNING: failed to load visrc.lua\");\n\t} else {\n\t\tlua_getglobal(L, \"require\");\n\t\tlua_pushstring(L, \"visrc\");\n\t\tpcall(vis, L, 1, 0);\n\t\tvis_lua_event_call(vis, \"init\");\n\t}\n}\n\n/***\n * Editor startup completed.\n * This event is emitted immediately before the main loop starts.\n * At this point all files are loaded and corresponding windows are created.\n * We are about to process interactive keyboard input.\n * @function start\n */\nstatic void vis_lua_start(Vis *vis) {\n\tvis_lua_event_call(vis, \"start\");\n}\n\n/**\n * Editor is about to terminate.\n * @function quit\n */\nstatic void vis_lua_quit(Vis *vis) {\n\tif (!vis->lua)\n\t\treturn;\n\tvis_lua_event_call(vis, \"quit\");\n\tlua_close(vis->lua);\n\tvis->lua = NULL;\n}\n\n/***\n * Input key event in either input or replace mode.\n * @function input\n * @tparam string key\n * @treturn bool whether the key was consumed or not\n */\nstatic bool vis_lua_input(Vis *vis, const char *key, size_t len) {\n\tlua_State *L = vis->lua;\n\tif (!L || !vis->win || vis->win->file->internal)\n\t\treturn false;\n\tbool ret = false;\n\tvis_lua_event_get(L, \"input\");\n\tif (lua_isfunction(L, -1)) {\n\t\tlua_pushlstring(L, key, len);\n\t\tif (pcall(vis, L, 1, 1) == 0) {\n\t\t\tret = lua_isboolean(L, -1) && lua_toboolean(L, -1);\n\t\t\tlua_pop(L, 1);\n\t\t}\n\t}\n\tlua_pop(L, 1);\n\treturn ret;\n}\n\nvoid vis_event_mode_insert_input(Vis *vis, const char *key, size_t len) {\n\tif (!vis_lua_input(vis, key, len))\n\t\tvis_insert_key(vis, key, len);\n}\n\nvoid vis_event_mode_replace_input(Vis *vis, const char *key, size_t len) {\n\tif (!vis_lua_input(vis, key, len))\n\t\tvis_replace_key(vis, key, len);\n}\n\n/***\n * File open.\n * @function file_open\n * @tparam File file the file to be opened\n */\nstatic void vis_lua_file_open(Vis *vis, File *file) {\n\tdebug(\"event: file-open: %s %p %p\\n\", file->name ? file->name : \"unnamed\", (void*)file, (void*)file->text);\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"file_open\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, file, VIS_LUA_TYPE_FILE);\n\t\tpcall(vis, L, 1, 0);\n\t}\n\tlua_pop(L, 1);\n}\n\n/***\n * File pre save.\n * Triggered *before* the file is being written.\n * @function file_save_pre\n * @tparam File file the file being written\n * @tparam string path the absolute path to which the file will be written, `nil` if standard output\n * @treturn bool whether the write operation should be proceeded\n */\nstatic bool vis_lua_file_save_pre(Vis *vis, File *file, const char *path) {\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn true;\n\tvis_lua_event_get(L, \"file_save_pre\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, file, VIS_LUA_TYPE_FILE);\n\t\tlua_pushstring(L, path);\n\t\tif (pcall(vis, L, 2, 1) != 0)\n\t\t\treturn false;\n\t\treturn !lua_isboolean(L, -1) || lua_toboolean(L, -1);\n\t}\n\tlua_pop(L, 1);\n\treturn true;\n}\n\n/***\n * File post save.\n * Triggered *after* a successful write operation.\n * @function file_save_post\n * @tparam File file the file which was written\n * @tparam string path the absolute path to which it was written, `nil` if standard output\n */\nstatic void vis_lua_file_save_post(Vis *vis, File *file, const char *path) {\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"file_save_post\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, file, VIS_LUA_TYPE_FILE);\n\t\tlua_pushstring(L, path);\n\t\tpcall(vis, L, 2, 0);\n\t}\n\tlua_pop(L, 1);\n}\n\n/***\n * File close.\n * The last window displaying the file has been closed.\n * @function file_close\n * @tparam File file the file being closed\n */\nstatic void vis_lua_file_close(Vis *vis, File *file) {\n\tdebug(\"event: file-close: %s %p %p\\n\", file->name ? file->name : \"unnamed\", (void*)file, (void*)file->text);\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"file_close\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, file, VIS_LUA_TYPE_FILE);\n\t\tpcall(vis, L, 1, 0);\n\t}\n\tobj_ref_free(L, file->marks);\n\tobj_ref_free(L, file->text);\n\tobj_ref_free(L, file);\n\tlua_pop(L, 1);\n}\n\n/***\n * Window open.\n * A new window has been created.\n * @function win_open\n * @tparam Window win the window being opened\n */\nstatic void vis_lua_win_open(Vis *vis, Win *win) {\n\tdebug(\"event: win-open: %s %p %p\\n\", win->file->name ? win->file->name : \"unnamed\", (void*)win, (void*)win->view);\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"win_open\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, win, VIS_LUA_TYPE_WINDOW);\n\t\tpcall(vis, L, 1, 0);\n\t}\n\tlua_pop(L, 1);\n}\n\n/***\n * Window close.\n * An window is being closed.\n * @function win_close\n * @tparam Window win the window being closed\n */\nstatic void vis_lua_win_close(Vis *vis, Win *win) {\n\tdebug(\"event: win-close: %s %p %p\\n\", win->file->name ? win->file->name : \"unnamed\", (void*)win, (void*)win->view);\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"win_close\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, win, VIS_LUA_TYPE_WINDOW);\n\t\tpcall(vis, L, 1, 0);\n\t}\n\tobj_ref_free(L, &win->view);\n\tobj_ref_free(L, win);\n\tlua_pop(L, 1);\n}\n\n/**\n * Window highlight.\n * The window has been redrawn and the syntax highlighting needs to be performed.\n * @function win_highlight\n * @tparam Window win the window being redrawn\n * @see style\n */\nstatic void vis_lua_win_highlight(Vis *vis, Win *win) {\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"win_highlight\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, win, VIS_LUA_TYPE_WINDOW);\n\t\tpcall(vis, L, 1, 0);\n\t}\n\tlua_pop(L, 1);\n}\n\n/***\n * Window status bar redraw.\n * @function win_status\n * @tparam Window win the affected window\n * @see status\n */\nstatic void vis_lua_win_status(Vis *vis, Win *win) {\n\tlua_State *L = vis->lua;\n\tif (!L || win->file->internal) {\n\t\twindow_status_update(vis, win);\n\t\treturn;\n\t}\n\tvis_lua_event_get(L, \"win_status\");\n\tif (lua_isfunction(L, -1)) {\n\t\tobj_ref_new(L, win, VIS_LUA_TYPE_WINDOW);\n\t\tpcall(vis, L, 1, 0);\n\t} else {\n\t\twindow_status_update(vis, win);\n\t}\n\tlua_pop(L, 1);\n}\n\n/***\n * CSI command received from terminal.\n * @function term_csi\n * @param List of CSI parameters\n */\nstatic void vis_lua_term_csi(Vis *vis, const long *csi) {\n\tlua_State *L = vis->lua;\n\tif (!L)\n\t\treturn;\n\tvis_lua_event_get(L, \"term_csi\");\n\tif (lua_isfunction(L, -1)) {\n\t\tint nargs = csi[1];\n\t\tlua_pushinteger(L, csi[0]);\n\t\tfor (int i = 0; i < nargs; i++)\n\t\t\tlua_pushinteger(L, csi[2 + i]);\n\t\tpcall(vis, L, 1 + nargs, 0);\n\t}\n\tlua_pop(L, 1);\n}\n/***\n * The response received from the process started via @{Vis:communicate}.\n * @function process_response\n * @tparam string name the name of process given to @{Vis:communicate}\n * @tparam string response_type can be \"STDOUT\" or \"STDERR\" if new output was received in corresponding channel, \"SIGNAL\" if the process was terminated by a signal or \"EXIT\" when the process terminated normally\n * @tparam int code the exit code number if response_type is \"EXIT\", or the signal number if response_type is \"SIGNAL\"\n * @tparam string buffer the available content sent by the process\n */\nvoid vis_lua_process_response(Vis *vis, const char *name,\n                              char *buffer, size_t len, ResponseType rtype) {\n\tlua_State *L = vis->lua;\n\tif (!L) {\n\t\treturn;\n\t}\n\tvis_lua_event_get(L, \"process_response\");\n\tif (lua_isfunction(L, -1)) {\n\t\tlua_pushstring(L, name);\n\t\tswitch (rtype) {\n\t\tcase STDOUT: lua_pushstring(L, \"STDOUT\"); break;\n\t\tcase STDERR: lua_pushstring(L, \"STDERR\"); break;\n\t\tcase SIGNAL: lua_pushstring(L, \"SIGNAL\"); break;\n\t\tcase EXIT: lua_pushstring(L, \"EXIT\"); break;\n\t\t}\n\t\tswitch (rtype) {\n\t\tcase EXIT:\n\t\tcase SIGNAL:\n\t\t\tlua_pushinteger(L, len);\n\t\t\tlua_pushnil(L);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlua_pushnil(L);\n\t\t\tlua_pushlstring(L, buffer, len);\n\t\t}\n\t\tpcall(vis, L, 4, 0);\n\t}\n\tlua_pop(L, 1);\n}\n\n/***\n * Emitted immediately before the UI is drawn to the screen.\n * Allows last-minute overrides to the styling of UI elements.\n *\n * *WARNING:* This is emitted every screen draw!\n * Use sparingly and check for `nil` values!\n * @function ui_draw\n */\nstatic void vis_lua_ui_draw(Vis *vis) {\n\tvis_lua_event_call(vis, \"ui_draw\");\n}\n\nbool vis_event_emit(Vis *vis, enum VisEvents id, ...) {\n\tva_list ap;\n\tva_start(ap, id);\n\tbool ret = true;\n\n\tswitch (id) {\n\tcase VIS_EVENT_INIT:\n\t\tvis_lua_init(vis);\n\t\tbreak;\n\tcase VIS_EVENT_START:\n\t\tvis_lua_start(vis);\n\t\tbreak;\n\tcase VIS_EVENT_FILE_OPEN:\n\tcase VIS_EVENT_FILE_SAVE_PRE:\n\tcase VIS_EVENT_FILE_SAVE_POST:\n\tcase VIS_EVENT_FILE_CLOSE:\n\t{\n\t\tFile *file = va_arg(ap, File*);\n\t\tif (file->internal)\n\t\t\tbreak;\n\t\tif (id == VIS_EVENT_FILE_OPEN) {\n\t\t\tvis_lua_file_open(vis, file);\n\t\t} else if (id == VIS_EVENT_FILE_SAVE_PRE) {\n\t\t\tconst char *path = va_arg(ap, const char*);\n\t\t\tret = vis_lua_file_save_pre(vis, file, path);\n\t\t} else if (id == VIS_EVENT_FILE_SAVE_POST) {\n\t\t\tconst char *path = va_arg(ap, const char*);\n\t\t\tvis_lua_file_save_post(vis, file, path);\n\t\t} else if (id == VIS_EVENT_FILE_CLOSE) {\n\t\t\tvis_lua_file_close(vis, file);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIS_EVENT_WIN_OPEN:\n\tcase VIS_EVENT_WIN_CLOSE:\n\tcase VIS_EVENT_WIN_HIGHLIGHT:\n\tcase VIS_EVENT_WIN_STATUS:\n\t{\n\t\tWin *win = va_arg(ap, Win*);\n\t\tif (win->file->internal && id != VIS_EVENT_WIN_STATUS)\n\t\t\tbreak;\n\t\tif (id == VIS_EVENT_WIN_OPEN) {\n\t\t\tvis_lua_win_open(vis, win);\n\t\t} else if (id == VIS_EVENT_WIN_CLOSE) {\n\t\t\tvis_lua_win_close(vis, win);\n\t\t} else if (id == VIS_EVENT_WIN_HIGHLIGHT) {\n\t\t\tvis_lua_win_highlight(vis, win);\n\t\t} else if (id == VIS_EVENT_WIN_STATUS) {\n\t\t\tvis_lua_win_status(vis, win);\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIS_EVENT_QUIT:\n\t\tvis_lua_quit(vis);\n\t\tbreak;\n\tcase VIS_EVENT_TERM_CSI:\n\t\tvis_lua_term_csi(vis, va_arg(ap, const long *));\n\t\tbreak;\n\tcase VIS_EVENT_UI_DRAW:\n\t\tvis_lua_ui_draw(vis);\n\t\tbreak;\n\t}\n\n\tva_end(ap);\n\treturn ret;\n}\n\n#endif\n"
        },
        {
          "name": "vis-lua.h",
          "type": "blob",
          "size": 0.9853515625,
          "content": "#ifndef VIS_LUA_H\n#define VIS_LUA_H\n\n#if CONFIG_LUA\n#include <lua.h>\n#include <lualib.h>\n#include <lauxlib.h>\n\n#else\ntypedef struct lua_State lua_State;\ntypedef void* lua_CFunction;\n#endif\n\n#include \"vis.h\"\n#include \"vis-subprocess.h\"\n\n/* add a directory to consider when loading lua files */\nbool vis_lua_path_add(Vis*, const char *path);\n/* get semicolon separated list of paths to load lua files\n * (*lpath = package.path) and Lua C modules (*cpath = package.cpath)\n * both these pointers need to be free(3)-ed by the caller */\nbool vis_lua_paths_get(Vis*, char **lpath, char **cpath);\n\n/* various event handlers, triggered by the vis core */\n#if !CONFIG_LUA\n#define vis_event_mode_insert_input  vis_insert_key\n#define vis_event_mode_replace_input vis_replace_key\n#else\nvoid vis_event_mode_insert_input(Vis*, const char *key, size_t len);\nvoid vis_event_mode_replace_input(Vis*, const char *key, size_t len);\n#endif\nvoid vis_lua_process_response(Vis *, const char *, char *, size_t, ResponseType);\n\n#endif\n"
        },
        {
          "name": "vis-marks.c",
          "type": "blob",
          "size": 5.767578125,
          "content": "#include \"vis-core.h\"\n\nstatic int ranges_comparator(const void *a, const void *b) {\n\tconst Filerange *r1 = a, *r2 = b;\n\tif (!text_range_valid(r1))\n\t\treturn text_range_valid(r2) ? 1 : 0;\n\tif (!text_range_valid(r2))\n\t\treturn -1;\n\treturn (r1->start < r2->start || (r1->start == r2->start && r1->end < r2->end)) ? -1 : 1;\n}\n\nvoid vis_mark_normalize(Array *a) {\n\tarray_sort(a, ranges_comparator);\n\tFilerange *prev = NULL, *r = array_get(a, 0);\n\tfor (size_t i = 0; r; r = array_get(a, i)) {\n\t\tif (text_range_size(r) == 0) {\n\t\t\tarray_remove(a, i);\n\t\t} else if (prev && text_range_overlap(prev, r)) {\n\t\t\t*prev = text_range_union(prev, r);\n\t\t\tarray_remove(a, i);\n\t\t} else {\n\t\t\tprev = r;\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nbool vis_mark_equal(Array *a, Array *b) {\n\tif (a->len != b->len)\n\t\treturn false;\n\tsize_t len = a->len;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (!text_range_equal(array_get(a, i), array_get(b, i)))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid mark_init(Array *arr) {\n\tarray_init_sized(arr, sizeof(SelectionRegion));\n}\n\nvoid mark_release(Array *arr) {\n\tif (!arr)\n\t\treturn;\n\tarray_release(arr);\n}\n\nstatic Array *mark_from(Vis *vis, enum VisMark id) {\n\tif (!vis->win)\n\t\treturn NULL;\n\tif (id == VIS_MARK_SELECTION)\n\t\treturn &vis->win->saved_selections;\n\tFile *file = vis->win->file;\n\tif (id < LENGTH(file->marks))\n\t\treturn &file->marks[id];\n\treturn NULL;\n}\n\nenum VisMark vis_mark_used(Vis *vis) {\n\treturn vis->action.mark;\n}\n\nvoid vis_mark(Vis *vis, enum VisMark mark) {\n\tif (mark < LENGTH(vis->win->file->marks))\n\t\tvis->action.mark = mark;\n}\n\nstatic Array mark_get(Win *win, Array *mark) {\n\tArray sel;\n\tarray_init_sized(&sel, sizeof(Filerange));\n\tif (!mark)\n\t\treturn sel;\n\tsize_t len = mark->len;\n\tarray_reserve(&sel, len);\n\tfor (size_t i = 0; i < len; i++) {\n\t\tSelectionRegion *sr = array_get(mark, i);\n\t\tFilerange r = view_regions_restore(&win->view, sr);\n\t\tif (text_range_valid(&r))\n\t\t\tarray_add(&sel, &r);\n\t}\n\tvis_mark_normalize(&sel);\n\treturn sel;\n}\n\nArray vis_mark_get(Win *win, enum VisMark id) {\n\treturn mark_get(win, mark_from(win->vis, id));\n}\n\nstatic void mark_set(Win *win, Array *mark, Array *sel) {\n\tif (!mark)\n\t\treturn;\n\tarray_clear(mark);\n\tfor (size_t i = 0, len = sel->len; i < len; i++) {\n\t\tSelectionRegion ss;\n\t\tFilerange *r = array_get(sel, i);\n\t\tif (view_regions_save(&win->view, r, &ss))\n\t\t\tarray_add(mark, &ss);\n\t}\n}\n\nvoid vis_mark_set(Win *win, enum VisMark id, Array *sel) {\n\tmark_set(win, mark_from(win->vis, id), sel);\n}\n\nvoid marklist_init(MarkList *list, size_t max) {\n\tArray mark;\n\tmark_init(&mark);\n\tarray_init_sized(&list->prev, sizeof(Array));\n\tarray_reserve(&list->prev, max);\n\tarray_add(&list->prev, &mark);\n\tarray_init_sized(&list->next, sizeof(Array));\n\tarray_reserve(&list->next, max);\n}\n\nvoid marklist_release(MarkList *list) {\n\tfor (size_t i = 0, len = list->prev.len; i < len; i++)\n\t\tarray_release(array_get(&list->prev, i));\n\tarray_release(&list->prev);\n\tfor (size_t i = 0, len = list->next.len; i < len; i++)\n\t\tarray_release(array_get(&list->next, i));\n\tarray_release(&list->next);\n}\n\nstatic bool marklist_push(Win *win, MarkList *list, Array *sel) {\n\tArray *top = array_peek(&list->prev);\n\tif (top) {\n\t\tArray top_sel = mark_get(win, top);\n\t\tbool eq = vis_mark_equal(&top_sel, sel);\n\t\tarray_release(&top_sel);\n\t\tif (eq)\n\t\t\treturn true;\n\t}\n\n\tfor (size_t i = 0, len = list->next.len; i < len; i++)\n\t\tarray_release(array_get(&list->next, i));\n\tarray_clear(&list->next);\n\tArray arr;\n\tmark_init(&arr);\n\tif (list->prev.len >= list->prev.count) {\n\t\tArray *tmp = array_get(&list->prev, 0);\n\t\tarr = *tmp;\n\t\tarray_remove(&list->prev, 0);\n\t}\n\tmark_set(win, &arr, sel);\n\treturn array_push(&list->prev, &arr);\n}\n\nbool vis_jumplist_save(Vis *vis) {\n\tArray sel = view_selections_get_all(&vis->win->view);\n\tbool ret = marklist_push(vis->win, &vis->win->jumplist, &sel);\n\tarray_release(&sel);\n\treturn ret;\n}\n\nstatic bool marklist_prev(Win *win, MarkList *list) {\n\tView *view = &win->view;\n\tbool restore = false;\n\tArray cur = view_selections_get_all(view);\n\tbool anchored = view_selections_primary_get(view)->anchored;\n\tArray *top = array_peek(&list->prev);\n\tif (!top)\n\t\tgoto out;\n\tArray top_sel = mark_get(win, top);\n\trestore = !vis_mark_equal(&top_sel, &cur);\n\tif (restore)\n\t\tview_selections_set_all(view, &top_sel, anchored);\n\tarray_release(&top_sel);\n\tif (restore)\n\t\tgoto out;\n\n\twhile (list->prev.len > 1) {\n\t\tArray *prev = array_pop(&list->prev);\n\t\tarray_push(&list->next, prev);\n\t\tprev = array_peek(&list->prev);\n\t\tArray sel = mark_get(win, prev);\n\t\trestore = sel.len > 0;\n\t\tif (restore)\n\t\t\tview_selections_set_all(view, &sel, anchored);\n\t\tarray_release(&sel);\n\t\tif (restore)\n\t\t\tgoto out;\n\t}\nout:\n\tarray_release(&cur);\n\treturn restore;\n}\n\nstatic bool marklist_next(Win *win, MarkList *list) {\n\tView *view = &win->view;\n\tbool anchored = view_selections_primary_get(view)->anchored;\n\tfor (;;) {\n\t\tArray *next = array_pop(&list->next);\n\t\tif (!next)\n\t\t\treturn false;\n\t\tArray sel = mark_get(win, next);\n\t\tif (sel.len > 0) {\n\t\t\tview_selections_set_all(view, &sel, anchored);\n\t\t\tarray_release(&sel);\n\t\t\tarray_push(&list->prev, next);\n\t\t\treturn true;\n\t\t}\n\t\tarray_release(next);\n\t}\n}\n\nbool vis_jumplist_prev(Vis *vis) {\n\treturn marklist_prev(vis->win, &vis->win->jumplist);\n}\n\nbool vis_jumplist_next(Vis *vis) {\n\treturn marklist_next(vis->win, &vis->win->jumplist);\n}\n\nenum VisMark vis_mark_from(Vis *vis, char mark) {\n\tif (mark >= 'a' && mark <= 'z')\n\t\treturn VIS_MARK_a + mark - 'a';\n\tfor (size_t i = 0; i < LENGTH(vis_marks); i++) {\n\t\tif (vis_marks[i].name == mark)\n\t\t\treturn i;\n\t}\n\treturn VIS_MARK_INVALID;\n}\n\nchar vis_mark_to(Vis *vis, enum VisMark mark) {\n\tif (VIS_MARK_a <= mark && mark <= VIS_MARK_z)\n\t\treturn 'a' + mark - VIS_MARK_a;\n\n\tif (mark < LENGTH(vis_marks))\n\t\treturn vis_marks[mark].name;\n\n\treturn '\\0';\n}\n\nconst MarkDef vis_marks[] = {\n\t[VIS_MARK_DEFAULT]        = { '\\'', VIS_HELP(\"Default mark\")    },\n\t[VIS_MARK_SELECTION]      = { '^',  VIS_HELP(\"Last selections\") },\n};\n"
        },
        {
          "name": "vis-menu.c",
          "type": "blob",
          "size": 15.509765625,
          "content": "/*\n * MIT/X Consortium License\n *\n * © 2011 Rafael Garcia Gallego <rafael.garcia.gallego@gmail.com>\n *\n * Based on dmenu:\n * © 2010-2011 Connor Lane Smith <cls@lubutu.com>\n * © 2006-2011 Anselm R Garbe <anselm@garbe.us>\n * © 2009 Gottox <gottox@s01.de>\n * © 2009 Markus Schnalke <meillo@marmaro.de>\n * © 2009 Evan Gates <evan.gates@gmail.com>\n * © 2006-2008 Sander van Dijk <a dot h dot vandijk at gmail dot com>\n * © 2006-2007 Michał Janeczek <janeczek at gmail dot com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n * DEALINGS IN THE SOFTWARE.\n */\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <ctype.h>\n#include <sys/ioctl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <termios.h>\n#include <unistd.h>\n#include <errno.h>\n\n#define CONTROL(ch)   (ch ^ 0x40)\n#define MIN(a,b)      ((a) < (b) ? (a) : (b))\n#define MAX(a,b)      ((a) > (b) ? (a) : (b))\n\ntypedef enum {\n\tC_Normal,\n\tC_Reverse\n} Color;\n\ntypedef struct Item Item;\nstruct Item {\n\tchar *text;\n\tItem *left, *right;\n};\n\nstatic char   text[BUFSIZ] = \"\";\nstatic int    barpos = 0;\nstatic size_t mw, mh;\nstatic size_t lines = 0;\nstatic size_t inputw, promptw;\nstatic size_t cursor;\nstatic char  *prompt = NULL;\nstatic Item  *items = NULL;\nstatic Item  *matches, *matchend;\nstatic Item  *prev, *curr, *next, *sel;\nstatic struct termios tio_old, tio_new;\nstatic int  (*fstrncmp)(const char *, const char *, size_t) = strncmp;\n\nstatic void\nappenditem(Item *item, Item **list, Item **last) {\n\tif (!*last)\n\t\t*list = item;\n\telse\n\t\t(*last)->right = item;\n\titem->left = *last;\n\titem->right = NULL;\n\t*last = item;\n}\n\nstatic size_t\ntextwn(const char *s, int l) {\n\tint c;\n\n\tfor (c=0; s && s[c] && (l<0 || c<l); c++);\n\treturn c+4; /* Accomodate for the leading and trailing spaces */\n}\n\n/*\n * textvalidn returns the highest amount of bytes <= l of string s that\n * only contains valid Unicode points. This is used to make sure we don't\n * cut off any valid UTF-8-encoded unicode point in case there is not\n * enough space to render the whole text string.\n*/\nstatic ssize_t\ntextvalidn(const char *s, int l) {\n  int c, utfcharbytes; /* byte count and UTF-8 codepoint length */\n\n  for (c=0; s && s[c] && (l<0 || c<l); ) {\n\t\tutfcharbytes = 0;\n\t\tif ((s[c] & 0x80) == 0) {\n\t\t\tutfcharbytes = 1;\n\t\t} else if ((s[c] & 0xf0) == 0xf0) {\n\t\t\tutfcharbytes = 4;\n\t\t} else if ((s[c] & 0xf0) == 0xe0) {\n\t\t\tutfcharbytes = 3;\n\t\t} else if ((s[c] & 0xe0) == 0xc0) {\n\t\t\tutfcharbytes = 2;\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\n\t\tif ((l>0 && c + utfcharbytes >= l)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tc += utfcharbytes;\n  }\n\n\treturn c;\n}\n\nstatic size_t\ntextw(const char *s) {\n\treturn textwn(s, -1);\n}\n\nstatic void\ncalcoffsets(void) {\n        size_t i, n;\n\n\tif (lines > 0)\n\t\tn = lines;\n\telse\n\t\tn = mw - (promptw + inputw + textw(\"<\") + textw(\">\"));\n\n        for (i = 0, next = curr; next; next = next->right)\n                if ((i += (lines>0 ? 1 : MIN(textw(next->text), n))) > n)\n                        break;\n        for (i = 0, prev = curr; prev && prev->left; prev = prev->left)\n                if ((i += (lines>0 ? 1 : MIN(textw(prev->left->text), n))) > n)\n                        break;\n}\n\nstatic void\ncleanup(void) {\n\tif (barpos == 0) fprintf(stderr, \"\\n\");\n\telse fprintf(stderr, \"\\033[G\\033[K\");\n\ttcsetattr(0, TCSANOW, &tio_old);\n}\n\nstatic void\ndie(const char *s) {\n\ttcsetattr(0, TCSANOW, &tio_old);\n\tfprintf(stderr, \"%s\\n\", s);\n\texit(2);\n}\n\nstatic void\ndrawtext(const char *t, size_t w, Color col) {\n\tconst char *prestr, *poststr;\n\tsize_t i, tw;\n\tchar *buf;\n\n\tif (w<5) return; /* This is the minimum size needed to write a label: 1 char + 4 padding spaces */\n\ttw = w-4; /* This is the text width, without the padding */\n\tif (!(buf = calloc(1, tw+1))) die(\"Can't calloc.\");\n\tswitch (col) {\n\tcase C_Reverse:\n\t\tprestr=\"\\033[7m\";\n\t\tpoststr=\"\\033[0m\";\n\t\tbreak;\n\tcase C_Normal:\n\tdefault:\n\t\tprestr=poststr=\"\";\n\t}\n\n\tmemset(buf, ' ', tw);\n\tbuf[tw] = '\\0';\n\tmemcpy(buf, t, MIN(strlen(t), tw));\n\tif (textw(t) > w) /* Remember textw returns the width WITH padding */\n\t\tfor (i = MAX(textvalidn(t, w-4), 0); i < tw; i++) buf[i] = '.';\n\n\tfprintf(stderr, \"%s  %s  %s\", prestr, buf, poststr);\n\tfree(buf);\n}\n\nstatic void\nresetline(void) {\n\tif (barpos != 0) fprintf(stderr, \"\\033[%ldH\", (long)(barpos > 0 ? 0 : (mh-lines)));\n\telse fprintf(stderr, \"\\033[%zuF\", lines);\n}\n\nstatic void\ndrawmenu(void) {\n\tItem *item;\n\tsize_t rw;\n\n\t/* use default colors */\n\tfprintf(stderr, \"\\033[0m\");\n\n\t/* place cursor in first column, clear it */\n\tfprintf(stderr, \"\\033[0G\");\n\tfprintf(stderr, \"\\033[K\");\n\n\tif (prompt)\n\t\tdrawtext(prompt, promptw, C_Reverse);\n\n\tdrawtext(text, (lines==0 && matches) ? inputw : mw-promptw, C_Normal);\n\n\tif (lines > 0) {\n\t\tif (barpos != 0) resetline();\n\t\tfor (rw = 0, item = curr; item != next; rw++, item = item->right) {\n\t\t\tfprintf(stderr, \"\\n\");\n\t\t\tdrawtext(item->text, mw, (item == sel) ? C_Reverse : C_Normal);\n\t\t}\n\t\tfor (; rw < lines; rw++)\n\t\t\tfprintf(stderr, \"\\n\\033[K\");\n\t\tresetline();\n\t} else if (matches) {\n\t\trw = mw-(4+promptw+inputw);\n\t\tif (curr->left)\n\t\t\tdrawtext(\"<\", 5 /*textw(\"<\")*/, C_Normal);\n\t\tfor (item = curr; item != next; item = item->right) {\n\t\t\tdrawtext(item->text, MIN(textw(item->text), rw), (item == sel) ? C_Reverse : C_Normal);\n\t\t\tif ((rw -= textw(item->text)) <= 0) break;\n\t\t}\n\t\tif (next) {\n\t\t\tfprintf(stderr, \"\\033[%zuG\", mw-5);\n\t\t\tdrawtext(\">\", 5 /*textw(\">\")*/, C_Normal);\n\t\t}\n\n\t}\n\tfprintf(stderr, \"\\033[%ldG\", (long)(promptw+textwn(text, cursor)-1));\n\tfflush(stderr);\n}\n\nstatic char*\nfstrstr(const char *s, const char *sub) {\n\tfor (size_t len = strlen(sub); *s; s++)\n\t\tif (!fstrncmp(s, sub, len))\n\t\t\treturn (char*)s;\n\treturn NULL;\n}\n\nstatic void\nmatch(void)\n{\n\tstatic char **tokv = NULL;\n\tstatic int tokn = 0;\n\n\tchar buf[sizeof text], *s;\n\tint i, tokc = 0;\n\tsize_t len, textsize;\n\tItem *item, *lprefix, *lsubstr, *prefixend, *substrend;\n\n\tstrcpy(buf, text);\n\t/* separate input text into tokens to be matched individually */\n\tfor (s = strtok(buf, \" \"); s; tokv[tokc - 1] = s, s = strtok(NULL, \" \"))\n\t\tif (++tokc > tokn && !(tokv = realloc(tokv, ++tokn * sizeof *tokv)))\n\t\t\tdie(\"Can't realloc.\");\n\tlen = tokc ? strlen(tokv[0]) : 0;\n\n\tmatches = lprefix = lsubstr = matchend = prefixend = substrend = NULL;\n\ttextsize = strlen(text) + 1;\n\tfor (item = items; item && item->text; item++) {\n\t\tfor (i = 0; i < tokc; i++)\n\t\t\tif (!fstrstr(item->text, tokv[i]))\n\t\t\t\tbreak;\n\t\tif (i != tokc) /* not all tokens match */\n\t\t\tcontinue;\n\t\t/* exact matches go first, then prefixes, then substrings */\n\t\tif (!tokc || !fstrncmp(text, item->text, textsize))\n\t\t\tappenditem(item, &matches, &matchend);\n\t\telse if (!fstrncmp(tokv[0], item->text, len))\n\t\t\tappenditem(item, &lprefix, &prefixend);\n\t\telse\n\t\t\tappenditem(item, &lsubstr, &substrend);\n\t}\n\tif (lprefix) {\n\t\tif (matches) {\n\t\t\tmatchend->right = lprefix;\n\t\t\tlprefix->left = matchend;\n\t\t} else\n\t\t\tmatches = lprefix;\n\t\tmatchend = prefixend;\n\t}\n\tif (lsubstr) {\n\t\tif (matches) {\n\t\t\tmatchend->right = lsubstr;\n\t\t\tlsubstr->left = matchend;\n\t\t} else\n\t\t\tmatches = lsubstr;\n\t\tmatchend = substrend;\n\t}\n\tcurr = sel = matches;\n\tcalcoffsets();\n}\n\nstatic void\ninsert(const char *str, ssize_t n) {\n\tif (strlen(text) + n > sizeof text - 1)\n\t\treturn;\n\tmemmove(&text[cursor + n], &text[cursor], sizeof text - cursor - MAX(n, 0));\n\tif (n > 0)\n\t\tmemcpy(&text[cursor], str, n);\n\tcursor += n;\n\tmatch();\n}\n\nstatic size_t\nnextrune(int inc) {\n\tssize_t n;\n\n\tfor(n = cursor + inc; n + inc >= 0 && (text[n] & 0xc0) == 0x80; n += inc);\n\treturn n;\n}\n\nstatic void\nreadstdin(void) {\n\tchar buf[sizeof text], *p, *maxstr = NULL;\n\tsize_t i, max = 0, size = 0;\n\n\tfor(i = 0; fgets(buf, sizeof buf, stdin); i++) {\n\t\tif (i+1 >= size / sizeof *items)\n\t\t\tif (!(items = realloc(items, (size += BUFSIZ))))\n\t\t\t\tdie(\"Can't realloc.\");\n\t\tif ((p = strchr(buf, '\\n')))\n\t\t\t*p = '\\0';\n\t\tif (!(items[i].text = strdup(buf)))\n\t\t\tdie(\"Can't strdup.\");\n\t\tif (strlen(items[i].text) > max)\n\t\t\tmax = textw(maxstr = items[i].text);\n\t}\n\tif (items)\n\t\titems[i].text = NULL;\n\tinputw = textw(maxstr);\n}\n\nstatic void\nxread(int fd, void *buf, size_t nbyte) {\n\tssize_t r = read(fd, buf, nbyte);\n\tif (r < 0 || (size_t)r != nbyte)\n\t\tdie(\"Can not read.\");\n}\n\nstatic void\nsetup(void) {\n\tint fd, result = -1;\n\tstruct winsize ws;\n\n\t/* re-open stdin to read keyboard */\n\tif (!freopen(\"/dev/tty\", \"r\", stdin)) die(\"Can't reopen tty as stdin.\");\n\tif (!freopen(\"/dev/tty\", \"w\", stderr)) die(\"Can't reopen tty as stderr.\");\n\n\t/* ioctl() the tty to get size */\n\tfd = open(\"/dev/tty\", O_RDWR);\n\tif (fd == -1) {\n\t\tmh = 24;\n\t\tmw = 80;\n\t} else {\n\t\tresult = ioctl(fd, TIOCGWINSZ, &ws);\n\t\tclose(fd);\n\t\tif (result < 0) {\n\t\t\tmw = 80;\n\t\t\tmh = 24;\n\t\t} else {\n\t\t\tmw = ws.ws_col;\n\t\t\tmh = ws.ws_row;\n\t\t}\n\t}\n\n\t/* change terminal attributes, save old */\n\ttcgetattr(0, &tio_old);\n\ttio_new = tio_old;\n\ttio_new.c_iflag &= ~(BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);\n\ttio_new.c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);\n\ttio_new.c_cflag &= ~(CSIZE|PARENB);\n\ttio_new.c_cflag |= CS8;\n\ttio_new.c_cc[VMIN] = 1;\n\ttcsetattr(0, TCSANOW, &tio_new);\n\n\tlines = MIN(MAX(lines, 0), mh);\n\tpromptw = prompt ? textw(prompt) : 0;\n\tinputw = MIN(inputw, mw/3);\n\tmatch();\n\tif (barpos != 0) resetline();\n\tdrawmenu();\n}\n\nstatic int\nrun(void) {\n\tchar buf[32];\n\tchar c;\n\n\tfor (;;) {\n\t\txread(0, &c, 1);\n\t\tmemset(buf, '\\0', sizeof buf);\n\t\tbuf[0] = c;\n\t\tswitch_top:\n\t\tswitch(c) {\n\t\tcase CONTROL('['):\n\t\t\txread(0, &c, 1);\n\t\t\tesc_switch_top:\n\t\t\tswitch(c) {\n\t\t\tcase CONTROL('['): /* ESC, need to press twice due to console limitations */\n\t\t\t\tc = CONTROL('C');\n\t\t\t\tgoto switch_top;\n\t\t\tcase '[':\n\t\t\t\txread(0, &c, 1);\n\t\t\t\tswitch(c) {\n\t\t\t\tcase '1': /* Home */\n\t\t\t\tcase '7':\n\t\t\t\tcase 'H':\n\t\t\t\t\tif (c != 'H') xread(0, &c, 1); /* Remove trailing '~' from stdin */\n\t\t\t\t\tc = CONTROL('A');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase '2': /* Insert */\n\t\t\t\t\txread(0, &c, 1); /* Remove trailing '~' from stdin */\n\t\t\t\t\tc = CONTROL('Y');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase '3': /* Delete */\n\t\t\t\t\txread(0, &c, 1); /* Remove trailing '~' from stdin */\n\t\t\t\t\tc = CONTROL('D');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase '4': /* End */\n\t\t\t\tcase '8':\n\t\t\t\tcase 'F':\n\t\t\t\t\tif (c != 'F') xread(0, &c, 1); /* Remove trailing '~' from stdin */\n\t\t\t\t\tc = CONTROL('E');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase '5': /* PageUp */\n\t\t\t\t\txread(0, &c, 1); /* Remove trailing '~' from stdin */\n\t\t\t\t\tc = CONTROL('V');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase '6': /* PageDown */\n\t\t\t\t\txread(0, &c, 1); /* Remove trailing '~' from stdin */\n\t\t\t\t\tc = 'v';\n\t\t\t\t\tgoto esc_switch_top;\n\t\t\t\tcase 'A': /* Up arrow */\n\t\t\t\t\tc = CONTROL('P');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase 'B': /* Down arrow */\n\t\t\t\t\tc = CONTROL('N');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase 'C': /* Right arrow */\n\t\t\t\t\tc = CONTROL('F');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\tcase 'D': /* Left arrow */\n\t\t\t\t\tc = CONTROL('B');\n\t\t\t\t\tgoto switch_top;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\twhile (cursor > 0 && text[nextrune(-1)] == ' ')\n\t\t\t\t\tcursor = nextrune(-1);\n\t\t\t\twhile (cursor > 0 && text[nextrune(-1)] != ' ')\n\t\t\t\t\tcursor = nextrune(-1);\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\twhile (text[cursor] != '\\0' && text[nextrune(+1)] == ' ')\n\t\t\t\t\tcursor = nextrune(+1);\n\t\t\t\tif (text[cursor] != '\\0') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tcursor = nextrune(+1);\n\t\t\t\t\t} while (text[cursor] != '\\0' && text[cursor] != ' ');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\twhile (text[cursor] != '\\0' && text[nextrune(+1)] == ' ') {\n\t\t\t\t\tcursor = nextrune(+1);\n\t\t\t\t\tinsert(NULL, nextrune(-1) - cursor);\n\t\t\t\t}\n\t\t\t\tif (text[cursor] != '\\0') {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tcursor = nextrune(+1);\n\t\t\t\t\t\tinsert(NULL, nextrune(-1) - cursor);\n\t\t\t\t\t} while (text[cursor] != '\\0' && text[cursor] != ' ');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tif (!next)\n\t\t\t\t\tbreak;\n\t\t\t\tsel = curr = next;\n\t\t\t\tcalcoffsets();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONTROL('C'):\n\t\t\treturn 1;\n\t\tcase CONTROL('M'): /* Return */\n\t\tcase CONTROL('J'):\n\t\t\tif (sel) strncpy(text, sel->text, sizeof(text)-1); /* Complete the input first, when hitting return */\n\t\t\tcursor = strlen(text);\n\t\t\tmatch();\n\t\t\tdrawmenu();\n\t\t\t/* fallthrough */\n\t\tcase CONTROL(']'):\n\t\tcase CONTROL('\\\\'): /* These are usually close enough to RET to replace Shift+RET, again due to console limitations */\n\t\t\tputs(text);\n\t\t\treturn 0;\n\t\tcase CONTROL('A'):\n\t\t\tif (sel == matches) {\n\t\t\t\tcursor = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsel = curr = matches;\n\t\t\tcalcoffsets();\n\t\t\tbreak;\n\t\tcase CONTROL('E'):\n\t\t\tif (text[cursor] != '\\0') {\n\t\t\t\tcursor = strlen(text);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (next) {\n\t\t\t\tcurr = matchend;\n\t\t\t\tcalcoffsets();\n\t\t\t\tcurr = prev;\n\t\t\t\tcalcoffsets();\n\t\t\t\twhile(next && (curr = curr->right))\n\t\t\t\t\tcalcoffsets();\n\t\t\t}\n\t\t\tsel = matchend;\n\t\t\tbreak;\n\t\tcase CONTROL('B'):\n\t\t\tif (cursor > 0 && (!sel || !sel->left || lines > 0)) {\n\t\t\t\tcursor = nextrune(-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase CONTROL('P'):\n\t\t\tif (sel && sel->left && (sel = sel->left)->right == curr) {\n\t\t\t\tcurr = prev;\n\t\t\t\tcalcoffsets();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONTROL('F'):\n\t\t\tif (text[cursor] != '\\0') {\n\t\t\t\tcursor = nextrune(+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fallthrough */\n\t\tcase CONTROL('N'):\n\t\t\tif (sel && sel->right && (sel = sel->right) == next) {\n\t\t\t\tcurr = next;\n\t\t\t\tcalcoffsets();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CONTROL('D'):\n\t\t\tif (text[cursor] == '\\0')\n\t\t\t\tbreak;\n\t\t\tcursor = nextrune(+1);\n\t\t\t/* fallthrough */\n\t\tcase CONTROL('H'):\n\t\tcase CONTROL('?'): /* Backspace */\n\t\t\tif (cursor == 0)\n\t\t\t\tbreak;\n\t\t\tinsert(NULL, nextrune(-1) - cursor);\n\t\t\tbreak;\n\t\tcase CONTROL('I'): /* TAB */\n\t\t\tif (!sel)\n\t\t\t\tbreak;\n\t\t\tstrncpy(text, sel->text, sizeof(text)-1);\n\t\t\tcursor = strlen(text);\n\t\t\tmatch();\n\t\t\tbreak;\n\t\tcase CONTROL('K'):\n\t\t\ttext[cursor] = '\\0';\n\t\t\tmatch();\n\t\t\tbreak;\n\t\tcase CONTROL('U'):\n\t\t\tinsert(NULL, 0 - cursor);\n\t\t\tbreak;\n\t\tcase CONTROL('W'):\n\t\t\twhile (cursor > 0 && text[nextrune(-1)] == ' ')\n\t\t\t\tinsert(NULL, nextrune(-1) - cursor);\n\t\t\twhile (cursor > 0 && text[nextrune(-1)] != ' ')\n\t\t\t\tinsert(NULL, nextrune(-1) - cursor);\n\t\t\tbreak;\n\t\tcase CONTROL('V'):\n\t\t\tif (!prev)\n\t\t\t\tbreak;\n\t\t\tsel = curr = prev;\n\t\t\tcalcoffsets();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(*buf))\n\t\t\t\tinsert(buf, strlen(buf));\n\t\t\tbreak;\n\t\t}\n\t\tdrawmenu();\n\t}\n}\n\nstatic void\nusage(void) {\n\tfputs(\"usage: vis-menu [-b|-t] [-i] [-l lines] [-p prompt] [initial selection]\\n\", stderr);\n\texit(2);\n}\n\nint\nmain(int argc, char **argv) {\n\tfor (int i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-v\")) {\n\t\t\tputs(\"vis-menu \" VERSION);\n\t\t\texit(0);\n\t\t} else if (!strcmp(argv[i], \"-i\")) {\n\t\t\tfstrncmp = strncasecmp;\n\t\t} else if (!strcmp(argv[i], \"-t\")) {\n\t\t\tbarpos = +1;\n\t\t} else if (!strcmp(argv[i], \"-b\")) {\n\t\t\tbarpos = -1;\n\t\t} else if (argv[i][0] != '-') {\n\t\t\tstrncpy(text, argv[i], sizeof(text)-1);\n\t\t\tcursor = strlen(text);\n\t\t} else if (i + 1 == argc) {\n\t\t\tusage();\n\t\t} else if (!strcmp(argv[i], \"-p\")) {\n\t\t\tprompt = argv[++i];\n\t\t\tif (prompt && !prompt[0])\n\t\t\t\tprompt = NULL;\n\t\t} else if (!strcmp(argv[i], \"-l\")) {\n\t\t\terrno = 0;\n\t\t\tlines = strtoul(argv[++i], NULL, 10);\n\t\t\tif (errno)\n\t\t\t\tusage();\n\t\t} else {\n\t\t\tusage();\n\t\t}\n\t}\n\n\treadstdin();\n\tsetup();\n\tint status = run();\n\tcleanup();\n\treturn status;\n}\n"
        },
        {
          "name": "vis-modes.c",
          "type": "blob",
          "size": 8.0908203125,
          "content": "#include <string.h>\n#include <strings.h>\n#include \"vis-core.h\"\n#include \"text-motions.h\"\n#include \"util.h\"\n\nstatic void keyaction_free(KeyAction *action) {\n\tif (!action)\n\t\treturn;\n\tfree((char*)action->name);\n\tfree(VIS_HELP_USE((char*)action->help));\n\tfree(action);\n}\n\nKeyAction *vis_action_new(Vis *vis, const char *name, const char *help, KeyActionFunction *func, Arg arg) {\n\tKeyAction *action = calloc(1, sizeof *action);\n\tif (!action)\n\t\treturn NULL;\n\tif (name && !(action->name = strdup(name)))\n\t\tgoto err;\n#if CONFIG_HELP\n\tif (help && !(action->help = strdup(help)))\n\t\tgoto err;\n#endif\n\taction->func = func;\n\taction->arg = arg;\n\tif (!array_add_ptr(&vis->actions_user, action))\n\t\tgoto err;\n\treturn action;\nerr:\n\tkeyaction_free(action);\n\treturn NULL;\n}\n\nvoid vis_action_free(Vis *vis, KeyAction *action) {\n\tif (!action)\n\t\treturn;\n\tsize_t len = vis->actions_user.len;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (action == array_get_ptr(&vis->actions_user, i)) {\n\t\t\tkeyaction_free(action);\n\t\t\tarray_remove(&vis->actions_user, i);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nKeyBinding *vis_binding_new(Vis *vis) {\n\tKeyBinding *binding = calloc(1, sizeof *binding);\n\tif (binding && array_add_ptr(&vis->bindings, binding))\n\t\treturn binding;\n\tfree(binding);\n\treturn NULL;\n}\n\nvoid vis_binding_free(Vis *vis, KeyBinding *binding) {\n\tif (!binding)\n\t\treturn;\n\tsize_t len = vis->bindings.len;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tif (binding == array_get_ptr(&vis->bindings, i)) {\n\t\t\tif (binding->alias)\n\t\t\t\tfree((char*)binding->alias);\n\t\t\tif (binding->action && !binding->action->name)\n\t\t\t\tvis_action_free(vis, (KeyAction*)binding->action);\n\t\t\tfree(binding);\n\t\t\tarray_remove(&vis->bindings, i);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nMode *mode_get(Vis *vis, enum VisMode mode) {\n\tif (mode < LENGTH(vis_modes))\n\t\treturn &vis_modes[mode];\n\treturn NULL;\n}\n\nvoid mode_set(Vis *vis, Mode *new_mode) {\n\tif (vis->mode == new_mode)\n\t\treturn;\n\tif (vis->mode->leave)\n\t\tvis->mode->leave(vis, new_mode);\n\tif (vis->mode != &vis_modes[VIS_MODE_OPERATOR_PENDING])\n\t\tvis->mode_prev = vis->mode;\n\tvis->mode = new_mode;\n\tif (new_mode->enter)\n\t\tnew_mode->enter(vis, vis->mode_prev);\n}\n\nvoid vis_mode_switch(Vis *vis, enum VisMode mode) {\n\tif (mode < LENGTH(vis_modes))\n\t\tmode_set(vis, &vis_modes[mode]);\n}\n\nenum VisMode vis_mode_from(Vis *vis, const char *name) {\n\tfor (size_t i = 0; name && i < LENGTH(vis_modes); i++) {\n\t\tMode *mode = &vis_modes[i];\n\t\tif (!strcasecmp(mode->name, name))\n\t\t\treturn mode->id;\n\t}\n\treturn VIS_MODE_INVALID;\n}\n\nenum VisMode vis_mode_get(Vis *vis) {\n\treturn vis->mode->id;\n}\n\nstatic bool mode_unmap(Mode *mode, const char *key) {\n\treturn mode && mode->bindings && map_delete(mode->bindings, key);\n}\n\nbool vis_mode_unmap(Vis *vis, enum VisMode id, const char *key) {\n\treturn id < LENGTH(vis_modes) && mode_unmap(&vis_modes[id], key);\n}\n\nbool vis_window_mode_unmap(Win *win, enum VisMode id, const char *key) {\n\treturn id < LENGTH(win->modes) && mode_unmap(&win->modes[id], key);\n}\n\nstatic bool mode_map(Vis *vis, Mode *mode, bool force, const char *key, const KeyBinding *binding) {\n\tif (!mode)\n\t\treturn false;\n\tif (binding->alias && key[0] != '<' && strncmp(key, binding->alias, strlen(key)) == 0)\n\t\treturn false;\n\tif (!mode->bindings && !(mode->bindings = map_new()))\n\t\treturn false;\n\tif (force)\n\t\tmap_delete(mode->bindings, key);\n\treturn map_put(mode->bindings, key, binding);\n}\n\nbool vis_mode_map(Vis *vis, enum VisMode id, bool force, const char *key, const KeyBinding *binding) {\n\treturn id < LENGTH(vis_modes) && mode_map(vis, &vis_modes[id], force, key, binding);\n}\n\nbool vis_window_mode_map(Win *win, enum VisMode id, bool force, const char *key, const KeyBinding *binding) {\n\treturn id < LENGTH(win->modes) && mode_map(win->vis, &win->modes[id], force, key, binding);\n}\n\n/** mode switching event handlers */\n\nstatic void vis_mode_normal_enter(Vis *vis, Mode *old) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tif (old != mode_get(vis, VIS_MODE_INSERT) && old != mode_get(vis, VIS_MODE_REPLACE))\n\t\treturn;\n\tif (vis->autoindent && strcmp(vis->key_prev, \"<Enter>\") == 0) {\n\t\tText *txt = win->file->text;\n\t\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\t\tsize_t pos = view_cursors_pos(s);\n\t\t\tsize_t start = text_line_start(txt, pos);\n\t\t\tsize_t end = text_line_end(txt, pos);\n\t\t\tif (start == pos && start == end) {\n\t\t\t\tsize_t begin = text_line_begin(txt, pos);\n\t\t\t\tsize_t len = start - begin;\n\t\t\t\tif (len) {\n\t\t\t\t\ttext_delete(txt, begin, len);\n\t\t\t\t\tview_cursors_to(s, pos-len);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmacro_operator_stop(vis);\n\tif (!win->parent && vis->action_prev.op == &vis_operators[VIS_OP_MODESWITCH] &&\n\t    vis->action_prev.count > 1) {\n\t\t/* temporarily disable motion, in something like `5atext`\n\t\t * we should only move the cursor once then insert the text */\n\t\tconst Movement *motion = vis->action_prev.movement;\n\t\tif (motion)\n\t\t\tvis->action_prev.movement = &vis_motions[VIS_MOVE_NOP];\n\t\t/* we already inserted the text once, so temporarily decrease count */\n\t\tvis->action_prev.count--;\n\t\tvis_repeat(vis);\n\t\tvis->action_prev.count++;\n\t\tvis->action_prev.movement = motion;\n\t}\n\t/* make sure we can recover the current state after an editing operation */\n\tvis_file_snapshot(vis, win->file);\n}\n\nstatic void vis_mode_operator_input(Vis *vis, const char *str, size_t len) {\n\t/* invalid operator */\n\tvis_cancel(vis);\n\tmode_set(vis, vis->mode_prev);\n}\n\nstatic void vis_mode_visual_enter(Vis *vis, Mode *old) {\n\tWin *win = vis->win;\n\tif (!old->visual && win) {\n\t\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s))\n\t\t\ts->anchored = true;\n\t}\n}\n\nstatic void vis_mode_visual_line_enter(Vis *vis, Mode *old) {\n\tWin *win = vis->win;\n\tif (!old->visual && win) {\n\t\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s))\n\t\t\ts->anchored = true;\n\t}\n\tif (!vis->action.op)\n\t\tvis_motion(vis, VIS_MOVE_NOP);\n}\n\nstatic void vis_mode_visual_line_leave(Vis *vis, Mode *new) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tif (!new->visual) {\n\t\tif (!vis->action.op)\n\t\t\twindow_selection_save(win);\n\t\tview_selections_clear_all(&win->view);\n\t} else {\n\t\tview_cursors_to(win->view.selection, view_cursor_get(&win->view));\n\t}\n}\n\nstatic void vis_mode_visual_leave(Vis *vis, Mode *new) {\n\tWin *win = vis->win;\n\tif (!new->visual && win) {\n\t\tif (!vis->action.op)\n\t\t\twindow_selection_save(win);\n\t\tview_selections_clear_all(&win->view);\n\t}\n}\n\nstatic void vis_mode_insert_replace_enter(Vis *vis, Mode *old) {\n\tif (!vis->win || vis->win->parent)\n\t\treturn;\n\tif (!vis->action.op) {\n\t\taction_reset(&vis->action_prev);\n\t\tvis->action_prev.op = &vis_operators[VIS_OP_MODESWITCH];\n\t\tvis->action_prev.mode = vis->mode->id;\n\t}\n\tmacro_operator_record(vis);\n}\n\nstatic void vis_mode_insert_idle(Vis *vis) {\n\tWin *win = vis->win;\n\tif (win)\n\t\tvis_file_snapshot(vis, win->file);\n}\n\nstatic void vis_mode_insert_input(Vis *vis, const char *str, size_t len) {\n\tvis_insert_key(vis, str, len);\n}\n\nstatic void vis_mode_replace_input(Vis *vis, const char *str, size_t len) {\n\tvis_replace_key(vis, str, len);\n}\n\nMode vis_modes[] = {\n\t[VIS_MODE_OPERATOR_PENDING] = {\n\t\t.id = VIS_MODE_OPERATOR_PENDING,\n\t\t.name = \"OPERATOR-PENDING\",\n\t\t.input = vis_mode_operator_input,\n\t\t.help = \"\",\n\t},\n\t[VIS_MODE_NORMAL] = {\n\t\t.id = VIS_MODE_NORMAL,\n\t\t.name = \"NORMAL\",\n\t\t.help = \"\",\n\t\t.enter = vis_mode_normal_enter,\n\t},\n\t[VIS_MODE_VISUAL] = {\n\t\t.id = VIS_MODE_VISUAL,\n\t\t.name = \"VISUAL\",\n\t\t.status = \"VISUAL\",\n\t\t.help = \"\",\n\t\t.enter = vis_mode_visual_enter,\n\t\t.leave = vis_mode_visual_leave,\n\t\t.visual = true,\n\t},\n\t[VIS_MODE_VISUAL_LINE] = {\n\t\t.id = VIS_MODE_VISUAL_LINE,\n\t\t.name = \"VISUAL-LINE\",\n\t\t.parent = &vis_modes[VIS_MODE_VISUAL],\n\t\t.status = \"VISUAL-LINE\",\n\t\t.help = \"\",\n\t\t.enter = vis_mode_visual_line_enter,\n\t\t.leave = vis_mode_visual_line_leave,\n\t\t.visual = true,\n\t},\n\t[VIS_MODE_INSERT] = {\n\t\t.id = VIS_MODE_INSERT,\n\t\t.name = \"INSERT\",\n\t\t.status = \"INSERT\",\n\t\t.help = \"\",\n\t\t.enter = vis_mode_insert_replace_enter,\n\t\t.input = vis_mode_insert_input,\n\t\t.idle = vis_mode_insert_idle,\n\t\t.idle_timeout = 3,\n\t},\n\t[VIS_MODE_REPLACE] = {\n\t\t.id = VIS_MODE_REPLACE,\n\t\t.name = \"REPLACE\",\n\t\t.parent = &vis_modes[VIS_MODE_INSERT],\n\t\t.status = \"REPLACE\",\n\t\t.help = \"\",\n\t\t.enter = vis_mode_insert_replace_enter,\n\t\t.input = vis_mode_replace_input,\n\t\t.idle = vis_mode_insert_idle,\n\t\t.idle_timeout = 3,\n\t},\n};\n\n"
        },
        {
          "name": "vis-motions.c",
          "type": "blob",
          "size": 14.9765625,
          "content": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include \"vis-core.h\"\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"text-util.h\"\n#include \"util.h\"\n\nstatic Regex *search_word(Vis *vis, Text *txt, size_t pos) {\n\tchar expr[512];\n\tFilerange word = text_object_word(txt, pos);\n\tif (!text_range_valid(&word))\n\t\treturn NULL;\n\tchar *buf = text_bytes_alloc0(txt, word.start, text_range_size(&word));\n\tif (!buf)\n\t\treturn NULL;\n\tsnprintf(expr, sizeof(expr), \"[[:<:]]%s[[:>:]]\", buf);\n\tRegex *regex = vis_regex(vis, expr);\n\tif (!regex) {\n\t\tsnprintf(expr, sizeof(expr), \"\\\\<%s\\\\>\", buf);\n\t\tregex = vis_regex(vis, expr);\n\t}\n\tfree(buf);\n\treturn regex;\n}\n\nstatic size_t search_word_forward(Vis *vis, Text *txt, size_t pos) {\n\tRegex *regex = search_word(vis, txt, pos);\n\tif (regex) {\n\t\tvis->search_direction = VIS_MOVE_SEARCH_REPEAT_FORWARD;\n\t\tpos = text_search_forward(txt, pos, regex);\n\t}\n\ttext_regex_free(regex);\n\treturn pos;\n}\n\nstatic size_t search_word_backward(Vis *vis, Text *txt, size_t pos) {\n\tRegex *regex = search_word(vis, txt, pos);\n\tif (regex) {\n\t\tvis->search_direction = VIS_MOVE_SEARCH_REPEAT_BACKWARD;\n\t\tpos = text_search_backward(txt, pos, regex);\n\t}\n\ttext_regex_free(regex);\n\treturn pos;\n}\n\nstatic size_t search_forward(Vis *vis, Text *txt, size_t pos) {\n\tRegex *regex = vis_regex(vis, NULL);\n\tif (regex)\n\t\tpos = text_search_forward(txt, pos, regex);\n\ttext_regex_free(regex);\n\treturn pos;\n}\n\nstatic size_t search_backward(Vis *vis, Text *txt, size_t pos) {\n\tRegex *regex = vis_regex(vis, NULL);\n\tif (regex)\n\t\tpos = text_search_backward(txt, pos, regex);\n\ttext_regex_free(regex);\n\treturn pos;\n}\n\nstatic size_t common_word_next(Vis *vis, Text *txt, size_t pos,\n                               enum VisMotion start_next, enum VisMotion end_next,\n                               int (*isboundary)(int)) {\n\tchar c;\n\tIterator it = text_iterator_get(txt, pos);\n\tif (!text_iterator_byte_get(&it, &c))\n\t\treturn pos;\n\tconst Movement *motion = NULL;\n\tint count = VIS_COUNT_DEFAULT(vis->action.count, 1);\n\tif (isspace((unsigned char)c)) {\n\t\tmotion = &vis_motions[start_next];\n\t} else if (!isboundary((unsigned char)c) && text_iterator_char_next(&it, &c) && isboundary((unsigned char)c)) {\n\t\t/* we are on the last character of a word */\n\t\tif (count == 1) {\n\t\t\t/* map `cw` to `cl` */\n\t\t\tmotion = &vis_motions[VIS_MOVE_CHAR_NEXT];\n\t\t} else {\n\t\t\t/* map `c{n}w` to `c{n-1}e` */\n\t\t\tcount--;\n\t\t\tmotion = &vis_motions[end_next];\n\t\t}\n\t} else {\n\t\t/* map `cw` to `ce` */\n\t\tmotion = &vis_motions[end_next];\n\t}\n\n\twhile (count--) {\n\t\tif (vis->interrupted)\n\t\t\treturn pos;\n\t\tsize_t newpos = motion->txt(txt, pos);\n\t\tif (newpos == pos)\n\t\t\tbreak;\n\t\tpos = newpos;\n\t}\n\n\tif (motion->type & INCLUSIVE)\n\t\tpos = text_char_next(txt, pos);\n\n\treturn pos;\n}\n\nstatic size_t word_next(Vis *vis, Text *txt, size_t pos) {\n\treturn common_word_next(vis, txt, pos, VIS_MOVE_WORD_START_NEXT,\n\t                        VIS_MOVE_WORD_END_NEXT, is_word_boundary);\n}\n\nstatic size_t longword_next(Vis *vis, Text *txt, size_t pos) {\n\treturn common_word_next(vis, txt, pos, VIS_MOVE_LONGWORD_START_NEXT,\n\t                        VIS_MOVE_LONGWORD_END_NEXT, isspace);\n}\n\nstatic size_t to_right(Vis *vis, Text *txt, size_t pos) {\n\tchar c;\n\tsize_t hit = text_find_next(txt, pos+1, vis->search_char);\n\tif (!text_byte_get(txt, hit, &c) || c != vis->search_char[0])\n\t\treturn pos;\n\treturn hit;\n}\n\nstatic size_t till_right(Vis *vis, Text *txt, size_t pos) {\n\tsize_t hit = to_right(vis, txt, pos+1);\n\tif (hit != pos)\n\t\treturn text_char_prev(txt, hit);\n\treturn pos;\n}\n\nstatic size_t to_left(Vis *vis, Text *txt, size_t pos) {\n\treturn text_find_prev(txt, pos, vis->search_char);\n}\n\nstatic size_t till_left(Vis *vis, Text *txt, size_t pos) {\n\tsize_t hit = to_left(vis, txt, pos-1);\n\tif (hit != pos-1)\n\t\treturn text_char_next(txt, hit);\n\treturn pos;\n}\n\nstatic size_t to_line_right(Vis *vis, Text *txt, size_t pos) {\n\tchar c;\n\tif (pos == text_line_end(txt, pos))\n\t\treturn pos;\n\tsize_t hit = text_line_find_next(txt, pos+1, vis->search_char);\n\tif (!text_byte_get(txt, hit, &c) || c != vis->search_char[0])\n\t\treturn pos;\n\treturn hit;\n}\n\nstatic size_t till_line_right(Vis *vis, Text *txt, size_t pos) {\n\tsize_t hit = to_line_right(vis, txt, pos+1);\n\tif (pos == text_line_end(txt, pos))\n\t\treturn pos;\n\tif (hit != pos)\n\t\treturn text_char_prev(txt, hit);\n\treturn pos;\n}\n\nstatic size_t to_line_left(Vis *vis, Text *txt, size_t pos) {\n\treturn text_line_find_prev(txt, pos, vis->search_char);\n}\n\nstatic size_t till_line_left(Vis *vis, Text *txt, size_t pos) {\n\tif (pos == text_line_begin(txt, pos))\n\t\treturn pos;\n\tsize_t hit = to_line_left(vis, txt, pos-1);\n\tif (hit != pos-1)\n\t\treturn text_char_next(txt, hit);\n\treturn pos;\n}\n\nstatic size_t firstline(Text *txt, size_t pos) {\n\treturn text_line_start(txt, 0);\n}\n\nstatic size_t line(Vis *vis, Text *txt, size_t pos) {\n\tint count = VIS_COUNT_DEFAULT(vis->action.count, 1);\n\treturn text_line_start(txt, text_pos_by_lineno(txt, count));\n}\n\nstatic size_t lastline(Text *txt, size_t pos) {\n\tpos = text_size(txt);\n\treturn text_line_start(txt, pos > 0 ? pos-1 : pos);\n}\n\nstatic size_t column(Vis *vis, Text *txt, size_t pos) {\n\treturn text_line_offset(txt, pos, VIS_COUNT_DEFAULT(vis->action.count, 0));\n}\n\nstatic size_t view_lines_top(Vis *vis, View *view) {\n\treturn view_screenline_goto(view, VIS_COUNT_DEFAULT(vis->action.count, 1));\n}\n\nstatic size_t view_lines_middle(Vis *vis, View *view) {\n\tint h = view->height;\n\treturn view_screenline_goto(view, h/2);\n}\n\nstatic size_t view_lines_bottom(Vis *vis, View *view) {\n\tint h = view->height;\n\treturn view_screenline_goto(view, h - VIS_COUNT_DEFAULT(vis->action.count, 0));\n}\n\nstatic size_t window_nop(Vis *vis, Win *win, size_t pos) {\n\treturn pos;\n}\n\nstatic size_t bracket_match(Text *txt, size_t pos) {\n\tsize_t hit = text_bracket_match_symbol(txt, pos, \"(){}[]<>'\\\"`\", NULL);\n\tif (hit != pos)\n\t\treturn hit;\n\tchar current;\n\tIterator it = text_iterator_get(txt, pos);\n\twhile (text_iterator_byte_get(&it, &current)) {\n\t\tswitch (current) {\n\t\tcase '(':\n\t\tcase ')':\n\t\tcase '{':\n\t\tcase '}':\n\t\tcase '[':\n\t\tcase ']':\n\t\tcase '<':\n\t\tcase '>':\n\t\tcase '\"':\n\t\tcase '\\'':\n\t\tcase '`':\n\t\t\treturn it.pos;\n\t\t}\n\t\ttext_iterator_byte_next(&it, NULL);\n\t}\n\treturn pos;\n}\n\nstatic size_t percent(Vis *vis, Text *txt, size_t pos) {\n\tint ratio = VIS_COUNT_DEFAULT(vis->action.count, 0);\n\tif (ratio > 100)\n\t\tratio = 100;\n\treturn text_size(txt) * ratio / 100;\n}\n\nstatic size_t byte(Vis *vis, Text *txt, size_t pos) {\n\tpos = VIS_COUNT_DEFAULT(vis->action.count, 0);\n\tsize_t max = text_size(txt);\n\treturn pos <= max ? pos : max;\n}\n\nstatic size_t byte_left(Vis *vis, Text *txt, size_t pos) {\n\tsize_t off = VIS_COUNT_DEFAULT(vis->action.count, 1);\n\treturn off <= pos ? pos-off : 0;\n}\n\nstatic size_t byte_right(Vis *vis, Text *txt, size_t pos) {\n\tsize_t off = VIS_COUNT_DEFAULT(vis->action.count, 1);\n\tsize_t new = pos + off;\n\tsize_t max = text_size(txt);\n\treturn new <= max && new > pos ? new : max;\n}\n\nvoid vis_motion_type(Vis *vis, enum VisMotionType type) {\n\tvis->action.type = type;\n}\n\nint vis_motion_register(Vis *vis, void *data, VisMotionFunction *motion) {\n\n\tMovement *move = calloc(1, sizeof *move);\n\tif (!move)\n\t\treturn -1;\n\n\tmove->user = motion;\n\tmove->data = data;\n\n\tif (array_add_ptr(&vis->motions, move))\n\t\treturn VIS_MOVE_LAST + vis->motions.len - 1;\n\tfree(move);\n\treturn -1;\n}\n\nbool vis_motion(Vis *vis, enum VisMotion motion, ...) {\n\tva_list ap;\n\tva_start(ap, motion);\n\n\tswitch (motion) {\n\tcase VIS_MOVE_WORD_START_NEXT:\n\t\tif (vis->action.op == &vis_operators[VIS_OP_CHANGE])\n\t\t\tmotion = VIS_MOVE_WORD_NEXT;\n\t\tbreak;\n\tcase VIS_MOVE_LONGWORD_START_NEXT:\n\t\tif (vis->action.op == &vis_operators[VIS_OP_CHANGE])\n\t\t\tmotion = VIS_MOVE_LONGWORD_NEXT;\n\t\tbreak;\n\tcase VIS_MOVE_SEARCH_FORWARD:\n\tcase VIS_MOVE_SEARCH_BACKWARD:\n\t{\n\t\tconst char *pattern = va_arg(ap, char*);\n\t\tRegex *regex = vis_regex(vis, pattern);\n\t\tif (!regex) {\n\t\t\tvis_cancel(vis);\n\t\t\tgoto err;\n\t\t}\n\t\ttext_regex_free(regex);\n\t\tif (motion == VIS_MOVE_SEARCH_FORWARD)\n\t\t\tmotion = VIS_MOVE_SEARCH_REPEAT_FORWARD;\n\t\telse\n\t\t\tmotion = VIS_MOVE_SEARCH_REPEAT_BACKWARD;\n\t\tvis->search_direction = motion;\n\t\tbreak;\n\t}\n\tcase VIS_MOVE_SEARCH_REPEAT:\n\tcase VIS_MOVE_SEARCH_REPEAT_REVERSE:\n\t{\n\t\tif (!vis->search_direction)\n\t\t\tvis->search_direction = VIS_MOVE_SEARCH_REPEAT_FORWARD;\n\t\tif (motion == VIS_MOVE_SEARCH_REPEAT) {\n\t\t\tmotion = vis->search_direction;\n\t\t} else {\n\t\t\tmotion = vis->search_direction == VIS_MOVE_SEARCH_REPEAT_FORWARD ?\n\t\t\t                                  VIS_MOVE_SEARCH_REPEAT_BACKWARD :\n\t\t\t                                  VIS_MOVE_SEARCH_REPEAT_FORWARD;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIS_MOVE_TO_RIGHT:\n\tcase VIS_MOVE_TO_LEFT:\n\tcase VIS_MOVE_TO_LINE_RIGHT:\n\tcase VIS_MOVE_TO_LINE_LEFT:\n\tcase VIS_MOVE_TILL_RIGHT:\n\tcase VIS_MOVE_TILL_LEFT:\n\tcase VIS_MOVE_TILL_LINE_RIGHT:\n\tcase VIS_MOVE_TILL_LINE_LEFT:\n\t{\n\t\tconst char *key = va_arg(ap, char*);\n\t\tif (!key)\n\t\t\tgoto err;\n\t\tstrncpy(vis->search_char, key, sizeof(vis->search_char));\n\t\tvis->search_char[sizeof(vis->search_char)-1] = '\\0';\n\t\tvis->last_totill = motion;\n\t\tbreak;\n\t}\n\tcase VIS_MOVE_TOTILL_REPEAT:\n\t\tif (!vis->last_totill)\n\t\t\tgoto err;\n\t\tmotion = vis->last_totill;\n\t\tbreak;\n\tcase VIS_MOVE_TOTILL_REVERSE:\n\t\tswitch (vis->last_totill) {\n\t\tcase VIS_MOVE_TO_RIGHT:\n\t\t\tmotion = VIS_MOVE_TO_LEFT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TO_LEFT:\n\t\t\tmotion = VIS_MOVE_TO_RIGHT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TO_LINE_RIGHT:\n\t\t\tmotion = VIS_MOVE_TO_LINE_LEFT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TO_LINE_LEFT:\n\t\t\tmotion = VIS_MOVE_TO_LINE_RIGHT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TILL_RIGHT:\n\t\t\tmotion = VIS_MOVE_TILL_LEFT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TILL_LEFT:\n\t\t\tmotion = VIS_MOVE_TILL_RIGHT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TILL_LINE_RIGHT:\n\t\t\tmotion = VIS_MOVE_TILL_LINE_LEFT;\n\t\t\tbreak;\n\t\tcase VIS_MOVE_TILL_LINE_LEFT:\n\t\t\tmotion = VIS_MOVE_TILL_LINE_RIGHT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (motion < LENGTH(vis_motions))\n\t\tvis->action.movement = &vis_motions[motion];\n\telse\n\t\tvis->action.movement = array_get_ptr(&vis->motions, motion - VIS_MOVE_LAST);\n\n\tif (!vis->action.movement)\n\t\tgoto err;\n\n\tva_end(ap);\n\tvis_do(vis);\n\treturn true;\nerr:\n\tva_end(ap);\n\treturn false;\n}\n\nconst Movement vis_motions[] = {\n\t[VIS_MOVE_LINE_UP] = {\n\t\t.cur = view_line_up,\n\t\t.type = LINEWISE|LINEWISE_INCLUSIVE,\n\t},\n\t[VIS_MOVE_LINE_DOWN] = {\n\t\t.cur = view_line_down,\n\t\t.type = LINEWISE|LINEWISE_INCLUSIVE,\n\t},\n\t[VIS_MOVE_SCREEN_LINE_UP] = {\n\t\t.cur = view_screenline_up,\n\t},\n\t[VIS_MOVE_SCREEN_LINE_DOWN] = {\n\t\t.cur = view_screenline_down,\n\t},\n\t[VIS_MOVE_SCREEN_LINE_BEGIN] = {\n\t\t.cur = view_screenline_begin,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_SCREEN_LINE_MIDDLE] = {\n\t\t.cur = view_screenline_middle,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_SCREEN_LINE_END] = {\n\t\t.cur = view_screenline_end,\n\t\t.type = CHARWISE|INCLUSIVE,\n\t},\n\t[VIS_MOVE_LINE_PREV] = {\n\t\t.txt = text_line_prev,\n\t},\n\t[VIS_MOVE_LINE_BEGIN] = {\n\t\t.txt = text_line_begin,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_LINE_START] = {\n\t\t.txt = text_line_start,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_LINE_FINISH] = {\n\t\t.txt = text_line_finish,\n\t\t.type = INCLUSIVE|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_LINE_END] = {\n\t\t.txt = text_line_end,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_LINE_NEXT] = {\n\t\t.txt = text_line_next,\n\t},\n\t[VIS_MOVE_LINE] = {\n\t\t.vis = line,\n\t\t.type = LINEWISE|IDEMPOTENT|JUMP,\n\t},\n\t[VIS_MOVE_COLUMN] = {\n\t\t.vis = column,\n\t\t.type = CHARWISE|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_CHAR_PREV] = {\n\t\t.txt = text_char_prev,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_CHAR_NEXT] = {\n\t\t.txt = text_char_next,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_LINE_CHAR_PREV] = {\n\t\t.txt = text_line_char_prev,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_LINE_CHAR_NEXT] = {\n\t\t.txt = text_line_char_next,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_CODEPOINT_PREV] = {\n\t\t.txt = text_codepoint_prev,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_CODEPOINT_NEXT] = {\n\t\t.txt = text_codepoint_next,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_WORD_NEXT] = {\n\t\t.vis = word_next,\n\t\t.type = CHARWISE|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_WORD_START_PREV] = {\n\t\t.txt = text_word_start_prev,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_WORD_START_NEXT] = {\n\t\t.txt = text_word_start_next,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_WORD_END_PREV] = {\n\t\t.txt = text_word_end_prev,\n\t\t.type = CHARWISE|INCLUSIVE,\n\t},\n\t[VIS_MOVE_WORD_END_NEXT] = {\n\t\t.txt = text_word_end_next,\n\t\t.type = CHARWISE|INCLUSIVE,\n\t},\n\t[VIS_MOVE_LONGWORD_NEXT] = {\n\t\t.vis = longword_next,\n\t\t.type = CHARWISE|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_LONGWORD_START_PREV] = {\n\t\t.txt = text_longword_start_prev,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_LONGWORD_START_NEXT] = {\n\t\t.txt = text_longword_start_next,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_LONGWORD_END_PREV] = {\n\t\t.txt = text_longword_end_prev,\n\t\t.type = CHARWISE|INCLUSIVE,\n\t},\n\t[VIS_MOVE_LONGWORD_END_NEXT] = {\n\t\t.txt = text_longword_end_next,\n\t\t.type = CHARWISE|INCLUSIVE,\n\t},\n\t[VIS_MOVE_SENTENCE_PREV] = {\n\t\t.txt = text_sentence_prev,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_SENTENCE_NEXT] = {\n\t\t.txt = text_sentence_next,\n\t\t.type = CHARWISE,\n\t},\n\t[VIS_MOVE_PARAGRAPH_PREV] = {\n\t\t.txt = text_paragraph_prev,\n\t\t.type = LINEWISE|JUMP,\n\t},\n\t[VIS_MOVE_PARAGRAPH_NEXT] = {\n\t\t.txt = text_paragraph_next,\n\t\t.type = LINEWISE|JUMP,\n\t},\n\t[VIS_MOVE_BLOCK_START] = {\n\t\t.txt = text_block_start,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_BLOCK_END] = {\n\t\t.txt = text_block_end,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_PARENTHESIS_START] = {\n\t\t.txt = text_parenthesis_start,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_PARENTHESIS_END] = {\n\t\t.txt = text_parenthesis_end,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_BRACKET_MATCH] = {\n\t\t.txt = bracket_match,\n\t\t.type = INCLUSIVE|JUMP,\n\t},\n\t[VIS_MOVE_FILE_BEGIN] = {\n\t\t.txt = firstline,\n\t\t.type = LINEWISE|LINEWISE_INCLUSIVE|JUMP|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_FILE_END] = {\n\t\t.txt = lastline,\n\t\t.type = LINEWISE|LINEWISE_INCLUSIVE|JUMP|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_TO_LEFT] = {\n\t\t.vis = to_left,\n\t\t.type = COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TO_RIGHT] = {\n\t\t.vis = to_right,\n\t\t.type = INCLUSIVE|COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TO_LINE_LEFT] = {\n\t\t.vis = to_line_left,\n\t\t.type = COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TO_LINE_RIGHT] = {\n\t\t.vis = to_line_right,\n\t\t.type = INCLUSIVE|COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TILL_LEFT] = {\n\t\t.vis = till_left,\n\t\t.type = COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TILL_RIGHT] = {\n\t\t.vis = till_right,\n\t\t.type = INCLUSIVE|COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TILL_LINE_LEFT] = {\n\t\t.vis = till_line_left,\n\t\t.type = COUNT_EXACT,\n\t},\n\t[VIS_MOVE_TILL_LINE_RIGHT] = {\n\t\t.vis = till_line_right,\n\t\t.type = INCLUSIVE|COUNT_EXACT,\n\t},\n\t[VIS_MOVE_SEARCH_WORD_FORWARD] = {\n\t\t.vis = search_word_forward,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_SEARCH_WORD_BACKWARD] = {\n\t\t.vis = search_word_backward,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_SEARCH_REPEAT_FORWARD] = {\n\t\t.vis = search_forward,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_SEARCH_REPEAT_BACKWARD] = {\n\t\t.vis = search_backward,\n\t\t.type = JUMP,\n\t},\n\t[VIS_MOVE_WINDOW_LINE_TOP] = {\n\t\t.view = view_lines_top,\n\t\t.type = LINEWISE|JUMP|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_WINDOW_LINE_MIDDLE] = {\n\t\t.view = view_lines_middle,\n\t\t.type = LINEWISE|JUMP|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_WINDOW_LINE_BOTTOM] = {\n\t\t.view = view_lines_bottom,\n\t\t.type = LINEWISE|JUMP|IDEMPOTENT,\n\t},\n\t[VIS_MOVE_NOP] = {\n\t\t.win = window_nop,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_PERCENT] = {\n\t\t.vis = percent,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_BYTE] = {\n\t\t.vis = byte,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_BYTE_LEFT] = {\n\t\t.vis = byte_left,\n\t\t.type = IDEMPOTENT,\n\t},\n\t[VIS_MOVE_BYTE_RIGHT] = {\n\t\t.vis = byte_right,\n\t\t.type = IDEMPOTENT,\n\t},\n};\n"
        },
        {
          "name": "vis-open",
          "type": "blob",
          "size": 2.15234375,
          "content": "#!/bin/sh\nset -e\n\n# Later, we're going to want to set $IFS to a single newline, so let's prepare one.\nNL='\n'\n\nfatal() {\n\techo \"$@\" >&2\n\texit 1\n}\n\nusage() {\n\tfatal \"Usage: $(basename \"$0\") [-f] [-p prompt] [--] [file-pattern]\n\nInteractively select a file to open\n\nOptions:\n    -f            always present given arguments, even when there is only one\n    -p            use prompt as prompt string\n    file-pattern  list of filenames and directories\"\n}\n\n# print a list of filenames on stdin and distinguish directories\nwrap_dirs() {\n\twhile read -r filename\n\tdo\n\t\tif [ -d \"$filename\" ]; then\n\t\t\tprintf '%s/\\n' \"$filename\"\n\t\telse\n\t\t\tprintf '%s\\n' \"$filename\"\n\t\tfi\n\tdone\n}\n\nVIS_OPEN_LINES=\"${VIS_OPEN_LINES:-0}\"\nVIS_MENU_PROMPT=''\nALLOW_AUTO_SELECT='1'\n\nwhile getopts fhp: opt; do\n\tcase \"$opt\" in\n\tf)\n\t\tALLOW_AUTO_SELECT=''\n\t\t;;\n\tp)\n\t\tVIS_MENU_PROMPT=\"$OPTARG\"\n\t\t;;\n\t*)\n\t\tusage\n\t\t;;\n\tesac\ndone\nshift \"$((OPTIND - 1))\"\n\n# At this point, all the remaining arguments should be the expansion of\n# any globs that were passed on the command line.\n\nif [ \"$#\" -eq 1 ] && [ \"$ALLOW_AUTO_SELECT\" = '1' ]; then\n\t# If there were globs on the command-line, they've expanded to\n\t# a single item, so we can just process it.\n\n\tif [ -d \"$1\" ]; then\n\t\t# Recurse and show the contents of the named directory,\n\t\t# We pass -f to force the next iteration to present the\n\t\t# full list, even if it's just an empty directory.\n\t\tcd \"$1\"\n\t\tIFS=\"$NL\"  # Don't split ls output on tabs or spaces.\n\t\texec \"$0\" -p \"$VIS_MENU_PROMPT\" -f \"$(ls -1)\"\n\telse\n\t\t# We've found a single item, and it's not a directory,\n\t\t# so it must be a filename (or file-like thing) to open,\n\t\t# unless the parent directory does not exist.\n\t\tparentdir=\"$(dirname -- \"$1\")\"\n\t\tif [ -d \"$parentdir\" ]; then\n\t\t\tcd \"$parentdir\"\n\t\t\tprintf '%s/%s\\n' \"$(pwd -P)\" \"$(basename -- \"${1%\\*}\")\"\n\t\t\texit 0\n\t\telse\n\t\t\texit 1\n\t\tfi\n\tfi\nfi\n\n# At this point, we have a bunch of options we need to present to the\n# user so they can pick one.\nCHOICE=\"$(printf '%s\\n' '..' \"$@\" | wrap_dirs | vis-menu -b -l \"$VIS_OPEN_LINES\" -p \"$VIS_MENU_PROMPT\")\"\n\n# Did they pick a file or directory? Who knows, let's let the next iteration figure it out.\nexec \"$0\" -p \"$VIS_MENU_PROMPT\" -- \"$CHOICE\"\n"
        },
        {
          "name": "vis-operators.c",
          "type": "blob",
          "size": 9.2236328125,
          "content": "#include <string.h>\n#include <ctype.h>\n#include \"vis-core.h\"\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"text-util.h\"\n#include \"util.h\"\n\nstatic size_t op_delete(Vis *vis, Text *txt, OperatorContext *c) {\n\tc->reg->linewise = c->linewise;\n\tregister_slot_put_range(vis, c->reg, c->reg_slot, txt, &c->range);\n\ttext_delete_range(txt, &c->range);\n\tsize_t pos = c->range.start;\n\tif (c->linewise && pos == text_size(txt))\n\t\tpos = text_line_begin(txt, text_line_prev(txt, pos));\n\treturn pos;\n}\n\nstatic size_t op_change(Vis *vis, Text *txt, OperatorContext *c) {\n\tbool linewise = c->linewise || text_range_is_linewise(txt, &c->range);\n\top_delete(vis, txt, c);\n\tsize_t pos = c->range.start;\n\tif (linewise) {\n\t\tsize_t newpos = vis_text_insert_nl(vis, txt, pos > 0 ? pos-1 : pos);\n\t\tif (pos > 0)\n\t\t\tpos = newpos;\n\t}\n\treturn pos;\n}\n\nstatic size_t op_yank(Vis *vis, Text *txt, OperatorContext *c) {\n\tc->reg->linewise = c->linewise;\n\tregister_slot_put_range(vis, c->reg, c->reg_slot, txt, &c->range);\n\tif (c->reg == &vis->registers[VIS_REG_DEFAULT]) {\n\t\tvis->registers[VIS_REG_ZERO].linewise = c->reg->linewise;\n\t\tregister_slot_put_range(vis, &vis->registers[VIS_REG_ZERO], c->reg_slot, txt, &c->range);\n\t}\n\treturn c->linewise ? c->pos : c->range.start;\n}\n\nstatic size_t op_put(Vis *vis, Text *txt, OperatorContext *c) {\n\tchar b;\n\tsize_t pos = c->pos;\n\tbool sel = text_range_size(&c->range) > 0;\n\tbool sel_linewise = sel && text_range_is_linewise(txt, &c->range);\n\tif (sel) {\n\t\ttext_delete_range(txt, &c->range);\n\t\tpos = c->pos = c->range.start;\n\t}\n\tswitch (c->arg->i) {\n\tcase VIS_OP_PUT_AFTER:\n\tcase VIS_OP_PUT_AFTER_END:\n\t\tif (c->reg->linewise && !sel_linewise)\n\t\t\tpos = text_line_next(txt, pos);\n\t\telse if (!sel && text_byte_get(txt, pos, &b) && b != '\\n')\n\t\t\tpos = text_char_next(txt, pos);\n\t\tbreak;\n\tcase VIS_OP_PUT_BEFORE:\n\tcase VIS_OP_PUT_BEFORE_END:\n\t\tif (c->reg->linewise)\n\t\t\tpos = text_line_begin(txt, pos);\n\t\tbreak;\n\t}\n\n\tsize_t len;\n\tconst char *data = register_slot_get(vis, c->reg, c->reg_slot, &len);\n\n\tfor (int i = 0; i < c->count; i++) {\n\t\tchar nl;\n\t\tif (c->reg->linewise && pos > 0 && text_byte_get(txt, pos-1, &nl) && nl != '\\n')\n\t\t\tpos += text_insert(txt, pos, \"\\n\", 1);\n\t\ttext_insert(txt, pos, data, len);\n\t\tpos += len;\n\t\tif (c->reg->linewise && pos > 0 && text_byte_get(txt, pos-1, &nl) && nl != '\\n')\n\t\t\tpos += text_insert(txt, pos, \"\\n\", 1);\n\t}\n\n\tif (c->reg->linewise) {\n\t\tswitch (c->arg->i) {\n\t\tcase VIS_OP_PUT_BEFORE_END:\n\t\tcase VIS_OP_PUT_AFTER_END:\n\t\t\tpos = text_line_start(txt, pos);\n\t\t\tbreak;\n\t\tcase VIS_OP_PUT_AFTER:\n\t\t\tpos = text_line_start(txt, text_line_next(txt, c->pos));\n\t\t\tbreak;\n\t\tcase VIS_OP_PUT_BEFORE:\n\t\t\tpos = text_line_start(txt, c->pos);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (c->arg->i) {\n\t\tcase VIS_OP_PUT_AFTER:\n\t\tcase VIS_OP_PUT_BEFORE:\n\t\t\tpos = text_char_prev(txt, pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n}\n\nstatic size_t op_shift_right(Vis *vis, Text *txt, OperatorContext *c) {\n\tchar spaces[9] = \"         \";\n\tspaces[MIN(vis->win->view.tabwidth, LENGTH(spaces) - 1)] = '\\0';\n\tconst char *tab = vis->win->expandtab ? spaces : \"\\t\";\n\tsize_t tablen = strlen(tab);\n\tsize_t pos = text_line_begin(txt, c->range.end), prev_pos;\n\tsize_t newpos = c->pos;\n\n\t/* if range ends at the begin of a line, skip line break */\n\tif (pos == c->range.end)\n\t\tpos = text_line_prev(txt, pos);\n\tbool multiple_lines = text_line_prev(txt, pos) >= c->range.start;\n\n\tdo {\n\t\tsize_t end = text_line_end(txt, pos);\n\t\tprev_pos = pos = text_line_begin(txt, end);\n\t\tif ((!multiple_lines || pos != end) &&\n\t\t    text_insert(txt, pos, tab, tablen) && pos <= c->pos)\n\t\t\tnewpos += tablen;\n\t\tpos = text_line_prev(txt, pos);\n\t}  while (pos >= c->range.start && pos != prev_pos);\n\n\treturn newpos;\n}\n\nstatic size_t op_shift_left(Vis *vis, Text *txt, OperatorContext *c) {\n\tsize_t pos = text_line_begin(txt, c->range.end), prev_pos;\n\tsize_t tabwidth = vis->win->view.tabwidth, tablen;\n\tsize_t newpos = c->pos;\n\n\t/* if range ends at the begin of a line, skip line break */\n\tif (pos == c->range.end)\n\t\tpos = text_line_prev(txt, pos);\n\n\tdo {\n\t\tchar b;\n\t\tsize_t len = 0;\n\t\tprev_pos = pos = text_line_begin(txt, pos);\n\t\tIterator it = text_iterator_get(txt, pos);\n\t\tif (text_iterator_byte_get(&it, &b) && b == '\\t') {\n\t\t\tlen = 1;\n\t\t} else {\n\t\t\tfor (len = 0; text_iterator_byte_get(&it, &b) && b == ' '; len++)\n\t\t\t\ttext_iterator_byte_next(&it, NULL);\n\t\t}\n\t\ttablen = MIN(len, tabwidth);\n\t\tif (text_delete(txt, pos, tablen) && pos < c->pos) {\n\t\t\tsize_t delta = c->pos - pos;\n\t\t\tif (delta > tablen)\n\t\t\t\tdelta = tablen;\n\t\t\tif (delta > newpos)\n\t\t\t\tdelta = newpos;\n\t\t\tnewpos -= delta;\n\t\t}\n\t\tpos = text_line_prev(txt, pos);\n\t}  while (pos >= c->range.start && pos != prev_pos);\n\n\treturn newpos;\n}\n\nstatic size_t op_cursor(Vis *vis, Text *txt, OperatorContext *c) {\n\tFilerange r = text_range_linewise(txt, &c->range);\n\tfor (size_t line = text_range_line_first(txt, &r); line != EPOS; line = text_range_line_next(txt, &r, line)) {\n\t\tsize_t pos;\n\t\tif (c->arg->i == VIS_OP_CURSOR_EOL)\n\t\t\tpos = text_line_finish(txt, line);\n\t\telse\n\t\t\tpos = text_line_start(txt, line);\n\t\tview_selections_new_force(&vis->win->view, pos);\n\t}\n\treturn EPOS;\n}\n\nstatic size_t op_join(Vis *vis, Text *txt, OperatorContext *c) {\n\tsize_t pos = text_line_begin(txt, c->range.end), prev_pos;\n\tMark mark = EMARK;\n\n\t/* if operator and range are both linewise, skip last line break */\n\tif (c->linewise && text_range_is_linewise(txt, &c->range)) {\n\t\tsize_t line_prev = text_line_prev(txt, pos);\n\t\tsize_t line_prev_prev = text_line_prev(txt, line_prev);\n\t\tif (line_prev_prev >= c->range.start)\n\t\t\tpos = line_prev;\n\t}\n\n\tsize_t len = c->arg->s ? strlen(c->arg->s) : 0;\n\n\tdo {\n\t\tprev_pos = pos;\n\t\tsize_t end = text_line_start(txt, pos);\n\t\tpos = text_line_prev(txt, end);\n\t\tif (pos < c->range.start || end <= pos)\n\t\t\tbreak;\n\t\ttext_delete(txt, pos, end - pos);\n\t\tchar prev, next;\n\t\tif (text_byte_get(txt, pos-1, &prev) && !isspace((unsigned char)prev) &&\n\t\t    text_byte_get(txt, pos, &next) && next != '\\n')\n\t\t\ttext_insert(txt, pos, c->arg->s, len);\n\t\tif (mark == EMARK)\n\t\t\tmark = text_mark_set(txt, pos);\n\t} while (pos != prev_pos);\n\n\tsize_t newpos = text_mark_get(txt, mark);\n\treturn newpos != EPOS ? newpos : c->range.start;\n}\n\nstatic size_t op_modeswitch(Vis *vis, Text *txt, OperatorContext *c) {\n\treturn c->newpos != EPOS ? c->newpos : c->pos;\n}\n\nstatic size_t op_replace(Vis *vis, Text *txt, OperatorContext *c) {\n\tsize_t count = 0;\n\tIterator it = text_iterator_get(txt, c->range.start);\n\twhile (it. pos < c->range.end && text_iterator_char_next(&it, NULL))\n\t\tcount++;\n\top_delete(vis, txt, c);\n\tsize_t pos = c->range.start;\n\tfor (size_t len = strlen(c->arg->s); count > 0; pos += len, count--)\n\t\ttext_insert(txt, pos, c->arg->s, len);\n\treturn c->range.start;\n}\n\nint vis_operator_register(Vis *vis, VisOperatorFunction *func, void *context) {\n\tOperator *op = calloc(1, sizeof *op);\n\tif (!op)\n\t\treturn -1;\n\top->func = func;\n\top->context = context;\n\tif (array_add_ptr(&vis->operators, op))\n\t\treturn VIS_OP_LAST + vis->operators.len - 1;\n\tfree(op);\n\treturn -1;\n}\n\nbool vis_operator(Vis *vis, enum VisOperator id, ...) {\n\tva_list ap;\n\tva_start(ap, id);\n\n\tswitch (id) {\n\tcase VIS_OP_MODESWITCH:\n\t\tvis->action.mode = va_arg(ap, int);\n\t\tbreak;\n\tcase VIS_OP_CURSOR_SOL:\n\tcase VIS_OP_CURSOR_EOL:\n\t\tvis->action.arg.i = id;\n\t\tid = VIS_OP_CURSOR_SOL;\n\t\tbreak;\n\tcase VIS_OP_PUT_AFTER:\n\tcase VIS_OP_PUT_AFTER_END:\n\tcase VIS_OP_PUT_BEFORE:\n\tcase VIS_OP_PUT_BEFORE_END:\n\t\tvis->action.arg.i = id;\n\t\tid = VIS_OP_PUT_AFTER;\n\t\tbreak;\n\tcase VIS_OP_JOIN:\n\t\tvis->action.arg.s = va_arg(ap, char*);\n\t\tbreak;\n\tcase VIS_OP_SHIFT_LEFT:\n\tcase VIS_OP_SHIFT_RIGHT:\n\t\tvis_motion_type(vis, VIS_MOTIONTYPE_LINEWISE);\n\t\tbreak;\n\tcase VIS_OP_REPLACE:\n\t{\n\t\tMacro *macro = macro_get(vis, VIS_REG_DOT);\n\t\tmacro->len   = 0;\n\t\tmacro_append(macro, va_arg(ap, char*));\n\t\tvis->action.arg.s = macro->data;\n\t\tbreak;\n\t}\n\tcase VIS_OP_DELETE:\n\t{\n\t\tenum VisMode mode = vis->mode->id;\n\t\tenum VisRegister reg = vis_register_used(vis);\n\t\tif (reg == VIS_REG_DEFAULT && (mode == VIS_MODE_INSERT || mode == VIS_MODE_REPLACE))\n\t\t\tvis_register(vis, VIS_REG_BLACKHOLE);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\tconst Operator *op = NULL;\n\tif (id < LENGTH(vis_operators))\n\t\top = &vis_operators[id];\n\telse\n\t\top = array_get_ptr(&vis->operators, id - VIS_OP_LAST);\n\n\tif (!op)\n\t\tgoto err;\n\n\tif (vis->mode->visual) {\n\t\tvis->action.op = op;\n\t\tvis_do(vis);\n\t\tgoto out;\n\t}\n\n\t/* switch to operator mode inorder to make operator options and\n\t * text-object available */\n\tvis_mode_switch(vis, VIS_MODE_OPERATOR_PENDING);\n\tif (vis->action.op == op) {\n\t\t/* hacky way to handle double operators i.e. things like\n\t\t * dd, yy etc where the second char isn't a movement */\n\t\tvis_motion_type(vis, VIS_MOTIONTYPE_LINEWISE);\n\t\tvis_motion(vis, VIS_MOVE_LINE_NEXT);\n\t} else {\n\t\tvis->action.op = op;\n\t}\n\n\t/* put is not a real operator, does not need a range to operate on */\n\tif (id == VIS_OP_PUT_AFTER)\n\t\tvis_motion(vis, VIS_MOVE_NOP);\n\nout:\n\tva_end(ap);\n\treturn true;\nerr:\n\tva_end(ap);\n\treturn false;\n}\n\nconst Operator vis_operators[] = {\n\t[VIS_OP_DELETE]      = { op_delete      },\n\t[VIS_OP_CHANGE]      = { op_change      },\n\t[VIS_OP_YANK]        = { op_yank        },\n\t[VIS_OP_PUT_AFTER]   = { op_put         },\n\t[VIS_OP_SHIFT_RIGHT] = { op_shift_right },\n\t[VIS_OP_SHIFT_LEFT]  = { op_shift_left  },\n\t[VIS_OP_JOIN]        = { op_join        },\n\t[VIS_OP_MODESWITCH]  = { op_modeswitch  },\n\t[VIS_OP_REPLACE]     = { op_replace     },\n\t[VIS_OP_CURSOR_SOL]  = { op_cursor      },\n};\n"
        },
        {
          "name": "vis-prompt.c",
          "type": "blob",
          "size": 5.7451171875,
          "content": "#include <string.h>\n#include \"vis-core.h\"\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"text-util.h\"\n\nbool vis_prompt_cmd(Vis *vis, const char *cmd) {\n\tif (!cmd || !cmd[0] || !cmd[1])\n\t\treturn true;\n\tswitch (cmd[0]) {\n\tcase '/':\n\t\treturn vis_motion(vis, VIS_MOVE_SEARCH_FORWARD, cmd+1);\n\tcase '?':\n\t\treturn vis_motion(vis, VIS_MOVE_SEARCH_BACKWARD, cmd+1);\n\tcase '+':\n\tcase ':':\n\t\tregister_put0(vis, &vis->registers[VIS_REG_COMMAND], cmd+1);\n\t\treturn vis_cmd(vis, cmd+1);\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void prompt_hide(Win *win) {\n\tText *txt = win->file->text;\n\tsize_t size = text_size(txt);\n\t/* make sure that file is new line terminated */\n\tchar lastchar = '\\0';\n\tif (size >= 1 && text_byte_get(txt, size-1, &lastchar) && lastchar != '\\n')\n\t\ttext_insert(txt, size, \"\\n\", 1);\n\t/* remove empty entries */\n\tFilerange line_range = text_object_line(txt, text_size(txt)-1);\n\tchar *line = text_bytes_alloc0(txt, line_range.start, text_range_size(&line_range));\n\tif (line && (line[0] == '\\n' || (strchr(\":/?\", line[0]) && (line[1] == '\\n' || line[1] == '\\0'))))\n\t\ttext_delete_range(txt, &line_range);\n\tfree(line);\n\tvis_window_close(win);\n}\n\nstatic void prompt_restore(Win *win) {\n\tVis *vis = win->vis;\n\t/* restore window and mode which was active before the prompt window\n\t * we deliberately don't use vis_mode_switch because we do not want\n\t * to invoke the modes enter/leave functions */\n\tif (win->parent)\n\t\tvis->win = win->parent;\n\tvis->mode = win->parent_mode;\n}\n\nstatic const char *prompt_enter(Vis *vis, const char *keys, const Arg *arg) {\n\tWin *prompt = vis->win;\n\tView *view = &prompt->view;\n\tText *txt = prompt->file->text;\n\tWin *win = prompt->parent;\n\tchar *cmd = NULL;\n\n\tFilerange range = view_selections_get(view->selection);\n\tif (!vis->mode->visual) {\n\t\tconst char *pattern = NULL;\n\t\tRegex *regex = text_regex_new();\n\t\tsize_t pos = view_cursor_get(view);\n\t\tif (prompt->file == vis->command_file)\n\t\t\tpattern = \"^:\";\n\t\telse if (prompt->file == vis->search_file)\n\t\t\tpattern = \"^(/|\\\\?)\";\n\t\tint cflags = REG_EXTENDED|REG_NEWLINE|(REG_ICASE*vis->ignorecase);\n\t\tif (pattern && regex && text_regex_compile(regex, pattern, cflags) == 0) {\n\t\t\tsize_t end = text_line_end(txt, pos);\n\t\t\tsize_t prev = text_search_backward(txt, end, regex);\n\t\t\tif (prev > pos)\n\t\t\t\tprev = EPOS;\n\t\t\tsize_t next = text_search_forward(txt, pos, regex);\n\t\t\tif (next < pos)\n\t\t\t\tnext = text_size(txt);\n\t\t\trange = text_range_new(prev, next);\n\t\t}\n\t\ttext_regex_free(regex);\n\t}\n\tif (text_range_valid(&range))\n\t\tcmd = text_bytes_alloc0(txt, range.start, text_range_size(&range));\n\n\tif (!win || !cmd) {\n\t\tif (!win)\n\t\t\tvis_info_show(vis, \"Prompt window invalid\");\n\t\telse if (!cmd)\n\t\t\tvis_info_show(vis, \"Failed to detect command\");\n\t\tprompt_restore(prompt);\n\t\tprompt_hide(prompt);\n\t\tfree(cmd);\n\t\treturn keys;\n\t}\n\n\tsize_t len = strlen(cmd);\n\tif (len > 0 && cmd[len-1] == '\\n')\n\t\tcmd[len-1] = '\\0';\n\n\tbool lastline = (range.end == text_size(txt));\n\n\tprompt_restore(prompt);\n\tif (vis_prompt_cmd(vis, cmd)) {\n\t\tprompt_hide(prompt);\n\t\tif (!lastline) {\n\t\t\ttext_delete(txt, range.start, text_range_size(&range));\n\t\t\ttext_appendf(txt, \"%s\\n\", cmd);\n\t\t}\n\t} else {\n\t\tvis->win = prompt;\n\t\tvis->mode = &vis_modes[VIS_MODE_INSERT];\n\t}\n\tfree(cmd);\n\tvis_draw(vis);\n\treturn keys;\n}\n\nstatic const char *prompt_esc(Vis *vis, const char *keys, const Arg *arg) {\n\tWin *prompt = vis->win;\n\tif (prompt->view.selection_count > 1) {\n\t\tview_selections_dispose_all(&prompt->view);\n\t} else {\n\t\tprompt_restore(prompt);\n\t\tprompt_hide(prompt);\n\t}\n\treturn keys;\n}\n\nstatic const char *prompt_up(Vis *vis, const char *keys, const Arg *arg) {\n\tvis_motion(vis, VIS_MOVE_LINE_UP);\n\tvis_window_mode_unmap(vis->win, VIS_MODE_INSERT, \"<Up>\");\n\twin_options_set(vis->win, UI_OPTION_SYMBOL_EOF);\n\treturn keys;\n}\n\nstatic const KeyBinding prompt_enter_binding = {\n\t.key = \"<Enter>\",\n\t.action = &(KeyAction){\n\t\t.func = prompt_enter,\n\t},\n};\n\nstatic const KeyBinding prompt_esc_binding = {\n\t.key = \"<Escape>\",\n\t.action = &(KeyAction){\n\t\t.func = prompt_esc,\n\t},\n};\n\nstatic const KeyBinding prompt_up_binding = {\n\t.key = \"<Up>\",\n\t.action = &(KeyAction){\n\t\t.func = prompt_up,\n\t},\n};\n\nstatic const KeyBinding prompt_tab_binding = {\n\t.key = \"<Tab>\",\n\t.alias = \"<C-x><C-o>\",\n};\n\nvoid vis_prompt_show(Vis *vis, const char *title) {\n\tWin *active = vis->win;\n\tWin *prompt = window_new_file(vis, title[0] == ':' ? vis->command_file : vis->search_file,\n\t\tUI_OPTION_ONELINE);\n\tif (!prompt)\n\t\treturn;\n\tText *txt = prompt->file->text;\n\ttext_appendf(txt, \"%s\\n\", title);\n\tSelection *sel = view_selections_primary_get(&prompt->view);\n\tview_cursors_scroll_to(sel, text_size(txt)-1);\n\tprompt->parent = active;\n\tprompt->parent_mode = vis->mode;\n\tvis_window_mode_map(prompt, VIS_MODE_NORMAL, true, \"<Enter>\", &prompt_enter_binding);\n\tvis_window_mode_map(prompt, VIS_MODE_INSERT, true, \"<Enter>\", &prompt_enter_binding);\n\tvis_window_mode_map(prompt, VIS_MODE_INSERT, true, \"<C-j>\", &prompt_enter_binding);\n\tvis_window_mode_map(prompt, VIS_MODE_VISUAL, true, \"<Enter>\", &prompt_enter_binding);\n\tvis_window_mode_map(prompt, VIS_MODE_NORMAL, true, \"<Escape>\", &prompt_esc_binding);\n\tvis_window_mode_map(prompt, VIS_MODE_INSERT, true, \"<Up>\", &prompt_up_binding);\n\tif (CONFIG_LUA)\n\t\tvis_window_mode_map(prompt, VIS_MODE_INSERT, true, \"<Tab>\", &prompt_tab_binding);\n\tvis_mode_switch(vis, VIS_MODE_INSERT);\n}\n\nvoid vis_info_show(Vis *vis, const char *msg, ...) {\n\tva_list ap;\n\tva_start(ap, msg);\n\tui_info_show(&vis->ui, msg, ap);\n\tva_end(ap);\n}\n\nvoid vis_message_show(Vis *vis, const char *msg) {\n\tif (!msg)\n\t\treturn;\n\tif (!vis->message_window)\n\t\tvis->message_window = window_new_file(vis, vis->error_file, UI_OPTION_STATUSBAR);\n\tWin *win = vis->message_window;\n\tif (!win)\n\t\treturn;\n\tText *txt = win->file->text;\n\tsize_t pos = text_size(txt);\n\ttext_appendf(txt, \"%s\\n\", msg);\n\ttext_save(txt, NULL);\n\tview_cursors_to(win->view.selection, pos);\n\tvis_window_focus(win);\n}\n"
        },
        {
          "name": "vis-registers.c",
          "type": "blob",
          "size": 8.9033203125,
          "content": "#include <stdlib.h>\n#include <string.h>\n\n#include \"vis-core.h\"\n\nstatic Buffer *register_buffer(Register *reg, size_t slot) {\n\tBuffer *buf = array_get(&reg->values, slot);\n\tif (buf)\n\t\treturn buf;\n\tif (array_resize(&reg->values, slot) && (buf = array_get(&reg->values, slot)))\n\t\treturn buf;\n\tBuffer new = {0};\n\tif (!array_add(&reg->values, &new))\n\t\treturn NULL;\n\tsize_t capacity = reg->values.count;\n\tfor (size_t i = reg->values.len; i < capacity; i++) {\n\t\tif (!array_add(&reg->values, &new))\n\t\t\treturn NULL;\n\t}\n\treturn array_get(&reg->values, slot);\n}\n\nbool register_init(Register *reg) {\n\tBuffer buf = {0};\n\tarray_init_sized(&reg->values, sizeof(Buffer));\n\treturn array_add(&reg->values, &buf);\n}\n\nvoid register_release(Register *reg) {\n\tif (!reg)\n\t\treturn;\n\tsize_t n = reg->values.count;\n\tfor (size_t i = 0; i < n; i++)\n\t\tbuffer_release(array_get(&reg->values, i));\n\tarray_release(&reg->values);\n}\n\nconst char *register_slot_get(Vis *vis, Register *reg, size_t slot, size_t *len) {\n\tif (len)\n\t\t*len = 0;\n\tswitch (reg->type) {\n\tcase REGISTER_NORMAL:\n\t{\n\t\tBuffer *buf = array_get(&reg->values, slot);\n\t\tif (!buf)\n\t\t\treturn NULL;\n\t\tbuffer_terminate(buf);\n\t\tif (len)\n\t\t\t*len = buffer_length0(buf);\n\t\treturn buffer_content0(buf);\n\t}\n\tcase REGISTER_NUMBER:\n\t{\n\t\tBuffer *buf = array_get(&reg->values, 0);\n\t\tif (!buf)\n\t\t\treturn NULL;\n\t\tbuffer_printf(buf, \"%zu\", slot+1);\n\t\tif (len)\n\t\t\t*len = buffer_length0(buf);\n\t\treturn buffer_content0(buf);\n\t}\n\tcase REGISTER_CLIPBOARD:\n\t{\n\t\tBuffer buferr = {0};\n\t\tenum VisRegister id = reg - vis->registers;\n\t\tconst char *cmd[] = { VIS_CLIPBOARD, \"--paste\", \"--selection\", NULL, NULL };\n\t\tBuffer *buf = array_get(&reg->values, slot);\n\t\tif (!buf)\n\t\t\treturn NULL;\n\t\tbuf->len = 0;\n\n\t\tif (id == VIS_REG_PRIMARY)\n\t\t\tcmd[3] = \"primary\";\n\t\telse\n\t\t\tcmd[3] = \"clipboard\";\n\t\tint status = vis_pipe(vis, vis->win->file,\n\t\t\t&(Filerange){ .start = 0, .end = 0 },\n\t\t\tcmd, buf, read_into_buffer, &buferr, read_into_buffer, false);\n\n\t\tif (status != 0)\n\t\t\tvis_info_show(vis, \"Command failed %s\", buffer_content0(&buferr));\n\t\tbuffer_release(&buferr);\n\t\tif (len)\n\t\t\t*len = buffer_length0(buf);\n\t\treturn buffer_content0(buf);\n\t}\n\tcase REGISTER_BLACKHOLE:\n\tdefault:\n\t\treturn NULL;\n\t}\n}\n\nconst char *register_get(Vis *vis, Register *reg, size_t *len) {\n\treturn register_slot_get(vis, reg, 0, len);\n}\n\nbool register_slot_put(Vis *vis, Register *reg, size_t slot, const char *data, size_t len) {\n\tif (reg->type != REGISTER_NORMAL)\n\t\treturn false;\n\tBuffer *buf = register_buffer(reg, slot);\n\treturn buf && buffer_put(buf, data, len);\n}\n\nbool register_put(Vis *vis, Register *reg, const char *data, size_t len) {\n\treturn register_slot_put(vis, reg, 0, data, len) &&\n\t       register_resize(reg, 1);\n}\n\nbool register_put0(Vis *vis, Register *reg, const char *data) {\n\treturn register_put(vis, reg, data, strlen(data)+1);\n}\n\nstatic bool register_slot_append_range(Register *reg, size_t slot, Text *txt, Filerange *range) {\n\tswitch (reg->type) {\n\tcase REGISTER_NORMAL:\n\t{\n\t\tBuffer *buf = register_buffer(reg, slot);\n\t\tif (!buf)\n\t\t\treturn false;\n\t\tsize_t len = text_range_size(range);\n\t\tif (len == SIZE_MAX || !buffer_grow(buf, len+1))\n\t\t\treturn false;\n\t\tif (buf->len > 0 && buf->data[buf->len-1] == '\\0')\n\t\t\tbuf->len--;\n\t\tbuf->len += text_bytes_get(txt, range->start, len, buf->data + buf->len);\n\t\treturn buffer_append(buf, \"\\0\", 1);\n\t}\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool register_slot_put_range(Vis *vis, Register *reg, size_t slot, Text *txt, Filerange *range) {\n\tif (reg->append)\n\t\treturn register_slot_append_range(reg, slot, txt, range);\n\n\tswitch (reg->type) {\n\tcase REGISTER_NORMAL:\n\t{\n\t\tBuffer *buf = register_buffer(reg, slot);\n\t\tif (!buf)\n\t\t\treturn false;\n\t\tsize_t len = text_range_size(range);\n\t\tif (len == SIZE_MAX || !buffer_reserve(buf, len+1))\n\t\t\treturn false;\n\t\tbuf->len = text_bytes_get(txt, range->start, len, buf->data);\n\t\treturn buffer_append(buf, \"\\0\", 1);\n\t}\n\tcase REGISTER_CLIPBOARD:\n\t{\n\t\tBuffer buferr = {0};\n\t\tconst char *cmd[] = { VIS_CLIPBOARD, \"--copy\", \"--selection\", NULL, NULL };\n\t\tenum VisRegister id = reg - vis->registers;\n\n\t\tif (id == VIS_REG_PRIMARY)\n\t\t\tcmd[3] = \"primary\";\n\t\telse\n\t\t\tcmd[3] = \"clipboard\";\n\n\t\tint status = vis_pipe(vis, vis->win->file, range,\n\t\t\tcmd, NULL, NULL, &buferr, read_into_buffer, false);\n\n\t\tif (status != 0)\n\t\t\tvis_info_show(vis, \"Command failed %s\", buffer_content0(&buferr));\n\t\tbuffer_release(&buferr);\n\t\treturn status == 0;\n\t}\n\tcase REGISTER_BLACKHOLE:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nbool register_put_range(Vis *vis, Register *reg, Text *txt, Filerange *range) {\n\treturn register_slot_put_range(vis, reg, 0, txt, range) &&\n\t       register_resize(reg, 1);\n}\n\nsize_t vis_register_count(Vis *vis, Register *reg) {\n\tif (reg->type == REGISTER_NUMBER)\n\t\treturn vis->win ? vis->win->view.selection_count : 0;\n\treturn reg->values.len;\n}\n\nbool register_resize(Register *reg, size_t count) {\n\treturn array_truncate(&reg->values, count);\n}\n\nenum VisRegister vis_register_from(Vis *vis, char reg) {\n\n\tif (reg == '@')\n\t\treturn VIS_MACRO_LAST_RECORDED;\n\n\tif ('a' <= reg && reg <= 'z')\n\t\treturn VIS_REG_a + reg - 'a';\n\tif ('A' <= reg && reg <= 'Z')\n\t\treturn VIS_REG_A + reg - 'A';\n\n\tfor (size_t i = 0; i < LENGTH(vis_registers); i++) {\n\t\tif (vis_registers[i].name == reg)\n\t\t\treturn i;\n\t}\n\treturn VIS_REG_INVALID;\n}\n\nchar vis_register_to(Vis *vis, enum VisRegister reg) {\n\n\tif (reg == VIS_MACRO_LAST_RECORDED)\n\t\treturn '@';\n\n\tif (VIS_REG_a <= reg && reg <= VIS_REG_z)\n\t\treturn 'a' + reg - VIS_REG_a;\n\tif (VIS_REG_A <= reg && reg <= VIS_REG_Z)\n\t\treturn 'A' + reg - VIS_REG_A;\n\n\tif (reg < LENGTH(vis_registers))\n\t\treturn vis_registers[reg].name;\n\n\treturn '\\0';\n}\n\nvoid vis_register(Vis *vis, enum VisRegister reg) {\n\tif (VIS_REG_A <= reg && reg <= VIS_REG_Z) {\n\t\tvis->action.reg = &vis->registers[VIS_REG_a + reg - VIS_REG_A];\n\t\tvis->action.reg->append = true;\n\t} else if (reg < LENGTH(vis->registers)) {\n\t\tvis->action.reg = &vis->registers[reg];\n\t\tvis->action.reg->append = false;\n\t}\n}\n\nenum VisRegister vis_register_used(Vis *vis) {\n\tif (!vis->action.reg)\n\t\treturn VIS_REG_DEFAULT;\n\treturn vis->action.reg - vis->registers;\n}\n\nstatic Register *register_from(Vis *vis, enum VisRegister id) {\n\tif (VIS_REG_A <= id && id <= VIS_REG_Z)\n\t\tid = VIS_REG_a + id - VIS_REG_A;\n\tif (id < LENGTH(vis->registers))\n\t\treturn &vis->registers[id];\n\treturn NULL;\n}\n\nbool vis_register_set(Vis *vis, enum VisRegister id, Array *data) {\n\tRegister *reg = register_from(vis, id);\n\tif (!reg)\n\t\treturn false;\n\tsize_t len = data->len;\n\tfor (size_t i = 0; i < len; i++) {\n\t\tBuffer *buf = register_buffer(reg, i);\n\t\tif (!buf)\n\t\t\treturn false;\n\t\tTextString *string = array_get(data, i);\n\t\tif (!buffer_put(buf, string->data, string->len))\n\t\t\treturn false;\n\t}\n\treturn register_resize(reg, len);\n}\n\nArray vis_register_get(Vis *vis, enum VisRegister id) {\n\tArray data;\n\tarray_init_sized(&data, sizeof(TextString));\n\tRegister *reg = register_from(vis, id);\n\tif (reg) {\n\t\tsize_t len = reg->values.len;\n\t\tarray_reserve(&data, len);\n\t\tfor (size_t i = 0; i < len; i++) {\n\t\t\tBuffer *buf = array_get(&reg->values, i);\n\t\t\tTextString string = {\n\t\t\t\t.data = buf->data,\n\t\t\t\t.len  = buf->len,\n\t\t\t};\n\t\t\tarray_add(&data, &string);\n\t\t}\n\t}\n\treturn data;\n}\n\nconst RegisterDef vis_registers[] = {\n\t[VIS_REG_DEFAULT]    = { '\"', VIS_HELP(\"Unnamed register\")                                 },\n\t[VIS_REG_ZERO]       = { '0', VIS_HELP(\"Yank register\")                                    },\n\t[VIS_REG_1]          = { '1', VIS_HELP(\"1st sub-expression match\")                         },\n\t[VIS_REG_2]          = { '2', VIS_HELP(\"2nd sub-expression match\")                         },\n\t[VIS_REG_3]          = { '3', VIS_HELP(\"3rd sub-expression match\")                         },\n\t[VIS_REG_4]          = { '4', VIS_HELP(\"4th sub-expression match\")                         },\n\t[VIS_REG_5]          = { '5', VIS_HELP(\"5th sub-expression match\")                         },\n\t[VIS_REG_6]          = { '6', VIS_HELP(\"6th sub-expression match\")                         },\n\t[VIS_REG_7]          = { '7', VIS_HELP(\"7th sub-expression match\")                         },\n\t[VIS_REG_8]          = { '8', VIS_HELP(\"8th sub-expression match\")                         },\n\t[VIS_REG_9]          = { '9', VIS_HELP(\"9th sub-expression match\")                         },\n\t[VIS_REG_AMPERSAND]  = { '&', VIS_HELP(\"Last regex match\")                                 },\n\t[VIS_REG_BLACKHOLE]  = { '_', VIS_HELP(\"/dev/null register\")                               },\n\t[VIS_REG_PRIMARY]    = { '*', VIS_HELP(\"Primary clipboard register, see vis-clipboard(1)\") },\n\t[VIS_REG_CLIPBOARD]  = { '+', VIS_HELP(\"System clipboard register, see vis-clipboard(1)\")  },\n\t[VIS_REG_DOT]        = { '.', VIS_HELP(\"Last inserted text\")                               },\n\t[VIS_REG_SEARCH]     = { '/', VIS_HELP(\"Last search pattern\")                              },\n\t[VIS_REG_COMMAND]    = { ':', VIS_HELP(\"Last :-command\")                                   },\n\t[VIS_REG_SHELL]      = { '!', VIS_HELP(\"Last shell command given to either <, >, |, or !\") },\n\t[VIS_REG_NUMBER]     = { '#', VIS_HELP(\"Register number\")                                  },\n};\n"
        },
        {
          "name": "vis-single.c",
          "type": "blob",
          "size": 3.1201171875,
          "content": "#include <sys/wait.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <ftw.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <lzma.h>\n#include <libuntar.h>\n\n#ifndef PATH_MAX\n#define PATH_MAX 4096\n#endif\n\n#include \"vis-single-payload.inc\"\n\n#ifndef VIS_TMP_DIR\n#define VIS_TMP_DIR \"/tmp\"\n#endif\n\n#ifndef VIS_TMP\n#define VIS_TMP \".vis-single-XXXXXX\"\n#endif\n\n#ifndef VIS_TERMINFO\n#define VIS_TERMINFO \"/etc/terminfo:/lib/terminfo:/usr/share/terminfo:\" \\\n\t\"/usr/lib/terminfo:/usr/local/share/terminfo:/usr/local/lib/terminfo\"\n#endif\n\nstatic lzma_stream strm = LZMA_STREAM_INIT;\n\nstatic int libtar_xzopen(const char *pathname, int flags, ...) {\n\tint ret = lzma_stream_decoder(&strm, UINT64_MAX, LZMA_TELL_UNSUPPORTED_CHECK | LZMA_CONCATENATED);\n\tif (ret != LZMA_OK) {\n\t\tfprintf(stderr, \"lzma_stream_decoder error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tstrm.next_in = vis_single_payload;\n\tstrm.avail_in = sizeof(vis_single_payload);\n\n\treturn ret;\n}\n\nstatic int libtar_xzclose(int fd) {\n\tlzma_end(&strm);\n\treturn 0;\n}\n\nstatic ssize_t libtar_xzread(int fd, void *buf, size_t count) {\n\tstrm.next_out = buf;\n\tstrm.avail_out = count;\n\n\tint ret = lzma_code(&strm, LZMA_FINISH);\n\tif (ret != LZMA_OK && ret != LZMA_STREAM_END) {\n\t\tfprintf(stderr, \"lzma_code error: %d\\n\", ret);\n\t\treturn -1;\n\t}\n\n\treturn count - strm.avail_out;\n}\n\ntartype_t xztype = {\n\tlibtar_xzopen,\n\tlibtar_xzclose,\n\tlibtar_xzread,\n};\n\nint extract(char *directory) {\n\tTAR *tar;\n\n\tif (tar_open(&tar, NULL, &xztype, O_RDONLY, 0, 0) == -1) {\n\t\tperror(\"tar_open\");\n\t\treturn -1;\n\t}\n\n\tif (tar_extract_all(tar, directory) != 0) {\n\t\tperror(\"tar_extract_all\");\n\t\treturn -1;\n\t}\n\n\tif (tar_close(tar) != 0) {\n\t\tperror(\"tar_close\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int unlink_cb(const char *path, const struct stat *sb, int typeflag, struct FTW *ftwbuf) {\n\treturn remove(path);\n}\n\nint main(int argc, char **argv) {\n\tint rc = EXIT_FAILURE;\n\tchar exe[256], path[PATH_MAX], tmp_dirname[PATH_MAX];\n\n\tchar *tmpdir = getenv(\"TMPDIR\");\n\tif (snprintf(tmp_dirname, sizeof(tmp_dirname), \"%s/%s\",\n\t             tmpdir ? tmpdir : VIS_TMP_DIR, VIS_TMP) < 0) {\n\t\tperror(\"snprintf\");\n\t\treturn rc;\n\t}\n\n\tif (!mkdtemp(tmp_dirname)) {\n\t\tperror(\"mkdtemp\");\n\t\treturn rc;\n\t}\n\n\tchar *old_path = getenv(\"PATH\");\n\tif (snprintf(path, sizeof(path), \"%s%s%s\", tmp_dirname,\n\t             old_path ? \":\" : \"\", old_path ? old_path : \"\") < 0) {\n\t\tgoto err;\n\t}\n\n\tif (setenv(\"PATH\", path, 1) == -1 ||\n\t    setenv(\"TERMINFO_DIRS\", VIS_TERMINFO, 0) == -1) {\n\t\tperror(\"setenv\");\n\t\tgoto err;\n\t}\n\n\tif (extract(tmp_dirname) != 0)\n\t\tgoto err;\n\n\tif (snprintf(exe, sizeof(exe), \"%s/vis\", tmp_dirname) < 0)\n\t\tgoto err;\n\n\tint child_pid = fork();\n\tif (child_pid == -1) {\n\t\tperror(\"fork\");\n\t\tgoto err;\n\t} else if (child_pid == 0) {\n\t\texecv(exe, argv);\n\t\tperror(\"execv\");\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tsignal(SIGINT, SIG_IGN);\n\n\tfor (;;) {\n\t\tint status;\n\t\tint w = waitpid(child_pid, &status, 0);\n\t\tif (w == -1) {\n\t\t\tperror(\"waitpid\");\n\t\t\tbreak;\n\t\t}\n\t\tif (w == child_pid) {\n\t\t\trc = WEXITSTATUS(status);\n\t\t\tbreak;\n\t\t}\n\t}\n\nerr:\n\tnftw(tmp_dirname, unlink_cb, 64, FTW_DEPTH|FTW_PHYS|FTW_MOUNT);\n\treturn rc;\n}\n"
        },
        {
          "name": "vis-subprocess.c",
          "type": "blob",
          "size": 7.255859375,
          "content": "#include <fcntl.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/wait.h>\n#include \"vis-lua.h\"\n#include \"vis-subprocess.h\"\n#include \"util.h\"\n\n/* Pool of information about currently running subprocesses */\nstatic Process *process_pool;\n\n/**\n * Adds new empty process information structure to the process pool and\n * returns it\n * @return a new Process instance\n */\nstatic Process *new_process_in_pool(void) {\n\tProcess *newprocess = malloc(sizeof(Process));\n\tif (!newprocess) {\n\t\treturn NULL;\n\t}\n\tnewprocess->next = process_pool;\n\tprocess_pool = newprocess;\n\treturn newprocess;\n}\n\n/**\n * Removes the subprocess information from the pool, sets invalidator to NULL\n * and frees resources.\n * @param a reference to the process to be removed\n * @return the next process in the pool\n */\nstatic Process *destroy_process(Process *target) {\n\tif (target->outfd != -1) {\n\t\tclose(target->outfd);\n\t}\n\tif (target->errfd != -1) {\n\t\tclose(target->errfd);\n\t}\n\tif (target->inpfd != -1) {\n\t\tclose(target->inpfd);\n\t}\n\t/* marking stream as closed for lua */\n\tif (target->invalidator) {\n\t\t*(target->invalidator) = NULL;\n\t}\n\tProcess *next = target->next;\n\tfree(target->name);\n\tfree(target);\n\n\treturn next;\n}\n\n/**\n * Starts new subprocess by passing the `command` to the shell and\n * returns the subprocess information structure, containing file descriptors\n * of the process.\n * Also stores the subprocess information to the internal pool to track\n * its status and responses.\n * @param name a string that contains a unique name for the subprocess.\n * This name will be passed to the PROCESS_RESPONSE event handler\n * to distinguish running subprocesses.\n * @param command a command to be executed to spawn a process\n * @param invalidator a pointer to the pointer which shows that the subprocess\n * is invalid when set to NULL. When the subprocess dies, it is set to NULL.\n * If a caller sets the pointer to NULL the subprocess will be killed on the\n * next main loop iteration.\n */\nProcess *vis_process_communicate(Vis *vis, const char *name,\n                                 const char *command, Invalidator **invalidator) {\n\tint pin[2], pout[2], perr[2];\n\tpid_t pid = (pid_t)-1;\n\tif (pipe(perr) == -1) {\n\t\tgoto closeerr;\n\t}\n\tif (pipe(pout) == -1) {\n\t\tgoto closeouterr;\n\t}\n\tif (pipe(pin) == -1) {\n\t\tgoto closeall;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tvis_info_show(vis, \"fork failed: %s\", strerror(errno));\n\t} else if (pid == 0) { /* child process */\n\t\tsigset_t sigterm_mask;\n\t\tsigemptyset(&sigterm_mask);\n\t\tsigaddset(&sigterm_mask, SIGTERM);\n\t\tif (sigprocmask(SIG_UNBLOCK, &sigterm_mask, NULL) == -1) {\n\t\t\tfprintf(stderr, \"failed to reset signal mask\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tdup2(pin[0], STDIN_FILENO);\n\t\tdup2(pout[1], STDOUT_FILENO);\n\t\tdup2(perr[1], STDERR_FILENO);\n\t} else { /* main process */\n\t\tProcess *new = new_process_in_pool();\n\t\tif (!new) {\n\t\t\tvis_info_show(vis, \"Cannot create process: %s\", strerror(errno));\n\t\t\tgoto closeall;\n\t\t}\n\t\tnew->name = strdup(name);\n\t\tif (!new->name) {\n\t\t\tvis_info_show(vis, \"Cannot copy process name: %s\", strerror(errno));\n\t\t\t/* pop top element (which is `new`) from the pool */\n\t\t\tprocess_pool = destroy_process(process_pool);\n\t\t\tgoto closeall;\n\t\t}\n\t\tnew->outfd = pout[0];\n\t\tnew->errfd = perr[0];\n\t\tnew->inpfd = pin[1];\n\t\tnew->pid = pid;\n\t\tnew->invalidator = invalidator;\n\t\tclose(pin[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[1]);\n\t\treturn new;\n\t}\ncloseall:\n\tclose(pin[0]);\n\tclose(pin[1]);\ncloseouterr:\n\tclose(pout[0]);\n\tclose(pout[1]);\ncloseerr:\n\tclose(perr[0]);\n\tclose(perr[1]);\n\tif (pid == 0) { /* start command in child process */\n\t\texeclp(vis->shell, vis->shell, \"-c\", command, (char*)NULL);\n\t\tfprintf(stderr, \"exec failed: %s(%d)\\n\", strerror(errno), errno);\n\t\texit(1);\n\t} else {\n\t\tvis_info_show(vis, \"process creation failed: %s\", strerror(errno));\n\t}\n\treturn NULL;\n}\n\n/**\n * Adds file descriptors of currently running subprocesses to the `readfds`\n * to track their readiness and returns maximum file descriptor value\n * to pass it to the `pselect` call\n * @param readfds the structure for `pselect` call to fill\n * @return maximum file descriptor number in the readfds structure\n */\nint vis_process_before_tick(fd_set *readfds) {\n\tint maxfd = 0;\n\tfor (Process **pointer = &process_pool; *pointer; pointer = &((*pointer)->next)) {\n\t\tProcess *current = *pointer;\n\t\tif (current->outfd != -1) {\n\t\t\tFD_SET(current->outfd, readfds);\n\t\t\tmaxfd = maxfd < current->outfd ? current->outfd : maxfd;\n\t\t}\n\t\tif (current->errfd != -1) {\n\t\t\tFD_SET(current->errfd, readfds);\n\t\t\tmaxfd = maxfd < current->errfd ? current->errfd : maxfd;\n\t\t}\n\t}\n\treturn maxfd;\n}\n\n/**\n * Reads data from the given subprocess file descriptor `fd` and fires\n * the PROCESS_RESPONSE event in Lua with given subprocess `name`,\n * `rtype` and the read data as arguments.\n * @param fd the file descriptor to read data from\n * @param name a name of the subprocess\n * @param rtype a type of file descriptor where the new data is found\n */\nstatic void read_and_fire(Vis* vis, int fd, const char *name, ResponseType rtype) {\n\tstatic char buffer[PIPE_BUF];\n\tsize_t obtained = read(fd, &buffer, PIPE_BUF-1);\n\tif (obtained > 0) {\n\t\tvis_lua_process_response(vis, name, buffer, obtained, rtype);\n\t}\n}\n\n/**\n * Checks if a subprocess is dead or needs to be killed then raises an event\n * or kills it if necessary.\n * @param current the process to wait for or kill\n * @return true if the process is dead\n */\nstatic bool wait_or_kill_process(Vis *vis, Process *current) {\n\tint status;\n\tpid_t wpid = waitpid(current->pid, &status, WNOHANG);\n\tif (wpid == -1) {\n\t\tvis_message_show(vis, strerror(errno));\n\t} else if (wpid == current->pid) {\n\t\tgoto just_destroy;\n\t} else if (!*(current->invalidator)) {\n\t\tgoto kill_and_destroy;\n\t}\n\treturn false;\n\nkill_and_destroy:\n\tkill(current->pid, SIGTERM);\n\twaitpid(current->pid, &status, 0);\njust_destroy:\n\tif (WIFSIGNALED(status)) {\n\t\tvis_lua_process_response(vis, current->name, NULL, WTERMSIG(status), SIGNAL);\n\t} else {\n\t\tvis_lua_process_response(vis, current->name, NULL, WEXITSTATUS(status), EXIT);\n\t}\n\treturn true;\n}\n\n/**\n * Checks if `readfds` contains file descriptors of subprocesses from\n * the pool. If so, it reads their data and fires corresponding events.\n * Also checks if each subprocess from the pool is dead or needs to be\n * killed then raises an event or kills it if necessary.\n * @param readfds the structure for `pselect` call with file descriptors\n */\nvoid vis_process_tick(Vis *vis, fd_set *readfds) {\n\tfor (Process **pointer = &process_pool; *pointer; ) {\n\t\tProcess *current = *pointer;\n\t\tif (current->outfd != -1 && FD_ISSET(current->outfd, readfds)) {\n\t\t\tread_and_fire(vis, current->outfd, current->name, STDOUT);\n\t\t}\n\t\tif (current->errfd != -1 && FD_ISSET(current->errfd, readfds)) {\n\t\t\tread_and_fire(vis, current->errfd, current->name, STDERR);\n\t\t}\n\t\tif (!wait_or_kill_process(vis, current)) {\n\t\t\tpointer = &current->next;\n\t\t} else {\n\t\t\t/* update our iteration pointer */\n\t\t\t*pointer = destroy_process(current);\n\t\t}\n\t}\n}\n\n/**\n * Checks if each subprocess from the pool is dead or needs to be\n * killed then raises an event or kills it if necessary.\n */\nvoid vis_process_waitall(Vis *vis) {\n\tfor (Process **pointer = &process_pool; *pointer; ) {\n\t\tProcess *current = *pointer;\n\t\tif (!wait_or_kill_process(vis, current)) {\n\t\t\tpointer = &current->next;\n\t\t} else {\n\t\t\t/* update our iteration pointer */\n\t\t\t*pointer = destroy_process(current);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "vis-subprocess.h",
          "type": "blob",
          "size": 0.671875,
          "content": "#ifndef VIS_SUBPROCESS_H\n#define VIS_SUBPROCESS_H\n#include \"vis-core.h\"\n#include \"vis-lua.h\"\n#include <sys/select.h>\n\ntypedef struct Process Process;\n#if CONFIG_LUA\ntypedef int Invalidator(lua_State*);\n#else\ntypedef void Invalidator;\n#endif\n\nstruct Process {\n\tchar *name;\n\tint outfd;\n\tint errfd;\n\tint inpfd;\n\tpid_t pid;\n\tInvalidator** invalidator;\n\tProcess *next;\n};\n\ntypedef enum { STDOUT, STDERR, SIGNAL, EXIT } ResponseType;\n\nProcess *vis_process_communicate(Vis *, const char *command, const char *name,\n                                 Invalidator **invalidator);\nint vis_process_before_tick(fd_set *);\nvoid vis_process_tick(Vis *, fd_set *);\nvoid vis_process_waitall(Vis *);\n#endif\n"
        },
        {
          "name": "vis-text-objects.c",
          "type": "blob",
          "size": 4.8125,
          "content": "#include \"vis-core.h\"\n#include \"text-objects.h\"\n#include \"util.h\"\n\nint vis_textobject_register(Vis *vis, int type, void *data, VisTextObjectFunction *textobject) {\n\n\tTextObject *obj = calloc(1, sizeof *obj);\n\tif (!obj)\n\t\treturn -1;\n\n\tobj->user = textobject;\n\tobj->type = type;\n\tobj->data = data;\n\n\tif (array_add_ptr(&vis->textobjects, obj))\n\t\treturn LENGTH(vis_textobjects) + vis->textobjects.len - 1;\n\tfree(obj);\n\treturn -1;\n}\n\nbool vis_textobject(Vis *vis, enum VisTextObject id) {\n\tif (id < LENGTH(vis_textobjects))\n\t\tvis->action.textobj = &vis_textobjects[id];\n\telse\n\t\tvis->action.textobj = array_get_ptr(&vis->textobjects, id - LENGTH(vis_textobjects));\n\tif (!vis->action.textobj)\n\t\treturn false;\n\tvis_do(vis);\n\treturn true;\n}\n\nstatic Filerange search_forward(Vis *vis, Text *txt, size_t pos) {\n\tFilerange range = text_range_empty();\n\tRegex *regex = vis_regex(vis, NULL);\n\tif (regex)\n\t\trange = text_object_search_forward(txt, pos, regex);\n\ttext_regex_free(regex);\n\treturn range;\n}\n\nstatic Filerange search_backward(Vis *vis, Text *txt, size_t pos) {\n\tFilerange range = text_range_empty();\n\tRegex *regex = vis_regex(vis, NULL);\n\tif (regex)\n\t\trange = text_object_search_backward(txt, pos, regex);\n\ttext_regex_free(regex);\n\treturn range;\n}\n\nstatic Filerange object_unpaired(Text *txt, size_t pos, char obj) {\n\tchar c;\n\tbool before = false;\n\tIterator it = text_iterator_get(txt, pos), rit = it;\n\n\twhile (text_iterator_byte_get(&rit, &c) && c != '\\n') {\n\t\tif (c == obj) {\n\t\t\tbefore = true;\n\t\t\tbreak;\n\t\t}\n\t\ttext_iterator_byte_prev(&rit, NULL);\n\t}\n\n\t/* if there is no previous occurrence on the same line, advance starting position */\n\tif (!before) {\n\t\twhile (text_iterator_byte_get(&it, &c) && c != '\\n') {\n\t\t\tif (c == obj) {\n\t\t\t\tpos = it.pos;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttext_iterator_byte_next(&it, NULL);\n\t\t}\n\t}\n\n\tswitch (obj) {\n\tcase '\"':\n\t\treturn text_object_quote(txt, pos);\n\tcase '\\'':\n\t\treturn text_object_single_quote(txt, pos);\n\tcase '`':\n\t\treturn text_object_backtick(txt, pos);\n\tdefault:\n\t\treturn text_range_empty();\n\t}\n}\n\nstatic Filerange object_quote(Text *txt, size_t pos) {\n\treturn object_unpaired(txt, pos, '\"');\n}\n\nstatic Filerange object_single_quote(Text *txt, size_t pos) {\n\treturn object_unpaired(txt, pos, '\\'');\n}\n\nstatic Filerange object_backtick(Text *txt, size_t pos) {\n\treturn object_unpaired(txt, pos, '`');\n}\n\nconst TextObject vis_textobjects[] = {\n\t[VIS_TEXTOBJECT_INNER_WORD] = {\n\t\t.txt = text_object_word,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_WORD] = {\n\t\t.txt = text_object_word_outer,\n\t},\n\t[VIS_TEXTOBJECT_INNER_LONGWORD] = {\n\t\t.txt = text_object_longword,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_LONGWORD] = {\n\t\t.txt = text_object_longword_outer,\n\t},\n\t[VIS_TEXTOBJECT_SENTENCE] = {\n\t\t.txt = text_object_sentence,\n\t},\n\t[VIS_TEXTOBJECT_PARAGRAPH] = {\n\t\t.txt = text_object_paragraph,\n\t},\n\t[VIS_TEXTOBJECT_PARAGRAPH_OUTER] = {\n\t\t.txt = text_object_paragraph_outer,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_SQUARE_BRACKET] = {\n\t\t.txt = text_object_square_bracket,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_SQUARE_BRACKET] = {\n\t\t.txt = text_object_square_bracket,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_CURLY_BRACKET] = {\n\t\t.txt = text_object_curly_bracket,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_CURLY_BRACKET] = {\n\t\t.txt = text_object_curly_bracket,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_ANGLE_BRACKET] = {\n\t\t.txt = text_object_angle_bracket,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_ANGLE_BRACKET] = {\n\t\t.txt = text_object_angle_bracket,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_PARENTHESIS] = {\n\t\t.txt = text_object_parenthesis,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_PARENTHESIS] = {\n\t\t.txt = text_object_parenthesis,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_QUOTE] = {\n\t\t.txt = object_quote,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_QUOTE] = {\n\t\t.txt = object_quote,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_SINGLE_QUOTE] = {\n\t\t.txt = object_single_quote,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_SINGLE_QUOTE] = {\n\t\t.txt = object_single_quote,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_BACKTICK] = {\n\t\t.txt = object_backtick,\n\t\t.type = TEXTOBJECT_DELIMITED_OUTER,\n\t},\n\t[VIS_TEXTOBJECT_INNER_BACKTICK] = {\n\t\t.txt = object_backtick,\n\t\t.type = TEXTOBJECT_DELIMITED_INNER,\n\t},\n\t[VIS_TEXTOBJECT_OUTER_LINE] = {\n\t\t.txt = text_object_line,\n\t},\n\t[VIS_TEXTOBJECT_INNER_LINE] = {\n\t\t.txt = text_object_line_inner,\n\t},\n\t[VIS_TEXTOBJECT_INDENTATION] = {\n\t\t.txt = text_object_indentation,\n\t},\n\t[VIS_TEXTOBJECT_SEARCH_FORWARD] = {\n\t\t.vis = search_forward,\n\t\t.type = TEXTOBJECT_NON_CONTIGUOUS|TEXTOBJECT_EXTEND_FORWARD,\n\t},\n\t[VIS_TEXTOBJECT_SEARCH_BACKWARD] = {\n\t\t.vis = search_backward,\n\t\t.type = TEXTOBJECT_NON_CONTIGUOUS|TEXTOBJECT_EXTEND_BACKWARD,\n\t},\n};\n\n"
        },
        {
          "name": "vis.c",
          "type": "blob",
          "size": 48.94921875,
          "content": "#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <strings.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <ctype.h>\n#include <time.h>\n#include <sys/select.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <pwd.h>\n#include <libgen.h>\n#include <termkey.h>\n\n#include \"vis.h\"\n#include \"text-util.h\"\n#include \"text-motions.h\"\n#include \"text-objects.h\"\n#include \"util.h\"\n#include \"vis-core.h\"\n#include \"sam.h\"\n#include \"ui.h\"\n#include \"vis-subprocess.h\"\n\n\nstatic void macro_replay(Vis *vis, const Macro *macro);\nstatic void macro_replay_internal(Vis *vis, const Macro *macro);\nstatic void vis_keys_push(Vis *vis, const char *input, size_t pos, bool record);\n\n/** window / file handling */\n\nstatic void file_free(Vis *vis, File *file) {\n\tif (!file)\n\t\treturn;\n\tif (file->refcount > 1) {\n\t\t--file->refcount;\n\t\treturn;\n\t}\n\tvis_event_emit(vis, VIS_EVENT_FILE_CLOSE, file);\n\tfor (size_t i = 0; i < LENGTH(file->marks); i++)\n\t\tmark_release(&file->marks[i]);\n\ttext_free(file->text);\n\tfree((char*)file->name);\n\n\tif (file->prev)\n\t\tfile->prev->next = file->next;\n\tif (file->next)\n\t\tfile->next->prev = file->prev;\n\tif (vis->files == file)\n\t\tvis->files = file->next;\n\tfree(file);\n}\n\nstatic File *file_new_text(Vis *vis, Text *text) {\n\tFile *file = calloc(1, sizeof(*file));\n\tif (!file)\n\t\treturn NULL;\n\tfile->fd = -1;\n\tfile->text = text;\n\tfile->stat = text_stat(text);\n\tfor (size_t i = 0; i < LENGTH(file->marks); i++)\n\t\tmark_init(&file->marks[i]);\n\tif (vis->files)\n\t\tvis->files->prev = file;\n\tfile->next = vis->files;\n\tvis->files = file;\n\treturn file;\n}\n\nchar *absolute_path(const char *name) {\n\tif (!name)\n\t\treturn NULL;\n\tchar *copy1 = strdup(name);\n\tchar *copy2 = strdup(name);\n\tchar *path_absolute = NULL;\n\tchar path_normalized[PATH_MAX] = \"\";\n\n\tif (!copy1 || !copy2)\n\t\tgoto err;\n\n\tchar *dir = dirname(copy1);\n\tchar *base = basename(copy2);\n\tif (!(path_absolute = realpath(dir, NULL)))\n\t\tgoto err;\n\tif (strcmp(path_absolute, \"/\") == 0)\n\t\tpath_absolute[0] = '\\0';\n\n\tsnprintf(path_normalized, sizeof(path_normalized), \"%s/%s\",\n\t         path_absolute, base);\nerr:\n\tfree(copy1);\n\tfree(copy2);\n\tfree(path_absolute);\n\treturn path_normalized[0] ? strdup(path_normalized) : NULL;\n}\n\nstatic File *file_new(Vis *vis, const char *name, bool internal) {\n\tchar *name_absolute = NULL;\n\tbool cmp_names = 0;\n\tstruct stat new;\n\n\tif (name) {\n\t\tif (!(name_absolute = absolute_path(name)))\n\t\t\treturn NULL;\n\n\t\tif (stat(name_absolute, &new)) {\n\t\t\tif (errno != ENOENT) {\n\t\t\t\tfree(name_absolute);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tcmp_names = 1;\n\t\t}\n\n\t\tFile *existing = NULL;\n\t\t/* try to detect whether the same file is already open in another window */\n\t\tfor (File *file = vis->files; file; file = file->next) {\n\t\t\tif (file->name) {\n\t\t\t\tif ((cmp_names && strcmp(file->name, name_absolute) == 0) ||\n\t\t\t\t    (file->stat.st_dev == new.st_dev && file->stat.st_ino == new.st_ino)) {\n\t\t\t\t\texisting = file;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (existing) {\n\t\t\tfree(name_absolute);\n\t\t\treturn existing;\n\t\t}\n\t}\n\n\tFile *file = NULL;\n\tText *text = text_load_method(name, vis->load_method);\n\tif (!text && name && errno == ENOENT)\n\t\ttext = text_load(NULL);\n\tif (!text)\n\t\tgoto err;\n\tif (!(file = file_new_text(vis, text)))\n\t\tgoto err;\n\tfile->name = name_absolute;\n\tfile->internal = internal;\n\tif (!internal)\n\t\tvis_event_emit(vis, VIS_EVENT_FILE_OPEN, file);\n\treturn file;\nerr:\n\tfree(name_absolute);\n\ttext_free(text);\n\tfile_free(vis, file);\n\treturn NULL;\n}\n\nstatic File *file_new_internal(Vis *vis, const char *filename) {\n\tFile *file = file_new(vis, filename, true);\n\tif (file)\n\t\tfile->refcount = 1;\n\treturn file;\n}\n\nvoid file_name_set(File *file, const char *name) {\n\tif (name == file->name)\n\t\treturn;\n\tfree((char*)file->name);\n\tfile->name = absolute_path(name);\n}\n\nconst char *file_name_get(File *file) {\n\t/* TODO: calculate path relative to working directory, cache result */\n\tif (!file->name)\n\t\treturn NULL;\n\tchar cwd[PATH_MAX];\n\tif (!getcwd(cwd, sizeof cwd))\n\t\treturn file->name;\n\tconst char *path = strstr(file->name, cwd);\n\tif (path != file->name)\n\t\treturn file->name;\n\tsize_t cwdlen = strlen(cwd);\n\treturn file->name[cwdlen] == '/' ? file->name+cwdlen+1 : file->name;\n}\n\nvoid window_selection_save(Win *win) {\n\tVis *vis = win->vis;\n\tArray sel = view_selections_get_all(&win->view);\n\tvis_mark_set(win, VIS_MARK_SELECTION, &sel);\n\tarray_release(&sel);\n\tvis_jumplist_save(vis);\n}\n\n\nstatic void window_free(Win *win) {\n\tif (!win)\n\t\treturn;\n\tVis *vis = win->vis;\n\tfor (Win *other = vis->windows; other; other = other->next) {\n\t\tif (other->parent == win)\n\t\t\tother->parent = NULL;\n\t}\n\tui_window_release(&vis->ui, win);\n\tview_free(&win->view);\n\tfor (size_t i = 0; i < LENGTH(win->modes); i++)\n\t\tmap_free(win->modes[i].bindings);\n\tmarklist_release(&win->jumplist);\n\tmark_release(&win->saved_selections);\n\tfree(win);\n}\n\nstatic void window_draw_colorcolumn(Win *win) {\n\tint cc = win->view.colorcolumn;\n\tif (cc <= 0)\n\t\treturn;\n\tsize_t lineno = 0;\n\tint line_cols = 0; /* Track the number of columns we've passed on each line */\n\tbool line_cc_set = false; /* Has the colorcolumn attribute been set for this line yet */\n\tint width = win->view.width;\n\n\tfor (Line *l = win->view.topline; l; l = l->next) {\n\t\tif (l->lineno != lineno) {\n\t\t\tline_cols = 0;\n\t\t\tline_cc_set = false;\n\t\t\tif (!(lineno = l->lineno))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (line_cc_set)\n\t\t\tcontinue;\n\n\t\t/* This screen line contains the cell we want to highlight */\n\t\tif (cc <= line_cols + width) {\n\t\t\tui_window_style_set(&win->vis->ui, win->id, &l->cells[cc - 1 - line_cols], UI_STYLE_COLOR_COLUMN);\n\t\t\tline_cc_set = true;\n\t\t} else {\n\t\t\tline_cols += width;\n\t\t}\n\t}\n}\n\nstatic void window_draw_cursorline(Win *win) {\n\tVis *vis = win->vis;\n\tenum UiOption options = win->options;\n\tif (!(options & UI_OPTION_CURSOR_LINE))\n\t\treturn;\n\tif (vis->mode->visual || vis->win != win)\n\t\treturn;\n\tif (win->view.selection_count > 1)\n\t\treturn;\n\n\tint width = win->view.width;\n\tSelection *sel = view_selections_primary_get(&win->view);\n\tsize_t lineno = sel->line->lineno;\n\tfor (Line *l = win->view.topline; l; l = l->next) {\n\t\tif (l->lineno == lineno) {\n\t\t\tfor (int x = 0; x < width; x++)\n\t\t\t\tui_window_style_set(&vis->ui, win->id, &l->cells[x], UI_STYLE_CURSOR_LINE);\n\t\t} else if (l->lineno > lineno) {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void window_draw_selection(Win *win, Selection *cur) {\n\tView *view = &win->view;\n\tFilerange sel = view_selections_get(cur);\n\tif (!text_range_valid(&sel))\n\t\treturn;\n\tLine *start_line; int start_col;\n\tLine *end_line; int end_col;\n\tview_coord_get(view, sel.start, &start_line, NULL, &start_col);\n\tview_coord_get(view, sel.end, &end_line, NULL, &end_col);\n\tif (!start_line && !end_line)\n\t\treturn;\n\tif (!start_line) {\n\t\tstart_line = view->topline;\n\t\tstart_col = 0;\n\t}\n\tif (!end_line) {\n\t\tend_line = view->lastline;\n\t\tend_col = end_line->width;\n\t}\n\tfor (Line *l = start_line; l != end_line->next; l = l->next) {\n\t\tint col = (l == start_line) ? start_col : 0;\n\t\tint end = (l == end_line) ? end_col : l->width;\n\t\twhile (col < end)\n\t\t\tui_window_style_set(&win->vis->ui, win->id, &l->cells[col++], UI_STYLE_SELECTION);\n\t}\n}\n\nstatic void window_draw_cursor_matching(Win *win, Selection *cur) {\n\tif (win->vis->mode->visual)\n\t\treturn;\n\tLine *line_match; int col_match;\n\tsize_t pos = view_cursors_pos(cur);\n\tFilerange limits = VIEW_VIEWPORT_GET(win->view);\n\tsize_t pos_match = text_bracket_match_symbol(win->file->text, pos, \"(){}[]\\\"'`\", &limits);\n\tif (pos == pos_match)\n\t\treturn;\n\tif (!view_coord_get(&win->view, pos_match, &line_match, NULL, &col_match))\n\t\treturn;\n\tui_window_style_set(&win->vis->ui, win->id, &line_match->cells[col_match], UI_STYLE_SELECTION);\n}\n\nstatic void window_draw_cursor(Win *win, Selection *cur) {\n\tif (win->vis->win != win)\n\t\treturn;\n\tLine *line = cur->line;\n\tif (!line)\n\t\treturn;\n\tSelection *primary = view_selections_primary_get(&win->view);\n\tui_window_style_set(&win->vis->ui, win->id, &line->cells[cur->col], primary == cur ? UI_STYLE_CURSOR_PRIMARY : UI_STYLE_CURSOR);\n\twindow_draw_cursor_matching(win, cur);\n\treturn;\n}\n\nstatic void window_draw_selections(Win *win) {\n\tFilerange viewport = VIEW_VIEWPORT_GET(win->view);\n\tSelection *sel = view_selections_primary_get(&win->view);\n\tfor (Selection *s = view_selections_prev(sel); s; s = view_selections_prev(s)) {\n\t\twindow_draw_selection(win, s);\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tif (pos < viewport.start)\n\t\t\tbreak;\n\t\twindow_draw_cursor(win, s);\n\t}\n\twindow_draw_selection(win, sel);\n\twindow_draw_cursor(win, sel);\n\tfor (Selection *s = view_selections_next(sel); s; s = view_selections_next(s)) {\n\t\twindow_draw_selection(win, s);\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tif (pos > viewport.end)\n\t\t\tbreak;\n\t\twindow_draw_cursor(win, s);\n\t}\n}\n\nstatic void window_draw_eof(Win *win) {\n\tView *view = &win->view;\n\tif (view->width == 0)\n\t\treturn;\n\tfor (Line *l = view->lastline->next; l; l = l->next) {\n\t\tstrncpy(l->cells[0].data, view->symbols[SYNTAX_SYMBOL_EOF], sizeof(l->cells[0].data)-1);\n\t\tui_window_style_set(&win->vis->ui, win->id, l->cells, UI_STYLE_EOF);\n\t}\n}\n\nvoid vis_window_draw(Win *win) {\n\tif (!view_update(&win->view))\n\t\treturn;\n\tVis *vis = win->vis;\n\tvis_event_emit(vis, VIS_EVENT_WIN_HIGHLIGHT, win);\n\n\twindow_draw_colorcolumn(win);\n\twindow_draw_cursorline(win);\n\tif (!vis->win || vis->win == win || vis->win->parent == win)\n\t\twindow_draw_selections(win);\n\twindow_draw_eof(win);\n\n\tvis_event_emit(vis, VIS_EVENT_WIN_STATUS, win);\n}\n\n\nvoid vis_window_invalidate(Win *win) {\n\tfor (Win *w = win->vis->windows; w; w = w->next) {\n\t\tif (w->file == win->file)\n\t\t\tview_draw(&w->view);\n\t}\n}\n\nWin *window_new_file(Vis *vis, File *file, enum UiOption options) {\n\tWin *win = calloc(1, sizeof(Win));\n\tif (!win)\n\t\treturn NULL;\n\twin->vis = vis;\n\twin->file = file;\n\tif (!view_init(win, file->text)) {\n\t\tfree(win);\n\t\treturn NULL;\n\t}\n\twin->expandtab = false;\n\tif (!ui_window_init(&vis->ui, win, options)) {\n\t\twindow_free(win);\n\t\treturn NULL;\n\t}\n\tmarklist_init(&win->jumplist, 32);\n\tmark_init(&win->saved_selections);\n\tfile->refcount++;\n\twin_options_set(win, win->options);\n\n\tif (vis->windows)\n\t\tvis->windows->prev = win;\n\twin->next = vis->windows;\n\tvis->windows = win;\n\tvis->win = win;\n\tui_window_focus(win);\n\tfor (size_t i = 0; i < LENGTH(win->modes); i++)\n\t\twin->modes[i].parent = &vis_modes[i];\n\tvis_event_emit(vis, VIS_EVENT_WIN_OPEN, win);\n\treturn win;\n}\n\nbool vis_window_reload(Win *win) {\n\tconst char *name = win->file->name;\n\tif (!name)\n\t\treturn false; /* can't reload unsaved file */\n\t/* temporarily unset file name, otherwise file_new returns the same File */\n\twin->file->name = NULL;\n\tFile *file = file_new(win->vis, name, false);\n\twin->file->name = name;\n\tif (!file)\n\t\treturn false;\n\tfile_free(win->vis, win->file);\n\tfile->refcount = 1;\n\twin->file = file;\n\tview_reload(&win->view, file->text);\n\treturn true;\n}\n\nbool vis_window_change_file(Win *win, const char* filename) {\n\tFile *file = file_new(win->vis, filename, false);\n\tif (!file)\n\t\treturn false;\n\tfile->refcount++;\n\tif (win->file)\n\t\tfile_free(win->vis, win->file);\n\twin->file = file;\n\tview_reload(&win->view, file->text);\n\treturn true;\n}\n\nbool vis_window_split(Win *original) {\n\toriginal->vis->ui.doupdate = false;\n\tWin *win = window_new_file(original->vis, original->file, UI_OPTION_STATUSBAR);\n\tif (!win)\n\t\treturn false;\n\tfor (size_t i = 0; i < LENGTH(win->modes); i++) {\n\t\tif (original->modes[i].bindings)\n\t\t\twin->modes[i].bindings = map_new();\n\t\tif (win->modes[i].bindings)\n\t\t\tmap_copy(win->modes[i].bindings, original->modes[i].bindings);\n\t}\n\twin->file = original->file;\n\twin_options_set(win, original->options);\n\tview_cursors_to(win->view.selection, view_cursor_get(&original->view));\n\twin->vis->ui.doupdate = true;\n\treturn true;\n}\n\nvoid vis_window_focus(Win *win) {\n\tif (!win)\n\t\treturn;\n\tVis *vis = win->vis;\n\tvis->win = win;\n\tui_window_focus(win);\n}\n\nvoid vis_window_next(Vis *vis) {\n\tWin *sel = vis->win;\n\tif (!sel)\n\t\treturn;\n\tvis_window_focus(sel->next ? sel->next : vis->windows);\n}\n\nvoid vis_window_prev(Vis *vis) {\n\tWin *sel = vis->win;\n\tif (!sel)\n\t\treturn;\n\tsel = sel->prev;\n\tif (!sel)\n\t\tfor (sel = vis->windows; sel->next; sel = sel->next);\n\tvis_window_focus(sel);\n}\n\nvoid vis_draw(Vis *vis) {\n\tfor (Win *win = vis->windows; win; win = win->next)\n\t\tview_draw(&win->view);\n}\n\nvoid vis_redraw(Vis *vis) {\n\tui_redraw(&vis->ui);\n\tui_draw(&vis->ui);\n}\n\nbool vis_window_new(Vis *vis, const char *filename) {\n\tFile *file = file_new(vis, filename, false);\n\tif (!file)\n\t\treturn false;\n\tvis->ui.doupdate = false;\n\tWin *win = window_new_file(vis, file, UI_OPTION_STATUSBAR|UI_OPTION_SYMBOL_EOF);\n\tif (!win) {\n\t\tfile_free(vis, file);\n\t\treturn false;\n\t}\n\tvis->ui.doupdate = true;\n\n\treturn true;\n}\n\nbool vis_window_new_fd(Vis *vis, int fd) {\n\tif (fd == -1)\n\t\treturn false;\n\tif (!vis_window_new(vis, NULL))\n\t\treturn false;\n\tvis->win->file->fd = fd;\n\treturn true;\n}\n\nbool vis_window_closable(Win *win) {\n\tif (!win || !text_modified(win->file->text))\n\t\treturn true;\n\treturn win->file->refcount > 1;\n}\n\nvoid vis_window_swap(Win *a, Win *b) {\n\tif (a == b || !a || !b)\n\t\treturn;\n\tVis *vis = a->vis;\n\tWin *tmp = a->next;\n\ta->next = b->next;\n\tb->next = tmp;\n\tif (a->next)\n\t\ta->next->prev = a;\n\tif (b->next)\n\t\tb->next->prev = b;\n\ttmp = a->prev;\n\ta->prev = b->prev;\n\tb->prev = tmp;\n\tif (a->prev)\n\t\ta->prev->next = a;\n\tif (b->prev)\n\t\tb->prev->next = b;\n\tif (vis->windows == a)\n\t\tvis->windows = b;\n\telse if (vis->windows == b)\n\t\tvis->windows = a;\n\tui_window_swap(a, b);\n\tif (vis->win == a)\n\t\tvis_window_focus(b);\n\telse if (vis->win == b)\n\t\tvis_window_focus(a);\n}\n\nvoid vis_window_close(Win *win) {\n\tif (!win)\n\t\treturn;\n\tVis *vis = win->vis;\n\tvis_event_emit(vis, VIS_EVENT_WIN_CLOSE, win);\n\tfile_free(vis, win->file);\n\tif (win->prev)\n\t\twin->prev->next = win->next;\n\tif (win->next)\n\t\twin->next->prev = win->prev;\n\tif (vis->windows == win)\n\t\tvis->windows = win->next;\n\tif (vis->win == win)\n\t\tvis->win = win->next ? win->next : win->prev;\n\tif (win == vis->message_window)\n\t\tvis->message_window = NULL;\n\twindow_free(win);\n\tif (vis->win)\n\t\tui_window_focus(vis->win);\n\tvis_draw(vis);\n}\n\nVis *vis_new(void) {\n\tVis *vis = calloc(1, sizeof(Vis));\n\tif (!vis)\n\t\treturn NULL;\n\tvis->exit_status = -1;\n\tif (!ui_terminal_init(&vis->ui)) {\n\t\tfree(vis);\n\t\treturn NULL;\n\t}\n\tui_init(&vis->ui, vis);\n\tvis->change_colors = true;\n\tfor (size_t i = 0; i < LENGTH(vis->registers); i++)\n\t\tregister_init(&vis->registers[i]);\n\tvis->registers[VIS_REG_BLACKHOLE].type = REGISTER_BLACKHOLE;\n\tvis->registers[VIS_REG_CLIPBOARD].type = REGISTER_CLIPBOARD;\n\tvis->registers[VIS_REG_PRIMARY].type = REGISTER_CLIPBOARD;\n\tvis->registers[VIS_REG_NUMBER].type = REGISTER_NUMBER;\n\tarray_init(&vis->operators);\n\tarray_init(&vis->motions);\n\tarray_init(&vis->textobjects);\n\tarray_init(&vis->bindings);\n\tarray_init(&vis->actions_user);\n\taction_reset(&vis->action);\n\tvis->input_queue = (Buffer){0};\n\tif (!(vis->command_file = file_new_internal(vis, NULL)))\n\t\tgoto err;\n\tif (!(vis->search_file = file_new_internal(vis, NULL)))\n\t\tgoto err;\n\tif (!(vis->error_file = file_new_internal(vis, NULL)))\n\t\tgoto err;\n\tif (!(vis->actions = map_new()))\n\t\tgoto err;\n\tif (!(vis->keymap = map_new()))\n\t\tgoto err;\n\tif (!sam_init(vis))\n\t\tgoto err;\n\tstruct passwd *pw;\n\tchar *shell = getenv(\"SHELL\");\n\tif ((!shell || !*shell) && (pw = getpwuid(getuid())))\n\t\tshell = pw->pw_shell;\n\tif (!shell || !*shell)\n\t\tshell = \"/bin/sh\";\n\tif (!(vis->shell = strdup(shell)))\n\t\tgoto err;\n\tvis->mode_prev = vis->mode = &vis_modes[VIS_MODE_NORMAL];\n\tvis_modes[VIS_MODE_INSERT].input  = vis_event_mode_insert_input;\n\tvis_modes[VIS_MODE_REPLACE].input = vis_event_mode_replace_input;\n\treturn vis;\nerr:\n\tvis_free(vis);\n\treturn NULL;\n}\n\nvoid vis_free(Vis *vis) {\n\tif (!vis)\n\t\treturn;\n\twhile (vis->windows)\n\t\tvis_window_close(vis->windows);\n\tvis_event_emit(vis, VIS_EVENT_QUIT);\n\tvis_process_waitall(vis);\n\tfile_free(vis, vis->command_file);\n\tfile_free(vis, vis->search_file);\n\tfile_free(vis, vis->error_file);\n\tfor (int i = 0; i < LENGTH(vis->registers); i++)\n\t\tregister_release(&vis->registers[i]);\n\tui_terminal_free(&vis->ui);\n\tif (vis->usercmds) {\n\t\tconst char *name;\n\t\twhile (map_first(vis->usercmds, &name) && vis_cmd_unregister(vis, name));\n\t}\n\tmap_free(vis->usercmds);\n\tmap_free(vis->cmds);\n\tif (vis->options) {\n\t\tconst char *name;\n\t\twhile (map_first(vis->options, &name) && vis_option_unregister(vis, name));\n\t}\n\tmap_free(vis->options);\n\tmap_free(vis->actions);\n\tmap_free(vis->keymap);\n\tbuffer_release(&vis->input_queue);\n\tfor (int i = 0; i < VIS_MODE_INVALID; i++)\n\t\tmap_free(vis_modes[i].bindings);\n\tarray_release_full(&vis->operators);\n\tarray_release_full(&vis->motions);\n\tarray_release_full(&vis->textobjects);\n\twhile (vis->bindings.len)\n\t\tvis_binding_free(vis, array_get_ptr(&vis->bindings, 0));\n\tarray_release(&vis->bindings);\n\twhile (vis->actions_user.len)\n\t\tvis_action_free(vis, array_get_ptr(&vis->actions_user, 0));\n\tarray_release(&vis->actions_user);\n\tfree(vis->shell);\n\tfree(vis);\n}\n\nvoid vis_insert(Vis *vis, size_t pos, const char *data, size_t len) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\ttext_insert(win->file->text, pos, data, len);\n\tvis_window_invalidate(win);\n}\n\nvoid vis_insert_key(Vis *vis, const char *data, size_t len) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tvis_insert(vis, pos, data, len);\n\t\tview_cursors_scroll_to(s, pos + len);\n\t}\n}\n\nvoid vis_replace(Vis *vis, size_t pos, const char *data, size_t len) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tText *txt = win->file->text;\n\tIterator it = text_iterator_get(txt, pos);\n\tint chars = text_char_count(data, len);\n\tfor (char c; chars-- > 0 && text_iterator_byte_get(&it, &c) && c != '\\n'; )\n\t\ttext_iterator_char_next(&it, NULL);\n\n\ttext_delete(txt, pos, it.pos - pos);\n\tvis_insert(vis, pos, data, len);\n}\n\nvoid vis_replace_key(Vis *vis, const char *data, size_t len) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tvis_replace(vis, pos, data, len);\n\t\tview_cursors_scroll_to(s, pos + len);\n\t}\n}\n\nvoid vis_delete(Vis *vis, size_t pos, size_t len) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\ttext_delete(win->file->text, pos, len);\n\tvis_window_invalidate(win);\n}\n\nbool vis_action_register(Vis *vis, const KeyAction *action) {\n\treturn map_put(vis->actions, action->name, action);\n}\n\nbool vis_keymap_add(Vis *vis, const char *key, const char *mapping) {\n\treturn map_put(vis->keymap, key, mapping);\n}\n\nvoid vis_keymap_disable(Vis *vis) {\n\tvis->keymap_disabled = true;\n}\n\nvoid vis_interrupt(Vis *vis) {\n\tvis->interrupted = true;\n}\n\nbool vis_interrupt_requested(Vis *vis) {\n\treturn vis->interrupted;\n}\n\nvoid vis_do(Vis *vis) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tFile *file = win->file;\n\tText *txt = file->text;\n\tView *view = &win->view;\n\tAction *a = &vis->action;\n\n\tint count = MAX(a->count, 1);\n\tif (a->op == &vis_operators[VIS_OP_MODESWITCH])\n\t\tcount = 1; /* count should apply to inserted text not motion */\n\tbool repeatable = a->op && !vis->macro_operator && !vis->win->parent;\n\tbool multiple_cursors = view->selection_count > 1;\n\n\tbool linewise = !(a->type & CHARWISE) && (\n\t\ta->type & LINEWISE || (a->movement && a->movement->type & LINEWISE) ||\n\t\tvis->mode == &vis_modes[VIS_MODE_VISUAL_LINE]);\n\n\tRegister *reg = a->reg;\n\tsize_t reg_slot = multiple_cursors ? EPOS : 0;\n\tsize_t last_reg_slot = reg_slot;\n\tif (!reg)\n\t\treg = &vis->registers[file->internal ? VIS_REG_PROMPT : VIS_REG_DEFAULT];\n\tif (a->op == &vis_operators[VIS_OP_PUT_AFTER] && multiple_cursors && vis_register_count(vis, reg) == 1)\n\t\treg_slot = 0;\n\n\tif (vis->mode->visual && a->op)\n\t\twindow_selection_save(win);\n\n\tfor (Selection *sel = view_selections(view), *next; sel; sel = next) {\n\t\tif (vis->interrupted)\n\t\t\tbreak;\n\n\t\tnext = view_selections_next(sel);\n\n\t\tsize_t pos = view_cursors_pos(sel);\n\t\tif (pos == EPOS) {\n\t\t\tif (!view_selections_dispose(sel))\n\t\t\t\tview_cursors_to(sel, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tOperatorContext c = {\n\t\t\t.count = count,\n\t\t\t.pos = pos,\n\t\t\t.newpos = EPOS,\n\t\t\t.range = text_range_empty(),\n\t\t\t.reg = reg,\n\t\t\t.reg_slot = reg_slot == EPOS ? (size_t)view_selections_number(sel) : reg_slot,\n\t\t\t.linewise = linewise,\n\t\t\t.arg = &a->arg,\n\t\t\t.context = a->op ? a->op->context : NULL,\n\t\t};\n\n\t\tlast_reg_slot = c.reg_slot;\n\n\t\tbool err = false;\n\t\tif (a->movement) {\n\t\t\tsize_t start = pos;\n\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\tsize_t pos_prev = pos;\n\t\t\t\tif (a->movement->txt)\n\t\t\t\t\tpos = a->movement->txt(txt, pos);\n\t\t\t\telse if (a->movement->cur)\n\t\t\t\t\tpos = a->movement->cur(sel);\n\t\t\t\telse if (a->movement->file)\n\t\t\t\t\tpos = a->movement->file(vis, file, sel);\n\t\t\t\telse if (a->movement->vis)\n\t\t\t\t\tpos = a->movement->vis(vis, txt, pos);\n\t\t\t\telse if (a->movement->view)\n\t\t\t\t\tpos = a->movement->view(vis, view);\n\t\t\t\telse if (a->movement->win)\n\t\t\t\t\tpos = a->movement->win(vis, win, pos);\n\t\t\t\telse if (a->movement->user)\n\t\t\t\t\tpos = a->movement->user(vis, win, a->movement->data, pos);\n\t\t\t\tif (pos == EPOS || a->movement->type & IDEMPOTENT || pos == pos_prev) {\n\t\t\t\t\terr = a->movement->type & COUNT_EXACT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (err) {\n\t\t\t\trepeatable = false;\n\t\t\t\tcontinue; // break?\n\t\t\t}\n\n\t\t\tif (pos == EPOS) {\n\t\t\t\tc.range.start = start;\n\t\t\t\tc.range.end = start;\n\t\t\t\tpos = start;\n\t\t\t} else {\n\t\t\t\tc.range = text_range_new(start, pos);\n\t\t\t\tc.newpos = pos;\n\t\t\t}\n\n\t\t\tif (!a->op) {\n\t\t\t\tif (a->movement->type & CHARWISE)\n\t\t\t\t\tview_cursors_scroll_to(sel, pos);\n\t\t\t\telse\n\t\t\t\t\tview_cursors_to(sel, pos);\n\t\t\t\tif (vis->mode->visual)\n\t\t\t\t\tc.range = view_selections_get(sel);\n\t\t\t} else if (a->movement->type & INCLUSIVE && c.range.end > start) {\n\t\t\t\tc.range.end = text_char_next(txt, c.range.end);\n\t\t\t} else if (linewise && (a->movement->type & LINEWISE_INCLUSIVE)) {\n\t\t\t\tc.range.end = text_char_next(txt, c.range.end);\n\t\t\t}\n\t\t} else if (a->textobj) {\n\t\t\tif (vis->mode->visual)\n\t\t\t\tc.range = view_selections_get(sel);\n\t\t\telse\n\t\t\t\tc.range.start = c.range.end = pos;\n\t\t\tfor (int i = 0; i < count; i++) {\n\t\t\t\tFilerange r = text_range_empty();\n\t\t\t\tif (a->textobj->txt)\n\t\t\t\t\tr = a->textobj->txt(txt, pos);\n\t\t\t\telse if (a->textobj->vis)\n\t\t\t\t\tr = a->textobj->vis(vis, txt, pos);\n\t\t\t\telse if (a->textobj->user)\n\t\t\t\t\tr = a->textobj->user(vis, win, a->textobj->data, pos);\n\t\t\t\tif (!text_range_valid(&r))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a->textobj->type & TEXTOBJECT_DELIMITED_OUTER) {\n\t\t\t\t\tr.start--;\n\t\t\t\t\tr.end++;\n\t\t\t\t} else if (linewise && (a->textobj->type & TEXTOBJECT_DELIMITED_INNER)) {\n\t\t\t\t\tr.start = text_line_next(txt, r.start);\n\t\t\t\t\tr.end = text_line_prev(txt, r.end);\n\t\t\t\t}\n\n\t\t\t\tif (vis->mode->visual || (i > 0 && !(a->textobj->type & TEXTOBJECT_NON_CONTIGUOUS)))\n\t\t\t\t\tc.range = text_range_union(&c.range, &r);\n\t\t\t\telse\n\t\t\t\t\tc.range = r;\n\n\t\t\t\tif (i < count - 1) {\n\t\t\t\t\tif (a->textobj->type & TEXTOBJECT_EXTEND_BACKWARD) {\n\t\t\t\t\t\tpos = c.range.start;\n\t\t\t\t\t\tif ((a->textobj->type & TEXTOBJECT_DELIMITED_INNER) && pos > 0)\n\t\t\t\t\t\t\tpos--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos = c.range.end;\n\t\t\t\t\t\tif (a->textobj->type & TEXTOBJECT_DELIMITED_INNER)\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (vis->mode->visual) {\n\t\t\tc.range = view_selections_get(sel);\n\t\t\tif (!text_range_valid(&c.range))\n\t\t\t\tc.range.start = c.range.end = pos;\n\t\t}\n\n\t\tif (linewise && vis->mode != &vis_modes[VIS_MODE_VISUAL])\n\t\t\tc.range = text_range_linewise(txt, &c.range);\n\t\tif (vis->mode->visual) {\n\t\t\tview_selections_set(sel, &c.range);\n\t\t\tsel->anchored = true;\n\t\t}\n\n\t\tif (a->op) {\n\t\t\tsize_t pos = a->op->func(vis, txt, &c);\n\t\t\tif (pos == EPOS) {\n\t\t\t\tview_selections_dispose(sel);\n\t\t\t} else if (pos <= text_size(txt)) {\n\t\t\t\tview_selection_clear(sel);\n\t\t\t\tview_cursors_to(sel, pos);\n\t\t\t}\n\t\t}\n\t}\n\n\tview_selections_normalize(view);\n\tif (a->movement && (a->movement->type & JUMP))\n\t\tvis_jumplist_save(vis);\n\n\tif (a->op) {\n\n\t\tif (a->op == &vis_operators[VIS_OP_YANK] ||\n\t\t    a->op == &vis_operators[VIS_OP_DELETE] ||\n\t\t    a->op == &vis_operators[VIS_OP_CHANGE] ||\n\t\t    a->op == &vis_operators[VIS_OP_REPLACE]) {\n\t\t\tregister_resize(reg, last_reg_slot+1);\n\t\t}\n\n\t\t/* we do not support visual repeat, still do something reasonable */\n\t\tif (vis->mode->visual && !a->movement && !a->textobj)\n\t\t\ta->movement = &vis_motions[VIS_MOVE_NOP];\n\n\t\t/* operator implementations must not change the mode,\n\t\t * they might get called multiple times (once for every cursor)\n\t\t */\n\t\tif (a->op == &vis_operators[VIS_OP_CHANGE]) {\n\t\t\tvis_mode_switch(vis, VIS_MODE_INSERT);\n\t\t} else if (a->op == &vis_operators[VIS_OP_MODESWITCH]) {\n\t\t\tvis_mode_switch(vis, a->mode);\n\t\t} else if (vis->mode == &vis_modes[VIS_MODE_OPERATOR_PENDING]) {\n\t\t\tmode_set(vis, vis->mode_prev);\n\t\t} else if (vis->mode->visual) {\n\t\t\tvis_mode_switch(vis, VIS_MODE_NORMAL);\n\t\t}\n\n\t\tif (vis->mode == &vis_modes[VIS_MODE_NORMAL])\n\t\t\tvis_file_snapshot(vis, file);\n\t\tvis_draw(vis);\n\t}\n\n\tif (a != &vis->action_prev) {\n\t\tif (repeatable) {\n\t\t\tif (!a->macro)\n\t\t\t\ta->macro = vis->macro_operator;\n\t\t\tvis->action_prev = *a;\n\t\t}\n\t\taction_reset(a);\n\t}\n}\n\nvoid action_reset(Action *a) {\n\tmemset(a, 0, sizeof(*a));\n\ta->count = VIS_COUNT_UNKNOWN;\n}\n\nvoid vis_cancel(Vis *vis) {\n\taction_reset(&vis->action);\n}\n\nvoid vis_die(Vis *vis, const char *msg, ...) {\n\tva_list ap;\n\tva_start(ap, msg);\n\tui_die(&vis->ui, msg, ap);\n\tva_end(ap);\n}\n\nconst char *vis_keys_next(Vis *vis, const char *keys) {\n\tif (!keys || !*keys)\n\t\treturn NULL;\n\tTermKeyKey key;\n\tTermKey *termkey = vis->ui.termkey;\n\tconst char *next = NULL;\n\t/* first try to parse a special key of the form <Key> */\n\tif (*keys == '<' && keys[1] && (next = termkey_strpkey(termkey, keys+1, &key, TERMKEY_FORMAT_VIM)) && *next == '>')\n\t\treturn next+1;\n\tif (strncmp(keys, \"<vis-\", 5) == 0) {\n\t\tconst char *start = keys + 1, *end = start;\n\t\twhile (*end && *end != '>')\n\t\t\tend++;\n\t\tif (end > start && end - start - 1 < VIS_KEY_LENGTH_MAX && *end == '>') {\n\t\t\tchar key[VIS_KEY_LENGTH_MAX];\n\t\t\tmemcpy(key, start, end - start);\n\t\t\tkey[end - start] = '\\0';\n\t\t\tif (map_get(vis->actions, key))\n\t\t\t\treturn end + 1;\n\t\t}\n\t}\n\tif (ISUTF8(*keys))\n\t\tkeys++;\n\twhile (!ISUTF8(*keys))\n\t\tkeys++;\n\treturn keys;\n}\n\nlong vis_keys_codepoint(Vis *vis, const char *keys) {\n\tlong codepoint = -1;\n\tconst char *next;\n\tTermKeyKey key;\n\tTermKey *termkey = vis->ui.termkey;\n\n\tif (!keys[0])\n\t\treturn -1;\n\tif (keys[0] == '<' && !keys[1])\n\t\treturn '<';\n\n\tif (keys[0] == '<' && (next = termkey_strpkey(termkey, keys+1, &key, TERMKEY_FORMAT_VIM)) && *next == '>')\n\t\tcodepoint = (key.type == TERMKEY_TYPE_UNICODE) ? key.code.codepoint : -1;\n\telse if ((next = termkey_strpkey(termkey, keys, &key, TERMKEY_FORMAT_VIM)))\n\t\tcodepoint = (key.type == TERMKEY_TYPE_UNICODE) ? key.code.codepoint : -1;\n\n\tif (codepoint != -1) {\n\t\tif (key.modifiers == TERMKEY_KEYMOD_CTRL)\n\t\t\tcodepoint &= 0x1f;\n\t\treturn codepoint;\n\t}\n\n\tif (!next || key.type != TERMKEY_TYPE_KEYSYM)\n\t\treturn -1;\n\n\tconst int keysym[] = {\n\t\tTERMKEY_SYM_ENTER, '\\n',\n\t\tTERMKEY_SYM_TAB, '\\t',\n\t\tTERMKEY_SYM_BACKSPACE, '\\b',\n\t\tTERMKEY_SYM_ESCAPE, 0x1b,\n\t\tTERMKEY_SYM_DELETE, 0x7f,\n\t\t0,\n\t};\n\n\tfor (const int *k = keysym; k[0]; k += 2) {\n\t\tif (key.code.sym == k[0])\n\t\t\treturn k[1];\n\t}\n\n\treturn -1;\n}\n\nbool vis_keys_utf8(Vis *vis, const char *keys, char utf8[static UTFmax+1]) {\n\tRune rune = vis_keys_codepoint(vis, keys);\n\tif (rune == (Rune)-1)\n\t\treturn false;\n\tsize_t len = runetochar(utf8, &rune);\n\tutf8[len] = '\\0';\n\treturn true;\n}\n\ntypedef struct {\n\tVis *vis;\n\tsize_t len;         // length of the prefix\n\tint count;          // how many bindings can complete this prefix\n\tbool angle_bracket; // does the prefix end with '<'\n} PrefixCompletion;\n\nstatic bool isprefix(const char *key, void *value, void *data) {\n\tPrefixCompletion *completion = data;\n\tif (!completion->angle_bracket) {\n\t\tcompletion->count++;\n\t} else {\n\t\tconst char *start = key + completion->len;\n\t\tconst char *end = vis_keys_next(completion->vis, start);\n\t\tif (end && start + 1 == end)\n\t\t\tcompletion->count++;\n\t}\n\treturn completion->count == 1;\n}\n\nstatic void vis_keys_process(Vis *vis, size_t pos) {\n\tBuffer *buf = &vis->input_queue;\n\tchar *keys = buf->data + pos, *start = keys, *cur = keys, *end = keys, *binding_end = keys;;\n\tbool prefix = false;\n\tKeyBinding *binding = NULL;\n\n\twhile (cur && *cur) {\n\n\t\tif (!(end = (char*)vis_keys_next(vis, cur))) {\n\t\t\tbuffer_remove(buf, keys - buf->data, strlen(keys));\n\t\t\treturn;\n\t\t}\n\n\t\tchar tmp = *end;\n\t\t*end = '\\0';\n\t\tprefix = false;\n\n\t\tfor (Mode *global_mode = vis->mode; global_mode && !prefix; global_mode = global_mode->parent) {\n\t\t\tfor (int global = 0; global < 2 && !prefix; global++) {\n\t\t\t\tMode *mode = (global || !vis->win) ?\n\t\t\t\t\t     global_mode :\n\t\t\t\t             &vis->win->modes[global_mode->id];\n\t\t\t\tif (!mode->bindings)\n\t\t\t\t\tcontinue;\n\t\t\t\t/* keep track of longest matching binding */\n\t\t\t\tKeyBinding *match = map_get(mode->bindings, start);\n\t\t\t\tif (match && end > binding_end) {\n\t\t\t\t\tbinding = match;\n\t\t\t\t\tbinding_end = end;\n\t\t\t\t}\n\n\t\t\t\tconst Map *pmap = map_prefix(mode->bindings, start);\n\t\t\t\tPrefixCompletion completions = {\n\t\t\t\t\t.vis = vis,\n\t\t\t\t\t.len = cur - start,\n\t\t\t\t\t.count = 0,\n\t\t\t\t\t.angle_bracket = !strcmp(cur, \"<\"),\n\t\t\t\t};\n\t\t\t\tmap_iterate(pmap, isprefix, &completions);\n\n\t\t\t\tprefix = (!match && completions.count > 0) ||\n\t\t\t\t         ( match && completions.count > 1);\n\t\t\t}\n\t\t}\n\n\t\t*end = tmp;\n\n\t\tif (prefix) {\n\t\t\t/* input so far is ambiguous, wait for more */\n\t\t\tcur = end;\n\t\t\tend = start;\n\t\t} else if (binding) { /* exact match */\n\t\t\tif (binding->action) {\n\t\t\t\tsize_t len = binding_end - start;\n\t\t\t\tstrcpy(vis->key_prev, vis->key_current);\n\t\t\t\tstrncpy(vis->key_current, start, len);\n\t\t\t\tvis->key_current[len] = '\\0';\n\t\t\t\tend = (char*)binding->action->func(vis, binding_end, &binding->action->arg);\n\t\t\t\tif (!end) {\n\t\t\t\t\tend = start;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart = cur = end;\n\t\t\t} else if (binding->alias) {\n\t\t\t\tbuffer_remove(buf, start - buf->data, binding_end - start);\n\t\t\t\tbuffer_insert0(buf, start - buf->data, binding->alias);\n\t\t\t\tcur = end = start;\n\t\t\t}\n\t\t\tbinding = NULL;\n\t\t\tbinding_end = start;\n\t\t} else { /* no keybinding */\n\t\t\tKeyAction *action = NULL;\n\t\t\tif (start[0] == '<' && end[-1] == '>') {\n\t\t\t\t/* test for special editor key command */\n\t\t\t\tchar tmp = end[-1];\n\t\t\t\tend[-1] = '\\0';\n\t\t\t\taction = map_get(vis->actions, start+1);\n\t\t\t\tend[-1] = tmp;\n\t\t\t\tif (action) {\n\t\t\t\t\tsize_t len = end - start;\n\t\t\t\t\tstrcpy(vis->key_prev, vis->key_current);\n\t\t\t\t\tstrncpy(vis->key_current, start, len);\n\t\t\t\t\tvis->key_current[len] = '\\0';\n\t\t\t\t\tend = (char*)action->func(vis, end, &action->arg);\n\t\t\t\t\tif (!end) {\n\t\t\t\t\t\tend = start;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!action && vis->mode->input) {\n\t\t\t\tend = (char*)vis_keys_next(vis, start);\n\t\t\t\tvis->mode->input(vis, start, end - start);\n\t\t\t}\n\t\t\tstart = cur = end;\n\t\t}\n\t}\n\n\tbuffer_remove(buf, keys - buf->data, end - keys);\n}\n\nvoid vis_keys_feed(Vis *vis, const char *input) {\n\tif (!input)\n\t\treturn;\n\tMacro macro = {0};\n\tif (!macro_append(&macro, input))\n\t\treturn;\n\t/* use internal function, to keep Lua based tests which use undo points working */\n\tmacro_replay_internal(vis, &macro);\n\tmacro_release(&macro);\n}\n\nstatic void vis_keys_push(Vis *vis, const char *input, size_t pos, bool record) {\n\tif (!input)\n\t\treturn;\n\tif (record && vis->recording)\n\t\tmacro_append(vis->recording, input);\n\tif (vis->macro_operator)\n\t\tmacro_append(vis->macro_operator, input);\n\tif (buffer_append0(&vis->input_queue, input))\n\t\tvis_keys_process(vis, pos);\n}\n\nstatic const char *getkey(Vis *vis) {\n\tTermKeyKey key = { 0 };\n\tif (!ui_getkey(&vis->ui, &key))\n\t\treturn NULL;\n\tui_info_hide(&vis->ui);\n\tbool use_keymap = vis->mode->id != VIS_MODE_INSERT &&\n\t                  vis->mode->id != VIS_MODE_REPLACE &&\n\t                  !vis->keymap_disabled;\n\tvis->keymap_disabled = false;\n\tif (key.type == TERMKEY_TYPE_UNICODE && use_keymap) {\n\t\tconst char *mapped = map_get(vis->keymap, key.utf8);\n\t\tif (mapped) {\n\t\t\tsize_t len = strlen(mapped)+1;\n\t\t\tif (len <= sizeof(key.utf8))\n\t\t\t\tmemcpy(key.utf8, mapped, len);\n\t\t}\n\t}\n\n\tTermKey *termkey = vis->ui.termkey;\n\tif (key.type == TERMKEY_TYPE_UNKNOWN_CSI) {\n\t\tlong args[18];\n\t\tsize_t nargs;\n\t\tunsigned long cmd;\n\t\tif (termkey_interpret_csi(termkey, &key, &args[2], &nargs, &cmd) == TERMKEY_RES_KEY) {\n\t\t\targs[0] = (long)cmd;\n\t\t\targs[1] = nargs;\n\t\t\tvis_event_emit(vis, VIS_EVENT_TERM_CSI, args);\n\t\t}\n\t\treturn getkey(vis);\n\t}\n\ttermkey_strfkey(termkey, vis->key, sizeof(vis->key), &key, TERMKEY_FORMAT_VIM);\n\treturn vis->key;\n}\n\nbool vis_signal_handler(Vis *vis, int signum, const siginfo_t *siginfo, const void *context) {\n\tswitch (signum) {\n\tcase SIGBUS:\n\t\tfor (File *file = vis->files; file; file = file->next) {\n\t\t\tif (text_mmaped(file->text, siginfo->si_addr))\n\t\t\t\tfile->truncated = true;\n\t\t}\n\t\tvis->sigbus = true;\n\t\tif (vis->running)\n\t\t\tsiglongjmp(vis->sigbus_jmpbuf, 1);\n\t\treturn true;\n\tcase SIGINT:\n\t\tvis->interrupted = true;\n\t\treturn true;\n\tcase SIGCONT:\n\t\tvis->resume = true;\n\t\t/* fall through */\n\tcase SIGWINCH:\n\t\tvis->need_resize = true;\n\t\treturn true;\n\tcase SIGTERM:\n\tcase SIGHUP:\n\t\tvis->terminate = true;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint vis_run(Vis *vis) {\n\tif (!vis->windows)\n\t\treturn EXIT_SUCCESS;\n\tif (vis->exit_status != -1)\n\t\treturn vis->exit_status;\n\tvis->running = true;\n\n\tvis_event_emit(vis, VIS_EVENT_START);\n\n\tstruct timespec idle = { .tv_nsec = 0 }, *timeout = NULL;\n\n\tsigset_t emptyset;\n\tsigemptyset(&emptyset);\n\tvis_draw(vis);\n\tvis->exit_status = EXIT_SUCCESS;\n\n\tsigsetjmp(vis->sigbus_jmpbuf, 1);\n\n\twhile (vis->running) {\n\t\tfd_set fds;\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(STDIN_FILENO, &fds);\n\n\t\tif (vis->sigbus) {\n\t\t\tchar *name = NULL;\n\t\t\tfor (Win *next, *win = vis->windows; win; win = next) {\n\t\t\t\tnext = win->next;\n\t\t\t\tif (win->file->truncated) {\n\t\t\t\t\tfree(name);\n\t\t\t\t\tname = strdup(win->file->name);\n\t\t\t\t\tvis_window_close(win);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis->windows)\n\t\t\t\tvis_die(vis, \"WARNING: file `%s' truncated!\\n\", name ? name : \"-\");\n\t\t\telse\n\t\t\t\tvis_info_show(vis, \"WARNING: file `%s' truncated!\\n\", name ? name : \"-\");\n\t\t\tvis->sigbus = false;\n\t\t\tfree(name);\n\t\t}\n\n\t\tif (vis->terminate)\n\t\t\tvis_die(vis, \"Killed by SIGTERM\\n\");\n\t\tif (vis->interrupted) {\n\t\t\tvis->interrupted = false;\n\t\t\tvis_keys_push(vis, \"<C-c>\", 0, true);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (vis->resume) {\n\t\t\tui_terminal_resume(&vis->ui);\n\t\t\tvis->resume = false;\n\t\t}\n\n\t\tif (vis->need_resize) {\n\t\t\tui_resize(&vis->ui);\n\t\t\tvis->need_resize = false;\n\t\t}\n\n\t\tui_draw(&vis->ui);\n\t\tidle.tv_sec = vis->mode->idle_timeout;\n\t\tint r = pselect(vis_process_before_tick(&fds) + 1, &fds, NULL, NULL,\n\t\t                timeout, &emptyset);\n\t\tif (r == -1 && errno == EINTR)\n\t\t\tcontinue;\n\n\t\tif (r < 0) {\n\t\t\t/* TODO save all pending changes to a ~suffixed file */\n\t\t\tvis_die(vis, \"Error in mainloop: %s\\n\", strerror(errno));\n\t\t}\n\t\tvis_process_tick(vis, &fds);\n\n\t\tif (!FD_ISSET(STDIN_FILENO, &fds)) {\n\t\t\tif (vis->mode->idle)\n\t\t\t\tvis->mode->idle(vis);\n\t\t\ttimeout = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttermkey_advisereadable(vis->ui.termkey);\n\t\tconst char *key;\n\n\t\twhile ((key = getkey(vis)))\n\t\t\tvis_keys_push(vis, key, 0, true);\n\n\t\tif (vis->mode->idle)\n\t\t\ttimeout = &idle;\n\t}\n\treturn vis->exit_status;\n}\n\nMacro *macro_get(Vis *vis, enum VisRegister id) {\n\tif (id == VIS_MACRO_LAST_RECORDED)\n\t\treturn vis->last_recording;\n\tif (VIS_REG_A <= id && id <= VIS_REG_Z)\n\t\tid -= VIS_REG_A;\n\tif (id < LENGTH(vis->registers))\n\t\treturn array_get(&vis->registers[id].values, 0);\n\treturn NULL;\n}\n\nvoid macro_operator_record(Vis *vis) {\n\tif (vis->macro_operator)\n\t\treturn;\n\tvis->macro_operator = macro_get(vis, VIS_MACRO_OPERATOR);\n\tvis->macro_operator->len = 0;\n}\n\nvoid macro_operator_stop(Vis *vis) {\n\tif (!vis->macro_operator)\n\t\treturn;\n\tMacro *dot = macro_get(vis, VIS_REG_DOT);\n\tbuffer_put(dot, vis->macro_operator->data, vis->macro_operator->len);\n\tvis->action_prev.macro = dot;\n\tvis->macro_operator = NULL;\n}\n\nbool vis_macro_record(Vis *vis, enum VisRegister id) {\n\tMacro *macro = macro_get(vis, id);\n\tif (vis->recording || !macro)\n\t\treturn false;\n\tif (!(VIS_REG_A <= id && id <= VIS_REG_Z))\n\t\tmacro->len = 0;\n\tvis->recording = macro;\n\tvis_event_emit(vis, VIS_EVENT_WIN_STATUS, vis->win);\n\treturn true;\n}\n\nbool vis_macro_record_stop(Vis *vis) {\n\tif (!vis->recording)\n\t\treturn false;\n\t/* XXX: hack to remove last recorded key, otherwise upon replay\n\t * we would start another recording */\n\tif (vis->recording->len > 1) {\n\t\tvis->recording->len--;\n\t\tvis->recording->data[vis->recording->len-1] = '\\0';\n\t}\n\tvis->last_recording = vis->recording;\n\tvis->recording = NULL;\n\tvis_event_emit(vis, VIS_EVENT_WIN_STATUS, vis->win);\n\treturn true;\n}\n\nbool vis_macro_recording(Vis *vis) {\n\treturn vis->recording;\n}\n\nstatic void macro_replay(Vis *vis, const Macro *macro) {\n\tconst Macro *replaying = vis->replaying;\n\tvis->replaying = macro;\n\tmacro_replay_internal(vis, macro);\n\tvis->replaying = replaying;\n}\n\nstatic void macro_replay_internal(Vis *vis, const Macro *macro) {\n\tsize_t pos = buffer_length0(&vis->input_queue);\n\tfor (char *key = macro->data, *next; key; key = next) {\n\t\tchar tmp;\n\t\tnext = (char*)vis_keys_next(vis, key);\n\t\tif (next) {\n\t\t\ttmp = *next;\n\t\t\t*next = '\\0';\n\t\t}\n\n\t\tvis_keys_push(vis, key, pos, false);\n\n\t\tif (next)\n\t\t\t*next = tmp;\n\t}\n}\n\nbool vis_macro_replay(Vis *vis, enum VisRegister id) {\n\tif (id == VIS_REG_SEARCH)\n\t\treturn vis_motion(vis, VIS_MOVE_SEARCH_REPEAT_FORWARD);\n\tif (id == VIS_REG_COMMAND) {\n\t\tconst char *cmd = register_get(vis, &vis->registers[id], NULL);\n\t\treturn vis_cmd(vis, cmd);\n\t}\n\n\tMacro *macro = macro_get(vis, id);\n\tif (!macro || macro == vis->recording)\n\t\treturn false;\n\tint count = VIS_COUNT_DEFAULT(vis->action.count, 1);\n\tvis_cancel(vis);\n\tfor (int i = 0; i < count; i++)\n\t\tmacro_replay(vis, macro);\n\tWin *win = vis->win;\n\tif (win)\n\t\tvis_file_snapshot(vis, win->file);\n\treturn true;\n}\n\nvoid vis_repeat(Vis *vis) {\n\tconst Macro *macro = vis->action_prev.macro;\n\tint count = vis->action.count;\n\tif (count != VIS_COUNT_UNKNOWN)\n\t\tvis->action_prev.count = count;\n\telse\n\t\tcount = vis->action_prev.count;\n\tvis->action = vis->action_prev;\n\tvis_mode_switch(vis, VIS_MODE_OPERATOR_PENDING);\n\tvis_do(vis);\n\tif (macro) {\n\t\tMode *mode = vis->mode;\n\t\tAction action_prev = vis->action_prev;\n\t\tif (count < 1 || action_prev.op == &vis_operators[VIS_OP_CHANGE])\n\t\t\tcount = 1;\n\t\tif (vis->action_prev.op == &vis_operators[VIS_OP_MODESWITCH])\n\t\t\tvis->action_prev.count = 1;\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tif (vis->interrupted)\n\t\t\t\tbreak;\n\t\t\tmode_set(vis, mode);\n\t\t\tmacro_replay(vis, macro);\n\t\t}\n\t\tvis->action_prev = action_prev;\n\t}\n\tvis_cancel(vis);\n\tWin *win = vis->win;\n\tif (win)\n\t\tvis_file_snapshot(vis, win->file);\n}\n\nVisCountIterator vis_count_iterator_get(Vis *vis, int def) {\n\treturn (VisCountIterator) {\n\t\t.vis = vis,\n\t\t.iteration = 0,\n\t\t.count = VIS_COUNT_DEFAULT(vis->action.count, def),\n\t};\n}\n\nVisCountIterator vis_count_iterator_init(Vis *vis, int count) {\n\treturn (VisCountIterator) {\n\t\t.vis = vis,\n\t\t.iteration = 0,\n\t\t.count = count,\n\t};\n}\n\nbool vis_count_iterator_next(VisCountIterator *it) {\n\tif (it->vis->interrupted)\n\t\treturn false;\n\treturn it->iteration++ < it->count;\n}\n\nvoid vis_exit(Vis *vis, int status) {\n\tvis->running = false;\n\tvis->exit_status = status;\n}\n\nvoid vis_insert_tab(Vis *vis) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tif (!win->expandtab) {\n\t\tvis_insert_key(vis, \"\\t\", 1);\n\t\treturn;\n\t}\n\tchar spaces[9];\n\tint tabwidth = MIN(vis->win->view.tabwidth, LENGTH(spaces) - 1);\n\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tint width = text_line_width_get(win->file->text, pos);\n\t\tint count = tabwidth - (width % tabwidth);\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tspaces[i] = ' ';\n\t\tspaces[count] = '\\0';\n\t\tvis_insert(vis, pos, spaces, count);\n\t\tview_cursors_scroll_to(s, pos + count);\n\t}\n}\n\nsize_t vis_text_insert_nl(Vis *vis, Text *txt, size_t pos) {\n\tsize_t indent_len = 0;\n\tchar byte, *indent = NULL;\n\t/* insert second newline at end of file, except if there is already one */\n\tbool eof = pos == text_size(txt);\n\tbool nl2 = eof && !(pos > 0 && text_byte_get(txt, pos-1, &byte) && byte == '\\n');\n\n\tif (vis->autoindent) {\n\t\t/* copy leading white space of current line */\n\t\tsize_t begin = text_line_begin(txt, pos);\n\t\tsize_t start = text_line_start(txt, begin);\n\t\tsize_t end = text_line_end(txt, start);\n\t\tif (start > pos)\n\t\t\tstart = pos;\n\t\tindent_len = start >= begin ? start-begin : 0;\n\t\tif (start == end) {\n\t\t\tpos = begin;\n\t\t} else {\n\t\t\tindent = malloc(indent_len+1);\n\t\t\tif (indent)\n\t\t\t\tindent_len = text_bytes_get(txt, begin, indent_len, indent);\n\t\t}\n\t}\n\n\ttext_insert(txt, pos, \"\\n\", 1);\n\tif (eof) {\n\t\tif (nl2)\n\t\t\ttext_insert(txt, text_size(txt), \"\\n\", 1);\n\t\telse\n\t\t\tpos--; /* place cursor before, not after nl */\n\t}\n\tpos++;\n\n\tif (indent)\n\t\ttext_insert(txt, pos, indent, indent_len);\n\tfree(indent);\n\treturn pos + indent_len;\n}\n\nvoid vis_insert_nl(Vis *vis) {\n\tWin *win = vis->win;\n\tif (!win)\n\t\treturn;\n\tText *txt = win->file->text;\n\tfor (Selection *s = view_selections(&win->view); s; s = view_selections_next(s)) {\n\t\tsize_t pos = view_cursors_pos(s);\n\t\tsize_t newpos = vis_text_insert_nl(vis, txt, pos);\n\t\t/* This is a bit of a hack to fix cursor positioning when\n\t\t * inserting a new line at the start of the view port.\n\t\t * It has the effect of resetting the mark used by the view\n\t\t * code to keep track of the start of the visible region.\n\t\t */\n\t\tview_cursors_to(s, pos);\n\t\tview_cursors_to(s, newpos);\n\t}\n\tvis_window_invalidate(win);\n}\n\nRegex *vis_regex(Vis *vis, const char *pattern) {\n\tif (!pattern && !(pattern = register_get(vis, &vis->registers[VIS_REG_SEARCH], NULL)))\n\t\treturn NULL;\n\tRegex *regex = text_regex_new();\n\tif (!regex)\n\t\treturn NULL;\n\tint cflags = REG_EXTENDED|REG_NEWLINE|(REG_ICASE*vis->ignorecase);\n\tif (text_regex_compile(regex, pattern, cflags) != 0) {\n\t\ttext_regex_free(regex);\n\t\treturn NULL;\n\t}\n\tregister_put0(vis, &vis->registers[VIS_REG_SEARCH], pattern);\n\treturn regex;\n}\n\nstatic int _vis_pipe(Vis *vis, File *file, Filerange *range, const char* buf, const char *argv[],\n\tvoid *stdout_context, ssize_t (*read_stdout)(void *stdout_context, char *data, size_t len),\n\tvoid *stderr_context, ssize_t (*read_stderr)(void *stderr_context, char *data, size_t len),\n\tbool fullscreen) {\n\n\t/* if an invalid range was given, stdin (i.e. key board input) is passed\n\t * through the external command. */\n\tText *text = file != NULL ? file->text : NULL;\n\tint pin[2], pout[2], perr[2], status = -1;\n\tbool interactive = buf == NULL && (range == NULL || !text_range_valid(range));\n\tFilerange rout = (interactive  || buf != NULL) ? text_range_new(0, 0) : *range;\n\n\tif (pipe(pin) == -1)\n\t\treturn -1;\n\tif (pipe(pout) == -1) {\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\treturn -1;\n\t}\n\n\tif (pipe(perr) == -1) {\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\treturn -1;\n\t}\n\n\tui_terminal_save(&vis->ui, fullscreen);\n\tpid_t pid = fork();\n\n\tif (pid == -1) {\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tclose(pout[0]);\n\t\tclose(pout[1]);\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n\t\tvis_info_show(vis, \"fork failure: %s\", strerror(errno));\n\t\treturn -1;\n\t} else if (pid == 0) { /* child i.e filter */\n\t\tsigset_t sigterm_mask;\n\t\tsigemptyset(&sigterm_mask);\n\t\tsigaddset(&sigterm_mask, SIGTERM);\n\t\tif (sigprocmask(SIG_UNBLOCK, &sigterm_mask, NULL) == -1) {\n\t\t\tfprintf(stderr, \"failed to reset signal mask\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tint null = open(\"/dev/null\", O_RDWR);\n\t\tif (null == -1) {\n\t\t\tfprintf(stderr, \"failed to open /dev/null\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (!interactive) {\n\t\t\t/* If we have nothing to write, let stdin point to\n\t\t\t * /dev/null instead of a pipe which is immediately\n\t\t\t * closed. Some programs behave differently when used\n\t\t\t * in a pipeline.\n\t\t\t */\n\t\t\tif (range && text_range_size(range) == 0)\n\t\t\t\tdup2(null, STDIN_FILENO);\n\t\t\telse\n\t\t\t\tdup2(pin[0], STDIN_FILENO);\n\t\t}\n\n\t\tclose(pin[0]);\n\t\tclose(pin[1]);\n\t\tif (interactive) {\n\t\t\tdup2(STDERR_FILENO, STDOUT_FILENO);\n\t\t\t/* For some reason the first byte written by the\n\t\t\t * interactive application is not being displayed.\n\t\t\t * It probably has something to do with the terminal\n\t\t\t * state change. By writing a dummy byte ourself we\n\t\t\t * ensure that the complete output is visible.\n\t\t\t */\n\t\t\twhile(write(STDOUT_FILENO, \" \", 1) == -1 && errno == EINTR);\n\t\t} else if (read_stdout) {\n\t\t\tdup2(pout[1], STDOUT_FILENO);\n\t\t} else {\n\t\t\tdup2(null, STDOUT_FILENO);\n\t\t}\n\t\tclose(pout[1]);\n\t\tclose(pout[0]);\n\t\tif (!interactive) {\n\t\t\tif (read_stderr)\n\t\t\t\tdup2(perr[1], STDERR_FILENO);\n\t\t\telse\n\t\t\t\tdup2(null, STDERR_FILENO);\n\t\t}\n\t\tclose(perr[0]);\n\t\tclose(perr[1]);\n\t\tclose(null);\n\n\t\tif (file != NULL && file->name) {\n\t\t\tchar *name = strrchr(file->name, '/');\n\t\t\tsetenv(\"vis_filepath\", file->name, 1);\n\t\t\tsetenv(\"vis_filename\", name ? name+1 : file->name, 1);\n\t\t}\n\n\t\tif (!argv[1])\n\t\t\texeclp(vis->shell, vis->shell, \"-c\", argv[0], (char*)NULL);\n\t\telse\n\t\t\texecvp(argv[0], (char* const*)argv);\n\t\tfprintf(stderr, \"exec failure: %s\", strerror(errno));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tvis->interrupted = false;\n\n\tclose(pin[0]);\n\tclose(pout[1]);\n\tclose(perr[1]);\n\n\tif (fcntl(pout[0], F_SETFL, O_NONBLOCK) == -1 ||\n\t    fcntl(perr[0], F_SETFL, O_NONBLOCK) == -1)\n\t\tgoto err;\n\n\tfd_set rfds, wfds;\n\n\tdo {\n\t\tif (vis->interrupted) {\n\t\t\tkill(0, SIGTERM);\n\t\t\tbreak;\n\t\t}\n\n\t\tFD_ZERO(&rfds);\n\t\tFD_ZERO(&wfds);\n\t\tif (pin[1] != -1)\n\t\t\tFD_SET(pin[1], &wfds);\n\t\tif (pout[0] != -1)\n\t\t\tFD_SET(pout[0], &rfds);\n\t\tif (perr[0] != -1)\n\t\t\tFD_SET(perr[0], &rfds);\n\n\t\tif (select(FD_SETSIZE, &rfds, &wfds, NULL, NULL) == -1) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tvis_info_show(vis, \"Select failure\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pin[1] != -1 && FD_ISSET(pin[1], &wfds)) {\n\t\t\tssize_t written = 0;\n\t\t\tFilerange junk = rout;\n\t\t\tif (text_range_size(&rout)) {\n\t\t\t\tif (junk.end > junk.start + PIPE_BUF)\n\t\t\t\t\tjunk.end = junk.start + PIPE_BUF;\n\t\t\t\twritten = text_write_range(text, &junk, pin[1]);\n\t\t\t\tif (written > 0) {\n\t\t\t\t\trout.start += written;\n\t\t\t\t\tif (text_range_size(&rout) == 0) {\n\t\t\t\t\t\tclose(pin[1]);\n\t\t\t\t\t\tpin[1] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (buf != NULL) {\n\t\t\t\tsize_t len = strlen(buf);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tif (len > PIPE_BUF)\n\t\t\t\t\t\tlen = PIPE_BUF;\n\n\t\t\t\t\twritten = write_all(pin[1], buf, len);\n\t\t\t\t\tif (written > 0) {\n\t\t\t\t\t\tbuf += written;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (written <= 0) {\n\t\t\t\tclose(pin[1]);\n\t\t\t\tpin[1] = -1;\n\t\t\t\tif (written == -1)\n\t\t\t\t\tvis_info_show(vis, \"Error writing to external command\");\n\t\t\t}\n\t\t}\n\n\t\tif (pout[0] != -1 && FD_ISSET(pout[0], &rfds)) {\n\t\t\tchar buf[BUFSIZ];\n\t\t\tssize_t len = read(pout[0], buf, sizeof buf);\n\t\t\tif (len > 0) {\n\t\t\t\tif (read_stdout)\n\t\t\t\t\t(*read_stdout)(stdout_context, buf, len);\n\t\t\t} else if (len == 0) {\n\t\t\t\tclose(pout[0]);\n\t\t\t\tpout[0] = -1;\n\t\t\t} else if (errno != EINTR && errno != EWOULDBLOCK) {\n\t\t\t\tvis_info_show(vis, \"Error reading from filter stdout\");\n\t\t\t\tclose(pout[0]);\n\t\t\t\tpout[0] = -1;\n\t\t\t}\n\t\t}\n\n\t\tif (perr[0] != -1 && FD_ISSET(perr[0], &rfds)) {\n\t\t\tchar buf[BUFSIZ];\n\t\t\tssize_t len = read(perr[0], buf, sizeof buf);\n\t\t\tif (len > 0) {\n\t\t\t\tif (read_stderr)\n\t\t\t\t\t(*read_stderr)(stderr_context, buf, len);\n\t\t\t} else if (len == 0) {\n\t\t\t\tclose(perr[0]);\n\t\t\t\tperr[0] = -1;\n\t\t\t} else if (errno != EINTR && errno != EWOULDBLOCK) {\n\t\t\t\tvis_info_show(vis, \"Error reading from filter stderr\");\n\t\t\t\tclose(perr[0]);\n\t\t\t\tperr[0] = -1;\n\t\t\t}\n\t\t}\n\n\t} while (pin[1] != -1 || pout[0] != -1 || perr[0] != -1);\n\nerr:\n\tif (pin[1] != -1)\n\t\tclose(pin[1]);\n\tif (pout[0] != -1)\n\t\tclose(pout[0]);\n\tif (perr[0] != -1)\n\t\tclose(perr[0]);\n\n\tfor (;;) {\n\t\tif (vis->interrupted)\n\t\t\tkill(0, SIGTERM);\n\t\tpid_t died = waitpid(pid, &status, 0);\n\t\tif ((died == -1 && errno == ECHILD) || pid == died)\n\t\t\tbreak;\n\t}\n\n\t/* clear any pending SIGTERM */\n\tstruct sigaction sigterm_ignore, sigterm_old;\n\tsigterm_ignore.sa_handler = SIG_IGN;\n\tsigterm_ignore.sa_flags = 0;\n\tsigemptyset(&sigterm_ignore.sa_mask);\n\n\tsigaction(SIGTERM, &sigterm_ignore, &sigterm_old);\n\tsigaction(SIGTERM, &sigterm_old, NULL);\n\n\tvis->interrupted = false;\n\tui_terminal_restore(&vis->ui);\n\n\tif (WIFEXITED(status))\n\t\treturn WEXITSTATUS(status);\n\n\treturn -1;\n}\n\nint vis_pipe(Vis *vis, File *file, Filerange *range, const char *argv[],\n\tvoid *stdout_context, ssize_t (*read_stdout)(void *stdout_context, char *data, size_t len),\n\tvoid *stderr_context, ssize_t (*read_stderr)(void *stderr_context, char *data, size_t len),\n\tbool fullscreen) {\n\treturn _vis_pipe(vis, file, range, NULL, argv, stdout_context, read_stdout, stderr_context, read_stderr, fullscreen);\n}\n\nint vis_pipe_buf(Vis *vis, const char* buf, const char *argv[],\n\tvoid *stdout_context, ssize_t (*read_stdout)(void *stdout_context, char *data, size_t len),\n\tvoid *stderr_context, ssize_t (*read_stderr)(void *stderr_context, char *data, size_t len),\n\tbool fullscreen) {\n\treturn _vis_pipe(vis, NULL, NULL, buf, argv, stdout_context, read_stdout, stderr_context, read_stderr, fullscreen);\n}\n\nstatic int _vis_pipe_collect(Vis *vis, File *file, Filerange *range, const char* buf, const char *argv[], char **out, char **err, bool fullscreen) {\n\tBuffer bufout = {0}, buferr = {0};\n\tint status = _vis_pipe(vis, file, range, buf, argv,\n\t                      &bufout, out ? read_into_buffer : NULL,\n\t                      &buferr, err ? read_into_buffer : NULL,\n\t                      fullscreen);\n\tbuffer_terminate(&bufout);\n\tbuffer_terminate(&buferr);\n\tif (out) *out = bufout.data;\n\tif (err) *err = buferr.data;\n\treturn status;\n}\n\nint vis_pipe_collect(Vis *vis, File *file, Filerange *range, const char *argv[], char **out, char **err, bool fullscreen) {\n\treturn _vis_pipe_collect(vis, file, range, NULL, argv, out, err, fullscreen);\n}\n\nint vis_pipe_buf_collect(Vis *vis, const char* buf, const char *argv[], char **out, char **err, bool fullscreen) {\n\treturn _vis_pipe_collect(vis, NULL, NULL, buf, argv, out, err, fullscreen);\n}\n\nbool vis_cmd(Vis *vis, const char *cmdline) {\n\tif (!cmdline)\n\t\treturn true;\n\twhile (*cmdline == ':')\n\t\tcmdline++;\n\tchar *line = strdup(cmdline);\n\tif (!line)\n\t\treturn false;\n\n\tsize_t len = strlen(line);\n\twhile (len > 0 && isspace((unsigned char)line[len-1]))\n\t\tlen--;\n\tline[len] = '\\0';\n\n\tenum SamError err = sam_cmd(vis, line);\n\tif (err != SAM_ERR_OK)\n\t\tvis_info_show(vis, \"%s\", sam_error(err));\n\tfree(line);\n\treturn err == SAM_ERR_OK;\n}\n\nvoid vis_file_snapshot(Vis *vis, File *file) {\n\tif (!vis->replaying)\n\t\ttext_snapshot(file->text);\n}\n\nText *vis_text(Vis *vis) {\n\tWin *win = vis->win;\n\treturn win ? win->file->text : NULL;\n}\n\nView *vis_view(Vis *vis) {\n\tWin *win = vis->win;\n\treturn win ? &win->view : NULL;\n}\n"
        },
        {
          "name": "vis.h",
          "type": "blob",
          "size": 28.078125,
          "content": "#ifndef VIS_H\n#define VIS_H\n\n#include <signal.h>\n#include <stddef.h>\n#include <stdbool.h>\n\ntypedef struct Vis Vis;\ntypedef struct File File;\ntypedef struct Win Win;\n\n#include \"ui.h\"\n#include \"view.h\"\n#include \"text-regex.h\"\n#include \"libutf.h\"\n#include \"array.h\"\n\n#ifndef CONFIG_HELP\n#define CONFIG_HELP 1\n#endif\n\n#if CONFIG_HELP\n#define VIS_HELP_DECL(x) x\n#define VIS_HELP_USE(x) x\n#define VIS_HELP(x) (x),\n#else\n#define VIS_HELP_DECL(x)\n#define VIS_HELP_USE(x) NULL\n#define VIS_HELP(x)\n#endif\n\n/* simplify utility renames by distribution packagers */\n#ifndef VIS_OPEN\n#define VIS_OPEN \"vis-open\"\n#endif\n#ifndef VIS_CLIPBOARD\n#define VIS_CLIPBOARD \"vis-clipboard\"\n#endif\n\n/* maximum bytes needed for string representation of a (pseudo) key */\n#define VIS_KEY_LENGTH_MAX 64\n\n/** Union used to pass arguments to key action functions. */\ntypedef union {\n\tbool b;\n\tint i;\n\tconst char *s;\n\tconst void *v;\n\tvoid (*w)(View*);\n\tvoid (*f)(Vis*);\n} Arg;\n\n/**\n * Key action handling function.\n * @param keys Input queue content *after* the binding which invoked this function.\n * @rst\n * .. note:: An empty string ``\"\"`` indicates that no further input is available.\n * @endrst\n * @return Pointer to first non-consumed key.\n * @rst\n * .. warning:: Must be in range ``[keys, keys+strlen(keys)]`` or ``NULL`` to\n *              indicate that not enough input was available. In the latter case\n *              the function will be called again once more input has been received.\n * @endrst\n * @ingroup vis_action\n */\ntypedef const char *KeyActionFunction(Vis*, const char *keys, const Arg*);\n\n/** Key action definition. */\ntypedef struct {\n\tconst char *name;                /**< Name of a pseudo key ``<name>`` which can be used in mappings. */\n\tVIS_HELP_DECL(const char *help;) /**< One line human readable description, displayed by ``:help``. */\n\tKeyActionFunction *func;         /**< Key action implementation function. */\n\tArg arg;                         /**< Options passes as last argument to ``func``. */\n} KeyAction;\n\n/**\n * A key binding, refers to an action or an alias\n * @rst\n * .. note:: Either ``action`` or ``alias`` must be ``NULL``.\n * @endrst\n */\ntypedef struct {\n\tconst char *key;         /**< Symbolic key to trigger this binding. */\n\tconst KeyAction *action; /**< Action to invoke when triggering this binding. */\n\tconst char *alias;       /**< Replaces ``key`` with ``alias`` at the front of the input queue. */\n} KeyBinding;\n\n/**\n * @defgroup vis_lifecycle\n * @{\n */\n/** Create a new editor instance. */\nVis *vis_new(void);\n/** Free all resources associated with this editor instance, terminates UI. */\nvoid vis_free(Vis*);\n/**\n * Enter main loop, start processing user input.\n * @return The editor exit status code.\n */\nint vis_run(Vis*);\n/** Terminate editing session, the given ``status`` will be the return value of `vis_run`. */\nvoid vis_exit(Vis*, int status);\n/**\n * Emergency exit, print given message, perform minimal UI cleanup and exit process.\n * @rst\n * .. note:: This function does not return.\n * @endrst\n */\nvoid vis_die(Vis*, const char *msg, ...) __attribute__((noreturn,format(printf, 2, 3)));\n\n/**\n * Inform the editor core that a signal occurred.\n * @return Whether the signal was handled.\n * @rst\n * .. note:: Being designed as a library the editor core does *not* register any\n *           signal handlers on its own.\n * .. note:: The remaining arguments match the prototype of ``sa_sigaction`` as\n *           specified in `sigaction(2)`.\n * @endrst\n */\nbool vis_signal_handler(Vis*, int signum, const siginfo_t *siginfo, const void *context);\n/**\n * Interrupt long running operation.\n * @rst\n * .. warning:: There is no guarantee that a long running operation is actually\n *              interrupted. It is analogous to cooperative multitasking where\n *              the operation has to voluntarily yield control.\n * .. note:: It is invoked from `vis_signal_handler` when receiving ``SIGINT``.\n * @endrst\n */\nvoid vis_interrupt(Vis*);\n/** Check whether interruption was requested. */\nbool vis_interrupt_requested(Vis*);\n/**\n * @}\n * @defgroup vis_draw\n * @{\n */\n/** Draw user interface. */\nvoid vis_draw(Vis*);\n/** Completely redraw user interface. */\nvoid vis_redraw(Vis*);\n/**\n * @}\n * @defgroup vis_windows\n * @{\n */\n/**\n * Create a new window and load the given file.\n * @param filename If ``NULL`` an unnamed, empty buffer is created.\n * @rst\n * .. note:: If the given file name is already opened in another window,\n *           the underlying File object is shared.\n * @endrst\n */\nbool vis_window_new(Vis*, const char *filename);\n/**\n * Create a new window associated with a file descriptor.\n * @rst\n * .. note:: No data is read from `fd`, but write commands without an\n *           explicit filename will instead write to the file descriptor.\n * @endrst\n */\nbool vis_window_new_fd(Vis*, int fd);\n/** Reload the file currently displayed in the window from disk. */\nbool vis_window_reload(Win*);\n/** Change the file currently displayed in the window. */\nbool vis_window_change_file(Win*, const char *filename);\n/** Check whether closing the window would loose unsaved changes. */\nbool vis_window_closable(Win*);\n/** Close window, redraw user interface. */\nvoid vis_window_close(Win*);\n/** Split the window, shares the underlying file object. */\nbool vis_window_split(Win*);\nvoid vis_window_draw(Win*);\nvoid vis_window_invalidate(Win*);\n/** Focus next window. */\nvoid vis_window_next(Vis*);\n/** Focus previous window. */\nvoid vis_window_prev(Vis*);\n/** Change currently focused window, receiving user input. */\nvoid vis_window_focus(Win*);\n/** Swap location of two windows. */\nvoid vis_window_swap(Win*, Win*);\n/**\n * @}\n * @defgroup vis_info\n * @{\n */\n/**\n * Display a user prompt with a certain title.\n * @rst\n * .. note:: The prompt is currently implemented as a single line height window.\n * @endrst\n */\nvoid vis_prompt_show(Vis*, const char *title);\n\n/**\n * Display a single line message.\n * @rst\n * .. note:: The message will automatically be hidden upon next input.\n * @endrst\n */\nvoid vis_info_show(Vis*, const char *msg, ...) __attribute__((format(printf, 2, 3)));\n\n/** Display arbitrary long message in a dedicated window. */\nvoid vis_message_show(Vis*, const char *msg);\n/**\n * @}\n * @defgroup vis_changes\n * @{\n */\nvoid vis_insert(Vis*, size_t pos, const char *data, size_t len);\nvoid vis_delete(Vis*, size_t pos, size_t len);\nvoid vis_replace(Vis*, size_t pos, const char *data, size_t len);\n/** Perform insertion at all cursor positions. */\nvoid vis_insert_key(Vis*, const char *data, size_t len);\n/**\n * Perform character substitution at all cursor positions.\n * @rst\n * .. note:: Does not replace new line characters.\n * @endrst\n */\nvoid vis_replace_key(Vis*, const char *data, size_t len);\n/**\n * Insert a tab at all cursor positions.\n * @rst\n * .. note:: Performs tab expansion according to current settings.\n * @endrst\n */\nvoid vis_insert_tab(Vis*);\n/**\n * Inserts a new line character at every cursor position.\n * @rst\n * .. note:: Performs auto indentation according to current settings.\n * @endrst\n */\nvoid vis_insert_nl(Vis*);\n\n/** @} */\n/** Mode specifiers. */\nenum VisMode {\n\tVIS_MODE_NORMAL,\n\tVIS_MODE_OPERATOR_PENDING,\n\tVIS_MODE_VISUAL,\n\tVIS_MODE_VISUAL_LINE, /**< Sub mode of `VIS_MODE_VISUAL`. */\n\tVIS_MODE_INSERT,\n\tVIS_MODE_REPLACE, /**< Sub mode of `VIS_MODE_INSERT`. */\n\tVIS_MODE_INVALID,\n};\n\n/**\n * @defgroup vis_modes\n * @{\n */\n/**\n * Switch mode.\n * @rst\n * .. note:: Will first trigger the leave event of the currently active\n *           mode, followed by an enter event of the new mode.\n *           No events are emitted, if the specified mode is already active.\n * @endrst\n */\nvoid vis_mode_switch(Vis*, enum VisMode);\n/** Translate human readable mode name to constant. */\nenum VisMode vis_mode_from(Vis*, const char *name);\n\n/**\n * @}\n * @defgroup vis_keybind\n * @{\n */\nKeyBinding *vis_binding_new(Vis*);\nvoid vis_binding_free(Vis*, KeyBinding*);\n\n/**\n * Set up a key binding.\n * @param force Whether an existing mapping should be discarded.\n * @param key The symbolic key to map.\n * @param binding The binding to map.\n * @rst\n * .. note:: ``binding->key`` is always ignored in favor of ``key``.\n * @endrst\n */\nbool vis_mode_map(Vis*, enum VisMode, bool force, const char *key, const KeyBinding*);\n/** Analogous to `vis_mode_map`, but window specific. */\nbool vis_window_mode_map(Win*, enum VisMode, bool force, const char *key, const KeyBinding*);\n/** Unmap a symbolic key in a given mode. */\nbool vis_mode_unmap(Vis*, enum VisMode, const char *key);\n/** Analogous to `vis_mode_unmap`, but window specific. */\nbool vis_window_mode_unmap(Win*, enum VisMode, const char *key);\n/**\n * @}\n * @defgroup vis_action\n * @{\n */\n/**\n * Create new key action.\n * @param name The name to be used as symbolic key when registering.\n * @param help Optional single line help text.\n * @param func The function implementing the key action logic.\n * @param arg Argument passed to function.\n */\nKeyAction *vis_action_new(Vis*, const char *name, const char *help, KeyActionFunction*, Arg);\nvoid vis_action_free(Vis*, KeyAction*);\n/**\n * Register key action.\n * @rst\n * .. note:: Makes the key action available under the pseudo key name specified\n *           in ``keyaction->name``.\n * @endrst\n */\nbool vis_action_register(Vis*, const KeyAction*);\n\n/**\n * @}\n * @defgroup vis_keymap\n * @{\n */\n\n/** Add a key translation. */\nbool vis_keymap_add(Vis*, const char *key, const char *mapping);\n/** Temporarily disable the keymap for the next key press. */\nvoid vis_keymap_disable(Vis*);\n\n/** @} */\n/** Operator specifiers. */\nenum VisOperator {\n\tVIS_OP_DELETE,\n\tVIS_OP_CHANGE,\n\tVIS_OP_YANK,\n\tVIS_OP_PUT_AFTER,\n\tVIS_OP_SHIFT_RIGHT,\n\tVIS_OP_SHIFT_LEFT,\n\tVIS_OP_JOIN,\n\tVIS_OP_MODESWITCH,\n\tVIS_OP_REPLACE,\n\tVIS_OP_CURSOR_SOL,\n\tVIS_OP_INVALID, /* denotes the end of the \"real\" operators */\n\t/* pseudo operators: keep them at the end to save space in array definition */\n\tVIS_OP_CURSOR_EOL,\n\tVIS_OP_PUT_AFTER_END,\n\tVIS_OP_PUT_BEFORE,\n\tVIS_OP_PUT_BEFORE_END,\n\tVIS_OP_LAST, /* has to be last enum member */\n};\n\n/**\n * @defgroup vis_operators\n * @{\n */\ntypedef struct OperatorContext OperatorContext;\n\n/**\n * An operator performs a certain function on a given text range.\n * @rst\n * .. note:: The operator must return the new cursor position or ``EPOS`` if\n *           the cursor should be disposed.\n * .. note:: The last used operator can be repeated using `vis_repeat`.\n * @endrst\n */\ntypedef size_t (VisOperatorFunction)(Vis*, Text*, OperatorContext*);\n\n/**\n * Register an operator.\n * @return Operator ID. Negative values indicate an error, positive ones can be\n *         used with `vis_operator`.\n */\nint vis_operator_register(Vis*, VisOperatorFunction*, void *context);\n\n/**\n * Set operator to execute.\n *\n * Has immediate effect if:\n *  - A visual mode is active.\n *  - The same operator was already set (range will be the current line).\n *\n * Otherwise the operator will be executed on the range determined by:\n *  - A motion (see `vis_motion`).\n *  - A text object (`vis_textobject`).\n *\n * The expected varying arguments are:\n *\n *  - `VIS_OP_JOIN`       a char pointer referring to the text to insert between lines.\n *  - `VIS_OP_MODESWITCH` an ``enum VisMode`` indicating the mode to switch to.\n *  - `VIS_OP_REPLACE`    a char pointer referring to the replacement character.\n */\nbool vis_operator(Vis*, enum VisOperator, ...);\n\n/** Repeat last operator, possibly with a new count if one was provided in the meantime. */\nvoid vis_repeat(Vis*);\n\n/** Cancel pending operator, reset count, motion, text object, register etc. */\nvoid vis_cancel(Vis*);\n\n/** @} */\n/** Motion specifiers. */\nenum VisMotion {\n\tVIS_MOVE_LINE_DOWN,\n\tVIS_MOVE_LINE_UP,\n\tVIS_MOVE_SCREEN_LINE_UP,\n\tVIS_MOVE_SCREEN_LINE_DOWN,\n\tVIS_MOVE_SCREEN_LINE_BEGIN,\n\tVIS_MOVE_SCREEN_LINE_MIDDLE,\n\tVIS_MOVE_SCREEN_LINE_END,\n\tVIS_MOVE_LINE_PREV,\n\tVIS_MOVE_LINE_BEGIN,\n\tVIS_MOVE_LINE_START,\n\tVIS_MOVE_LINE_FINISH,\n\tVIS_MOVE_LINE_LASTCHAR,\n\tVIS_MOVE_LINE_END,\n\tVIS_MOVE_LINE_NEXT,\n\tVIS_MOVE_LINE,\n\tVIS_MOVE_COLUMN,\n\tVIS_MOVE_CHAR_PREV,\n\tVIS_MOVE_CHAR_NEXT,\n\tVIS_MOVE_LINE_CHAR_PREV,\n\tVIS_MOVE_LINE_CHAR_NEXT,\n\tVIS_MOVE_CODEPOINT_PREV,\n\tVIS_MOVE_CODEPOINT_NEXT,\n\tVIS_MOVE_WORD_NEXT,\n\tVIS_MOVE_WORD_START_NEXT,\n\tVIS_MOVE_WORD_END_PREV,\n\tVIS_MOVE_WORD_END_NEXT,\n\tVIS_MOVE_WORD_START_PREV,\n\tVIS_MOVE_LONGWORD_NEXT,\n\tVIS_MOVE_LONGWORD_START_PREV,\n\tVIS_MOVE_LONGWORD_START_NEXT,\n\tVIS_MOVE_LONGWORD_END_PREV,\n\tVIS_MOVE_LONGWORD_END_NEXT,\n\tVIS_MOVE_SENTENCE_PREV,\n\tVIS_MOVE_SENTENCE_NEXT,\n\tVIS_MOVE_PARAGRAPH_PREV,\n\tVIS_MOVE_PARAGRAPH_NEXT,\n\tVIS_MOVE_FUNCTION_START_PREV,\n\tVIS_MOVE_FUNCTION_START_NEXT,\n\tVIS_MOVE_FUNCTION_END_PREV,\n\tVIS_MOVE_FUNCTION_END_NEXT,\n\tVIS_MOVE_BLOCK_START,\n\tVIS_MOVE_BLOCK_END,\n\tVIS_MOVE_PARENTHESIS_START,\n\tVIS_MOVE_PARENTHESIS_END,\n\tVIS_MOVE_BRACKET_MATCH,\n\tVIS_MOVE_TO_LEFT,\n\tVIS_MOVE_TO_RIGHT,\n\tVIS_MOVE_TO_LINE_LEFT,\n\tVIS_MOVE_TO_LINE_RIGHT,\n\tVIS_MOVE_TILL_LEFT,\n\tVIS_MOVE_TILL_RIGHT,\n\tVIS_MOVE_TILL_LINE_LEFT,\n\tVIS_MOVE_TILL_LINE_RIGHT,\n\tVIS_MOVE_FILE_BEGIN,\n\tVIS_MOVE_FILE_END,\n\tVIS_MOVE_SEARCH_WORD_FORWARD,\n\tVIS_MOVE_SEARCH_WORD_BACKWARD,\n\tVIS_MOVE_SEARCH_REPEAT_FORWARD,\n\tVIS_MOVE_SEARCH_REPEAT_BACKWARD,\n\tVIS_MOVE_WINDOW_LINE_TOP,\n\tVIS_MOVE_WINDOW_LINE_MIDDLE,\n\tVIS_MOVE_WINDOW_LINE_BOTTOM,\n\tVIS_MOVE_CHANGELIST_NEXT,\n\tVIS_MOVE_CHANGELIST_PREV,\n\tVIS_MOVE_NOP,\n\tVIS_MOVE_PERCENT,\n\tVIS_MOVE_BYTE,\n\tVIS_MOVE_BYTE_LEFT,\n\tVIS_MOVE_BYTE_RIGHT,\n\tVIS_MOVE_INVALID, /* denotes the end of the \"real\" motions */\n\t/* pseudo motions: keep them at the end to save space in array definition */\n\tVIS_MOVE_TOTILL_REPEAT,\n\tVIS_MOVE_TOTILL_REVERSE,\n\tVIS_MOVE_SEARCH_FORWARD,\n\tVIS_MOVE_SEARCH_BACKWARD,\n\tVIS_MOVE_SEARCH_REPEAT,\n\tVIS_MOVE_SEARCH_REPEAT_REVERSE,\n\tVIS_MOVE_LAST, /* denotes the end of all motions */\n};\n\n/**\n * @defgroup vis_motions\n * @{\n */\n/**\n * Set motion to perform.\n *\n * The following motions take an additional argument:\n *\n *  - `VIS_MOVE_SEARCH_FORWARD` and `VIS_MOVE_SEARCH_BACKWARD`\n *\n *     The search pattern as ``const char *``.\n *\n *  - ``VIS_MOVE_{LEFT,RIGHT}_{TO,TILL}``\n *\n *     The character to search for as ``const char *``.\n */\nbool vis_motion(Vis*, enum VisMotion, ...);\n\nenum VisMotionType {\n\tVIS_MOTIONTYPE_LINEWISE  = 1 << 0,\n\tVIS_MOTIONTYPE_CHARWISE  = 1 << 1,\n};\n\n/** Force currently specified motion to behave in line or character wise mode. */\nvoid vis_motion_type(Vis *vis, enum VisMotionType);\n\n/**\n * Motions take a starting position and transform it to an end position.\n * @rst\n * .. note:: Should a motion not be possible, the original position must be returned.\n *           TODO: we might want to change that to ``EPOS``?\n * @endrst\n */\ntypedef size_t (VisMotionFunction)(Vis*, Win*, void *context, size_t pos);\n\n/**\n * Register a motion function.\n * @return Motion ID. Negative values indicate an error, positive ones can be\n *         used with `vis_motion`.\n */\nint vis_motion_register(Vis*, void *context, VisMotionFunction*);\n\n/**\n * @}\n * @defgroup vis_count\n * @{\n */\n/** No count was specified. */\n#define VIS_COUNT_UNKNOWN (-1)\n#define VIS_COUNT_DEFAULT(count, def) ((count) == VIS_COUNT_UNKNOWN ? (def) : (count))\n#define VIS_COUNT_NORMALIZE(count)    ((count) < 0 ? VIS_COUNT_UNKNOWN : (count))\n/** Set the shell */\nvoid vis_shell_set(Vis*, const char *new_shell);\n\ntypedef struct {\n\tVis *vis;\n\tint iteration;\n\tint count;\n} VisCountIterator;\n\n/** Get iterator initialized with current count or ``def`` if not specified. */\nVisCountIterator vis_count_iterator_get(Vis*, int def);\n/** Get iterator initialized with a count value. */\nVisCountIterator vis_count_iterator_init(Vis*, int count);\n/**\n * Increment iterator counter.\n * @return Whether iteration should continue.\n * @rst\n * .. note:: Terminates iteration if the editor was\n *           `interrupted <vis_interrupt>`_ in the meantime.\n * @endrst\n */\nbool vis_count_iterator_next(VisCountIterator*);\n\n/** @} */\n/** Text object specifier. */\nenum VisTextObject {\n\tVIS_TEXTOBJECT_INNER_WORD,\n\tVIS_TEXTOBJECT_OUTER_WORD,\n\tVIS_TEXTOBJECT_INNER_LONGWORD,\n\tVIS_TEXTOBJECT_OUTER_LONGWORD,\n\tVIS_TEXTOBJECT_SENTENCE,\n\tVIS_TEXTOBJECT_PARAGRAPH,\n\tVIS_TEXTOBJECT_PARAGRAPH_OUTER,\n\tVIS_TEXTOBJECT_OUTER_SQUARE_BRACKET,\n\tVIS_TEXTOBJECT_INNER_SQUARE_BRACKET,\n\tVIS_TEXTOBJECT_OUTER_CURLY_BRACKET,\n\tVIS_TEXTOBJECT_INNER_CURLY_BRACKET,\n\tVIS_TEXTOBJECT_OUTER_ANGLE_BRACKET,\n\tVIS_TEXTOBJECT_INNER_ANGLE_BRACKET,\n\tVIS_TEXTOBJECT_OUTER_PARENTHESIS,\n\tVIS_TEXTOBJECT_INNER_PARENTHESIS,\n\tVIS_TEXTOBJECT_OUTER_QUOTE,\n\tVIS_TEXTOBJECT_INNER_QUOTE,\n\tVIS_TEXTOBJECT_OUTER_SINGLE_QUOTE,\n\tVIS_TEXTOBJECT_INNER_SINGLE_QUOTE,\n\tVIS_TEXTOBJECT_OUTER_BACKTICK,\n\tVIS_TEXTOBJECT_INNER_BACKTICK,\n\tVIS_TEXTOBJECT_OUTER_LINE,\n\tVIS_TEXTOBJECT_INNER_LINE,\n\tVIS_TEXTOBJECT_INDENTATION,\n\tVIS_TEXTOBJECT_SEARCH_FORWARD,\n\tVIS_TEXTOBJECT_SEARCH_BACKWARD,\n\tVIS_TEXTOBJECT_INVALID,\n};\n\n/**\n * @defgroup vis_textobjs\n * @{\n */\n\n/**\n * Text objects take a starting position and return a text range.\n * @rst\n * .. note:: The originating position does not necessarily have to be contained in\n *           the resulting range.\n * @endrst\n */\ntypedef Filerange (VisTextObjectFunction)(Vis*, Win*, void *context, size_t pos);\n\n/**\n * Register a new text object.\n * @return Text object ID. Negative values indicate an error, positive ones can be\n *         used with `vis_textobject`.\n */\nint vis_textobject_register(Vis*, int type, void *data, VisTextObjectFunction*);\n\n/** Set text object to use. */\nbool vis_textobject(Vis*, enum VisTextObject);\n\n/** @} */\n/** Mark specifiers. */\nenum VisMark {\n\tVIS_MARK_DEFAULT,\n\tVIS_MARK_SELECTION,\n\tVIS_MARK_a, VIS_MARK_b, VIS_MARK_c, VIS_MARK_d, VIS_MARK_e,\n\tVIS_MARK_f, VIS_MARK_g, VIS_MARK_h, VIS_MARK_i, VIS_MARK_j,\n\tVIS_MARK_k, VIS_MARK_l, VIS_MARK_m, VIS_MARK_n, VIS_MARK_o,\n\tVIS_MARK_p, VIS_MARK_q, VIS_MARK_r, VIS_MARK_s, VIS_MARK_t,\n\tVIS_MARK_u, VIS_MARK_v, VIS_MARK_w, VIS_MARK_x, VIS_MARK_y,\n\tVIS_MARK_z,\n\tVIS_MARK_INVALID,     /* has to be the last enum member */\n};\n\n/**\n * @}\n * @defgroup vis_marks\n * @{\n */\n/** Translate between single character mark name and corresponding constant. */\nenum VisMark vis_mark_from(Vis*, char mark);\nchar vis_mark_to(Vis*, enum VisMark);\n/**\n * Specify mark to use.\n * @rst\n * .. note:: If none is specified `VIS_MARK_DEFAULT` will be used.\n * @endrst\n */\nvoid vis_mark(Vis*, enum VisMark);\nenum VisMark vis_mark_used(Vis*);\n/**\n * Store a set of ``Filerange``s in a mark.\n *\n * @param id The register to use.\n * @param sel The array containing the file ranges.\n */\nvoid vis_mark_set(Win*, enum VisMark id, Array *sel);\n/**\n * Get an array of file ranges stored in the mark.\n *\n * @rst\n * .. warning:: The caller must eventually free the Array by calling\n *              ``array_release``.\n * @endrst\n */\nArray vis_mark_get(Win*, enum VisMark id);\n/**\n * Normalize an Array of Fileranges.\n *\n * Removes invalid ranges, merges overlapping ones and sorts\n * according to the start position.\n */\nvoid vis_mark_normalize(Array*);\n/** Add selections of focused window to jump list. */\nbool vis_jumplist_save(Vis*);\n/** Navigate jump list backwards. */\nbool vis_jumplist_prev(Vis*);\n/** Navigate jump list forwards. */\nbool vis_jumplist_next(Vis*);\n/** @} */\n/** Register specifiers. */\nenum VisRegister {\n\tVIS_REG_DEFAULT,    /* used when no other register is specified */\n\tVIS_REG_ZERO,       /* yank register */\n\tVIS_REG_AMPERSAND,  /* last regex match */\n\tVIS_REG_1,\t    /* 1-9 last sub-expression matches */\n\tVIS_REG_2,\n\tVIS_REG_3,\n\tVIS_REG_4,\n\tVIS_REG_5,\n\tVIS_REG_6,\n\tVIS_REG_7,\n\tVIS_REG_8,\n\tVIS_REG_9,\n\tVIS_REG_BLACKHOLE,  /* /dev/null register */\n\tVIS_REG_CLIPBOARD,  /* system clipboard register */\n\tVIS_REG_PRIMARY,    /* system primary clipboard register */\n\tVIS_REG_DOT,        /* last inserted text, copy of VIS_MACRO_OPERATOR */\n\tVIS_REG_SEARCH,     /* last used search pattern \"/ */\n\tVIS_REG_COMMAND,    /* last used :-command \": */\n\tVIS_REG_SHELL,      /* last used shell command given to either <, >, |, or ! */\n\tVIS_REG_NUMBER,     /* cursor number */\n\tVIS_REG_a, VIS_REG_b, VIS_REG_c, VIS_REG_d, VIS_REG_e,\n\tVIS_REG_f, VIS_REG_g, VIS_REG_h, VIS_REG_i, VIS_REG_j,\n\tVIS_REG_k, VIS_REG_l, VIS_REG_m, VIS_REG_n, VIS_REG_o,\n\tVIS_REG_p, VIS_REG_q, VIS_REG_r, VIS_REG_s, VIS_REG_t,\n\tVIS_REG_u, VIS_REG_v, VIS_REG_w, VIS_REG_x, VIS_REG_y,\n\tVIS_REG_z,\n\tVIS_MACRO_OPERATOR, /* records entered keys after an operator */\n\tVIS_REG_PROMPT, /* internal register which shadows DEFAULT in PROMPT mode */\n\tVIS_REG_INVALID, /* has to be the last 'real' register */\n\tVIS_REG_A, VIS_REG_B, VIS_REG_C, VIS_REG_D, VIS_REG_E,\n\tVIS_REG_F, VIS_REG_G, VIS_REG_H, VIS_REG_I, VIS_REG_J,\n\tVIS_REG_K, VIS_REG_L, VIS_REG_M, VIS_REG_N, VIS_REG_O,\n\tVIS_REG_P, VIS_REG_Q, VIS_REG_R, VIS_REG_S, VIS_REG_T,\n\tVIS_REG_U, VIS_REG_V, VIS_REG_W, VIS_REG_X, VIS_REG_Y,\n\tVIS_REG_Z,\n\tVIS_MACRO_LAST_RECORDED, /* pseudo macro referring to last recorded one */\n};\n\n/**\n * @defgroup vis_registers\n * @{\n */\n/** Translate between single character register name and corresponding constant. */\nenum VisRegister vis_register_from(Vis*, char reg);\nchar vis_register_to(Vis*, enum VisRegister);\n/**\n * Specify register to use.\n * @rst\n * .. note:: If none is specified `VIS_REG_DEFAULT` will be used.\n * @endrst\n */\nvoid vis_register(Vis*, enum VisRegister);\nenum VisRegister vis_register_used(Vis*);\n/**\n * Get register content.\n * @return An array of ``TextString`` structs.\n * @rst\n * .. warning:: The caller must eventually free the array resources using\n *              ``array_release``.\n * @endrst\n */\nArray vis_register_get(Vis*, enum VisRegister);\n/**\n * Set register content.\n * @param data The array comprised of ``TextString`` structs.\n */\nbool vis_register_set(Vis*, enum VisRegister, Array *data);\n/**\n * @}\n * @defgroup vis_macros\n * @{\n */\n/**\n * Start recording a macro.\n * @rst\n * .. note:: Fails if a recording is already ongoing.\n * @endrst\n */\nbool vis_macro_record(Vis*, enum VisRegister);\n/** Stop recording, fails if there is nothing to stop. */\nbool vis_macro_record_stop(Vis*);\n/** Check whether a recording is currently ongoing. */\nbool vis_macro_recording(Vis*);\n/**\n * Replay a macro.\n * @rst\n * .. note:: A macro currently being recorded can not be replayed.\n * @endrst\n */\nbool vis_macro_replay(Vis*, enum VisRegister);\n\n/**\n * @}\n * @defgroup vis_cmds\n * @{\n */\n\n/** Execute a ``:``-command. */\nbool vis_cmd(Vis*, const char *cmd);\n\n/** Command handler function. */\ntypedef bool (VisCommandFunction)(Vis*, Win*, void *data, bool force,\n\tconst char *argv[], Selection*, Filerange*);\n/**\n * Register new ``:``-command.\n * @param name The command name.\n * @param help Optional single line help text.\n * @param context User supplied context pointer passed to the handler function.\n * @param func The function implementing the command logic.\n * @rst\n * .. note:: Any unique prefix of the command name will invoke the command.\n * @endrst\n */\nbool vis_cmd_register(Vis*, const char *name, const char *help, void *context, VisCommandFunction*);\n\n/** Unregister ``:``-command. */\nbool vis_cmd_unregister(Vis*, const char *name);\n\n/**\n * @}\n * @defgroup vis_options\n * @{\n */\n/** Option properties. */\nenum VisOption {\n\tVIS_OPTION_TYPE_BOOL = 1 << 0,\n\tVIS_OPTION_TYPE_STRING = 1 << 1,\n\tVIS_OPTION_TYPE_NUMBER = 1 << 2,\n\tVIS_OPTION_VALUE_OPTIONAL = 1 << 3,\n\tVIS_OPTION_NEED_WINDOW = 1 << 4,\n\tVIS_OPTION_DEPRECATED = 1 << 5,\n};\n\n/**\n * Option handler function.\n * @param win The window to which option should apply, might be ``NULL``.\n * @param context User provided context pointer as given to `vis_option_register`.\n * @param force Whether the option was specified with a bang ``!``.\n * @param name Name of option which was set.\n * @param arg The new option value.\n */\ntypedef bool (VisOptionFunction)(Vis*, Win*, void *context, bool toggle,\n                                 enum VisOption, const char *name, Arg *value);\n\n/**\n * Register a new ``:set`` option.\n * @param names A ``NULL`` terminated array of option names.\n * @param option Option properties.\n * @param func The function handling the option.\n * @param context User supplied context pointer passed to the handler function.\n * @param help Optional single line help text.\n * @rst\n * .. note:: Fails if any of the given option names is already registered.\n * @endrst\n */\nbool vis_option_register(Vis*, const char *names[], enum VisOption,\n                         VisOptionFunction*, void *context, const char *help);\n/**\n * Unregister an existing ``:set`` option.\n * @rst\n * .. note:: Also unregisters all aliases as given to `vis_option_register`.\n * @endrst\n */\nbool vis_option_unregister(Vis*, const char *name);\n\n/** Execute any kind (``:``, ``?``, ``/``) of prompt command */\nbool vis_prompt_cmd(Vis*, const char *cmd);\n\n/**\n * Pipe a given file range to an external process.\n *\n * If the range is invalid 'interactive' mode is enabled, meaning that\n * stdin and stderr are passed through the underlying command, stdout\n * points to vis' stderr.\n *\n * If ``argv`` contains only one non-NULL element the command is executed\n * through an intermediate shell (using ``/bin/sh -c argv[0]``) that is\n * argument expansion is performed by the shell. Otherwise the argument\n * list will be passed unmodified to ``execvp(argv[0], argv)``.\n *\n * If the ``read_stdout`` and ``read_stderr`` callbacks are non-NULL they\n * will be invoked when output from the forked process is available.\n *\n * If ``fullscreen`` is set to ``true`` the external process is assumed to\n * be a fullscreen program (e.g. curses based) and the ui context is\n * restored accordingly.\n *\n * @rst\n * .. warning:: The editor core is blocked until this function returns.\n * @endrst\n *\n * @return The exit status of the forked process.\n */\nint vis_pipe(Vis*, File*, Filerange*, const char *argv[],\n\tvoid *stdout_context, ssize_t (*read_stdout)(void *stdout_context, char *data, size_t len),\n\tvoid *stderr_context, ssize_t (*read_stderr)(void *stderr_context, char *data, size_t len),\n\tbool fullscreen);\n\n/**\n * Pipe a Filerange to an external process, return its exit status and capture\n * everything that is written to stdout/stderr.\n * @param argv Argument list, must be ``NULL`` terminated.\n * @param out Data written to ``stdout``, will be ``NUL`` terminated.\n * @param err Data written to ``stderr``, will be ``NUL`` terminated.\n * @param fullscreen Whether the external process is a fullscreen program (e.g. curses based)\n * @rst\n * .. warning:: The pointers stored in ``out`` and ``err`` need to be `free(3)`-ed\n *              by the caller.\n * @endrst\n */\nint vis_pipe_collect(Vis*, File*, Filerange*, const char *argv[], char **out, char **err, bool fullscreen);\n\n/**\n * Pipe a buffer to an external process, return its exit status and capture\n * everything that is written to stdout/stderr.\n * @param argv Argument list, must be ``NULL`` terminated.\n * @param out Data written to ``stdout``, will be ``NUL`` terminated.\n * @param err Data written to ``stderr``, will be ``NUL`` terminated.\n * @param fullscreen Whether the external process is a fullscreen program (e.g. curses based)\n * @rst\n * .. warning:: The pointers stored in ``out`` and ``err`` need to be `free(3)`-ed\n *              by the caller.\n * @endrst\n */\nint vis_pipe_buf_collect(Vis*, const char*, const char *argv[], char **out, char **err, bool fullscreen);\n\n/**\n * @}\n * @defgroup vis_keys\n * @{\n */\n/**\n * Advance to the start of the next symbolic key.\n *\n * Given the start of a symbolic key, returns a pointer to the start of the one\n * immediately following it.\n */\nconst char *vis_keys_next(Vis*, const char *keys);\n/** Convert next symbolic key to an Unicode code point, returns ``-1`` for unknown keys. */\nlong vis_keys_codepoint(Vis*, const char *keys);\n/**\n * Convert next symbolic key to a UTF-8 sequence.\n * @return Whether conversion was successful, if not ``utf8`` is left unmodified.\n * @rst\n * .. note:: Guarantees that ``utf8`` is NUL terminated on success.\n * @endrst\n */\nbool vis_keys_utf8(Vis*, const char *keys, char utf8[static UTFmax+1]);\n/** Process symbolic keys as if they were user originated input. */\nvoid vis_keys_feed(Vis*, const char *keys);\n/**\n * @}\n * @defgroup vis_misc\n * @{\n */\n\n/**\n * Get a regex object matching pattern.\n * @param regex The regex pattern to compile, if ``NULL`` the most recently used\n *        one is substituted.\n * @return A Regex object or ``NULL`` in case of an error.\n * @rst\n * .. warning:: The caller must free the regex object using `text_regex_free`.\n * @endrst\n */\nRegex *vis_regex(Vis*, const char *pattern);\n\n/**\n * Take an undo snapshot to which we can later revert.\n * @rst\n * .. note:: Does nothing when invoked while replaying a macro.\n * @endrst\n */\nvoid vis_file_snapshot(Vis*, File*);\n/** @} */\n\n/* TODO: expose proper API to iterate through files etc */\nText *vis_text(Vis*);\nView *vis_view(Vis*);\n\n#endif\n"
        }
      ]
    }
  ]
}