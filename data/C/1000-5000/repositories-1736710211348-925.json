{
  "metadata": {
    "timestamp": 1736710211348,
    "page": 925,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cmuratori/refterm",
      "stars": 1616,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0380859375,
          "content": ".vs\n*.exe\n*.pdb\n*.obj\nrefterm_shader.h\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.2099609375,
          "content": "# refterm v2\n\nrefterm is a reference renderer for monospace terminal displays.  It was designed to demonstrate that even in the worst-case scenario - extremely slow Unicode parsing with Uniscribe and extremely slow glyph generation with DirectWrite - it is still straightforward to achieve reasonable frame rates and reasonable throughput by being sensible.\n\n__Please note that refterm is UTF-8__.  If you are doing tests with it, you must use UTF-8 encoded files or command output.\n\n# Simple Code, Reasonable Speed\n\nrefterm actually isn't very fast.  Despite being several orders of magnitude faster than Windows Terminal, __refterm is largely unoptimized and is much slower than it could be__.  It is nothing more than a straightforward implementation of a tile renderer, with a very simple cache to ensure that glyph generation only gets called when new glyphs are seen.  It is all very, very simple.  A more complex codebase that parsed Unicode and rendered glyphs itself would likely be _much_ faster than refterm for many important metrics.\n\nVT code and line break parsing in refterm has had one piece of optimization in v2.  It now checks each 16-byte block for control codes before actually running the parser.  This was done to help test high-bandwidth throughput.  The actual control code parser has still not been optimized at all, however.\n\nTL;DR: refterm should be thought of as establishing a modern _minimum_ speed at which a reasonable terminal should be expected to perform.  It should not be thought of as a maximum to aspire to.  If your terminal runs _slower_ than refterm, that is not a good sign.\n\n# Feature Support\n\nrefterm is designed to support several features, just to ensure that no shortcuts have been taken in the design of the renderer.  As such, refterm supports:\n\n* Multicolor fonts\n* All of Unicode, including combining characters and right-to-left text like Arabic\n* Glyphs that can take up several cells\n* Line wrapping\n* Reflowing line wrapping on terminal resize\n* Large scrollback buffer\n* VT codes for setting colors and cursor positions, as well as strikethrough, underline, blink, reverse video, etc.\n\nThese features are not designed to be comprehensive, since this is only meant to be a reference renderer, not a complete terminal.\n\n# Code Layout\n\nThe important code for the reference renderer resides in three simple files:\n\n* refterm.hlsl - shader for doing tile-based rendering\n* refterm_glyph_cache.h/c - cache for mapping Unicode runs to glyphs\n\nThe rest of the code - refterm_example_*.h/c - is just there to verify that the API for the glyph cache conveniently supports all the features a terminal needs.  The code in those files may be useful as a vague reference, but no thought was put into their design so it is not likely to be directly useful.\n\n# Fast Pipes\n\nPrior to v2, it was assumed that conhost had to be bypassed in order to do high-throughput terminal processing.  However, after some testing it was determined that so long as conhost receives large writes, it is actually within 10% of the fast pipe alternative.  So it _appears_ that so long as you either directly call WriteFile with large buffers, or you use stdio with large buffers and set stdout to binary mode, you _can_ get reasonable speed going through conhost!\n\n"
        },
        {
          "name": "build.bat",
          "type": "blob",
          "size": 1.646484375,
          "content": "@echo off\nsetlocal\n\nwhere /q cl || (\n  echo ERROR: \"cl\" not found - please run this from the MSVC x64 native tools command prompt.\n  exit /b 1\n)\n\nif \"%Platform%\" neq \"x64\" (\n    echo ERROR: Platform is not \"x64\" - please run this from the MSVC x64 native tools command prompt.\n    exit /b 1\n)\n\ncall fxc /nologo /T cs_5_0 /E ComputeMain /O3 /WX /Fh refterm_cs.h /Vn ReftermCSShaderBytes /Qstrip_reflect /Qstrip_debug /Qstrip_priv refterm.hlsl\ncall fxc /nologo /T ps_5_0 /E PixelMain /O3 /WX /Fh refterm_ps.h /Vn ReftermPSShaderBytes /Qstrip_reflect /Qstrip_debug /Qstrip_priv refterm.hlsl\ncall fxc /nologo /T vs_5_0 /E VertexMain /O3 /WX /Fh refterm_vs.h /Vn ReftermVSShaderBytes /Qstrip_reflect /Qstrip_debug /Qstrip_priv refterm.hlsl\n\nset CFLAGS=/nologo /W3 /Z7 /GS- /Gs999999\nset LDFLAGS=/incremental:no /opt:icf /opt:ref\n\nset CLANGCompileFlags= -g -nostdlib -nostdlib++ -mno-stack-arg-probe -maes\nset CLANGLinkFlags=-fuse-ld=lld -Wl,-subsystem:windows\n\nset BASE_FILES=refterm.c refterm_example_dwrite.cpp\n\ncall cl -D_DEBUG -Od -Ferefterm_debug_msvc.exe %CFLAGS% %BASE_FILES% /link %LDFLAGS% /subsystem:windows\ncall cl -O2 -Ferefterm_release_msvc.exe %CFLAGS% %BASE_FILES% /link %LDFLAGS% /subsystem:windows\n\ncall cl -O2 -Fesplat.exe %CFLAGS% splat.cpp /link %LDFLAGS% /subsystem:console\ncall cl -O2 -Fesplat2.exe %CFLAGS% splat2.cpp /link %LDFLAGS% /subsystem:console\n\nwhere /q clang || (\n  echo WARNING: \"clang\" not found - to run the fastest version of refterm, please install CLANG.\n  exit /b 1\n)\n\ncall clang %CLANGCompileFlags% %CLANGLinkFlags% %BASE_FILES% -o refterm_debug_clang.exe\ncall clang -O3 %CLANGCompileFlags% %CLANGLinkFlags% %BASE_FILES% -o refterm_release_clang.exe\n"
        },
        {
          "name": "faq.md",
          "type": "blob",
          "size": 5.8720703125,
          "content": "For people who know performance programming well, here are the things they might care about:\n\n## There are two separate problems to talk about with respect to terminal speed on Windows.\n\nOne is the speed of the renderer, and the other is the speed of the pipe.  In Windows Terminal they are both slow, but the degree to which they are bad depends on how you are using it.\n\n## The Windows Terminal renderer is slow itself. \n\nI have not done profiling of Windows Terminal directly, so there may be many sources of slowdown, take these with a grain of salt.  But at least two have been identified.  One is that it uses a standard \"modern C++\" approach to things with lots of indiscriminate use of things like std::vector and std::string, so even though there is no reason to ever allocate or deallocate anything when rendering a terminal, there is tons of that (and tons of call stacking, etc.) happening in the code base.  So the code in general does way, way more work than it needs to.\n\nBut that is likely only the reason it is slow when it is rendering single-color text.  The reason Windows Terminal gets slow when rendering multicolor text (like text where the color of the foreground and background changes frequently) is because there is no \"renderer\" per se in Windows Terminal, there is just a call to DirectWrite.  It calls DirectWrite as frequently as _once per character on the screen_ if it does not detect that a group of characters can be passed together.  Changing the background color is one of the (many) things that can prevent characters from being passed together, for example.  Obviously, a full call into DirectWrite every time you want to render a single character is going to put a signficant bound on how fast the terminal can update, no matter how optimized you made the rest of the code.\n\nSo the renderer in Windows Terminal is either slow (single color) or very slow (multiple background colors), before considering the pipe.\n\n## The console pipe in Windows is slow separately.\n\nWhenever you call CreateProcess() or otherwise cause a process to be created that uses /SUBSYSTEM:console, Windows inserts a thing called \"conhost\" in between the parent and the child process that intercepts all three standard handles (in, out, and error).  So communication between a terminal and a sub-process __is not just a pipe__.  It is actually a man-in-the-middle pipe with Windows doing a bunch of processing.\n\nThe reason for this architecture is because Windows supports a bunch of additional console calls (for example, https://docs.microsoft.com/en-us/windows/console/readconsoleoutputcharacter) which it obviously couldn't fulfill if it didn't buffer the output to the console itself.  So unlike a normal Windows pipe, a console pipe is artificially slow because it is intermediated by some code that is itself slow.\n\nIn the refterm demo, I attempted to \"measure\" this by showing the same code running with and without conhost as an intermediary.  I did this using a technique I called \"fast pipes\" (which you can see here: https://github.com/cmuratori/refterm/blob/main/fast_pipe.h).  All it does is use the process's ID to generate a unique named pipe with the Windows kernel that both the terminal and the child process then use in lieu of the intermediated handles they were given.\n\nThere is also a way in Windows 10 to do a limited bypass of conhost that allows a more complete terminal experience.  This is called ConPTY (https://github.com/microsoft/terminal/tree/main/src/winconpty) and it allows you to reimplement all the Windows conhost functions.  This is what you would need to do if you wanted to do a completely backwards-compatible terminal, so fast pipes is just a tool for testing.\n\n## How slow is each?\n\nIn the demo video (https://www.youtube.com/watch?v=hxM8QmyZXtg), I show comparisons between dumping a one gigabyte file to Windows Terminal Preview (their most recent release) through conhost, which takes on the order of 330 seconds; dumping to refterm through conhost, which takes on the order of 40 seconds, and dumping to refterm through fast pipes, which takes on the order of 6 seconds.\n\nThis pretty clearly demonstrates that Windows Terminal is 10x slower than it should be, and conhost is another 10x slower than it should be :)\n\nBut this was with completely unoptimized code (as I mentioned in the video).  So when I showed that demo, I didn't know how much of the 6 seconds was just my code being bad.  Later that weekend, I found some time to put in the most basic optimization I could think of, and the no-conhost refterm speed went down to around 0.6 seconds, another order of magnitude.\n\nBut there was more intrique.  In the course of doing so, I found that actually, __how you call conhost matters a great deal__.  From preliminary inspection, it _appears_ as if the number of _times_ you call conhost is the problem, at least for non-VT-code output.  This makes reasonable sense, since the handoff might be costly as it is two separate processes.  But what obscures this is the fact that using stdio _introduces_ lots of extra conhost calls, because if you do not turn text mode off, it will use small buffers and generate a lot more calls to conhost.\n\nSo, if you either a) use WriteFile() directly, or b) set stdio mode to binary, you will actually find that conhost adds only a small ~10% overhead to the processing, rather than 10x.\n\n## What about VT-codes?\n\nUnfortunately, conhost seems to still be relatively slow when VT-codes are turned on.  By default, Windows doesn't handle VT-codes - you have to call SetConsoleMode() with a new flag in order to enable them.  Once you do that, conhost is much slower, presumably because it is now going through \"modern\" code that does a ton of work it doesn't need to do.\n\n## That's probably not all.\n\nThis was a very spare-time project, which obviously I don't get paid to do.  There's a lot more to learn here, but those are the basic things that have been determined so far.\n\nHope that helps explain things.\n"
        },
        {
          "name": "fast_pipe.h",
          "type": "blob",
          "size": 1.966796875,
          "content": "/* NOTE(casey):\n\n   \"Fast pipe\" is a technique to bypass the (very slow) Windows conio subsystem.\n   Since the Windows kernel has reasonably fast pipes, if the calling process\n   opens a named pipe under the \"fastpipe########\" label, where the #'s are\n   replaced with our process ID, then we know that the shell on the other\n   side can accept direct output.  stdin and stdout are then remapped to\n   that pipe.\n   \n   To use, #include this file in your program, and insert\n   \n       USE_FAST_PIPE_IF_AVAILABLE();\n       \n   at the very start of your program (ideally the first line in main).\n   It will also optionally return non-zero when the fast pipe is available,\n   in case your program wishes to take special action when a fast pipe\n   exists:\n   \n       int FastPipeIsAvailable = USE_FAST_PIPE_IF_AVAILABLE();\n       \n   No further changes to the program should be necessary.  Note that\n   stderr is, by default, still mapped to the slow conio pipe.\n*/\n\n#if _WIN32\n#include <windows.h>\n#ifndef _VC_NODEFAULTLIB\n#include <io.h>\n#include <fcntl.h>\n#include <stdio.h>\n#endif\n#pragma comment (lib, \"kernel32.lib\")\n#pragma comment (lib, \"user32.lib\")\nstatic int USE_FAST_PIPE_IF_AVAILABLE()\n{\n    int Result = 0;\n    \n    wchar_t PipeName[32];\n    wsprintfW(PipeName, L\"\\\\\\\\.\\\\pipe\\\\fastpipe%x\", GetCurrentProcessId());\n    HANDLE FastPipe = CreateFileW(PipeName, GENERIC_READ|GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);\n    if(FastPipe != INVALID_HANDLE_VALUE)\n    {\n        SetStdHandle(STD_OUTPUT_HANDLE, FastPipe);\n        SetStdHandle(STD_INPUT_HANDLE, FastPipe);\n        \n#ifndef _VC_NODEFAULTLIB\n        int StdOut = _open_osfhandle((intptr_t)FastPipe, O_WRONLY|O_TEXT);\n        int StdIn = _open_osfhandle((intptr_t)FastPipe, O_RDONLY|O_TEXT);\n        \n        _dup2(StdOut, _fileno(stdout));\n        _dup2(StdIn, _fileno(stdin));\n        \n        _close(StdOut);\n        _close(StdIn);\n#endif\n\n        Result = 1;\n    }\n    \n    return Result;\n}\n#else\n#define USE_FAST_PIPE_IF_AVAILABLE(...) 0\n#endif\n"
        },
        {
          "name": "refterm.c",
          "type": "blob",
          "size": 4.6513671875,
          "content": "#if !_M_X64\n#error refterm requires a 64-bit platform\n#endif\n\n#define COBJMACROS\n#define NOMINMAX\n#define WIN32_LEAN_AND_MEAN\n#define _NO_CRT_STDIO_INLINE\n\n#include <windows.h>\n#include <shlwapi.h>\n#include <d3d11_1.h>\n#include <dxgi1_3.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <intrin.h>\n#include <usp10.h>\n#include <strsafe.h>\n#include <stdarg.h>\n\n#include <intrin.h>\n\n#include \"refterm.h\"\n\n#include \"refterm_glyph_cache.h\"\n#include \"refterm_glyph_cache.c\"\n\n#include \"refterm_vs.h\"\n#include \"refterm_ps.h\"\n#include \"refterm_cs.h\"\n#include \"refterm_example_source_buffer.h\"\n#include \"refterm_example_dwrite.h\"\n#include \"refterm_example_d3d11.h\"\n#include \"refterm_example_glyph_generator.h\"\n#include \"refterm_example_terminal.h\"\n#include \"refterm_example_source_buffer.c\"\n#include \"refterm_example_glyph_generator.c\"\n#include \"refterm_example_d3d11.c\"\n#include \"refterm_example_terminal.c\"\n\n#pragma comment (lib, \"kernel32\")\n#pragma comment (lib, \"user32\")\n#pragma comment (lib, \"gdi32\")\n#pragma comment (lib, \"usp10\")\n#pragma comment (lib, \"dwrite\")\n#pragma comment (lib, \"d2d1\")\n#pragma comment (lib, \"mincore\")\n\nDWORD RenderThreadID = 0;\n\nstatic LRESULT CALLBACK WindowProc(HWND Window, UINT Message, WPARAM WParam, LPARAM LParam)\n{\n    LRESULT Result = 0;\n\n    switch (Message)\n    {\n        case WM_CLOSE:\n        case WM_DESTROY:\n        {\n            PostQuitMessage(0);\n        } break;\n        \n        case WM_CHAR:\n        case WM_SIZE:\n        {\n            PostThreadMessageW(RenderThreadID, Message, WParam, LParam);\n        } break;\n\n        default:\n        {\n            Result = DefWindowProcW(Window, Message, WParam, LParam);\n        } break;\n    }\n\n    return Result;\n}\n\ntypedef BOOL WINAPI set_process_dpi_aware(void);\ntypedef BOOL WINAPI set_process_dpi_awareness_context(DPI_AWARENESS_CONTEXT);\nstatic void PreventWindowsDPIScaling()\n{\n    HMODULE WinUser = LoadLibraryW(L\"user32.dll\");\n    set_process_dpi_awareness_context *SetProcessDPIAwarenessContext = (set_process_dpi_awareness_context *)GetProcAddress(WinUser, \"SetProcessDPIAwarenessContext\");\n    if(SetProcessDPIAwarenessContext)\n    {\n        SetProcessDPIAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE);\n    }\n    else\n    {\n        set_process_dpi_aware *SetProcessDPIAware = (set_process_dpi_aware *)GetProcAddress(WinUser, \"SetProcessDPIAware\");\n        if(SetProcessDPIAware)\n        {\n            SetProcessDPIAware();\n        }\n    }\n}\n\nstatic HWND CreateOutputWindow()\n{\n    WNDCLASSEXW WindowClass =\n    {\n        .cbSize = sizeof(WindowClass),\n        .lpfnWndProc = &WindowProc,\n        .hInstance = GetModuleHandleW(NULL),\n        .hIcon = LoadIconA(NULL, IDI_APPLICATION),\n        .hCursor = LoadCursorA(NULL, IDC_ARROW),\n        .hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH),\n        .lpszClassName = L\"reftermclass\",\n    };\n\n    HWND Result = {0};\n    if(RegisterClassExW(&WindowClass))\n    {\n        // NOTE(casey): Martins says WS_EX_NOREDIRECTIONBITMAP is necessary to make\n        // DXGI_SWAP_EFFECT_FLIP_DISCARD \"not glitch on window resizing\", and since\n        // I don't normally program DirectX and have no idea, we're just going to\n        // leave it here :)\n        DWORD ExStyle = WS_EX_APPWINDOW | WS_EX_NOREDIRECTIONBITMAP;\n\n        Result = CreateWindowExW(ExStyle, WindowClass.lpszClassName, L\"refterm\", WS_OVERLAPPEDWINDOW,\n                                 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\n                                 0, 0, WindowClass.hInstance, 0);\n    }\n\n    return Result;\n}\n\nvoid WinMainCRTStartup()\n{\n    PreventWindowsDPIScaling();\n\n    HWND Window = CreateOutputWindow();\n    Assert(IsWindow(Window));\n\n    CreateThread(0, 0, TerminalThread, Window, 0, &RenderThreadID);\n\n    for(;;)\n    {\n        MSG Message;\n        GetMessageW(&Message, 0, 0, 0);\n        TranslateMessage(&Message);\n        if((Message.message == WM_CHAR) ||\n           (Message.message == WM_KEYDOWN) ||\n           (Message.message == WM_QUIT) ||\n           (Message.message == WM_SIZE))\n        {\n            PostThreadMessageW(RenderThreadID, Message.message, Message.wParam, Message.lParam);\n        }\n        else\n        {\n            DispatchMessageW(&Message);\n        }\n    }\n}\n\n// CRT stuff\n\nint _fltused = 0x9875;\n\n#pragma function(memset)\nvoid *memset(void *DestInit, int Source, size_t Size)\n{\n    unsigned char *Dest = (unsigned char *)DestInit;\n    while(Size--) *Dest++ = (unsigned char)Source;\n\n    return(DestInit);\n}\n\n#pragma function(memcpy)\nvoid *memcpy(void *DestInit, void const *SourceInit, size_t Size)\n{\n    unsigned char *Source = (unsigned char *)SourceInit;\n    unsigned char *Dest = (unsigned char *)DestInit;\n    while(Size--) *Dest++ = *Source++;\n\n    return(DestInit);\n}\n"
        },
        {
          "name": "refterm.h",
          "type": "blob",
          "size": 0.3486328125,
          "content": "#define REFTERM_VERSION 2\n\n#if _DEBUG\n#define Assert(cond) do { if (!(cond)) __debugbreak(); } while (0)\n#else\n#define Assert(cond)\n#endif\n\n#define AssertHR(hr) Assert(SUCCEEDED(hr))\n#define ArrayCount(Array) (sizeof(Array) / sizeof((Array)[0]))\n\n#define IsPowerOfTwo(Value) (((Value) & ((Value) - 1)) == 0)\n#define SafeRatio1(A, B) ((B) ? ((A)/(B)) : (A))\n"
        },
        {
          "name": "refterm.hlsl",
          "type": "blob",
          "size": 2.802734375,
          "content": "struct TerminalCell\n{\n    uint GlyphIndex;\n    uint Foreground;\n    uint Background;\n};\n\ncbuffer ConstBuffer : register(b0)\n{\n    uint2 CellSize;\n    uint2 TermSize;\n    uint2 TopLeftMargin;\n    uint BlinkModulate;\n    uint MarginColor;\n\n    uint StrikeMin;\n    uint StrikeMax;\n    uint UnderlineMin;\n    uint UnderlineMax;\n};\n\nStructuredBuffer<TerminalCell> Cells : register(t0);\nTexture2D<float4> GlyphTexture : register(t1);\n\nfloat3 UnpackColor(uint Packed)\n{\n    int R = Packed & 0xff;\n    int G = (Packed >> 8) & 0xff;\n    int B = (Packed >> 16) & 0xff;\n\n    return float3(R, G, B) / 255.0;\n}\n\nuint2 UnpackGlyphXY(uint GlyphIndex)\n{\n    int x = (GlyphIndex & 0xffff);\n    int y = (GlyphIndex >> 16);\n    return uint2(x, y);\n}\n\nfloat4 ComputeOutputColor(uint2 ScreenPos)\n{\n    uint2 CellIndex = (ScreenPos - TopLeftMargin) / CellSize;\n    uint2 CellPos = (ScreenPos - TopLeftMargin) % CellSize;\n\n    float3 Result;\n    if((ScreenPos.x >= TopLeftMargin.x) &&\n       (ScreenPos.y >= TopLeftMargin.y) &&\n       (CellIndex.x < TermSize.x) &&\n       (CellIndex.y < TermSize.y))\n    {\n        TerminalCell Cell = Cells[CellIndex.y * TermSize.x + CellIndex.x];\n        uint2 GlyphPos = UnpackGlyphXY(Cell.GlyphIndex)*CellSize;\n\n        uint2 PixelPos = GlyphPos + CellPos;\n        float4 GlyphTexel = GlyphTexture[PixelPos];\n\n        float3 Background = UnpackColor(Cell.Background);\n        float3 Foreground = UnpackColor(Cell.Foreground);\n        float3 Blink = UnpackColor(BlinkModulate);\n\n\n        if((Cell.Foreground >> 28) & 1) Foreground *= Blink;\n        if((Cell.Foreground >> 25) & 1) Foreground *= 0.5;\n\n        // TODO: proper ClearType blending\n        Result = (1-GlyphTexel.a)*Background + GlyphTexel.rgb*Foreground;\n\n        if( ((Cell.Foreground >> 27) & 1) &&\n            (CellPos.y >= UnderlineMin) &&\n            (CellPos.y < UnderlineMax)) Result.rgb = Foreground.rgb;\n        if( (Cell.Foreground >> 31) &&\n            (CellPos.y >= StrikeMin) &&\n            (CellPos.y < StrikeMax)) Result.rgb = Foreground.rgb;\n    }\n    else\n    {\n        Result = UnpackColor(MarginColor);\n    }\n\n    // NOTE(casey): Uncomment this to view the cache texture\n    // Result = GlyphTexture[ScreenPos].rgb;\n\n    return float4(Result, 1);\n}\n\n//\n// NOTE(casey): This is the pixel shader version\n//\n\nfloat4 VertexMain(uint vI : SV_VERTEXID):SV_POSITION\n{\n    return float4(2.0*(float(vI&1) - 0.5), -(float(vI>>1) - 0.5)*2.0, 0, 1);\n}\n\nfloat4 PixelMain(float4 ScreenPos:SV_POSITION):SV_TARGET\n{\n    return ComputeOutputColor(ScreenPos.xy);\n}\n\n//\n// NOTE(casey): This is the compute shader version\n//\n\nRWTexture2D<float4> Output : register(u0);\n\n// dispatch with (TermSize*CellSize+7)/8 groups for x,y and 1 for z\n[numthreads(8, 8, 1)]\nvoid ComputeMain(uint3 Id: SV_DispatchThreadID)\n{\n    uint2 ScreenPos = Id.xy;\n    Output[ScreenPos] = ComputeOutputColor(ScreenPos);\n}\n"
        },
        {
          "name": "refterm_cs.h",
          "type": "blob",
          "size": 14.1904296875,
          "content": "#if 0\r\n//\r\n// Generated by Microsoft (R) D3D Shader Disassembler\r\n//\r\n//\r\n// Input signature:\r\n//\r\n// Name                 Index   Mask Register SysValue  Format   Used\r\n// -------------------- ----- ------ -------- -------- ------- ------\r\n// no Input\r\n//\r\n// Output signature:\r\n//\r\n// Name                 Index   Mask Register SysValue  Format   Used\r\n// -------------------- ----- ------ -------- -------- ------- ------\r\n// no Output\r\ncs_5_0\r\ndcl_globalFlags refactoringAllowed\r\ndcl_constantbuffer CB0[3], immediateIndexed\r\ndcl_resource_structured t0, 12\r\ndcl_resource_texture2d (float,float,float,float) t1\r\ndcl_uav_typed_texture2d (float,float,float,float) u0\r\ndcl_input vThreadID.xy\r\ndcl_temps 6\r\ndcl_thread_group 8, 8, 1\r\niadd r0.xy, vThreadID.xyxx, -cb0[1].xyxx\r\nudiv r0.zw, null, r0.xxxy, cb0[0].xxxy\r\nuge r1.xy, vThreadID.xyxx, cb0[1].xyxx\r\nand r1.x, r1.y, r1.x\r\nult r1.yz, r0.zzwz, cb0[0].zzwz\r\nand r1.x, r1.y, r1.x\r\nand r1.x, r1.z, r1.x\r\nif_nz r1.x\r\n  udiv null, r0.xy, r0.xyxx, cb0[0].xyxx\r\n  imad r0.z, r0.w, cb0[0].z, r0.z\r\n  ld_structured_indexable(structured_buffer, stride=12)(mixed,mixed,mixed,mixed) r1.xyz, r0.z, l(0), t0.xyzx\r\n  and r2.xyz, r1.xzyx, l(0x0000ffff, 255, 255, 0)\r\n  ushr r0.zw, r1.xxxy, l(0, 0, 16, 31)\r\n  mov r2.w, r0.z\r\n  imad r3.xy, r2.xwxx, cb0[0].xyxx, r0.xyxx\r\n  mov r3.zw, l(0,0,0,0)\r\n  ld_indexable(texture2d)(float,float,float,float) r3.xyzw, r3.xyzw, t1.xyzw\r\n  ubfe r4.xyzw, l(8, 8, 8, 8), l(8, 16, 8, 16), r1.zzyy\r\n  itof r5.x, r2.y\r\n  itof r5.yz, r4.xxyx\r\n  mul r1.xzw, r5.xxyz, l(0.003922, 0.000000, 0.003922, 0.003922)\r\n  itof r2.x, r2.z\r\n  itof r2.yz, r4.zzwz\r\n  mul r2.xyz, r2.xyzx, l(0.003922, 0.003922, 0.003922, 0.000000)\r\n  and r0.x, cb0[1].z, l(255)\r\n  ubfe r4.xy, l(8, 8, 0, 0), l(8, 16, 0, 0), cb0[1].zzzz\r\n  itof r5.x, r0.x\r\n  itof r5.yz, r4.xxyx\r\n  mul r4.xyz, r2.xyzx, r5.xyzx\r\n  ubfe r5.xyz, l(1, 1, 1, 0), l(28, 25, 27, 0), r1.yyyy\r\n  mul r4.xyz, r4.xyzx, l(0.003922, 0.003922, 0.003922, 0.000000)\r\n  movc r2.xyz, r5.xxxx, r4.xyzx, r2.xyzx\r\n  mul r4.xyz, r2.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000)\r\n  movc r2.xyz, r5.yyyy, r4.xyzx, r2.xyzx\r\n  add r0.x, -r3.w, l(1.000000)\r\n  mul r3.xyz, r2.xyzx, r3.xyzx\r\n  mad r1.xyz, r0.xxxx, r1.xzwx, r3.xyzx\r\n  ine r0.x, r5.z, l(0)\r\n  uge r3.xy, r0.yyyy, cb0[2].zxzz\r\n  and r0.x, r0.x, r3.x\r\n  ult r0.yz, r0.yyyy, cb0[2].wwyw\r\n  and r0.x, r0.y, r0.x\r\n  ine r0.y, r0.w, l(0)\r\n  and r0.y, r3.y, r0.y\r\n  and r0.y, r0.z, r0.y\r\n  or r0.x, r0.y, r0.x\r\n  movc r0.xyz, r0.xxxx, r2.xyzx, r1.xyzx\r\nelse \r\n  and r1.x, cb0[1].w, l(255)\r\n  ubfe r1.yz, l(0, 8, 8, 0), l(0, 8, 16, 0), cb0[1].wwww\r\n  itof r2.xyz, r1.xyzx\r\n  mul r0.xyz, r2.xyzx, l(0.003922, 0.003922, 0.003922, 0.000000)\r\nendif \r\nmov r0.w, l(1.000000)\r\nstore_uav_typed u0.xyzw, vThreadID.xyyy, r0.xyzw\r\nret \r\n// Approximately 0 instruction slots used\r\n#endif\r\n\r\nconst BYTE ReftermCSShaderBytes[] =\r\n{\r\n     68,  88,  66,  67, 190, 252, \r\n      5, 194, 210,  57, 221, 140, \r\n     14, 251, 167, 144, 241, 177, \r\n    127,  71,   1,   0,   0,   0, \r\n    152,   7,   0,   0,   3,   0, \r\n      0,   0,  44,   0,   0,   0, \r\n     60,   0,   0,   0,  76,   0, \r\n      0,   0,  73,  83,  71,  78, \r\n      8,   0,   0,   0,   0,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n     79,  83,  71,  78,   8,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      8,   0,   0,   0,  83,  72, \r\n     69,  88,  68,   7,   0,   0, \r\n     80,   0,   5,   0, 209,   1, \r\n      0,   0, 106,   8,   0,   1, \r\n     89,   0,   0,   4,  70, 142, \r\n     32,   0,   0,   0,   0,   0, \r\n      3,   0,   0,   0, 162,   0, \r\n      0,   4,   0, 112,  16,   0, \r\n      0,   0,   0,   0,  12,   0, \r\n      0,   0,  88,  24,   0,   4, \r\n      0, 112,  16,   0,   1,   0, \r\n      0,   0,  85,  85,   0,   0, \r\n    156,  24,   0,   4,   0, 224, \r\n     17,   0,   0,   0,   0,   0, \r\n     85,  85,   0,   0,  95,   0, \r\n      0,   2,  50,   0,   2,   0, \r\n    104,   0,   0,   2,   6,   0, \r\n      0,   0, 155,   0,   0,   4, \r\n      8,   0,   0,   0,   8,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n     30,   0,   0,   8,  50,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     70,   0,   2,   0,  70, 128, \r\n     32, 128,  65,   0,   0,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0,  78,   0,   0,   9, \r\n    194,   0,  16,   0,   0,   0, \r\n      0,   0,   0, 208,   0,   0, \r\n      6,   4,  16,   0,   0,   0, \r\n      0,   0,   6, 132,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,  80,   0,   0,   7, \r\n     50,   0,  16,   0,   1,   0, \r\n      0,   0,  70,   0,   2,   0, \r\n     70, 128,  32,   0,   0,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n      1,   0,   0,   7,  18,   0, \r\n     16,   0,   1,   0,   0,   0, \r\n     26,   0,  16,   0,   1,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      1,   0,   0,   0,  79,   0, \r\n      0,   8,  98,   0,  16,   0, \r\n      1,   0,   0,   0, 166,  11, \r\n     16,   0,   0,   0,   0,   0, \r\n    166, 139,  32,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   7,  18,   0, \r\n     16,   0,   1,   0,   0,   0, \r\n     26,   0,  16,   0,   1,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      1,   0,   0,   0,   1,   0, \r\n      0,   7,  18,   0,  16,   0, \r\n      1,   0,   0,   0,  42,   0, \r\n     16,   0,   1,   0,   0,   0, \r\n     10,   0,  16,   0,   1,   0, \r\n      0,   0,  31,   0,   4,   3, \r\n     10,   0,  16,   0,   1,   0, \r\n      0,   0,  78,   0,   0,   9, \r\n      0, 208,   0,   0,  50,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     70,   0,  16,   0,   0,   0, \r\n      0,   0,  70, 128,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,  35,   0,   0,  10, \r\n     66,   0,  16,   0,   0,   0, \r\n      0,   0,  58,   0,  16,   0, \r\n      0,   0,   0,   0,  42, 128, \r\n     32,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,  42,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n    167,   0,   0, 139,   2,  99, \r\n      0, 128, 131, 153,  25,   0, \r\n    114,   0,  16,   0,   1,   0, \r\n      0,   0,  42,   0,  16,   0, \r\n      0,   0,   0,   0,   1,  64, \r\n      0,   0,   0,   0,   0,   0, \r\n     70, 114,  16,   0,   0,   0, \r\n      0,   0,   1,   0,   0,  10, \r\n    114,   0,  16,   0,   2,   0, \r\n      0,   0, 134,   1,  16,   0, \r\n      1,   0,   0,   0,   2,  64, \r\n      0,   0, 255, 255,   0,   0, \r\n    255,   0,   0,   0, 255,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     85,   0,   0,  10, 194,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      6,   4,  16,   0,   1,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,  16,   0,   0,   0, \r\n     31,   0,   0,   0,  54,   0, \r\n      0,   5, 130,   0,  16,   0, \r\n      2,   0,   0,   0,  42,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     35,   0,   0,  10,  50,   0, \r\n     16,   0,   3,   0,   0,   0, \r\n    198,   0,  16,   0,   2,   0, \r\n      0,   0,  70, 128,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,  70,   0,  16,   0, \r\n      0,   0,   0,   0,  54,   0, \r\n      0,   8, 194,   0,  16,   0, \r\n      3,   0,   0,   0,   2,  64, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     45,   0,   0, 137, 194,   0, \r\n      0, 128,  67,  85,  21,   0, \r\n    242,   0,  16,   0,   3,   0, \r\n      0,   0,  70,  14,  16,   0, \r\n      3,   0,   0,   0,  70, 126, \r\n     16,   0,   1,   0,   0,   0, \r\n    138,   0,   0,  15, 242,   0, \r\n     16,   0,   4,   0,   0,   0, \r\n      2,  64,   0,   0,   8,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n      8,   0,   0,   0,   8,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n      8,   0,   0,   0,  16,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n     16,   0,   0,   0, 166,   5, \r\n     16,   0,   1,   0,   0,   0, \r\n     43,   0,   0,   5,  18,   0, \r\n     16,   0,   5,   0,   0,   0, \r\n     26,   0,  16,   0,   2,   0, \r\n      0,   0,  43,   0,   0,   5, \r\n     98,   0,  16,   0,   5,   0, \r\n      0,   0,   6,   1,  16,   0, \r\n      4,   0,   0,   0,  56,   0, \r\n      0,  10, 210,   0,  16,   0, \r\n      1,   0,   0,   0,   6,   9, \r\n     16,   0,   5,   0,   0,   0, \r\n      2,  64,   0,   0, 129, 128, \r\n    128,  59,   0,   0,   0,   0, \r\n    129, 128, 128,  59, 129, 128, \r\n    128,  59,  43,   0,   0,   5, \r\n     18,   0,  16,   0,   2,   0, \r\n      0,   0,  42,   0,  16,   0, \r\n      2,   0,   0,   0,  43,   0, \r\n      0,   5,  98,   0,  16,   0, \r\n      2,   0,   0,   0, 166,  11, \r\n     16,   0,   4,   0,   0,   0, \r\n     56,   0,   0,  10, 114,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n     70,   2,  16,   0,   2,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n    129, 128, 128,  59, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   8,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  42, 128, \r\n     32,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   0,   1,  64, \r\n      0,   0, 255,   0,   0,   0, \r\n    138,   0,   0,  16,  50,   0, \r\n     16,   0,   4,   0,   0,   0, \r\n      2,  64,   0,   0,   8,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n      8,   0,   0,   0,  16,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0, 166, 138, \r\n     32,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   0,  43,   0, \r\n      0,   5,  18,   0,  16,   0, \r\n      5,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     43,   0,   0,   5,  98,   0, \r\n     16,   0,   5,   0,   0,   0, \r\n      6,   1,  16,   0,   4,   0, \r\n      0,   0,  56,   0,   0,   7, \r\n    114,   0,  16,   0,   4,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      2,   0,   0,   0,  70,   2, \r\n     16,   0,   5,   0,   0,   0, \r\n    138,   0,   0,  15, 114,   0, \r\n     16,   0,   5,   0,   0,   0, \r\n      2,  64,   0,   0,   1,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n      1,   0,   0,   0,   0,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n     28,   0,   0,   0,  25,   0, \r\n      0,   0,  27,   0,   0,   0, \r\n      0,   0,   0,   0,  86,   5, \r\n     16,   0,   1,   0,   0,   0, \r\n     56,   0,   0,  10, 114,   0, \r\n     16,   0,   4,   0,   0,   0, \r\n     70,   2,  16,   0,   4,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n    129, 128, 128,  59, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n      0,   0,   0,   0,  55,   0, \r\n      0,   9, 114,   0,  16,   0, \r\n      2,   0,   0,   0,   6,   0, \r\n     16,   0,   5,   0,   0,   0, \r\n     70,   2,  16,   0,   4,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      2,   0,   0,   0,  56,   0, \r\n      0,  10, 114,   0,  16,   0, \r\n      4,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n      2,  64,   0,   0,   0,   0, \r\n      0,  63,   0,   0,   0,  63, \r\n      0,   0,   0,  63,   0,   0, \r\n      0,   0,  55,   0,   0,   9, \r\n    114,   0,  16,   0,   2,   0, \r\n      0,   0,  86,   5,  16,   0, \r\n      5,   0,   0,   0,  70,   2, \r\n     16,   0,   4,   0,   0,   0, \r\n     70,   2,  16,   0,   2,   0, \r\n      0,   0,   0,   0,   0,   8, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  58,   0,  16, 128, \r\n     65,   0,   0,   0,   3,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      0,   0, 128,  63,  56,   0, \r\n      0,   7, 114,   0,  16,   0, \r\n      3,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n     70,   2,  16,   0,   3,   0, \r\n      0,   0,  50,   0,   0,   9, \r\n    114,   0,  16,   0,   1,   0, \r\n      0,   0,   6,   0,  16,   0, \r\n      0,   0,   0,   0, 134,   3, \r\n     16,   0,   1,   0,   0,   0, \r\n     70,   2,  16,   0,   3,   0, \r\n      0,   0,  39,   0,   0,   7, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  42,   0,  16,   0, \r\n      5,   0,   0,   0,   1,  64, \r\n      0,   0,   0,   0,   0,   0, \r\n     80,   0,   0,   8,  50,   0, \r\n     16,   0,   3,   0,   0,   0, \r\n     86,   5,  16,   0,   0,   0, \r\n      0,   0,  38, 138,  32,   0, \r\n      0,   0,   0,   0,   2,   0, \r\n      0,   0,   1,   0,   0,   7, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   3,   0,   0,   0, \r\n     79,   0,   0,   8,  98,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     86,   5,  16,   0,   0,   0, \r\n      0,   0, 246, 141,  32,   0, \r\n      0,   0,   0,   0,   2,   0, \r\n      0,   0,   1,   0,   0,   7, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  26,   0,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     39,   0,   0,   7,  34,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     58,   0,  16,   0,   0,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   7,  34,   0,  16,   0, \r\n      0,   0,   0,   0,  26,   0, \r\n     16,   0,   3,   0,   0,   0, \r\n     26,   0,  16,   0,   0,   0, \r\n      0,   0,   1,   0,   0,   7, \r\n     34,   0,  16,   0,   0,   0, \r\n      0,   0,  42,   0,  16,   0, \r\n      0,   0,   0,   0,  26,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     60,   0,   0,   7,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     26,   0,  16,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      0,   0,   0,   0,  55,   0, \r\n      0,   9, 114,   0,  16,   0, \r\n      0,   0,   0,   0,   6,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     70,   2,  16,   0,   2,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      1,   0,   0,   0,  18,   0, \r\n      0,   1,   1,   0,   0,   8, \r\n     18,   0,  16,   0,   1,   0, \r\n      0,   0,  58, 128,  32,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n    255,   0,   0,   0, 138,   0, \r\n      0,  16,  98,   0,  16,   0, \r\n      1,   0,   0,   0,   2,  64, \r\n      0,   0,   0,   0,   0,   0, \r\n      8,   0,   0,   0,   8,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      2,  64,   0,   0,   0,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      0,   0, 246, 143,  32,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0,  43,   0,   0,   5, \r\n    114,   0,  16,   0,   2,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      1,   0,   0,   0,  56,   0, \r\n      0,  10, 114,   0,  16,   0, \r\n      0,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n      2,  64,   0,   0, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n    129, 128, 128,  59,   0,   0, \r\n      0,   0,  21,   0,   0,   1, \r\n     54,   0,   0,   5, 130,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,  64,   0,   0,   0,   0, \r\n    128,  63, 164,   0,   0,   6, \r\n    242, 224,  17,   0,   0,   0, \r\n      0,   0,  70,   5,   2,   0, \r\n     70,  14,  16,   0,   0,   0, \r\n      0,   0,  62,   0,   0,   1\r\n};\r\n"
        },
        {
          "name": "refterm_example_d3d11.c",
          "type": "blob",
          "size": 17.4970703125,
          "content": "// TODO(casey): These are lightly adapted from Martins' original sketch, which he\n// did in like an hour.  I don't have much D3D11 knowledge so someone who does\n// have some should go through this and give advice about if there are any things\n// that should be done differently in production code.\n\n#pragma comment (lib, \"d3d11.lib\")\n#pragma comment (lib, \"dxguid.lib\")\n\nstatic int D3D11RendererIsValid(d3d11_renderer *Renderer)\n{\n    int Result = (Renderer->Device &&\n                  Renderer->SwapChain &&\n                  Renderer->ComputeShader &&\n                  Renderer->ConstantBuffer &&\n                  Renderer->CellView &&\n                  Renderer->GlyphTextureView);\n\n    return Result;\n}\n\nstatic void ActivateD3D11DebugInfo(ID3D11Device *Device)\n{\n    ID3D11InfoQueue *Info;\n    if(SUCCEEDED(IProvideClassInfo_QueryInterface(Device, &IID_ID3D11InfoQueue, (void**)&Info)))\n    {\n        ID3D11InfoQueue_SetBreakOnSeverity(Info, D3D11_MESSAGE_SEVERITY_CORRUPTION, TRUE);\n        ID3D11InfoQueue_SetBreakOnSeverity(Info, D3D11_MESSAGE_SEVERITY_ERROR, TRUE);\n\n        ID3D11InfoQueue_Release(Info);\n    }\n}\n\nstatic IDXGIFactory2 *AcquireDXGIFactory(ID3D11Device *Device)\n{\n    IDXGIFactory2 *Result = 0;\n\n    if(Device)\n    {\n        IDXGIDevice *DxgiDevice = 0;\n        if(SUCCEEDED(ID3D11Device_QueryInterface(Device, &IID_IDXGIDevice, (void **)&DxgiDevice)))\n        {\n            IDXGIAdapter *DxgiAdapter = 0;\n            if(SUCCEEDED(IDXGIDevice_GetAdapter(DxgiDevice, &DxgiAdapter)))\n            {\n                IDXGIAdapter_GetParent(DxgiAdapter, &IID_IDXGIFactory2, (void**)&Result);\n\n                IDXGIAdapter_Release(DxgiAdapter);\n            }\n\n            IDXGIDevice_Release(DxgiDevice);\n        }\n    }\n\n    return Result;\n}\n\nstatic IDXGISwapChain2 *AcquireDXGISwapChain(ID3D11Device *Device, HWND Window, int UseComputeShader)\n{\n    IDXGISwapChain2 *Result = 0;\n\n    if(Device)\n    {\n        IDXGIFactory2 *DxgiFactory = AcquireDXGIFactory(Device);\n        if(DxgiFactory)\n        {\n            DXGI_SWAP_CHAIN_DESC1 SwapChainDesc =\n            {\n                .Format = DXGI_FORMAT_B8G8R8A8_UNORM,\n                .SampleDesc = {1, 0},\n                .BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT,\n                .BufferCount = 2,\n                .SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD,\n                .Scaling = DXGI_SCALING_NONE,\n                .AlphaMode = DXGI_ALPHA_MODE_IGNORE,\n                .Flags = DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT,\n            };\n\n            if(UseComputeShader)\n            {\n                SwapChainDesc.BufferUsage |= DXGI_USAGE_UNORDERED_ACCESS;\n            }\n\n            IDXGISwapChain1 *SwapChain1 = 0;\n            if(SUCCEEDED(IDXGIFactory2_CreateSwapChainForHwnd(DxgiFactory, (IUnknown*)Device, Window, &SwapChainDesc, NULL, NULL, &SwapChain1)))\n            {\n                if(SUCCEEDED(IDXGISwapChain1_QueryInterface(SwapChain1, &IID_IDXGISwapChain2, (void **)&Result)))\n                {\n                    IDXGIFactory2_MakeWindowAssociation(DxgiFactory, Window, DXGI_MWA_NO_ALT_ENTER | DXGI_MWA_NO_WINDOW_CHANGES);\n                }\n\n                IDXGISwapChain1_Release(SwapChain1);\n            }\n\n            IDXGIFactory2_Release(DxgiFactory);\n        }\n    }\n\n    return Result;\n}\n\nstatic void ReleaseD3DCellBuffer(d3d11_renderer *Renderer)\n{\n    if(Renderer->CellBuffer)\n    {\n        ID3D11Buffer_Release(Renderer->CellBuffer);\n        Renderer->CellBuffer = 0;\n    }\n\n    if(Renderer->CellView)\n    {\n        ID3D11ShaderResourceView_Release(Renderer->CellView);\n        Renderer->CellView = 0;\n    }\n}\n\nstatic void SetD3D11MaxCellCount(d3d11_renderer *Renderer, uint32_t Count)\n{\n    ReleaseD3DCellBuffer(Renderer);\n\n    if(Renderer->Device)\n    {\n        D3D11_BUFFER_DESC CellBufferDesc =\n        {\n            .ByteWidth = Count * sizeof(renderer_cell),\n            .Usage = D3D11_USAGE_DYNAMIC,\n            .BindFlags = D3D11_BIND_SHADER_RESOURCE,\n            .CPUAccessFlags = D3D11_CPU_ACCESS_WRITE,\n            .MiscFlags = D3D11_RESOURCE_MISC_BUFFER_STRUCTURED,\n            .StructureByteStride = sizeof(renderer_cell),\n        };\n\n        if(SUCCEEDED(ID3D11Device_CreateBuffer(Renderer->Device, &CellBufferDesc, 0, &Renderer->CellBuffer)))\n        {\n            D3D11_SHADER_RESOURCE_VIEW_DESC CellViewDesc =\n            {\n                .ViewDimension = D3D11_SRV_DIMENSION_BUFFER,\n                .Buffer.FirstElement = 0,\n                .Buffer.NumElements = Count,\n            };\n\n            ID3D11Device_CreateShaderResourceView(Renderer->Device, (ID3D11Resource *)Renderer->CellBuffer, &CellViewDesc, &Renderer->CellView);\n        }\n        \n        Renderer->MaxCellCount = Count;\n    }\n}\n\nstatic void ReleaseD3DGlyphCache(d3d11_renderer *Renderer)\n{\n    if(Renderer->GlyphTexture)\n    {\n        ID3D11ShaderResourceView_Release(Renderer->GlyphTexture);\n        Renderer->GlyphTexture = 0;\n    }\n\n    if(Renderer->GlyphTextureView)\n    {\n        ID3D11ShaderResourceView_Release(Renderer->GlyphTextureView);\n        Renderer->GlyphTextureView = 0;\n    }\n}\n\nstatic void ReleaseD3DGlyphTransfer(d3d11_renderer *Renderer)\n{\n    D2DRelease(&Renderer->DWriteRenderTarget, &Renderer->DWriteFillBrush);\n\n    if(Renderer->GlyphTransfer)\n    {\n        ID3D11ShaderResourceView_Release(Renderer->GlyphTransfer);\n        Renderer->GlyphTransfer = 0;\n    }\n\n    if(Renderer->GlyphTransferView)\n    {\n        ID3D11ShaderResourceView_Release(Renderer->GlyphTransferView);\n        Renderer->GlyphTransferView = 0;\n    }\n\n    if(Renderer->GlyphTransferSurface)\n    {\n        IDXGISurface_Release(Renderer->GlyphTransferSurface);\n        Renderer->GlyphTransferSurface = 0;\n    }\n}\n\nstatic void SetD3D11GlyphCacheDim(d3d11_renderer *Renderer, uint32_t Width, uint32_t Height)\n{\n    ReleaseD3DGlyphCache(Renderer);\n\n    if(Renderer->Device)\n    {\n        D3D11_TEXTURE2D_DESC TextureDesc =\n        {\n            .Width = Width,\n            .Height = Height,\n            .MipLevels = 1,\n            .ArraySize = 1,\n            .Format = DXGI_FORMAT_B8G8R8A8_UNORM,\n            .SampleDesc = { 1, 0 },\n            .Usage = D3D11_USAGE_DEFAULT,\n            .BindFlags = D3D11_BIND_SHADER_RESOURCE,\n        };\n\n        if(SUCCEEDED(ID3D11Device_CreateTexture2D(Renderer->Device, &TextureDesc, NULL, &Renderer->GlyphTexture)))\n        {\n            ID3D11Device_CreateShaderResourceView(Renderer->Device, (ID3D11Resource*)Renderer->GlyphTexture, NULL, &Renderer->GlyphTextureView);\n        }\n    }\n}\n\nstatic void SetD3D11GlyphTransferDim(d3d11_renderer *Renderer, uint32_t Width, uint32_t Height)\n{\n    ReleaseD3DGlyphTransfer(Renderer);\n\n    if(Renderer->Device)\n    {\n        D3D11_TEXTURE2D_DESC TextureDesc =\n        {\n            .Width = Width,\n            .Height = Height,\n            .MipLevels = 1,\n            .ArraySize = 1,\n            .Format = DXGI_FORMAT_B8G8R8A8_UNORM,\n            .SampleDesc = { 1, 0 },\n            .Usage = D3D11_USAGE_DEFAULT,\n            .BindFlags = D3D11_BIND_SHADER_RESOURCE|D3D11_BIND_RENDER_TARGET,\n        };\n\n        if(SUCCEEDED(ID3D11Device_CreateTexture2D(Renderer->Device, &TextureDesc, 0, &Renderer->GlyphTransfer)))\n        {\n            ID3D11Device_CreateShaderResourceView(Renderer->Device, (ID3D11Resource *)Renderer->GlyphTransfer, 0, &Renderer->GlyphTransferView);\n            ID3D11Texture2D_QueryInterface(Renderer->GlyphTransfer, &IID_IDXGISurface, (void **)&Renderer->GlyphTransferSurface);\n\n            D2DAcquire(Renderer->GlyphTransferSurface,\n                       &Renderer->DWriteRenderTarget,\n                       &Renderer->DWriteFillBrush);\n        }\n    }\n}\n\nstatic void ReleaseD3D11RenderTargets(d3d11_renderer *Renderer)\n{\n    if (Renderer->RenderView)\n    {\n        ID3D11UnorderedAccessView_Release(Renderer->RenderView);\n        Renderer->RenderView = 0;\n    }\n\n    if (Renderer->RenderTarget)\n    {\n        ID3D11RenderTargetView_Release(Renderer->RenderTarget);\n        Renderer->RenderTarget = 0;\n    }\n}\n\nstatic void ReleaseD3D11Renderer(d3d11_renderer *Renderer)\n{\n    // TODO(casey): When you want to release a D3D11 device, do you have to release all the sub-components?\n    // Can you just release the main device and have all the sub-components release themselves?\n\n    ReleaseD3DCellBuffer(Renderer);\n    ReleaseD3DGlyphCache(Renderer);\n    ReleaseD3DGlyphTransfer(Renderer);\n    ReleaseD3D11RenderTargets(Renderer);\n\n    if(Renderer->ComputeShader) ID3D11ComputeShader_Release(Renderer->ComputeShader);\n    if(Renderer->PixelShader) ID3D11ComputeShader_Release(Renderer->PixelShader);\n    if(Renderer->VertexShader) ID3D11ComputeShader_Release(Renderer->VertexShader);\n\n    if(Renderer->ConstantBuffer) ID3D11Buffer_Release(Renderer->ConstantBuffer);\n\n    if(Renderer->RenderView) ID3D11UnorderedAccessView_Release(Renderer->RenderView);\n    if(Renderer->SwapChain) IDXGISwapChain2_Release(Renderer->SwapChain);\n\n    if(Renderer->DeviceContext) ID3D11DeviceContext_Release(Renderer->DeviceContext);\n    if(Renderer->DeviceContext1) ID3D11DeviceContext1_Release(Renderer->DeviceContext1);\n    if(Renderer->Device) ID3D11Device_Release(Renderer->Device);\n\n    d3d11_renderer ZeroRenderer = {0};\n    *Renderer = ZeroRenderer;\n}\n\nstatic d3d11_renderer AcquireD3D11Renderer(HWND Window, int EnableDebugging)\n{\n    d3d11_renderer Result = {0};\n\n    UINT Flags = D3D11_CREATE_DEVICE_BGRA_SUPPORT | D3D11_CREATE_DEVICE_SINGLETHREADED;\n    if(EnableDebugging)\n    {\n        Flags |= D3D11_CREATE_DEVICE_DEBUG;\n    }\n\n    D3D_FEATURE_LEVEL Levels[] = {D3D_FEATURE_LEVEL_11_0};\n    HRESULT hr = D3D11CreateDevice(0, D3D_DRIVER_TYPE_HARDWARE, 0, Flags, Levels, ARRAYSIZE(Levels), D3D11_SDK_VERSION,\n                                   &Result.Device, 0, &Result.DeviceContext);\n    if(FAILED(hr))\n    {\n        hr = D3D11CreateDevice(0, D3D_DRIVER_TYPE_WARP, 0, Flags, Levels, ARRAYSIZE(Levels), D3D11_SDK_VERSION,\n                               &Result.Device, 0, &Result.DeviceContext);\n    }\n\n    if(SUCCEEDED(hr))\n    {\n        if(SUCCEEDED(ID3D11DeviceContext1_QueryInterface(Result.DeviceContext, &IID_ID3D11DeviceContext1, (void **)&Result.DeviceContext1)))\n        {\n            if(EnableDebugging)\n            {\n                ActivateD3D11DebugInfo(Result.Device);\n            }\n\n            Result.SwapChain = AcquireDXGISwapChain(Result.Device, Window, 0);\n            if(Result.SwapChain)\n            {\n                Result.FrameLatencyWaitableObject = IDXGISwapChain2_GetFrameLatencyWaitableObject(Result.SwapChain);\n\n                D3D11_BUFFER_DESC ConstantBufferDesc =\n                {\n                    .ByteWidth = sizeof(renderer_const_buffer),\n                    .Usage = D3D11_USAGE_DYNAMIC,\n                    .BindFlags = D3D11_BIND_CONSTANT_BUFFER,\n                    .CPUAccessFlags = D3D11_CPU_ACCESS_WRITE,\n                };\n                ID3D11Device_CreateBuffer(Result.Device, &ConstantBufferDesc, 0, &Result.ConstantBuffer);\n\n                ID3D11Device_CreateComputeShader(Result.Device, ReftermCSShaderBytes, sizeof(ReftermCSShaderBytes), 0, &Result.ComputeShader);\n                ID3D11Device_CreatePixelShader(Result.Device, ReftermPSShaderBytes, sizeof(ReftermPSShaderBytes), 0, &Result.PixelShader);\n                ID3D11Device_CreateVertexShader(Result.Device, ReftermVSShaderBytes, sizeof(ReftermVSShaderBytes), 0, &Result.VertexShader);\n            }\n        }\n    }\n\n    if(!Result.SwapChain)\n    {\n        ReleaseD3D11Renderer(&Result);\n    }\n\n    return Result;\n}\n\nstatic void RendererDraw(example_terminal *Terminal, uint32_t Width, uint32_t Height, terminal_buffer *Term, uint32_t BlinkModulate)\n{\n    // TODO(casey): This should be split into two routines now, since we don't actually\n    // need to resubmit anything if the terminal hasn't updated.\n\n    glyph_table *Table = Terminal->GlyphTable;\n    d3d11_renderer *Renderer = &Terminal->Renderer;\n    glyph_generator *GlyphGen = &Terminal->GlyphGen;\n    source_buffer *Source = &Terminal->ScrollBackBuffer;\n\n    HRESULT hr;\n\n    // resize RenderView to match window size\n    if(Width != Renderer->CurrentWidth || Height != Renderer->CurrentHeight)\n    {\n        ID3D11DeviceContext_ClearState(Renderer->DeviceContext);\n        ReleaseD3D11RenderTargets(Renderer);\n        ID3D11DeviceContext_Flush(Renderer->DeviceContext);\n\n        if (Width != 0 && Height != 0)\n        {\n            hr = IDXGISwapChain_ResizeBuffers(Renderer->SwapChain, 0, Width, Height, DXGI_FORMAT_UNKNOWN, DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT);\n            AssertHR(hr);\n\n            ID3D11Texture2D *Buffer;\n            hr = IDXGISwapChain_GetBuffer(Renderer->SwapChain, 0, &IID_ID3D11Texture2D, (void**)&Buffer);\n            AssertHR(hr);\n\n            if(Renderer->UseComputeShader)\n            {\n                hr = ID3D11Device_CreateUnorderedAccessView(Renderer->Device, (ID3D11Resource*)Buffer, 0, &Renderer->RenderView);\n                AssertHR(hr);\n            }\n            else\n            {\n                hr = ID3D11Device_CreateRenderTargetView(Renderer->Device, (ID3D11Resource*)Buffer, 0, &Renderer->RenderTarget);\n                AssertHR(hr);\n\n                D3D11_VIEWPORT Viewport =\n                {\n                    .TopLeftX = 0.0f,\n                    .TopLeftY = 0.0f,\n                    .Width = (float)Width,\n                    .Height = (float)Height,\n                };\n                ID3D11DeviceContext_RSSetViewports(Renderer->DeviceContext, 1, &Viewport);\n                ID3D11DeviceContext_IASetPrimitiveTopology(Renderer->DeviceContext, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);\n            }\n\n            ID3D11Texture2D_Release(Buffer);\n        }\n\n        Renderer->CurrentWidth = Width;\n        Renderer->CurrentHeight = Height;\n    }\n\n    uint32_t CellCount = Term->DimX*Term->DimY;\n    if(Renderer->MaxCellCount < CellCount)\n    {\n        SetD3D11MaxCellCount(Renderer, CellCount);\n    }\n        \n    if(Renderer->RenderView || Renderer->RenderTarget)\n    {\n        D3D11_MAPPED_SUBRESOURCE Mapped;\n        hr = ID3D11DeviceContext_Map(Renderer->DeviceContext, (ID3D11Resource*)Renderer->ConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &Mapped);\n        AssertHR(hr);\n        {\n            renderer_const_buffer ConstData =\n            {\n                .CellSize = { GlyphGen->FontWidth, GlyphGen->FontHeight },\n                .TermSize = { Term->DimX, Term->DimY },\n                .TopLeftMargin = {8, 8},\n                .BlinkModulate = BlinkModulate,\n                .MarginColor = 0x000c0c0c,\n                \n                .StrikeMin = GlyphGen->FontHeight/2 - GlyphGen->FontHeight/10,\n                .StrikeMax = GlyphGen->FontHeight/2 + GlyphGen->FontHeight/10,\n                .UnderlineMin = GlyphGen->FontHeight - GlyphGen->FontHeight/5,\n                .UnderlineMax = GlyphGen->FontHeight,\n            };\n            memcpy(Mapped.pData, &ConstData, sizeof(ConstData));\n        }\n        ID3D11DeviceContext_Unmap(Renderer->DeviceContext, (ID3D11Resource*)Renderer->ConstantBuffer, 0);\n\n        hr = ID3D11DeviceContext_Map(Renderer->DeviceContext, (ID3D11Resource*)Renderer->CellBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &Mapped);\n        AssertHR(hr);\n        {\n            renderer_cell *Cells = Mapped.pData;\n\n            uint32_t TopCellCount = Term->DimX * (Term->DimY - Term->FirstLineY);\n            uint32_t BotCellCount = Term->DimX * (Term->FirstLineY);\n            Assert((TopCellCount + BotCellCount) == (Term->DimX * Term->DimY));\n            memcpy(Cells, Term->Cells + Term->FirstLineY*Term->DimX, TopCellCount*sizeof(renderer_cell));\n            memcpy(Cells + TopCellCount, Term->Cells, BotCellCount*sizeof(renderer_cell));\n        }\n        ID3D11DeviceContext_Unmap(Renderer->DeviceContext, (ID3D11Resource*)Renderer->CellBuffer, 0);\n\n        // this should match t0/t1 order in hlsl shader\n        ID3D11ShaderResourceView* Resources[] = { Renderer->CellView, Renderer->GlyphTextureView };\n\n        if(Renderer->UseComputeShader)\n        {\n            // this issues compute shader for window size, which in real terminal should match its size\n            ID3D11DeviceContext_CSSetConstantBuffers(Renderer->DeviceContext, 0, 1, &Renderer->ConstantBuffer);\n            ID3D11DeviceContext_CSSetShaderResources(Renderer->DeviceContext, 0, ARRAYSIZE(Resources), Resources);\n            ID3D11DeviceContext_CSSetUnorderedAccessViews(Renderer->DeviceContext, 0, 1, &Renderer->RenderView, NULL);\n            ID3D11DeviceContext_CSSetShader(Renderer->DeviceContext, Renderer->ComputeShader, 0, 0);\n            ID3D11DeviceContext_Dispatch(Renderer->DeviceContext, (Renderer->CurrentWidth + 7) / 8, (Renderer->CurrentHeight + 7) / 8, 1);\n        }\n        else\n        {\n            // NOTE(casey): This MUST be set every frame, because PAGE FLIPPING, I guess :/\n            ID3D11DeviceContext_OMSetRenderTargets(Renderer->DeviceContext, 1, &Renderer->RenderTarget, 0);\n\n            ID3D11DeviceContext_PSSetConstantBuffers(Renderer->DeviceContext, 0, 1, &Renderer->ConstantBuffer);\n            ID3D11DeviceContext_PSSetShaderResources(Renderer->DeviceContext, 0, ARRAYSIZE(Resources), Resources);\n            ID3D11DeviceContext_VSSetShader(Renderer->DeviceContext, Renderer->VertexShader, 0, 0);\n            ID3D11DeviceContext_PSSetShader(Renderer->DeviceContext, Renderer->PixelShader, 0, 0);\n            ID3D11DeviceContext_Draw(Renderer->DeviceContext, 4, 0);\n        }\n    }\n\n    BOOL Vsync = FALSE;\n    hr = IDXGISwapChain1_Present(Renderer->SwapChain, Vsync ? 1 : 0, 0);\n    if((hr == DXGI_ERROR_DEVICE_RESET) || (hr == DXGI_ERROR_DEVICE_REMOVED))\n    {\n        Assert(!\"Device lost!\");\n        ReleaseD3D11Renderer(Renderer);\n    }\n    else\n    {\n        AssertHR(hr);\n    }\n\n    if(Renderer->RenderView)\n    {\n        ID3D11DeviceContext1_DiscardView(Renderer->DeviceContext1, (ID3D11View*)Renderer->RenderView);\n    }\n}\n"
        },
        {
          "name": "refterm_example_d3d11.h",
          "type": "blob",
          "size": 1.6982421875,
          "content": "typedef struct\n{\n    uint32_t CellSize[2];\n    uint32_t TermSize[2];\n    uint32_t TopLeftMargin[2];\n    uint32_t BlinkModulate;\n    uint32_t MarginColor;\n    uint32_t StrikeMin;\n    uint32_t StrikeMax;\n    uint32_t UnderlineMin;\n    uint32_t UnderlineMax;\n} renderer_const_buffer;\n\n#define RENDERER_CELL_BLINK 0x80000000\ntypedef struct\n{\n    uint32_t GlyphIndex;\n    uint32_t Foreground;\n    uint32_t Background; // NOTE(casey): The top bit of the background flag indicates blinking\n} renderer_cell;\n\ntypedef struct\n{\n    ID3D11Device *Device;\n    ID3D11DeviceContext *DeviceContext;\n    ID3D11DeviceContext1 *DeviceContext1;\n\n    IDXGISwapChain2 *SwapChain;\n    HANDLE FrameLatencyWaitableObject;\n\n    ID3D11ComputeShader *ComputeShader;\n    ID3D11PixelShader *PixelShader;\n    ID3D11VertexShader *VertexShader;\n\n    ID3D11Buffer *ConstantBuffer;\n    ID3D11RenderTargetView *RenderTarget;\n    ID3D11UnorderedAccessView *RenderView;\n\n    ID3D11Buffer *CellBuffer;\n    ID3D11ShaderResourceView *CellView;\n\n    ID3D11Texture2D *GlyphTexture;\n    ID3D11ShaderResourceView *GlyphTextureView;\n\n    ID3D11Texture2D *GlyphTransfer;\n    ID3D11ShaderResourceView *GlyphTransferView;\n    IDXGISurface *GlyphTransferSurface;\n\n    // NOTE(casey): These are for DirectWrite\n    struct ID2D1RenderTarget *DWriteRenderTarget;\n    struct ID2D1SolidColorBrush *DWriteFillBrush;\n\n    uint32_t CurrentWidth;\n    uint32_t CurrentHeight;\n    uint32_t MaxCellCount;\n\n    int UseComputeShader;\n} d3d11_renderer;\n\nstatic d3d11_renderer AcquireD3D11Renderer(HWND Window, int EnableDebugging);\n\nstatic void SetD3D11MaxCellCount(d3d11_renderer *Renderer, uint32_t Count);\nstatic void SetD3D11GlyphCacheDim(d3d11_renderer *Renderer, uint32_t Width, uint32_t Height);\n"
        },
        {
          "name": "refterm_example_dwrite.cpp",
          "type": "blob",
          "size": 6.9228515625,
          "content": "#include <dwrite.h>\n#include <d2d1.h>\n#include <stddef.h>\n#include <stdint.h>\n\nextern \"C\"\n{\n#include \"refterm.h\"\n#include \"refterm_example_glyph_generator.h\"\n}\n\nextern \"C\" int D2DAcquire(IDXGISurface *GlyphTransferSurface,\n                          struct ID2D1RenderTarget **DWriteRenderTarget,\n                          struct ID2D1SolidColorBrush **DWriteFillBrush)\n{\n    int Result = 0;\n\n    // TODO(casey): Obey \"ClearType\" here.\n\n    // TODO(casey): Not sure about these props...\n    D2D1_RENDER_TARGET_PROPERTIES Props = D2D1::RenderTargetProperties(D2D1_RENDER_TARGET_TYPE_DEFAULT,\n                                                                       D2D1::PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED),\n                                                                       0, 0);\n\n    ID2D1Factory *Factory = 0;\n    D2D1_FACTORY_OPTIONS Options = {};\n    Options.debugLevel = D2D1_DEBUG_LEVEL_ERROR;\n    D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, __uuidof(ID2D1Factory), &Options, (void**)&Factory);\n    if(Factory)\n    {\n        Factory->CreateDxgiSurfaceRenderTarget(GlyphTransferSurface, &Props, DWriteRenderTarget);\n        if(*DWriteRenderTarget)\n        {\n            (*DWriteRenderTarget)->CreateSolidColorBrush(D2D1::ColorF(1.0f, 1.0f, 1.0f, 1.0f), DWriteFillBrush);\n            Result = (*DWriteFillBrush != 0);\n        }\n\n        Factory->Release();\n    }\n\n    return Result;\n}\n\nextern \"C\" void D2DRelease(struct ID2D1RenderTarget **DWriteRenderTarget,\n                           struct ID2D1SolidColorBrush **DWriteFillBrush)\n{\n    if(*DWriteFillBrush)\n    {\n        (*DWriteFillBrush)->Release();\n        *DWriteFillBrush = 0;\n    }\n\n    if(*DWriteRenderTarget)\n    {\n        (*DWriteRenderTarget)->Release();\n        *DWriteRenderTarget = 0;\n    }\n}\n\nextern \"C\" int DWriteInit(glyph_generator *GlyphGen, IDXGISurface *GlyphTransferSurface)\n{\n    int Result = 0;\n\n    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), (IUnknown**)&GlyphGen->DWriteFactory);\n    if(GlyphGen->DWriteFactory)\n    {\n        Result = 1;\n    }\n\n    return Result;\n}\n\nextern \"C\" SIZE DWriteGetTextExtent(glyph_generator *GlyphGen, int StringLen, wchar_t *String)\n{\n    SIZE Result = {0};\n\n    IDWriteTextLayout *Layout = 0;\n    GlyphGen->DWriteFactory->CreateTextLayout(String, StringLen, GlyphGen->TextFormat,\n                                              (float)GlyphGen->TransferWidth, (float)GlyphGen->TransferHeight, &Layout);\n    if(Layout)\n    {\n        DWRITE_TEXT_METRICS Metrics = {0};\n        Layout->GetMetrics(&Metrics);\n        Assert(Metrics.left == 0);\n        Assert(Metrics.top == 0);\n        Result.cx = (uint32_t)(Metrics.width + 0.5f);\n        Result.cy = (uint32_t)(Metrics.height + 0.5f);\n\n        Layout->Release();\n    }\n\n    return Result;\n}\n\nvoid DWriteReleaseFont(glyph_generator *GlyphGen)\n{\n    if(GlyphGen->FontFace)\n    {\n        GlyphGen->FontFace->Release();\n        GlyphGen->FontFace = 0;\n    }\n}\n\nvoid IncludeLetterBounds(glyph_generator *GlyphGen, wchar_t Letter)\n{\n    IDWriteTextLayout *Layout = 0;\n    GlyphGen->DWriteFactory->CreateTextLayout(&Letter, 1, GlyphGen->TextFormat,\n                                              (float)GlyphGen->TransferWidth, (float)GlyphGen->TransferHeight, &Layout);\n    if(Layout)\n    {\n        // TODO(casey): Real cell size determination would go here - probably with input from the user?\n        DWRITE_TEXT_METRICS CharMetrics = {0};\n        Layout->GetMetrics(&CharMetrics);\n\n        DWRITE_LINE_METRICS LineMetrics = {0};\n        UINT32 Ignored;\n        Layout->GetLineMetrics(&LineMetrics, 1, &Ignored);\n\n        if(GlyphGen->FontHeight < (uint32_t)(LineMetrics.height + 0.5f))\n        {\n            GlyphGen->FontHeight = (uint32_t)(LineMetrics.height + 0.5f);\n        }\n\n        if(GlyphGen->FontHeight < (uint32_t)(CharMetrics.height + 0.5f))\n        {\n            GlyphGen->FontHeight = (uint32_t)(CharMetrics.height + 0.5f);\n        }\n\n        if(GlyphGen->FontWidth < (uint32_t)(CharMetrics.width + 0.5f))\n        {\n            GlyphGen->FontWidth = (uint32_t)(CharMetrics.width + 0.5f);\n        }\n\n        Layout->Release();\n    }\n}\n\nextern \"C\" int DWriteSetFont(glyph_generator *GlyphGen, wchar_t *FontName, uint32_t FontHeight)\n{\n    int Result = 0;\n\n    DWriteReleaseFont(GlyphGen);\n\n    if(GlyphGen->DWriteFactory)\n    {\n        GlyphGen->DWriteFactory->CreateTextFormat(FontName,\n                                                  0,\n                                                  DWRITE_FONT_WEIGHT_REGULAR,\n                                                  DWRITE_FONT_STYLE_NORMAL,\n                                                  DWRITE_FONT_STRETCH_NORMAL,\n                                                  (float)FontHeight,\n                                                  L\"en-us\", // TODO(casey): Where do I get this from?  Normally locales are IDs, but this is a string for some reason???\n                                                  &GlyphGen->TextFormat);\n        if(GlyphGen->TextFormat)\n        {\n            GlyphGen->TextFormat->SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);\n            GlyphGen->TextFormat->SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);\n\n            GlyphGen->FontWidth = 0;\n            GlyphGen->FontHeight = 0;\n            IncludeLetterBounds(GlyphGen, L'M');\n            IncludeLetterBounds(GlyphGen, L'g');\n\n            Result = 1;\n        }\n    }\n\n    return Result;\n}\n\nextern \"C\" void DWriteDrawText(glyph_generator *GlyphGen, int StringLen, WCHAR *String,\n                               uint32_t Left, uint32_t Top, uint32_t Right, uint32_t Bottom,\n                               struct ID2D1RenderTarget *RenderTarget,\n                               struct ID2D1SolidColorBrush *FillBrush,\n                               float XScale, float YScale)\n{\n    D2D1_RECT_F Rect;\n\n    Rect.left = (float)Left;\n    Rect.top = (float)Top;\n    Rect.right = (float)Right;\n    Rect.bottom = (float)Bottom;\n\n    RenderTarget->SetTransform(D2D1::Matrix3x2F::Scale(D2D1::Size(XScale, YScale),\n                               D2D1::Point2F(0.0f, 0.0f)));\n    RenderTarget->BeginDraw();\n    RenderTarget->Clear();\n    RenderTarget->DrawText(String, StringLen, GlyphGen->TextFormat, &Rect, FillBrush,\n                           D2D1_DRAW_TEXT_OPTIONS_CLIP|D2D1_DRAW_TEXT_OPTIONS_ENABLE_COLOR_FONT, DWRITE_MEASURING_MODE_NATURAL);\n    HRESULT Error = RenderTarget->EndDraw();\n    if(!SUCCEEDED(Error))\n    {\n        Assert(!\"EndDraw failed\");\n    }\n}\n\nextern \"C\" void DWriteRelease(glyph_generator *GlyphGen)\n{\n    /* NOTE(casey): There is literally no point to this function\n       whatsoever except to stop the D3D debug runtime from\n       complaining about unreleased resources when the program\n       exits.  EVEN THOUGH THEY WOULD BE AUTOMATICALLY RELEASED\n       AT THAT TIME.  So now here I am manually releasing them,\n       which wastes the user's time, for no reason at all. */\n\n    DWriteReleaseFont(GlyphGen);\n    if(GlyphGen->DWriteFactory) GlyphGen->DWriteFactory->Release();\n}\n"
        },
        {
          "name": "refterm_example_dwrite.h",
          "type": "blob",
          "size": 1.3095703125,
          "content": "/* NOTE(casey): \n\n   There is no reason for this file to exist at all, other than the fact that\n   they didn't bother to make DirectWrite work with C.  So this file just\n   hides the DirectWrite C++ calls behind a simple C API so that they can\n   be used by people writing plain C code.\n*/\n\ntypedef struct ID2D1RenderTarget ID2D1RenderTarget;\ntypedef struct ID2D1SolidColorBrush ID2D1SolidColorBrush;\nint D2DAcquire(IDXGISurface *GlyphTransferSurface,\n               ID2D1RenderTarget **DWriteRenderTarget,\n               ID2D1SolidColorBrush **DWriteFillBrush);\nvoid D2DRelease(ID2D1RenderTarget **DWriteRenderTarget,\n                ID2D1SolidColorBrush **DWriteFillBrush);\n\ntypedef struct glyph_generator glyph_generator;\nint DWriteInit(glyph_generator *GlyphGen, IDXGISurface *GlyphTransferSurface);\n\nint DWriteSetFont(glyph_generator *GlyphGen, wchar_t *FontName, uint32_t FontHeight);\n\nvoid DWriteDrawText(glyph_generator *GlyphGen, int StringLen, wchar_t *String,\n                    uint32_t Left, uint32_t Top, uint32_t Right, uint32_t Bottom,\n                    ID2D1RenderTarget *RenderTarget,\n                    ID2D1SolidColorBrush *FillBrush,\n                    float XScale, float YScale);\n\nSIZE DWriteGetTextExtent(glyph_generator *GlyphGen, int StringLen, wchar_t *String);\n\nvoid DWriteRelease(glyph_generator *GlyphGen);"
        },
        {
          "name": "refterm_example_glyph_generator.c",
          "type": "blob",
          "size": 5.1572265625,
          "content": "static int SetFont(glyph_generator *GlyphGen, wchar_t *FontName, uint32_t FontHeight)\n{\n    int Result = DWriteSetFont(GlyphGen, FontName, FontHeight);\n    return Result;\n}\n\nstatic glyph_generator AllocateGlyphGenerator(uint32_t TransferWidth, uint32_t TransferHeight,\n                                              IDXGISurface *GlyphTransferSurface)\n{\n    glyph_generator GlyphGen = {0};\n\n    GlyphGen.TransferWidth = TransferWidth;\n    GlyphGen.TransferHeight = TransferHeight;\n\n    DWriteInit(&GlyphGen, GlyphTransferSurface);\n\n    return GlyphGen;\n}\n\nstatic uint32_t GetExpectedTileCountForDimension(glyph_generator *GlyphGen, uint32_t Width, uint32_t Height)\n{\n    uint32_t PerRow = SafeRatio1(Width, GlyphGen->FontWidth);\n    uint32_t PerColumn = SafeRatio1(Height, GlyphGen->FontHeight);\n    uint32_t Result = PerRow*PerColumn;\n\n    return Result;\n}\n\nstatic glyph_dim GetSingleTileUnitDim(void)\n{\n    glyph_dim Result = {1, 1.0f, 1.0f};\n    return Result;\n}\n\nstatic glyph_dim GetGlyphDim(glyph_generator *GlyphGen, glyph_table *Table, size_t Count, wchar_t *String, glyph_hash RunHash)\n{\n    /* TODO(casey): Windows can only 2^31 glyph runs - which\n       seems fine, but... technically Unicode can have more than two\n       billion combining characters, so I guess theoretically this\n       code is broken - another \"reason\" to do a custom glyph rasterizer? */\n\n    glyph_dim Result = {0};\n\n    DWORD StringLen = (DWORD)Count;\n    Assert(StringLen == Count);\n\n    SIZE Size = {0};\n    glyph_state Entry = FindGlyphEntryByHash(Table, RunHash);\n    if(Entry.FilledState == GlyphState_None)\n    {\n        if(StringLen)\n        {\n            Size = DWriteGetTextExtent(GlyphGen, StringLen, String);\n        }\n\n        UpdateGlyphCacheEntry(Table, Entry.ID, GlyphState_Sized, (uint16_t)Size.cx, (uint16_t)Size.cy);\n    }\n    else\n    {\n        Size.cx = Entry.DimX;\n        Size.cy = Entry.DimY;\n    }\n\n    Result.TileCount = SafeRatio1((uint16_t)(Size.cx + GlyphGen->FontWidth/2), GlyphGen->FontWidth);\n    \n    Result.XScale = 1.0f;\n    if((uint32_t)Size.cx > GlyphGen->FontWidth)\n    {\n        Result.XScale = SafeRatio1((float)(Result.TileCount*GlyphGen->FontWidth),\n                                   (float)(Size.cx));\n    }\n    \n    Result.YScale = 1.0f;\n    if((uint32_t)Size.cy > GlyphGen->FontHeight)\n    {\n        Result.YScale = SafeRatio1((float)GlyphGen->FontHeight, (float)Size.cy);\n    }\n        \n    return Result;\n}\n\nstatic void PrepareTilesForTransfer(glyph_generator *GlyphGen, d3d11_renderer *Renderer, size_t Count, wchar_t *String, glyph_dim Dim)\n{\n    DWORD StringLen = (DWORD)Count;\n    Assert(StringLen == Count);\n\n    DWriteDrawText(GlyphGen, StringLen, String, 0, 0, GlyphGen->TransferWidth, GlyphGen->TransferHeight,\n                   Renderer->DWriteRenderTarget, Renderer->DWriteFillBrush, Dim.XScale, Dim.YScale);\n}\n\nstatic void TransferTile(glyph_generator *GlyphGen, d3d11_renderer *Renderer, uint32_t TileIndex, gpu_glyph_index DestIndex)\n{\n    /* TODO(casey):\n\n       Regardless of whether DirectWrite or GDI is used, rasterizing glyphs via Windows' libraries is extremely slow.\n\n       It may appear that this code path itself is the reason for the slowness, because this does a very inefficient\n       \"draw-then-transfer\" for every glyph group, which is the slowest possible way you could do it.  However, I\n       actually _tried_ doing batching, where you make a single call to DirectWrite or GDI to rasterize\n       large sets of glyphs which are then transfered all at once.\n\n       Although this does help the performance (IIRC there was about 2x total speedup in heavy use),\n       the peformance is still about two orders of magnitude away from where it should be.  So I removed the batching,\n       because it complicates the code quite a bit, and does not actually produce acceptable performance.\n\n       I believe the only solution to actual fast glyph generation is to just write something that isn't as\n       bad as GDI/DirectWrite.  It's a waste of code complexity to try to get a reasonable speed out of them, unless\n       someone else manages to find some magic switches I didn't find that make them work at a high speed in\n       bulk.\n    */\n\n    /* TODO(casey):\n\n       At the moment, we do not do anything to fix the problem of trying to set the font size\n       so large that it cannot be rasterized into the transfer buffer.  At some point, maybe\n       we should warn about that and revert the font size to something smaller?\n    */\n\n    if(Renderer->DeviceContext)\n    {\n        glyph_cache_point Point = UnpackGlyphCachePoint(DestIndex);\n        uint32_t X = Point.X*GlyphGen->FontWidth;\n        uint32_t Y = Point.Y*GlyphGen->FontHeight;\n\n        D3D11_BOX SourceBox =\n        {\n            .left = (TileIndex)*GlyphGen->FontWidth,\n            .right = (TileIndex + 1)*GlyphGen->FontWidth,\n            .top = 0,\n            .bottom = GlyphGen->FontHeight,\n            .front = 0,\n            .back = 1,\n        };\n\n        ID3D11DeviceContext_CopySubresourceRegion(Renderer->DeviceContext,\n                                                  (ID3D11Resource *)Renderer->GlyphTexture, 0, X, Y, 0,\n                                                  (ID3D11Resource *)Renderer->GlyphTransfer, 0, &SourceBox);\n    }\n}\n"
        },
        {
          "name": "refterm_example_glyph_generator.h",
          "type": "blob",
          "size": 0.5947265625,
          "content": "typedef enum\n{\n    GlyphState_None,\n    GlyphState_Sized,\n    GlyphState_Rasterized,\n} glyph_entry_state;\n\ntypedef struct glyph_generator glyph_generator;\ntypedef struct glyph_dim glyph_dim;\n\nstruct glyph_dim\n{\n    uint32_t TileCount;\n    float XScale, YScale;\n};\n\nstruct glyph_generator\n{\n    uint32_t FontWidth, FontHeight;\n    uint32_t Pitch;\n    uint32_t *Pixels;\n    \n    uint32_t TransferWidth;\n    uint32_t TransferHeight;\n    \n    // NOTE(casey): For DWrite-based generation:\n    struct IDWriteFactory *DWriteFactory;\n    struct IDWriteFontFace *FontFace;\n    struct IDWriteTextFormat *TextFormat;\n};\n"
        },
        {
          "name": "refterm_example_source_buffer.c",
          "type": "blob",
          "size": 7.9169921875,
          "content": "static source_buffer AllocateSourceBuffer(size_t DataSize)\n{\n    source_buffer Result = {0};\n\n    SYSTEM_INFO Info;\n    GetSystemInfo(&Info);\n    Assert(IsPowerOfTwo(Info.dwAllocationGranularity));\n\n    // NOTE(casey): This has to be aligned to the allocation granularity otherwise the back-to-back buffer mapping might\n    // not work.\n    DataSize = (DataSize + Info.dwAllocationGranularity - 1) & ~(Info.dwAllocationGranularity - 1);\n    HANDLE Section = CreateFileMapping (INVALID_HANDLE_VALUE, 0, PAGE_READWRITE, (DWORD)(DataSize >> 32), (DWORD)(DataSize & 0xffffffff), 0);\n\n #ifdef MEM_REPLACE_PLACEHOLDER\n    void* Placeholder1 = VirtualAlloc2 (0, 0,\n                                        2 * DataSize, MEM_RESERVE | MEM_RESERVE_PLACEHOLDER, PAGE_NOACCESS,\n                                        0, 0);\n    VirtualFree (Placeholder1, DataSize, MEM_RELEASE | MEM_PRESERVE_PLACEHOLDER);\n    void *Placeholder2 = ((char *)Placeholder1 + DataSize);\n\n    void *View1 = MapViewOfFile3 (Section, 0, Placeholder1, 0, DataSize, MEM_REPLACE_PLACEHOLDER, PAGE_READWRITE, 0, 0);\n    void *View2 = MapViewOfFile3 (Section, 0, Placeholder2, 0, DataSize, MEM_REPLACE_PLACEHOLDER, PAGE_READWRITE, 0, 0);\n    if(View1 && View2)\n    {\n        Result.Data = View1;\n        Result.DataSize = DataSize;\n    }\n    else\n    {\n        MessageBoxW(0, L\"Unable to allocate scrollback buffer with placeholder\", L\"WARNING\", MB_OK);\n#endif\n        for(size_t Offset = 0x40000000;\n            Offset < 0x400000000;\n            Offset += 0x1000000)\n        {\n            // TODO(casey): Harden this path to try multiple times\n            void *View1 = (char *)MapViewOfFileEx(Section, FILE_MAP_ALL_ACCESS, 0, 0, DataSize, (void *)Offset);\n            void *View2 = MapViewOfFileEx(Section, FILE_MAP_ALL_ACCESS, 0, 0, DataSize, ((char *)View1 + DataSize));\n\n            if(View1 && View2)\n            {\n                Result.Data = View1;\n                Result.DataSize = DataSize;\n                break;\n            }\n\n            if(View1) UnmapViewOfFile(View1);\n            if(View2) UnmapViewOfFile(View2);\n        }\n\n        if(!Result.Data)\n        {\n            MessageBoxW(0, L\"Unable to allocate scrollback buffer with probing\", L\"Fatal error\", MB_OK|MB_ICONSTOP);\n        }\n#ifdef MEM_REPLACE_PLACEHOLDER\n    }\n#endif\n\n    return Result;\n}\n\nstatic int IsInBuffer(source_buffer *Buffer, size_t AbsoluteP)\n{\n    size_t BackwardOffset = Buffer->AbsoluteFilledSize - AbsoluteP;\n    int Result = ((AbsoluteP < Buffer->AbsoluteFilledSize) &&\n                  (BackwardOffset < Buffer->DataSize));\n    return Result;\n}\n\nstatic source_buffer_range AdvanceRange(source_buffer_range Source, size_t ToAbsoluteP, size_t Count)\n{\n    source_buffer_range Result = Source;\n\n    // NOTE(casey): Moving ranges backwards isn't safe, because you may slide off the beginning of the circular buffer.\n    Assert(ToAbsoluteP >= Result.AbsoluteP);\n\n    Result.Data += ToAbsoluteP - Result.AbsoluteP;\n    Result.AbsoluteP = ToAbsoluteP;\n    Result.Count = Count;\n\n    return Result;\n}\n\nstatic source_buffer_range ConsumeCount(source_buffer_range Source, size_t Count)\n{\n    source_buffer_range Result = Source;\n\n    if(Count > Result.Count)\n    {\n        Count = Result.Count;\n    }\n\n    Result.Data += Count;\n    Result.AbsoluteP += Count;\n    Result.Count -= Count;\n\n    return Result;\n}\n\nstatic source_buffer_range ReadSourceAt(source_buffer *Buffer, size_t AbsoluteP, size_t Count)\n{\n    source_buffer_range Result = {0};\n    if(IsInBuffer(Buffer, AbsoluteP))\n    {\n        Result.AbsoluteP = AbsoluteP;\n        Result.Count = (Buffer->AbsoluteFilledSize - AbsoluteP);\n        Result.Data = Buffer->Data + Buffer->DataSize + Buffer->RelativePoint - Result.Count;\n\n        if(Result.Count > Count)\n        {\n            Result.Count = Count;\n        }\n    }\n\n    return Result;\n}\n\nstatic size_t GetCurrentAbsoluteP(source_buffer *Buffer)\n{\n    size_t Result = Buffer->AbsoluteFilledSize;\n    return Result;\n}\n\n#define LARGEST_AVAILABLE ((size_t)-1)\nstatic source_buffer_range GetNextWritableRange(source_buffer *Buffer, size_t MaxCount)\n{\n    Assert(Buffer->RelativePoint < Buffer->DataSize);\n\n    source_buffer_range Result = {0};\n    Result.AbsoluteP = Buffer->AbsoluteFilledSize;\n    Result.Count = Buffer->DataSize;\n    Result.Data = Buffer->Data + Buffer->RelativePoint;\n\n    if(Result.Count > MaxCount)\n    {\n        Result.Count = MaxCount;\n    }\n\n    return Result;\n}\n\nstatic void CommitWrite(source_buffer *Buffer, size_t Size)\n{\n    Assert(Buffer->RelativePoint < Buffer->DataSize);\n    Assert(Size <= Buffer->DataSize);\n\n    Buffer->RelativePoint += Size;\n    Buffer->AbsoluteFilledSize += Size;\n\n    size_t WrappedRelative = Buffer->RelativePoint - Buffer->DataSize;\n    Buffer->RelativePoint = (Buffer->RelativePoint >= Buffer->DataSize) ? WrappedRelative : Buffer->RelativePoint;\n\n    Assert(Buffer->RelativePoint < Buffer->DataSize);\n}\n\nstatic char unsigned OverhangMask[32] =\n{\n    255, 255, 255, 255,  255, 255, 255, 255,  255, 255, 255, 255,  255, 255, 255, 255,\n    0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0\n};\nstatic char unsigned DefaultSeed[16] =\n{\n    178, 201, 95, 240, 40, 41, 143, 216,\n    2, 209, 178, 114, 232, 4, 176, 188\n};\nstatic glyph_hash ComputeGlyphHash(size_t Count, char unsigned *At, char unsigned *Seedx16)\n{\n    /* TODO(casey):\n\n      Consider and test some alternate hash designs.  The hash here\n      was the simplest thing to type in, but it is not necessarily\n      the best hash for the job.  It may be that less AES rounds\n      would produce equivalently collision-free results for the\n      problem space.  It may be that non-AES hashing would be\n      better.  Some careful analysis would be nice.\n    */\n\n    // TODO(casey): Does the result of a grapheme composition\n    // depend on whether or not it was RTL or LTR?  Or are there\n    // no fonts that ever get used in both directions, so it doesn't\n    // matter?\n\n    // TODO(casey): Double-check exactly the pattern\n    // we want to use for the hash here\n\n    glyph_hash Result = {0};\n\n    // TODO(casey): Should there be an IV?\n    __m128i HashValue = _mm_cvtsi64_si128(Count);\n    HashValue = _mm_xor_si128(HashValue, _mm_loadu_si128((__m128i *)Seedx16));\n\n    size_t ChunkCount = Count / 16;\n    while(ChunkCount--)\n    {\n        __m128i In = _mm_loadu_si128((__m128i *)At);\n        At += 16;\n\n        HashValue = _mm_xor_si128(HashValue, In);\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n    }\n\n    size_t Overhang = Count % 16;\n\n\n#if 0\n    __m128i In = _mm_loadu_si128((__m128i *)At);\n#else\n    // TODO(casey): This needs to be improved - it's too slow, and the #if 0 branch would be nice but can't\n    // work because of overrun, etc.\n    char Temp[16];\n    __movsb((unsigned char *)Temp, At, Overhang);\n    __m128i In = _mm_loadu_si128((__m128i *)Temp);\n#endif\n    In = _mm_and_si128(In, _mm_loadu_si128((__m128i *)(OverhangMask + 16 - Overhang)));\n    HashValue = _mm_xor_si128(HashValue, In);\n    HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n    HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n    HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n    HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n\n    Result.Value = HashValue;\n\n    return Result;\n}\n\nstatic glyph_hash ComputeHashForTileIndex(glyph_hash Tile0Hash, uint32_t TileIndex)\n{\n    __m128i HashValue = Tile0Hash.Value;\n    if(TileIndex)\n    {\n        HashValue = _mm_xor_si128(HashValue, _mm_set1_epi32(TileIndex));\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n        HashValue = _mm_aesdec_si128(HashValue, _mm_setzero_si128());\n    }\n\n    glyph_hash Result = {HashValue};\n    return Result;\n}\n"
        },
        {
          "name": "refterm_example_source_buffer.h",
          "type": "blob",
          "size": 0.3046875,
          "content": "typedef struct\n{\n    size_t AbsoluteP;\n    size_t Count;\n    char *Data;\n} source_buffer_range;\n\ntypedef struct \n{\n    size_t DataSize;\n    char *Data;\n\n    // NOTE(casey): For circular buffer\n    size_t RelativePoint;\n    \n    // NOTE(casey): For cache checking\n    size_t AbsoluteFilledSize;\n} source_buffer;\n\n"
        },
        {
          "name": "refterm_example_terminal.c",
          "type": "blob",
          "size": 50.216796875,
          "content": "static terminal_buffer AllocateTerminalBuffer(int DimX, int DimY)\n{\n    terminal_buffer Result = {0};\n\n    size_t TotalSize = sizeof(renderer_cell)*DimX*DimY;\n    Result.Cells = VirtualAlloc(0, TotalSize, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n    if(Result.Cells)\n    {\n        Result.DimX = DimX;\n        Result.DimY = DimY;\n    }\n\n    return Result;\n}\n\nstatic void DeallocateTerminalBuffer(terminal_buffer *Buffer)\n{\n    if(Buffer && Buffer->Cells)\n    {\n        VirtualFree(Buffer->Cells, 0, MEM_RELEASE);\n        Buffer->DimX = Buffer->DimY = 0;\n        Buffer->Cells = 0;\n    }\n}\n\nstatic DWORD GetPipePendingDataCount(HANDLE Pipe)\n{\n    DWORD Result = 0;\n    PeekNamedPipe(Pipe, 0, 0, 0, &Result, 0);\n\n    return Result;\n}\n\nstatic void UpdateLineEnd(example_terminal *Terminal, size_t ToP)\n{\n    Terminal->Lines[Terminal->CurrentLineIndex].OnePastLastP = ToP;\n}\n\nstatic void LineFeed(example_terminal *Terminal, size_t AtP, size_t NextLineStart, glyph_props AtProps)\n{\n    UpdateLineEnd(Terminal, AtP);\n    ++Terminal->CurrentLineIndex;\n    if(Terminal->CurrentLineIndex >= Terminal->MaxLineCount)\n    {\n        Terminal->CurrentLineIndex = 0;\n    }\n\n    example_line *Line = Terminal->Lines + Terminal->CurrentLineIndex;\n    Line->FirstP = NextLineStart;\n    Line->OnePastLastP = NextLineStart;\n    Line->ContainsComplexChars = 0;\n    Line->StartingProps = AtProps;\n\n    if(Terminal->LineCount <= Terminal->CurrentLineIndex)\n    {\n        Terminal->LineCount = Terminal->CurrentLineIndex + 1;\n    }\n}\n\nstatic int IsInBounds(terminal_buffer *Buffer, terminal_point Point)\n{\n    int Result = ((Point.X >= 0) && (Point.X < (int)Buffer->DimX) &&\n                  (Point.Y >= 0) && (Point.Y < (int)Buffer->DimY));\n    return Result;\n}\n\nstatic uint32_t PackRGB(uint32_t R, uint32_t G, uint32_t B)\n{\n    if(R > 255) R = 255;\n    if(G > 255) G = 255;\n    if(B > 255) B = 255;\n    uint32_t Result = ((B << 16) | (G << 8) | (R << 0));\n    return Result;\n}\n\nstatic int IsDigit(char Digit)\n{\n    int Result = ((Digit >= '0') && (Digit <= '9'));\n    return Result;\n}\n\nstatic char PeekToken(source_buffer_range *Range, int Ordinal)\n{\n    char Result = 0;\n\n    if(Ordinal < Range->Count)\n    {\n        Result = Range->Data[Ordinal];\n    }\n\n    return Result;\n}\n\nstatic char GetToken(source_buffer_range *Range)\n{\n    char Result = 0;\n\n    if(Range->Count)\n    {\n        Result = Range->Data[0];\n        *Range = ConsumeCount(*Range, 1);\n    }\n\n    return Result;\n}\n\nstatic uint32_t ParseNumber(source_buffer_range *Range)\n{\n    uint32_t Result = 0;\n    while(IsDigit(PeekToken(Range, 0)))\n    {\n        char Token = GetToken(Range);\n        Result = 10*Result + (Token - '0');\n    }\n    return Result;\n}\n\nstatic int AtEscape(source_buffer_range *Range)\n{\n    int Result = ((PeekToken(Range, 0) == '\\x1b') &&\n                  (PeekToken(Range, 1) == '['));\n    return Result;\n}\n\nstatic int IsDirectCodepoint(wchar_t CodePoint)\n{\n    int Result = ((CodePoint >= MinDirectCodepoint) &&\n                  (CodePoint <= MaxDirectCodepoint));\n    return Result;\n}\n\nstatic renderer_cell *GetCell(terminal_buffer *Buffer, terminal_point Point)\n{\n    renderer_cell *Result = IsInBounds(Buffer, Point) ? (Buffer->Cells + Point.Y*Buffer->DimX + Point.X) : 0;\n    return Result;\n}\n\nstatic void ClearCellCount(example_terminal *Terminal, int32_t Count, renderer_cell *Cell)\n{\n    uint32_t Background = Terminal->DefaultBackgroundColor;\n    while(Count--)\n    {\n        Cell->GlyphIndex = 0;\n        Cell->Foreground = Background; // TODO(casey): Should be able to set this to 0, but need to make sure cache slot 0 never gets filled\n        Cell->Background = Background;\n        ++Cell;\n    }\n}\n\nstatic void ClearLine(example_terminal *Terminal, terminal_buffer *Buffer, int32_t Y)\n{\n    terminal_point Point = {0, Y};\n    if(IsInBounds(Buffer, Point))\n    {\n        ClearCellCount(Terminal, Buffer->DimX, GetCell(Buffer, Point));\n    }\n}\n\nstatic void Clear(example_terminal *Terminal, terminal_buffer *Buffer)\n{\n    ClearCellCount(Terminal, Buffer->DimX*Buffer->DimY, Buffer->Cells);\n}\n\nstatic void AdvanceRowNoClear(example_terminal *Terminal, terminal_point *Point)\n{\n    Point->X = 0;\n    ++Point->Y;\n    if(Point->Y >= (int32_t)Terminal->ScreenBuffer.DimY)\n    {\n        Point->Y = 0;\n    }\n}\n\nstatic void AdvanceRow(example_terminal *Terminal, terminal_point *Point)\n{\n    AdvanceRowNoClear(Terminal, Point);\n    ClearLine(Terminal, &Terminal->ScreenBuffer, Point->Y);\n}\n\nstatic void AdvanceColumn(example_terminal *Terminal, terminal_point *Point)\n{\n    ++Point->X;\n    if(Terminal->LineWrap && (Point->X >= (int32_t)Terminal->ScreenBuffer.DimX))\n    {\n        AdvanceRow(Terminal, Point);\n    }\n}\n\nstatic void SetCellDirect(gpu_glyph_index GPUIndex, glyph_props Props, renderer_cell *Dest)\n{\n    Dest->GlyphIndex = GPUIndex.Value;\n    uint32_t Foreground = Props.Foreground;\n    uint32_t Background = Props.Background;\n    if(Props.Flags & TerminalCell_ReverseVideo)\n    {\n        Foreground = Props.Background;\n        Background = Props.Foreground;\n    }\n\n    if(Props.Flags & TerminalCell_Invisible)\n    {\n        Dest->GlyphIndex = 0;\n    }\n\n    Dest->Foreground = Foreground | (Props.Flags << 24);\n    Dest->Background = Background;\n}\n\nstatic void ClearProps(example_terminal *Terminal, glyph_props *Props)\n{\n    Props->Foreground = Terminal->DefaultForegroundColor;\n    Props->Background = Terminal->DefaultBackgroundColor;\n    Props->Flags = 0;\n}\n\nstatic void ClearCursor(example_terminal *Terminal, cursor_state *Cursor)\n{\n    Cursor->At.X = 0;\n    Cursor->At.Y = 0;\n    ClearProps(Terminal, &Cursor->Props);\n}\n\nstatic int ParseEscape(example_terminal *Terminal, source_buffer_range *Range, cursor_state *Cursor)\n{\n    int MovedCursor = 0;\n\n    GetToken(Range);\n    GetToken(Range);\n\n    wchar_t Command = 0;\n    uint32_t ParamCount = 0;\n    uint32_t Params[8] = {0};\n    while((ParamCount < ArrayCount(Params)) && Range->Count)\n    {\n        char Token = PeekToken(Range, 0);\n        if(IsDigit(Token))\n        {\n            Params[ParamCount++] = ParseNumber(Range);\n            wchar_t Semi = GetToken(Range);\n            if(Semi != ';')\n            {\n                Command = Semi;\n                break;\n            }\n        }\n        else\n        {\n            Command = GetToken(Range);\n        }\n    }\n\n    switch(Command)\n    {\n        case 'H':\n        {\n            // NOTE(casey): Move cursor to X,Y position\n            Cursor->At.X = Params[1] - 1;\n            Cursor->At.Y = Params[0] - 1;\n            MovedCursor = 1;\n        } break;\n\n        case 'm':\n        {\n            // NOTE(casey): Set graphics mode\n            if(Params[0] == 0)\n            {\n                ClearProps(Terminal, &Cursor->Props);\n            }\n\n            if(Params[0] == 1) Cursor->Props.Flags |= TerminalCell_Bold;\n            if(Params[0] == 2) Cursor->Props.Flags |= TerminalCell_Dim;\n            if(Params[0] == 3) Cursor->Props.Flags |= TerminalCell_Italic;\n            if(Params[0] == 4) Cursor->Props.Flags |= TerminalCell_Underline;\n            if(Params[0] == 5) Cursor->Props.Flags |= TerminalCell_Blinking;\n            if(Params[0] == 7) Cursor->Props.Flags |= TerminalCell_ReverseVideo;\n            if(Params[0] == 8) Cursor->Props.Flags |= TerminalCell_Invisible;\n            if(Params[0] == 9) Cursor->Props.Flags |= TerminalCell_Strikethrough;\n\n            if((Params[0] == 38) && (Params[1] == 2)) Cursor->Props.Foreground = PackRGB(Params[2], Params[3], Params[4]);\n            if((Params[0] == 48) && (Params[1] == 2)) Cursor->Props.Background = PackRGB(Params[2], Params[3], Params[4]);\n        } break;\n    }\n\n    return MovedCursor;\n}\n\nstatic size_t GetLineLength(example_line *Line)\n{\n    Assert(Line->OnePastLastP >= Line->FirstP);\n    size_t Result = Line->OnePastLastP - Line->FirstP;\n    return Result;\n}\n\nstatic void ParseLines(example_terminal *Terminal, source_buffer_range Range, cursor_state *Cursor)\n{\n    /* TODO(casey): Currently, if the commit of line data _straddles_ a control code boundary\n       this code does not properly _stop_ the processing cursor.  This can cause an edge case\n       where a VT code that splits a line _doesn't_ split the line as it should.  To fix this\n       the ending code just needs to check to see if the reason it couldn't parse an escape\n       code in \"AtEscape\" was that it ran out of characters, and if so, don't advance the parser\n       past that point.\n    */\n\n    __m128i Carriage = _mm_set1_epi8('\\n');\n    __m128i Escape = _mm_set1_epi8('\\x1b');\n    __m128i Complex = _mm_set1_epi8(0x80);\n\n    size_t SplitLineAtCount = 4096;\n    size_t LastP = Range.AbsoluteP;\n    while(Range.Count)\n    {\n        __m128i ContainsComplex = _mm_setzero_si128();\n        size_t Count = Range.Count;\n        if(Count > SplitLineAtCount) Count = SplitLineAtCount;\n        char *Data = Range.Data;\n        while(Count >= 16)\n        {\n            __m128i Batch = _mm_loadu_si128((__m128i *)Data);\n            __m128i TestC = _mm_cmpeq_epi8(Batch, Carriage);\n            __m128i TestE = _mm_cmpeq_epi8(Batch, Escape);\n            __m128i TestX = _mm_and_si128(Batch, Complex);\n            __m128i Test = _mm_or_si128(TestC, TestE);\n            int Check = _mm_movemask_epi8(Test);\n            if(Check)\n            {\n                int Advance = _tzcnt_u32(Check);\n                __m128i MaskX = _mm_loadu_si128((__m128i *)(OverhangMask + 16 - Advance));\n                TestX = _mm_and_si128(MaskX, TestX);\n                ContainsComplex = _mm_or_si128(ContainsComplex, TestX);\n                Count -= Advance;\n                Data += Advance;\n                break;\n            }\n\n            ContainsComplex = _mm_or_si128(ContainsComplex, TestX);\n            Count -= 16;\n            Data += 16;\n        }\n\n        Range = ConsumeCount(Range, Data - Range.Data);\n\n        Terminal->Lines[Terminal->CurrentLineIndex].ContainsComplexChars |=\n            _mm_movemask_epi8(ContainsComplex);\n\n        if(AtEscape(&Range))\n        {\n            size_t FeedAt = Range.AbsoluteP;\n            if(ParseEscape(Terminal, &Range, Cursor))\n            {\n                LineFeed(Terminal, FeedAt, FeedAt, Cursor->Props);\n            }\n        }\n        else\n        {\n            char Token = GetToken(&Range);\n            if(Token == '\\n')\n            {\n                LineFeed(Terminal, Range.AbsoluteP, Range.AbsoluteP, Cursor->Props);\n            }\n            else if(Token < 0) // TODO(casey): Not sure what is a \"combining char\" here, really, but this is a rough test\n            {\n                Terminal->Lines[Terminal->CurrentLineIndex].ContainsComplexChars = 1;\n            }\n        }\n\n        UpdateLineEnd(Terminal, Range.AbsoluteP);\n        if(GetLineLength(&Terminal->Lines[Terminal->CurrentLineIndex]) > SplitLineAtCount)\n        {\n            LineFeed(Terminal, Range.AbsoluteP, Range.AbsoluteP, Cursor->Props);\n        }\n    }\n}\n\nstatic void ParseWithUniscribe(example_terminal *Terminal, source_buffer_range UTF8Range, cursor_state *Cursor)\n{\n    /* TODO(casey): This code is absolutely horrible - Uniscribe is basically unusable as an API, because it doesn't support\n       a clean state-machine way of feeding things to it.  So I don't even know how you would really use it in a way\n       that guaranteed you didn't have buffer-too-small problems.  It's just horrible.\n\n       Plus, it is UTF16, which means we have to do an entire conversion here before we even call it :(\n\n       I would rather get rid of this function altogether and move to something that supports UTF8, because we never\n       actually want to have to do this garbage - it's just a giant hack for no reason.  Basically everything in this\n       function should be replaced by something that can turn UTF8 into chunks that need to be rasterized together.\n\n       That's all we need here, and it could be done very efficiently with sensible code.\n    */\n\n    example_partitioner *Partitioner = &Terminal->Partitioner;\n\n    DWORD Count = MultiByteToWideChar(CP_UTF8, 0, UTF8Range.Data, (DWORD)UTF8Range.Count,\n                                      Partitioner->Expansion, ArrayCount(Partitioner->Expansion));\n    wchar_t *Data = Partitioner->Expansion;\n\n    int ItemCount = 0;\n    ScriptItemize(Data, Count, ArrayCount(Partitioner->Items), &Partitioner->UniControl, &Partitioner->UniState, Partitioner->Items, &ItemCount);\n\n    int Segment = 0;\n\n    for(int ItemIndex = 0;\n        ItemIndex < ItemCount;\n        ++ItemIndex)\n    {\n        SCRIPT_ITEM *Item = Partitioner->Items + ItemIndex;\n\n        Assert((DWORD)Item->iCharPos < Count);\n        DWORD StrCount = Count - Item->iCharPos;\n        if((ItemIndex + 1) < ItemCount)\n        {\n            Assert(Item[1].iCharPos >= Item[0].iCharPos);\n            StrCount = (Item[1].iCharPos - Item[0].iCharPos);\n        }\n\n        wchar_t *Str = Data + Item->iCharPos;\n\n        int IsComplex = (ScriptIsComplex(Str, StrCount, SIC_COMPLEX) == S_OK);\n        ScriptBreak(Str, StrCount, &Item->a, Partitioner->Log);\n\n        int SegCount = 0;\n\n        Partitioner->SegP[SegCount++] = 0;\n        for(uint32_t CheckIndex = 0;\n            CheckIndex < StrCount;\n            ++CheckIndex)\n        {\n            SCRIPT_LOGATTR Attr = Partitioner->Log[CheckIndex];\n            int ShouldBreak = (Str[CheckIndex] == ' ');;\n            if(IsComplex)\n            {\n                ShouldBreak |= Attr.fSoftBreak;\n            }\n            else\n            {\n                ShouldBreak |= Attr.fCharStop;\n            }\n\n            if(ShouldBreak) Partitioner->SegP[SegCount++] = CheckIndex;\n        }\n        Partitioner->SegP[SegCount++] = StrCount;\n\n        int dSeg = 1;\n        int SegStart = 0;\n        int SegStop = SegCount - 1;\n        if(Item->a.fRTL || Item->a.fLayoutRTL)\n        {\n            dSeg = -1;\n            SegStart = SegCount - 2;\n            SegStop = -1;\n        }\n\n        for(int SegIndex = SegStart;\n            SegIndex != SegStop;\n            SegIndex += dSeg)\n        {\n            size_t Start = Partitioner->SegP[SegIndex];\n            size_t End = Partitioner->SegP[SegIndex + 1];\n            size_t ThisCount = (End - Start);\n            if(ThisCount)\n            {\n                wchar_t *Run = Str + Start;\n                wchar_t CodePoint = Run[0];\n                if((ThisCount == 1) && IsDirectCodepoint(CodePoint))\n                {\n                    renderer_cell *Cell = GetCell(&Terminal->ScreenBuffer, Cursor->At);\n                    if(Cell)\n                    {\n                        glyph_props Props = Cursor->Props;\n                        if(Terminal->DebugHighlighting)\n                        {\n                            Props.Background = 0x00800000;\n                        }\n                        SetCellDirect(Terminal->ReservedTileTable[CodePoint - MinDirectCodepoint], Props, Cell);\n                    }\n\n                    AdvanceColumn(Terminal, &Cursor->At);\n                }\n                else\n                {\n                    // TODO(casey): This wastes a lookup on the tile count.\n                    // It should save the entry somehow, and roll it into the first cell.\n\n                    int Prepped = 0;\n                    glyph_hash RunHash = ComputeGlyphHash(2*ThisCount, (char unsigned *)Run, DefaultSeed);\n                    glyph_dim GlyphDim = GetGlyphDim(&Terminal->GlyphGen, Terminal->GlyphTable, ThisCount, Run, RunHash);\n                    for(uint32_t TileIndex = 0;\n                        TileIndex < GlyphDim.TileCount;\n                        ++TileIndex)\n                    {\n                        renderer_cell *Cell = GetCell(&Terminal->ScreenBuffer, Cursor->At);\n                        if(Cell)\n                        {\n                            glyph_hash TileHash = ComputeHashForTileIndex(RunHash, TileIndex);\n                            glyph_state Entry = FindGlyphEntryByHash(Terminal->GlyphTable, TileHash);\n                            if(Entry.FilledState != GlyphState_Rasterized)\n                            {\n                                if(!Prepped)\n                                {\n                                    PrepareTilesForTransfer(&Terminal->GlyphGen, &Terminal->Renderer, ThisCount, Run, GlyphDim);\n                                    Prepped = 1;\n                                }\n\n                                TransferTile(&Terminal->GlyphGen, &Terminal->Renderer, TileIndex, Entry.GPUIndex);\n                                UpdateGlyphCacheEntry(Terminal->GlyphTable, Entry.ID, GlyphState_Rasterized, Entry.DimX, Entry.DimY);\n                            }\n\n                            glyph_props Props = Cursor->Props;\n                            if(Terminal->DebugHighlighting)\n                            {\n                                Props.Background = Segment ? 0x0008080 : 0x00000080;\n                                Segment = !Segment;\n                            }\n                            SetCellDirect(Entry.GPUIndex, Props, Cell);\n                        }\n\n                        AdvanceColumn(Terminal, &Cursor->At);\n                    }\n                }\n            }\n        }\n    }\n}\n\nstatic int ParseLineIntoGlyphs(example_terminal *Terminal, source_buffer_range Range,\n                                cursor_state *Cursor, int ContainsComplexChars)\n{\n    int CursorJumped = 0;\n\n    while(Range.Count)\n    {\n        // NOTE(casey): Eat all non-Unicode\n        char Peek = PeekToken(&Range, 0);\n        if((Peek == '\\x1b') && AtEscape(&Range))\n        {\n            if(ParseEscape(Terminal, &Range, Cursor))\n            {\n                CursorJumped = 1;\n            }\n        }\n        else if(Peek == '\\r')\n        {\n            GetToken(&Range);\n            Cursor->At.X = 0;\n        }\n        else if(Peek == '\\n')\n        {\n            GetToken(&Range);\n            AdvanceRow(Terminal, &Cursor->At);\n        }\n        else if(ContainsComplexChars)\n        {\n            /* TODO(casey): Currently, if you have a long line that force-splits, it will not\n               recombine properly with Unicode.  I _DO NOT_ think this should be fixed in\n               the line parser.  Instead, the fix should be what should happen here to begin\n               with, which is that the glyph chunking should happen in a state machine,\n               NOT using buffer runs like Uniscribe does.\n\n               So I believe the _correct_ design here is that you have a state machine instead\n               of Uniscribe for complex grapheme clusters, and _that_ will \"just work\" here\n               as well as being much much faster than the current path, which is very slow\n               because of Uniscribe _and_ is limited to intermediate buffer sizes.\n            */\n\n            // NOTE(casey): If it's not an escape, and this line contains fancy Unicode stuff,\n            // it's something we need to pass to a shaper to find out how it\n            // has to be segmented.  Which sadly is Uniscribe at this point :(\n            // Putting something actually good in here would probably be a massive improvement.\n\n            // NOTE(casey): Scan for the next escape code (which Uniscribe helpfully totally fails to handle)\n            source_buffer_range SubRange = Range;\n            do\n            {\n                Range = ConsumeCount(Range, 1);\n            } while(Range.Count &&\n                        (Range.Data[0] != '\\n') &&\n                        (Range.Data[0] != '\\r') &&\n                        (Range.Data[0] != '\\x1b'));\n\n\n            // NOTE(casey): Pass the range between the escape codes to Uniscribe\n            SubRange.Count = Range.AbsoluteP - SubRange.AbsoluteP;\n            ParseWithUniscribe(Terminal, SubRange, Cursor);\n        }\n        else\n        {\n            // NOTE(casey): It's not an escape, and we know there are only simple characters on the line.\n\n            wchar_t CodePoint = GetToken(&Range);\n            renderer_cell *Cell = GetCell(&Terminal->ScreenBuffer, Cursor->At);\n            if(Cell)\n            {\n                gpu_glyph_index GPUIndex = {0};\n                if(IsDirectCodepoint(CodePoint))\n                {\n                    GPUIndex = Terminal->ReservedTileTable[CodePoint - MinDirectCodepoint];\n                }\n                else\n                {\n                    Assert(CodePoint <= 127);\n                    glyph_hash RunHash = ComputeGlyphHash(2, (char unsigned *)&CodePoint, DefaultSeed);\n                    glyph_state Entry = FindGlyphEntryByHash(Terminal->GlyphTable, RunHash);\n                    if(Entry.FilledState != GlyphState_Rasterized)\n                    {\n                        PrepareTilesForTransfer(&Terminal->GlyphGen, &Terminal->Renderer, 1, &CodePoint, GetSingleTileUnitDim());\n                        TransferTile(&Terminal->GlyphGen, &Terminal->Renderer, 0, Entry.GPUIndex);\n                        UpdateGlyphCacheEntry(Terminal->GlyphTable, Entry.ID, GlyphState_Rasterized, Entry.DimX, Entry.DimY);\n                    }\n                    GPUIndex = Entry.GPUIndex;\n                }\n\n                SetCellDirect(GPUIndex, Cursor->Props, Cell);\n            }\n\n            AdvanceColumn(Terminal, &Cursor->At);\n        }\n    }\n\n    return CursorJumped;\n}\n\nstatic void CloseProcess(example_terminal *Terminal)\n{\n    CloseHandle(Terminal->ChildProcess);\n    CloseHandle(Terminal->Legacy_WriteStdIn);\n    CloseHandle(Terminal->Legacy_ReadStdOut);\n    CloseHandle(Terminal->Legacy_ReadStdError);\n    CloseHandle(Terminal->FastPipe);\n\n    Terminal->ChildProcess = INVALID_HANDLE_VALUE;\n    Terminal->Legacy_WriteStdIn = INVALID_HANDLE_VALUE;\n    Terminal->Legacy_ReadStdOut = INVALID_HANDLE_VALUE;\n    Terminal->Legacy_ReadStdError = INVALID_HANDLE_VALUE;\n    Terminal->FastPipe = INVALID_HANDLE_VALUE;\n}\n\nstatic void KillProcess(example_terminal *Terminal)\n{\n    if(Terminal->ChildProcess != INVALID_HANDLE_VALUE)\n    {\n        TerminateProcess(Terminal->ChildProcess, 0);\n        CloseProcess(Terminal);\n    }\n}\n\nstatic void AppendOutput(example_terminal *Terminal, char *Format, ...)\n{\n    // TODO(casey): This is all garbage code.  You need a checked printf here, and of\n    // course there isn't one of those.  Ideally this would change over to using\n    // a real concatenator here, like with a #define system, but this is just\n    // a hack for now to do basic printing from the internal code.\n\n    source_buffer_range Dest = GetNextWritableRange(&Terminal->ScrollBackBuffer, LARGEST_AVAILABLE);\n    va_list ArgList;\n    va_start(ArgList, Format);\n    int Used = wvsprintfA(Dest.Data, Format, ArgList);\n    va_end(ArgList);\n\n    Dest.Count = Used;\n    CommitWrite(&Terminal->ScrollBackBuffer, Dest.Count);\n    ParseLines(Terminal, Dest, &Terminal->RunningCursor);\n}\n\nstatic int UpdateTerminalBuffer(example_terminal *Terminal, HANDLE FromPipe)\n{\n    int Result = 0;\n\n    if(FromPipe != INVALID_HANDLE_VALUE)\n    {\n        Result = 1;\n\n        terminal_buffer *Term = &Terminal->ScreenBuffer;\n\n        DWORD PendingCount = GetPipePendingDataCount(FromPipe);\n        if(PendingCount)\n        {\n            source_buffer_range Dest = GetNextWritableRange(&Terminal->ScrollBackBuffer, PendingCount);\n\n            DWORD ReadCount = 0;\n            if(ReadFile(FromPipe, Dest.Data, (DWORD)Dest.Count, &ReadCount, 0))\n            {\n                Assert(ReadCount <= Dest.Count);\n                Dest.Count = ReadCount;\n                CommitWrite(&Terminal->ScrollBackBuffer, Dest.Count);\n                ParseLines(Terminal, Dest, &Terminal->RunningCursor);\n            }\n        }\n        else\n        {\n            DWORD Error = GetLastError();\n            if((Error == ERROR_BROKEN_PIPE) ||\n               (Error == ERROR_INVALID_HANDLE))\n            {\n                Result = 0;\n            }\n        }\n    }\n\n    return Result;\n}\n\nstatic void LayoutLines(example_terminal *Terminal)\n{\n    // TODO(casey): Probably want to do something better here - this over-clears, since we clear\n    // the whole thing and then also each line, for no real reason other than to make line wrapping\n    // simpler.\n    Clear(Terminal, &Terminal->ScreenBuffer);\n\n    //\n    // TODO(casey): This code is super bad, and there's no need for it to keep repeating itself.\n    //\n\n    // TODO(casey): How do we know how far back to go, for control chars?\n    int32_t LineCount = 2*Terminal->ScreenBuffer.DimY;\n    int32_t LineOffset = Terminal->CurrentLineIndex + Terminal->ViewingLineOffset - LineCount;\n\n    int CursorJumped = 0;\n\n    cursor_state Cursor = {0};\n    ClearCursor(Terminal, &Cursor);\n    for(int32_t LineIndexIndex = 0;\n        LineIndexIndex < LineCount;\n        ++LineIndexIndex)\n    {\n        int32_t LineIndex = (LineOffset + LineIndexIndex) % Terminal->MaxLineCount;\n        if(LineIndex < 0) LineIndex += Terminal->MaxLineCount;\n\n        example_line Line = Terminal->Lines[LineIndex];\n\n        source_buffer_range Range = ReadSourceAt(&Terminal->ScrollBackBuffer, Line.FirstP, Line.OnePastLastP - Line.FirstP);\n        Cursor.Props = Line.StartingProps;\n        if(ParseLineIntoGlyphs(Terminal, Range, &Cursor, Line.ContainsComplexChars))\n        {\n            CursorJumped = 1;\n        }\n    }\n\n    if(CursorJumped)\n    {\n        Cursor.At.X = 0;\n        Cursor.At.Y = Terminal->ScreenBuffer.DimY - 4;\n    }\n\n    AdvanceRow(Terminal, &Cursor.At);\n    ClearProps(Terminal, &Cursor.Props);\n\n#if 0\n    uint32_t CLCount = Terminal->CommandLineCount;\n\n    source_buffer_range CommandLineRange = {0};\n    CommandLineRange.AbsoluteP = 0;\n    CommandLineRange.Count = CLCount;\n    CommandLineRange.Data = (char *)Terminal->CommandLine;\n#else\n#endif\n    char Prompt[] = {'>', ' '};\n    source_buffer_range PromptRange = {0};\n    PromptRange.Count = ArrayCount(Prompt);\n    PromptRange.Data = Prompt;\n    ParseLineIntoGlyphs(Terminal, PromptRange, &Cursor, 0);\n\n    source_buffer_range CommandLineRange = {0};\n    CommandLineRange.Count = Terminal->CommandLineCount;\n    CommandLineRange.Data = Terminal->CommandLine;\n    ParseLineIntoGlyphs(Terminal, CommandLineRange, &Cursor, 1);\n\n    char CursorCode[] = {'\\x1b', '[', '5',  'm', 0xe2, 0x96, 0x88};\n    source_buffer_range CursorRange = {0};\n    CursorRange.Count = ArrayCount(CursorCode);\n    CursorRange.Data = CursorCode;\n    ParseLineIntoGlyphs(Terminal, CursorRange, &Cursor, 1);\n    AdvanceRowNoClear(Terminal, &Cursor.At);\n\n    Terminal->ScreenBuffer.FirstLineY = CursorJumped ? 0 : Cursor.At.Y;\n}\n\nstatic int ExecuteSubProcess(example_terminal *Terminal, char *ProcessName, char *ProcessCommandLine)\n{\n    if(Terminal->ChildProcess != INVALID_HANDLE_VALUE)\n    {\n        KillProcess(Terminal);\n    }\n\n    PROCESS_INFORMATION ProcessInfo = {0};\n    STARTUPINFOA StartupInfo = {sizeof(StartupInfo)};\n    StartupInfo.dwFlags = STARTF_USESTDHANDLES;\n\n    SECURITY_ATTRIBUTES Inherit = {sizeof(Inherit)};\n    Inherit.bInheritHandle = TRUE;\n\n    CreatePipe(&StartupInfo.hStdInput, &Terminal->Legacy_WriteStdIn, &Inherit, 0);\n    CreatePipe(&Terminal->Legacy_ReadStdOut, &StartupInfo.hStdOutput, &Inherit, 0);\n    CreatePipe(&Terminal->Legacy_ReadStdError, &StartupInfo.hStdError, &Inherit, 0);\n\n    SetHandleInformation(Terminal->Legacy_WriteStdIn, HANDLE_FLAG_INHERIT, 0);\n    SetHandleInformation(Terminal->Legacy_ReadStdOut, HANDLE_FLAG_INHERIT, 0);\n    SetHandleInformation(Terminal->Legacy_ReadStdError, HANDLE_FLAG_INHERIT, 0);\n\n    int Result = 0;\n\n    char *ProcessDir = \".\\\\\";\n    if(CreateProcessA(\n        ProcessName,\n        ProcessCommandLine,\n        0,\n        0,\n        TRUE,\n        CREATE_NO_WINDOW|CREATE_SUSPENDED,\n        0,\n        ProcessDir,\n        &StartupInfo,\n        &ProcessInfo))\n    {\n        if(Terminal->EnableFastPipe)\n        {\n            wchar_t PipeName[64];\n            wsprintfW(PipeName, L\"\\\\\\\\.\\\\pipe\\\\fastpipe%x\", ProcessInfo.dwProcessId);\n            Terminal->FastPipe = CreateNamedPipeW(PipeName, PIPE_ACCESS_DUPLEX|FILE_FLAG_OVERLAPPED, 0, 1,\n                                                      Terminal->PipeSize, Terminal->PipeSize, 0, 0);\n\n            // TODO(casey): Should give this its own event / overlapped\n            ConnectNamedPipe(Terminal->FastPipe, &Terminal->FastPipeTrigger);\n\n            DWORD Error = GetLastError();\n            Assert(Error == ERROR_IO_PENDING);\n        }\n\n        ResumeThread(ProcessInfo.hThread);\n        CloseHandle(ProcessInfo.hThread);\n        Terminal->ChildProcess = ProcessInfo.hProcess;\n\n        Result = 1;\n    }\n\n    CloseHandle(StartupInfo.hStdInput);\n    CloseHandle(StartupInfo.hStdOutput);\n    CloseHandle(StartupInfo.hStdError);\n\n    return Result;\n}\n\nstatic int StringsAreEqual(char *A, char *B)\n{\n    if(A && B)\n    {\n        while(*A && *B && (*A == *B))\n        {\n            ++A;\n            ++B;\n        }\n\n        return(*A == *B);\n    }\n    else\n    {\n        return(A == B);\n    }\n}\n\nstatic void\nRevertToDefaultFont(example_terminal *Terminal)\n{\n#if 0\n    wsprintfW(Terminal->RequestedFontName, L\"%s\", L\"Courier New\");\n    Terminal->RequestedFontHeight = 25;\n#else\n    wsprintfW(Terminal->RequestedFontName, L\"%s\", L\"Consolas\");\n    Terminal->RequestedFontHeight = 17;\n#endif\n}\n\nstatic int\nRefreshFont(example_terminal *Terminal)\n{\n    int Result = 0;\n\n    //\n    // NOTE(casey): Set up the mapping table between run-hashes and glyphs\n    //\n\n    glyph_table_params Params = {0};\n\n    // NOTE(casey): An additional tile is reserved for position 0, so it can be \"empty\",\n    // in case the space glyph is not actually empty.\n    Params.ReservedTileCount = ArrayCount(Terminal->ReservedTileTable) + 1;\n\n    // NOTE(casey): We have to shrink the font size until it fits in the glyph texture,\n    // to prevent large fonts from overflowing.\n    for(int Try = 0; Try <= 1; ++Try)\n    {\n        Result = SetFont(&Terminal->GlyphGen, Terminal->RequestedFontName, Terminal->RequestedFontHeight);\n        if(Result)\n        {\n            Params.CacheTileCountInX = SafeRatio1(Terminal->REFTERM_TEXTURE_WIDTH, Terminal->GlyphGen.FontWidth);\n            Params.EntryCount = GetExpectedTileCountForDimension(&Terminal->GlyphGen, Terminal->REFTERM_TEXTURE_WIDTH, Terminal->REFTERM_TEXTURE_HEIGHT);\n            Params.HashCount = 4096;\n\n            if(Params.EntryCount > Params.ReservedTileCount)\n            {\n                Params.EntryCount -= Params.ReservedTileCount;\n                break;\n            }\n        }\n\n        RevertToDefaultFont(Terminal);\n    }\n\n    // TODO(casey): In theory, this VirtualAlloc could fail, so it may be a better idea to\n    // just use a reserved memory footprint here and always use the same size.  It is not\n    // a very large amount of memory, so picking a maximum and sticking with it is probably\n    // better.  You can cap the size of the cache and there is no real penalty for doing\n    // that, since it's a cache, so it'd just be a better idea all around.\n    if(Terminal->GlyphTableMem)\n    {\n        VirtualFree(Terminal->GlyphTableMem, 0, MEM_RELEASE);\n        Terminal->GlyphTableMem = 0;\n    }\n    Terminal->GlyphTableMem = VirtualAlloc(0, GetGlyphTableFootprint(Params), MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);\n    Terminal->GlyphTable = PlaceGlyphTableInMemory(Params, Terminal->GlyphTableMem);\n\n    InitializeDirectGlyphTable(Params, Terminal->ReservedTileTable, 1);\n\n    //\n    // NOTE(casey): Pre-rasterize all the ASCII characters, since they are directly mapped rather than hash-mapped.\n    //\n\n    glyph_dim UnitDim = GetSingleTileUnitDim();\n\n    for(uint32_t TileIndex = 0;\n        TileIndex < ArrayCount(Terminal->ReservedTileTable);\n        ++TileIndex)\n    {\n        wchar_t Letter = MinDirectCodepoint + TileIndex;\n        PrepareTilesForTransfer(&Terminal->GlyphGen, &Terminal->Renderer, 1, &Letter, UnitDim);\n        TransferTile(&Terminal->GlyphGen, &Terminal->Renderer, 0, Terminal->ReservedTileTable[TileIndex]);\n    }\n\n    // NOTE(casey): Clear the reserved 0 tile\n    wchar_t Nothing = 0;\n    gpu_glyph_index ZeroTile = {0};\n    PrepareTilesForTransfer(&Terminal->GlyphGen, &Terminal->Renderer, 0, &Nothing, UnitDim);\n    TransferTile(&Terminal->GlyphGen, &Terminal->Renderer, 0, ZeroTile);\n\n    return Result;\n}\n\nstatic void ExecuteCommandLine(example_terminal *Terminal)\n{\n    // TODO(casey): All of this is complete garbage and should never ever be used.\n\n    Terminal->CommandLine[Terminal->CommandLineCount] = 0;\n    uint32_t ParamStart = 0;\n    while(ParamStart < Terminal->CommandLineCount)\n    {\n        if(Terminal->CommandLine[ParamStart] == ' ') break;\n        ++ParamStart;\n    }\n\n    char *A = Terminal->CommandLine;\n    char *B = Terminal->CommandLine + ParamStart;\n    *B = 0;\n    if(ParamStart < Terminal->CommandLineCount)\n    {\n        ++ParamStart;\n        ++B;\n    }\n\n    source_buffer_range ParamRange = {0};\n    ParamRange.Data = B;\n    ParamRange.Count = Terminal->CommandLineCount - ParamStart;\n\n    // TODO(casey): Collapse all these options into a little array, so there's no\n    // copy-pasta.\n    AppendOutput(Terminal, \"\\n\");\n    if(StringsAreEqual(Terminal->CommandLine, \"status\"))\n    {\n        ClearProps(Terminal, &Terminal->RunningCursor.Props);\n        AppendOutput(Terminal, \"RefTerm v%u\\n\", REFTERM_VERSION);\n        AppendOutput(Terminal, \"Size: %u x %u\\n\", Terminal->ScreenBuffer.DimX, Terminal->ScreenBuffer.DimY);\n        AppendOutput(Terminal, \"Fast pipe: %s\\n\", Terminal->EnableFastPipe ? \"ON\" : \"off\");\n        AppendOutput(Terminal, \"Font: %S %u\\n\", Terminal->RequestedFontName, Terminal->RequestedFontHeight);\n        AppendOutput(Terminal, \"Line Wrap: %s\\n\", Terminal->LineWrap ? \"ON\" : \"off\");\n        AppendOutput(Terminal, \"Debug: %s\\n\", Terminal->DebugHighlighting ? \"ON\" : \"off\");\n        AppendOutput(Terminal, \"Throttling: %s\\n\", !Terminal->NoThrottle ? \"ON\" : \"off\");\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"fastpipe\"))\n    {\n        Terminal->EnableFastPipe = !Terminal->EnableFastPipe;\n        AppendOutput(Terminal, \"Fast pipe: %s\\n\", Terminal->EnableFastPipe ? \"ON\" : \"off\");\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"linewrap\"))\n    {\n        Terminal->LineWrap = !Terminal->LineWrap;\n        AppendOutput(Terminal, \"LineWrap: %s\\n\", Terminal->LineWrap ? \"ON\" : \"off\");\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"debug\"))\n    {\n        Terminal->DebugHighlighting = !Terminal->DebugHighlighting;\n        AppendOutput(Terminal, \"Debug: %s\\n\", Terminal->DebugHighlighting ? \"ON\" : \"off\");\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"throttle\"))\n    {\n        Terminal->NoThrottle = !Terminal->NoThrottle;\n        AppendOutput(Terminal, \"Throttling: %s\\n\", !Terminal->NoThrottle ? \"ON\" : \"off\");\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"font\"))\n    {\n        DWORD NullAt = MultiByteToWideChar(CP_UTF8, 0, B, (DWORD)(Terminal->CommandLineCount - ParamStart),\n                                           Terminal->RequestedFontName, ArrayCount(Terminal->RequestedFontName) - 1);\n        Terminal->RequestedFontName[NullAt] = 0;\n\n        RefreshFont(Terminal);\n        AppendOutput(Terminal, \"Font: %S\\n\", Terminal->RequestedFontName);\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"fontsize\"))\n    {\n        Terminal->RequestedFontHeight = ParseNumber(&ParamRange);\n        RefreshFont(Terminal);\n        AppendOutput(Terminal, \"Font height: %u\\n\", Terminal->RequestedFontHeight);\n    }\n    else if((StringsAreEqual(Terminal->CommandLine, \"kill\")) ||\n            (StringsAreEqual(Terminal->CommandLine, \"break\")))\n    {\n        KillProcess(Terminal);\n    }\n    else if((StringsAreEqual(Terminal->CommandLine, \"clear\")) ||\n            (StringsAreEqual(Terminal->CommandLine, \"cls\")))\n    {\n        ClearCursor(Terminal, &Terminal->RunningCursor);\n        memset(Terminal->Lines, 0, Terminal->MaxLineCount*sizeof(example_line));\n    }\n    else if((StringsAreEqual(Terminal->CommandLine, \"exit\")) ||\n            (StringsAreEqual(Terminal->CommandLine, \"quit\")))\n    {\n        KillProcess(Terminal);\n        AppendOutput(Terminal, \"Exiting...\\n\");\n        Terminal->Quit = 1;\n    }\n    else if((StringsAreEqual(Terminal->CommandLine, \"echo\")) ||\n            (StringsAreEqual(Terminal->CommandLine, \"print\")))\n    {\n        AppendOutput(Terminal, \"%s\\n\", B);\n    }\n    else if(StringsAreEqual(Terminal->CommandLine, \"\"))\n    {\n    }\n    else\n    {\n        char ProcessName[ArrayCount(Terminal->CommandLine) + 1];\n        char ProcessCommandLine[ArrayCount(Terminal->CommandLine) + 1];\n        wsprintfA(ProcessName, \"%s.exe\", A);\n        wsprintfA(ProcessCommandLine, \"%s.exe %s\", A, B);\n        if(!ExecuteSubProcess(Terminal, ProcessName, ProcessCommandLine))\n        {\n            wsprintfA(ProcessName, \"c:\\\\Windows\\\\System32\\\\cmd.exe\");\n            wsprintfA(ProcessCommandLine, \"cmd.exe /c %s.exe %s\", A, B);\n            if(!ExecuteSubProcess(Terminal, ProcessName, ProcessCommandLine))\n            {\n                AppendOutput(Terminal, \"ERROR: Unable to execute %s\\n\", Terminal->CommandLine);\n            }\n        }\n    }\n}\n\nstatic int IsUTF8Extension(char A)\n{\n    int Result = ((A & 0xc0) == 0x80);\n    return Result;\n}\n\nstatic void ProcessMessages(example_terminal *Terminal)\n{\n    MSG Message;\n    while(PeekMessage(&Message, 0, 0, 0, PM_REMOVE))\n    {\n        switch(Message.message)\n        {\n            case WM_QUIT:\n            {\n                Terminal->Quit = 1;\n            } break;\n\n            case WM_KEYDOWN:\n            {\n                switch(Message.wParam)\n                {\n                    case VK_PRIOR:\n                    {\n                        Terminal->ViewingLineOffset -= Terminal->ScreenBuffer.DimY/2;\n                    } break;\n\n                    case VK_NEXT:\n                    {\n                        Terminal->ViewingLineOffset += Terminal->ScreenBuffer.DimY/2;\n                    } break;\n                }\n\n                if(Terminal->ViewingLineOffset > 0)\n                {\n                    Terminal->ViewingLineOffset = 0;\n                }\n\n                if(Terminal->ViewingLineOffset < -(int)Terminal->LineCount)\n                {\n                    Terminal->ViewingLineOffset = -(int)Terminal->LineCount;\n                }\n            } break;\n\n            case WM_CHAR:\n            {\n                switch(Message.wParam)\n                {\n                    case VK_BACK:\n                    {\n                        while((Terminal->CommandLineCount > 0) &&\n                              IsUTF8Extension(Terminal->CommandLine[Terminal->CommandLineCount - 1]))\n                        {\n                            --Terminal->CommandLineCount;\n                        }\n\n                        if(Terminal->CommandLineCount > 0)\n                        {\n                            --Terminal->CommandLineCount;\n                        }\n                    } break;\n\n                    case VK_RETURN:\n                    {\n                        ExecuteCommandLine(Terminal);\n                        Terminal->CommandLineCount = 0;\n                        Terminal->ViewingLineOffset = 0;\n                    } break;\n\n                    default:\n                    {\n                        wchar_t Char = (wchar_t)Message.wParam;\n                        wchar_t Chars[2];\n                        int CharCount = 0;\n\n                        if(IS_HIGH_SURROGATE(Char))\n                        {\n                            Terminal->LastChar = Char;\n                        }\n                        else if(IS_LOW_SURROGATE(Char))\n                        {\n                            if(IS_SURROGATE_PAIR(Terminal->LastChar, Char))\n                            {\n                                Chars[0] = Terminal->LastChar;\n                                Chars[1] = Char;\n                                CharCount = 2;\n                            }\n                            Terminal->LastChar = 0;\n                        }\n                        else\n                        {\n                            Chars[0] = Char;\n                            CharCount = 1;\n                        }\n\n                        if(CharCount)\n                        {\n                            DWORD SpaceLeft = ArrayCount(Terminal->CommandLine) - Terminal->CommandLineCount;\n                            Terminal->CommandLineCount +=\n                                WideCharToMultiByte(CP_UTF8, 0,\n                                                    Chars, CharCount,\n                                                    Terminal->CommandLine + Terminal->CommandLineCount,\n                                                    SpaceLeft, 0, 0);\n                        }\n                    } break;\n                }\n            } break;\n        }\n    }\n}\n\nstatic char OpeningMessage[] = { 0xE0, 0xA4, 0x9C, 0xE0, 0xA5, 0x8B, 0x20, 0xE0, 0xA4, 0xB8, 0xE0, 0xA5, 0x8B, 0x20, 0xE0, 0xA4, 0xB0, 0xE0, 0xA4, 0xB9, 0xE0, 0xA4, 0xBE, 0x20, 0xE0, 0xA4, 0xB9, 0xE0, 0xA5, 0x8B, 0x20, 0xE0, 0xA4, 0x89, 0xE0, 0xA4, 0xB8, 0xE0, 0xA5, 0x87, 0x20, 0xE0, 0xA4, 0xA4, 0xE0, 0xA5, 0x8B, 0x20, 0xE0, 0xA4, 0x9C, 0xE0, 0xA4, 0x97, 0xE0, 0xA4, 0xBE, 0x20, 0xE0, 0xA4, 0xB8, 0xE0, 0xA4, 0x95, 0xE0, 0xA4, 0xA4, 0xE0, 0xA5, 0x87, 0x20, 0xE0, 0xA4, 0xB9, 0xE0, 0xA5, 0x88, 0xE0, 0xA4, 0x82, 0x2C, 0x20, 0xE0, 0xA4, 0xB2, 0xE0, 0xA5, 0x87, 0xE0, 0xA4, 0x95, 0xE0, 0xA4, 0xBF, 0xE0, 0xA4, 0xA8, 0x20, 0xE0, 0xA4, 0x9C, 0xE0, 0xA5, 0x8B, 0x20, 0xE0, 0xA4, 0x86, 0xE0, 0xA4, 0x81, 0xE0, 0xA4, 0x96, 0xE0, 0xA5, 0x87, 0x20, 0xE0, 0xA4, 0xAE, 0xE0, 0xA5, 0x82, 0xE0, 0xA4, 0x81, 0xE0, 0xA4, 0xA6, 0x20, 0xE0, 0xA4, 0x95, 0xE0, 0xA4, 0xB0, 0x20, 0xE0, 0xA4, 0xB8, 0xE0, 0xA5, 0x8B, 0xE0, 0xA4, 0xA8, 0xE0, 0xA5, 0x87, 0x20, 0xE0, 0xA4, 0x95, 0xE0, 0xA4, 0xBE, 0x20, 0xE0, 0xA4, 0x85, 0xE0, 0xA4, 0xAD, 0xE0, 0xA4, 0xBF, 0xE0, 0xA4, 0xA8, 0xE0, 0xA4, 0xAF, 0x20, 0xE0, 0xA4, 0x95, 0xE0, 0xA4, 0xB0, 0x20, 0xE0, 0xA4, 0xB0, 0xE0, 0xA4, 0xB9, 0xE0, 0xA4, 0xBE, 0x20, 0xE0, 0xA4, 0xB9, 0xE0, 0xA5, 0x8B, 0x20, 0xE0, 0xA4, 0x89, 0xE0, 0xA4, 0xB8, 0xE0, 0xA5, 0x87, 0x20, 0xE0, 0xA4, 0x95, 0xE0, 0xA5, 0x88, 0xE0, 0xA4, 0xB8, 0xE0, 0xA5, 0x87, 0x20, 0xE0, 0xA4, 0x9C, 0xE0, 0xA4, 0x97, 0xE0, 0xA4, 0xBE, 0xE0, 0xA4, 0x8F, 0xE0, 0xA4, 0x82, 0xE0, 0xA4, 0x97, 0xE0, 0xA5, 0x87, 0x20, 0x7C, 0x20, '\\n' };\nstatic DWORD WINAPI TerminalThread(LPVOID Param)\n{\n    example_terminal *Terminal = VirtualAlloc(0, sizeof(example_terminal), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);\n    Terminal->Window = (HWND)Param;\n    Terminal->LineWrap = 1;\n    Terminal->ChildProcess = INVALID_HANDLE_VALUE;\n    Terminal->Legacy_WriteStdIn = INVALID_HANDLE_VALUE;\n    Terminal->Legacy_ReadStdOut = INVALID_HANDLE_VALUE;\n    Terminal->Legacy_ReadStdError = INVALID_HANDLE_VALUE;\n    Terminal->FastPipe = INVALID_HANDLE_VALUE;\n    Terminal->DefaultForegroundColor = 0x00afafaf;\n    Terminal->DefaultBackgroundColor = 0x000c0c0c;\n    Terminal->FastPipeReady = CreateEventW(0, TRUE, FALSE, 0);\n    Terminal->FastPipeTrigger.hEvent = Terminal->FastPipeReady;\n    Terminal->PipeSize = 16*1024*1024;\n\n    ClearCursor(Terminal, &Terminal->RunningCursor);\n\n    // TODO(casey): I believe this should probably be sized to be the same\n    // as the window at a minimum, because if it isn't, you may run into\n    // pathological cases where the wrong glyph is rendered.  The alternative\n    // would be forcing flushes of the pipe when the total number of recycles\n    // in a frame reaches the total number of glyphs in the cache.  Since the\n    // basically never happens, you don't see any bugs with it, but it\n    // theoretically _could_ happen if the texture size isn't large enough\n    // to fit one whole screen of glyphs.\n    Terminal->REFTERM_TEXTURE_WIDTH = 2048;\n    Terminal->REFTERM_TEXTURE_HEIGHT = 2048;\n\n    // TODO(casey): Auto-size this, somehow?  The TransferHeight effectively restricts the maximum size of the\n    // font, so it may want to be \"grown\" based on the font size selected.\n    Terminal->TransferWidth = 1024;\n    Terminal->TransferHeight = 512;\n\n    Terminal->REFTERM_MAX_WIDTH = 1024;\n    Terminal->REFTERM_MAX_HEIGHT = 1024;\n\n    int DebugD3D11 = 0;\n#if _DEBUG\n    DebugD3D11 = 1;\n#endif\n\n    Terminal->Renderer = AcquireD3D11Renderer(Terminal->Window, DebugD3D11);\n    SetD3D11GlyphCacheDim(&Terminal->Renderer, Terminal->REFTERM_TEXTURE_WIDTH, Terminal->REFTERM_TEXTURE_HEIGHT);\n    SetD3D11GlyphTransferDim(&Terminal->Renderer, Terminal->TransferWidth, Terminal->TransferHeight);\n\n    Terminal->GlyphGen = AllocateGlyphGenerator(Terminal->TransferWidth, Terminal->TransferHeight, Terminal->Renderer.GlyphTransferSurface);\n    Terminal->ScrollBackBuffer = AllocateSourceBuffer(Terminal->PipeSize);\n\n    ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &Terminal->Partitioner.UniDigiSub); // TODO(casey): Move this out to the stored code\n    ScriptApplyDigitSubstitution(&Terminal->Partitioner.UniDigiSub, &Terminal->Partitioner.UniControl, &Terminal->Partitioner.UniState);\n\n    Terminal->MaxLineCount = 8192;\n    Terminal->Lines = VirtualAlloc(0, Terminal->MaxLineCount*sizeof(example_line), MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);\n\n    RevertToDefaultFont(Terminal);\n    RefreshFont(Terminal);\n\n    ShowWindow(Terminal->Window, SW_SHOWDEFAULT);\n\n    AppendOutput(Terminal, \"\\n\"); // TODO(casey): Better line startup - this is here just to initialize the running cursor.\n    AppendOutput(Terminal, \"Refterm v%u\\n\", REFTERM_VERSION);\n    AppendOutput(Terminal,\n                     \"THIS IS \\x1b[38;2;255;0;0m\\x1b[5mNOT\\x1b[0m A REAL \\x1b[9mTERMINAL\\x1b[0m.\\r\\n\"\n                     \"It is a reference renderer for demonstrating how to easily build relatively efficient terminal displays.\\r\\n\"\n                     \"\\x1b[38;2;255;0;0m\\x1b[5m\\x1b[4mDO NOT\\x1b[0m attempt to use this as your terminal, or you will be \\x1b[2mvery\\x1b[0m sad.\\r\\n\"\n                 );\n\n    AppendOutput(Terminal, \"\\n\");\n    AppendOutput(Terminal, OpeningMessage);\n    AppendOutput(Terminal, \"\\n\");\n    \n    int BlinkMS = 500; // TODO(casey): Use this in blink determination\n    int MinTermSize = 512;\n    uint32_t Width = MinTermSize;\n    uint32_t Height = MinTermSize;\n\n    LARGE_INTEGER Frequency, Time;\n    QueryPerformanceFrequency(&Frequency);\n    QueryPerformanceCounter(&Time);\n\n    LARGE_INTEGER StartTime;\n    QueryPerformanceCounter(&StartTime);\n\n    size_t FrameCount = 0;\n    size_t FrameIndex = 0;\n    int64_t UpdateTitle = Time.QuadPart + Frequency.QuadPart;\n\n    wchar_t LastChar = 0;\n\n    while(!Terminal->Quit)\n    {\n        if(!Terminal->NoThrottle)\n        {\n            HANDLE Handles[8];\n            DWORD HandleCount = 0;\n\n            Handles[HandleCount++] = Terminal->FastPipeReady;\n            if(Terminal->Legacy_ReadStdOut != INVALID_HANDLE_VALUE) Handles[HandleCount++] = Terminal->Legacy_ReadStdOut;\n            if(Terminal->Legacy_ReadStdError != INVALID_HANDLE_VALUE) Handles[HandleCount++] = Terminal->Legacy_ReadStdError;\n            MsgWaitForMultipleObjects(HandleCount, Handles, FALSE, BlinkMS, QS_ALLINPUT);\n        }\n\n        ProcessMessages(Terminal);\n\n        RECT Rect;\n        GetClientRect(Terminal->Window, &Rect);\n\n        if(((Rect.left + MinTermSize) <= Rect.right) &&\n           ((Rect.top + MinTermSize) <= Rect.bottom))\n        {\n            Width = Rect.right - Rect.left;\n            Height = Rect.bottom - Rect.top;\n\n            uint32_t Margin = 8;\n            uint32_t NewDimX = SafeRatio1(Width - Margin, Terminal->GlyphGen.FontWidth);\n            uint32_t NewDimY = SafeRatio1(Height - Margin, Terminal->GlyphGen.FontHeight);\n            if(NewDimX > Terminal->REFTERM_MAX_WIDTH) NewDimX = Terminal->REFTERM_MAX_WIDTH;\n            if(NewDimY > Terminal->REFTERM_MAX_HEIGHT) NewDimY = Terminal->REFTERM_MAX_HEIGHT;\n\n            // TODO(casey): Maybe only allocate on size differences,\n            // etc. Make a real resize function here for people who care.\n            if((Terminal->ScreenBuffer.DimX != NewDimX) ||\n               (Terminal->ScreenBuffer.DimY != NewDimY))\n            {\n                DeallocateTerminalBuffer(&Terminal->ScreenBuffer);\n                Terminal->ScreenBuffer = AllocateTerminalBuffer(NewDimX, NewDimY);\n            }\n        }\n\n        do\n        {\n            int FastIn = UpdateTerminalBuffer(Terminal, Terminal->FastPipe);\n            int SlowIn = UpdateTerminalBuffer(Terminal, Terminal->Legacy_ReadStdOut);\n            int ErrIn = UpdateTerminalBuffer(Terminal, Terminal->Legacy_ReadStdError);\n\n            if(!SlowIn && (Terminal->Legacy_ReadStdOut != INVALID_HANDLE_VALUE))\n            {\n                CloseHandle(Terminal->Legacy_ReadStdOut); // TODO(casey): Not sure if this is supposed to be called?\n                Terminal->Legacy_ReadStdOut = INVALID_HANDLE_VALUE;\n            }\n\n            if(!ErrIn && (Terminal->Legacy_ReadStdError != INVALID_HANDLE_VALUE))\n            {\n                CloseHandle(Terminal->Legacy_ReadStdError); // TODO(casey): Not sure if this is supposed to be called?\n                Terminal->Legacy_ReadStdError = INVALID_HANDLE_VALUE;\n            }\n        }\n        while((Terminal->Renderer.FrameLatencyWaitableObject != INVALID_HANDLE_VALUE) &&\n                  (WaitForSingleObject(Terminal->Renderer.FrameLatencyWaitableObject, 0) == WAIT_TIMEOUT));\n\n        ResetEvent(Terminal->FastPipeReady);\n        ReadFile(Terminal->FastPipe, 0, 0, 0, &Terminal->FastPipeTrigger);\n\n        LayoutLines(Terminal);\n\n        // TODO(casey): Split RendererDraw into two!\n        // Update, and render, since we only need to update if we actually get new input.\n\n        LARGE_INTEGER BlinkTimer;\n        QueryPerformanceCounter(&BlinkTimer);\n        int Blink = ((1000*(BlinkTimer.QuadPart - StartTime.QuadPart) / (BlinkMS*Frequency.QuadPart)) & 1);\n        if(!Terminal->Renderer.Device)\n        {\n            Terminal->Renderer = AcquireD3D11Renderer(Terminal->Window, 0);\n            RefreshFont(Terminal);\n        }\n        if(Terminal->Renderer.Device)\n        {\n            RendererDraw(Terminal, Width, Height, &Terminal->ScreenBuffer, Blink ? 0xffffffff : 0xff222222);\n        }\n        ++FrameIndex;\n        ++FrameCount;\n\n        LARGE_INTEGER Now;\n        QueryPerformanceCounter(&Now);\n\n        if (Now.QuadPart >= UpdateTitle)\n        {\n            UpdateTitle = Now.QuadPart + Frequency.QuadPart;\n\n            double FramesPerSec = (double)FrameCount * Frequency.QuadPart / (Now.QuadPart - Time.QuadPart);\n            Time = Now;\n            FrameCount = 0;\n\n            WCHAR Title[1024];\n\n            if(Terminal->NoThrottle)\n            {\n                glyph_table_stats Stats = GetAndClearStats(Terminal->GlyphTable);\n                wsprintfW(Title, L\"refterm Size=%dx%d RenderFPS=%d.%02d CacheHits/Misses=%d/%d Recycle:%d\",\n                              Terminal->ScreenBuffer.DimX, Terminal->ScreenBuffer.DimY, (int)FramesPerSec, (int)(FramesPerSec*100) % 100,\n                              (int)Stats.HitCount, (int)Stats.MissCount, (int)Stats.RecycleCount);\n            }\n            else\n            {\n                wsprintfW(Title, L\"refterm\");\n            }\n\n            SetWindowTextW(Terminal->Window, Title);\n        }\n    }\n\n    DWriteRelease(&Terminal->GlyphGen);\n    ReleaseD3D11Renderer(&Terminal->Renderer);\n\n    // TODO(casey): How do we actually do an ensured-kill here?  Like even if we crash?  Is there some kind\n    // of process parameter we can pass to CreateProcess that will ensure it is killed?  Because this won't.\n    KillProcess(Terminal);\n\n    ExitProcess(0);\n}\n"
        },
        {
          "name": "refterm_example_terminal.h",
          "type": "blob",
          "size": 2.4150390625,
          "content": "enum\n{\n    TerminalCell_Bold = 0x1,\n    TerminalCell_Dim = 0x2,\n    TerminalCell_Italic = 0x4,\n    TerminalCell_Underline = 0x8,\n    TerminalCell_Blinking = 0x10,\n    TerminalCell_ReverseVideo = 0x20,\n    TerminalCell_Invisible = 0x40,\n    TerminalCell_Strikethrough = 0x80,\n};\n\ntypedef struct\n{\n    renderer_cell *Cells;\n    uint32_t DimX, DimY;\n    uint32_t FirstLineY;\n} terminal_buffer;\n\ntypedef struct\n{\n    int32_t X, Y;\n} terminal_point;\n\ntypedef struct\n{\n    uint32_t Foreground;\n    uint32_t Background;\n    uint32_t Flags;\n} glyph_props;\n\ntypedef struct\n{\n    terminal_point At;\n    glyph_props Props;\n} cursor_state;\n\ntypedef struct\n{\n    // TODO(casey): Get rid of Uniscribe so this garbage doesn't have to happen\n\n    SCRIPT_DIGITSUBSTITUTE UniDigiSub;\n    SCRIPT_CONTROL UniControl;\n    SCRIPT_STATE UniState;\n    SCRIPT_CACHE UniCache;\n\n    wchar_t Expansion[1024];\n    SCRIPT_ITEM Items[1024];\n    SCRIPT_LOGATTR Log[1024];\n    DWORD SegP[1026];\n} example_partitioner;\n\ntypedef struct\n{\n    size_t FirstP;\n    size_t OnePastLastP;\n    uint32_t ContainsComplexChars;\n    glyph_props StartingProps;\n} example_line;\n\ntypedef struct\n{\n    HWND Window;\n    int Quit;\n\n    d3d11_renderer Renderer;\n    glyph_generator GlyphGen;\n    void *GlyphTableMem;\n    glyph_table *GlyphTable;\n    terminal_buffer ScreenBuffer;\n    source_buffer ScrollBackBuffer;\n    example_partitioner Partitioner;\n\n    DWORD PipeSize;\n\n    HANDLE Legacy_WriteStdIn;\n    HANDLE Legacy_ReadStdOut;\n    HANDLE Legacy_ReadStdError;\n\n    int EnableFastPipe;\n    HANDLE FastPipeReady;\n    HANDLE FastPipe;\n    OVERLAPPED FastPipeTrigger;\n\n    HANDLE ChildProcess;\n\n    cursor_state RunningCursor;\n\n    wchar_t LastChar;\n    uint32_t CommandLineCount;\n    char CommandLine[256];\n\n    int NoThrottle;\n    int DebugHighlighting;\n\n    uint32_t MaxLineCount;\n    uint32_t CurrentLineIndex;\n    uint32_t LineCount;\n    example_line *Lines;\n\n    int32_t ViewingLineOffset;\n\n    wchar_t RequestedFontName[64];\n    uint32_t RequestedFontHeight;\n    int LineWrap;\n\n    uint32_t DefaultForegroundColor;\n    uint32_t DefaultBackgroundColor;\n\n    uint32_t REFTERM_TEXTURE_WIDTH;\n    uint32_t REFTERM_TEXTURE_HEIGHT;\n\n    uint32_t TransferWidth;\n    uint32_t TransferHeight;\n\n    uint32_t REFTERM_MAX_WIDTH;\n    uint32_t REFTERM_MAX_HEIGHT;\n\n#define MinDirectCodepoint 32\n#define MaxDirectCodepoint 126\n    gpu_glyph_index ReservedTileTable[MaxDirectCodepoint - MinDirectCodepoint + 1];\n} example_terminal;\n\n"
        },
        {
          "name": "refterm_glyph_cache.c",
          "type": "blob",
          "size": 9.66015625,
          "content": "#ifndef Assert\n#define Assert(...)\n#define GLYPH_TABLE_UNDEF_ASSERT\n#endif\n\n#define DEBUG_VALIDATE_LRU 0\n\nstruct glyph_entry\n{\n    glyph_hash HashValue;\n\n    uint32_t NextWithSameHash;\n    uint32_t NextLRU;\n    uint32_t PrevLRU;\n    gpu_glyph_index GPUIndex;\n\n    // NOTE(casey): For user use:\n    uint32_t FilledState;\n    uint16_t DimX;\n    uint16_t DimY;\n    \n#if DEBUG_VALIDATE_LRU\n    size_t Ordering;\n#endif\n};\n\nstruct glyph_table\n{\n    glyph_table_stats Stats;\n\n    uint32_t HashMask;\n    uint32_t HashCount;\n    uint32_t EntryCount;\n\n    uint32_t *HashTable;\n    glyph_entry *Entries;\n\n#if DEBUG_VALIDATE_LRU\n    uint32_t LastLRUCount;\n#endif\n};\n\nstatic gpu_glyph_index PackGlyphCachePoint(uint32_t X, uint32_t Y)\n{\n    gpu_glyph_index Result = {(Y << 16) | X};\n    return Result;\n}\n\nstatic glyph_cache_point UnpackGlyphCachePoint(gpu_glyph_index P)\n{\n    glyph_cache_point Result;\n\n    Result.X = (P.Value & 0xffff);\n    Result.Y = (P.Value >> 16);\n\n    return Result;\n}\n\nstatic int GlyphHashesAreEqual(glyph_hash A, glyph_hash B)\n{\n    __m128i Compare = _mm_cmpeq_epi32(A.Value, B.Value);\n    int Result = (_mm_movemask_epi8(Compare) == 0xffff);\n\n    return Result;\n}\n\nstatic uint32_t *GetSlotPointer(glyph_table *Table, glyph_hash RunHash)\n{\n    uint32_t HashIndex = _mm_cvtsi128_si32(RunHash.Value);\n    uint32_t HashSlot = (HashIndex & Table->HashMask);\n\n    Assert(HashSlot < Table->HashCount);\n    uint32_t *Result = &Table->HashTable[HashSlot];\n\n    return Result;\n}\n\nstatic glyph_entry *GetEntry(glyph_table *Table, uint32_t Index)\n{\n    Assert(Index < Table->EntryCount);\n    glyph_entry *Result = Table->Entries + Index;\n    return Result;\n}\n\nstatic glyph_entry *GetSentinel(glyph_table *Table)\n{\n    glyph_entry *Result = Table->Entries;\n    return Result;\n}\n\nstatic glyph_table_stats GetAndClearStats(glyph_table *Table)\n{\n    glyph_table_stats Result = Table->Stats;\n    glyph_table_stats ZeroStats = {0};\n    Table->Stats = ZeroStats;\n\n    return Result;\n}\n\nstatic void UpdateGlyphCacheEntry(glyph_table *Table, uint32_t ID, uint32_t NewState, uint16_t NewDimX, uint16_t NewDimY)\n{\n    glyph_entry *Entry = GetEntry(Table, ID);\n\n    Entry->FilledState = NewState;\n    Entry->DimX = NewDimX;\n    Entry->DimY = NewDimY;\n}\n\n#if DEBUG_VALIDATE_LRU\nstatic void ValidateLRU(glyph_table *Table, int ExpectedCountChange)\n{\n    uint32_t EntryCount = 0;\n\n    glyph_entry *Sentinel = GetSentinel(Table);\n    size_t LastOrdering = Sentinel->Ordering;\n    for(uint32_t EntryIndex = Sentinel->NextLRU;\n        EntryIndex != 0;\n        )\n    {\n        glyph_entry *Entry = GetEntry(Table, EntryIndex);\n        Assert(Entry->Ordering < LastOrdering);\n        LastOrdering = Entry->Ordering;\n        EntryIndex = Entry->NextLRU;\n        ++EntryCount;\n    }\n\n    if((Table->LastLRUCount + ExpectedCountChange) != EntryCount)\n    {\n        __debugbreak();\n    }\n    Table->LastLRUCount = EntryCount;\n}\n#else\n#define ValidateLRU(...)\n#endif\n\nstatic void RecycleLRU(glyph_table *Table)\n{\n    glyph_entry *Sentinel = GetSentinel(Table);\n\n    // NOTE(casey): There are no more unused entries, evict the least recently used one\n    Assert(Sentinel->PrevLRU);\n\n    // NOTE(casey): Remove least recently used element from the LRU chain\n    uint32_t EntryIndex = Sentinel->PrevLRU;\n    glyph_entry *Entry = GetEntry(Table, EntryIndex);\n    glyph_entry *Prev = GetEntry(Table, Entry->PrevLRU);\n    Prev->NextLRU = 0;\n    Sentinel->PrevLRU = Entry->PrevLRU;\n    ValidateLRU(Table, -1);\n\n    // NOTE(casey): Find the location of this entry in its hash chain\n    uint32_t *NextIndex = GetSlotPointer(Table, Entry->HashValue);\n    while(*NextIndex != EntryIndex)\n    {\n        Assert(*NextIndex);\n        NextIndex = &GetEntry(Table, *NextIndex)->NextWithSameHash;\n    }\n\n    // NOTE(casey): Remove least recently used element from its hash chain, and place it on the free chain\n    Assert(*NextIndex == EntryIndex);\n    *NextIndex = Entry->NextWithSameHash;\n    Entry->NextWithSameHash = Sentinel->NextWithSameHash;\n    Sentinel->NextWithSameHash = EntryIndex;\n\n    // NOTE(casey): Clear the index count and state\n    UpdateGlyphCacheEntry(Table, EntryIndex, 0, 0, 0);\n\n    ++Table->Stats.RecycleCount;\n}\n\nstatic uint32_t PopFreeEntry(glyph_table *Table)\n{\n    glyph_entry *Sentinel = GetSentinel(Table);\n\n    if(!Sentinel->NextWithSameHash)\n    {\n        RecycleLRU(Table);\n    }\n\n    uint32_t Result = Sentinel->NextWithSameHash;\n    Assert(Result);\n\n    // NOTE(casey): Pop this unused entry off the sentinel's chain of unused entries\n    glyph_entry *Entry = GetEntry(Table, Result);\n    Sentinel->NextWithSameHash = Entry->NextWithSameHash;\n    Entry->NextWithSameHash = 0;\n\n    Assert(Entry);\n    Assert(Entry != Sentinel);\n    Assert(Entry->DimX == 0);\n    Assert(Entry->DimY == 0);\n    Assert(Entry->FilledState == 0);\n    Assert(Entry->NextWithSameHash == 0);\n    Assert(Entry == GetEntry(Table, Result));\n\n    return Result;\n}\n\nstatic glyph_state FindGlyphEntryByHash(glyph_table *Table, glyph_hash RunHash)\n{\n    glyph_entry *Result = 0;\n\n    uint32_t *Slot = GetSlotPointer(Table, RunHash);\n    uint32_t EntryIndex = *Slot;\n    while(EntryIndex)\n    {\n        glyph_entry *Entry = GetEntry(Table, EntryIndex);\n        if(GlyphHashesAreEqual(Entry->HashValue, RunHash))\n        {\n            Result = Entry;\n            break;\n        }\n\n        EntryIndex = Entry->NextWithSameHash;\n    }\n\n    if(Result)\n    {\n        Assert(EntryIndex);\n\n        // NOTE(casey): An existing entry was found, remove it from the LRU\n        glyph_entry *Prev = GetEntry(Table, Result->PrevLRU);\n        glyph_entry *Next = GetEntry(Table, Result->NextLRU);\n\n        Prev->NextLRU = Result->NextLRU;\n        Next->PrevLRU = Result->PrevLRU;\n\n        ValidateLRU(Table, -1);\n\n        ++Table->Stats.HitCount;\n    }\n    else\n    {\n        // NOTE(casey): No existing entry was found, allocate a new one and link it into the hash chain\n\n        EntryIndex = PopFreeEntry(Table);\n        Assert(EntryIndex);\n\n        Result = GetEntry(Table, EntryIndex);\n        Assert(Result->FilledState == 0);\n        Assert(Result->NextWithSameHash == 0);\n        Assert(Result->DimX == 0);\n        Assert(Result->DimY == 0);\n        \n        Result->NextWithSameHash = *Slot;\n        Result->HashValue = RunHash;\n        *Slot = EntryIndex;\n\n        ++Table->Stats.MissCount;\n    }\n\n    // NOTE(casey): Update the LRU doubly-linked list to ensure this entry is now \"first\"\n    glyph_entry *Sentinel = GetSentinel(Table);\n    Assert(Result != Sentinel);\n    Result->NextLRU = Sentinel->NextLRU;\n    Result->PrevLRU = 0;\n\n    glyph_entry *NextLRU = GetEntry(Table, Sentinel->NextLRU);\n    NextLRU->PrevLRU = EntryIndex;\n    Sentinel->NextLRU = EntryIndex;\n\n#if DEBUG_VALIDATE_LRU\n    Result->Ordering = Sentinel->Ordering++;\n#endif\n    ValidateLRU(Table, 1);\n\n    glyph_state State;\n    State.ID = EntryIndex;\n    State.DimX = Result->DimX;\n    State.DimY = Result->DimY;\n    State.GPUIndex = Result->GPUIndex;\n    State.FilledState = Result->FilledState;\n\n    return State;\n}\n\nstatic void InitializeDirectGlyphTable(glyph_table_params Params, gpu_glyph_index *Table, int SkipZeroSlot)\n{\n    Assert(Params.CacheTileCountInX >= 1);\n    \n    if(SkipZeroSlot)\n    {\n        SkipZeroSlot = 1;\n    }\n        \n    uint32_t X = SkipZeroSlot;\n    uint32_t Y = 0;\n    for(uint32_t EntryIndex = 0;\n        EntryIndex < (Params.ReservedTileCount - SkipZeroSlot);\n        ++EntryIndex)\n    {\n        if(X >= Params.CacheTileCountInX)\n        {\n            X = 0;\n            ++Y;\n        }\n\n        Table[EntryIndex] = PackGlyphCachePoint(X, Y);\n\n        ++X;\n    }\n}\n\nstatic size_t GetGlyphTableFootprint(glyph_table_params Params)\n{\n    size_t HashSize = Params.HashCount*sizeof(uint32_t);\n    size_t EntrySize = Params.EntryCount*sizeof(glyph_entry);\n    size_t Result = (sizeof(glyph_table) + HashSize + EntrySize);\n\n    return Result;\n}\n\nstatic glyph_table *PlaceGlyphTableInMemory(glyph_table_params Params, void *Memory)\n{\n    Assert(Params.HashCount >= 1);\n    Assert(Params.EntryCount >= 2);\n    Assert(IsPowerOfTwo(Params.HashCount));\n    Assert(Params.CacheTileCountInX >= 1);\n\n    glyph_table *Result = 0;\n\n    if(Memory)\n    {\n        // NOTE(casey): Always put the glyph_entry array at the base of the memory, because the\n        // compiler may generate aligned-SSE ops, which would crash if it was unaligned.\n        glyph_entry *Entries = (glyph_entry *)Memory;\n        Result = (glyph_table *)(Entries + Params.EntryCount);\n        Result->HashTable = (uint32_t *)(Result + 1);\n        Result->Entries = Entries;\n\n        Result->HashMask = Params.HashCount - 1;\n        Result->HashCount = Params.HashCount;\n        Result->EntryCount = Params.EntryCount;\n\n        memset(Result->HashTable, 0, Result->HashCount*sizeof(Result->HashTable[0]));\n\n        uint32_t StartingTile = Params.ReservedTileCount;\n\n        glyph_entry *Sentinel = GetSentinel(Result);\n        uint32_t X = StartingTile % Params.CacheTileCountInX;\n        uint32_t Y = StartingTile / Params.CacheTileCountInX;\n        for(uint32_t EntryIndex = 0;\n            EntryIndex < Params.EntryCount;\n            ++EntryIndex)\n        {\n            if(X >= Params.CacheTileCountInX)\n            {\n                X = 0;\n                ++Y;\n            }\n\n            glyph_entry *Entry = GetEntry(Result, EntryIndex);\n            if((EntryIndex+1) < Params.EntryCount)\n            {\n                Entry->NextWithSameHash = EntryIndex + 1;\n            }\n            else\n            {\n                Entry->NextWithSameHash = 0;\n            }\n            Entry->GPUIndex = PackGlyphCachePoint(X, Y);\n\n            Entry->FilledState = 0;\n            Entry->DimX = 0;\n            Entry->DimY = 0;\n            \n            ++X;\n        }\n\n        GetAndClearStats(Result);\n    }\n\n    return Result;\n}\n\n#ifdef  GLYPH_TABLE_UNDEF_ASSERT\n#undef Assert\n#endif\n"
        },
        {
          "name": "refterm_glyph_cache.h",
          "type": "blob",
          "size": 6.857421875,
          "content": "/* TODO(casey): \n\n   This is not designed to be a particularly high-speed cache.\n   \n   It is merely a simple example of a basic LRU cache, which is all \n   that is necessary for something like a terminal.\n   \n   Things that would probably want to be done for harder-core use:\n   \n   1) Consider and test some alternate cache designs to see if there\n      are any that remain simple to understand, but provide better\n      performance.  For example, this is a two-level cache (first the\n      chain is looked up, then the elements), which almost certainly\n      has worse cache behavior than a design where the first lookup\n      produced an actual element.\n      \n   2) Battle-test all the functions with a lot of randomized and constructed\n      data to ensure there are no lurking reference errors.  There are\n      three chaining behaviors - the LRU chain, the hash chains, and the\n      free list.  It would be nice to stress-test all of them to remove\n      any remaining corner-case bugs.\n*/\n\n// NOTE(casey): Types that are bundles of data for you to use:\ntypedef struct glyph_table_params glyph_table_params;\ntypedef struct glyph_hash glyph_hash;\ntypedef struct glyph_cache_point glyph_cache_point;\ntypedef struct gpu_glyph_index gpu_glyph_index;\ntypedef struct glyph_table_stats glyph_table_stats;\ntypedef struct glyph_state glyph_state;\n\n// NOTE(Casey): \"Opaque\" types used for the internals:\ntypedef struct glyph_table glyph_table;\ntypedef struct glyph_entry glyph_entry;\n\n/* NOTE(casey):\n\n   The glyph table requires some simple settings.\n   \n   HashCount = The size of the hash table.  This must be a power of two.\n               Larger is faster, up to a point.  Values like 65536 may be\n               appropriate for extensive codepoint usage, whereas much\n               smaller values like 256 or 4096 would be fine for situations\n               where very few Unicode combinations will be used.\n               \n   EntryCount = The total number of entries to remember.  This must be\n                no larger than the number that fit into the actual cache\n                texture, otherwise the glyph table will report back\n                indexes into that texture that are \"off the bottom\".\n                \n   ReservedTileCount = The total number of rects in the cache texture\n                       to reserve for direct mapping.  These will not\n                       be used when assigning slots to hashes, and\n                       are assumed to be for the app's own short-circuit\n                       usage.\n                       \n   CacheTileCountInX = The number of rects to put horizontally in the\n                       cache texture.  This should generally be the width of the\n                       cache texture divided by the font width.\n*/\nstruct glyph_table_params\n{\n    uint32_t HashCount;\n    uint32_t EntryCount;\n    uint32_t ReservedTileCount;\n    uint32_t CacheTileCountInX;\n};\n\n/* NOTE(casey):\n\n   If you have a non-zero ReservedTileCount, InitializeDirectGlyphTable\n   will fill out a gpu_glyph_index array you provide with ReservedTileCount's\n   worth of reserved rects you can use for direct-mapping codepoints of your\n   choice (that you won't send to the cache).  This is independent of the\n   glyph table, and does not change unless you change the glyph_table_params,\n   even if you reallocate the glyph table.\n\n   If you want an implicit 0 slot, the first slot filled by InitializeDirectGlyphTable\n   is always guaranteed to be 0, so you can put it in your table if you wish.\n   If instead you want it to skip writing it, because your table omits the 0 slot,\n   you can pass 1 as SkipZeroSlot and it will start writing at Table[0] with the\n   _first_ actual entry instead of the _zeroth_.\n\n   I know that's confusing, but it was the only way I could think of to\n   provide the ability for the user to both reserve the zero slot and not\n   reserve the zero slot, their choice.\n*/\nstatic void InitializeDirectGlyphTable(glyph_table_params Params, gpu_glyph_index *Table, int SkipZeroSlot);\n\n/* NOTE(casey):\n\n   To allocate a new glyph cache, call GetGlyphTableFootprint to find out the total size,\n   allocate that, then pass the memory block to PlaceGlyphTableInMemory.\n   Everything else is done for you:\n   \n   glyph_table *Table = PlaceGlyphTableInMemory(Params, malloc(GetGlyphTableFootprint(Params)));\n   if(Table)\n   {\n       // ...\n   }\n   \n   You do not need to check your allocation - PlaceGlyphTableInMemory will pass 0 through.\n   So it is sufficient to just check the PlaceGlyphTableInMemory return value.\n*/\nstatic size_t GetGlyphTableFootprint(glyph_table_params Params);\nstatic glyph_table *PlaceGlyphTableInMemory(glyph_table_params Params, void *Memory);\n\n/* NOTE(casey):\n\n   Glyph indices are packed Y.X as a 32-bit 16.16 value.  Whenever you get back a gpu_glyph_index,\n   you can retrieve the X/Y ordinal of the point int he texture with UnpackGlyphCachePoint,\n   so you don't have to do the unpacking yourself.\n*/\nstruct gpu_glyph_index \n{\n    uint32_t Value;\n};\nstruct glyph_cache_point\n{\n    uint32_t X, Y;\n};\nstatic glyph_cache_point UnpackGlyphCachePoint(gpu_glyph_index P);\n\n/* NOTE(casey):\n\n   To use the cache, compute a hash (however you want to, but it must be unique for your dataset)\n   and pass it to FindGlyphEntryByHash.  You'll get back a glyph_state that represents\n   this glyph in the cache.\n*/\nstruct glyph_hash \n{\n    __m128i Value;\n};\nstruct glyph_state\n{\n    uint32_t ID;\n    gpu_glyph_index GPUIndex;\n\n    // NOTE(casey): Technically these two values can be whatever you want.\n    uint32_t FilledState;\n    uint16_t DimX;\n    uint16_t DimY;\n};\nstatic glyph_state FindGlyphEntryByHash(glyph_table *Table, glyph_hash RunHash);\n\n/* NOTE(casey):\n\n   Whenever you change the state of the cache texture, call UpdateGlyphCacheEntry with the ID from the glyph_state\n   to inform the cache about the new filled status and tile count (if you are using tile counts).  Note that\n   the cache itself doesn't care about this at all - it is strictly for your code, so you can retrieve tile counts\n   later and/or know that glyphs have been sized and/or rasterized.\n*/\nstatic void UpdateGlyphCacheEntry(glyph_table *Table, uint32_t ID, uint32_t NewState, uint16_t NewDimX, uint16_t NewDimY);\n\n/* NOTE(casey):\n\n   The table keeps some simple internal stats.  The values are zeroed after every GetAndClearStats,\n   so the count is the total number since the last time the stats were retrieved.\n   \n   TODO(casey): This may be a mistake.  Perhaps the stats should just accumulate ad infinitum,\n   and people can diff vs. their old stats to find out the change?\n*/\nstruct glyph_table_stats\n{\n    size_t HitCount; // NOTE(casey): Number of times FindGlyphEntryByHash hit the cache\n    size_t MissCount; // NOTE(casey): Number of times FindGlyphEntryByHash misses the cache\n    size_t RecycleCount;  // NOTE(casey): Number of times an entry had to be recycled to fill a cache miss\n};\nstatic glyph_table_stats GetAndClearStats(glyph_table *Table);\n"
        },
        {
          "name": "refterm_ps.h",
          "type": "blob",
          "size": 14.8916015625,
          "content": "#if 0\r\n//\r\n// Generated by Microsoft (R) D3D Shader Disassembler\r\n//\r\n//\r\n// Input signature:\r\n//\r\n// Name                 Index   Mask Register SysValue  Format   Used\r\n// -------------------- ----- ------ -------- -------- ------- ------\r\n// SV_POSITION              0   xyzw        0      POS   float   xy  \r\n//\r\n//\r\n// Output signature:\r\n//\r\n// Name                 Index   Mask Register SysValue  Format   Used\r\n// -------------------- ----- ------ -------- -------- ------- ------\r\n// SV_TARGET                0   xyzw        0   TARGET   float   xyzw\r\n//\r\nps_5_0\r\ndcl_globalFlags refactoringAllowed\r\ndcl_constantbuffer CB0[3], immediateIndexed\r\ndcl_resource_structured t0, 12\r\ndcl_resource_texture2d (float,float,float,float) t1\r\ndcl_input_ps_siv linear noperspective v0.xy, position\r\ndcl_output o0.xyzw\r\ndcl_temps 6\r\nftou r0.xy, v0.xyxx\r\niadd r0.zw, r0.xxxy, -cb0[1].xxxy\r\nudiv r1.xy, null, r0.zwzz, cb0[0].xyxx\r\nuge r0.xy, r0.xyxx, cb0[1].xyxx\r\nand r0.x, r0.y, r0.x\r\nult r1.zw, r1.xxxy, cb0[0].zzzw\r\nand r0.x, r0.x, r1.z\r\nand r0.x, r1.w, r0.x\r\nif_nz r0.x\r\n  udiv null, r0.xy, r0.zwzz, cb0[0].xyxx\r\n  imad r0.z, r1.y, cb0[0].z, r1.x\r\n  ld_structured_indexable(structured_buffer, stride=12)(mixed,mixed,mixed,mixed) r1.xyz, r0.z, l(0), t0.xyzx\r\n  and r2.xyz, r1.xzyx, l(0x0000ffff, 255, 255, 0)\r\n  ushr r0.zw, r1.xxxy, l(0, 0, 16, 31)\r\n  mov r2.w, r0.z\r\n  imad r3.xy, r2.xwxx, cb0[0].xyxx, r0.xyxx\r\n  mov r3.zw, l(0,0,0,0)\r\n  ld_indexable(texture2d)(float,float,float,float) r3.xyzw, r3.xyzw, t1.xyzw\r\n  ubfe r4.xyzw, l(8, 8, 8, 8), l(8, 16, 8, 16), r1.zzyy\r\n  itof r5.x, r2.y\r\n  itof r5.yz, r4.xxyx\r\n  mul r1.xzw, r5.xxyz, l(0.003922, 0.000000, 0.003922, 0.003922)\r\n  itof r2.x, r2.z\r\n  itof r2.yz, r4.zzwz\r\n  mul r2.xyz, r2.xyzx, l(0.003922, 0.003922, 0.003922, 0.000000)\r\n  and r0.x, cb0[1].z, l(255)\r\n  ubfe r4.xy, l(8, 8, 0, 0), l(8, 16, 0, 0), cb0[1].zzzz\r\n  itof r5.x, r0.x\r\n  itof r5.yz, r4.xxyx\r\n  mul r4.xyz, r2.xyzx, r5.xyzx\r\n  ubfe r5.xyz, l(1, 1, 1, 0), l(28, 25, 27, 0), r1.yyyy\r\n  mul r4.xyz, r4.xyzx, l(0.003922, 0.003922, 0.003922, 0.000000)\r\n  movc r2.xyz, r5.xxxx, r4.xyzx, r2.xyzx\r\n  mul r4.xyz, r2.xyzx, l(0.500000, 0.500000, 0.500000, 0.000000)\r\n  movc r2.xyz, r5.yyyy, r4.xyzx, r2.xyzx\r\n  add r0.x, -r3.w, l(1.000000)\r\n  mul r3.xyz, r2.xyzx, r3.xyzx\r\n  mad r1.xyz, r0.xxxx, r1.xzwx, r3.xyzx\r\n  ine r0.x, r5.z, l(0)\r\n  uge r3.xy, r0.yyyy, cb0[2].zxzz\r\n  and r0.x, r0.x, r3.x\r\n  ult r0.yz, r0.yyyy, cb0[2].wwyw\r\n  and r0.x, r0.y, r0.x\r\n  ine r0.y, r0.w, l(0)\r\n  and r0.y, r3.y, r0.y\r\n  and r0.y, r0.z, r0.y\r\n  or r0.x, r0.y, r0.x\r\n  movc r0.xyz, r0.xxxx, r2.xyzx, r1.xyzx\r\nelse \r\n  and r0.w, cb0[1].w, l(255)\r\n  ubfe r1.xy, l(8, 8, 0, 0), l(8, 16, 0, 0), cb0[1].wwww\r\n  itof r2.x, r0.w\r\n  itof r2.yz, r1.xxyx\r\n  mul r0.xyz, r2.xyzx, l(0.003922, 0.003922, 0.003922, 0.000000)\r\nendif \r\nmov o0.xyz, r0.xyzx\r\nmov o0.w, l(1.000000)\r\nret \r\n// Approximately 0 instruction slots used\r\n#endif\r\n\r\nconst BYTE ReftermPSShaderBytes[] =\r\n{\r\n     68,  88,  66,  67, 128, 220, \r\n     99, 152, 112,  30, 119, 113, \r\n      9, 107, 241, 182, 138,  85, \r\n     27,   5,   1,   0,   0,   0, \r\n      0,   8,   0,   0,   3,   0, \r\n      0,   0,  44,   0,   0,   0, \r\n     96,   0,   0,   0, 148,   0, \r\n      0,   0,  73,  83,  71,  78, \r\n     44,   0,   0,   0,   1,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n     32,   0,   0,   0,   0,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n      3,   0,   0,   0,   0,   0, \r\n      0,   0,  15,   3,   0,   0, \r\n     83,  86,  95,  80,  79,  83, \r\n     73,  84,  73,  79,  78,   0, \r\n     79,  83,  71,  78,  44,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n      8,   0,   0,   0,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   3,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     15,   0,   0,   0,  83,  86, \r\n     95,  84,  65,  82,  71,  69, \r\n     84,   0, 171, 171,  83,  72, \r\n     69,  88, 100,   7,   0,   0, \r\n     80,   0,   0,   0, 217,   1, \r\n      0,   0, 106,   8,   0,   1, \r\n     89,   0,   0,   4,  70, 142, \r\n     32,   0,   0,   0,   0,   0, \r\n      3,   0,   0,   0, 162,   0, \r\n      0,   4,   0, 112,  16,   0, \r\n      0,   0,   0,   0,  12,   0, \r\n      0,   0,  88,  24,   0,   4, \r\n      0, 112,  16,   0,   1,   0, \r\n      0,   0,  85,  85,   0,   0, \r\n    100,  32,   0,   4,  50,  16, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   0, 101,   0, \r\n      0,   3, 242,  32,  16,   0, \r\n      0,   0,   0,   0, 104,   0, \r\n      0,   2,   6,   0,   0,   0, \r\n     28,   0,   0,   5,  50,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     70,  16,  16,   0,   0,   0, \r\n      0,   0,  30,   0,   0,   9, \r\n    194,   0,  16,   0,   0,   0, \r\n      0,   0,   6,   4,  16,   0, \r\n      0,   0,   0,   0,   6, 132, \r\n     32, 128,  65,   0,   0,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0,  78,   0,   0,   9, \r\n     50,   0,  16,   0,   1,   0, \r\n      0,   0,   0, 208,   0,   0, \r\n    230,  10,  16,   0,   0,   0, \r\n      0,   0,  70, 128,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,  80,   0,   0,   8, \r\n     50,   0,  16,   0,   0,   0, \r\n      0,   0,  70,   0,  16,   0, \r\n      0,   0,   0,   0,  70, 128, \r\n     32,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   0,   1,   0, \r\n      0,   7,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  26,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     10,   0,  16,   0,   0,   0, \r\n      0,   0,  79,   0,   0,   8, \r\n    194,   0,  16,   0,   1,   0, \r\n      0,   0,   6,   4,  16,   0, \r\n      1,   0,   0,   0, 166, 142, \r\n     32,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   7,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     42,   0,  16,   0,   1,   0, \r\n      0,   0,   1,   0,   0,   7, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  58,   0,  16,   0, \r\n      1,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     31,   0,   4,   3,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     78,   0,   0,   9,   0, 208, \r\n      0,   0,  50,   0,  16,   0, \r\n      0,   0,   0,   0, 230,  10, \r\n     16,   0,   0,   0,   0,   0, \r\n     70, 128,  32,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     35,   0,   0,  10,  66,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     26,   0,  16,   0,   1,   0, \r\n      0,   0,  42, 128,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      1,   0,   0,   0, 167,   0, \r\n      0, 139,   2,  99,   0, 128, \r\n    131, 153,  25,   0, 114,   0, \r\n     16,   0,   1,   0,   0,   0, \r\n     42,   0,  16,   0,   0,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      0,   0,   0,   0,  70, 114, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,   0,   0,  10, 114,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n    134,   1,  16,   0,   1,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n    255, 255,   0,   0, 255,   0, \r\n      0,   0, 255,   0,   0,   0, \r\n      0,   0,   0,   0,  85,   0, \r\n      0,  10, 194,   0,  16,   0, \r\n      0,   0,   0,   0,   6,   4, \r\n     16,   0,   1,   0,   0,   0, \r\n      2,  64,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     16,   0,   0,   0,  31,   0, \r\n      0,   0,  54,   0,   0,   5, \r\n    130,   0,  16,   0,   2,   0, \r\n      0,   0,  42,   0,  16,   0, \r\n      0,   0,   0,   0,  35,   0, \r\n      0,  10,  50,   0,  16,   0, \r\n      3,   0,   0,   0, 198,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n     70, 128,  32,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     70,   0,  16,   0,   0,   0, \r\n      0,   0,  54,   0,   0,   8, \r\n    194,   0,  16,   0,   3,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,  45,   0, \r\n      0, 137, 194,   0,   0, 128, \r\n     67,  85,  21,   0, 242,   0, \r\n     16,   0,   3,   0,   0,   0, \r\n     70,  14,  16,   0,   3,   0, \r\n      0,   0,  70, 126,  16,   0, \r\n      1,   0,   0,   0, 138,   0, \r\n      0,  15, 242,   0,  16,   0, \r\n      4,   0,   0,   0,   2,  64, \r\n      0,   0,   8,   0,   0,   0, \r\n      8,   0,   0,   0,   8,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n      2,  64,   0,   0,   8,   0, \r\n      0,   0,  16,   0,   0,   0, \r\n      8,   0,   0,   0,  16,   0, \r\n      0,   0, 166,   5,  16,   0, \r\n      1,   0,   0,   0,  43,   0, \r\n      0,   5,  18,   0,  16,   0, \r\n      5,   0,   0,   0,  26,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n     43,   0,   0,   5,  98,   0, \r\n     16,   0,   5,   0,   0,   0, \r\n      6,   1,  16,   0,   4,   0, \r\n      0,   0,  56,   0,   0,  10, \r\n    210,   0,  16,   0,   1,   0, \r\n      0,   0,   6,   9,  16,   0, \r\n      5,   0,   0,   0,   2,  64, \r\n      0,   0, 129, 128, 128,  59, \r\n      0,   0,   0,   0, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n     43,   0,   0,   5,  18,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n     42,   0,  16,   0,   2,   0, \r\n      0,   0,  43,   0,   0,   5, \r\n     98,   0,  16,   0,   2,   0, \r\n      0,   0, 166,  11,  16,   0, \r\n      4,   0,   0,   0,  56,   0, \r\n      0,  10, 114,   0,  16,   0, \r\n      2,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n      2,  64,   0,   0, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n    129, 128, 128,  59,   0,   0, \r\n      0,   0,   1,   0,   0,   8, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  42, 128,  32,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n    255,   0,   0,   0, 138,   0, \r\n      0,  16,  50,   0,  16,   0, \r\n      4,   0,   0,   0,   2,  64, \r\n      0,   0,   8,   0,   0,   0, \r\n      8,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      2,  64,   0,   0,   8,   0, \r\n      0,   0,  16,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0, 166, 138,  32,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0,  43,   0,   0,   5, \r\n     18,   0,  16,   0,   5,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      0,   0,   0,   0,  43,   0, \r\n      0,   5,  98,   0,  16,   0, \r\n      5,   0,   0,   0,   6,   1, \r\n     16,   0,   4,   0,   0,   0, \r\n     56,   0,   0,   7, 114,   0, \r\n     16,   0,   4,   0,   0,   0, \r\n     70,   2,  16,   0,   2,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      5,   0,   0,   0, 138,   0, \r\n      0,  15, 114,   0,  16,   0, \r\n      5,   0,   0,   0,   2,  64, \r\n      0,   0,   1,   0,   0,   0, \r\n      1,   0,   0,   0,   1,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      2,  64,   0,   0,  28,   0, \r\n      0,   0,  25,   0,   0,   0, \r\n     27,   0,   0,   0,   0,   0, \r\n      0,   0,  86,   5,  16,   0, \r\n      1,   0,   0,   0,  56,   0, \r\n      0,  10, 114,   0,  16,   0, \r\n      4,   0,   0,   0,  70,   2, \r\n     16,   0,   4,   0,   0,   0, \r\n      2,  64,   0,   0, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n    129, 128, 128,  59,   0,   0, \r\n      0,   0,  55,   0,   0,   9, \r\n    114,   0,  16,   0,   2,   0, \r\n      0,   0,   6,   0,  16,   0, \r\n      5,   0,   0,   0,  70,   2, \r\n     16,   0,   4,   0,   0,   0, \r\n     70,   2,  16,   0,   2,   0, \r\n      0,   0,  56,   0,   0,  10, \r\n    114,   0,  16,   0,   4,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      2,   0,   0,   0,   2,  64, \r\n      0,   0,   0,   0,   0,  63, \r\n      0,   0,   0,  63,   0,   0, \r\n      0,  63,   0,   0,   0,   0, \r\n     55,   0,   0,   9, 114,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n     86,   5,  16,   0,   5,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      4,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n      0,   0,   0,   8,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     58,   0,  16, 128,  65,   0, \r\n      0,   0,   3,   0,   0,   0, \r\n      1,  64,   0,   0,   0,   0, \r\n    128,  63,  56,   0,   0,   7, \r\n    114,   0,  16,   0,   3,   0, \r\n      0,   0,  70,   2,  16,   0, \r\n      2,   0,   0,   0,  70,   2, \r\n     16,   0,   3,   0,   0,   0, \r\n     50,   0,   0,   9, 114,   0, \r\n     16,   0,   1,   0,   0,   0, \r\n      6,   0,  16,   0,   0,   0, \r\n      0,   0, 134,   3,  16,   0, \r\n      1,   0,   0,   0,  70,   2, \r\n     16,   0,   3,   0,   0,   0, \r\n     39,   0,   0,   7,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     42,   0,  16,   0,   5,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      0,   0,   0,   0,  80,   0, \r\n      0,   8,  50,   0,  16,   0, \r\n      3,   0,   0,   0,  86,   5, \r\n     16,   0,   0,   0,   0,   0, \r\n     38, 138,  32,   0,   0,   0, \r\n      0,   0,   2,   0,   0,   0, \r\n      1,   0,   0,   7,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     10,   0,  16,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      3,   0,   0,   0,  79,   0, \r\n      0,   8,  98,   0,  16,   0, \r\n      0,   0,   0,   0,  86,   5, \r\n     16,   0,   0,   0,   0,   0, \r\n    246, 141,  32,   0,   0,   0, \r\n      0,   0,   2,   0,   0,   0, \r\n      1,   0,   0,   7,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     26,   0,  16,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      0,   0,   0,   0,  39,   0, \r\n      0,   7,  34,   0,  16,   0, \r\n      0,   0,   0,   0,  58,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,  64,   0,   0,   0,   0, \r\n      0,   0,   1,   0,   0,   7, \r\n     34,   0,  16,   0,   0,   0, \r\n      0,   0,  26,   0,  16,   0, \r\n      3,   0,   0,   0,  26,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   7,  34,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     42,   0,  16,   0,   0,   0, \r\n      0,   0,  26,   0,  16,   0, \r\n      0,   0,   0,   0,  60,   0, \r\n      0,   7,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  26,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     10,   0,  16,   0,   0,   0, \r\n      0,   0,  55,   0,   0,   9, \r\n    114,   0,  16,   0,   0,   0, \r\n      0,   0,   6,   0,  16,   0, \r\n      0,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n     70,   2,  16,   0,   1,   0, \r\n      0,   0,  18,   0,   0,   1, \r\n      1,   0,   0,   8, 130,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     58, 128,  32,   0,   0,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n      1,  64,   0,   0, 255,   0, \r\n      0,   0, 138,   0,   0,  16, \r\n     50,   0,  16,   0,   1,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n      8,   0,   0,   0,   8,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   2,  64, \r\n      0,   0,   8,   0,   0,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n    246, 143,  32,   0,   0,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n     43,   0,   0,   5,  18,   0, \r\n     16,   0,   2,   0,   0,   0, \r\n     58,   0,  16,   0,   0,   0, \r\n      0,   0,  43,   0,   0,   5, \r\n     98,   0,  16,   0,   2,   0, \r\n      0,   0,   6,   1,  16,   0, \r\n      1,   0,   0,   0,  56,   0, \r\n      0,  10, 114,   0,  16,   0, \r\n      0,   0,   0,   0,  70,   2, \r\n     16,   0,   2,   0,   0,   0, \r\n      2,  64,   0,   0, 129, 128, \r\n    128,  59, 129, 128, 128,  59, \r\n    129, 128, 128,  59,   0,   0, \r\n      0,   0,  21,   0,   0,   1, \r\n     54,   0,   0,   5, 114,  32, \r\n     16,   0,   0,   0,   0,   0, \r\n     70,   2,  16,   0,   0,   0, \r\n      0,   0,  54,   0,   0,   5, \r\n    130,  32,  16,   0,   0,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      0,   0, 128,  63,  62,   0, \r\n      0,   1\r\n};\r\n"
        },
        {
          "name": "refterm_vs.h",
          "type": "blob",
          "size": 3.6357421875,
          "content": "#if 0\r\n//\r\n// Generated by Microsoft (R) D3D Shader Disassembler\r\n//\r\n//\r\n// Input signature:\r\n//\r\n// Name                 Index   Mask Register SysValue  Format   Used\r\n// -------------------- ----- ------ -------- -------- ------- ------\r\n// SV_VERTEXID              0   x           0   VERTID    uint   x   \r\n//\r\n//\r\n// Output signature:\r\n//\r\n// Name                 Index   Mask Register SysValue  Format   Used\r\n// -------------------- ----- ------ -------- -------- ------- ------\r\n// SV_POSITION              0   xyzw        0      POS   float   xyzw\r\n//\r\nvs_5_0\r\ndcl_globalFlags refactoringAllowed\r\ndcl_input_sgv v0.x, vertex_id\r\ndcl_output_siv o0.xyzw, position\r\ndcl_temps 1\r\nand r0.x, v0.x, l(1)\r\nutof r0.x, r0.x\r\nadd r0.x, r0.x, l(-0.500000)\r\nadd o0.x, r0.x, r0.x\r\nushr r0.x, v0.x, l(1)\r\nutof r0.x, r0.x\r\nadd r0.x, r0.x, l(-0.500000)\r\nmul o0.y, r0.x, l(-2.000000)\r\nmov o0.zw, l(0,0,0,1.000000)\r\nret \r\n// Approximately 0 instruction slots used\r\n#endif\r\n\r\nconst BYTE ReftermVSShaderBytes[] =\r\n{\r\n     68,  88,  66,  67, 173, 161, \r\n    191, 148, 243,  58, 210,  73, \r\n    205,  38,  94,  72,  97,  14, \r\n     93,  15,   1,   0,   0,   0, \r\n    196,   1,   0,   0,   3,   0, \r\n      0,   0,  44,   0,   0,   0, \r\n     96,   0,   0,   0, 148,   0, \r\n      0,   0,  73,  83,  71,  78, \r\n     44,   0,   0,   0,   1,   0, \r\n      0,   0,   8,   0,   0,   0, \r\n     32,   0,   0,   0,   0,   0, \r\n      0,   0,   6,   0,   0,   0, \r\n      1,   0,   0,   0,   0,   0, \r\n      0,   0,   1,   1,   0,   0, \r\n     83,  86,  95,  86,  69,  82, \r\n     84,  69,  88,  73,  68,   0, \r\n     79,  83,  71,  78,  44,   0, \r\n      0,   0,   1,   0,   0,   0, \r\n      8,   0,   0,   0,  32,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      1,   0,   0,   0,   3,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n     15,   0,   0,   0,  83,  86, \r\n     95,  80,  79,  83,  73,  84, \r\n     73,  79,  78,   0,  83,  72, \r\n     69,  88,  40,   1,   0,   0, \r\n     80,   0,   1,   0,  74,   0, \r\n      0,   0, 106,   8,   0,   1, \r\n     96,   0,   0,   4,  18,  16, \r\n     16,   0,   0,   0,   0,   0, \r\n      6,   0,   0,   0, 103,   0, \r\n      0,   4, 242,  32,  16,   0, \r\n      0,   0,   0,   0,   1,   0, \r\n      0,   0, 104,   0,   0,   2, \r\n      1,   0,   0,   0,   1,   0, \r\n      0,   7,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  10,  16, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,  64,   0,   0,   1,   0, \r\n      0,   0,  86,   0,   0,   5, \r\n     18,   0,  16,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   7,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,  64,   0,   0,   0,   0, \r\n      0, 191,   0,   0,   0,   7, \r\n     18,  32,  16,   0,   0,   0, \r\n      0,   0,  10,   0,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     85,   0,   0,   7,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     10,  16,  16,   0,   0,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      1,   0,   0,   0,  86,   0, \r\n      0,   5,  18,   0,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   7,  18,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n     10,   0,  16,   0,   0,   0, \r\n      0,   0,   1,  64,   0,   0, \r\n      0,   0,   0, 191,  56,   0, \r\n      0,   7,  34,  32,  16,   0, \r\n      0,   0,   0,   0,  10,   0, \r\n     16,   0,   0,   0,   0,   0, \r\n      1,  64,   0,   0,   0,   0, \r\n      0, 192,  54,   0,   0,   8, \r\n    194,  32,  16,   0,   0,   0, \r\n      0,   0,   2,  64,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0,   0,   0,   0,   0, \r\n      0,   0, 128,  63,  62,   0, \r\n      0,   1\r\n};\r\n"
        },
        {
          "name": "splat.cpp",
          "type": "blob",
          "size": 1.51953125,
          "content": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <stdio.h>\n#include <time.h>\n\n#include \"fast_pipe.h\"\n\nint main(int ArgCount, char **Args)\n{\n    int FastPipeAvailable = USE_FAST_PIPE_IF_AVAILABLE();\n\n#if _WIN32\n    if(!FastPipeAvailable)\n    {\n        // NOTE(casey): Need to set UTF-8 output page if we are using the antiquated Windows terminal system\n        SetConsoleOutputCP(65001);\n    }\n#endif\n    \n    size_t TotalTransfer = 0;\n    size_t BufferSize = 64*1024*1024;\n    char *Buffer = (char *)malloc(BufferSize);\n    if(Buffer)\n    {\n        for(int ArgIndex = 1;\n            ArgIndex < ArgCount;\n            ++ArgIndex)\n        {\n            char *FileName = Args[ArgIndex];\n            FILE *File = fopen(FileName, \"rb\");\n            if(File)\n            {\n                clock_t Start = clock();\n                while(size_t ByteCount = fread(Buffer, 1, BufferSize, File))\n                {\n                    TotalTransfer += ByteCount;\n                    fwrite(Buffer, 1, ByteCount, stdout);\n                }\n                clock_t End = clock();\n                \n                double Elapsed = (double)(End - Start) / (double)CLOCKS_PER_SEC;\n                fprintf(stdout, \"\\n\\nTotal sink time: %.03fs (%fgb/s)\\n\", \n                        Elapsed, TotalTransfer / (1024.0*1024.0*1024.0*Elapsed));\n                \n                fclose(File);\n            }\n            else\n            {\n                fprintf(stderr, \"Unable to open \\\"%s\\\".\\n\", FileName);\n            }\n        }\n     \n        free(Buffer);\n    }\n    \n    return 0;\n}\n"
        },
        {
          "name": "splat2.cpp",
          "type": "blob",
          "size": 3.4482421875,
          "content": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <stdio.h>\n#include <time.h>\n#include <windows.h>\n\n#include \"fast_pipe.h\"\n\nint main(int ArgCount, char **Args)\n{\n    int FastPipeAvailable = USE_FAST_PIPE_IF_AVAILABLE();\n\n#if _WIN32\n    if(!FastPipeAvailable)\n    {\n        // NOTE(casey): Need to set UTF-8 output page if we are using the antiquated Windows terminal system\n        SetConsoleOutputCP(65001);\n    }\n#endif\n\n    HANDLE StdOut = GetStdHandle(STD_OUTPUT_HANDLE);\n\n    int VTEnabled = 0;\n    double Elapsed = 0.0;\n    size_t TotalTransfer = 0;\n    size_t BufferSize = 64*1024*1024;\n    char *Buffer = (char *)malloc(BufferSize);\n    if(Buffer)\n    {\n        for(int ArgIndex = 1;\n            ArgIndex < ArgCount;\n            ++ArgIndex)\n        {\n            int LongLine = (strcmp(Args[ArgIndex], \"-longline\") == 0);\n            int ManyLine = (strcmp(Args[ArgIndex], \"-manyline\") == 0);\n            if(LongLine || ManyLine)\n            {\n                int TotalCharCount = ManyLine ? 27 : 26;\n                for(size_t At = 0; At < BufferSize; ++At)\n                {\n                    int Pick = rand()%TotalCharCount;\n                    Buffer[At] = 'a' + Pick;\n                    if(ManyLine && (Pick == 26)) Buffer[At] = '\\n';\n                }\n\n                clock_t Start = clock();\n                while(TotalTransfer < 1024*1024*1024)\n                {\n                    DWORD ByteCount = 0;\n                    WriteFile(StdOut, Buffer, (DWORD)BufferSize, &ByteCount, 0);\n                    TotalTransfer += ByteCount;\n                }\n                clock_t End = clock();\n                Elapsed += (double)(End - Start) / (double)CLOCKS_PER_SEC;\n            }\n            else if(strcmp(Args[ArgIndex], \"-vt\") == 0)\n            {\n#if _WIN32\n                if(!FastPipeAvailable)\n                {\n                    DWORD WinConMode = 0;\n                    DWORD EnableVirtualTerminalProcessing = 0x0004;\n                    GetConsoleMode(StdOut, &WinConMode);\n                    SetConsoleMode(StdOut, WinConMode | EnableVirtualTerminalProcessing);\n                }\n#endif\n                VTEnabled = 1;\n            }\n            else\n            {\n                char *FileName = Args[ArgIndex];\n                HANDLE File = CreateFileA(FileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING,\n                                          FILE_ATTRIBUTE_NORMAL, 0);\n                if(File != INVALID_HANDLE_VALUE)\n                {\n                    clock_t Start = clock();\n                    DWORD ByteCount = 0;\n                    while(ReadFile(File, Buffer, (DWORD)BufferSize, &ByteCount, 0) && ByteCount)\n                    {\n                        WriteFile(StdOut, Buffer, (DWORD)ByteCount, &ByteCount, 0);\n                        TotalTransfer += ByteCount;\n                    }\n                    clock_t End = clock();\n                    Elapsed += (double)(End - Start) / (double)CLOCKS_PER_SEC;\n\n                    CloseHandle(File);\n                }\n                else\n                {\n                    fprintf(stderr, \"Unable to open \\\"%s\\\".\\n\", FileName);\n                }\n            }\n        }\n        \n        if(VTEnabled)\n        {\n            fprintf(stdout, \"\\x1b[0m\");\n        }\n        \n        double GBs = 0;\n        if(Elapsed)\n        {\n            GBs = TotalTransfer / (1024.0*1024.0*1024.0*Elapsed);\n        }\n        fprintf(stdout, \"\\n\\nTotal sink time: %.03fs (%fgb/s)\\n\", Elapsed, GBs);\n\n        free(Buffer);\n    }\n\n    return 0;\n}\n"
        }
      ]
    }
  ]
}