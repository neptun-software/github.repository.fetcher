{
  "metadata": {
    "timestamp": 1736709678098,
    "page": 39,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "yrutschle/sslh",
      "stars": 4618,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.154296875,
          "content": "*.swp\n*.swo\n*.o\ncscope.*\nechosrv\nlibsslh.a\nsslh-fork\nsslh-select\nsslh-ev\nsystemd-sslh-generator\nsslh.8.gz\ntags\n/config.status\n/config.log\n/config.h\n/Makefile\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 13.6259765625,
          "content": "vNEXT:\n\tAdded a boolean setting \"is_unix\" for listen and\n\tprotocol entries. This will use the 'host' setting\n\tas a path name to a socket file, and connections\n\t(listening or connecting) will be performed on Unix\n\tsocket instead of Internet sockets.\n\nv2.1.3:\n\tFix Landlock access to /etc/hosts.deny and\n\t/etc/hosts.allow.\n\nv2.1.2:\n\tFix inetd mode.\n\nv2.1.1:\n\tVarious minor fixes.\n\nv2.1.0:\n\tSupport for the Landlock LSM. After initial setup,\n\tsslh gives up all local file access rights.\n\n\tReintroduced --ssl as an alias to --tls.\n\n\tIntroduce autoconf to adapt to landlock presence.\n\n\tClose connexion without error message if remote\n\tclient forcefully closes connexion, for Windows.\n\nv2.0.1:\t\n\tFix resolve_on_forward setting, which would crash\n\tsslh reliably.\n\nv2.0.0:\nv2.0:\n\tNew sslh-ev: this is functionally equivalent to\n\tsslh-select (mono-process, only forks for specified\n\tprotocols), but based on libev, which should make it\n\tscalable to large numbers of connections.\n\n\tNew log system: instead of --verbose with arbitrary\n\tlevels, there are now several message classes. Each\n\tmessage class can be set to go to stderr, syslog, or\n\tboth. Classes are documented in example.cfg.\n\n\tUDP connections are now managed in a hash to avoid\n\tlinear searches. The downside is that the number of\n\tUDP connections is a hard limit, configurable with\n\tthe 'udp_max_connections', which defaults to 1024.\n\tTimeouts are managed with lists.\n\n\tinetd merges stderr output to what is sent to the\n\tclient, which is a security issue as it might give\n\tinformation to an attacker. When inetd is activated,\n\tstderr is forcibly closed.\n\n\tNew protocol-level option `resolve_on_forward`,\n\trequests that target names are resolved at each\n\tconnection instead of at startup. Useful for dynamic\n\tDNS situations. (Paul Schroeder/milkpirate)\n\n\tNew probe for MSRDP (akappner).\n\nv1.22: 17AUG2021\n\tsslh-select now supports UDP protocols.\n\tProbes specified in the `protocols`\n\tconfiguration entry are tried on incoming packets,\n\tTCP or UDP, and forwarded based on the input\n\tprotocol (an incoming TCP connection will be\n\tforwarded as TCP, and same with UDP).\n\tThis has been tested with DNS as shown in udp.cfg:\n\tincoming packets that contain my domain name are\n\tassumed to be a DNS request and forwarded\n\taccordingly. Note this could cause problems if\n\tcombined with incoming TLS with SNI.  UDP clients\n\tand servers need to agree on the IPv4/IPv6 they use:\n\tuse the same protocol on all sides! Often, this\n\tmeans explicitly using 'ip4-localhost'.\n\tUDP sender-receiver pairs (connections, so to speak)\n\tare kept for 60s, which can be changed with\n\t`udp_timeout` in the configuration.\n\n\tAdded probes for UDP protocols QUICK and Teamspeak.\n\n\tAdded probes for syslog protocol.\n\n\tsslh-select refactored to change linear searches\n\tthrough connections to linear searches through\n\tfd_set.\n\n\tFixed a libconfig call to support libconfig 1.7.3.\n\n\tAdded symbol to support libconfig 1.4.9, still in\n\tuse in CentOS7.\n\n\tWarn about unknown settings in the configuration\n\tfile.\n\n\tAdded per-protocol `transparent` option. sslh-fork\n\tdrops the capability after creating the server-side\n\ttransparent socket. Transparent now uses CAP_NET_RAW\n\tinstead of CAP_NET_ADMIN.\n\n\tRemoved compile-time option to use POSIX regex. Now\n\tregex must be PCRE2 (Perl-Compatible). This was in\n\tfact the case since v1.21, as PCRE are used to parse\n\tthe config file.\n\nv1.21: 11JUL2020\n\tWARNING:\n\tMoved configuration and command-line management to\n\tuse conf2struct. Changes are:\n\t* `--ssl` and using `name: 'ssl'` in config file is no longer supported, use `tls` instead.\n\t* command line option <-F|--config> no longer defaults to /etc/sslh.cfg, so you have to\n\tspecify it explicitly.\n\t* command line option <-v|--verbose> takes a mandatory integer parameter\n\n\tAdded TCP_FASTOPEN support for client sockets (if\n\ttfo_ok is specified in their configuration) and for\n\tlistening socket, if all client protocols support it.\n\t(Craig Andrews)\n\n\tAdded 'minlength' option to skip a probe if less\n\tthan that many bytes have been received (mostly for\n\tregex)\n\n\tUpdate Let's Encrypt entry in example.cfg for tls-alpn-01\n\tchallenges; tls-sni-* challenges are now deprecated.\n\n\tLog to syslog even if in foreground (for people who\n\tuse fail2ban)\n\n\tUse syslog_facility: \"none\" to disable syslog\n\toutput.\n\n\tChanged exit code for illegal command line parameter\n\tfrom 1 to 6 (for testing purposes)\n\nv1.20: 20NOV2018\n\tAdded support for socks5 protocol (Eugene Protozanov)\n\n\tNew probing method:\n\tBefore, probes were tried in order, repeating on the\n\tsame probe as long it returned PROBE_AGAIN before\n\tmoving to the next one. This means a probe which\n\trequires a lot of data (i.e. return PROBE_AGAIN for\n\ta long time) could prevent successful matches from \n\tsubsequent probes. The configuration file needed to\n\ttake that into account.\n\n\tNow, all probes are tried each time new data is\n\tfound. If any probe matches, use it. If at least one\n\tprobe requires more data, wait for more. If all\n\tprobes failed, connect to the last one. So the only\n\tthing to know when writing the configuration file is\n\tthat 'anyprot' needs to be last.\n\n\tTest suite heavily refactored; `t` uses `test.cfg`\n\tto decide which probes to test and all setup is\n\tautomatic; probes get tested with 'fast' (entire\n\tfirst message in one packet) and 'slow' (one byte at\n\ta time); when SNI/ALPN are defined, all combinations\n\tare tested.\n\n\tOld 'tls' probe removed, 'sni_alpn' probe renamed as 'tls'.\n\tYou'll need to change 'sni_alpn' to 'tls' in\n\tyour configuration file, if ever you used it.\n\nv1.19: 20JAN2018\n\tAdded 'syslog_facility' configuration option to\n\tspecify where to log.\n\n\tTLS now supports SNI and ALPN (Travis Burtrum),\n\tincluding support for Let's Encrypt challenges\n\t(Jonathan McCrohan)\n\n\tADB probe. (Mike Frysinger)\n\n\tAdded per-protocol 'fork' option. (Oleg Oshmyan)\n\n\tAdded chroot option. (Mike Frysinger)\n\n\tA truckload of bug fixes and documentation\n\timprovements (Various contributors)\n\nv1.18:\t29MAR2016\n\tAdded USELIBPCRE to make use of regex engine\n\toptional.\n\n\tAdded support for RFC4366 SNI and RFC7301 ALPN\n\t(Travis Burtrum)\n\n\tChanged connection log to include the name of the probe that\n\ttriggered.\n\n\tChanged configuration file format: 'probe' field is\n\tno longer required, 'name' field can now contain\n\t'tls' or 'regex', with corresponding options (see\n\texample.cfg)\n\tAdded 'log_level' option to each protocol, which\n\tallows to turn off generation of log at each\n\tconnection.\n\tAdded 'keepalive' option.\n\nv1.17: \t09MAR2015\n\tSupport RFC5952-style IPv6 addresses, e.g. [::]:443.\n\n\tTransparent proxy support for FreeBSD.\n\t(Ruben van Staveren)\n\n\tUsing -F with no argument will try\n\t/etc/sslh/sslh.cfg and then /etc/sslh.cfg as\n\tconfiguration files. (argument to -F can no longer\n\tbe separated from the option by a space, e.g. must\n\tbe -Ffoo.cfg)\n\n\tCall setgroups() before setgid() (fixes potential\n\tprivilege escalation).\n\t(Lars Vogdt)\n\n\tUse portable way of getting modified time for OSX\n\tsupport.\n\t(Aaron Madlon-Kay)\n\n\tExample configuration for fail2ban.\n\t(Every Mouw)\n\nv1.16:\t11FEB2014\n\tProbes made more resilient, to incoming data\n\tcontaining NULLs. Also made them behave properly\n\twhen receiving too short packets to probe on the\n\tfirst incoming packet.\n\t(Ondrej Kuzník)\n\n\tLibcap support: Keep only CAP_NET_ADMIN if started\n\tas root with transparent proxying and dropping\n\tprivileges (enable USELIBCAP in Makefile). This\n\tavoids having to mess with filesystem capabilities.\n\t(Sebastian Schmidt/yath)\n\n\tFixed bugs related to getpeername that would cause\n\tsslh to quit erroneously (getpeername can return\n\tactual errors if connections are dropped before\n\tgetting to getpeername).\n\n\tSet IP_FREEBIND if available to bind to addresses\n\tthat don't yet exist.\n\nv1.15:\t27JUL2013\n\tAdded --transparent option for transparent proxying.\n\tSee README for iptables magic and capability\n\tmanagement.\n\n\tFixed bug in sslh-select: if number of opened file\n\tdescriptor became bigger than FD_SETSIZE, bad things\n\twould happen.\n\n\tFixed bug in sslh-select: if socket dropped while\n\tdeferred_data was present, sslh-select would crash.\n\n\tIncreased FD_SETSIZE for Cygwin, as the default 64\n\tis too low for even moderate load.\n\nv1.14: 21DEC2012\n\tCorrected OpenVPN probe to support pre-shared secret\n\tmode (OpenVPN port-sharing code is... wrong). Thanks\n\tto Kai Ellinger for help in investigating and\n\ttesting.\n\n\tAdded an actual TLS/SSL probe.\n\n\tAdded configurable --on-timeout protocol\n\tspecification.\n\n\tAdded a --anyprot protocol probe (equivalent to what\n\t--ssl was).\n\n\tMakefile respects the user's compiler and CFLAG\n\tchoices (falling back to the current values if\n\tundefined), as well as LDFLAGS. \n\t(Michael Palimaka)\n\n\tAdded \"After\" and \"KillMode\" to systemd.sslh.service\n\t(Thomas Weißschuh).\n\n\tAdded LSB tags to etc.init.d.sslh\n\t(Thomas Varis).\n\nv1.13: 18MAY2012\n\tWrite PID file before dropping privileges.\n\n\tAdded --background, which overrides 'foreground'\n\tconfiguration file setting.\n\n\tAdded example systemd service file from Archlinux in\n\tscripts/\n\thttps://projects.archlinux.org/svntogit/community.git/tree/trunk/sslh.service?h=packages/sslh\n\t(Sébastien Luttringer)\n\nv1.12: 08MAY2012\n\tAdded support for configuration file.\n\n\tNew protocol probes can be defined using regular\n\texpressions that match the first packet sent by the\n\tclient.\n\n\tsslh now connects timed out connections to the first\n\tconfigured protocol instead of 'ssh' (just make sure\n\tssh is the first defined protocol).\n\n\tsslh now tries protocols in the order in which they\n\tare defined (just make sure sslh is the last defined\n\tprotocol).\n\nv1.11: 21APR2012\n\tWARNING: defaults have been removed for --user and\n\t--pidfile options, update your start-up scripts!\n\n\tNo longer stop sslh when reverse DNS requests fail\n\tfor logging.\n\n\tAdded HTTP probe.\n\n\tNo longer create new session if running in\n\tforeground.\n\n\tNo longer default to changing user to 'nobody'. If\n\t--user isn't specified, just run as current user.\n\n\tNo longer create PID file by default, it should be\n\texplicitly set with --pidfile.\n\n\tNo longer log to syslog if in foreground. Logs are\n\tinstead output to stderr.\n\n\tThe four changes above make it straightforward to\n\tintegrate sslh with systemd, and should help with\n\tlaunchd.\n\nv1.10: 27NOV2011\n\tFixed calls referring to sockaddr length so they work\n\twith FreeBSD.\n\n\tTry target addresses in turn until one works if\n\tthere are several (e.g. \"localhost:22\" resolves to\n\tan IPv6 address and an IPv4 address and sshd does\n\tnot listen on IPv6).\n\n\tFixed sslh-fork so killing the head process kills\n\tthe listener processes.\n\n\tHeavily cleaned up test suite. Added stress test\n\tt_load script. Added coverage (requires lcov).\n\n\tSupport for XMPP (Arnaud Gendre).\n\n\tUpdated README.MacOSX (Aaron Madlon-Kay).\n\nv1.9: 02AUG2011\n\tWARNING: This version does not work with FreeBSD and\n\tderivatives!\n\n\tWARNING: Options changed, you'll need to update your\n\tstart-up scripts! Log format changed, you'll need to\n\tupdate log processing scripts!\n\n\tNow supports IPv6 throughout (both on listening and\n\tforwarding)\n\n\tLogs now contain IPv6 addresses, local forwarding\n\taddress, and resolves names (unless --numeric is\n\tspecified).\n\n\tIntroduced long options.\n\n\tOptions -l, -s and -o replaced by their long\n\tcounterparts.\n\n\tDefaults for SSL and SSH options suppressed (it's \n\tlegitimate to want to use sslh to mux OpenVPN and \n\ttinc while not caring about SSH nor SSL).\n\n\tBind to multiple addresses with multiple -p options.\n\n\tSupport for tinc VPN (experimental).\n\n\tNumeric logging option.\n\nv1.8: 15JUL2011\n\tChanged log format to make it possible to link\n\tconnections to subsequent logs from other services.\n\n\tUpdated CentOS init.d script (Andre Krajnik).\n\n\tFixed zombie issue with OpenBSD (The SA_NOCLDWAIT flag is not\n\tpropagated to the child process, so we set up signals after\n\tthe fork.) (François FRITZ)\n\n\tAdded -o \"OpenVPN\" and OpenVPN probing and support.\n\n\tAdded single-threaded, select(2)-based version.\n\n\tAdded support for \"Bold\" SSH clients (clients that speak first)\n\tThanks to Guillaume Ricaud for spotting a regression\n\tbug.\n\n\tAdded -f \"foreground\" option.\n\n\tAdded test suite. (only tests connexions. No test for libwrap,\n\tsetsid, setuid and so on) and corresponding 'make\n\ttest' target.\n\n\tAdded README.MacOSX (thanks Aaron Madlon-Kay)\n\n\tDocumented use with proxytunnel and corkscrew in\n\tREADME.\n\n\t\nv1.7: 01FEB2010\n\tAdded CentOS init.d script (Andre Krajnik).\n\n\tFixed default ssl address inconsistency, now\n\tdefaults to \"localhost:443\" and fixed documentation\n\taccordingly (pointed by Markus Schalke).\n\n\tChildren no longer bind to the listen socket, so\n\tparent server can be stopped without killing an\n\tactive child (pointed by Matthias Buecher).\n\n\tInetd support (Dima Barsky).\n\nv1.6: 25APR2009\n\tAdded -V, version option.\n\n\tInstall target directory configurable in Makefile\n\n\tChanged syslog prefix in auth.log to \"sslh[%pid]\"\n\n\tMan page\n\n\tnew 'make install' and 'make install-debian' targets\n\n\tPID file now specified using -P command line option\n\n\tActually fixed zombie generation (the v1.5 patch got\n\tlost, doh!)\n\n\nv1.5: 10DEC2008\n\tFixed zombie generation.\n\n\tAdded support scripts (), Makefile.\n\n\tChanged all 'connexions' to 'connections' to please\n\tpesky users. Damn users.\n\nv1.4: 13JUL2008\n\tAdded libwrap support for ssh service (Christian Weinberger)\n\tOnly SSH is libwraped, not SSL.\n\nv1.3: 14MAY2008\n\tAdded parsing for local interface to listen on\n\n\tChanged default SSL connection to port 442 (443 doesn't make\n\tsense as a default as we're already listening on 443)\n\n\tSyslog incoming connections\n\nv1.2: 12MAY2008\n\tFixed compilation warning for AMD64 (Thx Daniel Lange)\n\nv1.1: 21MAY2007\n\tMaking sslhc more like a real daemon:\n\t* If $PIDFILE is defined, write first PID to it upon startup\n\t* Fork at startup (detach from terminal)\n\t(thanks to http://www.enderunix.org/docs/eng/daemon.php -- good checklist)\n\t* Less memory usage (?)\n\nv1.0: \n\tBasic functionality: privilege dropping, target hostnames and ports\n\tconfigurable.\n\n\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.81640625,
          "content": "ARG ALPINE_VERSION=\"latest\"\nARG TARGET_ARCH=\"library\"\n\nFROM docker.io/${TARGET_ARCH}/alpine:${ALPINE_VERSION} AS build\n\nWORKDIR /sslh\n\nRUN apk add --no-cache \\\n        'gcc' \\\n        'libconfig-dev' \\\n        'make' \\\n        'musl-dev' \\\n        'pcre2-dev' \\\n        'perl' \\\n        ;\n\nCOPY . /sslh\n\nRUN ./configure && make sslh-select && strip sslh-select\n\nFROM docker.io/${TARGET_ARCH}/alpine:${ALPINE_VERSION}\n\nCOPY --from=build \"/sslh/sslh-select\" \"/usr/local/bin/sslh\"\nRUN apk add --no-cache \\\n        'libconfig' \\\n        'pcre2' \\\n        'iptables' \\\n        'ip6tables' \\\n        'libcap' \\\n    && \\\n    adduser -s '/bin/sh' -S -D sslh && \\\n    setcap cap_net_bind_service,cap_net_raw+ep /usr/local/bin/sslh\n\nCOPY \"./container-entrypoint.sh\" \"/init\"\nENTRYPOINT [ \"/init\" ]\n\n# required for updating iptables\nUSER root:root\n"
        },
        {
          "name": "Makefile.in",
          "type": "blob",
          "size": 4.9404296875,
          "content": "\nVERSION=$(shell ./genver.sh -r)\n\n# Configuration -- you probably need to `make clean` if you\n# change any of these\n\n# uncomment the following line to disable landlock\n# override undefine HAVE_LANDLOCK\nENABLE_SANITIZER= # Enable ASAN/LSAN/UBSAN\nENABLE_REGEX=1  # Enable regex probes\nUSELIBCONFIG=1\t# Use libconfig? (necessary to use configuration files)\nUSELIBEV=1\t# Use libev?\nUSELIBWRAP?=\t# Use libwrap?\nUSELIBCAP=\t# Use libcap?\nUSESYSTEMD=     # Make use of systemd socket activation\nUSELIBBSD?=     # Use libbsd (needed to update process name in `ps`)\nCOV_TEST= \t# Perform test coverage?\nPREFIX?=/usr\nBINDIR?=$(PREFIX)/sbin\nMANDIR?=$(PREFIX)/share/man/man8\n\nMAN=sslh.8.gz\t# man page name\n\n# End of configuration -- the rest should take care of\n# itself\n\nifneq ($(strip $(ENABLE_SANITIZER)),)\n    CFLAGS_SAN=-fsanitize=address -fsanitize=leak -fsanitize=undefined\nendif\n\nifneq ($(strip $(COV_TEST)),)\n    CFLAGS_COV=-fprofile-arcs -ftest-coverage\nendif\n\nCC ?= gcc\nAR ?= ar\nCFLAGS +=-Wall -O2 -DLIBPCRE -g $(CFLAGS_COV) $(CFLAGS_SAN)\n\n\nLIBS=-lm -lpcre2-8\nOBJS=sslh-conf.o common.o log.o sslh-main.o probe.o tls.o argtable3.o collection.o gap.o tcp-probe.o landlock.o\nOBJS_A=libsslh.a\nFORK_OBJS=sslh-fork.o $(OBJS_A)\nSELECT_OBJS=processes.o udp-listener.o sslh-select.o hash.o tcp-listener.o $(OBJS_A)\nEV_OBJS=processes.o udp-listener.o sslh-ev.o hash.o tcp-listener.o $(OBJS_A)\n\nCONDITIONAL_TARGETS=\n\nifneq ($(strip $(USELIBWRAP)),)\n\tLIBS:=$(LIBS) -lwrap\n\tCPPFLAGS+=-DLIBWRAP\nendif\n\nifneq ($(strip $(ENABLE_REGEX)),)\n\tCPPFLAGS+=-DENABLE_REGEX\nendif\n\nifneq ($(strip $(USELIBCONFIG)),)\n\tLIBS:=$(LIBS) -lconfig\n\tCPPFLAGS+=-DLIBCONFIG\nendif\n\nifneq ($(strip $(USELIBCAP)),)\n\tLIBS:=$(LIBS) -lcap\n\tCPPFLAGS+=-DLIBCAP\nendif\n\nifneq ($(strip $(USESYSTEMD)),)\n        LIBS:=$(LIBS) -lsystemd\n        CPPFLAGS+=-DSYSTEMD\n\tCONDITIONAL_TARGETS+=systemd-sslh-generator\nendif\n\nifneq ($(strip $(USELIBBSD)),)\n        LIBS:=$(LIBS) -lbsd\n        CPPFLAGS+=-DLIBBSD\nendif\n\nifneq ($(strip $(USELIBEV)),)\n        CONDITIONAL_TARGETS+=sslh-ev\nendif\n\nall: sslh-fork sslh-select $(MAN) echosrv $(CONDITIONAL_TARGETS)\n\n%.o: %.c %.h version.h\n\t$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $@\n\n$(OBJS_A): $(OBJS)\n\t$(AR) rcs $(OBJS_A) $(OBJS)\n\nversion.h: .FORCE\n\t./genver.sh >version.h\n.FORCE:\t\n\n$(OBJS) $(FORK_OBJS) $(SELECT_OBJS) $(EV_OBJS): argtable3.h collection.h common.h gap.h hash.h log.h probe.h processes.h sslh-conf.h tcp-listener.h tcp-probe.h tls.h udp-listener.h version.h\n\n\nc2s:\n\tconf2struct sslhconf.cfg\n\tconf2struct echosrv.cfg\n\nsslh-conf.c sslh-conf.h: sslhconf.cfg\n\t$(warning \"sslhconf.cfg is more recent than sslh-conf.[ch]. Use `make c2s` to rebuild using `conf2struct`\")\n\nsslh-fork: version.h Makefile $(FORK_OBJS)\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o sslh-fork $(FORK_OBJS) $(LIBS)\n\nsslh-select: version.h $(SELECT_OBJS) Makefile\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o sslh-select $(SELECT_OBJS) $(LIBS)\n\nsslh-ev: version.h $(EV_OBJS) Makefile\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o sslh-ev $(EV_OBJS) $(LIBS) -lev\n\nsystemd-sslh-generator: systemd-sslh-generator.o\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o systemd-sslh-generator systemd-sslh-generator.o -lconfig\n\nechosrv-conf.c echosrv-conf.h: echosrv.cfg\n\t$(warning \"echosrv.cfg is more recent than echosrv-conf.[ch]. Use `make c2s` to rebuild using `conf2struct`\")\n\nechosrv: version.h echosrv-conf.c echosrv.o echosrv-conf.o argtable3.o\n\t$(CC) $(CFLAGS) $(LDFLAGS) -o echosrv echosrv.o echosrv-conf.o argtable3.o $(LIBS)\n\n\nlandlock.o: config.h\n\n$(MAN): sslh.pod Makefile\n\tpod2man --section=8 --release=$(VERSION) --center=\" \" sslh.pod | gzip -9 - > $(MAN)\n\n# Create release: export clean tree and tag current\n# configuration\nrelease:\n\tgit archive $(VERSION) --prefix=\"sslh-$(VERSION)/\" | gzip > /tmp/sslh-$(VERSION).tar.gz\n\tgpg --detach-sign --armor /tmp/sslh-$(VERSION).tar.gz\n\n# Build docker image\ndocker:\n\tdocker image build -t \"sslh:${VERSION}\" .\n\tdocker image tag \"sslh:${VERSION}\" sslh:latest\n\ndocker-clean:\n\tyes | docker image rm \"sslh:${VERSION}\" sslh:latest\n\tyes | docker image prune\n\n# generic install: install binary and man page\ninstall: sslh-fork $(MAN)\n\tmkdir -p $(DESTDIR)/$(BINDIR)\n\tmkdir -p $(DESTDIR)/$(MANDIR)\n\tinstall -p sslh-fork $(DESTDIR)/$(BINDIR)/sslh\n\tinstall -p -m 0644 $(MAN) $(DESTDIR)/$(MANDIR)/$(MAN)\n\n# \"extended\" install for Debian: install startup script\ninstall-debian: install sslh $(MAN)\n\tsed -e \"s+^PREFIX=+PREFIX=$(PREFIX)+\" scripts/etc.init.d.sslh > /etc/init.d/sslh\n\tchmod 755 /etc/init.d/sslh\n\tupdate-rc.d sslh defaults\n\nuninstall:\n\trm -f $(DESTDIR)$(BINDIR)/sslh $(DESTDIR)$(MANDIR)/$(MAN) $(DESTDIR)/etc/init.d/sslh $(DESTDIR)/etc/default/sslh\n\tupdate-rc.d sslh remove\n\ndistclean: clean\n\trm -f tags sslh-conf.[ch] echosrv-conf.[ch] cscope.*\n\nclean:\n\trm -f sslh-fork sslh-select $(CONDITIONAL_TARGETS) echosrv version.h $(MAN) systemd-sslh-generator *.o *.gcov *.gcno *.gcda *.png *.html *.css *.info\n\techo \"// this is a placeholder for version.h, to make code-checking editors happy\" > version.h\n\ntags:\n\tctags --globals -T *.[ch]\n\ncscope:\n\t-find . -name \"*.[chS]\" >cscope.files\n\t-cscope -b -R\n\ntest:\n\t./t\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.0703125,
          "content": "sslh -- A ssl/ssh multiplexer\n=============================\n\n`sslh` accepts connections on specified ports, and forwards\nthem further based on tests performed on the first data\npacket sent by the remote client.\n\nProbes for HTTP, TLS/SSL (including SNI and ALPN), SSH,\nOpenVPN, tinc, XMPP, SOCKS5, are implemented, and any other\nprotocol that can be tested using a regular expression, can\nbe recognised. A typical use case is to allow serving\nseveral services on port 443 (e.g. to connect to SSH from\ninside a corporate firewall, which almost never block port\n443) while still serving HTTPS on that port.\n\nHence `sslh` acts as a protocol demultiplexer, or a\nswitchboard. With the SNI and ALPN probe, it makes a good\nfront-end to a virtual host farm hosted behind a single IP\naddress.\n\n`sslh` has the bells and whistles expected from a mature\ndaemon: privilege and capabilities dropping, inetd support,\nsystemd support, transparent proxying, chroot, logging,\nIPv4 and IPv6, TCP and UDP, a fork-based, a select-based\nmodel, and yet another based on libev for larger\ninstallations.\n\nInstall\n=======\n\nPlease refer to the [install guide](doc/INSTALL.md).\n\n\nConfiguration\n=============\n\nPlease refer to the [configuration guide](doc/config.md).\n\nTransparent proxying\n--------------------\n\nTransparent proxying allows the target server to see the\noriginal client IP address, i.e. `sslh` becomes invisible.\n\nThis means services behind `sslh` (Apache, `sshd` and so on)\nwill see the external IP and ports as if the external world\nconnected directly to them. This simplifies IP-based access\ncontrol (or makes it possible at all), and makes it possible\nto use IP-based banning tools such as `fail2ban`.\n\nThere are two methods. One uses additional virtual network\ninterfaces. The principle and basic setup is described\n[here](doc/simple_transparent_proxy.md), with further\nscenarios described [there](doc/scenarios-for-simple-transparent-proxy.md).\n\n\nAnother method uses iptable packet marking features, and is\nhighly dependent on your network environment and\ninfrastructure setup. There is no known generic approach,\nand if you do not find directions for your exact setup, you\nwill probably need an extensive knowledge of network\nmanagement and iptables setup\".\n\nIt is described in its own [document](doc/tproxy.md).\nIn most cases, you will be better off following the first\nmethod.\n\n\nDocker image\n------------\n\nHow to use\n\n---\n\n\n```bash\ndocker run \\\n  --cap-add CAP_NET_RAW \\\n  --cap-add CAP_NET_BIND_SERVICE \\\n  --rm \\\n  -it \\\n  ghcr.io/yrutschle/sslh:latest \\\n  --foreground \\\n  --listen=0.0.0.0:443 \\\n  --ssh=hostname:22 \\\n  --tls=hostname:443\n```\n\ndocker-compose example\n\n```yaml\nversion: \"3\"\n\nservices:\n  sslh:\n    image: ghcr.io/yrutschle/sslh:latest\n    hostname: sslh\n    ports:\n      - 443:443\n    command: --foreground --listen=0.0.0.0:443 --tls=nginx:443 --openvpn=openvpn:1194\n    depends_on:\n      - nginx\n      - openvpn\n\n  nginx:\n    image: nginx\n\n  openvpn:\n    image: openvpn\n```\n\nTransparent mode 1: using sslh container for networking\n\n_Note: For transparent mode to work, the sslh container must be able to reach your services via **localhost**_\n```yaml\nversion: \"3\"\n\nservices:\n  sslh:\n    build: https://github.com/yrutschle/sslh.git\n    container_name: sslh\n    environment:\n      - TZ=${TZ}\n    cap_add:\n      - NET_ADMIN\n      - NET_RAW\n      - NET_BIND_SERVICE\n    sysctls:\n      - net.ipv4.conf.default.route_localnet=1\n      - net.ipv4.conf.all.route_localnet=1\n    command: --transparent --foreground --listen=0.0.0.0:443 --tls=localhost:8443 --openvpn=localhost:1194\n    ports:\n      - 443:443 #sslh\n\n      - 80:80 #nginx\n      - 8443:8443 #nginx\n\n      - 1194:1194 #openvpn\n    extra_hosts:\n      - localbox:host-gateway\n    restart: unless-stopped\n\n  nginx:\n    image: nginx:latest\n    .....\n    network_mode: service:sslh #set nginx container to use sslh networking.\n    # ^^^ This is required. This makes nginx reachable by sslh via localhost\n  \n  openvpn:\n    image: openvpn:latest\n    .....\n    network_mode: service:sslh #set openvpn container to use sslh networking\n```\n\nTransparent mode 2: using host networking\n\n```yaml\nversion: \"3\"\n\nservices:\n  sslh:\n    build: https://github.com/yrutschle/sslh.git\n    container_name: sslh\n    environment:\n      - TZ=${TZ}\n    cap_add:\n      - NET_ADMIN\n      - NET_RAW\n      - NET_BIND_SERVICE\n    # must be set manually\n    #sysctls:\n    #  - net.ipv4.conf.default.route_localnet=1\n    #  - net.ipv4.conf.all.route_localnet=1\n    command: --transparent --foreground --listen=0.0.0.0:443 --tls=localhost:8443 --openvpn=localhost:1194\n    network_mode: host\n    restart: unless-stopped\n  \n  nginx:\n    image: nginx:latest\n    .....\n    ports:\n      - 8443:8443 # bind to docker host on port 8443\n\n  openvpn:\n    image: openvpn:latest\n    .....\n    ports:\n      - 1194:1194 # bind to docker host on port 1194\n```\n\nComments? Questions?\n====================\n\nYou can subscribe to the `sslh` mailing list here:\n<https://lists.rutschle.net/mailman/listinfo/sslh>\n\nThis mailing list should be used for discussion, feature\nrequests, and will be the preferred channel for announcements.\n\nOf course, check the [FAQ](doc/FAQ.md) first!\n\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.955078125,
          "content": "Here's a list of features that have been suggested or\nsometimes requested. This list is not a roadmap and\nshouldn't be construed to mean that any of this will happen.\n\n- configurable behaviour depending on services (e.g.\n  select() for ssl but fork() for ssh).\n\n- have certain services available only from specified subnets\n\n- some sort of \"service knocking\" allowing to activate a\n  service upon some external even, similar to port knocking;\nfor example, go to a specific URL to enable sslh forwarding\nto sshd for a set period of time:\n    * sslh listens on 443 and only directs to httpd\n    * user goes somewhere to https://example.org/open_ssh.cgi\n    * open_ssh.cgi tells sslh\n    * sslh starts checking if incoming connections are ssh, and\n    if they are, forward to sshd\n    * 10 minutes later, sslh stops forwarding to ssh\n\nThat would make it almost impossible for an observer\n(someone who'd telnet regularly on 443) to ever notice both\nservices are available on 443.\n\n\n"
        },
        {
          "name": "argtable3.c",
          "type": "blob",
          "size": 203.30078125,
          "content": "/*******************************************************************************\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#define ARG_AMALGAMATION\n\n/*******************************************************************************\n * argtable3_private: Declares private types, constants, and interfaces\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 2013-2019 Tom G. Huang\n * <tomghuang@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#ifndef ARG_UTILS_H\n#define ARG_UTILS_H\n\n#include <stdlib.h>\n\n#define ARG_ENABLE_TRACE 0\n#define ARG_ENABLE_LOG 1\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nenum { ARG_ERR_MINCOUNT = 1, ARG_ERR_MAXCOUNT, ARG_ERR_BADINT, ARG_ERR_OVERFLOW, ARG_ERR_BADDOUBLE, ARG_ERR_BADDATE, ARG_ERR_REGNOMATCH };\n\ntypedef void(arg_panicfn)(const char* fmt, ...);\n\n#if defined(_MSC_VER)\n#define ARG_TRACE(x)                                               \\\n    __pragma(warning(push)) __pragma(warning(disable : 4127)) do { \\\n        if (ARG_ENABLE_TRACE)                                      \\\n            dbg_printf x;                                          \\\n    }                                                              \\\n    while (0)                                                      \\\n    __pragma(warning(pop))\n\n#define ARG_LOG(x)                                                 \\\n    __pragma(warning(push)) __pragma(warning(disable : 4127)) do { \\\n        if (ARG_ENABLE_LOG)                                        \\\n            dbg_printf x;                                          \\\n    }                                                              \\\n    while (0)                                                      \\\n    __pragma(warning(pop))\n#else\n#define ARG_TRACE(x)          \\\n    do {                      \\\n        if (ARG_ENABLE_TRACE) \\\n            dbg_printf x;     \\\n    } while (0)\n\n#define ARG_LOG(x)          \\\n    do {                    \\\n        if (ARG_ENABLE_LOG) \\\n            dbg_printf x;   \\\n    } while (0)\n#endif\n\n/*\n * Rename a few generic names to unique names.\n * They can be a problem for the platforms like NuttX, where\n * the namespace is flat for everything including apps and libraries.\n */\n#define\txmalloc argtable3_xmalloc\n#define\txcalloc argtable3_xcalloc\n#define\txrealloc argtable3_xrealloc\n#define\txfree argtable3_xfree\n\nextern void dbg_printf(const char* fmt, ...);\nextern void arg_set_panic(arg_panicfn* proc);\nextern void* xmalloc(size_t size);\nextern void* xcalloc(size_t count, size_t size);\nextern void* xrealloc(void* ptr, size_t size);\nextern void xfree(void* ptr);\n\nstruct arg_hashtable_entry {\n    void *k, *v;\n    unsigned int h;\n    struct arg_hashtable_entry* next;\n};\n\ntypedef struct arg_hashtable {\n    unsigned int tablelength;\n    struct arg_hashtable_entry** table;\n    unsigned int entrycount;\n    unsigned int loadlimit;\n    unsigned int primeindex;\n    unsigned int (*hashfn)(const void* k);\n    int (*eqfn)(const void* k1, const void* k2);\n} arg_hashtable_t;\n\n/**\n * @brief Create a hash table.\n *\n * @param   minsize   minimum initial size of hash table\n * @param   hashfn    function for hashing keys\n * @param   eqfn      function for determining key equality\n * @return            newly created hash table or NULL on failure\n */\narg_hashtable_t* arg_hashtable_create(unsigned int minsize, unsigned int (*hashfn)(const void*), int (*eqfn)(const void*, const void*));\n\n/**\n * @brief This function will cause the table to expand if the insertion would take\n * the ratio of entries to table size over the maximum load factor.\n *\n * This function does not check for repeated insertions with a duplicate key.\n * The value returned when using a duplicate key is undefined -- when\n * the hash table changes size, the order of retrieval of duplicate key\n * entries is reversed.\n * If in doubt, remove before insert.\n *\n * @param   h   the hash table to insert into\n * @param   k   the key - hash table claims ownership and will free on removal\n * @param   v   the value - does not claim ownership\n * @return      non-zero for successful insertion\n */\nvoid arg_hashtable_insert(arg_hashtable_t* h, void* k, void* v);\n\n#define ARG_DEFINE_HASHTABLE_INSERT(fnname, keytype, valuetype) \\\n    int fnname(arg_hashtable_t* h, keytype* k, valuetype* v) { return arg_hashtable_insert(h, k, v); }\n\n/**\n * @brief Search the specified key in the hash table.\n *\n * @param   h   the hash table to search\n * @param   k   the key to search for  - does not claim ownership\n * @return      the value associated with the key, or NULL if none found\n */\nvoid* arg_hashtable_search(arg_hashtable_t* h, const void* k);\n\n#define ARG_DEFINE_HASHTABLE_SEARCH(fnname, keytype, valuetype) \\\n    valuetype* fnname(arg_hashtable_t* h, keytype* k) { return (valuetype*)(arg_hashtable_search(h, k)); }\n\n/**\n * @brief Remove the specified key from the hash table.\n *\n * @param   h   the hash table to remove the item from\n * @param   k   the key to search for  - does not claim ownership\n */\nvoid arg_hashtable_remove(arg_hashtable_t* h, const void* k);\n\n#define ARG_DEFINE_HASHTABLE_REMOVE(fnname, keytype, valuetype) \\\n    void fnname(arg_hashtable_t* h, keytype* k) { arg_hashtable_remove(h, k); }\n\n/**\n * @brief Return the number of keys in the hash table.\n *\n * @param   h   the hash table\n * @return      the number of items stored in the hash table\n */\nunsigned int arg_hashtable_count(arg_hashtable_t* h);\n\n/**\n * @brief Change the value associated with the key.\n *\n * function to change the value associated with a key, where there already\n * exists a value bound to the key in the hash table.\n * Source due to Holger Schemel.\n *\n * @name        hashtable_change\n * @param   h   the hash table\n * @param       key\n * @param       value\n */\nint arg_hashtable_change(arg_hashtable_t* h, void* k, void* v);\n\n/**\n * @brief Free the hash table and the memory allocated for each key-value pair.\n *\n * @param   h            the hash table\n * @param   free_values  whether to call 'free' on the remaining values\n */\nvoid arg_hashtable_destroy(arg_hashtable_t* h, int free_values);\n\ntypedef struct arg_hashtable_itr {\n    arg_hashtable_t* h;\n    struct arg_hashtable_entry* e;\n    struct arg_hashtable_entry* parent;\n    unsigned int index;\n} arg_hashtable_itr_t;\n\narg_hashtable_itr_t* arg_hashtable_itr_create(arg_hashtable_t* h);\n\nvoid arg_hashtable_itr_destroy(arg_hashtable_itr_t* itr);\n\n/**\n * @brief Return the value of the (key,value) pair at the current position.\n */\nextern void* arg_hashtable_itr_key(arg_hashtable_itr_t* i);\n\n/**\n * @brief Return the value of the (key,value) pair at the current position.\n */\nextern void* arg_hashtable_itr_value(arg_hashtable_itr_t* i);\n\n/**\n * @brief Advance the iterator to the next element. Returns zero if advanced to end of table.\n */\nint arg_hashtable_itr_advance(arg_hashtable_itr_t* itr);\n\n/**\n * @brief Remove current element and advance the iterator to the next element.\n */\nint arg_hashtable_itr_remove(arg_hashtable_itr_t* itr);\n\n/**\n * @brief Search and overwrite the supplied iterator, to point to the entry matching the supplied key.\n *\n * @return  Zero if not found.\n */\nint arg_hashtable_itr_search(arg_hashtable_itr_t* itr, arg_hashtable_t* h, void* k);\n\n#define ARG_DEFINE_HASHTABLE_ITERATOR_SEARCH(fnname, keytype) \\\n    int fnname(arg_hashtable_itr_t* i, arg_hashtable_t* h, keytype* k) { return (arg_hashtable_iterator_search(i, h, k)); }\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n/*******************************************************************************\n * arg_utils: Implements memory, panic, and other utility functions\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 2013-2019 Tom G. Huang\n * <tomghuang@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void panic(const char* fmt, ...);\nstatic arg_panicfn* s_panic = panic;\n\nvoid dbg_printf(const char* fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    vfprintf(stderr, fmt, args);\n    va_end(args);\n}\n\nstatic void panic(const char* fmt, ...) {\n    va_list args;\n    char* s;\n\n    va_start(args, fmt);\n    vfprintf(stderr, fmt, args);\n    va_end(args);\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4996)\n#endif\n    s = getenv(\"EF_DUMPCORE\");\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n    if (s != NULL && *s != '\\0') {\n        abort();\n    } else {\n        exit(EXIT_FAILURE);\n    }\n}\n\nvoid arg_set_panic(arg_panicfn* proc) {\n    s_panic = proc;\n}\n\nvoid* xmalloc(size_t size) {\n    void* ret = malloc(size);\n    if (!ret) {\n        s_panic(\"Out of memory!\\n\");\n    }\n    return ret;\n}\n\nvoid* xcalloc(size_t count, size_t size) {\n    size_t allocated_count = count && size ? count : 1;\n    size_t allocated_size = count && size ? size : 1;\n    void* ret = calloc(allocated_count, allocated_size);\n    if (!ret) {\n        s_panic(\"Out of memory!\\n\");\n    }\n    return ret;\n}\n\nvoid* xrealloc(void* ptr, size_t size) {\n    size_t allocated_size = size ? size : 1;\n    void* ret = realloc(ptr, allocated_size);\n    if (!ret) {\n        s_panic(\"Out of memory!\\n\");\n    }\n    return ret;\n}\n\nvoid xfree(void* ptr) {\n    free(ptr);\n}\n\nstatic void merge(void* data, int esize, int i, int j, int k, arg_comparefn* comparefn) {\n    char* a = (char*)data;\n    char* m;\n    int ipos, jpos, mpos;\n\n    /* Initialize the counters used in merging. */\n    ipos = i;\n    jpos = j + 1;\n    mpos = 0;\n\n    /* Allocate storage for the merged elements. */\n    m = (char*)xmalloc(esize * ((k - i) + 1));\n\n    /* Continue while either division has elements to merge. */\n    while (ipos <= j || jpos <= k) {\n        if (ipos > j) {\n            /* The left division has no more elements to merge. */\n            while (jpos <= k) {\n                memcpy(&m[mpos * esize], &a[jpos * esize], esize);\n                jpos++;\n                mpos++;\n            }\n\n            continue;\n        } else if (jpos > k) {\n            /* The right division has no more elements to merge. */\n            while (ipos <= j) {\n                memcpy(&m[mpos * esize], &a[ipos * esize], esize);\n                ipos++;\n                mpos++;\n            }\n\n            continue;\n        }\n\n        /* Append the next ordered element to the merged elements. */\n        if (comparefn(&a[ipos * esize], &a[jpos * esize]) < 0) {\n            memcpy(&m[mpos * esize], &a[ipos * esize], esize);\n            ipos++;\n            mpos++;\n        } else {\n            memcpy(&m[mpos * esize], &a[jpos * esize], esize);\n            jpos++;\n            mpos++;\n        }\n    }\n\n    /* Prepare to pass back the merged data. */\n    memcpy(&a[i * esize], m, esize * ((k - i) + 1));\n    xfree(m);\n}\n\nvoid arg_mgsort(void* data, int size, int esize, int i, int k, arg_comparefn* comparefn) {\n    int j;\n\n    /* Stop the recursion when no more divisions can be made. */\n    if (i < k) {\n        /* Determine where to divide the elements. */\n        j = (int)(((i + k - 1)) / 2);\n\n        /* Recursively sort the two divisions. */\n        arg_mgsort(data, size, esize, i, j, comparefn);\n        arg_mgsort(data, size, esize, j + 1, k, comparefn);\n        merge(data, esize, i, j, k, comparefn);\n    }\n}\n/*******************************************************************************\n * arg_hashtable: Implements the hash table utilities\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 2013-2019 Tom G. Huang\n * <tomghuang@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * This hash table module is adapted from the C hash table implementation by\n * Christopher Clark. Here is the copyright notice from the library:\n *\n * Copyright (c) 2002, Christopher Clark\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * * Neither the name of the original author; nor the names of any contributors\n * may be used to endorse or promote products derived from this software\n * without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER\n * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * Credit for primes table: Aaron Krowne\n * http://br.endernet.org/~akrowne/\n * http://planetmath.org/encyclopedia/GoodHashTablePrimes.html\n */\nstatic const unsigned int primes[] = {53,       97,       193,      389,       769,       1543,      3079,      6151,      12289,\n                                      24593,    49157,    98317,    196613,    393241,    786433,    1572869,   3145739,   6291469,\n                                      12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457, 1610612741};\nconst unsigned int prime_table_length = sizeof(primes) / sizeof(primes[0]);\nconst float max_load_factor = (float)0.65;\n\nstatic unsigned int enhanced_hash(arg_hashtable_t* h, const void* k) {\n    /*\n     * Aim to protect against poor hash functions by adding logic here.\n     * The logic is taken from Java 1.4 hash table source.\n     */\n    unsigned int i = h->hashfn(k);\n    i += ~(i << 9);\n    i ^= ((i >> 14) | (i << 18)); /* >>> */\n    i += (i << 4);\n    i ^= ((i >> 10) | (i << 22)); /* >>> */\n    return i;\n}\n\nstatic unsigned int index_for(unsigned int tablelength, unsigned int hashvalue) {\n    return (hashvalue % tablelength);\n}\n\narg_hashtable_t* arg_hashtable_create(unsigned int minsize, unsigned int (*hashfn)(const void*), int (*eqfn)(const void*, const void*)) {\n    arg_hashtable_t* h;\n    unsigned int pindex;\n    unsigned int size = primes[0];\n\n    /* Check requested hash table isn't too large */\n    if (minsize > (1u << 30))\n        return NULL;\n\n    /*\n     * Enforce size as prime. The reason is to avoid clustering of values\n     * into a small number of buckets (yes, distribution). A more even\n     *  distributed hash table will perform more consistently.\n     */\n    for (pindex = 0; pindex < prime_table_length; pindex++) {\n        if (primes[pindex] > minsize) {\n            size = primes[pindex];\n            break;\n        }\n    }\n\n    h = (arg_hashtable_t*)xmalloc(sizeof(arg_hashtable_t));\n    h->table = (struct arg_hashtable_entry**)xmalloc(sizeof(struct arg_hashtable_entry*) * size);\n    memset(h->table, 0, size * sizeof(struct arg_hashtable_entry*));\n    h->tablelength = size;\n    h->primeindex = pindex;\n    h->entrycount = 0;\n    h->hashfn = hashfn;\n    h->eqfn = eqfn;\n    h->loadlimit = (unsigned int)ceil(size * max_load_factor);\n    return h;\n}\n\nstatic int arg_hashtable_expand(arg_hashtable_t* h) {\n    /* Double the size of the table to accommodate more entries */\n    struct arg_hashtable_entry** newtable;\n    struct arg_hashtable_entry* e;\n    unsigned int newsize;\n    unsigned int i;\n    unsigned int index;\n\n    /* Check we're not hitting max capacity */\n    if (h->primeindex == (prime_table_length - 1))\n        return 0;\n    newsize = primes[++(h->primeindex)];\n\n    newtable = (struct arg_hashtable_entry**)xmalloc(sizeof(struct arg_hashtable_entry*) * newsize);\n    memset(newtable, 0, newsize * sizeof(struct arg_hashtable_entry*));\n    /*\n     * This algorithm is not 'stable': it reverses the list\n     * when it transfers entries between the tables\n     */\n    for (i = 0; i < h->tablelength; i++) {\n        while (NULL != (e = h->table[i])) {\n            h->table[i] = e->next;\n            index = index_for(newsize, e->h);\n            e->next = newtable[index];\n            newtable[index] = e;\n        }\n    }\n\n    xfree(h->table);\n    h->table = newtable;\n    h->tablelength = newsize;\n    h->loadlimit = (unsigned int)ceil(newsize * max_load_factor);\n    return -1;\n}\n\nunsigned int arg_hashtable_count(arg_hashtable_t* h) {\n    return h->entrycount;\n}\n\nvoid arg_hashtable_insert(arg_hashtable_t* h, void* k, void* v) {\n    /* This method allows duplicate keys - but they shouldn't be used */\n    unsigned int index;\n    struct arg_hashtable_entry* e;\n    if ((h->entrycount + 1) > h->loadlimit) {\n        /*\n         * Ignore the return value. If expand fails, we should\n         * still try cramming just this value into the existing table\n         * -- we may not have memory for a larger table, but one more\n         * element may be ok. Next time we insert, we'll try expanding again.\n         */\n        arg_hashtable_expand(h);\n    }\n    e = (struct arg_hashtable_entry*)xmalloc(sizeof(struct arg_hashtable_entry));\n    e->h = enhanced_hash(h, k);\n    index = index_for(h->tablelength, e->h);\n    e->k = k;\n    e->v = v;\n    e->next = h->table[index];\n    h->table[index] = e;\n    h->entrycount++;\n}\n\nvoid* arg_hashtable_search(arg_hashtable_t* h, const void* k) {\n    struct arg_hashtable_entry* e;\n    unsigned int hashvalue;\n    unsigned int index;\n\n    hashvalue = enhanced_hash(h, k);\n    index = index_for(h->tablelength, hashvalue);\n    e = h->table[index];\n    while (e != NULL) {\n        /* Check hash value to short circuit heavier comparison */\n        if ((hashvalue == e->h) && (h->eqfn(k, e->k)))\n            return e->v;\n        e = e->next;\n    }\n    return NULL;\n}\n\nvoid arg_hashtable_remove(arg_hashtable_t* h, const void* k) {\n    /*\n     * TODO: consider compacting the table when the load factor drops enough,\n     *       or provide a 'compact' method.\n     */\n\n    struct arg_hashtable_entry* e;\n    struct arg_hashtable_entry** pE;\n    unsigned int hashvalue;\n    unsigned int index;\n\n    hashvalue = enhanced_hash(h, k);\n    index = index_for(h->tablelength, hashvalue);\n    pE = &(h->table[index]);\n    e = *pE;\n    while (NULL != e) {\n        /* Check hash value to short circuit heavier comparison */\n        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) {\n            *pE = e->next;\n            h->entrycount--;\n            xfree(e->k);\n            xfree(e->v);\n            xfree(e);\n            return;\n        }\n        pE = &(e->next);\n        e = e->next;\n    }\n}\n\nvoid arg_hashtable_destroy(arg_hashtable_t* h, int free_values) {\n    unsigned int i;\n    struct arg_hashtable_entry *e, *f;\n    struct arg_hashtable_entry** table = h->table;\n    if (free_values) {\n        for (i = 0; i < h->tablelength; i++) {\n            e = table[i];\n            while (NULL != e) {\n                f = e;\n                e = e->next;\n                xfree(f->k);\n                xfree(f->v);\n                xfree(f);\n            }\n        }\n    } else {\n        for (i = 0; i < h->tablelength; i++) {\n            e = table[i];\n            while (NULL != e) {\n                f = e;\n                e = e->next;\n                xfree(f->k);\n                xfree(f);\n            }\n        }\n    }\n    xfree(h->table);\n    xfree(h);\n}\n\narg_hashtable_itr_t* arg_hashtable_itr_create(arg_hashtable_t* h) {\n    unsigned int i;\n    unsigned int tablelength;\n\n    arg_hashtable_itr_t* itr = (arg_hashtable_itr_t*)xmalloc(sizeof(arg_hashtable_itr_t));\n    itr->h = h;\n    itr->e = NULL;\n    itr->parent = NULL;\n    tablelength = h->tablelength;\n    itr->index = tablelength;\n    if (0 == h->entrycount)\n        return itr;\n\n    for (i = 0; i < tablelength; i++) {\n        if (h->table[i] != NULL) {\n            itr->e = h->table[i];\n            itr->index = i;\n            break;\n        }\n    }\n    return itr;\n}\n\nvoid arg_hashtable_itr_destroy(arg_hashtable_itr_t* itr) {\n    xfree(itr);\n}\n\nvoid* arg_hashtable_itr_key(arg_hashtable_itr_t* i) {\n    return i->e->k;\n}\n\nvoid* arg_hashtable_itr_value(arg_hashtable_itr_t* i) {\n    return i->e->v;\n}\n\nint arg_hashtable_itr_advance(arg_hashtable_itr_t* itr) {\n    unsigned int j;\n    unsigned int tablelength;\n    struct arg_hashtable_entry** table;\n    struct arg_hashtable_entry* next;\n\n    if (itr->e == NULL)\n        return 0; /* stupidity check */\n\n    next = itr->e->next;\n    if (NULL != next) {\n        itr->parent = itr->e;\n        itr->e = next;\n        return -1;\n    }\n\n    tablelength = itr->h->tablelength;\n    itr->parent = NULL;\n    if (tablelength <= (j = ++(itr->index))) {\n        itr->e = NULL;\n        return 0;\n    }\n\n    table = itr->h->table;\n    while (NULL == (next = table[j])) {\n        if (++j >= tablelength) {\n            itr->index = tablelength;\n            itr->e = NULL;\n            return 0;\n        }\n    }\n\n    itr->index = j;\n    itr->e = next;\n    return -1;\n}\n\nint arg_hashtable_itr_remove(arg_hashtable_itr_t* itr) {\n    struct arg_hashtable_entry* remember_e;\n    struct arg_hashtable_entry* remember_parent;\n    int ret;\n\n    /* Do the removal */\n    if ((itr->parent) == NULL) {\n        /* element is head of a chain */\n        itr->h->table[itr->index] = itr->e->next;\n    } else {\n        /* element is mid-chain */\n        itr->parent->next = itr->e->next;\n    }\n    /* itr->e is now outside the hashtable */\n    remember_e = itr->e;\n    itr->h->entrycount--;\n    xfree(remember_e->k);\n    xfree(remember_e->v);\n\n    /* Advance the iterator, correcting the parent */\n    remember_parent = itr->parent;\n    ret = arg_hashtable_itr_advance(itr);\n    if (itr->parent == remember_e) {\n        itr->parent = remember_parent;\n    }\n    xfree(remember_e);\n    return ret;\n}\n\nint arg_hashtable_itr_search(arg_hashtable_itr_t* itr, arg_hashtable_t* h, void* k) {\n    struct arg_hashtable_entry* e;\n    struct arg_hashtable_entry* parent;\n    unsigned int hashvalue;\n    unsigned int index;\n\n    hashvalue = enhanced_hash(h, k);\n    index = index_for(h->tablelength, hashvalue);\n\n    e = h->table[index];\n    parent = NULL;\n    while (e != NULL) {\n        /* Check hash value to short circuit heavier comparison */\n        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) {\n            itr->index = index;\n            itr->e = e;\n            itr->parent = parent;\n            itr->h = h;\n            return -1;\n        }\n        parent = e;\n        e = e->next;\n    }\n    return 0;\n}\n\nint arg_hashtable_change(arg_hashtable_t* h, void* k, void* v) {\n    struct arg_hashtable_entry* e;\n    unsigned int hashvalue;\n    unsigned int index;\n\n    hashvalue = enhanced_hash(h, k);\n    index = index_for(h->tablelength, hashvalue);\n    e = h->table[index];\n    while (e != NULL) {\n        /* Check hash value to short circuit heavier comparison */\n        if ((hashvalue == e->h) && (h->eqfn(k, e->k))) {\n            xfree(e->v);\n            e->v = v;\n            return -1;\n        }\n        e = e->next;\n    }\n    return 0;\n}\n/*******************************************************************************\n * arg_dstr: Implements the dynamic string utilities\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 2013-2019 Tom G. Huang\n * <tomghuang@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdarg.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4996)\n#endif\n\n#define START_VSNBUFF 16\n\n/*\n * This dynamic string module is adapted from TclResult.c in the Tcl library.\n * Here is the copyright notice from the library:\n *\n * This software is copyrighted by the Regents of the University of\n * California, Sun Microsystems, Inc., Scriptics Corporation, ActiveState\n * Corporation and other parties.  The following terms apply to all files\n * associated with the software unless explicitly disclaimed in\n * individual files.\n *\n * The authors hereby grant permission to use, copy, modify, distribute,\n * and license this software and its documentation for any purpose, provided\n * that existing copyright notices are retained in all copies and that this\n * notice is included verbatim in any distributions. No written agreement,\n * license, or royalty fee is required for any of the authorized uses.\n * Modifications to this software may be copyrighted by their authors\n * and need not follow the licensing terms described here, provided that\n * the new terms are clearly indicated on the first page of each file where\n * they apply.\n *\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY\n * FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n * ARISING OUT OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY\n * DERIVATIVES THEREOF, EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE\n * IS PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE\n * NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\n * MODIFICATIONS.\n *\n * GOVERNMENT USE: If you are acquiring this software on behalf of the\n * U.S. government, the Government shall have only \"Restricted Rights\"\n * in the software and related documentation as defined in the Federal\n * Acquisition Regulations (FARs) in Clause 52.227.19 (c) (2).  If you\n * are acquiring the software on behalf of the Department of Defense, the\n * software shall be classified as \"Commercial Computer Software\" and the\n * Government shall have only \"Restricted Rights\" as defined in Clause\n * 252.227-7014 (b) (3) of DFARs.  Notwithstanding the foregoing, the\n * authors grant the U.S. Government and others acting in its behalf\n * permission to use and distribute the software in accordance with the\n * terms specified in this license.\n */\n\ntypedef struct _internal_arg_dstr {\n    char* data;\n    arg_dstr_freefn* free_proc;\n    char sbuf[ARG_DSTR_SIZE + 1];\n    char* append_data;\n    int append_data_size;\n    int append_used;\n} _internal_arg_dstr_t;\n\nstatic void setup_append_buf(arg_dstr_t res, int newSpace);\n\narg_dstr_t arg_dstr_create(void) {\n    _internal_arg_dstr_t* h = (_internal_arg_dstr_t*)xmalloc(sizeof(_internal_arg_dstr_t));\n    memset(h, 0, sizeof(_internal_arg_dstr_t));\n    h->sbuf[0] = 0;\n    h->data = h->sbuf;\n    h->free_proc = ARG_DSTR_STATIC;\n    return h;\n}\n\nvoid arg_dstr_destroy(arg_dstr_t ds) {\n    if (ds == NULL)\n        return;\n\n    arg_dstr_reset(ds);\n    xfree(ds);\n    return;\n}\n\nvoid arg_dstr_set(arg_dstr_t ds, char* str, arg_dstr_freefn* free_proc) {\n    int length;\n    register arg_dstr_freefn* old_free_proc = ds->free_proc;\n    char* old_result = ds->data;\n\n    if (str == NULL) {\n        ds->sbuf[0] = 0;\n        ds->data = ds->sbuf;\n        ds->free_proc = ARG_DSTR_STATIC;\n    } else if (free_proc == ARG_DSTR_VOLATILE) {\n        length = (int)strlen(str);\n        if (length > ARG_DSTR_SIZE) {\n            ds->data = (char*)xmalloc((unsigned)length + 1);\n            ds->free_proc = ARG_DSTR_DYNAMIC;\n        } else {\n            ds->data = ds->sbuf;\n            ds->free_proc = ARG_DSTR_STATIC;\n        }\n        strcpy(ds->data, str);\n    } else {\n        ds->data = str;\n        ds->free_proc = free_proc;\n    }\n\n    /*\n     * If the old result was dynamically-allocated, free it up. Do it here,\n     * rather than at the beginning, in case the new result value was part of\n     * the old result value.\n     */\n\n    if ((old_free_proc != 0) && (old_result != ds->data)) {\n        if (old_free_proc == ARG_DSTR_DYNAMIC) {\n            xfree(old_result);\n        } else {\n            (*old_free_proc)(old_result);\n        }\n    }\n\n    if ((ds->append_data != NULL) && (ds->append_data_size > 0)) {\n        xfree(ds->append_data);\n        ds->append_data = NULL;\n        ds->append_data_size = 0;\n    }\n}\n\nchar* arg_dstr_cstr(arg_dstr_t ds) /* Interpreter whose result to return. */\n{\n    return ds->data;\n}\n\nvoid arg_dstr_cat(arg_dstr_t ds, const char* str) {\n    setup_append_buf(ds, (int)strlen(str) + 1);\n    memcpy(ds->data + strlen(ds->data), str, strlen(str));\n}\n\nvoid arg_dstr_catc(arg_dstr_t ds, char c) {\n    setup_append_buf(ds, 2);\n    memcpy(ds->data + strlen(ds->data), &c, 1);\n}\n\n/*\n * The logic of the `arg_dstr_catf` function is adapted from the `bformat`\n * function in The Better String Library by Paul Hsieh. Here is the copyright\n * notice from the library:\n *\n * Copyright (c) 2014, Paul Hsieh\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of bstrlib nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nvoid arg_dstr_catf(arg_dstr_t ds, const char* fmt, ...) {\n    va_list arglist;\n    char* buff;\n    int n, r;\n    size_t slen;\n\n    if (fmt == NULL)\n        return;\n\n    /* Since the length is not determinable beforehand, a search is\n       performed using the truncating \"vsnprintf\" call (to avoid buffer\n       overflows) on increasing potential sizes for the output result. */\n\n    if ((n = (int)(2 * strlen(fmt))) < START_VSNBUFF)\n        n = START_VSNBUFF;\n\n    buff = (char*)xmalloc(n + 2);\n    memset(buff, 0, n + 2);\n\n    for (;;) {\n        va_start(arglist, fmt);\n        r = vsnprintf(buff, n + 1, fmt, arglist);\n        va_end(arglist);\n\n        slen = strlen(buff);\n        if (slen < (size_t)n)\n            break;\n\n        if (r > n)\n            n = r;\n        else\n            n += n;\n\n        xfree(buff);\n        buff = (char*)xmalloc(n + 2);\n        memset(buff, 0, n + 2);\n    }\n\n    arg_dstr_cat(ds, buff);\n    xfree(buff);\n}\n\nstatic void setup_append_buf(arg_dstr_t ds, int new_space) {\n    int total_space;\n\n    /*\n     * Make the append buffer larger, if that's necessary, then copy the\n     * data into the append buffer and make the append buffer the official\n     * data.\n     */\n    if (ds->data != ds->append_data) {\n        /*\n         * If the buffer is too big, then free it up so we go back to a\n         * smaller buffer. This avoids tying up memory forever after a large\n         * operation.\n         */\n        if (ds->append_data_size > 500) {\n            xfree(ds->append_data);\n            ds->append_data = NULL;\n            ds->append_data_size = 0;\n        }\n        ds->append_used = (int)strlen(ds->data);\n    } else if (ds->data[ds->append_used] != 0) {\n        /*\n         * Most likely someone has modified a result created by\n         * arg_dstr_cat et al. so that it has a different size. Just\n         * recompute the size.\n         */\n        ds->append_used = (int)strlen(ds->data);\n    }\n\n    total_space = new_space + ds->append_used;\n    if (total_space >= ds->append_data_size) {\n        char* newbuf;\n\n        if (total_space < 100) {\n            total_space = 200;\n        } else {\n            total_space *= 2;\n        }\n        newbuf = (char*)xmalloc((unsigned)total_space);\n        memset(newbuf, 0, total_space);\n        strcpy(newbuf, ds->data);\n        if (ds->append_data != NULL) {\n            xfree(ds->append_data);\n        }\n        ds->append_data = newbuf;\n        ds->append_data_size = total_space;\n    } else if (ds->data != ds->append_data) {\n        strcpy(ds->append_data, ds->data);\n    }\n\n    arg_dstr_free(ds);\n    ds->data = ds->append_data;\n}\n\nvoid arg_dstr_free(arg_dstr_t ds) {\n    if (ds->free_proc != NULL) {\n        if (ds->free_proc == ARG_DSTR_DYNAMIC) {\n            xfree(ds->data);\n        } else {\n            (*ds->free_proc)(ds->data);\n        }\n        ds->free_proc = NULL;\n    }\n}\n\nvoid arg_dstr_reset(arg_dstr_t ds) {\n    arg_dstr_free(ds);\n    if ((ds->append_data != NULL) && (ds->append_data_size > 0)) {\n        xfree(ds->append_data);\n        ds->append_data = NULL;\n        ds->append_data_size = 0;\n    }\n\n    ds->data = ds->sbuf;\n    ds->sbuf[0] = 0;\n}\n\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n/*\t$NetBSD: getopt.h,v 1.4 2000/07/07 10:43:54 ad Exp $\t*/\n/*\t$FreeBSD$ */\n\n/*-\n * SPDX-License-Identifier: BSD-2-Clause-NetBSD\n *\n * Copyright (c) 2000 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code is derived from software contributed to The NetBSD Foundation\n * by Dieter Baron and Thomas Klausner.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#if ARG_REPLACE_GETOPT == 1\n\n#ifndef _GETOPT_H_\n#define _GETOPT_H_\n\n/*\n * GNU-like getopt_long()/getopt_long_only() with 4.4BSD optreset extension.\n * getopt() is declared here too for GNU programs.\n */\n#define no_argument        0\n#define required_argument  1\n#define optional_argument  2\n\nstruct option {\n\t/* name of long option */\n\tconst char *name;\n\t/*\n\t * one of no_argument, required_argument, and optional_argument:\n\t * whether option takes an argument\n\t */\n\tint has_arg;\n\t/* if not NULL, set *flag to val when option found */\n\tint *flag;\n\t/* if flag not NULL, value to set *flag to; else return value */\n\tint val;\n};\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint\tgetopt_long(int, char * const *, const char *,\n\tconst struct option *, int *);\nint\tgetopt_long_only(int, char * const *, const char *,\n\tconst struct option *, int *);\n#ifndef _GETOPT_DECLARED\n#define\t_GETOPT_DECLARED\nint getopt(int, char * const [], const char *);\n\nextern char *optarg;\t\t\t/* getopt(3) external variables */\nextern int optind, opterr, optopt;\n#endif\n#ifndef _OPTRESET_DECLARED\n#define\t_OPTRESET_DECLARED\nextern int optreset;\t\t\t/* getopt(3) external variable */\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n \n#endif /* !_GETOPT_H_ */\n\n#endif /* ARG_REPLACE_GETOPT == 1 */\n/*\t$OpenBSD: getopt_long.c,v 1.26 2013/06/08 22:47:56 millert Exp $\t*/\n/*\t$NetBSD: getopt_long.c,v 1.15 2002/01/31 22:43:40 tv Exp $\t*/\n\n/*\n * Copyright (c) 2002 Todd C. Miller <Todd.Miller@courtesan.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n * Sponsored in part by the Defense Advanced Research Projects\n * Agency (DARPA) and Air Force Research Laboratory, Air Force\n * Materiel Command, USAF, under agreement number F39502-99-1-0512.\n */\n/*-\n * Copyright (c) 2000 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code is derived from software contributed to The NetBSD Foundation\n * by Dieter Baron and Thomas Klausner.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"argtable3.h\"\n\n#if ARG_REPLACE_GETOPT == 1\n\n#ifndef ARG_AMALGAMATION\n#include \"arg_getopt.h\"\n#endif\n\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define GNU_COMPATIBLE\t\t/* Be more compatible, configure's use us! */\n\nint\topterr = 1;\t\t/* if error message should be printed */\nint\toptind = 1;\t\t/* index into parent argv vector */\nint\toptopt = '?';\t/* character checked for validity */\nint\toptreset;\t\t/* reset getopt */\nchar *optarg;\t\t/* argument associated with option */\n\n#define PRINT_ERROR\t((opterr) && (*options != ':'))\n\n#define FLAG_PERMUTE\t0x01\t/* permute non-options to the end of argv */\n#define FLAG_ALLARGS\t0x02\t/* treat non-options as args to option \"-1\" */\n#define FLAG_LONGONLY\t0x04\t/* operate as getopt_long_only */\n\n/* return values */\n#define\tBADCH\t\t(int)'?'\n#define\tBADARG\t\t((*options == ':') ? (int)':' : (int)'?')\n#define\tINORDER \t(int)1\n\n#define\tEMSG\t\t\"\"\n\n#ifdef GNU_COMPATIBLE\n#define NO_PREFIX\t(-1)\n#define D_PREFIX\t0\n#define DD_PREFIX\t1\n#define W_PREFIX\t2\n#endif\n\nstatic int getopt_internal(int, char * const *, const char *,\n\t\t\t   const struct option *, int *, int);\nstatic int parse_long_options(char * const *, const char *,\n\t\t\t      const struct option *, int *, int, int);\nstatic int gcd(int, int);\nstatic void permute_args(int, int, int, char * const *);\n\nstatic char *place = EMSG; /* option letter processing */\n\n/* XXX: set optreset to 1 rather than these two */\nstatic int nonopt_start = -1; /* first non option argument (for permute) */\nstatic int nonopt_end = -1;   /* first option after non options (for permute) */\n\n/* Error messages */\nstatic const char recargchar[] = \"option requires an argument -- %c\";\nstatic const char illoptchar[] = \"illegal option -- %c\"; /* From P1003.2 */\n#ifdef GNU_COMPATIBLE\nstatic int dash_prefix = NO_PREFIX;\nstatic const char gnuoptchar[] = \"invalid option -- %c\";\n\nstatic const char recargstring[] = \"option `%s%s' requires an argument\";\nstatic const char ambig[] = \"option `%s%.*s' is ambiguous\";\nstatic const char noarg[] = \"option `%s%.*s' doesn't allow an argument\";\nstatic const char illoptstring[] = \"unrecognized option `%s%s'\";\n#else\nstatic const char recargstring[] = \"option requires an argument -- %s\";\nstatic const char ambig[] = \"ambiguous option -- %.*s\";\nstatic const char noarg[] = \"option doesn't take an argument -- %.*s\";\nstatic const char illoptstring[] = \"unknown option -- %s\";\n#endif\n\n#ifdef _WIN32\n\n/*\n * Windows needs warnx().  We change the definition though:\n *  1. (another) global is defined, opterrmsg, which holds the error message\n *  2. errors are always printed out on stderr w/o the program name\n * Note that opterrmsg always gets set no matter what opterr is set to.  The\n * error message will not be printed if opterr is 0 as usual.\n */\n\n#include <stdarg.h>\n#include <stdio.h>\n\n#define MAX_OPTERRMSG_SIZE 128\n\nextern char opterrmsg[MAX_OPTERRMSG_SIZE];\nchar opterrmsg[MAX_OPTERRMSG_SIZE]; /* buffer for the last error message */\n\nstatic void warnx(const char* fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n\n    /*\n     * Make sure opterrmsg is always zero-terminated despite the _vsnprintf()\n     * implementation specifics and manually suppress the warning.\n     */\n    memset(opterrmsg, 0, sizeof(opterrmsg));\n    if (fmt != NULL)\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n        _vsnprintf_s(opterrmsg, sizeof(opterrmsg), sizeof(opterrmsg) - 1, fmt, ap);\n#else\n        _vsnprintf(opterrmsg, sizeof(opterrmsg) - 1, fmt, ap);\n#endif\n\n    va_end(ap);\n\n#ifdef _MSC_VER\n#pragma warning(suppress : 6053)\n#endif\n    fprintf(stderr, \"%s\\n\", opterrmsg);\n}\n\n#else\n#include <err.h>\n#endif /*_WIN32*/\n/*\n * Compute the greatest common divisor of a and b.\n */\nstatic int\ngcd(int a, int b)\n{\n\tint c;\n\n\tc = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\n\treturn (b);\n}\n\n/*\n * Exchange the block from nonopt_start to nonopt_end with the block\n * from nonopt_end to opt_end (keeping the same order of arguments\n * in each block).\n */\nstatic void\npermute_args(int panonopt_start, int panonopt_end, int opt_end,\n\tchar * const *nargv)\n{\n\tint cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;\n\tchar *swap;\n\n\t/*\n\t * compute lengths of blocks and number and size of cycles\n\t */\n\tnnonopts = panonopt_end - panonopt_start;\n\tnopts = opt_end - panonopt_end;\n\tncycle = gcd(nnonopts, nopts);\n\tcyclelen = (opt_end - panonopt_start) / ncycle;\n\n\tfor (i = 0; i < ncycle; i++) {\n\t\tcstart = panonopt_end+i;\n\t\tpos = cstart;\n\t\tfor (j = 0; j < cyclelen; j++) {\n\t\t\tif (pos >= panonopt_end)\n\t\t\t\tpos -= nnonopts;\n\t\t\telse\n\t\t\t\tpos += nopts;\n\t\t\tswap = nargv[pos];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **) nargv)[pos] = nargv[cstart];\n\t\t\t/* LINTED const cast */\n\t\t\t((char **)nargv)[cstart] = swap;\n\t\t}\n\t}\n}\n\n/*\n * parse_long_options --\n *\tParse long options in argc/argv argument vector.\n * Returns -1 if short_too is set and the option does not match long_options.\n */\nstatic int\nparse_long_options(char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int short_too, int flags)\n{\n\tchar *current_argv, *has_equal;\n#ifdef GNU_COMPATIBLE\n\tchar *current_dash;\n#endif\n\tsize_t current_argv_len;\n\tint i, match, exact_match, second_partial_match;\n\n\tcurrent_argv = place;\n#ifdef GNU_COMPATIBLE\n\tswitch (dash_prefix) {\n\t\tcase D_PREFIX:\n\t\t\tcurrent_dash = \"-\";\n\t\t\tbreak;\n\t\tcase DD_PREFIX:\n\t\t\tcurrent_dash = \"--\";\n\t\t\tbreak;\n\t\tcase W_PREFIX:\n\t\t\tcurrent_dash = \"-W \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcurrent_dash = \"\";\n\t\t\tbreak;\n\t}\n#endif\n\tmatch = -1;\n\texact_match = 0;\n\tsecond_partial_match = 0;\n\n\toptind++;\n\n\tif ((has_equal = strchr(current_argv, '=')) != NULL) {\n\t\t/* argument found (--option=arg) */\n\t\tcurrent_argv_len = has_equal - current_argv;\n\t\thas_equal++;\n\t} else\n\t\tcurrent_argv_len = strlen(current_argv);\n\n\tfor (i = 0; long_options[i].name; i++) {\n\t\t/* find matching long option */\n\t\tif (strncmp(current_argv, long_options[i].name,\n\t\t    current_argv_len))\n\t\t\tcontinue;\n\n\t\tif (strlen(long_options[i].name) == current_argv_len) {\n\t\t\t/* exact match */\n\t\t\tmatch = i;\n\t\t\texact_match = 1;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * If this is a known short option, don't allow\n\t\t * a partial match of a single character.\n\t\t */\n\t\tif (short_too && current_argv_len == 1)\n\t\t\tcontinue;\n\n\t\tif (match == -1)\t/* first partial match */\n\t\t\tmatch = i;\n\t\telse if ((flags & FLAG_LONGONLY) ||\n\t\t\t long_options[i].has_arg !=\n\t\t\t     long_options[match].has_arg ||\n\t\t\t long_options[i].flag != long_options[match].flag ||\n\t\t\t long_options[i].val != long_options[match].val)\n\t\t\tsecond_partial_match = 1;\n\t}\n\tif (!exact_match && second_partial_match) {\n\t\t/* ambiguous abbreviation */\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(ambig,\n#ifdef GNU_COMPATIBLE\n\t\t\t     current_dash,\n#endif\n\t\t\t     (int)current_argv_len,\n\t\t\t     current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (match != -1) {\t\t/* option found */\n\t\tif (long_options[match].has_arg == no_argument\n\t\t    && has_equal) {\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(noarg,\n#ifdef GNU_COMPATIBLE\n\t\t\t\t     current_dash,\n#endif\n\t\t\t\t     (int)current_argv_len,\n\t\t\t\t     current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n#ifdef GNU_COMPATIBLE\n\t\t\treturn (BADCH);\n#else\n\t\t\treturn (BADARG);\n#endif\n\t\t}\n\t\tif (long_options[match].has_arg == required_argument ||\n\t\t    long_options[match].has_arg == optional_argument) {\n\t\t\tif (has_equal)\n\t\t\t\toptarg = has_equal;\n\t\t\telse if (long_options[match].has_arg ==\n\t\t\t    required_argument) {\n\t\t\t\t/*\n\t\t\t\t * optional argument doesn't use next nargv\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t}\n\t\t}\n\t\tif ((long_options[match].has_arg == required_argument)\n\t\t    && (optarg == NULL)) {\n\t\t\t/*\n\t\t\t * Missing argument; leading ':' indicates no error\n\t\t\t * should be generated.\n\t\t\t */\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargstring,\n#ifdef GNU_COMPATIBLE\n\t\t\t\t    current_dash,\n#endif\n\t\t\t\t    current_argv);\n\t\t\t/*\n\t\t\t * XXX: GNU sets optopt to val regardless of flag\n\t\t\t */\n\t\t\tif (long_options[match].flag == NULL)\n\t\t\t\toptopt = long_options[match].val;\n\t\t\telse\n\t\t\t\toptopt = 0;\n\t\t\t--optind;\n\t\t\treturn (BADARG);\n\t\t}\n\t} else {\t\t\t/* unknown option */\n\t\tif (short_too) {\n\t\t\t--optind;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptstring,\n#ifdef GNU_COMPATIBLE\n\t\t\t      current_dash,\n#endif\n\t\t\t      current_argv);\n\t\toptopt = 0;\n\t\treturn (BADCH);\n\t}\n\tif (idx)\n\t\t*idx = match;\n\tif (long_options[match].flag) {\n\t\t*long_options[match].flag = long_options[match].val;\n\t\treturn (0);\n\t} else\n\t\treturn (long_options[match].val);\n}\n\n/*\n * getopt_internal --\n *\tParse argc/argv argument vector.  Called by user level routines.\n */\nstatic int\ngetopt_internal(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx, int flags)\n{\n\tchar *oli;\t\t\t\t/* option letter list index */\n\tint optchar, short_too;\n\tstatic int posixly_correct = -1;\n\n\tif (options == NULL)\n\t\treturn (-1);\n\n\t/*\n\t * XXX Some GNU programs (like cvs) set optind to 0 instead of\n\t * XXX using optreset.  Work around this braindamage.\n\t */\n\tif (optind == 0)\n\t\toptind = optreset = 1;\n\n\t/*\n\t * Disable GNU extensions if POSIXLY_CORRECT is set or options\n\t * string begins with a '+'.\n\t */\n\tif (posixly_correct == -1 || optreset) {\n#if defined(_WIN32) && ((defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__)))\n\t\tsize_t requiredSize;\n\t\tgetenv_s(&requiredSize, NULL, 0, \"POSIXLY_CORRECT\");\n\t\tposixly_correct = requiredSize != 0;\n#else\n\t\tposixly_correct = (getenv(\"POSIXLY_CORRECT\") != NULL);\n#endif\n\t}\n\n\tif (*options == '-')\n\t\tflags |= FLAG_ALLARGS;\n\telse if (posixly_correct || *options == '+')\n\t\tflags &= ~FLAG_PERMUTE;\n\tif (*options == '+' || *options == '-')\n\t\toptions++;\n\n\toptarg = NULL;\n\tif (optreset)\n\t\tnonopt_start = nonopt_end = -1;\nstart:\n\tif (optreset || !*place) {\t\t/* update scanning pointer */\n\t\toptreset = 0;\n\t\tif (optind >= nargc) {          /* end of argument vector */\n\t\t\tplace = EMSG;\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\t/* do permutation, if we have to */\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\telse if (nonopt_start != -1) {\n\t\t\t\t/*\n\t\t\t\t * If we skipped non-options, set optind\n\t\t\t\t * to the first of them.\n\t\t\t\t */\n\t\t\t\toptind = nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t\tif (*(place = nargv[optind]) != '-' ||\n#ifdef GNU_COMPATIBLE\n\t\t    place[1] == '\\0') {\n#else\n\t\t    (place[1] == '\\0' && strchr(options, '-') == NULL)) {\n#endif\n\t\t\tplace = EMSG;\t\t/* found non-option */\n\t\t\tif (flags & FLAG_ALLARGS) {\n\t\t\t\t/*\n\t\t\t\t * GNU extension:\n\t\t\t\t * return non-option as argument to option 1\n\t\t\t\t */\n\t\t\t\toptarg = nargv[optind++];\n\t\t\t\treturn (INORDER);\n\t\t\t}\n\t\t\tif (!(flags & FLAG_PERMUTE)) {\n\t\t\t\t/*\n\t\t\t\t * If no permutation wanted, stop parsing\n\t\t\t\t * at first non-option.\n\t\t\t\t */\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\t/* do permutation */\n\t\t\tif (nonopt_start == -1)\n\t\t\t\tnonopt_start = optind;\n\t\t\telse if (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\tnonopt_start = optind -\n\t\t\t\t    (nonopt_end - nonopt_start);\n\t\t\t\tnonopt_end = -1;\n\t\t\t}\n\t\t\toptind++;\n\t\t\t/* process next argument */\n\t\t\tgoto start;\n\t\t}\n\t\tif (nonopt_start != -1 && nonopt_end == -1)\n\t\t\tnonopt_end = optind;\n\n\t\t/*\n\t\t * If we have \"-\" do nothing, if \"--\" we are done.\n\t\t */\n\t\tif (place[1] != '\\0' && *++place == '-' && place[1] == '\\0') {\n\t\t\toptind++;\n\t\t\tplace = EMSG;\n\t\t\t/*\n\t\t\t * We found an option (--), so if we skipped\n\t\t\t * non-options, we have to permute.\n\t\t\t */\n\t\t\tif (nonopt_end != -1) {\n\t\t\t\tpermute_args(nonopt_start, nonopt_end,\n\t\t\t\t    optind, nargv);\n\t\t\t\toptind -= nonopt_end - nonopt_start;\n\t\t\t}\n\t\t\tnonopt_start = nonopt_end = -1;\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\t/*\n\t * Check long options if:\n\t *  1) we were passed some\n\t *  2) the arg is not just \"-\"\n\t *  3) either the arg starts with -- we are getopt_long_only()\n\t */\n\tif (long_options != NULL && place != nargv[optind] &&\n\t    (*place == '-' || (flags & FLAG_LONGONLY))) {\n\t\tshort_too = 0;\n#ifdef GNU_COMPATIBLE\n\t\tdash_prefix = D_PREFIX;\n#endif\n\t\tif (*place == '-') {\n\t\t\tplace++;\t\t/* --foo long option */\n\t\t\tif (*place == '\\0')\n\t\t\t\treturn (BADARG);\t/* malformed option */\n#ifdef GNU_COMPATIBLE\n\t\t\tdash_prefix = DD_PREFIX;\n#endif\n\t\t} else if (*place != ':' && strchr(options, *place) != NULL)\n\t\t\tshort_too = 1;\t\t/* could be short option too */\n\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, short_too, flags);\n\t\tif (optchar != -1) {\n\t\t\tplace = EMSG;\n\t\t\treturn (optchar);\n\t\t}\n\t}\n\n\tif ((optchar = (int)*place++) == (int)':' ||\n\t    (optchar == (int)'-' && *place != '\\0') ||\n\t    (oli = strchr(options, optchar)) == NULL) {\n\t\t/*\n\t\t * If the user specified \"-\" and  '-' isn't listed in\n\t\t * options, return -1 (non-option) as per POSIX.\n\t\t * Otherwise, it is an unknown option character (or ':').\n\t\t */\n\t\tif (optchar == (int)'-' && *place == '\\0')\n\t\t\treturn (-1);\n\t\tif (!*place)\n\t\t\t++optind;\n#ifdef GNU_COMPATIBLE\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(posixly_correct ? illoptchar : gnuoptchar,\n\t\t\t      optchar);\n#else\n\t\tif (PRINT_ERROR)\n\t\t\twarnx(illoptchar, optchar);\n#endif\n\t\toptopt = optchar;\n\t\treturn (BADCH);\n\t}\n\tif (long_options != NULL && optchar == 'W' && oli[1] == ';') {\n\t\t/* -W long-option */\n\t\tif (*place)\t\t\t/* no space */\n\t\t\t/* NOTHING */;\n\t\telse if (++optind >= nargc) {\t/* no arg */\n\t\t\tplace = EMSG;\n\t\t\tif (PRINT_ERROR)\n\t\t\t\twarnx(recargchar, optchar);\n\t\t\toptopt = optchar;\n\t\t\treturn (BADARG);\n\t\t} else\t\t\t\t/* white space */\n\t\t\tplace = nargv[optind];\n#ifdef GNU_COMPATIBLE\n\t\tdash_prefix = W_PREFIX;\n#endif\n\t\toptchar = parse_long_options(nargv, options, long_options,\n\t\t    idx, 0, flags);\n\t\tplace = EMSG;\n\t\treturn (optchar);\n\t}\n\tif (*++oli != ':') {\t\t\t/* doesn't take argument */\n\t\tif (!*place)\n\t\t\t++optind;\n\t} else {\t\t\t\t/* takes (optional) argument */\n\t\toptarg = NULL;\n\t\tif (*place)\t\t\t/* no white space */\n\t\t\toptarg = place;\n\t\telse if (oli[1] != ':') {\t/* arg not optional */\n\t\t\tif (++optind >= nargc) {\t/* no arg */\n\t\t\t\tplace = EMSG;\n\t\t\t\tif (PRINT_ERROR)\n\t\t\t\t\twarnx(recargchar, optchar);\n\t\t\t\toptopt = optchar;\n\t\t\t\treturn (BADARG);\n\t\t\t} else\n\t\t\t\toptarg = nargv[optind];\n\t\t}\n\t\tplace = EMSG;\n\t\t++optind;\n\t}\n\t/* dump back option letter */\n\treturn (optchar);\n}\n\n/*\n * getopt --\n *\tParse argc/argv argument vector.\n *\n * [eventually this will replace the BSD getopt]\n */\nint\ngetopt(int nargc, char * const *nargv, const char *options)\n{\n\n\t/*\n\t * We don't pass FLAG_PERMUTE to getopt_internal() since\n\t * the BSD getopt(3) (unlike GNU) has never done this.\n\t *\n\t * Furthermore, since many privileged programs call getopt()\n\t * before dropping privileges it makes sense to keep things\n\t * as simple (and bug-free) as possible.\n\t */\n\treturn (getopt_internal(nargc, nargv, options, NULL, NULL, 0));\n}\n\n/*\n * getopt_long --\n *\tParse argc/argv argument vector.\n */\nint\ngetopt_long(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE));\n}\n\n/*\n * getopt_long_only --\n *\tParse argc/argv argument vector.\n */\nint\ngetopt_long_only(int nargc, char * const *nargv, const char *options,\n\tconst struct option *long_options, int *idx)\n{\n\n\treturn (getopt_internal(nargc, nargv, options, long_options, idx,\n\t    FLAG_PERMUTE|FLAG_LONGONLY));\n}\n\n#endif /* ARG_REPLACE_GETOPT == 1 */\n/*******************************************************************************\n * arg_date: Implements the date command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\nchar* arg_strptime(const char* buf, const char* fmt, struct tm* tm);\n\nstatic void arg_date_resetfn(struct arg_date* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\nstatic int arg_date_scanfn(struct arg_date* parent, const char* argval) {\n    int errorcode = 0;\n\n    if (parent->count == parent->hdr.maxcount) {\n        errorcode = ARG_ERR_MAXCOUNT;\n    } else if (!argval) {\n        /* no argument value was given, leave parent->tmval[] unaltered but still count it */\n        parent->count++;\n    } else {\n        const char* pend;\n        struct tm tm = parent->tmval[parent->count];\n\n        /* parse the given argument value, store result in parent->tmval[] */\n        pend = arg_strptime(argval, parent->format, &tm);\n        if (pend && pend[0] == '\\0')\n            parent->tmval[parent->count++] = tm;\n        else\n            errorcode = ARG_ERR_BADDATE;\n    }\n\n    ARG_TRACE((\"%s:scanfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic int arg_date_checkfn(struct arg_date* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n\n    ARG_TRACE((\"%s:checkfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic void arg_date_errorfn(struct arg_date* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    /* make argval NULL safe */\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_cat(ds, \"missing option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_cat(ds, \"excess option \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n\n        case ARG_ERR_BADDATE: {\n            struct tm tm;\n            char buff[200];\n\n            arg_dstr_catf(ds, \"illegal timestamp format \\\"%s\\\"\\n\", argval);\n            memset(&tm, 0, sizeof(tm));\n            arg_strptime(\"1999-12-31 23:59:59\", \"%F %H:%M:%S\", &tm);\n            strftime(buff, sizeof(buff), parent->format, &tm);\n            arg_dstr_catf(ds, \"correct format is \\\"%s\\\"\\n\", buff);\n            break;\n        }\n    }\n}\n\nstruct arg_date* arg_date0(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary) {\n    return arg_daten(shortopts, longopts, format, datatype, 0, 1, glossary);\n}\n\nstruct arg_date* arg_date1(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary) {\n    return arg_daten(shortopts, longopts, format, datatype, 1, 1, glossary);\n}\n\nstruct arg_date*\narg_daten(const char* shortopts, const char* longopts, const char* format, const char* datatype, int mincount, int maxcount, const char* glossary) {\n    size_t nbytes;\n    struct arg_date* result;\n\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    /* default time format is the national date format for the locale */\n    if (!format)\n        format = \"%x\";\n\n    nbytes = sizeof(struct arg_date)         /* storage for struct arg_date */\n             + maxcount * sizeof(struct tm); /* storage for tmval[maxcount] array */\n\n    /* allocate storage for the arg_date struct + tmval[] array.    */\n    /* we use calloc because we want the tmval[] array zero filled. */\n    result = (struct arg_date*)xcalloc(1, nbytes);\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = ARG_HASVALUE;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.datatype = datatype ? datatype : format;\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_date_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_date_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_date_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_date_errorfn;\n\n    /* store the tmval[maxcount] array immediately after the arg_date struct */\n    result->tmval = (struct tm*)(result + 1);\n\n    /* init the remaining arg_date member variables */\n    result->count = 0;\n    result->format = format;\n\n    ARG_TRACE((\"arg_daten() returns %p\\n\", result));\n    return result;\n}\n\n/*-\n * Copyright (c) 1997, 1998, 2005, 2008 The NetBSD Foundation, Inc.\n * All rights reserved.\n *\n * This code was contributed to The NetBSD Foundation by Klaus Klein.\n * Heavily optimised by David Laight\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n\n/*\n * We do not implement alternate representations. However, we always\n * check whether a given modifier is allowed for a certain conversion.\n */\n#define ALT_E 0x01\n#define ALT_O 0x02\n#define LEGAL_ALT(x)           \\\n    {                          \\\n        if (alt_format & ~(x)) \\\n            return (0);        \\\n    }\n#define TM_YEAR_BASE (1900)\n\nstatic int conv_num(const char**, int*, int, int);\n\nstatic const char* day[7] = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n\nstatic const char* abday[7] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"};\n\nstatic const char* mon[12] = {\"January\", \"February\", \"March\",     \"April\",   \"May\",      \"June\",\n                              \"July\",    \"August\",   \"September\", \"October\", \"November\", \"December\"};\n\nstatic const char* abmon[12] = {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n\nstatic const char* am_pm[2] = {\"AM\", \"PM\"};\n\nstatic int arg_strcasecmp(const char* s1, const char* s2) {\n    const unsigned char* us1 = (const unsigned char*)s1;\n    const unsigned char* us2 = (const unsigned char*)s2;\n    while (tolower(*us1) == tolower(*us2++))\n        if (*us1++ == '\\0')\n            return 0;\n\n    return tolower(*us1) - tolower(*--us2);\n}\n\nstatic int arg_strncasecmp(const char* s1, const char* s2, size_t n) {\n    if (n != 0) {\n        const unsigned char* us1 = (const unsigned char*)s1;\n        const unsigned char* us2 = (const unsigned char*)s2;\n        do {\n            if (tolower(*us1) != tolower(*us2++))\n                return tolower(*us1) - tolower(*--us2);\n\n            if (*us1++ == '\\0')\n                break;\n        } while (--n != 0);\n    }\n\n    return 0;\n}\n\nchar* arg_strptime(const char* buf, const char* fmt, struct tm* tm) {\n    char c;\n    const char* bp;\n    size_t len = 0;\n    int alt_format, i, split_year = 0;\n\n    bp = buf;\n\n    while ((c = *fmt) != '\\0') {\n        /* Clear `alternate' modifier prior to new conversion. */\n        alt_format = 0;\n\n        /* Eat up white-space. */\n        if (isspace(c)) {\n            while (isspace((int)(*bp)))\n                bp++;\n\n            fmt++;\n            continue;\n        }\n\n        if ((c = *fmt++) != '%')\n            goto literal;\n\n    again:\n        switch (c = *fmt++) {\n            case '%': /* \"%%\" is converted to \"%\". */\n            literal:\n                if (c != *bp++)\n                    return (0);\n                break;\n\n            /*\n             * \"Alternative\" modifiers. Just set the appropriate flag\n             * and start over again.\n             */\n            case 'E': /* \"%E?\" alternative conversion modifier. */\n                LEGAL_ALT(0);\n                alt_format |= ALT_E;\n                goto again;\n\n            case 'O': /* \"%O?\" alternative conversion modifier. */\n                LEGAL_ALT(0);\n                alt_format |= ALT_O;\n                goto again;\n\n            /*\n             * \"Complex\" conversion rules, implemented through recursion.\n             */\n            case 'c': /* Date and time, using the locale's format. */\n                LEGAL_ALT(ALT_E);\n                bp = arg_strptime(bp, \"%x %X\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            case 'D': /* The date as \"%m/%d/%y\". */\n                LEGAL_ALT(0);\n                bp = arg_strptime(bp, \"%m/%d/%y\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            case 'R': /* The time as \"%H:%M\". */\n                LEGAL_ALT(0);\n                bp = arg_strptime(bp, \"%H:%M\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            case 'r': /* The time in 12-hour clock representation. */\n                LEGAL_ALT(0);\n                bp = arg_strptime(bp, \"%I:%M:%S %p\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            case 'T': /* The time as \"%H:%M:%S\". */\n                LEGAL_ALT(0);\n                bp = arg_strptime(bp, \"%H:%M:%S\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            case 'X': /* The time, using the locale's format. */\n                LEGAL_ALT(ALT_E);\n                bp = arg_strptime(bp, \"%H:%M:%S\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            case 'x': /* The date, using the locale's format. */\n                LEGAL_ALT(ALT_E);\n                bp = arg_strptime(bp, \"%m/%d/%y\", tm);\n                if (!bp)\n                    return (0);\n                break;\n\n            /*\n             * \"Elementary\" conversion rules.\n             */\n            case 'A': /* The day of week, using the locale's form. */\n            case 'a':\n                LEGAL_ALT(0);\n                for (i = 0; i < 7; i++) {\n                    /* Full name. */\n                    len = strlen(day[i]);\n                    if (arg_strncasecmp(day[i], bp, len) == 0)\n                        break;\n\n                    /* Abbreviated name. */\n                    len = strlen(abday[i]);\n                    if (arg_strncasecmp(abday[i], bp, len) == 0)\n                        break;\n                }\n\n                /* Nothing matched. */\n                if (i == 7)\n                    return (0);\n\n                tm->tm_wday = i;\n                bp += len;\n                break;\n\n            case 'B': /* The month, using the locale's form. */\n            case 'b':\n            case 'h':\n                LEGAL_ALT(0);\n                for (i = 0; i < 12; i++) {\n                    /* Full name. */\n                    len = strlen(mon[i]);\n                    if (arg_strncasecmp(mon[i], bp, len) == 0)\n                        break;\n\n                    /* Abbreviated name. */\n                    len = strlen(abmon[i]);\n                    if (arg_strncasecmp(abmon[i], bp, len) == 0)\n                        break;\n                }\n\n                /* Nothing matched. */\n                if (i == 12)\n                    return (0);\n\n                tm->tm_mon = i;\n                bp += len;\n                break;\n\n            case 'C': /* The century number. */\n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 99)))\n                    return (0);\n\n                if (split_year) {\n                    tm->tm_year = (tm->tm_year % 100) + (i * 100);\n                } else {\n                    tm->tm_year = i * 100;\n                    split_year = 1;\n                }\n                break;\n\n            case 'd': /* The day of month. */\n            case 'e':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_mday, 1, 31)))\n                    return (0);\n                break;\n\n            case 'k': /* The hour (24-hour clock representation). */\n                LEGAL_ALT(0);\n            /* FALLTHROUGH */\n            case 'H':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 0, 23)))\n                    return (0);\n                break;\n\n            case 'l': /* The hour (12-hour clock representation). */\n                LEGAL_ALT(0);\n            /* FALLTHROUGH */\n            case 'I':\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_hour, 1, 12)))\n                    return (0);\n                if (tm->tm_hour == 12)\n                    tm->tm_hour = 0;\n                break;\n\n            case 'j': /* The day of year. */\n                LEGAL_ALT(0);\n                if (!(conv_num(&bp, &i, 1, 366)))\n                    return (0);\n                tm->tm_yday = i - 1;\n                break;\n\n            case 'M': /* The minute. */\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_min, 0, 59)))\n                    return (0);\n                break;\n\n            case 'm': /* The month. */\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &i, 1, 12)))\n                    return (0);\n                tm->tm_mon = i - 1;\n                break;\n\n            case 'p': /* The locale's equivalent of AM/PM. */\n                LEGAL_ALT(0);\n                /* AM? */\n                if (arg_strcasecmp(am_pm[0], bp) == 0) {\n                    if (tm->tm_hour > 11)\n                        return (0);\n\n                    bp += strlen(am_pm[0]);\n                    break;\n                }\n                /* PM? */\n                else if (arg_strcasecmp(am_pm[1], bp) == 0) {\n                    if (tm->tm_hour > 11)\n                        return (0);\n\n                    tm->tm_hour += 12;\n                    bp += strlen(am_pm[1]);\n                    break;\n                }\n\n                /* Nothing matched. */\n                return (0);\n\n            case 'S': /* The seconds. */\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_sec, 0, 61)))\n                    return (0);\n                break;\n\n            case 'U': /* The week of year, beginning on sunday. */\n            case 'W': /* The week of year, beginning on monday. */\n                LEGAL_ALT(ALT_O);\n                /*\n                 * XXX This is bogus, as we can not assume any valid\n                 * information present in the tm structure at this\n                 * point to calculate a real value, so just check the\n                 * range for now.\n                 */\n                if (!(conv_num(&bp, &i, 0, 53)))\n                    return (0);\n                break;\n\n            case 'w': /* The day of week, beginning on sunday. */\n                LEGAL_ALT(ALT_O);\n                if (!(conv_num(&bp, &tm->tm_wday, 0, 6)))\n                    return (0);\n                break;\n\n            case 'Y': /* The year. */\n                LEGAL_ALT(ALT_E);\n                if (!(conv_num(&bp, &i, 0, 9999)))\n                    return (0);\n\n                tm->tm_year = i - TM_YEAR_BASE;\n                break;\n\n            case 'y': /* The year within 100 years of the epoch. */\n                LEGAL_ALT(ALT_E | ALT_O);\n                if (!(conv_num(&bp, &i, 0, 99)))\n                    return (0);\n\n                if (split_year) {\n                    tm->tm_year = ((tm->tm_year / 100) * 100) + i;\n                    break;\n                }\n                split_year = 1;\n                if (i <= 68)\n                    tm->tm_year = i + 2000 - TM_YEAR_BASE;\n                else\n                    tm->tm_year = i + 1900 - TM_YEAR_BASE;\n                break;\n\n            /*\n             * Miscellaneous conversions.\n             */\n            case 'n': /* Any kind of white-space. */\n            case 't':\n                LEGAL_ALT(0);\n                while (isspace((int)(*bp)))\n                    bp++;\n                break;\n\n            default: /* Unknown/unsupported conversion. */\n                return (0);\n        }\n    }\n\n    /* LINTED functional specification */\n    return ((char*)bp);\n}\n\nstatic int conv_num(const char** buf, int* dest, int llim, int ulim) {\n    int result = 0;\n\n    /* The limit also determines the number of valid digits. */\n    int rulim = ulim;\n\n    if (**buf < '0' || **buf > '9')\n        return (0);\n\n    do {\n        result *= 10;\n        result += *(*buf)++ - '0';\n        rulim /= 10;\n    } while ((result * 10 <= ulim) && rulim && **buf >= '0' && **buf <= '9');\n\n    if (result < llim || result > ulim)\n        return (0);\n\n    *dest = result;\n    return (1);\n}\n/*******************************************************************************\n * arg_dbl: Implements the double command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n\nstatic void arg_dbl_resetfn(struct arg_dbl* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\nstatic int arg_dbl_scanfn(struct arg_dbl* parent, const char* argval) {\n    int errorcode = 0;\n\n    if (parent->count == parent->hdr.maxcount) {\n        /* maximum number of arguments exceeded */\n        errorcode = ARG_ERR_MAXCOUNT;\n    } else if (!argval) {\n        /* a valid argument with no argument value was given. */\n        /* This happens when an optional argument value was invoked. */\n        /* leave parent argument value unaltered but still count the argument. */\n        parent->count++;\n    } else {\n        double val;\n        char* end;\n\n        /* extract double from argval into val */\n        val = strtod(argval, &end);\n\n        /* if success then store result in parent->dval[] array otherwise return error*/\n        if (*end == 0)\n            parent->dval[parent->count++] = val;\n        else\n            errorcode = ARG_ERR_BADDOUBLE;\n    }\n\n    ARG_TRACE((\"%s:scanfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic int arg_dbl_checkfn(struct arg_dbl* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n\n    ARG_TRACE((\"%s:checkfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic void arg_dbl_errorfn(struct arg_dbl* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    /* make argval NULL safe */\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_cat(ds, \"missing option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_cat(ds, \"excess option \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n\n        case ARG_ERR_BADDOUBLE:\n            arg_dstr_catf(ds, \"invalid argument \\\"%s\\\" to option \", argval);\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n    }\n}\n\nstruct arg_dbl* arg_dbl0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_dbln(shortopts, longopts, datatype, 0, 1, glossary);\n}\n\nstruct arg_dbl* arg_dbl1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_dbln(shortopts, longopts, datatype, 1, 1, glossary);\n}\n\nstruct arg_dbl* arg_dbln(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {\n    size_t nbytes;\n    struct arg_dbl* result;\n    size_t addr;\n    size_t rem;\n\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    nbytes = sizeof(struct arg_dbl)             /* storage for struct arg_dbl */\n             + (maxcount + 1) * sizeof(double); /* storage for dval[maxcount] array plus one extra for padding to memory boundary */\n\n    result = (struct arg_dbl*)xmalloc(nbytes);\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = ARG_HASVALUE;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.datatype = datatype ? datatype : \"<double>\";\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_dbl_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_dbl_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_dbl_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_dbl_errorfn;\n\n    /* Store the dval[maxcount] array on the first double boundary that\n     * immediately follows the arg_dbl struct. We do the memory alignment\n     * purely for SPARC and Motorola systems. They require floats and\n     * doubles to be aligned on natural boundaries.\n     */\n    addr = (size_t)(result + 1);\n    rem = addr % sizeof(double);\n    result->dval = (double*)(addr + sizeof(double) - rem);\n    ARG_TRACE((\"addr=%p, dval=%p, sizeof(double)=%d rem=%d\\n\", addr, result->dval, (int)sizeof(double), (int)rem));\n\n    result->count = 0;\n\n    ARG_TRACE((\"arg_dbln() returns %p\\n\", result));\n    return result;\n}\n/*******************************************************************************\n * arg_end: Implements the error handling utilities\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n\nstatic void arg_end_resetfn(struct arg_end* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\nstatic void arg_end_errorfn(void* parent, arg_dstr_t ds, int error, const char* argval, const char* progname) {\n    /* suppress unreferenced formal parameter warning */\n    (void)parent;\n\n    progname = progname ? progname : \"\";\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (error) {\n        case ARG_ELIMIT:\n            arg_dstr_cat(ds, \"too many errors to display\");\n            break;\n        case ARG_EMALLOC:\n            arg_dstr_cat(ds, \"insufficient memory\");\n            break;\n        case ARG_ENOMATCH:\n            arg_dstr_catf(ds, \"unexpected argument \\\"%s\\\"\", argval);\n            break;\n        case ARG_EMISSARG:\n            arg_dstr_catf(ds, \"option \\\"%s\\\" requires an argument\", argval);\n            break;\n        case ARG_ELONGOPT:\n            arg_dstr_catf(ds, \"invalid option \\\"%s\\\"\", argval);\n            break;\n        default:\n            arg_dstr_catf(ds, \"invalid option \\\"-%c\\\"\", error);\n            break;\n    }\n\n    arg_dstr_cat(ds, \"\\n\");\n}\n\nstruct arg_end* arg_end(int maxcount) {\n    size_t nbytes;\n    struct arg_end* result;\n\n    nbytes = sizeof(struct arg_end) + maxcount * sizeof(int) /* storage for int error[maxcount] array*/\n             + maxcount * sizeof(void*)                      /* storage for void* parent[maxcount] array */\n             + maxcount * sizeof(char*);                     /* storage for char* argval[maxcount] array */\n\n    result = (struct arg_end*)xmalloc(nbytes);\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = ARG_TERMINATOR;\n    result->hdr.shortopts = NULL;\n    result->hdr.longopts = NULL;\n    result->hdr.datatype = NULL;\n    result->hdr.glossary = NULL;\n    result->hdr.mincount = 1;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_end_resetfn;\n    result->hdr.scanfn = NULL;\n    result->hdr.checkfn = NULL;\n    result->hdr.errorfn = (arg_errorfn*)arg_end_errorfn;\n\n    /* store error[maxcount] array immediately after struct arg_end */\n    result->error = (int*)(result + 1);\n\n    /* store parent[maxcount] array immediately after error[] array */\n    result->parent = (void**)(result->error + maxcount);\n\n    /* store argval[maxcount] array immediately after parent[] array */\n    result->argval = (const char**)(result->parent + maxcount);\n\n    ARG_TRACE((\"arg_end(%d) returns %p\\n\", maxcount, result));\n    return result;\n}\n\nvoid arg_print_errors_ds(arg_dstr_t ds, struct arg_end* end, const char* progname) {\n    int i;\n    ARG_TRACE((\"arg_errors()\\n\"));\n    for (i = 0; i < end->count; i++) {\n        struct arg_hdr* errorparent = (struct arg_hdr*)(end->parent[i]);\n        if (errorparent->errorfn)\n            errorparent->errorfn(end->parent[i], ds, end->error[i], end->argval[i], progname);\n    }\n}\n\nvoid arg_print_errors(FILE* fp, struct arg_end* end, const char* progname) {\n    arg_dstr_t ds = arg_dstr_create();\n    arg_print_errors_ds(ds, end, progname);\n    fputs(arg_dstr_cstr(ds), fp);\n    arg_dstr_destroy(ds);\n}\n/*******************************************************************************\n * arg_file: Implements the file command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef WIN32\n#define FILESEPARATOR1 '\\\\'\n#define FILESEPARATOR2 '/'\n#else\n#define FILESEPARATOR1 '/'\n#define FILESEPARATOR2 '/'\n#endif\n\nstatic void arg_file_resetfn(struct arg_file* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\n/* Returns ptr to the base filename within *filename */\nstatic const char* arg_basename(const char* filename) {\n    const char *result = NULL, *result1, *result2;\n\n    /* Find the last occurrence of other file separator character. */\n    /* Two alternative file separator chars are supported as legal */\n    /* file separators but not both together in the same filename. */\n    result1 = (filename ? strrchr(filename, FILESEPARATOR1) : NULL);\n    result2 = (filename ? strrchr(filename, FILESEPARATOR2) : NULL);\n\n    if (result2)\n        result = result2 + 1; /* using FILESEPARATOR2 (the alternative file separator) */\n\n    if (result1)\n        result = result1 + 1; /* using FILESEPARATOR1 (the preferred file separator) */\n\n    if (!result)\n        result = filename; /* neither file separator was found so basename is the whole filename */\n\n    /* special cases of \".\" and \"..\" are not considered basenames */\n    if (result && (strcmp(\".\", result) == 0 || strcmp(\"..\", result) == 0))\n        result = filename + strlen(filename);\n\n    return result;\n}\n\n/* Returns ptr to the file extension within *basename */\nstatic const char* arg_extension(const char* basename) {\n    /* find the last occurrence of '.' in basename */\n    const char* result = (basename ? strrchr(basename, '.') : NULL);\n\n    /* if no '.' was found then return pointer to end of basename */\n    if (basename && !result)\n        result = basename + strlen(basename);\n\n    /* special case: basenames with a single leading dot (eg \".foo\") are not considered as true extensions */\n    if (basename && result == basename)\n        result = basename + strlen(basename);\n\n    /* special case: empty extensions (eg \"foo.\",\"foo..\") are not considered as true extensions */\n    if (basename && result && strlen(result) == 1)\n        result = basename + strlen(basename);\n\n    return result;\n}\n\nstatic int arg_file_scanfn(struct arg_file* parent, const char* argval) {\n    int errorcode = 0;\n\n    if (parent->count == parent->hdr.maxcount) {\n        /* maximum number of arguments exceeded */\n        errorcode = ARG_ERR_MAXCOUNT;\n    } else if (!argval) {\n        /* a valid argument with no argument value was given. */\n        /* This happens when an optional argument value was invoked. */\n        /* leave parent argument value unaltered but still count the argument. */\n        parent->count++;\n    } else {\n        parent->filename[parent->count] = argval;\n        parent->basename[parent->count] = arg_basename(argval);\n        parent->extension[parent->count] =\n                arg_extension(parent->basename[parent->count]); /* only seek extensions within the basename (not the file path)*/\n        parent->count++;\n    }\n\n    ARG_TRACE((\"%s4:scanfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic int arg_file_checkfn(struct arg_file* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n\n    ARG_TRACE((\"%s:checkfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic void arg_file_errorfn(struct arg_file* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    /* make argval NULL safe */\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_cat(ds, \"missing option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_cat(ds, \"excess option \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n\n        default:\n            arg_dstr_catf(ds, \"unknown error at \\\"%s\\\"\\n\", argval);\n    }\n}\n\nstruct arg_file* arg_file0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_filen(shortopts, longopts, datatype, 0, 1, glossary);\n}\n\nstruct arg_file* arg_file1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_filen(shortopts, longopts, datatype, 1, 1, glossary);\n}\n\nstruct arg_file* arg_filen(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {\n    size_t nbytes;\n    struct arg_file* result;\n    int i;\n\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    nbytes = sizeof(struct arg_file)     /* storage for struct arg_file */\n             + sizeof(char*) * maxcount  /* storage for filename[maxcount] array */\n             + sizeof(char*) * maxcount  /* storage for basename[maxcount] array */\n             + sizeof(char*) * maxcount; /* storage for extension[maxcount] array */\n\n    result = (struct arg_file*)xmalloc(nbytes);\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = ARG_HASVALUE;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.glossary = glossary;\n    result->hdr.datatype = datatype ? datatype : \"<file>\";\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_file_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_file_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_file_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_file_errorfn;\n\n    /* store the filename,basename,extension arrays immediately after the arg_file struct */\n    result->filename = (const char**)(result + 1);\n    result->basename = result->filename + maxcount;\n    result->extension = result->basename + maxcount;\n    result->count = 0;\n\n    /* foolproof the string pointers by initialising them with empty strings */\n    for (i = 0; i < maxcount; i++) {\n        result->filename[i] = \"\";\n        result->basename[i] = \"\";\n        result->extension[i] = \"\";\n    }\n\n    ARG_TRACE((\"arg_filen() returns %p\\n\", result));\n    return result;\n}\n/*******************************************************************************\n * arg_int: Implements the int command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n\nstatic void arg_int_resetfn(struct arg_int* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\n/* strtol0x() is like strtol() except that the numeric string is    */\n/* expected to be prefixed by \"0X\" where X is a user supplied char. */\n/* The string may optionally be prefixed by white space and + or -  */\n/* as in +0X123 or -0X123.                                          */\n/* Once the prefix has been scanned, the remainder of the numeric   */\n/* string is converted using strtol() with the given base.          */\n/* eg: to parse hex str=\"-0X12324\", specify X='X' and base=16.      */\n/* eg: to parse oct str=\"+0o12324\", specify X='O' and base=8.       */\n/* eg: to parse bin str=\"-0B01010\", specify X='B' and base=2.       */\n/* Failure of conversion is indicated by result where *endptr==str. */\nstatic long int strtol0X(const char* str, const char** endptr, char X, int base) {\n    long int val;          /* stores result */\n    int s = 1;             /* sign is +1 or -1 */\n    const char* ptr = str; /* ptr to current position in str */\n\n    /* skip leading whitespace */\n    while (isspace((int)(*ptr)))\n        ptr++;\n    /* printf(\"1) %s\\n\",ptr); */\n\n    /* scan optional sign character */\n    switch (*ptr) {\n        case '+':\n            ptr++;\n            s = 1;\n            break;\n        case '-':\n            ptr++;\n            s = -1;\n            break;\n        default:\n            s = 1;\n            break;\n    }\n    /* printf(\"2) %s\\n\",ptr); */\n\n    /* '0X' prefix */\n    if ((*ptr++) != '0') {\n        /* printf(\"failed to detect '0'\\n\"); */\n        *endptr = str;\n        return 0;\n    }\n    /* printf(\"3) %s\\n\",ptr); */\n    if (toupper(*ptr++) != toupper(X)) {\n        /* printf(\"failed to detect '%c'\\n\",X); */\n        *endptr = str;\n        return 0;\n    }\n    /* printf(\"4) %s\\n\",ptr); */\n\n    /* attempt conversion on remainder of string using strtol() */\n    val = strtol(ptr, (char**)endptr, base);\n    if (*endptr == ptr) {\n        /* conversion failed */\n        *endptr = str;\n        return 0;\n    }\n\n    /* success */\n    return s * val;\n}\n\n/* Returns 1 if str matches suffix (case insensitive).    */\n/* Str may contain trailing whitespace, but nothing else. */\nstatic int detectsuffix(const char* str, const char* suffix) {\n    /* scan pairwise through strings until mismatch detected */\n    while (toupper(*str) == toupper(*suffix)) {\n        /* printf(\"'%c' '%c'\\n\", *str, *suffix); */\n\n        /* return 1 (success) if match persists until the string terminator */\n        if (*str == '\\0')\n            return 1;\n\n        /* next chars */\n        str++;\n        suffix++;\n    }\n    /* printf(\"'%c' '%c' mismatch\\n\", *str, *suffix); */\n\n    /* return 0 (fail) if the matching did not consume the entire suffix */\n    if (*suffix != 0)\n        return 0; /* failed to consume entire suffix */\n\n    /* skip any remaining whitespace in str */\n    while (isspace((int)(*str)))\n        str++;\n\n    /* return 1 (success) if we have reached end of str else return 0 (fail) */\n    return (*str == '\\0') ? 1 : 0;\n}\n\nstatic int arg_int_scanfn(struct arg_int* parent, const char* argval) {\n    int errorcode = 0;\n\n    if (parent->count == parent->hdr.maxcount) {\n        /* maximum number of arguments exceeded */\n        errorcode = ARG_ERR_MAXCOUNT;\n    } else if (!argval) {\n        /* a valid argument with no argument value was given. */\n        /* This happens when an optional argument value was invoked. */\n        /* leave parent argument value unaltered but still count the argument. */\n        parent->count++;\n    } else {\n        long int val;\n        const char* end;\n\n        /* attempt to extract hex integer (eg: +0x123) from argval into val conversion */\n        val = strtol0X(argval, &end, 'X', 16);\n        if (end == argval) {\n            /* hex failed, attempt octal conversion (eg +0o123) */\n            val = strtol0X(argval, &end, 'O', 8);\n            if (end == argval) {\n                /* octal failed, attempt binary conversion (eg +0B101) */\n                val = strtol0X(argval, &end, 'B', 2);\n                if (end == argval) {\n                    /* binary failed, attempt decimal conversion with no prefix (eg 1234) */\n                    val = strtol(argval, (char**)&end, 10);\n                    if (end == argval) {\n                        /* all supported number formats failed */\n                        return ARG_ERR_BADINT;\n                    }\n                }\n            }\n        }\n\n        /* Safety check for integer overflow. WARNING: this check    */\n        /* achieves nothing on machines where size(int)==size(long). */\n        if (val > INT_MAX || val < INT_MIN)\n            errorcode = ARG_ERR_OVERFLOW;\n\n        /* Detect any suffixes (KB,MB,GB) and multiply argument value appropriately. */\n        /* We need to be mindful of integer overflows when using such big numbers.   */\n        if (detectsuffix(end, \"KB\")) /* kilobytes */\n        {\n            if (val > (INT_MAX / 1024) || val < (INT_MIN / 1024))\n                errorcode = ARG_ERR_OVERFLOW; /* Overflow would occur if we proceed */\n            else\n                val *= 1024;                /* 1KB = 1024 */\n        } else if (detectsuffix(end, \"MB\")) /* megabytes */\n        {\n            if (val > (INT_MAX / 1048576) || val < (INT_MIN / 1048576))\n                errorcode = ARG_ERR_OVERFLOW; /* Overflow would occur if we proceed */\n            else\n                val *= 1048576;             /* 1MB = 1024*1024 */\n        } else if (detectsuffix(end, \"GB\")) /* gigabytes */\n        {\n            if (val > (INT_MAX / 1073741824) || val < (INT_MIN / 1073741824))\n                errorcode = ARG_ERR_OVERFLOW; /* Overflow would occur if we proceed */\n            else\n                val *= 1073741824; /* 1GB = 1024*1024*1024 */\n        } else if (!detectsuffix(end, \"\"))\n            errorcode = ARG_ERR_BADINT; /* invalid suffix detected */\n\n        /* if success then store result in parent->ival[] array */\n        if (errorcode == 0)\n            parent->ival[parent->count++] = (int)val;\n    }\n\n    /* printf(\"%s:scanfn(%p,%p) returns %d\\n\",__FILE__,parent,argval,errorcode); */\n    return errorcode;\n}\n\nstatic int arg_int_checkfn(struct arg_int* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n    /*printf(\"%s:checkfn(%p) returns %d\\n\",__FILE__,parent,errorcode);*/\n    return errorcode;\n}\n\nstatic void arg_int_errorfn(struct arg_int* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    /* make argval NULL safe */\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_cat(ds, \"missing option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_cat(ds, \"excess option \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n\n        case ARG_ERR_BADINT:\n            arg_dstr_catf(ds, \"invalid argument \\\"%s\\\" to option \", argval);\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_OVERFLOW:\n            arg_dstr_cat(ds, \"integer overflow at option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \" \");\n            arg_dstr_catf(ds, \"(%s is too large)\\n\", argval);\n            break;\n    }\n}\n\nstruct arg_int* arg_int0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_intn(shortopts, longopts, datatype, 0, 1, glossary);\n}\n\nstruct arg_int* arg_int1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_intn(shortopts, longopts, datatype, 1, 1, glossary);\n}\n\nstruct arg_int* arg_intn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {\n    size_t nbytes;\n    struct arg_int* result;\n\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    nbytes = sizeof(struct arg_int)    /* storage for struct arg_int */\n             + maxcount * sizeof(int); /* storage for ival[maxcount] array */\n\n    result = (struct arg_int*)xmalloc(nbytes);\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = ARG_HASVALUE;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.datatype = datatype ? datatype : \"<int>\";\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_int_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_int_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_int_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_int_errorfn;\n\n    /* store the ival[maxcount] array immediately after the arg_int struct */\n    result->ival = (int*)(result + 1);\n    result->count = 0;\n\n    ARG_TRACE((\"arg_intn() returns %p\\n\", result));\n    return result;\n}\n/*******************************************************************************\n * arg_lit: Implements the literature command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n\nstatic void arg_lit_resetfn(struct arg_lit* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\nstatic int arg_lit_scanfn(struct arg_lit* parent, const char* argval) {\n    int errorcode = 0;\n    if (parent->count < parent->hdr.maxcount)\n        parent->count++;\n    else\n        errorcode = ARG_ERR_MAXCOUNT;\n\n    ARG_TRACE((\"%s:scanfn(%p,%s) returns %d\\n\", __FILE__, parent, argval, errorcode));\n    return errorcode;\n}\n\nstatic int arg_lit_checkfn(struct arg_lit* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n    ARG_TRACE((\"%s:checkfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic void arg_lit_errorfn(struct arg_lit* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_catf(ds, \"%s: missing option \", progname);\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            arg_dstr_cat(ds, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_catf(ds, \"%s: extraneous option \", progname);\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n    }\n\n    ARG_TRACE((\"%s:errorfn(%p, %p, %d, %s, %s)\\n\", __FILE__, parent, ds, errorcode, argval, progname));\n}\n\nstruct arg_lit* arg_lit0(const char* shortopts, const char* longopts, const char* glossary) {\n    return arg_litn(shortopts, longopts, 0, 1, glossary);\n}\n\nstruct arg_lit* arg_lit1(const char* shortopts, const char* longopts, const char* glossary) {\n    return arg_litn(shortopts, longopts, 1, 1, glossary);\n}\n\nstruct arg_lit* arg_litn(const char* shortopts, const char* longopts, int mincount, int maxcount, const char* glossary) {\n    struct arg_lit* result;\n\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    result = (struct arg_lit*)xmalloc(sizeof(struct arg_lit));\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = 0;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.datatype = NULL;\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_lit_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_lit_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_lit_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_lit_errorfn;\n\n    /* init local variables */\n    result->count = 0;\n\n    ARG_TRACE((\"arg_litn() returns %p\\n\", result));\n    return result;\n}\n/*******************************************************************************\n * arg_rem: Implements the rem command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n\nstruct arg_rem* arg_rem(const char* datatype, const char* glossary) {\n    struct arg_rem* result = (struct arg_rem*)xmalloc(sizeof(struct arg_rem));\n\n    result->hdr.flag = 0;\n    result->hdr.shortopts = NULL;\n    result->hdr.longopts = NULL;\n    result->hdr.datatype = datatype;\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = 1;\n    result->hdr.maxcount = 1;\n    result->hdr.parent = result;\n    result->hdr.resetfn = NULL;\n    result->hdr.scanfn = NULL;\n    result->hdr.checkfn = NULL;\n    result->hdr.errorfn = NULL;\n\n    ARG_TRACE((\"arg_rem() returns %p\\n\", result));\n    return result;\n}\n/*******************************************************************************\n * arg_rex: Implements the regex command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef _TREX_H_\n#define _TREX_H_\n\n/*\n * This module uses the T-Rex regular expression library to implement the regex\n * logic. Here is the copyright notice of the library:\n *\n * Copyright (C) 2003-2006 Alberto Demichelis\n *\n * This software is provided 'as-is', without any express\n * or implied warranty. In no event will the authors be held\n * liable for any damages arising from the use of this software.\n *\n * Permission is granted to anyone to use this software for\n * any purpose, including commercial applications, and to alter\n * it and redistribute it freely, subject to the following restrictions:\n *\n *   1. The origin of this software must not be misrepresented;\n *      you must not claim that you wrote the original software.\n *      If you use this software in a product, an acknowledgment\n *      in the product documentation would be appreciated but\n *      is not required.\n *\n *   2. Altered source versions must be plainly marked as such,\n *      and must not be misrepresented as being the original software.\n *\n *   3. This notice may not be removed or altered from any\n *      source distribution.\n */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define TRexChar char\n#define MAX_CHAR 0xFF\n#define _TREXC(c) (c)\n#define trex_strlen strlen\n#define trex_printf printf\n\n#ifndef TREX_API\n#define TREX_API extern\n#endif\n\n#define TRex_True 1\n#define TRex_False 0\n\n#define TREX_ICASE ARG_REX_ICASE\n\ntypedef unsigned int TRexBool;\ntypedef struct TRex TRex;\n\ntypedef struct {\n    const TRexChar* begin;\n    int len;\n} TRexMatch;\n\n#ifdef __GNUC__\nTREX_API TRex* trex_compile(const TRexChar* pattern, const TRexChar** error, int flags) __attribute__((optimize(0)));\n#else\nTREX_API TRex* trex_compile(const TRexChar* pattern, const TRexChar** error, int flags);\n#endif\nTREX_API void trex_free(TRex* exp);\nTREX_API TRexBool trex_match(TRex* exp, const TRexChar* text);\nTREX_API TRexBool trex_search(TRex* exp, const TRexChar* text, const TRexChar** out_begin, const TRexChar** out_end);\nTREX_API TRexBool\ntrex_searchrange(TRex* exp, const TRexChar* text_begin, const TRexChar* text_end, const TRexChar** out_begin, const TRexChar** out_end);\nTREX_API int trex_getsubexpcount(TRex* exp);\nTREX_API TRexBool trex_getsubexp(TRex* exp, int n, TRexMatch* subexp);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\nstruct privhdr {\n    const char* pattern;\n    int flags;\n};\n\nstatic void arg_rex_resetfn(struct arg_rex* parent) {\n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    parent->count = 0;\n}\n\nstatic int arg_rex_scanfn(struct arg_rex* parent, const char* argval) {\n    int errorcode = 0;\n    const TRexChar* error = NULL;\n    TRex* rex = NULL;\n    TRexBool is_match = TRex_False;\n\n    if (parent->count == parent->hdr.maxcount) {\n        /* maximum number of arguments exceeded */\n        errorcode = ARG_ERR_MAXCOUNT;\n    } else if (!argval) {\n        /* a valid argument with no argument value was given. */\n        /* This happens when an optional argument value was invoked. */\n        /* leave parent argument value unaltered but still count the argument. */\n        parent->count++;\n    } else {\n        struct privhdr* priv = (struct privhdr*)parent->hdr.priv;\n\n        /* test the current argument value for a match with the regular expression */\n        /* if a match is detected, record the argument value in the arg_rex struct */\n\n        rex = trex_compile(priv->pattern, &error, priv->flags);\n        is_match = trex_match(rex, argval);\n        if (!is_match)\n            errorcode = ARG_ERR_REGNOMATCH;\n        else\n            parent->sval[parent->count++] = argval;\n\n        trex_free(rex);\n    }\n\n    ARG_TRACE((\"%s:scanfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic int arg_rex_checkfn(struct arg_rex* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n#if 0\n    struct privhdr *priv = (struct privhdr*)parent->hdr.priv;\n\n    /* free the regex \"program\" we constructed in resetfn */\n    regfree(&(priv->regex));\n\n    /*printf(\"%s:checkfn(%p) returns %d\\n\",__FILE__,parent,errorcode);*/\n#endif\n    return errorcode;\n}\n\nstatic void arg_rex_errorfn(struct arg_rex* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    /* make argval NULL safe */\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_cat(ds, \"missing option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_cat(ds, \"excess option \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n\n        case ARG_ERR_REGNOMATCH:\n            arg_dstr_cat(ds, \"illegal value  \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n\n        default: {\n        #if 0\n            char errbuff[256];\n            regerror(errorcode, NULL, errbuff, sizeof(errbuff));\n            printf(\"%s\\n\", errbuff);\n        #endif\n        } break;\n    }\n}\n\nstruct arg_rex* arg_rex0(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary) {\n    return arg_rexn(shortopts, longopts, pattern, datatype, 0, 1, flags, glossary);\n}\n\nstruct arg_rex* arg_rex1(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary) {\n    return arg_rexn(shortopts, longopts, pattern, datatype, 1, 1, flags, glossary);\n}\n\nstruct arg_rex* arg_rexn(const char* shortopts,\n                         const char* longopts,\n                         const char* pattern,\n                         const char* datatype,\n                         int mincount,\n                         int maxcount,\n                         int flags,\n                         const char* glossary) {\n    size_t nbytes;\n    struct arg_rex* result;\n    struct privhdr* priv;\n    int i;\n    const TRexChar* error = NULL;\n    TRex* rex = NULL;\n\n    if (!pattern) {\n        printf(\"argtable: ERROR - illegal regular expression pattern \\\"(NULL)\\\"\\n\");\n        printf(\"argtable: Bad argument table.\\n\");\n        return NULL;\n    }\n\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    nbytes = sizeof(struct arg_rex)      /* storage for struct arg_rex */\n             + sizeof(struct privhdr)    /* storage for private arg_rex data */\n             + maxcount * sizeof(char*); /* storage for sval[maxcount] array */\n\n    /* init the arg_hdr struct */\n    result = (struct arg_rex*)xmalloc(nbytes);\n    result->hdr.flag = ARG_HASVALUE;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.datatype = datatype ? datatype : pattern;\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_rex_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_rex_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_rex_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_rex_errorfn;\n\n    /* store the arg_rex_priv struct immediately after the arg_rex struct */\n    result->hdr.priv = result + 1;\n    priv = (struct privhdr*)(result->hdr.priv);\n    priv->pattern = pattern;\n    priv->flags = flags;\n\n    /* store the sval[maxcount] array immediately after the arg_rex_priv struct */\n    result->sval = (const char**)(priv + 1);\n    result->count = 0;\n\n    /* foolproof the string pointers by initializing them to reference empty strings */\n    for (i = 0; i < maxcount; i++)\n        result->sval[i] = \"\";\n\n    /* here we construct and destroy a regex representation of the regular\n     * expression for no other reason than to force any regex errors to be\n     * trapped now rather than later. If we don't, then errors may go undetected\n     * until an argument is actually parsed.\n     */\n\n    rex = trex_compile(priv->pattern, &error, priv->flags);\n    if (rex == NULL) {\n        ARG_LOG((\"argtable: %s \\\"%s\\\"\\n\", error ? error : _TREXC(\"undefined\"), priv->pattern));\n        ARG_LOG((\"argtable: Bad argument table.\\n\"));\n    }\n\n    trex_free(rex);\n\n    ARG_TRACE((\"arg_rexn() returns %p\\n\", result));\n    return result;\n}\n\n/* see copyright notice in trex.h */\n#include <ctype.h>\n#include <setjmp.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _UINCODE\n#define scisprint iswprint\n#define scstrlen wcslen\n#define scprintf wprintf\n#define _SC(x) L(x)\n#else\n#define scisprint isprint\n#define scstrlen strlen\n#define scprintf printf\n#define _SC(x) (x)\n#endif\n\n#ifdef ARG_REX_DEBUG\n#include <stdio.h>\n\nstatic const TRexChar* g_nnames[] = {_SC(\"NONE\"),    _SC(\"OP_GREEDY\"), _SC(\"OP_OR\"),     _SC(\"OP_EXPR\"),   _SC(\"OP_NOCAPEXPR\"),\n                                     _SC(\"OP_DOT\"),  _SC(\"OP_CLASS\"),  _SC(\"OP_CCLASS\"), _SC(\"OP_NCLASS\"), _SC(\"OP_RANGE\"),\n                                     _SC(\"OP_CHAR\"), _SC(\"OP_EOL\"),    _SC(\"OP_BOL\"),    _SC(\"OP_WB\")};\n\n#endif\n#define OP_GREEDY (MAX_CHAR + 1)  /*  * + ? {n} */\n#define OP_OR (MAX_CHAR + 2)\n#define OP_EXPR (MAX_CHAR + 3)       /* parenthesis () */\n#define OP_NOCAPEXPR (MAX_CHAR + 4)  /* parenthesis (?:) */\n#define OP_DOT (MAX_CHAR + 5)\n#define OP_CLASS (MAX_CHAR + 6)\n#define OP_CCLASS (MAX_CHAR + 7)\n#define OP_NCLASS (MAX_CHAR + 8)  /* negates class the [^ */\n#define OP_RANGE (MAX_CHAR + 9)\n#define OP_CHAR (MAX_CHAR + 10)\n#define OP_EOL (MAX_CHAR + 11)\n#define OP_BOL (MAX_CHAR + 12)\n#define OP_WB (MAX_CHAR + 13)\n\n#define TREX_SYMBOL_ANY_CHAR ('.')\n#define TREX_SYMBOL_GREEDY_ONE_OR_MORE ('+')\n#define TREX_SYMBOL_GREEDY_ZERO_OR_MORE ('*')\n#define TREX_SYMBOL_GREEDY_ZERO_OR_ONE ('?')\n#define TREX_SYMBOL_BRANCH ('|')\n#define TREX_SYMBOL_END_OF_STRING ('$')\n#define TREX_SYMBOL_BEGINNING_OF_STRING ('^')\n#define TREX_SYMBOL_ESCAPE_CHAR ('\\\\')\n\ntypedef int TRexNodeType;\n\ntypedef struct tagTRexNode {\n    TRexNodeType type;\n    int left;\n    int right;\n    int next;\n} TRexNode;\n\nstruct TRex {\n    const TRexChar* _eol;\n    const TRexChar* _bol;\n    const TRexChar* _p;\n    int _first;\n    int _op;\n    TRexNode* _nodes;\n    int _nallocated;\n    int _nsize;\n    int _nsubexpr;\n    TRexMatch* _matches;\n    int _currsubexp;\n    void* _jmpbuf;\n    const TRexChar** _error;\n    int _flags;\n};\n\nstatic int trex_list(TRex* exp);\n\nstatic int trex_newnode(TRex* exp, TRexNodeType type) {\n    TRexNode n;\n    int newid;\n    n.type = type;\n    n.next = n.right = n.left = -1;\n    if (type == OP_EXPR)\n        n.right = exp->_nsubexpr++;\n    if (exp->_nallocated < (exp->_nsize + 1)) {\n        exp->_nallocated *= 2;\n        exp->_nodes = (TRexNode*)xrealloc(exp->_nodes, exp->_nallocated * sizeof(TRexNode));\n    }\n    exp->_nodes[exp->_nsize++] = n;\n    newid = exp->_nsize - 1;\n    return (int)newid;\n}\n\nstatic void trex_error(TRex* exp, const TRexChar* error) {\n    if (exp->_error)\n        *exp->_error = error;\n    longjmp(*((jmp_buf*)exp->_jmpbuf), -1);\n}\n\nstatic void trex_expect(TRex* exp, int n) {\n    if ((*exp->_p) != n)\n        trex_error(exp, _SC(\"expected paren\"));\n    exp->_p++;\n}\n\nstatic TRexChar trex_escapechar(TRex* exp) {\n    if (*exp->_p == TREX_SYMBOL_ESCAPE_CHAR) {\n        exp->_p++;\n        switch (*exp->_p) {\n            case 'v':\n                exp->_p++;\n                return '\\v';\n            case 'n':\n                exp->_p++;\n                return '\\n';\n            case 't':\n                exp->_p++;\n                return '\\t';\n            case 'r':\n                exp->_p++;\n                return '\\r';\n            case 'f':\n                exp->_p++;\n                return '\\f';\n            default:\n                return (*exp->_p++);\n        }\n    } else if (!scisprint((int)(*exp->_p)))\n        trex_error(exp, _SC(\"letter expected\"));\n    return (*exp->_p++);\n}\n\nstatic int trex_charclass(TRex* exp, int classid) {\n    int n = trex_newnode(exp, OP_CCLASS);\n    exp->_nodes[n].left = classid;\n    return n;\n}\n\nstatic int trex_charnode(TRex* exp, TRexBool isclass) {\n    TRexChar t;\n    if (*exp->_p == TREX_SYMBOL_ESCAPE_CHAR) {\n        exp->_p++;\n        switch (*exp->_p) {\n            case 'n':\n                exp->_p++;\n                return trex_newnode(exp, '\\n');\n            case 't':\n                exp->_p++;\n                return trex_newnode(exp, '\\t');\n            case 'r':\n                exp->_p++;\n                return trex_newnode(exp, '\\r');\n            case 'f':\n                exp->_p++;\n                return trex_newnode(exp, '\\f');\n            case 'v':\n                exp->_p++;\n                return trex_newnode(exp, '\\v');\n            case 'a':\n            case 'A':\n            case 'w':\n            case 'W':\n            case 's':\n            case 'S':\n            case 'd':\n            case 'D':\n            case 'x':\n            case 'X':\n            case 'c':\n            case 'C':\n            case 'p':\n            case 'P':\n            case 'l':\n            case 'u': {\n                t = *exp->_p;\n                exp->_p++;\n                return trex_charclass(exp, t);\n            }\n            case 'b':\n            case 'B':\n                if (!isclass) {\n                    int node = trex_newnode(exp, OP_WB);\n                    exp->_nodes[node].left = *exp->_p;\n                    exp->_p++;\n                    return node;\n                }\n                /* fall through */\n            default:\n                t = *exp->_p;\n                exp->_p++;\n                return trex_newnode(exp, t);\n        }\n    } else if (!scisprint((int)(*exp->_p))) {\n        trex_error(exp, _SC(\"letter expected\"));\n    }\n    t = *exp->_p;\n    exp->_p++;\n    return trex_newnode(exp, t);\n}\nstatic int trex_class(TRex* exp) {\n    int ret = -1;\n    int first = -1, chain;\n    if (*exp->_p == TREX_SYMBOL_BEGINNING_OF_STRING) {\n        ret = trex_newnode(exp, OP_NCLASS);\n        exp->_p++;\n    } else\n        ret = trex_newnode(exp, OP_CLASS);\n\n    if (*exp->_p == ']')\n        trex_error(exp, _SC(\"empty class\"));\n    chain = ret;\n    while (*exp->_p != ']' && exp->_p != exp->_eol) {\n        if (*exp->_p == '-' && first != -1) {\n            int r, t;\n            if (*exp->_p++ == ']')\n                trex_error(exp, _SC(\"unfinished range\"));\n            r = trex_newnode(exp, OP_RANGE);\n            if (first > *exp->_p)\n                trex_error(exp, _SC(\"invalid range\"));\n            if (exp->_nodes[first].type == OP_CCLASS)\n                trex_error(exp, _SC(\"cannot use character classes in ranges\"));\n            exp->_nodes[r].left = exp->_nodes[first].type;\n            t = trex_escapechar(exp);\n            exp->_nodes[r].right = t;\n            exp->_nodes[chain].next = r;\n            chain = r;\n            first = -1;\n        } else {\n            if (first != -1) {\n                int c = first;\n                exp->_nodes[chain].next = c;\n                chain = c;\n                first = trex_charnode(exp, TRex_True);\n            } else {\n                first = trex_charnode(exp, TRex_True);\n            }\n        }\n    }\n    if (first != -1) {\n        int c = first;\n        exp->_nodes[chain].next = c;\n        chain = c;\n        first = -1;\n    }\n    /* hack? */\n    exp->_nodes[ret].left = exp->_nodes[ret].next;\n    exp->_nodes[ret].next = -1;\n    return ret;\n}\n\nstatic int trex_parsenumber(TRex* exp) {\n    int ret = *exp->_p - '0';\n    int positions = 10;\n    exp->_p++;\n    while (isdigit((int)(*exp->_p))) {\n        ret = ret * 10 + (*exp->_p++ - '0');\n        if (positions == 1000000000)\n            trex_error(exp, _SC(\"overflow in numeric constant\"));\n        positions *= 10;\n    };\n    return ret;\n}\n\nstatic int trex_element(TRex* exp) {\n    int ret = -1;\n    switch (*exp->_p) {\n        case '(': {\n            int expr, newn;\n            exp->_p++;\n\n            if (*exp->_p == '?') {\n                exp->_p++;\n                trex_expect(exp, ':');\n                expr = trex_newnode(exp, OP_NOCAPEXPR);\n            } else\n                expr = trex_newnode(exp, OP_EXPR);\n            newn = trex_list(exp);\n            exp->_nodes[expr].left = newn;\n            ret = expr;\n            trex_expect(exp, ')');\n        } break;\n        case '[':\n            exp->_p++;\n            ret = trex_class(exp);\n            trex_expect(exp, ']');\n            break;\n        case TREX_SYMBOL_END_OF_STRING:\n            exp->_p++;\n            ret = trex_newnode(exp, OP_EOL);\n            break;\n        case TREX_SYMBOL_ANY_CHAR:\n            exp->_p++;\n            ret = trex_newnode(exp, OP_DOT);\n            break;\n        default:\n            ret = trex_charnode(exp, TRex_False);\n            break;\n    }\n\n    {\n        TRexBool isgreedy = TRex_False;\n        unsigned short p0 = 0, p1 = 0;\n        switch (*exp->_p) {\n            case TREX_SYMBOL_GREEDY_ZERO_OR_MORE:\n                p0 = 0;\n                p1 = 0xFFFF;\n                exp->_p++;\n                isgreedy = TRex_True;\n                break;\n            case TREX_SYMBOL_GREEDY_ONE_OR_MORE:\n                p0 = 1;\n                p1 = 0xFFFF;\n                exp->_p++;\n                isgreedy = TRex_True;\n                break;\n            case TREX_SYMBOL_GREEDY_ZERO_OR_ONE:\n                p0 = 0;\n                p1 = 1;\n                exp->_p++;\n                isgreedy = TRex_True;\n                break;\n            case '{':\n                exp->_p++;\n                if (!isdigit((int)(*exp->_p)))\n                    trex_error(exp, _SC(\"number expected\"));\n                p0 = (unsigned short)trex_parsenumber(exp);\n                /*******************************/\n                switch (*exp->_p) {\n                    case '}':\n                        p1 = p0;\n                        exp->_p++;\n                        break;\n                    case ',':\n                        exp->_p++;\n                        p1 = 0xFFFF;\n                        if (isdigit((int)(*exp->_p))) {\n                            p1 = (unsigned short)trex_parsenumber(exp);\n                        }\n                        trex_expect(exp, '}');\n                        break;\n                    default:\n                        trex_error(exp, _SC(\", or } expected\"));\n                }\n                /*******************************/\n                isgreedy = TRex_True;\n                break;\n        }\n        if (isgreedy) {\n            int nnode = trex_newnode(exp, OP_GREEDY);\n            exp->_nodes[nnode].left = ret;\n            exp->_nodes[nnode].right = ((p0) << 16) | p1;\n            ret = nnode;\n        }\n    }\n    if ((*exp->_p != TREX_SYMBOL_BRANCH) && (*exp->_p != ')') && (*exp->_p != TREX_SYMBOL_GREEDY_ZERO_OR_MORE) &&\n        (*exp->_p != TREX_SYMBOL_GREEDY_ONE_OR_MORE) && (*exp->_p != '\\0')) {\n        int nnode = trex_element(exp);\n        exp->_nodes[ret].next = nnode;\n    }\n\n    return ret;\n}\n\nstatic int trex_list(TRex* exp) {\n    int ret = -1, e;\n    if (*exp->_p == TREX_SYMBOL_BEGINNING_OF_STRING) {\n        exp->_p++;\n        ret = trex_newnode(exp, OP_BOL);\n    }\n    e = trex_element(exp);\n    if (ret != -1) {\n        exp->_nodes[ret].next = e;\n    } else\n        ret = e;\n\n    if (*exp->_p == TREX_SYMBOL_BRANCH) {\n        int temp, tright;\n        exp->_p++;\n        temp = trex_newnode(exp, OP_OR);\n        exp->_nodes[temp].left = ret;\n        tright = trex_list(exp);\n        exp->_nodes[temp].right = tright;\n        ret = temp;\n    }\n    return ret;\n}\n\nstatic TRexBool trex_matchcclass(int cclass, TRexChar c) {\n    switch (cclass) {\n        case 'a':\n            return isalpha(c) ? TRex_True : TRex_False;\n        case 'A':\n            return !isalpha(c) ? TRex_True : TRex_False;\n        case 'w':\n            return (isalnum(c) || c == '_') ? TRex_True : TRex_False;\n        case 'W':\n            return (!isalnum(c) && c != '_') ? TRex_True : TRex_False;\n        case 's':\n            return isspace(c) ? TRex_True : TRex_False;\n        case 'S':\n            return !isspace(c) ? TRex_True : TRex_False;\n        case 'd':\n            return isdigit(c) ? TRex_True : TRex_False;\n        case 'D':\n            return !isdigit(c) ? TRex_True : TRex_False;\n        case 'x':\n            return isxdigit(c) ? TRex_True : TRex_False;\n        case 'X':\n            return !isxdigit(c) ? TRex_True : TRex_False;\n        case 'c':\n            return iscntrl(c) ? TRex_True : TRex_False;\n        case 'C':\n            return !iscntrl(c) ? TRex_True : TRex_False;\n        case 'p':\n            return ispunct(c) ? TRex_True : TRex_False;\n        case 'P':\n            return !ispunct(c) ? TRex_True : TRex_False;\n        case 'l':\n            return islower(c) ? TRex_True : TRex_False;\n        case 'u':\n            return isupper(c) ? TRex_True : TRex_False;\n    }\n    return TRex_False; /*cannot happen*/\n}\n\nstatic TRexBool trex_matchclass(TRex* exp, TRexNode* node, TRexChar c) {\n    do {\n        switch (node->type) {\n            case OP_RANGE:\n                if (exp->_flags & TREX_ICASE) {\n                    if (c >= toupper(node->left) && c <= toupper(node->right))\n                        return TRex_True;\n                    if (c >= tolower(node->left) && c <= tolower(node->right))\n                        return TRex_True;\n                } else {\n                    if (c >= node->left && c <= node->right)\n                        return TRex_True;\n                }\n                break;\n            case OP_CCLASS:\n                if (trex_matchcclass(node->left, c))\n                    return TRex_True;\n                break;\n            default:\n                if (exp->_flags & TREX_ICASE) {\n                    if (c == tolower(node->type) || c == toupper(node->type))\n                        return TRex_True;\n                } else {\n                    if (c == node->type)\n                        return TRex_True;\n                }\n        }\n    } while ((node->next != -1) && ((node = &exp->_nodes[node->next]) != NULL));\n    return TRex_False;\n}\n\nstatic const TRexChar* trex_matchnode(TRex* exp, TRexNode* node, const TRexChar* str, TRexNode* next) {\n    TRexNodeType type = node->type;\n    switch (type) {\n        case OP_GREEDY: {\n            /* TRexNode *greedystop = (node->next != -1) ? &exp->_nodes[node->next] : NULL; */\n            TRexNode* greedystop = NULL;\n            int p0 = (node->right >> 16) & 0x0000FFFF, p1 = node->right & 0x0000FFFF, nmaches = 0;\n            const TRexChar *s = str, *good = str;\n\n            if (node->next != -1) {\n                greedystop = &exp->_nodes[node->next];\n            } else {\n                greedystop = next;\n            }\n\n            while ((nmaches == 0xFFFF || nmaches < p1)) {\n                const TRexChar* stop;\n                if ((s = trex_matchnode(exp, &exp->_nodes[node->left], s, greedystop)) == NULL)\n                    break;\n                nmaches++;\n                good = s;\n                if (greedystop) {\n                    /* checks that 0 matches satisfy the expression(if so skips) */\n                    /* if not would always stop(for instance if is a '?') */\n                    if (greedystop->type != OP_GREEDY || (greedystop->type == OP_GREEDY && ((greedystop->right >> 16) & 0x0000FFFF) != 0)) {\n                        TRexNode* gnext = NULL;\n                        if (greedystop->next != -1) {\n                            gnext = &exp->_nodes[greedystop->next];\n                        } else if (next && next->next != -1) {\n                            gnext = &exp->_nodes[next->next];\n                        }\n                        stop = trex_matchnode(exp, greedystop, s, gnext);\n                        if (stop) {\n                            /* if satisfied stop it */\n                            if (p0 == p1 && p0 == nmaches)\n                                break;\n                            else if (nmaches >= p0 && p1 == 0xFFFF)\n                                break;\n                            else if (nmaches >= p0 && nmaches <= p1)\n                                break;\n                        }\n                    }\n                }\n\n                if (s >= exp->_eol)\n                    break;\n            }\n            if (p0 == p1 && p0 == nmaches)\n                return good;\n            else if (nmaches >= p0 && p1 == 0xFFFF)\n                return good;\n            else if (nmaches >= p0 && nmaches <= p1)\n                return good;\n            return NULL;\n        }\n        case OP_OR: {\n            const TRexChar* asd = str;\n            TRexNode* temp = &exp->_nodes[node->left];\n            while ((asd = trex_matchnode(exp, temp, asd, NULL)) != NULL) {\n                if (temp->next != -1)\n                    temp = &exp->_nodes[temp->next];\n                else\n                    return asd;\n            }\n            asd = str;\n            temp = &exp->_nodes[node->right];\n            while ((asd = trex_matchnode(exp, temp, asd, NULL)) != NULL) {\n                if (temp->next != -1)\n                    temp = &exp->_nodes[temp->next];\n                else\n                    return asd;\n            }\n            return NULL;\n            break;\n        }\n        case OP_EXPR:\n        case OP_NOCAPEXPR: {\n            TRexNode* n = &exp->_nodes[node->left];\n            const TRexChar* cur = str;\n            int capture = -1;\n            if (node->type != OP_NOCAPEXPR && node->right == exp->_currsubexp) {\n                capture = exp->_currsubexp;\n                exp->_matches[capture].begin = cur;\n                exp->_currsubexp++;\n            }\n\n            do {\n                TRexNode* subnext = NULL;\n                if (n->next != -1) {\n                    subnext = &exp->_nodes[n->next];\n                } else {\n                    subnext = next;\n                }\n                if ((cur = trex_matchnode(exp, n, cur, subnext)) == NULL) {\n                    if (capture != -1) {\n                        exp->_matches[capture].begin = 0;\n                        exp->_matches[capture].len = 0;\n                    }\n                    return NULL;\n                }\n            } while ((n->next != -1) && ((n = &exp->_nodes[n->next]) != NULL));\n\n            if (capture != -1)\n                exp->_matches[capture].len = (int)(cur - exp->_matches[capture].begin);\n            return cur;\n        }\n        case OP_WB:\n            if ((str == exp->_bol && !isspace((int)(*str))) || (str == exp->_eol && !isspace((int)(*(str - 1)))) || (!isspace((int)(*str)) && isspace((int)(*(str + 1)))) ||\n                (isspace((int)(*str)) && !isspace((int)(*(str + 1))))) {\n                return (node->left == 'b') ? str : NULL;\n            }\n            return (node->left == 'b') ? NULL : str;\n        case OP_BOL:\n            if (str == exp->_bol)\n                return str;\n            return NULL;\n        case OP_EOL:\n            if (str == exp->_eol)\n                return str;\n            return NULL;\n        case OP_DOT: {\n            str++;\n        }\n            return str;\n        case OP_NCLASS:\n        case OP_CLASS:\n            if (trex_matchclass(exp, &exp->_nodes[node->left], *str) ? (type == OP_CLASS ? TRex_True : TRex_False)\n                                                                     : (type == OP_NCLASS ? TRex_True : TRex_False)) {\n                str++;\n                return str;\n            }\n            return NULL;\n        case OP_CCLASS:\n            if (trex_matchcclass(node->left, *str)) {\n                str++;\n                return str;\n            }\n            return NULL;\n        default: /* char */\n            if (exp->_flags & TREX_ICASE) {\n                if (*str != tolower(node->type) && *str != toupper(node->type))\n                    return NULL;\n            } else {\n                if (*str != node->type)\n                    return NULL;\n            }\n            str++;\n            return str;\n    }\n}\n\n/* public api */\nTRex* trex_compile(const TRexChar* pattern, const TRexChar** error, int flags) {\n    TRex* exp = (TRex*)xmalloc(sizeof(TRex));\n    exp->_eol = exp->_bol = NULL;\n    exp->_p = pattern;\n    exp->_nallocated = (int)scstrlen(pattern) * sizeof(TRexChar);\n    exp->_nodes = (TRexNode*)xmalloc(exp->_nallocated * sizeof(TRexNode));\n    exp->_nsize = 0;\n    exp->_matches = 0;\n    exp->_nsubexpr = 0;\n    exp->_first = trex_newnode(exp, OP_EXPR);\n    exp->_error = error;\n    exp->_jmpbuf = xmalloc(sizeof(jmp_buf));\n    exp->_flags = flags;\n    if (setjmp(*((jmp_buf*)exp->_jmpbuf)) == 0) {\n        int res = trex_list(exp);\n        exp->_nodes[exp->_first].left = res;\n        if (*exp->_p != '\\0')\n            trex_error(exp, _SC(\"unexpected character\"));\n#ifdef ARG_REX_DEBUG\n        {\n            int nsize, i;\n            nsize = exp->_nsize;\n            scprintf(_SC(\"\\n\"));\n            for (i = 0; i < nsize; i++) {\n                if (exp->_nodes[i].type > MAX_CHAR)\n                    scprintf(_SC(\"[%02d] %10s \"), i, g_nnames[exp->_nodes[i].type - MAX_CHAR]);\n                else\n                    scprintf(_SC(\"[%02d] %10c \"), i, exp->_nodes[i].type);\n                scprintf(_SC(\"left %02d right %02d next %02d\\n\"), exp->_nodes[i].left, exp->_nodes[i].right, exp->_nodes[i].next);\n            }\n            scprintf(_SC(\"\\n\"));\n        }\n#endif\n        exp->_matches = (TRexMatch*)xmalloc(exp->_nsubexpr * sizeof(TRexMatch));\n        memset(exp->_matches, 0, exp->_nsubexpr * sizeof(TRexMatch));\n    } else {\n        trex_free(exp);\n        return NULL;\n    }\n    return exp;\n}\n\nvoid trex_free(TRex* exp) {\n    if (exp) {\n        xfree(exp->_nodes);\n        xfree(exp->_jmpbuf);\n        xfree(exp->_matches);\n        xfree(exp);\n    }\n}\n\nTRexBool trex_match(TRex* exp, const TRexChar* text) {\n    const TRexChar* res = NULL;\n    exp->_bol = text;\n    exp->_eol = text + scstrlen(text);\n    exp->_currsubexp = 0;\n    res = trex_matchnode(exp, exp->_nodes, text, NULL);\n    if (res == NULL || res != exp->_eol)\n        return TRex_False;\n    return TRex_True;\n}\n\nTRexBool trex_searchrange(TRex* exp, const TRexChar* text_begin, const TRexChar* text_end, const TRexChar** out_begin, const TRexChar** out_end) {\n    const TRexChar* cur = NULL;\n    int node = exp->_first;\n    if (text_begin >= text_end)\n        return TRex_False;\n    exp->_bol = text_begin;\n    exp->_eol = text_end;\n    do {\n        cur = text_begin;\n        while (node != -1) {\n            exp->_currsubexp = 0;\n            cur = trex_matchnode(exp, &exp->_nodes[node], cur, NULL);\n            if (!cur)\n                break;\n            node = exp->_nodes[node].next;\n        }\n        text_begin++;\n    } while (cur == NULL && text_begin != text_end);\n\n    if (cur == NULL)\n        return TRex_False;\n\n    --text_begin;\n\n    if (out_begin)\n        *out_begin = text_begin;\n    if (out_end)\n        *out_end = cur;\n    return TRex_True;\n}\n\nTRexBool trex_search(TRex* exp, const TRexChar* text, const TRexChar** out_begin, const TRexChar** out_end) {\n    return trex_searchrange(exp, text, text + scstrlen(text), out_begin, out_end);\n}\n\nint trex_getsubexpcount(TRex* exp) {\n    return exp->_nsubexpr;\n}\n\nTRexBool trex_getsubexp(TRex* exp, int n, TRexMatch* subexp) {\n    if (n < 0 || n >= exp->_nsubexpr)\n        return TRex_False;\n    *subexp = exp->_matches[n];\n    return TRex_True;\n}\n/*******************************************************************************\n * arg_str: Implements the str command-line option\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <stdlib.h>\n\nstatic void arg_str_resetfn(struct arg_str* parent) {\n    int i;\n    \n    ARG_TRACE((\"%s:resetfn(%p)\\n\", __FILE__, parent));\n    for (i = 0; i < parent->count; i++) {\n        parent->sval[i] = \"\";\n    }\n    parent->count = 0;\n}\n\nstatic int arg_str_scanfn(struct arg_str* parent, const char* argval) {\n    int errorcode = 0;\n\n    if (parent->count == parent->hdr.maxcount) {\n        /* maximum number of arguments exceeded */\n        errorcode = ARG_ERR_MAXCOUNT;\n    } else if (!argval) {\n        /* a valid argument with no argument value was given. */\n        /* This happens when an optional argument value was invoked. */\n        /* leave parent argument value unaltered but still count the argument. */\n        parent->count++;\n    } else {\n        parent->sval[parent->count++] = argval;\n    }\n\n    ARG_TRACE((\"%s:scanfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic int arg_str_checkfn(struct arg_str* parent) {\n    int errorcode = (parent->count < parent->hdr.mincount) ? ARG_ERR_MINCOUNT : 0;\n\n    ARG_TRACE((\"%s:checkfn(%p) returns %d\\n\", __FILE__, parent, errorcode));\n    return errorcode;\n}\n\nstatic void arg_str_errorfn(struct arg_str* parent, arg_dstr_t ds, int errorcode, const char* argval, const char* progname) {\n    const char* shortopts = parent->hdr.shortopts;\n    const char* longopts = parent->hdr.longopts;\n    const char* datatype = parent->hdr.datatype;\n\n    /* make argval NULL safe */\n    argval = argval ? argval : \"\";\n\n    arg_dstr_catf(ds, \"%s: \", progname);\n    switch (errorcode) {\n        case ARG_ERR_MINCOUNT:\n            arg_dstr_cat(ds, \"missing option \");\n            arg_print_option_ds(ds, shortopts, longopts, datatype, \"\\n\");\n            break;\n\n        case ARG_ERR_MAXCOUNT:\n            arg_dstr_cat(ds, \"excess option \");\n            arg_print_option_ds(ds, shortopts, longopts, argval, \"\\n\");\n            break;\n    }\n}\n\nstruct arg_str* arg_str0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_strn(shortopts, longopts, datatype, 0, 1, glossary);\n}\n\nstruct arg_str* arg_str1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary) {\n    return arg_strn(shortopts, longopts, datatype, 1, 1, glossary);\n}\n\nstruct arg_str* arg_strn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary) {\n    size_t nbytes;\n    struct arg_str* result;\n    int i;\n\n    /* should not allow this stupid error */\n    /* we should return an error code warning this logic error */\n    /* foolproof things by ensuring maxcount is not less than mincount */\n    maxcount = (maxcount < mincount) ? mincount : maxcount;\n\n    nbytes = sizeof(struct arg_str)      /* storage for struct arg_str */\n             + maxcount * sizeof(char*); /* storage for sval[maxcount] array */\n\n    result = (struct arg_str*)xmalloc(nbytes);\n\n    /* init the arg_hdr struct */\n    result->hdr.flag = ARG_HASVALUE;\n    result->hdr.shortopts = shortopts;\n    result->hdr.longopts = longopts;\n    result->hdr.datatype = datatype ? datatype : \"<string>\";\n    result->hdr.glossary = glossary;\n    result->hdr.mincount = mincount;\n    result->hdr.maxcount = maxcount;\n    result->hdr.parent = result;\n    result->hdr.resetfn = (arg_resetfn*)arg_str_resetfn;\n    result->hdr.scanfn = (arg_scanfn*)arg_str_scanfn;\n    result->hdr.checkfn = (arg_checkfn*)arg_str_checkfn;\n    result->hdr.errorfn = (arg_errorfn*)arg_str_errorfn;\n\n    /* store the sval[maxcount] array immediately after the arg_str struct */\n    result->sval = (const char**)(result + 1);\n    result->count = 0;\n\n    /* foolproof the string pointers by initializing them to reference empty strings */\n    for (i = 0; i < maxcount; i++)\n        result->sval[i] = \"\";\n\n    ARG_TRACE((\"arg_strn() returns %p\\n\", result));\n    return result;\n}\n/*******************************************************************************\n * arg_cmd: Provides the sub-command mechanism\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 2013-2019 Tom G. Huang\n * <tomghuang@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#endif\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_MODULE_VERSION_SIZE 128\n\nstatic arg_hashtable_t* s_hashtable = NULL;\nstatic char* s_module_name = NULL;\nstatic int s_mod_ver_major = 0;\nstatic int s_mod_ver_minor = 0;\nstatic int s_mod_ver_patch = 0;\nstatic char* s_mod_ver_tag = NULL;\nstatic char* s_mod_ver = NULL;\n\nvoid arg_set_module_name(const char* name) {\n    size_t slen;\n\n    xfree(s_module_name);\n    slen = strlen(name);\n    s_module_name = (char*)xmalloc(slen + 1);\n    memset(s_module_name, 0, slen + 1);\n\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n    strncpy_s(s_module_name, slen + 1, name, slen);\n#else\n    memcpy(s_module_name, name, slen);\n#endif\n}\n\nvoid arg_set_module_version(int major, int minor, int patch, const char* tag) {\n    size_t slen_tag, slen_ds;\n    arg_dstr_t ds;\n\n    s_mod_ver_major = major;\n    s_mod_ver_minor = minor;\n    s_mod_ver_patch = patch;\n\n    xfree(s_mod_ver_tag);\n    slen_tag = strlen(tag);\n    s_mod_ver_tag = (char*)xmalloc(slen_tag + 1);\n    memset(s_mod_ver_tag, 0, slen_tag + 1);\n\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n    strncpy_s(s_mod_ver_tag, slen_tag + 1, tag, slen_tag);\n#else\n    memcpy(s_mod_ver_tag, tag, slen_tag);\n#endif\n\n    ds = arg_dstr_create();\n    arg_dstr_catf(ds, \"%d.\", s_mod_ver_major);\n    arg_dstr_catf(ds, \"%d.\", s_mod_ver_minor);\n    arg_dstr_catf(ds, \"%d.\", s_mod_ver_patch);\n    arg_dstr_cat(ds, s_mod_ver_tag);\n\n    xfree(s_mod_ver);\n    slen_ds = strlen(arg_dstr_cstr(ds));\n    s_mod_ver = (char*)xmalloc(slen_ds + 1);\n    memset(s_mod_ver, 0, slen_ds + 1);\n\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n    strncpy_s(s_mod_ver, slen_ds + 1, arg_dstr_cstr(ds), slen_ds);\n#else\n    memcpy(s_mod_ver, arg_dstr_cstr(ds), slen_ds);\n#endif\n\n    arg_dstr_destroy(ds);\n}\n\nstatic unsigned int hash_key(const void* key) {\n    const char* str = (const char*)key;\n    int c;\n    unsigned int hash = 5381;\n\n    while ((c = *str++) != 0)\n        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */\n\n    return hash;\n}\n\nstatic int equal_keys(const void* key1, const void* key2) {\n    char* k1 = (char*)key1;\n    char* k2 = (char*)key2;\n    return (0 == strcmp(k1, k2));\n}\n\nvoid arg_cmd_init(void) {\n    s_hashtable = arg_hashtable_create(32, hash_key, equal_keys);\n}\n\nvoid arg_cmd_uninit(void) {\n    arg_hashtable_destroy(s_hashtable, 1);\n}\n\nvoid arg_cmd_register(const char* name, arg_cmdfn* proc, const char* description) {\n    arg_cmd_info_t* cmd_info;\n    size_t slen_name;\n    void* k;\n\n    assert(strlen(name) < ARG_CMD_NAME_LEN);\n    assert(strlen(description) < ARG_CMD_DESCRIPTION_LEN);\n\n    /* Check if the command already exists. */\n    /* If the command exists, replace the existing command. */\n    /* If the command doesn't exist, insert the command. */\n    cmd_info = (arg_cmd_info_t*)arg_hashtable_search(s_hashtable, name);\n    if (cmd_info) {\n        arg_hashtable_remove(s_hashtable, name);\n        cmd_info = NULL;\n    }\n\n    cmd_info = (arg_cmd_info_t*)xmalloc(sizeof(arg_cmd_info_t));\n    memset(cmd_info, 0, sizeof(arg_cmd_info_t));\n\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n    strncpy_s(cmd_info->name, ARG_CMD_NAME_LEN, name, strlen(name));\n    strncpy_s(cmd_info->description, ARG_CMD_DESCRIPTION_LEN, description, strlen(description));\n#else\n    memcpy(cmd_info->name, name, strlen(name));\n    memcpy(cmd_info->description, description, strlen(description));\n#endif\n\n    cmd_info->proc = proc;\n\n    slen_name = strlen(name);\n    k = xmalloc(slen_name + 1);\n    memset(k, 0, slen_name + 1);\n\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n    strncpy_s((char*)k, slen_name + 1, name, slen_name);\n#else\n    memcpy((char*)k, name, slen_name);\n#endif\n\n    arg_hashtable_insert(s_hashtable, k, cmd_info);\n}\n\nvoid arg_cmd_unregister(const char* name) {\n    arg_hashtable_remove(s_hashtable, name);\n}\n\nint arg_cmd_dispatch(const char* name, int argc, char* argv[], arg_dstr_t res) {\n    arg_cmd_info_t* cmd_info = arg_cmd_info(name);\n\n    assert(cmd_info != NULL);\n    assert(cmd_info->proc != NULL);\n\n    return cmd_info->proc(argc, argv, res);\n}\n\narg_cmd_info_t* arg_cmd_info(const char* name) {\n    return (arg_cmd_info_t*)arg_hashtable_search(s_hashtable, name);\n}\n\nunsigned int arg_cmd_count(void) {\n    return arg_hashtable_count(s_hashtable);\n}\n\narg_cmd_itr_t arg_cmd_itr_create(void) {\n    return (arg_cmd_itr_t)arg_hashtable_itr_create(s_hashtable);\n}\n\nint arg_cmd_itr_advance(arg_cmd_itr_t itr) {\n    return arg_hashtable_itr_advance((arg_hashtable_itr_t*)itr);\n}\n\nchar* arg_cmd_itr_key(arg_cmd_itr_t itr) {\n    return (char*)arg_hashtable_itr_key((arg_hashtable_itr_t*)itr);\n}\n\narg_cmd_info_t* arg_cmd_itr_value(arg_cmd_itr_t itr) {\n    return (arg_cmd_info_t*)arg_hashtable_itr_value((arg_hashtable_itr_t*)itr);\n}\n\nvoid arg_cmd_itr_destroy(arg_cmd_itr_t itr) {\n    arg_hashtable_itr_destroy((arg_hashtable_itr_t*)itr);\n}\n\nint arg_cmd_itr_search(arg_cmd_itr_t itr, void* k) {\n    return arg_hashtable_itr_search((arg_hashtable_itr_t*)itr, s_hashtable, k);\n}\n\nstatic const char* module_name(void) {\n    if (s_module_name == NULL || strlen(s_module_name) == 0)\n        return \"<name>\";\n\n    return s_module_name;\n}\n\nstatic const char* module_version(void) {\n    if (s_mod_ver == NULL || strlen(s_mod_ver) == 0)\n        return \"0.0.0.0\";\n\n    return s_mod_ver;\n}\n\nvoid arg_make_get_help_msg(arg_dstr_t res) {\n    arg_dstr_catf(res, \"%s v%s\\n\", module_name(), module_version());\n    arg_dstr_catf(res, \"Please type '%s help' to get more information.\\n\", module_name());\n}\n\nvoid arg_make_help_msg(arg_dstr_t ds, char* cmd_name, void** argtable) {\n    arg_cmd_info_t* cmd_info = (arg_cmd_info_t*)arg_hashtable_search(s_hashtable, cmd_name);\n    if (cmd_info) {\n        arg_dstr_catf(ds, \"%s: %s\\n\", cmd_name, cmd_info->description);\n    }\n\n    arg_dstr_cat(ds, \"Usage:\\n\");\n    arg_dstr_catf(ds, \"  %s\", module_name());\n\n    arg_print_syntaxv_ds(ds, argtable, \"\\n \\nAvailable options:\\n\");\n    arg_print_glossary_ds(ds, argtable, \"  %-23s %s\\n\");\n\n    arg_dstr_cat(ds, \"\\n\");\n}\n\nvoid arg_make_syntax_err_msg(arg_dstr_t ds, void** argtable, struct arg_end* end) {\n    arg_print_errors_ds(ds, end, module_name());\n    arg_dstr_cat(ds, \"Usage: \\n\");\n    arg_dstr_catf(ds, \"  %s\", module_name());\n    arg_print_syntaxv_ds(ds, argtable, \"\\n\");\n    arg_dstr_cat(ds, \"\\n\");\n}\n\nint arg_make_syntax_err_help_msg(arg_dstr_t ds, char* name, int help, int nerrors, void** argtable, struct arg_end* end, int* exitcode) {\n    /* help handling\n     * note: '-h|--help' takes precedence over error reporting\n     */\n    if (help > 0) {\n        arg_make_help_msg(ds, name, argtable);\n        *exitcode = EXIT_SUCCESS;\n        return 1;\n    }\n\n    /* syntax error handling */\n    if (nerrors > 0) {\n        arg_make_syntax_err_msg(ds, argtable, end);\n        *exitcode = EXIT_FAILURE;\n        return 1;\n    }\n\n    return 0;\n}\n/*******************************************************************************\n * argtable3: Implements the main interfaces of the library\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#include \"argtable3.h\"\n\n#ifndef ARG_AMALGAMATION\n#include \"argtable3_private.h\"\n#if ARG_REPLACE_GETOPT == 1\n#include \"arg_getopt.h\"\n#else\n#include <getopt.h>\n#endif\n#else\n#if ARG_REPLACE_GETOPT == 0\n#include <getopt.h>\n#endif\n#endif\n\n#ifdef _WIN32\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n#undef WIN32_LEAN_AND_MEAN\n#endif\n\n#include <assert.h>\n#include <ctype.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\nstatic void arg_register_error(struct arg_end* end, void* parent, int error, const char* argval) {\n    /* printf(\"arg_register_error(%p,%p,%d,%s)\\n\",end,parent,error,argval); */\n    if (end->count < end->hdr.maxcount) {\n        end->error[end->count] = error;\n        end->parent[end->count] = parent;\n        end->argval[end->count] = argval;\n        end->count++;\n    } else {\n        end->error[end->hdr.maxcount - 1] = ARG_ELIMIT;\n        end->parent[end->hdr.maxcount - 1] = end;\n        end->argval[end->hdr.maxcount - 1] = NULL;\n    }\n}\n\n/*\n * Return index of first table entry with a matching short option\n * or -1 if no match was found.\n */\nstatic int find_shortoption(struct arg_hdr** table, char shortopt) {\n    int tabindex;\n    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        if (table[tabindex]->shortopts && strchr(table[tabindex]->shortopts, shortopt))\n            return tabindex;\n    }\n    return -1;\n}\n\nstruct longoptions {\n    int getoptval;\n    int noptions;\n    struct option* options;\n};\n\n#if 0\nstatic\nvoid dump_longoptions(struct longoptions * longoptions)\n{\n    int i;\n    printf(\"getoptval = %d\\n\", longoptions->getoptval);\n    printf(\"noptions  = %d\\n\", longoptions->noptions);\n    for (i = 0; i < longoptions->noptions; i++)\n    {\n        printf(\"options[%d].name    = \\\"%s\\\"\\n\",\n               i,\n               longoptions->options[i].name);\n        printf(\"options[%d].has_arg = %d\\n\", i, longoptions->options[i].has_arg);\n        printf(\"options[%d].flag    = %p\\n\", i, longoptions->options[i].flag);\n        printf(\"options[%d].val     = %d\\n\", i, longoptions->options[i].val);\n    }\n}\n#endif\n\nstatic struct longoptions* alloc_longoptions(struct arg_hdr** table) {\n    struct longoptions* result;\n    size_t nbytes;\n    int noptions = 1;\n    size_t longoptlen = 0;\n    int tabindex;\n    int option_index = 0;\n    char* store;\n\n    /*\n     * Determine the total number of option structs required\n     * by counting the number of comma separated long options\n     * in all table entries and return the count in noptions.\n     * note: noptions starts at 1 not 0 because we getoptlong\n     * requires a NULL option entry to terminate the option array.\n     * While we are at it, count the number of chars required\n     * to store private copies of all the longoption strings\n     * and return that count in logoptlen.\n     */\n    tabindex = 0;\n    do {\n        const char* longopts = table[tabindex]->longopts;\n        longoptlen += (longopts ? strlen(longopts) : 0) + 1;\n        while (longopts) {\n            noptions++;\n            longopts = strchr(longopts + 1, ',');\n        }\n    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));\n    /*printf(\"%d long options consuming %d chars in total\\n\",noptions,longoptlen);*/\n\n    /* allocate storage for return data structure as: */\n    /* (struct longoptions) + (struct options)[noptions] + char[longoptlen] */\n    nbytes = sizeof(struct longoptions) + sizeof(struct option) * noptions + longoptlen;\n    result = (struct longoptions*)xmalloc(nbytes);\n\n    result->getoptval = 0;\n    result->noptions = noptions;\n    result->options = (struct option*)(result + 1);\n    store = (char*)(result->options + noptions);\n\n    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        const char* longopts = table[tabindex]->longopts;\n\n        while (longopts && *longopts) {\n            char* storestart = store;\n\n            /* copy progressive longopt strings into the store */\n            while (*longopts != 0 && *longopts != ',')\n                *store++ = *longopts++;\n            *store++ = 0;\n            if (*longopts == ',')\n                longopts++;\n            /*fprintf(stderr,\"storestart=\\\"%s\\\"\\n\",storestart);*/\n\n            result->options[option_index].name = storestart;\n            result->options[option_index].flag = &(result->getoptval);\n            result->options[option_index].val = tabindex;\n            if (table[tabindex]->flag & ARG_HASOPTVALUE)\n                result->options[option_index].has_arg = 2;\n            else if (table[tabindex]->flag & ARG_HASVALUE)\n                result->options[option_index].has_arg = 1;\n            else\n                result->options[option_index].has_arg = 0;\n\n            option_index++;\n        }\n    }\n    /* terminate the options array with a zero-filled entry */\n    result->options[option_index].name = 0;\n    result->options[option_index].has_arg = 0;\n    result->options[option_index].flag = 0;\n    result->options[option_index].val = 0;\n\n    /*dump_longoptions(result);*/\n    return result;\n}\n\nstatic char* alloc_shortoptions(struct arg_hdr** table) {\n    char* result;\n    size_t len = 2;\n    int tabindex;\n    char* res;\n\n    /* determine the total number of option chars required */\n    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        struct arg_hdr* hdr = table[tabindex];\n        len += 3 * (hdr->shortopts ? strlen(hdr->shortopts) : 0);\n    }\n\n    result = xmalloc(len);\n\n    res = result;\n\n    /* add a leading ':' so getopt return codes distinguish    */\n    /* unrecognised option and options missing argument values */\n    *res++ = ':';\n\n    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        struct arg_hdr* hdr = table[tabindex];\n        const char* shortopts = hdr->shortopts;\n        while (shortopts && *shortopts) {\n            *res++ = *shortopts++;\n            if (hdr->flag & ARG_HASVALUE)\n                *res++ = ':';\n            if (hdr->flag & ARG_HASOPTVALUE)\n                *res++ = ':';\n        }\n    }\n    /* null terminate the string */\n    *res = 0;\n\n    /*printf(\"alloc_shortoptions() returns \\\"%s\\\"\\n\",(result?result:\"NULL\"));*/\n    return result;\n}\n\n/* return index of the table terminator entry */\nstatic int arg_endindex(struct arg_hdr** table) {\n    int tabindex = 0;\n    while (!(table[tabindex]->flag & ARG_TERMINATOR))\n        tabindex++;\n    return tabindex;\n}\n\nstatic void arg_parse_tagged(int argc, char** argv, struct arg_hdr** table, struct arg_end* endtable) {\n    struct longoptions* longoptions;\n    char* shortoptions;\n    int copt;\n\n    /*printf(\"arg_parse_tagged(%d,%p,%p,%p)\\n\",argc,argv,table,endtable);*/\n\n    /* allocate short and long option arrays for the given opttable[].   */\n    /* if the allocs fail then put an error msg in the last table entry. */\n    longoptions = alloc_longoptions(table);\n    shortoptions = alloc_shortoptions(table);\n\n    /*dump_longoptions(longoptions);*/\n\n    /* reset getopts internal option-index to zero, and disable error reporting */\n    optind = 0;\n    opterr = 0;\n\n    /* fetch and process args using getopt_long */\n#ifdef ARG_LONG_ONLY\n    while ((copt = getopt_long_only(argc, argv, shortoptions, longoptions->options, NULL)) != -1) {\n#else\n    while ((copt = getopt_long(argc, argv, shortoptions, longoptions->options, NULL)) != -1) {\n#endif\n        /*\n           printf(\"optarg='%s'\\n\",optarg);\n           printf(\"optind=%d\\n\",optind);\n           printf(\"copt=%c\\n\",(char)copt);\n           printf(\"optopt=%c (%d)\\n\",optopt, (int)(optopt));\n         */\n        switch (copt) {\n            case 0: {\n                int tabindex = longoptions->getoptval;\n                void* parent = table[tabindex]->parent;\n                /*printf(\"long option detected from argtable[%d]\\n\", tabindex);*/\n                if (optarg && optarg[0] == 0 && (table[tabindex]->flag & ARG_HASVALUE)) {\n                    /* printf(\": long option %s requires an argument\\n\",argv[optind-1]); */\n                    arg_register_error(endtable, endtable, ARG_EMISSARG, argv[optind - 1]);\n                    /* continue to scan the (empty) argument value to enforce argument count checking */\n                }\n                if (table[tabindex]->scanfn) {\n                    int errorcode = table[tabindex]->scanfn(parent, optarg);\n                    if (errorcode != 0)\n                        arg_register_error(endtable, parent, errorcode, optarg);\n                }\n            } break;\n\n            case '?':\n                /*\n                 * getopt_long() found an unrecognised short option.\n                 * if it was a short option its value is in optopt\n                 * if it was a long option then optopt=0\n                 */\n                switch (optopt) {\n                    case 0:\n                        /*printf(\"?0 unrecognised long option %s\\n\",argv[optind-1]);*/\n                        arg_register_error(endtable, endtable, ARG_ELONGOPT, argv[optind - 1]);\n                        break;\n                    default:\n                        /*printf(\"?* unrecognised short option '%c'\\n\",optopt);*/\n                        arg_register_error(endtable, endtable, optopt, NULL);\n                        break;\n                }\n                break;\n\n            case ':':\n                /*\n                 * getopt_long() found an option with its argument missing.\n                 */\n                /*printf(\": option %s requires an argument\\n\",argv[optind-1]); */\n                arg_register_error(endtable, endtable, ARG_EMISSARG, argv[optind - 1]);\n                break;\n\n            default: {\n                /* getopt_long() found a valid short option */\n                int tabindex = find_shortoption(table, (char)copt);\n                /*printf(\"short option detected from argtable[%d]\\n\", tabindex);*/\n                if (tabindex == -1) {\n                    /* should never get here - but handle it just in case */\n                    /*printf(\"unrecognised short option %d\\n\",copt);*/\n                    arg_register_error(endtable, endtable, copt, NULL);\n                } else {\n                    if (table[tabindex]->scanfn) {\n                        void* parent = table[tabindex]->parent;\n                        int errorcode = table[tabindex]->scanfn(parent, optarg);\n                        if (errorcode != 0)\n                            arg_register_error(endtable, parent, errorcode, optarg);\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    xfree(shortoptions);\n    xfree(longoptions);\n}\n\nstatic void arg_parse_untagged(int argc, char** argv, struct arg_hdr** table, struct arg_end* endtable) {\n    int tabindex = 0;\n    int errorlast = 0;\n    const char* optarglast = NULL;\n    void* parentlast = NULL;\n\n    /*printf(\"arg_parse_untagged(%d,%p,%p,%p)\\n\",argc,argv,table,endtable);*/\n    while (!(table[tabindex]->flag & ARG_TERMINATOR)) {\n        void* parent;\n        int errorcode;\n\n        /* if we have exhausted our argv[optind] entries then we have finished */\n        if (optind >= argc) {\n            /*printf(\"arg_parse_untagged(): argv[] exhausted\\n\");*/\n            return;\n        }\n\n        /* skip table entries with non-null long or short options (they are not untagged entries) */\n        if (table[tabindex]->longopts || table[tabindex]->shortopts) {\n            /*printf(\"arg_parse_untagged(): skipping argtable[%d] (tagged argument)\\n\",tabindex);*/\n            tabindex++;\n            continue;\n        }\n\n        /* skip table entries with NULL scanfn */\n        if (!(table[tabindex]->scanfn)) {\n            /*printf(\"arg_parse_untagged(): skipping argtable[%d] (NULL scanfn)\\n\",tabindex);*/\n            tabindex++;\n            continue;\n        }\n\n        /* attempt to scan the current argv[optind] with the current     */\n        /* table[tabindex] entry. If it succeeds then keep it, otherwise */\n        /* try again with the next table[] entry.                        */\n        parent = table[tabindex]->parent;\n        errorcode = table[tabindex]->scanfn(parent, argv[optind]);\n        if (errorcode == 0) {\n            /* success, move onto next argv[optind] but stay with same table[tabindex] */\n            /*printf(\"arg_parse_untagged(): argtable[%d] successfully matched\\n\",tabindex);*/\n            optind++;\n\n            /* clear the last tentative error */\n            errorlast = 0;\n        } else {\n            /* failure, try same argv[optind] with next table[tabindex] entry */\n            /*printf(\"arg_parse_untagged(): argtable[%d] failed match\\n\",tabindex);*/\n            tabindex++;\n\n            /* remember this as a tentative error we may wish to reinstate later */\n            errorlast = errorcode;\n            optarglast = argv[optind];\n            parentlast = parent;\n        }\n    }\n\n    /* if a tentative error still remains at this point then register it as a proper error */\n    if (errorlast) {\n        arg_register_error(endtable, parentlast, errorlast, optarglast);\n        optind++;\n    }\n\n    /* only get here when not all argv[] entries were consumed */\n    /* register an error for each unused argv[] entry */\n    while (optind < argc) {\n        /*printf(\"arg_parse_untagged(): argv[%d]=\\\"%s\\\" not consumed\\n\",optind,argv[optind]);*/\n        arg_register_error(endtable, endtable, ARG_ENOMATCH, argv[optind++]);\n    }\n\n    return;\n}\n\nstatic void arg_parse_check(struct arg_hdr** table, struct arg_end* endtable) {\n    int tabindex = 0;\n    /* printf(\"arg_parse_check()\\n\"); */\n    do {\n        if (table[tabindex]->checkfn) {\n            void* parent = table[tabindex]->parent;\n            int errorcode = table[tabindex]->checkfn(parent);\n            if (errorcode != 0)\n                arg_register_error(endtable, parent, errorcode, NULL);\n        }\n    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));\n}\n\nstatic void arg_reset(void** argtable) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int tabindex = 0;\n    /*printf(\"arg_reset(%p)\\n\",argtable);*/\n    do {\n        if (table[tabindex]->resetfn)\n            table[tabindex]->resetfn(table[tabindex]->parent);\n    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));\n}\n\nint arg_parse(int argc, char** argv, void** argtable) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    struct arg_end* endtable;\n    int endindex;\n    char** argvcopy = NULL;\n    int i;\n\n    /*printf(\"arg_parse(%d,%p,%p)\\n\",argc,argv,argtable);*/\n\n    /* reset any argtable data from previous invocations */\n    arg_reset(argtable);\n\n    /* locate the first end-of-table marker within the array */\n    endindex = arg_endindex(table);\n    endtable = (struct arg_end*)table[endindex];\n\n    /* Special case of argc==0.  This can occur on Texas Instruments DSP. */\n    /* Failure to trap this case results in an unwanted NULL result from  */\n    /* the malloc for argvcopy (next code block).                         */\n    if (argc == 0) {\n        /* We must still perform post-parse checks despite the absence of command line arguments */\n        arg_parse_check(table, endtable);\n\n        /* Now we are finished */\n        return endtable->count;\n    }\n\n    argvcopy = (char**)xmalloc(sizeof(char*) * (argc + 1));\n\n    /*\n        Fill in the local copy of argv[]. We need a local copy\n        because getopt rearranges argv[] which adversely affects\n        subsequent parsing attempts.\n        */\n    for (i = 0; i < argc; i++)\n        argvcopy[i] = argv[i];\n\n    argvcopy[argc] = NULL;\n\n    /* parse the command line (local copy) for tagged options */\n    arg_parse_tagged(argc, argvcopy, table, endtable);\n\n    /* parse the command line (local copy) for untagged options */\n    arg_parse_untagged(argc, argvcopy, table, endtable);\n\n    /* if no errors so far then perform post-parse checks otherwise dont bother */\n    if (endtable->count == 0)\n        arg_parse_check(table, endtable);\n\n    /* release the local copt of argv[] */\n    xfree(argvcopy);\n\n    return endtable->count;\n}\n\n/*\n * Concatenate contents of src[] string onto *pdest[] string.\n * The *pdest pointer is altered to point to the end of the\n * target string and *pndest is decremented by the same number\n * of chars.\n * Does not append more than *pndest chars into *pdest[]\n * so as to prevent buffer overruns.\n * Its something like strncat() but more efficient for repeated\n * calls on the same destination string.\n * Example of use:\n *   char dest[30] = \"good\"\n *   size_t ndest = sizeof(dest);\n *   char *pdest = dest;\n *   arg_char(&pdest,\"bye \",&ndest);\n *   arg_char(&pdest,\"cruel \",&ndest);\n *   arg_char(&pdest,\"world!\",&ndest);\n * Results in:\n *   dest[] == \"goodbye cruel world!\"\n *   ndest  == 10\n */\nstatic void arg_cat(char** pdest, const char* src, size_t* pndest) {\n    char* dest = *pdest;\n    char* end = dest + *pndest;\n\n    /*locate null terminator of dest string */\n    while (dest < end && *dest != 0)\n        dest++;\n\n    /* concat src string to dest string */\n    while (dest < end && *src != 0)\n        *dest++ = *src++;\n\n    /* null terminate dest string */\n    *dest = 0;\n\n    /* update *pdest and *pndest */\n    *pndest = end - dest;\n    *pdest = dest;\n}\n\nstatic void arg_cat_option(char* dest, size_t ndest, const char* shortopts, const char* longopts, const char* datatype, int optvalue) {\n    if (shortopts) {\n        char option[3];\n\n        /* note: option array[] is initialized dynamically here to satisfy   */\n        /* a deficiency in the watcom compiler wrt static array initializers. */\n        option[0] = '-';\n        option[1] = shortopts[0];\n        option[2] = 0;\n\n        arg_cat(&dest, option, &ndest);\n        if (datatype) {\n            arg_cat(&dest, \" \", &ndest);\n            if (optvalue) {\n                arg_cat(&dest, \"[\", &ndest);\n                arg_cat(&dest, datatype, &ndest);\n                arg_cat(&dest, \"]\", &ndest);\n            } else\n                arg_cat(&dest, datatype, &ndest);\n        }\n    } else if (longopts) {\n        size_t ncspn;\n\n        /* add \"--\" tag prefix */\n        arg_cat(&dest, \"--\", &ndest);\n\n        /* add comma separated option tag */\n        ncspn = strcspn(longopts, \",\");\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n        strncat_s(dest, ndest, longopts, (ncspn < ndest) ? ncspn : ndest);\n#else\n        strncat(dest, longopts, (ncspn < ndest) ? ncspn : ndest);\n#endif\n\n        if (datatype) {\n            arg_cat(&dest, \"=\", &ndest);\n            if (optvalue) {\n                arg_cat(&dest, \"[\", &ndest);\n                arg_cat(&dest, datatype, &ndest);\n                arg_cat(&dest, \"]\", &ndest);\n            } else\n                arg_cat(&dest, datatype, &ndest);\n        }\n    } else if (datatype) {\n        if (optvalue) {\n            arg_cat(&dest, \"[\", &ndest);\n            arg_cat(&dest, datatype, &ndest);\n            arg_cat(&dest, \"]\", &ndest);\n        } else\n            arg_cat(&dest, datatype, &ndest);\n    }\n}\n\nstatic void arg_cat_optionv(char* dest, size_t ndest, const char* shortopts, const char* longopts, const char* datatype, int optvalue, const char* separator) {\n    separator = separator ? separator : \"\";\n\n    if (shortopts) {\n        const char* c = shortopts;\n        while (*c) {\n            /* \"-a|-b|-c\" */\n            char shortopt[3];\n\n            /* note: shortopt array[] is initialized dynamically here to satisfy */\n            /* a deficiency in the watcom compiler wrt static array initializers. */\n            shortopt[0] = '-';\n            shortopt[1] = *c;\n            shortopt[2] = 0;\n\n            arg_cat(&dest, shortopt, &ndest);\n            if (*++c)\n                arg_cat(&dest, separator, &ndest);\n        }\n    }\n\n    /* put separator between long opts and short opts */\n    if (shortopts && longopts)\n        arg_cat(&dest, separator, &ndest);\n\n    if (longopts) {\n        const char* c = longopts;\n        while (*c) {\n            size_t ncspn;\n\n            /* add \"--\" tag prefix */\n            arg_cat(&dest, \"--\", &ndest);\n\n            /* add comma separated option tag */\n            ncspn = strcspn(c, \",\");\n#if (defined(__STDC_LIB_EXT1__) && defined(__STDC_WANT_LIB_EXT1__)) || (defined(__STDC_SECURE_LIB__) && defined(__STDC_WANT_SECURE_LIB__))\n            strncat_s(dest, ndest, c, (ncspn < ndest) ? ncspn : ndest);\n#else\n            strncat(dest, c, (ncspn < ndest) ? ncspn : ndest);\n#endif\n            c += ncspn;\n\n            /* add given separator in place of comma */\n            if (*c == ',') {\n                arg_cat(&dest, separator, &ndest);\n                c++;\n            }\n        }\n    }\n\n    if (datatype) {\n        if (longopts)\n            arg_cat(&dest, \"=\", &ndest);\n        else if (shortopts)\n            arg_cat(&dest, \" \", &ndest);\n\n        if (optvalue) {\n            arg_cat(&dest, \"[\", &ndest);\n            arg_cat(&dest, datatype, &ndest);\n            arg_cat(&dest, \"]\", &ndest);\n        } else\n            arg_cat(&dest, datatype, &ndest);\n    }\n}\n\nvoid arg_print_option_ds(arg_dstr_t ds, const char* shortopts, const char* longopts, const char* datatype, const char* suffix) {\n    char syntax[200] = \"\";\n    suffix = suffix ? suffix : \"\";\n\n    /* there is no way of passing the proper optvalue for optional argument values here, so we must ignore it */\n    arg_cat_optionv(syntax, sizeof(syntax) - 1, shortopts, longopts, datatype, 0, \"|\");\n\n    arg_dstr_cat(ds, syntax);\n    arg_dstr_cat(ds, (char*)suffix);\n}\n\n/* this function should be deprecated because it doesn't consider optional argument values (ARG_HASOPTVALUE) */\nvoid arg_print_option(FILE* fp, const char* shortopts, const char* longopts, const char* datatype, const char* suffix) {\n    arg_dstr_t ds = arg_dstr_create();\n    arg_print_option_ds(ds, shortopts, longopts, datatype, suffix);\n    fputs(arg_dstr_cstr(ds), fp);\n    arg_dstr_destroy(ds);\n}\n\n/*\n * Print a GNU style [OPTION] string in which all short options that\n * do not take argument values are presented in abbreviated form, as\n * in: -xvfsd, or -xvf[sd], or [-xvsfd]\n */\nstatic void arg_print_gnuswitch_ds(arg_dstr_t ds, struct arg_hdr** table) {\n    int tabindex;\n    char* format1 = \" -%c\";\n    char* format2 = \" [-%c\";\n    char* suffix = \"\";\n\n    /* print all mandatory switches that are without argument values */\n    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        /* skip optional options */\n        if (table[tabindex]->mincount < 1)\n            continue;\n\n        /* skip non-short options */\n        if (table[tabindex]->shortopts == NULL)\n            continue;\n\n        /* skip options that take argument values */\n        if (table[tabindex]->flag & ARG_HASVALUE)\n            continue;\n\n        /* print the short option (only the first short option char, ignore multiple choices)*/\n        arg_dstr_catf(ds, format1, table[tabindex]->shortopts[0]);\n        format1 = \"%c\";\n        format2 = \"[%c\";\n    }\n\n    /* print all optional switches that are without argument values */\n    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        /* skip mandatory args */\n        if (table[tabindex]->mincount > 0)\n            continue;\n\n        /* skip args without short options */\n        if (table[tabindex]->shortopts == NULL)\n            continue;\n\n        /* skip args with values */\n        if (table[tabindex]->flag & ARG_HASVALUE)\n            continue;\n\n        /* print first short option */\n        arg_dstr_catf(ds, format2, table[tabindex]->shortopts[0]);\n        format2 = \"%c\";\n        suffix = \"]\";\n    }\n\n    arg_dstr_catf(ds, \"%s\", suffix);\n}\n\nvoid arg_print_syntax_ds(arg_dstr_t ds, void** argtable, const char* suffix) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int i, tabindex;\n\n    /* print GNU style [OPTION] string */\n    arg_print_gnuswitch_ds(ds, table);\n\n    /* print remaining options in abbreviated style */\n    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        char syntax[200] = \"\";\n        const char *shortopts, *longopts, *datatype;\n\n        /* skip short options without arg values (they were printed by arg_print_gnu_switch) */\n        if (table[tabindex]->shortopts && !(table[tabindex]->flag & ARG_HASVALUE))\n            continue;\n\n        shortopts = table[tabindex]->shortopts;\n        longopts = table[tabindex]->longopts;\n        datatype = table[tabindex]->datatype;\n        arg_cat_option(syntax, sizeof(syntax) - 1, shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE);\n\n        if (strlen(syntax) > 0) {\n            /* print mandatory instances of this option */\n            for (i = 0; i < table[tabindex]->mincount; i++) {\n                arg_dstr_cat(ds, \" \");\n                arg_dstr_cat(ds, syntax);\n            }\n\n            /* print optional instances enclosed in \"[..]\" */\n            switch (table[tabindex]->maxcount - table[tabindex]->mincount) {\n                case 0:\n                    break;\n                case 1:\n                    arg_dstr_cat(ds, \" [\");\n                    arg_dstr_cat(ds, syntax);\n                    arg_dstr_cat(ds, \"]\");\n                    break;\n                case 2:\n                    arg_dstr_cat(ds, \" [\");\n                    arg_dstr_cat(ds, syntax);\n                    arg_dstr_cat(ds, \"]\");\n                    arg_dstr_cat(ds, \" [\");\n                    arg_dstr_cat(ds, syntax);\n                    arg_dstr_cat(ds, \"]\");\n                    break;\n                default:\n                    arg_dstr_cat(ds, \" [\");\n                    arg_dstr_cat(ds, syntax);\n                    arg_dstr_cat(ds, \"]...\");\n                    break;\n            }\n        }\n    }\n\n    if (suffix) {\n        arg_dstr_cat(ds, (char*)suffix);\n    }\n}\n\nvoid arg_print_syntax(FILE* fp, void** argtable, const char* suffix) {\n    arg_dstr_t ds = arg_dstr_create();\n    arg_print_syntax_ds(ds, argtable, suffix);\n    fputs(arg_dstr_cstr(ds), fp);\n    arg_dstr_destroy(ds);\n}\n\nvoid arg_print_syntaxv_ds(arg_dstr_t ds, void** argtable, const char* suffix) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int i, tabindex;\n\n    /* print remaining options in abbreviated style */\n    for (tabindex = 0; table[tabindex] && !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        char syntax[200] = \"\";\n        const char *shortopts, *longopts, *datatype;\n\n        shortopts = table[tabindex]->shortopts;\n        longopts = table[tabindex]->longopts;\n        datatype = table[tabindex]->datatype;\n        arg_cat_optionv(syntax, sizeof(syntax) - 1, shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE, \"|\");\n\n        /* print mandatory options */\n        for (i = 0; i < table[tabindex]->mincount; i++) {\n            arg_dstr_cat(ds, \" \");\n            arg_dstr_cat(ds, syntax);\n        }\n\n        /* print optional args enclosed in \"[..]\" */\n        switch (table[tabindex]->maxcount - table[tabindex]->mincount) {\n            case 0:\n                break;\n            case 1:\n                arg_dstr_cat(ds, \" [\");\n                arg_dstr_cat(ds, syntax);\n                arg_dstr_cat(ds, \"]\");\n                break;\n            case 2:\n                arg_dstr_cat(ds, \" [\");\n                arg_dstr_cat(ds, syntax);\n                arg_dstr_cat(ds, \"]\");\n                arg_dstr_cat(ds, \" [\");\n                arg_dstr_cat(ds, syntax);\n                arg_dstr_cat(ds, \"]\");\n                break;\n            default:\n                arg_dstr_cat(ds, \" [\");\n                arg_dstr_cat(ds, syntax);\n                arg_dstr_cat(ds, \"]...\");\n                break;\n        }\n    }\n\n    if (suffix) {\n        arg_dstr_cat(ds, (char*)suffix);\n    }\n}\n\nvoid arg_print_syntaxv(FILE* fp, void** argtable, const char* suffix) {\n    arg_dstr_t ds = arg_dstr_create();\n    arg_print_syntaxv_ds(ds, argtable, suffix);\n    fputs(arg_dstr_cstr(ds), fp);\n    arg_dstr_destroy(ds);\n}\n\nvoid arg_print_glossary_ds(arg_dstr_t ds, void** argtable, const char* format) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int tabindex;\n\n    format = format ? format : \"  %-20s %s\\n\";\n    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        if (table[tabindex]->glossary) {\n            char syntax[200] = \"\";\n            const char* shortopts = table[tabindex]->shortopts;\n            const char* longopts = table[tabindex]->longopts;\n            const char* datatype = table[tabindex]->datatype;\n            const char* glossary = table[tabindex]->glossary;\n            arg_cat_optionv(syntax, sizeof(syntax) - 1, shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE, \", \");\n            arg_dstr_catf(ds, format, syntax, glossary);\n        }\n    }\n}\n\nvoid arg_print_glossary(FILE* fp, void** argtable, const char* format) {\n    arg_dstr_t ds = arg_dstr_create();\n    arg_print_glossary_ds(ds, argtable, format);\n    fputs(arg_dstr_cstr(ds), fp);\n    arg_dstr_destroy(ds);\n}\n\n/**\n * Print a piece of text formatted, which means in a column with a\n * left and a right margin. The lines are wrapped at whitspaces next\n * to right margin. The function does not indent the first line, but\n * only the following ones.\n *\n * Example:\n * arg_print_formatted( fp, 0, 5, \"Some text that doesn't fit.\" )\n * will result in the following output:\n *\n * Some\n * text\n * that\n * doesn'\n * t fit.\n *\n * Too long lines will be wrapped in the middle of a word.\n *\n * arg_print_formatted( fp, 2, 7, \"Some text that doesn't fit.\" )\n * will result in the following output:\n *\n * Some\n *   text\n *   that\n *   doesn'\n *   t fit.\n *\n * As you see, the first line is not indented. This enables output of\n * lines, which start in a line where output already happened.\n *\n * Author: Uli Fouquet\n */\nstatic void arg_print_formatted_ds(arg_dstr_t ds, const unsigned lmargin, const unsigned rmargin, const char* text) {\n    const unsigned int textlen = (unsigned int)strlen(text);\n    unsigned int line_start = 0;\n    unsigned int line_end = textlen;\n    const unsigned int colwidth = (rmargin - lmargin) + 1;\n\n    assert(strlen(text) < UINT_MAX);\n\n    /* Someone doesn't like us... */\n    if (line_end < line_start) {\n        arg_dstr_catf(ds, \"%s\\n\", text);\n    }\n\n    while (line_end > line_start) {\n        /* Eat leading white spaces. This is essential because while\n           wrapping lines, there will often be a whitespace at beginning\n           of line */\n        while (isspace((int)(*(text + line_start)))) {\n            line_start++;\n        }\n\n        /* Find last whitespace, that fits into line */\n        if (line_end - line_start > colwidth) {\n            line_end = line_start + colwidth;\n\n            while ((line_end > line_start) && !isspace((int)(*(text + line_end)))) {\n                line_end--;\n            }\n\n            /* Consume trailing spaces */\n            while ((line_end > line_start) && isspace((int)(*(text + line_end)))) {\n                line_end--;\n            }\n\n            /* Restore the last non-space character */\n            line_end++;\n        }\n\n        /* Output line of text */\n        while (line_start < line_end) {\n            char c = *(text + line_start);\n            arg_dstr_catc(ds, c);\n            line_start++;\n        }\n        arg_dstr_cat(ds, \"\\n\");\n\n        /* Initialize another line */\n        if (line_end < textlen) {\n            unsigned i;\n\n            for (i = 0; i < lmargin; i++) {\n                arg_dstr_cat(ds, \" \");\n            }\n\n            line_end = textlen;\n        }\n    } /* lines of text */\n}\n\n/**\n * Prints the glossary in strict GNU format.\n * Differences to arg_print_glossary() are:\n *   - wraps lines after 80 chars\n *   - indents lines without shortopts\n *   - does not accept formatstrings\n *\n * Contributed by Uli Fouquet\n */\nvoid arg_print_glossary_gnu_ds(arg_dstr_t ds, void** argtable) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int tabindex;\n\n    for (tabindex = 0; !(table[tabindex]->flag & ARG_TERMINATOR); tabindex++) {\n        if (table[tabindex]->glossary) {\n            char syntax[200] = \"\";\n            const char* shortopts = table[tabindex]->shortopts;\n            const char* longopts = table[tabindex]->longopts;\n            const char* datatype = table[tabindex]->datatype;\n            const char* glossary = table[tabindex]->glossary;\n\n            if (!shortopts && longopts) {\n                /* Indent trailing line by 4 spaces... */\n                memset(syntax, ' ', 4);\n                *(syntax + 4) = '\\0';\n            }\n\n            arg_cat_optionv(syntax, sizeof(syntax) - 1, shortopts, longopts, datatype, table[tabindex]->flag & ARG_HASOPTVALUE, \", \");\n\n            /* If syntax fits not into column, print glossary in new line... */\n            if (strlen(syntax) > 25) {\n                arg_dstr_catf(ds, \"  %-25s %s\\n\", syntax, \"\");\n                *syntax = '\\0';\n            }\n\n            arg_dstr_catf(ds, \"  %-25s \", syntax);\n            arg_print_formatted_ds(ds, 28, 79, glossary);\n        }\n    } /* for each table entry */\n\n    arg_dstr_cat(ds, \"\\n\");\n}\n\nvoid arg_print_glossary_gnu(FILE* fp, void** argtable) {\n    arg_dstr_t ds = arg_dstr_create();\n    arg_print_glossary_gnu_ds(ds, argtable);\n    fputs(arg_dstr_cstr(ds), fp);\n    arg_dstr_destroy(ds);\n}\n\n/**\n * Checks the argtable[] array for NULL entries and returns 1\n * if any are found, zero otherwise.\n */\nint arg_nullcheck(void** argtable) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int tabindex;\n    /*printf(\"arg_nullcheck(%p)\\n\",argtable);*/\n\n    if (!table)\n        return 1;\n\n    tabindex = 0;\n    do {\n        /*printf(\"argtable[%d]=%p\\n\",tabindex,argtable[tabindex]);*/\n        if (!table[tabindex])\n            return 1;\n    } while (!(table[tabindex++]->flag & ARG_TERMINATOR));\n\n    return 0;\n}\n\n/*\n * arg_free() is deprecated in favour of arg_freetable() due to a flaw in its design.\n * The flaw results in memory leak in the (very rare) case that an intermediate\n * entry in the argtable array failed its memory allocation while others following\n * that entry were still allocated ok. Those subsequent allocations will not be\n * deallocated by arg_free().\n * Despite the unlikeliness of the problem occurring, and the even unlikelier event\n * that it has any deleterious effect, it is fixed regardless by replacing arg_free()\n * with the newer arg_freetable() function.\n * We still keep arg_free() for backwards compatibility.\n */\nvoid arg_free(void** argtable) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    int tabindex = 0;\n    int flag;\n    /*printf(\"arg_free(%p)\\n\",argtable);*/\n    do {\n        /*\n           if we encounter a NULL entry then somewhat incorrectly we presume\n           we have come to the end of the array. It isnt strictly true because\n           an intermediate entry could be NULL with other non-NULL entries to follow.\n           The subsequent argtable entries would then not be freed as they should.\n         */\n        if (table[tabindex] == NULL)\n            break;\n\n        flag = table[tabindex]->flag;\n        xfree(table[tabindex]);\n        table[tabindex++] = NULL;\n\n    } while (!(flag & ARG_TERMINATOR));\n}\n\n/* frees each non-NULL element of argtable[], where n is the size of the number of entries in the array */\nvoid arg_freetable(void** argtable, size_t n) {\n    struct arg_hdr** table = (struct arg_hdr**)argtable;\n    size_t tabindex = 0;\n    /*printf(\"arg_freetable(%p)\\n\",argtable);*/\n    for (tabindex = 0; tabindex < n; tabindex++) {\n        if (table[tabindex] == NULL)\n            continue;\n\n        xfree(table[tabindex]);\n        table[tabindex] = NULL;\n    };\n}\n\n#ifdef _WIN32\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {\n    return TRUE;\n    UNREFERENCED_PARAMETER(hinstDLL);\n    UNREFERENCED_PARAMETER(fdwReason);\n    UNREFERENCED_PARAMETER(lpvReserved);\n}\n#endif\n"
        },
        {
          "name": "argtable3.h",
          "type": "blob",
          "size": 14.203125,
          "content": "/*******************************************************************************\n * argtable3: Declares the main interfaces of the library\n *\n * This file is part of the argtable3 library.\n *\n * Copyright (C) 1998-2001,2003-2011,2013 Stewart Heitmann\n * <sheitmann@users.sourceforge.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of STEWART HEITMANN nor the  names of its contributors\n *       may be used to endorse or promote products derived from this software\n *       without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL STEWART HEITMANN BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n ******************************************************************************/\n\n#ifndef ARGTABLE3\n#define ARGTABLE3\n\n#include <stdio.h> /* FILE */\n#include <time.h>  /* struct tm */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ARG_REX_ICASE 1\n#define ARG_DSTR_SIZE 200\n#define ARG_CMD_NAME_LEN 100\n#define ARG_CMD_DESCRIPTION_LEN 256\n\n#ifndef ARG_REPLACE_GETOPT\n#define ARG_REPLACE_GETOPT 1 /* use the embedded getopt as the system getopt(3) */\n#endif /* ARG_REPLACE_GETOPT */\n\n/* bit masks for arg_hdr.flag */\nenum { ARG_TERMINATOR = 0x1, ARG_HASVALUE = 0x2, ARG_HASOPTVALUE = 0x4 };\n\n#if defined(_WIN32)\n  #if defined(argtable3_EXPORTS)\n    #define ARG_EXTERN __declspec(dllexport)\n  #elif defined(argtable3_IMPORTS)\n    #define ARG_EXTERN __declspec(dllimport)\n  #else\n    #define ARG_EXTERN\n  #endif\n#else\n  #define ARG_EXTERN\n#endif\n\ntypedef struct _internal_arg_dstr* arg_dstr_t;\ntypedef void* arg_cmd_itr_t;\n\ntypedef void(arg_resetfn)(void* parent);\ntypedef int(arg_scanfn)(void* parent, const char* argval);\ntypedef int(arg_checkfn)(void* parent);\ntypedef void(arg_errorfn)(void* parent, arg_dstr_t ds, int error, const char* argval, const char* progname);\ntypedef void(arg_dstr_freefn)(char* buf);\ntypedef int(arg_cmdfn)(int argc, char* argv[], arg_dstr_t res);\ntypedef int(arg_comparefn)(const void* k1, const void* k2);\n\n/*\n * The arg_hdr struct defines properties that are common to all arg_xxx structs.\n * The argtable library requires each arg_xxx struct to have an arg_hdr\n * struct as its first data member.\n * The argtable library functions then use this data to identify the\n * properties of the command line option, such as its option tags,\n * datatype string, and glossary strings, and so on.\n * Moreover, the arg_hdr struct contains pointers to custom functions that\n * are provided by each arg_xxx struct which perform the tasks of parsing\n * that particular arg_xxx arguments, performing post-parse checks, and\n * reporting errors.\n * These functions are private to the individual arg_xxx source code\n * and are the pointer to them are initialised by that arg_xxx struct's\n * constructor function. The user could alter them after construction\n * if desired, but the original intention is for them to be set by the\n * constructor and left unaltered.\n */\ntypedef struct arg_hdr {\n    char flag;             /* Modifier flags: ARG_TERMINATOR, ARG_HASVALUE. */\n    const char* shortopts; /* String defining the short options */\n    const char* longopts;  /* String defining the long options */\n    const char* datatype;  /* Description of the argument data type */\n    const char* glossary;  /* Description of the option as shown by arg_print_glossary function */\n    int mincount;          /* Minimum number of occurences of this option accepted */\n    int maxcount;          /* Maximum number of occurences if this option accepted */\n    void* parent;          /* Pointer to parent arg_xxx struct */\n    arg_resetfn* resetfn;  /* Pointer to parent arg_xxx reset function */\n    arg_scanfn* scanfn;    /* Pointer to parent arg_xxx scan function */\n    arg_checkfn* checkfn;  /* Pointer to parent arg_xxx check function */\n    arg_errorfn* errorfn;  /* Pointer to parent arg_xxx error function */\n    void* priv;            /* Pointer to private header data for use by arg_xxx functions */\n} arg_hdr_t;\n\ntypedef struct arg_rem {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n} arg_rem_t;\n\ntypedef struct arg_lit {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n    int count;          /* Number of matching command line args */\n} arg_lit_t;\n\ntypedef struct arg_int {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n    int count;          /* Number of matching command line args */\n    int* ival;          /* Array of parsed argument values */\n} arg_int_t;\n\ntypedef struct arg_dbl {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n    int count;          /* Number of matching command line args */\n    double* dval;       /* Array of parsed argument values */\n} arg_dbl_t;\n\ntypedef struct arg_str {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n    int count;          /* Number of matching command line args */\n    const char** sval;  /* Array of parsed argument values */\n} arg_str_t;\n\ntypedef struct arg_rex {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n    int count;          /* Number of matching command line args */\n    const char** sval;  /* Array of parsed argument values */\n} arg_rex_t;\n\ntypedef struct arg_file {\n    struct arg_hdr hdr;     /* The mandatory argtable header struct */\n    int count;              /* Number of matching command line args*/\n    const char** filename;  /* Array of parsed filenames  (eg: /home/foo.bar) */\n    const char** basename;  /* Array of parsed basenames  (eg: foo.bar) */\n    const char** extension; /* Array of parsed extensions (eg: .bar) */\n} arg_file_t;\n\ntypedef struct arg_date {\n    struct arg_hdr hdr; /* The mandatory argtable header struct */\n    const char* format; /* strptime format string used to parse the date */\n    int count;          /* Number of matching command line args */\n    struct tm* tmval;   /* Array of parsed time values */\n} arg_date_t;\n\nenum { ARG_ELIMIT = 1, ARG_EMALLOC, ARG_ENOMATCH, ARG_ELONGOPT, ARG_EMISSARG };\ntypedef struct arg_end {\n    struct arg_hdr hdr;  /* The mandatory argtable header struct */\n    int count;           /* Number of errors encountered */\n    int* error;          /* Array of error codes */\n    void** parent;       /* Array of pointers to offending arg_xxx struct */\n    const char** argval; /* Array of pointers to offending argv[] string */\n} arg_end_t;\n\ntypedef struct arg_cmd_info {\n    char name[ARG_CMD_NAME_LEN];\n    char description[ARG_CMD_DESCRIPTION_LEN];\n    arg_cmdfn* proc;\n} arg_cmd_info_t;\n\n/**** arg_xxx constructor functions *********************************/\n\nARG_EXTERN struct arg_rem* arg_rem(const char* datatype, const char* glossary);\n\nARG_EXTERN struct arg_lit* arg_lit0(const char* shortopts, const char* longopts, const char* glossary);\nARG_EXTERN struct arg_lit* arg_lit1(const char* shortopts, const char* longopts, const char* glossary);\nARG_EXTERN struct arg_lit* arg_litn(const char* shortopts, const char* longopts, int mincount, int maxcount, const char* glossary);\n\nARG_EXTERN struct arg_int* arg_int0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_int* arg_int1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_int* arg_intn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);\n\nARG_EXTERN struct arg_dbl* arg_dbl0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_dbl* arg_dbl1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_dbl* arg_dbln(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);\n\nARG_EXTERN struct arg_str* arg_str0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_str* arg_str1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_str* arg_strn(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);\n\nARG_EXTERN struct arg_rex* arg_rex0(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary);\nARG_EXTERN struct arg_rex* arg_rex1(const char* shortopts, const char* longopts, const char* pattern, const char* datatype, int flags, const char* glossary);\nARG_EXTERN struct arg_rex* arg_rexn(const char* shortopts,\n                         const char* longopts,\n                         const char* pattern,\n                         const char* datatype,\n                         int mincount,\n                         int maxcount,\n                         int flags,\n                         const char* glossary);\n\nARG_EXTERN struct arg_file* arg_file0(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_file* arg_file1(const char* shortopts, const char* longopts, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_file* arg_filen(const char* shortopts, const char* longopts, const char* datatype, int mincount, int maxcount, const char* glossary);\n\nARG_EXTERN struct arg_date* arg_date0(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_date* arg_date1(const char* shortopts, const char* longopts, const char* format, const char* datatype, const char* glossary);\nARG_EXTERN struct arg_date* arg_daten(const char* shortopts, const char* longopts, const char* format, const char* datatype, int mincount, int maxcount, const char* glossary);\n\nARG_EXTERN struct arg_end* arg_end(int maxerrors);\n\n#define ARG_DSTR_STATIC ((arg_dstr_freefn*)0)\n#define ARG_DSTR_VOLATILE ((arg_dstr_freefn*)1)\n#define ARG_DSTR_DYNAMIC ((arg_dstr_freefn*)3)\n\n/**** other functions *******************************************/\nARG_EXTERN int arg_nullcheck(void** argtable);\nARG_EXTERN int arg_parse(int argc, char** argv, void** argtable);\nARG_EXTERN void arg_print_option(FILE* fp, const char* shortopts, const char* longopts, const char* datatype, const char* suffix);\nARG_EXTERN void arg_print_syntax(FILE* fp, void** argtable, const char* suffix);\nARG_EXTERN void arg_print_syntaxv(FILE* fp, void** argtable, const char* suffix);\nARG_EXTERN void arg_print_glossary(FILE* fp, void** argtable, const char* format);\nARG_EXTERN void arg_print_glossary_gnu(FILE* fp, void** argtable);\nARG_EXTERN void arg_print_errors(FILE* fp, struct arg_end* end, const char* progname);\nARG_EXTERN void arg_print_option_ds(arg_dstr_t ds, const char* shortopts, const char* longopts, const char* datatype, const char* suffix);\nARG_EXTERN void arg_print_syntax_ds(arg_dstr_t ds, void** argtable, const char* suffix);\nARG_EXTERN void arg_print_syntaxv_ds(arg_dstr_t ds, void** argtable, const char* suffix);\nARG_EXTERN void arg_print_glossary_ds(arg_dstr_t ds, void** argtable, const char* format);\nARG_EXTERN void arg_print_glossary_gnu_ds(arg_dstr_t ds, void** argtable);\nARG_EXTERN void arg_print_errors_ds(arg_dstr_t ds, struct arg_end* end, const char* progname);\nARG_EXTERN void arg_freetable(void** argtable, size_t n);\n\nARG_EXTERN arg_dstr_t arg_dstr_create(void);\nARG_EXTERN void arg_dstr_destroy(arg_dstr_t ds);\nARG_EXTERN void arg_dstr_reset(arg_dstr_t ds);\nARG_EXTERN void arg_dstr_free(arg_dstr_t ds);\nARG_EXTERN void arg_dstr_set(arg_dstr_t ds, char* str, arg_dstr_freefn* free_proc);\nARG_EXTERN void arg_dstr_cat(arg_dstr_t ds, const char* str);\nARG_EXTERN void arg_dstr_catc(arg_dstr_t ds, char c);\nARG_EXTERN void arg_dstr_catf(arg_dstr_t ds, const char* fmt, ...);\nARG_EXTERN char* arg_dstr_cstr(arg_dstr_t ds);\n\nARG_EXTERN void arg_cmd_init(void);\nARG_EXTERN void arg_cmd_uninit(void);\nARG_EXTERN void arg_cmd_register(const char* name, arg_cmdfn* proc, const char* description);\nARG_EXTERN void arg_cmd_unregister(const char* name);\nARG_EXTERN int arg_cmd_dispatch(const char* name, int argc, char* argv[], arg_dstr_t res);\nARG_EXTERN unsigned int arg_cmd_count(void);\nARG_EXTERN arg_cmd_info_t* arg_cmd_info(const char* name);\nARG_EXTERN arg_cmd_itr_t arg_cmd_itr_create(void);\nARG_EXTERN void arg_cmd_itr_destroy(arg_cmd_itr_t itr);\nARG_EXTERN int arg_cmd_itr_advance(arg_cmd_itr_t itr);\nARG_EXTERN char* arg_cmd_itr_key(arg_cmd_itr_t itr);\nARG_EXTERN arg_cmd_info_t* arg_cmd_itr_value(arg_cmd_itr_t itr);\nARG_EXTERN int arg_cmd_itr_search(arg_cmd_itr_t itr, void* k);\nARG_EXTERN void arg_mgsort(void* data, int size, int esize, int i, int k, arg_comparefn* comparefn);\nARG_EXTERN void arg_make_get_help_msg(arg_dstr_t res);\nARG_EXTERN void arg_make_help_msg(arg_dstr_t ds, char* cmd_name, void** argtable);\nARG_EXTERN void arg_make_syntax_err_msg(arg_dstr_t ds, void** argtable, struct arg_end* end);\nARG_EXTERN int arg_make_syntax_err_help_msg(arg_dstr_t ds, char* name, int help, int nerrors, void** argtable, struct arg_end* end, int* exitcode);\nARG_EXTERN void arg_set_module_name(const char* name);\nARG_EXTERN void arg_set_module_version(int major, int minor, int patch, const char* tag);\n\n/**** deprecated functions, for back-compatibility only ********/\nARG_EXTERN void arg_free(void** argtable);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n"
        },
        {
          "name": "basic.cfg",
          "type": "blob",
          "size": 0.9482421875,
          "content": "# This is a basic configuration file that should provide\n# sensible values for \"standard\" setup.\n\n# You will find extensive examples with explanations in\n# example.cfg\n\ntimeout: 2;\nuser: \"nobody\";\npidfile: \"/var/run/sslh.pid\";\n\n\n# Change hostname with your external address name, or the IP\n# of the interface that receives connections\n# Default is to bind all interfaces. httpd can be started\n# first to bind on localhost, in which case sslh will bind\n# only other interfaces.\nlisten:\n(\n    { host: \"0.0.0.0\"; port: \"443\"; },\n    { host: \"[::]\"; port: \"443\"; }\n);\n\n\n# Change to the protocols you want to forward to. The\n# defaults here are sensible for services running on\n# localhost\nprotocols:\n(\n     { name: \"ssh\"; service: \"ssh\"; host: \"localhost\"; port: \"22\"; fork: true; },\n     { name: \"openvpn\"; host: \"localhost\"; port: \"1194\"; },\n     { name: \"tls\"; host: \"localhost\"; port: \"443\"; log_level: 0; },\n     { name: \"anyprot\"; host: \"localhost\"; port: \"443\"; }\n);\n\n"
        },
        {
          "name": "collection.c",
          "type": "blob",
          "size": 2.708984375,
          "content": "/*\n   collection.c: management of a collection of connections, for sslh-select\n\n# Copyright (C) 2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#include \"common.h\"\n#include \"collection.h\"\n#include \"sslh-conf.h\"\n#include \"gap.h\"\n\n/* Info to keep track of all connections */\nstruct cnx_collection {\n    gap_array* fd2cnx;  /* Array indexed by file descriptor to things in cnx[] */\n};\n\n/* Allocates and initialises a new collection of connections with at least\n * `len` elements. */\ncnx_collection* collection_init(int len)\n{\n    cnx_collection* collection;\n\n    collection = malloc(sizeof(*collection));\n    CHECK_ALLOC(collection, \"collection_init(collection)\");\n\n    memset(collection, 0, sizeof(*collection));\n\n    collection->fd2cnx = gap_init(len);\n\n    return collection;\n}\n\n/* Caveat: might not work, as has never been used */\nvoid collection_destroy(cnx_collection* collection)\n{\n    /* Caveat 2: no code to free connections yet */\n    gap_destroy(collection->fd2cnx);\n    free(collection);\n}\n\n/* Points the file descriptor to the specified connection index */\nint collection_add_fd(cnx_collection* collection, struct connection* cnx, int fd)\n{\n    gap_set(collection->fd2cnx, fd, cnx);\n    return 0;\n}\n\n/* Allocates a connection and inits it with specified file descriptor */\nstruct connection* collection_alloc_cnx_from_fd(struct cnx_collection* collection, int fd)\n{\n    struct connection* cnx = malloc(sizeof(*cnx));\n\n    if (!cnx) return NULL;\n\n    init_cnx(cnx);\n    cnx->type = SOCK_STREAM;\n    cnx->q[0].fd = fd;\n    cnx->state = ST_PROBING;\n    cnx->probe_timeout = time(NULL) + cfg.timeout;\n\n    gap_set(collection->fd2cnx, fd, cnx);\n\n    return cnx;\n}\n\n/* Remove a connection from the collection */\nint collection_remove_cnx(cnx_collection* collection, struct connection *cnx)\n{\n    if (cnx->q[0].fd != -1)\n        gap_set(collection->fd2cnx, cnx->q[0].fd, NULL);\n    if (cnx->q[1].fd != -1)\n        gap_set(collection->fd2cnx, cnx->q[1].fd, NULL);\n    free(cnx);\n    return 0;\n}\n\n/* Returns the connection that contains the file descriptor */\nstruct connection* collection_get_cnx_from_fd(struct cnx_collection* collection, int fd)\n{\n    return gap_get(collection->fd2cnx, fd);\n}\n\n"
        },
        {
          "name": "collection.h",
          "type": "blob",
          "size": 0.56640625,
          "content": "#ifndef COLLECTION_H\n#define COLLECTION_H\n\ntypedef struct cnx_collection cnx_collection;\n\n\ncnx_collection* collection_init(int len);\nvoid collection_destroy(cnx_collection* collection);\n\nstruct connection* collection_alloc_cnx_from_fd(cnx_collection* collection, int fd);\nint collection_add_fd(cnx_collection* collection, struct connection* cnx, int fd);\n\n/* Remove a connection from the collection */\nint collection_remove_cnx(cnx_collection* collection, struct connection *cnx);\n\nstruct connection* collection_get_cnx_from_fd(struct cnx_collection* collection, int fd);\n\n#endif\n"
        },
        {
          "name": "common.c",
          "type": "blob",
          "size": 28.70703125,
          "content": "/* Code and variables that is common to both fork and select-based\n * servers.\n *\n * No code here should assume whether sockets are blocking or not.\n **/\n\n#define _GNU_SOURCE\n#include <stddef.h>\n#include <stdarg.h>\n#include <grp.h>\n\n#include <sys/types.h>\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <sys/un.h>\n\n#include \"common.h\"\n#include \"probe.h\"\n#include \"log.h\"\n#include \"sslh-conf.h\"\n\n/* Added to make the code compilable under CYGWIN\n * */\n#ifndef SA_NOCLDWAIT\n#define SA_NOCLDWAIT 0\n#endif\n\n/* Make use of systemd socket activation\n * */\n#ifdef SYSTEMD\n#include <systemd/sd-daemon.h>\n#endif\n\n#ifdef LIBBSD\n#include <bsd/unistd.h>\n#endif\n\n/*\n * Settings that depend on the command line or the config file\n */\nstruct sslhcfg_item cfg;\n\nstruct addrinfo *addr_listen = NULL; /* what addresses do we listen to? */\n\n\n#ifdef LIBWRAP\n#include <tcpd.h>\nint allow_severity =0, deny_severity = 0;\n#endif\n\ntypedef enum {\n    CR_DIE,\n    CR_WARN\n} CR_ACTION;\n\n/* check result and die, printing the offending address and error */\nvoid check_res_dump(CR_ACTION act, int res, struct addrinfo *addr, char* syscall)\n{\n    char buf[NI_MAXHOST];\n\n    if (res == -1) {\n        print_message(msg_system_error, \"%s:%s: %s\\n\",\n                sprintaddr(buf, sizeof(buf), addr),\n                syscall,\n                strerror(errno));\n\n        if (act == CR_DIE)\n            exit(1);\n    }\n}\n\nint get_fd_sockets(struct listen_endpoint *sockfd[])\n{\n    int sd = 0;\n\n#ifdef SYSTEMD\n    sd = sd_listen_fds(0);\n    if (sd < 0) {\n      print_message(msg_system_error, \"sd_listen_fds(): %s\\n\", strerror(-sd));\n      exit(1);\n    }\n    if (sd > 0) {\n      int i;\n      *sockfd = malloc(sd * sizeof(*sockfd[0]));\n      CHECK_ALLOC(*sockfd, \"malloc\");\n      for (i = 0; i < sd; i++) {\n        (*sockfd)[i].socketfd = SD_LISTEN_FDS_START + i;\n        (*sockfd)[i].type = SOCK_STREAM;\n      }\n    }\n#endif\n\n    return sd;\n}\n\n/* Set TCP_FASTOPEN on listening socket if all client protocols support it */\nint make_listen_tfo(int s)\n{\n    int i, qlen = 5;\n\n    /* Don't do it if not supported */\n    if (!TCP_FASTOPEN)\n        return 0;\n\n    /* Don't do it if any protocol does not specify it */\n    for (i = 0; i < cfg.protocols_len; i++) {\n        if (! cfg.protocols[i].tfo_ok)\n            return 0;\n    }\n\n    return setsockopt(s, SOL_SOCKET, TCP_FASTOPEN, (char*)&qlen, sizeof(qlen));\n}\n\n/* Starts listening on a single address\n * Returns a socket filehandle, or dies with message in case of major error */\nint listen_single_addr(struct addrinfo* addr, int keepalive, int udp)\n{\n    struct sockaddr_storage *saddr;\n    int sockfd, one, res;\n\n    saddr = (struct sockaddr_storage*)addr->ai_addr;\n\n    sockfd = socket(saddr->ss_family, udp ? SOCK_DGRAM : SOCK_STREAM, 0);\n    check_res_dump(CR_DIE, sockfd, addr, \"socket\");\n\n    one = 1;\n    res = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (char*)&one, sizeof(one));\n    check_res_dump(CR_DIE, res, addr, \"setsockopt(SO_REUSEADDR)\");\n\n    res = make_listen_tfo(sockfd);\n    check_res_dump(CR_WARN, res, addr, \"setsockopt(TCP_FASTOPEN)\");\n\n    if (keepalive) {\n        res = setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, (char*)&one, sizeof(one));\n        check_res_dump(CR_DIE, res, addr, \"setsockopt(SO_KEEPALIVE)\");\n    }\n\n    if (IP_FREEBIND) {\n        res = setsockopt(sockfd, IPPROTO_IP, IP_FREEBIND, (char*)&one, sizeof(one));\n        check_res_dump(CR_WARN, res, addr, \"setsockopt(IP_FREEBIND)\");\n    }\n\n    if (addr->ai_addr->sa_family == AF_INET6) {\n        res = setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&one, sizeof(one));\n        check_res_dump(CR_WARN, res, addr, \"setsockopt(IPV6_V6ONLY)\");\n    }\n\n    res = bind(sockfd, addr->ai_addr, addr->ai_addrlen);\n    check_res_dump(CR_DIE, res, addr, \"bind\");\n\n    if (!udp) {\n        res = listen (sockfd, 50);\n        check_res_dump(CR_DIE, res, addr, \"listen\");\n    }\n\n    return sockfd;\n}\n\n\n/* Start listening internet sockets for configuration entry 'index' \n * OUT: *sockfd[]: pointer to array of listen_endpoint object; we append new\n * endpoints to that array\n * IN: num_addr: how many entries are in sockfd[]\n *     *cfg: configuration data for the endpoint we are adding\n * Return: new value of num_addr\n * */\nstatic int start_listen_inet(struct listen_endpoint *sockfd[], int num_addr, struct sslhcfg_listen_item* cfg)\n{\n    struct addrinfo *addr, *start_addr;\n    char buf[NI_MAXHOST];\n    int res;\n\n    res = resolve_split_name(&start_addr, cfg->host, cfg->port);\n    if (res) exit(4);\n\n    for (addr = start_addr; addr; addr = addr->ai_next) {\n        num_addr++;\n        *sockfd = realloc(*sockfd, num_addr * sizeof(*sockfd[0]));\n        (*sockfd)[num_addr-1].socketfd = listen_single_addr(addr, cfg->keepalive, cfg->is_udp);\n        (*sockfd)[num_addr-1].type = cfg->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n        (*sockfd)[num_addr-1].family = AF_INET;\n        print_message(msg_config, \"%d:\\t%s\\t[%s] [%s]\\n\", (*sockfd)[num_addr-1].socketfd, sprintaddr(buf, sizeof(buf), addr),\n                      cfg->keepalive ? \"keepalive\" : \"\",\n                      cfg->is_udp ? \"udp\" : \"\");\n    }\n    freeaddrinfo(start_addr);\n    return num_addr;\n}\n\n/* Same, but for UNIX sockets */\nstatic int start_listen_unix(struct listen_endpoint *sockfd[], int num_addr, struct sslhcfg_listen_item* cfg)\n{\n    int fd = socket(AF_UNIX, cfg->is_udp ? SOCK_DGRAM : SOCK_STREAM, 0);\n    CHECK_RES_DIE(fd, \"socket(AF_UNIX)\");\n\n    int res = unlink(cfg->host);\n    if ((res == -1) && (errno != ENOENT)) {\n        print_message(msg_config_error, \"unlink unix socket `%s':%d:%s\\n\", cfg->host, errno, strerror(errno));\n        exit(4);\n    }\n\n    struct sockaddr_un sun;\n    sun.sun_family = AF_UNIX;\n    strncpy(sun.sun_path, cfg->host, sizeof(sun.sun_path)-1);\n    printf(\"binding [%s]\\n\", sun.sun_path);\n    res = bind(fd, (struct sockaddr*)&sun, sizeof(sun));\n    CHECK_RES_DIE(res, \"bind(AF_UNIX)\");\n\n    res = listen(fd, 50);\n\n    num_addr++;\n    *sockfd = realloc(*sockfd, num_addr * sizeof(*sockfd[0]));\n    (*sockfd)[num_addr-1].socketfd = fd;\n    (*sockfd)[num_addr-1].type = cfg->is_udp ? SOCK_DGRAM : SOCK_STREAM;\n    (*sockfd)[num_addr-1].family = AF_INET;\n\n    return num_addr;\n}\n\n\n/* Starts listening sockets on specified addresses.\n * OUT: *sockfd[]  pointer to newly-allocated array of listen_endpoint objects\n * Returns number of addresses bound\n   */\nint start_listen_sockets(struct listen_endpoint *sockfd[])\n{\n    int i;\n    int num_addr = 0, sd_socks = 0;\n\n    sd_socks = get_fd_sockets(sockfd);\n\n    if (sd_socks > 0) {\n        return sd_socks;\n    }\n\n    *sockfd = NULL;\n\n    print_message(msg_config, \"Listening to:\\n\");\n\n    for (i = 0; i < cfg.listen_len; i++) {\n        if (cfg.listen[i].is_unix) {\n            num_addr = start_listen_unix(sockfd, num_addr, &cfg.listen[i]);\n        } else {\n            num_addr = start_listen_inet(sockfd, num_addr, &cfg.listen[i]);\n        }\n    }\n\n    return num_addr;\n}\n\n\n/* returns 1 if given address is on the local machine: iterate through all\n * network interfaces and check their addresses */\nint is_same_machine(struct addrinfo* from)\n{\n    struct ifaddrs *ifaddrs_p = NULL, *ifa;\n    int match = 0;\n\n    getifaddrs(&ifaddrs_p);\n\n    for (ifa = ifaddrs_p; ifa != NULL; ifa = ifa->ifa_next)\n    {\n        if (!ifa->ifa_addr)\n            continue;\n        if (from->ai_addr->sa_family == ifa->ifa_addr->sa_family)\n        {\n            int family = ifa->ifa_addr->sa_family;\n            if (family == AF_INET)\n            {\n                struct sockaddr_in *from_addr = (struct sockaddr_in*)from->ai_addr;\n                struct sockaddr_in *ifa_addr = (struct sockaddr_in*)ifa->ifa_addr;\n                if (from_addr->sin_addr.s_addr == ifa_addr->sin_addr.s_addr) {\n                    match = 1;\n                    break;\n                }\n            }\n            else if (family == AF_INET6)\n            {\n                struct sockaddr_in6 *from_addr = (struct sockaddr_in6*)from->ai_addr;\n                struct sockaddr_in6 *ifa_addr = (struct sockaddr_in6*)ifa->ifa_addr;\n                if (!memcmp(from_addr->sin6_addr.s6_addr, ifa_addr->sin6_addr.s6_addr, 16)) {\n                    match = 1;\n                    break;\n                }\n            }\n        }\n    }\n    freeifaddrs(ifaddrs_p);\n    return match;\n}\n\n\n/* Transparent proxying: bind the peer address of fd to the peer address of\n * fd_from */\n#ifndef IP_TRANSPARENT\n  #define IP_TRANSPARENT 19\n#endif\n#ifndef IP_BIND_ADDRESS_NO_PORT\n  #define IP_BIND_ADDRESS_NO_PORT 24\n#endif\nint bind_peer(int fd, int fd_from)\n{\n    struct addrinfo from;\n    struct sockaddr_storage ss;\n    int res, enable = 1, disable = 0;\n\n    memset(&from, 0, sizeof(from));\n    from.ai_addr = (struct sockaddr*)&ss;\n    from.ai_addrlen = sizeof(ss);\n\n    /* getpeername can fail with ENOTCONN if connection was dropped before we\n     * got here */\n    res = getpeername(fd_from, from.ai_addr, &from.ai_addrlen);\n    CHECK_RES_RETURN(res, \"getpeername\", res);\n\n    /* if the destination is the same machine, there's no need to do bind */\n    if (is_same_machine(&from))\n        return 0;\n\n#ifndef IP_BINDANY /* use IP_TRANSPARENT */\n    res = setsockopt(fd, IPPROTO_IP, IP_TRANSPARENT, &enable, sizeof(enable));\n    CHECK_RES_DIE(res, \"setsockopt IP_TRANSPARENT\");\n    res = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));\n    CHECK_RES_DIE(res, \"setsockopt SO_REUSEADDR\");\n#else\n    if (from.ai_addr->sa_family==AF_INET) { /* IPv4 */\n        res = setsockopt(fd, IPPROTO_IP, IP_BINDANY, &enable, sizeof(enable));\n        CHECK_RES_RETURN(res, \"setsockopt IP_BINDANY\", res);\n#ifdef IPV6_BINDANY\n    } else { /* IPv6 */\n        res = setsockopt(fd, IPPROTO_IPV6, IPV6_BINDANY, &enable, sizeof(enable));\n        CHECK_RES_RETURN(res, \"setsockopt IPV6_BINDANY\", res);\n#endif /* IPV6_BINDANY */\n    }\n#endif /* IP_TRANSPARENT / IP_BINDANY */\n    res = bind(fd, from.ai_addr, from.ai_addrlen);\n    if (res == -1) {\n        if (errno != EADDRINUSE) {\n            print_message(msg_system_error, \"%s:%d:%s:%d:%s\\n\", __FILE__, __LINE__,\n                        \"bind\", errno, strerror(errno));\n            return res;\n        }\n        res = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &disable, sizeof(disable));\n        CHECK_RES_DIE(res, \"setsockopt SO_REUSEADDR\");\n        res = setsockopt(fd, IPPROTO_IP, IP_BIND_ADDRESS_NO_PORT, &enable, sizeof(enable));\n        CHECK_RES_RETURN(res, \"setsockopt IP_BIND_ADDRESS_NO_PORT\", res);\n        ((struct sockaddr_in *)from.ai_addr)->sin_port = 0;\n        res = bind(fd, from.ai_addr, from.ai_addrlen);\n        CHECK_RES_RETURN(res, \"bind\", res);\n        /*\n\t * There was a serious problem, when daisy-chaining programs using the same\n\t * ip transparent mechanism, as sslh uses. stunnel was mentioned in a previous \n\t * comment. This problem should now be solved through the two methods, getting\n\t * a connection established:\n\t * In the first try, SO_REUSEADDR is set to socket, which will allow the same\n\t * IP-address:port tuple, as it is used by another application. The check for\n\t * inconsistency with other connections (same 4-value-tupel) is done at the \n\t * moment, when the connection gets established.\n\t * If that fails, SO_REUSEADDR gets removed and IP_BIND_ADDRESS_NO_PORT get set.\n\t * This will search for a free port, which will not collide with current \n\t * connections. Read more in this excellent blog-post: \n\t * https://blog.cloudflare.com/how-to-stop-running-out-of-ephemeral-ports-and-start-to-love-long-lived-connections\n\t * The problem will still appear, if the another application in the daisy-chain\n\t * does not use similar mechanisms. In that case you must either pull this \n\t * application at the beginning of the chain, or get it fixed.\n         */\n    }\n\n    return 0;\n}\n\n/* Make the file descriptor non-block  */\nint set_nonblock(int fd)\n{\n    int flags;\n\n    flags = fcntl(fd, F_GETFL);\n    CHECK_RES_RETURN(flags, \"fcntl\", -1);\n\n    flags |= O_NONBLOCK;\n\n    flags = fcntl(fd, F_SETFL, flags);\n    CHECK_RES_RETURN(flags, \"fcntl\", -1);\n\n    return flags;\n}\n\n\n/* Connects to INET/INET6 domain sockets and return a fd */\nstatic int connect_inet(struct connection *cnx, int fd_from, connect_blocking blocking)\n{\n    struct addrinfo *a, from;\n    struct sockaddr_storage ss;\n    char buf[NI_MAXHOST];\n    int fd, res, one;\n    int transparent = cnx->proto->transparent || cfg.transparent;\n\n    memset(&from, 0, sizeof(from));\n    from.ai_addr = (struct sockaddr*)&ss;\n    from.ai_addrlen = sizeof(ss);\n\n    res = getpeername(fd_from, from.ai_addr, &from.ai_addrlen);\n    CHECK_RES_RETURN(res, \"getpeername\", res);\n\n    if (cnx->proto->resolve_on_forward) {\n        resolve_split_name(&(cnx->proto->saddr), cnx->proto->host,\n                           cnx->proto->port);\n    }\n    for (a = cnx->proto->saddr; a; a = a->ai_next) {\n        /* When transparent, make sure both connections use the same address family */\n        if (transparent && a->ai_family != from.ai_addr->sa_family)\n            continue;\n        print_message(msg_connections_try, \"trying to connect to %s family %d len %d\\n\",\n                    sprintaddr(buf, sizeof(buf), a),\n                    a->ai_addr->sa_family, a->ai_addrlen);\n\n        /* XXX Needs to match ai_family from fd_from when being transparent! */\n        fd = socket(a->ai_family, SOCK_STREAM, 0);\n        if (fd == -1) {\n            print_message(msg_connections_error, \"forward to %s failed:socket: %s\\n\",\n                        cnx->proto->name, strerror(errno));\n        } else {\n            one = 1;\n            setsockopt(fd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, &one, sizeof(one));\n            /* no need to check return value; if it's not supported, that's okay */\n\n            if (blocking == NON_BLOCKING) {\n                set_nonblock(fd);\n            }\n\n            if (transparent) {\n                res = bind_peer(fd, fd_from);\n                if (res == -1) close(fd);\n                CHECK_RES_RETURN(res, \"bind_peer\", res);\n            }\n            res = connect(fd, a->ai_addr, a->ai_addrlen);\n\n            /* EINPROGRESS indicates it might take time. If it eventually\n             * fails, it'll be caught as a failed read */\n            if ((res == -1) && (errno != EINPROGRESS)) {\n                print_message(msg_connections_error, \"forward to %s failed:connect: %s\\n\",\n                                     cnx->proto->name, strerror(errno));\n                close(fd);\n                continue; /* Try the next address */\n            }\n            if (cnx->proto->keepalive) {\n                res = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char*)&one, sizeof(one));\n                CHECK_RES_RETURN(res, \"setsockopt(SO_KEEPALIVE)\", res);\n            }\n            return fd;\n        }\n    }\n    return -1;\n}\n\n/* Connects to AF_UNIX domain sockets */\nstatic int connect_unix(struct connection *cnx, int fd_from, connect_blocking blocking)\n{\n    struct sockaddr_storage ss;\n    struct sockaddr_un* sun = (struct sockaddr_un*)&ss;\n\n    int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    sun->sun_family = AF_UNIX;\n    strncpy(sun->sun_path, cnx->proto->host, sizeof(sun->sun_path)-1);\n\n    int res = connect(fd, (struct sockaddr*)sun, sizeof(*sun));\n    CHECK_RES_RETURN(res, \"connect\", res);\n\n    if (blocking == NON_BLOCKING) {\n        set_nonblock(fd);\n    }\n    return fd;\n}\n\n/* Connect to first address that works and returns a file descriptor, or -1 if\n * none work.\n * If transparent proxying is on, use fd_from peer address on external address\n * of new file descriptor. */\nint connect_addr(struct connection *cnx, int fd_from, connect_blocking blocking)\n{\n    int fd;\n\n    if (cnx->proto->is_unix) {\n        fd = connect_unix(cnx, fd_from, blocking);\n    } else {\n        fd = connect_inet(cnx, fd_from, blocking);\n    }\n\n    return fd;\n}\n\n/* Store some data to write to the queue later */\nint defer_write(struct queue *q, void* data, ssize_t data_size)\n{\n    char *p;\n    ptrdiff_t data_offset = q->deferred_data - q->begin_deferred_data;\n\n    print_message(msg_fd, \"writing deferred on fd %d\\n\", q->fd);\n    p = realloc(q->begin_deferred_data, data_offset + q->deferred_data_size + data_size);\n    CHECK_ALLOC(p, \"realloc\");\n\n    q->begin_deferred_data = p;\n    q->deferred_data = p + data_offset;\n    p += data_offset + q->deferred_data_size;\n    q->deferred_data_size += (int)data_size;\n    memcpy(p, data, data_size);\n\n    return 0;\n}\n\n/* tries to flush some of the data for specified queue\n * Upon success, the number of bytes written is returned.\n * Upon failure, -1 returned (e.g. connexion closed)\n * */\nint flush_deferred(struct queue *q)\n{\n    ssize_t n;\n\n    print_message(msg_fd, \"flushing deferred data to fd %d\\n\", q->fd);\n\n    n = write(q->fd, q->deferred_data, q->deferred_data_size);\n    if (n == -1)\n        return (int)n;\n\n    if (n == q->deferred_data_size) {\n        /* All has been written -- release the memory */\n        free(q->begin_deferred_data);\n        q->begin_deferred_data = NULL;\n        q->deferred_data = NULL;\n        q->deferred_data_size = 0;\n    } else {\n        /* There is data left */\n        q->deferred_data += n;\n        q->deferred_data_size -= (int)n;\n    }\n\n    return (int)n;\n}\n\n\nvoid init_cnx(struct connection *cnx)\n{\n    memset(cnx, 0, sizeof(*cnx));\n    cnx->q[0].fd = -1;\n    cnx->q[1].fd = -1;\n    cnx->proto = NULL;\n}\n\nvoid dump_connection(struct connection *cnx)\n{\n    print_message(msg_int_error, \"type: %s\\n\", cnx->type == SOCK_DGRAM ? \"UDP\" : \"TCP\");\n    print_message(msg_int_error, \"state: %d\\n\", cnx->state);\n    print_message(msg_int_error, \"0: fd %d, %d deferred\\n\", cnx->q[0].fd, cnx->q[0].deferred_data_size);\n    hexdump(msg_int_error, cnx->q[0].deferred_data, cnx->q[0].deferred_data_size);\n    print_message(msg_int_error, \"1: fd %d, %d deferred\\n\", cnx->q[1].fd, cnx->q[1].deferred_data_size);\n    hexdump(msg_int_error, cnx->q[1].deferred_data, cnx->q[1].deferred_data_size);\n}\n\n\n/*\n * moves data from one fd to other\n *\n * returns number of bytes copied if success\n * returns 0 (FD_CNXCLOSED) if incoming socket closed\n * returns FD_NODATA if no data was available\n * returns FD_STALLED if data was read, could not be written, and has been\n * stored in temporary buffer.\n */\nint fd2fd(struct queue *target_q, struct queue *from_q)\n{\n   char buffer[BUFSIZ];\n   int target, from;\n   ssize_t size_r, size_w;\n\n   target = target_q->fd;\n   from = from_q->fd;\n\n   size_r = read(from, buffer, sizeof(buffer));\n   if (size_r == -1) {\n       switch (errno) {\n       case EAGAIN:\n           return FD_NODATA;\n\n       case ECONNRESET:\n       case ENOTSOCK:\n       case EPIPE:\n           return FD_CNXCLOSED;\n       }\n   }\n\n   CHECK_RES_RETURN(size_r, \"read\",FD_CNXCLOSED);\n\n   if (size_r == 0)\n      return FD_CNXCLOSED;\n\n   size_w = write(target, buffer, size_r);\n   /* process -1 when we know how to deal with it */\n   if (size_w == -1) {\n       switch (errno) {\n       case EAGAIN:\n           /* write blocked: Defer data */\n           defer_write(target_q, buffer, size_r);\n           return FD_STALLED;\n\n       case ECONNRESET:\n       case EPIPE:\n           /* remote end closed -- drop the connection */\n           return FD_CNXCLOSED;\n       }\n   } else if (size_w < size_r) {\n       /* incomplete write -- defer the rest of the data */\n       defer_write(target_q, buffer + size_w, size_r - size_w);\n       return FD_STALLED;\n   }\n\n   CHECK_RES_RETURN(size_w, \"write\", FD_CNXCLOSED);\n\n   return (int)size_w;\n}\n\n/* returns a string that prints the IP and port of the sockaddr */\nchar* sprintaddr(char* buf, size_t size, struct addrinfo *a)\n{\n   char host[NI_MAXHOST], serv[NI_MAXSERV];\n   int res;\n\n   memset(host, 0, sizeof(host));\n   memset(serv, 0, sizeof(serv));\n\n   res = getnameinfo(a->ai_addr, a->ai_addrlen,\n               host, sizeof(host),\n               serv, sizeof(serv),\n               cfg.numeric ? NI_NUMERICHOST | NI_NUMERICSERV : 0 );\n\n   if (res) {\n       print_message(msg_system_error, \"sprintaddr:getnameinfo: %s\\n\", gai_strerror(res));\n       /* Name resolution failed: do it numerically instead */\n       res = getnameinfo(a->ai_addr, a->ai_addrlen,\n                         host, sizeof(host),\n                         serv, sizeof(serv),\n                         NI_NUMERICHOST | NI_NUMERICSERV);\n       /* should not fail but... */\n       if (res) {\n           print_message(msg_system_error, \"sprintaddr:getnameinfo(NUM): %s\\n\", gai_strerror(res));\n           strcpy(host, \"?\");\n           strcpy(serv, \"?\");\n       }\n   }\n\n   snprintf(buf, size, \"%s:%s\", host, serv);\n\n   return buf;\n}\n\n/* Turns a hostname and port (or service) into a list of struct addrinfo\n * On success, returns 0 \n * On failure, returns -1 or one of getaddrinfo() codes\n */\nint resolve_split_name(struct addrinfo **out, char* host, char* serv)\n{\n   struct addrinfo hint;\n   char *end;\n   int res;\n\n   memset(&hint, 0, sizeof(hint));\n   hint.ai_family = PF_UNSPEC;\n   hint.ai_socktype = SOCK_STREAM;\n\n   /* If it is a RFC-Compliant IPv6 address (\"[1234::12]:443\"), remove brackets\n    * around IP address */\n   if (host[0] == '[') {\n       end = strrchr(host, ']');\n       if (!end) {\n           print_message(msg_config_error, \"%s: no closing bracket in IPv6 address?\\n\", host);\n           return -1;\n       }\n       host++; /* skip first bracket */\n       *end = 0; /* remove last bracket */\n   }\n\n   res = getaddrinfo(host, serv, &hint, out);\n   if (res)\n      print_message(msg_system_error, \"resolve_split_name: %s `%s:%s'\\n\", gai_strerror(res), host, serv);\n   return res;\n}\n\n/* turns a \"hostname:port\" string into a list of struct addrinfo;\nout: list of newly allocated addrinfo (see getaddrinfo(3)); freeaddrinfo(3) when done\nfullname: input string -- it gets clobbered\n*/\nvoid resolve_name(struct addrinfo **out, char* fullname)\n{\n   char *serv, *host;\n   int res;\n\n   /* Find port */\n   char *sep = strrchr(fullname, ':');\n   if (!sep) { /* No separator: parameter is just a port */\n      print_message(msg_config_error, \"%s: names must be fully specified as hostname:port\\n\", fullname);\n      exit(1);\n   }\n   serv = sep+1;\n   *sep = 0;\n\n   host = fullname;\n\n   res = resolve_split_name(out, host, serv);\n   if (res) {\n      print_message(msg_config_error, \"%s `%s'\\n\", gai_strerror(res), fullname);\n      if (res == EAI_SERVICE)\n         print_message(msg_config_error, \"(Check you have specified all ports)\\n\");\n      exit(4);\n   }\n}\n\n\n/* Fills a connection description; returns 0 on failure */\nint get_connection_desc(struct connection_desc* desc, const struct connection *cnx)\n{\n    int res;\n    struct addrinfo addr;\n    struct sockaddr_storage ss;\n\n    addr.ai_addr = (struct sockaddr*)&ss;\n    addr.ai_addrlen = sizeof(ss);\n\n    res = getpeername(cnx->q[0].fd, addr.ai_addr, &addr.ai_addrlen);\n    if (res == -1) return 0; /* Can happen if connection drops before we get here.\n                               In that case, don't log anything (there is no connection) */\n    sprintaddr(desc->peer, sizeof(desc->peer), &addr);\n\n    addr.ai_addrlen = sizeof(ss);\n    res = getsockname(cnx->q[0].fd, addr.ai_addr, &addr.ai_addrlen);\n    if (res == -1) return 0;\n    sprintaddr(desc->service, sizeof(desc->service), &addr);\n\n    addr.ai_addrlen = sizeof(ss);\n    res = getpeername(cnx->q[1].fd, addr.ai_addr, &addr.ai_addrlen);\n    if (res == -1) return 0;\n    sprintaddr(desc->target, sizeof(desc->target), &addr);\n\n    addr.ai_addrlen = sizeof(ss);\n    res = getsockname(cnx->q[1].fd, addr.ai_addr, &addr.ai_addrlen);\n    if (res == -1) return 0;\n    sprintaddr(desc->local, sizeof(desc->local), &addr);\n\n    return 1;\n}\n\n\nvoid set_proctitle_shovel(struct connection_desc* desc, const struct connection *cnx)\n{\n#ifdef LIBBSD\n    struct connection_desc d;\n\n    if (!desc) {\n        desc = &d;\n        get_connection_desc(desc, cnx);\n    }\n    setproctitle(\"shovel %s %s->%s => %s->%s\",\n        cnx->proto->name,\n        desc->peer,\n        desc->service,\n        desc->local,\n        desc->target);\n#endif\n}\n\n\n/* libwrap (tcpd): check the connection is legal. This is necessary because\n * the actual server will only see a connection coming from localhost and can't\n * apply the rules itself.\n *\n * Returns -1 if access is denied, 0 otherwise\n */\nint check_access_rights(int in_socket, const char* service)\n{\n#ifdef LIBWRAP\n    union {\n        struct sockaddr saddr;\n        struct sockaddr_storage ss;\n    } peer;\n    socklen_t size = sizeof(peer);\n    char addr_str[NI_MAXHOST], host[NI_MAXHOST];\n    int res;\n\n    res = getpeername(in_socket, &peer.saddr, &size);\n    CHECK_RES_RETURN(res, \"getpeername\", res);\n\n    /* extract peer address */\n    res = getnameinfo(&peer.saddr, size, addr_str, sizeof(addr_str), NULL, 0, NI_NUMERICHOST);\n    if (res) {\n        print_message(msg_system_error, \"getnameinfo(NI_NUMERICHOST):%s\\n\", gai_strerror(res));\n        strcpy(addr_str, STRING_UNKNOWN);\n    }\n    /* extract peer name */\n    strcpy(host, STRING_UNKNOWN);\n    if (!cfg.numeric) {\n        res = getnameinfo(&peer.saddr, size, host, sizeof(host), NULL, 0, NI_NAMEREQD);\n        if (res) {\n            print_message(msg_system_error, \"getnameinfo(NI_NAMEREQD):%s\\n\", gai_strerror(res));\n        }\n    }\n\n    if (!hosts_ctl(service, host, addr_str, STRING_UNKNOWN)) {\n        print_message(msg_connections, \"connection from %s(%s): access denied\", host, addr_str);\n        close(in_socket);\n        return -1;\n    }\n#endif\n    return 0;\n}\n\nvoid setup_signals(void)\n{\n    int res;\n    struct sigaction action;\n\n    /* Request no SIGCHLD is sent upon termination of\n     * the children */\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = NULL;\n    action.sa_flags = SA_NOCLDWAIT;\n    res = sigaction(SIGCHLD, &action, NULL);\n    CHECK_RES_DIE(res, \"sigaction\");\n\n    /* Set SIGTERM to exit. For some reason if it's not set explicitly,\n     * coverage information is lost when killing the process */\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = exit;\n    res = sigaction(SIGTERM, &action, NULL);\n    CHECK_RES_DIE(res, \"sigaction\");\n\n    /* Ignore SIGPIPE . */\n    action.sa_handler = SIG_IGN;\n    res = sigaction(SIGPIPE, &action, NULL);\n    CHECK_RES_DIE(res, \"sigaction\");\n\n}\n\n\n/* Ask OS to keep capabilities over a setuid(nonzero) */\nvoid set_keepcaps(int val) {\n#ifdef LIBCAP\n    int res;\n    res = prctl(PR_SET_KEEPCAPS, val, 0, 0, 0);\n    if (res) {\n        perror(\"prctl\");\n        exit(1);\n    }\n#endif\n}\n\n/* Returns true if anything requires transparent proxying. */\nstatic int use_transparent(void)\n{\n#ifdef LIBCAP\n    if (cfg.transparent)\n        return 1;\n\n    for (int i = 0; i < cfg.protocols_len; i++)\n        if (cfg.protocols[i].transparent)\n            return 1;\n\n#endif\n    return 0;\n}\n\n/* set needed capabilities for effective and permitted, clear rest\n * IN: cap_net_admin: set to 1 to set CAP_NET_RAW\n * */\nvoid set_capabilities(int cap_net_admin) {\n#ifdef LIBCAP\n    int res;\n    cap_t caps;\n    cap_value_t cap_list[10];\n    int ncap = 0;\n\n    if (cap_net_admin)\n        cap_list[ncap++] = CAP_NET_RAW;\n\n    caps = cap_init();\n\n#define _cap_set_flag(flag) do { \\\n        res = cap_clear_flag(caps, flag); \\\n        CHECK_RES_DIE(res, \"cap_clear_flag(\" #flag \")\"); \\\n        if (ncap > 0) { \\\n            res = cap_set_flag(caps, flag, ncap, cap_list, CAP_SET); \\\n            CHECK_RES_DIE(res, \"cap_set_flag(\" #flag \")\"); \\\n        } \\\n    } while(0)\n\n    _cap_set_flag(CAP_EFFECTIVE);\n    _cap_set_flag(CAP_PERMITTED);\n\n#undef _cap_set_flag\n\n    res = cap_set_proc(caps);\n    CHECK_RES_DIE(res, \"cap_set_proc\");\n\n    res = cap_free(caps);\n    if (res) {\n        perror(\"cap_free\");\n        exit(1);\n    }\n#endif\n}\n\n/* We don't want to run as root -- drop privileges if required */\nvoid drop_privileges(const char* user_name, const char* chroot_path)\n{\n    int res;\n    struct passwd *pw = NULL;\n\n    if (user_name) {\n        pw = getpwnam(user_name);\n        if (!pw) {\n            print_message(msg_config_error, \"%s: not found\\n\", user_name);\n            exit(2);\n        }\n        print_message(msg_config, \"turning into %s\\n\", user_name);\n    }\n\n    if (chroot_path) {\n        print_message(msg_config, \"chrooting into %s\\n\", chroot_path);\n\n        res = chroot(chroot_path);\n        CHECK_RES_DIE(res, \"chroot\");\n    }\n\n    if (user_name) {\n        set_keepcaps(1);\n\n        /* remove extraneous groups in case we belong to several extra groups\n         * that may have unwanted rights. If non-root when calling setgroups(),\n         * it fails, which is fine because... we have no unwanted rights\n         * (see POS36-C for security context)\n         * */\n        setgroups(0, NULL);\n\n        res = setgid(pw->pw_gid);\n        CHECK_RES_DIE(res, \"setgid\");\n        res = setuid(pw->pw_uid);\n        CHECK_RES_DIE(res, \"setuid\");\n\n        set_capabilities(use_transparent());\n        set_keepcaps(0);\n    }\n}\n\n/* Writes my PID */\nvoid write_pid_file(const char* pidfile)\n{\n    FILE *f;\n    int res;\n\n    f = fopen(pidfile, \"w\");\n    if (!f) {\n        print_message(msg_system_error, \"write_pid_file: %s: %s\\n\", pidfile, strerror(errno));\n        return;\n    }\n\n    res = fprintf(f, \"%d\\n\", getpid());\n    if (res < 0) {\n        print_message(msg_system_error, \"write_pid_file: fprintf: %s\\n\", strerror(errno));\n    }\n\n    res = fclose(f);\n    if (res == EOF) {\n        print_message(msg_system_error, \"write_pid_file: fclose: %s\\n\", strerror(errno));\n        return;\n    }\n}\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 5.025390625,
          "content": "#ifndef COMMON_H\n#define COMMON_H\n\n/* FD_SETSIZE is 64 on Cygwin, which is really low. Just redefining it is\n * enough for the macros to adapt (http://support.microsoft.com/kb/111855)\n */\n#ifdef __CYGWIN__\n#undef FD_SETSIZE\n#define FD_SETSIZE 4096\n#endif\n\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <libgen.h>\n#include <time.h>\n#include <getopt.h>\n\n#ifdef LIBCAP\n#include <sys/prctl.h>\n#include <sys/capability.h>\n#endif\n\n#include \"version.h\"\n\n#define MAX(a, b)  (((a) > (b)) ? (a) : (b))\n\n\n#define CHECK_RES_DIE(res, str) \\\n    if (res == -1) {    \\\n       print_message(msg_system_error, \"%s:%d:\", __FILE__, __LINE__); \\\n       perror(str);     \\\n       exit(1);         \\\n    }\n\n#define CHECK_RES_RETURN(res, str, ret) \\\n    if (res == -1) {                                    \\\n        print_message(msg_system_error, \"%s:%d:%s:%d:%s\\n\", __FILE__, __LINE__, str, errno, strerror(errno));  \\\n        return ret;                                     \\\n    } \n\n#define CHECK_ALLOC(a, str) \\\n    if (!a) { \\\n        print_message(msg_system_error, \"%s:%d:\", __FILE__, __LINE__); \\\n        perror(str); \\\n        exit(1); \\\n    }\n\n#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))\n\n#if 1\n#define TRACE fprintf(stderr, \"%s:%d\\n\", __FILE__, __LINE__);\n#else\n#define TRACE\n#endif\n\n#ifndef IP_FREEBIND\n#define IP_FREEBIND 0\n#endif\n\n#ifndef TCP_FASTOPEN\n#define TCP_FASTOPEN 0\n#endif\n\n#ifndef TCP_FASTOPEN_CONNECT\n#define TCP_FASTOPEN_CONNECT 30 /* Attempt FastOpen with connect.  */\n#endif\n\nenum connection_state {\n    ST_PROBING=1,    /* Waiting for timeout to find where to forward */\n    ST_SHOVELING   /* Connexion is established */\n};\n\n/* A 'queue' is composed of a file descriptor (which can be read from or\n * written to), and a queue for deferred write data */\nstruct queue {\n    int fd;\n    void *begin_deferred_data;\n    void *deferred_data;\n    int deferred_data_size;\n};\n\n/* Double linked list for timeout management */\ntypedef struct {\n    struct connection* head;\n    struct connection* tail;\n} dl_list;\n\nstruct connection {\n    int type;           /* SOCK_DGRAM | SOCK_STREAM */\n    struct sslhcfg_protocols_item* proto; /* Where to connect to */\n\n    /* SOCK_STREAM */\n    enum connection_state state;\n    time_t probe_timeout;\n\n    /* q[0]: queue for external connection (client);\n     * q[1]: queue for internal connection (httpd or sshd);\n     * */\n    struct queue q[2];\n\n    /* SOCK_DGRAM */\n    struct sockaddr_storage client_addr; /* Contains the remote client address */\n    socklen_t addrlen;\n\n    int local_endpoint; /* Contains the local address */\n\n    time_t last_active;\n\n    /* double linked list of timeouts */\n    struct connection *timeout_prev, *timeout_next;\n\n    /* We need one local socket for each target server, so we know where to\n     * forward server responses */\n    int target_sock;  \n};\n\n\nstruct listen_endpoint {\n    int socketfd;       /* file descriptor of listening socket */\n    int type;           /* SOCK_DGRAM | SOCK_STREAM */\n    int family;         /* AF_INET | AF_UNIX */\n};\n\n#define FD_CNXCLOSED    0\n#define FD_NODATA       -1\n#define FD_STALLED      -2\n\n/* String description of a connection */\n#define MAX_NAMELENGTH (NI_MAXHOST + NI_MAXSERV + 1)\nstruct connection_desc {\n    char peer[MAX_NAMELENGTH], service[MAX_NAMELENGTH],\n        local[MAX_NAMELENGTH], target[MAX_NAMELENGTH];\n};\n\ntypedef enum {\n    NON_BLOCKING = 0,\n    BLOCKING = 1\n} connect_blocking;\n\n\n/* common.c */\nvoid init_cnx(struct connection *cnx);\nint set_nonblock(int fd);\nint connect_addr(struct connection *cnx, int fd_from, connect_blocking blocking);\nint fd2fd(struct queue *target, struct queue *from);\nchar* sprintaddr(char* buf, size_t size, struct addrinfo *a);\nvoid resolve_name(struct addrinfo **out, char* fullname);\nint get_connection_desc(struct connection_desc* desc, const struct connection *cnx);\nvoid log_connection(struct connection_desc* desc, const struct connection *cnx);\nvoid set_proctitle_shovel(struct connection_desc* desc, const struct connection *cnx);\nint check_access_rights(int in_socket, const char* service);\nvoid setup_signals(void);\nvoid setup_syslog(const char* bin_name);\nvoid drop_privileges(const char* user_name, const char* chroot_path);\nvoid set_capabilities(int cap_net_admin);\nvoid write_pid_file(const char* pidfile);\nvoid dump_connection(struct connection *cnx);\nint resolve_split_name(struct addrinfo **out, char* hostname, char* port);\n\nint start_listen_sockets(struct listen_endpoint *sockfd[]);\n\nint defer_write(struct queue *q, void* data, ssize_t data_size);\nint flush_deferred(struct queue *q);\n\nextern struct sslhcfg_item cfg;\nextern struct addrinfo *addr_listen;\nextern const char* server_type;\n\n/* sslh-fork.c */\nvoid start_shoveler(int);\n\nvoid main_loop(struct listen_endpoint *listen_sockets, int num_addr_listen);\n\n/* landlock.c */\nvoid setup_landlock(void);\n\n\n#endif\n"
        },
        {
          "name": "config.h.in",
          "type": "blob",
          "size": 0.1337890625,
          "content": "\n\n#ifndef CONFIG_H\n/* Template for config.h, filled by `configure`. */\n\n/* Landlock sandboxing Linux LSM */\n#undef HAVE_LANDLOCK\n\n#endif\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 125.234375,
          "content": "#! /bin/sh\n# Guess values for system-dependent variables and create Makefiles.\n# Generated by GNU Autoconf 2.71.\n#\n#\n# Copyright (C) 1992-1996, 1998-2017, 2020-2021 Free Software Foundation,\n# Inc.\n#\n#\n# This configure script is free software; the Free Software Foundation\n# gives unlimited permission to copy, distribute and modify it.\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nas_nop=:\nif test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse $as_nop\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\n\n# Reset variables that may have inherited troublesome values from\n# the environment.\n\n# IFS needs to be set, to space, tab, and newline, in precisely that order.\n# (If _AS_PATH_WALK were called with IFS unset, it would have the\n# side effect of setting IFS to empty, thus disabling word splitting.)\n# Quoting is to prevent editors from complaining about space-tab.\nas_nl='\n'\nexport as_nl\nIFS=\" \"\"\t$as_nl\"\n\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# Ensure predictable behavior from utilities with locale-dependent output.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# We cannot yet rely on \"unset\" to work, but we need these variables\n# to be unset--not just set to an empty or harmless value--now, to\n# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct\n# also avoids known problems related to \"unset\" and subshell syntax\n# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).\nfor as_var in BASH_ENV ENV MAIL MAILPATH CDPATH\ndo eval test \\${$as_var+y} \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\n\n# Ensure that fds 0, 1, and 2 are open.\nif (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi\nif (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi\nif (exec 3>&2)            ; then :; else exec 2>/dev/null; fi\n\n# The user is always right.\nif ${PATH_SEPARATOR+false} :; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    test -r \"$as_dir$0\" && as_myself=$as_dir$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  printf \"%s\\n\" \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n\n# Use a proper internal environment variable to ensure we don't fall\n  # into an infinite loop, continuously re-executing ourselves.\n  if test x\"${_as_can_reexec}\" != xno && test \"x$CONFIG_SHELL\" != x; then\n    _as_can_reexec=no; export _as_can_reexec;\n    # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\nprintf \"%s\\n\" \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\n  fi\n  # We don't want this to propagate to other subprocesses.\n          { _as_can_reexec=; unset _as_can_reexec;}\nif test \"x$CONFIG_SHELL\" = x; then\n  as_bourne_compatible=\"as_nop=:\nif test \\${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse \\$as_nop\n  case \\`(set -o) 2>/dev/null\\` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\"\n  as_required=\"as_fn_return () { (exit \\$1); }\nas_fn_success () { as_fn_return 0; }\nas_fn_failure () { as_fn_return 1; }\nas_fn_ret_success () { return 0; }\nas_fn_ret_failure () { return 1; }\n\nexitcode=0\nas_fn_success || { exitcode=1; echo as_fn_success failed.; }\nas_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }\nas_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }\nas_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }\nif ( set x; as_fn_ret_success y && test x = \\\"\\$1\\\" )\nthen :\n\nelse \\$as_nop\n  exitcode=1; echo positional parameters were not saved.\nfi\ntest x\\$exitcode = x0 || exit 1\nblah=\\$(echo \\$(echo blah))\ntest x\\\"\\$blah\\\" = xblah || exit 1\ntest -x / || exit 1\"\n  as_suggested=\"  as_lineno_1=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_1a=\\$LINENO\n  as_lineno_2=\";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested\" as_lineno_2a=\\$LINENO\n  eval 'test \\\"x\\$as_lineno_1'\\$as_run'\\\" != \\\"x\\$as_lineno_2'\\$as_run'\\\" &&\n  test \\\"x\\`expr \\$as_lineno_1'\\$as_run' + 1\\`\\\" = \\\"x\\$as_lineno_2'\\$as_run'\\\"' || exit 1\"\n  if (eval \"$as_required\") 2>/dev/null\nthen :\n  as_have_required=yes\nelse $as_nop\n  as_have_required=no\nfi\n  if test x$as_have_required = xyes && (eval \"$as_suggested\") 2>/dev/null\nthen :\n\nelse $as_nop\n  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nas_found=false\nfor as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n  as_found=:\n  case $as_dir in #(\n\t /*)\n\t   for as_base in sh bash ksh sh5; do\n\t     # Try only shells that exist, to save several forks.\n\t     as_shell=$as_dir$as_base\n\t     if { test -f \"$as_shell\" || test -f \"$as_shell.exe\"; } &&\n\t\t    as_run=a \"$as_shell\" -c \"$as_bourne_compatible\"\"$as_required\" 2>/dev/null\nthen :\n  CONFIG_SHELL=$as_shell as_have_required=yes\n\t\t   if as_run=a \"$as_shell\" -c \"$as_bourne_compatible\"\"$as_suggested\" 2>/dev/null\nthen :\n  break 2\nfi\nfi\n\t   done;;\n       esac\n  as_found=false\ndone\nIFS=$as_save_IFS\nif $as_found\nthen :\n\nelse $as_nop\n  if { test -f \"$SHELL\" || test -f \"$SHELL.exe\"; } &&\n\t      as_run=a \"$SHELL\" -c \"$as_bourne_compatible\"\"$as_required\" 2>/dev/null\nthen :\n  CONFIG_SHELL=$SHELL as_have_required=yes\nfi\nfi\n\n\n      if test \"x$CONFIG_SHELL\" != x\nthen :\n  export CONFIG_SHELL\n             # We cannot yet assume a decent shell, so we have to provide a\n# neutralization value for shells without unset; and this also\n# works around shells that cannot unset nonexistent variables.\n# Preserve -v and -x to the replacement shell.\nBASH_ENV=/dev/null\nENV=/dev/null\n(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV\ncase $- in # ((((\n  *v*x* | *x*v* ) as_opts=-vx ;;\n  *v* ) as_opts=-v ;;\n  *x* ) as_opts=-x ;;\n  * ) as_opts= ;;\nesac\nexec $CONFIG_SHELL $as_opts \"$as_myself\" ${1+\"$@\"}\n# Admittedly, this is quite paranoid, since all the known shells bail\n# out after a failed `exec'.\nprintf \"%s\\n\" \"$0: could not re-execute with $CONFIG_SHELL\" >&2\nexit 255\nfi\n\n    if test x$as_have_required = xno\nthen :\n  printf \"%s\\n\" \"$0: This script requires a shell more modern than all\"\n  printf \"%s\\n\" \"$0: the shells that I found on your system.\"\n  if test ${ZSH_VERSION+y} ; then\n    printf \"%s\\n\" \"$0: In particular, zsh $ZSH_VERSION has bugs and should\"\n    printf \"%s\\n\" \"$0: be upgraded to zsh 4.3.4 or later.\"\n  else\n    printf \"%s\\n\" \"$0: Please tell bug-autoconf@gnu.org about your system,\n$0: including any error possibly output before this\n$0: message. Then install a modern shell, or manually run\n$0: the script under such a shell if you do have one.\"\n  fi\n  exit 1\nfi\nfi\nfi\nSHELL=${CONFIG_SHELL-/bin/sh}\nexport SHELL\n# Unset more variables known to interfere with behavior of common tools.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n## --------------------- ##\n## M4sh Shell Functions. ##\n## --------------------- ##\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n# as_fn_nop\n# ---------\n# Do nothing but, unlike \":\", preserve the value of $?.\nas_fn_nop ()\n{\n  return $?\n}\nas_nop=as_fn_nop\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`printf \"%s\\n\" \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null\nthen :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse $as_nop\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null\nthen :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse $as_nop\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n# as_fn_nop\n# ---------\n# Do nothing but, unlike \":\", preserve the value of $?.\nas_fn_nop ()\n{\n  return $?\n}\nas_nop=as_fn_nop\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  printf \"%s\\n\" \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n  as_lineno_1=$LINENO as_lineno_1a=$LINENO\n  as_lineno_2=$LINENO as_lineno_2a=$LINENO\n  eval 'test \"x$as_lineno_1'$as_run'\" != \"x$as_lineno_2'$as_run'\" &&\n  test \"x`expr $as_lineno_1'$as_run' + 1`\" = \"x$as_lineno_2'$as_run'\"' || {\n  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)\n  sed -n '\n    p\n    /[$]LINENO/=\n  ' <$as_myself |\n    sed '\n      s/[$]LINENO.*/&-/\n      t lineno\n      b\n      :lineno\n      N\n      :loop\n      s/[$]LINENO\\([^'$as_cr_alnum'_].*\\n\\)\\(.*\\)/\\2\\1\\2/\n      t loop\n      s/-\\n.*//\n    ' >$as_me.lineno &&\n  chmod +x \"$as_me.lineno\" ||\n    { printf \"%s\\n\" \"$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell\" >&2; as_fn_exit 1; }\n\n  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have\n  # already done that, so ensure we don't try to do so again and fall\n  # in an infinite loop.  This has already happened in practice.\n  _as_can_reexec=no; export _as_can_reexec\n  # Don't try to exec as it changes $[0], causing all sort of problems\n  # (the dirname of $[0] is not the place where we might find the\n  # original and so on.  Autoconf is especially sensitive to this).\n  . \"./$as_me.lineno\"\n  # Exit status is that of the last command.\n  exit\n}\n\n\n# Determine whether it's possible to make 'echo' print without a newline.\n# These variables are no longer used directly by Autoconf, but are AC_SUBSTed\n# for compatibility with existing Makefiles.\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\n# For backward compatibility with old third-party macros, we provide\n# the shell variables $as_echo and $as_echo_n.  New code should use\n# AS_ECHO([\"message\"]) and AS_ECHO_N([\"message\"]), respectively.\nas_echo='printf %s\\n'\nas_echo_n='printf %s'\n\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\ntest -n \"$DJDIR\" || exec 7<&0 </dev/null\nexec 6>&1\n\n# Name of the host.\n# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,\n# so uname gets run too.\nac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`\n\n#\n# Initializations.\n#\nac_default_prefix=/usr/local\nac_clean_files=\nac_config_libobj_dir=.\nLIBOBJS=\ncross_compiling=no\nsubdirs=\nMFLAGS=\nMAKEFLAGS=\n\n# Identity of this package.\nPACKAGE_NAME=''\nPACKAGE_TARNAME=''\nPACKAGE_VERSION=''\nPACKAGE_STRING=''\nPACKAGE_BUGREPORT=''\nPACKAGE_URL=''\n\n# Factoring default headers for most tests.\nac_includes_default=\"\\\n#include <stddef.h>\n#ifdef HAVE_STDIO_H\n# include <stdio.h>\n#endif\n#ifdef HAVE_STDLIB_H\n# include <stdlib.h>\n#endif\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n# include <inttypes.h>\n#endif\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#ifdef HAVE_STRINGS_H\n# include <strings.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\"\n\nac_header_c_list=\nac_subst_vars='LTLIBOBJS\nLIBOBJS\nOBJEXT\nEXEEXT\nac_ct_CC\nCPPFLAGS\nLDFLAGS\nCFLAGS\nCC\ntarget_alias\nhost_alias\nbuild_alias\nLIBS\nECHO_T\nECHO_N\nECHO_C\nDEFS\nmandir\nlocaledir\nlibdir\npsdir\npdfdir\ndvidir\nhtmldir\ninfodir\ndocdir\noldincludedir\nincludedir\nrunstatedir\nlocalstatedir\nsharedstatedir\nsysconfdir\ndatadir\ndatarootdir\nlibexecdir\nsbindir\nbindir\nprogram_transform_name\nprefix\nexec_prefix\nPACKAGE_URL\nPACKAGE_BUGREPORT\nPACKAGE_STRING\nPACKAGE_VERSION\nPACKAGE_TARNAME\nPACKAGE_NAME\nPATH_SEPARATOR\nSHELL'\nac_subst_files=''\nac_user_opts='\nenable_option_checking\n'\n      ac_precious_vars='build_alias\nhost_alias\ntarget_alias\nCC\nCFLAGS\nLDFLAGS\nLIBS\nCPPFLAGS'\n\n\n# Initialize some variables set by options.\nac_init_help=\nac_init_version=false\nac_unrecognized_opts=\nac_unrecognized_sep=\n# The variables have the same names as the options, with\n# dashes changed to underlines.\ncache_file=/dev/null\nexec_prefix=NONE\nno_create=\nno_recursion=\nprefix=NONE\nprogram_prefix=NONE\nprogram_suffix=NONE\nprogram_transform_name=s,x,x,\nsilent=\nsite=\nsrcdir=\nverbose=\nx_includes=NONE\nx_libraries=NONE\n\n# Installation directory options.\n# These are left unexpanded so users can \"make install exec_prefix=/foo\"\n# and all the variables that are supposed to be based on exec_prefix\n# by default will actually change.\n# Use braces instead of parens because sh, perl, etc. also accept them.\n# (The list follows the same order as the GNU Coding Standards.)\nbindir='${exec_prefix}/bin'\nsbindir='${exec_prefix}/sbin'\nlibexecdir='${exec_prefix}/libexec'\ndatarootdir='${prefix}/share'\ndatadir='${datarootdir}'\nsysconfdir='${prefix}/etc'\nsharedstatedir='${prefix}/com'\nlocalstatedir='${prefix}/var'\nrunstatedir='${localstatedir}/run'\nincludedir='${prefix}/include'\noldincludedir='/usr/include'\ndocdir='${datarootdir}/doc/${PACKAGE}'\ninfodir='${datarootdir}/info'\nhtmldir='${docdir}'\ndvidir='${docdir}'\npdfdir='${docdir}'\npsdir='${docdir}'\nlibdir='${exec_prefix}/lib'\nlocaledir='${datarootdir}/locale'\nmandir='${datarootdir}/man'\n\nac_prev=\nac_dashdash=\nfor ac_option\ndo\n  # If the previous option needs an argument, assign it.\n  if test -n \"$ac_prev\"; then\n    eval $ac_prev=\\$ac_option\n    ac_prev=\n    continue\n  fi\n\n  case $ac_option in\n  *=?*) ac_optarg=`expr \"X$ac_option\" : '[^=]*=\\(.*\\)'` ;;\n  *=)   ac_optarg= ;;\n  *)    ac_optarg=yes ;;\n  esac\n\n  case $ac_dashdash$ac_option in\n  --)\n    ac_dashdash=yes ;;\n\n  -bindir | --bindir | --bindi | --bind | --bin | --bi)\n    ac_prev=bindir ;;\n  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)\n    bindir=$ac_optarg ;;\n\n  -build | --build | --buil | --bui | --bu)\n    ac_prev=build_alias ;;\n  -build=* | --build=* | --buil=* | --bui=* | --bu=*)\n    build_alias=$ac_optarg ;;\n\n  -cache-file | --cache-file | --cache-fil | --cache-fi \\\n  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)\n    ac_prev=cache_file ;;\n  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \\\n  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)\n    cache_file=$ac_optarg ;;\n\n  --config-cache | -C)\n    cache_file=config.cache ;;\n\n  -datadir | --datadir | --datadi | --datad)\n    ac_prev=datadir ;;\n  -datadir=* | --datadir=* | --datadi=* | --datad=*)\n    datadir=$ac_optarg ;;\n\n  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \\\n  | --dataroo | --dataro | --datar)\n    ac_prev=datarootdir ;;\n  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \\\n  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)\n    datarootdir=$ac_optarg ;;\n\n  -disable-* | --disable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*disable-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=no ;;\n\n  -docdir | --docdir | --docdi | --doc | --do)\n    ac_prev=docdir ;;\n  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)\n    docdir=$ac_optarg ;;\n\n  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)\n    ac_prev=dvidir ;;\n  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)\n    dvidir=$ac_optarg ;;\n\n  -enable-* | --enable-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*enable-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid feature name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"enable_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval enable_$ac_useropt=\\$ac_optarg ;;\n\n  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \\\n  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \\\n  | --exec | --exe | --ex)\n    ac_prev=exec_prefix ;;\n  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \\\n  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \\\n  | --exec=* | --exe=* | --ex=*)\n    exec_prefix=$ac_optarg ;;\n\n  -gas | --gas | --ga | --g)\n    # Obsolete; use --with-gas.\n    with_gas=yes ;;\n\n  -help | --help | --hel | --he | -h)\n    ac_init_help=long ;;\n  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)\n    ac_init_help=recursive ;;\n  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)\n    ac_init_help=short ;;\n\n  -host | --host | --hos | --ho)\n    ac_prev=host_alias ;;\n  -host=* | --host=* | --hos=* | --ho=*)\n    host_alias=$ac_optarg ;;\n\n  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)\n    ac_prev=htmldir ;;\n  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \\\n  | --ht=*)\n    htmldir=$ac_optarg ;;\n\n  -includedir | --includedir | --includedi | --included | --include \\\n  | --includ | --inclu | --incl | --inc)\n    ac_prev=includedir ;;\n  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \\\n  | --includ=* | --inclu=* | --incl=* | --inc=*)\n    includedir=$ac_optarg ;;\n\n  -infodir | --infodir | --infodi | --infod | --info | --inf)\n    ac_prev=infodir ;;\n  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)\n    infodir=$ac_optarg ;;\n\n  -libdir | --libdir | --libdi | --libd)\n    ac_prev=libdir ;;\n  -libdir=* | --libdir=* | --libdi=* | --libd=*)\n    libdir=$ac_optarg ;;\n\n  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \\\n  | --libexe | --libex | --libe)\n    ac_prev=libexecdir ;;\n  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \\\n  | --libexe=* | --libex=* | --libe=*)\n    libexecdir=$ac_optarg ;;\n\n  -localedir | --localedir | --localedi | --localed | --locale)\n    ac_prev=localedir ;;\n  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)\n    localedir=$ac_optarg ;;\n\n  -localstatedir | --localstatedir | --localstatedi | --localstated \\\n  | --localstate | --localstat | --localsta | --localst | --locals)\n    ac_prev=localstatedir ;;\n  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \\\n  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)\n    localstatedir=$ac_optarg ;;\n\n  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)\n    ac_prev=mandir ;;\n  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)\n    mandir=$ac_optarg ;;\n\n  -nfp | --nfp | --nf)\n    # Obsolete; use --without-fp.\n    with_fp=no ;;\n\n  -no-create | --no-create | --no-creat | --no-crea | --no-cre \\\n  | --no-cr | --no-c | -n)\n    no_create=yes ;;\n\n  -no-recursion | --no-recursion | --no-recursio | --no-recursi \\\n  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)\n    no_recursion=yes ;;\n\n  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \\\n  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \\\n  | --oldin | --oldi | --old | --ol | --o)\n    ac_prev=oldincludedir ;;\n  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \\\n  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \\\n  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)\n    oldincludedir=$ac_optarg ;;\n\n  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)\n    ac_prev=prefix ;;\n  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)\n    prefix=$ac_optarg ;;\n\n  -program-prefix | --program-prefix | --program-prefi | --program-pref \\\n  | --program-pre | --program-pr | --program-p)\n    ac_prev=program_prefix ;;\n  -program-prefix=* | --program-prefix=* | --program-prefi=* \\\n  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)\n    program_prefix=$ac_optarg ;;\n\n  -program-suffix | --program-suffix | --program-suffi | --program-suff \\\n  | --program-suf | --program-su | --program-s)\n    ac_prev=program_suffix ;;\n  -program-suffix=* | --program-suffix=* | --program-suffi=* \\\n  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)\n    program_suffix=$ac_optarg ;;\n\n  -program-transform-name | --program-transform-name \\\n  | --program-transform-nam | --program-transform-na \\\n  | --program-transform-n | --program-transform- \\\n  | --program-transform | --program-transfor \\\n  | --program-transfo | --program-transf \\\n  | --program-trans | --program-tran \\\n  | --progr-tra | --program-tr | --program-t)\n    ac_prev=program_transform_name ;;\n  -program-transform-name=* | --program-transform-name=* \\\n  | --program-transform-nam=* | --program-transform-na=* \\\n  | --program-transform-n=* | --program-transform-=* \\\n  | --program-transform=* | --program-transfor=* \\\n  | --program-transfo=* | --program-transf=* \\\n  | --program-trans=* | --program-tran=* \\\n  | --progr-tra=* | --program-tr=* | --program-t=*)\n    program_transform_name=$ac_optarg ;;\n\n  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)\n    ac_prev=pdfdir ;;\n  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)\n    pdfdir=$ac_optarg ;;\n\n  -psdir | --psdir | --psdi | --psd | --ps)\n    ac_prev=psdir ;;\n  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)\n    psdir=$ac_optarg ;;\n\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil)\n    silent=yes ;;\n\n  -runstatedir | --runstatedir | --runstatedi | --runstated \\\n  | --runstate | --runstat | --runsta | --runst | --runs \\\n  | --run | --ru | --r)\n    ac_prev=runstatedir ;;\n  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \\\n  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \\\n  | --run=* | --ru=* | --r=*)\n    runstatedir=$ac_optarg ;;\n\n  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)\n    ac_prev=sbindir ;;\n  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \\\n  | --sbi=* | --sb=*)\n    sbindir=$ac_optarg ;;\n\n  -sharedstatedir | --sharedstatedir | --sharedstatedi \\\n  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \\\n  | --sharedst | --shareds | --shared | --share | --shar \\\n  | --sha | --sh)\n    ac_prev=sharedstatedir ;;\n  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \\\n  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \\\n  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \\\n  | --sha=* | --sh=*)\n    sharedstatedir=$ac_optarg ;;\n\n  -site | --site | --sit)\n    ac_prev=site ;;\n  -site=* | --site=* | --sit=*)\n    site=$ac_optarg ;;\n\n  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n    ac_prev=srcdir ;;\n  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n    srcdir=$ac_optarg ;;\n\n  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \\\n  | --syscon | --sysco | --sysc | --sys | --sy)\n    ac_prev=sysconfdir ;;\n  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \\\n  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)\n    sysconfdir=$ac_optarg ;;\n\n  -target | --target | --targe | --targ | --tar | --ta | --t)\n    ac_prev=target_alias ;;\n  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)\n    target_alias=$ac_optarg ;;\n\n  -v | -verbose | --verbose | --verbos | --verbo | --verb)\n    verbose=yes ;;\n\n  -version | --version | --versio | --versi | --vers | -V)\n    ac_init_version=: ;;\n\n  -with-* | --with-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*with-\\([^=]*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=\\$ac_optarg ;;\n\n  -without-* | --without-*)\n    ac_useropt=`expr \"x$ac_option\" : 'x-*without-\\(.*\\)'`\n    # Reject names that are not valid shell variable names.\n    expr \"x$ac_useropt\" : \".*[^-+._$as_cr_alnum]\" >/dev/null &&\n      as_fn_error $? \"invalid package name: \\`$ac_useropt'\"\n    ac_useropt_orig=$ac_useropt\n    ac_useropt=`printf \"%s\\n\" \"$ac_useropt\" | sed 's/[-+.]/_/g'`\n    case $ac_user_opts in\n      *\"\n\"with_$ac_useropt\"\n\"*) ;;\n      *) ac_unrecognized_opts=\"$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig\"\n\t ac_unrecognized_sep=', ';;\n    esac\n    eval with_$ac_useropt=no ;;\n\n  --x)\n    # Obsolete; use --with-x.\n    with_x=yes ;;\n\n  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \\\n  | --x-incl | --x-inc | --x-in | --x-i)\n    ac_prev=x_includes ;;\n  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \\\n  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)\n    x_includes=$ac_optarg ;;\n\n  -x-libraries | --x-libraries | --x-librarie | --x-librari \\\n  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)\n    ac_prev=x_libraries ;;\n  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \\\n  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)\n    x_libraries=$ac_optarg ;;\n\n  -*) as_fn_error $? \"unrecognized option: \\`$ac_option'\nTry \\`$0 --help' for more information\"\n    ;;\n\n  *=*)\n    ac_envvar=`expr \"x$ac_option\" : 'x\\([^=]*\\)='`\n    # Reject names that are not valid shell variable names.\n    case $ac_envvar in #(\n      '' | [0-9]* | *[!_$as_cr_alnum]* )\n      as_fn_error $? \"invalid variable name: \\`$ac_envvar'\" ;;\n    esac\n    eval $ac_envvar=\\$ac_optarg\n    export $ac_envvar ;;\n\n  *)\n    # FIXME: should be removed in autoconf 3.0.\n    printf \"%s\\n\" \"$as_me: WARNING: you should use --build, --host, --target\" >&2\n    expr \"x$ac_option\" : \".*[^-._$as_cr_alnum]\" >/dev/null &&\n      printf \"%s\\n\" \"$as_me: WARNING: invalid host type: $ac_option\" >&2\n    : \"${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}\"\n    ;;\n\n  esac\ndone\n\nif test -n \"$ac_prev\"; then\n  ac_option=--`echo $ac_prev | sed 's/_/-/g'`\n  as_fn_error $? \"missing argument to $ac_option\"\nfi\n\nif test -n \"$ac_unrecognized_opts\"; then\n  case $enable_option_checking in\n    no) ;;\n    fatal) as_fn_error $? \"unrecognized options: $ac_unrecognized_opts\" ;;\n    *)     printf \"%s\\n\" \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2 ;;\n  esac\nfi\n\n# Check all directory arguments for consistency.\nfor ac_var in\texec_prefix prefix bindir sbindir libexecdir datarootdir \\\n\t\tdatadir sysconfdir sharedstatedir localstatedir includedir \\\n\t\toldincludedir docdir infodir htmldir dvidir pdfdir psdir \\\n\t\tlibdir localedir mandir runstatedir\ndo\n  eval ac_val=\\$$ac_var\n  # Remove trailing slashes.\n  case $ac_val in\n    */ )\n      ac_val=`expr \"X$ac_val\" : 'X\\(.*[^/]\\)' \\| \"X$ac_val\" : 'X\\(.*\\)'`\n      eval $ac_var=\\$ac_val;;\n  esac\n  # Be sure to have absolute directory names.\n  case $ac_val in\n    [\\\\/$]* | ?:[\\\\/]* )  continue;;\n    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;\n  esac\n  as_fn_error $? \"expected an absolute directory name for --$ac_var: $ac_val\"\ndone\n\n# There might be people who depend on the old broken behavior: `$host'\n# used to hold the argument of --host etc.\n# FIXME: To remove some day.\nbuild=$build_alias\nhost=$host_alias\ntarget=$target_alias\n\n# FIXME: To remove some day.\nif test \"x$host_alias\" != x; then\n  if test \"x$build_alias\" = x; then\n    cross_compiling=maybe\n  elif test \"x$build_alias\" != \"x$host_alias\"; then\n    cross_compiling=yes\n  fi\nfi\n\nac_tool_prefix=\ntest -n \"$host_alias\" && ac_tool_prefix=$host_alias-\n\ntest \"$silent\" = yes && exec 6>/dev/null\n\n\nac_pwd=`pwd` && test -n \"$ac_pwd\" &&\nac_ls_di=`ls -di .` &&\nac_pwd_ls_di=`cd \"$ac_pwd\" && ls -di .` ||\n  as_fn_error $? \"working directory cannot be determined\"\ntest \"X$ac_ls_di\" = \"X$ac_pwd_ls_di\" ||\n  as_fn_error $? \"pwd does not report name of working directory\"\n\n\n# Find the source files, if location was not specified.\nif test -z \"$srcdir\"; then\n  ac_srcdir_defaulted=yes\n  # Try the directory containing this script, then the parent directory.\n  ac_confdir=`$as_dirname -- \"$as_myself\" ||\n$as_expr X\"$as_myself\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_myself\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_myself\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_myself\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  srcdir=$ac_confdir\n  if test ! -r \"$srcdir/$ac_unique_file\"; then\n    srcdir=..\n  fi\nelse\n  ac_srcdir_defaulted=no\nfi\nif test ! -r \"$srcdir/$ac_unique_file\"; then\n  test \"$ac_srcdir_defaulted\" = yes && srcdir=\"$ac_confdir or ..\"\n  as_fn_error $? \"cannot find sources ($ac_unique_file) in $srcdir\"\nfi\nac_msg=\"sources are in $srcdir, but \\`cd $srcdir' does not work\"\nac_abs_confdir=`(\n\tcd \"$srcdir\" && test -r \"./$ac_unique_file\" || as_fn_error $? \"$ac_msg\"\n\tpwd)`\n# When building in place, set srcdir=.\nif test \"$ac_abs_confdir\" = \"$ac_pwd\"; then\n  srcdir=.\nfi\n# Remove unnecessary trailing slashes from srcdir.\n# Double slashes in file names in object file debugging info\n# mess up M-x gdb in Emacs.\ncase $srcdir in\n*/) srcdir=`expr \"X$srcdir\" : 'X\\(.*[^/]\\)' \\| \"X$srcdir\" : 'X\\(.*\\)'`;;\nesac\nfor ac_var in $ac_precious_vars; do\n  eval ac_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_env_${ac_var}_value=\\$${ac_var}\n  eval ac_cv_env_${ac_var}_set=\\${${ac_var}+set}\n  eval ac_cv_env_${ac_var}_value=\\$${ac_var}\ndone\n\n#\n# Report the --help message.\n#\nif test \"$ac_init_help\" = \"long\"; then\n  # Omit some internal or obsolete options to make the list less imposing.\n  # This message is too long to be a string in the A/UX 3.1 sh.\n  cat <<_ACEOF\n\\`configure' configures this package to adapt to many kinds of systems.\n\nUsage: $0 [OPTION]... [VAR=VALUE]...\n\nTo assign environment variables (e.g., CC, CFLAGS...), specify them as\nVAR=VALUE.  See below for descriptions of some of the useful variables.\n\nDefaults for the options are specified in brackets.\n\nConfiguration:\n  -h, --help              display this help and exit\n      --help=short        display options specific to this package\n      --help=recursive    display the short help of all the included packages\n  -V, --version           display version information and exit\n  -q, --quiet, --silent   do not print \\`checking ...' messages\n      --cache-file=FILE   cache test results in FILE [disabled]\n  -C, --config-cache      alias for \\`--cache-file=config.cache'\n  -n, --no-create         do not create output files\n      --srcdir=DIR        find the sources in DIR [configure dir or \\`..']\n\nInstallation directories:\n  --prefix=PREFIX         install architecture-independent files in PREFIX\n                          [$ac_default_prefix]\n  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX\n                          [PREFIX]\n\nBy default, \\`make install' will install all the files in\n\\`$ac_default_prefix/bin', \\`$ac_default_prefix/lib' etc.  You can specify\nan installation prefix other than \\`$ac_default_prefix' using \\`--prefix',\nfor instance \\`--prefix=\\$HOME'.\n\nFor better control, use the options below.\n\nFine tuning of the installation directories:\n  --bindir=DIR            user executables [EPREFIX/bin]\n  --sbindir=DIR           system admin executables [EPREFIX/sbin]\n  --libexecdir=DIR        program executables [EPREFIX/libexec]\n  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]\n  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]\n  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]\n  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]\n  --libdir=DIR            object code libraries [EPREFIX/lib]\n  --includedir=DIR        C header files [PREFIX/include]\n  --oldincludedir=DIR     C header files for non-gcc [/usr/include]\n  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]\n  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]\n  --infodir=DIR           info documentation [DATAROOTDIR/info]\n  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]\n  --mandir=DIR            man documentation [DATAROOTDIR/man]\n  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]\n  --htmldir=DIR           html documentation [DOCDIR]\n  --dvidir=DIR            dvi documentation [DOCDIR]\n  --pdfdir=DIR            pdf documentation [DOCDIR]\n  --psdir=DIR             ps documentation [DOCDIR]\n_ACEOF\n\n  cat <<\\_ACEOF\n_ACEOF\nfi\n\nif test -n \"$ac_init_help\"; then\n\n  cat <<\\_ACEOF\n\nSome influential environment variables:\n  CC          C compiler command\n  CFLAGS      C compiler flags\n  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a\n              nonstandard directory <lib dir>\n  LIBS        libraries to pass to the linker, e.g. -l<library>\n  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if\n              you have headers in a nonstandard directory <include dir>\n\nUse these variables to override the choices made by `configure' or to help\nit to find libraries and programs with nonstandard names/locations.\n\nReport bugs to the package provider.\n_ACEOF\nac_status=$?\nfi\n\nif test \"$ac_init_help\" = \"recursive\"; then\n  # If there are subdirs, report their specific --help.\n  for ac_dir in : $ac_subdirs_all; do test \"x$ac_dir\" = x: && continue\n    test -d \"$ac_dir\" ||\n      { cd \"$srcdir\" && ac_pwd=`pwd` && srcdir=. && test -d \"$ac_dir\"; } ||\n      continue\n    ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`printf \"%s\\n\" \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`printf \"%s\\n\" \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n    cd \"$ac_dir\" || { ac_status=$?; continue; }\n    # Check for configure.gnu first; this name is used for a wrapper for\n    # Metaconfig's \"Configure\" on case-insensitive file systems.\n    if test -f \"$ac_srcdir/configure.gnu\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure.gnu\" --help=recursive\n    elif test -f \"$ac_srcdir/configure\"; then\n      echo &&\n      $SHELL \"$ac_srcdir/configure\" --help=recursive\n    else\n      printf \"%s\\n\" \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n    fi || ac_status=$?\n    cd \"$ac_pwd\" || { ac_status=$?; break; }\n  done\nfi\n\ntest -n \"$ac_init_help\" && exit $ac_status\nif $ac_init_version; then\n  cat <<\\_ACEOF\nconfigure\ngenerated by GNU Autoconf 2.71\n\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis configure script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\n_ACEOF\n  exit\nfi\n\n## ------------------------ ##\n## Autoconf initialization. ##\n## ------------------------ ##\n\n# ac_fn_c_try_compile LINENO\n# --------------------------\n# Try to compile conftest.$ac_ext, and return whether this succeeded.\nac_fn_c_try_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  rm -f conftest.$ac_objext conftest.beam\n  if { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    grep -v '^ *+' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n    mv -f conftest.er1 conftest.err\n  fi\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; } && {\n\t test -z \"$ac_c_werror_flag\" ||\n\t test ! -s conftest.err\n       } && test -s conftest.$ac_objext\nthen :\n  ac_retval=0\nelse $as_nop\n  printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n\tac_retval=1\nfi\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n  as_fn_set_status $ac_retval\n\n} # ac_fn_c_try_compile\n\n# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES\n# -------------------------------------------------------\n# Tests whether HEADER exists and can be compiled using the include files in\n# INCLUDES, setting the cache variable VAR accordingly.\nac_fn_c_check_header_compile ()\n{\n  as_lineno=${as_lineno-\"$1\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $2\" >&5\nprintf %s \"checking for $2... \" >&6; }\nif eval test \\${$3+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$4\n#include <$2>\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  eval \"$3=yes\"\nelse $as_nop\n  eval \"$3=no\"\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\neval ac_res=\\$$3\n\t       { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_res\" >&5\nprintf \"%s\\n\" \"$ac_res\" >&6; }\n  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno\n\n} # ac_fn_c_check_header_compile\nac_configure_args_raw=\nfor ac_arg\ndo\n  case $ac_arg in\n  *\\'*)\n    ac_arg=`printf \"%s\\n\" \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n  esac\n  as_fn_append ac_configure_args_raw \" '$ac_arg'\"\ndone\n\ncase $ac_configure_args_raw in\n  *$as_nl*)\n    ac_safe_unquote= ;;\n  *)\n    ac_unsafe_z='|&;<>()$`\\\\\"*?[ ''\t' # This string ends in space, tab.\n    ac_unsafe_a=\"$ac_unsafe_z#~\"\n    ac_safe_unquote=\"s/ '\\\\([^$ac_unsafe_a][^$ac_unsafe_z]*\\\\)'/ \\\\1/g\"\n    ac_configure_args_raw=`      printf \"%s\\n\" \"$ac_configure_args_raw\" | sed \"$ac_safe_unquote\"`;;\nesac\n\ncat >config.log <<_ACEOF\nThis file contains any messages produced by compilers while\nrunning configure, to aid debugging if configure makes a mistake.\n\nIt was created by $as_me, which was\ngenerated by GNU Autoconf 2.71.  Invocation command line was\n\n  $ $0$ac_configure_args_raw\n\n_ACEOF\nexec 5>>config.log\n{\ncat <<_ASUNAME\n## --------- ##\n## Platform. ##\n## --------- ##\n\nhostname = `(hostname || uname -n) 2>/dev/null | sed 1q`\nuname -m = `(uname -m) 2>/dev/null || echo unknown`\nuname -r = `(uname -r) 2>/dev/null || echo unknown`\nuname -s = `(uname -s) 2>/dev/null || echo unknown`\nuname -v = `(uname -v) 2>/dev/null || echo unknown`\n\n/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`\n/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`\n\n/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`\n/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`\n/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`\n/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`\n/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`\n/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`\n/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`\n\n_ASUNAME\n\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    printf \"%s\\n\" \"PATH: $as_dir\"\n  done\nIFS=$as_save_IFS\n\n} >&5\n\ncat >&5 <<_ACEOF\n\n\n## ----------- ##\n## Core tests. ##\n## ----------- ##\n\n_ACEOF\n\n\n# Keep a trace of the command line.\n# Strip out --no-create and --no-recursion so they do not pile up.\n# Strip out --silent because we don't want to record it for future runs.\n# Also quote any args containing shell meta-characters.\n# Make two passes to allow for proper duplicate-argument suppression.\nac_configure_args=\nac_configure_args0=\nac_configure_args1=\nac_must_keep_next=false\nfor ac_pass in 1 2\ndo\n  for ac_arg\n  do\n    case $ac_arg in\n    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;\n    -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n    | -silent | --silent | --silen | --sile | --sil)\n      continue ;;\n    *\\'*)\n      ac_arg=`printf \"%s\\n\" \"$ac_arg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    case $ac_pass in\n    1) as_fn_append ac_configure_args0 \" '$ac_arg'\" ;;\n    2)\n      as_fn_append ac_configure_args1 \" '$ac_arg'\"\n      if test $ac_must_keep_next = true; then\n\tac_must_keep_next=false # Got value, back to normal.\n      else\n\tcase $ac_arg in\n\t  *=* | --config-cache | -C | -disable-* | --disable-* \\\n\t  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \\\n\t  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \\\n\t  | -with-* | --with-* | -without-* | --without-* | --x)\n\t    case \"$ac_configure_args0 \" in\n\t      \"$ac_configure_args1\"*\" '$ac_arg' \"* ) continue ;;\n\t    esac\n\t    ;;\n\t  -* ) ac_must_keep_next=true ;;\n\tesac\n      fi\n      as_fn_append ac_configure_args \" '$ac_arg'\"\n      ;;\n    esac\n  done\ndone\n{ ac_configure_args0=; unset ac_configure_args0;}\n{ ac_configure_args1=; unset ac_configure_args1;}\n\n# When interrupted or exit'd, cleanup temporary files, and complete\n# config.log.  We remove comments because anyway the quotes in there\n# would cause problems or look ugly.\n# WARNING: Use '\\'' to represent an apostrophe within the trap.\n# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.\ntrap 'exit_status=$?\n  # Sanitize IFS.\n  IFS=\" \"\"\t$as_nl\"\n  # Save into config.log some information that might help in debugging.\n  {\n    echo\n\n    printf \"%s\\n\" \"## ---------------- ##\n## Cache variables. ##\n## ---------------- ##\"\n    echo\n    # The following way of writing the cache mishandles newlines in values,\n(\n  for ac_var in `(set) 2>&1 | sed -n '\\''s/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'\\''`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n  (set) 2>&1 |\n    case $as_nl`(ac_space='\\'' '\\''; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      sed -n \\\n\t\"s/'\\''/'\\''\\\\\\\\'\\'''\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\''\\\\2'\\''/p\"\n      ;; #(\n    *)\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n)\n    echo\n\n    printf \"%s\\n\" \"## ----------------- ##\n## Output variables. ##\n## ----------------- ##\"\n    echo\n    for ac_var in $ac_subst_vars\n    do\n      eval ac_val=\\$$ac_var\n      case $ac_val in\n      *\\'\\''*) ac_val=`printf \"%s\\n\" \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n      esac\n      printf \"%s\\n\" \"$ac_var='\\''$ac_val'\\''\"\n    done | sort\n    echo\n\n    if test -n \"$ac_subst_files\"; then\n      printf \"%s\\n\" \"## ------------------- ##\n## File substitutions. ##\n## ------------------- ##\"\n      echo\n      for ac_var in $ac_subst_files\n      do\n\teval ac_val=\\$$ac_var\n\tcase $ac_val in\n\t*\\'\\''*) ac_val=`printf \"%s\\n\" \"$ac_val\" | sed \"s/'\\''/'\\''\\\\\\\\\\\\\\\\'\\'''\\''/g\"`;;\n\tesac\n\tprintf \"%s\\n\" \"$ac_var='\\''$ac_val'\\''\"\n      done | sort\n      echo\n    fi\n\n    if test -s confdefs.h; then\n      printf \"%s\\n\" \"## ----------- ##\n## confdefs.h. ##\n## ----------- ##\"\n      echo\n      cat confdefs.h\n      echo\n    fi\n    test \"$ac_signal\" != 0 &&\n      printf \"%s\\n\" \"$as_me: caught signal $ac_signal\"\n    printf \"%s\\n\" \"$as_me: exit $exit_status\"\n  } >&5\n  rm -f core *.core core.conftest.* &&\n    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&\n    exit $exit_status\n' 0\nfor ac_signal in 1 2 13 15; do\n  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal\ndone\nac_signal=0\n\n# confdefs.h avoids OS command line length limits that DEFS can exceed.\nrm -f -r conftest* confdefs.h\n\nprintf \"%s\\n\" \"/* confdefs.h */\" > confdefs.h\n\n# Predefined preprocessor variables.\n\nprintf \"%s\\n\" \"#define PACKAGE_NAME \\\"$PACKAGE_NAME\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_TARNAME \\\"$PACKAGE_TARNAME\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_VERSION \\\"$PACKAGE_VERSION\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_STRING \\\"$PACKAGE_STRING\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_BUGREPORT \\\"$PACKAGE_BUGREPORT\\\"\" >>confdefs.h\n\nprintf \"%s\\n\" \"#define PACKAGE_URL \\\"$PACKAGE_URL\\\"\" >>confdefs.h\n\n\n# Let the site file select an alternate cache file if it wants to.\n# Prefer an explicitly selected file to automatically selected ones.\nif test -n \"$CONFIG_SITE\"; then\n  ac_site_files=\"$CONFIG_SITE\"\nelif test \"x$prefix\" != xNONE; then\n  ac_site_files=\"$prefix/share/config.site $prefix/etc/config.site\"\nelse\n  ac_site_files=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\nfi\n\nfor ac_site_file in $ac_site_files\ndo\n  case $ac_site_file in #(\n  */*) :\n     ;; #(\n  *) :\n    ac_site_file=./$ac_site_file ;;\nesac\n  if test -f \"$ac_site_file\" && test -r \"$ac_site_file\"; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file\" >&5\nprintf \"%s\\n\" \"$as_me: loading site script $ac_site_file\" >&6;}\n    sed 's/^/| /' \"$ac_site_file\" >&5\n    . \"$ac_site_file\" \\\n      || { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"failed to load site script $ac_site_file\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n  fi\ndone\n\nif test -r \"$cache_file\"; then\n  # Some versions of bash will fail to source /dev/null (special files\n  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.\n  if test /dev/null != \"$cache_file\" && test -f \"$cache_file\"; then\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: loading cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: loading cache $cache_file\" >&6;}\n    case $cache_file in\n      [\\\\/]* | ?:[\\\\/]* ) . \"$cache_file\";;\n      *)                      . \"./$cache_file\";;\n    esac\n  fi\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: creating cache $cache_file\" >&6;}\n  >$cache_file\nfi\n\n# Test code for whether the C compiler supports C89 (global declarations)\nac_c_conftest_c89_globals='\n/* Does the compiler advertise C89 conformance?\n   Do not test the value of __STDC__, because some compilers set it to 0\n   while being otherwise adequately conformant. */\n#if !defined __STDC__\n# error \"Compiler does not advertise C89 conformance\"\n#endif\n\n#include <stddef.h>\n#include <stdarg.h>\nstruct stat;\n/* Most of the following tests are stolen from RCS 5.7 src/conf.sh.  */\nstruct buf { int x; };\nstruct buf * (*rcsopen) (struct buf *, struct stat *, int);\nstatic char *e (p, i)\n     char **p;\n     int i;\n{\n  return p[i];\n}\nstatic char *f (char * (*g) (char **, int), char **p, ...)\n{\n  char *s;\n  va_list v;\n  va_start (v,p);\n  s = g (p, va_arg (v,int));\n  va_end (v);\n  return s;\n}\n\n/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has\n   function prototypes and stuff, but not \\xHH hex character constants.\n   These do not provoke an error unfortunately, instead are silently treated\n   as an \"x\".  The following induces an error, until -std is added to get\n   proper ANSI mode.  Curiously \\x00 != x always comes out true, for an\n   array size at least.  It is necessary to write \\x00 == 0 to get something\n   that is true only with -std.  */\nint osf4_cc_array ['\\''\\x00'\\'' == 0 ? 1 : -1];\n\n/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters\n   inside strings and character constants.  */\n#define FOO(x) '\\''x'\\''\nint xlc6_cc_array[FOO(a) == '\\''x'\\'' ? 1 : -1];\n\nint test (int i, double x);\nstruct s1 {int (*f) (int a);};\nstruct s2 {int (*f) (double a);};\nint pairnames (int, char **, int *(*)(struct buf *, struct stat *, int),\n               int, int);'\n\n# Test code for whether the C compiler supports C89 (body of main).\nac_c_conftest_c89_main='\nok |= (argc == 0 || f (e, argv, 0) != argv[0] || f (e, argv, 1) != argv[1]);\n'\n\n# Test code for whether the C compiler supports C99 (global declarations)\nac_c_conftest_c99_globals='\n// Does the compiler advertise C99 conformance?\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 199901L\n# error \"Compiler does not advertise C99 conformance\"\n#endif\n\n#include <stdbool.h>\nextern int puts (const char *);\nextern int printf (const char *, ...);\nextern int dprintf (int, const char *, ...);\nextern void *malloc (size_t);\n\n// Check varargs macros.  These examples are taken from C99 6.10.3.5.\n// dprintf is used instead of fprintf to avoid needing to declare\n// FILE and stderr.\n#define debug(...) dprintf (2, __VA_ARGS__)\n#define showlist(...) puts (#__VA_ARGS__)\n#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))\nstatic void\ntest_varargs_macros (void)\n{\n  int x = 1234;\n  int y = 5678;\n  debug (\"Flag\");\n  debug (\"X = %d\\n\", x);\n  showlist (The first, second, and third items.);\n  report (x>y, \"x is %d but y is %d\", x, y);\n}\n\n// Check long long types.\n#define BIG64 18446744073709551615ull\n#define BIG32 4294967295ul\n#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)\n#if !BIG_OK\n  #error \"your preprocessor is broken\"\n#endif\n#if BIG_OK\n#else\n  #error \"your preprocessor is broken\"\n#endif\nstatic long long int bignum = -9223372036854775807LL;\nstatic unsigned long long int ubignum = BIG64;\n\nstruct incomplete_array\n{\n  int datasize;\n  double data[];\n};\n\nstruct named_init {\n  int number;\n  const wchar_t *name;\n  double average;\n};\n\ntypedef const char *ccp;\n\nstatic inline int\ntest_restrict (ccp restrict text)\n{\n  // See if C++-style comments work.\n  // Iterate through items via the restricted pointer.\n  // Also check for declarations in for loops.\n  for (unsigned int i = 0; *(text+i) != '\\''\\0'\\''; ++i)\n    continue;\n  return 0;\n}\n\n// Check varargs and va_copy.\nstatic bool\ntest_varargs (const char *format, ...)\n{\n  va_list args;\n  va_start (args, format);\n  va_list args_copy;\n  va_copy (args_copy, args);\n\n  const char *str = \"\";\n  int number = 0;\n  float fnumber = 0;\n\n  while (*format)\n    {\n      switch (*format++)\n\t{\n\tcase '\\''s'\\'': // string\n\t  str = va_arg (args_copy, const char *);\n\t  break;\n\tcase '\\''d'\\'': // int\n\t  number = va_arg (args_copy, int);\n\t  break;\n\tcase '\\''f'\\'': // float\n\t  fnumber = va_arg (args_copy, double);\n\t  break;\n\tdefault:\n\t  break;\n\t}\n    }\n  va_end (args_copy);\n  va_end (args);\n\n  return *str && number && fnumber;\n}\n'\n\n# Test code for whether the C compiler supports C99 (body of main).\nac_c_conftest_c99_main='\n  // Check bool.\n  _Bool success = false;\n  success |= (argc != 0);\n\n  // Check restrict.\n  if (test_restrict (\"String literal\") == 0)\n    success = true;\n  char *restrict newvar = \"Another string\";\n\n  // Check varargs.\n  success &= test_varargs (\"s, d'\\'' f .\", \"string\", 65, 34.234);\n  test_varargs_macros ();\n\n  // Check flexible array members.\n  struct incomplete_array *ia =\n    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));\n  ia->datasize = 10;\n  for (int i = 0; i < ia->datasize; ++i)\n    ia->data[i] = i * 1.234;\n\n  // Check named initializers.\n  struct named_init ni = {\n    .number = 34,\n    .name = L\"Test wide string\",\n    .average = 543.34343,\n  };\n\n  ni.number = 58;\n\n  int dynamic_array[ni.number];\n  dynamic_array[0] = argv[0][0];\n  dynamic_array[ni.number - 1] = 543;\n\n  // work around unused variable warnings\n  ok |= (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == '\\''x'\\''\n\t || dynamic_array[ni.number - 1] != 543);\n'\n\n# Test code for whether the C compiler supports C11 (global declarations)\nac_c_conftest_c11_globals='\n// Does the compiler advertise C11 conformance?\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 201112L\n# error \"Compiler does not advertise C11 conformance\"\n#endif\n\n// Check _Alignas.\nchar _Alignas (double) aligned_as_double;\nchar _Alignas (0) no_special_alignment;\nextern char aligned_as_int;\nchar _Alignas (0) _Alignas (int) aligned_as_int;\n\n// Check _Alignof.\nenum\n{\n  int_alignment = _Alignof (int),\n  int_array_alignment = _Alignof (int[100]),\n  char_alignment = _Alignof (char)\n};\n_Static_assert (0 < -_Alignof (int), \"_Alignof is signed\");\n\n// Check _Noreturn.\nint _Noreturn does_not_return (void) { for (;;) continue; }\n\n// Check _Static_assert.\nstruct test_static_assert\n{\n  int x;\n  _Static_assert (sizeof (int) <= sizeof (long int),\n                  \"_Static_assert does not work in struct\");\n  long int y;\n};\n\n// Check UTF-8 literals.\n#define u8 syntax error!\nchar const utf8_literal[] = u8\"happens to be ASCII\" \"another string\";\n\n// Check duplicate typedefs.\ntypedef long *long_ptr;\ntypedef long int *long_ptr;\ntypedef long_ptr long_ptr;\n\n// Anonymous structures and unions -- taken from C11 6.7.2.1 Example 1.\nstruct anonymous\n{\n  union {\n    struct { int i; int j; };\n    struct { int k; long int l; } w;\n  };\n  int m;\n} v1;\n'\n\n# Test code for whether the C compiler supports C11 (body of main).\nac_c_conftest_c11_main='\n  _Static_assert ((offsetof (struct anonymous, i)\n\t\t   == offsetof (struct anonymous, w.k)),\n\t\t  \"Anonymous union alignment botch\");\n  v1.i = 2;\n  v1.w.k = 5;\n  ok |= v1.i != 5;\n'\n\n# Test code for whether the C compiler supports C11 (complete).\nac_c_conftest_c11_program=\"${ac_c_conftest_c89_globals}\n${ac_c_conftest_c99_globals}\n${ac_c_conftest_c11_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  ${ac_c_conftest_c99_main}\n  ${ac_c_conftest_c11_main}\n  return ok;\n}\n\"\n\n# Test code for whether the C compiler supports C99 (complete).\nac_c_conftest_c99_program=\"${ac_c_conftest_c89_globals}\n${ac_c_conftest_c99_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  ${ac_c_conftest_c99_main}\n  return ok;\n}\n\"\n\n# Test code for whether the C compiler supports C89 (complete).\nac_c_conftest_c89_program=\"${ac_c_conftest_c89_globals}\n\nint\nmain (int argc, char **argv)\n{\n  int ok = 0;\n  ${ac_c_conftest_c89_main}\n  return ok;\n}\n\"\n\nas_fn_append ac_header_c_list \" stdio.h stdio_h HAVE_STDIO_H\"\nas_fn_append ac_header_c_list \" stdlib.h stdlib_h HAVE_STDLIB_H\"\nas_fn_append ac_header_c_list \" string.h string_h HAVE_STRING_H\"\nas_fn_append ac_header_c_list \" inttypes.h inttypes_h HAVE_INTTYPES_H\"\nas_fn_append ac_header_c_list \" stdint.h stdint_h HAVE_STDINT_H\"\nas_fn_append ac_header_c_list \" strings.h strings_h HAVE_STRINGS_H\"\nas_fn_append ac_header_c_list \" sys/stat.h sys_stat_h HAVE_SYS_STAT_H\"\nas_fn_append ac_header_c_list \" sys/types.h sys_types_h HAVE_SYS_TYPES_H\"\nas_fn_append ac_header_c_list \" unistd.h unistd_h HAVE_UNISTD_H\"\n# Check that the precious variables saved in the cache have kept the same\n# value.\nac_cache_corrupted=false\nfor ac_var in $ac_precious_vars; do\n  eval ac_old_set=\\$ac_cv_env_${ac_var}_set\n  eval ac_new_set=\\$ac_env_${ac_var}_set\n  eval ac_old_val=\\$ac_cv_env_${ac_var}_value\n  eval ac_new_val=\\$ac_env_${ac_var}_value\n  case $ac_old_set,$ac_new_set in\n    set,)\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&5\nprintf \"%s\\n\" \"$as_me: error: \\`$ac_var' was set to \\`$ac_old_val' in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,set)\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' was not set in the previous run\" >&5\nprintf \"%s\\n\" \"$as_me: error: \\`$ac_var' was not set in the previous run\" >&2;}\n      ac_cache_corrupted=: ;;\n    ,);;\n    *)\n      if test \"x$ac_old_val\" != \"x$ac_new_val\"; then\n\t# differences in whitespace do not lead to failure.\n\tac_old_val_w=`echo x $ac_old_val`\n\tac_new_val_w=`echo x $ac_new_val`\n\tif test \"$ac_old_val_w\" != \"$ac_new_val_w\"; then\n\t  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: \\`$ac_var' has changed since the previous run:\" >&5\nprintf \"%s\\n\" \"$as_me: error: \\`$ac_var' has changed since the previous run:\" >&2;}\n\t  ac_cache_corrupted=:\n\telse\n\t  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&5\nprintf \"%s\\n\" \"$as_me: warning: ignoring whitespace changes in \\`$ac_var' since the previous run:\" >&2;}\n\t  eval $ac_var=\\$ac_old_val\n\tfi\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   former value:  \\`$ac_old_val'\" >&5\nprintf \"%s\\n\" \"$as_me:   former value:  \\`$ac_old_val'\" >&2;}\n\t{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}:   current value: \\`$ac_new_val'\" >&5\nprintf \"%s\\n\" \"$as_me:   current value: \\`$ac_new_val'\" >&2;}\n      fi;;\n  esac\n  # Pass precious variables to config.status.\n  if test \"$ac_new_set\" = set; then\n    case $ac_new_val in\n    *\\'*) ac_arg=$ac_var=`printf \"%s\\n\" \"$ac_new_val\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    *) ac_arg=$ac_var=$ac_new_val ;;\n    esac\n    case \" $ac_configure_args \" in\n      *\" '$ac_arg' \"*) ;; # Avoid dups.  Use of quotes ensures accuracy.\n      *) as_fn_append ac_configure_args \" '$ac_arg'\" ;;\n    esac\n  fi\ndone\nif $ac_cache_corrupted; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build\" >&5\nprintf \"%s\\n\" \"$as_me: error: changes in the environment can compromise the build\" >&2;}\n  as_fn_error $? \"run \\`${MAKE-make} distclean' and/or \\`rm $cache_file'\n\t    and start over\" \"$LINENO\" 5\nfi\n## -------------------- ##\n## Main body of script. ##\n## -------------------- ##\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\nac_config_headers=\"$ac_config_headers config.h\"\n\nac_config_files=\"$ac_config_files Makefile\"\n\n\n\n\n\n\n\n\n\n\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\nif test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}gcc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"gcc\", so it can be a program name with args.\nset dummy gcc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"gcc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nif test -z \"$CC\"; then\n          if test -n \"$ac_tool_prefix\"; then\n    # Extract the first word of \"${ac_tool_prefix}cc\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  fi\nfi\nif test -z \"$CC\"; then\n  # Extract the first word of \"cc\", so it can be a program name with args.\nset dummy cc; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\n  ac_prog_rejected=no\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    if test \"$as_dir$ac_word$ac_exec_ext\" = \"/usr/ucb/cc\"; then\n       ac_prog_rejected=yes\n       continue\n     fi\n    ac_cv_prog_CC=\"cc\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nif test $ac_prog_rejected = yes; then\n  # We found a bogon in the path, so make sure we never use it.\n  set dummy $ac_cv_prog_CC\n  shift\n  if test $# != 0; then\n    # We chose a different compiler from the bogus one.\n    # However, it has the same basename, so the bogon will be chosen\n    # first if we set CC to just the basename; use the full file name.\n    shift\n    ac_cv_prog_CC=\"$as_dir$ac_word${1+' '}$@\"\n  fi\nfi\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  for ac_prog in cl.exe\n  do\n    # Extract the first word of \"$ac_tool_prefix$ac_prog\", so it can be a program name with args.\nset dummy $ac_tool_prefix$ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"$ac_tool_prefix$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n    test -n \"$CC\" && break\n  done\nfi\nif test -z \"$CC\"; then\n  ac_ct_CC=$CC\n  for ac_prog in cl.exe\ndo\n  # Extract the first word of \"$ac_prog\", so it can be a program name with args.\nset dummy $ac_prog; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"$ac_prog\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\n  test -n \"$ac_ct_CC\" && break\ndone\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nfi\n\nfi\nif test -z \"$CC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n  # Extract the first word of \"${ac_tool_prefix}clang\", so it can be a program name with args.\nset dummy ${ac_tool_prefix}clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$CC\"; then\n  ac_cv_prog_CC=\"$CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_CC=\"${ac_tool_prefix}clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nCC=$ac_cv_prog_CC\nif test -n \"$CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $CC\" >&5\nprintf \"%s\\n\" \"$CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n\nfi\nif test -z \"$ac_cv_prog_CC\"; then\n  ac_ct_CC=$CC\n  # Extract the first word of \"clang\", so it can be a program name with args.\nset dummy clang; ac_word=$2\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\nprintf %s \"checking for $ac_word... \" >&6; }\nif test ${ac_cv_prog_ac_ct_CC+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  if test -n \"$ac_ct_CC\"; then\n  ac_cv_prog_ac_ct_CC=\"$ac_ct_CC\" # Let the user override the test.\nelse\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    for ac_exec_ext in '' $ac_executable_extensions; do\n  if as_fn_executable_p \"$as_dir$ac_word$ac_exec_ext\"; then\n    ac_cv_prog_ac_ct_CC=\"clang\"\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: found $as_dir$ac_word$ac_exec_ext\" >&5\n    break 2\n  fi\ndone\n  done\nIFS=$as_save_IFS\n\nfi\nfi\nac_ct_CC=$ac_cv_prog_ac_ct_CC\nif test -n \"$ac_ct_CC\"; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC\" >&5\nprintf \"%s\\n\" \"$ac_ct_CC\" >&6; }\nelse\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nfi\n\n  if test \"x$ac_ct_CC\" = x; then\n    CC=\"\"\n  else\n    case $cross_compiling:$ac_tool_warned in\nyes:)\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: using cross tools not prefixed with host triplet\" >&2;}\nac_tool_warned=yes ;;\nesac\n    CC=$ac_ct_CC\n  fi\nelse\n  CC=\"$ac_cv_prog_CC\"\nfi\n\nfi\n\n\ntest -z \"$CC\" && { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"no acceptable C compiler found in \\$PATH\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n\n# Provide some information about the compiler.\nprintf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler version\" >&5\nset X $ac_compile\nac_compiler=$2\nfor ac_option in --version -v -V -qversion -version; do\n  { { ac_try=\"$ac_compiler $ac_option >&5\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compiler $ac_option >&5\") 2>conftest.err\n  ac_status=$?\n  if test -s conftest.err; then\n    sed '10a\\\n... rest of stderr output deleted ...\n         10q' conftest.err >conftest.er1\n    cat conftest.er1 >&5\n  fi\n  rm -f conftest.er1 conftest.err\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\ndone\n\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files a.out a.out.dSYM a.exe b.out\"\n# Try to create an executable without -o first, disregard a.out.\n# It will help us diagnose broken compilers, and finding out an intuition\n# of exeext.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the C compiler works\" >&5\nprintf %s \"checking whether the C compiler works... \" >&6; }\nac_link_default=`printf \"%s\\n\" \"$ac_link\" | sed 's/ -o *conftest[^ ]*//'`\n\n# The possible output files:\nac_files=\"a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*\"\n\nac_rmfiles=\nfor ac_file in $ac_files\ndo\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    * ) ac_rmfiles=\"$ac_rmfiles $ac_file\";;\n  esac\ndone\nrm -f $ac_rmfiles\n\nif { { ac_try=\"$ac_link_default\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link_default\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.\n# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'\n# in a Makefile.  We should not override ac_cv_exeext if it was cached,\n# so that the user can short-circuit this test for compilers unknown to\n# Autoconf.\nfor ac_file in $ac_files ''\ndo\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )\n\t;;\n    [ab].out )\n\t# We found the default executable, but exeext='' is most\n\t# certainly right.\n\tbreak;;\n    *.* )\n\tif test ${ac_cv_exeext+y} && test \"$ac_cv_exeext\" != no;\n\tthen :; else\n\t   ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\tfi\n\t# We set ac_cv_exeext here because the later test for it is not\n\t# safe: cross compilers may not add the suffix if given an `-o'\n\t# argument, so we may need to know it at that point already.\n\t# Even if this section looks crufty: it has the advantage of\n\t# actually working.\n\tbreak;;\n    * )\n\tbreak;;\n  esac\ndone\ntest \"$ac_cv_exeext\" = no && ac_cv_exeext=\n\nelse $as_nop\n  ac_file=''\nfi\nif test -z \"$ac_file\"\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\nprintf \"%s\\n\" \"no\" >&6; }\nprintf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error 77 \"C compiler cannot create executables\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\nprintf \"%s\\n\" \"yes\" >&6; }\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name\" >&5\nprintf %s \"checking for C compiler default output file name... \" >&6; }\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_file\" >&5\nprintf \"%s\\n\" \"$ac_file\" >&6; }\nac_exeext=$ac_cv_exeext\n\nrm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out\nac_clean_files=$ac_clean_files_save\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for suffix of executables\" >&5\nprintf %s \"checking for suffix of executables... \" >&6; }\nif { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  # If both `conftest.exe' and `conftest' are `present' (well, observable)\n# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will\n# work properly (i.e., refer to `conftest.exe'), while it won't with\n# `rm'.\nfor ac_file in conftest.exe conftest conftest.*; do\n  test -f \"$ac_file\" || continue\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;\n    *.* ) ac_cv_exeext=`expr \"$ac_file\" : '[^.]*\\(\\..*\\)'`\n\t  break;;\n    * ) break;;\n  esac\ndone\nelse $as_nop\n  { { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of executables: cannot compile and link\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\nrm -f conftest conftest$ac_cv_exeext\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext\" >&5\nprintf \"%s\\n\" \"$ac_cv_exeext\" >&6; }\n\nrm -f conftest.$ac_ext\nEXEEXT=$ac_cv_exeext\nac_exeext=$EXEEXT\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n#include <stdio.h>\nint\nmain (void)\n{\nFILE *f = fopen (\"conftest.out\", \"w\");\n return ferror (f) || fclose (f) != 0;\n\n  ;\n  return 0;\n}\n_ACEOF\nac_clean_files=\"$ac_clean_files conftest.out\"\n# Check that the compiler produces executables we can run.  If not, either\n# the compiler is broken, or we cross compile.\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling\" >&5\nprintf %s \"checking whether we are cross compiling... \" >&6; }\nif test \"$cross_compiling\" != yes; then\n  { { ac_try=\"$ac_link\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_link\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\n  if { ac_try='./conftest$ac_cv_exeext'\n  { { case \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_try\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }; }; then\n    cross_compiling=no\n  else\n    if test \"$cross_compiling\" = maybe; then\n\tcross_compiling=yes\n    else\n\t{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error 77 \"cannot run C compiled programs.\nIf you meant to cross compile, use \\`--host'.\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\n    fi\n  fi\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $cross_compiling\" >&5\nprintf \"%s\\n\" \"$cross_compiling\" >&6; }\n\nrm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out\nac_clean_files=$ac_clean_files_save\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for suffix of object files\" >&5\nprintf %s \"checking for suffix of object files... \" >&6; }\nif test ${ac_cv_objext+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nrm -f conftest.o conftest.obj\nif { { ac_try=\"$ac_compile\"\ncase \"(($ac_try\" in\n  *\\\"* | *\\`* | *\\\\*) ac_try_echo=\\$ac_try;;\n  *) ac_try_echo=$ac_try;;\nesac\neval ac_try_echo=\"\\\"\\$as_me:${as_lineno-$LINENO}: $ac_try_echo\\\"\"\nprintf \"%s\\n\" \"$ac_try_echo\"; } >&5\n  (eval \"$ac_compile\") 2>&5\n  ac_status=$?\n  printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n  test $ac_status = 0; }\nthen :\n  for ac_file in conftest.o conftest.obj conftest.*; do\n  test -f \"$ac_file\" || continue;\n  case $ac_file in\n    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;\n    *) ac_cv_objext=`expr \"$ac_file\" : '.*\\.\\(.*\\)'`\n       break;;\n  esac\ndone\nelse $as_nop\n  printf \"%s\\n\" \"$as_me: failed program was:\" >&5\nsed 's/^/| /' conftest.$ac_ext >&5\n\n{ { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: in \\`$ac_pwd':\" >&5\nprintf \"%s\\n\" \"$as_me: error: in \\`$ac_pwd':\" >&2;}\nas_fn_error $? \"cannot compute suffix of object files: cannot compile\nSee \\`config.log' for more details\" \"$LINENO\" 5; }\nfi\nrm -f conftest.$ac_cv_objext conftest.$ac_ext\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext\" >&5\nprintf \"%s\\n\" \"$ac_cv_objext\" >&6; }\nOBJEXT=$ac_cv_objext\nac_objext=$OBJEXT\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether the compiler supports GNU C\" >&5\nprintf %s \"checking whether the compiler supports GNU C... \" >&6; }\nif test ${ac_cv_c_compiler_gnu+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n#ifndef __GNUC__\n       choke me\n#endif\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_compiler_gnu=yes\nelse $as_nop\n  ac_compiler_gnu=no\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nac_cv_c_compiler_gnu=$ac_compiler_gnu\n\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu\" >&5\nprintf \"%s\\n\" \"$ac_cv_c_compiler_gnu\" >&6; }\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\nif test $ac_compiler_gnu = yes; then\n  GCC=yes\nelse\n  GCC=\nfi\nac_test_CFLAGS=${CFLAGS+y}\nac_save_CFLAGS=$CFLAGS\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g\" >&5\nprintf %s \"checking whether $CC accepts -g... \" >&6; }\nif test ${ac_cv_prog_cc_g+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_save_c_werror_flag=$ac_c_werror_flag\n   ac_c_werror_flag=yes\n   ac_cv_prog_cc_g=no\n   CFLAGS=\"-g\"\n   cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nelse $as_nop\n  CFLAGS=\"\"\n      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n\nelse $as_nop\n  ac_c_werror_flag=$ac_save_c_werror_flag\n\t CFLAGS=\"-g\"\n\t cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n\nint\nmain (void)\n{\n\n  ;\n  return 0;\n}\n_ACEOF\nif ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_g=yes\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam conftest.$ac_ext\n   ac_c_werror_flag=$ac_save_c_werror_flag\nfi\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_g\" >&6; }\nif test $ac_test_CFLAGS; then\n  CFLAGS=$ac_save_CFLAGS\nelif test $ac_cv_prog_cc_g = yes; then\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-g -O2\"\n  else\n    CFLAGS=\"-g\"\n  fi\nelse\n  if test \"$GCC\" = yes; then\n    CFLAGS=\"-O2\"\n  else\n    CFLAGS=\n  fi\nfi\nac_prog_cc_stdc=no\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C11 features\" >&5\nprintf %s \"checking for $CC option to enable C11 features... \" >&6; }\nif test ${ac_cv_prog_cc_c11+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_prog_cc_c11=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c11_program\n_ACEOF\nfor ac_arg in '' -std=gnu11\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c11=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c11\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\nfi\n\nif test \"x$ac_cv_prog_cc_c11\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse $as_nop\n  if test \"x$ac_cv_prog_cc_c11\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c11\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c11\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c11\"\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c11\n  ac_prog_cc_stdc=c11\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C99 features\" >&5\nprintf %s \"checking for $CC option to enable C99 features... \" >&6; }\nif test ${ac_cv_prog_cc_c99+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_prog_cc_c99=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c99_program\n_ACEOF\nfor ac_arg in '' -std=gnu99 -std=c99 -c99 -qlanglvl=extc1x -qlanglvl=extc99 -AC99 -D_STDC_C99=\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c99=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c99\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\nfi\n\nif test \"x$ac_cv_prog_cc_c99\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse $as_nop\n  if test \"x$ac_cv_prog_cc_c99\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c99\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c99\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c99\"\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99\n  ac_prog_cc_stdc=c99\nfi\nfi\nif test x$ac_prog_cc_stdc = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: checking for $CC option to enable C89 features\" >&5\nprintf %s \"checking for $CC option to enable C89 features... \" >&6; }\nif test ${ac_cv_prog_cc_c89+y}\nthen :\n  printf %s \"(cached) \" >&6\nelse $as_nop\n  ac_cv_prog_cc_c89=no\nac_save_CC=$CC\ncat confdefs.h - <<_ACEOF >conftest.$ac_ext\n/* end confdefs.h.  */\n$ac_c_conftest_c89_program\n_ACEOF\nfor ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std -Ae \"-Aa -D_HPUX_SOURCE\" \"-Xc -D__EXTENSIONS__\"\ndo\n  CC=\"$ac_save_CC $ac_arg\"\n  if ac_fn_c_try_compile \"$LINENO\"\nthen :\n  ac_cv_prog_cc_c89=$ac_arg\nfi\nrm -f core conftest.err conftest.$ac_objext conftest.beam\n  test \"x$ac_cv_prog_cc_c89\" != \"xno\" && break\ndone\nrm -f conftest.$ac_ext\nCC=$ac_save_CC\nfi\n\nif test \"x$ac_cv_prog_cc_c89\" = xno\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: unsupported\" >&5\nprintf \"%s\\n\" \"unsupported\" >&6; }\nelse $as_nop\n  if test \"x$ac_cv_prog_cc_c89\" = x\nthen :\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: none needed\" >&5\nprintf \"%s\\n\" \"none needed\" >&6; }\nelse $as_nop\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89\" >&5\nprintf \"%s\\n\" \"$ac_cv_prog_cc_c89\" >&6; }\n     CC=\"$CC $ac_cv_prog_cc_c89\"\nfi\n  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89\n  ac_prog_cc_stdc=c89\nfi\nfi\n\nac_ext=c\nac_cpp='$CPP $CPPFLAGS'\nac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'\nac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'\nac_compiler_gnu=$ac_cv_c_compiler_gnu\n\n\nac_header= ac_cache=\nfor ac_item in $ac_header_c_list\ndo\n  if test $ac_cache; then\n    ac_fn_c_check_header_compile \"$LINENO\" $ac_header ac_cv_header_$ac_cache \"$ac_includes_default\"\n    if eval test \\\"x\\$ac_cv_header_$ac_cache\\\" = xyes; then\n      printf \"%s\\n\" \"#define $ac_item 1\" >> confdefs.h\n    fi\n    ac_header= ac_cache=\n  elif test $ac_header; then\n    ac_cache=$ac_item\n  else\n    ac_header=$ac_item\n  fi\ndone\n\n\n\n\n\n\n\n\nif test $ac_cv_header_stdlib_h = yes && test $ac_cv_header_string_h = yes\nthen :\n\nprintf \"%s\\n\" \"#define STDC_HEADERS 1\" >>confdefs.h\n\nfi\n       for ac_header in linux/landlock.h\ndo :\n  ac_fn_c_check_header_compile \"$LINENO\" \"linux/landlock.h\" \"ac_cv_header_linux_landlock_h\" \"$ac_includes_default\"\nif test \"x$ac_cv_header_linux_landlock_h\" = xyes\nthen :\n  printf \"%s\\n\" \"#define HAVE_LINUX_LANDLOCK_H 1\" >>confdefs.h\n printf \"%s\\n\" \"#define HAVE_LANDLOCK 1\" >>confdefs.h\n\nfi\n\ndone\ncat >confcache <<\\_ACEOF\n# This file is a shell script that caches the results of configure\n# tests run on this system so they can be shared between configure\n# scripts and configure runs, see configure's option --config-cache.\n# It is not useful on other systems.  If it contains results you don't\n# want to keep, you may remove or edit it.\n#\n# config.status only pays attention to the cache file if you give it\n# the --recheck option to rerun configure.\n#\n# `ac_cv_env_foo' variables (set or unset) will be overridden when\n# loading this file, other *unset* `ac_cv_foo' will be assigned the\n# following values.\n\n_ACEOF\n\n# The following way of writing the cache mishandles newlines in values,\n# but we know of no workaround that is simple, portable, and efficient.\n# So, we kill variables containing newlines.\n# Ultrix sh set writes to stderr and can't be redirected directly,\n# and sets the high bit in the cache file unless we assign to the vars.\n(\n  for ac_var in `(set) 2>&1 | sed -n 's/^\\([a-zA-Z_][a-zA-Z0-9_]*\\)=.*/\\1/p'`; do\n    eval ac_val=\\$$ac_var\n    case $ac_val in #(\n    *${as_nl}*)\n      case $ac_var in #(\n      *_cv_*) { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: cache variable $ac_var contains a newline\" >&2;} ;;\n      esac\n      case $ac_var in #(\n      _ | IFS | as_nl) ;; #(\n      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(\n      *) { eval $ac_var=; unset $ac_var;} ;;\n      esac ;;\n    esac\n  done\n\n  (set) 2>&1 |\n    case $as_nl`(ac_space=' '; set) 2>&1` in #(\n    *${as_nl}ac_space=\\ *)\n      # `set' does not quote correctly, so add quotes: double-quote\n      # substitution turns \\\\\\\\ into \\\\, and sed turns \\\\ into \\.\n      sed -n \\\n\t\"s/'/'\\\\\\\\''/g;\n\t  s/^\\\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\\\)=\\\\(.*\\\\)/\\\\1='\\\\2'/p\"\n      ;; #(\n    *)\n      # `set' quotes correctly as required by POSIX, so do not add quotes.\n      sed -n \"/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p\"\n      ;;\n    esac |\n    sort\n) |\n  sed '\n     /^ac_cv_env_/b end\n     t clear\n     :clear\n     s/^\\([^=]*\\)=\\(.*[{}].*\\)$/test ${\\1+y} || &/\n     t end\n     s/^\\([^=]*\\)=\\(.*\\)$/\\1=${\\1=\\2}/\n     :end' >>confcache\nif diff \"$cache_file\" confcache >/dev/null 2>&1; then :; else\n  if test -w \"$cache_file\"; then\n    if test \"x$cache_file\" != \"x/dev/null\"; then\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: updating cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: updating cache $cache_file\" >&6;}\n      if test ! -f \"$cache_file\" || test -h \"$cache_file\"; then\n\tcat confcache >\"$cache_file\"\n      else\n        case $cache_file in #(\n        */* | ?:*)\n\t  mv -f confcache \"$cache_file\"$$ &&\n\t  mv -f \"$cache_file\"$$ \"$cache_file\" ;; #(\n        *)\n\t  mv -f confcache \"$cache_file\" ;;\n\tesac\n      fi\n    fi\n  else\n    { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file\" >&5\nprintf \"%s\\n\" \"$as_me: not updating unwritable cache $cache_file\" >&6;}\n  fi\nfi\nrm -f confcache\n\ntest \"x$prefix\" = xNONE && prefix=$ac_default_prefix\n# Let make expand exec_prefix.\ntest \"x$exec_prefix\" = xNONE && exec_prefix='${prefix}'\n\nDEFS=-DHAVE_CONFIG_H\n\nac_libobjs=\nac_ltlibobjs=\nU=\nfor ac_i in : $LIBOBJS; do test \"x$ac_i\" = x: && continue\n  # 1. Remove the extension, and $U if already installed.\n  ac_script='s/\\$U\\././;s/\\.o$//;s/\\.obj$//'\n  ac_i=`printf \"%s\\n\" \"$ac_i\" | sed \"$ac_script\"`\n  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR\n  #    will be set to the directory where LIBOBJS objects are built.\n  as_fn_append ac_libobjs \" \\${LIBOBJDIR}$ac_i\\$U.$ac_objext\"\n  as_fn_append ac_ltlibobjs \" \\${LIBOBJDIR}$ac_i\"'$U.lo'\ndone\nLIBOBJS=$ac_libobjs\n\nLTLIBOBJS=$ac_ltlibobjs\n\n\n\n: \"${CONFIG_STATUS=./config.status}\"\nac_write_fail=0\nac_clean_files_save=$ac_clean_files\nac_clean_files=\"$ac_clean_files $CONFIG_STATUS\"\n{ printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS\" >&5\nprintf \"%s\\n\" \"$as_me: creating $CONFIG_STATUS\" >&6;}\nas_write_fail=0\ncat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\n\ndebug=false\nac_cs_recheck=false\nac_cs_silent=false\n\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$CONFIG_STATUS <<\\_ASEOF || as_write_fail=1\n## -------------------- ##\n## M4sh Initialization. ##\n## -------------------- ##\n\n# Be more Bourne compatible\nDUALCASE=1; export DUALCASE # for MKS sh\nas_nop=:\nif test ${ZSH_VERSION+y} && (emulate sh) >/dev/null 2>&1\nthen :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse $as_nop\n  case `(set -o) 2>/dev/null` in #(\n  *posix*) :\n    set -o posix ;; #(\n  *) :\n     ;;\nesac\nfi\n\n\n\n# Reset variables that may have inherited troublesome values from\n# the environment.\n\n# IFS needs to be set, to space, tab, and newline, in precisely that order.\n# (If _AS_PATH_WALK were called with IFS unset, it would have the\n# side effect of setting IFS to empty, thus disabling word splitting.)\n# Quoting is to prevent editors from complaining about space-tab.\nas_nl='\n'\nexport as_nl\nIFS=\" \"\"\t$as_nl\"\n\nPS1='$ '\nPS2='> '\nPS4='+ '\n\n# Ensure predictable behavior from utilities with locale-dependent output.\nLC_ALL=C\nexport LC_ALL\nLANGUAGE=C\nexport LANGUAGE\n\n# We cannot yet rely on \"unset\" to work, but we need these variables\n# to be unset--not just set to an empty or harmless value--now, to\n# avoid bugs in old shells (e.g. pre-3.0 UWIN ksh).  This construct\n# also avoids known problems related to \"unset\" and subshell syntax\n# in other old shells (e.g. bash 2.01 and pdksh 5.2.14).\nfor as_var in BASH_ENV ENV MAIL MAILPATH CDPATH\ndo eval test \\${$as_var+y} \\\n  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :\ndone\n\n# Ensure that fds 0, 1, and 2 are open.\nif (exec 3>&0) 2>/dev/null; then :; else exec 0</dev/null; fi\nif (exec 3>&1) 2>/dev/null; then :; else exec 1>/dev/null; fi\nif (exec 3>&2)            ; then :; else exec 2>/dev/null; fi\n\n# The user is always right.\nif ${PATH_SEPARATOR+false} :; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n# Find who we are.  Look in the path if we contain no directory separator.\nas_myself=\ncase $0 in #((\n  *[\\\\/]* ) as_myself=$0 ;;\n  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  case $as_dir in #(((\n    '') as_dir=./ ;;\n    */) ;;\n    *) as_dir=$as_dir/ ;;\n  esac\n    test -r \"$as_dir$0\" && as_myself=$as_dir$0 && break\n  done\nIFS=$as_save_IFS\n\n     ;;\nesac\n# We did not find ourselves, most probably we were run as `sh COMMAND'\n# in which case we are not to be found in the path.\nif test \"x$as_myself\" = x; then\n  as_myself=$0\nfi\nif test ! -f \"$as_myself\"; then\n  printf \"%s\\n\" \"$as_myself: error: cannot find myself; rerun with an absolute file name\" >&2\n  exit 1\nfi\n\n\n\n# as_fn_error STATUS ERROR [LINENO LOG_FD]\n# ----------------------------------------\n# Output \"`basename $0`: error: ERROR\" to stderr. If LINENO and LOG_FD are\n# provided, also output the error to LOG_FD, referencing LINENO. Then exit the\n# script with STATUS, using 1 if that was 0.\nas_fn_error ()\n{\n  as_status=$1; test $as_status -eq 0 && as_status=1\n  if test \"$4\"; then\n    as_lineno=${as_lineno-\"$3\"} as_lineno_stack=as_lineno_stack=$as_lineno_stack\n    printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: error: $2\" >&$4\n  fi\n  printf \"%s\\n\" \"$as_me: error: $2\" >&2\n  as_fn_exit $as_status\n} # as_fn_error\n\n\n\n# as_fn_set_status STATUS\n# -----------------------\n# Set $? to STATUS, without forking.\nas_fn_set_status ()\n{\n  return $1\n} # as_fn_set_status\n\n# as_fn_exit STATUS\n# -----------------\n# Exit the shell with STATUS, even in a \"trap 0\" or \"set -e\" context.\nas_fn_exit ()\n{\n  set +e\n  as_fn_set_status $1\n  exit $1\n} # as_fn_exit\n\n# as_fn_unset VAR\n# ---------------\n# Portably unset VAR.\nas_fn_unset ()\n{\n  { eval $1=; unset $1;}\n}\nas_unset=as_fn_unset\n\n# as_fn_append VAR VALUE\n# ----------------------\n# Append the text in VALUE to the end of the definition contained in VAR. Take\n# advantage of any shell optimizations that allow amortized linear growth over\n# repeated appends, instead of the typical quadratic growth present in naive\n# implementations.\nif (eval \"as_var=1; as_var+=2; test x\\$as_var = x12\") 2>/dev/null\nthen :\n  eval 'as_fn_append ()\n  {\n    eval $1+=\\$2\n  }'\nelse $as_nop\n  as_fn_append ()\n  {\n    eval $1=\\$$1\\$2\n  }\nfi # as_fn_append\n\n# as_fn_arith ARG...\n# ------------------\n# Perform arithmetic evaluation on the ARGs, and store the result in the\n# global $as_val. Take advantage of shells that can avoid forks. The arguments\n# must be portable across $(()) and expr.\nif (eval \"test \\$(( 1 + 1 )) = 2\") 2>/dev/null\nthen :\n  eval 'as_fn_arith ()\n  {\n    as_val=$(( $* ))\n  }'\nelse $as_nop\n  as_fn_arith ()\n  {\n    as_val=`expr \"$@\" || test $? -eq 1`\n  }\nfi # as_fn_arith\n\n\nif expr a : '\\(a\\)' >/dev/null 2>&1 &&\n   test \"X`expr 00001 : '.*\\(...\\)'`\" = X001; then\n  as_expr=expr\nelse\n  as_expr=false\nfi\n\nif (basename -- /) >/dev/null 2>&1 && test \"X`basename -- / 2>&1`\" = \"X/\"; then\n  as_basename=basename\nelse\n  as_basename=false\nfi\n\nif (as_dir=`dirname -- /` && test \"X$as_dir\" = X/) >/dev/null 2>&1; then\n  as_dirname=dirname\nelse\n  as_dirname=false\nfi\n\nas_me=`$as_basename -- \"$0\" ||\n$as_expr X/\"$0\" : '.*/\\([^/][^/]*\\)/*$' \\| \\\n\t X\"$0\" : 'X\\(//\\)$' \\| \\\n\t X\"$0\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X/\"$0\" |\n    sed '/^.*\\/\\([^/][^/]*\\)\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\/\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n\n# Avoid depending upon Character Ranges.\nas_cr_letters='abcdefghijklmnopqrstuvwxyz'\nas_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nas_cr_Letters=$as_cr_letters$as_cr_LETTERS\nas_cr_digits='0123456789'\nas_cr_alnum=$as_cr_Letters$as_cr_digits\n\n\n# Determine whether it's possible to make 'echo' print without a newline.\n# These variables are no longer used directly by Autoconf, but are AC_SUBSTed\n# for compatibility with existing Makefiles.\nECHO_C= ECHO_N= ECHO_T=\ncase `echo -n x` in #(((((\n-n*)\n  case `echo 'xy\\c'` in\n  *c*) ECHO_T='\t';;\t# ECHO_T is single tab character.\n  xy)  ECHO_C='\\c';;\n  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null\n       ECHO_T='\t';;\n  esac;;\n*)\n  ECHO_N='-n';;\nesac\n\n# For backward compatibility with old third-party macros, we provide\n# the shell variables $as_echo and $as_echo_n.  New code should use\n# AS_ECHO([\"message\"]) and AS_ECHO_N([\"message\"]), respectively.\nas_echo='printf %s\\n'\nas_echo_n='printf %s'\n\nrm -f conf$$ conf$$.exe conf$$.file\nif test -d conf$$.dir; then\n  rm -f conf$$.dir/conf$$.file\nelse\n  rm -f conf$$.dir\n  mkdir conf$$.dir 2>/dev/null\nfi\nif (echo >conf$$.file) 2>/dev/null; then\n  if ln -s conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s='ln -s'\n    # ... but there are two gotchas:\n    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.\n    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.\n    # In both cases, we have to default to `cp -pR'.\n    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||\n      as_ln_s='cp -pR'\n  elif ln conf$$.file conf$$ 2>/dev/null; then\n    as_ln_s=ln\n  else\n    as_ln_s='cp -pR'\n  fi\nelse\n  as_ln_s='cp -pR'\nfi\nrm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file\nrmdir conf$$.dir 2>/dev/null\n\n\n# as_fn_mkdir_p\n# -------------\n# Create \"$as_dir\" as a directory, including parents if necessary.\nas_fn_mkdir_p ()\n{\n\n  case $as_dir in #(\n  -*) as_dir=./$as_dir;;\n  esac\n  test -d \"$as_dir\" || eval $as_mkdir_p || {\n    as_dirs=\n    while :; do\n      case $as_dir in #(\n      *\\'*) as_qdir=`printf \"%s\\n\" \"$as_dir\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; #'(\n      *) as_qdir=$as_dir;;\n      esac\n      as_dirs=\"'$as_qdir' $as_dirs\"\n      as_dir=`$as_dirname -- \"$as_dir\" ||\n$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n\t X\"$as_dir\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$as_dir\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n      test -d \"$as_dir\" && break\n    done\n    test -z \"$as_dirs\" || eval \"mkdir $as_dirs\"\n  } || test -d \"$as_dir\" || as_fn_error $? \"cannot create directory $as_dir\"\n\n\n} # as_fn_mkdir_p\nif mkdir -p . 2>/dev/null; then\n  as_mkdir_p='mkdir -p \"$as_dir\"'\nelse\n  test -d ./-p && rmdir ./-p\n  as_mkdir_p=false\nfi\n\n\n# as_fn_executable_p FILE\n# -----------------------\n# Test if FILE is an executable regular file.\nas_fn_executable_p ()\n{\n  test -f \"$1\" && test -x \"$1\"\n} # as_fn_executable_p\nas_test_x='test -x'\nas_executable_p=as_fn_executable_p\n\n# Sed expression to map a string onto a valid CPP name.\nas_tr_cpp=\"eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'\"\n\n# Sed expression to map a string onto a valid variable name.\nas_tr_sh=\"eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'\"\n\n\nexec 6>&1\n## ----------------------------------- ##\n## Main body of $CONFIG_STATUS script. ##\n## ----------------------------------- ##\n_ASEOF\ntest $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# Save the log message, to keep $0 and so on meaningful, and to\n# report actual input values of CONFIG_FILES etc. instead of their\n# values after options handling.\nac_log=\"\nThis file was extended by $as_me, which was\ngenerated by GNU Autoconf 2.71.  Invocation command line was\n\n  CONFIG_FILES    = $CONFIG_FILES\n  CONFIG_HEADERS  = $CONFIG_HEADERS\n  CONFIG_LINKS    = $CONFIG_LINKS\n  CONFIG_COMMANDS = $CONFIG_COMMANDS\n  $ $0 $@\n\non `(hostname || uname -n) 2>/dev/null | sed 1q`\n\"\n\n_ACEOF\n\ncase $ac_config_files in *\"\n\"*) set x $ac_config_files; shift; ac_config_files=$*;;\nesac\n\ncase $ac_config_headers in *\"\n\"*) set x $ac_config_headers; shift; ac_config_headers=$*;;\nesac\n\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n# Files that config.status was made for.\nconfig_files=\"$ac_config_files\"\nconfig_headers=\"$ac_config_headers\"\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nac_cs_usage=\"\\\n\\`$as_me' instantiates files and other configuration actions\nfrom templates according to the current configuration.  Unless the files\nand actions are specified as TAGs, all are instantiated by default.\n\nUsage: $0 [OPTION]... [TAG]...\n\n  -h, --help       print this help, then exit\n  -V, --version    print version number and configuration settings, then exit\n      --config     print configuration, then exit\n  -q, --quiet, --silent\n                   do not print progress messages\n  -d, --debug      don't remove temporary files\n      --recheck    update $as_me by reconfiguring in the same conditions\n      --file=FILE[:TEMPLATE]\n                   instantiate the configuration file FILE\n      --header=FILE[:TEMPLATE]\n                   instantiate the configuration header FILE\n\nConfiguration files:\n$config_files\n\nConfiguration headers:\n$config_headers\n\nReport bugs to the package provider.\"\n\n_ACEOF\nac_cs_config=`printf \"%s\\n\" \"$ac_configure_args\" | sed \"$ac_safe_unquote\"`\nac_cs_config_escaped=`printf \"%s\\n\" \"$ac_cs_config\" | sed \"s/^ //; s/'/'\\\\\\\\\\\\\\\\''/g\"`\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_cs_config='$ac_cs_config_escaped'\nac_cs_version=\"\\\\\nconfig.status\nconfigured by $0, generated by GNU Autoconf 2.71,\n  with options \\\\\"\\$ac_cs_config\\\\\"\n\nCopyright (C) 2021 Free Software Foundation, Inc.\nThis config.status script is free software; the Free Software Foundation\ngives unlimited permission to copy, distribute and modify it.\"\n\nac_pwd='$ac_pwd'\nsrcdir='$srcdir'\ntest -n \"\\$AWK\" || AWK=awk\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# The default lists apply if the user does not specify any file.\nac_need_defaults=:\nwhile test $# != 0\ndo\n  case $1 in\n  --*=?*)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=`expr \"X$1\" : 'X[^=]*=\\(.*\\)'`\n    ac_shift=:\n    ;;\n  --*=)\n    ac_option=`expr \"X$1\" : 'X\\([^=]*\\)='`\n    ac_optarg=\n    ac_shift=:\n    ;;\n  *)\n    ac_option=$1\n    ac_optarg=$2\n    ac_shift=shift\n    ;;\n  esac\n\n  case $ac_option in\n  # Handling of the options.\n  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)\n    ac_cs_recheck=: ;;\n  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )\n    printf \"%s\\n\" \"$ac_cs_version\"; exit ;;\n  --config | --confi | --conf | --con | --co | --c )\n    printf \"%s\\n\" \"$ac_cs_config\"; exit ;;\n  --debug | --debu | --deb | --de | --d | -d )\n    debug=: ;;\n  --file | --fil | --fi | --f )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`printf \"%s\\n\" \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    '') as_fn_error $? \"missing file argument\" ;;\n    esac\n    as_fn_append CONFIG_FILES \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --header | --heade | --head | --hea )\n    $ac_shift\n    case $ac_optarg in\n    *\\'*) ac_optarg=`printf \"%s\\n\" \"$ac_optarg\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"` ;;\n    esac\n    as_fn_append CONFIG_HEADERS \" '$ac_optarg'\"\n    ac_need_defaults=false;;\n  --he | --h)\n    # Conflict between --help and --header\n    as_fn_error $? \"ambiguous option: \\`$1'\nTry \\`$0 --help' for more information.\";;\n  --help | --hel | -h )\n    printf \"%s\\n\" \"$ac_cs_usage\"; exit ;;\n  -q | -quiet | --quiet | --quie | --qui | --qu | --q \\\n  | -silent | --silent | --silen | --sile | --sil | --si | --s)\n    ac_cs_silent=: ;;\n\n  # This is an error.\n  -*) as_fn_error $? \"unrecognized option: \\`$1'\nTry \\`$0 --help' for more information.\" ;;\n\n  *) as_fn_append ac_config_targets \" $1\"\n     ac_need_defaults=false ;;\n\n  esac\n  shift\ndone\n\nac_configure_extra_args=\n\nif $ac_cs_silent; then\n  exec 6>/dev/null\n  ac_configure_extra_args=\"$ac_configure_extra_args --silent\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nif \\$ac_cs_recheck; then\n  set X $SHELL '$0' $ac_configure_args \\$ac_configure_extra_args --no-create --no-recursion\n  shift\n  \\printf \"%s\\n\" \"running CONFIG_SHELL=$SHELL \\$*\" >&6\n  CONFIG_SHELL='$SHELL'\n  export CONFIG_SHELL\n  exec \"\\$@\"\nfi\n\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nexec 5>>config.log\n{\n  echo\n  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX\n## Running $as_me. ##\n_ASBOX\n  printf \"%s\\n\" \"$ac_log\"\n} >&5\n\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n\n# Handling of arguments.\nfor ac_config_target in $ac_config_targets\ndo\n  case $ac_config_target in\n    \"config.h\") CONFIG_HEADERS=\"$CONFIG_HEADERS config.h\" ;;\n    \"Makefile\") CONFIG_FILES=\"$CONFIG_FILES Makefile\" ;;\n\n  *) as_fn_error $? \"invalid argument: \\`$ac_config_target'\" \"$LINENO\" 5;;\n  esac\ndone\n\n\n# If the user did not use the arguments to specify the items to instantiate,\n# then the envvar interface is used.  Set only those that are not.\n# We use the long form for the default assignment because of an extremely\n# bizarre bug on SunOS 4.1.3.\nif $ac_need_defaults; then\n  test ${CONFIG_FILES+y} || CONFIG_FILES=$config_files\n  test ${CONFIG_HEADERS+y} || CONFIG_HEADERS=$config_headers\nfi\n\n# Have a temporary directory for convenience.  Make it in the build tree\n# simply because there is no reason against having it here, and in addition,\n# creating and moving files from /tmp can sometimes cause problems.\n# Hook for its removal unless debugging.\n# Note that there is a small window in which the directory will not be cleaned:\n# after its creation but before its name has been assigned to `$tmp'.\n$debug ||\n{\n  tmp= ac_tmp=\n  trap 'exit_status=$?\n  : \"${ac_tmp:=$tmp}\"\n  { test ! -d \"$ac_tmp\" || rm -fr \"$ac_tmp\"; } && exit $exit_status\n' 0\n  trap 'as_fn_exit 1' 1 2 13 15\n}\n# Create a (secure) tmp directory for tmp files.\n\n{\n  tmp=`(umask 077 && mktemp -d \"./confXXXXXX\") 2>/dev/null` &&\n  test -d \"$tmp\"\n}  ||\n{\n  tmp=./conf$$-$RANDOM\n  (umask 077 && mkdir \"$tmp\")\n} || as_fn_error $? \"cannot create a temporary directory in .\" \"$LINENO\" 5\nac_tmp=$tmp\n\n# Set up the scripts for CONFIG_FILES section.\n# No need to generate them if there are no CONFIG_FILES.\n# This happens for instance with `./config.status config.h'.\nif test -n \"$CONFIG_FILES\"; then\n\n\nac_cr=`echo X | tr X '\\015'`\n# On cygwin, bash can eat \\r inside `` if the user requested igncr.\n# But we know of no other shell where ac_cr would be empty at this\n# point, so we can use a bashism as a fallback.\nif test \"x$ac_cr\" = x; then\n  eval ac_cr=\\$\\'\\\\r\\'\nfi\nac_cs_awk_cr=`$AWK 'BEGIN { print \"a\\rb\" }' </dev/null 2>/dev/null`\nif test \"$ac_cs_awk_cr\" = \"a${ac_cr}b\"; then\n  ac_cs_awk_cr='\\\\r'\nelse\n  ac_cs_awk_cr=$ac_cr\nfi\n\necho 'BEGIN {' >\"$ac_tmp/subs1.awk\" &&\n_ACEOF\n\n\n{\n  echo \"cat >conf$$subs.awk <<_ACEOF\" &&\n  echo \"$ac_subst_vars\" | sed 's/.*/&!$&$ac_delim/' &&\n  echo \"_ACEOF\"\n} >conf$$subs.sh ||\n  as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\nac_delim_num=`echo \"$ac_subst_vars\" | grep -c '^'`\nac_delim='%!_!# '\nfor ac_last_try in false false false false false :; do\n  . ./conf$$subs.sh ||\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n\n  ac_delim_n=`sed -n \"s/.*$ac_delim\\$/X/p\" conf$$subs.awk | grep -c X`\n  if test $ac_delim_n = $ac_delim_num; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_STATUS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\nrm -f conf$$subs.sh\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\ncat >>\"\\$ac_tmp/subs1.awk\" <<\\\\_ACAWK &&\n_ACEOF\nsed -n '\nh\ns/^/S[\"/; s/!.*/\"]=/\np\ng\ns/^[^!]*!//\n:repl\nt repl\ns/'\"$ac_delim\"'$//\nt delim\n:nl\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\n\"\\\\/\np\nn\nb repl\n:more1\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt nl\n:delim\nh\ns/\\(.\\{148\\}\\)..*/\\1/\nt more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/\np\nb\n:more2\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"\\\\/\np\ng\ns/.\\{148\\}//\nt delim\n' <conf$$subs.awk | sed '\n/^[^\"\"]/{\n  N\n  s/\\n//\n}\n' >>$CONFIG_STATUS || ac_write_fail=1\nrm -f conf$$subs.awk\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n_ACAWK\ncat >>\"\\$ac_tmp/subs1.awk\" <<_ACAWK &&\n  for (key in S) S_is_set[key] = 1\n  FS = \"\u0007\"\n\n}\n{\n  line = $ 0\n  nfields = split(line, field, \"@\")\n  substed = 0\n  len = length(field[1])\n  for (i = 2; i < nfields; i++) {\n    key = field[i]\n    keylen = length(key)\n    if (S_is_set[key]) {\n      value = S[key]\n      line = substr(line, 1, len) \"\" value \"\" substr(line, len + keylen + 3)\n      len += length(value) + length(field[++i])\n      substed = 1\n    } else\n      len += 1 + keylen\n  }\n\n  print line\n}\n\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nif sed \"s/$ac_cr//\" < /dev/null > /dev/null 2>&1; then\n  sed \"s/$ac_cr\\$//; s/$ac_cr/$ac_cs_awk_cr/g\"\nelse\n  cat\nfi < \"$ac_tmp/subs1.awk\" > \"$ac_tmp/subs.awk\" \\\n  || as_fn_error $? \"could not setup config files machinery\" \"$LINENO\" 5\n_ACEOF\n\n# VPATH may cause trouble with some makes, so we remove sole $(srcdir),\n# ${srcdir} and @srcdir@ entries from VPATH if srcdir is \".\", strip leading and\n# trailing colons and then remove the whole line if VPATH becomes empty\n# (actually we leave an empty line to preserve line numbers).\nif test \"x$srcdir\" = x.; then\n  ac_vpsub='/^[\t ]*VPATH[\t ]*=[\t ]*/{\nh\ns///\ns/^/:/\ns/[\t ]*$/:/\ns/:\\$(srcdir):/:/g\ns/:\\${srcdir}:/:/g\ns/:@srcdir@:/:/g\ns/^:*//\ns/:*$//\nx\ns/\\(=[\t ]*\\).*/\\1/\nG\ns/\\n//\ns/^[^=]*=[\t ]*$//\n}'\nfi\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\nfi # test -n \"$CONFIG_FILES\"\n\n# Set up the scripts for CONFIG_HEADERS section.\n# No need to generate them if there are no CONFIG_HEADERS.\n# This happens for instance with `./config.status Makefile'.\nif test -n \"$CONFIG_HEADERS\"; then\ncat >\"$ac_tmp/defines.awk\" <<\\_ACAWK ||\nBEGIN {\n_ACEOF\n\n# Transform confdefs.h into an awk script `defines.awk', embedded as\n# here-document in config.status, that substitutes the proper values into\n# config.h.in to produce config.h.\n\n# Create a delimiter string that does not exist in confdefs.h, to ease\n# handling of long lines.\nac_delim='%!_!# '\nfor ac_last_try in false false :; do\n  ac_tt=`sed -n \"/$ac_delim/p\" confdefs.h`\n  if test -z \"$ac_tt\"; then\n    break\n  elif $ac_last_try; then\n    as_fn_error $? \"could not make $CONFIG_HEADERS\" \"$LINENO\" 5\n  else\n    ac_delim=\"$ac_delim!$ac_delim _$ac_delim!! \"\n  fi\ndone\n\n# For the awk script, D is an array of macro values keyed by name,\n# likewise P contains macro parameters if any.  Preserve backslash\n# newline sequences.\n\nac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*\nsed -n '\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt rset\n:rset\ns/^[\t ]*#[\t ]*define[\t ][\t ]*/ /\nt def\nd\n:def\ns/\\\\$//\nt bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\"/p\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\"/p\nd\n:bsnl\ns/[\"\\\\]/\\\\&/g\ns/^ \\('\"$ac_word_re\"'\\)\\(([^()]*)\\)[\t ]*\\(.*\\)/P[\"\\1\"]=\"\\2\"\\\nD[\"\\1\"]=\" \\3\\\\\\\\\\\\n\"\\\\/p\nt cont\ns/^ \\('\"$ac_word_re\"'\\)[\t ]*\\(.*\\)/D[\"\\1\"]=\" \\2\\\\\\\\\\\\n\"\\\\/p\nt cont\nd\n:cont\nn\ns/.\\{148\\}/&'\"$ac_delim\"'/g\nt clear\n:clear\ns/\\\\$//\nt bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\"/p\nd\n:bsnlc\ns/[\"\\\\]/\\\\&/g; s/^/\"/; s/$/\\\\\\\\\\\\n\"\\\\/p\nb cont\n' <confdefs.h | sed '\ns/'\"$ac_delim\"'/\"\\\\\\\n\"/g' >>$CONFIG_STATUS || ac_write_fail=1\n\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  for (key in D) D_is_set[key] = 1\n  FS = \"\u0007\"\n}\n/^[\\t ]*#[\\t ]*(define|undef)[\\t ]+$ac_word_re([\\t (]|\\$)/ {\n  line = \\$ 0\n  split(line, arg, \" \")\n  if (arg[1] == \"#\") {\n    defundef = arg[2]\n    mac1 = arg[3]\n  } else {\n    defundef = substr(arg[1], 2)\n    mac1 = arg[2]\n  }\n  split(mac1, mac2, \"(\") #)\n  macro = mac2[1]\n  prefix = substr(line, 1, index(line, defundef) - 1)\n  if (D_is_set[macro]) {\n    # Preserve the white space surrounding the \"#\".\n    print prefix \"define\", macro P[macro] D[macro]\n    next\n  } else {\n    # Replace #undef with comments.  This is necessary, for example,\n    # in the case of _POSIX_SOURCE, which is predefined and required\n    # on some systems where configure will not decide to define it.\n    if (defundef == \"undef\") {\n      print \"/*\", prefix defundef, macro, \"*/\"\n      next\n    }\n  }\n}\n{ print }\n_ACAWK\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n  as_fn_error $? \"could not setup config headers machinery\" \"$LINENO\" 5\nfi # test -n \"$CONFIG_HEADERS\"\n\n\neval set X \"  :F $CONFIG_FILES  :H $CONFIG_HEADERS    \"\nshift\nfor ac_tag\ndo\n  case $ac_tag in\n  :[FHLC]) ac_mode=$ac_tag; continue;;\n  esac\n  case $ac_mode$ac_tag in\n  :[FHL]*:*);;\n  :L* | :C*:*) as_fn_error $? \"invalid tag \\`$ac_tag'\" \"$LINENO\" 5;;\n  :[FH]-) ac_tag=-:-;;\n  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;\n  esac\n  ac_save_IFS=$IFS\n  IFS=:\n  set x $ac_tag\n  IFS=$ac_save_IFS\n  shift\n  ac_file=$1\n  shift\n\n  case $ac_mode in\n  :L) ac_source=$1;;\n  :[FH])\n    ac_file_inputs=\n    for ac_f\n    do\n      case $ac_f in\n      -) ac_f=\"$ac_tmp/stdin\";;\n      *) # Look for the file first in the build tree, then in the source tree\n\t # (if the path is not absolute).  The absolute path cannot be DOS-style,\n\t # because $ac_f cannot contain `:'.\n\t test -f \"$ac_f\" ||\n\t   case $ac_f in\n\t   [\\\\/$]*) false;;\n\t   *) test -f \"$srcdir/$ac_f\" && ac_f=\"$srcdir/$ac_f\";;\n\t   esac ||\n\t   as_fn_error 1 \"cannot find input file: \\`$ac_f'\" \"$LINENO\" 5;;\n      esac\n      case $ac_f in *\\'*) ac_f=`printf \"%s\\n\" \"$ac_f\" | sed \"s/'/'\\\\\\\\\\\\\\\\''/g\"`;; esac\n      as_fn_append ac_file_inputs \" '$ac_f'\"\n    done\n\n    # Let's still pretend it is `configure' which instantiates (i.e., don't\n    # use $as_me), people would be surprised to read:\n    #    /* config.h.  Generated by config.status.  */\n    configure_input='Generated from '`\n\t  printf \"%s\\n\" \"$*\" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'\n\t`' by configure.'\n    if test x\"$ac_file\" != x-; then\n      configure_input=\"$ac_file.  $configure_input\"\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: creating $ac_file\" >&5\nprintf \"%s\\n\" \"$as_me: creating $ac_file\" >&6;}\n    fi\n    # Neutralize special characters interpreted by sed in replacement strings.\n    case $configure_input in #(\n    *\\&* | *\\|* | *\\\\* )\n       ac_sed_conf_input=`printf \"%s\\n\" \"$configure_input\" |\n       sed 's/[\\\\\\\\&|]/\\\\\\\\&/g'`;; #(\n    *) ac_sed_conf_input=$configure_input;;\n    esac\n\n    case $ac_tag in\n    *:-:* | *:-) cat >\"$ac_tmp/stdin\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5 ;;\n    esac\n    ;;\n  esac\n\n  ac_dir=`$as_dirname -- \"$ac_file\" ||\n$as_expr X\"$ac_file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)[^/]' \\| \\\n\t X\"$ac_file\" : 'X\\(//\\)$' \\| \\\n\t X\"$ac_file\" : 'X\\(/\\)' \\| . 2>/dev/null ||\nprintf \"%s\\n\" X\"$ac_file\" |\n    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)[^/].*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\/\\)$/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  /^X\\(\\/\\).*/{\n\t    s//\\1/\n\t    q\n\t  }\n\t  s/.*/./; q'`\n  as_dir=\"$ac_dir\"; as_fn_mkdir_p\n  ac_builddir=.\n\ncase \"$ac_dir\" in\n.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;\n*)\n  ac_dir_suffix=/`printf \"%s\\n\" \"$ac_dir\" | sed 's|^\\.[\\\\/]||'`\n  # A \"..\" for each directory in $ac_dir_suffix.\n  ac_top_builddir_sub=`printf \"%s\\n\" \"$ac_dir_suffix\" | sed 's|/[^\\\\/]*|/..|g;s|/||'`\n  case $ac_top_builddir_sub in\n  \"\") ac_top_builddir_sub=. ac_top_build_prefix= ;;\n  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;\n  esac ;;\nesac\nac_abs_top_builddir=$ac_pwd\nac_abs_builddir=$ac_pwd$ac_dir_suffix\n# for backward compatibility:\nac_top_builddir=$ac_top_build_prefix\n\ncase $srcdir in\n  .)  # We are building in place.\n    ac_srcdir=.\n    ac_top_srcdir=$ac_top_builddir_sub\n    ac_abs_top_srcdir=$ac_pwd ;;\n  [\\\\/]* | ?:[\\\\/]* )  # Absolute name.\n    ac_srcdir=$srcdir$ac_dir_suffix;\n    ac_top_srcdir=$srcdir\n    ac_abs_top_srcdir=$srcdir ;;\n  *) # Relative name.\n    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix\n    ac_top_srcdir=$ac_top_build_prefix$srcdir\n    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;\nesac\nac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix\n\n\n  case $ac_mode in\n  :F)\n  #\n  # CONFIG_FILE\n  #\n\n_ACEOF\n\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n# If the template does not know about datarootdir, expand it.\n# FIXME: This hack should be removed a few years after 2.60.\nac_datarootdir_hack=; ac_datarootdir_seen=\nac_sed_dataroot='\n/datarootdir/ {\n  p\n  q\n}\n/@datadir@/p\n/@docdir@/p\n/@infodir@/p\n/@localedir@/p\n/@mandir@/p'\ncase `eval \"sed -n \\\"\\$ac_sed_dataroot\\\" $ac_file_inputs\"` in\n*datarootdir*) ac_datarootdir_seen=yes;;\n*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting\" >&2;}\n_ACEOF\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n  ac_datarootdir_hack='\n  s&@datadir@&$datadir&g\n  s&@docdir@&$docdir&g\n  s&@infodir@&$infodir&g\n  s&@localedir@&$localedir&g\n  s&@mandir@&$mandir&g\n  s&\\\\\\${datarootdir}&$datarootdir&g' ;;\nesac\n_ACEOF\n\n# Neutralize VPATH when `$srcdir' = `.'.\n# Shell code in configure.ac might set extrasub.\n# FIXME: do we really want to maintain this feature?\ncat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\nac_sed_extra=\"$ac_vpsub\n$extrasub\n_ACEOF\ncat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n:t\n/@[a-zA-Z_][a-zA-Z_0-9]*@/!b\ns|@configure_input@|$ac_sed_conf_input|;t t\ns&@top_builddir@&$ac_top_builddir_sub&;t t\ns&@top_build_prefix@&$ac_top_build_prefix&;t t\ns&@srcdir@&$ac_srcdir&;t t\ns&@abs_srcdir@&$ac_abs_srcdir&;t t\ns&@top_srcdir@&$ac_top_srcdir&;t t\ns&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t\ns&@builddir@&$ac_builddir&;t t\ns&@abs_builddir@&$ac_abs_builddir&;t t\ns&@abs_top_builddir@&$ac_abs_top_builddir&;t t\n$ac_datarootdir_hack\n\"\neval sed \\\"\\$ac_sed_extra\\\" \"$ac_file_inputs\" | $AWK -f \"$ac_tmp/subs.awk\" \\\n  >$ac_tmp/out || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n\ntest -z \"$ac_datarootdir_hack$ac_datarootdir_seen\" &&\n  { ac_out=`sed -n '/\\${datarootdir}/p' \"$ac_tmp/out\"`; test -n \"$ac_out\"; } &&\n  { ac_out=`sed -n '/^[\t ]*datarootdir[\t ]*:*=/p' \\\n      \"$ac_tmp/out\"`; test -z \"$ac_out\"; } &&\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: $ac_file contains a reference to the variable \\`datarootdir'\nwhich seems to be undefined.  Please make sure it is defined\" >&2;}\n\n  rm -f \"$ac_tmp/stdin\"\n  case $ac_file in\n  -) cat \"$ac_tmp/out\" && rm -f \"$ac_tmp/out\";;\n  *) rm -f \"$ac_file\" && mv \"$ac_tmp/out\" \"$ac_file\";;\n  esac \\\n  || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n ;;\n  :H)\n  #\n  # CONFIG_HEADER\n  #\n  if test x\"$ac_file\" != x-; then\n    {\n      printf \"%s\\n\" \"/* $configure_input  */\" >&1 \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\"\n    } >\"$ac_tmp/config.h\" \\\n      || as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    if diff \"$ac_file\" \"$ac_tmp/config.h\" >/dev/null 2>&1; then\n      { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: $ac_file is unchanged\" >&5\nprintf \"%s\\n\" \"$as_me: $ac_file is unchanged\" >&6;}\n    else\n      rm -f \"$ac_file\"\n      mv \"$ac_tmp/config.h\" \"$ac_file\" \\\n\t|| as_fn_error $? \"could not create $ac_file\" \"$LINENO\" 5\n    fi\n  else\n    printf \"%s\\n\" \"/* $configure_input  */\" >&1 \\\n      && eval '$AWK -f \"$ac_tmp/defines.awk\"' \"$ac_file_inputs\" \\\n      || as_fn_error $? \"could not create -\" \"$LINENO\" 5\n  fi\n ;;\n\n\n  esac\n\ndone # for ac_tag\n\n\nas_fn_exit 0\n_ACEOF\nac_clean_files=$ac_clean_files_save\n\ntest $ac_write_fail = 0 ||\n  as_fn_error $? \"write failure creating $CONFIG_STATUS\" \"$LINENO\" 5\n\n\n# configure is writing to config.log, and then calls config.status.\n# config.status does its own redirection, appending to config.log.\n# Unfortunately, on DOS this fails, as config.log is still kept open\n# by configure, so config.status won't be able to write to it; its\n# output is simply discarded.  So we exec the FD to /dev/null,\n# effectively closing config.log, so it can be properly (re)opened and\n# appended to by config.status.  When coming back to configure, we\n# need to make the FD available again.\nif test \"$no_create\" != yes; then\n  ac_cs_success=:\n  ac_config_status_args=\n  test \"$silent\" = yes &&\n    ac_config_status_args=\"$ac_config_status_args --quiet\"\n  exec 5>/dev/null\n  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false\n  exec 5>>config.log\n  # Use ||, not &&, to avoid exiting from the if with $? = 1, which\n  # would make configure fail if this is the last instruction.\n  $ac_cs_success || as_fn_exit 1\nfi\nif test -n \"$ac_unrecognized_opts\" && test \"$enable_option_checking\" != no; then\n  { printf \"%s\\n\" \"$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts\" >&5\nprintf \"%s\\n\" \"$as_me: WARNING: unrecognized options: $ac_unrecognized_opts\" >&2;}\nfi\n\n\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 0.21484375,
          "content": "\ndnl Use autoconf to generate the `configure` script from this and Makefile.in\n\nAC_INIT\nAC_CONFIG_HEADERS(config.h)\nAC_CONFIG_FILES([Makefile])\n\nAC_CHECK_HEADERS(linux/landlock.h, AC_DEFINE(HAVE_LANDLOCK), [])\nAC_OUTPUT\n"
        },
        {
          "name": "container-entrypoint.sh",
          "type": "blob",
          "size": 3.0830078125,
          "content": "#!/bin/sh\n# SPDX-License-Identifier: GPL2-or-later\n#\n# Copyright (C) 2023 Olliver Schinagl <oliver@schinagl.nl>\n#\n# A beginning user should be able to docker run image bash (or sh) without\n# needing to learn about --entrypoint\n# https://github.com/docker-library/official-images#consistency\n\nset -eu\n\nbin='sslh'\n\n# run command if it is not starting with a \"-\" and is an executable in PATH\nif [ \"${#}\" -le 0 ] || \\\n   [ \"${1#-}\" != \"${1}\" ] || \\\n   [ -d \"${1}\" ] || \\\n   ! command -v \"${1}\" > '/dev/null' 2>&1; then\n\tentrypoint='true'\nfi\n\nunconfigure_iptables() { \n\techo \"Received SIG TERM/INT/KILL. Removing iptables / routing changes\"\n\n\tset +e # Don't exit if got error\n\tset -x\n\n\tiptables -t raw -D PREROUTING ! -i lo -d 127.0.0.0/8 -j DROP\n\tiptables -t mangle -D POSTROUTING ! -o lo -s 127.0.0.0/8 -j DROP\n\n\tiptables -t nat -D OUTPUT -m owner --uid-owner sslh -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -j CONNMARK --set-xmark 0x01/0x0f\n\tiptables -t mangle -D OUTPUT ! -o lo -p tcp -m connmark --mark 0x01/0x0f -j CONNMARK --restore-mark --mask 0x0f\n\n\tip rule del fwmark 0x1 lookup 100\n\tip route del local 0.0.0.0/0 dev lo table 100\n\n\n\tif [ $(cat /proc/sys/net/ipv6/conf/all/disable_ipv6) -eq 0 ]; then\n\t\tip6tables -t raw -D PREROUTING ! -i lo -d ::1/128 -j DROP\n\t\tip6tables -t mangle -D POSTROUTING ! -o lo -s ::1/128 -j DROP\n\t\tip6tables -t nat -D OUTPUT -m owner --uid-owner sslh -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -j CONNMARK --set-xmark 0x01/0x0f\n\t\tip6tables -t mangle -D OUTPUT ! -o lo -p tcp -m connmark --mark 0x01/0x0f -j CONNMARK --restore-mark --mask 0x0f\n\n\t\tip -6 rule del fwmark 0x1 lookup 100\n\t\tip -6 route del local ::/0 dev lo table 100\n\tfi\n\t\t\n\tset -e\n\tset +x\n}\n\nconfigure_iptables() {\n\techo \"Configuring iptables and routing...\"\n\n\tset +e # Don't exit if got error\n\tset -x\n\t\n\tiptables -t raw -A PREROUTING ! -i lo -d 127.0.0.0/8 -j DROP\n\tiptables -t mangle -A POSTROUTING ! -o lo -s 127.0.0.0/8 -j DROP\n\n\tiptables -t nat -A OUTPUT -m owner --uid-owner sslh -p tcp --tcp-flags FIN,SYN,RST,ACK SYN  -j CONNMARK --set-xmark 0x01/0x0f\n\tiptables -t mangle -A OUTPUT ! -o lo -p tcp -m connmark --mark 0x01/0x0f -j CONNMARK --restore-mark --mask 0x0f\n\n\tip rule add fwmark 0x1 lookup 100\n\tip route add local 0.0.0.0/0 dev lo table 100\n\n\tif [ $(cat /proc/sys/net/ipv6/conf/all/disable_ipv6) -eq 0 ]; then\n\t\tip6tables -t raw -A PREROUTING ! -i lo -d ::1/128 -j DROP\n\t\tip6tables -t mangle -A POSTROUTING ! -o lo -s ::1/128 -j DROP\n\t\tip6tables -t nat -A OUTPUT -m owner --uid-owner sslh -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -j CONNMARK --set-xmark 0x01/0x0f\n\t\tip6tables -t mangle -A OUTPUT ! -o lo -p tcp -m connmark --mark 0x01/0x0f -j CONNMARK --restore-mark --mask 0x0f\n\n\t\tip -6 rule add fwmark 0x1 lookup 100\n\t\tip -6 route add local ::/0 dev lo table 100\n\tfi\n\t\n\tset -e\n\tset +x\n}\n\nfor _args in \"${@}\" ; do\n\tif [ \"${_args:-}\" = '--transparent' ] ; then\n\t\techo '--transparent flag is set'\n\t\tconfigure_iptables\n\t\ttrap unconfigure_iptables TERM INT KILL\n\t\tbreak\n\tfi\ndone\n\n# Drop privileges and run as sslh user\nsslh_cmd=\"${entrypoint:+${bin}} ${@}\"\necho \"Executing with user 'sslh': ${sslh_cmd}\"\n\nexec su - sslh -c \"${sslh_cmd}\" &\nwait \"${!}\"\n\nexit 0\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "echo_test.cfg",
          "type": "blob",
          "size": 0.1591796875,
          "content": "\n# TODO: c2s does not warn if udp: 1 (instead of 'true')\n\nudp: true;\n\nprefix: \"hello\";\n\nlisten: \"localhost:9000\";\n\nlisten-host: \"localhost\";\nlisten-port: \"9000\";\n\n"
        },
        {
          "name": "echosrv-conf.c",
          "type": "blob",
          "size": 39.205078125,
          "content": "/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)\n * on Sun Dec 22 22:40:51 2024. \n\n# conf2struct: generate libconf parsers that read to structs\n# Copyright (C) 2018-2024  Yves Rutschle\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#define _GNU_SOURCE\n#include <string.h>\n#ifdef LIBCONFIG\n#    include <libconfig.h>\n#endif\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <setjmp.h>\n#include \"echosrv-conf.h\"\n#include \"argtable3.h\"\n#ifdef LIBPCRE\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\ntypedef struct {\n    PCRE2_SIZE rm_so;\n    PCRE2_SIZE rm_eo;\n} regmatch_t;\n#else\n#include <regex.h>\n#endif\n\n\n/* This gets included in the output .c file */\n\n\n/* Libconfig 1.4.9 is still used by major distributions\n * (e.g. CentOS7) and had a different name for\n * config_setting_lookup */\n#if LIBCONFIG_VER_MAJOR == 1\n#if LIBCONFIG_VER_MINOR == 4\n#if LIBCONFIG_VER_REVISION == 9\n#define config_setting_lookup config_lookup_from\n#endif\n#endif\n#endif\n\n\n/* config_type, lookup_fns, type2str are related, keep them together */\ntypedef enum {\n    CFG_BOOL,\n    CFG_INT,\n    CFG_INT64,\n    CFG_FLOAT,\n    CFG_STRING,\n    CFG_GROUP,\n    CFG_ARRAY,\n    CFG_LIST,\n} config_type;\n/* /config_type */\n\nconst char* type2str[] = {\n    \"boolean\",\n    \"int\",\n    \"int64\",\n    \"float\",\n    \"string\",\n    \"group\",\n    \"array\",\n    \"list\",\n};\n\ntypedef union {\n    int def_bool;\n    int def_int;\n    long long def_int64;\n    double def_float;\n    char* def_string;\n} any_val;\n\nstruct config_desc {\n    const char* name;\n    int type;\n    struct config_desc * sub_group; /* Table for compound types (list and group) */\n    void* arg_cl; /* command-line argument for this setting */\n    void* base_addr; /* Base of the structure (filled at runtime). Probably not useable for list elements */\n    size_t offset;  /* Offset of setting in the structure */\n    size_t offset_len; /* Offset of *_len field, for arrays and lists */\n    size_t offset_present; /* offset of *_is_present field, for optional settings */\n    size_t size;   /* Size of element, or size of group for groups and lists */\n    int array_type; /* type of array elements, when type == CFG_ARRAY */\n    int mandatory;\n    int optional;\n    any_val default_val;\n};\n\n#ifndef LIBCONFIG\n/* Stubs in case you don't want libconfig */\n\ntypedef void config_setting_t;\ntypedef int config_t;\n#define CONFIG_TRUE 1\n#define CONFIG_FALSE 0\n\n#define make_config_setting_lookup(type) \\\n    int config_setting_lookup_##type(const config_setting_t* a, const char* b, void* c) { \\\n        return 0; \\\n    }\n\n#define make_config_setting_get(type, ret_type) \\\n    ret_type config_setting_get_##type(const config_setting_t* a) { \\\n        return 0; \\\n    }\n\nenum {\n    CONFIG_TYPE_INT,\n    CONFIG_TYPE_BOOL,\n    CONFIG_TYPE_INT64,\n    CONFIG_TYPE_FLOAT,\n    CONFIG_TYPE_STRING\n};\n\nmake_config_setting_lookup(bool);\nmake_config_setting_lookup(int);\nmake_config_setting_lookup(int64);\nmake_config_setting_lookup(float);\nmake_config_setting_lookup(string);\n\nmake_config_setting_get(bool, int);\nmake_config_setting_get(int, int);\nmake_config_setting_get(int64, long long int);\nmake_config_setting_get(float, double);\nmake_config_setting_get(string, char*);\n\nconfig_setting_t* config_root_setting(config_t* c) {\n    return NULL;\n}\n\nconfig_setting_t* config_lookup(config_t* c, const char* b) {\n    return NULL;\n}\n\nvoid config_init(config_t* c) {\n    return;\n}\n\nchar* config_setting_name(config_setting_t* c) {\n    return NULL;\n}\n\nint config_setting_is_list(config_setting_t* c) {\n    return 0;\n}\n\nint config_setting_is_array(config_setting_t* c) {\n    return 0;\n}\n\nint config_setting_is_scalar(config_setting_t* c) {\n    return 0;\n}\n\nint config_setting_index(const config_setting_t *setting) {\n    return 0;\n}\n\nconfig_setting_t* config_setting_lookup(config_setting_t* a, char* b) {\n    return NULL;\n}\n\nint config_setting_remove(config_setting_t* cfg, char* name) {\n    return 0;\n}\n\nint config_setting_type(config_setting_t* s) {\n    return -1;\n}\n\nint config_setting_length(config_setting_t* a) {\n    return 0;\n}\n\nconfig_setting_t* config_setting_get_elem(config_setting_t* a, int i) {\n    return NULL;\n}\n\nint config_read_file(config_t* a, const char* b) {\n    return CONFIG_TRUE;\n}\n\nint config_error_line(config_t* c) {\n    return 0;\n}\n\nchar* config_error_text(config_t* c) {\n    return NULL;\n}\n#endif\n\nstatic jmp_buf c2s_asprintf_fail;\n\nstatic int c2s_asprintf(char **restrict strp, const char *restrict fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap,fmt);\n    int res = vasprintf(strp, fmt, ap);\n    va_end(ap);\n    if (res == -1) longjmp(c2s_asprintf_fail, res);\n    return res;\n}\n\n/* This is the same as config_setting_lookup_string() except\nit allocates a new string which belongs to the caller */\nstatic int myconfig_setting_lookup_stringcpy(\n        const config_setting_t* setting, \n        const char* name, \n        char** value)\n{\n    const char* str;\n    *value = NULL;\n    if (config_setting_lookup_string(setting, name, &str) == CONFIG_TRUE) {\n        c2s_asprintf(value, \"%s\", str);\n        return CONFIG_TRUE;\n    } else {\n        return CONFIG_FALSE;\n    }\n}\n\ntypedef int (*lookup_fn)(const config_setting_t*, const char*, void*);\nlookup_fn lookup_fns[] = {\n    (lookup_fn)config_setting_lookup_bool,\n    (lookup_fn)config_setting_lookup_int,\n    (lookup_fn)config_setting_lookup_int64,\n    (lookup_fn)config_setting_lookup_float,\n    (lookup_fn)myconfig_setting_lookup_stringcpy,\n    NULL,  /* CFG_GROUP */\n    NULL,  /* CFG_ARRAY */\n    NULL,  /* CFG_LIST */\n};\n\n/* Copy an any_val to arbitrary memory location */\n/* 0: success\n * <0: error */\nstatic int any_valcpy(config_type type, void* target, any_val val)\n{\n    switch(type) {\n    case CFG_BOOL:\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        *(double*)target = val.def_float;\n        break;\n\n    case CFG_STRING:\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 1;\n}\n\n\n/* Copy the value of a setting to an arbitrary memory that\n* must be large enough */\n/* 0: success\n * <0: error */\nstatic int settingcpy(config_type type, void* target, const config_setting_t* setting)\n{\n    any_val val;\n    char* str;\n\n    switch(type) {\n    case CFG_BOOL:\n        val.def_bool = config_setting_get_bool(setting);\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        val.def_int = config_setting_get_int(setting);\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        val.def_int64 = config_setting_get_int64(setting);\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        val.def_float = config_setting_get_float(setting);\n        *(double*)target = val.def_int64;\n        break;\n\n    case CFG_STRING:\n        c2s_asprintf(&str, \"%s\", config_setting_get_string(setting));\n        val.def_string = str;\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 0;\n}\n\n/* Copy the value of a command line arg to arbitrary memory\n* that must be large enough for the type */\n/* 0: success\n * <0: error */\nstatic int clcpy(config_type type, void* target, const void* cl_arg)\n{\n    any_val val;\n    char* str;\n\n    switch(type) {\n    case CFG_BOOL:\n        val.def_bool = (*(struct arg_lit**)cl_arg)->count;\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        val.def_int = (*(struct arg_int**)cl_arg)->ival[0];\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        val.def_int64 = (*(struct arg_int**)cl_arg)->ival[0];\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        val.def_float = (*(struct arg_dbl**)cl_arg)->dval[0];\n        *(double*)target = val.def_float;\n        break;\n\n    case CFG_STRING:\n        c2s_asprintf(&str, \"%s\", (*(struct arg_str**)cl_arg)->sval[0]);\n        val.def_string = str;\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 0;\n}\n\n/* Copy the value of a string argument to arbitary memory\n* location that must be large enough, converting on the way\n* (i.e. CFG_INT gets atoi() and so on) */\n/* 0: success\n * <0: error */\nstatic int stringcpy(config_type type, void* target, char* from)\n{\n    any_val val;\n    \n    switch(type) {\n    case CFG_BOOL:\n        val.def_bool = (*from != '0');\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        val.def_int = strtol(from, NULL, 10);\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        val.def_int64 = strtoll(from, NULL, 10);\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        val.def_float = strtod(from, NULL);\n        *(double*)target = val.def_float;\n        break;\n\n    case CFG_STRING:\n        val.def_string = from;\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 0;\n}\n\n\n/* Element to describe the target of a compound element\n* element: which config entry is being changed\n* match: if >0, index in pmatch to set\n*        if 0, don't match but init with value\n* value: constant if not matching */\nstruct compound_cl_target {\n    struct config_desc * element;\n    int match;\n    any_val value;\n};\n\n/* Element to describe one compound command line argument\n * An argument is string that gets matched against a regex,\n * then match-groups get evaluated to each targets[].\n * For lists, base_entry points to the config_setting so we\n * can append to it */\nstruct compound_cl_arg {\n    const char* regex;\n    struct arg_str** arg_cl; /* arg_str entry for this compound option */\n    struct config_desc * base_entry;\n    struct compound_cl_target* targets;\n\n    /* If override_desc is set, it points to the descriptor of the element in\n    the group which will be checked for override. Then, override_matchindex\n    indicates the command-line parameter match used to compare against\n    override_desc to know if this group is overridden. If override_matchindex\n    is 0, we don't match from the command-line but from a constant stored in\n    override_const instead */\n    struct config_desc * override_desc;\n    int override_matchindex;\n    char* override_const;\n};\n\n\nstruct arg_file* echocfg_conffile;\n struct arg_lit* echocfg_udp;\n struct arg_str* echocfg_prefix;\n struct arg_str* echocfg_listen_host;\n struct arg_str* echocfg_listen_port;\n \tstruct arg_str* echocfg_listen;\n struct arg_end* echocfg_end;\n\n                          \nstatic struct config_desc table_echocfg_listen[] = {\n\n\n        { \n            /* name */          \"host\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & echocfg_listen_host,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct echocfg_listen_item, host),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"port\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & echocfg_listen_port,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct echocfg_listen_item, port),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\t{ 0 }\n};\n                   \nstatic struct config_desc table_echocfg[] = {\n\n\n        { \n            /* name */          \"udp\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & echocfg_udp,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct echocfg_item, udp),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"prefix\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & echocfg_prefix,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct echocfg_item, prefix),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"listen\", \n            /* type */          CFG_LIST, \n            /* sub_group*/      table_echocfg_listen,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct echocfg_item, listen),\n            /* offset_len */    offsetof(struct echocfg_item, listen_len),\n            /* offset_present */ 0,\n            /* size */          sizeof(struct echocfg_listen_item), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\t{ 0 }\n};\nstatic struct compound_cl_target echocfg_listen_targets [] = {\n\t{ & table_echocfg_listen[0], 1, .value.def_string = \"0\" },\n\t{ & table_echocfg_listen[1], 2, .value.def_string = \"0\" },\n\t{ 0 }\n};\n\nstatic struct compound_cl_arg compound_cl_args[] = {\n        {   /* arg: listen */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & echocfg_listen,\n            .base_entry =      & table_echocfg [2],\n            .targets =         echocfg_listen_targets,\n\n\n            .override_desc =   NULL,\n            .override_matchindex = 0,\n            .override_const = NULL,\n        },\n\n\t{ 0 }\n};\n\n\n/* Enable debug to follow the parsing of tables */\n#if 0\n#define TRACE_READ(x) printf x\n#define TRACE_READ_PRINT_SETTING 1\n#else\n#define TRACE_READ(x)\n#define TRACE_READ_PRINT_SETTING 0\n#endif\n\n/* Enable debug to follow the parsing of compound options */\n#if 0\n#define TRACE_CMPD(x) printf x\n#define TRACE_CMPD_PRINT_SETTING 1\n#else\n#define TRACE_CMPD(x)\n#define TRACE_CMPD_PRINT_SETTING 0\n#endif\n\nstatic void print_setting(config_type type, void* val)\n{\n    if (TRACE_READ_PRINT_SETTING || TRACE_CMPD_PRINT_SETTING) {\n        switch(type) {\n        case CFG_BOOL:\n        case CFG_INT:\n            printf(\"%d\", *(int*)val);\n            break;\n        case CFG_INT64:\n            printf(\"%lld\", *(long long*)val);\n            break;\n        case CFG_FLOAT:\n            printf(\"%f\", *(double*)val);\n            break;\n        case CFG_STRING:\n            printf(\"`%s'\", *(char**)val);\n            break;\n        case CFG_GROUP:\n        case CFG_LIST:\n        case CFG_ARRAY:\n            break;\n        }\n    }\n}\n\n/* Changes all dashes to underscores in a string of\n* vice-versa */\nstatic void strswap_ud(const char target, char* str)\n{\n    char* c;\n    for (c = str; *c; c++)\n        if (*c == (target == '_' ? '-' : '_'))\n             *c = (target == '_' ? '_' : '-');\n}\n\n/* Same as config_setting_lookup() but looks up with dash or\n* underscore so `my_setting` and `my-setting` match the same */\nstatic config_setting_t* config_setting_lookup_ud(config_setting_t* cfg, struct config_desc* desc)\n{\n    config_setting_t* setting;\n    char name[strlen(desc->name)+1];;\n    strcpy(name, desc->name);\n\n    strswap_ud('_', name);\n    setting = config_setting_lookup(cfg, name);\n    if (setting)\n        return setting;\n\n    strswap_ud('-', name);\n    setting = config_setting_lookup(cfg, name);\n    return setting;\n}\n\nstatic int lookup_typed_ud(config_setting_t* cfg, void* target, struct config_desc *desc)\n{\n    lookup_fn lookup_fn = lookup_fns[desc->type];\n    char name[strlen(desc->name)+1];;\n    strcpy(name, desc->name);\n\n    strswap_ud('_', name);\n    if (lookup_fn(cfg, name, ((char*)target) + desc->offset) == CONFIG_TRUE)\n        return CONFIG_TRUE;\n\n    strswap_ud('-', name);\n    return lookup_fn(cfg, name, ((char*)target) + desc->offset);\n}\n\n/* Removes a setting, trying both underscores and dashes as\n* name (so deleting 'my-setting' deletes both 'my_setting'\n* and 'my-setting') */\nstatic int setting_delete_ud(config_setting_t* cfg, struct config_desc *desc)\n{\n    char name[strlen(desc->name)+1];;\n    strcpy(name, desc->name);\n\n    strswap_ud('_', name);\n    if (config_setting_remove(cfg, name) == CONFIG_TRUE)\n        return CONFIG_TRUE;\n\n    strswap_ud('-', name);\n    return config_setting_remove(cfg, name);\n}\n\n/* When traversing configuration, allocate memory for plural\n* types, init for scalars */\nstatic void read_block_init(void* target, config_setting_t* cfg, struct config_desc* desc)\n{\n    size_t len = 0;\n    void* block;\n    config_setting_t* setting;\n\n    switch (desc->type) {\n    case CFG_LIST:\n    case CFG_ARRAY:\n        if (cfg) {\n            setting = config_setting_lookup_ud(cfg, desc);\n            if (setting)\n                len = config_setting_length(setting);\n        } \n        block = calloc(len, desc->size);\n\n        *(size_t*)(((char*)target) + desc->offset_len) = len;\n        *(void**)(((char*)target) + desc->offset) = block;\n        TRACE_READ((\" sizing for %zu elems \", len));\n        break;\n\n    case CFG_GROUP:\n        block = calloc(1, desc->size);\n        *(void**)(((char*)target) + desc->offset) = block;\n        TRACE_READ((\" sizing for %zu elems \", len));\n        break;\n\n    default: \n        /* scalar types: copy default */\n        memcpy(((char*)target) + desc->offset, &desc->default_val, desc->size);\n        TRACE_READ((\"setting %s to default \", desc->name));\n        print_setting(desc->type,(char*)target + desc->offset);\n        break;\n    }\n}\n\nstatic int read_block(config_setting_t* cfg, \n                      void* target, \n                      struct config_desc* desc, \n                      char** errmsg);\n\n/* When traversing configuration, set value from config\n* file, or command line \n* return: 0 if not set, 1 if set somehow */\nstatic int read_block_setval(void* target, \n                             config_setting_t* cfg, \n                             struct config_desc* desc, \n                             char** errmsg)\n{\n    int i;\n    size_t len = 0;\n    void* block;\n    int in_cfg = 0, in_cl = 0; /* Present in config file?  present on command line? */\n    config_setting_t* setting = NULL;\n\n    switch (desc->type) {\n    case CFG_LIST:\n        if (cfg) {\n            setting = config_setting_lookup_ud(cfg, desc);\n            if (setting) \n                len = config_setting_length(setting);\n            block = *(void**)(((char*)target) + desc->offset);\n            for (i = 0; i < len; i++) {\n                config_setting_t* elem = config_setting_get_elem(setting, i);\n                if (!read_block(elem, (char*)block + desc->size * i, desc->sub_group, errmsg))\n                    return 0;\n            }\n        }\n        break;\n\n    case CFG_ARRAY:\n        if (cfg) {\n            setting = config_setting_lookup_ud(cfg, desc);\n            if (setting)\n                len = config_setting_length(setting);\n            block = *(void**)(((char*)target) + desc->offset);\n            for (i = 0; i < len; i++) {\n                config_setting_t* elem = config_setting_get_elem(setting, i);\n                settingcpy(desc->array_type, (char*)block + desc->size * i, elem);\n                TRACE_READ((\"[%d] = \", i));\n                print_setting(desc->array_type, (char*)block + desc->size *i); TRACE_READ((\"\\n\"));\n            }\n            setting_delete_ud(cfg, desc);\n        }\n        break;\n\n    case CFG_GROUP:\n        if (cfg) setting = config_setting_lookup_ud(cfg, desc);\n        block = *(void**)(((char*)target) + desc->offset);\n        if (!read_block(setting, block, desc->sub_group, errmsg)) return 0;\n        break;\n\n    default: /* scalar types */\n        TRACE_READ((\" `%s'\", desc->name));\n        if (cfg && config_setting_lookup_ud(cfg, desc)) {\n            TRACE_READ((\" in config file: \"));\n            /* setting is present in cfg, look it up */\n            if (lookup_typed_ud(cfg, target, desc) != CONFIG_TRUE) {\n                TRACE_READ((\" but wrong type (expected %s) \", type2str[desc->type]));\n                c2s_asprintf(errmsg, \"Option \\\"%s\\\" wrong type, expected %s\\n\", \n                    desc->name, type2str[desc->type]);\n                return 0;\n            }\n            print_setting(desc->type, (((char*)target) + desc->offset));\n            setting_delete_ud(cfg, desc);\n            in_cfg = 1;\n        } else {\n            TRACE_READ((\" not in config file\"));\n        }\n        if (desc->arg_cl && (*(struct arg_int**)desc->arg_cl)->count) {\n            clcpy(desc->type, ((char*)target) + desc->offset, desc->arg_cl);\n            TRACE_READ((\", command line sets to \"));\n            print_setting(desc->type, (((char*)target) + desc->offset));\n            in_cl = 1;\n        } else {\n            TRACE_READ((\", not in command line\"));\n        }\n        if (!(in_cfg || in_cl)) {\n            TRACE_READ((\"\\n\"));\n            return 0;\n        }\n        TRACE_READ((\"\\n\"));\n        break;\n    }\n    return 1;\n}\n\n/* Set *_is_present flag for target */\nstatic void target_is_present(void* target, struct config_desc* desc, int val)\n{\n    if (desc->optional) {  /* _is_present only exists in target for optional settings */\n        TRACE_READ((\" mark as set\"));\n        *(int*)((char*)target + desc->offset_present) = val;\n    }\n}\n\n/* traverses the configuration; allocates memory if needed,\n* set to default if exists,\n* fill from configuration file if present, overrides or set from\n* command line if present, verifies mandatory options have\n* been set\n* target: base address of the group being processed\n*/\nstatic int read_block(config_setting_t* cfg, void* target, struct config_desc* desc, char** errmsg)\n{\n    int set;\n\n    for (; desc->name; desc++) {\n        TRACE_READ((\"reading %s%s%s: \", desc->optional ? \"optional \" : \"\", desc->mandatory ? \"mandatory \" : \"\",  desc->name));\n        desc->base_addr = target;\n\n\n        read_block_init(target, cfg, desc);\n        set = read_block_setval(target, cfg, desc, errmsg);\n\n        if (!set && desc->mandatory) {\n            c2s_asprintf(errmsg, \"Mandatory option \\\"%s\\\" not found\", desc->name);\n            return 0;\n        }\n\n        if (desc->optional) target_is_present(target, desc, set && desc->optional);\n    }\n    return 1;\n}\n\n/* Copy regex match into newly allocated string\n * out: newly allocated string (caller has to free it)\n * in: string into which the match was made\n * pmatch: the match to extract */\nstatic void pmatchcpy(char** out, const char* in, regmatch_t* pmatch)\n{\n    int len = pmatch->rm_eo - pmatch->rm_so;\n    *out = calloc(len+1, 1);\n    memcpy(*out, in + pmatch->rm_so, len);\n}\n\n/* Processes a list of targets within one element, setting\n* the values in the target setting \n* target: where to put the data\n* arg: CL arg containing the target fields\n* clval: command line parameter\n* pmatch: regex match array into clval\n*/\nstatic int set_target_fields(void* target_addr, struct compound_cl_arg* arg, const char* clval, regmatch_t* pmatch)\n{\n    int pmatch_cnt = 1;\n    struct compound_cl_target* target;\n\n    for (target = arg->targets; target->element; target++) {\n        struct config_desc * element = target->element;\n        if (target->match) {\n            TRACE_CMPD((\"    match %d rm_so %d rm_eo %d type %d\\n\", \n                        pmatch_cnt, pmatch[pmatch_cnt].rm_so, pmatch[pmatch_cnt].rm_eo, element->type ));\n            if (pmatch[pmatch_cnt].rm_so == -1) {\n                /* This should not happen as regexec() did\n                * match before, unless there is a\n                * discrepency between the regex and the\n                * number of backreferences */\n                return 0;\n            }\n            char* str;\n            pmatchcpy(&str, clval, &pmatch[pmatch_cnt]);\n\n            stringcpy(element->type, (char*)target_addr + element->offset, str);\n            TRACE_CMPD((\"setting %p+%zu to : \", target_addr , element->offset));\n            print_setting(element->type , (char*)target_addr + element->offset);\n            TRACE_CMPD((\"\\n\"));\n\n            /* str is temporary buffer for type conversion, except for strings which we\n            * need to keep around so don't free them */\n            if (element->type != CFG_STRING)\n                free(str);\n            pmatch_cnt++;\n        } else { /* don't use matching, set constant */\n            any_valcpy(element->type, (char*)target_addr + element->offset,\n                        target->value);\n        }\n    }\n\n    return 1;\n}\n\n/* Goes over a list, finds if a group matches the specified string and overwrite\n* it if it does. */\nstatic int override_on_str(struct compound_cl_arg* arg, const char* str, regmatch_t* pmatch)\n{\n    struct config_desc * desc = arg->base_entry;\n    void* list_base = *(void**)(desc->base_addr + desc->offset);\n    size_t list_len = *(size_t*)(desc->base_addr + desc->offset_len);\n    size_t elem_size = desc->size;\n    int i;\n\n    for (i = 0; i < list_len; i++) {\n        char* group_base = ((char*)list_base + i * elem_size);\n\n        char* cfg_member = *(char**)(group_base + arg->override_desc->offset);\n        if (!strcmp(str, cfg_member)) {\n            memset(group_base, 0, elem_size);\n            struct arg_str* arg_cl = *arg->arg_cl;\n            if (!set_target_fields(group_base, arg, arg_cl->sval[0], pmatch))\n                return 0;\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Goes over a list and override group if needed */\nstatic int override_elem(struct compound_cl_arg* arg, int arg_index, regmatch_t* pmatch) \n{\n    char* str;\n    int allocated = 0;\n    int res;\n\n    if (arg->override_matchindex) {\n        struct arg_str* arg_cl = *arg->arg_cl;\n        pmatchcpy(&str, arg_cl->sval[arg_index], &pmatch[arg->override_matchindex]);\n        allocated = 1;\n    } else {\n        str = arg->override_const;\n    }\n\n    res = override_on_str(arg, str, pmatch);\n\n    if (allocated) free(str);\n\n    return res;\n}\n\n/* Add an argument to a list, overriding if required or\n* appending otherwise */\nstatic int add_arg_to_list(struct compound_cl_arg* arg, int arg_index, regmatch_t* pmatch)\n{\n    struct config_desc * desc = arg->base_entry;\n    void* list_base = *(void**)(desc->base_addr + desc->offset);\n    size_t list_len = *(size_t*)(desc->base_addr + desc->offset_len);\n    size_t elem_size = desc->size;\n\n    /* are we overriding an existing group? */\n    if (arg->override_desc)\n        if (override_elem(arg, arg_index, pmatch))\n            return 1;\n\n    /* override not found or no override, append element and * zero it out */\n    list_len++;\n    list_base = realloc(list_base, list_len * elem_size);\n    *(size_t*)(desc->base_addr + desc->offset_len) = list_len;\n    *(void**)(desc->base_addr + desc->offset) = list_base;\n    memset(list_base + (list_len - 1) * elem_size, 0, elem_size);\n\n    struct arg_str* arg_cl = *arg->arg_cl;\n    if (!set_target_fields((char*)list_base + (list_len - 1) * elem_size, arg, arg_cl->sval[arg_index], pmatch)) {\n        return 0;\n    }\n    return 1;\n}\n\n/* TODO: pass pmatch size as parameter or something */\n#define MAX_MATCH 10\n\n#ifndef LIBPCRE\nstatic int regcompmatch_posix( regmatch_t* pmatch, \n                        struct compound_cl_arg* arg, \n                        int arg_index, \n                        char** errmsg)\n{\n    char* regerr;\n    struct arg_str* arg_cl = *arg->arg_cl;\n    regex_t preg;\n    int res = regcomp(&preg, arg->regex, REG_EXTENDED);\n    if (res) {\n        int errlen = regerror(res, &preg, NULL, 0);\n        regerr = malloc(errlen);\n        regerror(res, &preg, regerr, errlen);\n        c2s_asprintf(errmsg, \"compiling pattern /%s/:%s\", arg->regex, regerr);\n        free(regerr);\n        return 0;\n    }\n    res = regexec(&preg, arg_cl->sval[arg_index], MAX_MATCH, &pmatch[0], 0);\n    if (res) {\n        c2s_asprintf(errmsg, \"--%s %s: Illegal argument\", \n        arg_cl->hdr.longopts, \n        arg->regex); \n        return 0;\n    }\n    return 1;\n}\n#endif\n\n\n#ifdef LIBPCRE\nstatic int regcompmatch_pcre2( regmatch_t* pmatch,\n                        struct compound_cl_arg* arg,\n                        int arg_index,\n                        char** errmsg)\n{\n    int i, error;\n    pcre2_code* pcre;\n    PCRE2_UCHAR8 err_str[120];  /* ample, according to pcre2api(3) */\n    pcre2_match_data* matches;\n    PCRE2_SIZE error_offset;\n    struct arg_str* arg_cl = *arg->arg_cl;\n\n    pcre = pcre2_compile((PCRE2_SPTR8)arg->regex, PCRE2_ZERO_TERMINATED, 0, &error, &error_offset, NULL);\n    if (!pcre) {\n        pcre2_get_error_message(error, err_str, sizeof(err_str));\n        c2s_asprintf(errmsg, \"compiling pattern /%s/:%d: %s at offset %ld\\n\",\n                arg->regex, error, err_str, error_offset);\n        return 0;\n    }\n\n    matches = pcre2_match_data_create(MAX_MATCH, NULL);\n    int res = pcre2_match(pcre, (PCRE2_SPTR8)arg_cl->sval[arg_index], PCRE2_ZERO_TERMINATED,\n                          0, 0, matches, NULL);\n    if (res < 0) {\n        pcre2_get_error_message(res, err_str, sizeof(err_str));\n        c2s_asprintf(errmsg, \"matching %s =~ /%s/:%d: %s\\n\", \n                          arg_cl->sval[arg_index], arg->regex, res, err_str);\n        return 0;\n    }\n\n    PCRE2_SIZE *ovec = pcre2_get_ovector_pointer(matches);\n    if (res > MAX_MATCH) res = MAX_MATCH;\n    /* From pcre2posix.c */\n    for (i = 0; i < res; i++) {\n        pmatch[i].rm_so = (ovec[i*2] == PCRE2_UNSET) ? -1 : ovec[i*2];\n        pmatch[i].rm_eo = (ovec[i*2+1] == PCRE2_UNSET) ? -1 : ovec[i*2+1];\n    }\n    for (; i < MAX_MATCH; i++) pmatch[i].rm_so = pmatch[i].rm_eo = -1;\n\n    pcre2_match_data_free(matches);\n    return 1;\n}\n#endif\n\n\n/* Regex fiddling: uses info in arg to fill pmatch\n* arg: description of the command line argument\n* arg_index: occurence of this argument on the command line\n*/\nstatic int regcompmatch(regmatch_t* pmatch,\n                        struct compound_cl_arg* arg,\n                        int arg_index,\n                        char** errmsg)\n{\n#if LIBPCRE\n    return regcompmatch_pcre2(pmatch, arg, arg_index, errmsg);\n#else\n    return regcompmatch_posix(pmatch, arg, arg_index, errmsg);\n#endif\n}\n\n/* Read compound options described in `arg`, from `cfg`, to `setting` */\nstatic int read_compounds(config_setting_t* cfg, \n                          void* setting, \n                          struct compound_cl_arg* arg, \n                          char** errmsg)\n{\n    int arg_i;\n    struct arg_str* arg_cl;\n    regmatch_t pmatch[MAX_MATCH];\n\n    for (; arg->regex; arg++) {\n        arg_cl = *arg->arg_cl;\n        TRACE_CMPD((\"Compound %s occurs %d : \", arg_cl->hdr.longopts, arg_cl->count));\n        for (arg_i = 0; arg_i < arg_cl->count; arg_i++) {\n            if (!regcompmatch(&pmatch[0], arg, arg_i, errmsg))\n                return 0;\n            TRACE_CMPD((\"`%s' matched\\n\", arg_cl->sval[arg_i]));\n\n            switch (arg->base_entry->type) {\n            case CFG_LIST:\n                /* In a list, find the end or the element to override */\n                if (!add_arg_to_list(arg, arg_i, pmatch)) {\n                    return 0;\n                }\n                break;\n\n            /* Semantics for CFG_ARRAY TBD */\n\n            case CFG_GROUP:\n                if (!set_target_fields(\n                            /* base_addr is the same for all elements in the group */\n                            arg->targets[0].element->base_addr, \n                            arg, \n                            arg_cl->sval[arg_i], \n                            pmatch))\n                    return 0;\n\n            default:\n                TRACE_CMPD((\"error, compound on type %d\\n\", arg->base_entry->type));\n                break;\n            }\n        }\n        TRACE_CMPD((\"done %s\\n\", arg_cl->hdr.longopts));\n    }\n    return 1;\n}\n\n/* read config file `filename` into `c` */\nstatic int c2s_parse_file(const char* filename, config_t* c, char**errmsg)\n{\n    /* Read config file */\n    if (config_read_file(c, filename) == CONFIG_FALSE) {\n        if (config_error_line(c) != 0) {\n           c2s_asprintf(errmsg, \"%s:%d:%s\", \n                    filename,\n                    config_error_line(c),\n                    config_error_text(c));\n           return 0;\n        }\n        c2s_asprintf(errmsg, \"%s:%s\", filename, config_error_text(c));\n        return 0;\n    }\n    return 1;\n}\n\n/* Allocates a new string that represents the setting value, which must be a scalar */\nstatic void scalar_to_string(char** strp, config_setting_t* s)\n{\n    switch(config_setting_type(s)) {\n    case CONFIG_TYPE_INT:\n        c2s_asprintf(strp, \"%d\\n\", config_setting_get_int(s));\n        break;\n\n    case CONFIG_TYPE_BOOL:\n        c2s_asprintf(strp, \"%s\\n\", config_setting_get_bool(s) ?  \"[true]\" : \"[false]\" );\n        break;\n\n    case CONFIG_TYPE_INT64:\n        c2s_asprintf(strp, \"%lld\\n\", config_setting_get_int64(s));\n        break;\n\n    case CONFIG_TYPE_FLOAT:\n        c2s_asprintf(strp, \"%lf\\n\", config_setting_get_float(s));\n        break;\n\n    case CONFIG_TYPE_STRING:\n        c2s_asprintf(strp, \"%s\\n\", config_setting_get_string(s));\n        break;\n\n    default: /* This means a bug */\n        fprintf(stderr, \"Unexpected type %d\\n\", config_setting_type(s));\n        exit(1);\n    }\n}\n\n/* Typesets all the settings in a configuration as a\n* newly-allocated string. The string management is caller's\n* responsability. \n* Returns the number of scalars in the configuration */\nstatic int cfg_as_string(config_setting_t* parent, const char* path, char** strp)\n{\n    int i, len, res = 0;\n    config_setting_t* child;\n    char* subpath, *value, *old;\n    const char* name;\n\n    len = config_setting_length(parent);\n    for (i = 0; i < len; i++) {\n        child = config_setting_get_elem(parent, i);\n        name = config_setting_name(child);\n        if (!name) name = \"\";\n\n        if(config_setting_is_list(parent) ||\n           config_setting_is_array(parent)) {\n            c2s_asprintf(&subpath, \"%s[%d]%s\", path, config_setting_index(child), name);\n        } else {\n            c2s_asprintf(&subpath, \"%s/%s\", path, name);\n        }\n\n        if (config_setting_is_scalar(child)) {\n            scalar_to_string(&value, child);\n\n            /* Add value to the output string  */\n            if (*strp) {\n                c2s_asprintf(&old, \"%s\", *strp);\n                free(*strp);\n            }  else {\n                c2s_asprintf(&old, \"%s\", \"\");\n            }\n            c2s_asprintf(strp, \"%s%s:%s\", old, subpath, value);\n            free(value);\n            free(old);\n\n            res++; /* At least one scalar was found */\n        } else {\n            /* It's an aggregate -- descend into it */\n            res += cfg_as_string(child, subpath, strp);\n        }\n\n        free(subpath);\n    }\n    return res;\n}\n\n\n/* 0: success\n   <0: error */\nint echocfg_cl_parse(int argc, char* argv[], struct echocfg_item* cfg)\n{\n    int nerrors, res;\n    config_t c;\n    char* errmsg;\n    config_setting_t* s;\n    void* argtable[] = {\n            #ifdef LIBCONFIG\n        echocfg_conffile = arg_filen(\"F\", \"config\", \"<file>\", 0, 1, \"Specify configuration file\"),\n    #endif\n         echocfg_udp = arg_litn(NULL, \"udp\", 0, 1, \"\"),\n         echocfg_prefix = arg_strn(NULL, \"prefix\", \"<str>\", 0, 1, \"\"),\n         echocfg_listen_host = arg_strn(NULL, \"listen-host\", \"<str>\", 0, 10, \"\"),\n         echocfg_listen_port = arg_strn(NULL, \"listen-port\", \"<str>\", 0, 10, \"\"),\n \techocfg_listen = arg_strn(\"p\", \"listen\", \"<host:port>\", 0, 10, \"Listen on host:port\"),\n \techocfg_end = arg_end(10)\n\n    };\n\n    /* Set up failure handler in case asprintf() runs out of\n    * memory */\n    ;\n    if (setjmp(c2s_asprintf_fail)) {\n        fprintf(stderr, \"asprintf: probably out of memory\\n\");\n        return -1;\n    }\n\n    /* Parse command line */\n    nerrors = arg_parse(argc, argv, argtable);\n    if (nerrors) {\n        arg_print_errors(stdout, echocfg_end, \"echocfg\"); \n        arg_print_syntax(stdout, argtable, \"\\n\");\n        arg_print_glossary(stdout, argtable, \"  %-25s\\t%s\\n\");\n        return -1;\n    }\n\n\n    config_init(&c);\n    if (echocfg_conffile && echocfg_conffile->count) {\n        if (!c2s_parse_file(echocfg_conffile->filename[0], &c, &errmsg)) {\n            fprintf(stderr, \"%s\\n\", errmsg);\n            return -1;\n        }\n    }\n\n    s = config_root_setting(&c);\n\n    res = read_block(s, cfg, table_echocfg, &errmsg);\n    if (!res) {\n        fprintf(stderr, \"%s\\n\", errmsg);\n        return -1;\n    }\n\n    res = read_compounds(s, cfg, compound_cl_args, &errmsg);\n    if (!res) {\n        fprintf(stderr, \"%s\\n\", errmsg);\n        return -1;\n    }\n\n    errmsg = NULL;\n    res = cfg_as_string(s, \"\", &errmsg);\n    if (res)\n        fprintf(stderr, \"Unknown settings:\\n%s\\n\", errmsg);\n\n    return 0;\n}\n\n\nstatic void indent(FILE* out, int depth) \n{\n    int i;\n    for (i = 0; i < depth; i++)\n        fprintf(out, \"    \");\n}\n\nstatic void echocfg_listen_fprint(\n        FILE* out,\n        struct echocfg_listen_item* echocfg_listen,\n        int depth) \n{\n    \n        indent(out, depth);\n        fprintf(out, \"host: %s\", echocfg_listen->host);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"port: %s\", echocfg_listen->port);\n        fprintf(out, \"\\n\");\n}\n\nvoid echocfg_fprint(\n        FILE* out,\n        struct echocfg_item* echocfg,\n        int depth) \n{\n    int i;\n        indent(out, depth);\n        fprintf(out, \"udp: %d\", echocfg->udp);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"prefix: %s\", echocfg->prefix);\n        fprintf(out, \"\\n\");\n\n        indent(out, depth);\n        fprintf(out, \"listen [%zu]:\\n\", echocfg->listen_len);\n        for (i = 0; i < echocfg->listen_len; i++) {\n            echocfg_listen_fprint(out, &echocfg->listen[i], depth+1);\n        }\n}\n"
        },
        {
          "name": "echosrv-conf.h",
          "type": "blob",
          "size": 2.0517578125,
          "content": "/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)\n * on Sun Dec 22 22:40:51 2024. \n\n# conf2struct: generate libconf parsers that read to structs\n# Copyright (C) 2018-2024  Yves Rutschle\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n*/\n \n#ifndef C2S_ECHOCFG_H\n#define C2S_ECHOCFG_H\n#ifdef LIBCONFIG\n#    include <libconfig.h>\n#endif\n\n\n\nstruct echocfg_listen_item {\n\tchar*\thost;\n\tchar*\tport;\n};\n\nstruct echocfg_item {\n\tint\tudp;\n\tchar*\tprefix;\n\tsize_t\tlisten_len;\n\tstruct echocfg_listen_item* listen;\n};\n\nint echocfg_parse_file(\n        const char* filename,\n        struct echocfg_item* echocfg, \n        const char** errmsg);\n\nvoid echocfg_fprint(\n    FILE* out,\n    struct echocfg_item *echocfg,\n    int depth);\n\nint echocfg_cl_parse(\n    int argc,\n    char* argv[],\n    struct echocfg_item *echocfg);\n\n#endif\n"
        },
        {
          "name": "echosrv.c",
          "type": "blob",
          "size": 8.990234375,
          "content": "/* echosrv: a simple line echo server with optional prefix adding.\n *\n * echosrv --listen localhost6:1234 --prefix \"ssl: \"\n *\n * This will bind to 1234, and echo every line pre-pending \"ssl: \". This is\n * used for testing: we create several such servers with different prefixes,\n * then we connect test clients that can then check they get the proper data\n * back (thus testing that shoveling works both ways) with the correct prefix\n * (thus testing it connected to the expected service).\n * **/\n\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <fcntl.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <signal.h>\n#include <sys/socket.h>\n#include <sys/wait.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <pwd.h>\n#include <syslog.h>\n#include <libgen.h>\n#include <getopt.h>\n#include <errno.h>\n\n#define cfg sslhcfg\n#include \"common.h\"\n#undef cfg\n\n#include \"echosrv-conf.h\"\n\n/* Added to make the code compilable under CYGWIN \n * */\n#ifndef SA_NOCLDWAIT\n#define SA_NOCLDWAIT 0\n#endif\n\nstruct echocfg_item cfg;\n\nvoid check_res_dump(int res, struct addrinfo *addr, char* syscall)\n{\n    char buf[NI_MAXHOST];\n\n    if (res == -1) {\n        if (addr)\n            fprintf(stderr, \"error %s:%s: %s\\n\",\n                    sprintaddr(buf, sizeof(buf), addr),\n                    syscall,\n                    strerror(errno));\n        else \n            fprintf(stderr, \"Dying just because\\n\");\n\n        exit(1);\n    }\n}\n\nvoid start_echo(int fd)\n{\n    ssize_t res;\n    char buffer[1 << 20];\n    ssize_t ret;\n    size_t prefix_len;\n    int first = 1;\n\n    prefix_len = strlen(cfg.prefix);\n\n    memset(buffer, 0, sizeof(buffer));\n    strcpy(buffer, cfg.prefix);\n\n    while (1) {\n        ret = read(fd, buffer + prefix_len, sizeof(buffer) - prefix_len);\n        if (ret <= 0) {\n            fprintf(stderr, \"%s\", strerror(errno));\n            return;\n        }\n        if (first) {\n            res = write(fd, buffer, ret + prefix_len);\n            first = 0;\n            if (write(1, buffer, ret + prefix_len) < 0) {\n                fprintf(stderr, \"%s\", strerror(errno));\n            }\n        } else {\n            res = write(fd, buffer + prefix_len, ret);\n        }\n        if (res < 0) {\n            fprintf(stderr, \"%s\", strerror(errno));\n            return;\n        }\n    }\n}\n\n/* TCP echo server: accepts connections to an endpoint, forks an echo for each\n * connection, forever. Prefix is added at start of response stream */\nvoid tcp_echo(struct listen_endpoint* listen_socket)\n{\n    while (1) {\n        int in_socket = accept(listen_socket->socketfd, 0, 0);\n        if (in_socket == -1) {\n            perror(\"tcp_echo:accept\");\n            exit(1);\n        }\n\n        if (!fork())\n        {\n            close(listen_socket->socketfd);\n            start_echo(in_socket);\n            exit(0);\n        }\n        close(in_socket);\n        waitpid(-1, NULL, WNOHANG);\n    }\n}\n\nvoid print_udp_xchange(int sockfd, struct sockaddr* addr, socklen_t addrlen)\n{\n    struct addrinfo src_addrinfo, to_addrinfo;\n    char str_addr[NI_MAXHOST+1+NI_MAXSERV+1];\n    char str_addr2[NI_MAXHOST+1+NI_MAXSERV+1];\n    struct sockaddr_storage ss;\n\n    src_addrinfo.ai_addr = (struct sockaddr*)&ss;\n    src_addrinfo.ai_addrlen = sizeof(ss);\n    getsockname(sockfd, src_addrinfo.ai_addr, &src_addrinfo.ai_addrlen);\n\n    to_addrinfo.ai_addr = addr;\n    to_addrinfo.ai_addrlen = sizeof(*addr);\n\n    fprintf(stderr, \"UDP local %s remote %s\\n\", \n            sprintaddr(str_addr, sizeof(str_addr), &src_addrinfo),\n            sprintaddr(str_addr2, sizeof(str_addr2), &to_addrinfo)\n           );\n}\n\n/* UDP echo server: receive packets, return them, forever.\n * Prefix is added at each packet */\nvoid udp_echo(struct listen_endpoint* listen_socket)\n{\n    char data[65536];\n    struct sockaddr src_addr;\n    socklen_t addrlen;\n\n    memset(data, 0, sizeof(data));\n\n    size_t prefix_len = strlen(cfg.prefix);\n    memcpy(data, cfg.prefix, prefix_len);\n\n    while (1) {\n        addrlen = sizeof(src_addr);\n        ssize_t len = recvfrom(listen_socket->socketfd,\n                           data + prefix_len,\n                           sizeof(data) - prefix_len,\n                           0,\n                           &src_addr,\n                           &addrlen);\n\n        if (len < 0) {\n            perror(\"recvfrom\");\n        }\n        *(data + prefix_len + len) = 0;\n        fprintf(stderr, \"%zd %s\\n\", len, data + prefix_len);\n\n        print_udp_xchange(listen_socket->socketfd, &src_addr, addrlen);\n\n        ssize_t res = sendto(listen_socket->socketfd,\n                         data,\n                         len + prefix_len,\n                         0,\n                         &src_addr,\n                         addrlen);\n        if (res < 0) {\n            perror(\"sendto\");\n        }\n    }\n}\n\nvoid main_loop(struct listen_endpoint listen_sockets[], int num_addr_listen)\n{\n    int i;\n\n    for (i = 0; i < num_addr_listen; i++) {\n        if (!fork()) {\n            if (cfg.udp) {\n                udp_echo(&listen_sockets[i]);\n            } else {\n                tcp_echo(&listen_sockets[i]);\n            }\n        }\n    }\n    wait(NULL);\n}\n\n/* Following is a number of utility functions copied from common.c: linking\n * against common.o directly means echosrv has to work with sslh config struct,\n * which makes it all too awkward */\n\n/* simplified from common.c */\nchar* sprintaddr(char* buf, size_t size, struct addrinfo *a)\n{\n   char host[NI_MAXHOST], serv[NI_MAXSERV];\n   int res;\n\n   res = getnameinfo(a->ai_addr, a->ai_addrlen,\n               host, sizeof(host),\n               serv, sizeof(serv),\n               0 );\n\n   if (res) {\n       /* Name resolution failed: do it numerically instead */\n       res = getnameinfo(a->ai_addr, a->ai_addrlen,\n                         host, sizeof(host),\n                         serv, sizeof(serv),\n                         NI_NUMERICHOST | NI_NUMERICSERV);\n       /* should not fail but... */\n       if (res) {\n           strcpy(host, \"?\");\n           strcpy(serv, \"?\");\n       }\n   }\n\n   snprintf(buf, size, \"%s:%s\", host, serv);\n\n   return buf;\n}\n\n\n/* simplified from common.c */\nint listen_single_addr(struct addrinfo* addr, int keepalive, int udp)\n{\n    struct sockaddr_storage *saddr;\n    int sockfd, one, res;\n\n    saddr = (struct sockaddr_storage*)addr->ai_addr;\n\n    sockfd = socket(saddr->ss_family, udp ? SOCK_DGRAM : SOCK_STREAM, 0);\n    check_res_dump(sockfd, addr, \"socket\");\n\n    one = 1;\n    res = setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (char*)&one, sizeof(one));\n    check_res_dump(res, addr, \"setsockopt(SO_REUSEADDR)\");\n\n    if (addr->ai_addr->sa_family == AF_INET6) {\n        res = setsockopt(sockfd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&one, sizeof(one));\n        check_res_dump(res, addr, \"setsockopt(IPV6_V6ONLY)\");\n    }\n\n    res = bind(sockfd, addr->ai_addr, addr->ai_addrlen);\n    check_res_dump(res, addr, \"bind\");\n\n    if (!udp) {\n        res = listen (sockfd, 50);\n        check_res_dump(res, addr, \"listen\");\n    }\n\n    return sockfd;\n}\n\n/* simplified from common.c */\nint resolve_split_name(struct addrinfo **out, char* host, char* serv)\n{\n   struct addrinfo hint;\n   char *end;\n   int res;\n\n   memset(&hint, 0, sizeof(hint));\n   hint.ai_family = PF_UNSPEC;\n   hint.ai_socktype = SOCK_STREAM;\n\n   /* If it is a RFC-Compliant IPv6 address (\"[1234::12]:443\"), remove brackets\n    * around IP address */\n   if (host[0] == '[') {\n       end = strrchr(host, ']');\n       if (!end) {\n           fprintf(stderr, \"%s: no closing bracket in IPv6 address?\\n\", host);\n           return -1;\n       }\n       host++; /* skip first bracket */\n       *end = 0; /* remove last bracket */\n   }\n\n   res = getaddrinfo(host, serv, &hint, out);\n\n   if (res)\n      fprintf(stderr, \"%s `%s:%s'\\n\", gai_strerror(res), host, serv);\n   return res;\n}\n\nint start_listen_sockets(struct listen_endpoint *sockfd[])\n{\n    struct addrinfo *addr, *start_addr;\n    char buf[NI_MAXHOST];\n    int i, res;\n    int num_addr = 0, keepalive = 0, udp = 0;\n\n    *sockfd = NULL;\n\n    fprintf(stderr, \"Listening to:\\n\");\n\n    for (i = 0; i < cfg.listen_len; i++) {\n        udp = cfg.udp;\n\n\n        res = resolve_split_name(&start_addr, cfg.listen[i].host, cfg.listen[i].port);\n        if (res) exit(4);\n\n        for (addr = start_addr; addr; addr = addr->ai_next) {\n            num_addr++;\n            *sockfd = realloc(*sockfd, num_addr * sizeof(*sockfd));\n            (*sockfd)[num_addr-1].socketfd = listen_single_addr(addr, keepalive, udp);\n            (*sockfd)[num_addr-1].type = udp ? SOCK_DGRAM : SOCK_STREAM;\n            fprintf(stderr, \"%d:\\t%s\\n\", (*sockfd)[num_addr-1].socketfd, sprintaddr(buf, sizeof(buf), addr));\n        }\n        freeaddrinfo(start_addr);\n    }\n\n    return num_addr;\n}\n\nint main(int argc, char *argv[])\n{\n\n   extern char *optarg;\n   extern int optind;\n   int num_addr_listen;\n\n   struct listen_endpoint *listen_sockets;\n\n   memset(&cfg, 0, sizeof(cfg));\n   if (echocfg_cl_parse(argc, argv, &cfg))\n       exit(1);\n\n   echocfg_fprint(stdout, &cfg, 0);\n\n   num_addr_listen = start_listen_sockets(&listen_sockets);\n\n   main_loop(listen_sockets, num_addr_listen);\n\n   return 0;\n}\n"
        },
        {
          "name": "echosrv.cfg",
          "type": "blob",
          "size": 0.9599609375,
          "content": "# conf2struct for echosrv\n\nheader: \"echosrv-conf.h\";\nparser: \"echosrv-conf.c\";\n\nprinter: true;\n\nconffile_option: (\"F\", \"config\");\n\nconfig: {\n          name: \"echocfg\",\n          type: \"list\",\n          items: (\n                  {name: \"udp\", type: \"bool\"; default: false; },\n                  {name: \"prefix\", type: \"string\"; },\n              { name: \"listen\", \n                type: \"list\", \n                items: (\n                        { name: \"host\"; type: \"string\"; var: true; },\n                        { name: \"port\"; type: \"string\"; var: true; }\n                    )\n                }\n            )\n}\n\n\ncl_groups: (\n    { name: \"listen\"; pattern: \"(.+):(\\w+)\"; description: \"Listen on host:port\";\n      short: \"p\"; argdesc: \"<host:port>\";\n        list: \"listen\";\n        # no override, this just adds to the list (and thus can be specified several times)\n        targets: (\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" }\n        );\n    }\n)\n"
        },
        {
          "name": "echoѕrv-conf.h",
          "type": "blob",
          "size": 2.86328125,
          "content": "/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)\n * on Sat Nov  7 09:19:26 2020. \n\n# conf2struct: generate libconf parsers that read to structs\n# Copyright (C) 2018-2019  Yves Rutschle\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n*/\n \n#ifndef C2S_SSLHCFG_H\n#define C2S_SSLHCFG_H\n#ifdef LIBCONFIG\n#    include <libconfig.h>\n#endif\n\n\n#include \"probe.h\"\n#include  <sys/types.h>\n#include  <sys/socket.h>\n#include  <netdb.h>\n\nstruct sslhcfg_listen_item {\n\tchar*\thost;\n\tchar*\tport;\n\tint\tkeepalive;\n};\n\nstruct sslhcfg_protocols_item {\n\tchar*\tname;\n\tchar*\thost;\n\tchar*\tport;\n\tint\tservice_is_present;\n\tchar*\tservice;\n\tint\tfork;\n\tint\ttfo_ok;\n\tint\tlog_level;\n\tint\tkeepalive;\n\tsize_t\tsni_hostnames_len;\n\tchar** sni_hostnames;\n\tsize_t\talpn_protocols_len;\n\tchar** alpn_protocols;\n\tsize_t\tregex_patterns_len;\n\tchar** regex_patterns;\n\tint\tminlength_is_present;\n\tint\tminlength;\n\tT_PROBE*\tprobe;\n\tstruct addrinfo*\tsaddr;\n\tvoid*\tdata;\n};\n\nstruct sslhcfg_item {\n\tchar*\tprefix;\n\tint\tverbose;\n\tint\tforeground;\n\tint\tinetd;\n\tint\tnumeric;\n\tint\ttransparent;\n\tint\ttimeout;\n\tint\tuser_is_present;\n\tchar*\tuser;\n\tint\tpidfile_is_present;\n\tchar*\tpidfile;\n\tint\tchroot_is_present;\n\tchar*\tchroot;\n\tchar*\tsyslog_facility;\n\tchar*\ton_timeout;\n\tsize_t\tlisten_len;\n\tstruct sslhcfg_listen_item* listen;\n\tsize_t\tprotocols_len;\n\tstruct sslhcfg_protocols_item* protocols;\n};\n\nint sslhcfg_parse_file(\n        const char* filename,\n        struct sslhcfg_item* sslhcfg, \n        const char** errmsg);\n\nvoid sslhcfg_fprint(\n    FILE* out,\n    struct sslhcfg_item *sslhcfg,\n    int depth);\n\nint sslhcfg_cl_parse(\n    int argc,\n    char* argv[],\n    struct sslhcfg_item *sslhcfg);\n\n#endif\n"
        },
        {
          "name": "example.cfg",
          "type": "blob",
          "size": 7.11328125,
          "content": "# This file is provided as documentation to show what is\n# possible. It should not be used as-is, and probably should\n# not be used as a starting point for a working\n# configuration. Instead use basic.cfg.\n\nforeground: true;\ninetd: false;\nnumeric: false;\ntransparent: false;\ntimeout: 2;\nuser: \"nobody\";\npidfile: \"/var/run/sslh.pid\";\nchroot: \"/var/empty\";\n\n# Logging configuration\n# Value: 1: stdout; 2: syslog; 3: stdout+syslog; 4: logfile; ...; 7: all\n# Defaults are indicated here, and should be sensible. Generally, you want *-error\n# to be always enabled, to know if something is going wrong.\n# Each option relates to a different set of messages.\nverbose-config: 0; #  print configuration at startup\nverbose-config-error: 3;  # print configuration errors\nverbose-connections: 3; # trace established incoming address to forward address\nverbose-connections-error: 3; # connection errors\nverbose-connections-try: 0; # connection attempts towards targets\nverbose-fd: 0; # file descriptor activity, open/close/whatnot\nverbose-packets: 0; # hexdump packets on which probing is done\nverbose-probe-info: 0; # what's happening during the probe process\nverbose-probe-error: 3; # failures and problems during probing\nverbose-system-error: 3; # system call problem, i.e.  malloc, fork, failing\nverbose-int-error: 3; # internal errors, the kind that should never happen\n\n# This one is special and overrides all previous options if\n# set, as a quick way to get \"as much as possible\"\n#verbose: 3;\n\n# Specify a path to the logfile.\n#logfile: \"/var/log/sslh.log\"\n\n# Specify the number of concurrent UDP connection that can\n# be managed (default 1024)\nudp_max_connections: 16;\n\n# Specify which syslog facility to use (names for your\n# system are usually defined in /usr/include/*/sys/syslog.h\n# or equivalent)\n# Default is \"auth\"\n# \"none\" disables use of syslog\nsyslog_facility: \"auth\"; \n\n# List of interfaces on which we should listen\n# Options:\nlisten:\n(\n    { host: \"thelonious\"; port: \"443\"; },\n    { host: \"thelonious\"; port: \"8080\"; keepalive: true; },\n    { host: \"thelonious\"; is_udp: true; port: \"443\"; },\n    { host: \"/tmp/unix_socket\"; is_unix: true; port: \"\"; }\n);\n\n# List of protocols\n#\n# Each protocol entry consists of:\n#   name: name of the probe. These are listed on the command\n#   line (ssh -?), plus 'regex' and 'timeout'.\n\n#   service: (optional) libwrap service name (see hosts_access(5))\n#   host, port: where to connect when this probe succeeds\n#   log_level:  0 to turn off logging\n#               1 to log each incoming connection\n#   keepalive:  Should TCP keepalive be on or off for that\n#               connection (default is off)\n#   fork: Should a new process be forked for this protocol?\n#         (only useful for sslh-select)\n#   tfo_ok: Set to true if the server supports TCP FAST OPEN\n#   resolve_on_forward: Set to true if server address should be resolved on\n#         (every) newly incoming connection (again)\n#   transparent: Set to true to proxy this protocol\n#         transparently (server sees the remote client IP\n#         address). Same as the global option, but per-protocol\n#   is_unix: [true|false] connect to a UNIX socket. The host\n#   field becomes the pathname to the socket, and the port\n#   field is unused (but necessary).\n#\n#  Probe-specific options:\n# (sslh will try each probe in order they are declared, and\n# connect to the first that matches.)\n#\n#       tls:\n#               sni_hostnames:  list of FQDN for that target. Each name can\n#               include wildcard following glob(7) rules.\n\n#               alpn_protocols: list of ALPN protocols for that target, see:\n#               https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids\n#\n#               if both sni_hostnames AND alpn_protocols are specified, both must match\n#\n#               if neither are set, it is just checked whether this is the TLS protocol or not\n#\n#               Obviously set the most specific probes\n#               first, and if you use TLS with no ALPN/SNI\n#               set it as the last TLS probe\n#       regex:\n#               regex_patterns: list of patterns to match for\n#               that target.\n#   \n# You can specify several of 'regex' and 'tls'.\n#\n# If you want to filter on incoming IP addresses, you can\n# use libwrap which will use /etc/hosts.allow and\n# /etc/hosts.deny.\n \nprotocols:\n(\n     { name: \"ssh\"; service: \"ssh\"; host: \"localhost\"; port: \"22\"; \n       keepalive: true; fork: true; tfo_ok: true },\n\n# UNIX socket to a local NGINX. The socket name is in  'host'; 'port' is necessary but not used.\n     { name: \"http\"; is_unix: true; host: \"/tmp/nginx.sock\"; port: \"\"; },\n\n# match BOTH ALPN/SNI\n     { name: \"tls\"; host: \"localhost\"; port: \"5223\"; alpn_protocols: [ \"xmpp-client\" ]; sni_hostnames: [ \"im.somethingelse.net\" ]; log_level: 0; tfo_ok: true },\n\n# just match ALPN\n     { name: \"tls\"; host: \"localhost\"; port: \"443\"; alpn_protocols: [ \"h2\", \"http/1.1\", \"spdy/1\", \"spdy/2\", \"spdy/3\" ]; log_level: 0;  tfo_ok: true },\n     { name: \"tls\"; host: \"localhost\"; port: \"xmpp-client\"; alpn_protocols: [ \"xmpp-client\" ];  log_level: 0; tfo_ok: true },\n\n# just match SNI\n     { name: \"tls\"; host: \"localhost\"; port: \"993\"; sni_hostnames: [ \"mail.rutschle.net\", \"mail.englishintoulouse.com\" ]; log_level: 0;  tfo_ok: true },\n     { name: \"tls\"; host: \"localhost\"; port: \"xmpp-client\"; sni_hostnames: [ \"im.rutschle.net\", \"im.englishintoulouse.com\" ];  log_level: 0; tfo_ok: true },\n\n# Let's Encrypt (tls-alpn-* challenges)\n     { name: \"tls\"; host: \"localhost\"; port: \"letsencrypt-client\"; alpn_protocols: [ \"acme-tls/1\" ]; log_level: 0;},\n\n# catch anything else TLS\n     { name: \"tls\"; host: \"localhost\"; port: \"443\";  tfo_ok: true },\n\n# Forward UDP \n     { name: \"regex\"; host: \"localhost\"; is_udp: true; port: \"123\";\n                      udp_timeout: 20;  # Time after which the \"connection\" is forgotten\n                      regex_patterns: [ \"hello\" ]; },\n# Forward Teamspeak3 (Voice only)\n     { name: \"teamspeak\"; host: \"localhost\"; is_udp: true; port: \"9987\"; },\n# Forward IETF QUIC-50 (\"Q050\" -> \"\\x51\\x30\\x35\\x30\")\n# Remember that the regex needs to be adjusted for every supported QUIC version.\n     { name: \"regex\"; host: \"localhost\"; is_udp: true; port: \"4433\"; regex_patterns: [ \"\\x51\\x30\\x35\\x30\" ]; },\n\n# Regex examples -- better use the built-in probes for real-world use!\n# OpenVPN\n     { name: \"regex\"; host: \"localhost\"; port: \"1194\"; regex_patterns: [ \"^\\x00[\\x0D-\\xFF]$\", \"^\\x00[\\x0D-\\xFF]\\x38\" ]; },\n# Jabber\n     { name: \"regex\"; host: \"localhost\"; port: \"5222\"; regex_patterns: [ \"jabber\" ];\n       minlength: 60;  # Won't even try to match the regex if we don't have that many bytes\n     },\n    \n# Catch-all (but better use 'anyprot')\n     { name: \"regex\"; host: \"localhost\"; port: \"443\"; regex_patterns: [ \"\" ]; },\n\n# Where to connect in case of timeout (defaults to ssh)\n     { name: \"timeout\"; service: \"daytime\"; host: \"localhost\"; port: \"daytime\"; }\n);\n\n# Optionally, specify to which protocol to connect in case\n# of timeout (defaults to \"ssh\").\n# You can timeout to any arbitrary address by setting an\n# entry in 'protocols' named \"timeout\".\n# This enables you to set a tcpd service name for this\n# protocol too.\non-timeout: \"timeout\";\n\n"
        },
        {
          "name": "gap.c",
          "type": "blob",
          "size": 2.5302734375,
          "content": "/*\n   gap.c: gap, a simple, dynamically-growing array\n   of pointers that never shrinks\n\n# Copyright (C) 2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n\n#include \"sslh-conf.h\"\n#include \"gap.h\"\n\n\n/* Allocate one page-worth of elements */\nstatic int gap_len_alloc(int elem_size)\n{\n    return getpagesize() / elem_size;\n}\n\n/* Creates a new gap at least `len` big, all pointers are initialised at NULL */\ngap_array* gap_init(int len)\n{\n    gap_array* gap = malloc(sizeof(*gap));\n    if (!gap) return NULL;\n    memset(gap, 0, sizeof(*gap));\n\n    int elem_size = sizeof(gap->array[0]);\n    gap->len = gap_len_alloc(elem_size);\n    if (gap->len < len) gap->len = len;\n    gap->array = malloc(gap->len * elem_size);\n    if (!gap->array) {\n        free(gap);\n        return NULL;\n    }\n\n    for (int i = 0; i < gap->len; i++)\n        gap->array[i] = NULL;\n\n    return gap;\n}\n\nint gap_extend(gap_array* gap)\n{\n    int elem_size = sizeof(gap->array[0]);\n    int new_length = gap->len + gap_len_alloc(elem_size);\n    void** new = realloc(gap->array, new_length * elem_size);\n    if (!new) return -1;\n\n    gap->array = new;\n\n    for (int i = gap->len; i < new_length; i++) {\n        gap->array[i] = NULL;\n    }\n\n    gap->len = new_length;\n\n    return 0;\n}\n\nvoid gap_destroy(gap_array* gap) \n{\n    free(gap->array);\n    free(gap);\n}\n\n\n/* In gap, find element pointing to ptr, then shift the rest of the array that\n * is considered len elements long.\n * A poor man's list, if you will. Currently only used to remove probing\n * connections, so it only copies a few pointers at most.\n * Returns -1 if ptr was not found */\nint gap_remove_ptr(gap_array* gap, void* ptr, int len)\n{\n    int start, i;\n\n    for (i = 0; i < len; i++)\n        if (gap->array[i] == ptr)\n            break;\n\n    if (i < len)\n        start = i;\n    else\n        return -1;\n\n    for (i = start; i < len - 1; i++) {\n        gap->array[i] = gap->array[i+1];\n    }\n\n    return 0;\n}\n\n"
        },
        {
          "name": "gap.h",
          "type": "blob",
          "size": 1.1025390625,
          "content": "#ifndef GAP_H\n#define GAP_H\n\ntypedef struct gap_array gap_array;\n\ngap_array* gap_init(int len);\nstatic void* gap_get(gap_array* gap, int index);\nstatic int gap_set(gap_array* gap, int index, void* ptr);\nvoid gap_destroy(gap_array* gap);\n\nint gap_remove_ptr(gap_array* gap, void* ptr, int len);\n\n/* Private declarations to allow inlining.\n * Don't assume my implementation. */\ntypedef struct gap_array {\n    int len; /* Number of elements in array */\n    void** array;\n} gap_array;\n\nint gap_extend(gap_array* gap);\n\nstatic inline int __attribute__((unused)) gap_set(gap_array* gap, int index, void* ptr)\n{\n    while (index >= gap->len) {\n        int res = gap_extend(gap);\n        if (res == -1) return -1;\n    }\n\n    gap->array[index] = ptr;\n    return 0;\n}\n\nstatic inline void* __attribute__((unused)) gap_get(gap_array* gap, int index)\n{\n    /* sslh-ev routinely reads before it writes. It's not clear if it should be\n     * its job to check the length (and add a gap_getlen()), or if it should be\n     * gap_get()'s job. This will do for now */\n    if (index >= gap->len) return NULL;\n\n    return gap->array[index];\n}\n\n#endif\n"
        },
        {
          "name": "genver.sh",
          "type": "blob",
          "size": 1.4462890625,
          "content": "#! /bin/sh\n\nif [ ${#} -eq 1 ] && [ \"x$1\" = \"x-r\" ]; then\n\t# release text only\n\tQUIET=1\nelse\n\tQUIET=0\nfi\n\nif [ ! -d .git ] || ! `(git status | grep -q \"On branch\") 2> /dev/null`; then\n        # If we don't have git, we can't work out what\n        # version this is. It must have been downloaded as a\n        # zip file.\n\n        # If downloaded from the release page, the directory\n        # has the version number.\n        release=`pwd | sed s/.*sslh-// | grep \"[[:digit:]]\"`\n\n        if [ \"x$release\" = \"x\" ]; then\n            # If downloaded from the head, GitHub creates the\n            # zip file with all files dated from the last\n            # change: use the Makefile's modification time as a\n            # release number\n            release=head-`perl -MPOSIX -e 'print strftime \"%Y-%m-%d\",localtime((stat \"Makefile\")[9])'`\n        fi\nfi\n\nif [ -d .git ] && head=`git rev-parse --verify HEAD 2>/dev/null`; then\n\t# generate the version info based on the tag\n\trelease=`(git describe --tags || git --describe || git describe --all --long) \\\n\t\t2>/dev/null | tr -s '/' '-' | tr -d '\\n'`\n\n\t# Are there uncommitted changes?\n\tgit update-index --refresh --unmerged > /dev/null\n\tif git diff-index --name-only HEAD | grep -v \"^scripts/package\" \\\n\t    | read dummy; then\n\t\trelease=\"$release-dirty\"\n\tfi\nfi\n\n\nif [ $QUIET -ne 1 ]; then\n\tprintf \"#ifndef VERSION_H \\n\"\n\tprintf \"#define VERSION_H \\n\\n\"\n\tprintf \"#define VERSION \\\"$release\\\"\\n\"\n\tprintf \"#endif\\n\"\nelse\n\tprintf \"$release\\n\"\nfi\n"
        },
        {
          "name": "hash.c",
          "type": "blob",
          "size": 5.43359375,
          "content": "/* \n * a fixed-sized hash\n *\n# Copyright (C) 2022  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n#\n# */\n\n\n/*  * The hash is open-addressing, linear search, robin-hood insertion, with \n * backward shift deletion. References:\n * https://codecapsule.com/2013/11/11/robin-hood-hashing/\n * https://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/\n * This means items are reordered upon insertion and deletion, and the hash\n * is well-ordered at all times with no tombstones.\n *\n * Each pointer is either:\n * - to a connection struct\n * - FREE (NULL) if not allocated\n *\n * */\n\n#include <stdlib.h>\n#include <stddef.h>\n\n#include \"gap.h\"\n\ntypedef void* hash_item;\n#include \"hash.h\"\n\nstatic void* const FREE = NULL;\n\nstruct hash {\n    int hash_size;      /* Max number of items in the hash */\n    int item_cnt;       /* Number of items in the hash */\n    gap_array* data;\n\n    hash_make_key_fn hash_make_key;\n    hash_cmp_item_fn cmp_item;\n};\n\ntypedef struct hash hash;\n\n\nstatic int hash_make_key(hash* h, hash_item item)\n{\n    return h->hash_make_key(item) % h->hash_size;\n}\n\n\nhash* hash_init(int hash_size, hash_make_key_fn make_key, hash_cmp_item_fn cmp_item)\n{\n    hash* h = malloc(sizeof(*h));\n    if (!h) return NULL;\n\n    h->hash_size = hash_size;\n    h->item_cnt = 0;\n    h->data = gap_init(hash_size);\n    h->hash_make_key = make_key;\n    h->cmp_item = cmp_item;\n\n    return h;\n}\n\n/* Return the index following i in h */\nstatic int hash_next_index(hash* h, int i)\n{\n    return (i + 1) % h->hash_size;\n}\n\n/* Returns the index in h of specified address, -1 if not found \n * item is an item object that must return the target wanted index and for\n * which comparison with the searched object will succeed.\n * */\nstatic int hash_find_index(hash* h, hash_item item)\n{\n    hash_item cnx;\n    int index = hash_make_key(h, item);\n    int cnt = 0;\n\n    cnx = gap_get(h->data, index);\n#ifdef DEBUG\n    fprintf(stderr, \"searching %d\\n\", index);\n#endif\n    while (cnx != FREE) {\n        if (cnt++ > h->hash_size) return -1;\n\n        if (!h->cmp_item(cnx, item))\n            break;\n\n        index = hash_next_index(h, index);\n        cnx = gap_get(h->data, index);\n#ifdef DEBUG\n        fprintf(stderr, \"searching %d\\n\", index);\n#endif\n    } \n    if (cnx == FREE) return -1;\n    return index;\n}\n\nhash_item hash_find(hash* h, hash_item item)\n{\n    int index = hash_find_index(h, item);\n    if (index == -1) return NULL;\n    hash_item out = gap_get(h->data, index);\n    return out;\n}\n\n\n/* Returns DIB: distance to initial bucket */\nstatic int distance(int current_index, hash* h, hash_item item)\n{\n    int wanted_index = hash_make_key(h, item);\n    if (wanted_index <= current_index)\n        return current_index - wanted_index;\n    else\n        return current_index - wanted_index + h->hash_size;\n}\n\n\nint hash_insert(hash* h, hash_item new)\n{\n    int bubble_wanted_index = hash_make_key(h, new);\n    int index = bubble_wanted_index;\n    gap_array* hash = h->data;\n\n    if (h->item_cnt == h->hash_size)\n        return -1;\n\n    hash_item curr_item = gap_get(hash, index);\n    while (curr_item) {\n        if (distance(index, h, curr_item) < distance(index, h, new)) {\n            gap_set(h->data, index, new);\n#if DEBUG\n            fprintf(stderr, \"intermediate insert [%s] at %d\\n\", &new->client_addr, index);\n#endif\n            new = curr_item;\n        }\n\n        index = hash_next_index(h, index);\n        curr_item = gap_get(hash, index);\n    }\n\n#if DEBUG\n    fprintf(stderr, \"final insert at %d\\n\", index);\n#endif\n    gap_set(hash, index, new);\n    h->item_cnt++;\n\n    return 0;\n}\n\n/* Remove cnx from the hash */\nint hash_remove(hash* h, hash_item item)\n{\n    gap_array* hash = h->data;\n\n    int index = hash_find_index(h, item);\n    if (index == -1) return -1; /* Tried to remove something that isn't there */\n\n    while (1) {\n        int next_index = hash_next_index(h, index);\n        hash_item next = gap_get(h->data, next_index);\n        if ((next == FREE) || (distance(next_index, h, next) == 0)) {\n            h->item_cnt--;\n            gap_set(hash, index, FREE);\n            return 0;\n        }\n\n        gap_set(hash, index, next);\n\n        index = hash_next_index(h, index);;\n    }\n    return 0;\n}\n\n#if HASH_TESTING\n#include <stdio.h>\n#include <string.h>\n#define STR_LENGTH 16\nstruct hash_item {\n    int wanted_index;\n    char str[STR_LENGTH];\n};\nvoid hash_dump(hash* h, char* filename)\n{\n    char str[STR_LENGTH];\n    FILE* out = fopen(filename, \"w\");\n\n    if (!out) {\n        perror(filename);\n        exit(1);\n    }\n    \n    fprintf(out, \"<hash elem=%d>\\n\", h->item_cnt);\n    for (int i = 0; i < h->hash_size; i++) {\n        hash_item item = gap_get(h->data, i);\n        int idx = 0;\n\n        memset(str, 0, STR_LENGTH);\n        if (item) {\n            idx = hash_make_key(h, item);\n            memcpy(str, ((struct hash_item*)item)->str, STR_LENGTH);\n        }\n        fprintf(out, \"\\t%d:%d:%s\\n\", i, idx, str);\n    }\n    fprintf(out, \"</hash>\\n\");\n    fclose(out);\n}\n#endif\n"
        },
        {
          "name": "hash.h",
          "type": "blob",
          "size": 0.9150390625,
          "content": "#ifndef HASH_H\n#define HASH_H\n\n/* You will need to typedef a pointer type to hash_item before including this\n * .h */\n\ntypedef struct hash hash;\n\n/* Function that returns a key (index) for a given item. The key must be always\n * the same for an item. It doesn't need to be bounded (hash.c masks it for you) */\ntypedef int (*hash_make_key_fn)(hash_item item);\n\n/* Function that compares two items: returns 0 if they are the same */\ntypedef int (*hash_cmp_item_fn)(hash_item item1, hash_item item2);\n\nhash* hash_init(int hash_size, hash_make_key_fn make_key, hash_cmp_item_fn cmp_item);\n\nint hash_insert(hash* h, hash_item new);\nint hash_remove(hash* h, hash_item item);\n\n/* Returns the hash item that matches specification (meaning the\n * comparison function returns true for cmp(x, item), or NULL if not found */\nhash_item hash_find(hash* h, hash_item item);\n\n\nvoid hash_dump(hash* h, char* filename); /* For development only */\n\n#endif\n"
        },
        {
          "name": "hashtest",
          "type": "tree",
          "content": null
        },
        {
          "name": "landlock.c",
          "type": "blob",
          "size": 5.056640625,
          "content": "/*\n * Setup a sandbox using the Landlock LSM, if available.\n\n# Copyright (C) 2023  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n#\n*/\n\n#include \"config.h\"\n#include \"log.h\"\n\n#ifdef HAVE_LANDLOCK\n\n#define _GNU_SOURCE\n#include <linux/landlock.h>\n#include <sys/prctl.h>\n#include <sys/syscall.h>\n\n/* Ubuntu 22.04 does not have this symbol */\n#ifndef LANDLOCK_ACCESS_FS_REFER\n#define LANDLOCK_ACCESS_FS_REFER\t\t\t(1ULL << 13)\n#endif\n\n#ifndef landlock_create_ruleset\nstatic inline int\nlandlock_create_ruleset(const struct landlock_ruleset_attr *const attr,\n\t\t\tconst size_t size, const __u32 flags)\n{\n\treturn syscall(__NR_landlock_create_ruleset, attr, size, flags);\n}\n#endif\n\n#ifndef landlock_add_rule\nstatic inline int landlock_add_rule(const int ruleset_fd,\n\t\t\t\t    const enum landlock_rule_type rule_type,\n\t\t\t\t    const void *const rule_attr,\n\t\t\t\t    const __u32 flags)\n{\n\treturn syscall(__NR_landlock_add_rule, ruleset_fd, rule_type, rule_attr,\n\t\t       flags);\n}\n#endif\n\n#ifndef landlock_restrict_self\nstatic inline int landlock_restrict_self(const int ruleset_fd,\n\t\t\t\t\t const __u32 flags)\n{\n\treturn syscall(__NR_landlock_restrict_self, ruleset_fd, flags);\n}\n#endif\n\ntypedef enum {\n    LL_TREE,\n    LL_FILE\n} ll_obj_type;\n\nstatic int add_path_ro(int ruleset_fd, ll_obj_type otype, const char* path)\n{\n    int fd = open(path, O_PATH | O_CLOEXEC);\n    if (fd < 0) {\n        print_message(msg_config_error, \"Landlock: Failed to open %s: %s\\n\", path, strerror(errno));\n        return -1;\n    }\n\n    struct landlock_path_beneath_attr path_beneath = {\n        .allowed_access = (otype == LL_TREE ? LANDLOCK_ACCESS_FS_READ_DIR : 0 ) |\n                          LANDLOCK_ACCESS_FS_READ_FILE,\n        .parent_fd = fd,\n    };\n\n    int res = landlock_add_rule(ruleset_fd, LANDLOCK_RULE_PATH_BENEATH, &path_beneath, 0);\n    if (res) {\n        print_message(msg_config_error, \"Landlock: Failed to update the ruleset with \\\"%s\\\": %s\\n\",\n                path, strerror(errno));\n        close(path_beneath.parent_fd);\n        return -1;\n    }\n\n    // close helper handle\n    close(fd);\n\n    return 0;\n}\n\n\nstatic int add_libs(int ruleset_fd)\n{\n    /* Access to libraries, to be able to fork */\n    add_path_ro(ruleset_fd, LL_TREE, \"/lib\");\n    add_path_ro(ruleset_fd, LL_TREE, \"/usr/lib\");\n    add_path_ro(ruleset_fd, LL_FILE, \"/etc/ld.so.cache\");  /* To avoid searching all libs... */\n    return 0;\n}\n\nstatic int add_resolv(int ruleset_fd)\n{\n    /* Files to resolve names (required when dynamic resolution is used) */\n    add_path_ro(ruleset_fd, LL_FILE, \"/etc/hosts\");\n    add_path_ro(ruleset_fd, LL_FILE, \"/etc/resolv.conf\");\n    add_path_ro(ruleset_fd, LL_FILE, \"/etc/nsswitch.conf\");\n    return 0;\n}\n\nstatic int add_libwrap(int ruleset_fd)\n{\n    /* Files for libwrap */\n#ifdef LIBWRAP\n    add_path_ro(ruleset_fd, LL_FILE, \"/etc/hosts.allow\");\n    add_path_ro(ruleset_fd, LL_FILE, \"/etc/hosts.deny\");\n#endif\n\n    return 0;\n}\n\n\n\nvoid setup_landlock(void)\n{\n    __u64 restrict_rules = \n        LANDLOCK_ACCESS_FS_EXECUTE |\n        LANDLOCK_ACCESS_FS_READ_FILE |\n        LANDLOCK_ACCESS_FS_READ_DIR |\n        LANDLOCK_ACCESS_FS_WRITE_FILE |\n        LANDLOCK_ACCESS_FS_REMOVE_DIR |\n        LANDLOCK_ACCESS_FS_REMOVE_FILE |\n        LANDLOCK_ACCESS_FS_MAKE_CHAR |\n        LANDLOCK_ACCESS_FS_MAKE_DIR |\n        LANDLOCK_ACCESS_FS_MAKE_REG |\n        LANDLOCK_ACCESS_FS_MAKE_SOCK |\n        LANDLOCK_ACCESS_FS_MAKE_FIFO |\n        LANDLOCK_ACCESS_FS_MAKE_BLOCK |\n        LANDLOCK_ACCESS_FS_MAKE_SYM |\n        LANDLOCK_ACCESS_FS_REFER;\n\n    struct landlock_ruleset_attr ruleset_attr = {\n        .handled_access_fs = restrict_rules\n    };\n\n    /* ruleset_addr.handled_access_fs contains all rights that will be restricted\n     * unless explicitly added */\n    int ruleset_fd = landlock_create_ruleset(&ruleset_attr, sizeof(ruleset_attr), 0);\n    if (ruleset_fd < 0) {\n        print_message(msg_config_error, \"Landlock: Failed to create a ruleset\");\n        return;\n    }\n\n\n    /* Add all the paths we need */\n    add_libs(ruleset_fd);\n    add_resolv(ruleset_fd);\n    add_libwrap(ruleset_fd);\n\n    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n        print_message(msg_config_error, \"Landlock: Failed to restrict privileges\");\n        return;\n    }\n    if (landlock_restrict_self(ruleset_fd, 0)) {\n        print_message(msg_config_error, \"Landlock: Failed to enforce ruleset\");\n        return;\n    }\n    close(ruleset_fd);\n\n    print_message(msg_config, \"Landlock: all restricted\\n\");\n}\n\n#else /* HAVE_LANDLOCK */\nvoid setup_landlock(void)\n{\n    print_message(msg_config, \"Landlock: not built in\\n\");\n    return;\n}\n#endif /* HAVE_LANDLOCK */\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 4.97265625,
          "content": "/*\n# log: processing of all outgoing messages\n#\n# Copyright (C) 2007-2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n\n#define SYSLOG_NAMES\n#define _GNU_SOURCE\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include \"sslh-conf.h\"\n#include \"common.h\"\n#include \"log.h\"\n\nmsg_info msg_config = {\n    LOG_INFO,\n    &cfg.verbose_config\n};\n\nmsg_info msg_config_error = {\n    LOG_ERR,\n    &cfg.verbose_config_error\n};\n\nmsg_info msg_fd = {\n    LOG_DEBUG,\n    &cfg.verbose_fd\n};\n\n/* Internal errors: inconsistent states, impossible values, things that should never happen, and are therefore the sign of memory corruption: hence the LOG_CRIT */\nmsg_info msg_int_error = {\n    LOG_CRIT,\n    &cfg.verbose_system_error\n};\n\n/* System errors: when the system around us fails us: memory allocation, fork, ... */\nmsg_info msg_system_error = {\n    LOG_ERR,\n    &cfg.verbose_system_error\n};\n\nmsg_info msg_packets = {\n    LOG_INFO,\n    &cfg.verbose_packets\n};\n\n/* additional info when attempting outgoing connections */\nmsg_info msg_connections_try = {\n    LOG_DEBUG,\n    &cfg.verbose_connections_try\n};\n\n/* Connection information and failures (e.g. forbidden by policy) */\nmsg_info msg_connections = {\n    LOG_INFO,\n    &cfg.verbose_connections\n};\n\n/* Connection failures, e.g. target server not present */\nmsg_info msg_connections_error = {\n    LOG_ERR,\n    &cfg.verbose_connections_error\n};\n\n\n/* comment the probing process */\nmsg_info msg_probe_info = {\n    LOG_INFO,\n    &cfg.verbose_probe_info\n};\n\n/* probing errors, e.g. inconsistent data in connections */\nmsg_info msg_probe_error = {\n    LOG_ERR,\n    &cfg.verbose_probe_error\n};\n\n\n\n/* Bitmasks in verbose-* values */\n#define MSG_STDOUT 1\n#define MSG_SYSLOG 2\n#define MSG_FILE   4\n\nstatic FILE* logfile_fp = NULL;\n\n/* Prints a message to stderr and/or syslog if appropriate */\nvoid print_message(msg_info info, const char* str, ...)\n{\n    va_list ap;\n\n    if ((*info.verbose & MSG_STDOUT) && ! cfg.inetd) {\n        va_start(ap, str);\n        vfprintf(stderr, str, ap);\n        va_end(ap);\n    }\n\n    if (*info.verbose & MSG_SYSLOG) {\n        va_start(ap, str);\n        vsyslog(info.log_level, str, ap);\n        va_end(ap);\n    }\n\n    if (*info.verbose & MSG_FILE && logfile_fp != NULL) {\n        va_start(ap, str);\n        vfprintf(logfile_fp, str, ap);\n        fflush(logfile_fp);\n        va_end(ap);\n    }\n}\n\nstatic int do_syslog = 1; /* Should we syslog? controled by syslog_facility = \"none\" */\n\n/* Open syslog connection with appropriate banner;\n * banner is made up of basename(bin_name)+\"[pid]\" */\nvoid setup_syslog(const char* bin_name) {\n    char *name1, *name2;\n    int res, fn;\n\n    if (!strcmp(cfg.syslog_facility, \"none\")) {\n        do_syslog = 0;\n        return;\n    }\n\n    name1 = strdup(bin_name);\n    res = asprintf(&name2, \"%s[%d]\", basename(name1), getpid());\n    CHECK_RES_DIE(res, \"asprintf\");\n\n    for (fn = 0; facilitynames[fn].c_val != -1; fn++)\n        if (strcmp(facilitynames[fn].c_name, cfg.syslog_facility) == 0)\n            break;\n    if (facilitynames[fn].c_val == -1) {\n        fprintf(stderr, \"Unknown facility %s\\n\", cfg.syslog_facility);\n        exit(1);\n    }\n\n    openlog(name2, LOG_CONS, facilitynames[fn].c_val);\n    free(name1);\n    /* Don't free name2, as openlog(3) uses it (at least in glibc) */\n}\n\nvoid setup_logfile()\n{\n    if (cfg.logfile == NULL)\n    {\n        return;\n    }\n\n    logfile_fp = fopen(cfg.logfile, \"a\");\n    if (logfile_fp == NULL)\n    {\n        fprintf(stderr, \"Could not open logfile %s for writing: %s\\n\", cfg.logfile, strerror(errno));\n        exit(1);\n    }\n}\n\nvoid close_logfile()\n{\n    if (logfile_fp != NULL)\n    {\n        fclose(logfile_fp);\n        logfile_fp = NULL;\n    }\n}\n\n/* syslogs who connected to where \n * desc: string description of the connection. if NULL, log_connection will\n * manage on its own\n * cnx: connection descriptor\n * */\nvoid log_connection(struct connection_desc* desc, const struct connection *cnx)\n{\n    struct connection_desc d;\n\n    if (cnx->proto->log_level < 1)\n        return;\n\n    if (!desc) {\n        desc = &d;\n        if (!get_connection_desc(desc, cnx)) {\n            print_message(msg_connections, \"%s: lost incoming connection\\n\",\n                          cnx->proto->name);\n            return;\n        }\n    }\n\n    print_message(msg_connections, \"%s:connection from %s to %s forwarded from %s to %s\\n\",\n                cnx->proto->name,\n                desc->peer,\n                desc->service,\n                desc->local,\n                desc->target);\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 0.71484375,
          "content": "#ifndef LOG_H\n#define LOG_H\n\n#include \"common.h\"\n\nvoid setup_syslog(const char* bin_name);\n\nvoid setup_logfile();\n\nvoid close_logfile();\n\nvoid log_connection(struct connection_desc* desc, const struct connection *cnx);\n\ntypedef struct s_msg_info{\n    int log_level;\n    int *verbose;\n} msg_info;\n\nvoid print_message(msg_info info, const char* str, ...);\nextern msg_info msg_config;\nextern msg_info msg_config_error;\n\nextern msg_info msg_fd;\nextern msg_info msg_packets;\n\nextern msg_info msg_int_error;\nextern msg_info msg_system_error;\n\nextern msg_info msg_connections_try;\nextern msg_info msg_connections_error;\nextern msg_info msg_connections;\n\nextern msg_info msg_probe_info;\nextern msg_info msg_probe_error;\n\n#endif /* LOG_H */\n"
        },
        {
          "name": "probe.c",
          "type": "blob",
          "size": 16.28125,
          "content": "/*\n# probe.c: Code for probing protocols\n#\n# Copyright (C) 2007-2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n*/\n\n#define _GNU_SOURCE\n#include <stdio.h>\n#ifdef ENABLE_REGEX\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n#endif\n#include <ctype.h>\n#include \"probe.h\"\n#include \"log.h\"\n\n\n\nstatic int is_ssh_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_openvpn_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_wireguard_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_tinc_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_xmpp_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_http_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_tls_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_adb_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_socks5_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_syslog_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_teamspeak_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_msrdp_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item*);\nstatic int is_true(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto) { return 1; }\n\n/* Table of protocols that have a built-in probe\n */\nstatic struct protocol_probe_desc builtins[] = {\n    /* description  probe  */\n    { \"ssh\",        is_ssh_protocol},\n    { \"openvpn\",    is_openvpn_protocol },\n    { \"wireguard\",  is_wireguard_protocol },\n    { \"tinc\",       is_tinc_protocol },\n    { \"xmpp\",       is_xmpp_protocol },\n    { \"http\",       is_http_protocol },\n    { \"tls\",        is_tls_protocol },\n    { \"adb\",        is_adb_protocol },\n    { \"socks5\",     is_socks5_protocol },\n    { \"syslog\",     is_syslog_protocol },\n    { \"teamspeak\",  is_teamspeak_protocol },\n    { \"msrdp\",      is_msrdp_protocol },\n    { \"anyprot\",    is_true }\n};\n\n/* TODO I think this has to go */\nstruct protocol_probe_desc*  get_builtins(void) {\n    return builtins;\n}\n\nint get_num_builtins(void) {\n    return ARRAY_SIZE(builtins);\n}\n\n/* Returns the protocol to connect to in case of timeout; \n * if not found, return the first protocol specified \n */\nstruct sslhcfg_protocols_item* timeout_protocol(void) \n{\n    int i;\n    for (i = 0; i < cfg.protocols_len; i++) {\n        if (!strcmp(cfg.protocols[i].name, cfg.on_timeout)) return &cfg.protocols[i];\n    }\n    return &cfg.protocols[0];\n}\n\n\n/* From http://grapsus.net/blog/post/Hexadecimal-dump-in-C */\n#define HEXDUMP_COLS 16\nvoid hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; /* index in str */\n\n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        /* print offset */\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n\n        /* print hex data */\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else /* end of block, just aligning for ASCII dump */\n            c+= sprintf(&str[c], \"   \");\n\n        /* print ASCII dump */\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) /* end of block, not really printing */\n                    str[c++] = ' ';\n                else if(isprint(mem[j])) /* printable char */\n                    str[c++] = 0xFF & mem[j];\n                else /* other char */\n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, \"%s\", str);\n            c = 0;\n        }\n    }\n}\n\n/* Is the buffer the beginning of an SSH connection? */\nstatic int is_ssh_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 4)\n        return PROBE_AGAIN;\n\n    return !strncmp(p, \"SSH-\", 4);\n}\n\n/* Is the buffer the beginning of an OpenVPN connection?\n *\n * Code inspired from OpenVPN port-share option; however, OpenVPN code is\n * wrong: users using pre-shared secrets have non-initialised key_id fields so\n * p[3] & 7 should not be looked at, and also the key_method can be specified\n * to 1 which changes the opcode to P_CONTROL_HARD_RESET_CLIENT_V1.\n * See:\n * http://www.fengnet.com/book/vpns%20illustrated%20tunnels%20%20vpnsand%20ipsec/ch08lev1sec5.html\n * and OpenVPN ssl.c, ssl.h and options.c\n */\n#define OVPN_OPCODE_MASK 0xF8\n#define OVPN_CONTROL_HARD_RESET_CLIENT_V1  (0x01 << 3)\n#define OVPN_CONTROL_HARD_RESET_CLIENT_V2  (0x07 << 3)\n#define OVPN_HMAC_128 16\n#define OVPN_HMAC_160 20\n#define OVPN_HARD_RESET_PACKET_ID_OFFSET(hmac_size) (9 + hmac_size)\nstatic int is_openvpn_protocol (const char*p,ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int packet_len;\n\n    if (proto->is_udp == 0)\n    {\n        if (len < 2)\n            return PROBE_AGAIN;\n\n        packet_len = ntohs(*(uint16_t*)p);\n        return packet_len == len - 2;\n    } else {\n        if (len < 1)\n            return PROBE_NEXT;\n\n        if ((p[0] & OVPN_OPCODE_MASK) != OVPN_CONTROL_HARD_RESET_CLIENT_V1 &&\n            (p[0] & OVPN_OPCODE_MASK) != OVPN_CONTROL_HARD_RESET_CLIENT_V2)\n            return PROBE_NEXT;\n\n        /* The detection pattern above may not be reliable enough.\n         * Check the packet id: OpenVPN sents five initial packets\n         * whereas the packet id is increased with every transmitted datagram.\n         */\n\n        if (len <= OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_128) + sizeof(uint32_t))\n            return PROBE_NEXT;\n\n        if (ntohl(*(uint32_t*)(p + OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_128))) <= 5u)\n            return PROBE_MATCH;\n\n        if (len <= OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_160) + sizeof(uint32_t))\n            return PROBE_NEXT;\n\n        if (ntohl(*(uint32_t*)(p + OVPN_HARD_RESET_PACKET_ID_OFFSET(OVPN_HMAC_160))) <= 5u)\n            return PROBE_MATCH;\n\n        return PROBE_NEXT;\n    }\n}\n\nstatic int is_wireguard_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (proto->is_udp == 0)\n        return PROBE_NEXT;\n\n    // Handshake Init: 148 bytes\n    if (len != 148)\n        return PROBE_NEXT;\n\n    // Handshake Init: p[0] = 0x01, p[1..3] = 0x000000 (reserved)\n    if (ntohl(*(uint32_t*)p) != 0x01000000)\n        return PROBE_NEXT;\n\n    return PROBE_MATCH;\n}\n\n/* Is the buffer the beginning of a tinc connections?\n * Protocol is documented here: http://www.tinc-vpn.org/documentation/tinc.pdf\n * First connection starts with \"0 \" in 1.0.15)\n * */\nstatic int is_tinc_protocol( const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 2)\n        return PROBE_AGAIN;\n\n    return !strncmp(p, \"0 \", 2);\n}\n\n/* Is the buffer the beginning of a jabber (XMPP) connections?\n * (Protocol is documented (http://tools.ietf.org/html/rfc6120) but for lazy\n * clients, just checking first frame containing \"jabber\" in xml entity)\n * */\nstatic int is_xmpp_protocol( const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (memmem(p, len, \"jabber\", 6))\n        return PROBE_MATCH;\n\n    /* sometimes the word 'jabber' shows up late in the initial string,\n       sometimes after a newline. this makes sure we snarf the entire preamble\n       and detect it. (fixed for adium/pidgin) */\n    if (len < 50)\n        return PROBE_AGAIN;\n\n    return PROBE_NEXT;\n}\n\nstatic int probe_http_method(const char *p, int len, const char *opt)\n{\n    if (len < strlen(opt))\n        return PROBE_AGAIN;\n\n    return !strncmp(p, opt, strlen(opt));\n}\n\n/* Is the buffer the beginning of an HTTP connection?  */\nstatic int is_http_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int res;\n    /* If it's got HTTP in the request (HTTP/1.1) then it's HTTP */\n    if (memmem(p, len, \"HTTP\", 4))\n        return PROBE_MATCH;\n\n#define PROBE_HTTP_METHOD(opt) if ((res = probe_http_method(p, len, opt)) != PROBE_NEXT) return res\n\n    /* Otherwise it could be HTTP/1.0 without version: check if it's got an\n     * HTTP method (RFC2616 5.1.1) */\n    PROBE_HTTP_METHOD(\"OPTIONS\");\n    PROBE_HTTP_METHOD(\"GET\");\n    PROBE_HTTP_METHOD(\"HEAD\");\n    PROBE_HTTP_METHOD(\"POST\");\n    PROBE_HTTP_METHOD(\"PUT\");\n    PROBE_HTTP_METHOD(\"DELETE\");\n    PROBE_HTTP_METHOD(\"TRACE\");\n    PROBE_HTTP_METHOD(\"CONNECT\");\n\n#undef PROBE_HTTP_METHOD\n\n    return PROBE_NEXT;\n}\n\n/* Says if it's TLS, optionally with SNI and ALPN lists in proto->data */\nstatic int is_tls_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    switch (parse_tls_header(proto->data, p, len)) {\n    case TLS_MATCH: return PROBE_MATCH;\n    case TLS_NOMATCH: return PROBE_NEXT;\n    case TLS_ELENGTH: return PROBE_AGAIN;\n    default: return PROBE_NEXT;\n    }\n}\n\nstatic int probe_adb_cnxn_message(const char *p)\n{\n    /* The initial ADB host->device packet has a command type of CNXN, and a\n     * data payload starting with \"host:\".  Note that current versions of the\n     * client hardcode \"host::\" (with empty serialno and banner fields) but\n     * other clients may populate those fields.\n     */\n    return !memcmp(&p[0], \"CNXN\", 4) && !memcmp(&p[24], \"host:\", 5);\n}\n\nstatic int is_adb_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    /* amessage.data_length is not being checked, under the assumption that\n     * a packet >= 30 bytes will have \"something\" in the payload field.\n     *\n     * 24 bytes for the message header and 5 bytes for the \"host:\" tag.\n     *\n     * ADB protocol:\n     * https://android.googlesource.com/platform/system/adb/+/master/protocol.txt\n     */\n    static const unsigned int min_data_packet_size = 30;\n\n    if (len < min_data_packet_size)\n        return PROBE_AGAIN;\n\n    if (probe_adb_cnxn_message(&p[0]) == PROBE_MATCH)\n        return PROBE_MATCH;\n\n    /* In ADB v26.0.0 rc1-4321094, the initial host->device packet sends an\n     * empty message before sending the CNXN command type. This was an\n     * unintended side effect introduced in\n     * https://android-review.googlesource.com/c/342653, and will be reverted for\n     * a future release.\n     */\n    static const unsigned char empty_message[] = {\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff\n    };\n\n    if (len < min_data_packet_size + sizeof(empty_message))\n        return PROBE_AGAIN;\n\n    if (memcmp(&p[0], empty_message, sizeof(empty_message)) != 0)\n        return PROBE_NEXT;\n\n    return probe_adb_cnxn_message(&p[sizeof(empty_message)]);\n}\n\nstatic int is_socks5_protocol(const char *p_in, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    unsigned char* p = (unsigned char*)p_in;\n    int i;\n\n    if (len < 2)\n        return PROBE_AGAIN;\n\n    /* First byte should be socks protocol version */\n    if (p[0] != 5)\n        return PROBE_NEXT;\n\n    /* Second byte should be number of supported \n     * authentication methods, assuming maximum of 10,\n     * as defined in https://www.iana.org/assignments/socks-methods/socks-methods.xhtml\n     */\n    char m_count = p[1];\n    if (m_count < 1 || m_count > 10)\n        return PROBE_NEXT;\n\n    if (len < 2 + m_count)\n        return PROBE_AGAIN;\n\n    /* Each authentication method number should be in range 0..9 \n     * (https://www.iana.org/assignments/socks-methods/socks-methods.xhtml)\n     */\n    for (i = 0; i < m_count; i++) {\n        if (p[2 + i] > 9)\n            return PROBE_NEXT;\n    }\n    return PROBE_MATCH;\n}\n\nstatic int is_syslog_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    int res, i, j;\n\n    res = sscanf(p, \"<%d>\", &i);\n    if (res == 1) return 1;\n\n    res = sscanf(p, \"%d <%d>\", &i, &j);\n    if (res == 2) return 1;\n\n    return 0;\n}\n\nstatic int is_teamspeak_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    if (len < 8)\n        return PROBE_NEXT;\n\n    return !strncmp(p, \"TS3INIT1\", len);\n}\n\nstatic int is_msrdp_protocol(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n    char version;\n    char packet_len;\n    if (len < 7)\n        return PROBE_NEXT;\n    version=*p;\n    if (version!=0x03)\n        return 0;\n    packet_len = ntohs(*(uint16_t*)(p+2));\n    return packet_len == len;\n}\n\nstatic int regex_probe(const char *p, ssize_t len, struct sslhcfg_protocols_item* proto)\n{\n#ifdef ENABLE_REGEX\n    pcre2_code**probe = (pcre2_code**)proto->data;\n    pcre2_match_data* matches;\n\n    matches = pcre2_match_data_create(1, NULL);\n\n    for (; *probe; probe++) {\n        int res = pcre2_match(*probe, (PCRE2_SPTR8)p, len, 0, 0, matches, NULL);\n        if (res >= 0) return 1;\n\n    }\n    return 0;\n#else\n    /* Should never happen as we check when loading config file */\n    print_message(msg_int_error, \"FATAL: regex probe called but not built in\\n\");\n    exit(5);\n#endif\n}\n\n/* Run all the probes on a buffer\n * buf, len: buffer to test on\n * proto_in, proto_len: array of protocols to try\n * proto_out: protocol that matched\n *\n * Returns\n *      PROBE_AGAIN if not enough data, and set *proto to NULL\n *      PROBE_MATCH if protocol is identified, in which case *proto is set to\n *      point to the appropriate protocol\n * */\nint probe_buffer(char* buf, int len,\n                 struct sslhcfg_protocols_item** proto_in,\n                 int proto_len,\n                 struct sslhcfg_protocols_item** proto_out\n                 )\n{\n    struct sslhcfg_protocols_item* p;\n    int i, res, again = 0;\n\n    print_message(msg_packets, \"hexdump of incoming packet:\\n\");\n    hexdump(msg_packets, buf, len);\n\n    *proto_out = NULL;\n    for (i = 0; i < proto_len; i++) {\n        char* probe_str[3] = {\"PROBE_NEXT\", \"PROBE_MATCH\", \"PROBE_AGAIN\"};\n        p = proto_in[i];\n\n        if (! p->probe) continue;\n\n        print_message(msg_probe_info, \"probing for %s\\n\", p->name);\n\n        /* Don't probe last protocol if it is anyprot (and store last protocol) */\n        if ((i == proto_len - 1) && (!strcmp(p->name, \"anyprot\")))\n            break;\n\n        if (p->minlength_is_present && (len < p->minlength )) {\n            print_message(msg_probe_info, \"input too short, %d bytes but need %d\\n\", \n                          len , p->minlength);\n            again++;\n            continue;\n        }\n\n        res = p->probe(buf, len, p);\n        print_message(msg_probe_info, \"probed for %s: %s\\n\", p->name, probe_str[res]);\n\n        if (res == PROBE_MATCH) {\n            *proto_out = p;\n            return PROBE_MATCH;\n        }\n        if (res == PROBE_AGAIN)\n            again++;\n    }\n    if (again)\n        return PROBE_AGAIN;\n\n    /* Everything failed: match the last one */\n\n    if (proto_len == 0) {\n        /* This should be caught by configuration sanity checks, but just in\n         * case, die gracefully rather than segfaulting */\n        print_message(msg_int_error, \"Received traffic on transport that has no target\\n\");\n        exit(0);\n    }\n    *proto_out = proto_in[proto_len-1];\n    return PROBE_MATCH;\n}\n\n/* Returns the probe for specified protocol:\n * parameter is the description in builtins[], or \"regex\" \n * */\nT_PROBE* get_probe(const char* description) {\n    int i;\n\n    for (i = 0; i < ARRAY_SIZE(builtins); i++) {\n        if (!strcmp(builtins[i].name, description)) {\n            return builtins[i].probe;\n        }\n    }\n\n    /* Special case of \"regex\" probe (we don't want to set it in builtins\n     * because builtins is also used to build the command-line options and\n     * regexp is not legal on the command line)*/\n    if (!strcmp(description, \"regex\"))\n        return regex_probe;\n\n    /* Special case of \"timeout\" is allowed as a probe name in the\n     * configuration file even though it's not really a probe */\n    if (!strcmp(description, \"timeout\"))\n        return is_true;\n\n    return NULL;\n}\n\n\n"
        },
        {
          "name": "probe.h",
          "type": "blob",
          "size": 1.8623046875,
          "content": "/* API for probe.c */\n\n#ifndef PROBE_H\n#define PROBE_H\n\n#include \"common.h\"\n#include \"tls.h\"\n#include \"log.h\"\n\ntypedef enum {\n    PROBE_NEXT,  /* Enough data, probe failed -- it's some other protocol */\n    PROBE_MATCH, /* Enough data, probe successful -- it's the current protocol */\n    PROBE_AGAIN, /* Not enough data for this probe, try again with more data */\n} probe_result;\n\nstruct sslhcfg_protocols_item;\ntypedef int T_PROBE(const char*, ssize_t, struct sslhcfg_protocols_item*);\n\nstruct protocol_probe_desc {\n    const char* name;\n    T_PROBE* probe;\n};\n\n\n#include \"sslh-conf.h\"\n\n/* Returns a pointer to the array of builtin protocols */\nstruct protocol_probe_desc* get_builtins(void);\n\n/* Returns the number of builtin protocols */\nint get_num_builtins(void);\n\n/* Returns the probe for specified protocol */\nT_PROBE* get_probe(const char* description);\n\n/* Returns the head of the configured protocols */\nstruct sslhcfg_protocols_item* get_first_protocol(void);\n\n/* Set the list of configured protocols */\nvoid set_protocol_list(struct sslhcfg_protocols_item*);\n\n/* probe_client_protocol\n *\n * Read the beginning of data coming from the client connection and check if\n * it's a known protocol. Then leave the data on the deferred\n * write buffer of the connection and returns a pointer to the protocol\n * structure\n */\nint probe_client_protocol(struct connection *cnx);\n\n/* Probe on a buffer */\nint probe_buffer(char* buf, int len,\n                 struct sslhcfg_protocols_item** proto_in,\n                 int proto_len,\n                 struct sslhcfg_protocols_item** proto_out\n                 );\n\n/* set the protocol to connect to in case of timeout */\nvoid set_ontimeout(const char* name);\n\n/* timeout_protocol\n *\n * Returns the protocol to connect to in case of timeout\n */\nstruct sslhcfg_protocols_item* timeout_protocol(void);\n\nvoid hexdump(msg_info, const char*, unsigned int);\n\n#endif\n"
        },
        {
          "name": "processes.c",
          "type": "blob",
          "size": 2.8896484375,
          "content": "/* \n  Processes that are common to sslh-ev and sslh-select\n \n# Copyright (C) 2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#include \"udp-listener.h\"\n#include \"tcp-listener.h\"\n#include \"processes.h\"\n#include \"probe.h\"\n#include \"log.h\"\n\n\nint tidy_connection(struct connection *cnx, struct loop_info* fd_info)\n{\n    int i;\n\n    for (i = 0; i < 2; i++) {\n        if (cnx->q[i].fd != -1) {\n            print_message(msg_fd, \"closing fd %d\\n\", cnx->q[i].fd);\n\n            watchers_del_read(fd_info->watchers, cnx->q[i].fd);\n            watchers_del_write(fd_info->watchers, cnx->q[i].fd);\n            close(cnx->q[i].fd);\n            if (cnx->q[i].deferred_data)\n                free(cnx->q[i].deferred_data);\n        }\n    }\n\n    if (cnx->type == SOCK_DGRAM)\n        udp_tidy(cnx, fd_info);\n\n    if (gap_remove_ptr(fd_info->probing_list, cnx, fd_info->num_probing) != -1)\n        fd_info->num_probing--;\n\n    collection_remove_cnx(fd_info->collection, cnx);\n    return 0;\n}\n\n\n\n/* Process a connection that is active in read */\n\nvoid cnx_read_process(struct loop_info* fd_info, int fd)\n{\n    cnx_collection* collection = fd_info->collection;\n    struct connection* cnx = collection_get_cnx_from_fd(collection, fd);\n    switch (cnx->type)  {\n    case SOCK_STREAM:\n        tcp_read_process(fd_info, fd);\n        break;\n\n    case SOCK_DGRAM:\n        udp_s2c_forward(cnx);\n        break;\n\n    default:\n        print_message(msg_int_error, \"cnx_read_process: Illegal connection type %d\\n\", cnx->type);\n        dump_connection(cnx);\n        exit(1);\n    }\n}\n\n\n/* Process a connection that accepts a socket\n * (For UDP, this means all traffic coming from remote clients)\n * Returns new connection object, or NULL\n * */\nstruct connection* cnx_accept_process(struct loop_info* fd_info, struct listen_endpoint* listen_socket)\n{\n    int fd = listen_socket->socketfd;\n    int type = listen_socket->type;\n    struct connection* cnx;\n\n    switch (type) {\n    case SOCK_STREAM:\n        cnx = accept_new_connection(fd, fd_info);\n        if (!cnx) return NULL;\n\n        break;\n\n    case SOCK_DGRAM:\n        cnx = udp_c2s_forward(fd, fd_info);\n        if (!cnx) return NULL;\n        break;\n\n    default:\n        print_message(msg_int_error, \"Inconsistent cnx type: %d\\n\", type);\n        exit(1);\n    }\n\n    int new_fd = cnx->q[0].fd;\n    watchers_add_read(fd_info->watchers, new_fd);\n    return cnx;\n}\n\n\n\n\n"
        },
        {
          "name": "processes.h",
          "type": "blob",
          "size": 1.25390625,
          "content": "#ifndef PROCESSES_H\n#define PROCESSES_H\n\n#include \"common.h\"\n#include \"collection.h\"\n#include \"gap.h\"\n\ntypedef struct connection* hash_item;\n#include \"hash.h\"\n\n/* Provided by event loop, sslh-ev or sslh-select, for implementation-dependant\n * data */\ntypedef struct watchers watchers; \n\n/* Global state for a loop */\nstruct loop_info {\n    int num_probing;     /* Number of connections currently probing \n                          * We use this to know if we need to time out of\n                          * select() */\n    gap_array* probing_list;  /* Pointers to cnx that are in probing mode */\n\n    hash* hash_sources; /* UDP remote sources previously encountered */\n\n    watchers* watchers;\n\n    cnx_collection* collection; /* Collection of connections linked to this loop */\n};\n\nvoid cnx_read_process(struct loop_info* fd_info, int fd);\nstruct connection* cnx_accept_process(struct loop_info* fd_info, struct listen_endpoint* listen_socket);\n\nint tidy_connection(struct connection *cnx, struct loop_info* fd_info);\n\n\n/* These must be declared in the loop handler, sslh-ev or sslh-select */\nvoid watchers_add_read(watchers* w, int fd);\nvoid watchers_del_read(watchers* w, int fd);\nvoid watchers_add_write(watchers* w, int fd);\nvoid watchers_del_write(watchers* w, int fd);\n\n#endif\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "sslh-conf.c",
          "type": "blob",
          "size": 87.9248046875,
          "content": "/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)\n * on Sun Dec 22 22:40:51 2024. \n\n# conf2struct: generate libconf parsers that read to structs\n# Copyright (C) 2018-2024  Yves Rutschle\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n*/\n\n#define _GNU_SOURCE\n#include <string.h>\n#ifdef LIBCONFIG\n#    include <libconfig.h>\n#endif\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <setjmp.h>\n#include \"sslh-conf.h\"\n#include \"argtable3.h\"\n#ifdef LIBPCRE\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\ntypedef struct {\n    PCRE2_SIZE rm_so;\n    PCRE2_SIZE rm_eo;\n} regmatch_t;\n#else\n#include <regex.h>\n#endif\n\n\n/* This gets included in the output .c file */\n\n\n/* Libconfig 1.4.9 is still used by major distributions\n * (e.g. CentOS7) and had a different name for\n * config_setting_lookup */\n#if LIBCONFIG_VER_MAJOR == 1\n#if LIBCONFIG_VER_MINOR == 4\n#if LIBCONFIG_VER_REVISION == 9\n#define config_setting_lookup config_lookup_from\n#endif\n#endif\n#endif\n\n\n/* config_type, lookup_fns, type2str are related, keep them together */\ntypedef enum {\n    CFG_BOOL,\n    CFG_INT,\n    CFG_INT64,\n    CFG_FLOAT,\n    CFG_STRING,\n    CFG_GROUP,\n    CFG_ARRAY,\n    CFG_LIST,\n} config_type;\n/* /config_type */\n\nconst char* type2str[] = {\n    \"boolean\",\n    \"int\",\n    \"int64\",\n    \"float\",\n    \"string\",\n    \"group\",\n    \"array\",\n    \"list\",\n};\n\ntypedef union {\n    int def_bool;\n    int def_int;\n    long long def_int64;\n    double def_float;\n    char* def_string;\n} any_val;\n\nstruct config_desc {\n    const char* name;\n    int type;\n    struct config_desc * sub_group; /* Table for compound types (list and group) */\n    void* arg_cl; /* command-line argument for this setting */\n    void* base_addr; /* Base of the structure (filled at runtime). Probably not useable for list elements */\n    size_t offset;  /* Offset of setting in the structure */\n    size_t offset_len; /* Offset of *_len field, for arrays and lists */\n    size_t offset_present; /* offset of *_is_present field, for optional settings */\n    size_t size;   /* Size of element, or size of group for groups and lists */\n    int array_type; /* type of array elements, when type == CFG_ARRAY */\n    int mandatory;\n    int optional;\n    any_val default_val;\n};\n\n#ifndef LIBCONFIG\n/* Stubs in case you don't want libconfig */\n\ntypedef void config_setting_t;\ntypedef int config_t;\n#define CONFIG_TRUE 1\n#define CONFIG_FALSE 0\n\n#define make_config_setting_lookup(type) \\\n    int config_setting_lookup_##type(const config_setting_t* a, const char* b, void* c) { \\\n        return 0; \\\n    }\n\n#define make_config_setting_get(type, ret_type) \\\n    ret_type config_setting_get_##type(const config_setting_t* a) { \\\n        return 0; \\\n    }\n\nenum {\n    CONFIG_TYPE_INT,\n    CONFIG_TYPE_BOOL,\n    CONFIG_TYPE_INT64,\n    CONFIG_TYPE_FLOAT,\n    CONFIG_TYPE_STRING\n};\n\nmake_config_setting_lookup(bool);\nmake_config_setting_lookup(int);\nmake_config_setting_lookup(int64);\nmake_config_setting_lookup(float);\nmake_config_setting_lookup(string);\n\nmake_config_setting_get(bool, int);\nmake_config_setting_get(int, int);\nmake_config_setting_get(int64, long long int);\nmake_config_setting_get(float, double);\nmake_config_setting_get(string, char*);\n\nconfig_setting_t* config_root_setting(config_t* c) {\n    return NULL;\n}\n\nconfig_setting_t* config_lookup(config_t* c, const char* b) {\n    return NULL;\n}\n\nvoid config_init(config_t* c) {\n    return;\n}\n\nchar* config_setting_name(config_setting_t* c) {\n    return NULL;\n}\n\nint config_setting_is_list(config_setting_t* c) {\n    return 0;\n}\n\nint config_setting_is_array(config_setting_t* c) {\n    return 0;\n}\n\nint config_setting_is_scalar(config_setting_t* c) {\n    return 0;\n}\n\nint config_setting_index(const config_setting_t *setting) {\n    return 0;\n}\n\nconfig_setting_t* config_setting_lookup(config_setting_t* a, char* b) {\n    return NULL;\n}\n\nint config_setting_remove(config_setting_t* cfg, char* name) {\n    return 0;\n}\n\nint config_setting_type(config_setting_t* s) {\n    return -1;\n}\n\nint config_setting_length(config_setting_t* a) {\n    return 0;\n}\n\nconfig_setting_t* config_setting_get_elem(config_setting_t* a, int i) {\n    return NULL;\n}\n\nint config_read_file(config_t* a, const char* b) {\n    return CONFIG_TRUE;\n}\n\nint config_error_line(config_t* c) {\n    return 0;\n}\n\nchar* config_error_text(config_t* c) {\n    return NULL;\n}\n#endif\n\nstatic jmp_buf c2s_asprintf_fail;\n\nstatic int c2s_asprintf(char **restrict strp, const char *restrict fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap,fmt);\n    int res = vasprintf(strp, fmt, ap);\n    va_end(ap);\n    if (res == -1) longjmp(c2s_asprintf_fail, res);\n    return res;\n}\n\n/* This is the same as config_setting_lookup_string() except\nit allocates a new string which belongs to the caller */\nstatic int myconfig_setting_lookup_stringcpy(\n        const config_setting_t* setting, \n        const char* name, \n        char** value)\n{\n    const char* str;\n    *value = NULL;\n    if (config_setting_lookup_string(setting, name, &str) == CONFIG_TRUE) {\n        c2s_asprintf(value, \"%s\", str);\n        return CONFIG_TRUE;\n    } else {\n        return CONFIG_FALSE;\n    }\n}\n\ntypedef int (*lookup_fn)(const config_setting_t*, const char*, void*);\nlookup_fn lookup_fns[] = {\n    (lookup_fn)config_setting_lookup_bool,\n    (lookup_fn)config_setting_lookup_int,\n    (lookup_fn)config_setting_lookup_int64,\n    (lookup_fn)config_setting_lookup_float,\n    (lookup_fn)myconfig_setting_lookup_stringcpy,\n    NULL,  /* CFG_GROUP */\n    NULL,  /* CFG_ARRAY */\n    NULL,  /* CFG_LIST */\n};\n\n/* Copy an any_val to arbitrary memory location */\n/* 0: success\n * <0: error */\nstatic int any_valcpy(config_type type, void* target, any_val val)\n{\n    switch(type) {\n    case CFG_BOOL:\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        *(double*)target = val.def_float;\n        break;\n\n    case CFG_STRING:\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 1;\n}\n\n\n/* Copy the value of a setting to an arbitrary memory that\n* must be large enough */\n/* 0: success\n * <0: error */\nstatic int settingcpy(config_type type, void* target, const config_setting_t* setting)\n{\n    any_val val;\n    char* str;\n\n    switch(type) {\n    case CFG_BOOL:\n        val.def_bool = config_setting_get_bool(setting);\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        val.def_int = config_setting_get_int(setting);\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        val.def_int64 = config_setting_get_int64(setting);\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        val.def_float = config_setting_get_float(setting);\n        *(double*)target = val.def_int64;\n        break;\n\n    case CFG_STRING:\n        c2s_asprintf(&str, \"%s\", config_setting_get_string(setting));\n        val.def_string = str;\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 0;\n}\n\n/* Copy the value of a command line arg to arbitrary memory\n* that must be large enough for the type */\n/* 0: success\n * <0: error */\nstatic int clcpy(config_type type, void* target, const void* cl_arg)\n{\n    any_val val;\n    char* str;\n\n    switch(type) {\n    case CFG_BOOL:\n        val.def_bool = (*(struct arg_lit**)cl_arg)->count;\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        val.def_int = (*(struct arg_int**)cl_arg)->ival[0];\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        val.def_int64 = (*(struct arg_int**)cl_arg)->ival[0];\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        val.def_float = (*(struct arg_dbl**)cl_arg)->dval[0];\n        *(double*)target = val.def_float;\n        break;\n\n    case CFG_STRING:\n        c2s_asprintf(&str, \"%s\", (*(struct arg_str**)cl_arg)->sval[0]);\n        val.def_string = str;\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 0;\n}\n\n/* Copy the value of a string argument to arbitary memory\n* location that must be large enough, converting on the way\n* (i.e. CFG_INT gets atoi() and so on) */\n/* 0: success\n * <0: error */\nstatic int stringcpy(config_type type, void* target, char* from)\n{\n    any_val val;\n    \n    switch(type) {\n    case CFG_BOOL:\n        val.def_bool = (*from != '0');\n        *(int*)target = val.def_bool;\n        break;\n\n    case CFG_INT:\n        val.def_int = strtol(from, NULL, 10);\n        *(int*)target = val.def_int;\n        break;\n\n    case CFG_INT64:\n        val.def_int64 = strtoll(from, NULL, 10);\n        *(long long*)target = val.def_int64;\n        break;\n\n    case CFG_FLOAT:\n        val.def_float = strtod(from, NULL);\n        *(double*)target = val.def_float;\n        break;\n\n    case CFG_STRING:\n        val.def_string = from;\n        *(char**)target = val.def_string;\n        break;\n\n    default:\n        fprintf(stderr, \"Unknown type specification %d\\n\", type);\n        return -1;\n    }\n    return 0;\n}\n\n\n/* Element to describe the target of a compound element\n* element: which config entry is being changed\n* match: if >0, index in pmatch to set\n*        if 0, don't match but init with value\n* value: constant if not matching */\nstruct compound_cl_target {\n    struct config_desc * element;\n    int match;\n    any_val value;\n};\n\n/* Element to describe one compound command line argument\n * An argument is string that gets matched against a regex,\n * then match-groups get evaluated to each targets[].\n * For lists, base_entry points to the config_setting so we\n * can append to it */\nstruct compound_cl_arg {\n    const char* regex;\n    struct arg_str** arg_cl; /* arg_str entry for this compound option */\n    struct config_desc * base_entry;\n    struct compound_cl_target* targets;\n\n    /* If override_desc is set, it points to the descriptor of the element in\n    the group which will be checked for override. Then, override_matchindex\n    indicates the command-line parameter match used to compare against\n    override_desc to know if this group is overridden. If override_matchindex\n    is 0, we don't match from the command-line but from a constant stored in\n    override_const instead */\n    struct config_desc * override_desc;\n    int override_matchindex;\n    char* override_const;\n};\n\n\nstruct arg_file* sslhcfg_conffile;\n struct arg_int* sslhcfg_verbose;\n struct arg_int* sslhcfg_verbose_config;\n struct arg_int* sslhcfg_verbose_config_error;\n struct arg_int* sslhcfg_verbose_connections;\n struct arg_int* sslhcfg_verbose_connections_try;\n struct arg_int* sslhcfg_verbose_connections_error;\n struct arg_int* sslhcfg_verbose_fd;\n struct arg_int* sslhcfg_verbose_packets;\n struct arg_int* sslhcfg_verbose_probe_info;\n struct arg_int* sslhcfg_verbose_probe_error;\n struct arg_int* sslhcfg_verbose_system_error;\n struct arg_int* sslhcfg_verbose_int_error;\n struct arg_lit* sslhcfg_version;\n struct arg_lit* sslhcfg_foreground;\n struct arg_lit* sslhcfg_inetd;\n struct arg_lit* sslhcfg_numeric;\n struct arg_lit* sslhcfg_transparent;\n struct arg_int* sslhcfg_timeout;\n struct arg_int* sslhcfg_udp_max_connections;\n struct arg_str* sslhcfg_user;\n struct arg_str* sslhcfg_pidfile;\n struct arg_str* sslhcfg_chroot;\n struct arg_str* sslhcfg_syslog_facility;\n struct arg_str* sslhcfg_logfile;\n struct arg_str* sslhcfg_on_timeout;\n struct arg_str* sslhcfg_prefix;\n \tstruct arg_str* sslhcfg_listen;\n \tstruct arg_str* sslhcfg_ssh;\n \tstruct arg_str* sslhcfg_tls;\n \tstruct arg_str* sslhcfg_ssl;\n \tstruct arg_str* sslhcfg_openvpn;\n \tstruct arg_str* sslhcfg_tinc;\n \tstruct arg_str* sslhcfg_wireguard;\n \tstruct arg_str* sslhcfg_xmpp;\n \tstruct arg_str* sslhcfg_http;\n \tstruct arg_str* sslhcfg_adb;\n \tstruct arg_str* sslhcfg_socks5;\n \tstruct arg_str* sslhcfg_syslog;\n \tstruct arg_str* sslhcfg_msrdp;\n \tstruct arg_str* sslhcfg_anyprot;\n struct arg_end* sslhcfg_end;\n\n                                                                                                                                                                 \nstatic struct config_desc table_sslhcfg_protocols[] = {\n\n\n        { \n            /* name */          \"name\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, name),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"host\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, host),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"port\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, port),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"service\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, service),\n            /* offset_len */    0,\n            /* offset_present */ offsetof(struct sslhcfg_protocols_item, service_is_present),\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      1, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"is_unix\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, is_unix),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"is_udp\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, is_udp),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"udp_timeout\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, udp_timeout),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 60 \n        },\n\n        { \n            /* name */          \"fork\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, fork),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"tfo_ok\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, tfo_ok),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"transparent\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, transparent),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"resolve_on_forward\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, resolve_on_forward),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"log_level\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, log_level),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 1 \n        },\n\n        { \n            /* name */          \"keepalive\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, keepalive),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"sni_hostnames\", \n            /* type */          CFG_ARRAY, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, sni_hostnames),\n            /* offset_len */    offsetof(struct sslhcfg_protocols_item, sni_hostnames_len),\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    CFG_STRING,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"alpn_protocols\", \n            /* type */          CFG_ARRAY, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, alpn_protocols),\n            /* offset_len */    offsetof(struct sslhcfg_protocols_item, alpn_protocols_len),\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    CFG_STRING,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"regex_patterns\", \n            /* type */          CFG_ARRAY, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, regex_patterns),\n            /* offset_len */    offsetof(struct sslhcfg_protocols_item, regex_patterns_len),\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    CFG_STRING,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"minlength\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_protocols_item, minlength),\n            /* offset_len */    0,\n            /* offset_present */ offsetof(struct sslhcfg_protocols_item, minlength_is_present),\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      1, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\t{ 0 }\n};\n                                                      \nstatic struct config_desc table_sslhcfg_listen[] = {\n\n\n        { \n            /* name */          \"host\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_listen_item, host),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"port\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_listen_item, port),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"is_udp\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_listen_item, is_udp),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"is_unix\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_listen_item, is_unix),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"keepalive\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_listen_item, keepalive),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\t{ 0 }\n};\n                                                                                                                                                                                                                                           \nstatic struct config_desc table_sslhcfg[] = {\n\n\n        { \n            /* name */          \"verbose\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"verbose_config\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_config,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_config),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"verbose_config_error\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_config_error,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_config_error),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 3 \n        },\n\n        { \n            /* name */          \"verbose_connections\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_connections,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_connections),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 3 \n        },\n\n        { \n            /* name */          \"verbose_connections_try\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_connections_try,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_connections_try),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"verbose_connections_error\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_connections_error,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_connections_error),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 3 \n        },\n\n        { \n            /* name */          \"verbose_fd\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_fd,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_fd),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"verbose_packets\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_packets,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_packets),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"verbose_probe_info\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_probe_info,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_probe_info),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"verbose_probe_error\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_probe_error,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_probe_error),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 3 \n        },\n\n        { \n            /* name */          \"verbose_system_error\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_system_error,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_system_error),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 3 \n        },\n\n        { \n            /* name */          \"verbose_int_error\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_verbose_int_error,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, verbose_int_error),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 3 \n        },\n\n        { \n            /* name */          \"version\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_version,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, version),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"foreground\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_foreground,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, foreground),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"inetd\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_inetd,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, inetd),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"numeric\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_numeric,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, numeric),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"transparent\", \n            /* type */          CFG_BOOL, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_transparent,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, transparent),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_bool = 0 \n        },\n\n        { \n            /* name */          \"timeout\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_timeout,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, timeout),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 5 \n        },\n\n        { \n            /* name */          \"udp_max_connections\", \n            /* type */          CFG_INT, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_udp_max_connections,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, udp_max_connections),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(int), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 1024 \n        },\n\n        { \n            /* name */          \"user\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_user,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, user),\n            /* offset_len */    0,\n            /* offset_present */ offsetof(struct sslhcfg_item, user_is_present),\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      1, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"pidfile\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_pidfile,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, pidfile),\n            /* offset_len */    0,\n            /* offset_present */ offsetof(struct sslhcfg_item, pidfile_is_present),\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      1, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"chroot\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_chroot,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, chroot),\n            /* offset_len */    0,\n            /* offset_present */ offsetof(struct sslhcfg_item, chroot_is_present),\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      1, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"syslog_facility\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_syslog_facility,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, syslog_facility),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = \"auth\" \n        },\n\n        { \n            /* name */          \"logfile\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_logfile,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, logfile),\n            /* offset_len */    0,\n            /* offset_present */ offsetof(struct sslhcfg_item, logfile_is_present),\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      1, \n            /* default_val*/    .default_val.def_string = NULL \n        },\n\n        { \n            /* name */          \"on_timeout\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_on_timeout,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, on_timeout),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = \"ssh\" \n        },\n\n        { \n            /* name */          \"prefix\", \n            /* type */          CFG_STRING, \n            /* sub_group*/      NULL,\n            /* arg_cl */        & sslhcfg_prefix,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, prefix),\n            /* offset_len */    0,\n            /* offset_present */ 0,\n            /* size */          sizeof(char*), \n            /* array_type */    -1,\n            /* mandatory */     0, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_string = \"\" \n        },\n\n        { \n            /* name */          \"listen\", \n            /* type */          CFG_LIST, \n            /* sub_group*/      table_sslhcfg_listen,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, listen),\n            /* offset_len */    offsetof(struct sslhcfg_item, listen_len),\n            /* offset_present */ 0,\n            /* size */          sizeof(struct sslhcfg_listen_item), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\n        { \n            /* name */          \"protocols\", \n            /* type */          CFG_LIST, \n            /* sub_group*/      table_sslhcfg_protocols,\n            /* arg_cl */        NULL,\n            /* base_addr */     NULL,\n            /* offset */        offsetof(struct sslhcfg_item, protocols),\n            /* offset_len */    offsetof(struct sslhcfg_item, protocols_len),\n            /* offset_present */ 0,\n            /* size */          sizeof(struct sslhcfg_protocols_item), \n            /* array_type */    -1,\n            /* mandatory */     1, \n            /* optional */      0, \n            /* default_val*/    .default_val.def_int = 0 \n        },\n\t{ 0 }\n};\nstatic struct compound_cl_target sslhcfg_anyprot_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"anyprot\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_msrdp_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"msrdp\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_syslog_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"syslog\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_socks5_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"socks5\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_adb_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"adb\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_http_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"http\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_xmpp_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"xmpp\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_wireguard_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"wireguard\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ & table_sslhcfg_protocols[8], 0, .value.def_bool = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_tinc_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"tinc\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ & table_sslhcfg_protocols[8], 0, .value.def_bool = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_openvpn_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"openvpn\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ & table_sslhcfg_protocols[8], 0, .value.def_bool = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_ssl_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"tls\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ & table_sslhcfg_protocols[8], 0, .value.def_bool = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_tls_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"tls\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ & table_sslhcfg_protocols[8], 0, .value.def_bool = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_ssh_targets [] = {\n\t{ & table_sslhcfg_protocols[0], 0, .value.def_string = \"ssh\" },\n\t{ & table_sslhcfg_protocols[1], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[2], 2, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_protocols[7], 0, .value.def_bool = 1 },\n\t{ & table_sslhcfg_protocols[11], 0, .value.def_int = 1 },\n\t{ & table_sslhcfg_protocols[8], 0, .value.def_bool = 1 },\n\t{ 0 }\n};\n\nstatic struct compound_cl_target sslhcfg_listen_targets [] = {\n\t{ & table_sslhcfg_listen[0], 1, .value.def_string = \"0\" },\n\t{ & table_sslhcfg_listen[1], 2, .value.def_string = \"0\" },\n\t{ 0 }\n};\n\nstatic struct compound_cl_arg compound_cl_args[] = {\n        {   /* arg: listen */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_listen,\n            .base_entry =      & table_sslhcfg [26],\n            .targets =         sslhcfg_listen_targets,\n\n\n            .override_desc =   NULL,\n            .override_matchindex = 0,\n            .override_const = NULL,\n        },\n\n        {   /* arg: ssh */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_ssh,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_ssh_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"ssh\",\n        },\n\n        {   /* arg: tls */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_tls,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_tls_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"tls\",\n        },\n\n        {   /* arg: ssl */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_ssl,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_ssl_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"tls\",\n        },\n\n        {   /* arg: openvpn */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_openvpn,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_openvpn_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"openvpn\",\n        },\n\n        {   /* arg: tinc */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_tinc,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_tinc_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"tinc\",\n        },\n\n        {   /* arg: wireguard */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_wireguard,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_wireguard_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"wireguard\",\n        },\n\n        {   /* arg: xmpp */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_xmpp,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_xmpp_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"xmpp\",\n        },\n\n        {   /* arg: http */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_http,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_http_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"http\",\n        },\n\n        {   /* arg: adb */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_adb,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_adb_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"adb\",\n        },\n\n        {   /* arg: socks5 */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_socks5,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_socks5_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"socks5\",\n        },\n\n        {   /* arg: syslog */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_syslog,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_syslog_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"syslog\",\n        },\n\n        {   /* arg: msrdp */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_msrdp,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_msrdp_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"msrdp\",\n        },\n\n        {   /* arg: anyprot */\n            .regex =           \"(.+):(\\\\w+)\",\n            .arg_cl =          & sslhcfg_anyprot,\n            .base_entry =      & table_sslhcfg [27],\n            .targets =         sslhcfg_anyprot_targets,\n\n\n            .override_desc =   & table_sslhcfg_protocols [0],\n            .override_matchindex = 0,\n            .override_const = \"anyprot\",\n        },\n\n\t{ 0 }\n};\n\n\n/* Enable debug to follow the parsing of tables */\n#if 0\n#define TRACE_READ(x) printf x\n#define TRACE_READ_PRINT_SETTING 1\n#else\n#define TRACE_READ(x)\n#define TRACE_READ_PRINT_SETTING 0\n#endif\n\n/* Enable debug to follow the parsing of compound options */\n#if 0\n#define TRACE_CMPD(x) printf x\n#define TRACE_CMPD_PRINT_SETTING 1\n#else\n#define TRACE_CMPD(x)\n#define TRACE_CMPD_PRINT_SETTING 0\n#endif\n\nstatic void print_setting(config_type type, void* val)\n{\n    if (TRACE_READ_PRINT_SETTING || TRACE_CMPD_PRINT_SETTING) {\n        switch(type) {\n        case CFG_BOOL:\n        case CFG_INT:\n            printf(\"%d\", *(int*)val);\n            break;\n        case CFG_INT64:\n            printf(\"%lld\", *(long long*)val);\n            break;\n        case CFG_FLOAT:\n            printf(\"%f\", *(double*)val);\n            break;\n        case CFG_STRING:\n            printf(\"`%s'\", *(char**)val);\n            break;\n        case CFG_GROUP:\n        case CFG_LIST:\n        case CFG_ARRAY:\n            break;\n        }\n    }\n}\n\n/* Changes all dashes to underscores in a string of\n* vice-versa */\nstatic void strswap_ud(const char target, char* str)\n{\n    char* c;\n    for (c = str; *c; c++)\n        if (*c == (target == '_' ? '-' : '_'))\n             *c = (target == '_' ? '_' : '-');\n}\n\n/* Same as config_setting_lookup() but looks up with dash or\n* underscore so `my_setting` and `my-setting` match the same */\nstatic config_setting_t* config_setting_lookup_ud(config_setting_t* cfg, struct config_desc* desc)\n{\n    config_setting_t* setting;\n    char name[strlen(desc->name)+1];;\n    strcpy(name, desc->name);\n\n    strswap_ud('_', name);\n    setting = config_setting_lookup(cfg, name);\n    if (setting)\n        return setting;\n\n    strswap_ud('-', name);\n    setting = config_setting_lookup(cfg, name);\n    return setting;\n}\n\nstatic int lookup_typed_ud(config_setting_t* cfg, void* target, struct config_desc *desc)\n{\n    lookup_fn lookup_fn = lookup_fns[desc->type];\n    char name[strlen(desc->name)+1];;\n    strcpy(name, desc->name);\n\n    strswap_ud('_', name);\n    if (lookup_fn(cfg, name, ((char*)target) + desc->offset) == CONFIG_TRUE)\n        return CONFIG_TRUE;\n\n    strswap_ud('-', name);\n    return lookup_fn(cfg, name, ((char*)target) + desc->offset);\n}\n\n/* Removes a setting, trying both underscores and dashes as\n* name (so deleting 'my-setting' deletes both 'my_setting'\n* and 'my-setting') */\nstatic int setting_delete_ud(config_setting_t* cfg, struct config_desc *desc)\n{\n    char name[strlen(desc->name)+1];;\n    strcpy(name, desc->name);\n\n    strswap_ud('_', name);\n    if (config_setting_remove(cfg, name) == CONFIG_TRUE)\n        return CONFIG_TRUE;\n\n    strswap_ud('-', name);\n    return config_setting_remove(cfg, name);\n}\n\n/* When traversing configuration, allocate memory for plural\n* types, init for scalars */\nstatic void read_block_init(void* target, config_setting_t* cfg, struct config_desc* desc)\n{\n    size_t len = 0;\n    void* block;\n    config_setting_t* setting;\n\n    switch (desc->type) {\n    case CFG_LIST:\n    case CFG_ARRAY:\n        if (cfg) {\n            setting = config_setting_lookup_ud(cfg, desc);\n            if (setting)\n                len = config_setting_length(setting);\n        } \n        block = calloc(len, desc->size);\n\n        *(size_t*)(((char*)target) + desc->offset_len) = len;\n        *(void**)(((char*)target) + desc->offset) = block;\n        TRACE_READ((\" sizing for %zu elems \", len));\n        break;\n\n    case CFG_GROUP:\n        block = calloc(1, desc->size);\n        *(void**)(((char*)target) + desc->offset) = block;\n        TRACE_READ((\" sizing for %zu elems \", len));\n        break;\n\n    default: \n        /* scalar types: copy default */\n        memcpy(((char*)target) + desc->offset, &desc->default_val, desc->size);\n        TRACE_READ((\"setting %s to default \", desc->name));\n        print_setting(desc->type,(char*)target + desc->offset);\n        break;\n    }\n}\n\nstatic int read_block(config_setting_t* cfg, \n                      void* target, \n                      struct config_desc* desc, \n                      char** errmsg);\n\n/* When traversing configuration, set value from config\n* file, or command line \n* return: 0 if not set, 1 if set somehow */\nstatic int read_block_setval(void* target, \n                             config_setting_t* cfg, \n                             struct config_desc* desc, \n                             char** errmsg)\n{\n    int i;\n    size_t len = 0;\n    void* block;\n    int in_cfg = 0, in_cl = 0; /* Present in config file?  present on command line? */\n    config_setting_t* setting = NULL;\n\n    switch (desc->type) {\n    case CFG_LIST:\n        if (cfg) {\n            setting = config_setting_lookup_ud(cfg, desc);\n            if (setting) \n                len = config_setting_length(setting);\n            block = *(void**)(((char*)target) + desc->offset);\n            for (i = 0; i < len; i++) {\n                config_setting_t* elem = config_setting_get_elem(setting, i);\n                if (!read_block(elem, (char*)block + desc->size * i, desc->sub_group, errmsg))\n                    return 0;\n            }\n        }\n        break;\n\n    case CFG_ARRAY:\n        if (cfg) {\n            setting = config_setting_lookup_ud(cfg, desc);\n            if (setting)\n                len = config_setting_length(setting);\n            block = *(void**)(((char*)target) + desc->offset);\n            for (i = 0; i < len; i++) {\n                config_setting_t* elem = config_setting_get_elem(setting, i);\n                settingcpy(desc->array_type, (char*)block + desc->size * i, elem);\n                TRACE_READ((\"[%d] = \", i));\n                print_setting(desc->array_type, (char*)block + desc->size *i); TRACE_READ((\"\\n\"));\n            }\n            setting_delete_ud(cfg, desc);\n        }\n        break;\n\n    case CFG_GROUP:\n        if (cfg) setting = config_setting_lookup_ud(cfg, desc);\n        block = *(void**)(((char*)target) + desc->offset);\n        if (!read_block(setting, block, desc->sub_group, errmsg)) return 0;\n        break;\n\n    default: /* scalar types */\n        TRACE_READ((\" `%s'\", desc->name));\n        if (cfg && config_setting_lookup_ud(cfg, desc)) {\n            TRACE_READ((\" in config file: \"));\n            /* setting is present in cfg, look it up */\n            if (lookup_typed_ud(cfg, target, desc) != CONFIG_TRUE) {\n                TRACE_READ((\" but wrong type (expected %s) \", type2str[desc->type]));\n                c2s_asprintf(errmsg, \"Option \\\"%s\\\" wrong type, expected %s\\n\", \n                    desc->name, type2str[desc->type]);\n                return 0;\n            }\n            print_setting(desc->type, (((char*)target) + desc->offset));\n            setting_delete_ud(cfg, desc);\n            in_cfg = 1;\n        } else {\n            TRACE_READ((\" not in config file\"));\n        }\n        if (desc->arg_cl && (*(struct arg_int**)desc->arg_cl)->count) {\n            clcpy(desc->type, ((char*)target) + desc->offset, desc->arg_cl);\n            TRACE_READ((\", command line sets to \"));\n            print_setting(desc->type, (((char*)target) + desc->offset));\n            in_cl = 1;\n        } else {\n            TRACE_READ((\", not in command line\"));\n        }\n        if (!(in_cfg || in_cl)) {\n            TRACE_READ((\"\\n\"));\n            return 0;\n        }\n        TRACE_READ((\"\\n\"));\n        break;\n    }\n    return 1;\n}\n\n/* Set *_is_present flag for target */\nstatic void target_is_present(void* target, struct config_desc* desc, int val)\n{\n    if (desc->optional) {  /* _is_present only exists in target for optional settings */\n        TRACE_READ((\" mark as set\"));\n        *(int*)((char*)target + desc->offset_present) = val;\n    }\n}\n\n/* traverses the configuration; allocates memory if needed,\n* set to default if exists,\n* fill from configuration file if present, overrides or set from\n* command line if present, verifies mandatory options have\n* been set\n* target: base address of the group being processed\n*/\nstatic int read_block(config_setting_t* cfg, void* target, struct config_desc* desc, char** errmsg)\n{\n    int set;\n\n    for (; desc->name; desc++) {\n        TRACE_READ((\"reading %s%s%s: \", desc->optional ? \"optional \" : \"\", desc->mandatory ? \"mandatory \" : \"\",  desc->name));\n        desc->base_addr = target;\n\n\n        read_block_init(target, cfg, desc);\n        set = read_block_setval(target, cfg, desc, errmsg);\n\n        if (!set && desc->mandatory) {\n            c2s_asprintf(errmsg, \"Mandatory option \\\"%s\\\" not found\", desc->name);\n            return 0;\n        }\n\n        if (desc->optional) target_is_present(target, desc, set && desc->optional);\n    }\n    return 1;\n}\n\n/* Copy regex match into newly allocated string\n * out: newly allocated string (caller has to free it)\n * in: string into which the match was made\n * pmatch: the match to extract */\nstatic void pmatchcpy(char** out, const char* in, regmatch_t* pmatch)\n{\n    int len = pmatch->rm_eo - pmatch->rm_so;\n    *out = calloc(len+1, 1);\n    memcpy(*out, in + pmatch->rm_so, len);\n}\n\n/* Processes a list of targets within one element, setting\n* the values in the target setting \n* target: where to put the data\n* arg: CL arg containing the target fields\n* clval: command line parameter\n* pmatch: regex match array into clval\n*/\nstatic int set_target_fields(void* target_addr, struct compound_cl_arg* arg, const char* clval, regmatch_t* pmatch)\n{\n    int pmatch_cnt = 1;\n    struct compound_cl_target* target;\n\n    for (target = arg->targets; target->element; target++) {\n        struct config_desc * element = target->element;\n        if (target->match) {\n            TRACE_CMPD((\"    match %d rm_so %d rm_eo %d type %d\\n\", \n                        pmatch_cnt, pmatch[pmatch_cnt].rm_so, pmatch[pmatch_cnt].rm_eo, element->type ));\n            if (pmatch[pmatch_cnt].rm_so == -1) {\n                /* This should not happen as regexec() did\n                * match before, unless there is a\n                * discrepency between the regex and the\n                * number of backreferences */\n                return 0;\n            }\n            char* str;\n            pmatchcpy(&str, clval, &pmatch[pmatch_cnt]);\n\n            stringcpy(element->type, (char*)target_addr + element->offset, str);\n            TRACE_CMPD((\"setting %p+%zu to : \", target_addr , element->offset));\n            print_setting(element->type , (char*)target_addr + element->offset);\n            TRACE_CMPD((\"\\n\"));\n\n            /* str is temporary buffer for type conversion, except for strings which we\n            * need to keep around so don't free them */\n            if (element->type != CFG_STRING)\n                free(str);\n            pmatch_cnt++;\n        } else { /* don't use matching, set constant */\n            any_valcpy(element->type, (char*)target_addr + element->offset,\n                        target->value);\n        }\n    }\n\n    return 1;\n}\n\n/* Goes over a list, finds if a group matches the specified string and overwrite\n* it if it does. */\nstatic int override_on_str(struct compound_cl_arg* arg, const char* str, regmatch_t* pmatch)\n{\n    struct config_desc * desc = arg->base_entry;\n    void* list_base = *(void**)(desc->base_addr + desc->offset);\n    size_t list_len = *(size_t*)(desc->base_addr + desc->offset_len);\n    size_t elem_size = desc->size;\n    int i;\n\n    for (i = 0; i < list_len; i++) {\n        char* group_base = ((char*)list_base + i * elem_size);\n\n        char* cfg_member = *(char**)(group_base + arg->override_desc->offset);\n        if (!strcmp(str, cfg_member)) {\n            memset(group_base, 0, elem_size);\n            struct arg_str* arg_cl = *arg->arg_cl;\n            if (!set_target_fields(group_base, arg, arg_cl->sval[0], pmatch))\n                return 0;\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Goes over a list and override group if needed */\nstatic int override_elem(struct compound_cl_arg* arg, int arg_index, regmatch_t* pmatch) \n{\n    char* str;\n    int allocated = 0;\n    int res;\n\n    if (arg->override_matchindex) {\n        struct arg_str* arg_cl = *arg->arg_cl;\n        pmatchcpy(&str, arg_cl->sval[arg_index], &pmatch[arg->override_matchindex]);\n        allocated = 1;\n    } else {\n        str = arg->override_const;\n    }\n\n    res = override_on_str(arg, str, pmatch);\n\n    if (allocated) free(str);\n\n    return res;\n}\n\n/* Add an argument to a list, overriding if required or\n* appending otherwise */\nstatic int add_arg_to_list(struct compound_cl_arg* arg, int arg_index, regmatch_t* pmatch)\n{\n    struct config_desc * desc = arg->base_entry;\n    void* list_base = *(void**)(desc->base_addr + desc->offset);\n    size_t list_len = *(size_t*)(desc->base_addr + desc->offset_len);\n    size_t elem_size = desc->size;\n\n    /* are we overriding an existing group? */\n    if (arg->override_desc)\n        if (override_elem(arg, arg_index, pmatch))\n            return 1;\n\n    /* override not found or no override, append element and * zero it out */\n    list_len++;\n    list_base = realloc(list_base, list_len * elem_size);\n    *(size_t*)(desc->base_addr + desc->offset_len) = list_len;\n    *(void**)(desc->base_addr + desc->offset) = list_base;\n    memset(list_base + (list_len - 1) * elem_size, 0, elem_size);\n\n    struct arg_str* arg_cl = *arg->arg_cl;\n    if (!set_target_fields((char*)list_base + (list_len - 1) * elem_size, arg, arg_cl->sval[arg_index], pmatch)) {\n        return 0;\n    }\n    return 1;\n}\n\n/* TODO: pass pmatch size as parameter or something */\n#define MAX_MATCH 10\n\n#ifndef LIBPCRE\nstatic int regcompmatch_posix( regmatch_t* pmatch, \n                        struct compound_cl_arg* arg, \n                        int arg_index, \n                        char** errmsg)\n{\n    char* regerr;\n    struct arg_str* arg_cl = *arg->arg_cl;\n    regex_t preg;\n    int res = regcomp(&preg, arg->regex, REG_EXTENDED);\n    if (res) {\n        int errlen = regerror(res, &preg, NULL, 0);\n        regerr = malloc(errlen);\n        regerror(res, &preg, regerr, errlen);\n        c2s_asprintf(errmsg, \"compiling pattern /%s/:%s\", arg->regex, regerr);\n        free(regerr);\n        return 0;\n    }\n    res = regexec(&preg, arg_cl->sval[arg_index], MAX_MATCH, &pmatch[0], 0);\n    if (res) {\n        c2s_asprintf(errmsg, \"--%s %s: Illegal argument\", \n        arg_cl->hdr.longopts, \n        arg->regex); \n        return 0;\n    }\n    return 1;\n}\n#endif\n\n\n#ifdef LIBPCRE\nstatic int regcompmatch_pcre2( regmatch_t* pmatch,\n                        struct compound_cl_arg* arg,\n                        int arg_index,\n                        char** errmsg)\n{\n    int i, error;\n    pcre2_code* pcre;\n    PCRE2_UCHAR8 err_str[120];  /* ample, according to pcre2api(3) */\n    pcre2_match_data* matches;\n    PCRE2_SIZE error_offset;\n    struct arg_str* arg_cl = *arg->arg_cl;\n\n    pcre = pcre2_compile((PCRE2_SPTR8)arg->regex, PCRE2_ZERO_TERMINATED, 0, &error, &error_offset, NULL);\n    if (!pcre) {\n        pcre2_get_error_message(error, err_str, sizeof(err_str));\n        c2s_asprintf(errmsg, \"compiling pattern /%s/:%d: %s at offset %ld\\n\",\n                arg->regex, error, err_str, error_offset);\n        return 0;\n    }\n\n    matches = pcre2_match_data_create(MAX_MATCH, NULL);\n    int res = pcre2_match(pcre, (PCRE2_SPTR8)arg_cl->sval[arg_index], PCRE2_ZERO_TERMINATED,\n                          0, 0, matches, NULL);\n    if (res < 0) {\n        pcre2_get_error_message(res, err_str, sizeof(err_str));\n        c2s_asprintf(errmsg, \"matching %s =~ /%s/:%d: %s\\n\", \n                          arg_cl->sval[arg_index], arg->regex, res, err_str);\n        return 0;\n    }\n\n    PCRE2_SIZE *ovec = pcre2_get_ovector_pointer(matches);\n    if (res > MAX_MATCH) res = MAX_MATCH;\n    /* From pcre2posix.c */\n    for (i = 0; i < res; i++) {\n        pmatch[i].rm_so = (ovec[i*2] == PCRE2_UNSET) ? -1 : ovec[i*2];\n        pmatch[i].rm_eo = (ovec[i*2+1] == PCRE2_UNSET) ? -1 : ovec[i*2+1];\n    }\n    for (; i < MAX_MATCH; i++) pmatch[i].rm_so = pmatch[i].rm_eo = -1;\n\n    pcre2_match_data_free(matches);\n    return 1;\n}\n#endif\n\n\n/* Regex fiddling: uses info in arg to fill pmatch\n* arg: description of the command line argument\n* arg_index: occurence of this argument on the command line\n*/\nstatic int regcompmatch(regmatch_t* pmatch,\n                        struct compound_cl_arg* arg,\n                        int arg_index,\n                        char** errmsg)\n{\n#if LIBPCRE\n    return regcompmatch_pcre2(pmatch, arg, arg_index, errmsg);\n#else\n    return regcompmatch_posix(pmatch, arg, arg_index, errmsg);\n#endif\n}\n\n/* Read compound options described in `arg`, from `cfg`, to `setting` */\nstatic int read_compounds(config_setting_t* cfg, \n                          void* setting, \n                          struct compound_cl_arg* arg, \n                          char** errmsg)\n{\n    int arg_i;\n    struct arg_str* arg_cl;\n    regmatch_t pmatch[MAX_MATCH];\n\n    for (; arg->regex; arg++) {\n        arg_cl = *arg->arg_cl;\n        TRACE_CMPD((\"Compound %s occurs %d : \", arg_cl->hdr.longopts, arg_cl->count));\n        for (arg_i = 0; arg_i < arg_cl->count; arg_i++) {\n            if (!regcompmatch(&pmatch[0], arg, arg_i, errmsg))\n                return 0;\n            TRACE_CMPD((\"`%s' matched\\n\", arg_cl->sval[arg_i]));\n\n            switch (arg->base_entry->type) {\n            case CFG_LIST:\n                /* In a list, find the end or the element to override */\n                if (!add_arg_to_list(arg, arg_i, pmatch)) {\n                    return 0;\n                }\n                break;\n\n            /* Semantics for CFG_ARRAY TBD */\n\n            case CFG_GROUP:\n                if (!set_target_fields(\n                            /* base_addr is the same for all elements in the group */\n                            arg->targets[0].element->base_addr, \n                            arg, \n                            arg_cl->sval[arg_i], \n                            pmatch))\n                    return 0;\n\n            default:\n                TRACE_CMPD((\"error, compound on type %d\\n\", arg->base_entry->type));\n                break;\n            }\n        }\n        TRACE_CMPD((\"done %s\\n\", arg_cl->hdr.longopts));\n    }\n    return 1;\n}\n\n/* read config file `filename` into `c` */\nstatic int c2s_parse_file(const char* filename, config_t* c, char**errmsg)\n{\n    /* Read config file */\n    if (config_read_file(c, filename) == CONFIG_FALSE) {\n        if (config_error_line(c) != 0) {\n           c2s_asprintf(errmsg, \"%s:%d:%s\", \n                    filename,\n                    config_error_line(c),\n                    config_error_text(c));\n           return 0;\n        }\n        c2s_asprintf(errmsg, \"%s:%s\", filename, config_error_text(c));\n        return 0;\n    }\n    return 1;\n}\n\n/* Allocates a new string that represents the setting value, which must be a scalar */\nstatic void scalar_to_string(char** strp, config_setting_t* s)\n{\n    switch(config_setting_type(s)) {\n    case CONFIG_TYPE_INT:\n        c2s_asprintf(strp, \"%d\\n\", config_setting_get_int(s));\n        break;\n\n    case CONFIG_TYPE_BOOL:\n        c2s_asprintf(strp, \"%s\\n\", config_setting_get_bool(s) ?  \"[true]\" : \"[false]\" );\n        break;\n\n    case CONFIG_TYPE_INT64:\n        c2s_asprintf(strp, \"%lld\\n\", config_setting_get_int64(s));\n        break;\n\n    case CONFIG_TYPE_FLOAT:\n        c2s_asprintf(strp, \"%lf\\n\", config_setting_get_float(s));\n        break;\n\n    case CONFIG_TYPE_STRING:\n        c2s_asprintf(strp, \"%s\\n\", config_setting_get_string(s));\n        break;\n\n    default: /* This means a bug */\n        fprintf(stderr, \"Unexpected type %d\\n\", config_setting_type(s));\n        exit(1);\n    }\n}\n\n/* Typesets all the settings in a configuration as a\n* newly-allocated string. The string management is caller's\n* responsability. \n* Returns the number of scalars in the configuration */\nstatic int cfg_as_string(config_setting_t* parent, const char* path, char** strp)\n{\n    int i, len, res = 0;\n    config_setting_t* child;\n    char* subpath, *value, *old;\n    const char* name;\n\n    len = config_setting_length(parent);\n    for (i = 0; i < len; i++) {\n        child = config_setting_get_elem(parent, i);\n        name = config_setting_name(child);\n        if (!name) name = \"\";\n\n        if(config_setting_is_list(parent) ||\n           config_setting_is_array(parent)) {\n            c2s_asprintf(&subpath, \"%s[%d]%s\", path, config_setting_index(child), name);\n        } else {\n            c2s_asprintf(&subpath, \"%s/%s\", path, name);\n        }\n\n        if (config_setting_is_scalar(child)) {\n            scalar_to_string(&value, child);\n\n            /* Add value to the output string  */\n            if (*strp) {\n                c2s_asprintf(&old, \"%s\", *strp);\n                free(*strp);\n            }  else {\n                c2s_asprintf(&old, \"%s\", \"\");\n            }\n            c2s_asprintf(strp, \"%s%s:%s\", old, subpath, value);\n            free(value);\n            free(old);\n\n            res++; /* At least one scalar was found */\n        } else {\n            /* It's an aggregate -- descend into it */\n            res += cfg_as_string(child, subpath, strp);\n        }\n\n        free(subpath);\n    }\n    return res;\n}\n\n\n/* 0: success\n   <0: error */\nint sslhcfg_cl_parse(int argc, char* argv[], struct sslhcfg_item* cfg)\n{\n    int nerrors, res;\n    config_t c;\n    char* errmsg;\n    config_setting_t* s;\n    void* argtable[] = {\n            #ifdef LIBCONFIG\n        sslhcfg_conffile = arg_filen(\"F\", \"config\", \"<file>\", 0, 1, \"Specify configuration file\"),\n    #endif\n         sslhcfg_verbose = arg_intn(\"v\", \"verbose\", \"<n>\", 0, 1, \"Override all verbosness options\"),\n         sslhcfg_verbose_config = arg_intn(NULL, \"verbose-config\", \"<n>\", 0, 1, \"Print configuration at startup\"),\n         sslhcfg_verbose_config_error = arg_intn(NULL, \"verbose-config-error\", \"<n>\", 0, 1, \"Print configuration errors\"),\n         sslhcfg_verbose_connections = arg_intn(NULL, \"verbose-connections\", \"<n>\", 0, 1, \"Trace established incoming address to forward address\"),\n         sslhcfg_verbose_connections_try = arg_intn(NULL, \"verbose-connections-try\", \"<n>\", 0, 1, \"Connection errors\"),\n         sslhcfg_verbose_connections_error = arg_intn(NULL, \"verbose-connections-error\", \"<n>\", 0, 1, \"Connection attempts towards targets\"),\n         sslhcfg_verbose_fd = arg_intn(NULL, \"verbose-fd\", \"<n>\", 0, 1, \"File descriptor activity, open/close/whatnot\"),\n         sslhcfg_verbose_packets = arg_intn(NULL, \"verbose-packets\", \"<n>\", 0, 1, \"Hexdump packets on which probing is done\"),\n         sslhcfg_verbose_probe_info = arg_intn(NULL, \"verbose-probe-info\", \"<n>\", 0, 1, \"Trace the probe process\"),\n         sslhcfg_verbose_probe_error = arg_intn(NULL, \"verbose-probe-error\", \"<n>\", 0, 1, \"Failures and problems during probing\"),\n         sslhcfg_verbose_system_error = arg_intn(NULL, \"verbose-system-error\", \"<n>\", 0, 1, \"System call failures\"),\n         sslhcfg_verbose_int_error = arg_intn(NULL, \"verbose-int-error\", \"<n>\", 0, 1, \"Internal errors that should never happen\"),\n         sslhcfg_version = arg_litn(\"V\", \"version\", 0, 1, \"Print version information and exit\"),\n         sslhcfg_foreground = arg_litn(\"f\", \"foreground\", 0, 1, \"Run in foreground instead of as a daemon\"),\n         sslhcfg_inetd = arg_litn(\"i\", \"inetd\", 0, 1, \"Run in inetd mode: use stdin/stdout instead of network listen\"),\n         sslhcfg_numeric = arg_litn(\"n\", \"numeric\", 0, 1, \"Print IP addresses and ports as numbers\"),\n         sslhcfg_transparent = arg_litn(NULL, \"transparent\", 0, 1, \"Set up as a transparent proxy\"),\n         sslhcfg_timeout = arg_intn(\"t\", \"timeout\", \"<n>\", 0, 1, \"Set up timeout before connecting to default target\"),\n         sslhcfg_udp_max_connections = arg_intn(NULL, \"udp-max-connections\", \"<n>\", 0, 1, \"Number of concurrent UDP connections\"),\n         sslhcfg_user = arg_strn(\"u\", \"user\", \"<str>\", 0, 1, \"Username to change to after set-up\"),\n         sslhcfg_pidfile = arg_strn(\"P\", \"pidfile\", \"<file>\", 0, 1, \"Path to file to store PID of current instance\"),\n         sslhcfg_chroot = arg_strn(\"C\", \"chroot\", \"<path>\", 0, 1, \"Root to change to after set-up\"),\n         sslhcfg_syslog_facility = arg_strn(NULL, \"syslog-facility\", \"<str>\", 0, 1, \"Facility to syslog to\"),\n         sslhcfg_logfile = arg_strn(NULL, \"logfile\", \"<str>\", 0, 1, \"Log messages to a file\"),\n         sslhcfg_on_timeout = arg_strn(NULL, \"on-timeout\", \"<str>\", 0, 1, \"Target to connect to when timing out\"),\n         sslhcfg_prefix = arg_strn(NULL, \"prefix\", \"<str>\", 0, 1, \"Reserved for testing\"),\n \tsslhcfg_listen = arg_strn(\"p\", \"listen\", \"<host:port>\", 0, 10, \"Listen on host:port\"),\n \tsslhcfg_ssh = arg_strn(NULL, \"ssh\", \"<host:port>\", 0, 10, \"Set up ssh target\"),\n \tsslhcfg_tls = arg_strn(NULL, \"tls\", \"<host:port>\", 0, 10, \"Set up TLS/SSL target\"),\n \tsslhcfg_ssl = arg_strn(NULL, \"ssl\", \"<host:port>\", 0, 10, \"Set up TLS/SSL target\"),\n \tsslhcfg_openvpn = arg_strn(NULL, \"openvpn\", \"<host:port>\", 0, 10, \"Set up OpenVPN target\"),\n \tsslhcfg_tinc = arg_strn(NULL, \"tinc\", \"<host:port>\", 0, 10, \"Set up tinc target\"),\n \tsslhcfg_wireguard = arg_strn(NULL, \"wireguard\", \"<host:port>\", 0, 10, \"Set up WireGuard target\"),\n \tsslhcfg_xmpp = arg_strn(NULL, \"xmpp\", \"<host:port>\", 0, 10, \"Set up XMPP target\"),\n \tsslhcfg_http = arg_strn(NULL, \"http\", \"<host:port>\", 0, 10, \"Set up HTTP (plain) target\"),\n \tsslhcfg_adb = arg_strn(NULL, \"adb\", \"<host:port>\", 0, 10, \"Set up ADB (Android Debug) target\"),\n \tsslhcfg_socks5 = arg_strn(NULL, \"socks5\", \"<host:port>\", 0, 10, \"Set up socks5 target\"),\n \tsslhcfg_syslog = arg_strn(NULL, \"syslog\", \"<host:port>\", 0, 10, \"Set up syslog target\"),\n \tsslhcfg_msrdp = arg_strn(NULL, \"msrdp\", \"<host:port>\", 0, 10, \"Set up msrdp target\"),\n \tsslhcfg_anyprot = arg_strn(NULL, \"anyprot\", \"<host:port>\", 0, 10, \"Set up default target\"),\n \tsslhcfg_end = arg_end(10)\n\n    };\n\n    /* Set up failure handler in case asprintf() runs out of\n    * memory */\n    ;\n    if (setjmp(c2s_asprintf_fail)) {\n        fprintf(stderr, \"asprintf: probably out of memory\\n\");\n        return -1;\n    }\n\n    /* Parse command line */\n    nerrors = arg_parse(argc, argv, argtable);\n    if (nerrors) {\n        arg_print_errors(stdout, sslhcfg_end, \"sslhcfg\"); \n        arg_print_syntax(stdout, argtable, \"\\n\");\n        arg_print_glossary(stdout, argtable, \"  %-25s\\t%s\\n\");\n        return -1;\n    }\n\n\n    config_init(&c);\n    if (sslhcfg_conffile && sslhcfg_conffile->count) {\n        if (!c2s_parse_file(sslhcfg_conffile->filename[0], &c, &errmsg)) {\n            fprintf(stderr, \"%s\\n\", errmsg);\n            return -1;\n        }\n    }\n\n    s = config_root_setting(&c);\n\n    res = read_block(s, cfg, table_sslhcfg, &errmsg);\n    if (!res) {\n        fprintf(stderr, \"%s\\n\", errmsg);\n        return -1;\n    }\n\n    res = read_compounds(s, cfg, compound_cl_args, &errmsg);\n    if (!res) {\n        fprintf(stderr, \"%s\\n\", errmsg);\n        return -1;\n    }\n\n    errmsg = NULL;\n    res = cfg_as_string(s, \"\", &errmsg);\n    if (res)\n        fprintf(stderr, \"Unknown settings:\\n%s\\n\", errmsg);\n\n    return 0;\n}\n\n\nstatic void indent(FILE* out, int depth) \n{\n    int i;\n    for (i = 0; i < depth; i++)\n        fprintf(out, \"    \");\n}\n\nstatic void sslhcfg_protocols_fprint(\n        FILE* out,\n        struct sslhcfg_protocols_item* sslhcfg_protocols,\n        int depth) \n{\n    int i;\n        indent(out, depth);\n        fprintf(out, \"name: %s\", sslhcfg_protocols->name);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"host: %s\", sslhcfg_protocols->host);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"port: %s\", sslhcfg_protocols->port);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"service: %s\", sslhcfg_protocols->service);\n        if (! sslhcfg_protocols->service_is_present)\n            fprintf(out, \" <unset>\");\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"is_unix: %d\", sslhcfg_protocols->is_unix);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"is_udp: %d\", sslhcfg_protocols->is_udp);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"udp_timeout: %d\", sslhcfg_protocols->udp_timeout);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"fork: %d\", sslhcfg_protocols->fork);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"tfo_ok: %d\", sslhcfg_protocols->tfo_ok);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"transparent: %d\", sslhcfg_protocols->transparent);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"resolve_on_forward: %d\", sslhcfg_protocols->resolve_on_forward);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"log_level: %d\", sslhcfg_protocols->log_level);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"keepalive: %d\", sslhcfg_protocols->keepalive);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"sni_hostnames [%zu]:\\n\", sslhcfg_protocols->sni_hostnames_len);\n        for (i = 0; i < sslhcfg_protocols->sni_hostnames_len; i++) {\n            indent(out, depth+1);\n            fprintf(out, \"%d:\\t%s\\n\", i, sslhcfg_protocols->sni_hostnames[i]);\n        }\n        indent(out, depth);\n        fprintf(out, \"alpn_protocols [%zu]:\\n\", sslhcfg_protocols->alpn_protocols_len);\n        for (i = 0; i < sslhcfg_protocols->alpn_protocols_len; i++) {\n            indent(out, depth+1);\n            fprintf(out, \"%d:\\t%s\\n\", i, sslhcfg_protocols->alpn_protocols[i]);\n        }\n        indent(out, depth);\n        fprintf(out, \"regex_patterns [%zu]:\\n\", sslhcfg_protocols->regex_patterns_len);\n        for (i = 0; i < sslhcfg_protocols->regex_patterns_len; i++) {\n            indent(out, depth+1);\n            fprintf(out, \"%d:\\t%s\\n\", i, sslhcfg_protocols->regex_patterns[i]);\n        }\n        indent(out, depth);\n        fprintf(out, \"minlength: %d\", sslhcfg_protocols->minlength);\n        if (! sslhcfg_protocols->minlength_is_present)\n            fprintf(out, \" <unset>\");\n        fprintf(out, \"\\n\");\n}\n\nstatic void sslhcfg_listen_fprint(\n        FILE* out,\n        struct sslhcfg_listen_item* sslhcfg_listen,\n        int depth) \n{\n    \n        indent(out, depth);\n        fprintf(out, \"host: %s\", sslhcfg_listen->host);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"port: %s\", sslhcfg_listen->port);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"is_udp: %d\", sslhcfg_listen->is_udp);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"is_unix: %d\", sslhcfg_listen->is_unix);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"keepalive: %d\", sslhcfg_listen->keepalive);\n        fprintf(out, \"\\n\");\n}\n\nvoid sslhcfg_fprint(\n        FILE* out,\n        struct sslhcfg_item* sslhcfg,\n        int depth) \n{\n    int i;\n        indent(out, depth);\n        fprintf(out, \"verbose: %d\", sslhcfg->verbose);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_config: %d\", sslhcfg->verbose_config);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_config_error: %d\", sslhcfg->verbose_config_error);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_connections: %d\", sslhcfg->verbose_connections);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_connections_try: %d\", sslhcfg->verbose_connections_try);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_connections_error: %d\", sslhcfg->verbose_connections_error);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_fd: %d\", sslhcfg->verbose_fd);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_packets: %d\", sslhcfg->verbose_packets);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_probe_info: %d\", sslhcfg->verbose_probe_info);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_probe_error: %d\", sslhcfg->verbose_probe_error);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_system_error: %d\", sslhcfg->verbose_system_error);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"verbose_int_error: %d\", sslhcfg->verbose_int_error);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"version: %d\", sslhcfg->version);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"foreground: %d\", sslhcfg->foreground);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"inetd: %d\", sslhcfg->inetd);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"numeric: %d\", sslhcfg->numeric);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"transparent: %d\", sslhcfg->transparent);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"timeout: %d\", sslhcfg->timeout);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"udp_max_connections: %d\", sslhcfg->udp_max_connections);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"user: %s\", sslhcfg->user);\n        if (! sslhcfg->user_is_present)\n            fprintf(out, \" <unset>\");\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"pidfile: %s\", sslhcfg->pidfile);\n        if (! sslhcfg->pidfile_is_present)\n            fprintf(out, \" <unset>\");\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"chroot: %s\", sslhcfg->chroot);\n        if (! sslhcfg->chroot_is_present)\n            fprintf(out, \" <unset>\");\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"syslog_facility: %s\", sslhcfg->syslog_facility);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"logfile: %s\", sslhcfg->logfile);\n        if (! sslhcfg->logfile_is_present)\n            fprintf(out, \" <unset>\");\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"on_timeout: %s\", sslhcfg->on_timeout);\n        fprintf(out, \"\\n\");\n        indent(out, depth);\n        fprintf(out, \"prefix: %s\", sslhcfg->prefix);\n        fprintf(out, \"\\n\");\n\n        indent(out, depth);\n        fprintf(out, \"listen [%zu]:\\n\", sslhcfg->listen_len);\n        for (i = 0; i < sslhcfg->listen_len; i++) {\n            sslhcfg_listen_fprint(out, &sslhcfg->listen[i], depth+1);\n        }\n\n        indent(out, depth);\n        fprintf(out, \"protocols [%zu]:\\n\", sslhcfg->protocols_len);\n        for (i = 0; i < sslhcfg->protocols_len; i++) {\n            sslhcfg_protocols_fprint(out, &sslhcfg->protocols[i], depth+1);\n        }\n}\n"
        },
        {
          "name": "sslh-conf.h",
          "type": "blob",
          "size": 3.34375,
          "content": "/* Generated by conf2struct (https://www.rutschle.net/tech/conf2struct/README)\n * on Sun Dec 22 22:40:51 2024. \n\n# conf2struct: generate libconf parsers that read to structs\n# Copyright (C) 2018-2024  Yves Rutschle\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n#    this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n*/\n \n#ifndef C2S_SSLHCFG_H\n#define C2S_SSLHCFG_H\n#ifdef LIBCONFIG\n#    include <libconfig.h>\n#endif\n\n\n#include \"probe.h\"\n#include  <sys/types.h>\n#include  <sys/socket.h>\n#include  <netdb.h>\n\nstruct sslhcfg_listen_item {\n\tchar*\thost;\n\tchar*\tport;\n\tint\tis_udp;\n\tint\tis_unix;\n\tint\tkeepalive;\n};\n\nstruct sslhcfg_protocols_item {\n\tchar*\tname;\n\tchar*\thost;\n\tchar*\tport;\n\tint\tservice_is_present;\n\tchar*\tservice;\n\tint\tis_unix;\n\tint\tis_udp;\n\tint\tudp_timeout;\n\tint\tfork;\n\tint\ttfo_ok;\n\tint\ttransparent;\n\tint\tresolve_on_forward;\n\tint\tlog_level;\n\tint\tkeepalive;\n\tsize_t\tsni_hostnames_len;\n\tchar** sni_hostnames;\n\tsize_t\talpn_protocols_len;\n\tchar** alpn_protocols;\n\tsize_t\tregex_patterns_len;\n\tchar** regex_patterns;\n\tint\tminlength_is_present;\n\tint\tminlength;\n\tT_PROBE*\tprobe;\n\tstruct addrinfo*\tsaddr;\n\tvoid*\tdata;\n\tdl_list\ttimeouts;\n};\n\nstruct sslhcfg_item {\n\tint\tverbose;\n\tint\tverbose_config;\n\tint\tverbose_config_error;\n\tint\tverbose_connections;\n\tint\tverbose_connections_try;\n\tint\tverbose_connections_error;\n\tint\tverbose_fd;\n\tint\tverbose_packets;\n\tint\tverbose_probe_info;\n\tint\tverbose_probe_error;\n\tint\tverbose_system_error;\n\tint\tverbose_int_error;\n\tint\tversion;\n\tint\tforeground;\n\tint\tinetd;\n\tint\tnumeric;\n\tint\ttransparent;\n\tint\ttimeout;\n\tint\tudp_max_connections;\n\tint\tuser_is_present;\n\tchar*\tuser;\n\tint\tpidfile_is_present;\n\tchar*\tpidfile;\n\tint\tchroot_is_present;\n\tchar*\tchroot;\n\tchar*\tsyslog_facility;\n\tint\tlogfile_is_present;\n\tchar*\tlogfile;\n\tchar*\ton_timeout;\n\tchar*\tprefix;\n\tsize_t\tlisten_len;\n\tstruct sslhcfg_listen_item* listen;\n\tsize_t\tprotocols_len;\n\tstruct sslhcfg_protocols_item* protocols;\n};\n\nint sslhcfg_parse_file(\n        const char* filename,\n        struct sslhcfg_item* sslhcfg, \n        const char** errmsg);\n\nvoid sslhcfg_fprint(\n    FILE* out,\n    struct sslhcfg_item *sslhcfg,\n    int depth);\n\nint sslhcfg_cl_parse(\n    int argc,\n    char* argv[],\n    struct sslhcfg_item *sslhcfg);\n\n#endif\n"
        },
        {
          "name": "sslh-ev.c",
          "type": "blob",
          "size": 3.8984375,
          "content": "/*\n   sslh-ev: mono-processus server based on libev\n\n# Copyright (C) 2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#include <stdlib.h>\n#include <ev.h>\n#include \"gap.h\"\n#include \"log.h\"\n#include \"udp-listener.h\"\n#include \"tcp-listener.h\"\n\n\nconst char* server_type = \"sslh-ev\";\n\nstatic struct ev_loop* loop;\n\n/* Libev watchers */\nstruct watchers {\n    /* one set of ev_io for read, one for write, indexed by file descriptor */\n    gap_array *ev_ior, *ev_iow;\n\n    struct listen_endpoint* listen_sockets;\n    gap_array* fd2ls;  /* Array indexed by file descriptor, pointing to listen_sockets */\n};\n\nstatic void cnx_read_cb(EV_P_ ev_io *w, int revents);\nstatic void cnx_write_cb(EV_P_ ev_io *w, int wevents);\nstatic void cnx_accept_cb(EV_P_ ev_io *w, int revents);\n\n\nstatic void watchers_init(watchers** w, struct listen_endpoint* listen_sockets, \n                          int num_addr_listen)\n{\n    *w = malloc(sizeof(**w));\n    (*w)->ev_ior = gap_init(num_addr_listen);\n    (*w)->ev_iow = gap_init(num_addr_listen);\n    (*w)->listen_sockets = listen_sockets;\n    (*w)->fd2ls = gap_init(0);\n\n    /* Create watchers for listen sockets */\n    for (int i = 0; i < num_addr_listen; i++) {\n        ev_io* io = malloc(sizeof(*io));\n\n        ev_io_init(io, &cnx_accept_cb, listen_sockets[i].socketfd, EV_READ);\n        ev_io_start(EV_A_  io);\n        gap_set((*w)->ev_ior, i, io);\n        gap_set((*w)->fd2ls, listen_sockets[i].socketfd, &listen_sockets[i]);\n        set_nonblock(listen_sockets[i].socketfd);\n    }\n}\n\nvoid watchers_add_read(watchers* w, int fd)\n{\n    ev_io* io = gap_get(w->ev_ior, fd);\n    if (!io) {\n        io = malloc(sizeof(*io));\n        ev_io_init(io, &cnx_read_cb, fd, EV_READ);\n        ev_io_set(io, fd, EV_READ);\n\n        gap_set(w->ev_ior, fd, io);\n    }\n    ev_io_start(loop, io);\n}\n\nvoid watchers_del_read(watchers* w, int fd)\n{\n    ev_io* io = gap_get(w->ev_ior, fd);\n    if (io) ev_io_stop(EV_A_ io);\n}\n\nvoid watchers_add_write(watchers* w, int fd)\n{\n    ev_io* io = gap_get(w->ev_iow, fd);\n    if (!io) {\n        io = malloc(sizeof(*io));\n        ev_io_init(io, &cnx_write_cb, fd, EV_WRITE);\n        ev_io_set(io, fd, EV_WRITE);\n\n        gap_set(w->ev_iow, fd, io);\n    }\n    ev_io_start(loop, io);\n}\n\nvoid watchers_del_write(watchers* w, int fd)\n{\n    ev_io* io = gap_get(w->ev_iow, fd);\n    if (io) ev_io_stop(EV_A_ io);\n}\n\n/* /watchers */\n\n#include \"processes.h\"\n\n/* Libev callbacks */\nstatic void cnx_read_cb(EV_P_ ev_io *w, int revents)\n{\n    struct loop_info* info = ev_userdata(EV_A);\n    cnx_read_process(info, w->fd);\n}\n\nstatic void cnx_write_cb(EV_P_ ev_io *w, int wevents)\n{\n    struct loop_info* info = ev_userdata(EV_A);\n    cnx_write_process(info, w->fd);\n}\n\n\nstatic void cnx_accept_cb(EV_P_ ev_io *w, int revents)\n{\n    struct loop_info* info = ev_userdata(EV_A);\n    cnx_accept_process(info, gap_get(info->watchers->fd2ls, w->fd));\n}\n\nvoid main_loop(struct listen_endpoint listen_sockets[], int num_addr_listen)\n{\n    struct loop_info ev_info = {0};\n    loop = EV_DEFAULT;\n\n    ev_info.collection = collection_init(0);\n    ev_info.probing_list = gap_init(0);\n    udp_init(&ev_info);\n    tcp_init();\n\n    watchers_init(&ev_info.watchers, listen_sockets, num_addr_listen);\n    ev_set_userdata(EV_A_ &ev_info);\n\n    ev_run(EV_A_ 0);\n}\n\nvoid start_shoveler(int listen_socket) {\n    print_message(msg_config_error, \"inetd mode is not supported in libev mode\\n\");\n    exit(1);\n}\n\n\n"
        },
        {
          "name": "sslh-fork.c",
          "type": "blob",
          "size": 7.5009765625,
          "content": "/*\n   sslh-fork: forking server\n\n# Copyright (C) 2007-2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#include \"common.h\"\n#include \"probe.h\"\n#include \"sslh-conf.h\"\n#include \"tcp-probe.h\"\n#include \"log.h\"\n\n#ifdef LIBBSD\n#include <bsd/unistd.h>\n#endif\n\nconst char* server_type = \"sslh-fork\";\n\n/* shovels data from one fd to the other and vice-versa \n   returns after one socket closed\n */\nint shovel(struct connection *cnx)\n{\n   fd_set fds;\n   int res, i;\n   int max_fd = MAX(cnx->q[0].fd, cnx->q[1].fd) + 1;\n\n   FD_ZERO(&fds);\n   while (1) {\n      FD_SET(cnx->q[0].fd, &fds);\n      FD_SET(cnx->q[1].fd, &fds);\n\n      res = select(\n                   max_fd,\n                   &fds,\n                   NULL,\n                   NULL,\n                   NULL\n                  );\n      CHECK_RES_DIE(res, \"select\");\n\n      for (i = 0; i < 2; i++) {\n          if (FD_ISSET(cnx->q[i].fd, &fds)) {\n              res = fd2fd(&cnx->q[1-i], &cnx->q[i]);\n              if (res == FD_CNXCLOSED) {\n                  print_message(msg_fd, \"%s %s\", i ? \"client\" : \"server\", \"socket closed\\n\");\n                  return res;\n              }\n          }\n      }\n   }\n}\n\n/* Child process that finds out what to connect to and proxies \n */\nvoid start_shoveler(int in_socket)\n{\n   fd_set fds;\n   struct timeval tv;\n   int res = PROBE_AGAIN;\n   int out_socket;\n   struct connection cnx;\n   struct connection_desc desc;\n\n   init_cnx(&cnx);\n   cnx.q[0].fd = in_socket;\n\n   FD_ZERO(&fds);\n   FD_SET(in_socket, &fds);\n   memset(&tv, 0, sizeof(tv));\n   tv.tv_sec = cfg.timeout;\n\n   while (res == PROBE_AGAIN) {\n       /* POSIX does not guarantee that tv will be updated, but the client can\n        * only postpone the inevitable for so long */\n       res = select(in_socket + 1, &fds, NULL, NULL, &tv);\n       if (res == -1)\n           perror(\"select\");\n\n       if (FD_ISSET(in_socket, &fds)) {\n           /* Received data: figure out what protocol it is */\n           res = probe_client_protocol(&cnx);\n       } else {\n           /* Timed out: it's necessarily SSH */\n           cnx.proto = timeout_protocol();\n           print_message(msg_fd, \"timed out, connect to %s\\n\", cnx.proto->name);\n           break;\n       }\n   }\n\n   if (cnx.proto->service &&\n       check_access_rights(in_socket, cnx.proto->service)) {\n       exit(0);\n   }\n\n   /* Connect the target socket */\n   out_socket = connect_addr(&cnx, in_socket, BLOCKING);\n   CHECK_RES_DIE(out_socket, \"connect\");\n\n   set_capabilities(0);\n\n   cnx.q[1].fd = out_socket;\n\n   get_connection_desc(&desc, &cnx);\n   log_connection(&desc, &cnx);\n   set_proctitle_shovel(&desc, &cnx);\n\n   flush_deferred(&cnx.q[1]);\n\n   shovel(&cnx);\n\n   close(in_socket);\n   close(out_socket);\n   \n   print_message(msg_fd, \"connection closed down\\n\");\n\n   exit(0);\n}\n\nstatic pid_t *listener_pid;\nstatic int listener_pid_number = 0;\n\nvoid stop_listeners(int sig)\n{\n    int i;\n\n    for (i = 0; i < listener_pid_number; i++) {\n        kill(listener_pid[i], sig);\n    }\n}\n\nvoid set_listen_procname(struct listen_endpoint *listen_socket)\n{\n#ifdef LIBBSD\n    int res;\n    struct addrinfo addr;\n    struct sockaddr_storage ss;\n    char listen_addr[NI_MAXHOST+1+NI_MAXSERV+1];\n\n    addr.ai_addr = (struct sockaddr*)&ss;\n    addr.ai_addrlen = sizeof(ss);\n    res = getsockname(listen_socket->socketfd, addr.ai_addr, &addr.ai_addrlen);\n    if (res != -1) {\n        sprintaddr(listen_addr, sizeof(listen_addr), &addr);\n        setproctitle(\"listener %s\", listen_addr);\n    }\n#endif\n}\n\n\n/* At least MacOS does not know these two options, so define them to something\n * equivalent for our use case */\n#ifndef ENONET\n#define ENONET EWOULDBLOCK\n#endif\n/* /MacOS kludge */\n\n/* TCP listener: connections, fork a child for each new connection \n * IN: \n *      endpoint: array of listening endpoint objects\n *      num_endpoints: size of endpoint array\n *      active_endpoint: which endpoint is this listener working on\n * Does not return\n * */\nvoid tcp_listener(struct listen_endpoint* endpoint, int num_endpoints, int active_endpoint)\n{\n    int i, in_socket;\n\n    while (1) {\n        in_socket = accept(endpoint[active_endpoint].socketfd, 0, 0);\n        CHECK_RES_RETURN(in_socket, \"accept\", /*void*/ );\n        if (in_socket == -1) {\n            print_message(msg_system_error, \"%s:%d:%s:%d:%s\\n\", \n                          __FILE__, __LINE__, \"accept\", errno, strerror(errno));\n            switch(in_socket) {\n            case ENETDOWN:  /* accept(2) cites all these errnos as \"you should retry\" */\n            case EPROTO:\n            case ENOPROTOOPT:\n            case EHOSTDOWN:\n            case ENONET:\n            case EHOSTUNREACH:\n            case EOPNOTSUPP:\n            case ENETUNREACH:\n            case ECONNABORTED:\n                continue;\n\n            default:  /* Otherwise, it's something wrong in our parameters, we fail */\n                return;\n            }\n        }\n        print_message(msg_fd, \"accepted fd %d\\n\", in_socket);\n\n        switch(fork()) {\n        case -1: print_message(msg_system_error, \"fork failed: err %d: %s\\n\", errno, strerror(errno));\n                 break;\n\n        case 0: /* In child process */\n                 /* Shoveler processes don't need to hog file descriptors */\n                 for (i = 0; i < num_endpoints; i++)\n                     close(endpoint[i].socketfd);\n                 start_shoveler(in_socket);\n                 exit(0);\n\n        default: /* In parent process */\n                 break;\n        }\n        close(in_socket);\n    }\n}\n\n\nvoid main_loop(struct listen_endpoint listen_sockets[], int num_addr_listen)\n{\n    int i, res;\n    struct sigaction action;\n\n    listener_pid_number = num_addr_listen;\n    listener_pid = malloc(listener_pid_number * sizeof(listener_pid[0]));\n    CHECK_ALLOC(listener_pid, \"malloc\");\n\n    tcp_init();\n\n    /* Start one process for each listening address */\n    for (i = 0; i < num_addr_listen; i++) {\n        listener_pid[i] = fork();\n        switch(listener_pid[i]) {\n        /* Log if fork() fails for some reason */\n        case -1: print_message(msg_system_error, \"fork failed: err %d: %s\\n\", errno, strerror(errno));\n                 break;\n        /* We're in the child, we have work to do  */\n        case 0:\n            set_listen_procname(&listen_sockets[i]);\n            if (listen_sockets[i].type == SOCK_DGRAM)\n                print_message(msg_config_error, \"UDP not (yet?) supported in sslh-fork\\n\");\n            else\n                tcp_listener(listen_sockets, num_addr_listen, i);\n\n            exit(0);\n\t    break;\n\n\t/* We're in the parent, we don't need to do anything */\n\tdefault:\n\t    break;\n        }\n    }\n\n    /* Set SIGTERM to \"stop_listeners\" which further kills all listener\n     * processes. Note this won't kill processes that listeners forked, which\n     * means active connections remain active. */\n    memset(&action, 0, sizeof(action));\n    action.sa_handler = stop_listeners;\n    res = sigaction(SIGTERM, &action, NULL);\n    CHECK_RES_DIE(res, \"sigaction\");\n\n\n    wait(NULL);\n}\n\n/* The actual main() is in sslh_main.c: it's the same for all versions of\n * the server\n */\n\n"
        },
        {
          "name": "sslh-main.c",
          "type": "blob",
          "size": 10.1943359375,
          "content": "/*\n# main: processing of config file, command line options and start the main\n# loop.\n#\n# Copyright (C) 2007-2018  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#define _GNU_SOURCE\n#ifdef LIBCONFIG\n#include <libconfig.h>\n#endif\n#ifdef ENABLE_REGEX\n#define PCRE2_CODE_UNIT_WIDTH 8\n#include <pcre2.h>\n#endif\n\n#ifdef LIBBSD\n#include <bsd/unistd.h>\n#endif\n\n#include \"common.h\"\n#include \"probe.h\"\n#include \"log.h\"\n#include \"tcp-probe.h\"\n\n/* Constants for options that have no one-character shorthand */\n#define OPT_ONTIMEOUT   257\n\nstatic void printcaps(void) {\n#ifdef LIBCAP\n    cap_t caps;\n    char* desc;\n    ssize_t len;\n\n    caps = cap_get_proc();\n\n    desc = cap_to_text(caps, &len);\n\n    print_message(msg_config, \"capabilities: %s\\n\", desc);\n\n    cap_free(caps);\n    cap_free(desc);\n#endif\n}\n\nstatic void printsettings(void)\n{\n    char buf[NI_MAXHOST + 256]; /* 256 > \" family %d %d\" for reasonable ints */\n    int i;\n    struct sslhcfg_protocols_item *p;\n    \n    for (i = 0; i < cfg.protocols_len; i++ ) {\n        p = &cfg.protocols[i];\n        if (p->is_unix) {\n            sprintf(buf, \"unix socket: %s\", p->host);\n        } else {\n            strcpy(buf, \"resolve on forward\");\n            if (!p->resolve_on_forward) {\n                sprintaddr(buf, sizeof(buf), p->saddr);\n                size_t len = strlen(buf);\n                sprintf(buf+len, \" family %d %d\",\n                        p->saddr->ai_family,\n                        p->saddr->ai_addr->sa_family);\n            }\n        }\n        print_message(msg_config, \n                      \"%s addr: %s. libwrap service: %s log_level: %d [%s] [%s] [%s]\\n\",\n                      p->name, \n                      buf,\n                      p->service,\n                      p->log_level,\n                      p->keepalive ? \"keepalive\" : \"\",\n                      p->fork ? \"fork\" : \"\",\n                      p->transparent ? \"transparent\" : \"\"\n                     );\n    }\n    print_message(msg_config, \n                  \"timeout: %d\\n\"\n                  \"on-timeout: %s\\n\"\n                  \"UDP hash size: %d\\n\", \n                  cfg.timeout,\n                  timeout_protocol()->name,\n                  cfg.udp_max_connections);\n}\n\n\nstatic void setup_regex_probe(struct sslhcfg_protocols_item *p)\n#ifdef ENABLE_REGEX\n{\n    size_t num_patterns, i;\n    int error;\n    pcre2_code** pattern_list;\n    PCRE2_SIZE error_offset;\n    PCRE2_UCHAR8 err_str[120];\n\n    num_patterns = p->regex_patterns_len;\n\n    pattern_list = calloc(num_patterns + 1, sizeof(*pattern_list));\n    CHECK_ALLOC(pattern_list, \"calloc\");\n    p->data = (void*)pattern_list;\n\n    for (i = 0; i < num_patterns; i++) {\n        pattern_list[i] = pcre2_compile((PCRE2_SPTR8)p->regex_patterns[i], \n                                        PCRE2_ZERO_TERMINATED, 0,\n                                        &error, &error_offset, NULL);\n        if (!pattern_list[i]) {\n            pcre2_get_error_message(error, err_str, sizeof(err_str));\n            print_message(msg_config_error, \"compiling pattern /%s/:%d:%s at offset %ld\\n\",\n                    p->regex_patterns[i], error, err_str, error_offset);\n            exit(1);\n        }\n    }\n}\n#else\n{\n    return;\n}\n#endif\n\n/* Perform some fixups on configuration after reading it.\n * if verbose is present, override all other verbose options\n */\nvoid config_finish(struct sslhcfg_item* cfg)\n{\n    if (cfg->verbose) {\n        cfg->verbose_config = cfg->verbose;\n\tcfg->verbose_config_error = cfg->verbose;\n\tcfg->verbose_connections = cfg->verbose;\n\tcfg->verbose_connections_try = cfg->verbose;\n\tcfg->verbose_connections_error = cfg->verbose;\n\tcfg->verbose_fd = cfg->verbose;\n\tcfg->verbose_packets = cfg->verbose;\n\tcfg->verbose_probe_info = cfg->verbose;\n\tcfg->verbose_probe_error = cfg->verbose;\n\tcfg->verbose_system_error = cfg->verbose;\n\tcfg->verbose_int_error = cfg->verbose;\n    }\n}\n\n/* Checks that the UNIX socket specified exists and is accessible\n * Dies otherwise\n */\nstatic void check_access_unix_socket(struct sslhcfg_protocols_item* p)\n{\n    /* TODO */\n    return;\n}\n\n\n/* For each protocol in the configuration, resolve address and set up protocol\n * options if required\n */\nstatic void config_protocols()\n{\n    int i;\n    for (i = 0; i < cfg.protocols_len; i++) {\n        struct sslhcfg_protocols_item* p = &(cfg.protocols[i]);\n\n        if (p->is_unix) {\n            check_access_unix_socket(p);\n        } else if (\n            !p->resolve_on_forward &&\n            resolve_split_name(&(p->saddr), p->host, p->port)\n        ) {\n            print_message(msg_config_error, \"cannot resolve %s:%s\\n\",\n                          p->host, p->port);\n            exit(4);\n        }\n\n        p->probe = get_probe(p->name);\n        if (!p->probe) {\n            print_message(msg_config_error, \"%s: probe unknown\\n\", p->name);\n            exit(1);\n        }\n\n        if (!strcmp(cfg.protocols[i].name, \"regex\")) {\n            setup_regex_probe(&cfg.protocols[i]);\n        }\n\n        if (!strcmp(cfg.protocols[i].name, \"tls\")) {\n            cfg.protocols[i].data = (void*)new_tls_data();\n            if (cfg.protocols[i].sni_hostnames_len)\n                tls_data_set_list(cfg.protocols[i].data, 0,\n                                  (const char**) cfg.protocols[i].sni_hostnames,\n                                  cfg.protocols[i].sni_hostnames_len);\n            if (cfg.protocols[i].alpn_protocols_len)\n                tls_data_set_list(cfg.protocols[i].data, 1, \n                                  (const char**) cfg.protocols[i].alpn_protocols,\n                                  cfg.protocols[i].alpn_protocols_len);\n        }\n\n        p->timeouts.head = NULL;\n        p->timeouts.tail = NULL;\n    }\n}\n\n\nvoid config_sanity_check(struct sslhcfg_item* cfg)\n{\n    size_t i;\n\n/* If compiling with systemd socket support no need to require listen address */\n#ifndef SYSTEMD\n    if (!cfg->listen_len && !cfg->inetd) {\n        print_message(msg_config_error, \"No listening address specified; use at least one -p option\\n\");\n        exit(1);\n    }\n#endif\n\n    for (i = 0; i < cfg->protocols_len; ++i) {\n        if (strcmp(cfg->protocols[i].name, \"tls\") != 0) {\n            if (cfg->protocols[i].sni_hostnames_len) {\n                print_message(msg_config_error, \"name: \\\"%s\\\"; host: \\\"%s\\\"; port: \\\"%s\\\": \"\n                              \"Config option sni_hostnames is only applicable for tls\\n\",\n                              cfg->protocols[i].name, cfg->protocols[i].host, cfg->protocols[i].port);\n                exit(1);\n            }\n            if (cfg->protocols[i].alpn_protocols_len) {\n                print_message(msg_config_error, \"name: \\\"%s\\\"; host: \\\"%s\\\"; port: \\\"%s\\\": \"\n                              \"Config option alpn_protocols is only applicable for tls\\n\",\n                              cfg->protocols[i].name, cfg->protocols[i].host, cfg->protocols[i].port);\n                exit(1);\n            }\n        }\n\n        if (cfg->protocols[i].is_udp) {\n            if (cfg->protocols[i].tfo_ok) {\n                print_message(msg_config_error, \"name: \\\"%s\\\"; host: \\\"%s\\\"; port: \\\"%s\\\": \"\n                              \"Config option tfo_ok is not applicable for udp connections\\n\",\n                              cfg->protocols[i].name, cfg->protocols[i].host, cfg->protocols[i].port);\n                exit(1);\n            }\n        } else {\n            if (!strcmp(cfg->protocols[i].name, \"wireguard\")) {\n                print_message(msg_config_error, \"Wireguard works only with UDP\\n\");\n                exit(1);\n            }\n        }\n    }\n}\n\n/* Connect stdin, stdout, stderr to /dev/null. It is better to keep them around\n * so they do not get re-used by socket descriptors, and accidently used by\n * some library code.\n */\nvoid close_std(void)\n{\n    int newfd;\n\n    if ((newfd = open(\"/dev/null\", O_RDWR))) {\n        dup2 (newfd, STDIN_FILENO);\n        dup2 (newfd, STDOUT_FILENO);\n        dup2 (newfd, STDERR_FILENO);\n        /* close the helper handle, as this is now unnecessary */\n        close(newfd);\n    } else {\n        print_message(msg_system_error, \"Error closing standard filehandles for background daemon\\n\");\n    }\n}\n\nint main(int argc, char *argv[], char* envp[])\n{\n\n   extern char *optarg;\n   extern int optind;\n   int res, num_addr_listen;\n   struct listen_endpoint *listen_sockets;\n\n#ifdef LIBBSD\n   setproctitle_init(argc, argv, envp);\n#endif\n\n   memset(&cfg, 0, sizeof(cfg));\n   res = sslhcfg_cl_parse(argc, argv, &cfg);\n   if (res) exit(6);\n   config_finish(&cfg);\n\n   if (cfg.version) {\n       printf(\"%s %s\\n\", server_type, VERSION);\n       exit(0);\n   }\n\n   config_protocols();\n   config_sanity_check(&cfg);\n\n   if (cfg.inetd)\n   {\n       close(fileno(stderr)); /* Make sure no error will go to client */\n       tcp_init();\n       start_shoveler(0);\n       exit(0);\n   }\n\n   printsettings();\n\n   num_addr_listen = start_listen_sockets(&listen_sockets);\n\n#ifdef SYSTEMD\n   if (num_addr_listen < 1) {\n     print_message(msg_config_error, \"No listening sockets found, restart sockets or specify addresses in config\\n\");\n     exit(1);\n    }\n#endif\n\n   if (!cfg.foreground) {\n       if (fork() > 0) exit(0); /* Detach */\n       close_std();\n\n       /* New session -- become group leader */\n       if (getuid() == 0) {\n           res = setsid();\n           CHECK_RES_DIE(res, \"setsid: already process leader\");\n       }\n   }\n\n   setup_signals();\n\n   if (cfg.pidfile)\n       write_pid_file(cfg.pidfile);\n\n   /* Open syslog connection before we drop privs/chroot */\n   setup_syslog(argv[0]);\n\n   /* Open log file for writing */\n   setup_logfile();\n\n   if (cfg.user || cfg.chroot)\n       drop_privileges(cfg.user, cfg.chroot);\n   setup_landlock();\n\n   printcaps();\n\n   print_message(msg_config, \"%s %s started\\n\", server_type, VERSION);\n\n   main_loop(listen_sockets, num_addr_listen);\n\n   close_logfile();\n\n   free(listen_sockets);\n\n   return 0;\n}\n"
        },
        {
          "name": "sslh-select.c",
          "type": "blob",
          "size": 6.869140625,
          "content": "/*\n   sslh-select: mono-processus server\n\n# Copyright (C) 2007-2021  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n/* Why use select(2) rather than poll(2)?\n * No real reason except that's how it was written at first. This article:\n * https://daniel.haxx.se/docs/poll-vs-select.html suggests that over a few\n * hundred file descriptors, both become very slow, so there is little\n * incentive to move to poll() to support more than FD_SETSIZE (which is 1024\n * on many Linux. To support large numbers of descriptors efficiently, either use sslh-fork\n * or sslh-ev. */\n\n#define __LINUX__\n\n#include \"common.h\"\n#include \"probe.h\"\n#include \"tcp-listener.h\"\n#include \"udp-listener.h\"\n#include \"collection.h\"\n#include \"processes.h\"\n#include \"gap.h\"\n#include \"log.h\"\n\nconst char* server_type = \"sslh-select\";\n\n/* watcher type for a select() loop */\nstruct watchers {\n    fd_set fds_r, fds_w;  /* reference fd sets (used to init working copies) */\n    int max_fd;   /* Highest fd number to pass to select() */\n};\n\n\nstatic void watchers_init(watchers** w, struct listen_endpoint* listen_sockets,\n                          int num_addr_listen)\n{\n    *w = malloc(sizeof(**w));\n    CHECK_ALLOC(*w, \"malloc\");\n\n    memset(*w, 0, sizeof(**w));\n    FD_ZERO(&(*w)->fds_r);\n    FD_ZERO(&(*w)->fds_w);\n\n    for (int i = 0; i < num_addr_listen; i++) {\n        watchers_add_read(*w, listen_sockets[i].socketfd);\n        set_nonblock(listen_sockets[i].socketfd);\n    }\n}\n\nvoid watchers_add_read(watchers* w, int fd)\n{\n    FD_SET(fd, &w->fds_r); \n    if (fd + 1 > w->max_fd)\n        w->max_fd = fd + 1;\n}\n\nvoid watchers_del_read(watchers* w, int fd)\n{\n    FD_CLR(fd, &w->fds_r);\n}\n\nvoid watchers_add_write(watchers* w, int fd)\n{\n    FD_SET(fd, &w->fds_w); \n    if (fd > w->max_fd)\n        w->max_fd = fd + 1;\n}\n\nvoid watchers_del_write(watchers* w, int fd)\n{\n    FD_CLR(fd, &w->fds_w);\n}\n\n/* /end watchers */\n\n\n\n\n/* if fd becomes higher than FD_SETSIZE, things won't work so well with FD_SET\n * and FD_CLR. Need to drop connections if we go above that limit */\nstatic int fd_out_of_range(int fd) {\n    if (fd >= FD_SETSIZE) {\n        print_message(msg_system_error, \"too many open file descriptor to monitor them all -- dropping connection\\n\");\n        return 1;\n    }\n    return 0;\n}\n\n\n\n\n\n\n/* Main loop: the idea is as follow:\n * - fds_r and fds_w contain the file descriptors to monitor in read and write\n * - When a file descriptor goes off, process it: read from it, write the data\n * to its corresponding pair.\n * - When a file descriptor blocks when writing, remove the read fd from fds_r,\n * move the data to a deferred buffer, and add the write fd to fds_w. Deferred\n * buffer is allocated dynamically.\n * - When we can write to a file descriptor that has deferred data, we try to\n * write as much as we can. Once all data is written, remove the fd from fds_w\n * and add its corresponding pair to fds_r, free the buffer.\n *\n * That way, each pair of file descriptor (read from one, write to the other)\n * is monitored either for read or for write, but never for both.\n */\nvoid main_loop(struct listen_endpoint listen_sockets[], int num_addr_listen)\n{\n    struct loop_info fd_info = {0};\n    fd_set readfds, writefds; /* working read and write fd sets */\n    struct timeval tv;\n    int i, res;\n\n    fd_info.num_probing = 0; \n    fd_info.probing_list = gap_init(0);\n    udp_init(&fd_info);\n    tcp_init();\n\n    watchers_init(&fd_info.watchers, listen_sockets, num_addr_listen);\n\n    fd_info.collection = collection_init(fd_info.watchers->max_fd);\n\n    while (1)\n    {\n        memset(&tv, 0, sizeof(tv));\n        tv.tv_sec = cfg.timeout;\n\n        memcpy(&readfds, &fd_info.watchers->fds_r, sizeof(readfds));\n        memcpy(&writefds, &fd_info.watchers->fds_w, sizeof(writefds));\n\n        print_message(msg_fd, \"selecting... max_fd=%d num_probing=%d\\n\",\n                                          fd_info.watchers->max_fd, fd_info.num_probing);\n        res = select(fd_info.watchers->max_fd, &readfds, &writefds,\n                     NULL, fd_info.num_probing ? &tv : NULL);\n        if (res < 0)\n            perror(\"select\");\n\n        /* Check main socket for new connections */\n        for (i = 0; i < num_addr_listen; i++) {\n            if (FD_ISSET(listen_sockets[i].socketfd, &readfds)) {\n                struct connection* new_cnx = cnx_accept_process(&fd_info, &listen_sockets[i]);\n\n                if (fd_out_of_range(new_cnx->q[0].fd))\n                    tidy_connection(new_cnx, &fd_info);\n\n                /* don't also process it as a read socket */\n                FD_CLR(listen_sockets[i].socketfd, &readfds);\n            }\n        }\n\n        /* Check all sockets for write activity */\n        for (i = 0; i < fd_info.watchers->max_fd; i++) {\n            /* Check if it's active AND currently monitored (if a connection\n             * died, it gets tidied, which closes both sockets, but writefs does\n             * not know about that */\n            if (FD_ISSET(i, &writefds) && FD_ISSET(i, &fd_info.watchers->fds_w)) {\n                cnx_write_process(&fd_info, i);\n            }\n        }\n\n        /* Check sockets in probing state for timeouts */\n        for (i = 0; i < fd_info.num_probing; i++) {\n            struct connection* cnx = gap_get(fd_info.probing_list, i);\n            if (!cnx || cnx->state != ST_PROBING) {\n                print_message(msg_int_error, \"Inconsistent probing: cnx=0x%p\\n\", cnx);\n                if (cnx)\n                    print_message(msg_int_error, \"Inconsistent probing: state=%d\\n\", cnx->state);\n                exit(1);\n            }\n            if (cnx->probe_timeout < time(NULL)) {\n                print_message(msg_fd, \"timeout slot %d\\n\", i);\n                probing_read_process(cnx, &fd_info);\n            }\n        }\n\n        /* Check all sockets for read activity */\n        for (i = 0; i < fd_info.watchers->max_fd; i++) {\n            /* Check if it's active AND currently monitored (if a connection\n             * died, it gets tidied, which closes both sockets, but readfs does\n             * not know about that */\n            if (FD_ISSET(i, &readfds) && FD_ISSET(i, &fd_info.watchers->fds_r)) {\n                cnx_read_process(&fd_info, i);\n            }\n        }\n    }\n}\n\n\nvoid start_shoveler(int listen_socket) {\n    print_message(msg_config_error, \"inetd mode is not supported in select mode\\n\");\n    exit(1);\n}\n\n\n/* The actual main is in sslh-main.c: it's the same for all versions of\n * the server\n */\n\n\n"
        },
        {
          "name": "sslh.pod",
          "type": "blob",
          "size": 7.7919921875,
          "content": "# I'm just not gonna write troff :-)\n\n=head1 NAME\n\n sslh - protocol demultiplexer\n\n=head1 SYNOPSIS\n\nsslh [B<-F>I<config file>] [B<-t> I<num>] [B<--transparent>] [B<-p> I<listening address> [B<-p> I<listening address> ...]  [B<--tls> I<target address for TLS>] [B<--ssh> I<target address for SSH>] [B<--openvpn> I<target address for OpenVPN>] [B<--http> I<target address for HTTP>] [B<--xmpp> I<target address for XMPP>] [B<--tinc> I<target address for TINC>] [B<--anyprot> I<default target address>] [B<--on-timeout> I<protocol name>] [B<-u> I<username>] [B<-C> I<chroot>] [B<-P> I<pidfile>] [B<-v> I<n>] [-i] [-V] [-f] [-n]\n\n=head1 DESCRIPTION\n\nB<sslh> accepts connections on specified ports, and forwards\nthem further based on tests performed on the first data\npacket sent by the remote client.\n\nProbes for HTTP, TLS, SSH, OpenVPN, tinc, XMPP are\nimplemented, and any other protocol that can be tested using\na regular expression, can be recognised. A typical use case\nis to allow serving several services on port 443 (e.g. to\nconnect to ssh from inside a corporate firewall, which\nalmost never block port 443) while still serving HTTPS on\nthat port. \n\nHence B<sslh> acts as a protocol demultiplexer, or a\nswitchboard. Its name comes from its original function to\nserve SSH and HTTPS on the same port.\n\n=head2 Libwrap support\n\nOne drawback of B<sslh> is that the servers do not see the\noriginal IP address of the client anymore, as the connection\nis forwarded through B<sslh>.\n\nFor this reason, B<sslh> can be compiled with B<libwrap> to\ncheck accesses defined in F</etc/hosts.allow> and\nF</etc/hosts.deny>.  Libwrap services can be defined using\nthe configuration file.\n\n=head2 Configuration file\n\nA configuration file can be supplied to B<sslh>. Command\nline arguments override file settings. B<sslh> uses\nB<libconfig> to parse the configuration file, so the general\nfile format is indicated in\nL<http://www.hyperrealm.com/libconfig/libconfig_manual.html>.\nPlease refer to the example configuration file provided with\nB<sslh> for the specific format (Options have the same names\nas on the command line, except for the list of listen ports\nand the list of protocols).\n\nThe configuration file makes it possible to specify\nprotocols using regular expressions: a list of regular\nexpressions is given as the I<regex_patterns> parameter, and if the\nfirst packet received from the client matches any of these\nexpressions, B<sslh> connects to that protocol.\n\n=head2 Probing protocols\n\nWhen receiving an incoming connection, B<sslh> will read the\nfirst bytes sent by the connecting client. It will then\nprobe for the protocol in the order specified on the command\nline (or the configuration file). Therefore B<--anyprot>\nshould alway be used last, as it always succeeds and further\nprotocols will never be tried.\n\nIf no data is sent by the client, B<sslh> will eventually\ntime out and connect to the protocol specified with\nB<--on-timeout>, or I<ssh> if none is specified.\n\n=head2 Logging\n\nAs a security/authorization program, B<sslh> logs to the\nLOG_AUTH facility, with priority LOG_INFO for normal\nconnections and LOG_ERR for failures.\n\n=head1 OPTIONS\n\n=over 4\n\n=item B<-F>I<filename>, B<--config> I<filename>\n\nUses I<filename> as configuration file. If other\ncommand-line options are specified, they will override the\nconfiguration file's settings.\n\n=item B<-t> I<num>, B<--timeout> I<num>\n\nTimeout before forwarding the connection to the timeout\nprotocol (which should usually be SSH). Default is 2s.\n\n=item B<--on-timeout> I<protocol name>\n\nName of the protocol to connect to after the timeout period\nis over. Default is to forward to the first specified\nprotocol. It usually makes sense to specify 'ssh' as the\ntimeout protocol, as the SSH specification does not tell\nwho is supposed to speak first and a large number of SSH\nclients wait for the server to send its banner.\n\n=item B<--transparent>\n\nMakes B<sslh> behave as a transparent proxy, i.e. the\nreceiving service sees the original client's IP address.\nThis works on Linux only and involves B<iproute2> settings.\nIn some cases also B<iptables/nftables> settings are needed.\nRefer to the README or L<https://github.com/ftasnetamot/sslh/blob/2014-08-16--close-filehandles-with-detach/doc/simple_transparent_proxy.md>\nfor more information.\n\n=item B<-p> I<listening address>, B<--listen> I<listening address>\n\nInterface and port on which to listen, e.g. I<foobar:443>,\nwhere I<foobar> is the name of an interface (typically the\nIP address on which the Internet connection ends up).\n\nThis can be specified several times to bind B<sslh> to\nseveral addresses.\n\n=item B<--tls> I<target address>\n\nInterface and port on which to forward SSL connection,\ntypically I<localhost:443>.\n\nNote that you can set B<sslh> to listen on I<ext_ip:443> and\nB<httpd> to listen on I<localhost:443>: this allows clients\ninside your network to just connect directly to B<httpd>.\n\nAlso, B<sslh> probes for TLS handshakes and will\nreject connections from clients requesting SSLv2. This is\ncompliant with RFC6176 which prohibits the usage of SSLv2. \nIf you wish to accept SSLv2, use B<--anyprot> instead.\n\n\n=item B<--ssh> I<target address>\n\nInterface and port on which to forward SSH connections,\ntypically I<localhost:22>.\n\n=item B<--openvpn> I<target address>\n\nInterface and port on which to forward OpenVPN connections,\ntypically I<localhost:1194>.\n\n=item B<--xmpp> I<target address>\n\nInterface and port on which to forward XMPP connections,\ntypically I<localhost:5222>.\n\n=item B<--http> I<target address>\n\nInterface and port on which to forward HTTP connections,\ntypically I<localhost:80>.\n\n=item B<--tinc> I<target address>\n\nInterface and port on which to forward tinc connections,\ntypically I<localhost:655>.\n\nThis is experimental. If you use this feature, please report\nthe results (even if it works!)\n\n=item B<--anyprot> I<target address>\n\nInterface and port on which to forward if no other protocol\nhas been found. Because B<sslh> tries protocols in the order\nspecified on the command line, this should be specified\nlast. If no default is specified, B<sslh> will forward\nunknown protocols to the first protocol specified.\n\n=item B<-v>, B<--verbose> I<n>\n\nOverride all verboseness. Refer to B<example.cfg> for all\nverbose sub-options.\n\n=item B<-n>, B<--numeric>\n\nDo not attempt to resolve hostnames: logs will contain IP\naddresses. This is mostly useful if the system's DNS is slow\nand running the I<sslh-select> variant, as DNS requests will\nhang all connections.\n\n=item B<-V>\n\nPrints B<sslh> version.\n\n=item B<-u> I<username>, B<--user> I<username>\n\nRequires to run under the specified username. \n\n=item B<-C> I<chroot>, B<--chroot> I<chroot>\n\nRequires to run under the specified chroot.\n\n=item B<-P> I<pidfile>, B<--pidfile> I<pidfile>\n\nSpecifies a file in which to write the PID of the main\nserver.\n\n=item B<-i>, B<--inetd>\n\nRuns as an I<inetd> server. Options B<-P> (PID file), B<-p>\n(listen address), B<-u> (user) are ignored.\n\n=item B<-f>, B<--foreground>\n\nRuns in foreground. The server will not fork and will remain connected\nto the terminal. Messages normally sent to B<syslog> will also be sent\nto I<stderr>.\n\n=item B<--background>\n\nRuns in background. This overrides B<foreground> if set in\nthe configuration file (or on the command line, but there is\nno point setting both on the command line unless you have a\npersonality disorder).\n\n=back\n\n=head1 FILES\n\n=over 4\n\n=item F</etc/init.d/sslh>\n\nStart-up script. The standard actions B<start>, B<stop> and\nB<restart> are supported.\n\n=item F</etc/default/sslh>\n\nServer configuration. These are environment variables\nloaded by the start-up script and passed to B<sslh> as\ncommand-line arguments. Refer to the OPTIONS section for a\ndetailed explanation of the variables used by B<sslh>.\n\n=back\n\n=head1 SEE ALSO\n\nThe latest version is available from\nL<https://github.com/yrutschle/sslh>. There you can find a more\ndetailed and recent documentation.\n\n=head1 AUTHOR\n\nWritten by Yves Rutschle.\n"
        },
        {
          "name": "sslhconf.cfg",
          "type": "blob",
          "size": 12.9833984375,
          "content": "# This is a configuration file for the configuration\n# generator: it is used by\n# conf2struct(http://www.rutschle.net/tech/conf2struct/README.html)\n# to generate the config file and command line parser in\n# sslh-conf.c\n\nheader: \"sslh-conf.h\";\nparser: \"sslh-conf.c\";\n\nprinter: true;\n\nconffile_option: (\"F\", \"config\");\n\n# List of includes to define runtime types\n# (bug in libconfig? if swallows the brackets if they start\n# the string)\nincludes: (\n           \"probe.h\",\n           \" <sys/types.h>\",\n           \" <sys/socket.h>\",\n           \" <netdb.h>\"\n          );\n\nconfig: {\n         name : \"sslhcfg\",\n         type: \"list\",\n         items: (\n            { name: \"verbose\"; type: \"int\" default: 0;\n                short: \"v\";\n                description: \"Override all verbosness options\" },\n            { name: \"verbose-config\"; type: \"int\"; default: 0; \n                description: \"Print configuration at startup\" },\n            { name: \"verbose-config-error\"; type: \"int\"; default: 3; \n                description: \"Print configuration errors\" },\n            { name: \"verbose-connections\"; type: \"int\"; default: 3; \n                description: \"Trace established incoming address to forward address\" },\n            { name: \"verbose-connections-try\"; type: \"int\"; default: 0; \n                description: \"Connection errors\" },\n            { name: \"verbose-connections-error\"; type: \"int\"; default: 3; \n                description: \"Connection attempts towards targets\" },\n            { name: \"verbose-fd\"; type: \"int\"; default: 0; \n                description: \"File descriptor activity, open/close/whatnot\" },\n            { name: \"verbose-packets\"; type: \"int\"; default: 0; \n                description: \"Hexdump packets on which probing is done\" },\n\n            { name: \"verbose-probe-info\"; type: \"int\"; default: 0; \n                description: \"Trace the probe process\" },\n            { name: \"verbose-probe-error\"; type: \"int\"; default: 3; \n                description: \"Failures and problems during probing\" },\n\n            { name: \"verbose-system-error\"; type: \"int\"; default: 3; \n                description: \"System call failures\" },\n            { name: \"verbose-int-error\"; type: \"int\"; default: 3; \n                description: \"Internal errors that should never happen\" },\n\n            { name: \"version\"; type: \"bool\"; default: false;\n              short: \"V\";\n              description: \"Print version information and exit\"; },\n            { name: \"foreground\"; type: \"bool\"; default: false;\n              short: \"f\";\n              description: \"Run in foreground instead of as a daemon\"; },\n            { name: \"inetd\"; type: \"bool\"; default: false;\n              short: \"i\";\n              description: \"Run in inetd mode: use stdin/stdout instead of network listen\"; },\n            { name: \"numeric\"; type: \"bool\"; default: false;\n              short: \"n\";\n              description: \"Print IP addresses and ports as numbers\"; },\n            { name: \"transparent\"; type: \"bool\"; default: false;\n              description: \"Set up as a transparent proxy\"; },\n            { name: \"timeout\"; type: \"int\"; default: 5; \n              short: \"t\";\n              description: \"Set up timeout before connecting to default target\"; },\n            { name: \"udp_max_connections\"; type: \"int\"; default: 1024;\n              description: \"Number of concurrent UDP connections\"; },\n            { name: \"user\"; type: \"string\"; optional: true; \n              short: \"u\";\n              description: \"Username to change to after set-up\"; },\n            { name: \"pidfile\"; type: \"string\"; optional: true; \n              short: \"P\"; argdesc: \"<file>\";\n              description: \"Path to file to store PID of current instance\"; },\n            { name: \"chroot\"; type: \"string\"; optional: true;\n              short: \"C\"; argdesc: \"<path>\";\n              description: \"Root to change to after set-up\"; },\n            { name: \"syslog_facility\"; type: \"string\"; default: \"auth\"; \n              description: \"Facility to syslog to\"; },\n            { name: \"logfile\"; type: \"string\"; optional: true;\n              description: \"Log messages to a file\" },\n\n            { name: \"on-timeout\"; type: \"string\"; default: \"ssh\"; \n              description: \"Target to connect to when timing out\"; },\n\n            { name: \"prefix\"; type: \"string\"; default: \"\"; description: \"Reserved for testing\" }, # For echosrv only, not sslh\n\n            { name: \"listen\", \n                no_cl_accessors: true;  # disable generation of individual cl options for each group element (we create a specific --listen option further below)\n                type: \"list\", \n                items: (\n                    { name: \"host\"; type: \"string\"; var: true; },\n                    { name: \"port\"; type: \"string\"; var: true; },\n                    { name: \"is_udp\"; type: \"bool\"; default: false },\n                    { name: \"is_unix\"; type: \"bool\"; default: false },\n                    { name: \"keepalive\"; type: \"bool\"; default: false; }\n                )\n            },\n\n            { name: \"protocols\",\n                no_cl_accessors: true;\n                type: \"list\",\n                items: (\n                    { name: \"name\"; type: \"string\"; },\n                    { name: \"host\"; type: \"string\"; var: true; },\n                    { name: \"port\"; type: \"string\"; var: true; },\n                    { name: \"service\"; type: \"string\"; optional: true; },\n                    { name: \"is_unix\"; type: \"bool\"; default: false },\n                    { name: \"is_udp\"; type: \"bool\"; default: false },\n                    { name: \"udp_timeout\"; type: \"int\"; default: 60 },\n                    { name: \"fork\"; type: \"bool\"; default: false },\n                    { name: \"tfo_ok\"; type: \"bool\"; default: false;\n                        description: \"Set to true if this protocol supports TCP FAST OPEN\" },\n                    { name: \"transparent\"; type: \"bool\"; default: false;\n                        description: \"Set to proxy this protocol transparently\" },\n                    { name: \"resolve_on_forward\"; type: \"bool\"; default: false;\n                        description: \"Set to true if server address should be resolved on (every) newly incoming connection (again)\" },\n                    { name: \"log_level\"; type: \"int\"; default: 1 },\n                    { name: \"keepalive\"; type: \"bool\"; default: false },\n                    { name: \"sni_hostnames\",\n                        type: \"array\", \n                        element_type: \"string\"\n                    },\n                    { name: \"alpn_protocols\",\n                    type: \"array\",\n                    element_type: \"string\" \n                    },\n                    { name: \"regex_patterns\",\n                    type: \"array\",\n                    element_type: \"string\"\n                    },\n                    { name: \"minlength\"; type: \"int\"; optional: true },\n\n                    # Runtime data\n                    { name: \"probe\"; type: \"runtime\"; c_type: \"T_PROBE*\" },\n                    { name: \"saddr\"; type: \"runtime\"; c_type: \"struct addrinfo*\" },\n                    { name: \"data\"; type: \"runtime\"; c_type: \"void*\" },\n                    { name: \"timeouts\"; type: \"runtime\"; c_type: \"dl_list\" }\n                )\n            }\n        )\n}\n\n# Command line for list settings: additional options that\n# can set up several settings at once. Each option will\n# create a new group setting entry if required (with\n# defaults set up)\n# This only works with string targets\n# This may not be the right abstraction at all and way too\n# sslh-centric\ncl_groups: (\n    { name: \"listen\"; pattern: \"(.+):(\\w+)\"; description: \"Listen on host:port\";\n      short: \"p\"; argdesc: \"<host:port>\";\n        list: \"listen\";\n        # no override, this just adds to the list (and thus can be specified several times)\n        targets: (\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" }\n        );\n    },\n    { name: \"ssh\"; pattern: \"(.+):(\\w+)\";  description: \"Set up ssh target\";\n        list: \"protocols\"; # List name that we're defining with this command line option\n        override: \"name\";  # Field in the group to override.  If not found in list, add an item\n                           # (it's mandatory to have that field as one of the targets\n                           # below)\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"ssh\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"fork\"; value: 1 },\n        { path: \"log_level\"; value: 1 },\n        { path: \"tfo_ok\"; value: 1 }\n        );\n    },\n    { name: \"tls\"; pattern: \"(.+):(\\w+)\"; description: \"Set up TLS/SSL target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"tls\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 },\n        { path: \"tfo_ok\"; value: 1 }\n        );\n    },\n    # Redundant with the --tls setting before, for backwards compatibility\n    { name: \"ssl\"; pattern: \"(.+):(\\w+)\"; description: \"Set up TLS/SSL target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"tls\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 },\n        { path: \"tfo_ok\"; value: 1 }\n        );\n    },\n    { name: \"openvpn\"; pattern: \"(.+):(\\w+)\"; description: \"Set up OpenVPN target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"openvpn\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 },\n        { path: \"tfo_ok\"; value: 1 }\n        );\n    },\n    { name: \"tinc\"; pattern: \"(.+):(\\w+)\"; description: \"Set up tinc target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"tinc\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 },\n        { path: \"tfo_ok\"; value: 1 }\n        );\n    },\n    { name: \"wireguard\"; pattern: \"(.+):(\\w+)\"; description: \"Set up WireGuard target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"wireguard\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 },\n        { path: \"tfo_ok\"; value: 1 }\n        );\n    },\n    { name: \"xmpp\"; pattern: \"(.+):(\\w+)\"; description: \"Set up XMPP target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"xmpp\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    },\n    { name: \"http\"; pattern: \"(.+):(\\w+)\"; description: \"Set up HTTP (plain) target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"http\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    },\n    { name: \"adb\"; pattern: \"(.+):(\\w+)\"; description: \"Set up ADB (Android Debug) target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"adb\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    },\n    { name: \"socks5\"; pattern: \"(.+):(\\w+)\"; description: \"Set up socks5 target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"socks5\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    },\n    { name: \"syslog\"; pattern: \"(.+):(\\w+)\"; description: \"Set up syslog target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"syslog\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    },\n    { name: \"msrdp\"; pattern: \"(.+):(\\w+)\"; description: \"Set up msrdp target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"msrdp\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    },\n    { name: \"anyprot\"; pattern: \"(.+):(\\w+)\"; description: \"Set up default target\";\n        list: \"protocols\";\n        override: \"name\";\n        argdesc: \"<host:port>\";\n        targets: (\n        { path: \"name\"; value: \"anyprot\" },\n        { path: \"host\"; value: \"$1\" },\n        { path: \"port\"; value: \"$2\" },\n        { path: \"log_level\"; value: 1 }\n        );\n    }\n)\n"
        },
        {
          "name": "systemd-sslh-generator.c",
          "type": "blob",
          "size": 11.7021484375,
          "content": "#include <libconfig.h>\n#include <dirent.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdarg.h>\n#include <sys/stat.h>\n#include \"common.h\"\n\n\n#define print_message(sink, format, file, line) fprintf(stderr, format, file, line)                                                                                                                                               \n\ntypedef struct FileList FileList;\n\nstruct FileList {\n    char *name;\n    struct FileList *prev;\n};\n\nstatic void free_file_list(FileList *fl) {\n    while (fl != NULL) {\n        FileList *prev = fl->prev;\n        free(fl->name);\n        free(fl);\n        fl = prev;\n    }\n}\n\nstatic FILE *err_log;\nstatic bool systemd_invoked = false;\nstatic const char\n        *socket_ext = \".socket\",\n        *dropin_ext = \".conf\",\n        *service_ext = \".service.d/\",\n        *fork_unit_file = \"/sslh@\",\n        *select_unit_file = \"/sslh-select@\",\n        *fork_unit = \"# Automatically generated by systemd-sslh-generator\\n\\n\"\n                     \"[Unit]\\n\"\n                     \"Requires=sslh@%s.socket\\n\"\n                     \"Conflicts=sslh-select@%s.service\\n\"\n                     \"PartOf=sslh@%s.socket\\n\",\n        *select_unit = \"# Automatically generated by systemd-sslh-generator\\n\\n\"\n                       \"[Unit]\\n\"\n                       \"Requires=sslh@%s.socket\\n\"\n                       \"Conflicts=sslh@%s.service\\n\"\n                       \"PartOf=sslh@%s.socket\\n\";\n\nstatic char *resolve_listen(const char *hostname, const char *port) {\n    char *conn = calloc(1, strlen(hostname) + strlen(port) + 2);\n    CHECK_ALLOC(conn, \"malloc\")\n    strcpy(conn, hostname);\n    strcat(conn, \":\");\n    strcat(conn, port);\n    return conn;\n}\n\nstatic int get_listen_from_conf(const char *filename, char **listen[]) {\n    config_t config;\n    config_setting_t *setting, *addr;\n    const char *hostname, *port;\n    int len = 0;\n\n    config_init(&config);\n    if (config_read_file(&config, filename) == CONFIG_FALSE) {\n        if (config_error_line(&config) != 0) {\n            fprintf(err_log,\n                    \"systemd-sslh-generator: %s%d%s\\n\",\n                    filename,\n                    config_error_line(&config),\n                    config_error_text(&config));\n            return -1;\n        }\n    } else {\n        setting = config_lookup(&config, \"listen\");\n        if (setting) {\n            len = config_setting_length(setting);\n            *listen = malloc(len * sizeof(**listen));\n            CHECK_ALLOC(*listen, \"malloc\")\n            for (int i = 0; i < len; i++) {\n                addr = config_setting_get_elem(setting, i);\n                if (!(config_setting_lookup_string(addr, \"host\", &hostname) && config_setting_lookup_string(addr, \"port\", &port))) {\n                    fprintf(err_log,\n                            \"systemd-sslh-generator: line %d:Incomplete specification (hostname and port required)\\n\",\n                            config_setting_source_line(addr));\n                    return -1;\n                } else {\n                    (*listen)[i] = resolve_listen(hostname, port);\n                }\n            }\n        }\n    }\n    return len;\n}\n\nstatic void write_socket_unit(FILE *socket, char *listen[], int num_addr, const char *cfg, const char *source) {\n    fprintf(socket,\n            \"# Automatically generated by systemd-sslh-generator\\n\\n\"\n            \"[Unit]\\n\"\n            \"Before=sslh@%s.service\\n\"\n            \"SourcePath=%s\\n\"\n            \"PartOf=sslh@%s.service\\n\"\n            \"Documentation=man:sslh(8) man:systemd-sslh-generator(8)\\n\\n\"\n            \"[Socket]\\n\"\n            \"FreeBind=true\\n\",\n            cfg,\n            source,\n            cfg);\n    for (int i = 0; i < num_addr; i++) {\n        fprintf(socket, \"ListenStream=%s\\n\", listen[i]);\n    }\n    fprintf(socket,\n           \"\\n[Install]\\n\"\n           \"WantedBy=sockets.target\\n\");\n}\n\nstatic int write_unit_dropin(const char *runtime_unit_dir, const bool is_fork, const char *cfg) {\n    const char\n        *unit_file = is_fork ? fork_unit_file : select_unit_file,\n        *unit_string = is_fork ? fork_unit : select_unit;\n    FILE *dropin_fd = stdout;\n    if (systemd_invoked) {\n        //Systemd drop-in configuration for the base select service sslh@%I.service\n        const size_t runtime_len = strlen(runtime_unit_dir);\n        size_t len = strlen(unit_file) + strlen(cfg) + strlen(service_ext) + strlen(dropin_ext);\n        char dropin_dir[runtime_len + len + 1];\n        strcpy(dropin_dir, runtime_unit_dir);\n        strcat(dropin_dir, unit_file);\n        strcat(dropin_dir, cfg);\n        strcat(dropin_dir, service_ext);\n\n        if (mkdir(dropin_dir, S_IRWXU | S_IRWXG | S_IROTH)) {\n            fprintf(err_log,\n                    \"systemd-sslh-generator: Could not create directory '%s' to generate drop-in configuration: %s\\n\",\n                    dropin_dir,\n                    strerror(errno));\n            return errno;\n        }\n\n        len = len + strlen(cfg) + strlen(dropin_ext);\n        char dropin_path[len + 1];\n        strcpy(dropin_path, dropin_dir);\n        strcat(dropin_path, cfg);\n        strcat(dropin_path, dropin_ext);\n        dropin_fd = fopen(dropin_path, \"w\");\n        if (!dropin_fd) {\n            fprintf(err_log,\n                    \"systemd-sslh-generator: Could not open '%s' to generate drop-in configuration: %s\\n\",\n                    dropin_path,\n                    strerror(errno));\n            return errno;\n        }\n    }\n    fprintf(dropin_fd, unit_string, cfg, cfg, cfg);\n    if (systemd_invoked) {\n        fclose(dropin_fd);\n    }\n    return 0;\n}\n\nstatic int gen_sslh_config(char *runtime_unit_dir) {\n    int status = 0;\n    const char *config_dir = \"/etc/sslh/\";\n    char **listen;\n    DIR *d = opendir(config_dir);\n    FileList *fa = NULL;\n\n    if (d) {\n        struct dirent *dir;\n        while ((dir = readdir(d)) != NULL) {\n            if ((strcmp(dir->d_name, \".\") == 0) || (strcmp(dir->d_name, \"..\") == 0)) {\n                continue;\n            }\n            FileList *lfa = malloc(sizeof(FileList));\n            CHECK_ALLOC(lfa, \"malloc\")\n            lfa->name = malloc(strlen(dir->d_name) + 1);\n            CHECK_ALLOC(lfa->name, \"malloc\")\n            strcpy(lfa->name, dir->d_name);\n            lfa->prev = NULL;\n            if (fa) {\n                lfa->prev = fa;\n            }\n            fa = lfa;\n        }\n        closedir(d);\n    } else {\n        fprintf(err_log,\n                \"systemd-sslh-generator: Configuration directory '/etc/sslh/' does not exist! No units generated.\\n\");\n        //Config directory /etc/sslh/ does not exist\n        return 0;\n    }\n    if (!fa) {\n        fprintf(err_log,\n                \"systemd-sslh-generator: Configuration directory '/etc/sslh/' is empty! No units generated.\\n\");\n        //No configuration files in /etc/sslh/\n        return 0;\n    }\n    FileList *fa_ref = fa;\n//    size_t num_listen_addresses = 0;\n//    char **listen_addresses = NULL;\n    //Process all config files\n    do {\n        char *end = strstr(fa->name, \".cfg\");\n        if (!end) {\n            continue;\n        }\n        //Current sslh config name\n        const size_t end_count = end - fa->name;\n        char config_name[end_count + 1];\n        memcpy(config_name, fa->name, end_count);\n        config_name[end_count] = '\\0';\n\n        //Full path to current sslh config\n        char full_path[strlen(config_dir) + strlen(fa->name) + 1];\n        strcpy(full_path, config_dir);\n        strcat(full_path, fa->name);\n        FILE *config = fopen(full_path, \"r\");\n        if (!config) {\n            fprintf(err_log,\n                    \"systemd-sslh-generator: Could not open config file '%s': %s\\n\",\n                    full_path,\n                    strerror(errno));\n            return errno;\n        } else {\n            fclose(config);\n            int num_addr = get_listen_from_conf(full_path, &listen);\n            if (num_addr <= 0) {\n                fprintf(err_log,\n                        \"systemd-sslh-generator: sslh config '%s' contains no valid listen configurations!\\n\",\n                        fa->name);\n                status |= -1;\n                continue;\n            }\n            FILE *socket_fd = stdout;\n            if (systemd_invoked) {\n                //Systemd socket for the current sslh config\n                const size_t len = strlen(runtime_unit_dir) + strlen(fork_unit_file) + strlen(config_name) + strlen(socket_ext);\n                char socket_path[len + 1];\n                strcpy(socket_path, runtime_unit_dir);\n                strcat(socket_path, fork_unit_file);\n                strcat(socket_path, config_name);\n                strcat(socket_path, socket_ext);\n                socket_fd = fopen(socket_path, \"w\");\n                if (!socket_fd) {\n                    fprintf(err_log,\n                            \"systemd-sslh-generator: Could not open '%s' to generate socket configuration: %s\\n\",\n                            socket_path,\n                            strerror(errno));\n                    status |= errno;\n                    continue;\n                }\n            }\n            //Write socket unit\n            write_socket_unit(socket_fd, listen, num_addr, config_name, full_path);\n            //Write forking drop-in config\n            status |= write_unit_dropin(runtime_unit_dir, false, config_name);\n            //Write select drop-in config\n            status |= write_unit_dropin(runtime_unit_dir, true, config_name);\n            if (systemd_invoked) {\n                fclose(socket_fd);\n            }\n//            if (listen_addresses) {\n//                //Check for overlapping addresses\n//                for (size_t i = 0; i < num_listen_addresses; i++) {\n//                    for (size_t j = 0; j < num_addr; j++) {\n//                        if (strcmp(*(listen_addresses + i), *(listen + j)) == 0) {\n//                            fprintf(err_log, \"systemd-sslh-generator: Overlapping listen addresses across sslh configurations!\");\n//                            return -1;\n//                        }\n//                    }\n//                }\n//            }\n//            char *listen_addresses_copy[num_listen_addresses + num_addr];\n//            if (listen_addresses) {\n//                //Copy previous configurations' listen addresses into temp\n//                memcpy(listen_addresses_copy, listen_addresses, num_listen_addresses);\n//                //Free global list of listen addresses\n//                free(listen_addresses);\n//            }\n//            //Copy listen addresses from current configuration into temp\n//            memcpy(listen_addresses_copy + num_listen_addresses, listen, num_addr);\n//            num_listen_addresses += num_addr;\n//            listen_addresses = malloc(num_listen_addresses * sizeof(char *));\n//            CHECK_ALLOC(listen_addresses, \"malloc\")\n//            //Append all addresses to global list\n//            memcpy(listen_addresses, listen_addresses_copy, num_listen_addresses);\n            //Free all allocated listen strings\n            for (size_t i = 0; i < num_addr; i++) {\n                free(*(listen + i));\n            }\n        }\n    } while((fa = fa->prev));\n    free_file_list(fa_ref);\n    return status;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc == 1 || argc == 4) {\n        systemd_invoked = argc == 4;\n        if (systemd_invoked) {\n            err_log = fopen(\"/dev/kmsg\", \"w\");\n            if (!err_log) {\n                return -1;\n            }\n        } else {\n            err_log = stderr;\n        }\n        const int r = gen_sslh_config(systemd_invoked ? argv[1] : \"\");\n        if (systemd_invoked) {\n            fclose(err_log);\n        }\n        if (!r) {\n            fprintf(err_log, \"systemd-sslh-generator: Successfully generated all targets.\\n\");\n        }\n        return r < 0 ? -1 : 0;\n    } else {\n        printf(\"This program takes three or no arguments.\\n\");\n        return -1;\n    }\n}\n"
        },
        {
          "name": "t",
          "type": "blob",
          "size": 18.328125,
          "content": "#! /usr/bin/perl -w\n\n# Test script for sslh\n\n# Uses Conf::Libconfig to read sslh config file: install\n# with:\n# cpan Conf::Libconfig\n\nuse strict;\nuse IO::Socket::INET6;\nuse Test::More qw/no_plan/;\nuse Conf::Libconfig;\n\nmy $conf = new Conf::Libconfig;\n$conf->read_file(\"test.cfg\");\n\n\nmy $no_listen = 8083;  # Port on which no-one listens\nmy $pidfile = $conf->lookup_value(\"pidfile\");\nmy $sslh_port = $conf->fetch_array(\"listen\")->[0]->{port};\nmy $user = (getpwuid $<)[0]; # Run under current username\n\n# Which tests do we run\nmy $SSH_SHY_CNX =       0;\nmy $PROBES_NOFRAG =     1;\nmy $PROBES_AGAIN =      1;\nmy $SSL_MIX_SSH =       1;\nmy $SSH_MIX_SSL =       1;\nmy $DROP_CNX =          1;\n\n# Robustness tests. These are mostly to achieve full test\n# coverage, but do not necessarily result in an actual test\n# (e.g. some tests need to be run with valgrind to check all\n# memory management code).\nmy $RB_CNX_NOSERVER =           0;\nmy $RB_PARAM_NOHOST =           0;\nmy $RB_WRONG_USERNAME =         0;\nmy $RB_OPEN_PID_FILE =          0;\nmy $RB_RESOLVE_ADDRESS =        0;\nmy $RB_CL_PARAMS =              0;\n\n`lcov --directory . --zerocounters`;\n\nsub verbose_exec\n{\n    my ($cmd) = @_;\n\n    warn \"$cmd\\n\";\n    if (!fork) {\n        exec $cmd;\n    }\n}\n\n# We want to keep track of tests to print a report at the\n# end, so we centralise all calls to Test::More::is here\nmy $cnt = 1;   # test counter\nmy @results;\nsub my_is {\n    my ($a, $b, $desc) = @_;\n\n    my $res =  is($a, $b, $desc);\n    push @results, [$cnt++, $desc, $res];\n}\n\n\n\n# For SNI/ALPN, build a protocol name as such:\n# tls:sni1,sni2,...;alpn1,alpn2,...\n# input: a protocol entry from Libconfig\nsub make_sni_alpn_name {\n    my ($prot) = @_;\n\n   return \"tls:\" . (join \",\", @{$prot->{sni_hostnames} // []})\n           . \";\" . (join \",\", @{$prot->{alpn_protocols} // [] });\n}\n\n\n# Tests one probe: given input data, connect, verify we get\n# the expected server, verify shoveling works\n# Named options:\n# data: what to write\n# expected: expected protocol prefix\n# no_frag: don't print byte-per-byte\nsub test_probe {\n    my (%opts) = @_;\n\n    my $cnx = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n    warn \"$!\\n\" unless $cnx;\n    return unless $cnx;\n\n    my $pattern = $opts{data};\n    if ($opts{no_frag}) {\n        syswrite $cnx, $pattern;\n    } else {\n        while (length $pattern) {\n            syswrite $cnx, (substr $pattern, 0, 1, '');\n            select undef, undef, undef, .01;\n        }\n    }\n\n    my $data;\n    my $n = sysread $cnx, $data, 1024;\n    $data =~ /^(.*?): /;\n    my $prefix = $1;\n    $data =~ s/$prefix: //g;\n    print \"Received $n bytes: protocol $prefix data [$data]\\n\";\n    close $cnx;\n\n    $opts{expected} =~ s/^ssl/tls/; # to remove in 1.21\n    my_is($prefix, $opts{expected}, \"$opts{binary}:$opts{expected}: probe connected correctly\");\n    my_is($data, $opts{data}, \"$opts{binary}:$opts{expected}: data shoveled correctly\");\n}\n\n# Test all probes, with or without fragmentation\n# options:\n#     no_frag: write test patterns all at once (also\n#     available per-protocol as some probes don't support\n#     fragmentation)\nsub test_probes {\n    my (%in_opts) = @_;\n\n    my @probes = @{$conf->fetch_array(\"protocols\")};\n    foreach my $p (@probes) {\n        my %protocols = (\n            'ssh' => { data => \"SSH-2.0 tester\" },\n            'socks5' => { data => \"\\x05\\x04\\x01\\x02\\x03\\x04\" },\n            'http' => { \n                data => \"GET index.html HTTP/1.1\",\n                no_frag => 1 },\n            'tls' => { \n                # Packet with SNI and ALPN (`openssl s_client -connect localhost:443 -alpn alpn1 -servername sni1`)\n                data_sni_alpn => \"\\x16\\x03\\x01\\x00\\xc4\\x01\\x00\\x00\\xc0\\x03\\x03\\x03\\x19\\x01\\x00\\x40\\x14\\x13\\xcc\\x1b\\x94\\xad\\x20\\x5d\\x13\\x1a\\x8d\\xd2\\x65\\x23\\x70\\xde\\xd1\\x3c\\x5d\\x05\\x19\\xcb\\x27\\x0d\\x7c\\x2c\\x89\\x00\\x00\\x38\\xc0\\x2c\\xc0\\x30\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\x2b\\xc0\\x2f\\x00\\x9e\\xc0\\x24\\xc0\\x28\\x00\\x6b\\xc0\\x23\\xc0\\x27\\x00\\x67\\xc0\\x0a\\xc0\\x14\\x00\\x39\\xc0\\x09\\xc0\\x13\\x00\\x33\\x00\\x9d\\x00\\x9c\\x00\\x3d\\x00\\x3c\\x00\\x35\\x00\\x2f\\x00\\xff\\x01\\x00\\x00\\x5f\\x00\\x00\\x00\\x09\\x00\\x07\\x00\\x00\\x04\\$sni\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x0a\\x00\\x08\\x00\\x1d\\x00\\x17\\x00\\x19\\x00\\x18\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x20\\x00\\x1e\\x06\\x01\\x06\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x00\\x10\\x00\\x08\\x00\\x06\\x05\\$alpn\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00hello sni/alpn\",\n                # Packet with SNI alone\n                data_sni => \"\\x16\\x03\\x01\\x00\\xb8\\x01\\x00\\x00\\xb4\\x03\\x03\\x97\\xe4\\xe9\\xad\\x86\\xe1\\x21\\xfd\\xc4\\x5b\\x27\\x0e\\xad\\x4b\\x55\\xc2\\x50\\xe4\\x1c\\x86\\x2f\\x37\\x25\\xde\\xe8\\x9c\\x59\\xfc\\x1b\\xa9\\x37\\x32\\x00\\x00\\x38\\xc0\\x2c\\xc0\\x30\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\x2b\\xc0\\x2f\\x00\\x9e\\xc0\\x24\\xc0\\x28\\x00\\x6b\\xc0\\x23\\xc0\\x27\\x00\\x67\\xc0\\x0a\\xc0\\x14\\x00\\x39\\xc0\\x09\\xc0\\x13\\x00\\x33\\x00\\x9d\\x00\\x9c\\x00\\x3d\\x00\\x3c\\x00\\x35\\x00\\x2f\\x00\\xff\\x01\\x00\\x00\\x53\\x00\\x00\\x00\\x09\\x00\\x07\\x00\\x00\\x04\\$sni\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x0a\\x00\\x08\\x00\\x1d\\x00\\x17\\x00\\x19\\x00\\x18\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x20\\x00\\x1e\\x06\\x01\\x06\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00hello sni\",\n                # packet with ALPN alone\n                data_alpn => \"\\x16\\x03\\x01\\x00\\xb7\\x01\\x00\\x00\\xb3\\x03\\x03\\xe2\\x90\\xa2\\x29\\x03\\x31\\xad\\x98\\x44\\x51\\x54\\x90\\x5b\\xd9\\x51\\x0e\\x66\\xb5\\x3f\\xe8\\x8b\\x09\\xc9\\xe4\\x2b\\x97\\x24\\xef\\xad\\x56\\x06\\xc9\\x00\\x00\\x38\\xc0\\x2c\\xc0\\x30\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\x2b\\xc0\\x2f\\x00\\x9e\\xc0\\x24\\xc0\\x28\\x00\\x6b\\xc0\\x23\\xc0\\x27\\x00\\x67\\xc0\\x0a\\xc0\\x14\\x00\\x39\\xc0\\x09\\xc0\\x13\\x00\\x33\\x00\\x9d\\x00\\x9c\\x00\\x3d\\x00\\x3c\\x00\\x35\\x00\\x2f\\x00\\xff\\x01\\x00\\x00\\x52\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x0a\\x00\\x08\\x00\\x1d\\x00\\x17\\x00\\x19\\x00\\x18\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x20\\x00\\x1e\\x06\\x01\\x06\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x00\\x10\\x00\\x08\\x00\\x06\\x05\\$alpn\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00hello alpn\",\n                # packet with no SNI, no ALPN\n                data => \"\\x16\\x03\\x01\\x00\\xab\\x01\\x00\\x00\\xa7\\x03\\x03\\x89\\x22\\x33\\x95\\x43\\x7a\\xc3\\x89\\x45\\x51\\x12\\x3c\\x28\\x24\\x1b\\x6a\\x78\\xbf\\xbe\\x95\\xd8\\x90\\x58\\xd7\\x65\\xf7\\xbb\\x2d\\xb2\\x8d\\xa0\\x75\\x00\\x00\\x38\\xc0\\x2c\\xc0\\x30\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\x2b\\xc0\\x2f\\x00\\x9e\\xc0\\x24\\xc0\\x28\\x00\\x6b\\xc0\\x23\\xc0\\x27\\x00\\x67\\xc0\\x0a\\xc0\\x14\\x00\\x39\\xc0\\x09\\xc0\\x13\\x00\\x33\\x00\\x9d\\x00\\x9c\\x00\\x3d\\x00\\x3c\\x00\\x35\\x00\\x2f\\x00\\xff\\x01\\x00\\x00\\x46\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x0a\\x00\\x08\\x00\\x1d\\x00\\x17\\x00\\x19\\x00\\x18\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x20\\x00\\x1e\\x06\\x01\\x06\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00hello tls alone\"\n            },\n            'openvpn' => { data => \"\\x00\\x00\" },\n            'syslog' => { data => \"<42> My syslog message\" },\n            'tinc' => { data => \"0 hello\" },\n            'xmpp' => {data => \"I should get a real jabber connection initialisation here\" },\n            'adb' => { data => \"CNXN....................host:...\" },\n            'anyprot' => {data => \"hello anyprot this needs to be longer than xmpp and adb which expect about 50 characters, which I all have to write before the timeout!\" },\n        );\n\n        my $pattern = $protocols{$p->{name}}->{data};\n\n        my %opts = %in_opts;\n        $opts{no_frag} = 1 if $protocols{$p->{name}}->{no_frag};\n\n        if ($p->{sni_hostnames} or $p->{alpn_protocols}) {\n            my $pname = make_sni_alpn_name($p);\n\n            my @sni = @{$p->{sni_hostnames} // [\"\"] };\n            my @alpn = @{$p->{alpn_protocols} // [\"\"] };\n\n            foreach my $sni ( @sni ) {\n                foreach my $alpn ( @alpn ) {\n                    print \"sni: $sni\\nalpn: $alpn\\n\";\n                    $pattern = $protocols{tls}->{\n                        \"data\". ($sni ?  \"_sni\" : \"\") . \n                                ($alpn ?  \"_alpn\": \"\")\n                    };\n                    $pattern =~ s/(\\$\\w+)/$1/eeg;\n\n                    test_probe(\n                        data => $pattern,\n                        expected => $pname,\n                        %opts\n                    );\n                }\n            }\n        } elsif ($p->{name} eq 'regex') {\n            foreach my $test (@{$p->{test_patterns}}) {\n                test_probe(\n                    data => $test->{pattern},\n                    expected => $test->{result},\n                    %opts\n                );\n            }\n        } else {\n            test_probe(\n                data => $pattern,\n                expected => $p->{name},\n                %opts\n            );\n\n        }\n    }\n}\n\n\n\n# Start an echoserver for each service\nforeach my $s (@{$conf->fetch_array(\"protocols\")}) {\n    my $prefix = $s->{name};\n\n    $prefix =~ s/^ssl/tls/; # To remove in 1.21\n\n    if ($s->{sni_hostnames} or $s->{alpn_protocols}) {\n        $prefix = make_sni_alpn_name($s);\n    }\n\n    verbose_exec \"./echosrv --listen $s->{host}:$s->{port} --prefix '$prefix: '\";\n}\n\n\n#my @binaries = ('sslh-select', 'sslh-fork');\nmy @binaries = ('sslh-select');\n\nfor my $binary (@binaries) {\n    warn \"Testing $binary\\n\";\n\n# Start sslh with the right plumbing\n    my ($sslh_pid, $valgrind);\n    if (!($sslh_pid = fork)) {\n        my $user = (getpwuid $<)[0]; # Run under current username\n        my $cmd = \"./$binary -v 4 -f -u $user -F test.cfg\";\n        #$valgrind = 1;\n        #$cmd = \"valgrind --leak-check=full $cmd\";\n        verbose_exec $cmd;\n        exit 0;\n    }\n    warn \"spawned $sslh_pid\\n\";\n    sleep 1; # Give everyone some time to start\n    sleep 5 if $valgrind;  # valgrind can be heavy -- wait 5 seconds\n\n\n    my $test_data = \"hello world\\n\";\n    my $ssl_test_data =  \"\\x16\\x03\\x01\\x00\\xab\\x01\\x00\\x00\\xa7\\x03\\x03\\x89\\x22\\x33\\x95\\x43\\x7a\\xc3\\x89\\x45\\x51\\x12\\x3c\\x28\\x24\\x1b\\x6a\\x78\\xbf\\xbe\\x95\\xd8\\x90\\x58\\xd7\\x65\\xf7\\xbb\\x2d\\xb2\\x8d\\xa0\\x75\\x00\\x00\\x38\\xc0\\x2c\\xc0\\x30\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\x2b\\xc0\\x2f\\x00\\x9e\\xc0\\x24\\xc0\\x28\\x00\\x6b\\xc0\\x23\\xc0\\x27\\x00\\x67\\xc0\\x0a\\xc0\\x14\\x00\\x39\\xc0\\x09\\xc0\\x13\\x00\\x33\\x00\\x9d\\x00\\x9c\\x00\\x3d\\x00\\x3c\\x00\\x35\\x00\\x2f\\x00\\xff\\x01\\x00\\x00\\x46\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x0a\\x00\\x08\\x00\\x1d\\x00\\x17\\x00\\x19\\x00\\x18\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x20\\x00\\x1e\\x06\\x01\\x06\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00hello tls alone\";\n\n# Test: Shy SSH connection\n    if ($SSH_SHY_CNX) {\n        print \"***Test: Shy SSH connection\\n\";\n        my $cnx_h = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n        warn \"$!\\n\" unless $cnx_h;\n        if (defined $cnx_h) {\n            sleep 13;\n            print $cnx_h $test_data;\n            my $data = <$cnx_h>;\n            my_is($data, \"ssh: $test_data\", \"$binary: Shy SSH connection\");\n        }\n    }\n\n# Test: One SSL half-started then one SSH\n    if ($SSL_MIX_SSH) {\n        print \"***Test: One SSL half-started then one SSH\\n\";\n        my $cnx_l = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n        warn \"$!\\n\" unless $cnx_l;\n        if (defined $cnx_l) {\n            print $cnx_l $ssl_test_data;\n            my $cnx_h= new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n            warn \"$!\\n\" unless $cnx_h;\n            if (defined $cnx_h) {\n                sleep 3;\n                print $cnx_h $test_data;\n                my $data_h = <$cnx_h>;\n                my_is($data_h, \"ssh: $test_data\", \"$binary: SSH during SSL being established\");\n            }\n            my $data;\n            my $n = sysread $cnx_l, $data, 1024;\n            my_is($data, \"tls: $ssl_test_data\", \"$binary: SSL connection interrupted by SSH\");\n        }\n    }\n\n# Test: One SSH half-started then one SSL\n    if ($SSH_MIX_SSL) {\n        print \"***Test: One SSH half-started then one SSL\\n\";\n        my $cnx_h = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n        warn \"$!\\n\" unless $cnx_h;\n        if (defined $cnx_h) {\n            sleep 3;\n            my $cnx_l = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n            warn \"$!\\n\" unless $cnx_l;\n            if (defined $cnx_l) {\n                print $cnx_l $ssl_test_data;\n                my $data;\n                my $n = sysread $cnx_l, $data, 1024;\n                my_is($data, \"tls: $ssl_test_data\", \"$binary: SSL during SSH being established\");\n            }\n            print $cnx_h $test_data;\n            my $data = <$cnx_h>;\n            my_is($data, \"ssh: $test_data\", \"$binary: SSH connection interrupted by SSL\");\n        }\n    }\n\n# Test: Drop connection without writing anything\n    if ($DROP_CNX) {\n        print \"***Test: Connect but don't write anything\\n\";\n        my $cnx_h = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n        warn \"$!\\n\" unless $cnx_h;\n        if ($cnx_h) {\n            close $cnx_h;\n            my_is(1, \"$binary: Connect and write nothing\");\n            # The goal of the test is to check sslh doesn't\n            # crash\n        }\n    }\n\n\n    if ($PROBES_NOFRAG) {\n        test_probes(no_frag => 1, binary => $binary);\n    }\n\n    if ($PROBES_AGAIN) {\n        test_probes(binary => $binary);\n    }\n\n    my $pid = `cat $pidfile`;\n    warn \"killing $pid\\n\";\n    kill TERM => $pid or warn \"kill process: $!\\n\";\n    sleep 1;\n}\n\n# Robustness: Connecting to non-existant server\nif ($RB_CNX_NOSERVER) {\n    print \"***Test: Connecting to non-existant server\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        exec \"./sslh-select -v 3 -f -u $user --listen localhost:$sslh_port --ssh localhost:$no_listen --tls localhost:$no_listen -P $pidfile\";\n    }\n    warn \"spawned $sslh_pid\\n\";\n\n    sleep 1;\n\n    my $cnx_h = new IO::Socket::INET(PeerHost => \"localhost:$sslh_port\");\n    warn \"$!\\n\" unless $cnx_h;\n    if (defined $cnx_h) {\n        sleep 1;\n        my $test_data = \"hello\";\n        print $cnx_h $test_data;\n    }\n    # Ideally we should check a log is emitted.\n\n    kill TERM => `cat $pidfile` or warn \"kill: $!\\n\";\n    sleep 1;\n}\n\n\nmy $ssh_conf = (grep { $_->{name} eq \"ssh\" } @{$conf->fetch_array(\"protocols\")})[0];\nmy $ssh_address = $ssh_conf->{host} . \":\" .  $ssh_conf->{port};\n\n# Use the last TLS echoserv (no SNI/ALPN)\nmy $ssl_conf = (grep { $_->{name} eq \"tls\" } @{$conf->fetch_array(\"protocols\")})[-1];\nmy $ssl_address = $ssl_conf->{host} . \":\" .  $ssl_conf->{port};\n\n\n# Robustness: No hostname in address\nif ($RB_PARAM_NOHOST) {\n    print \"***Test: No hostname in address\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        exec \"./sslh-select -v 3 -f -u $user --listen $sslh_port --ssh $ssh_address --tls $ssl_address -P $pidfile\";\n    }\n    warn \"spawned $sslh_pid\\n\";\n    waitpid $sslh_pid, 0;\n    my $code = $? >> 8;\n    warn \"exited with $code\\n\";\n    my_is($code, 6, \"Exit status on illegal option\");\n}\n\n# Robustness: User does not exist\nif ($RB_WRONG_USERNAME) {\n    print \"***Test: Changing to non-existant username\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        exec \"./sslh-select -v 3 -f -u ${user}_doesnt_exist --listen localhost:$no_listen --ssh $ssh_address --tls $ssl_address -P $pidfile\";\n    }\n    warn \"spawned $sslh_pid\\n\";\n    waitpid $sslh_pid, 0;\n    my $code = $? >> 8;\n    warn \"exited with $code\\n\";\n    my_is($code, 2, \"Exit status on non-existant username\");\n}\n\n# Robustness: Can't open PID file\nif ($RB_OPEN_PID_FILE) {\n    print \"***Test: Can't open PID file\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        exec \"./sslh-select -v 3 -f -u $user --listen localhost:$no_listen --ssh $ssh_address --tls $ssl_address -P /dont_exist/$pidfile\";\n        # You don't have a /dont_exist/ directory, do you?!\n    }\n    warn \"spawned $sslh_pid\\n\";\n    waitpid $sslh_pid, 0;\n    my $code = $? >> 8;\n    warn \"exited with $code\\n\";\n    my_is($code, 3, \"Exit status if can't open PID file\");\n}\n\n# Robustness: Can't resolve address\nif ($RB_RESOLVE_ADDRESS) {\n    print \"***Test: Can't resolve address\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        my $user = (getpwuid $<)[0]; # Run under current username\n        exec \"./sslh-select -v 3 -f -u $user --listen blahblah.nonexistent:9000 --ssh $ssh_address --tls $ssl_address -P $pidfile\";\n    }\n    warn \"spawned $sslh_pid\\n\";\n    waitpid $sslh_pid, 0;\n    my $code = $? >> 8;\n    warn \"exited with $code\\n\";\n    my_is($code, 4, \"Exit status if can't resolve address\");\n}\n\n# Robustness: verify all command line options work\nif ($RB_CL_PARAMS) {\n    print \"***Test: Command line parameters\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        my $user = (getpwuid $<)[0]; # Run under current username\n        # This doesn't test --inetd\n        exec \"./sslh-select -v 3 -f -u $user -P $pidfile\".\n        \" -n --transparent --timeout 10 -C /tmp\".\n        \" --syslog-facility auth --on-timeout ssh\".\n        \" --listen localhost:$no_listen --ssh $ssh_address --tls $ssl_address\".\n        \" --openvpn localhost:$no_listen\".\n        \" --tinc localhost:$no_listen\".\n        \" --xmpp localhost:$no_listen\".\n        \" --http localhost:$no_listen\".\n        \" --adb localhost:$no_listen\".\n        \" --socks5 localhost:$no_listen\".\n        \" --anyprot localhost:$no_listen\";\n        exit 0;\n    }\n    warn \"spawned $sslh_pid\\n\";\n    # It will die soon because $user cannot chroot (you\n    # don't test as root, do you?)\n\n    waitpid $sslh_pid, 0;\n    my $code = $? >> 8;\n    warn \"exited with $code\\n\";\n    my_is($code, 1, \"Command line arguments\");\n\n\n    print \"***Test: Bad command line parameters\\n\";\n    my $sslh_pid;\n    if (!($sslh_pid = fork)) {\n        my $user = (getpwuid $<)[0]; # Run under current username\n        # This doesn't test --inetd\n        exec \"./sslh-select -v 3 -f -u $user -P $pidfile\".\n        \" -n --transparent --timeout 10 -C /tmp\".\n        \" --fakeoption\".\n        \" --anyprot localhost:$no_listen\";\n        exit 0;\n    }\n    warn \"spawned $sslh_pid\\n\";\n\n    waitpid $sslh_pid, 0;\n    my $code = $? >> 8;\n    warn \"exited with $code\\n\";\n    my_is($code, 6, \"Bad command line parameters\");\n}\n\n`lcov --directory . --capture --output-file sslh_cov.info`;\n`genhtml sslh_cov.info`;\n\n`killall echosrv`;\n\n\nformat test_results_top =\nID  | Description                                                       | Status\n----+-------------------------------------------------------------------+-------\n.\n\nformat test_results = \n@>> | @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |   @>>\n$_->[0], $_->[1], $_->[2] ? \"OK\" : \"NOK\"\n.\n\nformat_name STDOUT \"test_results\";\nformat_top_name STDOUT \"test_results_top\";\nmap { write; } @results;\n"
        },
        {
          "name": "t_load",
          "type": "blob",
          "size": 7.759765625,
          "content": "#! /usr/bin/perl -w\n\n# Test script for sslh -- mass communication\n\n# This creates many clients that perform concurrent\n# connections, disconnect at any time, and try to generally\n# behave as badly as possible.\n\n# It can be used to test sslh behaves properly with many\n# clients, however its main use is to get an idea of how\n# much load it can take on your system before things start\n# to go wrong.\n\nuse strict;\nuse IO::Socket::INET6;\nuse Data::Dumper;\nuse Conf::Libconfig 1.0.3;\n\n## BEGIN TEST CONFIG\n\n# How many total clients to we start? Each client will pick\n# a new protocol among what's in test.cfg.\nmy $NUM_CNX = 16;\n\n# Delay between starting new processes when starting up. If\n# you start 200 processes in under a second, things go wrong\n# and it's not sslh's fault (typically the echosrv won't be\n# forking fast enough).\nmy $start_time_delay = .5;\n\n# Max times we repeat the test string: allows to test for\n# large messages.\nmy $block_rpt = 5;\n\n# Probability to stop a client after a message (e.g. with\n# .01 a client will send an average of 100 messages before\n# disconnecting).\nmy $stop_client_probability = .0001;\n\n##END CONFIG\n\nmy $conf = new Conf::Libconfig;\n$conf->read_file(\"test.cfg\");\n\n\n# Pick one address for TCP and one for UDP\nmy @listen = @{$conf->value(\"listen\")};\nmy ($sslh_tcp_address, $sslh_udp_address);\n\nforeach my $l (@listen) {\n    if ($l->{is_udp}) {\n        $sslh_udp_address //= \"$l->{host}:$l->{port}\";\n    } else {\n        $sslh_tcp_address //= \"$l->{host}:$l->{port}\";\n    }\n    last if defined $sslh_tcp_address and defined $sslh_udp_address;\n}\n\n\n# code snippets to connect to each protocol\nmy %connect_params = (\n    regex => {\n        is_udp => 1,\n        sleep => 0,\n        test_data => \"foo bar\",\n        resp_len => 12,\n    },\n    ssh => {\n        sleep => 20,  # So it times out 50% of connections\n        test_data => \"SSH-2.0 hello\",\n        resp_len => 18,  # length \"ssh: SSH-2.0 hello\" => 18\n    },\n    tinc => {\n        sleep => 0,\n        test_data => \"0 \",\n        resp_len => 8, # length \"tinc: 0 \" => 10\n    },\n    openvpn => {\n        sleep => 0,\n        test_data => \"\\x00\\x00\",\n        resp_len => 11,  # length \"openvpn: \\x0\\x0\" => 11\n    },\n);\n\nsub connect_service {\n    my ($cnx, $service) = @_;\n\n    my $params = $connect_params{$service};\n\n    sleep rand $params->{sleep};\n    my $test_data = $params->{test_data};\n    syswrite $cnx, $test_data;\n    sleep 1;\n    sysread $cnx, my $r, $params->{resp_len}; \n\n    my $expected = \"$service: $test_data\";\n    return ($r eq $expected);\n}\n\n\nsub client {\n    my ($protocol, $client_id, $fd_out) = @_;\n\n    my $service = $protocol->{name};\n\n    while (1) {\n        my $r;\n        #warn \"$client_id: connect $sslh_tcp_address\\n\";\n        my $cnx = new IO::Socket::INET(PeerHost => $sslh_tcp_address);\n        die \"$@\\n\" if (!$cnx);\n\n        my $cnt = 0;\n\n        #warn \"$client_id: connecting $service\\n\";\n\n        if (not connect_service($cnx, $service)) {\n            print $fd_out \"$client_id\\t0\\tC\\n\";\n            warn \"$client_id: connecting failed\\n\";\n            exit;\n        }\n\n        #warn \"$client_id: shoveling $service\\n\";\n\n        while (1) {\n            my $test_data = \"$service $cnt\" x int(rand($block_rpt)+1) . \"\\n\";\n            print $cnx $test_data;\n            $r = <$cnx>;\n            my $expected= \"$test_data\";\n            my $r_l = length $r;\n            my $e_l = length $expected;\n            $fd_out->autoflush;\n            my $error = \"\";\n            $error = \"E\" if $r ne $expected;\n            print $fd_out (\"$client_id\\t$r_l\\t$error\\n\");\n            ($? = 1, die \"$service got [$r] expected [$expected]\\n\") if ($r ne $expected);\n            if (rand(1) < $stop_client_probability) {\n                print $fd_out (\"$client_id\\t$r_l\\tD\\n\");\n                last;\n            }\n            $cnt++;\n        }\n    }\n    exit 0;\n}\n\n# For now, a simple regex client\nsub udp_client {\n    my ($protocol, $client_id, $fd_out) = @_;\n\n    warn \"UDP client starts\\n\";\n\n    while (1) {\n        my $cnx = new IO::Socket::INET(Proto => 'udp', PeerHost => $sslh_udp_address);\n        #        my $cnx; socket $cnx, PF_INET, SOCK_DGRAM, 0 or die \"socket: $!\\n\";\n        die \"$@\\n\" if (!$cnx);\n        my $cnt = 0;\n\n        while (1) {\n            my $test_data = \"foo udp $cnt\"x int(rand($block_rpt)+1). \"\\n\";\n\n            my $ipaddr   = inet_aton(\"localhost\");\n            my $portaddr = sockaddr_in(8086, $ipaddr);\n            my $res = send($cnx, $test_data, 0, $portaddr);\n            if ($res != length($test_data)) {\n                die \"cannot sendto: $!\";\n            }\n\n            my $expected= \"$protocol->{name}: $test_data\";\n\n            my $r;\n            defined(recv($cnx, $r, length $expected, 0)) or die \"recv: $!\\n\";\n\n            my $r_l = length $r;\n            my $e_l = length $expected;\n            $fd_out->autoflush;\n            my $error = \"\";\n            $error = \"M\" if $r ne $expected;\n            print $fd_out (\"$client_id\\t$r_l\\t$error\\n\");\n            ($? = 1, die \"udp got [$r] expected [$expected]\\n\") if ($r ne $expected);\n            if (rand(1) < $stop_client_probability) {\n                print $fd_out (\"$client_id\\t$r_l\\tD\\n\");\n                last;\n            }\n            $cnt++;\n        }\n    }\n}\n\nforeach my $p (@{$conf->value(\"protocols\")}) {\n    if (!fork) {\n        my $udp = $p->{is_udp} ? \"--udp\" : \"\";\n        my $cmd = \"./echosrv $udp -p $p->{host}:$p->{port} --prefix '$p->{name}: ' 2> /dev/null\";\n        warn \"$cmd\\n\";\n        exec $cmd;\n        exit;\n    }\n}\n\nwarn \"Don't forget to run sslh -F test.cfg!\\n\";\n\nsleep 2; # Let echosrv's and sslh start\n\nmy ($c_in, $c_out);\npipe $c_in, $c_out;\n\nmy @protocols = @{$conf->value(\"protocols\")};\n\nif (!fork) {\n    # Process that starts all the clients\n    for my $client_num (1 .. $NUM_CNX) {\n            if (!fork) {\n                my @supported_protocols = keys %connect_params;\n                my $p_name = $supported_protocols[rand @supported_protocols];\n                my @p = grep { $_->{name} eq $p_name } @protocols;\n                my $p = shift @p;\n                if ($p->{is_udp}) {\n                    udp_client($p, \"$p->{name}$client_num\", $c_out);\n                } else {\n                    client($p, \"$p->{name}$client_num\", $c_out);\n                }\n                exit;\n            }\n            # Give a little time so we don't overrun the\n            # listen(2) backlog.\n            select undef, undef, undef, $start_time_delay;\n    }\n    exit;\n} else {\n    my %data;\n\n    # The condition here selects between pretty output or\n    # raw output\n    if (1) {\n        my $CLEAR_LINE = \"\\033[2K\";\n        my $CURSOR_HOME = \"\\033[1;1H\";\n        my $CLEAR_SCREEN = \"\\033[2J\";\n\n        # Process that retrieves client output to pretty print\n        print $CLEAR_SCREEN; # Clear screen\n        while (<$c_in>) {\n            chop;\n            my ($client_id, $r_l, $error, @rest) = split /\\t/, $_;\n\n            $data{$client_id} = [ 0, \"\"] if not exists $data{$client_id};\n            my ($curr_rcv) = ${$data{$client_id}}[0] + $r_l;;\n            $error //= \"\";\n            my ($curr_error) = \"${$data{$client_id}}[1]$error\";\n            # Consolidate into... roman numerals!\n            $curr_error =~ s/D{10}/X/;\n            $curr_error =~ s/X{10}/C/;\n            $curr_error =~ s/C{10}/M/;\n\n            $data{$client_id} = [ $r_l + $curr_rcv, \"$curr_error$error\" ];\n\n\n            $client_id =~ /(\\d+)/;\n            my $i = $1;\n            #            print $CURSOR_HOME;\n            print \"\\033[$i;1H$CLEAR_LINE$client_id\\t$curr_rcv\\t$curr_error\\n\";\n            #foreach my $i (sort keys %data) {\n            #    ($r_l, $error) = @{$data{$i}};\n            #    print \"$CLEAR_LINE$i\\t$r_l\\t$error\\n\"; \n        }\n    } else {\n        # Just print the client outputs\n        while (<$c_in>) {\n            print;\n        }\n    }\n}\n\nwarn \"waiting\\n\";\nwait;\nwarn \"finished waiting\\n\";\n\n\n`killall echosrv`;\n\n"
        },
        {
          "name": "tcp-listener.c",
          "type": "blob",
          "size": 9.3701171875,
          "content": "/*\n   tcp-listener.c: handles demultiplexing TCP protocols\n\n# Copyright (C) 2022  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#include <errno.h>\n#include \"tcp-listener.h\"\n#include \"probe.h\"\n#include \"log.h\"\n\n/* Removes cnx from probing list */\nstatic void remove_probing_cnx(struct loop_info* fd_info, struct connection* cnx)\n{\n    gap_remove_ptr(fd_info->probing_list, cnx, fd_info->num_probing);\n    fd_info->num_probing--;\n}\n\nstatic void add_probing_cnx(struct loop_info* fd_info, struct connection* cnx)\n{\n    gap_set(fd_info->probing_list, fd_info->num_probing, cnx);\n    fd_info->num_probing++;\n}\n\n/* shovels data from active fd to the other\n   returns after one socket closed or operation would block\n */\nstatic void shovel(struct connection *cnx, int active_fd, struct loop_info* fd_info)\n{\n    struct queue *read_q, *write_q;\n\n    read_q = &cnx->q[active_fd];\n    write_q = &cnx->q[1-active_fd];\n\n    print_message(msg_fd, \"activity on fd%d\\n\", read_q->fd);\n\n    switch(fd2fd(write_q, read_q)) {\n    case -1:\n    case FD_CNXCLOSED:\n        tidy_connection(cnx, fd_info);\n        break;\n\n    case FD_STALLED:\n        watchers_add_write(fd_info->watchers, write_q->fd);\n        watchers_del_read(fd_info->watchers, read_q->fd);\n        break;\n\n    default: /* Nothing */\n        break;\n    }\n}\n\n\n/* Returns the queue index that contains the specified file descriptor.\n * This is called by the *_process functions, which got cnx from the fd, so it\n * is impossible for fd to not be cnx, hence we die if it happens */\nstatic int active_queue(struct connection* cnx, int fd)\n{\n    if (cnx->q[0].fd == fd) return 0;\n    if (cnx->q[1].fd == fd) return 1;\n\n    print_message(msg_int_error, \"file descriptor %d not found in connection object\\n\", fd);\n    exit(1);\n}\n\n/* Process a TCP read event on the specified file descriptor */\nvoid tcp_read_process(struct loop_info* fd_info,\n                             int fd)\n{\n    cnx_collection* collection = fd_info->collection;\n    struct connection* cnx = collection_get_cnx_from_fd(collection, fd);\n\n    /* connection can get tidied if there is an error on the other file\n     * descriptor -- then cnx is NULL */\n    if (!cnx) return;\n\n    /* Determine active queue (0 or 1): if fd is that of q[1], active_q = 1,\n     * otherwise it's 0 */\n    int active_q = active_queue(cnx, fd);\n\n    switch (cnx->state) {\n\n    case ST_PROBING:\n        if (active_q == 1) {\n            print_message(msg_int_error, \"Activity on fd2 while probing, impossible\\n\");\n            dump_connection(cnx);\n            exit(1);\n        }\n\n        probing_read_process(cnx, fd_info);\n\n        break;\n\n    case ST_SHOVELING:\n        shovel(cnx, active_q, fd_info);\n        break;\n\n    default: /* illegal */\n        print_message(msg_int_error, \"Illegal connection state %d\\n\", cnx->state);\n        dump_connection(cnx);\n        exit(1);\n    }\n}\n\n/* Accepts a connection from the main socket and assigns it to an empty slot.\n * If no slots are available, allocate another few. If that fails, drop the\n * connexion */\nstruct connection* accept_new_connection(int listen_socket, struct loop_info* fd_info)\n{\n    int in_socket, res;\n\n    print_message(msg_fd, \"accepting from %d\\n\", listen_socket);\n\n    in_socket = accept(listen_socket, 0, 0);\n    CHECK_RES_RETURN(in_socket, \"accept\", NULL);\n\n    res = set_nonblock(in_socket);\n    if (res == -1) {\n        close(in_socket);\n        return NULL;\n    }\n\n    struct connection* cnx = collection_alloc_cnx_from_fd(fd_info->collection, in_socket);\n    if (!cnx) {\n        close(in_socket);\n        return NULL;\n    }\n\n    add_probing_cnx(fd_info, cnx);\n    return cnx;\n}\n\n\n/* Connect queue 1 of connection to SSL; returns new file descriptor */\nstatic int connect_queue(struct connection* cnx,\n                         struct loop_info* fd_info)\n{\n    struct queue *q = &cnx->q[1];\n\n    q->fd = connect_addr(cnx, cnx->q[0].fd, NON_BLOCKING);\n    if (q->fd != -1) {\n        log_connection(NULL, cnx);\n        flush_deferred(q);\n        if (q->deferred_data) {\n            watchers_add_write(fd_info->watchers, q->fd);\n            watchers_del_read(fd_info->watchers, cnx->q[0].fd);\n        }\n        watchers_add_read(fd_info->watchers, q->fd);\n        collection_add_fd(fd_info->collection, cnx, q->fd);\n        return q->fd;\n    } else {\n        tidy_connection(cnx, fd_info);\n        return -1;\n    }\n}\n\n/* shovels data from one fd to the other and vice-versa\n   returns after one socket closed\n */\nstatic void shovel_single(struct connection *cnx)\n{\n   fd_set fds_r, fds_w;\n   int res, i;\n   int max_fd = MAX(cnx->q[0].fd, cnx->q[1].fd) + 1;\n\n   FD_ZERO(&fds_r);\n   FD_ZERO(&fds_w);\n   while (1) {\n      for (i = 0; i < 2; i++) {\n         if (cnx->q[i].deferred_data_size) {\n            FD_SET(cnx->q[i].fd, &fds_w);\n            FD_CLR(cnx->q[1-i].fd, &fds_r);\n         } else {\n            FD_CLR(cnx->q[i].fd, &fds_w);\n            FD_SET(cnx->q[1-i].fd, &fds_r);\n         }\n      }\n\n      res = select(\n                   max_fd,\n                   &fds_r,\n                   &fds_w,\n                   NULL,\n                   NULL\n                  );\n      CHECK_RES_DIE(res, \"select\");\n\n      for (i = 0; i < 2; i++) {\n          if (FD_ISSET(cnx->q[i].fd, &fds_w)) {\n              res = flush_deferred(&cnx->q[i]);\n              if ((res == -1) && ((errno == EPIPE) || (errno == ECONNRESET))) {\n                  print_message(msg_fd, \"%s socket closed\\n\", i ? \"server\" : \"client\");\n                  return;\n              }\n          }\n          if (FD_ISSET(cnx->q[i].fd, &fds_r)) {\n              res = fd2fd(&cnx->q[1-i], &cnx->q[i]);\n              if (!res) {\n                  print_message(msg_fd, \"socket closed\\n\");\n                  return;\n              }\n          }\n      }\n   }\n}\n\n\n\n/* Child process that makes internal connection and proxies\n */\nstatic void connect_proxy(struct connection *cnx)\n{\n    int in_socket;\n    int out_socket;\n\n    /* Minimize the file descriptor value to help select() */\n    in_socket = dup(cnx->q[0].fd);\n    if (in_socket == -1) {\n        in_socket = cnx->q[0].fd;\n    } else {\n        close(cnx->q[0].fd);\n        cnx->q[0].fd = in_socket;\n    }\n\n    /* Connect the target socket */\n    out_socket = connect_addr(cnx, in_socket, BLOCKING);\n    CHECK_RES_DIE(out_socket, \"connect\");\n\n    cnx->q[1].fd = out_socket;\n\n    log_connection(NULL, cnx);\n\n    shovel_single(cnx);\n\n    close(in_socket);\n    close(out_socket);\n\n    print_message(msg_fd, \"connection closed down\\n\");\n\n    exit(0);\n}\n\n/* Process read activity on a socket in probe state \n * IN/OUT cnx: connection data, updated if connected\n * IN/OUT info: updated if connected\n * */\nvoid probing_read_process(struct connection* cnx,\n                                 struct loop_info* fd_info)\n{\n    int res;\n\n    /* If timed out it's SSH, otherwise the client sent\n     * data so probe the protocol */\n    if ((cnx->probe_timeout < time(NULL))) {\n        cnx->proto = timeout_protocol();\n        print_message(msg_fd, \"timed out, connect to %s\\n\", cnx->proto->name);\n    } else {\n        res = probe_client_protocol(cnx);\n        if (res == PROBE_AGAIN)\n            return;\n    }\n\n    remove_probing_cnx(fd_info, cnx);\n    cnx->state = ST_SHOVELING;\n\n    /* libwrap check if required for this protocol */\n    if (cnx->proto->service &&\n        check_access_rights(cnx->q[0].fd, cnx->proto->service)) {\n        tidy_connection(cnx, fd_info);\n        res = -1;\n    } else if (cnx->proto->fork) {\n        switch (fork()) {\n        case 0:  /* child */\n            /* TODO: close all file descriptors except 2 */\n            /* free(cnx); */\n            connect_proxy(cnx);\n            exit(0);\n        case -1: print_message(msg_system_error, \"fork failed: err %d: %s\\n\", errno, strerror(errno));\n                 break;\n        default: /* parent */\n                 break;\n        }\n        tidy_connection(cnx, fd_info);\n        res = -1;\n    } else {\n        res = connect_queue(cnx, fd_info);\n    }\n}\n\n\n/* Process a connection that is active in write (this is TCP only, as\n * UDP sockets are never \"full\" or deferred or whatever) */\nvoid cnx_write_process(struct loop_info* fd_info, int fd)\n{\n    struct connection* cnx = collection_get_cnx_from_fd(fd_info->collection, fd);\n\n    /* connection can get tidied if there is an error on the other file\n     * descriptor -- then cnx is NULL */\n    if (!cnx) return;\n\n    int res;\n    int queue = active_queue(cnx, fd);\n\n    res = flush_deferred(&cnx->q[queue]);\n    if ((res == -1) && ((errno == EPIPE) || (errno == ECONNRESET))) {\n        if (cnx->state == ST_PROBING) remove_probing_cnx(fd_info, cnx);\n        tidy_connection(cnx, fd_info);\n    } else {\n        /* If no deferred data is left, stop monitoring the fd \n         * for write, and restart monitoring the other one for reads*/\n        if (!cnx->q[queue].deferred_data_size) {\n            watchers_del_write(fd_info->watchers, cnx->q[queue].fd);\n            watchers_add_read(fd_info->watchers, cnx->q[1-queue].fd);\n        }\n    }\n}\n\n"
        },
        {
          "name": "tcp-listener.h",
          "type": "blob",
          "size": 0.3994140625,
          "content": "#ifndef TCP_LISTENER_H\n#define TCP_LISTENER_H\n\n#include \"processes.h\"\n#include \"collection.h\"\n#include \"tcp-probe.h\"\n\nvoid tcp_read_process(struct loop_info* fd_info, int fd);\nstruct connection* accept_new_connection(int listen_socket, struct loop_info* fd_info);\nvoid probing_read_process(struct connection* cnx, struct loop_info* fd_info);\nvoid cnx_write_process(struct loop_info* fd_info, int fd);\n\n#endif\n"
        },
        {
          "name": "tcp-probe.c",
          "type": "blob",
          "size": 3.005859375,
          "content": "/*\n# tcp-probe.c: TCP code that is common to the sslh-fork and sslh-[ev|select] \n#\n# Copyright (C) 2022  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n*/\n\n\n#include \"probe.h\"\n\nstatic struct sslhcfg_protocols_item** tcp_protocols;\nstatic int tcp_protocols_len = 0;\n\n/*\n * Read the beginning of data coming from the client connection and check if\n * it's a known protocol.\n * Return PROBE_AGAIN if not enough data, or PROBE_MATCH if it succeeded in\n * which case cnx->proto is set to the appropriate protocol.\n */\nint probe_client_protocol(struct connection *cnx)\n{\n    char buffer[BUFSIZ];\n    ssize_t n;\n\n    n = read(cnx->q[0].fd, buffer, sizeof(buffer));\n    /* It's possible that read() returns an error, e.g. if the client\n     * disconnected between the previous call to select() and now. If that\n     * happens, we just connect to the default protocol so the caller of this\n     * function does not have to deal with a specific  failure condition (the\n     * connection will just fail later normally). */\n\n    if (n > 0) {\n        defer_write(&cnx->q[1], buffer, n);\n        return probe_buffer(cnx->q[1].begin_deferred_data,\n                            cnx->q[1].deferred_data_size,\n                            tcp_protocols, tcp_protocols_len,\n                            &cnx->proto\n                            );\n    }\n\n    /* read() returned an error, so just connect to the last protocol to die */\n    cnx->proto = &cfg.protocols[cfg.protocols_len-1];\n    return PROBE_MATCH;\n}\n\n\nstatic void tcp_protocol_list_init(void)\n{\n    tcp_protocols = calloc(cfg.protocols_len, sizeof(tcp_protocols));\n    CHECK_ALLOC(tcp_protocols, \"tcp_protocols\");\n    for (int i = 0; i < cfg.protocols_len; i++) {\n        struct sslhcfg_protocols_item* p = &cfg.protocols[i];\n        if (!p->is_udp) {\n            tcp_protocols[tcp_protocols_len] = p;\n            tcp_protocols_len++;\n        }\n    }\n}\n\n/* Configuration sanity check for TCP:\n * - If there is a listening socket, there must be at least one target\n */\nstatic void tcp_sanity_check(void)\n{\n    int tcp_present = 0;\n\n    for (int i = 0; i < cfg.listen_len; i++) {\n        struct sslhcfg_listen_item* p = &cfg.listen[i];\n        if (!p->is_udp) {\n            tcp_present = 1;\n            break;\n        }\n    }\n\n    if (tcp_present && !tcp_protocols_len) {\n        print_message(msg_config_error, \"At least one TCP target protocol must be specified.\\n\");\n        exit(2);\n    }\n}\n\nvoid tcp_init(void)\n{\n    tcp_protocol_list_init();\n    tcp_sanity_check();\n}\n"
        },
        {
          "name": "tcp-probe.h",
          "type": "blob",
          "size": 0.068359375,
          "content": "#ifndef TCP_PROBE_H\n#define TCP_PROBE_H\n\nvoid tcp_init(void);\n\n#endif\n"
        },
        {
          "name": "test.cfg",
          "type": "blob",
          "size": 3.33984375,
          "content": "# Configuration file for testing (use both by sslh under\n# test and the test script `t`)\n\nforeground: true;\ninetd: false;\nnumeric: true;\ntransparent: false;\ntimeout: 10;   # Probe test writes slowly\npidfile: \"/tmp/sslh_test.pid\";\n\nsyslog_facility: \"auth\"; \n\n# Logging configuration\n# Value: 1: stdout; 2: syslog; 3: both\n# Defaults should be sensible. Generally, you want *-error\n# to be always enabled, to know if something is going wrong.\nverbose-config: 1; #  print configuration at startup\nverbose-config-error: 1;  # print configuration errors\nverbose-connections: 1; # trace established incoming address to forward address\nverbose-connections-error: 1; # connection errors\nverbose-connections-try: 1; # connection attempts towards targets\nverbose-fd: 0; # file descriptor activity, open/close/whatnot\nverbose-packets: 1; # hexdump packets on which probing is done\nverbose-probe-info: 0; # what's happening during the probe process\nverbose-probe-error: 1; # failures and problems during probing\nverbose-system-error: 1; # system call problem, i.e.  malloc, fork, failing\nverbose-int-error: 1; # internal errors, the kind that should never happen\n\n# List of interfaces on which we should listen\n# Options:\nlisten:\n(\n    { host: \"localhost\"; port: \"8080\"; keepalive: true; },\n    { host: \"localhost\"; port: \"8081\"; keepalive: true; },\n    { host: \"ip4-localhost\"; is_udp: true; port: \"8086\"; },\n    { host: \"/tmp/sslh.sock\"; is_unix: true; port: \"\"; }\n);\n\n\n# Tester beware: when using fork, the forked process loses\n# track of buffers of other, concurrent connections. Memory\n# leak tools thus complain each time a forked process stops.\n \nprotocols:\n(\n     { name: \"ssh\";  host: \"localhost\"; port: \"9000\"; fork: true; transparent: true; resolve_on_forward: true; },\n     { name: \"socks5\";  host: \"localhost\"; port: \"9001\";  },\n     { name: \"http\";  is_unix: true; host: \"/tmp/nginx.sock\"; port: \"\";  },\n     { name: \"tinc\";  host: \"localhost\"; port: \"9003\"; },\n     { name: \"openvpn\";  host: \"localhost\"; port: \"9004\"; },\n     { name: \"xmpp\";  host: \"localhost\"; port: \"9009\"; },\n     { name: \"adb\";  host: \"localhost\"; port: \"9010\"; },\n     { name: \"syslog\"; host: \"localhost\"; port: \"9013\"; },\n     { name: \"regex\"; host: \"ip4-localhost\"; is_udp: true; port: \"9020\";\n         udp_timeout: 30;\n         regex_patterns: [ \"^foo\" ];\n         resolve_on_forward: true;\n     },\n     { name: \"regex\"; host: \"localhost\"; port: \"9011\";\n        regex_patterns: [ \"^foo\", \"^bar\" ];\n        minlength: 4; \n        test_patterns: (    # this is used by the test script, not by sslh\n            { pattern: \"foo\"; result: \"ssh\"; },  # After timeout\n            { pattern: \"fooo\"; result: \"regex\"; },\n            { pattern: \"bar\"; result: \"ssh\"; },\n            { pattern: \"barr\"; result: \"regex\"; },\n            { pattern: \"barrrr\"; result: \"regex\"; }\n        );\n     },\n     { name: \"tls\"; host: \"localhost\"; port: \"9021\"; alpn_protocols: [ \"alpn1\", \"alpn2\" ]; sni_hostnames: [ \"sni1\" ]; },\n     { name: \"tls\"; host: \"localhost\"; port: \"9022\"; alpn_protocols: [ \"alpn1\", \"alpn2\" ]; sni_hostnames: [ \"sni2\", \"sni3\" ]; },\n     { name: \"tls\"; host: \"localhost\"; port: \"9023\"; alpn_protocols: [ \"alpn3\" ]; },\n     { name: \"tls\"; host: \"localhost\"; port: \"9024\"; sni_hostnames: [ \"sni3\" ]; },\n     { name: \"tls\"; host: \"localhost\"; port: \"9025\"; },\n     { name: \"anyprot\";  host: \"localhost\"; port: \"9099\";  }\n);\n\non_timeout: \"ssh\";\n\n"
        },
        {
          "name": "tls.c",
          "type": "blob",
          "size": 9.81640625,
          "content": "/*\n * Copyright (c) 2011 and 2012, Dustin Lundquist <dustin@null-ptr.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * This is a minimal TLS implementation intended only to parse the server name\n * extension.  This was created based primarily on Wireshark dissection of a\n * TLS handshake and RFC4366.\n */\n#include <stdio.h>\n#include <stdlib.h> /* malloc() */\n#include <fnmatch.h> /* fnmatch() */\n#include \"tls.h\"\n#include \"sslh-conf.h\"\n#include \"log.h\"\n\n#define TLS_HEADER_LEN 5\n#define TLS_HANDSHAKE_CONTENT_TYPE 0x16\n#define TLS_HANDSHAKE_TYPE_CLIENT_HELLO 0x01\n\n#ifndef MIN\n#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n#endif\n\ntypedef struct {\n    int tls_match_sni : 1;\n    int tls_match_alpn : 1;\n} TLS_MATCHMODE;\n\nstruct TLSProtocol {\n    TLS_MATCHMODE match_mode;\n    int sni_list_len;\n    const char** sni_hostname_list;\n    int alpn_list_len;\n    const char** alpn_protocol_list;\n};\n\nstatic int parse_extensions(const struct TLSProtocol *, const char *, size_t);\nstatic int parse_server_name_extension(const struct TLSProtocol *, const char *, size_t);\nstatic int parse_alpn_extension(const struct TLSProtocol *, const char *, size_t);\nstatic int has_match(const char**, size_t, const char*, size_t);\n\n/* Parse a TLS packet for the Server Name Indication and ALPN extension in the client\n * hello handshake, returning a status code\n *\n * Returns:\n * 0: no match\n * 1: match\n *  < 0:  error code (see tls.h)\n */\nint\nparse_tls_header(const struct TLSProtocol *tls_data, const char *data, size_t data_len) {\n    char tls_content_type;\n    char tls_version_major;\n    char tls_version_minor;\n    size_t pos = TLS_HEADER_LEN;\n    size_t len;\n\n    /* Check that our TCP payload is at least large enough for a TLS header */\n    if (data_len < TLS_HEADER_LEN)\n        return TLS_ELENGTH;\n\n    tls_content_type = data[0];\n    if (tls_content_type != TLS_HANDSHAKE_CONTENT_TYPE) {\n        print_message(msg_probe_info, \"Request did not begin with TLS handshake.\\n\");\n        return TLS_EPROTOCOL;\n    }\n\n    tls_version_major = data[1];\n    tls_version_minor = data[2];\n    if (tls_version_major < 3) {\n        print_message(msg_probe_error, \"Received SSL %d.%d handshake which cannot be parsed.\\n\",\n              tls_version_major, tls_version_minor);\n\n        return TLS_EVERSION;\n    }\n\n    /* TLS record length */\n    len = ((unsigned char)data[3] << 8) +\n          (unsigned char)data[4] + TLS_HEADER_LEN;\n    data_len = MIN(data_len, len);\n\n    /* Check we received entire TLS record length */\n    if (data_len < len)\n        return TLS_ELENGTH;\n\n    /*\n     * Handshake\n     */\n    if (pos + 1 > data_len) {\n        return TLS_EPROTOCOL;\n    }\n    if (data[pos] != TLS_HANDSHAKE_TYPE_CLIENT_HELLO) {\n        print_message(msg_probe_error, \"Not a client hello\\n\");\n\n        return TLS_EPROTOCOL;\n    }\n\n    /* Skip past fixed length records:\n       1\tHandshake Type\n       3\tLength\n       2\tVersion (again)\n       32\tRandom\n       to\tSession ID Length\n     */\n    pos += 38;\n\n    /* Session ID */\n    if (pos + 1 > data_len)\n        return TLS_EPROTOCOL;\n    len = (unsigned char)data[pos];\n    pos += 1 + len;\n\n    /* Cipher Suites */\n    if (pos + 2 > data_len)\n        return TLS_EPROTOCOL;\n    len = ((unsigned char)data[pos] << 8) + (unsigned char)data[pos + 1];\n    pos += 2 + len;\n\n    /* Compression Methods */\n    if (pos + 1 > data_len)\n        return TLS_EPROTOCOL;\n    len = (unsigned char)data[pos];\n    pos += 1 + len;\n\n    if (pos == data_len && tls_version_major == 3 && tls_version_minor == 0) {\n        print_message(msg_probe_error, \"Received SSL 3.0 handshake without extensions\\n\");\n        return TLS_EVERSION;\n    }\n\n    /* Extensions */\n    if (pos + 2 > data_len)\n        return TLS_EPROTOCOL;\n    len = ((unsigned char)data[pos] << 8) + (unsigned char)data[pos + 1];\n    pos += 2;\n\n    if (pos + len > data_len)\n        return TLS_EPROTOCOL;\n\n    /* By now we know it's TLS. if SNI or ALPN is set, parse extensions to see if\n     * they match. Otherwise, it's a match already */\n    if (tls_data && \n        (tls_data->match_mode.tls_match_alpn || tls_data->match_mode.tls_match_sni)) {\n        return parse_extensions(tls_data, data + pos, len);\n    } else {\n        return TLS_MATCH;\n    }\n}\n\nstatic int\nparse_extensions(const struct TLSProtocol *tls_data, const char *data, size_t data_len) {\n    size_t pos = 0;\n    size_t len;\n    int sni_match = 0, alpn_match = 0;\n\n    if (tls_data == NULL)\n        return TLS_EINVAL;\n\n    /* Parse each 4 bytes for the extension header */\n    while (pos + 4 <= data_len) {\n        /* Extension Length */\n        len = ((unsigned char) data[pos + 2] << 8) +\n              (unsigned char) data[pos + 3];\n\n        if (pos + 4 + len > data_len)\n            return TLS_EPROTOCOL;\n\n        size_t extension_type = ((unsigned char) data[pos] << 8) +\n                                (unsigned char) data[pos + 1];\n\n        if (extension_type == 0x00 && tls_data->match_mode.tls_match_sni) { /* Server Name */\n            sni_match = parse_server_name_extension(tls_data, data + pos + 4, len);\n            if (sni_match < 0) return sni_match;\n        } else if (extension_type == 0x10 && tls_data->match_mode.tls_match_alpn) { /* ALPN */\n            alpn_match = parse_alpn_extension(tls_data, data + pos + 4, len);\n            if (alpn_match < 0) return alpn_match;\n        }\n\n        pos += 4 + len; /* Advance to the next extension header */\n    }\n\n    /* Check we ended where we expected to */\n    if (pos != data_len)\n        return TLS_EPROTOCOL;\n\n    return (sni_match && alpn_match) \n        || (!tls_data->match_mode.tls_match_sni && alpn_match)\n        || (!tls_data->match_mode.tls_match_alpn && sni_match);\n}\n\nstatic int\nparse_server_name_extension(const struct TLSProtocol *tls_data, const char *data, size_t data_len) {\n    size_t pos = 2; /* skip server name list length */\n    size_t len;\n\n    while (pos + 3 < data_len) {\n        len = ((unsigned char)data[pos + 1] << 8) +\n              (unsigned char)data[pos + 2];\n\n        if (pos + 3 + len > data_len)\n            return TLS_EPROTOCOL;\n\n        switch (data[pos]) { /* name type */\n            case 0x00: /* host_name */\n                if(has_match(tls_data->sni_hostname_list, tls_data->sni_list_len, data + pos + 3, len)) {\n                    return (int)len;\n                } else {\n                    return TLS_ENOEXT;\n                }\n            default:\n                print_message(msg_probe_error, \"Unknown server name extension name type: %d\\n\",\n                      data[pos]);\n        }\n        pos += 3 + len;\n    }\n    /* Check we ended where we expected to */\n    if (pos != data_len)\n        return TLS_EPROTOCOL;\n\n    return TLS_ENOEXT;\n}\n\nstatic int\nparse_alpn_extension(const struct TLSProtocol *tls_data, const char *data, size_t data_len) {\n    size_t pos = 2;\n    size_t len;\n\n    while (pos + 1 < data_len) {\n        len = (unsigned char)data[pos];\n\n        if (pos + 1 + len > data_len)\n            return TLS_EPROTOCOL;\n\n        if (len > 0 && has_match(tls_data->alpn_protocol_list, tls_data->alpn_list_len, data + pos + 1, len)) {\n            return (int)len;\n        } else if (len > 0) {\n            print_message(msg_probe_error, \"Unknown ALPN name: %.*s\\n\", (int)len, data + pos + 1);\n        }\n        pos += 1 + len;\n    }\n    /* Check we ended where we expected to */\n    if (pos != data_len)\n        return TLS_EPROTOCOL;\n\n    return TLS_ENOEXT;\n}\n\nstatic int\nhas_match(const char** list, size_t list_len, const char* name, size_t name_len) {\n    const char **item;\n    int i;\n    char *name_nullterminated = malloc(name_len+1);\n    CHECK_ALLOC(name_nullterminated, \"malloc\");\n    memcpy(name_nullterminated, name, name_len);\n    name_nullterminated[name_len]='\\0';\n\n    for (i = 0; i < list_len; i++) {\n        item = &list[i];\n        print_message(msg_probe_error, \"matching [%.*s] with [%s]\\n\", (int)name_len, name, *item);\n        if(!fnmatch(*item, name_nullterminated, 0)) {\n            free(name_nullterminated);\n            return 1;\n        }\n    }\n    free(name_nullterminated);\n    return 0;\n}\n\nstruct TLSProtocol *\nnew_tls_data() {\n    struct TLSProtocol *tls_data = malloc(sizeof(struct TLSProtocol));\n    CHECK_ALLOC(tls_data, \"malloc\");\n\n    memset(tls_data, 0, sizeof(*tls_data));\n\n    return tls_data;\n}\n\nstruct TLSProtocol *\ntls_data_set_list(struct TLSProtocol *tls_data, int alpn, const char** list, size_t list_len) {\n    if (alpn) {\n        tls_data->alpn_protocol_list = list;\n        tls_data->alpn_list_len = (int)list_len;\n        tls_data->match_mode.tls_match_alpn = 1;\n    } else {\n        tls_data->sni_hostname_list = list;\n        tls_data->sni_list_len = (int)list_len;\n        tls_data->match_mode.tls_match_sni = 1;\n    }\n\n    return tls_data;\n}\n"
        },
        {
          "name": "tls.h",
          "type": "blob",
          "size": 2.0126953125,
          "content": "/*\n * Copyright (c) 2011 and 2012, Dustin Lundquist <dustin@null-ptr.net>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n#ifndef TLS_H\n#define TLS_H\n\n#include \"common.h\"\n\nstruct TLSProtocol;\n\nint parse_tls_header(const struct TLSProtocol *tls_data, const char *data, size_t data_len);\n\nstruct TLSProtocol *new_tls_data();\nstruct TLSProtocol *tls_data_set_list(struct TLSProtocol *, int, const char**, size_t);\n\n#define TLS_MATCH       1\n#define TLS_NOMATCH     0\n\n#define TLS_EINVAL      -1 /* Invalid parameter (NULL data pointer) */\n#define TLS_ELENGTH     -2 /* Incomplete request */\n#define TLS_EVERSION    -3 /* TLS version that cannot be parsed */\n#define TLS_ENOEXT      -4 /* No ALPN or SNI extension found */\n#define TLS_EPROTOCOL   -5 /* Protocol error */\n\n\n#endif\n"
        },
        {
          "name": "udp-listener.c",
          "type": "blob",
          "size": 9.951171875,
          "content": "/*\n   udp-listener.c: handles demultiplexing UDP protocols\n\n# Copyright (C) 2020-2022  Yves Rutschle\n# \n# This program is free software; you can redistribute it\n# and/or modify it under the terms of the GNU General Public\n# License as published by the Free Software Foundation; either\n# version 2 of the License, or (at your option) any later\n# version.\n# \n# This program is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied\n# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n# PURPOSE.  See the GNU General Public License for more\n# details.\n# \n# The full text for the General Public License is here:\n# http://www.gnu.org/licenses/gpl.html\n\n*/\n\n#include <limits.h>\n\n#include \"common.h\"\n#include \"probe.h\"\n#include \"sslh-conf.h\"\n#include \"udp-listener.h\"\n\n/* Incoming connections are of course all received on a single socket. Create a\n * hash that associates (incoming sockaddr) => struct connection*, so finding\n * the connection related to an incoming packet is fast.\n */\n\n\n\nstatic int cnx_cmp(struct connection* cnx1, struct connection* cnx2)\n{\n    struct sockaddr_storage* addr1 = &cnx1->client_addr;\n    socklen_t addrlen1 = cnx1->addrlen;\n\n    struct sockaddr_storage* addr2 = &cnx2->client_addr;\n    socklen_t addrlen2 = cnx2->addrlen;\n\n    if (addrlen1 != addrlen2) return -1;\n\n    return memcmp(addr1, addr2, addrlen1);\n}\n\n/* From an IP address, create something that's useable as a hash key.\n * Currently:\n * lowest bytes of remote port */\nstatic int hash_make_key(hash_item new)\n{\n    struct sockaddr_storage* addr = &new->client_addr;\n    //socklen_t addrlen = new->addrlen;\n    struct sockaddr_in* addr4;\n    struct sockaddr_in6* addr6;\n    int out;\n\n    switch (((struct sockaddr*)addr)->sa_family) {\n    case AF_INET:\n        addr4 = (struct sockaddr_in*)addr;\n        out = addr4->sin_port;\n        break;\n\n    case AF_INET6:\n        addr6 = (struct sockaddr_in6*)addr;\n        out = addr6->sin6_port;\n        break;\n\n    default: /* Just use the first bytes, skipping the address family */\n        out = ((char*)addr)[2];\n        break;\n    }\n    return out;\n}\n\nstatic struct sslhcfg_protocols_item** udp_protocols;\nstatic int udp_protocols_len = 0;\n\nstatic void udp_protocol_list_init(void)\n{\n    for (int i = 0; i < cfg.protocols_len; i++) {\n        struct sslhcfg_protocols_item* p = &cfg.protocols[i];\n        if (p->is_udp) {\n            udp_protocols_len++;\n            udp_protocols = realloc(udp_protocols, udp_protocols_len * sizeof(*udp_protocols));\n            CHECK_ALLOC(udp_protocols, \"realloc\");\n            udp_protocols[udp_protocols_len-1] = p;\n        }\n    }\n}\n\n/* Configuration sanity check for UDP:\n * - If there is a listening address, there must be at least one target\n */\nstatic void udp_sanity_check(void)\n{\n    int udp_present = 0;\n\n    for (int i = 0; i < cfg.listen_len; i++) {\n        struct sslhcfg_listen_item* p = &cfg.listen[i];\n        if (p->is_udp) {\n            udp_present = 1;\n            break;\n        }\n    }\n\n    if (udp_present && !udp_protocols_len) {\n        print_message(msg_config_error, \"At least one UDP target protocol must be specified.\\n\");\n        exit(2);\n    }\n}\n\n/* Init the UDP subsystem.\n * - Initialise the hash\n * - that's all, folks\n * */\nvoid udp_init(struct loop_info* fd_info)\n{\n    fd_info->hash_sources = hash_init(cfg.udp_max_connections, &hash_make_key, &cnx_cmp);\n\n    udp_protocol_list_init();\n    udp_sanity_check();\n}\n\n\n/* Find if the specified source has been seen before.\n * If yes, returns file descriptor of connection\n * If not, returns -1\n * */\nstatic int known_source(hash* h, struct sockaddr_storage* addr, socklen_t addrlen)\n{\n    struct connection search;\n    search.client_addr = *addr;\n    search.addrlen = addrlen;\n\n    struct connection* cnx = hash_find(h, &search);\n    if (!cnx) return -1;\n    return cnx->q[0].fd;\n}\n\n\n\nstatic int new_source(hash* h, struct connection* new)\n{\n    return hash_insert(h, new);\n}\n\n\n/* Double linked list utilities: push element at tail of list */\nstatic void list_push(dl_list* list, struct connection* cnx)\n{\n    cnx->timeout_next = NULL;\n\n    if (!list->head) {\n        cnx->timeout_prev = NULL;\n        list->head = cnx;\n    }\n\n    if (list->tail) {\n        list->tail->timeout_next = cnx;\n        cnx->timeout_prev = list->tail;\n    }\n\n    list->tail = cnx;\n}\n\n/* Double linked list utilities: remove element */\nstatic void list_remove(dl_list* list, struct connection* cnx)\n{\n    if (list->head == cnx) list->head = cnx->timeout_next;\n    if (list->tail == cnx) list->tail = cnx->timeout_prev;\n\n    if (cnx->timeout_prev)\n        cnx->timeout_prev->timeout_next = cnx->timeout_next;\n\n    if (cnx->timeout_next)\n        cnx->timeout_next->timeout_prev = cnx->timeout_prev;\n}\n\n/* Timeouts are managed with one list for each protocol. Whenever a connection\n * is active, it gets moved to the end of the list. Each call will pop the\n * first elements that have timed out and free their resources.\n *\n * This gets called every time a UDP packet is received from the outside, i.e.\n * every time we might need to free up resources. If no packets come in, we\n * don't time out anything, as we don't need the resources.\n * */\nvoid udp_timeouts(struct loop_info* fd_info)\n{\n    time_t now = time(NULL);\n\n    for (int i = 0; i < cfg.protocols_len; i++) {\n        struct connection *cnx = cfg.protocols[i].timeouts.head;\n        while (cnx && (now - cnx->last_active > cfg.protocols[i].udp_timeout)) {\n            print_message(msg_fd, \"timed out UDP %d\\n\", cnx->target_sock);\n            tidy_connection(cnx, fd_info);\n\n            cnx = cfg.protocols[i].timeouts.head;\n        }\n    }\n}\n\nvoid udp_tidy(struct connection* cnx, struct loop_info* fd_info)\n{\n    close(cnx->target_sock);\n    hash_remove(fd_info->hash_sources, cnx);\n    list_remove(&cnx->proto->timeouts, cnx);\n}\n\n/* Mark the connection was active */\nstatic void mark_active(struct connection* cnx)\n{\n    cnx->last_active = time(NULL);\n\n    dl_list* list = &cnx->proto->timeouts;\n\n    list_remove(list, cnx);\n    list_push(list, cnx);\n}\n\n\n/* Creates a new non-blocking socket */\nstatic int nonblocking_socket(struct sslhcfg_protocols_item* proto)\n{\n    int res;\n\n    if (proto->resolve_on_forward) {\n        res = resolve_split_name(&(proto->saddr), proto->host,\n                                 proto->port);\n        if (res) return -1;\n    }\n\n    int out = socket(proto->saddr->ai_family, SOCK_DGRAM, 0);\n    res = set_nonblock(out);\n    if (res == -1) {\n        print_message(msg_system_error, \"%s:%d:%s:%d:%s\\n\", __FILE__, __LINE__, \"udp:socket:nonblock\", errno, strerror(errno));\n        close(out);\n        return -1;\n    }\n    return out;\n}\n\n\n/* Process UDP coming from outside (client towards server)\n * If it's a new source, probe; otherwise, forward to previous target \n * Returns: newly allocate connections, for new connections\n * NULL otherwise\n * */\nstruct connection* udp_c2s_forward(int sockfd, struct loop_info* fd_info)\n{\n    char addr_str[NI_MAXHOST+1+NI_MAXSERV+1];\n    struct sockaddr_storage src_addr;\n    struct addrinfo addrinfo;\n    struct sslhcfg_protocols_item* proto;\n    cnx_collection* collection = fd_info->collection;\n    struct connection* cnx;\n    ssize_t len;\n    socklen_t addrlen;\n    ssize_t res;\n    int target, out = -1;\n    char data[65536]; /* Theoretical max is 65507 (https://en.wikipedia.org/wiki/User_Datagram_Protocol).\n                         This will do.  Dynamic allocation is possible with the MSG_PEEK flag in recvfrom(2), but that'd imply\n                         malloc/free overhead for each packet, when really 64K is not that much */\n\n\n    udp_timeouts(fd_info);\n\n    addrlen = sizeof(src_addr);\n    len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr*) &src_addr, &addrlen);\n    if (len < 0) {\n        perror(\"recvfrom\");\n        return NULL;\n    }\n    target = known_source(fd_info->hash_sources, &src_addr, addrlen);\n    addrinfo.ai_addr = (struct sockaddr*) &src_addr;\n    addrinfo.ai_addrlen = addrlen;\n    print_message(msg_probe_info, \"received %ld UDP from %d:%s\\n\", \n                  len, target, sprintaddr(addr_str, sizeof(addr_str), &addrinfo));\n\n    if (target == -1) {\n        res = probe_buffer(data, (int)len, udp_protocols, udp_protocols_len, &proto);\n        /* First version: if we can't work out the protocol from the first\n         * packet, drop it. Conceivably, we could store several packets to\n         * run probes on packet sets */\n        print_message(msg_probe_info, \"UDP probed: %d\\n\", res);\n        if (res != PROBE_MATCH) {\n            return NULL;\n        }\n\n        out = nonblocking_socket(proto);\n        if (out == -1) return NULL;\n        struct connection* cnx = collection_alloc_cnx_from_fd(collection, out);\n        if (!cnx) return NULL;\n        target = out;\n        cnx->target_sock = out;\n        cnx->proto = proto;\n        cnx->type = SOCK_DGRAM;\n        cnx->client_addr = src_addr;\n        cnx->addrlen = addrlen;\n        cnx->local_endpoint = sockfd;\n\n        res = new_source(fd_info->hash_sources, cnx);\n        if (res == -1) {\n            print_message(msg_connections_error, \"Out of hash space for new incoming UDP connection -- increase udp_max_connections\");\n            collection_remove_cnx(collection, cnx);\n            return NULL;\n        }\n    }\n    cnx = collection_get_cnx_from_fd(collection, target);\n\n    /* at this point src is the UDP connection */\n    res = sendto(cnx->target_sock, data, len, 0,\n                 cnx->proto->saddr->ai_addr, cnx->proto->saddr->ai_addrlen);\n    mark_active(cnx);\n    print_message(msg_fd, \"sending %d to %s\\n\", \n            res, sprintaddr(data, sizeof(data), cnx->proto->saddr));\n\n    return cnx;\n}\n\nvoid udp_s2c_forward(struct connection* cnx)\n{\n    int sockfd = cnx->target_sock;\n    char data[65536];\n    ssize_t res;\n\n    res = recvfrom(sockfd, data, sizeof(data), 0, NULL, NULL);\n    if ((res == -1) && ((errno == EAGAIN) || (errno == EWOULDBLOCK))) return;\n    CHECK_RES_DIE(res, \"udp_listener/recvfrom\");\n    res = sendto(cnx->local_endpoint, data, res, 0,\n                 (struct sockaddr*)&cnx->client_addr, cnx->addrlen);\n    mark_active(cnx);\n}\n\n"
        },
        {
          "name": "udp-listener.h",
          "type": "blob",
          "size": 0.841796875,
          "content": "#ifndef UDPLISTENER_H\n#define UDPLISTENER_H\n\n\n#include \"collection.h\"\n#include \"processes.h\"\n#include \"common.h\"\n\n/* UDP listener: upon incoming packet, find where it should go\n * This is run in its own process and never returns.\n */\nvoid udp_listener(struct listen_endpoint* endpoint, int num_endpoints, int active_endpoint);\n\n\n/* Process UDP coming from outside (client towards server)\n * If it's a new source, probe; otherwise, forward to previous target \n * Returns: newly allocate connections, for new connections\n * -1 otherwise\n * */\nstruct connection* udp_c2s_forward(int sockfd, struct loop_info* fd_info);\n\n/* Process UDP coming from inside (server towards client) */\nvoid udp_s2c_forward(struct connection* cnx);\n\n\nvoid udp_init(struct loop_info* fd_info);\nvoid udp_tidy(struct connection* cnx, struct loop_info* fd_info);\n\n#endif /* UDPLISTENER_H */\n"
        },
        {
          "name": "udp.cfg",
          "type": "blob",
          "size": 0.8212890625,
          "content": "# Example for UDP protocols\n\n# Listen sockets get a `is_udp : true` option\n# Protocol entries work exactly the same as TCP, there is no\n# difference. Currently, if mix up TCP and UDP probes, sslh will\n# try them in order and forward a UDP packet to a TCP probe\n# that matches (but using UDP; meaning, sslh will happily\n# forward a UDP packet to udp:localhost:80 if the HTTP\n# probe is specified, and matches)\n\nverbose: 3;\nforeground: true;\ninetd: false;\nnumeric: false;\ntransparent: false;\ntimeout: 10;\npidfile: \"/tmp/sslh_test.pid\";\n\n\n# List of interfaces on which we should listen\n# Options:\nlisten: (\n    { host: \"localhost\"; is_udp: true; port: \"4443\"; }\n);\n\n \nprotocols:\n(\n     { name: \"regex\"; regex_patterns: [ \"rutschle.net\" ]; host: \"ns1.rutschle.net\"; port: \"53\"; },\n     { name: \"anyprot\";  host: \"localhost\"; port: \"9099\";  }\n);\n"
        },
        {
          "name": "version.h",
          "type": "blob",
          "size": 0.0869140625,
          "content": "#ifndef VERSION_H \n#define VERSION_H \n\n#define VERSION \"v2.1.4-25-gbf08229-dirty\"\n#endif\n"
        }
      ]
    }
  ]
}