{
  "metadata": {
    "timestamp": 1736709763086,
    "page": 197,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cpq/bare-metal-programming-guide",
      "stars": 3429,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "/**/build/\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0556640625,
          "content": "MIT License\n\nCopyright (c) 2022 Cesanta Software Limited\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 72.9580078125,
          "content": "# A bare metal programming guide\n\n[![License: MIT](https://img.shields.io/badge/license-MIT-blue)](https://opensource.org/licenses/MIT)\n[![Build Status]( https://github.com/cpq/bare-metal-programming-guide/workflows/build/badge.svg)](https://github.com/cpq/bare-metal-programming-guide/actions)\n\nEnglish | [中文](README_zh-CN.md) | [Türkçe](README_tr-TR.md)\n\nThis guide is written for developers who wish to start programming\nmicrocontrollers using a GCC compiler and a datasheet, without using any\nframework. This guide explains the fundamentals, and helps to understand how\nembedded frameworks like Cube, Keil, Arduino, and others, work.\n\nEvery chapter in this guide comes with a complete source code which gradually\nprogress in functionality and completeness. In the end, I provide bare metal\ntemplate projects for different architectures:\n\n- **blinky** - classic, blink an LED and print a debug message periodically\n- **cli** - UART command line interface. Implements commands to set LED status and hexdump RAM\n- **lfs** - implement file functions `mkdir(),readdir(),fopen(),...` using\n  [littlefs](https://github.com/littlefs-project/littlefs) in the upper\n  region of buit-in flash memory. Store device boot\n  count in a file, increment on each boot, and print periodically\n- **webui** - embedded web server with a professional device dashboard UI\n  using [mongoose library](https://github.com/cesanta/mongoose)\n\n| Board | Arch | MCU datasheet | Board datasheet | Template project |\n| ----- | ---- | ------------- | --------------- | ---------------- |\n| STM32 Nucleo-F429ZI | Cortex-M4  | [mcu datasheet](https://www.st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf) | [board datasheet](https://www.st.com/resource/en/user_manual/dm00244518-stm32-nucleo144-boards-mb1137-stmicroelectronics.pdf) | [blinky](templates/blinky/nucleo-f429zi), [cli](templates/cli/nucleo-f429zi), [webui](steps/step-7-webserver/nucleo-f429zi/) |\n| STM32 Nucleo-F303K8 | Cortex-M4  | [mcu datasheet](https://www.st.com/resource/en/reference_manual/DM00043574-.pdf) | [board datasheet](https://www.st.com/resource/en/datasheet/stm32f303k8.pdf) | [lfs](templates/lfs/nucleo-f303k8) |\n| STM32 Nucleo-L432KC | Cortex-M4  | [mcu datasheet](https://www.st.com/resource/en/reference_manual/dm00151940-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf) | [board datasheet](https://www.st.com/resource/en/datasheet/stm32l432kc.pdf) | [blinky](templates/blinky/nucleo-l432kc), [cli](templates/cli/nucleo-l432kc), [lfs](templates/lfs/nucleo-l432kc) |\n| SAME54 Xplained     | Cortex-M4  | [mcu datasheet](https://ww1.microchip.com/downloads/aemDocuments/documents/MCU32/ProductDocuments/DataSheets/SAM-D5x-E5x-Family-Data-Sheet-DS60001507.pdf) | [board datasheet](https://ww1.microchip.com/downloads/en/DeviceDoc/70005321A.pdf) | [blinky](templates/blinky/same54-xplained) |\n| TI EK-TM4C1294XL    | Cortex-M4F | [mcu datasheet](https://www.ti.com/lit/ds/symlink/tm4c1294ncpdt.pdf) | [board datasheet](https://www.ti.com/lit/ug/spmu365c/spmu365c.pdf) | [webui](steps/step-7-webserver/ek-tm4c1294xl) | \n| RP2040 Pico-W5500   | Cortex-M0+ | [mcu datasheet](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf) | [board datasheet](https://docs.wiznet.io/Product/iEthernet/W5500/w5500-evb-pico) | [webui](steps/step-7-webserver/pico-w5500/) |\n| ESP32-C3            | RISCV      | [mcu datasheet](https://www.espressif.com/sites/default/files/documentation/esp32-c3_technical_reference_manual_en.pdf) | | [blinky](templates/blinky/esp32-c3) |\n\nIn this tutorial we'll use the **Nucleo-F429ZI** development board, so\ngo ahead and download the mcu datasheet and the board datasheet for it.\n\n## Tools setup\n\nTo proceed, the following tools are required:\n\n- ARM GCC, https://launchpad.net/gcc-arm-embedded - for compiling and linking\n- GNU make, http://www.gnu.org/software/make/ - for build automation\n- ST link, https://github.com/stlink-org/stlink - for flashing\n- Git, https://git-scm.com/ - for downloading source code and version control\n\n### Setup instructions for Mac\n\nStart a terminal, and execute:\n\n```sh\n$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n$ brew install gcc-arm-embedded make stlink git\n```\n\n### Setup instructions for Linux (Ubuntu)\n\nStart a terminal, and execute:\n\n```sh\n$ sudo apt -y update\n$ sudo apt -y install gcc-arm-none-eabi make stlink-tools git\n```\n\n### Setup instructions for Windows\n\n- Download and install [gcc-arm-none-eabi-10.3-2021.10-win32.exe](https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C). Enable \"Add path to environment variable\" during the installation\n- Create `c:\\tools` folder\n- Download [stlink-1.7.0-x86_64-w64-mingw32.zip](https://github.com/stlink-org/stlink/releases/download/v1.7.0/stlink-1.7.0-x86_64-w64-mingw32.zip) and unpack `bin/st-flash.exe` into `c:\\tools`\n- Download [make-4.4-without-guile-w32-bin.zip](https://sourceforge.net/projects/ezwinports/files/make-4.4-without-guile-w32-bin.zip/download) and unpack `bin/make.exe` into `c:\\tools`\n- Add `c:\\tools` to the `Path` environment variable\n- Enable \"Developer Mode\" in Windows 10/11, for symbolic link support.\n- Install Git from https://git-scm.com/download/win. Check \"Enable symlink\" during installation\n\n### Verify installed tools\n\nNow, when all required tools are installed, start terminal/command prompt, and\nenter the following commands to download this repository and build an example:\n\n```sh\ngit clone https://github.com/cpq/bare-metal-programming-guide\ncd bare-metal-programming-guide/steps/step-0-minimal\nmake\n```\n\n## Introduction\n\nA microcontroller (uC, or MCU) is a small computer. Typically it has CPU, RAM,\nflash to store firmware code, and a bunch of pins that stick out. Some pins are\nused to power the MCU, usually marked as GND (ground) and VCC pins. Other pins\nare used to communicate with the MCU, by means of high/low voltage applied to\nthose pins. One of the simplest ways of communication is an LED attached to a\npin: one LED contact is attached to the ground pin (GND), and another contact\nis attached to a signal pin via a current-limiting resistor.  A firmware code\ncan set high or low voltage on a signal pin, making LED blink:\n\n<img src=\"images/mcu.svg\" height=\"200\" />\n\n### Memory and registers\n\nThe 32-bit address space of the MCU is divided by regions. For example, some\nregion of memory is mapped to the internal MCU flash at a specific address.\nFirmware code instructions are read and executed by reading from that memory region. Another region is\nRAM, which is also mapped to a specific address. We can read and write any\nvalues to the RAM region.\n\nFrom STM32F429 datasheet, we can take a look at section 2.3.1 and learn\nthat RAM region starts at address 0x20000000 and has size of 192KB. From section\n2.4 we can learn that flash is mapped at address 0x08000000. Our MCU has\n2MB flash, so flash and RAM regions are located like this:\n\n<img src=\"images/mem.svg\" />\n\nFrom the datasheet we can also learn that there are many more memory regions.\nTheir address ranges are given in the section 2.3 \"Memory Map\". For example,\nthere is a \"GPIOA\" region that starts at 0x40020000 and has length of 1KB.\n\nThese memory regions correspond to a different \"peripherals\" inside the MCU -\na piece of silicon circuitry that make certain pins behave in a special way.\nA peripheral memory region is a collection of 32-bit **registers**. Each\nregister is a 4-byte memory range at a certain address, that maps to a certain\nfunction of the given peripheral. By writing values into a register - in other\nwords, by writing a 32-bit value at a certain memory address, we can control\nhow given peripheral should behave. By reading registers, we can read back\nperipheral's data or configuration.\n\nThere are many different peripherals. One of the simpler ones are GPIO\n(General Purpose Input Output), which allow user to set MCU pins\ninto \"output mode\" and set high or low voltage on them. Or, set pins into\nan \"input mode\" and read voltage values from them. There is a UART peripheral\nwhich can transmit and receive serial data over two pins using serial protocol.\nThere are many other peripherals.\n\nOften, there are multiple \"instances\" of the same peripheral, for example\nGPIOA, GPIOB, ... which control different set of MCU pins. Likewise, there\ncould be UART1, UART2, ... which allow to implement multiple UART channels.\nOn Nucleo-F429, there are several GPIO and UART peripherals.\n\nFor example, GPIOA\nperipheral starts at 0x40020000, and we can find GPIO register description in\nsection 8.4. The datasheet says that `GPIOA_MODER` register has offset 0, that\nmeans that it's address is `0x40020000 + 0`, and this is the format of the\nregister:\n\n<img src=\"images/moder.png\" style=\"max-width: 100%\" />\n\nThe datasheet shows that the 32-bit MODER register is a collection of 2-bit\nvalues, 16 in total. Therefore, one MODER register controls 16 physical pins,\nBits 0-1 control pin 0, bits 2-3 control pin 1, and so on. The 2-bit value\nencodes pin mode: 0 means input, 1 means output, 2 means \"alternate function\" -\nsome specific behavior described elsewhere, and 3 means analog. Since the\nperipheral name is \"GPIOA\", then pins are named \"A0\", \"A1\", etc. For peripheral\n\"GPIOB\", pin naming would be \"B0\", \"B1\", ...\n\nIf we write 32-bit value `0` to the register MODER, we'll set all 16 pins,\nfrom A0 to A15, to input mode:\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) = 0;  // Set A0-A15 to input mode\n```\n\nNote the `volatile` specifier. Its meaning will be covered later.  By setting\nindividual bits, we can selectively set specific pins to a desired mode. For\nexample, this snippet sets pin A3 to output mode:\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // CLear bit range 6-7\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // Set bit range 6-7 to 1\n```\n\nLet me explain those bit operations. Our goal is to set bits 6-7, which are\nresponsible for the pin 3 of GPIOA peripheral, to a specific value (1, in our\ncase). This is done in two steps. First, we must clear the current value of\nbits 6-7, because it may hold some value already. Then we must set bits 6-7\nto the value we want.\n\nSo, first, we must set bit range 6-7 (two bits at position 6) to zero. How do\nwe set a number of bits to zero? In four steps:\n\n| Action | Expression | Bits (first 12 of 32) |\n| - | - | - |\n| Get a number with N contiguous bits set: `2^N-1`, N=2 | `3`  | `000000000011` |\n| Shift that number X positions left | `(3<<6)` | `000011000000` |\n| Invert the number: turn zeros to ones, and ones to zeroes | `~(3<<6)` | `111100111111` |\n| Bitwise AND with existing value | `VAL &= ~(3<<6)` | `xxxx00xxxxxx` |\n\nNote that the last operation, bitwise AND, turns N bits at position X to zero\n(because they are ANDed with 0), but retains the value of all other bits\n(because they are ANDed with 1). Retaining existing value is important, cause\nwe don't want to change settings in other bit ranges. So in general, if we want\nto clear N bits at position X:\n\n```c\nREGISTER &= ~((2^N - 1) << X);\n```\n\nAnd, finally, we want to set a given bit range to the value we want. We\nshift that value X positions left, and OR with the current value of the whole\nregister (in order to retain other bits' values):\n\n```c\nREGISTER |= VALUE << X;\n```\n\n## Human-readable peripherals programming\n\nIn the previous section we have learned that we can read and write peripheral\nregister by direct accessing certain memory addresses. Let's look at the\nsnippet that sets pin A3 to output mode:\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // CLear bit range 6-7\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // Set bit range 6-7 to 1\n```\n\nThat is pretty cryptic. Without extensive comments, such code would be quite\nhard to understand. We can rewrite this code to a much more readable form.  The\nidea is to represent the whole peripheral as a structure that contains 32-bit\nfields. Let's see what registers exist for the GPIO peripheral in the section\n8.4 of the datasheet. They are MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR,\nLCKR, AFR. Their offsets are with offsets 0, 4, 8, etc... . That means we can\nrepresent them as a structure with 32-bit fields, and make a define for GPIOA:\n\n```c\nstruct gpio {\n  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];\n};\n\n#define GPIOA ((struct gpio *) 0x40020000)\n```\n\nThen, for setting GPIO pin mode, we can define a function:\n\n```c\n// Enum values are per datasheet: 0, 1, 2, 3\nenum {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG};\n\nstatic inline void gpio_set_mode(struct gpio *gpio, uint8_t pin, uint8_t mode) {\n  gpio->MODER &= ~(3U << (pin * 2));        // Clear existing setting\n  gpio->MODER |= (mode & 3) << (pin * 2);   // Set new mode\n}\n```\nNow, we can rewrite the snippet for A3 like this:\n\n```c\ngpio_set_mode(GPIOA, 3 /* pin */, GPIO_MODE_OUTPUT);  // Set A3 to output\n```\n\nOur MCU has several GPIO peripherals (also called \"banks\"): A, B, C, ... K.\nFrom section 2.3 we can see that they are 1KB away from each other:\nGPIOA is at address 0x40020000, GPIOB is at 0x40020400, and so on:\n\n```c\n#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))\n```\n\nWe can create pin numbering that includes the bank and the pin number.\nTo do that, we use 2-byte `uint16_t` value, where upper byte indicates\nGPIO bank, and lower byte indicates pin number:\n\n```c\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n```\n\nThis way, we can specify pins for any GPIO bank:\n\n```c\n  uint16_t pin1 = PIN('A', 3);    // A3   - GPIOA pin 3\n  uint16_t pin2 = PIN('G', 11);   // G11  - GPIOG pin 11\n``` \n\nLet's look first at what happens for `PIN('A', 3)`:\n\n- `(bank) - 'A'` results in `'A' - 'A'` which will evaluate to `0`. As a 16 bit binary value this would be `0b00000000,00000000`.\n- Next we bit shift this value left by 8 bits because we want to store `bank` in the upper byte of this 16 bit, or 2 byte value. In this case the result remains the same: `0b00000000,00000000`.\n- Finally we bitwise OR the value above with `num`, in our case `3` which has a 16 bit binary representation of `0b00000000,00000011`. The result in binary is `0b00000000,00000011`.\n\nLet's take a look at what happens for `PIN('G',11)`:\n\n- `(bank) - 'G'` results in `'G' - 'A'` which will evaluate to `6`. As a 16 bit binary value this would be `0b00000000,00000110`.\n- Next we bit shift this value left by 8 bits because we want to store `bank` in the upper byte of this 16 bit, or 2 byte value. This results in a binary value of: `0b00000110,00000000`.\n- Finally we bitwise OR the value above with `num`, in our case `11` which has a 16 bit binary representation of `0b00000000,00001011`. The result of the bitwise OR in binary is `0b00000110,00001011` which is a combination of `bank` in the upper byte and `pin` in the lower byte.\n\nLet's rewrite the `gpio_set_mode()` function to take our pin specification:\n\n```c\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin)); // GPIO bank\n  uint8_t n = PINNO(pin);                 // Pin number\n  gpio->MODER &= ~(3U << (n * 2));        // Clear existing setting\n  gpio->MODER |= (mode & 3) << (n * 2);   // Set new mode\n}\n```\n\nNow the code for A3 is self-explanatory:\n\n```c\n  uint16_t pin = PIN('A', 3);            // Pin A3\n  gpio_set_mode(pin, GPIO_MODE_OUTPUT);  // Set to output\n```\n\nNote that we have created a useful initial API for the GPIO peripheral. Other\nperipherals, like UART (serial communication) and others - can be implemented\nin a similar way. This is a good programming practice that makes code\nself-explanatory and human readable.\n\n## MCU boot and vector table\n\nWhen an ARM MCU boots, it reads a so-called \"vector table\" from the\nbeginning of flash memory. A vector table is a concept common to all ARM MCUs.\nThat is an array of 32-bit addresses of interrupt handlers. First 16 entries\nare reserved by ARM and are common to all ARM MCUs. The rest of interrupt\nhandlers are specific to the given MCU - these are interrupt handlers for\nperipherals. Simpler MCUs with few peripherals have few interrupt handlers,\nand more complex MCUs have many.\n\nVector table for STM32F429 is documented in Table 62. From there we can learn\nthat there are 91 peripheral handlers, in addition to the standard 16.\n\nEvery entry in the vector table is an address of a function that MCU executes\nwhen a hardware interrupt (IRQ) triggers. The exception are first two entries,\nwhich play a key role in the MCU boot process.  Those two first values are: an\ninitial stack pointer, and an address of the boot function to execute (a\nfirmware entry point).\n\nSo now we know, that we must make sure that our firmware should be composed in\na way that the 2nd 32-bit value in the flash should contain an address of\nour boot function. When MCU boots, it'll read that address from flash, and\njump to our boot function.\n\n\n## Minimal firmware\n\nLet's create a file `main.c`, and specify our boot function that initially does\nnothing (falls into infinite loop), and specify a vector table that contains 16\nstandard entries and 91 STM32 entries. In your editor of choice, create\n`main.c` file and copy/paste the following into `main.c` file:\n\n```c\n// Startup code\n__attribute__((naked, noreturn)) void _reset(void) {\n  for (;;) (void) 0;  // Infinite loop\n}\n\nextern void _estack(void);  // Defined in link.ld\n\n// 16 standard and 91 STM32-specific handlers\n__attribute__((section(\".vectors\"))) void (*const tab[16 + 91])(void) = {\n  _estack, _reset\n};\n```\n\nFor function `_reset()`, we have used GCC-specific attributes `naked` and\n`noreturn` - they mean, standard function's prologue and epilogue should not\nbe created by the compiler, and that function does not return.\n\nThe `void (*const tab[16 + 91])(void)` expression means: define an array of 16\n\\+ 91 pointers to functions which return nothing (void) and take no arguments (void).\nEach such function is an IRQ handler (Interrupt ReQuest handler). An array of\nthose handlers is called a vector table.\n\nThe vector table `tab` we put in a separate section called `.vectors` - that we\nneed later to tell the linker to put that section right at the beginning of the\ngenerated firmware - and consecutively, at the beginning of flash memory. The\nfirst two entries are: the value of the stack pointer register, and the\nfirmware's entry point.  We leave the rest of vector table filled with zeroes.\n\n### Compilation\n\nLet's compile our code. Start a terminal (or a command prompt on Windows) and execute:\n\n```sh\n$ arm-none-eabi-gcc -mcpu=cortex-m4 main.c -c\n```\n\nThat works! The compilation produced a file `main.o` which contains\nour minimal firmware that does nothing.  The `main.o` file is in ELF binary\nformat, which contains several sections. Let's see them:\n\n```sh\n$ arm-none-eabi-objdump -h main.o\n...\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00000002  00000000  00000000  00000034  2**1\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .data         00000000  00000000  00000000  00000036  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  00000000  00000000  00000036  2**0\n                  ALLOC\n  3 .vectors      000001ac  00000000  00000000  00000038  2**2\n                  CONTENTS, ALLOC, LOAD, RELOC, DATA\n...\n```\n\nNote that VMA/LMA addresses for sections are set to 0 - meaning, `main.o`\nis not yet a complete firmware, because it does not contain the information\nwhere those sections should be loaded in the address space. We need to use\na linker to produce a full firmware `firmware.elf` from `main.o`.\n\nThe section .text contains firmware code, in our case it is just a _reset()\nfunction, 2-bytes long - a jump instruction to its own address. There is\nan empty `.data` section and an empty `.bss` section\n(data that is initialized to zero) . Our firmware will be copied\nto the flash region at offset 0x8000000, but our data section should reside\nin RAM - therefore our `_reset()` function should copy the contents of the\n`.data` section to RAM. Also it has to write zeroes to the whole `.bss`\nsection. Our `.data` and `.bss` sections are empty, but let's modify our\n`_reset()` function anyway to handle them properly.\n\nIn order to do all that, we must know where stack starts, and where data and\nbss section start. This we can specify in the \"linker script\", which is a file\nwith the instructions to the linker, where to put various sections in the\naddress space, and which symbols to create.\n\n### Linker script\n\nCreate a file `link.ld`, and copy-paste contents from\n[steps/step-0-minimal/link.ld](steps/step-0-minimal/link.ld). Below is the explanation:\n\n```\nENTRY(_reset);\n```\n\nThis line tells the linker the value of the \"entry point\" attribute in the\ngenerated ELF header - so this is a duplicate to what a vector table has.  This\nis an aid for a debugger (like Ozone, described below) that helps to set a\nbreakpoint at the beginning of the firmware.  A debugger does not know about a\nvector table, so it relies on the ELF header.\n\n```\nMEMORY {\n  flash(rx)  : ORIGIN = 0x08000000, LENGTH = 2048k\n  sram(rwx) : ORIGIN = 0x20000000, LENGTH = 192k  /* remaining 64k in a separate address space */\n}\n```\nThis tells the linker that we have two memory regions in the address space,\ntheir addresses and sizes.\n\n```\n_estack     = ORIGIN(sram) + LENGTH(sram);    /* stack points to end of SRAM */\n```\n\nThis tell a linker to create a symbol `estack` with value at the very end\nof the RAM memory region. That will be our initial stack value!\n\n```\n  .vectors  : { KEEP(*(.vectors)) }   > flash\n  .text     : { *(.text*) }           > flash\n  .rodata   : { *(.rodata*) }         > flash\n```\n\nThese lines tell the linker to put vectors table on flash first,\nfollowed by `.text` section (firmware code), followed by the read only\ndata `.rodata`.\n\nThe next goes `.data` section:\n\n```\n  .data : {\n    _sdata = .;   /* .data section start */\n    *(.first_data)\n    *(.data SORT(.data.*))\n    _edata = .;  /* .data section end */\n  } > sram AT > flash\n  _sidata = LOADADDR(.data);\n```\n\nNote that we tell linker to create `_sdata` and `_edata` symbols. We'll\nuse them to copy data section to RAM in the `_reset()` function.\n\nSame for `.bss` section:\n\n```\n  .bss : {\n    _sbss = .;              /* .bss section start */\n    *(.bss SORT(.bss.*) COMMON)\n    _ebss = .;              /* .bss section end */\n  } > sram\n```\n\n### Startup code\n\nNow we can update our `_reset()` function. We copy `.data` section to RAM, and\ninitialise bss section to zeroes. Then, we call main() function - and fall into\ninfinite loop in case if main() returns:\n\n```c\nint main(void) {\n  return 0; // Do nothing so far\n}\n\n// Startup code\n__attribute__((naked, noreturn)) void _reset(void) {\n  // memset .bss to zero, and copy .data section to RAM region\n  extern long _sbss, _ebss, _sdata, _edata, _sidata;\n  for (long *dst = &_sbss; dst < &_ebss; dst++) *dst = 0;\n  for (long *dst = &_sdata, *src = &_sidata; dst < &_edata;) *dst++ = *src++;\n\n  main();             // Call main()\n  for (;;) (void) 0;  // Infinite loop in the case if main() returns\n}\n```\n\nThe following diagram visualises how `_reset()` initialises .data and .bss:\n\n![](images/mem2.svg)\n\nThe `firmware.bin` file is just a concatenation of the three sections:\n`.vectors` (IRQ vector table), `.text` (code) and `.data` (data).  Those\nsections were built according to the linker script: `.vectors` lies at the very\nbeginning of flash, then `.text` follows immediately after, and `.data` lies\nfar above. Addresses in `.text` are in the flash region, and addresses in\n`.data` are in the RAM region.  If some function has address e.g. `0x8000100`,\nthen it is located exactly at that address on flash. But if the code accesses\nsome variable in the `.data` section by the address e.g. `0x20000200`, then\nthere is nothing at that address, because at boot, `.data` section in the\n`firmware.bin` resides in flash! That's why the startup code must relocate\n`.data` section from flash region to the RAM region.\n\nNow we are ready to produce a full firmware file `firmware.elf`:\n\n```sh\n$ arm-none-eabi-gcc -T link.ld -nostdlib main.o -o firmware.elf\n```\n\nLet's examine sections in firmware.elf:\n\n```sh\n$ arm-none-eabi-objdump -h firmware.elf\n...\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .vectors      000001ac  08000000  08000000  00010000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  1 .text         00000058  080001ac  080001ac  000101ac  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n...\n```\n\nNow we can see that the .vectors section will reside at the very beginning of\nflash memory at address 0x8000000, then the .text section right after it, at\n0x80001ac. Our code does not create any variables, so there is no data section.\n\n## Flash firmware\n\nWe're ready to flash this firmware! First, extract sections from the\nfirmware.elf into a single contiguous binary blob:\n\n```sh\n$ arm-none-eabi-objcopy -O binary firmware.elf firmware.bin\n```\n\nAnd use `st-link` utility to flash the firmware.bin. Plug your board to the\nUSB, and execute:\n\n```sh\n$ st-flash --reset write firmware.bin 0x8000000\n```\n\nDone! We've flashed a firmware that does nothing.\n\n## Makefile: build automation\n\nInstead of typing those compilation, linking and flashing commands, we can\nuse `make` command line tool to automate the whole process. `make` utility\nuses a configuration file named `Makefile` where it reads instructions\nhow to execute actions. This automation is great because it also documents the\nprocess of building firmware, used compilation flags, etc.\n\nThere is a great Makefile tutorial at https://makefiletutorial.com - for those\nnew to `make`, I suggest to take a look. Below, I list the most essential\nconcepts required to understand our simple bare metal Makefile. Those who\nalready familiar with `make`, can skip this section.\n\nThe `Makefile` format is simple:\n\n```make\naction1:\n\tcommand ...     # Comments can go after hash symbol\n\tcommand ....    # IMPORTANT: command must be preceded with the TAB character\n\naction2:\n\tcommand ...     # Don't forget about TAB. Spaces won't work!\n```\n\nNow, we can invoke `make` with the action name (also called *target*) to execute\na corresponding action:\n\n```sh\n$ make action1\n```\n\nIt is possible to define variables and use them in commands. Also, actions\ncan be file names that needs to be created:\n\n```make\nfirmware.elf:\n\tCOMPILATION COMMAND .....\n```\n\nAnd, any action can have a list of dependencies. For example, `firmware.elf`\ndepends on our source file `main.c`. Whenever `main.c` file changes, the\n`make build` command rebuilds `firmware.elf`:\n\n```\nbuild: firmware.elf\n\nfirmware.elf: main.c\n\tCOMPILATION COMMAND\n```\n\nNow we are ready to write a Makefile for our firmware. We define a `build`\naction / target:\n\n```make\nCFLAGS  ?=  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion \\\n            -Wformat-truncation -fno-common -Wconversion \\\n            -g3 -Os -ffunction-sections -fdata-sections -I. \\\n            -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 $(EXTRA_CFLAGS)\nLDFLAGS ?= -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=$@.map\nSOURCES = main.c \n\nbuild: firmware.elf\n\nfirmware.elf: $(SOURCES)\n\tarm-none-eabi-gcc $(SOURCES) $(CFLAGS) $(LDFLAGS) -o $@\n```\n\nThere, we define compilation flags. The `?=` means that's a default value;\nwe could override them from the command line like this:\n\n```sh\n$ make build CFLAGS=\"-O2 ....\"\n```\n\nWe specify `CFLAGS`, `LDFLAGS` and `SOURCES` variables.\nThen we tell `make`: if you're told to `build`, then create a `firmware.elf`\nfile. It depends on the `main.c` file, and to create it, start\n`arm-none-eabi-gcc` compiler with a given flags. `$@` special variable\nexpands to a target name - in our case, `firmware.elf`.\n\nLet's call `make`:\n\n```\n$ make build\narm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion -Wformat-truncation -fno-common -Wconversion -g3 -Os -ffunction-sections -fdata-sections -I. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16  -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=firmware.elf.map -o firmware.elf\n```\n\nIf we run it again:\n\n```sh\n$ make build\nmake: Nothing to be done for `build'.\n```\n\nThe `make` utility examines modification times for `main.c` dependency and\n`firmware.elf` - and does not do anything if `firmware.elf` is up to date.\nBut if we change `main.c`, then next `make build` will recompile:\n\n```sh\n$ touch main.c # Simulate changes in main.c\n$ make build\n```\n\nNow, what is left - is the `flash` target:\n\n\n```make\nfirmware.bin: firmware.elf\n\tarm-none-eabi-objcopy -O binary $< $@\n\nflash: firmware.bin\n\tst-flash --reset write $< 0x8000000\n```\n\nThat's it! Now, `make flash` terminal command creates a `firmware.bin` file,\nand flashes it to the board. It'll recompile the firmware if `main.c` changes,\nbecause `firmware.bin` depends on `firmware.elf`, and it in turn depends on\n`main.c`. So, now the development cycle would be these two actions in a loop:\n\n```sh\n# Develop code in main.c\n$ make flash\n```\n\nIt is a good idea to add a clean target to remove build artifacts:\n\n\n```\nclean:\n\trm -rf firmware.*\n```\n\nA complete project source code you can find in [steps/step-0-minimal](steps/step-0-minimal) folder.\n\n## Blinky LED\n\nNow as we have the whole build / flash infrastructure set up, it is time to\nteach our firmware to do something useful. Something useful is of course blinking\nan LED. A Nucleo-F429ZI board has three built-in LEDs. In a Nucleo board\ndatasheet section 6.5 we can see which pins built-in LEDs are attached to:\n\n- PB0: green LED\n- PB7: blue LED\n- PB14: red LED\n\nLet's modify `main.c` file and add our definitions for PIN, `gpio_set_mode()`.\nIn the main() function, we set the blue LED to output mode, and start an\ninfinite loop. First, let's copy the definitions for pins and GPIO we have\ndiscussed earlier. Note we also add a convenience macro `BIT(position)`:\n\n```c\n#include <inttypes.h>\n#include <stdbool.h>\n\n#define BIT(x) (1UL << (x))\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n\nstruct gpio {\n  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];\n};\n#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))\n\n// Enum values are per datasheet: 0, 1, 2, 3\nenum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };\n\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  gpio->MODER &= ~(3U << (n * 2));         // Clear existing setting\n  gpio->MODER |= (mode & 3) << (n * 2);    // Set new mode\n}\n```\n\nSome microcontrollers, when they are powered, have all their peripherals\npowered and enabled, automatically. STM32 MCUs, however, by default have their\nperipherals disabled in order to save power. In order to enable a GPIO peripheral,\nit should be enabled (clocked) via the RCC (Reset and Clock Control) unit.\nIn the datasheet section 7.3.10 we find that the AHB1ENR (AHB1 peripheral\nclock enable register) is responsible to turn GPIO banks on or off. First we\nadd a definition for the whole RCC unit:\n\n```c\nstruct rcc {\n  volatile uint32_t CR, PLLCFGR, CFGR, CIR, AHB1RSTR, AHB2RSTR, AHB3RSTR,\n      RESERVED0, APB1RSTR, APB2RSTR, RESERVED1[2], AHB1ENR, AHB2ENR, AHB3ENR,\n      RESERVED2, APB1ENR, APB2ENR, RESERVED3[2], AHB1LPENR, AHB2LPENR,\n      AHB3LPENR, RESERVED4, APB1LPENR, APB2LPENR, RESERVED5[2], BDCR, CSR,\n      RESERVED6[2], SSCGR, PLLI2SCFGR;\n};\n#define RCC ((struct rcc *) 0x40023800)\n```\n\nIn the AHB1ENR register documentation we see that bits from 0 to 10 inclusive\nset the clock for GPIO banks GPIOA - GPIOK:\n\n```c\nint main(void) {\n  uint16_t led = PIN('B', 7);            // Blue LED\n  RCC->AHB1ENR |= BIT(PINBANK(led));     // Enable GPIO clock for LED\n  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode\n  for (;;) (void) 0;                     // Infinite loop\n  return 0;\n}\n```\n\nNow, what is left to do, is to find out how to set a GPIO pin on and off, and\nthen modify the main loop to set an LED pin on, delay, off, delay.  Looking at\nthe datasheet section 8.4.7, wee see that the register BSRR is responsible for\nsetting voltage high or low. The low 16 bit are used to set the ODR register\n(i.e. set pin high), and high 16 bit are used  to reset the ODR\nregister (i.e. set pin low). Let's define an API function for that:\n\n```c\nstatic inline void gpio_write(uint16_t pin, bool val) {\n  struct gpio *gpio = GPIO(PINBANK(pin));\n  gpio->BSRR = (1U << PINNO(pin)) << (val ? 0 : 16);\n}\n```\n\nNext we need to implement a delay function. We do not require an accurate\ndelay at this moment, so let's define a function `spin()` that just executes\na NOP instruction a given number of times:\n\n```c\nstatic inline void spin(volatile uint32_t count) {\n  while (count--) (void) 0;\n}\n```\n\nFinally, we're ready to modify our main loop to implement LED blinking:\n\n```c\n  for (;;) {\n    gpio_write(led, true);\n    spin(999999);\n    gpio_write(led, false);\n    spin(999999);\n  }\n```\n\nRun `make flash` and enjoy blue LED flashing.\nA complete project source code you can find in [steps/step-1-blinky](steps/step-1-blinky).\n\n## Blinky with SysTick interrupt\n\nIn order to implement an accurate time keeping, we should enable ARM's SysTick\ninterrupt. SysTick a 24-bit hardware counter, and is part of ARM core,\ntherefore it is documented by the ARM datasheet. Looking at the datasheet, we\nsee that SysTick has four registers:\n\n- CTRL - used to enable/disable systick\n- LOAD - an initial counter value\n- VAL - a current counter value, decremented on each clock cycle\n- CALIB - calibration register\n\nEvery time VAL drops to zero, a SysTick interrupt is generated.\nThe SysTick interrupt index in the vector table is 15, so we need to set it.\nUpon boot, our board Nucleo-F429ZI runs at 16Mhz. We can configure the SysTick\ncounter to trigger interrupt each millisecond.\n\nFirst, let's define a SysTick peripheral. We know 4 registers, and from the\ndatasheet we can learn that the SysTick address is 0xe000e010. So:\n\n```c\nstruct systick {\n  volatile uint32_t CTRL, LOAD, VAL, CALIB;\n};\n#define SYSTICK ((struct systick *) 0xe000e010)\n```\n\nNext, add an API function that configures it. We need to enable SysTick\nin the `SYSTICK->CTRL` register, and also we must clock it via the\n`RCC->APB2ENR`, described in the section 7.4.14:\n\n```c\n#define BIT(x) (1UL << (x))\nstatic inline void systick_init(uint32_t ticks) {\n  if ((ticks - 1) > 0xffffff) return;  // Systick timer is 24 bit\n  SYSTICK->LOAD = ticks - 1;\n  SYSTICK->VAL = 0;\n  SYSTICK->CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick\n  RCC->APB2ENR |= BIT(14);                   // Enable SYSCFG\n}\n```\n\nBy default, Nucleo-F429ZI board runs at 16Mhz. That means, if we call\n`systick_init(16000000 / 1000);`, then SysTick interrupt will be generated\nevery millisecond. We should have interrupt handler function defined - here\nit is, we simply increment a 32-bit millisecond counter:\n\n```c\nstatic volatile uint32_t s_ticks; // volatile is important!!\nvoid SysTick_Handler(void) {\n  s_ticks++;\n}\n```\n\nWith 16MHz clock, we init SysTick counter to trigger an interrupt every\n16000 cycles: the `SYSTICK->VAL` initial value is 15999, then it decrements\non each cycle by 1, and when it reaches 0, an interrupt is generated. The\nfirmware code execution gets interrupted: a `SysTick_Handler()` function is\ncalled to increment `s_tick` variable. Here how it looks like on a time scale:\n\n![](images/systick.svg)\n\n\nThe `volatile` specifier is required here because `s_ticks` is modified by the\ninterrupt handler. `volatile` prevents the compiler to optimise/cache `s_ticks`\nvalue in a CPU register: instead, generated code always accesses memory.  That\nis why `volatile` keywords is present in the peripheral struct definitions,\ntoo. Since this is important to understand, let's demonstrate that on a simple\nfunction: Arduino's `delay()`. Let it use our `s_ticks` variable:\n\n```c\nvoid delay(unsigned ms) {            // This function waits \"ms\" milliseconds\n uint32_t until = s_ticks + ms;      // Time in a future when we need to stop\n while (s_ticks < until) (void) 0;   // Loop until then\n}\n```\n\nNow let's compile this code with, and without `volatile` specifier for `s_ticks`\nand compare generated machine code:\n\n```\n// NO VOLATILE: uint32_t s_ticks;       |  // VOLATILE: volatile uint32_t s_ticks;\n                                        |\n ldr     r3, [pc, #8]  // cache s_ticks |  ldr     r2, [pc, #12]\n ldr     r3, [r3, #0]  // in r3         |  ldr     r3, [r2, #0]   // r3 = s_ticks\n adds    r0, r3, r0    // r0 = r3 + ms  |  adds    r3, r3, r0     // r3 = r3 + ms\n                                        |  ldr     r1, [r2, #0]   // RELOAD: r1 = s_ticks\n cmp     r3, r0        // ALWAYS FALSE  |  cmp     r1, r3         // compare\n bcc.n   200000d2 <delay+0x6>           |  bcc.n   200000d2 <delay+0x6>\n bx      lr                             |  bx      lr\n```\n\nIf there is no `volatile`, the `delay()` function will loop forever and never\nreturn. That is because it caches (optimises) the value of `s_ticks` in a\nregister and never updates it. A compiler does that because it doesn't know\nthat `s_ticks` can be updated elsewhere - by the interrupt handler!  The\ngenerated code with `volatile`, on the other hand, loads `s_ticks` value on\neach iteration.  So, the rule of thumb: **those values in memory that get\nupdated by interrupt handlers, or by the hardware, declare as `volatile`**.\n\nNow we should add `SysTick_Handler()` interrupt handler to the vector table:\n\n```c\n__attribute__((section(\".vectors\"))) void (*const tab[16 + 91])(void) = {\n    _estack, _reset, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SysTick_Handler};\n```\n\nNow we have a precise millisecond clock! Let's create a helper function\nfor arbitrary periodic timers:\n\n```c\n// t: expiration time, prd: period, now: current time. Return true if expired\nbool timer_expired(uint32_t *t, uint32_t prd, uint32_t now) {\n  if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer\n  if (*t == 0) *t = now + prd;                   // First poll? Set expiration\n  if (*t > now) return false;                    // Not expired yet, return\n  *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time\n  return true;                                   // Expired, return true\n}\n```\n\nNow we are ready to update our main loop and use a precise timer for LED blink.\nFor example, let's use 500 milliseconds blinking interval:\n\n```c\n  uint32_t timer, period = 500;          // Declare timer and 500ms period\n  for (;;) {\n    if (timer_expired(&timer, period, s_ticks)) {\n      static bool on;       // This block is executed\n      gpio_write(led, on);  // Every `period` milliseconds\n      on = !on;             // Toggle LED state\n    }\n    // Here we could perform other activities!\n  }\n```\n\nNote that using SysTick, and a helper `timer_expired()` function, we made our\nmain loop (also called superloop) non-blocking. That means that inside that\nloop we can perform many actions - for example, have different timers with\ndifferent periods, and they all will be triggered in time.\n\nA complete project source code you can find in [steps/step-2-systick](steps/step-2-systick) folder.\n\n## Add UART debug output\n\nNow it's time to add a human-readable diagnostics to our firmware. One of the\nMCU peripherals is a serial UART interface. Looking at the datasheet section\n2.3, we see that there are several UART/USART controllers - i.e. pieces of\ncircuitry inside MCU that, properly configured, can exchange data via\ncertain pins. A mimimal UART setup uses two pins, RX (receive) and TX (transmit).\n\nIn a Nucleo board datasheet section 6.9 we see that one of the\ncontrollers, USART3, is using pins PD8 (TX) and PD9 (RX) and is connected to\nthe on-board ST-LINK debugger. That means that if we configure USART3 and\noutput data via the PD9 pin, we can see it on our workstation via the ST-LINK\nUSB connection.\n\nThus, let us create a handy API for the UART, the way we did it for GPIO.\nDatasheet section 30.6 summarises UART registers - so here is our UART struct:\n\n```c\nstruct uart {\n  volatile uint32_t SR, DR, BRR, CR1, CR2, CR3, GTPR;\n};\n#define UART1 ((struct uart *) 0x40011000)\n#define UART2 ((struct uart *) 0x40004400)\n#define UART3 ((struct uart *) 0x40004800)\n```\n\nTo configure UART, we need to:\n- Enable UART clock by setting appropriate bit in `RCC->APB2ENR` register\n- Set \"alternate function\" pin mode for RX and TX pins. There can be several\n  alternate functions (AF) for any given pin, depending on the peripheral that\n  is used. The AF list can be found in the\n  [STM32F429ZI](https://www.st.com/resource/en/datasheet/stm32f429zi.pdf)\n  table 12\n- Set baud rate (receive/transmit clock frequency) via the BRR register\n- Enable the peripheral, receive and transmit via the CR1 register\n\nWe already know how to set a GPIO pin into a specific mode. If a pin is in the\nAF mode, we also need to specify the \"function number\", i.e. which exact\nperipheral takes control. This can be done via the \"alternate function register\",\n`AFR`, of the GPIO peripheral. Reading the AFR register description in the\ndatasheet, we can see that the AF number occupies 4 bits, thus the whole setup\nfor 16 pins occupies 2 registers.\n\n```c\nstatic inline void gpio_set_af(uint16_t pin, uint8_t af_num) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  gpio->AFR[n >> 3] &= ~(15UL << ((n & 7) * 4));\n  gpio->AFR[n >> 3] |= ((uint32_t) af_num) << ((n & 7) * 4);\n}\n```\n\nIn order to completely hide register-specific code from the GPIO API, let's\nmove the GPIO clock init to the `gpio_set_mode()` function:\n\n```c\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  RCC->AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock\n  ...\n```\n\nNow we're ready to create a UART initialization API function:\n\n```c\n#define FREQ 16000000  // CPU frequency, 16 Mhz\nstatic inline void uart_init(struct uart *uart, unsigned long baud) {\n  // https://www.st.com/resource/en/datasheet/stm32f429zi.pdf\n  uint8_t af = 7;           // Alternate function\n  uint16_t rx = 0, tx = 0;  // pins\n\n  if (uart == UART1) RCC->APB2ENR |= BIT(4);\n  if (uart == UART2) RCC->APB1ENR |= BIT(17);\n  if (uart == UART3) RCC->APB1ENR |= BIT(18);\n\n  if (uart == UART1) tx = PIN('A', 9), rx = PIN('A', 10);\n  if (uart == UART2) tx = PIN('A', 2), rx = PIN('A', 3);\n  if (uart == UART3) tx = PIN('D', 8), rx = PIN('D', 9);\n\n  gpio_set_mode(tx, GPIO_MODE_AF);\n  gpio_set_af(tx, af);\n  gpio_set_mode(rx, GPIO_MODE_AF);\n  gpio_set_af(rx, af);\n  uart->CR1 = 0;                           // Disable this UART\n  uart->BRR = FREQ / baud;                 // FREQ is a UART bus frequency\n  uart->CR1 |= BIT(13) | BIT(2) | BIT(3);  // Set UE, RE, TE\n}\n```\n\nAnd, finally, functions for reading and writing to the UART.\nThe datasheet section 30.6.1 tells us that the status register SR tells us\nwhether data is ready:\n```c\nstatic inline int uart_read_ready(struct uart *uart) {\n  return uart->SR & BIT(5);  // If RXNE bit is set, data is ready\n}\n```\n\nThe data byte itself can be fetched from the data register DR:\n```c\nstatic inline uint8_t uart_read_byte(struct uart *uart) {\n  return (uint8_t) (uart->DR & 255);\n}\n```\n\nTransmitting a single byte can be done via the data register too. After\nsetting a byte to write, we need to wait for the transmission to end, indicated\nvia bit 7 in the status register:\n```c\nstatic inline void uart_write_byte(struct uart *uart, uint8_t byte) {\n  uart->DR = byte;\n  while ((uart->SR & BIT(7)) == 0) spin(1);\n}\n```\n\nAnd writing a buffer:\n```c\nstatic inline void uart_write_buf(struct uart *uart, char *buf, size_t len) {\n  while (len-- > 0) uart_write_byte(uart, *(uint8_t *) buf++);\n}\n```\n\nNow, initialise UART in our main() function:\n\n```c\n  ...\n  uart_init(UART3, 115200);              // Initialise UART\n```\n\nNow, we're ready to print a message \"hi\\r\\n\" every time LED blinks!\n```c\n    if (timer_expired(&timer, period, s_ticks)) {\n      ...\n      uart_write_buf(UART3, \"hi\\r\\n\", 4);  // Write message\n    }\n```\n\nRebuild, reflash, and attach a terminal program to the ST-LINK port.\nOn my Mac workstation, I use `cu`. It also can be used on Linux. On Windows,\nusing `putty` utility can be a good idea. Run a terminal and see the messages:\n\n```sh\n$ cu -l /dev/YOUR_SERIAL_PORT -s 115200\nhi\nhi\n```\n\nA complete project source code you can find in [steps/step-3-uart](steps/step-3-uart) folder.\n\n## Redirect printf() to UART\n\nIn this section, we replace `uart_write_buf()` call by `printf()` call, which\ngives us an ability to do formatted output - and increase our abilities to\nprint diagnostic information, implemeting so called \"printf-style debugging\".\n\nA GNU ARM toolchain that we're using comes not only with a GCC compiler and\nother tools, but with a C library called newlib,\nhttps://sourceware.org/newlib. A newlib library was developed by RedHat for\nembedded systems.\n\nIf our firmware calls a standard C library function, for example `strcmp()`,\nthen a newlib code will be added to our firmware by the GCC linker.\n\nSome of the standard C functions that newlib implements, specifically, file\ninput/output (IO) operations, implemented by the newlib is a special fashion: those\nfunctions eventually call a set of low-level IO functions called \"syscalls\".\n\nFor example:\n- `fopen()` eventually calls `_open()`\n- `fread()` eventually calls a low level `_read()`\n- `fwrite()`, `fprintf()`, `printf()` eventually call a low level `_write()`\n- `malloc()` eventually calls `_sbrk()`, and so on.\n\nThus, by modifying a `_write()` syscall, we can redirect\nprintf() to whatever we want. That mechanism is called \"IO retargeting\".\n\nNote: STM32 Cube also uses ARM GCC with newlib, that's why Cube projects\ntypically include `syscalls.c` file.  Other toolchains, like TI's CCS, Keil's\nCC, might use a different  C library with a bit different retargeting\nmechanism. We use newlib, so let's modify `_write()` syscall to print to the\nUART3.\n\nBefore that, let's organise our source code in the following way:\n- move all API definitions to the file `hal.h` (Hardware Abstraction Layer)\n- move startup code to `startup.c`\n- create an empty file `syscalls.c` for newlib \"syscalls\"\n- modify Makefile to add `syscalls.c` and `startup.c` to the build\n\nAfter moving all API definitions to the `hal.h`, our `main.c` file becomes\nquite compact. Note that it does not have any mention of the low-level\nregisters, just a high level API functions that are easy to understand:\n\n```c\n#include \"hal.h\"\n\nstatic volatile uint32_t s_ticks;\nvoid SysTick_Handler(void) {\n  s_ticks++;\n}\n\nint main(void) {\n  uint16_t led = PIN('B', 7);            // Blue LED\n  systick_init(16000000 / 1000);         // Tick every 1 ms\n  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode\n  uart_init(UART3, 115200);              // Initialise UART\n  uint32_t timer = 0, period = 500;      // Declare timer and 500ms period\n  for (;;) {\n    if (timer_expired(&timer, period, s_ticks)) {\n      static bool on;                      // This block is executed\n      gpio_write(led, on);                 // Every `period` milliseconds\n      on = !on;                            // Toggle LED state\n      uart_write_buf(UART3, \"hi\\r\\n\", 4);  // Write message\n    }\n    // Here we could perform other activities!\n  }\n  return 0;\n}\n```\n\nGreat, now let's retarget printf to the UART3. In the empty syscalls.c,\ncopy/paste the following code:\n\n```c\n#include \"hal.h\"\n\nint _write(int fd, char *ptr, int len) {\n  (void) fd, (void) ptr, (void) len;\n  if (fd == 1) uart_write_buf(UART3, ptr, (size_t) len);\n  return -1;\n}\n```\n\nHere we say: if the file descriptor we're writing to is 1 (which is a\nstandard output descriptor), then write the buffer to the UART3. Otherwise,\nignore. This is the essence of retargeting!\n\nRebuilding this firmware results in a bunch of linker errors:\n\n```sh\n../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-sbrkr.o): in function `_sbrk_r':\nsbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk'\ncloser.c:(.text._close_r+0xc): undefined reference to `_close'\nlseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek'\nreadr.c:(.text._read_r+0x10): undefined reference to `_read'\nfstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat'\nisattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty'\n```\n\nSince we've used a newlib stdio function, we need to supply newlib with the\nrest of syscalls. We add a simple stubs that do nothing, with exception  of\n`_sbrk()`. It needs to be implemented, since `printf()` calls `malloc()` which\ncalls `_sbrk()`:\n\n```c\nint _fstat(int fd, struct stat *st) {\n  (void) fd, (void) st;\n  return -1;\n}\n\nvoid *_sbrk(int incr) {\n  extern char _end;\n  static unsigned char *heap = NULL;\n  unsigned char *prev_heap;\n  if (heap == NULL) heap = (unsigned char *) &_end;\n  prev_heap = heap;\n  heap += incr;\n  return prev_heap;\n}\n\nint _close(int fd) {\n  (void) fd;\n  return -1;\n}\n\nint _isatty(int fd) {\n  (void) fd;\n  return 1;\n}\n\nint _read(int fd, char *ptr, int len) {\n  (void) fd, (void) ptr, (void) len;\n  return -1;\n}\n\nint _lseek(int fd, int ptr, int dir) {\n  (void) fd, (void) ptr, (void) dir;\n  return 0;\n}\n```\n\nNow, rebuild gives no errors. Last step: replace the `uart_write_buf()`\ncall in the `main()` function with `printf()` call that prints something\nuseful, e.g. a LED status and a current value of systick:\n\n```c\nprintf(\"LED: %d, tick: %lu\\r\\n\", on, s_ticks);  // Write message\n```\n\nThe serial output looks like this:\n\n```sh\nLED: 1, tick: 250\nLED: 0, tick: 500\nLED: 1, tick: 750\nLED: 0, tick: 1000\n```\n\nCongratulations! We learned how IO retargeting works, and\ncan now printf-debug our firmware.\nA complete project source code you can find in [steps/step-4-printf](steps/step-4-printf) folder.\n\n## Debug with Segger Ozone\n\nWhat if our firmware is stuck somewhere and printf debug does not work?\nWhat if even a startup code does not work? We would need a debugger. There\nare many options, but I'd recommend using an Ozone debugger from Segger.\nWhy? Because it is stand-alone. It does not need any IDE set up. We can\nfeed our `firmware.elf` directly to Ozone, and it'll pick up our source files.\n\nSo, [download Ozone](https://www.segger.com/products/development-tools/ozone-j-link-debugger/)\nfrom the Segger website. Before we can use it with our Nucleo board,\nwe need to convert ST-LINK firmware on the onboard debugger to the jlink firmware\nthat Ozone understands. Follow the [instructions](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/)\non the Segger site.\n\nNow, run Ozone. Choose our device in the wizard:\n\n<img src=\"images/ozone1.png\" width=\"50%\" />\n\nSelect a debugger we're going to use - that should be a ST-LINK:\n\n<img src=\"images/ozone2.png\" width=\"50%\" />\n\nChoose our firmware.elf file:\n\n<img src=\"images/ozone3.png\" width=\"50%\" />\n\nLeave the defaults on the next screen, click Finish, and we've got our\ndebugger loaded (note the hal.h source code is picked up):\n\n![](images/ozone4.png)\n\nClick the green button to download, run the firmware, and we're stopped here:\n\n![](images/ozone5.png)\n\nNow we can single-step through code, set breakpoints, and do the usual debugging\nstuff. One thing that could be noted, is a handy Ozone peripheral view:\n\n![](images/ozone6.png)\n\nUsing it, we can directly examine or set the state of the peripherals. For\nexample, let's turn on a green on-board LED (PB0):\n\n1. We need to clock GPIOB first. Find Peripherals -> RCC -> AHB1ENR,\n   and enable GPIOBEN bit - set it to 1:\n  <img src=\"images/ozone7.png\" width=\"75%\" />\n2. Find Peripherals -> GPIO -> GPIOB -> MODER, set MODER0 to 1 (output): \n  <img src=\"images/ozone8.png\" width=\"75%\" />\n3. Find Peripherals -> GPIO -> GPIOB -> ODR, set ODR0 to 1 (on): \n  <img src=\"images/ozone9.png\" width=\"75%\" />\n\nNow, a green LED should be on! Happy debugging.\n\n## Vendor CMSIS headers\n\nIn the previous sections, we have developed the firmware using only datasheets,\neditor, and GCC compiler. We have created peripheral structure definitions\nmanually, using datasheets.\n\nNow as you know how it all works, it is time to introduce CMSIS headers.\nWhat is it ? These are header files with all definitions, created and supplied\nby the MCU vendor. They contain definitions for everything that MCU contains,\ntherefore they rather big.\n\nCMSIS stands for Common Microcontroller Software Interface Standard, thus it is\na common ground for the MCU manufacturers to specify peripheral API.  Since\nCMSIS is an ARM standard, and since CMSIS headers are supplied by the MCU\nvendor, they are the source of authority. Therefore, using vendor\nheaders is a preferred way, rather than writing definitions manually.\n\nThere are two sets of CMSIS headers:\n- First, there are ARM Core CMSIS headers. They describe ARM core,\n  and published by ARM on github: https://github.com/ARM-software/CMSIS_5\n- Second, there are MCU vendor CMSIS headers. They describe MCU peripherals,\n  and published by the MCU vendor. In our case, ST publishes them at\n  https://github.com/STMicroelectronics/cmsis_device_f4\n\nWe can pull those headers by a simple Makefile snippet:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/785aa2ead0432fc67327781c82b9c41149fba158/step-5-cmsis/Makefile#L27-L31\n\nThe ST CMSIS package also provides startup files for all their MCUs. We\ncan use those instead of hand-writing the startup.c. The ST-provided startup\nfile calls `SystemInit()` function, so we define it in the `main.c`.\n\nNow, let's replace our API functions in the `hal.h` using CMSIS definitions,\nand leave the rest of the firmware intact.  From the `hal.h`, remove all\nperipheral API and definitions, and leave only standard C inludes, vendor CMSIS\ninclude, defines to PIN, BIT, FREQ, and `timer_expired()` helper function.\n\nIf we try to rebuild the firmware - `make clean build`, then GCC will fail\ncomplaining about missing `systick_init()`, `GPIO_MODE_OUTPUT`, `uart_init()`,\nand `UART3`. Let's add those using STM32 CMSIS files.\n\nLet's start from `systick_init()`. ARM core CMSIS headers provide a\n`SysTick_Config()` function that does the same - so we'll use it.\n\nNext goes `gpio_set_mode()` function. The  `stm32f429xx.h` header has\n`GPIO_TypeDef` structure, identical to our `struct gpio`. Let's use it:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/52e1a8acd30e60eba4c119e22b609571e39a86e0/step-5-cmsis/hal.h#L24-L28\n\nThe `gpio_set_af()` and `gpio_write()` functions is also trivial -\nsimply replace `struct gpio` with `GPIO_TypeDef`, and that's all.\n\nNext goes UART. There is a `USART_TypeDef`, and defines for  USART1, USART2,\nUSART3. Let's use them:\n\n```c\n#define UART1 USART1\n#define UART2 USART2\n#define UART3 USART3\n```\n\nIn the `uart_init()` and the rest of UART functions, change `struct uart` to\n`USART_TypeDef`. The rest stays the same!\n\nAnd we are done. Rebuild, reflash the firmware. The LED blinks, the UART\nshows the output. Congratulations, we have adopted our firmware code to\nuse vendor CMSIS header files. Now let's reorganise the repository a bit\nby moving all standard files into `include` directory and updating Makefile\nto let GCC know about it:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/785aa2ead0432fc67327781c82b9c41149fba158/step-5-cmsis/Makefile#L4\n\nAlso, let's include CMSIS header pulling as a dependency for the binary:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/785aa2ead0432fc67327781c82b9c41149fba158/step-5-cmsis/Makefile#L18\n\nWe have left with a project template that can be reused for the future\nprojects.  A complete project source code you can find in\n[steps/step-5-cmsis](steps/step-5-cmsis)\n\n\n## Setting up clocks\n\nAfter boot, Nucleo-F429ZI CPU runs at 16MHz. The maximum frequency is 180MHz.\nNote that system clock frequency is not the only factor we need to care about.\nPeripherals are attached to different buses, APB1 and APB2 which are clocked\ndifferently.  Their clock speeds are configured by the frequency prescaler\nvalues, set in the RCC. The main CPU clock source can also be\ndifferent - we can use either an external crystal oscillator (HSE) or an\ninternal oscillator (HSI). In our case, we'll use HSI.\n\nWhen CPU executes instructions from flash, a flash read speed (which is around\n25MHz) becomes a bottleneck if CPU clock gets higher. There are several tricks\nthat can help. Instruction prefetch is one. Also, we can give a clue to the\nflash controller, how faster the system clock is: that value is called flash\nlatency. For 180MHz system clock, the `FLASH_LATENCY` value is 5. Bits 8 and 9\nin the flash controller enable instruction and data caches:\n\n```c\n  FLASH->ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches\n```\n\nThe clock source (HSI or HSE) goes through a piece of hardware called\nPLL, which multiplies source frequency by a certain value. Then, a set of\nfrequency dividers are used to set the system clock and APB1, APB2 clocks.\nIn order to obtain the maximum system clock of 180MHz, multiple values\nof PLL dividers and APB prescalers are possible. Section 6.3.3 of the\ndatasheet tells us the maximum values for APB1 clock: <= 45MHz,\nand the APB2 clock: <= 90MHz. That narrows down the list of possible\ncombinations. Here we chose the values manually. Note that tools like\nCubeMX can automate the process and make it easy and visual.\n\nhttps://github.com/cpq/bare-metal-programming-guide/blob/9a3f9bc7b07d6a2a114581979e5b6715754c87c1/step-6-clock/hal.h#L20-L28\n\nNow we're ready for a simple algorithm to set up the clock for CPU and peripheral buses\nmay look like this:\n\n- Optionally, enable FPU\n- Set flash latency\n- Decide on a clock source, and PLL, APB1 and APB2 prescalers\n- Configure RCC by setting respective values:\n- Move clock inititialization into a separate file `sysinit.c`, function\n  `SystemInit()` which is automatically called by the startup code\n\nhttps://github.com/cpq/bare-metal-programming-guide/blob/9a3f9bc7b07d6a2a114581979e5b6715754c87c1/step-6-clock/sysinit.c#L10-L26\n\nWe need to also change `hal.h` - specifically, the UART intialization code.\nDifferent UART controllers are running on different buses: UART1 runs on a\nfast APB2, and the rest of UARTs run on a slower APB1. When running on a\ndefault 16Mhz clock, that did not make a difference. But when running on\nhigher speeds, APB1 and APB2 may have different clocks, thus we need to\nadjust the baud rate calculation for the UART:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/9a3f9bc7b07d6a2a114581979e5b6715754c87c1/step-6-clock/hal.h#L90-L107\n\nRebuild and reflash, and our board runs at its maximum speed, 180MHz!\nA complete project source code you can find in [steps/step-6-clock](steps/step-6-clock)\n\n## Web server with device dashboard\n\nThe Nucleo-F429ZI comes with Ethernet on-board. Ethernet hardware needs\ntwo components: a PHY (which transmits/receives electrical signals to the\nmedia like copper, optical cable, etc) and MAC (which drives PHY controller).\nOn our Nucleo, the MAC controller is built-in, and the PHY is external\n(specifically, it is Microchip's LAN8720a).\n\nMAC and PHY can talk several interfaces, we'll use RMII. For that, a bunch\nof pins must be configured to use their Alternative Function (AF).\nTo implement a web server, we need 3 software components:\n- a network driver, which sends/receives Ethernet frames to/from MAC controller\n- a network stack, that parses frames and understands TCP/IP\n- a network library that understands HTTP\n\nWe will use [Mongoose Network Library](https://github.com/cesanta/mongoose)\nwhich implements all of that in a single file. It is a dual-licensed library\n(GPLv2/commercial) that was designed to make network embedded development\nfast and easy.\n\nSo, copy\n[mongoose.c](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c)\nand\n[mongoose.h](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h)\nto our project. Now we have a driver, a network stack, and a library at hand.\nMongoose also provides a large set of examples, and one of them is a\n[device dashboard example](https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard).\nIt implements lots of things - like dashboard login, real-time data exchange\nover WebSocket, embedded file system, MQTT communication, etcetera.  So let's\nuse that example. Copy two extra files:\n- [net.c](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/net.c) - implements dashboard functionality\n- [packed_fs.c](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/packed_fs.c) - contains HTML/CSS/JS GUI files\n\nWhat we need is to tell Mongoose which functionality to enable. That can\nbe done via compilation flags, by setting preprocessor constants. Alternatively,\nthe same constants can be set in the `mongoose_custom.h` file. Let's go\nthe second way. Create `mongoose_custom.h` file with the following contents:\n\n```c\n#pragma once\n#define MG_ARCH MG_ARCH_NEWLIB\n#define MG_ENABLE_MIP 1\n#define MG_ENABLE_PACKED_FS 1\n#define MG_IO_SIZE 512\n#define MG_ENABLE_CUSTOM_MILLIS 1\n```\n\nNow it's time to add some networking code to main.c. We `#include \"mongoose.c\"`,\ninitialise Ethernet RMII pins and enable Ethernet in the RCC:\n\n```c\n  uint16_t pins[] = {PIN('A', 1),  PIN('A', 2),  PIN('A', 7),\n                     PIN('B', 13), PIN('C', 1),  PIN('C', 4),\n                     PIN('C', 5),  PIN('G', 11), PIN('G', 13)};\n  for (size_t i = 0; i < sizeof(pins) / sizeof(pins[0]); i++) {\n    gpio_init(pins[i], GPIO_MODE_AF, GPIO_OTYPE_PUSH_PULL, GPIO_SPEED_INSANE,\n              GPIO_PULL_NONE, 11);\n  }\n  nvic_enable_irq(61);                          // Setup Ethernet IRQ handler\n  RCC->APB2ENR |= BIT(14);                      // Enable SYSCFG\n  SYSCFG->PMC |= BIT(23);                       // Use RMII. Goes first!\n  RCC->AHB1ENR |= BIT(25) | BIT(26) | BIT(27);  // Enable Ethernet clocks\n  RCC->AHB1RSTR |= BIT(25);                     // ETHMAC force reset\n  RCC->AHB1RSTR &= ~BIT(25);                    // ETHMAC release reset\n```\n\nMongoose's driver uses Ethernet interrupt, thus we need to update `startup.c`\nand add `ETH_IRQHandler` to the vector table. Let's reorganise vector table\ndefinition in `startup.c` in a way that does not require any modification\nto add an interrupt handler function. The idea is to use a \"weak symbol\"\nconcept.\n\nA function can be marked \"weak\" and it works like a normal function.  The\ndifference comes when a source code defines a function with the same name\nelsewhere. Normally, two functions with the same name make a build fail.\nHowever if one function is marked weak, then a build succeeds and linker\nselects a non-weak function. This gives an ability to provide a \"default\"\nfunction in a boilerplate, with an ability to override it by simply creating a\nfunction with the same name elsewhere in the code.\n\nHere how it works in our case. We want to fill a vector table with default\nhandlers, but give user an ability to override any handler. For that, we create\na function `DefaultIRQHandler()` and mark it weak. Then, for every IRQ handler,\nwe declare a handler name and make it an alias to `DefaultIRQHandler()`:\n\n```c\nvoid __attribute__((weak)) DefaultIRQHandler(void) {\n  for (;;) (void) 0;\n}\n#define WEAK_ALIAS __attribute__((weak, alias(\"DefaultIRQHandler\")))\n\nWEAK_ALIAS void NMI_Handler(void);\nWEAK_ALIAS void HardFault_Handler(void);\nWEAK_ALIAS void MemManage_Handler(void);\n...\n__attribute__((section(\".vectors\"))) void (*const tab[16 + 91])(void) = {\n    0, _reset, NMI_Handler, HardFault_Handler, MemManage_Handler,\n    ...\n```\n\nNow, we can define any IRQ handler in our code, and it will replace the default\none. This is what happens in our case: there is a `ETH_IRQHandler()` defined\nby the Mongoose's STM32 driver which replaces a default handler.\n\nThe next step is to initialise Mongoose library: create an event manager,\nsetup network driver, and start a listening HTTP connection:\n\n```c\n  struct mg_mgr mgr;        // Initialise Mongoose event manager\n  mg_mgr_init(&mgr);        // and attach it to the MIP interface\n  mg_log_set(MG_LL_DEBUG);  // Set log level\n\n  struct mip_driver_stm32 driver_data = {.mdc_cr = 4};  // See driver_stm32.h\n  struct mip_if mif = {\n      .mac = {2, 0, 1, 2, 3, 5},\n      .use_dhcp = true,\n      .driver = &mip_driver_stm32,\n      .driver_data = &driver_data,\n  };\n  mip_init(&mgr, &mif);\n  extern void device_dashboard_fn(struct mg_connection *, int, void *, void *);\n  mg_http_listen(&mgr, \"http://0.0.0.0\", device_dashboard_fn, &mgr);\n  MG_INFO((\"Init done, starting main loop\"));\n```\n\nWhat is left, is to add a `mg_mgr_poll()` call into the main loop.\n\nNow, add `mongoose.c`, `net.c` and `packed_fs.c` files to the Makefile.\nRebuild, reflash the board.  Attach a serial console to the debug output,\nobserve that the board obtains an IP address over DHCP:\n\n```\n847 3 mongoose.c:6784:arp_cache_add     ARP cache: added 0xc0a80001 @ 90:5c:44:55:19:8b\n84e 2 mongoose.c:6817:onstatechange     READY, IP: 192.168.0.24\n854 2 mongoose.c:6818:onstatechange            GW: 192.168.0.1\n859 2 mongoose.c:6819:onstatechange            Lease: 86363 sec\nLED: 1, tick: 2262\nLED: 0, tick: 2512\n```\n\nFire up a browser at that IP address, and get a working dashboard, with\nreal-time graph over WebSocket, with MQTT, authentication, and other things!\nSee\n[full description](https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard)\nfor more details.\n\n![Device dashboard](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/screenshots/dashboard.png)\n\nA complete project source code you can find in\n[steps/step-7-webserver](steps/step-7-webserver) directory.\n\n## Automated firmware builds (software CI)\n\nIt is a good practice for a software project to have continuous\nintegration (CI). On every change pushed to the\nrepository, CI automatically rebuilds and tests all components.\n\nGithub makes it easy to do. We can create a `.github/workflows/test.yml` file\nwhich is a CI configuration file. In that file, we can install ARM GCC\nand run `make` in every example directory to build respective firmwares.\n\nLong story short! This tells Github to run on every repo push:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/b0820b5c62b74a9b4456854feb376cda8cde4ecd/.github/workflows/test.yml#L1-L2\n\nThis installs ARM GCC compiler:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/b0820b5c62b74a9b4456854feb376cda8cde4ecd/.github/workflows/test.yml#L9\n\nThis builds a firmware in every example directory:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/b0820b5c62b74a9b4456854feb376cda8cde4ecd/.github/workflows/test.yml#L10-L18\n\nThat's it!  Extremely simple and extremely powerful. Now if we push a change to\nthe repo which breaks a build, Github will notify us. On success, Github will\nkeep quiet.  See an [example successful\nrun](https://github.com/cpq/bare-metal-programming-guide/actions/runs/3840030588).\n\n\n## Automated firmware tests (hardware CI)\n\nWould it be great to also test built firmware binaries on a real hardware, to\ntest not only the build process, but that the built firmware is correct and\nfunctional?\n\nIt is not trivial to build such a system ad hoc. For example,\none can setup a dedicated test workstation, attach a tested device\n(e.g. Nucleo-F429ZI board) to it, and write a piece of software for remote\nfirmware upload and test using a built-in debugger. Possible, but fragile,\nconsumes a lot of efforts and needs a lot of attention.\n\nThe alternative is to use one of the commercial hardware test systems (or EBFs,\nEmbedded Board Farms), though such commercial solutions are quite expensive. \n\nBut there is an easy way.\n\n### Solution: ESP32 + vcon.io\n\nUsing https://vcon.io service, which implements remote firmware update and\nUART monitor, we can:\n\n1. Take any ESP32 or ESP32C3 device (e.g. any inexpensive development board)\n2. Flash a pre-built firmware on it, turning ESP32 into a remotely-controlled programmer\n3. Wire ESP32 to your target device: SWD pins for flashing, UART pins for capturing output\n4. Configure ESP32 to register on https://dash.vcon.io management dashboard\n\nWhen done, your target device will have an authenticated, secure RESTful\nAPI for reflashing and capturing device output. It can be called from anywhere,\nfor example from the software CI:\n\n![VCON module operation](images/hero.svg)\n\nNote: the [vcon.io](https://vcon.io) service is run by Cesanta - the company I\nwork for. It is a paid service with a freebie quota: if you have just a few\ndevices to manage, it is completely free.\n\n### Configuring and wiring ESP32\n\nTake any ESP32 or ESP32C3 device - a devboard, a module, or your custom device.\nMy recommendation is ESP32C3 XIAO devboard\n([buy on Digikey](https://www.digikey.ie/en/products/detail/seeed-technology-co-ltd/113991054/16652880))\nbecause of its low price (about 5 EUR) and small form factor.\n\nWe're going to assume that the target device is a Raspberry Pi\n[W5500-EVB-Pico](https://docs.wiznet.io/Product/iEthernet/W5500/w5500-evb-pico)\nboard with a built-in Ethernet interface. If your device is different,\nadjust the \"Wiring\" step according to your device's pinout.\n\n- Follow [Flashing ESP32](https://vcon.io/docs/#module-flashing) to flash your ESP32\n- Follow [Network Setup](https://vcon.io/docs/#module-registration) to register ESP32 on https://dash.vcon.io\n- Follow [Wiring](https://vcon.io/docs/#module-to-device-wiring) to wire ESP32 to your device\n\nThis is how a configured device breadboard setup may look like:\n![](images/breadboard.webp)\n\nThis is how a configured device dashboard looks like:\n![](images/screenshot.webp)\n\nNow, you can reflash your device with a single command:\n\n```sh\ncurl -su :API_KEY https://dash.vcon.io/api/v3/devices/ID/ota --data-binary @firmware.bin\n```\n\nWhere `API_KEY` is the dash.vcon.io authentication key, `ID` is the registered\ndevice number, and `firmware.bin` is the name of the newly built firmware.  You\ncan get the `API_KEY` by clicking on the \"api key\" link on a dashboard.  The\ndevice ID is listed in the table.\n\nWe can also capture device output with a single command: \n\n```sh\ncurl -su :API_KEY https://dash.vcon.io/api/v3/devices/ID/tx?t=5\n```\n\nThere, `t=5` means wait 5 seconds while capturing UART output.\n\nNow, we can use those two commands in any software CI platform to test a new\nfirmware on a real device, and test device's UART output against some expected\nkeywords. \n\n### Integrating with Github Actions\n\nOkay, our software CI builds a firmware image for us. It would be nice to\ntest that firmware image on a real hardware. And now we can!\nWe should add few extra commands that use `curl` utility to send a built\nfirmware to the test board, and then capture its debug output.\n\nA `curl` command requires a secret API key, which we do not want to expose to\nthe public. The right way to go is to:\n1. Go to the project settings / Secrets / Actions\n2. Click on \"New repository secret\" button\n3. Give it a name, `VCON_API_KEY`, paste the value into a \"Secret\" box, click \"Add secret\"\n\nOne of the example projects builds firmware for the RP2040-W5500 board, so\nlet's flash it using a `curl` command and a saved API key. The best way is\nto add a Makefile target for testing, and let Github Actions (our software CI)\ncall it:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/8d419f5e7718a8dcacad2ddc2f899eb75f64271e/.github/workflows/test.yml#L18\n\nNote that we pass a `VCON_API_KEY` environment variable to `make`. Also note\nthat we're invoking `test` Makefile target, which should build and test our\nfirmware. Here is the `test` Makefile target:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/d9bced31b1ccde8eca4d6dc38440e104dba053ce/step-7-webserver/pico-w5500/Makefile#L32-L39\n\nExplanation:\n- line 34: The `test` target depends on the `upload` target, so `upload`\n  is executed first (see line 38)\n- line 35: Capture UART log for 5 seconds and save it to `/tmp/output.txt`\n- line 36: Search for the string `Ethernet: up` in the output, and fail if it\n  is not found\n- line 38: The `upload` target depends on `build`, so we always build firmware\n  before testing\n- line 39: We flash firmware remotely. The `--fail` flag to `curl` utility\n  makes it fail if the response from the server is not successful (not HTTP 200\n  OK)\n\nThis is the example output of the `make test` command described above:\n\n```sh\n$ make test\ncurl --fail ...\n{\"success\":true,\"written\":59904}\ncurl --fail ...\n3f3 2 main.c:65:main                    Ethernet: down\n7d7 1 mongoose.c:6760:onstatechange     Link up\n7e5 3 mongoose.c:6843:tx_dhcp_discover  DHCP discover sent\n7e8 2 main.c:65:main                    Ethernet: up\n81d 3 mongoose.c:6726:arp_cache_add     ARP cache: added 192.168.0.1 @ 90:5c:44:55:19:8b\n822 2 mongoose.c:6752:onstatechange     READY, IP: 192.168.0.24\n827 2 mongoose.c:6753:onstatechange            GW: 192.168.0.1\n82d 2 mongoose.c:6755:onstatechange            Lease: 86336 sec\nbc3 2 main.c:65:main                    Ethernet: up\nfab 2 main.c:65:main                    Ethernet: up\n```\n\nDone! Now, our automatic tests ensure that the firmware can be built, that\nit is bootable, that it initialises the network stack correctly.  This mechanism\ncan be easily extended: just add more complex actions in your firmware binary,\nprint the result to the UART, and check for the expected output in the test.\n\nHappy testing!\n\n## About me\n\nI am Sergey Lyubka, an engineer and entrepreneur. I hold a MSc in Physics from\nKyiv State University, Ukraine. I am a director and co-founder at Cesanta - a\ntechnology company based in Dublin, Ireland. Cesanta develops embedded solutions:\n- https://mongoose.ws - an open source HTTP/MQTT/Websocket network library\n- https://vcon.io - a remote firmware update / serial monitor framework\n\nYou are welcome\nto [register for my free webinar on embedded network programming](https://mongoose.ws/webinars/).\n"
        },
        {
          "name": "README_tr-TR.md",
          "type": "blob",
          "size": 80.658203125,
          "content": "# Sıfırdan programlamaya başlangıç rehberi\n\n[![Lisans: MIT](https://img.shields.io/badge/license-MIT-blue)](https://opensource.org/licenses/MIT)\n[![Build Status](https://github.com/cpq/bare-metal-programming-guide/workflows/build/badge.svg)](https://github.com/cpq/bare-metal-programming-guide/actions)\n\n[English](README.md) | [中文](README_zh-CN.md) | Türkçe\n\nBu rehber herhangi bir framework kullanmadan sadece GCC derleyicisi ve datasheet kullanarak mikrodenetleyici programlamayı arzulayan geliştiriciler için yazılmıştır. Rehber, Cuce, Keil, Arduino gibi araçların temelinde nasıl çalıştığını ana hatlarıyla açıklamayı amaçlamaktadır.\n\nBu rehberdeki her bölüm, işlevsellik ve eksiksizlik açısından kademeli olarak ilerleyen kaynakları içerir. Özetle, farklı mimarilerdeki projeleri sıfırdan anlatacağız.\n\n- **blinky** - En klasiklerden biri olan LED yakma ve düzenli olarak debug mesajı yazmak\n- **cli** - UART komut satırı arayüzü. LED durumunu ve RAM'in hexdump'ını alan komutları implemente eder.\n- **lfs** - Flash memory'nin üst bölümüne [littlefs](https://github.com/littlefs-project/littlefs) kullanarak `mkdir(),readdir(),fopen()` gibi fonksiyonları implemente eder. Cihaz boot sayısını bir dosyada tutar, her boot'ta arttırır ve düzenli olarak yazdırır.\n- **webui** - [mongoose library](https://github.com/cesanta/mongoose) sayesinde profesyönel bir cihaz arayüzü sunan gömülü web sunucusu\n\n| Kart                | Arch       | MCU datasheet                                                                                                                                                                                 | Board datasheet                                                                                                               | Örnek proje                                                                                                                  |\n| ------------------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\n| STM32 Nucleo-F429ZI | Cortex-M4  | [mcu datasheet](https://www.st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf) | [board datasheet](https://www.st.com/resource/en/user_manual/dm00244518-stm32-nucleo144-boards-mb1137-stmicroelectronics.pdf) | [blinky](templates/blinky/nucleo-f429zi), [cli](templates/cli/nucleo-f429zi), [webui](steps/step-7-webserver/nucleo-f429zi/) |\n| STM32 Nucleo-F303K8 | Cortex-M4  | [mcu datasheet](https://www.st.com/resource/en/reference_manual/DM00043574-.pdf)                                                                                                              | [board datasheet](https://www.st.com/resource/en/datasheet/stm32f303k8.pdf)                                                   | [lfs](templates/lfs/nucleo-f303k8)                                                                                           |\n| STM32 Nucleo-L432KC | Cortex-M4  | [mcu datasheet](https://www.st.com/resource/en/reference_manual/dm00151940-stm32l41xxx42xxx43xxx44xxx45xxx46xxx-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)                          | [board datasheet](https://www.st.com/resource/en/datasheet/stm32l432kc.pdf)                                                   | [blinky](templates/blinky/nucleo-l432kc), [cli](templates/cli/nucleo-l432kc), [lfs](templates/lfs/nucleo-l432kc)             |\n| TI EK-TM4C1294XL    | Cortex-M4F | [mcu datasheet](https://www.ti.com/lit/ds/symlink/tm4c1294ncpdt.pdf)                                                                                                                          | [board datasheet](https://www.ti.com/lit/ug/spmu365c/spmu365c.pdf)                                                            | [webui](steps/step-7-webserver/ek-tm4c1294xl)                                                                                |\n| RP2040 Pico-W5500   | Cortex-M0+ | [mcu datasheet](https://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf)                                                                                                               | [board datasheet](https://docs.wiznet.io/Product/iEthernet/W5500/w5500-evb-pico)                                              | [webui](steps/step-7-webserver/pico-w5500/)                                                                                  |\n| ESP32-C3            | RISCV      | [mcu datasheet](https://www.espressif.com/sites/default/files/documentation/esp32-c3_technical_reference_manual_en.pdf)                                                                       |                                                                                                                               | [blinky](templates/blinky/esp32-c3)                                                                                          |\n\nBu öğreticide **Nucleo-F429ZI** geliştirme kartını kullanacağız bu yüzden mikrodenetleyicinin ve kartın datasheet'lerini indirmeyi unutmayın.\n\n## Hakkımda\n\nBen Sergey Lyubka, mühendis ve girişimciyim. Ukrayna Kyiv State üniversitesinde fizik lisansı yapıyorum . İrlanda Dublin merkezli Cesanata teknoloji şirketinin kurucu ortağı ve yöneticisiyim. Cesanata'nın geliştirdiği bazı gömülü çözümler:\n\n- https://mongoose.ws - açık kaynaklı HTTP/MQTT/Websocket ağ kütüphanesi\n- https://vcon.io - uzaktan firmware güncelleme ve serial monitoring framework'ü\n\nGömülü ağ programlama konusundaki [ücretsiz web seminerime](https://mongoose.ws/webinars/) davetlisiniz.\n\n## Araçların kurulumu\n\nÇalışmalara devam edebilmek için şunlar gereklidir :\n\n- ARM GCC, https://launchpad.net/gcc-arm-embedded - derleme ve link'leme için\n- GNU make, http://www.gnu.org/software/make/ - derlemeyi otomatik hale getirmek için\n- ST link, https://github.com/stlink-org/stlink - Flash'lama için\n- Git, https://git-scm.com/ - Kodları indirmek ve versiyon kontrolü için\n\n### Mac için kurulum aşamaları\n\nTerminalinizi açın ve şu komutu çalıştırın:\n\n```sh\n$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n$ brew install gcc-arm-embedded make stlink git\n```\n\n### Linux (Ubuntu) için kurulum aşamaları\n\nTerminalinizi açın ve şu komutu çalıştırın:\n\n```sh\n$ sudo apt -y update\n$ sudo apt -y install gcc-arm-none-eabi make stlink-tools git\n```\n\n### Windows için kurulum aşamaları\n\n- İndirin ve kurun [gcc-arm-none-eabi-10.3-2021.10-win32.exe](https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C). Kurulum sırasında \"Path ekle\" seçeneğini aktifleştirin.\n- `c:\\tools` klasörünü oluşturun.\n- [stlink-1.7.0-x86_64-w64-mingw32.zip](https://github.com/stlink-org/stlink/releases/download/v1.7.0/stlink-1.7.0-x86_64-w64-mingw32.zip) indirin ve `bin/st-flash.exe` dosyasını `c:\\tools` içine çıkartın.\n- [make-4.4-without-guile-w32-bin.zip](https://sourceforge.net/projects/ezwinports/files/make-4.4-without-guile-w32-bin.zip/download) indirin ve `bin/make.exe` dosyasını `c:\\tools` içine çıkartın.\n- `c:\\tools` klasörünü `Path` ortam değişkenine ekleyin.\n- Windows 10/11 için \"Geliştirici Ayarları\"ndan \"Simbiyotik link ekleme\" özelliğini açın.\n- Git'i https://git-scm.com/download/win adresinden indirin. \"symlink aktifleştir / Enable symlink\" seçeneğini işaretleyin.\n\n### Yüklenmiş araçların kontrolü\n\nAn itibariyle tüm gerekli araçlar yüklendi, terminali ya da komut istemcisini açın ve aşağıdaki komutla bu projeyi indirin ve örneği derleyin.\n\n```sh\ngit clone https://github.com/cpq/bare-metal-programming-guide\ncd bare-metal-programming-guide/steps/step-0-minimal\nmake\n```\n\n## Giriş\n\nmikrodenetleyiciler (uC, veya MCU) özünde küçük bilgisayarlardır. Genellikle CPU, RAM,\nkodun yükleneceği flash ve bir avuç pin içerirler. Bazı pinler kontrolcüye güç sağlamak\niçin kullanılır, bunlar çoğunlukla GND (topraklama) ve VCC pini olarak işaretlenir.\nDiğer pinler ise yüksek(high) ve alçak(low) voltaj vererek kontrolcü ile haberleşmek\niçin kullanılır. Haberleşmeden kastedilenlerden en basiti LED yakmaktır. LED'in\nbir ayağı GND'ye diğer ayağı ise akım sınırlayıcı direnciyle birlikte bir sinyal\npinine takılır. Yazılım sinyal pinini low ve high yaparak LED'i yakıp söndürür.\n\n<img src=\"images/mcu.svg\" height=\"200\" />\n\n### Bellek ve register'lar\n\nKontrolcü 32-bit'lik adreslenebilir bölge(region)'lere bölünmüştür. Mesela bazı\nbellek bölümleri kontrolcünün dahili flash'ının spesifik adresleri ile eşlenmiştir.\nFirmware kodu bu bölgeyi kullanarak komutları okur ve çalıştırır. Diğer bir bölüm\nise başka bir spesifik adresle eşlenmiş olan RAM'dir. RAM bölgesine istediğimiz\nherhangi bir değeri okuyup yazabiliriz.\n\nSTM32F429 datasheet'inin 2.3.1 bölümünü incelediğimizde RAM'in 0x20000000 adresinden\nbaşladığını ve 192KB genişliği bulunduğunu anlarız. 2.4 numaralı bölümde flash'ın ise\n0x08000000 adresi ile eşlendiğini görebiliriz. mikrodenetleyicimiz 2MB'lık flash'a\nsahip olduğuna göre RAM bölgesi şöyle konumlandırılmıştır:\n\n<img src=\"images/mem.svg\" />\n\nDatasheet'te baktığımızda bunlardan daha fazla bellek bölgesi olduğunu da fark ederiz\n2.3 numaralı \"Memmory Map\" bölümünde bunların adres aralıkları verilmiştir. Örnek olarak\n\"GPIOA\" bölgesi 0x40020000 adresinden başlayım 1KB uzunluğa sahiptir.\n\nBu bellek bölgeleri, MCU içindeki farklı \"çevre birimlerine\" karşılık gelir\n\n- belirli pinlerin özel bir şekilde davranmasını sağlayan devrelerdir.\n  Çevresel bellek bölgesi, 32 bitlik register'lardan oluşur.Her register,\n  belirli bir adresteki 4 byte'lık hafızayla çevre biriminin belirli bir özelliği\n  ile eşleşir Veriler bu adreslere yazılır. Bir başka deyişle verilen adres aralığına\n  32 bit yazarak çevre birimine istediğimizi yaptırabiliriz. Register'ları okuyarak\n  da çevre biriminin konfigrasyonunu veya gönderdiği veriyi elde edebiliriz.\n\nBirden fazla çevre birimi bulunmaktadır. Bunlardan en basiti MCU'nun pinlerini\n\"output mode\"(çıktı modu) olarak ayarlayıp pine high veya low voltaj vermemizi\nveya \"input mode\"(girdi modu) olarak ayarlayıp pine uygulanan voltajı okumamızı\nsağlayan GPIO(genen amaçlı girdi çıktı)'dur. Seri haberleşme protokolünü kullanarak\nsadece iki pin ile seri veri almamıza(recive) ve iletmemize(transmit) olanak sağlayan\nUART çevre birimi de örnek verilebilir. Bunlar dışındada birsürü birim vardır.\n\nSıklıkla çevre birimlerinin birden fazla örneği,varyasyonu bulunur. Mesela,\nGPIOA, GPIOB MCU'nun farklı pinlerini kontrol ederler. Aynı şekilde UART1, UART2 de\nfarklı UART kanallarını implemente ederler.Nucleo-F429'de, birden fazla GPIO and UART\nçevre birimi bulunur.\n\nGPIOA 0x40020000 adresinden başlar,bölüm 8.4'te GPIO register'larının açıklamalarına ulaşabilirsiniz\nDatasheet'in söylediğine göre `GPIOA_MODER` register'ının offset'i 0'dır,bunun anlamı\nregister'ın adresi `0x40020000 + 0`'dir ve register'ın formatı şu şekildedir:\n\n<img src=\"images/moder.png\" style=\"max-width: 100%\" />\n\nDatasheet'te 32-bit MODER register'larının toplamda 16 olacak şekilde 2-bit'lik veriler\ntuttuğunu görebilirsiniz. Öyleyse bir MODER register'ı 0.pin için 0 ve 1 bitleri,\n1.pin için 2 ve 3 bitleri şeklinde devam ederek 16 fiziksel pini kontrol edebilir.\n2 bitlik pinin modununa göre 0 girdiyi(input), 1 çıktıyı(output), 2 özel fonksiyonu\n(alternate function) -başka bir yerde açıklanan özel işlev- ve 3 ise analog modu ifade eder.\nPinler ise bulunduğu bölgeye uygun yani GPIOA için \"A0\", \"A1\" veya GPIOB için \"B0\", \"B1\" şeklinde\nadlandırılırlar.\n\nEğer MODER register'ına 32 bit boyunca `0` değerini yazarsak A0'dan A15'e kadar 16 pini de\ninput moduna göre ayarlamış oluruz.\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) = 0;  // A0-A15 arasını input olarak ata\n```\n\n`volatile` anahtar kelimesini aklınızda tutun bunun anlamına daha sonra değineceğiz.Bitleri\ntek tek değiştirerek sadece istediğimiz pinlere mod atayabiliriz. Örnek olarak A3 pinini \"output\"\nolarak ayarlayalım.\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // 6-7 aralığını temizle\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // 6-7 aralığını 1 ata\n```\n\nGelin bu bit işlemlerini birlikte inceleyelim. Amacımız, GPIOA çevre biriminin 3.pininden sorumlu olan\nbit 6-7'yi belirli bir değere (bizim durumumuzda 1) olacak şekilde atamaktır. Bu işlem iki adımda yapılır.\nİlk olarak, 6-7 bitlerinin mevcut değerini silmeliyiz, çünkü daha önceden içinde tuttuğu değer işimizi bozabilir.\nArdından 6-7 bitlerini istediğimiz değere ayarlamalıyız.\n\nBundan dolayı,ilk önce 6. ve 7. bitleri 0 yapmalıyız.Peki bir sayının belirli bitlerini nasıl sıfır yaparız?\nDört adımla şöyle:\n\n| İşlem                                               | İfade            | Bitler (32 bitin ilk 12'si) |\n| --------------------------------------------------- | ---------------- | --------------------------- |\n| N tane yan yana biti alın: `2^N-1`, N=2             | `3`              | `000000000011`              |\n| O sayıyı X kere sola kaydırın                       | `(3<<6)`         | `000011000000`              |\n| Sayıyı tersleyin: Birler sıfır, sıfırlar bir olacak | `~(3<<6)`        | `111100111111`              |\n| Sayıyı bitsel VE(AND) işlemine tabi tutun           | `VAL &= ~(3<<6)` | `xxxx00xxxxxx`              |\n\nSon adımı aklınızda tutun, bitsel AND işlemi X yerindeki N tane biti sıfırlar\n(çünkü 0 ile AND'lendi) ama geri kalan bitlere dokunmaz(çünkü 1 ile AND'lendi.\nKendisi neyse yeni değeri de o kalacak). Kalan verilere dokunulmaması çok önemlidir çünkü iki\nveriyi değiştirmek isterken önceden atanan diğer verileri değiştirmek sistemimizi bozacaktır.\nÖzetle X pozisyonundaki N tane biti sıfırlamak istiyorsanız yapmanız gereken şudur:\n\n```c\nREGISTER &= ~((2^N - 1) << X);\n```\n\nVe artık istediğimiz register ile veriyi birleştirebiliriz. Maskeyi X kere sola kaydırıp register ile OR işlemine tabi tutuyoruz. (OR işlemiyle geri kalan veriler bozulmadan sadece 1 yaptığımız alanları oraya işleyebiliriz)\n\n```c\nREGISTER |= VALUE << X;\n```\n\n## Okunaklı çevre birlimi programlama\n\nBir önceki bölümde çevre birimi register'ına doğrudan adresine erişerek okuma\nve yazma yapmayı öğrenmiştik. Gelin bu A3 pinini output moduna alan kodu birlikte\ninceleyelim.\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // 6-7 bit aralığını temizle\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // 6-7 aralığını 1 ata\n```\n\nOldukça şifreli görünüyor. Herhangi bir yorum satırı olmadan buna benzer kodlar\nfazlasıyla zor anlaşılır. Kodumuzu bundan daha okunaklı şekilde yazabiliriz.\nBunun ana fikiri tüm 32 bitlik çevre birimini bir yapı ile göstermektir.\nGelin datasheet'te 8.4 bölümünde bulunan GPIO için tanımlı hangi registerlar\nvar birlikte bakalım. MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR,\nLCKR, AFR ile karşılaşmaktayız. Bunlar ana yapının 0, 4, 8, vb offsetleridirler.\nYani bunları kullanarak 32bitlik alanları temsil edebilir ve GPIOA'yı şu şekilde\ntanımlayabiliriz:\n\n```c\nstruct gpio {\n  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];\n};\n\n#define GPIOA ((struct gpio *) 0x40020000)\n```\n\nArdından, GPIO pin modu tanımlamak için şöyle bir fonksiyon oluşturalım:\n\n```c\n// Dataheet'e göre enum değerleri: 0, 1, 2, 3\nenum {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG};\n\nstatic inline void gpio_set_mode(struct gpio *gpio, uint8_t pin, uint8_t mode) {\n  gpio->MODER &= ~(3U << (pin * 2));        // Mevcut ayarları temizle\n  gpio->MODER |= (mode & 3) << (pin * 2);   // Yeni modu ata\n}\n```\n\nArtık A3 pininin modunu şu şekilde output yapabiliriz\n\n```c\ngpio_set_mode(GPIOA, 3 /* pin */, GPIO_MODE_OUTPUT);  // A3'ü output olarak ata\n```\n\nMCU'muz birden fazla GPIO çevre birimi (\"bank\" diye de adlandırılır)\niçermektedir, bunlar: A, B, C, ..., K.\n2.3 bölümünde de görebileeceğimiz gibi birbirlerinden 1KB uzaklıktadırlar.\nGPIOA'nın adresi 0x40020000, GPIOB'nin adresi 0x40020400 ise:\n\n```c\n#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))\n```\n\nPin numarasını ve bank'ını içeren bir numaralandırma oluşturabiliriz.\nBunu yapmak için 2 byte'lık `uint16_t` değerini, üst byte'ı GPIO banklarını\nalt byte'ı ise pin numaralarını tutacak şekilde kullanırız.\n\n```c\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n```\n\nBu şekilde herhangi bir GPIO bankını pinler için özelleştirebiliriz.\n\n```c\n  uint16_t pin1 = PIN('A', 3);    // A3   - GPIOA pin 3\n  uint16_t pin2 = PIN('G', 11);   // G11  - GPIOG pin 11\n```\n\nHadi birlikte pin özelleştirmesi için `gpio_set_mode()`fonksiyonunu yazalım:\n\n```c\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin)); // GPIO bank\n  uint8_t n = PINNO(pin);                 // Pin numarası\n  gpio->MODER &= ~(3U << (n * 2));        // Mevcut temizle\n  gpio->MODER |= (mode & 3) << (n * 2);   // Yeni modu ata\n}\n```\n\nİşte karşınızda A3'ün yeni görünümü.\n\n```c\n  uint16_t pin = PIN('A', 3);            // Pin A3\n  gpio_set_mode(pin, GPIO_MODE_OUTPUT);  // output olarak ata\n```\n\nGPIO çevre birimi için yararlı bir başlangıç API'si oluşturduğumuzu unutmayın.\nUART (seri iletişim) ve diğerleri gibi diğer çevre birimleri de benzer şekilde\nuygulanabilir. Bu, kodu kendi kendini açıklayıcı ve insan tarafından okunabilir\nkılan iyi bir programlama uygulamasıdır.\n\n## MCU boot ve vector tablosu\n\nBir ARM MCU önyükleme(boot) yaptığında, flash belleğinin başında bulunan vektör tablosunu\nokur. Vektör tablosu, tüm ARM MCU'lar için ortak bir kavramdır. Bu, kesme\nişleyicilerinin 32 bit adreslerinden oluşan bir dizidir. İlk 16 vektör ARM tarafından\nayrılmıştır ve tüm ARM MCU'larında ortaktır. Kesme işleyicilerinin geri kalanı\nverilen MCU'ya özeldir -bunlar çevre birimleri için kesme işleyicileridir-.\nBirkaç çevre birimli basit MCU'larda az sayıda kesme yakalayıcısı varken MCU\nkarmaşıklaştıkça bu sayı da artar.\n\nSTM32F429 için vektör tablosu Tablo 62'de verilmiştir. Buradan standart 16'ya\nek olarak 91 çevresel işleyici olduğunu görebiliriz.\n\nVektör tablosundaki her değer, MCU'nun yürüttüğü bir işlevin adresidir.\nbir donanım kesmesi (IRQ) tetiklendiğinde. MCU önyükleme sürecinde önemli bir\nrol oynayan ilk iki değer istisnadır. Bu değerler şunlardır:\nilk yığın işaretçisi ve yürütülecek önyükleme işlevinin adresi (firmware'in başlangıç noktası).\n\nArtık biliyoruz ki, bellenimimizin flaştaki 2. 32 bitlik değerin bir önyükleme\nişlevi adresi içermesi gerektiği şekilde oluşturulması gerektiğinden emin olmalıyız.\nMCU önyüklendiğinde, bu adresi flaştan okuyacak ve önyükleme fonksiyonunu çalıştıracaktır.\n\n## Minimal firmware\n\nBir `main.c` dosyası oluşturalım ve başlangıçta hiçbir şey yapmayan\n(sonsuz döngüye düşen) önyükleme fonksiyonumuzu belirleyelim ve 16\nstandart giriş ve 91 STM32 girişi içeren bir vektör tablosu belirleyelim.\nSeçtiğiniz editörde, \"main.c\" dosyasını oluşturun ve aşağıdakini \"main.c\"\ndosyasına kopyalayın/yapıştırın:\n\n```c\n// Startup kodu\n__attribute__((naked, noreturn)) void _reset(void) {\n  for (;;) (void) 0;  // Sonsuz döngü\n}\n\nextern void _estack(void);  // link.ld'de tanımlanmıştır.\n\n// 16 standart ve 91 STM32-specific yakalayıcı\n__attribute__((section(\".vectors\"))) void (*const tab[16 + 91])(void) = {\n  _estack, _reset\n};\n```\n\n`_reset()` fonksiyonu için, GCC'ye özgü `naked` ve `noreturn` attribute'larını kullandık\nbunlar standart fonksiyonun giriş ve sonsözünün derleyici tarafından oluşturulmaması\ngerektiği ve bu işlevin geri dönmediği anlamına gelir-.\n\n`void (*const tab[16 + 91])(void)` ifadesi şu anlama gelir: 16 + 91 genişlikte,\ngeriye bir şey döndermeyen(void) ve void argulanı alan bir fonksiyon pointer'ı dizisidir.\nBu fonksiyonlardan her biri bir IRQ fonksiyonudur(Interrupt ReQuest işleyici).\nBu fonksiyonlardan oluşan dizi ise vektör tablosudur.\n\nVektör tablosu `tab`, `.vector` diye adlandırılan section'a yerleştirilir\n-daha sonra bağlayıcıya bu bölümü üretilen ürün yazılımının hemen başına\nve ardından flash belleğin başına koymasını söylememiz gerekiyor-.Vektör\ntablosunun geri kalanını sıfırlarla dolu bırakıyoruz.\n\n### Derleme\n\nHadi kodumuzu derleyelim. Terminali (veya Windows'ta komut istemini) açalım\nve şunu çalıştıralım:\n\n```sh\n$ arm-none-eabi-gcc -mcpu=cortex-m4 main.c -c\n```\n\nDerleme, hiçbir şey yapmayan minimum aygıt yazılımımızı aşağıdakileri içeren bir `main.o`\ndosyasına çevirdi. `main.o` dosyası, birkaç bölümlük ELF binary formatındadır.\n\nHadi inceleyelim:\n\n```sh\n$ arm-none-eabi-objdump -h main.o\n...\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00000002  00000000  00000000  00000034  2**1\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .data         00000000  00000000  00000000  00000036  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  00000000  00000000  00000036  2**0\n                  ALLOC\n  3 .vectors      000001ac  00000000  00000000  00000038  2**2\n                  CONTENTS, ALLOC, LOAD, RELOC, DATA\n...\n```\n\nBölümler(section) için VMA/LMA adreslerinin 0'a ayarlandığını unutmayın\n-bu, adres alanında bu bölümlerin yüklenmesi gereken bilgileri içermediğinden,\n'main.o'nun henüz tam bir sabit yazılım olmadığı anlamına gelir-. `main.o`dan\ntam bir `firmware.elf` üretmek için bir bağlayıcı(linker) kullanmamız gerekiyor.\n\n.text bölümü kodu içerir, bizim işin bu sadece `_reset()` fonksiyonudur.\n2 bayt uzunluğu kendi adresine atlama talimatı içerdiğinden gelmektedir. Orada\nboş bir `.data` bölümü ve boş bir `.bss` bölümü (sıfır olarak başlatılan veriler).\nFirmware'imizin, 0x8000000 ofsetindeki flash bölgesine kopyalanacak, ancak\nveri bölümümüz RAM'de bulunacaktır -bu nedenle `_reset()` işlevimiz `.data` bölümünün\niçeriğini RAM'e kopyalamalıdır-. Ayrıca `.bss`nin tamamına sıfır yazmalıdır.\n`.data` ve `.bss` bölümleri boş, ancak yine de `_reset()` işlevimizi düzgün\nbir şekilde işlemek için değiştirelim.\n\nTüm bunları yapabilmek için, yığının(stack) nerede başladığını, data ve bss\nbölümlerinin nerede başladığını bilmeliyiz. Bunu adres alanında çeşitli bölümlerin\nnereye yerleştirileceğini ve hangi sembollerin oluşturulacağını içeren\nbir dosya olan \"linker script\" içinde belirtebiliriz.\n\n### Linker script\n\n`link.ld` adında bir dosya oluşturun ve içine şunu yapıştırın [steps/step-0-minimal/link.ld](steps/step-0-minimal/link.ld).\n\nGelin adım adım ne olduklarını açıklayalım:\n\n```\nENTRY(_reset);\n```\n\nBu satır, oluşturulan ELF başlığındaki \"entiry point\" özniteliğinin değerini\nlinker'a söyler -yani bu, vektör tablosunun sahip olduğu şeyin bir kopyasıdır-.\nBu, debogger'a firmware'in başlangıcına breakpoint koymasına yardımcı olur.\nDebugger vektör tablosu hakkında bir şey bilemed, bu nedenle ELF başlığına ihtiyaç duyar.\n\n```\nMEMORY {\n  flash(rx)  : ORIGIN = 0x08000000, LENGTH = 2048k\n  sram(rwx) : ORIGIN = 0x20000000, LENGTH = 192k  /* 64k'lık bölünmüş bir alan olduğunu hatırlatır */\n}\n```\n\nBu satır linker'a iki bellek bölgemiz olduğunu, bellek bölgelerinin adreslerini\nve boyutlarını söyler.\n\n```\n_estack     = ORIGIN(sram) + LENGTH(sram);    /* stack'e SRAM'in sonunu işaret ettirir */\n```\n\nBu satır linker'a RAM bölgesinin en sonlarına doğru bir `estack` sembolü oluşturtur.\nBu bizim varsayılan stack değerimiz olacaktır.!\n\n```\n  .vectors  : { KEEP(*(.vectors)) }   > flash\n  .text     : { *(.text*) }           > flash\n  .rodata   : { *(.rodata*) }         > flash\n```\n\nBu satırlar, bağlayıcıya önce vektör tablosunu flash'a koymasını, ardından `.text` bölümünü (firmware kodu), ardından sa read-only veri olan `.rodata`yı koymasını söyler.\n\nSonda da `.data` bölümü gelir:\n\n```\n  .data : {\n    _sdata = .;   /* .data bölümünün başlangıcı */\n    *(.first_data)\n    *(.data SORT(.data.*))\n    _edata = .;  /* .data bölümünün bitimi */\n  } > sram AT > flash\n  _sidata = LOADADDR(.data);\n```\n\nBağlayıcıya `_sdata` ve `_edata` sembolleri oluşturmasını söylediğimize\ndikkat edin. Bunları, `_reset()` işlevinde veri bölümünü\nRAM'e kopyalamak için kullanacağız.\n\n`.bss` bölümü de benzer şekilde:\n\n```\n  .bss : {\n    _sbss = .;              /* .bss bölümünün başlangıcı */\n    *(.bss SORT(.bss.*) COMMON)\n    _ebss = .;              /* .bss bölümünün bitimi */\n  } > sram\n```\n\n### Startup kodu\n\nArtık `_reset()` fonksiyonumuzu güncelleyebiliriz. `.data` kısmını RAM'e kopyalıyoruz ve bss kısmını sıfırlıyoruz. Ardından, main() işlevini çağırırız ve main()'den return edilene kadar sonsuz döngüye giriyor:\n\n```c\nint main(void) {\n  return 0; // Şimdilik bir şey yapmayalım\n}\n\n// Başlangıç kodu\n__attribute__((naked, noreturn)) void _reset(void) {\n  // .bss'e 0 ata ve .data'yı RAM'e kopyala\n  extern long _sbss, _ebss, _sdata, _edata, _sidata;\n  for (long *dst = &_sbss; dst < &_ebss; dst++) *dst = 0;\n  for (long *dst = &_sdata, *src = &_sidata; dst < &_edata;) *dst++ = *src++;\n\n  main();             // main()' çağır\n  for (;;) (void) 0;  // main'den return gelene kadar sonsuz döngü\n}\n```\n\naşağıdaki diyagram `_reset()`'in .data ve .bss'i nasıl yükeldiğini gösteriyor:\n\n![](images/mem2.svg)\n\n`firmware.bin` dosyası, yalnızca şu üç bölümün birleşiminden oluşur:\n`.vectors` (IRQ vektör tablosu), `.text` (kod) ve `.data` (veri).\nBu bölümler linker script dosyasına göre oluşturulmuştur:\n`.vectors` flash'ın en başında yer alır, hemen ardından `.text` gelir\nve çok yukarısında `.data` yer alır. `.text` içindeki adresler flaş bölgesindedir\nve `.data` içindeki adresler RAM bölgesindedir. Bazı işlevlerin adresi\nvarsa, örn. `0x8000100`, ardından flash'ta tam olarak bu adreste\nbulunur. Ancak kod, `.data` bölümündeki bazı değişkenlere adresle\nerişirse, örn. `0x20000200`, o zaman o adreste hiçbir şey yoktur,\nçünkü açılışta `firmware.bin` içindeki `.data` bölümü flash'ta bulunur!\nBu nedenle başlangıç kodunun `.data` bölümünü flash bölgesinden\nRAM bölgesine taşıması gerekir.\n\nArtık komple bir `firmware.elf` dosyası üretmeye hazırız\n\n```sh\n$ arm-none-eabi-gcc -T link.ld -nostdlib main.o -o firmware.elf\n```\n\nHadi firmware.elf dosyasının parçalarına bakalım:\n\n```sh\n$ arm-none-eabi-objdump -h firmware.elf\n...\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .vectors      000001ac  08000000  08000000  00010000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  1 .text         00000058  080001ac  080001ac  000101ac  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n...\n```\n\nŞimdi .vectors bölümünün flash belleğin en başında olan 0x8000000 adresinde,\nardından 0x80001ac adresinde hemen sonra .text bölümünün yer alacağını\ngörebiliriz. Henüz .data bölümü olmadığı için kodumuz herhangi bir değişken\noluşturamaz.\n\n## Firmware yükleme\n\nFirmware'i yüklemeye hazırız. İlk önce firmware.elf dosyasından bölümleri\nçıkarıp tek bir binary dosyasında toplamalıyız.:\n\n```sh\n$ arm-none-eabi-objcopy -O binary firmware.elf firmware.bin\n```\n\n`st-link` kullanarak firmware.bin dosyasını yükleyelim. Kartınızı USB ile bağlayın\nve şunu çalıştırın:\n\n```sh\n$ st-flash --reset write firmware.bin 0x8000000\n```\n\nSonunda! Sonunda hiçbir şey yapmayan yazılımımızı kartımıza yükledik.\n\n## Makefile: derleme otomasyonu\n\nŞu ana kadarki, linkleme ve yükleme komutlarını yazmak yerine,\ntüm süreci otomatikleştirmek için `make` komut satırı aracını\nkullanabiliriz.`make` yardımcı programı, eylemlerin nasıl yürütüleceğine\nilişkin talimatları okuduğu `Makefile` adlı bir yapılandırma\ndosyası kullanır. Bu otomasyon harika çünkü aynı zamanda sabit\nyazılım, kullanılan derleme flag'ları vb. oluşturma sürecini de dokümante eder.\n\nhttps://makefiletutorial.com adresinde harika bir Makefile eğitimi\nvar. `make` konusunda yeni olanlar için bir göz atmalarını öneririm.\nAşağıda, basitçe sıfırdan Makefile'imizi anlamak için gereken\nen temel kavramları listeliyorum. `make` kelimesini zaten bilenler\nbu bölümü atlayabilir.\n\nBasitçe `Makefile` formatı:\n\n```make\nislem1:\n\tkomut ...     # Hash işaretinden sonra yorum yazılabilir\n\tkomut ....    # ÖNEMLİ UYARI: komutlardan önce TAB karakteri gelmek zorundadur\n\nislem2:\n\tkomut ...     # TAB koymayı unutma! Space ile çalışmaz.\n```\n\nArtık `make` ile istediğiniz işlemin ismini vererek onu tetikleyebilirsiniz.\n\n```sh\n$ make islem1\n```\n\nDeğişkenler tanımlamak ve onları komutlarda kullanmak da mümkündür.\nAynı zamanda işlemler oluşturulması gereken dosya adları da olabilir.\n\n```make\nfirmware.elf:\n\tDERLEME KOMUTU .....\n```\n\nVe bir işlem diğer işlemlere de bağımlı olabilir. Örnek olarak\n`firmware.elf` kaynak dosyamız olan `main.c`'ye bağımlıdır. `main.c`\ndosyası ne zaman değişirse `make build` komutu `firmware.elf`'i de\ntekrardan çalıştırır.\n\n```\nbuild: firmware.elf\n\nfirmware.elf: main.c\n\tDERLEME KOMUTU\n```\n\nArtık firmware'imiz için Makefile yazmaya hazırız. `build` komutunu tanımlayalım.\n\n```make\nCFLAGS  ?=  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion \\\n            -Wformat-truncation -fno-common -Wconversion \\\n            -g3 -Os -ffunction-sections -fdata-sections -I. \\\n            -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 $(EXTRA_CFLAGS)\nLDFLAGS ?= -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=$@.map\nSOURCES = main.c\n\nbuild: firmware.elf\n\nfirmware.elf: $(SOURCES)\n\tarm-none-eabi-gcc $(SOURCES) $(CFLAGS) $(LDFLAGS) -o $@\n```\n\nGördüğünüz üzere derleme flag'larını tanımladık. `?=`'nin anlamı bunu\nvarsayılan değer olduğu ve komut satırından ezmemize olanak sağladığıdır.\n\n```sh\n$ make build CFLAGS=\"-O2 ....\"\n```\n\n`CFLAGS`, `LDFLAGS` ve `SOURCES` değişkenlerini tanımladık.\n`make`'e şunu dedik: `build` yapmanız istenirse, bir `firmware.elf`\ndosyası oluşturun. `main.c` dosyasına bağlıdır ve onu oluşturmak\niçin `arm-none-eabi-gcc` derleyicisini verilen flag'larla çalıştır.\n`$@` özel değişkeni bir hedef adına genişler - bizim durumumuzda `firmware.elf`.\n\nHadi `make`'i çalıştıralım:\n\n```\n$ make build\narm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion -Wformat-truncation -fno-common -Wconversion -g3 -Os -ffunction-sections -fdata-sections -I. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16  -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=firmware.elf.map -o firmware.elf\n```\n\nEğer tekrardan çalıştırırsanız\n\n```sh\n$ make build\nmake: Nothing to be done for `build'.\n```\n\n`make` programı, `main.c` bağımlılığı ve `firmware.elf` için\ndeğişiklik zamanlarını inceler ve şu durumlarda hiçbir şey yapmaz:\n`firmware.elf` güncelse ancak `main.c`yi değiştirirsek, sonraki\n`make build` komutunda yeniden derlenir:\n\n```sh\n$ touch main.c # main.c'deki değişikli simüla ediyoruz\n$ make build\n```\n\nPeki şimdi geriye ne kaldı? Tabii ki `flash` komutu\n\n```make\nfirmware.bin: firmware.elf\n\tarm-none-eabi-objcopy -O binary $< $@\n\nflash: firmware.bin\n\tst-flash --reset write $< 0x8000000\n```\n\nBu kadar! Şimdi, `make flash` terminal komutu bir\n`irmware.bin` dosyasını kopyalar ve onu yükler. `main.c`\ndeğişirse sabit yazılımı yeniden derler, çünkü `firmware.bin`\n`firmware.elf`'e bağlıdır ve o da `main.c`ye bağlıdır. Yani,\nşimdi yaptığınızda şu iki eylem olacaktır:\n\n```sh\n# main.c içinde geliştirme yaptıktan sonra\n$ make flash\n```\n\nHedef dosyaları temizleyecek `clean` komutunu eklemek artık iyi bir fikir\n\n```\nclean:\n\trm -rf firmware.*\n```\n\nProjenin tamamlanmış halini [steps/step-0-minimal](steps/step-0-minimal) klasöründe bulabilirsiniz.\n\n## LED yakma\n\nŞimdi tüm derleme / flash altyapısını kurduğumuza göre,firmware'imizle kullanışlı\nbir şeyler yapmasını öğretme zamanı. Elektronikten kullanışlı şey elbette LED'i\nyakıp sökmektir. Bir Nucleo-F429ZI kartında üç dahili LED bulunur.\nNucleo kartı datasheet'inin bölüm 6.5'ünde dahili LED'lerin hangi pinlere\n\n- PB0: yeşil LED\n- PB7: mavi LED\n- PB14: kırmızı LED\n\nHadi `main.c` dosyasını düzenleyelim ve PIN ve `gpio_set_mode()` tanımlamalarımızı yapalım.\n`main()` fonksiyonunda mavi LED'i çıkış moduna ayarlıyoruz ve sonsuz bir döngü başlatıyoruz.\nİlk olarak, daha önce konuştuğumuz pinler ve GPIO tanımlarını kopyalayalım.\nAyrıca `BIT(konum)` makrosunu eklediğimizi unutmayın:\n\n```c\n#include <inttypes.h>\n#include <stdbool.h>\n\n#define BIT(x) (1UL << (x))\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n\nstruct gpio {\n  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];\n};\n#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))\n\n// Datasheet'e göre enum değerleri: 0, 1, 2, 3\nenum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };\n\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin numarası\n  gpio->MODER &= ~(3U << (n * 2));         // Mevcut değeri temizle\n  gpio->MODER |= (mode & 3) << (n * 2);    // Yeni modu ata\n}\n```\n\nBazı mikrodenetleyiciler, çalıştırıldıklarında, tüm çevre birimlerine\notomatik olarak güç verilir ve etkinleştirilir. Ne yazıkki, STM32 MCU'lar,\ngüç tasarrufu yapmak için varsayılan olarak çevre birimlerini devre\ndışı bırakmıştır. Bir GPIO çevre birimini etkinleştirmek için,\nRCC (Sıfırlama ve Saat Kontrolü) birimi aracılığıyla etkinleştirilmelidir(saatli).\nDatasheet'in 7.3.10 numaralı bölümünde, AHB1ENR'nin (AHB1 çevresel saat etkinleştirme kaydı)\nGPIO bankalarını açıp kapatmaktan sorumlu olduğunu görüyoruz.\nÖnce biz tüm RCC birimi için bir tanım ekleyin:\n\n```c\nstruct rcc {\n  volatile uint32_t CR, PLLCFGR, CFGR, CIR, AHB1RSTR, AHB2RSTR, AHB3RSTR,\n      RESERVED0, APB1RSTR, APB2RSTR, RESERVED1[2], AHB1ENR, AHB2ENR, AHB3ENR,\n      RESERVED2, APB1ENR, APB2ENR, RESERVED3[2], AHB1LPENR, AHB2LPENR,\n      AHB3LPENR, RESERVED4, APB1LPENR, APB2LPENR, RESERVED5[2], BDCR, CSR,\n      RESERVED6[2], SSCGR, PLLI2SCFGR;\n};\n#define RCC ((struct rcc *) 0x40023800)\n```\n\nAHB1ENR register dokümanına göre 0'dan 8'e kadar olan bitler\nGPIOA - GPIOE bankaları için saati ayarlar :\n\n```c\nint main(void) {\n  uint16_t led = PIN('B', 7);            // mavi LED\n  RCC->AHB1ENR |= BIT(PINBANK(led));     // LED için saati aktifleştirme\n  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Mavi LED'i output olarak ayarlama\n  for (;;) (void) 0;                     // sonsuz döngü\n  return 0;\n}\n```\n\nŞimdi geriye kalan şey, bir GPIO pininin nasıl açılıp kapatılacağını\nbulmak ve ardından bir LED pinini açmak, geciktirmek, kapatmak,\ngeciktirmek için ana döngüyü değiştirmek. Veri sayfası bölüm 8.4.7'ye baktığımızda,\nBSRR kaydının voltajı yüksek veya düşük ayarlamaktan sorumlu olduğunu\ngörüyoruz. Düşük 16 bit, ODR kaydını ayarlamak için kullanılır\n(yani, yüksek pin ayarı) ve yüksek 16 bit, ODR kaydını sıfırlamak için\nkullanılır (yani, düşük pin ayarı). Bunun için bir API fonksiyonu tanımlayalım:\n\n```c\nstatic inline void gpio_write(uint16_t pin, bool val) {\n  struct gpio *gpio = GPIO(PINBANK(pin));\n  gpio->BSRR = (1U << PINNO(pin)) << (val ? 0 : 16);\n}\n```\n\nŞimdi artık bekleme fonksiyonunu tanımlama zamanımız geldi. Şu anlık özel bir\ngecikme fonksiyonuna ihtiyacımız yok. `spin()` fonksiyonu ile verilen\nkez kadar NOP(no operation) işlemini yapacak fonksiyon tanımlalamız\nyeterli olacaktır;\n\n```c\nstatic inline void spin(volatile uint32_t count) {\n  while (count--) (void) 0;\n}\n```\n\nSonunda döngümüzü LED yakıp söndürmek için güncellemeye hazırız:inking:\n\n```c\n  for (;;) {\n    gpio_write(led, true);\n    spin(999999);\n    gpio_write(led, false);\n    spin(999999);\n  }\n```\n\n`make flash` komutunu çalıştırın ve arkanıza yaslanıp LED'in keyfini sürün.\nProjenin tamamına [steps/step-1-blinky](steps/step-1-blinky) klasöründen ulaşabilirsiniz.\n\n## SysTick kesmesi ile Blink\n\nDoğru bir zaman tutma uygulamak için ARM'nin SysTick kesmesini(interrupt) etkinleştirmeliyiz.\nSysTick 24 bitlik bir donanım sayacıdır ve ARM çekirdeğinin bir parçasıdır,\ndolayısıyla ARM datasheet'inde dokümante edilmiştir.Datasheet'e baktığımızda,\nSysTick'in dört adet register'ı olduğunu görüyoruz:\n\n- CTRL - systick'i açıp kapatmak için kullanılır\n- LOAD - sayaca başlangıç değerini yükler\n- VAL - şu anki sayaç değeri, her clock'ta bir azaltılır\n- CALIB - calibrasyon register'ı\n\nVAL her sıfır olduğunda bir SysTick kesmesi oluşturulur.\nBu interrupt'ın vektör tablosundaki değeri 15'tir, bu yüzden onu doldurmalıyız.\nNucleo-F429ZI kartı 16Mhz ile kod koşturur bu sayede SysTick sayacını\nher milisaniyede çalışacak şekilde tetikletebiliriz.\n\nİlk önce hadi SysTick çevre birimini tanımlayalık. Bildiğimiz üzere 4 adet\nregister'ı vardı ve SysTick adresi 0xe000e010'idi. O zaman:\n\n```c\nstruct systick {\n  volatile uint32_t CTRL, LOAD, VAL, CALIB;\n};\n#define SYSTICK ((struct systick *) 0xe000e010)\n```\n\nArdından, bunu konfigre edebilecğeimiz bir API ekleyelim. İlk önce\n`SYSTICK->CTRL` register'ı ile SysTick'i devreye sokmalıyız ve\n`RCC->APB2ENR` sayacını dokümanda 7.4.14 bölümünde tanımlandığı\ngibi kullanmalıyız.\n\n```c\n#define BIT(x) (1UL << (x))\nstatic inline void systick_init(uint32_t ticks) {\n  if ((ticks - 1) > 0xffffff) return;  // Systick timer'ı 24 bittir\n  SYSTICK->LOAD = ticks - 1;\n  SYSTICK->VAL = 0;\n  SYSTICK->CTRL = BIT(0) | BIT(1) | BIT(2);  // systick'i devreye al\n  RCC->APB2ENR |= BIT(14);                   // SYSCFG'yi devreye al\n}\n```\n\nVarsayılan olarak Nucleo-F429ZI kartı 16Mhz ile kodu koşturduğu için\n`systick_init(16000000 / 1000);` çağrısı yaptığımızda 1 milisaniyede\ntetikleneceğini garanti eder. Bir tane kesme yakalayıcısı tanımlamalıyız.\nBurada basit bir 32 bir milisaniye sayıcı görünmektedir:\n\n```c\nstatic volatile uint32_t s_ticks; // volatile olması önemli!!\nvoid SysTick_Handler(void) {\n  s_ticks++;\n}\n```\n\n16Mhz'lik saat ile SysTick her 16000 döngüde tetiklenecektir.\n`SYSTICK->VAL`'in varsayılan değeri 15999'dur ve her döngüde\nbirer birer azalır ve 0 olduğunda kesme üretir. Firmware kodunun\nyürütülmesi durdurulur ve `SysTick_Handler()` fonksiyonu tetiklenir.\nO da `s_ticks` değerini arttırır. Burada zaman aralığında nasıl göründüğüne bakalım:\n\n![](images/systick.svg)\n\n`volatile` tanımlayıcısı burada gereklidir çünkü `s_ticks` değeri kesme ile\ngüncellenir. `volatile` tanımlayıcısı derleyiciye optimizasyon/cache'leme\niçin `s_ticks` değişkenini register'a çekmemesini söyler. Oluşturulan kod\nher zaman bellekten veriye erişir. Bu yüzden çevre birimi yapılarında bolca\nkullanılır. Bunu anlamanız oldukça önemlidir, hadi gelin bunun Arduino'nun `delay()`\nfonksiyonla bizim `s_ticks` ile kıyaslayalım:\n\n```c\nvoid delay(unsigned ms) {            // bu fonksiyon \"ms\" kadar milisaniye bekler\n uint32_t until = s_ticks + ms;      // Durmamız gereken zamanı hesaplayalım\n while (s_ticks < until) (void) 0;   // bitene kadar döngü\n}\n```\n\nŞimdi bunu `s_ticks`'te `volatile` tanımlayıcısı olmadan derleyelim ve makine koduna bakalım:\n\n```\n// NO VOLATILE: uint32_t s_ticks;       |  // VOLATILE: volatile uint32_t s_ticks;\n                                        |\n ldr     r3, [pc, #8]  // cache s_ticks |  ldr     r2, [pc, #12]\n ldr     r3, [r3, #0]  // in r3         |  ldr     r3, [r2, #0]   // r3 = s_ticks\n adds    r0, r3, r0    // r0 = r3 + ms  |  adds    r3, r3, r0     // r3 = r3 + ms\n                                        |  ldr     r1, [r2, #0]   // RELOAD: r1 = s_ticks\n cmp     r3, r0        // ALWAYS FALSE  |  cmp     r1, r3         // compare\n bcc.n   200000d2 <delay+0x6>           |  bcc.n   200000d2 <delay+0x6>\n bx      lr                             |  bx      lr\n```\n\n`volatile` olmayan `delay()` fonksiyonu hiçbir zaman çıkmayacak ve sonsuza\nkadar dönecektir çünkü optimizasyon için `s_ticks`'in değeri register'da\ncache'lenir ve asla güncellenmez. Derleyici bu değişkenin başka bir yerde\n-kesme gibi- değişceğini bilmediği için yapar.\n\n`volatile` olan fonksiyonda her döngüde `s_ticks`'in değeri register'dan istenir.\nYani altın kuralımız şudur:\n**bellekteki interrupt handler yahut donanım tarafından güncellenen veriler her zaman `volatile` olarak tanımlanmalıdır**\n\nArtık `volitale` kullanmamızın nedenini öğrendiğimize göre `SysTick_Handler()` kesme yakalayıcısını vektör tablosuna ekleyebiliriz.\n\n```c\n__attribute__((section(\".vectors\"))) void (*const tab[16 + 91])(void) = {\n    _estack, _reset, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SysTick_Handler};\n```\n\nElimizde artık saniye bazlı bir saatimiz var. Gelin periyodik zamanlar\niçin de bir yardımcı fonksiyon yazalım\n\n```c\n// t: bitiş zamanı, prd: periyod, now: şu an. Eğer zaman geçtiyse true döner\nbool timer_expired(uint32_t *t, uint32_t prd, uint32_t now) {\n  if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer\n  if (*t == 0) *t = now + prd;                   // First poll? Set expiration\n  if (*t > now) return false;                    // Not expired yet, return\n  *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time\n  return true;                                   // Expired, return true\n}\n```\n\nNow we are ready to update our main loop and use a precise timer for LED blink.\nFor example, let's use 250 milliseconds blinking interval:\n\n```c\n  uint32_t timer, period = 500;          // Declare timer and 500ms period\n  for (;;) {\n    if (timer_expired(&timer, period, s_ticks)) {\n      static bool on;       // This block is executed\n      gpio_write(led, on);  // Every `period` milliseconds\n      on = !on;             // Toggle LED state\n    }\n    // Here we could perform other activities!\n  }\n```\n\nSysTick ve bir yardımcı 'timer_expired()' işlevini kullanarak, ana döngümüzü\n(superloop olarak da adlandırılır) non-blocking hale getirdiğimize dikkat\nedin. Bu, bu döngü içinde birçok işlem gerçekleştirebileceğimiz anlamına\ngelir - örneğin, farklı dönemlere sahip farklı zamanlayıcılara sahip olabiliriz\nve bunların tümü zamanında tetiklenecektir.\n\nProjenin tamamına [steps/step-2-systick](steps/step-2-systick) klasöründen ulaşabilirsiniz..\n\n## UART debug çıktısı ekleme\n\nŞimdi frimware'imize insanlar tarafından okunabilen bir çıktı ekleme zamanı.\nMCU çevre birimlerinden biri seri UART arabirimidir. Datasheet'te bölüm 2.3'e\nbaktığımızda, birkaç UART/USART denetleyicisi olduğunu görüyoruz\n-yani MCU içinde uygun şekilde yapılandırılmış, belirli\npinler aracılığıyla veri alışverişi yapabilen devre parçaları-. Minimum bir\nUART kurulumunda, RX (alma) ve TX (iletim) olmak üzere iki pin kullanır.\n\nBir Nucleo kartı datasheet'inde bölüm 6.9'da, denetleyicilerden biri olan\nUSART3'ün PD8 (TX) ve PD9 (RX) pinlerini kullandığını ve yerleşik\nST-LINK hata ayıklayıcısına bağlı olduğunu görüyoruz.Bu, USART3'ü\nyapılandırırsak ve verileri PD9 pini aracılığıyla aktarırsak ST-LINK\nUSB bağlantısı aracılığıyla bilgisayarımızdan okuyabiliriz.\n\nBu da bize UART için GPIO ile birlikte bir API oluşturmayı gerektirtiyor.\nDatasheet'in 30.6 bölümü UART register'larını şöyle özetliyor:\n\n```c\nstruct uart {\n  volatile uint32_t SR, DR, BRR, CR1, CR2, CR3, GTPR;\n};\n#define UART1 ((struct uart *) 0x40011000)\n#define UART2 ((struct uart *) 0x40004400)\n#define UART3 ((struct uart *) 0x40004800)\n```\n\nUART'ı konfigre etmemiz için:\n\n- `RCC->APB2ENR` register'ı ile UART saatini devreye sokmamız.\n- RX ve TX pinlerini \"alternatif fonksiyon\" moduyla tanımlamamız.\n  Verilen pinlerin çevre birimlerine göre birden fazla Alternatif fonksiyon(AF) bulunmaktadır. AF listesine tablo 12'den erişebilirsiniz [STM32F429ZI](https://www.st.com/resource/en/datasheet/stm32f429zi.pdf)\n- BRR register'ı ile bound rate (okuma/yazma bit hızı) ayarlanması\n- CRR register'ı ile çevre biriminin aktif hale getirilmesi\n\nArtık istediğimiz GPIO modunu nasıl atayacağımızı bildiğimize göre hızlıca\nişe başlayalım. Eğer bir pin AF modundaysa onun fonksiyon numarasını\nda belirlememiz gerekmektedir. Örnek olarak hangi çevre biriminin\nkontrolünde olduğu gibi. Bu işlem GPIO'nun alternatif fonksiyon register(`ARF`)'ı\nile yapılır. Datasheet'ten AFR açıklamasını okuduğumuzda 4 bitlik\nsayıdan oluştuğunu görebiliriz. Bu da 16 pin için 2 register'ı ayarlamamız gerektiğini gösterir\n\n```c\nstatic inline void gpio_set_af(uint16_t pin, uint8_t af_num) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin numarası\n  gpio->AFR[n >> 3] &= ~(15UL << ((n & 7) * 4));\n  gpio->AFR[n >> 3] |= ((uint32_t) af_num) << ((n & 7) * 4);\n}\n```\n\nHali hazırda bulunan kodda register register-sepecific kodları gizlenmiş halde,\nhadi GPIO saatini `gpio_set_mode()` fonksiyonunda başlatalım.\n\n```c\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin numarası\n  RCC->AHB1ENR |= BIT(PINBANK(pin));       // GPIO Clock'unu aktifleştirme\n  ...\n```\n\nUART'ı başlatacak API fonksiyonu için şu an tüm ortam hazır.\n\n```c\n#define FREQ 16000000  // CPU frekansı, 16 Mhz\nstatic inline void uart_init(struct uart *uart, unsigned long baud) {\n  // https://www.st.com/resource/en/datasheet/stm32f429zi.pdf\n  uint8_t af = 7;           // alternatif fonksiyon\n  uint16_t rx = 0, tx = 0;  // pinler\n\n  if (uart == UART1) RCC->APB2ENR |= BIT(4);\n  if (uart == UART2) RCC->APB1ENR |= BIT(17);\n  if (uart == UART3) RCC->APB1ENR |= BIT(18);\n\n  if (uart == UART1) tx = PIN('A', 9), rx = PIN('A', 10);\n  if (uart == UART2) tx = PIN('A', 2), rx = PIN('A', 3);\n  if (uart == UART3) tx = PIN('D', 8), rx = PIN('D', 9);\n\n  gpio_set_mode(tx, GPIO_MODE_AF);\n  gpio_set_af(tx, af);\n  gpio_set_mode(rx, GPIO_MODE_AF);\n  gpio_set_af(rx, af);\n  uart->CR1 = 0;                           // UART'ı kapatma\n  uart->BRR = FREQ / baud;                 // FREQ,  UART'ın bus frekansı\n  uart->CR1 |= BIT(13) | BIT(2) | BIT(3);  // UE, RE, TE atama\n}\n```\n\nVe son olarak UART ile okuma ve yazma fonksiyonları kaldı.\nDatasheet'in 30.6.1 bölümü bize durum ragister'ı olan SR'nin\nveri hazır olduğunda set edilmiş olacağını söylüyor\n\n```c\nstatic inline int uart_read_ready(struct uart *uart) {\n  return uart->SR & BIT(5);  // Eğer RXNE biti atandıysa veri hazırdır.\n}\n```\n\nVeri bayt'ı veri register'ı DR içinden doğrudan çekilebilir\n\n```c\nstatic inline uint8_t uart_read_byte(struct uart *uart) {\n  return (uint8_t) (uart->DR & 255);\n}\n```\n\nVeri register'ı ile bir btye veri de iletilebilir. Veri yazıldıktan sonra\nstatus register'ındaki 7.bit set edilene kadar bekleyip iletimin bittiğinden\nemin olmamız gerekir.\n\n```c\nstatic inline void uart_write_byte(struct uart *uart, uint8_t byte) {\n  uart->DR = byte;\n  while ((uart->SR & BIT(7)) == 0) spin(1);\n}\n```\n\nBuffer'ı yazma:\n\n```c\nstatic inline void uart_write_buf(struct uart *uart, char *buf, size_t len) {\n  while (len-- > 0) uart_write_byte(uart, *(uint8_t *) buf++);\n}\n```\n\nArtık main() fonksiyonumuzda uart'ı başlatabiliriz.\n\n```c\n  ...\n  uart_init(UART3, 115200);              // UART'ı başlatır\n```\n\nŞimdi, LED her yandığında \"hi\\r\\n\" yazmaya hazırız\n\n```c\n    if (timer_expired(&timer, period, s_ticks)) {\n      ...\n      uart_write_buf(UART3, \"hi\\r\\n\", 4);  // Write message\n    }\n```\n\nYeniden derleyip, tekrardan yükleyip programı ST-LINK ile termilane bağlayın.\nMac ve Linux bilgisayarlarda, ben `cu` kullanıyorum. Windowsta ise `putty`\nkullanmak iyi bir tercih olabilir. programı çalıştırdığınızda şöyle bir\nmesaj göreceksiniz:\n\n```sh\n$ cu -l /dev/BURAYA_SERI_PORTUNUZ_GELECEK -s 115200\nhi\nhi\n```\n\nProjenin tam haline [steps/step-3-uart](steps/step-3-uart) klasöründen ulaşabilirsiniz.\n\n## prinf()'i UART'a uyarlama\n\nBu bölümde `uart_write_buf()` çağrısını bize formatlanmış çıktı veren `prinf()` çağrısı\nile değiştireceğiz. Bu bizim bilgi yazabilme yeteneğimizi arttıracak ve\n\"printf-style debuging\"'i implemente etmemizi sağlayacak.\n\nGNU ARM toolchain'i sadece bizim kullandığımız GCC derleyicisi veya diğer\naraçlarla gelmiyor, RedHat tarafından gömülü sistemler için geliştirilen\nnewlib adındaki C kütüphanesiyle de geliyor.\n\nIn this section, we replace `uart_write_buf()` call by `printf()` call, which\ngives us an ability to do formatted output - and increase our abilities to\nprint diagnostic information, implemeting so called \"printf-style debugging\".\nhttps://sourceware.org/newlib\n\nFirmware'imiz `strcmp()` gibi standart C fonksiyonlarını çağırdığında newlib\nkodu GCC linker'ı ile firmware'imze eklenir.\n\nnewlib'in standart C kütüphanesinden implemente ettiği özellikle de dosya\ngirdi/çıktı(IO) işlemleri gibi işlemler newlib tarafından kendine has bir\nşekilde yapılmaktadır. Bu fonksiyanlar düşük seviyeli IO fonksiyonları olan\n\"syscalls\" yani sistem çağrılarını kullanırlar.\n\nÖrnek olarak:\n\n- `fopen()` nihayetinde `_open()` fonksiyonunu çağırır\n- `fread()` `_read()` fonksiyonunu çağırır\n- `fwrite()`, `fprintf()`, `printf()` fonksiyonları `_write()` çağrısını kullanır\n- `malloc()` arka planda `_sbrk()` ile çalışır, ve bu liste uzayıp gider.\n\nBuna göre `_write()` çağrısını modifiye ederek prinft() fonksiyonuna istediğimizi\nyaptırtabiliriz. Bu mekanizma \"IO retargeting\", \"IO yeniden yönlendirme/yeniden hedefleme\"\nolarak adlandırılır.\n\nNot: STM32 Cube de aynı zamanda ARM GCC ile newlib kullanır, bundan dolayı\ngenellikle Cube projeleri `syscalls.c` dosyasını include ederler.TI'ın CCS'si, Keil'ın\nderleyicisi gibi diğer toolchain'lerde farklı c kütüphaneleri ile küçük\nfarklılıkları olan retargeting mekanizmalarını kullanırlar. Biz newlib\nkullanarak `_write()` çağrısını UART3 için modifiye edeceğiz.\n\nBaşlamadan önce kodumuzu şu şekilde modifiye edeceğiz:\n\n- Tüm API tanımlamalarını `hal.h` (Harware Abstraction Layer/Donanım Soyutlama Katmanı)\n  dosyasına taşıyalım.\n- başlangıç kodumuzu `startup.c` dosyasına taşıyalım\n- newlib sistem çağrıları için `syscalls.c` adında yeni bir dosya oluşturalım\n- Makefile'ın build'ini `syscalls.c` ve `startup.c` dosyaları için\n\nTüm API tanımlamalarını `hal.h`'a taşıdıktan sonra `main.c` dosyamız daha öz\nhale geldi. Daha anlaşılır ve kolay düşük seviyeli işler yapmak için bunu\naklınızda bulundurun.\n\n```c\n#include \"hal.h\"\n\nstatic volatile uint32_t s_ticks;\nvoid SysTick_Handler(void) {\n  s_ticks++;\n}\n\nint main(void) {\n  uint16_t led = PIN('B', 7);            // Mavi LED\n  systick_init(16000000 / 1000);         // Her 1 ms için tikleme\n  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Mavi LED'i output olarak ayarlıyoruz\n  uart_init(UART3, 115200);              // UART'ı başlat\n  uint32_t timer = 0, period = 500;      // Timer'ı tanımla ve periyodunu 500ms olarak ayarla\n  for (;;) {\n    if (timer_expired(&timer, period, s_ticks)) {\n      static bool on;                      // Bu blog çalıştırılacak\n      gpio_write(led, on);                 // Her `period` milisaniyesinde\n      on = !on;                            // Led'in durumunu tersle\n      uart_write_buf(UART3, \"hi\\r\\n\", 4);  // Mesajı yaz\n    }\n    // Diğer işlemlerinizi burada yapabilirsiniz.\n  }\n  return 0;\n}\n```\n\nTamamdır, artık printf'i UART3 için retarget'leyebiliriz. Boş olan\nsyscalls.c dosyasına aşağıdaki kodu kopyalayıp yapıştırın\n\n```c\n#include \"hal.h\"\n\nint _write(int fd, char *ptr, int len) {\n  (void) fd, (void) ptr, (void) len;\n  if (fd == 1) uart_write_buf(UART3, ptr, (size_t) len);\n  return -1;\n}\n```\n\nŞimdi şunu yapacağız: Eğer dosya tanımlayıcıs(file descriptor) 1 ise\nki bu standart output'tur, buffer'ı UART3'e yaz aksi taktirde görmezden\ngel. İşte bu retargetingiz özüdür.\n\nFirmware'i yeniden derlediğimizde şu hata dizisi bizi karşılar:\n\n```sh\n../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-sbrkr.o): in function `_sbrk_r':\nsbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk'\ncloser.c:(.text._close_r+0xc): undefined reference to `_close'\nlseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek'\nreadr.c:(.text._read_r+0x10): undefined reference to `_read'\nfstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat'\nisattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty'\n```\n\nnewlib stdio fonksiyonlarını kullandığımız andan itibaren diğer newlib\ndiğer çağrıları da oluşturmamız gerekiyor. `prinff()` ve `malloc()`\nfonksiyonlarının kullandığı `_sbrk()` çağrısı dışındakileri\nkullanmayacağımız için basitçe hiçbirşey yapmayacak şekilde tanımlayacağız.\n\n```c\nint _fstat(int fd, struct stat *st) {\n  (void) fd, (void) st;\n  return -1;\n}\n\nvoid *_sbrk(int incr) {\n  extern char _end;\n  static unsigned char *heap = NULL;\n  unsigned char *prev_heap;\n  if (heap == NULL) heap = (unsigned char *) &_end;\n  prev_heap = heap;\n  heap += incr;\n  return prev_heap;\n}\n\nint _close(int fd) {\n  (void) fd;\n  return -1;\n}\n\nint _isatty(int fd) {\n  (void) fd;\n  return 1;\n}\n\nint _read(int fd, char *ptr, int len) {\n  (void) fd, (void) ptr, (void) len;\n  return -1;\n}\n\nint _lseek(int fd, int ptr, int dir) {\n  (void) fd, (void) ptr, (void) dir;\n  return 0;\n}\n```\n\nŞimdi hata almadan yeniden derleyebilirsiniz. Son adım olarak\n`main()`'deki `uart_write_buf()` fonksiyonunu `printf()` ile\ndeğiştirip artık kullanışlı bir şekilde LED durumunu veya systick sayısını\nyazdırabileceğiz.\n\n```c\nprintf(\"LED: %d, tick: %lu\\r\\n\", on, s_ticks);  // Write message\n```\n\nSeri çıktı şöyledir:\n\n```sh\nLED: 1, tick: 250\nLED: 0, tick: 500\nLED: 1, tick: 750\nLED: 0, tick: 1000\n```\n\nTebrikler! Artık IO retargeting nasıl çalışıyor biliyoruz ve\nfirmware'imiz için printf-style gebug yapabiliyoruz.\n\nKodun tam haline [steps/step-4-printf](steps/step-4-printf) klasöründen ulaşabilirsiniz.\n\n## Segger Ozone ile debug\n\nFirmware'iniz bir yerde takılsa ve printf çalışmasaydı ne olurdu? Ya eğer\nstartup kodunuz bile çalışmıyorsa? Kesinlikle gerçek bir debuger'a ihtiyacımız\nvar. Bu konuda birden fazla seçenek bulunurken ben Ozone debuger'ını kullanmanızı\ntavsiye ederim. Herhangi bir IDE kurulumuna ihtiyaç duymaz. Ozone'a doğudan\n`firmwere.elf` dosyasını verdiğimizde gidip kaynak dosyalarımıza erişir.\n\nÖyleyse, Ozone'ı [Segger'ın sitesinden](https://www.segger.com/products/development-tools/ozone-j-link-debugger/) indirebilirsiniz. Nucleo kartımızla kullanmadan önce ST-LINK firmware'ini\nOzone'un anlayabildiği jlink firmware'ine dönüştürmemiz lazım.\nSegger'in sitesindeki [adımları](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/) takip edin.\n\nArtık Ozone'u çalıştırabiliriz. Cihaz gezgininden seçiminizi yapın:\n\n<img src=\"images/ozone1.png\" width=\"50%\" />\n\nKullanmak istediğiniz debugger'ı seçin(bizim için bu ST-LINK olacak):\n\n<img src=\"images/ozone2.png\" width=\"50%\" />\n\nfirmware.elf dosyanızı seçin\n\n<img src=\"images/ozone3.png\" width=\"50%\" />\n\nBir sonraki sayfayı da varsayılan ayarlarla geçtikten sonra \"Finish\" tuşuna basın\nve debugger'ımız yüklendi(hal.h dosyasındaki kodu not alın):\n\n![](images/ozone4.png)\n\nİndirmek için yeşil tuşa basın, firmware'i çalıştırın ve şurada durun:\n\n![](images/ozone5.png)\n\nArtık kodu adım adım geçebiliriz. breakpoint koyun ve sonra sıradan debugging\nişlerinizi yapın. Not etmeniz gereken bir şey de Ozone'un çevre birimleri sayfasıdır:\n\n![](images/ozone6.png)\n\nBunu kullanarak doğrudan çevre biriminin durumunu anlayabiliriz. Örnek olarak\ngelin karttaki yeşil LED(PB0)'i yakalım.\n\n1. İlk önce GPIOB'yi clock'lamalıyız. Peripherals -> RCC -> AHB1ENR şeklinde\n   ilerleyin ve GPIOBEN'yi 1 yapın\n   <img src=\"images/ozone7.png\" width=\"75%\" />\n2. Peripherals -> GPIO -> GPIOB -> MODER ile MODER0'ı 1 yapın (output):\n   <img src=\"images/ozone8.png\" width=\"75%\" />\n3. Peripherals -> GPIO -> GPIOB -> ODR ile ODR0'ı 1 yapın (on/açık):\n   <img src=\"images/ozone9.png\" width=\"75%\" />\n\nŞimdi yeşil LED yanmış olmalı. Mutlu debug'lamalar.\n\n## CMSIS başlıklarını vendor'lama\n\nGeçen bölümde sadece datasheet, editör ve GCC derleyicisini kullanarak firmware\ngeliştirmiştik. Yine sadece datasheet kullanıp elimizle yazılımsal çevre birimi\nyapısı tanımlamıştık.\n\nArtık işlerin nasıl yürüdüğünü biliyorsunuz, işte şimdi CMSIS başlıklarını\ntanıtma zamanı. Peki ne olaki bu? MCU vendor'u tarafından oluşturulan ve\nkullanılan tüm tanımların bulunduğu başlık dosyalarıdır. MCU'nun içerdiği\nher şeyin tanımlamasını taşır ve de bundan fazlası da vardır.\n\nCommon Microcontroller Software Interface Standard(Genel mikrodenetleyici\nyazılım arayüzü standartı)'ın kısaltması olan CMSIS, MCU üreticileri\ntarafından çevre birimlerini özelleştirmeye zeminini dayandırır.\nCMSIS ARM standartı olduğundan beri CMSIS başlıkları tüm MCU Vendor'ları\ntarafından desteklenmekte ve yetkili olarak kabul edilmektedir. Bundan dolayı\ntanımlamaları elle yapmaktansa vendor başlıklarının kullanılması daha fazla\ntercih edilir.\n\nİki farklı CMSIS başlık anlayışı vardır, bunlar:\n\n- İlki, ARM Core CMSIS başlıklarıdır. Bunlar ARM'ın tabanıdır ve ARM'ın GitHub\n  sayfasından yayınlanırlar. https://github.com/ARM-software/CMSIS_5\n- İkincisi, MCU vendor CMSIS başlıklarıdır. MCU çevre birimlerini açıklarlar\n  ve MCU Vendor'ları tarafından yayınlanırlar. Bizim örneğimizde bu ST tarafından\n  yayınlanan olacak. https://github.com/STMicroelectronics/cmsis_device_f4\n\nÖrnek olması için şu Makefile snippet'ini çekebiliriz:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/785aa2ead0432fc67327781c82b9c41149fba158/step-5-cmsis/Makefile#L27-L31\n\nST CMSIS paketi aynı zamanda bize tüm MCU'larına dair startup dosyalarını da sunar.\nBunu elle yazdığımız startup.c yerine de kullanabiliriz. ST tarafından verilen\nstartup dosyası `SystemInit()` fonksiyonunu çağırırır.\nDolayısıyla bunu `main.c` içinde tanımlayacağız.\n\nHadi gelin şimdi `hal.h` dosyasındaki kendi API fonksiyonlarımızı CMSIS\ntanımlamalarını kullanarak değiştirelim ve bırakalım firmware\ngerisini halletsin. `hal.h` dosyasından tüm çevre birimi API'larını ve\ntanımlamaları kaldırıyoruz ve sadece standart C include'larını, vendor CMSIS include'larını, PIN/BIT/FREQ tanımlamalarını ve `timer_expired()` yardımcı fonksiyonunu bırakıyoruz.\n\nEğer `make clean build` ile yeniden derlemeye çalışırsak GCC `systick_init()`, `GPIO_MODE_OUTPUT`, `uart_init()` ve `UART3`'ü bulamadığını söyleyecektir. Bunları hemen STM32 CMSIS dosyaları ile ekleyelim.\n\n\n`systick_init()` fonksiyonuyla yola çıkalım. ARM core CMSIS başlığı bize\n`SysTick_Config()` adında ve bunla aynı şeyi yapan bir tanımlama veriyor\nbu yüzden doğrudan bunu kullanacağız.\n\nBir sonraki noktamız `gpio_set_mode()` fonksiyonu. `stm32f429xx.h` header'ı\nbizim `struct gpio` ile tıpatıp aynı olan `GPIO_TypeDef` yapısını içeriyor.\nBunu kullanabiliriz:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/52e1a8acd30e60eba4c119e22b609571e39a86e0/step-5-cmsis/hal.h#L24-L28\n\n\n\n `gpio_set_af()` ve `gpio_write()` fonksiyonları da neredeyse hazır tek\n yapmamız gereken `struct gpio` ile `GPIO_TypeDef`'i değiştirmek ve tadaa.\n\nSıra UART'ta. USART1'i, USART2'yi ve USART3'ü tanımlayan  `USART_TypeDef`\ntanımlaması bulunmakta.\n\n```c\n#define UART1 USART1\n#define UART2 USART2\n#define UART3 USART3\n```\n\n`uart_init()`'in içindeki hiçbir UART fonksiyonuna dokunmadan `struct uart`'ı\n`USART_TypeDef` olarak değiştirelim.\n\nVe artık işimiz bitti. Firmware'i yeniden derle ve yeniden yükle. LED yanıp söner\nve UART'tan veri görünmeye başlar. Tebrikler, firmware kodumuzu vendor dosyalarına\nbaşarıyla adapte ettik. Şimdi tüm standat dosyalarımızı `include` klasörüne taşıyarak\nrepo'muzu birazcık daha organize hale getirelim ve Makfile dosyamızı GCC'nin dediği\ngibi düzenleyelim.\nhttps://github.com/cpq/bare-metal-programming-guide/blob/785aa2ead0432fc67327781c82b9c41149fba158/step-5-cmsis/Makefile#L4\n\nAynı zamanda CMSIS başlıklarımızı bağımlılık olarak ekleyelim\nhttps://github.com/cpq/bare-metal-programming-guide/blob/785aa2ead0432fc67327781c82b9c41149fba158/step-5-cmsis/Makefile#L18\n\nBunu ileride tekrardan kullanmak için template bir proje olarak bırakıyoruz. Projenin tamamına [steps/step-5-cmsis](steps/step-5-cmsis) klasöründen ulaşabilirsiniz.\n\n\n## Clock'ları ayarlamak\n\nBoot'tan sonra Nucleo-F429ZI işlemcisi 16MHz'de koşar. Maksimum frekansı 180MHz'dir.\nİlgilenmemiz gereken tek şeyin sistem frekansı olmadığını aklınızın bir köşesine not alın.\nÇevre birimleri, APB1 ve APB2 gibi farklı clock'lanmış farklı bus'lara bağlıdır.\nBunların saat hızları RCC'ye atanan preskaler frekans değerleri ile configre edilir.\nAna CPU clock'u kaynağını farklı yerden alır-harici bir kristal osilatör(HSE)\nveya bir dahili osilatör(HSI) kullanarak da yapılabilir-. Şu anda biz HSI\nkullanmayı tercih edeceğiz.\n\nİşlemci flash içinden komutları yürütürken, eğer işlemci clock'u flash'ın\nokuma hızından(ki bu 25Mhz civarındadır) daha fazla olursa darboğaz oluşur.\nBunun için birkaç kurnazlık bize yardımcı olabilir. Komutları önceden okumak bunların\nilkidir. Aynı zamanda flash kontrolcüsüne flash latency'i kullanarak sistem saatinin\nhızı hakkında ipucu verebiliriz. 180Mhz clock için `FLASH_LATENCY` değeri 5'tir.\nFlash kontrolcüsünün komut aktifleştirme ve veri cache'leme özelliğini 9. ve\n5.bitleri ile açabiliriz.\n```c\n  FLASH->ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash gecikmesi, cache'leme\n```\n\nClock kaynağı(HSI veya HSE) PLL diye adlandırılan ve gelen frekansı katlayan\nbir donanım parçasına gider. Ardından bir dizi frekans bölücüsü sistem clock'ını\nve APB1, APB2 clock'ları ayarlamak için kullanılır. Sistem clock'u maksimum 180MHz\nolmak şartıyla birden PLL bölücü değeri ve APB preskaler'leri olması mümkündür.\nBölüm 6.3.3'te datasheet bize APB1 clock değerinin minimum 45MHz ve APB2 clock\ndeğerinin minimum 90Mhz olması gerektiğini söyler. Bu da bize kombinasyonlarla\ndolu bir listemizin olabileceğini anlatır. Burada manuel olarak değerleri seçiyoruz.\nCubeMX gibi bu işlemi kolaylaştıran ve görselleştiren tool'ların olduğunu unutmayın.\n\nhttps://github.com/cpq/bare-metal-programming-guide/blob/9a3f9bc7b07d6a2a114581979e5b6715754c87c1/step-6-clock/hal.h#L20-L28\n\nŞimdi işlemci ve çevre birimleri için şöyle görülen basit bir clock ayarlama\nalgoritmasını yazmaya hazırız.\n\n- FPU'u aç (opsiyoneldir)\n- Flash latency'i ayarla\n- Clock kaynağına, PLL, ARB1 ve APB2 preskaler'lerine karar ver\n- RCC'yi bunlara göre ata\n- Clock başlatımını tüm dosyalardan `sysinit.c` dosyasındaki startup kodunda otonatik\n  olarak çağrılan `SystemInit()` fonksiyonuna topla\n\nhttps://github.com/cpq/bare-metal-programming-guide/blob/9a3f9bc7b07d6a2a114581979e5b6715754c87c1/step-6-clock/sysinit.c#L10-L26\n\n`hal.h` dosyasındaki özellikle de UARt başlatma kodunu düzenlememiz lazım.\nFarklı UART kontrolcüleri farklı bus'larla çalışır: UART1 hızlı APB2 ile,\ngeri kalan UART'lar ise görece daha yavaş olan APB1 ile çalışır. 16MHz'lik\nvarsayılan clock üzerinde çalışırken bir farklılık yoktur. Fakat daha yüksek\nhızlar istediğimizde APB1 ve APB2 farklılaşırlar. Bu da bize UART için\nbaud rate hesaplaması yapmamızı elzem hale getirir.\n\nhttps://github.com/cpq/bare-metal-programming-guide/blob/9a3f9bc7b07d6a2a114581979e5b6715754c87c1/step-6-clock/hal.h#L90-L107\n\nYeniden derleyip yeniden yüklediğimizde kartımız maksimum hız olan 180MHz'de çalışacaktır.\nProjenin tamamlanmış hanile [steps/step-6-clock](steps/step-6-clock) klasöründen erişebilirsiniz.\n\n## Web sunucusu ve cihaz dashboard'u\n\nNucleo-F429ZI gömülü Ethernet ile birlikte gelir. Ethernet donanımı iki\nkomponente ihtiyaç duyar: bir PHY(bakır veya optik gibi ortamlardan elektrik\nsinyali aktaran ve alan cihaz) ve MAC(PHY kontrolcüsünü sürer). Nucleo'muzda\nMAC kontrolcüsü dahiliyken PHY haricidir(özellikle de Microchip'in LAN8720a'sı).\n\nMAC ve PHY birden fazla arayüz ile konuşabilir, biz RMII kullanacağız.\nBunun için alternatif fonksiyon(AF) kullanabilmek adına bir ton pin konfigre edilmelidir.\nWeb sunucusunu implemente etmek için 3 yazılım komponentine ihtiyaç duyarız:\n\n- MAC kontrolcüsüyle Ethernet frame'lerini alıp gönderen network sürücüsü\n- TCP/IP frame'lerini parçalayan ve anlayan bir network stack'i\n- HTTP'yi anlayan bir network kütüphanesi\n\nBunların hepsini tek bir dosyayla implemente etmek için  [Mongoose Network Kütüphanesini](https://github.com/cesanta/mongoose)\nkullanacağız. Bu hızlı ve kolay gömülü network geliştirmesi için tasarlanmış\nve (GPLv2/commercial) ile lisanslanmıştır.  \n\nO zaman, [mongoose.c](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c) ve [mongoose.h](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h) dosyasını projemize kopyalayın.\nArtık elimizde bir sürücümüz, network stack'imiz ve kütüphanemiz var.\nMongoose hem de geniş bir örnek setini bize sunar ve bunlardan birisi de [cihaz dashboard örneğidir](https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard).\nBu login, WebSocket üzerinden gerçek zamanlı veri alışverişi, gömülü dosya sistemi,\nMQTT iletişimi gibi şeyleri de implemente eder.Hadi gelin bu örneği yapalım. İki dosyayı ekstradan kopyalayın:\n\n- [net.c](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/net.c) - dashboard fonksiyonelitesini implemente eder.\n- [packed_fs.c](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/packed_fs.c) -  HTML/CSS/JS GUI dosyalarını içerir.\n\nMongoose'a fonksiyonalitesini devreye sokmayı söylememiz kaldı. Preprocessor\nflag'larını ayarlayadak bu da hemencecik hallolacaktır. Alternatif olarak\n`mongoose_customs.h` dosyasında da bunları tanımlayabilirsiniz.\nHadi gelin ikinci yolu yapıp `mongoose_custom.h` dosyasını oluşturalım\nve şunları içine atalım:\n\n```c\n#pragma once\n#define MG_ARCH MG_ARCH_NEWLIB\n#define MG_ENABLE_MIP 1\n#define MG_ENABLE_PACKED_FS 1\n#define MG_IO_SIZE 512\n#define MG_ENABLE_CUSTOM_MILLIS 1\n```\nŞimdi main.c'te biraz networkink kodu ekleme zamanı. `#include \"mongoose.c\"`\nile Ethernet RMII pinlerini alıyoruz ve RCC içinden Etherneti aktifleştiriyoruz.\n\n```c\n  uint16_t pins[] = {PIN('A', 1),  PIN('A', 2),  PIN('A', 7),\n                     PIN('B', 13), PIN('C', 1),  PIN('C', 4),\n                     PIN('C', 5),  PIN('G', 11), PIN('G', 13)};\n  for (size_t i = 0; i < sizeof(pins) / sizeof(pins[0]); i++) {\n    gpio_init(pins[i], GPIO_MODE_AF, GPIO_OTYPE_PUSH_PULL, GPIO_SPEED_INSANE,\n              GPIO_PULL_NONE, 11);\n  }\n  nvic_enable_irq(61);                          // Ethernet IRQ handler'ını ayarlama\n  RCC->APB2ENR |= BIT(14);                      // SYSCFG aktifleştirme\n  SYSCFG->PMC |= BIT(23);                       // ilk önce RMII kullanımı geliyor\n  RCC->AHB1ENR |= BIT(25) | BIT(26) | BIT(27);  // Ethernet clocks aktifleştirme\n  RCC->AHB1RSTR |= BIT(25);                     // ETHMAC'i zorla resetleme\n  RCC->AHB1RSTR &= ~BIT(25);                    // ETHMAC resetini kaldırma\n```\n\nMongoose'un sürücüsü Ethernet kesmesini kullanır, bu da `startup.c`'yi güncelleyip\n`ETH_IRQHandler`'o vektör tablosuna eklememize ihtiyacı var demek oluyor.\n`startup.c`'deki vektör tablosunu kesme fonksiyonunda bir değişikliğe ihtiyaç duymadan\ntekrardan organize edelim. \"weak symbol\" konsepti ana fikrimiz olacak\n\n\"weak/zayıf\" olarak işaretlenen fonksiyonlar aynı normal fonksiyonlar gibi çalışır.\nNormal fonksiyonlardan farkı, aynı isimde başka bir yerde iki fonksiyon olduğunda\nbuild anında hata alırken eğer bir fonksiyon weak olarak işaretlendiyse derleme hatası\nalınmamasından ve linker'ın non-weak fonksiyonu seçmesinden gelir. Bu da bize\nboilerplate'lere \"varsayılan\" fonksiyon atayabilme özelliğini verir. Aynı isimde\nyeni bir fonksiyonla o fonksiyonu ezerek kendi işleyişinizi yazabilirsiniz.\n\nİşte karşınızda bizim için bu konunun kullanımı. Vektör tablosuna varsayılan bir handler\natamak istiyoruz ama kullanıcı da bunu istediği handler'la ezebilmeli. Bunun için\n`DefaultIRQHandler()` adında weak olan bir fonksiyon oluşturuyoruz ardından\nher bir IRQ handler için handler ismi tanımlıyor ve `DefaultIRQHandler()`'la alias\noluşturuyoruz.\n\n```c\nvoid __attribute__((weak)) DefaultIRQHandler(void) {\n  for (;;) (void) 0;\n}\n#define WEAK_ALIAS __attribute__((weak, alias(\"DefaultIRQHandler\")))\n\nWEAK_ALIAS void NMI_Handler(void);\nWEAK_ALIAS void HardFault_Handler(void);\nWEAK_ALIAS void MemManage_Handler(void);\n...\n__attribute__((section(\".vectors\"))) void (*const tab[16 + 91])(void) = {\n    0, _reset, NMI_Handler, HardFault_Handler, MemManage_Handler,\n    ...\n```\n\nArtık herhangi bir IRQ handler'ını kodumuzda tanımlayabiliriz ve onu varsayılanıyla\ndeğiştirebiliriz. Bizim için işleyiş şöyle olacak: Mongoose'un STM32 sürücüsü olarak\ntanımlanan `ETH_IRQHandler()`'ı varsayılan handler'la değiştireceğiz\n\nSonraki adımımız Mongoose kütüphanesini başlatmak: bir event maneger' oluşturun,\nnetwork sürücünüzü ayarlayın ve HTTP'ye bağlanıp dinlemeye başlayın:\n\n```c\n  struct mg_mgr mgr;        // Mongoose event manager'ını başlatır\n  mg_mgr_init(&mgr);        // MIP arayüzüyle bağlar\n  mg_log_set(MG_LL_DEBUG);  // log seviyesini ayarlar\n\n  struct mip_driver_stm32 driver_data = {.mdc_cr = 4};  // driver_stm32.h'a bakınız\n  struct mip_if mif = {\n      .mac = {2, 0, 1, 2, 3, 5},\n      .use_dhcp = true,\n      .driver = &mip_driver_stm32,\n      .driver_data = &driver_data,\n  };\n  mip_init(&mgr, &mif);\n  extern void device_dashboard_fn(struct mg_connection *, int, void *, void *);\n  mg_http_listen(&mgr, \"http://0.0.0.0\", device_dashboard_fn, &mgr);\n  MG_INFO((\"Init done, starting main loop\"));\n```\n\nPeki geriye ne kaldı, tabii ki `mg_mgr_poll()` çağrısını main döngüsüne eklemek.\n\nŞimdi `mongoose.c`, `net.c` ve `packed_fs.c` dosyalarını Makefile'a ekleyelim.\nYeniden derleyelim ve tekrardan karta yükleyelim. Debug çıktısı için seri konsolu\nekleyelim, DHPC üzerinden gelen karta atanan IP adresi inceleyelim:\n\n```\n847 3 mongoose.c:6784:arp_cache_add     ARP cache: added 0xc0a80001 @ 90:5c:44:55:19:8b\n84e 2 mongoose.c:6817:onstatechange     READY, IP: 192.168.0.24\n854 2 mongoose.c:6818:onstatechange            GW: 192.168.0.1\n859 2 mongoose.c:6819:onstatechange            Lease: 86363 sec\nLED: 1, tick: 2262\nLED: 0, tick: 2512\n```\n\nTarayıcınızdan IP adresini açın ve MQTT, kullanıcı doğrulama ve diğer şeyler\nile WebSocket üzerinden gerçek zamanlı grafiklerin keyfine varın.\nBakınız:\nDaha fazla bilgi için [detaylı açıklama](https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard)\n\n\n![Cihaz dashboard'ı](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/screenshots/dashboard.png)\n\nProjenin tamamına [steps/step-7-webserver](steps/step-7-webserver) klasöründen erişebilirsiniz.\n\n## Otomatikleştirilmiş firmware derlenmesi (software CI)\n\nYazılım projelerindeki güzel pratiklerden birisi de devamlı entegrasyon(CI)'dır.\nRepository'e her push geldiğinde CI otomatik olarak yeniden build alır\nve tüm komponentleri testeder.\n\nGitHub bunu yapmayı oldukça kolaylaştırıyor. Sadece `.github/workflows/test.yml`\nkonfigrasyon dosyasını oluşturmamız yeterli. Dosyada ARM GCC'yi kurup `make`\nkomutunu çalıştırarak her örnek klasörünü derleyebiliriz.\n\nUzun lafın kısası! GitHub'a her push'ta işlem yapmasını söyleyebiliriz.:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/b0820b5c62b74a9b4456854feb376cda8cde4ecd/.github/workflows/test.yml#L1-L2\n\nThis installs ARM GCC compiler:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/b0820b5c62b74a9b4456854feb376cda8cde4ecd/.github/workflows/test.yml#L9\n\nThis builds a firmware in every example directory:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/b0820b5c62b74a9b4456854feb376cda8cde4ecd/.github/workflows/test.yml#L10-L18\n\nİşte bu kadar. Aşırı basit ve aşırı güçlü. Eğer artık bir değişiklik yapıp repo'ya\nbuild'i başlatacak, GitHub bize bildirim yollayacak ve başarılı olursa GitHub kendi\nişine devam edecek. Örneği inceleyebilirsiniz [example successful\nrun](https://github.com/cpq/bare-metal-programming-guide/actions/runs/3840030588).\n\n## Otomatikleştirilmiş firmware testi (hardware CI)\n\nGerçek bir donanımda derlenmiş firmware yazılımını sadece derleme sürecini değil,\naynı zamanda doğru ve işlevsel olup olmadığını da test etmek harika olmaz mıydı?\n\nBu tür bir sistemi ad hoc olarak oluşturmak kolay değildir. Örneğin,\nözel bir test istasyonu kurabilir, test edilmiş bir cihazı\n(örneğin, Nucleo-F429ZI kartı) bağlayabilir ve yerleşik bir hata ayıklama\naracı kullanarak uzaktan firmware yükleme ve test için bir yazılım\nyazabilirsiniz. Bu mümkün olsa da, kırılgandır, çok çaba gerektirir\nve dikkat gerektirir.\n\nAlternatif olarak, ticari donanım test sistemlerinden birini veya EBF'leri\n(Gömülü Kart Çiftlikleri) kullanabilirsiniz, ancak bu ticari çözümler oldukça pahalıdır.\n\nAncak, kolay bir yol vardır\n\n### Çözüm: ESP32 + vcon.io\n\nhttps://vcon.io servisini kullanarak, uzaktan firmware güncellemesi ve\nUART izleyici uygulayan bir hizmeti kullanabiliriz:\n\n1. Herhangi bir ESP32 veya ESP32C3 cihazı alın (örneğin, herhangi birucuz geliştirme kartı).\n   Önceden derlenmiş bir firmware'i cihaza yükleyerek, ESP32'yi uzaktan kontrol edilebilen\n   bir programlayıcıya dönüştürün.\n2. ESP32'yi hedef cihaza bağlayın: Flashlama için SWD pinleri, çıktıyı yakalamak için UART pinleri.\n3. ESP32'yi https://dash.vcon.io yönetim paneline kaydetmek için yapılandırın.\n4. Bu işlem tamamlandığında, hedef cihazınızın yetkilendirilmiş ve güvenli bir RESTful\n   API'si olacak ve cihazın firmware'ini yeniden yazabilir ve cihaz çıktısını yakalayabilirsiniz.\n   Bu API herhangi bir yerden çağrılabilir, örneğin yazılım sürekli entegrasyonundan (CI) çağrılabilir.\n\n![VCON module operation](images/hero.svg)\n\nNot: [vcon.io](https://vcon.io) hizmeti, çalıştığı şirket olan Cesanta tarafından sunulmaktadır.\nBu ücretli bir hizmet olup, belirli bir sınıra kadar ücretsiz kullanım imkanı sunmaktadır.\nEğer yönetilmesi gereken sadece birkaç cihazınız varsa, tamamen ücretsiz olarak kullanabilirsiniz.\n\n### Configuring and wiring ESP32\n\nESP32 veya ESP32C3 cihazınızı alın-başka bir geliştirme kartı, bir modül\nveya özel bir cihaz olabilir-. Önerim ESP32C3 XIAO geliştirme kartıdır\n([Digikey'den satın alın](https://www.digikey.ie/en/products/detail/seeed-technology-co-ltd/113991054/16652880))\nçünkü düşük fiyatı (yaklaşık 5 EUR) ve küçük form faktörüne sahip olmasıdır.\n\nHedef cihazın bir Raspberry Pi\n[W5500-EVB-Pico](https://docs.wiznet.io/Product/iEthernet/W5500/w5500-evb-pico)\nkartı olduğunu varsayalım ve bu kartın üzerinde dahili bir Ethernet arabirimi bulunmaktadır.\nEğer cihazınız farklı ise,\n\"Bağlantı Şeması\" adımını cihazınızın pin düzenine göre ayarlayın.\n\n- ESP32'nizi programlamak için [ESP32 Flashlama](https://vcon.io/docs/#module-flashing) adımlarını izleyin.\n- ESP32'nizi https://dash.vcon.io üzerinde kaydetmek için [Ağ Kurulumu](https://vcon.io/docs/#module-registration) adımlarını izleyin.\n- ESP32'nizi cihazınıza bağlamak için [Bağlantı Şeması](https://vcon.io/docs/#module-to-device-wiring) adımlarını izleyin.\n\nAşağıda, yapılandırılmış bir cihaz breadboard düzeni örneği bulunmaktadır:\n![](images/breadboard.webp)\n\nAşağıda, yapılandırılmış bir cihaz kontrol paneli örneği bulunmaktadır:\n![](images/screenshot.webp)\n\nArtık cihazınızı tek bir komutla yeniden programlayabilirsiniz:\n\n```sh\ncurl -su :API_KEY https://dash.vcon.io/api/v3/devices/ID/ota --data-binary @firmware.bin\n```\n\nBurada, `API_KEY`, dash.vcon.io kimlik doğrulama anahtarını temsil eder, ID, kaydedilmiş\ncihaz numarasını temsil eder ve `firmware.bin`, yeni derlenmiş firmware'in adını temsil eder.\n\"api key\" bağlantısına tıklayarak `API_KEY`'i alabilirsiniz. Cihaz Kimliği tabloda listelenir.\n\nAyrıca, cihaz çıktısını tek bir komutla yakalayabiliriz:\n\n```sh\ncurl -su :API_KEY https://dash.vcon.io/api/v3/devices/ID/tx?t=5\n```\n\nBurada, `t=5`, UART çıktısını yakalarken 5 saniye beklemeyi temsil eder.\n\nArtık bu iki komutu herhangi bir yazılım CI platformunda kullanarak yeni bir\nfirmware'i gerçek bir cihazda test edebilir ve cihazın UART çıktısını bazı beklenen\nanahtar kelimelere karşı test edebilirsiniz.\n\n### Github Actions'la entegrasyon\n\nFirmamızın yazılım sürekli entegrasyonu (CI) sistemi, bize bir firmware\nimajı oluşturuyor. Bu imajı gerçek bir donanım üzerinde test etmek harika\nolurdu. Ve şimdi bunu yapabiliriz! Bunun için `curl` aracını kullanarak,\noluşturulan firmware'ı test kartına gönderen ve hata ayıklama çıktısını\nyakalayan birkaç ekstra komut eklememiz gerekiyor.\n\n`curl` komutu, gizli bir API anahtarı gerektirir ve bunu kamuya açık bir\nşekilde paylaşmak istemeyiz. Doğru yol, aşağıdaki adımları izleyerek proje\nayarlarına, secret key eklemek:\n\n1. Proje ayarlarına git: `Settings / Secrets / Actions`\n2. \"New repository secret\" düğmesine tıkla\n3. Bir isim ver, `VCON_API_KEY` olarak adlandıralım. Değeri \"Secret\" kutusuna yapıştır\n   ve \"Add secret\" düğmesine tıkla.\n\nÖrnek projelerden biri, RP2040-W5500 kartı için bir firmware oluşturuyor,\nbu yüzden `curl` komutunu ve kaydedilen bir API anahtarını kullanarak bu\nfirmware'ı yükleyelim. Bunun için en iyi yol, test etme için bir Makefile\nhedefi eklemek ve Github Actions(yazılımsal CI)'ın bunu çağırmasına izin vermek:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/8d419f5e7718a8dcacad2ddc2f899eb75f64271e/.github/workflows/test.yml#L18\n\nNot: make'e `VCON_API_KEY` ortam değişkenini aktarıyoruz. Ayrıca,\n`test` Makefile hedefini çağırıyoruz. Bu hedef, firmware'ı oluşturacak\nve test edecektir. İşte `test` Makefile hedefi:\nhttps://github.com/cpq/bare-metal-programming-guide/blob/d9bced31b1ccde8eca4d6dc38440e104dba053ce/step-7-webserver/pico-w5500/Makefile#L32-L39\n\nAçıklaması:\n\n- Satır 34: `test` hedefi, `upload` hedefine bağımlıdır, bu yüzden önce\n  `upload` hedefi çalıştırılır (satır 38'de görülebilir).\n- Satır 35: UART kaydını 5 saniye boyunca yakalar ve `/tmp/output.txt`'ye kaydeder.\n- Satır 36: Çıktıda `Ethernet: up` dizgisini arar ve bulunamazsa hata döndürür.\n- Satır 38: `upload` hedefi, `build` hedefine bağımlıdır, bu yüzden her zaman\n  test etmeden önce firmware'ı derleriz.\n- Satır 39: Firmware'ı uzaktan yükleriz. `curl` aracındaki `--fail` bayrağı,\n  sunucudan gelen yanıtın başarılı olmadığında (HTTP 200 OK değilse) hata döndürmesini sağlar.\n\nYukarıdaki açıklamalar doğrultusunda `make test` komutunun örnek çıktısında şöyledir:\n\n```sh\n$ make test\ncurl --fail ...\n{\"success\":true,\"written\":59904}\ncurl --fail ...\n3f3 2 main.c:65:main                    Ethernet: down\n7d7 1 mongoose.c:6760:onstatechange     Link up\n7e5 3 mongoose.c:6843:tx_dhcp_discover  DHCP discover sent\n7e8 2 main.c:65:main                    Ethernet: up\n81d 3 mongoose.c:6726:arp_cache_add     ARP cache: added 192.168.0.1 @ 90:5c:44:55:19:8b\n822 2 mongoose.c:6752:onstatechange     READY, IP: 192.168.0.24\n827 2 mongoose.c:6753:onstatechange            GW: 192.168.0.1\n82d 2 mongoose.c:6755:onstatechange            Lease: 86336 sec\nbc3 2 main.c:65:main                    Ethernet: up\nfab 2 main.c:65:main                    Ethernet: up\n```\nTebrikler! Şimdi otomatik testlerimiz, firmware'ın oluşturulabilmesini, başlatılabilmesini\nve ağ'ın doğru şekilde başlatılmasını sağlar. Bu mekanizma kolayca genişletilebilir:\nFirmware binary dosyasına daha karmaşık eylemler ekleyin, sonucu UART'a yazdırın ve\ntestte beklenen çıktıyı kontrol edin.\n\nMutlu testler!\n"
        },
        {
          "name": "README_zh-CN.md",
          "type": "blob",
          "size": 59.1923828125,
          "content": "# 裸机编程指南\n\n[![License: MIT](https://img.shields.io/badge/license-MIT-blue)](https://opensource.org/licenses/MIT)\n[![Build Status]( https://github.com/cpq/bare-metal-programming-guide/workflows/build/badge.svg)](https://github.com/cpq/bare-metal-programming-guide/actions)\n\n[English](README.md) | 中文 | [Türkçe](README_tr-TR.md)\n\n本指南是为那些希望用GCC编译器和数据手册而无需其他任何东西就能开始为微控制器（单片机）编程的开发者而写的。本指南中的基础知识可以帮助你更好地理解像STM32Cube、Keil、Arduino和其他框架或IDE是怎么工作的。\n\n本指南涵盖了以下话题：\n\n- 存储和寄存器\n- 中断向量表\n- 启动代码\n- 链接脚本\n- 使用`make`进行自动化构建\n- GPIO外设和闪烁LED\n- SysTick定时器\n- UART外设和调试输出\n- `printf`重定向到UART\n- 用Segger Ozone进行调试\n- 系统时钟配置\n- 实现一个带设备仪表盘的web服务器\n\n我们将使用[Nucleo-F429ZI](https://www.st.com/en/evaluation-tools/nucleo-f429zi.html)开发板([淘宝购买](https://item.taobao.com/item.htm?spm=a230r.1.14.232.74e4559brlH7oU&id=655793165717&ns=1&abbucket=5#detail))贯穿整个指南的实践，每个章节都有一个相关的完整小项目可以实战。最后一个web服务器项目非常完整，可以作为你自己项目的框架，因此这个示例项目也提供了其他开发板的适配：\n\n- [STM32 Nucleo-F429ZI](step-7-webserver/nucleo-f429zi/)\n- [TI EK-TM4C1294XL](step-7-webserver/ek-tm4c1294xl/)\n- [树莓派 Pico-W](step-7-webserver/pico-w/)\n\n对其他板子的适配支持还在进行中，可以提交issue来建议适配你正在用的板子。\n\n## 工具配置\n\n为继续进行，需要以下工具：\n\n- ARM GCC, https://launchpad.net/gcc-arm-embedded - 编译和链接\n- GNU make, http://www.gnu.org/software/make/ - 构建自动化\n- ST link, https://github.com/stlink-org/stlink - 烧写固件\n\n### Mac安装\n\n打开终端，执行：\n\n```sh\n$ /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n$ brew install gcc-arm-embedded make stlink\n```\n\n### Linux(Ubuntu)安装\n\n打开终端，执行：\n\n```sh\n$ sudo apt -y install gcc-arm-none-eabi make stlink-tools\n```\n\n### Windows安装\n\n- 下载并安装 [gcc-arm-none-eabi-10.3-2021.10-win32.exe](https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C)，安装过程注意勾选\"Add path to environment variable\"。\n- 创建 `C:\\tools` 文件夹\n- 下载 [stlink-1.7.0-x86_64-w64-mingw32.zip](https://github.com/stlink-org/stlink/releases/download/v1.7.0/stlink-1.7.0-x86_64-w64-mingw32.zip)，解压 `bin/st-flash.exe` 到 `C:\\tools`\n- 下载 [make-4.4-without-guile-w32-bin.zip](https://sourceforge.net/projects/ezwinports/files/make-4.4-without-guile-w32-bin.zip/download)，解压 `bin/make.exe` 到 `C:\\tools`\n- 添加 `C:\\tools` 到 `Path` 环境变量\n- 验证安装：\n  - 下载[这个仓库](https://github.com/cpq/bare-metal-programming-guide/archive/refs/heads/main.zip)，解压到 `C:\\`\n  - 打开命令行，执行：\n  <pre style=\"color: silver;\">\n  C:\\Users\\YOURNAME> <b style=\"color: black;\">cd \\</b>\n  C:\\> <b style=\"color: black;\">cd bare-metal-programming-guide-main\\step-0-minimal</b>\n  C:\\bare-metal-programming-guide-main\\step-0-minimal> <b style=\"color: black;\">make</b>\n  arm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror ...\n  </pre>\n\n### 需要的数据手册\n\n- [STM32F429 MCU datasheet](https://www.st.com/resource/en/reference_manual/dm00031020-stm32f405-415-stm32f407-417-stm32f427-437-and-stm32f429-439-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf)\n- [Nucleo-F429ZI board datasheet](https://www.st.com/resource/en/user_manual/dm00244518-stm32-nucleo144-boards-mb1137-stmicroelectronics.pdf)\n\n## 微控制器介绍\n\n微控制器（microcontroller，uC或MCU）是一个小计算机，典型地包含CPU、RAM、存储固件代码的Flash，以及一些引脚。其中一些引脚为MCU供电，通常被标记为VCC和GND。其他引脚通过高低电压来与MCU通信，最简单的通信方法之一就是把一个LED接在引脚上：LED一端接地，另一端串接一个限流电阻，然后接到MCU信号引脚。在固件代码中设置引脚电压的高低就可以使LED闪烁：\n\n<img src=\"images/mcu.svg\" height=\"200\" />\n\n### 存储和寄存器\n\nMCU的32位地址空间按区分割。例如，一些存储区被映射到特定的地址，这里是MCU的片内flash，固件代码指令在这些存储区读和执行。另一些区是RAM，也被映射到特定的地址，我们可以读或写任意值到RAM区。\n\n从STM32F429数据手册的2.3.1节，我们可以了解到RAM区从地址0x20000000开始，共有192KB。从2.4节我们可以了解到flash被映射到0x08000000，共2MB，所以flash和RAM的位置像这样：\n\n<img src=\"images/mem.svg\" />\n\n从数据手册中我们也可以看到还有很多其它存储区，它们的地址在2.3节\"Memory Map\"给出，例如：\"GPIOA\"区从地址0x40020000开始，长度为1KB。\n\n这些存储区被关联到MCU芯片内部不同的外设电路上，以特殊的方式控制外设引脚的行为。一个外设存储区是一些32位寄存器的集合，每个寄存器有4字节的空间，在特定的地址，控制着外设的特定功能。通过向寄存器写入值，或者说向特定的地址写一个32位的值，我们就可以控制外设的行为。通过读寄存器的值，我们就可以得到外设的数据或配置。\n\nMCU通常有许多不同的外设，其中比较简单的就是GPIO（General Purpose Input Output，通用输入输出），它允许用户将MCU引脚设为输出模式，然后置“高”或置“低”；或者设置为输入模式，然后读引脚电压的“高”或“低”。还有UART外设，可以使用串行协议通过两个引脚收发数据。还有许多其它外设。\n\n在MCU中，一个相同外设通常会有多个“实例”，比如GPIOA、GPIOB等等，它们控制着MCU引脚的不同集合。类似地，也有UART1、UART2等等，可以实现多通道。在Nucleo-F429上，有多个GPIO和UART外设。\n\n例如，GPIOA外设起始地址为0x40020000，我们可以从数据手册8.4节找到GPIO寄存器的描述，上面说 `GPIOA_MODER` 寄存器偏移为0，意味着它的地址是 `0x40020000 + 0`，寄存器地址格式如下：\n\n<img src=\"images/moder.png\" style=\"max-width: 100%\" />\n\n数据手册显示MODER这个32位寄存器是由16个2位的值组成。因此，一个MODER寄存器控制16个物理引脚，0-1位控制引脚0，2-3位控制引脚1，以此类推。这个2位的值编码了引脚模式：'00'代表输入，'01'代表输出，'10'代表替代功能——在其它部分进行描述，'11'代表模拟引脚。因为这个外设命名为'GPIOA'，所以对应引脚名为'A0'、'A1'，等等。对于外设'GPIOB'，引脚则对应叫'B0'、'B1'，等等。\n\n如果我们向MODER寄存器写入32位的值'0'，就会把从A0到A15这16个引脚设为输入模式：\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) = 0;  // Set A0-A15 to input mode\n```\n\n通过设置独立的位，我们就可以把特定的引脚设为想要的模式。例如，下面的代码将A3设为输出模式：\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // CLear bit range 6-7\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // Set bit range 6-7 to 1\n```\n\n我来解释下上面的位操作。我们的目标是把控制GPIOA外设引脚3的位，也就是6-7，设为特定值，在这里是1。这个需要2步，首先，我们必须将6-7位的当前值清除，也就是清'0'，因为这两位可能已经有值；然后，我们再将6-7设为期望值。\n\n所以，第一步，我们先把6-7位清'0'，怎么做呢？4步：\n\n- 使一个数有连续的N位'1'\n  - 1位用1：  `0b1`\n  - 2位用3:   `0b11`\n  - 3位用7：  `0b111`\n  - 4位用15： `0b1111`\n  - 以此类推，对于N位，数值应为 `2^N - 1`。对于2位，数值为 `3`，或者写为二进制 `0b00000000000000000000000000000011`\n- 将数字左移位。如果我们需要设置位 X-Y，则将数字左移X位。在我们的例子中，左移6位：`(3 << 6)`，得到 `0b00000000000000000000000011000000`\n- 取反：0变1，1变0：`~(3 << 6)`, 得到 `0xb11111111111111111111111100111111`\n- 现在，将寄存器值与我们的数字进行逻辑\"与\"操作，6-7位与'0'后会变0，其它位与'1'后不变，这就是我们想要的：`REG &= ~(3 << 6)`。注意，保持其它位的值不变是重要的，我们并不想改变其它位的配置。\n\n一般地，如果我们想将 X-Y 位清除，或者说设为0，这样做：\n\n```c\nPERIPHERAL->REGISTER &= ~(NUMBER_WITH_N_BITS << X);\n```\n\n最后，我们把那些位设为我们想要的值，则需要把想要的值左移X位，然后与寄存器当前值进行逻辑\"或\"运算：\n\n```c\nPERIPHERAL->REGISTER |= VALUE << X;\n```\n\n现在，你应该明白了，下面的两行代码将把GPIOA MODER寄存器的6-7位设为1，即输出模式：\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // CLear bit range 6-7\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // Set bit range 6-7 to 1\n```\n\n还有一些寄存器没有被映射到MCU外设，而是被映射到了ARM CPU的配置和控制。例如，有一个\"Reset and clock control\"单元（RCC），在数据手册第6节有描述，这些寄存器用来配置系统时钟和一些其它的事情。\n\n### 可读性更好的外设寄存器编程\n\n在前一节我们已经学习到可以通过直接访问存储地址来读写外设寄存器，下面复习下将GPIO A3设为输出模式的代码：\n\n```c\n  * (volatile uint32_t *) (0x40020000 + 0) &= ~(3 << 6);  // CLear bit range 6-7\n  * (volatile uint32_t *) (0x40020000 + 0) |= 1 << 6;     // Set bit range 6-7 to 1\n```\n\n这段代码有些诡秘，如果不加以注释，很难理解。我们可以把这段代码重写成更易读的形式，方法就是用一个包含32位域的结构体来表示整个外设。我们来看一下数据手册8.4节中描述的GPIO外设的寄存器，它们是MODER、OTYPER、OSPEEDR、PUPDR、IDR、ODR、BSRR、LCKR、AFR，它们的偏移量分别是0、4、8，等等，以此类推，这意味着我们可以用一个32位域的结构体来表示，然后这样定义GPIOA：\n\n```c\nstruct gpio {\n  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];\n};\n\n#define GPIOA ((struct gpio *) 0x40020000)\n```\n\n这样我们就可以定义一个设置GPIO引脚模式的函数：\n\n```c\n// Enum values are per datasheet: 0, 1, 2, 3\nenum {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG};\n\nstatic inline void gpio_set_mode(struct gpio *gpio, uint8_t pin, uint8_t mode) {\n  gpio->MODER &= ~(3U << (pin * 2));        // Clear existing setting\n  gpio->MODER |= (mode & 3) << (pin * 2);   // Set new mode\n}\n```\n\n现在重写上面将GPIO A3设为输出模式的代码：\n\n```c\ngpio_set_mode(GPIOA, 3 /* pin */, GPIO_MODE_OUTPUT);  // Set A3 to output\n```\n\nMCU有好多个GPIO外设（也常被叫作'banks'）：A、B、C...K，在数据手册2.3节可以看到，它们映射的存储空间相隔1KB，GPIOA起始地址为0x40020000，GPIOB起始地址为0x40020400，以此类推：\n\n```c\n#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))\n```\n\n我们可以给引脚进行编号，既包含组号，也包含序号。为了做到这一点，我们用一个2字节的`uint16_t`类型的数，高字节表示组号，低字节表示序号：\n\n```c\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n```\n\n通过这种方法，我们可以指定任意GPIO引脚：\n\n```c\n  uint16_t pin1 = PIN('A', 3);    // A3   - GPIOA pin 3\n  uint16_t pin2 = PIN('G', 11);   // G11  - GPIOG pin 11\n```\n\n现在，我们用这个方法再次改写`gpio_set_mode()`函数：\n\n```c\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin)); // GPIO bank\n  uint8_t n = PINNO(pin);                 // Pin number\n  gpio->MODER &= ~(3U << (n * 2));        // Clear existing setting\n  gpio->MODER |= (mode & 3) << (n * 2);   // Set new mode\n}\n```\n\n这样再设置GPIO A3为输出模式就很明了了：\n\n```c\n  uint16_t pin = PIN('A', 3);            // Pin A3\n  gpio_set_mode(pin, GPIO_MODE_OUTPUT);  // Set to output\n```\n\n至此我们已经为GPIO外设创建了一个有用的初始化API，其它外设，比如串口，也可以用相似的方法来实现。这是一种很好的编程实践，可以让代码清晰可读。\n\n## MCU启动和向量表\n\n当STM32F429 MCU启动时，它会从flash存储区最前面的位置读取一个叫作“向量表”的东西。“向量表”的概念所有ARM MCU都通用，它是一个包含32位中断处理程序地址的数组。对于所有的ARM MCU，向量表前16个地址由ARM保留，其余的作为外设中断处理程序入口，由MCU厂商定义。越简单的MCU中断处理程序入口越少，越复杂的MCU中断处理程序入口则会更多。\n\nSTM32F429的向量表在数据手册表62中描述，我们可以看到它在16个ARM保留的标准中断处理程序入口外还有91个外设中断处理程序入口。\n\n在向量表中，我们当前对前两个入口点比较感兴趣，它们在MCU启动过程中扮演了关键角色。这两个值是：初始堆栈指针和执行启动函数的地址（固件程序入口点）。\n\n所以现在我们知道，我们必须确保固件中第2个32位值包含启动函数的地址，当MCU启动时，它会从flash读取这个地址，然后跳转到我们的启动函数。\n\n## 最小固件\n\n现在我们创建一个 `main.c` 文件，指定一个初始进入无限循环什么都不做的启动函数，并把包含16个标准入口和91个STM32入口的向量表放进去。用你常用的编辑器创建 `main.c` 文件，并写入下面的内容：\n\n```c\n// Startup code\n__attribute__((naked, noreturn)) void _reset(void) {\n  for (;;) (void) 0;  // Infinite loop\n}\n\nextern void _estack(void);  // Defined in link.ld\n\n// 16 standard and 91 STM32-specific handlers\n__attribute__((section(\".vectors\"))) void (*tab[16 + 91])(void) = {\n  _estack, _reset\n};\n```\n\n对于 `_reset()` 函数，我们使用了GCC编译器特定的 `naked` 和 `noreturn` 属性，这意味着标准函数的进入和退出不会被编译器创建，这个函数永远不会返回。\n\n`void (*tab[16 + 91])(void)` 这个表达式的意思是：定义一个16+91个指向没有返回也没有参数的函数的指针数组，每个这样的函数都是一个中断处理程序，这个指针数组就是向量表。\n\n我们把 `tab` 向量表放到一个独立的叫作 `.vectors` 的区段，后面需要告诉链接器把这个区段放到固件最开始的地址，也就是flash存储区最开始的地方。前2个入口分别是：堆栈指针和固件入口，目前先把向量表其它值用0填充。\n\n### 编译\n\n我们来编译下代码，打开终端并执行：\n\n```sh\n$ arm-none-eabi-gcc -mcpu=cortex-m4 main.c -c\n```\n\n成功了！编译器生成了 `main.o` 文件，包含了最小固件，虽然这个固件程序什么都没做。这个 `main.o` 文件是ELF二进制格式的，包含了多个区段，我们来具体看一下：\n\n```sh\n$ arm-none-eabi-objdump -h main.o\n...\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .text         00000002  00000000  00000000  00000034  2**1\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n  1 .data         00000000  00000000  00000000  00000036  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\n  2 .bss          00000000  00000000  00000000  00000036  2**0\n                  ALLOC\n  3 .vectors      000001ac  00000000  00000000  00000038  2**2\n                  CONTENTS, ALLOC, LOAD, RELOC, DATA\n  4 .comment      0000004a  00000000  00000000  000001e4  2**0\n                  CONTENTS, READONLY\n  5 .ARM.attributes 0000002e  00000000  00000000  0000022e  2**0\n                  CONTENTS, READONLY\n```\n\n注意现在所有区段的 VMA/LMA 地址都是0，这表示 `main.o` 还不是一个完整的固件，因为它没有包含各个区段从哪个地址空间载入的信息。我们需要链接器从 `main.o` 生成一个完整的固件 `firmware.elf`。\n\n`.text` 区段包含固件代码，在上面的例子中，只有一个 `_reset()` 函数，2个字节长，是跳转到自身地址的 `jump` 指令。`.data` 和 `.bss`(初始化为0的数据) 区段都是空的。我们的固件将被拷贝到偏移0x8000000的flash区，但是数据区段应该被放到RAM里，因此 `_reset()` 函数应该把 `.data` 区段拷贝到RAM，并把整个 `.bss` 区段写入0。现在 `.data` 和 `.bss` 区段是空的，我们修改下 `_reset()` 函数让它处理好这些。\n\n为了做到这一点，我们必须知道堆栈从哪开始，也需要知道 `.data` 和 `.bss` 区段从哪开始。这些可以通过“链接脚本”指定，链接脚本是一个带有链接器指令的文件，这个文件里存有各个区段的地址空间以及对应的符号。\n\n### 链接脚本\n\n创建一个链接脚本文件 `link.ld`，然后把一下内容拷进去：\n\n```\nENTRY(_reset);\nMEMORY {\n  flash(rx)  : ORIGIN = 0x08000000, LENGTH = 2048k\n  sram(rwx) : ORIGIN = 0x20000000, LENGTH = 192k  /* remaining 64k in a separate address space */\n}\n_estack     = ORIGIN(sram) + LENGTH(sram);    /* stack points to end of SRAM */\n\nSECTIONS {\n  .vectors  : { KEEP(*(.vectors)) }   > flash\n  .text     : { *(.text*) }           > flash\n  .rodata   : { *(.rodata*) }         > flash\n\n  .data : {\n    _sdata = .;   /* .data section start */\n    *(.first_data)\n    *(.data SORT(.data.*))\n    _edata = .;  /* .data section end */\n  } > sram AT > flash\n  _sidata = LOADADDR(.data);\n\n  .bss : {\n    _sbss = .;              /* .bss section start */\n    *(.bss SORT(.bss.*) COMMON)\n    _ebss = .;              /* .bss section end */\n  } > sram\n\n  . = ALIGN(8);\n  _end = .;     /* for cmsis_gcc.h  */\n}\n```\n\n下面分段解释下：\n\n```\nENTRY(_reset);\n```\n\n这行是告诉链接器在生成的ELF文件头中 \"entry point\" 属性的值。没错，这跟向量表重复了，这个的目的是为像 Ozone 这样的调试器设置固件起始的断点。调试器是不知道向量表的，所以只能依赖ELF文件头。\n\n```\nMEMORY {\n  flash(rx)  : ORIGIN = 0x08000000, LENGTH = 2048k\n  sram(rwx) : ORIGIN = 0x20000000, LENGTH = 192k  /* remaining 64k in a separate address space */\n}\n```\n\n这是告诉链接器有2个存储区空间，以及它们的起始地址和大小。\n\n```\n_estack     = ORIGIN(sram) + LENGTH(sram);    /* stack points to end of SRAM */\n```\n\n这行告诉链接器创建一个 `_estack` 符号，它的值是RAM区的最后，这也是初始化堆栈指针的值。\n\n```\n  .vectors  : { KEEP(*(.vectors)) }   > flash\n  .text     : { *(.text*) }           > flash\n  .rodata   : { *(.rodata*) }         > flash\n```\n\n这是告诉链接器把向量表放在flash区最前，然后是 `.text` 区段（固件代码），再然后是只读数据 `.rodata`。\n\n```\n  .data : {\n    _sdata = .;   /* .data section start */\n    *(.first_data)\n    *(.data SORT(.data.*))\n    _edata = .;  /* .data section end */\n  } > sram AT > flash\n  _sidata = LOADADDR(.data);\n```\n\n这是 `.data` 区段，告诉链接器创建 `_sdata` 和 `_edata` 两个符号，我们将在 `_reset()` 函数中使用它们将数据拷贝到RAM。\n\n```\n  .bss : {\n    _sbss = .;              /* .bss section start */\n    *(.bss SORT(.bss.*) COMMON)\n    _ebss = .;              /* .bss section end */\n  } > sram\n```\n\n`.bss` 区段也是一样。\n\n### 启动代码\n\n现在我们来更新下 `_reset` 函数，把 `.data` 区段拷贝到RAM，然后把 `.bss` 区段初始化为0，再然后调用 `main()` 函数，在 `main()` 函数有返回的情况下进入无限循环：\n\n```c\nint main(void) {\n  return 0; // Do nothing so far\n}\n\n// Startup code\n__attribute__((naked, noreturn)) void _reset(void) {\n  // memset .bss to zero, and copy .data section to RAM region\n  extern long _sbss, _ebss, _sdata, _edata, _sidata;\n  for (long *dst = &_sbss; dst < &_ebss; dst++) *dst = 0;\n  for (long *dst = &_sdata, *src = &_sidata; dst < &_edata;) *dst++ = *src++;\n\n  main();             // Call main()\n  for (;;) (void) 0;  // Infinite loop in the case if main() returns\n}\n```\n\n下面的框图演示了 `_reset()` 如何初始化 `.data` 和 `.bss`：\n\n![](images/mem2.svg)\n\n`firmware.bin` 文件由3部分组成：`.vectors`(中断向量表)、`.text`(代码)、`.data`(数据)。这些部分根据链接脚本被分配到不同的存储空间：`.vectors` 在flash的最前面，`.text` 紧随其后，`.data` 则在那之后很远的地方。`.text` 中的地址在flash区，`.data` 在RAM区。例如，一个函数的地址是 `0x8000100`，则它位于flash中。而如果代码要访问 `.data` 中的变量，比如位于 `0x20000200`，那里将什么也没有，因为在启动时 `firmware.bin` 中 `.data` 还在flash里！这就是为什么必须要在启动代码中将 `.data` 区段拷贝到RAM。\n\n现在我们可以生成完整的 `firmware.elf` 固件了：\n\n```sh\n$ arm-none-eabi-gcc -T link.ld -nostdlib main.o -o firmware.elf\n```\n\n再次检验 `firmware.elf` 中的区段：\n\n```sh\n$ arm-none-eabi-objdump -h firmware.elf\n...\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .vectors      000001ac  08000000  08000000  00010000  2**2\n                  CONTENTS, ALLOC, LOAD, DATA\n  1 .text         00000058  080001ac  080001ac  000101ac  2**2\n                  CONTENTS, ALLOC, LOAD, READONLY, CODE\n...\n```\n\n可以看到，`.vectors` 区段在flash的起始地址0x8000000，`.text` 紧随其后。我们在代码中没有创建任何变量，所以没有 `.data` 区段。\n\n## 烧写固件\n\n现在可以把这个固件烧写到板子上了！\n\n先把 `firmware.elf` 中各个区段抽取到一个连续二进制文件中：\n\n```sh\n$ arm-none-eabi-objcopy -O binary firmware.elf firmware.bin\n```\n\n然后使用 `st-link` 工具将 `firmware.bin` 烧入板子，连接好板子，然后执行：\n\n```sh\n$ st-flash --reset write firmware.bin 0x8000000\n```\n\n这样就把固件烧写到板子上了。\n\n## Makefile：构建自动化\n\n我们可以用 `make` 命令行工具替代手动敲入“编译”、“链接”、“烧写”这些命令，自动完成整个过程。`make` 工具使用一个名为 `Makefile` 的配置文件，从中读取执行动作的指令。这种自动化方式非常棒，因为这样可以把构建固件的过程、使用了哪些编译标记等也文档化。\n\n在 https://makefiletutorial.com 上有一个非常好的给初学者的Makefile教程，强烈建议看一下。下面我将列出一些非常必要的概念以理解我们所使用的Makefile。对于已经很熟悉 `make` 的朋友，可以跳过这一部分。\n\n其实 `Makefile` 的格式并不复杂：\n\n```make\naction1:\n\tcommand ...     # Comments can go after hash symbol\n\tcommand ....    # IMPORTANT: command must be preceded with the TAB character\n\naction2:\n\tcommand ...     # Don't forget about TAB. Spaces won't work!\n```\n\n现在我们可以跟动作名（也被称作目标）一起调用 `make` 来执行相应的动作：\n\n```sh\n$ make action1\n```\n\n当然，也可以在命令中定义和使用变量，动作也可以是需要创建的文件名：\n\n```make\nfirmware.elf:\n\tCOMPILATION COMMAND .....\n```\n\n任何动作都可以有一个依赖列表。例如，`firmware.elf` 依赖源文件 `main.c`，当 `main.c` 改变时，`make build` 就会重新构建 `firmware.elf`:\n\n```\nbuild: firmware.elf\n\nfirmware.elf: main.c\n\tCOMPILATION COMMAND\n```\n\n我们已经准备好为固件编写 `Makefile`，定义一个 `build` 动作/目标：\n\n```make\nCFLAGS  ?=  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion \\\n            -Wformat-truncation -fno-common -Wconversion \\\n            -g3 -Os -ffunction-sections -fdata-sections -I. \\\n            -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16 $(EXTRA_CFLAGS)\nLDFLAGS ?= -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=$@.map\nSOURCES = main.c \n\nbuild: firmware.elf\n\nfirmware.elf: $(SOURCES)\n\tarm-none-eabi-gcc $(SOURCES) $(CFLAGS) $(LDFLAGS) -o $@\n```\n\n在这里我们定义了一些编译标记。`?=` 表示这是默认值，我们可以在命令行中覆盖它们，像这样：\n\n```sh\n$ make build CFLAGS=\"-O2 ....\"\n```\n\n上面的 `Makefile` 文件中定义了 `CFLAGS`、`LDFLAGS`、`SOURCES` 变量，然后我们告诉 `make` ，当要 `build` 时创建 `firmware.elf` 文件，它依赖 `main.c` 文件，使用 `arm-none-eabi-gcc` 编译器和给定的编译标记生成它。`$@` 特殊变量会被展开成动作/目标名，在这个例子中是 `firmware.elf`。\n\n现在调用 `make` 试一下：\n\n``` sh\n$ make build\narm-none-eabi-gcc main.c  -W -Wall -Wextra -Werror -Wundef -Wshadow -Wdouble-promotion -Wformat-truncation -fno-common -Wconversion -g3 -Os -ffunction-sections -fdata-sections -I. -mcpu=cortex-m4 -mthumb -mfloat-abi=hard -mfpu=fpv4-sp-d16  -Tlink.ld -nostartfiles -nostdlib --specs nano.specs -lc -lgcc -Wl,--gc-sections -Wl,-Map=firmware.elf.map -o firmware.elf\n```\n\n如果我们再次运行：\n\n```sh\n$ make build\nmake: Nothing to be done for `build'.\n```\n\n`make` 会检查 `firmware.elf` 和依赖项 `main.c` 的修改时间，如果是它们是最新的，则什么都不做。如果我们修改下 `main.c`，则会重新构建：\n\n```sh\n$ touch main.c # Simulate changes in main.c\n$ make build\n```\n\n现在，还剩下“烧写”这个动作/目标：\n\n```make\nfirmware.bin: firmware.elf\n\tarm-none-eabi-objcopy -O binary $< $@\n\nflash: firmware.bin\n\tst-flash --reset write $(TARGET).bin 0x8000000\n```\n\nOK，现在从终端中执行命令 `make flash` 就会创建 `firmware.bin` 文件，然后通过 `st-link` 烧入板子。当 `main.c` 改变时，这个命令也会重新构建，因为 `firmware.bin` 依赖 `firmware.elf`，`firmware.elf` 又依赖 `main.c`。所以我们的开发循环就是这样的两步：\n\n```sh\n# Develop code in main.c\n$ make flash\n```\n\n还有一个良好实践就是在 `Makefile` 中添加 `clean` 动作，以删除构建生成的文件：\n\n```\nclean:\n\trm -rf firmware.*\n```\n\n完整工程代码可以在 [step-0-minimal](step-0-minimal) 文件夹找到。\n\n## 闪烁LED\n\n现在我们已经搭建好了完整的构建、烧写的基础设施，是时候让固件做点儿有用的事情了。什么是有用的事情？当然是闪烁LED了！Nucleo-F429ZI开发板有3颗LED，在开发板数据手册的6.5节，我们可以看到板载LED连接的引脚：\n\n- PB0: green LED\n- PB7: blue LED\n- PB14: red LED\n\n再次修改 `main.c` 文件，添加上引脚定义，然后把蓝色LED引脚设为输出模式，开始无限循环。首先，把我们之前讨论过的GPIO定义和模式设置拷贝过来，注意，现在又新加了一个 `BIT(position)` 工具宏：\n\n```c\n#include <inttypes.h>\n#include <stdbool.h>\n\n#define BIT(x) (1UL << (x))\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n\nstruct gpio {\n  volatile uint32_t MODER, OTYPER, OSPEEDR, PUPDR, IDR, ODR, BSRR, LCKR, AFR[2];\n};\n#define GPIO(bank) ((struct gpio *) (0x40020000 + 0x400 * (bank)))\n\n// Enum values are per datasheet: 0, 1, 2, 3\nenum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };\n\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  gpio->MODER &= ~(3U << (n * 2));         // Clear existing setting\n  gpio->MODER |= (mode & 3) << (n * 2);    // Set new mode\n}\n```\n\n某些微控制器在上电时会把所有外设都自动使能，然而，STM32微控制器在上电时外设是默认关闭的，以降低功耗。为了使能GPIO外设，我们需要通过RCC单元使能外设时钟。在芯片数据手册7.3.10节，可以找到AHB1ENR寄存器与此相关，还是先定义整个RCC单元：\n\n```c\nstruct rcc {\n  volatile uint32_t CR, PLLCFGR, CFGR, CIR, AHB1RSTR, AHB2RSTR, AHB3RSTR,\n      RESERVED0, APB1RSTR, APB2RSTR, RESERVED1[2], AHB1ENR, AHB2ENR, AHB3ENR,\n      RESERVED2, APB1ENR, APB2ENR, RESERVED3[2], AHB1LPENR, AHB2LPENR,\n      AHB3LPENR, RESERVED4, APB1LPENR, APB2LPENR, RESERVED5[2], BDCR, CSR,\n      RESERVED6[2], SSCGR, PLLI2SCFGR;\n};\n#define RCC ((struct rcc *) 0x40023800)\n```\n\n在AHB1ENR寄存器文档中可以看到0-8位控制GPIOA - GPIOI的时钟：\n\n```c\nint main(void) {\n  uint16_t led = PIN('B', 7);            // Blue LED\n  RCC->AHB1ENR |= BIT(PINBANK(led));     // Enable GPIO clock for LED\n  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode\n  for (;;) asm volatile(\"nop\");          // Infinite loop\n  return 0;\n}\n```\n\n接下来需要做的就是找到如何开关GPIO引脚，然后在主循环中点亮LED，延时，熄灭LED，延时。在芯片数据手册8.4.7节，可以看到BSRR寄存器与设置电压高低有关，低16位设置ODR寄存器输出高，高16位设置ODR寄存器输出低。为此定义一个API函数：\n\n```c\nstatic inline void gpio_write(uint16_t pin, bool val) {\n  struct gpio *gpio = GPIO(PINBANK(pin));\n  gpio->BSRR = (1U << PINNO(pin)) << (val ? 0 : 16);\n}\n```\n\n下一步我们需要实现一个延时函数，目前还不需要精确延时，所以定义一个 `spin()` 函数，执行NOP指令给定的次数：\n\n```c\nstatic inline void spin(volatile uint32_t count) {\n  while (count--) asm(\"nop\");\n}\n```\n\n最后，修改主循环来让LED闪烁起来：\n\n```c\n  for (;;) {\n    gpio_write(pin, true);\n    spin(999999);\n    gpio_write(pin, false);\n    spin(999999);\n  }\n```\n\n执行 `make flash` 来看蓝色LED闪烁吧！\n\n完整工程源码可以在 [step-1-blinky](step-1-blinky) 文件夹找到。\n\n## 用SysTick中断实现闪烁\n\n为了实现精确的时间控制，我们应该使能ARM的SysTick中断。SysTick是一个24位的硬件计数器，是ARM核的一部分，因为在ARM的数据手册中有它的文档。从芯片数据手册中可以看到，SysTick有4个寄存器：\n\n- CTRL，使能/禁能SysTick\n- LOAD，初始计数值\n- VAL，当前计数值，每个时钟周期递减\n- CALIB，校准寄存器\n\n每次VAL减到0，就会产生一个SysTick中断，SysTick中断在向量表中的索引为15，我们需要设置它。在启动时，Nucleo-F429ZI的时钟是16MHz，我们可以配置SysTick计数器使其每毫秒产生一个中断。\n\n首先，定义SysTick外设，我们知道有4个寄存器，并且从芯片数据手册中可以知道SysTick地址为0xe000e010，编写代码：\n\n```c\nstruct systick {\n  volatile uint32_t CTRL, LOAD, VAL, CALIB;\n};\n#define SYSTICK ((struct systick *) 0xe000e010)\n```\n\n接下来定义一个API函数配置SysTick，我们需要在 `SYSTICK->CTRL` 寄存器使能SysTick，同时也需要在 `RCC->APB2ENR` 中使能它的时钟，这一点在芯片数据手册7.4.14节描述：\n\n```c\n#define BIT(x) (1UL << (x))\nstatic inline void systick_init(uint32_t ticks) {\n  if ((ticks - 1) > 0xffffff) return;  // Systick timer is 24 bit\n  SYSTICK->LOAD = ticks - 1;\n  SYSTICK->VAL = 0;\n  SYSTICK->CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick\n  RCC->APB2ENR |= BIT(14);                   // Enable SYSCFG\n}\n```\n\n默认情况下，Nucleo-F429ZI运行频率为16MHz，这表示如果我们调用 `systick_init(16000000 / 1000)`，就会每毫秒产生一个SysTick中断。还需要定义一个中断处理函数，现在只是在中断处理函数中递增一个32位数：\n\n```c\nstatic volatile uint32_t s_ticks; // volatile is important!!\nvoid SysTick_Handler(void) {\n  s_ticks++;\n}\n```\n\n注意 `s_ticks` 要用 `volatile` 说明符，在中断处理函数中的任何变量都应该标记为 `volatile`，这样可以避免编译器通过在寄存器中缓存变量值的优化操作。`volatile` 关键字可以是生成的代码总是从存储空间载入变量值。\n\n现在把SysTick中断处理函数加到向量表中：\n\n```c\n__attribute__((section(\".vectors\"))) void (*tab[16 + 91])(void) = {\n    0, _reset, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, SysTick_Handler};\n```\n\n这样我们就有精确的毫秒时钟了！再创建一个任意周期的定时器工具函数：\n\n```c\n// t: expiration time, prd: period, now: current time. Return true if expired\nbool timer_expired(uint32_t *t, uint64_t prd, uint64_t now) {\n  if (now + prd < *t) *t = 0;                    // Time wrapped? Reset timer\n  if (*t == 0) *t = now + prd;                   // First poll? Set expiration\n  if (*t > now) return false;                    // Not expired yet, return\n  *t = (now - *t) > prd ? now + prd : *t + prd;  // Next expiration time\n  return true;                                   // Expired, return true\n}\n```\n\n使用这个精确的定时器函数更新闪烁LED的主循环，例如，每500ms闪烁一次：\n\n```c\n  uint32_t timer = 0, period = 500;       // Declare timer and 500ms period\n  for (;;) {\n    if (timer_expired(&timer, period, s_ticks)) {\n      static bool on;       // This block is executed\n      gpio_write(led, on);  // Every `period` milliseconds\n      on = !on;             // Toggle LED state\n    }\n    // Here we could perform other activities!\n  }\n```\n\n通过使用 `SysTick` 和 `timer_expired()` 工具函数，使主循环成为非阻塞的。这意味着在主循环中我们还可以执行许多动作，例如，创建不同周期的定时器，它们都能及时被触发。\n\n完整工程源码可以在 [step-2-systick](step-2-systick) 文件夹找到。\n\n## 添加串口调试输出\n\n现在是时候给固件添加一些人类可读的诊断信息了。MCU外设中有一个串行通信接口，通常被称作串口。看一下芯片数据手册2.3节，STM32F429有多个串口控制器，适当配置后就可以通过特定引脚与外部交换数据。最小化的串口配置需要2个引脚，一个接收，另一个发送。\n\n在Nucleo开发板数据手册6.9节，可以看到MCU的串口3的发送引脚是PD8，接收引脚是PD9，并且已经被连到了板载的ST-LINK调试器上，这意味着我们配置好串口3就可以通过PD8发送数据，然后通过ST-LINK在工作站上看到MCU发送的数据。\n\n现在给串口创建API，就像之前GPIO那样。芯片数据手册30.6节概括了串口寄存器，可以这样定义串口结构体：\n\n```c\nstruct uart {\n  volatile uint32_t SR, DR, BRR, CR1, CR2, CR3, GTPR;\n};\n#define UART1 ((struct uart *) 0x40011000)\n#define UART2 ((struct uart *) 0x40004400)\n#define UART3 ((struct uart *) 0x40004800)\n```\n\n要配置串口，需要这些步骤：\n\n- 使能串口时钟，通过设置 `RCC->APB2ENR` 寄存器的相应位\n- 设置接收和发送引脚为替代功能，替代功能列表在芯片数据手册表12\n- 设置波特率（通信速率），通过 `BRR` 寄存器\n- 使能串口外设，通过 `CR1` 寄存器接收和发送数据\n\n我们已经知道如何把GPIO引脚设为特定的模式，如果1个引脚被用作替代功能，我们也必须指定替代功能编号，可以通过GPIO外设的替代功能寄存器 `AFR` 进行控制。仔细阅读芯片数据手册中对 `AFR` 寄存器的描述，可以发现替代功能有4位编号，所以要控制全部16个引脚需要2个32位寄存器。设置引脚替代功能的API可以这样实现：\n\n```c\nstatic inline void gpio_set_af(uint16_t pin, uint8_t af_num) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  gpio->AFR[n >> 3] &= ~(15UL << ((n & 7) * 4));\n  gpio->AFR[n >> 3] |= ((uint32_t) af_num) << ((n & 7) * 4);\n}\n```\n\n为了从GPIO API中完全隐藏寄存器特定的代码，我们把GPIO时钟初始化的代码移动到 `gpio_set_mode()` 函数中：\n\n```c\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  struct gpio *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  RCC->AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock\n  ...\n```\n\n现在可以创建一个串口初始化的API函数：\n\n```c\n#define FREQ 16000000  // CPU frequency, 16 Mhz\nstatic inline void uart_init(struct uart *uart, unsigned long baud) {\n  // https://www.st.com/resource/en/datasheet/stm32f429zi.pdf\n  uint8_t af = 7;           // Alternate function\n  uint16_t rx = 0, tx = 0;  // pins\n\n  if (uart == UART1) RCC->APB2ENR |= BIT(4);\n  if (uart == UART2) RCC->APB1ENR |= BIT(17);\n  if (uart == UART3) RCC->APB1ENR |= BIT(18);\n\n  if (uart == UART1) tx = PIN('A', 9), rx = PIN('A', 10);\n  if (uart == UART2) tx = PIN('A', 2), rx = PIN('A', 3);\n  if (uart == UART3) tx = PIN('D', 8), rx = PIN('D', 9);\n\n  gpio_set_mode(tx, GPIO_MODE_AF);\n  gpio_set_af(tx, af);\n  gpio_set_mode(rx, GPIO_MODE_AF);\n  gpio_set_af(rx, af);\n  uart->CR1 = 0;                           // Disable this UART\n  uart->BRR = FREQ / baud;                 // FREQ is a UART bus frequency\n  uart->CR1 |= BIT(13) | BIT(2) | BIT(3);  // Set UE, RE, TE\n}\n```\n\n最后，再来实现串口读写函数。芯片数据手册30.6.1节告诉我们状态寄存器 `SR` 表示数据是否准备好：\n\n```c\nstatic inline int uart_read_ready(struct uart *uart) {\n  return uart->SR & BIT(5);  // If RXNE bit is set, data is ready\n}\n```\n\n数据可以从数据寄存器 `DR` 中获取：\n\n```c\nstatic inline uint8_t uart_read_byte(struct uart *uart) {\n  return (uint8_t) (uart->DR & 255);\n}\n```\n\n发送单个字节的数据也是通过 `DR` 寄存器完成。设置好要发送的数据后，我们需要等待发送完成，通过检查 `SR` 寄存器第7位来实现：\n\n```c\nstatic inline void uart_write_byte(struct uart *uart, uint8_t byte) {\n  uart->DR = byte;\n  while ((uart->SR & BIT(7)) == 0) spin(1);\n}\n```\n\n写数据到缓冲区：\n\n```c\nstatic inline void uart_write_buf(struct uart *uart, char *buf, size_t len) {\n  while (len-- > 0) uart_write_byte(uart, *(uint8_t *) buf++);\n}\n```\n\n在 `main()` 函数中初始化串口：\n\n```c\n  ...\n  uart_init(UART3, 115200);              // Initialise UART\n```\n\n然后每次闪烁LED时输出一条消息 \"hi\\r\\n\"：\n\n```c\n    if (timer_expired(&timer, period, s_ticks)) {\n      ...\n      uart_write_buf(UART3, \"hi\\r\\n\", 4);  // Write message\n    }\n```\n\n重新编译，然后烧写到开发板上，用一个终端程序连接ST-LINK的端口。在Mac上，我用 `cu`，在Linux上也可以用它。在Windows上使用 `putty` 工具是一个好主意。打开终端，执行命令后可以看到：\n\n```sh\n$ cu -l /dev/cu.YOUR_SERIAL_PORT -s 115200\nhi\nhi\n```\n\n完整工程代码可以在 [step-3-uart](step-3-uart) 文件夹找到。\n\n## 重定向`printf()`到串口\n\n在这一节，我们将 `uart_write_buf()` 调用替换为 `printf()`，它使我们能够进行格式化输出，这样可以更好的输出诊断信息，实现了“打印样式的调试”。\n\n我们使用的GNU ARM工具链除了包含GCC编译器和一些工具外，还包含了一个被称为[newlib](https://sourceware.org/newlib)的C库，由红帽为嵌入式系统开发。\n\n如果我们的固件调用了一个标准C库函数，比如 `strcmp()`，newlib就会被GCC链接器加到我们的固件中。\n\nnewlib实现了一些标准C函数，特别是文件输入输出操作，并且被实现的很随潮流：这些函数最终调用一组被称为 \"syscalls\" 的底层输入输出函数。\n\n例如：\n\n- `fopen()` 最终调用 `_open()`\n- `fread()` 最终调用 `_read()`\n- `fwrite()`, `fprintf()`, `printf()` 最终调用 `_write()`\n- `malloc` 最终调用 `_sbrk()`，等等\n\n因此，通过修改 `_write()` 系统调用，我们可以重定向 `printf()` 到任何我们希望的地方，这个机制被称为 \"IO retargeting\"。\n\n注意，STM32 Cube也使用ARM GCC工具链，这就是为什么Cube工程都包含 `syscalls.c` 文件。其它工具链，比如TI的CCS、Keil的CC，可能使用不同的C库，重定向机制会有一点区别。我们用newlib，所以修改 `_write()` 可以打印到串口3。\n\n在那之前，我们先重新组织下源码结构：\n\n- 把所有API定义放到 `hal.h` 文件中\n- 把启动代码放到 `startup.c` 文件中\n- 为newlib的系统调用创建一个空文件 `syscalls.c`\n- 修改Makefile，把 `syscalls.c` 和 `startup.c` 加到build中\n\n将所有 API 定义移动到 `hal.h` 后，`main.c` 文件变得相当紧凑。注意我们还没提到底层寄存器，高级API函数很容易理解：\n\n```c\n#include \"hal.h\"\n\nstatic volatile uint32_t s_ticks;\nvoid SysTick_Handler(void) {\n  s_ticks++;\n}\n\nint main(void) {\n  uint16_t led = PIN('B', 7);            // Blue LED\n  systick_init(16000000 / 1000);         // Tick every 1 ms\n  gpio_set_mode(led, GPIO_MODE_OUTPUT);  // Set blue LED to output mode\n  uart_init(UART3, 115200);              // Initialise UART\n  uint32_t timer = 0, period = 500;      // Declare timer and 500ms period\n  for (;;) {\n    if (timer_expired(&timer, period, s_ticks)) {\n      static bool on;                      // This block is executed\n      gpio_write(led, on);                 // Every `period` milliseconds\n      on = !on;                            // Toggle LED state\n      uart_write_buf(UART3, \"hi\\r\\n\", 4);  // Write message\n    }\n    // Here we could perform other activities!\n  }\n  return 0;\n}\n```\n\n现在我们把 `printf()` 重定向到串口3，在空的 `syscalls.c` 文件中拷入一下内容：\n\n```c\n#include \"hal.h\"\n\nint _write(int fd, char *ptr, int len) {\n  (void) fd, (void) ptr, (void) len;\n  if (fd == 1) uart_write_buf(UART3, ptr, (size_t) len);\n  return -1;\n}\n```\n\n这段代码：如果我们写入的文件描述符是 1（这是一个标准输出描述符），则将缓冲区写入串口3，否则忽视。这就是重定向的本质！\n\n重新编译，会得到一些链接器错误：\n\n```sh\n../../arm-none-eabi/lib/thumb/v7e-m+fp/hard/libc_nano.a(lib_a-sbrkr.o): in function `_sbrk_r':\nsbrkr.c:(.text._sbrk_r+0xc): undefined reference to `_sbrk'\ncloser.c:(.text._close_r+0xc): undefined reference to `_close'\nlseekr.c:(.text._lseek_r+0x10): undefined reference to `_lseek'\nreadr.c:(.text._read_r+0x10): undefined reference to `_read'\nfstatr.c:(.text._fstat_r+0xe): undefined reference to `_fstat'\nisattyr.c:(.text._isatty_r+0xc): undefined reference to `_isatty'\n```\n\n这是因为我们使用了newlib的标准输入输出函数，那么就需要把newlib中其它的系统调用也实现。加入一些简单的什么都不做的桩函数：\n\n```c\nint _fstat(int fd, struct stat *st) {\n  (void) fd, (void) st;\n  return -1;\n}\n\nvoid *_sbrk(int incr) {\n  (void) incr;\n  return NULL;\n}\n\nint _close(int fd) {\n  (void) fd;\n  return -1;\n}\n\nint _isatty(int fd) {\n  (void) fd;\n  return 1;\n}\n\nint _read(int fd, char *ptr, int len) {\n  (void) fd, (void) ptr, (void) len;\n  return -1;\n}\n\nint _lseek(int fd, int ptr, int dir) {\n  (void) fd, (void) ptr, (void) dir;\n  return 0;\n}\n```\n\n再重新编译，应该就不会报错了。\n\n最后一步，将 `main()` 中 `uart_write_buf()` 替换为 `printf()`，并打印一些有用的信息，比如LED状态和当前s_ticks的值：\n\n```c\nprintf(\"LED: %d, tick: %lu\\r\\n\", on, s_ticks);  // Write message\n```\n\n再重新编译，串口输出应该像这样：\n\n```sh\nLED: 1, tick: 250\nLED: 0, tick: 500\nLED: 1, tick: 750\nLED: 0, tick: 1000\n```\n\n可喜可贺！我们学习了IO重定向是如何工作的，并且可以用打印输出来调试固件了。\n\n完整工程源码可以在 [step-4-printf](step-4-printf) 文件夹找到。\n\n## 用Segger Ozone进行调试\n\n如果我们的固件卡在某个地方并且 printf 调试不起作用怎么办？甚至连启动代码都不起作用怎么办？我们需要一个调试器。那有很多选项，但我建议使用Segger的Ozone调试器。为什么？因为它是独立的，不依赖任何IDE。我们可以把 `firmware.elf` 直接提供给Ozone，它会自动拾取源文件。\n\n可以从Segger网站[下载 Ozone](https://www.segger.com/products/development-tools/ozone-j-link-debugger/)。在用它调试我们的Nucleo开发板之前，我们需要把板载的ST-LINK固件改成jlink的固件，这样Ozone才能识别。遵循Segger网站的[说明](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/)完成固件修改。\n\n现在，运行Ozone，在向导中选择设备：\n\n<img src=\"images/ozone1.png\" width=\"50%\" />\n\n选择我们要用的调试器硬件：\n\n<img src=\"images/ozone2.png\" width=\"50%\" />\n\n然后选择 `firmware.elf` 固件文件：\n\n<img src=\"images/ozone3.png\" width=\"50%\" />\n\n接下来的步骤保持默认，点击“完成”，调试器已经载入（可以看到`hal.h`源码被拾取）：\n\n<img src=\"images/ozone3.png\" width=\"50%\" />\n\n点击左上角的绿色按钮，下载、运行固件，然后会停在这里：\n\n![](images/ozone5.png)\n\n现在我们可以单步运行代码，设置断点，以及其它调试工作。有一个地方可以注意，那就是Ozone方便的外设视图：\n\n![](images/ozone6.png)\n\n我们可以用它直接检查或设置外设的状态，例如，点亮板子上的绿色LED（PB0）：\n\n1. 先使能GPIOB时钟，找到  Peripherals -> RCC -> AHB1ENR，然后把 GPIOBEN 位设为1：\n  <img src=\"images/ozone7.png\" width=\"75%\" />\n\n2. 找到 Peripherals -> GPIO -> GPIOB -> MODER，设置 MODER0 为1（输出）：\n  <img src=\"images/ozone8.png\" width=\"75%\" />\n\n3. 找到 Peripherals -> GPIO -> GPIOB -> ODR，设置 ODR0 为1（高电平）：\n  <img src=\"images/ozone9.png\" width=\"75%\" />\n\n这样绿色LED就被点亮了。愉快地调试吧！\n\n## 供应商CMSIS头文件\n\n在前面的部分，我们仅使用数据手册、编辑器和GCC编译器开发了固件程序，使用数据手册创建了外设结构定义。\n\n现在我们已经知道MCU是怎么工作的，是时候介绍一下CMSIS头文件了。它是什么？它是由MCU厂商创建和提供的带有全部定义的头文件。它包含MCU相关的全部，所以很庞大。\n\nCMSIS代表通用微控制器软件接口标准（Common Microcontroller Software Interface Standard），因此它是MCU制造商指定外设API的共同基础。 因为CMSIS是一种ARM标准，并且CMSIS头文件由MCU厂商提供，所以是权威的来源。因此，使用供应商头文件是首选方法，而不是手动编写定义。\n\n在这一节，我们将使用供应商CMSIS头文件替换 `hal.h` 中的API函数，并保持固件其它部分不变。\n\nSTM32 F4系列的CMSIS头文件在这个[仓库](https://github.com/STMicroelectronics/cmsis_device_f4)，从那里将以下文件拷到我们的固件文件夹[step-5-cmsis](step-5-cmsis)：\n\n- [stm32f429xx.h](https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f4/master/Include/stm32f429xx.h)\n- [system_stm32f4xx.h](https://raw.githubusercontent.com/STMicroelectronics/cmsis_device_f4/master/Include/system_stm32f4xx.h)\n\nThose two files depend on a standard ARM CMSIS includes, download them too:\n- [core_cm4.h](https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/core_cm4.h)\n- [cmsis_gcc.h](https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_gcc.h)\n- [cmsis_version.h](https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_version.h)\n- [cmsis_compiler.h](https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/cmsis_compiler.h)\n- [mpu_armv7.h](https://raw.githubusercontent.com/STMicroelectronics/STM32CubeF4/master/Drivers/CMSIS/Core/Include/mpu_armv7.h)\n\n然后移除 `hal.h` 中所有外设API和定义，只留下标准C包含、供应商CMSIS包含，引脚定义等：\n\n```c\n#pragma once\n\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/stat.h>\n\n#include \"stm32f429xx.h\"\n\n#define FREQ 16000000  // CPU frequency, 16 Mhz\n#define BIT(x) (1UL << (x))\n#define PIN(bank, num) ((((bank) - 'A') << 8) | (num))\n#define PINNO(pin) (pin & 255)\n#define PINBANK(pin) (pin >> 8)\n\nstatic inline void spin(volatile uint32_t count) {\n  while (count--) asm(\"nop\");\n}\n\nstatic inline bool timer_expired(uint32_t *t, uint32_t prd, uint32_t now) {\n  ...\n}\n```\n\n如果我们执行 `make clean build` 重新编译固件，GCC会报错：缺少 `systick_init()`, `GPIO_MODE_OUTPUT`, `uart_init()`,\n和 `UART3`。我们使用STM32 CMSIS文件重新添加它们。\n\n从 `systick_init()` 开始， `core_cm4.h` 头文件中定义了 `SysTick_Type` 结构体，与我们的 `struct systick` 和 `SysTick` 外设相关宏定义作用相同。还有，`stm32f429xx.h` 头文件中有一个 `RCC_TypeDef` 结构体与我们的 `RCC` 宏定义一样，所以我们的 `systick_init()` 函数几乎不用修改，只需要用 `SYSTICK` 替换 `SysTick`：\n\n```c\nstatic inline void systick_init(uint32_t ticks) {\n  if ((ticks - 1) > 0xffffff) return;  // Systick timer is 24 bit\n  SysTick->LOAD = ticks - 1;\n  SysTick->VAL = 0;\n  SysTick->CTRL = BIT(0) | BIT(1) | BIT(2);  // Enable systick\n  RCC->APB2ENR |= BIT(14);                   // Enable SYSCFG\n}\n```\n\n接下来是 `gpio_set_mode()` 函数。`stm32f429xx.h` 头文件中有一个 `GPIO_TypeDef` 结构体，与我们的 `struct gpio` 相同，使用它改写：\n\n```c\n#define GPIO(bank) ((GPIO_TypeDef *) (GPIOA_BASE + 0x400 * (bank)))\nenum { GPIO_MODE_INPUT, GPIO_MODE_OUTPUT, GPIO_MODE_AF, GPIO_MODE_ANALOG };\n\nstatic inline void gpio_set_mode(uint16_t pin, uint8_t mode) {\n  GPIO_TypeDef *gpio = GPIO(PINBANK(pin));  // GPIO bank\n  int n = PINNO(pin);                      // Pin number\n  RCC->AHB1ENR |= BIT(PINBANK(pin));       // Enable GPIO clock\n  gpio->MODER &= ~(3U << (n * 2));         // Clear existing setting\n  gpio->MODER |= (mode & 3) << (n * 2);    // Set new mode\n}\n```\n\n`gpio_set_af()` 和 `gpio_write()` 也是一样简单替换就行。\n\n然后是串口，CMSIS中有 `USART_TypeDef` 和 `USART1`、`USART2`、`USART3` 的定义，使用它们：\n\n```c\n#define UART1 USART1\n#define UART2 USART2\n#define UART3 USART3\n```\n\n在 `uart_init()` 以及其它串口函数中将 `struct uart` 替换为 `USART_TypeDef`，其余部分保持不变。\n\n做完这些，重新编译和烧写固件。LED又闪烁起来，串口也有输出了。恭喜！\n\n我们已经使用供应商CMSIS头文件重写了固件代码，现在重新组织下代码，把所有标准文件放到 `include` 目录下，然后更新Makefile文件让GCC编译器知道：\n\n```make\n...\n  -g3 -Os -ffunction-sections -fdata-sections -I. -Iinclude \\\n```\n\n现在得到了一个可以在未来的工程中重用的工程模板。\n\n完整工程源码可以在 [step-5-cmsis](step-5-cmsis) 文件夹找到。\n\n## 配置时钟\n\n启动后，Nucleo-F429ZI CPU以16MHz运行，最大频率为180MHz。请注意，系统时钟频率并不是我们需要关心的唯一因素。外设连接到不同的总线，APB1 和 APB2 时钟不同。 它们的时钟速度由频率预分频器配置值，在 RCC 中设置。主 CPU 时钟源也可以不同 - 我们可以使用外部晶体振荡器 （HSE） 或内部振荡器（HSI）。在我们的例子中，我们将使用 HSI。\n\n当CPU从闪存执行指令时，闪存读取速度（大约25MHz）在CPU时钟变高时成为瓶颈。有几个技巧会有所帮助，指令预取就是其中之一。此外，我们可以给闪存控制器提供一些线索，告诉它系统时钟有多快：该值称为闪存延迟。对于 180MHz 系统时钟，`FLASH_LATENCY`值为 5。闪存控制器中的位 8 和 9 控制启用指令和数据缓存：\n\n```c\n  FLASH->ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches\n```\n\n时钟源（HSI 或 HSE）通过一个称为锁相环（PLL）的硬件，将源频率乘以特定值。然后，一组分频器用于设置系统时钟和APB1、APB2时钟。为了获得180MHz的最大系统时钟，可能需要多个值的PLL分频器和APB预分频器。第 6.3.3 节数据表告诉我们APB1时钟的最大值：<= 45MHz，和 APB2 时钟：<= 90MHz。这缩小了可能的列表组合。在这里，我们手动选择值。请注意，像CubeMX这样的工具可以自动化该过程，并使其变得简单和可视化。\n\n```c\nenum { APB1_PRE = 5 /* AHB clock / 4 */, APB2_PRE = 4 /* AHB clock / 2 */ };\nenum { PLL_HSI = 16, PLL_M = 8, PLL_N = 180, PLL_P = 2 };  // Run at 180 Mhz\n#define PLL_FREQ (PLL_HSI * PLL_N / PLL_M / PLL_P)\n#define FREQ (PLL_FREQ * 1000000)\n```\n\n现在，我们已经准备好使用简单的算法来设置CPU和外设总线的时钟。可能看起来像这样：\n\n- 可选，使能FPU\n- 设置flash延迟\n- 确定时钟源，PLL、APB1和APB2分频\n- 配置RCC\n\n```c\nstatic inline void clock_init(void) {                 // Set clock frequency\n  SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2));  // Enable FPU\n  FLASH->ACR |= FLASH_LATENCY | BIT(8) | BIT(9);      // Flash latency, caches\n  RCC->PLLCFGR &= ~((BIT(17) - 1));                   // Clear PLL multipliers\n  RCC->PLLCFGR |= (((PLL_P - 2) / 2) & 3) << 16;      // Set PLL_P\n  RCC->PLLCFGR |= PLL_M | (PLL_N << 6);               // Set PLL_M and PLL_N\n  RCC->CR |= BIT(24);                                 // Enable PLL\n  while ((RCC->CR & BIT(25)) == 0) spin(1);           // Wait until done\n  RCC->CFGR = (APB1_PRE << 10) | (APB2_PRE << 13);    // Set prescalers\n  RCC->CFGR |= 2;                                     // Set clock source to PLL\n  while ((RCC->CFGR & 12) == 0) spin(1);              // Wait until done\n}\n```\n\n剩下的就是从主函数调用 `clock_init`，然后重新编译和烧写，这样我们的板子就以它的最大速度180MHz运行了！\n\n完整工程源码可以在 [step-6-clock](step-6-clock) 文件夹找到。\n\n## 带设备仪表盘的网络服务器\n\nNucleo-F429ZI 带有板载以太网。以太网硬件需要两个组件：PHY（向铜缆、光缆等介质发送和接收电信号）和 MAC（驱动 PHY 控制器）。\n在我们的Nucleo开发板上，MAC控制器是MCU内置的，PHY是外部的（具体来说，是Microchip的LAN8720a）。\n\nMAC和PHY可以用多个接口通信，我们将使用RMII。为此，一些引脚必须配置为使用其替代功能 （AF）。要实现 Web 服务器，我们需要 3 个软件组件：\n- 网络驱动程序，用于向 MAC 控制器发送/接收以太网帧\n- 一个网络堆栈，用于解析帧并理解 TCP/IP\n- 理解HTTP的网络库\n\n我们将使用[猫鼬网络库]（https://github.com/cesanta/mongoose），它在单个文件中实现所有这些。这是一个双重许可的库（GPLv2/商业），旨在使网络嵌入式开发快速简便。\n\n先拷贝 [mongoose.c](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.c) 和 [mongoose.h](https://raw.githubusercontent.com/cesanta/mongoose/master/mongoose.h) 到我们的工程中，现在我们手上有网络驱动、网络协议栈和HTTP库了，Mongoose还提供了很多示例，其中之一是[设备仪表盘示例](https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard)。这个示例实现了很多事情，像登录、通过WebSocket实时传输数据、嵌入式文件系统、MQTT通信等等，我们就使用这个例子，再拷贝2个文件：\n\n- [net.c](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/net.c)，实现了仪表盘功能\n- [packed_fs.c](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/packed_fs.c)，包含了HTML/CSS/JS GUI文件\n\n我们需要告诉 Mongoose 开启哪些功能，可以通过设置预处理常数等编译器标记实现，也可以在 `mongoose_custom.h` 文件中设置。我们用第二种方法，创建 `mongoose_custom.h` 文件并写入以下内容：\n\n```c\n#pragma once\n#define MG_ARCH MG_ARCH_NEWLIB\n#define MG_ENABLE_MIP 1\n#define MG_ENABLE_PACKED_FS 1\n#define MG_IO_SIZE 512\n#define MG_ENABLE_CUSTOM_MILLIS 1\n```\n\n现在向 `main.c` 添加一些网络代码，`#include \"mongoose.c\"` 初始化以太网RMII引脚，并在RCC中使能以太网：\n\n```c\n  uint16_t pins[] = {PIN('A', 1),  PIN('A', 2),  PIN('A', 7),\n                     PIN('B', 13), PIN('C', 1),  PIN('C', 4),\n                     PIN('C', 5),  PIN('G', 11), PIN('G', 13)};\n  for (size_t i = 0; i < sizeof(pins) / sizeof(pins[0]); i++) {\n    gpio_init(pins[i], GPIO_MODE_AF, GPIO_OTYPE_PUSH_PULL, GPIO_SPEED_INSANE,\n              GPIO_PULL_NONE, 11);\n  }\n  nvic_enable_irq(61);                          // Setup Ethernet IRQ handler\n  RCC->APB2ENR |= BIT(14);                      // Enable SYSCFG\n  SYSCFG->PMC |= BIT(23);                       // Use RMII. Goes first!\n  RCC->AHB1ENR |= BIT(25) | BIT(26) | BIT(27);  // Enable Ethernet clocks\n  RCC->AHB1RSTR |= BIT(25);                     // ETHMAC force reset\n  RCC->AHB1RSTR &= ~BIT(25);                    // ETHMAC release reset\n```\n\nMongoose的驱动程序使用以太网中断，因此我们需要更新 `startup.c` 并将 `ETH_IRQHandler` 添加到向量表中。让我们以不需要任何修改就能添加中断处理函数的方式重新组织 `startup.c` 中的向量表定义，方法是使用“弱符号”概念。\n\n函数可以标记为“弱”，它的工作方式与普通函数类似。当源代码定义具有相同名称的函数时，差异就来了。通常，两个同名的函数会构建失败。但是，如果一个函数被标记为弱函数，则可以构建成功并且链接器会选择非弱函数。这提供了设置样板中的函数为“默认函数”的能力，然后可以在代码中的其他位置简单地创建一个同名函数来覆盖它。\n\n我们接下来用这种方法填充向量表，创建一个 `DefaultIRQHandler()` 并标记为weak，然后给每一个中断处理函数声明一个处理函数名并使它成为 `DefaultIRQHandler()` 的别名：\n\n```c\nvoid __attribute__((weak)) DefaultIRQHandler(void) {\n  for (;;) (void) 0;\n}\n#define WEAK_ALIAS __attribute__((weak, alias(\"DefaultIRQHandler\")))\n\nWEAK_ALIAS void NMI_Handler(void);\nWEAK_ALIAS void HardFault_Handler(void);\nWEAK_ALIAS void MemManage_Handler(void);\n...\n__attribute__((section(\".vectors\"))) void (*tab[16 + 91])(void) = {\n    0, _reset, NMI_Handler, HardFault_Handler, MemManage_Handler,\n    ...\n```\n\n现在，我们可以在代码中定义任何中断处理函数，它会替代默认的那个。这就是我们的例子中所发生的：Mongoose的STM32驱动中定义了一个 `ETH_IRQHandler()`，它会替代默认的中断处理函数。\n\n下一步是初始化Mongoose库：创建时间管理器、配置网络驱动、启动监听HTTP连接：\n\n```c\n  struct mg_mgr mgr;        // Initialise Mongoose event manager\n  mg_mgr_init(&mgr);        // and attach it to the MIP interface\n  mg_log_set(MG_LL_DEBUG);  // Set log level\n\n  struct mip_driver_stm32 driver_data = {.mdc_cr = 4};  // See driver_stm32.h\n  struct mip_if mif = {\n      .mac = {2, 0, 1, 2, 3, 5},\n      .use_dhcp = true,\n      .driver = &mip_driver_stm32,\n      .driver_data = &driver_data,\n  };\n  mip_init(&mgr, &mif);\n  extern void device_dashboard_fn(struct mg_connection *, int, void *, void *);\n  mg_http_listen(&mgr, \"http://0.0.0.0\", device_dashboard_fn, &mgr);\n  MG_INFO((\"Init done, starting main loop\"));\n```\n\n剩下的就是把 `mg_mgr_poll()` 调用加到主循环。\n\n现在把 `mongoose.c`、`net.c` 和 `packed_fs.c` 文件加到Makefile，重新构建，烧写到板子上。连接一个串口控制台到调试输出，可以观察到板子通过DHCP获取了IP地址：\n\n```\n847 3 mongoose.c:6784:arp_cache_add     ARP cache: added 0xc0a80001 @ 90:5c:44:55:19:8b\n84e 2 mongoose.c:6817:onstatechange     READY, IP: 192.168.0.24\n854 2 mongoose.c:6818:onstatechange            GW: 192.168.0.1\n859 2 mongoose.c:6819:onstatechange            Lease: 86363 sec\nLED: 1, tick: 2262\nLED: 0, tick: 2512\n```\n\n打开一个浏览器，输入上面的IP地址，就可以看到一个仪表盘。在[full description](https://github.com/cesanta/mongoose/tree/master/examples/device-dashboard)获取更多细节。\n\n![Device dashboard](https://raw.githubusercontent.com/cesanta/mongoose/master/examples/device-dashboard/screenshots/dashboard.png)\n\n完整工程源码可以 [step-7-webserver](step-7-webserver) 文件夹找到。\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "steps",
          "type": "tree",
          "content": null
        },
        {
          "name": "templates",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}