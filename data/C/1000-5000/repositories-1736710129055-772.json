{
  "metadata": {
    "timestamp": 1736710129055,
    "page": 772,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jgarff/rpi_ws281x",
      "stars": 1811,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0947265625,
          "content": ".sconsign.dblite\nversion.h\n*.pyc\ntest\nnewtest\n*.o\n*.a\n*.swp\n\nbuild/\nrelease/\ndebug/\nsettings.json"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 2.173828125,
          "content": "cmake_minimum_required(VERSION 3.0.0)\n\n# read and parse version file\nfile(READ version PROJECT_VERSION)\nstring(STRIP ${PROJECT_VERSION} PROJECT_VERSION)\nstring(REGEX REPLACE \"([0-9]+)\\\\.[0-9]+\\\\.[0-9]+\" \"\\\\1\" VERSION_MAJOR ${PROJECT_VERSION})\nstring(REGEX REPLACE \"[0-9]+\\\\.([0-9]+)\\\\.[0-9]+\" \"\\\\1\" VERSION_MINOR ${PROJECT_VERSION})\nstring(REGEX REPLACE \"[0-9]+\\\\.[0-9]+\\\\.([0-9]+)\" \"\\\\1\" VERSION_MICRO ${PROJECT_VERSION})\n\nset(HEADERDEF \"${VERSION_MAJOR}_${VERSION_MINOR}_${VERSION_MICRO}\")\n\nproject(rpi_ws281x VERSION ${PROJECT_VERSION})\n\noption(BUILD_SHARED \"Build as shared library\" OFF)\noption(BUILD_TEST \"Build test application\" ON)\n\nset(CMAKE_C_STANDARD 11)\n\nset(LIB_TARGET ws2811)\nset(TEST_TARGET test)\n\nset(LIB_PUBLIC_HEADERS\n    ws2811.h\n    rpihw.h\n    pwm.h\n    clk.h\n    dma.h\n    gpio.h\n    mailbox.h\n    pcm.h\n)\n\nset(LIB_SOURCES\n    mailbox.c\n    ws2811.c\n    pwm.c\n    pcm.c\n    dma.c\n    rpihw.c\n)\n\nset(TEST_SOURCES\n    main.c\n)\n\ninclude(GNUInstallDirs)\n\nconfigure_file(version.h.in version.h)\n\nconfigure_file(\n    \"${CMAKE_CURRENT_SOURCE_DIR}/pkg-config.pc.in\"\n    \"${CMAKE_CURRENT_BINARY_DIR}/libws2811.pc\"\n    @ONLY\n)\n\nset(DEST_HEADERS_DIR include/ws2811)\nset(DEST_LIB_DIR lib)\n\nif(BUILD_SHARED)\n    add_library(${LIB_TARGET} SHARED ${LIB_SOURCES})\nelse()\n    add_library(${LIB_TARGET} ${LIB_SOURCES})\nendif()\n\ntarget_link_libraries(${LIB_TARGET} m)\nset_target_properties(${LIB_TARGET} PROPERTIES PUBLIC_HEADER \"${LIB_PUBLIC_HEADERS}\")\n\ninstall(TARGETS ${LIB_TARGET}\n    ARCHIVE DESTINATION ${DEST_LIB_DIR}\n    PUBLIC_HEADER DESTINATION ${DEST_HEADERS_DIR}\n)\n\nINSTALL(FILES \"${CMAKE_CURRENT_BINARY_DIR}/libws2811.pc\"\n        DESTINATION lib/pkgconfig)\n\ninstall(CODE \"execute_process(COMMAND /sbin/ldconfig\n                              RESULT_VARIABLE EXIT_STATUS\n                              ERROR_QUIET)\n             if (NOT EXIT_STATUS EQUAL 0)\n                 message(\\\"Warning: Could not run ldconfig. You may need to manually run ldconfig as root to cache the newly installed libraries.\\\")\n             endif()\")\n\nif(BUILD_TEST)\n    include_directories(${CMAKE_CURRENT_BINARY_DIR})\n\n    add_executable(${TEST_TARGET} ${TEST_SOURCES})\n    target_link_libraries(${TEST_TARGET} ${LIB_TARGET})\nendif()\n"
        },
        {
          "name": "DEBIAN",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.259765625,
          "content": "Copyright (c) 2014, jgarff\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.0107421875,
          "content": "rpi_ws281x\n==========\n\nUserspace Raspberry Pi library for controlling WS281X LEDs.\nThis includes WS2812 and SK6812RGB RGB LEDs\nPreliminary support is now included for SK6812RGBW LEDs (yes, RGB + W)\nThe LEDs can be controlled by either the PWM (2 independent channels)\nor PCM controller (1 channel) or the SPI interface (1 channel).\n\n### Bindings:\n\nLanguage-specific bindings for rpi_ws281x are available in:\n\n* Python - https://github.com/rpi-ws281x/rpi-ws281x-python\n* Rust - https://github.com/rpi-ws281x/rpi-ws281x-rust\n* Powershell - https://github.com/rpi-ws281x/rpi-ws281x-powershell\n* Java - https://github.com/rpi-ws281x/rpi-ws281x-java\n* CSharp - https://github.com/rpi-ws281x/rpi-ws281x-csharp\n* Go - https://github.com/rpi-ws281x/rpi-ws281x-go\n* Swift - https://github.com/kbongort/rpi-ws281x-swift\n\n### Background:\n\nThe BCM2835 in the Raspberry Pi has both a PWM and a PCM module that\nare well suited to driving individually controllable WS281X LEDs.\nUsing the DMA, PWM or PCM FIFO, and serial mode in the PWM, it's\npossible to control almost any number of WS281X LEDs in a chain connected\nto the appropriate output pin.\nFor SPI the Raspbian spidev driver is used (`/dev/spidev0.0`).\nThis library and test program set the clock rate to 3X the desired output\nfrequency and creates a bit pattern in RAM from an array of colors where\neach bit is represented by 3 bits as follows.\n\n    Bit 1 - 1 1 0\n    Bit 0 - 1 0 0\n\n\n### GPIO Usage:\n\nThe GPIOs that can be used are limited by the hardware of the Pi and will\nvary based on the method used to drive them (PWM, PCM or SPI).\nBeware that the GPIO numbers are not the same as the physical pin numbers\non the header.\n\nPWM:\n```\n        PWM0, which can be set to use GPIOs 12, 18, 40, and 52.\n        Only 12 (pin 32) and 18 (pin 12) are available on the B+/2B/3B\n\n        PWM1 which can be set to use GPIOs 13, 19, 41, 45 and 53.\n        Only 13 is available on the B+/2B/PiZero/3B, on pin 33\n```\n\nPCM:\n```\n        PCM_DOUT, which can be set to use GPIOs 21 and 31.\n        Only 21 is available on the B+/2B/PiZero/3B, on pin 40.\n```\n\nSPI:\n```\n        SPI0-MOSI is available on GPIOs 10 and 38.\n        Only GPIO 10 is available on all models.\n        See also note for RPi 3 below.\n```\n\n\n### Power and voltage requirements\n\nWS281X LEDs are generally driven at 5V. Depending on your actual\nLED model and data line length you might be able to successfully drive\nthe data input with 3.3V. However in the general case you probably\nwant to use a level shifter to convert from the Raspberry Pi GPIO/PWM to 5V.\n\nIt is also possible to run the LEDs from a 3.3V - 3.6V power source, and\nconnect the GPIO directly at a cost of brightness, but this isn't\nrecommended.\n\nThe test program is designed to drive a 8x8 grid of LEDs e.g.from\nAdafruit (http://www.adafruit.com/products/1487) or Pimoroni\n(https://shop.pimoroni.com/products/unicorn-hat).\nPlease see the Adafruit and Pimoroni websites for more information.\n\nKnow what you're doing with the hardware and electricity.  I take no\nreponsibility for damage, harm, or mistakes.\n\n### Build:\n\n#### Build with SCons:\n\n- Install Scons (on raspbian, `apt-get install scons`).\n- Make sure to adjust the parameters in main.c to suit your hardware.\n  - Signal rate (400kHz to 800kHz).  Default 800kHz.\n  - ledstring.invert=1 if using a inverting level shifter.\n  - Width and height of LED matrix (height=1 for LED string).\n- Type `scons` from inside the source directory.\n\n#### Build and install with CMake:\n\n- Install CMake\n- Configure your build:\n\n  For example:\n  ```\n  mkdir build\n  cd build\n  cmake -D BUILD_SHARED=OFF -D BUILD_TEST=ON ..\n  ```\n  See also for available options in `CMakeLists.txt`.\n- Type `cmake --build .` to build\n- To install built binaries and headers into your system type:\n  ```\n  sudo make install\n  ```\n\n### Running:\n\n- Type `sudo ./test` (default uses PWM channel 0).\n- That's it.  You should see a moving rainbow scroll across the\n  display.\n- More options are available, `./test -h` should show them:\n```\n./test version 1.1.0\nUsage: ./test\n-h (--help)    - this information\n-s (--strip)   - strip type - rgb, grb, gbr, rgbw\n-x (--width)   - matrix width (default 8)\n-y (--height)  - matrix height (default 8)\n-d (--dma)     - dma channel to use (default 10)\n-g (--gpio)    - GPIO to use\n                 If omitted, default is 18 (PWM0)\n-i (--invert)  - invert pin output (pulse LOW)\n-c (--clear)   - clear matrix on exit.\n-v (--version) - version information\n```\n\n### Important warning about DMA channels\n\nYou must make sure that the DMA channel you choose to use for the LEDs is not [already in use](https://www.raspberrypi.org/forums/viewtopic.php?p=609380#p609380) by the operating system.\n\nFor example, **using DMA channel 5 [will cause](https://github.com/jgarff/rpi_ws281x/issues/224) filesystem corruption** on the Raspberry Pi 3 Model B.\n\nThe default DMA channel (10) should be safe for the Raspberry Pi 3 Model B, but this may change in future software releases.\n\n### Limitations:\n\n#### PWM\n\nSince this library and the onboard Raspberry Pi audio\nboth use the PWM, they cannot be used together.  You will need to\nblacklist the Broadcom audio kernel module by creating a file\n`/etc/modprobe.d/snd-blacklist.conf` with\n\n    blacklist snd_bcm2835\n\nIf the audio device is still loading after blacklisting, you may also\nneed to comment it out in the /etc/modules file.\n\nOn headless systems you may also need to force audio through hdmi\nEdit config.txt and add:\n\n    hdmi_force_hotplug=1\n    hdmi_force_edid_audio=1\n\nA reboot is required for this change to take effect\n\nSome distributions use audio by default, even if nothing is being played.\nIf audio is needed, you can use a USB audio device instead.\n\n#### PCM\n\nWhen using PCM you cannot use digital audio devices which use I2S since I2S\nuses the PCM hardware, but you can use analog audio.\n\n#### SPI\n\nWhen using SPI the led string is the only device which can be connected to\nthe SPI bus. Both digital (I2S/PCM) and analog (PWM) audio can be used.\n\nMany distributions have a maximum SPI transfer of 4096 bytes. This can be\nchanged in `/boot/cmdline.txt` by appending\n```\n    spidev.bufsiz=32768\n```\n\nOn an RPi 3 you have to change the GPU core frequency to 250 MHz, otherwise\nthe SPI clock has the wrong frequency.\n\nDo this by adding the following line to /boot/config.txt and reboot:\n\n```\n    core_freq=250\n```\n\nOn an RPi 4 you must set a fixed frequency to avoid the idle CPU scaling changing the SPI frequency and breaking the ws281x timings:\n\nDo this by adding the following lines to /boot/config.txt and reboot:\n\n```\n    core_freq=500\n    core_freq_min=500\n```\n\nSPI requires you to be in the `gpio` group if you wish to control your LEDs\nwithout root.\n\n### Comparison PWM/PCM/SPI\n\nBoth PWM and PCM use DMA transfer to output the control signal for the LEDs.\nThe max size of a DMA transfer is 65536 bytes. Since each LED needs 12 bytes\n(4 colors, 8 symbols per color, 3 bits per symbol) this means you can\ncontrol approximately 5400 LEDs for a single strand in PCM and 2700 LEDs per string\nfor PWM (Only PWM can control 2 independent strings simultaneously)\nSPI uses the SPI device driver in the kernel. For transfers larger than\n96 bytes the kernel driver also uses DMA.\nOf course there are practical limits on power and signal quality. These will\nbe more constraining in practice than the theoretical limits above.\n\nWhen controlling a LED string of 240 LEDs the CPU load on the original Pi 2 (BCM2836) are:\n  PWM  5%\n  PCM  5%\n  SPI  1%\n\n### Usage:\n\nThe API is very simple.  Make sure to create and initialize the `ws2811_t`\nstructure as seen in [`main.c`](main.c).  From there it can be initialized\nby calling `ws2811_init()`.  LEDs are changed by modifying the color in\nthe `.led[index]` array and calling `ws2811_render()`.\nThe rest is handled by the library, which either creates the DMA memory and\nstarts the DMA for PWM and PCM or prepares the SPI transfer buffer and sends\nit out on the MISO pin.\n\nMake sure to hook a signal handler for SIGKILL to do cleanup.  From the\nhandler make sure to call `ws2811_fini()`.  It'll make sure that the DMA\nis finished before program execution stops and cleans up after itself.\n"
        },
        {
          "name": "SConscript",
          "type": "blob",
          "size": 2.912109375,
          "content": "#\n# SConscript\n#\n# Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, are permitted\n# provided that the following conditions are met:\n#\n#     1.  Redistributions of source code must retain the above copyright notice, this list of\n#         conditions and the following disclaimer.\n#     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n#         of conditions and the following disclaimer in the documentation and/or other materials\n#         provided with the distribution.\n#     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n#         or promote products derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\n\nImport(['clean_envs'])\n\ntools_env = clean_envs['userspace'].Clone()\n\n\n# Build Library\nlib_srcs = Split('''\n    mailbox.c\n    ws2811.c\n    pwm.c\n    pcm.c\n    dma.c\n    rpihw.c\n''')\n\nversion_hdr = tools_env.Version('version')\nws2811_lib = tools_env.Library('libws2811', lib_srcs)\ntools_env['LIBS'].append(ws2811_lib)\n\n# Shared library (if required)\nws2811_slib = tools_env.SharedLibrary('libws2811', lib_srcs)\n\n# Test Program\nsrcs = Split('''\n    main.c\n''')\n\nobjs = []\nfor src in srcs:\n   objs.append(tools_env.Object(src))\n\ntest = tools_env.Program('test', objs + tools_env['LIBS'])\n\nDefault([test, ws2811_lib])\n\npackage_version = \"1.1.0-1\"\npackage_name = 'libws2811_%s' % package_version\n\ndebian_files = [\n    'DEBIAN/control',\n    'DEBIAN/postinst',\n    'DEBIAN/prerm',\n    'DEBIAN/postrm',\n]\n\npackage_files_desc = [\n    [ '/usr/lib', ws2811_slib ],\n]\n\npackage_files = []\nfor target in package_files_desc:\n    package_files.append(tools_env.Install(package_name + target[0], target[1]))\n\nfor deb_file in debian_files:\n    package_files.append(\n        tools_env.Command('%s/%s' % (package_name, deb_file), deb_file, [\n            Copy(\"$TARGET\", \"$SOURCE\"),\n            Chmod(\"$TARGET\", 0o755)\n        ])\n    )\n\npackage = tools_env.Command('%s.deb' % package_name, package_files,\n                            'cd %s; dpkg-deb --build %s' % (Dir('.').abspath, package_name));\n\nAlias(\"deb\", package)\n\n"
        },
        {
          "name": "SConstruct",
          "type": "blob",
          "size": 2.583984375,
          "content": "#\n# SConstruct\n#\n# Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, are permitted\n# provided that the following conditions are met:\n#\n#     1.  Redistributions of source code must retain the above copyright notice, this list of\n#         conditions and the following disclaimer.\n#     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n#         of conditions and the following disclaimer in the documentation and/or other materials\n#         provided with the distribution.\n#     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n#         or promote products derived from this software without specific prior written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\n\nimport os\n\n\nopts = Variables()\nopts.Add(BoolVariable('V',\n                      'Verbose build',\n                      False))\n\nopts.Add('TOOLCHAIN',\n         'Set toolchain for cross compilation (e.g. arm-linux-gnueabihf)',\n         '')\n\nplatforms = [ \n    [\n        'userspace',            # Target Name\n        [ 'linux', 'version' ], # Scons tool (linux, avr, etc.)\n        {                       # Special environment setup\n            'CPPPATH' : [\n            ],\n            'LINKFLAGS' : [\n                \"-lrt\",\n                \"-lm\",\n            ],\n        },\n    ], \n]\n\nclean_envs = {}\nfor platform, tool, flags in platforms:\n    env = Environment(\n        options = opts,\n        tools = tool,\n        toolpath = ['.'],\n        ENV = {'PATH' : os.environ['PATH']},\n        LIBS = [],\n    )\n    env.MergeFlags(flags)\n    clean_envs[platform] = env\n\nHelp(opts.GenerateHelpText(clean_envs))\n\nif env['TOOLCHAIN'] != '':\n    env['CC'] = env['TOOLCHAIN'] + '-gcc'\n    env['AR'] = env['TOOLCHAIN'] + '-ar'\n\nExport(['clean_envs'])\nSConscript('SConscript');\n\n"
        },
        {
          "name": "clk.h",
          "type": "blob",
          "size": 2.9765625,
          "content": "/*\n * clk.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __CLK_H__\n#define __CLK_H__\n\n#include <stdint.h>\n\ntypedef struct {\n    uint32_t ctl;\n#define CM_CLK_CTL_PASSWD                        (0x5a << 24)\n#define CM_CLK_CTL_MASH(val)                     ((val & 0x3) << 9)\n#define CM_CLK_CTL_FLIP                          (1 << 8)\n#define CM_CLK_CTL_BUSY                          (1 << 7)\n#define CM_CLK_CTL_KILL                          (1 << 5)\n#define CM_CLK_CTL_ENAB                          (1 << 4)\n#define CM_CLK_CTL_SRC_GND                       (0 << 0)\n#define CM_CLK_CTL_SRC_OSC                       (1 << 0)\n#define CM_CLK_CTL_SRC_TSTDBG0                   (2 << 0)\n#define CM_CLK_CTL_SRC_TSTDBG1                   (3 << 0)\n#define CM_CLK_CTL_SRC_PLLA                      (4 << 0)\n#define CM_CLK_CTL_SRC_PLLC                      (5 << 0)\n#define CM_CLK_CTL_SRC_PLLD                      (6 << 0)\n#define CM_CLK_CTL_SRC_HDMIAUX                   (7 << 0)\n    uint32_t div;\n#define CM_CLK_DIV_PASSWD                        (0x5a << 24)\n#define CM_CLK_DIV_DIVI(val)                     ((val & 0xfff) << 12)\n#define CM_CLK_DIV_DIVF(val)                     ((val & 0xfff) << 0)\n} __attribute__((packed, aligned(4))) cm_clk_t;\n\n\n/*\n * PWM and PCM clock offsets from https://www.scribd.com/doc/127599939/BCM2835-Audio-clocks\n *\n */\n#define CM_PCM_OFFSET                            (0x00101098)\n#define CM_PWM_OFFSET                            (0x001010a0)\n\n\n#endif /* __CLK_H__ */\n"
        },
        {
          "name": "dma.c",
          "type": "blob",
          "size": 2.306640625,
          "content": "/*\n * dma.c\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/mman.h>\n\n#include \"dma.h\"\n\n\n// DMA address mapping by DMA number index\nstatic const uint32_t dma_offset[] =\n{\n    DMA0_OFFSET,\n    DMA1_OFFSET,\n    DMA2_OFFSET,\n    DMA3_OFFSET,\n    DMA4_OFFSET,\n    DMA5_OFFSET,\n    DMA6_OFFSET,\n    DMA7_OFFSET,\n    DMA8_OFFSET,\n    DMA9_OFFSET,\n    DMA10_OFFSET,\n    DMA11_OFFSET,\n    DMA12_OFFSET,\n    DMA13_OFFSET,\n    DMA14_OFFSET,\n    DMA15_OFFSET,\n};\n\n\nuint32_t dmanum_to_offset(int dmanum)\n{\n    int array_size = sizeof(dma_offset) / sizeof(dma_offset[0]);\n\n    if (dmanum >= array_size)\n    {\n        return 0;\n    }\n\n    return dma_offset[dmanum];\n}\n\n\n"
        },
        {
          "name": "dma.h",
          "type": "blob",
          "size": 5.5009765625,
          "content": "/*\n * dma.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __DMA_H__\n#define __DMA_H__\n\n#include <stdint.h>\n\n/*\n * DMA Control Block in Main Memory\n *\n * Note: Must start at a 256 byte aligned address.\n *       Use corresponding register field definitions.\n */\ntypedef struct\n{\n    uint32_t ti;\n    uint32_t source_ad;\n    uint32_t dest_ad;\n    uint32_t txfr_len;\n    uint32_t stride;\n    uint32_t nextconbk;\n    uint32_t resvd_0x18[2];\n} __attribute__((packed, aligned(4))) dma_cb_t;\n\n/*\n * DMA register set\n */\ntypedef struct\n{\n    uint32_t cs;\n#define RPI_DMA_CS_RESET                         (1 << 31)\n#define RPI_DMA_CS_ABORT                         (1 << 30)\n#define RPI_DMA_CS_DISDEBUG                      (1 << 29)\n#define RPI_DMA_CS_WAIT_OUTSTANDING_WRITES       (1 << 28)\n#define RPI_DMA_CS_PANIC_PRIORITY(val)           ((val & 0xf) << 20)                \n#define RPI_DMA_CS_PRIORITY(val)                 ((val & 0xf) << 16)\n#define RPI_DMA_CS_ERROR                         (1 << 8)\n#define RPI_DMA_CS_WAITING_OUTSTANDING_WRITES    (1 << 6)\n#define RPI_DMA_CS_DREQ_STOPS_DMA                (1 << 5)\n#define RPI_DMA_CS_PAUSED                        (1 << 4)\n#define RPI_DMA_CS_DREQ                          (1 << 3)\n#define RPI_DMA_CS_INT                           (1 << 2)\n#define RPI_DMA_CS_END                           (1 << 1)\n#define RPI_DMA_CS_ACTIVE                        (1 << 0)\n    uint32_t conblk_ad;\n    uint32_t ti;\n#define RPI_DMA_TI_NO_WIDE_BURSTS                (1 << 26)\n#define RPI_DMA_TI_WAITS(val)                    ((val & 0x1f) << 21)\n#define RPI_DMA_TI_PERMAP(val)                   ((val & 0x1f) << 16)\n#define RPI_DMA_TI_BURST_LENGTH(val)             ((val & 0xf) << 12)\n#define RPI_DMA_TI_SRC_IGNORE                    (1 << 11)\n#define RPI_DMA_TI_SRC_DREQ                      (1 << 10)\n#define RPI_DMA_TI_SRC_WIDTH                     (1 << 9)\n#define RPI_DMA_TI_SRC_INC                       (1 << 8)\n#define RPI_DMA_TI_DEST_IGNORE                   (1 << 7)\n#define RPI_DMA_TI_DEST_DREQ                     (1 << 6)\n#define RPI_DMA_TI_DEST_WIDTH                    (1 << 5)\n#define RPI_DMA_TI_DEST_INC                      (1 << 4)\n#define RPI_DMA_TI_WAIT_RESP                     (1 << 3)\n#define RPI_DMA_TI_TDMODE                        (1 << 1)\n#define RPI_DMA_TI_INTEN                         (1 << 0)\n    uint32_t source_ad;\n    uint32_t dest_ad;\n    uint32_t txfr_len;\n#define RPI_DMA_TXFR_LEN_YLENGTH(val)            ((val & 0xffff) << 16)\n#define RPI_DMA_TXFR_LEN_XLENGTH(val)            ((val & 0xffff) << 0)\n    uint32_t stride;\n#define RPI_DMA_STRIDE_D_STRIDE(val)             ((val & 0xffff) << 16)\n#define RPI_DMA_STRIDE_S_STRIDE(val)             ((val & 0xffff) << 0)\n    uint32_t nextconbk;\n    uint32_t debug;\n} __attribute__((packed, aligned(4))) dma_t;\n\n\n#define DMA0_OFFSET                              (0x00007000)\n#define DMA1_OFFSET                              (0x00007100)\n#define DMA2_OFFSET                              (0x00007200)\n#define DMA3_OFFSET                              (0x00007300)\n#define DMA4_OFFSET                              (0x00007400)\n#define DMA5_OFFSET                              (0x00007500)\n#define DMA6_OFFSET                              (0x00007600)\n#define DMA7_OFFSET                              (0x00007700)\n#define DMA8_OFFSET                              (0x00007800)\n#define DMA9_OFFSET                              (0x00007900)\n#define DMA10_OFFSET                             (0x00007a00)\n#define DMA11_OFFSET                             (0x00007b00)\n#define DMA12_OFFSET                             (0x00007c00)\n#define DMA13_OFFSET                             (0x00007d00)\n#define DMA14_OFFSET                             (0x00007e00)\n#define DMA15_OFFSET                             (0x00e05000)\n\n\n#define PAGE_SIZE                                (1 << 12)\n#define PAGE_MASK                                (~(PAGE_SIZE - 1))\n#define PAGE_OFFSET(page)                        (page & (PAGE_SIZE - 1))\n\n\nuint32_t dmanum_to_offset(int dmanum);\n\n#endif /* __DMA_H__ */\n"
        },
        {
          "name": "gpio.h",
          "type": "blob",
          "size": 4.0791015625,
          "content": "/*\n * gpio.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __GPIO_H__\n#define __GPIO_H__\n\n#include <stdint.h>\n\ntypedef struct\n{\n    uint32_t fsel[6];                            // GPIO Function Select\n    uint32_t resvd_0x18;\n    uint32_t set[2];                             // GPIO Pin Output Set\n    uint32_t resvd_0x24;\n    uint32_t clr[2];                             // GPIO Pin Output Clear\n    uint32_t resvd_0x30;\n    uint32_t lev[2];                             // GPIO Pin Level\n    uint32_t resvd_0x3c;\n    uint32_t eds[2];                             // GPIO Pin Event Detect Status\n    uint32_t resvd_0x48;\n    uint32_t ren[2];                             // GPIO Pin Rising Edge Detect Enable\n    uint32_t resvd_0x54;\n    uint32_t fen[2];                             // GPIO Pin Falling Edge Detect Enable\n    uint32_t resvd_0x60;\n    uint32_t hen[2];                             // GPIO Pin High Detect Enable\n    uint32_t resvd_0x6c;\n    uint32_t len[2];                             // GPIO Pin Low Detect Enable\n    uint32_t resvd_0x78;\n    uint32_t aren[2];                            // GPIO Pin Async Rising Edge Detect\n    uint32_t resvd_0x84;\n    uint32_t afen[2];                            // GPIO Pin Async Falling Edge Detect\n    uint32_t resvd_0x90;\n    uint32_t pud;                                // GPIO Pin Pull up/down Enable\n    uint32_t pudclk[2];                          // GPIO Pin Pull up/down Enable Clock\n    uint32_t resvd_0xa0[4];\n    uint32_t test;\n} __attribute__((packed, aligned(4))) gpio_t;\n\n\n#define GPIO_OFFSET                              (0x00200000)\n\n\nstatic inline void gpio_function_set(volatile gpio_t *gpio, uint8_t pin, uint8_t function)\n{\n    int regnum = pin / 10;\n    int offset = (pin % 10) * 3;\n    uint8_t funcmap[] = { 4, 5, 6, 7, 3, 2 };  // See datasheet for mapping\n\n    if (function > 5)\n    {\n        return;\n    }\n\n    gpio->fsel[regnum] &= ~(0x7 << offset);\n    gpio->fsel[regnum] |= ((funcmap[function]) << offset);\n}\n\nstatic inline void gpio_level_set(volatile gpio_t *gpio, uint8_t pin, uint8_t level)\n{\n    int regnum = pin >> 5;\n    int offset = (pin & 0x1f);\n\n    if (level)\n    {\n        gpio->set[regnum] = (1 << offset);\n    }\n    else\n    {\n        gpio->clr[regnum] = (1 << offset);\n    }\n}\n\nstatic inline void gpio_output_set(volatile gpio_t *gpio, uint8_t pin, uint8_t output)\n{\n    int regnum = pin / 10;\n    int offset = (pin % 10) * 3;\n    uint8_t function = output ? 1 : 0;  // See datasheet for mapping\n\n    gpio->fsel[regnum] &= ~(0x7 << offset);\n    gpio->fsel[regnum] |= ((function & 0x7) << offset);\n}\n\n#endif /* __GPIO_H__ */\n"
        },
        {
          "name": "linux.py",
          "type": "blob",
          "size": 2.775390625,
          "content": "#\n# linux.py\n#\n# Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, are permitted\n# provided that the following conditions are met:\n#\n#     1.  Redistributions of source code must retain the above copyright notice, this list of\n#         conditions and the following disclaimer.\n#     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n#         of conditions and the following disclaimer in the documentation and/or other materials\n#         provided with the distribution.\n#     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n#         or promote products derived from this software without specific prior written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\n\nimport SCons\nimport string\nimport array\nimport os\n\n\ntools = ['gcc', 'g++', 'gnulink', 'ar', 'gas']\n\n\ndef linux_tools(env):\n    for tool in tools:\n        env.Tool(tool)\n\n    if not env['V']:\n        env['ARCOMSTR']      = 'AR      ${TARGET}'\n        env['ASCOMSTR']      = 'AS      ${TARGET}'\n        env['CCCOMSTR']      = 'CC      ${TARGET}'\n        env['CXXCOMSTR']     = 'C++     ${TARGET}'\n        env['LINKCOMSTR']    = 'LINK    ${TARGET}'\n        env['RANLIBCOMSTR']  = 'RANLIB  ${TARGET}'\n\ndef linux_flags(env):\n    env.MergeFlags({\n        'CPPFLAGS' : '''\n            -fPIC\n            -g\n            -O2\n            -Wall\n            -Wextra\n            -Werror\n        '''.split(),\n    }),\n    env.MergeFlags({\n        'LINKFLAGS' : '''\n        '''.split()\n    })\n\n\ndef linux_builders(env):\n    env.Append(BUILDERS = {\n        'Program' : SCons.Builder.Builder(\n            action = SCons.Action.Action('${LINK} -o ${TARGET} ${SOURCES} ${LINKFLAGS}',\n                                         '${LINKCOMSTR}'),\n        ),\n    })\n    return 1\n\n\n# The following are required functions by SCons when incorporating through tools\ndef exists(env):\n    return 1\n\ndef generate(env, **kwargs):\n    [f(env) for f in (linux_tools, linux_flags, linux_builders)]\n\n"
        },
        {
          "name": "mailbox.c",
          "type": "blob",
          "size": 7.248046875,
          "content": "/*\nCopyright (c) 2012, Broadcom Europe Ltd.\nCopyright (c) 2016, Jeremy Garff\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the copyright holder nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <assert.h>\n#include <stdint.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/ioctl.h>\n#include <sys/sysmacros.h>\n#include <sys/stat.h>\n\n#include \"mailbox.h\"\n\n\nvoid *mapmem(uint32_t base, uint32_t size, const char *mem_dev) {\n    uint32_t pagemask = ~0UL ^ (getpagesize() - 1);\n    uint32_t offsetmask = getpagesize() - 1;\n    int mem_fd;\n    void *mem;\n\n    mem_fd = open(mem_dev, O_RDWR | O_SYNC);\n    if (mem_fd < 0) {\n       perror(\"Can't open /dev/mem\");\n       return NULL;\n    }\n\n    mem = mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, mem_fd, base & pagemask);\n    if (mem == MAP_FAILED) {\n        perror(\"mmap error\\n\");\n        return NULL;\n    }\n\n    close(mem_fd);\n\n    return (char *)mem + (base & offsetmask);\n}\n\nvoid *unmapmem(void *addr, uint32_t size) {\n    uint32_t pagemask = ~0UL ^ (getpagesize() - 1);\n    uintptr_t baseaddr = (uintptr_t)addr & pagemask;\n    int s;\n    \n    s = munmap((void *)baseaddr, size);\n    if (s != 0) {\n        perror(\"munmap error\\n\");\n    }\n\n    return NULL;\n}\n\n/*\n * use ioctl to send mbox property message\n */\n\nstatic int mbox_property(int file_desc, void *buf) {\n    int fd = file_desc;\n    int ret_val = -1;\n\n    if (fd < 0) {\n        fd = mbox_open();\n    }\n\n    if (fd >= 0) {\n        ret_val = ioctl(fd, IOCTL_MBOX_PROPERTY, buf);\n\n        if (ret_val < 0) {\n            perror(\"ioctl_set_msg failed\\n\");\n        }\n    }\n\n    if (file_desc < 0) {\n        mbox_close(fd);\n    }\n\n    return ret_val;\n}\n\nuint32_t mem_alloc(int file_desc, uint32_t size, uint32_t align, uint32_t flags) {\n    int i=0;\n    uint32_t p[32];\n\n    p[i++] = 0; // size\n    p[i++] = 0x00000000; // process request\n\n    p[i++] = 0x3000c; // (the tag id)\n    p[i++] = 12; // (size of the buffer)\n    p[i++] = 12; // (size of the data)\n    p[i++] = size; // (num bytes? or pages?)\n    p[i++] = align; // (alignment)\n    p[i++] = flags; // (MEM_FLAG_L1_NONALLOCATING)\n\n    p[i++] = 0x00000000; // end tag\n    p[0] = i*sizeof *p; // actual size\n\n    if (mbox_property(file_desc, p) < 0)\n        return 0;\n    else\n        return p[5];\n}\n\nuint32_t mem_free(int file_desc, uint32_t handle) {\n    int i=0;\n    uint32_t p[32];\n\n    p[i++] = 0; // size\n    p[i++] = 0x00000000; // process request\n\n    p[i++] = 0x3000f; // (the tag id)\n    p[i++] = 4; // (size of the buffer)\n    p[i++] = 4; // (size of the data)\n    p[i++] = handle;\n\n    p[i++] = 0x00000000; // end tag\n    p[0] = i*sizeof *p; // actual size\n\n    mbox_property(file_desc, p);\n\n    return p[5];\n}\n\nuint32_t mem_lock(int file_desc, uint32_t handle) {\n    int i=0;\n    uint32_t p[32];\n\n    p[i++] = 0; // size\n    p[i++] = 0x00000000; // process request\n\n    p[i++] = 0x3000d; // (the tag id)\n    p[i++] = 4; // (size of the buffer)\n    p[i++] = 4; // (size of the data)\n    p[i++] = handle;\n\n    p[i++] = 0x00000000; // end tag\n    p[0] = i*sizeof *p; // actual size\n\n    if (mbox_property(file_desc, p) < 0)\n        return ~0;\n    else\n        return p[5];\n}\n\nuint32_t mem_unlock(int file_desc, uint32_t handle) {\n   int i=0;\n   uint32_t p[32];\n\n   p[i++] = 0; // size\n   p[i++] = 0x00000000; // process request\n\n   p[i++] = 0x3000e; // (the tag id)\n   p[i++] = 4; // (size of the buffer)\n   p[i++] = 4; // (size of the data)\n   p[i++] = handle;\n\n   p[i++] = 0x00000000; // end tag\n   p[0] = i * sizeof(*p); // actual size\n\n   mbox_property(file_desc, p);\n\n   return p[5];\n}\n\nuint32_t execute_code(int file_desc, uint32_t code, uint32_t r0, uint32_t r1, \n                      uint32_t r2, uint32_t r3, uint32_t r4, uint32_t r5) {\n    int i=0;\n    uint32_t p[32];\n\n    p[i++] = 0; // size\n    p[i++] = 0x00000000; // process request\n\n    p[i++] = 0x30010; // (the tag id)\n    p[i++] = 28; // (size of the buffer)\n    p[i++] = 28; // (size of the data)\n    p[i++] = code;\n    p[i++] = r0;\n    p[i++] = r1;\n    p[i++] = r2;\n    p[i++] = r3;\n    p[i++] = r4;\n    p[i++] = r5;\n\n    p[i++] = 0x00000000; // end tag\n    p[0] = i * sizeof(*p); // actual size\n\n    mbox_property(file_desc, p);\n\n    return p[5];\n}\n\nuint32_t qpu_enable(int file_desc, uint32_t enable) {\n    int i=0;\n    uint32_t p[32];\n\n    p[i++] = 0; // size\n    p[i++] = 0x00000000; // process request\n\n    p[i++] = 0x30012; // (the tag id)\n    p[i++] = 4; // (size of the buffer)\n    p[i++] = 4; // (size of the data)\n    p[i++] = enable;\n\n    p[i++] = 0x00000000; // end tag\n    p[0] = i * sizeof(*p); // actual size\n\n    mbox_property(file_desc, p);\n\n    return p[5];\n}\n\nuint32_t execute_qpu(int file_desc, uint32_t num_qpus, uint32_t control,\n                     uint32_t noflush, uint32_t timeout) {\n    int i = 0;\n    uint32_t p[32];\n\n    p[i++] = 0; // size\n    p[i++] = 0x00000000; // process request\n    p[i++] = 0x30011; // (the tag id)\n    p[i++] = 16; // (size of the buffer)\n    p[i++] = 16; // (size of the data)\n    p[i++] = num_qpus;\n    p[i++] = control;\n    p[i++] = noflush;\n    p[i++] = timeout; // ms\n\n    p[i++] = 0x00000000; // end tag\n    p[0] = i * sizeof(*p); // actual size\n\n    mbox_property(file_desc, p);\n\n    return p[5];\n}\n\nint mbox_open(void) {\n    int file_desc;\n    char filename[64];\n\n    file_desc = open(\"/dev/vcio\", 0);\n    if (file_desc >= 0) {\n        return file_desc;\n    }\n\n    // open a char device file used for communicating with kernel mbox driver\n    sprintf(filename, \"/tmp/mailbox-%d\", getpid());\n    unlink(filename);\n    if (mknod(filename, S_IFCHR|0600, makedev(100, 0)) < 0) {\n        perror(\"Failed to create mailbox device\\n\");\n        return -1;\n    }\n    file_desc = open(filename, 0);\n    if (file_desc < 0) {\n        perror(\"Can't open device file\\n\");\n        unlink(filename);\n        return -1;\n    }\n    unlink(filename);\n\n    return file_desc;\n}\n\nvoid mbox_close(int file_desc) {\n    close(file_desc);\n}\n"
        },
        {
          "name": "mailbox.h",
          "type": "blob",
          "size": 2.3798828125,
          "content": "/*\nCopyright (c) 2012, Broadcom Europe Ltd.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the copyright holder nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <linux/ioctl.h>\n\n#define MAJOR_NUM 100\n#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)\n\n#define DEV_MEM     \"/dev/mem\"\n#define DEV_GPIOMEM \"/dev/gpiomem\"\n\nint mbox_open(void);\nvoid mbox_close(int file_desc);\n\nunsigned get_version(int file_desc);\nunsigned mem_alloc(int file_desc, unsigned size, unsigned align, unsigned flags);\nunsigned mem_free(int file_desc, unsigned handle);\nunsigned mem_lock(int file_desc, unsigned handle);\nunsigned mem_unlock(int file_desc, unsigned handle);\nvoid *mapmem(unsigned base, unsigned size, const char *mem_dev);\nvoid *unmapmem(void *addr, unsigned size);\n\nunsigned execute_code(int file_desc, unsigned code, unsigned r0, unsigned r1, unsigned r2, unsigned r3, unsigned r4, unsigned r5);\nunsigned execute_qpu(int file_desc, unsigned num_qpus, unsigned control, unsigned noflush, unsigned timeout);\nunsigned qpu_enable(int file_desc, unsigned enable);\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 9.8642578125,
          "content": "/*\n * newtest.c\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\nstatic char VERSION[] = \"XX.YY.ZZ\";\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <getopt.h>\n\n\n#include \"clk.h\"\n#include \"gpio.h\"\n#include \"dma.h\"\n#include \"pwm.h\"\n#include \"version.h\"\n\n#include \"ws2811.h\"\n\n\n#define ARRAY_SIZE(stuff)       (sizeof(stuff) / sizeof(stuff[0]))\n\n// defaults for cmdline options\n#define TARGET_FREQ             WS2811_TARGET_FREQ\n#define GPIO_PIN                18\n#define DMA                     10\n//#define STRIP_TYPE            WS2811_STRIP_RGB\t\t// WS2812/SK6812RGB integrated chip+leds\n#define STRIP_TYPE              WS2811_STRIP_GBR\t\t// WS2812/SK6812RGB integrated chip+leds\n//#define STRIP_TYPE            SK6812_STRIP_RGBW\t\t// SK6812RGBW (NOT SK6812RGB)\n\n#define WIDTH                   8\n#define HEIGHT                  8\n#define LED_COUNT               (WIDTH * HEIGHT)\n\nint width = WIDTH;\nint height = HEIGHT;\nint led_count = LED_COUNT;\n\nint clear_on_exit = 0;\n\nws2811_t ledstring =\n{\n    .freq = TARGET_FREQ,\n    .dmanum = DMA,\n    .channel =\n    {\n        [0] =\n        {\n            .gpionum = GPIO_PIN,\n            .invert = 0,\n            .count = LED_COUNT,\n            .strip_type = STRIP_TYPE,\n            .brightness = 255,\n        },\n        [1] =\n        {\n            .gpionum = 0,\n            .invert = 0,\n            .count = 0,\n            .brightness = 0,\n        },\n    },\n};\n\nws2811_led_t *matrix;\n\nstatic uint8_t running = 1;\n\nvoid matrix_render(void)\n{\n    int x, y;\n\n    for (x = 0; x < width; x++)\n    {\n        for (y = 0; y < height; y++)\n        {\n            ledstring.channel[0].leds[(y * width) + x] = matrix[y * width + x];\n        }\n    }\n}\n\nvoid matrix_raise(void)\n{\n    int x, y;\n\n    for (y = 0; y < (height - 1); y++)\n    {\n        for (x = 0; x < width; x++)\n        {\n            // This is for the 8x8 Pimoroni Unicorn-HAT where the LEDS in subsequent\n            // rows are arranged in opposite directions\n            matrix[y * width + x] = matrix[(y + 1)*width + width - x - 1];\n        }\n    }\n}\n\nvoid matrix_clear(void)\n{\n    int x, y;\n\n    for (y = 0; y < (height ); y++)\n    {\n        for (x = 0; x < width; x++)\n        {\n            matrix[y * width + x] = 0;\n        }\n    }\n}\n\nint dotspos[] = { 0, 1, 2, 3, 4, 5, 6, 7 };\nws2811_led_t dotcolors[] =\n{\n    0x00200000,  // red\n    0x00201000,  // orange\n    0x00202000,  // yellow\n    0x00002000,  // green\n    0x00002020,  // lightblue\n    0x00000020,  // blue\n    0x00100010,  // purple\n    0x00200010,  // pink\n};\n\nws2811_led_t dotcolors_rgbw[] =\n{\n    0x00200000,  // red\n    0x10200000,  // red + W\n    0x00002000,  // green\n    0x10002000,  // green + W\n    0x00000020,  // blue\n    0x10000020,  // blue + W\n    0x00101010,  // white\n    0x10101010,  // white + W\n\n};\n\nvoid matrix_bottom(void)\n{\n    int i;\n\n    for (i = 0; i < (int)(ARRAY_SIZE(dotspos)); i++)\n    {\n        dotspos[i]++;\n        if (dotspos[i] > (width - 1))\n        {\n            dotspos[i] = 0;\n        }\n\n        if (ledstring.channel[0].strip_type == SK6812_STRIP_RGBW) {\n            matrix[dotspos[i] + (height - 1) * width] = dotcolors_rgbw[i];\n        } else {\n            matrix[dotspos[i] + (height - 1) * width] = dotcolors[i];\n        }\n    }\n}\n\nstatic void ctrl_c_handler(int signum)\n{\n\t(void)(signum);\n    running = 0;\n}\n\nstatic void setup_handlers(void)\n{\n    struct sigaction sa =\n    {\n        .sa_handler = ctrl_c_handler,\n    };\n\n    sigaction(SIGINT, &sa, NULL);\n    sigaction(SIGTERM, &sa, NULL);\n}\n\n\nvoid parseargs(int argc, char **argv, ws2811_t *ws2811)\n{\n\tint index;\n\tint c;\n\n\tstatic struct option longopts[] =\n\t{\n\t\t{\"help\", no_argument, 0, 'h'},\n\t\t{\"dma\", required_argument, 0, 'd'},\n\t\t{\"gpio\", required_argument, 0, 'g'},\n\t\t{\"invert\", no_argument, 0, 'i'},\n\t\t{\"clear\", no_argument, 0, 'c'},\n\t\t{\"strip\", required_argument, 0, 's'},\n\t\t{\"height\", required_argument, 0, 'y'},\n\t\t{\"width\", required_argument, 0, 'x'},\n\t\t{\"version\", no_argument, 0, 'v'},\n\t\t{0, 0, 0, 0}\n\t};\n\n\twhile (1)\n\t{\n\n\t\tindex = 0;\n\t\tc = getopt_long(argc, argv, \"cd:g:his:vx:y:\", longopts, &index);\n\n\t\tif (c == -1)\n\t\t\tbreak;\n\n\t\tswitch (c)\n\t\t{\n\t\tcase 0:\n\t\t\t/* handle flag options (array's 3rd field non-0) */\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\tfprintf(stderr, \"%s version %s\\n\", argv[0], VERSION);\n\t\t\tfprintf(stderr, \"Usage: %s \\n\"\n\t\t\t\t\"-h (--help)    - this information\\n\"\n\t\t\t\t\"-s (--strip)   - strip type - rgb, grb, gbr, rgbw\\n\"\n\t\t\t\t\"-x (--width)   - matrix width (default 8)\\n\"\n\t\t\t\t\"-y (--height)  - matrix height (default 8)\\n\"\n\t\t\t\t\"-d (--dma)     - dma channel to use (default 10)\\n\"\n\t\t\t\t\"-g (--gpio)    - GPIO to use\\n\"\n\t\t\t\t\"                 If omitted, default is 18 (PWM0)\\n\"\n\t\t\t\t\"-i (--invert)  - invert pin output (pulse LOW)\\n\"\n\t\t\t\t\"-c (--clear)   - clear matrix on exit.\\n\"\n\t\t\t\t\"-v (--version) - version information\\n\"\n\t\t\t\t, argv[0]);\n\t\t\texit(-1);\n\n\t\tcase 'D':\n\t\t\tbreak;\n\n\t\tcase 'g':\n\t\t\tif (optarg) {\n\t\t\t\tint gpio = atoi(optarg);\n/*\n\tPWM0, which can be set to use GPIOs 12, 18, 40, and 52.\n\tOnly 12 (pin 32) and 18 (pin 12) are available on the B+/2B/3B\n\tPWM1 which can be set to use GPIOs 13, 19, 41, 45 and 53.\n\tOnly 13 is available on the B+/2B/PiZero/3B, on pin 33\n\tPCM_DOUT, which can be set to use GPIOs 21 and 31.\n\tOnly 21 is available on the B+/2B/PiZero/3B, on pin 40.\n\tSPI0-MOSI is available on GPIOs 10 and 38.\n\tOnly GPIO 10 is available on all models.\n\n\tThe library checks if the specified gpio is available\n\ton the specific model (from model B rev 1 till 3B)\n\n*/\n\t\t\t\tws2811->channel[0].gpionum = gpio;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'i':\n\t\t\tws2811->channel[0].invert=1;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\tclear_on_exit=1;\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\tif (optarg) {\n\t\t\t\tint dma = atoi(optarg);\n\t\t\t\tif (dma < 14) {\n\t\t\t\t\tws2811->dmanum = dma;\n\t\t\t\t} else {\n\t\t\t\t\tprintf (\"invalid dma %d\\n\", dma);\n\t\t\t\t\texit (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'y':\n\t\t\tif (optarg) {\n\t\t\t\theight = atoi(optarg);\n\t\t\t\tif (height > 0) {\n\t\t\t\t\tws2811->channel[0].count = height * width;\n\t\t\t\t} else {\n\t\t\t\t\tprintf (\"invalid height %d\\n\", height);\n\t\t\t\t\texit (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tif (optarg) {\n\t\t\t\twidth = atoi(optarg);\n\t\t\t\tif (width > 0) {\n\t\t\t\t\tws2811->channel[0].count = height * width;\n\t\t\t\t} else {\n\t\t\t\t\tprintf (\"invalid width %d\\n\", width);\n\t\t\t\t\texit (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t\tif (optarg) {\n\t\t\t\tif (!strncasecmp(\"rgb\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = WS2811_STRIP_RGB;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"rbg\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = WS2811_STRIP_RBG;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"grb\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = WS2811_STRIP_GRB;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"gbr\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = WS2811_STRIP_GBR;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"brg\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = WS2811_STRIP_BRG;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"bgr\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = WS2811_STRIP_BGR;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"rgbw\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = SK6812_STRIP_RGBW;\n\t\t\t\t}\n\t\t\t\telse if (!strncasecmp(\"grbw\", optarg, 4)) {\n\t\t\t\t\tws2811->channel[0].strip_type = SK6812_STRIP_GRBW;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprintf (\"invalid strip %s\\n\", optarg);\n\t\t\t\t\texit (-1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s version %s\\n\", argv[0], VERSION);\n\t\t\texit(-1);\n\n\t\tcase '?':\n\t\t\t/* getopt_long already reported error? */\n\t\t\texit(-1);\n\n\t\tdefault:\n\t\t\texit(-1);\n\t\t}\n\t}\n}\n\n\nint main(int argc, char *argv[])\n{\n    ws2811_return_t ret;\n\n    sprintf(VERSION, \"%d.%d.%d\", VERSION_MAJOR, VERSION_MINOR, VERSION_MICRO);\n\n    parseargs(argc, argv, &ledstring);\n\n    matrix = malloc(sizeof(ws2811_led_t) * width * height);\n\n    setup_handlers();\n\n    if ((ret = ws2811_init(&ledstring)) != WS2811_SUCCESS)\n    {\n        fprintf(stderr, \"ws2811_init failed: %s\\n\", ws2811_get_return_t_str(ret));\n        return ret;\n    }\n\n    while (running)\n    {\n        matrix_raise();\n        matrix_bottom();\n        matrix_render();\n\n        if ((ret = ws2811_render(&ledstring)) != WS2811_SUCCESS)\n        {\n            fprintf(stderr, \"ws2811_render failed: %s\\n\", ws2811_get_return_t_str(ret));\n            break;\n        }\n\n        // 15 frames /sec\n        usleep(1000000 / 15);\n    }\n\n    if (clear_on_exit) {\n\tmatrix_clear();\n\tmatrix_render();\n\tws2811_render(&ledstring);\n    }\n\n    ws2811_fini(&ledstring);\n\n    printf (\"\\n\");\n    return ret;\n}\n"
        },
        {
          "name": "pcm.c",
          "type": "blob",
          "size": 3.3203125,
          "content": "/*\n * pcm.c\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n * PCM version Copyright (c) 2016 Ton van Overbeek <tvoverbeek @ gmail.com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n#include \"pcm.h\"\n\n\n// Mapping of Pin to alternate function for PCM_CLK\nconst pcm_pin_table_t pcm_pin_clk[] =\n{\n    {\n        .pinnum = 18,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 28,\n        .altnum = 2,\n    },\n};\n\n// Mapping of Pin to alternate function for PCM_FS\nconst pcm_pin_table_t pcm_pin_fs[] =\n{\n    {\n        .pinnum = 19,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 29,\n        .altnum = 2,\n    },\n};\n\n// Mapping of Pin to alternate function for PCM_DIN\nconst pcm_pin_table_t pcm_pin_din[] =\n{\n    {\n        .pinnum = 20,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 30,\n        .altnum = 2,\n    },\n};\n\n// Mapping of Pin to alternate function for PCM_DOUT\nconst pcm_pin_table_t pcm_pin_dout[] =\n{\n    {\n        .pinnum = 21,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 31,\n        .altnum = 2,\n    },\n};\n\nconst pcm_pin_tables_t pcm_pin_tables[NUM_PCMFUNS] =\n{\n    {\n        .pins = pcm_pin_clk,\n        .count = sizeof(pcm_pin_clk) / sizeof(pcm_pin_clk[0]),\n    },\n    {\n        .pins = pcm_pin_fs,\n        .count = sizeof(pcm_pin_fs) / sizeof(pcm_pin_fs[0]),\n    },\n    {\n        .pins = pcm_pin_din,\n        .count = sizeof(pcm_pin_din) / sizeof(pcm_pin_din[0]),\n    },\n    {\n        .pins = pcm_pin_dout,\n        .count = sizeof(pcm_pin_dout) / sizeof(pcm_pin_dout[0]),\n    },\n};\n\n\nint pcm_pin_alt(int pcmfun, int pinnum)\n{\n    if (pcmfun < 0 || pcmfun > 3) {\n        return -1;\n    }\n    const pcm_pin_tables_t *pintable = &pcm_pin_tables[pcmfun];\n    int i;\n\n    for (i = 0; i < pintable->count; i++)\n    {\n        if (pintable->pins[i].pinnum == pinnum)\n        {\n            return pintable->pins[i].altnum;\n        }\n    }\n\n    return -1;\n}\n\n"
        },
        {
          "name": "pcm.h",
          "type": "blob",
          "size": 6.7666015625,
          "content": "/*\n * pcm.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n * PCM version Copyright (c) Ton van Overbeek <tvoverbeek @ gmail.com>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __PCM_H__\n#define __PCM_H__\n\n#include <stdint.h>\n\n/*\n *\n * Pin mapping of alternate pin configuration for PCM\n *\n * GPIO   ALT PCM_CLK   ALT PCM-FS   ALT PCM_DIN   ALT PCM_DOUT\n *\n *  18        0             \n *  19                      0\n *  20                                   0\n *  21                                                 0\n *  28        2 \n *  29                      2\n *  30                                   2\n *  31                                                 2\n *\n */\n\n\ntypedef struct\n{\n    uint32_t cs;\n#define RPI_PCM_CS_STBY                         (1 << 25)\n#define RPI_PCM_CS_SYNC                         (1 << 24)\n#define RPI_PCM_CS_RXSEX                        (1 << 23)\n#define RPI_PCM_CS_RXF                          (1 << 22)\n#define RPI_PCM_CS_TXE                          (1 << 21)\n#define RPI_PCM_CS_RXD                          (1 << 20)\n#define RPI_PCM_CS_TXD                          (1 << 19)\n#define RPI_PCM_CS_RXR                          (1 << 18)\n#define RPI_PCM_CS_TXW                          (1 << 17)\n#define RPI_PCM_CS_RXERR                        (1 << 16)\n#define RPI_PCM_CS_TXERR                        (1 << 15)\n#define RPI_PCM_CS_RXSYNC                       (1 << 14)\n#define RPI_PCM_CS_TXSYNC                       (1 << 13)\n#define RPI_PCM_CS_DMAEN                        (1 << 9)\n#define RPI_PCM_CS_RXTHR(val)                   ((val & 0x03) << 7)\n#define RPI_PCM_CS_TXTHR(val)                   ((val & 0x03) << 5)\n#define RPI_PCM_CS_RXCLR                        (1 << 4)\n#define RPI_PCM_CS_TXCLR                        (1 << 3)\n#define RPI_PCM_CS_TXON                         (1 << 2)\n#define RPI_PCM_CS_RXON                         (1 << 1)\n#define RPI_PCM_CS_EN                           (1 << 0)\n    uint32_t fifo;\n    uint32_t mode;\n#define RPI_PCM_MODE_CLK_DIS                    (1 << 28)\n#define RPI_PCM_MODE_PDMN                       (1 << 27)\n#define RPI_PCM_MODE_PDME                       (1 << 26)\n#define RPI_PCM_MODE_FRXP                       (1 << 25)\n#define RPI_PCM_MODE_FTXP                       (1 << 24)\n#define RPI_PCM_MODE_CLKM                       (1 << 23)\n#define RPI_PCM_MODE_CLKI                       (1 << 22)\n#define RPI_PCM_MODE_FSM                        (1 << 21)\n#define RPI_PCM_MODE_FSI                        (1 << 20)\n#define RPI_PCM_MODE_FLEN(val)                  ((val & 0x3ff) << 10)\n#define RPI_PCM_MODE_FSLEN(val)                 ((val & 0x3ff) << 0)\n    uint32_t rxc;\n#define RPI_PCM_RXC_CH1WEX                      (1 << 31)\n#define RPI_PCM_RXC_CH1EN                       (1 << 30)\n#define RPI_PCM_RXC_CH1POS(val)                 ((val & 0x3ff) << 20)\n#define RPI_PCM_RXC_CH1WID(val)                 ((val & 0x0f) << 16)\n#define RPI_PCM_RXC_CH2WEX                      (1 << 15)\n#define RPI_PCM_RXC_CH2EN                       (1 << 14)\n#define RPI_PCM_RXC_CH2POS(val)                 ((val & 0x3ff) << 4)\n#define RPI_PCM_RXC_CH2WID(val)                 ((val & 0x0f) << 0)\n    uint32_t txc;\n#define RPI_PCM_TXC_CH1WEX                      (1 << 31)\n#define RPI_PCM_TXC_CH1EN                       (1 << 30)\n#define RPI_PCM_TXC_CH1POS(val)                 ((val & 0x3ff) << 20)\n#define RPI_PCM_TXC_CH1WID(val)                 ((val & 0x0f) << 16)\n#define RPI_PCM_TXC_CH2WEX                      (1 << 15)\n#define RPI_PCM_TXC_CH2EN                       (1 << 14)\n#define RPI_PCM_TXC_CH2POS(val)                 ((val & 0x3ff) << 4)\n#define RPI_PCM_TXC_CH2WID(val)                 ((val & 0x0f) << 0)\n    uint32_t dreq;\n#define RPI_PCM_DREQ_TX_PANIC(val)              ((val & 0x7f) << 24)\n#define RPI_PCM_DREQ_RX_PANIC(val)              ((val & 0x7f) << 16)\n#define RPI_PCM_DREQ_TX(val)                    ((val & 0x7f) << 8)\n#define RPI_PCM_DREQ_RX(val)                    ((val & 0x7f) << 0)\n    uint32_t inten;\n#define RPI_PCM_INTEN_RXERR                     (1 << 3)\n#define RPI_PCM_INTEN_TXERR                     (1 << 2)\n#define RPI_PCM_INTEN_RXR                       (1 << 1)\n#define RPI_PCM_INTEN_TXW                       (1 << 0)\n    uint32_t intstc;\n#define RPI_PCM_INTSTC_RXERR                    (1 << 3)\n#define RPI_PCM_INTSTC_TXERR                    (1 << 2)\n#define RPI_PCM_INTSTC_RXR                      (1 << 1)\n#define RPI_PCM_INTSTC_TXW                      (1 << 0)\n    uint32_t gray;\n#define RPI_PCM_GRAY_RXFIFOLEVEL(val)           ((val & 0x3f) << 16)\n#define RPI_PCM_GRAY_FLUSHED(val)               ((val & 0x3f) << 10\n#define RPI_PCM_GRAY_RXLEVEL(val)               ((val & 0x3f) << 4)\n#define RPI_PCM_GRAY_FLUSH                      (1 << 2)\n#define RPI_PCM_GRAY_CLR                        (1 << 1)\n#define RPI_PCM_GRAY_EN                         (1 << 0)\n} __attribute__((packed, aligned(4))) pcm_t;\n\n\n#define PCM_OFFSET                               (0x00203000)\n#define PCM_PERIPH_PHYS                          (0x7e203000)\n\n#define NUM_PCMFUNS        4\n#define PCMFUN_CLK         0\n#define PCMFUN_FS          1\n#define PCMFUN_DIN         2\n#define PCMFUN_DOUT        3\n\ntypedef struct\n{\n    int pinnum;\n    int altnum;\n} pcm_pin_table_t;\n\ntypedef struct\n{\n    const int count;\n    const pcm_pin_table_t *pins;\n} pcm_pin_tables_t;\n\n\nint pcm_pin_alt(int pcmfun, int pinnum);\n\n\n#endif /* __PCM_H__ */\n"
        },
        {
          "name": "pkg-config.pc.in",
          "type": "blob",
          "size": 0.2548828125,
          "content": "libdir=@CMAKE_INSTALL_FULL_LIBDIR@\nincludedir=@CMAKE_INSTALL_FULL_INCLUDEDIR@/ws2811\n\nName: libws2811\nDescription: Raspberry Pi WS281X Library\nVersion: @VERSION_MAJOR@.@VERSION_MINOR@.@VERSION_MICRO@\nRequires:\nLibs: -L${libdir} -lws2811\nCflags: -I${includedir}\n"
        },
        {
          "name": "pwm.c",
          "type": "blob",
          "size": 2.7890625,
          "content": "/*\n * pwm.c\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n\n#include \"ws2811.h\"\n\n#include \"pwm.h\"\n\n\n// Mapping of Pin to alternate function for PWM channel 0\nconst pwm_pin_table_t pwm_pin_chan0[] =\n{\n    {\n        .pinnum = 12,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 18,\n        .altnum = 5,\n    },\n    {\n        .pinnum = 40,\n        .altnum = 0,\n    },\n};\n\n// Mapping of Pin to alternate function for PWM channel 1\nconst pwm_pin_table_t pwm_pin_chan1[] =\n{\n    {\n        .pinnum = 13,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 19,\n        .altnum = 5,\n    },\n    {\n        .pinnum = 41,\n        .altnum = 0,\n    },\n    {\n        .pinnum = 45,\n        .altnum = 0,\n    },\n};\n\nconst pwm_pin_tables_t pwm_pin_tables[RPI_PWM_CHANNELS] =\n{\n    {\n        .pins = pwm_pin_chan0,\n        .count = sizeof(pwm_pin_chan0) / sizeof(pwm_pin_chan0[0]),\n    },\n    {\n        .pins = pwm_pin_chan1,\n        .count = sizeof(pwm_pin_chan1) / sizeof(pwm_pin_chan1[0]),\n    },\n};\n\n\nint pwm_pin_alt(int chan, int pinnum)\n{\n    const pwm_pin_tables_t *pintable = &pwm_pin_tables[chan];\n    int i;\n\n    for (i = 0; i < pintable->count; i++)\n    {\n        if (pintable->pins[i].pinnum == pinnum)\n        {\n            return pintable->pins[i].altnum;\n        }\n    }\n\n    return -1;\n}\n\n"
        },
        {
          "name": "pwm.h",
          "type": "blob",
          "size": 4.36328125,
          "content": "/*\n * pwm.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#ifndef __PWM_H__\n#define __PWM_H__\n\n#include <stdint.h>\n\n/*\n *\n * Pin mappint of alternate pin configuration for PWM\n *\n * GPIO    ALT PWM0   ALT PWM1\n *\n *  12        0\n *  13                   0\n *  18        5\n *  19                   5\n *  40        0\n *  41                   0\n *  45                   0\n *  52        1\n *  53                   1\n *\n */\n\n\n#define RPI_PWM_CHANNELS                         2\n\n\ntypedef struct\n{\n    uint32_t ctl;\n#define RPI_PWM_CTL_MSEN2                        (1 << 15)\n#define RPI_PWM_CTL_USEF2                        (1 << 13)\n#define RPI_PWM_CTL_POLA2                        (1 << 12)\n#define RPI_PWM_CTL_SBIT2                        (1 << 11)\n#define RPI_PWM_CTL_RPTL2                        (1 << 10)\n#define RPI_PWM_CTL_MODE2                        (1 << 9)\n#define RPI_PWM_CTL_PWEN2                        (1 << 8)\n#define RPI_PWM_CTL_MSEN1                        (1 << 7)\n#define RPI_PWM_CTL_CLRF1                        (1 << 6)\n#define RPI_PWM_CTL_USEF1                        (1 << 5)\n#define RPI_PWM_CTL_POLA1                        (1 << 4)\n#define RPI_PWM_CTL_SBIT1                        (1 << 3)\n#define RPI_PWM_CTL_RPTL1                        (1 << 2)\n#define RPI_PWM_CTL_MODE1                        (1 << 1)\n#define RPI_PWM_CTL_PWEN1                        (1 << 0)\n    uint32_t sta;\n#define RPI_PWM_STA_STA4                         (1 << 12)\n#define RPI_PWM_STA_STA3                         (1 << 11)\n#define RPI_PWM_STA_STA2                         (1 << 10)\n#define RPI_PWM_STA_STA1                         (1 << 9)\n#define RPI_PWM_STA_BERR                         (1 << 8)\n#define RPI_PWM_STA_GAP04                        (1 << 7)\n#define RPI_PWM_STA_GAP03                        (1 << 6)\n#define RPI_PWM_STA_GAP02                        (1 << 5)\n#define RPI_PWM_STA_GAP01                        (1 << 4)\n#define RPI_PWM_STA_RERR1                        (1 << 3)\n#define RPI_PWM_STA_WERR1                        (1 << 2)\n#define RPI_PWM_STA_EMPT1                        (1 << 1)\n#define RPI_PWM_STA_FULL1                        (1 << 0)\n    uint32_t dmac;\n#define RPI_PWM_DMAC_ENAB                        (1 << 31)\n#define RPI_PWM_DMAC_PANIC(val)                  ((val & 0xff) << 8)\n#define RPI_PWM_DMAC_DREQ(val)                   ((val & 0xff) << 0)\n    uint32_t resvd_0x0c;\n    uint32_t rng1;\n    uint32_t dat1;\n    uint32_t fif1;\n    uint32_t resvd_0x1c;\n    uint32_t rng2;\n    uint32_t dat2;\n} __attribute__((packed, aligned(4))) pwm_t;\n\n\n#define PWM_OFFSET                               (0x0020c000)\n#define PWM_PERIPH_PHYS                          (0x7e20c000)\n\n\ntypedef struct\n{\n    int pinnum;\n    int altnum;\n} pwm_pin_table_t;\n\ntypedef struct\n{\n    const int count;\n    const pwm_pin_table_t *pins;\n} pwm_pin_tables_t;\n\n\nint pwm_pin_alt(int chan, int pinnum);\n\n\n#endif /* __PWM_H__ */\n"
        },
        {
          "name": "rpihw.c",
          "type": "blob",
          "size": 17.185546875,
          "content": "/*\n * rpihw.c\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <byteswap.h>\n\n#include \"rpihw.h\"\n\n\n#define LINE_WIDTH_MAX                           80\n#define HW_VER_STRING                            \"Revision\"\n\n#define PERIPH_BASE_RPI                          0x20000000\n#define PERIPH_BASE_RPI2                         0x3f000000\n#define PERIPH_BASE_RPI4                         0xfe000000\n\n#define VIDEOCORE_BASE_RPI                       0x40000000\n#define VIDEOCORE_BASE_RPI2                      0xc0000000\n\n#define RPI_MANUFACTURER_MASK                    (0xf << 16)\n#define RPI_WARRANTY_MASK                        (0x3 << 24)\n\nstatic const rpi_hw_t rpi_hw_info[] = {\n    //\n    // Raspberry Pi 400\n    //\n    {\n        .hwver = 0xc03130,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 400 - 4GB v1.0\"\n    },\n    {\n        .hwver = 0xc03131,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 400 - 4GB v1.1\"\n    },\n\n    //\n    // Raspberry Pi 4\n    //\n    {\n        .hwver = 0xA03111,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 1GB v1.1\"\n    },\n    {\n        .hwver = 0xB03111,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 2GB v.1.1\"\n    },\n    {\n        .hwver = 0xC03111,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 4GB v1.1\"\n    },\n    {\n        .hwver = 0xA03112,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 1GB v1.2\"\n    },\n    {\n        .hwver = 0xB03112,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 2GB v.1.2\"\n    },\n    {\n        .hwver = 0xC03112,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 4GB v1.2\"\n    },\n    {\n        .hwver = 0xb03114,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 2GB v1.4\"\n    },\n    {\n        .hwver = 0xD03114,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 8GB v1.4\"\n    },\n    {\n        .hwver = 0xc03114,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 4GB v1.4\"\n    },\n    {\n        .hwver = 0xa03115,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 1GB v1.5\"\n    },\n    {\n        .hwver = 0xb03115,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 2GB v1.5\"\n    },\n    {\n        .hwver = 0xc03115,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 4GB v1.5\"\n    },\n    {\n        .hwver = 0xd03115,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 4 Model B - 8GB v1.5\"\n    },\n\n    //\n    // Compute Module 4\n    //\n    {\n        .hwver = 0xa03140,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 v1.0 eMMC\"\n    },\n    {\n        .hwver = 0xb03140,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 v1.0 Lite\"\n    },\n    {\n        .hwver = 0xc03140,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 v1.0 WiFi\"\n    },\n    {\n        .hwver = 0xd03140,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 v1.0 WiFi 8GB\"\n    },\n    {\n        .hwver = 0xa03141,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 Rev 1.1\"\n    },\n    {\n        .hwver = 0xb03141,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 Rev 1.1\"\n    },\n    {\n        .hwver = 0xc03141,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 Rev 1.1\"\n    },\n    {\n        .hwver = 0xd03141,\n        .type = RPI_HWVER_TYPE_PI4,\n        .periph_base = PERIPH_BASE_RPI4,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 4 Rev 1.1\"\n    },\n\n    //\n    // Model B Rev 1.0\n    //\n    {\n        .hwver  = 0x02,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n    {\n        .hwver  = 0x03,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n\n    //\n    // Model B Rev 2.0\n    //\n    {\n        .hwver  = 0x04,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n    {\n        .hwver  = 0x05,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n    {\n        .hwver  = 0x06,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n\n    //\n    // Model A\n    //\n    {\n        .hwver  = 0x07,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model A\",\n    },\n    {\n        .hwver  = 0x08,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model A\",\n    },\n    {\n        .hwver  = 0x09,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model A\",\n    },\n\n    //\n    // Model B\n    //\n    {\n        .hwver  = 0x0d,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n    {\n        .hwver  = 0x0e,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n    {\n        .hwver  = 0x0f,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B\",\n    },\n\n    //\n    // Model B+\n    //\n    {\n        .hwver  = 0x10,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B+\",\n    },\n    {\n        .hwver  = 0x13,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B+\",\n    },\n    {\n        .hwver  = 0x900032,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model B+\",\n    },\n\n    //\n    // Compute Module\n    //\n    {\n        .hwver  = 0x11,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Compute Module 1\",\n    },\n    {\n        .hwver  = 0x14,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Compute Module 1\",\n    },\n    {\n        .hwver  = 0xa020a0,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 3/L3\",\n    },\n    {\n        .hwver  = 0xa02100,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Compute Module 3+\",\n    },\n    {\n            .hwver  = 0xa220a0,\n            .type = RPI_HWVER_TYPE_PI2,\n            .periph_base = PERIPH_BASE_RPI2,\n            .videocore_base = VIDEOCORE_BASE_RPI2,\n            .desc = \"Compute Module 3 Rev 1.0\",\n    },\n\n    //\n    // Pi Zero\n    //\n    {\n        .hwver  = 0x900092,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Pi Zero v1.2\",\n    },\n    {\n        .hwver  = 0x900093,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Pi Zero v1.3\",\n    },\n    {\n        .hwver  = 0x920093,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Pi Zero v1.3\",\n    },\n    {\n        .hwver  = 0x9200c1,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Pi Zero W v1.1\",\n    },\n    {\n        .hwver  = 0x9000c1,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Pi Zero W v1.1\",\n    },\n\n    //\n    // Model Zero 2 W\n    //\n    {\n        .hwver  = 0x902120,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi Zero 2 W v1.0\",\n    },\n\n    //\n    // Model A+\n    //\n    {\n        .hwver  = 0x12,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model A+\",\n    },\n    {\n        .hwver  = 0x15,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model A+\",\n    },\n    {\n        .hwver  = 0x900021,\n        .type = RPI_HWVER_TYPE_PI1,\n        .periph_base = PERIPH_BASE_RPI,\n        .videocore_base = VIDEOCORE_BASE_RPI,\n        .desc = \"Model A+\",\n    },\n\n    //\n    // Pi 2 Model B\n    //\n    {\n        .hwver  = 0xa01041,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 2\",\n    },\n    {\n        .hwver  = 0xa01040,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 2\",\n    },\n    {\n        .hwver  = 0xa21041,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 2\",\n    },\n    //\n    // Pi 2 with BCM2837\n    //\n    {\n        .hwver  = 0xa22042,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 2\",\n    },\n    //\n    // Pi 3 Model B\n    //\n    {\n        .hwver  = 0xa020d4,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3 B+\",\n    },\n    {\n        .hwver  = 0xa020d3,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3 B+\",\n    },\n    {\n        .hwver  = 0xa32082,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3 B\",\n    },\n    {\n        .hwver  = 0xa52082,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3 B\",\n    },\n    {\n        .hwver  = 0xa02082,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3\",\n    },\n    {\n        .hwver  = 0xa02083,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3\",\n    },\n    {\n        .hwver  = 0xa22082,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3\",\n    },\n    {\n        .hwver  = 0xa22083,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Pi 3\",\n    },\n    {\n        .hwver  = 0x9020e0,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Model 3 A+\",\n    },\n    {\n        .hwver  = 0x9020e1,\n        .type = RPI_HWVER_TYPE_PI2,\n        .periph_base = PERIPH_BASE_RPI2,\n        .videocore_base = VIDEOCORE_BASE_RPI2,\n        .desc = \"Model 3 A+\",\n    }\n};\n\n\nconst rpi_hw_t *rpi_hw_detect(void)\n{\n    const rpi_hw_t *result = NULL;\n    uint32_t rev;\n    unsigned i;\n\n#ifdef __aarch64__\n    // On ARM64, read revision from /proc/device-tree as it is not shown in\n    // /proc/cpuinfo\n    FILE *f = fopen(\"/proc/device-tree/system/linux,revision\", \"r\");\n    if (!f)\n    {\n        return NULL;\n    }\n    size_t read = fread(&rev, 1, sizeof(uint32_t), f);\n    if (read != sizeof(uint32_t))\n        goto done;\n    #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n        rev = bswap_32(rev);  // linux,revision appears to be in big endian\n    #endif\n\n    for (i = 0; i < (sizeof(rpi_hw_info) / sizeof(rpi_hw_info[0])); i++)\n    {\n        uint32_t hwver = rpi_hw_info[i].hwver;\n        if (rev == hwver)\n        {\n            result = &rpi_hw_info[i];\n\n            goto done;\n        }\n    }\n#else\n    FILE *f = fopen(\"/proc/cpuinfo\", \"r\");\n    char line[LINE_WIDTH_MAX];\n\n    if (!f)\n    {\n        return NULL;\n    }\n\n    while (fgets(line, LINE_WIDTH_MAX - 1, f))\n    {\n        if (strstr(line, HW_VER_STRING))\n        {\n            char *substr;\n\n            substr = strstr(line, \": \");\n            if (!substr)\n            {\n                continue;\n            }\n\n            errno = 0;\n            rev = strtoul(&substr[1], NULL, 16);  // Base 16\n            if (errno)\n            {\n                continue;\n            }\n\n            for (i = 0; i < (sizeof(rpi_hw_info) / sizeof(rpi_hw_info[0])); i++)\n            {\n                uint32_t hwver = rpi_hw_info[i].hwver;\n\n                // Take out warranty and manufacturer bits\n                hwver &= ~(RPI_WARRANTY_MASK | RPI_MANUFACTURER_MASK);\n                rev &= ~(RPI_WARRANTY_MASK | RPI_MANUFACTURER_MASK);\n\n                if (rev == hwver)\n                {\n                    result = &rpi_hw_info[i];\n\n                    goto done;\n                }\n            }\n        }\n    }\n#endif\ndone:\n    fclose(f);\n\n    return result;\n}\n"
        },
        {
          "name": "rpihw.h",
          "type": "blob",
          "size": 2.03125,
          "content": "/*\n * rpihw.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#ifndef __RPIHW_H__\n#define __RPIHW_H__\n\n#include <stdint.h>\n\ntypedef struct {\n    uint32_t type;\n#define RPI_HWVER_TYPE_UNKNOWN                   0\n#define RPI_HWVER_TYPE_PI1                       1\n#define RPI_HWVER_TYPE_PI2                       2\n#define RPI_HWVER_TYPE_PI4                       3\n    uint32_t hwver;\n    uint32_t periph_base;\n    uint32_t videocore_base;\n    char *desc;\n} rpi_hw_t;\n\n\nconst rpi_hw_t *rpi_hw_detect(void);\n\n\n#endif /* __RPIHW_H__ */\n"
        },
        {
          "name": "version",
          "type": "blob",
          "size": 0.005859375,
          "content": "1.1.0\n"
        },
        {
          "name": "version.h.in",
          "type": "blob",
          "size": 0.2666015625,
          "content": "/* Auto Generated Header built by version.py - DO NOT MODIFY */\n\n#ifndef __@HEADERDEF@__\n#define __@HEADERDEF@__\n\n#define VERSION_MAJOR @VERSION_MAJOR@\n#define VERSION_MINOR @VERSION_MINOR@\n#define VERSION_MICRO @VERSION_MICRO@\n                \n#endif /* __@HEADERDEF@__ */"
        },
        {
          "name": "version.py",
          "type": "blob",
          "size": 2.849609375,
          "content": "#\n# SConstruct\n#\n# Copyright (c) 2016 Jeremy Garff <jer @ jers.net>\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without modification, are permitted\n# provided that the following conditions are met:\n#\n#     1.  Redistributions of source code must retain the above copyright notice, this list of\n#         conditions and the following disclaimer.\n#     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n#         of conditions and the following disclaimer in the documentation and/or other materials\n#         provided with the distribution.\n#     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n#         or promote products derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n# FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n# OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n\nimport SCons, os\n\ndef version_flags(env):\n    if not env['V']:\n        env['VERSIONCOMSTR'] = 'Version ${TARGET}'\n\ndef version_builders(env):\n    def generate_version_header(target, source, env):\n        headername = os.path.basename(target[0].abspath)\n        headerdef = headername.replace('.', '_').replace('-', '_').upper()\n\n        try:\n            version = open(source[0].abspath, 'r').readline().strip().split('.')\n        except:\n            version = [ '0', '0', '0' ]\n\n        f = open(headername, 'w')\n        f.write('/* Auto Generated Header built by version.py - DO NOT MODIFY */\\n')\n        f.write('\\n')\n        f.write('#ifndef __%s__\\n' % (headerdef))\n        f.write('#define __%s__\\n' % (headerdef))\n        f.write('\\n')\n        f.write('#define VERSION_MAJOR %s\\n' % version[0])\n        f.write('#define VERSION_MINOR %s\\n' % version[1])\n        f.write('#define VERSION_MICRO %s\\n' % version[2])\n        f.write('\\n')\n        f.write('#endif /* __%s__ */\\n' % (headerdef))\n        f.close()\n\n    env.Append(BUILDERS = {\n        'Version' : SCons.Builder.Builder(\n            action = SCons.Action.Action(generate_version_header, '${VERSIONCOMSTR}'),\n            suffix = '.h',\n        ),\n    })\n\ndef exists(env):\n    return 1\n\ndef generate(env, **kwargs):\n    [f(env) for f in (version_flags, version_builders)]\n\n\n"
        },
        {
          "name": "ws2811.c",
          "type": "blob",
          "size": 39.2578125,
          "content": "/*\n * ws2811.c\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <signal.h>\n#include <linux/types.h>\n#include <linux/spi/spidev.h>\n#include <time.h>\n#include <math.h>\n#include \"mailbox.h\"\n#include \"clk.h\"\n#include \"gpio.h\"\n#include \"dma.h\"\n#include \"pwm.h\"\n#include \"pcm.h\"\n#include \"rpihw.h\"\n\n#include \"ws2811.h\"\n\n\n#define BUS_TO_PHYS(x)                           ((x)&~0xC0000000)\n\n#define OSC_FREQ                                 19200000   // crystal frequency\n#define OSC_FREQ_PI4                             54000000   // Pi 4 crystal frequency\n\n/* 4 colors (R, G, B + W), 8 bits per byte, 3 symbols per bit + 55uS low for reset signal */\n#define LED_COLOURS                              4\n#define LED_RESET_uS                             55\n#define LED_BIT_COUNT(leds, freq)                ((leds * LED_COLOURS * 8 * 3) + ((LED_RESET_uS * \\\n                                                  (freq * 3)) / 1000000))\n\n/* Minimum time to wait for reset to occur in microseconds. */\n#define LED_RESET_WAIT_TIME                      300\n\n// Pad out to the nearest uint32 + 32-bits for idle low/high times the number of channels\n#define PWM_BYTE_COUNT(leds, freq)               (((((LED_BIT_COUNT(leds, freq) >> 3) & ~0x7) + 4) + 4) * \\\n                                                  RPI_PWM_CHANNELS)\n#define PCM_BYTE_COUNT(leds, freq)               ((((LED_BIT_COUNT(leds, freq) >> 3) & ~0x7) + 4) + 4)\n\n// Driver mode definitions\n#define NONE\t0\n#define PWM\t1\n#define PCM\t2\n#define SPI\t3\n\n// We use the mailbox interface to request memory from the VideoCore.\n// This lets us request one physically contiguous chunk, find its\n// physical address, and map it 'uncached' so that writes from this\n// code are immediately visible to the DMA controller.  This struct\n// holds data relevant to the mailbox interface.\ntypedef struct videocore_mbox {\n    int handle;             /* From mbox_open() */\n    unsigned mem_ref;       /* From mem_alloc() */\n    unsigned bus_addr;      /* From mem_lock() */\n    unsigned size;          /* Size of allocation */\n    uint8_t *virt_addr;     /* From mapmem() */\n} videocore_mbox_t;\n\ntypedef struct ws2811_device\n{\n    int driver_mode;\n    volatile uint8_t *pxl_raw;\n    volatile dma_t *dma;\n    volatile pwm_t *pwm;\n    volatile pcm_t *pcm;\n    int spi_fd;\n    volatile dma_cb_t *dma_cb;\n    uint32_t dma_cb_addr;\n    volatile gpio_t *gpio;\n    volatile cm_clk_t *cm_clk;\n    videocore_mbox_t mbox;\n    int max_count;\n} ws2811_device_t;\n\n/**\n * Provides monotonic timestamp in microseconds.\n *\n * @returns  Current timestamp in microseconds or 0 on error.\n */\nstatic uint64_t get_microsecond_timestamp()\n{\n    struct timespec t;\n\n    if (clock_gettime(CLOCK_MONOTONIC_RAW, &t) != 0) {\n        return 0;\n    }\n\n    return (uint64_t) t.tv_sec * 1000000 + t.tv_nsec / 1000;\n}\n\n/**\n * Iterate through the channels and find the largest led count.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  Maximum number of LEDs in all channels.\n */\nstatic int max_channel_led_count(ws2811_t *ws2811)\n{\n    int chan, max = 0;\n\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        if (ws2811->channel[chan].count > max)\n        {\n            max = ws2811->channel[chan].count;\n        }\n    }\n\n    return max;\n}\n\n/**\n * Map all devices into userspace memory.\n * Not called for SPI\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  0 on success, -1 otherwise.\n */\nstatic int map_registers(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    const rpi_hw_t *rpi_hw = ws2811->rpi_hw;\n    uint32_t base = ws2811->rpi_hw->periph_base;\n    uint32_t dma_addr;\n    uint32_t offset = 0;\n\n    dma_addr = dmanum_to_offset(ws2811->dmanum);\n    if (!dma_addr)\n    {\n        return -1;\n    }\n    dma_addr += rpi_hw->periph_base;\n\n    device->dma = mapmem(dma_addr, sizeof(dma_t), DEV_MEM);\n    if (!device->dma)\n    {\n        return -1;\n    }\n\n    switch (device->driver_mode) {\n    case PWM:\n        device->pwm = mapmem(PWM_OFFSET + base, sizeof(pwm_t), DEV_MEM);\n        if (!device->pwm)\n        {\n            return -1;\n        }\n        break;\n\n    case PCM:\n        device->pcm = mapmem(PCM_OFFSET + base, sizeof(pcm_t), DEV_MEM);\n        if (!device->pcm)\n        {\n            return -1;\n        }\n        break;\n    }\n\n    /*\n     * The below call can potentially work with /dev/gpiomem instead.\n     * However, it used /dev/mem before, so I'm leaving it as such.\n     */\n\n    device->gpio = mapmem(GPIO_OFFSET + base, sizeof(gpio_t), DEV_MEM);\n    if (!device->gpio)\n    {\n        return -1;\n    }\n\n    switch (device->driver_mode) {\n    case PWM:\n        offset = CM_PWM_OFFSET;\n        break;\n    case PCM:\n        offset = CM_PCM_OFFSET;\n        break;\n    }\n    device->cm_clk = mapmem(offset + base, sizeof(cm_clk_t), DEV_MEM);\n    if (!device->cm_clk)\n    {\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * Unmap all devices from virtual memory.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nstatic void unmap_registers(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n\n    if (device->dma)\n    {\n        unmapmem((void *)device->dma, sizeof(dma_t));\n    }\n\n    if (device->pwm)\n    {\n        unmapmem((void *)device->pwm, sizeof(pwm_t));\n    }\n\n    if (device->pcm)\n    {\n        unmapmem((void *)device->pcm, sizeof(pcm_t));\n    }\n\n    if (device->cm_clk)\n    {\n        unmapmem((void *)device->cm_clk, sizeof(cm_clk_t));\n    }\n\n    if (device->gpio)\n    {\n        unmapmem((void *)device->gpio, sizeof(gpio_t));\n    }\n}\n\n/**\n * Given a userspace address pointer, return the matching bus address used by DMA.\n *     Note: The bus address is not the same as the CPU physical address.\n *\n * @param    addr   Userspace virtual address pointer.\n *\n * @returns  Bus address for use by DMA.\n */\nstatic uint32_t addr_to_bus(ws2811_device_t *device, const volatile void *virt)\n{\n    videocore_mbox_t *mbox = &device->mbox;\n\n    uint32_t offset = (uint8_t *)virt - mbox->virt_addr;\n\n    return mbox->bus_addr + offset;\n}\n\n/**\n * Stop the PWM controller.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nstatic void stop_pwm(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    volatile pwm_t *pwm = device->pwm;\n    volatile cm_clk_t *cm_clk = device->cm_clk;\n\n    // Turn off the PWM in case already running\n    pwm->ctl = 0;\n    usleep(10);\n\n    // Kill the clock if it was already running\n    cm_clk->ctl = CM_CLK_CTL_PASSWD | CM_CLK_CTL_KILL;\n    usleep(10);\n    while (cm_clk->ctl & CM_CLK_CTL_BUSY)\n        ;\n}\n\n/**\n * Stop the PCM controller.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nstatic void stop_pcm(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    volatile pcm_t *pcm = device->pcm;\n    volatile cm_clk_t *cm_clk = device->cm_clk;\n\n    // Turn off the PCM in case already running\n    pcm->cs = 0;\n    usleep(10);\n\n    // Kill the clock if it was already running\n    cm_clk->ctl = CM_CLK_CTL_PASSWD | CM_CLK_CTL_KILL;\n    usleep(10);\n    while (cm_clk->ctl & CM_CLK_CTL_BUSY)\n        ;\n}\n\n/**\n * Setup the PWM controller in serial mode on both channels using DMA to feed the PWM FIFO.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nstatic int setup_pwm(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    volatile dma_t *dma = device->dma;\n    volatile dma_cb_t *dma_cb = device->dma_cb;\n    volatile pwm_t *pwm = device->pwm;\n    volatile cm_clk_t *cm_clk = device->cm_clk;\n    int maxcount = device->max_count;\n    uint32_t freq = ws2811->freq;\n    int32_t byte_count;\n\n    const rpi_hw_t *rpi_hw = ws2811->rpi_hw;\n    const uint32_t rpi_type = rpi_hw->type;\n    uint32_t osc_freq = OSC_FREQ;\n\n    if(rpi_type == RPI_HWVER_TYPE_PI4){\n        osc_freq = OSC_FREQ_PI4;\n    }\n\n    stop_pwm(ws2811);\n\n    // Setup the Clock - Use OSC @ 19.2Mhz w/ 3 clocks/tick\n    cm_clk->div = CM_CLK_DIV_PASSWD | CM_CLK_DIV_DIVI(osc_freq / (3 * freq));\n    cm_clk->ctl = CM_CLK_CTL_PASSWD | CM_CLK_CTL_SRC_OSC;\n    cm_clk->ctl = CM_CLK_CTL_PASSWD | CM_CLK_CTL_SRC_OSC | CM_CLK_CTL_ENAB;\n    usleep(10);\n    while (!(cm_clk->ctl & CM_CLK_CTL_BUSY))\n        ;\n\n    // Setup the PWM, use delays as the block is rumored to lock up without them.  Make\n    // sure to use a high enough priority to avoid any FIFO underruns, especially if\n    // the CPU is busy doing lots of memory accesses, or another DMA controller is\n    // busy.  The FIFO will clock out data at a much slower rate (2.6Mhz max), so\n    // the odds of a DMA priority boost are extremely low.\n\n    pwm->rng1 = 32;  // 32-bits per word to serialize\n    usleep(10);\n    pwm->ctl = RPI_PWM_CTL_CLRF1;\n    usleep(10);\n    pwm->dmac = RPI_PWM_DMAC_ENAB | RPI_PWM_DMAC_PANIC(7) | RPI_PWM_DMAC_DREQ(3);\n    usleep(10);\n    pwm->ctl = RPI_PWM_CTL_USEF1 | RPI_PWM_CTL_MODE1 |\n               RPI_PWM_CTL_USEF2 | RPI_PWM_CTL_MODE2;\n    if (ws2811->channel[0].invert)\n    {\n        pwm->ctl |= RPI_PWM_CTL_POLA1;\n    }\n    if (ws2811->channel[1].invert)\n    {\n        pwm->ctl |= RPI_PWM_CTL_POLA2;\n    }\n    usleep(10);\n    pwm->ctl |= RPI_PWM_CTL_PWEN1 | RPI_PWM_CTL_PWEN2;\n\n    // Initialize the DMA control block\n    byte_count = PWM_BYTE_COUNT(maxcount, freq);\n    dma_cb->ti = RPI_DMA_TI_NO_WIDE_BURSTS |  // 32-bit transfers\n                 RPI_DMA_TI_WAIT_RESP |       // wait for write complete\n                 RPI_DMA_TI_DEST_DREQ |       // user peripheral flow control\n                 RPI_DMA_TI_PERMAP(5) |       // PWM peripheral\n                 RPI_DMA_TI_SRC_INC;          // Increment src addr\n\n    dma_cb->source_ad = addr_to_bus(device, device->pxl_raw);\n\n    dma_cb->dest_ad = (uintptr_t)&((pwm_t *)PWM_PERIPH_PHYS)->fif1;\n    dma_cb->txfr_len = byte_count;\n    dma_cb->stride = 0;\n    dma_cb->nextconbk = 0;\n\n    dma->cs = 0;\n    dma->txfr_len = 0;\n\n    return 0;\n}\n\n/**\n * Setup the PCM controller with one 32-bit channel in a 32-bit frame using DMA to feed the PCM FIFO.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nstatic int setup_pcm(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    volatile dma_t *dma = device->dma;\n    volatile dma_cb_t *dma_cb = device->dma_cb;\n    volatile pcm_t *pcm = device->pcm;\n    volatile cm_clk_t *cm_clk = device->cm_clk;\n    //int maxcount = max_channel_led_count(ws2811);\n    int maxcount = device->max_count;\n    uint32_t freq = ws2811->freq;\n    int32_t byte_count;\n\n    const rpi_hw_t *rpi_hw = ws2811->rpi_hw;\n    const uint32_t rpi_type = rpi_hw->type;\n    uint32_t osc_freq = OSC_FREQ;\n\n    if(rpi_type == RPI_HWVER_TYPE_PI4){\n        osc_freq = OSC_FREQ_PI4;\n    }\n\n    stop_pcm(ws2811);\n\n    // Setup the PCM Clock - Use OSC @ 19.2Mhz w/ 3 clocks/tick\n    cm_clk->div = CM_CLK_DIV_PASSWD | CM_CLK_DIV_DIVI(osc_freq / (3 * freq));\n    cm_clk->ctl = CM_CLK_CTL_PASSWD | CM_CLK_CTL_SRC_OSC;\n    cm_clk->ctl = CM_CLK_CTL_PASSWD | CM_CLK_CTL_SRC_OSC | CM_CLK_CTL_ENAB;\n    usleep(10);\n    while (!(cm_clk->ctl & CM_CLK_CTL_BUSY))\n        ;\n\n    // Setup the PCM, use delays as the block is rumored to lock up without them.  Make\n    // sure to use a high enough priority to avoid any FIFO underruns, especially if\n    // the CPU is busy doing lots of memory accesses, or another DMA controller is\n    // busy.  The FIFO will clock out data at a much slower rate (2.6Mhz max), so\n    // the odds of a DMA priority boost are extremely low.\n\n    pcm->cs = RPI_PCM_CS_EN;            // Enable PCM hardware\n    pcm->mode = (RPI_PCM_MODE_FLEN(31) | RPI_PCM_MODE_FSLEN(1));\n                // Framelength 32, clock enabled, frame sync pulse\n    pcm->txc = RPI_PCM_TXC_CH1WEX | RPI_PCM_TXC_CH1EN | RPI_PCM_TXC_CH1POS(0) | RPI_PCM_TXC_CH1WID(8);\n               // Single 32-bit channel\n    pcm->cs |= RPI_PCM_CS_TXCLR;        // Reset transmit fifo\n    usleep(10);\n    pcm->cs |= RPI_PCM_CS_DMAEN;         // Enable DMA DREQ\n    pcm->dreq = (RPI_PCM_DREQ_TX(0x3F) | RPI_PCM_DREQ_TX_PANIC(0x10)); // Set FIFO tresholds\n\n    // Initialize the DMA control block\n    byte_count = PCM_BYTE_COUNT(maxcount, freq);\n    dma_cb->ti = RPI_DMA_TI_NO_WIDE_BURSTS |  // 32-bit transfers\n                 RPI_DMA_TI_WAIT_RESP |       // wait for write complete\n                 RPI_DMA_TI_DEST_DREQ |       // user peripheral flow control\n                 RPI_DMA_TI_PERMAP(2) |       // PCM TX peripheral\n                 RPI_DMA_TI_SRC_INC;          // Increment src addr\n\n    dma_cb->source_ad = addr_to_bus(device, device->pxl_raw);\n    dma_cb->dest_ad = (uintptr_t)&((pcm_t *)PCM_PERIPH_PHYS)->fifo;\n    dma_cb->txfr_len = byte_count;\n    dma_cb->stride = 0;\n    dma_cb->nextconbk = 0;\n\n    dma->cs = 0;\n    dma->txfr_len = 0;\n\n    return 0;\n}\n\n/**\n * Start the DMA feeding the PWM FIFO.  This will stream the entire DMA buffer out of both\n * PWM channels.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nstatic void dma_start(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    volatile dma_t *dma = device->dma;\n    volatile pcm_t *pcm = device->pcm;\n    uint32_t dma_cb_addr = device->dma_cb_addr;\n\n    dma->cs = RPI_DMA_CS_RESET;\n    usleep(10);\n\n    dma->cs = RPI_DMA_CS_INT | RPI_DMA_CS_END;\n    usleep(10);\n\n    dma->conblk_ad = dma_cb_addr;\n    dma->debug = 7; // clear debug error flags\n    dma->cs = RPI_DMA_CS_WAIT_OUTSTANDING_WRITES |\n              RPI_DMA_CS_PANIC_PRIORITY(15) |\n              RPI_DMA_CS_PRIORITY(15) |\n              RPI_DMA_CS_ACTIVE;\n\n    if (device->driver_mode == PCM)\n    {\n        pcm->cs |= RPI_PCM_CS_TXON;  // Start transmission\n    }\n}\n\n/**\n * Initialize the application selected GPIO pins for PWM/PCM operation.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  0 on success, -1 on unsupported pin\n */\nstatic int gpio_init(ws2811_t *ws2811)\n{\n    volatile gpio_t *gpio = ws2811->device->gpio;\n    int chan;\n    int altnum;\n\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        int pinnum = ws2811->channel[chan].gpionum;\n\n        if (pinnum)\n        {\n            switch (ws2811->device->driver_mode)\n            {\n            case PWM:\n                altnum = pwm_pin_alt(chan, pinnum);\n                break;\n            case PCM:\n                altnum = pcm_pin_alt(PCMFUN_DOUT, pinnum);\n                break;\n            default:\n                altnum = -1;\n            }\n\n            if (altnum < 0)\n            {\n                return -1;\n            }\n\n            gpio_function_set(gpio, pinnum, altnum);\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Initialize the PWM DMA buffer with all zeros, inverted operation will be\n * handled by hardware.  The DMA buffer length is assumed to be a word\n * multiple.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nvoid pwm_raw_init(ws2811_t *ws2811)\n{\n    volatile uint32_t *pxl_raw = (uint32_t *)ws2811->device->pxl_raw;\n    int maxcount = ws2811->device->max_count;\n    int wordcount = (PWM_BYTE_COUNT(maxcount, ws2811->freq) / sizeof(uint32_t)) /\n                    RPI_PWM_CHANNELS;\n    int chan;\n\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        int i, wordpos = chan;\n\n        for (i = 0; i < wordcount; i++)\n        {\n            pxl_raw[wordpos] = 0x0;\n            wordpos += 2;\n        }\n    }\n}\n\n/**\n * Initialize the PCM DMA buffer with all zeros.\n * The DMA buffer length is assumed to be a word multiple.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nvoid pcm_raw_init(ws2811_t *ws2811)\n{\n    volatile uint32_t *pxl_raw = (uint32_t *)ws2811->device->pxl_raw;\n    int maxcount = ws2811->device->max_count;\n    int wordcount = PCM_BYTE_COUNT(maxcount, ws2811->freq) / sizeof(uint32_t);\n    int i;\n\n    for (i = 0; i < wordcount; i++)\n    {\n        pxl_raw[i] = 0x0;\n    }\n}\n\n/**\n * Cleanup previously allocated device memory and buffers.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nvoid ws2811_cleanup(ws2811_t *ws2811)\n{\n    ws2811_device_t *device = ws2811->device;\n    int chan;\n\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        if (ws2811->channel[chan].leds)\n        {\n            free(ws2811->channel[chan].leds);\n        }\n        ws2811->channel[chan].leds = NULL;\n        if (ws2811->channel[chan].gamma)\n        {\n            free(ws2811->channel[chan].gamma);\n        }\n        ws2811->channel[chan].gamma = NULL;\n    }\n\n    if (device->mbox.handle != -1)\n    {\n        videocore_mbox_t *mbox = &device->mbox;\n\n        unmapmem(mbox->virt_addr, mbox->size);\n        mem_unlock(mbox->handle, mbox->mem_ref);\n        mem_free(mbox->handle, mbox->mem_ref);\n        mbox_close(mbox->handle);\n\n        mbox->handle = -1;\n    }\n\n    if (device && (device->spi_fd > 0))\n    {\n        close(device->spi_fd);\n    }\n\n    if (device) {\n        free(device);\n    }\n    ws2811->device = NULL;\n}\n\nstatic int set_driver_mode(ws2811_t *ws2811, int gpionum)\n{\n    int gpionum2;\n\n    if (gpionum == 18 || gpionum == 12) {\n        ws2811->device->driver_mode = PWM;\n        // Check gpio for PWM1 (2nd channel) is OK if used\n        gpionum2 = ws2811->channel[1].gpionum;\n        if (gpionum2 == 0 || gpionum2 == 13 || gpionum2 == 19) {\n            return 0;\n        }\n    }\n    else if (gpionum == 21 || gpionum == 31) {\n        ws2811->device->driver_mode = PCM;\n    }\n    else if (gpionum == 10) {\n        ws2811->device->driver_mode = SPI;\n    }\n    else {\n        fprintf(stderr, \"gpionum %d not allowed\\n\", gpionum);\n        return -1;\n    }\n    // For PCM and SPI zero the 2nd channel\n    memset(&ws2811->channel[1], 0, sizeof(ws2811_channel_t));\n\n    return 0;\n}\n\nstatic int check_hwver_and_gpionum(ws2811_t *ws2811)\n{\n    const rpi_hw_t *rpi_hw;\n    int hwver, gpionum;\n    int gpionums_B1[] = { 10, 18, 21 };\n    int gpionums_B2[] = { 10, 18, 31 };\n    int gpionums_40p[] = { 10, 12, 18, 21};\n    int i;\n\n    rpi_hw = ws2811->rpi_hw;\n    hwver = rpi_hw->hwver & 0x0000ffff;\n    gpionum = ws2811->channel[0].gpionum;\n    if (hwver < 0x0004)  // Model B Rev 1\n    {\n        for ( i = 0; i < (int)(sizeof(gpionums_B1) / sizeof(gpionums_B1[0])); i++)\n        {\n            if (gpionums_B1[i] == gpionum) {\n                // Set driver mode (PWM, PCM, or SPI)\n                return set_driver_mode(ws2811, gpionum);\n            }\n        }\n    }\n    else if (hwver >= 0x0004 && hwver <= 0x000f)  // Models B Rev2, A\n    {\n        for ( i = 0; i < (int)(sizeof(gpionums_B2) / sizeof(gpionums_B2[0])); i++)\n        {\n            if (gpionums_B2[i] == gpionum) {\n                // Set driver mode (PWM, PCM, or SPI)\n                return set_driver_mode(ws2811, gpionum);\n            }\n        }\n    }\n    else if (hwver >= 0x010) // Models B+, A+, 2B, 3B, Zero Zero-W\n    {\n        if ((ws2811->channel[0].count == 0) && (ws2811->channel[1].count > 0))\n        {\n            // Special case: nothing in channel 0, channel 1 only PWM1 allowed\n            // PWM1 only available on 40 pin GPIO interface\n            gpionum = ws2811->channel[1].gpionum;\n            if ((gpionum == 13) || (gpionum == 19))\n            {\n                ws2811->device->driver_mode = PWM;\n                return 0;\n            }\n            else {\n                return -1;\n            }\n        }\n        for ( i = 0; i < (int)(sizeof(gpionums_40p) / sizeof(gpionums_40p[0])); i++)\n        {\n            if (gpionums_40p[i] == gpionum) {\n                // Set driver mode (PWM, PCM, or SPI)\n                return set_driver_mode(ws2811, gpionum);\n            }\n        }\n    }\n    fprintf(stderr, \"Gpio %d is illegal for LED channel 0\\n\", gpionum);\n    return -1;\n}\n\nstatic ws2811_return_t spi_init(ws2811_t *ws2811)\n{\n    int spi_fd;\n    static uint8_t mode;\n    static uint8_t bits = 8;\n    uint32_t speed = ws2811->freq * 3;\n    ws2811_device_t *device = ws2811->device;\n    uint32_t base = ws2811->rpi_hw->periph_base;\n    int pinnum = ws2811->channel[0].gpionum;\n\n    spi_fd = open(\"/dev/spidev0.0\", O_RDWR);\n    if (spi_fd < 0) {\n        fprintf(stderr, \"Cannot open /dev/spidev0.0. spi_bcm2835 module not loaded?\\n\");\n        return WS2811_ERROR_SPI_SETUP;\n    }\n    device->spi_fd = spi_fd;\n\n    // SPI mode\n    if (ioctl(spi_fd, SPI_IOC_WR_MODE, &mode) < 0)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n    if (ioctl(spi_fd, SPI_IOC_RD_MODE, &mode) < 0)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n\n    // Bits per word\n    if (ioctl(spi_fd, SPI_IOC_WR_BITS_PER_WORD, &bits) < 0)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n    if (ioctl(spi_fd, SPI_IOC_RD_BITS_PER_WORD, &bits) < 0)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n\n    // Max speed Hz\n    if (ioctl(spi_fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed) < 0)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n    if (ioctl(spi_fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed) < 0)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n\n    // Initialize device structure elements to not used\n    // except driver_mode, spi_fd and max_count (already defined when spi_init called)\n    device->pxl_raw = NULL;\n    device->dma = NULL;\n    device->pwm = NULL;\n    device->pcm = NULL;\n    device->dma_cb = NULL;\n    device->dma_cb_addr = 0;\n    device->cm_clk = NULL;\n    device->mbox.handle = -1;\n\n    // Set SPI-MOSI pin\n    device->gpio = mapmem(GPIO_OFFSET + base, sizeof(gpio_t), DEV_GPIOMEM);\n    if (!device->gpio)\n    {\n        return WS2811_ERROR_SPI_SETUP;\n    }\n    gpio_function_set(device->gpio, pinnum, 0);\t// SPI-MOSI ALT0\n\n    // Allocate LED buffer\n    ws2811_channel_t *channel = &ws2811->channel[0];\n    channel->leds = malloc(sizeof(ws2811_led_t) * channel->count);\n    if (!channel->leds)\n    {\n        ws2811_cleanup(ws2811);\n        return WS2811_ERROR_OUT_OF_MEMORY;\n    }\n    memset(channel->leds, 0, sizeof(ws2811_led_t) * channel->count);\n    if (!channel->strip_type)\n    {\n      channel->strip_type=WS2811_STRIP_RGB;\n    }\n\n    // Set default uncorrected gamma table\n    if (!channel->gamma)\n    {\n      channel->gamma = malloc(sizeof(uint8_t) * 256);\n      int x;\n      for(x = 0; x < 256; x++){\n        channel->gamma[x] = x;\n      }\n    }\n\n    channel->wshift = (channel->strip_type >> 24) & 0xff;\n    channel->rshift = (channel->strip_type >> 16) & 0xff;\n    channel->gshift = (channel->strip_type >> 8)  & 0xff;\n    channel->bshift = (channel->strip_type >> 0)  & 0xff;\n\n    // Allocate SPI transmit buffer (same size as PCM)\n    device->pxl_raw = malloc(PCM_BYTE_COUNT(device->max_count, ws2811->freq));\n    if (device->pxl_raw == NULL)\n    {\n        ws2811_cleanup(ws2811);\n        return WS2811_ERROR_OUT_OF_MEMORY;\n    }\n    pcm_raw_init(ws2811);\n\n    return WS2811_SUCCESS;\n}\n\nstatic ws2811_return_t spi_transfer(ws2811_t *ws2811)\n{\n    int ret;\n    struct spi_ioc_transfer tr;\n\n    memset(&tr, 0, sizeof(struct spi_ioc_transfer));\n    tr.tx_buf = (unsigned long)ws2811->device->pxl_raw;\n    tr.rx_buf = 0;\n    tr.len = PCM_BYTE_COUNT(ws2811->device->max_count, ws2811->freq);\n\n    ret = ioctl(ws2811->device->spi_fd, SPI_IOC_MESSAGE(1), &tr);\n    if (ret < 1)\n    {\n        fprintf(stderr, \"Can't send spi message\");\n        return WS2811_ERROR_SPI_TRANSFER;\n    }\n\n    return WS2811_SUCCESS;\n}\n\n\n/*\n *\n * Application API Functions\n *\n */\n\n\n/**\n * Allocate and initialize memory, buffers, pages, PWM, DMA, and GPIO.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  0 on success, -1 otherwise.\n */\nws2811_return_t ws2811_init(ws2811_t *ws2811)\n{\n    ws2811_device_t *device;\n    const rpi_hw_t *rpi_hw;\n    int chan;\n\n    ws2811->rpi_hw = rpi_hw_detect();\n    if (!ws2811->rpi_hw)\n    {\n        return WS2811_ERROR_HW_NOT_SUPPORTED;\n    }\n    rpi_hw = ws2811->rpi_hw;\n\n    ws2811->device = malloc(sizeof(*ws2811->device));\n    if (!ws2811->device)\n    {\n        return WS2811_ERROR_OUT_OF_MEMORY;\n    }\n    memset(ws2811->device, 0, sizeof(*ws2811->device));\n    device = ws2811->device;\n\n    if (check_hwver_and_gpionum(ws2811) < 0)\n    {\n        return WS2811_ERROR_ILLEGAL_GPIO;\n    }\n\n    device->max_count = max_channel_led_count(ws2811);\n\n    if (device->driver_mode == SPI) {\n        return spi_init(ws2811);\n    }\n\n    // Determine how much physical memory we need for DMA\n    switch (device->driver_mode) {\n    case PWM:\n        device->mbox.size = PWM_BYTE_COUNT(device->max_count, ws2811->freq) +\n                            sizeof(dma_cb_t);\n        break;\n\n    case PCM:\n        device->mbox.size = PCM_BYTE_COUNT(device->max_count, ws2811->freq) +\n                            sizeof(dma_cb_t);\n        break;\n    }\n    // Round up to page size multiple\n    device->mbox.size = (device->mbox.size + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n\n    device->mbox.handle = mbox_open();\n    if (device->mbox.handle == -1)\n    {\n        return WS2811_ERROR_MAILBOX_DEVICE;\n    }\n\n    device->mbox.mem_ref = mem_alloc(device->mbox.handle, device->mbox.size, PAGE_SIZE,\n                                     rpi_hw->videocore_base == 0x40000000 ? 0xC : 0x4);\n    if (device->mbox.mem_ref == 0)\n    {\n        return WS2811_ERROR_OUT_OF_MEMORY;\n    }\n\n    device->mbox.bus_addr = mem_lock(device->mbox.handle, device->mbox.mem_ref);\n    if (device->mbox.bus_addr == (uint32_t) ~0UL)\n    {\n       mem_free(device->mbox.handle, device->mbox.size);\n       return WS2811_ERROR_MEM_LOCK;\n    }\n\n    device->mbox.virt_addr = mapmem(BUS_TO_PHYS(device->mbox.bus_addr), device->mbox.size, DEV_MEM);\n    if (!device->mbox.virt_addr)\n    {\n        mem_unlock(device->mbox.handle, device->mbox.mem_ref);\n        mem_free(device->mbox.handle, device->mbox.size);\n\n        ws2811_cleanup(ws2811);\n        return WS2811_ERROR_MMAP;\n    }\n\n    // Initialize all pointers to NULL.  Any non-NULL pointers will be freed on cleanup.\n    device->pxl_raw = NULL;\n    device->dma_cb = NULL;\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        ws2811->channel[chan].leds = NULL;\n    }\n\n    // Allocate the LED buffers\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        ws2811_channel_t *channel = &ws2811->channel[chan];\n\n        channel->leds = malloc(sizeof(ws2811_led_t) * channel->count);\n        if (!channel->leds)\n        {\n            ws2811_cleanup(ws2811);\n            return WS2811_ERROR_OUT_OF_MEMORY;\n        }\n\n        memset(channel->leds, 0, sizeof(ws2811_led_t) * channel->count);\n\n        if (!channel->strip_type)\n        {\n          channel->strip_type=WS2811_STRIP_RGB;\n        }\n\n        // Set default uncorrected gamma table\n        if (!channel->gamma)\n        {\n          channel->gamma = malloc(sizeof(uint8_t) * 256);\n          int x;\n          for(x = 0; x < 256; x++){\n            channel->gamma[x] = x;\n          }\n        }\n\n        channel->wshift = (channel->strip_type >> 24) & 0xff;\n        channel->rshift = (channel->strip_type >> 16) & 0xff;\n        channel->gshift = (channel->strip_type >> 8)  & 0xff;\n        channel->bshift = (channel->strip_type >> 0)  & 0xff;\n\n    }\n\n    device->dma_cb = (dma_cb_t *)device->mbox.virt_addr;\n    device->pxl_raw = (uint8_t *)device->mbox.virt_addr + sizeof(dma_cb_t);\n\n    switch (device->driver_mode) {\n    case PWM:\n       pwm_raw_init(ws2811);\n       break;\n\n    case PCM:\n       pcm_raw_init(ws2811);\n       break;\n    }\n\n    memset((dma_cb_t *)device->dma_cb, 0, sizeof(dma_cb_t));\n\n    // Cache the DMA control block bus address\n    device->dma_cb_addr = addr_to_bus(device, device->dma_cb);\n\n    // Map the physical registers into userspace\n    if (map_registers(ws2811))\n    {\n        ws2811_cleanup(ws2811);\n        return WS2811_ERROR_MAP_REGISTERS;\n    }\n\n    // Initialize the GPIO pins\n    if (gpio_init(ws2811))\n    {\n        unmap_registers(ws2811);\n        ws2811_cleanup(ws2811);\n        return WS2811_ERROR_GPIO_INIT;\n    }\n\n    switch (device->driver_mode) {\n    case PWM:\n        // Setup the PWM, clocks, and DMA\n        if (setup_pwm(ws2811))\n        {\n            unmap_registers(ws2811);\n            ws2811_cleanup(ws2811);\n            return WS2811_ERROR_PWM_SETUP;\n        }\n        break;\n    case PCM:\n    // Setup the PCM, clock, and DMA\n        if (setup_pcm(ws2811))\n        {\n            unmap_registers(ws2811);\n            ws2811_cleanup(ws2811);\n            return WS2811_ERROR_PCM_SETUP;\n        }\n        break;\n    }\n\n    return WS2811_SUCCESS;\n}\n\n/**\n * Shut down DMA, PWM, and cleanup memory.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nvoid ws2811_fini(ws2811_t *ws2811)\n{\n    volatile pcm_t *pcm = ws2811->device->pcm;\n\n    ws2811_wait(ws2811);\n    switch (ws2811->device->driver_mode) {\n    case PWM:\n        stop_pwm(ws2811);\n        break;\n    case PCM:\n        while (!(pcm->cs & RPI_PCM_CS_TXE)) ;    // Wait till TX FIFO is empty\n        stop_pcm(ws2811);\n        break;\n    }\n\n    unmap_registers(ws2811);\n\n    ws2811_cleanup(ws2811);\n}\n\n/**\n * Wait for any executing DMA operation to complete before returning.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  0 on success, -1 on DMA competion error\n */\nws2811_return_t ws2811_wait(ws2811_t *ws2811)\n{\n    volatile dma_t *dma = ws2811->device->dma;\n\n    if (ws2811->device->driver_mode == SPI)  // Nothing to do for SPI\n    {\n        return WS2811_SUCCESS;\n    }\n\n    while ((dma->cs & RPI_DMA_CS_ACTIVE) &&\n           !(dma->cs & RPI_DMA_CS_ERROR))\n    {\n        usleep(10);\n    }\n\n    if (dma->cs & RPI_DMA_CS_ERROR)\n    {\n        fprintf(stderr, \"DMA Error: %08x\\n\", dma->debug);\n        return WS2811_ERROR_DMA;\n    }\n\n    return WS2811_SUCCESS;\n}\n\n/**\n * Render the DMA buffer from the user supplied LED arrays and start the DMA\n * controller.  This will update all LEDs on both PWM channels.\n *\n * @param    ws2811  ws2811 instance pointer.\n *\n * @returns  None\n */\nws2811_return_t  ws2811_render(ws2811_t *ws2811)\n{\n\tstatic uint8_t convert_table[3][256] =\n\t{ \n\t\t{\n\t\t\t0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92,  \n\t\t\t0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, \n\t\t\t0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x93, 0x93, 0x93, \n\t\t\t0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, \n\t\t\t0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, 0x93, \n\t\t\t0x93, 0x93, 0x93, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, \n\t\t\t0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, \n\t\t\t0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9A, 0x9B, 0x9B, 0x9B, 0x9B, \n\t\t\t0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, \n\t\t\t0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, \n\t\t\t0x9B, 0x9B, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, \n\t\t\t0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, \n\t\t\t0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD2, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, \n\t\t\t0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, \n\t\t\t0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, \n\t\t\t0xD3, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, \n\t\t\t0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, \n\t\t\t0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDA, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, \n\t\t\t0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, \n\t\t\t0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB \n\t\t},\n\t\t{\t\t \n\t\t\t0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4D, \n\t\t\t0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, \n\t\t\t0x69, 0x69, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x49, 0x49, 0x49, \n\t\t\t0x49, 0x49, 0x49, 0x49, 0x49, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, \n\t\t\t0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, \n\t\t\t0x6D, 0x6D, 0x6D, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4D, 0x4D, \n\t\t\t0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, \n\t\t\t0x69, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x49, 0x49, 0x49, 0x49, \n\t\t\t0x49, 0x49, 0x49, 0x49, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x69, \n\t\t\t0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, \n\t\t\t0x6D, 0x6D, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4D, 0x4D, 0x4D, \n\t\t\t0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, \n\t\t\t0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x49, 0x49, 0x49, 0x49, 0x49, \n\t\t\t0x49, 0x49, 0x49, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x69, 0x69, \n\t\t\t0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, \n\t\t\t0x6D, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4D, 0x4D, 0x4D, 0x4D, \n\t\t\t0x4D, 0x4D, 0x4D, 0x4D, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x6D, \n\t\t\t0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49, \n\t\t\t0x49, 0x49, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x4D, 0x69, 0x69, 0x69, \n\t\t\t0x69, 0x69, 0x69, 0x69, 0x69, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D \t\t\n\t\t},\t\t\n\t\t{\n\t\t\t0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, \n\t\t\t0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, \n\t\t\t0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, \n\t\t\t0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, \n\t\t\t0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, \n\t\t\t0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, \n\t\t\t0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, \n\t\t\t0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, \n\t\t\t0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, \n\t\t\t0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, \n\t\t\t0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, \n\t\t\t0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, \n\t\t\t0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, \n\t\t\t0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, \n\t\t\t0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, \n\t\t\t0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, \n\t\t\t0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, \n\t\t\t0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, \n\t\t\t0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, \n\t\t\t0x36, 0xA4, 0xA6, 0xB4, 0xB6, 0x24, 0x26, 0x34, 0x36, 0xA4, 0xA6, 0xB4, 0xB6 \n\t\t}\n\t};\n\n    volatile uint8_t *pxl_raw = ws2811->device->pxl_raw;\n    int driver_mode = ws2811->device->driver_mode;\n    int i, l, chan;\n    unsigned j;\n    ws2811_return_t ret = WS2811_SUCCESS;\n    uint32_t protocol_time = 0;\n    static uint64_t previous_timestamp = 0;\n\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)         // Channel\n    {\n        ws2811_channel_t *channel = &ws2811->channel[chan];\n\n        int wordpos = chan; // PWM & PCM\n        int bytepos = 0;    // SPI\n        const int scale = (channel->brightness & 0xff) + 1;\n        uint8_t array_size = 3; // Assume 3 color LEDs, RGB\n\n        // If our shift mask includes the highest nibble, then we have 4 LEDs, RBGW.\n        if (channel->strip_type & SK6812_SHIFT_WMASK)\n        {\n            array_size = 4;\n        }\n\n        // 1.25s per bit\n        const uint32_t channel_protocol_time = channel->count * array_size * 8 * 1.25;\n\n        // Only using the channel which takes the longest as both run in parallel\n        if (channel_protocol_time > protocol_time)\n        {\n            protocol_time = channel_protocol_time;\n        }\n\n        for (i = 0; i < channel->count; i++)                // Led\n        {\n            uint8_t color[] =\n            {\n                channel->gamma[(((channel->leds[i] >> channel->rshift) & 0xff) * scale) >> 8], // red\n                channel->gamma[(((channel->leds[i] >> channel->gshift) & 0xff) * scale) >> 8], // green\n                channel->gamma[(((channel->leds[i] >> channel->bshift) & 0xff) * scale) >> 8], // blue\n                channel->gamma[(((channel->leds[i] >> channel->wshift) & 0xff) * scale) >> 8], // white\n            };\n\n            for (j = 0; j < array_size; j++)               // Color\n            {\n\t\t\t\tfor(l = 0; l < 3; ++l)\n\t\t\t\t{\n\t\t\t\t\tuint8_t pos = driver_mode == SPI ? bytepos : 3 - bytepos;\n\t\t\t\t\tuint8_t val = convert_table[l][color[j]];\n\t\t\t\t\tif ((driver_mode != PWM) && channel->invert) val = ~val;\n\t\t\t\t\t\n\t\t\t\t\tpxl_raw[wordpos * 4 + pos] = val;\n\t\t\t\t\tif(++bytepos == 4) \n\t\t\t\t\t{ \n\t\t\t\t\t\tbytepos = 0; \n\t\t\t\t\t\twordpos += driver_mode == PWM ? 2 : 1; \n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n    }\n\n    // Wait for any previous DMA operation to complete.\n    if ((ret = ws2811_wait(ws2811)) != WS2811_SUCCESS)\n    {\n        return ret;\n    }\n\n    if (ws2811->render_wait_time != 0) {\n        const uint64_t current_timestamp = get_microsecond_timestamp();\n        uint64_t time_diff = current_timestamp - previous_timestamp;\n\n        if (ws2811->render_wait_time > time_diff) {\n            usleep(ws2811->render_wait_time - time_diff);\n        }\n    }\n\n    if (driver_mode != SPI)\n    {\n        dma_start(ws2811);\n    }\n    else\n    {\n        ret = spi_transfer(ws2811);\n    }\n\n    // LED_RESET_WAIT_TIME is added to allow enough time for the reset to occur.\n    previous_timestamp = get_microsecond_timestamp();\n    ws2811->render_wait_time = protocol_time + LED_RESET_WAIT_TIME;\n\n    return ret;\n}\n\nconst char * ws2811_get_return_t_str(const ws2811_return_t state)\n{\n    const int index = -state;\n    static const char * const ret_state_str[] = { WS2811_RETURN_STATES(WS2811_RETURN_STATES_STRING) };\n\n    if (index < (int)(sizeof(ret_state_str) / sizeof(ret_state_str[0])))\n    {\n        return ret_state_str[index];\n    }\n\n    return \"\";\n}\n\n\nvoid ws2811_set_custom_gamma_factor(ws2811_t *ws2811, double gamma_factor)\n{\n    int chan, counter;\n    for (chan = 0; chan < RPI_PWM_CHANNELS; chan++)\n    {\n        ws2811_channel_t *channel = &ws2811->channel[chan];\n\n        if (channel->gamma)\n        {\n          for(counter = 0; counter < 256; counter++)\n          {\n\n             channel->gamma[counter] = (gamma_factor > 0)? (int)(pow((float)counter / (float)255.00, gamma_factor) * 255.00 + 0.5) : counter;\n\n          }\n        }\n\n    }\n}\n"
        },
        {
          "name": "ws2811.h",
          "type": "blob",
          "size": 6.8486328125,
          "content": "/*\n * ws2811.h\n *\n * Copyright (c) 2014 Jeremy Garff <jer @ jers.net>\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n *     1.  Redistributions of source code must retain the above copyright notice, this list of\n *         conditions and the following disclaimer.\n *     2.  Redistributions in binary form must reproduce the above copyright notice, this list\n *         of conditions and the following disclaimer in the documentation and/or other materials\n *         provided with the distribution.\n *     3.  Neither the name of the owner nor the names of its contributors may be used to endorse\n *         or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n\n#ifndef __WS2811_H__\n#define __WS2811_H__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdint.h>\n\n#include \"rpihw.h\"\n#include \"pwm.h\"\n\n\n#define WS2811_TARGET_FREQ                       800000   // Can go as low as 400000\n\n// 4 color R, G, B and W ordering\n#define SK6812_STRIP_RGBW                        0x18100800\n#define SK6812_STRIP_RBGW                        0x18100008\n#define SK6812_STRIP_GRBW                        0x18081000\n#define SK6812_STRIP_GBRW                        0x18080010\n#define SK6812_STRIP_BRGW                        0x18001008\n#define SK6812_STRIP_BGRW                        0x18000810\n#define SK6812_SHIFT_WMASK                       0xf0000000\n\n// 3 color R, G and B ordering\n#define WS2811_STRIP_RGB                         0x00100800\n#define WS2811_STRIP_RBG                         0x00100008\n#define WS2811_STRIP_GRB                         0x00081000\n#define WS2811_STRIP_GBR                         0x00080010\n#define WS2811_STRIP_BRG                         0x00001008\n#define WS2811_STRIP_BGR                         0x00000810\n\n// predefined fixed LED types\n#define WS2812_STRIP                             WS2811_STRIP_GRB\n#define SK6812_STRIP                             WS2811_STRIP_GRB\n#define SK6812W_STRIP                            SK6812_STRIP_GRBW\n\nstruct ws2811_device;\n\ntypedef uint32_t ws2811_led_t;                   //< 0xWWRRGGBB\ntypedef struct ws2811_channel_t\n{\n    int gpionum;                                 //< GPIO Pin with PWM alternate function, 0 if unused\n    int invert;                                  //< Invert output signal\n    int count;                                   //< Number of LEDs, 0 if channel is unused\n    int strip_type;                              //< Strip color layout -- one of WS2811_STRIP_xxx constants\n    ws2811_led_t *leds;                          //< LED buffers, allocated by driver based on count\n    uint8_t brightness;                          //< Brightness value between 0 and 255\n    uint8_t wshift;                              //< White shift value\n    uint8_t rshift;                              //< Red shift value\n    uint8_t gshift;                              //< Green shift value\n    uint8_t bshift;                              //< Blue shift value\n    uint8_t *gamma;                              //< Gamma correction table\n} ws2811_channel_t;\n\ntypedef struct ws2811_t\n{\n    uint64_t render_wait_time;                   //< time in s before the next render can run\n    struct ws2811_device *device;                //< Private data for driver use\n    const rpi_hw_t *rpi_hw;                      //< RPI Hardware Information\n    uint32_t freq;                               //< Required output frequency\n    int dmanum;                                  //< DMA number _not_ already in use\n    ws2811_channel_t channel[RPI_PWM_CHANNELS];\n} ws2811_t;\n\n#define WS2811_RETURN_STATES(X)                                                             \\\n            X(0, WS2811_SUCCESS, \"Success\"),                                                \\\n            X(-1, WS2811_ERROR_GENERIC, \"Generic failure\"),                                 \\\n            X(-2, WS2811_ERROR_OUT_OF_MEMORY, \"Out of memory\"),                             \\\n            X(-3, WS2811_ERROR_HW_NOT_SUPPORTED, \"Hardware revision is not supported\"),     \\\n            X(-4, WS2811_ERROR_MEM_LOCK, \"Memory lock failed\"),                             \\\n            X(-5, WS2811_ERROR_MMAP, \"mmap() failed\"),                                      \\\n            X(-6, WS2811_ERROR_MAP_REGISTERS, \"Unable to map registers into userspace\"),    \\\n            X(-7, WS2811_ERROR_GPIO_INIT, \"Unable to initialize GPIO\"),                     \\\n            X(-8, WS2811_ERROR_PWM_SETUP, \"Unable to initialize PWM\"),                      \\\n            X(-9, WS2811_ERROR_MAILBOX_DEVICE, \"Failed to create mailbox device\"),          \\\n            X(-10, WS2811_ERROR_DMA, \"DMA error\"),                                          \\\n            X(-11, WS2811_ERROR_ILLEGAL_GPIO, \"Selected GPIO not possible\"),                \\\n            X(-12, WS2811_ERROR_PCM_SETUP, \"Unable to initialize PCM\"),                     \\\n            X(-13, WS2811_ERROR_SPI_SETUP, \"Unable to initialize SPI\"),                     \\\n            X(-14, WS2811_ERROR_SPI_TRANSFER, \"SPI transfer error\")                         \\\n\n#define WS2811_RETURN_STATES_ENUM(state, name, str) name = state\n#define WS2811_RETURN_STATES_STRING(state, name, str) str\n\ntypedef enum {\n    WS2811_RETURN_STATES(WS2811_RETURN_STATES_ENUM),\n\n    WS2811_RETURN_STATE_COUNT\n} ws2811_return_t;\n\nws2811_return_t ws2811_init(ws2811_t *ws2811);                                  //< Initialize buffers/hardware\nvoid ws2811_fini(ws2811_t *ws2811);                                             //< Tear it all down\nws2811_return_t ws2811_render(ws2811_t *ws2811);                                //< Send LEDs off to hardware\nws2811_return_t ws2811_wait(ws2811_t *ws2811);                                  //< Wait for DMA completion\nconst char * ws2811_get_return_t_str(const ws2811_return_t state);              //< Get string representation of the given return state\nvoid ws2811_set_custom_gamma_factor(ws2811_t *ws2811, double gamma_factor);     //< Set a custom Gamma correction array based on a gamma correction factor\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __WS2811_H__ */\n"
        }
      ]
    }
  ]
}