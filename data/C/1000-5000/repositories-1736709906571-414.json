{
  "metadata": {
    "timestamp": 1736709906571,
    "page": 414,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mpaland/printf",
      "stars": 2609,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.044921875,
          "content": "# ignore test path\r\ntest/* linguist-vendored\r\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 1.5068359375,
          "content": "# Use a C++11 distro\r\ndist: trusty\r\nsudo: required\r\n\r\n# Enable C++ support\r\nlanguage: cpp\r\n\r\n# Compiler selection\r\ncompiler: gcc\r\n\r\nenv:\r\n  global:\r\n    # coverity key\r\n    - secure: \"NKZbBnMALGIIQJy/s2kc3EST/stw+gjhtrGq0jkbsWr7Wx3FH+lmLeHNsDXRnD1VbpG02c5YsLllqz9OVu+0yxWGepvKNmCz1cNITIALEHbrax8/Af9LzPRL/QZxS/Qe11sMuySp4X16mFBUyxMd/X+I9i96Xf1vKkZABklYD1Q=\"\r\n\r\n# addons\r\naddons:\r\n  apt:\r\n    packages:\r\n      - gcc-6\r\n      - g++-6\r\n    sources:\r\n      - ubuntu-toolchain-r-test\r\n\r\n  coverity_scan:\r\n    project:\r\n      name: \"mpaland/printf\"\r\n      description: \"Tiny printf implementation\"\r\n    notification_email: marco@paland.com\r\n    build_command_prepend: \"make clean\"\r\n    build_command: \"make\"\r\n    branch_pattern: master\r\n\r\nbefore_install:\r\n  # connect coverity\r\n  - echo -n | openssl s_client -connect scan.coverity.com:443 | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sudo tee -a /etc/ssl/certs/ca-\r\n\r\n# Active branches\r\nbranches:\r\n  only:\r\n   - master\r\n\r\nscript:\r\n  # Link gcc-6 and g++-6 to their standard commands\r\n  - sudo rm /usr/bin/gcc\r\n  - sudo rm /usr/bin/g++\r\n  - sudo ln -s /usr/bin/gcc-6 /usr/bin/gcc\r\n  - sudo ln -s /usr/bin/g++-6 /usr/bin/g++\r\n  # Export CC and CXX\r\n  - export CC=/usr/bin/gcc-6\r\n  - export CXX=/usr/bin/g++-6\r\n  # Check versions of gcc, g++\r\n  - gcc -v && g++ -v\r\n  # Run build commands\r\n  - make\r\n  # execute the text suite\r\n  - bin/test_suite -d yes\r\n  # coverall profiling\r\n  - tmp/cov/test_suite\r\n\r\nafter_success:\r\n  ## Report to codecov\r\n  - bash <(curl -s https://codecov.io/bash)\r\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Marco Paland\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 10.7451171875,
          "content": "# ------------------------------------------------------------------------------\r\n# \r\n# Generic Makefile\r\n#\r\n# Copyright Marco Paland 2007 - 2017\r\n# Distributed under the MIT License\r\n#\r\n# ------------------------------------------------------------------------------\r\n\r\n# ------------------------------------------------------------------------------\r\n# Paths\r\n# ------------------------------------------------------------------------------\r\nPATH_TOOLS_CC        = /usr/bin/\r\nPATH_TOOLS_CC_LIB    = /usr/lib/\r\nPATH_TOOLS_UTIL      = \r\n\r\nPATH_BIN       = bin\r\nPATH_TMP       = tmp\r\nPATH_NUL       = /dev/null\r\nPATH_OBJ       = $(PATH_TMP)/obj\r\nPATH_LST       = $(PATH_TMP)/lst\r\nPATH_ERR       = $(PATH_TMP)/err\r\nPATH_PRE       = $(PATH_TMP)/pre\r\nPATH_COV       = $(PATH_TMP)/cov\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# Application to build\r\n# ------------------------------------------------------------------------------\r\n\r\nAPP = test_suite\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\n# Project file list\r\n# Format is:\r\n# FILES_PRJ  = file1                        \\\r\n#              foo/file2                    \\\r\n#              bar/file3\r\n# -----------------------------------------------------------------------------\r\n\r\nFILES_PRJ  = test/test_suite\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# Additional include files and compiler defines\r\n# Format is:\r\n# C_INCLUDES = -Iinclude_path1                 \\\r\n#              -Iinclude_path2                 \\\r\n#              -Iinclude_path3                 \\\r\n# ------------------------------------------------------------------------------\r\n\r\nC_INCLUDES = \r\n\r\nC_DEFINES  = \r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# The target name and location\r\n# ------------------------------------------------------------------------------\r\nTRG = $(PATH_BIN)/$(APP)\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# object files\r\n# ------------------------------------------------------------------------------\r\nFILES_TMP   = $(FILES_PRJ)\r\nFILES_O     = $(addsuffix .o, $(FILES_TMP))\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# VPATH definition\r\n#\r\n# VPATH is required for the maker to find the C-/ASM-Source files.\r\n# Extract the directory/module names from the file list with the dir\r\n# command and remove the duplicated directory names with the sort command.\r\n# FILES_PRJ is listed first to make sure that the source files in the project\r\n# directory are searched first.\r\n# ------------------------------------------------------------------------------\r\nVPATH := $(sort $(dir $(FILES_TMP)))\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# Development tools\r\n# ------------------------------------------------------------------------------\r\nAR        = $(PATH_TOOLS_CC)ar\r\nAS        = $(PATH_TOOLS_CC)g++\r\nCC        = $(PATH_TOOLS_CC)g++\r\nCL        = $(PATH_TOOLS_CC)g++\r\nNM        = $(PATH_TOOLS_CC)nm\r\nGCOV      = $(PATH_TOOLS_CC)gcov\r\nOBJDUMP   = $(PATH_TOOLS_CC)objdump\r\nOBJCOPY   = $(PATH_TOOLS_CC)objcopy\r\nREADELF   = $(PATH_TOOLS_CC)readelf\r\nSIZE      = $(PATH_TOOLS_CC)size\r\n\r\nECHO      = $(PATH_TOOLS_UTIL)echo\r\nMAKE      = $(PATH_TOOLS_UTIL)make\r\nMKDIR     = $(PATH_TOOLS_UTIL)mkdir\r\nRM        = $(PATH_TOOLS_UTIL)rm\r\nSED       = $(PATH_TOOLS_UTIL)sed\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# Compiler flags for the target architecture\r\n# ------------------------------------------------------------------------------\r\n\r\nGCCFLAGS      = $(C_INCLUDES)                     \\\r\n                $(C_DEFINES)                      \\\r\n                -std=c++11                        \\\r\n                -g                                \\\r\n                -Wall                             \\\r\n                -pedantic                         \\\r\n                -Wmain                            \\\r\n                -Wundef                           \\\r\n                -Wsign-conversion                 \\\r\n                -Wuninitialized                   \\\r\n                -Wshadow                          \\\r\n                -Wunreachable-code                \\\r\n                -Wswitch-default                  \\\r\n                -Wswitch                          \\\r\n                -Wcast-align                      \\\r\n                -Wmissing-include-dirs            \\\r\n                -Winit-self                       \\\r\n                -Wdouble-promotion                \\\r\n                -gdwarf-2                         \\\r\n                -fno-exceptions                   \\\r\n                -O2                               \\\r\n                -ffunction-sections               \\\r\n                -ffat-lto-objects                 \\\r\n                -fdata-sections                   \\\r\n                -fverbose-asm                     \\\r\n                -Wextra                           \\\r\n                -Wunused-parameter                \\\r\n                -Wfloat-equal\r\n\r\nCFLAGS        = $(GCCFLAGS)                       \\\r\n                -Wunsuffixed-float-constants      \\\r\n                -x c                              \\\r\n                -std=c99\r\n\r\nCPPFLAGS      = $(GCCFLAGS)                       \\\r\n                -x c++                            \\\r\n                -fno-rtti                         \\\r\n                -fstrict-enums                    \\\r\n                -fno-use-cxa-atexit               \\\r\n                -fno-use-cxa-get-exception-ptr    \\\r\n                -fno-nonansi-builtins             \\\r\n                -fno-threadsafe-statics           \\\r\n                -fno-enforce-eh-specs             \\\r\n                -ftemplate-depth-64               \\\r\n                -fexceptions\r\n\r\nAFLAGS        = $(GCCFLAGS)                       \\\r\n                -x assembler\r\n\r\nLFLAGS        = $(GCCFLAGS)                       \\\r\n                -x none                           \\\r\n                -Wl,--gc-sections\r\n\r\n# ------------------------------------------------------------------------------\r\n# Targets\r\n# ------------------------------------------------------------------------------\r\n\r\n# ------------------------------------------------------------------------------\r\n# Main-Dependencies (app: all)\r\n# ------------------------------------------------------------------------------\r\n.PHONY: all\r\nall: clean_prj $(TRG) $(TRG)_nm.txt\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# Main-Dependencies (app: rebuild)\r\n# ------------------------------------------------------------------------------\r\n.PHONY: rebuild\r\nrebuild: clean $(TRG) $(TRG)_nm.txt\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# clean project\r\n# ------------------------------------------------------------------------------\r\n.PHONY: clean_prj\r\nclean_prj:\r\n\t@-$(ECHO) +++ cleaning project\r\n\t@-$(RM) -rf $(PATH_BIN) 2> $(PATH_NUL)\r\n\t@-$(MKDIR) -p $(PATH_BIN)\r\n\t@-$(MKDIR) -p $(PATH_OBJ)\r\n\t@-$(MKDIR) -p $(PATH_ERR)\r\n\t@-$(MKDIR) -p $(PATH_LST)\r\n\t@-$(MKDIR) -p $(PATH_PRE)\r\n\t@-$(MKDIR) -p $(PATH_COV)\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# clean all\r\n# ------------------------------------------------------------------------------\r\n.PHONY: clean\r\nclean:\r\n\t@-$(ECHO) +++ cleaning all\r\n\t@-$(RM) -rf $(PATH_BIN) 2> $(PATH_NUL)\r\n\t@-$(RM) -rf $(PATH_TMP) 2> $(PATH_NUL)\r\n\t@-$(MKDIR) -p $(PATH_BIN)\r\n\t@-$(MKDIR) -p $(PATH_OBJ)\r\n\t@-$(MKDIR) -p $(PATH_ERR)\r\n\t@-$(MKDIR) -p $(PATH_LST)\r\n\t@-$(MKDIR) -p $(PATH_COV)\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# print the GNUmake version and the compiler version\r\n# ------------------------------------------------------------------------------\r\n.PHONY: version\r\nversion:\r\n  # Print the GNU make version and the compiler version\r\n\t@$(ECHO) GNUmake version:\r\n\t@$(MAKE) --version\r\n\t@$(ECHO) GCC version:\r\n\t@$(CL) -v\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# Rules\r\n# ------------------------------------------------------------------------------\r\n\r\n# ------------------------------------------------------------------------------\r\n# Link/locate application\r\n# ------------------------------------------------------------------------------\r\n$(TRG) : $(FILES_O)\r\n\t@-$(ECHO) +++ linkink application to generate: $(TRG)\r\n\t@-$(CL) $(LFLAGS) -L. -lc $(PATH_OBJ)/*.o -Wl,-Map,$(TRG).map -o $(TRG)\r\n  # profiling\r\n\t@-$(CL) $(LFLAGS) -L. -lc $(PATH_COV)/*.o --coverage -o $(PATH_COV)/$(APP)\r\n\r\n\r\n# ------------------------------------------------------------------------------\r\n# parse the object files to obtain symbol information, and create a size summary\r\n# ------------------------------------------------------------------------------\r\n$(TRG)_nm.txt : $(TRG)\r\n\t@-$(ECHO) +++ parsing symbols with nm to generate: $(TRG)_nm.txt\r\n\t@-$(NM) --numeric-sort --print-size $(TRG) > $(TRG)_nm.txt\r\n\t@-$(ECHO) +++ demangling symbols with c++filt to generate: $(TRG)_cppfilt.txt\r\n\t@-$(NM) --numeric-sort --print-size $(TRG) | $(CPPFILT) > $(TRG)_cppfilt.txt\r\n\t@-$(ECHO) +++ creating size summary table with size to generate: $(TRG)_size.txt\r\n\t@-$(SIZE) -A -t $(TRG) > $(TRG)_size.txt\r\n\r\n\r\n%.o : %.cpp\r\n\t@$(ECHO) +++ compile: $<\r\n  # Compile the source file\r\n  # ...and Reformat (using sed) any possible error/warning messages for the VisualStudio(R) output window\r\n  # ...and Create an assembly listing using objdump\r\n  # ...and Generate a dependency file (using the -MM flag)\r\n\t@-$(CL) $(CPPFLAGS) $< -E -o $(PATH_PRE)/$(basename $(@F)).pre\r\n\t@-$(CL) $(CPPFLAGS) $< -c -o $(PATH_OBJ)/$(basename $(@F)).o 2> $(PATH_ERR)/$(basename $(@F)).err\r\n\t@-$(SED) -e 's|.h:\\([0-9]*\\),|.h(\\1) :|' -e 's|:\\([0-9]*\\):|(\\1) :|' $(PATH_ERR)/$(basename $(@F)).err\r\n\t@-$(OBJDUMP) --disassemble --line-numbers -S $(PATH_OBJ)/$(basename $(@F)).o > $(PATH_LST)/$(basename $(@F)).lst\r\n\t@-$(CL) $(CPPFLAGS) $< -MM > $(PATH_OBJ)/$(basename $(@F)).d\r\n  # profiling\r\n\t@-$(CL) $(CPPFLAGS) -O0 --coverage $< -c -o $(PATH_COV)/$(basename $(@F)).o 2> $(PATH_NUL)\r\n\r\n%.o : %.c\r\n\t@$(ECHO) +++ compile: $<\r\n  # Compile the source file\r\n  # ...and Reformat (using sed) any possible error/warning messages for the VisualStudio(R) output window\r\n  # ...and Create an assembly listing using objdump\r\n  # ...and Generate a dependency file (using the -MM flag)\r\n\t@-$(CL) $(CFLAGS) $< -E -o $(PATH_PRE)/$(basename $(@F)).pre\r\n\t@-$(CC) $(CFLAGS) $< -c -o $(PATH_OBJ)/$(basename $(@F)).o 2> $(PATH_ERR)/$(basename $(@F)).err\r\n\t@-$(SED) -e 's|.h:\\([0-9]*\\),|.h(\\1) :|' -e 's|:\\([0-9]*\\):|(\\1) :|' $(PATH_ERR)/$(basename $(@F)).err\r\n\t@-$(OBJDUMP) -S $(PATH_OBJ)/$(basename $(@F)).o > $(PATH_LST)/$(basename $(@F)).lst\r\n\t@-$(CC) $(CFLAGS) $< -MM > $(PATH_OBJ)/$(basename $(@F)).d\r\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.40625,
          "content": "# A printf / sprintf Implementation for Embedded Systems\r\n\r\n[![Build Status](https://travis-ci.org/mpaland/printf.svg?branch=master)](https://travis-ci.org/mpaland/printf)\r\n[![codecov](https://codecov.io/gh/mpaland/printf/branch/master/graph/badge.svg)](https://codecov.io/gh/mpaland/printf)\r\n[![Coverity Status](https://img.shields.io/coverity/scan/14180.svg)](https://scan.coverity.com/projects/mpaland-printf)\r\n[![Github Issues](https://img.shields.io/github/issues/mpaland/printf.svg)](http://github.com/mpaland/printf/issues)\r\n[![Github Releases](https://img.shields.io/github/release/mpaland/printf.svg)](https://github.com/mpaland/printf/releases)\r\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://raw.githubusercontent.com/mpaland/avl_array/master/LICENSE)\r\n\r\nThis is a tiny but **fully loaded** printf, sprintf and (v)snprintf implementation.\r\nPrimarily designed for usage in embedded systems, where printf is not available due to memory issues or in avoidance of linking against libc.\r\nUsing the standard libc printf may pull **a lot** of unwanted library stuff and can bloat code size about 20k or is not 100% thread safe. In this cases the following implementation can be used.\r\nAbsolutely **NO dependencies** are required, *printf.c* brings all necessary routines, even its own fast `ftoa` (floating point), `ntoa` (decimal) conversion.\r\n\r\nIf memory footprint is really a critical issue, floating point, exponential and 'long long' support and can be turned off via the `PRINTF_DISABLE_SUPPORT_FLOAT`, `PRINTF_DISABLE_SUPPORT_EXPONENTIAL` and `PRINTF_DISABLE_SUPPORT_LONG_LONG` compiler switches.\r\nWhen using printf (instead of sprintf/snprintf) you have to provide your own `_putchar()` low level function as console/serial output.\r\n\r\n\r\n## 2020 announcement\r\nThis project is not dead! I just had no time in 2019 for sufficient support, sorry.\r\nWithin the next weeks, I will have a look to all PRs and open issues.  \r\nThank you all for supporting this project.\r\n\r\n\r\n## Highlights and Design Goals\r\n\r\nThere is a boatload of so called 'tiny' printf implementations around. So why this one?\r\nI've tested many implementations, but most of them have very limited flag/specifier support, a lot of other dependencies or are just not standard compliant and failing most of the test suite.\r\nTherefore I decided to write an own, final implementation which meets the following items:\r\n\r\n - Very small implementation (around 600 code lines)\r\n - NO dependencies, no libs, just one module file\r\n - Support of all important flags, width and precision sub-specifiers (see below)\r\n - Support of decimal/floating number representation (with an own fast itoa/ftoa)\r\n - Reentrant and thread-safe, malloc free, no static vars/buffers\r\n - LINT and compiler L4 warning free, mature, coverity clean, automotive ready\r\n - Extensive test suite (> 400 test cases) passing\r\n - Simply the best *printf* around the net\r\n - MIT license\r\n\r\n\r\n## Usage\r\n\r\nAdd/link *printf.c* to your project and include *printf.h*. That's it.\r\nImplement your low level output function needed for `printf()`:\r\n```C\r\nvoid _putchar(char character)\r\n{\r\n  // send char to console etc.\r\n}\r\n```\r\n\r\nUsage is 1:1 like the according stdio.h library version:\r\n```C\r\nint printf(const char* format, ...);\r\nint sprintf(char* buffer, const char* format, ...);\r\nint snprintf(char* buffer, size_t count, const char* format, ...);\r\nint vsnprintf(char* buffer, size_t count, const char* format, va_list va);\r\n\r\n// use output function (instead of buffer) for streamlike interface\r\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\r\n```\r\n\r\n**Due to general security reasons it is highly recommended to prefer and use `snprintf` (with the max buffer size as `count` parameter) instead of `sprintf`.**\r\n`sprintf` has no buffer limitation, so when needed - use it really with care!\r\n\r\n### Streamlike Usage\r\nBesides the regular standard `printf()` functions, this module also provides `fctprintf()`, which takes an output function as first parameter to build a streamlike output like `fprintf()`:\r\n```C\r\n// define the output function\r\nvoid my_stream_output(char character, void* arg)\r\n{\r\n  // opt. evaluate the argument and send the char somewhere\r\n}\r\n\r\n{\r\n  // in your code\r\n  void* arg = (void*)100;  // this argument is passed to the output function\r\n  fctprintf(&my_stream_output, arg, \"This is a test: %X\", 0xAA);\r\n  fctprintf(&my_stream_output, nullptr, \"Send to null dev\");\r\n}\r\n```\r\n\r\n## Format Specifiers\r\n\r\nA format specifier follows this prototype: `%[flags][width][.precision][length]type`\r\nThe following format specifiers are supported:\r\n\r\n\r\n### Supported Types\r\n\r\n| Type   | Output |\r\n|--------|--------|\r\n| d or i | Signed decimal integer |\r\n| u      | Unsigned decimal integer\t|\r\n| b      | Unsigned binary |\r\n| o      | Unsigned octal |\r\n| x      | Unsigned hexadecimal integer (lowercase) |\r\n| X      | Unsigned hexadecimal integer (uppercase) |\r\n| f or F | Decimal floating point |\r\n| e or E | Scientific-notation (exponential) floating point |\r\n| g or G | Scientific or decimal floating point |\r\n| c      | Single character |\r\n| s      | String of characters |\r\n| p      | Pointer address |\r\n| %      | A % followed by another % character will write a single % |\r\n\r\n\r\n### Supported Flags\r\n\r\n| Flags | Description |\r\n|-------|-------------|\r\n| -     | Left-justify within the given field width; Right justification is the default. |\r\n| +     | Forces to precede the result with a plus or minus sign (+ or -) even for positive numbers.<br>By default, only negative numbers are preceded with a - sign. |\r\n| (space) | If no sign is going to be written, a blank space is inserted before the value. |\r\n| #     | Used with o, b, x or X specifiers the value is preceded with 0, 0b, 0x or 0X respectively for values different than zero.<br>Used with f, F it forces the written output to contain a decimal point even if no more digits follow. By default, if no digits follow, no decimal point is written. |\r\n| 0     | Left-pads the number with zeros (0) instead of spaces when padding is specified (see width sub-specifier). |\r\n\r\n\r\n### Supported Width\r\n\r\n| Width    | Description |\r\n|----------|-------------|\r\n| (number) | Minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces. The value is not truncated even if the result is larger. |\r\n| *        | The width is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. |\r\n\r\n\r\n### Supported Precision\r\n\r\n| Precision\t| Description |\r\n|-----------|-------------|\r\n| .number   | For integer specifiers (d, i, o, u, x, X): precision specifies the minimum number of digits to be written. If the value to be written is shorter than this number, the result is padded with leading zeros. The value is not truncated even if the result is longer. A precision of 0 means that no character is written for the value 0.<br>For f and F specifiers: this is the number of digits to be printed after the decimal point. **By default, this is 6, maximum is 9**.<br>For s: this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.<br>If the period is specified without an explicit value for precision, 0 is assumed. |\r\n| .*        | The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. |\r\n\r\n\r\n### Supported Length\r\n\r\nThe length sub-specifier modifies the length of the data type.\r\n\r\n| Length | d i  | u o x X |\r\n|--------|------|---------|\r\n| (none) | int  | unsigned int |\r\n| hh     | char | unsigned char |\r\n| h      | short int | unsigned short int |\r\n| l      | long int | unsigned long int |\r\n| ll     | long long int | unsigned long long int (if PRINTF_SUPPORT_LONG_LONG is defined) |\r\n| j      | intmax_t | uintmax_t |\r\n| z      | size_t | size_t |\r\n| t      | ptrdiff_t | ptrdiff_t (if PRINTF_SUPPORT_PTRDIFF_T is defined) |\r\n\r\n\r\n### Return Value\r\n\r\nUpon successful return, all functions return the number of characters written, _excluding_ the terminating null character used to end the string.\r\nFunctions `snprintf()` and `vsnprintf()` don't write more than `count` bytes, _including_ the terminating null byte ('\\0').\r\nAnyway, if the output was truncated due to this limit, the return value is the number of characters that _could_ have been written.\r\nNotice that a value equal or larger than `count` indicates a truncation. Only when the returned value is non-negative and less than `count`,\r\nthe string has been completely written.\r\nIf any error is encountered, `-1` is returned.\r\n\r\nIf `buffer` is set to `NULL` (`nullptr`) nothing is written and just the formatted length is returned.\r\n```C\r\nint length = sprintf(NULL, \"Hello, world\"); // length is set to 12\r\n```\r\n\r\n\r\n## Compiler Switches/Defines\r\n\r\n| Name | Default value | Description |\r\n|------|---------------|-------------|\r\n| PRINTF_INCLUDE_CONFIG_H            | undefined | Define this as compiler switch (e.g. `gcc -DPRINTF_INCLUDE_CONFIG_H`) to include a \"printf_config.h\" definition file |\r\n| PRINTF_NTOA_BUFFER_SIZE            | 32        | ntoa (integer) conversion buffer size. This must be big enough to hold one converted numeric number _including_ leading zeros, normally 32 is a sufficient value. Created on the stack |\r\n| PRINTF_FTOA_BUFFER_SIZE            | 32        | ftoa (float) conversion buffer size. This must be big enough to hold one converted float number _including_ leading zeros, normally 32 is a sufficient value. Created on the stack |\r\n| PRINTF_DEFAULT_FLOAT_PRECISION     | 6         | Define the default floating point precision |\r\n| PRINTF_MAX_FLOAT                   | 1e9       | Define the largest suitable value to be printed with %f, before using exponential representation |\r\n| PRINTF_DISABLE_SUPPORT_FLOAT       | undefined | Define this to disable floating point (%f) support |\r\n| PRINTF_DISABLE_SUPPORT_EXPONENTIAL | undefined | Define this to disable exponential floating point (%e) support |\r\n| PRINTF_DISABLE_SUPPORT_LONG_LONG   | undefined | Define this to disable long long (%ll) support |\r\n| PRINTF_DISABLE_SUPPORT_PTRDIFF_T   | undefined | Define this to disable ptrdiff_t (%t) support |\r\n\r\n\r\n## Caveats\r\nNone anymore (finally).\r\n\r\n\r\n## Test Suite\r\nFor testing just compile, build and run the test suite located in `test/test_suite.cpp`. This uses the [catch](https://github.com/catchorg/Catch2) framework for unit-tests, which is auto-adding main().\r\nRunning with the `--wait-for-keypress exit` option waits for the enter key after test end.\r\n\r\n\r\n## Projects Using printf\r\n- [turnkeyboard](https://github.com/mpaland/turnkeyboard) uses printf as log and generic tty (formatting) output.\r\n- printf is part of [embeddedartistry/libc](https://github.com/embeddedartistry/libc), a libc targeted for embedded systems usage.\r\n- The [Hatchling Platform]( https://github.com/adrian3git/HatchlingPlatform) uses printf.\r\n\r\n(Just send me a mail/issue/PR to get *your* project listed here)\r\n\r\n\r\n## Contributing\r\n\r\n0. Give this project a :star:\r\n1. Create an issue and describe your idea\r\n2. [Fork it](https://github.com/mpaland/printf/fork)\r\n3. Create your feature branch (`git checkout -b my-new-feature`)\r\n4. Commit your changes (`git commit -am 'Add some feature'`)\r\n5. Publish the branch (`git push origin my-new-feature`)\r\n6. Create a new pull request\r\n7. Profit! :heavy_check_mark:\r\n\r\n\r\n## License\r\nprintf is written under the [MIT license](http://www.opensource.org/licenses/MIT).\r\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.0458984375,
          "content": "ignore:\r\n  - \"test\"  # ignore the test folder\r\n"
        },
        {
          "name": "printf.c",
          "type": "blob",
          "size": 27.3896484375,
          "content": "///////////////////////////////////////////////////////////////////////////////\r\n// \\author (c) Marco Paland (info@paland.com)\r\n//             2014-2019, PALANDesign Hannover, Germany\r\n//\r\n// \\license The MIT License (MIT)\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n//\r\n// \\brief Tiny printf, sprintf and (v)snprintf implementation, optimized for speed on\r\n//        embedded systems with a very limited resources. These routines are thread\r\n//        safe and reentrant!\r\n//        Use this instead of the bloated standard/newlib printf cause these use\r\n//        malloc for printf (and may not be thread safe).\r\n//\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#include <stdbool.h>\r\n#include <stdint.h>\r\n\r\n#include \"printf.h\"\r\n\r\n\r\n// define this globally (e.g. gcc -DPRINTF_INCLUDE_CONFIG_H ...) to include the\r\n// printf_config.h header file\r\n// default: undefined\r\n#ifdef PRINTF_INCLUDE_CONFIG_H\r\n#include \"printf_config.h\"\r\n#endif\r\n\r\n\r\n// 'ntoa' conversion buffer size, this must be big enough to hold one converted\r\n// numeric number including padded zeros (dynamically created on stack)\r\n// default: 32 byte\r\n#ifndef PRINTF_NTOA_BUFFER_SIZE\r\n#define PRINTF_NTOA_BUFFER_SIZE    32U\r\n#endif\r\n\r\n// 'ftoa' conversion buffer size, this must be big enough to hold one converted\r\n// float number including padded zeros (dynamically created on stack)\r\n// default: 32 byte\r\n#ifndef PRINTF_FTOA_BUFFER_SIZE\r\n#define PRINTF_FTOA_BUFFER_SIZE    32U\r\n#endif\r\n\r\n// support for the floating point type (%f)\r\n// default: activated\r\n#ifndef PRINTF_DISABLE_SUPPORT_FLOAT\r\n#define PRINTF_SUPPORT_FLOAT\r\n#endif\r\n\r\n// support for exponential floating point notation (%e/%g)\r\n// default: activated\r\n#ifndef PRINTF_DISABLE_SUPPORT_EXPONENTIAL\r\n#define PRINTF_SUPPORT_EXPONENTIAL\r\n#endif\r\n\r\n// define the default floating point precision\r\n// default: 6 digits\r\n#ifndef PRINTF_DEFAULT_FLOAT_PRECISION\r\n#define PRINTF_DEFAULT_FLOAT_PRECISION  6U\r\n#endif\r\n\r\n// define the largest float suitable to print with %f\r\n// default: 1e9\r\n#ifndef PRINTF_MAX_FLOAT\r\n#define PRINTF_MAX_FLOAT  1e9\r\n#endif\r\n\r\n// support for the long long types (%llu or %p)\r\n// default: activated\r\n#ifndef PRINTF_DISABLE_SUPPORT_LONG_LONG\r\n#define PRINTF_SUPPORT_LONG_LONG\r\n#endif\r\n\r\n// support for the ptrdiff_t type (%t)\r\n// ptrdiff_t is normally defined in <stddef.h> as long or long long type\r\n// default: activated\r\n#ifndef PRINTF_DISABLE_SUPPORT_PTRDIFF_T\r\n#define PRINTF_SUPPORT_PTRDIFF_T\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n// internal flag definitions\r\n#define FLAGS_ZEROPAD   (1U <<  0U)\r\n#define FLAGS_LEFT      (1U <<  1U)\r\n#define FLAGS_PLUS      (1U <<  2U)\r\n#define FLAGS_SPACE     (1U <<  3U)\r\n#define FLAGS_HASH      (1U <<  4U)\r\n#define FLAGS_UPPERCASE (1U <<  5U)\r\n#define FLAGS_CHAR      (1U <<  6U)\r\n#define FLAGS_SHORT     (1U <<  7U)\r\n#define FLAGS_LONG      (1U <<  8U)\r\n#define FLAGS_LONG_LONG (1U <<  9U)\r\n#define FLAGS_PRECISION (1U << 10U)\r\n#define FLAGS_ADAPT_EXP (1U << 11U)\r\n\r\n\r\n// import float.h for DBL_MAX\r\n#if defined(PRINTF_SUPPORT_FLOAT)\r\n#include <float.h>\r\n#endif\r\n\r\n\r\n// output function type\r\ntypedef void (*out_fct_type)(char character, void* buffer, size_t idx, size_t maxlen);\r\n\r\n\r\n// wrapper (used as buffer) for output function type\r\ntypedef struct {\r\n  void  (*fct)(char character, void* arg);\r\n  void* arg;\r\n} out_fct_wrap_type;\r\n\r\n\r\n// internal buffer output\r\nstatic inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)\r\n{\r\n  if (idx < maxlen) {\r\n    ((char*)buffer)[idx] = character;\r\n  }\r\n}\r\n\r\n\r\n// internal null output\r\nstatic inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)\r\n{\r\n  (void)character; (void)buffer; (void)idx; (void)maxlen;\r\n}\r\n\r\n\r\n// internal _putchar wrapper\r\nstatic inline void _out_char(char character, void* buffer, size_t idx, size_t maxlen)\r\n{\r\n  (void)buffer; (void)idx; (void)maxlen;\r\n  if (character) {\r\n    _putchar(character);\r\n  }\r\n}\r\n\r\n\r\n// internal output function wrapper\r\nstatic inline void _out_fct(char character, void* buffer, size_t idx, size_t maxlen)\r\n{\r\n  (void)idx; (void)maxlen;\r\n  if (character) {\r\n    // buffer is the output fct pointer\r\n    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);\r\n  }\r\n}\r\n\r\n\r\n// internal secure strlen\r\n// \\return The length of the string (excluding the terminating 0) limited by 'maxsize'\r\nstatic inline unsigned int _strnlen_s(const char* str, size_t maxsize)\r\n{\r\n  const char* s;\r\n  for (s = str; *s && maxsize--; ++s);\r\n  return (unsigned int)(s - str);\r\n}\r\n\r\n\r\n// internal test if char is a digit (0-9)\r\n// \\return true if char is a digit\r\nstatic inline bool _is_digit(char ch)\r\n{\r\n  return (ch >= '0') && (ch <= '9');\r\n}\r\n\r\n\r\n// internal ASCII string to unsigned int conversion\r\nstatic unsigned int _atoi(const char** str)\r\n{\r\n  unsigned int i = 0U;\r\n  while (_is_digit(**str)) {\r\n    i = i * 10U + (unsigned int)(*((*str)++) - '0');\r\n  }\r\n  return i;\r\n}\r\n\r\n\r\n// output the specified string in reverse, taking care of any zero-padding\r\nstatic size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)\r\n{\r\n  const size_t start_idx = idx;\r\n\r\n  // pad spaces up to given width\r\n  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {\r\n    for (size_t i = len; i < width; i++) {\r\n      out(' ', buffer, idx++, maxlen);\r\n    }\r\n  }\r\n\r\n  // reverse string\r\n  while (len) {\r\n    out(buf[--len], buffer, idx++, maxlen);\r\n  }\r\n\r\n  // append pad spaces up to given width\r\n  if (flags & FLAGS_LEFT) {\r\n    while (idx - start_idx < width) {\r\n      out(' ', buffer, idx++, maxlen);\r\n    }\r\n  }\r\n\r\n  return idx;\r\n}\r\n\r\n\r\n// internal itoa format\r\nstatic size_t _ntoa_format(out_fct_type out, char* buffer, size_t idx, size_t maxlen, char* buf, size_t len, bool negative, unsigned int base, unsigned int prec, unsigned int width, unsigned int flags)\r\n{\r\n  // pad leading zeros\r\n  if (!(flags & FLAGS_LEFT)) {\r\n    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\r\n      width--;\r\n    }\r\n    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\r\n      buf[len++] = '0';\r\n    }\r\n    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\r\n      buf[len++] = '0';\r\n    }\r\n  }\r\n\r\n  // handle hash\r\n  if (flags & FLAGS_HASH) {\r\n    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {\r\n      len--;\r\n      if (len && (base == 16U)) {\r\n        len--;\r\n      }\r\n    }\r\n    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\r\n      buf[len++] = 'x';\r\n    }\r\n    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\r\n      buf[len++] = 'X';\r\n    }\r\n    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {\r\n      buf[len++] = 'b';\r\n    }\r\n    if (len < PRINTF_NTOA_BUFFER_SIZE) {\r\n      buf[len++] = '0';\r\n    }\r\n  }\r\n\r\n  if (len < PRINTF_NTOA_BUFFER_SIZE) {\r\n    if (negative) {\r\n      buf[len++] = '-';\r\n    }\r\n    else if (flags & FLAGS_PLUS) {\r\n      buf[len++] = '+';  // ignore the space if the '+' exists\r\n    }\r\n    else if (flags & FLAGS_SPACE) {\r\n      buf[len++] = ' ';\r\n    }\r\n  }\r\n\r\n  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\r\n}\r\n\r\n\r\n// internal itoa for 'long' type\r\nstatic size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)\r\n{\r\n  char buf[PRINTF_NTOA_BUFFER_SIZE];\r\n  size_t len = 0U;\r\n\r\n  // no hash for 0 values\r\n  if (!value) {\r\n    flags &= ~FLAGS_HASH;\r\n  }\r\n\r\n  // write if precision != 0 and value is != 0\r\n  if (!(flags & FLAGS_PRECISION) || value) {\r\n    do {\r\n      const char digit = (char)(value % base);\r\n      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\r\n      value /= base;\r\n    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\r\n  }\r\n\r\n  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\r\n}\r\n\r\n\r\n// internal itoa for 'long long' type\r\n#if defined(PRINTF_SUPPORT_LONG_LONG)\r\nstatic size_t _ntoa_long_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long long value, bool negative, unsigned long long base, unsigned int prec, unsigned int width, unsigned int flags)\r\n{\r\n  char buf[PRINTF_NTOA_BUFFER_SIZE];\r\n  size_t len = 0U;\r\n\r\n  // no hash for 0 values\r\n  if (!value) {\r\n    flags &= ~FLAGS_HASH;\r\n  }\r\n\r\n  // write if precision != 0 and value is != 0\r\n  if (!(flags & FLAGS_PRECISION) || value) {\r\n    do {\r\n      const char digit = (char)(value % base);\r\n      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;\r\n      value /= base;\r\n    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));\r\n  }\r\n\r\n  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);\r\n}\r\n#endif  // PRINTF_SUPPORT_LONG_LONG\r\n\r\n\r\n#if defined(PRINTF_SUPPORT_FLOAT)\r\n\r\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\r\n// forward declaration so that _ftoa can switch to exp notation for values > PRINTF_MAX_FLOAT\r\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags);\r\n#endif\r\n\r\n\r\n// internal ftoa for fixed decimal floating point\r\nstatic size_t _ftoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\r\n{\r\n  char buf[PRINTF_FTOA_BUFFER_SIZE];\r\n  size_t len  = 0U;\r\n  double diff = 0.0;\r\n\r\n  // powers of 10\r\n  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };\r\n\r\n  // test for special values\r\n  if (value != value)\r\n    return _out_rev(out, buffer, idx, maxlen, \"nan\", 3, width, flags);\r\n  if (value < -DBL_MAX)\r\n    return _out_rev(out, buffer, idx, maxlen, \"fni-\", 4, width, flags);\r\n  if (value > DBL_MAX)\r\n    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? \"fni+\" : \"fni\", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);\r\n\r\n  // test for very large values\r\n  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad\r\n  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {\r\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\r\n    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);\r\n#else\r\n    return 0U;\r\n#endif\r\n  }\r\n\r\n  // test for negative\r\n  bool negative = false;\r\n  if (value < 0) {\r\n    negative = true;\r\n    value = 0 - value;\r\n  }\r\n\r\n  // set default precision, if not set explicitly\r\n  if (!(flags & FLAGS_PRECISION)) {\r\n    prec = PRINTF_DEFAULT_FLOAT_PRECISION;\r\n  }\r\n  // limit precision to 9, cause a prec >= 10 can lead to overflow errors\r\n  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {\r\n    buf[len++] = '0';\r\n    prec--;\r\n  }\r\n\r\n  int whole = (int)value;\r\n  double tmp = (value - whole) * pow10[prec];\r\n  unsigned long frac = (unsigned long)tmp;\r\n  diff = tmp - frac;\r\n\r\n  if (diff > 0.5) {\r\n    ++frac;\r\n    // handle rollover, e.g. case 0.99 with prec 1 is 1.0\r\n    if (frac >= pow10[prec]) {\r\n      frac = 0;\r\n      ++whole;\r\n    }\r\n  }\r\n  else if (diff < 0.5) {\r\n  }\r\n  else if ((frac == 0U) || (frac & 1U)) {\r\n    // if halfway, round up if odd OR if last digit is 0\r\n    ++frac;\r\n  }\r\n\r\n  if (prec == 0U) {\r\n    diff = value - (double)whole;\r\n    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {\r\n      // exactly 0.5 and ODD, then round up\r\n      // 1.5 -> 2, but 2.5 -> 2\r\n      ++whole;\r\n    }\r\n  }\r\n  else {\r\n    unsigned int count = prec;\r\n    // now do fractional part, as an unsigned number\r\n    while (len < PRINTF_FTOA_BUFFER_SIZE) {\r\n      --count;\r\n      buf[len++] = (char)(48U + (frac % 10U));\r\n      if (!(frac /= 10U)) {\r\n        break;\r\n      }\r\n    }\r\n    // add extra 0s\r\n    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {\r\n      buf[len++] = '0';\r\n    }\r\n    if (len < PRINTF_FTOA_BUFFER_SIZE) {\r\n      // add decimal\r\n      buf[len++] = '.';\r\n    }\r\n  }\r\n\r\n  // do whole part, number is reversed\r\n  while (len < PRINTF_FTOA_BUFFER_SIZE) {\r\n    buf[len++] = (char)(48 + (whole % 10));\r\n    if (!(whole /= 10)) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // pad leading zeros\r\n  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {\r\n    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {\r\n      width--;\r\n    }\r\n    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {\r\n      buf[len++] = '0';\r\n    }\r\n  }\r\n\r\n  if (len < PRINTF_FTOA_BUFFER_SIZE) {\r\n    if (negative) {\r\n      buf[len++] = '-';\r\n    }\r\n    else if (flags & FLAGS_PLUS) {\r\n      buf[len++] = '+';  // ignore the space if the '+' exists\r\n    }\r\n    else if (flags & FLAGS_SPACE) {\r\n      buf[len++] = ' ';\r\n    }\r\n  }\r\n\r\n  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);\r\n}\r\n\r\n\r\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\r\n// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>\r\nstatic size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)\r\n{\r\n  // check for NaN and special values\r\n  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {\r\n    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);\r\n  }\r\n\r\n  // determine the sign\r\n  const bool negative = value < 0;\r\n  if (negative) {\r\n    value = -value;\r\n  }\r\n\r\n  // default precision\r\n  if (!(flags & FLAGS_PRECISION)) {\r\n    prec = PRINTF_DEFAULT_FLOAT_PRECISION;\r\n  }\r\n\r\n  // determine the decimal exponent\r\n  // based on the algorithm by David Gay (https://www.ampl.com/netlib/fp/dtoa.c)\r\n  union {\r\n    uint64_t U;\r\n    double   F;\r\n  } conv;\r\n\r\n  conv.F = value;\r\n  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2\r\n  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)\r\n  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5\r\n  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);\r\n  // now we want to compute 10^expval but we want to be sure it won't overflow\r\n  exp2 = (int)(expval * 3.321928094887362 + 0.5);\r\n  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;\r\n  const double z2 = z * z;\r\n  conv.U = (uint64_t)(exp2 + 1023) << 52U;\r\n  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex\r\n  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));\r\n  // correct for rounding errors\r\n  if (value < conv.F) {\r\n    expval--;\r\n    conv.F /= 10;\r\n  }\r\n\r\n  // the exponent format is \"%+03d\" and largest value is \"307\", so set aside 4-5 characters\r\n  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;\r\n\r\n  // in \"%g\" mode, \"prec\" is the number of *significant figures* not decimals\r\n  if (flags & FLAGS_ADAPT_EXP) {\r\n    // do we want to fall-back to \"%f\" mode?\r\n    if ((value >= 1e-4) && (value < 1e6)) {\r\n      if ((int)prec > expval) {\r\n        prec = (unsigned)((int)prec - expval - 1);\r\n      }\r\n      else {\r\n        prec = 0;\r\n      }\r\n      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision\r\n      // no characters in exponent\r\n      minwidth = 0U;\r\n      expval   = 0;\r\n    }\r\n    else {\r\n      // we use one sigfig for the whole part\r\n      if ((prec > 0) && (flags & FLAGS_PRECISION)) {\r\n        --prec;\r\n      }\r\n    }\r\n  }\r\n\r\n  // will everything fit?\r\n  unsigned int fwidth = width;\r\n  if (width > minwidth) {\r\n    // we didn't fall-back so subtract the characters required for the exponent\r\n    fwidth -= minwidth;\r\n  } else {\r\n    // not enough characters, so go back to default sizing\r\n    fwidth = 0U;\r\n  }\r\n  if ((flags & FLAGS_LEFT) && minwidth) {\r\n    // if we're padding on the right, DON'T pad the floating part\r\n    fwidth = 0U;\r\n  }\r\n\r\n  // rescale the float value\r\n  if (expval) {\r\n    value /= conv.F;\r\n  }\r\n\r\n  // output the floating part\r\n  const size_t start_idx = idx;\r\n  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);\r\n\r\n  // output the exponent part\r\n  if (minwidth) {\r\n    // output the exponential symbol\r\n    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);\r\n    // output the exponent value\r\n    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);\r\n    // might need to right-pad spaces\r\n    if (flags & FLAGS_LEFT) {\r\n      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);\r\n    }\r\n  }\r\n  return idx;\r\n}\r\n#endif  // PRINTF_SUPPORT_EXPONENTIAL\r\n#endif  // PRINTF_SUPPORT_FLOAT\r\n\r\n\r\n// internal vsnprintf\r\nstatic int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)\r\n{\r\n  unsigned int flags, width, precision, n;\r\n  size_t idx = 0U;\r\n\r\n  if (!buffer) {\r\n    // use null output function\r\n    out = _out_null;\r\n  }\r\n\r\n  while (*format)\r\n  {\r\n    // format specifier?  %[flags][width][.precision][length]\r\n    if (*format != '%') {\r\n      // no\r\n      out(*format, buffer, idx++, maxlen);\r\n      format++;\r\n      continue;\r\n    }\r\n    else {\r\n      // yes, evaluate it\r\n      format++;\r\n    }\r\n\r\n    // evaluate flags\r\n    flags = 0U;\r\n    do {\r\n      switch (*format) {\r\n        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;\r\n        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;\r\n        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;\r\n        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;\r\n        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;\r\n        default :                                   n = 0U; break;\r\n      }\r\n    } while (n);\r\n\r\n    // evaluate width field\r\n    width = 0U;\r\n    if (_is_digit(*format)) {\r\n      width = _atoi(&format);\r\n    }\r\n    else if (*format == '*') {\r\n      const int w = va_arg(va, int);\r\n      if (w < 0) {\r\n        flags |= FLAGS_LEFT;    // reverse padding\r\n        width = (unsigned int)-w;\r\n      }\r\n      else {\r\n        width = (unsigned int)w;\r\n      }\r\n      format++;\r\n    }\r\n\r\n    // evaluate precision field\r\n    precision = 0U;\r\n    if (*format == '.') {\r\n      flags |= FLAGS_PRECISION;\r\n      format++;\r\n      if (_is_digit(*format)) {\r\n        precision = _atoi(&format);\r\n      }\r\n      else if (*format == '*') {\r\n        const int prec = (int)va_arg(va, int);\r\n        precision = prec > 0 ? (unsigned int)prec : 0U;\r\n        format++;\r\n      }\r\n    }\r\n\r\n    // evaluate length field\r\n    switch (*format) {\r\n      case 'l' :\r\n        flags |= FLAGS_LONG;\r\n        format++;\r\n        if (*format == 'l') {\r\n          flags |= FLAGS_LONG_LONG;\r\n          format++;\r\n        }\r\n        break;\r\n      case 'h' :\r\n        flags |= FLAGS_SHORT;\r\n        format++;\r\n        if (*format == 'h') {\r\n          flags |= FLAGS_CHAR;\r\n          format++;\r\n        }\r\n        break;\r\n#if defined(PRINTF_SUPPORT_PTRDIFF_T)\r\n      case 't' :\r\n        flags |= (sizeof(ptrdiff_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\r\n        format++;\r\n        break;\r\n#endif\r\n      case 'j' :\r\n        flags |= (sizeof(intmax_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\r\n        format++;\r\n        break;\r\n      case 'z' :\r\n        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);\r\n        format++;\r\n        break;\r\n      default :\r\n        break;\r\n    }\r\n\r\n    // evaluate specifier\r\n    switch (*format) {\r\n      case 'd' :\r\n      case 'i' :\r\n      case 'u' :\r\n      case 'x' :\r\n      case 'X' :\r\n      case 'o' :\r\n      case 'b' : {\r\n        // set the base\r\n        unsigned int base;\r\n        if (*format == 'x' || *format == 'X') {\r\n          base = 16U;\r\n        }\r\n        else if (*format == 'o') {\r\n          base =  8U;\r\n        }\r\n        else if (*format == 'b') {\r\n          base =  2U;\r\n        }\r\n        else {\r\n          base = 10U;\r\n          flags &= ~FLAGS_HASH;   // no hash for dec format\r\n        }\r\n        // uppercase\r\n        if (*format == 'X') {\r\n          flags |= FLAGS_UPPERCASE;\r\n        }\r\n\r\n        // no plus or space flag for u, x, X, o, b\r\n        if ((*format != 'i') && (*format != 'd')) {\r\n          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);\r\n        }\r\n\r\n        // ignore '0' flag when precision is given\r\n        if (flags & FLAGS_PRECISION) {\r\n          flags &= ~FLAGS_ZEROPAD;\r\n        }\r\n\r\n        // convert the integer\r\n        if ((*format == 'i') || (*format == 'd')) {\r\n          // signed\r\n          if (flags & FLAGS_LONG_LONG) {\r\n#if defined(PRINTF_SUPPORT_LONG_LONG)\r\n            const long long value = va_arg(va, long long);\r\n            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\r\n#endif\r\n          }\r\n          else if (flags & FLAGS_LONG) {\r\n            const long value = va_arg(va, long);\r\n            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\r\n          }\r\n          else {\r\n            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);\r\n            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);\r\n          }\r\n        }\r\n        else {\r\n          // unsigned\r\n          if (flags & FLAGS_LONG_LONG) {\r\n#if defined(PRINTF_SUPPORT_LONG_LONG)\r\n            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);\r\n#endif\r\n          }\r\n          else if (flags & FLAGS_LONG) {\r\n            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);\r\n          }\r\n          else {\r\n            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);\r\n            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);\r\n          }\r\n        }\r\n        format++;\r\n        break;\r\n      }\r\n#if defined(PRINTF_SUPPORT_FLOAT)\r\n      case 'f' :\r\n      case 'F' :\r\n        if (*format == 'F') flags |= FLAGS_UPPERCASE;\r\n        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\r\n        format++;\r\n        break;\r\n#if defined(PRINTF_SUPPORT_EXPONENTIAL)\r\n      case 'e':\r\n      case 'E':\r\n      case 'g':\r\n      case 'G':\r\n        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;\r\n        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;\r\n        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);\r\n        format++;\r\n        break;\r\n#endif  // PRINTF_SUPPORT_EXPONENTIAL\r\n#endif  // PRINTF_SUPPORT_FLOAT\r\n      case 'c' : {\r\n        unsigned int l = 1U;\r\n        // pre padding\r\n        if (!(flags & FLAGS_LEFT)) {\r\n          while (l++ < width) {\r\n            out(' ', buffer, idx++, maxlen);\r\n          }\r\n        }\r\n        // char output\r\n        out((char)va_arg(va, int), buffer, idx++, maxlen);\r\n        // post padding\r\n        if (flags & FLAGS_LEFT) {\r\n          while (l++ < width) {\r\n            out(' ', buffer, idx++, maxlen);\r\n          }\r\n        }\r\n        format++;\r\n        break;\r\n      }\r\n\r\n      case 's' : {\r\n        const char* p = va_arg(va, char*);\r\n        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);\r\n        // pre padding\r\n        if (flags & FLAGS_PRECISION) {\r\n          l = (l < precision ? l : precision);\r\n        }\r\n        if (!(flags & FLAGS_LEFT)) {\r\n          while (l++ < width) {\r\n            out(' ', buffer, idx++, maxlen);\r\n          }\r\n        }\r\n        // string output\r\n        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {\r\n          out(*(p++), buffer, idx++, maxlen);\r\n        }\r\n        // post padding\r\n        if (flags & FLAGS_LEFT) {\r\n          while (l++ < width) {\r\n            out(' ', buffer, idx++, maxlen);\r\n          }\r\n        }\r\n        format++;\r\n        break;\r\n      }\r\n\r\n      case 'p' : {\r\n        width = sizeof(void*) * 2U;\r\n        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;\r\n#if defined(PRINTF_SUPPORT_LONG_LONG)\r\n        const bool is_ll = sizeof(uintptr_t) == sizeof(long long);\r\n        if (is_ll) {\r\n          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);\r\n        }\r\n        else {\r\n#endif\r\n          idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)((uintptr_t)va_arg(va, void*)), false, 16U, precision, width, flags);\r\n#if defined(PRINTF_SUPPORT_LONG_LONG)\r\n        }\r\n#endif\r\n        format++;\r\n        break;\r\n      }\r\n\r\n      case '%' :\r\n        out('%', buffer, idx++, maxlen);\r\n        format++;\r\n        break;\r\n\r\n      default :\r\n        out(*format, buffer, idx++, maxlen);\r\n        format++;\r\n        break;\r\n    }\r\n  }\r\n\r\n  // termination\r\n  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);\r\n\r\n  // return written chars without terminating \\0\r\n  return (int)idx;\r\n}\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nint printf_(const char* format, ...)\r\n{\r\n  va_list va;\r\n  va_start(va, format);\r\n  char buffer[1];\r\n  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\r\n  va_end(va);\r\n  return ret;\r\n}\r\n\r\n\r\nint sprintf_(char* buffer, const char* format, ...)\r\n{\r\n  va_list va;\r\n  va_start(va, format);\r\n  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);\r\n  va_end(va);\r\n  return ret;\r\n}\r\n\r\n\r\nint snprintf_(char* buffer, size_t count, const char* format, ...)\r\n{\r\n  va_list va;\r\n  va_start(va, format);\r\n  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);\r\n  va_end(va);\r\n  return ret;\r\n}\r\n\r\n\r\nint vprintf_(const char* format, va_list va)\r\n{\r\n  char buffer[1];\r\n  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);\r\n}\r\n\r\n\r\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va)\r\n{\r\n  return _vsnprintf(_out_buffer, buffer, count, format, va);\r\n}\r\n\r\n\r\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)\r\n{\r\n  va_list va;\r\n  va_start(va, format);\r\n  const out_fct_wrap_type out_fct_wrap = { out, arg };\r\n  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);\r\n  va_end(va);\r\n  return ret;\r\n}\r\n"
        },
        {
          "name": "printf.h",
          "type": "blob",
          "size": 4.865234375,
          "content": "///////////////////////////////////////////////////////////////////////////////\r\n// \\author (c) Marco Paland (info@paland.com)\r\n//             2014-2019, PALANDesign Hannover, Germany\r\n//\r\n// \\license The MIT License (MIT)\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n// \r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n// \r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n//\r\n// \\brief Tiny printf, sprintf and snprintf implementation, optimized for speed on\r\n//        embedded systems with a very limited resources.\r\n//        Use this instead of bloated standard/newlib printf.\r\n//        These routines are thread safe and reentrant.\r\n//\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n#ifndef _PRINTF_H_\r\n#define _PRINTF_H_\r\n\r\n#include <stdarg.h>\r\n#include <stddef.h>\r\n\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n\r\n/**\r\n * Output a character to a custom device like UART, used by the printf() function\r\n * This function is declared here only. You have to write your custom implementation somewhere\r\n * \\param character Character to output\r\n */\r\nvoid _putchar(char character);\r\n\r\n\r\n/**\r\n * Tiny printf implementation\r\n * You have to implement _putchar if you use printf()\r\n * To avoid conflicts with the regular printf() API it is overridden by macro defines\r\n * and internal underscore-appended functions like printf_() are used\r\n * \\param format A string that specifies the format of the output\r\n * \\return The number of characters that are written into the array, not counting the terminating null character\r\n */\r\n#define printf printf_\r\nint printf_(const char* format, ...);\r\n\r\n\r\n/**\r\n * Tiny sprintf implementation\r\n * Due to security reasons (buffer overflow) YOU SHOULD CONSIDER USING (V)SNPRINTF INSTEAD!\r\n * \\param buffer A pointer to the buffer where to store the formatted string. MUST be big enough to store the output!\r\n * \\param format A string that specifies the format of the output\r\n * \\return The number of characters that are WRITTEN into the buffer, not counting the terminating null character\r\n */\r\n#define sprintf sprintf_\r\nint sprintf_(char* buffer, const char* format, ...);\r\n\r\n\r\n/**\r\n * Tiny snprintf/vsnprintf implementation\r\n * \\param buffer A pointer to the buffer where to store the formatted string\r\n * \\param count The maximum number of characters to store in the buffer, including a terminating null character\r\n * \\param format A string that specifies the format of the output\r\n * \\param va A value identifying a variable arguments list\r\n * \\return The number of characters that COULD have been written into the buffer, not counting the terminating\r\n *         null character. A value equal or larger than count indicates truncation. Only when the returned value\r\n *         is non-negative and less than count, the string has been completely written.\r\n */\r\n#define snprintf  snprintf_\r\n#define vsnprintf vsnprintf_\r\nint  snprintf_(char* buffer, size_t count, const char* format, ...);\r\nint vsnprintf_(char* buffer, size_t count, const char* format, va_list va);\r\n\r\n\r\n/**\r\n * Tiny vprintf implementation\r\n * \\param format A string that specifies the format of the output\r\n * \\param va A value identifying a variable arguments list\r\n * \\return The number of characters that are WRITTEN into the buffer, not counting the terminating null character\r\n */\r\n#define vprintf vprintf_\r\nint vprintf_(const char* format, va_list va);\r\n\r\n\r\n/**\r\n * printf with output function\r\n * You may use this as dynamic alternative to printf() with its fixed _putchar() output\r\n * \\param out An output function which takes one character and an argument pointer\r\n * \\param arg An argument pointer for user data passed to output function\r\n * \\param format A string that specifies the format of the output\r\n * \\return The number of characters that are sent to the output function, not counting the terminating null character\r\n */\r\nint fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...);\r\n\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n\r\n\r\n#endif  // _PRINTF_H_\r\n"
        },
        {
          "name": "test",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}