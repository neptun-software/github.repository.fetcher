{
  "metadata": {
    "timestamp": 1736710199314,
    "page": 903,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mptre/yank",
      "stars": 1630,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "/yank.o\n/yank\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 4.7578125,
          "content": "# v1.3.0 - 2022-06-18\n\n## News\n\n- Add opt-in selection of one and only field.\n  (d8b2024)\n  (Anton Lindqvist)\n\n# v1.2.0 - 2019-08-12\n\n- Add openSUSE installation instructions to README.\n  (c4ce72e)\n  (Dany Marcoux)\n\n- Do not confuse the escape key with up arrow.\n  (8536116)\n  (Emanuele Giaquinta)\n\n- Remove opinionated `-Werror` option from `CFLAGS`.\n  (f9ac9e6)\n  (Anton Lindqvist)\n\n- Map carriage return to newline.\n  (dffe105)\n  (Anton Lindqvist)\n\n# v1.1.0 - 2018-11-01\n\n- Fix compilation on FreeBSD by passing preprocessor macros in `CFLAGS` as\n  opposed of using `CPPFLAGS` which is not honored.\n  (78ededb)\n  (Tobias Kortkamp)\n\n- Add FreeBSD install instructions.\n  (0dd944b)\n  (Tobias Kortkamp)\n\n- Fix a bogus free by storing a copy of the pattern argument.\n  (8dff9f3)\n  (Tobias Kortkamp)\n\n# v1.0.0 - 2018-09-09\n\n- Fix a broken reference and improve the semantics of the manual.\n  (f99c6ed, 7a964c1)\n  (Anton Lindqvist)\n\n- Add Nix installation instructions to README.\n  (412a5cd, #40)\n  (Matt)\n\n- Add caveats section to manual.\n  (88e8ca8)\n  (Anton Lindqvist)\n\n- Start providing deterministic release tarballs,\n  instead of relying on the ones created by GitHub.\n  (99a91e2)\n\n# v0.8.3 - 2017-06-05\n\n- Fix typo in README and man page (fe45fc1) (Jakub Wilk)\n\n- Add OpenBSD install instructions to README (c20e9bb) (Anton Lindqvist)\n\n- Call `setlocale(3)` prior pledge, allows the `rpath` promise to be removed\n  (20cdc5a) (Anton Lindqvist)\n\n- Compile and link separately (7691802) (Anton Lindqvist)\n\n- Cleanup README and man page (495b53e, 6dd722d) (Anton Lindqvist)\n\n- `snprintf(3)` can return `-1` (9ecb1f5) (Anton Lindqvist)\n\n# v0.8.2 - 2017-02-19\n\n- Ensure `make clean` always exits with success (47a0ee9) (Sébastien Delafond)\n\n# v0.8.1 - 2017-02-18\n\n- Add Fedora install instructions to README (#33, #34, 8d90aae) (Nemanja\n  Milosevic)\n\n- Allow the name of the compiled binary to be changed using the `PROG` variable\n  (#35, #36, 1c43c46) (Nemanja Milosevic)\n\n# v0.8.0 - 2017-01-17\n\n- Update man page and README (9eac46f, 252a419) (Anton Lindqvist)\n\n- Add Arch Linux install instructions to README (#32, db259d8) (Javier Tiá)\n\n- Use `install(1)` in Makefile (11a2dc1, 42604e9) (Anton Lindqvist)\n\n- Add support for `DESTDIR` to Makefile (77cf987) (Anton Lindqvist)\n\n# v0.7.1 - 2016-10-08\n\n- Update man page (2e78c28, a5cdba9) (Anton Lindqvist)\n\n- Consolidate key bindings (5b4a840) (Anton Lindqvist)\n\n- Fix `snprintf(3)` return value check (9fbf248) (Anton Lindqvist)\n\n- Improve error messages (89be934) (Anton Lindqvist)\n\n- Fix segfault when no fields are found (f3ef1ea) (Anton Lindqvist)\n\n- Add Vi goto `g` and `G` key bindings (859f27b) (Anton Lindqvist)\n\n- Refactoring and cleanup (2017de6) (Anton Lindqvist)\n\n# v0.7.0 - 2016-05-18\n\n- Add MANPREFIX support to installation task (Anton Lindqvist)\n\n- Pledge on OpenBSD (Anton Lindqvist)\n\n# v0.6.4 - 2016-03-13\n\n- Add Vi key bindings (Samson Yeung)\n\n- Fix wrong exit code on yank command failure (Anton Lindqvist)\n\n# v0.6.3 - 2016-02-20\n\n- Exit with correct code on invocation failure (Anton Lindqvist)\n\n- Don't allow yanking if the input doesn't contain any fields (Anton Lindqvist)\n\n- Fix endless loop while executing the supplied regex (Anton Lindqvist)\n\n# v0.6.2 - 2015-12-15\n\n- Fix non string literal compilation warning (Anton Lindqvist)\n\n# v0.6.1 - 2015-12-15\n\n- Use more common save/restore cursor capabilities (Eli Young)\n\n# v0.6.0 - 2015-12-06\n\n- Add regex delimiter support using the `-g` option and `-i` to make the pattern\n  case-insensitive (Anton Lindqvist)\n\n# v0.5.0 - 2015-11-12\n\n- Add arrow key bindings (Anton Lindqvist)\n\n- Add Debian installation instructions (Sébastien Delafond)\n\n- Add OS X installation instructions (Carl Dong)\n\n# v0.4.1 - 2015-10-19\n\n- Fix number of lines in input bug (Anton Lindqvist)\n\n- Fix typo in man page (FND)\n\n- Fix description in man page (Jeremiah LaRocco)\n\n# v0.4.0 - 2015-10-10\n\n- Always recognize carriage return as a delimiter (Anton Lindqvist)\n\n- Exit with the same exit code as the yank command on failure (Anton Lindqvist)\n\n- Ensure all data is written to the terminal (Anton Lindqvist)\n\n- Fix number of lines in input bug (Anton Lindqvist)\n\n# v0.3.1 - 2015-09-24\n\n- Fix moving beyond input bug (Anton Lindqvist)\n\n# v0.3.0 - 2015-09-21\n\n- Add `-x` option used to enable usage of the alternate screen (Anton Lindqvist)\n\n- Fix `style(9)` violations (Anton Lindqvist)\n\n# v0.2.0 - 2015-09-10\n\n- Add `-l` option used to yank a whole line (Anton Lindqvist)\n\n- Add `Ctrl-D` key binding which will exit without invoking the yank command\n  (Anton Lindqvist)\n\n- Require presence of the `--` option used to separate options and the yank\n  command (Anton Lindqvist)\n\n- Fix number of lines in input bug (Anton Lindqvist)\n\n# v0.1.1 - 2015-08-28\n\n- Add support for linking against musl (Anton Lindqvist)\n\n# v0.1.0 - 2015-08-24\n\n- Initial commit (Anton Lindqvist)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2022 Anton Lindqvist\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.1845703125,
          "content": "VERSION=\t1.3.0\n\nYANKCMD=\txsel\n\nPREFIX=\t\t/usr/local\nMANPREFIX=\t${PREFIX}/share/man\n\nPROG=\tyank\nOBJS=\tyank.o\n\nKNFMT+=\tyank.c\n\nINSTALL_PROGRAM=\tinstall -s -m 0755\nINSTALL_MAN=\t\tinstall -m 0644\n\nCFLAGS+=\t-pedantic -Wall -Wextra\nCFLAGS+=\t-DVERSION=\\\"${VERSION}\\\" -DYANKCMD=\\\"${YANKCMD}\\\"\n\nDISTFILES=\tCHANGELOG.md \\\n\t\tLICENSE \\\n\t\tMakefile \\\n\t\tREADME.md \\\n\t\tyank.1 \\\n\t\tyank.c\n\nall: ${PROG}\n\n${PROG}: ${OBJS}\n\t${CC} -o ${PROG} ${OBJS} ${LDFLAGS}\n\nclean:\n\trm -f ${PROG} ${OBJS}\n.PHONY: clean\n\ndist:\n\tset -e; \\\n\td=yank-${VERSION}; \\\n\tmkdir $$d; \\\n\tfor f in ${DISTFILES}; do \\\n\t\tmkdir -p $$d/`dirname $$f`; \\\n\t\tcp -p ${.CURDIR}/$$f $$d/$$f; \\\n\tdone; \\\n\tfind $$d -type d -exec touch -r ${.CURDIR}/Makefile {} \\;; \\\n\ttar czvf ${.CURDIR}/$$d.tar.gz $$d; \\\n\t(cd ${.CURDIR}; sha256 $$d.tar.gz >$$d.sha256); \\\n\trm -r $$d\n.PHONY: dist\n\nformat:\n\tcd ${.CURDIR} && knfmt -is ${KNFMT}\n.PHONY: format\n\ninstall: ${PROG}\n\t@mkdir -p ${DESTDIR}${PREFIX}/bin\n\t@mkdir -p ${DESTDIR}${MANPREFIX}/man1\n\t${INSTALL_PROGRAM} ${PROG} ${DESTDIR}${PREFIX}/bin\n\t${INSTALL_MAN} yank.1 ${DESTDIR}${MANPREFIX}/man1\n.PHONY: install\n\nlint:\n\tcd ${.CURDIR} && mandoc -Tlint -Wstyle yank.1\n\tcd ${.CURDIR} && knfmt -ds ${KNFMT}\n.PHONY: lint\n\n-include config.mk\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.96484375,
          "content": "# yank\n\nYank terminal output to clipboard.\n\n![yank](https://raw.githubusercontent.com/mptre/yank/gh-pages/screencast.gif)\n\n## Description\n\nThe\n[yank(1)][yank]\nutility reads input from `stdin` and display a selection interface that allows a\nfield to be selected and copied to the clipboard.\nFields are either recognized by a regular expression using the `-g` option or by\nsplitting the input on a delimiter sequence using the `-d` option.\n\nUsing the arrow keys will move the selected field.\nThe interface supports several Emacs and Vi like key bindings,\nconsult the man page for further reference.\nPressing the return key will invoke the yank command and write the selected\nfield to its `stdin`.\nThe yank command defaults to\n[xsel(1)][xsel]\nbut could be anything that accepts input on `stdin`.\nWhen invoking yank,\neverything supplied after the `--` option will be used as the yank command,\nsee examples below.\n\n## Motivation\n\nOthers including myself consider it a cache miss when resort to using the mouse.\nCopying output from the terminal is still one of the few cases where I still use\nthe mouse.\nSeveral terminal multiplexers solves this issue,\nhowever I don't want to be required to use a multiplexer but instead use a\nterminal agnostic solution.\n\n## Examples\n\n- Yank an environment variable key or value:\n\n  ```sh\n  $ env | yank -d =\n  ```\n\n- Yank a field from a CSV file:\n\n  ```sh\n  $ yank -d \\\", <file.csv\n  ```\n\n- Yank a whole line using the `-l` option:\n\n  ```sh\n  $ make 2>&1 | yank -l\n  ```\n\n- If `stdout` is not a terminal the selected field will be written to `stdout`\n  and exit without invoking the yank command.\n  Kill the selected PID:\n\n  ```sh\n  $ ps ux | yank -g [0-9]+ | xargs kill\n  ```\n\n- Yank the selected field to the clipboard as opposed of the default primary\n  clipboard:\n\n  ```sh\n  $ yank -- xsel -b\n  ```\n\n## Installation\n\n### Arch Linux\n\n```sh\n$ pacman -S yank\n```\n\n### Debian\n\n```sh\n$ sudo apt-get install yank\n```\n\nThe binary is installed at `/usr/bin/yank-cli` due to a naming conflict.\n\n### Fedora\n\nVersions 24/25/26/Rawhide:\n\n```sh\n$ sudo dnf install yank\n```\n\nThe binary is installed at `/usr/bin/yank-cli` due to a naming conflict.\nMan-pages are available as both `yank` and `yank-cli`.\n\n### Nix/NixOS\n\n```sh\n$ nix-env -i yank\n```\n\n### openSUSE\n\n```\n$ zypper install yank\n```\n\n### macOS via Homebrew\n\n```sh\n$ brew install yank\n```\n\n### macOS via MacPorts\n\n```sh\n$ sudo port install yank\n```\n\n### FreeBSD\n\n```sh\n$ pkg install yank\n```\n\n### OpenBSD\n\n```sh\n$ pkg_add yank\n```\n\n### From source\n\nThe install directory defaults to `/usr/local`:\n\n```sh\n$ make install\n```\n\nChange the install directory using the `PREFIX` variable:\n\n```sh\n$ make PREFIX=DIR install\n```\n\nThe default yank command can be defined using the `YANKCMD` variable.\nFor instance,\nmacOS users would prefer `pbcopy(1)`:\n\n```sh\n$ make YANKCMD=pbcopy\n```\n\n## License\n\nCopyright (c) 2015-2022 Anton Lindqvist.\nDistributed under the MIT license.\n\n[xsel]: http://www.vergenet.net/~conrad/software/xsel/\n[yank]: https://www.basename.se/yank/\n"
        },
        {
          "name": "yank.1",
          "type": "blob",
          "size": 3.0224609375,
          "content": ".Dd $Mdocdate: July 10 2015 $\n.Dt YANK 1\n.Os\n.Sh NAME\n.Nm yank\n.Nd yank terminal output to clipboard\n.Sh SYNOPSIS\n.Nm\n.Op Fl 1ilxv\n.Op Fl d Ar delim\n.Op Fl g Ar pattern\n.Op Fl - Ar command Op Ar argument ...\n.Sh DESCRIPTION\nRead input from\n.Pa stdin\nand display a selection interface that allows a field to be selected and copied\nto the clipboard.\nFields are either recognized by a regular expression using the\n.Fl g\noption or by splitting the input on a delimiter sequence using the\n.Fl d\noption, see\n.Sx DELIMITERS .\n.Pp\nUsing the arrow keys will move the selected field, see\n.Sx COMMANDS .\nPressing the return key will invoke\n.Ar command\nand write the selected field to its\n.Pa stdin .\nThe\n.Ar command\ndefaults to\n.Xr xsel 1x\nbut could be anything that accepts input on\n.Pa stdin ,\nsee\n.Sx EXAMPLES .\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl 1\nIf only one field is recognized, select it and invoke\n.Ar command\nwithout displaying the selection interface.\n.It Fl d Ar delim\nAll input characters not present in\n.Ar delim\nwill be recognized as fields, see\n.Sx DELIMITERS .\n.It Fl g Ar pattern\nUse\n.Ar pattern\nto recognize fields, expressed as a POSIX extended regular expression.\n.It Fl i\nIgnore case differences between\n.Ar pattern\nand the input.\n.It Fl l\nUse the default delimiters except for space, see\n.Sx DELIMITERS .\n.It Fl v\nPrints version.\n.It Fl x\nUse alternate screen.\n.It Fl - Ar command Op Ar argument ...\nUse\n.Ar command\nwith zero or more\n.Ar args\nas the yank command.\n.El\n.Sh COMMANDS\n.Bl -tag -width XXXX\n.It Ic Ctrl-A | g\nMove selection to the first field.\n.It Ic Ctrl-C | Ctrl-D\nExit without invoking the yank command.\n.It Ic Ctrl-E | G\nMove selection to the last field.\n.It Ic Ctrl-P Ns / Ns Ic Ctrl-N | Ic Left Ns / Ns Ic Right | Ic h Ns / Ns Ic l\nMove selection to the left or right.\n.It Ic Up Ns / Ns Ic Down | Ic j Ns / Ns Ic k\nMove selection to the next or previous line.\n.It Ic Enter\nExit using the selected field.\n.El\n.Sh DELIMITERS\nIf the\n.Fl d\nand\n.Fl g\noptions are omitted the following characters are recognized as delimiters by\ndefault:\n.Bl -tag -width XXXX\n.It \\ef\nform feed\n.It \\en\nnew line\n.It \\er\ncarriage return\n.It \\es\nspace\n.It \\et\nhorizontal tab\n.El\n.Pp\nIf the\n.Fl d\noption is present space is not recognized as a delimiter.\n.Sh EXAMPLES\nYank an environment variable key or value:\n.Pp\n.Dl $ env | yank -d =\n.Pp\nYank a field from a CSV file:\n.Pp\n.Dl $ yank -d \\e\\&\", <file.csv\n.Pp\nYank a whole line using the\n.Fl l\noption:\n.Pp\n.Dl $ make 2>&1 | yank -l\n.Pp\nIf\n.Pa stdout\nis not a terminal the selected field will be written to\n.Pa stdout\nand exit without invoking the yank command.\nKill the selected PID:\n.Pp\n.Dl $ ps ux | yank -g [0-9]+ | xargs kill\n.Pp\nYank the selected field to the clipboard as opposed of the default primary\nclipboard:\n.Pp\n.Dl $ yank \\(em xsel -b\n.Sh DIAGNOSTICS\n.Ex -std\n.Sh SEE ALSO\n.Xr re_format 7\n.Sh AUTHORS\n.An Anton Lindqvist Aq Mt anton@basename.se\n.Sh CAVEATS\nRecognizing fields enclosed in brackets requires\n.Sq \\&]\nto be present before\n.Sq \\&[\nin the argument given to the\n.Fl d\noption,\nsee\n.Xr re_format 7 .\n"
        },
        {
          "name": "yank.c",
          "type": "blob",
          "size": 9.1181640625,
          "content": "#include <sys/ioctl.h>\n#include <sys/wait.h>\n\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <locale.h>\n#include <regex.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n\n/* Terminal capabilities */\n#define T_CLR_EOS             \"\\033[J\"\n#define T_CURSOR_INVISIBLE    \"\\033[?25l\"\n#define T_CURSOR_VISIBLE      \"\\033[?25h\"\n#define T_ENTER_CA_MODE       \"\\033[?1049h\"\n#define T_ENTER_STANDOUT_MODE \"\\033[7m\"\n#define T_EXIT_CA_MODE        \"\\033[?1049l\"\n#define T_EXIT_STANDOUT_MODE  \"\\033[0m\"\n#define T_RESTORE_CURSOR      \"\\0338\"\n#define T_SAVE_CURSOR         \"\\0337\"\n\n#define MAX(x, y) ((x) > (y) ? (x) : (y))\n#define MIN(x, y) ((x) < (y) ? (x) : (y))\n\nenum {\n\tKEY_ENTER = 1,\n\tKEY_HOME,\n\tKEY_END,\n\tKEY_TERM,\n\tKEY_UP,\n\tKEY_RIGHT,\n\tKEY_DOWN,\n\tKEY_LEFT\n};\n\nstruct field {\n\tsize_t\tso; /* start offset */\n\tsize_t\teo; /* end offset */\n\tsize_t\tlo; /* line offset */\n};\n\nstatic regex_t reg;\n\nstatic char **yankargv;\n\nstatic struct {\n\tsize_t\t\t nmemb;\n\tsize_t\t\t size;\n\tstruct field\t*v;\n} f;\n\nstatic struct {\n\tsize_t\t size;\n\tsize_t\t nmemb;\n\tchar\t*v;\n} in;\n\nstatic struct {\n\tint\t\trfd;\n\tint\t\twfd;\n\tint\t\tca;\t/* use alternate screen */\n\tstruct termios\tattr;\n} tty;\n\nstatic void\ninput(void)\n{\n\tint n;\n\n\tin.size = BUFSIZ;\n\tif ((in.v = malloc(in.size)) == NULL)\n\t\terr(1, NULL);\n\n\twhile ((n = read(0, in.v + in.nmemb, in.size - in.nmemb)) != 0) {\n\t\tif (n == -1)\n\t\t\terr(1, \"read\");\n\t\tin.nmemb += n;\n\n\t\tif (in.nmemb < in.size)\n\t\t\tcontinue;\n\t\tin.size *= 2;\n\t\tif ((in.v = realloc(in.v, in.size)) == NULL)\n\t\t\terr(1, NULL);\n\t}\n\tmemset(in.v + in.nmemb, 0, in.size - in.nmemb);\n}\n\n/*\n * Returns s transformed into a negation regular expression pattern concatenated\n * with the default delimiters.\n */\nstatic char *\nstrtopat(const char *s)\n{\n\tconst char *fmt = \"[^%s\\f\\n\\r\\t]+\";\n\tchar *pat;\n\tsize_t len;\n\tint n;\n\n\tlen = strlen(s) + strlen(fmt) + 1;\n\tif ((pat = malloc(len)) == NULL)\n\t\terr(1, NULL);\n\tn = snprintf(pat, len, fmt, s);\n\tif (n == -1 || n >= (ssize_t)len)\n\t\terrx(1, \"pattern too long\");\n\n\treturn pat;\n}\n\n/*\n * Returns zero if f1 and f2 intersects, 1 if f2 begins after f1 and -1\n * otherwise. Both field start and end offsets are normalized with their\n * corresponding line offset.\n */\nstatic int\nfcmp(const struct field *f1, const struct field *f2)\n{\n\tsize_t e1, e2, s1, s2;\n\n\ts1 = f1->so - f1->lo, e1 = f1->eo - f1->lo;\n\ts2 = f2->so - f2->lo, e2 = f2->eo - f2->lo;\n\n\treturn MAX(s1, s2) <= MIN(e1, e2) ? 0 : (e1 < s2 ? 1 : -1);\n}\n\nstatic ssize_t\nxwrite(int fd, const char *s, size_t nmemb)\n{\n\tssize_t r;\n\tsize_t n;\n\n\tn = nmemb;\n\tdo {\n\t\tr = write(fd, s, n);\n\t\tif (r == -1)\n\t\t\treturn r;\n\t\tn -= r;\n\t\ts += r;\n\t} while (n);\n\n\treturn nmemb;\n}\n\nstatic void\nyank(const char *s, size_t nmemb)\n{\n\tint fd[2];\n\tint status;\n\tpid_t pid;\n\n\tif (!isatty(1)) {\n\t\tif (xwrite(1, s, nmemb) == -1)\n\t\t\terr(1, \"write\");\n\t\texit(0);\n\t}\n\n\tif (pipe(fd) == -1)\n\t\terr(1, \"pipe\");\n\tif (dup2(fd[0], 0) == -1)\n\t\terr(1, \"dup2\");\n\tif (close(fd[0]) == -1)\n\t\terr(1, \"close\");\n\tif (xwrite(fd[1], s, nmemb) == -1)\n\t\terr(1, \"write\");\n\tif (close(fd[1]) == -1)\n\t\terr(1, \"close\");\n\tpid = fork();\n\tswitch (pid) {\n\tcase -1:\n\t\terr(1, \"fork\");\n\t\t/* NOTREACHED */\n\tcase 0:\n\t\texecvp(yankargv[0], yankargv);\n\t\terr(126 + (errno == ENOENT), \"%s\", yankargv[0]);\n\t\t/* NOTREACHED */\n\tdefault:\n\t\tif (waitpid(pid, &status, 0) == -1)\n\t\t\terr(1, \"waitpid\");\n\t\tif (WIFSIGNALED(status))\n\t\t\texit(128 + WTERMSIG(status));\n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t}\n}\n\nstatic void\ntwrite(const char *s, size_t nmemb)\n{\n\tif (xwrite(tty.wfd, s, nmemb) == -1)\n\t\terr(1, \"write\");\n}\n\nstatic void\ntputs(const char *s)\n{\n\tsize_t n;\n\n\tn = strlen(s);\n\ttwrite(s, n);\n}\n\nstatic void\ntsetup(void)\n{\n\tstruct termios attr;\n\tstruct winsize ws;\n\tregmatch_t r;\n\tchar *e, *s;\n\tsize_t m, n, w;\n\tunsigned int i, j;\n\n\tif ((tty.rfd = open(\"/dev/tty\", O_RDONLY)) == -1)\n\t\terr(1, \"/dev/tty\");\n\tif ((tty.wfd = open(\"/dev/tty\", O_WRONLY)) == -1)\n\t\terr(1, \"/dev/tty\");\n\n\tif (ioctl(tty.rfd, TIOCGWINSZ, &ws) == -1)\n\t\terr(1, \"TIOCGWINSZ\");\n\n\tf.size = 32;\n\tif ((f.v = malloc(f.size*sizeof(struct field))) == NULL)\n\t\terr(1, NULL);\n\tm = n = MIN(ws.ws_col*ws.ws_row, (ssize_t)in.nmemb);\n\ts = e = in.v;\n\twhile (m && !regexec(&reg, e, 1, &r, 0) && r.rm_eo - r.rm_so) {\n\t\tf.v[f.nmemb].so = f.v[f.nmemb].eo = e - s;\n\t\tf.v[f.nmemb].so += r.rm_so;\n\t\tf.v[f.nmemb].eo += MAX(MIN(r.rm_eo, (ssize_t)m) - 1, 0);\n\t\te += r.rm_eo;\n\t\tm -= MIN(r.rm_eo, (ssize_t)m);\n\n\t\tif (++f.nmemb < f.size)\n\t\t\tcontinue;\n\t\tf.size *= 2;\n\t\tif ((f.v = realloc(f.v, f.size*sizeof(struct field))) == NULL)\n\t\t\terr(1, NULL);\n\t}\n\n\tfor (i = j = 0, s = e = in.v; n && i < ws.ws_row; i++) {\n\t\tif (s == e && !(e = memchr(s + 1, '\\n', n)))\n\t\t\te = in.v + in.nmemb;\n\n\t\tw = MIN(e - s, ws.ws_col);\n\t\tfor (; j < f.nmemb && f.v[j].so < (size_t)(s - in.v + w); j++)\n\t\t\tf.v[j].lo = s - in.v;\n\t\ts += w;\n\t\tn -= w;\n\t}\n\tf.nmemb = MIN(f.nmemb, j);\n\t/* Ensure last field does not exceed the terminal width. */\n\tif (n > 0 && f.nmemb > 0 &&\n\t    f.v[f.nmemb - 1].eo - f.v[f.nmemb - 1].lo >= ws.ws_col)\n\t\tf.v[f.nmemb - 1].eo = f.v[f.nmemb - 1].lo + ws.ws_col - 1;\n\t/* Number of bytes to output. */\n\tf.v[f.nmemb].lo = MAX(s - in.v - 1, 0);\n\n\tif (tcgetattr(tty.rfd, &tty.attr) == -1)\n\t\terr(1, \"tcgetattr\");\n\tattr = tty.attr;\n\tattr.c_iflag |= ICRNL;\n\tattr.c_lflag &= ~(ICANON|ECHO|ISIG);\n\tif (tcsetattr(tty.rfd, TCSANOW, &attr) == -1)\n\t\terr(1, \"tcsetattr\");\n\n\tif (tty.ca)\n\t\ttputs(T_ENTER_CA_MODE);\n\ttputs(T_CURSOR_INVISIBLE);\n\t/* Emit the number of lines and save the cursor position. */\n\tfor (j = 0; j < i; j++)\n\t\ttputs(\"\\n\");\n\tfor (j = 0; j < i; j++)\n\t\ttputs(\"\\033M\");\n\ttputs(T_SAVE_CURSOR);\n}\n\nstatic void\ntend(void)\n{\n\ttputs(T_RESTORE_CURSOR);\n\ttputs(T_CLR_EOS);\n\ttputs(T_CURSOR_VISIBLE);\n\tif (tty.ca)\n\t\ttputs(T_EXIT_CA_MODE);\n\ttcsetattr(tty.rfd, TCSANOW, &tty.attr);\n\tclose(tty.rfd);\n\tclose(tty.wfd);\n}\n\nstatic int\ntgetc(void)\n{\n\tstatic struct {\n\t\tconst char\t*s;\n\t\tint\t\t c;\n\t} keys[] = {\n\t\t{ \"\\n\",\t\tKEY_ENTER },\n\t\t{ \"\\001\",\tKEY_HOME },\t/* Ctrl-A */\n\t\t{ \"\\003\",\tKEY_TERM },\t/* Ctrl-C */\n\t\t{ \"\\004\",\tKEY_TERM },\t/* Ctrl-D */\n\t\t{ \"\\005\",\tKEY_END },\t/* Ctrl-E */\n\t\t{ \"\\016\",\tKEY_RIGHT },\t/* Ctrl-N */\n\t\t{ \"\\020\",\tKEY_LEFT },\t/* Ctrl-P */\n\t\t{ \"G\",\t\tKEY_END },\n\t\t{ \"g\",\t\tKEY_HOME },\n\t\t{ \"h\",\t\tKEY_LEFT },\n\t\t{ \"j\",\t\tKEY_DOWN },\n\t\t{ \"k\",\t\tKEY_UP },\n\t\t{ \"l\",\t\tKEY_RIGHT },\n\t\t{ \"\\033[A\",\tKEY_UP },\n\t\t{ \"\\033[C\",\tKEY_RIGHT },\n\t\t{ \"\\033[B\",\tKEY_DOWN },\n\t\t{ \"\\033[D\",\tKEY_LEFT },\n\t\t{ NULL,\t\t0 },\n\t};\n\tchar buf[4];\n\tssize_t n;\n\tint i;\n\n\tn = read(tty.rfd, buf, sizeof(buf) - 1);\n\tif (n == -1)\n\t\terr(1, \"read\");\n\tif (n == 0)\n\t\treturn KEY_TERM;\t/* EOF */\n\tbuf[n] = '\\0';\n\n\tfor (i = 0; keys[i].s != NULL; i++)\n\t\tif (strncmp(keys[i].s, buf, strlen(keys[i].s)) == 0)\n\t\t\treturn keys[i].c;\n\n\treturn 0;\n}\n\nstatic const struct field *\ntmain(void)\n{\n\tsize_t n;\n\tint c, i, j, k;\n\n\ti = j = 0;\n\tn = f.v[f.nmemb].lo;\n\tfor (;;) {\n\t\ttputs(T_RESTORE_CURSOR);\n\t\tif (f.nmemb > 0) {\n\t\t\ttwrite(in.v, f.v[i].so);\n\t\t\ttputs(T_ENTER_STANDOUT_MODE);\n\t\t\ttwrite(in.v + f.v[i].so, f.v[i].eo - f.v[i].so + 1);\n\t\t\ttputs(T_EXIT_STANDOUT_MODE);\n\t\t\ttwrite(in.v + f.v[i].eo + 1, n - f.v[i].eo);\n\t\t} else {\n\t\t\ttwrite(in.v, n);\n\t\t}\n\n\t\tc = tgetc();\n\t\tswitch (c) {\n\t\tcase KEY_ENTER:\n\t\t\tif (f.nmemb > 0)\n\t\t\t\treturn &f.v[i];\n\t\t\tbreak;\n\t\tcase KEY_TERM:\n\t\t\treturn NULL;\n\t\tcase KEY_HOME:\n\t\t\tj = 0;\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\t\tj = i + 1;\n\t\t\tbreak;\n\t\tcase KEY_END:\n\t\t\tj = f.nmemb - 1;\n\t\t\tbreak;\n\t\tcase KEY_LEFT:\n\t\t\tj = i - 1;\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\tcase KEY_UP:\n\t\t\tif (c == KEY_DOWN) {\n\t\t\t\tj = i;\n\t\t\t\twhile (j < (ssize_t)f.nmemb &&\n\t\t\t\t    f.v[i].lo == f.v[j].lo)\n\t\t\t\t\tj++;\n\t\t\t\tif (j == (ssize_t)f.nmemb)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tk = i;\n\t\t\t\twhile (k && f.v[i].lo == f.v[k].lo)\n\t\t\t\t\tk--;\n\t\t\t\tj = k;\n\t\t\t\twhile (j && f.v[j - 1].lo == f.v[k].lo)\n\t\t\t\t\tj--;\n\t\t\t}\n\t\t\tfor (; fcmp(&f.v[i], &f.v[j]) < 0 &&\n\t\t\t    f.v[j].lo == f.v[j + 1].lo; j++)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tif (j >= 0 && j < (ssize_t)f.nmemb)\n\t\t\ti = j;\n\t}\n}\n\nstatic void\nusage(void)\n{\n\tfprintf(stderr, \"usage: yank [-1ilxv] [-d delim] [-g pattern] \"\n\t    \"[-- command [args]]\\n\");\n\texit(2);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tconst struct field *field;\n\tchar *pat;\n\tint one = 0;\n\tint rflags = REG_EXTENDED;\n\tint c, i;\n\n\tsetlocale(LC_CTYPE, \"\");\n\n#ifdef __OpenBSD__\n\tif (pledge(\"stdio tty proc exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n#endif\n\n\tpat = strtopat(\" \");\n\twhile ((c = getopt(argc, argv, \"1ilvxd:g:\")) != -1)\n\t\tswitch (c) {\n\t\tcase '1':\n\t\t\tone = 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tfree(pat);\n\t\t\tpat = strtopat(optarg);\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tfree(pat);\n\t\t\tif ((pat = strdup(optarg)) == NULL)\n\t\t\t\terr(1, NULL);\n\t\t\trflags |= REG_NEWLINE;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\trflags |= REG_ICASE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tfree(pat);\n\t\t\tpat = strtopat(\"\");\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tputs(\"yank \" VERSION);\n\t\t\texit(0);\n\t\tcase 'x':\n\t\t\ttty.ca = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\targc -= optind;\n\targv += optind;\n\n\tif (regcomp(&reg, pat, rflags) != 0)\n\t\terrx(1, \"invalid regular expression\");\n\n\t/* Ensure space for yank command and null terminator. */\n\tif ((yankargv = calloc(argc + 2, sizeof(char *))) == NULL)\n\t\terr(1, NULL);\n\tyankargv[0] = YANKCMD;\n\tfor (i = 0; i < argc; i++)\n\t\tyankargv[i] = argv[i];\n\n\tinput();\n\ttsetup();\n\tif (one && f.nmemb == 1)\n\t\tfield = &f.v[0];\n\telse\n\t\tfield = tmain();\n\ttend();\n\tif (field == NULL)\n\t\treturn 1;\n\tyank(in.v + field->so, field->eo - field->so + 1);\n\n\treturn 0;\n}\n"
        }
      ]
    }
  ]
}