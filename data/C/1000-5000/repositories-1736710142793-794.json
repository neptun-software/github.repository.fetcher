{
  "metadata": {
    "timestamp": 1736710142793,
    "page": 794,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "droe/sslsplit",
      "stars": 1775,
      "defaultBranch": "develop",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.078125,
          "content": ".gitattributes export-ignore\n.gitignore export-ignore\n.travis.yml export-ignore\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.44140625,
          "content": "/*.o\n/*.dSYM\n/sslsplit\n/sslsplit.test\n/sslsplit.1\n/sslsplit.conf\n/sslsplit.conf.5\n/extra/*.pyc\n/extra/engine/*.dylib\n/extra/engine/*.so\n/extra/pki/dh*.param\n/extra/pki/dsa.pem\n/extra/pki/dsa.crt\n/extra/pki/dsa.key\n/extra/pki/dsa.param\n/extra/pki/ec.pem\n/extra/pki/ec.crt\n/extra/pki/ec.key\n/extra/pki/pwd.key\n/extra/pki/rsa.pem\n/extra/pki/rsa.crt\n/extra/pki/rsa.key\n/extra/pki/server.pem\n/extra/pki/server.crt\n/extra/pki/server.key\n/extra/pki/targets/*\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 5.328125,
          "content": "language: c\nscript: make && make travis && ./sslsplit -V\nmatrix:\n  include:\n    - os: linux\n      compiler: gcc\n      env: SSL=ubuntu EVENT=ubuntu\n      before_install:\n        - sudo apt-get install -qq libssl-dev libevent-dev libnet1-dev libpcap-dev check\n    - os: linux\n      compiler: clang\n      env: SSL=ubuntu EVENT=ubuntu\n      before_install:\n        - sudo apt-get install -qq libssl-dev libevent-dev libnet1-dev libpcap-dev check\n    - os: linux\n      compiler: clang\n      env: FEATURES=-DWITHOUT_MIRROR SSL=ubuntu EVENT=ubuntu\n      before_install:\n        - sudo apt-get install -qq libssl-dev libevent-dev check\n    - os: linux\n      compiler: clang\n      env: SSL=openssl-0.9.8zh EVENT=libevent-2.0.22\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=openssl-1.0.0s EVENT=libevent-2.0.22\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=openssl-1.0.1u EVENT=libevent-2.0.22\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=openssl-1.0.2r EVENT=libevent-2.0.22\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=openssl-1.1.0j EVENT=libevent-2.1.11\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=openssl-1.1.1c EVENT=libevent-2.1.11\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=libressl-2.2.7 EVENT=libevent-2.0.22\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: linux\n      compiler: clang\n      env: SSL=libressl-2.7.4 EVENT=libevent-2.1.11\n      cache:\n        directories:\n          - $HOME/opt\n      before_install:\n        - sudo apt-get install -qq libnet1-dev libpcap-dev check\n      install:\n        - ./Mk/bin/install-opt.sh\n      before_script:\n        - export OPENSSL_BASE=\"$HOME/opt/$SSL\"\n        - export LIBEVENT_BASE=\"$HOME/opt/$EVENT\"\n        - export LD_LIBRARY_PATH=\"$HOME/opt/$SSL/lib\":\"$HOME/opt/$EVENT/lib\"\n    - os: osx\n      env: SSL=homebrew EVENT=homebrew\n      cache:\n        directories:\n          - /usr/local/Cellar/openssl\n          - /usr/local/opt/openssl\n          - /usr/local/Cellar/libevent\n          - /usr/local/opt/libevent\n          - /usr/local/Cellar/libnet\n          - /usr/local/opt/libnet\n          - /usr/local/Cellar/libpcap\n          - /usr/local/opt/libpcap\n          - /usr/local/Cellar/check\n          - /usr/local/opt/check\n      before_install:\n        - test -d /usr/local/opt/openssl/lib  || { rmdir /usr/local/opt/openssl; brew install openssl; }\n        - test -d /usr/local/opt/libevent/lib || { rmdir /usr/local/opt/libevent; brew install libevent; }\n        - test -d /usr/local/opt/libnet/lib   || { rmdir /usr/local/opt/libnet; brew install libnet; }\n        - test -d /usr/local/opt/libpcap/lib  || { rmdir /usr/local/opt/libpcap; brew install --build-from-source libpcap; }\n        - test -d /usr/local/opt/check/lib    || { rmdir /usr/local/opt/check; brew install check; }\n"
        },
        {
          "name": "AUTHORS.md",
          "type": "blob",
          "size": 1.7607421875,
          "content": "# Authors\n\nSSLsplit was written by\n[Daniel Roethlisberger](https://github.com/droe).\nSSLsplit is currently maintained by\n[Daniel Roethlisberger](https://github.com/droe) and\n[Soner Tari](https://github.com/sonertari).\n\nThe following individuals have contributed to the codebase by submitting\npatches or pull requests, in chronological order of their first contribution:\n\n-   Steve Wills ([swills](https://github.com/swills))\n-   Landon Fuller ([landonf](https://github.com/landonf))\n-   Wayne Jensen ([wjjensen](https://github.com/wjjensen))\n-   Rory McNamara ([psychomario](https://github.com/psychomario))\n-   Alexander Neumann ([fd0](https://github.com/fd0))\n-   Adam Jacob Muller ([AdamJacobMuller](https://github.com/AdamJacobMuller))\n-   Richard Poole ([RichardPoole42](https://github.com/RichardPoole42))\n-   Maciej Kotowicz ([mak](https://github.com/mak))\n-   Eun Soo Park ([eunsoopark](https://github.com/eunsoopark))\n-   Christian Groschupp ([cgroschupp](https://github.com/cgroschupp))\n-   Alexander Savchenkov ([antalos](https://github.com/antalos))\n-   Soner Tari ([sonertari](https://github.com/sonertari))\n-   Petr Vaněk ([arkamar](https://github.com/arkamar))\n-   Hilko Bengen ([hillu](https://github.com/hillu))\n-   Philip Duldig ([pduldig-at-tw](https://github.com/pduldig-at-tw))\n-   Levente Polyak ([anthraxx](https://github.com/anthraxx))\n-   Nick French ([naf419](https://github.com/naf419))\n-   Cihan Kömeçoğlu ([cihankom](https://github.com/cihankom))\n-   Sergey Pinaev (n/a)\n\nMany more individuals have contributed by reporting bugs or feature requests.\nSee [issue tracker on Github][1], `NEWS.md` and `git log` for details.\n\n[1]: https://github.com/droe/sslsplit/issues\n\nAll your contributions are greatly appreciated; without you, SSLsplit would not\nbe what it is today.\n\n"
        },
        {
          "name": "BSDmakefile",
          "type": "blob",
          "size": 0.0546875,
          "content": "all:\n\t@gmake $(.TARGETS)\n\n$(.TARGETS): all\n\n.PHONY: all\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 19.107421875,
          "content": "### Variable overrides\n\n# You can change many aspects of the build behaviour without modifying this\n# make file simply by setting environment variables.\n#\n# Dependencies and features are auto-detected, but can be overridden:\n#\n# OPENSSL_BASE  Prefix of OpenSSL library and headers to build against\n# LIBEVENT_BASE Prefix of libevent library and headers to build against\n# LIBPCAP_BASE  Prefix of libpcap library and headers to build against\n# LIBNET_BASE   Prefix of libnet library and headers to build against\n# CHECK_BASE    Prefix of check library and headers to build against (optional)\n# PKGCONFIG     Name/path of pkg-config program to use for auto-detection\n# PCFLAGS       Additional pkg-config flags\n# XNU_VERSION   Version of included XNU headers to build against (OS X only)\n# FEATURES      Enable optional or force-enable undetected features (see below)\n#\n# Where and how to install to:\n#\n# PREFIX        Prefix to install under (default /usr/local)\n# DESTDIR       Destination root under which prefix is located (default /)\n# BINDIR        Path to user executables (default $(PREFIX)/bin)\n# MANDIR        Path to man section dirs (default $(PREFIX)/share/man)\n# SYSCONFDIR    Path to system configuration (default $(PREFIX)/etc)\n# INSTALLUID    UID to use for installed files if installing as root\n# INSTALLGID    GID to use for installed files if installing as root\n#\n# Standard compiler variables are respected, e.g.:\n#\n# CC            Compiler, e.g. for cross-compiling, ccache or ccc-analyzer\n# CFLAGS        Additional compiler flags, e.g. optimization flags\n# CPPFLAGS      Additional pre-processor flags\n# LDFLAGS       Additional linker flags\n# LIBS          Additional libraries to link against\n# SOURCE_DATE_EPOCH     Set to epoch time to make the build reproducible\n#\n# On macOS, the following build environment variables are respected:\n#\n# DEVELOPER_DIR         Override Xcode Command Line Developer Tools directory\n# MACOSX_VERSION_MIN    Minimal version of macOS to target, e.g. 10.11\n# SDK                   SDK name to build against, e.g. macosx, macosx10.11\n#\n# Examples:\n#\n# Build against custom installed libraries under /opt:\n# % OPENSSL_BASE=/opt/openssl LIBEVENT_BASE=/opt/libevent make\n#\n# Create a statically linked binary:\n# % PCFLAGS='--static' CFLAGS='-static' LDFLAGS='-static' make\n#\n# Build against musl libc that needs an additional library for fts(3):\n# % LIBS='-lfts' make\n#\n# Build a macOS binary for El Capitan using the default SDK from Xcode 7.3.1:\n# % MACOSX_VERSION_MIN=10.11 DEVELOPER_DIR=/Applications/Xcode-7.3.1.app/Contents/Developer make\n\n\n### Mirroring\n\n# Define to disable support for mirroring connection content as emulated\n# packets to a network interface (-I/-T options).  Doing so will remove the\n# dependency on both libnet and libpcap.  Use this for constrained environments\n# or on platforms without usable libnet/libpcap.  Logging connection content to\n# PCAP files will remain fully functional (-X/-Y/-y options) as it does not\n# make use of libnet and libpcap.\n#FEATURES+=\t-DWITHOUT_MIRROR\n\n\n### OpenSSL tweaking\n\n# Define to enable support for SSLv2.\n# Default since 0.4.9 is to disable SSLv2 entirely even if OpenSSL supports it,\n# since there are servers that are not compatible with SSLv2 Client Hello\n# messages.  If you build in SSLv2 support, you can disable it at runtime using\n# -R ssl2 to get the same result as not building in SSLv2 support at all.\n#FEATURES+=\t-DWITH_SSLV2\n\n\n### Debugging\n\n# These flags are added to CFLAGS iff building from a git repo.\nDEBUG_CFLAGS?=\t-g\n#DEBUG_CFLAGS+=\t-Werror\n\n# Define to remove false positives when debugging memory allocation.\n# Note that you probably want to build OpenSSL with -DPURIFY too.\n#FEATURES+=\t-DPURIFY\n\n# Define to add proxy state machine debugging; dump state in debug mode.\n#FEATURES+=\t-DDEBUG_PROXY\n\n# Define to add certificate debugging; dump all certificates in debug mode.\n#FEATURES+=\t-DDEBUG_CERTIFICATE\n\n# Define to add SSL session cache debugging; dump all sessions in debug mode.\n#FEATURES+=\t-DDEBUG_SESSION_CACHE\n\n# Define to add debugging of sslsplit's own ClientHello message parser.\n#FEATURES+=\t-DDEBUG_CLIENTHELLO_PARSER\n\n# Define to add thread debugging; dump thread state when choosing a thread.\n#FEATURES+=\t-DDEBUG_THREAD\n\n# Define to add privilege separation server event loop debugging.\n#FEATURES+=\t-DDEBUG_PRIVSEP_SERVER\n\n# Define to add diagnostic output for debugging option parsing.\n#FEATURES+=\t-DDEBUG_OPTS\n\n# When debugging OpenSSL related issues, make sure you use a debug build of\n# OpenSSL and consider enabling its debugging options -DREF_PRINT -DREF_CHECK\n# for debugging reference counting of OpenSSL objects and/or\n# -DPURIFY for using valgrind and similar tools.\n\n\n### Mac OS X header selection\n\n# First, try to use the exact XNU version reported by the kernel.  If they\n# are not available, try to look up a suitable XNU version that we have\n# headers for based on the OS X release reported by sw_vers.  Then as a last\n# resort, fall back to the latest version of XNU that we have headers for,\n# which may or may not work, depending on if there were API or ABI changes\n# in the DIOCNATLOOK ioctl interface to the NAT state table in the kernel.\n#\n# Note that you can override the XNU headers used by defining XNU_VERSION.\n\nifeq ($(shell uname),Darwin)\ninclude Mk/xcode.mk\nifneq ($(wildcard /usr/include/libproc.h),)\nFEATURES+=\t-DHAVE_DARWIN_LIBPROC\nendif\nOSX_VERSION=\t$(shell sw_vers -productVersion)\nifneq ($(XNU_VERSION),)\nXNU_METHOD=\toverride\nXNU_HAVE=\t$(shell uname -a|sed 's/^.*root:xnu-//g'|sed 's/~.*$$//')\nelse\nXNU_METHOD=\tuname\nXNU_VERSION=\t$(shell uname -a|sed 's/^.*root:xnu-//g'|sed 's/~.*$$//')\nXNU_HAVE:=\t$(XNU_VERSION)\nendif\nifeq ($(wildcard xnu/xnu-$(XNU_VERSION)),)\nXNU_METHOD=\tsw_vers\nXNU_VERSION=\t$(shell awk '/^XNU_RELS.*\\# $(OSX_VERSION)$$/ {print $$2}' xnu/GNUmakefile)\nendif\nifeq ($(wildcard xnu/xnu-$(XNU_VERSION)),)\nXNU_METHOD=\tfallback\nXNU_VERSION=\t$(shell awk '/^XNU_RELS/ {print $$2}' xnu/GNUmakefile|tail -1)\nendif\nifneq ($(wildcard xnu/xnu-$(XNU_VERSION)),)\nFEATURES+=\t-DHAVE_PF\nPKG_CPPFLAGS+=\t-I./xnu/xnu-$(XNU_VERSION)\nBUILD_INFO+=\tOSX:$(OSX_VERSION) XNU:$(XNU_VERSION):$(XNU_METHOD):$(XNU_HAVE)\nendif\nendif\n\n\n### Autodetected features\n\n# Autodetect pf\nifneq ($(wildcard /usr/include/net/pfvar.h),)\nFEATURES+=\t-DHAVE_PF\n# OpenBSD 4.7+ and FreeBSD 9.0+ also include ipfw-style divert-to in pf\nFEATURES+=\t-DHAVE_IPFW\nendif\n\n# Autodetect ipfw\nifneq ($(wildcard /sbin/ipfw),)\nFEATURES+=\t-DHAVE_IPFW\nendif\n\n# Autodetect ipfilter\nifneq ($(wildcard /usr/include/netinet/ip_fil.h),)\nFEATURES+=\t-DHAVE_IPFILTER\nendif\n\n# Autodetect netfilter\nifneq ($(wildcard /usr/include/linux/netfilter.h),)\nFEATURES+=\t-DHAVE_NETFILTER\nendif\n\n\n### Variables you might need to override\n\nPREFIX?=\t/usr/local\nBINDIR?=\t$(PREFIX)/bin\nSYSCONFDIR?=\t$(PREFIX)/etc\nMANDIR?=\t$(PREFIX)/share/man\n\nINSTALLUID?=\t0\nINSTALLGID?=\t0\nBINUID?=\t$(INSTALLUID)\nBINGID?=\t$(INSTALLGID)\nBINMODE?=\t0755\nCNFUID?=\t$(INSTALLUID)\nCNFGID?=\t$(INSTALLGID)\nCNFMODE?=\t0644\nMANUID?=\t$(INSTALLUID)\nMANGID?=\t$(INSTALLGID)\nMANMODE?=\t0644\nifeq ($(shell id -u),0)\nBINOWNERFLAGS?=\t-o $(BINUID) -g $(BINGID)\nCNFOWNERFLAGS?=\t-o $(CNFUID) -g $(CNFGID)\nMANOWNERFLAGS?=\t-o $(MANUID) -g $(MANGID)\nelse\nBINOWNERFLAGS?=\t\nCNFOWNERFLAGS?=\t\nMANOWNERFLAGS?=\t\nendif\n\nOPENSSL?=\topenssl\nPKGCONFIG?=\t$(shell command -v pkg-config||echo false)\nifeq ($(PKGCONFIG),false)\n$(warning pkg-config not found - guessing paths/flags for dependencies)\nendif\n\nBASENAME?=\tbasename\nCAT?=\t\tcat\nCHECKNR?=\tchecknr\nCUT?=\t\tcut\nGREP?=\t\tgrep\nINSTALL?=\tinstall\nMKDIR?=\t\tmkdir\nSED?=\t\tsed\nSORT?=\t\tsort\n\n\n### Variables only used for developer targets\n\nKHASH_URL?=\thttps://github.com/attractivechaos/klib/raw/master/khash.h\nGPGSIGNKEY?=\t0xE1520675375F5E35\n\nCPPCHECK?=\tcppcheck\nGPG?=\t\tgpg\nGIT?=\t\tgit\nWGET?=\t\twget\nDOCKER?=\tdocker\n\nBZIP2?=\t\tbzip2\nCOL?=\t\tcol\nLN?=\t\tln\nMAN?=\t\tman\nTAR?=\t\ttar\n\n\n### You should not need to touch anything below this line\n\nPKGLABEL:=\tSSLsplit\nPKGNAME:=\tsslsplit\nTARGET:=\t$(PKGNAME)\nSRCS:=\t\t$(filter-out $(wildcard *.t.c),$(wildcard *.c))\nHDRS:=\t\t$(wildcard *.h)\nOBJS:=\t\t$(SRCS:.c=.o)\nMKFS=\t\t$(wildcard GNUmakefile Mk/*.mk)\nFEATURES:=\t$(sort $(FEATURES))\n\nTSRCS:=\t\t$(wildcard *.t.c)\nTOBJS:=\t\t$(TSRCS:.t.c=.t.o)\nTOBJS+=\t\t$(filter-out main.o,$(OBJS))\n\ninclude Mk/buildinfo.mk\nVERSION:=\t$(BUILD_VERSION)\nifdef GITDIR\nCFLAGS+=\t$(DEBUG_CFLAGS)\nendif\n\n# Autodetect dependencies known to pkg-config\nPKGS:=\t\t\nifndef OPENSSL_BASE\nPKGS+=\t\t$(shell $(PKGCONFIG) $(PCFLAGS) --exists openssl \\\n\t\t&& echo openssl)\nendif\nifndef LIBEVENT_BASE\nPKGS+=\t\t$(shell $(PKGCONFIG) $(PCFLAGS) --exists libevent \\\n\t\t&& echo libevent)\nPKGS+=\t\t$(shell $(PKGCONFIG) $(PCFLAGS) --exists libevent_openssl \\\n\t\t&& echo libevent_openssl)\nPKGS+=\t\t$(shell $(PKGCONFIG) $(PCFLAGS) --exists libevent_pthreads \\\n\t\t&& echo libevent_pthreads)\nendif\nifneq ($(filter -DWITHOUT_MIRROR,$(FEATURES)),-DWITHOUT_MIRROR)\nifndef LIBPCAP_BASE\nPKGS+=\t\t$(shell $(PKGCONFIG) $(PCFLAGS) --exists libpcap \\\n\t\t&& echo libpcap)\nendif\nendif\nTPKGS:=\t\t\nifndef CHECK_BASE\nTPKGS+=\t\t$(shell $(PKGCONFIG) $(PCFLAGS) --exists check \\\n\t\t&& echo check)\nendif\n\n# Function: Generate list of base paths to search when locating packages\n# $1 packagename\nbases=\t\t/usr/local/opt/$(1) \\\n\t\t/opt/local \\\n\t\t/usr/local \\\n\t\t/usr\n\n# Function: Locate base path for a package we depend on\n# $1 packagename, $2 pattern suffix, $3 override path(s)\nlocate=\t\t$(subst /$(2),,$(word 1,$(wildcard \\\n\t\t$(addsuffix /$(2),$(if $(3),$(3),$(call bases,$(1)))))))\n\n# Autodetect dependencies not known to pkg-config\nifeq (,$(filter openssl,$(PKGS)))\nOPENSSL_FOUND:=\t$(call locate,openssl,include/openssl/ssl.h,$(OPENSSL_BASE))\nOPENSSL:=\t$(OPENSSL_FOUND)/bin/openssl\nifndef OPENSSL_FOUND\n$(error dependency 'OpenSSL' not found; \\\n\tinstall it or point OPENSSL_BASE to base path)\nendif\nendif\nifeq (,$(filter libevent,$(PKGS)))\nLIBEVENT_FOUND:=$(call locate,libevent,include/event2/event.h,$(LIBEVENT_BASE))\nifndef LIBEVENT_FOUND\n$(error dependency 'libevent 2.x' not found; \\\n\tinstall it or point LIBEVENT_BASE to base path)\nendif\nendif\nifneq ($(filter -DWITHOUT_MIRROR,$(FEATURES)),-DWITHOUT_MIRROR)\nifeq (,$(filter libpcap,$(PKGS)))\nLIBPCAP_FOUND:=\t$(call locate,libpcap,include/pcap.h,$(LIBPCAP_BASE))\nifndef LIBPCAP_FOUND\n$(error dependency 'libpcap' not found; \\\n\tinstall it or point LIBPCAP_BASE to base path)\nendif\nendif\nendif\nifeq (,$(filter check,$(TPKGS)))\nCHECK_FOUND:=\t$(call locate,check,include/check.h,$(CHECK_BASE))\nifndef CHECK_FOUND\nCHECK_MISSING:=\t1\nendif\nendif\n\n# Always search filesystem for libnet because libnet-config is unreliable\nifneq ($(filter -DWITHOUT_MIRROR,$(FEATURES)),-DWITHOUT_MIRROR)\nLIBNET_FOUND:=\t$(call locate,libnet,include/libnet-1.1/libnet.h,$(LIBNET_BASE))\nifdef LIBNET_FOUND\nLIBNET_FOUND_INC:=\t$(LIBNET_FOUND)/include/libnet-1.1\nelse\nLIBNET_FOUND:=\t$(call locate,libnet,include/libnet.h,$(LIBNET_BASE))\nLIBNET_FOUND_INC:=\t$(LIBNET_FOUND)/include\nendif\nifndef LIBNET_FOUND\n$(error dependency 'libnet' not found; \\\n\tinstall it or point LIBNET_BASE to base path)\nendif\nendif\n\nifdef OPENSSL_FOUND\nPKG_CPPFLAGS+=\t-I$(OPENSSL_FOUND)/include\nifneq ($(findstring openssl-3.,$(OPENSSL_FOUND)),openssl-3.)\nPKG_LDFLAGS+=\t-L$(OPENSSL_FOUND)/lib\nelse\nPKG_LDFLAGS+=\t-L$(OPENSSL_FOUND)/lib64\nendif\nPKG_LIBS+=\t-lssl -lcrypto -lz\nendif\nifdef LIBEVENT_FOUND\nPKG_CPPFLAGS+=\t-I$(LIBEVENT_FOUND)/include\nPKG_LDFLAGS+=\t-L$(LIBEVENT_FOUND)/lib\nPKG_LIBS+=\t-levent\nendif\nifeq (,$(filter libevent_openssl,$(PKGS)))\nPKG_LIBS+=\t-levent_openssl\nendif\nifeq (,$(filter libevent_pthreads,$(PKGS)))\nPKG_LIBS+=\t-levent_pthreads\nendif\nifneq ($(filter -DWITHOUT_MIRROR,$(FEATURES)),-DWITHOUT_MIRROR)\nifdef LIBNET_FOUND\nPKG_CPPFLAGS+=\t-I$(LIBNET_FOUND_INC)\nPKG_LDFLAGS+=\t-L$(LIBNET_FOUND)/lib\nPKG_LIBS+=\t-lnet\nendif\nifdef LIBPCAP_FOUND\nPKG_CPPFLAGS+=\t-I$(LIBPCAP_FOUND)/include\nPKG_LDFLAGS+=\t-L$(LIBPCAP_FOUND)/lib\nPKG_LIBS+=\t-lpcap\nendif\nendif\nifdef CHECK_FOUND\nTPKG_CPPFLAGS+=\t-I$(CHECK_FOUND)/include\nTPKG_LDFLAGS+=\t-L$(CHECK_FOUND)/lib\nTPKG_LIBS+=\t-lcheck\nendif\n\nifneq (,$(strip $(PKGS)))\nPKG_CFLAGS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --cflags-only-other $(PKGS))\nPKG_CPPFLAGS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --cflags-only-I $(PKGS))\nPKG_LDFLAGS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --libs-only-L \\\n\t\t--libs-only-other $(PKGS))\nPKG_LIBS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --libs-only-l $(PKGS))\nendif\nifneq (,$(strip $(TPKGS)))\nTPKG_CFLAGS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --cflags-only-other $(TPKGS))\nTPKG_CPPFLAGS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --cflags-only-I $(TPKGS))\nTPKG_LDFLAGS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --libs-only-L \\\n\t\t--libs-only-other $(TPKGS))\nTPKG_LIBS+=\t$(shell $(PKGCONFIG) $(PCFLAGS) --libs-only-l $(TPKGS))\nendif\n\nCPPDEFS+=\t-D_GNU_SOURCE \\\n\t\t-D\"PKGLABEL=\\\"$(PKGLABEL)\\\"\"\nCPPCHECKFLAGS+=\t$(CPPDEFS)\n\nifneq (ccc-analyzer,$(notdir $(CC)))\nPKG_CPPFLAGS:=\t$(subst -I,-isystem,$(PKG_CPPFLAGS))\nTPKG_CPPFLAGS:=\t$(subst -I,-isystem,$(TPKG_CPPFLAGS))\nendif\n\nCFLAGS+=\t$(PKG_CFLAGS) \\\n\t\t-std=c99 -Wall -Wextra -pedantic \\\n\t\t-D_FORTIFY_SOURCE=2 -fstack-protector-all\nCPPFLAGS+=\t$(PKG_CPPFLAGS) $(CPPDEFS) $(FEATURES)\nTCPPFLAGS+=\t$(TPKG_CPPFLAGS)\nLDFLAGS+=\t$(PKG_LDFLAGS)\nLIBS+=\t\t$(PKG_LIBS)\n\nifneq ($(shell uname),Darwin)\nCFLAGS+=\t-pthread\nLDFLAGS+=\t-pthread\nendif\n\n# _FORTIFY_SOURCE requires -O on Linux\nifeq ($(shell uname),Linux)\nifeq (,$(findstring -O,$(CFLAGS)))\nCFLAGS+=\t-O\nendif\nendif\n\nexport VERSION\nexport OPENSSL\nexport OPENSSL_BASE\nexport OPENSSL_FOUND\nexport MKDIR\nexport WGET\n\nifndef MAKE_RESTARTS\n$(info ------------------------------------------------------------------------------)\n$(info $(PKGLABEL) $(VERSION))\n$(info ------------------------------------------------------------------------------)\n$(info Report bugs at https://github.com/droe/sslsplit/issues/new)\n$(info Please supply this header for diagnostics when reporting build issues)\n$(info Before reporting bugs, make sure to try the latest develop branch first:)\n$(info % git clone -b develop https://github.com/droe/sslsplit.git)\n$(info ------------------------------------------------------------------------------)\n$(info Via pkg-config: $(strip $(PKGS) $(TPKGS)))\nifdef OPENSSL_FOUND\n$(info OPENSSL_BASE:   $(strip $(OPENSSL_FOUND)))\nendif\nifdef LIBEVENT_FOUND\n$(info LIBEVENT_BASE:  $(strip $(LIBEVENT_FOUND)))\nendif\nifdef LIBPCAP_FOUND\n$(info LIBPCAP_BASE:   $(strip $(LIBPCAP_FOUND)))\nendif\nifdef LIBNET_FOUND\n$(info LIBNET_BASE:    $(strip $(LIBNET_FOUND)))\nendif\nifdef CHECK_FOUND\n$(info CHECK_BASE:     $(strip $(CHECK_FOUND)))\nendif\n$(info Build options:  $(FEATURES))\n$(info Build info:     $(BUILD_INFO))\nifeq ($(shell uname),Darwin)\n$(info OSX_VERSION:    $(OSX_VERSION))\n$(info XNU_VERSION:    $(XNU_VERSION) ($(XNU_METHOD), have $(XNU_HAVE)))\nendif\n$(info uname -a:       $(shell uname -a))\n$(info ------------------------------------------------------------------------------)\nendif\n\nall: $(TARGET) $(TARGET).conf $(TARGET).1 $(TARGET).conf.5\n\n$(TARGET).test: $(TOBJS)\n\t$(CC) $(LDFLAGS) $(TPKG_LDFLAGS) -o $@ $^ $(LIBS) $(TPKG_LIBS)\n\n$(TARGET): $(OBJS)\n\t$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)\n\nbuild.o: CPPFLAGS+=$(BUILD_CPPFLAGS)\nbuild.o: build.c FORCE\n\n%.t.o: %.t.c $(HDRS) $(MKFS)\nifdef CHECK_MISSING\n\t$(error unit test dependency 'check' not found; \\\n\tinstall it or point CHECK_BASE to base path)\nendif\n\t$(CC) -c $(CPPFLAGS) $(TCPPFLAGS) $(CFLAGS) $(TPKG_CFLAGS) -o $@ \\\n\t\t-x c $<\n\n%.o: %.c $(HDRS) $(MKFS)\n\t$(CC) -c $(CPPFLAGS) $(CFLAGS) -o $@ $<\n\nbuildtest: TCPPFLAGS+=-D\"TEST_ZEROUSR=\\\"$(shell id -u -n root||echo 0)\\\"\"\nbuildtest: TCPPFLAGS+=-D\"TEST_ZEROGRP=\\\"$(shell id -g -n root||echo 0)\\\"\"\nbuildtest: $(TARGET).test\n\t$(MAKE) -C extra/engine\n\t$(MAKE) -C extra/pki testreqs\n\ntest: buildtest\n\t./$(TARGET).test\n\nsudotest: buildtest\n\tsudo ./$(TARGET).test\n\ntravis: TCPPFLAGS+=-DTRAVIS\ntravis: test\n\nclean:\n\t$(MAKE) -C extra/engine clean\n\t$(RM) -f $(TARGET) $(TARGET).test *.o .*.o *.core *~\n\t$(RM) -f $(TARGET).conf\n\t$(RM) -rf *.dSYM\n\nSUBSTITUTIONS:=\t-e 's,/usr/local/etc/sslsplit,$(SYSCONFDIR)/$(TARGET),' \\\n\t\t-e 's,@@VERSION@@,$(VERSION),' \\\n\t\t-e 's,@@DATE@@,$(BUILD_DATE),'\n\n$(TARGET).1: $(TARGET).1.in $(MKFS) FORCE\n\t$(SED) $(SUBSTITUTIONS) <$< >$@\n\n$(TARGET).conf: $(TARGET).conf.in $(MKFS) FORCE\n\t$(SED) $(SUBSTITUTIONS) <$< >$@\n\n$(TARGET).conf.5: $(TARGET).conf.5.in $(MKFS) FORCE\n\t$(SED) $(SUBSTITUTIONS) <$< >$@\n\ninstall: $(TARGET) $(TARGET).conf $(TARGET).1 $(TARGET).conf.5\n\ttest -d $(DESTDIR)$(BINDIR) || $(MKDIR) -p $(DESTDIR)$(BINDIR)\n\ttest -d $(DESTDIR)$(SYSCONFDIR)/$(TARGET) || \\\n\t\t$(MKDIR) -p $(DESTDIR)$(SYSCONFDIR)/$(TARGET)\n\ttest -d $(DESTDIR)$(MANDIR)/man1 || \\\n\t\t$(MKDIR) -p $(DESTDIR)$(MANDIR)/man1\n\ttest -d $(DESTDIR)$(MANDIR)/man5 || \\\n\t\t$(MKDIR) -p $(DESTDIR)$(MANDIR)/man5\n\t$(INSTALL) $(BINOWNERFLAGS) -m $(BINMODE) \\\n\t\t$(TARGET) $(DESTDIR)$(BINDIR)/\n\t$(INSTALL) $(CNFOWNERFLAGS) -m $(CNFMODE) \\\n\t\t$(TARGET).conf \\\n\t\t$(DESTDIR)$(SYSCONFDIR)/$(TARGET)/$(TARGET).conf.sample\n\t$(INSTALL) $(MANOWNERFLAGS) -m $(MANMODE) \\\n\t\t$(TARGET).1 $(DESTDIR)$(MANDIR)/man1/\n\t$(INSTALL) $(MANOWNERFLAGS) -m $(MANMODE) \\\n\t\t$(TARGET).conf.5 $(DESTDIR)$(MANDIR)/man5/\n\ndeinstall:\n\t$(RM) -f $(DESTDIR)$(BINDIR)/$(TARGET) \\\n\t\t$(DESTDIR)$(MANDIR)/man1/$(TARGET).1 \\\n\t\t$(DESTDIR)$(MANDIR)/man5/$(TARGET).conf.5\n\t$(RM) -rf $(DESTDIR)$(SYSCONFDIR)/$(TARGET)/\n\nifdef GITDIR\nlint:\n\t$(CPPCHECK) $(CPPCHECKFLAGS) --force --enable=all --error-exitcode=1 .\n\nmanlint: $(TARGET).1 $(TARGET).conf.5\n\t$(CHECKNR) $(TARGET).1\n\nmantest: $(TARGET).1 $(TARGET).conf.5\n\t$(RM) -f man1 man5\n\t$(LN) -sf . man1\n\t$(LN) -sf . man5\n\t$(MAN) -M . 1 $(TARGET)\n\t$(MAN) -M . 5 $(TARGET).conf\n\t$(RM) man1 man5\n\ncopyright: *.c *.h *.1.in *.5.in extra/*/*.c\n\tMk/bin/copyright.py $^\n\n$(PKGNAME)-$(VERSION).1.txt: $(TARGET).1\n\t$(RM) -f man1\n\t$(LN) -sf . man1\n\t$(MAN) -M . 1 $(TARGET) | $(COL) -b >$@\n\t$(RM) man1\n\n$(PKGNAME)-$(VERSION).conf.5.txt: $(TARGET).conf.5\n\t$(RM) -f man5\n\t$(LN) -sf . man5\n\t$(MAN) -M . 5 $(TARGET).conf | $(COL) -b >$@\n\t$(RM) man5\n\nman: $(PKGNAME)-$(VERSION).1.txt $(PKGNAME)-$(VERSION).conf.5.txt\n\nmanclean:\n\t$(RM) -f $(PKGNAME)-*.1.txt $(PKGNAME)-*.conf.5.txt\n\nfetchdeps:\n\t$(WGET) -O- $(KHASH_URL) >khash.h\n\t#$(RM) -rf xnu/xnu-*\n\t$(MAKE) -C xnu fetch\n\ndist: $(PKGNAME)-$(VERSION).tar.bz2 $(PKGNAME)-$(VERSION).tar.bz2.asc\n\n%.asc: %\n\t$(GPG) -u $(GPGSIGNKEY) --armor --output $@ --detach-sig $<\n\n$(PKGNAME)-$(VERSION).tar.bz2:\n\t$(MKDIR) -p $(PKGNAME)-$(VERSION)\n\techo $(VERSION) >$(PKGNAME)-$(VERSION)/VERSION\n\t$(OPENSSL) dgst -sha1 -r *.[hc] | $(SORT) -k 2 \\\n\t\t>$(PKGNAME)-$(VERSION)/HASHES\n\t$(GIT) archive --prefix=$(PKGNAME)-$(VERSION)/ HEAD \\\n\t\t>$(PKGNAME)-$(VERSION).tar\n\t$(TAR) -f $(PKGNAME)-$(VERSION).tar -r $(PKGNAME)-$(VERSION)/VERSION\n\t$(TAR) -f $(PKGNAME)-$(VERSION).tar -r $(PKGNAME)-$(VERSION)/HASHES\n\t$(BZIP2) <$(PKGNAME)-$(VERSION).tar >$(PKGNAME)-$(VERSION).tar.bz2\n\t$(RM) $(PKGNAME)-$(VERSION).tar\n\t$(RM) -r $(PKGNAME)-$(VERSION)\n\ndisttest: $(PKGNAME)-$(VERSION).tar.bz2 $(PKGNAME)-$(VERSION).tar.bz2.asc\n\t$(GPG) --verify $<.asc $<\n\t$(BZIP2) -d < $< | $(TAR) -x -f -\n\tcd $(PKGNAME)-$(VERSION) && $(MAKE) && $(MAKE) test && ./$(TARGET) -V\n\t$(RM) -r $(PKGNAME)-$(VERSION)\n\ndistclean:\n\t$(RM) -f $(PKGNAME)-*.tar.bz2*\n\nrealclean: distclean manclean clean\n\t$(MAKE) -C extra/pki clean\nendif\n\ndocker:\n\t$(DOCKER) build -f docker/sslsplit/Dockerfile --target builder -t sslsplit-builder:$(VERSION) .\n\t$(DOCKER) build -f docker/sslsplit/Dockerfile --target production -t sslsplit:$(VERSION) .\n\t$(DOCKER) run sslsplit:$(VERSION)\n\nFORCE:\n\n.PHONY: all config clean buildtest test sudotest travis lint \\\n        install deinstall copyright manlint mantest man manclean fetchdeps \\\n        dist disttest distclean realclean docker\n\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.322265625,
          "content": "BSD 2-Clause License\n\nCopyright (c) 2009-2019, Daniel Roethlisberger and contributors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "LICENSE.contrib",
          "type": "blob",
          "size": 0.6123046875,
          "content": "By contributing to the software, the contributor releases their contribution\nunder the copyright and license terms of this software.  While contributors\nretain copyright to their contributions, they grant the main copyright holder\nof the software the irrevocable, transferable right to relicense the software\nas a whole or in part, including their contributions, under different open\nsource licenses than the one currently used.\n\nThird-party components included as documented in `LICENSE.third` and the\nrespective source files do not constitute contribution in this sense and retain\ntheir original copyright and license terms.\n"
        },
        {
          "name": "LICENSE.third",
          "type": "blob",
          "size": 0.7099609375,
          "content": "The software includes the following third-party source code components with\ndifferent copyright and license terms:\n\nkhash.h:\n\n    Copyright (c) 2008, 2009, 2011, Attractive Chaos.\n    Licensed under the MIT license.\n    https://github.com/attractivechaos/klib\n\nxnu/xnu-*:\n\n    Copyright (c) 1988-2017, Apple Inc. and original copyright holders.\n    Licensed under the APSL.\n    https://opensource.apple.com/\n\nextra/log*.py:\n\n    Copyright (C) 2015, Maciej Kotowicz and Daniel Roethlisberger.\n    Licensed under a 2-clause BSD license.\n\nMk/xcode.mk:\n\n    Copyright (c) Daniel Roethlisberger.\n    Released under the Unlicense.\n    https://github.com/droe/example.kext\n\nSee the respective source and/or license files for details.\n"
        },
        {
          "name": "Mk",
          "type": "tree",
          "content": null
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 13.3671875,
          "content": "\n### SSLsplit develop\n\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.5.5 2019-08-30\n\n-   Add -A option for specifying a default leaf certificate instead of\n    generating it on the fly (issue #139).\n-   Rename the following config file options for clarity and consistency:\n    -   LeafCerts to LeafKey\n    -   TargetCertDir to LeafCertDir\n    -   CRL to LeafCRLURL\n    The old syntax is still accepted for backwards compatibility.\n-   Increase the default RSA leaf key size to 2048 bits and force an OpenSSL\n    security level of 0 in order to maximize interoperability in the default\n    configuration.  OpenSSL with a security level of 2 or higher was rejecting\n    our old default leaf key size of 1024 bits (issue #248).\n-   Propagate the exit status of the privsep child process to the parent\n    process and use 128+signal convention (issue #252).\n-   Fix unexpected connection termination for certificates without a subject\n    common name.\n-   Fix TCP ports in packet mirroring mode (issue #247).\n-   Fix certificate loading with LibreSSL 2.9.2 and later.\n-   Fix MANDIR make variable semantics to GNU standards and introduce\n    BINDIR and SYSCONFDIR in order to allow better control over where files are\n    installed by the install target (pull request #255 by @arkamar and\n    follow-up work).  Also fixes the sample config file to be installed to\n    $(SYSCONFDIR)/sslsplit/ instead of $(PREFIX)/sslsplit/ by default.\n-   No longer create /var/log/sslsplit and /var/run/sslsplit directories as\n    part of `make install` (issue #251).\n-   Add XNU headers for macOS Mojave 10.14.1 to 10.14.3.\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.5.4 2018-10-29\n\nThis release includes work sponsored by HackerOne.\n\n-   Add PCAP content log modes (-X, -Y, -y) and a packet mirroring content log\n    mode (-T, -I) to encapsulate decrypted traffic segments in emulated TCP, IP\n    and Ethernet headers and write the result to PCAP files or send it to a\n    packet capture host on the local network segment (issue #215, based on pull\n    req #149 by @cihankom).\n-   Suppress Expect-CT header in order to avoid Certificate Transparency log\n    lookup failures (issue #205).\n-   Add -x option for activating an OpenSSL engine (issue #204, pull req #206).\n-   Add -f option for loading configuration from file, including a new manual\n    page, sslsplit.conf(5) (pull req #193).\n-   Bypass privilege separation overhead for when privileges are not actually\n    dropped; this allows the use of `-u root` to actively prevent privilege\n    separation and remove the associated IPC overhead (issue #222).\n-   Add `sudotest` target for optional unit tests which require privileges to\n    run successfully.\n-   Fix crash when using LibreSSL (pull req #207).\n-   Add XNU headers for macOS High Sierra 10.13.1 to 10.13.6.\n-   Release sig PGP/GPG key rollover from 0xB5D3397E to 0xE1520675375F5E35.\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.5.3 2018-07-20\n\n-   Add -a and -b for initial basic client certificate support (pull req #194\n    by @naf419, issue #46).\n-   Respect `SOURCE_DATE_EPOCH` for reproducible builds (pull req #192 by\n    @anthraxx).\n-   Sign using SHA-256 instead of SHA-1 when key type of server and key type\n    of used CA certificate differ (issue #189).\n-   Fix keyUsage to match the type of leaf key used instead of copying from\n    upstream certificate (issue #195).\n-   Fix build with OpenSSL 1.1.1 (pull req #186 by @sonertari, issue #183).\n-   Fix build on FreeBSD 12 (patch-proc.c r436571 from FreeBSD ports).\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.5.2 2018-02-10\n\n-   Add support for SSLv2 ClientHello handshake format for SSLv3/TLS\n    connections and while there, essentially fixing autossl for clients using\n    SSLv2 ClientHello handshake format with SSLv3/TLS (#185).\n-   Suppress Upgrade header in order to prevent upgrading connections to\n    WebSockets or HTTP/2 (#91).\n-   Add -M for writing an SSLKEYLOGFILE compatible log file (issue #184).\n-   Fix error handling for Darwin libproc functions (-i).\n-   Fix session cache misses and failed unit tests on MIPS by fixing undefined\n    behaviour in session cache hash functions (Debian #848919 and #851271).\n-   Synthesize MAC addresses to avoid the requirement for root privileges and\n    waiting for ARP timeouts on some platforms in log2pcap.py (issue #169).\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.5.1 2018-01-14\n\n-   Dump master key in NSS key log format in debug mode, allowing decryption of\n    SSL connections using Wireshark (issue #121).\n-   Add support for DSA and ECDSA certificates using hash algorithms other than\n    SHA-1.\n-   Copy basicConstraints, keyUsage and extendedKeyUsage X509v3 extensions from\n    the original certificate and only generate them anew if they were not\n    present (issue #73).\n-   Add -q to set the CRL distribution point on all forged certificates\n    (pull req #159 by @antalos).\n-   Add IPv6 support to netfilter NAT engine (pull req #179 by @armakar).\n-   Extend -L content logging with EOF message to allow log parsers to figure\n    out when a connection ends (issue #128 by @mattes).  Note that log parsers\n    need to be adjusted to handle the new EOF message.\n-   Fix potential segfaults in src.bev/dst.bev (pull req #174 by @sonertari).\n-   Fix SSL connections that result from autossl to shutdown cleanly.\n-   Fix data processing when EOF is received before all incoming data has been\n    processed.\n-   Fix multiple signal handling issues in the privilege separation parent\n    which led to the parent process being killed ungracefully or being stuck\n    in wait() while still having signals queued up for forwarding to the child\n    process (issue #137).\n-   No longer assume an out of memory condition when a certificate contains\n    neither a CN nor a subjectAltName extension.\n-   Fix parallel make build (-j) for the test target (issue #140).\n-   Do not set owner and group if install target is called by unprivileged\n    user (pull req #141 by @cgroschupp).\n-   Fix build with OpenSSL 1.1.0 and later (pull req #154 by @hillu, #156 by\n    @pduldig-at-tw and issue #148).\n-   Add XNU headers for Mac OS X El Capitan 10.11.3 to 10.11.6, Sierra 10.12\n    to 10.12.6 and High Sierra 10.13; fix headers for Mac OS X 10.6 to 10.6.8.\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.5.0 2016-03-27\n\n-   Generically support STARTTLS through the new autossl proxyspec type that\n    upgrades a TCP connection to SSL/TLS when a ClientHello message is seen\n    (based on contribution by @RichardPoole42, pull req #87).\n-   Add separate src/dst host and port format specifiers %S, %p, %D and %q\n    to -F (pull req #74 by @AdamJacobMuller).\n-   Add options -w and -W to write generated leaf key, original and forged\n    certificates to disk (issue #67 by @psychomario).\n-   Add signal SIGUSR1 to re-open long-living -l/-L log files (issue #52).\n-   Add contributed -L log parsing scripts to extra/, including conversion to\n    PCAP using emulated IP and TCP headers (contributed by @mak, issue #27).\n-   Enable full-strength DHE and ECDHE by default, even for non-RSA leaf keys,\n    in order to avoid weak cipher warnings from browsers (issue #119).\n-   Use the same hash algorithm in signatures on forged certificates as the\n    original certificates use, instead of always using SHA-1.\n-   Removed all references to SHA-1 and small key RSA root CA keys from\n    documentation, examples and unit testing (issue #83).\n-   Introduce privilege separation architecture with privileged parent process\n    and unprivileged child process; all files are now opened with the\n    privileges of the user running SSLsplit; arguments to -S/-F are no longer\n    relative to the chroot() if used with the -j option.\n-   Filenames generated by -S and -F %d and %s changed from [host]:port to\n    host,port format and using underscore instead of colon in IPv6 addresses\n    in order to be NTFS clean (issue #69).\n-   Connect log format: host and port are now separate fields (issues #69 #74).\n-   Only initialize DNS subsystems when DNS lookups are actually needed by the\n    loaded proxy specifications (related to issue #104).\n-   Removed the non-standard word \"unmodified\" from the 2-clause BSD license.\n-   Warn when an OpenSSL version mismatch is detected (issue #88).\n-   Add XNU headers for OS X 10.11 El Capitan (issue #116).\n-   Fix EV_READ event re-enable bug that could lead to stalled connections\n    after throttling one direction (issue #109).\n-   Fix build with LibreSSL that lacks recent OpenSSL API additions.\n-   Fix build with OpenSSL versions that had SSLv3 support removed.\n-   Fix a rare segmentation fault upon receiving EOF on the outbound connection\n    while it has not been established yet (patch by @eunsoopark, issue #124).\n-   Fix SSL sessions to actually time out (patch by @eunsoopark, issue #115).\n-   Fix passthrough mode with -t and an empty directory (issue #92).\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.4.11 2015-03-16\n\n-   Fix loading of certificate chains with OpenSSL 1.0.2 (issue #79).\n-   Fix build on Mac OS X 10.10.2 by improving XNU header selection.\n\n\n### SSLsplit 0.4.10 2014-11-28\n\n-   Add option -F to log to separate files with printf-style % directives,\n    including process information for connections originating on the same\n    system when also using -i (pull reqs #36, #53, #54, #55 by @landonf).\n-   Add option -i to look up local process owning a connection for logging to\n    connection log; initial support on Mac OS X (by @landonf) and FreeBSD.\n-   Add option -r to force a specific SSL/TLS protocol version (issue #30).\n-   Add option -R to disable specific SSL/TLS protocol versions (issue #30).\n-   Disallow -u with pf proxyspecs on Mac OS X because Apple restricts\n    ioctl(/dev/pf) to root even on an fd initially opened by root (issue #65).\n-   Extend the certificate loading workaround for OpenSSL 1.0.0k and 1.0.1e\n    also to OpenSSL 0.9.8y; fixes cert loading crash due to bug in in OpenSSL.\n-   Extend Mac OS X pf support to Yosemite 10.10.1.\n-   Fix startup memory leaks in key/cert loader (pull req #56 by @wjjensen).\n-   Replace WANT_SSLV2_CLIENT and WANT_SSLV2_SERVER build knobs with a single\n    WITH_SSLV2 build knob.\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.4.9 2014-11-03\n\n-   Filter out HSTS response header to allow users to accept untrusted certs.\n-   Build without SSLv2 support by default (issue #26).\n-   Add primary group override (-m) when dropping privileges to an\n    unprivileged user (pull req #35 by @landonf).\n-   Support pf on Mac OS X 10.10 Yosemite and fix segmentation fault if\n    no NAT engine is available (pull req #32 by @landonf).\n-   Support DESTDIR and MANDIR in the build (pull req #34 by @swills).\n-   No longer chroot() to /var/empty by default if run by root, in order to\n    prevent breaking -S and sni proxyspecs (issue #21).\n-   Load -t certificates before dropping privileges (issues #19 and #20).\n-   Fix segmentation fault when using -t without a CA.\n-   Minor bugfixes and improvements.\n\n\n### SSLsplit 0.4.8 2014-01-15\n\n-   Filter out Alternate-Protocol response header to suppress SPDY/QUIC.\n-   Add experimental support for pf on Mac OS X 10.7+ (issue #15).\n-   Also build ipfw NAT engine if pf is detected to support pf divert-to.\n-   Unit tests (make test) no longer require Internet connectivity.\n-   Always use SSL_MODE_RELEASE_BUFFERS when available, which lowers the per\n    connection memory footprint significantly when using OpenSSL 1.0.0+.\n-   Fix memory corruption after the certificate in the cache had to be updated\n    during connection setup (issue #16).\n-   Fix file descriptor leak in passthrough mode (-P) after SSL errors.\n-   Fix OpenSSL data structures memory leak on certificate forgery.\n-   Fix segmentation fault on connections without SNI hostname, caused by\n    compilers optimizing away a NULL pointer check (issue #14).\n-   Fix thread manager startup failure under some circumstances (issue #17).\n-   Fix segmentation faults if thread manager fails to start (issue #10).\n\n\n### SSLsplit 0.4.7 2013-07-02\n\n-   Fix remaining threading issues in daemon mode.\n-   Filter HPKP header lines from HTTP(S) response headers in order to prevent\n    public key pinning based on draft-ietf-websec-key-pinning-06.\n-   Add HTTP status code and content-length to connection log.\n\n\n### SSLsplit 0.4.6 2013-06-03\n\n-   Fix fallback to passthrough (-P) when no matching certificate is found\n    for a connection (issue #9).\n-   Work around segmentation fault when loading certificates caused by a bug\n    in OpenSSL 1.0.0k and 1.0.1e.\n-   Fix binding to ports < 1024 with default settings (issue #8).\n\n\n### SSLsplit 0.4.5 2012-11-07\n\n-   Add support for 2048 and 4096 bit Diffie-Hellman.\n-   Fix syslog error messages (issue #6).\n-   Fix threading issues in daemon mode (issue #5).\n-   Fix address family check in netfilter NAT lookup (issue #4).\n-   Fix build on recent glibc systems (issue #2).\n-   Minor code and build process improvements.\n\n\n### SSLsplit 0.4.4 2012-05-11\n\n-   Improve OCSP denial for GET based OCSP requests.\n-   Default elliptic curve is now 'secp160r2' for better ECDH performance.\n-   More user-friendly handling of -c, -k and friends.\n-   Unit test source code renamed from *.t to *.t.c to prevent them from being\n    misdetected as perl instead of c by Github et al.\n-   Minor bugfixes.\n\n\n### SSLsplit 0.4.3 2012-04-22\n\n-   Add generic OCSP denial (-O).  OCSP requests transmitted over HTTP or HTTPS\n    are recognized and denied with OCSP tryLater(3) responses.\n-   Minor bugfixes.\n\n\n### SSLsplit 0.4.2 2012-04-13\n\nFirst public release.\n\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.205078125,
          "content": "# SSLsplit - transparent SSL/TLS interception\nhttps://www.roe.ch/SSLsplit\n\n[![Build Status](https://travis-ci.org/droe/sslsplit.svg)](https://travis-ci.org/droe/sslsplit)\n[![Gitter chat](https://badges.gitter.im/droe/sslsplit.png)](https://gitter.im/droe/sslsplit)\n\n## Overview\n\nSSLsplit is a tool for man-in-the-middle attacks against SSL/TLS encrypted\nnetwork connections.  It is intended to be useful for network forensics,\napplication security analysis and penetration testing.\n\nSSLsplit is designed to transparently terminate connections that are redirected\nto it using a network address translation engine.  SSLsplit then terminates\nSSL/TLS and initiates a new SSL/TLS connection to the original destination\naddress, while logging all data transmitted.  Besides NAT based operation,\nSSLsplit also supports static destinations and using the server name indicated\nby SNI as upstream destination.  SSLsplit is purely a transparent proxy and\ncannot act as a HTTP or SOCKS proxy configured in a browser.\n\nSSLsplit supports plain TCP, plain SSL, HTTP and HTTPS connections over both\nIPv4 and IPv6.  It also has the ability to dynamically upgrade plain TCP to SSL\nin order to generically support SMTP STARTTLS and similar upgrade mechanisms.\nSSLsplit fully supports Server Name Indication (SNI) and is able to work with\nRSA, DSA and ECDSA keys and DHE and ECDHE cipher suites.  Depending on the\nversion of OpenSSL built against, SSLsplit supports SSL 3.0, TLS 1.0, TLS 1.1\nand TLS 1.2, and optionally SSL 2.0 as well.\n\nFor SSL and HTTPS connections, SSLsplit generates and signs forged X509v3\ncertificates on-the-fly, mimicking the original server certificate's subject\nDN, subjectAltName extension and other characteristics.  SSLsplit has the\nability to use existing certificates of which the private key is available,\ninstead of generating forged ones.  SSLsplit supports NULL-prefix CN\ncertificates but otherwise does not implement exploits against specific\ncertificate verification vulnerabilities in SSL/TLS stacks.\n\nSSLsplit implements a number of defences against mechanisms which would\nnormally prevent MitM attacks or make them more difficult.  SSLsplit can deny\nOCSP requests in a generic way.  For HTTP and HTTPS connections, SSLsplit\nmangles headers to prevent server-instructed public key pinning (HPKP), avoid\nstrict transport security restrictions (HSTS), avoid Certificate Transparency\nenforcement (Expect-CT) and prevent switching to QUIC/SPDY, HTTP/2 or\nWebSockets (Upgrade, Alternate Protocols).  HTTP compression, encodings and\nkeep-alive are disabled to make the logs more readable.\n\nLogging options include traditional SSLsplit connect and content log files as\nwell as PCAP files and mirroring decrypted traffic to a network interface.\nAdditionally, certificates, master secrets and local process information can be\nlogged.\n\nSee the manual page sslsplit(1) for details on using SSLsplit and setting up\nthe various NAT engines.\n\n\n## Requirements\n\nSSLsplit depends on the OpenSSL, libevent 2.x, libpcap and libnet 1.1.x\nlibraries by default; libpcap and libnet are not needed if the mirroring\nfeature is omitted.  The build depends on GNU make and a POSIX.2 environment in\n`PATH`.  If available, pkg-config is used to locate and configure the\ndependencies.  The optional unit tests depend on the check library.\n\nSSLsplit currently supports the following operating systems and NAT mechanisms:\n\n-   FreeBSD: pf rdr and divert-to, ipfw fwd, ipfilter rdr\n-   OpenBSD: pf rdr-to and divert-to\n-   Linux: netfilter REDIRECT and TPROXY\n-   Mac OS X: pf rdr and ipfw fwd\n\nSupport for local process information (`-i`) is currently available on Mac OS X\nand FreeBSD.\n\nSSL/TLS features and compatibility greatly depend on the version of OpenSSL\nlinked against.  For optimal results, use a recent release of OpenSSL or\nLibreSSL.\n\n\n## Installation\n\nWith the requirements above available, run:\n\n    make\n    make test       # optional unit tests\n    make sudotest   # optional unit tests requiring privileges\n    make install    # optional install\n\nDependencies are autoconfigured using pkg-config.  If dependencies are not\npicked up and fixing `PKG_CONFIG_PATH` does not help, you can specify their\nrespective locations manually by setting `OPENSSL_BASE`, `LIBEVENT_BASE`,\n`LIBPCAP_BASE`, `LIBNET_BASE` and/or `CHECK_BASE` to the respective prefixes.\n\nYou can override the default install prefix (`/usr/local`) by setting `PREFIX`.\nFor more build options and build-time defaults see [`GNUmakefile`](GNUmakefile)\nand [`defaults.h`](defaults.h).\n\n\n## Documentation\n\nSee the manual pages `sslsplit(1)` and `sslsplit.conf(5)` for user\ndocumentation.  See [`NEWS.md`](NEWS.md) for release notes listing significant\nchanges between releases and [`SECURITY.md`](SECURITY.md) for information on\nsecurity vulnerability disclosure.\n\n\n## License\n\nSSLsplit is provided under a 2-clause BSD license.\nSSLsplit contains components licensed under the MIT and APSL licenses.\nSee [`LICENSE`](LICENSE), [`LICENSE.contrib`](LICENSE.contrib) and\n[`LICENSE.third`](LICENSE.third) as well as the respective source file headers\nfor details.\n\n\n## Credits\n\nSee [`AUTHORS.md`](AUTHORS.md) for the list of contributors.\n\nSSLsplit was inspired by `mitm-ssl` by Claes M. Nyberg and `sslsniff` by Moxie\nMarlinspike, but shares no source code with them.\n\n\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.498046875,
          "content": "# Security\n\nPlease report all security issues privately to\n[Daniel Roethlisberger](mailto:daniel@roe.ch).\n\nThe maintainers pledge to act on all reported security issues in a timely and\nprofessional manner, working with the reporter to reproduce, understand,\naddress and disclose vulnerabilities in a coordinated manner.  For critical\nvulnerabilities, we will prepare a bugfix release based on the last release,\nobtain CVE numbers and notify distributions shipping affected packages in\nadvance of the release.\n\n"
        },
        {
          "name": "attrib.h",
          "type": "blob",
          "size": 2.6875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef ATTRIB_H\n#define ATTRIB_H\n\n/*\n * GCC attributes and built-ins for improved compile-time error checking\n * and performance optimization.\n *\n * All of these are fully optional and are automatically disabled on non-GCC\n * and non-LLVM/clang compilers.\n */\n\n/*\n * Attributes.\n * These serve to improve the compiler warnings or optimizations.\n */\n\n#if !defined(__GNUC__) && !defined(__clang__)\n#define __attribute__(x) \n#endif\n\n#define UNUSED          __attribute__((unused))\n#define NORET           __attribute__((noreturn))\n#define PRINTF(f,a)     __attribute__((format(printf,(f),(a))))\n#define SCANF(f,a)      __attribute__((format(scanf,(f),(a))))\n#define WUNRES          __attribute__((warn_unused_result))\n#define MALLOC          __attribute__((malloc)) WUNRES\n#define NONNULL(...)    __attribute__((nonnull(__VA_ARGS__)))\n#define PURE            __attribute__((pure))\n\n/*\n * Branch prediction macros.\n * These serve to tell the compiler which of the branches is more likely.\n */\n\n#if !defined(__GNUC__) && !defined(__clang__)\n#define likely(expr)    (expr)\n#define unlikely(expr)  (expr)\n#else\n#define likely(expr)    __builtin_expect((expr), 1)\n#define unlikely(expr)  __builtin_expect((expr), 0)\n#endif\n\n#endif /* !ATTRIB_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "base64.c",
          "type": "blob",
          "size": 6.1181640625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Base64 encoding functions.\n */\n\n/*\n * Base64 decode insz bytes from in.\n * Returns allocated buffer containing outsz bytes.\n * The buffer is null-terminated, but the terminator is not included in outsz.\n * If in does not contain valid Base64 encoded data, returns NULL.\n * This is a very strict implementation.  Any characters not within the\n * Base64 alphabet are considered invalid, including newline and whitespace.\n */\nunsigned char *\nbase64_dec(const char *in, size_t insz, size_t *outsz)\n{\n\tstatic const int revalphabet[] = {\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*   0 ..   7 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*   8 ..  15 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  16 ..  23 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  24 ..  31 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  32 ..  39 */\n\t\t-1, -1, -1, 62, -1, -1, -1, 63,   /*  40 ..  47 */\n\t\t52, 53, 54, 55, 56, 57, 58, 59,   /*  48  .. 55 */\n\t\t60, 61, -1, -1, -1, -1, -1, -1,   /*  56 ..  63 */\n\t\t-1,  0,  1,  2,  3,  4,  5,  6,   /*  64 ..  71 */\n\t\t 7,  8,  9, 10, 11, 12, 13, 14,   /*  72 ..  79 */\n\t\t15, 16, 17, 18, 19, 20, 21, 22,   /*  80 ..  87 */\n\t\t23, 24, 25, -1, -1, -1, -1, -1,   /*  88 ..  95 */\n\t\t-1, 26, 27, 28, 29, 30, 31, 32,   /*  96 .. 103 */\n\t\t33, 34, 35, 36, 37, 38, 39, 40,   /* 104 .. 111 */\n\t\t41, 42, 43, 44, 45, 46, 47, 48,   /* 112 .. 119 */\n\t\t49, 50, 51, -1, -1, -1, -1, -1,   /* 120 .. 127 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 128 .. 135 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 136 .. 143 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 144 .. 151 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 152 .. 159 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 160 .. 167 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 168 .. 175 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 176 .. 183 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 184 .. 191 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 192 .. 199 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 200 .. 207 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 208 .. 215 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 216 .. 223 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 224 .. 231 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 232 .. 239 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 240 .. 247 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1 }; /* 248 .. 255 */\n\tsize_t i, o;\n\tint tmp, digit;\n\tunsigned char *out;\n\n\tif (insz % 4)\n\t\treturn NULL;\n\n\tif (insz == 0) {\n\t\t*outsz = 0;\n\t\treturn (unsigned char *)strdup(\"\");\n\t}\n\n\tif (in[insz - 2] == '=')\n\t\t*outsz = ((insz / 4) * 3) - 2;\n\telse if (in[insz - 1] == '=')\n\t\t*outsz = ((insz / 4) * 3) - 1;\n\telse\n\t\t*outsz = (insz / 4) * 3;\n\tif (!(out = malloc((*outsz) + 1))) {\n\t\t*outsz = 0;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0, o = 0; i < insz; i += 4, o += 3) {\n\t\tif ((digit = revalphabet[(unsigned char)in[i    ]]) == -1)\n\t\t\tgoto leave;\n\t\ttmp  = digit << 18;\n\t\tif ((digit = revalphabet[(unsigned char)in[i + 1]]) == -1)\n\t\t\tgoto leave;\n\t\ttmp += digit << 12;\n\t\tif ((digit = revalphabet[(unsigned char)in[i + 2]]) == -1) {\n\t\t\tif ((i == insz - 4) && (in[i + 2] == '='))\n\t\t\t\tdigit = 0;\n\t\t\telse\n\t\t\t\tgoto leave;\n\t\t}\n\t\ttmp += digit <<  6;\n\t\tif ((digit = revalphabet[(unsigned char)in[i + 3]]) == -1) {\n\t\t\tif ((i == insz - 4) && (in[i + 3] == '='))\n\t\t\t\tdigit = 0;\n\t\t\telse\n\t\t\t\tgoto leave;\n\t\t}\n\t\ttmp += digit;\n\t\t\tout[o    ] = (tmp >> 16) & 0xff;\n\t\tif (o + 1 < *outsz)\n\t\t\tout[o + 1] = (tmp >>  8) & 0xff;\n\t\tif (o + 2 < *outsz)\n\t\t\tout[o + 2] =  tmp        & 0xff;\n\t}\n\tout[*outsz] = '\\0';\n\treturn out;\n\nleave:\n\tfree(out);\n\treturn NULL;\n}\n\n/*\n * Base64 encode insz bytes from in.\n * Returns allocated buffer containing outsz bytes.\n * The buffer is null-terminated, but the terminator is not included in outsz.\n */\nchar *\nbase64_enc(const unsigned char *in, size_t insz, size_t *outsz)\n{\n\tstatic const int alphabet[] = {\n\t\t'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n\t\t'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n\t\t'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n\t\t'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n\t\t'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n\t\t'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n\t\t'w', 'x', 'y', 'z', '0', '1', '2', '3',\n\t\t'4', '5', '6', '7', '8', '9', '+', '/' };\n\tsize_t i, o;\n\tchar *out;\n\n\tif (insz == 0) {\n\t\t*outsz = 0;\n\t\treturn strdup(\"\");\n\t}\n\n\t*outsz = ((insz + 2) / 3) * 4;\n\tif (!(out = malloc((*outsz) + 1))) {\n\t\t*outsz = 0;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0, o = 0; i < insz; i += 3, o += 4) {\n\t\tint tmp;\n\t\t\ttmp  = in[i    ] << 16;\n\t\tif (i + 1 < insz)\n\t\t\ttmp += in[i + 1] <<  8;\n\t\tif (i + 2 < insz)\n\t\t\ttmp += in[i + 2];\n\t\tout[o    ] = alphabet[(tmp >> 18) & 0x3f];\n\t\tout[o + 1] = alphabet[(tmp >> 12) & 0x3f];\n\t\tout[o + 2] = alphabet[(tmp >>  6) & 0x3f];\n\t\tout[o + 3] = alphabet[ tmp        & 0x3f];\n\t\tif (i + 2 > insz)\n\t\t\tout[o + 2] = '=';\n\t\tif (i + 3 > insz)\n\t\t\tout[o + 3] = '=';\n\t}\n\tout[*outsz] = '\\0';\n\treturn out;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "base64.h",
          "type": "blob",
          "size": 1.7314453125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef BASE64_H\n#define BASE64_H\n\n#include \"attrib.h\"\n\n#include <stdlib.h>\n\nunsigned char * base64_dec(const char *, size_t, size_t *) NONNULL(1,3) MALLOC;\nchar * base64_enc(const unsigned char *, size_t, size_t *) NONNULL(1,3) MALLOC;\n\n#endif /* !BASE64_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "base64.t.c",
          "type": "blob",
          "size": 8.5205078125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"base64.h\"\n\n#include <string.h>\n\n#include <check.h>\n\nstatic const char *plain01 = \"any carnal pleasure.\";\nstatic const char *plain02 = \"any carnal pleasure\";\nstatic const char *plain03 = \"any carnal pleasur\";\nstatic const char *plain04 = \"any carnal pleasu\";\nstatic const char *plain05 = \"any carnal pleas\";\n\nstatic const char *coded01 = \"YW55IGNhcm5hbCBwbGVhc3VyZS4=\";\nstatic const char *coded02 = \"YW55IGNhcm5hbCBwbGVhc3VyZQ==\";\nstatic const char *coded03 = \"YW55IGNhcm5hbCBwbGVhc3Vy\";\nstatic const char *coded04 = \"YW55IGNhcm5hbCBwbGVhc3U=\";\nstatic const char *coded05 = \"YW55IGNhcm5hbCBwbGVhcw==\";\n\nstatic const char *coded06 = \"YW55=GNhcm5hbCBwbGVhcw==\";\nstatic const char *coded07 = \"YW55I=Nhcm5hbCBwbGVhcw==\";\nstatic const char *coded08 = \"YW55IG=hcm5hbCBwbGVhcw==\";\nstatic const char *coded09 = \"YW55IGN=cm5hbCBwbGVhcw==\";\nstatic const char *coded10 = \"YW55\\nGNhcm5hbCBwbGVhcw==\";\nstatic const char *coded11 = \"YW55 GNhcm5hbCBwbGVhcw==\";\nstatic const char *coded12 = \"YW55-GNhcm5hbCBwbGVhcw==\";\nstatic const char *coded13 = \"YW55%GNhcm5hbCBwbGVhcw==\";\nstatic const char *coded14 = \"YW55IGNhcm5hbCBwbGVhcw=\";\nstatic const char *coded15 = \"YW55IGNhcm5hbCBwbGVhcw\";\n\nSTART_TEST(base64_enc_01)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = base64_enc((unsigned char *)plain01, strlen(plain01), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(coded01), \"wrong length\");\n\tfail_unless(!memcmp(coded01, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_enc_02)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = base64_enc((unsigned char *)plain02, strlen(plain02), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(coded02), \"wrong length\");\n\tfail_unless(!memcmp(coded02, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_enc_03)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = base64_enc((unsigned char *)plain03, strlen(plain03), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(coded03), \"wrong length\");\n\tfail_unless(!memcmp(coded03, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_enc_04)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = base64_enc((unsigned char *)plain04, strlen(plain04), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(coded04), \"wrong length\");\n\tfail_unless(!memcmp(coded04, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_enc_05)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = base64_enc((unsigned char *)plain05, strlen(plain05), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(coded05), \"wrong length\");\n\tfail_unless(!memcmp(coded05, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_enc_06)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = base64_enc((unsigned char *)\"\", 0, &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(!sz, \"length not 0\");\n\tfail_unless(!buf[0], \"not empty string\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_dec_01)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded01, strlen(coded01), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain01), \"wrong length\");\n\tfail_unless(!memcmp(plain01, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_dec_02)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded02, strlen(coded02), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain02), \"wrong length\");\n\tfail_unless(!memcmp(plain02, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_dec_03)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded03, strlen(coded03), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain03), \"wrong length\");\n\tfail_unless(!memcmp(plain03, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_dec_04)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded04, strlen(coded04), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain04), \"wrong length\");\n\tfail_unless(!memcmp(plain04, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_dec_05)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded05, strlen(coded05), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain05), \"wrong length\");\n\tfail_unless(!memcmp(plain05, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(base64_dec_06)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded06, strlen(coded06), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_07)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded07, strlen(coded07), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_08)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded08, strlen(coded08), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_09)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded09, strlen(coded09), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_10)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded10, strlen(coded10), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_11)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded11, strlen(coded11), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_12)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded12, strlen(coded12), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_13)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded13, strlen(coded13), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_14)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded14, strlen(coded14), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_15)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(coded15, strlen(coded15), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(base64_dec_16)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(\"\", 0, &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(!sz, \"length not 0\");\n\tfail_unless(!buf[0], \"not empty string\");\n\tfree(buf);\n}\nEND_TEST\n\nSuite *\nbase64_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"base64\");\n\n\ttc = tcase_create(\"base64_enc\");\n\ttcase_add_test(tc, base64_enc_01);\n\ttcase_add_test(tc, base64_enc_02);\n\ttcase_add_test(tc, base64_enc_03);\n\ttcase_add_test(tc, base64_enc_04);\n\ttcase_add_test(tc, base64_enc_05);\n\ttcase_add_test(tc, base64_enc_06);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"base64_dec\");\n\ttcase_add_test(tc, base64_dec_01);\n\ttcase_add_test(tc, base64_dec_02);\n\ttcase_add_test(tc, base64_dec_03);\n\ttcase_add_test(tc, base64_dec_04);\n\ttcase_add_test(tc, base64_dec_05);\n\ttcase_add_test(tc, base64_dec_06);\n\ttcase_add_test(tc, base64_dec_07);\n\ttcase_add_test(tc, base64_dec_08);\n\ttcase_add_test(tc, base64_dec_09);\n\ttcase_add_test(tc, base64_dec_10);\n\ttcase_add_test(tc, base64_dec_11);\n\ttcase_add_test(tc, base64_dec_12);\n\ttcase_add_test(tc, base64_dec_13);\n\ttcase_add_test(tc, base64_dec_14);\n\ttcase_add_test(tc, base64_dec_15);\n\ttcase_add_test(tc, base64_dec_16);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "build.c",
          "type": "blob",
          "size": 1.783203125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"build.h\"\n\n/*\n * Volatile build-time information which can change between make runs.\n */\n\nconst char *build_pkgname  = BUILD_PKGNAME;\nconst char *build_version  = BUILD_VERSION;\nconst char *build_date     = BUILD_DATE;\nconst char *build_info     = BUILD_INFO;\nconst char *build_features = BUILD_FEATURES;\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "build.h",
          "type": "blob",
          "size": 1.6923828125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef BUILD_H\n#define BUILD_H\n\nextern const char *build_pkgname;\nextern const char *build_version;\nextern const char *build_date;\nextern const char *build_info;\nextern const char *build_features;\n\n#endif /* !BUILD_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cache.c",
          "type": "blob",
          "size": 4.03515625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cache.h\"\n\n#include \"log.h\"\n#include \"khash.h\"\n\n#include <pthread.h>\n\n/*\n * Generic, thread-safe cache.\n */\n\n/*\n * Create a new cache based on the initializer callback init_cb.\n */\ncache_t *\ncache_new(cache_init_cb_t init_cb)\n{\n\tcache_t *cache;\n\n\tif (!(cache = malloc(sizeof(cache_t))))\n\t\treturn NULL;\n\n\tif (pthread_mutex_init(&cache->mutex, NULL)) {\n\t\tfree(cache);\n\t\treturn NULL;\n\t}\n\n\tinit_cb(cache);\n\treturn cache;\n}\n\n/*\n * Reinitialize cache after fork().  Returns 0 on success, -1 on failure.\n */\nint\ncache_reinit(cache_t *cache)\n{\n\treturn pthread_mutex_init(&cache->mutex, NULL) ? -1 : 0;\n}\n\n/*\n * Free a cache and all associated resources.\n * This function is not thread-safe.\n */\nvoid\ncache_free(cache_t *cache)\n{\n\tkhiter_t it;\n\n\tfor (it = cache->begin_cb(); it != cache->end_cb(); it++) {\n\t\tif (cache->exist_cb(it)) {\n\t\t\tcache->free_key_cb(cache->get_key_cb(it));\n\t\t\tcache->free_val_cb(cache->get_val_cb(it));\n\t\t}\n\t}\n\tcache->fini_cb();\n\tpthread_mutex_destroy(&cache->mutex);\n\tfree(cache);\n}\n\nvoid\ncache_gc(cache_t *cache)\n{\n\tkhiter_t it;\n\tcache_val_t val;\n\n\tpthread_mutex_lock(&cache->mutex);\n\tfor (it = cache->begin_cb(); it != cache->end_cb(); it++) {\n\t\tif (cache->exist_cb(it)) {\n\t\t\tval = cache->get_val_cb(it);\n\t\t\tif (!cache->unpackverify_val_cb(val, 0)) {\n\t\t\t\tcache->free_val_cb(val);\n\t\t\t\tcache->free_key_cb(cache->get_key_cb(it));\n\t\t\t\tcache->del_cb(it);\n\t\t\t}\n\t\t}\n\t}\n\tpthread_mutex_unlock(&cache->mutex);\n}\n\ncache_val_t\ncache_get(cache_t *cache, cache_key_t key)\n{\n\tcache_val_t rval = NULL;\n\tkhiter_t it;\n\n\tif (!key)\n\t\treturn NULL;\n\n\tpthread_mutex_lock(&cache->mutex);\n\tit = cache->get_cb(key);\n\tif (it != cache->end_cb()) {\n\t\tcache_val_t val;\n\t\tval = cache->get_val_cb(it);\n\t\tif (!(rval = cache->unpackverify_val_cb(val, 1))) {\n\t\t\tcache->free_val_cb(val);\n\t\t\tcache->free_key_cb(cache->get_key_cb(it));\n\t\t\tcache->del_cb(it);\n\t\t}\n\t}\n\tcache->free_key_cb(key);\n\tpthread_mutex_unlock(&cache->mutex);\n\treturn rval;\n}\n\nvoid\ncache_set(cache_t *cache, cache_key_t key, cache_val_t val)\n{\n\tkhiter_t it;\n\tint ret;\n\n\tif (!key || !val)\n\t\treturn;\n\n\tpthread_mutex_lock(&cache->mutex);\n\tit = cache->put_cb(key, &ret);\n\tif (!ret) {\n\t\tcache->free_key_cb(key);\n\t\tcache->free_val_cb(cache->get_val_cb(it));\n\t}\n\tcache->set_val_cb(it, val);\n\tpthread_mutex_unlock(&cache->mutex);\n}\n\nvoid\ncache_del(cache_t *cache, cache_key_t key)\n{\n\tkhiter_t it;\n\n\tpthread_mutex_lock(&cache->mutex);\n\tit = cache->get_cb(key);\n\tif (it != cache->end_cb()) {\n\t\tcache->free_val_cb(cache->get_val_cb(it));\n\t\tcache->free_key_cb(cache->get_key_cb(it));\n\t\tcache->del_cb(it);\n\t}\n\tcache->free_key_cb(key);\n\tpthread_mutex_unlock(&cache->mutex);\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cache.h",
          "type": "blob",
          "size": 3.189453125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CACHE_H\n#define CACHE_H\n\n#include \"attrib.h\"\n\n#include <pthread.h>\n\ntypedef void * cache_val_t;\ntypedef void * cache_key_t;\ntypedef unsigned int cache_iter_t; /* must match khiter_t */\n\ntypedef cache_iter_t (*cache_begin_cb_t)(void);\ntypedef cache_iter_t (*cache_end_cb_t)(void);\ntypedef int (*cache_exist_cb_t)(cache_iter_t);\ntypedef void (*cache_del_cb_t)(cache_iter_t);\ntypedef cache_iter_t (*cache_get_cb_t)(cache_key_t);\ntypedef cache_iter_t (*cache_put_cb_t)(cache_key_t, int *);\ntypedef void (*cache_free_key_cb_t)(cache_key_t);\ntypedef void (*cache_free_val_cb_t)(cache_val_t);\ntypedef cache_key_t (*cache_get_key_cb_t)(cache_iter_t);\ntypedef cache_val_t (*cache_get_val_cb_t)(cache_iter_t);\ntypedef void (*cache_set_val_cb_t)(cache_iter_t, cache_val_t);\ntypedef cache_val_t (*cache_unpackverify_val_cb_t)(cache_val_t, int);\ntypedef void (*cache_fini_cb_t)(void);\n\ntypedef struct cache {\n\tpthread_mutex_t mutex;\n\n\tcache_begin_cb_t begin_cb;\n\tcache_end_cb_t end_cb;\n\tcache_exist_cb_t exist_cb;\n\tcache_del_cb_t del_cb;\n\tcache_get_cb_t get_cb;\n\tcache_put_cb_t put_cb;\n\tcache_free_key_cb_t free_key_cb;\n\tcache_free_val_cb_t free_val_cb;\n\tcache_get_key_cb_t get_key_cb;\n\tcache_get_val_cb_t get_val_cb;\n\tcache_set_val_cb_t set_val_cb;\n\tcache_unpackverify_val_cb_t unpackverify_val_cb;\n\tcache_fini_cb_t fini_cb;\n} cache_t;\n\ntypedef void (*cache_init_cb_t)(struct cache *);\n\ncache_t * cache_new(cache_init_cb_t) MALLOC;\nint cache_reinit(cache_t *) NONNULL(1) WUNRES;\nvoid cache_free(cache_t *) NONNULL(1);\nvoid cache_gc(cache_t *) NONNULL(1);\ncache_val_t cache_get(cache_t *, cache_key_t) NONNULL(1) WUNRES;\nvoid cache_set(cache_t *, cache_key_t, cache_val_t) NONNULL(1);\nvoid cache_del(cache_t *, cache_key_t) NONNULL(1);\n\n#endif /* !CACHE_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachedsess.c",
          "type": "blob",
          "size": 5.7919921875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cachedsess.h\"\n\n#include \"dynbuf.h\"\n#include \"ssl.h\"\n#include \"khash.h\"\n\n#include <netinet/in.h>\n\n/*\n * Cache for outgoing dst connection SSL sessions.\n *\n * key: dynbuf_t *  original destination IP address, port and SNI string\n * val: dynbuf_t *  ASN.1 serialized SSL_SESSION\n */\n\nstatic inline khint_t\nkh_dynbuf_hash_func(dynbuf_t *b)\n{\n\tkhint_t *p = (khint_t *)b->buf;\n\tkhint_t h = 0;\n\tint rem;\n\n\tif ((rem = b->sz % sizeof(khint_t))) {\n\t\tmemcpy(&h, b->buf + b->sz - rem, rem);\n\t}\n\n\twhile (p < (khint_t*)(b->buf + b->sz - rem)) {\n\t\th ^= *p++;\n\t}\n\n\treturn h;\n}\n\n#define kh_dynbuf_hash_equal(a, b) \\\n        (((a)->sz == (b)->sz) && \\\n         (memcmp((a)->buf, (b)->buf, (a)->sz) == 0))\n\nKHASH_INIT(dynbufmap_t, dynbuf_t*, dynbuf_t*, 1, kh_dynbuf_hash_func,\n           kh_dynbuf_hash_equal)\n\nstatic khash_t(dynbufmap_t) *dstsessmap;\n\nstatic cache_iter_t\ncachedsess_begin_cb(void)\n{\n\treturn kh_begin(dstsessmap);\n}\n\nstatic cache_iter_t\ncachedsess_end_cb(void)\n{\n\treturn kh_end(dstsessmap);\n}\n\nstatic int\ncachedsess_exist_cb(cache_iter_t it)\n{\n\treturn kh_exist(dstsessmap, it);\n}\n\nstatic void\ncachedsess_del_cb(cache_iter_t it)\n{\n\tkh_del(dynbufmap_t, dstsessmap, it);\n}\n\nstatic cache_iter_t\ncachedsess_get_cb(cache_key_t key)\n{\n\treturn kh_get(dynbufmap_t, dstsessmap, key);\n}\n\nstatic cache_iter_t\ncachedsess_put_cb(cache_key_t key, int *ret)\n{\n\treturn kh_put(dynbufmap_t, dstsessmap, key, ret);\n}\n\nstatic void\ncachedsess_free_key_cb(cache_key_t key)\n{\n\tdynbuf_free(key);\n}\n\nstatic void\ncachedsess_free_val_cb(cache_val_t val)\n{\n\tdynbuf_free(val);\n}\n\nstatic cache_key_t\ncachedsess_get_key_cb(cache_iter_t it)\n{\n\treturn kh_key(dstsessmap, it);\n}\n\nstatic cache_val_t\ncachedsess_get_val_cb(cache_iter_t it)\n{\n\treturn kh_val(dstsessmap, it);\n}\n\nstatic void\ncachedsess_set_val_cb(cache_iter_t it, cache_val_t val)\n{\n\tkh_val(dstsessmap, it) = val;\n}\n\nstatic cache_val_t\ncachedsess_unpackverify_val_cb(cache_val_t val, int copy)\n{\n\tdynbuf_t *valbuf = val;\n\tSSL_SESSION *sess;\n\tconst unsigned char *p;\n\n\tp = (const unsigned char *)valbuf->buf;\n\tsess = d2i_SSL_SESSION(NULL, &p, valbuf->sz); /* increments p */\n\tif (!sess)\n\t\treturn NULL;\n\tif (!ssl_session_is_valid(sess)) {\n\t\tSSL_SESSION_free(sess);\n\t\treturn NULL;\n\t}\n\tif (copy)\n\t\treturn sess;\n\tSSL_SESSION_free(sess);\n\treturn ((void*)-1);\n}\n\nstatic void\ncachedsess_fini_cb(void)\n{\n\tkh_destroy(dynbufmap_t, dstsessmap);\n}\n\nvoid\ncachedsess_init_cb(cache_t *cache)\n{\n\tdstsessmap = kh_init(dynbufmap_t);\n\n\tcache->begin_cb                 = cachedsess_begin_cb;\n\tcache->end_cb                   = cachedsess_end_cb;\n\tcache->exist_cb                 = cachedsess_exist_cb;\n\tcache->del_cb                   = cachedsess_del_cb;\n\tcache->get_cb                   = cachedsess_get_cb;\n\tcache->put_cb                   = cachedsess_put_cb;\n\tcache->free_key_cb              = cachedsess_free_key_cb;\n\tcache->free_val_cb              = cachedsess_free_val_cb;\n\tcache->get_key_cb               = cachedsess_get_key_cb;\n\tcache->get_val_cb               = cachedsess_get_val_cb;\n\tcache->set_val_cb               = cachedsess_set_val_cb;\n\tcache->unpackverify_val_cb      = cachedsess_unpackverify_val_cb;\n\tcache->fini_cb                  = cachedsess_fini_cb;\n}\n\ncache_key_t\ncachedsess_mkkey(const struct sockaddr *addr, UNUSED const socklen_t addrlen,\n                 const char *sni)\n{\n\tdynbuf_t tmp, *db;\n\tshort port;\n\tsize_t snilen;\n\n\tswitch (((struct sockaddr_storage *)addr)->ss_family) {\n\t\tcase AF_INET:\n\t\t\ttmp.buf = (unsigned char *)\n\t\t\t          &((struct sockaddr_in*)addr)->sin_addr;\n\t\t\ttmp.sz = sizeof(struct in_addr);\n\t\t\tport = ((struct sockaddr_in*)addr)->sin_port;\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\ttmp.buf = (unsigned char *)\n\t\t\t          &((struct sockaddr_in6*)addr)->sin6_addr;\n\t\t\ttmp.sz = sizeof(struct in6_addr);\n\t\t\tport = ((struct sockaddr_in6*)addr)->sin6_port;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn NULL;\n\t}\n\n\tsnilen = sni ? strlen(sni) : 0;\n\tif (!(db = dynbuf_new_alloc(tmp.sz + sizeof(port) + snilen)))\n\t\treturn NULL;\n\tmemcpy(db->buf, tmp.buf, tmp.sz);\n\tmemcpy(db->buf + tmp.sz, (char*)&port, sizeof(port));\n\tif (sni)\n\t\tmemcpy(db->buf + tmp.sz + sizeof(port), sni, snilen);\n\treturn db;\n}\n\ncache_val_t\ncachedsess_mkval(SSL_SESSION *sess)\n{\n\tdynbuf_t *db;\n\tunsigned char *p;\n\tsize_t asn1sz;\n\n\tasn1sz = i2d_SSL_SESSION(sess, NULL);\n\tif (!asn1sz || !(db = dynbuf_new_alloc(asn1sz))) {\n\t\treturn NULL;\n\t}\n\tp = db->buf;\n\ti2d_SSL_SESSION(sess, &p); /* updates p */\n\treturn db;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachedsess.h",
          "type": "blob",
          "size": 1.900390625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CACHEDSESS_H\n#define CACHEDSESS_H\n\n#include \"cache.h\"\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <openssl/ssl.h>\n\nvoid cachedsess_init_cb(struct cache *) NONNULL(1);\n\ncache_key_t cachedsess_mkkey(const struct sockaddr *, const socklen_t,\n                             const char *) NONNULL(1) WUNRES;\ncache_val_t cachedsess_mkval(SSL_SESSION *) NONNULL(1) WUNRES;\n\n#endif /* !CACHEDSESS_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachedsess.t.c",
          "type": "blob",
          "size": 5.3837890625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"ssl.h\"\n#include \"cachemgr.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <netinet/in.h>\n#include <time.h>\n\n#include <check.h>\n\n#if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20501000L\n#define TMP_SESS_FILE \"extra/pki/session-libressl-2.5.0.pem\"\n#else\n#define TMP_SESS_FILE \"extra/pki/session.pem\"\n#endif\n\nstatic SSL_SESSION *\nssl_session_from_file(const char *filename)\n{\n\tSSL_SESSION *sess;\n\tFILE *f;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\tsess = PEM_read_SSL_SESSION(f, NULL, NULL, NULL);\n\tfclose(f);\n\t/* to avoid having to regenerate the session, just bump its time */\n\tSSL_SESSION_set_time(sess, time(NULL) - 1);\n\treturn sess;\n}\n\nstatic struct sockaddr_storage addr;\nstatic socklen_t addrlen;\nstatic char sni[] = \"daniel.roe.ch\";\n\nstatic void\ncachemgr_setup(void)\n{\n\tif ((ssl_init() == -1) || (cachemgr_preinit() == -1))\n\t\texit(EXIT_FAILURE);\n\taddrlen = sizeof(struct sockaddr_in);\n\tmemset(&addr, 0, addrlen);\n\taddr.ss_family = AF_INET;\n}\n\nstatic void\ncachemgr_teardown(void)\n{\n\tcachemgr_fini();\n\tssl_fini();\n}\n\nSTART_TEST(cache_dsess_01)\n{\n\tSSL_SESSION *s1, *s2;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tcachemgr_dsess_set((struct sockaddr*)&addr, addrlen, sni, s1);\n\ts2 = cachemgr_dsess_get((struct sockaddr*)&addr, addrlen, sni);\n\tfail_unless(!!s2, \"cache returned no session\");\n\tfail_unless(s2 != s1, \"cache returned same pointer\");\n\tSSL_SESSION_free(s1);\n\tSSL_SESSION_free(s2);\n}\nEND_TEST\n\nSTART_TEST(cache_dsess_02)\n{\n\tSSL_SESSION *s1, *s2;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\ts2 = cachemgr_dsess_get((struct sockaddr*)&addr, addrlen, sni);\n\tfail_unless(s2 == NULL, \"session was already in empty cache\");\n\tSSL_SESSION_free(s1);\n}\nEND_TEST\n\nSTART_TEST(cache_dsess_03)\n{\n\tSSL_SESSION *s1, *s2;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tcachemgr_dsess_set((struct sockaddr*)&addr, addrlen, sni, s1);\n\tcachemgr_dsess_del((struct sockaddr*)&addr, addrlen, sni);\n\ts2 = cachemgr_dsess_get((struct sockaddr*)&addr, addrlen, sni);\n\tfail_unless(s2 == NULL, \"cache returned deleted session\");\n\tSSL_SESSION_free(s1);\n}\nEND_TEST\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\nSTART_TEST(cache_dsess_04)\n{\n\tSSL_SESSION *s1, *s2;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tcachemgr_dsess_set((struct sockaddr*)&addr, addrlen, sni, s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\ts2 = cachemgr_dsess_get((struct sockaddr*)&addr, addrlen, sni);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tfail_unless(!!s2, \"cache returned no session\");\n\tfail_unless(s2->references == 1, \"refcount != 1\");\n\tcachemgr_dsess_set((struct sockaddr*)&addr, addrlen, sni, s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tcachemgr_dsess_del((struct sockaddr*)&addr, addrlen, sni);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tcachemgr_dsess_set((struct sockaddr*)&addr, addrlen, sni, s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tSSL_SESSION_free(s1);\n\tSSL_SESSION_free(s2);\n}\nEND_TEST\n#endif\n\nSuite *\ncachedsess_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"cachedsess\");\n\n\ttc = tcase_create(\"cache_dsess\");\n\ttcase_add_checked_fixture(tc, cachemgr_setup, cachemgr_teardown);\n\ttcase_add_test(tc, cache_dsess_01);\n\ttcase_add_test(tc, cache_dsess_02);\n\ttcase_add_test(tc, cache_dsess_03);\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\ttcase_add_test(tc, cache_dsess_04);\n#endif\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachefkcrt.c",
          "type": "blob",
          "size": 4.4404296875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cachefkcrt.h\"\n\n#include \"ssl.h\"\n#include \"khash.h\"\n\n/*\n * Cache for generated fake certificates.\n *\n * key: char[SSL_X509_FPRSZ]  fingerprint of original server cert\n * val: X509 *                generated fake certificate\n */\n\nstatic inline khint_t\nkh_x509fpr_hash_func(void *b)\n{\n\tkhint_t *p = (khint_t*)(((char*)b) + SSL_X509_FPRSZ);\n\tkhint_t h = 0;\n\n\t/* assumes fpr is uniformly distributed */\n\twhile (--p >= (khint_t*)b)\n\t\th ^= *p;\n\treturn h;\n}\n\n#define kh_x509fpr_hash_equal(a, b) \\\n        (memcmp((char*)(a), (char*)(b), SSL_X509_FPRSZ) == 0)\n\nKHASH_INIT(sha1map_t, void*, void*, 1, kh_x509fpr_hash_func,\n           kh_x509fpr_hash_equal)\n\nstatic khash_t(sha1map_t) *certmap;\n\nstatic cache_iter_t\ncachefkcrt_begin_cb(void)\n{\n\treturn kh_begin(certmap);\n}\n\nstatic cache_iter_t\ncachefkcrt_end_cb(void)\n{\n\treturn kh_end(certmap);\n}\n\nstatic int\ncachefkcrt_exist_cb(cache_iter_t it)\n{\n\treturn kh_exist(certmap, it);\n}\n\nstatic void\ncachefkcrt_del_cb(cache_iter_t it)\n{\n\tkh_del(sha1map_t, certmap, it);\n}\n\nstatic cache_iter_t\ncachefkcrt_get_cb(cache_key_t key)\n{\n\treturn kh_get(sha1map_t, certmap, key);\n}\n\nstatic cache_iter_t\ncachefkcrt_put_cb(cache_key_t key, int *ret)\n{\n\treturn kh_put(sha1map_t, certmap, key, ret);\n}\n\nstatic void\ncachefkcrt_free_key_cb(cache_key_t key)\n{\n\tfree(key);\n}\n\nstatic void\ncachefkcrt_free_val_cb(cache_val_t val)\n{\n\tX509_free(val);\n}\n\nstatic cache_key_t\ncachefkcrt_get_key_cb(cache_iter_t it)\n{\n\treturn kh_key(certmap, it);\n}\n\nstatic cache_val_t\ncachefkcrt_get_val_cb(cache_iter_t it)\n{\n\treturn kh_val(certmap, it);\n}\n\nstatic void\ncachefkcrt_set_val_cb(cache_iter_t it, cache_val_t val)\n{\n\tkh_val(certmap, it) = val;\n}\n\nstatic cache_val_t\ncachefkcrt_unpackverify_val_cb(cache_val_t val, int copy)\n{\n\tif (!ssl_x509_is_valid(val))\n\t\treturn NULL;\n\tif (copy) {\n\t\tssl_x509_refcount_inc(val);\n\t\treturn val;\n\t}\n\treturn ((void*)-1);\n}\n\nstatic void\ncachefkcrt_fini_cb(void)\n{\n\tkh_destroy(sha1map_t, certmap);\n}\n\nvoid\ncachefkcrt_init_cb(cache_t *cache)\n{\n\tcertmap = kh_init(sha1map_t);\n\n\tcache->begin_cb                 = cachefkcrt_begin_cb;\n\tcache->end_cb                   = cachefkcrt_end_cb;\n\tcache->exist_cb                 = cachefkcrt_exist_cb;\n\tcache->del_cb                   = cachefkcrt_del_cb;\n\tcache->get_cb                   = cachefkcrt_get_cb;\n\tcache->put_cb                   = cachefkcrt_put_cb;\n\tcache->free_key_cb              = cachefkcrt_free_key_cb;\n\tcache->free_val_cb              = cachefkcrt_free_val_cb;\n\tcache->get_key_cb               = cachefkcrt_get_key_cb;\n\tcache->get_val_cb               = cachefkcrt_get_val_cb;\n\tcache->set_val_cb               = cachefkcrt_set_val_cb;\n\tcache->unpackverify_val_cb      = cachefkcrt_unpackverify_val_cb;\n\tcache->fini_cb                  = cachefkcrt_fini_cb;\n}\n\ncache_key_t\ncachefkcrt_mkkey(X509 *keycrt)\n{\n\tunsigned char *fpr;\n\n\tif (!(fpr = malloc(SSL_X509_FPRSZ)))\n\t\treturn NULL;\n\tssl_x509_fingerprint_sha1(keycrt, fpr);\n\treturn fpr;\n}\n\ncache_val_t\ncachefkcrt_mkval(X509 *valcrt)\n{\n\tssl_x509_refcount_inc(valcrt);\n\treturn valcrt;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachefkcrt.h",
          "type": "blob",
          "size": 1.7724609375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CACHEFKCRT_H\n#define CACHEFKCRT_H\n\n#include \"cache.h\"\n#include \"attrib.h\"\n\n#include <openssl/x509.h>\n\nvoid cachefkcrt_init_cb(struct cache *) NONNULL(1);\n\ncache_key_t cachefkcrt_mkkey(X509 *) NONNULL(1) WUNRES;\ncache_val_t cachefkcrt_mkval(X509 *) NONNULL(1) WUNRES;\n\n#endif /* !CACHEFKCRT_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachefkcrt.t.c",
          "type": "blob",
          "size": 4.099609375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"ssl.h\"\n#include \"cachemgr.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <check.h>\n\n#define TESTCERT \"extra/pki/rsa.crt\"\n\nstatic void\ncachemgr_setup(void)\n{\n\tif ((ssl_init() == -1) || (cachemgr_preinit() == -1))\n\t\texit(EXIT_FAILURE);\n}\n\nstatic void\ncachemgr_teardown(void)\n{\n\tcachemgr_fini();\n\tssl_fini();\n}\n\nSTART_TEST(cache_fkcrt_01)\n{\n\tX509 *c1, *c2;\n\n\tc1 = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tcachemgr_fkcrt_set(c1, c1);\n\tc2 = cachemgr_fkcrt_get(c1);\n\tfail_unless(!!c2, \"cache did not return a certificate\");\n\tfail_unless(c2 == c1, \"cache did not return same pointer\");\n\tX509_free(c1);\n\tX509_free(c2);\n}\nEND_TEST\n\nSTART_TEST(cache_fkcrt_02)\n{\n\tX509 *c1, *c2;\n\n\tc1 = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tc2 = cachemgr_fkcrt_get(c1);\n\tfail_unless(c2 == NULL, \"certificate was already in empty cache\");\n\tX509_free(c1);\n}\nEND_TEST\n\nSTART_TEST(cache_fkcrt_03)\n{\n\tX509 *c1, *c2;\n\n\tc1 = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tcachemgr_fkcrt_set(c1, c1);\n\tcachemgr_fkcrt_del(c1);\n\tc2 = cachemgr_fkcrt_get(c1);\n\tfail_unless(c2 == NULL, \"cache returned deleted certificate\");\n\tX509_free(c1);\n}\nEND_TEST\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\nSTART_TEST(cache_fkcrt_04)\n{\n\tX509 *c1, *c2;\n\n\tc1 = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tfail_unless(c1->references == 1, \"refcount != 1\");\n\tcachemgr_fkcrt_set(c1, c1);\n\tfail_unless(c1->references == 2, \"refcount != 2\");\n\tc2 = cachemgr_fkcrt_get(c1);\n\tfail_unless(c1->references == 3, \"refcount != 3\");\n\tcachemgr_fkcrt_set(c1, c1);\n\tfail_unless(c1->references == 3, \"refcount != 3\");\n\tcachemgr_fkcrt_del(c1);\n\tfail_unless(c1->references == 2, \"refcount != 2\");\n\tcachemgr_fkcrt_set(c1, c1);\n\tfail_unless(c1->references == 3, \"refcount != 3\");\n\tX509_free(c1);\n\tfail_unless(c1->references == 2, \"refcount != 2\");\n\tcachemgr_fini();\n\tfail_unless(c1->references == 1, \"refcount != 1\");\n\tX509_free(c2);\n#if 0\n\t/* deliberate access of free'd X509* */\n\tfail_unless(c1->references == 0, \"refcount != 0\");\n#endif\n\tfail_unless(cachemgr_preinit() != -1, \"reinit\");\n}\nEND_TEST\n#endif\n\nSuite *\ncachefkcrt_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"cachefkcrt\");\n\n\ttc = tcase_create(\"cache_fkcrt\");\n\ttcase_add_checked_fixture(tc, cachemgr_setup, cachemgr_teardown);\n\ttcase_add_test(tc, cache_fkcrt_01);\n\ttcase_add_test(tc, cache_fkcrt_02);\n\ttcase_add_test(tc, cache_fkcrt_03);\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\ttcase_add_test(tc, cache_fkcrt_04);\n#endif\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachemgr.c",
          "type": "blob",
          "size": 4.5986328125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cachemgr.h\"\n\n#include \"cachefkcrt.h\"\n#include \"cachetgcrt.h\"\n#include \"cachessess.h\"\n#include \"cachedsess.h\"\n#include \"log.h\"\n#include \"attrib.h\"\n\n#include <string.h>\n#include <pthread.h>\n\n#include <netinet/in.h>\n\ncache_t *cachemgr_fkcrt;\ncache_t *cachemgr_tgcrt;\ncache_t *cachemgr_ssess;\ncache_t *cachemgr_dsess;\n\n/*\n * Garbage collector thread entry point.\n * Calls the _gc() method on the cache passed as argument, then returns.\n */\nstatic void *\ncachemgr_gc_thread(UNUSED void * arg)\n{\n\tcache_gc(arg);\n\treturn NULL;\n}\n\n/*\n * Pre-initialize the caches.\n * The caches may be initialized before or after libevent and OpenSSL.\n * Returns -1 on error, 0 on success.\n */\nint\ncachemgr_preinit(void)\n{\n\tif (!(cachemgr_fkcrt = cache_new(cachefkcrt_init_cb)))\n\t\tgoto out4;\n\tif (!(cachemgr_tgcrt = cache_new(cachetgcrt_init_cb)))\n\t\tgoto out3;\n\tif (!(cachemgr_ssess = cache_new(cachessess_init_cb)))\n\t\tgoto out2;\n\tif (!(cachemgr_dsess = cache_new(cachedsess_init_cb)))\n\t\tgoto out1;\n\treturn 0;\n\nout1:\n\tcache_free(cachemgr_ssess);\nout2:\n\tcache_free(cachemgr_tgcrt);\nout3:\n\tcache_free(cachemgr_fkcrt);\nout4:\n\treturn -1;\n}\n\n/*\n * Post-fork initialization.\n * Returns -1 on error, 0 on success.\n */\nint\ncachemgr_init(void)\n{\n\tif (cache_reinit(cachemgr_fkcrt))\n\t\treturn -1;\n\tif (cache_reinit(cachemgr_tgcrt))\n\t\treturn -1;\n\tif (cache_reinit(cachemgr_ssess))\n\t\treturn -1;\n\tif (cache_reinit(cachemgr_dsess))\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Cleanup the caches and free all memory.  Since OpenSSL certificates are\n * being freed, this must be done before calling the OpenSSL cleanup methods.\n * Also, it is not safe to call this while cachemgr_gc() is still running.\n */\nvoid\ncachemgr_fini(void)\n{\n\tcache_free(cachemgr_dsess);\n\tcache_free(cachemgr_ssess);\n\tcache_free(cachemgr_tgcrt);\n\tcache_free(cachemgr_fkcrt);\n}\n\n/*\n * Garbage collect all the cache contents; free's up resources occupied by\n * certificates and sessions which are no longer valid.\n * This function returns after the cleanup completed and all threads are\n * joined.\n */\nvoid\ncachemgr_gc(void)\n{\n\tpthread_t fkcrt_thr, dsess_thr, ssess_thr;\n\tint rv;\n\n\t/* the tgcrt cache does not need cleanup */\n\n\trv = pthread_create(&fkcrt_thr, NULL, cachemgr_gc_thread,\n\t                    cachemgr_fkcrt);\n\tif (rv) {\n\t\tlog_err_printf(\"cachemgr_gc: pthread_create failed: %s\\n\",\n\t\t               strerror(rv));\n\t}\n\trv = pthread_create(&ssess_thr, NULL, cachemgr_gc_thread,\n\t                    cachemgr_ssess);\n\tif (rv) {\n\t\tlog_err_printf(\"cachemgr_gc: pthread_create failed: %s\\n\",\n\t\t               strerror(rv));\n\t}\n\trv = pthread_create(&dsess_thr, NULL, cachemgr_gc_thread,\n\t                    cachemgr_dsess);\n\tif (rv) {\n\t\tlog_err_printf(\"cachemgr_gc: pthread_create failed: %s\\n\",\n\t\t               strerror(rv));\n\t}\n\n\trv = pthread_join(fkcrt_thr, NULL);\n\tif (rv) {\n\t\tlog_err_printf(\"cachemgr_gc: pthread_join failed: %s\\n\",\n\t\t               strerror(rv));\n\t}\n\trv = pthread_join(ssess_thr, NULL);\n\tif (rv) {\n\t\tlog_err_printf(\"cachemgr_gc: pthread_join failed: %s\\n\",\n\t\t               strerror(rv));\n\t}\n\trv = pthread_join(dsess_thr, NULL);\n\tif (rv) {\n\t\tlog_err_printf(\"cachemgr_gc: pthread_join failed: %s\\n\",\n\t\t               strerror(rv));\n\t}\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachemgr.h",
          "type": "blob",
          "size": 3.599609375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CACHEMGR_H\n#define CACHEMGR_H\n\n#include \"cache.h\"\n#include \"cachefkcrt.h\"\n#include \"cachetgcrt.h\"\n#include \"cachessess.h\"\n#include \"cachedsess.h\"\n\nextern cache_t *cachemgr_fkcrt;\nextern cache_t *cachemgr_tgcrt;\nextern cache_t *cachemgr_ssess;\nextern cache_t *cachemgr_dsess;\n\nint cachemgr_preinit(void) WUNRES;\nint cachemgr_init(void) WUNRES;\nvoid cachemgr_fini(void);\nvoid cachemgr_gc(void);\n\n#define cachemgr_fkcrt_get(key) \\\n        cache_get(cachemgr_fkcrt, cachefkcrt_mkkey(key))\n#define cachemgr_fkcrt_set(key, val) \\\n        cache_set(cachemgr_fkcrt, cachefkcrt_mkkey(key), cachefkcrt_mkval(val))\n#define cachemgr_fkcrt_del(key) \\\n        cache_del(cachemgr_fkcrt, cachefkcrt_mkkey(key))\n\n#define cachemgr_tgcrt_get(key) \\\n        cache_get(cachemgr_tgcrt, cachetgcrt_mkkey(key))\n#define cachemgr_tgcrt_set(key, val) \\\n        cache_set(cachemgr_tgcrt, cachetgcrt_mkkey(key), cachetgcrt_mkval(val))\n#define cachemgr_tgcrt_del(key) \\\n        cache_del(cachemgr_tgcrt, cachetgcrt_mkkey(key))\n\n#define cachemgr_ssess_get(key, keysz) \\\n        cache_get(cachemgr_ssess, cachessess_mkkey((key), (keysz)))\n#define cachemgr_ssess_set(val) \\\n        { \\\n                unsigned int len; \\\n                const unsigned char* id = SSL_SESSION_get_id(val, &len); \\\n                cache_set(cachemgr_ssess, \\\n                          cachessess_mkkey(id, len), \\\n                          cachessess_mkval(val));    \\\n        }\n#define cachemgr_ssess_del(val) \\\n        { \\\n                unsigned int len; \\\n                const unsigned char* id = SSL_SESSION_get_id(val, &len); \\\n                cache_del(cachemgr_ssess, \\\n                          cachessess_mkkey(id, len)); \\\n        }\n#define cachemgr_dsess_get(addr, addrlen, sni) \\\n        cache_get(cachemgr_dsess, cachedsess_mkkey((addr), (addrlen), (sni)))\n#define cachemgr_dsess_set(addr, addrlen, sni, val) \\\n        cache_set(cachemgr_dsess, cachedsess_mkkey((addr), (addrlen), (sni)), \\\n                                  cachedsess_mkval(val))\n#define cachemgr_dsess_del(addr, addrlen, sni) \\\n        cache_del(cachemgr_dsess, cachedsess_mkkey((addr), (addrlen), (sni)))\n\n#endif /* !CACHEMGR_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachemgr.t.c",
          "type": "blob",
          "size": 1.919921875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cachemgr.h\"\n#include \"khash.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <check.h>\n\nSTART_TEST(cache_types_01)\n{\n\tfail_unless(sizeof(cache_iter_t) == sizeof(khiter_t),\n\t            \"type mismatch: cache_iter_t != khiter_t\");\n}\nEND_TEST\n\nSuite *\ncachemgr_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"cachemgr\");\n\n\ttc = tcase_create(\"cache_types\");\n\ttcase_add_test(tc, cache_types_01);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachessess.c",
          "type": "blob",
          "size": 4.9228515625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cachessess.h\"\n\n#include \"dynbuf.h\"\n#include \"ssl.h\"\n#include \"khash.h\"\n\n/*\n * Cache for incoming src connection SSL sessions.\n *\n * key: dynbuf_t *  SSL session ID\n * val: dynbuf_t *  ASN.1 serialized SSL_SESSION\n */\n\nstatic inline khint_t\nkh_dynbuf_hash_func(dynbuf_t *b)\n{\n\tkhint_t *p = (khint_t *)b->buf;\n\tkhint_t h = 0;\n\tint rem;\n\n\tif ((rem = b->sz % sizeof(khint_t))) {\n\t\tmemcpy(&h, b->buf + b->sz - rem, rem);\n\t}\n\n\twhile (p < (khint_t*)(b->buf + b->sz - rem)) {\n\t\th ^= *p++;\n\t}\n\n\treturn h;\n}\n\n#define kh_dynbuf_hash_equal(a, b) \\\n        (((a)->sz == (b)->sz) && \\\n         (memcmp((a)->buf, (b)->buf, (a)->sz) == 0))\n\nKHASH_INIT(dynbufmap_t, dynbuf_t*, dynbuf_t*, 1, kh_dynbuf_hash_func,\n           kh_dynbuf_hash_equal)\n\nstatic khash_t(dynbufmap_t) *srcsessmap;\n\nstatic cache_iter_t\ncachessess_begin_cb(void)\n{\n\treturn kh_begin(srcsessmap);\n}\n\nstatic cache_iter_t\ncachessess_end_cb(void)\n{\n\treturn kh_end(srcsessmap);\n}\n\nstatic int\ncachessess_exist_cb(cache_iter_t it)\n{\n\treturn kh_exist(srcsessmap, it);\n}\n\nstatic void\ncachessess_del_cb(cache_iter_t it)\n{\n\tkh_del(dynbufmap_t, srcsessmap, it);\n}\n\nstatic cache_iter_t\ncachessess_get_cb(cache_key_t key)\n{\n\treturn kh_get(dynbufmap_t, srcsessmap, key);\n}\n\nstatic cache_iter_t\ncachessess_put_cb(cache_key_t key, int *ret)\n{\n\treturn kh_put(dynbufmap_t, srcsessmap, key, ret);\n}\n\nstatic void\ncachessess_free_key_cb(cache_key_t key)\n{\n\tdynbuf_free(key);\n}\n\nstatic void\ncachessess_free_val_cb(cache_val_t val)\n{\n\tdynbuf_free(val);\n}\n\nstatic cache_key_t\ncachessess_get_key_cb(cache_iter_t it)\n{\n\treturn kh_key(srcsessmap, it);\n}\n\nstatic cache_val_t\ncachessess_get_val_cb(cache_iter_t it)\n{\n\treturn kh_val(srcsessmap, it);\n}\n\nstatic void\ncachessess_set_val_cb(cache_iter_t it, cache_val_t val)\n{\n\tkh_val(srcsessmap, it) = val;\n}\n\nstatic cache_val_t\ncachessess_unpackverify_val_cb(cache_val_t val, int copy)\n{\n\tdynbuf_t *valbuf = val;\n\tSSL_SESSION *sess;\n\tconst unsigned char *p;\n\n\tp = (const unsigned char *)valbuf->buf;\n\tsess = d2i_SSL_SESSION(NULL, &p, valbuf->sz); /* increments p */\n\tif (!sess)\n\t\treturn NULL;\n\tif (!ssl_session_is_valid(sess)) {\n\t\tSSL_SESSION_free(sess);\n\t\treturn NULL;\n\t}\n\tif (copy)\n\t\treturn sess;\n\tSSL_SESSION_free(sess);\n\treturn ((void*)-1);\n}\n\nstatic void\ncachessess_fini_cb(void)\n{\n\tkh_destroy(dynbufmap_t, srcsessmap);\n}\n\nvoid\ncachessess_init_cb(cache_t *cache)\n{\n\tsrcsessmap = kh_init(dynbufmap_t);\n\n\tcache->begin_cb                 = cachessess_begin_cb;\n\tcache->end_cb                   = cachessess_end_cb;\n\tcache->exist_cb                 = cachessess_exist_cb;\n\tcache->del_cb                   = cachessess_del_cb;\n\tcache->get_cb                   = cachessess_get_cb;\n\tcache->put_cb                   = cachessess_put_cb;\n\tcache->free_key_cb              = cachessess_free_key_cb;\n\tcache->free_val_cb              = cachessess_free_val_cb;\n\tcache->get_key_cb               = cachessess_get_key_cb;\n\tcache->get_val_cb               = cachessess_get_val_cb;\n\tcache->set_val_cb               = cachessess_set_val_cb;\n\tcache->unpackverify_val_cb      = cachessess_unpackverify_val_cb;\n\tcache->fini_cb                  = cachessess_fini_cb;\n}\n\ncache_key_t\ncachessess_mkkey(const unsigned char *id, const size_t idlen)\n{\n\treturn dynbuf_new_copy(id, idlen);\n}\n\ncache_val_t\ncachessess_mkval(SSL_SESSION *sess)\n{\n\tdynbuf_t *db;\n\tunsigned char *p;\n\tsize_t asn1sz;\n\n\tasn1sz = i2d_SSL_SESSION(sess, NULL);\n\tif (!asn1sz || !(db = dynbuf_new_alloc(asn1sz))) {\n\t\treturn NULL;\n\t}\n\tp = db->buf;\n\ti2d_SSL_SESSION(sess, &p); /* updates p */\n\treturn db;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachessess.h",
          "type": "blob",
          "size": 1.818359375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CACHESSESS_H\n#define CACHESSESS_H\n\n#include \"cache.h\"\n#include \"attrib.h\"\n\n#include <openssl/ssl.h>\n\nvoid cachessess_init_cb(struct cache *) NONNULL(1);\n\ncache_key_t cachessess_mkkey(const unsigned char *, const size_t)\n            NONNULL(1) WUNRES;\ncache_val_t cachessess_mkval(SSL_SESSION *) NONNULL(1) WUNRES;\n\n#endif /* !CACHESSESS_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachessess.t.c",
          "type": "blob",
          "size": 5.205078125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"ssl.h\"\n#include \"cachemgr.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <time.h>\n\n#include <check.h>\n\n#if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20501000L\n#define TMP_SESS_FILE \"extra/pki/session-libressl-2.5.0.pem\"\n#else\n#define TMP_SESS_FILE \"extra/pki/session.pem\"\n#endif\n\n\nstatic SSL_SESSION *\nssl_session_from_file(const char *filename)\n{\n\tSSL_SESSION *sess;\n\tFILE *f;\n\n\tf = fopen(filename, \"r\");\n\tif (!f)\n\t\treturn NULL;\n\tsess = PEM_read_SSL_SESSION(f, NULL, NULL, NULL);\n\tfclose(f);\n\t/* to avoid having to regenerate the session, just bump its time */\n\tSSL_SESSION_set_time(sess, time(NULL) - 1);\n\treturn sess;\n}\n\nstatic void\ncachemgr_setup(void)\n{\n\tif ((ssl_init() == -1) || (cachemgr_preinit() == -1))\n\t\texit(EXIT_FAILURE);\n}\n\nstatic void\ncachemgr_teardown(void)\n{\n\tcachemgr_fini();\n\tssl_fini();\n}\n\nSTART_TEST(cache_ssess_01)\n{\n\tSSL_SESSION *s1, *s2;\n\tconst unsigned char* session_id;\n\tunsigned int len;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tcachemgr_ssess_set(s1);\n\tsession_id = SSL_SESSION_get_id(s1, &len);\n\ts2 = cachemgr_ssess_get(session_id, len);\n\tfail_unless(!!s2, \"cache returned no session\");\n\tfail_unless(s2 != s1, \"cache returned same pointer\");\n\tSSL_SESSION_free(s1);\n\tSSL_SESSION_free(s2);\n}\nEND_TEST\n\nSTART_TEST(cache_ssess_02)\n{\n\tSSL_SESSION *s1, *s2;\n\tconst unsigned char* session_id;\n\tunsigned int len;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tsession_id = SSL_SESSION_get_id(s1, &len);\n\ts2 = cachemgr_ssess_get(session_id, len);\n\tfail_unless(s2 == NULL, \"session was already in empty cache\");\n\tSSL_SESSION_free(s1);\n}\nEND_TEST\n\nSTART_TEST(cache_ssess_03)\n{\n\tSSL_SESSION *s1, *s2;\n\tconst unsigned char* session_id;\n\tunsigned int len;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tcachemgr_ssess_set(s1);\n\tcachemgr_ssess_del(s1);\n\tsession_id = SSL_SESSION_get_id(s1, &len);\n\ts2 = cachemgr_ssess_get(session_id, len);\n\tfail_unless(s2 == NULL, \"cache returned deleted session\");\n\tSSL_SESSION_free(s1);\n}\nEND_TEST\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\nSTART_TEST(cache_ssess_04)\n{\n\tSSL_SESSION *s1, *s2;\n\tconst unsigned char* session_id;\n\tunsigned int len;\n\n\ts1 = ssl_session_from_file(TMP_SESS_FILE);\n\tfail_unless(!!s1, \"creating session failed\");\n\tfail_unless(ssl_session_is_valid(s1), \"session invalid\");\n\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tcachemgr_ssess_set(s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tsession_id = SSL_SESSION_get_id(s1, &len);\n\ts2 = cachemgr_ssess_get(session_id, len);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tfail_unless(!!s2, \"cache returned no session\");\n\tfail_unless(s2->references == 1, \"refcount != 1\");\n\tcachemgr_ssess_set(s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tcachemgr_ssess_del(s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tcachemgr_ssess_set(s1);\n\tfail_unless(s1->references == 1, \"refcount != 1\");\n\tSSL_SESSION_free(s1);\n\tSSL_SESSION_free(s2);\n}\nEND_TEST\n#endif\n\nSuite *\ncachessess_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"cachessess\");\n\n\ttc = tcase_create(\"cache_ssess\");\n\ttcase_add_checked_fixture(tc, cachemgr_setup, cachemgr_teardown);\n\ttcase_add_test(tc, cache_ssess_01);\n\ttcase_add_test(tc, cache_ssess_02);\n\ttcase_add_test(tc, cache_ssess_03);\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\ttcase_add_test(tc, cache_ssess_04);\n#endif\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachetgcrt.c",
          "type": "blob",
          "size": 3.990234375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cachetgcrt.h\"\n\n#include \"ssl.h\"\n#include \"khash.h\"\n\n/*\n * Cache for target cert / chain / key tuples read from configured directory.\n * This cache does not need garbage collection.\n *\n * key: char *    common name\n * val: cert_t *  cert / chain / key tuple\n */\n\nKHASH_INIT(cstrmap_t, char*, void*, 1, kh_str_hash_func, kh_str_hash_equal)\n\nstatic khash_t(cstrmap_t) *certmap;\n\nstatic cache_iter_t\ncachetgcrt_begin_cb(void)\n{\n\treturn kh_begin(certmap);\n}\n\nstatic cache_iter_t\ncachetgcrt_end_cb(void)\n{\n\treturn kh_end(certmap);\n}\n\nstatic int\ncachetgcrt_exist_cb(cache_iter_t it)\n{\n\treturn kh_exist(certmap, it);\n}\n\nstatic void\ncachetgcrt_del_cb(cache_iter_t it)\n{\n\tkh_del(cstrmap_t, certmap, it);\n}\n\nstatic cache_iter_t\ncachetgcrt_get_cb(cache_key_t key)\n{\n\treturn kh_get(cstrmap_t, certmap, key);\n}\n\nstatic cache_iter_t\ncachetgcrt_put_cb(cache_key_t key, int *ret)\n{\n\treturn kh_put(cstrmap_t, certmap, key, ret);\n}\n\nstatic void\ncachetgcrt_free_key_cb(cache_key_t key)\n{\n\tfree(key);\n}\n\nstatic void\ncachetgcrt_free_val_cb(cache_val_t val)\n{\n\tcert_free(val);\n}\n\nstatic cache_key_t\ncachetgcrt_get_key_cb(cache_iter_t it)\n{\n\treturn kh_key(certmap, it);\n}\n\nstatic cache_val_t\ncachetgcrt_get_val_cb(cache_iter_t it)\n{\n\treturn kh_val(certmap, it);\n}\n\nstatic void\ncachetgcrt_set_val_cb(cache_iter_t it, cache_val_t val)\n{\n\tkh_val(certmap, it) = val;\n}\n\nstatic cache_val_t\ncachetgcrt_unpackverify_val_cb(cache_val_t val, int copy)\n{\n\tif (copy) {\n\t\tcert_refcount_inc(val);\n\t\treturn val;\n\t}\n\treturn ((void*)-1);\n}\n\nstatic void\ncachetgcrt_fini_cb(void)\n{\n\tkh_destroy(cstrmap_t, certmap);\n}\n\nvoid\ncachetgcrt_init_cb(cache_t *cache)\n{\n\tcertmap = kh_init(cstrmap_t);\n\n\tcache->begin_cb                 = cachetgcrt_begin_cb;\n\tcache->end_cb                   = cachetgcrt_end_cb;\n\tcache->exist_cb                 = cachetgcrt_exist_cb;\n\tcache->del_cb                   = cachetgcrt_del_cb;\n\tcache->get_cb                   = cachetgcrt_get_cb;\n\tcache->put_cb                   = cachetgcrt_put_cb;\n\tcache->free_key_cb              = cachetgcrt_free_key_cb;\n\tcache->free_val_cb              = cachetgcrt_free_val_cb;\n\tcache->get_key_cb               = cachetgcrt_get_key_cb;\n\tcache->get_val_cb               = cachetgcrt_get_val_cb;\n\tcache->set_val_cb               = cachetgcrt_set_val_cb;\n\tcache->unpackverify_val_cb      = cachetgcrt_unpackverify_val_cb;\n\tcache->fini_cb                  = cachetgcrt_fini_cb;\n}\n\ncache_key_t\ncachetgcrt_mkkey(const char *keycn)\n{\n\treturn strdup(keycn);\n}\n\ncache_val_t\ncachetgcrt_mkval(cert_t *valcrt)\n{\n\tcert_refcount_inc(valcrt);\n\treturn valcrt;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachetgcrt.h",
          "type": "blob",
          "size": 1.771484375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CACHETGCRT_H\n#define CACHETGCRT_H\n\n#include \"cache.h\"\n#include \"attrib.h\"\n#include \"cert.h\"\n\nvoid cachetgcrt_init_cb(struct cache *) NONNULL(1);\n\ncache_key_t cachetgcrt_mkkey(const char *) NONNULL(1) WUNRES;\ncache_val_t cachetgcrt_mkval(cert_t *) NONNULL(1) WUNRES;\n\n#endif /* !CACHETGCRT_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cachetgcrt.t.c",
          "type": "blob",
          "size": 4.013671875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"ssl.h\"\n#include \"cert.h\"\n#include \"cachemgr.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <check.h>\n\n#define TESTCERT \"extra/pki/targets/daniel.roe.ch.pem\"\n\nstatic void\ncachemgr_setup(void)\n{\n\tif ((ssl_init() == -1) || (cachemgr_preinit() == -1))\n\t\texit(EXIT_FAILURE);\n}\n\nstatic void\ncachemgr_teardown(void)\n{\n\tcachemgr_fini();\n\tssl_fini();\n}\n\nSTART_TEST(cache_tgcrt_01)\n{\n\tcert_t *c1, *c2;\n\n\tc1 = cert_new_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tcachemgr_tgcrt_set(\"daniel.roe.ch\", c1);\n\tc2 = cachemgr_tgcrt_get(\"daniel.roe.ch\");\n\tfail_unless(!!c2, \"cache did not return a certificate\");\n\tfail_unless(c2 == c1, \"cache did not return same pointer\");\n\tcert_free(c1);\n\tcert_free(c2);\n}\nEND_TEST\n\nSTART_TEST(cache_tgcrt_02)\n{\n\tcert_t *c;\n\n\tc = cachemgr_tgcrt_get(\"daniel.roe.ch\");\n\tfail_unless(c == NULL, \"certificate was already in empty cache\");\n}\nEND_TEST\n\nSTART_TEST(cache_tgcrt_03)\n{\n\tcert_t *c1, *c2;\n\n\tc1 = cert_new_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tcachemgr_tgcrt_set(\"daniel.roe.ch\", c1);\n\tcachemgr_tgcrt_del(\"daniel.roe.ch\");\n\tc2 = cachemgr_tgcrt_get(\"daniel.roe.ch\");\n\tfail_unless(c2 == NULL, \"cache returned deleted certificate\");\n\tcert_free(c1);\n}\nEND_TEST\n\nSTART_TEST(cache_tgcrt_04)\n{\n\tcert_t *c1, *c2;\n\n\tc1 = cert_new_load(TESTCERT);\n\tfail_unless(!!c1, \"loading certificate failed\");\n\tfail_unless(c1->references == 1, \"refcount != 1\");\n\tcachemgr_tgcrt_set(\"daniel.roe.ch\", c1);\n\tfail_unless(c1->references == 2, \"refcount != 2\");\n\tc2 = cachemgr_tgcrt_get(\"daniel.roe.ch\");\n\tfail_unless(c1->references == 3, \"refcount != 3\");\n\tcachemgr_tgcrt_set(\"daniel.roe.ch\", c1);\n\tfail_unless(c1->references == 3, \"refcount != 3\");\n\tcachemgr_tgcrt_del(\"daniel.roe.ch\");\n\tfail_unless(c1->references == 2, \"refcount != 2\");\n\tcachemgr_tgcrt_set(\"daniel.roe.ch\", c1);\n\tfail_unless(c1->references == 3, \"refcount != 3\");\n\tcert_free(c1);\n\tfail_unless(c1->references == 2, \"refcount != 2\");\n\tcachemgr_fini();\n\tfail_unless(c1->references == 1, \"refcount != 1\");\n\tcert_free(c2);\n#if 0\n\t/* deliberate access of free'd cert_t* */\n\tfail_unless(c1->references == 0, \"refcount != 0\");\n#endif\n\tfail_unless(cachemgr_preinit() != -1, \"reinit\");\n}\nEND_TEST\n\nSuite *\ncachetgcrt_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"cachetgcrt\");\n\n\ttc = tcase_create(\"cache_tgcrt\");\n\ttcase_add_checked_fixture(tc, cachemgr_setup, cachemgr_teardown);\n\ttcase_add_test(tc, cache_tgcrt_01);\n\ttcase_add_test(tc, cache_tgcrt_02);\n\ttcase_add_test(tc, cache_tgcrt_03);\n\ttcase_add_test(tc, cache_tgcrt_04);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cert.c",
          "type": "blob",
          "size": 4.77734375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"cert.h\"\n\n#include \"ssl.h\"\n\n#include <string.h>\n\n/*\n * Certificate, including private key and certificate chain.\n */\n\ncert_t *\ncert_new(void)\n{\n\tcert_t *c;\n\n\tif (!(c = malloc(sizeof(cert_t))))\n\t\treturn NULL;\n\tmemset(c, 0, sizeof(cert_t));\n\tif (pthread_mutex_init(&c->mutex, NULL)) {\n\t\tfree(c);\n\t\treturn NULL;\n\t}\n\tc->references = 1;\n\treturn c;\n}\n\n/*\n * Passed OpenSSL objects are owned by cert_t; refcount will not be\n * incremented, stack will not be duplicated.\n */\ncert_t *\ncert_new3(EVP_PKEY *key, X509 *crt, STACK_OF(X509) *chain)\n{\n\tcert_t *c;\n\n\tif (!(c = malloc(sizeof(cert_t))))\n\t\treturn NULL;\n\tif (pthread_mutex_init(&c->mutex, NULL)) {\n\t\tfree(c);\n\t\treturn NULL;\n\t}\n\tc->key = key;\n\tc->crt = crt;\n\tc->chain = chain;\n\tc->references = 1;\n\treturn c;\n}\n\n/*\n * Passed OpenSSL objects are copied by cert_t; crt/key refcount will be\n * incremented, stack will be duplicated.\n */\ncert_t *\ncert_new3_copy(EVP_PKEY *key, X509 *crt, STACK_OF(X509) *chain)\n{\n\tcert_t *c;\n\n\tif (!(c = malloc(sizeof(cert_t))))\n\t\treturn NULL;\n\tif (pthread_mutex_init(&c->mutex, NULL)) {\n\t\tfree(c);\n\t\treturn NULL;\n\t}\n\tc->key = key;\n\tssl_key_refcount_inc(c->key);\n\tc->crt = crt;\n\tssl_x509_refcount_inc(c->crt);\n\tc->chain = sk_X509_dup(chain);\n\tfor (int i = 0; i < sk_X509_num(c->chain); i++) {\n\t\tssl_x509_refcount_inc(sk_X509_value(c->chain, i));\n\t}\n\tc->references = 1;\n\treturn c;\n}\n\n/*\n * Load cert_t from file.\n */\ncert_t *\ncert_new_load(const char *filename)\n{\n\tcert_t *c;\n\n\tif (!(c = malloc(sizeof(cert_t))))\n\t\treturn NULL;\n\tmemset(c, 0, sizeof(cert_t));\n\tif (pthread_mutex_init(&c->mutex, NULL)) {\n\t\tfree(c);\n\t\treturn NULL;\n\t}\n\n\tif (ssl_x509chain_load(&c->crt, &c->chain, filename) == -1) {\n\t\tfree(c);\n\t\treturn NULL;\n\t}\n\tc->key = ssl_key_load(filename);\n\tif (!c->key) {\n\t\tX509_free(c->crt);\n\t\tif (c->chain) {\n\t\t\tsk_X509_pop_free(c->chain, X509_free);\n\t\t}\n\t\tfree(c);\n\t\treturn NULL;\n\t}\n\tc->references = 1;\n\treturn c;\n}\n\n/*\n * Increment reference count.\n */\nvoid\ncert_refcount_inc(cert_t *c)\n{\n\tpthread_mutex_lock(&c->mutex);\n\tc->references++;\n\tpthread_mutex_unlock(&c->mutex);\n}\n\n/*\n * Thread-safe setter functions; they copy the value (refcounts are inc'd).\n */\nvoid\ncert_set_key(cert_t *c, EVP_PKEY *key)\n{\n\tpthread_mutex_lock(&c->mutex);\n\tif (c->key) {\n\t\tEVP_PKEY_free(c->key);\n\t}\n\tc->key = key;\n\tif (c->key) {\n\t\tssl_key_refcount_inc(c->key);\n\t}\n\tpthread_mutex_unlock(&c->mutex);\n}\nvoid\ncert_set_crt(cert_t *c, X509 *crt)\n{\n\tpthread_mutex_lock(&c->mutex);\n\tif (c->crt) {\n\t\tX509_free(c->crt);\n\t}\n\tc->crt = crt;\n\tif (c->crt) {\n\t\tssl_x509_refcount_inc(c->crt);\n\t}\n\tpthread_mutex_unlock(&c->mutex);\n}\nvoid\ncert_set_chain(cert_t *c, STACK_OF(X509) *chain)\n{\n\tpthread_mutex_lock(&c->mutex);\n\tif (c->chain) {\n\t\tsk_X509_pop_free(c->chain, X509_free);\n\t}\n\tif (chain) {\n\t\tc->chain = sk_X509_dup(chain);\n\t\tfor (int i = 0; i < sk_X509_num(c->chain); i++) {\n\t\t\tssl_x509_refcount_inc(sk_X509_value(c->chain, i));\n\t\t}\n\t} else {\n\t\tc->chain = NULL;\n\t}\n\tpthread_mutex_unlock(&c->mutex);\n}\n\n/*\n * Free cert including internal objects.\n */\nvoid\ncert_free(cert_t *c)\n{\n\tpthread_mutex_lock(&c->mutex);\n\tc->references--;\n\tif (c->references) {\n\t\tpthread_mutex_unlock(&c->mutex);\n\t\treturn;\n\t}\n\tpthread_mutex_unlock(&c->mutex);\n\tpthread_mutex_destroy(&c->mutex);\n\tif (c->key) {\n\t\tEVP_PKEY_free(c->key);\n\t}\n\tif (c->crt) {\n\t\tX509_free(c->crt);\n\t}\n\tif (c->chain) {\n\t\tsk_X509_pop_free(c->chain, X509_free);\n\t}\n\tfree(c);\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cert.h",
          "type": "blob",
          "size": 2.1650390625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef CERT_H\n#define CERT_H\n\n#include \"attrib.h\"\n\n#include <openssl/ssl.h>\n#include <pthread.h>\n\ntypedef struct cert {\n\tEVP_PKEY *key;\n\tX509 *crt;\n\tSTACK_OF(X509) * chain;\n\tpthread_mutex_t mutex;\n\tsize_t references;\n} cert_t;\n\ncert_t * cert_new(void) MALLOC;\ncert_t * cert_new_load(const char *) MALLOC;\ncert_t * cert_new3(EVP_PKEY *, X509 *, STACK_OF(X509) *) MALLOC;\ncert_t * cert_new3_copy(EVP_PKEY *, X509 *, STACK_OF(X509) *) MALLOC;\nvoid cert_refcount_inc(cert_t *) NONNULL(1);\nvoid cert_set_key(cert_t *, EVP_PKEY *) NONNULL(1);\nvoid cert_set_crt(cert_t *, X509 *) NONNULL(1);\nvoid cert_set_chain(cert_t *, STACK_OF(X509) *) NONNULL(1);\nvoid cert_free(cert_t *) NONNULL(1);\n\n#endif /* !CERT_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "cert.t.c",
          "type": "blob",
          "size": 2.724609375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"ssl.h\"\n#include \"cert.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <check.h>\n\n#define TESTCERT \"extra/pki/targets/daniel.roe.ch.pem\"\n\nSTART_TEST(cert_new_load_01)\n{\n\tcert_t *c;\n\n\tc = cert_new_load(TESTCERT);\n\tfail_unless(!!c, \"loading PEM failed\");\n\tfail_unless(!!c->crt, \"loading crt failed\");\n\tfail_unless(!!c->key, \"loading key failed\");\n\tfail_unless(!!c->chain, \"initializing chain stack failed\");\n\tfail_unless(sk_X509_num(c->chain) == 1, \"loading chain failed\");\n\tcert_free(c);\n}\nEND_TEST\n\nSTART_TEST(cert_refcount_inc_01)\n{\n\tcert_t *c;\n\n\tc = cert_new_load(TESTCERT);\n\tfail_unless(!!c, \"loading PEM failed\");\n\tfail_unless(c->references == 1, \"refcount mismatch\");\n\tcert_refcount_inc(c);\n\tfail_unless(c->references == 2, \"refcount mismatch\");\n\tcert_free(c);\n\tfail_unless(c->references == 1, \"refcount mismatch\");\n\tcert_free(c);\n#if 0\n\t/* deliberate access after last free() */\n\tfail_unless(c->references == 0, \"refcount mismatch\");\n#endif\n}\nEND_TEST\n\nSuite *\ncert_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"cert\");\n\n\ttc = tcase_create(\"cert_new_load\");\n\ttcase_add_test(tc, cert_new_load_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"cert_refcount_inc\");\n\ttcase_add_test(tc, cert_refcount_inc_01);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "defaults.h",
          "type": "blob",
          "size": 3.763671875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef DEFAULTS_H\n#define DEFAULTS_H\n\n/*\n * Defaults for convenient tweaking or patching.\n */\n\n/*\n * User to drop privileges to by default.  This user needs to be allowed to\n * create outbound TCP connections, and in some configurations, perform DNS\n * resolution.\n *\n * Packagers may want to use a specific service user account instead of\n * overloading nobody with yet another use case.  Using nobody for source\n * builds makes sense because chances are high that it exists.  Good practice\n * is to create a dedicated user for sslsplit.\n *\n * Make sure to also patch the manual page if you patch this.\n */\n#define DFLT_DROPUSER \"nobody\"\n\n/*\n * Default file and directory modes for newly created files and directories\n * created as part of e.g. logging.  The default is to use full permissions\n * subject to the system's umask, as is the default for system utilities.\n * Use a more restrictive mode for the PID file.\n */\n#define DFLT_DIRMODE  0777\n#define DFLT_FILEMODE 0666\n#define DFLT_PIDFMODE 0644\n\n/*\n * Default cipher suite spec.\n * Use 'openssl ciphers -v spec' to see what ciphers are effectively enabled\n * by a cipher suite spec with a given version of OpenSSL.\n */\n#define DFLT_CIPHERS \"ALL:-aNULL\"\n\n/*\n * Default elliptic curve for EC cipher suites.\n */\n#define DFLT_CURVE \"prime256v1\"\n\n/*\n * Default leaf key RSA keysize in bits.\n *\n * While implementations still generally accepted leaf keys of 1024 bits in\n * size, we used 1024 for leaf keys.  As implementations are starting to sunset\n * 1024 bit RSA not only for CA keys, but also for leaf keys, we now use a 2048\n * bit key size for the leaf cert key in order to maximize interoperability in\n * default config.\n *\n * Users who want a different size, for example 1024 bit RSA for performance,\n * can always use their own pre-generated leaf key using the -K option instead\n * of generating one automatically.\n *\n * Refer to the following resources on key sizes accepted by different\n * implementations.  Note that OpenSSL security level restrictions potentially\n * apply to both sslsplit and all of the clients and servers using OpenSSL.\n *\n * OpenSSL:\n * https://www.openssl.org/docs/man1.1.0/man3/SSL_CTX_get_security_level.html\n * https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_get_security_level.html\n */\n#define DFLT_LEAFKEY_RSABITS 2048\n\n#endif /* !DEFAULTS_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "defaults.t.c",
          "type": "blob",
          "size": 2.9736328125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"sys.h\"\n\n#include \"defaults.h\"\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#include <check.h>\n\n#define CONNECT_CMD \"openssl s_client -connect www.google.com:443\" \\\n                    \" -quiet -no_ign_eof </dev/null >/dev/null 2>/dev/null\"\n\n#ifndef DOCKER\nSTART_TEST(defaults_dropuser_01)\n{\n\tfail_unless(0 == sys_privdrop(DFLT_DROPUSER, NULL, NULL),\n\t            \"privdrop failed\");\n}\nEND_TEST\n\n/*\n * This test is designed to fail in the third assertion if the currently\n * configured default dropuser is not allowed to make outbound network\n * connections.  It also fails if we do not have Internet connection.\n */\nSTART_TEST(defaults_dropuser_02)\n{\n\tfail_unless(0 == system(CONNECT_CMD),\n\t            \"connect failed for user running tests\");\n\tfail_unless(0 == sys_privdrop(DFLT_DROPUSER, NULL, NULL),\n\t            \"privdrop failed\");\n\tfail_unless(0 == system(CONNECT_CMD),\n\t            \"connect failed for default dropuser \" DFLT_DROPUSER);\n}\nEND_TEST\n#endif /* DOCKER */\n\nSuite *\ndefaults_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"defaults\");\n\n\ttc = tcase_create(\"dropuser\");\n#ifndef DOCKER\n\tif (getuid() == 0) {\n\t\ttcase_add_test(tc, defaults_dropuser_01);\n\t\ttcase_add_test(tc, defaults_dropuser_02);\n\t} else {\n\t\tfprintf(stderr, \"defaults: 2 tests omitted because \"\n\t\t                \"not building as root\\n\");\n\t}\n#else /* DOCKER */\n\tfprintf(stderr, \"defaults: 2 tests omitted because \"\n\t                \"building in docker\\n\");\n#endif /* DOCKER */\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "dynbuf.c",
          "type": "blob",
          "size": 3.3212890625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"dynbuf.h\"\n\n#include <string.h>\n#include <stdio.h>\n\n/*\n * Simple dynamic buffer, consisting of internal buffer ptr plus length.\n * Dynbuf always owns the internal allocated buffer.\n */\n\n/*\n * Allocate new dynbuf; will allocate sz bytes of memory in ->buf.\n */\ndynbuf_t *\ndynbuf_new_alloc(size_t sz)\n{\n\tdynbuf_t *db;\n\n\tif (!(db = malloc(sizeof(dynbuf_t))))\n\t\treturn NULL;\n\tif (!(db->buf = malloc(sz))) {\n\t\tfree(db);\n\t\treturn NULL;\n\t}\n\tdb->sz = sz;\n\treturn db;\n}\n\n/*\n * Create new dynbuf from provided buffer, which is copied.\n */\ndynbuf_t *\ndynbuf_new_copy(const unsigned char *buf, const size_t sz)\n{\n\tdynbuf_t *db;\n\n\tif (!(db = malloc(sizeof(dynbuf_t))))\n\t\treturn NULL;\n\tif (!(db->buf = malloc(sz))) {\n\t\tfree(db);\n\t\treturn NULL;\n\t}\n\tmemcpy(db->buf, buf, sz);\n\tdb->sz = sz;\n\treturn db;\n}\n\n/*\n * Create new dynbuf by loading a file into a newly allocated internal buffer.\n * The provided buffer will be freed by dynbuf_free().\n */\ndynbuf_t *\ndynbuf_new_file(const char *filename)\n{\n\tdynbuf_t *db;\n\tFILE *f;\n\n\tif (!(db = malloc(sizeof(dynbuf_t))))\n\t\treturn NULL;\n\n\tf = fopen(filename, \"rb\");\n\tif (!f) {\n\t\tfree(db);\n\t\treturn NULL;\n\t}\n\tfseek(f, 0, SEEK_END);\n\tdb->sz = ftell(f);\n\tif (db->sz == (size_t)-1) {\n\t\tfree(db);\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tfseek(f, 0, SEEK_SET);\n\tif (!(db->buf = malloc(db->sz))) {\n\t\tfree(db);\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tif (fread(db->buf, db->sz, 1, f) != 1) {\n\t\tfree(db->buf);\n\t\tfree(db);\n\t\tfclose(f);\n\t\treturn NULL;\n\t}\n\tfclose(f);\n\treturn db;\n}\n\n/*\n * Create new dynbuf from provided, pre-allocated buffer.\n * The provided buffer will be freed by dynbuf_free().\n */\ndynbuf_t *\ndynbuf_new(unsigned char *buf, size_t sz)\n{\n\tdynbuf_t *db;\n\n\tif (!(db = malloc(sizeof(dynbuf_t))))\n\t\treturn NULL;\n\tdb->buf = buf;\n\tdb->sz = sz;\n\treturn db;\n}\n\n/*\n * Free dynbuf including internal buffer.\n */\nvoid\ndynbuf_free(dynbuf_t *db)\n{\n\tfree(db->buf);\n\tfree(db);\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "dynbuf.h",
          "type": "blob",
          "size": 1.8984375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef DYNBUF_H\n#define DYNBUF_H\n\n#include \"attrib.h\"\n\n#include <stdlib.h>\n\ntypedef struct dynbuf {\n\tunsigned char *buf;\n\tsize_t sz;\n} dynbuf_t;\n\ndynbuf_t * dynbuf_new(unsigned char *, size_t) MALLOC;\ndynbuf_t * dynbuf_new_alloc(size_t) MALLOC;\ndynbuf_t * dynbuf_new_copy(const unsigned char *, const size_t) MALLOC;\ndynbuf_t * dynbuf_new_file(const char *) MALLOC;\nvoid dynbuf_free(dynbuf_t *) NONNULL(1);\n\n#endif /* !DYNBUF_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "dynbuf.t.c",
          "type": "blob",
          "size": 4,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"dynbuf.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <check.h>\n\n#define TESTCERT \"extra/pki/targets/daniel.roe.ch.pem\"\nstatic const unsigned char template[] = \"Hello World!\";\nstatic unsigned char *buf;\nstatic size_t sz;\n\nstatic void\nbuf_setup(void)\n{\n\tsz = sizeof(template);\n\tbuf = malloc(sz);\n\tmemcpy(buf, template, sz);\n}\n\nstatic void\nbuf_teardown(void)\n{\n\tfree(buf);\n\tbuf = NULL;\n\tsz = 0;\n}\n\nSTART_TEST(dynbuf_new_01)\n{\n\tdynbuf_t *db;\n\n\tdb = dynbuf_new(buf, sz);\n\tfail_unless(!!db, \"dynbuf not allocated\");\n\tfail_unless(!!db->buf, \"buffer not set\");\n\tfail_unless(db->buf == buf, \"buffer incorrect\");\n\tfail_unless(db->sz == sz, \"size incorrect\");\n\tdynbuf_free(db);\n\tbuf = malloc(sz);\n}\nEND_TEST\n\nSTART_TEST(dynbuf_new_alloc_01)\n{\n\tdynbuf_t *db;\n\n\tdb = dynbuf_new_alloc(sz);\n\tfail_unless(!!db, \"dynbuf not allocated\");\n\tfail_unless(!!db->buf, \"buffer not set\");\n\tfail_unless(db->sz == sz, \"size incorrect\");\n\tdynbuf_free(db);\n}\nEND_TEST\n\nSTART_TEST(dynbuf_new_copy_01)\n{\n\tdynbuf_t *db;\n\n\tdb = dynbuf_new_copy(buf, sz);\n\tfail_unless(!!db, \"dynbuf not allocated\");\n\tfail_unless(!!db->buf, \"buffer not set\");\n\tfail_unless(db->buf != buf, \"buffer incorrect\");\n\tfail_unless(db->sz == sz, \"size incorrect\");\n\tfail_unless(!memcmp(db->buf, buf, sz), \"buffer data incorrect\");\n\tdynbuf_free(db);\n}\nEND_TEST\n\nSTART_TEST(dynbuf_new_file_01)\n{\n\tdynbuf_t *db;\n\n\tdb = dynbuf_new_file(TESTCERT);\n\tfail_unless(!!db, \"dynbuf not allocated\");\n\tfail_unless(!!db->buf, \"buffer not set\");\n\tfail_unless(db->buf != buf, \"buffer incorrect\");\n\tfail_unless(db->sz > 0, \"size incorrect\");\n\tfail_unless(!!strstr((char*)db->buf, \"-----BEGIN CERTIFICATE-----\"),\n\t            \"cannot find begin of cert\");\n\tfail_unless(!!strstr((char*)db->buf, \"-----END CERTIFICATE-----\"),\n\t            \"cannot find end of cert\");\n\tdynbuf_free(db);\n}\nEND_TEST\n\nSuite *\ndynbuf_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"dynbuf\");\n\n\ttc = tcase_create(\"dynbuf_new_01\");\n\ttcase_add_checked_fixture(tc, buf_setup, buf_teardown);\n\ttcase_add_test(tc, dynbuf_new_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"dynbuf_new_alloc_01\");\n\ttcase_add_checked_fixture(tc, buf_setup, buf_teardown);\n\ttcase_add_test(tc, dynbuf_new_alloc_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"dynbuf_new_copy_01\");\n\ttcase_add_checked_fixture(tc, buf_setup, buf_teardown);\n\ttcase_add_test(tc, dynbuf_new_copy_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"dynbuf_new_file_01\");\n\ttcase_add_checked_fixture(tc, buf_setup, buf_teardown);\n\ttcase_add_test(tc, dynbuf_new_file_01);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "khash.h",
          "type": "blob",
          "size": 21.037109375,
          "content": "/* The MIT License\n\n   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n*/\n\n/*\n  An example:\n\n#include \"khash.h\"\nKHASH_MAP_INIT_INT(32, char)\nint main() {\n\tint ret, is_missing;\n\tkhiter_t k;\n\tkhash_t(32) *h = kh_init(32);\n\tk = kh_put(32, h, 5, &ret);\n\tkh_value(h, k) = 10;\n\tk = kh_get(32, h, 10);\n\tis_missing = (k == kh_end(h));\n\tk = kh_get(32, h, 5);\n\tkh_del(32, h, k);\n\tfor (k = kh_begin(h); k != kh_end(h); ++k)\n\t\tif (kh_exist(h, k)) kh_value(h, k) = 1;\n\tkh_destroy(32, h);\n\treturn 0;\n}\n*/\n\n/*\n  2013-05-02 (0.2.8):\n\n\t* Use quadratic probing. When the capacity is power of 2, stepping function\n\t  i*(i+1)/2 guarantees to traverse each bucket. It is better than double\n\t  hashing on cache performance and is more robust than linear probing.\n\n\t  In theory, double hashing should be more robust than quadratic probing.\n\t  However, my implementation is probably not for large hash tables, because\n\t  the second hash function is closely tied to the first hash function,\n\t  which reduce the effectiveness of double hashing.\n\n\tReference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php\n\n  2011-12-29 (0.2.7):\n\n    * Minor code clean up; no actual effect.\n\n  2011-09-16 (0.2.6):\n\n\t* The capacity is a power of 2. This seems to dramatically improve the\n\t  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:\n\n\t   - http://code.google.com/p/ulib/\n\t   - http://nothings.org/computer/judy/\n\n\t* Allow to optionally use linear probing which usually has better\n\t  performance for random input. Double hashing is still the default as it\n\t  is more robust to certain non-random input.\n\n\t* Added Wang's integer hash function (not used by default). This hash\n\t  function is more robust to certain non-random input.\n\n  2011-02-14 (0.2.5):\n\n    * Allow to declare global functions.\n\n  2009-09-26 (0.2.4):\n\n    * Improve portability\n\n  2008-09-19 (0.2.3):\n\n\t* Corrected the example\n\t* Improved interfaces\n\n  2008-09-11 (0.2.2):\n\n\t* Improved speed a little in kh_put()\n\n  2008-09-10 (0.2.1):\n\n\t* Added kh_clear()\n\t* Fixed a compiling error\n\n  2008-09-02 (0.2.0):\n\n\t* Changed to token concatenation which increases flexibility.\n\n  2008-08-31 (0.1.2):\n\n\t* Fixed a bug in kh_get(), which has not been tested previously.\n\n  2008-08-31 (0.1.1):\n\n\t* Added destructor\n*/\n\n\n#ifndef __AC_KHASH_H\n#define __AC_KHASH_H\n\n/*!\n  @header\n\n  Generic hash table library.\n */\n\n#define AC_VERSION_KHASH_H \"0.2.8\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n/* compiler specific configuration */\n\n#if UINT_MAX == 0xffffffffu\ntypedef unsigned int khint32_t;\n#elif ULONG_MAX == 0xffffffffu\ntypedef unsigned long khint32_t;\n#endif\n\n#if ULONG_MAX == ULLONG_MAX\ntypedef unsigned long khint64_t;\n#else\ntypedef unsigned long long khint64_t;\n#endif\n\n#ifndef kh_inline\n#ifdef _MSC_VER\n#define kh_inline __inline\n#else\n#define kh_inline inline\n#endif\n#endif /* kh_inline */\n\n#ifndef klib_unused\n#if (defined __clang__ && __clang_major__ >= 3) || (defined __GNUC__ && __GNUC__ >= 3)\n#define klib_unused __attribute__ ((__unused__))\n#else\n#define klib_unused\n#endif\n#endif /* klib_unused */\n\ntypedef khint32_t khint_t;\ntypedef khint_t khiter_t;\n\n#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)\n#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)\n#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)\n#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(1ul<<((i&0xfU)<<1)))\n#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(2ul<<((i&0xfU)<<1)))\n#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(3ul<<((i&0xfU)<<1)))\n#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=1ul<<((i&0xfU)<<1))\n\n#define __ac_fsize(m) ((m) < 16? 1 : (m)>>4)\n\n#ifndef kroundup32\n#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))\n#endif\n\n#ifndef kcalloc\n#define kcalloc(N,Z) calloc(N,Z)\n#endif\n#ifndef kmalloc\n#define kmalloc(Z) malloc(Z)\n#endif\n#ifndef krealloc\n#define krealloc(P,Z) realloc(P,Z)\n#endif\n#ifndef kfree\n#define kfree(P) free(P)\n#endif\n\nstatic const double __ac_HASH_UPPER = 0.77;\n\n#define __KHASH_TYPE(name, khkey_t, khval_t) \\\n\ttypedef struct kh_##name##_s { \\\n\t\tkhint_t n_buckets, size, n_occupied, upper_bound; \\\n\t\tkhint32_t *flags; \\\n\t\tkhkey_t *keys; \\\n\t\tkhval_t *vals; \\\n\t} kh_##name##_t;\n\n#define __KHASH_PROTOTYPES(name, khkey_t, khval_t)\t \t\t\t\t\t\\\n\textern kh_##name##_t *kh_init_##name(void);\t\t\t\t\t\t\t\\\n\textern void kh_destroy_##name(kh_##name##_t *h);\t\t\t\t\t\\\n\textern void kh_clear_##name(kh_##name##_t *h);\t\t\t\t\t\t\\\n\textern khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key); \t\\\n\textern int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets); \\\n\textern khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret); \\\n\textern void kh_del_##name(kh_##name##_t *h, khint_t x);\n\n#define __KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tSCOPE kh_##name##_t *kh_init_##name(void) {\t\t\t\t\t\t\t\\\n\t\treturn (kh_##name##_t*)kcalloc(1, sizeof(kh_##name##_t));\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_destroy_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree((void *)h->keys); kfree(h->flags);\t\t\t\t\t\\\n\t\t\tkfree((void *)h->vals);\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_clear_##name(kh_##name##_t *h)\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h && h->flags) {\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmemset(h->flags, 0xaa, __ac_fsize(h->n_buckets) * sizeof(khint32_t)); \\\n\t\t\th->size = h->n_occupied = 0;\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_get_##name(const kh_##name##_t *h, khkey_t key) \t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_buckets) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t k, i, last, mask, step = 0; \\\n\t\t\tmask = h->n_buckets - 1;\t\t\t\t\t\t\t\t\t\\\n\t\t\tk = __hash_func(key); i = k & mask;\t\t\t\t\t\t\t\\\n\t\t\tlast = i; \\\n\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\ti = (i + (++step)) & mask; \\\n\t\t\t\tif (i == last) return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\treturn __ac_iseither(h->flags, i)? h->n_buckets : i;\t\t\\\n\t\t} else return 0;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE int kh_resize_##name(kh_##name##_t *h, khint_t new_n_buckets) \\\n\t{ /* This function uses 0.25*n_buckets bytes of working space instead of [sizeof(key_t+val_t)+.25]*n_buckets. */ \\\n\t\tkhint32_t *new_flags = 0;\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t j = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkroundup32(new_n_buckets); \t\t\t\t\t\t\t\t\t\\\n\t\t\tif (new_n_buckets < 4) new_n_buckets = 4;\t\t\t\t\t\\\n\t\t\tif (h->size >= (khint_t)(new_n_buckets * __ac_HASH_UPPER + 0.5)) j = 0;\t/* requested size is too small */ \\\n\t\t\telse { /* hash table size to be changed (shrink or expand); rehash */ \\\n\t\t\t\tnew_flags = (khint32_t*)kmalloc(__ac_fsize(new_n_buckets) * sizeof(khint32_t));\t\\\n\t\t\t\tif (!new_flags) return -1;\t\t\t\t\t\t\t\t\\\n\t\t\t\tmemset(new_flags, 0xaa, __ac_fsize(new_n_buckets) * sizeof(khint32_t)); \\\n\t\t\t\tif (h->n_buckets < new_n_buckets) {\t/* expand */\t\t\\\n\t\t\t\t\tkhkey_t *new_keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\t\tif (!new_keys) { kfree(new_flags); return -1; }\t\t\\\n\t\t\t\t\th->keys = new_keys;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) {\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\tkhval_t *new_vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t\t\t\tif (!new_vals) { kfree(new_flags); return -1; }\t\\\n\t\t\t\t\t\th->vals = new_vals;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t} /* otherwise shrink */\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (j) { /* rehashing is needed */\t\t\t\t\t\t\t\t\\\n\t\t\tfor (j = 0; j != h->n_buckets; ++j) {\t\t\t\t\t\t\\\n\t\t\t\tif (__ac_iseither(h->flags, j) == 0) {\t\t\t\t\t\\\n\t\t\t\t\tkhkey_t key = h->keys[j];\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhval_t val;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tkhint_t new_mask;\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tnew_mask = new_n_buckets - 1; \t\t\t\t\t\t\\\n\t\t\t\t\tif (kh_is_map) val = h->vals[j];\t\t\t\t\t\\\n\t\t\t\t\t__ac_set_isdel_true(h->flags, j);\t\t\t\t\t\\\n\t\t\t\t\twhile (1) { /* kick-out process; sort of like in Cuckoo hashing */ \\\n\t\t\t\t\t\tkhint_t k, i, step = 0; \\\n\t\t\t\t\t\tk = __hash_func(key);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\ti = k & new_mask;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\twhile (!__ac_isempty(new_flags, i)) i = (i + (++step)) & new_mask; \\\n\t\t\t\t\t\t__ac_set_isempty_false(new_flags, i);\t\t\t\\\n\t\t\t\t\t\tif (i < h->n_buckets && __ac_iseither(h->flags, i) == 0) { /* kick out the existing element */ \\\n\t\t\t\t\t\t\t{ khkey_t tmp = h->keys[i]; h->keys[i] = key; key = tmp; } \\\n\t\t\t\t\t\t\tif (kh_is_map) { khval_t tmp = h->vals[i]; h->vals[i] = val; val = tmp; } \\\n\t\t\t\t\t\t\t__ac_set_isdel_true(h->flags, i); /* mark it as deleted in the old hash table */ \\\n\t\t\t\t\t\t} else { /* write the element and jump out of the loop */ \\\n\t\t\t\t\t\t\th->keys[i] = key;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\tif (kh_is_map) h->vals[i] = val;\t\t\t\\\n\t\t\t\t\t\t\tbreak;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tif (h->n_buckets > new_n_buckets) { /* shrink the hash table */ \\\n\t\t\t\th->keys = (khkey_t*)krealloc((void *)h->keys, new_n_buckets * sizeof(khkey_t)); \\\n\t\t\t\tif (kh_is_map) h->vals = (khval_t*)krealloc((void *)h->vals, new_n_buckets * sizeof(khval_t)); \\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkfree(h->flags); /* free the working space */\t\t\t\t\\\n\t\t\th->flags = new_flags;\t\t\t\t\t\t\t\t\t\t\\\n\t\t\th->n_buckets = new_n_buckets;\t\t\t\t\t\t\t\t\\\n\t\t\th->n_occupied = h->size;\t\t\t\t\t\t\t\t\t\\\n\t\t\th->upper_bound = (khint_t)(h->n_buckets * __ac_HASH_UPPER + 0.5); \\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE khint_t kh_put_##name(kh_##name##_t *h, khkey_t key, int *ret) \\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tkhint_t x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (h->n_occupied >= h->upper_bound) { /* update the hash table */ \\\n\t\t\tif (h->n_buckets > (h->size<<1)) {\t\t\t\t\t\t\t\\\n\t\t\t\tif (kh_resize_##name(h, h->n_buckets - 1) < 0) { /* clear \"deleted\" elements */ \\\n\t\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t} else if (kh_resize_##name(h, h->n_buckets + 1) < 0) { /* expand the hash table */ \\\n\t\t\t\t*ret = -1; return h->n_buckets;\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} /* TODO: to implement automatically shrinking; resize() already support shrinking */ \\\n\t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tkhint_t k, i, site, last, mask = h->n_buckets - 1, step = 0; \\\n\t\t\tx = site = h->n_buckets; k = __hash_func(key); i = k & mask; \\\n\t\t\tif (__ac_isempty(h->flags, i)) x = i; /* for speed up */\t\\\n\t\t\telse {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tlast = i; \\\n\t\t\t\twhile (!__ac_isempty(h->flags, i) && (__ac_isdel(h->flags, i) || !__hash_equal(h->keys[i], key))) { \\\n\t\t\t\t\tif (__ac_isdel(h->flags, i)) site = i;\t\t\t\t\\\n\t\t\t\t\ti = (i + (++step)) & mask; \\\n\t\t\t\t\tif (i == last) { x = site; break; }\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\tif (x == h->n_buckets) {\t\t\t\t\t\t\t\t\\\n\t\t\t\t\tif (__ac_isempty(h->flags, i) && site != h->n_buckets) x = site; \\\n\t\t\t\t\telse x = i;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (__ac_isempty(h->flags, x)) { /* not present at all */\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size; ++h->n_occupied;\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else if (__ac_isdel(h->flags, x)) { /* deleted */\t\t\t\t\\\n\t\t\th->keys[x] = key;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t__ac_set_isboth_false(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t++h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t*ret = 2;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} else *ret = 0; /* Don't touch h->keys[x] if present and not deleted */ \\\n\t\treturn x;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tSCOPE void kh_del_##name(kh_##name##_t *h, khint_t x)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tif (x != h->n_buckets && !__ac_iseither(h->flags, x)) {\t\t\t\\\n\t\t\t__ac_set_isdel_true(h->flags, x);\t\t\t\t\t\t\t\\\n\t\t\t--h->size;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#define KHASH_DECLARE(name, khkey_t, khval_t)\t\t \t\t\t\t\t\\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_PROTOTYPES(name, khkey_t, khval_t)\n\n#define KHASH_INIT2(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\t__KHASH_TYPE(name, khkey_t, khval_t) \t\t\t\t\t\t\t\t\\\n\t__KHASH_IMPL(name, SCOPE, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n#define KHASH_INIT(name, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal) \\\n\tKHASH_INIT2(name, static kh_inline klib_unused, khkey_t, khval_t, kh_is_map, __hash_func, __hash_equal)\n\n/* --- BEGIN OF HASH FUNCTIONS --- */\n\n/*! @function\n  @abstract     Integer hash function\n  @param  key   The integer [khint32_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int_hash_func(key) (khint32_t)(key)\n/*! @function\n  @abstract     Integer comparison function\n */\n#define kh_int_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     64-bit integer hash function\n  @param  key   The integer [khint64_t]\n  @return       The hash value [khint_t]\n */\n#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)\n/*! @function\n  @abstract     64-bit integer comparison function\n */\n#define kh_int64_hash_equal(a, b) ((a) == (b))\n/*! @function\n  @abstract     const char* hash function\n  @param  s     Pointer to a null terminated string\n  @return       The hash value\n */\nstatic kh_inline khint_t __ac_X31_hash_string(const char *s)\n{\n\tkhint_t h = (khint_t)*s;\n\tif (h) for (++s ; *s; ++s) h = (h << 5) - h + (khint_t)*s;\n\treturn h;\n}\n/*! @function\n  @abstract     Another interface to const char* hash function\n  @param  key   Pointer to a null terminated string [const char*]\n  @return       The hash value [khint_t]\n */\n#define kh_str_hash_func(key) __ac_X31_hash_string(key)\n/*! @function\n  @abstract     Const char* comparison function\n */\n#define kh_str_hash_equal(a, b) (strcmp(a, b) == 0)\n\nstatic kh_inline khint_t __ac_Wang_hash(khint_t key)\n{\n    key += ~(key << 15);\n    key ^=  (key >> 10);\n    key +=  (key << 3);\n    key ^=  (key >> 6);\n    key += ~(key << 11);\n    key ^=  (key >> 16);\n    return key;\n}\n#define kh_int_hash_func2(key) __ac_Wang_hash((khint_t)key)\n\n/* --- END OF HASH FUNCTIONS --- */\n\n/* Other convenient macros... */\n\n/*!\n  @abstract Type of the hash table.\n  @param  name  Name of the hash table [symbol]\n */\n#define khash_t(name) kh_##name##_t\n\n/*! @function\n  @abstract     Initiate a hash table.\n  @param  name  Name of the hash table [symbol]\n  @return       Pointer to the hash table [khash_t(name)*]\n */\n#define kh_init(name) kh_init_##name()\n\n/*! @function\n  @abstract     Destroy a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_destroy(name, h) kh_destroy_##name(h)\n\n/*! @function\n  @abstract     Reset a hash table without deallocating memory.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n */\n#define kh_clear(name, h) kh_clear_##name(h)\n\n/*! @function\n  @abstract     Resize a hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  s     New size [khint_t]\n */\n#define kh_resize(name, h, s) kh_resize_##name(h, s)\n\n/*! @function\n  @abstract     Insert a key to the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @param  r     Extra return code: -1 if the operation failed;\n                0 if the key is present in the hash table;\n                1 if the bucket is empty (never used); 2 if the element in\n\t\t\t\tthe bucket has been deleted [int*]\n  @return       Iterator to the inserted element [khint_t]\n */\n#define kh_put(name, h, k, r) kh_put_##name(h, k, r)\n\n/*! @function\n  @abstract     Retrieve a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Key [type of keys]\n  @return       Iterator to the found element, or kh_end(h) if the element is absent [khint_t]\n */\n#define kh_get(name, h, k) kh_get_##name(h, k)\n\n/*! @function\n  @abstract     Remove a key from the hash table.\n  @param  name  Name of the hash table [symbol]\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  k     Iterator to the element to be deleted [khint_t]\n */\n#define kh_del(name, h, k) kh_del_##name(h, k)\n\n/*! @function\n  @abstract     Test whether a bucket contains data.\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       1 if containing data; 0 otherwise [int]\n */\n#define kh_exist(h, x) (!__ac_iseither((h)->flags, (x)))\n\n/*! @function\n  @abstract     Get key given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Key [type of keys]\n */\n#define kh_key(h, x) ((h)->keys[x])\n\n/*! @function\n  @abstract     Get value given an iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  x     Iterator to the bucket [khint_t]\n  @return       Value [type of values]\n  @discussion   For hash sets, calling this results in segfault.\n */\n#define kh_val(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Alias of kh_val()\n */\n#define kh_value(h, x) ((h)->vals[x])\n\n/*! @function\n  @abstract     Get the start iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The start iterator [khint_t]\n */\n#define kh_begin(h) (khint_t)(0)\n\n/*! @function\n  @abstract     Get the end iterator\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       The end iterator [khint_t]\n */\n#define kh_end(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Get the number of elements in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of elements in the hash table [khint_t]\n */\n#define kh_size(h) ((h)->size)\n\n/*! @function\n  @abstract     Get the number of buckets in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @return       Number of buckets in the hash table [khint_t]\n */\n#define kh_n_buckets(h) ((h)->n_buckets)\n\n/*! @function\n  @abstract     Iterate over the entries in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  kvar  Variable to which key will be assigned\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach(h, kvar, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(kvar) = kh_key(h,__i);\t\t\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/*! @function\n  @abstract     Iterate over the values in the hash table\n  @param  h     Pointer to the hash table [khash_t(name)*]\n  @param  vvar  Variable to which value will be assigned\n  @param  code  Block of code to execute\n */\n#define kh_foreach_value(h, vvar, code) { khint_t __i;\t\t\\\n\tfor (__i = kh_begin(h); __i != kh_end(h); ++__i) {\t\t\\\n\t\tif (!kh_exist(h,__i)) continue;\t\t\t\t\t\t\\\n\t\t(vvar) = kh_val(h,__i);\t\t\t\t\t\t\t\t\\\n\t\tcode;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t} }\n\n/* More conenient interfaces */\n\n/*! @function\n  @abstract     Instantiate a hash set containing integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, char, 0, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint32_t, khval_t, 1, kh_int_hash_func, kh_int_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_INT64(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, char, 0, kh_int64_hash_func, kh_int64_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing 64-bit integer keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_INT64(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, khint64_t, khval_t, 1, kh_int64_hash_func, kh_int64_hash_equal)\n\ntypedef const char *kh_cstr_t;\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n */\n#define KHASH_SET_INIT_STR(name)\t\t\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, char, 0, kh_str_hash_func, kh_str_hash_equal)\n\n/*! @function\n  @abstract     Instantiate a hash map containing const char* keys\n  @param  name  Name of the hash table [symbol]\n  @param  khval_t  Type of values [type]\n */\n#define KHASH_MAP_INIT_STR(name, khval_t)\t\t\t\t\t\t\t\t\\\n\tKHASH_INIT(name, kh_cstr_t, khval_t, 1, kh_str_hash_func, kh_str_hash_equal)\n\n#endif /* __AC_KHASH_H */\n"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 45.3125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"log.h\"\n\n#include \"logger.h\"\n#include \"sys.h\"\n#include \"attrib.h\"\n#include \"privsep.h\"\n#include \"defaults.h\"\n#include \"logpkt.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <string.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <syslog.h>\n#include <assert.h>\n#include <sys/stat.h>\n#include <netinet/in.h>\n\n/*\n * Centralized logging code multiplexing thread access to the logger based\n * logging in separate threads.  Some log types are switchable to different\n * backends, such as syslog and stderr.\n */\n\n\n/*\n * Common code for all logs.\n */\nstatic proxy_ctx_t *proxy_ctx = NULL;\n\nvoid\nlog_exceptcb(void)\n{\n\tif (proxy_ctx) {\n\t\tproxy_loopbreak(proxy_ctx, -1);\n\t\tproxy_ctx = NULL;\n\t}\n}\n\n/*\n * Error log.\n * Switchable between stderr and syslog.\n * Uses logger thread.\n */\n\nstatic logger_t *err_log = NULL;\nstatic int err_shortcut_logger = 0;\nstatic int err_mode = LOG_ERR_MODE_STDERR;\n\nstatic ssize_t\nlog_err_writecb(UNUSED void *fh, UNUSED unsigned long ctl,\n                const void *buf, size_t sz)\n{\n\tswitch (err_mode) {\n\t\tcase LOG_ERR_MODE_STDERR:\n\t\t\treturn fwrite(buf, sz - 1, 1, stderr);\n\t\tcase LOG_ERR_MODE_SYSLOG:\n\t\t\tsyslog(LOG_ERR, \"%s\", (const char *)buf);\n\t\t\treturn sz;\n\t}\n\treturn -1;\n}\n\nint\nlog_err_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *buf;\n\tint rv;\n\n\tva_start(ap, fmt);\n\trv = vasprintf(&buf, fmt, ap);\n\tva_end(ap);\n\tif (rv < 0)\n\t\treturn -1;\n\tif (err_shortcut_logger) {\n\t\treturn logger_write_freebuf(err_log, NULL, 0,\n\t\t                            buf, strlen(buf) + 1);\n\t} else {\n\t\tlog_err_writecb(NULL, 0, (unsigned char*)buf, strlen(buf) + 1);\n\t\tfree(buf);\n\t}\n\treturn 0;\n}\n\nvoid\nlog_err_mode(int mode)\n{\n\terr_mode = mode;\n}\n\n\n/*\n * Debug log.  Redirects logging to error log.\n * Switchable between error log or no logging.\n * Uses the error log logger thread.\n */\n\nstatic int dbg_mode = LOG_DBG_MODE_NONE;\n\nint\nlog_dbg_write_free(void *buf, size_t sz)\n{\n\tif (dbg_mode == LOG_DBG_MODE_NONE)\n\t\treturn 0;\n\n\tif (err_shortcut_logger) {\n\t\treturn logger_write_freebuf(err_log, NULL, 0, buf, sz);\n\t} else {\n\t\tlog_err_writecb(NULL, 0, buf, sz);\n\t\tfree(buf);\n\t}\n\treturn 0;\n}\n\nint\nlog_dbg_print_free(char *s)\n{\n\treturn log_dbg_write_free(s, strlen(s) + 1);\n}\n\nint\nlog_dbg_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *buf;\n\tint rv;\n\n\tif (dbg_mode == LOG_DBG_MODE_NONE)\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\trv = vasprintf(&buf, fmt, ap);\n\tva_end(ap);\n\tif (rv < 0)\n\t\treturn -1;\n\treturn log_dbg_print_free(buf);\n}\n\nvoid\nlog_dbg_mode(int mode)\n{\n\tdbg_mode = mode;\n}\n\n\n/*\n * Master key log.  Logs master keys in SSLKEYLOGFILE format.\n * Uses a logger thread.\n */\n\nlogger_t *masterkey_log = NULL;\nstatic int masterkey_fd = -1;\nstatic char *masterkey_fn = NULL;\nstatic int masterkey_clisock = -1;\n\nstatic int\nlog_masterkey_preinit(const char *logfile)\n{\n\tmasterkey_fd = open(logfile, O_WRONLY|O_APPEND|O_CREAT, DFLT_FILEMODE);\n\tif (masterkey_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s (%i)\\n\",\n\t\t               logfile, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tmasterkey_fn = strdup(logfile);\n\tif (!masterkey_fn) {\n\t\tclose(masterkey_fd);\n\t\tmasterkey_fd = -1;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nlog_masterkey_reopencb(void)\n{\n\tclose(masterkey_fd);\n\tmasterkey_fd = privsep_client_openfile(masterkey_clisock,\n\t                                       masterkey_fn,\n\t                                       0);\n\tif (masterkey_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s\\n\",\n\t\t               masterkey_fn, strerror(errno));\n\t\tfree(masterkey_fn);\n\t\tmasterkey_fn = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Do the actual write to the open master key log file descriptor.\n */\nstatic ssize_t\nlog_masterkey_writecb(UNUSED void *fh, UNUSED unsigned long ctl,\n                      const void *buf, size_t sz)\n{\n\tif (write(masterkey_fd, buf, sz) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to masterkey log:\"\n\t\t               \" %s\\n\", strerror(errno));\n\t\treturn -1;\n\t}\n\treturn sz;\n}\n\nstatic void\nlog_masterkey_fini(void)\n{\n\tif (masterkey_fd != -1)\n\t\tclose(masterkey_fd);\n\tmasterkey_fd = -1;\n}\n\n\n/*\n * Connection log.  Logs a one-liner to a file-based connection log.\n * Uses a logger thread.\n */\n\nlogger_t *connect_log = NULL;\nstatic int connect_fd = -1;\nstatic char *connect_fn = NULL;\nstatic int connect_clisock = -1;\n\nstatic int\nlog_connect_preinit(const char *logfile)\n{\n\tconnect_fd = open(logfile, O_WRONLY|O_APPEND|O_CREAT, DFLT_FILEMODE);\n\tif (connect_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s (%i)\\n\",\n\t\t               logfile, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tconnect_fn = strdup(logfile);\n\tif (!connect_fn) {\n\t\tclose(connect_fd);\n\t\tconnect_fd = -1;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nlog_connect_reopencb(void)\n{\n\tclose(connect_fd);\n\tconnect_fd = privsep_client_openfile(connect_clisock,\n\t                                     connect_fn,\n\t                                     0);\n\tif (connect_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s\\n\",\n\t\t               connect_fn, strerror(errno));\n\t\tfree(connect_fn);\n\t\tconnect_fn = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Do the actual write to the open connection log file descriptor.\n * We prepend a timestamp here, which means that timestamps are slightly\n * delayed from the time of actual logging.  Since we only have second\n * resolution that should not make any difference.\n */\nstatic ssize_t\nlog_connect_writecb(UNUSED void *fh, UNUSED unsigned long ctl,\n                    const void *buf, size_t sz)\n{\n\tchar timebuf[32];\n\ttime_t epoch;\n\tstruct tm *utc;\n\tsize_t n;\n\n\ttime(&epoch);\n\tif ((utc = gmtime(&epoch)) == NULL) {\n\t\tlog_err_printf(\"Failed to convert time: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tn = strftime(timebuf, sizeof(timebuf), \"%Y-%m-%d %H:%M:%S UTC \", utc);\n\tif (n == 0) {\n\t\tlog_err_printf(\"Error from strftime(): buffer too small\\n\");\n\t\treturn -1;\n\t}\n\tif ((write(connect_fd, timebuf, n) == -1) ||\n\t    (write(connect_fd, buf, sz) == -1)) {\n\t\tlog_err_printf(\"Warning: Failed to write to connect log: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn sz;\n}\n\nstatic void\nlog_connect_fini(void)\n{\n\tif (connect_fd != -1)\n\t\tclose(connect_fd);\n\tconnect_fd = -1;\n}\n\n\n/*\n * Content log.\n * Logs connection content to either a single file or a directory containing\n * per-connection logs.\n * Uses a logger thread; the actual logging happens in a separate thread.\n * To ensure ordering of requests (open, write, ..., close), logging for a\n * single connection must happen from a single thread.\n * This is guaranteed by the current pxythr architecture.\n */\n\n#define PREPFLAG_REQUEST 1\n#define PREPFLAG_EOF     2\n\ntypedef struct log_content_file_ctx {\n\tunion {\n\t\tstruct {\n\t\t\tchar *header_req;\n\t\t\tchar *header_resp;\n\t\t} single;\n\t\tstruct {\n\t\t\tint fd;\n\t\t\tchar *filename;\n\t\t} dir;\n\t\tstruct {\n\t\t\tint fd;\n\t\t\tchar *filename;\n\t\t} spec;\n\t} u;\n} log_content_file_ctx_t;\n\ntypedef struct log_content_pcap_ctx {\n\tunion {\n\t\tstruct {\n\t\t\tint fd;\n\t\t\tchar *filename;\n\t\t} dir;\n\t\tstruct {\n\t\t\tint fd;\n\t\t\tchar *filename;\n\t\t} spec;\n\t} u;\n\tlogpkt_ctx_t state;\n} log_content_pcap_ctx_t;\n\n#ifndef WITHOUT_MIRROR\ntypedef struct log_content_mirror_ctx {\n\tlogpkt_ctx_t state;\n} log_content_mirror_ctx_t;\n#endif /* !WITHOUT_MIRROR */\n\nstatic int content_file_clisock = -1;\nstatic logger_t *content_file_log = NULL;\nstatic int content_pcap_clisock = -1;\nstatic logger_t *content_pcap_log = NULL;\nstatic uint8_t content_pcap_src_ether[ETHER_ADDR_LEN] = {\n\t0x02, 0x00, 0x00, 0x11, 0x11, 0x11};\nstatic uint8_t content_pcap_dst_ether[ETHER_ADDR_LEN] = {\n\t0x02, 0x00, 0x00, 0x22, 0x22, 0x22};\n#ifndef WITHOUT_MIRROR\nstatic logger_t *content_mirror_log = NULL;\nstatic libnet_t *content_mirror_libnet = NULL;\nstatic size_t content_mirror_mtu = 0;\nstatic uint8_t content_mirror_src_ether[ETHER_ADDR_LEN];\nstatic uint8_t content_mirror_dst_ether[ETHER_ADDR_LEN];\n#endif /* !WITHOUT_MIRROR */\n\n/*\n * Split a pathname into static LHS (including final slashes) and dynamic RHS.\n * Returns -1 on error, 0 on success.\n * On success, fills in lhs and rhs with newly allocated buffers that must\n * be freed by the caller.\n */\nint\nlog_content_split_pathspec(const char *path, char **lhs, char **rhs)\n{\n\tconst char *p, *q, *r;\n\n\tp = strchr(path, '%');\n\t/* at first % or EOS */\n\n\t/* skip % if next char is % (and implicitly not \\0) */\n\twhile (p && p[1] == '%') {\n\t\tp = strchr(p + 2, '%');\n\t}\n\t/* at first % that is not %%, or at EOS */\n\n\tif (!p || !p[1]) {\n\t\t/* EOS: no % that is not %% in path */\n\t\tp = path + strlen(path);\n\t}\n\t/* at first hot % or at '\\0' */\n\n\t/* find last / before % */\n\tfor (r = q = strchr(path, '/'); q && (q < p); q = strchr(q + 1, '/')) {\n\t\tr = q;\n\t}\n\tif (!(p = r)) {\n\t\t/* no / found, use dummy ./ as LHS */\n\t\t*lhs = strdup(\"./\");\n\t\tif (!*lhs)\n\t\t\treturn -1;\n\t\t*rhs = strdup(path);\n\t\tif (!*rhs) {\n\t\t\tfree(*lhs);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\t}\n\t/* at last / terminating the static part of path */\n\n\tp++; /* skip / */\n\t*lhs = malloc(p - path + 1 /* for terminating null */);\n\tif (!*lhs)\n\t\treturn -1;\n\tmemcpy(*lhs, path, p - path);\n\t(*lhs)[p - path] = '\\0';\n\t*rhs = strdup(p);\n\tif (!*rhs) {\n\t\tfree(*lhs);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Generate a log path based on the given log spec.\n * Returns an allocated buffer which must be freed by caller, or NULL on error.\n */\n#define PATH_BUF_INC\t1024\nstatic char * MALLOC NONNULL(1,2,3)\nlog_content_format_pathspec(const char *logspec,\n                            char *srchost, char *srcport,\n                            char *dsthost, char *dstport,\n                            char *exec_path, char *user, char *group)\n{\n\t/* set up buffer to hold our generated file path */\n\tsize_t path_buflen = PATH_BUF_INC;\n\tchar *path_buf = malloc(path_buflen);\n\tif (path_buf == NULL) {\n\t\tlog_err_printf(\"failed to allocate path buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\t/* initialize the buffer as an empty C string */\n\tpath_buf[0] = '\\0';\n\n\t/* iterate over format specifiers */\n\tsize_t path_len = 0;\n\tfor (const char *p = logspec; *p != '\\0'; p++) {\n\t\tconst char *elem = NULL;\n\t\tsize_t elem_len = 0;\n\n\t\tconst char iso8601[] =  \"%Y%m%dT%H%M%SZ\";\n\t\tchar timebuf[24]; /* sized for ISO 8601 format */\n\t\tchar addrbuf[INET6_ADDRSTRLEN + 8]; /* [host]:port */\n\n\t\t/* parse the format string and generate the next path element */\n\t\tswitch (*p) {\n\t\tcase '%':\n\t\t\tp++;\n\t\t\t/* handle format specifiers. */\n\t\t\tswitch (*p) {\n\t\t\tcase '\\0':\n\t\t\t\t/* unexpected eof; backtrack and discard\n\t\t\t\t * invalid format spec */\n\t\t\t\tp--;\n\t\t\t\telem_len = 0;\n\t\t\t\tbreak;\n\t\t\tcase '%':\n\t\t\t\telem = p;\n\t\t\t\telem_len = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tif (snprintf(addrbuf, sizeof(addrbuf),\n\t\t\t\t             \"%s,%s\", dsthost, dstport) < 0) {\n\t\t\t\t\taddrbuf[0] = '?';\n\t\t\t\t\taddrbuf[1] = '\\0';\n\t\t\t\t}\n\t\t\t\telem = addrbuf;\n\t\t\t\telem_len = strlen(addrbuf);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\telem = dsthost;\n\t\t\t\telem_len = strlen(dsthost);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\telem = dstport;\n\t\t\t\telem_len = strlen(dstport);\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tif (snprintf(addrbuf, sizeof(addrbuf),\n\t\t\t\t             \"%s,%s\", srchost, srcport) < 0) {\n\t\t\t\t\taddrbuf[0] = '?';\n\t\t\t\t\taddrbuf[1] = '\\0';\n\t\t\t\t}\n\t\t\t\telem = addrbuf;\n\t\t\t\telem_len = strlen(addrbuf);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\telem = srchost;\n\t\t\t\telem_len = strlen(srchost);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\telem = srcport;\n\t\t\t\telem_len = strlen(srcport);\n\t\t\t\tbreak;\n\t\t\tcase 'x':\n\t\t\t\tif (exec_path) {\n\t\t\t\t\tchar *match = exec_path;\n\t\t\t\t\twhile ((match = strchr(match, '/')) != NULL) {\n\t\t\t\t\t\tmatch++;\n\t\t\t\t\t\telem = match;\n\t\t\t\t\t}\n\t\t\t\t\telem_len = elem ? strlen(elem) : 0;\n\t\t\t\t} else {\n\t\t\t\t\telem_len = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\telem = exec_path;\n\t\t\t\telem_len = exec_path ? strlen(exec_path) : 0;\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\telem = user;\n\t\t\t\telem_len = user ? strlen(user) : 0;\n\t\t\t\tbreak;\n\t\t\tcase 'g':\n\t\t\t\telem = group;\n\t\t\t\telem_len = group ? strlen(group) : 0;\n\t\t\t\tbreak;\n\t\t\tcase 'T': {\n\t\t\t\ttime_t epoch;\n\t\t\t\tstruct tm *utc;\n\n\t\t\t\ttime(&epoch);\n\t\t\t\tif ((utc = gmtime(&epoch)) == NULL) {\n\t\t\t\t\tsnprintf(timebuf, sizeof(timebuf), \"gmtime error\");\n\t\t\t\t} else {\n\t\t\t\t\tstrftime(timebuf, sizeof(timebuf), iso8601, utc);\n\t\t\t\t}\n\n\t\t\t\telem = timebuf;\n\t\t\t\telem_len = sizeof(timebuf);\n\t\t\t\tbreak;\n\t\t\t}}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\telem = p;\n\t\t\telem_len = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (elem_len > 0) {\n\t\t\t/* growing the buffer to fit elem_len + terminating \\0 */\n\t\t\tif (path_buflen - path_len < elem_len + 1) {\n\t\t\t\t/* Grow in PATH_BUF_INC chunks.\n\t\t\t\t * Note that the use of `PATH_BUF_INC' provides\n\t\t\t\t * our guaranteed space for a trailing '\\0' */\n\t\t\t\tpath_buflen += elem_len + PATH_BUF_INC;\n\t\t\t\tchar *newbuf = realloc(path_buf, path_buflen);\n\t\t\t\tif (newbuf == NULL) {\n\t\t\t\t\tlog_err_printf(\"failed to reallocate\"\n\t\t\t\t\t               \" path buffer\\n\");\n\t\t\t\t\tfree(path_buf);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tpath_buf = newbuf;\n\t\t\t}\n\n\t\t\tstrncat(path_buf, elem, elem_len);\n\t\t\tpath_len += elem_len;\n\t\t}\n\t}\n\n\t/* apply terminating NUL */\n\tassert(path_buflen > path_len);\n\tpath_buf[path_len] = '\\0';\n\treturn path_buf;\n}\n#undef PATH_BUF_INC\n\n/*\n * log_content_ctx_t is preallocated by the caller (part of connection ctx).\n */\nint\nlog_content_open(log_content_ctx_t *ctx, opts_t *opts,\n                 const struct sockaddr *srcaddr, socklen_t srcaddrlen,\n                 const struct sockaddr *dstaddr, socklen_t dstaddrlen,\n                 char *srchost, char *srcport,\n                 char *dsthost, char *dstport,\n                 char *exec_path, char *user, char *group)\n{\n\tchar timebuf[24];\n\ttime_t epoch;\n\tstruct tm *utc;\n\tchar *dsthost_clean = NULL;\n\tchar *srchost_clean = NULL;\n\n\tif (ctx->file || ctx->pcap\n#ifndef WITHOUT_MIRROR\n\t    || ctx->mirror\n#endif /* !WITHOUT_MIRROR */\n\t    )\n\t\treturn 0; /* does this actually happen? */\n\n\tif (opts->contentlog_isdir || opts->contentlog_isspec ||\n\t    opts->pcaplog_isdir    || opts->pcaplog_isspec) {\n\t\tif (opts->contentlog_isdir || opts->pcaplog_isdir) {\n\t\t\tif (time(&epoch) == -1) {\n\t\t\t\tlog_err_printf(\"Failed to get time\\n\");\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tif ((utc = gmtime(&epoch)) == NULL) {\n\t\t\t\tlog_err_printf(\"Failed to convert time:\"\n\t\t\t\t               \" %s (%i)\\n\",\n\t\t\t\t               strerror(errno), errno);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tif (!strftime(timebuf, sizeof(timebuf),\n\t\t\t              \"%Y%m%dT%H%M%SZ\", utc)) {\n\t\t\t\tlog_err_printf(\"Failed to format time:\"\n\t\t\t\t               \" %s (%i)\\n\",\n\t\t\t\t               strerror(errno), errno);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\n\t\tsrchost_clean = sys_ip46str_sanitize(srchost);\n\t\tif (!srchost_clean) {\n\t\t\tlog_err_printf(\"Failed to sanitize srchost\\n\");\n\t\t\tgoto errout;\n\t\t}\n\t\tdsthost_clean = sys_ip46str_sanitize(dsthost);\n\t\tif (!dsthost_clean) {\n\t\t\tlog_err_printf(\"Failed to sanitize dsthost\\n\");\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (opts->contentlog) {\n\t\tctx->file = malloc(sizeof(log_content_file_ctx_t));\n\t\tif (!ctx->file)\n\t\t\tgoto errout;\n\t\tmemset(ctx->file, 0, sizeof(log_content_file_ctx_t));\n\n\t\tif (opts->contentlog_isdir) {\n\t\t\t/* per-connection-file content log (-S) */\n\t\t\tif (asprintf(&ctx->file->u.dir.filename,\n\t\t\t             \"%s/%s-%s,%s-%s,%s.log\",\n\t\t\t             opts->contentlog, timebuf,\n\t\t\t             srchost_clean, srcport,\n\t\t\t             dsthost_clean, dstport) < 0) {\n\t\t\t\tlog_err_printf(\"Failed to format filename:\"\n\t\t\t\t               \" %s (%i)\\n\",\n\t\t\t\t               strerror(errno), errno);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t} else if (opts->contentlog_isspec) {\n\t\t\t/* per-connection-file content log with logspec (-F) */\n\t\t\tctx->file->u.spec.filename =\n\t\t\t\tlog_content_format_pathspec(opts->contentlog,\n\t\t\t\t                            srchost_clean,\n\t\t\t\t                            srcport,\n\t\t\t\t                            dsthost_clean,\n\t\t\t\t                            dstport,\n\t\t\t\t                            exec_path,\n\t\t\t\t                            user, group);\n\t\t\tif (!ctx->file->u.spec.filename) {\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t} else {\n\t\t\t/* single-file content log (-L) */\n\t\t\tif (asprintf(&ctx->file->u.single.header_req,\n\t\t\t             \"[%s]:%s -> [%s]:%s\",\n\t\t\t             srchost, srcport, dsthost, dstport) < 0) {\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tif (asprintf(&ctx->file->u.single.header_resp,\n\t\t\t             \"[%s]:%s -> [%s]:%s\",\n\t\t\t             dsthost, dstport, srchost, srcport) < 0) {\n\t\t\t\tfree(ctx->file->u.single.header_req);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (opts->pcaplog) {\n\t\tctx->pcap = malloc(sizeof(log_content_pcap_ctx_t));\n\t\tif (!ctx->pcap)\n\t\t\tgoto errout;\n\t\tmemset(ctx->pcap, 0, sizeof(log_content_pcap_ctx_t));\n\n\t\tlogpkt_ctx_init(&ctx->pcap->state, NULL, 0,\n\t\t                content_pcap_src_ether, content_pcap_dst_ether,\n\t\t                srcaddr, srcaddrlen, dstaddr, dstaddrlen);\n\n\t\tif (opts->pcaplog_isdir) {\n\t\t\t/* per-connection-file pcap log (-Y) */\n\t\t\tif (asprintf(&ctx->pcap->u.dir.filename,\n\t\t\t             \"%s/%s-%s,%s-%s,%s.pcap\",\n\t\t\t             opts->pcaplog, timebuf,\n\t\t\t             srchost_clean, srcport,\n\t\t\t             dsthost_clean, dstport) < 0) {\n\t\t\t\tlog_err_printf(\"Failed to format filename:\"\n\t\t\t\t               \" %s (%i)\\n\",\n\t\t\t\t               strerror(errno), errno);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t} else if (opts->pcaplog_isspec) {\n\t\t\t/* per-connection-file pcap log with logspec (-y) */\n\t\t\tctx->pcap->u.spec.filename =\n\t\t\t\tlog_content_format_pathspec(opts->pcaplog,\n\t\t\t\t                            srchost_clean,\n\t\t\t\t                            srcport,\n\t\t\t\t                            dsthost_clean,\n\t\t\t\t                            dstport,\n\t\t\t\t                            exec_path,\n\t\t\t\t                            user, group);\n\t\t\tif (!ctx->pcap->u.spec.filename) {\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t}\n\t}\n\n#ifndef WITHOUT_MIRROR\n\tif (opts->mirrorif) {\n\t\tctx->mirror = malloc(sizeof(log_content_mirror_ctx_t));\n\t\tif (!ctx->mirror)\n\t\t\tgoto errout;\n\t\tmemset(ctx->mirror, 0, sizeof(log_content_mirror_ctx_t));\n\n\t\tlogpkt_ctx_init(&ctx->mirror->state,\n\t\t                content_mirror_libnet,\n\t\t                content_mirror_mtu,\n\t\t                content_mirror_src_ether,\n\t\t                content_mirror_dst_ether,\n\t\t                srcaddr, srcaddrlen, dstaddr, dstaddrlen);\n\t}\n#endif /* !WITHOUT_MIRROR */\n\n\t/* submit open events */\n\tif (ctx->file) {\n\t\tif (logger_open(content_file_log, ctx->file) == -1)\n\t\t\tgoto errout;\n\t}\n\tif (ctx->pcap) {\n\t\tif (logger_open(content_pcap_log, ctx->pcap) == -1)\n\t\t\tgoto errout;\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (ctx->mirror) {\n\t\tif (logger_open(content_mirror_log, ctx->mirror) == -1)\n\t\t\tgoto errout;\n\t}\n#endif /* !WITHOUT_MIRROR */\n\n\tif (srchost_clean)\n\t\tfree(srchost_clean);\n\tif (dsthost_clean)\n\t\tfree(dsthost_clean);\n\treturn 0;\n\nerrout:\n\tif (srchost_clean)\n\t\tfree(srchost_clean);\n\tif (dsthost_clean)\n\t\tfree(dsthost_clean);\n\tif (ctx->file)\n\t\tfree(ctx->file);\n\tif (ctx->pcap) {\n\t\tfree(ctx->pcap);\n\t}\n\tif (ctx->mirror) {\n\t\tfree(ctx->mirror);\n\t}\n\tmemset(ctx, 0, sizeof(log_content_ctx_t));\n\treturn -1;\n}\n\n/*\n * On failure, lb is not freed.\n */\nint\nlog_content_submit(log_content_ctx_t *ctx, logbuf_t *lb, int is_request)\n{\n\tunsigned long prepflags = 0;\n\tlogbuf_t *lbpcap, *lbmirror;\n\n\tif (is_request)\n\t\tprepflags |= PREPFLAG_REQUEST;\n\n\tlb = logbuf_make_contiguous(lb);\n\tif (!lb)\n\t\treturn -1;\n\n\tlbpcap = lbmirror = lb;\n\tif (content_file_log) {\n\t\tif (content_pcap_log) {\n\t\t\tlbpcap = logbuf_new_deepcopy(lb, 1);\n\t\t\tif (!lbpcap)\n\t\t\t\tgoto errout;\n\t\t}\n#ifndef WITHOUT_MIRROR\n\t\tif (content_mirror_log) {\n\t\t\tlbmirror = logbuf_new_deepcopy(lb, 1);\n\t\t\tif (!lbmirror)\n\t\t\t\tgoto errout;\n\t\t}\n\t} else if (content_pcap_log && content_mirror_log) {\n\t\tlbmirror = logbuf_new_deepcopy(lb, 1);\n\t\tif (!lbmirror)\n\t\t\tgoto errout;\n#endif /* !WITHOUT_MIRROR */\n\t}\n\n\tif (content_pcap_log) {\n\t\tif (logger_submit(content_pcap_log, ctx->pcap,\n\t\t                  prepflags, lbpcap) == -1) {\n\t\t\tgoto errout;\n\t\t}\n\t\tlbpcap = NULL;\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log) {\n\t\tif (logger_submit(content_mirror_log, ctx->mirror,\n\t\t                  prepflags, lbmirror) == -1) {\n\t\t\tgoto errout;\n\t\t}\n\t\tlbmirror = NULL;\n\t}\n#endif /* !WITHOUT_MIRROR */\n\tif (content_file_log) {\n\t\tif (logger_submit(content_file_log, ctx->file,\n\t\t                  prepflags, lb) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\nerrout:\n\tif (lbpcap && lbpcap != lb)\n\t\tlogbuf_free(lbpcap);\n\tif (lbmirror && lbmirror != lb)\n\t\tlogbuf_free(lbmirror);\n\treturn -1;\n}\n\nint\nlog_content_close(log_content_ctx_t *ctx, int by_requestor)\n{\n\tunsigned long prepflags = PREPFLAG_EOF;\n\tunsigned long ctl;\n\n\tif (by_requestor) {\n\t\tprepflags |= PREPFLAG_REQUEST;\n\t\tctl = LBFLAG_IS_REQ;\n\t} else {\n\t\tctl = LBFLAG_IS_RESP;\n\t}\n\n\t/* We call submit an empty log buffer in order to give the content log\n\t * a chance to insert an EOF footer to be logged before actually\n\t * closing the file.  The logger_close() call will actually close the\n\t * log.  Some logs prefer to use the close callback for logging the\n\t * close event to the log. */\n\tif (content_file_log && ctx->file) {\n\t\tif (logger_submit(content_file_log, ctx->file,\n\t\t                  prepflags, NULL) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (logger_close(content_file_log, ctx->file, ctl) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->file = NULL;\n\t}\n\tif (content_pcap_log && ctx->pcap) {\n\t\tif (logger_submit(content_pcap_log, ctx->pcap,\n\t\t                  prepflags, NULL) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (logger_close(content_pcap_log, ctx->pcap, ctl) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->pcap = NULL;\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log && ctx->mirror) {\n\t\tif (logger_submit(content_mirror_log, ctx->mirror,\n\t\t                  prepflags, NULL) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (logger_close(content_mirror_log, ctx->mirror, ctl) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\tctx->mirror = NULL;\n\t}\n#endif /* !WITHOUT_MIRROR */\n\treturn 0;\n}\n\n/*\n * Log-type specific code.\n *\n * The init/fini functions are executed globally in the main thread.\n * Callback functions are executed in the logger thread.\n */\n\nstatic int\nlog_content_file_dir_opencb(void *fh)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif ((ctx->u.dir.fd = privsep_client_openfile(content_file_clisock,\n\t                                             ctx->u.dir.filename,\n\t                                             0)) == -1) {\n\t\tlog_err_printf(\"Opening logdir file '%s' failed: %s (%i)\\n\",\n\t\t               ctx->u.dir.filename,\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlog_content_file_dir_closecb(void *fh, UNUSED unsigned long ctl)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif (ctx->u.dir.filename)\n\t\tfree(ctx->u.dir.filename);\n\tif (ctx->u.dir.fd != 1)\n\t\tclose(ctx->u.dir.fd);\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_file_dir_writecb(void *fh, UNUSED unsigned long ctl,\n                             const void *buf, size_t sz)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif (write(ctx->u.dir.fd, buf, sz) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to content log: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn sz;\n}\n\nstatic int\nlog_content_file_spec_opencb(void *fh)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif ((ctx->u.spec.fd = privsep_client_openfile(content_file_clisock,\n\t                                              ctx->u.spec.filename,\n\t                                              1)) == -1) {\n\t\tlog_err_printf(\"Opening logspec file '%s' failed: %s (%i)\\n\",\n\t\t               ctx->u.spec.filename, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlog_content_file_spec_closecb(void *fh, UNUSED unsigned long ctl)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif (ctx->u.spec.filename)\n\t\tfree(ctx->u.spec.filename);\n\tif (ctx->u.spec.fd != -1)\n\t\tclose(ctx->u.spec.fd);\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_file_spec_writecb(void *fh, UNUSED unsigned long ctl,\n                              const void *buf, size_t sz)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif (write(ctx->u.spec.fd, buf, sz) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to content log: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn sz;\n}\n\nstatic int content_file_single_fd = -1;\nstatic char *content_file_single_fn = NULL;\n\nstatic int\nlog_content_file_single_preinit(const char *logfile)\n{\n\tcontent_file_single_fd = open(logfile, O_WRONLY|O_APPEND|O_CREAT,\n\t                       DFLT_FILEMODE);\n\tif (content_file_single_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s (%i)\\n\",\n\t\t               logfile, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tcontent_file_single_fn = strdup(logfile);\n\tif (!content_file_single_fn) {\n\t\tclose(content_file_single_fd);\n\t\tcontent_file_single_fd = -1;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlog_content_file_single_fini(void)\n{\n\tif (content_file_single_fn) {\n\t\tfree(content_file_single_fn);\n\t\tcontent_file_single_fn = NULL;\n\t}\n\tif (content_file_single_fd != -1) {\n\t\tclose(content_file_single_fd);\n\t\tcontent_file_single_fd = -1;\n\t}\n}\n\nstatic int\nlog_content_file_single_reopencb(void)\n{\n\tclose(content_file_single_fd);\n\tcontent_file_single_fd = privsep_client_openfile(content_file_clisock,\n\t                                                 content_file_single_fn,\n\t                                                 0);\n\tif (content_file_single_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s (%i)\\n\",\n\t\t               content_file_single_fn, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlog_content_file_single_closecb(void *fh, UNUSED unsigned long ctl)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\n\tif (ctx->u.single.header_req) {\n\t\tfree(ctx->u.single.header_req);\n\t}\n\tif (ctx->u.single.header_resp) {\n\t\tfree(ctx->u.single.header_resp);\n\t}\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_file_single_writecb(void *fh, UNUSED unsigned long ctl,\n                                const void *buf, size_t sz)\n{\n\tUNUSED log_content_file_ctx_t *ctx = fh;\n\n\tif (write(content_file_single_fd, buf, sz) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to content log: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn sz;\n}\n\nstatic logbuf_t *\nlog_content_file_single_prepcb(void *fh, unsigned long prepflags,\n                               logbuf_t *lb)\n{\n\tlog_content_file_ctx_t *ctx = fh;\n\tint is_request = !!(prepflags & PREPFLAG_REQUEST);\n\tlogbuf_t *head;\n\ttime_t epoch;\n\tstruct tm *utc;\n\tchar *header;\n\n\tif (!(header = is_request ? ctx->u.single.header_req\n\t                          : ctx->u.single.header_resp))\n\t\tgoto out;\n\n\t/* prepend size tag or EOF, and newline */\n\tif (prepflags & PREPFLAG_EOF) {\n\t\thead = logbuf_new_printf(NULL, \" (EOF)\\n\");\n\t} else {\n\t\thead = logbuf_new_printf(lb, \" (%zu):\\n\", logbuf_size(lb));\n\t}\n\tif (!head) {\n\t\tlog_err_printf(\"Failed to allocate memory\\n\");\n\t\tlogbuf_free(lb);\n\t\treturn NULL;\n\t}\n\tlb = head;\n\n\t/* prepend header */\n\thead = logbuf_new_copy(header, strlen(header), lb);\n\tif (!head) {\n\t\tlog_err_printf(\"Failed to allocate memory\\n\");\n\t\tlogbuf_free(lb);\n\t\treturn NULL;\n\t}\n\tlb = head;\n\n\t/* prepend timestamp */\n\thead = logbuf_new_alloc(32, lb);\n\tif (!head) {\n\t\tlog_err_printf(\"Failed to allocate memory\\n\");\n\t\tlogbuf_free(lb);\n\t\treturn NULL;\n\t}\n\tlb = head;\n\ttime(&epoch);\n\tif ((utc = gmtime(&epoch)) == NULL) {\n\t\tlog_err_printf(\"Failed to convert time\\n\");\n\t\tlogbuf_free(lb);\n\t\treturn NULL;\n\t}\n\n\tlb->sz = strftime((char*)lb->buf, lb->sz, \"%Y-%m-%d %H:%M:%S UTC \",\n\t                  utc);\n\nout:\n\treturn lb;\n}\n\n/*\n * Pcap writer for -X/-Y/-y options.\n */\nstatic int content_pcap_fd = -1;\nstatic char *content_pcap_fn = NULL;\n\n/*\n * Initialize pcap content logging.  For single-file mode, pcapfile is the\n * path to the file.  For dir/spec modes, pcapfile is NULL.\n */\nstatic int\nlog_content_pcap_preinit(const char *pcapfile)\n{\n\tif (!pcapfile)\n\t\treturn 0;\n\n\t/* single file pcap mode */\n\n\tcontent_pcap_fd = open(pcapfile, O_RDWR|O_CREAT, DFLT_FILEMODE);\n\tif (content_pcap_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s (%i)\\n\",\n\t\t               pcapfile, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (logpkt_pcap_open_fd(content_pcap_fd) == -1) {\n\t\tlog_err_printf(\"Failed to prepare '%s' for PCAP writing\"\n\t\t               \": %s (%i)\\n\",\n\t\t               pcapfile, strerror(errno), errno);\n\t\tclose(content_pcap_fd);\n\t\tcontent_pcap_fd = -1;\n\t\treturn -1;\n\t}\n\tcontent_pcap_fn = strdup(pcapfile);\n\tif (!content_pcap_fn) {\n\t\tclose(content_pcap_fd);\n\t\tcontent_pcap_fd = -1;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlog_content_pcap_fini(void)\n{\n\tif (content_pcap_fn) {\n\t\tfree(content_pcap_fn);\n\t\tcontent_pcap_fn = NULL;\n\t}\n\tif (content_pcap_fd != -1) {\n\t\tclose(content_pcap_fd);\n\t\tcontent_pcap_fd = -1;\n\t}\n}\n\nstatic int\nlog_content_pcap_reopencb(void) {\n\tclose(content_pcap_fd);\n\tcontent_pcap_fd = privsep_client_openfile(content_pcap_clisock,\n\t                                          content_pcap_fn,\n\t                                          0);\n\tif (content_pcap_fd == -1) {\n\t\tlog_err_printf(\"Failed to open '%s' for writing: %s (%i)\\n\",\n\t\t               content_pcap_fn, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (logpkt_pcap_open_fd(content_pcap_fd) == -1) {\n\t\tlog_err_printf(\"Failed to prepare '%s' for PCAP writing\"\n\t\t               \": %s (%i)\\n\",\n\t\t               content_pcap_fn, strerror(errno), errno);\n\t\tclose(content_pcap_fd);\n\t\tcontent_pcap_fd = -1;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nlog_content_pcap_closecb_base(void *fh, unsigned long ctl, int fd) {\n\tlog_content_pcap_ctx_t *ctx = fh;\n\tint direction = (ctl & LBFLAG_IS_REQ) ? LOGPKT_REQUEST\n\t                                      : LOGPKT_RESPONSE;\n\n\tlogpkt_write_close(&ctx->state, fd, direction);\n}\n\nstatic void\nlog_content_pcap_closecb(void *fh, unsigned long ctl) {\n\tlog_content_pcap_ctx_t *ctx = fh;\n\tlog_content_pcap_closecb_base(fh, ctl, content_pcap_fd);\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_pcap_writecb_base(void *fh, unsigned long ctl,\n                              const void *buf, size_t sz, int fd) {\n\tlog_content_pcap_ctx_t *ctx = fh;\n\tint direction = (ctl & LBFLAG_IS_REQ) ? LOGPKT_REQUEST\n\t                                      : LOGPKT_RESPONSE;\n\n\tif (logpkt_write_payload(&ctx->state, fd, direction, buf, sz) == -1)\n\t\tgoto errout;\n\n\treturn sz;\nerrout:\n\tlog_err_printf(\"Warning: Failed to write to pcap log: %s (%i)\\n\",\n\t               strerror(errno), errno);\n\treturn -1;\n}\n\nstatic ssize_t\nlog_content_pcap_writecb(void *fh, unsigned long ctl,\n                         const void *buf, size_t sz) {\n\treturn log_content_pcap_writecb_base(fh, ctl, buf, sz, content_pcap_fd);\n}\n\nstatic int\nlog_content_pcap_dir_opencb(void *fh)\n{\n\tlog_content_pcap_ctx_t *ctx = fh;\n\n\tif ((ctx->u.dir.fd = privsep_client_openfile(content_pcap_clisock,\n\t                                             ctx->u.dir.filename,\n\t                                             0)) == -1) {\n\t\tlog_err_printf(\"Opening pcapdir file '%s' failed: %s (%i)\\n\",\n\t\t               ctx->u.dir.filename, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn logpkt_pcap_open_fd(ctx->u.dir.fd);\n}\n\nstatic void\nlog_content_pcap_dir_closecb(void *fh, unsigned long ctl)\n{\n\tlog_content_pcap_ctx_t *ctx = fh;\n\tlog_content_pcap_closecb_base(fh, ctl, ctx->u.dir.fd);\n\tif (ctx->u.dir.filename)\n\t\tfree(ctx->u.dir.filename);\n\tif (ctx->u.dir.fd != -1)\n\t\tclose(ctx->u.dir.fd);\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_pcap_dir_writecb(void *fh, unsigned long ctl,\n                             const void *buf, size_t sz)\n{\n\tlog_content_pcap_ctx_t *ctx = fh;\n\treturn log_content_pcap_writecb_base(fh, ctl, buf, sz, ctx->u.dir.fd);\n}\n\nstatic int\nlog_content_pcap_spec_opencb(void *fh)\n{\n\tlog_content_pcap_ctx_t *ctx = fh;\n\n\tif ((ctx->u.spec.fd = privsep_client_openfile(content_pcap_clisock,\n\t                                              ctx->u.spec.filename,\n\t                                              1)) == -1) {\n\t\tlog_err_printf(\"Opening pcapspec file '%s' failed: %s (%i)\\n\",\n\t\t               ctx->u.spec.filename, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn logpkt_pcap_open_fd(ctx->u.spec.fd);\n}\n\nstatic void\nlog_content_pcap_spec_closecb(void *fh, unsigned long ctl)\n{\n\tlog_content_pcap_ctx_t *ctx = fh;\n\tlog_content_pcap_closecb_base(fh, ctl, ctx->u.spec.fd);\n\tif (ctx->u.spec.filename)\n\t\tfree(ctx->u.spec.filename);\n\tif (ctx->u.spec.fd != -1)\n\t\tclose(ctx->u.spec.fd);\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_pcap_spec_writecb(void *fh, unsigned long ctl,\n                              const void *buf, size_t sz)\n{\n\tlog_content_pcap_ctx_t *ctx = fh;\n\treturn log_content_pcap_writecb_base(fh, ctl, buf, sz, ctx->u.spec.fd);\n}\n\nstatic logbuf_t *\nlog_content_pcap_prepcb(UNUSED void *fh, unsigned long prepflags,\n                        logbuf_t *lb) {\n\t/* log_content_pcap_ctx_t *ctx = fh; */\n\tif (prepflags & PREPFLAG_EOF)\n\t\treturn lb;\n\tlogbuf_ctl_set(lb, (prepflags & PREPFLAG_REQUEST) ? LBFLAG_IS_REQ\n\t                                                  : LBFLAG_IS_RESP);\n\treturn lb;\n}\n\n/*\n * Mirror writer for -T/-I options.\n */\n\n#ifndef WITHOUT_MIRROR\nstatic int\nlog_content_mirror_preinit(const char *ifname, const char *targetip) {\n\tchar errbuf[LIBNET_ERRBUF_SIZE];\n\n\t/* cast to char* needed on OpenBSD */\n\tcontent_mirror_libnet = libnet_init(LIBNET_LINK, (char *)ifname,\n\t                                    errbuf);\n\tif (content_mirror_libnet == NULL) {\n\t\tlog_err_printf(\"Failed to init mirror libnet: %s\\n\", errbuf);\n\t\treturn -1;\n\t}\n\tlibnet_seed_prand(content_mirror_libnet);\n\n\tcontent_mirror_mtu = sys_get_mtu(ifname);\n\tif (content_mirror_mtu == 0) {\n\t\tlog_err_printf(\"Failed to lookup MTU of interface %s\\n\",\n\t\t               ifname);\n\t\treturn -1;\n\t}\n\n\tif (logpkt_ether_lookup(content_mirror_libnet,\n\t                        content_mirror_src_ether,\n\t                        content_mirror_dst_ether,\n\t                        targetip, ifname) == -1) {\n\t\tlog_err_printf(\"Failed to lookup target ether\\n\");\n\t\tlibnet_destroy(content_mirror_libnet);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nlog_content_mirror_fini(void)\n{\n\tif (content_mirror_libnet) {\n\t\tlibnet_destroy(content_mirror_libnet);\n\t}\n}\n\nstatic void\nlog_content_mirror_closecb(void *fh, unsigned long ctl) {\n\tlog_content_mirror_ctx_t *ctx = fh;\n\tint direction = (ctl & LBFLAG_IS_REQ) ? LOGPKT_REQUEST\n\t                                      : LOGPKT_RESPONSE;\n\n\tlogpkt_write_close(&ctx->state, -1, direction);\n\tfree(ctx);\n}\n\nstatic ssize_t\nlog_content_mirror_writecb(void *fh, unsigned long ctl,\n                           const void *buf, size_t sz) {\n\tlog_content_mirror_ctx_t *ctx = fh;\n\tint direction = (ctl & LBFLAG_IS_REQ) ? LOGPKT_REQUEST\n\t                                      : LOGPKT_RESPONSE;\n\n\tif (logpkt_write_payload(&ctx->state, -1, direction, buf, sz) == -1)\n\t\tgoto errout;\n\treturn sz;\n\nerrout:\n\tlog_err_printf(\"Warning: Failed to write to mirror log: %s (%i)\\n\",\n\t               strerror(errno), errno);\n\treturn -1;\n}\n\nstatic logbuf_t *\nlog_content_mirror_prepcb(UNUSED void *fh, unsigned long prepflags,\n                          logbuf_t *lb) {\n\t/* log_content_mirror_ctx_t *ctx = fh; */\n\tif (prepflags & PREPFLAG_EOF)\n\t\treturn lb;\n\tlogbuf_ctl_set(lb, (prepflags & PREPFLAG_REQUEST) ? LBFLAG_IS_REQ\n\t                                                  : LBFLAG_IS_RESP);\n\treturn lb;\n}\n#endif /* !WITHOUT_MIRROR */\n\n/*\n * Certificate writer for -w/-W options.\n */\nstatic logger_t *cert_log = NULL;\nstatic int cert_clisock = -1; /* privsep client socket for cert logger */\n\nint\nlog_cert_submit(const char *fn, X509 *crt)\n{\n\tvoid *fh;\n\tlogbuf_t *lb;\n\tchar *pem;\n\n\tif (!(fh = strdup(fn)))\n\t\tgoto errout1;\n\tif (!(pem = ssl_x509_to_pem(crt)))\n\t\tgoto errout2;\n\tif (!(lb = logbuf_new(pem, strlen(pem), NULL)))\n\t\tgoto errout2;\n\treturn logger_submit(cert_log, fh, 0, lb);\nerrout2:\n\tfree(fh);\nerrout1:\n\treturn -1;\n}\n\nstatic ssize_t\nlog_cert_writecb(void *fh, UNUSED unsigned long ctl,\n                 const void *buf, size_t sz)\n{\n\tchar *fn = fh;\n\tint fd;\n\n\tif ((fd = privsep_client_certfile(cert_clisock, fn)) == -1) {\n\t\tif (errno != EEXIST) {\n\t\t\tlog_err_printf(\"Failed to open '%s': %s (%i)\\n\",\n\t\t\t               fn, strerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\treturn sz;\n\t}\n\tif (write(fd, buf, sz) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to '%s': %s (%i)\\n\",\n\t\t               fn, strerror(errno), errno);\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\tclose(fd);\n\treturn sz;\n}\n\n\n/*\n * Initialization and destruction.\n */\n\n/*\n * Log pre-init: open all log files but don't start any threads, since we may\n * fork() after pre-initialization.\n * Return -1 on errors, 0 otherwise.\n */\nint\nlog_preinit(opts_t *opts)\n{\n\tlogger_reopen_func_t reopencb;\n\tlogger_open_func_t opencb;\n\tlogger_close_func_t closecb;\n\tlogger_write_func_t writecb;\n\tlogger_prep_func_t prepcb;\n\n\tif (opts->contentlog) {\n\t\tif (opts->contentlog_isdir) {\n\t\t\treopencb = NULL;\n\t\t\topencb = log_content_file_dir_opencb;\n\t\t\tclosecb = log_content_file_dir_closecb;\n\t\t\twritecb = log_content_file_dir_writecb;\n\t\t\tprepcb = NULL;\n\t\t} else if (opts->contentlog_isspec) {\n\t\t\treopencb = NULL;\n\t\t\topencb = log_content_file_spec_opencb;\n\t\t\tclosecb = log_content_file_spec_closecb;\n\t\t\twritecb = log_content_file_spec_writecb;\n\t\t\tprepcb = NULL;\n\t\t} else {\n\t\t\tif (log_content_file_single_preinit(opts->contentlog) == -1)\n\t\t\t\tgoto out;\n\t\t\treopencb = log_content_file_single_reopencb;\n\t\t\topencb = NULL;\n\t\t\tclosecb = log_content_file_single_closecb;\n\t\t\twritecb = log_content_file_single_writecb;\n\t\t\tprepcb = log_content_file_single_prepcb;\n\t\t}\n\t\tif (!(content_file_log = logger_new(reopencb, opencb, closecb,\n\t\t                                    writecb, prepcb,\n\t\t                                    log_exceptcb))) {\n\t\t\tlog_content_file_single_fini();\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (opts->pcaplog) {\n\t\tif (log_content_pcap_preinit((opts->pcaplog_isdir ||\n\t\t                              opts->pcaplog_isspec) ?\n\t\t                              NULL :\n\t\t                              opts->pcaplog) == -1)\n\t\t\tgoto out;\n\t\tif (opts->pcaplog_isdir) {\n\t\t\treopencb = NULL;\n\t\t\topencb = log_content_pcap_dir_opencb;\n\t\t\tclosecb = log_content_pcap_dir_closecb;\n\t\t\twritecb = log_content_pcap_dir_writecb;\n\t\t\tprepcb = log_content_pcap_prepcb;\n\t\t} else if (opts->pcaplog_isspec) {\n\t\t\treopencb = NULL;\n\t\t\topencb = log_content_pcap_spec_opencb;\n\t\t\tclosecb = log_content_pcap_spec_closecb;\n\t\t\twritecb = log_content_pcap_spec_writecb;\n\t\t\tprepcb = log_content_pcap_prepcb;\n\t\t} else {\n\t\t\treopencb = log_content_pcap_reopencb;\n\t\t\topencb = NULL;\n\t\t\tclosecb = log_content_pcap_closecb;\n\t\t\twritecb = log_content_pcap_writecb;\n\t\t\tprepcb = log_content_pcap_prepcb;\n\t\t}\n\t\tif (!(content_pcap_log = logger_new(reopencb, opencb, closecb,\n\t\t                                    writecb, prepcb,\n\t\t                                    log_exceptcb))) {\n\t\t\tlog_content_pcap_fini();\n\t\t\tgoto out;\n\t\t}\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (opts->mirrorif) {\n\t\tif (log_content_mirror_preinit(opts->mirrorif,\n\t\t                               opts->mirrortarget) == -1)\n\t\t\tgoto out;\n\t\treopencb = NULL;\n\t\topencb = NULL;\n\t\tclosecb = log_content_mirror_closecb;\n\t\twritecb = log_content_mirror_writecb;\n\t\tprepcb = log_content_mirror_prepcb;\n\t\tif (!(content_mirror_log = logger_new(reopencb, opencb, closecb,\n\t\t                                      writecb, prepcb,\n\t\t                                      log_exceptcb))) {\n\t\t\tlog_content_mirror_fini();\n\t\t\tgoto out;\n\t\t}\n\t}\n#endif /* !WITHOUT_MIRROR */\n\tif (opts->connectlog) {\n\t\tif (log_connect_preinit(opts->connectlog) == -1)\n\t\t\tgoto out;\n\t\tif (!(connect_log = logger_new(log_connect_reopencb,\n\t\t                               NULL, NULL,\n\t\t                               log_connect_writecb, NULL,\n\t\t                               log_exceptcb))) {\n\t\t\tlog_connect_fini();\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (opts->masterkeylog) {\n\t\tif (log_masterkey_preinit(opts->masterkeylog) == -1)\n\t\t\tgoto out;\n\t\tif (!(masterkey_log = logger_new(log_masterkey_reopencb,\n\t\t                                 NULL, NULL,\n\t\t                                 log_masterkey_writecb, NULL,\n\t\t                                 log_exceptcb))) {\n\t\t\tlog_masterkey_fini();\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (opts->certgendir) {\n\t\tif (!(cert_log = logger_new(NULL, NULL, NULL, log_cert_writecb,\n\t\t                            NULL, log_exceptcb)))\n\t\t\tgoto out;\n\t}\n\tif (!(err_log = logger_new(NULL, NULL, NULL, log_err_writecb, NULL,\n\t                           log_exceptcb)))\n\t\tgoto out;\n\treturn 0;\n\nout:\n\tif (connect_log) {\n\t\tlog_connect_fini();\n\t\tlogger_free(connect_log);\n\t}\n\tif (content_file_log) {\n\t\tlog_content_file_single_fini();\n\t\tlogger_free(content_file_log);\n\t}\n\tif (content_pcap_log) {\n\t\tlog_content_pcap_fini();\n\t\tlogger_free(content_pcap_log);\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log) {\n\t\tlog_content_mirror_fini();\n\t\tlogger_free(content_mirror_log);\n\t}\n#endif /* !WITHOUT_MIRROR */\n\tif (cert_log) {\n\t\tlogger_free(cert_log);\n\t}\n\tif (masterkey_log) {\n\t\tlog_masterkey_fini();\n\t\tlogger_free(masterkey_log);\n\t}\n\treturn -1;\n}\n\n/*\n * Close all file descriptors opened by log_preinit; used in privsep parent.\n * Only undo content, connect and masterkey logs, leave error and debug log\n * functional.\n */\nvoid\nlog_preinit_undo(void)\n{\n\tif (connect_log) {\n\t\tlog_connect_fini();\n\t\tlogger_free(connect_log);\n\t}\n\tif (content_file_log) {\n\t\tlog_content_file_single_fini();\n\t\tlogger_free(content_file_log);\n\t}\n\tif (content_pcap_log) {\n\t\tlog_content_pcap_fini();\n\t\tlogger_free(content_pcap_log);\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log) {\n\t\tlog_content_mirror_fini();\n\t\tlogger_free(content_mirror_log);\n\t}\n#endif /* !WITHOUT_MIRROR */\n\tif (masterkey_log) {\n\t\tlog_masterkey_fini();\n\t\tlogger_free(masterkey_log);\n\t}\n}\n\n/*\n * Log post-init: start logging threads.\n * Return -1 on errors, 0 otherwise.\n */\nint\nlog_init(opts_t *opts, proxy_ctx_t *ctx, int clisock[5])\n{\n\tproxy_ctx = ctx;\n\tif (err_log)\n\t\tif (logger_start(err_log) == -1)\n\t\t\treturn -1;\n\tif (!opts->debug) {\n\t\terr_shortcut_logger = 1;\n\t}\n\n\tif (masterkey_log) {\n\t\tmasterkey_clisock = clisock[0];\n\t\tif (logger_start(masterkey_log) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tprivsep_client_close(clisock[0]);\n\t}\n\n\tif (connect_log) {\n\t\tconnect_clisock = clisock[1];\n\t\tif (logger_start(connect_log) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tprivsep_client_close(clisock[1]);\n\t}\n\n\tif (content_file_log) {\n\t\tcontent_file_clisock = clisock[2];\n\t\tif (logger_start(content_file_log) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tprivsep_client_close(clisock[2]);\n\t}\n\n\tif (content_pcap_log) {\n\t\tcontent_pcap_clisock = clisock[3];\n\t\tif (logger_start(content_pcap_log) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tprivsep_client_close(clisock[3]);\n\t}\n\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log) {\n\t\tif (logger_start(content_mirror_log) == -1)\n\t\t\treturn -1;\n\t}\n#endif /* !WITHOUT_MIRROR */\n\n\tif (cert_log) {\n\t\tcert_clisock = clisock[4];\n\t\tif (logger_start(cert_log) == -1)\n\t\t\treturn -1;\n\t} else {\n\t\tprivsep_client_close(clisock[4]);\n\t}\n\treturn 0;\n}\n\n/*\n * Drain and cleanup.  Tell all loggers to leave, then join all logger threads,\n * and finally free resources and close log files.\n */\nvoid\nlog_fini(void)\n{\n\t/* switch back to direct logging so we can still log errors while\n\t * tearing down the logging infrastructure */\n\terr_shortcut_logger = 1;\n\n\tif (cert_log)\n\t\tlogger_leave(cert_log);\n\tif (masterkey_log)\n\t\tlogger_leave(masterkey_log);\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log)\n\t\tlogger_leave(content_mirror_log);\n#endif /* !WITHOUT_MIRROR */\n\tif (content_pcap_log)\n\t\tlogger_leave(content_pcap_log);\n\tif (content_file_log)\n\t\tlogger_leave(content_file_log);\n\tif (connect_log)\n\t\tlogger_leave(connect_log);\n\tif (err_log)\n\t\tlogger_leave(err_log);\n\n\tif (cert_log)\n\t\tlogger_join(cert_log);\n\tif (masterkey_log)\n\t\tlogger_join(masterkey_log);\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log)\n\t\tlogger_join(content_mirror_log);\n#endif /* !WITHOUT_MIRROR */\n\tif (content_pcap_log)\n\t\tlogger_join(content_pcap_log);\n\tif (content_file_log)\n\t\tlogger_join(content_file_log);\n\tif (connect_log)\n\t\tlogger_join(connect_log);\n\tif (err_log)\n\t\tlogger_join(err_log);\n\n\tif (cert_log)\n\t\tlogger_free(cert_log);\n\tif (masterkey_log)\n\t\tlogger_free(masterkey_log);\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log)\n\t\tlogger_free(content_mirror_log);\n#endif /* !WITHOUT_MIRROR */\n\tif (content_pcap_log)\n\t\tlogger_free(content_pcap_log);\n\tif (content_file_log)\n\t\tlogger_free(content_file_log);\n\tif (connect_log)\n\t\tlogger_free(connect_log);\n\tif (err_log)\n\t\tlogger_free(err_log);\n\n\tif (masterkey_log)\n\t\tlog_masterkey_fini();\n#ifndef WITHOUT_MIRROR\n\tif (content_mirror_log)\n\t\tlog_content_mirror_fini();\n#endif /* !WITHOUT_MIRROR */\n\tif (content_pcap_log)\n\t\tlog_content_pcap_fini();\n\tif (content_file_log)\n\t\tlog_content_file_single_fini();\n\tif (connect_log)\n\t\tlog_connect_fini();\n\n\tif (masterkey_clisock != -1)\n\t\tprivsep_client_close(masterkey_clisock);\n\tif (cert_clisock != -1)\n\t\tprivsep_client_close(cert_clisock);\n\tif (content_file_clisock != -1)\n\t\tprivsep_client_close(content_file_clisock);\n\tif (content_pcap_clisock != -1)\n\t\tprivsep_client_close(content_pcap_clisock);\n\tif (connect_clisock != -1)\n\t\tprivsep_client_close(connect_clisock);\n}\n\nint\nlog_reopen(void)\n{\n\tint rv = 0;\n\n\tif (masterkey_log)\n\t\tif (logger_reopen(masterkey_log) == -1)\n\t\t\trv = -1;\n\tif (content_pcap_log)\n\t\tif (logger_reopen(content_pcap_log) == -1)\n\t\t\trv = -1;\n\tif (content_file_log)\n\t\tif (logger_reopen(content_file_log) == -1)\n\t\t\trv = -1;\n\tif (connect_log)\n\t\tif (logger_reopen(connect_log) == -1)\n\t\t\trv = -1;\n\n\treturn rv;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 4.05078125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef LOG_H\n#define LOG_H\n\n#include \"opts.h\"\n#include \"proxy.h\"\n#include \"logger.h\"\n#include \"attrib.h\"\n\nint log_err_printf(const char *, ...) PRINTF(1,2);\nvoid log_err_mode(int);\n#define LOG_ERR_MODE_STDERR 0\n#define LOG_ERR_MODE_SYSLOG 1\n\nint log_dbg_printf(const char *, ...) PRINTF(1,2);\nint log_dbg_print_free(char *);\nint log_dbg_write_free(void *, size_t);\nvoid log_dbg_mode(int);\n#define LOG_DBG_MODE_NONE 0\n#define LOG_DBG_MODE_ERRLOG 1\n\nextern logger_t *masterkey_log;\n#define log_masterkey_printf(fmt, ...) \\\n        logger_printf(masterkey_log, NULL, 0, (fmt), __VA_ARGS__)\n#define log_masterkey_print(s) \\\n        logger_print(masterkey_log, NULL, 0, (s))\n#define log_masterkey_write(buf, sz) \\\n        logger_write(masterkey_log, NULL, 0, (buf), (sz))\n#define log_masterkey_print_free(s) \\\n        logger_print_freebuf(masterkey_log, NULL, 0, (s))\n#define log_masterkey_write_free(buf, sz) \\\n        logger_write_freebuf(masterkey_log, NULL, 0, (buf), (sz))\n\nextern logger_t *connect_log;\n#define log_connect_printf(fmt, ...) \\\n        logger_printf(connect_log, NULL, 0, (fmt), __VA_ARGS__)\n#define log_connect_print(s) \\\n        logger_print(connect_log, NULL, 0, (s))\n#define log_connect_write(buf, sz) \\\n        logger_write(connect_log, NULL, 0, (buf), (sz))\n#define log_connect_print_free(s) \\\n        logger_print_freebuf(connect_log, NULL, 0, (s))\n#define log_connect_write_free(buf, sz) \\\n        logger_write_freebuf(connect_log, NULL, 0, (buf), (sz))\n\ntypedef struct log_content_ctx log_content_ctx_t;\nstruct log_content_file_ctx;\nstruct log_content_pcap_ctx;\nstruct log_content_mirror_ctx;\nstruct log_content_ctx {\n\tstruct log_content_file_ctx *file;\n\tstruct log_content_pcap_ctx *pcap;\n\tstruct log_content_mirror_ctx *mirror;\n};\nint log_content_open(log_content_ctx_t *, opts_t *,\n                     const struct sockaddr *, socklen_t,\n                     const struct sockaddr *, socklen_t,\n                     char *, char *, char *, char *,\n                     char *, char *, char *) NONNULL(1,2,3) WUNRES;\nint log_content_submit(log_content_ctx_t *, logbuf_t *, int)\n                       NONNULL(1,2) WUNRES;\nint log_content_close(log_content_ctx_t *, int) NONNULL(1) WUNRES;\nint log_content_split_pathspec(const char *, char **,\n                               char **) NONNULL(1,2,3) WUNRES;\n\nint log_cert_submit(const char *, X509 *) NONNULL(1,2) WUNRES;\n\nint log_preinit(opts_t *) NONNULL(1) WUNRES;\nvoid log_preinit_undo(void);\nint log_init(opts_t *, proxy_ctx_t *, int[5]) NONNULL(1,2) WUNRES;\nvoid log_fini(void);\nint log_reopen(void) WUNRES;\nvoid log_exceptcb(void);\n\n#endif /* !LOG_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logbuf.c",
          "type": "blob",
          "size": 5.7568359375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"logbuf.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n\n/*\n * Dynamic log buffer with zero-copy chaining, generic void * file handle\n * and ctl for status control flags.\n * Logbuf always owns the internal allocated buffer.\n */\n\n/*\n * Create new logbuf from provided, pre-allocated buffer, set fd and next.\n * The provided buffer will be freed by logbuf_free() if non-NULL, and by\n * logbuf_new() in case it fails returning NULL.\n */\nlogbuf_t *\nlogbuf_new(void *buf, size_t sz, logbuf_t *next)\n{\n\tlogbuf_t *lb;\n\n\tif (!(lb = malloc(sizeof(logbuf_t)))) {\n\t\tif (buf)\n\t\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tlb->buf = buf;\n\tlb->sz = sz;\n\tif (next) {\n\t\tlb->fh = next->fh;\n\t\tlb->ctl = next->ctl;\n\t\tlb->next = next;\n\t} else {\n\t\tlb->fh = NULL;\n\t\tlb->ctl = 0;\n\t\tlb->next = NULL;\n\t}\n\treturn lb;\n}\n\n/*\n * Create new logbuf, allocating sz bytes into the internal buffer.\n */\nlogbuf_t *\nlogbuf_new_alloc(size_t sz, logbuf_t *next)\n{\n\tlogbuf_t *lb;\n\n\tif (!(lb = malloc(sizeof(logbuf_t))))\n\t\treturn NULL;\n\tif (!(lb->buf = malloc(sz))) {\n\t\tfree(lb);\n\t\treturn NULL;\n\t}\n\tlb->sz = sz;\n\tif (next) {\n\t\tlb->fh = next->fh;\n\t\tlb->ctl = next->ctl;\n\t\tlb->next = next;\n\t} else {\n\t\tlb->fh = NULL;\n\t\tlb->ctl = 0;\n\t\tlb->next = NULL;\n\t}\n\treturn lb;\n}\n\n/*\n * Create new logbuf, copying buf into a newly allocated internal buffer.\n */\nlogbuf_t *\nlogbuf_new_copy(const void *buf, size_t sz, logbuf_t *next)\n{\n\tlogbuf_t *lb;\n\n\tif (!(lb = malloc(sizeof(logbuf_t))))\n\t\treturn NULL;\n\tif (!(lb->buf = malloc(sz))) {\n\t\tfree(lb);\n\t\treturn NULL;\n\t}\n\tmemcpy(lb->buf, buf, sz);\n\tlb->sz = sz;\n\tif (next) {\n\t\tlb->fh = next->fh;\n\t\tlb->ctl = next->ctl;\n\t\tlb->next = next;\n\t} else {\n\t\tlb->fh = NULL;\n\t\tlb->ctl = 0;\n\t\tlb->next = NULL;\n\t}\n\treturn lb;\n}\n\n/*\n * Create new logbuf using printf.\n */\nlogbuf_t *\nlogbuf_new_printf(logbuf_t *next, const char *fmt, ...)\n{\n\tva_list ap;\n\tlogbuf_t *lb;\n\n\tif (!(lb = malloc(sizeof(logbuf_t))))\n\t\treturn NULL;\n\tva_start(ap, fmt);\n\tlb->sz = vasprintf((char**)&lb->buf, fmt, ap);\n\tva_end(ap);\n\tif (lb->sz < 0) {\n\t\tfree(lb);\n\t\treturn NULL;\n\t}\n\tif (next) {\n\t\tlb->fh = next->fh;\n\t\tlb->ctl = next->ctl;\n\t\tlb->next = next;\n\t} else {\n\t\tlb->fh = NULL;\n\t\tlb->ctl = 0;\n\t\tlb->next = NULL;\n\t}\n\treturn lb;\n}\n\n/*\n * Create new logbuf from lb.  If combine is set, combine all the buffer\n * segments into a single contiguous one.  Otherwise, copy segment by segment.\n */\nlogbuf_t *\nlogbuf_new_deepcopy(logbuf_t *lb, int combine)\n{\n\tlogbuf_t *lbnew;\n\tunsigned char *p;\n\n\tif (!lb)\n\t\treturn NULL;\n\n\tif (combine) {\n\t\tlbnew = logbuf_new_alloc(logbuf_size(lb), NULL);\n\t\tif (!lbnew)\n\t\t\treturn NULL;\n\t\tlbnew->fh = lb->fh;\n\t\tlbnew->ctl = lb->ctl;\n\t\tp = lbnew->buf;\n\t\twhile (lb) {\n\t\t\tmemcpy(p, lb->buf, lb->sz);\n\t\t\tp += lb->sz;\n\t\t\tlb = lb->next;\n\t\t}\n\t} else {\n\t\tlbnew = logbuf_new_copy(lb->buf, lb->sz, NULL);\n\t\tif (!lbnew)\n\t\t\treturn NULL;\n\t\tlbnew->fh = lb->fh;\n\t\tlbnew->ctl = lb->ctl;\n\t\tlbnew->next = logbuf_new_deepcopy(lb->next, 0);\n\t}\n\treturn lbnew;\n}\n\nlogbuf_t *\nlogbuf_make_contiguous(logbuf_t *lb) {\n\tunsigned char *p;\n\tlogbuf_t *lbtmp;\n\n\tif (!lb)\n\t\treturn NULL;\n\tif (!lb->next)\n\t\treturn lb;\n\tp = realloc(lb->buf, logbuf_size(lb));\n\tif (!p)\n\t\treturn NULL;\n\tlb->buf = p;\n\tlbtmp = lb;\n\tp += lbtmp->sz;\n\twhile ((lbtmp = lbtmp->next)) {\n\t\tmemcpy(p, lbtmp->buf, lbtmp->sz);\n\t\tlb->sz += lbtmp->sz;\n\t\tp += lbtmp->sz;\n\t}\n\tlogbuf_free(lb->next);\n\tlb->next = NULL;\n\treturn lb;\n}\n\n/*\n * Calculate the total size of the logbuf and all chained buffers.\n */\nssize_t\nlogbuf_size(logbuf_t *lb)\n{\n\tssize_t sz;\n\n\tsz = lb->sz;\n\tif (lb->next) {\n\t\tsz += logbuf_size(lb->next);\n\t}\n\treturn sz;\n}\n\n/*\n * Write content of logbuf using writefunc and free all buffers.\n * Returns -1 on errors and sets errno according to write().\n * Returns total of bytes written by 1 .. n write() calls on success.\n */\nssize_t\nlogbuf_write_free(logbuf_t *lb, writefunc_t writefunc)\n{\n\tssize_t rv1, rv2 = 0;\n\trv1 = writefunc(lb->fh, lb->ctl, lb->buf, lb->sz);\n\tif (lb->buf) {\n\t\tfree(lb->buf);\n\t}\n\tif (lb->next) {\n\t\tif (rv1 == -1) {\n\t\t\tlogbuf_free(lb->next);\n\t\t} else {\n\t\t\tlb->next->fh = lb->fh;\n\t\t\trv2 = logbuf_write_free(lb->next, writefunc);\n\t\t}\n\t}\n\tfree(lb);\n\tif (rv1 == -1 || rv2 == -1)\n\t\treturn -1;\n\telse\n\t\treturn rv1 + rv2;\n}\n\n/*\n * Free logbuf including internal and chained buffers.\n */\nvoid\nlogbuf_free(logbuf_t *lb)\n{\n\tif (lb->buf) {\n\t\tfree(lb->buf);\n\t}\n\tif (lb->next) {\n\t\tlogbuf_free(lb->next);\n\t}\n\tfree(lb);\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logbuf.h",
          "type": "blob",
          "size": 2.783203125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef LOGBUF_H\n#define LOGBUF_H\n\n#include \"attrib.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n\ntypedef struct logbuf {\n\tunsigned char *buf;\n\tssize_t sz;\n\tvoid *fh;\n\tunsigned long ctl;\n\tstruct logbuf *next;\n} logbuf_t;\n\ntypedef ssize_t (*writefunc_t)(void *, unsigned long, const void *, size_t);\n\nlogbuf_t * logbuf_new(void *, size_t, logbuf_t *) MALLOC;\nlogbuf_t * logbuf_new_alloc(size_t, logbuf_t *) MALLOC;\nlogbuf_t * logbuf_new_copy(const void *, size_t, logbuf_t *) MALLOC;\nlogbuf_t * logbuf_new_printf(logbuf_t *, const char *, ...) MALLOC PRINTF(2,3);\nlogbuf_t * logbuf_new_deepcopy(logbuf_t *, int) MALLOC;\nlogbuf_t * logbuf_make_contiguous(logbuf_t *) WUNRES;\nssize_t logbuf_size(logbuf_t *) NONNULL(1) WUNRES;\nssize_t logbuf_write_free(logbuf_t *, writefunc_t) NONNULL(1);\nvoid logbuf_free(logbuf_t *) NONNULL(1);\n\n#define logbuf_ctl_clear(x) (x)->ctl = 0\n#define logbuf_ctl_set(x, y) (x)->ctl |= (y)\n#define logbuf_ctl_unset(x, y) (x)->ctl &= ~(y)\n#define logbuf_ctl_isset(x, y) (!!((x)->ctl & (y)))\n\n#define LBFLAG_REOPEN   (1 << 0)        /* logger */\n#define LBFLAG_OPEN     (1 << 1)        /* logger */\n#define LBFLAG_CLOSE    (1 << 2)        /* logger */\n#define LBFLAG_IS_REQ   (1 << 3)        /* pcap/mirror content log */\n#define LBFLAG_IS_RESP  (1 << 4)        /* pcap/mirror content log */\n\n#endif /* !LOGBUF_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logbuf.t.c",
          "type": "blob",
          "size": 2.1962890625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"logbuf.h\"\n\n#include <string.h>\n\n#include <check.h>\n\nSTART_TEST(logbuf_make_contiguous_01)\n{\n\tlogbuf_t *lb;\n\n\tlb = logbuf_new_printf(NULL, \"%s\", \"789\");\n\tlb = logbuf_new_printf(lb, \"%s\", \"456\");\n\tlb = logbuf_new_printf(lb, \"%s\", \"123\");\n\tlb = logbuf_make_contiguous(lb);\n\tfail_unless(!!lb, \"logbuf_make_contiguous failed\");\n\tfail_unless(!lb->next, \"multiple buffers\");\n\tfail_unless(logbuf_size(lb) == 9, \"buffer size incorrect\");\n\tfail_unless(!memcmp(lb->buf, \"123456789\", 9), \"buffer value incorrect\");\n\tlogbuf_free(lb);\n}\nEND_TEST\n\nSuite *\nlogbuf_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"logbuf\");\n\n\ttc = tcase_create(\"\");\n\ttcase_add_test(tc, logbuf_make_contiguous_01);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logger.c",
          "type": "blob",
          "size": 8.8974609375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"logger.h\"\n\n#include \"thrqueue.h\"\n#include \"logbuf.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <string.h>\n\n/*\n * Logger for multithreaded environments.  Disk writes are executed in a\n * writer thread.  Logging threads submit buffers to be logged by adding\n * them to the thrqueue.  Logging threads may block on the pthread mutex\n * of the thrqueue, but not on disk writes.\n */\n\nstruct logger {\n\tpthread_t thr;\n\tlogger_reopen_func_t reopen;\n\tlogger_open_func_t open;\n\tlogger_close_func_t close;\n\tlogger_prep_func_t prep;\n\tlogger_write_func_t write;\n\tlogger_except_func_t except;\n\tthrqueue_t *queue;\n};\n\nstatic void\nlogger_clear(logger_t *logger)\n{\n\tmemset(logger, 0, sizeof(logger_t));\n}\n\n/*\n * Create new logger with a set of specific function callbacks:\n *\n * reopenfunc:  handle SIGHUP for the log by reopening all open files across\n *              multiple connections\n * openfunc:    open a new log for a new connection\n * closefunc:   close a log for a connection\n * writefunc:   write a single logbuf to the log\n * prepfunc:    prepare a log buffer before adding it to the logbuffer's queue\n * exceptfunc:  called after failed callback operations\n *\n * All callbacks except prepfunc will be executed in the logger's writer\n * thread, not in the thread calling logger_submit().  Prepfunc will be called\n * in the thread calling logger_submit().\n */\nlogger_t *\nlogger_new(logger_reopen_func_t reopenfunc, logger_open_func_t openfunc,\n           logger_close_func_t closefunc, logger_write_func_t writefunc,\n           logger_prep_func_t prepfunc, logger_except_func_t exceptfunc)\n{\n\tlogger_t *logger;\n\n\tlogger = malloc(sizeof(logger_t));\n\tif (!logger)\n\t\treturn NULL;\n\tlogger_clear(logger);\n\tlogger->reopen = reopenfunc;\n\tlogger->open = openfunc;\n\tlogger->close = closefunc;\n\tlogger->write = writefunc;\n\tlogger->prep = prepfunc;\n\tlogger->except = exceptfunc;\n\tlogger->queue = NULL;\n\treturn logger;\n}\n\n/*\n * Free the logger data structures.  Caller must call logger_stop()\n * or logger_leave() and logger_join() prior to freeing.\n */\nvoid\nlogger_free(logger_t *logger) {\n\tif (logger->queue) {\n\t\tthrqueue_free(logger->queue);\n\t}\n\tfree(logger);\n}\n\n/*\n * Submit a buffer to be logged by the logger thread.\n * Calls the prep callback from within the calling tread before submission.\n * Buffer guaranteed to be freed after logging completes or on failure.\n * Returns -1 on error, 0 on success (including logging a NULL logbuf, which\n * is a no-op).\n */\nint\nlogger_submit(logger_t *logger, void *fh, unsigned long prepflags,\n              logbuf_t *lb)\n{\n\tif (lb) {\n\t\tlb->fh = fh;\n\t\tlogbuf_ctl_clear(lb);\n\t}\n\tif (logger->prep)\n\t\tlb = logger->prep(fh, prepflags, lb);\n\t/* If we got passed lb == NULL and prep callback did not replace it\n\t * with an actual log buffer, stop here. */\n\tif (!lb)\n\t\treturn 0;\n\tif (thrqueue_enqueue(logger->queue, lb)) {\n\t\treturn 0;\n\t} else {\n\t\tlogbuf_free(lb);\n\t\treturn -1;\n\t}\n}\n\n/*\n * Submit a log reopen event to the logger thread.\n */\nint\nlogger_reopen(logger_t *logger)\n{\n\tlogbuf_t *lb;\n\n\tif (!logger->reopen)\n\t\treturn 0;\n\n\tif (!(lb = logbuf_new(NULL, 0, NULL)))\n\t\treturn -1;\n\tlogbuf_ctl_set(lb, LBFLAG_REOPEN);\n\treturn thrqueue_enqueue(logger->queue, lb) ? 0 : -1;\n}\n\n/*\n * Submit a file open event to the logger thread.\n * fh is the file handle; an opaque unique address identifying the new file.\n * If no open callback is configured, returns successfully.\n * Returns 0 on success, -1 on failure.\n */\nint\nlogger_open(logger_t *logger, void *fh)\n{\n\tlogbuf_t *lb;\n\n\tif (!logger->open)\n\t\treturn 0;\n\n\tif (!(lb = logbuf_new(NULL, 0, NULL)))\n\t\treturn -1;\n\tlb->fh = fh;\n\tlogbuf_ctl_set(lb, LBFLAG_OPEN);\n\treturn thrqueue_enqueue(logger->queue, lb) ? 0 : -1;\n}\n\n/*\n * Submit a file close event to the logger thread.\n * If no close callback is configured, returns successfully.\n * Returns 0 on success, -1 on failure.\n */\nint\nlogger_close(logger_t *logger, void *fh, unsigned long ctl)\n{\n\tlogbuf_t *lb;\n\n\tif (!logger->close)\n\t\treturn 0;\n\n\tif (!(lb = logbuf_new(NULL, 0, NULL)))\n\t\treturn -1;\n\tlb->fh = fh;\n\tlb->ctl = ctl;\n\tlogbuf_ctl_set(lb, LBFLAG_CLOSE);\n\treturn thrqueue_enqueue(logger->queue, lb) ? 0 : -1;\n}\n\n/*\n * Logger thread main function.\n */\nstatic void *\nlogger_thread(void *arg)\n{\n\tlogger_t *logger = arg;\n\tlogbuf_t *lb;\n\tint e = 0;\n\n\twhile ((lb = thrqueue_dequeue(logger->queue))) {\n\t\tif (logbuf_ctl_isset(lb, LBFLAG_REOPEN)) {\n\t\t\tif (logger->reopen() != 0)\n\t\t\t\te = 1;\n\t\t\tlogbuf_free(lb);\n\t\t} else if (logbuf_ctl_isset(lb, LBFLAG_OPEN)) {\n\t\t\tif (logger->open(lb->fh) != 0)\n\t\t\t\te = 1;\n\t\t\tlogbuf_free(lb);\n\t\t} else if (logbuf_ctl_isset(lb, LBFLAG_CLOSE)) {\n\t\t\tlogger->close(lb->fh, lb->ctl);\n\t\t\tlogbuf_free(lb);\n\t\t} else {\n\t\t\tif (logbuf_write_free(lb, logger->write) < 0)\n\t\t\t\te = 1;\n\t\t}\n\n\t\tif (e && logger->except) {\n\t\t\tlogger->except();\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n/*\n * Start the logger's write thread.\n */\nint\nlogger_start(logger_t *logger) {\n\tint rv;\n\n\tif (logger->queue) {\n\t\tthrqueue_free(logger->queue);\n\t}\n\tlogger->queue = thrqueue_new(1024);\n\n\trv = pthread_create(&logger->thr, NULL, logger_thread, logger);\n\tif (rv)\n\t\treturn -1;\n\tsched_yield();\n\treturn 0;\n}\n\n/*\n * Tell the logger's write thread to write all pending write requests\n * and then exit.  Don't wait for the logger to exit.\n */\nvoid\nlogger_leave(logger_t *logger) {\n\tthrqueue_unblock_dequeue(logger->queue);\n\tsched_yield();\n}\n\n/*\n * Wait for the logger to exit.\n */\nint\nlogger_join(logger_t *logger) {\n\tint rv;\n\n\trv = pthread_join(logger->thr, NULL);\n\tif (rv)\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Tell the logger's write thread to write all pending write requests\n * and then exit; wait for the logger to exit.\n */\nint\nlogger_stop(logger_t *logger) {\n\tlogger_leave(logger);\n\treturn logger_join(logger);\n}\n\n/*\n * Generic print to a logger.  These functions should be called by the\n * actual worker thread(s) doing network I/O.\n *\n * _printf(), _print() and _write() copy the input buffers.\n * _ncprint() and _ncwrite() will free() the input buffers.\n *\n * The file descriptor argument is a virtual or real system file descriptor\n * used for multiplexing write requests to several files over the same\n * logger.  This argument is passed to the write handler as-is and is not\n * interpreted or used by the logger itself in any way.\n *\n * All of the functions return 0 on success, -1 on failure.\n */\nint\nlogger_printf(logger_t *logger, void *fh, unsigned long prepflags,\n              const char *fmt, ...)\n{\n\tva_list ap;\n\tlogbuf_t *lb;\n\n\tif (!(lb = logbuf_new(NULL, 0, NULL)))\n\t\treturn -1;\n\tva_start(ap, fmt);\n\tlb->sz = vasprintf((char**)&lb->buf, fmt, ap);\n\tva_end(ap);\n\tif (lb->sz < 0) {\n\t\tlogbuf_free(lb);\n\t\treturn -1;\n\t}\n\treturn logger_submit(logger, fh, prepflags, lb);\n}\nint\nlogger_write(logger_t *logger, void *fh, unsigned long prepflags,\n             const void *buf, size_t sz)\n{\n\tlogbuf_t *lb;\n\n\tif (!(lb = logbuf_new_copy(buf, sz, NULL)))\n\t\treturn -1;\n\treturn logger_submit(logger, fh, prepflags, lb);\n}\nint\nlogger_print(logger_t *logger, void *fh, unsigned long prepflags,\n             const char *s)\n{\n\tlogbuf_t *lb;\n\n\tif (!(lb = logbuf_new_copy(s, strlen(s), NULL)))\n\t\treturn -1;\n\treturn logger_submit(logger, fh, prepflags, lb);\n}\nint\nlogger_write_freebuf(logger_t *logger, void *fh, unsigned long prepflags,\n                     void *buf, size_t sz)\n{\n\tlogbuf_t *lb;\n\n\tif (!(lb = logbuf_new(buf, sz, NULL)))\n\t\treturn -1;\n\treturn logger_submit(logger, fh, prepflags, lb);\n}\nint\nlogger_print_freebuf(logger_t *logger, void *fh, unsigned long prepflags,\n                     char *s)\n{\n\treturn logger_write_freebuf(logger, fh, prepflags, s, strlen(s));\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logger.h",
          "type": "blob",
          "size": 3.3076171875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef LOGGER_H\n#define LOGGER_H\n\n#include \"logbuf.h\"\n#include \"attrib.h\"\n\n#include <unistd.h>\n#include <pthread.h>\n\ntypedef int (*logger_reopen_func_t)(void);\ntypedef int (*logger_open_func_t)(void *);\ntypedef void (*logger_close_func_t)(void *, unsigned long);\ntypedef ssize_t (*logger_write_func_t)(void *, unsigned long,\n                                       const void *, size_t);\ntypedef logbuf_t * (*logger_prep_func_t)(void *, unsigned long, logbuf_t *);\ntypedef void (*logger_except_func_t)(void);\ntypedef struct logger logger_t;\n\nlogger_t * logger_new(logger_reopen_func_t, logger_open_func_t,\n                      logger_close_func_t, logger_write_func_t,\n                      logger_prep_func_t, logger_except_func_t)\n                      NONNULL(4,6) MALLOC;\nvoid logger_free(logger_t *) NONNULL(1);\nint logger_start(logger_t *) NONNULL(1) WUNRES;\nvoid logger_leave(logger_t *) NONNULL(1);\nint logger_join(logger_t *) NONNULL(1);\nint logger_stop(logger_t *) NONNULL(1) WUNRES;\nint logger_reopen(logger_t *) NONNULL(1) WUNRES;\nint logger_open(logger_t *, void *) NONNULL(1,2) WUNRES;\nint logger_close(logger_t *, void *, unsigned long) NONNULL(1,2) WUNRES;\nint logger_submit(logger_t *, void *, unsigned long,\n                  logbuf_t *) NONNULL(1) WUNRES;\nint logger_printf(logger_t *, void *, unsigned long,\n                  const char *, ...) PRINTF(4,5) NONNULL(1,4) WUNRES;\nint logger_print(logger_t *, void *, unsigned long,\n                 const char *) NONNULL(1,4) WUNRES;\nint logger_write(logger_t *, void *, unsigned long,\n                 const void *, size_t) NONNULL(1,4) WUNRES;\nint logger_print_freebuf(logger_t *, void *, unsigned long,\n                         char *) NONNULL(1,4) WUNRES;\nint logger_write_freebuf(logger_t *, void *, unsigned long,\n                         void *, size_t) NONNULL(1,4) WUNRES;\n\n#endif /* !LOGGER_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logpkt.c",
          "type": "blob",
          "size": 26.8359375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"logpkt.h\"\n\n#include \"sys.h\"\n#include \"log.h\"\n\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <netinet/ip.h>\n#include <errno.h>\n#include <time.h>\n\n#ifndef WITHOUT_MIRROR\n#include <pcap.h>\n#endif /* !WITHOUT_MIRROR */\n\ntypedef struct __attribute__((packed)) {\n\tuint32_t magic_number;  /* magic number */\n\tuint16_t version_major; /* major version number */\n\tuint16_t version_minor; /* minor version number */\n\tuint32_t thiszone;      /* GMT to local correction */\n\tuint32_t sigfigs;       /* accuracy of timestamps */\n\tuint32_t snaplen;       /* max length of captured packets, in octets */\n\tuint32_t network;       /* data link type */\n} pcap_file_hdr_t;\n\ntypedef struct __attribute__((packed)) {\n\tuint32_t ts_sec;        /* timestamp seconds */\n\tuint32_t ts_usec;       /* timestamp microseconds */\n\tuint32_t incl_len;      /* number of octets of packet saved in file */\n\tuint32_t orig_len;      /* actual length of packet */\n} pcap_rec_hdr_t;\n\n#define PCAP_MAGIC      0xa1b2c3d4\n\ntypedef struct __attribute__((packed)) {\n\tuint8_t  dst_mac[ETHER_ADDR_LEN];\n\tuint8_t  src_mac[ETHER_ADDR_LEN];\n\tuint16_t ethertype;\n} ether_hdr_t;\n\n#ifndef ETHERTYPE_IP\n#define ETHERTYPE_IP    0x0800\n#endif\n#ifndef ETHERTYPE_IPV6\n#define ETHERTYPE_IPV6  0x86dd\n#endif\n\ntypedef struct __attribute__((packed)) {\n\tuint8_t  version_ihl;\n\tuint8_t  dscp_ecn;\n\tuint16_t len;\n\tuint16_t id;\n\tuint16_t frag;\n\tuint8_t  ttl;\n\tuint8_t  proto;\n\tuint16_t chksum;\n\tuint32_t src_addr;\n\tuint32_t dst_addr;\n} ip4_hdr_t;\n\ntypedef struct __attribute__((packed)) {\n\tuint32_t flags;\n\tuint16_t len;\n\tuint8_t  next_hdr;\n\tuint8_t  hop_limit;\n\tuint8_t  src_addr[16];\n\tuint8_t  dst_addr[16];\n} ip6_hdr_t;\n\ntypedef struct __attribute__((packed)) {\n\tuint16_t src_port;\n\tuint16_t dst_port;\n\tuint32_t seq;\n\tuint32_t ack;\n\tuint16_t flags;\n\tuint16_t win;\n\tuint16_t chksum;\n\tuint16_t urgp;\n} tcp_hdr_t;\n\n#ifndef TH_FIN\n#define TH_FIN          0x01\n#endif\n#ifndef TH_SYN\n#define TH_SYN          0x02\n#endif\n#ifndef TH_RST\n#define TH_RST          0x04\n#endif\n#ifndef TH_PUSH\n#define TH_PUSH         0x08\n#endif\n#ifndef TH_ACK\n#define TH_ACK          0x10\n#endif\n\n/*\n * *MTU* is the size of the largest layer 3 packet, including IP header.\n *\n * *MAX_PKTSZ* is the buffer size needed to construct a layer 2 frame\n * containing the largest possible layer 3 packet allowed by MTU.\n *\n * *MSS_IP4* and *MSS_IP6* are the maximum TCP segment sizes that fit into a\n * single IPv4 and IPv6 packet, respectively.\n *\n * The calculations assume no IPv4 options and no IPv6 option headers.\n *\n * These constants are only used for PCAP writing, not for mirroring.\n */\n#define MTU             1500\n#define MAX_PKTSZ       (MTU + sizeof(ether_hdr_t))\n#define MSS_IP4         (MTU - sizeof(ip4_hdr_t) - sizeof(tcp_hdr_t))\n#define MSS_IP6         (MTU - sizeof(ip6_hdr_t) - sizeof(tcp_hdr_t))\n\n/*\n * IP/TCP checksumming operating on uint32_t intermediate state variable C.\n */\n#define CHKSUM_INIT(C) \\\n\t{ \\\n\t\t(C) = 0; \\\n\t}\n#define CHKSUM_ADD_RANGE(C,B,S) \\\n\t{ \\\n\t\tuint16_t *p = (uint16_t *)(B); \\\n\t\tsize_t words = (S) >> 1; \\\n\t\twhile (words--) { \\\n\t\t\t(C) += *p++; \\\n\t\t} \\\n\t\tif ((S) & 1) { \\\n\t\t\t(C) += htons(*((char *)p) << 8); \\\n\t\t} \\\n\t}\n#define CHKSUM_ADD_UINT32(C,U) \\\n\t{ \\\n\t\t(C) += ((U) >> 16) + ((U) & 0xFFFF); \\\n\t}\n#define CHKSUM_ADD_UINT16(C,U) \\\n\t{ \\\n\t\t(C) += (U); \\\n\t}\n#define CHKSUM_FINALIZE(C) \\\n\t{ \\\n\t\t(C) = ((C) >> 16) + ((C) & 0xffff); \\\n\t\t(C) += ((C) >> 16); \\\n\t\t(C) = ~(C); \\\n\t}\n\n/* Socket address typecasting shorthand notations. */\n#define CSA(X)          ((const struct sockaddr *)(X))\n#define CSIN(X)         ((const struct sockaddr_in *)(X))\n#define CSIN6(X)        ((const struct sockaddr_in6 *)(X))\n\nstatic int\nlogpkt_write_all(int fd, const void *data, size_t sz)\n{\n\tconst char *ptr = data;\n\twhile (sz > 0) {\n\t\tssize_t w = write(fd, ptr, sz);\n\t\tif (w == -1 && errno == EINTR)\n\t\t\tcontinue;\n\t\tif (w == -1)\n\t\t\treturn -1;\n\t\tptr += w;\n\t\tsz -= w;\n\t}\n\treturn 0;\n}\n\n/*\n * Write the PCAP file-level header to file descriptor *fd* open for writing,\n * positioned at the beginning of an empty file.\n *\n * Returns 0 on success and -1 on failure.\n */\nstatic int\nlogpkt_write_global_pcap_hdr(int fd)\n{\n\tpcap_file_hdr_t hdr;\n\n\tmemset(&hdr, 0x0, sizeof(hdr));\n\thdr.magic_number = PCAP_MAGIC;\n\thdr.version_major = 2;\n\thdr.version_minor = 4;\n\thdr.snaplen = MAX_PKTSZ;\n\thdr.network = 1;\n\treturn logpkt_write_all(fd, &hdr, sizeof(hdr));\n}\n\n/*\n * Called on a file descriptor open for reading and writing.\n * If the fd points to an empty file, a pcap header is added and 0 is returned.\n * If the fd points to a file with PCAP magic bytes, the file position is moved\n * to the end of the file and 0 is returned.\n * If the fd points to a file without PCAP magic bytes, the file is truncated\n * to zero bytes and a new PCAP header is written.\n * On a return value of 0, the caller can continue to write PCAP records to the\n * file descriptor.  On error, -1 is returned and the file descriptor is in an\n * undefined but still open state.\n */\nint\nlogpkt_pcap_open_fd(int fd) {\n\tpcap_file_hdr_t hdr;\n\toff_t sz;\n\tssize_t n;\n\n\tsz = lseek(fd, 0, SEEK_END);\n\tif (sz == -1)\n\t\treturn -1;\n\n\tif (sz > 0) {\n\t\tif (lseek(fd, 0, SEEK_SET) == -1)\n\t\t\treturn -1;\n\t\tn = read(fd, &hdr, sizeof(pcap_file_hdr_t));\n\t\tif (n != sizeof(pcap_file_hdr_t))\n\t\t\treturn -1;\n\t\tif (hdr.magic_number == PCAP_MAGIC)\n\t\t\treturn lseek(fd, 0, SEEK_END) == -1 ? -1 : 0;\n\t\tif (lseek(fd, 0, SEEK_SET) == -1)\n\t\t\treturn -1;\n\t\tif (ftruncate(fd, 0) == -1)\n\t\t\treturn -1;\n\t}\n\n\treturn logpkt_write_global_pcap_hdr(fd);\n}\n\n/*\n * Initialize the per-connection packet crafting context.  For mirroring,\n * *libnet* must be an initialized libnet instance and *mtu* must be the\n * target interface MTU greater than 0.  For PCAP writing, *libnet* must be\n * NULL and *mtu* must be 0.  The ether and sockaddr addresses are used as the\n * layer 2 and layer 3 addresses respectively.  For mirroring, the ethers must\n * match the actual link layer addresses to be used when sending traffic, not\n * some emulated addresses.\n */\nvoid\nlogpkt_ctx_init(logpkt_ctx_t *ctx, libnet_t *libnet, size_t mtu,\n                const uint8_t *src_ether, const uint8_t *dst_ether,\n                const struct sockaddr *src_addr, socklen_t src_addr_len,\n                const struct sockaddr *dst_addr, socklen_t dst_addr_len)\n{\n\tctx->libnet = libnet;\n\tmemcpy(ctx->src_ether, src_ether, ETHER_ADDR_LEN);\n\tmemcpy(ctx->dst_ether, dst_ether, ETHER_ADDR_LEN);\n\tmemcpy(&ctx->src_addr, src_addr, src_addr_len);\n\tmemcpy(&ctx->dst_addr, dst_addr, dst_addr_len);\n\tctx->src_seq = 0;\n\tctx->dst_seq = 0;\n\tif (mtu) {\n\t\tctx->mss = mtu - sizeof(tcp_hdr_t)\n\t\t               - (dst_addr->sa_family == AF_INET\n\t\t                  ? sizeof(ip4_hdr_t)\n\t\t                  : sizeof(ip6_hdr_t));\n\t} else {\n\t\tctx->mss = dst_addr->sa_family == AF_INET ? MSS_IP4 : MSS_IP6;\n\t}\n}\n\n/*\n * Write the layer 2 frame contained in *pkt* to file descriptor *fd* already\n * open for writing.  First writes a PCAP record header, then the actual frame.\n */\nstatic int\nlogpkt_pcap_write(const uint8_t *pkt, size_t pktsz, int fd)\n{\n\tpcap_rec_hdr_t rec_hdr;\n\tstruct timespec tv;\n\n\tif (clock_gettime(CLOCK_REALTIME, &tv) == -1)\n\t{\n\t\tlog_err_printf(\"Error getting current time: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\trec_hdr.ts_sec = tv.tv_sec;\n\trec_hdr.ts_usec = tv.tv_nsec / 1000;\n\trec_hdr.orig_len = rec_hdr.incl_len = pktsz;\n\n\tif (logpkt_write_all(fd, &rec_hdr, sizeof(rec_hdr)) == -1) {\n\t\tlog_err_printf(\"Error writing pcap record hdr: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\tif (logpkt_write_all(fd, pkt, pktsz) == -1) {\n\t\tlog_err_printf(\"Error writing pcap record: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Build a frame from the given layer 2, layer 3 and layer 4 parameters plus\n * payload, write the resulting bytes into buffer pointed to by *pkt*, and fix\n * the checksums on all layers.  The receiving buffer must be at least\n * MAX_PKTSZ bytes large and payload must be a maximum of MSS_IP4 or MSS_IP6\n * respectively.  Layer 2 is Ethernet II, layer 3 is IPv4 or IPv6 depending on\n * the address family of *dst_addr*, and layer 4 is TCP.\n *\n * This function is stateless.  For header fields that cannot be directly\n * derived from the arguments, default values will be used.\n */\nstatic size_t\nlogpkt_pcap_build(uint8_t *pkt,\n                  uint8_t *src_ether, uint8_t *dst_ether,\n                  const struct sockaddr *src_addr,\n                  const struct sockaddr *dst_addr,\n                  char flags, uint32_t seq, uint32_t ack,\n                  const uint8_t *payload, size_t payloadlen)\n{\n\tether_hdr_t *ether_hdr;\n\tip4_hdr_t *ip4_hdr;\n\tip6_hdr_t *ip6_hdr;\n\ttcp_hdr_t *tcp_hdr;\n\tsize_t sz;\n\tuint32_t sum;\n\n\tether_hdr = (ether_hdr_t *)pkt;\n\tmemcpy(ether_hdr->src_mac, src_ether, sizeof(ether_hdr->src_mac));\n\tmemcpy(ether_hdr->dst_mac, dst_ether, sizeof(ether_hdr->dst_mac));\n\tsz = sizeof(ether_hdr_t);\n\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tether_hdr->ethertype = htons(ETHERTYPE_IP);\n\t\tip4_hdr = (ip4_hdr_t *)(((uint8_t *)ether_hdr) +\n\t\t                        sizeof(ether_hdr_t));\n\t\tip4_hdr->version_ihl = 0x45; /* version 4, ihl 5 words */\n\t\tip4_hdr->dscp_ecn = 0;\n\t\tip4_hdr->len = htons(sizeof(ip4_hdr_t) +\n\t\t                     sizeof(tcp_hdr_t) + payloadlen);\n\t\tip4_hdr->id = sys_rand16(),\n\t\tip4_hdr->frag = 0;\n\t\tip4_hdr->ttl = 64;\n\t\tip4_hdr->proto = IPPROTO_TCP;\n\t\tip4_hdr->src_addr = CSIN(src_addr)->sin_addr.s_addr;\n\t\tip4_hdr->dst_addr = CSIN(dst_addr)->sin_addr.s_addr;\n\t\tip4_hdr->chksum = 0;\n\t\tCHKSUM_INIT(sum);\n\t\tCHKSUM_ADD_RANGE(sum, ip4_hdr, sizeof(ip4_hdr_t));\n\t\tCHKSUM_FINALIZE(sum);\n\t\tip4_hdr->chksum = sum;\n\t\tsz += sizeof(ip4_hdr_t);\n\t\ttcp_hdr = (tcp_hdr_t *)(((uint8_t *)ip4_hdr) +\n\t\t                        sizeof(ip4_hdr_t));\n\t\ttcp_hdr->src_port = CSIN(src_addr)->sin_port;\n\t\ttcp_hdr->dst_port = CSIN(dst_addr)->sin_port;\n\t\t/* pseudo header */\n\t\tCHKSUM_INIT(sum);\n\t\tCHKSUM_ADD_UINT32(sum, ip4_hdr->src_addr);\n\t\tCHKSUM_ADD_UINT32(sum, ip4_hdr->dst_addr);\n\t\tCHKSUM_ADD_UINT16(sum, htons(ip4_hdr->proto));\n\t\tCHKSUM_ADD_UINT16(sum, htons(sizeof(tcp_hdr_t) + payloadlen));\n\t} else {\n\t\tether_hdr->ethertype = htons(ETHERTYPE_IPV6);\n\t\tip6_hdr = (ip6_hdr_t *)(((uint8_t *)ether_hdr) +\n\t\t                        sizeof(ether_hdr_t));\n\t\tip6_hdr->flags = htonl(0x60000000UL); /* version 6 */\n\t\tip6_hdr->len = htons(sizeof(tcp_hdr_t) + payloadlen);\n\t\tip6_hdr->next_hdr = IPPROTO_TCP;\n\t\tip6_hdr->hop_limit = 255;\n\t\tmemcpy(ip6_hdr->src_addr, CSIN6(src_addr)->sin6_addr.s6_addr,\n\t\t       sizeof(ip6_hdr->src_addr));\n\t\tmemcpy(ip6_hdr->dst_addr, CSIN6(dst_addr)->sin6_addr.s6_addr,\n\t\t       sizeof(ip6_hdr->dst_addr));\n\t\tsz += sizeof(ip6_hdr_t);\n\t\ttcp_hdr = (tcp_hdr_t *)(((uint8_t *)ip6_hdr) +\n\t\t                        sizeof(ip6_hdr_t));\n\t\ttcp_hdr->src_port = CSIN6(src_addr)->sin6_port;\n\t\ttcp_hdr->dst_port = CSIN6(dst_addr)->sin6_port;\n\t\t/* pseudo header */\n\t\tCHKSUM_INIT(sum);\n\t\tCHKSUM_ADD_RANGE(sum, ip6_hdr->src_addr,\n\t\t                 sizeof(ip6_hdr->src_addr));\n\t\tCHKSUM_ADD_RANGE(sum, ip6_hdr->dst_addr,\n\t\t                 sizeof(ip6_hdr->dst_addr));\n\t\tCHKSUM_ADD_UINT32(sum, (uint32_t)ip6_hdr->len);\n\t\tCHKSUM_ADD_UINT16(sum, htons(IPPROTO_TCP));\n\t}\n\ttcp_hdr->seq = htonl(seq);\n\ttcp_hdr->ack = htonl(ack);\n\ttcp_hdr->flags = htons(0x5000|flags); /* data offset 5 words */\n\ttcp_hdr->win = htons(32767);\n\ttcp_hdr->urgp = 0;\n\ttcp_hdr->chksum = 0;\n\tsz += sizeof(tcp_hdr_t);\n\tmemcpy(((uint8_t *)tcp_hdr) + sizeof(tcp_hdr_t), payload, payloadlen);\n\tCHKSUM_ADD_RANGE(sum, tcp_hdr, sizeof(tcp_hdr_t) + payloadlen);\n\tCHKSUM_FINALIZE(sum);\n\ttcp_hdr->chksum = sum;\n\treturn sz + payloadlen;\n}\n\n#ifndef WITHOUT_MIRROR\n/*\n * Build a packet using libnet intended for mirroring mode.  The packet will\n * be dynamically allocated on the heap by the libnet instance *libnet*.\n */\nstatic int\nlogpkt_mirror_build(libnet_t *libnet,\n                    uint8_t *src_ether, uint8_t *dst_ether,\n                    const struct sockaddr *src_addr,\n                    const struct sockaddr *dst_addr,\n                    char flags, uint32_t seq, uint32_t ack,\n                    const uint8_t *payload, size_t payloadlen)\n{\n\tlibnet_ptag_t ptag;\n\n\tptag = libnet_build_tcp(htons(src_addr->sa_family == AF_INET\n\t                        ? CSIN(src_addr)->sin_port\n\t                        : CSIN6(src_addr)->sin6_port),\n\t                        htons(dst_addr->sa_family == AF_INET\n\t                        ? CSIN(dst_addr)->sin_port\n\t                        : CSIN6(dst_addr)->sin6_port),\n\t                        seq,\n\t                        ack,\n\t                        flags,\n\t                        32767,          /* window size */\n\t                        0,              /* checksum */\n\t                        0,              /* urgent pointer */\n\t                        LIBNET_TCP_H + payloadlen,\n\t                        (uint8_t *)payload, payloadlen,\n\t                        libnet, 0);\n\tif (ptag == -1) {\n\t\tlog_err_printf(\"Error building tcp header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\treturn -1;\n\t}\n\n\tif (dst_addr->sa_family == AF_INET) {\n\t\tptag = libnet_build_ipv4(LIBNET_IPV4_H + LIBNET_TCP_H +\n\t\t                         payloadlen,\n\t\t                         0,             /* TOS */\n\t\t                         (uint16_t)\n\t\t                         sys_rand16(),  /* id */\n\t\t                         0x4000,        /* frag */\n\t\t                         64,            /* TTL */\n\t\t                         IPPROTO_TCP,   /* protocol */\n\t\t                         0,             /* checksum */\n\t\t                         CSIN(src_addr)->sin_addr.s_addr,\n\t\t                         CSIN(dst_addr)->sin_addr.s_addr,\n\t\t                         NULL, 0,\n\t\t                         libnet, 0);\n\t} else {\n\t\tptag = libnet_build_ipv6(0,             /* traffic class */\n\t\t                         0,             /* flow label */\n\t\t                         LIBNET_TCP_H + payloadlen,\n\t\t                         IPPROTO_TCP,\n\t\t                         255,           /* hop limit */\n\t\t                         *(struct libnet_in6_addr *)\n\t\t                         &CSIN6(src_addr)->sin6_addr,\n\t\t                         *(struct libnet_in6_addr *)\n\t\t                         &CSIN6(dst_addr)->sin6_addr,\n\t\t                         NULL, 0,\n\t\t                         libnet, 0);\n\t}\n\tif (ptag == -1) {\n\t\tlog_err_printf(\"Error building ip header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\treturn -1;\n\t}\n\n\tptag = libnet_build_ethernet(dst_ether,\n\t                             src_ether,\n\t                             dst_addr->sa_family == AF_INET\n\t                                     ? ETHERTYPE_IP : ETHERTYPE_IPV6,\n\t                             NULL, 0,\n\t                             libnet, 0);\n\tif (ptag == -1) {\n\t\tlog_err_printf(\"Error building ethernet header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif /* !WITHOUT_MIRROR */\n\n/*\n * Write a single packet to either PCAP (*fd* != -1) or a network interface\n * (*fd* == -1).  Caller must ensure that *ctx* was initialized accordingly.\n * The packet will be in direction *direction*, use TCP flags *flags*, and\n * transmit a payload *payload*.  TCP sequence and acknowledgement numbers as\n * well as source and destination identifiers are taken from *ctx*.\n *\n * Caller must ensure that *payload* fits into a frame depending on the MTU\n * selected (interface in mirroring mode, MTU value in PCAP writing mode).\n */\nstatic int\nlogpkt_write_packet(logpkt_ctx_t *ctx, int fd, int direction, char flags,\n                    const uint8_t *payload, size_t payloadlen)\n{\n\tint rv;\n\n\tif (fd != -1) {\n\t\tuint8_t buf[MAX_PKTSZ];\n\t\tsize_t sz;\n\t\tif (direction == LOGPKT_REQUEST) {\n\t\t\tsz = logpkt_pcap_build(buf,\n\t\t\t                       ctx->src_ether, ctx->dst_ether,\n\t\t\t                       CSA(&ctx->src_addr),\n\t\t\t                       CSA(&ctx->dst_addr),\n\t\t\t                       flags,\n\t\t\t                       ctx->src_seq, ctx->dst_seq,\n\t\t\t                       payload, payloadlen);\n\t\t} else {\n\t\t\tsz = logpkt_pcap_build(buf,\n\t\t\t                       ctx->dst_ether, ctx->src_ether,\n\t\t\t                       CSA(&ctx->dst_addr),\n\t\t\t                       CSA(&ctx->src_addr),\n\t\t\t                       flags,\n\t\t\t                       ctx->dst_seq, ctx->src_seq,\n\t\t\t                       payload, payloadlen);\n\t\t}\n\t\trv = logpkt_pcap_write(buf, sz, fd);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error writing packet to PCAP file\\n\");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n#ifndef WITHOUT_MIRROR\n\t\t/* Source and destination ether are determined by the actual\n\t\t * local MAC address and target MAC address for mirroring the\n\t\t * packets to; use them as-is for both directions. */\n\t\tif (direction == LOGPKT_REQUEST) {\n\t\t\trv = logpkt_mirror_build(ctx->libnet,\n\t\t\t                         ctx->src_ether, ctx->dst_ether,\n\t\t\t                         CSA(&ctx->src_addr),\n\t\t\t                         CSA(&ctx->dst_addr),\n\t\t\t                         flags,\n\t\t\t                         ctx->src_seq, ctx->dst_seq,\n\t\t\t                         payload, payloadlen);\n\t\t} else {\n\t\t\trv = logpkt_mirror_build(ctx->libnet,\n\t\t\t                         ctx->dst_ether, ctx->src_ether,\n\t\t\t                         CSA(&ctx->dst_addr),\n\t\t\t                         CSA(&ctx->src_addr),\n\t\t\t                         flags,\n\t\t\t                         ctx->dst_seq, ctx->src_seq,\n\t\t\t                         payload, payloadlen);\n\t\t}\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error building packet\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\trv = libnet_write(ctx->libnet);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error writing packet: %s\\n\",\n\t\t\t               libnet_geterror(ctx->libnet));\n\t\t}\n\t\tlibnet_clear_packet(ctx->libnet);\n#else /* WITHOUT_MIRROR */\n\t\trv = -1;\n#endif /* WITHOUT_MIRROR */\n\t}\n\treturn rv;\n}\n\n/*\n * Emulate the initial SYN handshake.\n */\nstatic int\nlogpkt_write_syn_handshake(logpkt_ctx_t *ctx, int fd)\n{\n\tctx->src_seq = sys_rand32();\n\tif (logpkt_write_packet(ctx, fd, LOGPKT_REQUEST,\n\t                        TH_SYN, NULL, 0) == -1)\n\t\treturn -1;\n\tctx->src_seq += 1;\n\tctx->dst_seq = sys_rand32();\n\tif (logpkt_write_packet(ctx, fd, LOGPKT_RESPONSE,\n\t                        TH_SYN|TH_ACK, NULL, 0) == -1)\n\t\treturn -1;\n\tctx->dst_seq += 1;\n\tif (logpkt_write_packet(ctx, fd, LOGPKT_REQUEST,\n\t                        TH_ACK, NULL, 0) == -1)\n\t\treturn -1;\n\treturn 0;\n}\n\n/*\n * Emulate the necessary packets to write a single payload segment.  If\n * necessary, a SYN handshake will automatically be generated before emitting\n * the packet carrying the payload plus a matching ACK.\n */\nint\nlogpkt_write_payload(logpkt_ctx_t *ctx, int fd, int direction,\n                     const uint8_t *payload, size_t payloadlen)\n{\n\tint other_direction = (direction == LOGPKT_REQUEST) ? LOGPKT_RESPONSE\n\t                                                    : LOGPKT_REQUEST;\n\n\tif (ctx->src_seq == 0) {\n\t\tif (logpkt_write_syn_handshake(ctx, fd) == -1)\n\t\t\treturn -1;\n\t}\n\n\twhile (payloadlen > 0) {\n\t\tsize_t n = payloadlen > ctx->mss ? ctx->mss : payloadlen;\n\t\tif (logpkt_write_packet(ctx, fd, direction,\n\t\t                        TH_PUSH|TH_ACK, payload, n) == -1) {\n\t\t\tlog_err_printf(\"Warning: Failed to write to pcap log\"\n\t\t\t               \": %s\\n\", strerror(errno));\n\t\t\treturn -1;\n\t\t}\n\t\tif (direction == LOGPKT_REQUEST) {\n\t\t\tctx->src_seq += n;\n\t\t} else {\n\t\t\tctx->dst_seq += n;\n\t\t}\n\t\tpayload += n;\n\t\tpayloadlen -= n;\n\t}\n\n\tif (logpkt_write_packet(ctx, fd, other_direction,\n\t                        TH_ACK, NULL, 0) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write to pcap log: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Emulate a connection close, emitting a FIN handshake in the correct\n * direction.  Does not close the file descriptor.\n */\nint\nlogpkt_write_close(logpkt_ctx_t *ctx, int fd, int direction) {\n\tint other_direction = (direction == LOGPKT_REQUEST) ? LOGPKT_RESPONSE\n\t                                                    : LOGPKT_REQUEST;\n\n\tif (ctx->src_seq == 0) {\n\t\tif (logpkt_write_syn_handshake(ctx, fd) == -1)\n\t\t\treturn -1;\n\t}\n\n\tif (logpkt_write_packet(ctx, fd, direction,\n\t                        TH_FIN|TH_ACK, NULL, 0) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write packet\\n\");\n\t\treturn -1;\n\t}\n\tif (direction == LOGPKT_REQUEST) {\n\t\tctx->src_seq += 1;\n\t} else {\n\t\tctx->dst_seq += 1;\n\t}\n\n\tif (logpkt_write_packet(ctx, fd, other_direction,\n\t                        TH_FIN|TH_ACK, NULL, 0) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write packet\\n\");\n\t\treturn -1;\n\t}\n\tif (other_direction == LOGPKT_REQUEST) {\n\t\tctx->src_seq += 1;\n\t} else {\n\t\tctx->dst_seq += 1;\n\t}\n\n\tif (logpkt_write_packet(ctx, fd, direction,\n\t                        TH_ACK, NULL, 0) == -1) {\n\t\tlog_err_printf(\"Warning: Failed to write packet\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#ifndef WITHOUT_MIRROR\ntypedef struct {\n\tuint32_t ip;\n\tint result;\n\tuint8_t ether[ETHER_ADDR_LEN];\n} logpkt_recv_arp_reply_ctx_t;\n\n/*\n * Receive a single ARP reply and copy the resulting ether to ctx->ether.\n */\nstatic void\nlogpkt_recv_arp_reply(uint8_t *user,\n                      UNUSED const struct pcap_pkthdr *h,\n                      const uint8_t *packet)\n{\n\tlogpkt_recv_arp_reply_ctx_t *ctx = (logpkt_recv_arp_reply_ctx_t*)user;\n\tstruct libnet_802_3_hdr *heth = (void*)packet;\n\tstruct libnet_arp_hdr *harp = (void*)((char*)heth + LIBNET_ETH_H);\n\n\t/* skip if wrong protocol */\n\tif (htons(harp->ar_op) != ARPOP_REPLY)\n\t\treturn;\n\tif (htons(harp->ar_pro) != ETHERTYPE_IP)\n\t\treturn;\n\tif (htons(harp->ar_hrd) != ARPHRD_ETHER)\n\t\treturn;\n\n\t/* skip if wrong target IP address */\n\tif (!!memcmp(&ctx->ip, (char*)harp + harp->ar_hln + LIBNET_ARP_H, 4))\n\t\treturn;\n\n\t/* skip if source ether mismatch */\n\tif (!!memcmp((u_char*)harp + sizeof(struct libnet_arp_hdr),\n\t             heth->_802_3_shost, ETHER_ADDR_LEN))\n\t\treturn;\n\n\tmemcpy(ctx->ether,\n\t       (u_char*)harp + sizeof(struct libnet_arp_hdr),\n\t       ETHER_ADDR_LEN);\n\tctx->result = 0;\n}\n\n/*\n * Look up the appropriate source and destination ethernet addresses for\n * mirroring packets to dst_ip_s on interface dst_if_s.\n * Only IPv4 mirror targets are supported.\n */\nint\nlogpkt_ether_lookup(libnet_t *libnet,\n                    uint8_t *src_ether, uint8_t *dst_ether,\n                    const char *dst_ip_s, const char *dst_if_s)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\n\tuint8_t broadcast_ether[ETHER_ADDR_LEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tuint8_t zero_ether[ETHER_ADDR_LEN] = {\n\t\t0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\tstruct libnet_ether_addr *src_ether_addr;\n\tuint32_t src_ip;\n\tstruct bpf_program bp;\n\tint count = 50;\n\tlogpkt_recv_arp_reply_ctx_t ctx;\n\n\t/* handle case of just spitting packets out, not caring about a dest */\n\tif (!dst_ip_s) {\n\t\tuint8_t src[ETHER_ADDR_LEN] = {\n\t\t\t0x1, 0x1, 0x1, 0x1, 0x1, 0x1};\n\t\tuint8_t dst[ETHER_ADDR_LEN] = {\n\t\t\t0x2, 0x2, 0x2, 0x2, 0x2, 0x2};\n\t\tmemcpy(src_ether, &src, ETHER_ADDR_LEN);\n\t\tmemcpy(dst_ether, &dst, ETHER_ADDR_LEN);\n\t\treturn 0;\n\t}\n\n\tif (sys_get_af(dst_ip_s) != AF_INET) {\n\t\tlog_err_printf(\"Mirroring target must be an IPv4 address.\\n\");\n\t\treturn -1;\n\t}\n\n\tctx.result = -1;\n\tctx.ip = libnet_name2addr4(libnet, (char *)dst_ip_s,\n\t                           LIBNET_DONT_RESOLVE);\n\tif (ctx.ip == (uint32_t)-1) {\n\t\tlog_err_printf(\"Error converting dst IP address: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\tsrc_ip = libnet_get_ipaddr4(libnet);\n\tif (src_ip == (uint32_t)-1) {\n\t\tlog_err_printf(\"Error getting src IP address: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\tsrc_ether_addr = libnet_get_hwaddr(libnet);\n\tif (src_ether_addr == NULL) {\n\t\tlog_err_printf(\"Error getting src ethernet address: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\tmemcpy(src_ether, src_ether_addr->ether_addr_octet, ETHER_ADDR_LEN);\n\n\tif (libnet_autobuild_arp(ARPOP_REQUEST,\n\t                         src_ether,\n\t                         (uint8_t*)&src_ip,\n\t                         zero_ether,\n\t                         (uint8_t*)&ctx.ip,\n\t                         libnet) == -1) {\n\t\tlog_err_printf(\"Error building arp header: %s\\n\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\n\tif (libnet_autobuild_ethernet(broadcast_ether,\n\t                              ETHERTYPE_ARP,\n\t                              libnet) == -1) {\n\t\tlog_err_printf(\"Error building ethernet header: %s\",\n\t\t               libnet_geterror(libnet));\n\t\tgoto out;\n\t}\n\n\tpcap_t *pcap = pcap_open_live(dst_if_s, 100, 0, 10, errbuf);\n\tif (pcap == NULL) {\n\t\tlog_err_printf(\"Error in pcap_open_live(): %s\\n\", errbuf);\n\t\tgoto out;\n\t}\n\n\tif (pcap_compile(pcap, &bp, \"arp\", 0, -1) == -1) {\n\t\tlog_err_printf(\"Error in pcap_compile(): %s\\n\",\n\t\t               pcap_geterr(pcap));\n\t\tgoto out2;\n\t}\n\tif (pcap_setfilter(pcap, &bp) == -1) {\n\t\tlog_err_printf(\"Error in pcap_setfilter(): %s\\n\",\n\t\t               pcap_geterr(pcap));\n\t\tgoto out3;\n\t}\n\n\tdo {\n\t\tif (libnet_write(libnet) != -1) {\n\t\t\t/* Limit # of packets to process, so we can loop to\n\t\t\t * send arp requests on busy networks. */\n\t\t\tif (pcap_dispatch(pcap, 1000,\n\t\t\t                  (pcap_handler)logpkt_recv_arp_reply,\n\t\t\t                  (u_char*)&ctx) < 0) {\n\t\t\t\tlog_err_printf(\"Error in pcap_dispatch(): %s\\n\",\n\t\t\t\t               pcap_geterr(pcap));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_err_printf(\"Error writing arp packet: %s\",\n\t\t\t               libnet_geterror(libnet));\n\t\t\tbreak;\n\t\t}\n\t\tsleep(1);\n\t} while (ctx.result == -1 && --count > 0);\n\n\tif (ctx.result == 0) {\n\t\tmemcpy(dst_ether, &ctx.ether, ETHER_ADDR_LEN);\n\t\tlog_dbg_printf(\"Mirror target is up: \"\n\t\t               \"%02x:%02x:%02x:%02x:%02x:%02x\\n\",\n\t\t               dst_ether[0], dst_ether[1], dst_ether[2],\n\t\t               dst_ether[3], dst_ether[4], dst_ether[5]);\n\t}\n\nout3:\n\tpcap_freecode(&bp);\nout2:\n\tpcap_close(pcap);\nout:\n\tlibnet_clear_packet(libnet);\n\treturn ctx.result;\n}\n#endif /* !WITHOUT_MIRROR */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "logpkt.h",
          "type": "blob",
          "size": 2.5615234375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef LOGPKT_H\n#define LOGPKT_H\n\n#include \"attrib.h\"\n\n#include <sys/socket.h>\n#include <stdint.h>\n#include <time.h>\n\n#ifndef WITHOUT_MIRROR\n#include <libnet.h>\n#else /* WITHOUT_MIRROR */\n#define libnet_t void\n#define ETHER_ADDR_LEN 6\n#endif /* WITHOUT_MIRROR */\n\ntypedef struct {\n\tlibnet_t *libnet;\n\tuint8_t src_ether[ETHER_ADDR_LEN];\n\tuint8_t dst_ether[ETHER_ADDR_LEN];\n\tstruct sockaddr_storage src_addr;\n\tstruct sockaddr_storage dst_addr;\n\tuint32_t src_seq;\n\tuint32_t dst_seq;\n\tsize_t mss;\n} logpkt_ctx_t;\n\n#define LOGPKT_REQUEST  0\n#define LOGPKT_RESPONSE 1\n\nint logpkt_pcap_open_fd(int fd) WUNRES;\nvoid logpkt_ctx_init(logpkt_ctx_t *, libnet_t *, size_t,\n                     const uint8_t *, const uint8_t *,\n                     const struct sockaddr *, socklen_t,\n                     const struct sockaddr *, socklen_t);\nint logpkt_write_payload(logpkt_ctx_t *, int, int,\n                         const unsigned char *, size_t) WUNRES;\nint logpkt_write_close(logpkt_ctx_t *, int, int);\nint logpkt_ether_lookup(libnet_t *, uint8_t *, uint8_t *,\n                        const char *, const char *) WUNRES;\n\n#endif /* !LOGPKT_H */\n"
        },
        {
          "name": "main.c",
          "type": "blob",
          "size": 28.109375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* silence daemon(3) deprecation warning on Mac OS X */\n#if __APPLE__\n#define daemon xdaemon\n#endif /* __APPLE__ */\n\n#include \"opts.h\"\n#include \"proxy.h\"\n#include \"privsep.h\"\n#include \"ssl.h\"\n#include \"nat.h\"\n#include \"proc.h\"\n#include \"cachemgr.h\"\n#include \"sys.h\"\n#include \"log.h\"\n#include \"build.h\"\n#include \"defaults.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <signal.h>\n#include <string.h>\n\n#ifndef __BSD__\n#include <getopt.h>\n#endif /* !__BSD__ */\n\n#include <openssl/ssl.h>\n#include <openssl/x509.h>\n#include <event2/event.h>\n#ifndef WITHOUT_MIRROR\n#include <libnet.h>\n#include <pcap.h>\n#endif /* !WITHOUT_MIRROR */\n\n#if __APPLE__\n#undef daemon\nextern int daemon(int, int);\n#endif /* __APPLE__ */\n\n\n/*\n * Print version information to stderr.\n */\nstatic void\nmain_version(void)\n{\n\tfprintf(stderr, \"%s %s (built %s)\\n\",\n\t                PKGLABEL, build_version, build_date);\n\tif (strlen(build_version) < 5) {\n\t\t/*\n\t\t * Note to package maintainers:  If you break the version\n\t\t * string in your build, it will be impossible to provide\n\t\t * proper upstream support to the users of the package,\n\t\t * because it will be difficult or impossible to identify\n\t\t * the exact codebase that is being used by the user\n\t\t * reporting a bug.  The version string is provided through\n\t\t * different means depending on whether the code is a git\n\t\t * checkout, a tarball downloaded from GitHub or a release.\n\t\t * See GNUmakefile for the gory details.\n\t\t */\n\t\tfprintf(stderr, \"---------------------------------------\"\n\t\t                \"---------------------------------------\\n\");\n\t\tfprintf(stderr, \"WARNING: Something is wrong with the \"\n\t\t                \"version compiled into sslsplit!\\n\");\n\t\tfprintf(stderr, \"The version should contain a release \"\n\t\t                \"number and/or a git commit reference.\\n\");\n\t\tfprintf(stderr, \"If using a package, please report a bug \"\n\t\t                \"to the distro package maintainer.\\n\");\n\t\tfprintf(stderr, \"---------------------------------------\"\n\t\t                \"---------------------------------------\\n\");\n\t}\n\tfprintf(stderr, \"Copyright (c) 2009-2019, \"\n\t                \"Daniel Roethlisberger <daniel@roe.ch>\\n\");\n\tfprintf(stderr, \"https://www.roe.ch/SSLsplit\\n\");\n\tif (build_info[0]) {\n\t\tfprintf(stderr, \"Build info: %s\\n\", build_info);\n\t}\n\tif (build_features[0]) {\n\t\tfprintf(stderr, \"Features: %s\\n\", build_features);\n\t}\n\tnat_version();\n\tfprintf(stderr, \"Local process info support: \");\n#ifdef HAVE_LOCAL_PROCINFO\n\tfprintf(stderr, \"yes (\" LOCAL_PROCINFO_STR \")\\n\");\n#else /* !HAVE_LOCAL_PROCINFO */\n\tfprintf(stderr, \"no\\n\");\n#endif /* !HAVE_LOCAL_PROCINFO */\n\tssl_openssl_version();\n\tfprintf(stderr, \"compiled against libevent %s\\n\", LIBEVENT_VERSION);\n\tfprintf(stderr, \"rtlinked against libevent %s\\n\", event_get_version());\n#ifndef WITHOUT_MIRROR\n\tfprintf(stderr, \"compiled against libnet %s\\n\", LIBNET_VERSION);\n#ifndef __OpenBSD__\n\tconst char *lnv = libnet_version();\n\tif (!strncmp(lnv, \"libnet version \", 15))\n\t\tlnv += 15;\n\tfprintf(stderr, \"rtlinked against libnet %s\\n\", lnv);\n#else /* __OpenBSD__ */\n\tfprintf(stderr, \"rtlinked against libnet n/a\\n\");\n#endif /* __OpenBSD__ */\n\tfprintf(stderr, \"compiled against libpcap n/a\\n\");\n\tconst char *lpv = pcap_lib_version();\n\tif (!strncmp(lpv, \"libpcap version \", 16))\n\t\tlpv += 16;\n\tfprintf(stderr, \"rtlinked against libpcap %s\\n\", lpv);\n#endif /* !WITHOUT_MIRROR */\n\tfprintf(stderr, \"%d CPU cores detected\\n\", sys_get_cpu_cores());\n}\n\n/*\n * Print usage to stderr.\n */\nstatic void\nmain_usage(void)\n{\n\tconst char *dflt, *warn;\n\tconst char *usagefmt1 =\n\"Usage: %s [-D] [-f conffile] [-o opt=val] [options...] [proxyspecs...]\\n\"\n\"  -f conffile use conffile to load configuration from\\n\"\n\"  -o opt=val  override conffile option opt with value val\\n\"\n\"  -c pemfile  use CA cert (and key) from pemfile to sign forged certs\\n\"\n\"  -k pemfile  use CA key (and cert) from pemfile to sign forged certs\\n\"\n\"  -C pemfile  use CA chain from pemfile (intermediate and root CA certs)\\n\"\n\"  -K pemfile  use key from pemfile for leaf certs (default: generate)\\n\"\n\"  -q crlurl   use URL as CRL distribution point for all forged certs\\n\"\n\"  -t certdir  use cert+chain+key PEM files from certdir to target all sites\\n\"\n\"              matching the common names (non-matching: -T or generate if CA)\\n\"\n\"  -A pemfile  use cert+chain+key PEM file as fallback leaf cert when none of\\n\"\n\"              those given by -t match, instead of generating one on the fly\\n\"\n\"  -w gendir   write leaf key and only generated certificates to gendir\\n\"\n\"  -W gendir   write leaf key and all certificates to gendir\\n\"\n\"  -O          deny all OCSP requests on all proxyspecs\\n\"\n\"  -P          passthrough SSL connections if they cannot be split because of\\n\"\n\"              client cert auth or no matching cert and no CA (default: drop)\\n\"\n\"  -a pemfile  use cert from pemfile when destination requests client certs\\n\"\n\"  -b pemfile  use key from pemfile when destination requests client certs\\n\"\n#ifndef OPENSSL_NO_DH\n\"  -g pemfile  use DH group params from pemfile (default: keyfiles or auto)\\n\"\n#define OPT_g \"g:\"\n#else /* OPENSSL_NO_DH */\n#define OPT_g \n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\"  -G curve    use ECDH named curve (default: \" DFLT_CURVE \")\\n\"\n#define OPT_G \"G:\"\n#else /* OPENSSL_NO_ECDH */\n#define OPT_G \n#endif /* OPENSSL_NO_ECDH */\n#ifdef SSL_OP_NO_COMPRESSION\n\"  -Z          disable SSL/TLS compression on all connections\\n\"\n#define OPT_Z \"Z\"\n#else /* !SSL_OP_NO_COMPRESSION */\n#define OPT_Z \n#endif /* !SSL_OP_NO_COMPRESSION */\n\"  -r proto    only support one of \" SSL_PROTO_SUPPORT_S \"(default: all)\\n\"\n\"  -R proto    disable one of \" SSL_PROTO_SUPPORT_S \"(default: none)\\n\"\n\"  -s ciphers  use the given OpenSSL cipher suite spec (default: \" DFLT_CIPHERS \")\\n\"\n#ifndef OPENSSL_NO_ENGINE\n\"  -x engine   load OpenSSL engine with the given identifier\\n\"\n#define OPT_x \"x:\"\n#else /* OPENSSL_NO_ENGINE */\n#define OPT_x \n#endif /* OPENSSL_NO_ENGINE */\n\"  -e engine   specify default NAT engine to use (default: %s)\\n\"\n\"  -E          list available NAT engines and exit\\n\"\n\"  -u user     drop privileges to user (default if run as root: \" DFLT_DROPUSER \")\\n\"\n\"  -m group    when using -u, override group (default: primary group of user)\\n\"\n\"  -j jaildir  chroot() to jaildir (impacts sni proxyspecs, see manual page)\\n\"\n\"  -p pidfile  write pid to pidfile (default: no pid file)\\n\"\n\"  -l logfile  connect log: log one line summary per connection to logfile\\n\"\n\"  -L logfile  content log: full data to file or named pipe (excludes -S/-F)\\n\"\n\"  -S logdir   content log: full data to separate files in dir (excludes -L/-F)\\n\"\n\"  -F pathspec content log: full data to sep files with %% subst (excl. -L/-S):\\n\"\n\"              %%T - initial connection time as an ISO 8601 UTC timestamp\\n\"\n\"              %%d - destination host and port\\n\"\n\"              %%D - destination host\\n\"\n\"              %%p - destination port\\n\"\n\"              %%s - source host and port\\n\"\n\"              %%S - source host\\n\"\n\"              %%q - source port\\n\"\n#ifdef HAVE_LOCAL_PROCINFO\n\"              %%x - base name of local process        (requires -i)\\n\"\n\"              %%X - full path to local process        (requires -i)\\n\"\n\"              %%u - user name or id of local process  (requires -i)\\n\"\n\"              %%g - group name or id of local process (requires -i)\\n\"\n#endif /* HAVE_LOCAL_PROCINFO */\n\"              %%%% - literal '%%'\\n\"\n#ifdef HAVE_LOCAL_PROCINFO\n\"      e.g.    \\\"/var/log/sslsplit/%%X/%%u-%%s-%%d-%%T.log\\\"\\n\"\n#else /* !HAVE_LOCAL_PROCINFO */\n\"      e.g.    \\\"/var/log/sslsplit/%%T-%%s-%%d.log\\\"\\n\"\n#endif /* HAVE_LOCAL_PROCINFO */\n\"  -X pcapfile pcap log: packets to pcapfile (excludes -Y/-y)\\n\"\n\"  -Y pcapdir  pcap log: packets to separate files in dir (excludes -X/-y)\\n\"\n\"  -y pathspec pcap log: packets to sep files with %% subst (excl. -X/-Y):\\n\"\n\"              see option -F for pathspec format\\n\"\n#ifndef WITHOUT_MIRROR\n\"  -I if       mirror packets to interface\\n\"\n\"  -T addr     mirror packets to target address (optionally used with -I)\\n\"\n#define OPT_I \"I:\"\n#define OPT_T \"T:\"\n#else /* WITHOUT_MIRROR */\n#define OPT_I \n#define OPT_T \n#endif /* WITHOUT_MIRROR */\n\"  -M logfile  log master keys to logfile in SSLKEYLOGFILE format\\n\"\n#ifdef HAVE_LOCAL_PROCINFO\n\"  -i          look up local process owning each connection for logging\\n\"\n#define OPT_i \"i\"\n#else /* !HAVE_LOCAL_PROCINFO */\n#define OPT_i \n#endif /* HAVE_LOCAL_PROCINFO */\n\"  -d          daemon mode: run in background, log error messages to syslog\\n\"\n\"  -D          debug mode: run in foreground, log debug messages on stderr\\n\"\n\"  -V          print version information and exit\\n\"\n\"  -h          print usage information and exit\\n\";\n\tconst char *usagefmt2 =\n\"  proxyspec = type listenaddr+port [natengine|targetaddr+port|\\\"sni\\\"+port]\\n\"\n\"      e.g.    http 0.0.0.0 8080 www.roe.ch 80  # http/4; static hostname dst\\n\"\n\"              https ::1 8443 2001:db8::1 443   # https/6; static address dst\\n\"\n\"              https 127.0.0.1 9443 sni 443     # https/4; SNI DNS lookups\\n\"\n\"              tcp 127.0.0.1 10025              # tcp/4; default NAT engine\\n\"\n\"              ssl 2001:db8::2 9999 pf          # ssl/6; NAT engine 'pf'\\n\"\n\"              autossl ::1 10025                # autossl/6; STARTTLS et al\\n\"\n\"Example:\\n\"\n\"  %s -k ca.key -c ca.pem -P  https 127.0.0.1 8443  https ::1 8443\\n\"\n\"%s\";\n\n\tif (!(dflt = nat_getdefaultname())) {\n\t\tdflt = \"n/a\";\n\t\twarn = \"\\nWarning: no supported NAT engine on this platform!\\n\"\n\t\t       \"Only static and SNI proxyspecs are supported.\\n\";\n\t} else {\n\t\twarn = \"\";\n\t}\n\n\tfprintf(stderr, usagefmt1, build_pkgname, dflt);\n\tfprintf(stderr, usagefmt2, build_pkgname, warn);\n}\n\n/*\n * Callback to load a cert/chain/key combo from a single PEM file for -t.\n * A return value of -1 indicates a fatal error to the file walker.\n */\nstatic int\nmain_load_leafcert(const char *filename, void *arg)\n{\n\topts_t *opts = arg;\n\tcert_t *cert;\n\tchar **names;\n\n\tcert = opts_load_cert_chain_key(filename);\n\tif (!cert)\n\t\treturn -1;\n\n\tif (OPTS_DEBUG(opts)) {\n\t\tlog_dbg_printf(\"Targets for '%s':\", filename);\n\t}\n\tnames = ssl_x509_names(cert->crt);\n\tfor (char **p = names; *p; p++) {\n\t\t/* be deliberately vulnerable to NULL prefix attacks */\n\t\tchar *sep;\n\t\tif ((sep = strchr(*p, '!'))) {\n\t\t\t*sep = '\\0';\n\t\t}\n\t\tif (OPTS_DEBUG(opts)) {\n\t\t\tlog_dbg_printf(\" '%s'\", *p);\n\t\t}\n\t\tcachemgr_tgcrt_set(*p, cert);\n\t\tfree(*p);\n\t}\n\tif (OPTS_DEBUG(opts)) {\n\t\tlog_dbg_printf(\"\\n\");\n\t}\n\tfree(names);\n\tcert_free(cert);\n\treturn 0;\n}\n\n/*\n * Main entry point.\n */\nint\nmain(int argc, char *argv[])\n{\n\tconst char *argv0;\n\tint ch;\n\topts_t *opts;\n\tchar *natengine;\n\tint pidfd = -1;\n\tint rv = EXIT_FAILURE;\n\n\targv0 = argv[0];\n\topts = opts_new();\n\tif (nat_getdefaultname()) {\n\t\tnatengine = strdup(nat_getdefaultname());\n\t\tif (!natengine)\n\t\t\toom_die(argv0);\n\t} else {\n\t\tnatengine = NULL;\n\t}\n\n\twhile ((ch = getopt(argc, argv,\n\t                    OPT_g OPT_G OPT_Z OPT_i OPT_x OPT_T OPT_I\n\t                    \"k:c:C:K:t:A:OPa:b:s:r:R:e:Eu:m:j:p:l:L:S:F:M:\"\n\t                    \"dDVhW:w:q:f:o:X:Y:y:\")) != -1) {\n\t\tswitch (ch) {\n\t\t\tcase 'f':\n\t\t\t\tif (opts->conffile)\n\t\t\t\t\tfree(opts->conffile);\n\t\t\t\topts->conffile = strdup(optarg);\n\t\t\t\tif (!opts->conffile)\n\t\t\t\t\toom_die(argv0);\n\t\t\t\tif (load_conffile(opts, argv0, &natengine) == -1) {\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n#ifdef DEBUG_OPTS\n\t\t\t\tlog_dbg_printf(\"Conf file: %s\\n\", opts->conffile);\n#endif /* DEBUG_OPTS */\n\t\t\t\tbreak;\n\t\t\tcase 'o':\n\t\t\t\tif (opts_set_option(opts, argv0, optarg, &natengine) == -1) {\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\topts_set_cacrt(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\topts_set_cakey(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\topts_set_cachain(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'K':\n\t\t\t\topts_set_leafkey(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\topts_set_leafcertdir(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'A':\n\t\t\t\topts_set_defaultleafcert(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'q':\n\t\t\t\topts_set_leafcrlurl(opts, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'O':\n\t\t\t\topts_set_deny_ocsp(opts);\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\topts_set_passthrough(opts);\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\topts_set_clientcrt(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\topts_set_clientkey(opts, argv0, optarg);\n\t\t\t\tbreak;\n#ifndef OPENSSL_NO_DH\n\t\t\tcase 'g':\n\t\t\t\topts_set_dh(opts, argv0, optarg);\n\t\t\t\tbreak;\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\t\t\tcase 'G':\n\t\t\t\topts_set_ecdhcurve(opts, argv0, optarg);\n\t\t\t\tbreak;\n#endif /* !OPENSSL_NO_ECDH */\n#ifdef SSL_OP_NO_COMPRESSION\n\t\t\tcase 'Z':\n\t\t\t\topts_unset_sslcomp(opts);\n\t\t\t\tbreak;\n#endif /* SSL_OP_NO_COMPRESSION */\n\t\t\tcase 's':\n\t\t\t\topts_set_ciphers(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\topts_force_proto(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'R':\n\t\t\t\topts_disable_proto(opts, argv0, optarg);\n\t\t\t\tbreak;\n#ifndef OPENSSL_NO_ENGINE\n\t\t\tcase 'x':\n\t\t\t\topts_set_openssl_engine(opts, argv0, optarg);\n\t\t\t\tbreak;\n#endif /* !OPENSSL_NO_ENGINE */\n\t\t\tcase 'e':\n\t\t\t\tif (natengine)\n\t\t\t\t\tfree(natengine);\n\t\t\t\tnatengine = strdup(optarg);\n\t\t\t\tif (!natengine)\n\t\t\t\t\toom_die(argv0);\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\t\tnat_list_engines();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\tbreak;\n\t\t\tcase 'u':\n\t\t\t\topts_set_user(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\topts_set_group(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\topts_set_pidfile(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'j':\n\t\t\t\topts_set_jaildir(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\topts_set_connectlog(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\topts_set_contentlog(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\topts_set_contentlogdir(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'F':\n\t\t\t\topts_set_contentlogpathspec(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'X':\n\t\t\t\topts_set_pcaplog(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'Y':\n\t\t\t\topts_set_pcaplogdir(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\topts_set_pcaplogpathspec(opts, argv0, optarg);\n\t\t\t\tbreak;\n#ifndef WITHOUT_MIRROR\n\t\t\tcase 'I':\n\t\t\t\topts_set_mirrorif(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'T':\n\t\t\t\topts_set_mirrortarget(opts, argv0, optarg);\n\t\t\t\tbreak;\n#endif /* !WITHOUT_MIRROR */\n\t\t\tcase 'W':\n\t\t\t\topts_set_certgendir_writeall(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'w':\n\t\t\t\topts_set_certgendir_writegencerts(opts, argv0, optarg);\n\t\t\t\tbreak;\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t\tcase 'i':\n\t\t\t\topts_set_lprocinfo(opts);\n\t\t\t\tbreak;\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t\tcase 'M':\n\t\t\t\topts_set_masterkeylog(opts, argv0, optarg);\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\topts_set_daemon(opts);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\topts_set_debug(opts);\n\t\t\t\tbreak;\n\t\t\tcase 'V':\n\t\t\t\tmain_version();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 'h':\n\t\t\t\tmain_usage();\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase '?':\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\tdefault:\n\t\t\t\tmain_usage();\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\targc -= optind;\n\targv += optind;\n\tproxyspec_parse(&argc, &argv, natengine, &opts->spec);\n\n\t/* usage checks before defaults */\n\tif (opts->detach && OPTS_DEBUG(opts)) {\n\t\tfprintf(stderr, \"%s: -d and -D are mutually exclusive.\\n\",\n\t\t                argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (opts->mirrortarget && !opts->mirrorif) {\n\t\tfprintf(stderr, \"%s: -T depends on -I.\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n#endif /* !WITHOUT_MIRROR */\n\tif (!opts->spec) {\n\t\tfprintf(stderr, \"%s: no proxyspec specified.\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n\tfor (proxyspec_t *spec = opts->spec; spec; spec = spec->next) {\n\t\tif (spec->connect_addrlen || spec->sni_port)\n\t\t\tcontinue;\n\t\tif (!spec->natengine) {\n\t\t\tfprintf(stderr, \"%s: no supported NAT engines \"\n\t\t\t                \"on this platform.\\n\"\n\t\t\t                \"Only static addr and SNI proxyspecs \"\n\t\t\t                \"supported.\\n\", argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (spec->listen_addr.ss_family == AF_INET6 &&\n\t\t    !nat_ipv6ready(spec->natengine)) {\n\t\t\tfprintf(stderr, \"%s: IPv6 not supported by '%s'\\n\",\n\t\t\t                argv0, spec->natengine);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tspec->natlookup = nat_getlookupcb(spec->natengine);\n\t\tspec->natsocket = nat_getsocketcb(spec->natengine);\n\t}\n\tif (opts_has_ssl_spec(opts)) {\n\t\tif (ssl_init() == -1) {\n\t\t\tfprintf(stderr, \"%s: failed to initialize OpenSSL.\\n\",\n\t\t\t                argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n#ifndef OPENSSL_NO_ENGINE\n\t\tif (opts->openssl_engine &&\n\t\t    ssl_engine(opts->openssl_engine) == -1) {\n\t\t\tfprintf(stderr, \"%s: failed to enable OpenSSL engine\"\n\t\t\t                \" %s.\\n\", argv0, opts->openssl_engine);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n#endif /* !OPENSSL_NO_ENGINE */\n\t\tif (opts->cacrt && !opts->cakey) {\n\t\t\tfprintf(stderr, \"%s: no CA key specified (-k).\\n\",\n\t\t\t                argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (opts->cakey && !opts->cacrt) {\n\t\t\tfprintf(stderr, \"%s: no CA cert specified (-c).\\n\",\n\t\t\t                argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (opts->cakey && opts->cacrt &&\n\t\t    (X509_check_private_key(opts->cacrt, opts->cakey) != 1)) {\n\t\t\tfprintf(stderr, \"%s: CA cert does not match key.\\n\",\n\t\t\t                argv0);\n\t\t\tERR_print_errors_fp(stderr);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (!opts->cakey &&\n\t\t    !opts->leafcertdir &&\n\t\t    !opts->defaultleafcert) {\n\t\t\tfprintf(stderr, \"%s: at least one of -c/-k, -t or -A \"\n\t\t\t                \"must be specified\\n\", argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n#ifdef __APPLE__\n\tif (opts->dropuser && !!strcmp(opts->dropuser, \"root\") &&\n\t    nat_used(\"pf\")) {\n\t\tfprintf(stderr, \"%s: cannot use 'pf' proxyspec with -u due \"\n\t\t                \"to Apple bug\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n#endif /* __APPLE__ */\n\n\t/* prevent multiple instances running */\n\tif (opts->pidfile) {\n\t\tpidfd = sys_pidf_open(opts->pidfile);\n\t\tif (pidfd == -1) {\n\t\t\tfprintf(stderr, \"%s: cannot open PID file '%s' \"\n\t\t\t                \"- process already running?\\n\",\n\t\t\t                argv0, opts->pidfile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/* dynamic defaults */\n\tif (!opts->ciphers) {\n\t\topts->ciphers = strdup(DFLT_CIPHERS);\n\t\tif (!opts->ciphers)\n\t\t\toom_die(argv0);\n\t}\n\tif (!opts->dropuser && !geteuid() && !getuid() &&\n\t    sys_isuser(DFLT_DROPUSER)) {\n#ifdef __APPLE__\n\t\t/* Apple broke ioctl(/dev/pf) for EUID != 0 so we do not\n\t\t * want to automatically drop privileges to nobody there\n\t\t * if pf has been used in any proxyspec */\n\t\tif (!nat_used(\"pf\")) {\n#endif /* __APPLE__ */\n\t\topts->dropuser = strdup(DFLT_DROPUSER);\n\t\tif (!opts->dropuser)\n\t\t\toom_die(argv0);\n#ifdef __APPLE__\n\t\t}\n#endif /* __APPLE__ */\n\t}\n\tif (opts->dropuser && sys_isgeteuid(opts->dropuser)) {\n\t\tif (opts->dropgroup) {\n\t\t\tfprintf(stderr, \"%s: cannot use -m when -u is \"\n\t\t\t        \"current user\\n\", argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tfree(opts->dropuser);\n\t\topts->dropuser = NULL;\n\t}\n\n\t/* usage checks after defaults */\n\tif (opts->dropgroup && !opts->dropuser) {\n\t\tfprintf(stderr, \"%s: -m depends on -u\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Warn about options that require per-connection privileged operations\n\t * to be executed through privsep, but only if dropuser is set and is\n\t * not root, because privsep will fastpath in that situation, skipping\n\t * the latency-incurring overhead. */\n\tint privsep_warn = 0;\n\tif (opts->dropuser) {\n\t\tif (opts->contentlog_isdir) {\n\t\t\tlog_dbg_printf(\"| Warning: -F requires a privileged \"\n\t\t\t               \"operation for each connection!\\n\");\n\t\t\tprivsep_warn = 1;\n\t\t}\n\t\tif (opts->contentlog_isspec) {\n\t\t\tlog_dbg_printf(\"| Warning: -S requires a privileged \"\n\t\t\t               \"operation for each connection!\\n\");\n\t\t\tprivsep_warn = 1;\n\t\t}\n\t\tif (opts->pcaplog_isdir) {\n\t\t\tlog_dbg_printf(\"| Warning: -Y requires a privileged \"\n\t\t\t               \"operation for each connection!\\n\");\n\t\t\tprivsep_warn = 1;\n\t\t}\n\t\tif (opts->pcaplog_isspec) {\n\t\t\tlog_dbg_printf(\"| Warning: -y requires a privileged \"\n\t\t\t               \"operation for each connection!\\n\");\n\t\t\tprivsep_warn = 1;\n\t\t}\n\t\tif (opts->certgendir) {\n\t\t\tlog_dbg_printf(\"| Warning: -w/-W require a privileged \"\n\t\t\t               \"op for each connection!\\n\");\n\t\t\tprivsep_warn = 1;\n\t\t}\n\t}\n\tif (privsep_warn) {\n\t\tlog_dbg_printf(\"| Privileged operations require communication \"\n\t\t               \"between parent and child process\\n\"\n\t\t               \"| and will negatively impact latency and \"\n\t\t               \"performance on each connection.\\n\");\n\t}\n\n\t/* debug log, part 1 */\n\tif (OPTS_DEBUG(opts)) {\n\t\tmain_version();\n\t}\n\n\t/* generate leaf key */\n\tif (opts_has_ssl_spec(opts) && opts->cakey && !opts->leafkey) {\n\t\topts->leafkey = ssl_key_genrsa(DFLT_LEAFKEY_RSABITS);\n\t\tif (!opts->leafkey) {\n\t\t\tfprintf(stderr, \"%s: error generating RSA key:\\n\",\n\t\t\t                argv0);\n\t\t\tERR_print_errors_fp(stderr);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (OPTS_DEBUG(opts)) {\n\t\t\tlog_dbg_printf(\"Generated %i bit RSA key for leaf \"\n\t\t\t               \"certs.\\n\", DFLT_LEAFKEY_RSABITS);\n\t\t}\n\t}\n\tif (opts->certgendir && opts->leafkey) {\n\t\tchar *keyid, *keyfn;\n\t\tint prv;\n\t\tFILE *keyf;\n\n\t\tkeyid = ssl_key_identifier(opts->leafkey, 0);\n\t\tif (!keyid) {\n\t\t\tfprintf(stderr, \"%s: error generating key id\\n\", argv0);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tprv = asprintf(&keyfn, \"%s/%s.key\", opts->certgendir, keyid);\n\t\tif (prv == -1) {\n\t\t\tfprintf(stderr, \"%s: %s (%i)\\n\", argv0,\n\t\t\t                strerror(errno), errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\n\t\tif (!(keyf = fopen(keyfn, \"w\"))) {\n\t\t\tfprintf(stderr, \"%s: Failed to open '%s' for writing: \"\n\t\t\t                \"%s (%i)\\n\", argv0, keyfn,\n\t\t\t                strerror(errno), errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif (!PEM_write_PrivateKey(keyf, opts->leafkey,\n\t\t                          NULL, 0, 0, NULL, NULL)) {\n\t\t\tfprintf(stderr, \"%s: Failed to write key to '%s': \"\n\t\t\t                \"%s (%i)\\n\", argv0, keyfn,\n\t\t\t                strerror(errno), errno);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tfclose(keyf);\n\t}\n\n\t/* debug log, part 2 */\n\tif (OPTS_DEBUG(opts)) {\n\t\topts_proto_dbg_dump(opts);\n\t\tlog_dbg_printf(\"proxyspecs:\\n\");\n\t\tfor (proxyspec_t *spec = opts->spec; spec; spec = spec->next) {\n\t\t\tchar *specstr = proxyspec_str(spec);\n\t\t\tif (!specstr) {\n\t\t\t\tfprintf(stderr, \"%s: out of memory\\n\", argv0);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tlog_dbg_printf(\"- %s\\n\", specstr);\n\t\t\tfree(specstr);\n\t\t}\n#ifndef OPENSSL_NO_ENGINE\n\t\tif (opts->openssl_engine) {\n\t\t\tlog_dbg_printf(\"Loaded OpenSSL engine %s\\n\",\n\t\t\t               opts->openssl_engine);\n\t\t}\n#endif /* !OPENSSL_NO_ENGINE */\n\t\tif (opts->cacrt) {\n\t\t\tchar *subj = ssl_x509_subject(opts->cacrt);\n\t\t\tlog_dbg_printf(\"Loaded CA: '%s'\\n\", subj);\n\t\t\tfree(subj);\n#ifdef DEBUG_CERTIFICATE\n\t\t\tlog_dbg_print_free(ssl_x509_to_str(opts->cacrt));\n\t\t\tlog_dbg_print_free(ssl_x509_to_pem(opts->cacrt));\n#endif /* DEBUG_CERTIFICATE */\n\t\t} else {\n\t\t\tlog_dbg_printf(\"No CA loaded.\\n\");\n\t\t}\n\t\tlog_dbg_printf(\"SSL/TLS leaf certificates taken from:\\n\");\n\t\tif (opts->leafcertdir) {\n\t\t\tlog_dbg_printf(\"- Matching PEM file in %s\\n\",\n\t\t\t               opts->leafcertdir);\n\t\t}\n\t\tif (opts->defaultleafcert) {\n\t\t\tlog_dbg_printf(\"- Default leaf key\\n\");\n\t\t} else if (opts->cakey) {\n\t\t\tlog_dbg_printf(\"- Generated on the fly\\n\");\n\t\t} else if (opts->passthrough) {\n\t\t\tlog_dbg_printf(\"- Passthrough without decryption\\n\");\n\t\t} else {\n\t\t\tlog_dbg_printf(\"- Connection drop\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * Initialize as much as possible before daemon() in order to be\n\t * able to provide direct feedback to the user when failing.\n\t */\n\tif (cachemgr_preinit() == -1) {\n\t\tfprintf(stderr, \"%s: failed to preinit cachemgr.\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (log_preinit(opts) == -1) {\n\t\tfprintf(stderr, \"%s: failed to preinit logging.\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (nat_preinit() == -1) {\n\t\tfprintf(stderr, \"%s: failed to preinit NAT lookup.\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Load certs before dropping privs but after cachemgr_preinit() */\n\tif (opts->leafcertdir) {\n\t\tif (sys_dir_eachfile(opts->leafcertdir,\n\t\t                     main_load_leafcert, opts) == -1) {\n\t\t\tfprintf(stderr, \"%s: failed to load certs from %s\\n\",\n\t\t\t                argv0, opts->leafcertdir);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\t/* Detach from tty; from this point on, only canonicalized absolute\n\t * paths should be used (-j, -F, -S). */\n\tif (opts->detach) {\n\t\tif (OPTS_DEBUG(opts)) {\n\t\t\tlog_dbg_printf(\"Detaching from TTY, see syslog for \"\n\t\t\t               \"errors after this point\\n\");\n\t\t}\n\t\tif (daemon(0, 0) == -1) {\n\t\t\tfprintf(stderr, \"%s: failed to detach from TTY: %s\\n\",\n\t\t\t                argv0, strerror(errno));\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tlog_err_mode(LOG_ERR_MODE_SYSLOG);\n\t}\n\n\tif (opts->pidfile && (sys_pidf_write(pidfd) == -1)) {\n\t\tlog_err_printf(\"Failed to write PID to PID file '%s': %s (%i)\"\n\t\t               \"\\n\", opts->pidfile, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\n\t/* Fork into parent monitor process and (potentially unprivileged)\n\t * child process doing the actual work.  We request 6 privsep client\n\t * sockets: five logger threads, and the child process main thread,\n\t * which will become the main proxy thread.  First slot is main thread,\n\t * remaining slots are passed down to log subsystem. */\n\tint clisock[6];\n\tif (privsep_fork(opts, clisock,\n\t                 sizeof(clisock)/sizeof(clisock[0]), &rv) != 0) {\n\t\t/* parent has exited the monitor loop after waiting for child,\n\t\t * or an error occurred */\n\t\tif (opts->pidfile) {\n\t\t\tsys_pidf_close(pidfd, opts->pidfile);\n\t\t}\n\t\tgoto out_parent;\n\t}\n\t/* child */\n\n\t/* close pidfile in child */\n\tif (opts->pidfile)\n\t\tclose(pidfd);\n\n\t/* Initialize proxy before dropping privs */\n\tproxy_ctx_t *proxy = proxy_new(opts, clisock[0]);\n\tif (!proxy) {\n\t\tlog_err_printf(\"Failed to initialize proxy.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* Drop privs, chroot */\n\tif (sys_privdrop(opts->dropuser, opts->dropgroup,\n\t                 opts->jaildir) == -1) {\n\t\tlog_err_printf(\"Failed to drop privileges: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\tlog_dbg_printf(\"Dropped privs to user %s group %s chroot %s\\n\",\n\t               opts->dropuser  ? opts->dropuser  : \"-\",\n\t               opts->dropgroup ? opts->dropgroup : \"-\",\n\t               opts->jaildir   ? opts->jaildir   : \"-\");\n\tif (ssl_reinit() == -1) {\n\t\tfprintf(stderr, \"%s: failed to reinit SSL\\n\", argv0);\n\t\tgoto out_sslreinit_failed;\n\t}\n\n\t/* Post-privdrop/chroot/detach initialization, thread spawning */\n\tif (log_init(opts, proxy, &clisock[1]) == -1) {\n\t\tfprintf(stderr, \"%s: failed to init log facility: %s\\n\",\n\t\t                argv0, strerror(errno));\n\t\tgoto out_log_failed;\n\t}\n\tif (cachemgr_init() == -1) {\n\t\tlog_err_printf(\"Failed to init cache manager.\\n\");\n\t\tgoto out_cachemgr_failed;\n\t}\n\tif (nat_init() == -1) {\n\t\tlog_err_printf(\"Failed to init NAT state table lookup.\\n\");\n\t\tgoto out_nat_failed;\n\t}\n\n\tint proxy_rv = proxy_run(proxy);\n\tif (proxy_rv == 0) {\n\t\trv = EXIT_SUCCESS;\n\t} else if (proxy_rv > 0) {\n\t\t/*\n\t\t * We terminated because of receiving a signal.  For our normal\n\t\t * termination signals as documented in the man page, we want\n\t\t * to return with EXIT_SUCCESS.  For other signals, which\n\t\t * should be considered abnormal terminations, we want to\n\t\t * return an exit status of 128 + signal number.\n\t\t */\n\t\tif (proxy_rv == SIGTERM || proxy_rv == SIGINT) {\n\t\t\trv = EXIT_SUCCESS;\n\t\t} else {\n\t\t\trv = 128 + proxy_rv;\n\t\t}\n\t}\n\tproxy_free(proxy);\n\tnat_fini();\nout_nat_failed:\n\tcachemgr_fini();\nout_cachemgr_failed:\n\tlog_fini();\nout_sslreinit_failed:\nout_log_failed:\nout_parent:\n\topts_free(opts);\n\tssl_fini();\n\tif (natengine)\n\t\tfree(natengine);\n\treturn rv;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "main.t.c",
          "type": "blob",
          "size": 3.44140625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"attrib.h\"\n#include \"opts.h\"\n#include \"build.h\"\n\n#include <stdlib.h>\n#include <string.h>\n\n#include <check.h>\n\nSuite *\nblank_suite(void)\n{\n\tSuite *s;\n\ts = suite_create(\"\");\n\treturn s;\n}\n\nSTART_TEST(build_date_01)\n{\n\tfail_unless(strlen(build_date) == 10, \"length mismatch\");\n\tfail_unless(build_date[4] == '-', \"year/month separator not dash\");\n\tfail_unless(build_date[7] == '-', \"month/day separator not dash\");\n}\nEND_TEST\n\nSuite *\nmain_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\ts = suite_create(\"main\");\n\n\ttc = tcase_create(\"build_date\");\n\ttcase_add_test(tc, build_date_01);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\nSuite * opts_suite(void);\nSuite * dynbuf_suite(void);\nSuite * logbuf_suite(void);\nSuite * cert_suite(void);\nSuite * cachemgr_suite(void);\nSuite * cachefkcrt_suite(void);\nSuite * cachetgcrt_suite(void);\nSuite * cachedsess_suite(void);\nSuite * cachessess_suite(void);\nSuite * ssl_suite(void);\nSuite * sys_suite(void);\nSuite * base64_suite(void);\nSuite * url_suite(void);\nSuite * util_suite(void);\nSuite * pxythrmgr_suite(void);\nSuite * defaults_suite(void);\n\nint\nmain(UNUSED int argc, UNUSED char *argv[])\n{\n\tint nfail;\n\tSRunner *sr;\n\n\tsr = srunner_create(blank_suite());\n\tsrunner_add_suite(sr, main_suite());\n\tsrunner_add_suite(sr, opts_suite());\n\tsrunner_add_suite(sr, dynbuf_suite());\n\tsrunner_add_suite(sr, logbuf_suite());\n\tsrunner_add_suite(sr, cert_suite());\n\tsrunner_add_suite(sr, cachemgr_suite());\n\tsrunner_add_suite(sr, cachefkcrt_suite());\n\tsrunner_add_suite(sr, cachetgcrt_suite());\n\tsrunner_add_suite(sr, cachedsess_suite());\n\tsrunner_add_suite(sr, cachessess_suite());\n\tsrunner_add_suite(sr, ssl_suite());\n\tsrunner_add_suite(sr, sys_suite());\n\tsrunner_add_suite(sr, base64_suite());\n\tsrunner_add_suite(sr, url_suite());\n\tsrunner_add_suite(sr, util_suite());\n\tsrunner_add_suite(sr, pxythrmgr_suite());\n\tsrunner_add_suite(sr, defaults_suite());\n\tsrunner_run_all(sr, CK_NORMAL);\n\tnfail = srunner_ntests_failed(sr);\n\tsrunner_free(sr);\n\n\treturn !nfail ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "nat.c",
          "type": "blob",
          "size": 16.45703125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"nat.h\"\n\n#include \"log.h\"\n#include \"attrib.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n#ifdef HAVE_PF\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/fcntl.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#ifdef __APPLE__\n#define PRIVATE\n#endif /* __APPLE__ */\n#include <net/pfvar.h>\n#ifdef __APPLE__\n#undef PRIVATE\n#endif /* __APPLE__ */\n#include <unistd.h>\n#endif /* HAVE_PF */\n\n#ifdef HAVE_IPFILTER\n#include <sys/ioctl.h>\n#include <netinet/tcp.h>\n#include <net/if.h>\n#include <netinet/ipl.h>\n#include <netinet/ip_compat.h>\n#include <netinet/ip_fil.h>\n#include <netinet/ip_nat.h>\n#endif /* HAVE_IPFILTER */\n\n#ifdef HAVE_NETFILTER\n#include <limits.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/netfilter_ipv6.h>\n#include <linux/if.h>\n#include <linux/netfilter_ipv6/ip6_tables.h>\n#endif /* HAVE_NETFILTER */\n\n\n/*\n * Access NAT state tables in a NAT engine independent way.\n * Adding support for additional NAT engines should require only\n * changes in this file.\n */\n\n\n/*\n * pf\n */\n\n#ifdef HAVE_PF\nstatic int nat_pf_fd = -1;\n\nstatic int\nnat_pf_preinit(void)\n{\n\tnat_pf_fd = open(\"/dev/pf\", O_RDONLY);\n\tif (nat_pf_fd < 0) {\n\t\tlog_err_printf(\"Error opening '/dev/pf': %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nnat_pf_init(void)\n{\n\tint rv;\n\n\trv = fcntl(nat_pf_fd, F_SETFD, fcntl(nat_pf_fd, F_GETFD) | FD_CLOEXEC);\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error setting FD_CLOEXEC on '/dev/pf': %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nnat_pf_fini(void)\n{\n\tclose(nat_pf_fd);\n}\n\nstatic int\nnat_pf_lookup_cb(struct sockaddr *dst_addr, socklen_t *dst_addrlen,\n                 evutil_socket_t s,\n                 struct sockaddr *src_addr, UNUSED socklen_t src_addrlen)\n{\n#ifdef __APPLE__\n#define sport sxport.port\n#define dport dxport.port\n#define rdport rdxport.port\n#ifdef v4addr /* XNU 4570.1.46 and newer */\n#define v4 v4addr\n#define v6 v6addr\n#endif /* XNU 4570.1.46 and newer */\n#endif /* __APPLE__ */\n\tstruct sockaddr_storage our_addr;\n\tsocklen_t our_addrlen;\n\tstruct pfioc_natlook nl;\n\n\tour_addrlen = sizeof(struct sockaddr_storage);\n\tif (getsockname(s, (struct sockaddr *)&our_addr, &our_addrlen) == -1) {\n\t\tlog_err_printf(\"Error from getsockname(): %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&nl, 0, sizeof(struct pfioc_natlook));\n\tnl.af = src_addr->sa_family;\n\tif (nl.af == AF_INET) {\n\t\tstruct sockaddr_in *src_sai = (struct sockaddr_in *)src_addr;\n\t\tstruct sockaddr_in *our_sai = (struct sockaddr_in *)&our_addr;\n\t\tnl.saddr.v4.s_addr = src_sai->sin_addr.s_addr;\n\t\tnl.sport = src_sai->sin_port;\n\t\tnl.daddr.v4.s_addr = our_sai->sin_addr.s_addr;\n\t\tnl.dport = our_sai->sin_port;\n\t}\n\tif (nl.af == AF_INET6) {\n\t\tstruct sockaddr_in6 *src_sai = (struct sockaddr_in6 *)src_addr;\n\t\tstruct sockaddr_in6 *our_sai = (struct sockaddr_in6 *)&our_addr;\n\t\tmemcpy(&nl.saddr.v6.s6_addr, &src_sai->sin6_addr.s6_addr, 16);\n\t\tnl.sport = src_sai->sin6_port;\n\t\tmemcpy(&nl.daddr.v6.s6_addr, &our_sai->sin6_addr.s6_addr, 16);\n\t\tnl.dport = our_sai->sin6_port;\n\t}\n\tnl.proto = IPPROTO_TCP;\n\tnl.direction = PF_OUT;\n\n\tif (ioctl(nat_pf_fd, DIOCNATLOOK, &nl)) {\n\t\tif (errno != ENOENT) {\n\t\t\tlog_err_printf(\"Error from ioctl(DIOCNATLOOK): %s\\n\",\n\t\t\t               strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ((nl.dport == nl.rdport) &&\n\t    ((nl.af == AF_INET && nl.daddr.v4.s_addr == nl.rdaddr.v4.s_addr) ||\n\t     (nl.af == AF_INET6 &&\n\t      !memcmp(nl.daddr.v6.s6_addr, nl.rdaddr.v6.s6_addr, 16)))) {\n\t\t/* no destination address/port translation in place */\n\t\treturn -1;\n\t}\n\n\t/* copy original destination address */\n\tif (nl.af == AF_INET) {\n\t\tstruct sockaddr_in *dst_sai = (struct sockaddr_in *)dst_addr;\n\t\tmemset(dst_sai, 0, sizeof(struct sockaddr_in));\n\t\tdst_sai->sin_addr.s_addr = nl.rdaddr.v4.s_addr;\n\t\tdst_sai->sin_port = nl.rdport;\n\t\tdst_sai->sin_family = nl.af;\n\t\t*dst_addrlen = sizeof(struct sockaddr_in);\n\t}\n\tif (nl.af == AF_INET6) {\n\t\tstruct sockaddr_in6 *dst_sai = (struct sockaddr_in6 *)dst_addr;\n\t\tmemset(dst_sai, 0, sizeof(struct sockaddr_in6));\n\t\tmemcpy(dst_sai->sin6_addr.s6_addr, nl.rdaddr.v6.s6_addr, 16);\n\t\tdst_sai->sin6_port = nl.rdport;\n\t\tdst_sai->sin6_family = nl.af;\n\t\t*dst_addrlen = sizeof(struct sockaddr_in6);\n\t}\n\n\treturn 0;\n#ifdef __APPLE__\n#undef sport\n#undef dport\n#undef rdport\n#ifdef v4addr /* XNU 4570.1.46 and newer */\n#undef v4\n#undef v6\n#endif /* XNU 4570.1.46 and newer */\n#endif /* __APPLE__ */\n}\n#endif /* HAVE_PF */\n\n\n/*\n * ipfilter\n */\n\n#ifdef HAVE_IPFILTER\nstatic int nat_ipfilter_fd = -1;\n\nstatic int\nnat_ipfilter_preinit(void)\n{\n\tnat_ipfilter_fd = open(IPNAT_NAME, O_RDONLY);\n\tif (nat_ipfilter_fd < 0) {\n\t\tlog_err_printf(\"Error opening '%s': %s\\n\",\n\t\t               IPNAT_NAME, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic int\nnat_ipfilter_init(void)\n{\n\tint rv;\n\n\trv = fcntl(nat_ipfilter_fd, F_SETFD,\n\t           fcntl(nat_ipfilter_fd, F_GETFD) | FD_CLOEXEC);\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error setting FD_CLOEXEC on '%s': %s\\n\",\n\t\t               IPNAT_NAME, strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void\nnat_ipfilter_fini(void)\n{\n\tclose(nat_ipfilter_fd);\n}\n\nstatic int\nnat_ipfilter_lookup_cb(struct sockaddr *dst_addr, socklen_t *dst_addrlen,\n                       evutil_socket_t s,\n                       struct sockaddr *src_addr, UNUSED socklen_t src_addrlen)\n{\n\tstruct sockaddr_storage our_addr;\n\tsocklen_t our_addrlen;\n\tstruct natlookup nl;\n\tstruct ipfobj ipfo;\n\n\tour_addrlen = sizeof(struct sockaddr_storage);\n\tif (getsockname(s, (struct sockaddr *)&our_addr, &our_addrlen) == -1) {\n\t\tlog_err_printf(\"Error from getsockname(): %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\n\tmemset(&nl, 0, sizeof(struct natlookup));\n\tif (src_addr->sa_family == AF_INET) {\n\t\tstruct sockaddr_in *src_sai = (struct sockaddr_in *)src_addr;\n\t\tstruct sockaddr_in *our_sai = (struct sockaddr_in *)&our_addr;\n\t\tnl.nl_outip.s_addr = src_sai->sin_addr.s_addr;\n\t\tnl.nl_outport = src_sai->sin_port;\n\t\tnl.nl_inip.s_addr = our_sai->sin_addr.s_addr;\n\t\tnl.nl_inport = our_sai->sin_port;\n\t} else {\n\t\tlog_err_printf(\"The ipfilter NAT engine does not \"\n\t\t               \"support IPv6 state lookups\\n\");\n\t\treturn -1;\n\t}\n\tnl.nl_flags = IPN_TCP;\n\n\t/* assuming IPv4 from here */\n\n\tmemset(&ipfo, 0, sizeof(struct ipfobj));\n\tipfo.ipfo_rev = IPFILTER_VERSION;\n\tipfo.ipfo_size = sizeof(struct natlookup);\n\tipfo.ipfo_ptr = &nl;\n\tipfo.ipfo_type = IPFOBJ_NATLOOKUP;\n\n\tif (ioctl(nat_ipfilter_fd, SIOCGNATL, &ipfo) == -1) {\n\t\tif (errno != ESRCH) {\n\t\t\tlog_err_printf(\"Error from ioctl(SIOCGNATL): %s\\n\",\n\t\t\t               strerror(errno));\n\t\t}\n\t\treturn -1;\n\t}\n\n\tif ((nl.nl_inport == nl.nl_realport) &&\n\t    (nl.nl_inip.s_addr == nl.nl_realip.s_addr)) {\n\t\t/* no destination address/port translation in place */\n\t\treturn -1;\n\t}\n\n\t/* copy original destination address */\n\tstruct sockaddr_in *dst_sai = (struct sockaddr_in *)dst_addr;\n\tmemset(dst_sai, 0, sizeof(struct sockaddr_in));\n\tdst_sai->sin_addr.s_addr = nl.nl_realip.s_addr;\n\tdst_sai->sin_port = nl.nl_realport;\n\tdst_sai->sin_family = AF_INET;\n\t*dst_addrlen = sizeof(struct sockaddr_in);\n\treturn 0;\n}\n#endif /* HAVE_IPFILTER */\n\n\n/*\n * netfilter, tproxy\n */\n\n#ifdef HAVE_NETFILTER\n/*\n * Linux commit 121d1e0941e05c64ee4223064dd83eb24e871739 adding\n * IP6T_SO_ORIGINAL_DST was first released as part of Linux v3.8-rc1 in 2012.\n * Before that, this interface only supported IPv4.\n */\nstatic int\nnat_netfilter_lookup_cb(struct sockaddr *dst_addr, socklen_t *dst_addrlen,\n                        evutil_socket_t s,\n                        struct sockaddr *src_addr, UNUSED socklen_t src_addrlen)\n{\n\tint rv;\n\n\tif (src_addr->sa_family == AF_INET) {\n\t\trv = getsockopt(s, SOL_IP, SO_ORIGINAL_DST,\n\t\t                dst_addr, dst_addrlen);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error from getsockopt(\"\n\t\t\t               \"SO_ORIGINAL_DST): %s\\n\",\n\t\t\t               strerror(errno));\n\t\t}\n\t} else {\n#ifdef IP6T_SO_ORIGINAL_DST\n\t\trv = getsockopt(s, SOL_IPV6, IP6T_SO_ORIGINAL_DST,\n\t\t                dst_addr, dst_addrlen);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"Error from getsockopt(\"\n\t\t\t               \"IP6T_SO_ORIGINAL_DST): %s\\n\",\n\t\t\t               strerror(errno));\n\t\t}\n#else /* !IP6T_SO_ORIGINAL_DST */\n\t\tlog_err_printf(\"The netfilter NAT engine only \"\n\t\t               \"supports IPv4 state lookups on \"\n\t\t               \"this version of Linux\\n\");\n\t\treturn -1;\n#endif /* !IP6T_SO_ORIGINAL_DST */\n\t}\n\treturn rv;\n}\n\n#ifdef IP_TRANSPARENT\n/*\n * Set the listening socket IP_TRANSPARENT.  This makes the Linux IP routing\n * stack omit the source address checks on output, which is needed for\n * Linux TPROXY transparent proxying support.\n */\nstatic int\nnat_iptransparent_socket_cb(evutil_socket_t s)\n{\n\tint on = 1;\n\tint rv;\n\n\trv = setsockopt(s, SOL_IP, IP_TRANSPARENT, (void*)&on, sizeof(on));\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error from setsockopt(IP_TRANSPARENT): %s\\n\",\n\t\t               strerror(errno));\n\t}\n\treturn rv;\n}\n#endif /* IP_TRANSPARENT */\n#endif /* HAVE_NETFILTER */\n\n\n/*\n * generic\n */\n\n#if defined(HAVE_IPFW) || (defined(HAVE_NETFILTER) && defined(IP_TRANSPARENT))\n/*\n * Generic getsockname based implementation.  This assumes that getsockname,\n * by kernel magic, gives us the original destination.\n */\nstatic int\nnat_getsockname_lookup_cb(struct sockaddr *dst_addr, socklen_t *dst_addrlen,\n                          evutil_socket_t s,\n                          UNUSED struct sockaddr *src_addr,\n                          UNUSED socklen_t src_addrlen)\n{\n\tif (getsockname(s, dst_addr, dst_addrlen) == -1) {\n\t\tlog_err_printf(\"Error from getsockname(): %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n#endif\n\n\n/*\n * NAT engine glue code and API.\n */\n\ntypedef int (*nat_init_cb_t)(void);\ntypedef void (*nat_fini_cb_t)(void);\n\nstruct engine {\n\tconst char *name;\n\tunsigned int ipv6 : 1;\n\tunsigned int used : 1;\n\tnat_init_cb_t preinitcb;\n\tnat_init_cb_t initcb;\n\tnat_fini_cb_t finicb;\n\tnat_lookup_cb_t lookupcb;\n\tnat_socket_cb_t socketcb;\n};\n\nstruct engine engines[] = {\n#ifdef HAVE_PF\n\t{\n\t\t\"pf\", 1, 0,\n\t\tnat_pf_preinit, nat_pf_init, nat_pf_fini,\n\t\tnat_pf_lookup_cb, NULL\n\t},\n#endif /* HAVE_PF */\n#ifdef HAVE_IPFW\n\t{\n\t\t\"ipfw\", 1, 0,\n\t\tNULL, NULL, NULL,\n\t\tnat_getsockname_lookup_cb, NULL\n\t},\n#endif /* HAVE_IPFW */\n#ifdef HAVE_IPFILTER\n\t{\n\t\t\"ipfilter\", 0, 0,\n\t\tnat_ipfilter_preinit, nat_ipfilter_init, nat_ipfilter_fini,\n\t\tnat_ipfilter_lookup_cb, NULL\n\t},\n#endif /* HAVE_IPFILTER */\n#ifdef HAVE_NETFILTER\n\t{\n#ifdef IP6T_SO_ORIGINAL_DST\n\t\t\"netfilter\", 1, 0,\n#else /* !IP6T_SO_ORIGINAL_DST */\n\t\t\"netfilter\", 0, 0,\n#endif /* !IP6T_SO_ORIGINAL_DST */\n\t\tNULL, NULL, NULL,\n\t\tnat_netfilter_lookup_cb, NULL\n\t},\n#ifdef IP_TRANSPARENT\n\t{\n\t\t\"tproxy\", 1, 0,\n\t\tNULL, NULL, NULL,\n\t\tnat_getsockname_lookup_cb, nat_iptransparent_socket_cb\n\t},\n#endif /* IP_TRANSPARENT */\n#endif /* HAVE_NETFILTER */\n\t{\n\t\tNULL, 0, 0,\n\t\tNULL, NULL, NULL,\n\t\tNULL, NULL\n\t}\n};\n\n\n/*\n * Return the name of the default NAT engine.\n */\nconst char *\nnat_getdefaultname(void)\n{\n\treturn engines[0].name;\n}\n\n/*\n * Look for a NAT engine in the table and return the index if found.\n * If there is no NAT engine with the given name, then the index of the\n * sentinel table entry is returned.\n */\nstatic int\nnat_index(const char *name)\n{\n\tif (name)\n\t\tfor (int i = 0; engines[i].name; i++)\n\t\t\tif (!strcmp(name, engines[i].name))\n\t\t\t\treturn i;\n\treturn ((sizeof(engines) / sizeof(struct engine)) - 1);\n}\n\n/*\n * Returns !=0 if the named NAT engine exists, 0 if it does not exist.\n * NULL refers to the default NAT engine.\n */\nint\nnat_exist(const char *name)\n{\n\tif (!name)\n\t\tname = engines[0].name;\n\treturn !!engines[nat_index(name)].name;\n}\n\n/*\n * Returns !=0 if the named NAT engine has been marked as used, 0 if not.\n * NULL refers to the default NAT engine.\n */\nint\nnat_used(const char *name)\n{\n\tif (!name)\n\t\tname = engines[0].name;\n\treturn !!engines[nat_index(name)].used;\n}\n\n/*\n * Returns the lookup callback of the named NAT engine and marks the NAT\n * engine as used.\n * NULL refers to the default NAT engine.\n */\nnat_lookup_cb_t\nnat_getlookupcb(const char *name)\n{\n\tint i;\n\n\tif (!name)\n\t\tname = engines[0].name;\n\ti = nat_index(name);\n\tengines[i].used = 1;\n\treturn engines[i].lookupcb;\n}\n\n/*\n * Returns the socket callback of the named NAT engine.\n * NULL refers to the default NAT engine.\n */\nnat_socket_cb_t\nnat_getsocketcb(const char *name)\n{\n\tif (!name)\n\t\tname = engines[0].name;\n\treturn engines[nat_index(name)].socketcb;\n}\n\n/*\n * Returns 1 if name is a NAT engine which supports IPv6.\n * NULL refers to the default NAT engine.\n */\nint\nnat_ipv6ready(const char *name)\n{\n\tif (!name)\n\t\tname = engines[0].name;\n\treturn engines[nat_index(name)].ipv6;\n}\n\n/*\n * List all available NAT engines to standard output and flush.\n */\nvoid\nnat_list_engines(void)\n{\n\tfor (int i = 0; engines[i].name; i++) {\n\t\tfprintf(stdout, \"%s%s\\n\", engines[i].name,\n\t\t                          i ? \"\" : \" (default)\");\n\t}\n\tfflush(stdout);\n}\n\n/*\n * Pre-initialize all NAT engines which were marked as used by previous calls\n * to nat_getlookupcb().\n *\n * Privileged initialization under root privs, before dropping privs,\n * before calling daemon().  Here should be initialization which needs\n * to provide the user feedback on errors.  This includes opening\n * special device files, for which the user may not have sufficient privs.\n *\n * Returns -1 on failure, 0 on success.\n */\nint\nnat_preinit(void)\n{\n\tfor (int i = 0; engines[i].preinitcb && engines[i].used; i++) {\n\t\tlog_dbg_printf(\"NAT engine preinit '%s'\\n\", engines[i].name);\n\t\tif (engines[i].preinitcb() == -1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Undo nat_preinit - close all file descriptors, for use in privsep parent.\n */\nvoid\nnat_preinit_undo(void)\n{\n\tnat_fini();\n}\n\n/*\n * Initialize all NAT engines which were marked as used by previous calls to\n * nat_getlookupcb().\n *\n * Unprivileged initialization, possibly root, possibly nobody or service user.\n *\n * Returns -1 on failure, 0 on success.\n */\nint\nnat_init(void)\n{\n\tfor (int i = 0; engines[i].initcb && engines[i].used; i++) {\n\t\tlog_dbg_printf(\"NAT engine init '%s'\\n\", engines[i].name);\n\t\tif (engines[i].initcb() == -1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Cleanup all NAT engines which were marked as used by previous calls to\n * nat_getlookupcb().\n */\nvoid\nnat_fini(void)\n{\n\tfor (int i = 0; engines[i].finicb && engines[i].used; i++) {\n\t\tlog_dbg_printf(\"NAT engine fini '%s'\\n\", engines[i].name);\n\t\tengines[i].finicb();\n\t}\n}\n\n/*\n * Print version and option availability to standard error.\n */\nvoid\nnat_version(void)\n{\n\tfprintf(stderr, \"NAT engines:\");\n\tfor (int i = 0; engines[i].name; i++) {\n\t\tfprintf(stderr, \" %s%s\", engines[i].name,\n\t\t                         i ? \"\" : \"*\");\n\t}\n\tif (!engines[0].name)\n\t\tfprintf(stderr, \" -\");\n\tfprintf(stderr, \"\\n\");\n#ifdef HAVE_IPFILTER\n\tfprintf(stderr, \"ipfilter: version %d\\n\", IPFILTER_VERSION);\n#endif /* HAVE_IPFILTER */\n#ifdef HAVE_NETFILTER\n\tfprintf(stderr, \"netfilter:\");\n#ifdef IP_TRANSPARENT\n\tfprintf(stderr, \" IP_TRANSPARENT\");\n#else /* !IP_TRANSPARENT */\n\tfprintf(stderr, \" !IP_TRANSPARENT\");\n#endif /* !IP_TRANSPARENT */\n#ifdef IP6T_SO_ORIGINAL_DST\n\tfprintf(stderr, \" IP6T_SO_ORIGINAL_DST\");\n#else /* !IP6T_SO_ORIGINAL_DST */\n\tfprintf(stderr, \" !IP6T_SO_ORIGINAL_DST\");\n#endif /* !IP6T_SO_ORIGINAL_DST */\n\tfprintf(stderr, \"\\n\");\n#endif /* HAVE_NETFILTER */\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "nat.h",
          "type": "blob",
          "size": 2.220703125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef NAT_H\n#define NAT_H\n\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <event2/util.h>\n\ntypedef int (*nat_lookup_cb_t)(struct sockaddr *, socklen_t *, evutil_socket_t,\n                               struct sockaddr *, socklen_t);\ntypedef int (*nat_socket_cb_t)(evutil_socket_t);\n\nint nat_exist(const char *) WUNRES;\nint nat_used(const char *) WUNRES;\nnat_lookup_cb_t nat_getlookupcb(const char *) WUNRES;\nnat_socket_cb_t nat_getsocketcb(const char *) WUNRES;\nint nat_ipv6ready(const char *) WUNRES;\n\nconst char *nat_getdefaultname(void) WUNRES;\nvoid nat_list_engines(void);\nint nat_preinit(void) WUNRES;\nvoid nat_preinit_undo(void);\nint nat_init(void) WUNRES;\nvoid nat_fini(void);\nvoid nat_version(void);\n\n#endif /* !NAT_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "opts.c",
          "type": "blob",
          "size": 41.39453125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"opts.h\"\n\n#include \"sys.h\"\n#include \"log.h\"\n\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#ifndef OPENSSL_NO_DH\n#include <openssl/dh.h>\n#endif /* !OPENSSL_NO_DH */\n#include <openssl/x509.h>\n\n/*\n * Handle out of memory conditions in early stages of main().\n * Print error message and exit with failure status code.\n * Does not return.\n */\nvoid NORET\noom_die(const char *argv0)\n{\n\tfprintf(stderr, \"%s: out of memory\\n\", argv0);\n\texit(EXIT_FAILURE);\n}\n\n/*\n * Load a cert/chain/key combo from a single PEM file.\n * Returns NULL on failure.\n */\ncert_t *\nopts_load_cert_chain_key(const char *filename)\n{\n\tcert_t *cert;\n\n\tcert = cert_new_load(filename);\n\tif (!cert) {\n\t\tlog_err_printf(\"Failed to load cert and key from PEM file \"\n\t\t                \"'%s'\\n\", filename);\n\t\treturn NULL;\n\t}\n\tif (X509_check_private_key(cert->crt, cert->key) != 1) {\n\t\tlog_err_printf(\"Cert does not match key in PEM file \"\n\t\t                \"'%s':\\n\", filename);\n\t\tERR_print_errors_fp(stderr);\n\t\tcert_free(cert);\n\t\treturn NULL;\n\t}\n\n#ifdef DEBUG_CERTIFICATE\n\tlog_dbg_printf(\"Loaded '%s':\\n\", filename);\n\tlog_dbg_print_free(ssl_x509_to_str(cert->crt));\n\tlog_dbg_print_free(ssl_x509_to_pem(cert->crt));\n#endif /* DEBUG_CERTIFICATE */\n\treturn cert;\n}\n\nopts_t *\nopts_new(void)\n{\n\topts_t *opts;\n\n\topts = malloc(sizeof(opts_t));\n\tmemset(opts, 0, sizeof(opts_t));\n\n\topts->sslcomp = 1;\n\topts->cachain = sk_X509_new_null();\n\topts->sslmethod = SSLv23_method;\n\topts->allow_wrong_host = 1;\n\n\treturn opts;\n}\n\nvoid\nopts_free(opts_t *opts)\n{\n\tif (opts->clientcrt) {\n\t\tX509_free(opts->clientcrt);\n\t}\n\tif (opts->clientkey) {\n\t\tEVP_PKEY_free(opts->clientkey);\n\t}\n\tif (opts->cacrt) {\n\t\tX509_free(opts->cacrt);\n\t}\n\tif (opts->cakey) {\n\t\tEVP_PKEY_free(opts->cakey);\n\t}\n\tsk_X509_pop_free(opts->cachain, X509_free);\n\tif (opts->leafkey) {\n\t\tEVP_PKEY_free(opts->leafkey);\n\t}\n\tif (opts->leafcertdir) {\n\t\tfree(opts->leafcertdir);\n\t}\n\tif (opts->defaultleafcert) {\n\t\tcert_free(opts->defaultleafcert);\n\t}\n\tif (opts->leafcrlurl) {\n\t\tfree(opts->leafcrlurl);\n\t}\n#ifndef OPENSSL_NO_DH\n\tif (opts->dh) {\n\t\tDH_free(opts->dh);\n\t}\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\tif (opts->ecdhcurve) {\n\t\tfree(opts->ecdhcurve);\n\t}\n#endif /* !OPENSSL_NO_ECDH */\n\tif (opts->spec) {\n\t\tproxyspec_free(opts->spec);\n\t}\n\tif (opts->ciphers) {\n\t\tfree(opts->ciphers);\n\t}\n#ifndef OPENSSL_NO_ENGINE\n\tif (opts->openssl_engine) {\n\t\tfree(opts->openssl_engine);\n\t}\n#endif /* !OPENSSL_NO_ENGINE */\n\tif (opts->dropuser) {\n\t\tfree(opts->dropuser);\n\t}\n\tif (opts->dropgroup) {\n\t\tfree(opts->dropgroup);\n\t}\n\tif (opts->jaildir) {\n\t\tfree(opts->jaildir);\n\t}\n\tif (opts->pidfile) {\n\t\tfree(opts->pidfile);\n\t}\n\tif (opts->connectlog) {\n\t\tfree(opts->connectlog);\n\t}\n\tif (opts->conffile) {\n\t\tfree(opts->conffile);\n\t}\n\tif (opts->contentlog) {\n\t\tfree(opts->contentlog);\n\t}\n\tif (opts->certgendir) {\n\t\tfree(opts->certgendir);\n\t}\n\tif (opts->contentlog_basedir) {\n\t\tfree(opts->contentlog_basedir);\n\t}\n\tif (opts->masterkeylog) {\n\t\tfree(opts->masterkeylog);\n\t}\n\tif (opts->pcaplog) {\n\t\tfree(opts->pcaplog);\n\t}\n\tif (opts->pcaplog_basedir) {\n\t\tfree(opts->pcaplog_basedir);\n\t}\n#ifndef WITHOUT_MIRROR\n\tif (opts->mirrorif) {\n\t\tfree(opts->mirrorif);\n\t}\n\tif (opts->mirrortarget) {\n\t\tfree(opts->mirrortarget);\n\t}\n#endif /* !WITHOUT_MIRROR */\n\tmemset(opts, 0, sizeof(opts_t));\n\tfree(opts);\n}\n\n/*\n * Return 1 if opts_t contains a proxyspec that (eventually) uses SSL/TLS,\n * 0 otherwise.  When 0, it is safe to assume that no SSL/TLS operations\n * will take place with this configuration.\n */\nint\nopts_has_ssl_spec(opts_t *opts)\n{\n\tproxyspec_t *p = opts->spec;\n\n\twhile (p) {\n\t\tif (p->ssl || p->upgrade)\n\t\t\treturn 1;\n\t\tp = p->next;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Return 1 if opts_t contains a proxyspec with dns, 0 otherwise.\n */\nint\nopts_has_dns_spec(opts_t *opts)\n{\n\tproxyspec_t *p = opts->spec;\n\n\twhile (p) {\n\t\tif (p->dns)\n\t\t\treturn 1;\n\t\tp = p->next;\n\t}\n\n\treturn 0;\n}\n\n/*\n * Dump the SSL/TLS protocol related configuration to the debug log.\n */\nvoid\nopts_proto_dbg_dump(opts_t *opts)\n{\n\tlog_dbg_printf(\"SSL/TLS protocol: %s%s%s%s%s%s\\n\",\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n#ifdef HAVE_SSLV2\n\t               (opts->sslmethod == SSLv2_method) ? \"ssl2\" :\n#endif /* HAVE_SSLV2 */\n#ifdef HAVE_SSLV3\n\t               (opts->sslmethod == SSLv3_method) ? \"ssl3\" :\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\t               (opts->sslmethod == TLSv1_method) ? \"tls10\" :\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\t               (opts->sslmethod == TLSv1_1_method) ? \"tls11\" :\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\t               (opts->sslmethod == TLSv1_2_method) ? \"tls12\" :\n#endif /* HAVE_TLSV12 */\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n#ifdef HAVE_SSLV3\n\t               (opts->sslversion == SSL3_VERSION) ? \"ssl3\" :\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\t               (opts->sslversion == TLS1_VERSION) ? \"tls10\" :\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\t               (opts->sslversion == TLS1_1_VERSION) ? \"tls11\" :\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\t               (opts->sslversion == TLS1_2_VERSION) ? \"tls12\" :\n#endif /* HAVE_TLSV12 */\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\t               \"negotiate\",\n#ifdef HAVE_SSLV2\n\t               opts->no_ssl2 ? \" -ssl2\" :\n#endif /* HAVE_SSLV2 */\n\t               \"\",\n#ifdef HAVE_SSLV3\n\t               opts->no_ssl3 ? \" -ssl3\" :\n#endif /* HAVE_SSLV3 */\n\t               \"\",\n#ifdef HAVE_TLSV10\n\t               opts->no_tls10 ? \" -tls10\" :\n#endif /* HAVE_TLSV10 */\n\t               \"\",\n#ifdef HAVE_TLSV11\n\t               opts->no_tls11 ? \" -tls11\" :\n#endif /* HAVE_TLSV11 */\n\t               \"\",\n#ifdef HAVE_TLSV12\n\t               opts->no_tls12 ? \" -tls12\" :\n#endif /* HAVE_TLSV12 */\n\t               \"\");\n}\n\n/*\n * Parse proxyspecs using a simple state machine.\n */\nvoid\nproxyspec_parse(int *argc, char **argv[], const char *natengine,\n                proxyspec_t **opts_spec)\n{\n\tproxyspec_t *spec = NULL;\n\tchar *addr = NULL;\n\tint af = AF_UNSPEC;\n\tint state = 0;\n\n\twhile ((*argc)--) {\n\t\tswitch (state) {\n\t\t\tdefault:\n\t\t\tcase 0:\n\t\t\t\t/* tcp | ssl | http | https | autossl */\n\t\t\t\tspec = malloc(sizeof(proxyspec_t));\n\t\t\t\tmemset(spec, 0, sizeof(proxyspec_t));\n\t\t\t\tspec->next = *opts_spec;\n\t\t\t\t*opts_spec = spec;\n\n\t\t\t\t/* Defaults */\n\t\t\t\tspec->ssl = 0;\n\t\t\t\tspec->http = 0;\n\t\t\t\tspec->upgrade = 0;\n\t\t\t\tif (!strcmp(**argv, \"tcp\")) {\n\t\t\t\t\t/* use defaults */\n\t\t\t\t} else\n\t\t\t\tif (!strcmp(**argv, \"ssl\")) {\n\t\t\t\t\tspec->ssl = 1;\n\t\t\t\t} else\n\t\t\t\tif (!strcmp(**argv, \"http\")) {\n\t\t\t\t\tspec->http = 1;\n\t\t\t\t} else\n\t\t\t\tif (!strcmp(**argv, \"https\")) {\n\t\t\t\t\tspec->ssl = 1;\n\t\t\t\t\tspec->http = 1;\n\t\t\t\t} else\n\t\t\t\tif (!strcmp(**argv, \"autossl\")) {\n\t\t\t\t\tspec->upgrade = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Unknown connection \"\n\t\t\t\t\t                \"type '%s'\\n\", **argv);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tstate++;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t/* listenaddr */\n\t\t\t\taddr = **argv;\n\t\t\t\tstate++;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t/* listenport */\n\t\t\t\taf = sys_sockaddr_parse(&spec->listen_addr,\n\t\t\t\t                        &spec->listen_addrlen,\n\t\t\t\t                        addr, **argv,\n\t\t\t\t                        sys_get_af(addr),\n\t\t\t\t                        EVUTIL_AI_PASSIVE);\n\t\t\t\tif (af == -1) {\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tif (natengine) {\n\t\t\t\t\tspec->natengine = strdup(natengine);\n\t\t\t\t\tif (!spec->natengine) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t        \"Out of memory\"\n\t\t\t\t\t\t        \"\\n\");\n\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tspec->natengine = NULL;\n\t\t\t\t}\n\t\t\t\tstate++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t/* [ natengine | dstaddr ] */\n\t\t\t\tif (!strcmp(**argv, \"tcp\") ||\n\t\t\t\t    !strcmp(**argv, \"ssl\") ||\n\t\t\t\t    !strcmp(**argv, \"http\") ||\n\t\t\t\t    !strcmp(**argv, \"https\") ||\n\t\t\t\t    !strcmp(**argv, \"autossl\")) {\n\t\t\t\t\t/* implicit default natengine */\n\t\t\t\t\t(*argv)--; (*argc)++; /* rewind */\n\t\t\t\t\tstate = 0;\n\t\t\t\t} else\n\t\t\t\tif (!strcmp(**argv, \"sni\")) {\n\t\t\t\t\tfree(spec->natengine);\n\t\t\t\t\tspec->natengine = NULL;\n\t\t\t\t\tif (!spec->ssl) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t        \"SNI hostname lookup \"\n\t\t\t\t\t\t        \"only works for ssl \"\n\t\t\t\t\t\t        \"and https proxyspecs\"\n\t\t\t\t\t\t        \"\\n\");\n\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\t\tstate = 5;\n\t\t\t\t} else\n\t\t\t\tif (nat_exist(**argv)) {\n\t\t\t\t\t/* natengine */\n\t\t\t\t\tfree(spec->natengine);\n\t\t\t\t\tspec->natengine = strdup(**argv);\n\t\t\t\t\tif (!spec->natengine) {\n\t\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t        \"Out of memory\"\n\t\t\t\t\t\t        \"\\n\");\n\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\t\tstate = 0;\n\t\t\t\t} else {\n\t\t\t\t\t/* explicit target address */\n\t\t\t\t\tfree(spec->natengine);\n\t\t\t\t\tspec->natengine = NULL;\n\t\t\t\t\taddr = **argv;\n\t\t\t\t\tstate++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t/* dstport */\n\t\t\t\taf = sys_sockaddr_parse(&spec->connect_addr,\n\t\t\t\t                        &spec->connect_addrlen,\n\t\t\t\t                        addr, **argv, af, 0);\n\t\t\t\tif (af == -1) {\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tstate = 0;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\t/* SNI dstport */\n\t\t\t\tspec->sni_port = atoi(**argv);\n\t\t\t\tif (!spec->sni_port) {\n\t\t\t\t\tfprintf(stderr, \"Invalid port '%s'\\n\",\n\t\t\t\t\t                **argv);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tspec->dns = 1;\n\t\t\t\tstate = 0;\n\t\t\t\tbreak;\n\t\t}\n\t\t(*argv)++;\n\t}\n\tif (state != 0 && state != 3) {\n\t\tfprintf(stderr, \"Incomplete proxyspec!\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\n/*\n * Clear and free a proxy spec.\n */\nvoid\nproxyspec_free(proxyspec_t *spec)\n{\n\tdo {\n\t\tproxyspec_t *next = spec->next;\n\t\tif (spec->natengine)\n\t\t\tfree(spec->natengine);\n\t\tmemset(spec, 0, sizeof(proxyspec_t));\n\t\tfree(spec);\n\t\tspec = next;\n\t} while (spec);\n}\n\n/*\n * Return text representation of proxy spec for display to the user.\n * Returned string must be freed by caller.\n */\nchar *\nproxyspec_str(proxyspec_t *spec)\n{\n\tchar *s = NULL;\n\tchar *lhbuf = NULL;\n\tchar *lpbuf = NULL;\n\tchar *chbuf = NULL;\n\tchar *cpbuf = NULL;\n\tchar *cbuf = NULL;\n\n\tif (sys_sockaddr_str((struct sockaddr *)&spec->listen_addr,\n\t                     spec->listen_addrlen, &lhbuf, &lpbuf) != 0) {\n\t\tgoto out;\n\t}\n\tif (spec->connect_addrlen) {\n\t\tif (sys_sockaddr_str((struct sockaddr *)&spec->connect_addr,\n\t\t                     spec->connect_addrlen,\n\t\t                     &chbuf, &cpbuf) != 0) {\n\t\t\tgoto out;\n\t\t}\n\t\tif (asprintf(&cbuf, \"[%s]:%s\", chbuf, cpbuf) < 0) {\n\t\t\tcbuf = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (spec->sni_port) {\n\t\tif (asprintf(&cbuf, \"sni %i\", spec->sni_port) < 0) {\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (asprintf(&s, \"[%s]:%s %s%s%s %s\", lhbuf, lpbuf,\n\t             (spec->ssl ? \"ssl\" : \"tcp\"),\n\t             (spec->upgrade ? \"|upgrade\" : \"\"),\n\t             (spec->http ? \"|http\" : \"\"),\n\t             (spec->natengine ? spec->natengine : cbuf)) < 0) {\n\t\ts = NULL;\n\t}\nout:\n\tif (lhbuf)\n\t\tfree(lhbuf);\n\tif (lpbuf)\n\t\tfree(lpbuf);\n\tif (chbuf)\n\t\tfree(chbuf);\n\tif (cpbuf)\n\t\tfree(cpbuf);\n\tif (cbuf)\n\t\tfree(cbuf);\n\treturn s;\n}\n\nvoid\nopts_set_cacrt(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->cacrt)\n\t\tX509_free(opts->cacrt);\n\topts->cacrt = ssl_x509_load(optarg);\n\tif (!opts->cacrt) {\n\t\tfprintf(stderr, \"%s: error loading CA cert from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\tssl_x509_refcount_inc(opts->cacrt);\n\tsk_X509_insert(opts->cachain, opts->cacrt, 0);\n\tif (!opts->cakey) {\n\t\topts->cakey = ssl_key_load(optarg);\n\t}\n#ifndef OPENSSL_NO_DH\n\tif (!opts->dh) {\n\t\topts->dh = ssl_dh_load(optarg);\n\t}\n#endif /* !OPENSSL_NO_DH */\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"CACert: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_cakey(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->cakey)\n\t\tEVP_PKEY_free(opts->cakey);\n\topts->cakey = ssl_key_load(optarg);\n\tif (!opts->cakey) {\n\t\tfprintf(stderr, \"%s: error loading CA key from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (!opts->cacrt) {\n\t\topts->cacrt = ssl_x509_load(optarg);\n\t\tif (opts->cacrt) {\n\t\t\tssl_x509_refcount_inc(opts->cacrt);\n\t\t\tsk_X509_insert(opts->cachain, opts->cacrt, 0);\n\t\t}\n\t}\n#ifndef OPENSSL_NO_DH\n\tif (!opts->dh) {\n\t\topts->dh = ssl_dh_load(optarg);\n\t}\n#endif /* !OPENSSL_NO_DH */\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"CAKey: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_cachain(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (ssl_x509chain_load(NULL, &opts->cachain, optarg) == -1) {\n\t\tfprintf(stderr, \"%s: error loading CA chain from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"CAChain: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_leafkey(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->leafkey)\n\t\tEVP_PKEY_free(opts->leafkey);\n\topts->leafkey = ssl_key_load(optarg);\n\tif (!opts->leafkey) {\n\t\tfprintf(stderr, \"%s: error loading leaf key from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n#ifndef OPENSSL_NO_DH\n\tif (!opts->dh) {\n\t\topts->dh = ssl_dh_load(optarg);\n\t}\n#endif /* !OPENSSL_NO_DH */\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"LeafKey: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_leafcrlurl(opts_t *opts, const char *optarg)\n{\n\tif (opts->leafcrlurl)\n\t\tfree(opts->leafcrlurl);\n\topts->leafcrlurl = strdup(optarg);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"LeafCRLURL: %s\\n\", opts->leafcrlurl);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_leafcertdir(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (!sys_isdir(optarg)) {\n\t\tfprintf(stderr, \"%s: '%s' is not a directory\\n\",\n\t\t        argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (opts->leafcertdir)\n\t\tfree(opts->leafcertdir);\n\topts->leafcertdir = strdup(optarg);\n\tif (!opts->leafcertdir)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"LeafCertDir: %s\\n\", opts->leafcertdir);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_defaultleafcert(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->defaultleafcert)\n\t\tcert_free(opts->defaultleafcert);\n\topts->defaultleafcert = opts_load_cert_chain_key(optarg);\n\tif (!opts->defaultleafcert) {\n\t\tfprintf(stderr, \"%s: error loading default leaf cert/chain/key\"\n\t\t                \" from '%s':\\n\", argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"DefaultLeafCert: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nstatic void\nset_certgendir(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->certgendir)\n\t\tfree(opts->certgendir);\n\topts->certgendir = strdup(optarg);\n\tif (!opts->certgendir)\n\t\toom_die(argv0);\n}\n\nvoid\nopts_set_certgendir_writegencerts(opts_t *opts, const char *argv0,\n                                  const char *optarg)\n{\n\topts->certgen_writeall = 0;\n\tset_certgendir(opts, argv0, optarg);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"WriteGenCertsDir: certgendir=%s, writeall=%u\\n\",\n\t               opts->certgendir, opts->certgen_writeall);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_certgendir_writeall(opts_t *opts, const char *argv0,\n                             const char *optarg)\n{\n\topts->certgen_writeall = 1;\n\tset_certgendir(opts, argv0, optarg);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"WriteAllCertsDir: certgendir=%s, writeall=%u\\n\",\n\t               opts->certgendir, opts->certgen_writeall);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_deny_ocsp(opts_t *opts)\n{\n\topts->deny_ocsp = 1;\n}\n\nvoid\nopts_unset_deny_ocsp(opts_t *opts)\n{\n\topts->deny_ocsp = 0;\n}\n\nvoid\nopts_set_passthrough(opts_t *opts)\n{\n\topts->passthrough = 1;\n}\n\nvoid\nopts_unset_passthrough(opts_t *opts)\n{\n\topts->passthrough = 0;\n}\n\nvoid\nopts_set_clientcrt(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->clientcrt)\n\t\tX509_free(opts->clientcrt);\n\topts->clientcrt = ssl_x509_load(optarg);\n\tif (!opts->clientcrt) {\n\t\tfprintf(stderr, \"%s: error loading client cert from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ClientCert: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_clientkey(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->clientkey)\n\t\tEVP_PKEY_free(opts->clientkey);\n\topts->clientkey = ssl_key_load(optarg);\n\tif (!opts->clientkey) {\n\t\tfprintf(stderr, \"%s: error loading client key from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ClientKey: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\n#ifndef OPENSSL_NO_DH\nvoid\nopts_set_dh(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->dh)\n\t\tDH_free(opts->dh);\n\topts->dh = ssl_dh_load(optarg);\n\tif (!opts->dh) {\n\t\tfprintf(stderr, \"%s: error loading DH params from '%s':\\n\",\n\t\t        argv0, optarg);\n\t\tif (errno) {\n\t\t\tfprintf(stderr, \"%s\\n\", strerror(errno));\n\t\t} else {\n\t\t\tERR_print_errors_fp(stderr);\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"DHGroupParams: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_ECDH\nvoid\nopts_set_ecdhcurve(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tEC_KEY *ec;\n\tif (opts->ecdhcurve)\n\t\tfree(opts->ecdhcurve);\n\tif (!(ec = ssl_ec_by_name(optarg))) {\n\t\tfprintf(stderr, \"%s: unknown curve '%s'\\n\", argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tEC_KEY_free(ec);\n\topts->ecdhcurve = strdup(optarg);\n\tif (!opts->ecdhcurve)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ECDHCurve: %s\\n\", opts->ecdhcurve);\n#endif /* DEBUG_OPTS */\n}\n#endif /* !OPENSSL_NO_ECDH */\n\nvoid\nopts_set_sslcomp(opts_t *opts)\n{\n\topts->sslcomp = 1;\n}\n\nvoid\nopts_unset_sslcomp(opts_t *opts)\n{\n\topts->sslcomp = 0;\n}\n\nvoid\nopts_set_ciphers(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->ciphers)\n\t\tfree(opts->ciphers);\n\topts->ciphers = strdup(optarg);\n\tif (!opts->ciphers)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"Ciphers: %s\\n\", opts->ciphers);\n#endif /* DEBUG_OPTS */\n}\n\n#ifndef OPENSSL_NO_ENGINE\nvoid\nopts_set_openssl_engine(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->openssl_engine)\n\t\tfree(opts->openssl_engine);\n\topts->openssl_engine = strdup(optarg);\n\tif (!opts->openssl_engine)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"OpenSSLEngine: %s\\n\", opts->openssl_engine);\n#endif /* DEBUG_OPTS */\n}\n#endif /* !OPENSSL_NO_ENGINE */\n\n/*\n * Parse SSL proto string in optarg and look up the corresponding SSL method.\n * Calls exit() on failure.\n */\nvoid\nopts_force_proto(opts_t *opts, const char *argv0, const char *optarg)\n{\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\tif (opts->sslmethod != SSLv23_method) {\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\tif (opts->sslversion) {\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\t\tfprintf(stderr, \"%s: cannot use -r multiple times\\n\", argv0);\n\t\texit(EXIT_FAILURE);\n\t}\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n#ifdef HAVE_SSLV2\n\tif (!strcmp(optarg, \"ssl2\")) {\n\t\topts->sslmethod = SSLv2_method;\n\t} else\n#endif /* HAVE_SSLV2 */\n#ifdef HAVE_SSLV3\n\tif (!strcmp(optarg, \"ssl3\")) {\n\t\topts->sslmethod = SSLv3_method;\n\t} else\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\tif (!strcmp(optarg, \"tls10\") || !strcmp(optarg, \"tls1\")) {\n\t\topts->sslmethod = TLSv1_method;\n\t} else\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\tif (!strcmp(optarg, \"tls11\")) {\n\t\topts->sslmethod = TLSv1_1_method;\n\t} else\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\tif (!strcmp(optarg, \"tls12\")) {\n\t\topts->sslmethod = TLSv1_2_method;\n\t} else\n#endif /* HAVE_TLSV12 */\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n/*\n * Support for SSLv2 and the corresponding SSLv2_method(),\n * SSLv2_server_method() and SSLv2_client_method() functions were\n * removed in OpenSSL 1.1.0.\n */\n#ifdef HAVE_SSLV3\n\tif (!strcmp(optarg, \"ssl3\")) {\n\t\topts->sslversion = SSL3_VERSION;\n\t} else\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\tif (!strcmp(optarg, \"tls10\") || !strcmp(optarg, \"tls1\")) {\n\t\topts->sslversion = TLS1_VERSION;\n\t} else\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\tif (!strcmp(optarg, \"tls11\")) {\n\t\topts->sslversion = TLS1_1_VERSION;\n\t} else\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\tif (!strcmp(optarg, \"tls12\")) {\n\t\topts->sslversion = TLS1_2_VERSION;\n\t} else\n#endif /* HAVE_TLSV12 */\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\t{\n\t\tfprintf(stderr, \"%s: Unsupported SSL/TLS protocol '%s'\\n\",\n\t\t                argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ForceSSLProto: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\n/*\n * Parse SSL proto string in optarg and set the corresponding no_foo bit.\n * Calls exit() on failure.\n */\nvoid\nopts_disable_proto(opts_t *opts, const char *argv0, const char *optarg)\n{\n#ifdef HAVE_SSLV2\n\tif (!strcmp(optarg, \"ssl2\")) {\n\t\topts->no_ssl2 = 1;\n\t} else\n#endif /* HAVE_SSLV2 */\n#ifdef HAVE_SSLV3\n\tif (!strcmp(optarg, \"ssl3\")) {\n\t\topts->no_ssl3 = 1;\n\t} else\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\tif (!strcmp(optarg, \"tls10\") || !strcmp(optarg, \"tls1\")) {\n\t\topts->no_tls10 = 1;\n\t} else\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\tif (!strcmp(optarg, \"tls11\")) {\n\t\topts->no_tls11 = 1;\n\t} else\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\tif (!strcmp(optarg, \"tls12\")) {\n\t\topts->no_tls12 = 1;\n\t} else\n#endif /* HAVE_TLSV12 */\n\t{\n\t\tfprintf(stderr, \"%s: Unsupported SSL/TLS protocol '%s'\\n\",\n\t\t                argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"DisableSSLProto: %s\\n\", optarg);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_user(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (!sys_isuser(optarg)) {\n\t\tfprintf(stderr, \"%s: '%s' is not an existing user\\n\",\n\t\t        argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (opts->dropuser)\n\t\tfree(opts->dropuser);\n\topts->dropuser = strdup(optarg);\n\tif (!opts->dropuser)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"User: %s\\n\", opts->dropuser);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_group(opts_t *opts, const char *argv0, const char *optarg)\n{\n\n\tif (!sys_isgroup(optarg)) {\n\t\tfprintf(stderr, \"%s: '%s' is not an existing group\\n\",\n\t\t        argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (opts->dropgroup)\n\t\tfree(opts->dropgroup);\n\topts->dropgroup = strdup(optarg);\n\tif (!opts->dropgroup)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"Group: %s\\n\", opts->dropgroup);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_jaildir(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (!sys_isdir(optarg)) {\n\t\tfprintf(stderr, \"%s: '%s' is not a directory\\n\", argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (opts->jaildir)\n\t\tfree(opts->jaildir);\n\topts->jaildir = realpath(optarg, NULL);\n\tif (!opts->jaildir) {\n\t\tfprintf(stderr, \"%s: Failed to realpath '%s': %s (%i)\\n\",\n\t\t        argv0, optarg, strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"Chroot: %s\\n\", opts->jaildir);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_pidfile(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->pidfile)\n\t\tfree(opts->pidfile);\n\topts->pidfile = strdup(optarg);\n\tif (!opts->pidfile)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"PidFile: %s\\n\", opts->pidfile);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_connectlog(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->connectlog)\n\t\tfree(opts->connectlog);\n\tif (!(opts->connectlog = sys_realdir(optarg))) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Directory part of '%s' does not \"\n\t\t\t                \"exist\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Failed to realpath '%s': %s (%i)\\n\",\n\t\t\t              optarg, strerror(errno), errno);\n\t\t\toom_die(argv0);\n\t\t}\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ConnectLog: %s\\n\", opts->connectlog);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_contentlog(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->contentlog)\n\t\tfree(opts->contentlog);\n\tif (!(opts->contentlog = sys_realdir(optarg))) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Directory part of '%s' does not \"\n\t\t\t                \"exist\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Failed to realpath '%s': %s (%i)\\n\",\n\t\t\t              optarg, strerror(errno), errno);\n\t\t\toom_die(argv0);\n\t\t}\n\t}\n\topts->contentlog_isdir = 0;\n\topts->contentlog_isspec = 0;\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ContentLog: %s\\n\", opts->contentlog);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_contentlogdir(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (!sys_isdir(optarg)) {\n\t\tfprintf(stderr, \"%s: '%s' is not a directory\\n\", argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (opts->contentlog)\n\t\tfree(opts->contentlog);\n\topts->contentlog = realpath(optarg, NULL);\n\tif (!opts->contentlog) {\n\t\tfprintf(stderr, \"%s: Failed to realpath '%s': %s (%i)\\n\",\n\t\t        argv0, optarg, strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\topts->contentlog_isdir = 1;\n\topts->contentlog_isspec = 0;\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ContentLogDir: %s\\n\", opts->contentlog);\n#endif /* DEBUG_OPTS */\n}\n\nstatic void\nopts_set_logbasedir(const char *argv0, const char *optarg,\n                    char **basedir, char **log)\n{\n\tchar *lhs, *rhs, *p, *q;\n\tsize_t n;\n\tif (*basedir)\n\t\tfree(*basedir);\n\tif (*log)\n\t\tfree(*log);\n\tif (log_content_split_pathspec(optarg, &lhs, &rhs) == -1) {\n\t\tfprintf(stderr, \"%s: Failed to split '%s' in lhs/rhs:\"\n\t\t                \" %s (%i)\\n\", argv0, optarg,\n\t\t                strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\t/* eliminate %% from lhs */\n\tfor (p = q = lhs; *p; p++, q++) {\n\t\tif (q < p)\n\t\t\t*q = *p;\n\t\tif (*p == '%' && *(p+1) == '%')\n\t\t\tp++;\n\t}\n\t*q = '\\0';\n\t/* all %% in lhs resolved to % */\n\tif (sys_mkpath(lhs, 0777) == -1) {\n\t\tfprintf(stderr, \"%s: Failed to create '%s': %s (%i)\\n\",\n\t\t        argv0, lhs, strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\t*basedir = realpath(lhs, NULL);\n\tif (!*basedir) {\n\t\tfprintf(stderr, \"%s: Failed to realpath '%s': %s (%i)\\n\",\n\t\t        argv0, lhs, strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\t/* count '%' in basedir */\n\tfor (n = 0, p = *basedir;\n\t\t *p;\n\t\t p++) {\n\t\tif (*p == '%')\n\t\t\tn++;\n\t}\n\tfree(lhs);\n\tn += strlen(*basedir);\n\tif (!(lhs = malloc(n + 1)))\n\t\toom_die(argv0);\n\t/* re-encoding % to %%, copying basedir to lhs */\n\tfor (p = *basedir, q = lhs;\n\t\t *p;\n\t\t p++, q++) {\n\t\t*q = *p;\n\t\tif (*q == '%')\n\t\t\t*(++q) = '%';\n\t}\n\t*q = '\\0';\n\t/* lhs contains encoded realpathed basedir */\n\tif (asprintf(log, \"%s/%s\", lhs, rhs) < 0)\n\t\toom_die(argv0);\n\tfree(lhs);\n\tfree(rhs);\n}\n\nvoid\nopts_set_contentlogpathspec(opts_t *opts, const char *argv0, const char *optarg)\n{\n\topts_set_logbasedir(argv0, optarg, &opts->contentlog_basedir,\n\t                    &opts->contentlog);\n\topts->contentlog_isdir = 0;\n\topts->contentlog_isspec = 1;\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"ContentLogPathSpec: basedir=%s, %s\\n\",\n\t               opts->contentlog_basedir, opts->contentlog);\n#endif /* DEBUG_OPTS */\n}\n\n#ifdef HAVE_LOCAL_PROCINFO\nvoid\nopts_set_lprocinfo(opts_t *opts)\n{\n\topts->lprocinfo = 1;\n}\n\nvoid\nopts_unset_lprocinfo(opts_t *opts)\n{\n\topts->lprocinfo = 0;\n}\n#endif /* HAVE_LOCAL_PROCINFO */\n\nvoid\nopts_set_masterkeylog(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->masterkeylog)\n\t\tfree(opts->masterkeylog);\n\tif (!(opts->masterkeylog = sys_realdir(optarg))) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Directory part of '%s' does not \"\n\t\t\t                \"exist\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Failed to realpath '%s': %s (%i)\\n\",\n\t\t\t              optarg, strerror(errno), errno);\n\t\t\toom_die(argv0);\n\t\t}\n\t}\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"MasterKeyLog: %s\\n\", opts->masterkeylog);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_pcaplog(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->pcaplog)\n\t\tfree(opts->pcaplog);\n\tif (!(opts->pcaplog = sys_realdir(optarg))) {\n\t\tif (errno == ENOENT) {\n\t\t\tfprintf(stderr, \"Directory part of '%s' does not \"\n\t\t\t                \"exist\\n\", optarg);\n\t\t\texit(EXIT_FAILURE);\n\t\t} else {\n\t\t\tfprintf(stderr, \"Failed to realpath '%s': %s (%i)\\n\",\n\t\t\t              optarg, strerror(errno), errno);\n\t\t\toom_die(argv0);\n\t\t}\n\t}\n\topts->pcaplog_isdir = 0;\n\topts->pcaplog_isspec = 0;\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"PcapLog: %s\\n\", opts->pcaplog);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_pcaplogdir(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (!sys_isdir(optarg)) {\n\t\tfprintf(stderr, \"%s: '%s' is not a directory\\n\", argv0, optarg);\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (opts->pcaplog)\n\t\tfree(opts->pcaplog);\n\topts->pcaplog = realpath(optarg, NULL);\n\tif (!opts->pcaplog) {\n\t\tfprintf(stderr, \"%s: Failed to realpath '%s': %s (%i)\\n\",\n\t\t        argv0, optarg, strerror(errno), errno);\n\t\texit(EXIT_FAILURE);\n\t}\n\topts->pcaplog_isdir = 1;\n\topts->pcaplog_isspec = 0;\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"PcapLogDir: %s\\n\", opts->pcaplog);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_pcaplogpathspec(opts_t *opts, const char *argv0, const char *optarg)\n{\n\topts_set_logbasedir(argv0, optarg, &opts->pcaplog_basedir,\n\t                    &opts->pcaplog);\n\topts->pcaplog_isdir = 0;\n\topts->pcaplog_isspec = 1;\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"PcapLogPathSpec: basedir=%s, %s\\n\",\n\t               opts->pcaplog_basedir, opts->pcaplog);\n#endif /* DEBUG_OPTS */\n}\n\n#ifndef WITHOUT_MIRROR\nvoid\nopts_set_mirrorif(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->mirrorif)\n\t\tfree(opts->mirrorif);\n\topts->mirrorif = strdup(optarg);\n\tif (!opts->mirrorif)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"MirrorIf: %s\\n\", opts->mirrorif);\n#endif /* DEBUG_OPTS */\n}\n\nvoid\nopts_set_mirrortarget(opts_t *opts, const char *argv0, const char *optarg)\n{\n\tif (opts->mirrortarget)\n\t\tfree(opts->mirrortarget);\n\topts->mirrortarget = strdup(optarg);\n\tif (!opts->mirrortarget)\n\t\toom_die(argv0);\n#ifdef DEBUG_OPTS\n\tlog_dbg_printf(\"MirrorTarget: %s\\n\", opts->mirrortarget);\n#endif /* DEBUG_OPTS */\n}\n#endif /* !WITHOUT_MIRROR */\n\nvoid\nopts_set_daemon(opts_t *opts)\n{\n\topts->detach = 1;\n}\n\nvoid\nopts_unset_daemon(opts_t *opts)\n{\n\topts->detach = 0;\n}\n\nvoid\nopts_set_debug(opts_t *opts)\n{\n\tlog_dbg_mode(LOG_DBG_MODE_ERRLOG);\n\topts->debug = 1;\n}\n\nvoid\nopts_unset_debug(opts_t *opts)\n{\n\tlog_dbg_mode(LOG_DBG_MODE_NONE);\n\topts->debug = 0;\n}\n\nstatic void\nopts_set_verify_peer(opts_t *opts)\n{\n\topts->verify_peer = 1;\n}\n\nstatic void\nopts_unset_verify_peer(opts_t *opts)\n{\n\topts->verify_peer = 0;\n}\n\nstatic void\nopts_set_allow_wrong_host(opts_t *opts)\n{\n\topts->allow_wrong_host = 1;\n}\n\nstatic void\nopts_unset_allow_wrong_host(opts_t *opts)\n{\n\topts->allow_wrong_host = 0;\n}\n\nstatic int\ncheck_value_yesno(const char *value, const char *name, int line_num)\n{\n\tif (!strcmp(value, \"yes\")) {\n\t\treturn 1;\n\t} else if (!strcmp(value, \"no\")) {\n\t\treturn 0;\n\t}\n\tfprintf(stderr, \"Error in conf: Invalid '%s' value '%s' at line %d, use yes|no\\n\", name, value, line_num);\n\treturn -1;\n}\n\n#define MAX_TOKEN 10\n\nstatic int\nset_option(opts_t *opts, const char *argv0,\n           const char *name, char *value, char **natengine, int line_num)\n{\n\tint yes;\n\tint retval = -1;\n\n\tif (!strcmp(name, \"CACert\")) {\n\t\topts_set_cacrt(opts, argv0, value);\n\t} else if (!strcmp(name, \"CAKey\")) {\n\t\topts_set_cakey(opts, argv0, value);\n\t} else if (!strcmp(name, \"ClientCert\")) {\n\t\topts_set_clientcrt(opts, argv0, value);\n\t} else if (!strcmp(name, \"ClientKey\")) {\n\t\topts_set_clientkey(opts, argv0, value);\n\t} else if (!strcmp(name, \"CAChain\")) {\n\t\topts_set_cachain(opts, argv0, value);\n\t} else if (!strcmp(name, \"LeafCerts\") ||        /* compat <= 0.5.4 */\n\t           !strcmp(name, \"LeafKey\")) {\n\t\topts_set_leafkey(opts, argv0, value);\n\t} else if (!strcmp(name, \"CRL\") ||              /* compat <= 0.5.4 */\n\t           !strcmp(name, \"LeafCRLURL\")) {\n\t\topts_set_leafcrlurl(opts, value);\n\t} else if (!strcmp(name, \"TargetCertDir\") ||    /* compat <= 0.5.4 */\n\t           !strcmp(name, \"LeafCertDir\")) {\n\t\topts_set_leafcertdir(opts, argv0, value);\n\t} else if (!strcmp(name, \"DefaultLeafCert\")) {\n\t\topts_set_defaultleafcert(opts, argv0, value);\n\t} else if (!strcmp(name, \"WriteGenCertsDir\")) {\n\t\topts_set_certgendir_writegencerts(opts, argv0, value);\n\t} else if (!strcmp(name, \"WriteAllCertsDir\")) {\n\t\topts_set_certgendir_writeall(opts, argv0, value);\n\t} else if (!strcmp(name, \"DenyOCSP\")) {\n\t\tyes = check_value_yesno(value, \"DenyOCSP\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_deny_ocsp(opts) : opts_unset_deny_ocsp(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"DenyOCSP: %u\\n\", opts->deny_ocsp);\n#endif /* DEBUG_OPTS */\n\t} else if (!strcmp(name, \"Passthrough\")) {\n\t\tyes = check_value_yesno(value, \"Passthrough\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_passthrough(opts) : opts_unset_passthrough(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"Passthrough: %u\\n\", opts->passthrough);\n#endif /* DEBUG_OPTS */\n#ifndef OPENSSL_NO_DH\n\t} else if (!strcmp(name, \"DHGroupParams\")) {\n\t\topts_set_dh(opts, argv0, value);\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\t} else if (!strcmp(name, \"ECDHCurve\")) {\n\t\topts_set_ecdhcurve(opts, argv0, value);\n#endif /* !OPENSSL_NO_ECDH */\n#ifdef SSL_OP_NO_COMPRESSION\n\t} else if (!strcmp(name, \"SSLCompression\")) {\n\t\tyes = check_value_yesno(value, \"SSLCompression\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_sslcomp(opts) : opts_unset_sslcomp(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"SSLCompression: %u\\n\", opts->sslcomp);\n#endif /* DEBUG_OPTS */\n#endif /* SSL_OP_NO_COMPRESSION */\n\t} else if (!strcmp(name, \"ForceSSLProto\")) {\n\t\topts_force_proto(opts, argv0, value);\n\t} else if (!strcmp(name, \"DisableSSLProto\")) {\n\t\topts_disable_proto(opts, argv0, value);\n\t} else if (!strcmp(name, \"Ciphers\")) {\n\t\topts_set_ciphers(opts, argv0, value);\n#ifndef OPENSSL_NO_ENGINE\n\t} else if (!strcmp(name, \"OpenSSLEngine\")) {\n\t\topts_set_openssl_engine(opts, argv0, value);\n#endif /* !OPENSSL_NO_ENGINE */\n\t} else if (!strcmp(name, \"NATEngine\")) {\n\t\tif (*natengine)\n\t\t\tfree(*natengine);\n\t\t*natengine = strdup(value);\n\t\tif (!*natengine)\n\t\t\tgoto leave;\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"NATEngine: %s\\n\", *natengine);\n#endif /* DEBUG_OPTS */\n\t} else if (!strcmp(name, \"User\")) {\n\t\topts_set_user(opts, argv0, value);\n\t} else if (!strcmp(name, \"Group\")) {\n\t\topts_set_group(opts, argv0, value);\n\t} else if (!strcmp(name, \"Chroot\")) {\n\t\topts_set_jaildir(opts, argv0, value);\n\t} else if (!strcmp(name, \"PidFile\")) {\n\t\topts_set_pidfile(opts, argv0, value);\n\t} else if (!strcmp(name, \"ConnectLog\")) {\n\t\topts_set_connectlog(opts, argv0, value);\n\t} else if (!strcmp(name, \"ContentLog\")) {\n\t\topts_set_contentlog(opts, argv0, value);\n\t} else if (!strcmp(name, \"ContentLogDir\")) {\n\t\topts_set_contentlogdir(opts, argv0, value);\n\t} else if (!strcmp(name, \"ContentLogPathSpec\")) {\n\t\topts_set_contentlogpathspec(opts, argv0, value);\n#ifdef HAVE_LOCAL_PROCINFO\n\t} else if (!strcmp(name, \"LogProcInfo\")) {\n\t\tyes = check_value_yesno(value, \"LogProcInfo\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_lprocinfo(opts) : opts_unset_lprocinfo(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"LogProcInfo: %u\\n\", opts->lprocinfo);\n#endif /* DEBUG_OPTS */\n#endif /* HAVE_LOCAL_PROCINFO */\n\t} else if (!strcmp(name, \"MasterKeyLog\")) {\n\t\topts_set_masterkeylog(opts, argv0, value);\n\t} else if (!strcmp(name, \"PcapLog\")) {\n\t\topts_set_pcaplog(opts, argv0, value);\n\t} else if (!strcmp(name, \"PcapLogDir\")) {\n\t\topts_set_pcaplogdir(opts, argv0, value);\n\t} else if (!strcmp(name, \"PcapLogPathSpec\")) {\n\t\topts_set_pcaplogpathspec(opts, argv0, value);\n#ifndef WITHOUT_MIRROR\n\t} else if (!strcmp(name, \"MirrorIf\")) {\n\t\topts_set_mirrorif(opts, argv0, value);\n\t} else if (!strcmp(name, \"MirrorTarget\")) {\n\t\topts_set_mirrortarget(opts, argv0, value);\n#endif /* !WITHOUT_MIRROR */\n\t} else if (!strcmp(name, \"Daemon\")) {\n\t\tyes = check_value_yesno(value, \"Daemon\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_daemon(opts) : opts_unset_daemon(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"Daemon: %u\\n\", opts->detach);\n#endif /* DEBUG_OPTS */\n\t} else if (!strcmp(name, \"Debug\")) {\n\t\tyes = check_value_yesno(value, \"Debug\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_debug(opts) : opts_unset_debug(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"Debug: %u\\n\", opts->debug);\n#endif /* DEBUG_OPTS */\n\t} else if (!strcmp(name, \"ProxySpec\")) {\n\t\t/* Use MAX_TOKEN instead of computing the actual number of tokens in value */\n\t\tchar **argv = malloc(sizeof(char *) * MAX_TOKEN);\n\t\tchar **save_argv = argv;\n\t\tint argc = 0;\n\t\tchar *p, *last = NULL;\n\n\t\tfor ((p = strtok_r(value, \" \", &last));\n\t\t     p;\n\t\t     (p = strtok_r(NULL, \" \", &last))) {\n\t\t\t/* Limit max # token */\n\t\t\tif (argc < MAX_TOKEN) {\n\t\t\t\targv[argc++] = p;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tproxyspec_parse(&argc, &argv, *natengine, &opts->spec);\n\t\tfree(save_argv);\n\t} else if (!strcmp(name, \"VerifyPeer\")) {\n\t\tyes = check_value_yesno(value, \"VerifyPeer\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_verify_peer(opts) : opts_unset_verify_peer(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"VerifyPeer: %u\\n\", opts->verify_peer);\n#endif /* DEBUG_OPTS */\n\t} else if (!strcmp(name, \"AddSNIToCertificate\")) {\n\t\tyes = check_value_yesno(value, \"AddSNIToCertificate\", line_num);\n\t\tif (yes == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tyes ? opts_set_allow_wrong_host(opts)\n\t\t    : opts_unset_allow_wrong_host(opts);\n#ifdef DEBUG_OPTS\n\t\tlog_dbg_printf(\"AddSNIToCertificate: %u\\n\",\n\t\t               opts->allow_wrong_host);\n#endif /* DEBUG_OPTS */\n\t} else {\n\t\tfprintf(stderr, \"Error in conf: Unknown option \"\n\t\t                \"'%s' at line %d\\n\", name, line_num);\n\t\tgoto leave;\n\t}\n\n\tretval = 0;\nleave:\n\treturn retval;\n}\n\n/*\n * Separator param is needed for command line options only.\n * Conf file option separator is ' '.\n */\nstatic int\nget_name_value(char **name, char **value, const char sep)\n{\n\tchar *n, *v, *value_end;\n\tint retval = -1;\n\n\t/* Skip to the end of option name and terminate it with '\\0' */\n\tfor (n = *name;; n++) {\n\t\t/* White spaces possible around separator,\n\t\t * if the command line option is passed between the quotes */\n\t\tif (*n == ' ' || *n == '\\t' || *n == sep) {\n\t\t\t*n = '\\0';\n\t\t\tn++;\n\t\t\tbreak;\n\t\t}\n\t\tif (*n == '\\0') {\n\t\t\tn = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* No option name */\n\tif (n == NULL) {\n\t\tfprintf(stderr, \"Error in option: No option name\\n\");\n\t\tgoto leave;\n\t}\n\n\t/* White spaces possible before value and around separator,\n\t * if the command line option is passed between the quotes */\n\twhile (*n == ' ' || *n == '\\t' || *n == sep) {\n\t\tn++;\n\t}\n\n\t*value = n;\n\n\t/* Find end of value and terminate it with '\\0'\n\t * Find first occurrence of trailing white space */\n\tvalue_end = NULL;\n\tfor (v = *value;; v++) {\n\t\tif (*v == '\\0') {\n\t\t\tbreak;\n\t\t}\n\t\tif (*v == '\\r' || *v == '\\n') {\n\t\t\t*v = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tif (*v == ' ' || *v == '\\t') {\n\t\t\tif (!value_end) {\n\t\t\t\tvalue_end = v;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue_end = NULL;\n\t\t}\n\t}\n\n\tif (value_end) {\n\t\t*value_end = '\\0';\n\t}\n\n\tretval = 0;\nleave:\n\treturn retval;\n}\n\nint\nopts_set_option(opts_t *opts, const char *argv0, const char *optarg,\n                char **natengine)\n{\n\tchar *name, *value, *line;\n\tint retval = -1;\n\tname = line = strdup(optarg);\n\n\t/* White spaces possible before option name,\n\t * if the command line option is passed between the quotes */\n\tif (name)\n\t\tfor (; *name == ' ' || *name == '\\t'; name++);\n\n\t/* Command line option separator is '=' */\n\tretval = get_name_value(&name, &value, '=');\n\tif (retval == 0) {\n\t\t/* Line number param is for conf file, pass 0 for command line options */\n\t\tretval = set_option(opts, argv0, name, value, natengine, 0);\n\t}\n\n\tif (line)\n\t\tfree(line);\n\treturn retval;\n}\n\nint\nload_conffile(opts_t *opts, const char *argv0, char **natengine)\n{\n\tint retval, line_num;\n\tchar *line, *name, *value;\n\tsize_t line_len;\n\tFILE *f;\n\t\n\tf = fopen(opts->conffile, \"r\");\n\tif (!f) {\n\t\tfprintf(stderr, \"Error opening conf file '%s': %s\\n\", opts->conffile, strerror(errno));\n\t\treturn -1;\n\t}\n\n\tline = NULL;\n\tline_num = 0;\n\tretval = -1;\n\twhile (!feof(f)) {\n\t\tif (getline(&line, &line_len, f) == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (line == NULL) {\n\t\t\tfprintf(stderr, \"Error in conf file: getline() returns NULL line after line %d\\n\", line_num);\n\t\t\tgoto leave;\n\t\t}\n\t\tline_num++;\n\n\t\t/* Skip white space */\n\t\tfor (name = line; *name == ' ' || *name == '\\t'; name++); \n\n\t\t/* Skip comments and empty lines */\n\t\tif ((name[0] == '\\0') || (name[0] == '#') || (name[0] == ';') ||\n\t\t\t(name[0] == '\\r') || (name[0] == '\\n')) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tretval = get_name_value(&name, &value, ' ');\n\t\tif (retval == 0) {\n\t\t\tretval = set_option(opts, argv0, name, value, natengine, line_num);\n\t\t}\n\n\t\tif (retval == -1) {\n\t\t\tgoto leave;\n\t\t}\n\t\tfree(line);\n\t\tline = NULL;\n\t}\n\nleave:\n\tfclose(f);\n\tif (line)\n\t\tfree(line);\n\treturn retval;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "opts.h",
          "type": "blob",
          "size": 7.623046875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef OPTS_H\n#define OPTS_H\n\n#include \"proc.h\"\n#include \"nat.h\"\n#include \"ssl.h\"\n#include \"cert.h\"\n#include \"attrib.h\"\n\ntypedef struct proxyspec {\n\tunsigned int ssl : 1;\n\tunsigned int http : 1;\n\tunsigned int upgrade: 1;\n\tunsigned int dns : 1;\t\t/* set if spec needs DNS lookups */\n\tstruct sockaddr_storage listen_addr;\n\tsocklen_t listen_addrlen;\n\t/* connect_addr and connect_addrlen are set: static mode;\n\t * natlookup is set: NAT mode; natsocket /may/ be set too;\n\t * sni_port is set, in which case we use SNI lookups */\n\tstruct sockaddr_storage connect_addr;\n\tsocklen_t connect_addrlen;\n\tunsigned short sni_port;\n\tchar *natengine;\n\tnat_lookup_cb_t natlookup;\n\tnat_socket_cb_t natsocket;\n\tstruct proxyspec *next;\n} proxyspec_t;\n\ntypedef struct opts {\n\tunsigned int debug : 1;\n\tunsigned int detach : 1;\n\tunsigned int sslcomp : 1;\n#ifdef HAVE_SSLV2\n\tunsigned int no_ssl2 : 1;\n#endif /* HAVE_SSLV2 */\n#ifdef HAVE_SSLV3\n\tunsigned int no_ssl3 : 1;\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\tunsigned int no_tls10 : 1;\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\tunsigned int no_tls11 : 1;\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\tunsigned int no_tls12 : 1;\n#endif /* HAVE_TLSV12 */\n\tunsigned int passthrough : 1;\n\tunsigned int deny_ocsp : 1;\n\tunsigned int contentlog_isdir : 1;\n\tunsigned int contentlog_isspec : 1;\n\tunsigned int pcaplog_isdir : 1;\n\tunsigned int pcaplog_isspec : 1;\n#ifdef HAVE_LOCAL_PROCINFO\n\tunsigned int lprocinfo : 1;\n#endif /* HAVE_LOCAL_PROCINFO */\n\tunsigned int certgen_writeall : 1;\n#ifndef OPENSSL_NO_ENGINE\n\tchar *openssl_engine;\n#endif /* !OPENSSL_NO_ENGINE */\n\tchar *ciphers;\n\tchar *certgendir;\n\tchar *leafcertdir;\n\tchar *leafcrlurl;\n\tchar *dropuser;\n\tchar *dropgroup;\n\tchar *jaildir;\n\tchar *pidfile;\n\tchar *conffile;\n\tchar *connectlog;\n\tchar *contentlog;\n\tchar *contentlog_basedir; /* static part of logspec for privsep srv */\n\tchar *masterkeylog;\n\tchar *pcaplog;\n\tchar *pcaplog_basedir; /* static part of pcap logspec for privsep srv */\n#ifndef WITHOUT_MIRROR\n\tchar *mirrorif;\n\tchar *mirrortarget;\n#endif /* !WITHOUT_MIRROR */\n\tCONST_SSL_METHOD *(*sslmethod)(void);\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n\tint sslversion;\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\tX509 *cacrt;\n\tEVP_PKEY *cakey;\n\tSTACK_OF(X509) *cachain;\n\tEVP_PKEY *leafkey;\n\tcert_t *defaultleafcert;\n\tX509 *clientcrt;\n\tEVP_PKEY *clientkey;\n#ifndef OPENSSL_NO_DH\n\tDH *dh;\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\tchar *ecdhcurve;\n#endif /* !OPENSSL_NO_ECDH */\n\tproxyspec_t *spec;\n\tunsigned int verify_peer: 1;\n\tunsigned int allow_wrong_host: 1;\n} opts_t;\n\nvoid NORET oom_die(const char *) NONNULL(1);\ncert_t *opts_load_cert_chain_key(const char *) NONNULL(1);\n\nopts_t *opts_new(void) MALLOC;\nvoid opts_free(opts_t *) NONNULL(1);\nint opts_has_ssl_spec(opts_t *) NONNULL(1) WUNRES;\nint opts_has_dns_spec(opts_t *) NONNULL(1) WUNRES;\nvoid opts_proto_dbg_dump(opts_t *) NONNULL(1);\n#define OPTS_DEBUG(opts) unlikely((opts)->debug)\n\nvoid proxyspec_parse(int *, char **[], const char *, proxyspec_t **);\nvoid proxyspec_free(proxyspec_t *) NONNULL(1);\nchar *proxyspec_str(proxyspec_t *) NONNULL(1) MALLOC;\n\nvoid opts_set_cacrt(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_cakey(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_cachain(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_leafkey(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_leafcrlurl(opts_t *, const char *) NONNULL(1,2);\nvoid opts_set_leafcertdir(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_defaultleafcert(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\nvoid opts_set_certgendir_writeall(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\nvoid opts_set_certgendir_writegencerts(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\nvoid opts_set_deny_ocsp(opts_t *) NONNULL(1);\nvoid opts_set_passthrough(opts_t *) NONNULL(1);\nvoid opts_set_clientcrt(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_clientkey(opts_t *, const char *, const char *) NONNULL(1,2,3);\n#ifndef OPENSSL_NO_DH\nvoid opts_set_dh(opts_t *, const char *, const char *) NONNULL(1,2,3);\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\nvoid opts_set_ecdhcurve(opts_t *, const char *, const char *) NONNULL(1,2,3);\n#endif /* !OPENSSL_NO_ECDH */\nvoid opts_unset_sslcomp(opts_t *) NONNULL(1);\nvoid opts_force_proto(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_disable_proto(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_ciphers(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_openssl_engine(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\nvoid opts_set_user(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_group(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_jaildir(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_pidfile(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_connectlog(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_contentlog(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_contentlogdir(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\nvoid opts_set_contentlogpathspec(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\n#ifdef HAVE_LOCAL_PROCINFO\nvoid opts_set_lprocinfo(opts_t *) NONNULL(1);\n#endif /* HAVE_LOCAL_PROCINFO */\nvoid opts_set_masterkeylog(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_pcaplog(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_pcaplogdir(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\nvoid opts_set_pcaplogpathspec(opts_t *, const char *, const char *)\n     NONNULL(1,2,3);\n#ifndef WITHOUT_MIRROR\nvoid opts_set_mirrorif(opts_t *, const char *, const char *) NONNULL(1,2,3);\nvoid opts_set_mirrortarget(opts_t *, const char *, const char *) NONNULL(1,2,3);\n#endif /* !WITHOUT_MIRROR */\nvoid opts_set_daemon(opts_t *) NONNULL(1);\nvoid opts_set_debug(opts_t *) NONNULL(1);\nint opts_set_option(opts_t *, const char *, const char *, char **)\n    NONNULL(1,2,3);\n\nint load_conffile(opts_t *, const char *, char **) NONNULL(1,2);\n#endif /* !OPTS_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "opts.t.c",
          "type": "blob",
          "size": 17.9775390625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"attrib.h\"\n#include \"opts.h\"\n\n#include <check.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <netinet/in.h>\n\nstatic char *argv01[] = {\n\t\"https\", \"127.0.0.1\", \"10443\", \"127.0.0.2\", \"443\"\n};\n#ifndef TRAVIS\nstatic char *argv02[] = {\n\t\"https\", \"::1\", \"10443\", \"::2\", \"443\"\n};\n#endif /* !TRAVIS */\nstatic char *argv03[] = {\n\t\"http\", \"127.0.0.1\", \"10443\", \"127.0.0.2\", \"443\"\n};\nstatic char *argv04[] = {\n\t\"ssl\", \"127.0.0.1\", \"10443\", \"127.0.0.2\", \"443\"\n};\nstatic char *argv05[] = {\n\t\"tcp\", \"127.0.0.1\", \"10443\", \"127.0.0.2\", \"443\"\n};\nstatic char *argv06[] = {\n\t\"https\", \"127.0.0.1\", \"10443\", \"sni\", \"443\"\n};\n#ifndef DOCKER\nstatic char *argv07[] = {\n\t\"http\", \"127.0.0.1\", \"10443\", \"sni\", \"443\"\n};\n#endif /* !DOCKER */\nstatic char *argv08[] = {\n\t\"https\", \"127.0.0.1\", \"10443\", \"no_such_engine\"\n};\n#ifndef TRAVIS\nstatic char *argv09[] = {\n\t\"https\", \"127.0.0.1\", \"10443\", \"127.0.0.2\", \"443\",\n\t\"https\", \"::1\", \"10443\", \"::2\", \"443\"\n};\nstatic char *argv10[] = {\n\t\"https\", \"127.0.0.1\", \"10443\",\n\t\"https\", \"::1\", \"10443\"\n};\n#endif /* !TRAVIS */\nstatic char *argv11[] = {\n\t\"autossl\", \"127.0.0.1\", \"10025\"\n};\nstatic char *argv12[] = {\n\t\"autossl\", \"127.0.0.1\", \"10025\", \"127.0.0.2\", \"25\",\n\t\"https\", \"127.0.0.1\", \"10443\", \"127.0.0.2\", \"443\"\n};\n#ifndef DOCKER\nstatic char *argv13[] = {\n\t\"autossl\", \"127.0.0.1\", \"10025\", \"sni\", \"25\"\n};\n#endif /* !DOCKER */\nstatic char *argv14[] = {\n\t\"https\", \"127.0.0.1\", \"10443\",\n\t\"autossl\", \"127.0.0.1\", \"10025\", \"127.0.0.2\", \"25\"\n};\n\n#ifdef __linux__\n#define NATENGINE \"netfilter\"\n#else\n#define NATENGINE \"pf\"\n#endif\n\nSTART_TEST(proxyspec_parse_01)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv01;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\n#ifndef TRAVIS\nSTART_TEST(proxyspec_parse_02)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv02;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in6),\n\t            \"not IPv6 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in6),\n\t            \"not IPv6 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !TRAVIS */\n\n#ifndef DOCKER\nSTART_TEST(proxyspec_parse_03)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 2;\n\tchar **argv = argv01;\n\n\tclose(2);\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tif (spec)\n\t\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !DOCKER */\n\n#ifndef DOCKER\nSTART_TEST(proxyspec_parse_04)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 4;\n\tchar **argv = argv01;\n\n\tclose(2);\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tif (spec)\n\t\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !DOCKER */\n\nSTART_TEST(proxyspec_parse_05)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv03;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(proxyspec_parse_06)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv04;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(!spec->http, \"HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(proxyspec_parse_07)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv05;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(!spec->http, \"HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(proxyspec_parse_08)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv06;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->connect_addrlen, \"connect addr set\");\n\tfail_unless(spec->sni_port == 443, \"SNI port is not set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\n#ifndef DOCKER\nSTART_TEST(proxyspec_parse_09)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv07;\n\n\tclose(2);\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tif (spec)\n\t\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(proxyspec_parse_10)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 4;\n\tchar **argv = argv06;\n\n\tclose(2);\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tif (spec)\n\t\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !DOCKER */\n\nSTART_TEST(proxyspec_parse_11)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 3;\n\tchar **argv = argv08;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->natengine, \"natengine not set\");\n\tfail_unless(!strcmp(spec->natengine, NATENGINE), \"natengine mismatch\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\n#ifndef DOCKER\nSTART_TEST(proxyspec_parse_12)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 4;\n\tchar **argv = argv08;\n\n\tclose(2);\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tif (spec)\n\t\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !DOCKER */\n\n#ifndef TRAVIS\nSTART_TEST(proxyspec_parse_13)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 10;\n\tchar **argv = argv09;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in6),\n\t            \"not IPv6 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in6),\n\t            \"not IPv6 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!!spec->next, \"next is not set\");\n\tfail_unless(spec->next->ssl, \"not SSL\");\n\tfail_unless(spec->next->http, \"not HTTP\");\n\tfail_unless(!spec->next->upgrade, \"Upgrade\");\n\tfail_unless(spec->next->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->next->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->next->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->next->natengine, \"natengine is set\");\n\tfail_unless(!spec->next->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->next->natsocket, \"natsocket() is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(proxyspec_parse_14)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 6;\n\tchar **argv = argv10;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in6),\n\t            \"not IPv6 listen addr\");\n\tfail_unless(!spec->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->natengine, \"natengine not set\");\n\tfail_unless(!strcmp(spec->natengine, NATENGINE), \"natengine mismatch\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!!spec->next, \"next is not set\");\n\tfail_unless(spec->next->ssl, \"not SSL\");\n\tfail_unless(spec->next->http, \"not HTTP\");\n\tfail_unless(!spec->next->upgrade, \"Upgrade\");\n\tfail_unless(spec->next->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->next->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->next->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->next->natengine, \"natengine not set\");\n\tfail_unless(!strcmp(spec->next->natengine, NATENGINE),\n\t            \"natengine mismatch\");\n\tfail_unless(!spec->next->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->next->natsocket, \"natsocket() is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !TRAVIS */\n\nSTART_TEST(proxyspec_parse_15)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 3;\n\tchar **argv = argv11;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(!spec->http, \"HTTP\");\n\tfail_unless(spec->upgrade, \"not Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->natengine, \"natengine is not set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!spec->next, \"next is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(proxyspec_parse_16)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 10;\n\tchar **argv = argv12;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(spec->ssl, \"not SSL\");\n\tfail_unless(spec->http, \"not HTTP\");\n\tfail_unless(!spec->upgrade, \"Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!!spec->next, \"next is not set\");\n\tfail_unless(!spec->next->ssl, \"SSL\");\n\tfail_unless(!spec->next->http, \"HTTP\");\n\tfail_unless(spec->next->upgrade, \"not Upgrade\");\n\tfail_unless(spec->next->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->next->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->next->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->next->natengine, \"natengine is set\");\n\tfail_unless(!spec->next->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->next->natsocket, \"natsocket() is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\n#ifndef DOCKER\nSTART_TEST(proxyspec_parse_17)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 5;\n\tchar **argv = argv13;\n\n\tclose(2);\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tif (spec)\n\t\tproxyspec_free(spec);\n}\nEND_TEST\n#endif /* !DOCKER */\n\nSTART_TEST(proxyspec_parse_18)\n{\n\tproxyspec_t *spec = NULL;\n\tint argc = 8;\n\tchar **argv = argv14;\n\n\tproxyspec_parse(&argc, &argv, NATENGINE, &spec);\n\tfail_unless(!!spec, \"failed to parse spec\");\n\tfail_unless(!spec->ssl, \"SSL\");\n\tfail_unless(!spec->http, \"HTTP\");\n\tfail_unless(spec->upgrade, \"not Upgrade\");\n\tfail_unless(spec->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(spec->connect_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 connect addr\");\n\tfail_unless(!spec->sni_port, \"SNI port is set\");\n\tfail_unless(!spec->natengine, \"natengine is set\");\n\tfail_unless(!spec->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->natsocket, \"natsocket() is set\");\n\tfail_unless(!!spec->next, \"next is not set\");\n\tfail_unless(spec->next->ssl, \"not SSL\");\n\tfail_unless(spec->next->http, \"not HTTP\");\n\tfail_unless(!spec->next->upgrade, \"Upgrade\");\n\tfail_unless(spec->next->listen_addrlen == sizeof(struct sockaddr_in),\n\t            \"not IPv4 listen addr\");\n\tfail_unless(!spec->next->connect_addrlen, \"connect addr set\");\n\tfail_unless(!spec->next->sni_port, \"SNI port is set\");\n\tfail_unless(!!spec->next->natengine, \"natengine is not set\");\n\tfail_unless(!spec->next->natlookup, \"natlookup() is set\");\n\tfail_unless(!spec->next->natsocket, \"natsocket() is set\");\n\tproxyspec_free(spec);\n}\nEND_TEST\n\nSTART_TEST(opts_debug_01)\n{\n\topts_t *opts;\n\n\topts = opts_new();\n\topts->debug = 0;\n\tfail_unless(!opts->debug, \"plain 0\");\n\tfail_unless(!OPTS_DEBUG(opts), \"macro 0\");\n\topts->debug = 1;\n\tfail_unless(!!opts->debug, \"plain 1\");\n\tfail_unless(!!OPTS_DEBUG(opts), \"macro 1\");\n\topts_free(opts);\n}\nEND_TEST\n\nSuite *\nopts_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\ts = suite_create(\"opts\");\n\n\ttc = tcase_create(\"proxyspec_parse\");\n\ttcase_add_test(tc, proxyspec_parse_01);\n#ifndef TRAVIS\n\ttcase_add_test(tc, proxyspec_parse_02); /* IPv6 */\n#endif /* !TRAVIS */\n#ifndef DOCKER\n\ttcase_add_exit_test(tc, proxyspec_parse_03, EXIT_FAILURE);\n\ttcase_add_exit_test(tc, proxyspec_parse_04, EXIT_FAILURE);\n#endif /* !DOCKER */\n\ttcase_add_test(tc, proxyspec_parse_05);\n\ttcase_add_test(tc, proxyspec_parse_06);\n\ttcase_add_test(tc, proxyspec_parse_07);\n\ttcase_add_test(tc, proxyspec_parse_08);\n#ifndef DOCKER\n\ttcase_add_exit_test(tc, proxyspec_parse_09, EXIT_FAILURE);\n\ttcase_add_exit_test(tc, proxyspec_parse_10, EXIT_FAILURE);\n#endif /* !DOCKER */\n\ttcase_add_test(tc, proxyspec_parse_11);\n#ifndef DOCKER\n\ttcase_add_exit_test(tc, proxyspec_parse_12, EXIT_FAILURE);\n#endif /* !DOCKER */\n#ifndef TRAVIS\n\ttcase_add_test(tc, proxyspec_parse_13); /* IPv6 */\n\ttcase_add_test(tc, proxyspec_parse_14); /* IPv6 */\n#endif /* !TRAVIS */\n\ttcase_add_test(tc, proxyspec_parse_15);\n\ttcase_add_test(tc, proxyspec_parse_16);\n#ifndef DOCKER\n\ttcase_add_exit_test(tc, proxyspec_parse_17, EXIT_FAILURE);\n#endif /* !DOCKER */\n\ttcase_add_test(tc, proxyspec_parse_18);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"opts_debug\");\n\ttcase_add_test(tc, opts_debug_01);\n\tsuite_add_tcase(s, tc);\n\n#ifdef DOCKER\n\tfprintf(stderr, \"opts: 6 tests omitted because building in docker\\n\");\n#endif\n#ifdef TRAVIS\n\tfprintf(stderr, \"opts: 3 tests omitted because building in travis\\n\");\n#endif\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "privsep.c",
          "type": "blob",
          "size": 27.3232421875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"privsep.h\"\n\n#include \"sys.h\"\n#include \"util.h\"\n#include \"log.h\"\n#include \"attrib.h\"\n#include \"defaults.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/select.h>\n#include <sys/wait.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <libgen.h>\n#include <fcntl.h>\n\n\n/*\n * Privilege separation functionality.\n *\n * The server code has limitations on the internal functionality that can be\n * used, namely only those that are initialized before forking.\n */\n\n/* maximal message sizes */\n#define PRIVSEP_MAX_REQ_SIZE\t512\t/* arbitrary limit */\n#define PRIVSEP_MAX_ANS_SIZE\t(1+sizeof(int))\n/* command byte */\n#define PRIVSEP_REQ_CLOSE\t0\t/* closing command socket */\n#define PRIVSEP_REQ_OPENFILE\t1\t/* open content log file */\n#define PRIVSEP_REQ_OPENFILE_P\t2\t/* open content log file w/mkpath */\n#define PRIVSEP_REQ_OPENSOCK\t3\t/* open socket and pass fd */\n#define PRIVSEP_REQ_CERTFILE\t4\t/* open cert file in certgendir */\n\n/* response byte */\n#define PRIVSEP_ANS_SUCCESS\t0\t/* success */\n#define PRIVSEP_ANS_UNK_CMD\t1\t/* unknown command */\n#define PRIVSEP_ANS_INVALID\t2\t/* invalid message */\n#define PRIVSEP_ANS_DENIED\t3\t/* request denied */\n#define PRIVSEP_ANS_SYS_ERR\t4\t/* system error; arg=errno */\n\n/* Whether we short-circuit calls to privsep_client_* directly to\n * privsep_server_* within the client process, bypassing the privilege\n * separation mechanism; this is a performance optimization for use cases\n * where the user chooses performance over security, especially with options\n * that require privsep operations for each connection passing through.\n * In the current implementation, for consistency, we still fork normally, but\n * will not actually send any privsep requests to the parent process. */\nstatic int privsep_fastpath;\n\n/* communication with signal handler */\nstatic volatile sig_atomic_t received_sighup;\nstatic volatile sig_atomic_t received_sigint;\nstatic volatile sig_atomic_t received_sigquit;\nstatic volatile sig_atomic_t received_sigterm;\nstatic volatile sig_atomic_t received_sigchld;\nstatic volatile sig_atomic_t received_sigusr1;\n/* write end of pipe used for unblocking select */\nstatic volatile sig_atomic_t selfpipe_wrfd;\n\nstatic void\nprivsep_server_signal_handler(int sig)\n{\n\tint saved_errno;\n\n\tsaved_errno = errno;\n\n#ifdef DEBUG_PRIVSEP_SERVER\n\tlog_dbg_printf(\"privsep_server_signal_handler\\n\");\n#endif /* DEBUG_PRIVSEP_SERVER */\n\n\tswitch (sig) {\n\tcase SIGHUP:\n\t\treceived_sighup = 1;\n\t\tbreak;\n\tcase SIGINT:\n\t\treceived_sigint = 1;\n\t\tbreak;\n\tcase SIGQUIT:\n\t\treceived_sigquit = 1;\n\t\tbreak;\n\tcase SIGTERM:\n\t\treceived_sigterm = 1;\n\t\tbreak;\n\tcase SIGCHLD:\n\t\treceived_sigchld = 1;\n\t\tbreak;\n\tcase SIGUSR1:\n\t\treceived_sigusr1 = 1;\n\t\tbreak;\n\t}\n\tif (selfpipe_wrfd != -1) {\n\t\tssize_t n;\n\n#ifdef DEBUG_PRIVSEP_SERVER\n\t\tlog_dbg_printf(\"writing to selfpipe_wrfd %i\\n\", selfpipe_wrfd);\n#endif /* DEBUG_PRIVSEP_SERVER */\n\t\tdo {\n\t\t\tn = write(selfpipe_wrfd, \"!\", 1);\n\t\t} while (n == -1 && errno == EINTR);\n\t\tif (n == -1) {\n\t\t\tlog_err_printf(\"Failed to write from signal handler: \"\n\t\t\t               \"%s (%i)\\n\", strerror(errno), errno);\n\t\t\t/* ignore error */\n\t\t}\n#ifdef DEBUG_PRIVSEP_SERVER\n\t} else {\n\t\tlog_dbg_printf(\"selfpipe_wrfd is %i - not writing\\n\", selfpipe_wrfd);\n#endif /* DEBUG_PRIVSEP_SERVER */\n\t}\n\terrno = saved_errno;\n}\n\nstatic int WUNRES\nprivsep_server_openfile_verify(opts_t *opts, const char *fn, UNUSED int mkpath)\n{\n\t/* Prefix must match one of the active log files that use privsep. */\n\tdo {\n\t\tif (opts->contentlog) {\n\t\t\tif (strstr(fn, opts->contentlog_isspec\n\t\t\t               ? opts->contentlog_basedir\n\t\t\t               : opts->contentlog) == fn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (opts->pcaplog) {\n\t\t\tif (strstr(fn, opts->pcaplog_isspec\n\t\t\t               ? opts->pcaplog_basedir\n\t\t\t               : opts->pcaplog) == fn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (opts->connectlog) {\n\t\t\tif (strstr(fn, opts->connectlog) == fn)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (opts->masterkeylog) {\n\t\t\tif (strstr(fn, opts->masterkeylog) == fn)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn -1;\n\t} while (0);\n\n\t/* Path must not contain dot-dot to prevent escaping the prefix. */\n\tif (strstr(fn, \"/../\"))\n\t\treturn -1;\n\n\treturn 0;\n}\n\nstatic int WUNRES\nprivsep_server_openfile(const char *fn, int mkpath)\n{\n\tint fd, tmp;\n\n\tif (mkpath) {\n\t\tchar *filedir, *fn2;\n\n\t\tfn2 = strdup(fn);\n\t\tif (!fn2) {\n\t\t\ttmp = errno;\n\t\t\tlog_err_printf(\"Could not duplicate filname: %s (%i)\\n\",\n\t\t\t               strerror(errno), errno);\n\t\t\terrno = tmp;\n\t\t\treturn -1;\n\t\t}\n\t\tfiledir = dirname(fn2);\n\t\tif (!filedir) {\n\t\t\ttmp = errno;\n\t\t\tlog_err_printf(\"Could not get dirname: %s (%i)\\n\",\n\t\t\t               strerror(errno), errno);\n\t\t\tfree(fn2);\n\t\t\terrno = tmp;\n\t\t\treturn -1;\n\t\t}\n\t\tif (sys_mkpath(filedir, DFLT_DIRMODE) == -1) {\n\t\t\ttmp = errno;\n\t\t\tlog_err_printf(\"Could not create directory '%s': %s (%i)\\n\",\n\t\t\t               filedir, strerror(errno), errno);\n\t\t\tfree(fn2);\n\t\t\terrno = tmp;\n\t\t\treturn -1;\n\t\t}\n\t\tfree(fn2);\n\t}\n\n\tfd = open(fn, O_RDWR|O_CREAT, DFLT_FILEMODE);\n\tif (fd == -1) {\n\t\ttmp = errno;\n\t\tlog_err_printf(\"Failed to open '%s': %s (%i)\\n\",\n\t\t               fn, strerror(errno), errno);\n\t\terrno = tmp;\n\t\treturn -1;\n\t}\n\tif (lseek(fd, 0, SEEK_END) == -1) {\n\t\ttmp = errno;\n\t\tlog_err_printf(\"Failed to seek on '%s': %s (%i)\\n\",\n\t\t               fn, strerror(errno), errno);\n\t\terrno = tmp;\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n}\n\nstatic int WUNRES\nprivsep_server_opensock_verify(opts_t *opts, void *arg)\n{\n\t/* This check is safe, because modifications of the spec in the child\n\t * process do not affect the copy of the spec here in the parent. */\n\tfor (proxyspec_t *spec = opts->spec; spec; spec = spec->next) {\n\t\tif (spec == arg)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}\n\nstatic int WUNRES\nprivsep_server_opensock(const proxyspec_t *spec)\n{\n\tevutil_socket_t fd;\n\tint on = 1;\n\tint rv;\n\n\tfd = socket(spec->listen_addr.ss_family, SOCK_STREAM, IPPROTO_TCP);\n\tif (fd == -1) {\n\t\tlog_err_printf(\"Error from socket(): %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\tevutil_closesocket(fd);\n\t\treturn -1;\n\t}\n\n\trv = evutil_make_socket_nonblocking(fd);\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error making socket nonblocking: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\tevutil_closesocket(fd);\n\t\treturn -1;\n\t}\n\n\trv = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void*)&on, sizeof(on));\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error from setsockopt(SO_KEEPALIVE): %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\tevutil_closesocket(fd);\n\t\treturn -1;\n\t}\n\n\trv = evutil_make_listen_socket_reuseable(fd);\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error from setsockopt(SO_REUSABLE): %s\\n\",\n\t\t               strerror(errno));\n\t\tevutil_closesocket(fd);\n\t\treturn -1;\n\t}\n\n\tif (spec->natsocket && (spec->natsocket(fd) == -1)) {\n\t\tlog_err_printf(\"Error from spec->natsocket()\\n\");\n\t\tevutil_closesocket(fd);\n\t\treturn -1;\n\t}\n\n\trv = bind(fd, (struct sockaddr *)&spec->listen_addr,\n\t          spec->listen_addrlen);\n\tif (rv == -1) {\n\t\tlog_err_printf(\"Error from bind(): %s\\n\", strerror(errno));\n\t\tevutil_closesocket(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nstatic int WUNRES\nprivsep_server_certfile_verify(opts_t *opts, const char *fn)\n{\n\tif (!opts->certgendir)\n\t\treturn -1;\n\tif (strstr(fn, opts->certgendir) != fn || strstr(fn, \"/../\"))\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic int WUNRES\nprivsep_server_certfile(const char *fn)\n{\n\tint fd;\n\n\tfd = open(fn, O_WRONLY|O_CREAT|O_EXCL, DFLT_FILEMODE);\n\tif (fd == -1 && errno != EEXIST) {\n\t\tlog_err_printf(\"Failed to open '%s': %s (%i)\\n\",\n\t\t               fn, strerror(errno), errno);\n\t\treturn -1;\n\t}\n\treturn fd;\n}\n\n/*\n * Handle a single request on a readable server socket.\n * Returns 0 on success, 1 on EOF and -1 on error.\n */\nstatic int WUNRES\nprivsep_server_handle_req(opts_t *opts, int srvsock)\n{\n\tchar req[PRIVSEP_MAX_REQ_SIZE];\n\tchar ans[PRIVSEP_MAX_ANS_SIZE];\n\tssize_t n;\n\tint mkpath = 0;\n\n\tif ((n = sys_recvmsgfd(srvsock, req, sizeof(req),\n\t                       NULL)) == -1) {\n\t\tif (errno == EPIPE || errno == ECONNRESET) {\n\t\t\t/* unfriendly EOF, leave server */\n\t\t\treturn 1;\n\t\t}\n\t\tlog_err_printf(\"Failed to receive msg: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (n == 0) {\n\t\t/* EOF, leave server; will not happen for SOCK_DGRAM sockets */\n\t\treturn 1;\n\t}\n\tlog_dbg_printf(\"Received privsep req type %02x sz %zd on srvsock %i\\n\",\n\t               req[0], n, srvsock);\n\tswitch (req[0]) {\n\tcase PRIVSEP_REQ_CLOSE: {\n\t\t/* client indicates EOF through close message */\n\t\treturn 1;\n\t}\n\tcase PRIVSEP_REQ_OPENFILE_P:\n\t\tmkpath = 1;\n\t\t/* fall through */\n\tcase PRIVSEP_REQ_OPENFILE: {\n\t\tchar *fn;\n\t\tint fd;\n\n\t\tif (n < 2) {\n\t\t\tans[0] = PRIVSEP_ANS_INVALID;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (!(fn = malloc(n))) {\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(fn, req + 1, n - 1);\n\t\tfn[n - 1] = '\\0';\n\t\tif (privsep_server_openfile_verify(opts, fn, mkpath) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_DENIED;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif ((fd = privsep_server_openfile(fn, mkpath)) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SUCCESS;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, fd) == -1) {\n\t\t\t\tclose(fd);\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\tcase PRIVSEP_REQ_OPENSOCK: {\n\t\tproxyspec_t *arg;\n\t\tint s;\n\n\t\tif (n != sizeof(char) + sizeof(arg)) {\n\t\t\tans[0] = PRIVSEP_ANS_INVALID;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\targ = *(proxyspec_t**)(&req[1]);\n\t\tif (privsep_server_opensock_verify(opts, arg) == -1) {\n\t\t\tans[0] = PRIVSEP_ANS_DENIED;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif ((s = privsep_server_opensock(arg)) == -1) {\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tans[0] = PRIVSEP_ANS_SUCCESS;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, s) == -1) {\n\t\t\t\tevutil_closesocket(s);\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tevutil_closesocket(s);\n\t\t\treturn 0;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\tcase PRIVSEP_REQ_CERTFILE: {\n\t\tchar *fn;\n\t\tint fd;\n\n\t\tif (n < 2) {\n\t\t\tans[0] = PRIVSEP_ANS_INVALID;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (!(fn = malloc(n))) {\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tmemcpy(fn, req + 1, n - 1);\n\t\tfn[n - 1] = '\\0';\n\t\tif (privsep_server_certfile_verify(opts, fn) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_DENIED;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif ((fd = privsep_server_certfile(fn)) == -1) {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SYS_ERR;\n\t\t\t*((int*)&ans[1]) = errno;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1 + sizeof(int),\n\t\t\t                  -1) == -1) {\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfree(fn);\n\t\t\tans[0] = PRIVSEP_ANS_SUCCESS;\n\t\t\tif (sys_sendmsgfd(srvsock, ans, 1, fd) == -1) {\n\t\t\t\tclose(fd);\n\t\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tclose(fd);\n\t\t\treturn 0;\n\t\t}\n\t\t/* not reached */\n\t\tbreak;\n\t}\n\tdefault:\n\t\tans[0] = PRIVSEP_ANS_UNK_CMD;\n\t\tif (sys_sendmsgfd(srvsock, ans, 1, -1) == -1) {\n\t\t\tlog_err_printf(\"Sending message failed: %s (%i\"\n\t\t\t               \")\\n\", strerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Privilege separation server (main privileged monitor loop)\n *\n * sigpipe is the self-pipe trick pipe used for communicating signals to\n * the main event loop and break out of select() without race conditions.\n * srvsock[] is a dynamic array of connected privsep server sockets to serve.\n * Caller is responsible for freeing memory after returning, if necessary.\n * childpid is the pid of the child process to forward signals to.\n *\n * Returns 0 on a successful clean exit and -1 on errors.\n */\nstatic int\nprivsep_server(opts_t *opts, int sigpipe, int srvsock[], size_t nsrvsock,\n               pid_t childpid)\n{\n\tint srveof[nsrvsock];\n\tsize_t i = 0;\n\n\tfor (i = 0; i < nsrvsock; i++) {\n\t\tsrveof[i] = 0;\n\t}\n\n\tfor (;;) {\n\t\tfd_set readfds;\n\t\tint maxfd, rv;\n\n#ifdef DEBUG_PRIVSEP_SERVER\n\t\tlog_dbg_printf(\"privsep_server select()\\n\");\n#endif /* DEBUG_PRIVSEP_SERVER */\n\t\tdo {\n\t\t\tFD_ZERO(&readfds);\n\t\t\tFD_SET(sigpipe, &readfds);\n\t\t\tmaxfd = sigpipe;\n\t\t\tfor (i = 0; i < nsrvsock; i++) {\n\t\t\t\tif (!srveof[i]) {\n\t\t\t\t\tFD_SET(srvsock[i], &readfds);\n\t\t\t\t\tmaxfd = util_max(maxfd, srvsock[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trv = select(maxfd + 1, &readfds, NULL, NULL, NULL);\n#ifdef DEBUG_PRIVSEP_SERVER\n\t\t\tlog_dbg_printf(\"privsep_server woke up (1)\\n\");\n#endif /* DEBUG_PRIVSEP_SERVER */\n\t\t} while (rv == -1 && errno == EINTR);\n\t\tif (rv == -1) {\n\t\t\tlog_err_printf(\"select() failed: %s (%i)\\n\",\n\t\t\t               strerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n#ifdef DEBUG_PRIVSEP_SERVER\n\t\tlog_dbg_printf(\"privsep_server woke up (2)\\n\");\n#endif /* DEBUG_PRIVSEP_SERVER */\n\n\t\tif (FD_ISSET(sigpipe, &readfds)) {\n\t\t\tchar buf[16];\n\t\t\tssize_t n;\n\t\t\t/* first drain the signal pipe, then deal with\n\t\t\t * all the individual signal flags */\n\t\t\tn = read(sigpipe, buf, sizeof(buf));\n\t\t\tif (n == -1) {\n\t\t\t\tlog_err_printf(\"read(sigpipe) failed:\"\n\t\t\t\t               \" %s (%i)\\n\",\n\t\t\t\t               strerror(errno), errno);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (received_sigquit) {\n\t\t\t\tif (kill(childpid, SIGQUIT) == -1) {\n\t\t\t\t\tlog_err_printf(\"kill(%i,SIGQUIT) \"\n\t\t\t\t\t               \"failed: %s (%i)\\n\",\n\t\t\t\t\t               childpid,\n\t\t\t\t\t               strerror(errno), errno);\n\t\t\t\t}\n\t\t\t\treceived_sigquit = 0;\n\t\t\t}\n\t\t\tif (received_sigterm) {\n\t\t\t\tif (kill(childpid, SIGTERM) == -1) {\n\t\t\t\t\tlog_err_printf(\"kill(%i,SIGTERM) \"\n\t\t\t\t\t               \"failed: %s (%i)\\n\",\n\t\t\t\t\t               childpid,\n\t\t\t\t\t               strerror(errno), errno);\n\t\t\t\t}\n\t\t\t\treceived_sigterm = 0;\n\t\t\t}\n\t\t\tif (received_sighup) {\n\t\t\t\tif (kill(childpid, SIGHUP) == -1) {\n\t\t\t\t\tlog_err_printf(\"kill(%i,SIGHUP) \"\n\t\t\t\t\t               \"failed: %s (%i)\\n\",\n\t\t\t\t\t               childpid,\n\t\t\t\t\t               strerror(errno), errno);\n\t\t\t\t}\n\t\t\t\treceived_sighup = 0;\n\t\t\t}\n\t\t\tif (received_sigusr1) {\n\t\t\t\tif (kill(childpid, SIGUSR1) == -1) {\n\t\t\t\t\tlog_err_printf(\"kill(%i,SIGUSR1) \"\n\t\t\t\t\t               \"failed: %s (%i)\\n\",\n\t\t\t\t\t               childpid,\n\t\t\t\t\t               strerror(errno), errno);\n\t\t\t\t}\n\t\t\t\treceived_sigusr1 = 0;\n\t\t\t}\n\t\t\tif (received_sigint) {\n\t\t\t\t/* if we don't detach from the TTY, the\n\t\t\t\t * child process receives SIGINT directly */\n\t\t\t\tif (opts->detach) {\n\t\t\t\t\tif (kill(childpid, SIGINT) == -1) {\n\t\t\t\t\t\tlog_err_printf(\"kill(%i,SIGINT\"\n\t\t\t\t\t\t               \") failed: \"\n\t\t\t\t\t\t               \"%s (%i)\\n\",\n\t\t\t\t\t\t               childpid,\n\t\t\t\t\t\t               strerror(errno),\n\t\t\t\t\t\t               errno);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treceived_sigint = 0;\n\t\t\t}\n\t\t\tif (received_sigchld) {\n\t\t\t\t/* break the loop; because we are using\n\t\t\t\t * SOCKET_DGRAM we don't get EOF conditions\n\t\t\t\t * on the disconnected socket ends here\n\t\t\t\t * unless we attempt to write or read, so\n\t\t\t\t * we depend on SIGCHLD to notify us of\n\t\t\t\t * our child erroring out or crashing */\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < nsrvsock; i++) {\n\t\t\tif (FD_ISSET(srvsock[i], &readfds)) {\n\t\t\t\tint rv = privsep_server_handle_req(opts,\n\t\t\t\t                                   srvsock[i]);\n\t\t\t\tif (rv == -1) {\n\t\t\t\t\tlog_err_printf(\"Failed to handle \"\n\t\t\t\t\t               \"privsep req \"\n\t\t\t\t\t               \"on srvsock %i\\n\",\n\t\t\t\t\t               srvsock[i]);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (rv == 1) {\n#ifdef DEBUG_PRIVSEP_SERVER\n\t\t\t\t\tlog_dbg_printf(\"srveof[%zu]=1\\n\", i);\n#endif /* DEBUG_PRIVSEP_SERVER */\n\t\t\t\t\tsrveof[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * We cannot exit as long as we need the signal handling,\n\t\t * which is as long as the child process is running.\n\t\t * The only way out of here is receiving SIGCHLD.\n\t\t */\n\t}\n\n\treturn 0;\n}\n\nint\nprivsep_client_openfile(int clisock, const char *fn, int mkpath)\n{\n\tchar ans[PRIVSEP_MAX_ANS_SIZE];\n\tchar req[1 + strlen(fn)];\n\tint fd = -1;\n\tssize_t n;\n\n\tif (privsep_fastpath)\n\t\treturn privsep_server_openfile(fn, mkpath);\n\n\treq[0] = mkpath ? PRIVSEP_REQ_OPENFILE_P : PRIVSEP_REQ_OPENFILE;\n\tmemcpy(req + 1, fn, sizeof(req) - 1);\n\n\tif (sys_sendmsgfd(clisock, req, sizeof(req), -1) == -1) {\n\t\treturn -1;\n\t}\n\n\tif ((n = sys_recvmsgfd(clisock, ans, sizeof(ans), &fd)) == -1) {\n\t\treturn -1;\n\t}\n\n\tif (n < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tswitch (ans[0]) {\n\tcase PRIVSEP_ANS_SUCCESS:\n\t\tbreak;\n\tcase PRIVSEP_ANS_DENIED:\n\t\terrno = EACCES;\n\t\treturn -1;\n\tcase PRIVSEP_ANS_SYS_ERR:\n\t\tif (n < (ssize_t)(1 + sizeof(int))) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\terrno = *((int*)&ans[1]);\n\t\treturn -1;\n\tcase PRIVSEP_ANS_UNK_CMD:\n\tcase PRIVSEP_ANS_INVALID:\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nint\nprivsep_client_opensock(int clisock, const proxyspec_t *spec)\n{\n\tchar ans[PRIVSEP_MAX_ANS_SIZE];\n\tchar req[1 + sizeof(spec)];\n\tint fd = -1;\n\tssize_t n;\n\n\tif (privsep_fastpath)\n\t\treturn privsep_server_opensock(spec);\n\n\treq[0] = PRIVSEP_REQ_OPENSOCK;\n\t*((const proxyspec_t **)&req[1]) = spec;\n\n\tif (sys_sendmsgfd(clisock, req, sizeof(req), -1) == -1) {\n\t\treturn -1;\n\t}\n\n\tif ((n = sys_recvmsgfd(clisock, ans, sizeof(ans), &fd)) == -1) {\n\t\treturn -1;\n\t}\n\n\tif (n < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tswitch (ans[0]) {\n\tcase PRIVSEP_ANS_SUCCESS:\n\t\tbreak;\n\tcase PRIVSEP_ANS_DENIED:\n\t\terrno = EACCES;\n\t\treturn -1;\n\tcase PRIVSEP_ANS_SYS_ERR:\n\t\tif (n < (ssize_t)(1 + sizeof(int))) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\terrno = *((int*)&ans[1]);\n\t\treturn -1;\n\tcase PRIVSEP_ANS_UNK_CMD:\n\tcase PRIVSEP_ANS_INVALID:\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nint\nprivsep_client_certfile(int clisock, const char *fn)\n{\n\tchar ans[PRIVSEP_MAX_ANS_SIZE];\n\tchar req[1 + strlen(fn)];\n\tint fd = -1;\n\tssize_t n;\n\n\tif (privsep_fastpath)\n\t\treturn privsep_server_certfile(fn);\n\n\treq[0] = PRIVSEP_REQ_CERTFILE;\n\tmemcpy(req + 1, fn, sizeof(req) - 1);\n\n\tif (sys_sendmsgfd(clisock, req, sizeof(req), -1) == -1) {\n\t\treturn -1;\n\t}\n\n\tif ((n = sys_recvmsgfd(clisock, ans, sizeof(ans), &fd)) == -1) {\n\t\treturn -1;\n\t}\n\n\tif (n < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tswitch (ans[0]) {\n\tcase PRIVSEP_ANS_SUCCESS:\n\t\tbreak;\n\tcase PRIVSEP_ANS_DENIED:\n\t\terrno = EACCES;\n\t\treturn -1;\n\tcase PRIVSEP_ANS_SYS_ERR:\n\t\tif (n < (ssize_t)(1 + sizeof(int))) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\terrno = *((int*)&ans[1]);\n\t\treturn -1;\n\tcase PRIVSEP_ANS_UNK_CMD:\n\tcase PRIVSEP_ANS_INVALID:\n\tdefault:\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\nint\nprivsep_client_close(int clisock)\n{\n\tchar req[1];\n\n\treq[0] = PRIVSEP_REQ_CLOSE;\n\n\tif (sys_sendmsgfd(clisock, req, sizeof(req), -1) == -1) {\n\t\tclose(clisock);\n\t\treturn -1;\n\t}\n\n\tclose(clisock);\n\treturn 0;\n}\n\n/*\n * Fork and set up privilege separated monitor process.\n * Returns -1 on error before forking, 1 as parent, or 0 as child.\n * The array of clisock's will get filled with nclisock privsep client\n * sockets only for the child; on error and in the parent process it\n * will not be touched.\n */\nint\nprivsep_fork(opts_t *opts, int clisock[], size_t nclisock, int *parent_rv)\n{\n\tint selfpipev[2]; /* self-pipe trick: signal handler -> select */\n\tint chldpipev[2]; /* el cheapo interprocess sync early after fork */\n\tint sockcliv[nclisock][2];\n\tpid_t pid;\n\n\tif (!opts->dropuser) {\n\t\tlog_dbg_printf(\"Privsep fastpath enabled\\n\");\n\t\tprivsep_fastpath = 1;\n\t} else {\n\t\tlog_dbg_printf(\"Privsep fastpath disabled\\n\");\n\t\tprivsep_fastpath = 0;\n\t}\n\n\treceived_sigquit = 0;\n\treceived_sighup = 0;\n\treceived_sigint = 0;\n\treceived_sigchld = 0;\n\treceived_sigusr1 = 0;\n\n\tif (pipe(selfpipev) == -1) {\n\t\tlog_err_printf(\"Failed to create self-pipe: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tlog_dbg_printf(\"Created self-pipe [r=%i,w=%i]\\n\",\n\t               selfpipev[0], selfpipev[1]);\n\n\tif (pipe(chldpipev) == -1) {\n\t\tlog_err_printf(\"Failed to create chld-pipe: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tlog_dbg_printf(\"Created chld-pipe [r=%i,w=%i]\\n\",\n\t               chldpipev[0], chldpipev[1]);\n\n\tfor (size_t i = 0; i < nclisock; i++) {\n\t\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sockcliv[i]) == -1) {\n\t\t\tlog_err_printf(\"Failed to create socket pair %zu: \"\n\t\t\t               \"%s (%i)\\n\", i, strerror(errno), errno);\n\t\t\treturn -1;\n\t\t}\n\t\tlog_dbg_printf(\"Created socketpair %zu [p=%i,c=%i]\\n\",\n\t\t               i, sockcliv[i][0], sockcliv[i][1]);\n\t}\n\n\tlog_dbg_printf(\"Privsep parent pid %i\\n\", getpid());\n\tpid = fork();\n\tif (pid == -1) {\n\t\tlog_err_printf(\"Failed to fork: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\tclose(selfpipev[0]);\n\t\tclose(selfpipev[1]);\n\t\tclose(chldpipev[0]);\n\t\tclose(chldpipev[1]);\n\t\tfor (size_t i = 0; i < nclisock; i++) {\n\t\t\tclose(sockcliv[i][0]);\n\t\t\tclose(sockcliv[i][1]);\n\t\t}\n\t\treturn -1;\n\t} else if (pid == 0) {\n\t\t/* child */\n\t\tclose(selfpipev[0]);\n\t\tclose(selfpipev[1]);\n\t\tfor (size_t i = 0; i < nclisock; i++)\n\t\t\tclose(sockcliv[i][0]);\n\t\t/* wait until parent has installed signal handlers,\n\t\t * intentionally ignoring errors */\n\t\tchar buf[1];\n\t\tssize_t n;\n\t\tclose(chldpipev[1]);\n\t\tdo {\n\t\t\tn = read(chldpipev[0], buf, sizeof(buf));\n\t\t} while (n == -1 && errno == EINTR);\n\t\tclose(chldpipev[0]);\n\t\tlog_dbg_printf(\"Privsep child pid %i\\n\", getpid());\n\t\t/* return the privsep client sockets */\n\t\tfor (size_t i = 0; i < nclisock; i++)\n\t\t\tclisock[i] = sockcliv[i][1];\n\t\treturn 0;\n\t}\n\t/* parent */\n\tfor (size_t i = 0; i < nclisock; i++)\n\t\tclose(sockcliv[i][1]);\n\tselfpipe_wrfd = selfpipev[1];\n\n\t/* close file descriptors opened by preinit's only needed in client;\n\t * we still call the preinit's before forking in order to provide\n\t * better user feedback and less privsep complexity */\n\tnat_preinit_undo();\n\tlog_preinit_undo();\n\n\t/* If the child exits before the parent installs the signal handler\n\t * here, we have a race condition; this is solved by the client\n\t * blocking on the reading end of a pipe (chldpipev[0]). */\n\tif (signal(SIGHUP, privsep_server_signal_handler) == SIG_ERR) {\n\t\tlog_err_printf(\"Failed to install SIGHUP handler: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (signal(SIGINT, privsep_server_signal_handler) == SIG_ERR) {\n\t\tlog_err_printf(\"Failed to install SIGINT handler: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (signal(SIGTERM, privsep_server_signal_handler) == SIG_ERR) {\n\t\tlog_err_printf(\"Failed to install SIGTERM handler: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (signal(SIGQUIT, privsep_server_signal_handler) == SIG_ERR) {\n\t\tlog_err_printf(\"Failed to install SIGQUIT handler: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (signal(SIGUSR1, privsep_server_signal_handler) == SIG_ERR) {\n\t\tlog_err_printf(\"Failed to install SIGUSR1 handler: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\tif (signal(SIGCHLD, privsep_server_signal_handler) == SIG_ERR) {\n\t\tlog_err_printf(\"Failed to install SIGCHLD handler: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn -1;\n\t}\n\n\t/* unblock the child */\n\tclose(chldpipev[0]);\n\tclose(chldpipev[1]);\n\n\tint socksrv[nclisock];\n\tfor (size_t i = 0; i < nclisock; i++)\n\t\tsocksrv[i] = sockcliv[i][0];\n\tif (privsep_server(opts, selfpipev[0], socksrv, nclisock, pid) == -1) {\n\t\tlog_err_printf(\"Privsep server failed: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\t/* fall through */\n\t}\n#ifdef DEBUG_PRIVSEP_SERVER\n\tlog_dbg_printf(\"privsep_server exited\\n\");\n#endif /* DEBUG_PRIVSEP_SERVER */\n\n\tfor (size_t i = 0; i < nclisock; i++)\n\t\tclose(sockcliv[i][0]);\n\tselfpipe_wrfd = -1; /* tell signal handler not to write anymore */\n\tclose(selfpipev[0]);\n\tclose(selfpipev[1]);\n\n\tint status;\n\tpid_t wpid;\n\twpid = wait(&status);\n\tif (wpid != pid) {\n\t\t/* should never happen, warn if it does anyway */\n\t\tlog_err_printf(\"Child pid %lld != expected %lld from wait(2)\\n\",\n\t\t               (long long)wpid, (long long)pid);\n\t}\n\tif (WIFEXITED(status)) {\n\t\tif (WEXITSTATUS(status) != 0) {\n\t\t\tlog_err_printf(\"Child pid %lld exited with status %d\\n\",\n\t\t\t               (long long)wpid, WEXITSTATUS(status));\n\t\t} else {\n\t\t\tlog_dbg_printf(\"Child pid %lld exited with status %d\\n\",\n\t\t\t               (long long)wpid, WEXITSTATUS(status));\n\t\t}\n\t\t*parent_rv = WEXITSTATUS(status);\n\t} else if (WIFSIGNALED(status)) {\n\t\tlog_err_printf(\"Child pid %lld killed by signal %d\\n\",\n\t\t               (long long)wpid, WTERMSIG(status));\n\t\t*parent_rv = 128 + WTERMSIG(status);\n\t} else {\n\t\t/* can only happen with WUNTRACED option or active tracing */\n\t\tlog_err_printf(\"Child pid %lld neither exited nor killed\\n\",\n\t\t               (long long)wpid);\n\t}\n\n\treturn 1;\n}\n\n/* vim: set noet ft=c: */\n\n\n\n"
        },
        {
          "name": "privsep.h",
          "type": "blob",
          "size": 1.8115234375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef PRIVSEP_H\n#define PRIVSEP_H\n\n#include \"attrib.h\"\n#include \"opts.h\"\n\nint privsep_fork(opts_t *, int[], size_t, int *);\n\nint privsep_client_openfile(int, const char *, int);\nint privsep_client_opensock(int, const proxyspec_t *spec);\nint privsep_client_certfile(int, const char *);\nint privsep_client_close(int);\n\n#endif /* !PRIVSEP_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "proc.c",
          "type": "blob",
          "size": 10.822265625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifdef __FreeBSD__\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/socket.h>\n#include <sys/socketvar.h>\n#include <sys/sysctl.h>\n#include <sys/file.h>\n#include <sys/user.h>\n\n#include <netinet/in.h>\n#include <netinet/in_pcb.h>\n#include <netinet/tcp.h>\n#include <netinet/tcp_seq.h>\n#include <netinet/tcp_var.h>\n#include <arpa/inet.h>\n#endif /* __FreeBSD__ */\n\n#include \"proc.h\"\n\n#include \"log.h\"\n#include \"attrib.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n#ifdef HAVE_DARWIN_LIBPROC\n#include <libproc.h>\n#endif /* HAVE_DARWIN_LIBPROC */\n\n\n/*\n * Local process lookup.\n */\n\n\n#ifdef __FreeBSD__\n\n/*\n * Get the list of open files from the kernel and do basic consistency checks.\n * If successful, returns 0, and *pxfiles will receive a pointer to the\n * received xfiles structure and *pnxfiles the number of file records in it.\n * If unsuccessful, returns -1 and *pxfiles will be NULL.\n * Caller is responsible to free() *pxfiles after use.\n */\nstatic int\nproc_freebsd_getfiles(struct xfile **pxfiles, int *pnxfiles)\n{\n\tint mib[4];\n\tsize_t sz;\n\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_FILE;\n\tmib[2] = mib[3] = 0;\n\n\tfor (;;) {\n\t\tif (sysctl(mib, 2, NULL, &sz, NULL, 0) < 0) {\n\t\t\t*pxfiles = NULL;\n\t\t\treturn -1;\n\t\t}\n\t\tif (!(*pxfiles = malloc(sz))) {\n\t\t\treturn -1;\n\t\t}\n\t\tif (sysctl(mib, 2, *pxfiles, &sz, NULL, 0) < 0) {\n\t\t\tfree(*pxfiles);\n\t\t\tif (errno == ENOMEM)\n\t\t\t\tcontinue;\n\t\t\t*pxfiles = NULL;\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (sz > 0 && (*pxfiles)->xf_size != sizeof **pxfiles) {\n\t\tlog_err_printf(\"struct xfile size mismatch\\n\");\n\t\treturn -1;\n\t}\n\t*pnxfiles = sz / sizeof **pxfiles;\n\n\treturn 0;\n}\n\n/*\n * Get the list of active TCP connections and do basic consistency checks.\n * If successful, returns 0, and *pxig will receive a pointer to the\n * received data structure, *pexig a pointer to the end of the buffer.\n * If unsuccessful, returns -1 and *pxig will be NULL.\n * Caller is responsible to free() *pxig after use.\n */\nstatic int\nproc_freebsd_gettcppcblist(struct xinpgen **pxig, struct xinpgen **pexig)\n{\n\tint mib[4];\n\tsize_t sz;\n\tint retry = 5;\n\n\tmib[0] = CTL_NET;\n\tmib[1] = PF_INET;\n\tmib[2] = IPPROTO_TCP;\n\tmib[3] = TCPCTL_PCBLIST;\n\tdo {\n\t\tfor (;;) {\n\t\t\tif (sysctl(mib, 4, NULL, &sz, NULL, 0) < 0) {\n\t\t\t\t*pxig = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (!(*pxig = malloc(sz))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (sysctl(mib, 4, *pxig, &sz, NULL, 0) < 0) {\n\t\t\t\tfree(*pxig);\n\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\tcontinue;\n\t\t\t\t*pxig = NULL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t*pexig = (struct xinpgen *)(void *)\n\t\t         ((char *)(*pxig) + sz - sizeof(**pexig));\n\t\tif ((*pxig)->xig_len != sizeof(**pxig) ||\n\t\t    (*pexig)->xig_len != sizeof(**pexig)) {\n\t\t\tlog_err_printf(\"struct xinpgen size mismatch\\n\");\n\t\t\tfree(*pxig);\n\t\t\t*pxig = NULL;\n\t\t\treturn -1;\n\t\t}\n\t} while ((*pxig)->xig_gen != (*pexig)->xig_gen && retry--);\n\n\t/* check if first and last record are from same generation */\n\tif ((*pxig)->xig_gen != (*pexig)->xig_gen) {\n\t\tlog_err_printf(\"Warning: data inconsistent \"\n\t\t               \"(xig->xig_gen != exig->xig_gen)\\n\");\n\t}\n\n\treturn 0;\n}\n\nint\nproc_freebsd_pid_for_addr(pid_t *result, struct sockaddr *src_addr,\n                          UNUSED socklen_t src_addrlen)\n{\n\tstruct xfile *xfiles;\n\tint nxfiles;\n\tstruct xfile *xf;\n\n\tstruct xinpgen *xig, *exig, *txig;\n\tstruct xtcpcb *xtp;\n#if __FreeBSD_version >= 1200026\n\tstruct xinpcb *inp;\n#else\n\tstruct inpcb *inp;\n#endif\n\tstruct xsocket *so;\n\n\tif (proc_freebsd_getfiles(&xfiles, &nxfiles) == -1) {\n\t\treturn -1;\n\t}\n\n\tif (proc_freebsd_gettcppcblist(&xig, &exig) == -1) {\n\t\tfree(xfiles);\n\t\treturn -1;\n\t}\n\n\tfor (txig = (struct xinpgen *)(void *)((char *)xig + xig->xig_len);\n\t     txig < exig;\n\t     txig = (struct xinpgen *)(void *)((char *)txig + txig->xig_len)) {\n\t\txtp = (struct xtcpcb *)txig;\n\t\tif (xtp->xt_len != sizeof *xtp) {\n\t\t\tfree(xfiles);\n\t\t\tfree(xig);\n\t\t\treturn -1;\n\t\t}\n\t\tinp = &xtp->xt_inp;\n#if __FreeBSD_version >= 1200026\n\t\tso = &inp->xi_socket;\n#else\n\t\tso = &xtp->xt_socket;\n#endif\n\n\t\tif (!(so->so_state & SS_ISCONNECTED))\n\t\t\t/* we are only interested in connected sockets */\n\t\t\tcontinue;\n\n\t\tif ((inp->inp_vflag & INP_IPV4) &&\n\t\t    (src_addr->sa_family == AF_INET)) {\n\t\t\tstruct sockaddr_in *src_sai =\n\t\t\t\t\t(struct sockaddr_in *)src_addr;\n\n\t\t\tif (src_sai->sin_addr.s_addr != inp->inp_laddr.s_addr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (src_sai->sin_port != inp->inp_lport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if ((inp->inp_vflag & INP_IPV6) &&\n\t\t          (src_addr->sa_family == AF_INET6)) {\n\t\t\tstruct sockaddr_in6 *src_sai =\n\t\t\t\t\t(struct sockaddr_in6 *)src_addr;\n\n\t\t\tif (memcmp(src_sai->sin6_addr.s6_addr, inp->in6p_laddr.s6_addr, 16) != 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (src_sai->sin6_port != inp->inp_lport) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* other address family */\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* valid match */\n\n\t\t/* only do this if we have a match */\n\t\txf = NULL;\n\t\tfor (int i = 0; i < nxfiles; ++i) {\n\t\t\tif (so->xso_so == xfiles[i].xf_data) {\n\t\t\t\t/* there can be several processes sharing a\n\t\t\t\t * connected socket file descriptor */\n\t\t\t\txf = &xfiles[i];\n\t\t\t}\n\t\t}\n\t\tif (!xf)\n\t\t\tcontinue;\n\t\t*result = xf->xf_pid;\n\t\tbreak;\n\t}\n\n\tfree(xfiles);\n\tfree(xig);\n\treturn 0;\n}\n\nint\nproc_freebsd_get_info(pid_t pid, char **path, uid_t *uid, gid_t *gid) {\n\tstatic struct kinfo_proc proc;\n\tsize_t len;\n\tint mib[4];\n\tchar buf[PATH_MAX];\n\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC;\n\tmib[2] = KERN_PROC_PATHNAME;\n\tmib[3] = (int)pid;\n\tlen = sizeof(buf);\n\tif (sysctl(mib, 4, buf, &len, NULL, 0) == -1) {\n\t\tif (errno != ESRCH) {\n\t\t\tlog_err_printf(\"Failed to get proc pathname: %s (%i)\",\n\t\t\t               strerror(errno), errno);\n\t\t}\n\t\t*path = NULL;\n\t} else {\n\t\t*path = strdup(buf);\n\t}\n\n\tmib[0] = CTL_KERN;\n\tmib[1] = KERN_PROC;\n\tmib[2] = KERN_PROC_PID;\n\tmib[3] = (int)pid;\n\tlen = sizeof proc;\n\tif (sysctl(mib, 4, &proc, &len, NULL, 0) == -1) {\n\t\tif (errno != ESRCH) {\n\t\t\tlog_err_printf(\"Failed to get proc info: %s (%i)\",\n\t\t\t               strerror(errno), errno);\n\t\t}\n\t\t*uid = -1;\n\t\t*gid = -1;\n\t} else {\n\t\tif (*path == NULL)\n\t\t\t*path = strdup(proc.ki_comm);\n\t\t*uid = proc.ki_uid;\n\t\t*gid = proc.ki_groups[0];\n\t}\n\n\treturn 0;\n}\n\n#endif /* __FreeBSD__ */\n\n\n#ifdef HAVE_DARWIN_LIBPROC\n\nint\nproc_darwin_pid_for_addr(pid_t *result, struct sockaddr *src_addr,\n                         UNUSED socklen_t src_addrlen)\n{\n\tpid_t *pids = NULL;\n\tstruct proc_fdinfo *fds = NULL;\n\tint ret = -1;\n\n\t/* default result if no pid matches */\n\t*result = -1;\n\n\t/* iterate over all pids to find a matching socket */\n\tint pid_count = proc_listallpids(NULL, 0);\n\tif (pid_count <= 0)\n\t\tgoto errout1;\n\tpids = malloc(sizeof(pid_t) * pid_count);\n\tif (!pids) {\n\t\tgoto errout1;\n\t}\n\n\tpid_count = proc_listallpids(pids, sizeof(pid_t) * pid_count);\n\tif (pid_count <= 0)\n\t\tgoto errout2;\n\n\tfor (int i = 0; i < pid_count; i++) {\n\t\tpid_t pid = pids[i];\n\n\t\t/* fetch fd info for this pid */\n\t\tint fd_count = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, NULL, 0);\n\t\tif (fd_count <= 0) {\n\t\t\t/* failed to fetch pidinfo; process may have exited */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (fds) {\n\t\t\tfree(fds);\n\t\t}\n\t\tfds = malloc(PROC_PIDLISTFD_SIZE * fd_count);\n\t\tif (!fds) {\n\t\t\tgoto errout2;\n\t\t}\n\t\tfd_count = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fds,\n\t\t                        sizeof(fds[0]) * fd_count);\n\n\t\t/* look for a matching socket file descriptor */\n\t\tfor (int j = 0; j < fd_count; j++) {\n\t\t\tstruct proc_fdinfo *fd = &fds[j];\n\t\t\tstruct socket_fdinfo sinfo;\n\n\t\t\tif (fd->proc_fdtype != PROX_FDTYPE_SOCKET) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (proc_pidfdinfo(pid, fd->proc_fd,\n\t\t\t                   PROC_PIDFDSOCKETINFO,\n\t\t\t                   &sinfo,\n\t\t\t                   sizeof(struct socket_fdinfo)) <= 0) {\n\t\t\t\t/* process may have exited or socket may have\n\t\t\t\t * been released. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sinfo.psi.soi_kind != SOCKINFO_TCP) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuint16_t sock_lport = sinfo.psi.soi_proto.pri_tcp.tcpsi_ini.insi_lport;\n\t\t\tif (sinfo.psi.soi_family == AF_INET &&\n\t\t\t    src_addr->sa_family == AF_INET) {\n\t\t\t\tstruct sockaddr_in *src_sai = (struct sockaddr_in *)src_addr;\n\n\t\t\t\tif (src_sai->sin_addr.s_addr != sinfo.psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_46.i46a_addr4.s_addr) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (src_sai->sin_port != sock_lport) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if (sinfo.psi.soi_family == AF_INET6 &&\n\t\t\t           src_addr->sa_family == AF_INET6) {\n\t\t\t\tstruct sockaddr_in6 *src_sai = (struct sockaddr_in6 *)src_addr;\n\n\t\t\t\tif (memcmp(src_sai->sin6_addr.s6_addr, sinfo.psi.soi_proto.pri_tcp.tcpsi_ini.insi_laddr.ina_6.s6_addr, 16) != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (src_sai->sin6_port != sock_lport) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* other address family */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* valid match */\n\t\t\t*result = pid;\n\t\t\tgoto success;\n\t\t}\n\t}\n\nsuccess:\n\tret = 0;\n\tfree(fds);\nerrout2:\n\tfree(pids);\nerrout1:\n\treturn ret;\n}\n\n/*\n * Fetch process info for the given pid.\n * On success, returns 0 and fills in path, uid, and gid.\n * Caller must free returned path string.\n * Returns -1 on failure, or if unsupported on this platform.\n */\nint\nproc_darwin_get_info(pid_t pid, char **path, uid_t *uid, gid_t *gid) {\n\t/* fetch process structure */\n\tstruct proc_bsdinfo bsd_info;\n\tif (proc_pidinfo(pid, PROC_PIDTBSDINFO, 0, &bsd_info,\n\t                 sizeof(bsd_info)) <= 0) {\n\t\treturn -1;\n\t}\n\n\t*uid = bsd_info.pbi_uid;\n\t*gid = bsd_info.pbi_gid;\n\n\t/* fetch process path */\n\t*path = malloc(PROC_PIDPATHINFO_MAXSIZE);\n\tif (!*path) {\n\t\treturn -1;\n\t}\n\tint path_len = proc_pidpath(pid, *path, PROC_PIDPATHINFO_MAXSIZE);\n\tif (path_len <= 0) {\n\t\tfree(*path);\n\t\t*path = NULL;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n#endif /* HAVE_DARWIN_LIBPROC */\n\n/* vim: set noet ft=c: */\n\n\n\n"
        },
        {
          "name": "proc.h",
          "type": "blob",
          "size": 2.6015625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef PROC_H\n#define PROC_H\n\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <event2/util.h>\n\n#if defined(HAVE_DARWIN_LIBPROC) || defined(__FreeBSD__)\n#define HAVE_LOCAL_PROCINFO\n#endif\n\n#ifdef HAVE_DARWIN_LIBPROC\n#ifndef LOCAL_PROCINFO_STR\n#define LOCAL_PROCINFO_STR \"Darwin libproc\"\n#define proc_pid_for_addr(a,b,c)\tproc_darwin_pid_for_addr(a,b,c)\n#define proc_get_info(a,b,c,d)\t\tproc_darwin_get_info(a,b,c,d)\n#endif /* LOCAL_PROCINFO_STR */\nint proc_darwin_pid_for_addr(pid_t *, struct sockaddr *, socklen_t) WUNRES NONNULL(1,2);\nint proc_darwin_get_info(pid_t, char **, uid_t *, gid_t *) WUNRES NONNULL(2,3,4);\n#endif /* HAVE_DARWIN_LIBPROC */\n\n#ifdef __FreeBSD__\n#ifndef LOCAL_PROCINFO_STR\n#define LOCAL_PROCINFO_STR \"FreeBSD sysctl\"\n#define proc_pid_for_addr(a,b,c)\tproc_freebsd_pid_for_addr(a,b,c)\n#define proc_get_info(a,b,c,d)\t\tproc_freebsd_get_info(a,b,c,d)\n#endif /* LOCAL_PROCINFO_STR */\nint proc_freebsd_pid_for_addr(pid_t *, struct sockaddr *, socklen_t) WUNRES NONNULL(1,2);\nint proc_freebsd_get_info(pid_t, char **, uid_t *, gid_t *) WUNRES NONNULL(2,3,4);\n#endif /* __FreeBSD__ */\n\n#endif /* !PROC_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "proxy.c",
          "type": "blob",
          "size": 11.0908203125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"proxy.h\"\n\n#include \"privsep.h\"\n#include \"pxythrmgr.h\"\n#include \"pxyconn.h\"\n#include \"cachemgr.h\"\n#include \"opts.h\"\n#include \"log.h\"\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <signal.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n#include <event2/event.h>\n#include <event2/listener.h>\n#include <event2/bufferevent.h>\n#include <event2/bufferevent_ssl.h>\n#include <event2/buffer.h>\n#include <event2/thread.h>\n\n\n/*\n * Proxy engine, built around libevent 2.x.\n */\n\nstatic int signals[] = { SIGTERM, SIGQUIT, SIGHUP, SIGINT, SIGPIPE, SIGUSR1 };\n\nstruct proxy_ctx {\n\tpxy_thrmgr_ctx_t *thrmgr;\n\tstruct event_base *evbase;\n\tstruct event *sev[sizeof(signals)/sizeof(int)];\n\tstruct event *gcev;\n\tstruct proxy_listener_ctx *lctx;\n\topts_t *opts;\n\tint loopbreak_reason;\n};\n\n\n/*\n * Listener context.\n */\ntypedef struct proxy_listener_ctx {\n\tpxy_thrmgr_ctx_t *thrmgr;\n\tproxyspec_t *spec;\n\topts_t *opts;\n\tstruct evconnlistener *evcl;\n\tstruct proxy_listener_ctx *next;\n} proxy_listener_ctx_t;\n\nstatic proxy_listener_ctx_t *\nproxy_listener_ctx_new(pxy_thrmgr_ctx_t *thrmgr, proxyspec_t *spec,\n                       opts_t *opts) MALLOC;\nstatic proxy_listener_ctx_t *\nproxy_listener_ctx_new(pxy_thrmgr_ctx_t *thrmgr, proxyspec_t *spec,\n                       opts_t *opts)\n{\n\tproxy_listener_ctx_t *ctx = malloc(sizeof(proxy_listener_ctx_t));\n\tif (!ctx)\n\t\treturn NULL;\n\tmemset(ctx, 0, sizeof(proxy_listener_ctx_t));\n\tctx->thrmgr = thrmgr;\n\tctx->spec = spec;\n\tctx->opts = opts;\n\treturn ctx;\n}\n\nstatic void\nproxy_listener_ctx_free(proxy_listener_ctx_t *ctx) NONNULL(1);\nstatic void\nproxy_listener_ctx_free(proxy_listener_ctx_t *ctx)\n{\n\tif (ctx->evcl) {\n\t\tevconnlistener_free(ctx->evcl);\n\t}\n\tif (ctx->next) {\n\t\tproxy_listener_ctx_free(ctx->next);\n\t}\n\tfree(ctx);\n}\n\n/*\n * Callback for accept events on the socket listener bufferevent.\n */\nstatic void\nproxy_listener_acceptcb(UNUSED struct evconnlistener *listener,\n                        evutil_socket_t fd,\n                        struct sockaddr *peeraddr, int peeraddrlen,\n                        void *arg)\n{\n\tproxy_listener_ctx_t *cfg = arg;\n\n\tpxy_conn_setup(fd, peeraddr, peeraddrlen, cfg->thrmgr,\n\t               cfg->spec, cfg->opts);\n}\n\n/*\n * Callback for error events on the socket listener bufferevent.\n */\nstatic void\nproxy_listener_errorcb(struct evconnlistener *listener, UNUSED void *ctx)\n{\n\tstruct event_base *evbase = evconnlistener_get_base(listener);\n\tint err = EVUTIL_SOCKET_ERROR();\n\tlog_err_printf(\"Error %d on listener: %s\\n\", err,\n\t               evutil_socket_error_to_string(err));\n\tevent_base_loopbreak(evbase);\n}\n\n/*\n * Dump a description of an evbase to debugging code.\n */\nstatic void\nproxy_debug_base(const struct event_base *ev_base)\n{\n\tlog_dbg_printf(\"Using libevent backend '%s'\\n\",\n\t               event_base_get_method(ev_base));\n\n\tenum event_method_feature f;\n\tf = event_base_get_features(ev_base);\n\tlog_dbg_printf(\"Event base supports: edge %s, O(1) %s, anyfd %s\\n\",\n\t               ((f & EV_FEATURE_ET) ? \"yes\" : \"no\"),\n\t               ((f & EV_FEATURE_O1) ? \"yes\" : \"no\"),\n\t               ((f & EV_FEATURE_FDS) ? \"yes\" : \"no\"));\n}\n\n/*\n * Set up the listener for a single proxyspec and add it to evbase.\n * Returns the proxy_listener_ctx_t pointer if successful, NULL otherwise.\n */\nstatic proxy_listener_ctx_t *\nproxy_listener_setup(struct event_base *evbase, pxy_thrmgr_ctx_t *thrmgr,\n                     proxyspec_t *spec, opts_t *opts, int clisock)\n{\n\tproxy_listener_ctx_t *plc;\n\tint fd;\n\n\tif ((fd = privsep_client_opensock(clisock, spec)) == -1) {\n\t\tlog_err_printf(\"Error opening socket: %s (%i)\\n\",\n\t\t               strerror(errno), errno);\n\t\treturn NULL;\n\t}\n\n\tplc = proxy_listener_ctx_new(thrmgr, spec, opts);\n\tif (!plc) {\n\t\tlog_err_printf(\"Error creating listener context\\n\");\n\t\tevutil_closesocket(fd);\n\t\treturn NULL;\n\t}\n\n\tplc->evcl = evconnlistener_new(evbase, proxy_listener_acceptcb,\n\t                               plc, LEV_OPT_CLOSE_ON_FREE, 1024, fd);\n\tif (!plc->evcl) {\n\t\tlog_err_printf(\"Error creating evconnlistener: %s\\n\",\n\t\t               strerror(errno));\n\t\tproxy_listener_ctx_free(plc);\n\t\tevutil_closesocket(fd);\n\t\treturn NULL;\n\t}\n\tevconnlistener_set_error_cb(plc->evcl, proxy_listener_errorcb);\n\treturn plc;\n}\n\n/*\n * Signal handler for SIGTERM, SIGQUIT, SIGINT, SIGHUP, SIGPIPE and SIGUSR1.\n */\nstatic void\nproxy_signal_cb(evutil_socket_t fd, UNUSED short what, void *arg)\n{\n\tproxy_ctx_t *ctx = arg;\n\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Received signal %i\\n\", fd);\n\t}\n\n\tswitch(fd) {\n\tcase SIGTERM:\n\tcase SIGQUIT:\n\tcase SIGINT:\n\tcase SIGHUP:\n\t\tproxy_loopbreak(ctx, fd);\n\t\tbreak;\n\tcase SIGUSR1:\n\t\tif (log_reopen() == -1) {\n\t\t\tlog_err_printf(\"Warning: Failed to reopen logs\\n\");\n\t\t} else {\n\t\t\tlog_dbg_printf(\"Reopened log files\\n\");\n\t\t}\n\t\tbreak;\n\tcase SIGPIPE:\n\t\tlog_err_printf(\"Warning: Received SIGPIPE; ignoring.\\n\");\n\t\tbreak;\n\tdefault:\n\t\tlog_err_printf(\"Warning: Received unexpected signal %i\\n\", fd);\n\t\tbreak;\n\t}\n}\n\n/*\n * Garbage collection handler.\n */\nstatic void\nproxy_gc_cb(UNUSED evutil_socket_t fd, UNUSED short what, void *arg)\n{\n\tproxy_ctx_t *ctx = arg;\n\n\tif (OPTS_DEBUG(ctx->opts))\n\t\tlog_dbg_printf(\"Garbage collecting caches started.\\n\");\n\n\tcachemgr_gc();\n\n\tif (OPTS_DEBUG(ctx->opts))\n\t\tlog_dbg_printf(\"Garbage collecting caches done.\\n\");\n}\n\n/*\n * Set up the core event loop.\n * Socket clisock is the privsep client socket used for binding to ports.\n * Returns ctx on success, or NULL on error.\n */\nproxy_ctx_t *\nproxy_new(opts_t *opts, int clisock)\n{\n\tproxy_listener_ctx_t *head;\n\tproxy_ctx_t *ctx;\n\tstruct evdns_base *dnsbase;\n\tint rc;\n\n\t/* adds locking, only required if accessed from separate threads */\n\tevthread_use_pthreads();\n\n#ifndef PURIFY\n\tif (OPTS_DEBUG(opts)) {\n\t\tevent_enable_debug_mode();\n\t}\n#endif /* PURIFY */\n\n\tctx = malloc(sizeof(proxy_ctx_t));\n\tif (!ctx) {\n\t\tlog_err_printf(\"Error allocating memory\\n\");\n\t\tgoto leave0;\n\t}\n\tmemset(ctx, 0, sizeof(proxy_ctx_t));\n\n\tctx->opts = opts;\n\tctx->evbase = event_base_new();\n\tif (!ctx->evbase) {\n\t\tlog_err_printf(\"Error getting event base\\n\");\n\t\tgoto leave1;\n\t}\n\n\tif (opts_has_dns_spec(opts)) {\n\t\t/* create a dnsbase here purely for being able to test parsing\n\t\t * resolv.conf while we can still alert the user about it. */\n\t\tdnsbase = evdns_base_new(ctx->evbase, 0);\n\t\tif (!dnsbase) {\n\t\t\tlog_err_printf(\"Error creating dns event base\\n\");\n\t\t\tgoto leave1b;\n\t\t}\n\t\trc = evdns_base_resolv_conf_parse(dnsbase, DNS_OPTIONS_ALL,\n\t\t                                  \"/etc/resolv.conf\");\n\t\tevdns_base_free(dnsbase, 0);\n\t\tif (rc != 0) {\n\t\t\tlog_err_printf(\"evdns cannot parse resolv.conf: \"\n\t\t\t               \"%s (%d)\\n\",\n\t\t\t               rc == 1 ? \"failed to open file\" :\n\t\t\t               rc == 2 ? \"failed to stat file\" :\n\t\t\t               rc == 3 ? \"file too large\" :\n\t\t\t               rc == 4 ? \"out of memory\" :\n\t\t\t               rc == 5 ? \"short read from file\" :\n\t\t\t               rc == 6 ? \"no nameservers in file\" :\n\t\t\t               \"unknown error\", rc);\n\t\t\tgoto leave1b;\n\t\t}\n\t}\n\n\tif (OPTS_DEBUG(opts)) {\n\t\tproxy_debug_base(ctx->evbase);\n\t}\n\n\tctx->thrmgr = pxy_thrmgr_new(opts);\n\tif (!ctx->thrmgr) {\n\t\tlog_err_printf(\"Error creating thread manager\\n\");\n\t\tgoto leave1b;\n\t}\n\n\thead = ctx->lctx = NULL;\n\tfor (proxyspec_t *spec = opts->spec; spec; spec = spec->next) {\n\t\thead = proxy_listener_setup(ctx->evbase, ctx->thrmgr,\n\t\t                            spec, opts, clisock);\n\t\tif (!head)\n\t\t\tgoto leave2;\n\t\thead->next = ctx->lctx;\n\t\tctx->lctx = head;\n\t}\n\n\tfor (size_t i = 0; i < (sizeof(signals) / sizeof(int)); i++) {\n\t\tctx->sev[i] = evsignal_new(ctx->evbase, signals[i],\n\t\t                           proxy_signal_cb, ctx);\n\t\tif (!ctx->sev[i])\n\t\t\tgoto leave3;\n\t\tevsignal_add(ctx->sev[i], NULL);\n\t}\n\n\tstruct timeval gc_delay = {60, 0};\n\tctx->gcev = event_new(ctx->evbase, -1, EV_PERSIST, proxy_gc_cb, ctx);\n\tif (!ctx->gcev)\n\t\tgoto leave4;\n\tevtimer_add(ctx->gcev, &gc_delay);\n\n\tprivsep_client_close(clisock);\n\treturn ctx;\n\nleave4:\n\tif (ctx->gcev) {\n\t\tevent_free(ctx->gcev);\n\t}\n\nleave3:\n\tfor (size_t i = 0; i < (sizeof(ctx->sev) / sizeof(ctx->sev[0])); i++) {\n\t\tif (ctx->sev[i]) {\n\t\t\tevent_free(ctx->sev[i]);\n\t\t}\n\t}\nleave2:\n\tif (ctx->lctx) {\n\t\tproxy_listener_ctx_free(ctx->lctx);\n\t}\n\tpxy_thrmgr_free(ctx->thrmgr);\nleave1b:\n\tevent_base_free(ctx->evbase);\nleave1:\n\tfree(ctx);\nleave0:\n\treturn NULL;\n}\n\n/*\n * Run the event loop.\n * Returns 0 on non-signal termination, signal number when the event loop was\n * cancelled by a signal, or -1 on failure.\n */\nint\nproxy_run(proxy_ctx_t *ctx)\n{\n\tif (ctx->opts->detach) {\n\t\tevent_reinit(ctx->evbase);\n\t}\n#ifndef PURIFY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tevent_base_dump_events(ctx->evbase, stderr);\n\t}\n#endif /* PURIFY */\n\tif (pxy_thrmgr_run(ctx->thrmgr) == -1) {\n\t\tlog_err_printf(\"Failed to start thread manager\\n\");\n\t\treturn -1;\n\t}\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Starting main event loop.\\n\");\n\t}\n\tevent_base_dispatch(ctx->evbase);\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Main event loop stopped (reason=%i).\\n\",\n\t\t               ctx->loopbreak_reason);\n\t}\n\treturn ctx->loopbreak_reason;\n}\n\n/*\n * Break the loop of the proxy, causing the proxy_run to return, returning\n * the reason given in reason (signal number, 0 for success, -1 for error).\n */\nvoid\nproxy_loopbreak(proxy_ctx_t *ctx, int reason)\n{\n\tctx->loopbreak_reason = reason;\n\tevent_base_loopbreak(ctx->evbase);\n}\n\n/*\n * Free the proxy data structures.\n */\nvoid\nproxy_free(proxy_ctx_t *ctx)\n{\n\tif (ctx->gcev) {\n\t\tevent_free(ctx->gcev);\n\t}\n\tif (ctx->lctx) {\n\t\tproxy_listener_ctx_free(ctx->lctx);\n\t}\n\tfor (size_t i = 0; i < (sizeof(ctx->sev) / sizeof(ctx->sev[0])); i++) {\n\t\tif (ctx->sev[i]) {\n\t\t\tevent_free(ctx->sev[i]);\n\t\t}\n\t}\n\tif (ctx->thrmgr) {\n\t\tpxy_thrmgr_free(ctx->thrmgr);\n\t}\n\tif (ctx->evbase) {\n\t\tevent_base_free(ctx->evbase);\n\t}\n\tfree(ctx);\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "proxy.h",
          "type": "blob",
          "size": 1.7978515625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef PROXY_H\n#define PROXY_H\n\n#include \"opts.h\"\n#include \"attrib.h\"\n\ntypedef struct proxy_ctx proxy_ctx_t;\n\nproxy_ctx_t * proxy_new(opts_t *, int) NONNULL(1) MALLOC;\nint proxy_run(proxy_ctx_t *) NONNULL(1);\nvoid proxy_loopbreak(proxy_ctx_t *, int) NONNULL(1);\nvoid proxy_free(proxy_ctx_t *) NONNULL(1);\n\n#endif /* !PROXY_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "pxyconn.c",
          "type": "blob",
          "size": 77.4501953125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"pxyconn.h\"\n\n#include \"cachemgr.h\"\n#include \"ssl.h\"\n#include \"opts.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"base64.h\"\n#include \"url.h\"\n#include \"log.h\"\n#include \"attrib.h\"\n#include \"proc.h\"\n\n#include <netinet/in.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n#include <event2/event.h>\n#include <event2/listener.h>\n#include <event2/bufferevent.h>\n#include <event2/bufferevent_ssl.h>\n#include <event2/buffer.h>\n#include <event2/thread.h>\n#include <event2/dns.h>\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n\n/*\n * libevent compatibility\n */\n#if LIBEVENT_VERSION_NUMBER < 0x02010000\nstatic void\nbufferevent_openssl_set_allow_dirty_shutdown(UNUSED struct bufferevent *bev,\n                                             UNUSED int allow_dirty_shutdown)\n{\n\treturn;\n}\n#endif /* LIBEVENT_VERSION_NUMBER < 0x02010000 */\n\n#if OPENSSL_VERSION_NUMBER >= 0x30000000L\n#define ERR_GET_FUNC(x) 0\n#define ERR_func_error_string(x) \"\"\n#endif\n\n/*\n * Maximum size of data to buffer per connection direction before\n * temporarily stopping to read data from the other end.\n */\n#define OUTBUF_LIMIT\t(128*1024)\n\n/*\n * Print helper for logging code.\n */\n#define STRORDASH(x)\t(((x)&&*(x))?(x):\"-\")\n\n/*\n * Context used for all server sessions.\n */\n#ifdef USE_SSL_SESSION_ID_CONTEXT\nstatic unsigned long ssl_session_context = 0x31415926;\n#endif /* USE_SSL_SESSION_ID_CONTEXT */\n\n\n/*\n * Proxy connection context state, describes a proxy connection\n * with source and destination socket bufferevents, SSL context and\n * other session state.  One of these exists per handled proxy\n * connection.\n */\n\n/* single dst or src socket bufferevent descriptor */\ntypedef struct pxy_conn_desc {\n\tstruct bufferevent *bev;\n\tSSL *ssl;\n\tunsigned int closed : 1;\n} pxy_conn_desc_t;\n\n#ifdef HAVE_LOCAL_PROCINFO\n/* local process data - filled in iff pid != -1 */\ntypedef struct pxy_conn_lproc_desc {\n\tpid_t pid;\n\tuid_t uid;\n\tgid_t gid;\n\n\t/* derived log strings */\n\tchar *exec_path;\n\tchar *user;\n\tchar *group;\n} pxy_conn_lproc_desc_t;\n#endif /* HAVE_LOCAL_PROCINFO */\n\n/* actual proxy connection state consisting of two connection descriptors,\n * connection-wide state and the specs and options */\ntypedef struct pxy_conn_ctx {\n\t/* per-connection state */\n\tstruct pxy_conn_desc src;\n\tstruct pxy_conn_desc dst;\n\n\t/* status flags */\n\tunsigned int connected : 1;       /* 0 until both ends are connected */\n\tunsigned int enomem : 1;                       /* 1 if out of memory */\n\t/* ssl */\n\tunsigned int sni_peek_retries : 6;       /* max 64 SNI parse retries */\n\tunsigned int immutable_cert : 1;  /* 1 if the cert cannot be changed */\n\tunsigned int generated_cert : 1;     /* 1 if we generated a new cert */\n\tunsigned int passthrough : 1;      /* 1 if SSL passthrough is active */\n\t/* http */\n\tunsigned int seen_req_header : 1; /* 0 until request header complete */\n\tunsigned int seen_resp_header : 1;  /* 0 until response hdr complete */\n\tunsigned int sent_http_conn_close : 1;   /* 0 until Conn: close sent */\n\tunsigned int ocsp_denied : 1;                /* 1 if OCSP was denied */\n\t/* autossl */\n\tunsigned int clienthello_search : 1;       /* 1 if waiting for hello */\n\tunsigned int clienthello_found : 1;      /* 1 if conn upgrade to SSL */\n\n\t/* server name indicated by client in SNI TLS extension */\n\tchar *sni;\n\n\t/* log strings from socket */\n\tchar *srchost_str;\n\tchar *srcport_str;\n\tchar *dsthost_str;\n\tchar *dstport_str;\n\n\t/* log strings from HTTP request */\n\tchar *http_method;\n\tchar *http_uri;\n\tchar *http_host;\n\tchar *http_content_type;\n\n\t/* log strings from HTTP response */\n\tchar *http_status_code;\n\tchar *http_status_text;\n\tchar *http_content_length;\n\n\t/* log strings related to SSL */\n\tchar *ssl_names;\n\tchar *origcrtfpr;\n\tchar *usedcrtfpr;\n\n#ifdef HAVE_LOCAL_PROCINFO\n\t/* local process information */\n\tpxy_conn_lproc_desc_t lproc;\n#endif /* HAVE_LOCAL_PROCINFO */\n\n\t/* content log context */\n\tlog_content_ctx_t logctx;\n\n\t/* store fd and fd event while connected is 0 */\n\tevutil_socket_t fd;\n\tstruct event *ev;\n\n\t/* original source and destination address, family and certificate */\n\tstruct sockaddr_storage srcaddr;\n\tsocklen_t srcaddrlen;\n\tstruct sockaddr_storage dstaddr;\n\tsocklen_t dstaddrlen;\n\tint af;\n\tX509 *origcrt;\n\n\t/* references to event base and configuration */\n\tstruct event_base *evbase;\n\tstruct evdns_base *dnsbase;\n\tint thridx;\n\tpxy_thrmgr_ctx_t *thrmgr;\n\tproxyspec_t *spec;\n\topts_t *opts;\n} pxy_conn_ctx_t;\n\n#define WANT_CONNECT_LOG(ctx)\t((ctx)->opts->connectlog||!(ctx)->opts->detach)\n#ifndef WITHOUT_MIRROR\n#define WANT_CONTENT_LOG(ctx)\t(((ctx)->opts->contentlog||(ctx)->opts->pcaplog||(ctx)->opts->mirrorif)&&!(ctx)->passthrough)\n#else /* WITHOUT_MIRROR */\n#define WANT_CONTENT_LOG(ctx)\t(((ctx)->opts->contentlog||(ctx)->opts->pcaplog)&&!(ctx)->passthrough)\n#endif /* WITHOUT_MIRROR */\n\nstatic void\nadd_line_to_content_log(const char *line, logbuf_t **plb, logbuf_t **ptail) {\n\tlogbuf_t *tmp;\n\ttmp = logbuf_new_printf(NULL, \"%s\\r\\n\", line);\n\tif (tmp) {\n\t\tif (*ptail) {\n\t\t\t(*ptail)->next = tmp;\n\t\t\t(*ptail) = (*ptail)->next;\n\t\t} else {\n\t\t\t*plb = *ptail = tmp;\n\t\t}\n\t}\n}\n\nstatic void\nsubmit_content_logbuf_free(pxy_conn_ctx_t *ctx, logbuf_t *lb, int is_req) {\n\tif (lb) {\n\t\tif (log_content_submit(&ctx->logctx, lb,\n\t                           is_req) == -1) {\n\t\t\tlogbuf_free(lb);\n\t\t\tlog_err_printf(\"Warning: Content log \"\n\t\t\t               \"submission failed\\n\");\n\t\t}\n\t}\n}\n\nstatic pxy_conn_ctx_t *\npxy_conn_ctx_new(proxyspec_t *spec, opts_t *opts,\n                 pxy_thrmgr_ctx_t *thrmgr, evutil_socket_t fd)\n                 MALLOC NONNULL(1,2,3);\nstatic pxy_conn_ctx_t *\npxy_conn_ctx_new(proxyspec_t *spec, opts_t *opts,\n                 pxy_thrmgr_ctx_t *thrmgr, evutil_socket_t fd)\n{\n\tpxy_conn_ctx_t *ctx = malloc(sizeof(pxy_conn_ctx_t));\n\tif (!ctx)\n\t\treturn NULL;\n\tmemset(ctx, 0, sizeof(pxy_conn_ctx_t));\n\tctx->spec = spec;\n\tctx->opts = opts;\n\tctx->clienthello_search = spec->upgrade;\n\tctx->fd = fd;\n\tctx->thridx = pxy_thrmgr_attach(thrmgr, &ctx->evbase, &ctx->dnsbase);\n\tctx->thrmgr = thrmgr;\n#ifdef HAVE_LOCAL_PROCINFO\n\tctx->lproc.pid = -1;\n#endif /* HAVE_LOCAL_PROCINFO */\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(opts)) {\n\t\tlog_dbg_printf(\"%p             pxy_conn_ctx_new\\n\",\n\t\t               (void*)ctx);\n\t}\n#endif /* DEBUG_PROXY */\n\treturn ctx;\n}\n\nstatic void NONNULL(1)\npxy_conn_ctx_free(pxy_conn_ctx_t *ctx, int by_requestor)\n{\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"%p             pxy_conn_ctx_free\\n\",\n\t\t                (void*)ctx);\n\t}\n#endif /* DEBUG_PROXY */\n\tif (WANT_CONTENT_LOG(ctx)) {\n\t\tif (log_content_close(&ctx->logctx, by_requestor) == -1) {\n\t\t\tlog_err_printf(\"Warning: Content log close failed\\n\");\n\t\t}\n\t}\n\tpxy_thrmgr_detach(ctx->thrmgr, ctx->thridx);\n\tif (ctx->srchost_str) {\n\t\tfree(ctx->srchost_str);\n\t}\n\tif (ctx->srcport_str) {\n\t\tfree(ctx->srcport_str);\n\t}\n\tif (ctx->dsthost_str) {\n\t\tfree(ctx->dsthost_str);\n\t}\n\tif (ctx->dstport_str) {\n\t\tfree(ctx->dstport_str);\n\t}\n\tif (ctx->http_method) {\n\t\tfree(ctx->http_method);\n\t}\n\tif (ctx->http_uri) {\n\t\tfree(ctx->http_uri);\n\t}\n\tif (ctx->http_host) {\n\t\tfree(ctx->http_host);\n\t}\n\tif (ctx->http_content_type) {\n\t\tfree(ctx->http_content_type);\n\t}\n\tif (ctx->http_status_code) {\n\t\tfree(ctx->http_status_code);\n\t}\n\tif (ctx->http_status_text) {\n\t\tfree(ctx->http_status_text);\n\t}\n\tif (ctx->http_content_length) {\n\t\tfree(ctx->http_content_length);\n\t}\n\tif (ctx->ssl_names) {\n\t\tfree(ctx->ssl_names);\n\t}\n\tif (ctx->origcrtfpr) {\n\t\tfree(ctx->origcrtfpr);\n\t}\n\tif (ctx->usedcrtfpr) {\n\t\tfree(ctx->usedcrtfpr);\n\t}\n#ifdef HAVE_LOCAL_PROCINFO\n\tif (ctx->lproc.exec_path) {\n\t\tfree(ctx->lproc.exec_path);\n\t}\n\tif (ctx->lproc.user) {\n\t\tfree(ctx->lproc.user);\n\t}\n\tif (ctx->lproc.group) {\n\t\tfree(ctx->lproc.group);\n\t}\n#endif /* HAVE_LOCAL_PROCINFO */\n\tif (ctx->origcrt) {\n\t\tX509_free(ctx->origcrt);\n\t}\n\tif (ctx->ev) {\n\t\tevent_free(ctx->ev);\n\t}\n\tif (ctx->sni) {\n\t\tfree(ctx->sni);\n\t}\n\tfree(ctx);\n}\n\n\n/* forward declaration of libevent callbacks */\nstatic void pxy_bev_readcb(struct bufferevent *, void *);\nstatic void pxy_bev_writecb(struct bufferevent *, void *);\nstatic void pxy_bev_eventcb(struct bufferevent *, short, void *);\nstatic void pxy_fd_readcb(evutil_socket_t, short, void *);\n\n/* forward declaration of OpenSSL callbacks */\n#ifndef OPENSSL_NO_TLSEXT\nstatic int pxy_ossl_servername_cb(SSL *ssl, int *al, void *arg);\n#endif /* !OPENSSL_NO_TLSEXT */\nstatic int pxy_ossl_sessnew_cb(SSL *, SSL_SESSION *);\nstatic void pxy_ossl_sessremove_cb(SSL_CTX *, SSL_SESSION *);\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20800000L)\nstatic SSL_SESSION * pxy_ossl_sessget_cb(SSL *, unsigned char *, int, int *);\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\nstatic SSL_SESSION * pxy_ossl_sessget_cb(SSL *, const unsigned char *, int,\n                                         int *);\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\n/*\n * Dump information on a certificate to the debug log.\n */\nstatic void\npxy_debug_crt(X509 *crt)\n{\n\tchar *sj = ssl_x509_subject(crt);\n\tif (sj) {\n\t\tlog_dbg_printf(\"Subject DN: %s\\n\", sj);\n\t\tfree(sj);\n\t}\n\n\tchar *names = ssl_x509_names_to_str(crt);\n\tif (names) {\n\t\tlog_dbg_printf(\"Common Names: %s\\n\", names);\n\t\tfree(names);\n\t}\n\n\tchar *fpr;\n\tif (!(fpr = ssl_x509_fingerprint(crt, 1))) {\n\t\tlog_err_printf(\"Warning: Error generating X509 fingerprint\\n\");\n\t} else {\n\t\tlog_dbg_printf(\"Fingerprint: %s\\n\", fpr);\n\t\tfree(fpr);\n\t}\n\n#ifdef DEBUG_CERTIFICATE\n\t/* dump certificate */\n\tlog_dbg_print_free(ssl_x509_to_str(crt));\n\tlog_dbg_print_free(ssl_x509_to_pem(crt));\n#endif /* DEBUG_CERTIFICATE */\n}\n\nstatic void\npxy_log_connect_nonhttp(pxy_conn_ctx_t *ctx)\n{\n\tchar *msg;\n#ifdef HAVE_LOCAL_PROCINFO\n\tchar *lpi = NULL;\n#endif /* HAVE_LOCAL_PROCINFO */\n\tint rv;\n\n#ifdef HAVE_LOCAL_PROCINFO\n\tif (ctx->opts->lprocinfo) {\n\t\trv = asprintf(&lpi, \"lproc:%i:%s:%s:%s\",\n\t\t              ctx->lproc.pid,\n\t\t              STRORDASH(ctx->lproc.user),\n\t\t              STRORDASH(ctx->lproc.group),\n\t\t              STRORDASH(ctx->lproc.exec_path));\n\t\tif ((rv < 0) || !lpi) {\n\t\t\tctx->enomem = 1;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tlpi = \"-\";\n\t}\n#endif /* HAVE_LOCAL_PROCINFO */\n\n\t/*\n\t * The following ifdef's within asprintf arguments list generates\n\t * warnings with -Wembedded-directive on some compilers.\n\t * Not fixing the code in order to avoid more code duplication.\n\t */\n\n\tif (!ctx->src.ssl) {\n\t\trv = asprintf(&msg, \"%s %s %s %s %s\"\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              \" %s\"\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              \"\\n\",\n\t\t              ctx->passthrough ? \"passthrough\" : \"tcp\",\n\t\t              STRORDASH(ctx->srchost_str),\n\t\t              STRORDASH(ctx->srcport_str),\n\t\t              STRORDASH(ctx->dsthost_str),\n\t\t              STRORDASH(ctx->dstport_str)\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              , lpi\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t             );\n\t} else {\n\t\trv = asprintf(&msg, \"%s %s %s %s %s \"\n\t\t              \"sni:%s names:%s \"\n\t\t              \"sproto:%s:%s dproto:%s:%s \"\n\t\t              \"origcrt:%s usedcrt:%s\"\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              \" %s\"\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              \"\\n\",\n\t\t              ctx->clienthello_found ? \"upgrade\" : \"ssl\",\n\t\t              STRORDASH(ctx->srchost_str),\n\t\t              STRORDASH(ctx->srcport_str),\n\t\t              STRORDASH(ctx->dsthost_str),\n\t\t              STRORDASH(ctx->dstport_str),\n\t\t              STRORDASH(ctx->sni),\n\t\t              STRORDASH(ctx->ssl_names),\n\t\t              SSL_get_version(ctx->src.ssl),\n\t\t              SSL_get_cipher(ctx->src.ssl),\n\t\t              SSL_get_version(ctx->dst.ssl),\n\t\t              SSL_get_cipher(ctx->dst.ssl),\n\t\t              STRORDASH(ctx->origcrtfpr),\n\t\t              STRORDASH(ctx->usedcrtfpr)\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              , lpi\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              );\n\t}\n\tif ((rv < 0) || !msg) {\n\t\tctx->enomem = 1;\n\t\tgoto out;\n\t}\n\tif (!ctx->opts->detach) {\n\t\tlog_err_printf(\"%s\", msg);\n\t}\n\tif (ctx->opts->connectlog) {\n\t\tif (log_connect_print_free(msg) == -1) {\n\t\t\tlog_err_printf(\"Warning: Connection logging failed\\n\");\n\t\t}\n\t} else {\n\t\tfree(msg);\n\t}\nout:\n#ifdef HAVE_LOCAL_PROCINFO\n\tif (lpi && ctx->opts->lprocinfo) {\n\t\tfree(lpi);\n\t}\n#endif /* HAVE_LOCAL_PROCINFO */\n\treturn;\n}\n\nstatic void\npxy_log_connect_http(pxy_conn_ctx_t *ctx)\n{\n\tchar *msg;\n#ifdef HAVE_LOCAL_PROCINFO\n\tchar *lpi = NULL;\n#endif /* HAVE_LOCAL_PROCINFO */\n\tint rv;\n\n#ifdef DEBUG_PROXY\n\tif (ctx->passthrough) {\n\t\tlog_err_printf(\"Warning: pxy_log_connect_http called while in \"\n\t\t               \"passthrough mode\\n\");\n\t\treturn;\n\t}\n#endif\n\n#ifdef HAVE_LOCAL_PROCINFO\n\tif (ctx->opts->lprocinfo) {\n\t\trv = asprintf(&lpi, \"lproc:%i:%s:%s:%s\",\n\t\t              ctx->lproc.pid,\n\t\t              STRORDASH(ctx->lproc.user),\n\t\t              STRORDASH(ctx->lproc.group),\n\t\t              STRORDASH(ctx->lproc.exec_path));\n\t\tif ((rv < 0) || !lpi) {\n\t\t\tctx->enomem = 1;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tlpi = \"-\";\n\t}\n#endif /* HAVE_LOCAL_PROCINFO */\n\n\t/*\n\t * The following ifdef's within asprintf arguments list generates\n\t * warnings with -Wembedded-directive on some compilers.\n\t * Not fixing the code in order to avoid more code duplication.\n\t */\n\n\tif (!ctx->spec->ssl) {\n\t\trv = asprintf(&msg, \"http %s %s %s %s %s %s %s %s %s\"\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              \" %s\"\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              \"%s\\n\",\n\t\t              STRORDASH(ctx->srchost_str),\n\t\t              STRORDASH(ctx->srcport_str),\n\t\t              STRORDASH(ctx->dsthost_str),\n\t\t              STRORDASH(ctx->dstport_str),\n\t\t              STRORDASH(ctx->http_host),\n\t\t              STRORDASH(ctx->http_method),\n\t\t              STRORDASH(ctx->http_uri),\n\t\t              STRORDASH(ctx->http_status_code),\n\t\t              STRORDASH(ctx->http_content_length),\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              lpi,\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              ctx->ocsp_denied ? \" ocsp:denied\" : \"\");\n\t} else {\n\t\trv = asprintf(&msg, \"https %s %s %s %s %s %s %s %s %s \"\n\t\t              \"sni:%s names:%s \"\n\t\t              \"sproto:%s:%s dproto:%s:%s \"\n\t\t              \"origcrt:%s usedcrt:%s\"\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              \" %s\"\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              \"%s\\n\",\n\t\t              STRORDASH(ctx->srchost_str),\n\t\t              STRORDASH(ctx->srcport_str),\n\t\t              STRORDASH(ctx->dsthost_str),\n\t\t              STRORDASH(ctx->dstport_str),\n\t\t              STRORDASH(ctx->http_host),\n\t\t              STRORDASH(ctx->http_method),\n\t\t              STRORDASH(ctx->http_uri),\n\t\t              STRORDASH(ctx->http_status_code),\n\t\t              STRORDASH(ctx->http_content_length),\n\t\t              STRORDASH(ctx->sni),\n\t\t              STRORDASH(ctx->ssl_names),\n\t\t              SSL_get_version(ctx->src.ssl),\n\t\t              SSL_get_cipher(ctx->src.ssl),\n\t\t              SSL_get_version(ctx->dst.ssl),\n\t\t              SSL_get_cipher(ctx->dst.ssl),\n\t\t              STRORDASH(ctx->origcrtfpr),\n\t\t              STRORDASH(ctx->usedcrtfpr),\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t              lpi,\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t              ctx->ocsp_denied ? \" ocsp:denied\" : \"\");\n\t}\n\tif ((rv < 0 ) || !msg) {\n\t\tctx->enomem = 1;\n\t\tgoto out;\n\t}\n\tif (!ctx->opts->detach) {\n\t\tlog_err_printf(\"%s\", msg);\n\t}\n\tif (ctx->opts->connectlog) {\n\t\tif (log_connect_print_free(msg) == -1) {\n\t\t\tlog_err_printf(\"Warning: Connection logging failed\\n\");\n\t\t}\n\t} else {\n\t\tfree(msg);\n\t}\nout:\n#ifdef HAVE_LOCAL_PROCINFO\n\tif (lpi && ctx->opts->lprocinfo) {\n\t\tfree(lpi);\n\t}\n#endif /* HAVE_LOCAL_PROCINFO */\n\treturn;\n}\n\n/*\n * Called by OpenSSL when a new src SSL session is created.\n * OpenSSL increments the refcount before calling the callback and will\n * decrement it again if we return 0.  Returning 1 will make OpenSSL skip\n * the refcount decrementing.  In other words, return 0 if we did not\n * keep a pointer to the object (which we never do here).\n */\n#ifdef HAVE_SSLV2\n#define MAYBE_UNUSED \n#else /* !HAVE_SSLV2 */\n#define MAYBE_UNUSED UNUSED\n#endif /* !HAVE_SSLV2 */\nstatic int\npxy_ossl_sessnew_cb(MAYBE_UNUSED SSL *ssl, SSL_SESSION *sess)\n#undef MAYBE_UNUSED\n{\n#ifdef DEBUG_SESSION_CACHE\n\tlog_dbg_printf(\"===> OpenSSL new session callback:\\n\");\n\tif (sess) {\n\t\tlog_dbg_print_free(ssl_session_to_str(sess));\n\t} else {\n\t\tlog_dbg_printf(\"(null)\\n\");\n\t}\n#endif /* DEBUG_SESSION_CACHE */\n#ifdef HAVE_SSLV2\n\t/* Session resumption seems to fail for SSLv2 with protocol\n\t * parsing errors, so we disable caching for SSLv2. */\n\tif (SSL_version(ssl) == SSL2_VERSION) {\n\t\tlog_err_printf(\"Warning: Session resumption denied to SSLv2\"\n\t\t               \"client.\\n\");\n\t\treturn 0;\n\t}\n#endif /* HAVE_SSLV2 */\n\tif (sess) {\n\t\tcachemgr_ssess_set(sess);\n\t}\n\treturn 0;\n}\n\n/*\n * Called by OpenSSL when a src SSL session should be removed.\n * OpenSSL calls SSL_SESSION_free() after calling the callback;\n * we do not need to free the reference here.\n */\nstatic void\npxy_ossl_sessremove_cb(UNUSED SSL_CTX *sslctx, SSL_SESSION *sess)\n{\n#ifdef DEBUG_SESSION_CACHE\n\tlog_dbg_printf(\"===> OpenSSL remove session callback:\\n\");\n\tif (sess) {\n\t\tlog_dbg_print_free(ssl_session_to_str(sess));\n\t} else {\n\t\tlog_dbg_printf(\"(null)\\n\");\n\t}\n#endif /* DEBUG_SESSION_CACHE */\n\tif (sess) {\n\t\tcachemgr_ssess_del(sess);\n\t}\n}\n\n/*\n * Called by OpenSSL when a src SSL session is requested by the client.\n */\nstatic SSL_SESSION *\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20800000L)\npxy_ossl_sessget_cb(UNUSED SSL *ssl, unsigned char *id, int idlen,\n                    int *copy)\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\npxy_ossl_sessget_cb(UNUSED SSL *ssl, const unsigned char *id, int idlen,\n                    int *copy)\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n{\n\tSSL_SESSION *sess;\n\n#ifdef DEBUG_SESSION_CACHE\n\tlog_dbg_printf(\"===> OpenSSL get session callback:\\n\");\n#endif /* DEBUG_SESSION_CACHE */\n\n\t*copy = 0; /* SSL should not increment reference count of session */\n\tsess = cachemgr_ssess_get(id, idlen);\n\n#ifdef DEBUG_SESSION_CACHE\n\tif (sess) {\n\t\tlog_dbg_print_free(ssl_session_to_str(sess));\n\t}\n#endif /* DEBUG_SESSION_CACHE */\n\n\tlog_dbg_printf(\"SSL session cache: %s\\n\", sess ? \"HIT\" : \"MISS\");\n\treturn sess;\n}\n\n/*\n * Set SSL_CTX options that are the same for incoming and outgoing SSL_CTX.\n */\nstatic void\npxy_sslctx_setoptions(SSL_CTX *sslctx, pxy_conn_ctx_t *ctx)\n{\n\tSSL_CTX_set_options(sslctx, SSL_OP_ALL);\n#ifdef SSL_OP_TLS_ROLLBACK_BUG\n\tSSL_CTX_set_options(sslctx, SSL_OP_TLS_ROLLBACK_BUG);\n#endif /* SSL_OP_TLS_ROLLBACK_BUG */\n#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\n\tSSL_CTX_set_options(sslctx, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n#endif /* SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION */\n#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n\tSSL_CTX_set_options(sslctx, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS);\n#endif /* SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS */\n#ifdef SSL_OP_NO_TICKET\n\tSSL_CTX_set_options(sslctx, SSL_OP_NO_TICKET);\n#endif /* SSL_OP_NO_TICKET */\n\n#ifdef SSL_OP_NO_SSLv2\n#ifdef HAVE_SSLV2\n\tif (ctx->opts->no_ssl2) {\n#endif /* HAVE_SSLV2 */\n\t\tSSL_CTX_set_options(sslctx, SSL_OP_NO_SSLv2);\n#ifdef HAVE_SSLV2\n\t}\n#endif /* HAVE_SSLV2 */\n#endif /* !SSL_OP_NO_SSLv2 */\n#ifdef HAVE_SSLV3\n\tif (ctx->opts->no_ssl3) {\n\t\tSSL_CTX_set_options(sslctx, SSL_OP_NO_SSLv3);\n\t}\n#endif /* HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n\tif (ctx->opts->no_tls10) {\n\t\tSSL_CTX_set_options(sslctx, SSL_OP_NO_TLSv1);\n\t}\n#endif /* HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n\tif (ctx->opts->no_tls11) {\n\t\tSSL_CTX_set_options(sslctx, SSL_OP_NO_TLSv1_1);\n\t}\n#endif /* HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n\tif (ctx->opts->no_tls12) {\n\t\tSSL_CTX_set_options(sslctx, SSL_OP_NO_TLSv1_2);\n\t}\n#endif /* HAVE_TLSV12 */\n\n#ifdef SSL_OP_NO_COMPRESSION\n\tif (!ctx->opts->sslcomp) {\n\t\tSSL_CTX_set_options(sslctx, SSL_OP_NO_COMPRESSION);\n\t}\n#endif /* SSL_OP_NO_COMPRESSION */\n\n\tSSL_CTX_set_cipher_list(sslctx, ctx->opts->ciphers);\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n\t/*\n\t * For maximum interoperability, force the security level to 0, meaning\n\t * all algorithms are permitted.  If we don't set the security level,\n\t * the level is taken from OpenSSL system configuration or library\n\t * compile-time defaults.  Security levels above 0 will reject weak\n\t * algorithms and key sizes both locally at load time and when they are\n\t * encountered from peers we receive connections from or connect to.\n\t * Specifically, our prevous default RSA leaf key size of 1024 bits\n\t * was rejected by a security level of 2 or higher (issue #248).\n\t */\n\tSSL_CTX_set_security_level(sslctx, 0);\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n}\n\n/*\n * Create and set up a new SSL_CTX instance for terminating SSL.\n * Set up all the necessary callbacks, the certificate, the cert chain and key.\n */\nstatic SSL_CTX *\npxy_srcsslctx_create(pxy_conn_ctx_t *ctx, X509 *crt, STACK_OF(X509) *chain,\n                     EVP_PKEY *key)\n{\n\tSSL_CTX *sslctx = SSL_CTX_new(ctx->opts->sslmethod());\n\tif (!sslctx) {\n\t\tctx->enomem = 1;\n\t\treturn NULL;\n\t}\n\n\tpxy_sslctx_setoptions(sslctx, ctx);\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n\tif (ctx->opts->sslversion) {\n\t\tif (SSL_CTX_set_min_proto_version(sslctx, ctx->opts->sslversion) == 0 ||\n\t\t\tSSL_CTX_set_max_proto_version(sslctx, ctx->opts->sslversion) == 0) {\n\t\t\tSSL_CTX_free(sslctx);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\n\tSSL_CTX_sess_set_new_cb(sslctx, pxy_ossl_sessnew_cb);\n\tSSL_CTX_sess_set_remove_cb(sslctx, pxy_ossl_sessremove_cb);\n\tSSL_CTX_sess_set_get_cb(sslctx, pxy_ossl_sessget_cb);\n\tSSL_CTX_set_session_cache_mode(sslctx, SSL_SESS_CACHE_SERVER |\n\t                                       SSL_SESS_CACHE_NO_INTERNAL);\n#ifdef USE_SSL_SESSION_ID_CONTEXT\n\tSSL_CTX_set_session_id_context(sslctx, (void *)(&ssl_session_context),\n\t                                       sizeof(ssl_session_context));\n#endif /* USE_SSL_SESSION_ID_CONTEXT */\n#ifndef OPENSSL_NO_TLSEXT\n\tSSL_CTX_set_tlsext_servername_callback(sslctx, pxy_ossl_servername_cb);\n\tSSL_CTX_set_tlsext_servername_arg(sslctx, ctx);\n#endif /* !OPENSSL_NO_TLSEXT */\n#ifndef OPENSSL_NO_DH\n\tif (ctx->opts->dh) {\n\t\tSSL_CTX_set_tmp_dh(sslctx, ctx->opts->dh);\n\t} else {\n\t\tSSL_CTX_set_tmp_dh_callback(sslctx, ssl_tmp_dh_callback);\n\t}\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\tif (ctx->opts->ecdhcurve) {\n\t\tEC_KEY *ecdh = ssl_ec_by_name(ctx->opts->ecdhcurve);\n\t\tSSL_CTX_set_tmp_ecdh(sslctx, ecdh);\n\t\tEC_KEY_free(ecdh);\n\t} else {\n\t\tEC_KEY *ecdh = ssl_ec_by_name(NULL);\n\t\tSSL_CTX_set_tmp_ecdh(sslctx, ecdh);\n\t\tEC_KEY_free(ecdh);\n\t}\n#endif /* !OPENSSL_NO_ECDH */\n\tif (SSL_CTX_use_certificate(sslctx, crt) != 1) {\n\t\tlog_dbg_printf(\"loading src server certificate failed\\n\");\n\t\tSSL_CTX_free(sslctx);\n\t\treturn NULL;\n\t}\n\tif (SSL_CTX_use_PrivateKey(sslctx, key) != 1) {\n\t\tlog_dbg_printf(\"loading src server key failed\\n\");\n\t\tSSL_CTX_free(sslctx);\n\t\treturn NULL;\n\t}\n\tfor (int i = 0; i < sk_X509_num(chain); i++) {\n\t\tX509 *c = sk_X509_value(chain, i);\n\t\tssl_x509_refcount_inc(c); /* next call consumes a reference */\n\t\tSSL_CTX_add_extra_chain_cert(sslctx, c);\n\t}\n\n#ifdef DEBUG_SESSION_CACHE\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tint mode = SSL_CTX_get_session_cache_mode(sslctx);\n\t\tlog_dbg_printf(\"SSL session cache mode: %08x\\n\", mode);\n\t\tif (mode == SSL_SESS_CACHE_OFF)\n\t\t\tlog_dbg_printf(\"SSL_SESS_CACHE_OFF\\n\");\n\t\tif (mode & SSL_SESS_CACHE_CLIENT)\n\t\t\tlog_dbg_printf(\"SSL_SESS_CACHE_CLIENT\\n\");\n\t\tif (mode & SSL_SESS_CACHE_SERVER)\n\t\t\tlog_dbg_printf(\"SSL_SESS_CACHE_SERVER\\n\");\n\t\tif (mode & SSL_SESS_CACHE_NO_AUTO_CLEAR)\n\t\t\tlog_dbg_printf(\"SSL_SESS_CACHE_NO_AUTO_CLEAR\\n\");\n\t\tif (mode & SSL_SESS_CACHE_NO_INTERNAL_LOOKUP)\n\t\t\tlog_dbg_printf(\"SSL_SESS_CACHE_NO_INTERNAL_LOOKUP\\n\");\n\t\tif (mode & SSL_SESS_CACHE_NO_INTERNAL_STORE)\n\t\t\tlog_dbg_printf(\"SSL_SESS_CACHE_NO_INTERNAL_STORE\\n\");\n\t}\n#endif /* DEBUG_SESSION_CACHE */\n\n\treturn sslctx;\n}\n\nstatic int\npxy_srccert_write_to_gendir(pxy_conn_ctx_t *ctx, X509 *crt, int is_orig)\n{\n\tchar *fn;\n\tint rv;\n\n\tif (!ctx->origcrtfpr)\n\t\treturn -1;\n\tif (is_orig) {\n\t\trv = asprintf(&fn, \"%s/%s.crt\", ctx->opts->certgendir,\n\t\t              ctx->origcrtfpr);\n\t} else {\n\t\tif (!ctx->usedcrtfpr)\n\t\t\treturn -1;\n\t\trv = asprintf(&fn, \"%s/%s-%s.crt\", ctx->opts->certgendir,\n\t\t              ctx->origcrtfpr, ctx->usedcrtfpr);\n\t}\n\tif (rv == -1) {\n\t\tctx->enomem = 1;\n\t\treturn -1;\n\t}\n\trv = log_cert_submit(fn, crt);\n\tfree(fn);\n\treturn rv;\n}\n\nstatic void\npxy_srccert_write(pxy_conn_ctx_t *ctx)\n{\n\tif (ctx->opts->certgen_writeall || ctx->generated_cert) {\n\t\tif (pxy_srccert_write_to_gendir(ctx,\n\t\t                SSL_get_certificate(ctx->src.ssl), 0) == -1) {\n\t\t\tlog_err_printf(\"Failed to write used certificate\\n\");\n\t\t}\n\t}\n\tif (ctx->opts->certgen_writeall) {\n\t\tif (pxy_srccert_write_to_gendir(ctx, ctx->origcrt, 1) == -1) {\n\t\t\tlog_err_printf(\"Failed to write orig certificate\\n\");\n\t\t}\n\t}\n}\n\nstatic cert_t *\npxy_srccert_create(pxy_conn_ctx_t *ctx)\n{\n\tcert_t *cert = NULL;\n\n\tif (ctx->opts->leafcertdir) {\n\t\tif (ctx->sni) {\n\t\t\tcert = cachemgr_tgcrt_get(ctx->sni);\n\t\t\tif (!cert) {\n\t\t\t\tchar *wildcarded;\n\t\t\t\twildcarded = ssl_wildcardify(ctx->sni);\n\t\t\t\tif (!wildcarded) {\n\t\t\t\t\tctx->enomem = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tcert = cachemgr_tgcrt_get(wildcarded);\n\t\t\t\tfree(wildcarded);\n\t\t\t}\n\t\t\tif (cert && OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Target cert by SNI\\n\");\n\t\t\t}\n\t\t} else if (ctx->origcrt) {\n\t\t\tchar **names = ssl_x509_names(ctx->origcrt);\n\t\t\tfor (char **p = names; *p; p++) {\n\t\t\t\tif (!cert) {\n\t\t\t\t\tcert = cachemgr_tgcrt_get(*p);\n\t\t\t\t}\n\t\t\t\tif (!cert) {\n\t\t\t\t\tchar *wildcarded;\n\t\t\t\t\twildcarded = ssl_wildcardify(*p);\n\t\t\t\t\tif (!wildcarded) {\n\t\t\t\t\t\tctx->enomem = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* increases ref count */\n\t\t\t\t\t\tcert = cachemgr_tgcrt_get(\n\t\t\t\t\t\t       wildcarded);\n\t\t\t\t\t\tfree(wildcarded);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(*p);\n\t\t\t}\n\t\t\tfree(names);\n\t\t\tif (ctx->enomem) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (cert && OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Target cert by origcrt\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (cert) {\n\t\t\tctx->immutable_cert = 1;\n\t\t}\n\t}\n\n\tif (!cert && ctx->opts->defaultleafcert) {\n\t\tcert = ctx->opts->defaultleafcert;\n\t\tcert_refcount_inc(cert);\n\t\tctx->immutable_cert = 1;\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"Using default leaf certificate\\n\");\n\t\t}\n\t}\n\n\tif (!cert && ctx->origcrt && ctx->opts->leafkey) {\n\t\tcert = cert_new();\n\n\t\tcert->crt = cachemgr_fkcrt_get(ctx->origcrt);\n\t\tif (cert->crt) {\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Certificate cache: HIT\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Certificate cache: MISS\\n\");\n\t\t\t}\n\t\t\tcert->crt = ssl_x509_forge(ctx->opts->cacrt,\n\t\t\t                           ctx->opts->cakey,\n\t\t\t                           ctx->origcrt,\n\t\t\t                           ctx->opts->leafkey,\n\t\t\t                           NULL,\n\t\t\t                           ctx->opts->leafcrlurl);\n\t\t\tcachemgr_fkcrt_set(ctx->origcrt, cert->crt);\n\t\t}\n\t\tcert_set_key(cert, ctx->opts->leafkey);\n\t\tcert_set_chain(cert, ctx->opts->cachain);\n\t\tctx->generated_cert = 1;\n\t}\n\n\tif ((WANT_CONNECT_LOG(ctx) || ctx->opts->certgendir) && ctx->origcrt) {\n\t\tctx->origcrtfpr = ssl_x509_fingerprint(ctx->origcrt, 0);\n\t\tif (!ctx->origcrtfpr)\n\t\t\tctx->enomem = 1;\n\t}\n\tif ((WANT_CONNECT_LOG(ctx) || ctx->opts->certgen_writeall) &&\n\t    cert && cert->crt) {\n\t\tctx->usedcrtfpr = ssl_x509_fingerprint(cert->crt, 0);\n\t\tif (!ctx->usedcrtfpr)\n\t\t\tctx->enomem = 1;\n\t}\n\n\treturn cert;\n}\n\n/*\n * Create new SSL context for the incoming connection, based on the original\n * destination SSL certificate.\n * Returns NULL if no suitable certificate could be found.\n */\nstatic SSL *\npxy_srcssl_create(pxy_conn_ctx_t *ctx, SSL *origssl)\n{\n\tcert_t *cert;\n\n\tcachemgr_dsess_set((struct sockaddr*)&ctx->dstaddr,\n\t                   ctx->dstaddrlen, ctx->sni,\n\t                   SSL_get0_session(origssl));\n\n\tctx->origcrt = SSL_get_peer_certificate(origssl);\n\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tif (ctx->origcrt) {\n\t\t\tlog_dbg_printf(\"===> Original server certificate:\\n\");\n\t\t\tpxy_debug_crt(ctx->origcrt);\n\t\t} else {\n\t\t\tlog_dbg_printf(\"===> Original server has no cert!\\n\");\n\t\t}\n\t}\n\n\tcert = pxy_srccert_create(ctx);\n\tif (!cert)\n\t\treturn NULL;\n\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"===> Forged server certificate:\\n\");\n\t\tpxy_debug_crt(cert->crt);\n\t}\n\n\tif (WANT_CONNECT_LOG(ctx)) {\n\t\tctx->ssl_names = ssl_x509_names_to_str(ctx->origcrt ?\n\t\t                                       ctx->origcrt :\n\t\t                                       cert->crt);\n\t\tif (!ctx->ssl_names)\n\t\t\tctx->enomem = 1;\n\t}\n\n\tSSL_CTX *sslctx = pxy_srcsslctx_create(ctx, cert->crt, cert->chain,\n\t                                       cert->key);\n\tcert_free(cert);\n\tif (!sslctx)\n\t\treturn NULL;\n\tSSL *ssl = SSL_new(sslctx);\n\tSSL_CTX_free(sslctx); /* SSL_new() increments refcount */\n\tif (!ssl) {\n\t\tctx->enomem = 1;\n\t\treturn NULL;\n\t}\n#ifdef SSL_MODE_RELEASE_BUFFERS\n\t/* lower memory footprint for idle connections */\n\tSSL_set_mode(ssl, SSL_get_mode(ssl) | SSL_MODE_RELEASE_BUFFERS);\n#endif /* SSL_MODE_RELEASE_BUFFERS */\n\treturn ssl;\n}\n\n#ifndef OPENSSL_NO_TLSEXT\n/*\n * OpenSSL servername callback, called when OpenSSL receives a servername\n * TLS extension in the clientHello.  Must switch to a new SSL_CTX with\n * a different certificate if we want to replace the server cert here.\n * We generate a new certificate if the current one does not match the\n * supplied servername.  This should only happen if the original destination\n * server supplies a certificate which does not match the server name we\n * indicate to it.\n */\nstatic int\npxy_ossl_servername_cb(SSL *ssl, UNUSED int *al, void *arg)\n{\n\tpxy_conn_ctx_t *ctx = arg;\n\tconst char *sn;\n\tX509 *sslcrt;\n\n\tif (!(sn = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name)))\n\t\treturn SSL_TLSEXT_ERR_NOACK;\n\n\tif (!ctx->sni) {\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"Warning: SNI parser yielded no \"\n\t\t\t               \"hostname, copying OpenSSL one: \"\n\t\t\t               \"[NULL] != [%s]\\n\", sn);\n\t\t}\n\t\tctx->sni = strdup(sn);\n\t\tif (!ctx->sni) {\n\t\t\tctx->enomem = 1;\n\t\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t\t}\n\t}\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tif (!!strcmp(sn, ctx->sni)) {\n\t\t\t/*\n\t\t\t * This may happen if the client resumes a session, but\n\t\t\t * uses a different SNI hostname when resuming than it\n\t\t\t * used when the session was created.  OpenSSL\n\t\t\t * correctly ignores the SNI in the ClientHello in this\n\t\t\t * case, but since we have already sent the SNI onwards\n\t\t\t * to the original destination, there is no way back.\n\t\t\t * We log an error and hope this never happens.\n\t\t\t */\n\t\t\tlog_dbg_printf(\"Warning: SNI parser yielded different \"\n\t\t\t               \"hostname than OpenSSL callback for \"\n\t\t\t               \"the same ClientHello message: \"\n\t\t\t               \"[%s] != [%s]\\n\", ctx->sni, sn);\n\t\t}\n\t}\n\n\t/* generate a new certificate with sn as additional altSubjectName\n\t * and replace it both in the current SSL ctx and in the cert cache */\n\tif (ctx->opts->allow_wrong_host && !ctx->immutable_cert &&\n\t    !ssl_x509_names_match((sslcrt = SSL_get_certificate(ssl)), sn)) {\n\t\tX509 *newcrt;\n\t\tSSL_CTX *newsslctx;\n\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"Certificate cache: UPDATE \"\n\t\t\t               \"(SNI mismatch)\\n\");\n\t\t}\n\t\tnewcrt = ssl_x509_forge(ctx->opts->cacrt, ctx->opts->cakey,\n\t\t                        sslcrt, ctx->opts->leafkey,\n\t\t                        sn, ctx->opts->leafcrlurl);\n\t\tif (!newcrt) {\n\t\t\tctx->enomem = 1;\n\t\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t\t}\n\t\tcachemgr_fkcrt_set(ctx->origcrt, newcrt);\n\t\tctx->generated_cert = 1;\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"===> Updated forged server \"\n\t\t\t               \"certificate:\\n\");\n\t\t\tpxy_debug_crt(newcrt);\n\t\t}\n\t\tif (WANT_CONNECT_LOG(ctx)) {\n\t\t\tif (ctx->ssl_names) {\n\t\t\t\tfree(ctx->ssl_names);\n\t\t\t}\n\t\t\tctx->ssl_names = ssl_x509_names_to_str(newcrt);\n\t\t\tif (!ctx->ssl_names) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t}\n\t\t}\n\t\tif (WANT_CONNECT_LOG(ctx) || ctx->opts->certgendir) {\n\t\t\tif (ctx->usedcrtfpr) {\n\t\t\t\tfree(ctx->usedcrtfpr);\n\t\t\t}\n\t\t\tctx->usedcrtfpr = ssl_x509_fingerprint(newcrt, 0);\n\t\t\tif (!ctx->usedcrtfpr) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t}\n\t\t}\n\n\t\tnewsslctx = pxy_srcsslctx_create(ctx, newcrt,\n\t\t                                 ctx->opts->cachain,\n\t\t                                 ctx->opts->leafkey);\n\t\tif (!newsslctx) {\n\t\t\tX509_free(newcrt);\n\t\t\treturn SSL_TLSEXT_ERR_NOACK;\n\t\t}\n\t\tSSL_set_SSL_CTX(ssl, newsslctx); /* decr's old incr new refc */\n\t\tSSL_CTX_free(newsslctx);\n\t\tX509_free(newcrt);\n\t} else if (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Certificate cache: KEEP (SNI match or \"\n\t\t               \"target mode)\\n\");\n\t}\n\n\treturn SSL_TLSEXT_ERR_OK;\n}\n#endif /* !OPENSSL_NO_TLSEXT */\n\n/*\n * Create new SSL context for outgoing connections to the original destination.\n * If hostname sni is provided, use it for Server Name Indication.\n */\nstatic SSL *\npxy_dstssl_create(pxy_conn_ctx_t *ctx)\n{\n\tSSL_CTX *sslctx;\n\tSSL *ssl;\n\tSSL_SESSION *sess;\n\n\tsslctx = SSL_CTX_new(ctx->opts->sslmethod());\n\tif (!sslctx) {\n\t\tctx->enomem = 1;\n\t\treturn NULL;\n\t}\n\n\tpxy_sslctx_setoptions(sslctx, ctx);\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n\tif (ctx->opts->sslversion) {\n\t\tif (SSL_CTX_set_min_proto_version(sslctx, ctx->opts->sslversion) == 0 ||\n\t\t\tSSL_CTX_set_max_proto_version(sslctx, ctx->opts->sslversion) == 0) {\n\t\t\tSSL_CTX_free(sslctx);\n\t\t\treturn NULL;\n\t\t}\n\t}\n#endif /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\n\tif (ctx->opts->verify_peer) {\n\t\tSSL_CTX_set_verify(sslctx, SSL_VERIFY_PEER, NULL);\n\t\tSSL_CTX_set_default_verify_paths(sslctx);\n\t} else {\n\t\tSSL_CTX_set_verify(sslctx, SSL_VERIFY_NONE, NULL);\n\t}\n\n\tif (ctx->opts->clientcrt &&\n\t    (SSL_CTX_use_certificate(sslctx, ctx->opts->clientcrt) != 1)) {\n\t\tlog_dbg_printf(\"loading dst client certificate failed\\n\");\n\t\tSSL_CTX_free(sslctx);\n\t\treturn NULL;\n\t}\n\tif (ctx->opts->clientkey &&\n\t    (SSL_CTX_use_PrivateKey(sslctx, ctx->opts->clientkey) != 1)) {\n\t\tlog_dbg_printf(\"loading dst client key failed\\n\");\n\t\tSSL_CTX_free(sslctx);\n\t\treturn NULL;\n\t}\n\n\tssl = SSL_new(sslctx);\n\tSSL_CTX_free(sslctx); /* SSL_new() increments refcount */\n\tif (!ssl) {\n\t\tctx->enomem = 1;\n\t\treturn NULL;\n\t}\n#ifndef OPENSSL_NO_TLSEXT\n\tif (ctx->sni) {\n\t\tSSL_set_tlsext_host_name(ssl, ctx->sni);\n\t}\n#endif /* !OPENSSL_NO_TLSEXT */\n\n#ifdef SSL_MODE_RELEASE_BUFFERS\n\t/* lower memory footprint for idle connections */\n\tSSL_set_mode(ssl, SSL_get_mode(ssl) | SSL_MODE_RELEASE_BUFFERS);\n#endif /* SSL_MODE_RELEASE_BUFFERS */\n\n\t/* session resuming based on remote endpoint address and port */\n\tsess = cachemgr_dsess_get((struct sockaddr *)&ctx->dstaddr,\n\t                          ctx->dstaddrlen, ctx->sni);\n\tif (sess) {\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"Attempt reuse dst SSL session\\n\");\n\t\t}\n\t\tSSL_set_session(ssl, sess); /* increments sess refcount */\n\t\tSSL_SESSION_free(sess);\n\t}\n\n\treturn ssl;\n}\n\n/*\n * Free bufferenvent and close underlying socket properly.\n * For OpenSSL bufferevents, this will shutdown the SSL connection.\n */\nstatic void\nbufferevent_free_and_close_fd(struct bufferevent *bev, pxy_conn_ctx_t *ctx)\n{\n\tstruct bufferevent *ubev;\n\tevutil_socket_t fd;\n\tSSL *ssl;\n\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"            %p free_and_close_fd\\n\",\n\t\t               (void*)bev);\n\t}\n#endif /* DEBUG_PROXY */\n\n\tubev = bufferevent_get_underlying(bev);\n\tssl = bufferevent_openssl_get_ssl(bev); /* does not inc refc */\n\n\tif (ubev) {\n\t\tfd = bufferevent_getfd(ubev);\n\t} else {\n\t\tfd = bufferevent_getfd(bev);\n\t}\n\tbufferevent_setcb(bev, NULL, NULL, NULL, NULL);\n\n\tif (ssl) {\n\t\t/*\n\t\t * From the libevent book:  SSL_RECEIVED_SHUTDOWN tells\n\t\t * SSL_shutdown to act as if we had already received a close\n\t\t * notify from the other end.  SSL_shutdown will then send the\n\t\t * final close notify in reply.  The other end will receive the\n\t\t * close notify and send theirs.  By this time, we will have\n\t\t * already closed the socket and the other end's real close\n\t\t * notify will never be received.  In effect, both sides will\n\t\t * think that they have completed a clean shutdown and keep\n\t\t * their sessions valid.  This strategy will fail if the socket\n\t\t * is not ready for writing, in which case this hack will lead\n\t\t * to an unclean shutdown and lost session on the other end.\n\t\t *\n\t\t * Note that in the case of autossl, the SSL object operates on\n\t\t * a BIO wrapper around the underlying bufferevent.\n\t\t */\n\t\tSSL_set_shutdown(ssl, SSL_RECEIVED_SHUTDOWN);\n\t\tSSL_shutdown(ssl);\n\t}\n\n\tbufferevent_disable(bev, EV_READ|EV_WRITE);\n\tif (ubev) {\n\t\tbufferevent_disable(ubev, EV_READ|EV_WRITE);\n\t\tbufferevent_setfd(ubev, -1);\n\t\tbufferevent_setcb(ubev, NULL, NULL, NULL, NULL);\n\t\tbufferevent_free(ubev);\n\t}\n\tbufferevent_free(bev);\n\tif (ssl) {\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"SSL_free() in state \");\n\t\t\tlog_dbg_print_free(ssl_ssl_state_to_str(ssl));\n\t\t\tlog_dbg_printf(\"\\n\");\n\t\t}\n\t\tSSL_free(ssl);\n\t}\n\t/* bufferevent_getfd() returns -1 if no file descriptor is associated\n\t * with the bufferevent */\n\tif (fd >= 0)\n\t\tevutil_closesocket(fd);\n}\n\n/*\n * Set up a bufferevent structure for either a dst or src connection,\n * optionally with or without SSL.  Sets all callbacks, enables read\n * and write events, but does not call bufferevent_socket_connect().\n *\n * For dst connections, pass -1 as fd.  Pass a pointer to an initialized\n * SSL struct as ssl if the connection should use SSL.\n *\n * Returns pointer to initialized bufferevent structure, as returned\n * by bufferevent_socket_new() or bufferevent_openssl_socket_new().\n */\nstatic struct bufferevent *\npxy_bufferevent_setup(pxy_conn_ctx_t *ctx, evutil_socket_t fd, SSL *ssl)\n{\n\tstruct bufferevent *bev;\n\n\tif (ssl) {\n\t\tbev = bufferevent_openssl_socket_new(ctx->evbase, fd, ssl,\n\t\t\t\t((fd == -1) ? BUFFEREVENT_SSL_CONNECTING\n\t\t\t\t           : BUFFEREVENT_SSL_ACCEPTING),\n\t\t\t\tBEV_OPT_DEFER_CALLBACKS);\n\t} else {\n\t\tbev = bufferevent_socket_new(ctx->evbase, fd,\n\t\t\t\tBEV_OPT_DEFER_CALLBACKS);\n\t}\n\tif (!bev) {\n\t\tlog_err_printf(\"Error creating bufferevent socket\\n\");\n\t\treturn NULL;\n\t}\n\tif (ssl) {\n\t\tbufferevent_openssl_set_allow_dirty_shutdown(bev, 1);\n\t}\n\tbufferevent_setcb(bev, pxy_bev_readcb, pxy_bev_writecb,\n\t                  pxy_bev_eventcb, ctx);\n\tbufferevent_enable(bev, EV_READ|EV_WRITE);\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"            %p pxy_bufferevent_setup\\n\",\n\t\t               (void*)bev);\n\t}\n#endif /* DEBUG_PROXY */\n\treturn bev;\n}\n\n/*\n * Filter a single line of HTTP request headers.\n * Also fills in some context fields for logging.\n *\n * Returns NULL if the current line should be deleted from the request.\n * Returns a newly allocated string if the current line should be replaced.\n * Returns `line' if the line should be kept.\n */\nstatic char *\npxy_http_reqhdr_filter_line(const char *line, pxy_conn_ctx_t *ctx)\n{\n\t/* parse information for connect log */\n\tif (!ctx->http_method) {\n\t\t/* first line */\n\t\tchar *space1, *space2;\n\n\t\tspace1 = strchr(line, ' ');\n\t\tspace2 = space1 ? strchr(space1 + 1, ' ') : NULL;\n\t\tif (!space1) {\n\t\t\t/* not HTTP */\n\t\t\tctx->seen_req_header = 1;\n\t\t} else {\n\t\t\tctx->http_method = malloc(space1 - line + 1);\n\t\t\tif (ctx->http_method) {\n\t\t\t\tmemcpy(ctx->http_method, line, space1 - line);\n\t\t\t\tctx->http_method[space1 - line] = '\\0';\n\t\t\t} else {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tspace1++;\n\t\t\tif (!space2) {\n\t\t\t\t/* HTTP/0.9 */\n\t\t\t\tctx->seen_req_header = 1;\n\t\t\t\tspace2 = space1 + strlen(space1);\n\t\t\t}\n\t\t\tctx->http_uri = malloc(space2 - space1 + 1);\n\t\t\tif (ctx->http_uri) {\n\t\t\t\tmemcpy(ctx->http_uri, space1, space2 - space1);\n\t\t\t\tctx->http_uri[space2 - space1] = '\\0';\n\t\t\t} else {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* not first line */\n\t\tchar *newhdr;\n\n\t\tif (!ctx->http_host && !strncasecmp(line, \"Host:\", 5)) {\n\t\t\tctx->http_host = strdup(util_skipws(line + 5));\n\t\t\tif (!ctx->http_host) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (!strncasecmp(line, \"Content-Type:\", 13)) {\n\t\t\tctx->http_content_type = strdup(util_skipws(line + 13));\n\t\t\tif (!ctx->http_content_type) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t/* Override Connection: keepalive and Connection: upgrade */\n\t\t} else if (!strncasecmp(line, \"Connection:\", 11)) {\n\t\t\tctx->sent_http_conn_close = 1;\n\t\t\tif (!(newhdr = strdup(\"Connection: close\"))) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn newhdr;\n\t\t/* Suppress upgrading to SSL/TLS, WebSockets or HTTP/2,\n\t\t * unsupported encodings, and keep-alive */\n\t\t} else if (!strncasecmp(line, \"Upgrade:\", 8) ||\n\t\t           !strncasecmp(line, \"Accept-Encoding:\", 16) ||\n\t\t           !strncasecmp(line, \"Keep-Alive:\", 11)) {\n\t\t\treturn NULL;\n\t\t} else if (line[0] == '\\0') {\n\t\t\tctx->seen_req_header = 1;\n\t\t\tif (!ctx->sent_http_conn_close) {\n\t\t\t\tnewhdr = strdup(\"Connection: close\\r\\n\");\n\t\t\t\tif (!newhdr) {\n\t\t\t\t\tctx->enomem = 1;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\treturn newhdr;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (char*)line;\n}\n\n/*\n * Filter a single line of HTTP response headers.\n *\n * Returns NULL if the current line should be deleted from the response.\n * Returns a newly allocated string if the current line should be replaced.\n * Returns `line' if the line should be kept.\n */\nstatic char *\npxy_http_resphdr_filter_line(const char *line, pxy_conn_ctx_t *ctx)\n{\n\t/* parse information for connect log */\n\tif (!ctx->http_status_code) {\n\t\t/* first line */\n\t\tchar *space1, *space2;\n\n\t\tspace1 = strchr(line, ' ');\n\t\tspace2 = space1 ? strchr(space1 + 1, ' ') : NULL;\n\t\tif (!space1 || !!strncmp(line, \"HTTP\", 4)) {\n\t\t\t/* not HTTP or HTTP/0.9 */\n\t\t\tctx->seen_resp_header = 1;\n\t\t} else {\n\t\t\tsize_t len_code, len_text;\n\n\t\t\tif (space2) {\n\t\t\t\tlen_code = space2 - space1 - 1;\n\t\t\t\tlen_text = strlen(space2 + 1);\n\t\t\t} else {\n\t\t\t\tlen_code = strlen(space1 + 1);\n\t\t\t\tlen_text = 0;\n\t\t\t}\n\t\t\tctx->http_status_code = malloc(len_code + 1);\n\t\t\tctx->http_status_text = malloc(len_text + 1);\n\t\t\tif (!ctx->http_status_code || !ctx->http_status_text) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(ctx->http_status_code, space1 + 1, len_code);\n\t\t\tctx->http_status_code[len_code] = '\\0';\n\t\t\tif (space2) {\n\t\t\t\tmemcpy(ctx->http_status_text,\n\t\t\t\t       space2 + 1, len_text);\n\t\t\t}\n\t\t\tctx->http_status_text[len_text] = '\\0';\n\t\t}\n\t} else {\n\t\t/* not first line */\n\t\tif (!ctx->http_content_length &&\n\t\t    !strncasecmp(line, \"Content-Length:\", 15)) {\n\t\t\tctx->http_content_length =\n\t\t\t\tstrdup(util_skipws(line + 15));\n\t\t\tif (!ctx->http_content_length) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else if (\n\t\t    /* HPKP: Public Key Pinning Extension for HTTP\n\t\t     * (draft-ietf-websec-key-pinning)\n\t\t     * remove to prevent public key pinning */\n\t\t    !strncasecmp(line, \"Public-Key-Pins:\", 16) ||\n\t\t    !strncasecmp(line, \"Public-Key-Pins-Report-Only:\", 28) ||\n\t\t    /* HSTS: HTTP Strict Transport Security (RFC 6797)\n\t\t     * remove to allow users to accept bad certs */\n\t\t    !strncasecmp(line, \"Strict-Transport-Security:\", 26) ||\n\t\t    /* Expect-CT: Expect Certificate Transparency\n\t\t     * (draft-ietf-httpbis-expect-ct-latest)\n\t\t     * remove to prevent failed CT log lookups */\n\t\t    !strncasecmp(line, \"Expect-CT:\", 10) ||\n\t\t    /* Alternate Protocol\n\t\t     * remove to prevent switching to QUIC, SPDY et al */\n\t\t    !strncasecmp(line, \"Alternate-Protocol:\", 19) ||\n\t\t    /* Upgrade header\n\t\t     * remove to prevent upgrading to HTTPS in unhandled ways,\n\t\t     * and more importantly, WebSockets and HTTP/2 */\n\t\t    !strncasecmp(line, \"Upgrade:\", 8)) {\n\t\t\treturn NULL;\n\t\t} else if (line[0] == '\\0') {\n\t\t\tctx->seen_resp_header = 1;\n\t\t}\n\t}\n\n\treturn (char*)line;\n}\n\n/*\n * Return 1 if uri is an OCSP GET URI, 0 if not.\n */\nstatic int\npxy_ocsp_is_valid_uri(const char *uri, pxy_conn_ctx_t *ctx)\n{\n\tchar *buf_url;\n\tsize_t sz_url;\n\tchar *buf_b64;\n\tsize_t sz_b64;\n\tunsigned char *buf_asn1;\n\tsize_t sz_asn1;\n\tint ret;\n\n\tbuf_url = strrchr(uri, '/');\n\tif (!buf_url)\n\t\treturn 0;\n\tbuf_url++;\n\n\t/*\n\t * Do some quick checks to avoid unnecessary buffer allocations and\n\t * decoding URL, Base64 and ASN.1:\n\t * -   OCSP requests begin with a SEQUENCE (0x30), so the first Base64\n\t *     byte is 'M' or, unlikely but legal, the URL encoding thereof.\n\t * -   There should be no query string in OCSP GET requests.\n\t * -   Encoded OCSP request ASN.1 blobs are longer than 32 bytes.\n\t */\n\tif (buf_url[0] != 'M' && buf_url[0] != '%')\n\t\treturn 0;\n\tif (strchr(uri, '?'))\n\t\treturn 0;\n\tsz_url = strlen(buf_url);\n\tif (sz_url < 32)\n\t\treturn 0;\n\tbuf_b64 = url_dec(buf_url, sz_url, &sz_b64);\n\tif (!buf_b64) {\n\t\tctx->enomem = 1;\n\t\treturn 0;\n\t}\n\tbuf_asn1 = base64_dec(buf_b64, sz_b64, &sz_asn1);\n\tif (!buf_asn1) {\n\t\tctx->enomem = 1;\n\t\tfree(buf_b64);\n\t\treturn 0;\n\t}\n\tret = ssl_is_ocspreq(buf_asn1, sz_asn1);\n\tfree(buf_asn1);\n\tfree(buf_b64);\n\treturn ret;\n}\n\n/*\n * Called after a request header was completely read.\n * If the request is an OCSP request, deny the request by sending an\n * OCSP response of type tryLater and close the connection to the server.\n *\n * Reference:\n * RFC 2560: X.509 Internet PKI Online Certificate Status Protocol (OCSP)\n */\nstatic void\npxy_ocsp_deny(pxy_conn_ctx_t *ctx)\n{\n\tstruct evbuffer *inbuf, *outbuf;\n\tstatic const char ocspresp[] =\n\t\t\"HTTP/1.0 200 OK\\r\\n\"\n\t\t\"Content-Type: application/ocsp-response\\r\\n\"\n\t\t\"Content-Length: 5\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"\\x30\\x03\"      /* OCSPResponse: SEQUENCE */\n\t\t\"\\x0a\\x01\"      /* OCSPResponseStatus: ENUMERATED */\n\t\t\"\\x03\";         /* tryLater (3) */\n\n\tif (!ctx->http_method)\n\t\treturn;\n\tif (!strncasecmp(ctx->http_method, \"GET\", 3) &&\n\t    pxy_ocsp_is_valid_uri(ctx->http_uri, ctx))\n\t\tgoto deny;\n\tif (!strncasecmp(ctx->http_method, \"POST\", 4) &&\n\t    ctx->http_content_type &&\n\t    !strncasecmp(ctx->http_content_type,\n\t                 \"application/ocsp-request\", 24))\n\t\tgoto deny;\n\treturn;\n\ndeny:\n\tinbuf = bufferevent_get_input(ctx->src.bev);\n\toutbuf = bufferevent_get_output(ctx->src.bev);\n\n\tif (evbuffer_get_length(inbuf) > 0) {\n\t\tif (WANT_CONTENT_LOG(ctx)) {\n\t\t\tlogbuf_t *lb;\n\t\t\tlb = logbuf_new_alloc(evbuffer_get_length(inbuf), NULL);\n\t\t\tif (lb &&\n\t\t\t    (evbuffer_copyout(inbuf, lb->buf, lb->sz) != -1)) {\n\t\t\t\tsubmit_content_logbuf_free(ctx, lb, 1/*req*/);\n\t\t\t}\n\t\t}\n\t\tevbuffer_drain(inbuf, evbuffer_get_length(inbuf));\n\t}\n\n\tstruct bufferevent *ubev = bufferevent_get_underlying(ctx->src.bev);\n\tif (ubev) {\n\t\tstruct evbuffer *ubev_inbuf = bufferevent_get_input(ubev);\n\t\tsize_t ubev_inbuf_size = evbuffer_get_length(ubev_inbuf);\n\t\tif (ubev_inbuf_size)\n\t\t\tevbuffer_drain(ubev_inbuf, ubev_inbuf_size);\n\t}\n\n\tbufferevent_free_and_close_fd(ctx->dst.bev, ctx);\n\tctx->dst.bev = NULL;\n\tctx->dst.closed = 1;\n\tevbuffer_add_printf(outbuf, ocspresp);\n\tctx->ocsp_denied = 1;\n\tif (WANT_CONTENT_LOG(ctx)) {\n\t\tlogbuf_t *lb;\n\t\tlb = logbuf_new_copy(ocspresp, sizeof(ocspresp) - 1, NULL);\n\t\tsubmit_content_logbuf_free(ctx, lb, 0/*resp*/);\n\t}\n}\n\n/*\n * Peek into pending data to see if it is an SSL/TLS ClientHello, and if so,\n * upgrade the connection from plain TCP to SSL/TLS.\n *\n * Return 1 if ClientHello was found and connection was upgraded to SSL/TLS,\n * 0 otherwise.\n *\n * WARNING: This is experimental code and will need to be improved.\n *\n * TODO - enable search and skip bytes before ClientHello in case it does not\n *        start at offset 0 (i.e. chello > vec_out[0].iov_base)\n * TODO - peek into more than just the current segment\n * TODO - add retry mechanism for short truncated ClientHello, possibly generic\n */\nint\npxy_conn_autossl_peek_and_upgrade(pxy_conn_ctx_t *ctx)\n{\n\tstruct evbuffer *inbuf;\n\tstruct evbuffer_iovec vec_out[1];\n\tconst unsigned char *chello;\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"Checking for a client hello\\n\");\n\t}\n\t/* peek the buffer */\n\tinbuf = bufferevent_get_input(ctx->src.bev);\n\tif (evbuffer_peek(inbuf, 1024, 0, vec_out, 1)) {\n\t\tif (ssl_tls_clienthello_parse(vec_out[0].iov_base,\n\t\t                              vec_out[0].iov_len,\n\t\t                              0, &chello, &ctx->sni) == 0) {\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Peek found ClientHello\\n\");\n\t\t\t}\n\t\t\tctx->dst.ssl = pxy_dstssl_create(ctx);\n\t\t\tif (!ctx->dst.ssl) {\n\t\t\t\tlog_err_printf(\"Error creating SSL for \"\n\t\t\t\t               \"upgrade\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tctx->dst.bev = bufferevent_openssl_filter_new(\n\t\t\t               ctx->evbase, ctx->dst.bev, ctx->dst.ssl,\n\t\t\t               BUFFEREVENT_SSL_CONNECTING,\n\t\t\t               BEV_OPT_DEFER_CALLBACKS);\n\t\t\tif (!ctx->dst.bev) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbufferevent_openssl_set_allow_dirty_shutdown(\n\t\t\t                                      ctx->dst.bev, 1);\n\t\t\tbufferevent_setcb(ctx->dst.bev, pxy_bev_readcb,\n\t\t\t                  pxy_bev_writecb, pxy_bev_eventcb,\n\t\t\t                  ctx);\n\t\t\tbufferevent_enable(ctx->dst.bev, EV_READ|EV_WRITE);\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_err_printf(\"Replaced dst bufferevent, new \"\n\t\t\t\t               \"one is %p\\n\",\n\t\t\t\t               (void*)ctx->dst.bev);\n\t\t\t}\n\t\t\tctx->clienthello_search = 0;\n\t\t\tctx->clienthello_found = 1;\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Peek found no ClientHello\\n\");\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void\npxy_conn_terminate_free(pxy_conn_ctx_t *ctx, int is_requestor)\n{\n\tlog_err_printf(\"Terminating connection%s!\\n\",\n\t               ctx->enomem ? \" (out of memory)\" : \"\");\n\tif (ctx->dst.bev && !ctx->dst.closed) {\n\t\tbufferevent_free_and_close_fd(ctx->dst.bev, ctx);\n\t\tctx->dst.bev = NULL;\n\t}\n\tif (ctx->src.bev && !ctx->src.closed) {\n\t\tbufferevent_free_and_close_fd(ctx->src.bev, ctx);\n\t\tctx->src.bev = NULL;\n\t}\n\tpxy_conn_ctx_free(ctx, is_requestor);\n}\n\n/*\n * Callback for read events on the up- and downstream connection bufferevents.\n * Called when there is data ready in the input evbuffer.\n */\nstatic void\npxy_bev_readcb(struct bufferevent *bev, void *arg)\n{\n\tpxy_conn_ctx_t *ctx = arg;\n\tpxy_conn_desc_t *other = (bev==ctx->src.bev) ? &ctx->dst : &ctx->src;\n\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"%p %p %s readcb\\n\", arg, (void*)bev,\n\t\t               (bev == ctx->src.bev) ? \"src\" : \"dst\");\n\t}\n#endif /* DEBUG_PROXY */\n\n\tif (!ctx->connected) {\n\t\tlog_err_printf(\"readcb called when other end not connected - \"\n\t\t               \"aborting.\\n\");\n\t\tlog_exceptcb();\n\t\treturn;\n\t}\n\n\tif (ctx->clienthello_search) {\n\t\tif (pxy_conn_autossl_peek_and_upgrade(ctx)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct evbuffer *inbuf = bufferevent_get_input(bev);\n\tif (other->closed) {\n\t\tlog_dbg_printf(\"Warning: Drained %zu bytes (conn closed)\\n\",\n\t\t               evbuffer_get_length(inbuf));\n\t\tevbuffer_drain(inbuf, evbuffer_get_length(inbuf));\n\n\t\tstruct bufferevent *ubev = bufferevent_get_underlying(bev);\n\t\tif (ubev) {\n\t\t\tstruct evbuffer *ubev_inbuf = bufferevent_get_input(ubev);\n\t\t\tlog_dbg_printf(\"Warning: Drained %zu bytes underlying (conn closed)\\n\",\n\t\t\t\t\t\t   evbuffer_get_length(ubev_inbuf));\n\t\t\tevbuffer_drain(ubev_inbuf, evbuffer_get_length(ubev_inbuf));\n\t\t}\n\t\treturn;\n\t}\n\n\tstruct evbuffer *outbuf = bufferevent_get_output(other->bev);\n\n\t/* request header munging */\n\tif (ctx->spec->http && !ctx->seen_req_header && (bev == ctx->src.bev)\n\t    && !ctx->passthrough) {\n\t\tlogbuf_t *lb = NULL, *tail = NULL;\n\t\tchar *line;\n\t\twhile ((line = evbuffer_readln(inbuf, NULL,\n\t\t                               EVBUFFER_EOL_CRLF))) {\n\t\t\tchar *replace;\n\t\t\tif (WANT_CONTENT_LOG(ctx)) {\n\t\t\t\tadd_line_to_content_log(line, &lb, &tail);\n\t\t\t}\n\t\t\treplace = pxy_http_reqhdr_filter_line(line, ctx);\n\t\t\tif (replace != line) {\n\t\t\t\tfree(line);\n\t\t\t}\n\t\t\tif (replace) {\n\t\t\t\tevbuffer_add_printf(outbuf, \"%s\\r\\n\", replace);\n\t\t\t\tfree(replace);\n\t\t\t}\n\t\t\tif (ctx->seen_req_header) {\n\t\t\t\t/* request header complete */\n\t\t\t\tif (ctx->opts->deny_ocsp) {\n\t\t\t\t\tpxy_ocsp_deny(ctx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (WANT_CONTENT_LOG(ctx)) {\n\t\t\tsubmit_content_logbuf_free(ctx, lb, 1/*req*/);\n\t\t}\n\t\tif (!ctx->seen_req_header)\n\t\t\treturn;\n\t} else\n\t/* response header munging */\n\tif (ctx->spec->http && !ctx->seen_resp_header && (bev == ctx->dst.bev)\n\t    && !ctx->passthrough) {\n\t\tlogbuf_t *lb = NULL, *tail = NULL;\n\t\tchar *line;\n\t\twhile ((line = evbuffer_readln(inbuf, NULL,\n\t\t                               EVBUFFER_EOL_CRLF))) {\n\t\t\tchar *replace;\n\t\t\tif (WANT_CONTENT_LOG(ctx)) {\n\t\t\t\tadd_line_to_content_log(line, &lb, &tail);\n\t\t\t}\n\t\t\treplace = pxy_http_resphdr_filter_line(line, ctx);\n\t\t\tif (replace == line) {\n\t\t\t\tevbuffer_add_printf(outbuf, \"%s\\r\\n\", line);\n\t\t\t} else if (replace) {\n\t\t\t\tevbuffer_add_printf(outbuf, \"%s\\r\\n\", replace);\n\t\t\t\tfree(replace);\n\t\t\t}\n\t\t\tfree(line);\n\t\t\tif (ctx->seen_resp_header) {\n\t\t\t\t/* response header complete: log connection */\n\t\t\t\tif (WANT_CONNECT_LOG(ctx)) {\n\t\t\t\t\tpxy_log_connect_http(ctx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (WANT_CONTENT_LOG(ctx)) {\n\t\t\tsubmit_content_logbuf_free(ctx, lb, 0/*resp*/);\n\t\t}\n\t\tif (!ctx->seen_resp_header)\n\t\t\treturn;\n\t}\n\n\t/* out of memory condition? */\n\tif (ctx->enomem) {\n\t\tpxy_conn_terminate_free(ctx, (bev == ctx->src.bev));\n\t\treturn;\n\t}\n\n\t/* no data left after parsing headers? */\n\tif (evbuffer_get_length(inbuf) == 0)\n\t\treturn;\n\n\tif (WANT_CONTENT_LOG(ctx)) {\n\t\tlogbuf_t *lb;\n\t\tlb = logbuf_new_alloc(evbuffer_get_length(inbuf), NULL);\n\t\tif (lb && (evbuffer_copyout(inbuf, lb->buf, lb->sz) != -1)) {\n\t\t\tsubmit_content_logbuf_free(ctx, lb, (bev == ctx->src.bev));\n\t\t}\n\t}\n\tevbuffer_add_buffer(outbuf, inbuf);\n\n\tstruct bufferevent *ubev_other = bufferevent_get_underlying(other->bev);\n\tif (evbuffer_get_length(outbuf) >= OUTBUF_LIMIT ||\n\t\t\t(ubev_other && evbuffer_get_length(bufferevent_get_output(ubev_other)) >= OUTBUF_LIMIT)) {\n\t\t/* temporarily disable data source;\n\t\t * set an appropriate watermark. */\n\t\tbufferevent_setwatermark(other->bev, EV_WRITE,\n\t\t\t\tOUTBUF_LIMIT/2, OUTBUF_LIMIT);\n\t\tbufferevent_disable(bev, EV_READ);\n\n\t\t/* The watermark for ubev_other may be already set, see writecb,\n\t\t * but getting is equally expensive as setting */\n\t\tif (ubev_other)\n\t\t\tbufferevent_setwatermark(ubev_other, EV_WRITE, OUTBUF_LIMIT/2, OUTBUF_LIMIT);\n\t}\n}\n\n/*\n * Callback for write events on the up- and downstream connection bufferevents.\n * Called when either all data from the output evbuffer has been written,\n * or if the outbuf is only half full again after having been full.\n */\nstatic void\npxy_bev_writecb(struct bufferevent *bev, void *arg)\n{\n\tpxy_conn_ctx_t *ctx = arg;\n\tpxy_conn_desc_t *other = (bev==ctx->src.bev) ? &ctx->dst : &ctx->src;\n\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"%p %p %s writecb\\n\", arg, (void*)bev,\n\t\t               (bev == ctx->src.bev) ? \"src\" : \"dst\");\n\t}\n#endif /* DEBUG_PROXY */\n\n\tif (other->closed) {\n\t\tstruct evbuffer *outbuf = bufferevent_get_output(bev);\n\t\tstruct bufferevent *ubev = bufferevent_get_underlying(bev);\n\t\tif (evbuffer_get_length(outbuf) == 0 &&\n\t\t\t\t(!ubev || evbuffer_get_length(bufferevent_get_output(ubev)) == 0)) {\n\t\t\t/* finished writing and other end is closed;\n\t\t\t * close this end too and clean up memory */\n\t\t\tbufferevent_free_and_close_fd(bev, ctx);\n\t\t\tpxy_conn_ctx_free(ctx, (bev == ctx->dst.bev));\n\t\t}\n\t\treturn;\n\t}\n\n\tif (other->bev && !(bufferevent_get_enabled(other->bev) & EV_READ)) {\n\t\t/* data source temporarily disabled;\n\t\t * re-enable and reset watermark to 0. */\n\t\tbufferevent_setwatermark(bev, EV_WRITE, 0, 0);\n\t\tbufferevent_enable(other->bev, EV_READ);\n\n\t\t/* Do not reset the watermark for ubev without checking its buf len,\n\t\t * because the current write event may be due to the buf len of bev\n\t\t * falling below OUTBUF_LIMIT/2, not that of ubev */\n\t\tstruct bufferevent *ubev = bufferevent_get_underlying(bev);\n\t\tif (ubev && evbuffer_get_length(bufferevent_get_output(ubev)) < OUTBUF_LIMIT/2)\n\t\t\tbufferevent_setwatermark(ubev, EV_WRITE, 0, 0);\n\t}\n}\n\n/*\n * Callback for meta events on the up- and downstream connection bufferevents.\n * Called when EOF has been reached, a connection has been made, and on errors.\n */\nstatic void\npxy_bev_eventcb(struct bufferevent *bev, short events, void *arg)\n{\n\tpxy_conn_ctx_t *ctx = arg;\n\tpxy_conn_desc_t *this = (bev==ctx->src.bev) ? &ctx->src : &ctx->dst;\n\tpxy_conn_desc_t *other = (bev==ctx->src.bev) ? &ctx->dst : &ctx->src;\n\tint is_requestor = (bev == ctx->src.bev);\n\n#ifdef DEBUG_PROXY\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"%p %p eventcb %s %s%s%s%s\\n\", arg, (void*)bev,\n\t\t               (bev == ctx->src.bev) ? \"src\" : \"dst\",\n\t\t               events & BEV_EVENT_CONNECTED ? \"connected\" : \"\",\n\t\t               events & BEV_EVENT_ERROR ? \"error\" : \"\",\n\t\t               events & BEV_EVENT_TIMEOUT ? \"timeout\" : \"\",\n\t\t               events & BEV_EVENT_EOF ? \"eof\" : \"\");\n\t}\n#endif /* DEBUG_PROXY */\n\n\tif (events & BEV_EVENT_CONNECTED) {\n\t\tif (bev != ctx->dst.bev) {\n#ifdef DEBUG_PROXY\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"src buffer event connected: \"\n\t\t\t\t               \"ignoring event\\n\");\n\t\t\t}\n#endif /* DEBUG_PROXY */\n\t\t\tgoto connected;\n\t\t}\n\n\t\t/* dst has connected */\n\t\tctx->connected = 1;\n\n\t\t/* wrap client-side socket in an eventbuffer */\n\t\tif ((ctx->spec->ssl || ctx->clienthello_found) &&\n\t\t    !ctx->passthrough) {\n\t\t\tctx->src.ssl = pxy_srcssl_create(ctx, this->ssl);\n\t\t\tif (!ctx->src.ssl) {\n\t\t\t\tbufferevent_free_and_close_fd(bev, ctx);\n\t\t\t\tctx->dst.bev = NULL;\n\t\t\t\tctx->dst.ssl = NULL;\n\t\t\t\tif (ctx->opts->passthrough && !ctx->enomem) {\n\t\t\t\t\tctx->passthrough = 1;\n\t\t\t\t\tctx->connected = 0;\n\t\t\t\t\tlog_dbg_printf(\"No cert found; \"\n\t\t\t\t\t               \"falling back \"\n\t\t\t\t\t               \"to passthrough\\n\");\n\t\t\t\t\tpxy_fd_readcb(ctx->fd, 0, ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tevutil_closesocket(ctx->fd);\n\t\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (ctx->clienthello_found) {\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Completing autossl upgrade\\n\");\n\t\t\t}\n\t\t\tctx->src.bev = bufferevent_openssl_filter_new(\n\t\t\t               ctx->evbase, ctx->src.bev, ctx->src.ssl,\n\t\t\t               BUFFEREVENT_SSL_ACCEPTING,\n\t\t\t               BEV_OPT_DEFER_CALLBACKS);\n\t\t\tif (ctx->src.bev) {\n\t\t\t\tbufferevent_openssl_set_allow_dirty_shutdown(\n\t\t\t\t                              ctx->src.bev, 1);\n\t\t\t\tbufferevent_setcb(ctx->src.bev,\n\t\t\t\t                  pxy_bev_readcb,\n\t\t\t\t                  pxy_bev_writecb,\n\t\t\t\t                  pxy_bev_eventcb,\n\t\t\t\t                  ctx);\n\t\t\t\tbufferevent_enable(ctx->src.bev,\n\t\t\t\t                   EV_READ|EV_WRITE);\n\t\t\t}\n\t\t} else {\n\t\t\tctx->src.bev = pxy_bufferevent_setup(ctx, ctx->fd,\n\t\t\t                                     ctx->src.ssl);\n\t\t}\n\t\tif (!ctx->src.bev) {\n\t\t\tif (ctx->src.ssl) {\n\t\t\t\tSSL_free(ctx->src.ssl);\n\t\t\t\tctx->src.ssl = NULL;\n\t\t\t}\n\t\t\tbufferevent_free_and_close_fd(bev, ctx);\n\t\t\tevutil_closesocket(ctx->fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\n\t\t/* prepare logging, part 2 */\n\t\tif (WANT_CONNECT_LOG(ctx) || WANT_CONTENT_LOG(ctx)) {\n\t\t\tif (ctx->dsthost_str) {\n\t\t\t\tfree(ctx->dsthost_str);\n\t\t\t\tctx->dsthost_str = NULL;\n\t\t\t}\n\t\t\tif (ctx->dstport_str) {\n\t\t\t\tfree(ctx->dstport_str);\n\t\t\t\tctx->dstport_str = NULL;\n\t\t\t}\n\t\t\tif (sys_sockaddr_str((struct sockaddr *)\n\t\t\t                     &ctx->dstaddr, ctx->dstaddrlen,\n\t\t\t                     &ctx->dsthost_str,\n\t\t\t                     &ctx->dstport_str) != 0) {\n\t\t\t\tctx->enomem = 1;\n\t\t\t\tpxy_conn_terminate_free(ctx, 1);\n\t\t\t\treturn;\n\t\t\t}\n\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t\tif (ctx->opts->lprocinfo) {\n\t\t\t\t/* fetch process info */\n\t\t\t\tif (proc_pid_for_addr(&ctx->lproc.pid,\n\t\t\t\t        (struct sockaddr*)&ctx->srcaddr,\n\t\t\t\t        ctx->srcaddrlen) == 0 &&\n\t\t\t\t    ctx->lproc.pid != -1 &&\n\t\t\t\t    proc_get_info(ctx->lproc.pid,\n\t\t\t\t                  &ctx->lproc.exec_path,\n\t\t\t\t                  &ctx->lproc.uid,\n\t\t\t\t                  &ctx->lproc.gid) == 0) {\n\t\t\t\t\t/* fetch user/group names */\n\t\t\t\t\tctx->lproc.user = sys_user_str(\n\t\t\t\t\t                ctx->lproc.uid);\n\t\t\t\t\tctx->lproc.group = sys_group_str(\n\t\t\t\t\t                ctx->lproc.gid);\n\t\t\t\t\tif (!ctx->lproc.user ||\n\t\t\t\t\t    !ctx->lproc.group) {\n\t\t\t\t\t\tctx->enomem = 1;\n\t\t\t\t\t\tpxy_conn_terminate_free(ctx, 1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t}\n\t\tif (WANT_CONTENT_LOG(ctx)) {\n\t\t\tif (log_content_open(&ctx->logctx, ctx->opts,\n\t\t\t                     (struct sockaddr *)&ctx->srcaddr,\n\t\t\t                     ctx->srcaddrlen,\n\t\t\t                     (struct sockaddr *)&ctx->dstaddr,\n\t\t\t                     ctx->dstaddrlen,\n\t\t\t                     ctx->srchost_str, ctx->srcport_str,\n\t\t\t                     ctx->dsthost_str, ctx->dstport_str,\n#ifdef HAVE_LOCAL_PROCINFO\n\t\t\t                     ctx->lproc.exec_path,\n\t\t\t                     ctx->lproc.user,\n\t\t\t                     ctx->lproc.group\n#else /* HAVE_LOCAL_PROCINFO */\n\t\t\t                     NULL, NULL, NULL\n#endif /* HAVE_LOCAL_PROCINFO */\n\t\t\t                    ) == -1) {\n\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\tctx->enomem = 1;\n\t\t\t\tpxy_conn_terminate_free(ctx, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\nconnected:\n\t\t/* log connection if we don't analyze any headers */\n\t\tif ((!this->ssl || (bev == ctx->src.bev)) &&\n\t\t    (!ctx->spec->http || ctx->passthrough) &&\n\t\t    WANT_CONNECT_LOG(ctx)) {\n\t\t\tpxy_log_connect_nonhttp(ctx);\n\t\t}\n\n\t\tif (this->ssl) {\n\t\t\t/* write SSL certificates to gendir */\n\t\t\tif ((bev == ctx->src.bev) && ctx->opts->certgendir) {\n\t\t\t\tpxy_srccert_write(ctx);\n\t\t\t}\n\n\t\t\t/* log master key */\n\t\t\tif (ctx->opts->masterkeylog) {\n\t\t\t\tchar *keystr;\n\t\t\t\tkeystr = ssl_ssl_masterkey_to_str(this->ssl);\n\t\t\t\tif ((keystr == NULL) ||\n\t\t\t\t    (log_masterkey_print_free(keystr) == -1)) {\n\t\t\t\t\tif (errno == ENOMEM)\n\t\t\t\t\t\tctx->enomem = 1;\n\t\t\t\t\tpxy_conn_terminate_free(ctx, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tif (this->ssl) {\n\t\t\t\tchar *keystr;\n\t\t\t\t/* for SSL, we get two connect events */\n\t\t\t\tlog_dbg_printf(\"SSL connected %s [%s]:%s\"\n\t\t\t\t               \" %s %s\\n\",\n\t\t\t\t               bev == ctx->dst.bev ?\n\t\t\t\t               \"to\" : \"from\",\n\t\t\t\t               bev == ctx->dst.bev ?\n\t\t\t\t               ctx->dsthost_str :\n\t\t\t\t               ctx->srchost_str,\n\t\t\t\t               bev == ctx->dst.bev ?\n\t\t\t\t               ctx->dstport_str :\n\t\t\t\t               ctx->srcport_str,\n\t\t\t\t               SSL_get_version(this->ssl),\n\t\t\t\t               SSL_get_cipher(this->ssl));\n\t\t\t\tkeystr = ssl_ssl_masterkey_to_str(this->ssl);\n\t\t\t\tif (keystr) {\n\t\t\t\t\tlog_dbg_print_free(keystr);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* for TCP, we get only a dst connect event,\n\t\t\t\t * since src was already connected from the\n\t\t\t\t * beginning; mirror SSL debug output anyway\n\t\t\t\t * in order not to confuse anyone who might be\n\t\t\t\t * looking closely at the output */\n\t\t\t\tlog_dbg_printf(\"TCP connected to [%s]:%s\\n\",\n\t\t\t\t               ctx->dsthost_str,\n\t\t\t\t               ctx->dstport_str);\n\t\t\t\tlog_dbg_printf(\"TCP connected from [%s]:%s\\n\",\n\t\t\t\t               ctx->srchost_str,\n\t\t\t\t               ctx->srcport_str);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (events & BEV_EVENT_ERROR) {\n\t\tunsigned long sslerr;\n\t\tint have_sslerr = 0;\n\n\t\t/* Can happen for socket errs, ssl errs;\n\t\t * may happen for unclean ssl socket shutdowns. */\n\t\tsslerr = bufferevent_get_openssl_error(bev);\n\t\tif (sslerr)\n\t\t\thave_sslerr = 1;\n\t\tif (!errno && !sslerr) {\n#if LIBEVENT_VERSION_NUMBER >= 0x02010000\n\t\t\t/* We have disabled notification for unclean shutdowns\n\t\t\t * so this should not happen; log a warning. */\n\t\t\tlog_err_printf(\"Warning: Spurious error from \"\n\t\t\t               \"bufferevent (errno=0,sslerr=0)\\n\");\n#else /* LIBEVENT_VERSION_NUMBER < 0x02010000 */\n\t\t\t/* Older versions of libevent will report these. */\n\t\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\t\tlog_dbg_printf(\"Unclean SSL shutdown.\\n\");\n\t\t\t}\n#endif /* LIBEVENT_VERSION_NUMBER < 0x02010000 */\n\t\t} else if (ERR_GET_REASON(sslerr) ==\n\t\t           SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE) {\n\t\t\t/* these can happen due to client cert auth,\n\t\t\t * only log error if debugging is activated */\n\t\t\tlog_dbg_printf(\"Error from %s bufferevent: \"\n\t\t\t               \"%i:%s %lu:%i:%s:%i:%s:%i:%s\\n\",\n\t\t\t               (bev == ctx->src.bev) ? \"src\" : \"dst\",\n\t\t\t               errno,\n\t\t\t               errno ? strerror(errno) : \"-\",\n\t\t\t               sslerr,\n\t\t\t               ERR_GET_REASON(sslerr),\n\t\t\t               sslerr ?\n\t\t\t               ERR_reason_error_string(sslerr) : \"-\",\n\t\t\t               ERR_GET_LIB(sslerr),\n\t\t\t               sslerr ?\n\t\t\t               ERR_lib_error_string(sslerr) : \"-\",\n\t\t\t               ERR_GET_FUNC(sslerr),\n\t\t\t               sslerr ?\n\t\t\t               ERR_func_error_string(sslerr) : \"-\");\n\t\t\twhile ((sslerr = bufferevent_get_openssl_error(bev))) {\n\t\t\t\tlog_dbg_printf(\"Additional SSL error: \"\n\t\t\t\t               \"%lu:%i:%s:%i:%s:%i:%s\\n\",\n\t\t\t\t               sslerr,\n\t\t\t\t               ERR_GET_REASON(sslerr),\n\t\t\t\t               ERR_reason_error_string(sslerr),\n\t\t\t\t               ERR_GET_LIB(sslerr),\n\t\t\t\t               ERR_lib_error_string(sslerr),\n\t\t\t\t               ERR_GET_FUNC(sslerr),\n\t\t\t\t               ERR_func_error_string(sslerr));\n\t\t\t}\n\t\t} else {\n\t\t\t/* real errors */\n\t\t\tlog_err_printf(\"Error from %s bufferevent: \"\n\t\t\t               \"%i:%s %lu:%i:%s:%i:%s:%i:%s\\n\",\n\t\t\t               (bev == ctx->src.bev) ? \"src\" : \"dst\",\n\t\t\t               errno,\n\t\t\t               errno ? strerror(errno) : \"-\",\n\t\t\t               sslerr,\n\t\t\t               ERR_GET_REASON(sslerr),\n\t\t\t               sslerr ?\n\t\t\t               ERR_reason_error_string(sslerr) : \"-\",\n\t\t\t               ERR_GET_LIB(sslerr),\n\t\t\t               sslerr ?\n\t\t\t               ERR_lib_error_string(sslerr) : \"-\",\n\t\t\t               ERR_GET_FUNC(sslerr),\n\t\t\t               sslerr ?\n\t\t\t               ERR_func_error_string(sslerr) : \"-\");\n\t\t\twhile ((sslerr = bufferevent_get_openssl_error(bev))) {\n\t\t\t\tlog_err_printf(\"Additional SSL error: \"\n\t\t\t\t               \"%lu:%i:%s:%i:%s:%i:%s\\n\",\n\t\t\t\t               sslerr,\n\t\t\t\t               ERR_GET_REASON(sslerr),\n\t\t\t\t               ERR_reason_error_string(sslerr),\n\t\t\t\t               ERR_GET_LIB(sslerr),\n\t\t\t\t               ERR_lib_error_string(sslerr),\n\t\t\t\t               ERR_GET_FUNC(sslerr),\n\t\t\t\t               ERR_func_error_string(sslerr));\n\t\t\t}\n\t\t}\n\n\t\tif (!ctx->connected) {\n\t\t\t/* the callout to the original destination failed,\n\t\t\t * e.g. because it asked for client cert auth, so\n\t\t\t * close the accepted socket and clean up */\n\t\t\tif (bev == ctx->dst.bev && ctx->dst.ssl &&\n\t\t\t    ctx->opts->passthrough && have_sslerr) {\n\t\t\t\t/* ssl callout failed, fall back to plain\n\t\t\t\t * TCP passthrough of SSL connection */\n\t\t\t\tbufferevent_free_and_close_fd(bev, ctx);\n\t\t\t\tctx->dst.bev = NULL;\n\t\t\t\tctx->dst.ssl = NULL;\n\t\t\t\tctx->passthrough = 1;\n\t\t\t\tlog_dbg_printf(\"SSL dst connection failed; fal\"\n\t\t\t\t               \"ling back to passthrough\\n\");\n\t\t\t\tpxy_fd_readcb(ctx->fd, 0, ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevutil_closesocket(ctx->fd);\n\t\t\tother->closed = 1;\n\t\t} else if (!other->closed) {\n\t\t\t/* if the other end is still open and doesn't have data\n\t\t\t * to send, close it, otherwise its writecb will close\n\t\t\t * it after writing what's left in the output buffer */\n\t\t\tstruct evbuffer *outbuf = bufferevent_get_output(other->bev);\n\t\t\tstruct bufferevent *ubev_other = bufferevent_get_underlying(other->bev);\n\t\t\tif (evbuffer_get_length(outbuf) == 0 &&\n\t\t\t\t\t(!ubev_other || evbuffer_get_length(bufferevent_get_output(ubev_other)) == 0)) {\n\t\t\t\tbufferevent_free_and_close_fd(other->bev, ctx);\n\t\t\t\tother->bev = NULL;\n\t\t\t\tother->closed = 1;\n\t\t\t}\n\t\t}\n\t\tgoto leave;\n\t}\n\n\tif (events & BEV_EVENT_EOF) {\n#ifdef DEBUG_PROXY\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"evbuffer size at EOF: \"\n\t\t\t               \"i:%zu o:%zu i:%zu o:%zu\\n\",\n\t\t\t                evbuffer_get_length(\n\t\t\t                    bufferevent_get_input(bev)),\n\t\t\t                evbuffer_get_length(\n\t\t\t                    bufferevent_get_output(bev)),\n\t\t\t\t\t\t\tother->closed ? 0 :\n\t\t\t                    evbuffer_get_length(\n\t\t\t                    bufferevent_get_input(other->bev)),\n\t\t\t\t\t\t\tother->closed ? 0 :\n\t\t\t                    evbuffer_get_length(\n\t\t\t                    bufferevent_get_output(other->bev))\n\t\t\t                );\n\t\t\tstruct bufferevent *ubev = bufferevent_get_underlying(bev);\n\t\t\tstruct bufferevent *ubev_other = other->closed ?\n\t\t\t\tNULL : bufferevent_get_underlying(other->bev);\n\t\t\tif (ubev || ubev_other) {\n\t\t\t\tlog_dbg_printf(\"underlying evbuffer size at EOF: \"\n\t\t\t\t\t\t\t   \"i:%zu o:%zu i:%zu o:%zu\\n\",\n\t\t\t\t\t\t\t\tubev ? evbuffer_get_length(\n\t\t\t\t\t\t\t\t\tbufferevent_get_input(ubev)) : 0,\n\t\t\t\t\t\t\t\tubev ? evbuffer_get_length(\n\t\t\t\t\t\t\t\t\tbufferevent_get_output(ubev)) : 0,\n\t\t\t\t\t\t\t\tubev_other ? evbuffer_get_length(\n\t\t\t\t\t\t\t\t\tbufferevent_get_input(ubev_other)) : 0,\n\t\t\t\t\t\t\t\tubev_other ? evbuffer_get_length(\n\t\t\t\t\t\t\t\t\tbufferevent_get_output(ubev_other)) : 0\n\t\t\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n#endif /* DEBUG_PROXY */\n\t\tif (!ctx->connected) {\n\t\t\tlog_dbg_printf(\"EOF on outbound connection before \"\n\t\t\t               \"connection establishment\\n\");\n\t\t\tevutil_closesocket(ctx->fd);\n\t\t\tother->closed = 1;\n\t\t} else if (!other->closed) {\n\t\t\t/* if there is data pending in the closed connection,\n\t\t\t * handle it here, otherwise it will be lost. */\n\t\t\tif (evbuffer_get_length(bufferevent_get_input(bev))) {\n\t\t\t\tpxy_bev_readcb(bev, ctx);\n\t\t\t}\n\t\t\t/* if the other end is still open and doesn't\n\t\t\t * have data to send, close it, otherwise its\n\t\t\t * writecb will close it after writing what's\n\t\t\t * left in the output buffer. */\n\t\t\tstruct bufferevent *ubev_other = bufferevent_get_underlying(other->bev);\n\t\t\tif (evbuffer_get_length(bufferevent_get_output(other->bev)) == 0 &&\n\t\t\t\t\t(!ubev_other || evbuffer_get_length(bufferevent_get_output(ubev_other)) == 0)) {\n\t\t\t\tbufferevent_free_and_close_fd(other->bev, ctx);\n\t\t\t\tother->bev = NULL;\n\t\t\t\tother->closed = 1;\n\t\t\t}\n\t\t}\n\t\tgoto leave;\n\t}\n\n\tlog_err_printf(\"Unknown bufferevent 0x%02X\\n\", (int)events);\n\treturn;\n\nleave:\n\t/* we only get a single disconnect event here for both connections */\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tlog_dbg_printf(\"%s disconnected to [%s]:%s\\n\",\n\t\t               this->ssl ? \"SSL\" : \"TCP\",\n\t\t               STRORDASH(ctx->dsthost_str),\n\t\t               STRORDASH(ctx->dstport_str));\n\t\tlog_dbg_printf(\"%s disconnected from [%s]:%s\\n\",\n\t\t               this->ssl ? \"SSL\" : \"TCP\",\n\t\t               ctx->srchost_str, ctx->srcport_str);\n\t}\n\n\tthis->closed = 1;\n\tbufferevent_free_and_close_fd(bev, ctx);\n\tthis->bev = NULL;\n\tif (other->closed) {\n\t\tpxy_conn_ctx_free(ctx, is_requestor);\n\t}\n}\n\n/*\n * Complete the connection.  This gets called after finding out where to\n * connect to.\n */\nstatic void\npxy_conn_connect(pxy_conn_ctx_t *ctx)\n{\n\tif (!ctx->dstaddrlen) {\n\t\tlog_err_printf(\"No target address; aborting connection\\n\");\n\t\tevutil_closesocket(ctx->fd);\n\t\tpxy_conn_ctx_free(ctx, 1);\n\t\treturn;\n\t}\n\n\t/* create server-side socket and eventbuffer */\n\tif (ctx->spec->ssl && !ctx->passthrough) {\n\t\tctx->dst.ssl = pxy_dstssl_create(ctx);\n\t\tif (!ctx->dst.ssl) {\n\t\t\tlog_err_printf(\"Error creating SSL\\n\");\n\t\t\tevutil_closesocket(ctx->fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\tctx->dst.bev = pxy_bufferevent_setup(ctx, -1, ctx->dst.ssl);\n\tif (!ctx->dst.bev) {\n\t\tif (ctx->dst.ssl) {\n\t\t\tSSL_free(ctx->dst.ssl);\n\t\t\tctx->dst.ssl = NULL;\n\t\t}\n\t\tevutil_closesocket(ctx->fd);\n\t\tpxy_conn_ctx_free(ctx, 1);\n\t\treturn;\n\t}\n\n\tif (OPTS_DEBUG(ctx->opts)) {\n\t\tchar *host, *port;\n\t\tif (sys_sockaddr_str((struct sockaddr *)&ctx->dstaddr,\n\t\t                     ctx->dstaddrlen, &host, &port) != 0) {\n\t\t\tlog_dbg_printf(\"Connecting to [?]:?\\n\");\n\t\t} else {\n\t\t\tlog_dbg_printf(\"Connecting to [%s]:%s\\n\", host, port);\n\t\t\tfree(host);\n\t\t\tfree(port);\n\t\t}\n\t}\n\n\t/* initiate connection */\n\tbufferevent_socket_connect(ctx->dst.bev,\n\t                           (struct sockaddr *)&ctx->dstaddr,\n\t                           ctx->dstaddrlen);\n}\n\n#ifndef OPENSSL_NO_TLSEXT\n/*\n * The SNI hostname has been resolved.  Fill the first resolved address into\n * the context and continue connecting.\n */\nstatic void\npxy_sni_resolve_cb(int errcode, struct evutil_addrinfo *ai, void *arg)\n{\n\tpxy_conn_ctx_t *ctx = arg;\n\n\tif (errcode) {\n\t\tlog_err_printf(\"Cannot resolve SNI hostname '%s': %s\\n\",\n\t\t               ctx->sni, evutil_gai_strerror(errcode));\n\t\tevutil_closesocket(ctx->fd);\n\t\tpxy_conn_ctx_free(ctx, 1);\n\t\treturn;\n\t}\n\n\tmemcpy(&ctx->dstaddr, ai->ai_addr, ai->ai_addrlen);\n\tctx->dstaddrlen = ai->ai_addrlen;\n\tevutil_freeaddrinfo(ai);\n\tpxy_conn_connect(ctx);\n}\n#endif /* !OPENSSL_NO_TLSEXT */\n\n/*\n * The src fd is readable.  This is used to sneak-preview the SNI on SSL\n * connections.  If ctx->ev is NULL, it was called manually for a non-SSL\n * connection.  If ctx->passthrough is set, it was called a second time\n * after the first ssl callout failed because of client cert auth.\n */\n#ifndef OPENSSL_NO_TLSEXT\n#define MAYBE_UNUSED \n#else /* OPENSSL_NO_TLSEXT */\n#define MAYBE_UNUSED UNUSED\n#endif /* OPENSSL_NO_TLSEXT */\nstatic void\npxy_fd_readcb(MAYBE_UNUSED evutil_socket_t fd, UNUSED short what, void *arg)\n#undef MAYBE_UNUSED\n{\n\tpxy_conn_ctx_t *ctx = arg;\n\n#ifndef OPENSSL_NO_TLSEXT\n\t/* for SSL, peek ClientHello and parse SNI from it */\n\tif (ctx->spec->ssl && !ctx->passthrough /*&& ctx->ev*/) {\n\t\tunsigned char buf[1024];\n\t\tssize_t n;\n\t\tconst unsigned char *chello;\n\t\tint rv;\n\n\t\tn = recv(fd, buf, sizeof(buf), MSG_PEEK);\n\t\tif (n == -1) {\n\t\t\tlog_err_printf(\"Error peeking on fd, aborting \"\n\t\t\t               \"connection\\n\");\n\t\t\tevutil_closesocket(fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (n == 0) {\n\t\t\t/* socket got closed while we were waiting */\n\t\t\tevutil_closesocket(fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\n\t\trv = ssl_tls_clienthello_parse(buf, n, 0, &chello, &ctx->sni);\n\t\tif ((rv == 1) && !chello) {\n\t\t\tlog_err_printf(\"Peeking did not yield a (truncated) \"\n\t\t\t               \"ClientHello message, \"\n\t\t\t               \"aborting connection\\n\");\n\t\t\tevutil_closesocket(fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\t\tif (OPTS_DEBUG(ctx->opts)) {\n\t\t\tlog_dbg_printf(\"SNI peek: [%s] [%s]\\n\",\n\t\t\t               ctx->sni ? ctx->sni : \"n/a\",\n\t\t\t               ((rv == 1) && chello) ?\n\t\t\t               \"incomplete\" : \"complete\");\n\t\t}\n\t\tif ((rv == 1) && chello && (ctx->sni_peek_retries++ < 50)) {\n\t\t\t/* ssl_tls_clienthello_parse indicates that we\n\t\t\t * should retry later when we have more data, and we\n\t\t\t * haven't reached the maximum retry count yet.\n\t\t\t * Reschedule this event as timeout-only event in\n\t\t\t * order to prevent busy looping over the read event.\n\t\t\t * Because we only peeked at the pending bytes and\n\t\t\t * never actually read them, fd is still ready for\n\t\t\t * reading now.  We use 25 * 0.2 s = 5 s timeout. */\n\t\t\tstruct timeval retry_delay = {0, 100};\n\n\t\t\tevent_free(ctx->ev);\n\t\t\tctx->ev = event_new(ctx->evbase, fd, 0,\n\t\t\t                    pxy_fd_readcb, ctx);\n\t\t\tif (!ctx->ev) {\n\t\t\t\tlog_err_printf(\"Error creating retry \"\n\t\t\t\t               \"event, aborting \"\n\t\t\t\t               \"connection\\n\");\n\t\t\t\tevutil_closesocket(fd);\n\t\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tevent_add(ctx->ev, &retry_delay);\n\t\t\treturn;\n\t\t}\n\t\tevent_free(ctx->ev);\n\t\tctx->ev = NULL;\n\t}\n\n\tif (ctx->sni && !ctx->dstaddrlen && ctx->spec->sni_port) {\n\t\tchar sniport[6];\n\t\tstruct evutil_addrinfo hints;\n\n\t\tmemset(&hints, 0, sizeof(hints));\n\t\thints.ai_family = ctx->af;\n\t\thints.ai_flags = EVUTIL_AI_ADDRCONFIG;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t\thints.ai_protocol = IPPROTO_TCP;\n\n\t\tsnprintf(sniport, sizeof(sniport), \"%i\", ctx->spec->sni_port);\n\t\tevdns_getaddrinfo(ctx->dnsbase, ctx->sni, sniport, &hints,\n\t\t                  pxy_sni_resolve_cb, ctx);\n\t\treturn;\n\t}\n#endif /* !OPENSSL_NO_TLSEXT */\n\n\tpxy_conn_connect(ctx);\n}\n\n/*\n * Callback for accept events on the socket listener bufferevent.\n * Called when a new incoming connection has been accepted.\n * Initiates the connection to the server.  The incoming connection\n * from the client is not being activated until we have a successful\n * connection to the server, because we need the server's certificate\n * in order to set up the SSL session to the client.\n * For consistency, plain TCP works the same way, even if we could\n * start reading from the client while waiting on the connection to\n * the server to connect.\n */\nvoid\npxy_conn_setup(evutil_socket_t fd,\n               struct sockaddr *peeraddr, int peeraddrlen,\n               pxy_thrmgr_ctx_t *thrmgr,\n               proxyspec_t *spec, opts_t *opts)\n{\n\tpxy_conn_ctx_t *ctx;\n\n\t/* create per connection pair state and attach to thread */\n\tctx = pxy_conn_ctx_new(spec, opts, thrmgr, fd);\n\tif (!ctx) {\n\t\tlog_err_printf(\"Error allocating memory\\n\");\n\t\tevutil_closesocket(fd);\n\t\treturn;\n\t}\n\n\tctx->af = peeraddr->sa_family;\n\n\t/* determine original destination of connection */\n\tif (spec->natlookup) {\n\t\t/* NAT engine lookup */\n\t\tctx->dstaddrlen = sizeof(struct sockaddr_storage);\n\t\tif (spec->natlookup((struct sockaddr *)&ctx->dstaddr,\n\t\t                    &ctx->dstaddrlen,\n\t\t                    fd, peeraddr, peeraddrlen) == -1) {\n\t\t\tlog_err_printf(\"Connection not found in NAT \"\n\t\t\t               \"state table, aborting connection\\n\");\n\t\t\tevutil_closesocket(fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\t} else if (spec->connect_addrlen > 0) {\n\t\t/* static forwarding */\n\t\tctx->dstaddrlen = spec->connect_addrlen;\n\t\tmemcpy(&ctx->dstaddr, &spec->connect_addr, ctx->dstaddrlen);\n\t} else {\n\t\t/* SNI mode */\n\t\tif (!ctx->spec->ssl) {\n\t\t\t/* if this happens, the proxyspec parser is broken */\n\t\t\tlog_err_printf(\"SNI mode used for non-SSL connection; \"\n\t\t\t               \"aborting connection\\n\");\n\t\t\tevutil_closesocket(fd);\n\t\t\tpxy_conn_ctx_free(ctx, 1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* prepare logging, part 1 */\n\tif (opts->pcaplog\n#ifndef WITHOUT_MIRROR\n\t    || opts->mirrorif\n#endif /* !WITHOUT_MIRROR */\n#ifdef HAVE_LOCAL_PROCINFO\n\t    || opts->lprocinfo\n#endif /* HAVE_LOCAL_PROCINFO */\n\t    ) {\n\t\tctx->srcaddrlen = peeraddrlen;\n\t\tmemcpy(&ctx->srcaddr, peeraddr, ctx->srcaddrlen);\n\t}\n\tif (WANT_CONNECT_LOG(ctx) || WANT_CONTENT_LOG(ctx)) {\n\t\tif (sys_sockaddr_str(peeraddr, peeraddrlen,\n\t\t                     &ctx->srchost_str,\n\t\t                     &ctx->srcport_str) != 0)\n\t\t\tgoto memout;\n\t}\n\n\t/* for SSL, defer dst connection setup to initial_readcb */\n\tif (ctx->spec->ssl) {\n\t\tctx->ev = event_new(ctx->evbase, fd, EV_READ, pxy_fd_readcb,\n\t\t                    ctx);\n\t\tif (!ctx->ev)\n\t\t\tgoto memout;\n\t\tevent_add(ctx->ev, NULL);\n\t} else {\n\t\tpxy_fd_readcb(fd, 0, ctx);\n\t}\n\treturn;\n\nmemout:\n\tlog_err_printf(\"Aborting connection setup (out of memory)!\\n\");\n\tevutil_closesocket(fd);\n\tpxy_conn_ctx_free(ctx, 1);\n\treturn;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "pxyconn.h",
          "type": "blob",
          "size": 1.85546875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef PXYCONN_H\n#define PXYCONN_H\n\n#include \"opts.h\"\n#include \"attrib.h\"\n#include \"pxythrmgr.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <event2/event.h>\n#include <event2/util.h>\n\nvoid pxy_conn_setup(evutil_socket_t, struct sockaddr *, int,\n                    pxy_thrmgr_ctx_t *, proxyspec_t *, opts_t *)\n                    NONNULL(2,4,5,6);\n\n#endif /* !PXYCONN_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "pxythrmgr.c",
          "type": "blob",
          "size": 7.421875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"pxythrmgr.h\"\n\n#include \"sys.h\"\n#include \"log.h\"\n\n#include <string.h>\n#include <pthread.h>\n\n/*\n * Proxy thread manager: manages the connection handling worker threads\n * and the per-thread resources (i.e. event bases).  The load is shared\n * across num_cpu * 2 connection handling threads, using the number of\n * currently assigned connections as the sole metric.\n *\n * The attach and detach functions are thread-safe.\n */\n\ntypedef struct pxy_thr_ctx {\n\tpthread_t thr;\n\tsize_t load;\n\tstruct event_base *evbase;\n\tstruct evdns_base *dnsbase;\n\tint running;\n} pxy_thr_ctx_t;\n\nstruct pxy_thrmgr_ctx {\n\tint num_thr;\n\topts_t *opts;\n\tpxy_thr_ctx_t **thr;\n\tpthread_mutex_t mutex;\n};\n\n/*\n * Dummy recurring timer event to prevent the event loops from exiting when\n * they run out of events.\n */\nstatic void\npxy_thrmgr_timer_cb(UNUSED evutil_socket_t fd, UNUSED short what,\n                    UNUSED void *arg)\n{\n\t/* do nothing */\n}\n\n/*\n * Thread entry point; runs the event loop of the event base.\n * Does not exit until the libevent loop is broken explicitly.\n */\nstatic void *\npxy_thrmgr_thr(void *arg)\n{\n\tpxy_thr_ctx_t *ctx = arg;\n\tstruct timeval timer_delay = {60, 0};\n\tstruct event *ev;\n\n\tev = event_new(ctx->evbase, -1, EV_PERSIST, pxy_thrmgr_timer_cb, NULL);\n\tif (!ev)\n\t\treturn NULL;\n\tevtimer_add(ev, &timer_delay);\n\tctx->running = 1;\n\tevent_base_dispatch(ctx->evbase);\n\tevent_free(ev);\n\n\treturn NULL;\n}\n\n/*\n * Create new thread manager but do not start any threads yet.\n * This gets called before forking to background.\n */\npxy_thrmgr_ctx_t *\npxy_thrmgr_new(opts_t *opts)\n{\n\tpxy_thrmgr_ctx_t *ctx;\n\n\tif (!(ctx = malloc(sizeof(pxy_thrmgr_ctx_t))))\n\t\treturn NULL;\n\tmemset(ctx, 0, sizeof(pxy_thrmgr_ctx_t));\n\n\tctx->opts = opts;\n\tctx->num_thr = 2 * sys_get_cpu_cores();\n\treturn ctx;\n}\n\n/*\n * Start the thread manager and associated threads.\n * This must be called after forking.\n *\n * Returns -1 on failure, 0 on success.\n */\nint\npxy_thrmgr_run(pxy_thrmgr_ctx_t *ctx)\n{\n\tint idx = -1, dns = 0;\n\n\tdns = opts_has_dns_spec(ctx->opts);\n\n\tif (pthread_mutex_init(&ctx->mutex, NULL)) {\n\t\tlog_dbg_printf(\"Failed to initialize mutex\\n\");\n\t\tgoto leave;\n\t}\n\n\tif (!(ctx->thr = malloc(ctx->num_thr * sizeof(pxy_thr_ctx_t*)))) {\n\t\tlog_dbg_printf(\"Failed to allocate memory\\n\");\n\t\tgoto leave;\n\t}\n\tmemset(ctx->thr, 0, ctx->num_thr * sizeof(pxy_thr_ctx_t*));\n\n\tfor (idx = 0; idx < ctx->num_thr; idx++) {\n\t\tif (!(ctx->thr[idx] = malloc(sizeof(pxy_thr_ctx_t)))) {\n\t\t\tlog_dbg_printf(\"Failed to allocate memory\\n\");\n\t\t\tgoto leave;\n\t\t}\n\t\tmemset(ctx->thr[idx], 0, sizeof(pxy_thr_ctx_t));\n\t\tctx->thr[idx]->evbase = event_base_new();\n\t\tif (!ctx->thr[idx]->evbase) {\n\t\t\tlog_dbg_printf(\"Failed to create evbase %d\\n\", idx);\n\t\t\tgoto leave;\n\t\t}\n\t\tif (dns) {\n\t\t\t/* only create dns base if we actually need it later */\n\t\t\tctx->thr[idx]->dnsbase = evdns_base_new(\n\t\t\t                         ctx->thr[idx]->evbase, 1);\n\t\t\tif (!ctx->thr[idx]->dnsbase) {\n\t\t\t\tlog_dbg_printf(\"Failed to create dnsbase %d\\n\",\n\t\t\t\t               idx);\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t}\n\t\tctx->thr[idx]->load = 0;\n\t\tctx->thr[idx]->running = 0;\n\t}\n\n\tlog_dbg_printf(\"Initialized %d connection handling threads\\n\",\n\t               ctx->num_thr);\n\n\tfor (idx = 0; idx < ctx->num_thr; idx++) {\n\t\tif (pthread_create(&ctx->thr[idx]->thr, NULL,\n\t\t                   pxy_thrmgr_thr, ctx->thr[idx]))\n\t\t\tgoto leave_thr;\n\t\twhile (!ctx->thr[idx]->running) {\n\t\t\tsched_yield();\n\t\t}\n\t}\n\n\tlog_dbg_printf(\"Started %d connection handling threads\\n\",\n\t               ctx->num_thr);\n\n\treturn 0;\n\nleave_thr:\n\tidx--;\n\twhile (idx >= 0) {\n\t\tpthread_cancel(ctx->thr[idx]->thr);\n\t\tpthread_join(ctx->thr[idx]->thr, NULL);\n\t\tidx--;\n\t}\n\tidx = ctx->num_thr - 1;\n\nleave:\n\twhile (idx >= 0) {\n\t\tif (ctx->thr[idx]) {\n\t\t\tif (ctx->thr[idx]->dnsbase) {\n\t\t\t\tevdns_base_free(ctx->thr[idx]->dnsbase, 0);\n\t\t\t}\n\t\t\tif (ctx->thr[idx]->evbase) {\n\t\t\t\tevent_base_free(ctx->thr[idx]->evbase);\n\t\t\t}\n\t\t\tfree(ctx->thr[idx]);\n\t\t}\n\t\tidx--;\n\t}\n\tpthread_mutex_destroy(&ctx->mutex);\n\tif (ctx->thr) {\n\t\tfree(ctx->thr);\n\t\tctx->thr = NULL;\n\t}\n\treturn -1;\n}\n\n/*\n * Destroy the event manager and stop all threads.\n */\nvoid\npxy_thrmgr_free(pxy_thrmgr_ctx_t *ctx)\n{\n\tpthread_mutex_destroy(&ctx->mutex);\n\tif (ctx->thr) {\n\t\tfor (int idx = 0; idx < ctx->num_thr; idx++) {\n\t\t\tevent_base_loopbreak(ctx->thr[idx]->evbase);\n\t\t\tsched_yield();\n\t\t}\n\t\tfor (int idx = 0; idx < ctx->num_thr; idx++) {\n\t\t\tpthread_join(ctx->thr[idx]->thr, NULL);\n\t\t}\n\t\tfor (int idx = 0; idx < ctx->num_thr; idx++) {\n\t\t\tif (ctx->thr[idx]->dnsbase) {\n\t\t\t\tevdns_base_free(ctx->thr[idx]->dnsbase, 0);\n\t\t\t}\n\t\t\tif (ctx->thr[idx]->evbase) {\n\t\t\t\tevent_base_free(ctx->thr[idx]->evbase);\n\t\t\t}\n\t\t\tfree(ctx->thr[idx]);\n\t\t}\n\t\tfree(ctx->thr);\n\t}\n\tfree(ctx);\n}\n\n/*\n * Attach a new connection to a thread.  Chooses the thread with the fewest\n * currently active connections, returns the appropriate event bases.\n * Returns the index of the chosen thread (for passing to _detach later).\n * This function cannot fail.\n */\nint\npxy_thrmgr_attach(pxy_thrmgr_ctx_t *ctx, struct event_base **evbase,\n                  struct evdns_base **dnsbase)\n{\n\tint thridx;\n\tsize_t minload;\n\n\tthridx = 0;\n\tpthread_mutex_lock(&ctx->mutex);\n\tminload = ctx->thr[thridx]->load;\n#ifdef DEBUG_THREAD\n\tlog_dbg_printf(\"===> Proxy connection handler thread status:\\n\"\n\t               \"thr[%d]: %zu\\n\", thridx, minload);\n#endif /* DEBUG_THREAD */\n\tfor (int idx = 1; idx < ctx->num_thr; idx++) {\n#ifdef DEBUG_THREAD\n\t\tlog_dbg_printf(\"thr[%d]: %zu\\n\", idx, ctx->thr[idx]->load);\n#endif /* DEBUG_THREAD */\n\t\tif (minload > ctx->thr[idx]->load) {\n\t\t\tminload = ctx->thr[idx]->load;\n\t\t\tthridx = idx;\n\t\t}\n\t}\n\t*evbase = ctx->thr[thridx]->evbase;\n\t*dnsbase = ctx->thr[thridx]->dnsbase;\n\tctx->thr[thridx]->load++;\n\tpthread_mutex_unlock(&ctx->mutex);\n\n#ifdef DEBUG_THREAD\n\tlog_dbg_printf(\"thridx: %d\\n\", thridx);\n#endif /* DEBUG_THREAD */\n\n\treturn thridx;\n}\n\n/*\n * Detach a connection from a thread by index.\n * This function cannot fail.\n */\nvoid\npxy_thrmgr_detach(pxy_thrmgr_ctx_t *ctx, int thridx)\n{\n\tpthread_mutex_lock(&ctx->mutex);\n\tctx->thr[thridx]->load--;\n\tpthread_mutex_unlock(&ctx->mutex);\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "pxythrmgr.h",
          "type": "blob",
          "size": 2.046875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef PXYTHRMGR_H\n#define PXYTHRMGR_H\n\n#include \"opts.h\"\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <event2/event.h>\n#include <event2/dns.h>\n\ntypedef struct pxy_thrmgr_ctx pxy_thrmgr_ctx_t;\n\npxy_thrmgr_ctx_t * pxy_thrmgr_new(opts_t *) MALLOC;\nint pxy_thrmgr_run(pxy_thrmgr_ctx_t *) NONNULL(1) WUNRES;\nvoid pxy_thrmgr_free(pxy_thrmgr_ctx_t *) NONNULL(1);\n\nint pxy_thrmgr_attach(pxy_thrmgr_ctx_t *, struct event_base **,\n                      struct evdns_base **) WUNRES;\nvoid pxy_thrmgr_detach(pxy_thrmgr_ctx_t *, int);\n\n#endif /* !PXYTHRMGR_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "pxythrmgr.t.c",
          "type": "blob",
          "size": 3.630859375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"pxythrmgr.h\"\n\n#include <string.h>\n\n#include <check.h>\n\nSTART_TEST(pxythrmgr_libevent_01)\n{\n\tstruct event_base *evbase;\n\n\tevbase = event_base_new();\n\tfail_unless(!!evbase, \"no event base\");\n\tevent_base_free(evbase);\n}\nEND_TEST\n\nSTART_TEST(pxythrmgr_libevent_02)\n{\n\tstruct event_base *evbase;\n\tstruct evdns_base *dnsbase;\n\n\tevbase = event_base_new();\n\tfail_unless(!!evbase, \"no event base\");\n\tdnsbase = evdns_base_new(evbase, 0);\n\tfail_unless(!!dnsbase, \"no evdns base\");\n\tevdns_base_free(dnsbase, 0);\n\tevent_base_free(evbase);\n}\nEND_TEST\n\nSTART_TEST(pxythrmgr_libevent_03)\n{\n\tstruct event_base *evbase;\n\tstruct evdns_base *dnsbase;\n\tint rc;\n\n\tevbase = event_base_new();\n\tfail_unless(!!evbase, \"no event base\");\n\tdnsbase = evdns_base_new(evbase, 0);\n\tfail_unless(!!dnsbase, \"no evdns base\");\n\trc = evdns_base_resolv_conf_parse(dnsbase, DNS_OPTIONS_ALL,\n\t                                  \"/etc/resolv.conf\");\n\tfail_unless(rc == 0, \"unable to parse resolv.conf\");\n\tevdns_base_free(dnsbase, 0);\n\tevent_base_free(evbase);\n}\nEND_TEST\n\nSTART_TEST(pxythrmgr_libevent_04)\n{\n\tstruct event_base *evbase;\n\tstruct evdns_base *dnsbase;\n\n\tevbase = event_base_new();\n\tfail_unless(!!evbase, \"no event base\");\n\tdnsbase = evdns_base_new(evbase, 1);\n\tfail_unless(!!dnsbase, \"no evdns base\");\n\tevdns_base_free(dnsbase, 0);\n\tevent_base_free(evbase);\n}\nEND_TEST\n\nSTART_TEST(pxythrmgr_libevent_05)\n{\n\tstruct event_base *evbase1;\n\tstruct event_base *evbase2;\n\tstruct evdns_base *dnsbase;\n\n\t/* issue #17:  */\n\tevbase1 = event_base_new();\n\tfail_unless(!!evbase1, \"no event base 1\");\n\tevbase2 = event_base_new();\n\tfail_unless(!!evbase1, \"no event base 2\");\n\tdnsbase = evdns_base_new(evbase2, 1);\n\tfail_unless(!!dnsbase, \"no evdns base\");\n\tevdns_base_free(dnsbase, 0);\n\tevent_base_free(evbase2);\n\tevent_base_free(evbase1);\n}\nEND_TEST\n\nSuite *\npxythrmgr_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"pxythrmgr\");\n\n\ttc = tcase_create(\"pxythrmgr_libevent\");\n\ttcase_add_test(tc, pxythrmgr_libevent_01);\n\ttcase_add_test(tc, pxythrmgr_libevent_02);\n\ttcase_add_test(tc, pxythrmgr_libevent_03);\n\ttcase_add_test(tc, pxythrmgr_libevent_04);\n\ttcase_add_test(tc, pxythrmgr_libevent_05);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "ssl.c",
          "type": "blob",
          "size": 65.6689453125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"ssl.h\"\n\n#include \"log.h\"\n#include \"defaults.h\"\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#include <openssl/crypto.h>\n#ifndef OPENSSL_NO_ENGINE\n#include <openssl/engine.h>\n#endif /* !OPENSSL_NO_ENGINE */\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#ifndef OPENSSL_NO_DH\n#include <openssl/dh.h>\n#endif /* !OPENSSL_NO_DH */\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <openssl/ocsp.h>\n\n\n/*\n * Collection of helper functions on top of the OpenSSL API.\n */\n\n\n/*\n * Workaround for bug in OpenSSL 1.0.0k and 1.0.1e\n * http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=703031\n * http://openssl.6102.n7.nabble.com/NULL-ptr-deref-when-calling-SSL-get-certificate-with-1-0-0k-td43636.html\n */\n#if (OPENSSL_VERSION_NUMBER == 0x0090819fL) || \\\n    (OPENSSL_VERSION_NUMBER == 0x100000bfL) || \\\n    (OPENSSL_VERSION_NUMBER == 0x1000105fL)\n/*\n * OpenSSL internal declarations from ssl_locl.h, reduced to what is needed.\n */\nstruct cert_pkey_st {\n\tX509 *x509;\n\t/*\n\tEVP_PKEY *privatekey;\n\tconst EVP_MD *digest;\n\t*/\n};\nstruct cert_st {\n\tstruct cert_pkey_st *key;\n\t/* ... */\n};\n\n/*\n * Replacement function for SSL_get_certificate().\n */\nX509 *\nssl_ssl_cert_get(SSL *s)\n{\n\treturn s->cert ? s->cert->key->x509 : NULL;\n}\n#endif /* OpenSSL 0.9.8y, 1.0.0k or 1.0.1e */\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x2070000fL)\nint\nDH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n\t/*\n\t * If the fields p and g in d are NULL, the corresponding input\n\t * parameters MUST be non-NULL.  q may remain NULL.\n\t */\n\tif ((dh->p == NULL && p == NULL) || (dh->g == NULL && g == NULL))\n\t\treturn 0;\n\n\tif (p != NULL) {\n\t\tBN_free(dh->p);\n\t\tdh->p = p;\n\t}\n\tif (q != NULL) {\n\t\tBN_free(dh->q);\n\t\tdh->q = q;\n\t\tdh->length = BN_num_bits(q);\n\t}\n\tif (g != NULL) {\n\t\tBN_free(dh->g);\n\t\tdh->g = g;\n\t}\n\n\treturn 1;\n}\n#endif\n\n\n/*\n * Print OpenSSL version and build-time configuration to standard error and\n * return.\n */\nvoid\nssl_openssl_version(void)\n{\n\tfprintf(stderr, \"compiled against %s (%lx)\\n\",\n\t                OPENSSL_VERSION_TEXT,\n\t                (long unsigned int)OPENSSL_VERSION_NUMBER);\n\tfprintf(stderr, \"rtlinked against %s (%lx)\\n\",\n\t                SSLeay_version(SSLEAY_VERSION),\n\t                SSLeay());\n\tif ((OPENSSL_VERSION_NUMBER ^ SSLeay()) & 0xfffff000L) {\n\t\tfprintf(stderr, \"---------------------------------------\"\n\t\t                \"---------------------------------------\\n\");\n\t\tfprintf(stderr, \"WARNING: OpenSSL version mismatch may \"\n\t\t                \"lead to crashes or other problems!\\n\");\n\t\tfprintf(stderr, \"If there are multiple versions of \"\n\t\t                \"OpenSSL available, make sure to use\\n\");\n\t\tfprintf(stderr, \"the same version of the library at \"\n\t\t                \"runtime as well as for compiling against.\\n\");\n\t\tfprintf(stderr, \"---------------------------------------\"\n\t\t                \"---------------------------------------\\n\");\n\t}\n#ifdef LIBRESSL_VERSION_NUMBER\n\tfprintf(stderr, \"OpenSSL API provided by LibreSSL: %s (%lx)\\n\",\n\t                LIBRESSL_VERSION_TEXT,\n\t                (long unsigned int)LIBRESSL_VERSION_NUMBER);\n#endif /* LIBRESSL_VERSION_NUMBER */\n#ifdef OPENSSL_IS_BORINGSSL\n\tfprintf(stderr, \"OpenSSL API provided by BoringSSL\\n\")\n#endif /* OPENSSL_IS_BORINGSSL */\n#ifndef OPENSSL_NO_TLSEXT\n\tfprintf(stderr, \"OpenSSL has support for TLS extensions\\n\"\n\t                \"TLS Server Name Indication (SNI) supported\\n\");\n#else /* OPENSSL_NO_TLSEXT */\n\tfprintf(stderr, \"OpenSSL has no support for TLS extensions\\n\"\n\t                \"TLS Server Name Indication (SNI) not supported\\n\");\n#endif /* OPENSSL_NO_TLSEXT */\n#ifdef OPENSSL_THREADS\n#ifndef OPENSSL_NO_THREADID\n\tfprintf(stderr, \"OpenSSL is thread-safe with THREADID\\n\");\n#else /* OPENSSL_NO_THREADID */\n\tfprintf(stderr, \"OpenSSL is thread-safe without THREADID\\n\");\n#endif /* OPENSSL_NO_THREADID */\n#else /* !OPENSSL_THREADS */\n\tfprintf(stderr, \"OpenSSL is not thread-safe\\n\");\n#endif /* !OPENSSL_THREADS */\n#ifndef OPENSSL_NO_ENGINE\n\tfprintf(stderr, \"OpenSSL has engine support\\n\");\n#else /* OPENSSL_NO_ENGINE */\n\tfprintf(stderr, \"OpenSSL has no engine support\\n\");\n#endif /* OPENSSL_NO_ENGINE */\n#ifdef SSL_MODE_RELEASE_BUFFERS\n\tfprintf(stderr, \"Using SSL_MODE_RELEASE_BUFFERS\\n\");\n#else /* !SSL_MODE_RELEASE_BUFFERS */\n\tfprintf(stderr, \"Not using SSL_MODE_RELEASE_BUFFERS\\n\");\n#endif /* !SSL_MODE_RELEASE_BUFFERS */\n#if (OPENSSL_VERSION_NUMBER == 0x0090819fL) || \\\n    (OPENSSL_VERSION_NUMBER == 0x100000bfL) || \\\n    (OPENSSL_VERSION_NUMBER == 0x1000105fL)\n\tfprintf(stderr, \"Using direct access workaround when loading certs\\n\");\n#endif /* OpenSSL 0.9.8y, 1.0.0k or 1.0.1e */\n\n\tfprintf(stderr, \"SSL/TLS protocol availability: %s\\n\",\n\t                SSL_PROTO_SUPPORT_S);\n\n\tfprintf(stderr, \"SSL/TLS algorithm availability:\");\n#ifndef OPENSSL_NO_SHA0\n\tfprintf(stderr, \" SHA0\");\n#else /* !OPENSSL_NO_SHA0 */\n\tfprintf(stderr, \" !SHA0\");\n#endif /* !OPENSSL_NO_SHA0 */\n#ifndef OPENSSL_NO_RSA\n\tfprintf(stderr, \" RSA\");\n#else /* !OPENSSL_NO_RSA */\n\tfprintf(stderr, \" !RSA\");\n#endif /* !OPENSSL_NO_RSA */\n#ifndef OPENSSL_NO_DSA\n\tfprintf(stderr, \" DSA\");\n#else /* !OPENSSL_NO_DSA */\n\tfprintf(stderr, \" !DSA\");\n#endif /* !OPENSSL_NO_DSA */\n#ifndef OPENSSL_NO_ECDSA\n\tfprintf(stderr, \" ECDSA\");\n#else /* !OPENSSL_NO_ECDSA */\n\tfprintf(stderr, \" !ECDSA\");\n#endif /* !OPENSSL_NO_ECDSA */\n#ifndef OPENSSL_NO_DH\n\tfprintf(stderr, \" DH\");\n#else /* !OPENSSL_NO_DH */\n\tfprintf(stderr, \" !DH\");\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n\tfprintf(stderr, \" ECDH\");\n#else /* !OPENSSL_NO_ECDH */\n\tfprintf(stderr, \" !ECDH\");\n#endif /* !OPENSSL_NO_ECDH */\n#ifndef OPENSSL_NO_EC\n\tfprintf(stderr, \" EC\");\n#else /* !OPENSSL_NO_EC */\n\tfprintf(stderr, \" !EC\");\n#endif /* !OPENSSL_NO_EC */\n\tfprintf(stderr, \"\\n\");\n\n\tfprintf(stderr, \"OpenSSL option availability:\");\n#ifdef SSL_OP_NO_COMPRESSION\n\tfprintf(stderr, \" SSL_OP_NO_COMPRESSION\");\n#else /* !SSL_OP_NO_COMPRESSION */\n\tfprintf(stderr, \" !SSL_OP_NO_COMPRESSION\");\n#endif /* SSL_OP_NO_COMPRESSION */\n#ifdef SSL_OP_NO_TICKET\n\tfprintf(stderr, \" SSL_OP_NO_TICKET\");\n#else /* !SSL_OP_NO_TICKET */\n\tfprintf(stderr, \" !SSL_OP_NO_TICKET\");\n#endif /* SSL_OP_NO_TICKET */\n#ifdef SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\n\tfprintf(stderr, \" SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\");\n#else /* !SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION */\n\tfprintf(stderr, \" !SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION\");\n#endif /* !SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION */\n#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\n\tfprintf(stderr, \" SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\");\n#else /* !SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS */\n\tfprintf(stderr, \" !SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\");\n#endif /* !SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS */\n#ifdef SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\n\tfprintf(stderr, \" SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\");\n#else /* !SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION */\n\tfprintf(stderr, \" !SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION\");\n#endif /* !SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION */\n#ifdef SSL_OP_TLS_ROLLBACK_BUG\n\tfprintf(stderr, \" SSL_OP_TLS_ROLLBACK_BUG\");\n#else /* !SSL_OP_TLS_ROLLBACK_BUG */\n\tfprintf(stderr, \" !SSL_OP_TLS_ROLLBACK_BUG\");\n#endif /* !SSL_OP_TLS_ROLLBACK_BUG */\n\tfprintf(stderr, \"\\n\");\n}\n\n/*\n * 1 if OpenSSL has been initialized, 0 if not.  When calling a _load()\n * function the first time, OpenSSL will automatically be initialized.\n * Not protected by a mutex and thus not thread-safe.\n */\nstatic int ssl_initialized = 0;\n\n#if defined(OPENSSL_THREADS) && ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\nstruct CRYPTO_dynlock_value {\n\tpthread_mutex_t mutex;\n};\nstatic pthread_mutex_t *ssl_mutex;\nstatic int ssl_mutex_num;\n\n/*\n * OpenSSL thread-safety locking callback, #1.\n */\nstatic void\nssl_thr_locking_cb(int mode, int type, UNUSED const char *file,\n                   UNUSED int line) {\n\tif (type < ssl_mutex_num) {\n\t\tif (mode & CRYPTO_LOCK)\n\t\t\tpthread_mutex_lock(&ssl_mutex[type]);\n\t\telse\n\t\t\tpthread_mutex_unlock(&ssl_mutex[type]);\n\t}\n}\n\n/*\n * OpenSSL thread-safety locking callback, #2.\n */\nstatic struct CRYPTO_dynlock_value *\nssl_thr_dyn_create_cb(UNUSED const char *file, UNUSED int line)\n{\n\tstruct CRYPTO_dynlock_value *dl;\n\n\tif ((dl = malloc(sizeof(struct CRYPTO_dynlock_value)))) {\n\t\tif (pthread_mutex_init(&dl->mutex, NULL)) {\n\t\t\tfree(dl);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn dl;\n}\n\n/*\n * OpenSSL thread-safety locking callback, #3.\n */\nstatic void\nssl_thr_dyn_lock_cb(int mode, struct CRYPTO_dynlock_value *dl,\n                    UNUSED const char *file, UNUSED int line)\n{\n\tif (mode & CRYPTO_LOCK) {\n\t\tpthread_mutex_lock(&dl->mutex);\n\t} else {\n\t\tpthread_mutex_unlock(&dl->mutex);\n\t}\n}\n\n/*\n * OpenSSL thread-safety locking callback, #4.\n */\nstatic void\nssl_thr_dyn_destroy_cb(struct CRYPTO_dynlock_value *dl,\n                       UNUSED const char *file, UNUSED int line)\n{\n\tpthread_mutex_destroy(&dl->mutex);\n\tfree(dl);\n}\n\n#ifdef OPENSSL_NO_THREADID\n/*\n * OpenSSL thread-safety thread ID callback, legacy version.\n */\nstatic unsigned long\nssl_thr_id_cb(void) {\n\treturn (unsigned long) pthread_self();\n}\n#else /* !OPENSSL_NO_THREADID */\n/*\n * OpenSSL thread-safety thread ID callback, up-to-date version.\n */\nstatic void\nssl_thr_id_cb(CRYPTO_THREADID *id)\n{\n\tCRYPTO_THREADID_set_numeric(id, (unsigned long) pthread_self());\n}\n#endif /* !OPENSSL_NO_THREADID */\n#endif /* OPENSSL_THREADS */\n\n/*\n * Initialize OpenSSL and verify the random number generator works.\n * Returns -1 on failure, 0 on success.\n */\nint\nssl_init(void)\n{\n#ifndef PURIFY\n\tint fd;\n#endif /* !PURIFY */\n\tchar buf[256];\n\n\tif (ssl_initialized)\n\t\treturn 0;\n\n\t/* general initialization */\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n\tOPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG\n#ifndef OPENSSL_NO_ENGINE\n\t                    |OPENSSL_INIT_ENGINE_ALL_BUILTIN\n#endif /* !OPENSSL_NO_ENGINE */\n\t                    , NULL);\n\tOPENSSL_init_ssl(0, NULL);\n#else /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\tSSL_library_init();\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\n#ifdef PURIFY\n\tCRYPTO_malloc_init();\n\tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n#endif /* PURIFY */\n\tSSL_load_error_strings();\n\tOpenSSL_add_all_algorithms();\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\tOPENSSL_config(NULL);\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\n\t/* thread-safety */\n#if defined(OPENSSL_THREADS) && ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tssl_mutex_num = CRYPTO_num_locks();\n\tssl_mutex = malloc(ssl_mutex_num * sizeof(*ssl_mutex));\n\tfor (int i = 0; i < ssl_mutex_num; i++) {\n\t\tif (pthread_mutex_init(&ssl_mutex[i], NULL)) {\n\t\t\tlog_err_printf(\"Failed to initialize mutex\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tCRYPTO_set_locking_callback(ssl_thr_locking_cb);\n\tCRYPTO_set_dynlock_create_callback(ssl_thr_dyn_create_cb);\n\tCRYPTO_set_dynlock_lock_callback(ssl_thr_dyn_lock_cb);\n\tCRYPTO_set_dynlock_destroy_callback(ssl_thr_dyn_destroy_cb);\n#ifdef OPENSSL_NO_THREADID\n\tCRYPTO_set_id_callback(ssl_thr_id_cb);\n#else /* !OPENSSL_NO_THREADID */\n\tCRYPTO_THREADID_set_callback(ssl_thr_id_cb);\n#endif /* !OPENSSL_NO_THREADID */\n#endif /* OPENSSL_THREADS && OPENSSL_VERSION_NUMBER < 0x10100000L */\n\n\t/* randomness */\n#ifndef PURIFY\n\tif ((fd = open(\"/dev/urandom\", O_RDONLY)) == -1) {\n\t\tlog_err_printf(\"Error opening /dev/urandom for reading: %s\\n\",\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\twhile (!RAND_status()) {\n\t\tif (read(fd, buf, sizeof(buf)) == -1) {\n\t\t\tlog_err_printf(\"Error reading from /dev/urandom: %s\\n\",\n\t\t\t               strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\t\tRAND_seed(buf, sizeof(buf));\n\t}\n\tclose(fd);\n\tif (!RAND_poll()) {\n\t\tlog_err_printf(\"RAND_poll() failed.\\n\");\n\t\treturn -1;\n\t}\n#else /* PURIFY */\n\tlog_err_printf(\"Warning: not seeding OpenSSL RAND due to PURITY!\\n\");\n\tmemset(buf, 0, sizeof(buf));\n\twhile (!RAND_status()) {\n\t\tRAND_seed(buf, sizeof(buf));\n\t}\n#endif /* PURIFY */\n\n#ifdef USE_FOOTPRINT_HACKS\n\t/* HACK: disable compression by zeroing the global comp algo stack.\n\t * This lowers the per-connection memory footprint by ~500k. */\n\tSTACK_OF(SSL_COMP)* comp_methods = SSL_COMP_get_compression_methods();\n\tsk_SSL_COMP_zero(comp_methods);\n#endif /* USE_FOOTPRINT_HACKS */\n\n\tssl_initialized = 1;\n\treturn 0;\n}\n\n/*\n * Re-initialize OpenSSL after forking.  Returns 0 on success, -1 on failure.\n */\nint\nssl_reinit(void)\n{\n\tif (!ssl_initialized)\n\t\treturn 0;\n\n#if defined(OPENSSL_THREADS) && ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tfor (int i = 0; i < ssl_mutex_num; i++) {\n\t\tif (pthread_mutex_init(&ssl_mutex[i], NULL)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n#endif /* OPENSSL_THREADS */\n\n\treturn 0;\n}\n\n/*\n * Deinitialize OpenSSL and free as much memory as possible.\n * Some 10k-100k will still remain resident no matter what.\n */\nvoid\nssl_fini(void)\n{\n\tif (!ssl_initialized)\n\t\treturn;\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\tERR_remove_state(0); /* current thread */\n#endif\n\n#if defined(OPENSSL_THREADS) && \\\n    ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tCRYPTO_set_locking_callback(NULL);\n\tCRYPTO_set_dynlock_create_callback(NULL);\n\tCRYPTO_set_dynlock_lock_callback(NULL);\n\tCRYPTO_set_dynlock_destroy_callback(NULL);\n#ifdef OPENSSL_NO_THREADID\n\tCRYPTO_set_id_callback(NULL);\n#else /* !OPENSSL_NO_THREADID */\n\tCRYPTO_THREADID_set_callback(NULL);\n#endif /* !OPENSSL_NO_THREADID */\n\tfor (int i = 0; i < ssl_mutex_num; i++) {\n\t\tpthread_mutex_destroy(&ssl_mutex[i]);\n\t}\n\tfree(ssl_mutex);\n#endif\n\n#if !defined(OPENSSL_NO_ENGINE) && \\\n    ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tENGINE_cleanup();\n#endif /* !OPENSSL_NO_ENGINE && OPENSSL_VERSION_NUMBER < 0x10100000L */\n\tCONF_modules_finish();\n\tCONF_modules_unload(1);\n\tCONF_modules_free();\n\n\tEVP_cleanup();\n\tERR_free_strings();\n\tCRYPTO_cleanup_all_ex_data();\n\n\tssl_initialized = 0;\n}\n\n/*\n * Look up an OpenSSL engine by ID or by full path and load it as default\n * engine.  This works globally, not on specific SSL_CTX or SSL instances.\n * OpenSSL must already have been initialized when calling this function.\n * Returns 0 on success, -1 on failure.\n */\n#ifndef OPENSSL_NO_ENGINE\nint\nssl_engine(const char *name) {\n\tENGINE *engine;\n\n\tengine = ENGINE_by_id(name);\n\tif (!engine)\n\t\treturn -1;\n\n\tif (!ENGINE_set_default(engine, ENGINE_METHOD_ALL))\n\t\treturn -1;\n\treturn 0;\n}\n#endif /* !OPENSSL_NO_ENGINE */\n\n/*\n * Format raw SHA1 hash into newly allocated string, with or without colons.\n */\nchar *\nssl_sha1_to_str(unsigned char *rawhash, int colons)\n{\n\tchar *str;\n\tint rv;\n\n\trv = asprintf(&str, colons ?\n\t              \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:\"\n\t              \"%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X:%02X\" :\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\",\n\t              rawhash[ 0], rawhash[ 1], rawhash[ 2], rawhash[ 3],\n\t              rawhash[ 4], rawhash[ 5], rawhash[ 6], rawhash[ 7],\n\t              rawhash[ 8], rawhash[ 9], rawhash[10], rawhash[11],\n\t              rawhash[12], rawhash[13], rawhash[14], rawhash[15],\n\t              rawhash[16], rawhash[17], rawhash[18], rawhash[19]);\n\tif (rv == -1)\n\t\treturn NULL;\n\treturn str;\n}\n\n/*\n * Format SSL state into newly allocated string.\n * Returns pointer to string that must be freed by caller, or NULL on error.\n */\nchar *\nssl_ssl_state_to_str(SSL *ssl)\n{\n\tchar *str = NULL;\n\tint rv;\n\n\trv = asprintf(&str, \"%08x = %s%s%04x = %s (%s) [%s]\",\n\t              SSL_get_state(ssl),\n\t              (SSL_get_state(ssl) & SSL_ST_CONNECT) ? \"SSL_ST_CONNECT|\" : \"\",\n\t              (SSL_get_state(ssl) & SSL_ST_ACCEPT) ? \"SSL_ST_ACCEPT|\" : \"\",\n\t              SSL_get_state(ssl) & SSL_ST_MASK,\n\t              SSL_state_string(ssl),\n\t              SSL_state_string_long(ssl),\n\t              SSL_is_server(ssl) ? \"accept socket\" : \"connect socket\");\n\n\treturn (rv < 0) ? NULL : str;\n}\n\n/*\n * Generates a NSS key log format compatible string containing the client\n * random and the master key, intended to be used to decrypt externally\n * captured network traffic using tools like Wireshark.\n *\n * Only supports the CLIENT_RANDOM method (SSL 3.0 - TLS 1.2).\n *\n * https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format\n */\nchar *\nssl_ssl_masterkey_to_str(SSL *ssl)\n{\n\tchar *str = NULL;\n\tint rv;\n\tunsigned char *k, *r;\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && (!defined(LIBRESSL_VERSION_NUMBER) || LIBRESSL_VERSION_NUMBER >= 0x2070000fL)\n\tunsigned char kbuf[48], rbuf[32];\n\tk = &kbuf[0];\n\tr = &rbuf[0];\n\tSSL_SESSION_get_master_key(SSL_get0_session(ssl), k, sizeof(kbuf));\n\tSSL_get_client_random(ssl, r, sizeof(rbuf));\n#else /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\tk = ssl->session->master_key;\n\tr = ssl->s3->client_random;\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\trv = asprintf(&str,\n\t              \"CLIENT_RANDOM \"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \" \"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"%02X%02X%02X%02X%02X%02X%02X%02X\"\n\t              \"\\n\",\n\t              r[ 0], r[ 1], r[ 2], r[ 3], r[ 4], r[ 5], r[ 6], r[ 7],\n\t              r[ 8], r[ 9], r[10], r[11], r[12], r[13], r[14], r[15],\n\t              r[16], r[17], r[18], r[19], r[20], r[21], r[22], r[23],\n\t              r[24], r[25], r[26], r[27], r[28], r[29], r[30], r[31],\n\t              k[ 0], k[ 1], k[ 2], k[ 3], k[ 4], k[ 5], k[ 6], k[ 7],\n\t              k[ 8], k[ 9], k[10], k[11], k[12], k[13], k[14], k[15],\n\t              k[16], k[17], k[18], k[19], k[20], k[21], k[22], k[23],\n\t              k[24], k[25], k[26], k[27], k[28], k[29], k[30], k[31],\n\t              k[32], k[33], k[34], k[35], k[36], k[37], k[38], k[39],\n\t              k[40], k[41], k[42], k[43], k[44], k[45], k[46], k[47]);\n\n\treturn (rv < 0) ? NULL : str;\n}\n\n#ifndef OPENSSL_NO_DH\nstatic unsigned char dh_g[] = { 0x02 };\nstatic unsigned char dh512_p[] = {\n\t0xAB, 0xC0, 0x34, 0x16, 0x95, 0x8B, 0x57, 0xE5, 0x5C, 0xB3, 0x4E, 0x6E,\n\t0x16, 0x0B, 0x35, 0xC5, 0x6A, 0xCC, 0x4F, 0xD3, 0xE5, 0x46, 0xE2, 0x23,\n\t0x6A, 0x5B, 0xBB, 0x5D, 0x3D, 0x52, 0xEA, 0xCE, 0x4F, 0x7D, 0xCA, 0xFF,\n\t0xB4, 0x8B, 0xC9, 0x78, 0xDC, 0xA0, 0xFC, 0xBE, 0xF3, 0xB5, 0xE6, 0x61,\n\t0xA6, 0x6D, 0x58, 0xFC, 0xA0, 0x0F, 0xF7, 0x9B, 0x97, 0xE6, 0xC7, 0xE8,\n\t0x1F, 0xCD, 0x16, 0x73 };\nstatic unsigned char dh1024_p[] = {\n\t0x99, 0x28, 0x34, 0x48, 0x9E, 0xB7, 0xD1, 0x4F, 0x0D, 0x17, 0x09, 0x97,\n\t0xB9, 0x9B, 0x20, 0xFE, 0xE5, 0x65, 0xE0, 0xE2, 0x56, 0x37, 0x80, 0xA2,\n\t0x9F, 0x2C, 0x2D, 0x87, 0x10, 0x58, 0x39, 0xAD, 0xF3, 0xC5, 0xA9, 0x08,\n\t0x24, 0xC7, 0xAA, 0xA9, 0x29, 0x3A, 0x13, 0xDF, 0x4E, 0x0A, 0x6D, 0x11,\n\t0x39, 0xB1, 0x1C, 0x3F, 0xFE, 0xFE, 0x0A, 0x5E, 0xAD, 0x2E, 0x5C, 0x10,\n\t0x97, 0x38, 0xAC, 0xE8, 0xEB, 0xAA, 0x4A, 0xA1, 0xC0, 0x5C, 0x1D, 0x27,\n\t0x65, 0x9C, 0xC8, 0x53, 0xAC, 0x35, 0xDD, 0x84, 0x1F, 0x47, 0x0E, 0x04,\n\t0xF1, 0x90, 0x61, 0x62, 0x2E, 0x29, 0x2C, 0xC6, 0x28, 0x91, 0x6D, 0xF0,\n\t0xE2, 0x5E, 0xCE, 0x60, 0x3E, 0xF7, 0xF8, 0x37, 0x99, 0x4D, 0x9F, 0xFB,\n\t0x68, 0xEC, 0x7F, 0x9D, 0x32, 0x74, 0xD1, 0xAA, 0xD4, 0x4C, 0xF5, 0xCD,\n\t0xC2, 0xD7, 0xD7, 0xAC, 0xDA, 0x69, 0xF5, 0x2B };\nstatic unsigned char dh2048_p[] = {\n\t0xAB, 0x88, 0x97, 0xCA, 0xF1, 0xE1, 0x60, 0x39, 0xFA, 0xB1, 0xA8, 0x7D,\n\t0xB3, 0x7A, 0x38, 0x08, 0xF0, 0x7A, 0x3D, 0x21, 0xC4, 0xE6, 0xB8, 0x32,\n\t0x3D, 0xAB, 0x0F, 0xE7, 0x8C, 0xA1, 0x59, 0x47, 0xB2, 0x0A, 0x7A, 0x3A,\n\t0x20, 0x2A, 0x1B, 0xD4, 0xBA, 0xFC, 0x4C, 0xC5, 0xEE, 0xA2, 0xB9, 0xB9,\n\t0x65, 0x47, 0xCC, 0x13, 0x99, 0xD7, 0xA6, 0xCA, 0xFF, 0x23, 0x05, 0x91,\n\t0xAB, 0x5C, 0x82, 0xB8, 0xB4, 0xFD, 0xB1, 0x2E, 0x5B, 0x0F, 0x8E, 0x03,\n\t0x3C, 0x23, 0xD6, 0x6A, 0xE2, 0x83, 0x95, 0xD2, 0x8E, 0xEB, 0xDF, 0x3A,\n\t0xAF, 0x89, 0xF0, 0xA0, 0x14, 0x09, 0x12, 0xF6, 0x54, 0x54, 0x93, 0xF4,\n\t0xD4, 0x41, 0x56, 0x7A, 0x0E, 0x56, 0x20, 0x1F, 0x1D, 0xBA, 0x3F, 0x07,\n\t0xD2, 0x89, 0x1B, 0x40, 0xD0, 0x1C, 0x08, 0xDF, 0x00, 0x7F, 0x34, 0xF4,\n\t0x28, 0x4E, 0xF7, 0x53, 0x8D, 0x4A, 0x00, 0xC3, 0xC0, 0x89, 0x9E, 0x63,\n\t0x96, 0xE9, 0x52, 0xDF, 0xA5, 0x2C, 0x00, 0x4E, 0xB0, 0x82, 0x6A, 0x10,\n\t0x28, 0x8D, 0xB9, 0xE7, 0x7A, 0xCB, 0xC3, 0xD6, 0xC1, 0xC0, 0x4D, 0x91,\n\t0xC4, 0x6F, 0xD3, 0x99, 0xD1, 0x86, 0x71, 0x67, 0x0A, 0xA1, 0xFC, 0xF4,\n\t0x7D, 0x40, 0x88, 0x8D, 0xAC, 0xCB, 0xBC, 0xEA, 0x17, 0x85, 0x0B, 0xC6,\n\t0x12, 0x3E, 0x4A, 0xB9, 0x60, 0x74, 0x93, 0x54, 0x14, 0x39, 0x10, 0xBF,\n\t0x21, 0xB0, 0x8B, 0xB1, 0x55, 0x3F, 0xBB, 0x6A, 0x1F, 0x42, 0x82, 0x0A,\n\t0x40, 0x3A, 0x15, 0xCD, 0xD3, 0x79, 0xD0, 0x02, 0xA4, 0xF5, 0x79, 0x78,\n\t0x03, 0xBD, 0x47, 0xCC, 0xD5, 0x08, 0x6A, 0x46, 0xAE, 0x36, 0xE4, 0xCD,\n\t0xB1, 0x17, 0x48, 0x30, 0xB4, 0x02, 0xBC, 0x50, 0x68, 0xE3, 0xA2, 0x76,\n\t0xD0, 0x5C, 0xB9, 0xE6, 0xBE, 0x4C, 0xFD, 0x50, 0xEF, 0xD0, 0x3F, 0x39,\n\t0x4F, 0x53, 0x16, 0x3B };\nstatic unsigned char dh4096_p[] = {\n\t0xB1, 0xCC, 0x09, 0x86, 0xEE, 0xF9, 0xB9, 0xC9, 0xB9, 0x87, 0xC4, 0xB9,\n\t0xD7, 0x31, 0x95, 0x84, 0x94, 0x65, 0xED, 0x82, 0x64, 0x11, 0xA7, 0x0A,\n\t0xFE, 0xC2, 0x60, 0xAE, 0x7C, 0x74, 0xFB, 0x72, 0x8F, 0x0D, 0xA6, 0xDD,\n\t0x02, 0x49, 0x5B, 0x69, 0xD6, 0x96, 0x05, 0xBE, 0x5E, 0x9B, 0x09, 0x83,\n\t0xD8, 0xF3, 0x91, 0x55, 0x30, 0x86, 0x97, 0x6C, 0x48, 0x7B, 0x99, 0x82,\n\t0xCC, 0x1E, 0x1E, 0x25, 0xE6, 0x25, 0xCC, 0xA3, 0x66, 0xDE, 0x8A, 0x78,\n\t0xEE, 0x7F, 0x4F, 0x86, 0x95, 0x06, 0xBE, 0x64, 0x86, 0xFD, 0x60, 0x6A,\n\t0x3F, 0x0D, 0x8F, 0x62, 0x17, 0x89, 0xDB, 0xE1, 0x01, 0xC1, 0x75, 0x3A,\n\t0x78, 0x42, 0xA8, 0x26, 0xEC, 0x00, 0x78, 0xF3, 0xDA, 0x40, 0x8D, 0x0D,\n\t0x4D, 0x53, 0x82, 0xD7, 0x21, 0xC8, 0x46, 0xC9, 0xE3, 0x80, 0xB4, 0xCF,\n\t0xEA, 0x46, 0x85, 0xE9, 0xC4, 0x9D, 0xD0, 0xC0, 0x4D, 0x27, 0x0F, 0xF8,\n\t0x34, 0x3B, 0x86, 0x8F, 0xFC, 0x40, 0x56, 0x49, 0x64, 0x76, 0x61, 0xBC,\n\t0x35, 0x6A, 0xB8, 0xC5, 0x32, 0x19, 0x00, 0x5E, 0x21, 0x1C, 0x34, 0xCB,\n\t0x74, 0x5B, 0x60, 0x85, 0x8C, 0x38, 0x52, 0x50, 0x4D, 0xAA, 0x25, 0xE4,\n\t0x1A, 0xE6, 0xE4, 0xDF, 0x0A, 0xD2, 0x8F, 0x2B, 0xD1, 0x35, 0xC7, 0x92,\n\t0x7D, 0x6F, 0x54, 0x61, 0x8E, 0x3F, 0xFB, 0xE2, 0xC8, 0x81, 0xD0, 0xAC,\n\t0x64, 0xE2, 0xA8, 0x30, 0xEA, 0x8E, 0xAD, 0xFE, 0xC0, 0x9E, 0x0B, 0xBF,\n\t0x34, 0xAC, 0x79, 0x96, 0x38, 0x31, 0x1E, 0xEA, 0xF2, 0x7E, 0xEE, 0x0A,\n\t0x10, 0x34, 0x7C, 0x1A, 0x30, 0x5F, 0xAF, 0x96, 0x2F, 0x7F, 0xB5, 0x1D,\n\t0xA7, 0x3D, 0x35, 0x7A, 0x30, 0x70, 0x40, 0xE7, 0xD6, 0x22, 0x1E, 0xD0,\n\t0x9A, 0x34, 0xC7, 0x6B, 0xE4, 0xF1, 0x78, 0xED, 0xD9, 0xCD, 0x18, 0xBF,\n\t0x2A, 0x1A, 0x98, 0xB7, 0x6C, 0x6E, 0x18, 0x40, 0xB5, 0xBE, 0xDF, 0xE4,\n\t0x78, 0x8E, 0x34, 0xB2, 0x7B, 0xE5, 0x88, 0xE6, 0xFD, 0x24, 0xBD, 0xBB,\n\t0x2E, 0x30, 0x72, 0x54, 0xC7, 0xF4, 0xA0, 0xF1, 0x25, 0xFF, 0xB1, 0x37,\n\t0x42, 0x07, 0x8C, 0xF2, 0xB9, 0xA1, 0xA4, 0xA7, 0x76, 0x39, 0xB8, 0x11,\n\t0x17, 0xF3, 0xA8, 0x2E, 0x78, 0x68, 0xF4, 0xBF, 0x98, 0x25, 0x59, 0x17,\n\t0x59, 0x9B, 0x0D, 0x0B, 0x9B, 0xE3, 0x0F, 0xFF, 0xDC, 0xC8, 0x47, 0x21,\n\t0xE1, 0x0B, 0x9A, 0x44, 0x79, 0xC7, 0x5F, 0x8E, 0x83, 0x1E, 0x04, 0xA1,\n\t0xB2, 0x9F, 0x9B, 0xFC, 0xB3, 0x4E, 0xD9, 0xF9, 0x8F, 0x03, 0xBC, 0x0A,\n\t0x04, 0x00, 0x5C, 0x59, 0xB7, 0x51, 0xAA, 0x75, 0xF8, 0x7A, 0x03, 0x07,\n\t0x81, 0x6D, 0x67, 0x3E, 0x28, 0x37, 0xE4, 0x74, 0x5B, 0x8C, 0x2A, 0x4B,\n\t0x6C, 0x10, 0x92, 0x75, 0xA5, 0x79, 0x4B, 0x6D, 0x30, 0xB7, 0x6E, 0xD6,\n\t0x9E, 0x16, 0xC2, 0x87, 0x69, 0x34, 0xFE, 0xD7, 0x2A, 0x4F, 0xD6, 0xC0,\n\t0xF3, 0xCD, 0x9C, 0x46, 0xED, 0xC0, 0xB2, 0x84, 0x8D, 0x7E, 0x93, 0xD2,\n\t0xE9, 0xBE, 0x59, 0x18, 0x92, 0xC1, 0x2C, 0xD6, 0x6C, 0x71, 0x50, 0xA1,\n\t0x98, 0xDA, 0xD1, 0xAC, 0xDB, 0x88, 0x40, 0x1F, 0x69, 0xDC, 0xDB, 0xB2,\n\t0xA0, 0x90, 0x01, 0x8E, 0x12, 0xD6, 0x40, 0x1A, 0x8E, 0xC5, 0x69, 0x9C,\n\t0x91, 0x67, 0xAC, 0xD8, 0x4C, 0x27, 0xCD, 0x08, 0xB8, 0x32, 0x97, 0xE1,\n\t0x13, 0x0C, 0xFF, 0xB1, 0x06, 0x65, 0x03, 0x98, 0x6F, 0x9E, 0xF7, 0xB8,\n\t0xA8, 0x75, 0xBA, 0x59, 0xFD, 0x23, 0x98, 0x94, 0x80, 0x9C, 0xA7, 0x46,\n\t0x32, 0x98, 0x28, 0x7A, 0x0A, 0x3A, 0xA6, 0x95, 0x16, 0x6A, 0x52, 0x8E,\n\t0x8F, 0x2C, 0xC9, 0x49, 0xB7, 0x59, 0x99, 0x2A, 0xE6, 0xCA, 0x82, 0x88,\n\t0x36, 0xD3, 0x2B, 0xA4, 0x73, 0xFA, 0x89, 0xBB,\n};\n\n/*\n * OpenSSL temporary DH callback which loads DH parameters from static memory.\n */\nDH *\nssl_tmp_dh_callback(UNUSED SSL *s, int is_export, int keylength)\n{\n\tDH *dh;\n\tint rv = 0;\n\n\tif (!(dh = DH_new())) {\n\t\tlog_err_printf(\"DH_new() failed\\n\");\n\t\treturn NULL;\n\t}\n\tswitch (keylength) {\n\tcase 512:\n\t\trv = DH_set0_pqg(dh,\n\t\t                 BN_bin2bn(dh512_p, sizeof(dh512_p), NULL),\n\t\t                 NULL,\n\t\t                 BN_bin2bn(dh_g, sizeof(dh_g), NULL));\n\t\tbreak;\n\tcase 1024:\n\t\trv = DH_set0_pqg(dh,\n\t\t                 BN_bin2bn(dh1024_p, sizeof(dh1024_p), NULL),\n\t\t                 NULL,\n\t\t                 BN_bin2bn(dh_g, sizeof(dh_g), NULL));\n\t\tbreak;\n\tcase 2048:\n\t\trv = DH_set0_pqg(dh,\n\t\t                 BN_bin2bn(dh2048_p, sizeof(dh2048_p), NULL),\n\t\t                 NULL,\n\t\t                 BN_bin2bn(dh_g, sizeof(dh_g), NULL));\n\t\tbreak;\n\tcase 4096:\n\t\trv = DH_set0_pqg(dh,\n\t\t                 BN_bin2bn(dh4096_p, sizeof(dh4096_p), NULL),\n\t\t                 NULL,\n\t\t                 BN_bin2bn(dh_g, sizeof(dh_g), NULL));\n\t\tbreak;\n\tdefault:\n\t\tlog_err_printf(\"Unhandled DH keylength %i%s\\n\",\n\t\t               keylength,\n\t\t               (is_export ? \" (export)\" : \"\"));\n\t\tDH_free(dh);\n\t\treturn NULL;\n\t}\n\tif (!rv) {\n\t\tlog_err_printf(\"Failed to load DH p and g from memory\\n\");\n\t\tDH_free(dh);\n\t\treturn NULL;\n\t}\n\treturn(dh);\n}\n\n/*\n * Load DH parameters from a PEM file.\n * Not thread-safe.\n */\nDH *\nssl_dh_load(const char *filename)\n{\n\tDH *dh;\n\tFILE *fh;\n\n\tif (ssl_init() == -1)\n\t\treturn NULL;\n\n\tif (!(fh = fopen(filename, \"r\"))) {\n\t\treturn NULL;\n\t}\n\tdh = PEM_read_DHparams(fh, NULL, NULL, NULL);\n\tfclose(fh);\n\treturn dh;\n}\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_EC\n/*\n * Load an Elliptic Curve by name.  If curvename is NULL, a default curve is\n * loaded.\n */\nEC_KEY *\nssl_ec_by_name(const char *curvename)\n{\n\tint nid;\n\n\tif (!curvename)\n\t\tcurvename = DFLT_CURVE;\n\n\tif ((nid = OBJ_sn2nid(curvename)) == NID_undef) {\n\t\treturn NULL;\n\t}\n\treturn EC_KEY_new_by_curve_name(nid);\n}\n#endif /* !OPENSSL_NO_EC */\n\n/*\n * Add a X509v3 extension to a certificate and handle errors.\n * Returns -1 on errors, 0 on success.\n */\nint\nssl_x509_v3ext_add(X509V3_CTX *ctx, X509 *crt, char *k, char *v)\n{\n\tX509_EXTENSION *ext;\n\n\tif (!(ext = X509V3_EXT_conf(NULL, ctx, k, v))) {\n\t\treturn -1;\n\t}\n\tif (X509_add_ext(crt, ext, -1) != 1) {\n\t\tX509_EXTENSION_free(ext);\n\t\treturn -1;\n\t}\n\tX509_EXTENSION_free(ext);\n\treturn 0;\n}\n\n/*\n * Copy a X509v3 extension from one certificate to another.\n * If the extension is not present in the original certificate,\n * the extension will not be added to the destination certificate.\n * Returns 1 if ext was copied, 0 if not present in origcrt, -1 on error.\n */\nint\nssl_x509_v3ext_copy_by_nid(X509 *crt, X509 *origcrt, int nid)\n{\n\tX509_EXTENSION *ext;\n\tint pos;\n\n\tpos = X509_get_ext_by_NID(origcrt, nid, -1);\n\tif (pos == -1)\n\t\treturn 0;\n\text = X509_get_ext(origcrt, pos);\n\tif (!ext)\n\t\treturn -1;\n\tif (X509_add_ext(crt, ext, -1) != 1)\n\t\treturn -1;\n\treturn 1;\n}\n\n/*\n * Best effort randomness generator.\n * Not for real life cryptography applications.\n * Returns 0 on success, -1 on failure.\n */\nint\nssl_rand(void *p, size_t sz)\n{\n\tint rv;\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)\n\trv = RAND_pseudo_bytes((unsigned char*)p, sz);\n\tif (rv == 1)\n\t\treturn 0;\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\trv = RAND_bytes((unsigned char*)p, sz);\n\tif (rv == 1)\n\t\treturn 0;\n\treturn -1;\n}\n\n/*\n * Copy the serial number from src certificate to dst certificate\n * and modify it by a random offset.\n * If reading the serial fails for some reason, generate a new\n * random serial and store it in the dst certificate.\n * Using the same serial is not a good idea since some SSL stacks\n * check for duplicate certificate serials.\n * Returns 0 on success, -1 on error.\n */\nint\nssl_x509_serial_copyrand(X509 *dstcrt, X509 *srccrt)\n{\n\tASN1_INTEGER *srcptr, *dstptr;\n\tBIGNUM *bnserial;\n\tunsigned int rand;\n\tint rv;\n\n#ifndef PURIFY\n\trv = ssl_rand(&rand, sizeof(rand));\n#else /* PURIFY */\n\trand = 0xF001;\n\trv = 0;\n#endif /* PURIFY */\n\tdstptr = X509_get_serialNumber(dstcrt);\n\tsrcptr = X509_get_serialNumber(srccrt);\n\tif ((rv == -1) || !dstptr || !srcptr)\n\t\treturn -1;\n\tbnserial = ASN1_INTEGER_to_BN(srcptr, NULL);\n\tif (!bnserial) {\n\t\t/* random 32-bit serial */\n\t\tASN1_INTEGER_set(dstptr, rand);\n\t} else {\n\t\t/* original serial plus random 32-bit offset */\n\t\tBN_add_word(bnserial, rand);\n\t\tBN_to_ASN1_INTEGER(bnserial, dstptr);\n\t\tBN_free(bnserial);\n\t}\n\treturn 0;\n}\n\n/*\n * Returns the appropriate key usage strings for the type of server key.\n * Return value should conceptually be const, but OpenSSL does not use const\n * appropriately.\n */\nstatic char *\nssl_key_usage_for_key(EVP_PKEY *key)\n{\n\tswitch (EVP_PKEY_type(EVP_PKEY_base_id(key))) {\n#ifndef OPENSSL_NO_RSA\n\tcase EVP_PKEY_RSA:\n\t\treturn \"keyEncipherment,digitalSignature\";\n#endif /* !OPENSSL_NO_RSA */\n#ifndef OPENSSL_NO_DH\n\tcase EVP_PKEY_DH:\n\t\treturn \"keyAgreement\";\n#endif /* !OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_DSA\n\tcase EVP_PKEY_DSA:\n\t\treturn \"digitalSignature\";\n#endif /* !OPENSSL_NO_DSA */\n#ifndef OPENSSL_NO_ECDSA\n\tcase EVP_PKEY_EC:\n\t\treturn \"digitalSignature,keyAgreement\";\n#endif /* !OPENSSL_NO_ECDSA */\n\tdefault:\n\t\treturn \"keyEncipherment,keyAgreement,digitalSignature\";\n\t}\n}\n\n/*\n * Create a fake X509v3 certificate, signed by the provided CA,\n * based on the original certificate retrieved from the real server.\n * The returned certificate is created using X509_new() and thus must\n * be freed by the caller using X509_free().\n * The optional argument extraname is added to subjectAltNames if provided.\n */\nX509 *\nssl_x509_forge(X509 *cacrt, EVP_PKEY *cakey, X509 *origcrt, EVP_PKEY *key,\n               const char *extraname, const char *crlurl)\n{\n\tX509_NAME *subject, *issuer;\n\tGENERAL_NAMES *names;\n\tGENERAL_NAME *gn;\n\tX509 *crt;\n\tint rv;\n\n\tsubject = X509_get_subject_name(origcrt);\n\tissuer = X509_get_subject_name(cacrt);\n\tif (!subject || !issuer)\n\t\treturn NULL;\n\n\tcrt = X509_new();\n\tif (!crt)\n\t\treturn NULL;\n\n\tif (!X509_set_version(crt, 0x02) ||\n\t    !X509_set_subject_name(crt, subject) ||\n\t    !X509_set_issuer_name(crt, issuer) ||\n\t    ssl_x509_serial_copyrand(crt, origcrt) == -1 ||\n\t    !X509_gmtime_adj(X509_get_notBefore(crt), (long)-60*60*24) ||\n\t    !X509_gmtime_adj(X509_get_notAfter(crt), (long)60*60*24*364) ||\n\t    !X509_set_pubkey(crt, key))\n\t\tgoto errout;\n\n\t/* add standard v3 extensions; cf. RFC 2459 */\n\n\tX509V3_CTX ctx;\n\tX509V3_set_ctx(&ctx, cacrt, crt, NULL, NULL, 0);\n\tif (ssl_x509_v3ext_add(&ctx, crt, \"subjectKeyIdentifier\",\n\t                                  \"hash\") == -1 ||\n\t    ssl_x509_v3ext_add(&ctx, crt, \"authorityKeyIdentifier\",\n\t                                  \"keyid,issuer:always\") == -1)\n\t\tgoto errout;\n\n\trv = ssl_x509_v3ext_copy_by_nid(crt, origcrt,\n\t                                NID_basic_constraints);\n\tif (rv == 0)\n\t\trv = ssl_x509_v3ext_add(&ctx, crt, \"basicConstraints\",\n\t\t                                   \"CA:FALSE\");\n\tif (rv == -1)\n\t\tgoto errout;\n\n\t/* key usage depends on the key type, do not copy from original */\n\trv = ssl_x509_v3ext_add(&ctx, crt, \"keyUsage\",\n\t                        ssl_key_usage_for_key(key));\n\tif (rv == -1)\n\t\tgoto errout;\n\n\trv = ssl_x509_v3ext_copy_by_nid(crt, origcrt,\n\t                                NID_ext_key_usage);\n\tif (rv == 0)\n\t\trv = ssl_x509_v3ext_add(&ctx, crt, \"extendedKeyUsage\",\n\t\t                                   \"serverAuth\");\n\tif (rv == -1)\n\t\tgoto errout;\n\n\tif (crlurl) {\n\t\tchar *crlurlval;\n\t\tif (asprintf(&crlurlval, \"URI:%s\", crlurl) < 0)\n\t\t\tgoto errout;\n\t\tif (ssl_x509_v3ext_add(&ctx, crt, \"crlDistributionPoints\",\n\t\t                       crlurlval) == -1) {\n\t\t\tfree(crlurlval);\n\t\t\tgoto errout;\n\t\t}\n\t\tfree(crlurlval);\n\t}\n\n\tif (!extraname) {\n\t\t/* no extraname provided: copy original subjectAltName ext */\n\t\tif (ssl_x509_v3ext_copy_by_nid(crt, origcrt,\n\t\t                               NID_subject_alt_name) == -1)\n\t\t\tgoto errout;\n\t} else {\n\t\tnames = X509_get_ext_d2i(origcrt, NID_subject_alt_name, 0, 0);\n\t\tif (!names) {\n\t\t\t/* no subjectAltName present: add new one */\n\t\t\tchar *cfval;\n\t\t\tif (asprintf(&cfval, \"DNS:%s\", extraname) < 0)\n\t\t\t\tgoto errout;\n\t\t\tif (ssl_x509_v3ext_add(&ctx, crt, \"subjectAltName\",\n\t\t\t                       cfval) == -1) {\n\t\t\t\tfree(cfval);\n\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\tfree(cfval);\n\t\t} else {\n\t\t\t/* add extraname to original subjectAltName\n\t\t\t * and add it to the new certificate */\n\t\t\tgn = GENERAL_NAME_new();\n\t\t\tif (!gn)\n\t\t\t\tgoto errout2;\n\t\t\tgn->type = GEN_DNS;\n\t\t\tgn->d.dNSName = ASN1_IA5STRING_new();\n\t\t\tif (!gn->d.dNSName)\n\t\t\t\tgoto errout3;\n\t\t\tASN1_STRING_set(gn->d.dNSName,\n\t\t\t                (unsigned char *)extraname,\n\t\t\t                strlen(extraname));\n\t\t\tsk_GENERAL_NAME_push(names, gn);\n\t\t\tX509_EXTENSION *ext = X509V3_EXT_i2d(\n\t\t\t                      NID_subject_alt_name, 0, names);\n\t\t\tif (!X509_add_ext(crt, ext, -1)) {\n\t\t\t\tif (ext) {\n\t\t\t\t\tX509_EXTENSION_free(ext);\n\t\t\t\t}\n\t\t\t\tgoto errout3;\n\t\t\t}\n\t\t\tX509_EXTENSION_free(ext);\n\t\t\tsk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\n\t\t}\n\t}\n#ifdef DEBUG_CERTIFICATE\n\tssl_x509_v3ext_add(&ctx, crt, \"nsComment\", \"Generated by \" PKGLABEL);\n#endif /* DEBUG_CERTIFICATE */\n\n\tconst EVP_MD *md;\n\tswitch (EVP_PKEY_type(EVP_PKEY_base_id(cakey))) {\n#ifndef OPENSSL_NO_RSA\n\tcase EVP_PKEY_RSA:\n\t\tswitch (X509_get_signature_nid(origcrt)) {\n\t\tcase NID_md5WithRSAEncryption:\n\t\t\tmd = EVP_md5();\n\t\t\tbreak;\n\t\tcase NID_ripemd160WithRSA:\n\t\t\tmd = EVP_ripemd160();\n\t\t\tbreak;\n\t\tcase NID_sha1WithRSAEncryption:\n\t\t\tmd = EVP_sha1();\n\t\t\tbreak;\n\t\tcase NID_sha224WithRSAEncryption:\n\t\t\tmd = EVP_sha224();\n\t\t\tbreak;\n\t\tcase NID_sha256WithRSAEncryption:\n\t\t\tmd = EVP_sha256();\n\t\t\tbreak;\n\t\tcase NID_sha384WithRSAEncryption:\n\t\t\tmd = EVP_sha384();\n\t\t\tbreak;\n\t\tcase NID_sha512WithRSAEncryption:\n\t\t\tmd = EVP_sha512();\n\t\t\tbreak;\n#ifndef OPENSSL_NO_SHA0\n\t\tcase NID_shaWithRSAEncryption:\n\t\t\tmd = EVP_sha();\n\t\t\tbreak;\n#endif /* !OPENSSL_NO_SHA0 */\n\t\tdefault:\n\t\t\tmd = EVP_sha256();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* !OPENSSL_NO_RSA */\n#ifndef OPENSSL_NO_DSA\n\tcase EVP_PKEY_DSA:\n\t\tswitch (X509_get_signature_nid(origcrt)) {\n\t\tcase NID_dsaWithSHA1:\n\t\tcase NID_dsaWithSHA1_2:\n\t\t\tmd = EVP_sha1();\n\t\t\tbreak;\n\t\tcase NID_dsa_with_SHA224:\n\t\t\tmd = EVP_sha224();\n\t\t\tbreak;\n\t\tcase NID_dsa_with_SHA256:\n\t\t\tmd = EVP_sha256();\n\t\t\tbreak;\n#ifndef OPENSSL_NO_SHA0\n\t\tcase NID_dsaWithSHA:\n\t\t\tmd = EVP_sha();\n\t\t\tbreak;\n#endif /* !OPENSSL_NO_SHA0 */\n\t\tdefault:\n\t\t\tmd = EVP_sha256();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* !OPENSSL_NO_DSA */\n#ifndef OPENSSL_NO_ECDSA\n\tcase EVP_PKEY_EC:\n\t\tswitch (X509_get_signature_nid(origcrt)) {\n\t\tcase NID_ecdsa_with_SHA1:\n\t\t\tmd = EVP_sha1();\n\t\t\tbreak;\n\t\tcase NID_ecdsa_with_SHA224:\n\t\t\tmd = EVP_sha224();\n\t\t\tbreak;\n\t\tcase NID_ecdsa_with_SHA256:\n\t\t\tmd = EVP_sha256();\n\t\t\tbreak;\n\t\tcase NID_ecdsa_with_SHA384:\n\t\t\tmd = EVP_sha384();\n\t\t\tbreak;\n\t\tcase NID_ecdsa_with_SHA512:\n\t\t\tmd = EVP_sha512();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmd = EVP_sha256();\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n#endif /* !OPENSSL_NO_ECDSA */\n\tdefault:\n\t\tgoto errout;\n\t}\n\tif (!X509_sign(crt, cakey, md))\n\t\tgoto errout;\n\n\treturn crt;\n\nerrout3:\n\tGENERAL_NAME_free(gn);\nerrout2:\n\tsk_GENERAL_NAME_pop_free(names, GENERAL_NAME_free);\nerrout:\n\tX509_free(crt);\n\treturn NULL;\n}\n\n/*\n * Load a X509 certificate chain from a PEM file.\n * Returns the first certificate in *crt and all subsequent certificates in\n * *chain.  If crt is NULL, the first certificate is prepended to *chain\n * instead of returned separately.  If *chain is NULL, a new stack of X509*\n * is created in *chain, else the certs are pushed onto an existing stack.\n * Returns -1 on error.\n * Not thread-safe.\n *\n * By accessing (SSLCTX*)->extra_certs directly on OpenSSL before 1.0.2, we\n * depend on OpenSSL internals in this function.  OpenSSL 1.0.2 introduced\n * the SSL_get0_chain_certs() API for accessing the certificate chain.\n */\nint\nssl_x509chain_load(X509 **crt, STACK_OF(X509) **chain, const char *filename)\n{\n\tX509 *tmpcrt;\n\tSSL_CTX *tmpctx;\n\tSSL *tmpssl;\n\tSTACK_OF(X509) *tmpchain;\n\tint rv;\n\n\tif (ssl_init() == -1)\n\t\treturn -1;\n\n\ttmpctx = SSL_CTX_new(SSLv23_server_method());\n\tif (!tmpctx)\n\t\tgoto leave1;\n\n\trv = SSL_CTX_use_certificate_chain_file(tmpctx, filename);\n\tif (rv != 1)\n\t\tgoto leave2;\n\ttmpssl = SSL_new(tmpctx);\n\tif (!tmpssl)\n\t\tgoto leave2;\n\n\ttmpcrt = SSL_get_certificate(tmpssl);\n\tif (!tmpcrt)\n\t\tgoto leave3;\n\n\tif (!*chain) {\n\t\t*chain = sk_X509_new_null();\n\t\tif (!*chain)\n\t\t\tgoto leave3;\n\t}\n\n#if (OPENSSL_VERSION_NUMBER < 0x1000200fL) || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20902000L)\n\ttmpchain = tmpctx->extra_certs;\n#else /* OpenSSL >= 1.0.2 || LIBRESSL_VERSION_NUMBER >= 0x20902000L */\n\trv = SSL_CTX_get0_chain_certs(tmpctx, &tmpchain);\n\tif (rv != 1)\n\t\tgoto leave3;\n#endif /* OpenSSL >= 1.0.2 */\n\n\tif (crt) {\n\t\t*crt = tmpcrt;\n\t} else {\n\t\tsk_X509_push(*chain, tmpcrt);\n\t}\n\tssl_x509_refcount_inc(tmpcrt);\n\n\tfor (int i = 0; i < sk_X509_num(tmpchain); i++) {\n\t\ttmpcrt = sk_X509_value(tmpchain, i);\n\t\tssl_x509_refcount_inc(tmpcrt);\n\t\tsk_X509_push(*chain, tmpcrt);\n\t}\n\tSSL_free(tmpssl);\n\tSSL_CTX_free(tmpctx);\n\treturn 0;\n\nleave3:\n\tSSL_free(tmpssl);\nleave2:\n\tSSL_CTX_free(tmpctx);\nleave1:\n\treturn -1;\n}\n\n/*\n * Use a X509 certificate chain for an SSL context.\n * Copies the certificate stack to the SSL_CTX internal data structures\n * and increases reference counts accordingly.\n */\nint\nssl_x509chain_use(SSL_CTX *sslctx, X509 *crt, STACK_OF(X509) *chain)\n{\n\tif (SSL_CTX_use_certificate(sslctx, crt) != 1)\n\t\treturn -1;\n\n\tfor (int i = 0; i < sk_X509_num(chain); i++) {\n\t\tX509 *tmpcrt;\n\n\t\ttmpcrt = sk_X509_value(chain, i);\n\t\tssl_x509_refcount_inc(tmpcrt);\n\t\tif (SSL_CTX_add_extra_chain_cert(sslctx, tmpcrt) != 1)\n\t\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Load a X509 certificate from a PEM file.\n * Returned X509 must be freed using X509_free() by the caller.\n * Not thread-safe.\n */\nX509 *\nssl_x509_load(const char *filename)\n{\n\tX509 *crt = NULL;\n\tSSL_CTX *tmpctx;\n\tSSL *tmpssl;\n\tint rv;\n\n\tif (ssl_init() == -1)\n\t\treturn NULL;\n\n\ttmpctx = SSL_CTX_new(SSLv23_server_method());\n\tif (!tmpctx)\n\t\tgoto leave1;\n\trv = SSL_CTX_use_certificate_file(tmpctx, filename, SSL_FILETYPE_PEM);\n\tif (rv != 1)\n\t\tgoto leave2;\n\ttmpssl = SSL_new(tmpctx);\n\tif (!tmpssl)\n\t\tgoto leave2;\n\tcrt = SSL_get_certificate(tmpssl);\n\tif (crt)\n\t\tssl_x509_refcount_inc(crt);\n\tSSL_free(tmpssl);\nleave2:\n\tSSL_CTX_free(tmpctx);\nleave1:\n\treturn crt;\n}\n\n/*\n * Load a private key from a PEM file.\n * Returned EVP_PKEY must be freed using EVP_PKEY_free() by the caller.\n * Not thread-safe.\n */\nEVP_PKEY *\nssl_key_load(const char *filename)\n{\n\tEVP_PKEY *key = NULL;\n\tSSL_CTX *tmpctx;\n\tSSL *tmpssl;\n\tint rv;\n\n\tif (ssl_init() == -1)\n\t\treturn NULL;\n\n\ttmpctx = SSL_CTX_new(SSLv23_server_method());\n\tif (!tmpctx)\n\t\tgoto leave1;\n\trv = SSL_CTX_use_PrivateKey_file(tmpctx, filename, SSL_FILETYPE_PEM);\n\tif (rv != 1)\n\t\tgoto leave2;\n\ttmpssl = SSL_new(tmpctx);\n\tif (!tmpssl)\n\t\tgoto leave2;\n\tkey = SSL_get_privatekey(tmpssl);\n\tif (key)\n\t\tssl_key_refcount_inc(key);\n\tSSL_free(tmpssl);\nleave2:\n\tSSL_CTX_free(tmpctx);\nleave1:\n\treturn key;\n}\n\n/*\n * Generate a new RSA key.\n * Returned EVP_PKEY must be freed using EVP_PKEY_free() by the caller.\n */\nEVP_PKEY *\nssl_key_genrsa(const int keysize)\n{\n\tEVP_PKEY *pkey;\n\tRSA *rsa;\n\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER)\n\tBIGNUM *bn;\n\tint rv;\n\trsa = RSA_new();\n\tbn = BN_new();\n\tBN_dec2bn(&bn, \"3\");\n\trv = RSA_generate_key_ex(rsa, keysize, bn, NULL);\n\tBN_free(bn);\n\tif (rv != 1) {\n\t\tRSA_free(rsa);\n\t\treturn NULL;\n\t}\n#else /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\trsa = RSA_generate_key(keysize, 3, NULL, NULL);\n\tif (!rsa)\n\t\treturn NULL;\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\tpkey = EVP_PKEY_new();\n\tEVP_PKEY_assign_RSA(pkey, rsa); /* does not increment refcount */\n\treturn pkey;\n}\n\n/*\n * Returns the subjectKeyIdentifier compatible key id of the public key.\n * keyid will receive a binary SHA-1 hash of SSL_KEY_IDSZ bytes.\n * Returns 0 on success, -1 on failure.\n */\nint\nssl_key_identifier_sha1(EVP_PKEY *key, unsigned char *keyid)\n{\n\tX509_PUBKEY *pubkey = NULL;\n\tconst unsigned char *pk;\n\tint length;\n\n\t/* X509_PUBKEY_set() will attempt to free pubkey if != NULL */\n\tif (X509_PUBKEY_set(&pubkey, key) != 1 || !pubkey)\n\t\treturn -1;\n\tif (!X509_PUBKEY_get0_param(NULL, &pk, &length, NULL, pubkey))\n\t\tgoto errout;\n\tif (!EVP_Digest(pk, length, keyid, NULL, EVP_sha1(), NULL))\n\t\tgoto errout;\n\tX509_PUBKEY_free(pubkey);\n\treturn 0;\n\nerrout:\n\tX509_PUBKEY_free(pubkey);\n\treturn -1;\n}\n\n/*\n * Returns the result of ssl_key_identifier_sha1() as hex characters with or\n * without colons in a newly allocated string.\n */\nchar *\nssl_key_identifier(EVP_PKEY *key, int colons)\n{\n\tunsigned char id[SSL_KEY_IDSZ];\n\n\tif (ssl_key_identifier_sha1(key, id) == -1)\n\t\treturn NULL;\n\n\treturn ssl_sha1_to_str(id, colons);\n}\n\n/*\n * Returns the one-line representation of the subject DN in a newly allocated\n * string which must be freed by the caller.\n */\nchar *\nssl_x509_subject(X509 *crt)\n{\n\treturn X509_NAME_oneline(X509_get_subject_name(crt), NULL, 0);\n}\n\n/*\n * Parse the common name from the subject distinguished name.\n * Returns string allocated using malloc(), caller must free().\n * Returns NULL on errors.\n */\nchar *\nssl_x509_subject_cn(X509 *crt, size_t *psz)\n{\n\tX509_NAME *ptr;\n\tchar *cn;\n\tsize_t sz;\n\n\tptr = X509_get_subject_name(crt); /* does not inc refcounts */\n\tif (!ptr)\n\t\treturn NULL;\n\tsz = X509_NAME_get_text_by_NID(ptr, NID_commonName, NULL, 0) + 1;\n\tif ((sz == 0) || !(cn = malloc(sz)))\n\t\treturn NULL;\n\tif (X509_NAME_get_text_by_NID(ptr, NID_commonName, cn, sz) == -1) {\n\t\tfree(cn);\n\t\treturn NULL;\n\t}\n\t*psz = sz;\n\treturn cn;\n}\n\n/*\n * Write the SHA1 fingerprint of certificate to fpr as SSL_X509_FPRSZ (20)\n * bytes long binary buffer.\n * Returns -1 on error, 0 on success.\n */\nint\nssl_x509_fingerprint_sha1(X509 *crt, unsigned char *fpr)\n{\n\tunsigned int sz = SSL_X509_FPRSZ;\n\n\treturn X509_digest(crt, EVP_sha1(), fpr, &sz) ? 0 : -1;\n}\n\n/*\n * Returns the result of ssl_x509_fingerprint_sha1() as hex characters with or\n * without colons in a newly allocated string.\n */\nchar *\nssl_x509_fingerprint(X509 *crt, int colons)\n{\n\tunsigned char fpr[SSL_X509_FPRSZ];\n\n\tif (ssl_x509_fingerprint_sha1(crt, fpr) == -1)\n\t\treturn NULL;\n\n\treturn ssl_sha1_to_str(fpr, colons);\n}\n\n#ifndef OPENSSL_NO_DH\n/*\n * Increment the reference count of DH parameters in a thread-safe\n * manner.\n */\nvoid\nssl_dh_refcount_inc(DH *dh)\n{\n#if defined(OPENSSL_THREADS) && ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tCRYPTO_add(&dh->references, 1, CRYPTO_LOCK_DH);\n#else /* !OPENSSL_THREADS */\n\tDH_up_ref(dh);\n#endif /* !OPENSSL_THREADS */\n}\n#endif /* !OPENSSL_NO_DH */\n\n/*\n * Increment the reference count of an X509 certificate in a thread-safe\n * manner.\n */\nvoid\nssl_key_refcount_inc(EVP_PKEY *key)\n{\n#if defined(OPENSSL_THREADS) && ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tCRYPTO_add(&key->references, 1, CRYPTO_LOCK_EVP_PKEY);\n#else /* !OPENSSL_THREADS */\n\tEVP_PKEY_up_ref(key);\n#endif /* !OPENSSL_THREADS */\n}\n\n/*\n * Increment the reference count of an X509 certificate in a thread-safe\n * manner.  This differs from X509_dup() in that it does not create new,\n * full copy of the certificate, but only increases the reference count.\n */\nvoid\nssl_x509_refcount_inc(X509 *crt)\n{\n#if defined(OPENSSL_THREADS) && ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER))\n\tCRYPTO_add(&crt->references, 1, CRYPTO_LOCK_X509);\n#else /* !OPENSSL_THREADS */\n\tX509_up_ref(crt);\n#endif /* !OPENSSL_THREADS */\n}\n\n/*\n * Match a URL/URI hostname against a single certificate DNS name\n * using RFC 6125 rules (6.4.3 Checking of Wildcard Certificates):\n *\n *   1.  The client SHOULD NOT attempt to match a presented identifier in\n *       which the wildcard character comprises a label other than the\n *       left-most label (e.g., do not match bar.*.example.net).\n *\n *   2.  If the wildcard character is the only character of the left-most\n *       label in the presented identifier, the client SHOULD NOT compare\n *       against anything but the left-most label of the reference\n *       identifier (e.g., *.example.com would match foo.example.com but\n *       not bar.foo.example.com or example.com).\n *\n *   3.  The client MAY match a presented identifier in which the wildcard\n *       character is not the only character of the label (e.g.,\n *       baz*.example.net and *baz.example.net and b*z.example.net would\n *       be taken to match baz1.example.net and foobaz.example.net and\n *       buzz.example.net, respectively).  However, the client SHOULD NOT\n *       attempt to match a presented identifier where the wildcard\n *       character is embedded within an A-label or U-label [IDNA-DEFS] of\n *       an internationalized domain name [IDNA-PROTO].\n *\n * The optional partial matching in rule 3 is not implemented.\n * Returns 1 on match, 0 on no match.\n */\nint\nssl_dnsname_match(const char *certname, size_t certnamesz,\n                  const char *hostname, size_t hostnamesz)\n{\n\tif (hostnamesz < certnamesz)\n\t\treturn 0;\n\tif ((hostnamesz == certnamesz) &&\n\t    !memcmp(certname, hostname, certnamesz))\n\t\treturn 1;\n\tif (!memcmp(certname, \"xn--\", 4))\n\t\treturn 0;\n\tif ((certnamesz == 1) && (certname[0] == '*') &&\n\t    !memchr(hostname, '.', hostnamesz))\n\t\treturn 1;\n\tif ((certnamesz > 2) && (certname[0] == '*') && (certname[1] == '.') &&\n\t    !memcmp(&certname[1],\n\t            &hostname[hostnamesz - (certnamesz - 1)],\n\t            certnamesz - 1) &&\n\t    (memchr(hostname, '.', hostnamesz) ==\n\t     &hostname[hostnamesz - (certnamesz - 1)]))\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Transform a NULL-terminated hostname into a matching wildcard hostname,\n * e.g. \"test.example.org\" -> \"*.example.org\".\n * Returns string which must be free()'d by the caller, or NULL on error.\n */\nchar *\nssl_wildcardify(const char *hostname)\n{\n\tchar *dot, *wildcarded;\n\tsize_t dotsz;\n\n\tif (!(dot = strchr(hostname, '.')))\n\t\treturn strdup(\"*\");\n\tdotsz = strlen(dot);\n\tif (!(wildcarded = malloc(dotsz + 2)))\n\t\treturn NULL;\n\twildcarded[0] = '*';\n\tfor (size_t i = 0; i < dotsz; i++) {\n\t\twildcarded[i+1] = dot[i];\n\t}\n\twildcarded[dotsz+1] = '\\0';\n\treturn wildcarded;\n}\n\n/*\n * Match DNS name against certificate subject CN and subjectAltNames DNS names.\n * Returns 1 if any name matches, 0 if none matches.\n */\nint\nssl_x509_names_match(X509 *crt, const char *dnsname)\n{\n\tGENERAL_NAMES *altnames;\n\tchar *cn;\n\tsize_t cnsz, dnsnamesz;\n\n\tdnsnamesz = strlen(dnsname);\n\n\tcn = ssl_x509_subject_cn(crt, &cnsz);\n\tif (cn && ssl_dnsname_match(cn, cnsz, dnsname, dnsnamesz)) {\n\t\tfree(cn);\n\t\treturn 1;\n\t}\n\tif (cn) {\n\t\tfree(cn);\n\t}\n\n\taltnames = X509_get_ext_d2i(crt, NID_subject_alt_name, 0, 0);\n\tif (!altnames)\n\t\treturn 0;\n\tfor (int i = 0; i < sk_GENERAL_NAME_num(altnames); i++) {\n\t\tGENERAL_NAME *gn = sk_GENERAL_NAME_value(altnames, i);\n\t\tif (gn->type == GEN_DNS) {\n\t\t\tunsigned char *altname;\n\t\t\tint altnamesz;\n\t\t\tASN1_STRING_to_UTF8(&altname, gn->d.dNSName);\n\t\t\taltnamesz = ASN1_STRING_length(gn->d.dNSName);\n\t\t\tif (altnamesz < 0)\n\t\t\t\tbreak;\n\t\t\tif (ssl_dnsname_match((char *)altname,\n\t\t\t                      (size_t)altnamesz,\n\t\t\t                      dnsname, dnsnamesz)) {\n\t\t\t\tOPENSSL_free((char*)altname);\n\t\t\t\tGENERAL_NAMES_free(altnames);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tOPENSSL_free((char*)altname);\n\t\t}\n\t}\n\tGENERAL_NAMES_free(altnames);\n\treturn 0;\n}\n\n/*\n * Returns a NULL terminated array of pointers to all common names found\n * in the Subject DN CN and subjectAltNames extension (DNSName only).\n * Caller must free returned buffer and all pointers within.\n * Embedded NULL characters in hostnames are replaced with '!'.\n */\nchar **\nssl_x509_names(X509 *crt)\n{\n\tGENERAL_NAMES *altnames;\n\tchar *cn;\n\tsize_t cnsz;\n\tchar **res, **p;\n\tsize_t count;\n\n\tcn = ssl_x509_subject_cn(crt, &cnsz);\n\taltnames = X509_get_ext_d2i(crt, NID_subject_alt_name, NULL, NULL);\n\n\tcount = (altnames ? sk_GENERAL_NAME_num(altnames) : 0) + (cn ? 2 : 1);\n\tres = malloc(count * sizeof(char*));\n\tif (!res) {\n\t\tfree(cn);\n\t\treturn NULL;\n\t}\n\tp = res;\n\tif (cn)\n\t\t*(p++) = cn;\n\tif (!altnames) {\n\t\t*p = NULL;\n\t\treturn res;\n\t}\n\tfor (int i = 0; i < sk_GENERAL_NAME_num(altnames); i++) {\n\t\tGENERAL_NAME *gn = sk_GENERAL_NAME_value(altnames, i);\n\t\tif (gn->type == GEN_DNS) {\n\t\t\tunsigned char *altname;\n\t\t\tint altnamesz;\n\n\t\t\tASN1_STRING_to_UTF8(&altname, gn->d.dNSName);\n\t\t\tif (!altname)\n\t\t\t\tbreak;\n\t\t\taltnamesz = ASN1_STRING_length(gn->d.dNSName);\n\t\t\tif (altnamesz < 0) {\n\t\t\t\tOPENSSL_free((char*)altname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*p = malloc(altnamesz + 1);\n\t\t\tif (!*p) {\n\t\t\t\tOPENSSL_free((char*)altname);\n\t\t\t\tGENERAL_NAMES_free(altnames);\n\t\t\t\tfor (p = res; *p; p++)\n\t\t\t\t\tfree(*p);\n\t\t\t\tfree(res);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (int j = 0; j < altnamesz; j++) {\n\t\t\t\t(*p)[j] = altname[j] ? altname[j] : '!';\n\t\t\t}\n\t\t\t(*p)[altnamesz] = '\\0';\n\t\t\tOPENSSL_free((char*)altname);\n\t\t\tp++;\n\t\t}\n\t}\n\t*p = NULL;\n\tGENERAL_NAMES_free(altnames);\n\treturn res;\n}\n\n/*\n * Returns a printable representation of a certificate's common names found\n * in the Subject DN CN and subjectAltNames extension, separated by slashes.\n * Caller must free returned buffer.\n * Embedded NULL characters in hostnames are replaced with '!'.\n * If no CN and no subjectAltNames are found, returns \"-\".\n */\nchar *\nssl_x509_names_to_str(X509 *crt)\n{\n\tchar **names;\n\tsize_t sz;\n\tchar *buf = NULL, *next;\n\n\tnames = ssl_x509_names(crt);\n\tif (!names)\n\t\treturn strdup(\"-\");\n\n\tsz = 0;\n\tfor (char **p = names; *p; p++) {\n\t\tsz += strlen(*p) + 1;\n\t}\n\tif (!sz) {\n\t\tbuf = strdup(\"-\");\n\t\tgoto out1;\n\t}\n\n\tif (!(buf = malloc(sz)))\n\t\tgoto out2;\n\tnext = buf;\n\tfor (char **p = names; *p; p++) {\n\t\tchar *src = *p;\n\t\twhile (*src) {\n\t\t\t*next++ = *src++;\n\t\t}\n\t\t*next++ = '/';\n\t}\n\t*--next = '\\0';\nout2:\n\tfor (char **p = names; *p; p++)\n\t\tfree(*p);\nout1:\n\tfree(names);\n\treturn buf;\n}\n\n/*\n * Returns a zero-terminated buffer containing the ASN1 IA5 string.\n * Returned buffer must be free()'d by caller.\n */\nstatic char *\nssl_ia5string_strdup(ASN1_IA5STRING *ia5)\n{\n\tchar *str;\n\n\tif (!ia5 || !ia5->length)\n\t\treturn NULL;\n\tstr = malloc(ia5->length + 1);\n\tif (!str)\n\t\treturn NULL;\n\tmemcpy(str, ia5->data, ia5->length);\n\tstr[ia5->length] = 0;\n\treturn str;\n}\n\n/*\n * Returns a NULL terminated array of pointers to copies of Authority\n * Information Access (AIA) URLs of a given type contained in the certificate.\n * Caller must free returned buffer and all pointers within.\n */\nchar **\nssl_x509_aias(X509 *crt, const int type)\n{\n\tAUTHORITY_INFO_ACCESS *aias;\n\tchar **res;\n\tint count, i, j;\n\n\taias = X509_get_ext_d2i(crt, NID_info_access, NULL, NULL);\n\tif (!aias || !(count = sk_ACCESS_DESCRIPTION_num(aias)))\n\t\treturn NULL;\n\n\tres = malloc((count + 1) * sizeof(char *));\n\tif (!res) {\n\t\tsk_ACCESS_DESCRIPTION_pop_free(aias, ACCESS_DESCRIPTION_free);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0, j = 0; i < count; i++) {\n\t\tACCESS_DESCRIPTION *aia;\n\n\t\taia = sk_ACCESS_DESCRIPTION_value(aias, i);\n\t\tif (aia &&\n\t\t    OBJ_obj2nid(aia->method) == type &&\n\t\t    aia->location->type == GEN_URI) {\n\t\t\tres[j] = ssl_ia5string_strdup(aia->location->d.ia5);\n\t\t\tif (res[j])\n\t\t\t\tj++;\n\t\t}\n\t}\n\tres[j] = NULL;\n\tsk_ACCESS_DESCRIPTION_pop_free(aias, ACCESS_DESCRIPTION_free);\n\treturn res;\n}\n\n/*\n * Returns a NULL terminated array of pointers to copies of Authority\n * Information Access (AIA) URLs of type OCSP contained in the certificate.\n * Caller must free returned buffer and all pointers within.\n */\nchar **\nssl_x509_ocsps(X509 *crt)\n{\n\treturn ssl_x509_aias(crt, NID_ad_OCSP);\n}\n\n/*\n * Check whether the certificate is valid based on current time.\n * Return 1 if valid, 0 otherwise.\n */\nint\nssl_x509_is_valid(X509 *crt)\n{\n\tif (X509_cmp_current_time(X509_get_notAfter(crt)) <= 0)\n\t\treturn 0;\n\tif (X509_cmp_current_time(X509_get_notBefore(crt)) > 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n/*\n * Print X509 certificate data to a newly allocated string.\n * Caller must free returned string.\n * Returns NULL on errors.\n */\nchar *\nssl_x509_to_str(X509 *crt)\n{\n\tBIO *bio;\n\tchar *p, *ret;\n\tsize_t sz;\n\n\tbio = BIO_new(BIO_s_mem());\n\tif (!bio)\n\t\treturn NULL;\n\tX509_print(bio, crt);\n\tsz = BIO_get_mem_data(bio, &p);\n\tif (!(ret = malloc(sz + 1))) {\n\t\tBIO_free(bio);\n\t\treturn NULL;\n\t}\n\tmemcpy(ret, p, sz);\n\tret[sz] = '\\0';\n\tBIO_free(bio);\n\treturn ret;\n}\n\n/*\n * Convert X509 certificate to PEM format in a newly allocated string.\n * Caller must free returned string.\n * Returns NULL on errors.\n */\nchar *\nssl_x509_to_pem(X509 *crt)\n{\n\tBIO *bio;\n\tchar *p, *ret;\n\tsize_t sz;\n\n\tbio = BIO_new(BIO_s_mem());\n\tif (!bio)\n\t\treturn NULL;\n\tPEM_write_bio_X509(bio, crt);\n\tsz = BIO_get_mem_data(bio, &p);\n\tif (!(ret = malloc(sz + 1))) {\n\t\tBIO_free(bio);\n\t\treturn NULL;\n\t}\n\tmemcpy(ret, p, sz);\n\tret[sz] = '\\0';\n\tBIO_free(bio);\n\treturn ret;\n}\n\n/*\n * Print SSL_SESSION data to a newly allocated string.\n * Caller must free returned string.\n * Returns NULL on errors.\n */\nchar *\nssl_session_to_str(SSL_SESSION *sess)\n{\n\tBIO *bio;\n\tchar *p, *ret;\n\tsize_t sz;\n\n\tbio = BIO_new(BIO_s_mem());\n\tif (!bio)\n\t\treturn NULL;\n\tSSL_SESSION_print(bio, sess);\n\tsz = BIO_get_mem_data(bio, &p); /* sets p to internal buffer */\n\tif (!(ret = malloc(sz + 1))) {\n\t\tBIO_free(bio);\n\t\treturn NULL;\n\t}\n\tmemcpy(ret, p, sz);\n\tret[sz] = '\\0';\n\tBIO_free(bio);\n\treturn ret;\n}\n\n/*\n * Returns non-zero if the session timeout has not expired yet,\n * zero if the session has expired or an error occurred.\n */\nint\nssl_session_is_valid(SSL_SESSION *sess)\n{\n\ttime_t curtimet;\n\tlong curtime, timeout;\n\n\tcurtimet = time(NULL);\n\tif (curtimet == (time_t)-1)\n\t\treturn 0;\n\tcurtime = curtimet;\n\tif ((curtime < 0) || ((time_t)curtime != curtimet))\n\t\treturn 0;\n\ttimeout = SSL_SESSION_get_timeout(sess);\n\tif (curtime < timeout)\n\t\treturn 0;\n\treturn (SSL_SESSION_get_time(sess) > curtime - timeout);\n}\n\n/*\n * Returns 1 if buf contains a DER encoded OCSP request which can be parsed.\n * Returns 0 otherwise.\n */\nint\nssl_is_ocspreq(const unsigned char *buf, size_t sz)\n{\n\tOCSP_REQUEST *req;\n\tconst unsigned char *p;\n\n\tp = (const unsigned char *)buf;\n\treq = d2i_OCSP_REQUEST(NULL, &p, sz); /* increments p */\n\tif (!req)\n\t\treturn 0;\n\tOCSP_REQUEST_free(req);\n\treturn 1;\n}\n\nstatic uint16_t\nlen2(uint8_t p0, uint8_t p1) {\n\treturn (uint16_t)p1 + ((uint16_t)p0 << 8);\n}\n\nstatic uint32_t\nlen3(uint8_t p0, uint8_t p1, uint8_t p2) {\n\treturn (uint32_t)p2 + ((uint32_t)p1 << 8) + ((uint32_t)p0 << 16);\n}\n\n/*\n * Ugly hack to manually parse a clientHello message from a memory buffer.\n * This is needed in order to be able to support SNI and STARTTLS.\n *\n * The OpenSSL SNI API only allows to read the indicated server name at the\n * time when we have to provide the server certificate.  OpenSSL does not\n * allow to asynchronously read the indicated server name, wait for some\n * unrelated event to happen, and then later to provide the server certificate\n * to use and continue the handshake.  Therefore we resort to parsing the\n * server name from the ClientHello manually before OpenSSL gets to work on it.\n *\n * For STARTTLS support in autossl mode, we need to peek into the buffer of\n * received octets and decide whether we have something that resembles a\n * (possibly incomplete) ClientHello message, so we can upgrade the connection\n * to SSL automatically.\n *\n * This function takes a buffer containing (part of) a ClientHello message as\n * seen on the network as input.\n *\n * Returns:\n *  1  if buf does not contain a complete ClientHello message;\n *     *clienthello may point to the start of a truncated ClientHello message,\n *     indicating that the caller should retry later with more bytes available\n *  0  if buf contains a complete ClientHello message;\n *     *clienthello will point to the start of the complete ClientHello message\n *\n * If a servername pointer was supplied by the caller, and a server name\n * extension was found and parsed, the server name is returned in *servername\n * as a newly allocated string that must be freed by the caller.  This may\n * only occur for a return value of 0.\n *\n * If search is non-zero, then the buffer will be searched for a ClientHello\n * message beginning at offsets >= 0, whereas if search is zero, only\n * ClientHello messages starting at offset 0 will be considered.\n *\n * This code currently supports SSL 2.0, SSL 3.0 and TLS 1.0-1.2.\n *\n * References:\n * draft-hickman-netscape-ssl-00: The SSL Protocol\n * RFC 6101: The Secure Sockets Layer (SSL) Protocol Version 3.0\n * RFC 2246: The TLS Protocol Version 1.0\n * RFC 3546: Transport Layer Security (TLS) Extensions\n * RFC 4346: The Transport Layer Security (TLS) Protocol Version 1.1\n * RFC 4366: Transport Layer Security (TLS) Extensions\n * RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2\n * RFC 6066: Transport Layer Security (TLS) Extensions: Extension Definitions\n */\nint\nssl_tls_clienthello_parse(const unsigned char *buf, ssize_t sz, int search,\n                          const unsigned char **clienthello, char **servername)\n{\n#ifdef DEBUG_CLIENTHELLO_PARSER\n#define DBG_printf(...) log_dbg_printf(\"ClientHello parser: \" __VA_ARGS__)\n#else /* !DEBUG_CLIENTHELLO_PARSER */\n#define DBG_printf(...) \n#endif /* !DEBUG_CLIENTHELLO_PARSER */\n\tconst unsigned char *p = buf;\n\tssize_t n = sz;\n\n\t*clienthello = NULL;\n\n\tDBG_printf(\"parsing buffer of sz %zd\\n\", sz);\n\n\tdo {\n\t\tchar *sn = NULL;\n\t\tif (*clienthello) {\n\t\t\t/*\n\t\t\t * Rewind after skipping an invalid ClientHello by\n\t\t\t * restarting the search one byte after the beginning\n\t\t\t * of the last candidate\n\t\t\t */\n\t\t\tp = (*clienthello) + 1;\n\t\t\tn = sz - (p - buf);\n\t\t}\n\n\t\tif (search) {\n\t\t\t/* Search for a potential ClientHello */\n\t\t\twhile ((n > 0) && (*p != 0x16) && (*p != 0x80)) {\n\t\t\t\tp++; n--;\n\t\t\t}\n\t\t\tif (n <= 0) {\n\t\t\t\t/* Search completed without a match; reset\n\t\t\t\t * clienthello to NULL to indicate to the\n\t\t\t\t * caller that this buffer does not need to be\n\t\t\t\t * retried */\n\t\t\t\tDBG_printf(\"===> No match:\"\n\t\t\t\t           \" rv 1, *clienthello NULL\\n\");\n\t\t\t\t*clienthello = NULL;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t*clienthello = p;\n\t\tDBG_printf(\"candidate at offset %td\\n\", p - buf);\n\n\t\tDBG_printf(\"byte 0: %02x\\n\", *p);\n\t\t/* +0 0x80 +2 0x01 SSLv2 short header, clientHello;\n\t\t * +0 0x16 +1 0x03 SSLv3/TLSv1.x handshake, clientHello */\n\t\tif (*p == 0x80) {\n\t\t\t/* SSLv2 handled here */\n\t\t\tp++; n--;\n\n\t\t\tif (n < 10) { /* length + 9 */\n\t\t\t\tDBG_printf(\"===> [SSLv2] Truncated:\"\n\t\t\t\t           \" rv 1, *clienthello set\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tDBG_printf(\"length: %02x\\n\", p[0]);\n\t\t\tif (n - 1 < p[0]) {\n\t\t\t\tDBG_printf(\"===> [SSLv2] Truncated:\"\n\t\t\t\t           \" rv 1, *clienthello set\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tp++; n--;\n\n\t\t\tDBG_printf(\"msgtype: %02x\\n\", p[0]);\n\t\t\tif (*p != 0x01)\n\t\t\t\tcontinue;\n\t\t\tp++; n--;\n\n\t\t\tDBG_printf(\"version: %02x %02x\\n\", p[0], p[1]);\n\t\t\t/* byte order is actually swapped for SSLv2 */\n\t\t\tif (!(\n#ifdef HAVE_SSLV2\n\t\t\t      (p[0] == 0x00 && p[1] == 0x02) ||\n#endif /* HAVE_SSLV2 */\n\t\t\t      (p[0] == 0x03 && p[1] <= 0x03)))\n\t\t\t\tcontinue;\n\t\t\tp += 2; n -= 2;\n\n\t\t\tDBG_printf(\"cipher-spec-len: %02x %02x\\n\", p[0], p[1]);\n\t\t\tssize_t cipherspec_len = len2(p[0], p[1]);\n\t\t\tp += 2; n -= 2;\n\n\t\t\tDBG_printf(\"session-id-len: %02x %02x\\n\", p[0], p[1]);\n\t\t\tssize_t sessionid_len = len2(p[0], p[1]);\n\t\t\tp += 2; n -= 2;\n\n\t\t\tDBG_printf(\"challenge-len: %02x %02x\\n\", p[0], p[1]);\n\t\t\tssize_t challenge_len = len2(p[0], p[1]);\n\t\t\tp += 2; n -= 2;\n\t\t\tif (challenge_len < 16 || challenge_len > 32)\n\t\t\t\tcontinue;\n\n\t\t\tif (n < cipherspec_len\n\t\t\t      + sessionid_len\n\t\t\t      + challenge_len) {\n\t\t\t\tDBG_printf(\"===> [SSLv2] Truncated:\"\n\t\t\t\t           \" rv 1, *clienthello set\\n\");\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tp += cipherspec_len + sessionid_len + challenge_len;\n\t\t\tn -= cipherspec_len + sessionid_len + challenge_len;\n\t\t\tgoto done_parsing;\n\t\t} else\n\t\tif (*p != 0x16) {\n\t\t\t/* this can only happen if search is 0 */\n\t\t\tDBG_printf(\"===> No match: rv 1, *clienthello NULL\\n\");\n\t\t\t*clienthello = NULL;\n\t\t\treturn 1;\n\t\t}\n\t\tp++; n--;\n\n\t\tif (n < 2) {\n\t\t\tDBG_printf(\"===> Truncated: rv 1, *clienthello set\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tDBG_printf(\"version: %02x %02x\\n\", p[0], p[1]);\n\t\t/* This supports up to TLS 1.2 (0x03 0x03) and will need to be\n\t\t * updated for TLS 1.3 once that is standardized and still\n\t\t * compatible with this parser; remember to also update the\n\t\t * inner version check below */\n\t\tif (p[0] != 0x03 || p[1] > 0x03)\n\t\t\tcontinue;\n\t\tp += 2; n -= 2;\n\n\t\tif (n < 2) {\n\t\t\tDBG_printf(\"===> Truncated: rv 1, *clienthello set\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tDBG_printf(\"length: %02x %02x\\n\", p[0], p[1]);\n\t\tssize_t recordlen = len2(p[0], p[1]);\n\t\tDBG_printf(\"recordlen=%zd\\n\", recordlen);\n\t\tp += 2; n -= 2;\n\t\tif (recordlen < 36) /* arbitrary size too small for a c-h */\n\t\t\tcontinue;\n\t\tif (n < recordlen) {\n\t\t\tDBG_printf(\"n < recordlen: n=%zd\\n\", n);\n\t\t\tDBG_printf(\"===> Truncated: rv 1, *clienthello set\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* from here we give up on a candidate if there is not enough\n\t\t * data available in the buffer, because we already checked the\n\t\t * availability of the whole record. */\n\n\t\tif (n < 1)\n\t\t\tcontinue;\n\t\tDBG_printf(\"message type: %i\\n\", *p);\n\t\tif (*p != 0x01) /* message type: ClientHello */\n\t\t\tcontinue;\n\t\tp++; n--;\n\n\t\tif (n < 3)\n\t\t\tcontinue;\n\t\tDBG_printf(\"message len: %02x %02x %02x\\n\", p[0], p[1], p[2]);\n\n\t\tssize_t msglen = len3(p[0], p[1], p[2]);\n\t\tDBG_printf(\"msglen=%zd\\n\", msglen);\n\t\tp += 3; n -= 3;\n\t\tif (msglen < 32) /* arbitrary size too small for a c-h */\n\t\t\tcontinue;\n\t\tif (msglen != recordlen - 4) {\n\t\t\tDBG_printf(\"msglen != recordlen - 4\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (n < msglen)\n\t\t\tcontinue;\n\t\tn = msglen; /* only parse first message */\n\n\t\tif (n < 2)\n\t\t\tcontinue;\n\t\tDBG_printf(\"clienthello version %02x %02x\\n\", p[0], p[1]);\n\t\t/* inner version check, see outer one above */\n\t\tif (p[0] != 0x03 || p[1] > 0x03)\n\t\t\tcontinue;\n\t\tp += 2; n -= 2;\n\n\t\tif (n < 32)\n\t\t\tcontinue;\n\t\tDBG_printf(\"clienthello random %02x %02x %02x %02x ...\\n\",\n\t\t           p[0], p[1], p[2], p[3]);\n\t\tDBG_printf(\"compare localtime: %08x\\n\",\n\t\t           (unsigned int)time(NULL));\n\t\tp += 32; n -= 32;\n\n\t\tif (n < 1)\n\t\t\tcontinue;\n\t\tDBG_printf(\"clienthello sidlen %02x\\n\", *p);\n\t\tssize_t sidlen = *p; /* session id length, 0..32 */\n\t\tp += 1; n -= 1;\n\t\tif (n < sidlen)\n\t\t\tcontinue;\n\t\tp += sidlen; n -= sidlen;\n\n\t\tif (n < 2)\n\t\t\tcontinue;\n\t\tDBG_printf(\"clienthello cipher suites length %02x %02x\\n\",\n\t\t           p[0], p[1]);\n\n\t\tssize_t suiteslen = len2(p[0], p[1]);\n\t\tp += 2; n -= 2;\n\t\tif (n < suiteslen)\n\t\t\tcontinue;\n\t\tp += suiteslen;\n\t\tn -= suiteslen;\n\n\t\tif (n < 1)\n\t\t\tcontinue;\n\t\tDBG_printf(\"clienthello compress methods length %02x\\n\", *p);\n\t\tssize_t compslen = *p;\n\t\tp++; n--;\n\t\tif (n < compslen)\n\t\t\tcontinue;\n\t\tp += compslen;\n\t\tn -= compslen;\n\n\t\t/* begin of extensions */\n\n\t\tif (n == 0) {\n\t\t\t/* valid ClientHello without extensions */\n\t\t\tDBG_printf(\"===> Match: rv 0, *clienthello set\\n\");\n\t\t\tif (servername)\n\t\t\t\t*servername = NULL;\n\t\t\treturn 0;\n\t\t}\n\t\tif (n < 2)\n\t\t\tcontinue;\n\t\tDBG_printf(\"tlsexts length %02x %02x\\n\", p[0], p[1]);\n\t\tssize_t tlsextslen = len2(p[0], p[1]);\n\t\tDBG_printf(\"tlsextslen %zd\\n\", tlsextslen);\n\t\tp += 2; n -= 2;\n\t\tif (n < tlsextslen)\n\t\t\tcontinue;\n\t\tn = tlsextslen; /* only parse exts, ignore trailing bits */\n\n\t\twhile (n > 0) {\n\t\t\tif (n < 4)\n\t\t\t\tgoto continue_search;\n\t\t\tDBG_printf(\"tlsext type %02x %02x len %02x %02x\\n\",\n\t\t\t           p[0], p[1], p[2], p[3]);\n\t\t\tunsigned short exttype = len2(p[0], p[1]);\n\t\t\tssize_t extlen = len2(p[2], p[3]);\n\t\t\tp += 4; n -= 4;\n\t\t\tif (n < extlen)\n\t\t\t\tgoto continue_search;\n\t\t\tswitch (exttype) {\n\t\t\tcase 0: {\n\t\t\t\tssize_t extn = extlen;\n\t\t\t\tconst unsigned char *extp = p;\n\n\t\t\t\tif (extn < 2)\n\t\t\t\t\tgoto continue_search;\n\t\t\t\tDBG_printf(\"list length %02x %02x\\n\",\n\t\t\t\t           extp[0], extp[1]);\n\t\t\t\tssize_t namelistlen = len2(extp[0], extp[1]);\n\t\t\t\tDBG_printf(\"namelistlen = %zd\\n\", namelistlen);\n\t\t\t\textp += 2;\n\t\t\t\textn -= 2;\n\n\t\t\t\tif (namelistlen != extn)\n\t\t\t\t\tgoto continue_search;\n\n\t\t\t\twhile (extn > 0) {\n\t\t\t\t\tif (extn < 3)\n\t\t\t\t\t\tgoto continue_search;\n\t\t\t\t\tDBG_printf(\"ServerName type %02x\"\n\t\t\t\t\t           \" len %02x %02x\\n\",\n\t\t\t\t\t           extp[0], extp[1], extp[2]);\n\t\t\t\t\tunsigned char sntype = extp[0];\n\t\t\t\t\tssize_t snlen = len2(extp[1], extp[2]);\n\t\t\t\t\textp += 3;\n\t\t\t\t\textn -= 3;\n\t\t\t\t\tif (snlen > extn)\n\t\t\t\t\t\tgoto continue_search;\n\t\t\t\t\tif (snlen > TLSEXT_MAXLEN_host_name)\n\t\t\t\t\t\tgoto continue_search;\n\t\t\t\t\t/*\n\t\t\t\t\t * We copy the first name only.\n\t\t\t\t\t * RFC 6066: \"The ServerNameList MUST\n\t\t\t\t\t * NOT contain more than one name of\n\t\t\t\t\t * the same name_type.\"\n\t\t\t\t\t */\n\t\t\t\t\tif (servername &&\n\t\t\t\t\t    sntype == 0 && sn == NULL) {\n\t\t\t\t\t\tsn = malloc(snlen + 1);\n\t\t\t\t\t\tmemcpy(sn, extp, snlen);\n\t\t\t\t\t\tsn[snlen] = '\\0';\n\t\t\t\t\t\t/* deliberately not checking\n\t\t\t\t\t\t * for malformed hostnames\n\t\t\t\t\t\t * containing invalid chars */\n\t\t\t\t\t}\n\t\t\t\t\textp += snlen;\n\t\t\t\t\textn -= snlen;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tDBG_printf(\"skipped\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp += extlen;\n\t\t\tn -= extlen;\n\t\t} /* while have more extensions */\n\ndone_parsing:\n\t\t;\n#ifdef DEBUG_CLIENTHELLO_PARSER\n\t\tif (n > 0) {\n\t\t\tDBG_printf(\"unparsed next bytes %02x %02x %02x %02x\\n\",\n\t\t\t           p[0], p[1], p[2], p[3]);\n\t\t}\n#endif /* DEBUG_CLIENTHELLO_PARSER */\n\t\tDBG_printf(\"%zd bytes unparsed\\n\", n);\n\n\t\t/* Valid ClientHello with or without server name */\n\t\tDBG_printf(\"===> Match: rv 0, *clienthello set\\n\");\n\t\tif (servername)\n\t\t\t*servername = sn;\n\t\treturn 0;\ncontinue_search:\n\t\tif (sn)\n\t\t\tfree(sn);\n\t} while (search && n > 0);\n\n\t/* No valid ClientHello messages found, not even a truncated one */\n\tDBG_printf(\"===> No match: rv 1, *clienthello NULL\\n\");\n\t*clienthello = NULL;\n\treturn 1;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "ssl.h",
          "type": "blob",
          "size": 9.3134765625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef SSL_H\n#define SSL_H\n\n#include \"attrib.h\"\n\n#include <openssl/opensslv.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <openssl/rand.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n/*\n * LibreSSL seems to ship engine support on a source code level, but it seems\n * to be broken.  Tested with LibreSSL 2.7.4 on OpenBSD and macOS.  For now,\n * disable engine support when building against LibreSSL.\n */\n#if defined(LIBRESSL_VERSION_NUMBER) && !defined(OPENSSL_NO_ENGINE)\n#define OPENSSL_NO_ENGINE\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x10000000L) && !defined(OPENSSL_NO_THREADID)\n#define OPENSSL_NO_THREADID\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x0090806FL) && !defined(OPENSSL_NO_TLSEXT)\n#define OPENSSL_NO_TLSEXT\n#endif\n\n/*\n * ECDH is disabled when building against OpenSSL < 1.0.0e due to issues with\n * thread-safety and security in server mode ephemereal ECDH cipher suites.\n * http://www.openssl.org/news/secadv_20110906.txt\n */\n#if (OPENSSL_VERSION_NUMBER < 0x1000005FL) && !defined(OPENSSL_NO_ECDH)\n#define OPENSSL_NO_ECDH\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x0090802FL) && !defined(OPENSSL_NO_ECDSA)\n#define OPENSSL_NO_ECDSA\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x0090802FL) && !defined(OPENSSL_NO_EC)\n#define OPENSSL_NO_EC\n#endif\n\n/*\n * SHA0 was removed in OpenSSL 1.1.0, including OPENSSL_NO_SHA0.\n */\n#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) && !defined(LIBRESSL_VERSION_NUMBER) && !defined(OPENSSL_NO_SHA0)\n#define OPENSSL_NO_SHA0\n#endif\n\n#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || (defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x2070000fL)\n#if LIBRESSL_VERSION_NUMBER >= 0x2050100fL\n#define SSL_is_server(ssl) ((ssl)->server)\n#else /* < LibreSSL 2.5.1 and OpenSSL < 1.1.0 */\n#define SSL_is_server(ssl) ((ssl)->type != SSL_ST_CONNECT)\n#endif /* < LibreSSL 2.5.1 and OpenSSL < 1.1.0 */\n#define ASN1_STRING_get0_data(value) ASN1_STRING_data(value)\n#define X509_get_signature_nid(x509) (OBJ_obj2nid(x509->sig_alg->algorithm))\nint DH_set0_pqg(DH *, BIGNUM *, BIGNUM *, BIGNUM *);\n#endif /* < OpenSSL 1.1.0 */\n\n#if OPENSSL_VERSION_NUMBER < 0x1000000fL\nstatic inline int EVP_PKEY_base_id(const EVP_PKEY *pkey)\n{\n\treturn EVP_PKEY_type(pkey->type);\n}\nstatic inline int X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg, const unsigned char **pk, int *ppklen, X509_ALGOR **pa, X509_PUBKEY *pub)\n{\n\tif (ppkalg)\n\t\t*ppkalg = pub->algor->algorithm;\n\tif (pk) {\n\t\t*pk = pub->public_key->data;\n\t\t*ppklen = pub->public_key->length;\n\t}\n\tif (pa)\n\t\t*pa = pub->algor;\n\treturn 1;\n}\n#ifndef X509_get_X509_PUBKEY\n#define X509_get_X509_PUBKEY(x) ((x)->cert_info->key\n#endif\n#endif /* OpenSSL < 1.0.0 */\n\n/*\n * The constructors returning a SSL_METHOD * were changed to return\n * a const SSL_METHOD * between 0.9.8 and 1.0.0.\n */\n#if (OPENSSL_VERSION_NUMBER < 0x1000000fL)\n#define CONST_SSL_METHOD SSL_METHOD\n#else /* >= OpenSSL 1.0.0 */\n#define CONST_SSL_METHOD const SSL_METHOD\n#endif /* >= OpensSL 1.0.0 */\n\n/*\n * Workaround for bug in OpenSSL 0.9.8y, 1.0.0k and 1.0.1e\n * http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=703031\n * http://openssl.6102.n7.nabble.com/NULL-ptr-deref-when-calling-SSL-get-certificate-with-1-0-0k-td43636.html\n */\n#if (OPENSSL_VERSION_NUMBER == 0x0090819fL) || \\\n    (OPENSSL_VERSION_NUMBER == 0x100000bfL) || \\\n    (OPENSSL_VERSION_NUMBER == 0x1000105fL)\n#define SSL_get_certificate(x) ssl_ssl_cert_get(x)\nX509 * ssl_ssl_cert_get(SSL *);\n#endif /* OpenSSL 0.9.8y or 1.0.0k or 1.0.1e */\n\n#ifdef OPENSSL_NO_TLSEXT\n#ifndef TLSEXT_MAXLEN_host_name\n#define TLSEXT_MAXLEN_host_name 255\n#endif /* !TLSEXT_MAXLEN_host_name */\n#endif /* OPENSSL_NO_TLSEXT */\n\n/*\n * SSL_OP_NO_* is used as an indication that OpenSSL is sufficiently recent\n * to have the respective protocol implemented.\n *\n * OPENSSL_NO_SSL2 indicates the complete removal of SSL 2.0 support.\n *\n * OPENSSL_NO_SSL3 indicates that no SSL 3.0 connections will be made by\n * default, but support is still present, unless OPENSSL_NO_SSL3_METHOD is\n * also defined.\n */\n#if defined(SSL_OP_NO_SSLv2) && !defined(OPENSSL_NO_SSL2) && \\\n    defined(WITH_SSLV2)\n#define HAVE_SSLV2\n#endif /* SSL_OP_NO_SSLv2 && !OPENSSL_NO_SSL2 && WITH_SSLV2 */\n#if defined(SSL_OP_NO_SSLv3) && !defined(OPENSSL_NO_SSL3_METHOD)\n#define HAVE_SSLV3\n#endif /* SSL_OP_NO_SSLv2 && !OPENSSL_NO_SSL3_METHOD */\n#ifdef SSL_OP_NO_TLSv1\n#define HAVE_TLSV10\n#endif /* SSL_OP_NO_TLSv1 */\n#ifdef SSL_OP_NO_TLSv1_1\n#define HAVE_TLSV11\n#endif /* SSL_OP_NO_TLSv1_1 */\n#ifdef SSL_OP_NO_TLSv1_2\n#define HAVE_TLSV12\n#endif /* SSL_OP_NO_TLSv1_2 */\n\n#ifdef HAVE_SSLV2\n#define SSL2_S \"ssl2 \"\n#else /* !HAVE_SSLV2 */\n#define SSL2_S \"\"\n#endif /* !HAVE_SSLV2 */\n#ifdef HAVE_SSLV3\n#define SSL3_S \"ssl3 \"\n#else /* !HAVE_SSLV3 */\n#define SSL3_S \"\"\n#endif /* !HAVE_SSLV3 */\n#ifdef HAVE_TLSV10\n#define TLS10_S \"tls10 \"\n#else /* !HAVE_TLSV10 */\n#define TLS10_S \"\"\n#endif /* !HAVE_TLSV10 */\n#ifdef HAVE_TLSV11\n#define TLS11_S \"tls11 \"\n#else /* !HAVE_TLSV11 */\n#define TLS11_S \"\"\n#endif /* !HAVE_TLSV11 */\n#ifdef HAVE_TLSV12\n#define TLS12_S \"tls12 \"\n#else /* !HAVE_TLSV12 */\n#define TLS12_S \"\"\n#endif /* !HAVE_TLSV12 */\n#define SSL_PROTO_SUPPORT_S SSL2_S SSL3_S TLS10_S TLS11_S TLS12_S\n\nvoid ssl_openssl_version(void);\nint ssl_init(void) WUNRES;\nint ssl_reinit(void) WUNRES;\nvoid ssl_fini(void);\n\n#ifndef OPENSSL_NO_ENGINE\nint ssl_engine(const char *) WUNRES;\n#endif /* !OPENSSL_NO_ENGINE */\n\nchar * ssl_sha1_to_str(unsigned char *, int) NONNULL(1) MALLOC;\n\nchar * ssl_ssl_state_to_str(SSL *) NONNULL(1) MALLOC;\nchar * ssl_ssl_masterkey_to_str(SSL *) NONNULL(1) MALLOC;\n\n#ifndef OPENSSL_NO_DH\nDH * ssl_tmp_dh_callback(SSL *, int, int) NONNULL(1) MALLOC;\nDH * ssl_dh_load(const char *) NONNULL(1) MALLOC;\nvoid ssl_dh_refcount_inc(DH *) NONNULL(1);\n#endif /* !OPENSSL_NO_DH */\n\n#ifndef OPENSSL_NO_EC\nEC_KEY * ssl_ec_by_name(const char *) MALLOC;\n#endif /* !OPENSSL_NO_EC */\n\nEVP_PKEY * ssl_key_load(const char *) NONNULL(1) MALLOC;\nEVP_PKEY * ssl_key_genrsa(const int) MALLOC;\nvoid ssl_key_refcount_inc(EVP_PKEY *) NONNULL(1);\n#define SSL_KEY_IDSZ 20\nint ssl_key_identifier_sha1(EVP_PKEY *, unsigned char *) NONNULL(1,2);\nchar * ssl_key_identifier(EVP_PKEY *, int) NONNULL(1) MALLOC;\n\n#ifndef OPENSSL_NO_TLSEXT\nint ssl_x509_v3ext_add(X509V3_CTX *, X509 *, char *, char *) NONNULL(1,2,3,4);\nint ssl_x509_v3ext_copy_by_nid(X509 *, X509 *, int) NONNULL(1,2);\n#endif /* !OPENSSL_NO_TLSEXT */\nint ssl_x509_serial_copyrand(X509 *, X509 *) NONNULL(1,2);\nX509 * ssl_x509_forge(X509 *, EVP_PKEY *, X509 *, EVP_PKEY *,\n                      const char *, const char *)\n       NONNULL(1,2,3,4) MALLOC;\nX509 * ssl_x509_load(const char *) NONNULL(1) MALLOC;\nchar * ssl_x509_subject(X509 *) NONNULL(1) MALLOC;\nchar * ssl_x509_subject_cn(X509 *, size_t *) NONNULL(1,2) MALLOC;\n#define SSL_X509_FPRSZ 20\nint ssl_x509_fingerprint_sha1(X509 *, unsigned char *) NONNULL(1,2);\nchar * ssl_x509_fingerprint(X509 *, int) NONNULL(1) MALLOC;\nchar ** ssl_x509_names(X509 *) NONNULL(1) MALLOC;\nint ssl_x509_names_match(X509 *, const char *) NONNULL(1,2);\nchar * ssl_x509_names_to_str(X509 *) NONNULL(1) MALLOC;\nchar ** ssl_x509_aias(X509 *, const int) NONNULL(1) MALLOC;\nchar ** ssl_x509_ocsps(X509 *) NONNULL(1) MALLOC;\nint ssl_x509_is_valid(X509 *) NONNULL(1) WUNRES;\nchar * ssl_x509_to_str(X509 *) NONNULL(1) MALLOC;\nchar * ssl_x509_to_pem(X509 *) NONNULL(1) MALLOC;\nvoid ssl_x509_refcount_inc(X509 *) NONNULL(1);\n\nint ssl_x509chain_load(X509 **, STACK_OF(X509) **, const char *) NONNULL(2,3);\nint ssl_x509chain_use(SSL_CTX *, X509 *, STACK_OF(X509) *)\n    NONNULL(1,2,3) WUNRES;\n\nchar * ssl_session_to_str(SSL_SESSION *) NONNULL(1) MALLOC;\nint ssl_session_is_valid(SSL_SESSION *) NONNULL(1);\n\nint ssl_is_ocspreq(const unsigned char *, size_t) NONNULL(1) WUNRES;\n\nint ssl_tls_clienthello_parse(const unsigned char *, ssize_t, int,\n                              const unsigned char **, char **)\n    NONNULL(1,4) WUNRES;\nint ssl_dnsname_match(const char *, size_t, const char *, size_t)\n    NONNULL(1,3) WUNRES;\nchar * ssl_wildcardify(const char *) NONNULL(1) MALLOC;\n\n#endif /* !SSL_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "ssl.t.c",
          "type": "blob",
          "size": 26.873046875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"base64.h\"\n#include \"ssl.h\"\n\n#include <limits.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#include <check.h>\n\n#ifdef __APPLE__\n#define DLSUFFIX \"dylib\"\n#else\n#define DLSUFFIX \"so\"\n#endif\n\n#define TESTKEY \"extra/pki/server.key\"\n#define TESTCERT \"extra/pki/server.crt\"\n#define TESTCERT2 \"extra/pki/rsa.crt\"\n#define ENGINE \"extra/engine/dummy-engine.\"DLSUFFIX\n\nstatic void\nssl_setup(void)\n{\n\tif (ssl_init() == -1)\n\t\texit(EXIT_FAILURE);\n}\n\nstatic void\nssl_teardown(void)\n{\n\tssl_fini();\n}\n\nstatic char wildcard1[] = \"*.example.org\";\nstatic char wildcard2[] = \"www.*.example.org\";\nstatic char wildcard3[] = \"*.*.org\";\nstatic char wildcard4[] = \"www*.example.org\";\nstatic char wildcard5[] = \"*\";\nstatic char wildcard6[] = \"*.xn--r-1ga.ch\";\nstatic char wildcard7[] = \"xn--r-1ga*.xn--r-1ga.ch\";\nstatic char wildcard8[] = \"xn--r-1ga.*.xn--r-1ga.ch\";\nstatic char name1[] = \"www.example.org\";\nstatic char name2[] = \"www.example.com\";\nstatic char name3[] = \"example.org\";\nstatic char name4[] = \"www.example.org.co.uk\";\nstatic char name5[] = \"test.www.example.org\";\nstatic char name6[] = \"www.test.example.org\";\nstatic char name7[] = \"wwwtest.example.org\";\nstatic char name8[] = \"ch\";\nstatic char name9[] = \"www.xn--r-1ga.ch\";\nstatic char name10[] = \"xn--r-1ga.xn--r-1ga.ch\";\nstatic char name11[] = \"\";\n\nSTART_TEST(ssl_wildcardify_01)\n{\n\tchar *wc = ssl_wildcardify(name1);\n\tfail_unless(!strcmp(wc, wildcard1), \"mismatch for 'www.example.org'\");\n\tfree(wc);\n}\nEND_TEST\n\nSTART_TEST(ssl_wildcardify_02)\n{\n\tchar *wc = ssl_wildcardify(name8);\n\tfail_unless(!strcmp(wc, wildcard5), \"mismatch for 'ch'\");\n\tfree(wc);\n}\nEND_TEST\n\nSTART_TEST(ssl_wildcardify_03)\n{\n\tchar *wc = ssl_wildcardify(name11);\n\tfail_unless(!strcmp(wc, wildcard5), \"mismatch for ''\");\n\tfree(wc);\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_01)\n{\n\tfail_unless(\n\t\tssl_dnsname_match(name1, sizeof(name1) - 1,\n\t\t                  name1, sizeof(name1) - 1),\n\t\t\"Hostname does not match itself\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_02)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(name1, sizeof(name1) - 1,\n\t\t                   name2, sizeof(name2) - 1),\n\t\t\"Hostname matches hostname with different TLD\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_03)\n{\n\tfail_unless(\n\t\tssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1,\n\t\t                  name1, sizeof(name1) - 1),\n\t\t\"Regular wildcard does not match\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_04)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1,\n\t\t                   name2, sizeof(name2) - 1),\n\t\t\"Regular wildcard matches other TLD\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_05)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1,\n\t\t                   name3, sizeof(name3) - 1),\n\t\t\"Regular wildcard matches upper level domain\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_06)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1,\n\t\t                   name4, sizeof(name4) - 1),\n\t\t\"Regular wildcard matches despite added suffix\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_07)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard1, sizeof(wildcard1) - 1,\n\t\t                   name5, sizeof(name5) - 1),\n\t\t\"Regular wildcard matches two elements\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_08)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard2, sizeof(wildcard2) - 1,\n\t\t                   name6, sizeof(name6) - 1),\n\t\t\"Wildcard matches in non-leftmost element\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_09)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard3, sizeof(wildcard3) - 1,\n\t\t                   name5, sizeof(name5) - 1),\n\t\t\"Multiple wildcard matches\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_10)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard4, sizeof(wildcard4) - 1,\n\t\t                   name7, sizeof(name7) - 1),\n\t\t\"Partial label wildcard matches\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_11)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard5, sizeof(wildcard5) - 1,\n\t\t                   name1, sizeof(name1) - 1),\n\t\t\"Global wildcard * matches fqdn\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_12)\n{\n\tfail_unless(\n\t\tssl_dnsname_match(wildcard5, sizeof(wildcard5) - 1,\n\t\t                  name8, sizeof(name8) - 1),\n\t\t\"Global wildcard * does not match TLD\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_13)\n{\n\tfail_unless(\n\t\tssl_dnsname_match(wildcard6, sizeof(wildcard6) - 1,\n\t\t                  name9, sizeof(name9) - 1),\n\t\t\"IDN wildcard does not match\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_14)\n{\n\tfail_unless(\n\t\tssl_dnsname_match(wildcard6, sizeof(wildcard6) - 1,\n\t\t                  name10, sizeof(name10) - 1),\n\t\t\"IDN wildcard does not match IDN element\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_15)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard7, sizeof(wildcard7) - 1,\n\t\t                   name10, sizeof(name10) - 1),\n\t\t\"Illegal IDN wildcard matches\");\n}\nEND_TEST\n\nSTART_TEST(ssl_dnsname_match_16)\n{\n\tfail_unless(\n\t\t!ssl_dnsname_match(wildcard8, sizeof(wildcard8) - 1,\n\t\t                   name10, sizeof(name10) - 1),\n\t\t\"Illegal IDN wildcard matches IDN element\");\n}\nEND_TEST\n\nstatic unsigned char clienthello00[] =\n\t\"\\x80\\x2b\\x01\\x00\\x02\\x00\\x12\\x00\\x00\\x00\\x10\\x07\\x00\\xc0\\x03\\x00\"\n\t\"\\x80\\x01\\x00\\x80\\x06\\x00\\x40\\x04\\x00\\x80\\x02\\x00\\x80\\xe0\\xc3\\x4a\"\n\t\"\\xc6\\xa4\\x89\\x23\\x21\\xb1\\xbb\\x51\\xc7\\x9c\\x06\\xa5\\xff\";\n\t/* SSL 2.0 */\n\nstatic unsigned char clienthello01[] =\n\t\"\\x80\\x67\\x01\\x03\\x00\\x00\\x4e\\x00\\x00\\x00\\x10\\x01\\x00\\x80\\x03\\x00\"\n\t\"\\x80\\x07\\x00\\xc0\\x06\\x00\\x40\\x02\\x00\\x80\\x04\\x00\\x80\\x00\\x00\\x39\"\n\t\"\\x00\\x00\\x38\\x00\\x00\\x35\\x00\\x00\\x33\\x00\\x00\\x32\\x00\\x00\\x04\\x00\"\n\t\"\\x00\\x05\\x00\\x00\\x2f\\x00\\x00\\x16\\x00\\x00\\x13\\x00\\xfe\\xff\\x00\\x00\"\n\t\"\\x0a\\x00\\x00\\x15\\x00\\x00\\x12\\x00\\xfe\\xfe\\x00\\x00\\x09\\x00\\x00\\x64\"\n\t\"\\x00\\x00\\x62\\x00\\x00\\x03\\x00\\x00\\x06\\xa8\\xb8\\x93\\xbb\\x90\\xe9\\x2a\"\n\t\"\\xa2\\x4d\\x6d\\xcc\\x1c\\xe7\\x2a\\x80\\x21\";\n\t/* SSL 3.0 in SSL 2.0 record */\n\nstatic unsigned char clienthello02[] =\n\t\"\\x16\\x03\\x00\\x00\\x73\\x01\\x00\\x00\\x6f\\x03\\x00\\x00\\x34\\x01\\x1e\\x67\"\n\t\"\\x3a\\xfa\\xce\\xd9\\x51\\xba\\xe4\\xfc\\x64\\x95\\x03\\x82\\x63\\x0f\\xe3\\x39\"\n\t\"\\x6b\\xc7\\xbd\\x2b\\xe5\\x51\\x37\\x23\\x48\\x5b\\xfb\\x20\\xa3\\xca\\xad\\x46\"\n\t\"\\x95\\x5d\\x64\\xbb\\x33\\xec\\xb5\\x12\\x91\\x21\\xa3\\x50\\xd2\\xc0\\xc5\\xf6\"\n\t\"\\x67\\xc3\\xcc\\x9e\\xc0\\x4a\\x71\\x1b\\x92\\xdc\\x58\\x55\\x00\\x28\\x00\\x39\"\n\t\"\\x00\\x38\\x00\\x35\\x00\\x33\\x00\\x32\\x00\\x04\\x00\\x05\\x00\\x2f\\x00\\x16\"\n\t\"\\x00\\x13\\xfe\\xff\\x00\\x0a\\x00\\x15\\x00\\x12\\xfe\\xfe\\x00\\x09\\x00\\x64\"\n\t\"\\x00\\x62\\x00\\x03\\x00\\x06\\x01\\x00\";\n\t/* SSL 3.0, no TLS extensions */\n\nstatic unsigned char clienthello03[] =\n\t\"\\x16\\x03\\x01\\x00\\x9b\\x01\\x00\\x00\\x97\\x03\\x01\\x4b\\x99\\x46\\xac\\x38\"\n\t\"\\x08\\xbb\\xa7\\x1c\\x9b\\xea\\x79\\xc5\\xd6\\x70\\x3d\\xed\\x20\\x80\\x60\\xb4\"\n\t\"\\x7e\\xb5\\x07\\x13\\xcf\\x9a\\x1c\\xec\\x6f\\x64\\xe5\\x00\\x00\\x46\\xc0\\x0a\"\n\t\"\\xc0\\x09\\xc0\\x07\\xc0\\x08\\xc0\\x13\\xc0\\x14\\xc0\\x11\\xc0\\x12\\xc0\\x04\"\n\t\"\\xc0\\x05\\xc0\\x02\\xc0\\x03\\xc0\\x0e\\xc0\\x0f\\xc0\\x0c\\xc0\\x0d\\x00\\x2f\"\n\t\"\\x00\\x05\\x00\\x04\\x00\\x35\\x00\\x0a\\x00\\x09\\x00\\x03\\x00\\x08\\x00\\x06\"\n\t\"\\x00\\x32\\x00\\x33\\x00\\x38\\x00\\x39\\x00\\x16\\x00\\x15\\x00\\x14\\x00\\x13\"\n\t\"\\x00\\x12\\x00\\x11\\x01\\x00\\x00\\x28\\x00\\x00\\x00\\x12\\x00\\x10\\x00\\x00\"\n\t\"\\x0d\\x31\\x39\\x32\\x2e\\x31\\x36\\x38\\x2e\\x31\\x30\\x30\\x2e\\x34\\x00\\x0a\"\n\t\"\\x00\\x08\\x00\\x06\\x00\\x17\\x00\\x18\\x00\\x19\\x00\\x0b\\x00\\x02\\x01\\x00\";\n\t/* TLS 1.0, SNI extension with hostname \"192.168.100.4\";\n\t * Note: IP addresses are not legal values */\n\nstatic unsigned char clienthello04[] =\n\t\"\\x16\\x03\\x01\\x00\\x6c\\x01\\x00\\x00\\x68\\x03\\x01\\x4a\\x9d\\x49\\x75\\xb2\"\n\t\"\\x7e\\xf9\\xbc\\xc3\\x76\\xac\\x19\\x78\\xfb\\x6a\\xee\\x50\\x55\\x5e\\x35\\x4c\"\n\t\"\\xca\\xf2\\x21\\x15\\xf3\\x8a\\x2a\\xfc\\xb5\\x35\\xed\\x00\\x00\\x28\\x00\\x39\"\n\t\"\\x00\\x38\\x00\\x35\\x00\\x16\\x00\\x13\\x00\\x0a\\x00\\x33\\x00\\x32\\x00\\x2f\"\n\t\"\\x00\\x07\\x00\\x05\\x00\\x04\\x00\\x15\\x00\\x12\\x00\\x09\\x00\\x14\\x00\\x11\"\n\t\"\\x00\\x08\\x00\\x06\\x00\\x03\\x01\\x00\\x00\\x17\\x00\\x00\\x00\\x0f\\x00\\x0d\"\n\t\"\\x00\\x00\\x0a\\x6b\\x61\\x6d\\x65\\x73\\x68\\x2e\\x63\\x6f\\x6d\\x00\\x23\\x00\"\n\t\"\\x00\";\n\t/* TLS 1.0, SNI extension with hostname \"kamesh.com\" */\n\nstatic unsigned char clienthello05[] =\n\t\"\\x16\\x03\\x03\\x01\\x7d\\x01\\x00\\x01\\x79\\x03\\x03\\x4f\\x7f\\x27\\xd0\\x76\"\n\t\"\\x5f\\xc1\\x3b\\xba\\x73\\xd5\\x07\\x8b\\xd9\\x79\\xf9\\x51\\xd4\\xce\\x7d\\x9a\"\n\t\"\\xdb\\xdf\\xf8\\x4e\\x95\\x86\\x38\\x61\\xdd\\x84\\x2a\\x00\\x00\\xca\\xc0\\x30\"\n\t\"\\xc0\\x2c\\xc0\\x28\\xc0\\x24\\xc0\\x14\\xc0\\x0a\\xc0\\x22\\xc0\\x21\\x00\\xa3\"\n\t\"\\x00\\x9f\\x00\\x6b\\x00\\x6a\\x00\\x39\\x00\\x38\\x00\\x88\\x00\\x87\\xc0\\x19\"\n\t\"\\xc0\\x20\\x00\\xa7\\x00\\x6d\\x00\\x3a\\x00\\x89\\xc0\\x32\\xc0\\x2e\\xc0\\x2a\"\n\t\"\\xc0\\x26\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00\\x3d\\x00\\x35\\x00\\x84\\xc0\\x12\"\n\t\"\\xc0\\x08\\xc0\\x1c\\xc0\\x1b\\x00\\x16\\x00\\x13\\xc0\\x17\\xc0\\x1a\\x00\\x1b\"\n\t\"\\xc0\\x0d\\xc0\\x03\\x00\\x0a\\xc0\\x2f\\xc0\\x2b\\xc0\\x27\\xc0\\x23\\xc0\\x13\"\n\t\"\\xc0\\x09\\xc0\\x1f\\xc0\\x1e\\x00\\xa2\\x00\\x9e\\x00\\x67\\x00\\x40\\x00\\x33\"\n\t\"\\x00\\x32\\x00\\x9a\\x00\\x99\\x00\\x45\\x00\\x44\\xc0\\x18\\xc0\\x1d\\x00\\xa6\"\n\t\"\\x00\\x6c\\x00\\x34\\x00\\x9b\\x00\\x46\\xc0\\x31\\xc0\\x2d\\xc0\\x29\\xc0\\x25\"\n\t\"\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00\\x3c\\x00\\x2f\\x00\\x96\\x00\\x41\\x00\\x07\"\n\t\"\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\"\n\t\"\\x00\\x15\\x00\\x12\\x00\\x1a\\x00\\x09\\x00\\x14\\x00\\x11\\x00\\x19\\x00\\x08\"\n\t\"\\x00\\x06\\x00\\x17\\x00\\x03\\x00\\xff\\x02\\x01\\x00\\x00\\x85\\x00\\x00\\x00\"\n\t\"\\x12\\x00\\x10\\x00\\x00\\x0d\\x64\\x61\\x6e\\x69\\x65\\x6c\\x2e\\x72\\x6f\\x65\"\n\t\"\\x2e\\x63\\x68\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x34\\x00\"\n\t\"\\x32\\x00\\x0e\\x00\\x0d\\x00\\x19\\x00\\x0b\\x00\\x0c\\x00\\x18\\x00\\x09\\x00\"\n\t\"\\x0a\\x00\\x16\\x00\\x17\\x00\\x08\\x00\\x06\\x00\\x07\\x00\\x14\\x00\\x15\\x00\"\n\t\"\\x04\\x00\\x05\\x00\\x12\\x00\\x13\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x0f\\x00\"\n\t\"\\x10\\x00\\x11\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x22\\x00\\x20\\x06\\x01\\x06\"\n\t\"\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\"\n\t\"\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x01\\x01\\x00\\x0f\\x00\"\n\t\"\\x01\\x01\";\n\t/* TLS 1.2, SNI extension with hostname \"daniel.roe.ch\" */\n\nstatic unsigned char clienthello06[] =\n\t\"I will start TLS now: \"\n\t\"\\x16\\x03\\x03\\x01\\x7d\\x01\\x00\\x01\\x79\\x03\\x03\\x4f\\x7f\\x27\\xd0\\x76\"\n\t\"\\x5f\\xc1\\x3b\\xba\\x73\\xd5\\x07\\x8b\\xd9\\x79\\xf9\\x51\\xd4\\xce\\x7d\\x9a\"\n\t\"\\xdb\\xdf\\xf8\\x4e\\x95\\x86\\x38\\x61\\xdd\\x84\\x2a\\x00\\x00\\xca\\xc0\\x30\"\n\t\"\\xc0\\x2c\\xc0\\x28\\xc0\\x24\\xc0\\x14\\xc0\\x0a\\xc0\\x22\\xc0\\x21\\x00\\xa3\"\n\t\"\\x00\\x9f\\x00\\x6b\\x00\\x6a\\x00\\x39\\x00\\x38\\x00\\x88\\x00\\x87\\xc0\\x19\"\n\t\"\\xc0\\x20\\x00\\xa7\\x00\\x6d\\x00\\x3a\\x00\\x89\\xc0\\x32\\xc0\\x2e\\xc0\\x2a\"\n\t\"\\xc0\\x26\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00\\x3d\\x00\\x35\\x00\\x84\\xc0\\x12\"\n\t\"\\xc0\\x08\\xc0\\x1c\\xc0\\x1b\\x00\\x16\\x00\\x13\\xc0\\x17\\xc0\\x1a\\x00\\x1b\"\n\t\"\\xc0\\x0d\\xc0\\x03\\x00\\x0a\\xc0\\x2f\\xc0\\x2b\\xc0\\x27\\xc0\\x23\\xc0\\x13\"\n\t\"\\xc0\\x09\\xc0\\x1f\\xc0\\x1e\\x00\\xa2\\x00\\x9e\\x00\\x67\\x00\\x40\\x00\\x33\"\n\t\"\\x00\\x32\\x00\\x9a\\x00\\x99\\x00\\x45\\x00\\x44\\xc0\\x18\\xc0\\x1d\\x00\\xa6\"\n\t\"\\x00\\x6c\\x00\\x34\\x00\\x9b\\x00\\x46\\xc0\\x31\\xc0\\x2d\\xc0\\x29\\xc0\\x25\"\n\t\"\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00\\x3c\\x00\\x2f\\x00\\x96\\x00\\x41\\x00\\x07\"\n\t\"\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\"\n\t\"\\x00\\x15\\x00\\x12\\x00\\x1a\\x00\\x09\\x00\\x14\\x00\\x11\\x00\\x19\\x00\\x08\"\n\t\"\\x00\\x06\\x00\\x17\\x00\\x03\\x00\\xff\\x02\\x01\\x00\\x00\\x85\\x00\\x00\\x00\"\n\t\"\\x12\\x00\\x10\\x00\\x00\\x0d\\x64\\x61\\x6e\\x69\\x65\\x6c\\x2e\\x72\\x6f\\x65\"\n\t\"\\x2e\\x63\\x68\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\x0a\\x00\\x34\\x00\"\n\t\"\\x32\\x00\\x0e\\x00\\x0d\\x00\\x19\\x00\\x0b\\x00\\x0c\\x00\\x18\\x00\\x09\\x00\"\n\t\"\\x0a\\x00\\x16\\x00\\x17\\x00\\x08\\x00\\x06\\x00\\x07\\x00\\x14\\x00\\x15\\x00\"\n\t\"\\x04\\x00\\x05\\x00\\x12\\x00\\x13\\x00\\x01\\x00\\x02\\x00\\x03\\x00\\x0f\\x00\"\n\t\"\\x10\\x00\\x11\\x00\\x23\\x00\\x00\\x00\\x0d\\x00\\x22\\x00\\x20\\x06\\x01\\x06\"\n\t\"\\x02\\x06\\x03\\x05\\x01\\x05\\x02\\x05\\x03\\x04\\x01\\x04\\x02\\x04\\x03\\x03\"\n\t\"\\x01\\x03\\x02\\x03\\x03\\x02\\x01\\x02\\x02\\x02\\x03\\x01\\x01\\x00\\x0f\\x00\"\n\t\"\\x01\\x01\";\n\t/* TLS 1.2, SNI extension with hostname \"daniel.roe.ch\" */\n\nSTART_TEST(ssl_tls_clienthello_parse_00)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = (void *)0xDEADBEEF;\n\n\trv = ssl_tls_clienthello_parse(clienthello00,\n\t                               sizeof(clienthello00) - 1,\n\t                               0, &ch, &sni);\n#ifdef HAVE_SSLV2\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless(sni == NULL, \"sni not NULL\");\n#else /* !HAVE_SSLV2 */\n\tfail_unless(rv == 1, \"rv not 1\");\n\tfail_unless(ch == NULL, \"ch not NULL\");\n\tfail_unless(sni == (void*)0xDEADBEEF, \"sni modified\");\n#endif /* !HAVE_SSLV2 */\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_01)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = (void *)0xDEADBEEF;\n\n\trv = ssl_tls_clienthello_parse(clienthello01,\n\t                               sizeof(clienthello01) - 1,\n\t                               0, &ch, &sni);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless(sni == NULL, \"sni not NULL\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_02)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = (void *)0xDEADBEEF;\n\n\trv = ssl_tls_clienthello_parse(clienthello02,\n\t                                sizeof(clienthello02) - 1,\n\t                                0, &ch, &sni);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless(sni == NULL, \"sni not NULL\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_03)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = NULL;\n\n\trv = ssl_tls_clienthello_parse(clienthello03,\n\t                                sizeof(clienthello03) - 1,\n\t                                0, &ch, &sni);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless(sni && !strcmp(sni, \"192.168.100.4\"),\n\t            \"sni not '192.168.100.4' but should be\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_04)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = NULL;\n\n\trv = ssl_tls_clienthello_parse(clienthello04,\n\t                                sizeof(clienthello04) - 1,\n\t                                0, &ch, &sni);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless(sni && !strcmp(sni, \"kamesh.com\"),\n\t            \"sni not 'kamesh.com' but should be\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_05)\n{\n\tfor (size_t i = 0; i < sizeof(clienthello04) - 1; i++) {\n\t\tint rv;\n\t\tconst unsigned char *ch = NULL;\n\t\tchar *sni = (void*)0xDEADBEEF;\n\t\tssize_t sz;\n\n\t\tsz = (ssize_t)i;\n\t\trv = ssl_tls_clienthello_parse(clienthello04, sz, 0, &ch, &sni);\n\t\tfail_unless(rv == 1, \"rv not 1\");\n\t\tfail_unless(ch != NULL, \"ch is NULL\");\n\t\tfail_unless(sni == (void*)0xDEADBEEF, \"sni modified\");\n\t}\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_06)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = NULL;\n\n\trv = ssl_tls_clienthello_parse(clienthello05,\n\t                                sizeof(clienthello05) - 1,\n\t                                0, &ch, &sni);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless(sni && !strcmp(sni, \"daniel.roe.ch\"),\n\t            \"sni not 'daniel.roe.ch' but should be\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_07)\n{\n\tfor (size_t i = 0; i < sizeof(clienthello05) - 1; i++) {\n\t\tint rv;\n\t\tconst unsigned char *ch = NULL;\n\t\tchar *sni = (void*)0xDEADBEEF;\n\t\tssize_t sz;\n\n\t\tsz = (ssize_t)i;\n\t\trv = ssl_tls_clienthello_parse(clienthello05, sz, 0, &ch, &sni);\n\t\tfail_unless(rv == 1, \"rv not 1\");\n\t\tfail_unless(ch != NULL, \"ch is NULL\");\n\t\tfail_unless(sni == (void*)0xDEADBEEF, \"sni modified\");\n\t}\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_08)\n{\n\tint rv;\n\tconst unsigned char *ch = (void *)0xDEADBEEF;\n\tchar *sni = (void *)0xDEADBEEF;\n\n\trv = ssl_tls_clienthello_parse(clienthello06,\n\t                                sizeof(clienthello06) - 1,\n\t                                0, &ch, &sni);\n\tfail_unless(rv == 1, \"rv not 1\");\n\tfail_unless(ch == NULL, \"ch not NULL\");\n\tfail_unless(sni == (void*)0xDEADBEEF, \"sni modified\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_09)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\tchar *sni = NULL;\n\n\trv = ssl_tls_clienthello_parse(clienthello06,\n\t                                sizeof(clienthello06) - 1,\n\t                                1, &ch, &sni);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless((ch - clienthello06) != 21, \"ch does not point to start\");\n\tfail_unless(sni && !strcmp(sni, \"daniel.roe.ch\"),\n\t            \"sni not 'daniel.roe.ch' but should be\");\n}\nEND_TEST\n\nSTART_TEST(ssl_tls_clienthello_parse_10)\n{\n\tint rv;\n\tconst unsigned char *ch = NULL;\n\n\trv = ssl_tls_clienthello_parse(clienthello06,\n\t                                sizeof(clienthello06) - 1,\n\t                                1, &ch, NULL);\n\tfail_unless(rv == 0, \"rv not 0\");\n\tfail_unless(ch != NULL, \"ch is NULL\");\n\tfail_unless((ch - clienthello06) != 21, \"ch does not point to start\");\n}\nEND_TEST\n\nSTART_TEST(ssl_key_identifier_sha1_01)\n{\n\tX509 *c;\n\tEVP_PKEY *k;\n\tunsigned char keyid[SSL_KEY_IDSZ];\n\n\tc = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tk = ssl_key_load(TESTKEY);\n\tfail_unless(!!k, \"loading key failed\");\n\n\tfail_unless(ssl_key_identifier_sha1(k, keyid) == 0,\n\t            \"ssl_key_identifier_sha1() failed\");\n\n\tint loc = X509_get_ext_by_NID(c, NID_subject_key_identifier, -1);\n\tX509_EXTENSION *ext = X509_get_ext(c, loc);\n\tfail_unless(!!ext, \"loading ext failed\");\n\tASN1_STRING *value = X509_EXTENSION_get_data(ext);\n\tfail_unless(ASN1_STRING_length(value) - 2 == SSL_KEY_IDSZ,\n\t             \"extension length mismatch\");\n\tfail_unless(!memcmp(ASN1_STRING_get0_data(value) + 2, keyid, SSL_KEY_IDSZ),\n\t            \"key id mismatch\");\n\tEVP_PKEY_free(k);\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_names_01)\n{\n\tX509 *c;\n\tchar **names, **p;\n\n\tc = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tnames = ssl_x509_names(c);\n\tfail_unless(!!names, \"parsing names failed\");\n\tfail_unless(!!names[0], \"first name\");\n\tfail_unless(!strcmp(names[0], \"daniel.roe.ch\"), \"first name\");\n\tfail_unless(!!names[1], \"second name\");\n\tfail_unless(!strcmp(names[1], \"daniel.roe.ch\"), \"second name\");\n\tfail_unless(!!names[2], \"third name\");\n\tfail_unless(!strcmp(names[2], \"www.roe.ch\"), \"third name\");\n\tfail_unless(!!names[3], \"fourth name\");\n\tfail_unless(!strcmp(names[3], \"*.roe.ch\"), \"fourth name\");\n\tfail_unless(!names[4], \"too many names\");\n\tp = names;\n\twhile (*p)\n\t\tfree(*p++);\n\tfree(names);\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_names_to_str_01)\n{\n\tX509 *c;\n\tchar *names;\n\n\tc = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tnames = ssl_x509_names_to_str(c);\n\tfail_unless(!!names, \"no string\");\n\tfail_unless(!strcmp(names,\n\t            \"daniel.roe.ch/daniel.roe.ch/www.roe.ch/*.roe.ch\"),\n\t            \"wrong name string\");\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_names_to_str_02)\n{\n\tX509 *c;\n\tchar *names;\n\n\tc = ssl_x509_load(TESTCERT2);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tnames = ssl_x509_names_to_str(c);\n\tfail_unless(!!names, \"no string\");\n\tfail_unless(!strcmp(names, \"SSLsplit Root CA\"), \"wrong name string\");\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_subject_01)\n{\n\tX509 *c;\n\tchar *subject;\n\n\tc = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tsubject = ssl_x509_subject(c);\n\tfail_unless(!!subject, \"no string\");\n\tfail_unless(!strcmp(subject, \"/C=CH/O=SSLsplit Test Certificate/\"\n\t                             \"CN=daniel.roe.ch\"),\n\t            \"wrong subject string\");\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_subject_cn_01)\n{\n\tX509 *c;\n\tchar *cn;\n\tsize_t sz;\n\tsize_t expsz = strlen(\"daniel.roe.ch\") + 1;\n\n\tc = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tcn = ssl_x509_subject_cn(c, &sz);\n\tfail_unless(!!cn, \"no string\");\n\tfail_unless(sz >= expsz, \"subject CN size too small\");\n\tfail_unless(!strcmp(cn, \"daniel.roe.ch\"), \"wrong subject CN string\");\n#if 0\n\tfor (unsigned int i = expsz; i < sz; i++) {\n\t\tfail_unless(cn[i] == '\\0', \"extra byte != 0\");\n\t}\n#endif\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_ocsps_01)\n{\n\tX509 *c;\n\tchar **ocsps, **p;\n\n\tc = ssl_x509_load(TESTCERT);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tocsps = ssl_x509_ocsps(c);\n\tfail_unless(!!ocsps, \"parsing OCSP extensions failed\");\n\tfail_unless(!!ocsps[0], \"first OCSP\");\n\tfail_unless(!strcmp(ocsps[0], \"http://daniel.roe.ch/test/ocsp\"),\n\t                              \"first OCSP\");\n\tfail_unless(!ocsps[1], \"too many OCSPs\");\n\tp = ocsps;\n\twhile (*p)\n\t\tfree(*p++);\n\tfree(ocsps);\n\tX509_free(c);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_ocsps_02)\n{\n\tX509 *c;\n\tchar **ocsps;\n\n\tc = ssl_x509_load(TESTCERT2);\n\tfail_unless(!!c, \"loading certificate failed\");\n\tocsps = ssl_x509_ocsps(c);\n\tfail_unless(!ocsps, \"unexpected OCSP extensions\");\n\tX509_free(c);\n}\nEND_TEST\n\nstatic char ocspreq01[] =\n\t\"MEIwQDA+MDwwOjAJBgUrDgMCGgUABBT4cyABkyiCIhU4JpmIB\"\n\t\"ewdDnn8ZgQUbyBZ44kgy35o7xW5BMzM8FTvyTwCAQE=\";\n\nSTART_TEST(ssl_is_ocspreq_01)\n{\n\tunsigned char *buf;\n\tsize_t sz;\n\n\tbuf = base64_dec(ocspreq01, sizeof(ocspreq01) - 1, &sz);\n\tfail_unless(!!buf, \"failed to base64 decode\");\n\tfail_unless(ssl_is_ocspreq(buf, sz), \"is not ocsp req\");\n}\nEND_TEST\n\nSTART_TEST(ssl_features_01)\n{\n\tlong vdiff = ((OPENSSL_VERSION_NUMBER ^ SSLeay()) & 0xfffff000L);\n\n\tfail_unless(!vdiff, \"OpenSSL version mismatch at runtime\");\n}\nEND_TEST\n\nSTART_TEST(ssl_features_02)\n{\n\tint have_threads = 0;\n#ifdef OPENSSL_THREADS\n\thave_threads = 1;\n#endif /* OPENSSL_THREADS */\n\tfail_unless(have_threads, \"!OPENSSL_THREADS: no threading support\");\n}\nEND_TEST\n\nSTART_TEST(ssl_key_refcount_inc_01)\n{\n\tEVP_PKEY *key;\n\n\tkey = ssl_key_load(TESTKEY);\n\tfail_unless(!!key, \"loading key failed\");\n\tssl_key_refcount_inc(key);\n\tssl_key_refcount_inc(key);\n\tssl_key_refcount_inc(key);\n\tEVP_PKEY_free(key);\n\t/* these must not crash */\n\tEVP_PKEY_free(key);\n\tEVP_PKEY_free(key);\n\tEVP_PKEY_free(key);\n}\nEND_TEST\n\nSTART_TEST(ssl_x509_refcount_inc_01)\n{\n\tX509 *crt;\n\n\tcrt = ssl_x509_load(TESTCERT);\n\tfail_unless(!!crt, \"loading certificate failed\");\n\tssl_x509_refcount_inc(crt);\n\tssl_x509_refcount_inc(crt);\n\tssl_x509_refcount_inc(crt);\n\tX509_free(crt);\n\t/* these must not crash */\n\tX509_free(crt);\n\tX509_free(crt);\n\tX509_free(crt);\n}\nEND_TEST\n\n#ifndef OPENSSL_NO_ENGINE\nSTART_TEST(ssl_engine_01)\n{\n\tchar cwd[PATH_MAX];\n\tchar *path;\n\n\tfail_unless(getcwd(cwd, sizeof(cwd)) == cwd, \"getcwd() failed\");\n\tfail_unless(asprintf(&path, \"%s/\"ENGINE, cwd) != -1 && !!path,\n\t            \"constructing engine path failed\");\n\tfail_unless(ssl_engine(path) == 0, \"loading OpenSSL engine failed\");\n\tfree(path);\n}\nEND_TEST\n#endif /* !OPENSSL_NO_ENGINE */\n\nSuite *\nssl_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"ssl\");\n\n\ttc = tcase_create(\"ssl_wildcardify\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_wildcardify_01);\n\ttcase_add_test(tc, ssl_wildcardify_02);\n\ttcase_add_test(tc, ssl_wildcardify_03);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_dnsname_match\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_dnsname_match_01);\n\ttcase_add_test(tc, ssl_dnsname_match_02);\n\ttcase_add_test(tc, ssl_dnsname_match_03);\n\ttcase_add_test(tc, ssl_dnsname_match_04);\n\ttcase_add_test(tc, ssl_dnsname_match_05);\n\ttcase_add_test(tc, ssl_dnsname_match_06);\n\ttcase_add_test(tc, ssl_dnsname_match_07);\n\ttcase_add_test(tc, ssl_dnsname_match_08);\n\ttcase_add_test(tc, ssl_dnsname_match_09);\n\ttcase_add_test(tc, ssl_dnsname_match_10);\n\ttcase_add_test(tc, ssl_dnsname_match_11);\n\ttcase_add_test(tc, ssl_dnsname_match_12);\n\ttcase_add_test(tc, ssl_dnsname_match_13);\n\ttcase_add_test(tc, ssl_dnsname_match_14);\n\ttcase_add_test(tc, ssl_dnsname_match_15);\n\ttcase_add_test(tc, ssl_dnsname_match_16);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_tls_clienthello_parse\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_00);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_01);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_02);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_03);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_04);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_05);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_06);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_07);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_08);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_09);\n\ttcase_add_test(tc, ssl_tls_clienthello_parse_10);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_key_identifier_sha1\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_key_identifier_sha1_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_x509_names\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_x509_names_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_x509_names_to_str\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_x509_names_to_str_01);\n\ttcase_add_test(tc, ssl_x509_names_to_str_02);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_x509_subject\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_x509_subject_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_x509_subject_cn\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_x509_subject_cn_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_x509_ocsps\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_x509_ocsps_01);\n\ttcase_add_test(tc, ssl_x509_ocsps_02);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_is_ocspreq\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_is_ocspreq_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_features\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_features_01);\n\ttcase_add_test(tc, ssl_features_02);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_key_refcount_inc\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_key_refcount_inc_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"ssl_x509_refcount_inc\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_x509_refcount_inc_01);\n\tsuite_add_tcase(s, tc);\n\n#ifndef OPENSSL_NO_ENGINE\n\ttc = tcase_create(\"ssl_engine\");\n\ttcase_add_checked_fixture(tc, ssl_setup, ssl_teardown);\n\ttcase_add_test(tc, ssl_engine_01);\n\tsuite_add_tcase(s, tc);\n#else /* OPENSSL_NO_ENGINE */\n\tfprintf(stderr, \"ssl: 1 test omitted because OpenSSL has no \"\n\t                \"engine support\\n\");\n#endif /* OPENSSL_NO_ENGINE */\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "sslsplit.1.in",
          "type": "blob",
          "size": 37.451171875,
          "content": ".\\\"-\n.\\\" SSLsplit - transparent SSL/TLS interception\n.\\\" https://www.roe.ch/SSLsplit\n.\\\"\n.\\\" Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n.\\\" All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that the following conditions are met:\n.\\\" 1. Redistributions of source code must retain the above copyright notice,\n.\\\"    this list of conditions and the following disclaimer.\n.\\\" 2. Redistributions in binary form must reproduce the above copyright notice,\n.\\\"    this list of conditions and the following disclaimer in the documentation\n.\\\"    and/or other materials provided with the distribution.\n.\\\"\n.\\\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n.\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n.\\\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n.\\\" ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n.\\\" LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n.\\\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n.\\\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n.\\\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n.\\\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n.\\\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n.\\\" POSSIBILITY OF SUCH DAMAGE.\n.TH \"sslsplit\" \"1\" \"@@DATE@@\" \"sslsplit @@VERSION@@\" \"SSLsplit\"\n.SH NAME\nsslsplit \\-\\- transparent SSL/TLS interception\n.SH SYNOPSIS\n.na\n.B sslsplit\n[\\fB-kCKqwWOPZdDgGsrRxeumjplLSFXYyTIMiab\\fP] \\fB-c\\fP \\fIpem\\fP\n\\fIproxyspecs\\fP [...]\n.br\n.B sslsplit\n[\\fB-kCKqwWOPZdDgGsrRxeumjplLSFXYyTIMiab\\fP] \\fB-c\\fP \\fIpem\\fP \\fB-t\\fP \\fIdir\\fP\n\\fIproxyspecs\\fP [...]\n.br\n.B sslsplit\n[\\fB-OPZwWdDgGsrRxeumjplLSFXYyTIMiab\\fP] \\fB-t\\fP \\fIdir\\fP\n\\fIproxyspecs\\fP [...]\n.br\n.B sslsplit [\\fB-kCKwWOPZdDgGsrRxeumjplLSFXYyTIMi\\fP] -f \\fIconffile\\fP\n.br\n.B sslsplit -E\n.br\n.B sslsplit -V\n.br\n.B sslsplit -h\n.br\n.ad\n.SH DESCRIPTION\nSSLsplit is a tool for man-in-the-middle attacks against SSL/TLS encrypted\nnetwork connections.  It is intended to be useful for network forensics,\napplication security analysis and penetration testing.\n.LP\nSSLsplit is designed to transparently terminate connections that are redirected\nto it using a network address translation engine.  SSLsplit then terminates\nSSL/TLS and initiates a new SSL/TLS connection to the original destination\naddress, while logging all data transmitted.\nBesides NAT based operation, SSLsplit also supports static destinations and\nusing the server name indicated by SNI as upstream destination.\nSSLsplit is purely a transparent proxy and cannot act as a HTTP or SOCKS proxy\nconfigured in a browser.\nSee NAT ENGINES and PROXY SPECIFICATIONS below for specifics on the different\nmodes of operation.\n.LP\nSSLsplit supports plain TCP, plain SSL, HTTP and HTTPS connections over both\nIPv4 and IPv6.  It also has the ability to dynamically upgrade plain TCP to SSL\nin order to generically support SMTP STARTTLS and similar upgrade mechanisms.\nSSLsplit fully supports Server Name Indication (SNI) and is able to work with\nRSA, DSA and ECDSA keys and DHE and ECDHE cipher suites.  Depending on the\nversion of OpenSSL, SSLsplit supports SSL 3.0, TLS 1.0, TLS 1.1 and TLS 1.2,\nand optionally SSL 2.0 as well.\n.LP\nFor SSL and HTTPS connections, SSLsplit generates and signs forged X509v3\ncertificates on-the-fly, mimicking the original server certificate's subject\nDN, subjectAltName extension and other characteristics.\nSSLsplit has the ability to use existing certificates of which the private key\nis available, instead of generating forged ones.  SSLsplit supports NULL-prefix\nCN certificates but otherwise does not implement exploits against specific\ncertificate verification vulnerabilities in SSL/TLS stacks.\n.LP\nSSLsplit implements a number of defences against mechanisms which would\nnormally prevent MitM attacks or make them more difficult.\nSSLsplit can deny OCSP requests in a generic way.\nFor HTTP and HTTPS connections, SSLsplit mangles headers to\nprevent server-instructed public key pinning (HPKP),\navoid strict transport security restrictions (HSTS),\navoid Certificate Transparency enforcement (Expect-CT) and\nprevent switching to QUIC/SPDY, HTTP/2 or WebSockets (Upgrade,\nAlternate Protocols).\nHTTP compression, encodings and keep-alive are disabled to make the logs more\nreadable.\n.LP\nLogging options include traditional SSLsplit connect and content log files as\nwell as PCAP files and mirroring decrypted traffic to a network interface.\nAdditionally, certificates, master secrets and local process information can be\nlogged.\n.LP\nIn order to maximize the chances that a connection can be successfully split,\nSSLsplit does not verify upstream server certificates by default.  Instead, all\ncertificates including self-signed are accepted and if the expected hostname\nsignalled in SNI is missing from the server certificate, it will be added to\ndynamically forged certificates.\n.LP\nSSLsplit does not automagically redirect any network traffic.  To actually\nimplement an attack, you also need to redirect the traffic to the system\nrunning \\fBsslsplit\\fP.  Your options include running \\fBsslsplit\\fP on a\nlegitimate router, ARP spoofing, ND spoofing, DNS poisoning, deploying a rogue\naccess point (e.g. using hostap mode), physical recabling, malicious VLAN\nreconfiguration or route injection, /etc/hosts modification and so on.\n.SH OPTIONS\n.TP\n.B \\-a \\fIpemfile\\fP\nUse client certificate from \\fIpemfile\\fP when destination server requests a\nclient certificate.\n.TP\n.B \\-A \\fIpemfile\\fP\nUse private key, certificate and certificate chain from PEM file \\fIpemfile\\fP\nas leaf certificate instead of generating a leaf certificate on the fly.\nThe PEM file must contain a single private key, a single certificate and\noptionally intermediate and root CA certificates to use as certificate chain.\nWhen using \\fB-t\\fP, SSLsplit will first attempt to use a matching certificate\nloaded from \\fIcertdir\\fP.\nIf \\fB-t\\fP is also used and a connection matches any certificate in the\ndirectory specified with the \\fB-t\\fP option, that matching certificate is used\ninstead, taking precedence over the certificate specified with \\fB-A\\fP.\n.TP\n.B \\-b \\fIpemfile\\fP\nUse client private key from \\fIpemfile\\fP when destination server requests a\nclient certificate.\n.TP\n.B \\-c \\fIpemfile\\fP\nUse CA certificate from \\fIpemfile\\fP to sign certificates forged on-the-fly.\nIf \\fIpemfile\\fP also contains the matching CA private key, it is also loaded,\notherwise it must be provided with \\fB-k\\fP.\nIf \\fIpemfile\\fP also contains Diffie-Hellman group parameters, they are also\nloaded, otherwise they can be provided with \\fB-g\\fP.\nIf \\fB-t\\fP is also given, SSLsplit will only forge a certificate if there is\nno matching certificate in the provided certificate directory.\n.TP\n.B \\-C \\fIpemfile\\fP\nUse CA certificates from \\fIpemfile\\fP as extra certificates in the certificate\nchain.  This is needed if the CA given with \\fB-k\\fP and \\fB-c\\fP is a sub-CA,\nin which case any intermediate CA certificates and the root CA certificate must\nbe included in the certificate chain.\n.TP\n.B \\-d\nDetach from TTY and run as a daemon, logging error messages to syslog instead\nof standard error.\n.TP\n.B \\-D\nRun in debug mode, log lots of debugging information to standard error.  This\nalso forces foreground mode and cannot be used with \\fB-d\\fP.\n.TP\n.B \\-e \\fIengine\\fP\nUse \\fIengine\\fP as the default NAT engine for \\fIproxyspecs\\fP without\nexplicit NAT engine, static destination address or SNI mode.\n\\fIengine\\fP can be any of the NAT engines supported by the system, as\nreturned by \\fB-E\\fP.\n.TP\n.B \\-E\nList all supported NAT engines available on the system and exit.  See\nNAT ENGINES for a list of NAT engines currently supported by SSLsplit.\n.TP\n.B \\-f \\fIconffile\\fP\nRead configuration from \\fIconffile\\fP.\n.TP\n.B \\-F \\fIlogspec\\fP\nLog connection content to separate log files with the given path specification\n(see LOG SPECIFICATIONS below).  For each connection, a log file will be\nwritten, which will contain both directions of data as transmitted.\nInformation about the connection will be contained in the filename only.\nOnly one of \\fB-F\\fP, \\fB-L\\fP and \\fB-S\\fP may be used (last one wins).\n.TP\n.B \\-g \\fIpemfile\\fP\nUse Diffie-Hellman group parameters from \\fIpemfile\\fP for Ephemereal\nDiffie-Hellman (EDH/DHE) cipher suites.  If \\fB-g\\fP is not given, SSLsplit\nfirst tries to load DH parameters from the PEM files given by \\fB-K\\fP,\n\\fB-k\\fP or \\fB-c\\fP.  If no DH parameters are found in the key files, built-in\ngroup parameters are automatically used.\nThe \\fB-g\\fP option is only available if SSLsplit was built against a version\nof OpenSSL which supports Diffie-Hellman cipher suites.\n.TP\n.B \\-G \\fIcurve\\fP\nUse the named \\fIcurve\\fP for Ephemereal Elliptic Curve Diffie-Hellman (ECDHE)\ncipher suites.  If \\fB-G\\fP is not given, a default curve (\\fBprime256v1\\fP) is\nused automatically.\nThe \\fB-G\\fP option is only available if SSLsplit was built against a version\nof OpenSSL which supports Elliptic Curve Diffie-Hellman cipher suites.\n.TP\n.B \\-h\nDisplay help on usage and exit.\n.TP\n.B \\-i\nFor each connection, find the local process owning the connection.  This makes\nprocess information such as pid, owner:group and executable path for\nconnections originating on the same system as SSLsplit available to the\nconnect log and enables the respective \\fB-F\\fP path specification directives.\n\\fB-i\\fP is available on Mac OS X and FreeBSD; support for other platforms has\nnot been implemented yet.\n.TP\n.B \\-I \\fIif\\fP\nMirror connection content as emulated packets to interface \\fIif\\fP with\ndestination address given by \\fB-T\\fP.  This option is not available if\nSSLsplit was built without mirroring support. If \\fB-T\\fP is omitted, the\npackets are blindly pushed to \\fIif\\fP.\n.TP\n.B \\-j \\fIjaildir\\fP\nChange the root directory to \\fIjaildir\\fP using chroot(2) after opening files.\nNote that this has implications for \\fBsni\\fP \\fIproxyspecs\\fP.\nDepending on your operating system, you will need to copy files such as\n\\fB/etc/resolv.conf\\fP to \\fIjaildir\\fP in order for name resolution to work.\nUsing \\fBsni\\fP proxyspecs depends on name resolution.\nSome operating systems require special device nodes such as \\fB/dev/null\\fP\nto be present within the jail.  Check your system's documentation for details.\n.TP\n.B \\-k \\fIpemfile\\fP\nUse CA private key from \\fIpemfile\\fP to sign certificates forged on-the-fly.\nIf \\fIpemfile\\fP also contains the matching CA certificate, it is also loaded,\notherwise it must be provided with \\fB-c\\fP.\nIf \\fIpemfile\\fP also contains Diffie-Hellman group parameters, they are also\nloaded, otherwise they can be provided with \\fB-g\\fP.\nIf \\fB-t\\fP is also given, SSLsplit will only forge a certificate if there is\nno matching certificate in the provided certificate directory.\n.TP\n.B \\-K \\fIpemfile\\fP\nUse private key from \\fIpemfile\\fP for the leaf certificates forged on-the-fly.\nIf \\fB-K\\fP is not given, SSLsplit will generate a random 2048 bit RSA key.\n.TP\n.B \\-l \\fIlogfile\\fP\nLog connections to \\fIlogfile\\fP in a single line per connection format,\nincluding addresses and ports and some HTTP and SSL information, if available.\nSIGUSR1 will cause \\fIlogfile\\fP to be re-opened.\n.TP\n.B \\-L \\fIlogfile\\fP\nLog connection content to \\fIlogfile\\fP.  The content log will contain a\nparsable log format with transmitted data, prepended with headers identifying\nthe connection and the data length of each logged segment.\nSIGUSR1 will cause \\fIlogfile\\fP to be re-opened.\nOnly one of \\fB-F\\fP, \\fB-L\\fP and \\fB-S\\fP may be used (last one wins).\n.TP\n.B \\-m\nWhen dropping privileges using \\fB-u\\fP, override the target primary group\nto be set to \\fIgroup\\fP.\n.TP\n.B \\-M \\fIlogfile\\fP\nLog master keys to \\fIlogfile\\fP in SSLKEYLOGFILE format as defined by Mozilla.\nLogging master keys in this format allows for decryption of SSL/TLS traffic\nusing Wireshark.\nNote that unlike browsers implementing this feature, setting the SSLKEYLOGFILE\nenvironment variable has no effect on SSLsplit.\nSIGUSR1 will cause \\fIlogfile\\fP to be re-opened.\n.TP\n.B \\-O\nDeny all Online Certificate Status Protocol (OCSP) requests on all\n\\fIproxyspecs\\fP and for all OCSP servers with an OCSP response of\n\\fBtryLater\\fP, causing OCSP clients to temporarily accept even revoked\ncertificates.\nHTTP requests are being treated as OCSP requests if the method is \\fBGET\\fP\nand the URI contains a syntactically valid OCSPRequest ASN.1 structure\nparsable by OpenSSL, or if the method is \\fBPOST\\fP and the \\fBContent-Type\\fP\nis \\fBapplication/ocsp-request\\fP.\nFor this to be effective, SSLsplit must be handling traffic destined to the\nport used by the OCSP server.  In particular, SSLsplit must be configured to\nreceive traffic to all ports used by OCSP servers of targeted certificates\nwithin the \\fIcertdir\\fP specified by \\fB-t\\fP.\n.TP\n.B \\-p \\fIpidfile\\fP\nWrite the process ID to \\fIpidfile\\fP and refuse to run if the \\fIpidfile\\fP\nis already in use by another process.\n.TP\n.B \\-P\nPassthrough SSL/TLS connections which cannot be split instead of dropping them.\nConnections cannot be split if \\fB-c\\fP and \\fB-k\\fP are not given and the\nsite does not match any certificate loaded using \\fB-t\\fP, or if the connection\nto the original server gives SSL/TLS errors.  Specifically, this happens if the\nsite requests a client certificate.\nIn these situations, passthrough with \\fB-P\\fP results in uninterrupted service\nfor the clients, while dropping is the more secure alternative if unmonitored\nconnections must be prevented.\nPassthrough mode currently does not apply to SSL/TLS errors in the connection\nfrom the client, since the connection from the client cannot easily be retried.\nSpecifically, \\fB-P\\fP does not currently work for clients that do not accept\nforged certificates.\n.TP\n.B \\-q \\fIcrlurl\\fP\nSet CRL distribution point (CDP) \\fIcrlurl\\fP on forged leaf certificates.\nSome clients, such as some .NET applications, reject certificates that do not\ncarry a CDP.  When using \\fB-q\\fP, you will need to generate an empty CRL\nsigned by the CA certificate and key provided with \\fB-c\\fP and \\fB-k\\fP, and\nmake it available at \\fIcrlurl\\fP.\n.TP\n.B \\-r \\fIproto\\fP\nForce SSL/TLS protocol version on both client and server side to \\fIproto\\fP\nby selecting the respective OpenSSL method constructor instead of the default\nSSLv23_method() which supports all protocol versions.\nThis is useful when analyzing traffic to a server that only supports a specific\nversion of SSL/TLS and does not implement proper protocol negotiation.\nDepending on build options and the version of OpenSSL that is used, the\nfollowing values for \\fIproto\\fP are accepted: \\fBssl2\\fP, \\fBssl3\\fP,\n\\fBtls10\\fP, \\fBtls11\\fP and \\fBtls12\\fP.\nNote that SSL 2.0 support is not built in by default because some servers\ndon't handle SSL 2.0 Client Hello messages gracefully.\n.TP\n.B \\-R \\fIproto\\fP\nDisable the SSL/TLS protocol version \\fIproto\\fP on both client and server\nside by disabling the respective protocols in OpenSSL.  To disable multiple\nprotocol versions, \\fB-R\\fP can be given multiple times.  If \\fI-r\\fP is also\ngiven, there will be no effect in disabling other protocol versions.\nDisabling protocol versions is useful when analyzing traffic to a server that\ndoes not handle some protocol versions well, or to test behaviour with\ndifferent protocol versions.\nDepending on build options and the version of OpenSSL that is used, the\nfollowing values for \\fIproto\\fP are accepted: \\fBssl2\\fP, \\fBssl3\\fP,\n\\fBtls10\\fP, \\fBtls11\\fP and \\fBtls12\\fP.\nNote that SSL 2.0 support is not built in by default because some servers\ndon't handle SSL 2.0 Client Hello messages gracefully.\n.TP\n.B \\-s \\fIciphers\\fP\nUse OpenSSL \\fIciphers\\fP specification for both server and client SSL/TLS\nconnections.  If \\fB-s\\fP is not given, a cipher list of \\fBALL:-aNULL\\fP is\nused.\nNormally, SSL/TLS implementations choose the most secure cipher suites, not the\nfastest ones.  By specifying an appropriate OpenSSL cipher list, the set of\ncipher suites can be limited to fast algorithms, or \\fBeNULL\\fP cipher suites\ncan be added.  Note that for connections to be successful, the SSLsplit cipher\nsuites must include at least one cipher suite supported by both the client and\nthe server of each connection.\nSee ciphers(1) for details on how to construct OpenSSL cipher lists.\n.TP\n.B \\-S \\fIlogdir\\fP\nLog connection content to separate log files under \\fIlogdir\\fP.  For each\nconnection, a log file will be written, which will contain both directions of\ndata as transmitted.  Information about the connection will be contained in\nthe filename only.\nOnly one of \\fB-F\\fP, \\fB-L\\fP and \\fB-S\\fP may be used (last one wins).\n.TP\n.B \\-t \\fIcertdir\\fP\nUse private key, certificate and certificate chain from PEM files in\n\\fIcertdir\\fP for connections to hostnames matching the respective\ncertificates, instead of using certificates forged on-the-fly.\nA single PEM file must contain a single private key, a single certificate and\noptionally intermediate and root CA certificates to use as certificate chain.\nWhen using \\fB-t\\fP, SSLsplit will first attempt to use a matching certificate\nloaded from \\fIcertdir\\fP.\nIf \\fB-A\\fP is also given, when there is no match in \\fIcertdir\\fP, the default\nkey, certificate and certificate chain from the PEM file specified with the\n\\fB-A\\fP option is used instead.\nOtherwise, if \\fB-c\\fP and \\fB-k\\fP are also given, certificates will be forged\non-the-fly for sites matching none of the common names in the certificates\nloaded from \\fIcertdir\\fP.\nOtherwise, connections matching no certificate will be dropped, or if\n\\fB-P\\fP is given, passed through without splitting SSL/TLS.\n.TP\n.B \\-T \\fIaddr\\fP\nMirror connection content as emulated packets to destination address \\fIaddr\\fP\non the interface given by \\fB-I\\fP.  Only IPv4 target addresses are currently\nsupported.  This option is not available if SSLsplit was built without\nmirroring support.\n.TP\n.B \\-u \\fIuser\\fP\nDrop privileges after opening sockets and files by setting the real,\neffective and stored user IDs to \\fIuser\\fP and loading the appropriate\nprimary and ancillary groups.  If \\fB-u\\fP is not given, SSLsplit will drop\nprivileges to the stored UID if EUID != UID (setuid bit scenario), or to\n\\fBnobody\\fP if running with full \\fBroot\\fP privileges (EUID == UID == 0).\nUser \\fIuser\\fP needs to be allowed to make outbound TCP connections, and in\nsome configurations, to also perform DNS resolution.\nDropping privileges enables privilege separation, which incurs latency for\ncertain options, such as separate per-connection log files.  By using\n\\fB-u root\\fP, SSLsplit can be run as root without dropping privileges.\nDue to an Apple bug, \\fB-u\\fP cannot be used with \\fBpf\\fP proxyspecs on\nMac OS X.\n.TP\n.B \\-x \\fIengine\\fP\nUse the OpenSSL engine with identifier \\fIengine\\fP as a default engine.  The\nengine must be available within the OpenSSL ecosystem under the specified\nidentifier, that is, they must be loaded from the global OpenSSL configuration.\nIf \\fIengine\\fP is an absolute path, it will be interpreted as path to an\nengine dynamically linked library and loaded by path, regardless of global\nOpenSSL configuration.\nThis option is only available if built against a version of OpenSSL with engine\nsupport.\n.TP\n.B \\-X \\fIpcapfile\\fP\nLog connection content to \\fIpcapfile\\fP in PCAP format, with emulated TCP, IP\nand Ethernet headers.\nSIGUSR1 will cause \\fIpcapfile\\fP to be re-opened.\nOnly one of \\fB-X\\fP, \\fB-Y\\fP and \\fB-y\\fP may be used (last one wins).\n.TP\n.B \\-Y \\fIpcapdir\\fP\nLog connection content to separate PCAP files under \\fIpcapdir\\fP.  For each\nconnection, a separate PCAP file will be written.\nOnly one of \\fB-X\\fP, \\fB-Y\\fP and \\fB-y\\fP may be used (last one wins).\n.TP\n.B \\-y \\fIpcapspec\\fP\nLog connection content to separate PCAP files with the given path specification\n(see LOG SPECIFICATIONS below).  For each connection, a separate PCAP file will\nbe written.\nOnly one of \\fB-X\\fP, \\fB-Y\\fP and \\fB-y\\fP may be used (last one wins).\n.TP\n.B \\-V\nDisplay version and compiled features information and exit.\n.TP\n.B \\-w \\fIgendir\\fP\nWrite generated keys and certificates to individual files in \\fIgendir\\fP.\nFor keys, the key identifier is used as filename, which consists of the SHA-1\nhash of the ASN.1 bit string of the public key, as referenced by the\nsubjectKeyIdentifier extension in certificates.\nFor certificates, the SHA-1 fingerprints of the original and the used (forged)\ncertificate are combined to form the filename.\nNote that only newly generated certificates are written to disk.\n.TP\n.B \\-W \\fIgendir\\fP\nSame as \\fB-w\\fP, but also write original certificates and certificates not\nnewly generated, such as those loaded from \\fB-t\\fP.\n.TP\n.B \\-Z\nDisable SSL/TLS compression on all connections.  This is useful if your\nlimiting factor is CPU, not network bandwidth.\nThe \\fB-Z\\fP option is only available if SSLsplit was built against a version\nof OpenSSL which supports disabling compression.\n.SH \"PROXY SPECIFICATIONS\"\nProxy specifications (\\fIproxyspecs\\fP) consist of the connection type, listen\naddress and static forward address or address resolution mechanism (NAT engine,\nSNI DNS lookup):\n.LP\n.na\n\\fBhttps\\fP \\fIlistenaddr port\\fP\n[\\fInat-engine\\fP|\\fIfwdaddr port\\fP|\\fBsni\\fP \\fIport\\fP]\n.br\n\\fBssl\\fP   \\fIlistenaddr port\\fP\n[\\fInat-engine\\fP|\\fIfwdaddr port\\fP|\\fBsni\\fP \\fIport\\fP]\n.br\n\\fBhttp\\fP  \\fIlistenaddr port\\fP\n[\\fInat-engine\\fP|\\fIfwdaddr port\\fP]\n.br\n\\fBtcp\\fP   \\fIlistenaddr port\\fP\n[\\fInat-engine\\fP|\\fIfwdaddr port\\fP]\n.br\n\\fBautossl\\fP \\fIlistenaddr port\\fP\n[\\fInat-engine\\fP|\\fIfwdaddr port\\fP]\n.ad\n.TP\n\\fBhttps\\fP\nSSL/TLS interception with HTTP protocol decoding, including the removal of\nHPKP, HSTS, Upgrade and Alternate Protocol response headers.\nThis mode currently suppresses WebSockets and HTTP/2.\n.TP\n\\fBssl\\fP\nSSL/TLS interception without any lower level protocol decoding; decrypted\nconnection content is treated as opaque stream of bytes and not modified.\n.TP\n\\fBhttp\\fP\nPlain TCP connection without SSL/TLS, with HTTP protocol decoding, including\nthe removal of HPKP, HSTS, Upgrade and Alternate Protocol response headers.\nThis mode currently suppresses WebSockets and HTTP/2.\n.TP\n\\fBtcp\\fP\nPlain TCP connection without SSL/TLS and without any lower level protocol\ndecoding; decrypted connection content is treated as opaque stream of bytes\nand not modified.\n.TP\n\\fBautossl\\fP\nPlain TCP connection until a Client Hello SSL/TLS message appears in the byte\nstream, then automatic upgrade to SSL/TLS interception.\nThis is generic, protocol-independent STARTTLS support, that may erroneously\ntrigger on byte sequences that look like Client Hello messages even though\nthere was no actual STARTTLS command issued.\n.TP\n.I listenaddr port\nIPv4 or IPv6 address and port or service name to listen on.  This is the\naddress and port where the NAT engine should redirect connections to.\n.TP\n.I nat-engine\nNAT engine to query for determining the original destination address and port\nof transparently redirected connections.\nIf no engine is given, the default engine is used, unless overridden with\n\\fB-e\\fP.  When using a NAT engine, \\fBsslsplit\\fP needs to run on the same\nsystem as the NAT rules redirecting the traffic to \\fBsslsplit\\fP.\nSee NAT ENGINES for a list of supported NAT engines.\n.TP\n.I fwdaddr port\nStatic destination address, IPv4 or IPv6, with port or service name.  When this\nis used, connections are forwarded to the given server address and port.\nIf \\fIfwdaddr\\fP is a hostname, it will be resolved to an IP address.\n.TP\n\\fBsni\\fP \\fIport\\fP\nUse the Server Name Indication (SNI) hostname sent by the client in the\nClient Hello SSL/TLS message to determine the IP address of the server to\nconnect to.  This only works for \\fBssl\\fP and \\fBhttps\\fP \\fIproxyspecs\\fP and\nneeds a port or service name as an argument.\nBecause this requires DNS lookups, it is preferable to use NAT engine\nlookups (see above), except when that is not possible, such as when there is\nno supported NAT engine or when running \\fBsslsplit\\fP on a different system\nthan the NAT rules redirecting the actual connections.\nNote that when using \\fB-j\\fP with \\fBsni\\fP, you may need to prepare\n\\fIjaildir\\fP to make name resolution work from within the chroot directory.\n.SH \"LOG SPECIFICATIONS\"\nLog specifications are composed of zero or more printf-style directives;\nordinary characters are included directly in the output path.\nSSLsplit current supports the following directives:\n.TP\n.I %T\nThe initial connection time as an ISO 8601 UTC timestamp.\n.TP\n.I %d\nThe destination host and port, separated by a comma, IPv6 addresses using\nunderscore instead of colon.\n.TP\n.I %D\nThe destination host, IPv6 addresses using underscore instead of colon.\n.TP\n.I %p\nThe destination port.\n.TP\n.I %s\nThe source host and port, separated by a comma, IPv6 addresses using\nunderscore instead of colon.\n.TP\n.I %S\nThe source host, IPv6 addresses using underscore instead of colon.\n.TP\n.I %q\nThe source port.\n.TP\n.I %x\nThe name of the local process.\nRequires \\fB-i\\fP to be used.\nIf process information is unavailable,\nthis directive will be omitted from the output path.\n.TP\n.I %X\nThe full path of the local process.\nRequires \\fB-i\\fP to be used.\nIf process information is unavailable,\nthis directive will be omitted from the output path.\n.TP\n.I %u\nThe username or numeric uid of the local process.\nRequires \\fB-i\\fP to be used.\nIf process information is unavailable,\nthis directive will be omitted from the output path.\n.TP\n.I %g\nThe group name or numeric gid of the local process.\nRequires \\fB-i\\fP to be used.\nIf process information is unavailable,\nthis directive will be omitted from the output path.\n.TP\n.I %%\nA literal '%' character.\n.LP\n.SH \"NAT ENGINES\"\nSSLsplit currently supports the following NAT engines:\n.TP\n.B pf\nOpenBSD packet filter (pf) \\fBrdr\\fP/\\fBrdr-to\\fP NAT redirects, also available\non FreeBSD, NetBSD and Mac OS X.\nFully supported, including IPv6.\nNote that SSLsplit needs permission to open \\fB/dev/pf\\fP for reading, which by\ndefault means that it needs to run under \\fBroot\\fP privileges.\nAssuming inbound interface \\fBem0\\fP, first in old (FreeBSD, Mac OS X),\nthen in new (OpenBSD 4.7+) syntax:\n.LP\n.RS\n.nf\n\\fBrdr pass on em0 proto tcp from 2001:db8::/64 to any port  80 \\\\\n         ->       ::1 port 10080\\fP\n\\fBrdr pass on em0 proto tcp from 2001:db8::/64 to any port 443 \\\\\n         ->       ::1 port 10443\\fP\n\\fBrdr pass on em0 proto tcp from  192.0.2.0/24 to any port  80 \\\\\n         -> 127.0.0.1 port 10080\\fP\n\\fBrdr pass on em0 proto tcp from  192.0.2.0/24 to any port 443 \\\\\n         -> 127.0.0.1 port 10443\\fP\n.fi\n.RE\n.LP\n.RS\n.nf\n\\fBpass in quick on em0 proto tcp from 2001:db8::/64 to any \\\\\n         port  80 rdr-to       ::1 port 10080\\fP\n\\fBpass in quick on em0 proto tcp from 2001:db8::/64 to any \\\\\n         port 443 rdr-to       ::1 port 10443\\fP\n\\fBpass in quick on em0 proto tcp from  192.0.2.0/24 to any \\\\\n         port  80 rdr-to 127.0.0.1 port 10080\\fP\n\\fBpass in quick on em0 proto tcp from  192.0.2.0/24 to any \\\\\n         port 443 rdr-to 127.0.0.1 port 10443\\fP\n.fi\n.RE\n.TP\n.B ipfw\nFreeBSD IP firewall (IPFW) divert sockets, also available on Mac OS X.\nAvailable on FreeBSD and OpenBSD using pf \\fBdivert-to\\fP.\nFully supported on FreeBSD and OpenBSD, including IPv6.\nOnly supports IPv4 on Mac OS X due to the ancient version of IPFW included.\nFirst in IPFW, then in pf \\fBdivert-to\\fP syntax:\n.LP\n.RS\n.nf\n\\fBipfw add fwd       ::1,10080 tcp from 2001:db8::/64 to any  80\\fP\n\\fBipfw add fwd       ::1,10443 tcp from 2001:db8::/64 to any 443\\fP\n\\fBipfw add fwd 127.0.0.1,10080 tcp from 192.0.2.0/24  to any  80\\fP\n\\fBipfw add fwd 127.0.0.1,10443 tcp from 192.0.2.0/24  to any 443\\fP\n.fi\n.RE\n.LP\n.RS\n.nf\n\\fBpass in quick on em0 proto tcp from 2001:db8::/64 to any \\\\\n         port  80 divert-to       ::1 port 10080\\fP\n\\fBpass in quick on em0 proto tcp from 2001:db8::/64 to any \\\\\n         port 443 divert-to       ::1 port 10443\\fP\n\\fBpass in quick on em0 proto tcp from  192.0.2.0/24 to any \\\\\n         port  80 divert-to 127.0.0.1 port 10080\\fP\n\\fBpass in quick on em0 proto tcp from  192.0.2.0/24 to any \\\\\n         port 443 divert-to 127.0.0.1 port 10443\\fP\n.fi\n.RE\n.TP\n.B ipfilter\nIPFilter (ipfilter, ipf), available on many systems, including FreeBSD, NetBSD,\nLinux and Solaris.\nNote that SSLsplit needs permission to open \\fB/dev/ipnat\\fP for reading, which\nby default means that it needs to run under \\fBroot\\fP privileges.\nOnly supports IPv4 due to limitations in the SIOCGNATL ioctl(2) interface.\nAssuming inbound interface \\fBbge0\\fP:\n.LP\n.RS\n.nf\n\\fBrdr bge0 0.0.0.0/0 port  80 -> 127.0.0.1 port 10080\\fP\n\\fBrdr bge0 0.0.0.0/0 port 443 -> 127.0.0.1 port 10443\\fP\n.fi\n.RE\n.TP\n.B netfilter\nLinux netfilter using the iptables REDIRECT target.\nFully supported including IPv6 since Linux v3.8-rc1; on older kernels only\nsupports IPv4 due to limitations in the SO_ORIGINAL_DST getsockopt(2)\ninterface.\n.LP\n.RS\n.nf\n\\fBiptables -t nat -A PREROUTING -s 192.0.2.0/24 \\\\\n         -p tcp --dport  80 \\\\\n         -j REDIRECT --to-ports 10080\\fP\n\\fBiptables -t nat -A PREROUTING -s 192.0.2.0/24 \\\\\n         -p tcp --dport 443 \\\\\n         -j REDIRECT --to-ports 10443\\fP\n\\fB# please contribute a tested ip6tables config\\fP\n.fi\n.LP\nNote that SSLsplit is only able to accept incoming connections if it binds\nto the correct IP address (e.g. 192.0.2.1) or on all interfaces (0.0.0.0).\nREDIRECT uses the local interface address of the incoming interface as\ntarget IP address, or 127.0.0.1 for locally generated packets.\n.RE\n.TP\n.B tproxy\nLinux netfilter using the iptables TPROXY target together with routing\ntable magic to allow non-local traffic to originate on local sockets.\nFully supported, including IPv6.\n.LP\n.RS\n.nf\n\\fBip -f inet6 rule add fwmark 1 lookup 100\\fP\n\\fBip -f inet6 route add local default dev lo table 100\\fP\n\\fBip6tables -t mangle -N DIVERT\\fP\n\\fBip6tables -t mangle -A DIVERT -j MARK --set-mark 1\\fP\n\\fBip6tables -t mangle -A DIVERT -j ACCEPT\\fP\n\\fBip6tables -t mangle -A PREROUTING -p tcp -m socket -j DIVERT\\fP\n\\fBip6tables -t mangle -A PREROUTING -s 2001:db8::/64 \\\\\n          -p tcp --dport 80 \\\\\n          -j TPROXY --tproxy-mark 0x1/0x1 --on-port 10080\\fP\n\\fBip6tables -t mangle -A PREROUTING -s 2001:db8::/64 \\\\\n          -p tcp --dport 443 \\\\\n          -j TPROXY --tproxy-mark 0x1/0x1 --on-port 10443\\fP\n\\fBip -f inet rule add fwmark 1 lookup 100\\fP\n\\fBip -f inet route add local default dev lo table 100\\fP\n\\fBiptables -t mangle -N DIVERT\\fP\n\\fBiptables -t mangle -A DIVERT -j MARK --set-mark 1\\fP\n\\fBiptables -t mangle -A DIVERT -j ACCEPT\\fP\n\\fBiptables -t mangle -A PREROUTING -p tcp -m socket -j DIVERT\\fP\n\\fBiptables -t mangle -A PREROUTING -s 192.0.2.0/24 \\\\\n         -p tcp --dport 80 \\\\\n         -j TPROXY --tproxy-mark 0x1/0x1 --on-port 10080\\fP\n\\fBiptables -t mangle -A PREROUTING -s 192.0.2.0/24 \\\\\n         -p tcp --dport 443 \\\\\n         -j TPROXY --tproxy-mark 0x1/0x1 --on-port 10443\\fP\n.fi\n.LP\nNote that return path filtering (rp_filter) also needs to be disabled on\ninterfaces which handle TPROXY redirected traffic.\n.RE\n.SH SIGNALS\nA running \\fBsslsplit\\fP accepts SIGINT and SIGTERM for a clean shutdown and\nSIGUSR1 to re-open the single-file log files (such as \\fB-l\\fP, \\fB-L\\fP and\n\\fB-X\\fP).  The canonical way to rotate or post-process logs is to rename the\nactive log file, send SIGUSR1 to the PID in the PID file given by \\fB-p\\fP,\ngive SSLsplit some time to flush buffers after closing the old file, and then\npost-process the renamed log file.\nPer-connection log files (such as \\fB-S\\fP and \\fB-F\\fP) are not re-opened\nbecause their filename is specific to the connection.\n.SH \"EXIT STATUS\"\nThe \\fBsslsplit\\fP process will exit with 0 on regular shutdown\n(SIGINT, SIGTERM), and 128 + signal number on controlled shutdown based on\nreceiving a different signal such as SIGHUP.  Exit status in the range 1..127\nindicates error conditions.\n.SH EXAMPLES\nMatching the above NAT engine configuration samples, intercept HTTP and HTTPS\nover IPv4 and IPv6 using forged certificates with CA private key \\fBca.key\\fP\nand certificate \\fBca.crt\\fP, logging connections to \\fBconnect.log\\fP and\nconnection data into separate files under \\fB/tmp\\fP (add \\fB-e\\fP\n\\fInat-engine\\fP to select the appropriate engine if multiple engines are\navailable on your system):\n.LP\n.nf\n\\fBsslsplit -k ca.key -c ca.crt -l connect.log -S /tmp \\\\\n         https ::1 10443  https 127.0.0.1 10443 \\\\\n         http  ::1 10080  http  127.0.0.1 10080\\fP\n.fi\n.LP\nIf the Linux netfilter engine is used with the iptables REDIRECT target, it is\nimportant to listen to the correct IP address (e.g. 192.0.2.1) or on all\ninterfaces (0.0.0.0), otherwise SSLsplit is not able to accept incoming\nconnections.\n.LP\nIntercepting IMAP/IMAPS using the same settings:\n.LP\n.nf\n\\fBsslsplit -k ca.key -c ca.crt -l connect.log -S /tmp \\\\\n         ssl ::1 10993  ssl 127.0.0.1 10993 \\\\\n         tcp ::1 10143  tcp 127.0.0.1 10143\\fP\n.fi\n.LP\nA more targeted setup, HTTPS only, using certificate/chain/key files from\n\\fB/path/to/cert.d\\fP and statically redirecting to \\fBwww.example.org\\fP\ninstead of querying a NAT engine:\n.LP\n.nf\n\\fBsslsplit -t /path/to/cert.d -l connect.log -S /tmp \\\\\n         https ::1       10443 www.example.org 443 \\\\\n         https 127.0.0.1 10443 www.example.org 443\\fP\n.fi\n.LP\nThe original example, but using plain ssl and tcp proxyspecs to avoid header\nmodifications, and logging to a single PCAP file for post-processing with an\nexternal tool.  To facilitate log rotation via SIGUSR1, \\fB-p\\fP is also given,\nso external log rotation tools or scripts can read the PID from the PID file.\n.LP\n.nf\n\\fBsslsplit -k ca.key -c ca.crt -X log.pcap -p /var/run/sslsplit.pid \\\\\n         ssl ::1 10443  ssl 127.0.0.1 10443 \\\\\n         tcp ::1 10080  tcp 127.0.0.1 10080\\fP\n.fi\n.LP\nThe original example, but using SSL options optimized for speed by disabling\ncompression and selecting only fast cipher cipher suites and using a\nprecomputed private key \\fBleaf.key\\fP for the forged certificates.  Most\nsignificant speed increase is gained by choosing fast algorithms and small\nkeysizes for the CA and leaf private keys.  Check \\fBopenssl speed\\fP for\nalgorithm performance on your system.  Note that clients may not support all\nalgorithms and key sizes.  Also, some clients warn their users about cipher\nsuites they consider weak.\n.LP\n.nf\n\\fBsslsplit -Z -s NULL:RC4:AES128:-DHE -K leaf.key \\\\\n         -k ca.key -c ca.crt -l connect.log -S /tmp \\\\\n         https ::1 10443  https 127.0.0.1 10443 \\\\\n         http  ::1 10080  http  127.0.0.1 10080\\fP\n.fi\n.LP\nThe original example, but running as a daemon under user \\fBsslsplit\\fP and\nwriting a PID file:\n.LP\n.nf\n\\fBsslsplit -d -p /var/run/sslsplit.pid -u sslsplit \\\\\n         -k ca.key -c ca.crt -l connect.log -S /tmp \\\\\n         https ::1 10443  https 127.0.0.1 10443 \\\\\n         http  ::1 10080  http  127.0.0.1 10080\\fP\n.fi\n.LP\nTo generate a CA private key \\fBca.key\\fP  and certificate \\fBca.crt\\fP using\nOpenSSL:\n.LP\n.nf\n\\fBcat >x509v3ca.cnf <<'EOF'\\fP\n[ req ]\ndistinguished_name = reqdn\n\n[ reqdn ]\n\n[ v3_ca ]\nbasicConstraints        = CA:TRUE\nsubjectKeyIdentifier    = hash\nauthorityKeyIdentifier  = keyid:always,issuer:always\n\\fBEOF\\fP\n\n\\fBopenssl genrsa -out ca.key 2048\\fP\n\\fBopenssl req -new -nodes -x509 -sha256 -out ca.crt -key ca.key \\\\\n        -config x509v3ca.cnf -extensions v3_ca \\\\\n        -subj '/O=SSLsplit Root CA/CN=SSLsplit Root CA/' \\\\\n        -set_serial 0 -days 3650\\fP\n.fi\n.SH NOTES\nSSLsplit is able to handle a relatively high number of listeners and\nconnections due to a multithreaded, event based architecture based on libevent,\ntaking advantage of platform specific select() replacements such as kqueue.\nThe main thread handles the listeners and signaling, while a number of worker\nthreads equal to twice the number of CPU cores is used for handling the actual\nconnections in separate event bases, including the CPU-intensive SSL/TLS\nhandling.\n.LP\nCare has been taken to choose well-performing data structures for caching\ncertificates and SSL sessions.  Logging is implemented in separate disk writer\nthreads to ensure that socket event handling threads don't have to block on\ndisk I/O.\nDNS lookups are performed asynchronously.\nSSLsplit uses SSL session caching on both ends to minimize the amount of full\nSSL handshakes, but even then, the limiting factor in handling SSL connections\nare the actual bignum computations.\n.LP\nFor high performance and low latency and when running SSLsplit as root or\notherwise in a privilege separation mode, avoid using options which require a\nprivileged operation to be invoked through privilege separation for each\nconnection.  These are currently all per-connection log types:\ncontent log to per-stream file in dir or filespec (\\fB-F\\fP, \\fB-S\\fP),\ncontent log to per-stream PCAP in dir or filespec (\\fB-Y\\fP, \\fB-y\\fP), and\ngenerated or all certificates to files in directory (\\fB-w\\fP, \\fB-W\\fP).\nInstead, use the respective single-file variants where available.\nIt is possible, albeit not recommended, to bypass the default privilege\nseparation when run as root by using \\fB-u root\\fP, thereby bypassing\nprivilege separation entirely.\n.SH \"SEE ALSO\"\nsslsplit.conf(5), openssl(1), ciphers(1), speed(1),\npf(4), ipfw(8), iptables(8), ip6tables(8), ip(8),\nhostapd(8), arpspoof(8), parasite6(8), yersinia(8),\n.I https://www.roe.ch/SSLsplit\n.SH AUTHORS\nSSLsplit was written by Daniel Roethlisberger <daniel@roe.ch>.\nSSLsplit is currently maintained by Daniel Roethlisberger and Soner Tari.\n\nThe following individuals have contributed code or documentation, in\nchronological order of their first contribution:\nSteve Wills, Landon Fuller, Wayne Jensen, Rory McNamara, Alexander Neumann,\nAdam Jacob Muller, Richard Poole, Maciej Kotowicz, Eun Soo Park, Christian\nGroschupp, Alexander Savchenkov, Soner Tari, Petr Vanek, Hilko Bengen,\nPhilip Duldig, Levente Polyak, Nick French, Cihan Komecoglu and Sergey Pinaev.\n\nSSLsplit contains work sponsored by HackerOne.\n.SH BUGS\nUse Github for submission of bug reports or patches:\n.LP\n.RS\n.I https://github.com/droe/sslsplit\n.RE\n.LP\n"
        },
        {
          "name": "sslsplit.conf.5.in",
          "type": "blob",
          "size": 7.9912109375,
          "content": ".\\\"-\n.\\\" SSLsplit - transparent SSL/TLS interception\n.\\\" https://www.roe.ch/SSLsplit\n.\\\"\n.\\\" Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n.\\\" All rights reserved.\n.\\\"\n.\\\" Redistribution and use in source and binary forms, with or without\n.\\\" modification, are permitted provided that the following conditions are met:\n.\\\" 1. Redistributions of source code must retain the above copyright notice,\n.\\\"    this list of conditions and the following disclaimer.\n.\\\" 2. Redistributions in binary form must reproduce the above copyright notice,\n.\\\"    this list of conditions and the following disclaimer in the documentation\n.\\\"    and/or other materials provided with the distribution.\n.\\\"\n.\\\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n.\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n.\\\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n.\\\" ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n.\\\" LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n.\\\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n.\\\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n.\\\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n.\\\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n.\\\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n.\\\" POSSIBILITY OF SUCH DAMAGE.\n.TH \"sslsplit.conf\" \"5\" \"@@DATE@@\" \"sslsplit @@VERSION@@\" \"SSLsplit\"\n.SH \"NAME\"\n.LP \n\\fBsslsplit.conf\\fR \\- Configuration file for SSLsplit\n.SH \"DESCRIPTION\"\n.LP \nThe file sslsplit.conf configures SSLsplit, sslsplit(1).\n.SH \"FILE FORMAT\"\nThe file consists of comments and options with arguments. Each line which \nstarts with a hash (\\fB#\\fR) symbol is ignored by the parser. Options and \narguments are of the form \\fBOption Argument\\fR. The arguments are of the \nfollowing types:\n.TP\n\\fBBOOL\\fR \nBoolean value (yes/no).\n.TP \n\\fBSTRING\\fR\nString.\n.SH \"DIRECTIVES\"\n.LP \nWhen an option is not used (hashed or doesn't exist in the configuration file) \nsslsplit takes a default action. If an option does not have a command line \nequivalent, -o opt=val option can be used to override it on the command line.\n.TP \n\\fBCACert STRING\\fR\nUse CA cert (and key) to sign forged certs. Equivalent to -c command line option.\n.TP\n\\fBCAKey STRING\\fR\nUse CA key (and cert) to sign forged certs. Equivalent to -k command line option.\n.TP \n\\fBClientCert STRING\\fR\nUse cert from pemfile when destination requests client certs. Equivalent to -a command line option.\n.TP\n\\fBClientKey STRING\\fR\nUse key from pemfile when destination requests client certs. Equivalent to -b command line option.\n.TP\n\\fBCAChain STRING\\fR\nUse CA chain from pemfile (intermediate and root CA certs). Equivalent to -C command line option.\n.TP\n\\fBLeafKey STRING\\fR\nUse key from pemfile for generating leaf certs. Equivalent to -K command line option.\n.br\nDefault: generate\n.TP\n\\fBLeafCRLURL STRING\\fR\nUse URL as CRL distribution point for all forged leaf certs. Equivalent to -q command line option.\n.TP\n\\fBLeafCertDir STRING\\fR\nUse cert+chain+key PEM files from certdir to target all sites matching the common names (non-matching: generate if CA). Equivalent to -t command line option.\n.TP\n\\fBDefaultLeafCert STRING\\fR\nUse cert+chain+key from PEM file for leaf certificates if there is no match in \\fBLeafCertDir\\fR. Equivalent to -A command line option.\n.TP\n\\fBWriteGenCertsDir STRING\\fR\nWrite leaf key and only generated certificates to gendir. Equivalent to -w command line option.\n.TP\n\\fBWriteAllCertsDir STRING\\fR\nWrite leaf key and all certificates to gendir. Equivalent to -W command line option.\n.TP\n\\fBDenyOCSP BOOL\\fR\nDeny all OCSP requests on all proxyspecs. Equivalent to -O command line option.\n.TP\n\\fBPassthrough BOOL\\fR\nPassthrough SSL connections if they cannot be split because of client cert auth or no matching cert and no CA. Equivalent to -P command line option.\n.br \nDefault: drop\n.TP\n\\fBDHGroupParams STRING\\fR\nUse DH group params from pemfile. Equivalent to -g command line option.\n.br \nDefault: keyfiles or auto\n.TP\n\\fBECDHCurve STRING\\fR\nUse ECDH named curve. Equivalent to -G command line option.\n.br \nDefault: prime256v1\n.TP\n\\fBSSLCompression BOOL\\fR\nEnable/disable SSL/TLS compression on all connections. Equivalent to -Z command line option.\n.TP\n\\fBForceSSLProto STRING\\fR\nForce SSL/TLS protocol version only. Equivalent to -r command line option.\n.br \nDefault: all\n.TP\n\\fBDisableSSLProto STRING\\fR\nDisable SSL/TLS protocol version. Equivalent to -R command line option.\n.br \nDefault: none\n.TP\n\\fBCiphers STRING\\fR\nUse the given OpenSSL cipher suite spec. Equivalent to -s command line option.\n.br \nDefault: ALL:-aNULL\n.TP \n\\fBOpenSSLEngine STRING\\fR\nThe OpenSSL engine to activate, either the ID or the full path to the shared\nlibrary implementing the engine.  If an ID is given, the engine needs to be\nknown to the system-wide OpenSSL configuration.  Only available if built\nagainst a version of OpenSSL with engine support.  Equivalent to -x command\nline option.\n.TP \n\\fBNATEngine STRING\\fR\nSpecify default NAT engine to use. Equivalent to -e command line option.\n.TP \n\\fBUser STRING\\fR\nDrop privileges to user. Equivalent to -u command line option.\n.br \nDefault: nobody, if run as root\n.TP\n\\fBGroup STRING\\fR\nDrop privileges to group. Equivalent to -m command line option.\n.br\nDefault: Primary group of user\n.TP \n\\fBChroot STRING\\fR\nchroot() to jaildir (impacts sni proxyspecs, see sslsplit(1)). Equivalent to -j command line option.\n.TP \n\\fBPidFile STRING\\fR\nWrite pid to file. Equivalent to -p command line option.\n.TP \n\\fBConnectLog STRING\\fR\nConnect log: log one line summary per connection to logfile. Equivalent to -l command line option.\n.TP \n\\fBContentLog STRING\\fR\nContent log: full data to file or named pipe (excludes ContentLogDir/ContentLogPathSpec). Equivalent to -L command line option.\n.TP \n\\fBContentLogDir STRING\\fR\nContent log: full data to separate files in dir (excludes ContentLog/ContentLogPathSpec). Equivalent to -S command line option.\n.TP \n\\fBContentLogPathSpec STRING\\fR\nContent log: full data to sep files with % subst (excludes ContentLog/ContentLogDir). Equivalent to -F command line option.\n.TP \n\\fBLogProcInfo BOOL\\fR\nLook up local process owning each connection for logging. Equivalent to -i command line option.\n.TP \n\\fBPcapLog STRING\\fR\nPcap log: packets to pcapfile (excludes PcapLogDir/PcapLogPathSpec). Equivalent to -X command line option.\n.TP \n\\fBPcapLogDir STRING\\fR\nPcap log: packets to separate files in dir (excludes PcapLog/PcapLogPathSpec). Equivalent to -Y command line option.\n.TP \n\\fBPcapLogPathSpec STRING\\fR\nPcap log: packets to sep files with % subst (excludes PcapLog/PcapLogDir). Equivalent to -y command line option.\n.TP \n\\fBMirrorIf STRING\\fR\nMirror packets to interface. Equivalent to -I command line option.\n.TP \n\\fBMirrorTarget STRING\\fR\nMirror packets to target address (used with MirrorIf). Equivalent to -T command line option. Not used if the target is irrelevant (e.g. mirror to dummy device)\n.TP \n\\fBMasterKeyLog STRING\\fR\nLog master keys to logfile in SSLKEYLOGFILE format. Equivalent to -M command line option.\n.TP \n\\fBDaemon BOOL\\fR\nDaemon mode: run in background, log error messages to syslog. Equivalent to -d command line option.\n.TP \n\\fBDebug BOOL\\fR\nDebug mode: run in foreground, log debug messages on stderr. Equivalent to -D command line option.\n.TP\n\\fBVerifyPeer BOOL\\fR\nVerify peer using default certificates.\n.br\nDefault: no\n.TP\n\\fBAddSNIToCertificate BOOL\\fR\nWhen disabled, never add the SNI to forged certificates, even if the SNI \nprovided by the client does not match the server certificate's CN/SAN. Helps \npass the wrong.host test at https://badssl.com.\n.br\nDefault: yes\n.TP \n\\fBProxySpec STRING\\fR\nProxy specification: type listenaddr+port [natengine|targetaddr+port|\"sni\"+port]. Multiple specs are allowed, one on each line.\n.SH \"FILES\"\n.LP \n/usr/local/etc/sslsplit/sslsplit.conf\n.SH \"AUTHOR\"\n.LP \nThe config file facility was added by Soner Tari <sonertari@gmail.com>.\n.SH \"SEE ALSO\"\n.LP \nsslsplit(1)\n"
        },
        {
          "name": "sslsplit.conf.in",
          "type": "blob",
          "size": 6.06640625,
          "content": "# Sample configuration for sslsplit @@VERSION@@\n#\n# Use the -f command line option to start sslsplit with a config file.\n# See sslsplit.conf(5) and sslsplit(1) for documentation.\n\n# Use CA cert (and key) to sign forged certs.\n# Equivalent to -c command line option.\nCACert /usr/local/etc/sslsplit/ca.crt\n\n# Use CA key (and cert) to sign forged certs.\n# Equivalent to -k command line option.\nCAKey /usr/local/etc/sslsplit/ca.key\n\n# Use cert from pemfile when destination requests client certs.\n# Equivalent to -a command line option.\n#ClientCert /usr/local/etc/sslsplit/client.crt\n\n# Use key from pemfile when destination requests client certs.\n# Equivalent to -b command line option.\n#ClientKey /usr/local/etc/sslsplit/client.key\n\n# Use CA chain from pemfile (intermediate and root CA certs).\n# Equivalent to -C command line option.\n#CAChain /usr/local/etc/sslsplit/chain.crt\n\n# Use key from pemfile for generated leaf certs.\n# Equivalent to -K command line option.\n# (default: generate)\n#LeafKey /usr/local/etc/sslsplit/leaf.key\n\n# Use URL as CRL distribution point for all forged certs.\n# Equivalent to -q command line option.\n#LeafCRLURL http://example.com/example.crl\n\n# Use cert+chain+key PEM files from certdir to target all sites matching the\n# common names (non-matching: generate if CA).\n# Equivalent to -t command line option.\n#LeafCertDir /usr/local/etc/sslsplit/leaf.d\n\n# Use cert+chain+key from PEM file instead of generating leaf keys on the fly.\n# Equivalent to -A command line option.\n#DefaultLeafCert /usr/local/etc/sslsplit/leaf.pem\n\n# Write leaf key and only generated certificates to gendir.\n# Equivalent to -w command line option.\n#WriteGenCertsDir /var/log/sslsplit\n\n# Write leaf key and all certificates to gendir.\n# Equivalent to -W command line option.\n#WriteAllCertsDir /var/log/sslsplit\n\n# Deny all OCSP requests on all proxyspecs.\n# Equivalent to -O command line option.\n#DenyOCSP yes\n\n# Passthrough SSL connections if they cannot be split because of client cert \n# auth or no matching cert and no CA.\n# Equivalent to -P command line option.\n# (default: drop)\n#Passthrough yes\n\n# Use DH group params from pemfile.\n# Equivalent to -g command line option.\n# (default: keyfiles or auto)\n#DHGroupParams /usr/local/etc/sslsplit/dh.pem\n\n# Use ECDH named curve.\n# Equivalent to -G command line option.\n# (default: prime256v1)\n#ECDHCurve prime256v1\n\n# Enable/disable SSL/TLS compression on all connections.\n# Equivalent to -Z command line option.\n#SSLCompression no\n\n# Force SSL/TLS protocol version only.\n# Equivalent to -r command line option.\n# (default: all)\n#ForceSSLProto tls12\n\n# Disable SSL/TLS protocol version.\n# Equivalent to -R command line option.\n# (default: none)\n#DisableSSLProto tls10\n\n# Use the given OpenSSL cipher suite spec.\n# Equivalent to -s command line option.\n# (default: ALL:-aNULL)\n#Ciphers MEDIUM:HIGH\n\n# The OpenSSL engine to activate, either the ID or the full path to the shared\n# library implementing the engine. If an ID is given, the engine needs to be\n# known to the system-wide OpenSSL configuration. Only available if built\n# against a version of OpenSSL with engine support.\n# Equivalent to -x command line option\n#OpenSSLEngine cloudhsm\n\n# Specify default NAT engine to use.\n# Equivalent to -e command line option.\n#NATEngine netfilter\n\n# Drop privileges to user.\n# Equivalent to -u command line option.\n# (default: nobody, if run as root)\n#User sslsplit\n\n# Drop privileges to group.\n# Equivalent to -m command line option.\n# (default: primary group of user)\n#Group sslsplit\n\n# chroot() to jaildir (impacts sni proxyspecs, see sslsplit(1)).\n# Equivalent to -j command line option.\n#Chroot /var/run/sslsplit\n\n# Write pid to file.\n# Equivalent to -p command line option.\n# (default: no pid file)\nPidFile /var/run/sslsplit.pid\n\n# Connect log: log one line summary per connection to logfile.\n# Equivalent to -l command line option.\n#ConnectLog /var/log/sslsplit/connect.log\n\n# Content log: full data to file or named pipe\n# (excludes ContentLogDir/ContentLogPathSpec).\n# Equivalent to -L command line option.\n#ContentLog /var/log/sslsplit/content.log\n\n# Content log: full data to separate files in dir\n# (excludes ContentLog/ContentLogPathSpec).\n# Equivalent to -S command line option.\n#ContentLogDir /var/log/sslsplit/content\n\n# Content log: full data to sep files with % subst\n# (excludes ContentLog/ContentLogDir).\n# Equivalent to -F command line option.\n#ContentLogPathSpec /var/log/sslsplit/%X/%u-%s-%d-%T.log\n\n# Look up local process owning each connection for logging.\n# Equivalent to -i command line option.\n#LogProcInfo yes\n\n# Pcap log: packets to pcapfile (excludes PcapLogDir/PcapLogPathSpec).\n# Equivalent to -X command line option.\n#PcapLog /var/log/sslsplit/content.pcap\n\n# Pcap log: packets to separate files in dir\n# (excludes PcapLog/PcapLogPathSpec).\n# Equivalent to -Y command line option.\n#PcapLogDir /var/log/sslsplit/pcap\n\n# Pcap log: packets to sep files with % subst (excludes PcapLog/PcapLogDir).\n# Equivalent to -y command line option.\n#PcapLogPathSpec /var/log/sslsplit/%X/%u-%s-%d-%T.pcap\n\n# Mirror packets to interface.\n# Equivalent to -I command line option.\n#MirrorIf lo\n\n# Mirror packets to target address (used with MirrorIf).\n# Equivalent to -T command line option. Leave commented if the target is\n# irrelevant (e.g. mirror to dummy device)\n#MirrorTarget 192.0.2.1\n\n# Log master keys to logfile in SSLKEYLOGFILE format.\n# Equivalent to -M command line option.\n#MasterKeyLog /var/log/sslsplit/masterkeys.log\n\n# Daemon mode: run in background, log error messages to syslog.\n# Equivalent to -d command line option.\nDaemon yes\n\n# Debug mode: run in foreground, log debug messages on stderr.\n# Equivalent to -D command line option.\n#Debug yes\n\n# Verify peer using default certificates\n#VerifyPeer no\n\n# When disabled, never add the SNI to forged certificates, even if the SNI\n# provided by the client does not match the server certificate's CN/SAN.\n# Helps pass the wrong.host test at https://badssl.com.\n#AddSNIToCertificate yes\n\n# Proxy specifications\n# type listenaddr+port [natengine|targetaddr+port|\"sni\"+port]\nProxySpec http 127.0.0.1 8080\nProxySpec http ::1 8080\nProxySpec https 127.0.0.1 8443\nProxySpec https ::1 8443\n"
        },
        {
          "name": "sys.c",
          "type": "blob",
          "size": 22.89453125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"sys.h\"\n\n#include \"log.h\"\n#include \"defaults.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <sys/uio.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/un.h>\n#include <net/if.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <grp.h>\n#include <fts.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n\n#ifndef _SC_NPROCESSORS_ONLN\n#include <sys/sysctl.h>\n#endif /* !_SC_NPROCESSORS_ONLN */\n\n#if HAVE_DARWIN_LIBPROC\n#include <libproc.h>\n#endif\n\n#include <event2/util.h>\n\n/*\n * Permanently drop from root privileges to an unprivileged user account.\n * Sets the real, effective and stored user and group ID and the list of\n * ancillary groups.  This is only safe if the effective user ID is 0.\n * If username is unset and the effective uid != uid, drop privs to uid.\n * This is to support setuid bit configurations.\n * If groupname is set, it will be used instead of the user's default primary\n * group.\n * If jaildir is set, also chroot to jaildir after reading system files\n * but before dropping privileges.\n * Returns 0 on success, -1 on failure.\n */\nint\nsys_privdrop(const char *username, const char *groupname, const char *jaildir)\n{\n\tstruct passwd *pw = NULL;\n\tstruct group *gr = NULL;\n\tint ret = -1;\n\n\tif (groupname) {\n\t\terrno = 0;\n\t\tif (!(gr = getgrnam(groupname))) {\n\t\t\tlog_err_printf(\"Failed to getgrnam group '%s': %s\\n\",\n\t\t\t               groupname, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (username) {\n\t\terrno = 0;\n\t\tif (!(pw = getpwnam(username))) {\n\t\t\tlog_err_printf(\"Failed to getpwnam user '%s': %s\\n\",\n\t\t\t               username, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (gr != NULL) {\n\t\t\tpw->pw_gid = gr->gr_gid;\n\t\t}\n\n\t\tif (initgroups(username, pw->pw_gid) == -1) {\n\t\t\tlog_err_printf(\"Failed to initgroups user '%s': %s\\n\",\n\t\t\t               username, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (jaildir) {\n\t\tif (chroot(jaildir) == -1) {\n\t\t\tlog_err_printf(\"Failed to chroot to '%s': %s\\n\",\n\t\t\t               jaildir, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t\tif (chdir(\"/\") == -1) {\n\t\t\tlog_err_printf(\"Failed to chdir to '/': %s\\n\",\n\t\t\t               strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (username) {\n\t\tif (setgid(pw->pw_gid) == -1) {\n\t\t\tlog_err_printf(\"Failed to setgid to %i: %s\\n\",\n\t\t\t               pw->pw_gid, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t\tif (setuid(pw->pw_uid) == -1) {\n\t\t\tlog_err_printf(\"Failed to setuid to %i: %s\\n\",\n\t\t\t               pw->pw_uid, strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t} else if (getuid() != geteuid()) {\n\t\tif (setuid(getuid()) == -1) {\n\t\t\tlog_err_printf(\"Failed to setuid(getuid()): %s\\n\",\n\t\t\t               strerror(errno));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = 0;\nerror:\n\tif (pw) {\n\t\tendpwent();\n\t}\n\tif (gr) {\n\t\tendgrent();\n\t}\n\treturn ret;\n}\n\n/*\n * If the user exists and on successful lookup, return 0 and if uid != NULL,\n * write the uid of *username* to the value pointed to by uid.\n * Return -1 on failure or if the user does not exist.\n */\nint\nsys_uid(const char *username, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tint rv;\n\n\terrno = 0;\n\tif (!(pw = getpwnam(username))) {\n\t\tif (errno != 0 && errno != ENOENT) {\n\t\t\tlog_err_printf(\"Failed to load user '%s': %s (%i)\\n\",\n\t\t\t               username, strerror(errno), errno);\n\t\t}\n\t\trv = -1;\n\t} else {\n\t\tif (uid)\n\t\t\t*uid = pw->pw_uid;\n\t\trv = 0;\n\t}\n\tendpwent();\n\treturn rv;\n}\n\n/*\n * Returns 1 if username can be loaded from user database, 0 otherwise.\n */\nint\nsys_isuser(const char *username)\n{\n\treturn sys_uid(username, NULL) == 0;\n}\n\n/*\n * If the group exists and on successful lookup, return 0 and if gid != NULL,\n * write the gid of *groupname* to the value pointed to by gid.\n * Return -1 on failure or if the group does not exist.\n */\nint\nsys_gid(const char *groupname, gid_t *gid)\n{\n\tstruct group *gr;\n\tint rv;\n\n\terrno = 0;\n\tif (!(gr = getgrnam(groupname))) {\n\t\tif (errno != 0 && errno != ENOENT) {\n\t\t\tlog_err_printf(\"Failed to load group '%s': %s (%i)\\n\",\n\t\t\t               groupname, strerror(errno), errno);\n\t\t}\n\t\trv = -1;\n\t} else {\n\t\tif (gid)\n\t\t\t*gid = gr->gr_gid;\n\t\trv = 0;\n\t}\n\tendgrent();\n\treturn rv;\n}\n\n/*\n * Returns 1 if groupname can be loaded from group database, 0 otherwise.\n */\nint\nsys_isgroup(const char *groupname)\n{\n\treturn sys_gid(groupname, NULL) == 0;\n}\n\n/*\n * Returns 1 if username is equivalent to the current effective UID.\n * Returns 0 otherwise.\n */\nint\nsys_isgeteuid(const char *username)\n{\n\tuid_t uid;\n\n\tif (sys_uid(username, &uid) == -1)\n\t\treturn 0;\n\tif (uid == geteuid())\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Open and lock process ID file fn.\n * Returns open file descriptor on success or -1 on errors.\n */\nint\nsys_pidf_open(const char *fn)\n{\n\tint fd;\n\n\tif ((fd = open(fn, O_RDWR|O_CREAT, DFLT_PIDFMODE)) == -1) {\n\t\tlog_err_printf(\"Failed to open '%s': %s\\n\", fn,\n\t\t               strerror(errno));\n\t\treturn -1;\n\t}\n\tif (flock(fd, LOCK_EX|LOCK_NB) == -1) {\n\t\tlog_err_printf(\"Failed to lock '%s': %s\\n\", fn,\n\t\t               strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\n/*\n * Write process ID to open process ID file descriptor fd.\n * Returns 0 on success, -1 on errors.\n */\nint\nsys_pidf_write(int fd)\n{\n\tchar pidbuf[4*sizeof(pid_t)];\n\tint rv;\n\tssize_t n;\n\n\trv = snprintf(pidbuf, sizeof(pidbuf), \"%d\\n\", getpid());\n\tif (rv == -1 || rv >= (int)sizeof(pidbuf))\n\t\treturn -1;\n\n\tn = write(fd, pidbuf, strlen(pidbuf));\n\tif (n < (ssize_t)strlen(pidbuf))\n\t\treturn -1;\n\n\trv = fsync(fd);\n\tif (rv == -1)\n\t\treturn -1;\n\n\trv = fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\tif (rv == -1)\n\t\treturn -1;\n\n\treturn 0;\n}\n\n/*\n * Close and remove open process ID file before quitting.\n */\nvoid\nsys_pidf_close(int fd, const char *fn)\n{\n\tunlink(fn);\n\tclose(fd);\n}\n\n/*\n * Converts a local uid into a printable string representation.\n * Returns an allocated buffer which must be freed by caller, or NULL on error.\n */\nchar *\nsys_user_str(uid_t uid)\n{\n\tstatic int bufsize = 0;\n\n\tif (!bufsize) {\n\t\t/* on some platforms this compiles, but does not succeed */\n\t\tif ((bufsize = sysconf(_SC_GETPW_R_SIZE_MAX)) == -1) {\n\t\t\tbufsize = 64;\n\t\t}\n\t}\n\n\tchar *buf, *newbuf;\n\tstruct passwd pwd, *result = NULL;\n\tint rv;\n\tchar *name;\n\n\tif (!(buf = malloc(bufsize)))\n\t\treturn NULL;\n\n\tdo {\n\t\trv = getpwuid_r(uid, &pwd, buf, bufsize, &result);\n\t\tif (rv == 0) {\n\t\t\tif (result) {\n\t\t\t\tname = strdup(pwd.pw_name);\n\t\t\t\tfree(buf);\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\tfree(buf);\n\n\t\t\t/* no entry found; return the integer representation */\n\t\t\tif (asprintf(&name, \"%llu\", (long long) uid) < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t\tbufsize *= 2;\n\t\tif (!(newbuf = realloc(buf, bufsize))) {\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = newbuf;\n\t} while (rv == ERANGE);\n\n\tfree(buf);\n\tlog_err_printf(\"Failed to lookup uid: %s (%i)\\n\", strerror(rv), rv);\n\treturn NULL;\n}\n\n/*\n * Converts a local gid into a printable string representation.\n * Returns an allocated buffer which must be freed by caller, or NULL on error.\n */\nchar *\nsys_group_str(gid_t gid)\n{\n\tstatic int bufsize = 0;\n\n\tif (!bufsize) {\n\t\t/* on some platforms this compiles, but does not succeed */\n\t\tif ((bufsize = sysconf(_SC_GETGR_R_SIZE_MAX)) == -1) {\n\t\t\tbufsize = 64;\n\t\t}\n\t}\n\n\tchar *buf, *newbuf;\n\tstruct group grp, *result = NULL;\n\tint rv;\n\tchar *name;\n\n\tif (!(buf = malloc(bufsize)))\n\t\treturn NULL;\n\n\tdo {\n\t\trv = getgrgid_r(gid, &grp, buf, bufsize, &result);\n\t\tif (rv == 0) {\n\t\t\tif (result) {\n\t\t\t\tname = strdup(grp.gr_name);\n\t\t\t\tfree(buf);\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\tfree(buf);\n\n\t\t\t/* no entry found; return the integer representation */\n\t\t\tif (asprintf(&name, \"%llu\", (long long) gid) < 0) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\treturn name;\n\t\t}\n\t\tbufsize *= 2;\n\t\tif (!(newbuf = realloc(buf, bufsize))) {\n\t\t\tfree(buf);\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = newbuf;\n\t} while (rv == ERANGE);\n\n\tfree(buf);\n\tlog_err_printf(\"Failed to lookup gid: %s (%i)\\n\", strerror(rv), rv);\n\treturn NULL;\n}\n\n/*\n * Determine address family of addr\n */\nint\nsys_get_af(const char *addr)\n{\n\tif (strstr(addr, \":\"))\n\t\treturn AF_INET6;\n\telse if (!strpbrk(addr, \"abcdefghijklmnopqrstu\"\n\t\t\t\t\t\t\t\"vwxyzABCDEFGHIJKLMNOP\"\n\t\t\t\t\t\t\t\"QRSTUVWXYZ-\"))\n\t\treturn AF_INET;\n\telse\n\t\treturn AF_UNSPEC;\n}\n\n/*\n * Parse an ascii host/IP and port tuple into a sockaddr_storage.\n * On success, returns address family and fills in addr, addrlen.\n * Returns -1 on error.\n */\nint\nsys_sockaddr_parse(struct sockaddr_storage *addr, socklen_t *addrlen,\n                   char *naddr, char *nport, int af, int flags)\n{\n\tstruct evutil_addrinfo hints;\n\tstruct evutil_addrinfo *ai;\n\tint rv;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = af;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_flags = EVUTIL_AI_ADDRCONFIG | flags;\n\trv = evutil_getaddrinfo(naddr, nport, &hints, &ai);\n\tif (rv != 0) {\n\t\tlog_err_printf(\"Cannot resolve address '%s' port '%s': %s\\n\",\n\t\t               naddr, nport, gai_strerror(rv));\n\t\treturn -1;\n\t}\n\tmemcpy(addr, ai->ai_addr, ai->ai_addrlen);\n\t*addrlen = ai->ai_addrlen;\n\taf = ai->ai_family;\n\tfreeaddrinfo(ai);\n\treturn af;\n}\n\n/*\n * Converts an IPv4/IPv6 sockaddr into printable string representations of the\n * host and the service (port) part.  Writes allocated buffers to *host and\n * *serv which must both be freed by the caller.  Neither *host nor *port are\n * freed by this function before newly allocating.\n * Returns 0 on success, -1 otherwise.  When -1 is returned, pointers in *host\n * and *serv are invalid and must not be used nor freed by the caller.\n */\nint\nsys_sockaddr_str(struct sockaddr *addr, socklen_t addrlen,\n                 char **host, char **serv)\n{\n\tchar tmphost[INET6_ADDRSTRLEN];\n\tchar tmpserv[6]; /* max decimal digits of short plus terminator */\n\tint rv;\n\n\trv = getnameinfo(addr, addrlen,\n\t                 tmphost, sizeof(tmphost),\n\t                 tmpserv, sizeof(tmpserv),\n\t                 NI_NUMERICHOST | NI_NUMERICSERV);\n\tif (rv != 0) {\n\t\tlog_err_printf(\"Cannot get nameinfo for socket address: %s\\n\",\n\t\t               gai_strerror(rv));\n\t\treturn -1;\n\t}\n\t*serv = strdup(tmpserv);\n\tif (!*serv) {\n\t\tlog_err_printf(\"Cannot allocate memory\\n\");\n\t\treturn -1;\n\t}\n\t*host = strdup(tmphost);\n\tif (!*host) {\n\t\tlog_err_printf(\"Cannot allocate memory\\n\");\n\t\tfree(*serv);\n\t\t*serv = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/*\n * Sanitizes a valid IPv4 or IPv6 address for use in a filename, i.e. removes\n * characters that are invalid on NTFS and replaces them with more innocent\n * characters.  The function assumes that the input is a valid IPv4 or IPv6\n * address; it is not a generic filename sanitizer.\n *\n * Returns a copy of string s that must be freed by the caller.\n *\n * Invalid NTFS characters are < > : \" / \\ | ? * according to\n * https://msdn.microsoft.com/en-gb/library/windows/desktop/aa365247.aspx\n */\nchar *\nsys_ip46str_sanitize(const char *s)\n{\n\tchar *copy, *p;\n\n\tcopy = strdup(s);\n\tif (!copy)\n\t\treturn NULL;\n\tp = copy;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\tcase ':':\n\t\tcase '%':\n\t\t\t*p = '_';\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\n\treturn copy;\n}\n\n/*\n * Returns the MTU of the interface with name *ifname* or 0 on errors.\n */\nsize_t\nsys_get_mtu(const char *ifname)\n{\n\tstruct ifreq ifr;\n\tsize_t ifnamelen;\n\tint s;\n\n\tifnamelen = strlen(ifname);\n\tif (ifnamelen > sizeof(ifr.ifr_name) + 1)\n\t\treturn 0;\n\tmemcpy(ifr.ifr_name, ifname, ifnamelen);\n\tifr.ifr_name[ifnamelen] = '\\0';\n\n\ts = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);\n\tif (s == -1)\n\t\treturn 0;\n\tif (ioctl(s, SIOCGIFMTU, &ifr) == -1) {\n\t\tclose(s);\n\t\treturn 0;\n\t}\n\tclose(s);\n\treturn ifr.ifr_mtu;\n}\n\n/*\n * Returns 1 if path points to an existing directory node in the filesystem.\n * Returns 0 if path is NULL, does not exist, or points to a file of some kind.\n */\nint\nsys_isdir(const char *path)\n{\n\tstruct stat s;\n\n\tif (stat(path, &s) == -1) {\n\t\tif (errno != ENOENT) {\n\t\t\tlog_err_printf(\"Error stating file: %s (%i)\\n\",\n\t\t\t               strerror(errno), errno);\n\t\t}\n\t\treturn 0;\n\t}\n\tif (s.st_mode & S_IFDIR)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Create directory including parent directories with mode_t.\n * Mode of existing parent directories is not changed.\n * Returns 0 on success, -1 and sets errno on error.\n */\nint\nsys_mkpath(const char *path, mode_t mode)\n{\n\tchar parent[strlen(path)+1];\n\tchar *p;\n\n\tmemcpy(parent, path, sizeof(parent));\n\n\tp = parent;\n\tdo {\n\t\t/* skip leading '/' characters */\n\t\twhile (*p == '/') p++;\n\t\tp = strchr(p, '/');\n\t\tif (p) {\n\t\t\t/* overwrite '/' to terminate the string at the next\n\t\t\t * parent directory */\n\t\t\t*p = '\\0';\n\t\t}\n\n\t\tstruct stat sbuf;\n\t\tif (stat(parent, &sbuf) == -1) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\tif (mkdir(parent, mode) != 0)\n\t\t\t\t\treturn -1;\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (!S_ISDIR(sbuf.st_mode)) {\n\t\t\terrno = ENOTDIR;\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (p) {\n\t\t\t/* replace the overwritten slash */\n\t\t\t*p = '/';\n\t\t\tp++;\n\t\t}\n\t} while (p);\n\n\treturn 0;\n}\n\n/*\n * Return realpath(dirname(path)) + / + basename(path) in a newly allocated\n * string.  Returns NULL on failure and sets errno to ENOENT if the directory\n * part does not exist.\n */\nchar *\nsys_realdir(const char *path)\n{\n\tchar *sep, *udir, *rdir, *p;\n\tint rerrno, rv;\n\n\tif (path[0] == '\\0') {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tudir = strdup(path);\n\tif (!udir)\n\t\treturn NULL;\n\n\tsep = strrchr(udir, '/');\n\tif (!sep) {\n\t\tfree(udir);\n\t\trv = asprintf(&udir, \"./%s\", path);\n\t\tif (rv == -1)\n\t\t\treturn NULL;\n\t\tsep = udir + 1;\n\t} else if (sep == udir) {\n\t\treturn udir;\n\t}\n\t*sep = '\\0';\n\trdir = realpath(udir, NULL);\n\tif (!rdir) {\n\t\trerrno = errno;\n\t\tfree(udir);\n\t\terrno = rerrno;\n\t\treturn NULL;\n\t}\n\trv = asprintf(&p, \"%s/%s\", rdir, sep + 1);\n\trerrno = errno;\n\tfree(rdir);\n\tfree(udir);\n\terrno = rerrno;\n\tif (rv == -1)\n\t\treturn NULL;\n\treturn p;\n}\n\n/*\n * Iterate over all files in a directory hierarchy, calling the callback\n * cb for each file, passing the filename and arg as arguments.  Files and\n * directories beginning with a dot are skipped, symlinks are followed.\n */\nint\nsys_dir_eachfile(const char *dirname, sys_dir_eachfile_cb_t cb, void *arg)\n{\n\tFTS *tree;\n\tFTSENT *node;\n\tchar * paths[2];\n\tint rv = 0;\n\n\tpaths[1] = NULL;\n\tpaths[0] = strdup(dirname);\n\tif (!paths[0])\n\t\treturn -1;\n\n\ttree = fts_open(paths, FTS_NOCHDIR | FTS_LOGICAL, NULL);\n\tif (!tree) {\n\t\tlog_err_printf(\"Cannot open directory '%s': %s\\n\",\n\t\t               dirname, strerror(errno));\n\t\trv = -1;\n\t\tgoto out1;\n\t}\n\n\twhile ((node = fts_read(tree))) {\n\t\tif (node->fts_level > 0 && node->fts_name[0] == '.')\n\t\t\tfts_set(tree, node, FTS_SKIP);\n\t\telse if (node->fts_info & FTS_F) {\n\t\t\trv = cb(node->fts_path, arg);\n\t\t\tif (rv == -1)\n\t\t\t\tgoto out2;\n\t\t}\n\t}\n\tif (errno) {\n\t\tlog_err_printf(\"Error reading directory entry: %s\\n\",\n\t\t               strerror(errno));\n\t\trv = -1;\n\t\tgoto out2;\n\t}\n\nout2:\n\tfts_close(tree);\n\nout1:\n\tfree(paths[0]);\n\treturn rv;\n}\n\n/*\n * Portably get the number of CPU cores online in the system.\n */\nuint32_t\nsys_get_cpu_cores(void)\n{\n#ifdef _SC_NPROCESSORS_ONLN\n\treturn sysconf(_SC_NPROCESSORS_ONLN);\n#else /* !_SC_NPROCESSORS_ONLN */\n\tint mib[2];\n\tuint32_t n;\n\tsize_t len = sizeof(n);\n\n\tmib[0] = CTL_HW;\n\tmib[1] = HW_AVAILCPU;\n\tsysctl(mib, sizeof(mib)/sizeof(int), &n, &len, NULL, 0);\n\n\tif (n < 1) {\n\t\tmib[1] = HW_NCPU;\n\t\tsysctl(mib, sizeof(mib)/sizeof(int), &n, &len, NULL, 0);\n\t\tif (n < 1) {\n\t\t\tn = 1;\n\t\t}\n\t}\n\treturn n;\n#endif /* !_SC_NPROCESSORS_ONLN */\n}\n\n/*\n * Send a message and optional file descriptor on a connected AF_UNIX\n * SOCKET_DGRAM socket s.  Returns the return value of sendmsg().\n * If fd is -1, no file descriptor is passed.\n */\nssize_t\nsys_sendmsgfd(int sock, void *buf, size_t bufsz, int fd)\n{\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct cmsghdr *cmsg;\n\tchar cmsgbuf[CMSG_SPACE(sizeof(int))];\n\tssize_t n;\n\n\tiov.iov_base = buf;\n\tiov.iov_len = bufsz;\n\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_flags = 0;\n\n\tif (fd != -1) {\n\t\tmsg.msg_control = cmsgbuf;\n\t\tmsg.msg_controllen = sizeof(cmsgbuf);\n\t\tmemset(cmsgbuf, 0, sizeof(cmsgbuf));\n\n\t\tcmsg = CMSG_FIRSTHDR(&msg);\n\t\tif (!cmsg)\n\t\t\treturn -1;\n\t\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\t\tcmsg->cmsg_level = SOL_SOCKET;\n\t\tcmsg->cmsg_type = SCM_RIGHTS;\n\n\t\t*((int *) CMSG_DATA(cmsg)) = fd;\n\t} else {\n\t\tmsg.msg_control = NULL;\n\t\tmsg.msg_controllen = 0;\n\t}\n\tdo {\n#ifdef MSG_NOSIGNAL\n\t\tn = sendmsg(sock, &msg, MSG_NOSIGNAL);\n#else /* !MSG_NOSIGNAL */\n\t\tn = sendmsg(sock, &msg, 0);\n#endif /* !MSG_NOSIGNAL */\n\t} while (n == -1 && errno == EINTR);\n\treturn n;\n}\n\n/*\n * Receive a message and optional file descriptor on a connected AF_UNIX\n * SOCKET_DGRAM socket s.  Returns the return value of recvmsg()/recv()\n * and sets errno to EINVAL if the received message is malformed.\n * If pfd is NULL, no file descriptor is received; if a file descriptor was\n * part of the received message and pfd is NULL, then the kernel will close it.\n */\nssize_t\nsys_recvmsgfd(int sock, void *buf, size_t bufsz, int *pfd)\n{\n\tssize_t n;\n\n\tif (pfd) {\n\t\tstruct iovec iov;\n\t\tstruct msghdr msg;\n\t\tstruct cmsghdr *cmsg;\n\t\tunsigned char cmsgbuf[CMSG_SPACE(sizeof(int))];\n\n\t\tiov.iov_base = buf;\n\t\tiov.iov_len = bufsz;\n\n\t\tmsg.msg_name = NULL;\n\t\tmsg.msg_namelen = 0;\n\t\tmsg.msg_iov = &iov;\n\t\tmsg.msg_iovlen = 1;\n\t\tmsg.msg_control = cmsgbuf;\n\t\tmsg.msg_controllen = sizeof(cmsgbuf);\n\t\tdo {\n\t\t\tn = recvmsg(sock, &msg, 0);\n\t\t} while (n == -1 && errno == EINTR);\n\t\tif (n <= 0)\n\t\t\treturn n;\n\t\tcmsg = CMSG_FIRSTHDR(&msg);\n\t\tif (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {\n\t\t\tif (cmsg->cmsg_level != SOL_SOCKET) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (cmsg->cmsg_type != SCM_RIGHTS) {\n\t\t\t\terrno = EINVAL;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*pfd = *((int *) CMSG_DATA(cmsg));\n\t\t} else {\n\t\t\t*pfd = -1;\n\t\t}\n\t} else {\n\t\tdo {\n\t\t\tn = recv(sock, buf, bufsz, 0);\n\t\t} while (n == -1 && errno == EINTR);\n\t}\n\treturn n;\n}\n\n/*\n * Format AF_UNIX socket address into printable string.\n * Returns newly allocated string that must be freed by caller.\n */\nstatic char *\nsys_afunix_str(struct sockaddr *addr, socklen_t addrlen)\n{\n\tstruct sockaddr_un *sun = (struct sockaddr_un *)addr;\n\tchar *name;\n\tint rv;\n\n\tif (addrlen == sizeof(sa_family_t)) {\n\t\trv = asprintf(&name, \"unnmd\");\n\t} else if (sun->sun_path[0] == '\\0') {\n\t\t/* abstract sockets is a Linux feature */\n\t\trv = asprintf(&name, \"abstr:%02x:%02x:%02x:%02x\",\n\t\t                     sun->sun_path[1],\n\t\t                     sun->sun_path[2],\n\t\t                     sun->sun_path[3],\n\t\t                     sun->sun_path[4]);\n\t} else {\n\t\trv = asprintf(&name, \"pname:%s\", sun->sun_path);\n\t}\n\tif (rv == -1)\n\t\tname = NULL;\n\treturn name;\n}\n\n/*\n * Dump all open file descriptors to stdout - poor man's lsof/fstat/sockstat\n */\nvoid\nsys_dump_fds(void)\n{\n\tint maxfd = 0;\n\n#ifdef F_MAXFD\n\tif (!maxfd && ((maxfd = fcntl(0, F_MAXFD)) == -1)) {\n\t\tfprintf(stderr, \"fcntl(0, F_MAXFD) failed: %s (%i)\\n\",\n\t\t                strerror(errno), errno);\n\t}\n#endif /* F_MAXFD */\n#ifdef _SC_OPEN_MAX\n\tif (!maxfd && ((maxfd = sysconf(_SC_OPEN_MAX)) == -1)) {\n\t\tfprintf(stderr, \"sysconf(_SC_OPEN_MAX) failed: %s (%i)\\n\",\n\t\t                strerror(errno), errno);\n\t}\n#endif /* _SC_OPEN_MAX */\n\tif (!maxfd)\n\t\tmaxfd = 65535;\n\n\tfor (int fd = 0; fd <= maxfd; fd++) {\n\t\tstruct stat st;\n\n\t\tif (fstat(fd, &st) == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tprintf(\"%5d:\", fd);\n\t\tswitch (st.st_mode & S_IFMT) {\n\t\tcase S_IFBLK:  printf(\" blkdev\"); break;\n\t\tcase S_IFCHR:  printf(\" chrdev\"); break;\n\t\tcase S_IFDIR:  printf(\" dir   \"); break;\n\t\tcase S_IFIFO:  printf(\" fifo  \"); break;\n\t\tcase S_IFLNK:  printf(\" lnkfil\"); break;\n\t\tcase S_IFREG:  printf(\" regfil\"); break;\n\t\tcase S_IFSOCK: printf(\" socket\"); break;\n\t\tdefault:       printf(\" unknwn\"); break;\n\t\t}\n\n\t\tif ((st.st_mode & S_IFMT) == S_IFSOCK) {\n\t\t\tint lrv, frv, arv;\n\t\t\tstruct sockaddr_storage lss, fss;\n\t\t\tsocklen_t lsslen = sizeof(lss);\n\t\t\tsocklen_t fsslen = sizeof(fss);\n\t\t\tchar *laddrstr, *faddrstr;\n\n\t\t\tlrv = getsockname(fd, (struct sockaddr *)&lss, &lsslen);\n\t\t\tfrv = getpeername(fd, (struct sockaddr *)&fss, &fsslen);\n\n\t\t\tswitch (lss.ss_family) {\n\t\t\tcase AF_INET:\n\t\t\tcase AF_INET6: {\n\t\t\t\tif (lrv == 0) {\n\t\t\t\t\tchar *host, *port;\n\t\t\t\t\tif (sys_sockaddr_str(\n\t\t\t\t\t        (struct sockaddr *)&lss,\n\t\t\t\t\t        lsslen,\n\t\t\t\t\t        &host, &port) != 0) {\n\t\t\t\t\t\tladdrstr = strdup(\"?\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarv = asprintf(&laddrstr,\n\t\t\t\t\t\t               \"[%s]:%s\",\n\t\t\t\t\t\t               host, port);\n\t\t\t\t\t\tif (arv == -1)\n\t\t\t\t\t\t\tladdrstr = NULL;\n\t\t\t\t\t\tfree(host);\n\t\t\t\t\t\tfree(port);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tladdrstr = strdup(\"n/a\");\n\t\t\t\t}\n\t\t\t\tif (frv == 0) {\n\t\t\t\t\tchar *host, *port;\n\t\t\t\t\tif (sys_sockaddr_str(\n\t\t\t\t\t        (struct sockaddr *)&fss,\n\t\t\t\t\t        fsslen,\n\t\t\t\t\t        &host, &port) != 0) {\n\t\t\t\t\t\tfaddrstr = strdup(\"?\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarv = asprintf(&faddrstr,\n\t\t\t\t\t\t               \"[%s]:%s\",\n\t\t\t\t\t\t               host, port);\n\t\t\t\t\t\tif (arv == -1)\n\t\t\t\t\t\t\tfaddrstr = NULL;\n\t\t\t\t\t\tfree(host);\n\t\t\t\t\t\tfree(port);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfaddrstr = strdup(\"n/a\");\n\t\t\t\t}\n\t\t\t\tprintf(\" %-6s %s -> %s\",\n\t\t\t\t       lss.ss_family == AF_INET ? \"in\" : \"in6\",\n\t\t\t\t       laddrstr, faddrstr);\n\t\t\t\tfree(laddrstr);\n\t\t\t\tfree(faddrstr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AF_UNIX: {\n\t\t\t\tif (lrv == 0) {\n\t\t\t\t\tladdrstr = sys_afunix_str((struct sockaddr *)&lss, lsslen);\n\t\t\t\t} else {\n\t\t\t\t\tladdrstr = strdup(\"n/a\");\n\t\t\t\t}\n\t\t\t\tif (frv == 0) {\n\t\t\t\t\tfaddrstr = sys_afunix_str((struct sockaddr *)&fss, fsslen);\n\t\t\t\t} else {\n\t\t\t\t\tfaddrstr = strdup(\"n/a\");\n\t\t\t\t}\n\t\t\t\tprintf(\" unix   %s -> %s\", laddrstr, faddrstr);\n\t\t\t\tfree(laddrstr);\n\t\t\t\tfree(faddrstr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase AF_UNSPEC: {\n\t\t\t\tprintf(\" unspec\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tprintf(\" (%i)\", lss.ss_family);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}\n\nstatic int sys_rand_seeded = 0;\n\nstatic void\nsys_rand_seed(void) {\n\tstruct timespec seed;\n\n\tif (clock_gettime(CLOCK_REALTIME, &seed) == -1) {\n\t\tsrandom((unsigned)time(NULL));\n\t} else {\n\t\tsrandom((unsigned)(seed.tv_sec ^ seed.tv_nsec));\n\t}\n\tsys_rand_seeded = 1;\n}\n\nuint16_t\nsys_rand16(void) {\n\tif (unlikely(!sys_rand_seeded))\n\t\tsys_rand_seed();\n\treturn random();\n}\n\nuint32_t\nsys_rand32(void) {\n\tif (unlikely(!sys_rand_seeded))\n\t\tsys_rand_seed();\n\treturn random();\n}\n\n/* vim: set noet ft=c: */\n\n"
        },
        {
          "name": "sys.h",
          "type": "blob",
          "size": 3.05859375,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef SYS_H\n#define SYS_H\n\n#include \"attrib.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <stdint.h>\n\nint sys_privdrop(const char *, const char *, const char *) WUNRES;\n\nint sys_pidf_open(const char *) NONNULL(1) WUNRES;\nint sys_pidf_write(int) WUNRES;\nvoid sys_pidf_close(int, const char *) NONNULL(2);\n\nint sys_uid(const char *, uid_t *) NONNULL(1) WUNRES;\nint sys_gid(const char *, gid_t *) NONNULL(1) WUNRES;\nint sys_isuser(const char *) NONNULL(1) WUNRES;\nint sys_isgroup(const char *) NONNULL(1) WUNRES;\nint sys_isgeteuid(const char *) NONNULL(1) WUNRES;\nchar * sys_user_str(uid_t) MALLOC;\nchar * sys_group_str(gid_t) MALLOC;\n\nint sys_get_af(const char *);\nint sys_sockaddr_parse(struct sockaddr_storage *, socklen_t *,\n                       char *, char *, int, int) NONNULL(1,2,3,4) WUNRES;\nint sys_sockaddr_str(struct sockaddr *, socklen_t,\n                     char **, char **) NONNULL(1,3,4);\nchar * sys_ip46str_sanitize(const char *) NONNULL(1) MALLOC;\nsize_t sys_get_mtu(const char *);\n\nint sys_isdir(const char *) NONNULL(1) WUNRES;\nint sys_mkpath(const char *, mode_t) NONNULL(1) WUNRES;\nchar * sys_realdir(const char *) NONNULL(1) MALLOC;\n\ntypedef int (*sys_dir_eachfile_cb_t)(const char *, void *) NONNULL(1) WUNRES;\nint sys_dir_eachfile(const char *, sys_dir_eachfile_cb_t, void *) NONNULL(1,2) WUNRES;\n\nuint32_t sys_get_cpu_cores(void) WUNRES;\n\nssize_t sys_sendmsgfd(int, void *, size_t, int) NONNULL(2) WUNRES;\nssize_t sys_recvmsgfd(int, void *, size_t, int *) NONNULL(2) WUNRES;\n\nvoid sys_dump_fds(void);\n\nuint16_t sys_rand16(void);\nuint32_t sys_rand32(void);\n\n#endif /* !SYS_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "sys.t.c",
          "type": "blob",
          "size": 8.390625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"sys.h\"\n\n#include \"defaults.h\"\n\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <pthread.h>\n\n#include <check.h>\n\n#define TARGETDIR \"extra/pki/targets\"\nstatic char template[] = \"/tmp/sslsplit.test.XXXXXX\";\nstatic char *basedir;\nstatic char *file, *lfile, *dir, *ldir, *notexist;\n\nstatic void\nsys_isdir_setup(void)\n{\n\tbasedir = strdup(template);\n\tif (!mkdtemp(basedir)) {\n\t\tperror(\"mkdtemp\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (asprintf(&file, \"%s/file\", basedir) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (asprintf(&lfile, \"%s/lfile\", basedir) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (asprintf(&dir, \"%s/dir\", basedir) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (asprintf(&ldir, \"%s/ldir\", basedir) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (asprintf(&notexist, \"%s/DOES_NOT_EXIST\", basedir) == -1) {\n\t\tperror(\"asprintf\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tclose(open(file, O_CREAT|O_WRONLY|O_APPEND, DFLT_FILEMODE));\n\tif (symlink(file, lfile) == -1) {\n\t\tperror(\"symlink\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (mkdir(dir, 0700) == -1) {\n\t\tperror(\"mkdir\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif (symlink(dir, ldir) == -1) {\n\t\tperror(\"symlink\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nstatic void\nsys_isdir_teardown(void)\n{\n\tunlink(lfile);\n\tunlink(file);\n\tunlink(ldir);\n\trmdir(dir);\n\trmdir(basedir);\n\tfree(lfile);\n\tfree(file);\n\tfree(ldir);\n\tfree(dir);\n\tfree(notexist);\n}\n\nSTART_TEST(sys_isdir_01)\n{\n\tfail_unless(sys_isdir(dir), \"Directory !isdir\");\n}\nEND_TEST\n\nSTART_TEST(sys_isdir_02)\n{\n\tfail_unless(sys_isdir(ldir), \"Symlink dir !isdir\");\n}\nEND_TEST\n\nSTART_TEST(sys_isdir_03)\n{\n\tfail_unless(!sys_isdir(notexist), \"Not-exist isdir\");\n}\nEND_TEST\n\nSTART_TEST(sys_isdir_04)\n{\n\tfail_unless(!sys_isdir(file), \"File isdir\");\n}\nEND_TEST\n\nSTART_TEST(sys_isdir_05)\n{\n\tfail_unless(!sys_isdir(lfile), \"Symlink file isdir\");\n}\nEND_TEST\n\nstatic void\nsys_mkpath_setup(void)\n{\n\tbasedir = strdup(template);\n\tif (!mkdtemp(basedir)) {\n\t\tperror(\"mkdtemp\");\n\t\texit(EXIT_FAILURE);\n\t}\n}\n\nstatic void\nsys_mkpath_teardown(void)\n{\n\tchar *cmd;\n\tint rv;\n\n\trv = asprintf(&cmd, \"rm -r '%s'\", basedir);\n\tif ((rv != -1) && cmd) {\n\t\trv = system(cmd);\n\t\tif (rv == -1) {\n\t\t\tperror(\"system\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n}\n\nSTART_TEST(sys_mkpath_01)\n{\n\tchar *dir;\n\tint rv;\n\n\trv = asprintf(&dir, \"%s/a/bb/ccc/dddd/eeeee/ffffff/ggggggg/hhhhhhhh\",\n\t              basedir);\n\tfail_unless((rv != -1) && !!dir, \"asprintf failed\");\n\tfail_unless(!sys_isdir(dir), \"dir already sys_isdir()\");\n\tfail_unless(!sys_mkpath(dir, DFLT_DIRMODE), \"sys_mkpath failed\");\n\tfail_unless(sys_isdir(dir), \"dir not sys_isdir()\");\n\tfree(dir);\n}\nEND_TEST\n\nSTART_TEST(sys_realdir_01)\n{\n\tchar *rd;\n\n\trd = sys_realdir(\"./extra/../sys.t.c\");\n\tfail_unless(!!rd, \"sys_realdir failed\");\n\tfail_unless(!!strstr(rd, \"/sys.t.c\"), \"filename not found\");\n\tfail_unless(!strstr(rd, \"/extra/\"), \"extra in path\");\n\tfail_unless(!strstr(rd, \"/../\"), \"dot-dot in path\");\n\tfree(rd);\n}\nEND_TEST\n\nSTART_TEST(sys_realdir_02)\n{\n\tchar *rd;\n\n\trd = sys_realdir(\"/foo/bar/baz\");\n\tfail_unless(!rd, \"sys_realdir did not fail\");\n\tfail_unless(errno == ENOENT, \"errno not ENOENT\");\n}\nEND_TEST\n\nSTART_TEST(sys_realdir_03)\n{\n\tchar *rd;\n\n\trd = sys_realdir(\"foobarbaz\");\n\tfail_unless(!!rd, \"sys_realdir failed\");\n\tfail_unless(!!strstr(rd, \"/foobarbaz\"), \"filename not found or dir\");\n\tfree(rd);\n}\nEND_TEST\n\nSTART_TEST(sys_realdir_04)\n{\n\tchar *rd;\n\n\trd = sys_realdir(\"\");\n\tfail_unless(!rd, \"sys_realdir did not fail\");\n}\nEND_TEST\n\nint\nsys_dir_eachfile_cb(UNUSED const char *fn, void *arg)\n{\n\t*((int*)arg) += 1;\n\t/* fprintf(stderr, \"%s\\n\", fn); */\n\treturn 0;\n}\n\nSTART_TEST(sys_dir_eachfile_01)\n{\n\tint flag = 0;\n\tint rv;\n\n\trv = sys_dir_eachfile(TARGETDIR, sys_dir_eachfile_cb, &flag);\n\n\tfail_unless(rv == 0, \"Did not return success\");\n\tfail_unless(flag == 2, \"Iterated wrong number of files\");\n}\nEND_TEST\n\nSTART_TEST(sys_get_cpu_cores_01)\n{\n\tfail_unless(sys_get_cpu_cores() >= 1, \"Number of CPU cores < 1\");\n}\nEND_TEST\n\nvoid *\nthrmain(void *arg)\n{\n\t*((int*)arg) = 1;\n\treturn (void*) 2;\n}\n\nSTART_TEST(pthread_create_01)\n{\n\tpthread_t tid;\n\tint x = 0;\n\tvoid *rv;\n\tfail_unless(!pthread_create(&tid, NULL, thrmain, &x),\n\t            \"Cannot create thread\");\n\tfail_unless(!pthread_join(tid, &rv), \"Cannot join thread\");\n\tfail_unless(x == 1, \"Thread failed to update x\");\n\tfail_unless(rv == (void*) 2, \"Thread return value mismatch\");\n}\nEND_TEST\n\nSTART_TEST(sys_user_str_01)\n{\n\tchar *name = sys_user_str(0);\n\tfail_unless(!strcmp(name, TEST_ZEROUSR), \"User 0 name mismatch\");\n}\nEND_TEST\n\nSTART_TEST(sys_group_str_01)\n{\n\tchar *name = sys_group_str(0);\n\tfail_unless(!strcmp(name, TEST_ZEROGRP), \"Group 0 name mismatch\");\n}\nEND_TEST\n\nSTART_TEST(sys_ip46str_sanitize_01)\n{\n\tchar *clean;\n\n\tclean = sys_ip46str_sanitize(\"2a01:7c8:aab0:1fb::1\");\n\tfail_unless(!!clean, \"Sanitized string is NULL\");\n\tfail_unless(!strcmp(clean, \"2a01_7c8_aab0_1fb__1\"),\n\t            \"Unexpected result\");\n\tfree(clean);\n}\nEND_TEST\n\nSTART_TEST(sys_ip46str_sanitize_02)\n{\n\tchar *clean;\n\n\tclean = sys_ip46str_sanitize(\"127.0.0.1\");\n\tfail_unless(!!clean, \"Sanitized string is NULL\");\n\tfail_unless(!strcmp(clean, \"127.0.0.1\"),\n\t            \"Unexpected result\");\n\tfree(clean);\n}\nEND_TEST\n\nSTART_TEST(sys_ip46str_sanitize_03)\n{\n\tchar *clean;\n\n\tclean = sys_ip46str_sanitize(\"fe80::5626:96ff:e4a7:f583%en0\");\n\tfail_unless(!!clean, \"Sanitized string is NULL\");\n\tfail_unless(!strcmp(clean, \"fe80__5626_96ff_e4a7_f583_en0\"),\n\t            \"Unexpected result\");\n\tfree(clean);\n}\nEND_TEST\n\n\nSuite *\nsys_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"sys\");\n\n\ttc = tcase_create(\"sys_isdir\");\n\ttcase_add_unchecked_fixture(tc, sys_isdir_setup, sys_isdir_teardown);\n\ttcase_add_test(tc, sys_isdir_01);\n\ttcase_add_test(tc, sys_isdir_02);\n\ttcase_add_test(tc, sys_isdir_03);\n\ttcase_add_test(tc, sys_isdir_04);\n\ttcase_add_test(tc, sys_isdir_05);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_mkpath\");\n\ttcase_add_unchecked_fixture(tc, sys_mkpath_setup, sys_mkpath_teardown);\n\ttcase_add_test(tc, sys_mkpath_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_realdir\");\n\ttcase_add_test(tc, sys_realdir_01);\n\ttcase_add_test(tc, sys_realdir_02);\n\ttcase_add_test(tc, sys_realdir_03);\n\ttcase_add_test(tc, sys_realdir_04);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_dir_eachfile\");\n\ttcase_add_test(tc, sys_dir_eachfile_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_get_cpu_cores\");\n\ttcase_add_test(tc, sys_get_cpu_cores_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"pthread_create\");\n\ttcase_add_test(tc, pthread_create_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_user_str\");\n\ttcase_add_test(tc, sys_user_str_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_group_str\");\n\ttcase_add_test(tc, sys_group_str_01);\n\tsuite_add_tcase(s, tc);\n\n\ttc = tcase_create(\"sys_ip46str_sanitize\");\n\ttcase_add_test(tc, sys_ip46str_sanitize_01);\n\ttcase_add_test(tc, sys_ip46str_sanitize_02);\n\ttcase_add_test(tc, sys_ip46str_sanitize_03);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "thrqueue.c",
          "type": "blob",
          "size": 5.9775390625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"thrqueue.h\"\n\n#include <stdlib.h>\n#include <string.h>\n#include <pthread.h>\n\n/*\n * Thread-safe, bounded-size queue based on pthreads mutex and conds.\n * Both enqueue and dequeue are available in a blocking and non-blocking\n * version.\n */\n\nstruct thrqueue {\n\tvoid **data;\n\tsize_t sz, n;\n\tsize_t in, out;\n\tunsigned int block_enqueue : 1;\n\tunsigned int block_dequeue : 1;\n\tpthread_mutex_t mutex;\n\tpthread_cond_t notempty;\n\tpthread_cond_t notfull;\n};\n\n/*\n * Create a new thread-safe queue of size sz.\n */\nthrqueue_t *\nthrqueue_new(size_t sz)\n{\n\tthrqueue_t *queue;\n\n\tif (!(queue = malloc(sizeof(thrqueue_t))))\n\t\tgoto out0;\n\tif (!(queue->data = malloc(sz * sizeof(void*))))\n\t\tgoto out1;\n\tif (pthread_mutex_init(&queue->mutex, NULL))\n\t\tgoto out2;\n\tif (pthread_cond_init(&queue->notempty, NULL))\n\t\tgoto out3;\n\tif (pthread_cond_init(&queue->notfull, NULL))\n\t\tgoto out4;\n\tqueue->sz = sz;\n\tqueue->n = 0;\n\tqueue->in = 0;\n\tqueue->out = 0;\n\tqueue->block_enqueue = 1;\n\tqueue->block_dequeue = 1;\n\treturn queue;\n\nout4:\n\tpthread_cond_destroy(&queue->notempty);\nout3:\n\tpthread_mutex_destroy(&queue->mutex);\nout2:\n\tfree(queue->data);\nout1:\n\tfree(queue);\nout0:\n\treturn NULL;\n}\n\n/*\n * Free all resources associated with queue.\n * The caller must ensure that there are no threads still\n * using the queue when it is free'd.\n */\nvoid\nthrqueue_free(thrqueue_t *queue)\n{\n\tfree(queue->data);\n\tpthread_mutex_destroy(&queue->mutex);\n\tpthread_cond_destroy(&queue->notempty);\n\tpthread_cond_destroy(&queue->notfull);\n\tfree(queue);\n}\n\n/*\n * Enqueue an item into the queue.  Will block if the queue is full.\n * If enqueue has been switched to non-blocking mode, never blocks\n * but instead returns NULL if queue is full.\n * Returns enqueued item on success.\n */\nvoid *\nthrqueue_enqueue(thrqueue_t *queue, void *item)\n{\n\tpthread_mutex_lock(&queue->mutex);\n\twhile (queue->n == queue->sz) {\n\t\tif (!queue->block_enqueue) {\n\t\t\tpthread_mutex_unlock(&queue->mutex);\n\t\t\treturn NULL;\n\t\t}\n\t\tpthread_cond_wait(&queue->notfull, &queue->mutex);\n\t}\n\tqueue->data[queue->in++] = item;\n\tqueue->in %= queue->sz;\n\tqueue->n++;\n\tpthread_mutex_unlock(&queue->mutex);\n\tpthread_cond_broadcast(&queue->notempty);\n\treturn item;\n}\n\n/*\n * Non-blocking enqueue.  Never blocks.\n * Returns NULL if the queue is full.\n * Returns the enqueued item on success.\n */\nvoid *\nthrqueue_enqueue_nb(thrqueue_t *queue, void *item)\n{\n\tpthread_mutex_lock(&queue->mutex);\n\tif (queue->n == queue->sz) {\n\t\tpthread_mutex_unlock(&queue->mutex);\n\t\treturn NULL;\n\t}\n\tqueue->data[queue->in++] = item;\n\tqueue->in %= queue->sz;\n\tqueue->n++;\n\tpthread_mutex_unlock(&queue->mutex);\n\tpthread_cond_signal(&queue->notempty);\n\treturn item;\n}\n\n/*\n * Dequeue an item from the queue.  Will block if the queue is empty.\n * If dequeue has been switched to non-blocking mode, never blocks\n * but instead returns NULL if queue is empty.\n * Returns dequeued item on success.\n */\nvoid *\nthrqueue_dequeue(thrqueue_t *queue)\n{\n\tvoid *item;\n\n\tpthread_mutex_lock(&queue->mutex);\n\twhile (queue->n == 0) {\n\t\tif (!queue->block_dequeue) {\n\t\t\tpthread_mutex_unlock(&queue->mutex);\n\t\t\treturn NULL;\n\t\t}\n\t\tpthread_cond_wait(&queue->notempty, &queue->mutex);\n\t}\n\titem = queue->data[queue->out++];\n\tqueue->out %= queue->sz;\n\tqueue->n--;\n\tpthread_mutex_unlock(&queue->mutex);\n\tpthread_cond_signal(&queue->notfull);\n\treturn item;\n}\n\n/*\n * Non-blocking dequeue.  Never blocks.\n * Returns NULL if the queue is empty.\n * Returns the dequeued item on success.\n */\nvoid *\nthrqueue_dequeue_nb(thrqueue_t *queue)\n{\n\tvoid *item;\n\n\tpthread_mutex_lock(&queue->mutex);\n\tif (queue->n == 0) {\n\t\tpthread_mutex_unlock(&queue->mutex);\n\t\treturn NULL;\n\t}\n\titem = queue->data[queue->out++];\n\tqueue->out %= queue->sz;\n\tqueue->n--;\n\tpthread_mutex_unlock(&queue->mutex);\n\tpthread_cond_signal(&queue->notfull);\n\treturn item;\n}\n\n/*\n * Permanently make all enqueue operations on queue non-blocking and wake\n * up all threads currently waiting for the queue to become not full.\n * This is to allow threads to finish their work on the queue on application\n * shutdown, but not be blocked forever.\n */\nvoid\nthrqueue_unblock_enqueue(thrqueue_t *queue)\n{\n\tqueue->block_enqueue = 0;\n\tpthread_cond_broadcast(&queue->notfull);\n\tsched_yield();\n}\n\n/*\n * Permanently make all dequeue operations on queue non-blocking and wake\n * up all threads currently waiting for the queue to become not empty.\n * This is to allow threads to finish their work on the queue on application\n * shutdown, but not be blocked forever.\n */\nvoid\nthrqueue_unblock_dequeue(thrqueue_t *queue)\n{\n\tqueue->block_dequeue = 0;\n\tpthread_cond_broadcast(&queue->notempty);\n\tsched_yield();\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "thrqueue.h",
          "type": "blob",
          "size": 2.056640625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef THRQUEUE_H\n#define THRQUEUE_H\n\n#include \"attrib.h\"\n\n#include <unistd.h>\n\ntypedef struct thrqueue thrqueue_t;\n\nthrqueue_t * thrqueue_new(size_t) MALLOC;\nvoid thrqueue_free(thrqueue_t *) NONNULL(1);\n\nvoid * thrqueue_enqueue(thrqueue_t *, void *) NONNULL(1) WUNRES;\nvoid * thrqueue_enqueue_nb(thrqueue_t *, void *) NONNULL(1) WUNRES;\nvoid * thrqueue_dequeue(thrqueue_t *) NONNULL(1) WUNRES;\nvoid * thrqueue_dequeue_nb(thrqueue_t *) NONNULL(1) WUNRES;\nvoid thrqueue_unblock_enqueue(thrqueue_t *) NONNULL(1);\nvoid thrqueue_unblock_dequeue(thrqueue_t *) NONNULL(1);\n\n#endif /* !THRQUEUE_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "url.c",
          "type": "blob",
          "size": 4.16796875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * URL encoding functions.\n */\n\n/*\n * URL decode insz bytes from in.\n * Returns allocated buffer containing outsz bytes plus a '\\0' terminator.\n * If in does not contain valid URL encoded data, returns NULL.\n */\nchar *\nurl_dec(const char *in, size_t insz, size_t *outsz)\n{\n\tstatic const int hex2dec[] = {\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*   0 ..   7 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*   8 ..  15 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  16 ..  23 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  24 ..  31 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  32 ..  39 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  40 ..  47 */\n\t\t 0,  1,  2,  3,  4,  5,  6,  7,   /*  48  .. 55 */\n\t\t 8,  9, -1, -1, -1, -1, -1, -1,   /*  56 ..  63 */\n\t\t-1, 10, 11, 12, 13, 14, 15, -1,   /*  64 ..  71 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  72 ..  79 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  80 ..  87 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /*  88 ..  95 */\n\t\t-1, 10, 11, 12, 13, 14, 15, -1,   /*  96 .. 103 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 104 .. 111 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 112 .. 119 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 120 .. 127 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 128 .. 135 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 136 .. 143 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 144 .. 151 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 152 .. 159 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 160 .. 167 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 168 .. 175 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 176 .. 183 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 184 .. 191 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 192 .. 199 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 200 .. 207 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 208 .. 215 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 216 .. 223 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 224 .. 231 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 232 .. 239 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1,   /* 240 .. 247 */\n\t\t-1, -1, -1, -1, -1, -1, -1, -1 }; /* 248 .. 255 */\n\tsize_t i, o;\n\tint hi, lo;\n\tchar *out;\n\n\tif (insz == 0) {\n\t\t*outsz = 0;\n\t\treturn strdup(\"\");\n\t}\n\n\tfor (i = 0, o = 0; i < insz; i++)\n\t\tif (in[i] == '%')\n\t\t\to++;\n\tif (2 * o > insz) {\n\t\t*outsz = 0;\n\t\treturn NULL;\n\t}\n\t*outsz = insz - (2 * o);\n\n\tif (!(out = malloc((*outsz) + 1))) {\n\t\t*outsz = 0;\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0, o = 0; i < insz; i++, o++) {\n\t\tif (in[i] != '%') {\n\t\t\tout[o] = in[i];\n\t\t\tcontinue;\n\t\t}\n\t\tif (i + 2 >= insz)\n\t\t\tgoto leave;\n\t\tif ((hi = hex2dec[(unsigned char)in[i + 1]]) == -1)\n\t\t\tgoto leave;\n\t\tif ((lo = hex2dec[(unsigned char)in[i + 2]]) == -1)\n\t\t\tgoto leave;\n\t\tout[o] = ((hi & 0xF) << 4) | (lo & 0xF);\n\t\ti += 2;\n\t}\n\tout[*outsz] = '\\0';\n\treturn out;\n\nleave:\n\tfree(out);\n\treturn NULL;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "url.h",
          "type": "blob",
          "size": 1.6328125,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef URL_H\n#define URL_H\n\n#include \"attrib.h\"\n\n#include <stdlib.h>\n\nchar * url_dec(const char *, size_t, size_t *) NONNULL(1,3) MALLOC;\n\n#endif /* !URL_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "url.t.c",
          "type": "blob",
          "size": 3.3701171875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"url.h\"\n\n#include <string.h>\n\n#include <check.h>\n\nstatic const char *plain01 = \"===1234===\";\nstatic const char *plain02 = \"\\x00\\x01\\x7F\\xFF\";\n\nstatic const char *coded01 = \"%3D%3D%3D1234%3D%3D%3D\";\nstatic const char *coded02 = \"%00%01%7F%FF\";\n\nstatic const char *coded03 = \"%\";\nstatic const char *coded04 = \"foo%zzbar\";\nstatic const char *coded05 = \"foo%a%3Dbar\";\n\nSTART_TEST(url_dec_01)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = url_dec(coded01, strlen(coded01), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain01), \"wrong length\");\n\tfail_unless(!memcmp(plain01, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(url_dec_02)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = url_dec(coded02, strlen(coded02), &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(sz == strlen(plain02 + 1) + 1, \"wrong length\");\n\tfail_unless(!memcmp(plain02, buf, sz), \"wrong data\");\n\tfree(buf);\n}\nEND_TEST\n\nSTART_TEST(url_dec_03)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = url_dec(coded03, strlen(coded03), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(url_dec_04)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = url_dec(coded04, strlen(coded04), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(url_dec_05)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = url_dec(coded05, strlen(coded05), &sz);\n\tfail_unless(!buf, \"buffer returned\");\n}\nEND_TEST\n\nSTART_TEST(url_dec_06)\n{\n\tchar *buf;\n\tsize_t sz;\n\n\tbuf = url_dec(\"\", 0, &sz);\n\tfail_unless(!!buf, \"no buffer returned\");\n\tfail_unless(!sz, \"length not 0\");\n\tfail_unless(!buf[0], \"not empty string\");\n\tfree(buf);\n}\nEND_TEST\n\n\nSuite *\nurl_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"url\");\n\n\ttc = tcase_create(\"url_dec\");\n\ttcase_add_test(tc, url_dec_01);\n\ttcase_add_test(tc, url_dec_02);\n\ttcase_add_test(tc, url_dec_03);\n\ttcase_add_test(tc, url_dec_04);\n\ttcase_add_test(tc, url_dec_05);\n\ttcase_add_test(tc, url_dec_06);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "util.c",
          "type": "blob",
          "size": 1.7373046875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <string.h>\n\n/*\n * Various utility functions.\n */\n\n/*\n * Returns a pointer to the first non-whitespace character in s.\n * Only space and tab characters are considered whitespace.\n */\nchar *\nutil_skipws(const char *s)\n{\n\treturn (char*) s + strspn(s, \" \\t\");\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "util.h",
          "type": "blob",
          "size": 1.6435546875,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef UTIL_H\n#define UTIL_H\n\n#include \"attrib.h\"\n\nchar * util_skipws(const char *) NONNULL(1) PURE;\n\n#define util_max(a,b) ((a) > (b) ? (a) : (b))\n\n#endif /* !UTIL_H */\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "util.t.c",
          "type": "blob",
          "size": 3.103515625,
          "content": "/*-\n * SSLsplit - transparent SSL/TLS interception\n * https://www.roe.ch/SSLsplit\n *\n * Copyright (c) 2009-2019, Daniel Roethlisberger <daniel@roe.ch>.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"util.h\"\n\n#include <string.h>\n\n#include <check.h>\n\nstatic const char *string01 = \"test\";\nstatic const char *string02 = \"    test\";\nstatic const char *string03 = \"\\t\\t\\t\\ttest\";\nstatic const char *string04 = \"\\t \\t test\";\nstatic const char *string05 = \"    \\r\\ntest\";\n\nSTART_TEST(util_skipws_01)\n{\n\tchar *p;\n\n\tp = util_skipws(string01);\n\tfail_unless(!!p, \"no pointer returned\");\n\tfail_unless(!strcmp(p, \"test\"), \"wrong data\");\n}\nEND_TEST\n\nSTART_TEST(util_skipws_02)\n{\n\tchar *p;\n\n\tp = util_skipws(string02);\n\tfail_unless(!!p, \"no pointer returned\");\n\tfail_unless(!strcmp(p, \"test\"), \"wrong data\");\n}\nEND_TEST\n\nSTART_TEST(util_skipws_03)\n{\n\tchar *p;\n\n\tp = util_skipws(string03);\n\tfail_unless(!!p, \"no pointer returned\");\n\tfail_unless(!strcmp(p, \"test\"), \"wrong data\");\n}\nEND_TEST\n\nSTART_TEST(util_skipws_04)\n{\n\tchar *p;\n\n\tp = util_skipws(string04);\n\tfail_unless(!!p, \"no pointer returned\");\n\tfail_unless(!strcmp(p, \"test\"), \"wrong data\");\n}\nEND_TEST\n\nSTART_TEST(util_skipws_05)\n{\n\tchar *p;\n\n\tp = util_skipws(string05);\n\tfail_unless(!!p, \"no pointer returned\");\n\tfail_unless(!strcmp(p, \"\\r\\ntest\"), \"wrong data\");\n}\nEND_TEST\n\nSTART_TEST(util_skipws_06)\n{\n\tchar *p;\n\n\tp = util_skipws(\"\");\n\tfail_unless(!!p, \"no pointer returned\");\n\tfail_unless(!strcmp(p, \"\"), \"wrong data\");\n}\nEND_TEST\n\nSuite *\nutil_suite(void)\n{\n\tSuite *s;\n\tTCase *tc;\n\n\ts = suite_create(\"util\");\n\n\ttc = tcase_create(\"util_skipws\");\n\ttcase_add_test(tc, util_skipws_01);\n\ttcase_add_test(tc, util_skipws_02);\n\ttcase_add_test(tc, util_skipws_03);\n\ttcase_add_test(tc, util_skipws_04);\n\ttcase_add_test(tc, util_skipws_05);\n\ttcase_add_test(tc, util_skipws_06);\n\tsuite_add_tcase(s, tc);\n\n\treturn s;\n}\n\n/* vim: set noet ft=c: */\n"
        },
        {
          "name": "xnu",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}