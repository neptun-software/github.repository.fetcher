{
  "metadata": {
    "timestamp": 1736709925245,
    "page": 444,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "antirez/dump1090",
      "stars": 2490,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0498046875,
          "content": "*.o\ndump1090\ntestfiles/*.bin\nmisc\nframes.js\n.*.swp\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.306640625,
          "content": "CFLAGS?=-O2 -g -Wall -W $(shell pkg-config --cflags librtlsdr)\nLDLIBS+=$(shell pkg-config --libs librtlsdr) -lpthread -lm\nCC?=gcc\nPROGNAME=dump1090\n\nall: dump1090\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $<\n\ndump1090: dump1090.o anet.o\n\t$(CC) -g -o dump1090 dump1090.o anet.o $(LDFLAGS) $(LDLIBS)\n\nclean:\n\trm -f *.o dump1090\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.6337890625,
          "content": "Dump1090 README\n===\n\nDump 1090 is a Mode S decoder specifically designed for RTLSDR devices.\n\nThe main features are:\n\n* Robust decoding of weak messages, with mode1090 many users observed\n  improved range compared to other popular decoders.\n* Network support: TCP30003 stream (MSG5...), Raw packets, HTTP.\n* Embedded HTTP server that displays the currently detected aircrafts on\n  Google Map.\n* Single bit errors correction using the 24 bit CRC.\n* Ability to decode DF11, DF17 messages.\n* Ability to decode DF formats like DF0, DF4, DF5, DF16, DF20 and DF21\n  where the checksum is xored with the ICAO address by brute forcing the\n  checksum field using recently seen ICAO addresses.\n* Decode raw IQ samples from file (using --ifile command line switch).\n* Interactive command-line-interfae mode where aircrafts currently detected\n  are shown as a list refreshing as more data arrives.\n* CPR coordinates decoding and track calculation from velocity.\n* TCP server streaming and receiving raw data to/from connected clients\n  (using --net).\n\nWhile from time to time I still add / fix stuff in my fork, I target\nminimalism of the implementation. However there is a\n[much more feature complete fork](https://github.com/MalcolmRobb/dump1090)\navailable, developed by MalcolmRobb.\n\nInstallation\n---\n\nType \"make\".\n\nNormal usage\n---\n\nTo capture traffic directly from your RTL device and show the captured traffic\non standard output, just run the program without options at all:\n\n    ./dump1090\n\nTo just output hexadecimal messages:\n\n    ./dump1090 --raw\n\nTo run the program in interactive mode:\n\n    ./dump1090 --interactive\n\nTo run the program in interactive mode, with networking support, and connect\nwith your browser to http://localhost:8080 to see live traffic:\n\n    ./dump1090 --interactive --net\n\nIn interactive mode it is possible to have a less information dense but more\n\"arcade style\" output, where the screen is refreshed every second displaying\nall the recently seen aircrafts with some additional information such as\naltitude and flight number, extracted from the received Mode S packets.\n\nUsing files as source of data\n---\n\nTo decode data from file, use:\n\n    ./dump1090 --ifile /path/to/binfile\n\nThe binary file should be created using `rtl_sdr` like this (or with any other\nprogram that is able to output 8-bit unsigned IQ samples at 2Mhz sample rate).\n\n    rtl_sdr -f 1090000000 -s 2000000 -g 50 output.bin\n\nIn the example `rtl_sdr` a gain of 50 is used, simply you should use the highest\ngain availabe for your tuner. This is not needed when calling Dump1090 itself\nas it is able to select the highest gain supported automatically.\n\nIt is possible to feed the program with data via standard input using\nthe --ifile option with \"-\" as argument.\n\nAdditional options\n---\n\nDump1090 can be called with other command line options to set a different\ngain, frequency, and so forth. For a list of options use:\n\n    ./dump1090 --help\n\nEverything is not documented here should be obvious, and for most users calling\nit without arguments at all is the best thing to do.\n\nReliability\n---\n\nBy default Dump1090 tries to fix single bit errors using the checksum.\nBasically the program will try to flip every bit of the message and check if\nthe checksum of the resulting message matches.\n\nThis is indeed able to fix errors and works reliably in my experience,\nhowever if you are interested in very reliable data I suggest to use\nthe --no-fix command line switch in order to disable error fixing.\n\nPerformances and sensibility of detection\n---\n\nIn my limited experience Dump1090 was able to decode a big number of messages\neven in conditions where I encountered problems using other programs, however\nno formal test was performed so I can't really claim that this program is\nbetter or worse compared to other similar programs.\n\nIf you can capture traffic that Dump1090 is not able to decode properly, drop\nme an email with a download link. I may try to improve the detection during\nmy free time (this is just an hobby project).\n\nNetwork server features\n---\n\nBy enabling the networking support with --net Dump1090 starts listening\nfor clients connections on port 30002 and 30001 (you can change both the\nports if you want, see --help output).\n\nPort 30002\n---\n\nConnected clients are served with data ASAP as they arrive from the device\n(or from file if --ifile is used) in the raw format similar to the following:\n\n    *8D451E8B99019699C00B0A81F36E;\n\nEvery entry is separated by a simple newline (LF character, hex 0x0A).\n\nPort 30001\n---\n\nPort 30001 is the raw input port, and can be used to feed Dump1090 with\ndata in the same format as specified above, with hex messages starting with\na `*` and ending with a `;` character.\n\nSo for instance if there is another remote Dump1090 instance collecting data\nit is possible to sum the output to a local Dump1090 instance doing something\nlike this:\n\n    nc remote-dump1090.example.net 30002 | nc localhost 30001\n\nIt is important to note that what is received via port 30001 is also\nbroadcasted to clients listening to port 30002.\n\nIn general everything received from port 30001 is handled exactly like the\nnormal traffic from RTL devices or from file when --ifile is used.\n\nIt is possible to use Dump1090 just as an hub using --ifile with /dev/zero\nas argument as in the following example:\n\n    ./dump1090 --net-only\n\nOr alternatively to see what's happening on the screen:\n\n    ./dump1090 --net-only --interactive\n\nThen you can feed it from different data sources from the internet.\n\nPort 30003\n---\n\nConnected clients are served with messages in SBS1 (BaseStation) format,\nsimilar to:\n\n    MSG,4,,,738065,,,,,,,,420,179,,,0,,0,0,0,0\n    MSG,3,,,738065,,,,,,,35000,,,34.81609,34.07810,,,0,0,0,0\n\nThis can be used to feed data to various sharing sites without the need to use another decoder.\n\nAntenna\n---\n\nMode S messages are transmitted in the 1090 Mhz frequency. If you have a decent\nantenna you'll be able to pick up signals from aircrafts pretty far from your\nposition, especially if you are outdoor and in a position with a good sky view.\n\nYou can easily build a very cheap antenna following the istructions at:\n\n    http://antirez.com/news/46\n\nWith this trivial antenna I was able to pick up signals of aircrafts 200+ Km\naway from me.\n\nIf you are interested in a more serious antenna check the following\nresources:\n\n* http://gnuradio.org/data/grcon11/06-foster-adsb.pdf\n* http://www.lll.lu/~edward/edward/adsb/antenna/ADSBantenna.html\n* http://modesbeast.com/pix/adsb-ant-drawing.gif\n\nAggressive mode\n---\n\nWith --aggressive it is possible to activate the *aggressive mode* that is a\nmodified version of the Mode S packet detection and decoding.\nTHe aggresive mode uses more CPU usually (especially if there are many planes\nsending DF17 packets), but can detect a few more messages.\n\nThe algorithm in aggressive mode is modified in the following ways:\n\n* Up to two demodulation errors are tolerated (adjacent entires in the magnitude\n  vector with the same eight). Normally only messages without errors are\n  checked.\n* It tries to fix DF17 messages trying every two bits combination.\n\nThe use of aggressive mdoe is only advised in places where there is low traffic\nin order to have a chance to capture some more messages.\n\nDebug mode\n---\n\nThe Debug mode is a visual help to improve the detection algorithm or to\nunderstand why the program is not working for a given input.\n\nIn this mode messages are displayed in an ASCII-art style graphical\nrepresentation, where the individial magnitude bars sampled at 2Mhz are\ndisplayed.\n\nAn index shows the sample number, where 0 is the sample where the first\nMode S peak was found. Some additional background noise is also added\nbefore the first peak to provide some context.\n\nTo enable debug mode and check what combinations of packets you can\nlog, use `mode1090 --help` to obtain a list of available debug flags.\n\nDebug mode includes an optional javascript output that is used to visualize\npackets using a web browser, you can use the file debug.html under the\n'tools' directory to load the generated frames.js file.\n\nHow this program works?\n---\n\nThe code is very documented and written in order to be easy to understand.\nFor the diligent programmer with a Mode S specification on his hands it\nshould be trivial to understand how it works.\n\nThe algorithms I used were obtained basically looking at many messages\nas displayed using a trow-away SDL program, and trying to model the algorithm\nbased on how the messages look graphically.\n\nHow to test the program?\n---\n\nIf you have an RTLSDR device and you happen to be in an area where there\nare aircrafts flying over your head, just run the program and check for signals.\n\nHowever if you don't have an RTLSDR device, or if in your area the presence\nof aircrafts is very limited, you may want to try the sample file distributed\nwith the Dump1090 distribution under the \"testfiles\" directory.\n\nJust run it like this:\n\n    ./dump1090 --ifile testfiles/modes1.bin\n\nWhat is --strip mode?\n---\n\nIt is just a simple filter that will get raw IQ 8 bit samples in input\nand will output a file missing all the parts of the file where I and Q\nare lower than the specified <level> for more than 32 samples.\n\nUse it like this:\n\n    cat big.bin | ./dump1090 --snip 25 > small.bin\n\nI used it in order to create a small test file to include inside this\nprogram source code distribution.\n\nContributing\n---\n\nDump1090 was written during some free time during xmas 2012, it is an hobby\nproject so I'll be able to address issues and improve it only during\nfree time, however you are incouraged to send pull requests in order to\nimprove the program. A good starting point can be the TODO list included in\nthe source distribution.\n\nCredits\n---\n\nDump1090 was written by Salvatore Sanfilippo <antirez@gmail.com> and is\nreleased under the BSD three clause license.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.1572265625,
          "content": "TODO\n\n* Extract more information from captured Mode S messages.\n* Improve the web interface gmap.html.\n* Enhance the algorithm to reliably decode more messages.\n"
        },
        {
          "name": "anet.c",
          "type": "blob",
          "size": 10.6767578125,
          "content": "/* anet.c -- Basic TCP socket stuff made a bit less boring\n *\n * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <string.h>\n#include <netdb.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"anet.h\"\n\nstatic void anetSetError(char *err, const char *fmt, ...)\n{\n    va_list ap;\n\n    if (!err) return;\n    va_start(ap, fmt);\n    vsnprintf(err, ANET_ERR_LEN, fmt, ap);\n    va_end(ap);\n}\n\nint anetNonBlock(char *err, int fd)\n{\n    int flags;\n\n    /* Set the socket nonblocking.\n     * Note that fcntl(2) for F_GETFL and F_SETFL can't be\n     * interrupted by a signal. */\n    if ((flags = fcntl(fd, F_GETFL)) == -1) {\n        anetSetError(err, \"fcntl(F_GETFL): %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n        anetSetError(err, \"fcntl(F_SETFL,O_NONBLOCK): %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetTcpNoDelay(char *err, int fd)\n{\n    int yes = 1;\n    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &yes, sizeof(yes)) == -1)\n    {\n        anetSetError(err, \"setsockopt TCP_NODELAY: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetSetSendBuffer(char *err, int fd, int buffsize)\n{\n    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &buffsize, sizeof(buffsize)) == -1)\n    {\n        anetSetError(err, \"setsockopt SO_SNDBUF: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetTcpKeepAlive(char *err, int fd)\n{\n    int yes = 1;\n    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)) == -1) {\n        anetSetError(err, \"setsockopt SO_KEEPALIVE: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetResolve(char *err, char *host, char *ipbuf)\n{\n    struct sockaddr_in sa;\n\n    sa.sin_family = AF_INET;\n    if (inet_aton(host, &sa.sin_addr) == 0) {\n        struct hostent *he;\n\n        he = gethostbyname(host);\n        if (he == NULL) {\n            anetSetError(err, \"can't resolve: %s\", host);\n            return ANET_ERR;\n        }\n        memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));\n    }\n    strcpy(ipbuf,inet_ntoa(sa.sin_addr));\n    return ANET_OK;\n}\n\nstatic int anetCreateSocket(char *err, int domain) {\n    int s, on = 1;\n    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {\n        anetSetError(err, \"creating socket: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    /* Make sure connection-intensive things like the redis benckmark\n     * will be able to close/open sockets a zillion of times */\n    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {\n        anetSetError(err, \"setsockopt SO_REUSEADDR: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n    return s;\n}\n\n#define ANET_CONNECT_NONE 0\n#define ANET_CONNECT_NONBLOCK 1\nstatic int anetTcpGenericConnect(char *err, char *addr, int port, int flags)\n{\n    int s;\n    struct sockaddr_in sa;\n\n    if ((s = anetCreateSocket(err,AF_INET)) == ANET_ERR)\n        return ANET_ERR;\n\n    sa.sin_family = AF_INET;\n    sa.sin_port = htons(port);\n    if (inet_aton(addr, &sa.sin_addr) == 0) {\n        struct hostent *he;\n\n        he = gethostbyname(addr);\n        if (he == NULL) {\n            anetSetError(err, \"can't resolve: %s\", addr);\n            close(s);\n            return ANET_ERR;\n        }\n        memcpy(&sa.sin_addr, he->h_addr, sizeof(struct in_addr));\n    }\n    if (flags & ANET_CONNECT_NONBLOCK) {\n        if (anetNonBlock(err,s) != ANET_OK)\n            return ANET_ERR;\n    }\n    if (connect(s, (struct sockaddr*)&sa, sizeof(sa)) == -1) {\n        if (errno == EINPROGRESS &&\n            flags & ANET_CONNECT_NONBLOCK)\n            return s;\n\n        anetSetError(err, \"connect: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return s;\n}\n\nint anetTcpConnect(char *err, char *addr, int port)\n{\n    return anetTcpGenericConnect(err,addr,port,ANET_CONNECT_NONE);\n}\n\nint anetTcpNonBlockConnect(char *err, char *addr, int port)\n{\n    return anetTcpGenericConnect(err,addr,port,ANET_CONNECT_NONBLOCK);\n}\n\nint anetUnixGenericConnect(char *err, char *path, int flags)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    sa.sun_family = AF_LOCAL;\n    strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);\n    if (flags & ANET_CONNECT_NONBLOCK) {\n        if (anetNonBlock(err,s) != ANET_OK)\n            return ANET_ERR;\n    }\n    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {\n        if (errno == EINPROGRESS &&\n            flags & ANET_CONNECT_NONBLOCK)\n            return s;\n\n        anetSetError(err, \"connect: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return s;\n}\n\nint anetUnixConnect(char *err, char *path)\n{\n    return anetUnixGenericConnect(err,path,ANET_CONNECT_NONE);\n}\n\nint anetUnixNonBlockConnect(char *err, char *path)\n{\n    return anetUnixGenericConnect(err,path,ANET_CONNECT_NONBLOCK);\n}\n\n/* Like read(2) but make sure 'count' is read before to return\n * (unless error or EOF condition is encountered) */\nint anetRead(int fd, char *buf, int count)\n{\n    int nread, totlen = 0;\n    while(totlen != count) {\n        nread = read(fd,buf,count-totlen);\n        if (nread == 0) return totlen;\n        if (nread == -1) return -1;\n        totlen += nread;\n        buf += nread;\n    }\n    return totlen;\n}\n\n/* Like write(2) but make sure 'count' is read before to return\n * (unless error is encountered) */\nint anetWrite(int fd, char *buf, int count)\n{\n    int nwritten, totlen = 0;\n    while(totlen != count) {\n        nwritten = write(fd,buf,count-totlen);\n        if (nwritten == 0) return totlen;\n        if (nwritten == -1) return -1;\n        totlen += nwritten;\n        buf += nwritten;\n    }\n    return totlen;\n}\n\nstatic int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n\n    /* Use a backlog of 512 entries. We pass 511 to the listen() call because\n     * the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n     * which will thus give us a backlog of 512 entries */\n    if (listen(s, 511) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}\n\nint anetTcpServer(char *err, int port, char *bindaddr)\n{\n    int s;\n    struct sockaddr_in sa;\n\n    if ((s = anetCreateSocket(err,AF_INET)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sin_family = AF_INET;\n    sa.sin_port = htons(port);\n    sa.sin_addr.s_addr = htonl(INADDR_ANY);\n    if (bindaddr && inet_aton(bindaddr, &sa.sin_addr) == 0) {\n        anetSetError(err, \"invalid bind address\");\n        close(s);\n        return ANET_ERR;\n    }\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa)) == ANET_ERR)\n        return ANET_ERR;\n    return s;\n}\n\nint anetUnixServer(char *err, char *path, mode_t perm)\n{\n    int s;\n    struct sockaddr_un sa;\n\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    strncpy(sa.sun_path,path,sizeof(sa.sun_path)-1);\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa)) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}\n\nstatic int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {\n    int fd;\n    while(1) {\n        fd = accept(s,sa,len);\n        if (fd == -1) {\n            if (errno == EINTR)\n                continue;\n            else {\n                anetSetError(err, \"accept: %s\", strerror(errno));\n                return ANET_ERR;\n            }\n        }\n        break;\n    }\n    return fd;\n}\n\nint anetTcpAccept(char *err, int s, char *ip, int *port) {\n    int fd;\n    struct sockaddr_in sa;\n    socklen_t salen = sizeof(sa);\n    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)\n        return ANET_ERR;\n\n    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));\n    if (port) *port = ntohs(sa.sin_port);\n    return fd;\n}\n\nint anetUnixAccept(char *err, int s) {\n    int fd;\n    struct sockaddr_un sa;\n    socklen_t salen = sizeof(sa);\n    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)\n        return ANET_ERR;\n\n    return fd;\n}\n\nint anetPeerToString(int fd, char *ip, int *port) {\n    struct sockaddr_in sa;\n    socklen_t salen = sizeof(sa);\n\n    if (getpeername(fd,(struct sockaddr*)&sa,&salen) == -1) {\n        *port = 0;\n        ip[0] = '?';\n        ip[1] = '\\0';\n        return -1;\n    }\n    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));\n    if (port) *port = ntohs(sa.sin_port);\n    return 0;\n}\n\nint anetSockName(int fd, char *ip, int *port) {\n    struct sockaddr_in sa;\n    socklen_t salen = sizeof(sa);\n\n    if (getsockname(fd,(struct sockaddr*)&sa,&salen) == -1) {\n        *port = 0;\n        ip[0] = '?';\n        ip[1] = '\\0';\n        return -1;\n    }\n    if (ip) strcpy(ip,inet_ntoa(sa.sin_addr));\n    if (port) *port = ntohs(sa.sin_port);\n    return 0;\n}\n"
        },
        {
          "name": "anet.h",
          "type": "blob",
          "size": 2.5654296875,
          "content": "/* anet.c -- Basic TCP socket stuff made a bit less boring\n *\n * Copyright (c) 2006-2012, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef ANET_H\n#define ANET_H\n\n#define ANET_OK 0\n#define ANET_ERR -1\n#define ANET_ERR_LEN 256\n\n#if defined(__sun)\n#define AF_LOCAL AF_UNIX\n#endif\n\nint anetTcpConnect(char *err, char *addr, int port);\nint anetTcpNonBlockConnect(char *err, char *addr, int port);\nint anetUnixConnect(char *err, char *path);\nint anetUnixNonBlockConnect(char *err, char *path);\nint anetRead(int fd, char *buf, int count);\nint anetResolve(char *err, char *host, char *ipbuf);\nint anetTcpServer(char *err, int port, char *bindaddr);\nint anetUnixServer(char *err, char *path, mode_t perm);\nint anetTcpAccept(char *err, int serversock, char *ip, int *port);\nint anetUnixAccept(char *err, int serversock);\nint anetWrite(int fd, char *buf, int count);\nint anetNonBlock(char *err, int fd);\nint anetTcpNoDelay(char *err, int fd);\nint anetTcpKeepAlive(char *err, int fd);\nint anetPeerToString(int fd, char *ip, int *port);\nint anetSetSendBuffer(char *err, int fd, int buffsize);\n\n#endif\n"
        },
        {
          "name": "dump1090.c",
          "type": "blob",
          "size": 97.373046875,
          "content": "/* Mode1090, a Mode S messages decoder for RTLSDR devices.\n *\n * Copyright (C) 2012 by Salvatore Sanfilippo <antirez@gmail.com>\n *\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n * \n *  *  Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *\n *  *  Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <stdint.h>\n#include <errno.h>\n#include <unistd.h>\n#include <math.h>\n#include <sys/time.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <sys/select.h>\n#include \"rtl-sdr.h\"\n#include \"anet.h\"\n\n#define MODES_DEFAULT_RATE         2000000\n#define MODES_DEFAULT_FREQ         1090000000\n#define MODES_DEFAULT_WIDTH        1000\n#define MODES_DEFAULT_HEIGHT       700\n#define MODES_ASYNC_BUF_NUMBER     12\n#define MODES_DATA_LEN             (16*16384)   /* 256k */\n#define MODES_AUTO_GAIN            -100         /* Use automatic gain. */\n#define MODES_MAX_GAIN             999999       /* Use max available gain. */\n\n#define MODES_PREAMBLE_US 8       /* microseconds */\n#define MODES_LONG_MSG_BITS 112\n#define MODES_SHORT_MSG_BITS 56\n#define MODES_FULL_LEN (MODES_PREAMBLE_US+MODES_LONG_MSG_BITS)\n#define MODES_LONG_MSG_BYTES (112/8)\n#define MODES_SHORT_MSG_BYTES (56/8)\n\n#define MODES_ICAO_CACHE_LEN 1024 /* Power of two required. */\n#define MODES_ICAO_CACHE_TTL 60   /* Time to live of cached addresses. */\n#define MODES_UNIT_FEET 0\n#define MODES_UNIT_METERS 1\n\n#define MODES_DEBUG_DEMOD (1<<0)\n#define MODES_DEBUG_DEMODERR (1<<1)\n#define MODES_DEBUG_BADCRC (1<<2)\n#define MODES_DEBUG_GOODCRC (1<<3)\n#define MODES_DEBUG_NOPREAMBLE (1<<4)\n#define MODES_DEBUG_NET (1<<5)\n#define MODES_DEBUG_JS (1<<6)\n\n/* When debug is set to MODES_DEBUG_NOPREAMBLE, the first sample must be\n * at least greater than a given level for us to dump the signal. */\n#define MODES_DEBUG_NOPREAMBLE_LEVEL 25\n\n#define MODES_INTERACTIVE_REFRESH_TIME 250      /* Milliseconds */\n#define MODES_INTERACTIVE_ROWS 15               /* Rows on screen */\n#define MODES_INTERACTIVE_TTL 60                /* TTL before being removed */\n\n#define MODES_NET_MAX_FD 1024\n#define MODES_NET_OUTPUT_SBS_PORT 30003\n#define MODES_NET_OUTPUT_RAW_PORT 30002\n#define MODES_NET_INPUT_RAW_PORT 30001\n#define MODES_NET_HTTP_PORT 8080\n#define MODES_CLIENT_BUF_SIZE 1024\n#define MODES_NET_SNDBUF_SIZE (1024*64)\n\n#define MODES_NOTUSED(V) ((void) V)\n\n/* Structure used to describe a networking client. */\nstruct client {\n    int fd;         /* File descriptor. */\n    int service;    /* TCP port the client is connected to. */\n    char buf[MODES_CLIENT_BUF_SIZE+1];    /* Read buffer. */\n    int buflen;                         /* Amount of data on buffer. */\n};\n\n/* Structure used to describe an aircraft in iteractive mode. */\nstruct aircraft {\n    uint32_t addr;      /* ICAO address */\n    char hexaddr[7];    /* Printable ICAO address */\n    char flight[9];     /* Flight number */\n    int altitude;       /* Altitude */\n    int speed;          /* Velocity computed from EW and NS components. */\n    int track;          /* Angle of flight. */\n    time_t seen;        /* Time at which the last packet was received. */\n    long messages;      /* Number of Mode S messages received. */\n    /* Encoded latitude and longitude as extracted by odd and even\n     * CPR encoded messages. */\n    int odd_cprlat;\n    int odd_cprlon;\n    int even_cprlat;\n    int even_cprlon;\n    double lat, lon;    /* Coordinated obtained from CPR encoded data. */\n    long long odd_cprtime, even_cprtime;\n    struct aircraft *next; /* Next aircraft in our linked list. */\n};\n\n/* Program global state. */\nstruct {\n    /* Internal state */\n    pthread_t reader_thread;\n    pthread_mutex_t data_mutex;     /* Mutex to synchronize buffer access. */\n    pthread_cond_t data_cond;       /* Conditional variable associated. */\n    unsigned char *data;            /* Raw IQ samples buffer */\n    uint16_t *magnitude;            /* Magnitude vector */\n    uint32_t data_len;              /* Buffer length. */\n    int fd;                         /* --ifile option file descriptor. */\n    int data_ready;                 /* Data ready to be processed. */\n    uint32_t *icao_cache;           /* Recently seen ICAO addresses cache. */\n    uint16_t *maglut;               /* I/Q -> Magnitude lookup table. */\n    int exit;                       /* Exit from the main loop when true. */\n\n    /* RTLSDR */\n    int dev_index;\n    int gain;\n    int enable_agc;\n    rtlsdr_dev_t *dev;\n    int freq;\n\n    /* Networking */\n    char aneterr[ANET_ERR_LEN];\n    struct client *clients[MODES_NET_MAX_FD]; /* Our clients. */\n    int maxfd;                      /* Greatest fd currently active. */\n    int sbsos;                      /* SBS output listening socket. */\n    int ros;                        /* Raw output listening socket. */\n    int ris;                        /* Raw input listening socket. */\n    int https;                      /* HTTP listening socket. */\n\n    /* Configuration */\n    char *filename;                 /* Input form file, --ifile option. */\n    int loop;                       /* Read input file again and again. */\n    int fix_errors;                 /* Single bit error correction if true. */\n    int check_crc;                  /* Only display messages with good CRC. */\n    int raw;                        /* Raw output format. */\n    int debug;                      /* Debugging mode. */\n    int net;                        /* Enable networking. */\n    int net_only;                   /* Enable just networking. */\n    int interactive;                /* Interactive mode */\n    int interactive_rows;           /* Interactive mode: max number of rows. */\n    int interactive_ttl;            /* Interactive mode: TTL before deletion. */\n    int stats;                      /* Print stats at exit in --ifile mode. */\n    int onlyaddr;                   /* Print only ICAO addresses. */\n    int metric;                     /* Use metric units. */\n    int aggressive;                 /* Aggressive detection algorithm. */\n\n    /* Interactive mode */\n    struct aircraft *aircrafts;\n    long long interactive_last_update;  /* Last screen update in milliseconds */\n\n    /* Statistics */\n    long long stat_valid_preamble;\n    long long stat_demodulated;\n    long long stat_goodcrc;\n    long long stat_badcrc;\n    long long stat_fixed;\n    long long stat_single_bit_fix;\n    long long stat_two_bits_fix;\n    long long stat_http_requests;\n    long long stat_sbs_connections;\n    long long stat_out_of_phase;\n} Modes;\n\n/* The struct we use to store information about a decoded message. */\nstruct modesMessage {\n    /* Generic fields */\n    unsigned char msg[MODES_LONG_MSG_BYTES]; /* Binary message. */\n    int msgbits;                /* Number of bits in message */\n    int msgtype;                /* Downlink format # */\n    int crcok;                  /* True if CRC was valid */\n    uint32_t crc;               /* Message CRC */\n    int errorbit;               /* Bit corrected. -1 if no bit corrected. */\n    int aa1, aa2, aa3;          /* ICAO Address bytes 1 2 and 3 */\n    int phase_corrected;        /* True if phase correction was applied. */\n\n    /* DF 11 */\n    int ca;                     /* Responder capabilities. */\n\n    /* DF 17 */\n    int metype;                 /* Extended squitter message type. */\n    int mesub;                  /* Extended squitter message subtype. */\n    int heading_is_valid;\n    int heading;\n    int aircraft_type;\n    int fflag;                  /* 1 = Odd, 0 = Even CPR message. */\n    int tflag;                  /* UTC synchronized? */\n    int raw_latitude;           /* Non decoded latitude */\n    int raw_longitude;          /* Non decoded longitude */\n    char flight[9];             /* 8 chars flight number. */\n    int ew_dir;                 /* 0 = East, 1 = West. */\n    int ew_velocity;            /* E/W velocity. */\n    int ns_dir;                 /* 0 = North, 1 = South. */\n    int ns_velocity;            /* N/S velocity. */\n    int vert_rate_source;       /* Vertical rate source. */\n    int vert_rate_sign;         /* Vertical rate sign. */\n    int vert_rate;              /* Vertical rate. */\n    int velocity;               /* Computed from EW and NS velocity. */\n\n    /* DF4, DF5, DF20, DF21 */\n    int fs;                     /* Flight status for DF4,5,20,21 */\n    int dr;                     /* Request extraction of downlink request. */\n    int um;                     /* Request extraction of downlink request. */\n    int identity;               /* 13 bits identity (Squawk). */\n\n    /* Fields used by multiple message types. */\n    int altitude, unit;\n};\n\nvoid interactiveShowData(void);\nstruct aircraft* interactiveReceiveData(struct modesMessage *mm);\nvoid modesSendRawOutput(struct modesMessage *mm);\nvoid modesSendSBSOutput(struct modesMessage *mm, struct aircraft *a);\nvoid useModesMessage(struct modesMessage *mm);\nint fixSingleBitErrors(unsigned char *msg, int bits);\nint fixTwoBitsErrors(unsigned char *msg, int bits);\nint modesMessageLenByType(int type);\nvoid sigWinchCallback();\nint getTermRows();\n\n/* ============================= Utility functions ========================== */\n\nstatic long long mstime(void) {\n    struct timeval tv;\n    long long mst;\n\n    gettimeofday(&tv, NULL);\n    mst = ((long long)tv.tv_sec)*1000;\n    mst += tv.tv_usec/1000;\n    return mst;\n}\n\n/* =============================== Initialization =========================== */\n\nvoid modesInitConfig(void) {\n    Modes.gain = MODES_MAX_GAIN;\n    Modes.dev_index = 0;\n    Modes.enable_agc = 0;\n    Modes.freq = MODES_DEFAULT_FREQ;\n    Modes.filename = NULL;\n    Modes.fix_errors = 1;\n    Modes.check_crc = 1;\n    Modes.raw = 0;\n    Modes.net = 0;\n    Modes.net_only = 0;\n    Modes.onlyaddr = 0;\n    Modes.debug = 0;\n    Modes.interactive = 0;\n    Modes.interactive_rows = MODES_INTERACTIVE_ROWS;\n    Modes.interactive_ttl = MODES_INTERACTIVE_TTL;\n    Modes.aggressive = 0;\n    Modes.interactive_rows = getTermRows();\n    Modes.loop = 0;\n}\n\nvoid modesInit(void) {\n    int i, q;\n\n    pthread_mutex_init(&Modes.data_mutex,NULL);\n    pthread_cond_init(&Modes.data_cond,NULL);\n    /* We add a full message minus a final bit to the length, so that we\n     * can carry the remaining part of the buffer that we can't process\n     * in the message detection loop, back at the start of the next data\n     * to process. This way we are able to also detect messages crossing\n     * two reads. */\n    Modes.data_len = MODES_DATA_LEN + (MODES_FULL_LEN-1)*4;\n    Modes.data_ready = 0;\n    /* Allocate the ICAO address cache. We use two uint32_t for every\n     * entry because it's a addr / timestamp pair for every entry. */\n    Modes.icao_cache = malloc(sizeof(uint32_t)*MODES_ICAO_CACHE_LEN*2);\n    memset(Modes.icao_cache,0,sizeof(uint32_t)*MODES_ICAO_CACHE_LEN*2);\n    Modes.aircrafts = NULL;\n    Modes.interactive_last_update = 0;\n    if ((Modes.data = malloc(Modes.data_len)) == NULL ||\n        (Modes.magnitude = malloc(Modes.data_len*2)) == NULL) {\n        fprintf(stderr, \"Out of memory allocating data buffer.\\n\");\n        exit(1);\n    }\n    memset(Modes.data,127,Modes.data_len);\n\n    /* Populate the I/Q -> Magnitude lookup table. It is used because\n     * sqrt or round may be expensive and performance may vary a lot\n     * depending on the libc used.\n     *\n     * Note that we don't need to fill the table for negative values, as\n     * we square both i and q to take the magnitude. So the maximum absolute\n     * value of i and q is 128, thus the maximum magnitude we get is:\n     *\n     * sqrt(128*128+128*128) = ~181.02\n     *\n     * Then, to retain the full resolution and be able to distinguish among\n     * every pair of I/Q values, we scale this range from the float range\n     * 0-181 to the uint16_t range of 0-65536 by multiplying for 360. */\n    Modes.maglut = malloc(129*129*2);\n    for (i = 0; i <= 128; i++) {\n        for (q = 0; q <= 128; q++) {\n            Modes.maglut[i*129+q] = round(sqrt(i*i+q*q)*360);\n        }\n    }\n\n    /* Statistics */\n    Modes.stat_valid_preamble = 0;\n    Modes.stat_demodulated = 0;\n    Modes.stat_goodcrc = 0;\n    Modes.stat_badcrc = 0;\n    Modes.stat_fixed = 0;\n    Modes.stat_single_bit_fix = 0;\n    Modes.stat_two_bits_fix = 0;\n    Modes.stat_http_requests = 0;\n    Modes.stat_sbs_connections = 0;\n    Modes.stat_out_of_phase = 0;\n    Modes.exit = 0;\n}\n\n/* =============================== RTLSDR handling ========================== */\n\nvoid modesInitRTLSDR(void) {\n    int j;\n    int device_count;\n    int ppm_error = 0;\n    char vendor[256], product[256], serial[256];\n\n    device_count = rtlsdr_get_device_count();\n    if (!device_count) {\n        fprintf(stderr, \"No supported RTLSDR devices found.\\n\");\n        exit(1);\n    }\n\n    fprintf(stderr, \"Found %d device(s):\\n\", device_count);\n    for (j = 0; j < device_count; j++) {\n        rtlsdr_get_device_usb_strings(j, vendor, product, serial);\n        fprintf(stderr, \"%d: %s, %s, SN: %s %s\\n\", j, vendor, product, serial,\n            (j == Modes.dev_index) ? \"(currently selected)\" : \"\");\n    }\n\n    if (rtlsdr_open(&Modes.dev, Modes.dev_index) < 0) {\n        fprintf(stderr, \"Error opening the RTLSDR device: %s\\n\",\n            strerror(errno));\n        exit(1);\n    }\n\n    /* Set gain, frequency, sample rate, and reset the device. */\n    rtlsdr_set_tuner_gain_mode(Modes.dev,\n        (Modes.gain == MODES_AUTO_GAIN) ? 0 : 1);\n    if (Modes.gain != MODES_AUTO_GAIN) {\n        if (Modes.gain == MODES_MAX_GAIN) {\n            /* Find the maximum gain available. */\n            int numgains;\n            int gains[100];\n\n            numgains = rtlsdr_get_tuner_gains(Modes.dev, gains);\n            Modes.gain = gains[numgains-1];\n            fprintf(stderr, \"Max available gain is: %.2f\\n\", Modes.gain/10.0);\n        }\n        rtlsdr_set_tuner_gain(Modes.dev, Modes.gain);\n        fprintf(stderr, \"Setting gain to: %.2f\\n\", Modes.gain/10.0);\n    } else {\n        fprintf(stderr, \"Using automatic gain control.\\n\");\n    }\n    rtlsdr_set_freq_correction(Modes.dev, ppm_error);\n    if (Modes.enable_agc) rtlsdr_set_agc_mode(Modes.dev, 1);\n    rtlsdr_set_center_freq(Modes.dev, Modes.freq);\n    rtlsdr_set_sample_rate(Modes.dev, MODES_DEFAULT_RATE);\n    rtlsdr_reset_buffer(Modes.dev);\n    fprintf(stderr, \"Gain reported by device: %.2f\\n\",\n        rtlsdr_get_tuner_gain(Modes.dev)/10.0);\n}\n\n/* We use a thread reading data in background, while the main thread\n * handles decoding and visualization of data to the user.\n *\n * The reading thread calls the RTLSDR API to read data asynchronously, and\n * uses a callback to populate the data buffer.\n * A Mutex is used to avoid races with the decoding thread. */\nvoid rtlsdrCallback(unsigned char *buf, uint32_t len, void *ctx) {\n    MODES_NOTUSED(ctx);\n\n    pthread_mutex_lock(&Modes.data_mutex);\n    if (len > MODES_DATA_LEN) len = MODES_DATA_LEN;\n    /* Move the last part of the previous buffer, that was not processed,\n     * on the start of the new buffer. */\n    memcpy(Modes.data, Modes.data+MODES_DATA_LEN, (MODES_FULL_LEN-1)*4);\n    /* Read the new data. */\n    memcpy(Modes.data+(MODES_FULL_LEN-1)*4, buf, len);\n    Modes.data_ready = 1;\n    /* Signal to the other thread that new data is ready */\n    pthread_cond_signal(&Modes.data_cond);\n    pthread_mutex_unlock(&Modes.data_mutex);\n}\n\n/* This is used when --ifile is specified in order to read data from file\n * instead of using an RTLSDR device. */\nvoid readDataFromFile(void) {\n    pthread_mutex_lock(&Modes.data_mutex);\n    while(1) {\n        ssize_t nread, toread;\n        unsigned char *p;\n\n        if (Modes.data_ready) {\n            pthread_cond_wait(&Modes.data_cond,&Modes.data_mutex);\n            continue;\n        }\n\n        if (Modes.interactive) {\n            /* When --ifile and --interactive are used together, slow down\n             * playing at the natural rate of the RTLSDR received. */\n            pthread_mutex_unlock(&Modes.data_mutex);\n            usleep(5000);\n            pthread_mutex_lock(&Modes.data_mutex);\n        }\n\n        /* Move the last part of the previous buffer, that was not processed,\n         * on the start of the new buffer. */\n        memcpy(Modes.data, Modes.data+MODES_DATA_LEN, (MODES_FULL_LEN-1)*4);\n        toread = MODES_DATA_LEN;\n        p = Modes.data+(MODES_FULL_LEN-1)*4;\n        while(toread) {\n            nread = read(Modes.fd, p, toread);\n            /* In --file mode, seek the file again from the start\n             * and re-play it if --loop was given. */\n            if (nread == 0 &&\n                Modes.filename != NULL &&\n                Modes.fd != STDIN_FILENO &&\n                Modes.loop)\n            {\n                if (lseek(Modes.fd,0,SEEK_SET) != -1) continue;\n            }\n\n            if (nread <= 0) {\n                Modes.exit = 1; /* Signal the other thread to exit. */\n                break;\n            }\n            p += nread;\n            toread -= nread;\n        }\n        if (toread) {\n            /* Not enough data on file to fill the buffer? Pad with\n             * no signal. */\n            memset(p,127,toread);\n        }\n        Modes.data_ready = 1;\n        /* Signal to the other thread that new data is ready */\n        pthread_cond_signal(&Modes.data_cond);\n    }\n}\n\n/* We read data using a thread, so the main thread only handles decoding\n * without caring about data acquisition. */\nvoid *readerThreadEntryPoint(void *arg) {\n    MODES_NOTUSED(arg);\n\n    if (Modes.filename == NULL) {\n        rtlsdr_read_async(Modes.dev, rtlsdrCallback, NULL,\n                              MODES_ASYNC_BUF_NUMBER,\n                              MODES_DATA_LEN);\n    } else {\n        readDataFromFile();\n    }\n    return NULL;\n}\n\n/* ============================== Debugging ================================= */\n\n/* Helper function for dumpMagnitudeVector().\n * It prints a single bar used to display raw signals.\n *\n * Since every magnitude sample is between 0-255, the function uses\n * up to 63 characters for every bar. Every character represents\n * a length of 4, 3, 2, 1, specifically:\n *\n * \"O\" is 4\n * \"o\" is 3\n * \"-\" is 2\n * \".\" is 1\n */\nvoid dumpMagnitudeBar(int index, int magnitude) {\n    char *set = \" .-o\";\n    char buf[256];\n    int div = magnitude / 256 / 4;\n    int rem = magnitude / 256 % 4;\n\n    memset(buf,'O',div);\n    buf[div] = set[rem];\n    buf[div+1] = '\\0';\n\n    if (index >= 0) {\n        int markchar = ']';\n\n        /* preamble peaks are marked with \">\" */\n        if (index == 0 || index == 2 || index == 7 || index == 9)\n            markchar = '>';\n        /* Data peaks are marked to distinguish pairs of bits. */\n        if (index >= 16) markchar = ((index-16)/2 & 1) ? '|' : ')';\n        printf(\"[%.3d%c |%-66s %d\\n\", index, markchar, buf, magnitude);\n    } else {\n        printf(\"[%.2d] |%-66s %d\\n\", index, buf, magnitude);\n    }\n}\n\n/* Display an ASCII-art alike graphical representation of the undecoded\n * message as a magnitude signal.\n *\n * The message starts at the specified offset in the \"m\" buffer.\n * The function will display enough data to cover a short 56 bit message.\n *\n * If possible a few samples before the start of the messsage are included\n * for context. */\n\nvoid dumpMagnitudeVector(uint16_t *m, uint32_t offset) {\n    uint32_t padding = 5; /* Show a few samples before the actual start. */\n    uint32_t start = (offset < padding) ? 0 : offset-padding;\n    uint32_t end = offset + (MODES_PREAMBLE_US*2)+(MODES_SHORT_MSG_BITS*2) - 1;\n    uint32_t j;\n\n    for (j = start; j <= end; j++) {\n        dumpMagnitudeBar(j-offset, m[j]);\n    }\n}\n\n/* Produce a raw representation of the message as a Javascript file\n * loadable by debug.html. */\nvoid dumpRawMessageJS(char *descr, unsigned char *msg,\n                      uint16_t *m, uint32_t offset, int fixable)\n{\n    int padding = 5; /* Show a few samples before the actual start. */\n    int start = offset - padding;\n    int end = offset + (MODES_PREAMBLE_US*2)+(MODES_LONG_MSG_BITS*2) - 1;\n    FILE *fp;\n    int j, fix1 = -1, fix2 = -1;\n\n    if (fixable != -1) {\n        fix1 = fixable & 0xff;\n        if (fixable > 255) fix2 = fixable >> 8;\n    }\n\n    if ((fp = fopen(\"frames.js\",\"a\")) == NULL) {\n        fprintf(stderr, \"Error opening frames.js: %s\\n\", strerror(errno));\n        exit(1);\n    }\n\n    fprintf(fp,\"frames.push({\\\"descr\\\": \\\"%s\\\", \\\"mag\\\": [\", descr);\n    for (j = start; j <= end; j++) {\n        fprintf(fp,\"%d\", j < 0 ? 0 : m[j]);\n        if (j != end) fprintf(fp,\",\");\n    }\n    fprintf(fp,\"], \\\"fix1\\\": %d, \\\"fix2\\\": %d, \\\"bits\\\": %d, \\\"hex\\\": \\\"\",\n        fix1, fix2, modesMessageLenByType(msg[0]>>3));\n    for (j = 0; j < MODES_LONG_MSG_BYTES; j++)\n        fprintf(fp,\"\\\\x%02x\",msg[j]);\n    fprintf(fp,\"\\\"});\\n\");\n    fclose(fp);\n}\n\n/* This is a wrapper for dumpMagnitudeVector() that also show the message\n * in hex format with an additional description.\n *\n * descr  is the additional message to show to describe the dump.\n * msg    points to the decoded message\n * m      is the original magnitude vector\n * offset is the offset where the message starts\n *\n * The function also produces the Javascript file used by debug.html to\n * display packets in a graphical format if the Javascript output was\n * enabled.\n */\nvoid dumpRawMessage(char *descr, unsigned char *msg,\n                    uint16_t *m, uint32_t offset)\n{\n    int j;\n    int msgtype = msg[0]>>3;\n    int fixable = -1;\n\n    if (msgtype == 11 || msgtype == 17) {\n        int msgbits = (msgtype == 11) ? MODES_SHORT_MSG_BITS :\n                                        MODES_LONG_MSG_BITS;\n        fixable = fixSingleBitErrors(msg,msgbits);\n        if (fixable == -1)\n            fixable = fixTwoBitsErrors(msg,msgbits);\n    }\n\n    if (Modes.debug & MODES_DEBUG_JS) {\n        dumpRawMessageJS(descr, msg, m, offset, fixable);\n        return;\n    }\n\n    printf(\"\\n--- %s\\n    \", descr);\n    for (j = 0; j < MODES_LONG_MSG_BYTES; j++) {\n        printf(\"%02x\",msg[j]);\n        if (j == MODES_SHORT_MSG_BYTES-1) printf(\" ... \");\n    }\n    printf(\" (DF %d, Fixable: %d)\\n\", msgtype, fixable);\n    dumpMagnitudeVector(m,offset);\n    printf(\"---\\n\\n\");\n}\n\n/* ===================== Mode S detection and decoding  ===================== */\n\n/* Parity table for MODE S Messages.\n * The table contains 112 elements, every element corresponds to a bit set\n * in the message, starting from the first bit of actual data after the\n * preamble.\n *\n * For messages of 112 bit, the whole table is used.\n * For messages of 56 bits only the last 56 elements are used.\n *\n * The algorithm is as simple as xoring all the elements in this table\n * for which the corresponding bit on the message is set to 1.\n *\n * The latest 24 elements in this table are set to 0 as the checksum at the\n * end of the message should not affect the computation.\n *\n * Note: this function can be used with DF11 and DF17, other modes have\n * the CRC xored with the sender address as they are reply to interrogations,\n * but a casual listener can't split the address from the checksum.\n */\nuint32_t modes_checksum_table[112] = {\n0x3935ea, 0x1c9af5, 0xf1b77e, 0x78dbbf, 0xc397db, 0x9e31e9, 0xb0e2f0, 0x587178,\n0x2c38bc, 0x161c5e, 0x0b0e2f, 0xfa7d13, 0x82c48d, 0xbe9842, 0x5f4c21, 0xd05c14,\n0x682e0a, 0x341705, 0xe5f186, 0x72f8c3, 0xc68665, 0x9cb936, 0x4e5c9b, 0xd8d449,\n0x939020, 0x49c810, 0x24e408, 0x127204, 0x093902, 0x049c81, 0xfdb444, 0x7eda22,\n0x3f6d11, 0xe04c8c, 0x702646, 0x381323, 0xe3f395, 0x8e03ce, 0x4701e7, 0xdc7af7,\n0x91c77f, 0xb719bb, 0xa476d9, 0xadc168, 0x56e0b4, 0x2b705a, 0x15b82d, 0xf52612,\n0x7a9309, 0xc2b380, 0x6159c0, 0x30ace0, 0x185670, 0x0c2b38, 0x06159c, 0x030ace,\n0x018567, 0xff38b7, 0x80665f, 0xbfc92b, 0xa01e91, 0xaff54c, 0x57faa6, 0x2bfd53,\n0xea04ad, 0x8af852, 0x457c29, 0xdd4410, 0x6ea208, 0x375104, 0x1ba882, 0x0dd441,\n0xf91024, 0x7c8812, 0x3e4409, 0xe0d800, 0x706c00, 0x383600, 0x1c1b00, 0x0e0d80,\n0x0706c0, 0x038360, 0x01c1b0, 0x00e0d8, 0x00706c, 0x003836, 0x001c1b, 0xfff409,\n0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,\n0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,\n0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000\n};\n\nuint32_t modesChecksum(unsigned char *msg, int bits) {\n    uint32_t crc = 0;\n    int offset = (bits == 112) ? 0 : (112-56);\n    int j;\n\n    for(j = 0; j < bits; j++) {\n        int byte = j/8;\n        int bit = j%8;\n        int bitmask = 1 << (7-bit);\n\n        /* If bit is set, xor with corresponding table entry. */\n        if (msg[byte] & bitmask)\n            crc ^= modes_checksum_table[j+offset];\n    }\n    return crc; /* 24 bit checksum. */\n}\n\n/* Given the Downlink Format (DF) of the message, return the message length\n * in bits. */\nint modesMessageLenByType(int type) {\n    if (type == 16 || type == 17 ||\n        type == 19 || type == 20 ||\n        type == 21)\n        return MODES_LONG_MSG_BITS;\n    else\n        return MODES_SHORT_MSG_BITS;\n}\n\n/* Try to fix single bit errors using the checksum. On success modifies\n * the original buffer with the fixed version, and returns the position\n * of the error bit. Otherwise if fixing failed -1 is returned. */\nint fixSingleBitErrors(unsigned char *msg, int bits) {\n    int j;\n    unsigned char aux[MODES_LONG_MSG_BITS/8];\n\n    for (j = 0; j < bits; j++) {\n        int byte = j/8;\n        int bitmask = 1 << (7-(j%8));\n        uint32_t crc1, crc2;\n\n        memcpy(aux,msg,bits/8);\n        aux[byte] ^= bitmask; /* Flip j-th bit. */\n\n        crc1 = ((uint32_t)aux[(bits/8)-3] << 16) |\n               ((uint32_t)aux[(bits/8)-2] << 8) |\n                (uint32_t)aux[(bits/8)-1];\n        crc2 = modesChecksum(aux,bits);\n\n        if (crc1 == crc2) {\n            /* The error is fixed. Overwrite the original buffer with\n             * the corrected sequence, and returns the error bit\n             * position. */\n            memcpy(msg,aux,bits/8);\n            return j;\n        }\n    }\n    return -1;\n}\n\n/* Similar to fixSingleBitErrors() but try every possible two bit combination.\n * This is very slow and should be tried only against DF17 messages that\n * don't pass the checksum, and only in Aggressive Mode. */\nint fixTwoBitsErrors(unsigned char *msg, int bits) {\n    int j, i;\n    unsigned char aux[MODES_LONG_MSG_BITS/8];\n\n    for (j = 0; j < bits; j++) {\n        int byte1 = j/8;\n        int bitmask1 = 1 << (7-(j%8));\n\n        /* Don't check the same pairs multiple times, so i starts from j+1 */\n        for (i = j+1; i < bits; i++) {\n            int byte2 = i/8;\n            int bitmask2 = 1 << (7-(i%8));\n            uint32_t crc1, crc2;\n\n            memcpy(aux,msg,bits/8);\n\n            aux[byte1] ^= bitmask1; /* Flip j-th bit. */\n            aux[byte2] ^= bitmask2; /* Flip i-th bit. */\n\n            crc1 = ((uint32_t)aux[(bits/8)-3] << 16) |\n                   ((uint32_t)aux[(bits/8)-2] << 8) |\n                    (uint32_t)aux[(bits/8)-1];\n            crc2 = modesChecksum(aux,bits);\n\n            if (crc1 == crc2) {\n                /* The error is fixed. Overwrite the original buffer with\n                 * the corrected sequence, and returns the error bit\n                 * position. */\n                memcpy(msg,aux,bits/8);\n                /* We return the two bits as a 16 bit integer by shifting\n                 * 'i' on the left. This is possible since 'i' will always\n                 * be non-zero because i starts from j+1. */\n                return j | (i<<8);\n            }\n        }\n    }\n    return -1;\n}\n\n/* Hash the ICAO address to index our cache of MODES_ICAO_CACHE_LEN\n * elements, that is assumed to be a power of two. */\nuint32_t ICAOCacheHashAddress(uint32_t a) {\n    /* The following three rounds wil make sure that every bit affects\n     * every output bit with ~ 50% of probability. */\n    a = ((a >> 16) ^ a) * 0x45d9f3b;\n    a = ((a >> 16) ^ a) * 0x45d9f3b;\n    a = ((a >> 16) ^ a);\n    return a & (MODES_ICAO_CACHE_LEN-1);\n}\n\n/* Add the specified entry to the cache of recently seen ICAO addresses.\n * Note that we also add a timestamp so that we can make sure that the\n * entry is only valid for MODES_ICAO_CACHE_TTL seconds. */\nvoid addRecentlySeenICAOAddr(uint32_t addr) {\n    uint32_t h = ICAOCacheHashAddress(addr);\n    Modes.icao_cache[h*2] = addr;\n    Modes.icao_cache[h*2+1] = (uint32_t) time(NULL);\n}\n\n/* Returns 1 if the specified ICAO address was seen in a DF format with\n * proper checksum (not xored with address) no more than * MODES_ICAO_CACHE_TTL\n * seconds ago. Otherwise returns 0. */\nint ICAOAddressWasRecentlySeen(uint32_t addr) {\n    uint32_t h = ICAOCacheHashAddress(addr);\n    uint32_t a = Modes.icao_cache[h*2];\n    uint32_t t = Modes.icao_cache[h*2+1];\n\n    return a && a == addr && time(NULL)-t <= MODES_ICAO_CACHE_TTL;\n}\n\n/* If the message type has the checksum xored with the ICAO address, try to\n * brute force it using a list of recently seen ICAO addresses.\n *\n * Do this in a brute-force fashion by xoring the predicted CRC with\n * the address XOR checksum field in the message. This will recover the\n * address: if we found it in our cache, we can assume the message is ok.\n *\n * This function expects mm->msgtype and mm->msgbits to be correctly\n * populated by the caller.\n *\n * On success the correct ICAO address is stored in the modesMessage\n * structure in the aa3, aa2, and aa1 fiedls.\n *\n * If the function successfully recovers a message with a correct checksum\n * it returns 1. Otherwise 0 is returned. */\nint bruteForceAP(unsigned char *msg, struct modesMessage *mm) {\n    unsigned char aux[MODES_LONG_MSG_BYTES];\n    int msgtype = mm->msgtype;\n    int msgbits = mm->msgbits;\n\n    if (msgtype == 0 ||         /* Short air surveillance */\n        msgtype == 4 ||         /* Surveillance, altitude reply */\n        msgtype == 5 ||         /* Surveillance, identity reply */\n        msgtype == 16 ||        /* Long Air-Air survillance */\n        msgtype == 20 ||        /* Comm-A, altitude request */\n        msgtype == 21 ||        /* Comm-A, identity request */\n        msgtype == 24)          /* Comm-C ELM */\n    {\n        uint32_t addr;\n        uint32_t crc;\n        int lastbyte = (msgbits/8)-1;\n\n        /* Work on a copy. */\n        memcpy(aux,msg,msgbits/8);\n\n        /* Compute the CRC of the message and XOR it with the AP field\n         * so that we recover the address, because:\n         *\n         * (ADDR xor CRC) xor CRC = ADDR. */\n        crc = modesChecksum(aux,msgbits);\n        aux[lastbyte] ^= crc & 0xff;\n        aux[lastbyte-1] ^= (crc >> 8) & 0xff;\n        aux[lastbyte-2] ^= (crc >> 16) & 0xff;\n        \n        /* If the obtained address exists in our cache we consider\n         * the message valid. */\n        addr = aux[lastbyte] | (aux[lastbyte-1] << 8) | (aux[lastbyte-2] << 16);\n        if (ICAOAddressWasRecentlySeen(addr)) {\n            mm->aa1 = aux[lastbyte-2];\n            mm->aa2 = aux[lastbyte-1];\n            mm->aa3 = aux[lastbyte];\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/* Decode the 13 bit AC altitude field (in DF 20 and others).\n * Returns the altitude, and set 'unit' to either MODES_UNIT_METERS\n * or MDOES_UNIT_FEETS. */\nint decodeAC13Field(unsigned char *msg, int *unit) {\n    int m_bit = msg[3] & (1<<6);\n    int q_bit = msg[3] & (1<<4);\n\n    if (!m_bit) {\n        *unit = MODES_UNIT_FEET;\n        if (q_bit) {\n            /* N is the 11 bit integer resulting from the removal of bit\n             * Q and M */\n            int n = ((msg[2]&31)<<6) |\n                    ((msg[3]&0x80)>>2) |\n                    ((msg[3]&0x20)>>1) |\n                     (msg[3]&15);\n            /* The final altitude is due to the resulting number multiplied\n             * by 25, minus 1000. */\n            return n*25-1000;\n        } else {\n            /* TODO: Implement altitude where Q=0 and M=0 */\n        }\n    } else {\n        *unit = MODES_UNIT_METERS;\n        /* TODO: Implement altitude when meter unit is selected. */\n    }\n    return 0;\n}\n\n/* Decode the 12 bit AC altitude field (in DF 17 and others).\n * Returns the altitude or 0 if it can't be decoded. */\nint decodeAC12Field(unsigned char *msg, int *unit) {\n    int q_bit = msg[5] & 1;\n\n    if (q_bit) {\n        /* N is the 11 bit integer resulting from the removal of bit\n         * Q */\n        *unit = MODES_UNIT_FEET;\n        int n = ((msg[5]>>1)<<4) | ((msg[6]&0xF0) >> 4);\n        /* The final altitude is due to the resulting number multiplied\n         * by 25, minus 1000. */\n        return n*25-1000;\n    } else {\n        return 0;\n    }\n}\n\n/* Capability table. */\nchar *ca_str[8] = {\n    /* 0 */ \"Level 1 (Survillance Only)\",\n    /* 1 */ \"Level 2 (DF0,4,5,11)\",\n    /* 2 */ \"Level 3 (DF0,4,5,11,20,21)\",\n    /* 3 */ \"Level 4 (DF0,4,5,11,20,21,24)\",\n    /* 4 */ \"Level 2+3+4 (DF0,4,5,11,20,21,24,code7 - is on ground)\",\n    /* 5 */ \"Level 2+3+4 (DF0,4,5,11,20,21,24,code7 - is on airborne)\",\n    /* 6 */ \"Level 2+3+4 (DF0,4,5,11,20,21,24,code7)\",\n    /* 7 */ \"Level 7 ???\"\n};\n\n/* Flight status table. */\nchar *fs_str[8] = {\n    /* 0 */ \"Normal, Airborne\",\n    /* 1 */ \"Normal, On the ground\",\n    /* 2 */ \"ALERT,  Airborne\",\n    /* 3 */ \"ALERT,  On the ground\",\n    /* 4 */ \"ALERT & Special Position Identification. Airborne or Ground\",\n    /* 5 */ \"Special Position Identification. Airborne or Ground\",\n    /* 6 */ \"Value 6 is not assigned\",\n    /* 7 */ \"Value 7 is not assigned\"\n};\n\n/* ME message type to description table. */\nchar *me_str[] = {\n};\n\nchar *getMEDescription(int metype, int mesub) {\n    char *mename = \"Unknown\";\n\n    if (metype >= 1 && metype <= 4)\n        mename = \"Aircraft Identification and Category\";\n    else if (metype >= 5 && metype <= 8)\n        mename = \"Surface Position\";\n    else if (metype >= 9 && metype <= 18)\n        mename = \"Airborne Position (Baro Altitude)\";\n    else if (metype == 19 && mesub >=1 && mesub <= 4)\n        mename = \"Airborne Velocity\";\n    else if (metype >= 20 && metype <= 22)\n        mename = \"Airborne Position (GNSS Height)\";\n    else if (metype == 23 && mesub == 0)\n        mename = \"Test Message\";\n    else if (metype == 24 && mesub == 1)\n        mename = \"Surface System Status\";\n    else if (metype == 28 && mesub == 1)\n        mename = \"Extended Squitter Aircraft Status (Emergency)\";\n    else if (metype == 28 && mesub == 2)\n        mename = \"Extended Squitter Aircraft Status (1090ES TCAS RA)\";\n    else if (metype == 29 && (mesub == 0 || mesub == 1))\n        mename = \"Target State and Status Message\";\n    else if (metype == 31 && (mesub == 0 || mesub == 1))\n        mename = \"Aircraft Operational Status Message\";\n    return mename;\n}\n\n/* Decode a raw Mode S message demodulated as a stream of bytes by\n * detectModeS(), and split it into fields populating a modesMessage\n * structure. */\nvoid decodeModesMessage(struct modesMessage *mm, unsigned char *msg) {\n    uint32_t crc2;   /* Computed CRC, used to verify the message CRC. */\n    char *ais_charset = \"?ABCDEFGHIJKLMNOPQRSTUVWXYZ????? ???????????????0123456789??????\";\n\n    /* Work on our local copy */\n    memcpy(mm->msg,msg,MODES_LONG_MSG_BYTES);\n    msg = mm->msg;\n\n    /* Get the message type ASAP as other operations depend on this */\n    mm->msgtype = msg[0]>>3;    /* Downlink Format */\n    mm->msgbits = modesMessageLenByType(mm->msgtype);\n\n    /* CRC is always the last three bytes. */\n    mm->crc = ((uint32_t)msg[(mm->msgbits/8)-3] << 16) |\n              ((uint32_t)msg[(mm->msgbits/8)-2] << 8) |\n               (uint32_t)msg[(mm->msgbits/8)-1];\n    crc2 = modesChecksum(msg,mm->msgbits);\n\n    /* Check CRC and fix single bit errors using the CRC when\n     * possible (DF 11 and 17). */\n    mm->errorbit = -1;  /* No error */\n    mm->crcok = (mm->crc == crc2);\n\n    if (!mm->crcok && Modes.fix_errors &&\n        (mm->msgtype == 11 || mm->msgtype == 17))\n    {\n        if ((mm->errorbit = fixSingleBitErrors(msg,mm->msgbits)) != -1) {\n            mm->crc = modesChecksum(msg,mm->msgbits);\n            mm->crcok = 1;\n        } else if (Modes.aggressive && mm->msgtype == 17 &&\n                   (mm->errorbit = fixTwoBitsErrors(msg,mm->msgbits)) != -1)\n        {\n            mm->crc = modesChecksum(msg,mm->msgbits);\n            mm->crcok = 1;\n        }\n    }\n\n    /* Note that most of the other computation happens *after* we fix\n     * the single bit errors, otherwise we would need to recompute the\n     * fields again. */\n    mm->ca = msg[0] & 7;        /* Responder capabilities. */\n\n    /* ICAO address */\n    mm->aa1 = msg[1];\n    mm->aa2 = msg[2];\n    mm->aa3 = msg[3];\n\n    /* DF 17 type (assuming this is a DF17, otherwise not used) */\n    mm->metype = msg[4] >> 3;   /* Extended squitter message type. */\n    mm->mesub = msg[4] & 7;     /* Extended squitter message subtype. */\n\n    /* Fields for DF4,5,20,21 */\n    mm->fs = msg[0] & 7;        /* Flight status for DF4,5,20,21 */\n    mm->dr = msg[1] >> 3 & 31;  /* Request extraction of downlink request. */\n    mm->um = ((msg[1] & 7)<<3)| /* Request extraction of downlink request. */\n              msg[2]>>5;\n\n    /* In the squawk (identity) field bits are interleaved like that\n     * (message bit 20 to bit 32):\n     *\n     * C1-A1-C2-A2-C4-A4-ZERO-B1-D1-B2-D2-B4-D4\n     *\n     * So every group of three bits A, B, C, D represent an integer\n     * from 0 to 7.\n     *\n     * The actual meaning is just 4 octal numbers, but we convert it\n     * into a base ten number tha happens to represent the four\n     * octal numbers.\n     *\n     * For more info: http://en.wikipedia.org/wiki/Gillham_code */\n    {\n        int a,b,c,d;\n\n        a = ((msg[3] & 0x80) >> 5) |\n            ((msg[2] & 0x02) >> 0) |\n            ((msg[2] & 0x08) >> 3);\n        b = ((msg[3] & 0x02) << 1) |\n            ((msg[3] & 0x08) >> 2) |\n            ((msg[3] & 0x20) >> 5);\n        c = ((msg[2] & 0x01) << 2) |\n            ((msg[2] & 0x04) >> 1) |\n            ((msg[2] & 0x10) >> 4);\n        d = ((msg[3] & 0x01) << 2) |\n            ((msg[3] & 0x04) >> 1) |\n            ((msg[3] & 0x10) >> 4);\n        mm->identity = a*1000 + b*100 + c*10 + d;\n    }\n\n    /* DF 11 & 17: try to populate our ICAO addresses whitelist.\n     * DFs with an AP field (xored addr and crc), try to decode it. */\n    if (mm->msgtype != 11 && mm->msgtype != 17) {\n        /* Check if we can check the checksum for the Downlink Formats where\n         * the checksum is xored with the aircraft ICAO address. We try to\n         * brute force it using a list of recently seen aircraft addresses. */\n        if (bruteForceAP(msg,mm)) {\n            /* We recovered the message, mark the checksum as valid. */\n            mm->crcok = 1;\n        } else {\n            mm->crcok = 0;\n        }\n    } else {\n        /* If this is DF 11 or DF 17 and the checksum was ok,\n         * we can add this address to the list of recently seen\n         * addresses. */\n        if (mm->crcok && mm->errorbit == -1) {\n            uint32_t addr = (mm->aa1 << 16) | (mm->aa2 << 8) | mm->aa3;\n            addRecentlySeenICAOAddr(addr);\n        }\n    }\n\n    /* Decode 13 bit altitude for DF0, DF4, DF16, DF20 */\n    if (mm->msgtype == 0 || mm->msgtype == 4 ||\n        mm->msgtype == 16 || mm->msgtype == 20) {\n        mm->altitude = decodeAC13Field(msg, &mm->unit);\n    }\n\n    /* Decode extended squitter specific stuff. */\n    if (mm->msgtype == 17) {\n        /* Decode the extended squitter message. */\n\n        if (mm->metype >= 1 && mm->metype <= 4) {\n            /* Aircraft Identification and Category */\n            mm->aircraft_type = mm->metype-1;\n            mm->flight[0] = ais_charset[msg[5]>>2];\n            mm->flight[1] = ais_charset[((msg[5]&3)<<4)|(msg[6]>>4)];\n            mm->flight[2] = ais_charset[((msg[6]&15)<<2)|(msg[7]>>6)];\n            mm->flight[3] = ais_charset[msg[7]&63];\n            mm->flight[4] = ais_charset[msg[8]>>2];\n            mm->flight[5] = ais_charset[((msg[8]&3)<<4)|(msg[9]>>4)];\n            mm->flight[6] = ais_charset[((msg[9]&15)<<2)|(msg[10]>>6)];\n            mm->flight[7] = ais_charset[msg[10]&63];\n            mm->flight[8] = '\\0';\n        } else if (mm->metype >= 9 && mm->metype <= 18) {\n            /* Airborne position Message */\n            mm->fflag = msg[6] & (1<<2);\n            mm->tflag = msg[6] & (1<<3);\n            mm->altitude = decodeAC12Field(msg,&mm->unit);\n            mm->raw_latitude = ((msg[6] & 3) << 15) |\n                                (msg[7] << 7) |\n                                (msg[8] >> 1);\n            mm->raw_longitude = ((msg[8]&1) << 16) |\n                                 (msg[9] << 8) |\n                                 msg[10];\n        } else if (mm->metype == 19 && mm->mesub >= 1 && mm->mesub <= 4) {\n            /* Airborne Velocity Message */\n            if (mm->mesub == 1 || mm->mesub == 2) {\n                mm->ew_dir = (msg[5]&4) >> 2;\n                mm->ew_velocity = ((msg[5]&3) << 8) | msg[6];\n                mm->ns_dir = (msg[7]&0x80) >> 7;\n                mm->ns_velocity = ((msg[7]&0x7f) << 3) | ((msg[8]&0xe0) >> 5);\n                mm->vert_rate_source = (msg[8]&0x10) >> 4;\n                mm->vert_rate_sign = (msg[8]&0x8) >> 3;\n                mm->vert_rate = ((msg[8]&7) << 6) | ((msg[9]&0xfc) >> 2);\n                /* Compute velocity and angle from the two speed\n                 * components. */\n                mm->velocity = sqrt(mm->ns_velocity*mm->ns_velocity+\n                                    mm->ew_velocity*mm->ew_velocity);\n                if (mm->velocity) {\n                    int ewv = mm->ew_velocity;\n                    int nsv = mm->ns_velocity;\n                    double heading;\n\n                    if (mm->ew_dir) ewv *= -1;\n                    if (mm->ns_dir) nsv *= -1;\n                    heading = atan2(ewv,nsv);\n\n                    /* Convert to degrees. */\n                    mm->heading = heading * 360 / (M_PI*2);\n                    /* We don't want negative values but a 0-360 scale. */\n                    if (mm->heading < 0) mm->heading += 360;\n                } else {\n                    mm->heading = 0;\n                }\n            } else if (mm->mesub == 3 || mm->mesub == 4) {\n                mm->heading_is_valid = msg[5] & (1<<2);\n                mm->heading = (360.0/128) * (((msg[5] & 3) << 5) |\n                                              (msg[6] >> 3));\n            }\n        }\n    }\n    mm->phase_corrected = 0; /* Set to 1 by the caller if needed. */\n}\n\n/* This function gets a decoded Mode S Message and prints it on the screen\n * in a human readable format. */\nvoid displayModesMessage(struct modesMessage *mm) {\n    int j;\n\n    /* Handle only addresses mode first. */\n    if (Modes.onlyaddr) {\n        printf(\"%02x%02x%02x\\n\", mm->aa1, mm->aa2, mm->aa3);\n        return;\n    }\n\n    /* Show the raw message. */\n    printf(\"*\");\n    for (j = 0; j < mm->msgbits/8; j++) printf(\"%02x\", mm->msg[j]);\n    printf(\";\\n\");\n\n    if (Modes.raw) {\n        fflush(stdout); /* Provide data to the reader ASAP. */\n        return; /* Enough for --raw mode */\n    }\n\n    printf(\"CRC: %06x (%s)\\n\", (int)mm->crc, mm->crcok ? \"ok\" : \"wrong\");\n    if (mm->errorbit != -1)\n        printf(\"Single bit error fixed, bit %d\\n\", mm->errorbit);\n\n    if (mm->msgtype == 0) {\n        /* DF 0 */\n        printf(\"DF 0: Short Air-Air Surveillance.\\n\");\n        printf(\"  Altitude       : %d %s\\n\", mm->altitude,\n            (mm->unit == MODES_UNIT_METERS) ? \"meters\" : \"feet\");\n        printf(\"  ICAO Address   : %02x%02x%02x\\n\", mm->aa1, mm->aa2, mm->aa3);\n    } else if (mm->msgtype == 4 || mm->msgtype == 20) {\n        printf(\"DF %d: %s, Altitude Reply.\\n\", mm->msgtype,\n            (mm->msgtype == 4) ? \"Surveillance\" : \"Comm-B\");\n        printf(\"  Flight Status  : %s\\n\", fs_str[mm->fs]);\n        printf(\"  DR             : %d\\n\", mm->dr);\n        printf(\"  UM             : %d\\n\", mm->um);\n        printf(\"  Altitude       : %d %s\\n\", mm->altitude,\n            (mm->unit == MODES_UNIT_METERS) ? \"meters\" : \"feet\");\n        printf(\"  ICAO Address   : %02x%02x%02x\\n\", mm->aa1, mm->aa2, mm->aa3);\n\n        if (mm->msgtype == 20) {\n            /* TODO: 56 bits DF20 MB additional field. */\n        }\n    } else if (mm->msgtype == 5 || mm->msgtype == 21) {\n        printf(\"DF %d: %s, Identity Reply.\\n\", mm->msgtype,\n            (mm->msgtype == 5) ? \"Surveillance\" : \"Comm-B\");\n        printf(\"  Flight Status  : %s\\n\", fs_str[mm->fs]);\n        printf(\"  DR             : %d\\n\", mm->dr);\n        printf(\"  UM             : %d\\n\", mm->um);\n        printf(\"  Squawk         : %d\\n\", mm->identity);\n        printf(\"  ICAO Address   : %02x%02x%02x\\n\", mm->aa1, mm->aa2, mm->aa3);\n\n        if (mm->msgtype == 21) {\n            /* TODO: 56 bits DF21 MB additional field. */\n        }\n    } else if (mm->msgtype == 11) {\n        /* DF 11 */\n        printf(\"DF 11: All Call Reply.\\n\");\n        printf(\"  Capability  : %s\\n\", ca_str[mm->ca]);\n        printf(\"  ICAO Address: %02x%02x%02x\\n\", mm->aa1, mm->aa2, mm->aa3);\n    } else if (mm->msgtype == 17) {\n        /* DF 17 */\n        printf(\"DF 17: ADS-B message.\\n\");\n        printf(\"  Capability     : %d (%s)\\n\", mm->ca, ca_str[mm->ca]);\n        printf(\"  ICAO Address   : %02x%02x%02x\\n\", mm->aa1, mm->aa2, mm->aa3);\n        printf(\"  Extended Squitter  Type: %d\\n\", mm->metype);\n        printf(\"  Extended Squitter  Sub : %d\\n\", mm->mesub);\n        printf(\"  Extended Squitter  Name: %s\\n\",\n            getMEDescription(mm->metype,mm->mesub));\n\n        /* Decode the extended squitter message. */\n        if (mm->metype >= 1 && mm->metype <= 4) {\n            /* Aircraft identification. */\n            char *ac_type_str[4] = {\n                \"Aircraft Type D\",\n                \"Aircraft Type C\",\n                \"Aircraft Type B\",\n                \"Aircraft Type A\"\n            };\n\n            printf(\"    Aircraft Type  : %s\\n\", ac_type_str[mm->aircraft_type]);\n            printf(\"    Identification : %s\\n\", mm->flight);\n        } else if (mm->metype >= 9 && mm->metype <= 18) {\n            printf(\"    F flag   : %s\\n\", mm->fflag ? \"odd\" : \"even\");\n            printf(\"    T flag   : %s\\n\", mm->tflag ? \"UTC\" : \"non-UTC\");\n            printf(\"    Altitude : %d feet\\n\", mm->altitude);\n            printf(\"    Latitude : %d (not decoded)\\n\", mm->raw_latitude);\n            printf(\"    Longitude: %d (not decoded)\\n\", mm->raw_longitude);\n        } else if (mm->metype == 19 && mm->mesub >= 1 && mm->mesub <= 4) {\n            if (mm->mesub == 1 || mm->mesub == 2) {\n                /* Velocity */\n                printf(\"    EW direction      : %d\\n\", mm->ew_dir);\n                printf(\"    EW velocity       : %d\\n\", mm->ew_velocity);\n                printf(\"    NS direction      : %d\\n\", mm->ns_dir);\n                printf(\"    NS velocity       : %d\\n\", mm->ns_velocity);\n                printf(\"    Vertical rate src : %d\\n\", mm->vert_rate_source);\n                printf(\"    Vertical rate sign: %d\\n\", mm->vert_rate_sign);\n                printf(\"    Vertical rate     : %d\\n\", mm->vert_rate);\n            } else if (mm->mesub == 3 || mm->mesub == 4) {\n                printf(\"    Heading status: %d\", mm->heading_is_valid);\n                printf(\"    Heading: %d\", mm->heading);\n            }\n        } else {\n            printf(\"    Unrecognized ME type: %d subtype: %d\\n\", \n                mm->metype, mm->mesub);\n        }\n    } else {\n        if (Modes.check_crc)\n            printf(\"DF %d with good CRC received \"\n                   \"(decoding still not implemented).\\n\",\n                mm->msgtype);\n    }\n}\n\n/* Turn I/Q samples pointed by Modes.data into the magnitude vector\n * pointed by Modes.magnitude. */\nvoid computeMagnitudeVector(void) {\n    uint16_t *m = Modes.magnitude;\n    unsigned char *p = Modes.data;\n    uint32_t j;\n\n    /* Compute the magnitudo vector. It's just SQRT(I^2 + Q^2), but\n     * we rescale to the 0-255 range to exploit the full resolution. */\n    for (j = 0; j < Modes.data_len; j += 2) {\n        int i = p[j]-127;\n        int q = p[j+1]-127;\n\n        if (i < 0) i = -i;\n        if (q < 0) q = -q;\n        m[j/2] = Modes.maglut[i*129+q];\n    }\n}\n\n/* Return -1 if the message is out of fase left-side\n * Return  1 if the message is out of fase right-size\n * Return  0 if the message is not particularly out of phase.\n *\n * Note: this function will access m[-1], so the caller should make sure to\n * call it only if we are not at the start of the current buffer. */\nint detectOutOfPhase(uint16_t *m) {\n    if (m[3] > m[2]/3) return 1;\n    if (m[10] > m[9]/3) return 1;\n    if (m[6] > m[7]/3) return -1;\n    if (m[-1] > m[1]/3) return -1;\n    return 0;\n}\n\n/* This function does not really correct the phase of the message, it just\n * applies a transformation to the first sample representing a given bit:\n *\n * If the previous bit was one, we amplify it a bit.\n * If the previous bit was zero, we decrease it a bit.\n *\n * This simple transformation makes the message a bit more likely to be\n * correctly decoded for out of phase messages:\n *\n * When messages are out of phase there is more uncertainty in\n * sequences of the same bit multiple times, since 11111 will be\n * transmitted as continuously altering magnitude (high, low, high, low...)\n * \n * However because the message is out of phase some part of the high\n * is mixed in the low part, so that it is hard to distinguish if it is\n * a zero or a one.\n *\n * However when the message is out of phase passing from 0 to 1 or from\n * 1 to 0 happens in a very recognizable way, for instance in the 0 -> 1\n * transition, magnitude goes low, high, high, low, and one of of the\n * two middle samples the high will be *very* high as part of the previous\n * or next high signal will be mixed there.\n *\n * Applying our simple transformation we make more likely if the current\n * bit is a zero, to detect another zero. Symmetrically if it is a one\n * it will be more likely to detect a one because of the transformation.\n * In this way similar levels will be interpreted more likely in the\n * correct way. */\nvoid applyPhaseCorrection(uint16_t *m) {\n    int j;\n\n    m += 16; /* Skip preamble. */\n    for (j = 0; j < (MODES_LONG_MSG_BITS-1)*2; j += 2) {\n        if (m[j] > m[j+1]) {\n            /* One */\n            m[j+2] = (m[j+2] * 5) / 4;\n        } else {\n            /* Zero */\n            m[j+2] = (m[j+2] * 4) / 5;\n        }\n    }\n}\n\n/* Detect a Mode S messages inside the magnitude buffer pointed by 'm' and of\n * size 'mlen' bytes. Every detected Mode S message is convert it into a\n * stream of bits and passed to the function to display it. */\nvoid detectModeS(uint16_t *m, uint32_t mlen) {\n    unsigned char bits[MODES_LONG_MSG_BITS];\n    unsigned char msg[MODES_LONG_MSG_BITS/2];\n    uint16_t aux[MODES_LONG_MSG_BITS*2];\n    uint32_t j;\n    int use_correction = 0;\n\n    /* The Mode S preamble is made of impulses of 0.5 microseconds at\n     * the following time offsets:\n     *\n     * 0   - 0.5 usec: first impulse.\n     * 1.0 - 1.5 usec: second impulse.\n     * 3.5 - 4   usec: third impulse.\n     * 4.5 - 5   usec: last impulse.\n     * \n     * Since we are sampling at 2 Mhz every sample in our magnitude vector\n     * is 0.5 usec, so the preamble will look like this, assuming there is\n     * an impulse at offset 0 in the array:\n     *\n     * 0   -----------------\n     * 1   -\n     * 2   ------------------\n     * 3   --\n     * 4   -\n     * 5   --\n     * 6   -\n     * 7   ------------------\n     * 8   --\n     * 9   -------------------\n     */\n    for (j = 0; j < mlen - MODES_FULL_LEN*2; j++) {\n        int low, high, delta, i, errors;\n        int good_message = 0;\n\n        if (use_correction) goto good_preamble; /* We already checked it. */\n\n        /* First check of relations between the first 10 samples\n         * representing a valid preamble. We don't even investigate further\n         * if this simple test is not passed. */\n        if (!(m[j] > m[j+1] &&\n            m[j+1] < m[j+2] &&\n            m[j+2] > m[j+3] &&\n            m[j+3] < m[j] &&\n            m[j+4] < m[j] &&\n            m[j+5] < m[j] &&\n            m[j+6] < m[j] &&\n            m[j+7] > m[j+8] &&\n            m[j+8] < m[j+9] &&\n            m[j+9] > m[j+6]))\n        {\n            if (Modes.debug & MODES_DEBUG_NOPREAMBLE &&\n                m[j] > MODES_DEBUG_NOPREAMBLE_LEVEL)\n                dumpRawMessage(\"Unexpected ratio among first 10 samples\",\n                    msg, m, j);\n            continue;\n        }\n\n        /* The samples between the two spikes must be < than the average\n         * of the high spikes level. We don't test bits too near to\n         * the high levels as signals can be out of phase so part of the\n         * energy can be in the near samples. */\n        high = (m[j]+m[j+2]+m[j+7]+m[j+9])/6;\n        if (m[j+4] >= high ||\n            m[j+5] >= high)\n        {\n            if (Modes.debug & MODES_DEBUG_NOPREAMBLE &&\n                m[j] > MODES_DEBUG_NOPREAMBLE_LEVEL)\n                dumpRawMessage(\n                    \"Too high level in samples between 3 and 6\",\n                    msg, m, j);\n            continue;\n        }\n\n        /* Similarly samples in the range 11-14 must be low, as it is the\n         * space between the preamble and real data. Again we don't test\n         * bits too near to high levels, see above. */\n        if (m[j+11] >= high ||\n            m[j+12] >= high ||\n            m[j+13] >= high ||\n            m[j+14] >= high)\n        {\n            if (Modes.debug & MODES_DEBUG_NOPREAMBLE &&\n                m[j] > MODES_DEBUG_NOPREAMBLE_LEVEL)\n                dumpRawMessage(\n                    \"Too high level in samples between 10 and 15\",\n                    msg, m, j);\n            continue;\n        }\n        Modes.stat_valid_preamble++;\n\ngood_preamble:\n        /* If the previous attempt with this message failed, retry using\n         * magnitude correction. */\n        if (use_correction) {\n            memcpy(aux,m+j+MODES_PREAMBLE_US*2,sizeof(aux));\n            if (j && detectOutOfPhase(m+j)) {\n                applyPhaseCorrection(m+j);\n                Modes.stat_out_of_phase++;\n            }\n            /* TODO ... apply other kind of corrections. */\n        }\n\n        /* Decode all the next 112 bits, regardless of the actual message\n         * size. We'll check the actual message type later. */\n        errors = 0;\n        for (i = 0; i < MODES_LONG_MSG_BITS*2; i += 2) {\n            low = m[j+i+MODES_PREAMBLE_US*2];\n            high = m[j+i+MODES_PREAMBLE_US*2+1];\n            delta = low-high;\n            if (delta < 0) delta = -delta;\n\n            if (i > 0 && delta < 256) {\n                bits[i/2] = bits[i/2-1];\n            } else if (low == high) {\n                /* Checking if two adiacent samples have the same magnitude\n                 * is an effective way to detect if it's just random noise\n                 * that was detected as a valid preamble. */\n                bits[i/2] = 2; /* error */\n                if (i < MODES_SHORT_MSG_BITS*2) errors++;\n            } else if (low > high) {\n                bits[i/2] = 1;\n            } else {\n                /* (low < high) for exclusion  */\n                bits[i/2] = 0;\n            }\n        }\n\n        /* Restore the original message if we used magnitude correction. */\n        if (use_correction)\n            memcpy(m+j+MODES_PREAMBLE_US*2,aux,sizeof(aux));\n\n        /* Pack bits into bytes */\n        for (i = 0; i < MODES_LONG_MSG_BITS; i += 8) {\n            msg[i/8] =\n                bits[i]<<7 | \n                bits[i+1]<<6 | \n                bits[i+2]<<5 | \n                bits[i+3]<<4 | \n                bits[i+4]<<3 | \n                bits[i+5]<<2 | \n                bits[i+6]<<1 | \n                bits[i+7];\n        }\n\n        int msgtype = msg[0]>>3;\n        int msglen = modesMessageLenByType(msgtype)/8;\n\n        /* Last check, high and low bits are different enough in magnitude\n         * to mark this as real message and not just noise? */\n        delta = 0;\n        for (i = 0; i < msglen*8*2; i += 2) {\n            delta += abs(m[j+i+MODES_PREAMBLE_US*2]-\n                         m[j+i+MODES_PREAMBLE_US*2+1]);\n        }\n        delta /= msglen*4;\n\n        /* Filter for an average delta of three is small enough to let almost\n         * every kind of message to pass, but high enough to filter some\n         * random noise. */\n        if (delta < 10*255) {\n            use_correction = 0;\n            continue;\n        }\n\n        /* If we reached this point, and error is zero, we are very likely\n         * with a Mode S message in our hands, but it may still be broken\n         * and CRC may not be correct. This is handled by the next layer. */\n        if (errors == 0 || (Modes.aggressive && errors < 3)) {\n            struct modesMessage mm;\n\n            /* Decode the received message and update statistics */\n            decodeModesMessage(&mm,msg);\n\n            /* Update statistics. */\n            if (mm.crcok || use_correction) {\n                if (errors == 0) Modes.stat_demodulated++;\n                if (mm.errorbit == -1) {\n                    if (mm.crcok)\n                        Modes.stat_goodcrc++;\n                    else\n                        Modes.stat_badcrc++;\n                } else {\n                    Modes.stat_badcrc++;\n                    Modes.stat_fixed++;\n                    if (mm.errorbit < MODES_LONG_MSG_BITS)\n                        Modes.stat_single_bit_fix++;\n                    else\n                        Modes.stat_two_bits_fix++;\n                }\n            }\n\n            /* Output debug mode info if needed. */\n            if (use_correction == 0) {\n                if (Modes.debug & MODES_DEBUG_DEMOD)\n                    dumpRawMessage(\"Demodulated with 0 errors\", msg, m, j);\n                else if (Modes.debug & MODES_DEBUG_BADCRC &&\n                         mm.msgtype == 17 &&\n                         (!mm.crcok || mm.errorbit != -1))\n                    dumpRawMessage(\"Decoded with bad CRC\", msg, m, j);\n                else if (Modes.debug & MODES_DEBUG_GOODCRC && mm.crcok &&\n                         mm.errorbit == -1)\n                    dumpRawMessage(\"Decoded with good CRC\", msg, m, j);\n            }\n\n            /* Skip this message if we are sure it's fine. */\n            if (mm.crcok) {\n                j += (MODES_PREAMBLE_US+(msglen*8))*2;\n                good_message = 1;\n                if (use_correction)\n                    mm.phase_corrected = 1;\n            }\n\n            /* Pass data to the next layer */\n            useModesMessage(&mm);\n        } else {\n            if (Modes.debug & MODES_DEBUG_DEMODERR && use_correction) {\n                printf(\"The following message has %d demod errors\\n\", errors);\n                dumpRawMessage(\"Demodulated with errors\", msg, m, j);\n            }\n        }\n\n        /* Retry with phase correction if possible. */\n        if (!good_message && !use_correction) {\n            j--;\n            use_correction = 1;\n        } else {\n            use_correction = 0;\n        }\n    }\n}\n\n/* When a new message is available, because it was decoded from the\n * RTL device, file, or received in the TCP input port, or any other\n * way we can receive a decoded message, we call this function in order\n * to use the message.\n *\n * Basically this function passes a raw message to the upper layers for\n * further processing and visualization. */\nvoid useModesMessage(struct modesMessage *mm) {\n    if (!Modes.stats && (Modes.check_crc == 0 || mm->crcok)) {\n        /* Track aircrafts in interactive mode or if the HTTP\n         * interface is enabled. */\n        if (Modes.interactive || Modes.stat_http_requests > 0 || Modes.stat_sbs_connections > 0) {\n            struct aircraft *a = interactiveReceiveData(mm);\n            if (a && Modes.stat_sbs_connections > 0) modesSendSBSOutput(mm, a);  /* Feed SBS output clients. */\n        }\n        /* In non-interactive way, display messages on standard output. */\n        if (!Modes.interactive) {\n            displayModesMessage(mm);\n            if (!Modes.raw && !Modes.onlyaddr) printf(\"\\n\");\n        }\n        /* Send data to connected clients. */\n        if (Modes.net) {\n            modesSendRawOutput(mm);  /* Feed raw output clients. */\n        }\n    }\n}\n\n/* ========================= Interactive mode =============================== */\n\n/* Return a new aircraft structure for the interactive mode linked list\n * of aircrafts. */\nstruct aircraft *interactiveCreateAircraft(uint32_t addr) {\n    struct aircraft *a = malloc(sizeof(*a));\n\n    a->addr = addr;\n    snprintf(a->hexaddr,sizeof(a->hexaddr),\"%06x\",(int)addr);\n    a->flight[0] = '\\0';\n    a->altitude = 0;\n    a->speed = 0;\n    a->track = 0;\n    a->odd_cprlat = 0;\n    a->odd_cprlon = 0;\n    a->odd_cprtime = 0;\n    a->even_cprlat = 0;\n    a->even_cprlon = 0;\n    a->even_cprtime = 0;\n    a->lat = 0;\n    a->lon = 0;\n    a->seen = time(NULL);\n    a->messages = 0;\n    a->next = NULL;\n    return a;\n}\n\n/* Return the aircraft with the specified address, or NULL if no aircraft\n * exists with this address. */\nstruct aircraft *interactiveFindAircraft(uint32_t addr) {\n    struct aircraft *a = Modes.aircrafts;\n\n    while(a) {\n        if (a->addr == addr) return a;\n        a = a->next;\n    }\n    return NULL;\n}\n\n/* Always positive MOD operation, used for CPR decoding. */\nint cprModFunction(int a, int b) {\n    int res = a % b;\n    if (res < 0) res += b;\n    return res;\n}\n\n/* The NL function uses the precomputed table from 1090-WP-9-14 */\nint cprNLFunction(double lat) {\n    if (lat < 0) lat = -lat; /* Table is simmetric about the equator. */\n    if (lat < 10.47047130) return 59;\n    if (lat < 14.82817437) return 58;\n    if (lat < 18.18626357) return 57;\n    if (lat < 21.02939493) return 56;\n    if (lat < 23.54504487) return 55;\n    if (lat < 25.82924707) return 54;\n    if (lat < 27.93898710) return 53;\n    if (lat < 29.91135686) return 52;\n    if (lat < 31.77209708) return 51;\n    if (lat < 33.53993436) return 50;\n    if (lat < 35.22899598) return 49;\n    if (lat < 36.85025108) return 48;\n    if (lat < 38.41241892) return 47;\n    if (lat < 39.92256684) return 46;\n    if (lat < 41.38651832) return 45;\n    if (lat < 42.80914012) return 44;\n    if (lat < 44.19454951) return 43;\n    if (lat < 45.54626723) return 42;\n    if (lat < 46.86733252) return 41;\n    if (lat < 48.16039128) return 40;\n    if (lat < 49.42776439) return 39;\n    if (lat < 50.67150166) return 38;\n    if (lat < 51.89342469) return 37;\n    if (lat < 53.09516153) return 36;\n    if (lat < 54.27817472) return 35;\n    if (lat < 55.44378444) return 34;\n    if (lat < 56.59318756) return 33;\n    if (lat < 57.72747354) return 32;\n    if (lat < 58.84763776) return 31;\n    if (lat < 59.95459277) return 30;\n    if (lat < 61.04917774) return 29;\n    if (lat < 62.13216659) return 28;\n    if (lat < 63.20427479) return 27;\n    if (lat < 64.26616523) return 26;\n    if (lat < 65.31845310) return 25;\n    if (lat < 66.36171008) return 24;\n    if (lat < 67.39646774) return 23;\n    if (lat < 68.42322022) return 22;\n    if (lat < 69.44242631) return 21;\n    if (lat < 70.45451075) return 20;\n    if (lat < 71.45986473) return 19;\n    if (lat < 72.45884545) return 18;\n    if (lat < 73.45177442) return 17;\n    if (lat < 74.43893416) return 16;\n    if (lat < 75.42056257) return 15;\n    if (lat < 76.39684391) return 14;\n    if (lat < 77.36789461) return 13;\n    if (lat < 78.33374083) return 12;\n    if (lat < 79.29428225) return 11;\n    if (lat < 80.24923213) return 10;\n    if (lat < 81.19801349) return 9;\n    if (lat < 82.13956981) return 8;\n    if (lat < 83.07199445) return 7;\n    if (lat < 83.99173563) return 6;\n    if (lat < 84.89166191) return 5;\n    if (lat < 85.75541621) return 4;\n    if (lat < 86.53536998) return 3;\n    if (lat < 87.00000000) return 2;\n    else return 1;\n}\n\nint cprNFunction(double lat, int isodd) {\n    int nl = cprNLFunction(lat) - isodd;\n    if (nl < 1) nl = 1;\n    return nl;\n}\n\ndouble cprDlonFunction(double lat, int isodd) {\n    return 360.0 / cprNFunction(lat, isodd);\n}\n\n/* This algorithm comes from:\n * http://www.lll.lu/~edward/edward/adsb/DecodingADSBposition.html.\n *\n *\n * A few remarks:\n * 1) 131072 is 2^17 since CPR latitude and longitude are encoded in 17 bits.\n * 2) We assume that we always received the odd packet as last packet for\n *    simplicity. This may provide a position that is less fresh of a few\n *    seconds.\n */\nvoid decodeCPR(struct aircraft *a) {\n    const double AirDlat0 = 360.0 / 60;\n    const double AirDlat1 = 360.0 / 59;\n    double lat0 = a->even_cprlat;\n    double lat1 = a->odd_cprlat;\n    double lon0 = a->even_cprlon;\n    double lon1 = a->odd_cprlon;\n\n    /* Compute the Latitude Index \"j\" */\n    int j = floor(((59*lat0 - 60*lat1) / 131072) + 0.5);\n    double rlat0 = AirDlat0 * (cprModFunction(j,60) + lat0 / 131072);\n    double rlat1 = AirDlat1 * (cprModFunction(j,59) + lat1 / 131072);\n\n    if (rlat0 >= 270) rlat0 -= 360;\n    if (rlat1 >= 270) rlat1 -= 360;\n\n    /* Check that both are in the same latitude zone, or abort. */\n    if (cprNLFunction(rlat0) != cprNLFunction(rlat1)) return;\n\n    /* Compute ni and the longitude index m */\n    if (a->even_cprtime > a->odd_cprtime) {\n        /* Use even packet. */\n        int ni = cprNFunction(rlat0,0);\n        int m = floor((((lon0 * (cprNLFunction(rlat0)-1)) -\n                        (lon1 * cprNLFunction(rlat0))) / 131072) + 0.5);\n        a->lon = cprDlonFunction(rlat0,0) * (cprModFunction(m,ni)+lon0/131072);\n        a->lat = rlat0;\n    } else {\n        /* Use odd packet. */\n        int ni = cprNFunction(rlat1,1);\n        int m = floor((((lon0 * (cprNLFunction(rlat1)-1)) -\n                        (lon1 * cprNLFunction(rlat1))) / 131072.0) + 0.5);\n        a->lon = cprDlonFunction(rlat1,1) * (cprModFunction(m,ni)+lon1/131072);\n        a->lat = rlat1;\n    }\n    if (a->lon > 180) a->lon -= 360;\n}\n\n/* Receive new messages and populate the interactive mode with more info. */\nstruct aircraft *interactiveReceiveData(struct modesMessage *mm) {\n    uint32_t addr;\n    struct aircraft *a, *aux;\n\n    if (Modes.check_crc && mm->crcok == 0) return NULL;\n    addr = (mm->aa1 << 16) | (mm->aa2 << 8) | mm->aa3;\n\n    /* Loookup our aircraft or create a new one. */\n    a = interactiveFindAircraft(addr);\n    if (!a) {\n        a = interactiveCreateAircraft(addr);\n        a->next = Modes.aircrafts;\n        Modes.aircrafts = a;\n    } else {\n        /* If it is an already known aircraft, move it on head\n         * so we keep aircrafts ordered by received message time.\n         *\n         * However move it on head only if at least one second elapsed\n         * since the aircraft that is currently on head sent a message,\n         * othewise with multiple aircrafts at the same time we have an\n         * useless shuffle of positions on the screen. */\n        if (0 && Modes.aircrafts != a && (time(NULL) - a->seen) >= 1) {\n            aux = Modes.aircrafts;\n            while(aux->next != a) aux = aux->next;\n            /* Now we are a node before the aircraft to remove. */\n            aux->next = aux->next->next; /* removed. */\n            /* Add on head */\n            a->next = Modes.aircrafts;\n            Modes.aircrafts = a;\n        }\n    }\n\n    a->seen = time(NULL);\n    a->messages++;\n\n    if (mm->msgtype == 0 || mm->msgtype == 4 || mm->msgtype == 20) {\n        a->altitude = mm->altitude;\n    } else if (mm->msgtype == 17) {\n        if (mm->metype >= 1 && mm->metype <= 4) {\n            memcpy(a->flight, mm->flight, sizeof(a->flight));\n        } else if (mm->metype >= 9 && mm->metype <= 18) {\n            a->altitude = mm->altitude;\n            if (mm->fflag) {\n                a->odd_cprlat = mm->raw_latitude;\n                a->odd_cprlon = mm->raw_longitude;\n                a->odd_cprtime = mstime();\n            } else {\n                a->even_cprlat = mm->raw_latitude;\n                a->even_cprlon = mm->raw_longitude;\n                a->even_cprtime = mstime();\n            }\n            /* If the two data is less than 10 seconds apart, compute\n             * the position. */\n            if (llabs(a->even_cprtime - a->odd_cprtime) <= 10000) {\n                decodeCPR(a);\n            }\n        } else if (mm->metype == 19) {\n            if (mm->mesub == 1 || mm->mesub == 2) {\n                a->speed = mm->velocity;\n                a->track = mm->heading;\n            }\n        }\n    }\n    return a;\n}\n\n/* Show the currently captured interactive data on screen. */\nvoid interactiveShowData(void) {\n    struct aircraft *a = Modes.aircrafts;\n    time_t now = time(NULL);\n    char progress[4];\n    int count = 0;\n\n    memset(progress,' ',3);\n    progress[time(NULL)%3] = '.';\n    progress[3] = '\\0';\n\n    printf(\"\\x1b[H\\x1b[2J\");    /* Clear the screen */\n    printf(\n\"Hex    Flight   Altitude  Speed   Lat       Lon       Track  Messages Seen %s\\n\"\n\"--------------------------------------------------------------------------------\\n\",\n        progress);\n\n    while(a && count < Modes.interactive_rows) {\n        int altitude = a->altitude, speed = a->speed;\n\n        /* Convert units to metric if --metric was specified. */\n        if (Modes.metric) {\n            altitude /= 3.2828;\n            speed *= 1.852;\n        }\n\n        printf(\"%-6s %-8s %-9d %-7d %-7.03f   %-7.03f   %-3d   %-9ld %d sec\\n\",\n            a->hexaddr, a->flight, altitude, speed,\n            a->lat, a->lon, a->track, a->messages,\n            (int)(now - a->seen));\n        a = a->next;\n        count++;\n    }\n}\n\n/* When in interactive mode If we don't receive new nessages within\n * MODES_INTERACTIVE_TTL seconds we remove the aircraft from the list. */\nvoid interactiveRemoveStaleAircrafts(void) {\n    struct aircraft *a = Modes.aircrafts;\n    struct aircraft *prev = NULL;\n    time_t now = time(NULL);\n\n    while(a) {\n        if ((now - a->seen) > Modes.interactive_ttl) {\n            struct aircraft *next = a->next;\n            /* Remove the element from the linked list, with care\n             * if we are removing the first element. */\n            free(a);\n            if (!prev)\n                Modes.aircrafts = next;\n            else\n                prev->next = next;\n            a = next;\n        } else {\n            prev = a;\n            a = a->next;\n        }\n    }\n}\n\n/* ============================== Snip mode ================================= */\n\n/* Get raw IQ samples and filter everything is < than the specified level\n * for more than 256 samples in order to reduce example file size. */\nvoid snipMode(int level) {\n    int i, q;\n    long long c = 0;\n\n    while ((i = getchar()) != EOF && (q = getchar()) != EOF) {\n        if (abs(i-127) < level && abs(q-127) < level) {\n            c++;\n            if (c > MODES_PREAMBLE_US*4) continue;\n        } else {\n            c = 0;\n        }\n        putchar(i);\n        putchar(q);\n    }\n}\n\n/* ============================= Networking =================================\n * Note: here we risregard any kind of good coding practice in favor of\n * extreme simplicity, that is:\n *\n * 1) We only rely on the kernel buffers for our I/O without any kind of\n *    user space buffering.\n * 2) We don't register any kind of event handler, from time to time a\n *    function gets called and we accept new connections. All the rest is\n *    handled via non-blocking I/O and manually pulling clients to see if\n *    they have something new to share with us when reading is needed.\n */\n\n#define MODES_NET_SERVICE_RAWO 0\n#define MODES_NET_SERVICE_RAWI 1\n#define MODES_NET_SERVICE_HTTP 2\n#define MODES_NET_SERVICE_SBS 3\n#define MODES_NET_SERVICES_NUM 4\nstruct {\n    char *descr;\n    int *socket;\n    int port;\n} modesNetServices[MODES_NET_SERVICES_NUM] = {\n    {\"Raw TCP output\", &Modes.ros, MODES_NET_OUTPUT_RAW_PORT},\n    {\"Raw TCP input\", &Modes.ris, MODES_NET_INPUT_RAW_PORT},\n    {\"HTTP server\", &Modes.https, MODES_NET_HTTP_PORT},\n    {\"Basestation TCP output\", &Modes.sbsos, MODES_NET_OUTPUT_SBS_PORT}\n};\n\n/* Networking \"stack\" initialization. */\nvoid modesInitNet(void) {\n    int j;\n\n    memset(Modes.clients,0,sizeof(Modes.clients));\n    Modes.maxfd = -1;\n\n    for (j = 0; j < MODES_NET_SERVICES_NUM; j++) {\n        int s = anetTcpServer(Modes.aneterr, modesNetServices[j].port, NULL);\n        if (s == -1) {\n            fprintf(stderr, \"Error opening the listening port %d (%s): %s\\n\",\n                modesNetServices[j].port,\n                modesNetServices[j].descr,\n                strerror(errno));\n            exit(1);\n        }\n        anetNonBlock(Modes.aneterr, s);\n        *modesNetServices[j].socket = s;\n    }\n\n    signal(SIGPIPE, SIG_IGN);\n}\n\n/* This function gets called from time to time when the decoding thread is\n * awakened by new data arriving. This usually happens a few times every\n * second. */\nvoid modesAcceptClients(void) {\n    int fd, port;\n    unsigned int j;\n    struct client *c;\n\n    for (j = 0; j < MODES_NET_SERVICES_NUM; j++) {\n        fd = anetTcpAccept(Modes.aneterr, *modesNetServices[j].socket,\n                           NULL, &port);\n        if (fd == -1) {\n            if (Modes.debug & MODES_DEBUG_NET && errno != EAGAIN)\n                printf(\"Accept %d: %s\\n\", *modesNetServices[j].socket,\n                       strerror(errno));\n            continue;\n        }\n\n        if (fd >= MODES_NET_MAX_FD) {\n            close(fd);\n            return; /* Max number of clients reached. */\n        }\n\n        anetNonBlock(Modes.aneterr, fd);\n        c = malloc(sizeof(*c));\n        c->service = *modesNetServices[j].socket;\n        c->fd = fd;\n        c->buflen = 0;\n        Modes.clients[fd] = c;\n        anetSetSendBuffer(Modes.aneterr,fd,MODES_NET_SNDBUF_SIZE);\n\n        if (Modes.maxfd < fd) Modes.maxfd = fd;\n        if (*modesNetServices[j].socket == Modes.sbsos)\n            Modes.stat_sbs_connections++;\n\n        j--; /* Try again with the same listening port. */\n\n        if (Modes.debug & MODES_DEBUG_NET)\n            printf(\"Created new client %d\\n\", fd);\n    }\n}\n\n/* On error free the client, collect the structure, adjust maxfd if needed. */\nvoid modesFreeClient(int fd) {\n    close(fd);\n    free(Modes.clients[fd]);\n    Modes.clients[fd] = NULL;\n\n    if (Modes.debug & MODES_DEBUG_NET)\n        printf(\"Closing client %d\\n\", fd);\n\n    /* If this was our maxfd, scan the clients array to find the new max.\n     * Note that we are sure there is no active fd greater than the closed\n     * fd, so we scan from fd-1 to 0. */\n    if (Modes.maxfd == fd) {\n        int j;\n\n        Modes.maxfd = -1;\n        for (j = fd-1; j >= 0; j--) {\n            if (Modes.clients[j]) {\n                Modes.maxfd = j;\n                break;\n            }\n        }\n    }\n}\n\n/* Send the specified message to all clients listening for a given service. */\nvoid modesSendAllClients(int service, void *msg, int len) {\n    int j;\n    struct client *c;\n\n    for (j = 0; j <= Modes.maxfd; j++) {\n        c = Modes.clients[j];\n        if (c && c->service == service) {\n            int nwritten = write(j, msg, len);\n            if (nwritten != len) {\n                modesFreeClient(j);\n            }\n        }\n    }\n}\n\n/* Write raw output to TCP clients. */\nvoid modesSendRawOutput(struct modesMessage *mm) {\n    char msg[128], *p = msg;\n    int j;\n\n    *p++ = '*';\n    for (j = 0; j < mm->msgbits/8; j++) {\n        sprintf(p, \"%02X\", mm->msg[j]);\n        p += 2;\n    }\n    *p++ = ';';\n    *p++ = '\\n';\n    modesSendAllClients(Modes.ros, msg, p-msg);\n}\n\n\n/* Write SBS output to TCP clients. */\nvoid modesSendSBSOutput(struct modesMessage *mm, struct aircraft *a) {\n    char msg[256], *p = msg;\n    int emergency = 0, ground = 0, alert = 0, spi = 0;\n\n    if (mm->msgtype == 4 || mm->msgtype == 5 || mm->msgtype == 21) {\n        /* Node: identity is calculated/kept in base10 but is actually\n         * octal (07500 is represented as 7500) */\n        if (mm->identity == 7500 || mm->identity == 7600 ||\n            mm->identity == 7700) emergency = -1;\n        if (mm->fs == 1 || mm->fs == 3) ground = -1;\n        if (mm->fs == 2 || mm->fs == 3 || mm->fs == 4) alert = -1;\n        if (mm->fs == 4 || mm->fs == 5) spi = -1;\n    }\n\n    if (mm->msgtype == 0) {\n        p += sprintf(p, \"MSG,5,,,%02X%02X%02X,,,,,,,%d,,,,,,,,,,\",\n        mm->aa1, mm->aa2, mm->aa3, mm->altitude);\n    } else if (mm->msgtype == 4) {\n        p += sprintf(p, \"MSG,5,,,%02X%02X%02X,,,,,,,%d,,,,,,,%d,%d,%d,%d\",\n        mm->aa1, mm->aa2, mm->aa3, mm->altitude, alert, emergency, spi, ground);\n    } else if (mm->msgtype == 5) {\n        p += sprintf(p, \"MSG,6,,,%02X%02X%02X,,,,,,,,,,,,,%d,%d,%d,%d,%d\",\n        mm->aa1, mm->aa2, mm->aa3, mm->identity, alert, emergency, spi, ground);\n    } else if (mm->msgtype == 11) {\n        p += sprintf(p, \"MSG,8,,,%02X%02X%02X,,,,,,,,,,,,,,,,,\",\n        mm->aa1, mm->aa2, mm->aa3);\n    } else if (mm->msgtype == 17 && mm->metype == 4) {\n        p += sprintf(p, \"MSG,1,,,%02X%02X%02X,,,,,,%s,,,,,,,,0,0,0,0\",\n        mm->aa1, mm->aa2, mm->aa3, mm->flight);\n    } else if (mm->msgtype == 17 && mm->metype >= 9 && mm->metype <= 18) {\n        if (a->lat == 0 && a->lon == 0)\n            p += sprintf(p, \"MSG,3,,,%02X%02X%02X,,,,,,,%d,,,,,,,0,0,0,0\",\n            mm->aa1, mm->aa2, mm->aa3, mm->altitude);\n        else\n            p += sprintf(p, \"MSG,3,,,%02X%02X%02X,,,,,,,%d,,,%1.5f,%1.5f,,,\"\n                            \"0,0,0,0\",\n            mm->aa1, mm->aa2, mm->aa3, mm->altitude, a->lat, a->lon);\n    } else if (mm->msgtype == 17 && mm->metype == 19 && mm->mesub == 1) {\n        int vr = (mm->vert_rate_sign==0?1:-1) * (mm->vert_rate-1) * 64;\n\n        p += sprintf(p, \"MSG,4,,,%02X%02X%02X,,,,,,,,%d,%d,,,%i,,0,0,0,0\",\n        mm->aa1, mm->aa2, mm->aa3, a->speed, a->track, vr);\n    } else if (mm->msgtype == 21) {\n        p += sprintf(p, \"MSG,6,,,%02X%02X%02X,,,,,,,,,,,,,%d,%d,%d,%d,%d\",\n        mm->aa1, mm->aa2, mm->aa3, mm->identity, alert, emergency, spi, ground);\n    } else {\n        return;\n    }\n\n    *p++ = '\\n';\n    modesSendAllClients(Modes.sbsos, msg, p-msg);\n}\n\n/* Turn an hex digit into its 4 bit decimal value.\n * Returns -1 if the digit is not in the 0-F range. */\nint hexDigitVal(int c) {\n    c = tolower(c);\n    if (c >= '0' && c <= '9') return c-'0';\n    else if (c >= 'a' && c <= 'f') return c-'a'+10;\n    else return -1;\n}\n\n/* This function decodes a string representing a Mode S message in\n * raw hex format like: *8D4B969699155600E87406F5B69F;\n * The string is supposed to be at the start of the client buffer\n * and null-terminated.\n * \n * The message is passed to the higher level layers, so it feeds\n * the selected screen output, the network output and so forth.\n * \n * If the message looks invalid is silently discarded.\n *\n * The function always returns 0 (success) to the caller as there is\n * no case where we want broken messages here to close the client\n * connection. */\nint decodeHexMessage(struct client *c) {\n    char *hex = c->buf;\n    int l = strlen(hex), j;\n    unsigned char msg[MODES_LONG_MSG_BYTES];\n    struct modesMessage mm;\n\n    /* Remove spaces on the left and on the right. */\n    while(l && isspace(hex[l-1])) {\n        hex[l-1] = '\\0';\n        l--;\n    }\n    while(isspace(*hex)) {\n        hex++;\n        l--;\n    }\n\n    /* Turn the message into binary. */\n    if (l < 2 || hex[0] != '*' || hex[l-1] != ';') return 0;\n    hex++; l-=2; /* Skip * and ; */\n    if (l > MODES_LONG_MSG_BYTES*2) return 0; /* Too long message... broken. */\n    for (j = 0; j < l; j += 2) {\n        int high = hexDigitVal(hex[j]);\n        int low = hexDigitVal(hex[j+1]);\n\n        if (high == -1 || low == -1) return 0;\n        msg[j/2] = (high<<4) | low;\n    }\n    decodeModesMessage(&mm,msg);\n    useModesMessage(&mm);\n    return 0;\n}\n\n/* Return a description of planes in json. */\nchar *aircraftsToJson(int *len) {\n    struct aircraft *a = Modes.aircrafts;\n    int buflen = 1024; /* The initial buffer is incremented as needed. */\n    char *buf = malloc(buflen), *p = buf;\n    int l;\n\n    l = snprintf(p,buflen,\"[\\n\");\n    p += l; buflen -= l;\n    while(a) {\n        int altitude = a->altitude, speed = a->speed;\n\n        /* Convert units to metric if --metric was specified. */\n        if (Modes.metric) {\n            altitude /= 3.2828;\n            speed *= 1.852;\n        }\n\n        if (a->lat != 0 && a->lon != 0) {\n            l = snprintf(p,buflen,\n                \"{\\\"hex\\\":\\\"%s\\\", \\\"flight\\\":\\\"%s\\\", \\\"lat\\\":%f, \"\n                \"\\\"lon\\\":%f, \\\"altitude\\\":%d, \\\"track\\\":%d, \"\n                \"\\\"speed\\\":%d},\\n\",\n                a->hexaddr, a->flight, a->lat, a->lon, altitude, a->track,\n                speed);\n            p += l; buflen -= l;\n            /* Resize if needed. */\n            if (buflen < 256) {\n                int used = p-buf;\n                buflen += 1024; /* Our increment. */\n                buf = realloc(buf,used+buflen);\n                p = buf+used;\n            }\n        }\n        a = a->next;\n    }\n    /* Remove the final comma if any, and closes the json array. */\n    if (*(p-2) == ',') {\n        *(p-2) = '\\n';\n        p--;\n        buflen++;\n    }\n    l = snprintf(p,buflen,\"]\\n\");\n    p += l; buflen -= l;\n\n    *len = p-buf;\n    return buf;\n}\n\n#define MODES_CONTENT_TYPE_HTML \"text/html;charset=utf-8\"\n#define MODES_CONTENT_TYPE_JSON \"application/json;charset=utf-8\"\n\n/* Get an HTTP request header and write the response to the client.\n * Again here we assume that the socket buffer is enough without doing\n * any kind of userspace buffering.\n *\n * Returns 1 on error to signal the caller the client connection should\n * be closed. */\nint handleHTTPRequest(struct client *c) {\n    char hdr[512];\n    int clen, hdrlen;\n    int httpver, keepalive;\n    char *p, *url, *content;\n    char *ctype;\n\n    if (Modes.debug & MODES_DEBUG_NET)\n        printf(\"\\nHTTP request: %s\\n\", c->buf);\n\n    /* Minimally parse the request. */\n    httpver = (strstr(c->buf, \"HTTP/1.1\") != NULL) ? 11 : 10;\n    if (httpver == 10) {\n        /* HTTP 1.0 defaults to close, unless otherwise specified. */\n        keepalive = strstr(c->buf, \"Connection: keep-alive\") != NULL;\n    } else if (httpver == 11) {\n        /* HTTP 1.1 defaults to keep-alive, unless close is specified. */\n        keepalive = strstr(c->buf, \"Connection: close\") == NULL;\n    }\n\n    /* Identify he URL. */\n    p = strchr(c->buf,' ');\n    if (!p) return 1; /* There should be the method and a space... */\n    url = ++p; /* Now this should point to the requested URL. */\n    p = strchr(p, ' ');\n    if (!p) return 1; /* There should be a space before HTTP/... */\n    *p = '\\0';\n\n    if (Modes.debug & MODES_DEBUG_NET) {\n        printf(\"\\nHTTP keep alive: %d\\n\", keepalive);\n        printf(\"HTTP requested URL: %s\\n\\n\", url);\n    }\n\n    /* Select the content to send, we have just two so far:\n     * \"/\" -> Our google map application.\n     * \"/data.json\" -> Our ajax request to update planes. */\n    if (strstr(url, \"/data.json\")) {\n        content = aircraftsToJson(&clen);\n        ctype = MODES_CONTENT_TYPE_JSON;\n    } else {\n        struct stat sbuf;\n        int fd = -1;\n\n        if (stat(\"gmap.html\",&sbuf) != -1 &&\n            (fd = open(\"gmap.html\",O_RDONLY)) != -1)\n        {\n            content = malloc(sbuf.st_size);\n            if (read(fd,content,sbuf.st_size) == -1) {\n                snprintf(content,sbuf.st_size,\"Error reading from file: %s\",\n                    strerror(errno));\n            }\n            clen = sbuf.st_size;\n        } else {\n            char buf[128];\n\n            clen = snprintf(buf,sizeof(buf),\"Error opening HTML file: %s\",\n                strerror(errno));\n            content = strdup(buf);\n        }\n        if (fd != -1) close(fd);\n        ctype = MODES_CONTENT_TYPE_HTML;\n    }\n\n    /* Create the header and send the reply. */\n    hdrlen = snprintf(hdr, sizeof(hdr),\n        \"HTTP/1.1 200 OK\\r\\n\"\n        \"Server: Dump1090\\r\\n\"\n        \"Content-Type: %s\\r\\n\"\n        \"Connection: %s\\r\\n\"\n        \"Content-Length: %d\\r\\n\"\n        \"Access-Control-Allow-Origin: *\\r\\n\"\n        \"\\r\\n\",\n        ctype,\n        keepalive ? \"keep-alive\" : \"close\",\n        clen);\n\n    if (Modes.debug & MODES_DEBUG_NET)\n        printf(\"HTTP Reply header:\\n%s\", hdr);\n\n    /* Send header and content. */\n    if (write(c->fd, hdr, hdrlen) != hdrlen ||\n        write(c->fd, content, clen) != clen)\n    {\n        free(content);\n        return 1;\n    }\n    free(content);\n    Modes.stat_http_requests++;\n    return !keepalive;\n}\n\n/* This function polls the clients using read() in order to receive new\n * messages from the net.\n *\n * The message is supposed to be separated by the next message by the\n * separator 'sep', that is a null-terminated C string.\n *\n * Every full message received is decoded and passed to the higher layers\n * calling the function 'handler'.\n *\n * The handelr returns 0 on success, or 1 to signal this function we\n * should close the connection with the client in case of non-recoverable\n * errors. */\nvoid modesReadFromClient(struct client *c, char *sep,\n                         int(*handler)(struct client *))\n{\n    while(1) {\n        int left = MODES_CLIENT_BUF_SIZE - c->buflen;\n        int nread = read(c->fd, c->buf+c->buflen, left);\n        int fullmsg = 0;\n        int i;\n        char *p;\n\n        if (nread <= 0) {\n            if (nread == 0 || errno != EAGAIN) {\n                /* Error, or end of file. */\n                modesFreeClient(c->fd);\n            }\n            break; /* Serve next client. */\n        }\n        c->buflen += nread;\n\n        /* Always null-term so we are free to use strstr() */\n        c->buf[c->buflen] = '\\0';\n\n        /* If there is a complete message there must be the separator 'sep'\n         * in the buffer, note that we full-scan the buffer at every read\n         * for simplicity. */\n        while ((p = strstr(c->buf, sep)) != NULL) {\n            i = p - c->buf; /* Turn it as an index inside the buffer. */\n            c->buf[i] = '\\0'; /* Te handler expects null terminated strings. */\n            /* Call the function to process the message. It returns 1\n             * on error to signal we should close the client connection. */\n            if (handler(c)) {\n                modesFreeClient(c->fd);\n                return;\n            }\n            /* Move what's left at the start of the buffer. */\n            i += strlen(sep); /* The separator is part of the previous msg. */\n            memmove(c->buf,c->buf+i,c->buflen-i);\n            c->buflen -= i;\n            c->buf[c->buflen] = '\\0';\n            /* Maybe there are more messages inside the buffer.\n             * Start looping from the start again. */\n            fullmsg = 1;\n        }\n        /* If our buffer is full discard it, this is some badly\n         * formatted shit. */\n        if (c->buflen == MODES_CLIENT_BUF_SIZE) {\n            c->buflen = 0;\n            /* If there is garbage, read more to discard it ASAP. */\n            continue;\n        }\n        /* If no message was decoded process the next client, otherwise\n         * read more data from the same client. */\n        if (!fullmsg) break;\n    }\n}\n\n/* Read data from clients. This function actually delegates a lower-level\n * function that depends on the kind of service (raw, http, ...). */\nvoid modesReadFromClients(void) {\n    int j;\n    struct client *c;\n\n    for (j = 0; j <= Modes.maxfd; j++) {\n        if ((c = Modes.clients[j]) == NULL) continue;\n        if (c->service == Modes.ris)\n            modesReadFromClient(c,\"\\n\",decodeHexMessage);\n        else if (c->service == Modes.https)\n            modesReadFromClient(c,\"\\r\\n\\r\\n\",handleHTTPRequest);\n    }\n}\n\n/* This function is used when \"net only\" mode is enabled to know when there\n * is at least a new client to serve. Note that the dump1090 networking model\n * is extremely trivial and a function takes care of handling all the clients\n * that have something to serve, without a proper event library, so the\n * function here returns as long as there is a single client ready, or\n * when the specified timeout in milliesconds elapsed, without specifying to\n * the caller what client requires to be served. */\nvoid modesWaitReadableClients(int timeout_ms) {\n    struct timeval tv;\n    fd_set fds;\n    int j, maxfd = Modes.maxfd;\n\n    FD_ZERO(&fds);\n\n    /* Set client FDs */\n    for (j = 0; j <= Modes.maxfd; j++) {\n        if (Modes.clients[j]) FD_SET(j,&fds);\n    }\n\n    /* Set listening sockets to accept new clients ASAP. */\n    for (j = 0; j < MODES_NET_SERVICES_NUM; j++) {\n        int s = *modesNetServices[j].socket;\n        FD_SET(s,&fds);\n        if (s > maxfd) maxfd = s;\n    }\n\n    tv.tv_sec = timeout_ms/1000;\n    tv.tv_usec = (timeout_ms%1000)*1000;\n    /* We don't care why select returned here, timeout, error, or\n     * FDs ready are all conditions for which we just return. */\n    select(maxfd+1,&fds,NULL,NULL,&tv);\n}\n\n/* ============================ Terminal handling  ========================== */\n\n/* Handle resizing terminal. */\nvoid sigWinchCallback() {\n    signal(SIGWINCH, SIG_IGN);\n    Modes.interactive_rows = getTermRows();\n    interactiveShowData();\n    signal(SIGWINCH, sigWinchCallback);\n}\n\n/* Get the number of rows after the terminal changes size. */\nint getTermRows() {\n    struct winsize w;\n    ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);\n    return w.ws_row;\n}\n\n/* ================================ Main ==================================== */\n\nvoid showHelp(void) {\n    printf(\n\"--device-index <index>   Select RTL device (default: 0).\\n\"\n\"--gain <db>              Set gain (default: max gain. Use -100 for auto-gain).\\n\"\n\"--enable-agc             Enable the Automatic Gain Control (default: off).\\n\"\n\"--freq <hz>              Set frequency (default: 1090 Mhz).\\n\"\n\"--ifile <filename>       Read data from file (use '-' for stdin).\\n\"\n\"--loop                   With --ifile, read the same file in a loop.\\n\"\n\"--interactive            Interactive mode refreshing data on screen.\\n\"\n\"--interactive-rows <num> Max number of rows in interactive mode (default: 15).\\n\"\n\"--interactive-ttl <sec>  Remove from list if idle for <sec> (default: 60).\\n\"\n\"--raw                    Show only messages hex values.\\n\"\n\"--net                    Enable networking.\\n\"\n\"--net-only               Enable just networking, no RTL device or file used.\\n\"\n\"--net-ro-port <port>     TCP listening port for raw output (default: 30002).\\n\"\n\"--net-ri-port <port>     TCP listening port for raw input (default: 30001).\\n\"\n\"--net-http-port <port>   HTTP server port (default: 8080).\\n\"\n\"--net-sbs-port <port>    TCP listening port for BaseStation format output (default: 30003).\\n\"\n\"--no-fix                 Disable single-bits error correction using CRC.\\n\"\n\"--no-crc-check           Disable messages with broken CRC (discouraged).\\n\"\n\"--aggressive             More CPU for more messages (two bits fixes, ...).\\n\"\n\"--stats                  With --ifile print stats at exit. No other output.\\n\"\n\"--onlyaddr               Show only ICAO addresses (testing purposes).\\n\"\n\"--metric                 Use metric units (meters, km/h, ...).\\n\"\n\"--snip <level>           Strip IQ file removing samples < level.\\n\"\n\"--debug <flags>          Debug mode (verbose), see README for details.\\n\"\n\"--help                   Show this help.\\n\"\n\"\\n\"\n\"Debug mode flags: d = Log frames decoded with errors\\n\"\n\"                  D = Log frames decoded with zero errors\\n\"\n\"                  c = Log frames with bad CRC\\n\"\n\"                  C = Log frames with good CRC\\n\"\n\"                  p = Log frames with bad preamble\\n\"\n\"                  n = Log network debugging info\\n\"\n\"                  j = Log frames to frames.js, loadable by debug.html.\\n\"\n    );\n}\n\n/* This function is called a few times every second by main in order to\n * perform tasks we need to do continuously, like accepting new clients\n * from the net, refreshing the screen in interactive mode, and so forth. */\nvoid backgroundTasks(void) {\n    if (Modes.net) {\n        modesAcceptClients();\n        modesReadFromClients();\n        interactiveRemoveStaleAircrafts();\n    }\n\n    /* Refresh screen when in interactive mode. */\n    if (Modes.interactive &&\n        (mstime() - Modes.interactive_last_update) >\n        MODES_INTERACTIVE_REFRESH_TIME)\n    {\n        interactiveRemoveStaleAircrafts();\n        interactiveShowData();\n        Modes.interactive_last_update = mstime();\n    }\n}\n\nint main(int argc, char **argv) {\n    int j;\n\n    /* Set sane defaults. */\n    modesInitConfig();\n\n    /* Parse the command line options */\n    for (j = 1; j < argc; j++) {\n        int more = j+1 < argc; /* There are more arguments. */\n\n        if (!strcmp(argv[j],\"--device-index\") && more) {\n            Modes.dev_index = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--gain\") && more) {\n            Modes.gain = atof(argv[++j])*10; /* Gain is in tens of DBs */\n        } else if (!strcmp(argv[j],\"--enable-agc\")) {\n            Modes.enable_agc++;\n        } else if (!strcmp(argv[j],\"--freq\") && more) {\n            Modes.freq = strtoll(argv[++j],NULL,10);\n        } else if (!strcmp(argv[j],\"--ifile\") && more) {\n            Modes.filename = strdup(argv[++j]);\n        } else if (!strcmp(argv[j],\"--loop\")) {\n            Modes.loop = 1;\n        } else if (!strcmp(argv[j],\"--no-fix\")) {\n            Modes.fix_errors = 0;\n        } else if (!strcmp(argv[j],\"--no-crc-check\")) {\n            Modes.check_crc = 0;\n        } else if (!strcmp(argv[j],\"--raw\")) {\n            Modes.raw = 1;\n        } else if (!strcmp(argv[j],\"--net\")) {\n            Modes.net = 1;\n        } else if (!strcmp(argv[j],\"--net-only\")) {\n            Modes.net = 1;\n            Modes.net_only = 1;\n        } else if (!strcmp(argv[j],\"--net-ro-port\") && more) {\n            modesNetServices[MODES_NET_SERVICE_RAWO].port = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--net-ri-port\") && more) {\n            modesNetServices[MODES_NET_SERVICE_RAWI].port = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--net-http-port\") && more) {\n            modesNetServices[MODES_NET_SERVICE_HTTP].port = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--net-sbs-port\") && more) {\n            modesNetServices[MODES_NET_SERVICE_SBS].port = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--onlyaddr\")) {\n            Modes.onlyaddr = 1;\n        } else if (!strcmp(argv[j],\"--metric\")) {\n            Modes.metric = 1;\n        } else if (!strcmp(argv[j],\"--aggressive\")) {\n            Modes.aggressive++;\n        } else if (!strcmp(argv[j],\"--interactive\")) {\n            Modes.interactive = 1;\n        } else if (!strcmp(argv[j],\"--interactive-rows\")) {\n            Modes.interactive_rows = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--interactive-ttl\")) {\n            Modes.interactive_ttl = atoi(argv[++j]);\n        } else if (!strcmp(argv[j],\"--debug\") && more) {\n            char *f = argv[++j];\n            while(*f) {\n                switch(*f) {\n                case 'D': Modes.debug |= MODES_DEBUG_DEMOD; break;\n                case 'd': Modes.debug |= MODES_DEBUG_DEMODERR; break;\n                case 'C': Modes.debug |= MODES_DEBUG_GOODCRC; break;\n                case 'c': Modes.debug |= MODES_DEBUG_BADCRC; break;\n                case 'p': Modes.debug |= MODES_DEBUG_NOPREAMBLE; break;\n                case 'n': Modes.debug |= MODES_DEBUG_NET; break;\n                case 'j': Modes.debug |= MODES_DEBUG_JS; break;\n                default:\n                    fprintf(stderr, \"Unknown debugging flag: %c\\n\", *f);\n                    exit(1);\n                    break;\n                }\n                f++;\n            }\n        } else if (!strcmp(argv[j],\"--stats\")) {\n            Modes.stats = 1;\n        } else if (!strcmp(argv[j],\"--snip\") && more) {\n            snipMode(atoi(argv[++j]));\n            exit(0);\n        } else if (!strcmp(argv[j],\"--help\")) {\n            showHelp();\n            exit(0);\n        } else {\n            fprintf(stderr,\n                \"Unknown or not enough arguments for option '%s'.\\n\\n\",\n                argv[j]);\n            showHelp();\n            exit(1);\n        }\n    }\n\n    /* Setup for SIGWINCH for handling lines */\n    if (Modes.interactive == 1) signal(SIGWINCH, sigWinchCallback);\n\n    /* Initialization */\n    modesInit();\n    if (Modes.net_only) {\n        fprintf(stderr,\"Net-only mode, no RTL device or file open.\\n\");\n    } else if (Modes.filename == NULL) {\n        modesInitRTLSDR();\n    } else {\n        if (Modes.filename[0] == '-' && Modes.filename[1] == '\\0') {\n            Modes.fd = STDIN_FILENO;\n        } else if ((Modes.fd = open(Modes.filename,O_RDONLY)) == -1) {\n            perror(\"Opening data file\");\n            exit(1);\n        }\n    }\n    if (Modes.net) modesInitNet();\n\n    /* If the user specifies --net-only, just run in order to serve network\n     * clients without reading data from the RTL device. */\n    while (Modes.net_only) {\n        backgroundTasks();\n        modesWaitReadableClients(100);\n    }\n\n    /* Create the thread that will read the data from the device. */\n    pthread_create(&Modes.reader_thread, NULL, readerThreadEntryPoint, NULL);\n\n    pthread_mutex_lock(&Modes.data_mutex);\n    while(1) {\n        if (!Modes.data_ready) {\n            pthread_cond_wait(&Modes.data_cond,&Modes.data_mutex);\n            continue;\n        }\n        computeMagnitudeVector();\n\n        /* Signal to the other thread that we processed the available data\n         * and we want more (useful for --ifile). */\n        Modes.data_ready = 0;\n        pthread_cond_signal(&Modes.data_cond);\n\n        /* Process data after releasing the lock, so that the capturing\n         * thread can read data while we perform computationally expensive\n         * stuff * at the same time. (This should only be useful with very\n         * slow processors). */\n        pthread_mutex_unlock(&Modes.data_mutex);\n        detectModeS(Modes.magnitude, Modes.data_len/2);\n        backgroundTasks();\n        pthread_mutex_lock(&Modes.data_mutex);\n        if (Modes.exit) break;\n    }\n\n    /* If --ifile and --stats were given, print statistics. */\n    if (Modes.stats && Modes.filename) {\n        printf(\"%lld valid preambles\\n\", Modes.stat_valid_preamble);\n        printf(\"%lld demodulated again after phase correction\\n\",\n            Modes.stat_out_of_phase);\n        printf(\"%lld demodulated with zero errors\\n\",\n            Modes.stat_demodulated);\n        printf(\"%lld with good crc\\n\", Modes.stat_goodcrc);\n        printf(\"%lld with bad crc\\n\", Modes.stat_badcrc);\n        printf(\"%lld errors corrected\\n\", Modes.stat_fixed);\n        printf(\"%lld single bit errors\\n\", Modes.stat_single_bit_fix);\n        printf(\"%lld two bits errors\\n\", Modes.stat_two_bits_fix);\n        printf(\"%lld total usable messages\\n\",\n            Modes.stat_goodcrc + Modes.stat_fixed);\n    }\n\n    rtlsdr_close(Modes.dev);\n    return 0;\n}\n\n\n"
        },
        {
          "name": "gmap.html",
          "type": "blob",
          "size": 6.685546875,
          "content": "<!DOCTYPE html>\n\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=no\" />\n     <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.6.0/dist/leaflet.css\" integrity=\"sha512-xwE/Az9zrjBIphAcBb3F6JVqxf46+CDLwfLMHloNu6KEQCAWi6HcDUbeOfBIptF7tcCzusKFjFw2yuvEpDL9wQ==\" crossorigin=\"\"/>\n    <style type=\"text/css\">\n      html { height: 100% }\n      body { height: 100%; margin: 0; padding: 0 }\n      .plane-icon {\n        padding:0px;\n        margin:0px;\n      }\n      #map_canvas { height: 100% }\n      #info {\n        position: absolute;\n        width:20%;\n        height:100%;\n        bottom:0px;\n        right:0px;\n        top:0px;\n        background-color: white;\n        border-left:1px #666 solid;\n        font-family:Helvetica;\n      }\n      #info div {\n        padding:0px;\n        padding-left:10px;\n        margin:0px;\n      }\n      #info div h1 {\n        margin-top:10px;\n        font-size:16px;\n      }\n      #info div p {\n        font-size:14px;\n        color:#333;\n      }\n    </style>\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js\"></script>\n    <script src=\"https://unpkg.com/leaflet@1.6.0/dist/leaflet.js\" integrity=\"sha512-gZwIG9x3wUXg2hdXF6+rVkLF/0Vi9U8D2Ntg4Ga5I5BZpVkVxlJWbSQtXPSiUTtC0TjtGOmxa1AJPuV0CPthew==\" crossorigin=\"\"></script>\n    <script type=\"text/javascript\">\n    Map=null;\n    CenterLat=45.0;\n    CenterLon=9.0;\n    Planes={};\n    NumPlanes = 0;\n    Selected=null\n\n    function getIconForPlane(plane) {\n        var r = 255, g = 255, b = 0;\n        var maxalt = 40000; /* Max altitude in the average case */\n        var invalt = maxalt-plane.altitude;\n        var selected = (Selected == plane.hex);\n\n        if (invalt < 0) invalt = 0;\n        b = parseInt(255/maxalt*invalt);\n\n        /* As Icon we use the plane emoji, this is a simple solution but\n           is definitely a compromise: we expect the icon to be rotated\n           45 degrees facing north-east by default, this is true in most\n           systems but not all. */\n        var he = document.createElement(\"P\");\n        he.innerHTML = '>';\n        var rotation = 45+360-plane.track;\n        var selhtml = '';\n\n        /* Give a border to the selected plane. */\n        if (Selected == plane.hex) {\n            selhtml = 'border:1px dotted #0000aa; border-radius:10px;';\n        } else {\n            selhtml = '';\n        }\n        he = '<div style=\"transform: rotate(-'+rotation+'deg); '+selhtml+'\">✈️</div>';\n        var icon = L.divIcon({html: he, className: 'plane-icon'});\n        return icon;\n    }\n\n    function selectPlane(planehex) {\n        if (!Planes[planehex]) return;\n        var old = Selected;\n        Selected = planehex;\n        if (Planes[old]) {\n            /* Remove the highlight in the previously selected plane. */\n            Planes[old].marker.setIcon(getIconForPlane(Planes[old]));\n        }\n        Planes[Selected].marker.setIcon(getIconForPlane(Planes[Selected]));\n        refreshSelectedInfo();\n    }\n\n    /* Return a closure to caputure the 'hex' argument. This way we don't\n       have to care about how Leaflet passes the object to the callback. */\n    function selectPlaneCallback(hex) {\n        return function() {\n            return selectPlane(hex);\n        }\n    }\n    \n    function refreshGeneralInfo() {\n        var i = document.getElementById('geninfo');\n\n        i.innerHTML = NumPlanes+' planes on screen.';\n    }\n\n    function refreshSelectedInfo() {\n        var i = document.getElementById('selinfo');\n        var p = Planes[Selected];\n\n        if (!p) return;\n        var html = 'ICAO: '+p.hex+'<br>';\n        if (p.flight.length) {\n            html += '<b>'+p.flight+'</b><br>';\n        }\n        html += 'Altitude: '+p.altitude+' feet<br>';\n        html += 'Speed: '+p.speed+' knots<br>';\n        html += 'Coordinates: '+p.lat+', '+p.lon+'<br>';\n        i.innerHTML = html;\n    }\n\n    function fetchData() {\n        $.getJSON('/data.json', function(data) {\n            var stillhere = {}\n            for (var j=0; j < data.length; j++) {\n                var plane = data[j];\n                var marker = null;\n                stillhere[plane.hex] = true;\n                plane.flight = $.trim(plane.flight);\n\n                if (Planes[plane.hex]) {\n                    var myplane = Planes[plane.hex];\n                    marker = myplane.marker;\n                    marker.setLatLng([plane.lat,plane.lon]);\n                    marker.setIcon(getIconForPlane(plane));\n                    myplane.altitude = plane.altitude;\n                    myplane.speed = plane.speed;\n                    myplane.lat = plane.lat;\n                    myplane.lon = plane.lon;\n                    myplane.track = plane.track;\n                    myplane.flight = plane.flight;\n                    if (myplane.hex == Selected)\n                        refreshSelectedInfo();\n                } else {\n                    var icon = getIconForPlane(plane);\n                    var marker = L.marker([plane.lat, plane.lon], {icon: icon}).addTo(Map);\n                    var hex = plane.hex;\n                    marker.on('click',selectPlaneCallback(plane.hex));\n                    plane.marker = marker;\n                    marker.planehex = plane.hex;\n                    Planes[plane.hex] = plane;\n                }\n\n                // FIXME: Set the title\n                // if (plane.flight.length == 0)\n                //     marker.setTitle(plane.hex)\n                // else\n                //    marker.setTitle(plane.flight+' ('+plane.hex+')')\n            }\n            NumPlanes = data.length;\n\n            /* Remove idle planes. */\n            for (var p in Planes) {\n                if (!stillhere[p]) {\n                    Map.removeLayer(Planes[p].marker);\n                    delete Planes[p];\n                }\n            }\n        });\n    }\n\n    function initialize() {\n        Map = L.map('map_canvas').setView([37.0, 13.0], 8);\n\n\tL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n\t    attribution: 'Map data &copy; <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, Imagery © <a href=\"https://www.mapbox.com/\">Mapbox</a>',\n\t    maxZoom: 18,\n\t    id: 'mapbox/streets-v11',\n\t    accessToken: 'your.mapbox.access.token'\n\t}).addTo(Map);\n\n        /* Setup our timer to poll from the server. */\n        window.setInterval(function() {\n            fetchData();\n            refreshGeneralInfo();\n        }, 100);\n    }\n\n    </script>\n  </head>\n  <body onload=\"initialize()\">\n    <div id=\"map_canvas\" style=\"width:80%; height:100%\"></div>\n    <div id=\"info\">\n      <div>\n        <h1>Dump1090</h1>\n        <p id=\"geninfo\"></p>\n        <p id=\"selinfo\">Click on a plane for info.</p>\n      </div>\n    </div>\n  </body>\n</html>\n"
        },
        {
          "name": "testfiles",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}