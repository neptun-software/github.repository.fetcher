{
  "metadata": {
    "timestamp": 1736710072156,
    "page": 686,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "keendreams/keen",
      "stars": 1931,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.0888671875,
          "content": "# Commander Keen in Keen Dreams\n\nThis repository contains the source for Commander Keen in Keen Dreams.  It is released under the GNU GPLv2+.  See LICENSE for more details.\n\nThe release of the source code does not affect the licensing of the game data files, which you must still legally acquire.  This includes the static data included in this repository for your convenience.  However, you are permitted to link and distribute that data for the purposes of compatibility with the original game.\n\nThis release was made possible by a crowdfunding effort.  It is brought to you by Javier M. Chavez and Chuck Naaden with additional support from:\n\n* Dave Allen\n* Kirill Illenseer\n* Michael Jurich\n* Tom Laermans\n* Jeremy Newman\n* Braden Obrzut\n* Evan Ramos\n* Sam Schultz\n* Matt Stath\n* Ian Williams\n* Steven Zakulec\n* et al\n\n## Compiling\n\nThe code is designed for Borland C++ 2.0, but all revisions compiled fine under 3.1 at the time of release.\n\nThere is some data that must be compiled into the binary.  This data is located in the static directory.  To prepare the source for building, make sure Borland C++ is in your *PATH* and then run `make.bat`.\n\nYou may now go to the root directory and type `bc` to open the project and build.  You may need to configure your directories in Borland for it to compile properly.\n\n### EGA/CGA Version\n\nVersion 1.00 can be built for either EGA or CGA by changing a constant.  All later versions are specific to one mode.  The constant is `GRMODE` in ID_HEADS.H and ID_ASM.EQU.  Finally ensure that the proper static data files are being linked.  KDREDICT.OBJ/KDREHEAD.OBJ for EGA and KDRCDICT.OBJ/KDRCHEAD.OBJ for CGA.\n\n## Revision History\n\n> A little confusing because revisions have proceeded in three different sequences, the regular (EGA) version, the CGA version, and the shareware version.  At present, 1.05 is the latest CGA version, 1.93 is the latest EGA version, and 1.20 is the latest shareware version.  Also, some versions with suffixed letters have been used when text and other items changed without recompilation of the program itself.\n\n* 1.00 (not numbered): Original release.\n* 1.01: Version used on Tiger Software marketing deal.\n* 1.01-360: Specially adapted version to fit on 360K disk for Tiger Software marketing deal.\n* 1.01S: (mistakenly labeled 1.01): Shareware version.\n* 1.02: Registered version.\n* 1.03: Registered version (re-mastered edition).\n* 1.04: CGA version.\n* 1.05: Re-master of CGA version without Gamer's Edge references.\n\n*New CGA versions should be numbered 1.06 through 1.12*\n\n* 1.13: Shareware version (re-mastered edition).\n* 1.20: Re-master of shareware version without Gamer's Edge references.\n\n*New shareware versions should be numbered 1.21 through 1.90*\n\n* 1.91: Version for Prodigy Download Superstore.\n* 1.92 [rev 0] : Version for Good Times. The shell is not on this version.\n* 1.93 [rev 1] : Version for catalog.  Uses DocView Shell instead of old GE shell.  Copyrights updated to \"1991-1993\" with Softdisk Publishing instead of Softdisk, Inc., to suit our present guidelines.  Otherwise the same as Good Times version.\n\n*New EGA versions should be numbered 1.94 and up.*\n"
        },
        {
          "name": "audiokdr.h",
          "type": "blob",
          "size": 2.017578125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n/////////////////////////////////////////////////\r\n//\r\n// MUSE Header for .KDR\r\n// Created Mon Jul 01 18:21:23 1991\r\n//\r\n/////////////////////////////////////////////////\r\n\r\n#define NUMSOUNDS\t\t28\r\n#define NUMSNDCHUNKS\t\t84\r\n\r\n//\r\n// Sound names & indexes\r\n//\r\n#define\tKEENWALK1SND\t\t0\r\n#define\tKEENWALK2SND\t\t1\r\n#define\tJUMPSND\t\t\t2\r\n#define\tLANDSND\t\t\t3\r\n#define\tTHROWSND\t\t4\r\n#define\tDIVESND\t\t\t5\r\n#define\tGETPOWERSND\t\t6\r\n#define\tGETPOINTSSND\t\t7\r\n#define\tGETBOMBSND\t\t8\r\n#define\tFLOWERPOWERSND\t\t9\r\n#define\tUNFLOWERPOWERSND\t10\r\n#define\tENTERLEVELSND\t\t11\r\n#define\tWAKEUPSND\t\t12\r\n#define\tLEVELDONESND\t\t13\r\n#define\tNOWAYSND\t\t14\r\n#define\tHITHEADSND\t\t15\r\n#define\tTATERSWINGSND\t\t16\r\n#define\tBOUNCESND\t\t17\r\n#define\tEXTRAKEENSND\t\t18\r\n#define\tOPENDOORSND\t\t19\r\n#define\tTHROWBOMBSND\t\t20\r\n#define\tBOMBBOOMSND\t\t21\r\n#define\tBOOBUSGONESND\t\t22\r\n#define\tGETKEYSND\t\t23\r\n#define\tGRAPESCREAMSND\t\t24\r\n#define\tPLUMMETSND\t\t25\r\n#define\tCLICKSND\t\t26\r\n#define\tTICKSND\t\t\t27\r\n\r\n//\r\n// Base offsets\r\n//\r\n#define STARTPCSOUNDS\t\t0\r\n#define STARTADLIBSOUNDS\t28\r\n#define STARTDIGISOUNDS\t\t56\r\n#define STARTMUSIC\t\t84\r\n\r\n//\r\n// Music names & indexes\r\n//\r\n\r\n/////////////////////////////////////////////////\r\n//\r\n// Thanks for playing with MUSE!\r\n//\r\n/////////////////////////////////////////////////\r\n"
        },
        {
          "name": "gelib.c",
          "type": "blob",
          "size": 5.5439453125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n#include \"KD_DEF.H\"\r\n\r\n#define BIO_BUFFER_LEN\t(512)\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n//\r\n// FreeShape()\r\n//\r\nvoid FreeShape(struct Shape *shape)\r\n{\r\n\tif (shape->Data)\r\n\t\tMM_FreePtr(&shape->Data);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n//\r\n// UnpackEGAShapeToScreen()\r\n//\r\nint UnpackEGAShapeToScreen(struct Shape *SHP,int startx,int starty)\r\n{\r\n\tint currenty;\r\n\tsigned char n, Rep, far *Src, far *Dst[8], loop, Plane;\r\n\tunsigned int BPR, Height;\r\n\tint NotWordAligned;\r\n\r\n\tNotWordAligned = SHP->BPR & 1;\r\n\tstartx>>=3;\r\n\tSrc = MK_FP(SHP->Data,0);\r\n\tcurrenty = starty;\r\n\tPlane = 0;\r\n\tHeight = SHP->bmHdr.h;\r\n\twhile (Height--)\r\n\t{\r\n\t\tDst[0] = (MK_FP(0xA000,displayofs));\r\n\t\tDst[0] += ylookup[currenty];\r\n\t\tDst[0] += startx;\r\n\t\tfor (loop=1; loop<SHP->bmHdr.d; loop++)\r\n\t\t\tDst[loop] = Dst[0];\r\n\r\n\r\n\t\tfor (Plane=0; Plane<SHP->bmHdr.d; Plane++)\r\n\t\t{\r\n\t\t\toutport(0x3c4,((1<<Plane)<<8)|2);\r\n\r\n\t\t\tBPR = ((SHP->BPR+1) >> 1) << 1;               // IGNORE WORD ALIGN\r\n\t\t\twhile (BPR)\r\n\t\t\t{\r\n\t\t\t\tif (SHP->bmHdr.comp)\r\n\t\t\t\t\tn = *Src++;\r\n\t\t\t\telse\r\n\t\t\t\t\tn = BPR-1;\r\n\r\n\t\t\t\tif (n < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (n != -128)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tn = (-n)+1;\r\n\t\t\t\t\t\tBPR -= n;\r\n\t\t\t\t\t\tRep = *Src++;\r\n\t\t\t\t\t\tif ((!BPR) && (NotWordAligned))   // IGNORE WORD ALIGN\r\n\t\t\t\t\t\t\tn--;\r\n\r\n\t\t\t\t\t\twhile (n--)\r\n\t\t\t\t\t\t\t*Dst[Plane]++ = Rep;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tBPR--;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tn++;\r\n\t\t\t\t\tBPR -= n;\r\n\t\t\t\t\tif ((!BPR) && (NotWordAligned))     // IGNORE WORD ALIGN\r\n\t\t\t\t\t\tn--;\r\n\r\n\t\t\t\t\twhile (n--)\r\n\t\t\t\t\t\t*Dst[Plane]++ = *Src++;\r\n\r\n\t\t\t\t\tif ((!BPR) && (NotWordAligned))     // IGNORE WORD ALIGN\r\n\t\t\t\t\t\tSrc++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcurrenty++;\r\n\t}\r\n\r\n\treturn(0);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n//\r\n// Verify()\r\n//\r\nlong Verify(char *filename)\r\n{\r\n\tint handle;\r\n\tlong size;\r\n\r\n\tif ((handle=open(filename,O_BINARY))==-1)\r\n\t\treturn (0);\r\n\tsize=filelength(handle);\r\n\tclose(handle);\r\n\treturn(size);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// InitBufferedIO()\r\n//--------------------------------------------------------------------------\r\nmemptr InitBufferedIO(int handle, BufferedIO *bio)\r\n{\r\n\tbio->handle = handle;\r\n\tbio->offset = BIO_BUFFER_LEN;\r\n\tbio->status = 0;\r\n\tMM_GetPtr(&bio->buffer,BIO_BUFFER_LEN);\r\n\r\n\treturn(bio->buffer);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// FreeBufferedIO()\r\n//--------------------------------------------------------------------------\r\nvoid FreeBufferedIO(BufferedIO *bio)\r\n{\r\n\tif (bio->buffer)\r\n\t\tMM_FreePtr(&bio->buffer);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// bio_readch()\r\n//--------------------------------------------------------------------------\r\nbyte bio_readch(BufferedIO *bio)\r\n{\r\n\tbyte far *buffer;\r\n\r\n\tif (bio->offset == BIO_BUFFER_LEN)\r\n\t{\r\n\t\tbio->offset = 0;\r\n\t\tbio_fillbuffer(bio);\r\n\t}\r\n\r\n\tbuffer = MK_FP(bio->buffer,bio->offset++);\r\n\r\n\treturn(*buffer);\r\n}\r\n\r\n//--------------------------------------------------------------------------\r\n// bio_fillbuffer()\r\n//\r\n// BUGS (Not really bugs... More like RULES!)\r\n//\r\n//    1) This code assumes BIO_BUFFER_LEN is no smaller than\r\n//       NEAR_BUFFER_LEN!!\r\n//\r\n//    2) BufferedIO.status should be altered by this code to report\r\n//       read errors, end of file, etc... If you know how big the file\r\n//       is you're reading, determining EOF should be no problem.\r\n//\r\n//--------------------------------------------------------------------------\r\nvoid bio_fillbuffer(BufferedIO *bio)\r\n{\r\n\t#define NEAR_BUFFER_LEN\t(64)\r\n\tbyte near_buffer[NEAR_BUFFER_LEN];\r\n\tshort bio_length,bytes_read,bytes_requested;\r\n\r\n\tbytes_read = 0;\r\n\tbio_length = BIO_BUFFER_LEN;\r\n\twhile (bio_length)\r\n\t{\r\n\t\tif (bio_length > NEAR_BUFFER_LEN-1)\r\n\t\t\tbytes_requested = NEAR_BUFFER_LEN;\r\n\t\telse\r\n\t\t\tbytes_requested = bio_length;\r\n\r\n\t\tread(bio->handle,near_buffer,bytes_requested);\r\n\t\t_fmemcpy(MK_FP(bio->buffer,bytes_read),near_buffer,bytes_requested);\r\n\r\n\t\tbio_length -= bytes_requested;\r\n\t\tbytes_read += bytes_requested;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// SwapLong()\r\n//\r\nvoid SwapLong(long far *Var)\r\n{\r\n\tasm\t\tles\tbx,Var\r\n\tasm\t\tmov\tax,[es:bx]\r\n\tasm\t\txchg\tah,al\r\n\tasm\t\txchg\tax,[es:bx+2]\r\n\tasm\t\txchg\tah,al\r\n\tasm \t\tmov\t[es:bx],ax\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// SwapWord()\r\n//\r\nvoid SwapWord(unsigned int far *Var)\r\n{\r\n\tasm\t\tles\tbx,Var\r\n\tasm\t\tmov\tax,[es:bx]\r\n\tasm\t\txchg\tah,al\r\n\tasm\t\tmov\t[es:bx],ax\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n//\r\n// MoveGfxDst()\r\n//\r\nvoid MoveGfxDst(short x, short y)\r\n{\r\n\tunsigned address;\r\n\r\n\taddress = (y*linewidth)+(x/8);\r\n\tbufferofs = displayofs = address;\r\n}\r\n"
        },
        {
          "name": "gelib.h",
          "type": "blob",
          "size": 1.353515625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n#include \"SL_FILE.h\"\r\n#include \"id_mm.h\"\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// Defines\r\n//\r\n\r\nstruct BitMapHeader {\r\n\tunsigned int\tw,h,x,y;\r\n\tunsigned char\td,trans,comp,pad;\r\n};\r\n\r\nstruct BitMap {\r\n\tunsigned int Width;\r\n\tunsigned int Height;\r\n\tunsigned int Depth;\r\n\tunsigned int BytesPerRow;\r\n\tchar far *Planes[8];\r\n};\r\n\r\nstruct Shape {\r\n\tmemptr Data;\r\n\tlong size;\r\n\tunsigned int BPR;\r\n\tstruct BitMapHeader bmHdr;\r\n};\r\n\r\nvoid FreeShape(struct Shape *shape);\r\nint UnpackEGAShapeToScreen(struct Shape *SHP,int startx,int starty);\r\n"
        },
        {
          "name": "graphkdr.equ",
          "type": "blob",
          "size": 10.1171875,
          "content": ";=====================================\r\n;\r\n; Graphics .EQU file for .KDR\r\n; IGRAB-ed on Fri Sep 10 11:18:08 1993\r\n;\r\n;=====================================\r\n\r\nCTL_STARTUPPIC\t\t\t=\t4\r\nCTL_HELPUPPIC\t\t\t=\t5\r\nCTL_DISKUPPIC\t\t\t=\t6\r\nCTL_CONTROLSUPPIC\t\t=\t7\r\nCTL_SOUNDUPPIC\t\t\t=\t8\r\nCTL_MUSICUPPIC\t\t\t=\t9\r\nCTL_STARTDNPIC\t\t\t=\t10\r\nCTL_HELPDNPIC\t\t\t=\t11\r\nCTL_DISKDNPIC\t\t\t=\t12\r\nCTL_CONTROLSDNPIC\t\t=\t13\r\nCTL_SOUNDDNPIC\t\t\t=\t14\r\nCTL_MUSICDNPIC\t\t\t=\t15\r\nCTL_C_KBDUPPIC\t\t\t=\t16\r\nCTL_C_JOY1UPPIC\t\t\t=\t17\r\nCTL_C_JOY2UPPIC\t\t\t=\t18\r\nCTL_S_NOSNDUPPIC\t\t=\t19\r\nCTL_S_PCSNDUPPIC\t\t=\t20\r\nCTL_S_ADLIBUPPIC\t\t=\t21\r\nCTL_S_SNDBLUPPIC\t\t=\t22\r\nCTL_S_SNDSRCUPPIC\t\t=\t23\r\nCTL_M_NOMUSUPPIC\t\t=\t24\r\nCTL_C_KBDDNPIC\t\t\t=\t25\r\nCTL_C_JOY1DNPIC\t\t\t=\t26\r\nCTL_C_JOY2DNPIC\t\t\t=\t27\r\nCTL_S_NOSNDDNPIC\t\t=\t28\r\nCTL_S_PCSNDDNPIC\t\t=\t29\r\nCTL_S_ADLIBDNPIC\t\t=\t30\r\nCTL_S_SNDBLDNPIC\t\t=\t31\r\nCTL_S_SNDSRCDNPIC\t\t=\t32\r\nCTL_M_NOMUSDNPIC\t\t=\t33\r\nCTL_CHECKUPPIC\t\t\t=\t34\r\nCTL_CHECKDNPIC\t\t\t=\t35\r\nCTL_KEYCAPPIC\t\t\t=\t36\r\nCTL_KEYCAPCURPIC\t\t=\t37\r\nCTL_DIRSPIC\t\t\t=\t38\r\nCTL_D_SAVEUPPIC\t\t\t=\t39\r\nCTL_D_SAVEDNPIC\t\t\t=\t40\r\nCTL_D_LOADUPPIC\t\t\t=\t41\r\nCTL_D_LOADDNPIC\t\t\t=\t42\r\nCTL_P_EASYUPPIC\t\t\t=\t43\r\nCTL_P_EASYDNPIC\t\t\t=\t44\r\nCTL_P_MEDUPPIC\t\t\t=\t45\r\nCTL_P_MEDDNPIC\t\t\t=\t46\r\nCTL_P_HARDUPPIC\t\t\t=\t47\r\nCTL_P_HARDDNPIC\t\t\t=\t48\r\nCTL_P_RESUMEUPPIC\t\t=\t49\r\nCTL_P_RESUMEDNPIC\t\t=\t50\r\nCTL_P_GORESUMEUPPIC\t\t=\t51\r\nCTL_P_GORESUMEDNPIC\t\t=\t52\r\nCTL_P_NEWGAMEUPPIC\t\t=\t53\r\nCTL_P_NEWGAMEDNPIC\t\t=\t54\r\nCTL_C_CALIBRATEUPPIC\t\t=\t55\r\nCTL_C_CALIBRATEDNPIC\t\t=\t56\r\nCTL_H_STORYUPPIC\t\t=\t57\r\nCTL_H_STORYDNPIC\t\t=\t58\r\nCTL_H_CTRLUPPIC\t\t\t=\t59\r\nCTL_H_CTRLDNPIC\t\t\t=\t60\r\nCTL_H_LOSTUPPIC\t\t\t=\t61\r\nCTL_H_LOSTDNPIC\t\t\t=\t62\r\nCTL_D_LSGAMEUPPIC\t\t=\t63\r\nCTL_D_LSGAMEDNPIC\t\t=\t64\r\nCTL_D_DOSUPPIC\t\t\t=\t65\r\nCTL_D_DOSDNPIC\t\t\t=\t66\r\nCTL_D_EXITUPPIC\t\t\t=\t67\r\nCTL_D_EXITDNPIC\t\t\t=\t68\r\n\r\nCTL_LITTLEMASKPICM\t\t=\t69\r\nCTL_LSMASKPICM\t\t\t=\t70\r\n\r\nCURSORARROWSPR\t\t\t=\t71\r\nKEENSTANDRSPR\t\t\t=\t72\r\nKEENRUNR1SPR\t\t\t=\t73\r\nKEENRUNR2SPR\t\t\t=\t74\r\nKEENRUNR3SPR\t\t\t=\t75\r\nKEENRUNR4SPR\t\t\t=\t76\r\nKEENJUMPR1SPR\t\t\t=\t77\r\nKEENJUMPR2SPR\t\t\t=\t78\r\nKEENJUMPR3SPR\t\t\t=\t79\r\nKEENSTANDLSPR\t\t\t=\t80\r\nKEENRUNL1SPR\t\t\t=\t81\r\nKEENRUNL2SPR\t\t\t=\t82\r\nKEENRUNL3SPR\t\t\t=\t83\r\nKEENRUNL4SPR\t\t\t=\t84\r\nKEENJUMPL1SPR\t\t\t=\t85\r\nKEENJUMPL2SPR\t\t\t=\t86\r\nKEENJUMPL3SPR\t\t\t=\t87\r\nKEENLOOKURSPR\t\t\t=\t88\r\nKEENWAITR1SPR\t\t\t=\t89\r\nKEENWAITR2SPR\t\t\t=\t90\r\nKEENWAITR3SPR\t\t\t=\t91\r\nKEENTURNRSPR\t\t\t=\t92\r\nKEENJUMPUR1SPR\t\t\t=\t93\r\nKEENJUMPUR2SPR\t\t\t=\t94\r\nKEENLOOKULSPR\t\t\t=\t95\r\nKEENWAITL1SPR\t\t\t=\t96\r\nKEENWAITL2SPR\t\t\t=\t97\r\nKEENWAITL3SPR\t\t\t=\t98\r\nKEENTURNLSPR\t\t\t=\t99\r\nKEENJUMPUL1SPR\t\t\t=\t100\r\nKEENJUMPUL2SPR\t\t\t=\t101\r\nKEENYAWN1SPR\t\t\t=\t102\r\nKEENYAWN2SPR\t\t\t=\t103\r\nKEENYAWN3SPR\t\t\t=\t104\r\nKEENYAWN4SPR\t\t\t=\t105\r\nKEENDUCKRSPR\t\t\t=\t106\r\nKEENDUCKLSPR\t\t\t=\t107\r\nKEENTHROWL1SPR\t\t\t=\t108\r\nKEENTHROWL2SPR\t\t\t=\t109\r\nKEENTHROWL3SPR\t\t\t=\t110\r\nKEENTHROWU1SPR\t\t\t=\t111\r\nKEENTHROWU2SPR\t\t\t=\t112\r\nKEENSLEEP1SPR\t\t\t=\t113\r\nKEENSLEEP2SPR\t\t\t=\t114\r\nKEENSLEEP3SPR\t\t\t=\t115\r\nKEENSLEEP4SPR\t\t\t=\t116\r\nKEENTHROWR1SPR\t\t\t=\t117\r\nKEENTHROWR2SPR\t\t\t=\t118\r\nKEENTHROWR3SPR\t\t\t=\t119\r\nKEENZEES1SPR\t\t\t=\t120\r\nKEENZEES2SPR\t\t\t=\t121\r\nKEENZEES3SPR\t\t\t=\t122\r\nKEENJLTHROWL1SPR\t\t=\t123\r\nKEENJLTHROWL2SPR\t\t=\t124\r\nKEENJLTHROWU1SPR\t\t=\t125\r\nKEENJLTHROWU2SPR\t\t=\t126\r\nKEENJLTHROWD1SPR\t\t=\t127\r\nKEENJLTHROWD2SPR\t\t=\t128\r\nKEENJRTHROWR1SPR\t\t=\t129\r\nKEENJRTHROWR2SPR\t\t=\t130\r\nKEENJRTHROWU1SPR\t\t=\t131\r\nKEENJRTHROWU2SPR\t\t=\t132\r\nKEENJRTHROWD1SPR\t\t=\t133\r\nKEENJRTHROWD2SPR\t\t=\t134\r\nKEENDREAM1SPR\t\t\t=\t135\r\nKEENDREAM2SPR\t\t\t=\t136\r\nKEENDREAM3SPR\t\t\t=\t137\r\nKEENSHINNYR1SPR\t\t\t=\t138\r\nKEENSHINNYR2SPR\t\t\t=\t139\r\nKEENSHINNYR3SPR\t\t\t=\t140\r\nKEENSLIDED1SPR\t\t\t=\t141\r\nKEENSLIDED2SPR\t\t\t=\t142\r\nKEENSLIDED3SPR\t\t\t=\t143\r\nKEENSLIDED4SPR\t\t\t=\t144\r\nKEENSHINNYL1SPR\t\t\t=\t145\r\nKEENSHINNYL2SPR\t\t\t=\t146\r\nKEENSHINNYL3SPR\t\t\t=\t147\r\nKEENPTHROWL1SPR\t\t\t=\t148\r\nKEENPTHROWL2SPR\t\t\t=\t149\r\nKEENPTHROWR1SPR\t\t\t=\t150\r\nKEENPTHROWR2SPR\t\t\t=\t151\r\nKEENPLTHROWU1SPR\t\t=\t152\r\nKEENPLTHROWU2SPR\t\t=\t153\r\nKEENPRTHROWD1SPR\t\t=\t154\r\nKEENPRTHROWD2SPR\t\t=\t155\r\nKEENGETUPRSPR\t\t\t=\t156\r\nKEENPRTHROWU1SPR\t\t=\t157\r\nKEENPRTHROWU2SPR\t\t=\t158\r\nKEENPLTHROWD1SPR\t\t=\t159\r\nKEENPLTHROWD2SPR\t\t=\t160\r\nKEENGETUPLSPR\t\t\t=\t161\r\nFLOWERPOWER1SPR\t\t\t=\t162\r\nFLOWERPOWER2SPR\t\t\t=\t163\r\nFLOWER1SPR\t\t\t=\t164\r\nFLOWER2SPR\t\t\t=\t165\r\nFLOWER3SPR\t\t\t=\t166\r\nFLOWER4SPR\t\t\t=\t167\r\nPOOF1SPR\t\t\t=\t168\r\nPOOF2SPR\t\t\t=\t169\r\nPOOF3SPR\t\t\t=\t170\r\nPOOF4SPR\t\t\t=\t171\r\nPEPPERMINT1SPR\t\t\t=\t172\r\nPEPPERMINT2SPR\t\t\t=\t173\r\nCOOKIE1SPR\t\t\t=\t174\r\nCOOKIE2SPR\t\t\t=\t175\r\nCANDYCANE1SPR\t\t\t=\t176\r\nCANDYCANE2SPR\t\t\t=\t177\r\nCANDYBAR1SPR\t\t\t=\t178\r\nCANDYBAR2SPR\t\t\t=\t179\r\nLOLLIPOP1SPR\t\t\t=\t180\r\nLOLLIPOP2SPR\t\t\t=\t181\r\nCOTTONCANDY1SPR\t\t\t=\t182\r\nCOTTONCANDY2SPR\t\t\t=\t183\r\nEXTRAKEEN1SPR\t\t\t=\t184\r\nEXTRAKEEN2SPR\t\t\t=\t185\r\nSUPERBONUS1SPR\t\t\t=\t186\r\nSUPERBONUS2SPR\t\t\t=\t187\r\nSUPERBONUS3SPR\t\t\t=\t188\r\nSUPERBONUS4SPR\t\t\t=\t189\r\nFLOWERPOWERUP1SPR\t\t=\t190\r\nFLOWERPOWERUP2SPR\t\t=\t191\r\nBOOBUSBOMB1SPR\t\t\t=\t192\r\nBOOBUSBOMB2SPR\t\t\t=\t193\r\nBOOBUSBOMB3SPR\t\t\t=\t194\r\nBOOBUSBOOM1SPR\t\t\t=\t195\r\nBOOBUSBOOM2SPR\t\t\t=\t196\r\nMAGICKEY1SPR\t\t\t=\t197\r\nMAGICKEY2SPR\t\t\t=\t198\r\nBONUS100SPR\t\t\t=\t199\r\nBONUS200SPR\t\t\t=\t200\r\nBONUS500SPR\t\t\t=\t201\r\nBONUS1000SPR\t\t\t=\t202\r\nBONUS2000SPR\t\t\t=\t203\r\nBONUS5000SPR\t\t\t=\t204\r\nBONUS1UPSPR\t\t\t=\t205\r\nBONUSSUPERSPR\t\t\t=\t206\r\nBONUSFLOWERSPR\t\t\t=\t207\r\nBONUSFLOWERUPSPR\t\t=\t208\r\nBONUSBOMBSPR\t\t\t=\t209\r\nBONUSKEYSPR\t\t\t=\t210\r\nDOORSPR\t\t\t\t=\t211\r\nSCOREBOXSPR\t\t\t=\t212\r\nWORLDKEENL1SPR\t\t\t=\t213\r\nWORLDKEENL2SPR\t\t\t=\t214\r\nWORLDKEENL3SPR\t\t\t=\t215\r\nWORLDKEENR1SPR\t\t\t=\t216\r\nWORLDKEENR2SPR\t\t\t=\t217\r\nWORLDKEENR3SPR\t\t\t=\t218\r\nWORLDKEENU1SPR\t\t\t=\t219\r\nWORLDKEENU2SPR\t\t\t=\t220\r\nWORLDKEENU3SPR\t\t\t=\t221\r\nWORLDKEEND1SPR\t\t\t=\t222\r\nWORLDKEEND2SPR\t\t\t=\t223\r\nWORLDKEEND3SPR\t\t\t=\t224\r\nWORLDKEENDR1SPR\t\t\t=\t225\r\nWORLDKEENDR2SPR\t\t\t=\t226\r\nWORLDKEENDR3SPR\t\t\t=\t227\r\nWORLDKEENDL1SPR\t\t\t=\t228\r\nWORLDKEENDL2SPR\t\t\t=\t229\r\nWORLDKEENDL3SPR\t\t\t=\t230\r\nWORLDKEENUL1SPR\t\t\t=\t231\r\nWORLDKEENUL2SPR\t\t\t=\t232\r\nWORLDKEENUL3SPR\t\t\t=\t233\r\nWORLDKEENUR1SPR\t\t\t=\t234\r\nWORLDKEENUR2SPR\t\t\t=\t235\r\nWORLDKEENUR3SPR\t\t\t=\t236\r\nWORLDKEENSLEEP1SPR\t\t=\t237\r\nWORLDKEENSLEEP2SPR\t\t=\t238\r\nWORLDKEENWAVE1SPR\t\t=\t239\r\nWORLDKEENWAVE2SPR\t\t=\t240\r\nBROCCOLASHRUNL1SPR\t\t=\t241\r\nBROCCOLASHRUNL2SPR\t\t=\t242\r\nBROCCOLASHRUNL3SPR\t\t=\t243\r\nBROCCOLASHRUNL4SPR\t\t=\t244\r\nBROCCOLASHSMASHL1SPR\t\t=\t245\r\nBROCCOLASHSMASHL2SPR\t\t=\t246\r\nBROCCOLASHSMASHL3SPR\t\t=\t247\r\nBROCCOLASHSMASHL4SPR\t\t=\t248\r\nBROCCOLASHRUNR1SPR\t\t=\t249\r\nBROCCOLASHRUNR2SPR\t\t=\t250\r\nBROCCOLASHRUNR3SPR\t\t=\t251\r\nBROCCOLASHRUNR4SPR\t\t=\t252\r\nBROCCOLASHSMASHR1SPR\t\t=\t253\r\nBROCCOLASHSMASHR2SPR\t\t=\t254\r\nBROCCOLASHSMASHR3SPR\t\t=\t255\r\nBROCCOLASHSMASHR4SPR\t\t=\t256\r\nTOMATOOTHL1SPR\t\t\t=\t257\r\nTOMATOOTHL2SPR\t\t\t=\t258\r\nTOMATOOTHR1SPR\t\t\t=\t259\r\nTOMATOOTHR2SPR\t\t\t=\t260\r\nCARROTRUNL1SPR\t\t\t=\t261\r\nCARROTRUNL2SPR\t\t\t=\t262\r\nCARROTRUNL3SPR\t\t\t=\t263\r\nCARROTRUNL4SPR\t\t\t=\t264\r\nCARROTLEAPL1SPR\t\t\t=\t265\r\nCARROTRUNR1SPR\t\t\t=\t266\r\nCARROTRUNR2SPR\t\t\t=\t267\r\nCARROTRUNR3SPR\t\t\t=\t268\r\nCARROTRUNR4SPR\t\t\t=\t269\r\nCARROTLEAPR1SPR\t\t\t=\t270\r\nASPARAGUSRUNL1SPR\t\t=\t271\r\nASPARAGUSRUNL2SPR\t\t=\t272\r\nASPARAGUSRUNL3SPR\t\t=\t273\r\nASPARAGUSRUNL4SPR\t\t=\t274\r\nASPARAGUSRUNR1SPR\t\t=\t275\r\nASPARAGUSRUNR2SPR\t\t=\t276\r\nASPARAGUSRUNR3SPR\t\t=\t277\r\nASPARAGUSRUNR4SPR\t\t=\t278\r\nGRAPEONVINESPR\t\t\t=\t279\r\nGRAPEFALLINGSPR\t\t\t=\t280\r\nTATERTROOPWALKR1SPR\t\t=\t281\r\nTATERTROOPWALKR2SPR\t\t=\t282\r\nTATERTROOPWALKR3SPR\t\t=\t283\r\nTATERTROOPWALKR4SPR\t\t=\t284\r\nTATERTROOPLUNGER1SPR\t\t=\t285\r\nTATERTROOPLUNGER2SPR\t\t=\t286\r\nTATERTROOPWALKL1SPR\t\t=\t287\r\nTATERTROOPWALKL2SPR\t\t=\t288\r\nTATERTROOPWALKL3SPR\t\t=\t289\r\nTATERTROOPWALKL4SPR\t\t=\t290\r\nTATERTROOPLUNGEL1SPR\t\t=\t291\r\nTATERTROOPLUNGEL2SPR\t\t=\t292\r\nCANTCARTL1SPR\t\t\t=\t293\r\nCANTCARTL2SPR\t\t\t=\t294\r\nFRENCHYRUNR1SPR\t\t\t=\t295\r\nFRENCHYRUNR2SPR\t\t\t=\t296\r\nFRENCHYRUNR3SPR\t\t\t=\t297\r\nFRENCHYRUNR4SPR\t\t\t=\t298\r\nFRENCHYTHROWR1SPR\t\t=\t299\r\nFRENCHYTHROWR2SPR\t\t=\t300\r\nFRENCHYRUNL1SPR\t\t\t=\t301\r\nFRENCHYRUNL2SPR\t\t\t=\t302\r\nFRENCHYRUNL3SPR\t\t\t=\t303\r\nFRENCHYRUNL4SPR\t\t\t=\t304\r\nFRENCHYTHROWL1SPR\t\t=\t305\r\nFRENCHYTHROWL2SPR\t\t=\t306\r\nFRENCHFRY1SPR\t\t\t=\t307\r\nFRENCHFRY2SPR\t\t\t=\t308\r\nMELONLIPSR1SPR\t\t\t=\t309\r\nMELONLIPSR2SPR\t\t\t=\t310\r\nMELONLIPSL1SPR\t\t\t=\t311\r\nMELONLIPSL2SPR\t\t\t=\t312\r\nMELONLIPSD1SPR\t\t\t=\t313\r\nMELONLIPSD2SPR\t\t\t=\t314\r\nMELONSEEDR1SPR\t\t\t=\t315\r\nMELONSEEDR2SPR\t\t\t=\t316\r\nMELONSEEDL1SPR\t\t\t=\t317\r\nMELONSEEDL2SPR\t\t\t=\t318\r\nMELONSEEDD1SPR\t\t\t=\t319\r\nMELONSEEDD2SPR\t\t\t=\t320\r\nSQUASHERWALKR1SPR\t\t=\t321\r\nSQUASHERWALKR2SPR\t\t=\t322\r\nSQUASHERJUMPR1SPR\t\t=\t323\r\nSQUASHERJUMPR2SPR\t\t=\t324\r\nSQUASHERWALKL1SPR\t\t=\t325\r\nSQUASHERWALKL2SPR\t\t=\t326\r\nSQUASHERJUMPL1SPR\t\t=\t327\r\nSQUASHERJUMPL2SPR\t\t=\t328\r\nAPELWALKR1SPR\t\t\t=\t329\r\nAPELWALKR2SPR\t\t\t=\t330\r\nAPELWALKR3SPR\t\t\t=\t331\r\nAPELWALKL1SPR\t\t\t=\t332\r\nAPELWALKL2SPR\t\t\t=\t333\r\nAPELWALKL3SPR\t\t\t=\t334\r\nAPELSHINNY1SPR\t\t\t=\t335\r\nAPELSHINNY2SPR\t\t\t=\t336\r\nAPELSLIDE1SPR\t\t\t=\t337\r\nAPELSLIDE2SPR\t\t\t=\t338\r\nAPELSLIDE3SPR\t\t\t=\t339\r\nAPELSLIDE4SPR\t\t\t=\t340\r\nPEAPODRUNR1SPR\t\t\t=\t341\r\nPEAPODRUNR2SPR\t\t\t=\t342\r\nPEAPODRUNR3SPR\t\t\t=\t343\r\nPEAPODRUNR4SPR\t\t\t=\t344\r\nPEAPODSPITRSPR\t\t\t=\t345\r\nPEAPODRUNL1SPR\t\t\t=\t346\r\nPEAPODRUNL2SPR\t\t\t=\t347\r\nPEAPODRUNL3SPR\t\t\t=\t348\r\nPEAPODRUNL4SPR\t\t\t=\t349\r\nPEAPODSPITLSPR\t\t\t=\t350\r\nPEABRAINWALKR1SPR\t\t=\t351\r\nPEABRAINWALKR2SPR\t\t=\t352\r\nPEABRAINWALKR3SPR\t\t=\t353\r\nPEABRAINWALKR4SPR\t\t=\t354\r\nPEABRAINWALKL1SPR\t\t=\t355\r\nPEABRAINWALKL2SPR\t\t=\t356\r\nPEABRAINWALKL3SPR\t\t=\t357\r\nPEABRAINWALKL4SPR\t\t=\t358\r\nBOOBUSWALKL1SPR\t\t\t=\t359\r\nBOOBUSWALKL2SPR\t\t\t=\t360\r\nBOOBUSWALKL3SPR\t\t\t=\t361\r\nBOOBUSWALKL4SPR\t\t\t=\t362\r\nBOOBUSWALKR1SPR\t\t\t=\t363\r\nBOOBUSWALKR2SPR\t\t\t=\t364\r\nBOOBUSWALKR3SPR\t\t\t=\t365\r\nBOOBUSWALKR4SPR\t\t\t=\t366\r\nBOOBUSJUMPSPR\t\t\t=\t367\r\n\r\nCONTROLS_LUMP_START\t\t=\t0\r\nCONTROLS_LUMP_END\t\t=\t64\r\nKEEN_LUMP_START\t\t\t=\t1\r\nKEEN_LUMP_END\t\t\t=\t141\r\nWORLDKEEN_LUMP_START\t\t=\t142\r\nWORLDKEEN_LUMP_END\t\t=\t169\r\nBROCCOLASH_LUMP_START\t\t=\t170\r\nBROCCOLASH_LUMP_END\t\t=\t185\r\nTOMATO_LUMP_START\t\t=\t186\r\nTOMATO_LUMP_END\t\t\t=\t189\r\nCARROT_LUMP_START\t\t=\t190\r\nCARROT_LUMP_END\t\t\t=\t199\r\nASPAR_LUMP_START\t\t=\t200\r\nASPAR_LUMP_END\t\t\t=\t207\r\nGRAPE_LUMP_START\t\t=\t208\r\nGRAPE_LUMP_END\t\t\t=\t209\r\nTATER_LUMP_START\t\t=\t210\r\nTATER_LUMP_END\t\t\t=\t221\r\nCANTA_LUMP_START\t\t=\t222\r\nCANTA_LUMP_END\t\t\t=\t223\r\nFRENCHY_LUMP_START\t\t=\t224\r\nFRENCHY_LUMP_END\t\t=\t237\r\nMELONLIPS_LUMP_START\t\t=\t238\r\nMELONLIPS_LUMP_END\t\t=\t249\r\nSQUASHER_LUMP_START\t\t=\t250\r\nSQUASHER_LUMP_END\t\t=\t257\r\nAPEL_LUMP_START\t\t\t=\t258\r\nAPEL_LUMP_END\t\t\t=\t269\r\nPEAS_LUMP_START\t\t\t=\t270\r\nPEAS_LUMP_END\t\t\t=\t287\r\nBOOBUS_LUMP_START\t\t=\t288\r\nBOOBUS_LUMP_END\t\t\t=\t296\r\n\r\n;\r\n; Amount of each data item\r\n;\r\nNUMCHUNKS\t=\t3016\r\nNUMFONT  \t=\t1\r\nNUMFONTM  \t=\t0\r\nNUMPICS  \t=\t65\r\nNUMPICM  \t=\t2\r\nNUMSPRITES  \t=\t297\r\nNUMTILE8  \t=\t72\r\nNUMTILE8M  \t=\t36\r\nNUMTILE16  \t=\t1440\r\nNUMTILE16M  \t=\t1206\r\nNUMTILE32  \t=\t0\r\nNUMTILE32M  \t=\t0\r\n;\r\n; File offsets for data items\r\n;\r\nSTRUCTPIC  \t=\t0\r\nSTRUCTPICM  \t=\t1\r\nSTRUCTSPRITE  \t=\t2\r\n\r\nSTARTFONT  \t=\t3\r\nSTARTFONTM  \t=\t4\r\nSTARTPICS  \t=\t4\r\nSTARTPICM  \t=\t69\r\nSTARTSPRITES  \t=\t71\r\nSTARTTILE8  \t=\t368\r\nSTARTTILE8M  \t=\t369\r\nSTARTTILE16  \t=\t370\r\nSTARTTILE16M  \t=\t1810\r\nSTARTTILE32  \t=\t3016\r\nSTARTTILE32M  \t=\t3016\r\n\r\n;\r\n; Thank you for using IGRAB!\r\n;\r\n"
        },
        {
          "name": "graphkdr.h",
          "type": "blob",
          "size": 13.4248046875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//////////////////////////////////////\r\n//\r\n// Graphics .H file for .KDR\r\n// IGRAB-ed on Fri Sep 10 11:18:07 1993\r\n//\r\n//////////////////////////////////////\r\n\r\n#define CTL_STARTUPPIC\t\t\t4\r\n#define CTL_HELPUPPIC\t\t\t5\r\n#define CTL_DISKUPPIC\t\t\t6\r\n#define CTL_CONTROLSUPPIC\t\t7\r\n#define CTL_SOUNDUPPIC\t\t\t8\r\n#define CTL_MUSICUPPIC\t\t\t9\r\n#define CTL_STARTDNPIC\t\t\t10\r\n#define CTL_HELPDNPIC\t\t\t11\r\n#define CTL_DISKDNPIC\t\t\t12\r\n#define CTL_CONTROLSDNPIC\t\t13\r\n#define CTL_SOUNDDNPIC\t\t\t14\r\n#define CTL_MUSICDNPIC\t\t\t15\r\n#define CTL_C_KBDUPPIC\t\t\t16\r\n#define CTL_C_JOY1UPPIC\t\t\t17\r\n#define CTL_C_JOY2UPPIC\t\t\t18\r\n#define CTL_S_NOSNDUPPIC\t\t19\r\n#define CTL_S_PCSNDUPPIC\t\t20\r\n#define CTL_S_ADLIBUPPIC\t\t21\r\n#define CTL_S_SNDBLUPPIC\t\t22\r\n#define CTL_S_SNDSRCUPPIC\t\t23\r\n#define CTL_M_NOMUSUPPIC\t\t24\r\n#define CTL_C_KBDDNPIC\t\t\t25\r\n#define CTL_C_JOY1DNPIC\t\t\t26\r\n#define CTL_C_JOY2DNPIC\t\t\t27\r\n#define CTL_S_NOSNDDNPIC\t\t28\r\n#define CTL_S_PCSNDDNPIC\t\t29\r\n#define CTL_S_ADLIBDNPIC\t\t30\r\n#define CTL_S_SNDBLDNPIC\t\t31\r\n#define CTL_S_SNDSRCDNPIC\t\t32\r\n#define CTL_M_NOMUSDNPIC\t\t33\r\n#define CTL_CHECKUPPIC\t\t\t34\r\n#define CTL_CHECKDNPIC\t\t\t35\r\n#define CTL_KEYCAPPIC\t\t\t36\r\n#define CTL_KEYCAPCURPIC\t\t37\r\n#define CTL_DIRSPIC\t\t\t38\r\n#define CTL_D_SAVEUPPIC\t\t\t39\r\n#define CTL_D_SAVEDNPIC\t\t\t40\r\n#define CTL_D_LOADUPPIC\t\t\t41\r\n#define CTL_D_LOADDNPIC\t\t\t42\r\n#define CTL_P_EASYUPPIC\t\t\t43\r\n#define CTL_P_EASYDNPIC\t\t\t44\r\n#define CTL_P_MEDUPPIC\t\t\t45\r\n#define CTL_P_MEDDNPIC\t\t\t46\r\n#define CTL_P_HARDUPPIC\t\t\t47\r\n#define CTL_P_HARDDNPIC\t\t\t48\r\n#define CTL_P_RESUMEUPPIC\t\t49\r\n#define CTL_P_RESUMEDNPIC\t\t50\r\n#define CTL_P_GORESUMEUPPIC\t\t51\r\n#define CTL_P_GORESUMEDNPIC\t\t52\r\n#define CTL_P_NEWGAMEUPPIC\t\t53\r\n#define CTL_P_NEWGAMEDNPIC\t\t54\r\n#define CTL_C_CALIBRATEUPPIC\t\t55\r\n#define CTL_C_CALIBRATEDNPIC\t\t56\r\n#define CTL_H_STORYUPPIC\t\t57\r\n#define CTL_H_STORYDNPIC\t\t58\r\n#define CTL_H_CTRLUPPIC\t\t\t59\r\n#define CTL_H_CTRLDNPIC\t\t\t60\r\n#define CTL_H_LOSTUPPIC\t\t\t61\r\n#define CTL_H_LOSTDNPIC\t\t\t62\r\n#define CTL_D_LSGAMEUPPIC\t\t63\r\n#define CTL_D_LSGAMEDNPIC\t\t64\r\n#define CTL_D_DOSUPPIC\t\t\t65\r\n#define CTL_D_DOSDNPIC\t\t\t66\r\n#define CTL_D_EXITUPPIC\t\t\t67\r\n#define CTL_D_EXITDNPIC\t\t\t68\r\n\r\n#define CTL_LITTLEMASKPICM\t\t69\r\n#define CTL_LSMASKPICM\t\t\t70\r\n\r\n#define CURSORARROWSPR\t\t\t71\r\n#define KEENSTANDRSPR\t\t\t72\r\n#define KEENRUNR1SPR\t\t\t73\r\n#define KEENRUNR2SPR\t\t\t74\r\n#define KEENRUNR3SPR\t\t\t75\r\n#define KEENRUNR4SPR\t\t\t76\r\n#define KEENJUMPR1SPR\t\t\t77\r\n#define KEENJUMPR2SPR\t\t\t78\r\n#define KEENJUMPR3SPR\t\t\t79\r\n#define KEENSTANDLSPR\t\t\t80\r\n#define KEENRUNL1SPR\t\t\t81\r\n#define KEENRUNL2SPR\t\t\t82\r\n#define KEENRUNL3SPR\t\t\t83\r\n#define KEENRUNL4SPR\t\t\t84\r\n#define KEENJUMPL1SPR\t\t\t85\r\n#define KEENJUMPL2SPR\t\t\t86\r\n#define KEENJUMPL3SPR\t\t\t87\r\n#define KEENLOOKURSPR\t\t\t88\r\n#define KEENWAITR1SPR\t\t\t89\r\n#define KEENWAITR2SPR\t\t\t90\r\n#define KEENWAITR3SPR\t\t\t91\r\n#define KEENTURNRSPR\t\t\t92\r\n#define KEENJUMPUR1SPR\t\t\t93\r\n#define KEENJUMPUR2SPR\t\t\t94\r\n#define KEENLOOKULSPR\t\t\t95\r\n#define KEENWAITL1SPR\t\t\t96\r\n#define KEENWAITL2SPR\t\t\t97\r\n#define KEENWAITL3SPR\t\t\t98\r\n#define KEENTURNLSPR\t\t\t99\r\n#define KEENJUMPUL1SPR\t\t\t100\r\n#define KEENJUMPUL2SPR\t\t\t101\r\n#define KEENYAWN1SPR\t\t\t102\r\n#define KEENYAWN2SPR\t\t\t103\r\n#define KEENYAWN3SPR\t\t\t104\r\n#define KEENYAWN4SPR\t\t\t105\r\n#define KEENDUCKRSPR\t\t\t106\r\n#define KEENDUCKLSPR\t\t\t107\r\n#define KEENTHROWL1SPR\t\t\t108\r\n#define KEENTHROWL2SPR\t\t\t109\r\n#define KEENTHROWL3SPR\t\t\t110\r\n#define KEENTHROWU1SPR\t\t\t111\r\n#define KEENTHROWU2SPR\t\t\t112\r\n#define KEENSLEEP1SPR\t\t\t113\r\n#define KEENSLEEP2SPR\t\t\t114\r\n#define KEENSLEEP3SPR\t\t\t115\r\n#define KEENSLEEP4SPR\t\t\t116\r\n#define KEENTHROWR1SPR\t\t\t117\r\n#define KEENTHROWR2SPR\t\t\t118\r\n#define KEENTHROWR3SPR\t\t\t119\r\n#define KEENZEES1SPR\t\t\t120\r\n#define KEENZEES2SPR\t\t\t121\r\n#define KEENZEES3SPR\t\t\t122\r\n#define KEENJLTHROWL1SPR\t\t123\r\n#define KEENJLTHROWL2SPR\t\t124\r\n#define KEENJLTHROWU1SPR\t\t125\r\n#define KEENJLTHROWU2SPR\t\t126\r\n#define KEENJLTHROWD1SPR\t\t127\r\n#define KEENJLTHROWD2SPR\t\t128\r\n#define KEENJRTHROWR1SPR\t\t129\r\n#define KEENJRTHROWR2SPR\t\t130\r\n#define KEENJRTHROWU1SPR\t\t131\r\n#define KEENJRTHROWU2SPR\t\t132\r\n#define KEENJRTHROWD1SPR\t\t133\r\n#define KEENJRTHROWD2SPR\t\t134\r\n#define KEENDREAM1SPR\t\t\t135\r\n#define KEENDREAM2SPR\t\t\t136\r\n#define KEENDREAM3SPR\t\t\t137\r\n#define KEENSHINNYR1SPR\t\t\t138\r\n#define KEENSHINNYR2SPR\t\t\t139\r\n#define KEENSHINNYR3SPR\t\t\t140\r\n#define KEENSLIDED1SPR\t\t\t141\r\n#define KEENSLIDED2SPR\t\t\t142\r\n#define KEENSLIDED3SPR\t\t\t143\r\n#define KEENSLIDED4SPR\t\t\t144\r\n#define KEENSHINNYL1SPR\t\t\t145\r\n#define KEENSHINNYL2SPR\t\t\t146\r\n#define KEENSHINNYL3SPR\t\t\t147\r\n#define KEENPTHROWL1SPR\t\t\t148\r\n#define KEENPTHROWL2SPR\t\t\t149\r\n#define KEENPTHROWR1SPR\t\t\t150\r\n#define KEENPTHROWR2SPR\t\t\t151\r\n#define KEENPLTHROWU1SPR\t\t152\r\n#define KEENPLTHROWU2SPR\t\t153\r\n#define KEENPRTHROWD1SPR\t\t154\r\n#define KEENPRTHROWD2SPR\t\t155\r\n#define KEENGETUPRSPR\t\t\t156\r\n#define KEENPRTHROWU1SPR\t\t157\r\n#define KEENPRTHROWU2SPR\t\t158\r\n#define KEENPLTHROWD1SPR\t\t159\r\n#define KEENPLTHROWD2SPR\t\t160\r\n#define KEENGETUPLSPR\t\t\t161\r\n#define FLOWERPOWER1SPR\t\t\t162\r\n#define FLOWERPOWER2SPR\t\t\t163\r\n#define FLOWER1SPR\t\t\t164\r\n#define FLOWER2SPR\t\t\t165\r\n#define FLOWER3SPR\t\t\t166\r\n#define FLOWER4SPR\t\t\t167\r\n#define POOF1SPR\t\t\t168\r\n#define POOF2SPR\t\t\t169\r\n#define POOF3SPR\t\t\t170\r\n#define POOF4SPR\t\t\t171\r\n#define PEPPERMINT1SPR\t\t\t172\r\n#define PEPPERMINT2SPR\t\t\t173\r\n#define COOKIE1SPR\t\t\t174\r\n#define COOKIE2SPR\t\t\t175\r\n#define CANDYCANE1SPR\t\t\t176\r\n#define CANDYCANE2SPR\t\t\t177\r\n#define CANDYBAR1SPR\t\t\t178\r\n#define CANDYBAR2SPR\t\t\t179\r\n#define LOLLIPOP1SPR\t\t\t180\r\n#define LOLLIPOP2SPR\t\t\t181\r\n#define COTTONCANDY1SPR\t\t\t182\r\n#define COTTONCANDY2SPR\t\t\t183\r\n#define EXTRAKEEN1SPR\t\t\t184\r\n#define EXTRAKEEN2SPR\t\t\t185\r\n#define SUPERBONUS1SPR\t\t\t186\r\n#define SUPERBONUS2SPR\t\t\t187\r\n#define SUPERBONUS3SPR\t\t\t188\r\n#define SUPERBONUS4SPR\t\t\t189\r\n#define FLOWERPOWERUP1SPR\t\t190\r\n#define FLOWERPOWERUP2SPR\t\t191\r\n#define BOOBUSBOMB1SPR\t\t\t192\r\n#define BOOBUSBOMB2SPR\t\t\t193\r\n#define BOOBUSBOMB3SPR\t\t\t194\r\n#define BOOBUSBOOM1SPR\t\t\t195\r\n#define BOOBUSBOOM2SPR\t\t\t196\r\n#define MAGICKEY1SPR\t\t\t197\r\n#define MAGICKEY2SPR\t\t\t198\r\n#define BONUS100SPR\t\t\t199\r\n#define BONUS200SPR\t\t\t200\r\n#define BONUS500SPR\t\t\t201\r\n#define BONUS1000SPR\t\t\t202\r\n#define BONUS2000SPR\t\t\t203\r\n#define BONUS5000SPR\t\t\t204\r\n#define BONUS1UPSPR\t\t\t205\r\n#define BONUSSUPERSPR\t\t\t206\r\n#define BONUSFLOWERSPR\t\t\t207\r\n#define BONUSFLOWERUPSPR\t\t208\r\n#define BONUSBOMBSPR\t\t\t209\r\n#define BONUSKEYSPR\t\t\t210\r\n#define DOORSPR\t\t\t\t211\r\n#define SCOREBOXSPR\t\t\t212\r\n#define WORLDKEENL1SPR\t\t\t213\r\n#define WORLDKEENL2SPR\t\t\t214\r\n#define WORLDKEENL3SPR\t\t\t215\r\n#define WORLDKEENR1SPR\t\t\t216\r\n#define WORLDKEENR2SPR\t\t\t217\r\n#define WORLDKEENR3SPR\t\t\t218\r\n#define WORLDKEENU1SPR\t\t\t219\r\n#define WORLDKEENU2SPR\t\t\t220\r\n#define WORLDKEENU3SPR\t\t\t221\r\n#define WORLDKEEND1SPR\t\t\t222\r\n#define WORLDKEEND2SPR\t\t\t223\r\n#define WORLDKEEND3SPR\t\t\t224\r\n#define WORLDKEENDR1SPR\t\t\t225\r\n#define WORLDKEENDR2SPR\t\t\t226\r\n#define WORLDKEENDR3SPR\t\t\t227\r\n#define WORLDKEENDL1SPR\t\t\t228\r\n#define WORLDKEENDL2SPR\t\t\t229\r\n#define WORLDKEENDL3SPR\t\t\t230\r\n#define WORLDKEENUL1SPR\t\t\t231\r\n#define WORLDKEENUL2SPR\t\t\t232\r\n#define WORLDKEENUL3SPR\t\t\t233\r\n#define WORLDKEENUR1SPR\t\t\t234\r\n#define WORLDKEENUR2SPR\t\t\t235\r\n#define WORLDKEENUR3SPR\t\t\t236\r\n#define WORLDKEENSLEEP1SPR\t\t237\r\n#define WORLDKEENSLEEP2SPR\t\t238\r\n#define WORLDKEENWAVE1SPR\t\t239\r\n#define WORLDKEENWAVE2SPR\t\t240\r\n#define BROCCOLASHRUNL1SPR\t\t241\r\n#define BROCCOLASHRUNL2SPR\t\t242\r\n#define BROCCOLASHRUNL3SPR\t\t243\r\n#define BROCCOLASHRUNL4SPR\t\t244\r\n#define BROCCOLASHSMASHL1SPR\t\t245\r\n#define BROCCOLASHSMASHL2SPR\t\t246\r\n#define BROCCOLASHSMASHL3SPR\t\t247\r\n#define BROCCOLASHSMASHL4SPR\t\t248\r\n#define BROCCOLASHRUNR1SPR\t\t249\r\n#define BROCCOLASHRUNR2SPR\t\t250\r\n#define BROCCOLASHRUNR3SPR\t\t251\r\n#define BROCCOLASHRUNR4SPR\t\t252\r\n#define BROCCOLASHSMASHR1SPR\t\t253\r\n#define BROCCOLASHSMASHR2SPR\t\t254\r\n#define BROCCOLASHSMASHR3SPR\t\t255\r\n#define BROCCOLASHSMASHR4SPR\t\t256\r\n#define TOMATOOTHL1SPR\t\t\t257\r\n#define TOMATOOTHL2SPR\t\t\t258\r\n#define TOMATOOTHR1SPR\t\t\t259\r\n#define TOMATOOTHR2SPR\t\t\t260\r\n#define CARROTRUNL1SPR\t\t\t261\r\n#define CARROTRUNL2SPR\t\t\t262\r\n#define CARROTRUNL3SPR\t\t\t263\r\n#define CARROTRUNL4SPR\t\t\t264\r\n#define CARROTLEAPL1SPR\t\t\t265\r\n#define CARROTRUNR1SPR\t\t\t266\r\n#define CARROTRUNR2SPR\t\t\t267\r\n#define CARROTRUNR3SPR\t\t\t268\r\n#define CARROTRUNR4SPR\t\t\t269\r\n#define CARROTLEAPR1SPR\t\t\t270\r\n#define ASPARAGUSRUNL1SPR\t\t271\r\n#define ASPARAGUSRUNL2SPR\t\t272\r\n#define ASPARAGUSRUNL3SPR\t\t273\r\n#define ASPARAGUSRUNL4SPR\t\t274\r\n#define ASPARAGUSRUNR1SPR\t\t275\r\n#define ASPARAGUSRUNR2SPR\t\t276\r\n#define ASPARAGUSRUNR3SPR\t\t277\r\n#define ASPARAGUSRUNR4SPR\t\t278\r\n#define GRAPEONVINESPR\t\t\t279\r\n#define GRAPEFALLINGSPR\t\t\t280\r\n#define TATERTROOPWALKR1SPR\t\t281\r\n#define TATERTROOPWALKR2SPR\t\t282\r\n#define TATERTROOPWALKR3SPR\t\t283\r\n#define TATERTROOPWALKR4SPR\t\t284\r\n#define TATERTROOPLUNGER1SPR\t\t285\r\n#define TATERTROOPLUNGER2SPR\t\t286\r\n#define TATERTROOPWALKL1SPR\t\t287\r\n#define TATERTROOPWALKL2SPR\t\t288\r\n#define TATERTROOPWALKL3SPR\t\t289\r\n#define TATERTROOPWALKL4SPR\t\t290\r\n#define TATERTROOPLUNGEL1SPR\t\t291\r\n#define TATERTROOPLUNGEL2SPR\t\t292\r\n#define CANTCARTL1SPR\t\t\t293\r\n#define CANTCARTL2SPR\t\t\t294\r\n#define FRENCHYRUNR1SPR\t\t\t295\r\n#define FRENCHYRUNR2SPR\t\t\t296\r\n#define FRENCHYRUNR3SPR\t\t\t297\r\n#define FRENCHYRUNR4SPR\t\t\t298\r\n#define FRENCHYTHROWR1SPR\t\t299\r\n#define FRENCHYTHROWR2SPR\t\t300\r\n#define FRENCHYRUNL1SPR\t\t\t301\r\n#define FRENCHYRUNL2SPR\t\t\t302\r\n#define FRENCHYRUNL3SPR\t\t\t303\r\n#define FRENCHYRUNL4SPR\t\t\t304\r\n#define FRENCHYTHROWL1SPR\t\t305\r\n#define FRENCHYTHROWL2SPR\t\t306\r\n#define FRENCHFRY1SPR\t\t\t307\r\n#define FRENCHFRY2SPR\t\t\t308\r\n#define MELONLIPSR1SPR\t\t\t309\r\n#define MELONLIPSR2SPR\t\t\t310\r\n#define MELONLIPSL1SPR\t\t\t311\r\n#define MELONLIPSL2SPR\t\t\t312\r\n#define MELONLIPSD1SPR\t\t\t313\r\n#define MELONLIPSD2SPR\t\t\t314\r\n#define MELONSEEDR1SPR\t\t\t315\r\n#define MELONSEEDR2SPR\t\t\t316\r\n#define MELONSEEDL1SPR\t\t\t317\r\n#define MELONSEEDL2SPR\t\t\t318\r\n#define MELONSEEDD1SPR\t\t\t319\r\n#define MELONSEEDD2SPR\t\t\t320\r\n#define SQUASHERWALKR1SPR\t\t321\r\n#define SQUASHERWALKR2SPR\t\t322\r\n#define SQUASHERJUMPR1SPR\t\t323\r\n#define SQUASHERJUMPR2SPR\t\t324\r\n#define SQUASHERWALKL1SPR\t\t325\r\n#define SQUASHERWALKL2SPR\t\t326\r\n#define SQUASHERJUMPL1SPR\t\t327\r\n#define SQUASHERJUMPL2SPR\t\t328\r\n#define APELWALKR1SPR\t\t\t329\r\n#define APELWALKR2SPR\t\t\t330\r\n#define APELWALKR3SPR\t\t\t331\r\n#define APELWALKL1SPR\t\t\t332\r\n#define APELWALKL2SPR\t\t\t333\r\n#define APELWALKL3SPR\t\t\t334\r\n#define APELSHINNY1SPR\t\t\t335\r\n#define APELSHINNY2SPR\t\t\t336\r\n#define APELSLIDE1SPR\t\t\t337\r\n#define APELSLIDE2SPR\t\t\t338\r\n#define APELSLIDE3SPR\t\t\t339\r\n#define APELSLIDE4SPR\t\t\t340\r\n#define PEAPODRUNR1SPR\t\t\t341\r\n#define PEAPODRUNR2SPR\t\t\t342\r\n#define PEAPODRUNR3SPR\t\t\t343\r\n#define PEAPODRUNR4SPR\t\t\t344\r\n#define PEAPODSPITRSPR\t\t\t345\r\n#define PEAPODRUNL1SPR\t\t\t346\r\n#define PEAPODRUNL2SPR\t\t\t347\r\n#define PEAPODRUNL3SPR\t\t\t348\r\n#define PEAPODRUNL4SPR\t\t\t349\r\n#define PEAPODSPITLSPR\t\t\t350\r\n#define PEABRAINWALKR1SPR\t\t351\r\n#define PEABRAINWALKR2SPR\t\t352\r\n#define PEABRAINWALKR3SPR\t\t353\r\n#define PEABRAINWALKR4SPR\t\t354\r\n#define PEABRAINWALKL1SPR\t\t355\r\n#define PEABRAINWALKL2SPR\t\t356\r\n#define PEABRAINWALKL3SPR\t\t357\r\n#define PEABRAINWALKL4SPR\t\t358\r\n#define BOOBUSWALKL1SPR\t\t\t359\r\n#define BOOBUSWALKL2SPR\t\t\t360\r\n#define BOOBUSWALKL3SPR\t\t\t361\r\n#define BOOBUSWALKL4SPR\t\t\t362\r\n#define BOOBUSWALKR1SPR\t\t\t363\r\n#define BOOBUSWALKR2SPR\t\t\t364\r\n#define BOOBUSWALKR3SPR\t\t\t365\r\n#define BOOBUSWALKR4SPR\t\t\t366\r\n#define BOOBUSJUMPSPR\t\t\t367\r\n\r\n//\r\n// Data LUMPs\r\n//\r\n#define CONTROLS_LUMP_START\t\t4\r\n#define CONTROLS_LUMP_END\t\t68\r\n#define KEEN_LUMP_START\t\t\t72\r\n#define KEEN_LUMP_END\t\t\t212\r\n#define WORLDKEEN_LUMP_START\t\t213\r\n#define WORLDKEEN_LUMP_END\t\t240\r\n#define BROCCOLASH_LUMP_START\t\t241\r\n#define BROCCOLASH_LUMP_END\t\t256\r\n#define TOMATO_LUMP_START\t\t257\r\n#define TOMATO_LUMP_END\t\t\t260\r\n#define CARROT_LUMP_START\t\t261\r\n#define CARROT_LUMP_END\t\t\t270\r\n#define ASPAR_LUMP_START\t\t271\r\n#define ASPAR_LUMP_END\t\t\t278\r\n#define GRAPE_LUMP_START\t\t279\r\n#define GRAPE_LUMP_END\t\t\t280\r\n#define TATER_LUMP_START\t\t281\r\n#define TATER_LUMP_END\t\t\t292\r\n#define CANTA_LUMP_START\t\t293\r\n#define CANTA_LUMP_END\t\t\t294\r\n#define FRENCHY_LUMP_START\t\t295\r\n#define FRENCHY_LUMP_END\t\t308\r\n#define MELONLIPS_LUMP_START\t\t309\r\n#define MELONLIPS_LUMP_END\t\t320\r\n#define SQUASHER_LUMP_START\t\t321\r\n#define SQUASHER_LUMP_END\t\t328\r\n#define APEL_LUMP_START\t\t\t329\r\n#define APEL_LUMP_END\t\t\t340\r\n#define PEAS_LUMP_START\t\t\t341\r\n#define PEAS_LUMP_END\t\t\t358\r\n#define BOOBUS_LUMP_START\t\t359\r\n#define BOOBUS_LUMP_END\t\t\t367\r\n\r\n//\r\n// Amount of each data item\r\n//\r\n#define NUMCHUNKS    3016\r\n#define NUMFONT      1\r\n#define NUMFONTM     0\r\n#define NUMPICS      65\r\n#define NUMPICM      2\r\n#define NUMSPRITES   297\r\n#define NUMTILE8     72\r\n#define NUMTILE8M    36\r\n#define NUMTILE16    1440\r\n#define NUMTILE16M   1206\r\n#define NUMTILE32    0\r\n#define NUMTILE32M   0\r\n//\r\n// File offsets for data items\r\n//\r\n#define STRUCTPIC    0\r\n#define STRUCTPICM   1\r\n#define STRUCTSPRITE 2\r\n\r\n#define STARTFONT    3\r\n#define STARTFONTM   4\r\n#define STARTPICS    4\r\n#define STARTPICM    69\r\n#define STARTSPRITES 71\r\n#define STARTTILE8   368\r\n#define STARTTILE8M  369\r\n#define STARTTILE16  370\r\n#define STARTTILE16M 1810\r\n#define STARTTILE32  3016\r\n#define STARTTILE32M 3016\r\n\r\n//\r\n// Thank you for using IGRAB!\r\n//\r\n"
        },
        {
          "name": "id_asm.equ",
          "type": "blob",
          "size": 1.673828125,
          "content": "\r\nINCLUDE\t\"GRAPHKDR.EQU\"\r\n\r\n\r\nCGAGR\t\t=\t1\r\nEGAGR\t\t=\t2\r\nVGAGR\t\t=\t3\r\n\r\nGRMODE\t\t=\tEGAGR\r\nPROFILE\t\t=\t0\t\t\t; 1=keep stats on tile drawing\r\n\r\nSC_INDEX\t=\t03C4h\r\nSC_RESET\t=\t0\r\nSC_CLOCK\t=\t1\r\nSC_MAPMASK\t=\t2\r\nSC_CHARMAP\t=\t3\r\nSC_MEMMODE\t=\t4\r\n\r\nCRTC_INDEX\t=\t03D4h\r\nCRTC_H_TOTAL\t=\t0\r\nCRTC_H_DISPEND\t=\t1\r\nCRTC_H_BLANK\t=\t2\r\nCRTC_H_ENDBLANK\t=\t3\r\nCRTC_H_RETRACE\t=\t4\r\nCRTC_H_ENDRETRACE =\t5\r\nCRTC_V_TOTAL\t=\t6\r\nCRTC_OVERFLOW\t=\t7\r\nCRTC_ROWSCAN\t=\t8\r\nCRTC_MAXSCANLINE =\t9\r\nCRTC_CURSORSTART =\t10\r\nCRTC_CURSOREND\t=\t11\r\nCRTC_STARTHIGH\t=\t12\r\nCRTC_STARTLOW\t=\t13\r\nCRTC_CURSORHIGH\t=\t14\r\nCRTC_CURSORLOW\t=\t15\r\nCRTC_V_RETRACE\t=\t16\r\nCRTC_V_ENDRETRACE =\t17\r\nCRTC_V_DISPEND\t=\t18\r\nCRTC_OFFSET\t=\t19\r\nCRTC_UNDERLINE\t=\t20\r\nCRTC_V_BLANK\t=\t21\r\nCRTC_V_ENDBLANK\t=\t22\r\nCRTC_MODE\t=\t23\r\nCRTC_LINECOMPARE =\t24\r\n\r\n\r\nGC_INDEX\t=\t03CEh\r\nGC_SETRESET\t=\t0\r\nGC_ENABLESETRESET =\t1\r\nGC_COLORCOMPARE\t=\t2\r\nGC_DATAROTATE\t=\t3\r\nGC_READMAP\t=\t4\r\nGC_MODE\t\t=\t5\r\nGC_MISCELLANEOUS =\t6\r\nGC_COLORDONTCARE =\t7\r\nGC_BITMASK\t=\t8\r\n\r\nATR_INDEX\t=\t03c0h\r\nATR_MODE\t=\t16\r\nATR_OVERSCAN\t=\t17\r\nATR_COLORPLANEENABLE =\t18\r\nATR_PELPAN\t=\t19\r\nATR_COLORSELECT\t=\t20\r\n\r\nSTATUS_REGISTER_1     =\t03dah\r\n\r\n\r\nMACRO\tWORDOUT\r\n\tout\tdx,ax\r\nENDM\r\n\r\nif 0\r\n\r\nMACRO\tWORDOUT\r\n\tout\tdx,al\r\n\tinc\tdx\r\n\txchg\tal,ah\r\n\tout\tdx,al\r\n\tdec\tdx\r\n\txchg\tal,ah\r\nENDM\r\n\r\nendif\r\n\r\nUPDATEWIDE\t=\t22\r\nUPDATEHIGH\t=\t14\r\n\r\n;\r\n; tile info offsets from segment tinf\r\n;\r\n\r\nSPEED\t\t=\t502\r\nANIM\t\t=\t(SPEED+NUMTILE16)\r\n\r\nNORTHWALL\t=\t(ANIM+NUMTILE16)\r\nEASTWALL\t=\t(NORTHWALL+NUMTILE16M)\r\nSOUTHWALL   =\t(EASTWALL+NUMTILE16M)\r\nWESTWALL    =\t(SOUTHWALL+NUMTILE16M)\r\nMANIM       =\t(WESTWALL+NUMTILE16M)\r\nINTILE      =\t(MANIM+NUMTILE16M)\r\nMSPEED      =\t(INTILE+NUMTILE16M)\r\n\r\nIFE GRMODE-EGAGR\r\nSCREENWIDTH\t=\t64\r\nENDIF\r\nIFE GRMODE-CGAGR\r\nSCREENWIDTH\t=\t128\r\nENDIF\r\n"
        },
        {
          "name": "id_ca.c",
          "type": "blob",
          "size": 37.1767578125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_CA.C\r\n\r\n/*\r\n=============================================================================\r\n\r\nId Software Caching Manager\r\n---------------------------\r\n\r\nMust be started BEFORE the memory manager, because it needs to get the headers\r\nloaded into the data segment\r\n\r\n=============================================================================\r\n*/\r\n\r\n#include \"ID_HEADS.H\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\ntypedef struct\r\n{\r\n  unsigned bit0,bit1;\t// 0-255 is a character, > is a pointer to a node\r\n} huffnode;\r\n\r\n\r\ntypedef struct\r\n{\r\n\tunsigned\tRLEWtag;\r\n\tlong\t\theaderoffsets[100];\r\n\tbyte\t\theadersize[100];\t\t// headers are very small\r\n\tbyte\t\ttileinfo[];\r\n} mapfiletype;\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nbyte \t\t_seg\t*tinf;\r\nint\t\t\tmapon;\r\n\r\nunsigned\t_seg\t*mapsegs[3];\r\nmaptype\t\t_seg\t*mapheaderseg[NUMMAPS];\r\nbyte\t\t_seg\t*audiosegs[NUMSNDCHUNKS];\r\nvoid\t\t_seg\t*grsegs[NUMCHUNKS];\r\n\r\nbyte\t\tgrneeded[NUMCHUNKS];\r\nbyte\t\tca_levelbit,ca_levelnum;\r\n\r\nchar\t\t*titleptr[8];\r\n\r\nint\t\t\tprofilehandle;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern\tlong\tfar\tCGAhead;\r\nextern\tlong\tfar\tEGAhead;\r\nextern\tbyte\tCGAdict;\r\nextern\tbyte\tEGAdict;\r\nextern\tbyte\tfar\tmaphead;\r\nextern\tbyte\tmapdict;\r\nextern\tbyte\tfar\taudiohead;\r\nextern\tbyte\taudiodict;\r\n\r\n\r\nlong\t\t_seg *grstarts;\t// array of offsets in egagraph, -1 for sparse\r\nlong\t\t_seg *audiostarts;\t// array of offsets in audio / audiot\r\n\r\n#ifdef GRHEADERLINKED\r\nhuffnode\t*grhuffman;\r\n#else\r\nhuffnode\tgrhuffman[255];\r\n#endif\r\n\r\n#ifdef MAPHEADERLINKED\r\nhuffnode\t*maphuffman;\r\n#else\r\nhuffnode\tmaphuffman[255];\r\n#endif\r\n\r\n#ifdef AUDIOHEADERLINKED\r\nhuffnode\t*audiohuffman;\r\n#else\r\nhuffnode\taudiohuffman[255];\r\n#endif\r\n\r\n\r\nint\t\t\tgrhandle;\t\t// handle to EGAGRAPH\r\nint\t\t\tmaphandle;\t\t// handle to MAPTEMP / GAMEMAPS\r\nint\t\t\taudiohandle;\t// handle to AUDIOT / AUDIO\r\n\r\nlong\t\tchunkcomplen,chunkexplen;\r\n\r\nSDMode\t\toldsoundmode;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t   LOW LEVEL ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n============================\r\n=\r\n= CAL_GetGrChunkLength\r\n=\r\n= Gets the length of an explicit length chunk (not tiles)\r\n= The file pointer is positioned so the compressed data can be read in next.\r\n=\r\n============================\r\n*/\r\n\r\nvoid CAL_GetGrChunkLength (int chunk)\r\n{\r\n\tlseek(grhandle,grstarts[chunk],SEEK_SET);\r\n\tread(grhandle,&chunkexplen,sizeof(chunkexplen));\r\n\tchunkcomplen = grstarts[chunk+1]-grstarts[chunk]-4;\r\n}\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= CA_FarRead\r\n=\r\n= Read from a file to a far pointer\r\n=\r\n==========================\r\n*/\r\n\r\nboolean CA_FarRead (int handle, byte far *dest, long length)\r\n{\r\n\tif (length>0xffffl)\r\n\t\tQuit (\"CA_FarRead doesn't support 64K reads yet!\");\r\n\r\nasm\t\tpush\tds\r\nasm\t\tmov\tbx,[handle]\r\nasm\t\tmov\tcx,[WORD PTR length]\r\nasm\t\tmov\tdx,[WORD PTR dest]\r\nasm\t\tmov\tds,[WORD PTR dest+2]\r\nasm\t\tmov\tah,0x3f\t\t\t\t// READ w/handle\r\nasm\t\tint\t21h\r\nasm\t\tpop\tds\r\nasm\t\tjnc\tgood\r\n\terrno = _AX;\r\n\treturn\tfalse;\r\ngood:\r\nasm\t\tcmp\tax,[WORD PTR length]\r\nasm\t\tje\tdone\r\n\terrno = EINVFMT;\t\t\t// user manager knows this is bad read\r\n\treturn\tfalse;\r\ndone:\r\n\treturn\ttrue;\r\n}\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= CA_SegWrite\r\n=\r\n= Write from a file to a far pointer\r\n=\r\n==========================\r\n*/\r\n\r\nboolean CA_FarWrite (int handle, byte far *source, long length)\r\n{\r\n\tif (length>0xffffl)\r\n\t\tQuit (\"CA_FarWrite doesn't support 64K reads yet!\");\r\n\r\nasm\t\tpush\tds\r\nasm\t\tmov\tbx,[handle]\r\nasm\t\tmov\tcx,[WORD PTR length]\r\nasm\t\tmov\tdx,[WORD PTR source]\r\nasm\t\tmov\tds,[WORD PTR source+2]\r\nasm\t\tmov\tah,0x40\t\t\t// WRITE w/handle\r\nasm\t\tint\t21h\r\nasm\t\tpop\tds\r\nasm\t\tjnc\tgood\r\n\terrno = _AX;\r\n\treturn\tfalse;\r\ngood:\r\nasm\t\tcmp\tax,[WORD PTR length]\r\nasm\t\tje\tdone\r\n\terrno = ENOMEM;\t\t\t\t// user manager knows this is bad write\r\n\treturn\tfalse;\r\n\r\ndone:\r\n\treturn\ttrue;\r\n}\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= CA_LoadFile\r\n=\r\n= Allocate space for and load a file\r\n=\r\n==========================\r\n*/\r\n\r\nboolean CA_LoadFile (char *filename, memptr *ptr)\r\n{\r\n\tint handle;\r\n\tlong size;\r\n\r\n\tif ((handle = open(filename,O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\treturn false;\r\n\r\n\tsize = filelength (handle);\r\n\tMM_GetPtr (ptr,size);\r\n\tif (!CA_FarRead (handle,*ptr,size))\r\n\t{\r\n\t\tclose (handle);\r\n\t\treturn false;\r\n\t}\r\n\tclose (handle);\r\n\treturn true;\r\n}\r\n\r\n/*\r\n============================================================================\r\n\r\n\t\tCOMPRESSION routines, see JHUFF.C for more\r\n\r\n============================================================================\r\n*/\r\n\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= CAL_OptimizeNodes\r\n=\r\n= Goes through a huffman table and changes the 256-511 node numbers to the\r\n= actular address of the node.  Must be called before CAL_HuffExpand\r\n=\r\n===============\r\n*/\r\n\r\nvoid CAL_OptimizeNodes (huffnode *table)\r\n{\r\n  huffnode *node;\r\n  int i;\r\n\r\n  node = table;\r\n\r\n  for (i=0;i<255;i++)\r\n  {\r\n\tif (node->bit0 >= 256)\r\n\t  node->bit0 = (unsigned)(table+(node->bit0-256));\r\n\tif (node->bit1 >= 256)\r\n\t  node->bit1 = (unsigned)(table+(node->bit1-256));\r\n\tnode++;\r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_HuffExpand\r\n=\r\n= Length is the length of the EXPANDED data\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_HuffExpand (byte huge *source, byte huge *dest,\r\n  long length,huffnode *hufftable)\r\n{\r\n  unsigned bit,byte,node,code;\r\n  unsigned sourceseg,sourceoff,destseg,destoff,endoff;\r\n  huffnode *nodeon,*headptr;\r\n\r\n  headptr = hufftable+254;\t// head node is allways node 254\r\n\r\n  source++;\t// normalize\r\n  source--;\r\n  dest++;\r\n  dest--;\r\n\r\n  sourceseg = FP_SEG(source);\r\n  sourceoff = FP_OFF(source);\r\n  destseg = FP_SEG(dest);\r\n  destoff = FP_OFF(dest);\r\n  endoff = destoff+length;\r\n\r\n//\r\n// ds:si source\r\n// es:di dest\r\n// ss:bx node pointer\r\n//\r\n\r\n\tif (length <0xfff0)\r\n\t{\r\n\r\n//--------------------------\r\n// expand less than 64k of data\r\n//--------------------------\r\n\r\nasm mov\tbx,[headptr]\r\n\r\nasm\tmov\tsi,[sourceoff]\r\nasm\tmov\tdi,[destoff]\r\nasm\tmov\tes,[destseg]\r\nasm\tmov\tds,[sourceseg]\r\nasm\tmov\tax,[endoff]\r\n\r\nasm\tmov\tch,[si]\t\t\t\t// load first byte\r\nasm\tinc\tsi\r\nasm\tmov\tcl,1\r\n\r\nexpandshort:\r\nasm\ttest\tch,cl\t\t\t// bit set?\r\nasm\tjnz\tbit1short\r\nasm\tmov\tdx,[ss:bx]\t\t\t// take bit0 path from node\r\nasm\tshl\tcl,1\t\t\t\t// advance to next bit position\r\nasm\tjc\tnewbyteshort\r\nasm\tjnc\tsourceupshort\r\n\r\nbit1short:\r\nasm\tmov\tdx,[ss:bx+2]\t\t// take bit1 path\r\nasm\tshl\tcl,1\t\t\t\t// advance to next bit position\r\nasm\tjnc\tsourceupshort\r\n\r\nnewbyteshort:\r\nasm\tmov\tch,[si]\t\t\t\t// load next byte\r\nasm\tinc\tsi\r\nasm\tmov\tcl,1\t\t\t\t// back to first bit\r\n\r\nsourceupshort:\r\nasm\tor\tdh,dh\t\t\t\t// if dx<256 its a byte, else move node\r\nasm\tjz\tstorebyteshort\r\nasm\tmov\tbx,dx\t\t\t\t// next node = (huffnode *)code\r\nasm\tjmp\texpandshort\r\n\r\nstorebyteshort:\r\nasm\tmov\t[es:di],dl\r\nasm\tinc\tdi\t\t\t\t\t// write a decopmpressed byte out\r\nasm\tmov\tbx,[headptr]\t\t// back to the head node for next bit\r\n\r\nasm\tcmp\tdi,ax\t\t\t\t// done?\r\nasm\tjne\texpandshort\r\n\t}\r\n\telse\r\n\t{\r\n\r\n//--------------------------\r\n// expand more than 64k of data\r\n//--------------------------\r\n\r\n  length--;\r\n\r\nasm mov\tbx,[headptr]\r\nasm\tmov\tcl,1\r\n\r\nasm\tmov\tsi,[sourceoff]\r\nasm\tmov\tdi,[destoff]\r\nasm\tmov\tes,[destseg]\r\nasm\tmov\tds,[sourceseg]\r\n\r\nasm\tlodsb\t\t\t// load first byte\r\n\r\nexpand:\r\nasm\ttest\tal,cl\t\t// bit set?\r\nasm\tjnz\tbit1\r\nasm\tmov\tdx,[ss:bx]\t// take bit0 path from node\r\nasm\tjmp\tgotcode\r\nbit1:\r\nasm\tmov\tdx,[ss:bx+2]\t// take bit1 path\r\n\r\ngotcode:\r\nasm\tshl\tcl,1\t\t// advance to next bit position\r\nasm\tjnc\tsourceup\r\nasm\tlodsb\r\nasm\tcmp\tsi,0x10\t\t// normalize ds:si\r\nasm  \tjb\tsinorm\r\nasm\tmov\tcx,ds\r\nasm\tinc\tcx\r\nasm\tmov\tds,cx\r\nasm\txor\tsi,si\r\nsinorm:\r\nasm\tmov\tcl,1\t\t// back to first bit\r\n\r\nsourceup:\r\nasm\tor\tdh,dh\t\t// if dx<256 its a byte, else move node\r\nasm\tjz\tstorebyte\r\nasm\tmov\tbx,dx\t\t// next node = (huffnode *)code\r\nasm\tjmp\texpand\r\n\r\nstorebyte:\r\nasm\tmov\t[es:di],dl\r\nasm\tinc\tdi\t\t// write a decopmpressed byte out\r\nasm\tmov\tbx,[headptr]\t// back to the head node for next bit\r\n\r\nasm\tcmp\tdi,0x10\t\t// normalize es:di\r\nasm  \tjb\tdinorm\r\nasm\tmov\tdx,es\r\nasm\tinc\tdx\r\nasm\tmov\tes,dx\r\nasm\txor\tdi,di\r\ndinorm:\r\n\r\nasm\tsub\t[WORD PTR ss:length],1\r\nasm\tjnc\texpand\r\nasm  \tdec\t[WORD PTR ss:length+2]\r\nasm\tjns\texpand\t\t// when length = ffff ffff, done\r\n\r\n\t}\r\n\r\nasm\tmov\tax,ss\r\nasm\tmov\tds,ax\r\n\r\n}\r\n\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_RLEWcompress\r\n=\r\n======================\r\n*/\r\n\r\nlong CA_RLEWCompress (unsigned huge *source, long length, unsigned huge *dest,\r\n  unsigned rlewtag)\r\n{\r\n  long complength;\r\n  unsigned value,count,i;\r\n  unsigned huge *start,huge *end;\r\n\r\n  start = dest;\r\n\r\n  end = source + (length+1)/2;\r\n\r\n//\r\n// compress it\r\n//\r\n  do\r\n  {\r\n    count = 1;\r\n    value = *source++;\r\n    while (*source == value && source<end)\r\n    {\r\n      count++;\r\n      source++;\r\n    }\r\n    if (count>3 || value == rlewtag)\r\n    {\r\n    //\r\n    // send a tag / count / value string\r\n    //\r\n      *dest++ = rlewtag;\r\n      *dest++ = count;\r\n      *dest++ = value;\r\n    }\r\n    else\r\n    {\r\n    //\r\n    // send word without compressing\r\n    //\r\n      for (i=1;i<=count;i++)\r\n\t*dest++ = value;\r\n\t}\r\n\r\n  } while (source<end);\r\n\r\n  complength = 2*(dest-start);\r\n  return complength;\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_RLEWexpand\r\n= length is COMPRESSED length\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_RLEWexpand (unsigned huge *source, unsigned huge *dest,long length,\r\n  unsigned rlewtag)\r\n{\r\n  unsigned value,count,i;\r\n  unsigned huge *end;\r\n  unsigned sourceseg,sourceoff,destseg,destoff,endseg,endoff;\r\n\r\n\r\n//\r\n// expand it\r\n//\r\n#if 0\r\n  do\r\n  {\r\n\tvalue = *source++;\r\n\tif (value != rlewtag)\r\n\t//\r\n\t// uncompressed\r\n\t//\r\n\t  *dest++=value;\r\n\telse\r\n\t{\r\n\t//\r\n\t// compressed string\r\n\t//\r\n\t  count = *source++;\r\n\t  value = *source++;\r\n\t  for (i=1;i<=count;i++)\r\n\t*dest++ = value;\r\n\t}\r\n  } while (dest<end);\r\n#endif\r\n\r\n  end = dest + (length)/2;\r\n  sourceseg = FP_SEG(source);\r\n  sourceoff = FP_OFF(source);\r\n  destseg = FP_SEG(dest);\r\n  destoff = FP_OFF(dest);\r\n  endseg = FP_SEG(end);\r\n  endoff = FP_OFF(end);\r\n\r\n\r\n//\r\n// ax = source value\r\n// bx = tag value\r\n// cx = repeat counts\r\n// dx = scratch\r\n//\r\n// NOTE: A repeat count that produces 0xfff0 bytes can blow this!\r\n//\r\n\r\nasm\tmov\tbx,rlewtag\r\nasm\tmov\tsi,sourceoff\r\nasm\tmov\tdi,destoff\r\nasm\tmov\tes,destseg\r\nasm\tmov\tds,sourceseg\r\n\r\nexpand:\r\nasm\tlodsw\r\nasm\tcmp\tax,bx\r\nasm\tje\trepeat\r\nasm\tstosw\r\nasm\tjmp\tnext\r\n\r\nrepeat:\r\nasm\tlodsw\r\nasm\tmov\tcx,ax\t\t// repeat count\r\nasm\tlodsw\t\t\t// repeat value\r\nasm\trep stosw\r\n\r\nnext:\r\n\r\nasm\tcmp\tsi,0x10\t\t// normalize ds:si\r\nasm  \tjb\tsinorm\r\nasm\tmov\tax,si\r\nasm\tshr\tax,1\r\nasm\tshr\tax,1\r\nasm\tshr\tax,1\r\nasm\tshr\tax,1\r\nasm\tmov\tdx,ds\r\nasm\tadd\tdx,ax\r\nasm\tmov\tds,dx\r\nasm\tand\tsi,0xf\r\nsinorm:\r\nasm\tcmp\tdi,0x10\t\t// normalize es:di\r\nasm  \tjb\tdinorm\r\nasm\tmov\tax,di\r\nasm\tshr\tax,1\r\nasm\tshr\tax,1\r\nasm\tshr\tax,1\r\nasm\tshr\tax,1\r\nasm\tmov\tdx,es\r\nasm\tadd\tdx,ax\r\nasm\tmov\tes,dx\r\nasm\tand\tdi,0xf\r\ndinorm:\r\n\r\nasm\tcmp     di,ss:endoff\r\nasm\tjne\texpand\r\nasm\tmov\tax,es\r\nasm\tcmp\tax,ss:endseg\r\nasm\tjb\texpand\r\n\r\nasm\tmov\tax,ss\r\nasm\tmov\tds,ax\r\n\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t CACHE MANAGER ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_SetupGrFile\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_SetupGrFile (void)\r\n{\r\n\tint handle;\r\n\tlong headersize,length;\r\n\tmemptr compseg;\r\n\r\n#ifdef GRHEADERLINKED\r\n\r\n#if GRMODE == EGAGR\r\n\tgrhuffman = (huffnode *)&EGAdict;\r\n\tgrstarts = (long _seg *)FP_SEG(&EGAhead);\r\n#endif\r\n#if GRMODE == CGAGR\r\n\tgrhuffman = (huffnode *)&CGAdict;\r\n\tgrstarts = (long _seg *)FP_SEG(&CGAhead);\r\n#endif\r\n\r\n\tCAL_OptimizeNodes (grhuffman);\r\n\r\n#else\r\n\r\n//\r\n// load ???dict.ext (huffman dictionary for graphics files)\r\n//\r\n\r\n//\tif ((handle = open(GREXT\"DICT.\",\r\n\tif ((handle = open(\"KDREAMS.EGA\",\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open KDREAMS.EGA!\");\r\n\r\n\tread(handle, &grhuffman, sizeof(grhuffman));\r\n\tclose(handle);\r\n\tCAL_OptimizeNodes (grhuffman);\r\n//\r\n// load the data offsets from ???head.ext\r\n//\r\n\tMM_GetPtr (&(memptr)grstarts,(NUMCHUNKS+1)*4);\r\n\r\n\tif ((handle = open(GREXT\"HEAD.\"EXTENSION,\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open \"GREXT\"HEAD.\"EXTENSION\"!\");\r\n\r\n\tCA_FarRead(handle, (memptr)grstarts, (NUMCHUNKS+1)*4);\r\n\r\n\tclose(handle);\r\n\r\n\r\n#endif\r\n\r\n//\r\n// Open the graphics file, leaving it open until the game is finished\r\n//\r\n//\tgrhandle = open(GREXT\"GRAPH.\"EXTENSION, O_RDONLY | O_BINARY); NOLAN\r\n\tgrhandle = open(\"KDREAMS.EGA\", O_RDONLY | O_BINARY);\r\n\tif (grhandle == -1)\r\n\t\tQuit (\"Cannot open KDREAMS.EGA!\");\r\n\r\n\r\n//\r\n// load the pic and sprite headers into the arrays in the data segment\r\n//\r\n#if NUMPICS>0\r\n\tMM_GetPtr(&(memptr)pictable,NUMPICS*sizeof(pictabletype));\r\n\tCAL_GetGrChunkLength(STRUCTPIC);\t\t// position file pointer\r\n\tMM_GetPtr(&compseg,chunkcomplen);\r\n\tCA_FarRead (grhandle,compseg,chunkcomplen);\r\n\tCAL_HuffExpand (compseg, (byte huge *)pictable,NUMPICS*sizeof(pictabletype),grhuffman);\r\n\tMM_FreePtr(&compseg);\r\n#endif\r\n\r\n#if NUMPICM>0\r\n\tMM_GetPtr(&(memptr)picmtable,NUMPICM*sizeof(pictabletype));\r\n\tCAL_GetGrChunkLength(STRUCTPICM);\t\t// position file pointer\r\n\tMM_GetPtr(&compseg,chunkcomplen);\r\n\tCA_FarRead (grhandle,compseg,chunkcomplen);\r\n\tCAL_HuffExpand (compseg, (byte huge *)picmtable,NUMPICS*sizeof(pictabletype),grhuffman);\r\n\tMM_FreePtr(&compseg);\r\n#endif\r\n\r\n#if NUMSPRITES>0\r\n\tMM_GetPtr(&(memptr)spritetable,NUMSPRITES*sizeof(spritetabletype));\r\n\tCAL_GetGrChunkLength(STRUCTSPRITE);\t// position file pointer\r\n\tMM_GetPtr(&compseg,chunkcomplen);\r\n\tCA_FarRead (grhandle,compseg,chunkcomplen);\r\n\tCAL_HuffExpand (compseg, (byte huge *)spritetable,NUMSPRITES*sizeof(spritetabletype),grhuffman);\r\n\tMM_FreePtr(&compseg);\r\n#endif\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_SetupMapFile\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_SetupMapFile (void)\r\n{\r\n\tint handle,i;\r\n\tlong length;\r\n\tbyte far *buffer;\r\n\r\n//\r\n// load maphead.ext (offsets and tileinfo for map file)\r\n//\r\n#ifndef MAPHEADERLINKED\r\n//\tif ((handle = open(\"MAPHEAD.\"EXTENSION,\r\n\tif ((handle = open(\"KDREAMS.MAP\",\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open KDREAMS.MAP!\");\r\n\tlength = filelength(handle);\r\n\tMM_GetPtr (&(memptr)tinf,length);\r\n\tCA_FarRead(handle, tinf, length);\r\n\tclose(handle);\r\n#else\r\n\r\n\tmaphuffman = (huffnode *)&mapdict;\r\n\tCAL_OptimizeNodes (maphuffman);\r\n\ttinf = (byte _seg *)FP_SEG(&maphead);\r\n\r\n#endif\r\n\r\n//\r\n// open the data file\r\n//\r\n#ifdef MAPHEADERLINKED\r\n\tif ((maphandle = open(\"KDREAMS.MAP\",\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open KDREAMS.MAP!\");\r\n#else\r\n\tif ((maphandle = open(\"MAPTEMP.\"EXTENSION,\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open MAPTEMP.\"EXTENSION\"!\");\r\n#endif\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_SetupAudioFile\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_SetupAudioFile (void)\r\n{\r\n\tint handle,i;\r\n\tlong length;\r\n\tbyte far *buffer;\r\n\r\n//\r\n// load maphead.ext (offsets and tileinfo for map file)\r\n//\r\n#ifndef AUDIOHEADERLINKED\r\n\tif ((handle = open(\"AUDIOHED.\"EXTENSION,\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open AUDIOHED.\"EXTENSION\"!\");\r\n\tlength = filelength(handle);\r\n\tMM_GetPtr (&(memptr)audiostarts,length);\r\n\tCA_FarRead(handle, (byte far *)audiostarts, length);\r\n\tclose(handle);\r\n#else\r\n\taudiohuffman = (huffnode *)&audiodict;\r\n\tCAL_OptimizeNodes (audiohuffman);\r\n\taudiostarts = (long _seg *)FP_SEG(&audiohead);\r\n#endif\r\n\r\n//\r\n// open the data file\r\n//\r\n#ifndef AUDIOHEADERLINKED\r\n\tif ((audiohandle = open(\"AUDIOT.\"EXTENSION,\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open AUDIOT.\"EXTENSION\"!\");\r\n#else\r\n//\tif ((audiohandle = open(\"AUDIO.\"EXTENSION,\tNOLAN\r\n\tif ((audiohandle = open(\"KDREAMS.AUD\",\r\n\t\t O_RDONLY | O_BINARY, S_IREAD)) == -1)\r\n\t\tQuit (\"Can't open KDREAMS.AUD!\");\r\n#endif\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_Startup\r\n=\r\n= Open all files and load in headers\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_Startup (void)\r\n{\r\n#ifdef PROFILE\r\n\tunlink (\"PROFILE.TXT\");\r\n\tprofilehandle = open(\"PROFILE.TXT\", O_CREAT | O_WRONLY | O_TEXT);\r\n#endif\r\n\r\n\tCAL_SetupMapFile ();\r\n\tCAL_SetupGrFile ();\r\n\tCAL_SetupAudioFile ();\r\n\r\n\tmapon = -1;\r\n\tca_levelbit = 1;\r\n\tca_levelnum = 0;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_Shutdown\r\n=\r\n= Closes all files\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_Shutdown (void)\r\n{\r\n#ifdef PROFILE\r\n\tclose (profilehandle);\r\n#endif\r\n\r\n\tclose (maphandle);\r\n\tclose (grhandle);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheAudioChunk\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_CacheAudioChunk (int chunk)\r\n{\r\n\tlong\tpos,compressed,expanded;\r\n\tmemptr\tbigbufferseg;\r\n\tbyte\tfar *source;\r\n\r\n\tif (audiosegs[chunk])\r\n\t{\r\n\t\tMM_SetPurge (&(memptr)audiosegs[chunk],0);\r\n\t\treturn;\t\t\t\t\t\t\t// allready in memory\r\n\t}\r\n\r\n//\r\n// load the chunk into a buffer, either the miscbuffer if it fits, or allocate\r\n// a larger buffer\r\n//\r\n\tpos = audiostarts[chunk];\r\n\tcompressed = audiostarts[chunk+1]-pos;\r\n\r\n\tlseek(audiohandle,pos,SEEK_SET);\r\n\r\n#ifndef AUDIOHEADERLINKED\r\n\r\n\tMM_GetPtr (&(memptr)audiosegs[chunk],compressed);\r\n\tCA_FarRead(audiohandle,audiosegs[chunk],compressed);\r\n\r\n#else\r\n\r\n\tif (compressed<=BUFFERSIZE)\r\n\t{\r\n\t\tCA_FarRead(audiohandle,bufferseg,compressed);\r\n\t\tsource = bufferseg;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMM_GetPtr(&bigbufferseg,compressed);\r\n\t\tCA_FarRead(audiohandle,bigbufferseg,compressed);\r\n\t\tsource = bigbufferseg;\r\n\t}\r\n\r\n\texpanded = *(long far *)source;\r\n\tsource += 4;\t\t\t// skip over length\r\n\tMM_GetPtr (&(memptr)audiosegs[chunk],expanded);\r\n\tCAL_HuffExpand (source,audiosegs[chunk],expanded,audiohuffman);\r\n\r\n\tif (compressed>BUFFERSIZE)\r\n\t\tMM_FreePtr(&bigbufferseg);\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_LoadAllSounds\r\n=\r\n= Purges all sounds, then loads all new ones (mode switch)\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_LoadAllSounds (void)\r\n{\r\n\tunsigned\tstart,i;\r\n\r\n\tswitch (oldsoundmode)\r\n\t{\r\n\tcase sdm_Off:\r\n\t\tgoto cachein;\r\n\tcase sdm_PC:\r\n\t\tstart = STARTPCSOUNDS;\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tstart = STARTADLIBSOUNDS;\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\tcase sdm_SoundSource:\r\n\t\tstart = STARTDIGISOUNDS;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tfor (i=0;i<NUMSOUNDS;i++,start++)\r\n\t\tif (audiosegs[start])\r\n\t\t\tMM_SetPurge (&(memptr)audiosegs[start],3);\t\t// make purgable\r\n\r\ncachein:\r\n\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_Off:\r\n\t\treturn;\r\n\tcase sdm_PC:\r\n\t\tstart = STARTPCSOUNDS;\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tstart = STARTADLIBSOUNDS;\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\tcase sdm_SoundSource:\r\n\t\tstart = STARTDIGISOUNDS;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tfor (i=0;i<NUMSOUNDS;i++,start++)\r\n\t\tCA_CacheAudioChunk (start);\r\n\r\n\toldsoundmode = SoundMode;\r\n}\r\n\r\n//===========================================================================\r\n\r\n#if GRMODE == EGAGR\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_ShiftSprite\r\n=\r\n= Make a shifted (one byte wider) copy of a sprite into another area\r\n=\r\n======================\r\n*/\r\n\r\nunsigned\tstatic\tsheight,swidth;\r\n\r\nvoid CAL_ShiftSprite (unsigned segment,unsigned source,unsigned dest,\r\n\tunsigned width, unsigned height, unsigned pixshift)\r\n{\r\n\r\n\tsheight = height;\t\t// because we are going to reassign bp\r\n\tswidth = width;\r\n\r\nasm\tmov\tax,[segment]\r\nasm\tmov\tds,ax\t\t// source and dest are in same segment, and all local\r\n\r\nasm\tmov\tbx,[source]\r\nasm\tmov\tdi,[dest]\r\n\r\nasm\tmov\tbp,[pixshift]\r\nasm\tshl\tbp,1\r\nasm\tmov\tbp,[shifttabletable+bp]\t// bp holds pointer to shift table\r\n\r\n//\r\n// table shift the mask\r\n//\r\nasm\tmov\tdx,[ss:sheight]\r\n\r\ndomaskrow:\r\n\r\nasm\tmov\tBYTE PTR [di],255\t// 0xff first byte\r\nasm\tmov\tcx,ss:[swidth]\r\n\r\ndomaskbyte:\r\n\r\nasm\tmov\tal,[bx]\t\t\t\t// source\r\nasm\tnot\tal\r\nasm\tinc\tbx\t\t\t\t\t// next source byte\r\nasm\txor\tah,ah\r\nasm\tshl\tax,1\r\nasm\tmov\tsi,ax\r\nasm\tmov\tax,[bp+si]\t\t\t// table shift into two bytes\r\nasm\tnot\tax\r\nasm\tand\t[di],al\t\t\t\t// and with first byte\r\nasm\tinc\tdi\r\nasm\tmov\t[di],ah\t\t\t\t// replace next byte\r\n\r\nasm\tloop\tdomaskbyte\r\n\r\nasm\tinc\tdi\t\t\t\t\t// the last shifted byte has 1s in it\r\nasm\tdec\tdx\r\nasm\tjnz\tdomaskrow\r\n\r\n//\r\n// table shift the data\r\n//\r\nasm\tmov\tdx,ss:[sheight]\r\nasm\tshl\tdx,1\r\nasm\tshl\tdx,1\t\t\t\t// four planes of data\r\n\r\ndodatarow:\r\n\r\nasm\tmov\tBYTE PTR [di],0\t\t// 0 first byte\r\nasm\tmov\tcx,ss:[swidth]\r\n\r\ndodatabyte:\r\n\r\nasm\tmov\tal,[bx]\t\t\t\t// source\r\nasm\tinc\tbx\t\t\t\t\t// next source byte\r\nasm\txor\tah,ah\r\nasm\tshl\tax,1\r\nasm\tmov\tsi,ax\r\nasm\tmov\tax,[bp+si]\t\t\t// table shift into two bytes\r\nasm\tor\t[di],al\t\t\t\t// or with first byte\r\nasm\tinc\tdi\r\nasm\tmov\t[di],ah\t\t\t\t// replace next byte\r\n\r\nasm\tloop\tdodatabyte\r\n\r\nasm\tinc\tdi\t\t\t\t\t// the last shifted byte has 0s in it\r\nasm\tdec\tdx\r\nasm\tjnz\tdodatarow\r\n\r\n//\r\n// done\r\n//\r\n\r\nasm\tmov\tax,ss\t\t\t\t// restore data segment\r\nasm\tmov\tds,ax\r\n\r\n}\r\n\r\n#endif\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_CacheSprite\r\n=\r\n= Generate shifts and set up sprite structure for a given sprite\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_CacheSprite (int chunk, char far *compressed)\r\n{\r\n\tint i;\r\n\tunsigned shiftstarts[5];\r\n\tunsigned smallplane,bigplane,expanded;\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg *dest;\r\n\r\n#if GRMODE == CGAGR\r\n//\r\n// CGA has no pel panning, so shifts are never needed\r\n//\r\n\tspr = &spritetable[chunk-STARTSPRITES];\r\n\tsmallplane = spr->width*spr->height;\r\n\tMM_GetPtr (&grsegs[chunk],smallplane*2+MAXSHIFTS*6);\r\n\tdest = (spritetype _seg *)grsegs[chunk];\r\n\tdest->sourceoffset[0] = MAXSHIFTS*6;\t// start data after 3 unsigned tables\r\n\tdest->planesize[0] = smallplane;\r\n\tdest->width[0] = spr->width;\r\n\r\n//\r\n// expand the unshifted shape\r\n//\r\n\tCAL_HuffExpand (compressed, &dest->data[0],smallplane*2,grhuffman);\r\n\r\n#endif\r\n\r\n\r\n#if GRMODE == EGAGR\r\n\r\n//\r\n// calculate sizes\r\n//\r\n\tspr = &spritetable[chunk-STARTSPRITES];\r\n\tsmallplane = spr->width*spr->height;\r\n\tbigplane = (spr->width+1)*spr->height;\r\n\r\n\tshiftstarts[0] = MAXSHIFTS*6;\t// start data after 3 unsigned tables\r\n\tshiftstarts[1] = shiftstarts[0] + smallplane*5;\t// 5 planes in a sprite\r\n\tshiftstarts[2] = shiftstarts[1] + bigplane*5;\r\n\tshiftstarts[3] = shiftstarts[2] + bigplane*5;\r\n\tshiftstarts[4] = shiftstarts[3] + bigplane*5;\t// nothing ever put here\r\n\r\n\texpanded = shiftstarts[spr->shifts];\r\n\tMM_GetPtr (&grsegs[chunk],expanded);\r\n\tdest = (spritetype _seg *)grsegs[chunk];\r\n\r\n//\r\n// expand the unshifted shape\r\n//\r\n\tCAL_HuffExpand (compressed, &dest->data[0],smallplane*5,grhuffman);\r\n\r\n//\r\n// make the shifts!\r\n//\r\n\tswitch (spr->shifts)\r\n\t{\r\n\tcase\t1:\r\n\t\tfor (i=0;i<4;i++)\r\n\t\t{\r\n\t\t\tdest->sourceoffset[i] = shiftstarts[0];\r\n\t\t\tdest->planesize[i] = smallplane;\r\n\t\t\tdest->width[i] = spr->width;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase\t2:\r\n\t\tfor (i=0;i<2;i++)\r\n\t\t{\r\n\t\t\tdest->sourceoffset[i] = shiftstarts[0];\r\n\t\t\tdest->planesize[i] = smallplane;\r\n\t\t\tdest->width[i] = spr->width;\r\n\t\t}\r\n\t\tfor (i=2;i<4;i++)\r\n\t\t{\r\n\t\t\tdest->sourceoffset[i] = shiftstarts[1];\r\n\t\t\tdest->planesize[i] = bigplane;\r\n\t\t\tdest->width[i] = spr->width+1;\r\n\t\t}\r\n\t\tCAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],\r\n\t\t\tdest->sourceoffset[2],spr->width,spr->height,4);\r\n\t\tbreak;\r\n\r\n\tcase\t4:\r\n\t\tdest->sourceoffset[0] = shiftstarts[0];\r\n\t\tdest->planesize[0] = smallplane;\r\n\t\tdest->width[0] = spr->width;\r\n\r\n\t\tdest->sourceoffset[1] = shiftstarts[1];\r\n\t\tdest->planesize[1] = bigplane;\r\n\t\tdest->width[1] = spr->width+1;\r\n\t\tCAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],\r\n\t\t\tdest->sourceoffset[1],spr->width,spr->height,2);\r\n\r\n\t\tdest->sourceoffset[2] = shiftstarts[2];\r\n\t\tdest->planesize[2] = bigplane;\r\n\t\tdest->width[2] = spr->width+1;\r\n\t\tCAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],\r\n\t\t\tdest->sourceoffset[2],spr->width,spr->height,4);\r\n\r\n\t\tdest->sourceoffset[3] = shiftstarts[3];\r\n\t\tdest->planesize[3] = bigplane;\r\n\t\tdest->width[3] = spr->width+1;\r\n\t\tCAL_ShiftSprite ((unsigned)grsegs[chunk],dest->sourceoffset[0],\r\n\t\t\tdest->sourceoffset[3],spr->width,spr->height,6);\r\n\r\n\t\tbreak;\r\n\r\n\tdefault:\r\n\t\tQuit (\"CAL_CacheSprite: Bad shifts number!\");\r\n\t}\r\n\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_ExpandGrChunk\r\n=\r\n= Does whatever is needed with a pointer to a compressed chunk\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_ExpandGrChunk (int chunk, byte far *source)\r\n{\r\n\tlong\tpos,compressed,expanded;\r\n\tint\t\tnext;\r\n\tspritetabletype\t*spr;\r\n\r\n\r\n\tif (chunk>=STARTTILE8)\r\n\t{\r\n\t//\r\n\t// expanded sizes of tile8/16/32 are implicit\r\n\t//\r\n\r\n#if GRMODE == EGAGR\r\n#define BLOCK\t\t32\r\n#define MASKBLOCK\t40\r\n#endif\r\n\r\n#if GRMODE == CGAGR\r\n#define BLOCK\t\t16\r\n#define MASKBLOCK\t32\r\n#endif\r\n\r\n\t\tif (chunk<STARTTILE8M)\t\t\t// tile 8s are all in one chunk!\r\n\t\t\texpanded = BLOCK*NUMTILE8;\r\n\t\telse if (chunk<STARTTILE16)\r\n\t\t\texpanded = MASKBLOCK*NUMTILE8M;\r\n\t\telse if (chunk<STARTTILE16M)\t// all other tiles are one/chunk\r\n\t\t\texpanded = BLOCK*4;\r\n\t\telse if (chunk<STARTTILE32)\r\n\t\t\texpanded = MASKBLOCK*4;\r\n\t\telse if (chunk<STARTTILE32M)\r\n\t\t\texpanded = BLOCK*16;\r\n\t\telse\r\n\t\t\texpanded = MASKBLOCK*16;\r\n\t}\r\n\telse\r\n\t{\r\n\t//\r\n\t// everything else has an explicit size longword\r\n\t//\r\n\t\texpanded = *(long far *)source;\r\n\t\tsource += 4;\t\t\t// skip over length\r\n\t}\r\n\r\n//\r\n// allocate final space, decompress it, and free bigbuffer\r\n// Sprites need to have shifts made and various other junk\r\n//\r\n\tif (chunk>=STARTSPRITES && chunk< STARTTILE8)\r\n\t\tCAL_CacheSprite(chunk,source);\r\n\telse\r\n\t{\r\n\t\tMM_GetPtr (&grsegs[chunk],expanded);\r\n\t\tCAL_HuffExpand (source,grsegs[chunk],expanded,grhuffman);\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CAL_ReadGrChunk\r\n=\r\n= Gets a chunk off disk, optimizing reads to general buffer\r\n=\r\n======================\r\n*/\r\n\r\nvoid CAL_ReadGrChunk (int chunk)\r\n{\r\n\tlong\tpos,compressed,expanded;\r\n\tmemptr\tbigbufferseg;\r\n\tbyte\tfar *source;\r\n\tint\t\tnext;\r\n\tspritetabletype\t*spr;\r\n\r\n//\r\n// load the chunk into a buffer, either the miscbuffer if it fits, or allocate\r\n// a larger buffer\r\n//\r\n\tpos = grstarts[chunk];\r\n\tif (pos<0)\t\t\t\t\t\t\t// $FFFFFFFF start is a sparse tile\r\n\t  return;\r\n\r\n\tnext = chunk +1;\r\n\twhile (grstarts[next] == -1)\t\t// skip past any sparse tiles\r\n\t\tnext++;\r\n\r\n\tcompressed = grstarts[next]-pos;\r\n\r\n\tlseek(grhandle,pos,SEEK_SET);\r\n\r\n\tif (compressed<=BUFFERSIZE)\r\n\t{\r\n\t\tCA_FarRead(grhandle,bufferseg,compressed);\r\n\t\tsource = bufferseg;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMM_GetPtr(&bigbufferseg,compressed);\r\n\t\tCA_FarRead(grhandle,bigbufferseg,compressed);\r\n\t\tsource = bigbufferseg;\r\n\t}\r\n\r\n\tCAL_ExpandGrChunk (chunk,source);\r\n\r\n\tif (compressed>BUFFERSIZE)\r\n\t\tMM_FreePtr(&bigbufferseg);\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheGrChunk\r\n=\r\n= Makes sure a given chunk is in memory, loadiing it if needed\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_CacheGrChunk (int chunk)\r\n{\r\n\tlong\tpos,compressed,expanded;\r\n\tmemptr\tbigbufferseg;\r\n\tbyte\tfar *source;\r\n\tint\t\tnext;\r\n\r\n\tgrneeded[chunk] |= ca_levelbit;\t\t// make sure it doesn't get removed\r\n\tif (grsegs[chunk])\r\n\t  return;\t\t\t\t\t\t\t// allready in memory\r\n\r\n//\r\n// load the chunk into a buffer, either the miscbuffer if it fits, or allocate\r\n// a larger buffer\r\n//\r\n\tpos = grstarts[chunk];\r\n\tif (pos<0)\t\t\t\t\t\t\t// $FFFFFFFF start is a sparse tile\r\n\t  return;\r\n\r\n\tnext = chunk +1;\r\n\twhile (grstarts[next] == -1)\t\t// skip past any sparse tiles\r\n\t\tnext++;\r\n\r\n\tcompressed = grstarts[next]-pos;\r\n\r\n\tlseek(grhandle,pos,SEEK_SET);\r\n\r\n\tif (compressed<=BUFFERSIZE)\r\n\t{\r\n\t\tCA_FarRead(grhandle,bufferseg,compressed);\r\n\t\tsource = bufferseg;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMM_GetPtr(&bigbufferseg,compressed);\r\n\t\tCA_FarRead(grhandle,bigbufferseg,compressed);\r\n\t\tsource = bigbufferseg;\r\n\t}\r\n\r\n\tCAL_ExpandGrChunk (chunk,source);\r\n\r\n\tif (compressed>BUFFERSIZE)\r\n\t\tMM_FreePtr(&bigbufferseg);\r\n}\r\n\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheMap\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_CacheMap (int mapnum)\r\n{\r\n\tlong\tpos,compressed,expanded;\r\n\tint\t\tplane;\r\n\tmemptr\t*dest,bigbufferseg,buffer2seg;\r\n\tunsigned\tsize;\r\n\tunsigned\tfar\t*source;\r\n\r\n\r\n//\r\n// free up memory from last map\r\n//\r\n\tif (mapon>-1 && mapheaderseg[mapon])\r\n\t\tMM_SetPurge (&(memptr)mapheaderseg[mapon],3);\r\n\tfor (plane=0;plane<3;plane++)\r\n\t\tif (mapsegs[plane])\r\n\t\t\tMM_FreePtr (&(memptr)mapsegs[plane]);\r\n\r\n\tmapon = mapnum;\r\n\r\n\r\n//\r\n// load map header\r\n// The header will be cached if it is still around\r\n//\r\n\tif (!mapheaderseg[mapnum])\r\n\t{\r\n\t\tpos = ((mapfiletype\t_seg *)tinf)->headeroffsets[mapnum];\r\n\t\tif (pos<0)\t\t\t\t\t\t// $FFFFFFFF start is a sparse map\r\n\t\t  Quit (\"CA_CacheMap: Tried to load a non existant map!\");\r\n\r\n\t\tMM_GetPtr(&(memptr)mapheaderseg[mapnum],sizeof(maptype));\r\n\t\tlseek(maphandle,pos,SEEK_SET);\r\n\r\n#ifdef MAPHEADERLINKED\r\n#if BUFFERSIZE < sizeof(maptype)\r\nThe general buffer size is too small!\r\n#endif\r\n\t\t//\r\n\t\t// load in, then unhuffman to the destination\r\n\t\t//\r\n\t\tCA_FarRead (maphandle,bufferseg,((mapfiletype\t_seg *)tinf)->headersize[mapnum]);\r\n\t\tCAL_HuffExpand ((byte huge *)bufferseg,\r\n\t\t\t(byte huge *)mapheaderseg[mapnum],sizeof(maptype),maphuffman);\r\n#else\r\n\t\tCA_FarRead (maphandle,(memptr)mapheaderseg[mapnum],sizeof(maptype));\r\n#endif\r\n\t}\r\n\telse\r\n\t\tMM_SetPurge (&(memptr)mapheaderseg[mapnum],0);\r\n\r\n//\r\n// load the planes in\r\n// If a plane's pointer still exists it will be overwritten (levels are\r\n// allways reloaded, never cached)\r\n//\r\n\r\n\tsize = mapheaderseg[mapnum]->width * mapheaderseg[mapnum]->height * 2;\r\n\r\n\tfor (plane = 0; plane<3; plane++)\r\n\t{\r\n\t\tdest = &(memptr)mapsegs[plane];\r\n\t\tMM_GetPtr(dest,size);\r\n\r\n\t\tpos = mapheaderseg[mapnum]->planestart[plane];\r\n\t\tcompressed = mapheaderseg[mapnum]->planelength[plane];\r\n\t\tlseek(maphandle,pos,SEEK_SET);\r\n\t\tif (compressed<=BUFFERSIZE)\r\n\t\t\tsource = bufferseg;\r\n\t\telse\r\n\t\t{\r\n\t\t\tMM_GetPtr(&bigbufferseg,compressed);\r\n\t\t\tsource = bigbufferseg;\r\n\t\t}\r\n\r\n\t\tCA_FarRead(maphandle,(byte far *)source,compressed);\r\n#ifdef MAPHEADERLINKED\r\n\t\t//\r\n\t\t// unhuffman, then unRLEW\r\n\t\t// The huffman'd chunk has a two byte expanded length first\r\n\t\t// The resulting RLEW chunk also does, even though it's not really\r\n\t\t// needed\r\n\t\t//\r\n\t\texpanded = *source;\r\n\t\tsource++;\r\n\t\tMM_GetPtr (&buffer2seg,expanded);\r\n\t\tCAL_HuffExpand ((byte huge *)source, buffer2seg,expanded,maphuffman);\r\n\t\tCA_RLEWexpand (((unsigned far *)buffer2seg)+1,*dest,size,\r\n\t\t((mapfiletype _seg *)tinf)->RLEWtag);\r\n\t\tMM_FreePtr (&buffer2seg);\r\n\r\n#else\r\n\t\t//\r\n\t\t// unRLEW, skipping expanded length\r\n\t\t//\r\n\t\tCA_RLEWexpand (source+1, *dest,size,\r\n\t\t((mapfiletype _seg *)tinf)->RLEWtag);\r\n#endif\r\n\r\n\t\tif (compressed>BUFFERSIZE)\r\n\t\t\tMM_FreePtr(&bigbufferseg);\r\n\t}\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_UpLevel\r\n=\r\n= Goes up a bit level in the needed lists and clears it out.\r\n= Everything is made purgable\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_UpLevel (void)\r\n{\r\n\tint i;\r\n\r\n\tif (ca_levelnum==7)\r\n\t\tQuit (\"CA_UpLevel: Up past level 7!\");\r\n\r\n//\tfor (i=0;i<NUMCHUNKS;i++)\r\n//\t\t\tif (grsegs[i])\r\n//\t\t\t\tMM_SetPurge(&grsegs[i],3);\r\n\r\n\tca_levelbit<<=1;\r\n\tca_levelnum++;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_DownLevel\r\n=\r\n= Goes down a bit level in the needed lists and recaches\r\n= everything from the lower level\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_DownLevel (void)\r\n{\r\n\tif (!ca_levelnum)\r\n\t\tQuit (\"CA_DownLevel: Down past level 0!\");\r\n\tca_levelbit>>=1;\r\n\tca_levelnum--;\r\n\tCA_CacheMarks(titleptr[ca_levelnum], 1);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_ClearMarks\r\n=\r\n= Clears out all the marks at the current level\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_ClearMarks (void)\r\n{\r\n\tint i;\r\n\r\n\tfor (i=0;i<NUMCHUNKS;i++)\r\n\t\tgrneeded[i]&=~ca_levelbit;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CA_ClearAllMarks\r\n=\r\n= Clears out all the marks on all the levels\r\n=\r\n======================\r\n*/\r\n\r\nvoid CA_ClearAllMarks (void)\r\n{\r\n\tmemset (grneeded,0,sizeof(grneeded));\r\n\tca_levelbit = 1;\r\n\tca_levelnum = 0;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CA_CacheMarks\r\n=\r\n======================\r\n*/\r\n\r\n#define NUMBARS\t(17l*8)\r\n#define BARSTEP\t8\r\n#define MAXEMPTYREAD\t1024\r\n\r\nvoid CA_CacheMarks (char *title, boolean cachedownlevel)\r\n{\r\n\tboolean dialog;\r\n\tint \ti,next,homex,homey,x,y,thx,thy,numcache,lastx,xl,xh;\r\n\tlong\tbarx,barstep;\r\n\tlong\tpos,endpos,nextpos,nextendpos,compressed;\r\n\tlong\tbufferstart,bufferend;\t// file position of general buffer\r\n\tbyte\tfar *source;\r\n\tmemptr\tbigbufferseg;\r\n\r\n\t//\r\n\t// save title so cache down level can redraw it\r\n\t//\r\n\ttitleptr[ca_levelnum] = title;\r\n\r\n\tdialog = (title!=NULL);\r\n\r\n\tif (cachedownlevel)\r\n\t\tdialog = false;\r\n\r\n\tif (dialog)\r\n\t{\r\n\t//\r\n\t// draw dialog window (masked tiles 12 - 20 are window borders)\r\n\t//\r\n\t\tUS_CenterWindow (20,8);\r\n\t\thomex = PrintX;\r\n\t\thomey = PrintY;\r\n\r\n\t\tUS_CPrint (\"Loading\");\r\n\t\tfontcolor = F_SECONDCOLOR;\r\n\t\tUS_CPrint (title);\r\n\t\tfontcolor = F_BLACK;\r\n\t\tVW_UpdateScreen();\r\n#ifdef PROFILE\r\n\t\twrite(profilehandle,title,strlen(title));\r\n\t\twrite(profilehandle,\"\\n\",1);\r\n#endif\r\n\r\n\t}\r\n\r\n\tnumcache = 0;\r\n//\r\n// go through and make everything not needed purgable\r\n//\r\n\tfor (i=0;i<NUMCHUNKS;i++)\r\n\t\tif (grneeded[i]&ca_levelbit)\r\n\t\t{\r\n\t\t\tif (grsegs[i])\t\t\t\t\t// its allready in memory, make\r\n\t\t\t\tMM_SetPurge(&grsegs[i],0);\t// sure it stays there!\r\n\t\t\telse\r\n\t\t\t\tnumcache++;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (grsegs[i])\t\t\t\t\t// not needed, so make it purgeable\r\n\t\t\t\tMM_SetPurge(&grsegs[i],3);\r\n\t\t}\r\n\r\n\tif (!numcache)\t\t\t// nothing to cache!\r\n\t\treturn;\r\n\r\n\tif (dialog)\r\n\t{\r\n\t//\r\n\t// draw thermometer bar\r\n\t//\r\n\t\tthx = homex + 8;\r\n\t\tthy = homey + 32;\r\n\t\tVWB_DrawTile8(thx,thy,11);\r\n\t\tVWB_DrawTile8(thx,thy+8,14);\r\n\t\tVWB_DrawTile8(thx,thy+16,17);\r\n\t\tVWB_DrawTile8(thx+17*8,thy,13);\r\n\t\tVWB_DrawTile8(thx+17*8,thy+8,16);\r\n\t\tVWB_DrawTile8(thx+17*8,thy+16,19);\r\n\t\tfor (x=thx+8;x<thx+17*8;x+=8)\r\n\t\t{\r\n\t\t\tVWB_DrawTile8(x,thy,12);\r\n\t\t\tVWB_DrawTile8(x,thy+8,15);\r\n\t\t\tVWB_DrawTile8(x,thy+16,18);\r\n\t\t}\r\n\r\n\t\tthx += 4;\t\t// first line location\r\n\t\tthy += 5;\r\n\t\tbarx = (long)thx<<16;\r\n\t\tlastx = thx;\r\n\t\tVW_UpdateScreen();\r\n\t}\r\n\r\n//\r\n// go through and load in anything still needed\r\n//\r\n\tbarstep = (NUMBARS<<16)/numcache;\r\n\tbufferstart = bufferend = 0;\t\t// nothing good in buffer now\r\n\r\n\tfor (i=0;i<NUMCHUNKS;i++)\r\n\t\tif ( (grneeded[i]&ca_levelbit) && !grsegs[i])\r\n\t\t{\r\n//\r\n// update thermometer\r\n//\r\n\t\t\tif (dialog)\r\n\t\t\t{\r\n\t\t\t\tbarx+=barstep;\r\n\t\t\t\txh = barx>>16;\r\n\t\t\t\tif (xh - lastx > BARSTEP)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (x=lastx;x<=xh;x++)\r\n#if GRMODE == EGAGR\r\n\t\t\t\t\t\tVWB_Vlin (thy,thy+13,x,14);\r\n#endif\r\n#if GRMODE == CGAGR\r\n\t\t\t\t\t\tVWB_Vlin (thy,thy+13,x,SECONDCOLOR);\r\n#endif\r\n\t\t\t\t\tlastx = xh;\r\n\t\t\t\t\tVW_UpdateScreen();\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tpos = grstarts[i];\r\n\t\t\tif (pos<0)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tnext = i +1;\r\n\t\t\twhile (grstarts[next] == -1)\t\t// skip past any sparse tiles\r\n\t\t\t\tnext++;\r\n\r\n\t\t\tcompressed = grstarts[next]-pos;\r\n\t\t\tendpos = pos+compressed;\r\n\r\n\t\t\tif (compressed<=BUFFERSIZE)\r\n\t\t\t{\r\n\t\t\t\tif (bufferstart<=pos\r\n\t\t\t\t&& bufferend>= endpos)\r\n\t\t\t\t{\r\n\t\t\t\t// data is allready in buffer\r\n\t\t\t\t\tsource = (byte _seg *)bufferseg+(pos-bufferstart);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t// load buffer with a new block from disk\r\n\t\t\t\t// try to get as many of the needed blocks in as possible\r\n\t\t\t\t\twhile ( next < NUMCHUNKS )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile (next < NUMCHUNKS &&\r\n\t\t\t\t\t\t!(grneeded[next]&ca_levelbit && !grsegs[next]))\r\n\t\t\t\t\t\t\tnext++;\r\n\t\t\t\t\t\tif (next == NUMCHUNKS)\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\tnextpos = grstarts[next];\r\n\t\t\t\t\t\twhile (grstarts[++next] == -1)\t// skip past any sparse tiles\r\n\t\t\t\t\t\t\t;\r\n\t\t\t\t\t\tnextendpos = grstarts[next];\r\n\t\t\t\t\t\tif (nextpos - endpos <= MAXEMPTYREAD\r\n\t\t\t\t\t\t&& nextendpos-pos <= BUFFERSIZE)\r\n\t\t\t\t\t\t\tendpos = nextendpos;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tnext = NUMCHUNKS;\t\t\t// read pos to posend\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlseek(grhandle,pos,SEEK_SET);\r\n\t\t\t\t\tCA_FarRead(grhandle,bufferseg,endpos-pos);\r\n\t\t\t\t\tbufferstart = pos;\r\n\t\t\t\t\tbufferend = endpos;\r\n\t\t\t\t\tsource = bufferseg;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t// big chunk, allocate temporary buffer\r\n\t\t\t\tMM_GetPtr(&bigbufferseg,compressed);\r\n\t\t\t\tlseek(grhandle,pos,SEEK_SET);\r\n\t\t\t\tCA_FarRead(grhandle,bigbufferseg,compressed);\r\n\t\t\t\tsource = bigbufferseg;\r\n\t\t\t}\r\n\r\n\t\t\tCAL_ExpandGrChunk (i,source);\r\n\r\n\t\t\tif (compressed>BUFFERSIZE)\r\n\t\t\t\tMM_FreePtr(&bigbufferseg);\r\n\r\n\t\t}\r\n\r\n//\r\n// finish up any thermometer remnants\r\n//\r\n\t\tif (dialog)\r\n\t\t{\r\n\t\t\txh = thx + NUMBARS;\r\n\t\t\tfor (x=lastx;x<=xh;x++)\r\n#if GRMODE == EGAGR\r\n\t\t\t\tVWB_Vlin (thy,thy+13,x,14);\r\n#endif\r\n#if GRMODE == CGAGR\r\n\t\t\t\tVWB_Vlin (thy,thy+13,x,SECONDCOLOR);\r\n#endif\r\n\t\t\tVW_UpdateScreen();\r\n\t\t}\r\n}\r\n\r\n"
        },
        {
          "name": "id_ca.h",
          "type": "blob",
          "size": 3.3046875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_CA.H\r\n\r\n#ifndef __TYPES__\r\n#include \"ID_TYPES.H\"\r\n#endif\r\n\r\n#ifndef __ID_MM__\r\n#include \"ID_MM.H\"\r\n#endif\r\n\r\n#ifndef __ID_GLOB__\r\n#include \"ID_GLOB.H\"\r\n#endif\r\n\r\n#define __ID_CA__\r\n\r\n//===========================================================================\r\n\r\n#define MAPHEADERLINKED\r\n#define GRHEADERLINKED\r\n#define AUDIOHEADERLINKED\r\n\r\n#define NUMMAPS\t30\r\n\r\n//\r\n// tile info defines, as bytes after tinf the table starts\r\n//\r\n\r\n\r\n#define\tSPEED\t502\r\n#define ANIM\t(SPEED+NUMTILE16)\r\n\r\n#define NORTHWALL\t(ANIM+NUMTILE16)\r\n#define EASTWALL\t(NORTHWALL+NUMTILE16M)\r\n#define SOUTHWALL   (EASTWALL+NUMTILE16M)\r\n#define WESTWALL    (SOUTHWALL+NUMTILE16M)\r\n#define MANIM       (WESTWALL+NUMTILE16M)\r\n#define INTILE      (MANIM+NUMTILE16M)\r\n#define MSPEED      (INTILE+NUMTILE16M)\r\n\r\n//===========================================================================\r\n\r\ntypedef\tstruct\r\n{\r\n\tlong\t\tplanestart[3];\r\n\tunsigned\tplanelength[3];\r\n\tunsigned\twidth,height;\r\n\tchar\t\tname[16];\r\n} maptype;\r\n\r\n//===========================================================================\r\n\r\nextern\tbyte \t\t_seg\t*tinf;\r\nextern\tint\t\t\tmapon;\r\n\r\nextern\tunsigned\t_seg\t*mapsegs[3];\r\nextern\tmaptype\t\t_seg\t*mapheaderseg[NUMMAPS];\r\nextern\tbyte\t\t_seg\t*audiosegs[NUMSNDCHUNKS];\r\nextern\tvoid\t\t_seg\t*grsegs[NUMCHUNKS];\r\n\r\nextern\tbyte\t\tgrneeded[NUMCHUNKS];\r\nextern\tbyte\t\tca_levelbit,ca_levelnum;\r\n\r\nextern\tchar\t\t*titleptr[8];\r\n\r\nextern\tint\t\t\tprofilehandle;\r\n\r\n//===========================================================================\r\n\r\n// just for the score box reshifting\r\n\r\nvoid CAL_ShiftSprite (unsigned segment,unsigned source,unsigned dest,\r\n\tunsigned width, unsigned height, unsigned pixshift);\r\n\r\n//===========================================================================\r\n\r\nboolean CA_FarRead (int handle, byte far *dest, long length);\r\nboolean CA_FarWrite (int handle, byte far *source, long length);\r\nboolean CA_LoadFile (char *filename, memptr *ptr);\r\n\r\nlong CA_RLEWCompress (unsigned huge *source, long length, unsigned huge *dest,\r\n  unsigned rlewtag);\r\n\r\nvoid CA_RLEWexpand (unsigned huge *source, unsigned huge *dest,long length,\r\n  unsigned rlewtag);\r\n\r\nvoid CA_Startup (void);\r\nvoid CA_Shutdown (void);\r\n\r\nvoid CA_CacheAudioChunk (int chunk);\r\nvoid CA_LoadAllSounds (void);\r\n\r\nvoid CA_UpLevel (void);\r\nvoid CA_DownLevel (void);\r\n\r\nvoid CA_ClearMarks (void);\r\nvoid CA_ClearAllMarks (void);\r\n\r\n#define CA_MarkGrChunk(chunk)\tgrneeded[chunk]|=ca_levelbit\r\n\r\nvoid CA_CacheGrChunk (int chunk);\r\nvoid CA_CacheMap (int mapnum);\r\n\r\nvoid CA_CacheMarks (char *title, boolean cachedownlevel);\r\n\r\n"
        },
        {
          "name": "id_heads.h",
          "type": "blob",
          "size": 1.89453125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_GLOB.H\r\n\r\n\r\n#include <ALLOC.H>\r\n#include <ctype.h>\r\n#include <DOS.H>\r\n#include <ERRNO.H>\r\n#include <FCNTL.H>\r\n#include <IO.H>\r\n#include <MEM.H>\r\n#include <process.h>\r\n#include <STDIO.H>\r\n#include <STDLIB.H>\r\n#include <STRING.H>\r\n#include <SYS\\STAT.H>\r\n\r\n#define __ID_GLOB__\r\n\r\n#define\tEXTENSION\t\"KDR\"\r\n\r\n#include \"GRAPHKDR.H\"\r\n#include \"AUDIOKDR.H\"\r\n\r\n#define\tTEXTGR\t0\r\n#define\tCGAGR\t1\r\n#define\tEGAGR\t2\r\n#define\tVGAGR\t3\r\n\r\n#define GRMODE\tEGAGR\r\n\r\n#if GRMODE == EGAGR\r\n#define GREXT\t\"EGA\"\r\n#endif\r\n#if GRMODE == CGAGR\r\n#define GREXT\t\"CGA\"\r\n#endif\r\n\r\n//#define PROFILE\r\n\r\n//\r\n//\tID Engine\r\n//\tTypes.h - Generic types, #defines, etc.\r\n//\tv1.0d1\r\n//\r\n\r\n#ifndef\t__TYPES__\r\n#define\t__TYPES__\r\n\r\ntypedef\tenum\t{false,true}\tboolean;\r\ntypedef\tunsigned\tchar\t\tbyte;\r\ntypedef\tunsigned\tint\t\t\tword;\r\ntypedef\tunsigned\tlong\t\tlongword;\r\ntypedef\tbyte *\t\t\t\t\tPtr;\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tint\tx,y;\r\n\t\t} Point;\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tPoint\tul,lr;\r\n\t\t} Rect;\r\n\r\n#define\tnil\t((void *)0)\r\n\r\n#endif\r\n\r\n#include \"ID_MM.H\"\r\n#include \"ID_CA.H\"\r\n#include \"ID_VW.H\"\r\n#include \"ID_RF.H\"\r\n#include \"ID_IN.H\"\r\n#include \"ID_SD.H\"\r\n#include \"ID_US.H\"\r\n\r\n\r\n\r\n"
        },
        {
          "name": "id_in.c",
          "type": "blob",
          "size": 27.2939453125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n//\tID Engine\r\n//\tID_IN.c - Input Manager\r\n//\tv1.0d1\r\n//\tBy Jason Blochowiak\r\n//\r\n\r\n//\r\n//\tThis module handles dealing with the various input devices\r\n//\r\n//\tDepends on: Memory Mgr (for demo recording), Sound Mgr (for timing stuff),\r\n//\t\t\t\tUser Mgr (for command line parms)\r\n//\r\n//\tGlobals:\r\n//\t\tLastScan - The keyboard scan code of the last key pressed\r\n//\t\tLastASCII - The ASCII value of the last key pressed\r\n//\tDEBUG - there are more globals\r\n//\r\n\r\n#include \"ID_HEADS.H\"\r\n#pragma\thdrstop\r\n\r\n#define\tKeyInt\t9\t// The keyboard ISR number\r\n\r\n// \tStuff for the mouse\r\n#define\tMReset\t\t0\r\n#define\tMButtons\t3\r\n#define\tMDelta\t\t11\r\n\r\n#define\tMouseInt\t0x33\r\n#define\tMouse(x)\t_AX = x,geninterrupt(MouseInt)\r\n\r\n// Stuff for the joystick\r\n#define\tJoyScaleMax\t\t32768\r\n#define\tJoyScaleShift\t8\r\n#define\tMaxJoyValue\t\t5000\r\n\r\n// \tGlobal variables\r\n\t\tboolean\t\tKeyboard[NumCodes],\r\n\t\t\t\t\tJoysPresent[MaxJoys],\r\n\t\t\t\t\tMousePresent;\r\n\t\tDemo\t\tDemoMode = demo_Off;\r\n\t\tboolean\t\tPaused;\r\n\t\tchar\t\tLastASCII;\r\n\t\tScanCode\tLastScan;\r\n\t\tKeyboardDef\tKbdDefs[MaxKbds] = {{0x1d,0x38,0x47,0x48,0x49,0x4b,0x4d,0x4f,0x50,0x51}};\r\n\t\tJoystickDef\tJoyDefs[MaxJoys];\r\n\t\tControlType\tControls[MaxPlayers];\r\n\r\n//\tInternal variables\r\nstatic\tboolean\t\tIN_Started;\r\nstatic\tboolean\t\tCapsLock;\r\nstatic\tScanCode\tCurCode,LastCode;\r\nstatic\tbyte        ASCIINames[] =\t\t// Unshifted ASCII for scan codes\r\n\t\t\t\t\t{\r\n//\t 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n\t0  ,27 ,'1','2','3','4','5','6','7','8','9','0','-','=',8  ,9  ,\t// 0\r\n\t'q','w','e','r','t','y','u','i','o','p','[',']',13 ,0  ,'a','s',\t// 1\r\n\t'd','f','g','h','j','k','l',';',39 ,'`',0  ,92 ,'z','x','c','v',\t// 2\r\n\t'b','n','m',',','.','/',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,\t// 3\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',\t// 4\r\n\t'2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 5\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 6\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0\t\t// 7\r\n\t\t\t\t\t},\r\n\t\t\t\t\tShiftNames[] =\t\t// Shifted ASCII for scan codes\r\n\t\t\t\t\t{\r\n//\t 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n\t0  ,27 ,'!','@','#','$','%','^','&','*','(',')','_','+',8  ,9  ,\t// 0\r\n\t'Q','W','E','R','T','Y','U','I','O','P','{','}',13 ,0  ,'A','S',\t// 1\r\n\t'D','F','G','H','J','K','L',':',34 ,'~',0  ,'|','Z','X','C','V',\t// 2\r\n\t'B','N','M','<','>','?',0  ,'*',0  ,' ',0  ,0  ,0  ,0  ,0  ,0  ,\t// 3\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,'7','8','9','-','4','5','6','+','1',\t// 4\r\n\t'2','3','0',127,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 5\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 6\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0   \t// 7\r\n\t\t\t\t\t},\r\n\t\t\t\t\tSpecialNames[] =\t// ASCII for 0xe0 prefixed codes\r\n\t\t\t\t\t{\r\n//\t 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 0\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,13 ,0  ,0  ,0  ,\t// 1\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 2\r\n\t0  ,0  ,0  ,0  ,0  ,'/',0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 3\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 4\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 5\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,\t// 6\r\n\t0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0  ,0   \t// 7\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t*ScanNames[] =\t\t// Scan code names with single chars\r\n\t\t\t\t\t{\r\n\t\"?\",\"?\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"0\",\"-\",\"+\",\"?\",\"?\",\r\n\t\"Q\",\"W\",\"E\",\"R\",\"T\",\"Y\",\"U\",\"I\",\"O\",\"P\",\"[\",\"]\",\"|\",\"?\",\"A\",\"S\",\r\n\t\"D\",\"F\",\"G\",\"H\",\"J\",\"K\",\"L\",\";\",\"\\\"\",\"?\",\"?\",\"?\",\"Z\",\"X\",\"C\",\"V\",\r\n\t\"B\",\"N\",\"M\",\",\",\".\",\"/\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\r\n\t\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"\\xf\",\"?\",\"-\",\"\\x15\",\"5\",\"\\x11\",\"+\",\"?\",\r\n\t\"\\x13\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\r\n\t\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\r\n\t\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\",\"?\"\r\n\t\t\t\t\t},\t// DEBUG - consolidate these\r\n\t\t\t\t\tExtScanCodes[] =\t// Scan codes with >1 char names\r\n\t\t\t\t\t{\r\n\t1,0xe,0xf,0x1d,0x2a,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,\r\n\t0x3f,0x40,0x41,0x42,0x43,0x44,0x57,0x59,0x46,0x1c,0x36,\r\n\t0x37,0x38,0x47,0x49,0x4f,0x51,0x52,0x53,0x45,0x48,\r\n\t0x50,0x4b,0x4d,0x00\r\n\t\t\t\t\t},\r\n\t\t\t\t\t*ExtScanNames[] =\t// Names corresponding to ExtScanCodes\r\n\t\t\t\t\t{\r\n\t\"Esc\",\"BkSp\",\"Tab\",\"Ctrl\",\"LShft\",\"Space\",\"CapsLk\",\"F1\",\"F2\",\"F3\",\"F4\",\r\n\t\"F5\",\"F6\",\"F7\",\"F8\",\"F9\",\"F10\",\"F11\",\"F12\",\"ScrlLk\",\"Enter\",\"RShft\",\r\n\t\"PrtSc\",\"Alt\",\"Home\",\"PgUp\",\"End\",\"PgDn\",\"Ins\",\"Del\",\"NumLk\",\"Up\",\r\n\t\"Down\",\"Left\",\"Right\",\"\"\r\n\t\t\t\t\t};\r\nstatic\tDirection\tDirTable[] =\t\t// Quick lookup for total direction\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdir_NorthWest,\tdir_North,\tdir_NorthEast,\r\n\t\t\t\t\t\tdir_West,\t\tdir_None,\tdir_East,\r\n\t\t\t\t\t\tdir_SouthWest,\tdir_South,\tdir_SouthEast\r\n\t\t\t\t\t};\r\n\r\nstatic\tbyte _seg\t*DemoBuffer;\r\nstatic\tword\t\tDemoOffset,DemoSize;\r\n\r\nstatic\tvoid\t\t\t(*INL_KeyHook)(void);\r\nstatic\tvoid interrupt\t(*OldKeyVect)(void);\r\n\r\nstatic\tchar\t\t\t*ParmStrings[] = {\"nojoys\",\"nomouse\",nil};\r\n\r\n//\tInternal routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_KeyService() - Handles a keyboard interrupt (key up/down)\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void interrupt\r\nINL_KeyService(void)\r\n{\r\nstatic\tboolean\tspecial;\r\n\t\tbyte\tk,c,\r\n\t\t\t\ttemp;\r\n\r\n\tk = inportb(0x60);\t// Get the scan code\r\n\r\n\t// Tell the XT keyboard controller to clear the key\r\n\toutportb(0x61,(temp = inportb(0x61)) | 0x80);\r\n\toutportb(0x61,temp);\r\n\r\n\tif (k == 0xe0)\t\t// Special key prefix\r\n\t\tspecial = true;\r\n\telse if (k == 0xe1)\t// Handle Pause key\r\n\t\tPaused = true;\r\n\telse\r\n\t{\r\n\t\tif (k & 0x80)\t// Break code\r\n\t\t{\r\n\t\t\tk &= 0x7f;\r\n\r\n// DEBUG - handle special keys: ctl-alt-delete, print scrn\r\n\r\n\t\t\tKeyboard[k] = false;\r\n\t\t}\r\n\t\telse\t\t\t// Make code\r\n\t\t{\r\n\t\t\tLastCode = CurCode;\r\n\t\t\tCurCode = LastScan = k;\r\n\t\t\tKeyboard[k] = true;\r\n\r\n\t\t\tif (special)\r\n\t\t\t\tc = SpecialNames[k];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (k == sc_CapsLock)\r\n\t\t\t\t{\r\n\t\t\t\t\tCapsLock ^= true;\r\n\t\t\t\t\t// DEBUG - make caps lock light work\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (Keyboard[sc_LShift] || Keyboard[sc_RShift])\t// If shifted\r\n\t\t\t\t{\r\n\t\t\t\t\tc = ShiftNames[k];\r\n\t\t\t\t\tif ((c >= 'A') && (c <= 'Z') && CapsLock)\r\n\t\t\t\t\t\tc += 'a' - 'A';\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tc = ASCIINames[k];\r\n\t\t\t\t\tif ((c >= 'a') && (c <= 'z') && CapsLock)\r\n\t\t\t\t\t\tc -= 'a' - 'A';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (c)\r\n\t\t\t\tLastASCII = c;\r\n\t\t}\r\n\r\n\t\tspecial = false;\r\n\t}\r\n\r\n\tif (INL_KeyHook && !special)\r\n\t\tINL_KeyHook();\r\n\toutportb(0x20,0x20);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_GetMouseDelta() - Gets the amount that the mouse has moved from the\r\n//\t\tmouse driver\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_GetMouseDelta(int *x,int *y)\r\n{\r\n\tMouse(MDelta);\r\n\t*x = _CX;\r\n\t*y = _DX;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_GetMouseButtons() - Gets the status of the mouse buttons from the\r\n//\t\tmouse driver\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic word\r\nINL_GetMouseButtons(void)\r\n{\r\n\tword\tbuttons;\r\n\r\n\tMouse(MButtons);\r\n\tbuttons = _BX;\r\n\treturn(buttons);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_GetJoyAbs() - Reads the absolute position of the specified joystick\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_GetJoyAbs(word joy,word *xp,word *yp)\r\n{\r\n\tbyte\txb,yb,\r\n\t\t\txs,ys;\r\n\tword\tx,y;\r\n\r\n\tx = y = 0;\r\n\txs = joy? 2 : 0;\t\t// Find shift value for x axis\r\n\txb = 1 << xs;\t\t\t// Use shift value to get x bit mask\r\n\tys = joy? 3 : 1;\t\t// Do the same for y axis\r\n\tyb = 1 << ys;\r\n\r\n// Read the absolute joystick values\r\nasm\t\tpushf\t\t\t\t// Save some registers\r\nasm\t\tpush\tsi\r\nasm\t\tpush\tdi\r\nasm\t\tcli\t\t\t\t\t// Make sure an interrupt doesn't screw the timings\r\n\r\n\r\nasm\t\tmov\t\tdx,0x201\r\nasm\t\tin\t\tal,dx\r\nasm\t\tout\t\tdx,al\t\t// Clear the resistors\r\n\r\nasm\t\tmov\t\tah,[xb]\t\t// Get masks into registers\r\nasm\t\tmov\t\tch,[yb]\r\n\r\nasm\t\txor\t\tsi,si\t\t// Clear count registers\r\nasm\t\txor\t\tdi,di\r\nasm\t\txor\t\tbh,bh\t\t// Clear high byte of bx for later\r\n\r\nasm\t\tpush\tbp\t\t\t// Don't mess up stack frame\r\nasm\t\tmov\t\tbp,MaxJoyValue\r\n\r\nloop:\r\nasm\t\tin\t\tal,dx\t\t// Get bits indicating whether all are finished\r\n\r\nasm\t\tdec\t\tbp\t\t\t// Check bounding register\r\nasm\t\tjz\t\tdone\t\t// We have a silly value - abort\r\n\r\nasm\t\tmov\t\tbl,al\t\t// Duplicate the bits\r\nasm\t\tand\t\tbl,ah\t\t// Mask off useless bits (in [xb])\r\nasm\t\tadd\t\tsi,bx\t\t// Possibly increment count register\r\nasm\t\tmov\t\tcl,bl\t\t// Save for testing later\r\n\r\nasm\t\tmov\t\tbl,al\r\nasm\t\tand\t\tbl,ch\t\t// [yb]\r\nasm\t\tadd\t\tdi,bx\r\n\r\nasm\t\tadd\t\tcl,bl\r\nasm\t\tjnz\t\tloop \t\t// If both bits were 0, drop out\r\n\r\ndone:\r\nasm     pop\t\tbp\r\n\r\nasm\t\tmov\t\tcl,[xs]\t\t// Get the number of bits to shift\r\nasm\t\tshr\t\tsi,cl\t\t//  and shift the count that many times\r\n\r\nasm\t\tmov\t\tcl,[ys]\r\nasm\t\tshr\t\tdi,cl\r\n\r\nasm\t\tmov\t\t[x],si\t\t// Store the values into the variables\r\nasm\t\tmov\t\t[y],di\r\n\r\nasm\t\tpop\t\tdi\r\nasm\t\tpop\t\tsi\r\nasm\t\tpopf\t\t\t\t// Restore the registers\r\n\r\n\t*xp = x;\r\n\t*yp = y;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_GetJoyDelta() - Returns the relative movement of the specified\r\n//\t\tjoystick (from +/-127, scaled adaptively)\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_GetJoyDelta(word joy,int *dx,int *dy,boolean adaptive)\r\n{\r\n\tword\t\tx,y;\r\n\tlongword\ttime;\r\n\tJoystickDef\t*def;\r\nstatic\tlongword\tlasttime;\r\n\r\n\tIN_GetJoyAbs(joy,&x,&y);\r\n\tdef = JoyDefs + joy;\r\n\r\n\tif (x < def->threshMinX)\r\n\t{\r\n\t\tif (x < def->joyMinX)\r\n\t\t\tx = def->joyMinX;\r\n\r\n\t\tx = -(x - def->threshMinX);\r\n\t\tx *= def->joyMultXL;\r\n\t\tx >>= JoyScaleShift;\r\n\t\t*dx = (x > 127)? -127 : -x;\r\n\t}\r\n\telse if (x > def->threshMaxX)\r\n\t{\r\n\t\tif (x > def->joyMaxX)\r\n\t\t\tx = def->joyMaxX;\r\n\r\n\t\tx = x - def->threshMaxX;\r\n\t\tx *= def->joyMultXH;\r\n\t\tx >>= JoyScaleShift;\r\n\t\t*dx = (x > 127)? 127 : x;\r\n\t}\r\n\telse\r\n\t\t*dx = 0;\r\n\r\n\tif (y < def->threshMinY)\r\n\t{\r\n\t\tif (y < def->joyMinY)\r\n\t\t\ty = def->joyMinY;\r\n\r\n\t\ty = -(y - def->threshMinY);\r\n\t\ty *= def->joyMultYL;\r\n\t\ty >>= JoyScaleShift;\r\n\t\t*dy = (y > 127)? -127 : -y;\r\n\t}\r\n\telse if (y > def->threshMaxY)\r\n\t{\r\n\t\tif (y > def->joyMaxY)\r\n\t\t\ty = def->joyMaxY;\r\n\r\n\t\ty = y - def->threshMaxY;\r\n\t\ty *= def->joyMultYH;\r\n\t\ty >>= JoyScaleShift;\r\n\t\t*dy = (y > 127)? 127 : y;\r\n\t}\r\n\telse\r\n\t\t*dy = 0;\r\n\r\n\tif (adaptive)\r\n\t{\r\n\t\ttime = (TimeCount - lasttime) / 2;\r\n\t\tif (time)\r\n\t\t{\r\n\t\t\tif (time > 8)\r\n\t\t\t\ttime = 8;\r\n\t\t\t*dx *= time;\r\n\t\t\t*dy *= time;\r\n\t\t}\r\n\t}\r\n\tlasttime = TimeCount;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_GetJoyButtons() - Returns the button status of the specified\r\n//\t\tjoystick\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic word\r\nINL_GetJoyButtons(word joy)\r\n{\r\nregister\tword\tresult;\r\n\r\n\tresult = inportb(0x201);\t// Get all the joystick buttons\r\n\tresult >>= joy? 6 : 4;\t// Shift into bits 0-1\r\n\tresult &= 3;\t\t\t\t// Mask off the useless bits\r\n\tresult ^= 3;\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_GetJoyButtonsDB() - Returns the de-bounced button status of the\r\n//\t\tspecified joystick\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nword\r\nIN_GetJoyButtonsDB(word joy)\r\n{\r\n\tlongword\tlasttime;\r\n\tword\t\tresult1,result2;\r\n\r\n\tdo\r\n\t{\r\n\t\tresult1 = INL_GetJoyButtons(joy);\r\n\t\tlasttime = TimeCount;\r\n\t\twhile (TimeCount == lasttime)\r\n\t\t\t;\r\n\t\tresult2 = INL_GetJoyButtons(joy);\r\n\t} while (result1 != result2);\r\n\treturn(result1);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_StartKbd() - Sets up my keyboard stuff for use\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_StartKbd(void)\r\n{\r\n\tIN_ClearKeysDown();\r\n\r\n\tOldKeyVect = getvect(KeyInt);\r\n\tsetvect(KeyInt,INL_KeyService);\r\n\r\n\tINL_KeyHook = 0;\t// Clear key hook\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_ShutKbd() - Restores keyboard control to the BIOS\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_ShutKbd(void)\r\n{\r\n\tpoke(0x40,0x17,peek(0x40,0x17) & 0xfaf0);\t// Clear ctrl/alt/shift flags\r\n\r\n\tsetvect(KeyInt,OldKeyVect);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_StartMouse() - Detects and sets up the mouse\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nINL_StartMouse(void)\r\n{\r\n\tif (getvect(MouseInt))\r\n\t{\r\n\t\tMouse(MReset);\r\n\t\tif (_AX == 0xffff)\r\n\t\t\treturn(true);\r\n\t}\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_ShutMouse() - Cleans up after the mouse\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_ShutMouse(void)\r\n{\r\n}\r\n\r\n//\r\n//\tINL_SetJoyScale() - Sets up scaling values for the specified joystick\r\n//\r\nstatic void\r\nINL_SetJoyScale(word joy)\r\n{\r\n\tJoystickDef\t*def;\r\n\r\n\tdef = &JoyDefs[joy];\r\n\tdef->joyMultXL = JoyScaleMax / (def->threshMinX - def->joyMinX);\r\n\tdef->joyMultXH = JoyScaleMax / (def->joyMaxX - def->threshMaxX);\r\n\tdef->joyMultYL = JoyScaleMax / (def->threshMinY - def->joyMinY);\r\n\tdef->joyMultYH = JoyScaleMax / (def->joyMaxY - def->threshMaxY);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_SetupJoy() - Sets up thresholding values and calls INL_SetJoyScale()\r\n//\t\tto set up scaling values\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_SetupJoy(word joy,word minx,word maxx,word miny,word maxy)\r\n{\r\n\tword\t\td,r;\r\n\tJoystickDef\t*def;\r\n\r\n\tdef = &JoyDefs[joy];\r\n\r\n\tdef->joyMinX = minx;\r\n\tdef->joyMaxX = maxx;\r\n\tr = maxx - minx;\r\n\td = r / 5;\r\n\tdef->threshMinX = ((r / 2) - d) + minx;\r\n\tdef->threshMaxX = ((r / 2) + d) + minx;\r\n\r\n\tdef->joyMinY = miny;\r\n\tdef->joyMaxY = maxy;\r\n\tr = maxy - miny;\r\n\td = r / 5;\r\n\tdef->threshMinY = ((r / 2) - d) + miny;\r\n\tdef->threshMaxY = ((r / 2) + d) + miny;\r\n\r\n\tINL_SetJoyScale(joy);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_StartJoy() - Detects & auto-configures the specified joystick\r\n//\t\t\t\t\tThe auto-config assumes the joystick is centered\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nINL_StartJoy(word joy)\r\n{\r\n\tword x,y;\r\n\r\n\tIN_GetJoyAbs(joy, &x, &y);\r\n\r\n\tif (((x == 0) || (x > MaxJoyValue - 10)) ||\r\n\t\t ((y == 0) || (y > MaxJoyValue - 10)))\r\n\t\treturn(false);\r\n\telse\r\n\t{\r\n\t\tIN_SetupJoy(joy, 0, x*2, 0, y*2);\r\n\t\treturn(true);\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_ShutJoy() - Cleans up the joystick stuff\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_ShutJoy(word joy)\r\n{\r\n\tJoysPresent[joy] = false;\r\n}\r\n\r\n//\tPublic routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_Startup() - Starts up the Input Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_Startup(void)\r\n{\r\n\tboolean\tcheckjoys,checkmouse;\r\n\tword\ti;\r\n\r\n\tif (IN_Started)\r\n\t\treturn;\r\n\r\n\tcheckjoys = true;\r\n\tcheckmouse = true;\r\n\tfor (i = 1;i < _argc;i++)\r\n\t{\r\n\t\tswitch (US_CheckParm(_argv[i],ParmStrings))\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tcheckjoys = false;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tcheckmouse = false;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tINL_StartKbd();\r\n\tMousePresent = checkmouse? INL_StartMouse() : false;\r\n\r\n\tfor (i = 0;i < MaxJoys;i++)\r\n\t\tJoysPresent[i] = checkjoys? INL_StartJoy(i) : false;\r\n\r\n\tIN_Started = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_Default() - Sets up default conditions for the Input Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_Default(boolean gotit,ControlType in)\r\n{\r\n\tif\r\n\t(\r\n\t\t(!gotit)\r\n\t|| \t((in == ctrl_Joystick1) && !JoysPresent[0])\r\n\t|| \t((in == ctrl_Joystick2) && !JoysPresent[1])\r\n\t|| \t((in == ctrl_Mouse) && !MousePresent)\r\n\t)\r\n\t\tin = ctrl_Keyboard1;\r\n\tIN_SetControlType(0,in);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_Shutdown() - Shuts down the Input Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_Shutdown(void)\r\n{\r\n\tif (!IN_Started)\r\n\t\treturn;\r\n\r\n\tINL_ShutMouse();\r\n\tINL_ShutKbd();\r\n\r\n\tIN_Started = false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_SetKeyHook() - Sets the routine that gets called by INL_KeyService()\r\n//\t\t\teverytime a real make/break code gets hit\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_SetKeyHook(void (*hook)())\r\n{\r\n\tINL_KeyHook = hook;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_ClearKeyDown() - Clears the keyboard array\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_ClearKeysDown(void)\r\n{\r\n\tint\ti;\r\n\r\n\tLastScan = sc_None;\r\n\tLastASCII = key_None;\r\n\tfor (i = 0;i < NumCodes;i++)\r\n\t\tKeyboard[i] = false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tINL_AdjustCursor() - Internal routine of common code from IN_ReadCursor()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nINL_AdjustCursor(CursorInfo *info,word buttons,int dx,int dy)\r\n{\r\n\tif (buttons & (1 << 0))\r\n\t\tinfo->button0 = true;\r\n\tif (buttons & (1 << 1))\r\n\t\tinfo->button1 = true;\r\n\r\n\tinfo->x += dx;\r\n\tinfo->y += dy;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_ReadCursor() - Reads the input devices and fills in the cursor info\r\n//\t\tstruct\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_ReadCursor(CursorInfo *info)\r\n{\r\n\tword\ti,\r\n\t\t\tbuttons;\r\n\tint\t\tdx,dy;\r\n\r\n\tinfo->x = info->y = 0;\r\n\tinfo->button0 = info->button1 = false;\r\n\r\n\tif (MousePresent)\r\n\t{\r\n\t\tbuttons = INL_GetMouseButtons();\r\n\t\tdx /= 2;\r\n\t\tdy /= 2;\r\n\t\tINL_GetMouseDelta(&dx,&dy);\r\n\t\tINL_AdjustCursor(info,buttons,dx,dy);\r\n\t}\r\n\r\n\tfor (i = 0;i < MaxJoys;i++)\r\n\t{\r\n\t\tif (!JoysPresent[i])\r\n\t\t\tcontinue;\r\n\r\n\t\tbuttons = INL_GetJoyButtons(i);\r\n\t\tINL_GetJoyDelta(i,&dx,&dy,true);\r\n\t\tdx /= 64;\r\n\t\tdy /= 64;\r\n\t\tINL_AdjustCursor(info,buttons,dx,dy);\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_ReadControl() - Reads the device associated with the specified\r\n//\t\tplayer and fills in the control info struct\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_ReadControl(int player,ControlInfo *info)\r\n{\r\n\t\t\tboolean\t\trealdelta;\r\n\t\t\tbyte\t\tdbyte;\r\n\t\t\tword\t\tbuttons;\r\n\t\t\tint\t\t\tdx,dy;\r\n\t\t\tMotion\t\tmx,my;\r\n\t\t\tControlType\ttype;\r\nregister\tKeyboardDef\t*def;\r\n\r\n\tdx = dy = 0;\r\n\tmx = my = motion_None;\r\n\tbuttons = 0;\r\n\r\n\tif (DemoMode == demo_Playback)\r\n\t{\r\n\t\tdbyte = DemoBuffer[DemoOffset + 1];\r\n\t\tdy = (dbyte & 3) - 1;\r\n\t\tdx = ((dbyte >> 2) & 3) - 1;\r\n\t\tbuttons = (dbyte >> 4) & 3;\r\n\r\n\t\tif (!DemoBuffer[DemoOffset]--)\r\n\t\t{\r\n\t\t\tDemoOffset += 2;\r\n\t\t\tif (DemoOffset >= DemoSize)\r\n\t\t\t\tDemoMode = demo_PlayDone;\r\n\t\t}\r\n\t}\r\n\telse if (DemoMode == demo_PlayDone)\r\n\t\tQuit(\"Demo playback exceeded\");\r\n\telse\r\n\t{\r\n\t\tswitch (type = Controls[player])\r\n\t\t{\r\n\t\tcase ctrl_Keyboard1:\r\n\t\tcase ctrl_Keyboard2:\r\n\t\t\tdef = &KbdDefs[type - ctrl_Keyboard];\r\n\r\n\t\t\tif (Keyboard[def->upleft])\r\n\t\t\t\tmx = motion_Left,my = motion_Up;\r\n\t\t\telse if (Keyboard[def->upright])\r\n\t\t\t\tmx = motion_Right,my = motion_Up;\r\n\t\t\telse if (Keyboard[def->downleft])\r\n\t\t\t\tmx = motion_Left,my = motion_Down;\r\n\t\t\telse if (Keyboard[def->downright])\r\n\t\t\t\tmx = motion_Right,my = motion_Down;\r\n\r\n\t\t\tif (Keyboard[def->up])\r\n\t\t\t\tmy = motion_Up;\r\n\t\t\telse if (Keyboard[def->down])\r\n\t\t\t\tmy = motion_Down;\r\n\r\n\t\t\tif (Keyboard[def->left])\r\n\t\t\t\tmx = motion_Left;\r\n\t\t\telse if (Keyboard[def->right])\r\n\t\t\t\tmx = motion_Right;\r\n\r\n\t\t\tif (Keyboard[def->button0])\r\n\t\t\t\tbuttons += 1 << 0;\r\n\t\t\tif (Keyboard[def->button1])\r\n\t\t\t\tbuttons += 1 << 1;\r\n\t\t\trealdelta = false;\r\n\t\t\tbreak;\r\n\t\tcase ctrl_Joystick1:\r\n\t\tcase ctrl_Joystick2:\r\n\t\t\tINL_GetJoyDelta(type - ctrl_Joystick,&dx,&dy,false);\r\n\t\t\tbuttons = INL_GetJoyButtons(type - ctrl_Joystick);\r\n\t\t\trealdelta = true;\r\n\t\t\tbreak;\r\n\t\tcase ctrl_Mouse:\r\n\t\t\tINL_GetMouseDelta(&dx,&dy);\r\n\t\t\tbuttons = INL_GetMouseButtons();\r\n\t\t\trealdelta = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (realdelta)\r\n\t{\r\n\t\tmx = (dx < 0)? motion_Left : ((dx > 0)? motion_Right : motion_None);\r\n\t\tmy = (dy < 0)? motion_Up : ((dy > 0)? motion_Down : motion_None);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdx = mx * 127;\r\n\t\tdy = my * 127;\r\n\t}\r\n\r\n\tinfo->x = dx;\r\n\tinfo->xaxis = mx;\r\n\tinfo->y = dy;\r\n\tinfo->yaxis = my;\r\n\tinfo->button0 = buttons & (1 << 0);\r\n\tinfo->button1 = buttons & (1 << 1);\r\n\tinfo->dir = DirTable[((my + 1) * 3) + (mx + 1)];\r\n\r\n\tif (DemoMode == demo_Record)\r\n\t{\r\n\t\t// Pack the control info into a byte\r\n\t\tdbyte = (buttons << 4) | ((dx + 1) << 2) | (dy + 1);\r\n\r\n\t\tif\r\n\t\t(\r\n\t\t\t(DemoBuffer[DemoOffset + 1] == dbyte)\r\n\t\t&&\t(DemoBuffer[DemoOffset] < 254)\r\n\t\t&&\tDemoOffset\r\n\t\t)\r\n\t\t\tDemoBuffer[DemoOffset]++;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (DemoOffset)\r\n\t\t\t\tDemoOffset += 2;\r\n\r\n\t\t\tif (DemoOffset >= DemoSize)\r\n\t\t\t\tQuit(\"Demo buffer overflow\");\r\n\r\n\t\t\tDemoBuffer[DemoOffset] = 1;\r\n\t\t\tDemoBuffer[DemoOffset + 1] = dbyte;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_SetControlType() - Sets the control type to be used by the specified\r\n//\t\tplayer\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_SetControlType(int player,ControlType type)\r\n{\r\n\t// DEBUG - check that type is present?\r\n\tControls[player] = type;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_StartDemoRecord() - Starts the demo recording, using a buffer the\r\n//\t\tsize passed. Returns if the buffer allocation was successful\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nIN_StartDemoRecord(word bufsize)\r\n{\r\n\tif (!bufsize)\r\n\t\treturn(false);\r\n\r\n\tMM_GetPtr((memptr *)&DemoBuffer,bufsize);\r\n\tDemoMode = demo_Record;\r\n\tDemoSize = bufsize & ~1;\r\n\tDemoOffset = 0;\r\n\r\n\treturn(true);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_StartDemoPlayback() - Plays back the demo pointed to of the given size\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_StartDemoPlayback(byte _seg *buffer,word bufsize)\r\n{\r\n\tDemoBuffer = buffer;\r\n\tDemoMode = demo_Playback;\r\n\tDemoSize = bufsize & ~1;\r\n\tDemoOffset = 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_StopDemoRecord() - Turns off demo mode\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_StopDemo(void)\r\n{\r\n\tDemoMode = demo_Off;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_FreeDemoBuffer() - Frees the demo buffer, if it's been allocated\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_FreeDemoBuffer(void)\r\n{\r\n\tif (DemoBuffer)\r\n\t\tMM_FreePtr((memptr *)&DemoBuffer);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_GetScanName() - Returns a string containing the name of the\r\n//\t\tspecified scan code\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nbyte *\r\nIN_GetScanName(ScanCode scan)\r\n{\r\n\tbyte\t\t**p;\r\n\tScanCode\t*s;\r\n\r\n\tfor (s = ExtScanCodes,p = ExtScanNames;*s;p++,s++)\r\n\t\tif (*s == scan)\r\n\t\t\treturn(*p);\r\n\r\n\treturn(ScanNames[scan]);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_WaitForKey() - Waits for a scan code, then clears LastScan and\r\n//\t\treturns the scan code\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nScanCode\r\nIN_WaitForKey(void)\r\n{\r\n\tScanCode\tresult;\r\n\r\n\twhile (!(result = LastScan))\r\n\t\t;\r\n\tLastScan = 0;\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_WaitForASCII() - Waits for an ASCII char, then clears LastASCII and\r\n//\t\treturns the ASCII value\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nchar\r\nIN_WaitForASCII(void)\r\n{\r\n\tchar\t\tresult;\r\n\r\n\twhile (!(result = LastASCII))\r\n\t\t;\r\n\tLastASCII = '\\0';\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_AckBack() - Waits for either an ASCII keypress or a button press\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_AckBack(void)\r\n{\r\n\tword\ti;\r\n\r\n\twhile (!LastScan)\r\n\t{\r\n\t\tif (MousePresent)\r\n\t\t{\r\n\t\t\tif (INL_GetMouseButtons())\r\n\t\t\t{\r\n\t\t\t\twhile (INL_GetMouseButtons())\r\n\t\t\t\t\t;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor (i = 0;i < MaxJoys;i++)\r\n\t\t{\r\n\t\t\tif (JoysPresent[i])\r\n\t\t\t{\r\n\t\t\t\tif (IN_GetJoyButtonsDB(i))\r\n\t\t\t\t{\r\n\t\t\t\t\twhile (IN_GetJoyButtonsDB(i))\r\n\t\t\t\t\t\t;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tIN_ClearKey(LastScan);\r\n\tLastScan = sc_None;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_Ack() - Clears user input & then calls IN_AckBack()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nIN_Ack(void)\r\n{\r\n\tword\ti;\r\n\r\n\tIN_ClearKey(LastScan);\r\n\tLastScan = sc_None;\r\n\r\n\tif (MousePresent)\r\n\t\twhile (INL_GetMouseButtons())\r\n\t\t\t\t\t;\r\n\tfor (i = 0;i < MaxJoys;i++)\r\n\t\tif (JoysPresent[i])\r\n\t\t\twhile (IN_GetJoyButtonsDB(i))\r\n\t\t\t\t;\r\n\r\n\tIN_AckBack();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_IsUserInput() - Returns true if a key has been pressed or a button\r\n//\t\tis down\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nIN_IsUserInput(void)\r\n{\r\n\tboolean\tresult;\r\n\tword\ti;\r\n\r\n\tresult = LastScan;\r\n\r\n\tif (MousePresent)\r\n\t\tif (INL_GetMouseButtons())\r\n\t\t\tresult = true;\r\n\r\n\tfor (i = 0;i < MaxJoys;i++)\r\n\t\tif (JoysPresent[i])\r\n\t\t\tif (INL_GetJoyButtons(i))\r\n\t\t\t\tresult = true;\r\n\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tIN_UserInput() - Waits for the specified delay time (in ticks) or the\r\n//\t\tuser pressing a key or a mouse button. If the clear flag is set, it\r\n//\t\tthen either clears the key or waits for the user to let the mouse\r\n//\t\tbutton up.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nIN_UserInput(longword delay,boolean clear)\r\n{\r\n\tlongword\tlasttime;\r\n\r\n\tlasttime = TimeCount;\r\n\tdo\r\n\t{\r\n\t\tif (IN_IsUserInput())\r\n\t\t{\r\n\t\t\tif (clear)\r\n\t\t\t\tIN_AckBack();\r\n\t\t\treturn(true);\r\n\t\t}\r\n\t} while (TimeCount - lasttime < delay);\r\n\treturn(false);\r\n}\r\n"
        },
        {
          "name": "id_in.h",
          "type": "blob",
          "size": 5.1279296875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n//\tID Engine\r\n//\tID_IN.h - Header file for Input Manager\r\n//\tv1.0d1\r\n//\tBy Jason Blochowiak\r\n//\r\n\r\n#ifndef\t__TYPES__\r\n#include \"ID_Types.h\"\r\n#endif\r\n\r\n#ifndef\t__ID_IN__\r\n#define\t__ID_IN__\r\n\r\n#ifdef\t__DEBUG__\r\n#define\t__DEBUG_InputMgr__\r\n#endif\r\n\r\n#define\tMaxPlayers\t4\r\n#define\tMaxKbds\t\t2\r\n#define\tMaxJoys\t\t2\r\n#define\tNumCodes\t128\r\n\r\ntypedef\tbyte\t\tScanCode;\r\n#define\tsc_None\t\t\t0\r\n#define\tsc_Bad\t\t\t0xff\r\n#define\tsc_Return\t\t0x1c\r\n#define\tsc_Escape\t\t0x01\r\n#define\tsc_Space\t\t0x39\r\n#define\tsc_BackSpace\t0x0e\r\n#define\tsc_Tab\t\t\t0x0f\r\n#define\tsc_Alt\t\t\t0x38\r\n#define\tsc_Control\t\t0x1d\r\n#define\tsc_CapsLock\t\t0x3a\r\n#define\tsc_LShift\t\t0x2a\r\n#define\tsc_RShift\t\t0x36\r\n#define\tsc_UpArrow\t\t0x48\r\n#define\tsc_DownArrow\t0x50\r\n#define\tsc_LeftArrow\t0x4b\r\n#define\tsc_RightArrow\t0x4d\r\n#define\tsc_Insert\t\t0x52\r\n#define\tsc_Delete\t\t0x53\r\n#define\tsc_Home\t\t\t0x47\r\n#define\tsc_End\t\t\t0x4f\r\n#define\tsc_PgUp\t\t\t0x49\r\n#define\tsc_PgDn\t\t\t0x51\r\n#define\tsc_F1\t\t\t0x3b\r\n#define\tsc_F2\t\t\t0x3c\r\n#define\tsc_F3\t\t\t0x3d\r\n#define\tsc_F4\t\t\t0x3e\r\n#define\tsc_F5\t\t\t0x3f\r\n#define\tsc_F6\t\t\t0x40\r\n#define\tsc_F7\t\t\t0x41\r\n#define\tsc_F8\t\t\t0x42\r\n#define\tsc_F9\t\t\t0x43\r\n#define\tsc_F10\t\t\t0x44\r\n#define\tsc_F11\t\t\t0x57\r\n#define\tsc_F12\t\t\t0x59\r\n\r\n#define\tsc_A\t\t\t0x1e\r\n#define\tsc_B\t\t\t0x30\r\n#define\tsc_C\t\t\t0x2e\r\n#define\tsc_D\t\t\t0x20\r\n#define\tsc_E\t\t\t0x12\r\n#define\tsc_F\t\t\t0x21\r\n#define\tsc_G\t\t\t0x22\r\n#define\tsc_H\t\t\t0x23\r\n#define\tsc_I\t\t\t0x17\r\n#define\tsc_J\t\t\t0x24\r\n#define\tsc_K\t\t\t0x25\r\n#define\tsc_L\t\t\t0x26\r\n#define\tsc_M\t\t\t0x32\r\n#define\tsc_N\t\t\t0x31\r\n#define\tsc_O\t\t\t0x18\r\n#define\tsc_P\t\t\t0x19\r\n#define\tsc_Q\t\t\t0x10\r\n#define\tsc_R\t\t\t0x13\r\n#define\tsc_S\t\t\t0x1f\r\n#define\tsc_T\t\t\t0x14\r\n#define\tsc_U\t\t\t0x16\r\n#define\tsc_V\t\t\t0x2f\r\n#define\tsc_W\t\t\t0x11\r\n#define\tsc_X\t\t\t0x2d\r\n#define\tsc_Y\t\t\t0x15\r\n#define\tsc_Z\t\t\t0x2c\r\n\r\n#define\tkey_None\t\t0\r\n#define\tkey_Return\t\t0x0d\r\n#define\tkey_Escape\t\t0x1b\r\n#define\tkey_Space\t\t0x20\r\n#define\tkey_BackSpace\t0x08\r\n#define\tkey_Tab\t\t\t0x09\r\n#define\tkey_Delete\t\t0x7f\r\n\r\ntypedef\tenum\t\t{\r\n\t\t\t\t\t\tdemo_Off,demo_Record,demo_Playback,demo_PlayDone\r\n\t\t\t\t\t} Demo;\r\ntypedef\tenum\t\t{\r\n\t\t\t\t\t\tctrl_Keyboard,\r\n\t\t\t\t\t\t\tctrl_Keyboard1 = ctrl_Keyboard,ctrl_Keyboard2,\r\n\t\t\t\t\t\tctrl_Joystick,\r\n\t\t\t\t\t\t\tctrl_Joystick1 = ctrl_Joystick,ctrl_Joystick2,\r\n\t\t\t\t\t\tctrl_Mouse\r\n\t\t\t\t\t} ControlType;\r\ntypedef\tenum\t\t{\r\n\t\t\t\t\t\tmotion_Left = -1,motion_Up = -1,\r\n\t\t\t\t\t\tmotion_None = 0,\r\n\t\t\t\t\t\tmotion_Right = 1,motion_Down = 1\r\n\t\t\t\t\t} Motion;\r\ntypedef\tenum\t\t{\r\n\t\t\t\t\t\tdir_North,dir_NorthEast,\r\n\t\t\t\t\t\tdir_East,dir_SouthEast,\r\n\t\t\t\t\t\tdir_South,dir_SouthWest,\r\n\t\t\t\t\t\tdir_West,dir_NorthWest,\r\n\t\t\t\t\t\tdir_None\r\n\t\t\t\t\t} Direction;\r\ntypedef\tstruct\t\t{\r\n\t\t\t\t\t\tboolean\t\tbutton0,button1;\r\n\t\t\t\t\t\tint\t\t\tx,y;\r\n\t\t\t\t\t\tMotion\t\txaxis,yaxis;\r\n\t\t\t\t\t\tDirection\tdir;\r\n\t\t\t\t\t} CursorInfo;\r\ntypedef\tCursorInfo\tControlInfo;\r\ntypedef\tstruct\t\t{\r\n\t\t\t\t\t\tScanCode\tbutton0,button1,\r\n\t\t\t\t\t\t\t\t\tupleft,\t\tup,\t\tupright,\r\n\t\t\t\t\t\t\t\t\tleft,\t\t\t\tright,\r\n\t\t\t\t\t\t\t\t\tdownleft,\tdown,\tdownright;\r\n\t\t\t\t\t} KeyboardDef;\r\ntypedef\tstruct\t\t{\r\n\t\t\t\t\t\tword\t\tjoyMinX,joyMinY,\r\n\t\t\t\t\t\t\t\t\tthreshMinX,threshMinY,\r\n\t\t\t\t\t\t\t\t\tthreshMaxX,threshMaxY,\r\n\t\t\t\t\t\t\t\t\tjoyMaxX,joyMaxY,\r\n\t\t\t\t\t\t\t\t\tjoyMultXL,joyMultYL,\r\n\t\t\t\t\t\t\t\t\tjoyMultXH,joyMultYH;\r\n\t\t\t\t\t} JoystickDef;\r\n// Global variables\r\nextern\tboolean\t\tKeyboard[],\r\n\t\t\t\t\tMousePresent,\r\n\t\t\t\t\tJoysPresent[];\r\nextern\tDemo\t\tDemoMode;\r\nextern\tboolean\t\tPaused;\r\nextern\tchar\t\tLastASCII;\r\nextern\tScanCode\tLastScan;\r\nextern\tKeyboardDef\tKbdDefs[];\r\nextern\tJoystickDef\tJoyDefs[];\r\nextern\tControlType\tControls[MaxPlayers];\r\n\r\n// Function prototypes\r\n#define\tIN_KeyDown(code)\t(Keyboard[(code)])\r\n#define\tIN_ClearKey(code)\t{Keyboard[code] = false;\\\r\n\t\t\t\t\t\t\tif (code == LastScan) LastScan = sc_None;}\r\n\r\n// DEBUG - put names in prototypes\r\nextern\tvoid\t\tIN_Startup(void),IN_Shutdown(void),\r\n\t\t\t\t\tIN_Default(boolean gotit,ControlType in),\r\n\t\t\t\t\tIN_SetKeyHook(void (*)()),\r\n\t\t\t\t\tIN_ClearKeysDown(void),\r\n\t\t\t\t\tIN_ReadCursor(CursorInfo *),\r\n\t\t\t\t\tIN_ReadControl(int,ControlInfo *),\r\n\t\t\t\t\tIN_SetControlType(int,ControlType),\r\n\t\t\t\t\tIN_GetJoyAbs(word joy,word *xp,word *yp),\r\n\t\t\t\t\tIN_SetupJoy(word joy,word minx,word maxx,\r\n\t\t\t\t\t\t\t\tword miny,word maxy),\r\n\t\t\t\t\tIN_StartDemoPlayback(byte _seg *buffer,word bufsize),\r\n\t\t\t\t\tIN_StopDemo(void),IN_FreeDemoBuffer(void),\r\n\t\t\t\t\tIN_Ack(void),IN_AckBack(void);\r\nextern\tboolean\t\tIN_UserInput(longword delay,boolean clear),\r\n\t\t\t\t\tIN_IsUserInput(void),\r\n\t\t\t\t\tIN_StartDemoRecord(word bufsize);\r\nextern\tbyte\t\t*IN_GetScanName(ScanCode);\r\nextern\tchar\t\tIN_WaitForASCII(void);\r\nextern\tScanCode\tIN_WaitForKey(void);\r\nextern\tword\t\tIN_GetJoyButtonsDB(word joy);\r\n\r\n#endif\r\n"
        },
        {
          "name": "id_mm.c",
          "type": "blob",
          "size": 14.9560546875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// NEWMM.C\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t   ID software memory manager\r\n\t\t   --------------------------\r\n\r\nPrimary coder: John Carmack\r\n\r\nRELIES ON\r\n---------\r\nQuit (char *error) function\r\n\r\n\r\nWORK TO DO\r\n----------\r\nSoft error on out of memory\r\n\r\nEMS 64k frame, upper memory block mapping\r\n\r\nMM_SizePtr to change the size of a given pointer\r\n\r\nMultiple purge levels utilized\r\n\r\nEMS / XMS unmanaged routines\r\n\r\n=============================================================================\r\n*/\r\n\r\n#include \"ID_HEADS.H\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tLOCAL INFO\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define EMSINT\t\t0x67\r\n\r\n#define LOCKBIT\t\t0x80\t// if set in attributes, block cannot be moved\r\n#define PURGEBITS\t3\t\t// 0-3 level, 0= unpurgable, 3= purge first\r\n#define PURGEMASK\t0xfffc\r\n#define BASEATTRIBUTES\t0\t// unlocked, non purgable\r\n\r\ntypedef struct mmblockstruct\r\n{\r\n\tunsigned\tstart,length;\r\n\tunsigned\tattributes;\r\n\tmemptr\t\t*useptr;\t// pointer to the segment start\r\n\tstruct mmblockstruct far *next;\r\n} mmblocktype;\r\n\r\n\r\n#define GETNEWBLOCK {if(!(mmnew=mmfree))Quit(\"MM_GETNEWBLOCK: No free blocks!\")\\\r\n\t;mmfree=mmfree->next;}\r\n\r\n#define FREEBLOCK(x) {*x->useptr=NULL;x->next=mmfree;mmfree=x;}\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nmminfotype\tmminfo;\r\nmemptr\t\tbufferseg;\r\nboolean\t\tbombonerror;\r\n\r\nvoid\t\t(* beforesort) (void);\r\nvoid\t\t(* aftersort) (void);\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nboolean\t\tmmstarted;\r\n\r\nvoid far\t*farheap;\r\nvoid\t\t*nearheap;\r\n\r\nmmblocktype\tfar mmblocks[MAXBLOCKS]\r\n\t\t\t,far *mmhead,far *mmfree,far *mmrover,far *mmnew;\r\n\r\n//==========================================================================\r\n\r\n//\r\n// local prototypes\r\n//\r\n\r\nboolean\t\tMML_CheckForEMS (void);\r\nvoid \t\tMML_ShutdownEMS (void);\r\nvoid \t\tMM_MapEMS (void);\r\nboolean \tMML_CheckForXMS (void);\r\nvoid \t\tMML_ShutdownXMS (void);\r\n\r\n//==========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= MML_CheckForEMS\r\n=\r\n= Routine from p36 of Extending DOS\r\n=\r\n=======================\r\n*/\r\n\r\nboolean MML_CheckForEMS (void)\r\n{\r\n  char\temmname[9] = \"EMMXXXX0\";\r\n\r\nasm\tmov\tdx,OFFSET emmname\r\nasm\tmov\tax,0x3d00\r\nasm\tint\t0x21\t\t// try to open EMMXXXX0 device\r\nasm\tjc\terror\r\n\r\nasm\tmov\tbx,ax\r\nasm\tmov\tax,0x4400\r\n\r\nasm\tint\t0x21\t\t// get device info\r\nasm\tjc\terror\r\n\r\nasm\tand\tdx,0x80\r\nasm\tjz\terror\r\n\r\nasm\tmov\tax,0x4407\r\n\r\nasm\tint\t0x21\t\t// get status\r\nasm\tjc\terror\r\nasm\tor\tal,al\r\nasm\tjz\terror\r\n\r\nasm\tmov\tah,0x3e\r\nasm\tint\t0x21\t\t// close handle\r\nasm\tjc\terror\r\n\r\n//\r\n// EMS is good\r\n//\r\n  return true;\r\n\r\nerror:\r\n//\r\n// EMS is bad\r\n//\r\n  return false;\r\n}\r\n\r\n/*\r\n======================\r\n=\r\n= MML_ShutdownEMS\r\n=\r\n=======================\r\n*/\r\n\r\nvoid MML_ShutdownEMS (void)\r\n{\r\n\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= MM_MapEMS\r\n=\r\n= Maps the 64k of EMS used by memory manager into the page frame\r\n= for general use.  This only needs to be called if you are keeping\r\n= other things in EMS.\r\n=\r\n====================\r\n*/\r\n\r\nvoid MM_MapEMS (void)\r\n{\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= MML_CheckForXMS\r\n=\r\n= Try to allocate an upper memory block\r\n=\r\n=======================\r\n*/\r\n\r\nboolean MML_CheckForXMS (void)\r\n{\r\n\r\n\treturn false;\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= MML_ShutdownXMS\r\n=\r\n=======================\r\n*/\r\n\r\nvoid MML_ShutdownXMS (void)\r\n{\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n===================\r\n=\r\n= MM_Startup\r\n=\r\n= Grabs all space from turbo with malloc/farmalloc\r\n= Allocates bufferseg misc buffer\r\n=\r\n===================\r\n*/\r\n\r\nvoid MM_Startup (void)\r\n{\r\n\tint i;\r\n\tunsigned \tlong length;\r\n\tvoid far \t*start;\r\n\tunsigned \tsegstart,seglength,endfree;\r\n\r\n\tif (mmstarted)\r\n\t\tMM_Shutdown ();\r\n\r\n\tmmstarted = true;\r\n\tbombonerror = true;\r\n\r\n//\r\n// set up the linked list (everything in the free list;\r\n//\r\n\tmmhead = NULL;\r\n\tmmfree = &mmblocks[0];\r\n\tfor (i=0;i<MAXBLOCKS-1;i++)\r\n\t\tmmblocks[i].next = &mmblocks[i+1];\r\n\tmmblocks[i].next = NULL;\r\n\r\n//\r\n// get all available near conventional memory segments\r\n//\r\n\tlength=coreleft();\r\n\tstart = (void far *)(nearheap = malloc(length));\r\n\r\n\tlength -= 16-(FP_OFF(start)&15);\r\n\tlength -= SAVENEARHEAP;\r\n\tseglength = length / 16;\t\t\t// now in paragraphs\r\n\tsegstart = FP_SEG(start)+(FP_OFF(start)+15)/16;\r\n\tmminfo.nearheap = length;\r\n\r\n\t// locked block of unusable low memory\r\n\t// from 0 to start of near heap\r\n\tGETNEWBLOCK;\r\n\tmmhead = mmnew;\t\t\t\t// this will allways be the first node\r\n\tmmnew->start = 0;\r\n\tmmnew->length = segstart;\r\n\tmmnew->attributes = LOCKBIT;\r\n\tendfree = segstart+seglength;\r\n\tmmrover = mmhead;\r\n\r\n//\r\n// get all available far conventional memory segments\r\n//\r\n\tlength=farcoreleft();\r\n\tstart = farheap = farmalloc(length);\r\n\r\n\tlength -= 16-(FP_OFF(start)&15);\r\n\tlength -= SAVEFARHEAP;\r\n\tseglength = length / 16;\t\t\t// now in paragraphs\r\n\tsegstart = FP_SEG(start)+(FP_OFF(start)+15)/16;\r\n\tmminfo.farheap = length;\r\n\tmminfo.mainmem = mminfo.nearheap + mminfo.farheap;\r\n\r\n\t// locked block of unusable near heap memory (usually just the stack)\r\n\t// from end of near heap to start of far heap\r\n\tGETNEWBLOCK;\r\n\tmmnew->start = endfree;\r\n\tmmnew->length = segstart-endfree;\r\n\tmmnew->attributes = LOCKBIT;\r\n\tmmrover->next = mmnew;\r\n\tendfree = segstart+seglength;\r\n\tmmrover = mmnew;\r\n\r\n\r\n//\r\n// detect EMS and allocate 64K at page frame\r\n//\r\n\tif (MML_CheckForEMS())\r\n\t{\r\n\t\tMM_MapEMS();\t\t\t\t\t// map in used pages\r\n\t\tmminfo.EMSmem = 0x10000l;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmminfo.EMSmem = 0;\r\n\t}\r\n\r\n//\r\n// detect XMS and get upper memory blocks\r\n//\r\n\tif (MML_CheckForXMS())\r\n\t{\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmminfo.XMSmem = 0;\r\n\t}\r\n\r\n\r\n//\r\n// cap off the list\r\n//\r\n\t// locked block of high memory (video, rom, etc)\r\n\t// from end of far heap or EMS/XMS to 0xffff\r\n\tGETNEWBLOCK;\r\n\tmmnew->start = endfree;\r\n\tmmnew->length = 0xffff-endfree;\r\n\tmmnew->attributes = LOCKBIT;\r\n\tmmnew->next = NULL;\r\n\tmmrover->next = mmnew;\r\n\r\n//\r\n// allocate the misc buffer\r\n//\r\n\tmmrover = mmhead;\t\t// start looking for space after low block\r\n\r\n\tMM_GetPtr (&bufferseg,BUFFERSIZE);\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= MM_Shutdown\r\n=\r\n= Frees all conventional, EMS, and XMS allocated\r\n=\r\n====================\r\n*/\r\n\r\nvoid MM_Shutdown (void)\r\n{\r\n  if (!mmstarted)\r\n\treturn;\r\n\r\n  farfree (farheap);\r\n  free (nearheap);\r\n  MML_ShutdownEMS ();\r\n  MML_ShutdownXMS ();\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= MM_GetPtr\r\n=\r\n= Allocates an unlocked, unpurgable block\r\n=\r\n====================\r\n*/\r\n\r\nvoid MM_GetPtr (memptr *baseptr,unsigned long size)\r\n{\r\n\tmmblocktype far *scan,far *lastscan,far *endscan\r\n\t\t\t\t,far *purge,far *next;\r\n\tint\t\t\tsearch;\r\n\tunsigned\tneeded,startseg;\r\n\r\n\tneeded = (size+15)/16;\t\t// convert size from bytes to paragraphs\r\n\r\n\tGETNEWBLOCK;\t\t\t\t// fill in start and next after a spot is found\r\n\tmmnew->length = needed;\r\n\tmmnew->useptr = baseptr;\r\n\tmmnew->attributes = BASEATTRIBUTES;\r\n\r\n\tfor (search = 0; search<3; search++)\r\n\t{\r\n\t//\r\n\t// first search:\ttry to allocate right after the rover, then on up\r\n\t// second search: \tsearch from the head pointer up to the rover\r\n\t// third search:\tcompress memory, then scan from start\r\n\t\tif (search == 1 && mmrover == mmhead)\r\n\t\t\tsearch++;\r\n\r\n\t\tswitch (search)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tlastscan = mmrover;\r\n\t\t\tscan = mmrover->next;\r\n\t\t\tendscan = NULL;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tlastscan = mmhead;\r\n\t\t\tscan = mmhead->next;\r\n\t\t\tendscan = mmrover;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tMM_SortMem ();\r\n\t\t\tlastscan = mmhead;\r\n\t\t\tscan = mmhead->next;\r\n\t\t\tendscan = NULL;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tstartseg = lastscan->start + lastscan->length;\r\n\r\n\t\twhile (scan != endscan)\r\n\t\t{\r\n\t\t\tif (scan->start - startseg >= needed)\r\n\t\t\t{\r\n\t\t\t//\r\n\t\t\t// got enough space between the end of lastscan and\r\n\t\t\t// the start of scan, so throw out anything in the middle\r\n\t\t\t// and allocate the new block\r\n\t\t\t//\r\n\t\t\t\tpurge = lastscan->next;\r\n\t\t\t\tlastscan->next = mmnew;\r\n\t\t\t\tmmnew->start = *(unsigned *)baseptr = startseg;\r\n\t\t\t\tmmnew->next = scan;\r\n\t\t\t\twhile ( purge != scan)\r\n\t\t\t\t{\t// free the purgable block\r\n\t\t\t\t\tnext = purge->next;\r\n\t\t\t\t\tFREEBLOCK(purge);\r\n\t\t\t\t\tpurge = next;\t\t// purge another if not at scan\r\n\t\t\t\t}\r\n\t\t\t\tmmrover = mmnew;\r\n\t\t\t\treturn;\t// good allocation!\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\t\t\t// if this block is purge level zero or locked, skip past it\r\n\t\t\t//\r\n\t\t\tif ( (scan->attributes & LOCKBIT)\r\n\t\t\t\t|| !(scan->attributes & PURGEBITS) )\r\n\t\t\t{\r\n\t\t\t\tlastscan = scan;\r\n\t\t\t\tstartseg = lastscan->start + lastscan->length;\r\n\t\t\t}\r\n\r\n\r\n\t\t\tscan=scan->next;\t\t// look at next line\r\n\t\t}\r\n\t}\r\n\r\n\tQuit (\"Out of memory!  Please make sure you have enough free memory.\");\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= MM_FreePtr\r\n=\r\n= Allocates an unlocked, unpurgable block\r\n=\r\n====================\r\n*/\r\n\r\nvoid MM_FreePtr (memptr *baseptr)\r\n{\r\n\tmmblocktype far *scan,far *last;\r\n\r\n\tlast = mmhead;\r\n\tscan = last->next;\r\n\r\n\tif (baseptr == mmrover->useptr)\t// removed the last allocated block\r\n\t\tmmrover = mmhead;\r\n\r\n\twhile (scan->useptr != baseptr && scan)\r\n\t{\r\n\t\tlast = scan;\r\n\t\tscan = scan->next;\r\n\t}\r\n\r\n\tif (!scan)\r\n\t\tQuit (\"MM_FreePtr: Block not found!\");\r\n\r\n\tlast->next = scan->next;\r\n\r\n\tFREEBLOCK(scan);\r\n}\r\n//==========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= MM_SetPurge\r\n=\r\n= Sets the purge level for a block (locked blocks cannot be made purgable)\r\n=\r\n=====================\r\n*/\r\n\r\nvoid MM_SetPurge (memptr *baseptr, int purge)\r\n{\r\n\tmmblocktype far *start;\r\n\r\n\tstart = mmrover;\r\n\r\n\tdo\r\n\t{\r\n\t\tif (mmrover->useptr == baseptr)\r\n\t\t\tbreak;\r\n\r\n\t\tmmrover = mmrover->next;\r\n\r\n\t\tif (!mmrover)\r\n\t\t\tmmrover = mmhead;\r\n\t\telse if (mmrover == start)\r\n\t\t\tQuit (\"MM_SetPurge: Block not found!\");\r\n\r\n\t} while (1);\r\n\r\n\tmmrover->attributes &= ~PURGEBITS;\r\n\tmmrover->attributes |= purge;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= MM_SetLock\r\n=\r\n= Locks / unlocks the block\r\n=\r\n=====================\r\n*/\r\n\r\nvoid MM_SetLock (memptr *baseptr, boolean locked)\r\n{\r\n\tmmblocktype far *start;\r\n\r\n\tstart = mmrover;\r\n\r\n\tdo\r\n\t{\r\n\t\tif (mmrover->useptr == baseptr)\r\n\t\t\tbreak;\r\n\r\n\t\tmmrover = mmrover->next;\r\n\r\n\t\tif (!mmrover)\r\n\t\t\tmmrover = mmhead;\r\n\t\telse if (mmrover == start)\r\n\t\t\tQuit (\"MM_SetLock: Block not found!\");\r\n\r\n\t} while (1);\r\n\r\n\tmmrover->attributes &= ~LOCKBIT;\r\n\tmmrover->attributes |= locked*LOCKBIT;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= MM_SortMem\r\n=\r\n= Throws out all purgable stuff and compresses movable blocks\r\n=\r\n=====================\r\n*/\r\n\r\nvoid MM_SortMem (void)\r\n{\r\n\tmmblocktype far *scan,far *last,far *next;\r\n\tunsigned\tstart,length,source,dest;\r\n\r\n\tVW_ColorBorder (15);\r\n\r\n\tif (beforesort)\r\n\t\tbeforesort();\r\n\r\n\tscan = mmhead;\r\n\r\n\twhile (scan)\r\n\t{\r\n\t\tif (scan->attributes & LOCKBIT)\r\n\t\t{\r\n\t\t//\r\n\t\t// block is locked, so try to pile later blocks right after it\r\n\t\t//\r\n\t\t\tstart = scan->start + scan->length;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (scan->attributes & PURGEBITS)\r\n\t\t\t{\r\n\t\t\t//\r\n\t\t\t// throw out the purgable block\r\n\t\t\t//\r\n\t\t\t\tnext = scan->next;\r\n\t\t\t\tFREEBLOCK(scan);\r\n\t\t\t\tlast->next = next;\r\n\t\t\t\tscan = next;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t//\r\n\t\t\t// push the non purgable block on top of the last moved block\r\n\t\t\t//\r\n\t\t\t\tif (scan->start != start)\r\n\t\t\t\t{\r\n\t\t\t\t\tlength = scan->length;\r\n\t\t\t\t\tsource = scan->start;\r\n\t\t\t\t\tdest = start;\r\n\t\t\t\t\twhile (length > 0xf00)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmovedata(source,0,dest,0,0xf00*16);\r\n\t\t\t\t\t\tlength -= 0xf00;\r\n\t\t\t\t\t\tsource += 0xf00;\r\n\t\t\t\t\t\tdest += 0xf00;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmovedata(source,0,dest,0,length*16);\r\n\r\n\t\t\t\t\tscan->start = start;\r\n\t\t\t\t\t*(unsigned *)scan->useptr = start;\r\n\t\t\t\t}\r\n\t\t\t\tstart = scan->start + scan->length;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlast = scan;\r\n\t\tscan = scan->next;\t\t// go to next block\r\n\t}\r\n\r\n\tmmrover = mmhead;\r\n\r\n\tif (aftersort)\r\n\t\taftersort();\r\n\r\n\tVW_ColorBorder (0);\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= MM_ShowMemory\r\n=\r\n=====================\r\n*/\r\n\r\nvoid MM_ShowMemory (void)\r\n{\r\n\tmmblocktype far *scan;\r\n\tunsigned color,temp;\r\n\tlong\tend;\r\n\r\n\tVW_SetLineWidth(40);\r\n\ttemp = bufferofs;\r\n\tbufferofs = 0;\r\n\tVW_SetScreen (0,0);\r\n\r\n\tscan = mmhead;\r\n\r\n\tend = -1;\r\n\r\n\twhile (scan)\r\n\t{\r\n\t\tif (scan->attributes & PURGEBITS)\r\n\t\t\tcolor = 5;\t\t// dark purple = purgable\r\n\t\telse\r\n\t\t\tcolor = 9;\t\t// medium blue = non purgable\r\n\t\tif (scan->attributes & LOCKBIT)\r\n\t\t\tcolor = 12;\t\t// red = locked\r\n\t\tif (scan->start<=end)\r\n\t\t\tQuit (\"MM_ShowMemory: Memory block order currupted!\");\r\n\t\tend = scan->start+scan->length-1;\r\n\t\tVW_Hlin(scan->start,(unsigned)end,0,color);\r\n\t\tVW_Plot(scan->start,0,15);\r\n\t\tif (scan->next->start > end+1)\r\n\t\t\tVW_Hlin(end+1,scan->next->start,0,0);\t// black = free\r\n\t\tscan = scan->next;\r\n\t}\r\n\r\n\tIN_Ack();\r\n\tVW_SetLineWidth(64);\r\n\tbufferofs = temp;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= MM_UnusedMemory\r\n=\r\n= Returns the total free space without purging\r\n=\r\n======================\r\n*/\r\n\r\nlong MM_UnusedMemory (void)\r\n{\r\n\tunsigned free;\r\n\tmmblocktype far *scan;\r\n\r\n\tfree = 0;\r\n\tscan = mmhead;\r\n\r\n\twhile (scan->next)\r\n\t{\r\n\t\tfree += scan->next->start - (scan->start + scan->length);\r\n\t\tscan = scan->next;\r\n\t}\r\n\r\n\treturn free*16l;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= MM_TotalFree\r\n=\r\n= Returns the total free space with purging\r\n=\r\n======================\r\n*/\r\n\r\nlong MM_TotalFree (void)\r\n{\r\n\tunsigned free;\r\n\tmmblocktype far *scan;\r\n\r\n\tfree = 0;\r\n\tscan = mmhead;\r\n\r\n\twhile (scan->next)\r\n\t{\r\n\t\tif ((scan->attributes&PURGEBITS) && !(scan->attributes&LOCKBIT))\r\n\t\t\tfree += scan->length;\r\n\t\tfree += scan->next->start - (scan->start + scan->length);\r\n\t\tscan = scan->next;\r\n\t}\r\n\r\n\treturn free*16l;\r\n}\r\n\r\n"
        },
        {
          "name": "id_mm.h",
          "type": "blob",
          "size": 2.1044921875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// NEWMM.H\r\n\r\n#ifndef __ID_MM__\r\n\r\n#define __ID_MM__\r\n\r\n#ifndef __TYPES__\r\n#include \"ID_TYPES.H\"\r\n#endif\r\n\r\nvoid Quit (char *error);\r\n\r\n\r\n//==========================================================================\r\n\r\n#define SAVENEARHEAP\t0x400\t\t// space to leave in data segment\r\n#define SAVEFARHEAP\t\t0\t\t\t// space to leave in far heap\r\n\r\n#define\tBUFFERSIZE\t\t0x1000\t\t// miscelanious, allways available buffer\r\n\r\n#define MAXBLOCKS\t\t1300\r\n\r\n//==========================================================================\r\n\r\ntypedef void _seg * memptr;\r\n\r\ntypedef struct\r\n{\r\n\tlong\tnearheap,farheap,EMSmem,XMSmem,mainmem;\r\n} mminfotype;\r\n\r\n//==========================================================================\r\n\r\nextern\tmminfotype\tmminfo;\r\nextern\tmemptr\t\tbufferseg;\r\nextern\tboolean\t\tbombonerror;\r\n\r\nextern\tvoid\t\t(* beforesort) (void);\r\nextern\tvoid\t\t(* aftersort) (void);\r\n\r\n//==========================================================================\r\n\r\nvoid MM_Startup (void);\r\nvoid MM_Shutdown (void);\r\nvoid MM_MapEMS (void);\r\n\r\nvoid MM_GetPtr (memptr *baseptr,unsigned long size);\r\nvoid MM_FreePtr (memptr *baseptr);\r\n\r\nvoid MM_SetPurge (memptr *baseptr, int purge);\r\nvoid MM_SetLock (memptr *baseptr, boolean locked);\r\nvoid MM_SortMem (void);\r\n\r\nvoid MM_ShowMemory (void);\r\n\r\nlong MM_UnusedMemory (void);\r\nlong MM_TotalFree (void);\r\n\r\n\r\n#endif"
        },
        {
          "name": "id_rf.c",
          "type": "blob",
          "size": 50.7783203125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_RF.C\r\n\r\n/*\r\n=============================================================================\r\n\r\nnotes\r\n-----\r\n\r\nscrolling more than one tile / refresh forces a total redraw\r\n\r\ntwo overlapping sprites of equal priority can change drawing order when\r\nupdated\r\n\r\n=============================================================================\r\n*/\r\n\r\n#include \"ID_HEADS.H\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define\tSCREENTILESWIDE\t20\r\n#define\tSCREENTILESHIGH\t13\r\n\r\n#define\tSCREENSPACE\t\t(SCREENWIDTH*240)\r\n#define FREEEGAMEM\t\t(0x10000l-3l*SCREENSPACE)\r\n\r\n//\r\n// the update array must have enough space for two screens that can float\r\n// up two two tiles each way\r\n//\r\n// (PORTTILESWIDE+1)*PORTTILESHIGH must be even so the arrays can be cleared\r\n// by word width instructions\r\n\r\n#define\tUPDATESCREENSIZE\t(UPDATEWIDE*PORTTILESHIGH+2)\r\n#define\tUPDATESPARESIZE\t\t(UPDATEWIDE*2+4)\r\n#define UPDATESIZE\t\t\t(UPDATESCREENSIZE+2*UPDATESPARESIZE)\r\n\r\n#define G_EGASX_SHIFT\t7\t// global >> ?? = screen x\r\n#define G_CGASX_SHIFT\t6\t// global >> ?? = screen x\r\n#define G_SY_SHIFT\t\t4\t// global >> ?? = screen y\r\n\r\nunsigned\tSX_T_SHIFT;\t\t// screen x >> ?? = tile EGA = 1, CGA = 2;\r\n#define\tSY_T_SHIFT\t\t4\t// screen y >> ?? = tile\r\n\r\n\r\n#define\tEGAPORTSCREENWIDE\t42\r\n#define\tCGAPORTSCREENWIDE\t84\r\n#define\tPORTSCREENHIGH  224\r\n\r\n#define\tUPDATESCREENSIZE\t(UPDATEWIDE*PORTTILESHIGH+2)\r\n#define\tUPDATESPARESIZE\t\t(UPDATEWIDE*2+4)\r\n#define UPDATESIZE\t\t\t(UPDATESCREENSIZE+2*UPDATESPARESIZE)\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t   LOCAL TYPES\r\n\r\n=============================================================================\r\n*/\r\n\r\ntypedef\tstruct spriteliststruct\r\n{\r\n\tint\t\t\tscreenx,screeny;\r\n\tint\t\t\twidth,height;\r\n\r\n\tunsigned\tgrseg,sourceofs,planesize;\r\n\tdrawtype\tdraw;\r\n\tunsigned\ttilex,tiley,tilewide,tilehigh;\r\n\tint\t\t\tpriority,updatecount;\r\n\tstruct spriteliststruct **prevptr,*nextsprite;\r\n} spritelisttype;\r\n\r\n\r\ntypedef struct\r\n{\r\n\tint\t\t\tscreenx,screeny;\r\n\tint\t\t\twidth,height;\r\n} eraseblocktype;\r\n\r\n\r\ntypedef struct\r\n{\r\n\tunsigned\tcurrent;\t\t// foreground tiles have high bit set\r\n\tint\t\t\tcount;\r\n} tiletype;\r\n\r\n\r\ntypedef struct animtilestruct\r\n{\r\n\tunsigned\tx,y,tile;\r\n\ttiletype\t*chain;\r\n\tunsigned\tfar *mapplane;\r\n\tstruct animtilestruct **prevptr,*nexttile;\r\n} animtiletype;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nunsigned\ttics;\r\nlong\t\tlasttimecount;\r\n\r\nboolean\t\tcompatability;\t\t\t// crippled refresh for wierdo SVGAs\r\n\r\nunsigned\tmapwidth,mapheight,mapbyteswide,mapwordswide\r\n\t\t\t,mapbytesextra,mapwordsextra;\r\nunsigned\tmapbwidthtable[MAXMAPHEIGHT];\r\n\r\n//\r\n// Global : Actor coordinates are in this, at 1/16 th of a pixel, to allow\r\n// for fractional movement and acceleration.\r\n//\r\n// Tiles  : Tile offsets from the upper left corner of the current map.\r\n//\r\n// Screen : Graphics level offsets from map origin, x in bytes, y in pixels.\r\n// originxscreen is the same spot as originxtile, just with extra precision\r\n// so graphics don't need to be done in tile boundaries.\r\n//\r\n\r\nunsigned\toriginxglobal,originyglobal;\r\nunsigned\toriginxtile,originytile;\r\nunsigned\toriginxscreen,originyscreen;\r\nunsigned\toriginmap;\r\nunsigned\toriginxmin,originxmax,originymin,originymax;\r\nunsigned\toriginxtile,originytile;\r\n\r\nunsigned\tmasterofs;\r\n\r\n//\r\n// Table of the offsets from bufferofs of each tile spot in the\r\n// view port.  The extra wide tile should never be drawn, but the space\r\n// is needed to account for the extra 0 in the update arrays.  Built by\r\n// RF_Startup\r\n//\r\n\r\nunsigned\tblockstarts[UPDATEWIDE*UPDATEHIGH];\r\nunsigned\tupdatemapofs[UPDATEWIDE*UPDATEHIGH];\r\n\r\nunsigned\tuwidthtable[PORTTILESHIGH];\t\t// lookup instead of multiply\r\n\r\nbyte\t\tupdate[2][UPDATESIZE];\r\nbyte\t\t*updateptr,*baseupdateptr,\t\t\t\t\t\t// current start of update window\r\n\t\t\t*updatestart[2],\r\n\t\t\t*baseupdatestart[2];\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nstatic\t\tchar\tscratch[20],str[20];\r\n\r\ntiletype\tallanims[MAXANIMTYPES];\r\nunsigned\tnumanimchains;\r\n\r\nvoid \t\t(*refreshvector) (void);\r\n\r\nunsigned\tscreenstart[3] =\r\n\t{0,SCREENSPACE,SCREENSPACE*2};\r\n\r\nunsigned\txpanmask;\t\t\t// prevent panning to odd pixels\r\n\r\nunsigned\tscreenpage;\t\t\t// screen currently being displayed\r\nunsigned\totherpage;\r\n\r\n#if GRMODE == EGAGR\r\nunsigned\ttilecache[NUMTILE16];\r\n#endif\r\n\r\nspritelisttype\tspritearray[MAXSPRITES],*prioritystart[PRIORITIES],\r\n\t\t\t\t*spritefreeptr;\r\n\r\nanimtiletype\tanimarray[MAXANIMTILES],*animhead,*animfreeptr;\r\n\r\nint\t\t\t\tanimfreespot;\r\n\r\neraseblocktype\teraselist[2][MAXSPRITES],*eraselistptr[2];\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL PROTOTYPES\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid RFL_NewTile (unsigned updateoffset);\r\nvoid RFL_MaskForegroundTiles (void);\r\nvoid RFL_UpdateTiles (void);\r\n\r\nvoid RFL_CalcOriginStuff (long x, long y);\r\nvoid RFL_InitSpriteList (void);\r\nvoid RFL_InitAnimList (void);\r\nvoid RFL_CheckForAnimTile (unsigned x, unsigned y);\r\nvoid RFL_AnimateTiles (void);\r\nvoid RFL_RemoveAnimsOnX (unsigned x);\r\nvoid RFL_RemoveAnimsOnY (unsigned y);\r\nvoid RFL_EraseBlocks (void);\r\nvoid RFL_UpdateSprites (void);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t GRMODE INDEPENDANT ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_Startup\r\n=\r\n=====================\r\n*/\r\n\r\nstatic\tchar *ParmStrings[] = {\"comp\",\"\"};\r\n\r\nvoid RF_Startup (void)\r\n{\r\n\tint i,x,y;\r\n\tunsigned\t*blockstart;\r\n\r\n\tif (grmode == EGAGR)\r\n\t\tfor (i = 1;i < _argc;i++)\r\n\t\t\tif (US_CheckParm(_argv[i],ParmStrings) == 0)\r\n\t\t\t{\r\n\t\t\t\tcompatability = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\tfor (i=0;i<PORTTILESHIGH;i++)\r\n\t\tuwidthtable[i] = UPDATEWIDE*i;\r\n\r\n\toriginxmin = originymin = MAPBORDER*TILEGLOBAL;\r\n\r\n\teraselistptr[0] = &eraselist[0][0];\r\n\teraselistptr[1] = &eraselist[1][0];\r\n\r\n\r\n\r\n\tif (grmode == EGAGR)\r\n\t{\r\n\t\tSX_T_SHIFT = 1;\r\n\r\n\t\tbaseupdatestart[0] = &update[0][UPDATESPARESIZE];\r\n\t\tbaseupdatestart[1] = &update[1][UPDATESPARESIZE];\r\n\r\n\t\tscreenpage = 0;\r\n\t\totherpage = 1;\r\n\t\tdisplayofs = screenstart[screenpage];\r\n\t\tbufferofs = screenstart[otherpage];\r\n\t\tmasterofs = screenstart[2];\r\n\r\n\t\tupdateptr = baseupdatestart[otherpage];\r\n\r\n\t\tblockstart = &blockstarts[0];\r\n\t\tfor (y=0;y<UPDATEHIGH;y++)\r\n\t\t\tfor (x=0;x<UPDATEWIDE;x++)\r\n\t\t\t\t*blockstart++ = SCREENWIDTH*16*y+x*TILEWIDTH;\r\n\r\n\t\txpanmask = 6;\t// dont pan to odd pixels\r\n\t}\r\n\r\n\telse if (grmode == CGAGR)\r\n\t{\r\n\t\tSX_T_SHIFT = 2;\r\n\r\n\t\tupdateptr = baseupdateptr = &update[0][UPDATESPARESIZE];\r\n\r\n\t\tbufferofs = 0;\r\n\t\tmasterofs = 0x8000;\r\n\r\n\t\tblockstart = &blockstarts[0];\r\n\t\tfor (y=0;y<UPDATEHIGH;y++)\r\n\t\t\tfor (x=0;x<UPDATEWIDE;x++)\r\n\t\t\t\t*blockstart++ = SCREENWIDTH*16*y+x*TILEWIDTH;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_Shutdown\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_Shutdown (void)\r\n{\r\n\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_NewMap\r\n=\r\n= Makes some convienient calculations based on maphead->\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_NewMap (void)\r\n{\r\n\tint i,x,y;\r\n\tunsigned spot,*table;\r\n\r\n\tmapwidth = mapheaderseg[mapon]->width;\r\n\tmapbyteswide = 2*mapwidth;\r\n\tmapheight = mapheaderseg[mapon]->height;\r\n\tmapwordsextra = mapwidth-PORTTILESWIDE;\r\n\tmapbytesextra = 2*mapwordsextra;\r\n\r\n//\r\n// make a lookup table for the maps left edge\r\n//\r\n\tspot = 0;\r\n\tfor (i=0;i<mapheight;i++)\r\n\t{\r\n\t  mapbwidthtable[i] = spot;\r\n\t  spot += mapbyteswide;\r\n\t}\r\n\r\n//\r\n// fill in updatemapofs with the new width info\r\n//\r\n\ttable = &updatemapofs[0];\r\n\tfor (y=0;y<PORTTILESHIGH;y++)\r\n\t\tfor (x=0;x<UPDATEWIDE;x++)\r\n\t\t\t*table++ = mapbwidthtable[y]+x*2;\r\n\r\n\r\n//\r\n// the y max value clips off the bottom half of a tile so a map that is\r\n// 13 + MAPBORDER*2 tile high will not scroll at all vertically\r\n//\r\n\toriginxmax = (mapwidth-MAPBORDER-SCREENTILESWIDE)*TILEGLOBAL;\r\n\toriginymax = (mapheight-MAPBORDER-SCREENTILESHIGH)*TILEGLOBAL;\r\n\tif (originxmax<originxmin)\t\t// for very small maps\r\n\t\toriginxmax=originxmin;\r\n\tif (originymax<originymin)\r\n\t\toriginymax=originymin;\r\n\r\n//\r\n// clear out the lists\r\n//\r\n\tRFL_InitSpriteList ();\r\n\tRFL_InitAnimList ();\r\n\r\n\r\n\tlasttimecount = TimeCount;\t\t// setup for adaptive timing\r\n\ttics = 1;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= RF_MarkTileGraphics\r\n=\r\n= Goes through mapplane[0/1] and marks all background/foreground tiles\r\n= needed, then follows all animation sequences to make sure animated\r\n= tiles get all the stages.  Every unique animating tile is given an\r\n= entry in allanims[], so every instance of that tile will animate at the\r\n= same rate.  The info plane for each animating tile will hold a pointer\r\n= into allanims[], therefore you can't have both an animating foreground\r\n= and background tile in the same spot!\r\n=\r\n==========================\r\n*/\r\n\r\nvoid RF_MarkTileGraphics (void)\r\n{\r\n\tunsigned\tsize;\r\n\tint\t\t\ttile,next,anims;\r\n\tunsigned\tfar\t*start,far *end,far *info;\r\n\tunsigned\ti,tilehigh;\r\n\r\n\tmemset (allanims,0,sizeof(allanims));\r\n\tnumanimchains = 0;\r\n\r\n\tsize = mapwidth*mapheight;\r\n\r\n//\r\n// background plane\r\n//\r\n\tstart = mapsegs[0];\r\n\tinfo = mapsegs[2];\r\n\tend = start+size;\r\n\tdo\r\n\t{\r\n\t\ttile = *start++;\r\n\t\tif (tile>=0)\t\t\t// <0 is a tile that is never drawn\r\n\t\t{\r\n\t\t\tCA_MarkGrChunk(STARTTILE16+tile);\r\n\t\t\tif (tinf[ANIM+tile])\r\n\t\t\t{\r\n\t\t\t\t// this tile will animated\r\n\r\n\t\t\t\tfor (i=0;i<numanimchains;i++)\r\n\t\t\t\t\tif (allanims[i].current == tile)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*info = (unsigned)&allanims[i];\r\n\t\t\t\t\t\tgoto nextback;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// new chain of animating tiles\r\n\r\n\t\t\t\tif (i>=MAXANIMTYPES)\r\n\t\t\t\t\tQuit (\"RF_MarkTileGraphics: Too many unique animated tiles!\");\r\n\t\t\t\tallanims[i].current = tile;\r\n\t\t\t\tallanims[i].count = tinf[SPEED+tile];\r\n\r\n\t\t\t\t*info = (unsigned)&allanims[i];\r\n\t\t\t\tnumanimchains++;\r\n\r\n\t\t\t\tanims = 0;\r\n\t\t\t\tnext = tile+(signed char)(tinf[ANIM+tile]);\r\n\t\t\t\twhile (next != tile)\r\n\t\t\t\t{\r\n\t\t\t\t\tCA_MarkGrChunk(STARTTILE16+next);\r\n\t\t\t\t\tnext += (signed char)(tinf[ANIM+next]);\r\n\t\t\t\t\tif (++anims > 20)\r\n\t\t\t\t\t\tQuit (\"MarkTileGraphics: Unending animation!\");\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\nnextback:\r\n\t\tinfo++;\r\n\t} while (start<end);\r\n\r\n//\r\n// foreground plane\r\n//\r\n\tstart = mapsegs[1];\r\n\tinfo = mapsegs[2];\r\n\tend = start+size;\r\n\tdo\r\n\t{\r\n\t\ttile = *start++;\r\n\t\tif (tile>=0)\t\t\t// <0 is a tile that is never drawn\r\n\t\t{\r\n\t\t\tCA_MarkGrChunk(STARTTILE16M+tile);\r\n\t\t\tif (tinf[MANIM+tile])\r\n\t\t\t{\r\n\t\t\t\t// this tile will animated\r\n\r\n\t\t\t\ttilehigh = tile | 0x8000;\t// foreground tiles have high bit\r\n\t\t\t\tfor (i=0;i<numanimchains;i++)\r\n\t\t\t\t\tif (allanims[i].current == tilehigh)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t*info = (unsigned)&allanims[i];\r\n\t\t\t\t\t\tgoto nextfront;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t// new chain of animating tiles\r\n\r\n\t\t\t\tif (i>=MAXANIMTYPES)\r\n\t\t\t\t\tQuit (\"RF_MarkTileGraphics: Too many unique animated tiles!\");\r\n\t\t\t\tallanims[i].current = tilehigh;\r\n\t\t\t\tallanims[i].count = tinf[MSPEED+tile];\r\n\r\n\t\t\t\t*info = (unsigned)&allanims[i];\r\n\t\t\t\tnumanimchains++;\r\n\r\n\t\t\t\tanims = 0;\r\n\t\t\t\tnext = tile+(signed char)(tinf[MANIM+tile]);\r\n\t\t\t\twhile (next != tile)\r\n\t\t\t\t{\r\n\t\t\t\t\tCA_MarkGrChunk(STARTTILE16M+next);\r\n\t\t\t\t\tnext += (signed char)(tinf[MANIM+next]);\r\n\t\t\t\t\tif (++anims > 20)\r\n\t\t\t\t\t\tQuit (\"MarkTileGraphics: Unending animation!\");\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\nnextfront:\r\n\t\tinfo++;\r\n\t} while (start<end);\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=========================\r\n=\r\n= RFL_InitAnimList\r\n=\r\n= Call to clear out the entire animating tile list and return all of them to\r\n= the free list.\r\n=\r\n=========================\r\n*/\r\n\r\nvoid RFL_InitAnimList (void)\r\n{\r\n\tint\ti;\r\n\r\n\tanimfreeptr = &animarray[0];\r\n\r\n\tfor (i=0;i<MAXANIMTILES-1;i++)\r\n\t\tanimarray[i].nexttile = &animarray[i+1];\r\n\r\n\tanimarray[i].nexttile = NULL;\r\n\r\n\tanimhead = NULL;\t\t\t// nothing in list\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_CheckForAnimTile\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_CheckForAnimTile (unsigned x, unsigned y)\r\n{\r\n\tunsigned \ttile,offset,speed,lasttime,thistime,timemissed;\r\n\tunsigned\tfar *map;\r\n\tanimtiletype\t*anim,*next;\r\n\r\n// the info plane of each animating tile has a near pointer into allanims[]\r\n// which gives the current state of all concurrently animating tiles\r\n\r\n\toffset = mapbwidthtable[y]/2+x;\r\n\r\n//\r\n// background\r\n//\r\n\tmap = mapsegs[0]+offset;\r\n\ttile = *map;\r\n\tif (tinf[ANIM+tile])\r\n\t{\r\n\t\tif (!animfreeptr)\r\n\t\t\tQuit (\"RF_CheckForAnimTile: No free spots in tilearray!\");\r\n\t\tanim = animfreeptr;\r\n\t\tanimfreeptr = animfreeptr->nexttile;\r\n\t\tnext = animhead;\t\t\t\t// stick it at the start of the list\r\n\t\tanimhead = anim;\r\n\t\tif (next)\r\n\t\t\tnext->prevptr = &anim->nexttile;\r\n\t\tanim->nexttile = next;\r\n\t\tanim->prevptr = &animhead;\r\n\r\n\t\tanim->x = x;\r\n\t\tanim->y = y;\r\n\t\tanim->tile = tile;\r\n\t\tanim->mapplane = map;\r\n\t\tanim->chain = (tiletype *)*(mapsegs[2]+offset);\r\n\t}\r\n\r\n//\r\n// foreground\r\n//\r\n\tmap = mapsegs[1]+offset;\r\n\ttile = *map;\r\n\tif (tinf[MANIM+tile])\r\n\t{\r\n\t\tif (!animfreeptr)\r\n\t\t\tQuit (\"RF_CheckForAnimTile: No free spots in tilearray!\");\r\n\t\tanim = animfreeptr;\r\n\t\tanimfreeptr = animfreeptr->nexttile;\r\n\t\tnext = animhead;\t\t\t\t// stick it at the start of the list\r\n\t\tanimhead = anim;\r\n\t\tif (next)\r\n\t\t\tnext->prevptr = &anim->nexttile;\r\n\t\tanim->nexttile = next;\r\n\t\tanim->prevptr = &animhead;\r\n\r\n\t\tanim->x = x;\r\n\t\tanim->y = y;\r\n\t\tanim->tile = tile;\r\n\t\tanim->mapplane = map;\r\n\t\tanim->chain = (tiletype *)*(mapsegs[2]+offset);\r\n\t}\r\n\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_RemoveAnimsOnX\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_RemoveAnimsOnX (unsigned x)\r\n{\r\n\tanimtiletype *current,*next;\r\n\r\n\tcurrent = animhead;\r\n\twhile (current)\r\n\t{\r\n\t\tif (current->x == x)\r\n\t\t{\r\n\t\t\t*(void **)current->prevptr = current->nexttile;\r\n\t\t\tif (current->nexttile)\r\n\t\t\t\tcurrent->nexttile->prevptr = current->prevptr;\r\n\t\t\tnext = current->nexttile;\r\n\t\t\tcurrent->nexttile = animfreeptr;\r\n\t\t\tanimfreeptr = current;\r\n\t\t\tcurrent = next;\r\n\t\t}\r\n\t\telse\r\n\t\t\tcurrent = current->nexttile;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_RemoveAnimsOnY\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_RemoveAnimsOnY (unsigned y)\r\n{\r\n\tanimtiletype *current,*next;\r\n\r\n\tcurrent = animhead;\r\n\twhile (current)\r\n\t{\r\n\t\tif (current->y == y)\r\n\t\t{\r\n\t\t\t*(void **)current->prevptr = current->nexttile;\r\n\t\t\tif (current->nexttile)\r\n\t\t\t\tcurrent->nexttile->prevptr = current->prevptr;\r\n\t\t\tnext = current->nexttile;\r\n\t\t\tcurrent->nexttile = animfreeptr;\r\n\t\t\tanimfreeptr = current;\r\n\t\t\tcurrent = next;\r\n\t\t}\r\n\t\telse\r\n\t\t\tcurrent = current->nexttile;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_AnimateTiles\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_AnimateTiles (void)\r\n{\r\n\tanimtiletype *current;\r\n\tunsigned\tupdateofs,tile,x,y;\r\n\ttiletype\t*anim;\r\n\r\n//\r\n// animate the lists of tiles\r\n//\r\n\tanim = &allanims[0];\r\n\twhile (anim->current)\r\n\t{\r\n\t\tanim->count-=tics;\r\n\t\twhile ( anim->count < 1)\r\n\t\t{\r\n\t\t\tif (anim->current & 0x8000)\r\n\t\t\t{\r\n\t\t\t\ttile = anim->current & 0x7fff;\r\n\t\t\t\ttile += (signed char)tinf[MANIM+tile];\r\n\t\t\t\tanim->count += tinf[MSPEED+tile];\r\n\t\t\t\ttile |= 0x8000;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttile = anim->current;\r\n\t\t\t\ttile += (signed char)tinf[ANIM+tile];\r\n\t\t\t\tanim->count += tinf[SPEED+tile];\r\n\t\t\t}\r\n\t\t\tanim->current = tile;\r\n\t\t}\r\n\t\tanim++;\r\n\t}\r\n\r\n\r\n//\r\n// traverse the list of animating tiles\r\n//\r\n\tcurrent = animhead;\r\n\twhile (current)\r\n\t{\r\n\t\ttile =current->chain->current;\r\n\t\tif ( tile != current->tile)\r\n\t\t{\r\n\t\t// tile has animated\r\n\t\t//\r\n\t\t// remove tile from master screen cache,\r\n\t\t// change a tile to its next state, set the structure up for\r\n\t\t// next animation, and post an update region to both update pages\r\n\t\t//\r\n\t\t\tcurrent->tile = tile;\r\n\r\n\t\t\t*(current->mapplane) = tile & 0x7fff; \t\t// change in map\r\n\r\n#if GRMODE == EGAGR\r\n\t\t\tif (tile<0x8000)\t\t// background\r\n\t\t\t\ttilecache[tile] = 0;\r\n#endif\r\n\r\n\t\t\tx = current->x-originxtile;\r\n\t\t\ty = current->y-originytile;\r\n\r\n\t\t\tif (x>=PORTTILESWIDE || y>=PORTTILESHIGH)\r\n\t\t\t\tQuit (\"RFL_AnimateTiles: Out of bounds!\");\r\n\r\n\t\t\tupdateofs = uwidthtable[y] + x;\r\n\t\t\tRFL_NewTile(updateofs);\t\t\t\t// puts \"1\"s in both pages\r\n\t\t}\r\n\t\tcurrent = current->nexttile;\r\n\t}\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=========================\r\n=\r\n= RFL_InitSpriteList\r\n=\r\n= Call to clear out the entire sprite list and return all of them to\r\n= the free list.\r\n=\r\n=========================\r\n*/\r\n\r\nvoid RFL_InitSpriteList (void)\r\n{\r\n\tint\ti;\r\n\r\n\tspritefreeptr = &spritearray[0];\r\n\tfor (i=0;i<MAXSPRITES-1;i++)\r\n\t\tspritearray[i].nextsprite = &spritearray[i+1];\r\n\r\n\tspritearray[i].nextsprite = NULL;\r\n\r\n// NULL in all priority levels\r\n\r\n\tmemset (prioritystart,0,sizeof(prioritystart));\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= RFL_CalcOriginStuff\r\n=\r\n= Calculate all the global variables for a new position\r\n= Long parms so position can be clipped to a maximum near 64k\r\n=\r\n=================\r\n*/\r\n\r\nvoid RFL_CalcOriginStuff (long x, long y)\r\n{\r\n\tif (x<originxmin)\r\n\t  x=originxmin;\r\n\telse if (x>originxmax)\r\n\t  x=originxmax;\r\n\r\n\tif (y<originymin)\r\n\t  y=originymin;\r\n\telse if (y>originymax)\r\n\t  y=originymax;\r\n\r\n\toriginxglobal = x;\r\n\toriginyglobal = y;\r\n\toriginxtile = originxglobal>>G_T_SHIFT;\r\n\toriginytile = originyglobal>>G_T_SHIFT;\r\n\toriginxscreen = originxtile<<SX_T_SHIFT;\r\n\toriginyscreen = originytile<<SY_T_SHIFT;\r\n\toriginmap = mapbwidthtable[originytile] + originxtile*2;\r\n\r\n#if GRMODE == EGAGR\r\n\tpanx = (originxglobal>>G_P_SHIFT) & 15;\r\n\tpansx = panx & 8;\r\n\tpany = pansy = (originyglobal>>G_P_SHIFT) & 15;\r\n\tpanadjust = panx/8 + ylookup[pany];\r\n#endif\r\n\r\n#if GRMODE == CGAGR\r\n\tpanx = (originxglobal>>G_P_SHIFT) & 15;\r\n\tpansx = panx & 12;\r\n\tpany = pansy = (originyglobal>>G_P_SHIFT) & 15;\r\n\tpanadjust = pansx/4 + ylookup[pansy];\r\n#endif\r\n\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_SetRefreshHook\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_SetRefreshHook (void (*func) (void) )\r\n{\r\n\trefreshvector = func;\r\n}\r\n\r\n\r\n\r\n/*\r\n=================\r\n=\r\n= RFL_NewRow\r\n=\r\n= Bring a new row of tiles onto the port, spawning animating tiles\r\n=\r\n=================\r\n*/\r\n\r\nvoid\tRFL_NewRow (int dir)\r\n{\r\n\tunsigned count,updatespot,updatestep;\r\n\tint\t\tx,y,xstep,ystep;\r\n\r\n\tswitch (dir)\r\n\t{\r\n\tcase 0:\t\t// top row\r\n\t\tupdatespot = 0;\r\n\t\tupdatestep = 1;\r\n\t\tx = originxtile;\r\n\t\ty = originytile;\r\n\t\txstep = 1;\r\n\t\tystep = 0;\r\n\t\tcount = PORTTILESWIDE;\r\n\t\tbreak;\r\n\r\n\tcase 1:\t\t// right row\r\n\t\tupdatespot = PORTTILESWIDE-1;\r\n\t\tupdatestep = UPDATEWIDE;\r\n\t\tx = originxtile + PORTTILESWIDE-1;\r\n\t\ty = originytile;\r\n\t\txstep = 0;\r\n\t\tystep = 1;\r\n\t\tcount = PORTTILESHIGH;\r\n\t\tbreak;\r\n\r\n\tcase 2:\t\t// bottom row\r\n\t\tupdatespot = UPDATEWIDE*(PORTTILESHIGH-1);\r\n\t\tupdatestep = 1;\r\n\t\tx = originxtile;\r\n\t\ty = originytile + PORTTILESHIGH-1;\r\n\t\txstep = 1;\r\n\t\tystep = 0;\r\n\t\tcount = PORTTILESWIDE;\r\n\t\tbreak;\r\n\r\n\tcase 3:\t\t// left row\r\n\t\tupdatespot = 0;\r\n\t\tupdatestep = UPDATEWIDE;\r\n\t\tx = originxtile;\r\n\t\ty = originytile;\r\n\t\txstep = 0;\r\n\t\tystep = 1;\r\n\t\tcount = PORTTILESHIGH;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tQuit (\"RFL_NewRow: Bad dir!\");\r\n\t}\r\n\r\n\twhile (count--)\r\n\t{\r\n\t\tRFL_NewTile(updatespot);\r\n\t\tRFL_CheckForAnimTile (x,y);\r\n\t\tupdatespot+=updatestep;\r\n\t\tx+=xstep;\r\n\t\ty+=ystep;\r\n\t}\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_ForceRefresh\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_ForceRefresh (void)\r\n{\r\n\tRF_NewPosition (originxglobal,originyglobal);\r\n\tRF_Refresh ();\r\n\tRF_Refresh ();\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\tEGA specific routines\r\n\r\n=============================================================================\r\n*/\r\n\r\n#if GRMODE == EGAGR\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_NewPosition EGA\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_NewPosition (unsigned x, unsigned y)\r\n{\r\n\tint mx,my;\r\n\tbyte\t*page0ptr,*page1ptr;\r\n\tunsigned \tupdatenum;\r\n\r\n//\r\n// calculate new origin related globals\r\n//\r\n\tRFL_CalcOriginStuff (x,y);\r\n\r\n//\r\n// clear out all animating tiles\r\n//\r\n\tRFL_InitAnimList ();\r\n\r\n//\r\n// set up the new update arrays at base position\r\n//\r\n\tmemset (tilecache,0,sizeof(tilecache));\t\t// old cache is invalid\r\n\r\n\tupdatestart[0] = baseupdatestart[0];\r\n\tupdatestart[1] = baseupdatestart[1];\r\n\r\n\tpage0ptr = updatestart[0]+PORTTILESWIDE;\t// used to stick \"0\"s after rows\r\n\tpage1ptr = updatestart[1]+PORTTILESWIDE;\r\n\r\n\tupdatenum = 0;\t\t\t\t// start at first visable tile\r\n\r\n\tfor (my=0;my<PORTTILESHIGH;my++)\r\n\t{\r\n\t\tfor (mx=0;mx<PORTTILESWIDE;mx++)\r\n\t\t{\r\n\t\t\tRFL_NewTile(updatenum);\t\t\t// puts \"1\"s in both pages\r\n\t\t\tRFL_CheckForAnimTile(mx+originxtile,my+originytile);\r\n\t\t\tupdatenum++;\r\n\t\t}\r\n\t\tupdatenum++;\r\n\t\t*page0ptr = *page1ptr = 0; // set a 0 at end of a line of tiles\r\n\t\tpage0ptr+=(PORTTILESWIDE+1);\r\n\t\tpage1ptr+=(PORTTILESWIDE+1);\r\n\t}\r\n\t*(word *)(page0ptr-PORTTILESWIDE)\r\n\t\t= *(word *)(page1ptr-PORTTILESWIDE) = UPDATETERMINATE;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=================\r\n=\r\n= RFL_OldRow EGA\r\n=\r\n= Uncache the trailing row of tiles\r\n=\r\n=================\r\n*/\r\n\r\nvoid\tRFL_OldRow (unsigned updatespot,unsigned count,unsigned step)\r\n{\r\n\r\nasm\tmov\tsi,[updatespot]\t\t\t// pointer inside each map plane\r\nasm\tmov\tcx,[count]\t\t\t\t// number of tiles to clear\r\nasm\tmov\tdx,[step]\t\t\t\t// move to next tile\r\nasm\tmov\tes,[WORD PTR mapsegs]\t\t\t// background plane\r\nasm\tmov\tds,[WORD PTR mapsegs+2]\t\t\t// foreground plane\r\n\r\nclearcache:\r\nasm\tmov\tbx,[si]\r\nasm\tor\tbx,bx\r\nasm\tjnz\tblockok\t\t\t\t\t// if a foreground tile, block wasn't cached\r\nasm\tmov\tbx,[es:si]\r\nasm\tshl\tbx,1\r\nasm\tmov\t[WORD PTR ss:tilecache+bx],0  //tile is no longer in master screen cache\r\nblockok:\r\nasm\tadd\tsi,dx\r\nasm\tloop\tclearcache\r\n\r\nasm\tmov\tax,ss\r\nasm\tmov\tds,ax\r\n\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_Scroll  EGA\r\n=\r\n= Move the origin x/y global coordinates, readjust the screen panning, and\r\n= scroll if needed.  If the scroll distance is greater than one tile, the\r\n= entire screen will be redrawn (this could be generalized, but scrolling\r\n= more than one tile per refresh is a bad idea!).\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_Scroll (int x, int y)\r\n{\r\n\tlong\t\tneworgx,neworgy;\r\n\tint\t\t\ti,deltax,deltay,absdx,absdy;\r\n\tint\t\t\toldxt,oldyt,move,yy;\r\n\tunsigned\tupdatespot;\r\n\tbyte\t\t*update0,*update1;\r\n\tunsigned\toldpanx,oldpanadjust,oldoriginmap,oldscreen,newscreen,screencopy;\r\n\tint\t\t\tscreenmove;\r\n\r\n\toldxt = originxtile;\r\n\toldyt = originytile;\r\n\toldoriginmap = originmap;\r\n\toldpanadjust = panadjust;\r\n\toldpanx = panx;\r\n\r\n\tRFL_CalcOriginStuff ((long)originxglobal + x,(long)originyglobal + y);\r\n\r\n\tdeltax = originxtile - oldxt;\r\n\tabsdx = abs(deltax);\r\n\tdeltay = originytile - oldyt;\r\n\tabsdy = abs(deltay);\r\n\r\n\tif (absdx>1 || absdy>1)\r\n\t{\r\n\t//\r\n\t// scrolled more than one tile, so start from scratch\r\n\t//\r\n\t\tRF_NewPosition(originxglobal,originyglobal);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!absdx && !absdy)\r\n\t\treturn;\t\t\t\t\t// the screen has not scrolled an entire tile\r\n\r\n\r\n//\r\n// adjust screens and handle SVGA crippled compatability mode\r\n//\r\n\tscreenmove = deltay*16*SCREENWIDTH + deltax*TILEWIDTH;\r\n\tfor (i=0;i<3;i++)\r\n\t{\r\n\t\tscreenstart[i]+= screenmove;\r\n\t\tif (compatability && screenstart[i] > (0x10000l-SCREENSPACE) )\r\n\t\t{\r\n\t\t\t//\r\n\t\t\t// move the screen to the opposite end of the buffer\r\n\t\t\t//\r\n\t\t\tscreencopy = screenmove>0 ? FREEEGAMEM : -FREEEGAMEM;\r\n\t\t\toldscreen = screenstart[i] - screenmove;\r\n\t\t\tnewscreen = oldscreen + screencopy;\r\n\t\t\tscreenstart[i] = newscreen + screenmove;\r\n\t\t\tVW_ScreenToScreen (oldscreen,newscreen,\r\n\t\t\t\tPORTTILESWIDE*2,PORTTILESHIGH*16);\r\n\r\n\t\t\tif (i==screenpage)\r\n\t\t\t\tVW_SetScreen(newscreen+oldpanadjust,oldpanx & xpanmask);\r\n\t\t}\r\n\t}\r\n\tbufferofs = screenstart[otherpage];\r\n\tdisplayofs = screenstart[screenpage];\r\n\tmasterofs = screenstart[2];\r\n\r\n\r\n//\r\n// float the update regions\r\n//\r\n\tmove = deltax;\r\n\tif (deltay==1)\r\n\t  move += UPDATEWIDE;\r\n\telse if (deltay==-1)\r\n\t  move -= UPDATEWIDE;\r\n\r\n\tupdatestart[0]+=move;\r\n\tupdatestart[1]+=move;\r\n\r\n//\r\n// draw the new tiles just scrolled on to the master screen, and\r\n// mark them as needing to be copied to each screen next refreshes\r\n// Make sure a zero is at the end of each row in update\r\n//\r\n\r\n\tif (deltax)\r\n\t{\r\n\t\tif (deltax==1)\r\n\t\t{\r\n\t\t\tRFL_NewRow (1);\t\t\t// new right row\r\n\t\t\tRFL_OldRow (oldoriginmap,PORTTILESHIGH,mapbyteswide);\r\n\t\t\tRFL_RemoveAnimsOnX (originxtile-1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tRFL_NewRow (3);\t\t\t// new left row\r\n\t\t\tRFL_OldRow (oldoriginmap+(PORTTILESWIDE-1)*2,PORTTILESHIGH\r\n\t\t\t,mapbyteswide);\r\n\t\t\tRFL_RemoveAnimsOnX (originxtile+PORTTILESWIDE);\r\n\t\t}\r\n\r\n\t\tupdate0 = updatestart[0]+PORTTILESWIDE;\r\n\t\tupdate1 = updatestart[1]+PORTTILESWIDE;\r\n\t\tfor\t(yy=0;yy<PORTTILESHIGH;yy++)\r\n\t\t{\r\n\t\t\t*update0 = *update1 = 0;\t// drop a 0 at end of each row\r\n\t\t\tupdate0+=UPDATEWIDE;\r\n\t\t\tupdate1+=UPDATEWIDE;\r\n\t\t}\r\n\t}\r\n\r\n//----------------\r\n\r\n\tif (deltay)\r\n\t{\r\n\t\tif (deltay==1)\r\n\t\t{\r\n\t\t\tRFL_NewRow (2);\t\t\t// new bottom row\r\n\t\t\tRFL_OldRow (oldoriginmap,PORTTILESWIDE,2);\r\n\t\t\tupdatespot = UPDATEWIDE*(PORTTILESHIGH-1);\r\n\t\t\tRFL_RemoveAnimsOnY (originytile-1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tRFL_NewRow (0);\t\t\t// new top row\r\n\t\t\tRFL_OldRow (oldoriginmap+mapbwidthtable[PORTTILESHIGH-1]\r\n\t\t\t,PORTTILESWIDE,2);\r\n\t\t\tupdatespot = 0;\r\n\t\t\tRFL_RemoveAnimsOnY (originytile+PORTTILESHIGH);\r\n\t\t}\r\n\r\n\t\t*(updatestart[0]+updatespot+PORTTILESWIDE) =\r\n\t\t\t*(updatestart[1]+updatespot+PORTTILESWIDE) = 0;\r\n\t}\r\n\r\n//----------------\r\n\r\n\t//\r\n\t// place a new terminator\r\n\t//\r\n\tupdate0 = updatestart[0]+UPDATEWIDE*PORTTILESHIGH-1;\r\n\tupdate1 = updatestart[1]+UPDATEWIDE*PORTTILESHIGH-1;\r\n\t*update0++ = *update1++ = 0;\r\n\t*(unsigned *)update0 = *(unsigned *)update1 = UPDATETERMINATE;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_PlaceSprite   EGA\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_PlaceSprite (void **user,unsigned globalx,unsigned globaly,\r\n\tunsigned spritenumber, drawtype draw, int priority)\r\n{\r\n\tspritelisttype\tregister *sprite,*next;\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg\t*block;\r\n\tunsigned\tshift,pixx;\r\n\r\n\tif (!spritenumber)\r\n\t{\r\n\t\tRF_RemoveSprite (user);\r\n\t\treturn;\r\n\t}\r\n\r\n\tsprite = (spritelisttype *)*user;\r\n\r\n\tif\t(sprite)\r\n\t{\r\n\t// sprite allready exists in the list, so we can use it's block\r\n\r\n\t//\r\n\t// post an erase block to both pages by copying screenx,screeny,width,height\r\n\t// both pages may not need to be erased if the sprite just changed last frame\r\n\t//\r\n\t\tif (sprite->updatecount<2)\r\n\t\t{\r\n\t\t\tif (!sprite->updatecount)\r\n\t\t\t\tmemcpy (eraselistptr[otherpage]++,sprite,sizeof(eraseblocktype));\r\n\t\t\tmemcpy (eraselistptr[screenpage]++,sprite,sizeof(eraseblocktype));\r\n\t\t}\r\n\r\n\t\tif (priority != sprite->priority)\r\n\t\t{\r\n\t\t// sprite mvoed to another priority, so unlink the old one and\r\n\t\t// relink it in the new priority\r\n\r\n\t\t\tnext = sprite->nextsprite;\t\t\t// cut old links\r\n\t\t\tif (next)\r\n\t\t\t\tnext->prevptr = sprite->prevptr;\r\n\t\t\t*sprite->prevptr = next;\r\n\t\t\tgoto linknewspot;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t// this is a brand new sprite, so allocate a block from the array\r\n\r\n\t\tif (!spritefreeptr)\r\n\t\t\tQuit (\"RF_PlaceSprite: No free spots in spritearray!\");\r\n\r\n\t\tsprite = spritefreeptr;\r\n\t\tspritefreeptr = spritefreeptr->nextsprite;\r\n\r\nlinknewspot:\r\n\t\tnext = prioritystart[priority];\t\t// stick it in new spot\r\n\t\tif (next)\r\n\t\t\tnext->prevptr = &sprite->nextsprite;\r\n\t\tsprite->nextsprite = next;\r\n\t\tprioritystart[priority] = sprite;\r\n\t\tsprite->prevptr = &prioritystart[priority];\r\n\t}\r\n\r\n//\r\n// write the new info to the sprite\r\n//\r\n\tspr = &spritetable[spritenumber-STARTSPRITES];\r\n\tblock = (spritetype _seg *)grsegs[spritenumber];\r\n\r\n\tglobaly+=spr->orgy;\r\n\tglobalx+=spr->orgx;\r\n\r\n\tpixx = globalx >> G_SY_SHIFT;\r\n\tshift = (pixx&7)/2;\r\n\r\n\tsprite->screenx = pixx >> (G_EGASX_SHIFT-G_SY_SHIFT);\r\n\tsprite->screeny = globaly >> G_SY_SHIFT;\r\n\tsprite->width = block->width[shift];\r\n\tsprite->height = spr->height;\r\n\tsprite->grseg = spritenumber;\r\n\tsprite->sourceofs = block->sourceoffset[shift];\r\n\tsprite->planesize = block->planesize[shift];\r\n\tsprite->draw = draw;\r\n\tsprite->priority = priority;\r\n\tsprite->tilex = sprite->screenx >> SX_T_SHIFT;\r\n\tsprite->tiley = sprite->screeny >> SY_T_SHIFT;\r\n\tsprite->tilewide = ( (sprite->screenx + sprite->width -1) >> SX_T_SHIFT )\r\n\t\t- sprite->tilex + 1;\r\n\tsprite->tilehigh = ( (sprite->screeny + sprite->height -1) >> SY_T_SHIFT )\r\n\t\t- sprite->tiley + 1;\r\n\r\n\tsprite->updatecount = 2;\t\t// draw on next two refreshes\r\n\r\n// save the sprite pointer off in the user's pointer so it can be moved\r\n// again later\r\n\r\n\t*user = sprite;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_RemoveSprite  EGA\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_RemoveSprite (void **user)\r\n{\r\n\tspritelisttype\t*sprite,*next;\r\n\r\n\tsprite = (spritelisttype *)*user;\r\n\tif (!sprite)\r\n\t\treturn;\r\n\r\n//\r\n// post an erase block to both pages by copying screenx,screeny,width,height\r\n// both pages may not need to be erased if the sprite just changed last frame\r\n//\r\n\tif (sprite->updatecount<2)\r\n\t{\r\n\t\tif (!sprite->updatecount)\r\n\t\t\tmemcpy (eraselistptr[otherpage]++,sprite,sizeof(eraseblocktype));\r\n\t\tmemcpy (eraselistptr[screenpage]++,sprite,sizeof(eraseblocktype));\r\n\t}\r\n\r\n//\r\n// unlink the sprite node\r\n//\r\n\tnext = sprite->nextsprite;\r\n\tif (next)\t\t\t\t\t\t// if (!next), sprite is last in chain\r\n\t\tnext->prevptr = sprite->prevptr;\r\n\t*sprite->prevptr = next;\r\n\r\n//\r\n// add it back to the free list\r\n//\r\n\tsprite->nextsprite = spritefreeptr;\r\n\tspritefreeptr = sprite;\r\n\r\n//\r\n// null the users pointer, so next time that actor gets placed, it will\r\n// allocate a new block\r\n//\r\n\r\n\t*user = 0;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_EraseBlocks  EGA\r\n=\r\n= Write mode 1 should be set\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_EraseBlocks (void)\r\n{\r\n\teraseblocktype\t*block,*done;\r\n\tint\t\t\tscreenxh,screenyh;\r\n\tunsigned\tpos,xtl,ytl,xth,yth,x,y;\r\n\tbyte\t\t*updatespot;\r\n\tunsigned\tupdatedelta;\r\n\tunsigned\terasecount;\r\n\r\n#ifdef PROFILE\r\n\terasecount = 0;\r\n#endif\r\n\r\n\tblock = otherpage ? &eraselist[1][0] : &eraselist[0][0];\r\n\r\n\tdone = eraselistptr[otherpage];\r\n\r\n\twhile (block != done)\r\n\t{\r\n\r\n\t//\r\n\t// clip the block to the current screen view\r\n\t//\r\n\t\tblock->screenx -= originxscreen;\r\n\t\tblock->screeny -= originyscreen;\r\n\r\n\t\tif (block->screenx < 0)\r\n\t\t{\r\n\t\t\tblock->width += block->screenx;\r\n\t\t\tif (block->width<1)\r\n\t\t\t\tgoto next;\r\n\t\t\tblock->screenx = 0;\r\n\t\t}\r\n\r\n\t\tif (block->screeny < 0)\r\n\t\t{\r\n\t\t\tblock->height += block->screeny;\r\n\t\t\tif (block->height<1)\r\n\t\t\t\tgoto next;\r\n\t\t\tblock->screeny = 0;\r\n\t\t}\r\n\r\n\t\tscreenxh = block->screenx + block->width;\r\n\t\tscreenyh = block->screeny + block->height;\r\n\r\n\t\tif (screenxh > EGAPORTSCREENWIDE)\r\n\t\t{\r\n\t\t\tblock->width = EGAPORTSCREENWIDE-block->screenx;\r\n\t\t\tscreenxh = block->screenx + block->width;\r\n\t\t}\r\n\r\n\t\tif (screenyh > PORTSCREENHIGH)\r\n\t\t{\r\n\t\t\tblock->height = PORTSCREENHIGH-block->screeny;\r\n\t\t\tscreenyh = block->screeny + block->height;\r\n\t\t}\r\n\r\n\t\tif (block->width<1 || block->height<1)\r\n\t\t\tgoto next;\r\n\r\n\t//\r\n\t// erase the block by copying from the master screen\r\n\t//\r\n\t\tpos = ylookup[block->screeny]+block->screenx;\r\n\t\tVW_ScreenToScreen (masterofs+pos,bufferofs+pos,\r\n\t\t\tblock->width,block->height);\r\n\r\n\t//\r\n\t// put 2s in update where the block was, to force sprites to update\r\n\t//\r\n\t\txtl = block->screenx >> SX_T_SHIFT;\r\n\t\txth = (block->screenx+block->width-1) >> SX_T_SHIFT;\r\n\t\tytl = block->screeny >> SY_T_SHIFT;\r\n\t\tyth = (block->screeny+block->height-1) >> SY_T_SHIFT;\r\n\r\n\t\tupdatespot = updateptr + uwidthtable[ytl] + xtl;\r\n\t\tupdatedelta = UPDATEWIDE - (xth-xtl+1);\r\n\r\n\t\tfor (y=ytl;y<=yth;y++)\r\n\t\t{\r\n\t\t\tfor (x=xtl;x<=xth;x++)\r\n\t\t\t\t*updatespot++ = 2;\r\n\t\t\tupdatespot += updatedelta;\t\t// down to next line\r\n\t\t}\r\n#ifdef PROFILE\r\n\t\terasecount++;\r\n#endif\r\n\r\nnext:\r\n\t\tblock++;\r\n\t}\r\n\teraselistptr[otherpage] = otherpage ? &eraselist[1][0] : &eraselist[0][0];\r\n#ifdef PROFILE\r\n\tstrcpy (scratch,\"\\tErase:\");\r\n\titoa (erasecount,str,10);\r\n\tstrcat (scratch,str);\r\n\twrite (profilehandle,scratch,strlen(scratch));\r\n#endif\r\n\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_UpdateSprites EGA\r\n=\r\n= NOTE: Implement vertical clipping!\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_UpdateSprites (void)\r\n{\r\n\tspritelisttype\t*sprite;\r\n\tint\tportx,porty,x,y,xtl,xth,ytl,yth;\r\n\tint\tpriority;\r\n\tunsigned dest;\r\n\tbyte\t\t*updatespot,*baseupdatespot;\r\n\tunsigned\tupdatedelta;\r\n\tunsigned\tupdatecount;\r\n\tunsigned\theight,sourceofs;\r\n\r\n#ifdef PROFILE\r\n\tupdatecount = 0;\r\n#endif\r\n\r\n\tfor (priority=0;priority<PRIORITIES;priority++)\r\n\t{\r\n\t\tif (priority==MASKEDTILEPRIORITY)\r\n\t\t\tRFL_MaskForegroundTiles ();\r\n\r\n\t\tfor (sprite = prioritystart[priority]; sprite ;\r\n\t\t\tsprite = (spritelisttype *)sprite->nextsprite)\r\n\t\t{\r\n\t\t//\r\n\t\t// see if the sprite has any visable area in the port\r\n\t\t//\r\n\r\n\t\t\tportx = sprite->screenx - originxscreen;\r\n\t\t\tporty = sprite->screeny - originyscreen;\r\n\t\t\txtl = portx >> SX_T_SHIFT;\r\n\t\t\txth = (portx + sprite->width-1) >> SX_T_SHIFT;\r\n\t\t\tytl = porty >> SY_T_SHIFT;\r\n\t\t\tyth = (porty + sprite->height-1) >> SY_T_SHIFT;\r\n\r\n\t\t\tif (xtl<0)\r\n\t\t\t  xtl = 0;\r\n\t\t\tif (xth>=PORTTILESWIDE)\r\n\t\t\t  xth = PORTTILESWIDE-1;\r\n\t\t\tif (ytl<0)\r\n\t\t\t  ytl = 0;\r\n\t\t\tif (yth>=PORTTILESHIGH)\r\n\t\t\t  yth = PORTTILESHIGH-1;\r\n\r\n\t\t\tif (xtl>xth || ytl>yth)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t//\r\n\t\t// see if it's visable area covers any non 0 update tiles\r\n\t\t//\r\n\t\t\tupdatespot = baseupdatespot = updateptr + uwidthtable[ytl] + xtl;\r\n\t\t\tupdatedelta = UPDATEWIDE - (xth-xtl+1);\r\n\r\n\t\t\tif (sprite->updatecount)\r\n\t\t\t{\r\n\t\t\t\tsprite->updatecount--;\t\t\t// the sprite was just placed,\r\n\t\t\t\tgoto redraw;\t\t\t\t\t// so draw it for sure\r\n\t\t\t}\r\n\r\n\t\t\tfor (y=ytl;y<=yth;y++)\r\n\t\t\t{\r\n\t\t\t\tfor (x=xtl;x<=xth;x++)\r\n\t\t\t\t\tif (*updatespot++)\r\n\t\t\t\t\t\tgoto redraw;\r\n\t\t\t\tupdatespot += updatedelta;\t\t// down to next line\r\n\t\t\t}\r\n\t\t\tcontinue;\t\t\t\t\t\t\t// no need to update\r\n\r\nredraw:\r\n\t\t//\r\n\t\t// set the tiles it covers to 3, because those tiles are being\r\n\t\t// updated\r\n\t\t//\r\n\t\t\tupdatespot = baseupdatespot;\r\n\t\t\tfor (y=ytl;y<=yth;y++)\r\n\t\t\t{\r\n\t\t\t\tfor (x=xtl;x<=xth;x++)\r\n\t\t\t\t\t*updatespot++ = 3;\r\n\t\t\t\tupdatespot += updatedelta;\t\t// down to next line\r\n\t\t\t}\r\n\t\t//\r\n\t\t// draw it!\r\n\t\t//\r\n\t\t\theight = sprite->height;\r\n\t\t\tsourceofs = sprite->sourceofs;\r\n\t\t\tif (porty<0)\r\n\t\t\t{\r\n\t\t\t\theight += porty;\t\t\t\t\t// clip top off\r\n\t\t\t\tsourceofs -= porty*sprite->width;\r\n\t\t\t\tporty = 0;\r\n\t\t\t}\r\n\t\t\telse if (porty+height>PORTSCREENHIGH)\r\n\t\t\t{\r\n\t\t\t\theight = PORTSCREENHIGH - porty;    // clip bottom off\r\n\t\t\t}\r\n\r\n\t\t\tdest = bufferofs + ylookup[porty] + portx;\r\n\r\n\t\t\tswitch (sprite->draw)\r\n\t\t\t{\r\n\t\t\tcase spritedraw:\r\n\t\t\t\tVW_MaskBlock(grsegs[sprite->grseg], sourceofs,\r\n\t\t\t\t\tdest,sprite->width,height,sprite->planesize);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase maskdraw:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n#ifdef PROFILE\r\n\t\t\tupdatecount++;\r\n#endif\r\n\r\n\r\n\t\t}\r\n\t}\r\n#ifdef PROFILE\r\n\tstrcpy (scratch,\"\\tSprites:\");\r\n\titoa (updatecount,str,10);\r\n\tstrcat (scratch,str);\r\n\twrite (profilehandle,scratch,strlen(scratch));\r\n#endif\r\n\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_Refresh   EGA\r\n=\r\n= All routines will draw at the port at bufferofs, possibly copying from\r\n= the port at masterofs.  The EGA version then page flips, while the\r\n= CGA version updates the screen from the buffer port.\r\n=\r\n= Screenpage is the currently displayed page, not the one being drawn\r\n= Otherpage is the page to be worked with now\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_Refresh (void)\r\n{\r\n\tbyte\t*newupdate;\r\n\tlong\tnewtime;\r\n\r\n\tupdateptr = updatestart[otherpage];\r\n\r\n\tRFL_AnimateTiles ();\t\t// DEBUG\r\n\r\n//\r\n// update newly scrolled on tiles and animated tiles from the master screen\r\n//\r\n\tEGAWRITEMODE(1);\r\n\tEGAMAPMASK(15);\r\n\tRFL_UpdateTiles ();\r\n\tRFL_EraseBlocks ();\r\n\r\n//\r\n// Update is all 0 except where sprites have changed or new area has\r\n// been scrolled on.  Go through all sprites and update the ones that cover\r\n// a non 0 update tile\r\n//\r\n\tEGAWRITEMODE(0);\r\n\tRFL_UpdateSprites ();\r\n\r\n//\r\n// if the main program has a refresh hook set, call their function before\r\n// displaying the new page\r\n//\r\n\tif (refreshvector)\r\n\t\trefreshvector();\r\n\r\n//\r\n// display the changed screen\r\n//\r\n\tVW_SetScreen(bufferofs+panadjust,panx & xpanmask);\r\n\r\n//\r\n// prepare for next refresh\r\n//\r\n// Set the update array to the middle position and clear it out to all \"0\"s\r\n// with an UPDATETERMINATE at the end\r\n//\r\n\tupdatestart[otherpage] = newupdate = baseupdatestart[otherpage];\r\nasm\tmov\tax,ds\r\nasm\tmov\tes,ax\r\nasm\txor\tax,ax\r\nasm\tmov\tcx,(UPDATESCREENSIZE-2)/2\r\nasm\tmov\tdi,[newupdate]\r\nasm\trep\tstosw\r\nasm\tmov\t[WORD PTR es:di],UPDATETERMINATE\r\n\r\n\tscreenpage ^= 1;\r\n\totherpage ^= 1;\r\n\tbufferofs = screenstart[otherpage];\r\n\tdisplayofs = screenstart[screenpage];\r\n\r\n//\r\n// calculate tics since last refresh for adaptive timing\r\n//\r\n\tif (lasttimecount > TimeCount)\r\n\t\tlasttimecount = TimeCount;\t\t// if the game was paused a LONG time\r\n\tdo\r\n\t{\r\n\t\tnewtime = TimeCount;\r\n\t\ttics = newtime-lasttimecount;\r\n\t} while (tics<MINTICS);\r\n\tlasttimecount = newtime;\r\n\r\n#ifdef PROFILE\r\n\tstrcpy (scratch,\"\\tTics:\");\r\n\titoa (tics,str,10);\r\n\tstrcat (scratch,str);\r\n\tstrcat (scratch,\"\\n\");\r\n\twrite (profilehandle,scratch,strlen(scratch));\r\n#endif\r\n\r\n\tif (tics>MAXTICS)\r\n\t{\r\n\t\tTimeCount -= (tics-MAXTICS);\r\n\t\ttics = MAXTICS;\r\n\t}\r\n}\r\n\r\n#endif\t\t// GRMODE == EGAGR\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\tCGA specific routines\r\n\r\n=============================================================================\r\n*/\r\n\r\n#if GRMODE == CGAGR\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_NewPosition   CGA\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_NewPosition (unsigned x, unsigned y)\r\n{\r\n\tint mx,my;\r\n\tbyte\t*spotptr;\r\n\tunsigned \tupdatenum;\r\n\r\n//\r\n// calculate new origin related globals\r\n//\r\n\tRFL_CalcOriginStuff (x,y);\r\n\r\n//\r\n// clear out all animating tiles\r\n//\r\n\tRFL_InitAnimList ();\r\n\r\n//\r\n// set up the new update arrays at base position\r\n//\r\n\tupdateptr = baseupdateptr;\r\n\r\n\tspotptr = updateptr + PORTTILESWIDE;\t// used to stick \"0\"s after rows\r\n\r\n\tupdatenum = 0;\t\t\t\t// start at first visable tile\r\n\r\n\tfor (my=0;my<PORTTILESHIGH;my++)\r\n\t{\r\n\t\tfor (mx=0;mx<PORTTILESWIDE;mx++)\r\n\t\t{\r\n\t\t\tRFL_NewTile(updatenum);\t\t\t// puts \"1\"s in both pages\r\n\t\t\tRFL_CheckForAnimTile(mx+originxtile,my+originytile);\r\n\t\t\tupdatenum++;\r\n\t\t}\r\n\t\tupdatenum++;\r\n\t\t*spotptr = 0; // set a 0 at end of a line of tiles\r\n\t\tspotptr +=(PORTTILESWIDE+1);\r\n\t}\r\n\t*(word *)(spotptr-PORTTILESWIDE) = UPDATETERMINATE;\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_Scroll       CGA\r\n=\r\n= Move the origin x/y global coordinates, readjust the screen panning, and\r\n= scroll if needed.  If the scroll distance is greater than one tile, the\r\n= entire screen will be redrawn (this could be generalized, but scrolling\r\n= more than one tile per refresh is a bad idea!).\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_Scroll (int x, int y)\r\n{\r\n\tlong\t\tneworgx,neworgy;\r\n\tint\t\t\ti,deltax,deltay,absdx,absdy;\r\n\tint\t\t\toldxt,oldyt,move,yy;\r\n\tunsigned\tupdatespot;\r\n\tbyte\t\t*spotptr;\r\n\tunsigned\toldoriginmap,oldscreen,newscreen,screencopy;\r\n\tint\t\t\tscreenmove;\r\n\r\n\toldxt = originxtile;\r\n\toldyt = originytile;\r\n\r\n\tRFL_CalcOriginStuff ((long)originxglobal + x,(long)originyglobal + y);\r\n\r\n\tdeltax = originxtile - oldxt;\r\n\tabsdx = abs(deltax);\r\n\tdeltay = originytile - oldyt;\r\n\tabsdy = abs(deltay);\r\n\r\n\tif (absdx>1 || absdy>1)\r\n\t{\r\n\t//\r\n\t// scrolled more than one tile, so start from scratch\r\n\t//\r\n\t\tRF_NewPosition(originxglobal,originyglobal);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!absdx && !absdy)\r\n\t\treturn;\t\t\t\t\t// the screen has not scrolled an entire tile\r\n\r\n\r\n//\r\n// float screens\r\n//\r\n\tscreenmove = deltay*16*SCREENWIDTH + deltax*TILEWIDTH;\r\n\tbufferofs += screenmove;\r\n\tmasterofs += screenmove;\r\n\r\n\r\n//\r\n// float the update regions\r\n//\r\n\tmove = deltax;\r\n\tif (deltay==1)\r\n\t  move += UPDATEWIDE;\r\n\telse if (deltay==-1)\r\n\t  move -= UPDATEWIDE;\r\n\r\n\tupdateptr+=move;\r\n\r\n//\r\n// draw the new tiles just scrolled on to the master screen, and\r\n// mark them as needing to be copied to each screen next refreshes\r\n// Make sure a zero is at the end of each row in update\r\n//\r\n\r\n\tif (deltax)\r\n\t{\r\n\t\tif (deltax==1)\r\n\t\t{\r\n\t\t\tRFL_NewRow (1);\t\t\t// new right row\r\n\t\t\tRFL_RemoveAnimsOnX (originxtile-1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tRFL_NewRow (3);\t\t\t// new left row\r\n\t\t\tRFL_RemoveAnimsOnX (originxtile+PORTTILESWIDE);\r\n\t\t}\r\n\r\n\t\tspotptr = updateptr+PORTTILESWIDE;\r\n\t\tfor\t(yy=0;yy<PORTTILESHIGH;yy++)\r\n\t\t{\r\n\t\t\t*spotptr = 0;\t\t// drop a 0 at end of each row\r\n\t\t\tspotptr+=UPDATEWIDE;\r\n\t\t}\r\n\t}\r\n\r\n//----------------\r\n\r\n\tif (deltay)\r\n\t{\r\n\t\tif (deltay==1)\r\n\t\t{\r\n\t\t\tRFL_NewRow (2);\t\t\t// new bottom row\r\n\t\t\t*(updateptr+UPDATEWIDE*(PORTTILESHIGH-1)+PORTTILESWIDE) = 0;\r\n\t\t\tRFL_RemoveAnimsOnY (originytile-1);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tRFL_NewRow (0);\t\t\t// new top row\r\n\t\t\t*(updateptr+PORTTILESWIDE) = 0;\r\n\t\t\tRFL_RemoveAnimsOnY (originytile+PORTTILESHIGH);\r\n\t\t}\r\n\t}\r\n\r\n//----------------\r\n\r\n\t//\r\n\t// place a new terminator\r\n\t//\r\n\tspotptr = updateptr+UPDATEWIDE*PORTTILESHIGH-1;\r\n\t*spotptr++ = 0;\r\n\t*(unsigned *)spotptr = UPDATETERMINATE;\r\n}\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_PlaceSprite  CGA\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_PlaceSprite (void **user,unsigned globalx,unsigned globaly,\r\n\tunsigned spritenumber, drawtype draw, int priority)\r\n{\r\n\tspritelisttype\tregister *sprite,*next;\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg\t*block;\r\n\tunsigned\tshift,pixx;\r\n\r\n\tif (!spritenumber)\r\n\t{\r\n\t\tRF_RemoveSprite (user);\r\n\t\treturn;\r\n\t}\r\n\r\n\tsprite = (spritelisttype *)*user;\r\n\r\n\tif\t(sprite)\r\n\t{\r\n\t// sprite allready exists in the list, so we can use it's block\r\n\r\n\t//\r\n\t// post an erase block to erase the old position by copying\r\n\t// screenx,screeny,width,height\r\n\t//\r\n\t\tif (!sprite->updatecount)\t\t// may not have been drawn at all yet\r\n\t\t\tmemcpy (eraselistptr[0]++,sprite,sizeof(eraseblocktype));\r\n\r\n\t\tif (priority != sprite->priority)\r\n\t\t{\r\n\t\t// sprite moved to another priority, so unlink the old one and\r\n\t\t// relink it in the new priority\r\n\r\n\t\t\tnext = sprite->nextsprite;\t\t\t// cut old links\r\n\t\t\tif (next)\r\n\t\t\t\tnext->prevptr = sprite->prevptr;\r\n\t\t\t*sprite->prevptr = next;\r\n\t\t\tgoto linknewspot;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t// this is a brand new sprite, so allocate a block from the array\r\n\r\n\t\tif (!spritefreeptr)\r\n\t\t\tQuit (\"RF_PlaceSprite: No free spots in spritearray!\");\r\n\r\n\t\tsprite = spritefreeptr;\r\n\t\tspritefreeptr = spritefreeptr->nextsprite;\r\n\r\nlinknewspot:\r\n\t\tnext = prioritystart[priority];\t\t// stick it in new spot\r\n\t\tif (next)\r\n\t\t\tnext->prevptr = &sprite->nextsprite;\r\n\t\tsprite->nextsprite = next;\r\n\t\tprioritystart[priority] = sprite;\r\n\t\tsprite->prevptr = &prioritystart[priority];\r\n\t}\r\n\r\n//\r\n// write the new info to the sprite\r\n//\r\n\tspr = &spritetable[spritenumber-STARTSPRITES];\r\n\tblock = (spritetype _seg *)grsegs[spritenumber];\r\n\r\n\tglobaly+=spr->orgy;\r\n\tglobalx+=spr->orgx;\r\n\r\n\tsprite->screenx = globalx >> G_CGASX_SHIFT;\r\n\tsprite->screeny = globaly >> G_SY_SHIFT;\r\n\tsprite->width = block->width[0];\r\n\tsprite->height = spr->height;\r\n\tsprite->grseg = spritenumber;\r\n\tsprite->sourceofs = block->sourceoffset[0];\r\n\tsprite->planesize = block->planesize[0];\r\n\tsprite->draw = draw;\r\n\tsprite->priority = priority;\r\n\tsprite->tilex = sprite->screenx >> SX_T_SHIFT;\r\n\tsprite->tiley = sprite->screeny >> SY_T_SHIFT;\r\n\tsprite->tilewide = ( (sprite->screenx + sprite->width -1) >> SX_T_SHIFT )\r\n\t\t- sprite->tilex + 1;\r\n\tsprite->tilehigh = ( (sprite->screeny + sprite->height -1) >> SY_T_SHIFT )\r\n\t\t- sprite->tiley + 1;\r\n\r\n\tsprite->updatecount = 1;\t\t// draw on next refresh\r\n\r\n// save the sprite pointer off in the user's pointer so it can be moved\r\n// again later\r\n\r\n\t*user = sprite;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_RemoveSprite CGA\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_RemoveSprite (void **user)\r\n{\r\n\tspritelisttype\t*sprite,*next;\r\n\r\n\tsprite = (spritelisttype *)*user;\r\n\tif (!sprite)\r\n\t\treturn;\r\n\r\n//\r\n// post an erase block to erase the old position by copying\r\n// screenx,screeny,width,height\r\n//\r\n\tif (!sprite->updatecount)\r\n\t{\r\n\t\tmemcpy (eraselistptr[0]++,sprite,sizeof(eraseblocktype));\r\n\t}\r\n\r\n//\r\n// unlink the sprite node\r\n//\r\n\tnext = sprite->nextsprite;\r\n\tif (next)\t\t\t\t\t\t// if (!next), sprite is last in chain\r\n\t\tnext->prevptr = sprite->prevptr;\r\n\t*sprite->prevptr = next;\r\n\r\n//\r\n// add it back to the free list\r\n//\r\n\tsprite->nextsprite = spritefreeptr;\r\n\tspritefreeptr = sprite;\r\n\r\n//\r\n// null the users pointer, so next time that actor gets placed, it will\r\n// allocate a new block\r\n//\r\n\r\n\t*user = 0;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_EraseBlocks CGA\r\n=\r\n= Write mode 1 should be set\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_EraseBlocks (void)\r\n{\r\n\teraseblocktype\t*block,*done;\r\n\tint\t\t\tscreenxh,screenyh;\r\n\tunsigned\tpos,xtl,ytl,xth,yth,x,y;\r\n\tbyte\t\t*updatespot;\r\n\tunsigned\tupdatedelta;\r\n\r\n\tblock = &eraselist[0][0];\r\n\r\n\tdone = eraselistptr[0];\r\n\r\n\twhile (block != done)\r\n\t{\r\n\r\n\t//\r\n\t// clip the block to the current screen view\r\n\t//\r\n\t\tblock->screenx -= originxscreen;\r\n\t\tblock->screeny -= originyscreen;\r\n\r\n\t\tif (block->screenx < 0)\r\n\t\t{\r\n\t\t\tblock->width += block->screenx;\r\n\t\t\tif (block->width<1)\r\n\t\t\t\tgoto next;\r\n\t\t\tblock->screenx = 0;\r\n\t\t}\r\n\r\n\t\tif (block->screeny < 0)\r\n\t\t{\r\n\t\t\tblock->height += block->screeny;\r\n\t\t\tif (block->height<1)\r\n\t\t\t\tgoto next;\r\n\t\t\tblock->screeny = 0;\r\n\t\t}\r\n\r\n\t\tscreenxh = block->screenx + block->width;\r\n\t\tscreenyh = block->screeny + block->height;\r\n\r\n\t\tif (screenxh > CGAPORTSCREENWIDE)\r\n\t\t{\r\n\t\t\tblock->width = CGAPORTSCREENWIDE-block->screenx;\r\n\t\t\tscreenxh = block->screenx + block->width;\r\n\t\t}\r\n\r\n\t\tif (screenyh > PORTSCREENHIGH)\r\n\t\t{\r\n\t\t\tblock->height = PORTSCREENHIGH-block->screeny;\r\n\t\t\tscreenyh = block->screeny + block->height;\r\n\t\t}\r\n\r\n\t\tif (block->width<1 || block->height<1)\r\n\t\t\tgoto next;\r\n\r\n\t//\r\n\t// erase the block by copying from the master screen\r\n\t//\r\n\t\tpos = ylookup[block->screeny]+block->screenx;\r\n\t\tblock->width = (block->width + (pos&1) + 1)& ~1;\r\n\t\tpos &= ~1;\t\t\t\t// make sure a word copy gets used\r\n\t\tVW_ScreenToScreen (masterofs+pos,bufferofs+pos,\r\n\t\t\tblock->width,block->height);\r\n\r\n\t//\r\n\t// put 2s in update where the block was, to force sprites to update\r\n\t//\r\n\t\txtl = block->screenx >> SX_T_SHIFT;\r\n\t\txth = (block->screenx+block->width-1) >> SX_T_SHIFT;\r\n\t\tytl = block->screeny >> SY_T_SHIFT;\r\n\t\tyth = (block->screeny+block->height-1) >> SY_T_SHIFT;\r\n\r\n\t\tupdatespot = updateptr + uwidthtable[ytl] + xtl;\r\n\t\tupdatedelta = UPDATEWIDE - (xth-xtl+1);\r\n\r\n\t\tfor (y=ytl;y<=yth;y++)\r\n\t\t{\r\n\t\t\tfor (x=xtl;x<=xth;x++)\r\n\t\t\t\t*updatespot++ = 2;\r\n\t\t\tupdatespot += updatedelta;\t\t// down to next line\r\n\t\t}\r\n\r\nnext:\r\n\t\tblock++;\r\n\t}\r\n\teraselistptr[0] = &eraselist[0][0];\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= RFL_UpdateSprites      CGA\r\n=\r\n= NOTE: Implement vertical clipping!\r\n=\r\n====================\r\n*/\r\n\r\nvoid RFL_UpdateSprites (void)\r\n{\r\n\tspritelisttype\t*sprite;\r\n\tint\tportx,porty,x,y,xtl,xth,ytl,yth;\r\n\tint\tpriority;\r\n\tunsigned dest;\r\n\tbyte\t\t*updatespot,*baseupdatespot;\r\n\tunsigned\tupdatedelta;\r\n\r\n\tunsigned\tupdatecount;\r\n\tunsigned\theight,sourceofs;\r\n\r\n#ifdef PROFILE\r\n\tupdatecount = 0;\r\n#endif\r\n\r\n\r\n\tfor (priority=0;priority<PRIORITIES;priority++)\r\n\t{\r\n\t\tif (priority==MASKEDTILEPRIORITY)\r\n\t\t\tRFL_MaskForegroundTiles ();\r\n\r\n\t\tfor (sprite = prioritystart[priority]; sprite ;\r\n\t\t\tsprite = (spritelisttype *)sprite->nextsprite)\r\n\t\t{\r\n\t\t//\r\n\t\t// see if the sprite has any visable area in the port\r\n\t\t//\r\n\r\n\t\t\tportx = sprite->screenx - originxscreen;\r\n\t\t\tporty = sprite->screeny - originyscreen;\r\n\t\t\txtl = portx >> SX_T_SHIFT;\r\n\t\t\txth = (portx + sprite->width-1) >> SX_T_SHIFT;\r\n\t\t\tytl = porty >> SY_T_SHIFT;\r\n\t\t\tyth = (porty + sprite->height-1) >> SY_T_SHIFT;\r\n\r\n\t\t\tif (xtl<0)\r\n\t\t\t  xtl = 0;\r\n\t\t\tif (xth>=PORTTILESWIDE)\r\n\t\t\t  xth = PORTTILESWIDE-1;\r\n\t\t\tif (ytl<0)\r\n\t\t\t  ytl = 0;\r\n\t\t\tif (yth>=PORTTILESHIGH)\r\n\t\t\t  yth = PORTTILESHIGH-1;\r\n\r\n\t\t\tif (xtl>xth || ytl>yth)\r\n\t\t\t\tcontinue;\r\n\r\n\t\t//\r\n\t\t// see if it's visable area covers any non 0 update tiles\r\n\t\t//\r\n\t\t\tupdatespot = baseupdatespot = updateptr + uwidthtable[ytl] + xtl;\r\n\t\t\tupdatedelta = UPDATEWIDE - (xth-xtl+1);\r\n\r\n\t\t\tif (sprite->updatecount)\r\n\t\t\t{\r\n\t\t\t\tsprite->updatecount--;\t\t\t// the sprite was just placed,\r\n\t\t\t\tgoto redraw;\t\t\t\t\t// so draw it for sure\r\n\t\t\t}\r\n\r\n\t\t\tfor (y=ytl;y<=yth;y++)\r\n\t\t\t{\r\n\t\t\t\tfor (x=xtl;x<=xth;x++)\r\n\t\t\t\t\tif (*updatespot++)\r\n\t\t\t\t\t\tgoto redraw;\r\n\t\t\t\tupdatespot += updatedelta;\t\t// down to next line\r\n\t\t\t}\r\n\t\t\tcontinue;\t\t\t\t\t\t\t// no need to update\r\n\r\nredraw:\r\n\t\t//\r\n\t\t// set the tiles it covers to 3, because those tiles are being\r\n\t\t// updated\r\n\t\t//\r\n\t\t\tupdatespot = baseupdatespot;\r\n\t\t\tfor (y=ytl;y<=yth;y++)\r\n\t\t\t{\r\n\t\t\t\tfor (x=xtl;x<=xth;x++)\r\n\t\t\t\t\t*updatespot++ = 3;\r\n\t\t\t\tupdatespot += updatedelta;\t\t// down to next line\r\n\t\t\t}\r\n\t\t//\r\n\t\t// draw it!\r\n\t\t//\r\n\t\t\theight = sprite->height;\r\n\t\t\tsourceofs = sprite->sourceofs;\r\n\t\t\tif (porty<0)\r\n\t\t\t{\r\n\t\t\t\theight += porty;\t\t\t\t\t// clip top off\r\n\t\t\t\tsourceofs -= porty*sprite->width;\r\n\t\t\t\tporty = 0;\r\n\t\t\t}\r\n\t\t\telse if (porty+height>PORTSCREENHIGH)\r\n\t\t\t{\r\n\t\t\t\theight = PORTSCREENHIGH - porty;    // clip bottom off\r\n\t\t\t}\r\n\r\n\t\t\tdest = bufferofs + ylookup[porty] + portx;\r\n\r\n\t\t\tswitch (sprite->draw)\r\n\t\t\t{\r\n\t\t\tcase spritedraw:\r\n\t\t\t\tVW_MaskBlock(grsegs[sprite->grseg], sourceofs,\r\n\t\t\t\t\tdest,sprite->width,height,sprite->planesize);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase maskdraw:\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n#ifdef PROFILE\r\n\t\t\tupdatecount++;\r\n#endif\r\n\r\n\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n=====================\r\n=\r\n= RF_Refresh        CGA\r\n=\r\n= All routines will draw at the port at bufferofs, possibly copying from\r\n= the port at masterofs.  The EGA version then page flips, while the\r\n= CGA version updates the screen from the buffer port.\r\n=\r\n= Screenpage is the currently displayed page, not the one being drawn\r\n= Otherpage is the page to be worked with now\r\n=\r\n=====================\r\n*/\r\n\r\nvoid RF_Refresh (void)\r\n{\r\n\tlong newtime;\r\n\r\n\tRFL_AnimateTiles ();\r\n\r\n//\r\n// update newly scrolled on tiles and animated tiles from the master screen\r\n//\r\n\tRFL_UpdateTiles ();\r\n\tRFL_EraseBlocks ();\r\n\r\n//\r\n// Update is all 0 except where sprites have changed or new area has\r\n// been scrolled on.  Go through all sprites and update the ones that cover\r\n// a non 0 update tile\r\n//\r\n\tRFL_UpdateSprites ();\r\n\r\n//\r\n// if the main program has a refresh hook set, call their function before\r\n// displaying the new page\r\n//\r\n\tif (refreshvector)\r\n\t\trefreshvector();\r\n\r\n//\r\n// update everything to the screen\r\n//\r\n\tVW_CGAFullUpdate ();\r\n\r\n//\r\n// calculate tics since last refresh for adaptive timing\r\n//\r\n\tif (lasttimecount > TimeCount)\r\n\t\tlasttimecount = TimeCount;\t\t// if the game was paused a LONG time\r\n\tdo\r\n\t{\r\n\t\tnewtime = TimeCount;\r\n\t\ttics = newtime-lasttimecount;\r\n\t} while (tics<MINTICS);\r\n\tlasttimecount = newtime;\r\n\r\n#ifdef PROFILE\r\n\titoa (tics,str,10);\r\n\tstrcat (str,\"\\t\");\r\n\tltoa (TimeCount,str2,10);\r\n\tstrcat (str,str2);\r\n\tstrcat (str,\"\\t\");\r\n\tltoa (LocalTime,str2,10);\r\n\tstrcat (str,str2);\r\n\tstrcat (str,\"\\n\");\r\n\twrite (profile,str,strlen(str));\r\n#endif\r\n\tif (tics>MAXTICS)\r\n\t\ttics = MAXTICS;\r\n\r\n}\r\n\r\n#endif\t\t// GRMODE == CGAGR\r\n"
        },
        {
          "name": "id_rf.h",
          "type": "blob",
          "size": 3.8271484375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_RF.H\r\n\r\n#define __ID_RF__\r\n\r\n#ifndef __ID_MM__\r\n#include \"ID_MM.H\"\r\n#endif\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tCONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define\tMINTICS\t\t\t\t2\r\n#define\tMAXTICS\t\t\t\t6\r\n\r\n#define\tMAPBORDER\t\t\t2\t\t// map border must be at least 1\r\n\r\n#define\tMAXSPRITES\t\t\t100\t\t// max tracked sprites\r\n#define\tMAXANIMTILES\t\t90\t\t// max animating tiles on screen\r\n#define MAXANIMTYPES\t\t50\t\t// max different unique anim tiles on map\r\n\r\n#define\tMAXMAPHEIGHT\t\t128\r\n\r\n#define\tPRIORITIES\t\t\t4\r\n#define\tMASKEDTILEPRIORITY\t3\t\t// planes go: 0,1,2,MTILES,3\r\n\r\n#define TILEGLOBAL\t\t\t256\r\n#define PIXGLOBAL\t\t\t16\r\n\r\n#define\tG_T_SHIFT\t\t\t8\t\t// global >> ?? = tile\r\n#define\tG_P_SHIFT\t\t\t4\t\t// global >> ?? = pixels\r\n#define P_T_SHIFT\t\t\t4\t\t// pixels >> ?? = tile\r\n\r\n#define\tPORTTILESWIDE\t\t21      // all drawing takes place inside a\r\n#define\tPORTTILESHIGH\t\t14\t\t// non displayed port of this size\r\n\r\n//#define\tPORTGLOBALWIDE\t\t(21*TILEGLOBAL)\r\n//#define\tPORTGLOBALHIGH\t\t(14*TILEGLOBAL)\r\n\r\n#define UPDATEWIDE\t\t\t(PORTTILESWIDE+1)\r\n#define UPDATEHIGH\t\t\tPORTTILESHIGH\r\n\r\n\r\n//===========================================================================\r\n\r\ntypedef enum {spritedraw,maskdraw} drawtype;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t PUBLIC VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\nextern\tboolean\t\tcompatability;\t\t\t// crippled refresh for wierdo SVGAs\r\n\r\nextern\tunsigned\ttics;\r\nextern\tlong\t\tlasttimecount;\r\n\r\nextern\tunsigned\toriginxglobal,originyglobal;\r\nextern\tunsigned\toriginxtile,originytile;\r\nextern\tunsigned\toriginxscreen,originyscreen;\r\n\r\nextern\tunsigned\tmapwidth,mapheight,mapbyteswide,mapwordswide\r\n\t\t\t\t\t,mapbytesextra,mapwordsextra;\r\nextern\tunsigned\tmapbwidthtable[MAXMAPHEIGHT];\r\n\r\nextern\tunsigned\toriginxmin,originxmax,originymin,originymax;\r\n\r\nextern\tunsigned\tmasterofs;\r\n\r\n//\r\n// the floating update window is also used by the view manager for\r\n// double buffer tracking\r\n//\r\n\r\nextern\tbyte\t\t*updateptr;\t\t\t\t// current start of update window\r\n\r\n#if GRMODE == CGAGR\r\nextern\tbyte\t\t*baseupdateptr;\r\n#endif\r\n\r\nextern unsigned\tblockstarts[UPDATEWIDE*UPDATEHIGH];\r\nextern unsigned\tupdatemapofs[UPDATEWIDE*UPDATEHIGH];\r\nextern unsigned\tuwidthtable[UPDATEHIGH];\t\t// lookup instead of multiple\r\n\r\n#define\tUPDATETERMINATE\t0x0301\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t PUBLIC FUNCTIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid RF_Startup (void);\r\nvoid RF_Shutdown (void);\r\n\r\nvoid RF_NewMap (void);\r\nvoid RF_MarkTileGraphics (void);\r\nvoid RF_NewPosition (unsigned x, unsigned y);\r\nvoid RF_Scroll (int x, int y);\r\n\r\nvoid RF_PlaceSprite (void **user,unsigned globalx,unsigned globaly,\r\n\tunsigned spritenumber, drawtype draw, int priority);\r\nvoid RF_RemoveSprite (void **user);\r\n\r\nvoid RF_Refresh (void);\r\nvoid RF_ForceRefresh (void);\r\nvoid RF_SetRefreshHook (void (*func) (void) );\r\n\r\n\r\n"
        },
        {
          "name": "id_rf_a.asm",
          "type": "blob",
          "size": 14.5322265625,
          "content": "; Keen Dreams Source Code\r\n; Copyright (C) 2014 Javier M. Chavez\r\n;\r\n; This program is free software; you can redistribute it and/or modify\r\n; it under the terms of the GNU General Public License as published by\r\n; the Free Software Foundation; either version 2 of the License, or\r\n; (at your option) any later version.\r\n;\r\n; This program is distributed in the hope that it will be useful,\r\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n; GNU General Public License for more details.\r\n;\r\n; You should have received a copy of the GNU General Public License along\r\n; with this program; if not, write to the Free Software Foundation, Inc.,\r\n; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n\r\n; ID_RF_A.ASM\r\n\r\nIDEAL\r\nMODEL\tMEDIUM,C\r\n\r\nINCLUDE\t\"ID_ASM.EQU\"\r\n\r\nCACHETILES\t= 1\t\t;enable master screen tile caching\r\n\r\n;============================================================================\r\n\r\nTILESWIDE\t=\t21\r\nTILESHIGH\t=\t14\r\n\r\nUPDATESIZE\t=\t(TILESWIDE+1)*TILESHIGH+1\r\n\r\nDATASEG\r\n\r\nEXTRN\tscreenseg:WORD\r\nEXTRN\tupdateptr:WORD\r\nEXTRN\tupdatestart:WORD\r\nEXTRN\tmasterofs:WORD\t\t;start of master tile port\r\nEXTRN\tbufferofs:WORD\t\t;start of current buffer port\r\nEXTRN\tscreenstart:WORD\t;starts of three screens (0/1/master) in EGA mem\r\nEXTRN\tgrsegs:WORD\r\nEXTRN\tmapsegs:WORD\r\nEXTRN\toriginmap:WORD\r\nEXTRN\tupdatemapofs:WORD\r\nEXTRN\ttilecache:WORD\r\nEXTRN\ttinf:WORD\t\t\t;seg pointer to map header and tile info\r\nEXTRN\tblockstarts:WORD\t;offsets from bufferofs for each update block\r\n\r\nplanemask\tdb\t?\r\nplanenum\tdb\t?\r\n\r\nCODESEG\r\n\r\nscreenstartcs\tdw\t?\t\t;in code segment for accesability\r\n\r\n\r\n\r\n\r\nIFE GRMODE-CGAGR\r\n;============================================================================\r\n;\r\n; CGA refresh routines\r\n;\r\n;============================================================================\r\n\r\nTILEWIDTH\t=\t4\r\n\r\n;=================\r\n;\r\n; RFL_NewTile\r\n;\r\n; Draws a composit two plane tile to the master screen and sets the update\r\n; spot to 1 in both update pages, forcing the tile to be copied to the\r\n; view pages the next two refreshes\r\n;\r\n; Called to draw newlly scrolled on strips and animating tiles\r\n;\r\n;=================\r\n\r\nPROC\tRFL_NewTile\tupdateoffset:WORD\r\nPUBLIC\tRFL_NewTile\r\nUSES\tSI,DI\r\n\r\n;\r\n; mark both update lists at this spot\r\n;\r\n\tmov\tdi,[updateoffset]\r\n\r\n\tmov\tbx,[updateptr]\t\t\t;start of update matrix\r\n\tmov\t[BYTE bx+di],1\r\n\r\n\tmov\tdx,SCREENWIDTH-TILEWIDTH\t\t;add to get to start of next line\r\n\r\n;\r\n; set di to the location in screenseg to draw the tile\r\n;\r\n\tshl\tdi,1\r\n\tmov\tsi,[updatemapofs+di]\t;offset in map from origin\r\n\tadd\tsi,[originmap]\r\n\tmov\tdi,[blockstarts+di]\t\t;screen location for tile\r\n\tadd\tdi,[masterofs]\r\n\r\n;\r\n; set BX to the foreground tile number and SI to the background number\r\n; If either BX or SI = 0xFFFF, the tile does not need to be masked together\r\n; as one of the planes totally eclipses the other\r\n;\r\n\tmov\tes,[mapsegs+2]\t\t\t;foreground plane\r\n\tmov\tbx,[es:si]\r\n\tmov\tes,[mapsegs]\t\t\t;background plane\r\n\tmov\tsi,[es:si]\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tor\tbx,bx\r\n\tjz\t@@singletile\r\n\tjmp\t@@maskeddraw\t\t\t;draw both together\r\n\r\n;=============\r\n;\r\n; Draw single background tile from main memory\r\n;\r\n;=============\r\n\r\n@@singletile:\r\n\tshl\tsi,1\r\n\tmov\tds,[grsegs+STARTTILE16*2+si]\r\n\r\n\txor\tsi,si\t\t\t\t\t;block is segment aligned\r\n\r\nREPT\t15\r\n\tmovsw\r\n\tmovsw\r\n\tadd\tdi,dx\r\nENDM\r\n\tmovsw\r\n\tmovsw\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\tret\r\n\r\n\r\n;=========\r\n;\r\n; Draw a masked tile combo\r\n; Interupts are disabled and the stack segment is reassigned\r\n;\r\n;=========\r\n@@maskeddraw:\r\n\tcli\t\t\t\t\t\t\t; don't allow ints when SS is set\r\n\tshl\tbx,1\r\n\tmov\tss,[grsegs+STARTTILE16M*2+bx]\r\n\tshl\tsi,1\r\n\tmov\tds,[grsegs+STARTTILE16*2+si]\r\n\r\n\txor\tsi,si\t\t\t\t\t;first word of tile data\r\n\r\nREPT\t16\r\n\tmov\tax,[si]\t\t\t\t\t;background tile\r\n\tand\tax,[ss:si]\t\t\t\t;mask\r\n\tor\tax,[ss:si+64]\t\t\t;masked data\r\n\tstosw\r\n\tmov\tax,[si+2]\t\t\t\t;background tile\r\n\tand\tax,[ss:si+2]\t\t\t;mask\r\n\tor\tax,[ss:si+66]\t\t\t;masked data\r\n\tstosw\r\n\tadd\tsi,4\r\n\tadd\tdi,dx\r\nENDM\r\n\r\n\tmov\tax,@DATA\r\n\tmov\tss,ax\r\n\tsti\r\n\tmov\tds,ax\r\n\tret\r\nENDP\r\n\r\nENDIF\r\n\r\n\r\n\r\nIFE GRMODE-EGAGR\r\n;===========================================================================\r\n;\r\n; EGA refresh routines\r\n;\r\n;===========================================================================\r\n\r\nTILEWIDTH\t=\t2\r\n\r\n;=================\r\n;\r\n; RFL_NewTile\r\n;\r\n; Draws a composit two plane tile to the master screen and sets the update\r\n; spot to 1 in both update pages, forcing the tile to be copied to the\r\n; view pages the next two refreshes\r\n;\r\n; Called to draw newlly scrolled on strips and animating tiles\r\n;\r\n; Assumes write mode 0\r\n;\r\n;=================\r\n\r\nPROC\tRFL_NewTile\tupdateoffset:WORD\r\nPUBLIC\tRFL_NewTile\r\nUSES\tSI,DI\r\n\r\n;\r\n; mark both update lists at this spot\r\n;\r\n\tmov\tdi,[updateoffset]\r\n\r\n\tmov\tbx,[updatestart]\t\t;page 0 pointer\r\n\tmov\t[BYTE bx+di],1\r\n\tmov\tbx,[updatestart+2]\t\t;page 1 pointer\r\n\tmov\t[BYTE bx+di],1\r\n\r\n;\r\n; set screenstartcs to the location in screenseg to draw the tile\r\n;\r\n\tshl\tdi,1\r\n\tmov\tsi,[updatemapofs+di]\t;offset in map from origin\r\n\tadd\tsi,[originmap]\r\n\tmov\tdi,[blockstarts+di]\t\t;screen location for tile\r\n\tadd\tdi,[masterofs]\r\n\tmov\t[cs:screenstartcs],di\r\n\r\n;\r\n; set BX to the foreground tile number and SI to the background number\r\n; If either BX or SI = 0xFFFF, the tile does not need to be masked together\r\n; as one of the planes totally eclipses the other\r\n;\r\n\tmov\tes,[mapsegs+2]\t\t\t;foreground plane\r\n\tmov\tbx,[es:si]\r\n\tmov\tes,[mapsegs]\t\t\t;background plane\r\n\tmov\tsi,[es:si]\r\n\r\n\tmov\tes,[screenseg]\r\n\tmov\tdx,SC_INDEX\t\t\t\t;for stepping through map mask planes\r\n\r\n\tor\tbx,bx\r\n\tjz\t@@singletile\r\n\tjmp\t@@maskeddraw\t\t\t;draw both together\r\n\r\n;=========\r\n;\r\n; No foreground tile, so draw a single background tile.\r\n; Use the master screen cache if possible\r\n;\r\n;=========\r\n@@singletile:\r\n\r\n\tmov\tbx,SCREENWIDTH-2\t\t;add to get to start of next line\r\n\tshl\tsi,1\r\n\r\nIFE CACHETILES\r\n\tjmp\t@@singlemain\r\nENDIF\r\n\r\n\tmov\tax,[tilecache+si]\r\n\tor\tax,ax\r\n\tjz\t@@singlemain\r\n;=============\r\n;\r\n; Draw single tile from cache\r\n;\r\n;=============\r\n\r\n\tmov\tsi,ax\r\n\r\n\tmov\tax,SC_MAPMASK + 15*256\t;all planes\r\n\tWORDOUT\r\n\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_MODE + 1*256\t\t;write mode 1\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[cs:screenstartcs]\r\n\tmov\tds,[screenseg]\r\n\r\nREPT\t15\r\n\tmovsb\r\n\tmovsb\r\n\tadd\tsi,bx\r\n\tadd\tdi,bx\r\nENDM\r\n\tmovsb\r\n\tmovsb\r\n\r\n\txor\tah,ah\t\t\t\t\t;write mode 0\r\n\tWORDOUT\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\tret\r\n\r\n;=============\r\n;\r\n; Draw single tile from main memory\r\n;\r\n;=============\r\n\r\n@@singlemain:\r\n\tmov\tax,[cs:screenstartcs]\r\n\tmov\t[tilecache+si],ax\t\t;next time it can be drawn from here with latch\r\n\tmov\tds,[grsegs+STARTTILE16*2+si]\r\n\r\n\txor\tsi,si\t\t\t\t\t;block is segment aligned\r\n\r\n\tmov\tax,SC_MAPMASK+0001b*256\t;map mask for plane 0\r\n\r\n\tmov\tcx,4\t\t\t\t\t;draw four planes\r\n@@planeloop:\r\n\tmov\tdx,SC_INDEX\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[cs:screenstartcs]\t;start at same place in all planes\r\n\r\nREPT\t15\r\n\tmovsw\r\n\tadd\tdi,bx\r\nENDM\r\n\tmovsw\r\n\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\tloop\t@@planeloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\tret\r\n\r\n\r\n;=========\r\n;\r\n; Draw a masked tile combo\r\n; Interupts are disabled and the stack segment is reassigned\r\n;\r\n;=========\r\n@@maskeddraw:\r\n\tcli\t\t\t\t\t\t\t; don't allow ints when SS is set\r\n\tshl\tbx,1\r\n\tmov\tss,[grsegs+STARTTILE16M*2+bx]\r\n\tshl\tsi,1\r\n\tmov\tds,[grsegs+STARTTILE16*2+si]\r\n\r\n\txor\tsi,si\t\t\t\t\t;first word of tile data\r\n\r\n\tmov\tax,SC_MAPMASK+0001b*256\t;map mask for plane 0\r\n\r\n\tmov\tdi,[cs:screenstartcs]\r\n@@planeloopm:\r\n\tWORDOUT\r\ntileofs\t\t=\t0\r\nlineoffset\t=\t0\r\nREPT\t16\r\n\tmov\tbx,[si+tileofs]\t\t\t;background tile\r\n\tand\tbx,[ss:tileofs]\t\t\t;mask\r\n\tor\tbx,[ss:si+tileofs+32]\t;masked data\r\n\tmov\t[es:di+lineoffset],bx\r\ntileofs\t\t=\ttileofs + 2\r\nlineoffset\t=\tlineoffset + SCREENWIDTH\r\nENDM\r\n\tadd\tsi,32\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\tcmp\tah,10000b\r\n\tje\t@@done\t\t\t\t\t;drawn all four planes\r\n\tjmp\t@@planeloopm\r\n\r\n@@done:\r\n\tmov\tax,@DATA\r\n\tmov\tss,ax\r\n\tsti\r\n\tmov\tds,ax\r\n\tret\r\nENDP\r\n\r\nENDIF\r\n\r\nIFE GRMODE-VGAGR\r\n;============================================================================\r\n;\r\n; VGA refresh routines\r\n;\r\n;============================================================================\r\n\r\n\r\nENDIF\r\n\r\n\r\n;============================================================================\r\n;\r\n; reasonably common refresh routines\r\n;\r\n;============================================================================\r\n\r\n\r\n;=================\r\n;\r\n; RFL_UpdateTiles\r\n;\r\n; Scans through the update matrix pointed to by updateptr, looking for 1s.\r\n; A 1 represents a tile that needs to be copied from the master screen to the\r\n; current screen (a new row or an animated tiled).  If more than one adjacent\r\n; tile in a horizontal row needs to be copied, they will be copied as a group.\r\n;\r\n; Assumes write mode 1\r\n;\r\n;=================\r\n\r\n\r\n; AX\t0/1 for scasb, temp for segment register transfers\r\n; BX    width for block copies\r\n; CX\tREP counter\r\n; DX\tline width deltas\r\n; SI\tsource for copies\r\n; DI\tscas dest / movsb dest\r\n; BP\tpointer to UPDATETERMINATE\r\n;\r\n; DS\r\n; ES\r\n; SS\r\n\r\nPROC\tRFL_UpdateTiles\r\nPUBLIC\tRFL_UpdateTiles\r\nUSES\tSI,DI,BP\r\n\r\n\tjmp\tSHORT @@realstart\r\n@@done:\r\n;\r\n; all tiles have been scanned\r\n;\r\n\tret\r\n\r\n@@realstart:\r\n\tmov\tdi,[updateptr]\r\n\tmov\tbp,(TILESWIDE+1)*TILESHIGH+1\r\n\tadd\tbp,di\t\t\t\t\t; when di = bx, all tiles have been scanned\r\n\tpush\tdi\r\n\tmov\tcx,-1\t\t\t\t\t; definately scan the entire thing\r\n\r\n;\r\n; scan for a 1 in the update list, meaning a tile needs to be copied\r\n; from the master screen to the current screen\r\n;\r\n@@findtile:\r\n\tpop\tdi\t\t\t\t\t\t; place to continue scaning from\r\n\tmov\tax,ss\r\n\tmov\tes,ax\t\t\t\t\t; search in the data segment\r\n\tmov\tds,ax\r\n\tmov al,1\r\n\trepne\tscasb\r\n\tcmp\tdi,bp\r\n\tje\t@@done\r\n\r\n\tcmp\t[BYTE di],al\r\n\tjne\t@@singletile\r\n\tjmp\t@@tileblock\r\n\r\n;============\r\n;\r\n; copy a single tile\r\n;\r\n;============\r\nEVEN\r\n@@singletile:\r\n\tinc\tdi\t\t\t\t\t\t; we know the next tile is nothing\r\n\tpush\tdi\t\t\t\t\t; save off the spot being scanned\r\n\tsub\tdi,[updateptr]\r\n\tshl\tdi,1\r\n\tmov\tdi,[blockstarts-4+di]\t; start of tile location on screen\r\n\tmov\tsi,di\r\n\tadd\tdi,[bufferofs]\t\t\t; dest in current screen\r\n\tadd\tsi,[masterofs]\t\t\t; source in master screen\r\n\r\n\tmov\tdx,SCREENWIDTH-TILEWIDTH\r\n\tmov\tax,[screenseg]\r\n\tmov\tds,ax\r\n\tmov\tes,ax\r\n\r\n;--------------------------\r\n\r\nIFE GRMODE-CGAGR\r\n\r\nREPT\t15\r\n\tmovsw\r\n\tmovsw\r\n\tadd\tsi,dx\r\n\tadd\tdi,dx\r\nENDM\r\n\tmovsw\r\n\tmovsw\r\n\r\nENDIF\r\n\r\n;--------------------------\r\n\r\nIFE GRMODE-EGAGR\r\n\r\nREPT\t15\r\n\tmovsb\r\n\tmovsb\r\n\tadd\tsi,dx\r\n\tadd\tdi,dx\r\nENDM\r\n\tmovsb\r\n\tmovsb\r\n\r\nENDIF\r\n\r\n;--------------------------\r\n\r\n\tjmp\t@@findtile\r\n\r\n;============\r\n;\r\n; more than one tile in a row needs to be updated, so do it as a group\r\n;\r\n;============\r\nEVEN\r\n@@tileblock:\r\n\tmov\tdx,di\t\t\t\t\t; hold starting position + 1 in dx\r\n\tinc\tdi\t\t\t\t\t\t; we know the next tile also gets updated\r\n\trepe\tscasb\t\t\t\t; see how many more in a row\r\n\tpush\tdi\t\t\t\t\t; save off the spot being scanned\r\n\r\n\tmov\tbx,di\r\n\tsub\tbx,dx\t\t\t\t\t; number of tiles in a row\r\n\tshl\tbx,1\t\t\t\t\t; number of bytes / row\r\n\r\n\tmov\tdi,dx\t\t\t\t\t; lookup position of start tile\r\n\tsub\tdi,[updateptr]\r\n\tshl\tdi,1\r\n\tmov\tdi,[blockstarts-2+di]\t; start of tile location\r\n\tmov\tsi,di\r\n\tadd\tdi,[bufferofs]\t\t\t; dest in current screen\r\n\tadd\tsi,[masterofs]\t\t\t; source in master screen\r\n\r\n\tmov\tdx,SCREENWIDTH\r\n\tsub\tdx,bx\t\t\t\t\t; offset to next line on screen\r\nIFE GRMODE-CGAGR\r\n\tsub\tdx,bx\t\t\t\t\t; bx is words wide in CGA tiles\r\nENDIF\r\n\r\n\tmov\tax,[screenseg]\r\n\tmov\tds,ax\r\n\tmov\tes,ax\r\n\r\nREPT\t15\r\n\tmov\tcx,bx\r\nIFE GRMODE-CGAGR\r\n\trep\tmovsw\r\nENDIF\r\nIFE GRMODE-EGAGR\r\n\trep\tmovsb\r\nENDIF\r\n\tadd\tsi,dx\r\n\tadd\tdi,dx\r\nENDM\r\n\tmov\tcx,bx\r\nIFE GRMODE-CGAGR\r\n\trep\tmovsw\r\nENDIF\r\nIFE GRMODE-EGAGR\r\n\trep\tmovsb\r\nENDIF\r\n\r\n\tdec\tcx\t\t\t\t\t\t; was 0 from last rep movsb, now $ffff for scasb\r\n\tjmp\t@@findtile\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n\r\n\r\n;=================\r\n;\r\n; RFL_MaskForegroundTiles\r\n;\r\n; Scan through update looking for 3's.  If the foreground tile there is a\r\n; masked foreground tile, draw it to the screen\r\n;\r\n;=================\r\n\r\nPROC\tRFL_MaskForegroundTiles\r\nPUBLIC\tRFL_MaskForegroundTiles\r\nUSES\tSI,DI,BP\r\n\tjmp\tSHORT @@realstart\r\n@@done:\r\n;\r\n; all tiles have been scanned\r\n;\r\n\tret\r\n\r\n@@realstart:\r\n\tmov\tdi,[updateptr]\r\n\tmov\tbp,(TILESWIDE+1)*TILESHIGH+2\r\n\tadd\tbp,di\t\t\t\t\t; when di = bx, all tiles have been scanned\r\n\tpush\tdi\r\n\tmov\tcx,-1\t\t\t\t\t; definately scan the entire thing\r\n;\r\n; scan for a 3 in the update list\r\n;\r\n@@findtile:\r\n\tmov\tax,ss\r\n\tmov\tes,ax\t\t\t\t\t; scan in the data segment\r\n\tmov\tal,3\r\n\tpop\tdi\t\t\t\t\t\t; place to continue scaning from\r\n\trepne\tscasb\r\n\tcmp\tdi,bp\r\n\tje\t@@done\r\n\r\n;============\r\n;\r\n; found a tile, see if it needs to be masked on\r\n;\r\n;============\r\n\r\n\tpush\tdi\r\n\r\n\tsub\tdi,[updateptr]\r\n\tshl\tdi,1\r\n\tmov\tsi,[updatemapofs-2+di]\t; offset from originmap\r\n\tadd\tsi,[originmap]\r\n\r\n\tmov\tes,[mapsegs+2]\t\t\t; foreground map plane segment\r\n\tmov\tsi,[es:si]\t\t\t\t; foreground tile number\r\n\r\n\tor\tsi,si\r\n\tjz\t@@findtile\t\t\t\t; 0 = no foreground tile\r\n\r\n\tmov\tbx,si\r\n\tadd\tbx,INTILE\t\t\t\t;INTILE tile info table\r\n\tmov\tes,[tinf]\r\n\ttest\t[BYTE PTR es:bx],80h\t\t;high bit = masked tile\r\n\tjz\t@@findtile\r\n\r\n;-------------------\r\n\r\nIFE GRMODE-CGAGR\r\n;=================\r\n;\r\n; mask the tile CGA\r\n;\r\n;=================\r\n\r\n\tmov\tdi,[blockstarts-2+di]\r\n\tadd\tdi,[bufferofs]\r\n\tmov\tes,[screenseg]\r\n\tshl\tsi,1\r\n\tmov\tds,[grsegs+STARTTILE16M*2+si]\r\n\r\n\tmov\tbx,64\t\t\t\t\t;data starts 64 bytes after mask\r\n\r\n\txor\tsi,si\r\n\r\nlineoffset\t=\t0\r\nREPT\t16\r\n\tmov\tax,[es:di+lineoffset]\t;background\r\n\tand\tax,[si]\t\t\t\t\t;mask\r\n\tor\tax,[si+bx]\t\t\t\t;masked data\r\n\tmov\t[es:di+lineoffset],ax\t;background\r\n\tinc\tsi\r\n\tinc\tsi\r\n\tmov\tax,[es:di+lineoffset+2]\t;background\r\n\tand\tax,[si]\t\t\t\t\t;mask\r\n\tor\tax,[si+bx]\t\t\t\t;masked data\r\n\tmov\t[es:di+lineoffset+2],ax\t;background\r\n\tinc\tsi\r\n\tinc\tsi\r\nlineoffset\t=\tlineoffset + SCREENWIDTH\r\nENDM\r\nENDIF\r\n\r\n;-------------------\r\n\r\nIFE GRMODE-EGAGR\r\n;=================\r\n;\r\n; mask the tile\r\n;\r\n;=================\r\n\r\n\tmov\t[BYTE planemask],1\r\n\tmov\t[BYTE planenum],0\r\n\r\n\tmov\tdi,[blockstarts-2+di]\r\n\tadd\tdi,[bufferofs]\r\n\tmov\t[cs:screenstartcs],di\r\n\tmov\tes,[screenseg]\r\n\tshl\tsi,1\r\n\tmov\tds,[grsegs+STARTTILE16M*2+si]\r\n\r\n\tmov\tbx,32\t\t\t\t\t;data starts 32 bytes after mask\r\n\r\n@@planeloopm:\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tal,SC_MAPMASK\r\n\tmov\tah,[ss:planemask]\r\n\tWORDOUT\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tal,GC_READMAP\r\n\tmov\tah,[ss:planenum]\r\n\tWORDOUT\r\n\r\n\txor\tsi,si\r\n\tmov\tdi,[cs:screenstartcs]\r\nlineoffset\t=\t0\r\nREPT\t16\r\n\tmov\tcx,[es:di+lineoffset]\t;background\r\n\tand\tcx,[si]\t\t\t\t\t;mask\r\n\tor\tcx,[si+bx]\t\t\t\t;masked data\r\n\tinc\tsi\r\n\tinc\tsi\r\n\tmov\t[es:di+lineoffset],cx\r\nlineoffset\t=\tlineoffset + SCREENWIDTH\r\nENDM\r\n\tadd\tbx,32\t\t\t\t\t;the mask is now further away\r\n\tinc\t[ss:planenum]\r\n\tshl\t[ss:planemask],1\t\t;shift plane mask over for next plane\r\n\tcmp\t[ss:planemask],10000b\t;done all four planes?\r\n\tje\t@@drawn\t\t\t\t\t;drawn all four planes\r\n\tjmp\t@@planeloopm\r\n\r\n@@drawn:\r\nENDIF\r\n\r\n;-------------------\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\r\n\tmov\tcx,-1\t\t\t\t\t;definately scan the entire thing\r\n\r\n\tjmp\t@@findtile\r\n\r\nENDP\r\n\r\n\r\nEND\r\n\r\n"
        },
        {
          "name": "id_sd.c",
          "type": "blob",
          "size": 39.1630859375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n//\tID Engine\r\n//\tID_SD.c - Sound Manager\r\n//\tv1.0d1\r\n//\tBy Jason Blochowiak\r\n//\r\n\r\n//\r\n//\tThis module handles dealing with generating sound on the appropriate\r\n//\t\thardware\r\n//\r\n//\tDepends on: User Mgr (for parm checking)\r\n//\r\n//\tGlobals:\r\n//\t\tFor User Mgr:\r\n//\t\t\tSoundSourcePresent - Sound Source thingie present?\r\n//\t\t\tSoundBlasterPresent - SoundBlaster card present?\r\n//\t\t\tAdLibPresent - AdLib card present?\r\n//\t\t\tSoundMode - What device is used for sound effects\r\n//\t\t\t\t(Use SM_SetSoundMode() to set)\r\n//\t\t\tMusicMode - What device is used for music\r\n//\t\t\t\t(Use SM_SetMusicMode() to set)\r\n//\t\tFor Cache Mgr:\r\n//\t\t\tNeedsDigitized - load digitized sounds?\r\n//\t\t\tNeedsMusic - load music?\r\n//\r\n\r\n#pragma hdrstop\t\t// Wierdo thing with MUSE\r\n\r\n#include <dos.h>\r\n\r\n#ifdef\t_MUSE_      // Will be defined in ID_Types.h\r\n#include \"ID_SD.h\"\r\n#else\r\n#include \"ID_HEADS.H\"\r\n#endif\r\n#pragma\thdrstop\r\n#pragma\twarn\t-pia\r\n\r\n#define\tSDL_SoundFinished()\t{SoundNumber = SoundPriority = 0;}\r\n\r\n// Macros for SoundBlaster stuff\r\n#define\tsbOut(n,b)\toutportb((n) + sbLocation,b)\r\n#define\tsbIn(n)\t\tinportb((n) + sbLocation)\r\n#define\tsbWriteDelay()\twhile (sbIn(sbWriteStat) & 0x80);\r\n#define\tsbReadDelay()\twhile (sbIn(sbDataAvail) & 0x80);\r\n\r\n// Macros for AdLib stuff\r\n#define\tselreg(n)\toutportb(0x388,n)\r\n#define\twritereg(n)\toutportb(0x389,n)\r\n#define\treadstat()\tinportb(0x388)\r\n\r\n\r\n//\r\n//\tStuff I need\r\n//\r\n// This table maps channel numbers to carrier and modulator op cells\r\nstatic\tbyte\t\t\tcarriers[9] =  { 3, 4, 5,11,12,13,19,20,21},\r\n\t\t\t\t\t\tmodifiers[9] = { 0, 1, 2, 8, 9,10,16,17,18};\r\nstatic\tActiveTrack\t\t*tracks[sqMaxTracks];\r\nstatic\tword\t\t\tsqMode,sqFadeStep;\r\n\r\n//\tGlobal variables\r\n\tboolean\t\tLeaveDriveOn,\r\n\t\t\t\tSoundSourcePresent,SoundBlasterPresent,AdLibPresent,\r\n\t\t\t\tNeedsDigitized,NeedsMusic;\r\n\tSDMode\t\tSoundMode;\r\n\tSMMode\t\tMusicMode;\r\n\tlongword\tTimeCount;\r\n\tword\t\t*SoundTable;\t// Really * _seg *SoundTable, but that don't work\r\n\tboolean\t\tssIsTandy;\r\n\tword\t\tssPort = 2;\r\n\r\n//\tInternal variables\r\nstatic\tboolean\t\t\tSD_Started;\r\nstatic\tboolean\t\t\tTimerDone;\r\nstatic\tword\t\t\tTimerVal,TimerDelay10,TimerDelay25,TimerDelay100;\r\nstatic\tchar\t\t\t*ParmStrings[] =\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"noal\",\r\n\t\t\t\t\t\t\t\"nosb\",\r\n\t\t\t\t\t\t\t\"nodr\",\r\n\t\t\t\t\t\t\t\"noss\",\r\n\t\t\t\t\t\t\t\"sst\",\r\n\t\t\t\t\t\t\t\"ss1\",\r\n\t\t\t\t\t\t\t\"ss2\",\r\n\t\t\t\t\t\t\t\"ss3\",\r\n\t\t\t\t\t\t\tnil\r\n\t\t\t\t\t\t};\r\nstatic\tvoid\t\t\t(*SoundUserHook)(void);\r\nstatic\tword\t\t\tSoundNumber,SoundPriority;\r\nstatic\tvoid interrupt\t(*t0OldService)(void);\r\nstatic\tword\t\t\tt0CountTable[] = {2,2,2,2,10,10};\r\nstatic\tlong\t\t\tLocalTime;\r\n\r\n//\tPC Sound variables\r\nstatic\tbyte\t\t\tpcLastSample,far *pcSound;\r\nstatic\tlongword\t\tpcLengthLeft;\r\nstatic\tword\t\t\tpcSoundLookup[255];\r\n\r\n//\tSoundBlaster variables\r\nstatic\tboolean\t\t\tsbNoCheck,\r\n\t\t\t\t\t\tsbSamplePlaying,\r\n\t\t\t\t\t\tsbIsCompressed,sbCompFirst;\r\nstatic\tbyte\t\t\tsbOldIntMask = -1;\r\nstatic\tbyte\t\t\thuge *sbNextSegPtr;\r\nstatic\tint\t\t\t\tsbLocation = -1,sbInterrupt = 7,sbIntVec = 0xf,\r\n\t\t\t\t\t\tsbIntVectors[] = {-1,-1,0xa,0xb,-1,0xd,-1,0xf};\r\nstatic\tlongword\t\tsbNextSegLen;\r\nstatic\tSampledSound\thuge *sbSamples;\r\nstatic\tvoid interrupt\t(*sbOldIntHand)(void);\r\n\r\n//\tSoundSource variables\r\nstatic\tboolean\t\t\tssNoCheck,\r\n\t\t\t\t\t\tssIsCompressed,ssCompFirst,\r\n\t\t\t\t\t\tssIsSlow;\r\nstatic\tword\t\t\tssControl,ssStatus,ssData,\r\n\t\t\t\t\t\tssHoldOver;\r\nstatic\tbyte\t\t\tssOn,ssOff,\r\n\t\t\t\t\t\tfar *ssSample;\r\nstatic\tlongword\t\tssLengthLeft;\r\n\r\n//\tAdLib variables\r\nstatic\tboolean\t\t\talNoCheck;\r\nstatic\tbyte\t\t\tfar *alSound;\r\nstatic\tword\t\t\talBlock;\r\nstatic\tlongword\t\talLengthLeft;\r\n\r\n//\tSequencer variables\r\nstatic\tboolean\t\t\tsqActive;\r\nstatic\tword  \t\t\t*sqTracks[sqMaxTracks];\r\nstatic\tword\t\t\talFXReg;\r\n\r\n//\tInternal routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SetTimer0() - Sets system timer 0 to the specified speed\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SetTimer0(word speed)\r\n{\r\n#ifndef TPROF\t// If using Borland's profiling, don't screw with the timer\r\n\toutportb(0x43,0x36);\t\t\t\t// Change timer 0\r\n\toutportb(0x40,speed);\r\n\toutportb(0x40,speed >> 8);\r\n#else\r\n\tspeed++;\t// Shut the compiler up\r\n#endif\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SetIntsPerSec() - Uses SDL_SetTimer0() to set the number of\r\n//\t\tinterrupts generated by system timer 0 per second\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SetIntsPerSec(word ints)\r\n{\r\n\tSDL_SetTimer0(1192755 / ints);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_TimingService() - Used by SDL_InitDelay() to determine a timing\r\n//\t\tvalue for the current system that we're running on\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void interrupt\r\nSDL_TimingService(void)\r\n{\r\n\tTimerVal = _CX;\r\n\tTimerDone++;\r\n\r\n\toutportb(0x20,0x20);\t\t\t\t// Ack interrupt\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_InitDelay() - Sets up TimerDelay's for SDL_Delay()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_InitDelay(void)\r\n{\r\n\tint\t\ti;\r\n\tword\ttimer,speed;\r\n\r\n\tsetvect(8,SDL_TimingService);\t\t// Set to my timer 0 ISR\r\n\r\n\tSDL_SetIntsPerSec(1000);\t\t\t// Time 1ms\r\n\r\n\tfor (i = 0,timer = 0;i < 10;i++)\t// Do timing test 10 times\r\n\t{\r\n\tasm\txor\t\tdx,dx\t\t\t\t\t// Zero DX\r\n\tasm\tmov\t\tcx,0xffff\t\t\t\t// Put starting value in CX\r\n\tasm\tmov\t\t[TimerDone],cx\t\t\t// TimerDone = false - 1\r\nstartloop:\r\n\tasm\tor\t\t[TimerDone],0\r\n\tasm\tjnz\t\tstartloop\t\t\t\t// Make sure we're at the start\r\nloop:\r\n\tasm\ttest\t[TimerDone],1\t\t\t// See if TimerDone flag got hit\r\n\tasm\tjnz\t\tdone\t\t\t\t\t// Yep - drop out of the loop\r\n\tasm\tloop\tloop\r\ndone:\r\n\r\n\t\tif (0xffff - TimerVal > timer)\r\n\t\t\ttimer = 0xffff - TimerVal;\r\n\t}\r\n\ttimer += timer / 2;\t\t\t\t\t// Use some slop\r\n\tTimerDelay10 =  timer / (1000 / 10);\r\n\tTimerDelay25 =  timer / (1000 / 25);\r\n\tTimerDelay100 = timer / (1000 / 100);\r\n\r\n\tSDL_SetTimer0(0);\t\t\t\t\t// Reset timer 0\r\n\r\n\tsetvect(8,t0OldService);\t\t\t// Set back to old ISR\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_Delay() - Delays the specified amount of time\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_Delay(word delay)\r\n{\r\n\tif (!delay)\r\n\t\treturn;\r\n\r\nasm\tmov\t\tcx,[delay]\r\nloop:\r\nasm\ttest\t[TimerDone],0\t// Useless code - just for timing equivilency\r\nasm\tjnz\t\tdone\r\nasm\tloop\tloop\r\ndone:;\r\n}\r\n\r\n//\r\n//\tPC Sound code\r\n//\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_PCPlaySound() - Plays the specified sound on the PC speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_PCPlaySound(PCSound far *sound)\r\n{\r\nasm\tpushf\r\nasm\tcli\r\n\r\n\tpcLastSample = -1;\r\n\tpcLengthLeft = sound->common.length;\r\n\tpcSound = sound->data;\r\n\r\nasm\tpopf\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_PCStopSound() - Stops the current sound playing on the PC Speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_PCStopSound(void)\r\n{\r\nasm\tpushf\r\nasm\tcli\r\n\r\n\t(long)pcSound = 0;\r\n\r\nasm\tin\tal,0x61\t\t  \t// Turn the speaker off\r\nasm\tand\tal,0xfd\t\t\t// ~2\r\nasm\tout\t0x61,al\r\n\r\nasm\tpopf\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_PCService() - Handles playing the next sample in a PC sound\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_PCService(void)\r\n{\r\n\tbyte\ts;\r\n\tword\tt;\r\n\r\n\tif (pcSound)\r\n\t{\r\n\t\ts = *pcSound++;\r\n\t\tif (s != pcLastSample)\r\n\t\t{\r\n\t\tasm\tpushf\r\n\t\tasm\tcli\r\n\r\n\t\t\tpcLastSample = s;\r\n\t\t\tif (s)\t\t\t\t\t// We have a frequency!\r\n\t\t\t{\r\n\t\t\t\tt = pcSoundLookup[s];\r\n\t\t\tasm\tmov\tbx,[t]\r\n\r\n\t\t\tasm\tmov\tal,0xb6\t\t\t// Write to channel 2 (speaker) timer\r\n\t\t\tasm\tout\t43h,al\r\n\t\t\tasm\tmov\tal,bl\r\n\t\t\tasm\tout\t42h,al\t\t\t// Low byte\r\n\t\t\tasm\tmov\tal,bh\r\n\t\t\tasm\tout\t42h,al\t\t\t// High byte\r\n\r\n\t\t\tasm\tin\tal,0x61\t\t\t// Turn the speaker & gate on\r\n\t\t\tasm\tor\tal,3\r\n\t\t\tasm\tout\t0x61,al\r\n\t\t\t}\r\n\t\t\telse\t\t\t\t\t// Time for some silence\r\n\t\t\t{\r\n\t\t\tasm\tin\tal,0x61\t\t  \t// Turn the speaker & gate off\r\n\t\t\tasm\tand\tal,0xfc\t\t\t// ~3\r\n\t\t\tasm\tout\t0x61,al\r\n\t\t\t}\r\n\r\n\t\tasm\tpopf\r\n\t\t}\r\n\r\n\t\tif (!(--pcLengthLeft))\r\n\t\t{\r\n\t\t\tSDL_PCStopSound();\r\n\t\t\tSDL_SoundFinished();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ShutPC() - Turns off the pc speaker\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutPC(void)\r\n{\r\nasm\tpushf\r\nasm\tcli\r\n\r\nasm\tin\tal,0x61\t\t  \t// Turn the speaker & gate off\r\nasm\tand\tal,0xfc\t\t\t// ~3\r\nasm\tout\t0x61,al\r\n\r\nasm\tpopf\r\n}\r\n\r\n//\r\n//\tSoundBlaster code\r\n//\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SBStopSample() - Stops any active sampled sound and causes DMA\r\n//\t\trequests from the SoundBlaster to cease\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_SBStopSample(void)\r\n{\r\n\tbyte\tis;\r\n\r\n\tif (sbSamplePlaying)\r\n\t{\r\n\t\tsbSamplePlaying = false;\r\n\r\n\t\tsbWriteDelay();\r\n\t\tsbOut(sbWriteCmd,0xd0);\t// Turn off DSP DMA\r\n\r\n\t\tis = inportb(0x21);\t// Restore interrupt mask bit\r\n\t\tif (sbOldIntMask & (1 << sbInterrupt))\r\n\t\t\tis |= (1 << sbInterrupt);\r\n\t\telse\r\n\t\t\tis &= ~(1 << sbInterrupt);\r\n\t\toutportb(0x21,is);\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SBPlaySeg() - Plays a chunk of sampled sound on the SoundBlaster\r\n//\tInsures that the chunk doesn't cross a bank boundary, programs the DMA\r\n//\t controller, and tells the SB to start doing DMA requests for DAC\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic longword\r\nSDL_SBPlaySeg(byte huge *data,longword length)\r\n{\r\n\tunsigned\t\tdatapage;\r\n\tlongword\t\tdataofs,uselen;\r\n\r\n\tuselen = length;\r\n\tdatapage = FP_SEG(data) >> 12;\r\n\tdataofs = ( (FP_SEG(data)&0xfff)<<4 ) + FP_OFF(data);\r\n\tif (dataofs>=0x10000)\r\n\t{\r\n\t  datapage++;\r\n\t  dataofs-=0x10000;\r\n\t}\r\n\r\n\tif (dataofs + uselen > 0x10000)\r\n\t\tuselen = 0x10000 - dataofs;\r\n\r\n\tuselen--;\r\n\r\n\t// Program the DMA controller\r\n\toutportb(0x0a,5);\t\t\t\t\t\t\t// Mask off channel 1 DMA\r\n\toutportb(0x0c,0);\t\t\t\t\t\t\t// Clear byte ptr F/F to lower byte\r\n\toutportb(0x0b,0x49);\t\t\t\t\t\t// Set transfer mode for D/A conv\r\n\toutportb(0x02,(byte)dataofs);\t\t\t\t// Give LSB of address\r\n\toutportb(0x02,(byte)(dataofs >> 8));\t\t// Give MSB of address\r\n\toutportb(0x83,(byte)datapage);\t\t\t\t// Give page of address\r\n\toutportb(0x03,(byte)uselen);\t\t\t\t// Give LSB of length\r\n\toutportb(0x03,(byte)(uselen >> 8));\t\t\t// Give MSB of length\r\n\toutportb(0x0a,1);\t\t\t\t\t\t\t// Turn on channel 1 DMA\r\n\r\n\t// Start playing the thing\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteCmd,0x14);\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteData,(byte)uselen);\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteData,(byte)(uselen >> 8));\r\n\r\n\treturn(uselen + 1);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SBService() - Services the SoundBlaster DMA interrupt\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void interrupt\r\nSDL_SBService(void)\r\n{\r\n\tlongword\tused;\r\n\r\n\tsbIn(sbDataAvail);\t// Ack interrupt to SB\r\n\r\n\tif (sbNextSegPtr)\r\n\t{\r\n\t\tused = SDL_SBPlaySeg(sbNextSegPtr,sbNextSegLen);\r\n\t\tif (sbNextSegLen <= used)\r\n\t\t\tsbNextSegPtr = nil;\r\n\t\telse\r\n\t\t{\r\n\t\t\tsbNextSegPtr += used;\r\n\t\t\tsbNextSegLen -= used;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tSDL_SBStopSample();\r\n\t\tSDL_SoundFinished();\r\n\t}\r\n\r\n\toutportb(0x20,0x20);\t// Ack interrupt\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SBPlaySample() - Plays a sampled sound on the SoundBlaster. Sets up\r\n//\t\tDMA to play the sound\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_SBPlaySample(SampledSound far *sample)\r\n{\r\n\tbyte\t\t\thuge *data,\r\n\t\t\t\t\ttimevalue;\r\n\tlongword\t\tused;\r\n\r\n\tSDL_SBStopSample();\r\n\r\n\tdata = (byte huge *)(sample->data);\r\n\ttimevalue = 256 - (1000000 / sample->hertz);\r\n\r\n\t// DEBUG - deal with compressed sounds\r\n\r\n\t// Set the SoundBlaster DAC time constant\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteCmd,0x40);\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteData,timevalue);\r\n\r\n\tused = SDL_SBPlaySeg(data,sample->common.length);\r\n\tif (sample->common.length <= used)\r\n\t\tsbNextSegPtr = nil;\r\n\telse\r\n\t{\r\n\t\tsbNextSegPtr = data + used;\r\n\t\tsbNextSegLen = sample->common.length - used;\r\n\t}\r\n\r\n\t// Save old interrupt status and unmask ours\r\n\tsbOldIntMask = inportb(0x21);\r\n\toutportb(0x21,sbOldIntMask & ~(1 << sbInterrupt));\r\n\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteCmd,0xd4);\t\t\t\t\t\t// Make sure DSP DMA is enabled\r\n\r\n\tsbSamplePlaying = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_CheckSB() - Checks to see if a SoundBlaster resides at a\r\n//\t\tparticular I/O location\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nSDL_CheckSB(int port)\r\n{\r\n\tint\ti;\r\n\r\n\tsbLocation = port << 4;\t\t// Initialize stuff for later use\r\n\r\n\tsbOut(sbReset,true);\t\t// Reset the SoundBlaster DSP\r\n\tSDL_Delay(TimerDelay10);\t// Wait 4usec\r\n\tsbOut(sbReset,false);\t\t// Turn off sb DSP reset\r\n\tSDL_Delay(TimerDelay100);\t// Wait 100usec\r\n\tfor (i = 0;i < 100;i++)\r\n\t{\r\n\t\tif (sbIn(sbDataAvail) & 0x80)\t\t// If data is available...\r\n\t\t{\r\n\t\t\tif (sbIn(sbReadData) == 0xaa)\t// If it matches correct value\r\n\t\t\t\treturn(true);\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tsbLocation = -1;\t\t\t// Otherwise not a SoundBlaster\r\n\t\t\t\treturn(false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tsbLocation = -1;\t\t\t\t\t\t// Retry count exceeded - fail\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tChecks to see if a SoundBlaster is in the system. If the port passed is\r\n//\t\t-1, then it scans through all possible I/O locations. If the port\r\n//\t\tpassed is 0, then it uses the default (2). If the port is >0, then\r\n//\t\tit just passes it directly to SDL_CheckSB()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nSDL_DetectSoundBlaster(int port)\r\n{\r\n\tint\ti;\r\n\r\n\tif (port == 0)\t\t\t\t\t// If user specifies default, use 2\r\n\t\tport = 2;\r\n\tif (port == -1)\r\n\t{\r\n\t\tif (SDL_CheckSB(2))\t\t\t// Check default before scanning\r\n\t\t\treturn(true);\r\n\r\n\t\tfor (i = 1;i <= 6;i++)\t\t// Scan through possible SB locations\r\n\t\t\tif (SDL_CheckSB(i))\t\t// If found at this address,\r\n\t\t\t\treturn(true);\t\t//\treturn success\r\n\t\treturn(false);\t\t\t\t// All addresses failed, return failure\r\n\t}\r\n\telse\r\n\t\treturn(SDL_CheckSB(port));\t// User specified address or default\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_StartSB() - Turns on the SoundBlaster\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_StartSB(void)\r\n{\r\n\tsbOldIntHand = getvect(sbIntVec);\t// Get old interrupt handler\r\n\tsetvect(sbIntVec,SDL_SBService);\t// Set mine\r\n\r\n\tsbWriteDelay();\r\n\tsbOut(sbWriteCmd,0xd1);\t\t\t\t// Turn on DSP speaker\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ShutSB() - Turns off the SoundBlaster\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutSB(void)\r\n{\r\n\tSDL_SBStopSample();\r\n\r\n\tsetvect(sbIntVec,sbOldIntHand);\t\t// Set vector back\r\n}\r\n\r\n//\tSound Source Code\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SSStopSample() - Stops a sample playing on the Sound Source\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_SSStopSample(void)\r\n{\r\n\t(long)ssSample = 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SSService() - Handles playing the next sample on the Sound Source\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SSService(void)\r\n{\r\n\tboolean\tgotit;\r\n\tbyte\tv;\r\n\r\n\twhile (ssSample)\r\n\t{\r\n\tasm\tmov\t\tdx,[ssStatus]\t// Check to see if FIFO is currently empty\r\n\tasm\tin\t\tal,dx\r\n\tasm\ttest\tal,0x40\r\n\tasm\tjnz\t\tdone\t\t\t// Nope - don't push any more data out\r\n\r\n\t\tgotit = false;\r\n\t\tif (ssIsSlow && (ssHoldOver != (word)-1))\r\n\t\t{\r\n\t\t\tgotit = true;\r\n\t\t\tv = ssHoldOver;\r\n\t\t\tssHoldOver = -1;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (ssIsCompressed)\r\n\t\t\t{\r\n\t\t\t\tif (ssCompFirst)\r\n\t\t\t\t{\r\n\t\t\t\t\t// DEBUG - not written\r\n\t\t\t\t}\r\n\t\t\t\t// DEBUG - not written\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tv = *ssSample++;\r\n\t\t\t\tgotit = true;\r\n\t\t\t\tif (ssIsSlow)\r\n\t\t\t\t\tssHoldOver = v;\r\n\t\t\t\tif (!(--ssLengthLeft))\r\n\t\t\t\t{\r\n\t\t\t\t\t(long)ssSample = 0;\r\n\t\t\t\t\tSDL_SoundFinished();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (gotit)\r\n\t\t{\r\n\t\tasm\tmov\t\tdx,[ssData]\t\t// Pump the value out\r\n\t\tasm\tmov\t\tal,[v]\r\n\t\tasm\tout\t\tdx,al\r\n\r\n\t\tasm\tmov\t\tdx,[ssControl]\t// Pulse printer select\r\n\t\tasm\tmov\t\tal,[ssOff]\r\n\t\tasm\tout\t\tdx,al\r\n\t\tasm\tpush\tax\r\n\t\tasm\tpop\t\tax\r\n\t\tasm\tmov\t\tal,[ssOn]\r\n\t\tasm\tout\t\tdx,al\r\n\r\n\t\tasm\tpush\tax\t\t\t\t// Delay a short while\r\n\t\tasm\tpop\t\tax\r\n\t\tasm\tpush\tax\r\n\t\tasm\tpop\t\tax\r\n\t\t}\r\n\t}\r\ndone:\r\n\t;\t// Garbage for compiler\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SSPlaySample() - Plays the specified sample on the Sound Source\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_SSPlaySample(SampledSound far *sample)\r\n{\r\nasm\tpushf\r\nasm\tcli\r\n\r\n\tssLengthLeft = sample->common.length;\r\n\tssSample = sample->data;\r\n\tssIsSlow = sample->hertz < 7000;\r\n\tssHoldOver = -1;\r\n\tif (sample->bits < 8)\r\n\t\tssIsCompressed = ssCompFirst = true;\r\n\r\nasm\tpopf\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_StartSS() - Sets up for and turns on the Sound Source\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_StartSS(void)\r\n{\r\n\tif (ssPort == 3)\r\n\t\tssControl = 0x27a;\t// If using LPT3\r\n\telse if (ssPort == 2)\r\n\t\tssControl = 0x37a;\t// If using LPT2\r\n\telse\r\n\t\tssControl = 0x3be;\t// If using LPT1\r\n\tssStatus = ssControl - 1;\r\n\tssData = ssStatus - 1;\r\n\r\n\tssOn = 0x04;\r\n\tif (ssIsTandy)\r\n\t\tssOff = 0x0e;\t\t\t\t// Tandy wierdness\r\n\telse\r\n\t\tssOff = 0x0c;\t\t\t\t// For normal machines\r\n\r\n\toutportb(ssControl,ssOn);\t\t// Enable SS\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ShutSS() - Turns off the Sound Source\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutSS(void)\r\n{\r\n\toutportb(ssControl,ssOff);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_CheckSS() - Checks to see if a Sound Source is present at the\r\n//\t\tlocation specified by the sound source variables\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nSDL_CheckSS(void)\r\n{\r\n\tboolean\t\tpresent = false;\r\n\tlongword\tlasttime;\r\n\r\n\t// Turn the Sound Source on and wait awhile (4 ticks)\r\n\tSDL_StartSS();\r\n\r\n\tlasttime = TimeCount;\r\n\twhile (TimeCount < lasttime + 4)\r\n\t\t;\r\n\r\nasm\tmov\t\tdx,[ssStatus]\t// Check to see if FIFO is currently empty\r\nasm\tin\t\tal,dx\r\nasm\ttest\tal,0x40\r\nasm\tjnz\t\tcheckdone\t\t// Nope - Sound Source not here\r\n\r\nasm\tmov\t\tcx,32\t\t\t// Force FIFO overflow (FIFO is 16 bytes)\r\noutloop:\r\nasm\tmov\t\tdx,[ssData]\t\t// Pump a neutral value out\r\nasm\tmov\t\tal,0x80\r\nasm\tout\t\tdx,al\r\n\r\nasm\tmov\t\tdx,[ssControl]\t// Pulse printer select\r\nasm\tmov\t\tal,[ssOff]\r\nasm\tout\t\tdx,al\r\nasm\tpush\tax\r\nasm\tpop\t\tax\r\nasm\tmov\t\tal,[ssOn]\r\nasm\tout\t\tdx,al\r\n\r\nasm\tpush\tax\t\t\t\t// Delay a short while before we do this again\r\nasm\tpop\t\tax\r\nasm\tpush\tax\r\nasm\tpop\t\tax\r\n\r\nasm\tloop\toutloop\r\n\r\nasm\tmov\t\tdx,[ssStatus]\t// Is FIFO overflowed now?\r\nasm\tin\t\tal,dx\r\nasm\ttest\tal,0x40\r\nasm\tjz\t\tcheckdone\t\t// Nope, still not - Sound Source not here\r\n\r\n\tpresent = true;\t\t\t// Yes - it's here!\r\n\r\ncheckdone:\r\n\tSDL_ShutSS();\r\n\treturn(present);\r\n}\r\n\r\nstatic boolean\r\nSDL_DetectSoundSource(void)\r\n{\r\n\tfor (ssPort = 1;ssPort <= 3;ssPort++)\r\n\t\tif (SDL_CheckSS())\r\n\t\t\treturn(true);\r\n\treturn(false);\r\n}\r\n\r\n// \tAdLib Code\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\talOut(n,b) - Puts b in AdLib card register n\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nalOut(byte n,byte b)\r\n{\r\n\tasm\tpushf\r\n\tasm\tcli\r\n\r\n\tasm\tmov\t\tdx,0x388\r\n\tasm\tmov\t\tal,[n]\r\n\tasm\tout\t\tdx,al\r\n\tSDL_Delay(TimerDelay10);\r\n\r\n\tasm\tmov\t\tdx,0x389\r\n\tasm\tmov\t\tal,[b]\r\n\tasm\tout\t\tdx,al\r\n\r\n\tasm\tpopf\r\n\r\n\tSDL_Delay(TimerDelay25);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SetInstrument() - Puts an instrument into a generator\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SetInstrument(int which,Instrument *inst)\r\n{\r\n\tbyte\t\tc,m;\r\n\r\n\t// DEBUG - what about percussive instruments?\r\n\r\n\tm = modifiers[which];\r\n\tc = carriers[which];\r\n\ttracks[which]->inst = *inst;\r\n\r\n\talOut(m + alChar,inst->mChar);\r\n\talOut(m + alScale,inst->mScale);\r\n\talOut(m + alAttack,inst->mAttack);\r\n\talOut(m + alSus,inst->mSus);\r\n\talOut(m + alWave,inst->mWave);\r\n\r\n\talOut(c + alChar,inst->cChar);\r\n\talOut(c + alScale,inst->cScale);\r\n\talOut(c + alAttack,inst->cAttack);\r\n\talOut(c + alSus,inst->cSus);\r\n\talOut(c + alWave,inst->cWave);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ALStopSound() - Turns off any sound effects playing through the\r\n//\t\tAdLib card\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_ALStopSound(void)\r\n{\r\nasm\tpushf\r\nasm\tcli\r\n\r\n\t(long)alSound = 0;\r\n\talOut(alFreqH + 0,0);\r\n\r\nasm\tpopf\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ALPlaySound() - Plays the specified sound on the AdLib card\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#ifdef\t_MUSE_\r\nvoid\r\n#else\r\nstatic void\r\n#endif\r\nSDL_ALPlaySound(AdLibSound far *sound)\r\n{\r\n\tbyte\t\tc,m;\r\n\tInstrument\tfar *inst;\r\n\r\nasm\tpushf\r\nasm\tcli\r\n\r\n\tSDL_ALStopSound();\r\n\r\n\talLengthLeft = sound->common.length;\r\n\talSound = sound->data;\r\n\talBlock = ((sound->block & 7) << 2) | 0x20;\r\n\tinst = &sound->inst;\r\n\r\n\tif (!(inst->mSus | inst->cSus))\r\n\t\tQuit(\"SDL_ALPlaySound() - Seriously suspicious instrument\");\r\n\r\n\tm = modifiers[0];\r\n\tc = carriers[0];\r\n\talOut(m + alChar,inst->mChar);\r\n\talOut(m + alScale,inst->mScale);\r\n\talOut(m + alAttack,inst->mAttack);\r\n\talOut(m + alSus,inst->mSus);\r\n\talOut(m + alWave,inst->mWave);\r\n\talOut(c + alChar,inst->cChar);\r\n\talOut(c + alScale,inst->cScale);\r\n\talOut(c + alAttack,inst->cAttack);\r\n\talOut(c + alSus,inst->cSus);\r\n\talOut(c + alWave,inst->cWave);\r\n\r\nasm\tpopf\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n// \tSDL_ALSoundService() - Plays the next sample out through the AdLib card\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ALSoundService(void)\r\n{\r\n\tbyte\ts;\r\n\r\n\tif (alSound)\r\n\t{\r\n\t\ts = *alSound++;\r\n\t\tif (!s)\r\n\t\t\talOut(alFreqH + 0,0);\r\n\t\telse\r\n\t\t{\r\n\t\t\talOut(alFreqL + 0,s);\r\n\t\t\talOut(alFreqH + 0,alBlock);\r\n\t\t}\r\n\r\n\t\tif (!(--alLengthLeft))\r\n\t\t{\r\n\t\t\t(long)alSound = 0;\r\n\t\t\talOut(alFreqH + 0,0);\r\n\t\t\tSDL_SoundFinished();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_SelectMeasure() - sets up sequencing variables for a given track\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_SelectMeasure(ActiveTrack *track)\r\n{\r\n\ttrack->seq = track->moods[track->mood];\r\n\ttrack->nextevent = 0;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tMy AdLib interrupt service routine\r\n//\tCalled 140 times/second by SDL_t0Service()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ALService(void)\r\n{\r\n\tboolean\t\tupdate;\r\n\tword\t\t*seq;\r\n\tlongword\tnext;\r\n\tint\t\t\ti;\r\n\tInstrument\t*ins;\r\n\tActiveTrack\t*track;\r\n\r\n\tif (!sqActive)\r\n\t\treturn;\r\n\r\n\tfor (i = 1;i <= sqMaxTracks;i++)\r\n\t{\r\n\t\tif (!((track = tracks[i - 1]) && (seq = track->seq)))\r\n\t\t\tcontinue;\r\n\r\n\t\tif ((sqMode != sqmode_Normal) && (sqFadeStep < sqMaxFade))\r\n\t\t{\r\n\t\t\t// DEBUG - not done\r\n\t\t\tsqFadeStep++;\r\n\t\t}\r\n\r\n\t\tnext = track->nextevent;\r\n\t\twhile (next <= TimeCount)\r\n\t\t{\r\n\t\t\tupdate = true;\r\n\t\t\tswitch (*seq++)\r\n\t\t\t{\r\n\t\t\tcase sev_NoteOff:\r\n\t\t\t\talOut(alFreqH + i,0);\t/* Turn the note off */\r\n\t\t\t\tnext = TimeCount + *seq;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_NoteOn:\r\n\t\t\tcase sev_NotePitch:\r\n\t\t\t\tnext = TimeCount + *seq++;\r\n\t\t\t\talOut(alFreqL + i,*seq);\t\t/* Program low 8 bits of freq */\r\n\t\t\t\talOut(alFreqH + i,(*seq >> 8) | 0x20);\t/* & hi 5 bits and turn note on */\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_NewInst:\r\n\t\t\t\tins = (Instrument *)seq;\r\n\t\t\t\tSDL_SetInstrument(i,ins++);\r\n\t\t\t\tseq = (word *)(ins);\r\n\t\t\t\tnext = TimeCount + *seq;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_NewPerc:\r\n\t\t\t\t// DEBUG - write this\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_PercOn:\r\n\t\t\t\talFXReg |= (1 << *seq);\r\n\t\t\t\talOut(alEffects,alFXReg);\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_PercOff:\r\n\t\t\t\talFXReg &= ~(1 << *seq);\r\n\t\t\t\talOut(alEffects,alFXReg);\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_SeqEnd:\r\n\t\t\t\tSDL_SelectMeasure(track);\r\n\t\t\t\tnext = track->nextevent;\r\n\t\t\t\tif (!(seq = track->seq))\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tupdate = false;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sev_Null:\r\n\t\t\t\tnext = TimeCount + *seq;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (update)\r\n\t\t\t{\r\n\t\t\t\ttrack->seq = ++seq;\r\n\t\t\t\ttrack->nextevent = next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ShutAL() - Shuts down the AdLib card for sound effects\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutAL(void)\r\n{\r\n\tword\ti;\r\n\r\n\talOut(alEffects,0);\r\n\talOut(alFreqH + 0,0);\r\n\t// DEBUG - reprogram with null instrument\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ShutAL() - Starts up the AdLib card for sound effects\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_StartAL(void)\r\n{\r\n\talFXReg = 0;\r\n\talOut(alEffects,alFXReg);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_DetectAdLib() - Determines if there's an AdLib (or SoundBlaster\r\n//\t\temulating an AdLib) present\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nSDL_DetectAdLib(void)\r\n{\r\n\tbyte\tstatus1,status2;\r\n\tint\t\ti;\r\n\r\n\talOut(4,0x60);\t// Reset T1 & T2\r\n\talOut(4,0x80);\t// Reset IRQ\r\n\tstatus1 = readstat();\r\n\talOut(2,0xff);\t// Set timer 1\r\n\talOut(4,0x21);\t// Start timer 1\r\n\tSDL_Delay(TimerDelay100);\r\n\r\n\tstatus2 = readstat();\r\n\talOut(4,0x60);\r\n\talOut(4,0x80);\r\n\r\n\tif (((status1 & 0xe0) == 0x00) && ((status2 & 0xe0) == 0xc0))\r\n\t\treturn(true);\r\n\telse\r\n\t\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_t0Service() - My timer 0 ISR which handles the different timings and\r\n//\t\tdispatches to whatever other routines are appropriate\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void interrupt\r\nSDL_t0Service(void)\r\n{\r\n\tbyte\t\tsdcount;\r\nstatic\tword\tcount = 1,\r\n\t\t\t\talcount = 1,\r\n\t\t\t\tdrivecount = 1;\r\n\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_PC:\r\n\t\tSDL_PCService();\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tSDL_ALSoundService();\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\tSDL_SSService();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif ((MusicMode == smm_AdLib) && !(--alcount))\r\n\t{\r\n\t\talcount = t0CountTable[SoundMode] / 2;\r\n\t\tSDL_ALService();\r\n\t}\r\n\r\n\tif (!(--count))\r\n\t{\r\n\t\tcount = t0CountTable[SoundMode];\r\n\t\tLocalTime++;\r\n\t\tTimeCount++;\r\n\t\tif (SoundUserHook)\r\n\t\t\tSoundUserHook();\r\n\r\n\t\t// If one of the drives is on, and we're not told to leave it on...\r\n\t\tif ((peekb(0x40,0x3f) & 3) && !LeaveDriveOn)\r\n\t\t{\r\n\t\t\tif (!(--drivecount))\r\n\t\t\t{\r\n\t\t\t\tdrivecount = 5;\r\n\r\n\t\t\t\tsdcount = peekb(0x40,0x40);\t// Get system drive count\r\n\t\t\t\tif (sdcount < 2)\t\t\t// Time to turn it off\r\n\t\t\t\t{\r\n\t\t\t\t\t// Wait until it's off\r\n\t\t\t\t\twhile ((peekb(0x40,0x3f) & 3))\r\n\t\t\t\t\t{\r\n\t\t\t\t\tasm\tpushf\r\n\t\t\t\t\t\tt0OldService();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\t// Not time yet, just decrement counter\r\n\t\t\t\t\tpokeb(0x40,0x40,--sdcount);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\toutportb(0x20,0x20);\t// Ack the interrupt\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_ShutDevice() - turns off whatever device was being used for sound fx\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_ShutDevice(void)\r\n{\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_PC:\r\n\t\tSDL_ShutPC();\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tSDL_ShutAL();\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\t\tSDL_ShutSB();\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\tSDL_ShutSS();\r\n\t\tbreak;\r\n\t}\r\n\tSoundMode = sdm_Off;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSDL_StartDevice() - turns on whatever device is to be used for sound fx\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nSDL_StartDevice(void)\r\n{\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_AdLib:\r\n\t\tSDL_StartAL();\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\t\tSDL_StartSB();\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\tSDL_StartSS();\r\n\t\tbreak;\r\n\t}\r\n\tSoundNumber = SoundPriority = 0;\r\n}\r\n\r\n//\tPublic routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_SetSoundMode() - Sets which sound hardware to use for sound effects\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_SetSoundMode(SDMode mode)\r\n{\r\n\tboolean\tresult;\r\n\tword\trate,speed,\r\n\t\t\ttableoffset;\r\n\r\n\tSD_StopSound();\r\n\r\n\tswitch (mode)\r\n\t{\r\n\tcase sdm_Off:\r\n\t\tNeedsDigitized = false;\r\n\t\tresult = true;\r\n\t\tbreak;\r\n\tcase sdm_PC:\r\n\t\ttableoffset = STARTPCSOUNDS;\r\n\t\tNeedsDigitized = false;\r\n\t\tresult = true;\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tif (AdLibPresent)\r\n\t\t{\r\n\t\t\ttableoffset = STARTADLIBSOUNDS;\r\n\t\t\tNeedsDigitized = false;\r\n\t\t\tresult = true;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\t\tif (SoundBlasterPresent)\r\n\t\t{\r\n\t\t\ttableoffset = STARTDIGISOUNDS;\r\n\t\t\tNeedsDigitized = true;\r\n\t\t\tresult = true;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\ttableoffset = STARTDIGISOUNDS;\r\n\t\tNeedsDigitized = true;\r\n\t\tresult = true;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tresult = false;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (result && (mode != SoundMode))\r\n\t{\r\n\t\tSDL_ShutDevice();\r\n\t\tSoundMode = mode;\r\n#ifndef\t_MUSE_\r\n\t\tSoundTable = (word *)(&audiosegs[tableoffset]);\r\n#endif\r\n\t\tSDL_StartDevice();\r\n\t}\r\n\r\n\trate = TickBase * t0CountTable[SoundMode];\r\n\tSDL_SetIntsPerSec(rate);\r\n\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_SetMusicMode() - sets the device to use for background music\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_SetMusicMode(SMMode mode)\r\n{\r\n\tboolean\tresult;\r\n\r\n\tSD_FadeOutMusic();\r\n\twhile (SD_MusicPlaying())\r\n\t\t;\r\n\r\n\tswitch (mode)\r\n\t{\r\n\tcase smm_Off:\r\n\t\tNeedsMusic = false;\r\n\t\tresult = true;\r\n\t\tbreak;\r\n\tcase smm_AdLib:\r\n\t\tif (AdLibPresent)\r\n\t\t{\r\n\t\t\tNeedsMusic = true;\r\n\t\t\tresult = true;\r\n\t\t}\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tresult = false;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (result)\r\n\t\tMusicMode = mode;\r\n\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_Startup() - starts up the Sound Mgr\r\n//\t\tDetects all additional sound hardware and installs my ISR\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_Startup(void)\r\n{\r\n\tint\ti;\r\n\r\n\tif (SD_Started)\r\n\t\treturn;\r\n\r\n\tssNoCheck = false;\r\n\tssIsTandy = false;\r\n\talNoCheck = false;\r\n\tsbNoCheck = false;\r\n\tLeaveDriveOn = false;\r\n#ifndef\t_MUSE_\r\n\tfor (i = 1;i < _argc;i++)\r\n\t{\r\n\t\tswitch (US_CheckParm(_argv[i],ParmStrings))\r\n\t\t{\r\n\t\tcase 0:\t\t\t\t\t\t// No AdLib detection\r\n\t\t\talNoCheck = true;\r\n\t\t\tbreak;\r\n\t\tcase 1:\t\t\t\t\t\t// No SoundBlaster detection\r\n\t\t\tsbNoCheck = true;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tLeaveDriveOn = true;\t// No drive turnoff\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tssNoCheck = true;\t\t// No Sound Source detection\r\n\t\t\tbreak;\r\n\t\tcase 4:\t\t\t\t\t\t// Tandy Sound Source handling\r\n\t\t\tssIsTandy = true;\r\n\t\t\tbreak;\r\n\t\tcase 5:\t\t\t\t\t\t// Sound Source present at LPT1\r\n\t\t\tssPort = 1;\r\n\t\t\tssNoCheck = SoundSourcePresent = true;\r\n\t\t\tbreak;\r\n\t\tcase 6:                     // Sound Source present at LPT2\r\n\t\t\tssPort = 2;\r\n\t\t\tssNoCheck = SoundSourcePresent = true;\r\n\t\t\tbreak;\r\n\t\tcase 7:                     // Sound Source present at LPT3\r\n\t\t\tssPort = 3;\r\n\t\t\tssNoCheck = SoundSourcePresent = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\tSoundUserHook = 0;\r\n\r\n\tt0OldService = getvect(8);\t// Get old timer 0 ISR\r\n\r\n\tSDL_InitDelay();\t\t\t// SDL_InitDelay() uses t0OldService\r\n\r\n\tsetvect(8,SDL_t0Service);\t// Set to my timer 0 ISR\r\n\tLocalTime = TimeCount = 0;\r\n\r\n\tSD_SetSoundMode(sdm_Off);\r\n\tSD_SetMusicMode(smm_Off);\r\n\r\n\tif (!ssNoCheck)\r\n\t\tSoundSourcePresent = SDL_DetectSoundSource();\r\n\r\n\tif (!alNoCheck)\r\n\t{\r\n\t\tAdLibPresent = SDL_DetectAdLib();\r\n\t\tif (AdLibPresent && !sbNoCheck)\r\n\t\t\tSoundBlasterPresent = SDL_DetectSoundBlaster(-1);\r\n\t}\r\n\r\n\tfor (i = 0;i < 255;i++)\r\n\t\tpcSoundLookup[i] = i * 60;\r\n\r\n\tSD_Started = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_Default() - Sets up the default behaviour for the Sound Mgr whether\r\n//\t\tthe config file was present or not.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_Default(boolean gotit,SDMode sd,SMMode sm)\r\n{\r\n\tboolean\tgotsd,gotsm;\r\n\r\n\tgotsd = gotsm = gotit;\r\n\r\n\tif (gotsd)\t// Make sure requested sound hardware is available\r\n\t{\r\n\t\tswitch (sd)\r\n\t\t{\r\n\t\tcase sdm_AdLib:\r\n\t\t\tgotsd = AdLibPresent;\r\n\t\t\tbreak;\r\n\t\tcase sdm_SoundBlaster:\r\n\t\t\tgotsd = SoundBlasterPresent;\r\n\t\t\tbreak;\r\n\t\tcase sdm_SoundSource:\r\n\t\t\tgotsd = SoundSourcePresent;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (!gotsd)\r\n\t{\r\n#if 0\t// DEBUG - hack for Keen Dreams because of no space...\r\n\t\t// Use the best sound hardware available\r\n\t\tif (SoundBlasterPresent)\r\n\t\t\tsd = sdm_SoundBlaster;\r\n\t\telse if (SoundSourcePresent)\r\n\t\t\tsd = sdm_SoundSource;\r\n\t\telse if (AdLibPresent)\r\n\t\t\tsd = sdm_AdLib;\r\n\t\telse\r\n\t\t\tsd = sdm_PC;\r\n#else\r\n\t\tif (AdLibPresent)\r\n\t\t\tsd = sdm_AdLib;\r\n\t\telse\r\n\t\t\tsd = sdm_PC;\r\n#endif\r\n\t}\r\n\tif (sd != SoundMode)\r\n\t\tSD_SetSoundMode(sd);\r\n\r\n\r\n\tif (gotsm)\t// Make sure requested music hardware is available\r\n\t{\r\n\t\tswitch (sm)\r\n\t\t{\r\n\t\tcase sdm_AdLib:\r\n\t\t\tgotsm = AdLibPresent;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (!gotsm)\r\n\t{\r\n#if 0\t// DEBUG - hack for Keen Dreams because of no space...\r\n\t\tif (AdLibPresent)\r\n\t\t\tsm = smm_AdLib;\r\n#endif\r\n\t}\r\n\tif (sm != MusicMode)\r\n\t\tSD_SetMusicMode(sm);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_Shutdown() - shuts down the Sound Mgr\r\n//\t\tRemoves sound ISR and turns off whatever sound hardware was active\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_Shutdown(void)\r\n{\r\n\tif (!SD_Started)\r\n\t\treturn;\r\n\r\n\tSDL_ShutDevice();\r\n\r\n\tasm\tpushf\r\n\tasm\tcli\r\n\r\n\tSDL_SetTimer0(0);\r\n\r\n\tsetvect(8,t0OldService);\r\n\r\n\tasm\tpopf\r\n\t// DEBUG - set the system clock\r\n\r\n\tSD_Started = false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_SetUserHook() - sets the routine that the Sound Mgr calls every 1/70th\r\n//\t\tof a second from its timer 0 ISR\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_SetUserHook(void (* hook)(void))\r\n{\r\n\tSoundUserHook = hook;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_PlaySound() - plays the specified sound on the appropriate hardware\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_PlaySound(word sound)\r\n{\r\n\tSoundCommon\tfar *s;\r\n\r\n\tif (SoundMode == sdm_Off)\r\n\t\treturn;\r\n\r\n\ts = MK_FP(SoundTable[sound],0);\r\n\tif (!s)\r\n\t\tQuit(\"SD_PlaySound() - Attempted to play an uncached sound\");\r\n\tif (s->priority < SoundPriority)\r\n\t\treturn;\r\n\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_PC:\r\n\t\tSDL_PCPlaySound((void far *)s);\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tSDL_ALPlaySound((void far *)s);\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\t\tSDL_SBPlaySample((void far *)s);\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\tSDL_SSPlaySample((void far *)s);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tSoundNumber = sound;\r\n\tSoundPriority = s->priority;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_SoundPlaying() - returns the sound number that's playing, or 0 if\r\n//\t\tno sound is playing\r\n///////////////////////////////////////////////////////////////////////////\r\nword\r\nSD_SoundPlaying(void)\r\n{\r\n\tboolean\tresult = false;\r\n\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_PC:\r\n\t\tresult = pcSound? true : false;\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tresult = alSound? true : false;\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\t\tresult = sbSamplePlaying;\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\tresult = ssSample? true : false;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (result)\r\n\t\treturn(SoundNumber);\r\n\telse\r\n\t\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_StopSound() - if a sound is playing, stops it\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_StopSound(void)\r\n{\r\n\tswitch (SoundMode)\r\n\t{\r\n\tcase sdm_PC:\r\n\t\tSDL_PCStopSound();\r\n\t\tbreak;\r\n\tcase sdm_AdLib:\r\n\t\tSDL_ALStopSound();\r\n\t\tbreak;\r\n\tcase sdm_SoundBlaster:\r\n\t\tSDL_SBStopSample();\r\n\t\tbreak;\r\n\tcase sdm_SoundSource:\r\n\t\tSDL_SSStopSample();\r\n\t\tbreak;\r\n\t}\r\n\r\n\tSDL_SoundFinished();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_WaitSoundDone() - waits until the current sound is done playing\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_WaitSoundDone(void)\r\n{\r\n\twhile (SD_SoundPlaying())\r\n\t\t;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_StartMusic() - starts playing the music pointed to\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_StartMusic(Ptr music)\t// DEBUG - this shouldn't be a Ptr...\r\n{\r\n\tswitch (MusicMode)\r\n\t{\r\n\tcase smm_AdLib:\r\n\t\tmusic = music;\r\n\t\t// DEBUG - not written\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_FadeOutMusic() - starts fading out the music. Call SD_MusicPlaying()\r\n//\t\tto see if the fadeout is complete\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nSD_FadeOutMusic(void)\r\n{\r\n\tswitch (MusicMode)\r\n\t{\r\n\tcase smm_AdLib:\r\n\t\t// DEBUG - not written\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tSD_MusicPlaying() - returns true if music is currently playing, false if\r\n//\t\tnot\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nSD_MusicPlaying(void)\r\n{\r\n\tboolean\tresult;\r\n\r\n\tswitch (MusicMode)\r\n\t{\r\n\tcase smm_AdLib:\r\n\t\tresult = false;\r\n\t\t// DEBUG - not written\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tresult = false;\r\n\t}\r\n\r\n\treturn(result);\r\n}\r\n"
        },
        {
          "name": "id_sd.h",
          "type": "blob",
          "size": 4.6435546875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n//\tID Engine\r\n//\tID_SD.h - Sound Manager Header\r\n//\tv1.0d1\r\n//\tBy Jason Blochowiak\r\n//\r\n\r\n#ifndef\t__TYPES__\r\n#include \"ID_Types.h\"\r\n#endif\r\n\r\n#ifndef\t__ID_SD__\r\n#define\t__ID_SD__\r\n\r\n#ifdef\t__DEBUG__\r\n#define\t__DEBUG_SoundMgr__\r\n#endif\r\n\r\n#define\tTickBase\t70\t\t// 70Hz per tick - used as a base for timer 0\r\n\r\ntypedef\tenum\t{\r\n\t\t\t\t\tsdm_Off,\r\n\t\t\t\t\tsdm_PC,sdm_AdLib,\r\n\t\t\t\t\tsdm_SoundBlaster,sdm_SoundSource\r\n\t\t\t\t}\tSDMode;\r\ntypedef\tenum\t{\r\n\t\t\t\t\tsmm_Off,smm_AdLib\r\n\t\t\t\t}\tSMMode;\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tlongword\tlength;\r\n\t\t\tword\t\tpriority;\r\n\t\t} SoundCommon;\r\n\r\n//\tPC Sound stuff\r\n#define\tpcTimer\t\t0x42\r\n#define\tpcTAccess\t0x43\r\n#define\tpcSpeaker\t0x61\r\n\r\n#define\tpcSpkBits\t3\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tSoundCommon\tcommon;\r\n\t\t\tbyte\t\tdata[1];\r\n\t\t} PCSound;\r\n\r\n// \tRegisters for the Sound Blaster card - needs to be offset by n0\r\n#define\tsbReset\t\t0x206\r\n#define\tsbReadData\t0x20a\r\n#define\tsbWriteCmd\t0x20c\r\n#define\tsbWriteData\t0x20c\r\n#define\tsbWriteStat\t0x20c\r\n#define\tsbDataAvail\t0x20e\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tSoundCommon\tcommon;\r\n\t\t\tword\t\thertz;\r\n\t\t\tbyte\t\tbits,\r\n\t\t\t\t\t\treference,\r\n\t\t\t\t\t\tdata[1];\r\n\t\t} SampledSound;\r\n\r\n// \tRegisters for the AdLib card\r\n// Operator stuff\r\n#define\talChar\t\t0x20\r\n#define\talScale\t\t0x40\r\n#define\talAttack\t0x60\r\n#define\talSus\t\t0x80\r\n#define\talWave\t\t0xe0\r\n// Channel stuff\r\n#define\talFreqL\t\t0xa0\r\n#define\talFreqH\t\t0xb0\r\n#define\talFeedCon\t0xc0\r\n// Global stuff\r\n#define\talEffects\t0xbd\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tbyte\tmChar,cChar,\r\n\t\t\t\t\tmScale,cScale,\r\n\t\t\t\t\tmAttack,cAttack,\r\n\t\t\t\t\tmSus,cSus,\r\n\t\t\t\t\tmWave,cWave,\r\n\t\t\t\t\tnConn,\r\n\t\t\t\t\tunused[5];\r\n\t\t} Instrument;\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tSoundCommon\tcommon;\r\n\t\t\tInstrument\tinst;\r\n\t\t\tbyte\t\tblock,\r\n\t\t\t\t\t\tdata[1];\r\n\t\t} AdLibSound;\r\n\r\n//\r\n//\tSequencing stuff\r\n//\r\n#define\tsqMaxTracks\t10\r\n#define\tsqMaxMoods\t1\t// DEBUG\r\n\r\n#define\tsev_Null\t\t0\t// Does nothing\r\n#define\tsev_NoteOff\t\t1\t// Turns a note off\r\n#define\tsev_NoteOn\t\t2\t// Turns a note on\r\n#define\tsev_NotePitch\t3\t// Sets the pitch of a currently playing note\r\n#define\tsev_NewInst\t\t4\t// Installs a new instrument\r\n#define\tsev_NewPerc\t\t5\t// Installs a new percussive instrument\r\n#define\tsev_PercOn\t\t6\t// Turns a percussive note on\r\n#define\tsev_PercOff\t\t7\t// Turns a percussive note off\r\n#define\tsev_SeqEnd\t\t-1\t// Terminates a sequence\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tword\tflags,\r\n\t\t\t\t\tcount,\r\n\t\t\t\t\toffsets[1];\r\n\t\t} MusicGroup;\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\t/* This part needs to be set up by the user */\r\n\t\t\tword        mood,*moods[sqMaxMoods];\r\n\r\n\t\t\t/* The rest is set up by the code */\r\n\t\t\tInstrument\tinst;\r\n\t\t\tword\t\t*seq;\r\n\t\t\tlongword\tnextevent;\r\n\t\t} ActiveTrack;\r\n\r\n#define\tsqmode_Normal\t\t0\r\n#define\tsqmode_FadeIn\t\t1\r\n#define\tsqmode_FadeOut\t\t2\r\n\r\n#define\tsqMaxFade\t\t64\t// DEBUG\r\n\r\n\r\n// Global variables\r\nextern\tboolean\t\tLeaveDriveOn;\r\nextern\tboolean\t\tSoundSourcePresent,SoundBlasterPresent,AdLibPresent,\r\n\t\t\t\t\tNeedsDigitized,NeedsMusic;\t// For Caching Mgr\r\nextern\tSDMode\t\tSoundMode;\r\nextern\tSMMode\t\tMusicMode;\r\nextern\tlongword\tTimeCount;\t\t\t\t\t// Global time in ticks\r\n\r\nextern\tboolean\t\tssIsTandy;\t\t\t\t\t// For config file\r\nextern\tword\t\tssPort;\r\n\r\n// Function prototypes\r\nextern\tvoid\tSD_Startup(void),\r\n\t\t\t\tSD_Shutdown(void),\r\n\t\t\t\tSD_Default(boolean gotit,SDMode sd,SMMode sm),\r\n\t\t\t\tSD_PlaySound(word sound),\r\n\t\t\t\tSD_StopSound(void),\r\n\t\t\t\tSD_WaitSoundDone(void),\r\n\t\t\t\tSD_StartMusic(Ptr music),\t// DEBUG - this shouldn't be a Ptr\r\n\t\t\t\tSD_FadeOutMusic(void),\r\n\t\t\t\tSD_SetUserHook(void (*hook)(void));\r\nextern\tboolean\tSD_MusicPlaying(void),\r\n\t\t\t\tSD_SetSoundMode(SDMode mode),\r\n\t\t\t\tSD_SetMusicMode(SMMode mode);\r\nextern\tword\tSD_SoundPlaying(void);\r\n\r\n#ifdef\t_MUSE_\t// MUSE Goes directly to the lower level routines\r\nextern\tvoid\tSDL_PCPlaySound(PCSound far *sound),\r\n\t\t\t\tSDL_PCStopSound(void),\r\n\t\t\t\tSDL_ALPlaySound(AdLibSound far *sound),\r\n\t\t\t\tSDL_ALStopSound(void),\r\n\t\t\t\tSDL_SBPlaySample(SampledSound far *sample),\r\n\t\t\t\tSDL_SBStopSample(void),\r\n\t\t\t\tSDL_SSPlaySample(SampledSound far *sample),\r\n\t\t\t\tSDL_SSStopSample(void);\r\n#endif\r\n\r\n#endif\r\n"
        },
        {
          "name": "id_us.c",
          "type": "blob",
          "size": 86.4248046875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n//\tID Engine\r\n//\tID_US.c - User Manager\r\n//\tv1.0d1\r\n//\tBy Jason Blochowiak\r\n//\r\n\r\n//\r\n//\tThis module handles dealing with user input & feedback\r\n//\r\n//\tDepends on: Input Mgr, View Mgr, some variables from the Sound, Caching,\r\n//\t\tand Refresh Mgrs, Memory Mgr for background save/restore\r\n//\r\n//\tGlobals:\r\n//\t\tingame - Flag set by game indicating if a game is in progress\r\n//      abortgame - Flag set if the current game should be aborted (if a load\r\n//\t\t\tgame fails)\r\n//\t\tloadedgame - Flag set if a game was loaded\r\n//\t\tabortprogram - Normally nil, this points to a terminal error message\r\n//\t\t\tif the program needs to abort\r\n//\t\trestartgame - Normally set to gd_Continue, this is set to one of the\r\n//\t\t\tdifficulty levels if a new game should be started\r\n//\t\tPrintX, PrintY - Where the User Mgr will print (global coords)\r\n//\t\tWindowX,WindowY,WindowW,WindowH - The dimensions of the current\r\n//\t\t\twindow\r\n//\r\n\r\n// DEBUG - handle LPT3 for Sound Source\r\n\r\n#include \"ID_HEADS.H\"\r\n\r\n#define CTL_M_ADLIBUPPIC\tCTL_S_ADLIBUPPIC\r\n#define CTL_M_ADLIBDNPIC\tCTL_S_ADLIBDNPIC\r\n\r\n#pragma\thdrstop\r\n\r\n#pragma\twarn\t-pia\r\n\r\n#define\tMaxX\t320\r\n#define\tMaxY\t200\r\n\r\n#define\tMaxHelpLines\t500\r\n\r\n#define\tMaxHighName\t57\r\n#define\tMaxScores\t10\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tchar\tname[MaxHighName + 1];\r\n\t\t\tlong\tscore;\r\n\t\t\tword\tcompleted;\r\n\t\t} HighScore;\r\n\r\n#define\tMaxGameName\t\t32\r\n#define\tMaxSaveGames\t7\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tchar\tsignature[4];\r\n\t\t\tboolean\tpresent;\r\n\t\t\tchar\tname[MaxGameName + 1];\r\n\t\t} SaveGame;\r\n\r\n//\tHack import for TED launch support\r\nextern\tboolean\t\ttedlevel;\r\nextern\tword\t\ttedlevelnum;\r\nextern\tvoid\t\tTEDDeath(void);\r\nstatic\tchar\t\t*ParmStrings[] = {\"TEDLEVEL\",\"\"};\r\n\r\n\r\n//\tGlobal variables\r\n\t\tboolean\t\tingame,abortgame,loadedgame;\r\n\t\tchar\t\t*abortprogram;\r\n\t\tGameDiff\trestartgame = gd_Continue;\r\n\t\tword\t\tPrintX,PrintY;\r\n\t\tword\t\tWindowX,WindowY,WindowW,WindowH;\r\n\r\n//\tInternal variables\r\nstatic\tboolean\t\tUS_Started;\r\nstatic\tboolean\t\tGameIsDirty,\r\n\t\t\t\t\tHighScoresDirty,\r\n\t\t\t\t\tQuitToDos,\r\n\t\t\t\t\tResumeGame;\r\n\r\nstatic\tmemptr\t\tLineOffsets;\r\n\r\nstatic\tboolean\t\tButton0,Button1,\r\n\t\t\t\t\tCursorBad;\r\nstatic\tint\t\t\tCursorX,CursorY;\r\n\r\nstatic\tvoid\t\t(*USL_MeasureString)(char far *,word *,word *) = VW_MeasurePropString,\r\n\t\t\t\t\t(*USL_DrawString)(char far *) = VWB_DrawPropString;\r\n\r\nstatic\tboolean\t\t(*USL_SaveGame)(int),(*USL_LoadGame)(int);\r\nstatic\tvoid\t\t(*USL_ResetGame)(void);\r\nstatic\tSaveGame\tGames[MaxSaveGames];\r\nstatic\tHighScore\tScores[MaxScores] =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000},\r\n\t\t\t\t\t\t{\"\",10000}\r\n\t\t\t\t\t};\r\n\r\n//\tInternal routines\r\n\r\n//\tPublic routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_HardError() - Handles the Abort/Retry/Fail sort of errors passed\r\n//\t\t\tfrom DOS.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n#pragma\twarn\t-par\r\n#pragma\twarn\t-rch\r\nint\r\nUSL_HardError(word errval,int ax,int bp,int si)\r\n{\r\n#define IGNORE  0\r\n#define RETRY   1\r\n#define\tABORT   2\r\nextern\tvoid\tShutdownId(void);\r\n\r\nstatic\tchar\t\tbuf[32];\r\nstatic\tWindowRec\twr;\r\nstatic\tboolean\t\toldleavedriveon;\r\n\t\tint\t\t\tdi;\r\n\t\tchar\t\tc,*s,*t;\r\n\r\n\r\n\tdi = _DI;\r\n\r\n\toldleavedriveon = LeaveDriveOn;\r\n\tLeaveDriveOn = false;\r\n\r\n\tif (ax < 0)\r\n\t\ts = \"Device Error\";\r\n\telse\r\n\t{\r\n\t\tif ((di & 0x00ff) == 0)\r\n\t\t\ts = \"Drive ~ is Write Protected\";\r\n\t\telse\r\n\t\t\ts = \"Error on Drive ~\";\r\n\t\tfor (t = buf;*s;s++,t++)\t// Can't use sprintf()\r\n\t\t\tif ((*t = *s) == '~')\r\n\t\t\t\t*t = (ax & 0x00ff) + 'A';\r\n\t\t*t = '\\0';\r\n\t\ts = buf;\r\n\t}\r\n\r\n\tc = peekb(0x40,0x49);\t// Get the current screen mode\r\n\tif ((c < 4) || (c == 7))\r\n\t\tgoto oh_kill_me;\r\n\r\n\t// DEBUG - handle screen cleanup\r\n\r\n\tUS_SaveWindow(&wr);\r\n\tUS_CenterWindow(30,3);\r\n\tUS_CPrint(s);\r\n\tUS_CPrint(\"(R)etry or (A)bort?\");\r\n\tVW_UpdateScreen();\r\n\tIN_ClearKeysDown();\r\n\r\nasm\tsti\t// Let the keyboard interrupts come through\r\n\r\n\twhile (true)\r\n\t{\r\n\t\tswitch (IN_WaitForASCII())\r\n\t\t{\r\n\t\tcase key_Escape:\r\n\t\tcase 'a':\r\n\t\tcase 'A':\r\n\t\t\tgoto oh_kill_me;\r\n\t\t\tbreak;\r\n\t\tcase key_Return:\r\n\t\tcase key_Space:\r\n\t\tcase 'r':\r\n\t\tcase 'R':\r\n\t\t\tUS_ClearWindow();\r\n\t\t\tVW_UpdateScreen();\r\n\t\t\tUS_RestoreWindow(&wr);\r\n\t\t\tLeaveDriveOn = oldleavedriveon;\r\n\t\t\treturn(RETRY);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\noh_kill_me:\r\n\tabortprogram = s;\r\n\tShutdownId();\r\n\tfprintf(stderr,\"Terminal Error: %s\\n\",s);\r\n\tif (tedlevel)\r\n\t\tfprintf(stderr,\"You launched from TED. I suggest that you reboot...\\n\");\r\n\r\n\treturn(ABORT);\r\n#undef\tIGNORE\r\n#undef\tRETRY\r\n#undef\tABORT\r\n}\r\n#pragma\twarn\t+par\r\n#pragma\twarn\t+rch\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_GiveSaveName() - Returns a pointer to a static buffer that contains\r\n//\t\tthe filename to use for the specified save game\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic char *\r\nUSL_GiveSaveName(word game)\r\n{\r\nstatic\tchar\tfilename[32];\r\n\t\tchar\t*s,*t;\r\n\r\n\tfor (s = \"SAVEGM\",t = filename;*s;)\r\n\t\t*t++ = *s++;\r\n\t*t++ = game + '0';\r\n\tfor (s = \".\"EXTENSION;*s;)\r\n\t\t*t++ = *s++;\r\n\t*t = '\\0';\r\n\r\n\treturn(filename);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_SetLoadSaveHooks() - Sets the routines that the User Mgr calls after\r\n//\t\treading or writing the save game headers\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_SetLoadSaveHooks(boolean (*load)(int),boolean (*save)(int),void (*reset)(void))\r\n{\r\n\tUSL_LoadGame = load;\r\n\tUSL_SaveGame = save;\r\n\tUSL_ResetGame = reset;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_ReadConfig() - Reads the configuration file, if present, and sets\r\n//\t\tthings up accordingly. If it's not present, uses defaults. This file\r\n//\t\tincludes the high scores.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_ReadConfig(void)\r\n{\r\n\tboolean\t\tgotit;\r\n\tint\t\t\tfile;\r\n\tSDMode\t\tsd;\r\n\tSMMode\t\tsm;\r\n\tControlType\tctl;\r\n\r\n\tif ((file = open(\"KDREAMS.CFG\",O_BINARY | O_RDONLY)) != -1)\r\n\t{\r\n\t\tread(file,Scores,sizeof(HighScore) * MaxScores);\r\n\t\tread(file,&sd,sizeof(sd));\r\n\t\tread(file,&sm,sizeof(sm));\r\n\t\tread(file,&ctl,sizeof(ctl));\r\n\t\tread(file,&(KbdDefs[0]),sizeof(KbdDefs[0]));\r\n\t\tclose(file);\r\n\r\n\t\tHighScoresDirty = false;\r\n\t\tgotit = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsd = sdm_Off;\r\n\t\tsm = smm_Off;\r\n\t\tctl = ctrl_Keyboard;\r\n\r\n\t\tgotit = false;\r\n\t\tHighScoresDirty = true;\r\n\t}\r\n\r\n\tSD_Default(gotit,sd,sm);\r\n\tIN_Default(gotit,ctl);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_WriteConfig() - Writes out the current configuration, including the\r\n//\t\thigh scores.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_WriteConfig(void)\r\n{\r\n\tint\tfile;\r\n\r\n\tfile = open(\"KDREAMS.CFG\", O_CREAT | O_BINARY | O_WRONLY,\r\n\t\t\t\tS_IREAD | S_IWRITE | S_IFREG);\r\n\tif (file != -1)\r\n\t{\r\n\t\twrite(file,Scores,sizeof(HighScore) * MaxScores);\r\n\t\twrite(file,&SoundMode,sizeof(SoundMode));\r\n\t\twrite(file,&MusicMode,sizeof(MusicMode));\r\n\t\twrite(file,&(Controls[0]),sizeof(Controls[0]));\r\n\t\twrite(file,&(KbdDefs[0]),sizeof(KbdDefs[0]));\r\n\t\tclose(file);\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CheckSavedGames() - Checks to see which saved games are present\r\n//\t\t& valid\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_CheckSavedGames(void)\r\n{\r\n\tboolean\t\tok;\r\n\tchar\t\t*filename;\r\n\tword\t\ti;\r\n\tint\t\t\tfile;\r\n\tSaveGame\t*game;\r\n\r\n\tUSL_SaveGame = 0;\r\n\tUSL_LoadGame = 0;\r\n\r\n\tfor (i = 0,game = Games;i < MaxSaveGames;i++,game++)\r\n\t{\r\n\t\tfilename = USL_GiveSaveName(i);\r\n\t\tok = false;\r\n\t\tif ((file = open(filename,O_BINARY | O_RDONLY)) != -1)\r\n\t\t{\r\n\t\t\tif\r\n\t\t\t(\r\n\t\t\t\t(read(file,game,sizeof(*game)) == sizeof(*game))\r\n\t\t\t&&\t(!strcmp(game->signature,EXTENSION))\r\n\t\t\t)\r\n\t\t\t\tok = true;\r\n\r\n\t\t\tclose(file);\r\n\t\t}\r\n\r\n\t\tif (ok)\r\n\t\t\tgame->present = true;\r\n\t\telse\r\n\t\t{\r\n\t\t\tstrcpy(game->signature,EXTENSION);\r\n\t\t\tgame->present = false;\r\n\t\t\tstrcpy(game->name,\"Empty\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_Startup() - Starts the User Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_Startup(void)\r\n{\r\n\tif (US_Started)\r\n\t\treturn;\r\n\r\n\tharderr(USL_HardError);\t// Install the fatal error handler\r\n\r\n\tUS_InitRndT(true);\t\t// Initialize the random number generator\r\n\r\n\tUSL_ReadConfig();\t\t// Read config file\r\n\r\n\tUS_Started = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_Setup() - Does the disk access part of the User Mgr's startup\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_Setup(void)\r\n{\r\n\tUSL_CheckSavedGames();\t// Check which saved games are present\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_Shutdown() - Shuts down the User Mgr\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_Shutdown(void)\r\n{\r\n\tif (!US_Started)\r\n\t\treturn;\r\n\r\n\tif (!abortprogram)\r\n\t\tUSL_WriteConfig();\r\n\r\n\tUS_Started = false;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_CheckParm() - checks to see if a string matches one of a set of\r\n//\t\tstrings. The check is case insensitive. The routine returns the\r\n//\t\tindex of the string that matched, or -1 if no matches were found\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nint\r\nUS_CheckParm(char *parm,char **strings)\r\n{\r\n\tchar\tcp,cs,\r\n\t\t\t*p,*s;\r\n\tint\t\ti;\r\n\r\n\twhile (!isalpha(*parm))\t// Skip non-alphas\r\n\t\tparm++;\r\n\r\n\tfor (i = 0;*strings && **strings;i++)\r\n\t{\r\n\t\tfor (s = *strings++,p = parm,cs = cp = 0;cs == cp;)\r\n\t\t{\r\n\t\t\tcs = *s++;\r\n\t\t\tif (!cs)\r\n\t\t\t\treturn(i);\r\n\t\t\tcp = *p++;\r\n\r\n\t\t\tif (isupper(cs))\r\n\t\t\t\tcs = tolower(cs);\r\n\t\t\tif (isupper(cp))\r\n\t\t\t\tcp = tolower(cp);\r\n\t\t}\r\n\t}\r\n\treturn(-1);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_ScreenDraw() - Draws a chunk of the text screen (called only by\r\n//\t\tUS_TextScreen())\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_ScreenDraw(word x,word y,char *s,byte attr)\r\n{\r\n\tbyte\tfar *screen;\r\n\r\n\tscreen = MK_FP(0xb800,(x * 2) + (y * 80 * 2));\r\n\twhile (*s)\r\n\t{\r\n\t\t*screen++ = *s++;\r\n\t\t*screen++ = attr;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_ClearTextScreen() - Makes sure the screen is in text mode, clears it,\r\n//\t\tand moves the cursor to the leftmost column of the bottom line\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_ClearTextScreen(void)\r\n{\r\n\t// Set to 80x25 color text mode\r\n\t_AL = 3;\t\t\t\t// Mode 3\r\n\t_AH = 0x00;\r\n\tgeninterrupt(0x10);\r\n\r\n\t// Use BIOS to move the cursor to the bottom of the screen\r\n\t_AH = 0x0f;\r\n\tgeninterrupt(0x10);\t\t// Get current video mode into _BH\r\n\t_DL = 0;\t\t\t\t// Lefthand side of the screen\r\n\t_DH = 24;\t\t\t\t// Bottom row\r\n\t_AH = 0x02;\r\n\tgeninterrupt(0x10);\r\n\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_TextScreen() - Puts up the startup text screen\r\n//\tNote: These are the only User Manager functions that can be safely called\r\n//\t\tbefore the User Mgr has been started up\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_TextScreen(void)\r\n{\r\n\tword\ti,\r\n\t\t\tsx,sy;\r\n\r\n\tUSL_ClearTextScreen();\r\n\r\n#define\tscr_rowcol(y,x)\t{sx = (x) - 1;sy = (y) - 1;}\r\n#define\tscr_aputs(s,a)\tUSL_ScreenDraw(sx,sy,(s),(a))\r\n#include \"ID_US_S.c\"\r\n#undef\tscr_rowcol\r\n#undef\tscr_aputs\r\n\r\n\t// Check for TED launching here\r\n\tfor (i = 1;i < _argc;i++)\r\n\t{\r\n\t\tif (US_CheckParm(_argv[i],ParmStrings) == 0)\r\n\t\t{\r\n\t\t\ttedlevelnum = atoi(_argv[i + 1]);\r\n\t\t\tif (tedlevelnum >= 0)\r\n\t\t\t{\r\n\t\t\t\ttedlevel = true;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_Show() - Changes the appearance of one of the fields on the text\r\n//\t\tscreen. Possibly adds a checkmark in front of it and highlights it\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_Show(word x,word y,word w,boolean show,boolean hilight)\r\n{\r\n\tbyte\tfar *screen;\r\n\r\n\tscreen = MK_FP(0xb800,((x - 1) * 2) + (y * 80 * 2));\r\n\t*screen++ = show? 251 : ' ';\t// Checkmark char or space\r\n\t*screen = 0x48;\r\n\tif (show && hilight)\r\n\t{\r\n\t\tfor (w++;w--;screen += 2)\r\n\t\t\t*screen = 0x4f;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_ShowMem() - Right justifies a longword in one of the memory fields on\r\n//\t\tthe text screen\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_ShowMem(word x,word y,long mem)\r\n{\r\n\tchar\tbuf[16];\r\n\tword\ti;\r\n\r\n\tfor (i = strlen(ltoa(mem,buf,10));i < 5;i++)\r\n\t\tUSL_ScreenDraw(x++,y,\" \",0x48);\r\n\tUSL_ScreenDraw(x,y,buf,0x48);\r\n}\r\n\r\n\r\n#if 0\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_UpdateTextScreen() - Called after the ID libraries are started up.\r\n//\t\tDisplays what hardware is present.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_UpdateTextScreen(void)\r\n{\r\n\tboolean\t\tb;\r\n\tbyte\t\tfar *screen;\r\n\tword\t\ti;\r\n\tlongword\ttotalmem;\r\n\r\n\t// Show video card info\r\n\tb = (grmode == CGAGR);\r\n\tUSL_Show(21,7,4,(videocard >= CGAcard) && (videocard <= VGAcard),b);\r\n\tb = (grmode == EGAGR);\r\n\tUSL_Show(21,8,4,(videocard >= EGAcard) && (videocard <= VGAcard),b);\r\n\tb = (grmode == VGAGR);\r\n\tUSL_Show(21,9,4,videocard == VGAcard,b);\r\n\tif (compatability)\r\n\t\tUSL_ScreenDraw(5,10,\"SVGA Compatibility Mode Enabled.\",0x4f);\r\n\r\n\t// Show input device info\r\n\tUSL_Show(60,7,8,true,true);\r\n\tUSL_Show(60,8,11,JoysPresent[0],true);\r\n\tUSL_Show(60,9,11,JoysPresent[1],true);\r\n\tUSL_Show(60,10,5,MousePresent,true);\r\n\r\n\t// Show sound hardware info\r\n\tUSL_Show(21,14,11,true,SoundMode == sdm_PC);\r\n\tb = (SoundMode == sdm_AdLib) || (MusicMode == smm_AdLib);\r\n\tUSL_Show(21,15,5,AdLibPresent && !SoundBlasterPresent,\r\n\t\t\t\tb && !SoundBlasterPresent);\r\n\tUSL_Show(21,16,13,SoundBlasterPresent,\r\n\t\t\tSoundBlasterPresent && (b || (SoundMode == sdm_SoundBlaster)));\r\n\tUSL_Show(21,17,13,SoundSourcePresent,SoundMode == sdm_SoundSource);\r\n\r\n\t// Show memory available/used\r\n\tUSL_ShowMem(63,15,mminfo.mainmem / 1024);\r\n\tUSL_Show(53,15,23,true,true);\r\n\tUSL_ShowMem(63,16,mminfo.EMSmem / 1024);\r\n\tUSL_Show(53,16,23,mminfo.EMSmem? true : false,true);\r\n\tUSL_ShowMem(63,17,mminfo.XMSmem / 1024);\r\n\tUSL_Show(53,17,23,mminfo.XMSmem? true : false,true);\r\n\ttotalmem = mminfo.mainmem + mminfo.EMSmem + mminfo.XMSmem;\r\n\tUSL_ShowMem(63,18,totalmem / 1024);\r\n\tscreen = MK_FP(0xb800,1 + (((63 - 1) * 2) + (18 * 80 * 2)));\r\n\tfor (i = 0;i < 13;i++,screen += 2)\r\n\t\t*screen = 0x4f;\r\n\r\n\t// Change Initializing... to Loading...\r\n\tUSL_ScreenDraw(27,22,\"  Loading...   \",0x9c);\r\n}\r\n\r\n#endif\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_FinishTextScreen() - After the main program has finished its initial\r\n//\t\tloading, this routine waits for a keypress and then clears the screen\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_FinishTextScreen(void)\r\n{\r\n\t// Change Loading... to Press a Key\r\n\tUSL_ScreenDraw(30, 18, \"Ready - Press a Key\",0xCE);\r\n\r\n\tif (!tedlevel)\r\n\t{\r\n\t\tIN_ClearKeysDown();\r\n\t\tIN_Ack();\r\n\t}\r\n\tIN_ClearKeysDown();\r\n\r\n\tUSL_ClearTextScreen();\r\n}\r\n\r\n//\tWindow/Printing routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_SetPrintRoutines() - Sets the routines used to measure and print\r\n//\t\tfrom within the User Mgr. Primarily provided to allow switching\r\n//\t\tbetween masked and non-masked fonts\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_SetPrintRoutines(void (*measure)(char far *,word *,word *),void (*print)(char far *))\r\n{\r\n\tUSL_MeasureString = measure;\r\n\tUSL_DrawString = print;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_Print() - Prints a string in the current window. Newlines are\r\n//\t\tsupported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_Print(char *s)\r\n{\r\n\tchar\tc,*se;\r\n\tword\tw,h;\r\n\r\n\twhile (*s)\r\n\t{\r\n\t\tse = s;\r\n\t\twhile ((c = *se) && (c != '\\n'))\r\n\t\t\tse++;\r\n\t\t*se = '\\0';\r\n\r\n\t\tUSL_MeasureString(s,&w,&h);\r\n\t\tpx = PrintX;\r\n\t\tpy = PrintY;\r\n\t\tUSL_DrawString(s);\r\n\r\n\t\ts = se;\r\n\t\tif (c)\r\n\t\t{\r\n\t\t\t*se = c;\r\n\t\t\ts++;\r\n\r\n\t\t\tPrintX = WindowX;\r\n\t\t\tPrintY += h;\r\n\t\t}\r\n\t\telse\r\n\t\t\tPrintX += w;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_PrintUnsigned() - Prints an unsigned long\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_PrintUnsigned(longword n)\r\n{\r\n\tchar\tbuffer[32];\r\n\r\n\tUS_Print(ultoa(n,buffer,10));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_PrintSigned() - Prints a signed long\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_PrintSigned(long n)\r\n{\r\n\tchar\tbuffer[32];\r\n\r\n\tUS_Print(ltoa(n,buffer,10));\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_PrintInCenter() - Prints a string in the center of the given rect\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_PrintInCenter(char *s,Rect r)\r\n{\r\n\tword\tw,h,\r\n\t\t\trw,rh;\r\n\r\n\tUSL_MeasureString(s,&w,&h);\r\n\trw = r.lr.x - r.ul.x;\r\n\trh = r.lr.y - r.ul.y;\r\n\r\n\tpx = r.ul.x + ((rw - w) / 2);\r\n\tpy = r.ul.y + ((rh - h) / 2);\r\n\tUSL_DrawString(s);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_PrintCentered() - Prints a string centered in the current window.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_PrintCentered(char *s)\r\n{\r\n\tRect\tr;\r\n\r\n\tr.ul.x = WindowX;\r\n\tr.ul.y = WindowY;\r\n\tr.lr.x = r.ul.x + WindowW;\r\n\tr.lr.y = r.ul.y + WindowH;\r\n\r\n\tUSL_PrintInCenter(s,r);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_CPrintLine() - Prints a string centered on the current line and\r\n//\t\tadvances to the next line. Newlines are not supported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CPrintLine(char *s)\r\n{\r\n\tword\tw,h;\r\n\r\n\tUSL_MeasureString(s,&w,&h);\r\n\r\n\tif (w > WindowW)\r\n\t\tQuit(\"US_CPrintLine() - String exceeds width\");\r\n\tpx = WindowX + ((WindowW - w) / 2);\r\n\tpy = PrintY;\r\n\tUSL_DrawString(s);\r\n\tPrintY += h;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_CPrint() - Prints a string in the current window. Newlines are\r\n//\t\tsupported.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CPrint(char *s)\r\n{\r\n\tchar\tc,*se;\r\n\tword\tw,h;\r\n\r\n\twhile (*s)\r\n\t{\r\n\t\tse = s;\r\n\t\twhile ((c = *se) && (c != '\\n'))\r\n\t\t\tse++;\r\n\t\t*se = '\\0';\r\n\r\n\t\tUS_CPrintLine(s);\r\n\r\n\t\ts = se;\r\n\t\tif (c)\r\n\t\t{\r\n\t\t\t*se = c;\r\n\t\t\ts++;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_ClearWindow() - Clears the current window to white and homes the\r\n//\t\tcursor\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_ClearWindow(void)\r\n{\r\n\tVWB_Bar(WindowX,WindowY,WindowW,WindowH,WHITE);\r\n\tPrintX = WindowX;\r\n\tPrintY = WindowY;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_DrawWindow() - Draws a frame and sets the current window parms\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_DrawWindow(word x,word y,word w,word h)\r\n{\r\n\tword\ti,\r\n\t\t\tsx,sy,sw,sh;\r\n\r\n\tWindowX = x * 8;\r\n\tWindowY = y * 8;\r\n\tWindowW = w * 8;\r\n\tWindowH = h * 8;\r\n\r\n\tPrintX = WindowX;\r\n\tPrintY = WindowY;\r\n\r\n\tsx = (x - 1) * 8;\r\n\tsy = (y - 1) * 8;\r\n\tsw = (w + 1) * 8;\r\n\tsh = (h + 1) * 8;\r\n\r\n\tUS_ClearWindow();\r\n\r\n\tVWB_DrawTile8M(sx,sy,0),VWB_DrawTile8M(sx,sy + sh,6);\r\n\tfor (i = sx + 8;i <= sx + sw - 8;i += 8)\r\n\t\tVWB_DrawTile8M(i,sy,1),VWB_DrawTile8M(i,sy + sh,7);\r\n\tVWB_DrawTile8M(i,sy,2),VWB_DrawTile8M(i,sy + sh,8);\r\n\r\n\tfor (i = sy + 8;i <= sy + sh - 8;i += 8)\r\n\t\tVWB_DrawTile8M(sx,i,3),VWB_DrawTile8M(sx + sw,i,5);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_CenterWindow() - Generates a window of a given width & height in the\r\n//\t\tmiddle of the screen\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CenterWindow(word w,word h)\r\n{\r\n\tUS_DrawWindow(((MaxX / 8) - w) / 2,((MaxY / 8) - h) / 2,w,h);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_CenterSaveWindow() - Generates a window of a given width & height in\r\n//\t\tthe middle of the screen, saving the background\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CenterSaveWindow(word w,word h,memptr *save)\r\n{\r\n\tword\tx,y,\r\n\t\t\tscreen;\r\n\r\n\tx = ((MaxX / 8) - w) / 2;\r\n\ty = ((MaxY / 8) - h) / 2;\r\n\tMM_GetPtr(save,(w * h) * CHARWIDTH);\r\n\tscreen = bufferofs + panadjust + ylookup[y] + (x * CHARWIDTH);\r\n\tVW_ScreenToMem(screen,*save,w * CHARWIDTH,h);\r\n\tUS_DrawWindow(((MaxX / 8) - w) / 2,((MaxY / 8) - h) / 2,w,h);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_RestoreSaveWindow() - Restores the background of the size of the\r\n//\t\tcurrent window from the memory specified by save\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_RestoreSaveWindow(memptr *save)\r\n{\r\n\tword\tscreen;\r\n\r\n\tscreen = bufferofs + panadjust + ylookup[WindowY] + (WindowX * CHARWIDTH);\r\n\tVW_MemToScreen(*save,screen,WindowW * CHARWIDTH,WindowH);\r\n\tMM_FreePtr(save);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_SaveWindow() - Saves the current window parms into a record for\r\n//\t\tlater restoration\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_SaveWindow(WindowRec *win)\r\n{\r\n\twin->x = WindowX;\r\n\twin->y = WindowY;\r\n\twin->w = WindowW;\r\n\twin->h = WindowH;\r\n\r\n\twin->px = PrintX;\r\n\twin->py = PrintY;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_RestoreWindow() - Sets the current window parms to those held in the\r\n//\t\trecord\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_RestoreWindow(WindowRec *win)\r\n{\r\n\tWindowX = win->x;\r\n\tWindowY = win->y;\r\n\tWindowW = win->w;\r\n\tWindowH = win->h;\r\n\r\n\tPrintX = win->px;\r\n\tPrintY = win->py;\r\n}\r\n\r\n//\tCursor routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_StartCursor() - Sets up the cursor for User Mgr use\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_StartCursor(void)\r\n{\r\n\tCursorInfo\tinfo;\r\n\r\n\tVW_SetCursor(CURSORARROWSPR);\r\n\tCursorX = MaxX / 2;\r\n\tCursorY = MaxY / 2;\r\n\tVW_MoveCursor(CursorX,CursorY);\r\n\tVW_ShowCursor();\r\n\r\n\tIN_ReadCursor(&info);\t// Dispose of any accumulated movement\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_ShutCursor() - Cleans up after US_StartCursor()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_ShutCursor(void)\r\n{\r\n\tVW_HideCursor();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_UpdateCursor() - Gets the new cursor position & button states from\r\n//\t\tthe Input Mgr and tells the View Mgr where the cursor is\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nUS_UpdateCursor(void)\r\n{\r\n\tCursorInfo\tinfo;\r\n\r\n\tIN_ReadCursor(&info);\r\n\tif (info.x || info.y || CursorBad)\r\n\t{\r\n\t\tCursorX += info.x;\r\n\t\tif (CursorX >= MaxX)\r\n\t\t\tCursorX = MaxX - 1;\r\n\t\telse if (CursorX < 0)\r\n\t\t\tCursorX = 0;\r\n\r\n\t\tCursorY += info.y;\r\n\t\tif (CursorY >= MaxY)\r\n\t\t\tCursorY = MaxY - 1;\r\n\t\telse if (CursorY < 0)\r\n\t\t\tCursorY = 0;\r\n\r\n\t\tVW_MoveCursor(CursorX,CursorY);\r\n\t\tCursorBad = false;\r\n\t}\r\n\tButton0 = info.button0;\r\n\tButton1 = info.button1;\r\n\treturn(Button0 || Button1);\r\n}\r\n\r\n//\tInput routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_XORICursor() - XORs the I-bar text cursor. Used by US_LineInput()\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_XORICursor(int x,int y,char *s,word cursor)\r\n{\r\n\tchar\tbuf[MaxString];\r\n\tword\tw,h;\r\n\r\n\tstrcpy(buf,s);\r\n\tbuf[cursor] = '\\0';\r\n\tUSL_MeasureString(buf,&w,&h);\r\n\r\n\tpx = x + w - 1;\r\n\tpy = y;\r\n\tUSL_DrawString(\"\\x80\");\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_LineInput() - Gets a line of user input at (x,y), the string defaults\r\n//\t\tto whatever is pointed at by def. Input is restricted to maxchars\r\n//\t\tchars or maxwidth pixels wide. If the user hits escape (and escok is\r\n//\t\ttrue), nothing is copied into buf, and false is returned. If the\r\n//\t\tuser hits return, the current string is copied into buf, and true is\r\n//\t\treturned\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nboolean\r\nUS_LineInput(int x,int y,char *buf,char *def,boolean escok,\r\n\t\t\t\tint maxchars,int maxwidth)\r\n{\r\n\tboolean\t\tredraw,\r\n\t\t\t\tcursorvis,cursormoved,\r\n\t\t\t\tdone,result;\r\n\tScanCode\tsc;\r\n\tchar\t\tc,\r\n\t\t\t\ts[MaxString],olds[MaxString];\r\n\tword\t\ti,\r\n\t\t\t\tcursor,\r\n\t\t\t\tw,h,\r\n\t\t\t\tlen;\r\n\tlongword\tlasttime;\r\n\r\n\tVW_HideCursor();\r\n\r\n\tif (def)\r\n\t\tstrcpy(s,def);\r\n\telse\r\n\t\t*s = '\\0';\r\n\t*olds = '\\0';\r\n\tcursor = strlen(s);\r\n\tcursormoved = redraw = true;\r\n\r\n\tcursorvis = done = false;\r\n\tlasttime = TimeCount;\r\n\tLastASCII = key_None;\r\n\tLastScan = sc_None;\r\n\r\n\twhile (!done)\r\n\t{\r\n\t\tif (cursorvis)\r\n\t\t\tUSL_XORICursor(x,y,s,cursor);\r\n\r\n\tasm\tpushf\r\n\tasm\tcli\r\n\r\n\t\tsc = LastScan;\r\n\t\tLastScan = sc_None;\r\n\t\tc = LastASCII;\r\n\t\tLastASCII = key_None;\r\n\r\n\tasm\tpopf\r\n\r\n\t\tswitch (sc)\r\n\t\t{\r\n\t\tcase sc_LeftArrow:\r\n\t\t\tif (cursor)\r\n\t\t\t\tcursor--;\r\n\t\t\tc = key_None;\r\n\t\t\tcursormoved = true;\r\n\t\t\tbreak;\r\n\t\tcase sc_RightArrow:\r\n\t\t\tif (s[cursor])\r\n\t\t\t\tcursor++;\r\n\t\t\tc = key_None;\r\n\t\t\tcursormoved = true;\r\n\t\t\tbreak;\r\n\t\tcase sc_Home:\r\n\t\t\tcursor = 0;\r\n\t\t\tc = key_None;\r\n\t\t\tcursormoved = true;\r\n\t\t\tbreak;\r\n\t\tcase sc_End:\r\n\t\t\tcursor = strlen(s);\r\n\t\t\tc = key_None;\r\n\t\t\tcursormoved = true;\r\n\t\t\tbreak;\r\n\r\n\t\tcase sc_Return:\r\n\t\t\tstrcpy(buf,s);\r\n\t\t\tdone = true;\r\n\t\t\tresult = true;\r\n\t\t\tc = key_None;\r\n\t\t\tbreak;\r\n\t\tcase sc_Escape:\r\n\t\t\tif (escok)\r\n\t\t\t{\r\n\t\t\t\tdone = true;\r\n\t\t\t\tresult = false;\r\n\t\t\t}\r\n\t\t\tc = key_None;\r\n\t\t\tbreak;\r\n\r\n\t\tcase sc_BackSpace:\r\n\t\t\tif (cursor)\r\n\t\t\t{\r\n\t\t\t\tstrcpy(s + cursor - 1,s + cursor);\r\n\t\t\t\tcursor--;\r\n\t\t\t\tredraw = true;\r\n\t\t\t}\r\n\t\t\tc = key_None;\r\n\t\t\tcursormoved = true;\r\n\t\t\tbreak;\r\n\t\tcase sc_Delete:\r\n\t\t\tif (s[cursor])\r\n\t\t\t{\r\n\t\t\t\tstrcpy(s + cursor,s + cursor + 1);\r\n\t\t\t\tredraw = true;\r\n\t\t\t}\r\n\t\t\tc = key_None;\r\n\t\t\tcursormoved = true;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 0x4c:\t// Keypad 5\r\n\t\tcase sc_UpArrow:\r\n\t\tcase sc_DownArrow:\r\n\t\tcase sc_PgUp:\r\n\t\tcase sc_PgDn:\r\n\t\tcase sc_Insert:\r\n\t\t\tc = key_None;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (c)\r\n\t\t{\r\n\t\t\tlen = strlen(s);\r\n\t\t\tUSL_MeasureString(s,&w,&h);\r\n\r\n\t\t\tif\r\n\t\t\t(\r\n\t\t\t\tisprint(c)\r\n\t\t\t&&\t(len < MaxString - 1)\r\n\t\t\t&&\t((!maxchars) || (len < maxchars))\r\n\t\t\t&&\t((!maxwidth) || (w < maxwidth))\r\n\t\t\t)\r\n\t\t\t{\r\n\t\t\t\tfor (i = len + 1;i > cursor;i--)\r\n\t\t\t\t\ts[i] = s[i - 1];\r\n\t\t\t\ts[cursor++] = c;\r\n\t\t\t\tredraw = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (redraw)\r\n\t\t{\r\n\t\t\tpx = x;\r\n\t\t\tpy = y;\r\n\t\t\tUSL_DrawString(olds);\r\n\t\t\tstrcpy(olds,s);\r\n\r\n\t\t\tpx = x;\r\n\t\t\tpy = y;\r\n\t\t\tUSL_DrawString(s);\r\n\r\n\t\t\tredraw = false;\r\n\t\t}\r\n\r\n\t\tif (cursormoved)\r\n\t\t{\r\n\t\t\tcursorvis = false;\r\n\t\t\tlasttime = TimeCount - TickBase;\r\n\r\n\t\t\tcursormoved = false;\r\n\t\t}\r\n\t\tif (TimeCount - lasttime > TickBase / 2)\r\n\t\t{\r\n\t\t\tlasttime = TimeCount;\r\n\r\n\t\t\tcursorvis ^= true;\r\n\t\t}\r\n\t\tif (cursorvis)\r\n\t\t\tUSL_XORICursor(x,y,s,cursor);\r\n\r\n\t\tVW_UpdateScreen();\r\n\t}\r\n\r\n\tif (cursorvis)\r\n\t\tUSL_XORICursor(x,y,s,cursor);\r\n\tif (!result)\r\n\t{\r\n\t\tpx = x;\r\n\t\tpy = y;\r\n\t\tUSL_DrawString(olds);\r\n\t}\r\n\tVW_ShowCursor();\r\n\tVW_UpdateScreen();\r\n\r\n\tIN_ClearKeysDown();\r\n\treturn(result);\r\n}\r\n\r\n//\tControl panel routines\r\n\r\nstatic\tboolean\t\tFlushHelp;\r\nstatic\tWindowRec\tHelpWindow,BottomWindow;\r\ntypedef\tenum\r\n\t\t{\r\n\t\t\tuic_Draw,uic_Hit\r\n\t\t} UserCall;\r\ntypedef\tenum\r\n\t\t{\r\n\t\t\tuii_Bad,uii_Button,uii_RadioButton,uii_CheckBox,uii_KeyCap\r\n\t\t} UIType;\r\n#define\tui_Normal\t0\r\n#define\tui_Selected\t1\r\n#define\tui_Disabled\t2\r\n\r\n\t\t\t\t\t// Prototype the custom routines\r\nstatic\tboolean\t\tUSL_CtlButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlPButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlPSButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlPRButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlHButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlDButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlDEButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlDLButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlDSButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlSButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlCButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlCKbdButtonCustom(UserCall,word,word),\r\n\t\t\t\t\tUSL_CtlCJoyButtonCustom(UserCall,word,word);\r\n\r\n\t\t\t\t\t// The structure of a user interaction item\r\ntypedef\tstruct\t{\r\n\t\t\t\t\tRect\t\tr;\t\t\t\t// The enclosing rectangle\r\n\t\t\t\t\tUIType\t\ttype;\t\t\t// The type of item\r\n\t\t\t\t\tint\t\t\tpicup,picdown;\t// What to draw when up/down\r\n\t\t\t\t\tchar\t\t*help;\t\t\t// Floating help string\r\n\t\t\t\t\tScanCode\tkey;\t\t\t// Key equiv\r\n\t\t\t\t\tword\t\tsel;\t\t\t// Interaction flags (ui_XXX)\r\n\t\t\t\t\tboolean\t\t(*custom)(UserCall,word,word);\t// Custom routine\r\n\t\t\t\t\tchar\t\t*text;\t\t\t// Text for some items\r\n\t\t\t\t} UserItem;\r\ntypedef\tstruct\t{\r\n\t\t\t\t\tScanCode\tkey;\r\n\t\t\t\t\tword\t\ti,n,\t\t// Hit CtlPanels2[i][n]\r\n\t\t\t\t\t\t\t\ttoi,ton;\t// Move to CtlPanels2[toi][ton]\r\n\t\t\t\t} HotKey;\t// MARK\r\n\r\nstatic\tScanCode\t*KeyMaps[] =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t&KbdDefs[0].button0,&KbdDefs[0].button1,\r\n\t\t\t\t\t\t&KbdDefs[0].upleft,&KbdDefs[0].up,&KbdDefs[0].upright,\r\n\t\t\t\t\t\t&KbdDefs[0].left, &KbdDefs[0].right,\r\n\t\t\t\t\t\t&KbdDefs[0].downleft,&KbdDefs[0].down,&KbdDefs[0].downright,\r\n\t\t\t\t\t};\r\n\r\n// Some macros to make rectangle definition quite a bit less unpleasant\r\n#define\tCtlPanelX\t8\r\n#define\tCtlPanelY\t4\r\n#define\tCtlPanel2X\t(8*8)\r\n#define\tCtlPanel2Y\t(2*8)\r\n#define\tCtlPanel3X\t(8*8)\r\n#define\tCtlPanel3Y\t(7*8)\r\n\r\n#define\tCtlPanelR(n)\t{\tCtlPanelX,CtlPanelY+(32 * (n)),\\\r\n\t\t\t\t\t\t\tCtlPanelX+40,CtlPanelY+(32 * (n)) + 32}\r\n#define\tCtlPanel2R(x,y)\t{\tCtlPanel2X+(x)*8,CtlPanel2Y+(y)*8,\\\r\n\t\t\t\t\t\t\tCtlPanel2X+32+(x)*8,CtlPanel2Y+24+(y)*8}\r\n#define\tCtlPanel3R(x,y)\t{\tCtlPanel3X+(x)*8,CtlPanel3Y+(y)*8,\\\r\n\t\t\t\t\t\t\tCtlPanel3X+32+(x)*8,CtlPanel3Y+24+(y)*8}\r\nstatic\tUserItem\tCtlPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanelR(0),uii_RadioButton,CTL_STARTUPPIC,CTL_STARTDNPIC,\"Start or Resume a Game\",sc_None,ui_Normal,USL_CtlButtonCustom},\r\n{CtlPanelR(1),uii_RadioButton,CTL_HELPUPPIC,CTL_HELPDNPIC,\"Get Help With Commander Keen\",sc_None,ui_Normal,USL_CtlButtonCustom},\r\n{CtlPanelR(2),uii_RadioButton,CTL_DISKUPPIC,CTL_DISKDNPIC,\"Load / Save / Quit\",sc_None,ui_Normal,USL_CtlButtonCustom},\r\n{CtlPanelR(3),uii_RadioButton,CTL_CONTROLSUPPIC,CTL_CONTROLSDNPIC,\"Choose Controls\",sc_C,ui_Normal,USL_CtlButtonCustom},\r\n{CtlPanelR(4),uii_RadioButton,CTL_SOUNDUPPIC,CTL_SOUNDDNPIC,\"Select Sound Device\",sc_F2,ui_Normal,USL_CtlButtonCustom},\r\n{CtlPanelR(5),uii_RadioButton,CTL_MUSICUPPIC,CTL_MUSICDNPIC,\"Turn Music On / Off\",sc_F7,ui_Normal,USL_CtlButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlPPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel2R(10,0),uii_RadioButton,CTL_P_NEWGAMEUPPIC,CTL_P_NEWGAMEDNPIC,\"Choose Difficulty for the New Game\",sc_F5,ui_Normal,USL_CtlPButtonCustom},\r\n{CtlPanel2R(15,0),uii_RadioButton,CTL_P_RESUMEUPPIC,CTL_P_RESUMEDNPIC,\"Go Back to Current Game\",sc_None,ui_Normal,USL_CtlPButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlPSPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel3R(13,5),uii_Button,CTL_P_MEDUPPIC,CTL_P_MEDDNPIC,\"Start New Game in Normal Mode\",sc_None,ui_Normal,USL_CtlPSButtonCustom},\r\n{CtlPanel3R(8,5),uii_Button,CTL_P_EASYUPPIC,CTL_P_EASYDNPIC,\"Start New Game in Easy Mode\",sc_None,ui_Normal,USL_CtlPSButtonCustom},\r\n{CtlPanel3R(18,5),uii_Button,CTL_P_HARDUPPIC,CTL_P_HARDDNPIC,\"Start New Game in Hard Mode\",sc_None,ui_Normal,USL_CtlPSButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlPRPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel3R(13,5),uii_Button,CTL_P_GORESUMEUPPIC,CTL_P_GORESUMEDNPIC,\"Resume Current Game\",sc_None,ui_Normal,USL_CtlPRButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlHPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel2R(8,0),uii_Button,CTL_H_LOSTUPPIC,CTL_H_LOSTDNPIC,\"Help Me, I'm Lost!\",sc_F1,ui_Normal,USL_CtlHButtonCustom},\r\n{CtlPanel2R(13,0),uii_Button,CTL_H_CTRLUPPIC,CTL_H_CTRLDNPIC,\"Get Help with Controls\",sc_None,ui_Normal,USL_CtlHButtonCustom},\r\n{CtlPanel2R(18,0),uii_Button,CTL_H_STORYUPPIC,CTL_H_STORYDNPIC,\"Read Story & Game Tips\",sc_None,ui_Normal,USL_CtlHButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlDPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel2R(9,0),uii_RadioButton,CTL_D_LSGAMEUPPIC,CTL_D_LSGAMEDNPIC,\"Load or Save a Game\",sc_F6,ui_Normal,USL_CtlDButtonCustom},\r\n{CtlPanel2R(15,0),uii_RadioButton,CTL_D_DOSUPPIC,CTL_D_DOSDNPIC,\"Exit to DOS\",sc_Q,ui_Normal,USL_CtlDButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlDLSPanels[] =\r\n\t\t\t\t\t{\r\n#define\tCtlPanel3LSR(x,y)\t{\tCtlPanel3X+(x)*8,CtlPanel3Y+(y)*8,\\\r\n\t\t\t\t\t\t\t\tCtlPanel3X+32+(x)*8,CtlPanel3Y+16+(y)*8}\r\n{CtlPanel3LSR(1,0),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,0),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{CtlPanel3LSR(1,2),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,2),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{CtlPanel3LSR(1,4),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,4),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{CtlPanel3LSR(1,6),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,6),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{CtlPanel3LSR(1,8),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,8),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{CtlPanel3LSR(1,10),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,10),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{CtlPanel3LSR(1,12),uii_Button,CTL_D_LOADUPPIC,CTL_D_LOADDNPIC,\"Load This Game\",sc_None,ui_Normal,USL_CtlDLButtonCustom},\r\n{CtlPanel3LSR(6,12),uii_Button,CTL_D_SAVEUPPIC,CTL_D_SAVEDNPIC,\"Save Current Game Here\",sc_None,ui_Normal,USL_CtlDSButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlDEPanels[] =\r\n\t\t\t\t\t{\r\n#define\tCtlPanel3ER(x,y)\t{\tCtlPanel3X+(x)*8,CtlPanel3Y+(y)*8,\\\r\n\t\t\t\t\t\t\t\tCtlPanel3X+40+(x)*8,CtlPanel3Y+24+(y)*8}\r\n{CtlPanel3ER(12,5),uii_Button,CTL_D_EXITUPPIC,CTL_D_EXITDNPIC,\"Really Exit to DOS\",sc_None,ui_Normal,USL_CtlDEButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlCPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel2R(8,0),uii_RadioButton,CTL_C_KBDUPPIC,CTL_C_KBDDNPIC,\"Use / Configure Keyboard\",sc_F3,ui_Normal,USL_CtlCButtonCustom},\r\n{CtlPanel2R(13,0),uii_RadioButton,CTL_C_JOY1UPPIC,CTL_C_JOY1DNPIC,\"Use / Configure Joystick 1\",sc_None,ui_Normal,USL_CtlCButtonCustom},\r\n{CtlPanel2R(18,0),uii_RadioButton,CTL_C_JOY2UPPIC,CTL_C_JOY2DNPIC,\"Use / Configure Joystick 2\",sc_None,ui_Normal,USL_CtlCButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n#define\tCtlPanelKC3R(x,y)\t{\tCtlPanel3X+(x)*8,CtlPanel3Y+(y)*8,\\\r\n\t\t\t\t\t\t\t\tCtlPanel3X+56+(x)*8,CtlPanel3Y+32+(y)*8}\r\n\t\t\t\t\tCtlCKbdPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanelKC3R(1,2),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key for Jumping\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(1,6),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key for Throwing\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(8,0),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Up & Left\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(15,0),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Up\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(22,0),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Up & Right\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(8,4),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Left\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(22,4),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Right\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(8,8),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Down & Left\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(15,8),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Down\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{CtlPanelKC3R(22,8),uii_KeyCap,CTL_KEYCAPPIC,CTL_KEYCAPCURPIC,\"Define Key to move Down & Right\",sc_None,ui_Normal,USL_CtlCKbdButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlCJoyPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel3R(13,5),uii_Button,CTL_C_CALIBRATEUPPIC,CTL_C_CALIBRATEDNPIC,\"Configure Joystick\",sc_None,ui_Normal,USL_CtlCJoyButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlSPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel2R(3,0),uii_RadioButton,CTL_S_NOSNDUPPIC,CTL_S_NOSNDDNPIC,\"Turn Sound Off\",sc_None,ui_Normal,USL_CtlSButtonCustom},\r\n{CtlPanel2R(8,0),uii_RadioButton,CTL_S_PCSNDUPPIC,CTL_S_PCSNDDNPIC,\"Use PC Speaker\",sc_None,ui_Normal,USL_CtlSButtonCustom},\r\n{CtlPanel2R(13,0),uii_RadioButton,CTL_S_ADLIBUPPIC,CTL_S_ADLIBDNPIC,\"Use AdLib Sound Effects\",sc_None,ui_Normal,USL_CtlSButtonCustom},\r\n{CtlPanel2R(18,0),uii_RadioButton,CTL_S_SNDBLUPPIC,CTL_S_SNDBLDNPIC,\"Use SoundBlaster Sound Effects\",sc_None,ui_Normal,USL_CtlSButtonCustom},\r\n{CtlPanel2R(23,0),uii_RadioButton,CTL_S_SNDSRCUPPIC,CTL_S_SNDSRCDNPIC,\"Use Sound Source Sound Effects\",sc_None,ui_Normal,USL_CtlSButtonCustom},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlSSSPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel3R(7,2),uii_CheckBox,CTL_CHECKUPPIC,CTL_CHECKDNPIC,\"Turn Tandy Mode On / Off\",sc_None,ui_Normal,0,\"Tandy Mode\"},\r\n{CtlPanel3R(7,6),uii_CheckBox,CTL_CHECKUPPIC,CTL_CHECKDNPIC,\"Switch between LPT1 & LPT2\",sc_None,ui_Normal,0,\"Use LPT2\"},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\tCtlMPanels[] =\r\n\t\t\t\t\t{\r\n{CtlPanel2R(9,0),uii_RadioButton,CTL_M_NOMUSUPPIC,CTL_M_NOMUSDNPIC,\"Background Music Off\"},\r\n{CtlPanel2R(15,0),uii_RadioButton,CTL_M_ADLIBUPPIC,CTL_M_ADLIBDNPIC,\"Use AdLib/SoundBlaster Music\"},\r\n{-1,-1,-1,-1,uii_Bad}\r\n\t\t\t\t\t},\r\n\t\t\t\t\t*CtlPanels2[] =\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tCtlPPanels,\t// Start\r\n\t\t\t\t\t\tCtlHPanels,\t// Help\r\n\t\t\t\t\t\tCtlDPanels,\t// Disk\r\n\t\t\t\t\t\tCtlCPanels,\t// Controls\r\n\t\t\t\t\t\tCtlSPanels,\t// Sound\r\n\t\t\t\t\t\tCtlMPanels\t// Music\r\n\t\t\t\t\t},\r\n\t\t\t\t\t*TheItems[4] = {CtlPanels};\r\nstatic\tint\t\t\tCtlPanelButton;\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_TurnOff() - Goes through a list of UserItems and sets them all to\r\n//\t\tthe normal state\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_TurnOff(UserItem *ip)\r\n{\r\n\twhile (ip->type != uii_Bad)\r\n\t{\r\n\t\tip->sel = ui_Normal;\r\n\t\tip++;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_FindDown() - Finds which UserItem, if any, is selected in the given\r\n//\t\tlist\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic int\r\nUSL_FindDown(UserItem *ip)\r\n{\r\n\tint\ti;\r\n\r\n\tfor (i = 0;ip->type != uii_Bad;i++,ip++)\r\n\t\tif (ip->sel & ui_Selected)\r\n\t\t\treturn(i);\r\n\treturn(-1);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_ShowHelp() - Shows the specified string in the help window\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_ShowHelp(char *s)\r\n{\r\n\tWindowRec\twr;\r\n\r\n\tif (!s)\r\n\t\treturn;\r\n\r\n\tUS_SaveWindow(&wr);\r\n\tUS_RestoreWindow(&HelpWindow);\r\n\r\n\tUS_ClearWindow();\r\n\tUS_PrintCentered(s);\r\n\r\n\tUS_RestoreWindow(&wr);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_HandleError() - Handles telling the user that there's been an error\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_HandleError(int num)\r\n{\r\n\tchar\tbuf[64];\r\n\r\n\tstrcpy(buf,\"Error: \");\r\n\tif (num < 0)\r\n\t\tstrcat(buf,\"Unknown\");\r\n\telse if (num == ENOMEM)\r\n\t\tstrcat(buf,\"Disk is Full\");\r\n\telse if (num == EINVFMT)\r\n\t\tstrcat(buf,\"File is Incomplete\");\r\n\telse\r\n\t\tstrcat(buf,sys_errlist[num]);\r\n\r\n\tVW_HideCursor();\r\n\r\n\tfontcolor = F_SECONDCOLOR;\r\n\tUSL_ShowHelp(buf);\r\n\tfontcolor = F_BLACK;\r\n\tVW_UpdateScreen();\r\n\r\n\tIN_ClearKeysDown();\r\n\tIN_Ack();\r\n\r\n\tVW_ShowCursor();\r\n\tVW_UpdateScreen();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_DrawItem() - Draws a UserItem. If there's a custom routine, this will\r\n//\t\tcall it with a uic_Draw command. If the custom routine returns true,\r\n//\t\tthen the routine handled all of the drawing. If it returns false,\r\n//\t\tthen this routine does the default drawing.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_DrawItem(word hiti,word hitn)\r\n{\r\n\tboolean\t\thandled,centered;\r\n\tchar\t\t*text;\r\n\tword\t\tw,h;\r\n\tint\t\t\tpicup,picdown;\r\n\tRect\t\tr;\r\n\tUserItem\t*ip;\r\n\r\n\tip = &TheItems[hiti][hitn];\r\n\tif (ip->custom)\r\n\t\thandled = ip->custom(uic_Draw,hiti,hitn);\r\n\telse\r\n\t\thandled = false;\r\n\r\n\tif (!handled)\r\n\t{\r\n\t\tpicup = ip->picup;\r\n\t\tpicdown = ip->picdown;\r\n\t\tswitch (ip->type)\r\n\t\t{\r\n\t\tcase uii_CheckBox:\r\n\t\t\tpx = ip->r.lr.x + 8;\r\n\t\t\tpy = ip->r.ul.y + 8;\r\n\t\t\ttext = ip->text;\r\n\t\t\tcentered = false;\r\n\t\t\tbreak;\r\n\t\tcase uii_KeyCap:\r\n\t\t\tif (!(ip->sel & ui_Selected))\r\n\t\t\t{\r\n\t\t\t\ttext = ip->text;\r\n\t\t\t\tif (text)\r\n\t\t\t\t{\r\n\t\t\t\t\tr = ip->r;\r\n\t\t\t\t\tcentered = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\ttext = nil;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\ttext = nil;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tVWB_DrawPic(ip->r.ul.x,ip->r.ul.y,\r\n\t\t\t\t\t\t(ip->sel & ui_Selected)? picdown : picup);\r\n\t\tif (text)\r\n\t\t{\r\n\t\t\tif (centered)\r\n\t\t\t\tUSL_PrintInCenter(text,r);\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tUSL_MeasureString(text,&w,&h);\r\n\t\t\t\tVWB_Bar(px,py,w + 7,h,WHITE);\r\n\t\t\t\tUSL_DrawString(text);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ip->sel & ui_Disabled)\r\n\t\t{\r\n\t\t\tif ((picup == CTL_D_LOADUPPIC) || (picup == CTL_D_SAVEUPPIC))\r\n\t\t\t\tVWB_DrawMPic(ip->r.ul.x,ip->r.ul.y,CTL_LSMASKPICM);\r\n\t\t\telse\r\n\t\t\t\tVWB_DrawMPic(ip->r.ul.x,ip->r.ul.y,CTL_LITTLEMASKPICM);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_DoHit() - Handles a hit on a UserItem. If there's a custom routine,\r\n//\t\t\tit will be called. If it returns true, then don't do anything\r\n//\t\t\tmore. If it returns false, then use the standard behaviour\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_DoHit(word hiti,word hitn)\r\n{\r\n\tboolean\t\thandled;\r\n\tword\t\ti;\r\n\tUserItem\t*ip;\r\n\r\n\tip = &TheItems[hiti][hitn];\r\n\tif (ip->custom)\r\n\t\thandled = ip->custom(uic_Hit,hiti,hitn);\r\n\telse\r\n\t\thandled = false;\r\n\r\n\tif (!handled)\r\n\t{\r\n\t\tif (TheItems[hiti][hitn].sel & ui_Disabled)\r\n\t\t{\r\n\t\t\tfontcolor = F_SECONDCOLOR;\r\n\t\t\tUSL_ShowHelp(\"This Item is Disabled\");\r\n\t\t\tfontcolor = F_BLACK;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tFlushHelp = true;\r\n\r\n\t\tswitch (ip->type)\r\n\t\t{\r\n\t\tcase uii_Button:\r\n\t\t\t// Must have a custom routine to handle hits - this just redraws\r\n\t\t\tip->sel ^= ui_Selected;\r\n\t\t\tUSL_DrawItem(hiti,hitn);\r\n\t\tcase uii_CheckBox:\r\n\t\t\tip->sel ^= ui_Selected;\r\n\t\t\tUSL_DrawItem(hiti,hitn);\r\n\t\t\tbreak;\r\n\t\tcase uii_RadioButton:\r\n\t\t\tfor (i = 0,ip = TheItems[hiti];ip->type != uii_Bad;i++,ip++)\r\n\t\t\t{\r\n\t\t\t\tif\r\n\t\t\t\t(\r\n\t\t\t\t\t(i != hitn)\r\n\t\t\t\t&&\t(ip->type == uii_RadioButton)\r\n\t\t\t\t&&\t(ip->sel & ui_Selected)\r\n\t\t\t\t)\r\n\t\t\t\t{\r\n\t\t\t\t\tip->sel &= ~ui_Selected;\r\n\t\t\t\t\tUSL_DrawItem(hiti,i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tTheItems[hiti][hitn].sel |= ui_Selected;\r\n\t\t\tUSL_DrawItem(hiti,hitn);\r\n\t\t\tbreak;\r\n\t\tcase uii_KeyCap:\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_IsInRect() - Checks to see if the coordinates given are within any\r\n//\t\tof the Rects in the UserItem list. If so, returns true & sets the\r\n//\t\tindex & number for lookup. If not, returns false.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_IsInRect(word x,word y,word *index,word *number)\r\n{\r\n\tUserItem\t*item,**items;\r\n\r\n\titems = TheItems;\r\n\t*index = 0;\r\n\twhile (*items)\r\n\t{\r\n\t\titem = *items;\r\n\t\t*number = 0;\r\n\t\twhile (item->type != uii_Bad)\r\n\t\t{\r\n\t\t\tif\r\n\t\t\t(\r\n\t\t\t\t(x >= item->r.ul.x)\r\n\t\t\t&&\t(x <  item->r.lr.x)\r\n\t\t\t&&\t(y >= item->r.ul.y)\r\n\t\t\t&&\t(y <  item->r.lr.y)\r\n\t\t\t)\r\n\t\t\t\treturn(true);\r\n\t\t\t(*number)++;\r\n\t\t\titem++;\r\n\t\t}\r\n\r\n\t\t(*index)++;\r\n\t\titems++;\r\n\t}\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_TrackItem() - Tracks the given item. If the cursor is inside of the\r\n//\t\titem, it's redrawn as down. If the cursor is outside, the item is\r\n//\t\tdrawn in its original state. Returns true if the button was released\r\n//\t\twhile the cursor was inside the item, or false if it wasn't.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_TrackItem(word hiti,word hitn)\r\n{\r\n\tboolean\t\tinside,last;\r\n\tword\t\tini,inn,\r\n\t\t\t\ton,\r\n\t\t\t\tsel,othersel;\r\n\tUserItem\t*ip,*op;\r\n\r\n\tip = &TheItems[hiti][hitn];\r\n\tsel = ip->sel;\r\n\tif (ip->type == uii_RadioButton)\r\n\t{\r\n\t\tinside = false;\r\n\t\tfor (op = TheItems[hiti],on = 0;op->type != uii_Bad;op++,on++)\r\n\t\t{\r\n\t\t\tif (op->sel & ui_Selected)\r\n\t\t\t{\r\n\t\t\t\tinside = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!inside)\r\n\t\t\top = ip;\r\n\t\tothersel = op->sel;\r\n\t}\r\n\telse\r\n\t\top = nil;\r\n\r\n\tif (ip->sel & ui_Disabled)\r\n\t{\r\n\t\tfontcolor = F_SECONDCOLOR;\r\n\t\tUSL_ShowHelp(\"This item is disabled\");\r\n\t\tfontcolor = F_BLACK;\r\n\r\n\t\twhile (US_UpdateCursor())\r\n\t\t\tVW_UpdateScreen();\r\n\r\n\t\tFlushHelp = true;\r\n\t\treturn(false);\r\n\t}\r\n\r\n\tlast = false;\r\n\tdo\r\n\t{\r\n\t\tUSL_IsInRect(CursorX,CursorY,&ini,&inn);\r\n\t\tinside = (ini == hiti) && (inn == hitn);\r\n\t\tif (inside != last)\r\n\t\t{\r\n\t\t\tif (inside)\r\n\t\t\t{\r\n\t\t\t\tif (op)\r\n\t\t\t\t{\r\n\t\t\t\t\top->sel &= ~ui_Selected;\r\n\t\t\t\t\tip->sel |= ui_Selected;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tip->sel = sel ^ ui_Selected;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (op && (op != ip))\r\n\t\t\t\t{\r\n\t\t\t\t\top->sel |= ui_Selected;\r\n\t\t\t\t\tip->sel &= ~ui_Selected;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tip->sel = sel;\r\n\t\t\t}\r\n\r\n\t\t\tUSL_DrawItem(hiti,hitn);\r\n\t\t\tif (op && (op != ip))\r\n\t\t\t\tUSL_DrawItem(hiti,on);\r\n\r\n\t\t\tlast = inside;\r\n\t\t}\r\n\t\tVW_UpdateScreen();\r\n\t} while (US_UpdateCursor());\r\n\r\n\tif (op)\r\n\t\top->sel = othersel;\r\n\tip->sel = sel;\r\n\tif (!inside)\r\n\t{\r\n\t\tif (op && (op != ip))\r\n\t\t\tUSL_DrawItem(hiti,on);\r\n\t\tUSL_DrawItem(hiti,hitn);\r\n\t\tVW_UpdateScreen();\r\n\t}\r\n\r\n\treturn(inside);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_GlideCursor() - Smoothly moves the cursor to the given location\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_GlideCursor(long newx,long newy)\r\n{\r\n\tword\tsteps;\r\n\tlong\tx,y,\r\n\t\t\tdx,dy;\r\n\r\n\tif (grmode == CGAGR)\r\n\t\tsteps = 1;\r\n\telse\r\n\t\tsteps = 8;\r\n\r\n\tx = (long)CursorX << 16;\r\n\tdx = ((newx << 16) - x) / steps;\r\n\ty = (long)CursorY << 16;\r\n\tdy = ((newy << 16) - y) / steps;\r\n\r\n\twhile ((CursorX != newx) || (CursorY != newy))\r\n\t{\r\n\t\tx += dx;\r\n\t\ty += dy;\r\n\r\n\t\tCursorX = x >> 16;\r\n\t\tCursorY = y >> 16;\r\n\t\tVW_MoveCursor(CursorX,CursorY);\r\n\t\tVW_UpdateScreen();\r\n\t}\r\n\tCursorBad = true;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_FindRect() - Code so ugly you'll puke! Given a Rect and direction,\r\n//      this routine will try to find a UserItem to move the cursor to\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_FindRect(Rect r,Motion xd,Motion yd)\r\n{\r\n\tword\t\ti,i1,i2,i3;\r\n\tMotion\t\tm1,m2;\r\n\tPoint\t\tdiffs[9],diff,*dp;\r\n\tRect\t\t*rp,*good,*goods[9];\r\n\tUserItem\t*ip,**items;\r\n\r\n\tfor (m1 = motion_Up,dp = diffs;m1 <= motion_Down;m1++)\r\n\t{\r\n\t\tfor (m2 = motion_Left;m2 <= motion_Right;m2++,dp++)\r\n\t\t{\r\n\t\t\tdp->x = m2 * 1024;\r\n\t\t\tdp->y = m1 * 1024;\r\n\t\t}\r\n\t}\r\n\tfor (i = 0;i < 9;i++)\r\n\t\tgoods[i] = nil;\r\n\r\n\t// Find out which octants all of the rects (except r) are in\r\n\tfor (items = TheItems;*items;items++)\r\n\t{\r\n\t\tfor (ip = *items;ip->type != uii_Bad;ip++)\r\n\t\t{\r\n\t\t\trp = &ip->r;\r\n\t\t\tdiff.x = rp->ul.x - r.ul.x;\r\n\t\t\tdiff.y = rp->ul.y - r.ul.y;\r\n\t\t\tif (!(diff.x || diff.y))\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\tif\t// 1,4,7\r\n\t\t\t(\r\n\t\t\t\t((rp->ul.x >= r.ul.x) && (rp->ul.x < r.lr.x))\r\n\t\t\t||\t((rp->lr.x > r.ul.x) && (rp->lr.x <= r.lr.x))\r\n\t\t\t)\r\n\t\t\t{\r\n\t\t\t\tif (rp->lr.y <= r.ul.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!(goods[1] && (diff.y < diffs[1].y)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[1] = rp;\r\n\t\t\t\t\t\tdiffs[1] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (rp->ul.y >= r.lr.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!(goods[7] && (diff.y > diffs[7].y)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[7] = rp;\r\n\t\t\t\t\t\tdiffs[7] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif\t// 3,4,5\r\n\t\t\t(\r\n\t\t\t\t((rp->ul.y >= r.ul.y) && (rp->ul.y < r.lr.y))\r\n\t\t\t||\t((rp->lr.y > r.ul.y) && (rp->lr.y <= r.lr.y))\r\n\t\t\t)\r\n\t\t\t{\r\n\t\t\t\tif (rp->lr.x <= r.ul.x)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!(goods[3] && (diff.x < diffs[3].x)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[3] = rp;\r\n\t\t\t\t\t\tdiffs[3] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (rp->ul.x >= r.lr.x)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (!(goods[5] && (diff.x > diffs[5].x)))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[5] = rp;\r\n\t\t\t\t\t\tdiffs[5] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rp->ul.x < r.ul.x)\t// 0,6\r\n\t\t\t{\r\n\t\t\t\tif (rp->lr.y <= r.ul.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tif\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(!goods[0])\r\n\t\t\t\t\t|| \t(diff.y > diffs[0].y)\r\n\t\t\t\t\t||\t(diff.x > diffs[6].x)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[0] = rp;\r\n\t\t\t\t\t\tdiffs[0] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (rp->ul.y >= r.lr.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tif\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(!goods[6])\r\n\t\t\t\t\t|| \t(diff.y < diffs[6].y)\r\n\t\t\t\t\t||\t(diff.x > diffs[6].x)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[6] = rp;\r\n\t\t\t\t\t\tdiffs[6] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (rp->lr.x > r.lr.x)\t// 2,8\r\n\t\t\t{\r\n\t\t\t\tif (rp->lr.y <= r.ul.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tif\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(!goods[2])\r\n\t\t\t\t\t|| \t(diff.y > diffs[2].y)\r\n\t\t\t\t\t|| \t(diff.x < diffs[2].x)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[2] = rp;\r\n\t\t\t\t\t\tdiffs[2] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (rp->ul.y >= r.lr.y)\r\n\t\t\t\t{\r\n\t\t\t\t\tif\r\n\t\t\t\t\t(\r\n\t\t\t\t\t\t(!goods[8])\r\n\t\t\t\t\t|| \t(diff.y < diffs[8].y)\r\n\t\t\t\t\t||\t(diff.x < diffs[8].x)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgoods[8] = rp;\r\n\t\t\t\t\t\tdiffs[8] = diff;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tswitch (yd)\r\n\t{\r\n\tcase motion_Up:\r\n\t\ti1 = 1,i2 = 0,i3 = 2;\r\n\t\tbreak;\r\n\tcase motion_None:\r\n\t\tswitch (xd)\r\n\t\t{\r\n\t\tcase motion_Left:\r\n\t\t\ti1 = 3,i2 = 0,i3 = 6;\r\n\t\t\tbreak;\r\n\t\tcase motion_Right:\r\n\t\t\ti1 = 5,i2 = 8,i3 = 2;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase motion_Down:\r\n\t\ti1 = 7,i2 = 8,i3 = 6;\r\n\t\tbreak;\r\n\t}\r\n\r\n\t(\r\n\t\t(good = goods[i1])\r\n\t|| \t(good = goods[i2])\r\n\t|| \t(good = goods[i3])\r\n\t|| \t(good = &r)\r\n\t);\r\n#if 0\r\n\tCursorX = good->lr.x - 8;\r\n\tCursorY = good->lr.y - 8;\r\n\tCursorBad = true;\r\n\tUS_UpdateCursor();\r\n#endif\r\n\tUSL_GlideCursor(good->lr.x - 8,good->lr.y - 8);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlButtonCustom() - The custom routine for all of the Control Panel\r\n//\t\t(leftmost) buttons. Clears all of the other item lists, clears the\r\n//\t\tlarge area, and draws the line dividing the top and bottom areas.\r\n//\t\tThen it sets up and draws the appropriate top row of icons.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tword\t\tj;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tif (n == CtlPanelButton)\r\n\t\treturn(true);\r\n\r\n\tUS_ClearWindow();\r\n\tfor (j = 8;j < 38;j++)\r\n\t{\r\n\t\tVWB_DrawTile8M(j * 8,6 * 8,10);\r\n\t\tVWB_DrawTile8M(j * 8,21 * 8,10);\r\n\t}\r\n\tVWB_DrawTile8M(7 * 8,6 * 8,9);\r\n\tVWB_DrawTile8M(38 * 8,6 * 8,11);\r\n\tVWB_DrawTile8M(7 * 8,21 * 8,9);\r\n\tVWB_DrawTile8M(38 * 8,21 * 8,11);\r\n\r\n\tfor (j = 1;j < 4;j++)\r\n\t\tTheItems[j] = nil;\r\n\r\n\t// Set to new button\r\n\tCtlPanelButton = n;\r\n\r\n\t// Draw new items\r\n\tTheItems[1] = ip = CtlPanels2[CtlPanelButton];\r\n\tj = 0;\r\n\twhile (ip && (ip->type != uii_Bad))\r\n\t{\r\n\t\tUSL_DrawItem(i + 1,j);\r\n\t\tif (ip->sel & ui_Selected)\r\n\t\t\tUSL_DoHit(i + 1,j);\r\n\t\tj++;\r\n\t\tip++;\r\n\t}\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlCKbdButtonCustom() - The custom routine for the keyboard keycaps.\r\n//\t\tThis routine gets a scancode and puts it in the appropriate\r\n//\t\tKbdDefs[0] member.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlCKbdButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tboolean\t\tstate;\r\n\tword\t\tj;\r\n\tScanCode\tscan;\r\n\tlongword\ttime;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tip = &TheItems[i][n];\r\n\r\n\tfontcolor = F_SECONDCOLOR;\r\n\tUSL_ShowHelp(ip->help);\r\n\tfontcolor = F_BLACK;\r\n\tVW_HideCursor();\r\n\tVWB_DrawPic(ip->r.ul.x,ip->r.ul.y,ip->picdown);\r\n\tVW_UpdateScreen();\r\n\r\n\tLastScan = sc_None;\r\n\ttime = TimeCount;\r\n\tstate = true;\r\n\tdo\r\n\t{\r\n\t\tif (TimeCount - time > 35)\t// Half-second delays\r\n\t\t{\r\n\t\t\tstate ^= true;\r\n\t\t\tVWB_DrawPic(ip->r.ul.x,ip->r.ul.y,state? ip->picdown : ip->picup);\r\n\t\t\tVW_UpdateScreen();\r\n\t\t\ttime = TimeCount;\r\n\t\t}\r\n\t\tif (US_UpdateCursor())\r\n\t\t{\r\n\t\t\twhile (US_UpdateCursor())\r\n\t\t\t\t;\r\n\t\t\tscan = sc_Escape;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tasm\tpushf\r\n\t\tasm\tcli\r\n\t\tif (LastScan == sc_LShift)\r\n\t\t\tLastScan = sc_None;\r\n\t\tasm\tpopf\r\n\t} while (!(scan = LastScan));\r\n\tIN_ClearKey(scan);\r\n\tif (scan != sc_Escape)\r\n\t{\r\n\t\tfor (j = 0,state = false;j < 10;j++)\r\n\t\t{\r\n\t\t\tif (j == n)\r\n\t\t\t\tcontinue;\r\n\t\t\tif (*(KeyMaps[j]) == scan)\r\n\t\t\t{\r\n\t\t\t\tstate = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (state)\r\n\t\t{\r\n\t\t\tfontcolor = F_SECONDCOLOR;\r\n\t\t\tUSL_ShowHelp(\"That Key is Already Used!\");\r\n\t\t\tfontcolor = F_BLACK;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tip->text = IN_GetScanName(scan);\r\n\t\t\t*(KeyMaps[n]) = scan;\r\n\t\t\tFlushHelp = true;\r\n\t\t}\r\n\t}\r\n\r\n\tUSL_DrawItem(i,n);\r\n\tVW_ShowCursor();\r\n\tVW_UpdateScreen();\r\n\r\n\treturn(true);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlCJoyButtonCustom() - The custom button routine for joystick\r\n//\t\tcalibration\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlCJoyButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tboolean Done = false;\r\n\tword\tjoy,\r\n\t\t\tminx,maxx,\r\n\t\t\tminy,maxy;\r\n\r\n\ti++,n++;\t// Shut the compiler up\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tIN_ClearKeysDown();\r\n\tjoy = USL_FindDown(CtlCPanels) - 1;\r\n\r\n\tVW_HideCursor();\r\n\tFlushHelp = true;\r\n\tfontcolor = F_SECONDCOLOR;\r\n\r\n\r\n\twhile (!(Done))\r\n\t{\r\n\t\tUSL_ShowHelp(\"Move Joystick to the Upper-Left\");\r\n\t\tVW_UpdateScreen();\r\n\t\twhile ((LastScan != sc_Escape) && !IN_GetJoyButtonsDB(joy));\r\n\r\n\t\tif (LastScan != sc_Escape)\r\n\t\t{\r\n\t\t\tIN_GetJoyAbs(joy,&minx,&miny);\r\n\t\t\twhile (IN_GetJoyButtonsDB(joy));\r\n\r\n\t\t\tUSL_ShowHelp(\"Move Joystick to the Lower-Right\");\r\n\t\t\tVW_UpdateScreen();\r\n\t\t\twhile ((LastScan != sc_Escape) && !IN_GetJoyButtonsDB(joy));\r\n\r\n\t\t\tif (LastScan != sc_Escape)\r\n\t\t\t{\r\n\t\t\t\tIN_GetJoyAbs(0,&maxx,&maxy);\r\n\r\n\t\t\t\tif ((maxx != minx) && (maxy != miny))\r\n\t\t\t\t{\r\n\t\t\t\t\tDone = true;\r\n\t\t\t\t\tIN_SetupJoy(joy,minx,maxx,miny,maxy);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\twhile (IN_GetJoyButtonsDB(joy));\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tDone = true;\r\n\t\t}\r\n\t\telse\r\n\t\t\tDone = true;\r\n\t}\r\n\r\n\r\n\tif (LastScan != sc_Escape)\r\n\t\twhile (IN_GetJoyButtonsDB(joy))\r\n\t\t\t;\r\n\r\n\tif (LastScan)\r\n\t\tIN_ClearKeysDown();\r\n\r\n\tfontcolor = F_BLACK;\r\n\tVW_ShowCursor();\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_ClearBottom() - Clears the bottom part of the window\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_ClearBottom(void)\r\n{\r\n\tWindowRec\twr;\r\n\r\n\tUS_SaveWindow(&wr);\r\n\tUS_RestoreWindow(&BottomWindow);\r\n\r\n\tUS_ClearWindow();\r\n\r\n\tUS_RestoreWindow(&wr);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_FormatHelp() - Formats helptext. Runs through and calculates the\r\n//\t\tnumber of lines, and the offset for the start of each line. Stops\r\n//\t\tafter len bytes or when it hits a tilde ('~'). Munges the text.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic word\r\nUSL_FormatHelp(char far *text,long len)\r\n{\r\n\tword\tline,\r\n\t\t\tw,h,\r\n\t\t\tfar *off;\r\n\tchar\tc,\r\n\t\t\tfar *s,far *l,far *le;\r\n\r\n\tWindowX += 4;\r\n\tWindowW -= 4;\r\n\r\n\tMM_GetPtr(&LineOffsets,MaxHelpLines * sizeof(word));\r\n\toff = (word far *)LineOffsets;\r\n\tfor (line = 0,le = l = s = text;(s - text < len) && (*s != '~');s++)\r\n\t{\r\n\t\tif ((c = *s) == '\\n')\r\n\t\t{\r\n\t\t\t*s = '\\0';\r\n\t\t\t*off++ = l - text;\t// Save offset of start of line\r\n\t\t\tline++;\t\t\t\t// Bump line number\r\n\t\t\tle = l = s + 1;\t\t// Set start of line ptr\r\n\t\t}\r\n\r\n\t\tif (c == '\\r')\r\n\t\t\tc = *s = ' ';\r\n\t\tif\t\t\t\t\t\t// Strip orphaned spaces\r\n\t\t(\r\n\t\t\t(c == ' ')\r\n\t\t&& \t(s == l)\r\n\t\t&& \t(*(s - 1) == '\\0')\r\n\t\t&&\t(*(s + 1) != ' ')\r\n\t\t&& \t(s > text)\r\n\t\t)\r\n\t\t\tle = l = s + 1;\r\n\t\telse if (c == ' ')\r\n\t\t{\r\n\t\t\t*s = '\\0';\r\n\t\t\tUSL_MeasureString(l,&w,&h);\r\n\t\t\tif (w >= WindowW)\t// If string width exceeds window,\r\n\t\t\t{\r\n\t\t\t\t*s = c;\t\t\t// Replace null char with proper char\r\n\t\t\t\t*le = '\\0';\t\t// Go back to last line end\r\n\t\t\t\t*off++ = l - text;\t// Save offset of start of line\r\n\t\t\t\tline++;\t\t\t// Bump line number\r\n\t\t\t\tl = s = le + 1;\t// Start next time through after last line end\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t*s = c;\t\t\t// Width still ok - put char back\r\n\t\t\t\tle = s;\t\t\t// And save ptr to last ok end of word\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tWindowX -= 4;\r\n\tWindowW += 4;\r\n\r\n\treturn(line);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_DrawHelp() - Draws helptext in the current window\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_DrawHelp(char far *text,word start,word end,word line,word h,word far *lp)\r\n{\r\n\tpx = WindowX + 4;\r\n\tpy = WindowY + (line * h);\r\n\tfor (lp += start;start < end;start++,px = WindowX + 4,py += h)\r\n\t\tUSL_DrawString(text + *lp++);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_DoHelp() - Formats and displays the specified help\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_DoHelp(memptr text,long len)\r\n{\r\n\tboolean\t\tdone,\r\n\t\t\t\tmoved;\r\n\tint\t\t\tscroll;\r\n\tword\t\ti,\r\n\t\t\t\tpixdiv,\r\n\t\t\t\tw,h,\r\n\t\t\t\tlines,cur,page,\r\n\t\t\t\ttop,num,loc,\r\n\t\t\t\tfar *lp,\r\n\t\t\t\tbase,srcbase,destbase;\r\n\tScanCode\twaitkey;\r\n\tlongword\tlasttime;\r\n\tWindowRec\twr;\r\n\tCursorInfo\tinfo;\r\n\r\n\tUSL_ShowHelp(\"Arrow Keys Move / Escape Exits\");\r\n\tfontcolor = F_BLACK;\r\n\r\n\tUS_SaveWindow(&wr);\r\n\tUS_RestoreWindow(&BottomWindow);\r\n\tUS_ClearWindow();\r\n\r\n\tVW_HideCursor();\r\n\tVW_UpdateScreen();\r\n\r\n\tlines = USL_FormatHelp((char far *)text,len);\r\n\tUSL_MeasureString(\"\",&w,&h);\r\n\tpage = WindowH / h;\r\n\tcur = 0;\r\n\tlp = LineOffsets;\r\n\r\n\tIN_ClearKeysDown();\r\n\tmoved = true;\r\n\tlasttime = 0;\r\n\tscroll = 0;\r\n\tdone = false;\r\n\twaitkey = sc_None;\r\n\twhile (!done)\r\n\t{\r\n\t\tif (moved)\r\n\t\t{\r\n\t\t\twhile (TimeCount - lasttime < 5)\r\n\t\t\t\t;\r\n\t\t\tlasttime = TimeCount;\r\n\r\n\t\t\tif (scroll == -1)\r\n\t\t\t{\r\n\t\t\t\ttop = cur;\r\n\t\t\t\tnum = 1;\r\n\t\t\t\tloc = 0;\r\n\t\t\t}\r\n\t\t\telse if (scroll == +1)\r\n\t\t\t{\r\n\t\t\t\tnum = 1;\r\n\t\t\t\tloc = page - 1;\r\n\t\t\t\ttop = cur + loc;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\ttop = cur;\r\n\t\t\t\tnum = (page < lines)? page : lines;\r\n\t\t\t\tloc = 0;\r\n\t\t\t}\r\n\t\t\tif (scroll)\r\n\t\t\t{\r\n\t\t\t\tif (grmode == CGAGR)\r\n\t\t\t\t{\r\n\t\t\t\t\tpixdiv = 4;\r\n\t\t\t\t\tbase = bufferofs + panadjust + (WindowX / pixdiv);\r\n\t\t\t\t}\r\n\t\t\t\telse if (grmode == EGAGR)\r\n\t\t\t\t{\r\n\t\t\t\t\tVWB_Bar(WindowX,WindowY + (loc * h),WindowW,num * h,WHITE);\r\n\t\t\t\t\tUSL_DrawHelp((char far *)text,top,top + num,loc,h,lp);\r\n\r\n\t\t\t\t\tpixdiv = 8;\r\n\t\t\t\t\tbase = displayofs + panadjust + (WindowX / pixdiv);\r\n\t\t\t\t}\r\n\t\t\t\telse if (grmode == VGAGR)\r\n\t\t\t\t\tpixdiv = 1;\r\n\r\n\t\t\t\tif (scroll == 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tsrcbase = base + ylookup[WindowY + h];\r\n\t\t\t\t\tdestbase = base + ylookup[WindowY];\r\n\t\t\t\t\tif (grmode == EGAGR)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tEGAWRITEMODE(1);\r\n\t\t\t\t\t\tVW_WaitVBL(1);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tVW_ScreenToScreen(srcbase,destbase,WindowW / pixdiv,\r\n\t\t\t\t\t\t\t\t\t\tWindowH - h);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ti = WindowY + (h * (page - 1));\r\n\t\t\t\t\tsrcbase = base + ylookup[i - h];\r\n\t\t\t\t\tdestbase = base + ylookup[i];\r\n\t\t\t\t\tbase = ylookup[h];\r\n\t\t\t\t\tfor (i = page - 1;i;i--,srcbase -= base,destbase -= base)\r\n\t\t\t\t\t\tVW_ScreenToScreen(srcbase,destbase,WindowW / pixdiv,h);\r\n\t\t\t\t}\r\n\t\t\t\tif (grmode == CGAGR)\r\n\t\t\t\t{\r\n\t\t\t\t\tVWB_Bar(WindowX,WindowY + (loc * h),WindowW,num * h,WHITE);\r\n\t\t\t\t\tUSL_DrawHelp((char far *)text,top,top + num,loc,h,lp);\r\n\t\t\t\t\tVW_UpdateScreen();\r\n\t\t\t\t}\r\n\t\t\t\telse if (grmode == EGAGR)\r\n\t\t\t\t{\r\n\t\t\t\t\tbase = panadjust + (WindowX / pixdiv) +\r\n\t\t\t\t\t\t\tylookup[WindowY + (loc * h)];\r\n\t\t\t\t\tVW_ScreenToScreen(base + bufferofs,base + displayofs,\r\n\t\t\t\t\t\t\t\t\t\tWindowW / pixdiv,h);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tUS_ClearWindow();\r\n\t\t\t\tUSL_DrawHelp((char far *)text,top,top + num,loc,h,lp);\r\n\t\t\t\tVW_UpdateScreen();\r\n\t\t\t}\r\n\r\n\t\t\tmoved = false;\r\n\t\t\tscroll = 0;\r\n\t\t}\r\n\r\n\t\tif (waitkey)\r\n\t\t\twhile (IN_KeyDown(waitkey))\r\n\t\t\t\t;\r\n\t\twaitkey = sc_None;\r\n\r\n\t\tIN_ReadCursor(&info);\r\n\t\tif (info.y < 0)\r\n\t\t{\r\n\t\t\tif (cur > 0)\r\n\t\t\t{\r\n\t\t\t\tscroll = -1;\r\n\t\t\t\tcur--;\r\n\t\t\t\tmoved = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (info.y > 0)\r\n\t\t{\r\n\t\t\tif (cur + page < lines)\r\n\t\t\t{\r\n\t\t\t\tscroll = +1;\r\n\t\t\t\tcur++;\r\n\t\t\t\tmoved = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (info.button0 || info.button1)\r\n\t\t\tdone = true;\r\n\t\telse if (IN_KeyDown(LastScan))\r\n\t\t{\r\n\t\t\tswitch (LastScan)\r\n\t\t\t{\r\n\t\t\tcase sc_Escape:\r\n\t\t\t\tdone = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_UpArrow:\r\n\t\t\t\tif (cur > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tscroll = -1;\r\n\t\t\t\t\tcur--;\r\n\t\t\t\t\tmoved = true;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_DownArrow:\r\n\t\t\t\tif (cur + page < lines)\r\n\t\t\t\t{\r\n\t\t\t\t\tscroll = +1;\r\n\t\t\t\t\tcur++;\r\n\t\t\t\t\tmoved = true;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_PgUp:\r\n\t\t\t\tif (cur > page)\r\n\t\t\t\t\tcur -= page;\r\n\t\t\t\telse\r\n\t\t\t\t\tcur = 0;\r\n\t\t\t\tmoved = true;\r\n\t\t\t\twaitkey = sc_PgUp;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_PgDn:\r\n\t\t\t\tif (cur + page < lines)\r\n\t\t\t\t{\r\n\t\t\t\t\tcur += page;\r\n\t\t\t\t\tif (cur + page >= lines)\r\n\t\t\t\t\t\tcur = lines - page;\r\n\t\t\t\t\tmoved = true;\r\n\t\t\t\t}\r\n\t\t\t\twaitkey = sc_PgDn;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tIN_ClearKeysDown();\r\n\tdo\r\n\t{\r\n\t\tIN_ReadCursor(&info);\r\n\t} while (info.button0 || info.button1);\r\n\r\n\tVW_ShowCursor();\r\n\tUS_ClearWindow();\r\n\tVW_UpdateScreen();\r\n\tUS_RestoreWindow(&wr);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlHButtonCustom() - The custom routine for all of the help buttons\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlHButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tword\t\tj;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tip = &TheItems[i][n];\r\n\tif (ip->sel & ui_Disabled)\r\n\t\treturn(false);\r\n\r\n\tip->sel |= ui_Selected;\r\n\tUSL_DrawItem(i,n);\r\n\r\n\tUSL_ClearBottom();\r\n\r\n\tfontcolor = F_SECONDCOLOR;\r\n\tUSL_ShowHelp(\"Loading & Formatting Text...\");\r\n\tVW_UpdateScreen();\r\n\r\n#ifdef\tHELPTEXTLINKED\t// Ugly hack because of lack of disk space...\r\n\t{\r\nextern\tchar\tfar gametext,far context,far story;\r\n\t\tchar\tfar *buf;\r\n\t\tmemptr\tdupe;\r\n\r\n\t\tswitch (n)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tbuf = &gametext;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tbuf = &context;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tbuf = &story;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tMM_GetPtr(&dupe,5600);\r\n\t\t_fmemcpy((char far *)dupe,buf,5600);\r\n\r\n\t\tUSL_DoHelp(dupe,5600);\r\n\r\n\t\tMM_FreePtr(&dupe);\r\n\t\tif (LineOffsets)\r\n\t\t\tMM_FreePtr(&LineOffsets);\r\n\t}\r\n#else\r\n\t{\r\n\t\tchar\t*name;\r\n\t\tint\t\tfile;\r\n\t\tlong\tlen;\r\n\t\tmemptr\tbuf;\r\n\r\n\t\tswitch (n)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tname = \"GAMETEXT.\"EXTENSION;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tname = \"CONTEXT.\"EXTENSION;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tname = \"STORY.\"EXTENSION;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tQuit(\"Bad help button number\");\r\n\t\t}\r\n\r\n\t\tif ((file = open(name,O_RDONLY | O_TEXT)) == -1)\r\n\t\t\tUSL_HandleError(errno);\r\n\t\telse\r\n\t\t{\r\n\t\t\tlen = filelength(file);\r\n\t\t\tMM_GetPtr(&buf,len);\r\n\r\n\t\t\tif (CA_FarRead(file,(byte far *)buf,len))\r\n\t\t\t\tUSL_DoHelp(buf,len);\r\n\t\t\telse\r\n\t\t\t\tUSL_HandleError(errno);\r\n\r\n\t\t\tclose(file);\r\n\t\t\tMM_FreePtr(&buf);\r\n\t\t}\r\n\r\n\t\tif (LineOffsets)\r\n\t\t\tMM_FreePtr(&LineOffsets);\r\n\t}\r\n#endif\r\n\r\n\tfontcolor = F_BLACK;\r\n\r\n\tip->sel &= ~ui_Selected;\r\n\tUSL_DrawItem(i,n);\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlDButtonCustom() - The custom routine for all of the disk buttons.\r\n//\t\tSets up the bottom area of the window with the appropriate buttons\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlDButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tword\t\tj;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tip = &TheItems[i][n];\r\n\tif (ip->sel & ui_Disabled)\r\n\t\treturn(false);\r\n\r\n\tUSL_ClearBottom();\r\n\r\n\tj = 0;\r\n\tTheItems[i + 1] = ip = n? CtlDEPanels : CtlDLSPanels;\r\n\twhile (ip && (ip->type != uii_Bad))\r\n\t{\r\n\t\tUSL_DrawItem(i + 1,j++);\r\n\t\tip++;\r\n\t}\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_DLSRect() - Draw the rectangle for the save game names\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic Rect\r\nUSL_DLSRect(UserItem *ip)\r\n{\r\n\tRect\tr;\r\n\r\n\tr.ul.x = ip->r.lr.x + 40 + 2;\r\n\tr.ul.y = ip->r.ul.y + 2;\r\n\tr.lr.x = WindowX + WindowW - 8 - 2;\r\n\tr.lr.y = ip->r.lr.y - 2;\r\n\r\n\tVWB_Bar(r.ul.x,r.ul.y,r.lr.x - r.ul.x,r.lr.y - r.ul.y,WHITE);\r\n\r\n\tVWB_Hlin(r.ul.x,r.lr.x,r.ul.y,BLACK);\r\n\tVWB_Hlin(r.ul.x,r.lr.x,r.lr.y,BLACK);\r\n\tVWB_Vlin(r.ul.y,r.lr.y,r.ul.x,BLACK);\r\n\tVWB_Vlin(r.ul.y,r.lr.y,r.lr.x,BLACK);\r\n\r\n\tpx = r.ul.x + 2;\r\n\tpy = r.ul.y + 2;\r\n\r\n\treturn(r);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlDLButtonCustom() - The load game custom routine\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlDLButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tchar\t\t*filename,\r\n\t\t\t\tmsg[MaxGameName + 12];\r\n\tword\t\terr;\r\n\tint\t\t\tfile;\r\n\tUserItem\t*ip;\r\n\tSaveGame\t*game;\r\n\tWindowRec \twr;\r\n\r\n\t// DEBUG - deal with warning user about loading a game causing abort\r\n\r\n\tgame = &Games[n / 2];\r\n\tip = &TheItems[i][n];\r\n\r\n\tswitch (call)\r\n\t{\r\n\tcase uic_Draw:\r\n\t\tif (!loadedgame)\r\n\t\t{\r\n\t\t\tUSL_DLSRect(ip);\r\n\t\t\tfontcolor = game->present? F_BLACK : F_FIRSTCOLOR;\r\n\t\t\tUSL_DrawString(game->present? game->name : \"Empty\");\r\n\t\t\tfontcolor = F_BLACK;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase uic_Hit:\r\n\t\tif (ip->sel & ui_Disabled)\r\n\t\t\treturn(false);\r\n\r\n\t\tLeaveDriveOn++;\r\n\t\tfilename = USL_GiveSaveName(n / 2);\r\n\r\n\t\tUS_SaveWindow(&wr);\r\n\t\tUS_CenterWindow(30,3);\r\n\t\tstrcpy(msg,\"Loading `\");\r\n\t\tstrcat(msg,game->name);\r\n\t\tstrcat(msg,\"\\'\");\r\n\t\tUS_PrintCentered(msg);\r\n\t\tVW_HideCursor();\r\n\t\tVW_UpdateScreen();\r\n\r\n\t\terr = 0;\r\n\t\tif ((file = open(filename,O_BINARY | O_RDONLY)) != -1)\r\n\t\t{\r\n\t\t\tif (read(file,game,sizeof(*game)) == sizeof(*game))\r\n\t\t\t{\r\n\t\t\t\tif (USL_LoadGame)\r\n\t\t\t\t\tif (!USL_LoadGame(file))\r\n\t\t\t\t\t\tUSL_HandleError(err = errno);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tUSL_HandleError(err = errno);\r\n\t\t\tclose(file);\r\n\t\t}\r\n\t\telse\r\n\t\t\tUSL_HandleError(err = errno);\r\n\t\tif (err)\r\n\t\t\tabortgame = true;\r\n\t\telse\r\n\t\t\tloadedgame = true;\r\n\t\tgame->present = true;\r\n\r\n\t\tif (loadedgame)\r\n\t\t\tPaused = true;\r\n\r\n\t\tVW_ShowCursor();\r\n\t\tUS_RestoreWindow(&wr);\r\n\r\n\t\tLeaveDriveOn--;\r\n\t\tbreak;\r\n\t}\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlDSButtonCustom() - The save game custom routine\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlDSButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tboolean\t\tok;\r\n\tchar\t\t*filename;\r\n\tword\t\terr;\r\n\tint\t\t\tfile;\r\n\tRect\t\tr;\r\n\tUserItem\t*ip;\r\n\tSaveGame\t*game;\r\n\tWindowRec\twr;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tgame = &Games[n / 2];\r\n\tip = &TheItems[i][n];\r\n\tif (ip->sel & ui_Disabled)\r\n\t\treturn(false);\r\n\r\n\tFlushHelp = true;\r\n\tfontcolor = F_SECONDCOLOR;\r\n\tUSL_ShowHelp(\"Enter Game Name / Escape Aborts\");\r\n\tfontcolor = F_BLACK;\r\n\r\n\tr = USL_DLSRect(ip - 1);\r\n\tok = US_LineInput(px,py,game->name,game->present? game->name : nil,true,\r\n\t\t\t\t\t\tMaxGameName,r.lr.x - r.ul.x - 8);\r\n\tif (!strlen(game->name))\r\n\t\tstrcpy(game->name,\"Untitled\");\r\n\tif (ok)\r\n\t{\r\n\t\tUS_SaveWindow(&wr);\r\n\t\tUS_CenterWindow(10,3);\r\n\t\tUS_PrintCentered(\"Saving\");\r\n\t\tVW_HideCursor();\r\n\t\tVW_UpdateScreen();\r\n\r\n\t\tLeaveDriveOn++;\r\n\t\tfilename = USL_GiveSaveName(n / 2);\r\n\t\terr = 0;\r\n\t\tfile = open(filename,O_CREAT | O_BINARY | O_WRONLY,\r\n\t\t\t\t\tS_IREAD | S_IWRITE | S_IFREG);\r\n\t\tif (file != -1)\r\n\t\t{\r\n\t\t\tif (write(file,game,sizeof(*game)) == sizeof(*game))\r\n\t\t\t{\r\n\t\t\t\tif (USL_SaveGame)\r\n\t\t\t\t\tok = USL_SaveGame(file);\r\n\t\t\t\tif (!ok)\r\n\t\t\t\t\tUSL_HandleError(err = errno);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tUSL_HandleError(err = ((errno == ENOENT)? ENOMEM : errno));\r\n\t\t\tclose(file);\r\n\t\t}\r\n\t\telse\r\n\t\t\tUSL_HandleError(err = ((errno == ENOENT)? ENOMEM : errno));\r\n\t\tif (err)\r\n\t\t{\r\n\t\t\tremove(filename);\r\n\t\t\tok = false;\r\n\t\t}\r\n\t\tLeaveDriveOn--;\r\n\r\n\t\tVW_ShowCursor();\r\n\t\tUS_RestoreWindow(&wr);\r\n\t\tUSL_DoHit(i - 1,0);\r\n\t\tVW_UpdateScreen();\r\n\t}\r\n\r\n\tif (!game->present)\r\n\t\tgame->present = ok;\r\n\r\n\tif (ok)\r\n\t{\r\n\t\tGameIsDirty = false;\r\n\t\t(ip - 1)->sel &= ~ui_Disabled;\r\n\t}\r\n\r\n\tUSL_DrawItem(i,n - 1);\r\n//\tUSL_CtlDLButtonCustom(uic_Draw,i,n - 1);\r\n\r\n\treturn(true);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlSButtonCustom() - The custom routine for all of the sound buttons\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlSButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tword\t\tj;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tip = &TheItems[i][n];\r\n\tif (ip->sel & ui_Disabled)\r\n\t\treturn(false);\r\n\r\n\tUSL_ClearBottom();\r\n\r\n\tif (n == sdm_SoundSource)\r\n\t{\r\n\t\tj = 0;\r\n\t\tTheItems[i + 1] = ip = CtlSSSPanels;\r\n\t\twhile (ip && (ip->type != uii_Bad))\r\n\t\t{\r\n\t\t\tUSL_DrawItem(i + 1,j++);\r\n\t\t\tip++;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\tTheItems[i + 1] = nil;\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlPButtonCustom() - The custom routine for all of the start game btns\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlPButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tword\t\tj;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tip = &TheItems[i][n];\r\n\tif (ip->sel & ui_Disabled)\r\n\t\treturn(false);\r\n\r\n\tUSL_ClearBottom();\r\n\r\n\tj = 0;\r\n\tTheItems[i + 1] = ip = n? CtlPRPanels : CtlPSPanels;\r\n\twhile (ip && (ip->type != uii_Bad))\r\n\t{\r\n\t\tUSL_DrawItem(i + 1,j++);\r\n\t\tip++;\r\n\t}\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_GiveAbortWarning() - Draws a string that warns the user that an\r\n//\t\taction they're about to take will abort the game in progress\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_GiveAbortWarning(void)\r\n{\r\n\tWindowRec\twr;\r\n\r\n\tif (!GameIsDirty)\r\n\t\treturn;\r\n\r\n\tUS_SaveWindow(&wr);\r\n\tUS_RestoreWindow(&BottomWindow);\r\n\tUS_HomeWindow();\r\n\tPrintY += 5;\r\n\r\n\tVWB_Bar(WindowX,WindowY,WindowW,30,WHITE);\r\n\tfontcolor = F_SECONDCOLOR;\r\n\tUS_CPrint(\"Warning! If you do this, you'll\");\r\n\tUS_CPrint(\"abort the current game.\");\r\n\tfontcolor = F_BLACK;\r\n\r\n\tUS_RestoreWindow(&wr);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlPSButtonCustom() - The custom routine for the start game button\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlPSButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tboolean\t\tresult;\r\n\tUserItem\t*ip;\r\n\r\n\ti++;\t// Shut the compiler up\r\n\r\n\tswitch (call)\r\n\t{\r\n\tcase uic_Hit:\r\n\t\tswitch (n)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\trestartgame = gd_Normal;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\trestartgame = gd_Easy;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\trestartgame = gd_Hard;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tif (restartgame && ingame && USL_ResetGame)\r\n\t\t\tUSL_ResetGame();\r\n\t\tresult = false;\r\n\t\tbreak;\r\n\tcase uic_Draw:\r\n\t\tUSL_GiveAbortWarning();\r\n\t\tresult = false;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tresult = false;\r\n\t\tbreak;\r\n\t}\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlPRButtonCustom() - The custom routine for the resume game button\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlPRButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\ti++,n++;\t// Shut the compiler up\r\n\tResumeGame = true;\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlDEButtonCustom() - The custom routine for the exit to DOS button\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlDEButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tboolean\t\tresult;\r\n\tUserItem\t*ip;\r\n\r\n\ti++,n++;\t// Shut the compiler up\r\n\r\n\tswitch (call)\r\n\t{\r\n\tcase uic_Hit:\r\n\t\tQuitToDos = true;\r\n\t\tbreak;\r\n\tcase uic_Draw:\r\n\t\tUSL_GiveAbortWarning();\r\n\tdefault:\r\n\t\tresult = false;\r\n\t\tbreak;\r\n\t}\r\n\treturn(result);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CtlCButtonCustom() - The custom routine for all of the control\r\n//\t\tbuttons\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CtlCButtonCustom(UserCall call,word i,word n)\r\n{\r\n\tword\t\tj;\r\n\tPoint\t\tp;\r\n\tUserItem\t*ip;\r\n\r\n\tif (call != uic_Hit)\r\n\t\treturn(false);\r\n\r\n\tip = &TheItems[i][n];\r\n\tif (ip->sel & ui_Disabled)\r\n\t\treturn(false);\r\n\r\n\tUSL_ClearBottom();\r\n\tif (n == 0)\t// Keyboard\r\n\t{\r\n\t\tTheItems[i + 1] = ip = CtlCKbdPanels;\r\n\t\tp = CtlCKbdPanels[2].r.lr;\r\n\t\tVWB_DrawPic(p.x,p.y,CTL_DIRSPIC);\r\n\t}\r\n\telse\r\n\t\tTheItems[i + 1] = ip = CtlCJoyPanels;\r\n\r\n\tj = 0;\r\n\twhile (ip && (ip->type != uii_Bad))\r\n\t{\r\n\t\tUSL_DrawItem(i + 1,j++);\r\n\t\tip++;\r\n\t}\r\n\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_HitHotKey() - After a hotkey was hit, move the cursor to the first\r\n//\t\tselected item in the group after the group containing the item\r\n//\t\tholding the hotkey\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_HitHotKey(int i,int n)\r\n{\r\n\tUserItem\t*ip;\r\n\r\n\tif (ip = TheItems[++i])\r\n\t{\r\n\t\tif ((n = USL_FindDown(TheItems[i])) == -1)\r\n\t\t\tn = 0;\r\n\t\tip += n;\r\n\t\tCursorX = ip->r.lr.x - 8;\r\n\t\tCursorY = ip->r.lr.y - 8;\r\n\t\tCursorBad = true;\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_CheckScan() - Checks to see if the scancode in LastScan corresponds\r\n//\t\tto anything in the list of useritems. If so, selects the item.\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic boolean\r\nUSL_CheckScan(word *ci,word *cn)\r\n{\r\n\tword\t\ti,n;\r\n\tUserItem\t*ip;\r\n\r\n\tif (!LastScan)\r\n\t\treturn(false);\r\n\r\n#if 1\t// DEBUG - probably kill this code\r\n\t// Use 1..? for the items across the top row\r\n\tif (TheItems[1] && !IN_KeyDown(sc_RShift))\r\n\t{\r\n\t\tfor (i = 0,ip = TheItems[1];(ip->type != uii_Bad) && (i < 9);i++,ip++)\r\n\t\t\t;\r\n\t\tfor (n = 0;n < i;n++)\r\n\t\t{\r\n\t\t\tif (LastScan == 2 + n)\t// Numbers from 1..9\r\n\t\t\t{\r\n\t\t\t\tif (!(TheItems[1][n].sel & ui_Disabled))\r\n\t\t\t\t{\r\n\t\t\t\t\tLastScan = sc_None;\r\n\t\t\t\t\tUSL_DoHit(1,n);\r\n\t\t\t\t\treturn(true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Use Alt-1..6 for the items in the leftmost column\r\n\tif (IN_KeyDown(sc_RShift))\r\n\t{\r\n\t\tn = LastScan - 2;\r\n\t\tif (n < 6)\t// Numbers from 1..6\r\n\t\t{\r\n\t\t\tUSL_DoHit(0,n);\r\n\t\t\tLastScan = sc_None;\r\n\t\t\treturn(true);\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\t// Check normal hotkeys for the leftmost column\r\n\tfor (i = 0;CtlPanels[i].type != uii_Bad;i++)\r\n\t{\r\n\t\tif (CtlPanels[i].key == LastScan)\r\n\t\t{\r\n\t\t\tLastScan = sc_None;\r\n\t\t\tUSL_DoHit(0,i);\r\n\t\t\t*ci = 0;\r\n\t\t\t*cn = i;\r\n\t\t\tUSL_HitHotKey(0,i);\r\n\t\t\treturn(true);\r\n\t\t}\r\n\t}\r\n\r\n\t// Check normal hotkeys for the top row\r\n\tfor (i = 0;i < 6;i++)\r\n\t{\r\n\t\tfor (n = 0,ip = CtlPanels2[i];ip && ip->type != uii_Bad;n++,ip++)\r\n\t\t{\r\n\t\t\tif ((ip->key == LastScan) && !(ip->sel & ui_Disabled))\r\n\t\t\t{\r\n\t\t\t\tLastScan = sc_None;\r\n\t\t\t\tUSL_DoHit(0,i);\r\n\t\t\t\tUSL_DoHit(1,n);\r\n\t\t\t\t*ci = 1;\r\n\t\t\t\t*cn = n;\r\n\t\t\t\tUSL_HitHotKey(1,n);\r\n\t\t\t\treturn(true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn(false);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_SetUpCtlPanel() - Sets the states of the UserItems to reflect the\r\n//\t\tvalues of all the appropriate variables\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_SetUpCtlPanel(void)\r\n{\r\n\tword\ti,j;\r\n\r\n\tGameIsDirty = ingame;\r\n\r\n\t// Set up restart game\r\n\tUSL_TurnOff(CtlPPanels);\r\n\tCtlPPanels[0].sel = ingame? ui_Normal : ui_Selected;\r\n\tCtlPPanels[1].sel = ingame? ui_Selected : ui_Disabled;\r\n\r\n\t// Set up disk stuff - default to load/save game\r\n\tUSL_TurnOff(CtlDPanels);\r\n\tCtlDPanels[0].sel = ui_Selected;\r\n\r\n\t// Set up load/save buttons\r\n\tUSL_TurnOff(CtlDLSPanels);\r\n\tfor (i = 0;i < MaxSaveGames;i++)\r\n\t{\r\n\t\tif (!Games[i].present)\r\n\t\t\tCtlDLSPanels[i * 2].sel = ui_Disabled;\r\n\t\tif (!ingame)\r\n\t\t\tCtlDLSPanels[(i * 2) + 1].sel = ui_Disabled;\r\n\t}\r\n\r\n\t// Set up Controls\r\n\tUSL_TurnOff(CtlCPanels);\r\n\tCtlCPanels[1].sel = JoysPresent[0]? ui_Normal : ui_Disabled;\r\n\tCtlCPanels[2].sel = JoysPresent[1]? ui_Normal : ui_Disabled;\r\n\tif (Controls[0] == ctrl_Keyboard)\r\n\t\ti = 0;\r\n\telse\r\n\t\ti = (Controls[0] == ctrl_Joystick1)? 1 : 2;\r\n\tCtlCPanels[i].sel |= ui_Selected;\r\n\tif (JoysPresent[1] && !JoysPresent[0])\r\n\t\tCtlCPanels[2].key = sc_F4;\r\n\telse\r\n\t\tCtlCPanels[1].key = sc_F4;\r\n\r\n\t// Set up Keyboard\r\n\tfor (i = 0;i < 10;i++)\r\n\t\tCtlCKbdPanels[i].text = IN_GetScanName(*(KeyMaps[i]));\r\n\r\n\t// Set up Sounds\r\n\tUSL_TurnOff(CtlSPanels);\r\n\tCtlSPanels[sdm_AdLib].sel = AdLibPresent? ui_Normal : ui_Disabled;\r\n#if 0\t// DEBUG - hack because no space for digitized sounds on Keen Dreams\r\n\tCtlSPanels[sdm_SoundBlaster].sel =\r\n\t\tSoundBlasterPresent? ui_Normal : ui_Disabled;\r\n\tCtlSPanels[sdm_SoundSource].sel =\r\n\t\tSoundSourcePresent? ui_Normal : ui_Disabled;\r\n#else\r\n\tCtlSPanels[sdm_SoundBlaster].sel = ui_Disabled;\r\n\tCtlSPanels[sdm_SoundSource].sel = ui_Disabled;\r\n#endif\r\n\tCtlSPanels[SoundMode].sel |= ui_Selected;\r\n\r\n\t// Set up SoundSource\r\n\tUSL_TurnOff(CtlSSSPanels);\r\n\tCtlSSSPanels[0].sel = ssIsTandy? ui_Selected : ui_Normal;\r\n\tCtlSSSPanels[1].sel = (ssPort == 2)? ui_Selected : ui_Normal;\r\n\r\n\t// Set up Music\r\n\tUSL_TurnOff(CtlMPanels);\r\n\tCtlMPanels[smm_AdLib].sel = AdLibPresent? ui_Normal : ui_Disabled;\r\n\tCtlMPanels[MusicMode].sel |= ui_Selected;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUSL_TearDownCtlPanel() - Given the state of the control panel, sets the\r\n//\t\tmodes and values as appropriate\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nstatic void\r\nUSL_TearDownCtlPanel(void)\r\n{\r\n\tint\ti;\r\n\r\n\ti = USL_FindDown(CtlCPanels);\r\n\tif (i != -1)\r\n\t{\r\n\t\ti = i? (i == 1? ctrl_Joystick1 : ctrl_Joystick2) : ctrl_Keyboard;\r\n\t\tIN_SetControlType(0,i);\r\n\t}\r\n\r\n\tCtlCPanels[1].key = CtlCPanels[2].key = sc_None;\r\n\r\n\ti = USL_FindDown(CtlSPanels);\r\n\tif (i != -1)\r\n\t\tSD_SetSoundMode(i);\r\n\r\n\tssIsTandy = CtlSSSPanels[0].sel & ui_Selected;\r\n\tssPort = (CtlSSSPanels[1].sel & ui_Selected)? 2 : 1;\r\n\r\n\ti = USL_FindDown(CtlMPanels);\r\n\tif (i != -1)\r\n\t{\r\n\t\tSD_SetMusicMode(i);\r\n\r\n\t\tif (!QuitToDos)\r\n\t\t{\r\n//\t\t\tUS_CenterWindow(20,8);\t\t//NOLAN\r\n//\t\t\tUS_CPrint(\"Loading\");\r\n#if 0\r\n\t\t\tfontcolor = F_SECONDCOLOR;\r\n\t\t\tUS_CPrint(\"Sounds\");\r\n\t\t\tfontcolor = F_BLACK;\r\n#endif\r\n//\t\t\tVW_UpdateScreen();\r\n\r\n\t\t\tCA_LoadAllSounds();\r\n\t\t}\r\n\t}\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_ControlPanel() - This is the main routine for the control panel\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_ControlPanel(void)\r\n{\r\n\tchar\t\tgamename[MaxGameName + 10 + 1];\r\n\tScanCode\tc;\r\n\tboolean\t\tdone,\r\n\t\t\t\tbuttondown,inrect;\r\n\tword\t\thiti,hitn,\r\n\t\t\t\ti,n,\r\n\t\t\t\tlasti,lastn,\r\n\t\t\t\tlastx,lasty;\r\n\tlongword\tlasttime;\r\n\tPoint\t\tp;\r\n\tRect\t\tuserect;\r\n\tUserItem\t*ip;\r\n\r\n\tc = LastScan;\r\n\tif (c == sc_Escape)\t// Map escape from game to Exit to DOS\r\n\t\tc = sc_Q;\r\n\r\n\tCA_UpLevel();\r\n\tfor (i = CONTROLS_LUMP_START;i <= CONTROLS_LUMP_END;i++)\r\n\t\tCA_MarkGrChunk(i);\r\n\tCA_MarkGrChunk(CTL_LITTLEMASKPICM);\r\n\tCA_MarkGrChunk(CTL_LSMASKPICM);\r\n\tCA_CacheMarks(\"Options Screen\", 0);\r\n\r\n\tUSL_SetUpCtlPanel();\r\n\r\n\tUS_SetPrintRoutines(VW_MeasurePropString,VWB_DrawPropString);\r\n\tfontcolor = F_BLACK;\r\n\r\n\tVW_InitDoubleBuffer();\r\n\r\n\tVWB_Bar(0,0,MaxX,MaxY,FIRSTCOLOR);\r\n\tUS_DrawWindow(8,22,30,2);\r\n\tUS_SaveWindow(&HelpWindow);\r\n\tUS_DrawWindow(8,7,30,14);\r\n\tUS_SaveWindow(&BottomWindow);\r\n\tUS_DrawWindow(8,1,30,20);\r\n\r\n\tfor (ip = CtlPanels;ip->type != uii_Bad;ip++)\r\n\t\tVWB_DrawPic(ip->r.ul.x,ip->r.ul.y,ip->picup);\r\n\r\n\tUS_StartCursor();\r\n\tCursorX = (8 * 8) + ((MaxX - (8 * 8)) / 2);\r\n\tCursorBad = true;\r\n\r\n\tCtlPanelButton = -1;\r\n\tLastScan = c;\r\n\tUSL_CheckScan(&i,&n);\r\n\tif (CtlPanelButton == -1)\r\n\t\tUSL_DoHit(0,0);\r\n\r\n\tResumeGame = false;\r\n\tdone = false;\r\n\tFlushHelp = true;\r\n\tlastx = lasty = -1;\r\n\twhile\r\n\t(\r\n\t\t(restartgame == gd_Continue)\r\n\t&&\t!(done || loadedgame || ResumeGame)\r\n\t)\r\n\t{\r\n\t\tVW_UpdateScreen();\r\n\r\n\t\tbuttondown = US_UpdateCursor();\r\n\t\tinrect = USL_IsInRect(CursorX,CursorY,&i,&n);\r\n\r\n\t\tif (FlushHelp)\r\n\t\t{\r\n\t\t\tlasti = -2;\r\n\t\t\tlasttime = TimeCount;\r\n\t\t\tFlushHelp = false;\r\n\t\t}\r\n\t\tif (inrect)\r\n\t\t{\r\n\t\t\tif ((lasti != i) || (lastn != n))\r\n\t\t\t{\r\n\t\t\t\t// If over a Load button\r\n\t\t\t\tif\r\n\t\t\t\t(\r\n\t\t\t\t\t(CtlPanelButton == 2)\r\n\t\t\t\t&&\t(i == 2)\r\n\t\t\t\t&&\t(TheItems[1][0].sel & ui_Selected)\r\n\t\t\t\t&&\t(Games[n / 2].present)\r\n\t\t\t\t&& \t!(n & 1)\r\n\t\t\t\t)\r\n\t\t\t\t{\r\n\t\t\t\t\tstrcpy(gamename,\"Load `\");\r\n\t\t\t\t\tstrcat(gamename,Games[n / 2].name);\r\n\t\t\t\t\tstrcat(gamename,\"'\");\r\n\t\t\t\t\tUSL_ShowHelp(gamename);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tUSL_ShowHelp(TheItems[i][n].help);\r\n\t\t\t\tlasti = i;\r\n\t\t\t\tlastn = n;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (lasti != (word)-1)\r\n\t\t{\r\n\t\t\tUSL_ShowHelp(\"Select a Button\");\r\n\t\t\tlasti = -1;\r\n\t\t}\r\n\r\n\t\thiti = i;\r\n\t\thitn = n;\r\n\r\n\t\tif (inrect)\r\n\t\t\tuserect = TheItems[i][n].r;\r\n\t\telse\r\n\t\t{\r\n\t\t\tuserect.ul.x = CursorX;\r\n\t\t\tuserect.ul.y = CursorY;\r\n\t\t\tuserect.lr = userect.ul;\r\n\t\t}\r\n\r\n\t\tif (IN_KeyDown(sc_UpArrow))\r\n\t\t{\r\n\t\t\tUSL_FindRect(userect,motion_None,motion_Up);\r\n\t\t\tbuttondown = false;\r\n\t\t\tIN_ClearKey(sc_UpArrow);\r\n\t\t}\r\n\t\telse if (IN_KeyDown(sc_DownArrow))\r\n\t\t{\r\n\t\t\tUSL_FindRect(userect,motion_None,motion_Down);\r\n\t\t\tbuttondown = false;\r\n\t\t\tIN_ClearKey(sc_DownArrow);\r\n\t\t}\r\n\t\telse if (IN_KeyDown(sc_LeftArrow))\r\n\t\t{\r\n\t\t\tUSL_FindRect(userect,motion_Left,motion_None);\r\n\t\t\tbuttondown = false;\r\n\t\t\tIN_ClearKey(sc_LeftArrow);\r\n\t\t}\r\n\t\telse if (IN_KeyDown(sc_RightArrow))\r\n\t\t{\r\n\t\t\tUSL_FindRect(userect,motion_Right,motion_None);\r\n\t\t\tbuttondown = false;\r\n\t\t\tIN_ClearKey(sc_RightArrow);\r\n\t\t}\r\n\t\telse if\r\n\t\t(\r\n\t\t\tIN_KeyDown(c = sc_Return)\r\n\t\t|| \tIN_KeyDown(c = KbdDefs[0].button0)\r\n\t\t|| \tIN_KeyDown(c = KbdDefs[0].button1)\r\n\t\t)\r\n\t\t{\r\n\t\t\tIN_ClearKey(c);\r\n\t\t\tif (inrect)\r\n\t\t\t{\r\n\t\t\t\tip = &TheItems[hiti][hitn];\r\n\r\n\t\t\t\tif ((ip->type == uii_Button) && !(ip->sel & ui_Disabled))\r\n\t\t\t\t{\r\n\t\t\t\t\tlasttime = TimeCount;\r\n\r\n\t\t\t\t\tip->sel |= ui_Selected;\r\n\t\t\t\t\tUSL_DrawItem(hiti,hitn);\r\n\t\t\t\t\tVW_UpdateScreen();\r\n\r\n\t\t\t\t\twhile (TimeCount - lasttime < TickBase / 4)\r\n\t\t\t\t\t\t;\r\n\t\t\t\t\tlasttime = TimeCount;\r\n\r\n\t\t\t\t\tip->sel &= ~ui_Selected;\r\n\t\t\t\t\tUSL_DrawItem(hiti,hitn);\r\n\t\t\t\t\tVW_UpdateScreen();\r\n\r\n\t\t\t\t\twhile (TimeCount - lasttime < TickBase / 4)\r\n\t\t\t\t\t\t;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tUSL_DoHit(hiti,hitn);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (USL_CheckScan(&i,&n))\r\n\t\t\t;\r\n\t\telse if (buttondown && inrect && USL_TrackItem(hiti,hitn))\r\n\t\t\tUSL_DoHit(hiti,hitn);\r\n\r\n\t\tif (LastScan == sc_Escape)\r\n\t\t{\r\n\t\t\tIN_ClearKey(sc_Escape);\r\n\t\t\tdone = true;\r\n\t\t}\r\n\r\n\t\tif (QuitToDos)\r\n\t\t\tdone = true;\r\n\r\n\t\tif ((lastx != CursorX) || (lasty != CursorY))\r\n\t\t{\r\n\t\t\tlastx = CursorX;\r\n\t\t\tlasty = CursorY;\r\n\t\t\tlasttime = TimeCount;\r\n\t\t}\r\n\t\tif (TimeCount - lasttime > TickBase * 10)\r\n\t\t{\r\n\t\t\tif (((TimeCount - lasttime) / TickBase) & 2)\r\n\t\t\t\tfontcolor = F_SECONDCOLOR;\r\n\t\t\tUSL_ShowHelp(\"Press F1 for Help\");\r\n\t\t\tfontcolor = F_BLACK;\r\n\t\t}\r\n\t}\r\n\r\n\tUS_ShutCursor();\r\n\r\n\tUSL_TearDownCtlPanel();\r\n\r\n\tif (QuitToDos)\r\n\t{\r\n#if FRILLS\r\n\t\tif (tedlevel)\r\n\t\t\tTEDDeath();\r\n\t\telse\r\n#endif\r\n\t\t{\r\n\t\t\tUS_CenterWindow(20,3);\r\n\t\t\tfontcolor = F_SECONDCOLOR;\r\n\t\t\tUS_PrintCentered(\"Now Exiting to DOS...\");\r\n\t\t\tfontcolor = F_BLACK;\r\n\t\t\tVW_UpdateScreen();\r\n\t\t\tQuit(nil);\r\n\t\t}\r\n\t}\r\n\r\n\tCA_DownLevel();\r\n}\r\n\r\n//\tHigh score routines\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_DisplayHighScores() - Assumes that double buffering has been started.\r\n//\t\tIf passed a -1 will just display the high scores, but if passed\r\n//\t\ta non-negative number will display that entry in red and let the\r\n//\t\tuser type in a name\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_DisplayHighScores(int which)\r\n{\r\n\tchar\t\tbuffer[16],*str;\r\n\tword\t\ti,\r\n\t\t\t\tw,h,\r\n\t\t\t\tx,y;\r\n\tHighScore\t*s;\r\n\r\n\tUS_CenterWindow(30,MaxScores + (MaxScores / 2));\r\n\r\n\tx = WindowX + (WindowW / 2);\r\n\tUS_Print(\" Name\");\r\n\tPrintX = x + 20;\r\n\tUS_Print(\"Score\");\r\n\tPrintX = x + 60;\r\n\tUS_Print(\"Done\\n\\n\");\r\n\tPrintY -= 3;\r\n\r\n\tfor (i = WindowX;i < WindowX + WindowW;i += 8)\r\n\t\tVWB_DrawTile8M(i,WindowY + 8,10);\r\n\tVWB_DrawTile8M(WindowX - 8,WindowY + 8,9);\r\n\tVWB_DrawTile8M(WindowX + WindowW,WindowY + 8,11);\r\n\r\n\tfor (i = 0,s = Scores;i < MaxScores;i++,s++)\r\n\t{\r\n\t\tfontcolor = (i == which)? F_SECONDCOLOR : F_BLACK;\r\n\r\n\t\tif (i != which)\r\n\t\t{\r\n\t\t\tUS_Print(\" \");\r\n\t\t\tif (strlen(s->name))\r\n\t\t\t\tUS_Print(s->name);\r\n\t\t\telse\r\n\t\t\t\tUS_Print(\"-\");\r\n\t\t}\r\n\t\telse\r\n\t\t\ty = PrintY;\r\n\r\n\t\tPrintX = x + (7 * 8);\r\n\t\tultoa(s->score,buffer,10);\r\n\t\tfor (str = buffer;*str;str++)\r\n\t\t\t*str = *str + (129 - '0');\t// Used fixed-width numbers (129...)\r\n\t\tUSL_MeasureString(buffer,&w,&h);\r\n\t\tPrintX -= w;\r\n\t\tUS_Print(buffer);\r\n\r\n\t\tPrintX = x + 60;\r\n\t\tif (s->completed)\r\n\t\t\tUS_PrintUnsigned(s->completed);\r\n\t\telse\r\n\t\t\tUS_Print(\"-\");\r\n\r\n\t\tUS_Print(\"\\n\");\r\n\t}\r\n\r\n\tif (which != -1)\r\n\t{\r\n\t\tfontcolor = F_SECONDCOLOR;\r\n\t\tPrintY = y;\r\n\t\tPrintX = WindowX;\r\n\t\tUS_Print(\" \");\r\n\t\tstrcpy(Scores[which].name,\"\");\r\n\t\tUS_LineInput(PrintX,PrintY,Scores[which].name,nil,true,MaxHighName,\r\n\t\t\t\t\t\t(WindowW / 2) - 8);\r\n\t}\r\n\tfontcolor = F_BLACK;\r\n\r\n\tVW_UpdateScreen();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\n//\r\n//\tUS_CheckHighScore() - Checks gamestate to see if the just-ended game\r\n//\t\tshould be entered in the high score list. If so, lets the user\r\n//\t\tenter their name\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\nvoid\r\nUS_CheckHighScore(long score,word other)\r\n{\r\n\tword\t\ti,j,\r\n\t\t\t\tn;\r\n\tHighScore\tmyscore;\r\n\r\n\tstrcpy(myscore.name,\"\");\r\n\tmyscore.score = score;\r\n\tmyscore.completed = other;\r\n\r\n\tfor (i = 0,n = -1;i < MaxScores;i++)\r\n\t{\r\n\t\tif\r\n\t\t(\r\n\t\t\t(myscore.score > Scores[i].score)\r\n\t\t||\t(\r\n\t\t\t\t(myscore.score == Scores[i].score)\r\n\t\t\t&& \t(myscore.completed > Scores[i].completed)\r\n\t\t\t)\r\n\t\t)\r\n\t\t{\r\n\t\t\tfor (j = MaxScores;--j > i;)\r\n\t\t\t\tScores[j] = Scores[j - 1];\r\n\t\t\tScores[i] = myscore;\r\n\r\n\t\t\tn = i;\r\n\t\t\tHighScoresDirty = true;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tVW_InitDoubleBuffer();\r\n\tVWB_Bar(0,0,MaxX,MaxY,FIRSTCOLOR);\r\n\r\n\tUS_DisplayHighScores(n);\r\n\tIN_UserInput(5 * TickBase,false);\r\n}\r\n"
        },
        {
          "name": "id_us.h",
          "type": "blob",
          "size": 3.0400390625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n//\tID Engine\r\n//\tID_US.h - Header file for the User Manager\r\n//\tv1.0d1\r\n//\tBy Jason Blochowiak\r\n//\r\n\r\n#ifndef\t__TYPES__\r\n#include \"ID_Types.h\"\r\n#endif\r\n\r\n#ifndef\t__ID_US__\r\n#define\t__ID_US__\r\n\r\n#ifdef\t__DEBUG__\r\n#define\t__DEBUG_UserMgr__\r\n#endif\r\n\r\n#define\tHELPTEXTLINKED\r\n\r\n#define\tMaxString\t128\t// Maximum input string size\r\n\r\ntypedef\tstruct\r\n\t\t{\r\n\t\t\tint\tx,y,\r\n\t\t\t\tw,h,\r\n\t\t\t\tpx,py;\r\n\t\t} WindowRec;\t// Record used to save & restore screen windows\r\n\r\ntypedef\tenum\r\n\t\t{\r\n\t\t\tgd_Continue,\r\n\t\t\tgd_Easy,\r\n\t\t\tgd_Normal,\r\n\t\t\tgd_Hard\r\n\t\t} GameDiff;\r\n\r\nextern\tboolean\t\tingame,\t// Set by game code if a game is in progress\r\n\t\t\t\t\tabortgame,\t// Set if a game load failed\r\n\t\t\t\t\tloadedgame;\t// Set if the current game was loaded\r\nextern\tchar\t\t*abortprogram;\t// Set to error msg if program is dying\r\nextern\tGameDiff\trestartgame;\t// Normally gd_Continue, else starts game\r\nextern\tword\t\tPrintX,PrintY;\t// Current printing location in the window\r\nextern\tword\t\tWindowX,WindowY,// Current location of window\r\n\t\t\t\t\tWindowW,WindowH;// Current size of window\r\n\r\n#define\tUS_HomeWindow()\t{PrintX = WindowX; PrintY = WindowY;}\r\n\r\nextern\tvoid\tUS_Startup(void),\r\n\t\t\t\tUS_Setup(void),\r\n\t\t\t\tUS_Shutdown(void),\r\n\t\t\t\tUS_InitRndT(boolean randomize),\r\n\t\t\t\tUS_SetLoadSaveHooks(boolean (*load)(int),\r\n\t\t\t\t\t\t\t\t\tboolean (*save)(int),\r\n\t\t\t\t\t\t\t\t\tvoid (*reset)(void)),\r\n\t\t\t\tUS_TextScreen(void),\r\n\t\t\t\tUS_UpdateTextScreen(void),\r\n\t\t\t\tUS_FinishTextScreen(void),\r\n\t\t\t\tUS_ControlPanel(void),\r\n\t\t\t\tUS_DrawWindow(word x,word y,word w,word h),\r\n\t\t\t\tUS_CenterWindow(word,word),\r\n\t\t\t\tUS_SaveWindow(WindowRec *win),\r\n\t\t\t\tUS_RestoreWindow(WindowRec *win),\r\n\t\t\t\tUS_ClearWindow(void),\r\n\t\t\t\tUS_SetPrintRoutines(void (*measure)(char far *,word *,word *),\r\n\t\t\t\t\t\t\t\t\tvoid (*print)(char far *)),\r\n\t\t\t\tUS_PrintCentered(char *s),\r\n\t\t\t\tUS_CPrint(char *s),\r\n\t\t\t\tUS_CPrintLine(char *s),\r\n\t\t\t\tUS_Print(char *s),\r\n\t\t\t\tUS_PrintUnsigned(longword n),\r\n\t\t\t\tUS_PrintSigned(long n),\r\n\t\t\t\tUS_StartCursor(void),\r\n\t\t\t\tUS_ShutCursor(void),\r\n\t\t\t\tUS_ControlPanel(void),\r\n\t\t\t\tUS_CheckHighScore(long score,word other),\r\n\t\t\t\tUS_DisplayHighScores(int which);\r\nextern\tboolean\tUS_UpdateCursor(void),\r\n\t\t\t\tUS_LineInput(int x,int y,char *buf,char *def,boolean escok,\r\n\t\t\t\t\t\t\t\tint maxchars,int maxwidth);\r\nextern\tint\t\tUS_CheckParm(char *parm,char **strings),\r\n\t\t\t\tUS_RndT(void);\r\n\r\n#endif\r\n"
        },
        {
          "name": "id_us_a.asm",
          "type": "blob",
          "size": 3.716796875,
          "content": "; Keen Dreams Source Code\r\n; Copyright (C) 2014 Javier M. Chavez\r\n;\r\n; This program is free software; you can redistribute it and/or modify\r\n; it under the terms of the GNU General Public License as published by\r\n; the Free Software Foundation; either version 2 of the License, or\r\n; (at your option) any later version.\r\n;\r\n; This program is distributed in the hope that it will be useful,\r\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n; GNU General Public License for more details.\r\n;\r\n; You should have received a copy of the GNU General Public License along\r\n; with this program; if not, write to the Free Software Foundation, Inc.,\r\n; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n\r\nIDEAL\r\nMODEL\tMEDIUM,C\r\n\r\n;\tAssembly portion of the User Mgr. This is just John Carmack's table\r\n;\t\tdriven pseudo-random number generator, and we put it in the User Mgr\r\n;\t\tbecause we couldn't figure out where it should go\r\n\r\n\r\n;============================================================================\r\n;\r\n;                           RANDOM ROUTINES\r\n;\r\n;============================================================================\r\n\r\n\tDATASEG\r\n\r\nrndindex\tdw\t?\r\n\r\nrndtable db    0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66\r\n    db   74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36\r\n    db   95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188\r\n    db   52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224\r\n    db  149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242\r\n    db  145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0\r\n    db  175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235\r\n    db   25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113\r\n    db   94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75\r\n    db  136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196\r\n    db  135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113\r\n    db   80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241\r\n    db   24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224\r\n    db  145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95\r\n    db   28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226\r\n    db   71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36\r\n    db   17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106\r\n    db  197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136\r\n    db  120, 163, 236, 249\r\n\r\n\r\n;\r\n; Random # Generator vars\r\n;\r\nindexi\t\tdw\t?\t;Rnd#Generator\r\nindexj\t\tdw\t?\r\nLastRnd\t\tdw\t?\r\nRndArray\tdw\t17 dup (?)\r\n\r\nbaseRndArray\tdw\t1,1,2,3,5,8,13,21,54,75,129,204\r\n\t\tdw\t323,527,850,1377,2227\r\n\r\n\tCODESEG\r\n\r\n;=================================================\r\n;\r\n; void US_InitRndT (boolean randomize)\r\n; Init table based RND generator\r\n; if randomize is false, the counter is set to 0\r\n;\r\n;=================================================\r\n\r\nPROC\tUS_InitRndT randomize:word\r\n\tuses\tsi,di\r\n\tpublic\tUS_InitRndT\r\n\r\n\tmov\tax,[randomize]\r\n\tor\tax,ax\r\n\tjne\t@@timeit\t\t;if randomize is true, really random\r\n\r\n\tmov\tdx,0\t\t\t;set to a definite value\r\n\tjmp\t@@setit\r\n\r\n@@timeit:\r\n\tmov\tah,2ch\r\n\tint\t21h\t\t\t;GetSystemTime\r\n\tand\tdx,0ffh\r\n\r\n@@setit:\r\n\tmov\t[rndindex],dx\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n;=================================================\r\n;\r\n; int US_RndT (void)\r\n; Return a random # between 0-255\r\n; Exit : AX = value\r\n;\r\n;=================================================\r\nPROC\tUS_RndT\r\n\tpublic\tUS_RndT\r\n\r\n\tmov\tbx,[rndindex]\r\n\tinc\tbx\r\n\tand\tbx,0ffh\r\n\tmov\t[rndindex],bx\r\n\tmov\tal,[rndtable+BX]\r\n\txor\tah,ah\r\n\r\n\tret\r\n\r\nENDP\r\n\r\nEND\r\n"
        },
        {
          "name": "id_us_s.c",
          "type": "blob",
          "size": 9.8994140625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\nscr_rowcol(1,1)      scr_aputs(\"                                                                                \",0xC4);\r\nscr_rowcol(2,1)      scr_aputs(\"                                                                                \",0xC4);\r\nscr_rowcol(3,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(3,12)      scr_aputs(\"                                                          \",0x4E);\r\nscr_rowcol(3,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(4,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(4,12)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ\",0x40);\r\nscr_rowcol(4,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(5,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(5,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(5,13)      scr_aputs(\"ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß\",0x7F);\r\nscr_rowcol(5,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(5,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(6,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(6,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(6,13)      scr_aputs(\"                                                        \",0x77);\r\nscr_rowcol(6,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(6,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(7,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(7,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(7,13)      scr_aputs(\" \",0x77);\r\nscr_rowcol(7,14)      scr_aputs(\" \",0x44);\r\nscr_rowcol(7,15)      scr_aputs(\"                \",0x40);\r\nscr_rowcol(7,31)      scr_aputs(\"Let the Dreams begin!\",0x4E);\r\nscr_rowcol(7,52)      scr_aputs(\"               \",0x40);\r\nscr_rowcol(7,67)      scr_aputs(\" \",0x44);\r\nscr_rowcol(7,68)      scr_aputs(\" \",0x77);\r\nscr_rowcol(7,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(7,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(8,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(8,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(8,13)      scr_aputs(\"                                                        \",0x77);\r\nscr_rowcol(8,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(8,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(9,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(9,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(9,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(9,19)      scr_aputs(\"ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»\",0x70);\r\nscr_rowcol(9,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(9,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(9,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(10,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(10,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(10,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(10,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(10,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(10,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(10,24)      scr_aputs(\"  \",0x77);\r\nscr_rowcol(10,26)      scr_aputs(\" \",0x78);\r\nscr_rowcol(10,27)      scr_aputs(\"Softdisk Publishing presents\",0x71);\r\nscr_rowcol(10,55)      scr_aputs(\"        \",0x77);\r\nscr_rowcol(10,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(10,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(10,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(10,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(11,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(11,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(11,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(11,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(11,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(11,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(11,24)      scr_aputs(\"        \",0x77);\r\nscr_rowcol(11,32)      scr_aputs(\"             \",0x74);\r\nscr_rowcol(11,45)      scr_aputs(\"                  \",0x77);\r\nscr_rowcol(11,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(11,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(11,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(11,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(12,1)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(12,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(12,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(12,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(12,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(12,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(12,24)      scr_aputs(\"          \",0x77);\r\nscr_rowcol(12,34)      scr_aputs(\" \",0x78);\r\nscr_rowcol(12,35)      scr_aputs(\"KEEN DREAMS\",0x74);\r\nscr_rowcol(12,46)      scr_aputs(\"                 \",0x77);\r\nscr_rowcol(12,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(12,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(12,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(12,70)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(13,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(13,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(13,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(13,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(13,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(13,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(13,24)      scr_aputs(\"                                       \",0x77);\r\nscr_rowcol(13,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(13,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(13,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(13,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(14,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(14,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(14,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(14,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(14,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(14,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(14,24)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(14,30)      scr_aputs(\"    COMMANDER KEEN\",0x78);\r\nscr_rowcol(14,48)      scr_aputs(\"               \",0x77);\r\nscr_rowcol(14,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(14,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(14,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(14,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(15,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(15,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(15,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(15,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(15,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(15,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(15,24)      scr_aputs(\"       \",0x77);\r\nscr_rowcol(15,31)      scr_aputs(\" is a trademark of\",0x78);\r\nscr_rowcol(15,49)      scr_aputs(\"              \",0x77);\r\nscr_rowcol(15,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(15,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(15,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(15,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(16,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(16,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(16,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(16,19)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(16,20)      scr_aputs(\"   \",0x77);\r\nscr_rowcol(16,23)      scr_aputs(\" \",0x70);\r\nscr_rowcol(16,24)      scr_aputs(\"        \",0x77);\r\nscr_rowcol(16,32)      scr_aputs(\"   Id Software\",0x78);\r\nscr_rowcol(16,46)      scr_aputs(\"                 \",0x77);\r\nscr_rowcol(16,63)      scr_aputs(\"º\",0x70);\r\nscr_rowcol(16,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(16,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(16,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(17,1)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(17,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(17,13)      scr_aputs(\"      \",0x77);\r\nscr_rowcol(17,19)      scr_aputs(\"ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼\",0x70);\r\nscr_rowcol(17,64)      scr_aputs(\"     \",0x77);\r\nscr_rowcol(17,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(17,70)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(18,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(18,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(18,13)      scr_aputs(\"                                                        \",0x77);\r\nscr_rowcol(18,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(18,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(19,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(19,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(19,13)      scr_aputs(\" \",0x77);\r\nscr_rowcol(19,14)      scr_aputs(\"                   \",0x44);\r\nscr_rowcol(19,33)      scr_aputs(\"Please standby...\",0x4E);\r\nscr_rowcol(19,50)      scr_aputs(\"                  \",0x44);\r\nscr_rowcol(19,68)      scr_aputs(\" \",0x77);\r\nscr_rowcol(19,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(19,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(20,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(20,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(20,13)      scr_aputs(\"                                                        \",0x77);\r\nscr_rowcol(20,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(20,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(21,1)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(21,12)      scr_aputs(\"Þ\",0xF);\r\nscr_rowcol(21,13)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ\",0x78);\r\nscr_rowcol(21,69)      scr_aputs(\"Ý\",0x8);\r\nscr_rowcol(21,70)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(22,1)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(22,12)      scr_aputs(\"ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß\",0x40);\r\nscr_rowcol(22,70)      scr_aputs(\"           \",0xC4);\r\nscr_rowcol(23,1)      scr_aputs(\"                                                                                \",0xC4);\r\nscr_rowcol(24,1)      scr_aputs(\"ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ\",0xC);\r\nscr_rowcol(25,1)      scr_aputs(\"                                                                                \",0x7);\r\n\u001a"
        },
        {
          "name": "id_vw.c",
          "type": "blob",
          "size": 26.0673828125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_VW.C\r\n\r\n#include \"ID_HEADS.H\"\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define VIEWWIDTH\t\t40\r\n\r\n#define PIXTOBLOCK\t\t4\t\t// 16 pixels to an update block\r\n\r\n#if GRMODE == EGAGR\r\n#define SCREENXMASK\t\t(~7)\r\n#define SCREENXPLUS\t\t(7)\r\n#define SCREENXDIV\t\t(8)\r\n#endif\r\n\r\n#if GRMODE == CGAGR\r\n#define SCREENXMASK\t\t(~3)\r\n#define SCREENXDIV\t\t(4)\r\n#endif\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\ncardtype\tvideocard;\t\t// set by VW_Startup\r\ngrtype\t\tgrmode;\t\t\t// CGAgr, EGAgr, VGAgr\r\n\r\nunsigned\tbufferofs;\t\t// hidden area to draw to before displaying\r\nunsigned\tdisplayofs;\t\t// origin of the visable screen\r\nunsigned\tpanx,pany;\t\t// panning adjustments inside port in pixels\r\nunsigned\tpansx,pansy;\t// panning adjustments inside port in screen\r\n\t\t\t\t\t\t\t// block limited pixel values (ie 0/8 for ega x)\r\nunsigned\tpanadjust;\t\t// panx/pany adjusted by screen resolution\r\n\r\nunsigned\tscreenseg;\t\t// normally 0xa000 / 0xb800\r\nunsigned\tlinewidth;\r\nunsigned\tylookup[VIRTUALHEIGHT];\r\n\r\nboolean\t\tscreenfaded;\r\n\r\npictabletype\t_seg *pictable;\r\npictabletype\t_seg *picmtable;\r\nspritetabletype _seg *spritetable;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tVWL_MeasureString (char far *string, word *width, word *height,\r\n\t\tfontstruct _seg *font);\r\nvoid \tVWL_DrawCursor (void);\r\nvoid \tVWL_EraseCursor (void);\r\nvoid \tVWL_DBSetup (void);\r\nvoid\tVWL_UpdateScreenBlocks (void);\r\n\r\n\r\nint\t\t\tbordercolor;\r\nint\t\t\tcursorvisible;\r\nint\t\t\tcursornumber,cursorwidth,cursorheight,cursorx,cursory;\r\nmemptr\t\tcursorsave;\r\nunsigned\tcursorspot;\r\n\r\nextern\tunsigned\tbufferwidth,bufferheight;\t// used by font drawing stuff\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= VW_Startup\r\n=\r\n=======================\r\n*/\r\n\r\nstatic\tchar *ParmStrings[] = {\"HIDDENCARD\",\"\"};\r\n\r\nvoid\tVW_Startup (void)\r\n{\r\n\tint i;\r\n\r\n\tasm\tcld;\r\n\r\n\tvideocard = 0;\r\n\r\n\tfor (i = 1;i < _argc;i++)\r\n\t\tif (US_CheckParm(_argv[i],ParmStrings) == 0)\r\n\t\t{\r\n\t\t\tvideocard = EGAcard;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\tif (!videocard)\r\n\t\tvideocard = VW_VideoID ();\r\n\r\n#if GRMODE == EGAGR\r\n\tgrmode = EGAGR;\r\n\tif (videocard != EGAcard && videocard != VGAcard)\r\nQuit (\"Improper video card!  If you really have an EGA/VGA card that I am not \\n\"\r\n\t  \"detecting, use the -HIDDENCARD command line parameter!\");\r\n\tEGAWRITEMODE(0);\r\n#endif\r\n\r\n#if GRMODE == CGAGR\r\n\tgrmode = CGAGR;\r\n\tif (videocard < CGAcard || videocard > VGAcard)\r\nQuit (\"Improper video card!  If you really have a CGA card that I am not \\n\"\r\n\t  \"detecting, use the -HIDDENCARD command line parameter!\");\r\n\tMM_GetPtr (&(memptr)screenseg,0x10000l);\t// grab 64k for floating screen\r\n#endif\r\n\r\n\tcursorvisible = 0;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= VW_Shutdown\r\n=\r\n=======================\r\n*/\r\n\r\nvoid\tVW_Shutdown (void)\r\n{\r\n\tVW_SetScreenMode (TEXTGR);\r\n#if GRMODE == EGAGR\r\n\tVW_SetLineWidth (80);\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n========================\r\n=\r\n= VW_SetScreenMode\r\n= Call BIOS to set TEXT / CGAgr / EGAgr / VGAgr\r\n=\r\n========================\r\n*/\r\n\r\nvoid VW_SetScreenMode (int grmode)\r\n{\r\n\tswitch (grmode)\r\n\t{\r\n\t  case TEXTGR:  _AX = 3;\r\n\t\t  geninterrupt (0x10);\r\n\t\t  screenseg=0xb000;\r\n\t\t  break;\r\n\t  case CGAGR: _AX = 4;\r\n\t\t  geninterrupt (0x10);\t\t// screenseg is actually a main mem buffer\r\n\t\t  break;\r\n\t  case EGAGR: _AX = 0xd;\r\n\t\t  geninterrupt (0x10);\r\n\t\t  screenseg=0xa000;\r\n\t\t  break;\r\n#ifdef VGAGAME\r\n\t  case VGAGR:{\r\n\t\t  char extern VGAPAL;\t// deluxepaint vga pallet .OBJ file\r\n\t\t  void far *vgapal = &VGAPAL;\r\n\t\t  SetCool256 ();\t\t// custom 256 color mode\r\n\t\t  screenseg=0xa000;\r\n\t\t  _ES = FP_SEG(vgapal);\r\n\t\t  _DX = FP_OFF(vgapal);\r\n\t\t  _BX = 0;\r\n\t\t  _CX = 0x100;\r\n\t\t  _AX = 0x1012;\r\n\t\t  geninterrupt(0x10);\t\t\t// set the deluxepaint pallet\r\n\r\n\t\t  break;\r\n#endif\r\n\t}\r\n\tVW_SetLineWidth(SCREENWIDTH);\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tSCREEN FADES\r\n\r\n=============================================================================\r\n*/\r\n\r\nchar colors[7][17]=\r\n{{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\r\n {0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,0},\r\n {0,0,0,0,0,0,0,0,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0},\r\n {0,1,2,3,4,5,6,7,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,0},\r\n {0,1,2,3,4,5,6,7,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0},\r\n {0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f}};\r\n\r\n\r\nvoid VW_ColorBorder (int color)\r\n{\r\n\t_AH=0x10;\r\n\t_AL=1;\r\n\t_BH=color;\r\n\tgeninterrupt (0x10);\r\n\tbordercolor = color;\r\n}\r\n\r\nvoid VW_SetDefaultColors(void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tcolors[3][16] = bordercolor;\r\n\t_ES=FP_SEG(&colors[3]);\r\n\t_DX=FP_OFF(&colors[3]);\r\n\t_AX=0x1002;\r\n\tgeninterrupt(0x10);\r\n\tscreenfaded = false;\r\n#endif\r\n}\r\n\r\n\r\nvoid VW_FadeOut(void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tint i;\r\n\r\n\tfor (i=3;i>=0;i--)\r\n\t{\r\n\t  colors[i][16] = bordercolor;\r\n\t  _ES=FP_SEG(&colors[i]);\r\n\t  _DX=FP_OFF(&colors[i]);\r\n\t  _AX=0x1002;\r\n\t  geninterrupt(0x10);\r\n\t  VW_WaitVBL(6);\r\n\t}\r\n\tscreenfaded = true;\r\n#endif\r\n}\r\n\r\n\r\nvoid VW_FadeIn(void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tint i;\r\n\r\n\tfor (i=0;i<4;i++)\r\n\t{\r\n\t  colors[i][16] = bordercolor;\r\n\t  _ES=FP_SEG(&colors[i]);\r\n\t  _DX=FP_OFF(&colors[i]);\r\n\t  _AX=0x1002;\r\n\t  geninterrupt(0x10);\r\n\t  VW_WaitVBL(6);\r\n\t}\r\n\tscreenfaded = false;\r\n#endif\r\n}\r\n\r\nvoid VW_FadeUp(void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tint i;\r\n\r\n\tfor (i=3;i<6;i++)\r\n\t{\r\n\t  colors[i][16] = bordercolor;\r\n\t  _ES=FP_SEG(&colors[i]);\r\n\t  _DX=FP_OFF(&colors[i]);\r\n\t  _AX=0x1002;\r\n\t  geninterrupt(0x10);\r\n\t  VW_WaitVBL(6);\r\n\t}\r\n\tscreenfaded = true;\r\n#endif\r\n}\r\n\r\nvoid VW_FadeDown(void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tint i;\r\n\r\n\tfor (i=5;i>2;i--)\r\n\t{\r\n\t  colors[i][16] = bordercolor;\r\n\t  _ES=FP_SEG(&colors[i]);\r\n\t  _DX=FP_OFF(&colors[i]);\r\n\t  _AX=0x1002;\r\n\t  geninterrupt(0x10);\r\n\t  VW_WaitVBL(6);\r\n\t}\r\n\tscreenfaded = false;\r\n#endif\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= VW_SetLineWidth\r\n=\r\n= Must be an even number of bytes\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_SetLineWidth (int width)\r\n{\r\n  int i,offset;\r\n\r\n#if GRMODE == EGAGR\r\n//\r\n// set wide virtual screen\r\n//\r\nasm\tmov\tdx,CRTC_INDEX\r\nasm\tmov\tal,CRTC_OFFSET\r\nasm mov\tah,[BYTE PTR width]\r\nasm\tshr\tah,1\r\nasm\tout\tdx,ax\r\n#endif\r\n\r\n//\r\n// set up lookup tables\r\n//\r\n  linewidth = width;\r\n\r\n  offset = 0;\r\n\r\n  for (i=0;i<VIRTUALHEIGHT;i++)\r\n  {\r\n\tylookup[i]=offset;\r\n\toffset += width;\r\n  }\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= VW_ClearVideo\r\n=\r\n====================\r\n*/\r\n\r\nvoid\tVW_ClearVideo (int color)\r\n{\r\n#if GRMODE == EGAGR\r\n\tEGAWRITEMODE(2);\r\n\tEGAMAPMASK(15);\r\n#endif\r\n\r\nasm\tmov\tes,[screenseg]\r\nasm\txor\tdi,di\r\nasm\tmov\tcx,0xffff\r\nasm\tmov\tal,[BYTE PTR color]\r\nasm\trep\tstosb\r\nasm\tstosb\r\n\r\n#if GRMODE == EGAGR\r\n\tEGAWRITEMODE(0);\r\n#endif\r\n}\r\n\r\n//===========================================================================\r\n\r\n#if NUMPICS>0\r\n\r\n/*\r\n====================\r\n=\r\n= VW_DrawPic\r\n=\r\n= X in bytes, y in pixels, chunknum is the #defined picnum\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_DrawPic(unsigned x, unsigned y, unsigned chunknum)\r\n{\r\n\tint\tpicnum = chunknum - STARTPICS;\r\n\tmemptr source;\r\n\tunsigned dest,width,height;\r\n\r\n\tsource = grsegs[chunknum];\r\n\tdest = ylookup[y]+x+bufferofs;\r\n\twidth = pictable[picnum].width;\r\n\theight = pictable[picnum].height;\r\n\r\n\tVW_MemToScreen(source,dest,width,height);\r\n}\r\n\r\n#endif\r\n\r\n#if NUMPICM>0\r\n\r\n/*\r\n====================\r\n=\r\n= VW_DrawMPic\r\n=\r\n= X in bytes, y in pixels, chunknum is the #defined picnum\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_DrawMPic(unsigned x, unsigned y, unsigned chunknum)\r\n{\r\n\tint\tpicnum = chunknum - STARTPICM;\r\n\tmemptr source;\r\n\tunsigned dest,width,height;\r\n\r\n\tsource = grsegs[chunknum];\r\n\tdest = ylookup[y]+x+bufferofs;\r\n\twidth = pictable[picnum].width;\r\n\theight = pictable[picnum].height;\r\n\r\n\tVW_MaskBlock(source,0,dest,width,height,width*height);\r\n}\r\n\r\n#endif\r\n\r\n//===========================================================================\r\n\r\n#if NUMSPRITES>0\r\n\r\n/*\r\n====================\r\n=\r\n= VW_DrawSprite\r\n=\r\n= X and Y in pixels, it will match the closest shift possible\r\n=\r\n= To do:\r\n= Add vertical clipping!\r\n= Make the shifts act as center points, rather than break points\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_DrawSprite(int x, int y, unsigned chunknum)\r\n{\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg\t*block;\r\n\tunsigned\tdest,shift;\r\n\r\n\tspr = &spritetable[chunknum-STARTSPRITES];\r\n\tblock = (spritetype _seg *)grsegs[chunknum];\r\n\r\n\ty+=spr->orgy>>G_P_SHIFT;\r\n\tx+=spr->orgx>>G_P_SHIFT;\r\n\r\n#if GRMODE == EGAGR\r\n\tshift = (x&7)/2;\r\n#endif\r\n#if GRMODE == CGAGR\r\n\tshift = 0;\r\n#endif\r\n\r\n\tdest = bufferofs + ylookup[y];\r\n\tif (x>=0)\r\n\t\tdest += x/SCREENXDIV;\r\n\telse\r\n\t\tdest += (x+1)/SCREENXDIV;\r\n\r\n\tVW_MaskBlock (block,block->sourceoffset[shift],dest,\r\n\t\tblock->width[shift],spr->height,block->planesize[shift]);\r\n}\r\n\r\n#endif\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= VW_Hlin\r\n=\r\n==================\r\n*/\r\n\r\n\r\n#if GRMODE == EGAGR\r\n\r\nunsigned char leftmask[8] = {0xff,0x7f,0x3f,0x1f,0xf,7,3,1};\r\nunsigned char rightmask[8] = {0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff};\r\n\r\nvoid VW_Hlin(unsigned xl, unsigned xh, unsigned y, unsigned color)\r\n{\r\n  unsigned dest,xlb,xhb,maskleft,maskright,mid;\r\n\r\n\txlb=xl/8;\r\n\txhb=xh/8;\r\n\r\n\tEGAWRITEMODE(2);\r\n\tEGAMAPMASK(15);\r\n\r\n\tmaskleft = leftmask[xl&7];\r\n\tmaskright = rightmask[xh&7];\r\n\r\n\tmid = xhb-xlb-1;\r\n\tdest = bufferofs+ylookup[y]+xlb;\r\n\r\n  if (xlb==xhb)\r\n  {\r\n  //\r\n  // entire line is in one byte\r\n  //\r\n\r\n\tmaskleft&=maskright;\r\n\r\n\tasm\tmov\tes,[screenseg]\r\n\tasm\tmov\tdi,[dest]\r\n\r\n\tasm\tmov\tdx,GC_INDEX\r\n\tasm\tmov\tal,GC_BITMASK\r\n\tasm\tmov\tah,[BYTE PTR maskleft]\r\n\tasm\tout\tdx,ax\t\t// mask off pixels\r\n\r\n\tasm\tmov\tal,[BYTE PTR color]\r\n\tasm\txchg\tal,[es:di]\t// load latches and write pixels\r\n\r\n\tgoto\tdone;\r\n  }\r\n\r\nasm\tmov\tes,[screenseg]\r\nasm\tmov\tdi,[dest]\r\nasm\tmov\tdx,GC_INDEX\r\nasm\tmov\tbh,[BYTE PTR color]\r\n\r\n//\r\n// draw left side\r\n//\r\nasm\tmov\tal,GC_BITMASK\r\nasm\tmov\tah,[BYTE PTR maskleft]\r\nasm\tout\tdx,ax\t\t// mask off pixels\r\n\r\nasm\tmov\tal,bh\r\nasm\tmov\tbl,[es:di]\t// load latches\r\nasm\tstosb\r\n\r\n//\r\n// draw middle\r\n//\r\nasm\tmov\tax,GC_BITMASK + 255*256\r\nasm\tout\tdx,ax\t\t// no masking\r\n\r\nasm\tmov\tal,bh\r\nasm\tmov\tcx,[mid]\r\nasm\trep\tstosb\r\n\r\n//\r\n// draw right side\r\n//\r\nasm\tmov\tal,GC_BITMASK\r\nasm\tmov\tah,[BYTE PTR maskright]\r\nasm\tout\tdx,ax\t\t// mask off pixels\r\n\r\nasm\txchg\tbh,[es:di]\t// load latches and write pixels\r\n\r\ndone:\r\n\tEGABITMASK(255);\r\n\tEGAWRITEMODE(0);\r\n}\r\n#endif\r\n\r\n\r\n#if GRMODE == CGAGR\r\n\r\nunsigned char pixmask[4] = {0xc0,0x30,0x0c,0x03};\r\nunsigned char leftmask[4] = {0xff,0x3f,0x0f,0x03};\r\nunsigned char rightmask[4] = {0xc0,0xf0,0xfc,0xff};\r\nunsigned char colorbyte[4] = {0,0x55,0xaa,0xff};\r\n\r\n//\r\n// could be optimized for rep stosw\r\n//\r\nvoid VW_Hlin(unsigned xl, unsigned xh, unsigned y, unsigned color)\r\n{\r\n\tunsigned dest,xlb,xhb,mid;\r\n\tbyte maskleft,maskright;\r\n\r\n\tcolor = colorbyte[color];\t// expand 2 color bits to 8\r\n\r\n\txlb=xl/4;\r\n\txhb=xh/4;\r\n\r\n\tmaskleft = leftmask[xl&3];\r\n\tmaskright = rightmask[xh&3];\r\n\r\n\tmid = xhb-xlb-1;\r\n\tdest = bufferofs+ylookup[y]+xlb;\r\nasm\tmov\tes,[screenseg]\r\n\r\n\tif (xlb==xhb)\r\n\t{\r\n\t//\r\n\t// entire line is in one byte\r\n\t//\r\n\t\tmaskleft&=maskright;\r\n\r\n\t\tasm\tmov\tah,[maskleft]\r\n\t\tasm\tmov\tbl,[BYTE PTR color]\r\n\t\tasm\tand\tbl,[maskleft]\r\n\t\tasm\tnot\tah\r\n\r\n\t\tasm\tmov\tdi,[dest]\r\n\r\n\t\tasm\tmov\tal,[es:di]\r\n\t\tasm\tand\tal,ah\t\t\t// mask out pixels\r\n\t\tasm\tor\tal,bl\t\t\t// or in color\r\n\t\tasm\tmov\t[es:di],al\r\n\t\treturn;\r\n\t}\r\n\r\nasm\tmov\tdi,[dest]\r\nasm\tmov\tbh,[BYTE PTR color]\r\n\r\n//\r\n// draw left side\r\n//\r\nasm\tmov\tah,[maskleft]\r\nasm\tmov\tbl,bh\r\nasm\tand\tbl,[maskleft]\r\nasm\tnot\tah\r\nasm\tmov\tal,[es:di]\r\nasm\tand\tal,ah\t\t\t// mask out pixels\r\nasm\tor\tal,bl\t\t\t// or in color\r\nasm\tstosb\r\n\r\n//\r\n// draw middle\r\n//\r\nasm\tmov\tal,bh\r\nasm\tmov\tcx,[mid]\r\nasm\trep\tstosb\r\n\r\n//\r\n// draw right side\r\n//\r\nasm\tmov\tah,[maskright]\r\nasm\tmov\tbl,bh\r\nasm\tand\tbl,[maskright]\r\nasm\tnot\tah\r\nasm\tmov\tal,[es:di]\r\nasm\tand\tal,ah\t\t\t// mask out pixels\r\nasm\tor\tal,bl\t\t\t// or in color\r\nasm\tstosb\r\n}\r\n#endif\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= VW_Bar\r\n=\r\n= Pixel addressable block fill routine\r\n=\r\n==================\r\n*/\r\n\r\n#if GRMODE == CGAGR\r\n\r\nvoid VW_Bar (unsigned x, unsigned y, unsigned width, unsigned height,\r\n\tunsigned color)\r\n{\r\n\tunsigned xh = x+width-1;\r\n\r\n\twhile (height--)\r\n\t\tVW_Hlin (x,xh,y++,color);\r\n}\r\n\r\n#endif\r\n\r\n\r\n#if\tGRMODE == EGAGR\r\n\r\nvoid VW_Bar (unsigned x, unsigned y, unsigned width, unsigned height,\r\n\tunsigned color)\r\n{\r\n\tunsigned dest,xh,xlb,xhb,maskleft,maskright,mid;\r\n\r\n\txh = x+width-1;\r\n\txlb=x/8;\r\n\txhb=xh/8;\r\n\r\n\tEGAWRITEMODE(2);\r\n\tEGAMAPMASK(15);\r\n\r\n\tmaskleft = leftmask[x&7];\r\n\tmaskright = rightmask[xh&7];\r\n\r\n\tmid = xhb-xlb-1;\r\n\tdest = bufferofs+ylookup[y]+xlb;\r\n\r\n\tif (xlb==xhb)\r\n\t{\r\n\t//\r\n\t// entire line is in one byte\r\n\t//\r\n\r\n\t\tmaskleft&=maskright;\r\n\r\n\tasm\tmov\tes,[screenseg]\r\n\tasm\tmov\tdi,[dest]\r\n\r\n\tasm\tmov\tdx,GC_INDEX\r\n\tasm\tmov\tal,GC_BITMASK\r\n\tasm\tmov\tah,[BYTE PTR maskleft]\r\n\tasm\tout\tdx,ax\t\t// mask off pixels\r\n\r\n\tasm\tmov\tah,[BYTE PTR color]\r\n\tasm\tmov\tdx,[linewidth]\r\nyloop1:\r\n\tasm\tmov\tal,ah\r\n\tasm\txchg\tal,[es:di]\t// load latches and write pixels\r\n\tasm\tadd\tdi,dx\t\t\t// down to next line\r\n\tasm\tdec\t[height]\r\n\tasm\tjnz\tyloop1\r\n\r\n\t\tgoto\tdone;\r\n\t}\r\n\r\nasm\tmov\tes,[screenseg]\r\nasm\tmov\tdi,[dest]\r\nasm\tmov\tbh,[BYTE PTR color]\r\nasm\tmov\tdx,GC_INDEX\r\nasm\tmov\tsi,[linewidth]\r\nasm\tsub\tsi,[mid]\t\t\t// add to di at end of line to get to next scan\r\nasm\tdec\tsi\r\n\r\n//\r\n// draw left side\r\n//\r\nyloop2:\r\nasm\tmov\tal,GC_BITMASK\r\nasm\tmov\tah,[BYTE PTR maskleft]\r\nasm\tout\tdx,ax\t\t// mask off pixels\r\n\r\nasm\tmov\tal,bh\r\nasm\tmov\tbl,[es:di]\t// load latches\r\nasm\tstosb\r\n\r\n//\r\n// draw middle\r\n//\r\nasm\tmov\tax,GC_BITMASK + 255*256\r\nasm\tout\tdx,ax\t\t// no masking\r\n\r\nasm\tmov\tal,bh\r\nasm\tmov\tcx,[mid]\r\nasm\trep\tstosb\r\n\r\n//\r\n// draw right side\r\n//\r\nasm\tmov\tal,GC_BITMASK\r\nasm\tmov\tah,[BYTE PTR maskright]\r\nasm\tout\tdx,ax\t\t// mask off pixels\r\n\r\nasm\tmov\tal,bh\r\nasm\txchg\tal,[es:di]\t// load latches and write pixels\r\n\r\nasm\tadd\tdi,si\t\t// move to start of next line\r\nasm\tdec\t[height]\r\nasm\tjnz\tyloop2\r\n\r\ndone:\r\n\tEGABITMASK(255);\r\n\tEGAWRITEMODE(0);\r\n}\r\n\r\n#endif\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= VW_MeasureString\r\n=\r\n==================\r\n*/\r\n\r\n#if NUMFONT+NUMFONTM>0\r\nvoid\r\nVWL_MeasureString (char far *string, word *width, word *height, fontstruct _seg *font)\r\n{\r\n\t*height = font->height;\r\n\tfor (*width = 0;*string;string++)\r\n\t\t*width += font->width[*string];\t\t// proportional width\r\n}\r\n\r\nvoid\tVW_MeasurePropString (char far *string, word *width, word *height)\r\n{\r\n\tVWL_MeasureString(string,width,height,(fontstruct _seg *)grsegs[STARTFONT]);\r\n}\r\n\r\nvoid\tVW_MeasureMPropString  (char far *string, word *width, word *height)\r\n{\r\n\tVWL_MeasureString(string,width,height,(fontstruct _seg *)grsegs[STARTFONTM]);\r\n}\r\n\r\n\r\n#endif\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tCGA stuff\r\n\r\n=============================================================================\r\n*/\r\n\r\n#if GRMODE == CGAGR\r\n\r\n#define CGACRTCWIDTH\t40\r\n\r\n/*\r\n==========================\r\n=\r\n= VW_CGAFullUpdate\r\n=\r\n==========================\r\n*/\r\n\r\nvoid VW_CGAFullUpdate (void)\r\n{\r\n\tbyte\t*update;\r\n\tboolean\thalftile;\r\n\tunsigned\tx,y,middlerows,middlecollumns;\r\n\r\n\tdisplayofs = bufferofs+panadjust;\r\n\r\nasm\tmov\tax,0xb800\r\nasm\tmov\tes,ax\r\n\r\nasm\tmov\tsi,[displayofs]\r\nasm\txor\tdi,di\r\n\r\nasm\tmov\tbx,100\t\t\t\t// pairs of scan lines to copy\r\nasm\tmov\tdx,[linewidth]\r\nasm\tsub\tdx,80\r\n\r\nasm\tmov\tds,[screenseg]\r\nasm\ttest\tsi,1\r\nasm\tjz\tevenblock\r\n\r\n//\r\n// odd source\r\n//\r\nasm\tmov\tax,39\t\t\t\t// words accross screen\r\ncopytwolineso:\r\nasm\tmovsb\r\nasm\tmov\tcx,ax\r\nasm\trep\tmovsw\r\nasm\tmovsb\r\nasm\tadd\tsi,dx\r\nasm\tadd\tdi,0x2000-80\t\t// go to the interlaced bank\r\nasm\tmovsb\r\nasm\tmov\tcx,ax\r\nasm\trep\tmovsw\r\nasm\tmovsb\r\nasm\tadd\tsi,dx\r\nasm\tsub\tdi,0x2000\t\t\t// go to the non interlaced bank\r\n\r\nasm\tdec\tbx\r\nasm\tjnz\tcopytwolineso\r\nasm\tjmp\tblitdone\r\n\r\n//\r\n// even source\r\n//\r\nevenblock:\r\nasm\tmov\tax,40\t\t\t\t// words accross screen\r\ncopytwolines:\r\nasm\tmov\tcx,ax\r\nasm\trep\tmovsw\r\nasm\tadd\tsi,dx\r\nasm\tadd\tdi,0x2000-80\t\t// go to the interlaced bank\r\nasm\tmov\tcx,ax\r\nasm\trep\tmovsw\r\nasm\tadd\tsi,dx\r\nasm\tsub\tdi,0x2000\t\t\t// go to the non interlaced bank\r\n\r\nasm\tdec\tbx\r\nasm\tjnz\tcopytwolines\r\n\r\nblitdone:\r\nasm\tmov\tax,ss\r\nasm\tmov\tds,ax\r\nasm\tmov\tes,ax\r\n\r\nasm\txor\tax,ax\t\t\t\t// clear out the update matrix\r\nasm\tmov\tcx,UPDATEWIDE*UPDATEHIGH/2\r\n\r\nasm\tmov\tdi,[baseupdateptr]\r\nasm\trep\tstosw\r\n\r\n\tupdateptr = baseupdateptr;\r\n\t*(unsigned *)(updateptr + UPDATEWIDE*PORTTILESHIGH) = UPDATETERMINATE;\r\n}\r\n\r\n\r\n#endif\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t   CURSOR ROUTINES\r\n\r\nThese only work in the context of the double buffered update routines\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n====================\r\n=\r\n= VWL_DrawCursor\r\n=\r\n= Background saves, then draws the cursor at cursorspot\r\n=\r\n====================\r\n*/\r\n\r\nvoid VWL_DrawCursor (void)\r\n{\r\n\tcursorspot = bufferofs + ylookup[cursory+pansy]+(cursorx+pansx)/SCREENXDIV;\r\n\tVW_ScreenToMem(cursorspot,cursorsave,cursorwidth,cursorheight);\r\n\tVWB_DrawSprite(cursorx,cursory,cursornumber);\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= VWL_EraseCursor\r\n=\r\n====================\r\n*/\r\n\r\nvoid VWL_EraseCursor (void)\r\n{\r\n\tVW_MemToScreen(cursorsave,cursorspot,cursorwidth,cursorheight);\r\n\tVW_MarkUpdateBlock ((cursorx+pansx)&SCREENXMASK,cursory+pansy,\r\n\t\t( (cursorx+pansx)&SCREENXMASK)+cursorwidth*SCREENXDIV-1,\r\n\t\tcursory+pansy+cursorheight-1);\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= VW_ShowCursor\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_ShowCursor (void)\r\n{\r\n\tcursorvisible++;\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= VW_HideCursor\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_HideCursor (void)\r\n{\r\n\tcursorvisible--;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= VW_MoveCursor\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_MoveCursor (int x, int y)\r\n{\r\n\tcursorx = x;\r\n\tcursory = y;\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= VW_SetCursor\r\n=\r\n= Load in a sprite to be used as a cursor, and allocate background save space\r\n=\r\n====================\r\n*/\r\n\r\nvoid VW_SetCursor (int spritenum)\r\n{\r\n\tif (cursornumber)\r\n\t{\r\n\t\tMM_SetLock (&grsegs[cursornumber],false);\r\n\t\tMM_FreePtr (&cursorsave);\r\n\t}\r\n\r\n\tcursornumber = spritenum;\r\n\r\n\tCA_CacheGrChunk (spritenum);\r\n\tMM_SetLock (&grsegs[cursornumber],true);\r\n\r\n\tcursorwidth = spritetable[spritenum-STARTSPRITES].width+1;\r\n\tcursorheight = spritetable[spritenum-STARTSPRITES].height;\r\n\r\n\tMM_GetPtr (&cursorsave,cursorwidth*cursorheight*5);\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\tDouble buffer management routines\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n======================\r\n=\r\n= VW_InitDoubleBuffer\r\n=\r\n======================\r\n*/\r\n\r\nvoid VW_InitDoubleBuffer (void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tVW_SetScreen (displayofs+panadjust,0);\t\t\t// no pel pan\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= VW_FixRefreshBuffer\r\n=\r\n= Copies the view page to the buffer page on page flipped refreshes to\r\n= avoid a one frame shear around pop up windows\r\n=\r\n======================\r\n*/\r\n\r\nvoid VW_FixRefreshBuffer (void)\r\n{\r\n#if GRMODE == EGAGR\r\n\tVW_ScreenToScreen (displayofs,bufferofs,PORTTILESWIDE*4*CHARWIDTH,\r\n\t\tPORTTILESHIGH*16);\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= VW_QuitDoubleBuffer\r\n=\r\n======================\r\n*/\r\n\r\nvoid VW_QuitDoubleBuffer (void)\r\n{\r\n}\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= VW_MarkUpdateBlock\r\n=\r\n= Takes a pixel bounded block and marks the tiles in bufferblocks\r\n= Returns 0 if the entire block is off the buffer screen\r\n=\r\n=======================\r\n*/\r\n\r\nint VW_MarkUpdateBlock (int x1, int y1, int x2, int y2)\r\n{\r\n\tint\tx,y,xt1,yt1,xt2,yt2,nextline;\r\n\tbyte *mark;\r\n\r\n\txt1 = x1>>PIXTOBLOCK;\r\n\tyt1 = y1>>PIXTOBLOCK;\r\n\r\n\txt2 = x2>>PIXTOBLOCK;\r\n\tyt2 = y2>>PIXTOBLOCK;\r\n\r\n\tif (xt1<0)\r\n\t\txt1=0;\r\n\telse if (xt1>=UPDATEWIDE-1)\r\n\t\treturn 0;\r\n\r\n\tif (yt1<0)\r\n\t\tyt1=0;\r\n\telse if (yt1>UPDATEHIGH)\r\n\t\treturn 0;\r\n\r\n\tif (xt2<0)\r\n\t\treturn 0;\r\n\telse if (xt2>=UPDATEWIDE-1)\r\n\t\txt2 = UPDATEWIDE-2;\r\n\r\n\tif (yt2<0)\r\n\t\treturn 0;\r\n\telse if (yt2>=UPDATEHIGH)\r\n\t\tyt2 = UPDATEHIGH-1;\r\n\r\n\tmark = updateptr + uwidthtable[yt1] + xt1;\r\n\tnextline = UPDATEWIDE - (xt2-xt1) - 1;\r\n\r\n\tfor (y=yt1;y<=yt2;y++)\r\n\t{\r\n\t\tfor (x=xt1;x<=xt2;x++)\r\n\t\t\t*mark++ = 1;\t\t\t// this tile will need to be updated\r\n\r\n\t\tmark += nextline;\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\n\r\n/*\r\n===========================\r\n=\r\n= VW_UpdateScreen\r\n=\r\n= Updates any changed areas of the double buffer and displays the cursor\r\n=\r\n===========================\r\n*/\r\n\r\nvoid VW_UpdateScreen (void)\r\n{\r\n\tif (cursorvisible>0)\r\n\t\tVWL_DrawCursor();\r\n\r\n#if GRMODE == EGAGR\r\n\tVWL_UpdateScreenBlocks();\r\n\r\nasm\tcli\r\nasm\tmov\tcx,[displayofs]\r\nasm\tadd\tcx,[panadjust]\r\nasm\tmov\tdx,CRTC_INDEX\r\nasm\tmov\tal,0ch\t\t// start address high register\r\nasm\tout\tdx,al\r\nasm\tinc\tdx\r\nasm\tmov\tal,ch\r\nasm\tout\tdx,al\r\nasm\tdec\tdx\r\nasm\tmov\tal,0dh\t\t// start address low register\r\nasm\tout\tdx,al\r\nasm\tmov\tal,cl\r\nasm\tinc\tdx\r\nasm\tout\tdx,al\r\nasm\tsti\r\n\r\n#endif\r\n#if GRMODE == CGAGR\r\n\tVW_CGAFullUpdate();\r\n#endif\r\n\r\n\tif (cursorvisible>0)\r\n\t\tVWL_EraseCursor();\r\n}\r\n\r\n\r\n\r\nvoid VWB_DrawTile8 (int x, int y, int tile)\r\n{\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\tif (VW_MarkUpdateBlock (x&SCREENXMASK,y,(x&SCREENXMASK)+7,y+7))\r\n\t\tVW_DrawTile8 (x/SCREENXDIV,y,tile);\r\n}\r\n\r\nvoid VWB_DrawTile8M (int x, int y, int tile)\r\n{\r\n\tint xb;\r\n\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\txb = x/SCREENXDIV; \t\t\t// use intermediate because VW_DT8M is macro\r\n\tif (VW_MarkUpdateBlock (x&SCREENXMASK,y,(x&SCREENXMASK)+7,y+7))\r\n\t\tVW_DrawTile8M (xb,y,tile);\r\n}\r\n\r\nvoid VWB_DrawTile16 (int x, int y, int tile)\r\n{\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\tif (VW_MarkUpdateBlock (x&SCREENXMASK,y,(x&SCREENXMASK)+15,y+15))\r\n\t\tVW_DrawTile16 (x/SCREENXDIV,y,tile);\r\n}\r\n\r\nvoid VWB_DrawTile16M (int x, int y, int tile)\r\n{\r\n\tint xb;\r\n\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\txb = x/SCREENXDIV;\t\t// use intermediate because VW_DT16M is macro\r\n\tif (VW_MarkUpdateBlock (x&SCREENXMASK,y,(x&SCREENXMASK)+15,y+15))\r\n\t\tVW_DrawTile16M (xb,y,tile);\r\n}\r\n\r\n#if NUMPICS\r\nvoid VWB_DrawPic (int x, int y, int chunknum)\r\n{\r\n// mostly copied from drawpic\r\n\tint\tpicnum = chunknum - STARTPICS;\r\n\tmemptr source;\r\n\tunsigned dest,width,height;\r\n\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\tx/= SCREENXDIV;\r\n\r\n\tsource = grsegs[chunknum];\r\n\tdest = ylookup[y]+x+bufferofs;\r\n\twidth = pictable[picnum].width;\r\n\theight = pictable[picnum].height;\r\n\r\n\tif (VW_MarkUpdateBlock (x*SCREENXDIV,y,(x+width)*SCREENXDIV-1,y+height-1))\r\n\t\tVW_MemToScreen(source,dest,width,height);\r\n}\r\n#endif\r\n\r\n#if NUMPICM>0\r\nvoid VWB_DrawMPic(int x, int y, int chunknum)\r\n{\r\n// mostly copied from drawmpic\r\n\tint\tpicnum = chunknum - STARTPICM;\r\n\tmemptr source;\r\n\tunsigned dest,width,height;\r\n\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\tx/=SCREENXDIV;\r\n\r\n\tsource = grsegs[chunknum];\r\n\tdest = ylookup[y]+x+bufferofs;\r\n\twidth = picmtable[picnum].width;\r\n\theight = picmtable[picnum].height;\r\n\r\n\tif (VW_MarkUpdateBlock (x*SCREENXDIV,y,(x+width)*SCREENXDIV-1,y+height-1))\r\n\t\tVW_MaskBlock(source,0,dest,width,height,width*height);\r\n}\r\n#endif\r\n\r\n\r\nvoid VWB_Bar (int x, int y, int width, int height, int color)\r\n{\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\tif (VW_MarkUpdateBlock (x,y,x+width,y+height-1) )\r\n\t\tVW_Bar (x,y,width,height,color);\r\n}\r\n\r\n\r\n#if NUMFONT\r\nvoid VWB_DrawPropString\t (char far *string)\r\n{\r\n\tint x,y;\r\n\tx = px+pansx;\r\n\ty = py+pansy;\r\n\tVW_DrawPropString (string);\r\n//\tVW_MarkUpdateBlock(0,0,320,200);\r\n\tVW_MarkUpdateBlock(x,y,x+bufferwidth*8-1,y+bufferheight-1);\r\n}\r\n#endif\r\n\r\n\r\n#if NUMFONTM\r\nvoid VWB_DrawMPropString (char far *string)\r\n{\r\n\tint x,y;\r\n\tx = px+pansx;\r\n\ty = py+pansy;\r\n\tVW_DrawMPropString (string);\r\n\tVW_MarkUpdateBlock(x,y,x+bufferwidth*8-1,y+bufferheight-1);\r\n}\r\n#endif\r\n\r\n#if NUMSPRITES\r\nvoid VWB_DrawSprite(int x, int y, int chunknum)\r\n{\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg\t*block;\r\n\tunsigned\tdest,shift,width,height;\r\n\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\r\n\tspr = &spritetable[chunknum-STARTSPRITES];\r\n\tblock = (spritetype _seg *)grsegs[chunknum];\r\n\r\n\ty+=spr->orgy>>G_P_SHIFT;\r\n\tx+=spr->orgx>>G_P_SHIFT;\r\n\r\n\r\n#if GRMODE == EGAGR\r\n\tshift = (x&7)/2;\r\n#endif\r\n#if GRMODE == CGAGR\r\n\tshift = 0;\r\n#endif\r\n\r\n\tdest = bufferofs + ylookup[y];\r\n\tif (x>=0)\r\n\t\tdest += x/SCREENXDIV;\r\n\telse\r\n\t\tdest += (x+1)/SCREENXDIV;\r\n\r\n\twidth = block->width[shift];\r\n\theight = spr->height;\r\n\r\n\tif (VW_MarkUpdateBlock (x&SCREENXMASK,y,(x&SCREENXMASK)+width*SCREENXDIV-1\r\n\t\t,y+height-1))\r\n\t\tVW_MaskBlock (block,block->sourceoffset[shift],dest,\r\n\t\t\twidth,height,block->planesize[shift]);\r\n}\r\n#endif\r\n\r\nvoid VWB_Plot (int x, int y, int color)\r\n{\r\n\tx+=pansx;\r\n\ty+=pansy;\r\n\tif (VW_MarkUpdateBlock (x,y,x,y))\r\n\t\tVW_Plot(x,y,color);\r\n}\r\n\r\nvoid VWB_Hlin (int x1, int x2, int y, int color)\r\n{\r\n\tx1+=pansx;\r\n\tx2+=pansx;\r\n\ty+=pansy;\r\n\tif (VW_MarkUpdateBlock (x1,y,x2,y))\r\n\t\tVW_Hlin(x1,x2,y,color);\r\n}\r\n\r\nvoid VWB_Vlin (int y1, int y2, int x, int color)\r\n{\r\n\tx+=pansx;\r\n\ty1+=pansy;\r\n\ty2+=pansy;\r\n\tif (VW_MarkUpdateBlock (x,y1,x,y2))\r\n\t\tVW_Vlin(y1,y2,x,color);\r\n}\r\n\r\n\r\n//===========================================================================\r\n"
        },
        {
          "name": "id_vw.h",
          "type": "blob",
          "size": 8.7783203125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// ID_VW.H\r\n\r\n#ifndef __TYPES__\r\n#include \"ID_TYPES.H\"\r\n#endif\r\n\r\n#ifndef __ID_MM__\r\n#include \"ID_MM.H\"\r\n#endif\r\n\r\n#ifndef __ID_GLOB__\r\n#include \"ID_GLOB.H\"\r\n#endif\r\n\r\n#define __ID_VW__\r\n\r\n//===========================================================================\r\n\r\n#define\tG_P_SHIFT\t\t4\t// global >> ?? = pixels\r\n\r\n#if GRMODE == EGAGR\r\n#define\tSCREENWIDTH\t\t64\r\n#define CHARWIDTH\t\t1\r\n#define TILEWIDTH\t\t2\r\n#endif\r\n#if GRMODE == CGAGR\r\n#define\tSCREENWIDTH\t\t128\r\n#define CHARWIDTH\t\t2\r\n#define TILEWIDTH\t\t4\r\n#endif\r\n\r\n#define VIRTUALHEIGHT\t300\r\n#define\tVIRTUALWIDTH\t512\r\n\r\n\r\n#if GRMODE == CGAGR\r\n\r\n#define\tMAXSHIFTS\t\t1\r\n\r\n#define WHITE\t\t\t3\t\t\t// graphics mode independant colors\r\n#define BLACK\t\t\t0\r\n#define FIRSTCOLOR\t\t1\r\n#define SECONDCOLOR\t\t2\r\n#define F_WHITE\t\t\t0\t\t\t// for XOR font drawing\r\n#define F_BLACK\t\t\t3\r\n#define F_FIRSTCOLOR\t2\r\n#define F_SECONDCOLOR\t1\r\n\r\n#endif\r\n\r\n#if GRMODE == EGAGR\r\n\r\n#define\tMAXSHIFTS\t\t8\r\n\r\n#define WHITE\t\t\t15\t\t\t// graphics mode independant colors\r\n#define BLACK\t\t\t0\r\n#define FIRSTCOLOR\t\t1\r\n#define SECONDCOLOR\t\t12\r\n#define F_WHITE\t\t\t0\t\t\t// for XOR font drawing\r\n#define F_BLACK\t\t\t15\r\n#define F_FIRSTCOLOR\t14\r\n#define F_SECONDCOLOR\t3\r\n\r\n#endif\r\n\r\n//===========================================================================\r\n\r\n\r\n#define SC_INDEX\t0x3C4\r\n#define SC_RESET\t0\r\n#define SC_CLOCK\t1\r\n#define SC_MAPMASK\t2\r\n#define SC_CHARMAP\t3\r\n#define SC_MEMMODE\t4\r\n\r\n#define CRTC_INDEX\t0x3D4\r\n#define CRTC_H_TOTAL\t0\r\n#define CRTC_H_DISPEND\t1\r\n#define CRTC_H_BLANK\t2\r\n#define CRTC_H_ENDBLANK\t3\r\n#define CRTC_H_RETRACE\t4\r\n#define CRTC_H_ENDRETRACE 5\r\n#define CRTC_V_TOTAL\t6\r\n#define CRTC_OVERFLOW\t7\r\n#define CRTC_ROWSCAN\t8\r\n#define CRTC_MAXSCANLINE 9\r\n#define CRTC_CURSORSTART 10\r\n#define CRTC_CURSOREND\t11\r\n#define CRTC_STARTHIGH\t12\r\n#define CRTC_STARTLOW\t13\r\n#define CRTC_CURSORHIGH\t14\r\n#define CRTC_CURSORLOW\t15\r\n#define CRTC_V_RETRACE\t16\r\n#define CRTC_V_ENDRETRACE 17\r\n#define CRTC_V_DISPEND\t18\r\n#define CRTC_OFFSET\t19\r\n#define CRTC_UNDERLINE\t20\r\n#define CRTC_V_BLANK\t21\r\n#define CRTC_V_ENDBLANK\t22\r\n#define CRTC_MODE\t23\r\n#define CRTC_LINECOMPARE 24\r\n\r\n\r\n#define GC_INDEX\t0x3CE\r\n#define GC_SETRESET\t0\r\n#define GC_ENABLESETRESET 1\r\n#define GC_COLORCOMPARE\t2\r\n#define GC_DATAROTATE\t3\r\n#define GC_READMAP\t4\r\n#define GC_MODE\t\t5\r\n#define GC_MISCELLANEOUS 6\r\n#define GC_COLORDONTCARE 7\r\n#define GC_BITMASK\t8\r\n\r\n#define ATR_INDEX\t0x3c0\r\n#define ATR_MODE\t16\r\n#define ATR_OVERSCAN\t17\r\n#define ATR_COLORPLANEENABLE 18\r\n#define ATR_PELPAN\t19\r\n#define ATR_COLORSELECT\t20\r\n\r\n\r\n//===========================================================================\r\n\r\ntypedef enum {NOcard,MDAcard,CGAcard,EGAcard,MCGAcard,VGAcard,\r\n\t\t  HGCcard=0x80,HGCPcard,HICcard} cardtype;\r\n\r\ntypedef struct\r\n{\r\n  int\twidth,\r\n\theight,\r\n\torgx,orgy,\r\n\txl,yl,xh,yh,\r\n\tshifts;\r\n} spritetabletype;\r\n\r\ntypedef\tstruct\r\n{\r\n\tunsigned\tsourceoffset[MAXSHIFTS];\r\n\tunsigned\tplanesize[MAXSHIFTS];\r\n\tunsigned\twidth[MAXSHIFTS];\r\n\tbyte\t\tdata[];\r\n} spritetype;\t\t// the memptr for each sprite points to this\r\n\r\ntypedef struct\r\n{\r\n\tint width,height;\r\n} pictabletype;\r\n\r\n\r\ntypedef struct\r\n{\r\n\tint height;\r\n\tint location[256];\r\n\tchar width[256];\r\n} fontstruct;\r\n\r\n\r\ntypedef enum {CGAgr,EGAgr,VGAgr} grtype;\r\n\r\n//===========================================================================\r\n\r\nextern\tcardtype\tvideocard;\t\t// set by VW_Startup\r\nextern\tgrtype\t\tgrmode;\t\t\t// CGAgr, EGAgr, VGAgr\r\n\r\nextern\tunsigned\tbufferofs;\t\t// hidden port to draw to before displaying\r\nextern\tunsigned\tdisplayofs;\t\t// origin of port on visable screen\r\nextern\tunsigned\tpanx,pany;\t\t// panning adjustments inside port in pixels\r\nextern\tunsigned\tpansx,pansy;\r\nextern\tunsigned\tpanadjust;\t\t// panx/pany adjusted by screen resolution\r\n\r\nextern\tunsigned\tscreenseg;\t\t// normally 0xa000 or buffer segment\r\n\r\nextern\tunsigned\tlinewidth;\r\nextern\tunsigned\tylookup[VIRTUALHEIGHT];\r\n\r\nextern\tboolean\t\tscreenfaded;\r\n\r\nextern\tpictabletype\t_seg *pictable;\r\nextern\tpictabletype\t_seg *picmtable;\r\nextern\tspritetabletype _seg *spritetable;\r\n\r\nextern\tint\t\t\tpx,py;\r\nextern\tbyte\t\tpdrawmode,fontcolor;\r\n\r\n//\r\n// asm globals\r\n//\r\n\r\nextern\tunsigned\t**shifttabletable;\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\nvoid\tVW_Startup (void);\r\nvoid\tVW_Shutdown (void);\r\n\r\ncardtype\tVW_VideoID (void);\r\n\r\n//\r\n// EGA hardware routines\r\n//\r\n\r\n#define EGAWRITEMODE(x) asm{cli;mov dx,GC_INDEX;mov ax,GC_MODE+256*x;out dx,ax;sti;}\r\n#define EGABITMASK(x) asm{mov dx,GC_INDEX;mov ax,GC_BITMASK+256*x;out dx,ax;sti;}\r\n#define EGAMAPMASK(x) asm{cli;mov dx,SC_INDEX;mov ax,SC_MAPMASK+x*256;out dx,ax;sti;}\r\n\r\nvoid \tVW_SetLineWidth(int width);\r\nvoid \tVW_SetScreen (unsigned CRTC, unsigned pelpan);\r\n\r\nvoid\tVW_SetScreenMode (int grmode);\r\nvoid\tVW_ClearVideo (int color);\r\nvoid\tVW_WaitVBL (int number);\r\n\r\nvoid\tVW_ColorBorder (int color);\r\nvoid\tVW_SetDefaultColors(void);\r\nvoid\tVW_FadeOut(void);\r\nvoid\tVW_FadeIn(void);\r\nvoid\tVW_FadeUp(void);\r\nvoid\tVW_FadeDown(void);\r\n\r\n//\r\n// block primitives\r\n//\r\n\r\nvoid VW_MaskBlock(memptr segm,unsigned ofs,unsigned dest,\r\n\tunsigned wide,unsigned height,unsigned planesize);\r\nvoid VW_MemToScreen(memptr source,unsigned dest,unsigned width,unsigned height);\r\nvoid VW_ScreenToMem(unsigned source,memptr dest,unsigned width,unsigned height);\r\nvoid VW_ScreenToScreen(unsigned source,unsigned dest,unsigned width,unsigned height);\r\n\r\n\r\n//\r\n// block addressable routines\r\n//\r\n\r\nvoid VW_DrawTile8(unsigned x, unsigned y, unsigned tile);\r\n\r\n#if GRMODE == EGAGR\r\n\r\n#define VW_DrawTile8M(x,y,t) \\\r\n\tVW_MaskBlock(grsegs[STARTTILE8M],(t)*40,bufferofs+ylookup[y]+(x),1,8,8)\r\n#define VW_DrawTile16(x,y,t) \\\r\n\tVW_MemToScreen(grsegs[STARTTILE16+t],bufferofs+ylookup[y]+(x),2,16)\r\n#define VW_DrawTile16M(x,y,t) \\\r\n\tVW_MaskBlock(grsegs[STARTTILE16M],(t)*160,bufferofs+ylookup[y]+(x),2,16,32)\r\n\r\n#endif\r\n\r\n#if GRMODE == CGAGR\r\n\r\n#define VW_DrawTile8M(x,y,t) \\\r\n\tVW_MaskBlock(grsegs[STARTTILE8M],(t)*32,bufferofs+ylookup[y]+(x),2,8,16)\r\n#define VW_DrawTile16(x,y,t) \\\r\n\tVW_MemToScreen(grsegs[STARTTILE16+t],bufferofs+ylookup[y]+(x),4,16)\r\n#define VW_DrawTile16M(x,y,t) \\\r\n\tVW_MaskBlock(grsegs[STARTTILE16M],(t)*128,bufferofs+ylookup[y]+(x),4,16,64)\r\n\r\n#endif\r\n\r\nvoid VW_DrawPic(unsigned x, unsigned y, unsigned chunknum);\r\nvoid VW_DrawMPic(unsigned x, unsigned y, unsigned chunknum);\r\n\r\n//\r\n// pixel addressable routines\r\n//\r\nvoid\tVW_MeasurePropString (char far *string, word *width, word *height);\r\nvoid\tVW_MeasureMPropString  (char far *string, word *width, word *height);\r\n\r\nvoid VW_DrawPropString (char far *string);\r\nvoid VW_DrawMPropString (char far *string);\r\nvoid VW_DrawSprite(int x, int y, unsigned sprite);\r\nvoid VW_Plot(unsigned x, unsigned y, unsigned color);\r\nvoid VW_Hlin(unsigned xl, unsigned xh, unsigned y, unsigned color);\r\nvoid VW_Vlin(unsigned yl, unsigned yh, unsigned x, unsigned color);\r\nvoid VW_Bar (unsigned x, unsigned y, unsigned width, unsigned height,\r\n\tunsigned color);\r\n\r\n//===========================================================================\r\n\r\n//\r\n// Double buffer management routines\r\n//\r\n\r\nvoid VW_InitDoubleBuffer (void);\r\nvoid VW_FixRefreshBuffer (void);\r\nint\t VW_MarkUpdateBlock (int x1, int y1, int x2, int y2);\r\nvoid VW_UpdateScreen (void);\r\nvoid VW_CGAFullUpdate (void);\r\n\r\n//\r\n// cursor\r\n//\r\n\r\nvoid VW_ShowCursor (void);\r\nvoid VW_HideCursor (void);\r\nvoid VW_MoveCursor (int x, int y);\r\nvoid VW_SetCursor (int spritenum);\r\n\r\n//\r\n// mode independant routines\r\n// coordinates in pixels, rounded to best screen res\r\n// regions marked in double buffer\r\n//\r\n\r\nvoid VWB_DrawTile8 (int x, int y, int tile);\r\nvoid VWB_DrawTile8M (int x, int y, int tile);\r\nvoid VWB_DrawTile16 (int x, int y, int tile);\r\nvoid VWB_DrawTile16M (int x, int y, int tile);\r\nvoid VWB_DrawPic (int x, int y, int chunknum);\r\nvoid VWB_DrawMPic(int x, int y, int chunknum);\r\nvoid VWB_Bar (int x, int y, int width, int height, int color);\r\n\r\nvoid VWB_DrawPropString\t (char far *string);\r\nvoid VWB_DrawMPropString (char far *string);\r\nvoid VWB_DrawSprite (int x, int y, int chunknum);\r\nvoid VWB_Plot (int x, int y, int color);\r\nvoid VWB_Hlin (int x1, int x2, int y, int color);\r\nvoid VWB_Vlin (int y1, int y2, int x, int color);\r\n\r\n//===========================================================================\r\n"
        },
        {
          "name": "id_vw_a.asm",
          "type": "blob",
          "size": 24.6611328125,
          "content": "; Keen Dreams Source Code\r\n; Copyright (C) 2014 Javier M. Chavez\r\n;\r\n; This program is free software; you can redistribute it and/or modify\r\n; it under the terms of the GNU General Public License as published by\r\n; the Free Software Foundation; either version 2 of the License, or\r\n; (at your option) any later version.\r\n;\r\n; This program is distributed in the hope that it will be useful,\r\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n; GNU General Public License for more details.\r\n;\r\n; You should have received a copy of the GNU General Public License along\r\n; with this program; if not, write to the Free Software Foundation, Inc.,\r\n; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n\r\n; ID_VW_A.ASM\r\n\r\nIDEAL\r\nMODEL\tMEDIUM,C\r\n\r\nINCLUDE\t\"ID_ASM.EQU\"\r\n\r\nWAITFORVBL\t=\t1\t\t\t; setting to 0 causes setscreen and waitvbl\r\n\t\t\t\t\t\t\t; to skip waiting for VBL (for timing things)\r\n\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nEXTRN\tscreenseg\t\t\t:WORD\r\nEXTRN\tdrawofs\t\t\t\t:WORD\r\nEXTRN\tbufferofs\t\t\t:WORD\r\nEXTRN\tdisplayofs\t\t\t:WORD\r\nEXTRN\tdrawofs\t\t\t\t:WORD\r\nEXTRN\tpanadjust\t\t\t:WORD\r\nEXTRN\tylookup\t\t\t\t:WORD\r\nEXTRN\tlinewidth\t\t\t:WORD\r\nEXTRN\tgrsegs\t\t\t\t:WORD\r\nEXTRN\tupdateptr\t\t\t:WORD\r\nEXTRN\tblockstarts\t\t\t:WORD\t;offsets from drawofs for each update block\r\nEXTRN\tfontspace\t\t\t:WORD\r\n\r\n\r\nplanemask\tdb\t?\r\nplanenum\tdb\t?\r\nscreendest\tdw\t?\r\nlinedelta\tdw\t?\r\n\r\nLABEL shiftdata0 WORD\r\n\tdw     0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13\r\n\tdw    14,   15,   16,   17,   18,   19,   20,   21,   22,   23,   24,   25,   26,   27\r\n\tdw    28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40,   41\r\n\tdw    42,   43,   44,   45,   46,   47,   48,   49,   50,   51,   52,   53,   54,   55\r\n\tdw    56,   57,   58,   59,   60,   61,   62,   63,   64,   65,   66,   67,   68,   69\r\n\tdw    70,   71,   72,   73,   74,   75,   76,   77,   78,   79,   80,   81,   82,   83\r\n\tdw    84,   85,   86,   87,   88,   89,   90,   91,   92,   93,   94,   95,   96,   97\r\n\tdw    98,   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,  111\r\n\tdw   112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,  125\r\n\tdw   126,  127,  128,  129,  130,  131,  132,  133,  134,  135,  136,  137,  138,  139\r\n\tdw   140,  141,  142,  143,  144,  145,  146,  147,  148,  149,  150,  151,  152,  153\r\n\tdw   154,  155,  156,  157,  158,  159,  160,  161,  162,  163,  164,  165,  166,  167\r\n\tdw   168,  169,  170,  171,  172,  173,  174,  175,  176,  177,  178,  179,  180,  181\r\n\tdw   182,  183,  184,  185,  186,  187,  188,  189,  190,  191,  192,  193,  194,  195\r\n\tdw   196,  197,  198,  199,  200,  201,  202,  203,  204,  205,  206,  207,  208,  209\r\n\tdw   210,  211,  212,  213,  214,  215,  216,  217,  218,  219,  220,  221,  222,  223\r\n\tdw   224,  225,  226,  227,  228,  229,  230,  231,  232,  233,  234,  235,  236,  237\r\n\tdw   238,  239,  240,  241,  242,  243,  244,  245,  246,  247,  248,  249,  250,  251\r\n\tdw   252,  253,  254,  255\r\n\r\nLABEL shiftdata1 WORD\r\n\tdw     0,32768,    1,32769,    2,32770,    3,32771,    4,32772,    5,32773,    6,32774\r\n\tdw     7,32775,    8,32776,    9,32777,   10,32778,   11,32779,   12,32780,   13,32781\r\n\tdw    14,32782,   15,32783,   16,32784,   17,32785,   18,32786,   19,32787,   20,32788\r\n\tdw    21,32789,   22,32790,   23,32791,   24,32792,   25,32793,   26,32794,   27,32795\r\n\tdw    28,32796,   29,32797,   30,32798,   31,32799,   32,32800,   33,32801,   34,32802\r\n\tdw    35,32803,   36,32804,   37,32805,   38,32806,   39,32807,   40,32808,   41,32809\r\n\tdw    42,32810,   43,32811,   44,32812,   45,32813,   46,32814,   47,32815,   48,32816\r\n\tdw    49,32817,   50,32818,   51,32819,   52,32820,   53,32821,   54,32822,   55,32823\r\n\tdw    56,32824,   57,32825,   58,32826,   59,32827,   60,32828,   61,32829,   62,32830\r\n\tdw    63,32831,   64,32832,   65,32833,   66,32834,   67,32835,   68,32836,   69,32837\r\n\tdw    70,32838,   71,32839,   72,32840,   73,32841,   74,32842,   75,32843,   76,32844\r\n\tdw    77,32845,   78,32846,   79,32847,   80,32848,   81,32849,   82,32850,   83,32851\r\n\tdw    84,32852,   85,32853,   86,32854,   87,32855,   88,32856,   89,32857,   90,32858\r\n\tdw    91,32859,   92,32860,   93,32861,   94,32862,   95,32863,   96,32864,   97,32865\r\n\tdw    98,32866,   99,32867,  100,32868,  101,32869,  102,32870,  103,32871,  104,32872\r\n\tdw   105,32873,  106,32874,  107,32875,  108,32876,  109,32877,  110,32878,  111,32879\r\n\tdw   112,32880,  113,32881,  114,32882,  115,32883,  116,32884,  117,32885,  118,32886\r\n\tdw   119,32887,  120,32888,  121,32889,  122,32890,  123,32891,  124,32892,  125,32893\r\n\tdw   126,32894,  127,32895\r\n\r\nLABEL shiftdata2 WORD\r\n\tdw     0,16384,32768,49152,    1,16385,32769,49153,    2,16386,32770,49154,    3,16387\r\n\tdw 32771,49155,    4,16388,32772,49156,    5,16389,32773,49157,    6,16390,32774,49158\r\n\tdw     7,16391,32775,49159,    8,16392,32776,49160,    9,16393,32777,49161,   10,16394\r\n\tdw 32778,49162,   11,16395,32779,49163,   12,16396,32780,49164,   13,16397,32781,49165\r\n\tdw    14,16398,32782,49166,   15,16399,32783,49167,   16,16400,32784,49168,   17,16401\r\n\tdw 32785,49169,   18,16402,32786,49170,   19,16403,32787,49171,   20,16404,32788,49172\r\n\tdw    21,16405,32789,49173,   22,16406,32790,49174,   23,16407,32791,49175,   24,16408\r\n\tdw 32792,49176,   25,16409,32793,49177,   26,16410,32794,49178,   27,16411,32795,49179\r\n\tdw    28,16412,32796,49180,   29,16413,32797,49181,   30,16414,32798,49182,   31,16415\r\n\tdw 32799,49183,   32,16416,32800,49184,   33,16417,32801,49185,   34,16418,32802,49186\r\n\tdw    35,16419,32803,49187,   36,16420,32804,49188,   37,16421,32805,49189,   38,16422\r\n\tdw 32806,49190,   39,16423,32807,49191,   40,16424,32808,49192,   41,16425,32809,49193\r\n\tdw    42,16426,32810,49194,   43,16427,32811,49195,   44,16428,32812,49196,   45,16429\r\n\tdw 32813,49197,   46,16430,32814,49198,   47,16431,32815,49199,   48,16432,32816,49200\r\n\tdw    49,16433,32817,49201,   50,16434,32818,49202,   51,16435,32819,49203,   52,16436\r\n\tdw 32820,49204,   53,16437,32821,49205,   54,16438,32822,49206,   55,16439,32823,49207\r\n\tdw    56,16440,32824,49208,   57,16441,32825,49209,   58,16442,32826,49210,   59,16443\r\n\tdw 32827,49211,   60,16444,32828,49212,   61,16445,32829,49213,   62,16446,32830,49214\r\n\tdw    63,16447,32831,49215\r\n\r\nLABEL shiftdata3 WORD\r\n\tdw     0, 8192,16384,24576,32768,40960,49152,57344,    1, 8193,16385,24577,32769,40961\r\n\tdw 49153,57345,    2, 8194,16386,24578,32770,40962,49154,57346,    3, 8195,16387,24579\r\n\tdw 32771,40963,49155,57347,    4, 8196,16388,24580,32772,40964,49156,57348,    5, 8197\r\n\tdw 16389,24581,32773,40965,49157,57349,    6, 8198,16390,24582,32774,40966,49158,57350\r\n\tdw     7, 8199,16391,24583,32775,40967,49159,57351,    8, 8200,16392,24584,32776,40968\r\n\tdw 49160,57352,    9, 8201,16393,24585,32777,40969,49161,57353,   10, 8202,16394,24586\r\n\tdw 32778,40970,49162,57354,   11, 8203,16395,24587,32779,40971,49163,57355,   12, 8204\r\n\tdw 16396,24588,32780,40972,49164,57356,   13, 8205,16397,24589,32781,40973,49165,57357\r\n\tdw    14, 8206,16398,24590,32782,40974,49166,57358,   15, 8207,16399,24591,32783,40975\r\n\tdw 49167,57359,   16, 8208,16400,24592,32784,40976,49168,57360,   17, 8209,16401,24593\r\n\tdw 32785,40977,49169,57361,   18, 8210,16402,24594,32786,40978,49170,57362,   19, 8211\r\n\tdw 16403,24595,32787,40979,49171,57363,   20, 8212,16404,24596,32788,40980,49172,57364\r\n\tdw    21, 8213,16405,24597,32789,40981,49173,57365,   22, 8214,16406,24598,32790,40982\r\n\tdw 49174,57366,   23, 8215,16407,24599,32791,40983,49175,57367,   24, 8216,16408,24600\r\n\tdw 32792,40984,49176,57368,   25, 8217,16409,24601,32793,40985,49177,57369,   26, 8218\r\n\tdw 16410,24602,32794,40986,49178,57370,   27, 8219,16411,24603,32795,40987,49179,57371\r\n\tdw    28, 8220,16412,24604,32796,40988,49180,57372,   29, 8221,16413,24605,32797,40989\r\n\tdw 49181,57373,   30, 8222,16414,24606,32798,40990,49182,57374,   31, 8223,16415,24607\r\n\tdw 32799,40991,49183,57375\r\n\r\nLABEL shiftdata4 WORD\r\n\tdw     0, 4096, 8192,12288,16384,20480,24576,28672,32768,36864,40960,45056,49152,53248\r\n\tdw 57344,61440,    1, 4097, 8193,12289,16385,20481,24577,28673,32769,36865,40961,45057\r\n\tdw 49153,53249,57345,61441,    2, 4098, 8194,12290,16386,20482,24578,28674,32770,36866\r\n\tdw 40962,45058,49154,53250,57346,61442,    3, 4099, 8195,12291,16387,20483,24579,28675\r\n\tdw 32771,36867,40963,45059,49155,53251,57347,61443,    4, 4100, 8196,12292,16388,20484\r\n\tdw 24580,28676,32772,36868,40964,45060,49156,53252,57348,61444,    5, 4101, 8197,12293\r\n\tdw 16389,20485,24581,28677,32773,36869,40965,45061,49157,53253,57349,61445,    6, 4102\r\n\tdw  8198,12294,16390,20486,24582,28678,32774,36870,40966,45062,49158,53254,57350,61446\r\n\tdw     7, 4103, 8199,12295,16391,20487,24583,28679,32775,36871,40967,45063,49159,53255\r\n\tdw 57351,61447,    8, 4104, 8200,12296,16392,20488,24584,28680,32776,36872,40968,45064\r\n\tdw 49160,53256,57352,61448,    9, 4105, 8201,12297,16393,20489,24585,28681,32777,36873\r\n\tdw 40969,45065,49161,53257,57353,61449,   10, 4106, 8202,12298,16394,20490,24586,28682\r\n\tdw 32778,36874,40970,45066,49162,53258,57354,61450,   11, 4107, 8203,12299,16395,20491\r\n\tdw 24587,28683,32779,36875,40971,45067,49163,53259,57355,61451,   12, 4108, 8204,12300\r\n\tdw 16396,20492,24588,28684,32780,36876,40972,45068,49164,53260,57356,61452,   13, 4109\r\n\tdw  8205,12301,16397,20493,24589,28685,32781,36877,40973,45069,49165,53261,57357,61453\r\n\tdw    14, 4110, 8206,12302,16398,20494,24590,28686,32782,36878,40974,45070,49166,53262\r\n\tdw 57358,61454,   15, 4111, 8207,12303,16399,20495,24591,28687,32783,36879,40975,45071\r\n\tdw 49167,53263,57359,61455\r\n\r\nLABEL shiftdata5 WORD\r\n\tdw     0, 2048, 4096, 6144, 8192,10240,12288,14336,16384,18432,20480,22528,24576,26624\r\n\tdw 28672,30720,32768,34816,36864,38912,40960,43008,45056,47104,49152,51200,53248,55296\r\n\tdw 57344,59392,61440,63488,    1, 2049, 4097, 6145, 8193,10241,12289,14337,16385,18433\r\n\tdw 20481,22529,24577,26625,28673,30721,32769,34817,36865,38913,40961,43009,45057,47105\r\n\tdw 49153,51201,53249,55297,57345,59393,61441,63489,    2, 2050, 4098, 6146, 8194,10242\r\n\tdw 12290,14338,16386,18434,20482,22530,24578,26626,28674,30722,32770,34818,36866,38914\r\n\tdw 40962,43010,45058,47106,49154,51202,53250,55298,57346,59394,61442,63490,    3, 2051\r\n\tdw  4099, 6147, 8195,10243,12291,14339,16387,18435,20483,22531,24579,26627,28675,30723\r\n\tdw 32771,34819,36867,38915,40963,43011,45059,47107,49155,51203,53251,55299,57347,59395\r\n\tdw 61443,63491,    4, 2052, 4100, 6148, 8196,10244,12292,14340,16388,18436,20484,22532\r\n\tdw 24580,26628,28676,30724,32772,34820,36868,38916,40964,43012,45060,47108,49156,51204\r\n\tdw 53252,55300,57348,59396,61444,63492,    5, 2053, 4101, 6149, 8197,10245,12293,14341\r\n\tdw 16389,18437,20485,22533,24581,26629,28677,30725,32773,34821,36869,38917,40965,43013\r\n\tdw 45061,47109,49157,51205,53253,55301,57349,59397,61445,63493,    6, 2054, 4102, 6150\r\n\tdw  8198,10246,12294,14342,16390,18438,20486,22534,24582,26630,28678,30726,32774,34822\r\n\tdw 36870,38918,40966,43014,45062,47110,49158,51206,53254,55302,57350,59398,61446,63494\r\n\tdw     7, 2055, 4103, 6151, 8199,10247,12295,14343,16391,18439,20487,22535,24583,26631\r\n\tdw 28679,30727,32775,34823,36871,38919,40967,43015,45063,47111,49159,51207,53255,55303\r\n\tdw 57351,59399,61447,63495\r\n\r\nLABEL shiftdata6 WORD\r\n\tdw     0, 1024, 2048, 3072, 4096, 5120, 6144, 7168, 8192, 9216,10240,11264,12288,13312\r\n\tdw 14336,15360,16384,17408,18432,19456,20480,21504,22528,23552,24576,25600,26624,27648\r\n\tdw 28672,29696,30720,31744,32768,33792,34816,35840,36864,37888,38912,39936,40960,41984\r\n\tdw 43008,44032,45056,46080,47104,48128,49152,50176,51200,52224,53248,54272,55296,56320\r\n\tdw 57344,58368,59392,60416,61440,62464,63488,64512,    1, 1025, 2049, 3073, 4097, 5121\r\n\tdw  6145, 7169, 8193, 9217,10241,11265,12289,13313,14337,15361,16385,17409,18433,19457\r\n\tdw 20481,21505,22529,23553,24577,25601,26625,27649,28673,29697,30721,31745,32769,33793\r\n\tdw 34817,35841,36865,37889,38913,39937,40961,41985,43009,44033,45057,46081,47105,48129\r\n\tdw 49153,50177,51201,52225,53249,54273,55297,56321,57345,58369,59393,60417,61441,62465\r\n\tdw 63489,64513,    2, 1026, 2050, 3074, 4098, 5122, 6146, 7170, 8194, 9218,10242,11266\r\n\tdw 12290,13314,14338,15362,16386,17410,18434,19458,20482,21506,22530,23554,24578,25602\r\n\tdw 26626,27650,28674,29698,30722,31746,32770,33794,34818,35842,36866,37890,38914,39938\r\n\tdw 40962,41986,43010,44034,45058,46082,47106,48130,49154,50178,51202,52226,53250,54274\r\n\tdw 55298,56322,57346,58370,59394,60418,61442,62466,63490,64514,    3, 1027, 2051, 3075\r\n\tdw  4099, 5123, 6147, 7171, 8195, 9219,10243,11267,12291,13315,14339,15363,16387,17411\r\n\tdw 18435,19459,20483,21507,22531,23555,24579,25603,26627,27651,28675,29699,30723,31747\r\n\tdw 32771,33795,34819,35843,36867,37891,38915,39939,40963,41987,43011,44035,45059,46083\r\n\tdw 47107,48131,49155,50179,51203,52227,53251,54275,55299,56323,57347,58371,59395,60419\r\n\tdw 61443,62467,63491,64515\r\n\r\nLABEL shiftdata7 WORD\r\n\tdw     0,  512, 1024, 1536, 2048, 2560, 3072, 3584, 4096, 4608, 5120, 5632, 6144, 6656\r\n\tdw  7168, 7680, 8192, 8704, 9216, 9728,10240,10752,11264,11776,12288,12800,13312,13824\r\n\tdw 14336,14848,15360,15872,16384,16896,17408,17920,18432,18944,19456,19968,20480,20992\r\n\tdw 21504,22016,22528,23040,23552,24064,24576,25088,25600,26112,26624,27136,27648,28160\r\n\tdw 28672,29184,29696,30208,30720,31232,31744,32256,32768,33280,33792,34304,34816,35328\r\n\tdw 35840,36352,36864,37376,37888,38400,38912,39424,39936,40448,40960,41472,41984,42496\r\n\tdw 43008,43520,44032,44544,45056,45568,46080,46592,47104,47616,48128,48640,49152,49664\r\n\tdw 50176,50688,51200,51712,52224,52736,53248,53760,54272,54784,55296,55808,56320,56832\r\n\tdw 57344,57856,58368,58880,59392,59904,60416,60928,61440,61952,62464,62976,63488,64000\r\n\tdw 64512,65024,    1,  513, 1025, 1537, 2049, 2561, 3073, 3585, 4097, 4609, 5121, 5633\r\n\tdw  6145, 6657, 7169, 7681, 8193, 8705, 9217, 9729,10241,10753,11265,11777,12289,12801\r\n\tdw 13313,13825,14337,14849,15361,15873,16385,16897,17409,17921,18433,18945,19457,19969\r\n\tdw 20481,20993,21505,22017,22529,23041,23553,24065,24577,25089,25601,26113,26625,27137\r\n\tdw 27649,28161,28673,29185,29697,30209,30721,31233,31745,32257,32769,33281,33793,34305\r\n\tdw 34817,35329,35841,36353,36865,37377,37889,38401,38913,39425,39937,40449,40961,41473\r\n\tdw 41985,42497,43009,43521,44033,44545,45057,45569,46081,46593,47105,47617,48129,48641\r\n\tdw 49153,49665,50177,50689,51201,51713,52225,52737,53249,53761,54273,54785,55297,55809\r\n\tdw 56321,56833,57345,57857,58369,58881,59393,59905,60417,60929,61441,61953,62465,62977\r\n\tdw 63489,64001,64513,65025\r\n\r\nshifttabletable\tdw\tshiftdata0,shiftdata1,shiftdata2,shiftdata3\r\n\t\tdw\tshiftdata4,shiftdata5,shiftdata6,shiftdata7\r\n\r\nPUBLIC\tshifttabletable\r\n\r\n\r\n;============================================================================\r\n\r\nCODESEG\r\n\r\nIFE GRMODE-CGAGR\r\nINCLUDE\t\"ID_VW_AC.ASM\"\r\nENDIF\r\n\r\nIFE GRMODE-EGAGR\r\nINCLUDE\t\"ID_VW_AE.ASM\"\r\nENDIF\r\n\r\nIFE GRMODE-VGAGR\r\nINCLUDE\t\"ID_VW_AV.ASM\"\r\nENDIF\r\n\r\n;============================================================================\r\n;\r\n;                           MISC VIDEO ROUTINES\r\n;\r\n;============================================================================\r\n\r\n;========\r\n;\r\n; VW_WaitVBL (int number)\r\n;\r\n;========\r\n\r\nPROC\tVW_WaitVBL number:WORD\r\nPUBLIC\tVW_WaitVBL\r\n\r\nif WAITFORVBL\t\t\t\t; skip wait if profiling\r\n\r\n\tmov\tdx,STATUS_REGISTER_1\r\n\r\n\tmov\tcx,[number]\r\n\r\nwaitvbl1:\r\n\tin\tal,dx\r\n\ttest\tal,00001000b\t;look for vbl\r\n\tjnz\twaitvbl1\r\n\r\nwaitvbl2:\r\n\tin\tal,dx\r\n\ttest\tal,00001000b\t;look for vbl\r\n\tjz\twaitvbl2\r\n\r\n\tloop\twaitvbl1\r\n\r\nendif\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;===========================================================================\r\n\r\n\r\n\tMASM\r\n;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ\r\n;\r\n; Name:\tVW_VideoID\r\n;\r\n; Function:\tDetects the presence of various video subsystems\r\n;\r\n; int VideoID;\r\n;\r\n; Subsystem ID values:\r\n; \t 0  = (none)\r\n; \t 1  = MDA\r\n; \t 2  = CGA\r\n; \t 3  = EGA\r\n; \t 4  = MCGA\r\n; \t 5  = VGA\r\n; \t80h = HGC\r\n; \t81h = HGC+\r\n; \t82h = Hercules InColor\r\n;\r\n;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ\r\n\r\n;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ\r\n;\r\n; Equates\r\n;\r\n;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ\r\nVIDstruct\tSTRUC\t\t; corresponds to C data structure\r\n\r\nVideo0Type\tDB\t?\t; first subsystem type\r\nDisplay0Type\tDB\t? \t; display attached to first subsystem\r\n\r\nVideo1Type\tDB\t?\t; second subsystem type\r\nDisplay1Type\tDB\t?\t; display attached to second subsystem\r\n\r\nVIDstruct\tENDS\r\n\r\n\r\nDevice0\tEQU\tword ptr Video0Type[di]\r\nDevice1\tEQU\tword ptr Video1Type[di]\r\n\r\n\r\nMDA\tEQU\t1\t; subsystem types\r\nCGA\tEQU\t2\r\nEGA\tEQU\t3\r\nMCGA\tEQU\t4\r\nVGA\tEQU\t5\r\nHGC\tEQU\t80h\r\nHGCPlus\tEQU\t81h\r\nInColor\tEQU\t82h\r\n\r\nMDADisplay\tEQU\t1\t; display types\r\nCGADisplay\tEQU\t2\r\nEGAColorDisplay\tEQU\t3\r\nPS2MonoDisplay\tEQU\t4\r\nPS2ColorDisplay\tEQU\t5\r\n\r\nTRUE\tEQU\t1\r\nFALSE\tEQU\t0\r\n\r\n;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ\r\n;\r\n; Program\r\n;\r\n;ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ\r\n\r\nResults\tVIDstruct <>\t;results go here!\r\n\r\nEGADisplays\tDB\tCGADisplay\t; 0000b, 0001b\t(EGA switch values)\r\n\tDB\tEGAColorDisplay\t; 0010b, 0011b\r\n\tDB\tMDADisplay\t; 0100b, 0101b\r\n\tDB\tCGADisplay\t; 0110b, 0111b\r\n\tDB\tEGAColorDisplay\t; 1000b, 1001b\r\n\tDB\tMDADisplay\t; 1010b, 1011b\r\n\r\nDCCtable\tDB\t0,0\t; translate table for INT 10h func 1Ah\r\n\tDB\tMDA,MDADisplay\r\n\tDB\tCGA,CGADisplay\r\n\tDB\t0,0\r\n\tDB\tEGA,EGAColorDisplay\r\n\tDB\tEGA,MDADisplay\r\n\tDB\t0,0\r\n\tDB\tVGA,PS2MonoDisplay\r\n\tDB\tVGA,PS2ColorDisplay\r\n\tDB\t0,0\r\n\tDB\tMCGA,EGAColorDisplay\r\n\tDB\tMCGA,PS2MonoDisplay\r\n\tDB\tMCGA,PS2ColorDisplay\r\n\r\nTestSequence\tDB\tTRUE\t; this list of flags and addresses\r\n\tDW\tFindPS2\t;  determines the order in which this\r\n\t\t\t;  program looks for the various\r\nEGAflag\tDB\t?\t;  subsystems\r\n\tDW\tFindEGA\r\n\r\nCGAflag\tDB\t?\r\n\tDW\tFindCGA\r\n\r\nMonoflag\tDB\t?\r\n\tDW\tFindMono\r\n\r\nNumberOfTests\tEQU\t($-TestSequence)/3\r\n\r\n\r\nPUBLIC\tVW_VideoID\r\nVW_VideoID\tPROC\r\n\r\n\tpush\tbp\t; preserve caller registers\r\n\tmov\tbp,sp\r\n\tpush\tds\r\n\tpush\tsi\r\n\tpush\tdi\r\n\r\n\tpush\tcs\r\n\tpop\tds\r\n\tASSUME\tDS:@Code\r\n\r\n; initialize the data structure that will contain the results\r\n\r\n\tlea\tdi,Results\t; DS:DI -> start of data structure\r\n\r\n\tmov\tDevice0,0\t; zero these variables\r\n\tmov\tDevice1,0\r\n\r\n; look for the various subsystems using the subroutines whose addresses are\r\n; tabulated in TestSequence; each subroutine sets flags in TestSequence\r\n; to indicate whether subsequent subroutines need to be called\r\n\r\n\tmov\tbyte ptr CGAflag,TRUE\r\n\tmov\tbyte ptr EGAflag,TRUE\r\n\tmov\tbyte ptr Monoflag,TRUE\r\n\r\n\tmov\tcx,NumberOfTests\r\n\tmov\tsi,offset TestSequence\r\n\r\n@@L01:\tlodsb\t\t; AL := flag\r\n\ttest\tal,al\r\n\tlodsw\t\t; AX := subroutine address\r\n\tjz\t@@L02\t; skip subroutine if flag is false\r\n\r\n\tpush\tsi\r\n\tpush\tcx\r\n\tcall\tax\t; call subroutine to detect subsystem\r\n\tpop\tcx\r\n\tpop\tsi\r\n\r\n@@L02:\tloop\t@@L01\r\n\r\n; determine which subsystem is active\r\n\r\n\tcall\tFindActive\r\n\r\n\tmov\tal,Results.Video0Type\r\n\tmov\tah,0\t; was:  Results.Display0Type\r\n\r\n\tpop\tdi\t; restore caller registers and return\r\n\tpop\tsi\r\n\tpop\tds\r\n\tmov\tsp,bp\r\n\tpop\tbp\r\n\tret\r\n\r\nVW_VideoID\tENDP\r\n\r\n\r\n;\r\n; FindPS2\r\n;\r\n; This subroutine uses INT 10H function 1Ah to determine the video BIOS\r\n; Display Combination Code (DCC) for each video subsystem present.\r\n;\r\n\r\nFindPS2\tPROC\tnear\r\n\r\n\tmov\tax,1A00h\r\n\tint\t10h\t; call video BIOS for info\r\n\r\n\tcmp\tal,1Ah\r\n\tjne\t@@L13\t; exit if function not supported (i.e.,\r\n\t\t\t;  no MCGA or VGA in system)\r\n\r\n; convert BIOS DCCs into specific subsystems & displays\r\n\r\n\tmov\tcx,bx\r\n\txor\tbh,bh\t; BX := DCC for active subsystem\r\n\r\n\tor\tch,ch\r\n\tjz\t@@L11\t; jump if only one subsystem present\r\n\r\n\tmov\tbl,ch\t; BX := inactive DCC\r\n\tadd\tbx,bx\r\n\tmov\tax,[bx+offset DCCtable]\r\n\r\n\tmov\tDevice1,ax\r\n\r\n\tmov\tbl,cl\r\n\txor\tbh,bh\t; BX := active DCC\r\n\r\n@@L11:\tadd\tbx,bx\r\n\tmov\tax,[bx+offset DCCtable]\r\n\r\n\tmov\tDevice0,ax\r\n\r\n; reset flags for subsystems that have been ruled out\r\n\r\n\tmov\tbyte ptr CGAflag,FALSE\r\n\tmov\tbyte ptr EGAflag,FALSE\r\n\tmov\tbyte ptr Monoflag,FALSE\r\n\r\n\tlea\tbx,Video0Type[di]  ; if the BIOS reported an MDA ...\r\n\tcmp\tbyte ptr [bx],MDA\r\n\tje\t@@L12\r\n\r\n\tlea\tbx,Video1Type[di]\r\n\tcmp\tbyte ptr [bx],MDA\r\n\tjne\t@@L13\r\n\r\n@@L12:\tmov\tword ptr [bx],0    ; ... Hercules can't be ruled out\r\n\tmov\tbyte ptr Monoflag,TRUE\r\n\r\n@@L13:\tret\r\n\r\nFindPS2\tENDP\r\n\r\n\r\n;\r\n; FindEGA\r\n;\r\n; Look for an EGA.  This is done by making a call to an EGA BIOS function\r\n;  which doesn't exist in the default (MDA, CGA) BIOS.\r\n\r\nFindEGA\tPROC\tnear\t; Caller:\tAH = flags\r\n\t\t\t; Returns:\tAH = flags\r\n\t\t\t;\t\tVideo0Type and\r\n\t\t\t;\t\t Display0Type updated\r\n\r\n\tmov\tbl,10h\t; BL := 10h (return EGA info)\r\n\tmov\tah,12h\t; AH := INT 10H function number\r\n\tint\t10h\t; call EGA BIOS for info\r\n\t\t\t; if EGA BIOS is present,\r\n\t\t\t;  BL <> 10H\r\n\t\t\t;  CL = switch setting\r\n\tcmp\tbl,10h\r\n\tje\t@@L22\t; jump if EGA BIOS not present\r\n\r\n\tmov\tal,cl\r\n\tshr\tal,1\t; AL := switches/2\r\n\tmov\tbx,offset EGADisplays\r\n\txlat\t\t; determine display type from switches\r\n\tmov\tah,al\t; AH := display type\r\n\tmov\tal,EGA\t; AL := subystem type\r\n\tcall\tFoundDevice\r\n\r\n\tcmp\tah,MDADisplay\r\n\tje\t@@L21\t; jump if EGA has a monochrome display\r\n\r\n\tmov\tCGAflag,FALSE\t; no CGA if EGA has color display\r\n\tjmp\tshort @@L22\r\n\r\n@@L21:\tmov\tMonoflag,FALSE\t; EGA has a mono display, so MDA and\r\n\t\t\t;  Hercules are ruled out\r\n@@L22:\tret\r\n\r\nFindEGA\tENDP\r\n\r\n;\r\n; FindCGA\r\n;\r\n; This is done by looking for the CGA's 6845 CRTC at I/O port 3D4H.\r\n;\r\nFindCGA\tPROC\tnear\t; Returns:\tVIDstruct updated\r\n\r\n\tmov\tdx,3D4h\t; DX := CRTC address port\r\n\tcall\tFind6845\r\n\tjc\t@@L31\t; jump if not present\r\n\r\n\tmov\tal,CGA\r\n\tmov\tah,CGADisplay\r\n\tcall\tFoundDevice\r\n\r\n@@L31:\tret\r\n\r\nFindCGA\tENDP\r\n\r\n;\r\n; FindMono\r\n;\r\n; This is done by looking for the MDA's 6845 CRTC at I/O port 3B4H.  If\r\n; a 6845 is found, the subroutine distinguishes between an MDA\r\n; and a Hercules adapter by monitoring bit 7 of the CRT Status byte.\r\n; This bit changes on Hercules adapters but does not change on an MDA.\r\n;\r\n; The various Hercules adapters are identified by bits 4 through 6 of\r\n; the CRT Status value:\r\n;\r\n; 000b = HGC\r\n; 001b = HGC+\r\n; 101b = InColor card\r\n;\r\n\r\nFindMono\tPROC\tnear\t; Returns:\tVIDstruct updated\r\n\r\n\tmov\tdx,3B4h\t; DX := CRTC address port\r\n\tcall\tFind6845\r\n\tjc\t@@L44\t; jump if not present\r\n\r\n\tmov\tdl,0BAh\t; DX := 3BAh (status port)\r\n\tin\tal,dx\r\n\tand\tal,80h\r\n\tmov\tah,al\t; AH := bit 7 (vertical sync on HGC)\r\n\r\n\tmov\tcx,8000h\t; do this 32768 times\r\n@@L41:\tin\tal,dx\r\n\tand\tal,80h\t; isolate bit 7\r\n\tcmp\tah,al\r\n\tloope\t@@L41\t; wait for bit 7 to change\r\n\tjne\t@@L42\t; if bit 7 changed, it's a Hercules\r\n\r\n\tmov\tal,MDA\t; if bit 7 didn't change, it's an MDA\r\n\tmov\tah,MDADisplay\r\n\tcall\tFoundDevice\r\n\tjmp\tshort @@L44\r\n\r\n@@L42:\tin\tal,dx\r\n\tmov\tdl,al\t; DL := value from status port\r\n\tand\tdl,01110000b\t; mask bits 4 thru 6\r\n\r\n\tmov\tah,MDADisplay\t; assume it's a monochrome display\r\n\r\n\tmov\tal,HGCPlus\t; look for an HGC+\r\n\tcmp\tdl,00010000b\r\n\tje\t@@L43\t; jump if it's an HGC+\r\n\r\n\tmov\tal,HGC\t; look for an InColor card or HGC\r\n\tcmp\tdl,01010000b\r\n\tjne\t@@L43\t; jump if it's not an InColor card\r\n\r\n\tmov\tal,InColor\t; it's an InColor card\r\n\tmov\tah,EGAColorDisplay\r\n\r\n@@L43:\tcall\tFoundDevice\r\n\r\n@@L44:\tret\r\n\r\nFindMono\tENDP\r\n\r\n;\r\n; Find6845\r\n;\r\n; This routine detects the presence of the CRTC on a MDA, CGA or HGC.\r\n; The technique is to write and read register 0Fh of the chip (cursor\r\n; low).  If the same value is read as written, assume the chip is\r\n; present at the specified port addr.\r\n;\r\n\r\nFind6845\tPROC\tnear\t; Caller:  DX = port addr\r\n\t\t\t; Returns: cf set if not present\r\n\tmov\tal,0Fh\r\n\tout\tdx,al\t; select 6845 reg 0Fh (Cursor Low)\r\n\tinc\tdx\r\n\tin\tal,dx\t; AL := current Cursor Low value\r\n\tmov\tah,al\t; preserve in AH\r\n\tmov\tal,66h\t; AL := arbitrary value\r\n\tout\tdx,al\t; try to write to 6845\r\n\r\n\tmov\tcx,100h\r\n@@L51:\tloop\t@@L51\t; wait for 6845 to respond\r\n\r\n\tin\tal,dx\r\n\txchg\tah,al\t; AH := returned value\r\n\t\t\t; AL := original value\r\n\tout\tdx,al\t; restore original value\r\n\r\n\tcmp\tah,66h\t; test whether 6845 responded\r\n\tje\t@@L52\t; jump if it did (cf is reset)\r\n\r\n\tstc\t\t; set carry flag if no 6845 present\r\n\r\n@@L52:\tret\r\n\r\nFind6845\tENDP\r\n\r\n\r\n;\r\n; FindActive\r\n;\r\n; This subroutine stores the currently active device as Device0.  The\r\n; current video mode determines which subsystem is active.\r\n;\r\n\r\nFindActive\tPROC\tnear\r\n\r\n\tcmp\tword ptr Device1,0\r\n\tje\t@@L63\t; exit if only one subsystem\r\n\r\n\tcmp\tVideo0Type[di],4\t; exit if MCGA or VGA present\r\n\tjge\t@@L63\t;  (INT 10H function 1AH\r\n\tcmp\tVideo1Type[di],4\t;  already did the work)\r\n\tjge\t@@L63\r\n\r\n\tmov\tah,0Fh\r\n\tint\t10h\t; AL := current BIOS video mode\r\n\r\n\tand\tal,7\r\n\tcmp\tal,7\t; jump if monochrome\r\n\tje\t@@L61\t;  (mode 7 or 0Fh)\r\n\r\n\tcmp\tDisplay0Type[di],MDADisplay\r\n\tjne\t@@L63\t; exit if Display0 is color\r\n\tjmp\tshort @@L62\r\n\r\n@@L61:\tcmp\tDisplay0Type[di],MDADisplay\r\n\tje\t@@L63\t; exit if Display0 is monochrome\r\n\r\n@@L62:\tmov\tax,Device0\t; make Device0 currently active\r\n\txchg\tax,Device1\r\n\tmov\tDevice0,ax\r\n\r\n@@L63:\tret\r\n\r\nFindActive\tENDP\r\n\r\n\r\n;\r\n; FoundDevice\r\n;\r\n; This routine updates the list of subsystems.\r\n;\r\n\r\nFoundDevice\tPROC\tnear\t; Caller:    AH = display #\r\n\t\t\t;\t     AL = subsystem #\r\n\t\t\t; Destroys:  BX\r\n\tlea\tbx,Video0Type[di]\r\n\tcmp\tbyte ptr [bx],0\r\n\tje\t@@L71\t; jump if 1st subsystem\r\n\r\n\tlea\tbx,Video1Type[di]\t; must be 2nd subsystem\r\n\r\n@@L71:\tmov\t[bx],ax\t; update list entry\r\n\tret\r\n\r\nFoundDevice\tENDP\r\n\r\nIDEAL\r\n\r\n\r\n\r\nEND\r\n"
        },
        {
          "name": "id_vw_ac.asm",
          "type": "blob",
          "size": 24.462890625,
          "content": "; Keen Dreams Source Code\r\n; Copyright (C) 2014 Javier M. Chavez\r\n;\r\n; This program is free software; you can redistribute it and/or modify\r\n; it under the terms of the GNU General Public License as published by\r\n; the Free Software Foundation; either version 2 of the License, or\r\n; (at your option) any later version.\r\n;\r\n; This program is distributed in the hope that it will be useful,\r\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n; GNU General Public License for more details.\r\n;\r\n; You should have received a copy of the GNU General Public License along\r\n; with this program; if not, write to the Free Software Foundation, Inc.,\r\n; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n\r\n;=================================\r\n;\r\n; CGA view manager routines\r\n;\r\n;=================================\r\n\r\n;============================================================================\r\n;\r\n; All of these routines draw into a floating virtual screen segment in main\r\n; memory.  bufferofs points to the origin of the drawing page in screenseg.\r\n; The routines that write out words must take into account buffer wrapping\r\n; and not write a word at 0xffff (which causes an exception on 386s).\r\n;\r\n; The direction flag should be clear\r\n;\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nplotpixels\tdb\t0c0h,030h,0ch,03h\r\ncolorbyte\tdb\t000000b,01010101b,10101010b,11111111b\r\ncolorword\tdw\t0,5555h,0aaaah,0ffffh\r\n\r\nCODESEG\r\n\r\n;============================================================================\r\n;\r\n; VW_Plot (int x,y,color)\r\n;\r\n;============================================================================\r\n\r\n\r\nPROC\tVW_Plot x:WORD, y:WORD, color:WORD\r\nPUBLIC\tVW_Plot\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdi,[bufferofs]\r\n\tmov\tbx,[y]\r\n\tshl\tbx,1\r\n\tadd\tdi,[ylookup+bx]\r\n\tmov\tbx,[x]\r\n\tmov\tax,bx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\tdi,ax\t\t\t\t; di = byte on screen\r\n\r\n\tand\tbx,3\r\n\tmov\tah,[plotpixels+bx]\r\n\tmov\tbx,[color]\r\n\tmov\tcl,[colorbyte+bx]\r\n\tand\tcl,ah\r\n\tnot\tah\r\n\r\n\tmov\tal,[es:di]\r\n\tand\tal,ah\t\t\t\t; mask off other pixels\r\n\tor\tal,cl\r\n\tstosb\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_Vlin (int yl,yh,x,color)\r\n;\r\n;============================================================================\r\n\r\nPROC\tVW_Vlin yl:WORD, yh:WORD, x:WORD, color:WORD\r\nPUBLIC\tVW_Vlin\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdi,[bufferofs]\r\n\tmov\tbx,[yl]\r\n\tshl\tbx,1\r\n\tadd\tdi,[ylookup+bx]\r\n\tmov\tbx,[x]\r\n\tmov\tax,bx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\tdi,ax\t\t\t\t; di = byte on screen\r\n\r\n\tand\tbx,3\r\n\tmov\tah,[plotpixels+bx]\r\n\tmov\tbx,[color]\r\n\tmov\tbl,[colorbyte+bx]\r\n\tand\tbl,ah\r\n\tnot\tah\r\n\r\n\tmov\tcx,[yh]\r\n\tsub\tcx,[yl]\r\n\tinc\tcx\t\t\t\t\t;number of pixels to plot\r\n\r\n\tmov\tdx,[linewidth]\r\n\r\n@@plot:\r\n\tmov\tal,[es:di]\r\n\tand\tal,ah\t\t\t\t; mask off other pixels\r\n\tor\tal,bl\r\n\tmov [es:di],al\r\n\tadd\tdi,dx\r\n\tloop\t@@plot\r\n\r\n\tret\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n\r\n\r\n;===================\r\n;\r\n; VW_DrawTile8\r\n;\r\n; xcoord in bytes (8 pixels), ycoord in pixels\r\n; All Tile8s are in one grseg, so an offset is calculated inside it\r\n;\r\n; DONE\r\n;\r\n;===================\r\n\r\nPROC\tVW_DrawTile8\txcoord:WORD, ycoord:WORD, tile:WORD\r\nPUBLIC\tVW_DrawTile8\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdi,[bufferofs]\r\n\tadd\tdi,[xcoord]\r\n\tmov\tbx,[ycoord]\r\n\tshl\tbx,1\r\n\tadd\tdi,[ylookup+bx]\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,2\r\n\r\n\tmov\tsi,[tile]\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\r\n\tmov\tds,[grsegs+STARTTILE8*2] ; segment for all tile8s\r\n\r\n;\r\n; start drawing\r\n;\r\n\r\nREPT\t7\r\n\tmovsb\t\t\t\t\t\t;no word moves because of segment wrapping\r\n\tmovsb\r\n\tadd\tdi,bx\r\nENDM\r\n\tmovsb\r\n\tmovsb\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_MaskBlock\r\n;\r\n; Draws a masked block shape to the screen.  bufferofs is NOT accounted for.\r\n; The mask comes first, then the data.  Seperate unwound routines are used\r\n; to speed drawing.\r\n;\r\n; Mask blocks will allways be an even width because of the way IGRAB works\r\n;\r\n; DONE\r\n;\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nUNWOUNDMASKS\t=\t18\r\n\r\n\r\nmaskroutines\tdw\tmask0,mask0,mask2E,mask2O,mask4E,mask4O\r\n\t\t\t\tdw\tmask6E,mask6O,mask8E,mask8O,mask10E,mask10O\r\n\t\t\t\tdw\tmask12E,mask12O,mask14E,mask14O,mask16E,mask16O\r\n\t\t\t\tdw\tmask18E,mask18O\r\n\r\n\r\nroutinetouse\tdw\t?\r\n\r\nCODESEG\r\n\r\nPROC\tVW_MaskBlock\tsegm:WORD, ofs:WORD, dest:WORD, wide:WORD, height:WORD, planesize:WORD\r\nPUBLIC\tVW_MaskBlock\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdi,[wide]\r\n\tmov\tdx,[linewidth]\r\n\tsub\tdx,di\t\t\t\t\t;dx = delta to start of next line\r\n\r\n\tmov\tbx,[planesize]\t\t\t; si+bx = data location\r\n\r\n\tcmp\tdi,UNWOUNDMASKS\r\n\tjbe\t@@unwoundroutine\r\n\r\n;==============\r\n;\r\n; General purpose masked block drawing.  This could be optimised into\r\n; four routines to use words, but few play loop sprites should be this big!\r\n;\r\n;==============\r\n\r\n\tmov\t[ss:linedelta],dx\r\n\tmov\tds,[segm]\r\n\tmov\tsi,[ofs]\r\n\tmov\tdi,[dest]\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloopgen:\r\n\tmov\tcx,[wide]\r\n@@byteloop:\r\n\tmov\tal,[es:di]\r\n\tand\tal,[si]\r\n\tor\tal,[bx+si]\r\n\tinc\tsi\r\n\tstosb\r\n\tloop\t@@byteloop\r\n\r\n\tadd\tdi,[ss:linedelta]\r\n\tdec\tdx\r\n\tjnz\t@@lineloopgen\r\n\r\nmask0:\r\n\tmov\tax,ss\r\n\tmov\tds,ax\r\n\tret\t\t\t\t\t\t\t;width of 0 = no drawing\r\n\r\n\r\n;=================\r\n;\r\n; use the unwound routines\r\n;\r\n;=================\r\n\r\n@@unwoundroutine:\r\n\tshr\tdi,1\t\t\t\t\t;we only have even width unwound routines\r\n\tmov\tcx,[dest]\r\n\tshr\tcx,1\r\n\trcl\tdi,1\t\t\t\t\t;shift a 1 in if destination is odd\r\n\tshl\tdi,1\r\n\tmov\tax,[maskroutines+di]\t;call the right routine\r\n\r\n\tmov\tds,[segm]\r\n\tmov\tsi,[ofs]\r\n\tmov\tdi,[dest]\r\n\tmov\tcx,[height]\t\t\t\t;scan lines to draw\r\n\r\n\tjmp ax\t\t\t\t\t\t;draw it\r\n\r\n;=================\r\n;\r\n; Horizontally unwound routines to draw certain masked blocks faster\r\n;\r\n;=================\r\n\r\nMACRO\tMASKBYTE\r\n\tmov\tal,[es:di]\r\n\tand\tal,[si]\r\n\tor\tal,[bx+si]\r\n\tinc\tsi\r\n\tstosb\r\nENDM\r\n\r\nMACRO\tMASKWORD\r\n\tmov\tax,[es:di]\r\n\tand\tax,[si]\r\n\tor\tax,[bx+si]\r\n\tinc\tsi\r\n\tinc\tsi\r\n\tstosw\r\nENDM\r\n\r\nMACRO\tSPRITELOOP\taddr\r\n\tadd\tdi,dx\r\n\tloop\taddr\r\n\tmov\tax,ss\r\n\tmov\tds,ax\r\n\tret\r\nENDM\r\n\r\n\r\nEVEN\r\nmask2E:\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask2E\r\n\r\nEVEN\r\nmask2O:\r\n\tMASKBYTE\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask2O\r\n\r\nEVEN\r\nmask4E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask4E\r\n\r\nEVEN\r\nmask4O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask4O\r\n\r\nEVEN\r\nmask6E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask6E\r\n\r\nEVEN\r\nmask6O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask6O\r\n\r\nEVEN\r\nmask8E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask8E\r\n\r\nEVEN\r\nmask8O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask8O\r\n\r\nEVEN\r\nmask10E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask10E\r\n\r\nEVEN\r\nmask10O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask10O\r\n\r\nEVEN\r\nmask12E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask12E\r\n\r\nEVEN\r\nmask12O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask12O\r\n\r\nEVEN\r\nmask14E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask14E\r\n\r\nEVEN\r\nmask14O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask14O\r\n\r\nEVEN\r\nmask16E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask16E\r\n\r\nEVEN\r\nmask16O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask16O\r\n\r\nEVEN\r\nmask18E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask18E\r\n\r\nEVEN\r\nmask18O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask18O\r\n\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_ScreenToScreen\r\n;\r\n; Basic block copy routine.  Copies one block of screen memory to another,\r\n; bufferofs is NOT accounted for.\r\n;\r\n; DONE\r\n;\r\n;============================================================================\r\n\r\nPROC\tVW_ScreenToScreen\tsource:WORD, dest:WORD, wide:WORD, height:WORD\r\nPUBLIC\tVW_ScreenToScreen\r\nUSES\tSI,DI\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,[wide]\r\n\r\n\tmov\tax,[screenseg]\r\n\tmov\tes,ax\r\n\tmov\tds,ax\r\n\r\n\tmov\tsi,[source]\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\tmov\tax,[wide]\r\n;\r\n; if the width, source, and dest are all even, use word moves\r\n; This is allways the case in the CGA refresh\r\n;\r\n\ttest\tax,1\r\n\tjnz\t@@bytelineloop\r\n\ttest\tsi,1\r\n\tjnz\t@@bytelineloop\r\n\ttest\tdi,1\r\n\tjnz\t@@bytelineloop\r\n\r\n\tshr\tax,1\r\n@@wordlineloop:\r\n\tmov\tcx,ax\r\n\trep\tmovsw\r\n\tadd\tsi,bx\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@wordlineloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n@@bytelineloop:\r\n\tmov\tcx,ax\r\n\trep\tmovsb\r\n\tadd\tsi,bx\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@bytelineloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_MemToScreen\r\n;\r\n; Basic block drawing routine. Takes a block shape at segment pointer source\r\n; of width by height data, and draws it to dest in the virtual screen,\r\n; based on linewidth.  bufferofs is NOT accounted for.\r\n; There are four drawing routines to provide the best optimized code while\r\n; accounting for odd segment wrappings due to the floating screens.\r\n;\r\n; DONE\r\n;\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nmemtoscreentable\tdw\teventoeven,eventoodd,oddtoeven,oddtoodd\r\n\r\nCODESEG\r\n\r\n\r\nPROC\tVW_MemToScreen\tsource:WORD, dest:WORD, wide:WORD, height:WORD\r\nPUBLIC\tVW_MemToScreen\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,[wide]\r\n\r\n\tmov\tds,[source]\r\n\r\n\txor\tsi,si\t\t\t\t\t;block is segment aligned\r\n\r\n\txor\tdi,di\r\n\tshr\t[wide],1\t\t\t\t;change wide to words, and see if carry is set\r\n\trcl\tdi,1\t\t\t\t\t;1 if wide is odd\r\n\tmov\tax,[dest]\r\n\tshr\tax,1\r\n\trcl\tdi,1\t\t\t\t\t;shift a 1 in if destination is odd\r\n\tshl\tdi,1\t\t\t\t\t;to index into a word width table\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\tmov\tax,[wide]\r\n\tjmp\t[ss:memtoscreentable+di]\t;call the right routine\r\n\r\n;==============\r\n;\r\n; Copy an even width block to an even destination address\r\n;\r\n;==============\r\n\r\neventoeven:\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\nEVEN\r\n@@lineloopEE:\r\n\tmov\tcx,ax\r\n\trep\tmovsw\r\n\tadd\tdi,bx\r\n\tdec\tdx\r\n\tjnz\t@@lineloopEE\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n;==============\r\n;\r\n; Copy an odd width block to an even video address\r\n;\r\n;==============\r\n\r\noddtoeven:\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\nEVEN\r\n@@lineloopOE:\r\n\tmov\tcx,ax\r\n\trep\tmovsw\r\n\tmovsb\t\t\t\t\t\t;copy the last byte\r\n\tadd\tdi,bx\r\n\tdec\tdx\r\n\tjnz\t@@lineloopOE\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n;==============\r\n;\r\n; Copy an even width block to an odd video address\r\n;\r\n;==============\r\n\r\neventoodd:\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tdec\tax\t\t\t\t\t\t;one word has to be handled seperately\r\nEVEN\r\n@@lineloopEO:\r\n\tmovsb\r\n\tmov\tcx,ax\r\n\trep\tmovsw\r\n\tmovsb\r\n\tadd\tdi,bx\r\n\tdec\tdx\r\n\tjnz\t@@lineloopEO\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n;==============\r\n;\r\n; Copy an odd width block to an odd video address\r\n;\r\n;==============\r\n\r\noddtoodd:\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\nEVEN\r\n@@lineloopOO:\r\n\tmovsb\r\n\tmov\tcx,ax\r\n\trep\tmovsw\r\n\tadd\tdi,bx\r\n\tdec\tdx\r\n\tjnz\t@@lineloopOO\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\tret\r\n\r\n\r\nENDP\r\n\r\n;===========================================================================\r\n;\r\n; VW_ScreenToMem\r\n;\r\n; Copies a block of video memory to main memory, in order from planes 0-3.\r\n; This could be optimized along the lines of VW_MemToScreen to take advantage\r\n; of word copies, but this is an infrequently called routine.\r\n;\r\n; DONE\r\n;\r\n;===========================================================================\r\n\r\nPROC\tVW_ScreenToMem\tsource:WORD, dest:WORD, wide:WORD, height:WORD\r\nPUBLIC\tVW_ScreenToMem\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[dest]\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,[wide]\r\n\r\n\tmov\tds,[screenseg]\r\n\r\n\txor\tdi,di\r\n\r\n\tmov\tsi,[source]\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloop:\r\n\tmov\tcx,[wide]\r\n\trep\tmovsb\r\n\r\n\tadd\tsi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;===========================================================================\r\n;\r\n;                    MISC CGA ROUTINES\r\n;\r\n;===========================================================================\r\n\r\n;==============\r\n;\r\n; VW_SetScreen\r\n;\r\n; DONE\r\n;\r\n;==============\r\n\r\nPROC\tVW_SetScreen  crtc:WORD\r\nPUBLIC\tVW_SetScreen\r\n\r\n;\r\n; for some reason, my XT's EGA card doesn't like word outs to the CRTC\r\n; index...\r\n;\r\n\tcli\r\n\r\n\tmov\tcx,[crtc]\r\n\tmov\tdx,CRTC_INDEX\r\n\tmov\tal,0ch\t\t;start address high register\r\n\tout\tdx,al\r\n\tinc\tdx\r\n\tmov\tal,ch\r\n\tout\tdx,al\r\n\tdec\tdx\r\n\tmov\tal,0dh\t\t;start address low register\r\n\tout\tdx,al\r\n\tmov\tal,cl\r\n\tinc\tdx\r\n\tout\tdx,al\r\n\r\n\tsti\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\nif NUMFONT+NUMFONTM\r\n\r\n;===========================================================================\r\n;\r\n; GENERAL FONT DRAWING ROUTINES\r\n;\r\n;===========================================================================\r\n\r\nDATASEG\r\n\r\npx\tdw\t?\t\t\t\t\t; proportional character drawing coordinates\r\npy\tdw\t?\r\npdrawmode\tdb\t11000b\t\t; 8 = OR, 24 = XOR, put in GC_DATAROTATE\r\nfontcolor\tdb\t15\t\t;0-15 mapmask value\r\n\r\nPUBLIC\tpx,py,pdrawmode,fontcolor\r\n\r\n;\r\n; offsets in font structure\r\n;\r\npcharheight\t=\t0\t\t;lines high\r\ncharloc\t\t=\t2\t\t;pointers to every character\r\ncharwidth\t=\t514\t\t;every character's width in pixels\r\n\r\n\r\npropchar\tdw\t?\t\t\t; the character number to shift\r\nstringptr\tdw\t?,?\r\n\r\nfontcolormask\tdw\t?\t\t\t; font color expands into this\r\n\r\nBUFFWIDTH\t=\t100\r\nBUFFHEIGHT\t=   32\t\t\t; must be twice as high as font for masked fonts\r\n\r\ndatabuffer\tdb\tBUFFWIDTH*BUFFHEIGHT dup (?)\r\n\r\nbufferwidth\tdw\t?\t\t\t\t\t\t; bytes with valid info / line\r\nbufferheight dw\t?\t\t\t\t\t\t; number of lines currently used\r\n\r\nbufferbyte\tdw\t?\r\nbufferbit\tdw\t?\r\nPUBLIC\tbufferwidth,bufferheight,bufferbyte,bufferbit\r\n\r\nscreenspot\tdw\t?\t\t\t\t\t\t; where the buffer is going\r\n\r\nbufferextra\tdw\t?\t\t\t\t\t\t; add at end of a line copy\r\nscreenextra\tdw\t?\r\n\r\nCODESEG\r\n\r\n;======================\r\n;\r\n; Macros to table shift a byte of font\r\n;\r\n;======================\r\n\r\nMACRO\tSHIFTNOXOR\r\n\tmov\tal,[es:bx]\t\t; source\r\n\txor\tah,ah\r\n\tshl\tax,1\r\n\tmov\tsi,ax\r\n\tmov\tax,[bp+si]\t\t; table shift into two bytes\r\n\tor\t[di],al\t\t\t; or with first byte\r\n\tinc\tdi\r\n\tmov\t[di],ah\t\t\t; replace next byte\r\n\tinc\tbx\t\t\t\t; next source byte\r\nENDM\r\n\r\nMACRO\tSHIFTWITHXOR\r\n\tmov\tal,[es:bx]\t\t; source\r\n\txor\tah,ah\r\n\tshl\tax,1\r\n\tmov\tsi,ax\r\n\tmov\tax,[bp+si]\t\t; table shift into two bytes\r\n\tnot\tax\r\n\tand\t[di],al\t\t\t; and with first byte\r\n\tinc\tdi\r\n\tmov\t[di],ah\t\t\t; replace next byte\r\n\tinc\tbx\t\t\t\t; next source byte\r\nENDM\r\n\r\n\r\n;=======================\r\n;\r\n; VWL_XORBuffer\r\n;\r\n; Pass buffer start in SI (somewhere in databuffer)\r\n; Draws the buffer to the screen buffer\r\n;\r\n;========================\r\n\r\nPROC\tVWL_XORBuffer\tNEAR\r\nUSES\tBP\r\n\tmov\tbl,[fontcolor]\r\n\txor\tbh,bh\r\n\tshl\tbx,1\r\n\tmov\tax,[colorword+bx]\r\n\tmov\t[fontcolormask],ax\r\n\r\n\tmov\tes,[screenseg]\r\n\tmov\tdi,[screenspot]\r\n\r\n\tmov\tbx,[bufferwidth]\t\t;calculate offsets for end of each line\r\n\tmov\t[bufferwidth],bx\r\n\r\n\tor\tbx,bx\r\n\tjnz\t@@isthere\r\n\tret\t\t\t\t\t\t\t;nothing to draw\r\n\r\n@@isthere:\r\n\ttest\tbx,1\r\n\tjnz\t@@odd\r\n\tjmp\t@@even\r\n;\r\n; clear the last byte so word draws can be used\r\n;\r\n@@odd:\r\n\tmov\tal,0\r\nline\t=\t0\r\nREPT\tBUFFHEIGHT\r\n\tmov\t[BYTE databuffer+BUFFWIDTH*line+bx],al\r\nline\t=\tline+1\r\nENDM\r\n\r\n\tinc\tbx\r\n@@even:\r\n\tmov\tax,[linewidth]\r\n\tsub\tax,bx\r\n\tmov\t[screenextra],ax\r\n\tmov\tax,BUFFWIDTH\r\n\tsub\tax,bx\r\n\tmov\t[bufferextra],ax\r\n\tmov\tdx,bx\r\n\tshr\tdx,1\t\t\t\t\t;word to copy\r\n\r\n\tmov\tbx,[bufferheight]\t\t;lines to copy\r\n\tmov\tbp,[fontcolormask]\r\n@@lineloop:\r\n\tmov\tcx,dx\r\n@@wordloop:\r\n\tlodsw\t\t\t\t\t\t;get a word from the buffer\r\n\tand\tax,bp\r\n\txor\t[es:di],ax\t\t\t\t;draw it\r\n\tadd\tdi,2\r\n\tloop\t@@wordloop\r\n\r\n\tadd\tsi,[bufferextra]\r\n\tadd\tdi,[screenextra]\r\n\r\n\tdec\tbx\r\n\tjnz\t@@lineloop\r\n\r\n\tret\r\nENDP\r\n\r\n\r\nDATASEG\r\n\r\n;============================================================================\r\n;\r\n; NON MASKED FONT DRAWING ROUTINES\r\n;\r\n;============================================================================\r\n\r\nif numfont\r\n\r\nDATASEG\r\n\r\nshiftdrawtable\tdw      0,shift1wide,shift2wide,shift3wide,shift4wide\r\n\t\t\t\tdw\t\tshift5wide,shift6wide\r\n\r\nCODESEG\r\n\r\n;==================\r\n;\r\n; ShiftPropChar\r\n;\r\n; Call with BX = character number (0-255)\r\n; Draws one character to the buffer at bufferbyte/bufferbit, and adjusts\r\n; them to the new position\r\n;\r\n;==================\r\n\r\nPROC\tShiftPropChar\tNEAR\r\n\r\n\tmov\tes,[grsegs+STARTFONT*2]\t;segment of font to use\r\n\r\n;\r\n; find character location, width, and height\r\n;\r\n\tmov\tsi,[es:charwidth+bx]\r\n\tand\tsi,0ffh\t\t\t\t\t;SI hold width in pixels\r\n\tshl\tbx,1\r\n\tmov\tbx,[es:charloc+bx]\t\t;BX holds pointer to character data\r\n\r\n;\r\n; look up which shift table to use, based on bufferbit\r\n;\r\n\tmov\tdi,[bufferbit]\r\n\tshl\tdi,1\r\n\tmov\tbp,[shifttabletable+di]\t;BP holds pointer to shift table\r\n\r\n\tmov\tdi,OFFSET databuffer\r\n\tadd\tdi,[bufferbyte]\t\t\t;DI holds pointer to buffer\r\n\r\n\tmov\tcx,[bufferbit]\r\n\tadd\tcx,si\t\t\t\t\t;add twice because pixel == two bits\r\n\tadd\tcx,si\t\t\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\t[bufferbyte],ax\t\t\t;new byte position\r\n\r\n\tadd\tsi,3\r\n\tshr\tsi,1\r\n\tshr\tsi,1\t\t\t\t\t;bytes the character is wide\r\n\tshl\tsi,1                    ;*2 to look up in shiftdrawtable\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\tmov\tdx,BUFFWIDTH\r\n\tjmp\t[ss:shiftdrawtable+si]\t;procedure to draw this width\r\n\r\n;\r\n; one byte character\r\n;\r\nshift1wide:\r\n\tdec\tdx\r\nEVEN\r\n@@loop1:\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop1\r\n\r\n\tret\r\n\r\n;\r\n; two byte character\r\n;\r\nshift2wide:\r\n\tdec\tdx\r\n\tdec\tdx\r\nEVEN\r\n@@loop2:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop2\r\n\r\n\tret\r\n\r\n;\r\n; three byte character\r\n;\r\nshift3wide:\r\n\tsub\tdx,3\r\nEVEN\r\n@@loop3:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop3\r\n\r\n\tret\r\n\r\n\r\n;\r\n; four byte character\r\n;\r\nshift4wide:\r\n\tsub\tdx,4\r\nEVEN\r\n@@loop4:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop4\r\n\r\n\tret\r\n\r\n\r\n;\r\n; five byte character\r\n;\r\nshift5wide:\r\n\tsub\tdx,5\r\nEVEN\r\n@@loop5:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop5\r\n\r\n\tret\r\n\r\n;\r\n; six byte character\r\n;\r\nshift6wide:\r\n\tsub\tdx,6\r\nEVEN\r\n@@loop6:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop6\r\n\r\n\tret\r\n\r\n\r\n\r\nENDP\r\n\r\n;============================================================================\r\n\r\n;==================\r\n;\r\n; VW_DrawPropString\r\n;\r\n; Draws a C string of characters at px/py and advances px\r\n;\r\n;==================\r\n\r\nCODESEG\r\n\r\nPROC\tVW_DrawPropString\tstring:DWORD\r\nPUBLIC\tVW_DrawPropString\r\nUSES\tSI,DI\r\n\r\n;\r\n; proportional spaceing, which clears the buffer ahead of it, so only\r\n; clear the first collumn\r\n;\r\n\tmov\tal,0\r\nline\t=\t0\r\nREPT\tBUFFHEIGHT\r\n\tmov\t[BYTE databuffer+BUFFWIDTH*line],al\r\nline\t=\tline+1\r\nENDM\r\n\r\n;\r\n; shift the characters into the buffer\r\n;\r\n@@shiftchars:\r\n\tmov\tax,[px]\r\n\tand\tax,3\r\n\tshl\tax,1\t\t\t;one pixel == two bits\r\n\tmov\t[bufferbit],ax\r\n\tmov\t[bufferbyte],0\r\n\r\n\tmov\tax,[WORD string]\r\n\tmov\t[stringptr],ax\r\n\tmov\tax,[WORD string+2]\r\n\tmov\t[stringptr+2],ax\r\n\r\n@@shiftone:\r\n\tmov\tes,[stringptr+2]\r\n\tmov\tbx,[stringptr]\r\n\tinc\t[stringptr]\r\n\tmov\tbx,[es:bx]\r\n\txor\tbh,bh\r\n\tor\tbl,bl\r\n\tjz\t@@allshifted\r\n\tcall\tShiftPropChar\r\n\tjmp\t@@shiftone\r\n\r\n@@allshifted:\r\n;\r\n; calculate position to draw buffer on screen\r\n;\r\n\tmov\tbx,[py]\r\n\tshl\tbx,1\r\n\tmov\tdi,[ylookup+bx]\r\n\tadd\tdi,[bufferofs]\r\n\tadd\tdi,[panadjust]\r\n\r\n\tmov\tax,[px]\r\n\tshr\tax,1\r\n\tshr\tax,1\t\t;x location in bytes\r\n\tadd\tdi,ax\r\n\tmov\t[screenspot],di\r\n\r\n;\r\n; advance px\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tmov\tbx,[bufferbit]\r\n\tshr\tbx,1\t\t\t;two bits == one pixel\r\n\tor\tax,bx\r\n\tadd\t[px],ax\r\n\r\n;\r\n; draw it\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\ttest\t[bufferbit],7\r\n\tjz\t@@go\r\n\tinc\tax\t\t\t\t;so the partial byte also gets drawn\r\n@@go:\r\n\tmov\t[bufferwidth],ax\r\n\tmov\tes,[grsegs+STARTFONT*2]\r\n\tmov\tax,[es:pcharheight]\r\n\tmov\t[bufferheight],ax\r\n\r\n\tmov\tsi,OFFSET databuffer\r\n\tcall\tVWL_XORBuffer\r\n\r\n\tret\r\n\r\nENDP\r\n\r\nendif\t;numfont\r\n\r\n;============================================================================\r\n;\r\n; MASKED FONT DRAWING ROUTINES\r\n;\r\n;============================================================================\r\n\r\nif\tnumfontm\r\n\r\nDATASEG\r\n\r\nmshiftdrawtable\tdw      0,mshift1wide,mshift2wide,mshift3wide\r\n\r\n\r\nCODESEG\r\n\r\n;==================\r\n;\r\n; ShiftMPropChar\r\n;\r\n; Call with BX = character number (0-255)\r\n; Draws one character to the buffer at bufferbyte/bufferbit, and adjusts\r\n; them to the new position\r\n;\r\n;==================\r\n\r\nPROC\tShiftMPropChar\tNEAR\r\n\r\n\tmov\tes,[grsegs+STARTFONTM*2]\t;segment of font to use\r\n\r\n;\r\n; find character location, width, and height\r\n;\r\n\tmov\tsi,[es:charwidth+bx]\r\n\tand\tsi,0ffh\t\t\t\t\t;SI hold width in pixels\r\n\tshl\tbx,1\r\n\tmov\tbx,[es:charloc+bx]\t\t;BX holds pointer to character data\r\n\r\n;\r\n; look up which shift table to use, based on bufferbit\r\n;\r\n\tmov\tdi,[bufferbit]\r\n\tshl\tdi,1\r\n\tmov\tbp,[shifttabletable+di]\t;BP holds pointer to shift table\r\n\r\n\tmov\tdi,OFFSET databuffer\r\n\tadd\tdi,[bufferbyte]\t\t\t;DI holds pointer to buffer\r\n\r\n;\r\n; advance position by character width\r\n;\r\n\tmov\tcx,[bufferbit]\r\n\tadd\tcx,si\t\t\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\t[bufferbyte],ax\t\t\t;new byte position\r\n\r\n\tadd\tsi,7\r\n\tshr\tsi,1\r\n\tshr\tsi,1\r\n\tshr\tsi,1\t\t\t\t\t;bytes the character is wide\r\n\tshl\tsi,1                    ;*2 to look up in shiftdrawtable\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\tmov\tdx,BUFFWIDTH\r\n\tjmp\t[ss:mshiftdrawtable+si]\t;procedure to draw this width\r\n\r\n;\r\n; one byte character\r\n;\r\nmshift1wide:\r\n\tdec\tdx\r\n\r\nEVEN\r\n@@loop1m:\r\n\tSHIFTWITHXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop1m\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\r\nEVEN\r\n@@loop1:\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\tloop\t@@loop1\r\n\r\n\tret\r\n\r\n;\r\n; two byte character\r\n;\r\nmshift2wide:\r\n\tdec\tdx\r\n\tdec\tdx\r\nEVEN\r\n@@loop2m:\r\n\tSHIFTWITHXOR\r\n\tSHIFTWITHXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop2m\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\r\nEVEN\r\n@@loop2:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\tloop\t@@loop2\r\n\r\n\tret\r\n\r\n;\r\n; three byte character\r\n;\r\nmshift3wide:\r\n\tsub\tdx,3\r\nEVEN\r\n@@loop3m:\r\n\tSHIFTWITHXOR\r\n\tSHIFTWITHXOR\r\n\tSHIFTWITHXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop3m\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\r\nEVEN\r\n@@loop3:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\tloop\t@@loop3\r\n\r\n\tret\r\n\r\n\r\nENDP\r\n\r\n;============================================================================\r\n\r\n;==================\r\n;\r\n; VW_DrawMPropString\r\n;\r\n; Draws a C string of characters at px/py and advances px\r\n;\r\n;==================\r\n\r\n\r\n\r\nPROC\tVW_DrawMPropString\tstring:DWORD\r\nPUBLIC\tVW_DrawMPropString\r\nUSES\tSI,DI\r\n\r\n;\r\n; clear out the first byte of the buffer, the rest will automatically be\r\n; cleared as characters are drawn into it\r\n;\r\n\tmov\tes,[grsegs+STARTFONTM*2]\r\n\tmov\tdx,[es:pcharheight]\r\n\tmov\tdi,OFFSET databuffer\r\n\tmov\tax,ds\r\n\tmov\tes,ax\r\n\tmov\tbx,BUFFWIDTH-1\r\n\r\n\tmov\tcx,dx\r\n\tmov\tal,0ffh\r\n@@maskfill:\r\n\tstosb\t\t\t\t; fill the mask part with $ff\r\n\tadd\tdi,bx\r\n\tloop\t@@maskfill\r\n\r\n\tmov\tcx,dx\r\n\txor\tal,al\r\n@@datafill:\r\n\tstosb\t\t\t\t; fill the data part with $0\r\n\tadd\tdi,bx\r\n\tloop\t@@datafill\r\n\r\n;\r\n; shift the characters into the buffer\r\n;\r\n\tmov\tax,[px]\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\r\n\tmov\t[bufferbyte],0\r\n\r\n\tmov\tax,[WORD string]\r\n\tmov\t[stringptr],ax\r\n\tmov\tax,[WORD string+2]\r\n\tmov\t[stringptr+2],ax\r\n\r\n@@shiftone:\r\n\tmov\tes,[stringptr+2]\r\n\tmov\tbx,[stringptr]\r\n\tinc\t[stringptr]\r\n\tmov\tbx,[es:bx]\r\n\txor\tbh,bh\r\n\tor\tbl,bl\r\n\tjz\t@@allshifted\r\n\tcall\tShiftMPropChar\r\n\tjmp\t@@shiftone\r\n\r\n@@allshifted:\r\n;\r\n; calculate position to draw buffer on screen\r\n;\r\n\tmov\tbx,[py]\r\n\tshl\tbx,1\r\n\tmov\tdi,[ylookup+bx]\r\n\tadd\tdi,[bufferofs]\r\n\r\n\tmov\tax,[px]\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\t\t;x location in bytes\r\n\tadd\tdi,ax\r\n\tmov\t[screenspot],di\r\n\r\n;\r\n; advance px\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tor\tax,[bufferbit]\r\n\tadd\t[px],ax\r\n\r\n;\r\n; draw it\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\ttest\t[bufferbit],7\r\n\tjz\t@@go\r\n\tinc\tax\t\t\t\t;so the partial byte also gets drawn\r\n@@go:\r\n\tmov\t[bufferwidth],ax\r\n\tmov\tes,[grsegs+STARTFONTM*2]\r\n\tmov\tax,[es:pcharheight]\r\n\tmov\t[bufferheight],ax\r\n\r\n\tmov\tsi,OFFSET databuffer\r\n\tcall\tBufferToScreen\t\t; cut out mask\r\n\t\t\t\t\t\t\t\t; or in data\r\n\tcall\tBufferToScreen\t\t; SI is still in the right position in buffer\r\n\r\n\tret\r\n\r\nENDP\r\n\r\nendif\t\t; if numfontm\r\n\r\nendif\t\t; if fonts\r\n"
        },
        {
          "name": "id_vw_ae.asm",
          "type": "blob",
          "size": 29.4462890625,
          "content": "; Keen Dreams Source Code\r\n; Copyright (C) 2014 Javier M. Chavez\r\n;\r\n; This program is free software; you can redistribute it and/or modify\r\n; it under the terms of the GNU General Public License as published by\r\n; the Free Software Foundation; either version 2 of the License, or\r\n; (at your option) any later version.\r\n;\r\n; This program is distributed in the hope that it will be useful,\r\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n; GNU General Public License for more details.\r\n;\r\n; You should have received a copy of the GNU General Public License along\r\n; with this program; if not, write to the Free Software Foundation, Inc.,\r\n; 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n\r\n;=================================\r\n;\r\n; EGA view manager routines\r\n;\r\n;=================================\r\n\r\n;============================================================================\r\n;\r\n; All EGA drawing routines that write out words need to have alternate forms\r\n; for starting on even and odd addresses, because writing a word at segment\r\n; offset 0xffff causes an exception!  To work around this, write a single\r\n; byte out to make the address even, so it wraps cleanly at the end.\r\n;\r\n; All of these routines assume read/write mode 0, and will allways return\r\n; in that state.\r\n; The direction flag should be clear\r\n; readmap/writemask is left in an undefined state\r\n;\r\n;============================================================================\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_Plot (int x,y,color)\r\n;\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nplotpixels\tdb\t128,64,32,16,8,4,2,1\r\n\r\nCODESEG\r\n\r\nPROC\tVW_Plot x:WORD, y:WORD, color:WORD\r\nPUBLIC\tVW_Plot\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK+15*256\r\n\tWORDOUT\r\n\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_MODE+2*256\t;write mode 2\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[bufferofs]\r\n\tmov\tbx,[y]\r\n\tshl\tbx,1\r\n\tadd\tdi,[ylookup+bx]\r\n\tmov\tbx,[x]\r\n\tmov\tax,bx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\tdi,ax\t\t\t\t; di = byte on screen\r\n\r\n\tand\tbx,7\r\n\tmov\tah,[plotpixels+bx]\r\n\tmov\tal,GC_BITMASK\t\t;mask off other pixels\r\n\tWORDOUT\r\n\r\n\tmov\t\tbl,[BYTE color]\r\n\txchg\tbl,[es:di]\t\t; load latches and write pixel\r\n\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tah,0ffh\t\t\t\t;no bit mask\r\n\tWORDOUT\r\n\tmov\tax,GC_MODE+0*256\t;write mode 0\r\n\tWORDOUT\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_Vlin (int yl,yh,x,color)\r\n;\r\n;============================================================================\r\n\r\nPROC\tVW_Vlin yl:WORD, yh:WORD, x:WORD, color:WORD\r\nPUBLIC\tVW_Vlin\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK+15*256\r\n\tWORDOUT\r\n\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_MODE+2*256\t;write mode 2\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[bufferofs]\r\n\tmov\tbx,[yl]\r\n\tshl\tbx,1\r\n\tadd\tdi,[ylookup+bx]\r\n\tmov\tbx,[x]\r\n\tmov\tax,bx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\tdi,ax\t\t\t\t; di = byte on screen\r\n\r\n\tand\tbx,7\r\n\tmov\tah,[plotpixels+bx]\r\n\tmov\tal,GC_BITMASK\t\t;mask off other pixels\r\n\tWORDOUT\r\n\r\n\tmov\tcx,[yh]\r\n\tsub\tcx,[yl]\r\n\tinc\tcx\t\t\t\t\t;number of pixels to plot\r\n\r\n\tmov\tbh,[BYTE color]\r\n\tmov\tdx,[linewidth]\r\n\r\n@@plot:\r\n\tmov\t\tbl,bh\r\n\txchg\tbl,[es:di]\t\t; load latches and write pixel\r\n\tadd\t\tdi,dx\r\n\r\n\tloop\t@@plot\r\n\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tah,0ffh\t\t\t\t;no bit mask\r\n\tWORDOUT\r\n\tmov\tax,GC_MODE+0*256\t;write mode 0\r\n\tWORDOUT\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n\r\n\r\n;===================\r\n;\r\n; VW_DrawTile8\r\n;\r\n; xcoord in bytes (8 pixels), ycoord in pixels\r\n; All Tile8s are in one grseg, so an offset is calculated inside it\r\n;\r\n;===================\r\n\r\nPROC\tVW_DrawTile8\txcoord:WORD, ycoord:WORD, tile:WORD\r\nPUBLIC\tVW_DrawTile8\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tdi,[bufferofs]\r\n\tadd\tdi,[xcoord]\r\n\tmov\tbx,[ycoord]\r\n\tshl\tbx,1\r\n\tadd\tdi,[ylookup+bx]\r\n\tmov\t[ss:screendest],di\t\t;screen destination\r\n\r\n\tmov\tbx,[linewidth]\r\n\tdec\tbx\r\n\r\n\tmov\tsi,[tile]\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\tshl\tsi,1\r\n\r\n\tmov\tds,[grsegs+STARTTILE8*2] ; segment for all tile8s\r\n\r\n\tmov\tcx,4\t\t\t\t\t;planes to draw\r\n\tmov\tah,0001b\t\t\t\t;map mask\r\n\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tal,SC_MAPMASK\r\n\r\n;\r\n; start drawing\r\n;\r\n\r\n@@planeloop:\r\n\tWORDOUT\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\r\n\tmov\tdi,[ss:screendest]\t\t;start at same place in all planes\r\n\r\nREPT\t7\r\n\tmovsb\r\n\tadd\tdi,bx\r\nENDM\r\n\tmovsb\r\n\r\n\tloop\t@@planeloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_MaskBlock\r\n;\r\n; Draws a masked block shape to the screen.  bufferofs is NOT accounted for.\r\n; The mask comes first, then four planes of data.\r\n;\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nUNWOUNDMASKS\t=\t10\r\n\r\n\r\nmaskroutines\tdw\tmask0,mask0,mask1E,mask1E,mask2E,mask2O,mask3E,mask3O\r\n\t\t\t\tdw\tmask4E,mask4O,mask5E,mask5O,mask6E,mask6O\r\n\t\t\t\tdw\tmask7E,mask7O,mask8E,mask8O,mask9E,mask9O\r\n\t\t\t\tdw\tmask10E,mask10O\r\n\r\n\r\nroutinetouse\tdw\t?\r\n\r\nCODESEG\r\n\r\nPROC\tVW_MaskBlock\tsegm:WORD, ofs:WORD, dest:WORD, wide:WORD, height:WORD, planesize:WORD\r\nPUBLIC\tVW_MaskBlock\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\t[BYTE planemask],1\r\n\tmov\t[BYTE planenum],0\r\n\r\n\tmov\tdi,[wide]\r\n\tmov\tdx,[linewidth]\r\n\tsub\tdx,[wide]\r\n\tmov\t[linedelta],dx\t\t\t;amount to add after drawing each line\r\n\r\n\tmov\tbx,[planesize]\t\t\t; si+bx = data location\r\n\r\n\tcmp\tdi,UNWOUNDMASKS\r\n\tjbe\t@@unwoundroutine\r\n\tmov\t[routinetouse],OFFSET generalmask\r\n\tjmp\tNEAR @@startloop\r\n\r\n;=================\r\n;\r\n; use the unwound routines\r\n;\r\n;=================\r\n\r\n@@unwoundroutine:\r\n\tmov\tcx,[dest]\r\n\tshr\tcx,1\r\n\trcl\tdi,1\t\t\t\t\t;shift a 1 in if destination is odd\r\n\tshl\tdi,1\t\t\t\t\t;to index into a word width table\r\n\tmov\tax,[maskroutines+di]\t;call the right routine\r\n\tmov\t[routinetouse],ax\r\n\r\n@@startloop:\r\n\tmov\tds,[segm]\r\n\r\n@@drawplane:\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tal,SC_MAPMASK\r\n\tmov\tah,[ss:planemask]\r\n\tWORDOUT\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tal,GC_READMAP\r\n\tmov\tah,[ss:planenum]\r\n\tWORDOUT\r\n\r\n\tmov\tsi,[ofs]\t\t\t\t;start back at the top of the mask\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tcx,[height]\t\t\t\t;scan lines to draw\r\n\tmov dx,[ss:linedelta]\r\n\r\n\tjmp [ss:routinetouse]\t\t;draw one plane\r\nplanereturn:\t\t\t\t\t;routine jmps back here\r\n\r\n\tadd\tbx,[ss:planesize]\t\t;start of mask = start of next plane\r\n\r\n\tinc\t[ss:planenum]\r\n\tshl\t[ss:planemask],1\t\t;shift plane mask over for next plane\r\n\tcmp\t[ss:planemask],10000b\t;done all four planes?\r\n\tjne\t@@drawplane\r\n\r\nmask0:\r\n\tmov\tax,ss\r\n\tmov\tds,ax\r\n\tret\t\t\t\t\t\t\t;width of 0 = no drawing\r\n\r\n;==============\r\n;\r\n; General purpose masked block drawing.  This could be optimised into\r\n; four routines to use words, but few play loop sprites should be this big!\r\n;\r\n;==============\r\n\r\ngeneralmask:\r\n\tmov\tdx,cx\r\n\r\n@@lineloopgen:\r\n\tmov\tcx,[wide]\r\n@@byteloop:\r\n\tmov\tal,[es:di]\r\n\tand\tal,[si]\r\n\tor\tal,[bx+si]\r\n\tinc\tsi\r\n\tstosb\r\n\tloop\t@@byteloop\r\n\r\n\tadd\tdi,[ss:linedelta]\r\n\tdec\tdx\r\n\tjnz\t@@lineloopgen\r\n\tjmp\tplanereturn\r\n\r\n;=================\r\n;\r\n; Horizontally unwound routines to draw certain masked blocks faster\r\n;\r\n;=================\r\n\r\nMACRO\tMASKBYTE\r\n\tmov\tal,[es:di]\r\n\tand\tal,[si]\r\n\tor\tal,[bx+si]\r\n\tinc\tsi\r\n\tstosb\r\nENDM\r\n\r\nMACRO\tMASKWORD\r\n\tmov\tax,[es:di]\r\n\tand\tax,[si]\r\n\tor\tax,[bx+si]\r\n\tinc\tsi\r\n\tinc\tsi\r\n\tstosw\r\nENDM\r\n\r\nMACRO\tSPRITELOOP\taddr\r\n\tadd\tdi,dx\r\n\tloop\taddr\r\n\tjmp\tplanereturn\r\nENDM\r\n\r\n\r\nEVEN\r\nmask1E:\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask1E\r\n\r\nEVEN\r\nmask2E:\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask2E\r\n\r\nEVEN\r\nmask2O:\r\n\tMASKBYTE\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask2O\r\n\r\nEVEN\r\nmask3E:\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask3E\r\n\r\nEVEN\r\nmask3O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask3O\r\n\r\nEVEN\r\nmask4E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask4E\r\n\r\nEVEN\r\nmask4O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask4O\r\n\r\nEVEN\r\nmask5E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask5E\r\n\r\nEVEN\r\nmask5O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask5O\r\n\r\nEVEN\r\nmask6E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask6E\r\n\r\nEVEN\r\nmask6O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask6O\r\n\r\nEVEN\r\nmask7E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask7E\r\n\r\nEVEN\r\nmask7O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask7O\r\n\r\nEVEN\r\nmask8E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask8E\r\n\r\nEVEN\r\nmask8O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask8O\r\n\r\nEVEN\r\nmask9E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask9E\r\n\r\nEVEN\r\nmask9O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask9O\r\n\r\nEVEN\r\nmask10E:\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tSPRITELOOP\tmask10E\r\n\r\nEVEN\r\nmask10O:\r\n\tMASKBYTE\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKWORD\r\n\tMASKBYTE\r\n\tSPRITELOOP\tmask10O\r\n\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_ScreenToScreen\r\n;\r\n; Basic block copy routine.  Copies one block of screen memory to another,\r\n; using write mode 1 (sets it and returns with write mode 0).  bufferofs is\r\n; NOT accounted for.\r\n;\r\n;============================================================================\r\n\r\nPROC\tVW_ScreenToScreen\tsource:WORD, dest:WORD, wide:WORD, height:WORD\r\nPUBLIC\tVW_ScreenToScreen\r\nUSES\tSI,DI\r\n\r\n\tpushf\r\n\tcli\r\n\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK+15*256\r\n\tWORDOUT\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_MODE+1*256\r\n\tWORDOUT\r\n\r\n\tpopf\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,[wide]\r\n\r\n\tmov\tax,[screenseg]\r\n\tmov\tes,ax\r\n\tmov\tds,ax\r\n\r\n\tmov\tsi,[source]\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\tmov\tax,[wide]\r\n\r\n@@lineloop:\r\n\tmov\tcx,ax\r\n\trep\tmovsb\r\n\tadd\tsi,bx\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloop\r\n\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_MODE+0*256\r\n\tWORDOUT\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VW_MemToScreen\r\n;\r\n; Basic block drawing routine. Takes a block shape at segment pointer source\r\n; with four planes of width by height data, and draws it to dest in the\r\n; virtual screen, based on linewidth.  bufferofs is NOT accounted for.\r\n; There are four drawing routines to provide the best optimized code while\r\n; accounting for odd segment wrappings due to the floating screens.\r\n;\r\n;============================================================================\r\n\r\nDATASEG\r\n\r\nmemtoscreentable\tdw\teventoeven,eventoodd,oddtoeven,oddtoodd\r\n\r\nCODESEG\r\n\r\n\r\nPROC\tVW_MemToScreen\tsource:WORD, dest:WORD, wide:WORD, height:WORD\r\nPUBLIC\tVW_MemToScreen\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[screenseg]\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,[wide]\r\n\r\n\tmov\tds,[source]\r\n\r\n\r\n\txor\tsi,si\t\t\t\t\t;block is segment aligned\r\n\r\n\txor\tdi,di\r\n\tshr\t[wide],1\t\t\t\t;change wide to words, and see if carry is set\r\n\trcl\tdi,1\t\t\t\t\t;1 if wide is odd\r\n\tmov\tax,[dest]\r\n\tshr\tax,1\r\n\trcl\tdi,1\t\t\t\t\t;shift a 1 in if destination is odd\r\n\tshl\tdi,1\t\t\t\t\t;to index into a word width table\r\n\tmov\tax,SC_MAPMASK+0001b*256\t;map mask for plane 0\r\n\tjmp\t[ss:memtoscreentable+di]\t;call the right routine\r\n\r\n;==============\r\n;\r\n; Copy an even width block to an even video address\r\n;\r\n;==============\r\n\r\neventoeven:\r\n\tmov\tdx,SC_INDEX\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloopEE:\r\n\tmov\tcx,[wide]\r\n\trep\tmovsw\r\n\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloopEE\r\n\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\tcmp\tah,10000b\t\t\t\t;done all four planes?\r\n\tjne\teventoeven\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n;==============\r\n;\r\n; Copy an odd width block to an even video address\r\n;\r\n;==============\r\n\r\noddtoeven:\r\n\tmov\tdx,SC_INDEX\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloopOE:\r\n\tmov\tcx,[wide]\r\n\trep\tmovsw\r\n\tmovsb\t\t\t\t\t\t;copy the last byte\r\n\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloopOE\r\n\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\tcmp\tah,10000b\t\t\t\t;done all four planes?\r\n\tjne\toddtoeven\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n;==============\r\n;\r\n; Copy an even width block to an odd video address\r\n;\r\n;==============\r\n\r\neventoodd:\r\n\tdec\t[wide]\t\t\t\t\t;one word has to be handled seperately\r\nEOplaneloop:\r\n\tmov\tdx,SC_INDEX\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloopEO:\r\n\tmovsb\r\n\tmov\tcx,[wide]\r\n\trep\tmovsw\r\n\tmovsb\r\n\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloopEO\r\n\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\tcmp\tah,10000b\t\t\t\t;done all four planes?\r\n\tjne\tEOplaneloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n;==============\r\n;\r\n; Copy an odd width block to an odd video address\r\n;\r\n;==============\r\n\r\noddtoodd:\r\n\tmov\tdx,SC_INDEX\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[dest]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloopOO:\r\n\tmovsb\r\n\tmov\tcx,[wide]\r\n\trep\tmovsw\r\n\r\n\tadd\tdi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloopOO\r\n\r\n\tshl\tah,1\t\t\t\t\t;shift plane mask over for next plane\r\n\tcmp\tah,10000b\t\t\t\t;done all four planes?\r\n\tjne\toddtoodd\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\n\r\nENDP\r\n\r\n;===========================================================================\r\n;\r\n; VW_ScreenToMem\r\n;\r\n; Copies a block of video memory to main memory, in order from planes 0-3.\r\n; This could be optimized along the lines of VW_MemToScreen to take advantage\r\n; of word copies, but this is an infrequently called routine.\r\n;\r\n;===========================================================================\r\n\r\nPROC\tVW_ScreenToMem\tsource:WORD, dest:WORD, wide:WORD, height:WORD\r\nPUBLIC\tVW_ScreenToMem\r\nUSES\tSI,DI\r\n\r\n\tmov\tes,[dest]\r\n\r\n\tmov\tbx,[linewidth]\r\n\tsub\tbx,[wide]\r\n\r\n\tmov\tds,[screenseg]\r\n\r\n\tmov\tax,GC_READMAP\t\t\t;read map for plane 0\r\n\r\n\txor\tdi,di\r\n\r\n@@planeloop:\r\n\tmov\tdx,GC_INDEX\r\n\tWORDOUT\r\n\r\n\tmov\tsi,[source]\t\t\t\t;start at same place in all planes\r\n\tmov\tdx,[height]\t\t\t\t;scan lines to draw\r\n\r\n@@lineloop:\r\n\tmov\tcx,[wide]\r\n\trep\tmovsb\r\n\r\n\tadd\tsi,bx\r\n\r\n\tdec\tdx\r\n\tjnz\t@@lineloop\r\n\r\n\tinc\tah\r\n\tcmp\tah,4\t\t\t\t\t;done all four planes?\r\n\tjne\t@@planeloop\r\n\r\n\tmov\tax,ss\r\n\tmov\tds,ax\t\t\t\t\t;restore turbo's data segment\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; VWL_UpdateScreenBlocks\r\n;\r\n; Scans through the update matrix and copies any areas that have changed\r\n; to the visable screen, then zeros the update array\r\n;\r\n;============================================================================\r\n\r\n\r\n\r\n; AX\t0/1 for scasb, temp for segment register transfers\r\n; BX    width for block copies\r\n; CX\tREP counter\r\n; DX\tline width deltas\r\n; SI\tsource for copies\r\n; DI\tscas dest / movsb dest\r\n; BP\tpointer to end of bufferblocks\r\n\r\nPROC\tVWL_UpdateScreenBlocks\r\nPUBLIC\tVWL_UpdateScreenBlocks\r\nUSES\tSI,DI,BP\r\n\r\n\tjmp\tSHORT @@realstart\r\n@@done:\r\n;\r\n; all tiles have been scanned\r\n;\r\n\tmov\tdx,GC_INDEX\t\t\t\t; restore write mode 0\r\n\tmov\tax,GC_MODE+0*256\r\n\tWORDOUT\r\n\r\n\txor\tax,ax\t\t\t\t\t; clear out the update matrix\r\n\tmov\tcx,UPDATEWIDE*UPDATEHIGH/2\r\n\r\n\tmov\tdi,[updateptr]\r\n\trep\tstosw\r\n\r\n\tret\r\n\r\n@@realstart:\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK+15*256\r\n\tWORDOUT\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_MODE+1*256\r\n\tWORDOUT\r\n\r\n\tmov\tdi,[updateptr]\t\t\t; start of floating update screen\r\n\tmov\tbp,di\r\n\tadd\tbp,UPDATEWIDE*UPDATEHIGH+1 ; when di = bp, all tiles have been scanned\r\n\r\n\tpush\tdi\r\n\tmov\tcx,-1\t\t\t\t\t; definately scan the entire thing\r\n\r\n;\r\n; scan for a 1 in the update list, meaning a tile needs to be copied\r\n; from the master screen to the current screen\r\n;\r\n@@findtile:\r\n\tpop\tdi\t\t\t\t\t\t; place to continue scaning from\r\n\tmov\tax,ss\r\n\tmov\tes,ax\t\t\t\t\t; search in the data segment\r\n\tmov\tds,ax\r\n\tmov al,1\r\n\trepne\tscasb\r\n\tcmp\tdi,bp\r\n\tjae\t@@done\r\n\r\n\tcmp\t[BYTE di],al\r\n\tjne\t@@singletile\r\n\tjmp\t@@tileblock\r\n\r\n;============\r\n;\r\n; copy a single tile\r\n;\r\n;============\r\n@@singletile:\r\n\tinc\tdi\t\t\t\t\t\t; we know the next tile is nothing\r\n\tpush\tdi\t\t\t\t\t; save off the spot being scanned\r\n\tsub\tdi,[updateptr]\r\n\tshl\tdi,1\r\n\tmov\tdi,[blockstarts-4+di]\t; start of tile location on screen\r\n\tmov\tsi,di\r\n\tadd\tsi,[bufferofs]\r\n\tadd\tdi,[displayofs]\r\n\r\n\tmov\tdx,[linewidth]\r\n\tsub\tdx,2\r\n\tmov\tax,[screenseg]\r\n\tmov\tds,ax\r\n\tmov\tes,ax\r\n\r\nREPT\t15\r\n\tmovsb\r\n\tmovsb\r\n\tadd\tsi,dx\r\n\tadd\tdi,dx\r\nENDM\r\n\tmovsb\r\n\tmovsb\r\n\r\n\tjmp\t@@findtile\r\n\r\n;============\r\n;\r\n; more than one tile in a row needs to be updated, so do it as a group\r\n;\r\n;============\r\nEVEN\r\n@@tileblock:\r\n\tmov\tdx,di\t\t\t\t\t; hold starting position + 1 in dx\r\n\tinc\tdi\t\t\t\t\t\t; we know the next tile also gets updated\r\n\trepe\tscasb\t\t\t\t; see how many more in a row\r\n\tpush\tdi\t\t\t\t\t; save off the spot being scanned\r\n\r\n\tmov\tbx,di\r\n\tsub\tbx,dx\t\t\t\t\t; number of tiles in a row\r\n\tshl\tbx,1\t\t\t\t\t; number of bytes / row\r\n\r\n\tmov\tdi,dx\t\t\t\t\t; lookup position of start tile\r\n\tsub\tdi,[updateptr]\r\n\tshl\tdi,1\r\n\tmov\tdi,[blockstarts-2+di]\t; start of tile location\r\n\tmov\tsi,di\r\n\tadd\tsi,[bufferofs]\r\n\tadd\tdi,[displayofs]\r\n\r\n\tmov\tdx,[linewidth]\r\n\tsub\tdx,bx\t\t\t\t\t; offset to next line on screen\r\n\r\n\tmov\tax,[screenseg]\r\n\tmov\tds,ax\r\n\tmov\tes,ax\r\n\r\nREPT\t15\r\n\tmov\tcx,bx\r\n\trep\tmovsb\r\n\tadd\tsi,dx\r\n\tadd\tdi,dx\r\nENDM\r\n\tmov\tcx,bx\r\n\trep\tmovsb\r\n\r\n\tdec\tcx\t\t\t\t\t\t; was 0 from last rep movsb, now $ffff for scasb\r\n\tjmp\t@@findtile\r\n\r\nENDP\r\n\r\n\r\n;===========================================================================\r\n;\r\n;                    MISC EGA ROUTINES\r\n;\r\n;===========================================================================\r\n\r\n;==============\r\n;\r\n; VW_SetScreen\r\n;\r\n;==============\r\n\r\nPROC\tVW_SetScreen  crtc:WORD, pel:WORD\r\nPUBLIC\tVW_SetScreen\r\n\r\nif waitforvbl\r\n\r\n\tmov\tdx,STATUS_REGISTER_1\r\n\r\n;\r\n; wait util the CRTC just starts scaning a diplayed line to set the CRTC start\r\n;\r\n\tcli\r\n\r\n@@waitnodisplay:\r\n\tin\tal,dx\r\n\ttest\tal,01b\r\n\tjz\t@@waitnodisplay\r\n\r\n@@waitdisplay:\r\n\tin\tal,dx\r\n\ttest\tal,01b\r\n\tjnz\t@@waitdisplay\r\n\r\nendif\r\n\r\n;\r\n; set CRTC start\r\n;\r\n; for some reason, my XT's EGA card doesn't like word outs to the CRTC\r\n; index...\r\n;\r\n\tmov\tcx,[crtc]\r\n\tmov\tdx,CRTC_INDEX\r\n\tmov\tal,0ch\t\t;start address high register\r\n\tout\tdx,al\r\n\tinc\tdx\r\n\tmov\tal,ch\r\n\tout\tdx,al\r\n\tdec\tdx\r\n\tmov\tal,0dh\t\t;start address low register\r\n\tout\tdx,al\r\n\tmov\tal,cl\r\n\tinc\tdx\r\n\tout\tdx,al\r\n\r\nif waitforvbl\r\n\r\n;\r\n; wait for a vertical retrace to set pel panning\r\n;\r\n\tmov\tdx,STATUS_REGISTER_1\r\n@@waitvbl:\r\n\tsti     \t\t;service interrupts\r\n\tjmp\t$+2\r\n\tcli\r\n\tin\tal,dx\r\n\ttest\tal,00001000b\t;look for vertical retrace\r\n\tjz\t@@waitvbl\r\n\r\nendif\r\n\r\n;\r\n; set horizontal panning\r\n;\r\n\tmov\tdx,ATR_INDEX\r\n\tmov\tal,ATR_PELPAN or 20h\r\n\tout\tdx,al\r\n\tjmp\t$+2\r\n\tmov\tal,[BYTE pel]\t\t;pel pan value\r\n\tout\tdx,al\r\n\r\n\tsti\r\n\r\n\tret\r\n\r\nENDP\r\n\r\n\r\nif NUMFONT+NUMFONTM\r\n\r\n;===========================================================================\r\n;\r\n; GENERAL FONT DRAWING ROUTINES\r\n;\r\n;===========================================================================\r\n\r\nDATASEG\r\n\r\npx\tdw\t?\t\t\t\t\t; proportional character drawing coordinates\r\npy\tdw\t?\r\npdrawmode\tdb\t11000b\t\t; 8 = OR, 24 = XOR, put in GC_DATAROTATE\r\nfontcolor\tdb\t15\t\t;0-15 mapmask value\r\n\r\nPUBLIC\tpx,py,pdrawmode,fontcolor\r\n\r\n;\r\n; offsets in font structure\r\n;\r\npcharheight\t=\t0\t\t;lines high\r\ncharloc\t\t=\t2\t\t;pointers to every character\r\ncharwidth\t=\t514\t\t;every character's width in pixels\r\n\r\n\r\npropchar\tdw\t?\t\t\t; the character number to shift\r\nstringptr\tdw\t?,?\r\n\r\n\r\nBUFFWIDTH\t=\t50\r\nBUFFHEIGHT\t=   32\t\t\t; must be twice as high as font for masked fonts\r\n\r\ndatabuffer\tdb\tBUFFWIDTH*BUFFHEIGHT dup (?)\r\n\r\nbufferwidth\tdw\t?\t\t\t\t\t\t; bytes with valid info / line\r\nbufferheight dw\t?\t\t\t\t\t\t; number of lines currently used\r\nPUBLIC\tbufferwidth,bufferheight\r\n\r\nbufferbyte\tdw\t?\r\nbufferbit\tdw\t?\r\n\r\nscreenspot\tdw\t?\t\t\t\t\t\t; where the buffer is going\r\n\r\nbufferextra\tdw\t?\t\t\t\t\t\t; add at end of a line copy\r\nscreenextra\tdw\t?\r\n\r\nCODESEG\r\n\r\n;======================\r\n;\r\n; Macros to table shift a byte of font\r\n;\r\n;======================\r\n\r\nMACRO\tSHIFTNOXOR\r\n\tmov\tal,[es:bx]\t\t; source\r\n\txor\tah,ah\r\n\tshl\tax,1\r\n\tmov\tsi,ax\r\n\tmov\tax,[bp+si]\t\t; table shift into two bytes\r\n\tor\t[di],al\t\t\t; or with first byte\r\n\tinc\tdi\r\n\tmov\t[di],ah\t\t\t; replace next byte\r\n\tinc\tbx\t\t\t\t; next source byte\r\nENDM\r\n\r\nMACRO\tSHIFTWITHXOR\r\n\tmov\tal,[es:bx]\t\t; source\r\n\txor\tah,ah\r\n\tshl\tax,1\r\n\tmov\tsi,ax\r\n\tmov\tax,[bp+si]\t\t; table shift into two bytes\r\n\tnot\tax\r\n\tand\t[di],al\t\t\t; and with first byte\r\n\tinc\tdi\r\n\tmov\t[di],ah\t\t\t; replace next byte\r\n\tinc\tbx\t\t\t\t; next source byte\r\nENDM\r\n\r\n\r\n;=======================\r\n;\r\n; BufferToScreen\r\n;\r\n; Pass buffer start in SI (somewhere in databuffer)\r\n; Draws the buffer to the EGA screen in the current write mode\r\n;\r\n;========================\r\n\r\nPROC\tBufferToScreen\tNEAR\r\n\r\n\tmov\tes,[screenseg]\r\n\tmov\tdi,[screenspot]\r\n\r\n\tmov\tbx,[bufferwidth]\t\t;calculate offsets for end of each line\r\n\tor\tbx,bx\r\n\tjnz\t@@isthere\r\n\tret\t\t\t\t\t\t\t;nothing to draw\r\n\r\n@@isthere:\r\n\tmov\tax,[linewidth]\r\n\tsub\tax,bx\r\n\tmov\t[screenextra],ax\r\n\tmov\tax,BUFFWIDTH\r\n\tsub\tax,bx\r\n\tmov\t[bufferextra],ax\r\n\r\n\tmov\tbx,[bufferheight]\t\t;lines to copy\r\n@@lineloop:\r\n\tmov\tcx,[bufferwidth]\t\t;bytes to copy\r\n@@byteloop:\r\n\tlodsb\t\t\t\t\t\t;get a byte from the buffer\r\n\txchg\t[es:di],al\t\t\t;load latches and store back to screen\r\n\tinc\tdi\r\n\r\n\tloop\t@@byteloop\r\n\r\n\tadd\tsi,[bufferextra]\r\n\tadd\tdi,[screenextra]\r\n\r\n\tdec\tbx\r\n\tjnz\t@@lineloop\r\n\r\n\tret\r\nENDP\r\n\r\n\r\n;============================================================================\r\n;\r\n; NON MASKED FONT DRAWING ROUTINES\r\n;\r\n;============================================================================\r\n\r\nif numfont\r\n\r\nDATASEG\r\n\r\nshiftdrawtable\tdw      0,shift1wide,shift2wide,shift3wide\r\n\r\nCODESEG\r\n\r\n;==================\r\n;\r\n; ShiftPropChar\r\n;\r\n; Call with BX = character number (0-255)\r\n; Draws one character to the buffer at bufferbyte/bufferbit, and adjusts\r\n; them to the new position\r\n;\r\n;==================\r\n\r\nPROC\tShiftPropChar\tNEAR\r\n\r\n\tmov\tes,[grsegs+STARTFONT*2]\t;segment of font to use\r\n\r\n;\r\n; find character location, width, and height\r\n;\r\n\tmov\tsi,[es:charwidth+bx]\r\n\tand\tsi,0ffh\t\t\t\t\t;SI hold width in pixels\r\n\tshl\tbx,1\r\n\tmov\tbx,[es:charloc+bx]\t\t;BX holds pointer to character data\r\n\r\n;\r\n; look up which shift table to use, based on bufferbit\r\n;\r\n\tmov\tdi,[bufferbit]\r\n\tshl\tdi,1\r\n\tmov\tbp,[shifttabletable+di]\t;BP holds pointer to shift table\r\n\r\n\tmov\tdi,OFFSET databuffer\r\n\tadd\tdi,[bufferbyte]\t\t\t;DI holds pointer to buffer\r\n\r\n;\r\n; advance position by character width\r\n;\r\n\tmov\tcx,[bufferbit]\r\n\tadd\tcx,si\t\t\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\t[bufferbyte],ax\t\t\t;new byte position\r\n\r\n\tadd\tsi,7\r\n\tshr\tsi,1\r\n\tshr\tsi,1\r\n\tshr\tsi,1\t\t\t\t\t;bytes the character is wide\r\n\tshl\tsi,1                    ;*2 to look up in shiftdrawtable\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\tmov\tdx,BUFFWIDTH\r\n\tjmp\t[ss:shiftdrawtable+si]\t;procedure to draw this width\r\n\r\n;\r\n; one byte character\r\n;\r\nshift1wide:\r\n\tdec\tdx\r\nEVEN\r\n@@loop1:\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop1\r\n\r\n\tret\r\n\r\n;\r\n; two byte character\r\n;\r\nshift2wide:\r\n\tdec\tdx\r\n\tdec\tdx\r\nEVEN\r\n@@loop2:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop2\r\n\r\n\tret\r\n\r\n;\r\n; three byte character\r\n;\r\nshift3wide:\r\n\tsub\tdx,3\r\nEVEN\r\n@@loop3:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop3\r\n\r\n\tret\r\n\r\n\r\n\r\nENDP\r\n\r\n;============================================================================\r\n\r\n;==================\r\n;\r\n; VW_DrawPropString\r\n;\r\n; Draws a C string of characters at px/py and advances px\r\n;\r\n; Assumes write mode 0\r\n;\r\n;==================\r\n\r\nCODESEG\r\n\r\nPROC\tVW_DrawPropString\tstring:DWORD\r\nPUBLIC\tVW_DrawPropString\r\nUSES\tSI,DI\r\n\r\n;\r\n; proportional spaceing, which clears the buffer ahead of it, so only\r\n; clear the first collumn\r\n;\r\n\tmov\tal,0\r\nline\t=\t0\r\nREPT\tBUFFHEIGHT\r\n\tmov\t[BYTE databuffer+BUFFWIDTH*line],al\r\nline\t=\tline+1\r\nENDM\r\n\r\n;\r\n; shift the characters into the buffer\r\n;\r\n@@shiftchars:\r\n\tmov\tax,[px]\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\r\n\tmov\t[bufferbyte],0\r\n\r\n\tmov\tax,[WORD string]\r\n\tmov\t[stringptr],ax\r\n\tmov\tax,[WORD string+2]\r\n\tmov\t[stringptr+2],ax\r\n\r\n@@shiftone:\r\n\tmov\tes,[stringptr+2]\r\n\tmov\tbx,[stringptr]\r\n\tinc\t[stringptr]\r\n\tmov\tbx,[es:bx]\r\n\txor\tbh,bh\r\n\tor\tbl,bl\r\n\tjz\t@@allshifted\r\n\tcall\tShiftPropChar\r\n\tjmp\t@@shiftone\r\n\r\n@@allshifted:\r\n;\r\n; calculate position to draw buffer on screen\r\n;\r\n\tmov\tbx,[py]\r\n\tshl\tbx,1\r\n\tmov\tdi,[ylookup+bx]\r\n\tadd\tdi,[bufferofs]\r\n\tadd\tdi,[panadjust]\r\n\r\n\tmov\tax,[px]\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\t\t;x location in bytes\r\n\tadd\tdi,ax\r\n\tmov\t[screenspot],di\r\n\r\n;\r\n; advance px\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tor\tax,[bufferbit]\r\n\tadd\t[px],ax\r\n\r\n;\r\n; draw it\r\n;\r\n\r\n; set xor/or mode\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tal,GC_DATAROTATE\r\n\tmov\tah,[pdrawmode]\r\n\tWORDOUT\r\n\r\n; set mapmask to color\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tal,SC_MAPMASK\r\n\tmov\tah,[fontcolor]\r\n\tWORDOUT\r\n\r\n\tmov\tax,[bufferbyte]\r\n\ttest\t[bufferbit],7\r\n\tjz\t@@go\r\n\tinc\tax\t\t\t\t;so the partial byte also gets drawn\r\n@@go:\r\n\tmov\t[bufferwidth],ax\r\n\tmov\tes,[grsegs+STARTFONT*2]\r\n\tmov\tax,[es:pcharheight]\r\n\tmov\t[bufferheight],ax\r\n\r\n\tmov\tsi,OFFSET databuffer\r\n\tcall\tBufferToScreen\r\n\r\n; set copy mode\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_DATAROTATE\r\n\tWORDOUT\r\n\r\n; set mapmask to all\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK + 15*256\r\n\tWORDOUT\r\n\r\n\r\n\tret\r\n\r\nENDP\r\n\r\nendif\t;numfont\r\n\r\n;============================================================================\r\n;\r\n; MASKED FONT DRAWING ROUTINES\r\n;\r\n;============================================================================\r\n\r\nif\tnumfontm\r\n\r\nDATASEG\r\n\r\nmshiftdrawtable\tdw      0,mshift1wide,mshift2wide,mshift3wide\r\n\r\n\r\nCODESEG\r\n\r\n;==================\r\n;\r\n; ShiftMPropChar\r\n;\r\n; Call with BX = character number (0-255)\r\n; Draws one character to the buffer at bufferbyte/bufferbit, and adjusts\r\n; them to the new position\r\n;\r\n;==================\r\n\r\nPROC\tShiftMPropChar\tNEAR\r\n\r\n\tmov\tes,[grsegs+STARTFONTM*2]\t;segment of font to use\r\n\r\n;\r\n; find character location, width, and height\r\n;\r\n\tmov\tsi,[es:charwidth+bx]\r\n\tand\tsi,0ffh\t\t\t\t\t;SI hold width in pixels\r\n\tshl\tbx,1\r\n\tmov\tbx,[es:charloc+bx]\t\t;BX holds pointer to character data\r\n\r\n;\r\n; look up which shift table to use, based on bufferbit\r\n;\r\n\tmov\tdi,[bufferbit]\r\n\tshl\tdi,1\r\n\tmov\tbp,[shifttabletable+di]\t;BP holds pointer to shift table\r\n\r\n\tmov\tdi,OFFSET databuffer\r\n\tadd\tdi,[bufferbyte]\t\t\t;DI holds pointer to buffer\r\n\r\n\tmov\tcx,[bufferbit]\r\n\tadd\tcx,si\t\t\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\t\t\t;new bit position\r\n\tmov\tax,cx\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tadd\t[bufferbyte],ax\t\t\t;new byte position\r\n\r\n\tadd\tsi,7\r\n\tshr\tsi,1\r\n\tshr\tsi,1\r\n\tshr\tsi,1\t\t\t\t\t;bytes the character is wide\r\n\tshl\tsi,1                    ;*2 to look up in shiftdrawtable\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\tmov\tdx,BUFFWIDTH\r\n\tjmp\t[ss:mshiftdrawtable+si]\t;procedure to draw this width\r\n\r\n;\r\n; one byte character\r\n;\r\nmshift1wide:\r\n\tdec\tdx\r\n\r\nEVEN\r\n@@loop1m:\r\n\tSHIFTWITHXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop1m\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\r\nEVEN\r\n@@loop1:\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\tloop\t@@loop1\r\n\r\n\tret\r\n\r\n;\r\n; two byte character\r\n;\r\nmshift2wide:\r\n\tdec\tdx\r\n\tdec\tdx\r\nEVEN\r\n@@loop2m:\r\n\tSHIFTWITHXOR\r\n\tSHIFTWITHXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop2m\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\r\nEVEN\r\n@@loop2:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\tloop\t@@loop2\r\n\r\n\tret\r\n\r\n;\r\n; three byte character\r\n;\r\nmshift3wide:\r\n\tsub\tdx,3\r\nEVEN\r\n@@loop3m:\r\n\tSHIFTWITHXOR\r\n\tSHIFTWITHXOR\r\n\tSHIFTWITHXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\r\n\tloop\t@@loop3m\r\n\r\n\tmov\tcx,[es:pcharheight]\r\n\r\nEVEN\r\n@@loop3:\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tSHIFTNOXOR\r\n\tadd\tdi,dx\t\t\t; next line in buffer\r\n\tloop\t@@loop3\r\n\r\n\tret\r\n\r\n\r\nENDP\r\n\r\n;============================================================================\r\n\r\n;==================\r\n;\r\n; VW_DrawMPropString\r\n;\r\n; Draws a C string of characters at px/py and advances px\r\n;\r\n; Assumes write mode 0\r\n;\r\n;==================\r\n\r\n\r\n\r\nPROC\tVW_DrawMPropString\tstring:DWORD\r\nPUBLIC\tVW_DrawMPropString\r\nUSES\tSI,DI\r\n\r\n;\r\n; clear out the first byte of the buffer, the rest will automatically be\r\n; cleared as characters are drawn into it\r\n;\r\n\tmov\tes,[grsegs+STARTFONTM*2]\r\n\tmov\tdx,[es:pcharheight]\r\n\tmov\tdi,OFFSET databuffer\r\n\tmov\tax,ds\r\n\tmov\tes,ax\r\n\tmov\tbx,BUFFWIDTH-1\r\n\r\n\tmov\tcx,dx\r\n\tmov\tal,0ffh\r\n@@maskfill:\r\n\tstosb\t\t\t\t; fill the mask part with $ff\r\n\tadd\tdi,bx\r\n\tloop\t@@maskfill\r\n\r\n\tmov\tcx,dx\r\n\txor\tal,al\r\n@@datafill:\r\n\tstosb\t\t\t\t; fill the data part with $0\r\n\tadd\tdi,bx\r\n\tloop\t@@datafill\r\n\r\n;\r\n; shift the characters into the buffer\r\n;\r\n\tmov\tax,[px]\r\n\tand\tax,7\r\n\tmov\t[bufferbit],ax\r\n\tmov\t[bufferbyte],0\r\n\r\n\tmov\tax,[WORD string]\r\n\tmov\t[stringptr],ax\r\n\tmov\tax,[WORD string+2]\r\n\tmov\t[stringptr+2],ax\r\n\r\n@@shiftone:\r\n\tmov\tes,[stringptr+2]\r\n\tmov\tbx,[stringptr]\r\n\tinc\t[stringptr]\r\n\tmov\tbx,[es:bx]\r\n\txor\tbh,bh\r\n\tor\tbl,bl\r\n\tjz\t@@allshifted\r\n\tcall\tShiftMPropChar\r\n\tjmp\t@@shiftone\r\n\r\n@@allshifted:\r\n;\r\n; calculate position to draw buffer on screen\r\n;\r\n\tmov\tbx,[py]\r\n\tshl\tbx,1\r\n\tmov\tdi,[ylookup+bx]\r\n\tadd\tdi,[bufferofs]\r\n\tadd\tdi,[panadjust]\r\n\r\n\tmov\tax,[px]\r\n\tshr\tax,1\r\n\tshr\tax,1\r\n\tshr\tax,1\t\t;x location in bytes\r\n\tadd\tdi,ax\r\n\tmov\t[screenspot],di\r\n\r\n;\r\n; advance px\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tshl\tax,1\r\n\tor\tax,[bufferbit]\r\n\tadd\t[px],ax\r\n\r\n;\r\n; draw it\r\n;\r\n\tmov\tax,[bufferbyte]\r\n\ttest\t[bufferbit],7\r\n\tjz\t@@go\r\n\tinc\tax\t\t\t\t;so the partial byte also gets drawn\r\n@@go:\r\n\tmov\t[bufferwidth],ax\r\n\tmov\tes,[grsegs+STARTFONTM*2]\r\n\tmov\tax,[es:pcharheight]\r\n\tmov\t[bufferheight],ax\r\n\r\n; set AND mode to punch out the mask\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_DATAROTATE + 8*256\r\n\tWORDOUT\r\n\r\n; set mapmask to all\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK + 15*256\r\n\tWORDOUT\r\n\r\n\tmov\tsi,OFFSET databuffer\r\n\tcall\tBufferToScreen\r\n\r\n; set OR mode to fill in the color\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_DATAROTATE + 16*256\r\n\tWORDOUT\r\n\r\n; set mapmask to color\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tal,SC_MAPMASK\r\n\tmov\tah,[fontcolor]\r\n\tWORDOUT\r\n\r\n\tcall\tBufferToScreen\t\t; SI is still in the right position in buffer\r\n\r\n; set copy mode\r\n\tmov\tdx,GC_INDEX\r\n\tmov\tax,GC_DATAROTATE\r\n\tWORDOUT\r\n\r\n; set mapmask to all\r\n\tmov\tdx,SC_INDEX\r\n\tmov\tax,SC_MAPMASK + 15*256\r\n\tWORDOUT\r\n\r\n\r\n\tret\r\n\r\nENDP\r\n\r\nendif\t\t; if numfontm\r\n\r\nendif\t\t; if fonts\r\n"
        },
        {
          "name": "jam_io.c",
          "type": "blob",
          "size": 2.9345703125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <alloc.h>\r\n#include <fcntl.h>\r\n#include <dos.h>\r\n#include <io.h>\r\n\r\n#include \"kd_def.h\"\r\n//#include \"gelib.h\"\r\n#include \"jam_io.h\"\r\n\r\n//----------------------------------------------------------------------------\r\n//\r\n//\t \t\t\t\t\t\tPTR/PTR COMPRESSION ROUTINES\r\n//\r\n//\r\n//----------------------------------------------------------------------------\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// WritePtr()  -- Outputs data to a particular ptr type\r\n//\r\n//\tPtrType MUST be of type DEST_TYPE.\r\n//\r\n// NOTE : For PtrTypes DEST_MEM a ZERO (0) is always returned.\r\n//\r\n//---------------------------------------------------------------------------\r\nchar WritePtr(long outfile, unsigned char data, unsigned PtrType)\r\n{\r\n\tint returnval = 0;\r\n\r\n\tswitch (PtrType & DEST_TYPES)\r\n\t{\r\n\t\tcase DEST_FILE:\r\n\t\t\twrite(*(int far *)outfile,(char *)&data,1);\r\n\t\tbreak;\r\n\r\n\t\tcase DEST_FFILE:\r\n\t\t\treturnval = putc(data, *(FILE **)outfile);\r\n\t\tbreak;\r\n\r\n\t\tcase DEST_IMEM:\r\n\t\t\tprintf(\"WritePtr - unsupported ptr type\\n\");\r\n\t\t\texit(0);\r\n\t\tbreak;\r\n\r\n\t\tcase DEST_MEM:\r\n\t\t\t*((char far *)*(char far **)outfile)++ = data;\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn(returnval);\r\n\r\n}\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// ReadPtr()  -- Reads data from a particular ptr type\r\n//\r\n//\tPtrType MUST be of type SRC_TYPE.\r\n//\r\n// RETURNS :\r\n//\t\tThe char read in or EOF for SRC_FFILE type of reads.\r\n//\r\n//\r\n//---------------------------------------------------------------------------\r\nint ReadPtr(long infile, unsigned PtrType)\r\n{\r\n\tint returnval = 0;\r\n\r\n\tswitch (PtrType & SRC_TYPES)\r\n\t{\r\n\t\tcase SRC_FILE:\r\n\t\t\tread(*(int far *)infile,(char *)&returnval,1);\r\n\t\tbreak;\r\n\r\n\t\tcase SRC_FFILE:\r\n\t\t\treturnval = getc(*(FILE far **)infile);\r\n\t\tbreak;\r\n\r\n\t\tcase SRC_BFILE:\r\n\t\t\treturnval = bio_readch((BufferedIO *)*(void far **)infile);\r\n\t\tbreak;\r\n\r\n//\t\tcase SRC_IMEM:\r\n//\t\t\tprintf(\"WritePtr - unsupported ptr type\\n\");\r\n//\t\t\texit(0);\r\n//\t\tbreak;\r\n\r\n\t\tcase SRC_MEM:\r\n\t\t\treturnval = (unsigned char)*((char far *)*(char far **)infile)++;\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn(returnval);\r\n}\r\n\r\n\r\n\r\n"
        },
        {
          "name": "jam_io.h",
          "type": "blob",
          "size": 2.9599609375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//\r\n// UNIT : JAM_IO.h\r\n//\r\n// FUNCTION : General defines, prototypes, typedefs used in all the\r\n//\t\t\t\t  supported compression techniques used in JAMPAK Ver x.x\r\n//\r\n//\r\n\r\n\r\n\r\n\r\n//==========================================================================\r\n//\r\n//\t  \t\t\t\t\t\t\tPARAMETER PASSING TYPES\r\n//\r\n//\r\n\t// SOURCE PARAMS (LO BYTE)\r\n\r\n#define SRC_FILE\t \t\t\t(0x0001)\t\t\t// GE Buffered IO\r\n#define SRC_FFILE\t\t\t\t(0x0002)\t\t\t// Stdio File IO (fwrite etc.)\r\n#define SRC_MEM\t\t\t\t(0x0004)\t\t\t// Std void ptr (alloc etc)\r\n#define SRC_BFILE\t\t\t\t(0x0008)\t\t\t\t// Buffered File I/O\r\n\r\n#define SRC_TYPES \t\t\t(SRC_FILE | SRC_FFILE | SRC_MEM | SRC_BFILE)\r\n\r\n\t// DESTINATION PARAMS (HI BYTE)\r\n\r\n#define DEST_FILE\t\t\t\t(0x0100)\t\t\t// GE Buffered IO\r\n#define DEST_FFILE\t\t\t(0x0200)\t\t\t// Stdio File IO (fwrite etc.)\r\n#define DEST_MEM\t\t\t\t(0x0400)\t\t\t// Std void ptr (alloc etc)\r\n#define DEST_IMEM\t\t\t\t(0x0800)\t\t\t// ID Memory alloc\r\n\r\n#define DEST_TYPES \t\t\t(DEST_FILE | DEST_FFILE | DEST_MEM | DEST_IMEM)\r\n\r\n\r\n\r\n//=========================================================================\r\n//\r\n// \t\t\t\t\t\t\t\tFILE CHUNK IDs\r\n//\r\n// NOTE: The only reason for changing from COMP to CMP1 and having multi\r\n//\t\t\tcomp header structs is for downward compatablity.\r\n//\r\n\r\n#define COMP\t\t\t\t\t(\"COMP\")\t\t// Comp type is ct_LZW ALWAYS!\r\n#define CMP1\t\t\t\t\t(\"CMP1\")\t\t// Comp type is determined in header.\r\n\r\n\r\n//\r\n// \tCOMPRESSION TYPES\r\n//\r\ntypedef enum ct_TYPES\r\n{\r\n\t\tct_NONE = 0,\t\t\t\t\t\t// No compression - Just data..Rarely used!\r\n\t\tct_LZW,\t\t\t\t\t\t\t\t// LZW data compression\r\n\t\tct_LZH,\r\n\r\n} ct_TYPES;\r\n\r\n//\r\n//  \tFILE CHUNK HEADER FORMATS\r\n//\r\n\r\nstruct COMPStruct\r\n{\r\n\tunsigned long DecompLen;\r\n\r\n};\r\n\r\n\r\nstruct CMP1Header\r\n{\r\n\tunsigned CompType;\t\t\t\t\t// SEE: ct_TYPES above for list of pos.\r\n\tunsigned long OrginalLen;\t\t\t// Orginal FileLength of compressed Data.\r\n\tunsigned long CompressLen;\t\t\t// Length of data after compression (A MUST for LZHUFF!)\r\n};\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//\r\n//\t\t\t\t\t\t\t\tFUNCTION PROTOTYPEING\r\n//\r\n//---------------------------------------------------------------------------\r\n\r\nchar WritePtr(long outfile, unsigned char data, unsigned PtrType);\r\nint ReadPtr(long infile, unsigned PtrType);\r\n\r\n\r\n"
        },
        {
          "name": "kd_act1.c",
          "type": "blob",
          "size": 23.521484375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_ACT1.C\r\n#include \"KD_DEF.H\"\r\n#pragma hdrstop\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n#define PLACESPRITE RF_PlaceSprite (&ob->sprite,ob->x,ob->y,ob->shapenum, \\\r\n\tspritedraw,0);\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nint\tflowertime[4] = {700,700,350,175};\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\tMISC ACTOR STUFF\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n==================\r\n=\r\n= DoGravity\r\n=\r\n= Changes speed and location\r\n=\r\n==================\r\n*/\r\n\r\n\r\nvoid DoGravity (objtype *ob)\r\n{\r\n\tlong\ti;\r\n//\r\n// only accelerate on odd tics, because of limited precision\r\n//\r\n\tfor (i=lasttimecount-tics;i<lasttimecount;i++)\r\n\t{\r\n\t\tif (i&1)\r\n\t\t{\r\n\t\t\tif (ob->yspeed < 0 && ob->yspeed >= -ACCGRAVITY)\r\n\t\t\t{\r\n\t\t\t// stop at apex of jump\r\n\t\t\t\tob->ymove += ob->yspeed;\r\n\t\t\t\tob->yspeed = 0;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tob->yspeed+=ACCGRAVITY;\r\n\t\t\tif (ob->yspeed>SPDMAXY)\r\n\t\t\t  ob->yspeed=SPDMAXY;\r\n\t\t}\r\n\t\tob->ymove+=ob->yspeed;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= AccelerateX\r\n=\r\n===============\r\n*/\r\n\r\nvoid AccelerateX (objtype *ob,int dir,int max)\r\n{\r\n\tlong\ti;\r\n\tunsigned\tolddir;\r\n\r\n\tolddir = ob->xspeed & 0x8000;\r\n//\r\n// only accelerate on odd tics, because of limited precision\r\n//\r\n\tfor (i=lasttimecount-tics;i<lasttimecount;i++)\r\n\t{\r\n\t\tif (i&1)\r\n\t\t{\r\n\t\t\tob->xspeed+=dir;\r\n\t\t\tif ( (ob->xspeed & 0x8000) != olddir)\r\n\t\t\t{\r\n\t\t\t\tolddir = ob->xspeed & 0x8000;\r\n\t\t\t\tob->xdir = olddir ? -1 : 1;\r\n\t\t\t}\r\n\t\t\tif (ob->xspeed>max)\r\n\t\t\t  ob->xspeed=max;\r\n\t\t\telse if (ob->xspeed<-max)\r\n\t\t\t  ob->xspeed=-max;\r\n\t\t}\r\n\t\tob->xmove+=ob->xspeed;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= FrictionX\r\n=\r\n===============\r\n*/\r\n\r\nvoid FrictionX (objtype *ob)\r\n{\r\n\tlong\ti;\r\n\tint\t\tdir;\r\n\tunsigned\tolddir;\r\n\r\n\tolddir = ob->xspeed & 0x8000;\r\n\r\n\tif (ob->xspeed > 0)\r\n\t\tdir = -1;\r\n\telse if (ob->xspeed < 0)\r\n\t\tdir = 1;\r\n\telse\r\n\t\tdir = 0;\r\n//\r\n// only accelerate on odd tics, because of limited precision\r\n//\r\n\tfor (i=lasttimecount-tics;i<lasttimecount;i++)\r\n\t{\r\n\t\tif (i&1)\r\n\t\t{\r\n\t\t\tob->xspeed+=dir;\r\n\t\t\tif ( (ob->xspeed & 0x8000) != olddir)\r\n\t\t\t\tob->xspeed = 0;\r\n\t\t}\r\n\t\tob->xmove+=ob->xspeed;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= ProjectileThink\r\n=\r\n===============\r\n*/\r\n\r\nvoid ProjectileThink (objtype *ob)\r\n{\r\n\tDoGravity (ob);\r\n\tob->xmove = tics*ob->xspeed;\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= VelocityThink\r\n=\r\n===============\r\n*/\r\n\r\nvoid VelocityThink (objtype *ob)\r\n{\r\n\tob->xmove = tics*ob->xspeed;\r\n\tob->ymove = tics*ob->yspeed;\r\n}\r\n\r\n/*\r\n===============\r\n=\r\n= DrawReact\r\n=\r\n===============\r\n*/\r\n\r\nvoid DrawReact (objtype *ob)\r\n{\r\n\tRF_PlaceSprite (&ob->sprite,ob->x,ob->y,ob->shapenum,spritedraw,1);\r\n}\r\n\r\nvoid DrawReact2 (objtype *ob)\r\n{\r\n\tRF_PlaceSprite (&ob->sprite,ob->x,ob->y,ob->shapenum,spritedraw,2);\r\n}\r\n\r\nvoid DrawReact3 (objtype *ob)\r\n{\r\n\tRF_PlaceSprite (&ob->sprite,ob->x,ob->y,ob->shapenum,spritedraw,3);\r\n}\r\n\r\n/*\r\n==================\r\n=\r\n= ChangeState\r\n=\r\n==================\r\n*/\r\n\r\nvoid ChangeState (objtype *ob, statetype *state)\r\n{\r\n\tob->state = state;\r\n\tob->ticcount = 0;\r\n\tif (state->rightshapenum)\r\n\t{\r\n\t\tif (ob->xdir>0)\r\n\t\t\tob->shapenum = state->rightshapenum;\r\n\t\telse\r\n\t\t\tob->shapenum = state->leftshapenum;\r\n\t}\r\n\r\n\tob->xmove = 0;\r\n\tob->ymove = 0;\r\n\r\n\tob->needtoreact = true;\t\t\t// it will need to be redrawn this frame\r\n\tClipToWalls (ob);\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= WalkReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid WalkReact (objtype *ob)\r\n{\r\n\tif (ob->xdir == 1 && ob->hitwest)\r\n\t{\r\n\t\tob->x -= ob->xmove;\r\n\t\tob->xdir = -1;\r\n\t\tob->nothink = US_RndT()>>5;\r\n\t\tChangeState (ob,ob->state);\r\n\t}\r\n\telse if (ob->xdir == -1 && ob->hiteast)\r\n\t{\r\n\t\tob->x -= ob->xmove;\r\n\t\tob->xdir = 1;\r\n\t\tob->nothink = US_RndT()>>5;\r\n\t\tChangeState (ob,ob->state);\r\n\t}\r\n\telse if (!ob->hitnorth)\r\n\t{\r\n\t\tob->x -= 2*ob->xmove;\r\n\t\tob->y -= ob->ymove;\r\n\r\n\t\tob->xdir = -ob->xdir;\r\n\t\tob->nothink = US_RndT()>>5;\r\n\t\tChangeState (ob,ob->state);\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tDOOR\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tDoorContact (objtype *ob, objtype *hit);\r\n\r\nextern\tstatetype s_door;\r\nextern\tstatetype s_doorraise;\r\n\r\nstatetype s_door  \t = {DOORSPR,DOORSPR,think,false,\r\n\tfalse,0, 0,0, NULL, DoorContact, DrawReact, &s_door};\r\nstatetype s_doorraise = {DOORSPR,DOORSPR,slide,false,\r\n\tfalse,24, 0,32, NULL, DoorContact, DrawReact, NULL};\r\n\r\n/*\r\n======================\r\n=\r\n= SpawnDoor\r\n=\r\n======================\r\n*/\r\n\r\nvoid\tSpawnDoor (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = doorobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = -1;\r\n\tnew->needtoclip = false;\r\n\tNewState (new,&s_door);\r\n}\r\n\r\n/*\r\n======================\r\n=\r\n= DoorContact\r\n=\r\n======================\r\n*/\r\n\r\nvoid\tDoorContact (objtype *ob, objtype *hit)\r\n{\r\n\tClipToSpriteSide (hit,ob);\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tFLOWER\r\n\r\ntemp1 = original class\r\ntemp2 = original state\r\ntemp3 = flower count\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid ChangeToFlower (objtype *ob);\r\nvoid FlowerThink (objtype *ob);\r\nvoid ChangeFromFlower (objtype *ob);\r\n\r\nextern\tstatetype s_flower1;\r\nextern\tstatetype s_flower2;\r\nextern\tstatetype s_flower3;\r\nextern\tstatetype s_flower4;\r\nextern\tstatetype s_flower5;\r\nextern\tstatetype s_flower6;\r\n\r\nextern\tstatetype s_poofto1;\r\nextern\tstatetype s_poofto2;\r\nextern\tstatetype s_poofto3;\r\nextern\tstatetype s_poofto4;\r\n\r\nextern\tstatetype s_pooffrom1;\r\nextern\tstatetype s_pooffrom2;\r\nextern\tstatetype s_pooffrom3;\r\nextern\tstatetype s_pooffrom4;\r\nextern\tstatetype s_pooffrom5;\r\nextern\tstatetype s_pooffrom6;\r\nextern\tstatetype s_pooffrom7;\r\n\r\nextern\tstatetype s_bonus1;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_flower1  \t = {FLOWER1SPR,FLOWER1SPR,stepthink,false,\r\n\tfalse,20, 0,0, FlowerThink, NULL, DrawReact, &s_flower2};\r\nstatetype s_flower2  \t = {FLOWER2SPR,FLOWER2SPR,stepthink,false,\r\n\tfalse,20, 0,0, FlowerThink, NULL, DrawReact, &s_flower3};\r\nstatetype s_flower3  \t = {FLOWER3SPR,FLOWER3SPR,stepthink,false,\r\n\tfalse,20, 0,0, FlowerThink, NULL, DrawReact, &s_flower4};\r\nstatetype s_flower4  \t = {FLOWER4SPR,FLOWER4SPR,stepthink,false,\r\n\tfalse,20, 0,0, FlowerThink, NULL, DrawReact, &s_flower5};\r\nstatetype s_flower5  \t = {FLOWER3SPR,FLOWER3SPR,stepthink,false,\r\n\tfalse,20, 0,0, FlowerThink, NULL, DrawReact, &s_flower6};\r\nstatetype s_flower6  \t = {FLOWER2SPR,FLOWER2SPR,stepthink,false,\r\n\tfalse,20, 0,0, FlowerThink, NULL, DrawReact, &s_flower1};\r\n\r\nstatetype s_poofto1\t  \t = {POOF1SPR,POOF1SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_poofto2};\r\nstatetype s_poofto2\t  \t = {POOF2SPR,POOF2SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_poofto3};\r\nstatetype s_poofto3\t  \t = {POOF3SPR,POOF3SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_poofto4};\r\nstatetype s_poofto4\t  \t = {POOF4SPR,POOF4SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, NULL};\r\n\r\nstatetype s_pooffrom1  \t = {POOF4SPR,POOF4SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_pooffrom2};\r\nstatetype s_pooffrom2  \t = {POOF3SPR,POOF3SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_pooffrom3};\r\nstatetype s_pooffrom3  \t = {POOF2SPR,POOF2SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_pooffrom4};\r\nstatetype s_pooffrom4  \t = {POOF1SPR,POOF1SPR,step,false,\r\n\tfalse,20, 0,0, ChangeFromFlower, NULL, DrawReact2, &s_pooffrom5};\r\nstatetype s_pooffrom5  \t = {POOF2SPR,POOF2SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_pooffrom6};\r\nstatetype s_pooffrom6  \t = {POOF3SPR,POOF3SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, &s_pooffrom7};\r\nstatetype s_pooffrom7  \t = {POOF4SPR,POOF4SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact2, NULL};\r\n\r\n\r\n#pragma warn +sus\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= ChangeToFlower\r\n=\r\n======================\r\n*/\r\n\r\nvoid ChangeToFlower (objtype *ob)\r\n{\r\n\tSD_PlaySound (FLOWERPOWERSND);\r\n\tob->y = ob->bottom-TILEGLOBAL*2;\r\n\tob->temp1 = (int)ob->obclass;\r\n\tob->temp2 = (int)ob->state;\r\n\tob->temp3 = 0;\r\n\tob->needtoclip = true;\r\n\tob->obclass = inertobj;\r\n\tob->xspeed = 0;\r\n\tChangeState (ob,&s_flower1);\r\n\tob->active = allways;\t\t\t// flower never deactivated\r\n\tGetNewObj (true);\r\n\tnew->x = ob->x;\r\n\tnew->y = ob->y;\r\n\tNewState (new,&s_poofto1);\r\n\tnew->active = removable;\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= FlowerThink\r\n=\r\n======================\r\n*/\r\n\r\nvoid FlowerThink (objtype *ob)\r\n{\r\n\tProjectileThink (ob);\r\n\tif ( (ob->temp3+=tics) >= flowertime[gamestate.difficulty])\r\n\t{\r\n\t\tGetNewObj (true);\r\n\t\tnew->active = allways;\r\n\t\tnew->temp1 = (int)ob;\r\n\t\tnew->x = ob->x;\r\n\t\tnew->y = ob->y;\r\n\t\tNewState (new,&s_pooffrom1);\r\n\t\tob->temp3 = 0;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= ChangeFromFlower\r\n=\r\n======================\r\n*/\r\n\r\nvoid ChangeFromFlower (objtype *ob)\r\n{\r\n\tobjtype *flower;\r\n\tstatetype *state;\r\n\tunsigned\toldbottom;\r\n\r\n\tSD_PlaySound (UNFLOWERPOWERSND);\r\n\tflower = (objtype *)ob->temp1;\r\n\r\n\toldbottom = flower->bottom;\r\n\tChangeState (flower,(statetype *)flower->temp2);\r\n\tflower->y += oldbottom - flower->bottom;\r\n\r\n\tflower->obclass = flower->temp1;\r\n\tflower->active = yes;\t\t\t// allow it to unspawn now if off screen\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tBONUS\r\n\r\ntemp1 = bonus type\r\ntemp2 = base shape number\r\ntemp3 = last animated shape number +1\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid BonusThink (objtype *ob);\r\n\r\nextern\tstatetype s_bonus1;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_bonus  \t = {NULL,NULL,step,false,\r\n\tfalse,20, 0,0, BonusThink, NULL, DrawReact2, &s_bonus};\r\n\r\nstatetype s_bonusrise  \t = {NULL,NULL,slide,false,\r\n\tfalse,40, 0,8, NULL, NULL, DrawReact3, NULL};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnBonus\r\n=\r\n====================\r\n*/\r\n\r\nint bonusshape[12] = {PEPPERMINT1SPR,COOKIE1SPR,CANDYCANE1SPR,CANDYBAR1SPR,\r\n\tLOLLIPOP1SPR,COTTONCANDY1SPR,EXTRAKEEN1SPR,SUPERBONUS1SPR,FLOWERPOWER1SPR,\r\n\tFLOWERPOWERUP1SPR,BOOBUSBOMB1SPR,MAGICKEY1SPR};\r\n\r\nvoid SpawnBonus (int tilex, int tiley, int type)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->needtoclip = false;\r\n\tnew->obclass = bonusobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = tiley<<G_T_SHIFT;\r\n\r\n\tif (type == 9)\r\n\t\tnew->y -= 8*PIXGLOBAL;\t// flower power up one block\r\n\r\n\tnew->ydir = -1;\t\t\t// bonus stuff flies up when touched\r\n\r\n\tnew->temp1 = type;\r\n\tnew->temp2 = new->shapenum = bonusshape[type];\r\n\tif (type != 7)\r\n\t\tnew->temp3 = new->temp2 + 2;\r\n\telse\r\n\t\tnew->temp3 = new->temp2 + 4;\t// super bonus is 4 stage animation\r\n\r\n\tNewState (new,&s_bonus);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= BonusThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid BonusThink (objtype *ob)\r\n{\r\n\tif (++ob->shapenum == ob->temp3)\r\n\t\tob->shapenum = ob->temp2;\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\tBROCCOLASH\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid BroccoThink (objtype *ob);\r\nvoid BroccoGetUp (objtype *ob);\r\n\r\nextern\tstatetype s_broccowalk1;\r\nextern\tstatetype s_broccowalk2;\r\nextern\tstatetype s_broccowalk3;\r\nextern\tstatetype s_broccowalk4;\r\n\r\nextern\tstatetype s_broccosmash1;\r\nextern\tstatetype s_broccosmash2;\r\nextern\tstatetype s_broccosmash3;\r\nextern\tstatetype s_broccosmash4;\r\nextern\tstatetype s_broccosmash5;\r\nextern\tstatetype s_broccosmash6;\r\nextern\tstatetype s_broccosmash7;\r\nextern\tstatetype s_broccosmash8;\r\nextern\tstatetype s_broccosmash9;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_broccowalk1\t = {BROCCOLASHRUNL1SPR,BROCCOLASHRUNR1SPR,step,false,\r\n\ttrue,7, 128,0, BroccoThink, NULL, WalkReact, &s_broccowalk2};\r\nstatetype s_broccowalk2\t = {BROCCOLASHRUNL2SPR,BROCCOLASHRUNR2SPR,step,false,\r\n\ttrue,7, 128,0, BroccoThink, NULL, WalkReact, &s_broccowalk3};\r\nstatetype s_broccowalk3\t = {BROCCOLASHRUNL3SPR,BROCCOLASHRUNR3SPR,step,false,\r\n\ttrue,7, 128,0, BroccoThink, NULL, WalkReact, &s_broccowalk4};\r\nstatetype s_broccowalk4\t = {BROCCOLASHRUNL4SPR,BROCCOLASHRUNR4SPR,step,false,\r\n\ttrue,7, 128,0, BroccoThink, NULL, WalkReact, &s_broccowalk1};\r\n\r\nstatetype s_broccosmash1 = {BROCCOLASHSMASHL1SPR,BROCCOLASHSMASHR1SPR,step,true,\r\n\tfalse,3, 0,0, NULL, NULL, DrawReact, &s_broccosmash2};\r\nstatetype s_broccosmash2 = {BROCCOLASHSMASHL2SPR,BROCCOLASHSMASHR2SPR,step,true,\r\n\tfalse,3, 0,0, NULL, NULL, DrawReact, &s_broccosmash3};\r\nstatetype s_broccosmash3 = {BROCCOLASHSMASHL3SPR,BROCCOLASHSMASHR3SPR,step,true,\r\n\tfalse,3, 0,0, NULL, NULL, DrawReact, &s_broccosmash4};\r\nstatetype s_broccosmash4 = {BROCCOLASHSMASHL4SPR,BROCCOLASHSMASHR4SPR,step,false,\r\n\tfalse,7, 0,0, NULL, NULL, DrawReact, &s_broccosmash5};\r\nstatetype s_broccosmash5 = {BROCCOLASHSMASHL3SPR,BROCCOLASHSMASHR3SPR,step,true,\r\n\tfalse,6, 0,0, NULL, NULL, DrawReact, &s_broccosmash6};\r\nstatetype s_broccosmash6 = {BROCCOLASHSMASHL2SPR,BROCCOLASHSMASHR2SPR,step,true,\r\n\tfalse,6, 0,0, NULL, NULL, DrawReact, &s_broccosmash7};\r\nstatetype s_broccosmash7 = {BROCCOLASHSMASHL1SPR,BROCCOLASHSMASHR1SPR,step,true,\r\n\tfalse,6, 0,0, NULL, NULL, DrawReact, &s_broccosmash8};\r\nstatetype s_broccosmash8 = {BROCCOLASHRUNL1SPR,BROCCOLASHRUNR1SPR,step,true,\r\n\tfalse,6, 0,0, BroccoGetUp, NULL, DrawReact, &s_broccosmash9};\r\nstatetype s_broccosmash9 = {BROCCOLASHRUNL1SPR,BROCCOLASHRUNR1SPR,step,true,\r\n\tfalse,6, 128,0, NULL, NULL, WalkReact, &s_broccowalk1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnBrocco\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnBrocco (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = broccoobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tNewState (new,&s_broccowalk1);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= BroccoGetUp\r\n=\r\n====================\r\n*/\r\n\r\nvoid BroccoGetUp (objtype *ob)\r\n{\r\n\tob->needtoclip = true;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= BroccoThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid BroccoThink (objtype *ob)\r\n{\r\n\tint delta;\r\n\r\n\tif (ob->top > player->bottom || ob->bottom < player->top)\r\n\t\treturn;\r\n\r\n\tdelta = player->x - ob->x;\r\n\r\n\tif ( ob->xdir == -1 )\r\n\t{\r\n\t\tif (delta < -3*TILEGLOBAL)\r\n\t\t\treturn;\r\n\t\tif (delta > TILEGLOBAL/2)\r\n\t\t{\r\n\t\t\tob->xdir = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tob->state = &s_broccosmash1;\r\n\t\tob->needtoclip = false;\r\n\t\tob->xmove = 0;\r\n\t\treturn;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdelta = player->left - ob->right;\r\n\t\tif (delta > 3*TILEGLOBAL)\r\n\t\t\treturn;\r\n\t\tif (delta < -TILEGLOBAL/2)\r\n\t\t{\r\n\t\t\tob->xdir = -1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tob->state = &s_broccosmash1;\r\n\t\tob->needtoclip = false;\r\n\t\tob->xmove = 0;\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t TOMATOOTH\r\n\r\nob->temp1 = jumptime\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define\tSPDTOMATBOUNCE\t30\r\n#define TICTOMATJUMP\t10\r\n#define SPDTOMAT\t\t16\r\n\r\nvoid TomatBounceThink (objtype *ob);\r\nvoid TomatReact (objtype *ob);\r\n\r\nextern\tstatetype s_tomatbounce;\r\nextern\tstatetype s_tomatbounce2;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_tomatbounce\t = {TOMATOOTHL1SPR,TOMATOOTHR1SPR,stepthink,false,\r\n\tfalse,20, 0,0, TomatBounceThink, NULL, TomatReact, &s_tomatbounce2};\r\nstatetype s_tomatbounce2 = {TOMATOOTHL2SPR,TOMATOOTHR2SPR,stepthink,false,\r\n\tfalse,20, 0,0, TomatBounceThink, NULL, TomatReact, &s_tomatbounce};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnTomat\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnTomat (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = tomatobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-1*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tNewState (new,&s_tomatbounce);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= TomatBounceThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid TomatBounceThink (objtype *ob)\r\n{\r\n\tAccelerateX (ob,ob->x > player->x ? -1 : 1,SPDTOMAT);\r\n\tif (ob->xspeed > 0)\r\n\t\tob->xdir = 1;\r\n\telse\r\n\t\tob->xdir = -1;\r\n\r\n\tif (ob->temp1)\r\n\t{\r\n\t\tif (ob->temp1<tics)\r\n\t\t{\r\n\t\t\tob->ymove = ob->yspeed*ob->temp1;\r\n\t\t\tob->temp1 = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tob->ymove = ob->yspeed*tics;\r\n\t\t\tob->temp1-=tics;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\tDoGravity(ob);\r\n\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= TomatReactThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid TomatReact (objtype *ob)\r\n{\r\n\tif (ob->hiteast || ob->hitwest)\r\n\t{\r\n\t\tob->xdir = -ob->xdir;\r\n\t\tob->xspeed = -ob->xspeed;\r\n\t}\r\n\r\n\tif (ob->hitsouth)\r\n\t{\r\n\t\tif (ob->tileright >= originxtile\r\n\t\t&& ob->tileleft <= originxtilemax\r\n\t\t&& ob->tiletop >= originytile\r\n\t\t&& ob->tilebottom <= originytilemax)\r\n\t\t\tSD_PlaySound (BOUNCESND);\r\n\t\tob->yspeed = -ob->yspeed;\r\n\t}\r\n\r\n\tif (ob->hitnorth)\r\n\t{\r\n\t\tif (ob->tileright >= originxtile\r\n\t\t&& ob->tileleft <= originxtilemax\r\n\t\t&& ob->tiletop >= originytile\r\n\t\t&& ob->tilebottom <= originytilemax)\r\n\t\t\tSD_PlaySound (BOUNCESND);\r\n\t\tob->yspeed = -SPDTOMATBOUNCE-(US_RndT()>>4);\r\n\t\tob->temp1 = TICTOMATJUMP;\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t CARROT COURIER\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define\tSPDCARROTLEAPX\t32\r\n#define SPDCARROTLEAPY  40\r\n\r\nvoid CarrotThink (objtype *ob);\r\nvoid CarrotReact (objtype *ob);\r\nvoid CarrotAirReact (objtype *ob);\r\n\r\nextern\tstatetype s_carrotwalk1;\r\nextern\tstatetype s_carrotwalk2;\r\nextern\tstatetype s_carrotwalk3;\r\nextern\tstatetype s_carrotwalk4;\r\n\r\nextern\tstatetype s_carrotleap;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_carrotwalk1\t = {CARROTRUNL1SPR,CARROTRUNR1SPR,step,false,\r\n\ttrue,5, 128,0, NULL, NULL, CarrotReact, &s_carrotwalk2};\r\nstatetype s_carrotwalk2\t = {CARROTRUNL2SPR,CARROTRUNR2SPR,step,false,\r\n\ttrue,5, 128,0, NULL, NULL, CarrotReact, &s_carrotwalk3};\r\nstatetype s_carrotwalk3\t = {CARROTRUNL3SPR,CARROTRUNR3SPR,step,false,\r\n\ttrue,5, 128,0, NULL, NULL, CarrotReact, &s_carrotwalk4};\r\nstatetype s_carrotwalk4\t = {CARROTRUNL4SPR,CARROTRUNR4SPR,step,false,\r\n\ttrue,5, 128,0, NULL, NULL, CarrotReact, &s_carrotwalk1};\r\n\r\nstatetype s_carrotleap\t = {CARROTLEAPL1SPR,CARROTLEAPR1SPR,think,false,\r\n\tfalse,0, 0,0, ProjectileThink, NULL, CarrotAirReact, NULL};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnCarrot\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnCarrot (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = carrotobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_carrotwalk1);\r\n\tnew->hitnorth = 1;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= CarrotReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid CarrotReact (objtype *ob)\r\n{\r\n\tunsigned x, width, bot, far *map;\r\n\r\n\tif (ob->xdir == 1 && ob->hitwest)\r\n\t{\r\n\t\tob->xdir = -1;\r\n\t}\r\n\telse if (ob->xdir == -1 && ob->hiteast)\r\n\t{\r\n\t\tob->xdir = 1;\r\n\t}\r\n\telse if (!ob->hitnorth)\r\n\t{\r\n\t\tob->x -= ob->xmove;\r\n\t\tob->y -= ob->ymove;\r\n\r\n\t\tob->yspeed = -SPDCARROTLEAPY;\r\n\t\tob->xspeed = SPDCARROTLEAPX*ob->xdir;\r\n\t\tChangeState (ob,&s_carrotleap);\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= CarrotAirReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid CarrotAirReact (objtype *ob)\r\n{\r\n\tif (ob->hitsouth)\r\n\t\tob->yspeed = 0;\r\n\r\n\tif (ob->hitnorth)\r\n\t\tChangeState (ob,&s_carrotwalk1);\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t   ASPARAGUSTO\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid AsparThink (objtype *ob);\r\n\r\nextern\tstatetype s_asparwalk1;\r\nextern\tstatetype s_asparwalk2;\r\nextern\tstatetype s_asparwalk3;\r\nextern\tstatetype s_asparwalk4;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_asparwalk1\t = {ASPARAGUSRUNL1SPR,ASPARAGUSRUNR1SPR,step,true,\r\n\ttrue,3, 100,0, NULL, NULL, WalkReact, &s_asparwalk2};\r\nstatetype s_asparwalk2\t = {ASPARAGUSRUNL2SPR,ASPARAGUSRUNR2SPR,step,false,\r\n\ttrue,3, 100,0, NULL, NULL, WalkReact, &s_asparwalk3};\r\nstatetype s_asparwalk3\t = {ASPARAGUSRUNL3SPR,ASPARAGUSRUNR3SPR,step,true,\r\n\ttrue,3, 100,0, NULL, NULL, WalkReact, &s_asparwalk4};\r\nstatetype s_asparwalk4\t = {ASPARAGUSRUNL4SPR,ASPARAGUSRUNR4SPR,step,false,\r\n\ttrue,3, 100,0, NULL, NULL, WalkReact, &s_asparwalk1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnAspar\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnAspar (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = asparobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = tiley<<G_T_SHIFT;\r\n\tnew->xdir = 1;\r\n\tNewState (new,&s_asparwalk1);\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t   SOUR GRAPE\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid GrapeThink (objtype *ob);\r\nvoid GrapeRiseReact (objtype *ob);\r\nvoid GrapeFallReact (objtype *ob);\r\n\r\nextern\tstatetype s_grapewait;\r\nextern\tstatetype s_grapefall;\r\nextern\tstatetype s_grapesit;\r\nextern\tstatetype s_graperise;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_grapewait\t= {GRAPEONVINESPR,GRAPEONVINESPR,think,false,\r\n\tfalse,0, 0,0, GrapeThink, NULL, DrawReact, NULL};\r\n\r\nstatetype s_grapefall\t= {GRAPEFALLINGSPR,GRAPEFALLINGSPR,think,false,\r\n\tfalse,0, 0,0, ProjectileThink, NULL, GrapeFallReact, NULL};\r\n\r\nstatetype s_grapesit\t= {GRAPEONVINESPR,GRAPEONVINESPR,step,false,\r\n\tfalse,30, 0,0, NULL, NULL, DrawReact, &s_graperise};\r\nstatetype s_graperise\t= {GRAPEONVINESPR,GRAPEONVINESPR,slide,false,\r\n\tfalse,0, 0,-16, NULL, NULL, GrapeRiseReact, NULL};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnGrape\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnGrape (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = grapeobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = tiley<<G_T_SHIFT;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_grapewait);\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= GrapeThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid GrapeThink (objtype *ob)\r\n{\r\n\tunsigned y,starty,endy, far *map;\r\n\r\n\tif (player->left > ob->right\r\n\t\t|| player->right < ob->left\r\n\t\t|| player->y < ob->y )\r\n\t\treturn;\r\n\r\n//\r\n// see if there are any walls between grape and player\r\n//\r\n\tstarty = ob->tilebottom;\r\n\tendy = player->tiletop;\r\n\r\n\tmap = mapsegs[1] + mapbwidthtable[starty]/2 + ob->tilemidx;\r\n\tfor (y = starty ; y<endy ; y++,map+=mapwidth)\r\n\t\tif (tinf[NORTHWALL+*map])\r\n\t\t\treturn;\r\n\r\n\tob->state = &s_grapefall;\r\n\tSD_PlaySound (GRAPESCREAMSND);\r\n\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= GrapeRiseReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid GrapeRiseReact (objtype *ob)\r\n{\r\n\tif (ob->hitsouth)\r\n\t\tChangeState(ob,&s_grapewait);\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= GrapeFallReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid GrapeFallReact (objtype *ob)\r\n{\r\n\tif (ob->hitnorth)\r\n\t{\r\n\t\tSD_PlaySound (BOUNCESND);\r\n\t\tob->yspeed = -(ob->yspeed<<1)/3;\r\n\t\tif (ob->yspeed > -32)\r\n\t\t\tChangeState(ob,&s_grapesit);\r\n\t}\r\n\tPLACESPRITE;\r\n}\r\n\r\n"
        },
        {
          "name": "kd_act2.c",
          "type": "blob",
          "size": 31.8896484375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_ACT1.C\r\n#include \"KD_DEF.H\"\r\n#pragma hdrstop\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define PLACESPRITE RF_PlaceSprite (&ob->sprite,ob->x,ob->y,ob->shapenum, \\\r\n\tspritedraw,0);\r\n\r\n\r\nvoid\tProjectileReact (objtype *ob);\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t   TATER TROOPER\r\n\r\ntemp1 = chasing player\r\ntemp2 = nothink time\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid TaterThink (objtype *ob);\r\nvoid BackupReact (objtype *ob);\r\n\r\nextern\tstatetype s_taterwalk1;\r\nextern\tstatetype s_taterwalk2;\r\nextern\tstatetype s_taterwalk3;\r\nextern\tstatetype s_taterwalk4;\r\n\r\n\r\nextern\tstatetype s_taterattack1;\r\nextern\tstatetype s_taterattack2;\r\nextern\tstatetype s_taterattack3;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_taterwalk1\t= {TATERTROOPWALKL1SPR,TATERTROOPWALKR1SPR,step,false,\r\n\ttrue,10, 128,0, TaterThink, NULL, WalkReact, &s_taterwalk2};\r\nstatetype s_taterwalk2\t= {TATERTROOPWALKL2SPR,TATERTROOPWALKR2SPR,step,false,\r\n\ttrue,10, 128,0, TaterThink, NULL, WalkReact, &s_taterwalk3};\r\nstatetype s_taterwalk3\t= {TATERTROOPWALKL3SPR,TATERTROOPWALKR3SPR,step,false,\r\n\ttrue,10, 128,0, TaterThink, NULL, WalkReact, &s_taterwalk4};\r\nstatetype s_taterwalk4\t= {TATERTROOPWALKL4SPR,TATERTROOPWALKR4SPR,step,false,\r\n\ttrue,10, 128,0, TaterThink, NULL, WalkReact, &s_taterwalk1};\r\n\r\nstatetype s_taterattack1= {TATERTROOPLUNGEL1SPR,TATERTROOPLUNGER1SPR,step,false,\r\n\tfalse,12, 0,0, NULL, NULL, BackupReact, &s_taterattack2};\r\nstatetype s_taterattack2= {TATERTROOPLUNGEL2SPR,TATERTROOPLUNGER2SPR,step,false,\r\n\tfalse,20, 0,0, NULL, NULL, DrawReact, &s_taterattack3};\r\nstatetype s_taterattack3= {TATERTROOPLUNGEL1SPR,TATERTROOPLUNGER1SPR,step,false,\r\n\tfalse,8, 0,0, NULL, NULL, DrawReact, &s_taterwalk1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnTater\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnTater (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = taterobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE + 15;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_taterwalk1);\r\n\tnew->hitnorth = 1;\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= TaterThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid TaterThink (objtype *ob)\r\n{\r\n\tint delta;\r\n\r\n\tif (ob->top > player->bottom || ob->bottom < player->top)\r\n\t\treturn;\r\n\r\n\tif ( ob->xdir == -1 )\r\n\t{\r\n\t\tdelta = ob->left - player->right;\r\n\t\tif (delta > TILEGLOBAL)\r\n\t\t\treturn;\r\n\t\tif (delta < -8*PIXGLOBAL)\r\n\t\t{\r\n\t\t\tob->xdir = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSD_PlaySound (TATERSWINGSND);\r\n\t\tob->state = &s_taterattack1;\r\n\t\treturn;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdelta = player->left - ob->right;\r\n\t\tif (delta > TILEGLOBAL)\r\n\t\t\treturn;\r\n\t\tif (delta < -8*PIXGLOBAL)\r\n\t\t{\r\n\t\t\tob->xdir = -1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSD_PlaySound (TATERSWINGSND);\r\n\t\tob->state = &s_taterattack1;\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= BackupReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid BackupReact (objtype *ob)\r\n{\r\n\tif (!ob->hitnorth)\r\n\t{\r\n\t\tob->x-=ob->xmove;\r\n\t\tob->y-=ob->ymove;\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t   CANTELOUPE CART\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern\tstatetype s_cartroll1;\r\nextern\tstatetype s_cartroll2;\r\n\r\nvoid CartReact (objtype *ob);\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_cartroll1\t= {CANTCARTL1SPR,CANTCARTL1SPR,slide,true,\r\n\tfalse,5, 32,0, NULL, NULL, CartReact, &s_cartroll2};\r\nstatetype s_cartroll2\t= {CANTCARTL2SPR,CANTCARTL2SPR,slide,true,\r\n\tfalse,5, 32,0, NULL, NULL, CartReact, &s_cartroll1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnCart\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnCart (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = cartobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-3*PIXGLOBAL;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tnew->active = allways;\r\n\tNewState (new,&s_cartroll1);\r\n}\r\n\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= CartReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid CartReact (objtype *ob)\r\n{\r\n\tunsigned far *map;\r\n\r\n\tif (ob->xdir == 1 && ob->hitwest)\r\n\t{\r\n\t\tob->xdir = -1;\r\n\t}\r\n\telse if (ob->xdir == -1 && ob->hiteast)\r\n\t{\r\n\t\tob->xdir = 1;\r\n\t}\r\n\r\n\tmap = mapsegs[1] + mapbwidthtable[ob->tilebottom+1]/2;\r\n\tif (ob->xdir == 1)\r\n\t\tmap += ob->tileright;\r\n\telse\r\n\t\tmap += ob->tileleft;\r\n\r\n\tif ( !tinf[NORTHWALL + *map] )\r\n\t\tob->xdir = -ob->xdir;\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tFRENCHY\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define FRYXSPEED\t40\r\n#define FRYYSPEED\t-20\r\n\r\n\r\nvoid FrenchyThink (objtype *ob);\r\nvoid FrenchyRunThink (objtype *ob);\r\nvoid FrenchyThrow (objtype *ob);\r\n\r\nextern\tstatetype s_frenchywalk1;\r\nextern\tstatetype s_frenchywalk2;\r\nextern\tstatetype s_frenchywalk3;\r\nextern\tstatetype s_frenchywalk4;\r\n\r\nextern\tstatetype s_frenchyrun1;\r\nextern\tstatetype s_frenchyrun2;\r\nextern\tstatetype s_frenchyrun3;\r\nextern\tstatetype s_frenchyrun4;\r\n\r\nextern\tstatetype s_frenchythrow1;\r\nextern\tstatetype s_frenchythrow2;\r\nextern\tstatetype s_frenchythrow3;\r\n\r\nextern\tstatetype s_fry1;\r\nextern\tstatetype s_fry2;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_frenchywalk1\t= {FRENCHYRUNL1SPR,FRENCHYRUNR1SPR,step,false,\r\n\ttrue,10, 128,0, FrenchyThink, NULL, WalkReact, &s_frenchywalk2};\r\nstatetype s_frenchywalk2\t= {FRENCHYRUNL2SPR,FRENCHYRUNR2SPR,step,false,\r\n\ttrue,10, 128,0, FrenchyThink, NULL, WalkReact, &s_frenchywalk3};\r\nstatetype s_frenchywalk3\t= {FRENCHYRUNL3SPR,FRENCHYRUNR3SPR,step,false,\r\n\ttrue,10, 128,0, FrenchyThink, NULL, WalkReact, &s_frenchywalk4};\r\nstatetype s_frenchywalk4\t= {FRENCHYRUNL4SPR,FRENCHYRUNR4SPR,step,false,\r\n\ttrue,10, 128,0, FrenchyThink, NULL, WalkReact, &s_frenchywalk1};\r\n\r\nstatetype s_frenchyrun1\t= {FRENCHYRUNL1SPR,FRENCHYRUNR1SPR,step,true,\r\n\ttrue,5, 128,0, FrenchyRunThink, NULL, WalkReact, &s_frenchyrun2};\r\nstatetype s_frenchyrun2\t= {FRENCHYRUNL2SPR,FRENCHYRUNR2SPR,step,true,\r\n\ttrue,5, 128,0, FrenchyRunThink, NULL, WalkReact, &s_frenchyrun3};\r\nstatetype s_frenchyrun3\t= {FRENCHYRUNL3SPR,FRENCHYRUNR3SPR,step,true,\r\n\ttrue,5, 128,0, FrenchyRunThink, NULL, WalkReact, &s_frenchyrun4};\r\nstatetype s_frenchyrun4\t= {FRENCHYRUNL4SPR,FRENCHYRUNR4SPR,step,true,\r\n\ttrue,5, 128,0, FrenchyRunThink, NULL, WalkReact, &s_frenchyrun1};\r\n\r\nstatetype s_frenchythrow1\t= {FRENCHYTHROWL1SPR,FRENCHYTHROWR1SPR,step,false,\r\n\tfalse,10, 0,0, NULL, NULL, DrawReact, &s_frenchythrow2};\r\nstatetype s_frenchythrow2\t= {FRENCHYTHROWL2SPR,FRENCHYTHROWR2SPR,step,false,\r\n\tfalse,1, 0,0, FrenchyThrow, NULL, DrawReact, &s_frenchythrow3};\r\nstatetype s_frenchythrow3\t= {FRENCHYTHROWL2SPR,FRENCHYTHROWR2SPR,step,false,\r\n\tfalse,10, -128,0, NULL, NULL, DrawReact, &s_frenchywalk1};\r\n\r\nstatetype s_fry1\t\t= {FRENCHFRY1SPR,FRENCHFRY1SPR,stepthink,false,\r\n\tfalse,4, 0,0, ProjectileThink, NULL, ProjectileReact, &s_fry2};\r\nstatetype s_fry2\t\t= {FRENCHFRY2SPR,FRENCHFRY2SPR,stepthink,false,\r\n\tfalse,4, 0,0, ProjectileThink, NULL, ProjectileReact, &s_fry1};\r\n\r\n\r\n#pragma warn +sus\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnFrenchy\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnFrenchy (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = frenchyobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_frenchywalk1);\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= FrenchyRunThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid FrenchyRunThink (objtype *ob)\r\n{\r\n\tob->state = &s_frenchywalk1;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= FrenchyThrow\r\n=\r\n====================\r\n*/\r\n\r\nvoid FrenchyThrow (objtype *ob)\r\n{\r\n\tGetNewObj (true);\r\n\tnew->obclass = shotobj;\r\n\tif (ob->xdir == 1)\r\n\t{\r\n\t\tnew->x = ob->x+24*16;\r\n\t\tnew->y = ob->y+8*16;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnew->x = ob->x;\r\n\t\tnew->y = ob->y+8*16;\r\n\t}\r\n\tnew->xdir = ob->xdir;\r\n\tnew->ydir = 1;\r\n\tnew->xspeed = ob->xdir * FRYXSPEED-(US_RndT()>>4);\r\n\tnew->yspeed = FRYYSPEED;\r\n\tnew->active = removable;\r\n\tNewState (new,&s_fry1);\r\n\r\n\tob->nothink = 2;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= FrenchyThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid FrenchyThink (objtype *ob)\r\n{\r\n\tint delta;\r\n\r\n\tif ( abs(ob->y - player->y) > 3*TILEGLOBAL )\r\n\t{\r\n\t\tif (US_RndT()<8)\r\n\t\t\tob->xdir = -ob->xdir;\t\t// turn randomly\r\n\t\treturn;\r\n\t}\r\n\r\n\tdelta = player->x - ob->x;\r\n\r\n\tif (delta < -8*TILEGLOBAL)\r\n\t{\r\n\t// walk closer\r\n\t\tob->xdir = -1;\r\n\t}\r\n\tif (delta < -4*TILEGLOBAL)\r\n\t{\r\n\t// throw\r\n\t\tob->xdir = -1;\r\n\t\tob->state = &s_frenchythrow1;\r\n\t}\r\n\telse if (delta < 0)\r\n\t{\r\n\t// run away\r\n\t\tob->xdir = 1;\r\n\t\tob->state = &s_frenchyrun1;\r\n\t\tob->nothink = 8;\r\n\t}\r\n\telse if (delta < 4*TILEGLOBAL)\r\n\t{\r\n\t// run away\r\n\t\tob->xdir = -1;\r\n\t\tob->state = &s_frenchyrun1;\r\n\t\tob->nothink = 8;\r\n\t}\r\n\telse if (delta < 8*TILEGLOBAL)\r\n\t{\r\n\t// throw and walk closer\r\n\t\tob->xdir = 1;\r\n\t\tob->state = &s_frenchythrow1;\r\n\t}\r\n\telse\r\n\t{\r\n\t// walk closer\r\n\t\tob->xdir = 1;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t  MELON LIPS\r\n\r\nob->temp1 = direction : 0 = left, 1 = right, 2 = down\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define SPITXSPEED\t48\r\n#define SPITYSPEED\t-20\r\n\r\nvoid MelonSpitThink (objtype *ob);\r\nvoid\tProjectileReact (objtype *ob);\r\n\r\nextern\tstatetype s_melonside;\r\nextern\tstatetype s_melonsidespit;\r\nextern\tstatetype s_melonsidespit2;\r\n\r\nextern\tstatetype s_melondown;\r\nextern\tstatetype s_melondownspit;\r\nextern\tstatetype s_melondownspit2;\r\n\r\nextern\tstatetype s_melonseed1;\r\nextern\tstatetype s_melonseed2;\r\n\r\nextern\tstatetype s_melonseedd1;\r\nextern\tstatetype s_melonseedd2;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_melonside\t= {MELONLIPSL1SPR,MELONLIPSR1SPR,step,false,\r\n\tfalse,200, 0,0, NULL, NULL, DrawReact, &s_melonsidespit};\r\nstatetype s_melonsidespit= {MELONLIPSL2SPR,MELONLIPSR2SPR,step,false,\r\n\tfalse,6, 0,0, MelonSpitThink, NULL, DrawReact, &s_melonsidespit2};\r\nstatetype s_melonsidespit2= {MELONLIPSL2SPR,MELONLIPSR2SPR,step,false,\r\n\tfalse,6, 0,0, NULL, NULL, DrawReact, &s_melonside};\r\n\r\nstatetype s_melondown\t= {MELONLIPSD1SPR,MELONLIPSD1SPR,step,false,\r\n\tfalse,200, 0,0, NULL, NULL, DrawReact, &s_melondownspit};\r\nstatetype s_melondownspit\t= {MELONLIPSD2SPR,MELONLIPSD2SPR,step,false,\r\n\tfalse,6, 0,0, MelonSpitThink, NULL, DrawReact, &s_melondownspit2};\r\nstatetype s_melondownspit2\t= {MELONLIPSD2SPR,MELONLIPSD2SPR,step,false,\r\n\tfalse,6, 0,0, NULL, NULL, DrawReact, &s_melondown};\r\n\r\nstatetype s_melonseed1\t= {MELONSEEDL1SPR,MELONSEEDR1SPR,think,false,\r\n\tfalse,4, 0,0, ProjectileThink, NULL, ProjectileReact, &s_melonseed2};\r\nstatetype s_melonseed2\t= {MELONSEEDL2SPR,MELONSEEDR2SPR,think,false,\r\n\tfalse,4, 0,0, ProjectileThink, NULL, ProjectileReact, &s_melonseed1};\r\n\r\nstatetype s_melonseedd1\t= {MELONSEEDD1SPR,MELONSEEDD1SPR,stepthink,false,\r\n\tfalse,4, 0,0, ProjectileThink, NULL, ProjectileReact, &s_melonseedd2};\r\nstatetype s_melonseedd2\t= {MELONSEEDD2SPR,MELONSEEDD2SPR,stepthink,false,\r\n\tfalse,4, 0,0, ProjectileThink, NULL, ProjectileReact, &s_melonseedd1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnMelon\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnMelon (int tilex, int tiley,int dir)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = melonobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = tiley<<G_T_SHIFT;\r\n\tif (dir)\r\n\t\tnew->xdir = 1;\r\n\telse\r\n\t\tnew->xdir = -1;\r\n\tif (dir <2)\r\n\t\tNewState (new,&s_melonside);\r\n\telse\r\n\t\tNewState (new,&s_melondown);\r\n\r\n\tnew->ticcount = US_RndT()>>1;\r\n\tnew->temp1 = dir;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= MelonSpitThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid MelonSpitThink (objtype *ob)\r\n{\r\n\tGetNewObj (false);\r\n\tnew->obclass = shotobj;\r\n\tswitch (ob->temp1)\r\n\t{\r\n\tcase 0:\r\n\t\tnew->x = ob->x+24*16;\r\n\t\tnew->y = ob->y+8*16;\r\n\t\tnew->xdir = ob->xdir;\r\n\t\tnew->ydir = 1;\r\n\t\tnew->xspeed = -SPITXSPEED-(US_RndT()>>4);\r\n\t\tnew->yspeed = SPITYSPEED;\r\n\t\tNewState (new,&s_melonseed1);\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tnew->x = ob->x;\r\n\t\tnew->y = ob->y+8*16;\r\n\t\tnew->xdir = ob->xdir;\r\n\t\tnew->ydir = 1;\r\n\t\tnew->xspeed = SPITXSPEED+(US_RndT()>>4);\r\n\t\tnew->yspeed = SPITYSPEED;\r\n\t\tNewState (new,&s_melonseed1);\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tnew->x = ob->x+8*16;\r\n\t\tnew->y = ob->y+24*16;\r\n\t\tnew->ydir = 1;\r\n\t\tnew->yspeed = -SPITYSPEED;\r\n\t\tNewState (new,&s_melonseedd1);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tnew->active = removable;\r\n}\r\n\r\n/*\r\n============================\r\n=\r\n= ProjectileReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tProjectileReact (objtype *ob)\r\n{\r\n\tunsigned wall,absx,absy,angle,newangle;\r\n\tunsigned long speed;\r\n\r\n\tPLACESPRITE;\r\n\tif (ob->hiteast || ob->hitwest)\r\n\t\tob->xspeed= -ob->xspeed/2;\r\n\r\n\tif (ob->hitsouth)\r\n\t\tob->yspeed= -ob->yspeed/2;\r\n\r\n\twall = ob->hitnorth;\r\n\tif (wall)\r\n\t{\r\n\t\tif (ob->yspeed < 0)\r\n\t\t\tob->yspeed = 0;\r\n\r\n\t\tabsx = abs(ob->xspeed);\r\n\t\tabsy = ob->yspeed;\r\n\t\tif (absx>absy)\r\n\t\t{\r\n\t\t\tif (absx>absy*2)\t// 22 degrees\r\n\t\t\t{\r\n\t\t\t\tangle = 0;\r\n\t\t\t\tspeed = absx*286;\t// x*sqrt(5)/2\r\n\t\t\t}\r\n\t\t\telse\t\t\t\t// 45 degrees\r\n\t\t\t{\r\n\t\t\t\tangle = 1;\r\n\t\t\t\tspeed = absx*362;\t// x*sqrt(2)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (absy>absx*2)\t// 90 degrees\r\n\t\t\t{\r\n\t\t\t\tangle = 3;\r\n\t\t\t\tspeed = absy*256;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tangle = 2;\t\t// 67 degrees\r\n\t\t\t\tspeed = absy*286;\t// y*sqrt(5)/2\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ob->xspeed > 0)\r\n\t\t\tangle = 7-angle;\r\n\r\n\t\tspeed >>= 1;\r\n\t\tnewangle = bounceangle[ob->hitnorth][angle];\r\n\t\tswitch (newangle)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tob->xspeed = speed / 286;\r\n\t\t\tob->yspeed = -ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tob->xspeed = speed / 362;\r\n\t\t\tob->yspeed = -ob->xspeed;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tob->yspeed = -(speed / 286);\r\n\t\t\tob->xspeed = -ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\r\n\t\tcase 4:\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->yspeed = -(speed / 256);\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tob->yspeed = -(speed / 286);\r\n\t\t\tob->xspeed = ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tob->xspeed = ob->yspeed = -(speed / 362);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tob->xspeed = -(speed / 286);\r\n\t\t\tob->yspeed = ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 8:\r\n\t\t\tob->xspeed = -(speed / 286);\r\n\t\t\tob->yspeed = -ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 9:\r\n\t\t\tob->xspeed = -(speed / 362);\r\n\t\t\tob->yspeed = -ob->xspeed;\r\n\t\t\tbreak;\r\n\t\tcase 10:\r\n\t\t\tob->yspeed = speed / 286;\r\n\t\t\tob->xspeed = -ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 11:\r\n\r\n\t\tcase 12:\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->yspeed = -(speed / 256);\r\n\t\t\tbreak;\r\n\t\tcase 13:\r\n\t\t\tob->yspeed = speed / 286;\r\n\t\t\tob->xspeed = ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 14:\r\n\t\t\tob->xspeed = speed / 362;\r\n\t\t\tob->yspeed = speed / 362;\r\n\t\t\tbreak;\r\n\t\tcase 15:\r\n\t\t\tob->xspeed = speed / 286;\r\n\t\t\tob->yspeed = ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (speed < 256*16)\r\n\t\t\tRemoveObj (ob);\r\n\t}\r\n}\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tSQUASHER\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define SPDSQUASHLEAPY  50\r\n\r\n\r\nvoid SquasherThink (objtype *ob);\r\nvoid SquasherJumpReact (objtype *ob);\r\n\r\nextern\tstatetype s_squasherwalk1;\r\nextern\tstatetype s_squasherwalk2;\r\n\r\nextern\tstatetype s_squasherjump1;\r\nextern\tstatetype s_squasherjump2;\r\n\r\nextern\tstatetype s_squasherwait;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_squasherwalk1\t= {SQUASHERWALKL1SPR,SQUASHERWALKR1SPR,step,false,\r\n\ttrue,10, 128,0, SquasherThink, NULL, WalkReact, &s_squasherwalk2};\r\nstatetype s_squasherwalk2\t= {SQUASHERWALKL2SPR,SQUASHERWALKR2SPR,step,false,\r\n\ttrue,10, 128,0, SquasherThink, NULL, WalkReact, &s_squasherwalk1};\r\n\r\nstatetype s_squasherjump1\t= {SQUASHERJUMPL1SPR,SQUASHERJUMPR1SPR,stepthink,false,\r\n\tfalse,20, 0,0, ProjectileThink, NULL, SquasherJumpReact, &s_squasherjump2};\r\nstatetype s_squasherjump2\t= {SQUASHERJUMPL2SPR,SQUASHERJUMPR2SPR,think,false,\r\n\tfalse,0, 0,0, ProjectileThink, NULL, SquasherJumpReact, NULL};\r\n\r\nstatetype s_squasherwait\t= {SQUASHERJUMPL2SPR,SQUASHERJUMPR2SPR,step,false,\r\n\tfalse,10, 0,0, ProjectileThink, NULL, DrawReact, &s_squasherwalk1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnSquasher\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnSquasher (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = squashobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_squasherwalk1);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= SquasherThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid SquasherThink (objtype *ob)\r\n{\r\n\tint delta;\r\n\r\n\tif ( abs(ob->y - player->y) > 3*TILEGLOBAL )\r\n\t{\r\n\t\tif (US_RndT()<8)\r\n\t\t\tob->xdir = -ob->xdir;\t\t// turn randomly\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\tdelta = player->x - ob->x;\r\n\r\n\tif ( ob->xdir == -1 )\r\n\t{\r\n\t\tif (delta < -6*TILEGLOBAL)\r\n\t\t\treturn;\r\n\t\tif (delta > 8*PIXGLOBAL)\r\n\t\t{\r\n\t\t\tob->xdir = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (delta > 6*TILEGLOBAL)\r\n\t\t\treturn;\r\n\t\tif (delta < -8*PIXGLOBAL)\r\n\t\t{\r\n\t\t\tob->xdir = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tob->yspeed = -SPDSQUASHLEAPY;\r\n\tob->xspeed = delta/60;\r\n\tob->state = &s_squasherjump1;\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= SquasherJumpReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid SquasherJumpReact (objtype *ob)\r\n{\r\n\tif (ob->hitsouth)\r\n\t\tob->yspeed = 0;\r\n\r\n\tif (ob->hitnorth)\r\n\t\tChangeState (ob,&s_squasherwait);\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\t\tAPEL\r\n\r\ntemp4 = pole x coordinate\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid ApelThink (objtype *ob);\r\nvoid ApelClimbThink (objtype *ob);\r\nvoid ApelSlideThink (objtype *ob);\r\nvoid ApelFallThink (objtype *ob);\r\n\r\nvoid ApelClimbReact (objtype *ob);\r\nvoid ApelSlideReact (objtype *ob);\r\nvoid ApelFallReact (objtype *ob);\r\n\r\nextern\tstatetype s_apelwalk1;\r\nextern\tstatetype s_apelwalk2;\r\nextern\tstatetype s_apelwalk3;\r\n\r\nextern\tstatetype s_apelclimb1;\r\nextern\tstatetype s_apelclimb2;\r\n\r\nextern\tstatetype s_apelslide1;\r\nextern\tstatetype s_apelslide2;\r\nextern\tstatetype s_apelslide3;\r\nextern\tstatetype s_apelslide4;\r\n\r\nextern\tstatetype s_apelfall;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_apelwalk1\t= {APELWALKL1SPR,APELWALKR1SPR,step,false,\r\n\ttrue,10, 128,0, ApelThink, NULL, WalkReact, &s_apelwalk2};\r\nstatetype s_apelwalk2\t= {APELWALKL2SPR,APELWALKR2SPR,step,false,\r\n\ttrue,10, 128,0, ApelThink, NULL, WalkReact, &s_apelwalk3};\r\nstatetype s_apelwalk3\t= {APELWALKL3SPR,APELWALKR3SPR,step,false,\r\n\ttrue,10, 128,0, ApelThink, NULL, WalkReact, &s_apelwalk1};\r\n\r\nstatetype s_apelclimb1\t= {APELSHINNY1SPR,APELSHINNY1SPR,slide,false,\r\n\tfalse,6, 0,-16, ApelClimbThink, NULL, ApelClimbReact, &s_apelclimb2};\r\nstatetype s_apelclimb2\t= {APELSHINNY2SPR,APELSHINNY2SPR,slide,false,\r\n\tfalse,6, 0,-16, ApelClimbThink, NULL, ApelClimbReact, &s_apelclimb1};\r\n\r\nstatetype s_apelslide1\t= {APELSLIDE1SPR,APELSLIDE1SPR,slide,false,\r\n\tfalse,6, 0,16, ApelSlideThink, NULL, ApelFallReact, &s_apelslide2};\r\nstatetype s_apelslide2\t= {APELSLIDE2SPR,APELSLIDE2SPR,slide,false,\r\n\tfalse,6, 0,16, ApelSlideThink, NULL, ApelFallReact, &s_apelslide3};\r\nstatetype s_apelslide3\t= {APELSLIDE3SPR,APELSLIDE3SPR,slide,false,\r\n\tfalse,6, 0,16, ApelSlideThink, NULL, ApelFallReact, &s_apelslide4};\r\nstatetype s_apelslide4\t= {APELSLIDE4SPR,APELSLIDE4SPR,slide,false,\r\n\tfalse,6, 0,16, ApelSlideThink, NULL, ApelFallReact, &s_apelslide1};\r\n\r\nstatetype s_apelfall = {APELWALKL1SPR,APELWALKR1SPR,think,false,\r\n\tfalse,0, 0,0, ProjectileThink, NULL, ApelFallReact, NULL};\r\n\r\n#pragma warn +sus\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnApel\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnApel (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = apelobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_apelwalk1);\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ApelThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid ApelThink (objtype *ob)\r\n{\r\n\tint\tx,y;\r\n\tunsigned far *map;\r\n\r\n\tif (ob->top > player->bottom || ob->bottom < player->top)\r\n\t{\r\n\t//\r\n\t// try to climb a pole to reach player\r\n\t//\r\n\t\tif (ob->y < player->y)\r\n\t\t\ty = ob->tilebottom;\r\n\t\telse\r\n\t\t\ty = ob->tiletop;\r\n\r\n\t\tmap = (unsigned _seg *)mapsegs[1]+\r\n\t\t\tmapbwidthtable[y]/2 + ob->tilemidx;\r\n\r\n\t\tif ((tinf[INTILE+*map]&0x7f) == 1)\r\n\t\t{\r\n\t\t\tob->xmove = (ob->tilemidx<<G_T_SHIFT) - ob->x;\r\n\t\t\tob->ymove = 0;\r\n\t\t\tob->temp4 = ob->tilemidx;\t// for future reference\r\n\t\t\tob->needtoclip = false;\t\t// can climb through pole holes\r\n\t\t\tif (ob->y < player->y)\r\n\t\t\t\tob->state = &s_apelslide1;\r\n\t\t\telse\r\n\t\t\t\tob->state = &s_apelclimb1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (US_RndT()>32)\t\t// don't turn around all the time\r\n\t\treturn;\r\n\r\n\tif (ob->x < player->x)\r\n\t\tob->xdir = 1;\r\n\telse\r\n\t\tob->xdir = -1;\r\n\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ApelClimbThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid ApelClimbThink (objtype *ob)\r\n{\r\n\tunsigned far *map;\r\n\r\n\tmap = (unsigned _seg *)mapsegs[1]+\r\n\t\tmapbwidthtable[ob->tiletop]/2 + ob->temp4;\r\n\r\n\tif ((tinf[INTILE+*map]&0x7f) != 1)\r\n\t{\r\n\t\tob->needtoclip = true;\r\n\t\tob->state = &s_apelfall;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ApelSlideThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid ApelSlideThink (objtype *ob)\r\n{\r\n\tunsigned far *map;\r\n\r\n\tmap = (unsigned _seg *)mapsegs[1]+\r\n\t\tmapbwidthtable[ob->tilebottom]/2 + ob->temp4;\r\n\r\n\tif ((tinf[INTILE+*map]&0x7f) != 1)\r\n\t{\r\n\t\tob->needtoclip = true;\r\n\t\tob->state = &s_apelfall;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ApelClimbReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid ApelClimbReact (objtype *ob)\r\n{\r\n\tif (ob->hitsouth)\r\n\t\tChangeState (ob,&s_apelfall);\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ApelFallReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid ApelFallReact (objtype *ob)\r\n{\r\n\tif (ob->hitnorth)\r\n\t\tChangeState (ob,&s_apelwalk1);\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\t\tPEA BRAIN\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid PeaBrainThink (objtype *ob);\r\nvoid PeaFlyReact (objtype *ob);\r\n\r\nextern statetype s_peabrainfly;\r\n\r\nextern\tstatetype s_peabrainwalk1;\r\nextern\tstatetype s_peabrainwalk2;\r\nextern\tstatetype s_peabrainwalk3;\r\nextern\tstatetype s_peabrainwalk4;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_peabrainfly\t= {PEABRAINWALKL1SPR,PEABRAINWALKR1SPR,think,false,\r\n\tfalse,0, 0,0, ProjectileThink, NULL, PeaFlyReact, NULL};\r\n\r\nstatetype s_peabrainwalk1\t= {PEABRAINWALKL1SPR,PEABRAINWALKR1SPR,step,false,\r\n\ttrue,10, 128,0, PeaBrainThink, NULL, WalkReact, &s_peabrainwalk2};\r\nstatetype s_peabrainwalk2\t= {PEABRAINWALKL2SPR,PEABRAINWALKR2SPR,step,false,\r\n\ttrue,10, 128,0, PeaBrainThink, NULL, WalkReact, &s_peabrainwalk3};\r\nstatetype s_peabrainwalk3\t= {PEABRAINWALKL3SPR,PEABRAINWALKR3SPR,step,false,\r\n\ttrue,10, 128,0, PeaBrainThink, NULL, WalkReact, &s_peabrainwalk4};\r\nstatetype s_peabrainwalk4\t= {PEABRAINWALKL4SPR,PEABRAINWALKR4SPR,step,false,\r\n\ttrue,10, 128,0, PeaBrainThink, NULL, WalkReact, &s_peabrainwalk1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnPeaBrain\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnPeaBrain (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = peabrainobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = tiley<<G_T_SHIFT;\r\n\tNewState (new,&s_peabrainwalk1);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= PeaBrainThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid PeaBrainThink (objtype *ob)\r\n{\r\n\tob++;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= PeaFlyReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid PeaFlyReact (objtype *ob)\r\n{\r\n\tif (ob->hitnorth)\r\n\t\tChangeState (ob,&s_peabrainwalk1);\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\t\tPEA POD\r\n\r\ntemp1 = number of peas spit\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define MAXPEASPIT\t4\r\n\r\n#define PEAXSPEED\t48\r\n#define PEAYSPEED\t-20\r\n\r\n\r\nvoid PeaPodThink (objtype *ob);\r\nvoid SpitPeaBrain (objtype *ob);\r\n\r\nextern\tstatetype s_peapodwalk1;\r\nextern\tstatetype s_peapodwalk2;\r\nextern\tstatetype s_peapodwalk3;\r\nextern\tstatetype s_peapodwalk4;\r\n\r\nextern\tstatetype s_peapodspit1;\r\nextern\tstatetype s_peapodspit2;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_peapodwalk1\t= {PEAPODRUNL1SPR,PEAPODRUNR1SPR,step,false,\r\n\ttrue,10, 128,0, PeaPodThink, NULL, WalkReact, &s_peapodwalk2};\r\nstatetype s_peapodwalk2\t= {PEAPODRUNL2SPR,PEAPODRUNR2SPR,step,false,\r\n\ttrue,10, 128,0, PeaPodThink, NULL, WalkReact, &s_peapodwalk3};\r\nstatetype s_peapodwalk3\t= {PEAPODRUNL3SPR,PEAPODRUNR3SPR,step,false,\r\n\ttrue,10, 128,0, PeaPodThink, NULL, WalkReact, &s_peapodwalk4};\r\nstatetype s_peapodwalk4\t= {PEAPODRUNL4SPR,PEAPODRUNR4SPR,step,false,\r\n\ttrue,10, 128,0, PeaPodThink, NULL, WalkReact, &s_peapodwalk1};\r\n\r\nstatetype s_peapodspit1\t= {PEAPODSPITLSPR,PEAPODSPITRSPR,step,false,\r\n\ttrue,30, 0,0, SpitPeaBrain, NULL, DrawReact, &s_peapodspit2};\r\nstatetype s_peapodspit2\t= {PEAPODSPITLSPR,PEAPODSPITRSPR,step,false,\r\n\ttrue,30, 0,0, NULL, NULL, DrawReact, &s_peapodwalk1};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnPeaPod\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnPeaPod (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = peapodobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-2*BLOCKSIZE;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = 1;\r\n\tNewState (new,&s_peapodwalk1);\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= SpitPeaBrain\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpitPeaBrain (objtype *ob)\r\n{\r\n\tGetNewObj (true);\r\n\tnew->obclass = peabrainobj;\r\n\tif (ob->xdir == 1)\r\n\t{\r\n\t\tnew->x = ob->x+8*16;\r\n\t\tnew->y = ob->y+8*16;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnew->x = ob->x;\r\n\t\tnew->y = ob->y+8*16;\r\n\t}\r\n\tnew->xdir = ob->xdir;\r\n\tnew->ydir = 1;\r\n\tnew->xspeed = ob->xdir * PEAXSPEED-(US_RndT()>>4);\r\n\tnew->yspeed = PEAYSPEED;\r\n\tNewState (new,&s_peabrainfly);\r\n}\r\n\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= PeaPodThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid PeaPodThink (objtype *ob)\r\n{\r\n\tint delta;\r\n\r\n\tif ( abs(ob->y - player->y) > 3*TILEGLOBAL )\r\n\t\treturn;\r\n\r\n\tif (player->x < ob->x && ob->xdir == 1)\r\n\t\treturn;\r\n\r\n\tif (player->x > ob->x && ob->xdir == -1)\r\n\t\treturn;\r\n\r\n\tif (US_RndT()<8 && ob->temp1 < MAXPEASPIT)\r\n\t{\r\n\t\tob->temp1 ++;\r\n\t\tob->state = &s_peapodspit1;\r\n\t\tob->xmove = 0;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tBOOBUS TUBOR\r\n\r\ntemp4 = hit points\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define PREFRAGTHINK\t60\r\n#define POSTFRAGTHINK\t60\r\n\r\n#define SPDBOOBUSJUMP\t60\r\n#define SPDBOOBUSRUNJUMP 24\r\n\r\nvoid BoobusThink (objtype *ob);\r\nvoid FinishThink (objtype *ob);\r\nvoid FragThink (objtype *ob);\r\nvoid BoobusGroundReact (objtype *ob);\r\nvoid BoobusAirReact (objtype *ob);\r\n\r\nextern\tstatetype s_boobuswalk1;\r\nextern\tstatetype s_boobuswalk2;\r\nextern\tstatetype s_boobuswalk3;\r\nextern\tstatetype s_boobuswalk4;\r\n\r\nextern\tstatetype s_boobusjump;\r\n\r\nextern\tstatetype s_deathwait1;\r\nextern\tstatetype s_deathwait2;\r\nextern\tstatetype s_deathwait3;\r\nextern\tstatetype s_deathboom1;\r\nextern\tstatetype s_deathboom2;\r\nextern\tstatetype s_deathboom3;\r\nextern\tstatetype s_deathboom4;\r\nextern\tstatetype s_deathboom5;\r\nextern\tstatetype s_deathboom6;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_boobuswalk1\t= {BOOBUSWALKL1SPR,BOOBUSWALKR1SPR,step,false,\r\n\ttrue,10, 128,0, BoobusThink, NULL, BoobusGroundReact, &s_boobuswalk2};\r\nstatetype s_boobuswalk2\t= {BOOBUSWALKL2SPR,BOOBUSWALKR2SPR,step,false,\r\n\ttrue,10, 128,0, BoobusThink, NULL, BoobusGroundReact, &s_boobuswalk3};\r\nstatetype s_boobuswalk3\t= {BOOBUSWALKL3SPR,BOOBUSWALKR3SPR,step,false,\r\n\ttrue,10, 128,0, BoobusThink, NULL, BoobusGroundReact, &s_boobuswalk4};\r\nstatetype s_boobuswalk4\t= {BOOBUSWALKL4SPR,BOOBUSWALKR4SPR,step,false,\r\n\ttrue,10, 128,0, BoobusThink, NULL, BoobusGroundReact, &s_boobuswalk1};\r\n\r\nstatetype s_boobusjump\t= {BOOBUSJUMPSPR,BOOBUSJUMPSPR,think,false,\r\n\tfalse,0, 0,0, ProjectileThink, NULL, BoobusAirReact, NULL};\r\n\r\nstatetype s_boobusdie\t= {BOOBUSJUMPSPR,BOOBUSJUMPSPR,step,false,\r\n\tfalse,4, 0,0, FragThink, NULL, DrawReact, &s_boobusdie};\r\nstatetype s_boobusdie2\t= {NULL,NULL,step,false,\r\n\tfalse,4, 0,0, FragThink, NULL, NULL, &s_boobusdie2};\r\nstatetype s_boobusdie3\t= {NULL,NULL,step,false,\r\n\tfalse,250, 0,0, FinishThink, NULL, NULL, NULL};\r\n\r\nstatetype s_deathboom1\t= {BOOBUSBOOM1SPR,BOOBUSBOOM1SPR,step,false,\r\n\tfalse,20, 0,0, ProjectileThink, NULL, DrawReact3, &s_deathboom2};\r\nstatetype s_deathboom2\t= {BOOBUSBOOM2SPR,BOOBUSBOOM2SPR,step,false,\r\n\tfalse,20, 0,0, ProjectileThink, NULL, DrawReact3, &s_deathboom3};\r\nstatetype s_deathboom3\t= {POOF1SPR,POOF1SPR,step,false,\r\n\tfalse,40, 0,0, ProjectileThink, NULL, DrawReact3, &s_deathboom4};\r\nstatetype s_deathboom4\t= {POOF2SPR,POOF2SPR,step,false,\r\n\tfalse,30, 0,0, ProjectileThink, NULL, DrawReact3, &s_deathboom5};\r\nstatetype s_deathboom5\t= {POOF3SPR,POOF3SPR,step,false,\r\n\tfalse,30, 0,0, ProjectileThink, NULL, DrawReact3, &s_deathboom6};\r\nstatetype s_deathboom6\t= {POOF4SPR,POOF4SPR,step,false,\r\n\tfalse,30, 0,0, ProjectileThink, NULL, DrawReact3, NULL};\r\n\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n====================\r\n=\r\n= SpawnBoobus\r\n=\r\n====================\r\n*/\r\n\r\nvoid SpawnBoobus (int tilex, int tiley)\r\n{\r\n\tGetNewObj (false);\r\n\r\n\tnew->obclass = boobusobj;\r\n\tnew->x = tilex<<G_T_SHIFT;\r\n\tnew->y = (tiley<<G_T_SHIFT)-11*BLOCKSIZE;\r\n\tnew->xdir = -1;\r\n\tNewState (new,&s_boobuswalk1);\r\n\tnew->temp4 = 12;\t\t\t// hit points\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= FragThink\r\n=\r\n===================\r\n*/\r\n\r\nvoid FragThink (objtype *ob)\r\n{\r\n\tif (++ob->temp1 == PREFRAGTHINK)\r\n\t\tob->state = &s_boobusdie2;\r\n\tif (++ob->temp1 == POSTFRAGTHINK)\r\n\t{\r\n\t\tRF_RemoveSprite (&ob->sprite);\r\n\t\tob->state = &s_boobusdie3;\r\n\t}\r\n\r\n\tSD_PlaySound (BOMBBOOMSND);\r\n\tGetNewObj (true);\r\n\tnew->x = ob->x-BLOCKSIZE + 5*US_RndT();\r\n\tnew->y = ob->y-BLOCKSIZE + 5*US_RndT();\r\n\tnew->xspeed = 0; //US_RndT()/4-32;\r\n\tnew->yspeed = 0; //US_RndT()/4-32;\r\n\tUS_RndT();\t\t\t\t\t// keep rnd from even wrapping\r\n\tChangeState (new,&s_deathboom1);\r\n}\r\n\r\n\r\n/*\r\n===================\r\n=\r\n= FinishThink\r\n=\r\n===================\r\n*/\r\n\r\nvoid FinishThink (objtype *ob)\r\n{\r\n\tplaystate = victorious;\r\n\tob++;\r\n\tSD_PlaySound (BOOBUSGONESND);\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= BoobusThink\r\n=\r\n====================\r\n*/\r\n\r\nvoid BoobusThink (objtype *ob)\r\n{\r\n\tunsigned\tmove;\r\n\tboolean\tinline = false;\r\n\r\n\tif (ob->left > player->right)\r\n\t\tob->xdir = -1;\r\n\telse if (ob->right < player->left)\r\n\t\tob->xdir = 1;\r\n\telse\r\n\t\tinline = true;\r\n\r\n\tif (player->top < ob->bottom && player->bottom > ob->top)\r\n\t{\r\n\t// on same level as player, so charge!\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t// above or below player, so get directly in line and jump\r\n\t\tif (inline)\r\n\t\t{\r\n\t\t\tif (ob->y < player->y)\r\n\t\t\t{\r\n\t\t\t// drop down\r\n\t\t\t\tmove = PIXGLOBAL*8;\r\n\t\t\t\tob->tilebottom++;\r\n\t\t\t\tob->bottom += move;\r\n\t\t\t\tob->y += move;\r\n\t\t\t\tob->state = &s_boobusjump;\r\n\t\t\t\tob->yspeed = ob->xmove = ob->xspeed = ob->ymove = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t// jump up\r\n\t\t\t\tob->state = &s_boobusjump;\r\n\t\t\t\tob->yspeed = -SPDBOOBUSJUMP;\r\n\t\t\t\tob->xspeed = 0;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/*\r\n====================\r\n=\r\n= BoobusGroundReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid BoobusGroundReact (objtype *ob)\r\n{\r\n\tif (ob->xdir == 1 && ob->hitwest)\r\n\t{\r\n\t\tob->x -= ob->xmove;\r\n\t\tob->xdir = -1;\r\n\t\tob->nothink = US_RndT()>>5;\r\n\t\tChangeState (ob,ob->state);\r\n\t}\r\n\telse if (ob->xdir == -1 && ob->hiteast)\r\n\t{\r\n\t\tob->x -= ob->xmove;\r\n\t\tob->xdir = 1;\r\n\t\tob->nothink = US_RndT()>>5;\r\n\t\tChangeState (ob,ob->state);\r\n\t}\r\n\telse if (!ob->hitnorth)\r\n\t{\r\n\t\tif (ob->bottom >= player->bottom)\r\n\t\t{\r\n\t\t // jump over\r\n\t\t\tob->x -= ob->xmove;\r\n\t\t\tob->y -= ob->ymove;\r\n\t\t\tob->yspeed = -SPDBOOBUSJUMP;\r\n\t\t\tob->xspeed = ob->xdir * SPDBOOBUSRUNJUMP;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t// drop down\r\n\t\t\tob->xspeed = ob->yspeed = 0;\r\n\t\t}\r\n\t\tChangeState (ob,&s_boobusjump);\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= BoobusAirReact\r\n=\r\n====================\r\n*/\r\n\r\nvoid BoobusAirReact (objtype *ob)\r\n{\r\n\tif (ob->hitsouth)\r\n\t\tob->yspeed = 0;\r\n\r\n\tif (ob->hitnorth)\r\n\t\tChangeState (ob,&s_boobuswalk1);\r\n\r\n\tPLACESPRITE;\r\n}\r\n"
        },
        {
          "name": "kd_def.h",
          "type": "blob",
          "size": 9.1806640625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_DEF.H\r\n\r\n#include \"ID_HEADS.H\"\r\n#include <BIOS.H>\r\n#include \"SOFT.H\"\r\n#include \"SL_FILE.H\"\r\n\r\n#define FRILLS\t0\t\t\t// Cut out frills for 360K - MIKE MAYNARD\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\tGLOBAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define CREDITS 0\r\n\r\n#define\tMAXACTORS\tMAXSPRITES\r\n\r\n#define ACCGRAVITY\t3\r\n#define SPDMAXY\t\t80\r\n\r\n#define BLOCKSIZE\t(8*PIXGLOBAL)\t\t// for positioning starting actors\r\n\r\n//\r\n// movement scrolling edges\r\n//\r\n#define SCROLLEAST (TILEGLOBAL*11)\r\n#define SCROLLWEST (TILEGLOBAL*9)\r\n#define SCROLLSOUTH (TILEGLOBAL*8)\r\n#define SCROLLNORTH (TILEGLOBAL*4)\r\n\r\n#define CLIPMOVE\t24\t\t\t\t\t// speed to push out of a solid wall\r\n\r\n#define GAMELEVELS\t17\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\t TYPES\r\n\r\n=============================================================================\r\n*/\r\n\r\ntypedef\tenum\t{notdone,resetgame,levelcomplete,warptolevel,died,victorious}\r\n\t\t\t\texittype;\r\n\r\ntypedef\tenum\t{nothing,keenobj,powerobj,doorobj,\r\n\tbonusobj,broccoobj,tomatobj,carrotobj,celeryobj,asparobj,grapeobj,\r\n\ttaterobj,cartobj,frenchyobj,melonobj,turnipobj,cauliobj,brusselobj,\r\n\tmushroomobj,squashobj,apelobj,peapodobj,peabrainobj,boobusobj,\r\n\tshotobj,inertobj}\tclasstype;\r\n\r\ntypedef struct\r\n{\r\n  int \t\tleftshapenum,rightshapenum;\r\n  enum\t\t{step,slide,think,stepthink,slidethink} progress;\r\n  boolean\tskippable;\r\n\r\n  boolean\tpushtofloor;\r\n  int tictime;\r\n  int xmove;\r\n  int ymove;\r\n  void (*think) ();\r\n  void (*contact) ();\r\n  void (*react) ();\r\n  void *nextstate;\r\n} statetype;\r\n\r\n\r\ntypedef\tstruct\r\n{\r\n\tunsigned\tworldx,worldy;\r\n\tboolean\tleveldone[GAMELEVELS];\r\n\tlong\tscore,nextextra;\r\n\tint\t\tflowerpowers;\r\n\tint\t\tboobusbombs,bombsthislevel;\r\n\tint\t\tkeys;\r\n\tint\t\tmapon;\r\n\tint\t\tlives;\r\n\tint\t\tdifficulty;\r\n} gametype;\r\n\r\n\r\ntypedef struct\tobjstruct\r\n{\r\n\tclasstype\tobclass;\r\n\tenum\t\t{no,yes,allways,removable} active;\r\n\tboolean\t\tneedtoreact,needtoclip;\r\n\tunsigned\tnothink;\r\n\tunsigned\tx,y;\r\n\r\n\tint\t\t\txdir,ydir;\r\n\tint\t\t\txmove,ymove;\r\n\tint\t\t\txspeed,yspeed;\r\n\r\n\tint\t\t\tticcount,ticadjust;\r\n\tstatetype\t*state;\r\n\r\n\tunsigned\tshapenum;\r\n\r\n\tunsigned\tleft,top,right,bottom;\t// hit rectangle\r\n\tunsigned\tmidx;\r\n\tunsigned\ttileleft,tiletop,tileright,tilebottom;\t// hit rect in tiles\r\n\tunsigned\ttilemidx;\r\n\r\n\tint\t\t\thitnorth,hiteast,hitsouth,hitwest;\t// wall numbers contacted\r\n\r\n\tint\t\t\ttemp1,temp2,temp3,temp4;\r\n\r\n\tvoid\t\t*sprite;\r\n\r\n\tstruct\tobjstruct\t*next,*prev;\r\n} objtype;\r\n\r\n\r\nstruct BitMapHeader {\r\n\tunsigned int\tw,h,x,y;\r\n\tunsigned char\td,trans,comp,pad;\r\n};\r\n\r\nstruct BitMap {\r\n\tunsigned int Width;\r\n\tunsigned int Height;\r\n\tunsigned int Depth;\r\n\tunsigned int BytesPerRow;\r\n\tchar far *Planes[8];\r\n};\r\n\r\nstruct Shape {\r\n\tmemptr Data;\r\n\tlong size;\r\n\tunsigned int BPR;\r\n\tstruct BitMapHeader bmHdr;\r\n};\r\n\r\ntypedef struct {\r\n\tint handle;\t\t\t// handle of file\r\n\tmemptr buffer;\t\t// pointer to buffer\r\n\tword offset;\t\t// offset into buffer\r\n\tword status;\t\t// read/write status\r\n} BufferedIO;\r\n\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t KD_MAIN.C DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern\tchar\tstr[80],str2[20];\r\nextern\tboolean\tsinglestep,jumpcheat,godmode,tedlevel;\r\nextern\tunsigned\ttedlevelnum;\r\n\r\nvoid\tDebugMemory (void);\r\nvoid\tTestSprites(void);\r\nint\t\tDebugKeys (void);\r\nvoid\tStartupId (void);\r\nvoid\tShutdownId (void);\r\nvoid\tQuit (char *error);\r\nvoid\tInitGame (void);\r\nvoid\tmain (void);\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t  KD_DEMO.C DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tFinale (void);\r\nvoid\tGameOver (void);\r\nvoid\tDemoLoop (void);\r\nvoid\tStatusWindow (void);\r\nvoid\tNewGame (void);\r\nvoid\tTEDDeath (void);\r\n\r\nboolean\tLoadGame (int file);\r\nboolean\tSaveGame (int file);\r\nvoid\tResetGame (void);\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t  KD_PLAY.C DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nextern\tgametype\tgamestate;\r\nextern\texittype\tplaystate;\r\nextern\tboolean\t\tbutton0held,button1held;\r\nextern\tunsigned\toriginxtilemax,originytilemax;\r\nextern\tobjtype\t\t*new,*check,*player,*scoreobj;\r\n\r\nextern\tControlInfo\tc;\r\n\r\nextern\tobjtype dummyobj;\r\n\r\nextern\tchar\t\t*levelnames[21];\r\n\r\nvoid\tCheckKeys (void);\r\nvoid\tCalcInactivate (void);\r\nvoid \tInitObjArray (void);\r\nvoid \tGetNewObj (boolean usedummy);\r\nvoid\tRemoveObj (objtype *gone);\r\nvoid \tScanInfoPlane (void);\r\nvoid \tPatchWorldMap (void);\r\nvoid \tMarkTileGraphics (void);\r\nvoid \tFadeAndUnhook (void);\r\nvoid \tSetupGameLevel (boolean loadnow);\r\nvoid \tScrollScreen (void);\r\nvoid \tMoveObjVert (objtype *ob, int ymove);\r\nvoid \tMoveObjHoriz (objtype *ob, int xmove);\r\nvoid \tGivePoints (unsigned points);\r\nvoid \tClipToEnds (objtype *ob);\r\nvoid \tClipToEastWalls (objtype *ob);\r\nvoid \tClipToWestWalls (objtype *ob);\r\nvoid \tClipToWalls (objtype *ob);\r\nvoid\tClipToSprite (objtype *push, objtype *solid, boolean squish);\r\nvoid\tClipToSpriteSide (objtype *push, objtype *solid);\r\nint \tDoActor (objtype *ob,int tics);\r\nvoid \tStateMachine (objtype *ob);\r\nvoid \tNewState (objtype *ob,statetype *state);\r\nvoid \tPlayLoop (void);\r\nvoid \tGameLoop (void);\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t  KD_KEEN.C DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tCalcSingleGravity (void);\r\n\r\nvoid\tProjectileThink\t\t(objtype *ob);\r\nvoid\tVelocityThink\t\t(objtype *ob);\r\nvoid\tDrawReact\t\t\t(objtype *ob);\r\n\r\nvoid\tSpawnScore (void);\r\nvoid\tFixScoreBox (void);\r\nvoid\tSpawnWorldKeen (int tilex, int tiley);\r\nvoid\tSpawnKeen (int tilex, int tiley, int dir);\r\n\r\nvoid \tKillKeen (void);\r\n\r\nextern\tint\tsinglegravity;\r\nextern\tunsigned\tbounceangle[8][8];\r\n\r\nextern\tstatetype s_keendie1;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t  KD_ACT1.C DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid WalkReact (objtype *ob);\r\n\r\nvoid \tDoGravity (objtype *ob);\r\nvoid\tAccelerateX (objtype *ob,int dir,int max);\r\nvoid \tFrictionX (objtype *ob);\r\n\r\nvoid\tProjectileThink\t\t(objtype *ob);\r\nvoid\tVelocityThink\t\t(objtype *ob);\r\nvoid\tDrawReact\t\t\t(objtype *ob);\r\nvoid\tDrawReact2\t\t\t(objtype *ob);\r\nvoid\tDrawReact3\t\t\t(objtype *ob);\r\nvoid\tChangeState (objtype *ob, statetype *state);\r\n\r\nvoid\tChangeToFlower (objtype *ob);\r\n\r\nvoid\tSpawnBonus (int tilex, int tiley, int type);\r\nvoid\tSpawnDoor (int tilex, int tiley);\r\nvoid \tSpawnBrocco (int tilex, int tiley);\r\nvoid \tSpawnTomat (int tilex, int tiley);\r\nvoid \tSpawnCarrot (int tilex, int tiley);\r\nvoid \tSpawnAspar (int tilex, int tiley);\r\nvoid \tSpawnGrape (int tilex, int tiley);\r\n\r\nextern\tstatetype s_doorraise;\r\n\r\nextern\tstatetype s_bonus;\r\nextern\tstatetype s_bonusrise;\r\n\r\nextern\tstatetype s_broccosmash3;\r\nextern\tstatetype s_broccosmash4;\r\n\r\nextern\tstatetype s_grapefall;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t  KD_ACT2.C DEFINITIONS\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid SpawnTater (int tilex, int tiley);\r\nvoid SpawnCart (int tilex, int tiley);\r\nvoid SpawnFrenchy (int tilex, int tiley);\r\nvoid SpawnMelon (int tilex, int tiley,int dir);\r\nvoid SpawnSquasher (int tilex, int tiley);\r\nvoid SpawnApel (int tilex, int tiley);\r\nvoid SpawnPeaPod (int tilex, int tiley);\r\nvoid SpawnPeaBrain (int tilex, int tiley);\r\nvoid SpawnBoobus (int tilex, int tiley);\r\n\r\nextern\tstatetype s_taterattack2;\r\nextern\tstatetype s_squasherjump2;\r\nextern\tstatetype s_boobusdie;\r\n\r\nextern\tstatetype s_deathwait1;\r\nextern\tstatetype s_deathwait2;\r\nextern\tstatetype s_deathwait3;\r\nextern\tstatetype s_deathboom1;\r\nextern\tstatetype s_deathboom2;\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n//\r\n//\t\t\t\t\t\tGELIB.C DEFINITIONS\r\n//\r\n/////////////////////////////////////////////////////////////////////////////\r\n\r\nvoid FreeShape(struct Shape *shape);\r\nint UnpackEGAShapeToScreen(struct Shape *SHP,int startx,int starty);\r\n\r\nlong Verify(char *filename);\r\nmemptr InitBufferedIO(int handle, BufferedIO *bio);\r\nvoid FreeBufferedIO(BufferedIO *bio);\r\nbyte bio_readch(BufferedIO *bio);\r\nvoid bio_fillbuffer(BufferedIO *bio);\r\nvoid SwapLong(long far *Var);\r\nvoid SwapWord(unsigned int far *Var);\r\nvoid MoveGfxDst(short x, short y);"
        },
        {
          "name": "kd_demo.c",
          "type": "blob",
          "size": 10.34765625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_DEMO.C\r\n\r\n#include <dir.h>\r\n#include \"KD_DEF.H\"\r\n\r\n#pragma\thdrstop\r\n\r\n#define RLETAG\t0xABCD\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= NewGame\r\n=\r\n= Set up new game to start from the beginning\r\n=\r\n=====================\r\n*/\r\n\r\nvoid NewGame (void)\r\n{\r\n\tword\ti;\r\n\r\n\tgamestate.worldx = 0;\t\t// spawn keen at starting spot\r\n\r\n\tgamestate.mapon = 0;\r\n\tgamestate.score = 0;\r\n\tgamestate.nextextra = 20000;\r\n\tgamestate.lives = 3;\r\n\tgamestate.flowerpowers = gamestate.boobusbombs = 0;\r\n\tfor (i = 0;i < GAMELEVELS;i++)\r\n\t\tgamestate.leveldone[i] = false;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= WaitOrKey\r\n=\r\n=====================\r\n*/\r\n\r\nint WaitOrKey (int vbls)\r\n{\r\n\twhile (vbls--)\r\n\t{\r\n\t\tIN_ReadControl(0,&c);\t\t// get player input\r\n\t\tif (LastScan || c.button0 || c.button1)\r\n\t\t{\r\n\t\t\tIN_ClearKeysDown ();\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\tVW_WaitVBL(1);\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= GameOver\r\n=\r\n=====================\r\n*/\r\n\r\nvoid\r\nGameOver (void)\r\n{\r\n\tVW_InitDoubleBuffer ();\r\n\tUS_CenterWindow (16,3);\r\n\r\n\tUS_PrintCentered(\"Game Over!\");\r\n\r\n\tVW_UpdateScreen ();\r\n\tIN_ClearKeysDown ();\r\n\tIN_Ack ();\r\n\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==================\r\n=\r\n= StatusWindow\r\n=\r\n==================\r\n*/\r\n\r\nvoid StatusWindow (void)\r\n{\r\n\tword\tx;\r\n\r\n\t// DEBUG - make this look better\r\n\r\n\tUS_CenterWindow(22,7);\r\n\tUS_CPrint(\"Status Window\");\r\n\r\n\tWindowX += 8;\r\n\tWindowW -= 8;\r\n\tWindowY += 20;\r\n\tWindowH -= 20;\r\n\tPrintX = WindowX;\r\n\tPrintY = WindowY;\r\n\r\n\tVWB_DrawTile8(PrintX,PrintY,26);\r\n\tVWB_DrawTile8(PrintX + 8,PrintY,27);\r\n\tPrintX += 24;\r\n\tUS_PrintUnsigned(gamestate.lives);\r\n\tUS_Print(\"\\n\");\r\n\r\n\tVWB_DrawTile8(PrintX,PrintY,32);\r\n\tVWB_DrawTile8(PrintX + 8,PrintY,33);\r\n\tVWB_DrawTile8(PrintX,PrintY + 8,34);\r\n\tVWB_DrawTile8(PrintX + 8,PrintY + 8,35);\r\n\tPrintX += 24;\r\n\tUS_PrintUnsigned(gamestate.boobusbombs);\r\n\tUS_Print(\"\\n\");\r\n\r\n\tWindowX += 50;\r\n\tWindowW -= 50;\r\n\tPrintX = WindowX;\r\n\tPrintY = WindowY;\r\n\r\n\tfontcolor = F_FIRSTCOLOR;\r\n\tUS_Print(\"Next \");\r\n\tfontcolor = F_BLACK;\r\n\tx = PrintX;\r\n\tVWB_DrawTile8(PrintX,PrintY,26);\r\n\tVWB_DrawTile8(PrintX + 8,PrintY,27);\r\n\tPrintX += 24;\r\n\tUS_PrintUnsigned(gamestate.nextextra);\r\n\tUS_Print(\"\\n\");\r\n\r\n\tPrintX = x;\r\n\tVWB_DrawTile8(PrintX,PrintY,24);\r\n\tVWB_DrawTile8(PrintX + 8,PrintY,25);\r\n\tPrintX += 24;\r\n\tUS_PrintUnsigned(gamestate.keys);\r\n\tUS_Print(\"\\n\");\r\n\r\n\t// DEBUG - add flower powers (#36)\r\n\r\n\tVW_UpdateScreen();\r\n\tIN_Ack();\r\n}\r\n\r\nboolean\r\nSaveGame(int file)\r\n{\r\n\tword\ti,size,compressed,expanded;\r\n\tobjtype\t*o;\r\n\tmemptr\tbigbuffer;\r\n\r\n\tif (!CA_FarWrite(file,(void far *)&gamestate,sizeof(gamestate)))\r\n\t\treturn(false);\r\n\r\n\texpanded = mapwidth * mapheight * 2;\r\n\tMM_GetPtr (&bigbuffer,expanded);\r\n\r\n\tfor (i = 0;i < 3;i++)\t// Write all three planes of the map\r\n\t{\r\n//\r\n// leave a word at start of compressed data for compressed length\r\n//\r\n\t\tcompressed = CA_RLEWCompress ((unsigned huge *)mapsegs[i]\r\n\t\t\t,expanded,((unsigned huge *)bigbuffer)+1,RLETAG);\r\n\r\n\t\t*(unsigned huge *)bigbuffer = compressed;\r\n\r\n\t\tif (!CA_FarWrite(file,(void far *)bigbuffer,compressed+2) )\r\n\t\t{\r\n\t\t\tMM_FreePtr (&bigbuffer);\r\n\t\t\treturn(false);\r\n\t\t}\r\n\t}\r\n\r\n\tfor (o = player;o;o = o->next)\r\n\t\tif (!CA_FarWrite(file,(void far *)o,sizeof(objtype)))\r\n\t\t{\r\n\t\t\tMM_FreePtr (&bigbuffer);\r\n\t\t\treturn(false);\r\n\t\t}\r\n\r\n\tMM_FreePtr (&bigbuffer);\r\n\treturn(true);\r\n}\r\n\r\n\r\nboolean\r\nLoadGame(int file)\r\n{\r\n\tword\ti,j,size;\r\n\tobjtype\t*o;\r\n\tint orgx,orgy;\r\n\tobjtype\t\t*prev,*next,*followed;\r\n\tunsigned\tcompressed,expanded;\r\n\tmemptr\tbigbuffer;\r\n\r\n\tif (!CA_FarRead(file,(void far *)&gamestate,sizeof(gamestate)))\r\n\t\treturn(false);\r\n\r\n// drop down a cache level and mark everything, so when the option screen\r\n// is exited it will be cached\r\n\r\n\tca_levelbit >>= 1;\r\n\tca_levelnum--;\r\n\r\n\tSetupGameLevel (false);\t\t// load in and cache the base old level\r\n\ttitleptr[ca_levelnum] = levelnames[mapon];\r\n\r\n\tca_levelbit <<= 1;\r\n\tca_levelnum ++;\r\n\r\n\texpanded = mapwidth * mapheight * 2;\r\n\tMM_GetPtr (&bigbuffer,expanded);\r\n\r\n\tfor (i = 0;i < 3;i++)\t// Read all three planes of the map\r\n\t{\r\n\t\tif (!CA_FarRead(file,(void far *)&compressed,sizeof(compressed)) )\r\n\t\t{\r\n\t\t\tMM_FreePtr (&bigbuffer);\r\n\t\t\treturn(false);\r\n\t\t}\r\n\r\n\t\tif (!CA_FarRead(file,(void far *)bigbuffer,compressed) )\r\n\t\t{\r\n\t\t\tMM_FreePtr (&bigbuffer);\r\n\t\t\treturn(false);\r\n\t\t}\r\n\r\n\t\tCA_RLEWexpand ((unsigned huge *)bigbuffer,\r\n\t\t\t(unsigned huge *)mapsegs[i],compressed,RLETAG);\r\n\t}\r\n\r\n\tMM_FreePtr (&bigbuffer);\r\n\r\n\t// Read the object list back in - assumes at least one object in list\r\n\r\n\tInitObjArray ();\r\n\tnew = player;\r\n\tprev = new->prev;\r\n\tnext = new->next;\r\n\tif (!CA_FarRead(file,(void far *)new,sizeof(objtype)))\r\n\t\treturn(false);\r\n\tnew->prev = prev;\r\n\tnew->next = next;\r\n\tnew->needtoreact = true;\r\n\tnew->sprite = NULL;\r\n\tnew = scoreobj;\r\n\twhile (true)\r\n\t{\r\n\t\tprev = new->prev;\r\n\t\tnext = new->next;\r\n\t\tif (!CA_FarRead(file,(void far *)new,sizeof(objtype)))\r\n\t\t\treturn(false);\r\n\t\tfollowed = new->next;\r\n\t\tnew->prev = prev;\r\n\t\tnew->next = next;\r\n\t\tnew->needtoreact = true;\r\n\t\tnew->sprite = NULL;\r\n\r\n\t\tif (followed)\r\n\t\t\tGetNewObj (false);\r\n\t\telse\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\t*((long *)&(scoreobj->temp1)) = -1;\t\t// force score to be updated\r\n\tscoreobj->temp3 = -1;\t\t\t// and flower power\r\n\tscoreobj->temp4 = -1;\t\t\t// and lives\r\n\r\n\treturn(true);\r\n}\r\n\r\nvoid\r\nResetGame(void)\r\n{\r\n\tNewGame ();\r\n\r\n\tca_levelnum--;\r\n\tCA_ClearMarks();\r\n\ttitleptr[ca_levelnum] = NULL;\t\t// don't reload old level\r\n\tca_levelnum++;\r\n}\r\n\r\n#if FRILLS\r\nvoid\r\nTEDDeath(void)\r\n{\r\n\tShutdownId();\r\n\texeclp(\"TED5.EXE\",\"TED5.EXE\",\"/LAUNCH\",\"KDREAMS\",NULL);\r\n}\r\n#endif\r\n\r\nstatic boolean\r\nMoveTitleTo(int offset)\r\n{\r\n\tboolean\t\tdone;\r\n\tint\t\t\tdir,\r\n\t\t\t\tchunk,\r\n\t\t\t\tmove;\r\n\tlongword\tlasttime,delay;\r\n\r\n\tif (offset < originxglobal)\r\n\t\tdir = -1;\r\n\telse\r\n\t\tdir = +1;\r\n\r\n\tchunk = dir * PIXGLOBAL;\r\n\r\n\tdone = false;\r\n\tdelay = 1;\r\n\twhile (!done)\r\n\t{\r\n\t\tlasttime = TimeCount;\r\n\t\tmove = delay * chunk;\r\n\t\tif (chunk < 0)\r\n\t\t\tdone = originxglobal + move <= offset;\r\n\t\telse\r\n\t\t\tdone = originxglobal + move >= offset;\r\n\t\tif (!done)\r\n\t\t{\r\n\t\t\tRF_Scroll(move,0);\r\n\t\t\tRF_Refresh();\r\n\t\t}\r\n\t\tif (IN_IsUserInput())\r\n\t\t\treturn(true);\r\n\t\tdelay = TimeCount - lasttime;\r\n\t}\r\n\tif (originxglobal != offset)\r\n\t{\r\n\t\tRF_Scroll(offset - originxglobal,0);\r\n\t\tRF_Refresh();\r\n\t}\r\n\treturn(false);\r\n}\r\n\r\nstatic boolean\r\nWait(longword time)\r\n{\r\n\ttime += TimeCount;\r\n\twhile ((TimeCount < time) && (!IN_IsUserInput()))\r\n\t{\r\n\t\tif (!(TimeCount % MINTICS))\r\n\t\t\tRF_Refresh();\r\n\t}\r\n\treturn(IN_IsUserInput());\r\n}\r\n\r\nstatic boolean\r\nShowText(int offset,WindowRec *wr,char *s)\r\n{\r\n\tif (MoveTitleTo(offset))\r\n\t\treturn(true);\r\n\r\n\tUS_RestoreWindow(wr);\r\n\tUS_CPrint(s);\r\n\tVW_UpdateScreen();\r\n\r\n\tif (Wait(TickBase * 5))\r\n\t\treturn(true);\r\n\r\n\tUS_RestoreWindow(wr);\r\n\tUS_CPrint(s);\r\n\tVW_UpdateScreen();\r\n\treturn(false);\r\n}\r\n\r\n/*\r\n=====================\r\n=\r\n= DemoLoop\r\n=\r\n=====================\r\n*/\r\n\r\nvoid\r\nDemoLoop (void)\r\n{\r\n\tchar\t\t*s;\r\n\tword\t\tmove;\r\n\tlongword\tlasttime;\r\n\tchar *FileName1;\r\n\tstruct Shape FileShape1;\r\n#if CREDITS\r\n\tchar *FileName2;\r\n\tstruct Shape FileShape2;\r\n#endif\r\n\tstruct ffblk ffblk;\r\n\tWindowRec\tmywin;\r\n\tint bufsave\t= bufferofs;\r\n\tint dissave\t= displayofs;\r\n\r\n\r\n#if FRILLS\r\n//\r\n// check for launch from ted\r\n//\r\n\tif (tedlevel)\r\n\t{\r\n\t\tNewGame();\r\n\t\tgamestate.mapon = tedlevelnum;\r\n\t\tGameLoop();\r\n\t\tTEDDeath();\r\n\t}\r\n#endif\r\n\r\n//\r\n// demo loop\r\n//\r\n\tUS_SetLoadSaveHooks(LoadGame,SaveGame,ResetGame);\r\n\trestartgame = gd_Continue;\r\n\r\n\tif (findfirst(\"KDREAMS.CMP\", &ffblk, 0) == -1)\r\n\t\tQuit(\"Couldn't find KDREAMS.CMP\");\r\n\r\n\twhile (true)\r\n\t{\r\n\r\n\t\tloadedgame = false;\r\n\r\n\t\tFileName1 = \"TITLESCR.LBM\";\r\n\t\tif (LoadLIBShape(\"KDREAMS.CMP\", FileName1, &FileShape1))\r\n\t\t\tQuit(\"Can't load TITLE SCREEN\");\r\n#if CREDITS\r\n\t\tFileName2 = \"CREDITS.LBM\";\r\n\t\tif (LoadLIBShape(\"KDREAMS.CMP\", FileName2, &FileShape2))\r\n\t\t\tQuit(\"Can't load CREDITS SCREEN\");\r\n#endif\r\n\r\n\t\twhile (!restartgame && !loadedgame)\r\n\t\t{\r\n\r\n\t\t\tVW_InitDoubleBuffer();\r\n\t\t\tIN_ClearKeysDown();\r\n\r\n\t\t\twhile (true)\r\n\t\t\t{\r\n\r\n\t\t\t\tVW_SetScreen(0, 0);\r\n\t\t\t\tMoveGfxDst(0, 200);\r\n\t\t\t\tUnpackEGAShapeToScreen(&FileShape1, 0, 0);\r\n\t\t\t\tVW_ScreenToScreen (64*200,0,40,200);\r\n\r\n#if CREDITS\r\n\t\t\t\tif (IN_UserInput(TickBase * 8, false))\r\n\t\t\t\t\tbreak;\r\n#else\r\n\t\t\t\tif (IN_UserInput(TickBase * 4, false))\r\n\t\t\t\t\tbreak;\r\n#endif\r\n\r\n#if CREDITS\r\n\t\t\t\tMoveGfxDst(0, 200);\r\n\t\t\t\tUnpackEGAShapeToScreen(&FileShape2, 0, 0);\r\n\t\t\t\tVW_ScreenToScreen (64*200,0,40,200);\r\n\r\n\t\t\t\tif (IN_UserInput(TickBase * 7, false))\r\n\t\t\t\t\tbreak;\r\n#else\r\n\t\t\t\tMoveGfxDst(0, 200);\r\n\t\t\t\tUnpackEGAShapeToScreen(&FileShape1, 0, 0);\r\n\t\t\t\tVW_ScreenToScreen (64*200,0,40,200);\r\n\r\n\t\t\t\tif (IN_UserInput(TickBase * 3, false))\r\n\t\t\t\t\tbreak;\r\n#endif\r\n\r\n\t\t\t\tdisplayofs = 0;\r\n\t\t\t\tVWB_Bar(0,0,320,200,FIRSTCOLOR);\r\n\t\t\t\tUS_DisplayHighScores(-1);\r\n\r\n\t\t\t\tif (IN_UserInput(TickBase * 6, false))\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbufferofs = bufsave;\r\n\t\t\tdisplayofs = dissave;\r\n\r\n\t\t\tVW_FixRefreshBuffer();\r\n\t\t\tUS_ControlPanel ();\r\n\t\t}\r\n\r\n\t\tif (!loadedgame)\r\n\t\t\tNewGame();\r\n\r\n\t\tFreeShape(&FileShape1);\r\n#if CREDITS\r\n\t\tFreeShape(&FileShape2);\r\n#endif\r\n\t\tGameLoop();\r\n\t}\r\n}\r\n"
        },
        {
          "name": "kd_keen.c",
          "type": "blob",
          "size": 56.0244140625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_KEEN.C\r\n\r\n#include \"KD_DEF.H\"\r\n#pragma hdrstop\r\n\r\n/*\r\n\r\nplayer->temp1 = pausetime / pointer to zees when sleeping\r\nplayer->temp2 = pausecount / stagecount\r\nplayer->temp3 =\r\nplayer->temp4 =\r\n\r\n\r\n*/\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define KEENPRIORITY\t1\r\n\r\n#define PLACESPRITE RF_PlaceSprite (&ob->sprite,ob->x,ob->y,ob->shapenum, \\\r\n\tspritedraw,KEENPRIORITY);\r\n\r\n#define\tMINPOLEJUMPTICS\t19\t// wait tics before allowing a pole regram\r\n\r\n#define SPDRUNJUMP\t\t16\r\n#define SPDPOLESIDEJUMP\t8\r\n#define WALKAIRSPEED\t8\r\n#define DIVESPEED\t\t32\r\n#define\tJUMPTIME\t\t16\r\n#define\tPOLEJUMPTIME\t10\r\n#define\tSPDJUMP\t\t\t40\r\n#define\tSPDDIVEUP\t\t16\r\n#define\tSPDPOLEJUMP\t\t20\r\n\r\n#define SPDPOWERUP\t\t-64\r\n#define SPDPOWER\t\t64\r\n#define SPDPOWERY\t\t-20\r\n#define POWERCOUNT\t\t50\r\n\r\n#define MAXXSPEED   24\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nint\tsinglegravity;\r\nunsigned\tbounceangle[8][8] =\r\n{\r\n{0,0,0,0,0,0,0,0},\r\n{7,6,5,4,3,2,1,0},\r\n{5,4,3,2,1,0,15,14},\r\n{5,4,3,2,1,0,15,14},\r\n{3,2,1,0,15,14,13,12},\r\n{9,8,7,6,5,4,3,2},\r\n{9,8,7,6,5,4,3,2},\r\n{11,10,9,8,7,6,5,4}\r\n};\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nint\tjumptime;\r\nlong\tleavepoletime;\t\t// TimeCount when jumped off pole\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t SCORE BOX ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tSpawnScore (void);\r\nvoid ScoreThink (objtype *ob);\r\nvoid ScoreReact (objtype *ob);\r\n\r\nvoid MemDrawChar (int char8,byte far *dest,unsigned width,unsigned planesize);\r\n\r\nstatetype s_score\t= {NULL,NULL,think,false,\r\n\tfalse,0, 0,0, ScoreThink , NULL, ScoreReact, NULL};\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= SpawnScore\r\n=\r\n======================\r\n*/\r\n\r\nvoid\tSpawnScore (void)\r\n{\r\n\tscoreobj->obclass = inertobj;\r\n\tscoreobj->active = allways;\r\n\tscoreobj->needtoclip = false;\r\n\t*((long *)&(scoreobj->temp1)) = -1;\t\t// force score to be updated\r\n\tscoreobj->temp3 = -1;\t\t\t// and flower power\r\n\tscoreobj->temp4 = -1;\t\t\t// and lives\r\n\tNewState (scoreobj,&s_score);\r\n}\r\n\r\n\r\nvoid\tFixScoreBox (void)\r\n{\r\n\tunsigned\twidth, planesize;\r\n\tunsigned smallplane,bigplane;\r\n\tspritetype\t_seg\t*block;\r\n\tbyte\tfar\t*dest;\r\n\r\n// draw boobus bomb if on level 15, else flower power\r\n\tblock = (spritetype _seg *)grsegs[SCOREBOXSPR];\r\n\twidth = block->width[0];\r\n\tplanesize = block->planesize[0];\r\n\tdest = (byte far *)grsegs[SCOREBOXSPR]+block->sourceoffset[0]\r\n\t\t+ planesize + width*16 + 4*CHARWIDTH;\r\n\tif (mapon == 15)\r\n\t{\r\n\t\tMemDrawChar (20,dest,width,planesize);\r\n\t\tMemDrawChar (21,dest+CHARWIDTH,width,planesize);\r\n\t\tMemDrawChar (22,dest+width*8,width,planesize);\r\n\t\tMemDrawChar (23,dest+width*8+CHARWIDTH,width,planesize);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tMemDrawChar (28,dest,width,planesize);\r\n\t\tMemDrawChar (29,dest+CHARWIDTH,width,planesize);\r\n\t\tMemDrawChar (30,dest+width*8,width,planesize);\r\n\t\tMemDrawChar (31,dest+width*8+CHARWIDTH,width,planesize);\r\n\t}\r\n\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= MemDrawChar\r\n=\r\n======================\r\n*/\r\n\r\n#if GRMODE == EGAGR\r\n\r\nvoid MemDrawChar (int char8,byte far *dest,unsigned width,unsigned planesize)\r\n{\r\nasm\tmov\tsi,[char8]\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\t\t// index into char 8 segment\r\n\r\nasm\tmov\tds,[WORD PTR grsegs+STARTTILE8*2]\r\nasm\tmov\tes,[WORD PTR dest+2]\r\n\r\nasm\tmov\tcx,4\t\t// draw four planes\r\nasm\tmov\tbx,[width]\r\nasm\tdec\tbx\r\n\r\nplaneloop:\r\n\r\nasm\tmov\tdi,[WORD PTR dest]\r\n\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\nasm\tadd\tdi,bx\r\nasm\tmovsb\r\n\r\nasm\tmov\tax,[planesize]\r\nasm\tadd\t[WORD PTR dest],ax\r\n\r\nasm\tloop\tplaneloop\r\n\r\nasm\tmov\tax,ss\r\nasm\tmov\tds,ax\r\n\r\n}\r\n#endif\r\n\r\n#if GRMODE == CGAGR\r\nvoid MemDrawChar (int char8,byte far *dest,unsigned width,unsigned planesize)\r\n{\r\nasm\tmov\tsi,[char8]\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\r\nasm\tshl\tsi,1\t\t// index into char 8 segment\r\n\r\nasm\tmov\tds,[WORD PTR grsegs+STARTTILE8*2]\r\nasm\tmov\tes,[WORD PTR dest+2]\r\n\r\nasm\tmov\tbx,[width]\r\nasm\tsub\tbx,2\r\n\r\nasm\tmov\tdi,[WORD PTR dest]\r\n\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\nasm\tadd\tdi,bx\r\nasm\tmovsw\r\n\r\nasm\tmov\tax,ss\r\nasm\tmov\tds,ax\r\n\r\n\tplanesize++;\t\t// shut the compiler up\r\n}\r\n#endif\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= ShiftScore\r\n=\r\n====================\r\n*/\r\n#if GRMODE == EGAGR\r\nvoid ShiftScore (void)\r\n{\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg *dest;\r\n\r\n\tspr = &spritetable[SCOREBOXSPR-STARTSPRITES];\r\n\tdest = (spritetype _seg *)grsegs[SCOREBOXSPR];\r\n\r\n\tCAL_ShiftSprite (FP_SEG(dest),dest->sourceoffset[0],\r\n\t\tdest->sourceoffset[1],spr->width,spr->height,2);\r\n\r\n\tCAL_ShiftSprite (FP_SEG(dest),dest->sourceoffset[0],\r\n\t\tdest->sourceoffset[2],spr->width,spr->height,4);\r\n\r\n\tCAL_ShiftSprite (FP_SEG(dest),dest->sourceoffset[0],\r\n\t\tdest->sourceoffset[3],spr->width,spr->height,6);\r\n}\r\n#endif\r\n\r\n/*\r\n===============\r\n=\r\n= ScoreThink\r\n=\r\n===============\r\n*/\r\n\r\nvoid ScoreThink (objtype *ob)\r\n{\r\n\tchar\t\tstr[10],*ch;\r\n\tspritetype\t_seg\t*block;\r\n\tbyte\t\tfar *dest;\r\n\tunsigned\ti, length, width, planesize, number;\r\n\r\n//\r\n// score changed\r\n//\r\n\tif ((gamestate.score>>16) != ob->temp1\r\n\t\t|| (unsigned)gamestate.score != ob->temp2 )\r\n\t{\r\n\t\tblock = (spritetype _seg *)grsegs[SCOREBOXSPR];\r\n\t\twidth = block->width[0];\r\n\t\tplanesize = block->planesize[0];\r\n\t\tdest = (byte far *)grsegs[SCOREBOXSPR]+block->sourceoffset[0]\r\n\t\t\t+ planesize + width*4 + 1*CHARWIDTH;\r\n\r\n\t\tltoa (gamestate.score,str,10);\r\n\r\n\t\t// erase leading spaces\r\n\t\tlength = strlen(str);\r\n\t\tfor (i=6;i>length;i--)\r\n\t\t\tMemDrawChar (0,dest+=CHARWIDTH,width,planesize);\r\n\r\n\t\t// draw digits\r\n\t\tch = str;\r\n\t\twhile (*ch)\r\n\t\t\tMemDrawChar (*ch++ - '0'+1,dest+=CHARWIDTH,width,planesize);\r\n\r\n#if GRMODE == EGAGR\r\n\t\tShiftScore ();\r\n#endif\r\n\t\tob->needtoreact = true;\r\n\t\tob->temp1 = gamestate.score>>16;\r\n\t\tob->temp2 = gamestate.score;\r\n\t}\r\n\r\n//\r\n// flower power changed\r\n//\r\n\tif (mapon == 15)\r\n\t\tnumber = gamestate.boobusbombs;\r\n\telse\r\n\t\tnumber = gamestate.flowerpowers;\r\n\tif (number != ob->temp3)\r\n\t{\r\n\t\tblock = (spritetype _seg *)grsegs[SCOREBOXSPR];\r\n\t\twidth = block->width[0];\r\n\t\tplanesize = block->planesize[0];\r\n\t\tdest = (byte far *)grsegs[SCOREBOXSPR]+block->sourceoffset[0]\r\n\t\t\t+ planesize + width*20 + 5*CHARWIDTH;\r\n\r\n\t\tif (number > 99)\r\n\t\t\tstrcpy (str,\"99\");\r\n\t\telse\r\n\t\t\tltoa (number,str,10);\r\n\r\n\t\t// erase leading spaces\r\n\t\tlength = strlen(str);\r\n\t\tfor (i=2;i>length;i--)\r\n\t\t\tMemDrawChar (0,dest+=CHARWIDTH,width,planesize);\r\n\r\n\t\t// draw digits\r\n\t\tch = str;\r\n\t\twhile (*ch)\r\n\t\t\tMemDrawChar (*ch++ - '0'+1,dest+=CHARWIDTH,width,planesize);\r\n\r\n#if GRMODE == EGAGR\r\n\t\tShiftScore ();\r\n#endif\r\n\t\tob->needtoreact = true;\r\n\t\tob->temp3 = gamestate.flowerpowers;\r\n\t}\r\n\r\n//\r\n// lives changed\r\n//\r\n\tif (gamestate.lives != ob->temp4)\r\n\t{\r\n\t\tblock = (spritetype _seg *)grsegs[SCOREBOXSPR];\r\n\t\twidth = block->width[0];\r\n\t\tplanesize = block->planesize[0];\r\n\t\tdest = (byte far *)grsegs[SCOREBOXSPR]+block->sourceoffset[0]\r\n\t\t\t+ planesize + width*20 + 2*CHARWIDTH;\r\n\r\n\t\tif (gamestate.lives>9)\r\n\t\t\tMemDrawChar ('9' - '0'+1,dest,width,planesize);\r\n\t\telse\r\n\t\t\tMemDrawChar (gamestate.lives +1,dest,width,planesize);\r\n\r\n#if GRMODE == EGAGR\r\n\t\tShiftScore ();\r\n#endif\r\n\t\tob->needtoreact = true;\r\n\t\tob->temp4 = gamestate.lives;\r\n\t}\r\n\r\n\tif (originxglobal != ob->x || originyglobal != ob->y)\r\n\t\tob->needtoreact = true;\r\n}\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= ScoreReact\r\n=\r\n===============\r\n*/\r\n\r\nvoid ScoreReact (objtype *ob)\r\n{\r\n\tob->x = originxglobal;\r\n\tob->y = originyglobal;\r\n\r\n#if GRMODE == EGAGR\r\n\tRF_PlaceSprite (&ob->sprite\r\n\t\t,ob->x+4*PIXGLOBAL\r\n\t\t,ob->y+4*PIXGLOBAL\r\n\t\t,SCOREBOXSPR\r\n\t\t,spritedraw\r\n\t\t,PRIORITIES-1);\r\n#endif\r\n#if GRMODE == CGAGR\r\n\tRF_PlaceSprite (&ob->sprite\r\n\t\t,ob->x+8*PIXGLOBAL\r\n\t\t,ob->y+8*PIXGLOBAL\r\n\t\t,SCOREBOXSPR\r\n\t\t,spritedraw\r\n\t\t,PRIORITIES-1);\r\n#endif\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\tFLOWER POWER ROUTINES\r\n\r\ntemp1 = 8, same as power bonus\r\ntemp2 = initial direction\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tPowerCount\t\t\t(objtype *ob);\r\nvoid\tPowerContact \t\t(objtype *ob, objtype *hit);\r\nvoid\tPowerReact\t\t\t(objtype *ob);\r\n\r\nextern\tstatetype s_flowerpower1;\r\nextern\tstatetype s_flowerpower2;\r\n\r\nextern\tstatetype s_boobusbomb1;\r\nextern\tstatetype s_boobusbomb2;\r\n\r\nextern\tstatetype s_bombexplode;\r\nextern\tstatetype s_bombexplode2;\r\nextern\tstatetype s_bombexplode3;\r\nextern\tstatetype s_bombexplode4;\r\nextern\tstatetype s_bombexplode5;\r\nextern\tstatetype s_bombexplode6;\r\n\r\nextern\tstatetype s_powerblink1;\r\nextern\tstatetype s_powerblink2;\r\n\r\nstatetype s_flowerpower1\t= {FLOWERPOWER1SPR,FLOWERPOWER1SPR,stepthink,false,\r\n\tfalse,10, 0,0, ProjectileThink, PowerContact, PowerReact, &s_flowerpower2};\r\nstatetype s_flowerpower2\t= {FLOWERPOWER2SPR,FLOWERPOWER2SPR,stepthink,false,\r\n\tfalse,10, 0,0, ProjectileThink, PowerContact, PowerReact, &s_flowerpower1};\r\n\r\nstatetype s_boobusbomb1\t= {BOOBUSBOMB1SPR,BOOBUSBOMB1SPR,stepthink,false,\r\n\tfalse,5, 0,0, ProjectileThink, PowerContact, PowerReact, &s_boobusbomb2};\r\nstatetype s_boobusbomb2\t= {BOOBUSBOMB3SPR,BOOBUSBOMB3SPR,stepthink,false,\r\n\tfalse,5, 0,0, ProjectileThink, PowerContact, PowerReact, &s_boobusbomb1};\r\n\r\nstatetype s_bombexplode\t= {BOOBUSBOOM1SPR,BOOBUSBOOM1SPR,step,false,\r\n\tfalse,5, 0,0, NULL, NULL, DrawReact, &s_bombexplode2};\r\nstatetype s_bombexplode2= {BOOBUSBOOM2SPR,BOOBUSBOOM2SPR,step,false,\r\n\tfalse,5, 0,0, NULL, NULL, DrawReact, &s_bombexplode3};\r\nstatetype s_bombexplode3= {BOOBUSBOOM1SPR,BOOBUSBOOM1SPR,step,false,\r\n\tfalse,5, 0,0, NULL, NULL, DrawReact, &s_bombexplode4};\r\nstatetype s_bombexplode4= {BOOBUSBOOM2SPR,BOOBUSBOOM2SPR,step,false,\r\n\tfalse,5, 0,0, NULL, NULL, DrawReact, &s_bombexplode5};\r\nstatetype s_bombexplode5= {BOOBUSBOOM1SPR,BOOBUSBOOM1SPR,step,false,\r\n\tfalse,5, 0,0, NULL, NULL, DrawReact, &s_bombexplode6};\r\nstatetype s_bombexplode6= {BOOBUSBOOM2SPR,BOOBUSBOOM2SPR,step,false,\r\n\tfalse,5, 0,0, NULL, NULL, DrawReact, NULL};\r\n\r\nstatetype s_powerblink1\t= {FLOWERPOWER1SPR,FLOWERPOWER1SPR,step,false,\r\n\tfalse,5, 0,0, PowerCount, NULL, DrawReact, &s_powerblink2};\r\nstatetype s_powerblink2\t= {-1,-1,step,false,\r\n\tfalse,5, 0,0, PowerCount, NULL, DrawReact, &s_powerblink1};\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= ThrowPower\r\n=\r\n===============\r\n*/\r\n\r\nvoid ThrowPower (unsigned x, unsigned y, int dir)\r\n{\r\n\tstatetype *startstate;\r\n\r\n\tif (mapon == 15)\r\n\t{\r\n\t\tif (!gamestate.boobusbombs)\r\n\t\t{\r\n\t\t\tSD_PlaySound (NOWAYSND);\r\n\t\t\treturn;\t\t\t\t\t\t// no bombs to throw\r\n\t\t}\r\n\t\tSD_PlaySound (THROWBOMBSND);\r\n\t\tgamestate.bombsthislevel--;\r\n\t\tgamestate.boobusbombs--;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tif (!gamestate.flowerpowers)\r\n\t\t{\r\n\t\t\tSD_PlaySound (NOWAYSND);\r\n\t\t\treturn;\t\t\t\t\t\t// no flower power to throw\r\n\t\t}\r\n\t\tSD_PlaySound (THROWSND);\r\n\t\tgamestate.flowerpowers--;\r\n\t}\r\n\r\n\r\n\r\n\tGetNewObj (true);\r\n\tnew->obclass = powerobj;\r\n\tnew->temp2 = dir;\r\n\tnew->x = x;\r\n\tnew->y = y;\r\n\tnew->tileleft = new->tileright = x>>G_T_SHIFT;\r\n\tnew->tiletop = new->tilebottom = y>>G_T_SHIFT;\r\n\tnew->ydir = -1;\r\n\r\n\tswitch (dir)\r\n\t{\r\n\tcase dir_North:\r\n\t\tnew->xspeed = 0;\r\n\t\tnew->yspeed = SPDPOWERUP;\r\n\t\tbreak;\r\n\tcase dir_East:\r\n\t\tnew->xspeed = SPDPOWER;\r\n\t\tnew->yspeed = SPDPOWERY;\r\n\t\tbreak;\r\n\tcase dir_South:\r\n\t\tnew->xspeed = 0;\r\n\t\tnew->yspeed = SPDPOWER;\r\n\t\tbreak;\r\n\tcase dir_West:\r\n\t\tnew->xspeed = -SPDPOWER;\r\n\t\tnew->yspeed = SPDPOWERY;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tQuit (\"ThrowPower: Bad dir!\");\r\n\t}\r\n\r\n\tif (mapon != 15)\r\n\t{\r\n\t\tnew->temp1 = 8;  \t\t\t\t// flower power bonus\r\n\t\tstartstate = &s_flowerpower1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tnew->temp1 = 10;  \t\t\t\t// boobus bomb bonus\r\n\t\tstartstate = &s_boobusbomb1;\r\n\t}\r\n\tnew->active = removable;\r\n\r\n#if 0\r\n\tnew->x -= 5*new->xspeed;\t\t// make sure they hit nearby walls\r\n\tnew->y -= 5*new->yspeed;\r\n#endif\r\n\tNewState (new,startstate);\r\n#if 0\r\n\tnew->xmove = 5*new->xspeed;\r\n\tnew->ymove = 5*new->yspeed;\r\n\tClipToWalls (new);\r\n#endif\r\n}\r\n\r\n/*\r\n============================\r\n=\r\n= PowerCount\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tPowerCount (objtype *ob)\r\n{\r\n\tob->temp2+=tics;\r\n\r\n\tob->shapenum = 0;\r\n\r\n\tif (ob->temp2 > POWERCOUNT)\r\n\t\tRemoveObj(ob);\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= CalcSingleGravity\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tCalcSingleGravity (void)\r\n{\r\n\tunsigned\tspeed;\r\n\tlong\ti;\r\n//\r\n// only accelerate on odd tics, because of limited precision\r\n//\r\n\tspeed = 0;\r\n\tsinglegravity = 0;\r\n\tfor (i=lasttimecount-tics;i<lasttimecount;i++)\r\n\t{\r\n\t\tif (i&1)\r\n\t\t{\r\n\t\t\tspeed+=ACCGRAVITY;\r\n\t\t\tif (speed>SPDMAXY)\r\n\t\t\t  speed=SPDMAXY;\r\n\t\t}\r\n\t\tsinglegravity+=speed;\r\n\t}\r\n\r\n\tsinglegravity/=2;\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= PowerContact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tPowerContact (objtype *ob, objtype *hit)\r\n{\r\n\tunsigned\tx,y,yspot,xspot;\r\n\r\n\tswitch (hit->obclass)\r\n\t{\r\n\tcase\tbroccoobj:\r\n\tcase\ttomatobj:\r\n\tcase\tcarrotobj:\r\n\tcase\tceleryobj:\r\n\tcase\tasparobj:\r\n\tcase\ttaterobj:\r\n\tcase\tfrenchyobj:\r\n\tcase\tsquashobj:\r\n\tcase\tapelobj:\r\n\tcase\tpeapodobj:\r\n\tcase\tpeabrainobj:\r\n\t\tChangeToFlower (hit);\r\n\t\tRemoveObj (ob);\r\n\t\tbreak;\r\n\tcase\tboobusobj:\r\n\t\tif (!--hit->temp4)\r\n\t\t{\r\n\t\t// killed boobus\r\n\t\t\tGivePoints (50000);\r\n\t\t\tGivePoints (50000);\r\n\t\t\thit->obclass = inertobj;\r\n\t\t\tChangeState (hit,&s_boobusdie);\r\n\t\t\thit->temp1 = 0;\t\t// death count\r\n\t\t}\r\n\t\tSD_PlaySound (BOMBBOOMSND);\r\n\t\tChangeState (ob,&s_bombexplode);\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= PowerReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tPowerReact (objtype *ob)\r\n{\r\n\tunsigned wall,absx,absy,angle,newangle;\r\n\tunsigned long speed;\r\n\r\n\tPLACESPRITE;\r\n\tif (ob->hiteast || ob->hitwest)\r\n\t{\r\n\t\tob->xspeed= -ob->xspeed/2;\r\n\t\tob->obclass = bonusobj;\r\n\t}\r\n\r\n\tif (ob->hitsouth)\r\n\t{\r\n\t\tif ( ob->hitsouth == 17)\t// go through pole holes\r\n\t\t{\r\n\t\t\tif (ob->temp2 != dir_North)\r\n\t\t\t\tob->obclass = bonusobj;\r\n\t\t\tob->top-=32;\r\n\t\t\tob->y-=32;\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->x = ob->tilemidx*TILEGLOBAL + 4*PIXGLOBAL;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tob->yspeed= -ob->yspeed/2;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\twall = ob->hitnorth;\r\n\tif ( wall == 17)\t// go through pole holes\r\n\t{\r\n\t\tif (ob->temp2 != dir_South)\r\n\t\t\tob->obclass = bonusobj;\r\n\t\tob->bottom+=32;\r\n\t\tob->y+=32;\r\n\t\tob->xspeed = 0;\r\n\t\tob->x = ob->tilemidx*TILEGLOBAL + 4*PIXGLOBAL;\r\n\t}\r\n\telse if (wall)\r\n\t{\r\n\t\tob->obclass = bonusobj;\r\n\t\tif (ob->yspeed < 0)\r\n\t\t\tob->yspeed = 0;\r\n\r\n\t\tabsx = abs(ob->xspeed);\r\n\t\tabsy = ob->yspeed;\r\n\t\tif (absx>absy)\r\n\t\t{\r\n\t\t\tif (absx>absy*2)\t// 22 degrees\r\n\t\t\t{\r\n\t\t\t\tangle = 0;\r\n\t\t\t\tspeed = absx*286;\t// x*sqrt(5)/2\r\n\t\t\t}\r\n\t\t\telse\t\t\t\t// 45 degrees\r\n\t\t\t{\r\n\t\t\t\tangle = 1;\r\n\t\t\t\tspeed = absx*362;\t// x*sqrt(2)\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (absy>absx*2)\t// 90 degrees\r\n\t\t\t{\r\n\t\t\t\tangle = 3;\r\n\t\t\t\tspeed = absy*256;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tangle = 2;\t\t// 67 degrees\r\n\t\t\t\tspeed = absy*286;\t// y*sqrt(5)/2\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ob->xspeed > 0)\r\n\t\t\tangle = 7-angle;\r\n\r\n\t\tspeed >>= 1;\r\n\t\tnewangle = bounceangle[ob->hitnorth][angle];\r\n\t\tswitch (newangle)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tob->xspeed = speed / 286;\r\n\t\t\tob->yspeed = -ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tob->xspeed = speed / 362;\r\n\t\t\tob->yspeed = -ob->xspeed;\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tob->yspeed = -(speed / 286);\r\n\t\t\tob->xspeed = -ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\r\n\t\tcase 4:\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->yspeed = -(speed / 256);\r\n\t\t\tbreak;\r\n\t\tcase 5:\r\n\t\t\tob->yspeed = -(speed / 286);\r\n\t\t\tob->xspeed = ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tob->xspeed = ob->yspeed = -(speed / 362);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tob->xspeed = -(speed / 286);\r\n\t\t\tob->yspeed = ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 8:\r\n\t\t\tob->xspeed = -(speed / 286);\r\n\t\t\tob->yspeed = -ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 9:\r\n\t\t\tob->xspeed = -(speed / 362);\r\n\t\t\tob->yspeed = -ob->xspeed;\r\n\t\t\tbreak;\r\n\t\tcase 10:\r\n\t\t\tob->yspeed = speed / 286;\r\n\t\t\tob->xspeed = -ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 11:\r\n\r\n\t\tcase 12:\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->yspeed = -(speed / 256);\r\n\t\t\tbreak;\r\n\t\tcase 13:\r\n\t\t\tob->yspeed = speed / 286;\r\n\t\t\tob->xspeed = ob->yspeed / 2;\r\n\t\t\tbreak;\r\n\t\tcase 14:\r\n\t\t\tob->xspeed = speed / 362;\r\n\t\t\tob->yspeed = speed / 362;\r\n\t\t\tbreak;\r\n\t\tcase 15:\r\n\t\t\tob->xspeed = speed / 286;\r\n\t\t\tob->yspeed = ob->xspeed / 2;\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (speed < 256*16)\r\n\t\t{\r\n\t\t\tif (mapon == 15)\r\n\t\t\t{\r\n\t\t\t\tob->ydir = -1;\t\t\t// bonus stuff flies up when touched\r\n\t\t\t\tob->temp2 = ob->shapenum = BOOBUSBOMB1SPR;\r\n\t\t\t\tob->temp3 = ob->temp2 + 2;\r\n\t\t\t\tob->needtoclip = 0;\r\n\t\t\t\tChangeState (ob,&s_bonus);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tChangeState (ob,&s_powerblink1);\r\n\t\t\t\tob->needtoclip = 0;\r\n\t\t\t\tob->temp2 = 0;\t\t// blink time\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\t   MINI KEEN\r\n\r\nplayer->temp1 = dir\r\nplayer->temp2 = animation stage\r\n\r\n#define WORLDKEENSLEEP1SPR\t\t238\r\n#define WORLDKEENSLEEP2SPR\t\t239\r\n#define WORLDKEENWAVE1SPR\t\t240\r\n#define WORLDKEENWAVE2SPR\t\t241\r\n=============================================================================\r\n*/\r\n\r\nvoid\tSpawnWorldKeen (int tilex, int tiley);\r\nvoid\tKeenWorldThink\t\t(objtype *ob);\r\nvoid\tKeenWorldWalk\t\t(objtype *ob);\r\n\r\nextern\tstatetype s_worldkeen;\r\n\r\nextern\tstatetype s_worldkeenwave1;\r\nextern\tstatetype s_worldkeenwave2;\r\nextern\tstatetype s_worldkeenwave3;\r\nextern\tstatetype s_worldkeenwave4;\r\nextern\tstatetype s_worldkeenwave5;\r\n\r\nextern\tstatetype s_worldkeenwait;\r\n\r\nextern\tstatetype s_worldkeensleep1;\r\nextern\tstatetype s_worldkeensleep2;\r\n\r\nextern\tstatetype s_worldwalk;\r\n\r\n#pragma warn -sus\r\n\r\nstatetype s_worldkeen\t= {NULL,NULL,stepthink,false,\r\n\tfalse,360, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeenwave1};\r\n\r\nstatetype s_worldkeenwave1= {WORLDKEENWAVE1SPR,WORLDKEENWAVE1SPR,stepthink,false,\r\n\tfalse,20, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeenwave2};\r\nstatetype s_worldkeenwave2= {WORLDKEENWAVE2SPR,WORLDKEENWAVE2SPR,stepthink,false,\r\n\tfalse,20, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeenwave3};\r\nstatetype s_worldkeenwave3= {WORLDKEENWAVE1SPR,WORLDKEENWAVE1SPR,stepthink,false,\r\n\tfalse,20, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeenwave4};\r\nstatetype s_worldkeenwave4= {WORLDKEENWAVE2SPR,WORLDKEENWAVE2SPR,stepthink,false,\r\n\tfalse,20, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeenwave5};\r\nstatetype s_worldkeenwave5= {WORLDKEENWAVE1SPR,WORLDKEENWAVE1SPR,stepthink,false,\r\n\tfalse,20, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeenwait};\r\n\r\nstatetype s_worldkeenwait\t= {WORLDKEEND3SPR,WORLDKEEND3SPR,stepthink,false,\r\n\tfalse,400, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeensleep1};\r\n\r\nstatetype s_worldkeensleep1\t= {WORLDKEENSLEEP1SPR,WORLDKEENSLEEP1SPR,stepthink,false,\r\n\tfalse,30, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeensleep2};\r\nstatetype s_worldkeensleep2\t= {WORLDKEENSLEEP2SPR,WORLDKEENSLEEP2SPR,stepthink,false,\r\n\tfalse,90, 0,0, KeenWorldThink, NULL, DrawReact, &s_worldkeensleep2};\r\n\r\nstatetype s_worldwalk\t= {NULL,NULL,slide,false,\r\n\tfalse,4, 16,16, KeenWorldWalk, NULL, DrawReact, &s_worldwalk};\r\n\r\n#pragma warn +sus\r\n\r\n/*\r\n======================\r\n=\r\n= SpawnWorldKeen\r\n=\r\n======================\r\n*/\r\n\r\nvoid\tSpawnWorldKeen (int tilex, int tiley)\r\n{\r\n\tplayer->obclass = keenobj;\r\n\tif (!gamestate.worldx)\r\n\t{\r\n\t\tplayer->x = tilex<<G_T_SHIFT;\r\n\t\tplayer->y = tiley<<G_T_SHIFT;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tplayer->x = gamestate.worldx;\r\n\t\tplayer->y = gamestate.worldy;\r\n\t}\r\n\r\n\tplayer->active = yes;\r\n\tplayer->needtoclip = true;\r\n\tplayer->xdir = 0;\r\n\tplayer->ydir = 0;\r\n\tplayer->temp1 = dir_West;\r\n\tplayer->temp2 = 3;\r\n\tplayer->shapenum = 3+WORLDKEENL1SPR-1;\t\t\t\t// feet together\r\n\tNewState (player,&s_worldkeen);\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= CheckEnterLevel\r\n=\r\n======================\r\n*/\r\n\r\nvoid\tCheckEnterLevel (objtype *ob)\r\n{\r\n\tint\tx,y,tile;\r\n\r\n\tfor (y=ob->tiletop;y<=ob->tilebottom;y++)\r\n\t\tfor (x=ob->tileleft;x<=ob->tileright;x++)\r\n\t\t{\r\n\t\t\ttile = *((unsigned _seg *)mapsegs[2]+mapbwidthtable[y]/2+x);\r\n\t\t\tif (tile >= 3 && tile <=18)\r\n\t\t\t{\r\n\t\t\t//\r\n\t\t\t// enter level!\r\n\t\t\t//\r\n\t\t\t\tif (tile == 17)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (gamestate.boobusbombs < 12)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tVW_FixRefreshBuffer ();\r\n\t\t\t\t\t\tUS_CenterWindow (26,6);\r\n\t\t\t\t\t\tPrintY+= 8;\r\n\t\t\t\t\t\tUS_CPrint (\"You can't possibly\\n\"\r\n\t\t\t\t\t\t\t\t   \"defeat King Boobus Tuber\\n\"\r\n\t\t\t\t\t\t\t\t   \"with less than 12 bombs!\");\r\n\t\t\t\t\t\tVW_UpdateScreen ();\r\n\t\t\t\t\t\tIN_Ack ();\r\n\t\t\t\t\t\tRF_ForceRefresh ();\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tgamestate.worldx = ob->x;\r\n\t\t\t\tgamestate.worldy = ob->y;\r\n\t\t\t\tgamestate.mapon = tile-2;\r\n\t\t\t\tplaystate = levelcomplete;\r\n\t\t\t\tSD_PlaySound (ENTERLEVELSND);\r\n\t\t\t}\r\n\t\t}\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= KeenWorldThink\r\n=\r\n======================\r\n*/\r\n\r\nvoid\tKeenWorldThink (objtype *ob)\r\n{\r\n\tif (c.dir!=dir_None)\r\n\t{\r\n\t\tob->state = &s_worldwalk;\r\n\t\tob->temp2 = 0;\r\n\t\tKeenWorldWalk (ob);\r\n\t}\r\n\r\n\tif (c.button0 || c.button1)\r\n\t\tCheckEnterLevel(ob);\r\n}\r\n\r\n\r\n/*\r\n======================\r\n=\r\n= KeenWorldWalk\r\n=\r\n======================\r\n*/\r\n\r\nint worldshapes[8] = {WORLDKEENU1SPR-1,WORLDKEENUR1SPR-1,WORLDKEENR1SPR-1,\r\n\tWORLDKEENDR1SPR-1,WORLDKEEND1SPR-1,WORLDKEENDL1SPR-1,WORLDKEENL1SPR-1,\r\n\tWORLDKEENUL1SPR-1};\r\n\r\nint worldanims[4] ={2,3,1,3};\r\n\r\nvoid\tKeenWorldWalk (objtype *ob)\r\n{\r\n\tob->xdir = c.xaxis;\r\n\tob->ydir = c.yaxis;\r\n\r\n\tif (++ob->temp2==4)\r\n\t\tob->temp2 = 0;\r\n\r\n\tif (c.button0 || c.button1)\r\n\t\tCheckEnterLevel(ob);\r\n\r\n\tif (c.dir == dir_None)\r\n\t{\r\n\t\tob->state = &s_worldkeen;\r\n\t\tob->shapenum = worldshapes[ob->temp1]+3;\r\n\t\treturn;\r\n\t}\r\n\r\n\tob->temp1 = c.dir;\r\n\tob->shapenum = worldshapes[ob->temp1]+worldanims[ob->temp2];\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\t\tKEEN\r\n\r\nplayer->temp1 = pausetime / pointer to zees when sleeping\r\nplayer->temp2 = pausecount / stagecount\r\nplayer->temp3 =\r\nplayer->temp4 = pole x location\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tKeenStandThink\t\t(objtype *ob);\r\nvoid\tKeenPauseThink\t\t(objtype *ob);\r\nvoid\tKeenGoSleepThink\t(objtype *ob);\r\nvoid\tKeenSleepThink\t\t(objtype *ob);\r\nvoid\tKeenDieThink\t\t(objtype *ob);\r\nvoid\tKeenDuckThink\t\t(objtype *ob);\r\nvoid\tKeenDropDownThink\t(objtype *ob);\r\nvoid\tKeenWalkThink\t\t(objtype *ob);\r\nvoid\tKeenAirThink\t\t(objtype *ob);\r\nvoid\tKeenPoleThink\t\t(objtype *ob);\r\nvoid\tKeenClimbThink\t\t(objtype *ob);\r\nvoid\tKeenDropThink\t\t(objtype *ob);\r\nvoid\tKeenDive\t\t\t(objtype *ob);\r\nvoid\tKeenThrow\t\t\t(objtype *ob);\r\n\r\nvoid\tKeenContact \t\t(objtype *ob, objtype *hit);\r\nvoid\tKeenSimpleReact\t\t(objtype *ob);\r\nvoid\tKeenStandReact\t\t(objtype *ob);\r\nvoid\tKeenWalkReact\t\t(objtype *ob);\r\nvoid\tKeenPoleReact\t\t(objtype *ob);\r\nvoid\tKeenAirReact\t\t(objtype *ob);\r\nvoid\tKeenDiveReact\t\t(objtype *ob);\r\nvoid\tKeenSlideReact\t\t(objtype *ob);\r\n\r\n//-------------------\r\n\r\nextern\tstatetype s_keenzee1;\r\nextern\tstatetype s_keenzee2;\r\nextern\tstatetype s_keenzee3;\r\nextern\tstatetype s_keenzee4;\r\nextern\tstatetype s_keenzee5;\r\n\r\n//-------------------\r\n\r\nextern\tstatetype\ts_keenstand;\r\nextern\tstatetype s_keenpauselook;\r\nextern\tstatetype s_keenyawn1;\r\nextern\tstatetype s_keenyawn2;\r\nextern\tstatetype s_keenyawn3;\r\nextern\tstatetype s_keenyawn4;\r\n\r\nextern\tstatetype s_keenwait1;\r\nextern\tstatetype s_keenwait2;\r\nextern\tstatetype s_keenwait3;\r\nextern\tstatetype s_keenwait4;\r\nextern\tstatetype s_keenwait5;\r\nextern\tstatetype s_keenwait6;\r\n\r\nextern\tstatetype s_keenmoon1;\r\nextern\tstatetype s_keenmoon2;\r\nextern\tstatetype s_keenmoon3;\r\n\r\nextern\tstatetype s_keengosleep1;\r\nextern\tstatetype s_keengosleep2;\r\nextern\tstatetype s_keensleep1;\r\nextern\tstatetype s_keensleep2;\r\n\r\nextern\tstatetype s_keendie1;\r\nextern\tstatetype s_keendie2;\r\nextern\tstatetype s_keendie3;\r\nextern\tstatetype s_keendie4;\r\n\r\nextern\tstatetype\ts_keenlookup;\r\nextern\tstatetype\ts_keenduck;\r\nextern\tstatetype\ts_keendrop;\r\n\r\n//-------------------\r\n\r\nextern\tstatetype s_keenreach;\r\n\r\nextern\tstatetype s_keenpole;\r\n\r\nextern\tstatetype s_keenclimb1;\r\nextern\tstatetype s_keenclimb2;\r\nextern\tstatetype s_keenclimb3;\r\n\r\nextern\tstatetype s_keenslide1;\r\nextern\tstatetype s_keenslide2;\r\nextern\tstatetype s_keenslide3;\r\nextern\tstatetype s_keenslide4;\r\n\r\nextern\tstatetype s_keenpolethrow1;\r\nextern\tstatetype s_keenpolethrow2;\r\nextern\tstatetype s_keenpolethrow3;\r\n\r\nextern\tstatetype s_keenpolethrowup1;\r\nextern\tstatetype s_keenpolethrowup2;\r\nextern\tstatetype s_keenpolethrowup3;\r\n\r\nextern\tstatetype s_keenpolethrowdown1;\r\nextern\tstatetype s_keenpolethrowdown2;\r\nextern\tstatetype s_keenpolethrowdown3;\r\n\r\n//-------------------\r\n\r\nextern\tstatetype\ts_keenwalk1;\r\nextern\tstatetype\ts_keenwalk2;\r\nextern\tstatetype\ts_keenwalk3;\r\nextern\tstatetype\ts_keenwalk4;\r\n\r\nextern\tstatetype\ts_keenthrow1;\r\nextern\tstatetype\ts_keenthrow2;\r\nextern\tstatetype\ts_keenthrow3;\r\nextern\tstatetype\ts_keenthrow4;\r\n\r\nextern\tstatetype\ts_keenthrowup1;\r\nextern\tstatetype\ts_keenthrowup2;\r\nextern\tstatetype\ts_keenthrowup3;\r\n\r\nextern\tstatetype\ts_keendive1;\r\nextern\tstatetype\ts_keendive2;\r\nextern\tstatetype\ts_keendive3;\r\n\r\n//-------------------\r\n\r\nextern\tstatetype s_keenjumpup1;\r\nextern\tstatetype s_keenjumpup2;\r\nextern\tstatetype s_keenjumpup3;\r\n\r\nextern\tstatetype s_keenjump1;\r\nextern\tstatetype s_keenjump2;\r\nextern\tstatetype s_keenjump3;\r\n\r\nextern\tstatetype s_keenairthrow1;\r\nextern\tstatetype s_keenairthrow2;\r\nextern\tstatetype s_keenairthrow3;\r\n\r\nextern\tstatetype s_keenairthrowup1;\r\nextern\tstatetype s_keenairthrowup2;\r\nextern\tstatetype s_keenairthrowup3;\r\n\r\nextern\tstatetype s_keenairthrowdown1;\r\nextern\tstatetype s_keenairthrowdown2;\r\nextern\tstatetype s_keenairthrowdown3;\r\n\r\n#pragma warn -sus\r\n\r\n//-------------------\r\n\r\nstatetype s_keenzee1\t= {KEENZEES1SPR,KEENZEES1SPR,step,false,\r\n\tfalse,30, 0,0, NULL, NULL, DrawReact, &s_keenzee2};\r\nstatetype s_keenzee2\t= {KEENZEES2SPR,KEENZEES2SPR,step,false,\r\n\tfalse,30, 0,0, NULL, NULL, DrawReact, &s_keenzee3};\r\nstatetype s_keenzee3\t= {KEENZEES3SPR,KEENZEES3SPR,step,false,\r\n\tfalse,30, 0,0, NULL, NULL, DrawReact, &s_keenzee1};\r\n\r\n//-------------------\r\n\r\nstatetype s_keenstand\t= {KEENSTANDLSPR,KEENSTANDRSPR,stepthink,false,\r\n\ttrue,4, 0,16, KeenPauseThink, KeenContact, KeenStandReact, &s_keenstand};\r\nstatetype s_keenpauselook= {KEENLOOKULSPR,KEENLOOKURSPR,stepthink,false,\r\n\ttrue,60, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenstand};\r\nstatetype s_keenyawn1\t= {KEENYAWN1SPR,KEENYAWN1SPR,stepthink,false,\r\n\ttrue,40, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenyawn2};\r\nstatetype s_keenyawn2\t= {KEENYAWN2SPR,KEENYAWN2SPR,stepthink,false,\r\n\ttrue,40, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenyawn3};\r\nstatetype s_keenyawn3\t= {KEENYAWN3SPR,KEENYAWN3SPR,stepthink,false,\r\n\ttrue,40, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenyawn4};\r\nstatetype s_keenyawn4\t= {KEENYAWN4SPR,KEENYAWN4SPR,stepthink,false,\r\n\ttrue,40, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenstand};\r\n\r\nstatetype s_keenwait1\t= {KEENWAITL2SPR,KEENWAITR2SPR,stepthink,false,\r\n\ttrue,90, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenwait2};\r\nstatetype s_keenwait2\t= {KEENWAITL1SPR,KEENWAITR1SPR,stepthink,false,\r\n\ttrue,10, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenwait3};\r\nstatetype s_keenwait3\t= {KEENWAITL2SPR,KEENWAITR2SPR,stepthink,false,\r\n\ttrue,90, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenwait4};\r\nstatetype s_keenwait4\t= {KEENWAITL1SPR,KEENWAITR1SPR,stepthink,false,\r\n\ttrue,10, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenwait5};\r\nstatetype s_keenwait5\t= {KEENWAITL2SPR,KEENWAITR2SPR,stepthink,false,\r\n\ttrue,90, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenwait6};\r\nstatetype s_keenwait6\t= {KEENWAITL3SPR,KEENWAITR3SPR,stepthink,false,\r\n\ttrue,70, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keenstand};\r\n\r\nstatetype s_keengosleep1= {KEENSLEEP1SPR,KEENSLEEP1SPR,stepthink,false,\r\n\ttrue,20, 0,0, KeenPauseThink, KeenContact, KeenStandReact, &s_keengosleep2};\r\nstatetype s_keengosleep2= {KEENSLEEP2SPR,KEENSLEEP2SPR,step,false,\r\n\ttrue,20, 0,0, KeenGoSleepThink, KeenContact, KeenStandReact, &s_keensleep1};\r\nstatetype s_keensleep1= {KEENSLEEP3SPR,KEENSLEEP3SPR,stepthink,false,\r\n\ttrue,120, 0,0, KeenSleepThink, KeenContact, KeenStandReact, &s_keensleep2};\r\nstatetype s_keensleep2= {KEENSLEEP4SPR,KEENSLEEP4SPR,stepthink,false,\r\n\ttrue,120, 0,0, KeenSleepThink, KeenContact, KeenStandReact, &s_keensleep1};\r\n\r\nstatetype s_keengetup\t= {KEENGETUPLSPR,KEENGETUPRSPR,step,false,\r\n\ttrue,15, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenstand};\r\n\r\nstatetype s_keendie1\t\t= {KEENDREAM1SPR,KEENDREAM1SPR,step,false,\r\n\tfalse,20, 0,0, NULL, NULL, KeenSimpleReact, &s_keendie2};\r\nstatetype s_keendie2\t\t= {KEENDREAM2SPR,KEENDREAM2SPR,step,false,\r\n\tfalse,20, 0,0, NULL, NULL, KeenSimpleReact, &s_keendie3};\r\nstatetype s_keendie3\t\t= {KEENDREAM3SPR,KEENDREAM3SPR,step,false,\r\n\tfalse,120, 0,0, KeenDieThink, NULL, KeenSimpleReact, &s_keendie3};\r\n\r\nstatetype s_keenlookup\t= {KEENLOOKULSPR,KEENLOOKURSPR,think,false,\r\n\ttrue,0, 0,0, KeenStandThink, KeenContact, KeenStandReact, &s_keenlookup};\r\n\r\nstatetype s_keenduck\t= {KEENDUCKLSPR,KEENDUCKRSPR,think,false,\r\n\ttrue,0, 0,0, KeenDuckThink, KeenContact, KeenStandReact, &s_keenduck};\r\n\r\nstatetype s_keendrop\t= {KEENDUCKLSPR,KEENDUCKRSPR,step,false,\r\n\tfalse,0, 0,0, KeenDropDownThink, KeenContact, KeenSimpleReact, &s_keenjumpup3};\r\n\r\n//-------------------\r\n\r\nstatetype s_keenpole\t= {KEENSHINNYL1SPR,KEENSHINNYR1SPR,think,false,\r\n\tfalse,0, 0,0, KeenPoleThink, KeenContact, KeenSimpleReact, &s_keenpole};\r\n\r\nstatetype s_keenclimb1\t= {KEENSHINNYL1SPR,KEENSHINNYR1SPR,slidethink,false,\r\n\tfalse,8, 0,8, KeenClimbThink, KeenContact, KeenSimpleReact, &s_keenclimb2};\r\nstatetype s_keenclimb2\t= {KEENSHINNYL2SPR,KEENSHINNYR2SPR,slidethink,false,\r\n\tfalse,8, 0,8, KeenClimbThink, KeenContact, KeenSimpleReact, &s_keenclimb3};\r\nstatetype s_keenclimb3\t= {KEENSHINNYL3SPR,KEENSHINNYR3SPR,slidethink,false,\r\n\tfalse,8, 0,8, KeenClimbThink, KeenContact, KeenSimpleReact, &s_keenclimb1};\r\n\r\nstatetype s_keenslide1\t= {KEENSLIDED1SPR,KEENSLIDED1SPR,slide,false,\r\n\tfalse,8, 0,24, KeenDropThink, KeenContact, KeenSimpleReact, &s_keenslide2};\r\nstatetype s_keenslide2\t= {KEENSLIDED2SPR,KEENSLIDED2SPR,slide,false,\r\n\tfalse,8, 0,24, KeenDropThink, KeenContact, KeenSimpleReact, &s_keenslide3};\r\nstatetype s_keenslide3\t= {KEENSLIDED3SPR,KEENSLIDED3SPR,slide,false,\r\n\tfalse,8, 0,24, KeenDropThink, KeenContact, KeenSimpleReact, &s_keenslide4};\r\nstatetype s_keenslide4\t= {KEENSLIDED4SPR,KEENSLIDED4SPR,slide,false,\r\n\tfalse,8, 0,24, KeenDropThink, KeenContact, KeenSimpleReact, &s_keenslide1};\r\n\r\nstatetype s_keenpolethrow1\t= {KEENPTHROWL1SPR,KEENPTHROWR1SPR,step,false,\r\n\tfalse,8, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenpolethrow2};\r\nstatetype s_keenpolethrow2\t= {KEENPTHROWL2SPR,KEENPTHROWR2SPR,step,true,\r\n\tfalse,1, 0,0, KeenThrow, KeenContact, KeenSimpleReact, &s_keenpolethrow3};\r\nstatetype s_keenpolethrow3\t= {KEENPTHROWL2SPR,KEENPTHROWR2SPR,step,false,\r\n\tfalse,10, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenpole};\r\n\r\nstatetype s_keenpolethrowup1 = {KEENPLTHROWU1SPR,KEENPRTHROWU1SPR,step,false,\r\n\tfalse,8, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenpolethrowup2};\r\nstatetype s_keenpolethrowup2 = {KEENPLTHROWU2SPR,KEENPRTHROWU2SPR,step,true,\r\n\tfalse,1, 0,0, KeenThrow, KeenContact, KeenSimpleReact, &s_keenpolethrowup3};\r\nstatetype s_keenpolethrowup3 = {KEENPLTHROWU2SPR,KEENPRTHROWU2SPR,step,false,\r\n\tfalse,10, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenpole};\r\n\r\nstatetype s_keenpolethrowdown1 = {KEENPLTHROWD1SPR,KEENPRTHROWD1SPR,step,false,\r\n\tfalse,8, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenpolethrowdown2};\r\nstatetype s_keenpolethrowdown2 = {KEENPLTHROWD2SPR,KEENPRTHROWD2SPR,step,true,\r\n\tfalse,1, 0,0, KeenThrow, KeenContact, KeenSimpleReact, &s_keenpolethrowdown3};\r\nstatetype s_keenpolethrowdown3 = {KEENPLTHROWD2SPR,KEENPRTHROWD2SPR,step,false,\r\n\tfalse,10, 0,0, NULL, KeenContact, KeenSimpleReact, &s_keenpole};\r\n\r\n\r\n//-------------------\r\n\r\nstatetype s_keenwalk1\t= {KEENRUNL1SPR,KEENRUNR1SPR,slidethink,true,\r\n\ttrue,6, 24,0, KeenWalkThink, KeenContact, KeenWalkReact, &s_keenwalk2};\r\nstatetype s_keenwalk2\t= {KEENRUNL2SPR,KEENRUNR2SPR,slidethink,true,\r\n\ttrue,6, 24,0, KeenWalkThink, KeenContact, KeenWalkReact, &s_keenwalk3};\r\nstatetype s_keenwalk3\t= {KEENRUNL3SPR,KEENRUNR3SPR,slidethink,true,\r\n\ttrue,6, 24,0, KeenWalkThink, KeenContact, KeenWalkReact, &s_keenwalk4};\r\nstatetype s_keenwalk4\t= {KEENRUNL4SPR,KEENRUNR4SPR,slidethink,true,\r\n\ttrue,6, 24,0, KeenWalkThink, KeenContact, KeenWalkReact, &s_keenwalk1};\r\n\r\nstatetype s_keenthrow1\t= {KEENTHROWL1SPR,KEENTHROWR1SPR,step,true,\r\n\ttrue,4, 0,0, NULL, KeenContact, KeenStandReact, &s_keenthrow2};\r\nstatetype s_keenthrow2\t= {KEENTHROWL2SPR,KEENTHROWR2SPR,step,false,\r\n\ttrue,4, 0,0, NULL, KeenContact, KeenStandReact, &s_keenthrow3};\r\nstatetype s_keenthrow3\t= {KEENTHROWL3SPR,KEENTHROWR3SPR,step,true,\r\n\ttrue,1, 0,0, KeenThrow, KeenContact, KeenStandReact, &s_keenthrow4};\r\nstatetype s_keenthrow4\t= {KEENTHROWL3SPR,KEENTHROWR3SPR,step,false,\r\n\ttrue,10, 0,0, NULL, KeenContact, KeenStandReact, &s_keenstand};\r\n\r\nstatetype s_keenthrowup1\t= {KEENTHROWU1SPR,KEENTHROWU1SPR,step,false,\r\n\ttrue,8, 0,0, NULL, KeenContact, KeenStandReact, &s_keenthrowup2};\r\nstatetype s_keenthrowup2\t= {KEENTHROWU2SPR,KEENTHROWU2SPR,step,true,\r\n\ttrue,1, 0,0, KeenThrow, KeenContact, KeenStandReact, &s_keenthrowup3};\r\nstatetype s_keenthrowup3\t= {KEENTHROWU2SPR,KEENTHROWU2SPR,step,false,\r\n\ttrue,10, 0,0, NULL, KeenContact, KeenStandReact, &s_keenstand};\r\n\r\n//-------------------\r\n\r\nstatetype s_keenjumpup1\t= {KEENJUMPUL1SPR,KEENJUMPUR1SPR,think,false,\r\n\tfalse,0, 0,0, KeenAirThink, KeenContact, KeenAirReact, &s_keenjumpup2};\r\nstatetype s_keenjumpup2\t= {KEENJUMPUL2SPR,KEENJUMPUR2SPR,think,false,\r\n\tfalse,0, 0,0, KeenAirThink, KeenContact, KeenAirReact, &s_keenjumpup3};\r\nstatetype s_keenjumpup3\t= {KEENJUMPUL1SPR,KEENJUMPUR1SPR,think,false,\r\n\tfalse,0, 0,0, KeenAirThink, KeenContact, KeenAirReact, &s_keenstand};\r\n\r\nstatetype s_keenjump1\t= {KEENJUMPL1SPR,KEENJUMPR1SPR,think,false,\r\n\tfalse,0, 0,0, KeenAirThink, KeenContact, KeenAirReact, &s_keenjump2};\r\nstatetype s_keenjump2\t= {KEENJUMPL2SPR,KEENJUMPR2SPR,think,false,\r\n\tfalse,0, 0,0, KeenAirThink, KeenContact, KeenAirReact, &s_keenjump3};\r\nstatetype s_keenjump3\t= {KEENJUMPL3SPR,KEENJUMPR3SPR,think,false,\r\n\tfalse,0, 0,0, KeenAirThink, KeenContact, KeenAirReact, &s_keenstand};\r\n\r\nstatetype s_keenairthrow1= {KEENJLTHROWL1SPR,KEENJRTHROWR1SPR,stepthink,false,\r\n\tfalse,8, 0,0, ProjectileThink, KeenContact, KeenAirReact, &s_keenairthrow2};\r\nstatetype s_keenairthrow2= {KEENJLTHROWL2SPR,KEENJRTHROWR2SPR,step,true,\r\n\tfalse,1, 0,0, KeenThrow, KeenContact, KeenAirReact, &s_keenairthrow3};\r\nstatetype s_keenairthrow3= {KEENJLTHROWL2SPR,KEENJRTHROWR2SPR,stepthink,false,\r\n\tfalse,10, 0,0, ProjectileThink, KeenContact, KeenAirReact, &s_keenjumpup3};\r\n\r\nstatetype s_keenairthrowup1= {KEENJLTHROWU1SPR,KEENJRTHROWU1SPR,stepthink,false,\r\n\tfalse,8, 0,0, ProjectileThink, KeenContact, KeenAirReact, &s_keenairthrowup2};\r\nstatetype s_keenairthrowup2= {KEENJLTHROWU2SPR,KEENJRTHROWU2SPR,step,true,\r\n\tfalse,1, 0,0, KeenThrow, KeenContact, KeenAirReact, &s_keenairthrowup3};\r\nstatetype s_keenairthrowup3= {KEENJLTHROWU2SPR,KEENJRTHROWU2SPR,stepthink,false,\r\n\tfalse,10, 0,0, ProjectileThink, KeenContact, KeenAirReact, &s_keenjumpup3};\r\n\r\nstatetype s_keenairthrowdown1= {KEENJLTHROWD1SPR,KEENJRTHROWD1SPR,stepthink,false,\r\n\tfalse,8, 0,0, ProjectileThink, KeenContact, KeenAirReact, &s_keenairthrowdown2};\r\nstatetype s_keenairthrowdown2= {KEENJLTHROWD2SPR,KEENJRTHROWD2SPR,step,true,\r\n\tfalse,1, 0,0, KeenThrow, KeenContact, KeenAirReact, &s_keenairthrowdown3};\r\nstatetype s_keenairthrowdown3= {KEENJLTHROWD2SPR,KEENJRTHROWD2SPR,stepthink,false,\r\n\tfalse,10, 0,0, ProjectileThink, KeenContact, KeenAirReact, &s_keenjumpup3};\r\n\r\n\r\n//===========================================================================\r\n\r\n#pragma warn +sus\r\n\r\n\r\n/*\r\n===============\r\n=\r\n= SpawnKeen\r\n=\r\n===============\r\n*/\r\n\r\nvoid SpawnKeen (int tilex, int tiley, int dir)\r\n{\r\n\tplayer->obclass = keenobj;\r\n\tplayer->active = yes;\r\n\tplayer->needtoclip = true;\r\n\tplayer->x = tilex<<G_T_SHIFT;\r\n\tplayer->y = (tiley<<G_T_SHIFT) - BLOCKSIZE*2;\r\n\r\n\tplayer->xdir = dir;\r\n\tplayer->ydir = 1;\r\n\tNewState (player,&s_keenstand);\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n======================\r\n=\r\n= CheckGrabPole\r\n=\r\n======================\r\n*/\r\n\r\nboolean\tCheckGrabPole (objtype *ob)\r\n{\r\n\tint\tx;\r\n\tunsigned far *map;\r\n\r\n//\r\n// kludgy bit to not let you grab a pole the instant you jump off it\r\n//\r\n\tif (TimeCount < leavepoletime)\r\n\t\tleavepoletime = 0;\r\n\telse if (TimeCount - leavepoletime < MINPOLEJUMPTICS)\r\n\t\treturn false;\r\n\r\n\tif (c.yaxis == -1)\r\n\t\tmap = (unsigned _seg *)mapsegs[1]+\r\n\t\t\tmapbwidthtable[(ob->top+6*PIXGLOBAL)/TILEGLOBAL]/2;\r\n\telse\r\n\t\tmap = (unsigned _seg *)mapsegs[1]+\r\n\t\t\tmapbwidthtable[ob->tilebottom]/2;\r\n\r\n\tx = (ob->left + (ob->right - ob->left)/2) >>G_T_SHIFT;\r\n\r\n\tmap += x;\r\n\r\n\tif ((tinf[INTILE+*map]&0x7f) == 1)\r\n\t{\r\n\t\tob->xmove = ((x<<G_T_SHIFT)-8*PIXGLOBAL) - ob->x;\r\n\t\tob->ymove = c.yaxis*32;\r\n\t\tob->temp4 = x;\t\t\t\t// for future reference\r\n\t\tob->needtoclip = false;\t\t// can climb through pole holes\r\n\t\tob->state = &s_keenpole;\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= KeenStandThink\r\n=\r\n============================\r\n*/\r\n\r\nvoid KeenStandThink (objtype *ob)\r\n{\r\n\tif (c.xaxis)\r\n\t{\r\n\t// started walking\r\n\t\tob->xdir = c.xaxis;\r\n\t\tob->state = &s_keenwalk1;\r\n\t\tob->xmove = ob->xdir*s_keenwalk1.xmove*tics;\r\n\t\tKeenWalkThink(ob);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c.button0 && !button0held)\r\n\t{\r\n\t// jump straight up\r\n\t\tSD_PlaySound (JUMPSND);\r\n\t\tob->xspeed = 0;\r\n\t\tob->yspeed = -SPDJUMP;\r\n\t\tob->xmove = 0;\r\n\t\tob->ymove = 0;\t\t// ob->yspeed*tics;\t\t\t// DEBUG\r\n\t\tjumptime = JUMPTIME;\t// -tics;\r\n\t\tob->state = &s_keenjumpup1;\r\n\t\tbutton0held = true;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c.button1 && !button1held)\r\n\t{\r\n\t// throw current xdir\r\n\t\tif (c.yaxis == -1)\r\n\t\t\tob->state = &s_keenthrowup1;\r\n\t\telse\r\n\t\t\tob->state = &s_keenthrow1;\r\n\t\tbutton1held = true;\r\n\t\treturn;\r\n\t}\r\n\r\n\tswitch (c.yaxis)\r\n\t{\r\n\tcase -1:\r\n\t\tif (!CheckGrabPole(ob))\t\t\t// try to go up/down pole first\r\n\t\t\tob->state = &s_keenlookup;\r\n\t\treturn;\r\n\tcase 0:\r\n\t\tob->state = &s_keenstand;\r\n\t\treturn;\r\n\tcase 1:\r\n\t\tif (!CheckGrabPole(ob))\t\t\t// try to go up/down pole first\r\n\t\t\tob->state = &s_keenduck;\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenPauseThink\r\n=\r\n= Do special animations in time\r\n=\r\n=======================\r\n*/\r\n\r\nvoid KeenPauseThink (objtype *ob)\r\n{\r\n\tif (c.dir != dir_None || c.button0 || c.button1)\r\n\t{\r\n\t\tob->temp1 = ob->temp2 = 0;\t\t\t// not paused any more\r\n\t\tob->state = &s_keenstand;\r\n\t\tKeenStandThink(ob);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif ((ob->hitnorth & ~7) != 24)\t// if it is 0 now, keen is standing on a sprite\r\n\t\tob->temp1 += tics;\r\n\r\n\tswitch (ob->temp2)\r\n\t{\r\n\tcase 0:\r\n\t\tif (ob->temp1 > 200)\r\n\t\t{\r\n\t\t\tob->temp2++;\r\n\t\t\tob->state = &s_keenpauselook;\r\n\t\t\tob->temp1 = 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tif (ob->temp1 > 300)\r\n\t\t{\r\n\t\t\tob->temp2++;\r\n\t\t\tob->state = &s_keenwait1;\r\n\t\t\tob->temp1 = 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tif (ob->temp1 > 700)\r\n\t\t{\r\n\t\t\tob->temp2++;\r\n\t\t\tob->state = &s_keenyawn1;\r\n\t\t\tob->temp1 = 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tif (ob->temp1 > 400)\r\n\t\t{\r\n\t\t\tob->temp2++;\r\n\t\t\tob->state = &s_keenpauselook;\r\n\t\t\tob->temp1 = 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tif (ob->temp1 > 700)\r\n\t\t{\r\n\t\t\tob->temp2++;\r\n\t\t\tob->state = &s_keenyawn1;\r\n\t\t\tob->temp1 = 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase 5:\r\n\t\tif (ob->temp1 > 400)\r\n\t\t{\r\n\t\t\tob->temp2++;\r\n\t\t\tob->state = &s_keengosleep1;\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenGoSleepThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid KeenGoSleepThink (objtype *ob)\r\n{\r\n//\r\n// spawn the zees above keens head\r\n//\r\n\tGetNewObj (true);\r\n\r\n\tnew->obclass = inertobj;\r\n\tnew->x = player->x;\r\n\tnew->y = player->y-4*PIXGLOBAL;\r\n\tnew->xdir = 1;\r\n\tnew->ydir = -1;\r\n\tNewState (new,&s_keenzee1);\r\n\r\n\tob->temp1 = (int)new;\t\t\t\t// so they can be removed later\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenSleepThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid KeenSleepThink (objtype *ob)\r\n{\r\n\tif (c.dir != dir_None || c.button0 || c.button1)\r\n\t{\r\n\t\tif (ob->temp1 != (unsigned)&dummyobj)\r\n\t\t\tRemoveObj ((objtype *)ob->temp1);\t// remove the zees\r\n\t\tob->temp1 = ob->temp2 = 0;\t\t\t// not paused any more\r\n\t\tob->state = &s_keengetup;\r\n\t}\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenDieThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid KeenDieThink (objtype *ob)\r\n{\r\n\tob++;\t\t\t// shut up compiler\r\n\tplaystate = died;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenDuckThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid KeenDuckThink (objtype *ob)\r\n{\r\n\tunsigned far *map, tile;\r\n\tint midtile,bottomtile,move;\r\n\r\n\tif (c.yaxis != 1)\r\n\t{\r\n\t\tob->state = &s_keenstand;\r\n\t\tKeenStandThink(ob);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c.xaxis)\r\n\t\tob->xdir = c.xaxis;\r\n\r\n\tif (c.button0 && !button0held)\r\n\t{\r\n\t//\r\n\t// drop down a level\r\n\t//\r\n\t\tbutton0held = true;\r\n\r\n\t\tmidtile = (ob->tileleft + ob->tileright) >> 1;\r\n\t\tbottomtile = ob->tilebottom;\r\n\t\tmap = (unsigned far *)mapsegs[1] + mapbwidthtable[bottomtile]/2\r\n\t\t\t+ midtile;\r\n\t\ttile = *map;\r\n\t\tif (tinf[WESTWALL+tile] || tinf[EASTWALL+tile]\r\n\t\t\t|| tinf[SOUTHWALL+tile])\r\n\t\t\treturn;\t\t\t\t// wall prevents drop down\r\n\r\n\t\tmap += mapwidth;\r\n\t\ttile = *map;\r\n\t\tif (tinf[WESTWALL+tile] || tinf[EASTWALL+tile]\r\n\t\t\t|| tinf[SOUTHWALL+tile])\r\n\t\t\treturn;\t\t\t\t// wall prevents drop down\r\n\r\n\t\tmove = PIXGLOBAL*(tics<4 ? 4: tics);\r\n\t\tob->bottom += move;\r\n\t\tob->y += move;\r\n\t\tob->xmove = ob->ymove = 0;\r\n\t\tob->state = &s_keenjumpup3;\r\n\t\tob->temp2 = 1;\t\t// allready in last stage\r\n\t\tob->xspeed = ob->yspeed = 0;\r\n\t\tSD_PlaySound (PLUMMETSND);\r\n\t}\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenDropDownThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid KeenDropDownThink (objtype *ob)\r\n{\r\n\tob->needtoclip = true;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenWalkThink\r\n=\r\n=======================\r\n*/\r\n\r\nunsigned slopespeed[8] = {0,0,4,4,8,-4,-4,-8};\r\n\r\nvoid KeenWalkThink (objtype *ob)\r\n{\r\n\tint move;\r\n\r\n\tif (!c.xaxis)\r\n\t{\r\n\t//\r\n\t// stopped running\r\n\t//\r\n\t\tKeenStandThink (ob);\r\n\t\treturn;\r\n\t}\r\n\r\n\tob->xdir = c.xaxis;\r\n\r\n\tif (c.yaxis && CheckGrabPole(ob))\t\t// try to go up/down pole\r\n\t\treturn;\r\n\r\n\tif (c.button0 && !button0held)\r\n\t{\r\n\t//\r\n\t// running jump\r\n\t//\r\n\t\tSD_PlaySound (JUMPSND);\r\n\t\tob->xspeed = ob->xdir * SPDRUNJUMP;\r\n\t\tob->yspeed = -SPDJUMP;\r\n\t\tob->xmove = 0;\r\n\t\tob->ymove = 0;\t\t\t\t\t// ob->yspeed*tics;\r\n\t\tbutton0held = true;\r\n\t\tjumptime = JUMPTIME; //-tics;\t\t// DEBUG\r\n\t\tob->state = &s_keenjump1;\r\n\t}\r\n\r\n\tif (c.button1 && !button1held)\r\n\t{\r\n\t//\r\n\t// throw\r\n\t//\r\n\t\tob->state = &s_keenthrow1;\r\n\t\tbutton1held = true;\r\n\t\treturn;\r\n\t}\r\n\r\n\t//\r\n\t// give speed for slopes\r\n\t//\r\n\tmove = tics*slopespeed[ob->hitnorth&7];\r\n\r\n\tob->xmove += move;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenAirThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid\tKeenAirThink\t\t(objtype *ob)\r\n{\r\n\tif (jumptime)\r\n\t{\r\n\t\tif (jumptime<tics)\r\n\t\t{\r\n\t\t\tob->ymove = ob->yspeed*jumptime;\r\n\t\t\tjumptime = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tob->ymove = ob->yspeed*tics;\r\n\t\t\tif (!jumpcheat)\r\n\t\t\t\tjumptime-=tics;\r\n\t\t}\r\n\t\tif (!c.button0)\r\n\t\t\tjumptime = 0;\r\n\r\n\t\tif (!jumptime)\r\n\t\t{\r\n\t\t\tob->temp2 = 0;\r\n\t\t\tob->state = ob->state->nextstate;\t// switch to second jump stage\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tDoGravity(ob);\r\n\r\n\t\tif (ob->yspeed>0 && !ob->temp2)\r\n\t\t{\r\n\t\t\tob->state = ob->state->nextstate;\t// switch to third jump stage\r\n\t\t\tob->temp2 = 1;\r\n\t\t}\r\n\t}\r\n\r\n//-------------\r\n\r\n\tif (c.xaxis)\r\n\t{\r\n\t\tob->xdir = c.xaxis;\r\n\t\tAccelerateX(ob,c.xaxis*2,MAXXSPEED);\r\n\t}\r\n\telse\r\n\t\tFrictionX(ob);\r\n\r\n\tif (c.button1 && !button1held)\r\n\t{\r\n\t\tbutton1held = true;\r\n\t//\r\n\t// throw\r\n\t//\r\n\t\tswitch (c.yaxis)\r\n\t\t{\r\n\t\tcase -1:\r\n\t\t\tob->state = &s_keenairthrowup1;\r\n\t\t\treturn;\r\n\t\tcase 0:\r\n\t\t\tob->state = &s_keenairthrow1;\r\n\t\t\treturn;\r\n\t\tcase 1:\r\n\t\t\tob->state = &s_keenairthrowdown1;\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tif (ob->hitsouth==17)\t\t// going through a pole hole\r\n\t{\r\n\t\tob->xspeed = ob->xmove = 0;\r\n\t}\r\n\r\n\r\n\tif (c.yaxis == -1)\r\n\t\tCheckGrabPole (ob);\r\n\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenPoleThink\r\n=\r\n=======================\r\n*/\r\n\r\nint\tpolexspeed[3] = {-SPDPOLESIDEJUMP,0,SPDPOLESIDEJUMP};\r\n\r\nvoid\tPoleActions (objtype *ob)\r\n{\r\n\tif (c.xaxis)\r\n\t\tob->xdir = c.xaxis;\r\n\r\n\tif (c.button0 && !button0held)\t\t// jump off the pole\r\n\t{\r\n\t\tSD_PlaySound (JUMPSND);\r\n\t\tob->xspeed = polexspeed[c.xaxis+1];\r\n\t\tob->yspeed = -SPDPOLEJUMP;\r\n\t\tob->needtoclip = true;\r\n\t\tjumptime = POLEJUMPTIME;\r\n\t\tob->state = &s_keenjump1;\r\n\t\tob->ydir = 1;\r\n\t\tbutton0held = true;\r\n\t\tleavepoletime = TimeCount;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c.button1 && !button1held)\r\n\t{\r\n\t\tbutton1held = true;\r\n\r\n\t\tswitch (c.yaxis)\r\n\t\t{\r\n\t\tcase -1:\r\n\t\t\tob->state = &s_keenpolethrowup1;\r\n\t\t\tbreak;\r\n\t\tcase 0:\r\n\t\t\tob->state = &s_keenpolethrow1;\r\n\t\t\tbreak;\r\n\t\tcase 1:\r\n\t\t\tob->state = &s_keenpolethrowdown1;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nvoid\tKeenPoleThink\t\t(objtype *ob)\r\n{\r\n\tunsigned far *map, tile;\r\n\r\n\tswitch (c.yaxis)\r\n\t{\r\n\tcase -1:\r\n\t\tob->state = &s_keenclimb1;\r\n\t\tob->ydir = -1;\r\n\t\treturn;\r\n\r\n\tcase 1:\r\n\t\tob->state = &s_keenslide1;\r\n\t\tob->ydir = 1;\r\n\t\tKeenDropThink (ob);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (c.xaxis)\r\n\t{\r\n\t//\r\n\t// walk off pole if right next to ground\r\n\t//\r\n\t\tmap = mapsegs[1] + (mapbwidthtable[ob->tilebottom+1]/2 + ob->tilemidx);\r\n\t\ttile = *map;\r\n\t\tif (tinf[NORTHWALL+tile])\r\n\t\t{\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->yspeed = 0;\r\n\t\t\tob->needtoclip = true;\r\n\t\t\tjumptime = 0;\r\n\t\t\tob->state = &s_keenjump3;\r\n\t\t\tob->ydir = 1;\r\n\t\t\tSD_PlaySound (PLUMMETSND);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\tPoleActions (ob);\r\n}\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenClimbThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid\tKeenClimbThink\t\t(objtype *ob)\r\n{\r\n\tunsigned far *map;\r\n\r\n\tmap = (unsigned _seg *)mapsegs[1]+mapbwidthtable[ob->tiletop]/2+ob->temp4;\r\n\r\n\tif ((tinf[INTILE+*map]&0x7f) != 1)\r\n\t{\r\n\t\tob->ymove=0;\r\n\t\tob->state = &s_keenpole;\t\t// ran out of pole\r\n\t\treturn;\r\n\t}\r\n\r\n\tswitch (c.yaxis)\r\n\t{\r\n\tcase 0:\r\n\t\tob->state = &s_keenpole;\r\n\t\tob->ydir = 0;\r\n\t\tbreak;\r\n\r\n\tcase 1:\r\n\t\tob->state = &s_keenslide1;\r\n\t\tob->ydir = 1;\r\n\t\tKeenDropThink (ob);\r\n\t\tbreak;\r\n\t}\r\n\r\n\tPoleActions (ob);\r\n}\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenDropThink\r\n=\r\n=======================\r\n*/\r\n\r\nvoid\tKeenDropThink\t\t(objtype *ob)\r\n{\r\n\tunsigned far *map;\r\n\r\n\tmap = (unsigned _seg *)mapsegs[1]+mapbwidthtable[ob->tilebottom]/2+ob->temp4;\r\n\r\n\tif ((tinf[INTILE+*map]&0x7f) != 1)\r\n\t{\r\n\t\tSD_PlaySound (PLUMMETSND);\r\n\t\tob->state = &s_keenjump3;\t\t// ran out of pole\r\n\t\tjumptime = 0;\r\n\t\tob->temp2 = 1;\r\n\t\tob->xspeed = polexspeed[c.xaxis+1];\r\n\t\tob->yspeed = 0;\r\n\t\tob->needtoclip = true;\r\n\t\tob->tilebottom--;\r\n\t\treturn;\r\n\t}\r\n\r\n\tswitch (c.yaxis)\r\n\t{\r\n\tcase -1:\r\n\t\tob->state = &s_keenclimb1;\r\n\t\tob->ydir = -1;\r\n\t\tbreak;\r\n\r\n\tcase 0:\r\n\t\tob->state = &s_keenpole;\r\n\t\tob->ydir = 0;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tPoleActions (ob);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=======================\r\n=\r\n= KeenThrow\r\n=\r\n=======================\r\n*/\r\n\r\nvoid\tKeenThrow\t(objtype *ob)\r\n{\r\n// can't use &<var> in a switch statement...\r\n\r\n\tif (ob->state == &s_keenthrow3)\r\n\t{\r\n\t\tif (ob->xdir > 0)\r\n\t\t\tThrowPower (ob->midx-4*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_East);\r\n\t\telse\r\n\t\t\tThrowPower (ob->midx-4*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_West);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenpolethrow2)\r\n\t{\r\n\t\tif (ob->xdir > 0)\r\n\t\t\tThrowPower (ob->x+24*PIXGLOBAL,ob->y,dir_East);\r\n\t\telse\r\n\t\t\tThrowPower (ob->x-8*PIXGLOBAL,ob->y,dir_West);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenthrowup2)\r\n\t{\r\n\t\tThrowPower (ob->x+4*PIXGLOBAL,ob->y-8*PIXGLOBAL,dir_North);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenpolethrowup2)\r\n\t{\r\n\t\tThrowPower (ob->x+8*PIXGLOBAL,ob->y-8*PIXGLOBAL,dir_North);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenpolethrowdown2)\r\n\t{\r\n\t\tThrowPower (ob->x+8*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_South);\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenairthrow2)\r\n\t{\r\n\t\tif (ob->xdir > 0)\r\n\t\t\tThrowPower (ob->midx-4*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_East);\r\n\t\telse\r\n\t\t\tThrowPower (ob->midx-4*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_West);\r\n#if 0\r\n\t\tif (ob->xdir > 0)\r\n\t\t\tThrowPower (ob->x+32*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_East);\r\n\t\telse\r\n\t\t\tThrowPower (ob->x-16*PIXGLOBAL,ob->y+8*PIXGLOBAL,dir_West);\r\n#endif\r\n\r\n\t\tnew->xspeed += ob->xspeed/2;\r\n\t\tnew->yspeed += ob->yspeed/2;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenairthrowup2)\r\n\t{\r\n\t\tif (ob->xdir > 0)\r\n\t\t\tThrowPower (ob->x+16*PIXGLOBAL,ob->y,dir_North);\r\n\t\telse\r\n\t\t\tThrowPower (ob->x+4*PIXGLOBAL,ob->y,dir_North);\r\n\t\tnew->xspeed += ob->xspeed/2;\r\n\t\tnew->yspeed += ob->yspeed/2;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (ob->state == &s_keenairthrowdown2)\r\n\t{\r\n\t\tif (ob->xdir > 0)\r\n\t\t\tThrowPower (ob->x+3*PIXGLOBAL,ob->y+16*PIXGLOBAL,dir_South);\r\n\t\telse\r\n\t\t\tThrowPower (ob->x+12*PIXGLOBAL,ob->y+16*PIXGLOBAL,dir_South);\r\n\t\tnew->xspeed += ob->xspeed/2;\r\n\t\tnew->yspeed += ob->yspeed/2;\r\n\t\treturn;\r\n\t}\r\n\r\n\tQuit (\"KeenThrow: Bad state!\");\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\tCONTACT ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n============================\r\n=\r\n= KillKeen\r\n=\r\n============================\r\n*/\r\n\r\nvoid KillKeen (void)\r\n{\r\n\tif (!godmode)\r\n\t{\r\n\t\tSD_PlaySound (WAKEUPSND);\r\n\t\tplayer->needtoclip = false;\r\n\t\tChangeState (player,&s_keendie1);\r\n\t}\r\n}\r\n\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= KeenContact\r\n=\r\n============================\r\n*/\r\n\r\nunsigned bonuspoints[6] = {100,200,500,1000,2000,5000};\r\n\r\nvoid\tKeenContact (objtype *ob, objtype *hit)\r\n{\r\n\tswitch (hit->obclass)\r\n\t{\r\n\tcase\tbonusobj:\r\n\t\thit->obclass = inertobj;\r\n\t\tswitch (hit->temp1)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\tcase 1:\r\n\t\tcase 2:\r\n\t\tcase 3:\r\n\t\tcase 4:\r\n\t\tcase 5:\r\n\t\t\tSD_PlaySound (GETPOINTSSND);\r\n\t\t\thit->shapenum = BONUS100SPR+hit->temp1;\r\n\t\t\tGivePoints (bonuspoints[hit->temp1]);\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\tcase 6:\r\n\t\t\tSD_PlaySound (EXTRAKEENSND);\r\n\t\t\thit->shapenum = BONUS1UPSPR;\r\n\t\t\tgamestate.lives++;\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\tcase 7:\r\n\t\t\tSD_PlaySound (EXTRAKEENSND);\r\n\t\t\thit->shapenum = BONUSSUPERSPR;\r\n\t\t\tgamestate.lives+=3;\r\n\t\t\tgamestate.flowerpowers+=8;\r\n\t\t\tGivePoints (10000);\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\tcase 8:\r\n\t\t\tSD_PlaySound (GETPOWERSND);\r\n\t\t\thit->shapenum = BONUSFLOWERSPR;\r\n\t\t\tgamestate.flowerpowers++;\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\tcase 9:\r\n\t\t\tSD_PlaySound (GETPOWERSND);\r\n\t\t\thit->shapenum = BONUSFLOWERUPSPR;\r\n\t\t\tgamestate.flowerpowers+=5;\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\tcase 10:\r\n\t\t\tSD_PlaySound (GETBOMBSND);\r\n\t\t\thit->shapenum = BONUSBOMBSPR;\r\n\t\t\tgamestate.boobusbombs++;\r\n\t\t\tgamestate.bombsthislevel++;\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\tcase 11:\r\n\t\t\tSD_PlaySound (GETKEYSND);\r\n\t\t\thit->shapenum = BONUSKEYSPR;\r\n\t\t\tgamestate.keys++;\r\n\t\t\tChangeState (hit,&s_bonusrise);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tbreak;\r\n\r\n\tcase\tdoorobj:\r\n\t\tif (gamestate.keys)\r\n\t\t{\r\n\t\t\tif (hit->state != &s_doorraise)\r\n\t\t\t{\r\n\t\t\t\tSD_PlaySound (OPENDOORSND);\r\n\t\t\t\tgamestate.keys--;\r\n\t\t\t\tChangeState (hit,&s_doorraise);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSD_PlaySound (NOWAYSND);\r\n\t\t\tClipToSpriteSide (ob,hit);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase\ttaterobj:\r\n\t\tif (hit->state == &s_taterattack2)\r\n\t\t\tKillKeen ();\r\n\t\tbreak;\r\n\tcase\tcarrotobj:\r\n\t\tClipToSpriteSide (ob,hit);\r\n\t\tif (!ob->needtoclip)\t\t// got pushed off a pole\r\n\t\t{\r\n\t\t\tSD_PlaySound (PLUMMETSND);\r\n\t\t\tob->needtoclip = true;\r\n\t\t\tob->xspeed = ob->yspeed = 0;\r\n\t\t\tChangeState(ob,&s_keenjump3);\r\n\t\t\tob->temp2 = 1;\r\n\t\t\tjumptime = 0;\r\n\t\t}\r\n\t\tbreak;\r\n\tcase\tcartobj:\r\n\t\tClipToSprite (ob,hit,true);\r\n\t\tbreak;\r\n\tcase\tbroccoobj:\r\n\t\tif (hit->state == &s_broccosmash3 || hit->state == &s_broccosmash4)\r\n\t\t\tKillKeen ();\r\n\t\tbreak;\r\n\tcase\tsquashobj:\r\n\t\tif (hit->state == &s_squasherjump2)\r\n\t\t\tKillKeen ();\r\n\t\telse\r\n\t\t{\r\n\t\t\tClipToSpriteSide (ob,hit);\r\n\t\t\tif (!ob->needtoclip)\t\t// got pushed off a pole\r\n\t\t\t{\r\n\t\t\t\tSD_PlaySound (PLUMMETSND);\r\n\t\t\t\tob->needtoclip = true;\r\n\t\t\t\tob->xspeed = ob->yspeed = 0;\r\n\t\t\t\tChangeState(ob,&s_keenjump3);\r\n\t\t\t\tob->temp2 = 1;\r\n\t\t\t\tjumptime = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\tbreak;\r\n\tcase\tgrapeobj:\r\n\t\tif (hit->state == &s_grapefall)\r\n\t\t\tKillKeen ();\r\n\t\tbreak;\r\n\tcase\ttomatobj:\r\n\tcase\tceleryobj:\r\n\tcase\tasparobj:\r\n\tcase\tturnipobj:\r\n\tcase\tcauliobj:\r\n\tcase\tbrusselobj:\r\n\tcase\tmushroomobj:\r\n\tcase\tapelobj:\r\n\tcase\tpeabrainobj:\r\n\tcase\tboobusobj:\r\n\tcase\tshotobj:\r\n\t\t\tKillKeen ();\r\n\t\tbreak;\r\n\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t REACTION ROUTINES\r\n\r\n=============================================================================\r\n*/\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= KeenSimpleReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tKeenSimpleReact (objtype *ob)\r\n{\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= KeenStandReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tKeenStandReact (objtype *ob)\r\n{\r\n\tif (!ob->hitnorth)\r\n\t{\r\n\t//\r\n\t// walked off an edge\r\n\t//\r\n\t\tSD_PlaySound (PLUMMETSND);\r\n\t\tob->xspeed = ob->xdir*WALKAIRSPEED;\r\n\t\tChangeState (ob,&s_keenjump3);\r\n\t\tob->temp2 = 1;\r\n\t\tjumptime = 0;\r\n\t}\r\n\telse if ( (ob->hitnorth & ~7) == 8)\t// deadly floor!\r\n\t{\r\n\t\tKillKeen ();\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n/*\r\n============================\r\n=\r\n= KeenWalkReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tKeenWalkReact (objtype *ob)\r\n{\r\n\tif (!ob->hitnorth)\r\n\t{\r\n\t//\r\n\t// walked off an edge\r\n\t//\r\n\t\tob->xspeed = ob->xdir*WALKAIRSPEED;\r\n\t\tob->yspeed = 0;\r\n\t\tChangeState (ob,&s_keenjump3);\r\n\t\tob->temp2 = 1;\r\n\t\tjumptime = 0;\r\n\t}\r\n\telse if ( (ob->hitnorth & ~7) == 8)\t// deadly floor!\r\n\t{\r\n\t\tKillKeen ();\r\n\t\tgoto placeit;\r\n\t}\r\n\r\n\tif (ob->hiteast == 2)\t\t\t// doors\r\n\t{\r\n\r\n\t}\r\n\telse if (ob->hitwest == 2)\t\t// doors\r\n\t{\r\n\r\n\t}\r\n\telse if (ob->hiteast || ob->hitwest)\r\n\t{\r\n\t//\r\n\t// ran into a wall\r\n\t//\r\n\t\tob->ticcount = 0;\r\n\t\tob->state = &s_keenstand;\r\n\t\tob->shapenum = ob->xdir == 1 ? s_keenstand.rightshapenum :\r\n\t\t\ts_keenstand.leftshapenum;\r\n\t}\r\nplaceit:\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n\r\n/*\r\n============================\r\n=\r\n= KeenAirReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tKeenAirReact (objtype *ob)\r\n{\r\n\tint x,y;\r\n\tunsigned far *map,mapextra;\r\n\r\n\tif (ob->hiteast || ob->hitwest)\r\n\t\tob->xspeed = 0;\r\n\r\n\tmap = mapsegs[1] + (mapbwidthtable[ob->tiletop]/2) + ob->tileleft;\r\n\tmapextra = mapwidth - (ob->tileright - ob->tileleft+1);\r\n\tfor (y=ob->tiletop;y<=ob->tilebottom;y++,map+=mapextra)\r\n\t\tfor (x=ob->tileleft;x<=ob->tileright;x++,map++)\r\n\t\t\tif (tinf[SOUTHWALL+*map] == 17)\t// jumping up through a pole hole\r\n\t\t\t{\r\n\t\t\t\tob->xspeed = 0;\r\n\t\t\t\tob->x = ob->tilemidx*TILEGLOBAL - 2*PIXGLOBAL;\r\n\t\t\t\tgoto checknorth;\r\n\t\t\t}\r\n\r\n\tif (ob->hitsouth)\r\n\t{\r\n\t\tif (ob->hitsouth == 17)\t// jumping up through a pole hole\r\n\t\t{\r\n\t\t\tob->y -= 32;\r\n\t\t\tob->top -= 32;\r\n\t\t\tob->xspeed = 0;\r\n\t\t\tob->x = ob->tilemidx*TILEGLOBAL - 2*PIXGLOBAL;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tSD_PlaySound (HITHEADSND);\r\n\r\n\t\t\tif (ob->hitsouth > 1)\r\n\t\t\t{\r\n\t\t\t\tob->yspeed += 16;\r\n\t\t\t\tif (ob->yspeed<0)\t// push away from slopes\r\n\t\t\t\t\tob->yspeed = 0;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tob->yspeed = 0;\r\n\t\t\tjumptime = 0;\r\n\t\t}\r\n\t}\r\n\r\nchecknorth:\r\n\tif (ob->hitnorth)\r\n\t{\r\n\t\tif (!(ob->hitnorth == 25 && jumptime))\t// KLUDGE to allow jumping off\r\n\t\t{\t\t\t\t\t\t\t\t\t\t// sprites\r\n\t\t\tob->temp1 = ob->temp2 = 0;\r\n\t\t\tChangeState (ob,&s_keenstand);\r\n\t\t\tSD_PlaySound (LANDSND);\r\n\t\t}\r\n\t}\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n/*\r\n============================\r\n=\r\n= KeenSlideReact\r\n=\r\n============================\r\n*/\r\n\r\nvoid\tKeenSlideReact (objtype *ob)\r\n{\r\n\tunsigned far *map;\r\n\r\n\tif (ob->hitnorth)\t\t\t// friction slow down\r\n\t{\r\n\t\tmap = mapsegs[2] + (mapbwidthtable[ob->tiletop]/2 + ob->tileleft);\r\n\t\tif (!tinf[SOUTHWALL+*map] && !tinf[SOUTHWALL+*(map+1)])\r\n\t\t\tFrictionX(ob);\r\n\t}\r\n\r\n\r\n\tif (ob->hitwest || ob->hiteast || !ob->xspeed)\r\n\t\tChangeState (ob,&s_keengetup);\r\n\r\n\tPLACESPRITE;\r\n}\r\n\r\n"
        },
        {
          "name": "kd_main.c",
          "type": "blob",
          "size": 11.1787109375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_MAIN.C\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t\tKEEN DREAMS\r\n\r\n\t\t\t\t\tAn Id Software production\r\n\r\n=============================================================================\r\n*/\r\n\r\n#include \"mem.h\"\r\n#include \"string.h\"\r\n\r\n#include \"KD_DEF.H\"\r\n#pragma hdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nchar\t\tstr[80],str2[20];\r\nboolean\t\tsinglestep,jumpcheat,godmode,tedlevel;\r\nunsigned\ttedlevelnum;\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nvoid\tDebugMemory (void);\r\nvoid\tTestSprites(void);\r\nint\t\tDebugKeys (void);\r\nvoid\tShutdownId (void);\r\nvoid\tQuit (char *error);\r\nvoid\tInitGame (void);\r\nvoid\tmain (void);\r\n\r\n//===========================================================================\r\n\r\n#if FRILLS\r\n\r\n/*\r\n==================\r\n=\r\n= DebugMemory\r\n=\r\n==================\r\n*/\r\n\r\nvoid DebugMemory (void)\r\n{\r\n\tVW_FixRefreshBuffer ();\r\n\tUS_CenterWindow (16,7);\r\n\r\n\tUS_CPrint (\"Memory Usage\");\r\n\tUS_CPrint (\"------------\");\r\n\tUS_Print (\"Total     :\");\r\n\tUS_PrintUnsigned (mminfo.mainmem/1024);\r\n\tUS_Print (\"k\\nFree      :\");\r\n\tUS_PrintUnsigned (MM_UnusedMemory()/1024);\r\n\tUS_Print (\"k\\nWith purge:\");\r\n\tUS_PrintUnsigned (MM_TotalFree()/1024);\r\n\tUS_Print (\"k\\n\");\r\n\tVW_UpdateScreen();\r\n\tIN_Ack ();\r\n#if GRMODE == EGAGR\r\n\tMM_ShowMemory ();\r\n#endif\r\n}\r\n\r\n/*\r\n===================\r\n=\r\n= TestSprites\r\n=\r\n===================\r\n*/\r\n\r\n#define DISPWIDTH\t110\r\n#define\tTEXTWIDTH   40\r\nvoid TestSprites(void)\r\n{\r\n\tint hx,hy,sprite,oldsprite,bottomy,topx,shift;\r\n\tspritetabletype far *spr;\r\n\tspritetype _seg\t*block;\r\n\tunsigned\tmem,scan;\r\n\r\n\r\n\tVW_FixRefreshBuffer ();\r\n\tUS_CenterWindow (30,17);\r\n\r\n\tUS_CPrint (\"Sprite Test\");\r\n\tUS_CPrint (\"-----------\");\r\n\r\n\thy=PrintY;\r\n\thx=(PrintX+56)&(~7);\r\n\ttopx = hx+TEXTWIDTH;\r\n\r\n\tUS_Print (\"Chunk:\\nWidth:\\nHeight:\\nOrgx:\\nOrgy:\\nXl:\\nYl:\\nXh:\\nYh:\\n\"\r\n\t\t\t  \"Shifts:\\nMem:\\n\");\r\n\r\n\tbottomy = PrintY;\r\n\r\n\tsprite = STARTSPRITES;\r\n\tshift = 0;\r\n\r\n\tdo\r\n\t{\r\n\t\tif (sprite>=STARTTILE8)\r\n\t\t\tsprite = STARTTILE8-1;\r\n\t\telse if (sprite<STARTSPRITES)\r\n\t\t\tsprite = STARTSPRITES;\r\n\r\n\t\tspr = &spritetable[sprite-STARTSPRITES];\r\n\t\tblock = (spritetype _seg *)grsegs[sprite];\r\n\r\n\t\tVWB_Bar (hx,hy,TEXTWIDTH,bottomy-hy,WHITE);\r\n\r\n\t\tPrintX=hx;\r\n\t\tPrintY=hy;\r\n\t\tUS_PrintUnsigned (sprite);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintUnsigned (spr->width);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintUnsigned (spr->height);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->orgx);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->orgy);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->xl);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->yl);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->xh);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->yh);US_Print (\"\\n\");PrintX=hx;\r\n\t\tUS_PrintSigned (spr->shifts);US_Print (\"\\n\");PrintX=hx;\r\n\t\tif (!block)\r\n\t\t{\r\n\t\t\tUS_Print (\"-----\");\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmem = block->sourceoffset[3]+5*block->planesize[3];\r\n\t\t\tmem = (mem+15)&(~15);\t\t// round to paragraphs\r\n\t\t\tUS_PrintUnsigned (mem);\r\n\t\t}\r\n\r\n\t\toldsprite = sprite;\r\n\t\tdo\r\n\t\t{\r\n\t\t//\r\n\t\t// draw the current shift, then wait for key\r\n\t\t//\r\n\t\t\tVWB_Bar(topx,hy,DISPWIDTH,bottomy-hy,WHITE);\r\n\t\t\tif (block)\r\n\t\t\t{\r\n\t\t\t\tPrintX = topx;\r\n\t\t\t\tPrintY = hy;\r\n\t\t\t\tUS_Print (\"Shift:\");\r\n\t\t\t\tUS_PrintUnsigned (shift);\r\n\t\t\t\tUS_Print (\"\\n\");\r\n\t\t\t\tVWB_DrawSprite (topx+16+shift*2,PrintY,sprite);\r\n\t\t\t}\r\n\r\n\t\t\tVW_UpdateScreen();\r\n\r\n\t\t\tscan = IN_WaitForKey ();\r\n\r\n\t\t\tswitch (scan)\r\n\t\t\t{\r\n\t\t\tcase sc_UpArrow:\r\n\t\t\t\tsprite++;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_DownArrow:\r\n\t\t\t\tsprite--;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_LeftArrow:\r\n\t\t\t\tif (--shift == -1)\r\n\t\t\t\t\tshift = 3;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_RightArrow:\r\n\t\t\t\tif (++shift == 4)\r\n\t\t\t\t\tshift = 0;\r\n\t\t\t\tbreak;\r\n\t\t\tcase sc_Escape:\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t} while (sprite == oldsprite);\r\n\r\n  } while (1);\r\n\r\n\r\n}\r\n\r\n#endif\r\n\r\n\r\n/*\r\n================\r\n=\r\n= DebugKeys\r\n=\r\n================\r\n*/\r\nint DebugKeys (void)\r\n{\r\n\tboolean esc;\r\n\tint level;\r\n\r\n#if FRILLS\r\n\tif (Keyboard[0x12] && ingame)\t// DEBUG: end + 'E' to quit level\r\n\t{\r\n\t\tif (tedlevel)\r\n\t\t\tTEDDeath();\r\n\t\tplaystate = levelcomplete;\r\n\t}\r\n#endif\r\n\r\n\tif (Keyboard[0x22] && ingame)\t\t// G = god mode\r\n\t{\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow (12,2);\r\n\t\tif (godmode)\r\n\t\t  US_PrintCentered (\"God mode OFF\");\r\n\t\telse\r\n\t\t  US_PrintCentered (\"God mode ON\");\r\n\t\tVW_UpdateScreen();\r\n\t\tIN_Ack();\r\n\t\tgodmode ^= 1;\r\n\t\treturn 1;\r\n\t}\r\n\telse if (Keyboard[0x17])\t\t\t// I = item cheat\r\n\t{\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow (12,3);\r\n\t\tUS_PrintCentered (\"Free items!\");\r\n\t\tgamestate.boobusbombs=99;\r\n\t\tgamestate.flowerpowers=99;\r\n\t\tgamestate.keys=99;\r\n\t\tVW_UpdateScreen();\r\n\t\tIN_Ack ();\r\n\t\treturn 1;\r\n\t}\r\n\telse if (Keyboard[0x24])\t\t\t// J = jump cheat\r\n\t{\r\n\t\tjumpcheat^=1;\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow (18,3);\r\n\t\tif (jumpcheat)\r\n\t\t\tUS_PrintCentered (\"Jump cheat ON\");\r\n\t\telse\r\n\t\t\tUS_PrintCentered (\"Jump cheat OFF\");\r\n\t\tVW_UpdateScreen();\r\n\t\tIN_Ack ();\r\n\t\treturn 1;\r\n\t}\r\n#if FRILLS\r\n\telse if (Keyboard[0x32])\t\t\t// M = memory info\r\n\t{\r\n\t\tDebugMemory();\r\n\t\treturn 1;\r\n\t}\r\n#endif\r\n\telse if (Keyboard[0x19])\t\t\t// P = pause with no screen disruptioon\r\n\t{\r\n\t\tIN_Ack();\r\n\t}\r\n\telse if (Keyboard[0x1f] && ingame)\t// S = slow motion\r\n\t{\r\n\t\tsinglestep^=1;\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow (18,3);\r\n\t\tif (singlestep)\r\n\t\t\tUS_PrintCentered (\"Slow motion ON\");\r\n\t\telse\r\n\t\t\tUS_PrintCentered (\"Slow motion OFF\");\r\n\t\tVW_UpdateScreen();\r\n\t\tIN_Ack ();\r\n\t\treturn 1;\r\n\t}\r\n#if FRILLS\r\n\telse if (Keyboard[0x14])\t\t\t// T = sprite test\r\n\t{\r\n\t\tTestSprites();\r\n\t\treturn 1;\r\n\t}\r\n#endif\r\n\telse if (Keyboard[0x11] && ingame)\t// W = warp to level\r\n\t{\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow(26,3);\r\n\t\tPrintY+=6;\r\n\t\tUS_Print(\"  Warp to which level(0-16):\");\r\n\t\tVW_UpdateScreen();\r\n\t\tesc = !US_LineInput (px,py,str,NULL,true,2,0);\r\n\t\tif (!esc)\r\n\t\t{\r\n\t\t\tlevel = atoi (str);\r\n\t\t\tif (level>=0 && level<=16)\r\n\t\t\t{\r\n\t\t\t\tgamestate.mapon = level;\r\n\t\t\t\tplaystate = warptolevel;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= ShutdownId\r\n=\r\n= Shuts down all ID_?? managers\r\n=\r\n==========================\r\n*/\r\n\r\nvoid ShutdownId (void)\r\n{\r\n  US_Shutdown ();\r\n  SD_Shutdown ();\r\n  IN_Shutdown ();\r\n  RF_Shutdown ();\r\n  VW_Shutdown ();\r\n  CA_Shutdown ();\r\n  MM_Shutdown ();\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= Quit\r\n=\r\n==========================\r\n*/\r\n\r\nvoid Quit (char *error)\r\n{\r\n  ShutdownId ();\r\n  if (error && *error)\r\n  {\r\n\tclrscr();\r\n\tputs(error);\r\n\tputs(\"\\n\");\r\n\texit(1);\r\n  }\r\n\texit (0);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= InitGame\r\n=\r\n= Load a few things right away\r\n=\r\n==========================\r\n*/\r\n\r\n#if 0\r\n#include \"piracy.h\"\r\n#endif\r\n\r\nvoid InitGame (void)\r\n{\r\n\tint i;\r\n\r\n\tMM_Startup ();\r\n\r\n\r\n#if 0\r\n\t// Handle piracy screen...\r\n\t//\r\n\tmovedata(FP_SEG(PIRACY),(unsigned)PIRACY,0xb800,displayofs,4000);\r\n\twhile ((bioskey(0)>>8) != sc_Return);\r\n#endif\r\n\r\n\r\n#if GRMODE == EGAGR\r\n\tif (mminfo.mainmem < 335l*1024)\r\n\t{\r\n#pragma\twarn\t-pro\r\n#pragma\twarn\t-nod\r\n\t\tclrscr();\t\t\t// we can't include CONIO because of a name conflict\r\n#pragma\twarn\t+nod\r\n#pragma\twarn\t+pro\r\n\t\tputs (\"There is not enough memory available to play the game reliably.  You can\");\r\n\t\tputs (\"play anyway, but an out of memory condition will eventually pop up.  The\");\r\n\t\tputs (\"correct solution is to unload some TSRs or rename your CONFIG.SYS and\");\r\n\t\tputs (\"AUTOEXEC.BAT to free up more memory.\\n\");\r\n\t\tputs (\"Do you want to (Q)uit, or (C)ontinue?\");\r\n\t\ti = bioskey (0);\r\n\t\tif ( (i>>8) != sc_C)\r\n\t\t\tQuit (\"\");\r\n\t}\r\n#endif\r\n\r\n\tUS_TextScreen();\r\n\r\n\tVW_Startup ();\r\n\tRF_Startup ();\r\n\tIN_Startup ();\r\n\tSD_Startup ();\r\n\tUS_Startup ();\r\n\r\n//\tUS_UpdateTextScreen();\r\n\r\n\tCA_Startup ();\r\n\tUS_Setup ();\r\n\r\n//\r\n// load in and lock down some basic chunks\r\n//\r\n\r\n\tCA_ClearMarks ();\r\n\r\n\tCA_MarkGrChunk(STARTFONT);\r\n\tCA_MarkGrChunk(STARTFONTM);\r\n\tCA_MarkGrChunk(STARTTILE8);\r\n\tCA_MarkGrChunk(STARTTILE8M);\r\n\tfor (i=KEEN_LUMP_START;i<=KEEN_LUMP_END;i++)\r\n\t\tCA_MarkGrChunk(i);\r\n\r\n\tCA_CacheMarks (NULL, 0);\r\n\r\n\tMM_SetLock (&grsegs[STARTFONT],true);\r\n\tMM_SetLock (&grsegs[STARTFONTM],true);\r\n\tMM_SetLock (&grsegs[STARTTILE8],true);\r\n\tMM_SetLock (&grsegs[STARTTILE8M],true);\r\n\tfor (i=KEEN_LUMP_START;i<=KEEN_LUMP_END;i++)\r\n\t\tMM_SetLock (&grsegs[i],true);\r\n\r\n\tCA_LoadAllSounds ();\r\n\r\n\tfontcolor = WHITE;\r\n\r\n\tUS_FinishTextScreen();\r\n\r\n\tVW_SetScreenMode (GRMODE);\r\n\tVW_ClearVideo (BLACK);\r\n}\r\n\r\n\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= main\r\n=\r\n==========================\r\n*/\r\n\r\nvoid main (void)\r\n{\r\n\tshort i;\r\n\r\n\tif (stricmp(_argv[1], \"/VER\") == 0)\r\n\t{\r\n\t\tprintf(\"\\nKeen Dreams version 1.93  (Rev 1)\\n\");\r\n\t\tprintf(\"developed for use with 100%% IBM compatibles\\n\");\r\n\t\tprintf(\"that have 640K memory, DOS version 3.3 or later,\\n\");\r\n\t\tprintf(\"and an EGA or VGA display adapter.\\n\");\r\n\t\tprintf(\"Copyright 1991-1993 Softdisk Publishing.\\n\");\r\n\t\tprintf(\"Commander Keen is a trademark of Id Software.\\n\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\tif (stricmp(_argv[1], \"/?\") == 0)\r\n\t{\r\n\t\tprintf(\"\\nKeen Dreams version 1.93\\n\");\r\n\t\tprintf(\"Copyright 1991-1993 Softdisk Publishing.\\n\\n\");\r\n\t\tprintf(\"Commander Keen is a trademark of Id Software.\\n\");\r\n\t\tprintf(\"Type KDREAMS from the DOS prompt to run.\\n\\n\");\r\n\t\tprintf(\"KDREAMS /COMP for SVGA compatibility mode\\n\");\r\n\t\tprintf(\"KDREAMS /NODR stops program hang with the drive still on\\n\");\r\n\t\tprintf(\"KDREAMS /NOAL disables AdLib and Sound Blaster detection\\n\");\r\n\t\tprintf(\"KDREAMS /NOSB disables Sound Blaster detection\\n\");\r\n\t\tprintf(\"KDREAMS /NOJOYS ignores joystick\\n\");\r\n\t\tprintf(\"KDREAMS /NOMOUSE ignores mouse\\n\");\r\n\t\tprintf(\"KDREAMS /HIDDENCARD overrides video card detection\\n\");\r\n\t\tprintf(\"KDREAMS /VER  for version and compatibility information\\n\");\r\n\t\tprintf(\"KDREAMS /? for this help information\\n\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\ttextcolor(7);\r\n\ttextbackground(0);\r\n\r\n\tInitGame();\r\n\r\n\tDemoLoop();\t\t\t\t\t// DemoLoop calls Quit when everything is done\r\n\tQuit(\"Demo loop exited???\");\r\n}\r\n\r\n"
        },
        {
          "name": "kd_play.c",
          "type": "blob",
          "size": 39.0693359375,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n// KD_PLAY.C\r\n\r\n#include \"KD_DEF.H\"\r\n#pragma\thdrstop\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL CONSTANTS\r\n\r\n=============================================================================\r\n*/\r\n\r\n#define\tINACTIVATEDIST\t10\r\n\r\n#define MAXMOVE\t(TILEGLOBAL-17)\r\n\r\n#define NUMLUMPS\t22\r\n\r\n\r\n#define CONTROLSLUMP\t0\r\n#define KEENLUMP\t\t1\r\n#define WORLDKEENLUMP\t2\r\n#define BROCCOLUMP\t\t3\r\n#define\tTOMATLUMP       4\r\n#define\tCARROTLUMP\t\t5\r\n#define\tASPARLUMP\t\t6\r\n#define\tGRAPELUMP\t\t7\r\n#define\tTATERLUMP\t\t8\r\n#define\tCARTLUMP\t\t9\r\n#define\tFRENCHYLUMP\t\t10\r\n#define\tMELONLUMP\t\t11\r\n#define\tSQUASHLUMP\t\t12\r\n#define\tAPELLUMP\t\t13\r\n#define\tPEALUMP\t\t\t14\r\n#define\tBOOBUSLUMP\t\t15\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t GLOBAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\nexittype\tplaystate;\r\ngametype\tgamestate;\r\n\r\nboolean\t\tbutton0held,button1held;\r\nobjtype\t\t*new,*check,*player,*scoreobj;\r\n\r\nunsigned\toriginxtilemax,originytilemax;\r\n\r\nControlInfo\tc;\r\n\r\nobjtype dummyobj;\r\n\r\nchar\t\t*levelnames[21] =\r\n{\r\n\"The Land of Tuberia\",\r\n\"Horseradish Hill\",\r\n\"The Melon Mines\",\r\n\"Bridge Bottoms\",\r\n\"Rhubarb Rapids\",\r\n\"Parsnip Pass\",\r\n\"Level 6\",\r\n\"Spud City\",\r\n\"Level 8\",\r\n\"Apple Acres\",\r\n\"Grape Grove\",\r\n\"Level 11\",\r\n\"Brussels Sprout Bay\",\r\n\"Level 13\",\r\n\"Squash Swamp\",\r\n\"Boobus' Chamber\",\r\n\"Castle Tuberia\",\r\n\"\",\r\n\"Title Page\"\r\n};\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\t\t LOCAL VARIABLES\r\n\r\n=============================================================================\r\n*/\r\n\r\n// for asm scaning of map planes\r\nunsigned\tmapx,mapy,mapxcount,mapycount,maptile,mapspot;\r\n\r\nint\t\t\tplummet;\r\n\r\nint\t\t\tobjectcount;\r\n\r\nobjtype\t\tobjarray[MAXACTORS],*lastobj,*objfreelist;\r\n\r\nint\t\t\toldtileleft,oldtiletop,oldtileright,oldtilebottom,oldtilemidx;\r\nint\t\t\toldleft,oldtop,oldright,oldbottom,oldmidx;\r\nint\t\t\tleftmoved,topmoved,rightmoved,bottommoved,midxmoved;\r\n\r\nint\t\t\ttopmove,bottommove,midxmove;\r\n\r\nint\t\t\tinactivateleft,inactivateright,inactivatetop,inactivatebottom;\r\n\r\nint\t\t\tfadecount;\r\n\r\nboolean\t\tbombspresent;\r\n\r\nboolean\t\tlumpneeded[NUMLUMPS];\r\nint\t\t\tlumpstart[NUMLUMPS] =\r\n{\r\nCONTROLS_LUMP_START,\r\nKEEN_LUMP_START,\r\nWORLDKEEN_LUMP_START,\r\nBROCCOLASH_LUMP_START,\r\nTOMATO_LUMP_START,\r\nCARROT_LUMP_START,\r\nASPAR_LUMP_START,\r\nGRAPE_LUMP_START,\r\nTATER_LUMP_START,\r\nCANTA_LUMP_START,\r\nFRENCHY_LUMP_START,\r\nMELONLIPS_LUMP_START,\r\nSQUASHER_LUMP_START,\r\nAPEL_LUMP_START,\r\nPEAS_LUMP_START,\r\nBOOBUS_LUMP_START,\r\n};\r\n\r\nint\t\t\tlumpend[NUMLUMPS] =\r\n{\r\nCONTROLS_LUMP_END,\r\nKEEN_LUMP_END,\r\nWORLDKEEN_LUMP_END,\r\nBROCCOLASH_LUMP_END,\r\nTOMATO_LUMP_END,\r\nCARROT_LUMP_END,\r\nASPAR_LUMP_END,\r\nGRAPE_LUMP_END,\r\nTATER_LUMP_END,\r\nCANTA_LUMP_END,\r\nFRENCHY_LUMP_END,\r\nMELONLIPS_LUMP_END,\r\nSQUASHER_LUMP_END,\r\nAPEL_LUMP_END,\r\nPEAS_LUMP_END,\r\nBOOBUS_LUMP_END,\r\n};\r\n\r\n\r\nvoid\tCheckKeys (void);\r\nvoid\tCalcInactivate (void);\r\nvoid \tInitObjArray (void);\r\nvoid \tGetNewObj (boolean usedummy);\r\nvoid\tRemoveObj (objtype *gone);\r\nvoid \tScanInfoPlane (void);\r\nvoid \tPatchWorldMap (void);\r\nvoid \tMarkTileGraphics (void);\r\nvoid \tFadeAndUnhook (void);\r\nvoid \tSetupGameLevel (boolean loadnow);\r\nvoid \tScrollScreen (void);\r\nvoid \tMoveObjVert (objtype *ob, int ymove);\r\nvoid \tMoveObjHoriz (objtype *ob, int xmove);\r\nvoid \tGivePoints (unsigned points);\r\nvoid \tClipToEnds (objtype *ob);\r\nvoid \tClipToEastWalls (objtype *ob);\r\nvoid \tClipToWestWalls (objtype *ob);\r\nvoid \tClipToWalls (objtype *ob);\r\nvoid \tClipToSpriteSide (objtype *push, objtype *solid);\r\nvoid \tClipToSprite (objtype *push, objtype *solid, boolean squish);\r\nint \tDoActor (objtype *ob,int tics);\r\nvoid \tStateMachine (objtype *ob);\r\nvoid \tNewState (objtype *ob,statetype *state);\r\nvoid \tPlayLoop (void);\r\nvoid \tGameLoop (void);\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=====================\r\n=\r\n= CheckKeys\r\n=\r\n=====================\r\n*/\r\n\r\nvoid CheckKeys (void)\r\n{\r\n\tif (screenfaded)\t\t\t// don't do anything with a faded screen\r\n\t\treturn;\r\n\r\n//\r\n// space for status screen\r\n//\r\n\tif (Keyboard[sc_Space])\r\n\t{\r\n\t\tStatusWindow ();\r\n\t\tIN_ClearKeysDown();\r\n\t\tRF_ForceRefresh();\r\n\t\tlasttimecount = TimeCount;\r\n\t}\r\n\r\n//\r\n// pause key wierdness can't be checked as a scan code\r\n//\r\n\tif (Paused)\r\n\t{\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow (8,3);\r\n\t\tUS_PrintCentered (\"PAUSED\");\r\n\t\tVW_UpdateScreen ();\r\n\t\tIN_Ack();\r\n\t\tRF_ForceRefresh ();\r\n\t\tPaused = false;\r\n\t}\r\n\r\n//\r\n// F1-F7/ESC to enter control panel\r\n//\r\n\tif ( (LastScan >= sc_F1 && LastScan <= sc_F7) || LastScan == sc_Escape)\r\n\t{\r\n\t\tVW_FixRefreshBuffer ();\r\n\t\tUS_CenterWindow (20,8);\r\n\t\tUS_CPrint (\"Loading\");\r\n\t\tVW_UpdateScreen ();\r\n\t\tUS_ControlPanel();\r\n\t\tIN_ClearKeysDown();\r\n\t\tif (restartgame)\r\n\t\t\tplaystate = resetgame;\r\n\t\telse if (!loadedgame)\r\n\t\t\tRF_ForceRefresh();\t\t// don't refresh if loading a new game\r\n\r\n\t\tlasttimecount = TimeCount;\r\n\t}\r\n\r\n//\r\n// F10-? debug keys\r\n//\r\n\tif (Keyboard[sc_F10] && DebugKeys() )\r\n\t{\r\n\t\tRF_ForceRefresh();\r\n\t\tlasttimecount = TimeCount;\r\n\t}\r\n\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n=======================\r\n=\r\n= CalcInactivate\r\n=\r\n=======================\r\n*/\r\n\r\nvoid CalcInactivate (void)\r\n{\r\n\toriginxtilemax = originxtile+PORTTILESWIDE-1;\r\n\toriginytilemax = originytile+PORTTILESHIGH-1;\r\n\r\n\tinactivateleft = originxtile-INACTIVATEDIST;\r\n\tif (inactivateleft < 0)\r\n\t\tinactivateleft = 0;\r\n\tinactivateright = originxtilemax+INACTIVATEDIST;\r\n\tinactivatetop = originytile-INACTIVATEDIST;\r\n\tif (inactivatetop < 0)\r\n\t\tinactivatetop = 0;\r\n\tinactivatebottom = originytilemax+INACTIVATEDIST;\r\n}\r\n\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n#############################################################################\r\n\r\n\t\t\t\t  The objarray data structure\r\n\r\n#############################################################################\r\n\r\nObjarray containt structures for every actor currently playing.  The structure\r\nis accessed as a linked list starting at *player, ending when ob->next ==\r\nNULL.  GetNewObj inserts a new object at the end of the list, meaning that\r\nif an actor spawn another actor, the new one WILL get to think and react the\r\nsame frame.  RemoveObj unlinks the given object and returns it to the free\r\nlist, but does not damage the objects ->next pointer, so if the current object\r\nremoves itself, a linked list following loop can still safely get to the\r\nnext element.\r\n\r\n<backwardly linked free list>\r\n\r\n#############################################################################\r\n*/\r\n\r\n\r\n/*\r\n=========================\r\n=\r\n= InitObjArray\r\n=\r\n= Call to clear out the entire object list, returning them all to the free\r\n= list.  Allocates a special spot for the player.\r\n=\r\n=========================\r\n*/\r\n\r\nvoid InitObjArray (void)\r\n{\r\n\tint\ti;\r\n\r\n\tfor (i=0;i<MAXACTORS;i++)\r\n\t{\r\n\t\tobjarray[i].prev = &objarray[i+1];\r\n\t\tobjarray[i].next = NULL;\r\n\t}\r\n\r\n\tobjarray[MAXACTORS-1].prev = NULL;\r\n\r\n\tobjfreelist = &objarray[0];\r\n\tlastobj = NULL;\r\n\r\n\tobjectcount = 0;\r\n\r\n//\r\n// give the player and score the first free spots\r\n//\r\n\tGetNewObj (false);\r\n\tplayer = new;\r\n\tGetNewObj (false);\r\n\tscoreobj = new;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=========================\r\n=\r\n= GetNewObj\r\n=\r\n= Sets the global variable new to point to a free spot in objarray.\r\n= The free spot is inserted at the end of the liked list\r\n=\r\n= When the object list is full, the caller can either have it bomb out ot\r\n= return a dummy object pointer that will never get used\r\n=\r\n=========================\r\n*/\r\n\r\nvoid GetNewObj (boolean usedummy)\r\n{\r\n\tif (!objfreelist)\r\n\t{\r\n\t\tif (usedummy)\r\n\t\t{\r\n\t\t\tnew = &dummyobj;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tQuit (\"GetNewObj: No free spots in objarray!\");\r\n\t}\r\n\r\n\tnew = objfreelist;\r\n\tobjfreelist = new->prev;\r\n\tmemset (new,0,sizeof(*new));\r\n\r\n\tif (lastobj)\r\n\t\tlastobj->next = new;\r\n\tnew->prev = lastobj;\t// new->next is allready NULL from memset\r\n\r\n\tnew->active = yes;\r\n\tnew->needtoclip = true;\r\n\tlastobj = new;\r\n\r\n\tobjectcount++;\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n=========================\r\n=\r\n= RemoveObj\r\n=\r\n= Add the given object back into the free list, and unlink it from it's\r\n= neighbors\r\n=\r\n=========================\r\n*/\r\n\r\nvoid RemoveObj (objtype *gone)\r\n{\r\n\tif (gone == player)\r\n\t\tQuit (\"RemoveObj: Tried to remove the player!\");\r\n\r\n//\r\n// erase it from the refresh manager\r\n//\r\n\tRF_RemoveSprite (&gone->sprite);\r\n\r\n//\r\n// fix the next object's back link\r\n//\r\n\tif (gone == lastobj)\r\n\t\tlastobj = (objtype *)gone->prev;\r\n\telse\r\n\t\tgone->next->prev = gone->prev;\r\n\r\n//\r\n// fix the previous object's forward link\r\n//\r\n\tgone->prev->next = gone->next;\r\n\r\n//\r\n// add it back in to the free list\r\n//\r\n\tgone->prev = objfreelist;\r\n\tobjfreelist = gone;\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\nvoid near HandleInfo (void)\r\n{\r\n\tswitch (maptile)\r\n\t{\r\n\tcase 1:\r\n\t\tSpawnKeen(mapx,mapy,1);\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tSpawnKeen(mapx,mapy,-1);\r\n\t\tbreak;\r\n\tcase 19:\r\n\t\tSpawnWorldKeen(mapx,mapy);\r\n\t\tlumpneeded[WORLDKEENLUMP] = true;\r\n\t\tbreak;\r\n\r\n\tcase 31:\r\n\t\tbombspresent = true;\r\n\tcase 21:\r\n\tcase 22:\r\n\tcase 23:\r\n\tcase 24:\r\n\tcase 25:\r\n\tcase 26:\r\n\tcase 27:\r\n\tcase 28:\r\n\tcase 29:\r\n\tcase 30:\r\n\tcase 32:\r\n\t\tSpawnBonus(mapx,mapy,maptile-21);\r\n\t\tnew->active = false;\r\n\t\tbreak;\r\n\tcase 33:\r\n\t\tSpawnDoor(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tbreak;\r\n\tcase 41:\r\n\t\tSpawnBrocco(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[BROCCOLUMP] = true;\r\n\t\tbreak;\r\n\tcase 42:\r\n\t\tSpawnTomat(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[TOMATLUMP] = true;\r\n\t\tbreak;\r\n\tcase 43:\r\n\t\tSpawnCarrot(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[CARROTLUMP] = true;\r\n\t\tbreak;\r\n\tcase 45:\r\n\t\tSpawnAspar(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[ASPARLUMP] = true;\r\n\t\tbreak;\r\n\tcase 46:\r\n\t\tSpawnGrape(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[GRAPELUMP] = true;\r\n\t\tbreak;\r\n\tcase 47:\r\n\t\tSpawnTater(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[TATERLUMP] = true;\r\n\t\tbreak;\r\n\tcase 48:\r\n\t\tSpawnCart(mapx,mapy);\r\n\t\tlumpneeded[CARTLUMP] = true;\r\n\t\tbreak;\r\n\tcase 49:\r\n\t\tSpawnFrenchy(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[FRENCHYLUMP] = true;\r\n\t\tbreak;\r\n\tcase 50:\r\n\tcase 51:\r\n\tcase 52:\r\n\t\tSpawnMelon(mapx,mapy,maptile-50);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[MELONLUMP] = true;\r\n\t\tbreak;\r\n\tcase 57:\r\n\t\tSpawnSquasher(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[SQUASHLUMP] = true;\r\n\t\tbreak;\r\n\tcase 58:\r\n\t\tSpawnApel(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[APELLUMP] = true;\r\n\t\tbreak;\r\n\tcase 59:\r\n\t\tSpawnPeaPod(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[PEALUMP] = true;\r\n\t\tbreak;\r\n\tcase 60:\r\n\t\tSpawnPeaBrain(mapx,mapy);\r\n\t\tnew->active = false;\r\n\t\tlumpneeded[PEALUMP] = true;\r\n\t\tbreak;\r\n\tcase 61:\r\n\t\tSpawnBoobus(mapx,mapy);\r\n\t\tlumpneeded[BOOBUSLUMP] = true;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (new->active != allways)\r\n\t\tnew->active = false;\r\n}\r\n\r\n/*\r\n==========================\r\n=\r\n= ScanInfoPlane\r\n=\r\n= Spawn all actors and mark down special places\r\n=\r\n==========================\r\n*/\r\n\r\nvoid ScanInfoPlane (void)\r\n{\r\n\tunsigned\tx,y,i,j;\r\n\tint\t\t\ttile;\r\n\tunsigned\tfar\t*start;\r\n\r\n\tInitObjArray();\t\t\t// start spawning things with a clean slate\r\n\r\n\tmemset (lumpneeded,0,sizeof(lumpneeded));\r\n\r\n#if 0\r\n\tstart = mapsegs[2];\r\n\tfor (y=0;y<mapheight;y++)\r\n\t\tfor (x=0;x<mapwidth;x++)\r\n\t\t{\r\n\t\t\ttile = *start++;\r\n\t\t\tif (!tile)\r\n\t\t\t\tcontinue;\r\n\t\t}\r\n#endif\r\n\r\n//\r\n// This doesn't really need to be in asm.  I thought it was a bottleneck,\r\n// but I was wrong...\r\n//\r\n\r\n\tasm\tmov\tes,[WORD PTR mapsegs+4]\r\n\tasm\txor\tsi,si\r\n\tasm\tmov\t[mapy],0\r\n\tasm\tmov\tax,[mapheight]\r\n\tasm\tmov\t[mapycount],ax\r\nyloop:\r\n\tasm\tmov\t[mapx],0\r\n\tasm\tmov\tax,[mapwidth]\r\n\tasm\tmov\t[mapxcount],ax\r\nxloop:\r\n\tasm\tmov\tax,[es:si]\r\n\tasm\tor\tax,ax\r\n\tasm\tjz\tnothing\r\n\tasm\tmov\t[maptile],ax\r\n\tHandleInfo ();\t\t\t\t\t\t// si is saved\r\n\tasm\tmov\tes,[WORD PTR mapsegs+4]\r\nnothing:\r\n\tasm\tinc\t[mapx]\r\n\tasm\tadd\tsi,2\r\n\tasm\tdec\t[mapxcount]\r\n\tasm\tjnz\txloop\r\n\tasm\tinc\t[mapy]\r\n\tasm\tdec\t[mapycount]\r\n\tasm\tjnz\tyloop\r\n\r\n\tfor (i=0;i<NUMLUMPS;i++)\r\n\t\tif (lumpneeded[i])\r\n\t\t\tfor (j=lumpstart[i];j<=lumpend[i];j++)\r\n\t\t\t\tCA_MarkGrChunk(j);\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= PatchWorldMap\r\n=\r\n= Takes out blocking squares and puts in dones\r\n=\r\n==========================\r\n*/\r\n\r\nvoid PatchWorldMap (void)\r\n{\r\n\tunsigned\tsize,spot,info,foreground;\r\n\r\n\tsize = mapwidth*mapheight;\r\n\tspot = 0;\r\n\tdo\r\n\t{\r\n\t\tinfo = *(mapsegs[2] + spot);\r\n\t\t// finished a city here?\r\n\t\tif (info>=3 && info<=18 && gamestate.leveldone[info-2])\r\n\t\t{\r\n\t\t\t*(mapsegs[2] + spot) = 0;\r\n\t\t\tforeground = *(mapsegs[1] + spot);\r\n\t\t\tif (foreground == 130)\r\n\t\t\t\t*(mapsegs[1]+spot) = 0;\t// not blocking now\r\n\t\t\telse if (foreground == 90)\r\n\t\t\t{\r\n\t\t\t// plant done flag\r\n\t\t\t\t*(mapsegs[1]+spot) = 133;\r\n\t\t\t\t*(mapsegs[1]+(spot-mapwidth-1)) = 131;\r\n\t\t\t\t*(mapsegs[1]+(spot-mapwidth)) = 132;\r\n\t\t\t}\r\n\t\t}\r\n\t\tspot++;\r\n\t} while (spot<size);\r\n}\r\n\r\n//===========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= FadeAndUnhook\r\n=\r\n= Latch this onto the refresh so the screen only gets faded in after two\r\n= refreshes.  This lets all actors draw themselves to both pages before\r\n= fading the screen in.\r\n=\r\n==========================\r\n*/\r\n\r\nvoid FadeAndUnhook (void)\r\n{\r\n\tif (++fadecount==2)\r\n\t{\r\n\t\tRF_ForceRefresh();\r\n\t\tVW_FadeIn ();\r\n\t\tRF_SetRefreshHook (NULL);\r\n\t\tlasttimecount = TimeCount;\t// don't adaptively time the fade\r\n\t}\r\n}\r\n\r\n//===========================================================================\r\n\r\n\r\n/*\r\n==========================\r\n=\r\n= SetupGameLevel\r\n=\r\n= Load in map mapon and cache everything needed for it\r\n=\r\n==========================\r\n*/\r\n\r\nvoid \tSetupGameLevel (boolean loadnow)\r\n{\r\n\tlong\torgx,orgy;\r\n\r\n\tbombspresent = false;\r\n//\r\n// load the level header and three map planes\r\n//\r\n\tCA_CacheMap (gamestate.mapon);\r\n\r\n//\r\n// let the refresh manager set up some variables\r\n//\r\n\tRF_NewMap ();\r\n\r\n//\r\n// decide which graphics are needed and spawn actors\r\n//\r\n\tCA_ClearMarks ();\r\n\r\n\tif (!mapon)\r\n\t\tPatchWorldMap ();\r\n\r\n\tif (mapon!=20)\t\t\t// map 20 is the title screen\r\n\t\tScanInfoPlane ();\r\n\tRF_MarkTileGraphics ();\r\n\r\n//\r\n// have the caching manager load and purge stuff to make sure all marks\r\n// are in memory\r\n//\r\n\tif (loadnow)\r\n\t{\r\n\t\tif (bombspresent)\r\n\t\t{\r\n\t\t\tVW_FixRefreshBuffer ();\r\n\t\t\tUS_DrawWindow (10,1,20,2);\r\n\t\t\tUS_PrintCentered (\"Boobus Bombs Near!\");\r\n\t\t\tVW_UpdateScreen ();\r\n\t\t}\r\n\t\tCA_CacheMarks (levelnames[mapon], 0);\r\n\t}\r\n\r\n#if 0\r\n\tVW_FixRefreshBuffer ();\r\n\tUS_CenterWindow (20,8);\r\n\tUS_Print (\"\\n\\n\\nObject count:\");\r\n\titoa (objectcount,str,10);\r\n\tUS_Print (str);\r\n\tVW_UpdateScreen ();\r\n\tIN_Ack ();\r\n#endif\r\n\r\n\tif (mapon!=20 && loadnow)\t\t\t// map 20 is the title screen\r\n\t{\r\n\t\tVW_FadeOut ();\r\n\t\tfadecount = 0;\r\n\t\tRF_SetRefreshHook (&FadeAndUnhook);\r\n\t\tSpawnScore ();\r\n\r\n//\r\n// start the initial view position to center the player\r\n//\r\n\t\torgx = (long)player->x - (150<<G_P_SHIFT);\r\n\t\torgy = (long)player->y-(84<<G_P_SHIFT);\r\n\t\tif (orgx<0)\r\n\t\t\torgx=0;\r\n\t\tif (orgy<0)\r\n\t\t\torgy=0;\r\n\r\n\t\tRF_NewPosition (orgx,orgy);\r\n\t\tCalcInactivate ();\r\n\t}\r\n\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n===============\r\n=\r\n= ScrollScreen\r\n=\r\n= Scroll if Keen is nearing an edge\r\n= Set playstate to levelcomplete\r\n=\r\n===============\r\n*/\r\n\r\nvoid ScrollScreen (void)\r\n{\r\n\tint\txscroll,yscroll;\r\n\r\n//\r\n// walked off edge of map?\r\n//\r\n\tif (player->left < originxmin\r\n\t|| player->right > originxmax+20*TILEGLOBAL)\r\n\t{\r\n\t\tplaystate = levelcomplete;\r\n\t\treturn;\r\n\t}\r\n\r\n//\r\n// fallen off bottom of world?\r\n//\r\n\tif (!plummet && player->bottom > originymax+13*TILEGLOBAL)\r\n\t{\r\n\t\tgodmode = 0;\r\n\t\tplummet = 1;\r\n\t\tKillKeen ();\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (player->x < originxglobal+SCROLLWEST)\r\n\t\txscroll = player->x - (originxglobal+SCROLLWEST);\r\n\telse if (player->x > originxglobal+SCROLLEAST)\r\n\t\txscroll = player->x - (originxglobal+SCROLLEAST);\r\n\telse\r\n\t\txscroll = 0;\r\n\r\n\tif (player->y < originyglobal+SCROLLNORTH)\r\n\t\tyscroll = player->y - (originyglobal+SCROLLNORTH);\r\n\telse if (player->y > originyglobal+SCROLLSOUTH)\r\n\t\tyscroll = player->y - (originyglobal+SCROLLSOUTH);\r\n\telse yscroll = 0;\r\n\r\n\tif (xscroll || yscroll)\r\n\t{\r\n\t\tRF_Scroll (xscroll,yscroll);\r\n\t\tCalcInactivate ();\r\n\t\tscoreobj->needtoreact = true;\r\n\t}\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= GivePoints\r\n=\r\n= Grants extra men at 20k,40k,80k,160k,320k\r\n=\r\n====================\r\n*/\r\n\r\nvoid GivePoints (unsigned points)\r\n{\r\n\tgamestate.score += points;\r\n\tif (gamestate.score >= gamestate.nextextra)\r\n\t{\r\n\t\tSD_PlaySound (EXTRAKEENSND);\r\n\t\tgamestate.lives++;\r\n\t\tgamestate.nextextra*=2;\r\n\t}\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n====================\r\n=\r\n= MoveObjVert\r\n=\r\n====================\r\n*/\r\n\r\nvoid MoveObjVert (objtype *ob, int ymove)\r\n{\r\n\tob->y += ymove;\r\n\tob->top += ymove;\r\n\tob->bottom += ymove;\r\n\tob->tiletop = ob->top >> G_T_SHIFT;\r\n\tob->tilebottom = ob->bottom >> G_T_SHIFT;\r\n}\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= MoveObjHoriz\r\n=\r\n====================\r\n*/\r\n\r\nvoid MoveObjHoriz (objtype *ob, int xmove)\r\n{\r\n\tob->x += xmove;\r\n\tob->left += xmove;\r\n\tob->right += xmove;\r\n\tob->tileleft = ob->left >> G_T_SHIFT;\r\n\tob->tileright = ob->right >> G_T_SHIFT;\r\n}\r\n\r\n\r\n/*\r\n=============================================================================\r\n\r\n\t\t\t\t\tActor to tile clipping rouitnes\r\n\r\n=============================================================================\r\n*/\r\n\r\n// walltype / x coordinate (0-15)\r\n\r\nint\twallclip[8][16] = {\t\t\t// the height of a given point in a tile\r\n{ 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 256},\r\n{   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0},\r\n{   0,0x08,0x10,0x18,0x20,0x28,0x30,0x38,0x40,0x48,0x50,0x58,0x60,0x68,0x70,0x78},\r\n{0x80,0x88,0x90,0x98,0xa0,0xa8,0xb0,0xb8,0xc0,0xc8,0xd0,0xd8,0xe0,0xe8,0xf0,0xf8},\r\n{   0,0x10,0x20,0x30,0x40,0x50,0x60,0x70,0x80,0x90,0xa0,0xb0,0xc0,0xd0,0xe0,0xf0},\r\n{0x78,0x70,0x68,0x60,0x58,0x50,0x48,0x40,0x38,0x30,0x28,0x20,0x18,0x10,0x08,   0},\r\n{0xf8,0xf0,0xe8,0xe0,0xd8,0xd0,0xc8,0xc0,0xb8,0xb0,0xa8,0xa0,0x98,0x90,0x88,0x80},\r\n{0xf0,0xe0,0xd0,0xc0,0xb0,0xa0,0x90,0x80,0x70,0x60,0x50,0x40,0x30,0x20,0x10,   0}\r\n};\r\n\r\n// assignment within ifs are used heavily here, so turn off the warning\r\n#pragma warn -pia\r\n\r\n/*\r\n===========================\r\n=\r\n= ClipToEnds\r\n=\r\n===========================\r\n*/\r\n\r\nvoid ClipToEnds (objtype *ob)\r\n{\r\n\tunsigned\tfar *map,tile,facetile,info,wall;\r\n\tint\tleftpix,rightpix,midtiles,toppix,bottompix;\r\n\tint\tx,y,clip,move,totalmove,maxmove,midxpix;\r\n\r\n\tmidxpix = (ob->midx&0xf0) >> 4;\r\n\r\n\tmaxmove = -abs(midxmoved) - bottommoved - 16;\r\n\tmap = (unsigned far *)mapsegs[1] +\r\n\t\tmapbwidthtable[oldtilebottom-1]/2 + ob->tilemidx;\r\n\tfor (y=oldtilebottom-1 ; y<=ob->tilebottom ; y++,map+=mapwidth)\r\n\t{\r\n\t\tif (wall = tinf[NORTHWALL+*map])\r\n\t\t{\r\n\t\t\tclip = wallclip[wall&7][midxpix];\r\n\t\t\tmove = ( (y<<G_T_SHIFT)+clip - 1) - ob->bottom;\r\n\t\t\tif (move<0 && move>=maxmove)\r\n\t\t\t{\r\n\t\t\t\tob->hitnorth = wall;\r\n\t\t\t\tMoveObjVert (ob,move);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tmaxmove = abs(midxmoved) - topmoved + 16;\r\n\tmap = (unsigned far *)mapsegs[1] +\r\n\t\tmapbwidthtable[oldtiletop+1]/2 + ob->tilemidx;\r\n\tfor (y=oldtiletop+1 ; y>=ob->tiletop ; y--,map-=mapwidth)\r\n\t{\r\n\t\tif (wall = tinf[SOUTHWALL+*map])\r\n\t\t{\r\n\t\t\tclip = wallclip[wall&7][midxpix];\r\n\t\t\tmove = ( ((y+1)<<G_T_SHIFT)-clip ) - ob->top;\r\n\t\t\tif (move > 0 && move<=maxmove)\r\n\t\t\t{\r\n\t\t\t\ttotalmove = ob->ymove + move;\r\n\t\t\t\tif (totalmove < TILEGLOBAL && totalmove > -TILEGLOBAL)\r\n\t\t\t\t{\r\n\t\t\t\t\tob->hitsouth = wall;\r\n\t\t\t\t\tMoveObjVert (ob,move);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/*\r\n===========================\r\n=\r\n= ClipToEastWalls / ClipToWestWalls\r\n=\r\n===========================\r\n*/\r\n\r\nvoid ClipToEastWalls (objtype *ob)\r\n{\r\n\tint\t\t\ty,move,top,bottom;\r\n\tunsigned\tfar *map,tile,info,wall;\r\n\r\n\t// clip to east walls if moving west\r\n\r\n\ttop = ob->tiletop;\r\n\tif (ob->hitsouth>1)\r\n\t\ttop++;\t\t\t// on a slope inside a tile\r\n\tbottom = ob->tilebottom;\r\n\tif (ob->hitnorth>1)\r\n\t\tbottom--;\t\t\t// on a slope inside a tile\r\n\r\n\tfor (y=top;y<=bottom;y++)\r\n\t{\r\n\t\tmap = (unsigned far *)mapsegs[1] +\r\n\t\t\tmapbwidthtable[y]/2 + ob->tileleft;\r\n\r\n\t\tif (ob->hiteast = tinf[EASTWALL+*map])\r\n\t\t{\r\n\t\t\tmove = ( (ob->tileleft+1)<<G_T_SHIFT ) - ob->left;\r\n\t\t\tMoveObjHoriz (ob,move);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nvoid ClipToWestWalls (objtype *ob)\r\n{\r\n\tint\t\t\ty,move,top,bottom;\r\n\tunsigned\tfar *map,tile,info,wall;\r\n\r\n\t// check west walls if moving east\r\n\r\n\ttop = ob->tiletop;\r\n\tif (ob->hitsouth>1)\r\n\t\ttop++;\t\t\t// on a slope inside a tile\r\n\tbottom = ob->tilebottom;\r\n\tif (ob->hitnorth>1)\r\n\t\tbottom--;\t\t\t// on a slope inside a tile\r\n\r\n\tfor (y=top;y<=bottom;y++)\r\n\t{\r\n\t\tmap = (unsigned far *)mapsegs[1] +\r\n\t\t\tmapbwidthtable[y]/2 + ob->tileright;\r\n\r\n\t\tif (ob->hitwest = tinf[WESTWALL+*map])\r\n\t\t{\r\n\t\t\tmove = ( (ob->tileright<<G_T_SHIFT ) -1) - ob->right;\r\n\t\t\tMoveObjHoriz (ob,move);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// turn 'possibly incorrect assignment' warnings back on\r\n#pragma warn +pia\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n================\r\n=\r\n= ClipToWalls\r\n=\r\n= Moves the current object xmove/ymove units, clipping to walls\r\n=\r\n================\r\n*/\r\n\r\nvoid ClipToWalls (objtype *ob)\r\n{\r\n\tunsigned\tx,y,tile;\r\n\tspritetabletype\tfar *shape;\r\n\tboolean\tendfirst;\r\n\r\n//\r\n// make sure it stays in contact with a 45 degree slope\r\n//\r\n\tif (ob->state->pushtofloor)\r\n\t{\r\n\t\tif (ob->xmove > 0)\r\n\t\t\tob->ymove = ob->xmove + 16;\r\n\t\telse\r\n\t\t\tob->ymove = -ob->xmove + 16;\r\n\t}\r\n\r\n//\r\n// move the shape\r\n//\r\n\tif (ob->xmove > MAXMOVE)\r\n\t\tob->xmove = MAXMOVE;\r\n\telse if (ob->xmove < -MAXMOVE)\r\n\t\tob->xmove = -MAXMOVE;\r\n\r\n\tif (ob->ymove > MAXMOVE+16)\t\t\t// +16 for push to floor\r\n\t\tob->ymove = MAXMOVE+16;\r\n\telse if (ob->ymove < -MAXMOVE)\r\n\t\tob->ymove = -MAXMOVE;\r\n\r\n\tob->x += ob->xmove;\r\n\tob->y += ob->ymove;\r\n\r\n\tob->needtoreact = true;\r\n\r\n\tif (!ob->shapenum)\t\t\t\t// can't get a hit rect with no shape!\r\n\t\treturn;\r\n\r\n\tshape = &spritetable[ob->shapenum-STARTSPRITES];\r\n\r\n\toldtileright = ob->tileright;\r\n\toldtiletop = ob->tiletop;\r\n\toldtileleft = ob->tileleft;\r\n\toldtilebottom = ob->tilebottom;\r\n\toldtilemidx = ob->tilemidx;\r\n\r\n\toldright = ob->right;\r\n\toldtop = ob->top;\r\n\toldleft = ob->left;\r\n\toldbottom = ob->bottom;\r\n\toldmidx = ob->midx;\r\n\r\n\tob->left = ob->x + shape->xl;\r\n\tob->right = ob->x + shape->xh;\r\n\tob->top = ob->y + shape->yl;\r\n\tob->bottom = ob->y + shape->yh;\r\n\tob->midx = ob->left + (ob->right - ob->left)/2;\r\n\r\n\tob->tileleft = ob->left >> G_T_SHIFT;\r\n\tob->tileright = ob->right >> G_T_SHIFT;\r\n\tob->tiletop = ob->top >> G_T_SHIFT;\r\n\tob->tilebottom = ob->bottom >> G_T_SHIFT;\r\n\tob->tilemidx = ob->midx >> G_T_SHIFT;\r\n\r\n\tob->hitnorth = ob->hiteast = ob->hitsouth = ob->hitwest = 0;\r\n\r\n\tif (!ob->needtoclip)\r\n\t\treturn;\r\n\r\n\tleftmoved = ob->left - oldleft;\r\n\trightmoved = ob->right - oldright;\r\n\ttopmoved = ob->top - oldtop;\r\n\tbottommoved = ob->bottom - oldbottom;\r\n\tmidxmoved = ob->midx - oldmidx;\r\n\r\n//\r\n// clip it\r\n//\r\n\r\n\tClipToEnds(ob);\r\n\r\n\tif (leftmoved < 0 || ob == player)\t// make sure player gets cliped\r\n\t\tClipToEastWalls (ob);\r\n\tif (rightmoved > 0 || ob == player)\r\n\t\tClipToWestWalls (ob);\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= ClipToSpriteSide\r\n=\r\n= Clips push to solid\r\n=\r\n==================\r\n*/\r\n\r\nvoid ClipToSpriteSide (objtype *push, objtype *solid)\r\n{\r\n\tint xmove,leftinto,rightinto;\r\n\r\n\t//\r\n\t// amount the push shape can be pushed\r\n\t//\r\n\txmove = solid->xmove - push->xmove;\r\n\r\n\t//\r\n\t// amount it is inside\r\n\t//\r\n\tleftinto = solid->right - push->left;\r\n\trightinto = push->right - solid->left;\r\n\r\n\tif (leftinto>0 && leftinto<= xmove)\r\n\t{\r\n\t\tpush->xmove = leftinto;\r\n\t\tif (push->state->pushtofloor)\r\n\t\t\tpush->ymove = leftinto+16;\r\n\t\tClipToWalls (push);\r\n\t\tpush->hiteast = 1;\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (rightinto>0 && rightinto<= -xmove)\r\n\t{\r\n\t\tpush->xmove = -rightinto;\r\n\t\tif (push->state->pushtofloor)\r\n\t\t\tpush->ymove = rightinto+16;\r\n\t\tClipToWalls (push);\r\n\t\tpush->hitwest = 1;\r\n\t\treturn;\r\n\t}\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= ClipToSprite\r\n=\r\n= Clips push to solid\r\n=\r\n==================\r\n*/\r\n\r\nvoid ClipToSprite (objtype *push, objtype *solid, boolean squish)\r\n{\r\n\tboolean temp;\r\n\tint walltemp,xmove,leftinto,rightinto,topinto,bottominto;\r\n\r\n\txmove = solid->xmove - push->xmove;\r\n\r\n\tpush->xmove = push->ymove = 0;\r\n\r\n\t//\r\n\t// left / right\r\n\t//\r\n\tleftinto = solid->right - push->left;\r\n\trightinto = push->right - solid->left;\r\n\r\n\tif (leftinto>0 && leftinto<=xmove)\r\n\t{\r\n\t\tpush->xmove = leftinto;\r\n\t\twalltemp = push->hitnorth;\r\n\t\tClipToWalls (push);\r\n\t\tif (!push->hitnorth)\r\n\t\t\tpush->hitnorth = walltemp;\r\n\t\tif (squish && push->hitwest)\r\n\t\t\tKillKeen ();\r\n\t\tpush->hiteast = 1;\r\n\t\treturn;\r\n\t}\r\n\telse if (rightinto>0 && rightinto<=-xmove)\r\n\t{\r\n\t\tpush->xmove = -rightinto;\r\n\t\twalltemp = push->hitnorth;\r\n\t\tClipToWalls (push);\r\n\t\tif (!push->hitnorth)\r\n\t\t\tpush->hitnorth = walltemp;\r\n\t\tif (squish && push->hiteast)\r\n\t\t\tKillKeen ();\r\n\t\tpush->hitwest = 1;\r\n\t\treturn;\r\n\t}\r\n\r\n\t//\r\n\t// top / bottom\r\n\t//\r\n\ttopinto = solid->bottom - push->top;\r\n\tbottominto = push->bottom - solid->top;\r\n\r\n\tif (bottominto>0)\r\n\t{\r\n\t\tpush->ymove = -bottominto+16;\r\n\t\tpush->xmove = solid->xmove;\r\n\t\ttemp = push->state->pushtofloor;\r\n\t\tpush->state->pushtofloor = false;\r\n\t\twalltemp = push->hitnorth;\r\n\t\tClipToWalls (push);\r\n\t\tif (!push->hitnorth)\r\n\t\t\tpush->hitnorth = walltemp;\r\n\t\tpush->state->pushtofloor = temp;\r\n\t\tpush->hitnorth = 25;\r\n\t}\r\n\telse if (topinto>0)\r\n\t{\r\n\t\tpush->ymove = topinto;\r\n\t\tClipToWalls (push);\r\n\t\tpush->hitsouth = 25;\r\n\t}\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n==================\r\n=\r\n= DoActor\r\n=\r\n= Moves an actor in its current state by a given number of tics.\r\n= If that time takes it into the next state, it changes the state\r\n= and returns the number of excess tics after the state change\r\n=\r\n==================\r\n*/\r\n\r\nint DoActor (objtype *ob,int tics)\r\n{\r\n\tint\tnewtics,movetics,excesstics;\r\n\tstatetype *state;\r\n\r\n\tstate = ob->state;\r\n\r\n\tif (state->progress == think)\r\n\t{\r\n\t\tif (state->think)\r\n\t\t{\r\n\t\t\tif (ob->nothink)\r\n\t\t\t\tob->nothink--;\r\n\t\t\telse\r\n#pragma warn -pro\r\n\t\t\t\tstate->think(ob);\r\n#pragma warn +pro\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tnewtics = ob->ticcount+tics;\r\n\r\n\tif (newtics < state->tictime || state->tictime == 0)\r\n\t{\r\n\t\tob->ticcount = newtics;\r\n\t\tif (state->progress == slide || state->progress == slidethink)\r\n\t\t{\r\n\t\t\tif (ob->xdir)\r\n\t\t\t\tob->xmove += ob->xdir == 1 ? tics*state->xmove\r\n\t\t\t\t: -tics*state->xmove;\r\n\t\t\tif (ob->ydir)\r\n\t\t\t\tob->ymove += ob->ydir == 1 ? tics*state->ymove\r\n\t\t\t\t: -tics*state->ymove;\r\n\t\t}\r\n\t\tif (state->progress == slidethink || state->progress == stepthink)\r\n\t\t{\r\n\t\t\tif (state->think)\r\n\t\t\t{\r\n\t\t\t\tif (ob->nothink)\r\n\t\t\t\t\tob->nothink--;\r\n\t\t\t\telse\r\n#pragma warn -pro\r\n\t\t\t\t\tstate->think(ob);\r\n#pragma warn +pro\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tmovetics = state->tictime - ob->ticcount;\r\n\t\texcesstics = newtics - state->tictime;\r\n\t\tob->ticcount = 0;\r\n\t\tif (state->progress == slide || state->progress == slidethink)\r\n\t\t{\r\n\t\t\tif (ob->xdir)\r\n\t\t\t\tob->xmove += ob->xdir == 1 ? movetics*state->xmove\r\n\t\t\t\t: -movetics*state->xmove;\r\n\t\t\tif (ob->ydir)\r\n\t\t\t\tob->ymove += ob->ydir == 1 ? movetics*state->ymove\r\n\t\t\t\t: -movetics*state->ymove;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (ob->xdir)\r\n\t\t\t\tob->xmove += ob->xdir == 1 ? state->xmove : -state->xmove;\r\n\t\t\tif (ob->ydir)\r\n\t\t\t\tob->ymove += ob->ydir == 1 ? state->ymove : -state->ymove;\r\n\t\t}\r\n\r\n\t\tif (state->think)\r\n\t\t{\r\n\t\t\tif (ob->nothink)\r\n\t\t\t\tob->nothink--;\r\n\t\t\telse\r\n#pragma warn -pro\r\n\t\t\t\tstate->think(ob);\r\n#pragma warn +pro\r\n\t\t}\r\n\r\n\t\tif (ob->state == state)\r\n\t\t\tob->state = state->nextstate;\t// go to next state\r\n\t\telse if (!ob->state)\r\n\t\t\treturn 0;\t\t\t// object removed itself\r\n\t\treturn excesstics;\r\n\t}\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= StateMachine\r\n=\r\n= Change state and give directions\r\n=\r\n====================\r\n*/\r\n\r\nvoid StateMachine (objtype *ob)\r\n{\r\n\tint excesstics,oldshapenum;\r\n\tstatetype *state;\r\n\r\n\tob->xmove = ob->ymove = 0;\r\n\toldshapenum = ob->shapenum;\r\n\r\n\tstate = ob->state;\r\n\r\n\texcesstics = DoActor(ob,tics);\r\n\tif (ob->state != state)\r\n\t{\r\n\t\tob->ticcount = 0;\t\t// start the new state at 0, then use excess\r\n\t\tstate = ob->state;\r\n\t}\r\n\r\n\twhile (excesstics)\r\n\t{\r\n\t//\r\n\t// passed through to next state\r\n\t//\r\n\t\tif (!state->skippable && excesstics >= state->tictime)\r\n\t\t\texcesstics = DoActor(ob,state->tictime-1);\r\n\t\telse\r\n\t\t\texcesstics = DoActor(ob,excesstics);\r\n\t\tif (ob->state != state)\r\n\t\t{\r\n\t\t\tob->ticcount = 0;\t\t// start the new state at 0, then use excess\r\n\t\t\tstate = ob->state;\r\n\t\t}\r\n\t}\r\n\r\n\tif (!state)\t\t\t// object removed itself\r\n\t{\r\n\t\tRemoveObj (ob);\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//\r\n\t// if state->rightshapenum == NULL, the state does not have a standard\r\n\t// shape (the think routine should have set it)\r\n\t//\r\n\tif (state->rightshapenum)\r\n\t{\r\n\t\tif (ob->xdir>0)\r\n\t\t\tob->shapenum = state->rightshapenum;\r\n\t\telse\r\n\t\t\tob->shapenum = state->leftshapenum;\r\n\t}\r\n\tif (ob->shapenum == (unsigned)-1)\r\n\t\tob->shapenum = 0;\t\t// make it invisable this time\r\n\r\n\tif (ob->xmove || ob->ymove || ob->shapenum != oldshapenum)\r\n\t{\r\n\t//\r\n\t// actor moved or changed shape\r\n\t// make sure the movement is within limits (one tile)\r\n\t//\r\n\t\tClipToWalls (ob);\r\n\t}\r\n}\r\n\r\n//==========================================================================\r\n\r\n\r\n/*\r\n====================\r\n=\r\n= NewState\r\n=\r\n====================\r\n*/\r\n\r\nvoid NewState (objtype *ob,statetype *state)\r\n{\r\n\tboolean temp;\r\n\r\n\tob->state = state;\r\n\r\n\tif (state->rightshapenum)\r\n\t{\r\n\t\tif (ob->xdir>0)\r\n\t\t\tob->shapenum = state->rightshapenum;\r\n\t\telse\r\n\t\t\tob->shapenum = state->leftshapenum;\r\n\t}\r\n\r\n\ttemp = ob->needtoclip;\r\n\r\n\tob->needtoclip = false;\r\n\r\n\tClipToWalls (ob);\t\t\t\t\t// just calculate values\r\n\r\n\tob->needtoclip = temp;\r\n\r\n\tif (ob->needtoclip)\r\n\t\tClipToWalls (ob);\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n============================\r\n=\r\n= PlayLoop\r\n=\r\n============================\r\n*/\r\n\r\nvoid PlayLoop (void)\r\n{\r\n\tobjtype\t*obj, *check;\r\n\tlong\tnewtime;\r\n\r\n\tbutton0held = button1held = false;\r\n\r\n\tingame = true;\r\n\tplaystate = 0;\r\n\tplummet = 0;\r\n\r\n\tFixScoreBox ();\t\t\t\t\t// draw bomb/flower\r\n\r\n\tdo\r\n\t{\r\n\t\tCalcSingleGravity ();\r\n\t\tIN_ReadControl(0,&c);\t\t// get player input\r\n\t\tif (!c.button0)\r\n\t\t\tbutton0held = 0;\r\n\t\tif (!c.button1)\r\n\t\t\tbutton1held = 0;\r\n\r\n//\r\n// go through state changes and propose movements\r\n//\r\n\t\tobj = player;\r\n\t\tdo\r\n\t\t{\r\n\t\t\tif (!obj->active\r\n\t\t\t&& obj->tileright >= originxtile\r\n\t\t\t&& obj->tileleft <= originxtilemax\r\n\t\t\t&& obj->tiletop <= originytilemax\r\n\t\t\t&& obj->tilebottom >= originytile)\r\n\t\t\t{\r\n\t\t\t\tobj->needtoreact = true;\r\n\t\t\t\tobj->active = yes;\r\n\t\t\t}\r\n\r\n\t\t\tif (obj->active)\r\n\t\t\t\tStateMachine(obj);\r\n\r\n\t\t\tif ( (obj->active == true || obj->active == removable) &&\r\n\t\t\t(  obj->tileright < inactivateleft\r\n\t\t\t|| obj->tileleft > inactivateright\r\n\t\t\t|| obj->tiletop > inactivatebottom\r\n\t\t\t|| obj->tilebottom < inactivatetop) )\r\n\t\t\t{\r\n\t\t\t\tif (obj->active == removable)\r\n\t\t\t\t\tRemoveObj (obj);\t\t\t\t// temp thing (shots, etc)\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif (US_RndT()<tics)\t\t\t\t// let them get a random dist\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tRF_RemoveSprite (&obj->sprite);\r\n\t\t\t\t\t\tobj->active = no;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tobj = (objtype *)obj->next;\r\n\t\t} while (obj);\r\n\r\n//\r\n// check for and handle collisions between objects\r\n//\r\n\t\tobj = player;\r\n\t\tdo\r\n\t\t{\r\n\t\t\tif (obj->active)\r\n\t\t\t{\r\n\t\t\t\tcheck = (objtype *)obj->next;\r\n\t\t\t\twhile (check)\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( check->active\r\n\t\t\t\t\t&& obj->right > check->left\r\n\t\t\t\t\t&& obj->left < check->right\r\n\t\t\t\t\t&& obj->top < check->bottom\r\n\t\t\t\t\t&& obj->bottom > check->top)\r\n\t\t\t\t\t{\r\n#pragma warn -pro\r\n\t\t\t\t\t\tif (obj->state->contact)\r\n\t\t\t\t\t\t\tobj->state->contact(obj,check);\r\n\t\t\t\t\t\tif (check->state->contact)\r\n\t\t\t\t\t\t\tcheck->state->contact(check,obj);\r\n#pragma warn +pro\r\n\t\t\t\t\t\tif (!obj->obclass)\r\n\t\t\t\t\t\t\tbreak;\t\t\t\t// contact removed object\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck = (objtype *)check->next;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tobj = (objtype *)obj->next;\r\n\t\t} while (obj);\r\n\r\n\r\n\t\tScrollScreen();\r\n\r\n//\r\n// react to whatever happened, and post sprites to the refresh manager\r\n//\r\n\t\tobj = player;\r\n\t\tdo\r\n\t\t{\r\n\t\t\tif (obj->needtoreact && obj->state->react)\r\n\t\t\t{\r\n\t\t\t\tobj->needtoreact = false;\r\n#pragma warn -pro\r\n\t\t\t\tobj->state->react(obj);\r\n#pragma warn +pro\r\n\t\t\t}\r\n\t\t\tobj = (objtype *)obj->next;\r\n\t\t} while (obj);\r\n\r\n\r\n//\r\n// update the screen and calculate the number of tics it took to execute\r\n// this cycle of events (for adaptive timing of next cycle)\r\n//\r\n\t\tRF_Refresh();\r\n\r\n//\r\n// single step debug mode\r\n//\r\n\t\tif (singlestep)\r\n\t\t{\r\n\t\t\tVW_WaitVBL(14);\r\n\t\t\tlasttimecount = TimeCount;\r\n\t\t}\r\n\r\n\t\tCheckKeys();\r\n\t} while (!loadedgame && !playstate);\r\n\r\n\tingame = false;\r\n}\r\n\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= GameFinale\r\n=\r\n==========================\r\n*/\r\n\r\nvoid GameFinale (void)\r\n{\r\nstruct date d;\r\n\r\n\tVW_FixRefreshBuffer ();\r\n\r\n/* screen 1 of finale text (16 lines) */\r\n\tUS_CenterWindow (30,21);\r\n\tPrintY += 4;\r\n\tUS_CPrint (\r\n\"Yes!  Boobus Tuber's hash-brown-\\n\"\r\n\"like remains rained down from\\n\"\r\n\"the skies as Commander Keen\\n\"\r\n\"walked up to the Dream Machine.\\n\"\r\n\"He analyzed all the complex\\n\"\r\n\"controls and readouts on it, then\\n\"\r\n\"pulled down a huge red lever\\n\"\r\n\"marked \\\"On/Off Switch.\\\"  The\\n\"\r\n\"machine clanked and rattled,\\n\"\r\n\"then went silent. He had freed\\n\"\r\n\"all the children from their\\n\"\r\n\"vegetable-enforced slavery!\\n\"\r\n\"Everything around Keen wobbled\\n\"\r\n\"in a disconcerting manner, his\\n\"\r\n\"eyelids grew heavy, and he\\n\"\r\n\"fell asleep....\\n\"\r\n\t);\r\n\tVW_UpdateScreen();\r\n\tVW_WaitVBL(60);\r\n\tSD_WaitSoundDone ();\r\n\tIN_ClearKeysDown ();\r\n\tIN_Ack();\r\n\r\n/* screen 2 of finale (15 lines) */\r\n\tUS_CenterWindow (30,21);\r\n\tPrintY += 9;\r\n\tUS_CPrint (\r\n\"Billy woke up, looking around the\\n\"\r\n\"room, the early morning sun\\n\"\r\n\"shining in his face.  Nothing.\\n\"\r\n\"No vegetables to be seen.  Was it\\n\"\r\n\"all just a dream?\\n\\n\"\r\n\"Billy's mom entered the room.\\n\\n\"\r\n\"\\\"Good morning, dear. I heard some\\n\"\r\n\"news on TV that you'd be\\n\"\r\n\"interested in,\\\" she said, sitting\\n\"\r\n\"by him on the bed.\\n\\n\"\r\n\"\\\"What news?\\\" Billy asked,\\n\"\r\n\"still groggy.\\n\\n\"\r\n\t);\r\n\tVW_UpdateScreen();\r\n\tVW_WaitVBL(60);\r\n\tIN_ClearKeysDown ();\r\n\tIN_Ack();\r\n\r\n/* screen 3 of finale (12 lines)*/\r\n\tUS_CenterWindow (30,21);\r\n\tPrintY += 23;\r\n\tUS_CPrint (\r\n\"\\\"The President declared today\\n\"\r\n\"National 'I Hate Broccoli' Day.\\n\"\r\n\"He said kids are allowed to pick\\n\"\r\n\"one vegetable today, and they\\n\"\r\n\"don't have to eat it.\\\"\\n\\n\"\r\n\"\\\"Aw, mom, I'm not afraid of any\\n\"\r\n\"stupid vegetables,\\\" Billy said.\\n\"\r\n\"\\\"But if it's okay with you, I'd\\n\"\r\n\"rather not have any french fries\\n\"\r\n\"for awhile.\\\"\\n\\n\"\r\n\"THE END\"\r\n\t);\r\n\tVW_UpdateScreen();\r\n\tVW_WaitVBL(60);\r\n\tIN_ClearKeysDown ();\r\n\tIN_Ack();\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n==========================\r\n=\r\n= HandleDeath\r\n=\r\n==========================\r\n*/\r\n\r\nvoid HandleDeath (void)\r\n{\r\n\tunsigned\ttop,bottom,selection,y,color;\r\n\r\n\tgamestate.keys = 0;\r\n\tgamestate.boobusbombs -= gamestate.bombsthislevel;\r\n\tgamestate.lives--;\r\n\tif (gamestate.lives < 0)\r\n\t\treturn;\r\n\r\n\tVW_FixRefreshBuffer ();\r\n\tUS_CenterWindow (20,8);\r\n\tPrintY += 4;\r\n\tUS_CPrint (\"You didn't make it past\");\r\n\tUS_CPrint (levelnames[mapon]);\r\n\tPrintY += 8;\r\n\ttop = PrintY-2;\r\n\tUS_CPrint (\"Try Again\");\r\n\tPrintY += 4;\r\n\tbottom = PrintY-2;\r\n\tUS_CPrint (\"Exit to Tuberia\");\r\n\r\n\tselection = 0;\r\n\tdo\r\n\t{\r\n\t\tif (selection)\r\n\t\t\ty = bottom;\r\n\t\telse\r\n\t\t\ty = top;\r\n\r\n// draw select bar\r\n\t\tif ( (TimeCount / 16)&1 )\r\n\t\t\tcolor = SECONDCOLOR;\r\n\t\telse\r\n\t\t\tcolor = FIRSTCOLOR;\r\n\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y,color);\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y+1,color);\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y+12,color);\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y+13,color);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+4,color);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+5,color);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+WindowW-4,color);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+WindowW-5,color);\r\n\r\n\t\tVW_UpdateScreen ();\r\n\r\n// erase select bar\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y,WHITE);\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y+1,WHITE);\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y+12,WHITE);\r\n\t\tVWB_Hlin (WindowX+4,WindowX+WindowW-4,y+13,WHITE);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+4,WHITE);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+5,WHITE);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+WindowW-4,WHITE);\r\n\t\tVWB_Vlin (y+1,y+11, WindowX+WindowW-5,WHITE);\r\n\r\n\t\tif (LastScan == sc_Escape)\r\n\t\t{\r\n\t\t\tgamestate.mapon = 0;\t\t// exit to tuberia\r\n\t\t\tIN_ClearKeysDown ();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tIN_ReadControl(0,&c);\t\t// get player input\r\n\t\tif (c.button0 || c.button1 || LastScan == sc_Return\r\n\t\t|| LastScan == sc_Space)\r\n\t\t{\r\n\t\t\tif (selection)\r\n\t\t\t\tgamestate.mapon = 0;\t\t// exit to tuberia\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (c.yaxis == -1 || LastScan == sc_UpArrow)\r\n\t\t\tselection = 0;\r\n\t\telse if (c.yaxis == 1 || LastScan == sc_DownArrow)\r\n\t\t\tselection = 1;\r\n\t} while (1);\r\n\r\n}\r\n\r\n//==========================================================================\r\n\r\n/*\r\n============================\r\n=\r\n= GameLoop\r\n=\r\n= A game has just started (after the cinematic or load game)\r\n=\r\n============================\r\n*/\r\n\r\nvoid GameLoop (void)\r\n{\r\n\tunsigned\tcities,i;\r\n\tlong\torgx,orgy;\r\n\r\n\tgamestate.difficulty = restartgame;\r\n\trestartgame = gd_Continue;\r\n\r\n\tdo\r\n\t{\r\nstartlevel:\r\n\t\tif (loadedgame)\r\n\t\t{\r\n\t\t\tloadedgame = false;\r\n\t\t\t//\r\n\t\t\t// start the initial view position to center the player\r\n\t\t\t//\r\n\t\t\torgx = (long)player->x - (150<<G_P_SHIFT);\r\n\t\t\torgy = (long)player->y-(84<<G_P_SHIFT);\r\n\t\t\tif (orgx<0)\r\n\t\t\t\torgx=0;\r\n\t\t\tif (orgy<0)\r\n\t\t\t\torgy=0;\r\n\r\n\t\t\tVW_FadeOut ();\r\n\t\t\tfadecount = 0;\r\n\t\t\tRF_SetRefreshHook (&FadeAndUnhook);\r\n\t\t\tRF_NewPosition (orgx,orgy);\r\n\t\t\tCalcInactivate ();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tVW_FixRefreshBuffer ();\r\n\t\t\tUS_CenterWindow (20,8);\r\n\t\t\tUS_CPrint (\"Loading\");\r\n\t\t\tVW_UpdateScreen ();\r\n\t\t\tgamestate.bombsthislevel = 0;\r\n\t\t\tSetupGameLevel (true);\r\n\t\t}\r\n\r\n\r\n\t\tPlayLoop ();\r\n\r\n#if FRILLS\r\n\t\tif (tedlevel)\r\n\t\t{\r\n\t\t\tif (playstate == died)\r\n\t\t\t\tgoto startlevel;\r\n\t\t\telse\r\n\t\t\t\tTEDDeath ();\r\n\t\t}\r\n#endif\r\n\r\n\t\tif (loadedgame)\r\n\t\t\tgoto startlevel;\r\n\r\n\t\tswitch (playstate)\r\n\t\t{\r\n\t\tcase warptolevel:\r\n\t\t\tgoto startlevel;\r\n\r\n\t\tcase died:\r\n\t\t\tHandleDeath ();\r\n\t\t\tbreak;\r\n\r\n\t\tcase levelcomplete:\r\n\t\t\tif (mapon)\r\n\t\t\t\tSD_PlaySound (LEVELDONESND);\r\n\t\t\tgamestate.leveldone[mapon] = true;\t// finished the level\r\n\t\t\tif (mapon != 0)\r\n\t\t\t\tgamestate.mapon = 0;\r\n\t\t\tbreak;\r\n\r\n\t\tcase resetgame:\r\n\t\t\treturn;\r\n\r\n\t\tcase victorious:\r\n\t\t\tGameFinale ();\r\n\t\t\tgoto done;\r\n\t\t}\r\n\r\n\r\n\t} while (gamestate.lives>-1 && playstate!=victorious);\r\n\r\n\tGameOver ();\r\n\r\ndone:\r\n\tcities = 0;\r\n\tfor (i= 1; i<=16; i++)\r\n\t\tif (gamestate.leveldone[i])\r\n\t\t\tcities++;\r\n\tUS_CheckHighScore (gamestate.score,cities);\r\n\tVW_ClearVideo (FIRSTCOLOR);\r\n}\r\n\r\n"
        },
        {
          "name": "kdreams.prj",
          "type": "blob",
          "size": 11.4189453125,
          "content": null
        },
        {
          "name": "lscr",
          "type": "tree",
          "content": null
        },
        {
          "name": "lzhuf.c",
          "type": "blob",
          "size": 23.5263671875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t LZHUFF COMPRESSION ROUTINES\r\n//\t\t\t\t\t\t\t\t\t\t  VERSION 1.0\r\n//\r\n//  \t\t\t\tCompression algrythim by Haruhiko OKUMURA\r\n//  \t\t\t\t\t\tImplementation by Jim T. Row\r\n//\r\n//\r\n//   Copyright (c) 1992 - Softdisk Publishing inc. - All rights reserved\r\n//\r\n//===========================================================================\r\n//\r\n// Compiler #ifdef switches\r\n//\r\n// \tLZHUFF_COMPRESSION & LZHUFF_DECOMPRESSION\t\t- not yet functional!\r\n//\r\n// Usage Explanition :\r\n//\r\n//    if LZHUFF_COMPRESSION is defined then the compression code & data is\r\n//    compiled and so-forth for the decompression code.\r\n//\r\n//---------------------------------------------------------------------------\r\n\r\n\r\n\r\n#include <fcntl.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <alloc.h>\r\n#include <dos.h>\r\n\r\n#include \"lzhuff.h\"\r\n#include \"jam_io.h\"\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\t\tSWITCHES\r\n//\r\n// NOTE : Make sure the appropriate switches are set in SOFT.c for Softlib\r\n//\t\t\t archive support.\r\n//\r\n//===========================================================================\r\n\r\n\r\n#define INCLUDE_LZH_COMP\t\t\t0\r\n#define INCLUDE_LZH_DECOMP\t\t\t1\r\n\r\n\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\t\tDEFINES\r\n//\r\n//===========================================================================\r\n\r\n\r\n#define EXIT_OK \t\t\t0\r\n#define EXIT_FAILED \t\t-1\r\n\r\n/* LZSS Parameters */\r\n\r\n#define N\t\t\t\t4096\t\t\t\t\t\t\t\t/* Size of string buffer */\r\n#define F\t\t\t\t30\t\t\t\t\t\t\t\t\t/* Size of look-ahead buffer */\r\n#define THRESHOLD\t\t2\r\n#define NIL\t\t\t\tN\t\t\t\t\t\t\t\t\t/* End of tree's node  */\r\n\r\n/* Huffman coding parameters */\r\n\r\n#define N_CHAR  \t\t(256 - THRESHOLD + F)\t\t/* character code (= 0..N_CHAR-1) */\r\n#define T \t\t\t\t(N_CHAR * 2 - 1)\t\t\t\t/* Size of table */\r\n#define R \t\t\t\t(T - 1)\t\t\t\t\t\t\t/* root position */\r\n#define MAX_FREQ\t\t0x8000                     /* update when cumulative frequency */\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* reaches to this value */\r\n\r\n\r\n//==========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\tLOCAL PROTOTYPES\r\n//\r\n//==========================================================================\r\n\r\n\r\nstatic void StartHuff();\r\nstatic void reconst();\r\nstatic void update(int c);\r\n\r\n\r\nstatic void DeleteNode(int p);  /* Deleting node from the tree */\r\nstatic void InsertNode(int r);  /* Inserting node to the tree */\r\nstatic void InitTree(void);  /* Initializing tree */\r\nstatic void Putcode(long outfile_ptr, int l, unsigned c,unsigned PtrTypes);\t\t/* output c bits */\r\nstatic void EncodeChar(long outfile_ptr, unsigned c, unsigned PtrTypes);\r\nstatic void EncodePosition(long outfile_ptr, unsigned c, unsigned PtrTypes);\r\nstatic void EncodeEnd(long outfile_ptr,unsigned PtrTypes);\r\n\r\n\r\nstatic int GetByte(long infile_ptr, unsigned long *CompressLength, unsigned PtrTypes);\r\nstatic int GetBit(long infile_ptr, unsigned long *CompressLength, unsigned PtrTypes);\t/* get one bit */\r\nstatic int DecodeChar(long infile_ptr, unsigned long *CompressLength, unsigned PtrTypes);\r\nstatic int DecodePosition(long infile_ptr,unsigned long *CompressLength, unsigned PtrTypes);\r\n\r\n\r\n\r\n\r\n//==========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\tUSER AVAILABLE VECTORS\r\n//\r\n//==========================================================================\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//\r\n// \t\t\t\t\t\t\t\tLZHUFF DISPLAY VECTORS\r\n//\r\n// These vectors allow you to hook up any form of display you desire for\r\n// displaying the compression/decompression status.\r\n//\r\n// These routines are called inside of the compression/decompression routines\r\n// and pass the orginal size of data and current position within that\r\n// data.  This allows for any kind of \"% Done\" messages.\r\n//\r\n// Your functions MUST have the following parameters in this order...\r\n//\r\n//   void VectorRoutine(unsigned long OrginalSize,unsigned long CurPosition)\r\n//\r\n//\r\n\r\n#if INCLUDE_LZH_COMP\r\nvoid (*LZH_CompressDisplayVector)() = NULL;\r\n#endif\r\n\r\n#if INCLUDE_LZH_DECOMP\r\nvoid (*LZH_DecompressDisplayVector)() = NULL;\r\n#endif\r\n\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\t\tGLOBAL VARIABLES\r\n//\r\n//===========================================================================\r\n\t/* pointing children nodes (son[], son[] + 1)*/\r\n\r\nint far son[T];\r\nunsigned code, len;\r\n\r\n\t//\r\n\t// pointing parent nodes.\r\n\t// area [T..(T + N_CHAR - 1)] are pointers for leaves\r\n\t//\r\n\r\nint far prnt[T + N_CHAR];\r\n\r\nunsigned far freq[T + 1];\t/* cumulative freq table */\r\n\r\nunsigned long textsize = 0, codesize = 0, printcount = 0,datasize;\r\nunsigned char far text_buf[N + F - 1];\r\n\r\n\r\n\r\n\t//\r\n\t// COMPRESSION VARIABLES\r\n\t//\r\n\r\n#if INCLUDE_LZH_COMP\r\n\r\nstatic int match_position,match_length, lson[N + 1], rson[N + 257], dad[N + 1];\r\nunsigned putbuf = 0;\r\nunsigned char putlen = 0;\r\n\r\n\t//\r\n\t// Tables for encoding/decoding upper 6 bits of\r\n\t// sliding dictionary pointer\r\n\t//\r\n\r\n\t//\r\n\t// encoder table\r\n\t//\r\n\r\nunsigned char far p_len[64] = {\r\n\t0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\r\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08\r\n};\r\n\r\nunsigned char far p_code[64] = {\r\n\t0x00, 0x20, 0x30, 0x40, 0x50, 0x58, 0x60, 0x68,\r\n\t0x70, 0x78, 0x80, 0x88, 0x90, 0x94, 0x98, 0x9C,\r\n\t0xA0, 0xA4, 0xA8, 0xAC, 0xB0, 0xB4, 0xB8, 0xBC,\r\n\t0xC0, 0xC2, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xCE,\r\n\t0xD0, 0xD2, 0xD4, 0xD6, 0xD8, 0xDA, 0xDC, 0xDE,\r\n\t0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE,\r\n\t0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,\r\n\t0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF\r\n};\r\n#endif\r\n\r\n\r\n\t//\r\n\t// DECOMPRESSION VARIABLES\r\n\t//\r\n\r\n\r\n\t//\r\n\t// decoder table\r\n\t//\r\n\r\n#if INCLUDE_LZH_DECOMP\r\n\r\nunsigned char far d_code[256] = {\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\r\n\t0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,\r\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\r\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\r\n\t0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,\r\n\t0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A, 0x0A,\r\n\t0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,\r\n\t0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D,\r\n\t0x0E, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F, 0x0F, 0x0F,\r\n\t0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11,\r\n\t0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,\r\n\t0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15,\r\n\t0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17,\r\n\t0x18, 0x18, 0x19, 0x19, 0x1A, 0x1A, 0x1B, 0x1B,\r\n\t0x1C, 0x1C, 0x1D, 0x1D, 0x1E, 0x1E, 0x1F, 0x1F,\r\n\t0x20, 0x20, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23,\r\n\t0x24, 0x24, 0x25, 0x25, 0x26, 0x26, 0x27, 0x27,\r\n\t0x28, 0x28, 0x29, 0x29, 0x2A, 0x2A, 0x2B, 0x2B,\r\n\t0x2C, 0x2C, 0x2D, 0x2D, 0x2E, 0x2E, 0x2F, 0x2F,\r\n\t0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\r\n\t0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,\r\n};\r\n\r\nunsigned char far d_len[256] = {\r\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\r\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\r\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\r\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,\r\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\r\n\t0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,\r\n};\r\n\r\nunsigned getbuf = 0;\r\nunsigned char getlen = 0;\r\n\r\n#endif\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\tCOMPRESSION & DECOMPRESSION ROUTINES\r\n//\r\n//===========================================================================\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//  StartHuff    /* initialize freq tree */\r\n//---------------------------------------------------------------------------\r\nstatic void StartHuff()\r\n{\r\n\tint i, j;\r\n\r\n\tfor (i = 0; i < N_CHAR; i++) {\r\n\t\tfreq[i] = 1;\r\n\t\tson[i] = i + T;\r\n\t\tprnt[i + T] = i;\r\n\t}\r\n\ti = 0; j = N_CHAR;\r\n\twhile (j <= R) {\r\n\t\tfreq[j] = freq[i] + freq[i + 1];\r\n\t\tson[j] = i;\r\n\t\tprnt[i] = prnt[i + 1] = j;\r\n\t\ti += 2; j++;\r\n\t}\r\n\tfreq[T] = 0xffff;\r\n\tprnt[R] = 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//   reconst        /* reconstruct freq tree */\r\n//---------------------------------------------------------------------------\r\nstatic void reconst()\r\n{\r\n\tint i, j, k;\r\n\tunsigned f, l;\r\n\r\n\t/* halven cumulative freq for leaf nodes */\r\n\r\n\tj = 0;\r\n\r\n\tfor (i = 0; i < T; i++)\r\n\t{\r\n\t\tif (son[i] >= T)\r\n\t\t{\r\n\t\t\tfreq[j] = (freq[i] + 1) / 2;\r\n\t\t\tson[j] = son[i];\r\n\t\t\tj++;\r\n\t\t}\r\n\t}\r\n\r\n\t/* make a tree : first, connect children nodes */\r\n\r\n\tfor (i = 0, j = N_CHAR; j < T; i += 2, j++)\r\n\t{\r\n\t\tk = i + 1;\r\n\t\tf = freq[j] = freq[i] + freq[k];\r\n\r\n\t\tfor (k = j - 1;f < freq[k]; k--);\r\n\r\n\t\tk++;\r\n\t\tl = (j - k) * 2;\r\n\r\n\t\t(void)memmove(&freq[k + 1], &freq[k], l);\r\n\t\tfreq[k] = f;\r\n\r\n\t\t(void)memmove(&son[k + 1], &son[k], l);\r\n\t\tson[k] = i;\r\n\t}\r\n\r\n\t/* connect parent nodes */\r\n\r\n\tfor (i = 0; i < T; i++)\r\n\t{\r\n\t\tif ((k = son[i]) >= T)\r\n\t\t{\r\n\t\t\tprnt[k] = i;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprnt[k] = prnt[k + 1] = i;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//  update()\t update freq tree\r\n//---------------------------------------------------------------------------\r\nstatic void update(int c)\r\n{\r\n\tint i, j, k, l;\r\n\r\n\tif (freq[R] == MAX_FREQ)\r\n\t{\r\n\t\treconst();\r\n\t}\r\n\r\n\tc = prnt[c + T];\r\n\r\n\tdo {\r\n\t\tk = ++freq[c];\r\n\r\n\t\t//\r\n\t\t// swap nodes to keep the tree freq-ordered\r\n\t\t//\r\n\r\n\t\tif (k > freq[l = c + 1])\r\n\t\t{\r\n\t\t\twhile (k > freq[++l]);\r\n\r\n\t\t\tl--;\r\n\t\t\tfreq[c] = freq[l];\r\n\t\t\tfreq[l] = k;\r\n\r\n\t\t\ti = son[c];\r\n\t\t\tprnt[i] = l;\r\n\t\t\tif (i < T)\r\n\t\t\t\tprnt[i + 1] = l;\r\n\r\n\t\t\tj = son[l];\r\n\t\t\tson[l] = i;\r\n\r\n\t\t\tprnt[j] = c;\r\n\t\t\tif (j < T)\r\n\t\t\t\tprnt[j + 1] = c;\r\n\r\n\t\t\tson[c] = j;\r\n\r\n\t\t\tc = l;\r\n\t\t}\r\n\t} while ((c = prnt[c]) != 0);\t/* do it until reaching the root */\r\n}\r\n\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t COMPRESSION ROUTINES\r\n//\r\n//===========================================================================\r\n\r\n\r\n\r\n\r\n\r\n\r\n#if INCLUDE_LZH_COMP\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// DeleteNode\r\n//---------------------------------------------------------------------------\r\nstatic void DeleteNode(int p)  /* Deleting node from the tree */\r\n{\r\n\tint  q;\r\n\r\n\tif (dad[p] == NIL)\r\n\t\treturn;\t\t\t/* unregistered */\r\n\r\n\tif (rson[p] == NIL)\r\n\t\tq = lson[p];\r\n\telse\r\n\tif (lson[p] == NIL)\r\n\t\tq = rson[p];\r\n\telse\r\n\t{\r\n\t\tq = lson[p];\r\n\t\tif (rson[q] != NIL)\r\n\t\t{\r\n\t\t\tdo {\r\n\t\t\t\tq = rson[q];\r\n\t\t\t} while (rson[q] != NIL);\r\n\r\n\t\t\trson[dad[q]] = lson[q];\r\n\t\t\tdad[lson[q]] = dad[q];\r\n\t\t\tlson[q] = lson[p];\r\n\t\t\tdad[lson[p]] = q;\r\n\t\t}\r\n\r\n\t\trson[q] = rson[p];\r\n\t\tdad[rson[p]] = q;\r\n\t}\r\n\r\n\tdad[q] = dad[p];\r\n\r\n\tif (rson[dad[p]] == p)\r\n\t\trson[dad[p]] = q;\r\n\telse\r\n\t\tlson[dad[p]] = q;\r\n\r\n\tdad[p] = NIL;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//  InsertNode\r\n//---------------------------------------------------------------------------\r\nstatic void InsertNode(int r)  /* Inserting node to the tree */\r\n{\r\n\tint  i, p, cmp;\r\n\tunsigned char  *key;\r\n\tunsigned c;\r\n\r\n\tcmp = 1;\r\n\tkey = &text_buf[r];\r\n\tp = N + 1 + key[0];\r\n\trson[r] = lson[r] = NIL;\r\n\tmatch_length = 0;\r\n\tfor ( ; ; )\r\n\t{\r\n\t\tif (cmp >= 0)\r\n\t\t{\r\n\t\t\tif (rson[p] != NIL)\r\n\t\t\t\tp = rson[p];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\trson[p] = r;\r\n\t\t\t\tdad[r] = p;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (lson[p] != NIL)\r\n\t\t\t\tp = lson[p];\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlson[p] = r;\r\n\t\t\t\tdad[r] = p;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tfor (i = 1; i < F; i++)\r\n\t\t\tif ((cmp = key[i] - text_buf[p + i]) != 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\tif (i > THRESHOLD)\r\n\t\t{\r\n\t\t\tif (i > match_length)\r\n\t\t\t{\r\n\t\t\t\tmatch_position = ((r - p) & (N - 1)) - 1;\r\n\t\t\t\tif ((match_length = i) >= F)\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (i == match_length)\r\n\t\t\t{\r\n\t\t\t\tif ((c = ((r - p) & (N - 1)) - 1) < match_position)\r\n\t\t\t\t{\r\n\t\t\t\t\tmatch_position = c;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdad[r] = dad[p];\r\n\tlson[r] = lson[p];\r\n\trson[r] = rson[p];\r\n\tdad[lson[p]] = r;\r\n\tdad[rson[p]] = r;\r\n\r\n\tif (rson[dad[p]] == p)\r\n\t\trson[dad[p]] = r;\r\n\telse\r\n\t\tlson[dad[p]] = r;\r\n\r\n\tdad[p] = NIL;  /* remove p */\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// InitTree\r\n//---------------------------------------------------------------------------\r\nstatic void InitTree(void)  /* Initializing tree */\r\n{\r\n\tint  i;\r\n\r\n\tfor (i = N + 1; i <= N + 256; i++)\r\n\t\trson[i] = NIL;\t\t\t/* root */\r\n\r\n\tfor (i = 0; i < N; i++)\r\n\t\tdad[i] = NIL;\t\t\t/* node */\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//  Putcode\r\n//---------------------------------------------------------------------------\r\nstatic void Putcode(long outfile_ptr, int l, unsigned c,unsigned PtrTypes)\t\t/* output c bits */\r\n{\r\n\tputbuf |= c >> putlen;\r\n\r\n\tif ((putlen += l) >= 8)\r\n\t{\r\n\t\tWritePtr(outfile_ptr, putbuf >> 8, PtrTypes);\r\n\t\tcodesize++;\r\n\r\n\t\tif ((putlen -= 8) >= 8)\r\n\t\t{\r\n\t\t\tWritePtr(outfile_ptr, putbuf, PtrTypes);\r\n\t\t\tcodesize++;\r\n\r\n\t\t\tputlen -= 8;\r\n\t\t\tputbuf = c << (l - putlen);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tputbuf <<= 8;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//  EncodeChar\r\n//---------------------------------------------------------------------------\r\nstatic void EncodeChar(long outfile_ptr, unsigned c, unsigned PtrTypes)\r\n{\r\n\tunsigned i;\r\n\tint j, k;\r\n\r\n\ti = 0;\r\n\tj = 0;\r\n\tk = prnt[c + T];\r\n\r\n\t/* search connections from leaf node to the root */\r\n\r\n\tdo {\r\n\t\ti >>= 1;\r\n\r\n\t\t//\r\n\t\t// if node's address is odd, output 1 else output 0\r\n\t\t//\r\n\r\n\t\tif (k & 1)\r\n\t\t\ti += 0x8000;\r\n\r\n\t\tj++;\r\n\t} while ((k = prnt[k]) != R);\r\n\r\n\tPutcode(outfile_ptr, j, i, PtrTypes);\r\n\r\n\tcode = i;\r\n\tlen = j;\r\n\tupdate(c);\r\n}\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// EncodePosition\r\n//---------------------------------------------------------------------------\r\nstatic void EncodePosition(long outfile_ptr, unsigned c, unsigned PtrTypes)\r\n{\r\n\tunsigned i;\r\n\r\n\t//\r\n\t// output upper 6 bits with encoding\r\n\t//\r\n\r\n\ti = c >> 6;\r\n\tPutcode(outfile_ptr, p_len[i], (unsigned)p_code[i] << 8,PtrTypes);\r\n\r\n\t//\r\n\t// output lower 6 bits directly\r\n\t//\r\n\r\n\tPutcode(outfile_ptr, 6, (c & 0x3f) << 10,PtrTypes);\r\n}\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// EncodeEnd\r\n//---------------------------------------------------------------------------\r\nstatic void EncodeEnd(long outfile_ptr,unsigned PtrTypes)\r\n{\r\n\tif (putlen)\r\n\t{\r\n\t\tWritePtr(outfile_ptr,(putbuf >> 8),PtrTypes);\r\n\t\tcodesize++;\r\n\t}\r\n}\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\tDECOMPRESSION ROUTINES\r\n//\r\n//===========================================================================\r\n\r\n\r\n\r\n#if INCLUDE_LZH_DECOMP\r\n\r\n//---------------------------------------------------------------------------\r\n// GetByte\r\n//---------------------------------------------------------------------------\r\nstatic int GetByte(long infile_ptr, unsigned long *CompressLength, unsigned PtrTypes)\r\n{\r\n\tunsigned i;\r\n\r\n\twhile (getlen <= 8)\r\n\t{\r\n\t\tif (*CompressLength)\r\n\t\t{\r\n\t\t\ti = ReadPtr(infile_ptr,PtrTypes);\r\n\t\t\t(*CompressLength)--;\r\n\t\t}\r\n\t\telse\r\n\t\t\ti = 0;\r\n\r\n\t\tgetbuf |= i << (8 - getlen);\r\n\t\tgetlen += 8;\r\n\t}\r\n\r\n\ti = getbuf;\r\n\tgetbuf <<= 8;\r\n\tgetlen -= 8;\r\n\treturn i>>8;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// GetBit\r\n//---------------------------------------------------------------------------\r\nstatic int GetBit(long infile_ptr, unsigned long *CompressLength, unsigned PtrTypes)\t/* get one bit */\r\n{\r\n\tint i;\r\n\r\n\twhile (getlen <= 8)\r\n\t{\r\n\t\tif (*CompressLength)\r\n\t\t{\r\n\t\t\ti = ReadPtr(infile_ptr,PtrTypes);\r\n\t\t\t(*CompressLength)--;\r\n\t\t}\r\n\t\telse\r\n\t\t\ti = 0;\r\n\r\n\t\tgetbuf |= i << (8 - getlen);\r\n\t\tgetlen += 8;\r\n\t}\r\n\r\n\ti = getbuf;\r\n\tgetbuf <<= 1;\r\n\tgetlen--;\r\n\treturn (i < 0);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// DecodeChar\r\n//---------------------------------------------------------------------------\r\nstatic int DecodeChar(long infile_ptr, unsigned long *CompressLength, unsigned PtrTypes)\r\n{\r\n\tunsigned c;\r\n\r\n\tc = son[R];\r\n\r\n\t/*\r\n\t * start searching tree from the root to leaves.\r\n\t * choose node #(son[]) if input bit == 0\r\n\t * else choose #(son[]+1) (input bit == 1)\r\n\t */\r\n\r\n\twhile (c < T)\r\n\t{\r\n\t\tc += GetBit(infile_ptr,CompressLength,PtrTypes);\r\n\t\tc = son[c];\r\n\t}\r\n\r\n\tc -= T;\r\n\tupdate(c);\r\n\treturn c;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n// DecodePosition\r\n//---------------------------------------------------------------------------\r\nstatic int DecodePosition(long infile_ptr,unsigned long *CompressLength, unsigned PtrTypes)\r\n{\r\n\tunsigned i, j, c;\r\n\r\n\t//\r\n\t// decode upper 6 bits from given table\r\n\t//\r\n\r\n\ti = GetByte(infile_ptr, CompressLength, PtrTypes);\r\n\tc = (unsigned)d_code[i] << 6;\r\n\tj = d_len[i];\r\n\r\n\t//\r\n\t// input lower 6 bits directly\r\n\t//\r\n\r\n\tj -= 2;\r\n\twhile (j--)\r\n\t{\r\n\t\ti = (i << 1) + GetBit(infile_ptr, CompressLength, PtrTypes);\r\n\t}\r\n\r\n\treturn c | i & 0x3f;\r\n}\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\tEXTERNAL REFERENCED\r\n//\t\t\t\t\t\t\t  COMPRESSION & DECOMPRESSION\r\n//\t\t\t\t\t\t\t\t\t     ROUTINES\r\n//\r\n//===========================================================================\r\n\r\n\r\n\r\n\r\n#if INCLUDE_LZH_DECOMP\r\n\r\n//---------------------------------------------------------------------------\r\n// lzhDecompress()\r\n//---------------------------------------------------------------------------\r\nlong lzhDecompress(void far *infile, void far *outfile, unsigned long OrginalLength, unsigned long CompressLength, unsigned PtrTypes)\r\n{\r\n\tint  i, j, k, r, c;\r\n\tlong count;\r\n\r\n\tdatasize = textsize = OrginalLength;\r\n\tgetbuf = 0;\r\n\tgetlen = 0;\r\n\r\n\tif (textsize == 0)\r\n\t\treturn;\r\n\r\n\tStartHuff();\r\n\tfor (i = 0; i < N - F; i++)\r\n\t\ttext_buf[i] = ' ';\r\n\r\n\tr = N - F;\r\n\r\n\tfor (count = 0; count < textsize; )\r\n\t{\r\n\t\tc = DecodeChar((long)&infile,&CompressLength,PtrTypes);\r\n\r\n\t\tif (c < 256)\r\n\t\t{\r\n\t\t\tWritePtr((long)&outfile,c,PtrTypes);\r\n\t\t\tdatasize--;\t\t\t\t\t\t\t\t// Dec # of bytes to write\r\n\r\n\t\t\ttext_buf[r++] = c;\r\n\t\t\tr &= (N - 1);\r\n\t\t\tcount++;\t\t\t\t\t\t\t\t\t// inc count of bytes written\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\ti = (r - DecodePosition((long)&infile,&CompressLength,PtrTypes) - 1) & (N - 1);\r\n\t\t\tj = c - 255 + THRESHOLD;\r\n\r\n\t\t\tfor (k = 0; k < j; k++)\r\n\t\t\t{\r\n\t\t\t\tc = text_buf[(i + k) & (N - 1)];\r\n\r\n\t\t\t\tWritePtr((long)&outfile,c,PtrTypes);\r\n\t\t\t\tdatasize--;\t\t\t\t\t\t\t// dec count of bytes to write\r\n\r\n\t\t\t\ttext_buf[r++] = c;\r\n\t\t\t\tr &= (N - 1);\r\n\t\t\t\tcount++;\t\t\t\t\t\t\t\t// inc count of bytes written\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (LZH_DecompressDisplayVector && (count > printcount))\r\n\t\t{\r\n\t\t\tLZH_DecompressDisplayVector(OrginalLength,OrginalLength-datasize);\r\n\t\t\tprintcount += 1024;\r\n\t\t}\r\n\t}\r\n\r\n//\tprintf(\"%12ld\\n\", count);\r\n\r\n\treturn(count);\r\n}\r\n\r\n#endif\r\n\r\n\r\n\r\n\r\n\r\n#if INCLUDE_LZH_COMP\r\n\r\n//---------------------------------------------------------------------------\r\n// lzhCompress()\r\n//---------------------------------------------------------------------------\r\nlong lzhCompress(void far *infile, void far *outfile,unsigned long DataLength,unsigned PtrTypes)\r\n{\r\n\tint  i, c, len, r, s, last_match_length;\r\n\r\n\ttextsize = DataLength;\r\n\r\n\tif (textsize == 0)\r\n\t\treturn;\r\n\r\n\tgetbuf = 0;\r\n\tgetlen = 0;\r\n\ttextsize = 0;\t\t\t/* rewind and rescan */\r\n\tcodesize = 0;\r\n\tdatasize = 0;\t\t\t// Init our counter of ReadData...\r\n\tStartHuff();\r\n\tInitTree();\r\n\r\n\ts = 0;\r\n\tr = N - F;\r\n\r\n\tfor (i = s; i < r; i++)\r\n\t\ttext_buf[i] = ' ';\r\n\r\n\tfor (len = 0; len < F && (DataLength > datasize); len++)\r\n\t{\r\n\t\tc = ReadPtr((long)&infile,PtrTypes);\r\n\t\tdatasize++;\t\t\t\t\t\t\t// Dec num of bytes to compress\r\n\t\ttext_buf[r + len] = c;\r\n\t}\r\n\r\n\ttextsize = len;\r\n\r\n\tfor (i = 1; i <= F; i++)\r\n\t\tInsertNode(r - i);\r\n\r\n\tInsertNode(r);\r\n\r\n\tdo {\r\n\t\tif (match_length > len)\r\n\t\t\tmatch_length = len;\r\n\r\n\t\tif (match_length <= THRESHOLD)\r\n\t\t{\r\n\t\t\tmatch_length = 1;\r\n\t\t\tEncodeChar((long)&outfile,text_buf[r],PtrTypes);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tEncodeChar((long)&outfile, 255 - THRESHOLD + match_length,PtrTypes);\r\n\t\t\tEncodePosition((long)&outfile, match_position,PtrTypes);\r\n\t\t}\r\n\r\n\t\tlast_match_length = match_length;\r\n\r\n\t\tfor (i = 0; i < last_match_length && (DataLength > datasize); i++)\r\n\t\t{\r\n\t\t\tc = ReadPtr((long)&infile,PtrTypes);\r\n\t\t\tdatasize++;\r\n\r\n\t\t\tDeleteNode(s);\r\n\t\t\ttext_buf[s] = c;\r\n\r\n\t\t\tif (s < F - 1)\r\n\t\t\t\ttext_buf[s + N] = c;\r\n\r\n\t\t\ts = (s + 1) & (N - 1);\r\n\t\t\tr = (r + 1) & (N - 1);\r\n\t\t\tInsertNode(r);\r\n\t\t}\r\n\r\n\t\tif (LZH_CompressDisplayVector && ((textsize += i) > printcount))\r\n\t\t{\r\n\t\t\tLZH_CompressDisplayVector(DataLength,datasize);\r\n\t\t\tprintcount += 1024;\r\n\t\t}\r\n\r\n\r\n\t\twhile (i++ < last_match_length)\r\n\t\t{\r\n\t\t\tDeleteNode(s);\r\n\t\t\ts = (s + 1) & (N - 1);\r\n\t\t\tr = (r + 1) & (N - 1);\r\n\t\t\tif (--len)\r\n\t\t\t\tInsertNode(r);\r\n\t\t}\r\n\r\n\t} while (len > 0);\r\n\r\n\tEncodeEnd((long)&outfile,PtrTypes);\r\n\r\n\treturn(codesize);\r\n\r\n}\r\n\r\n\r\n#endif"
        },
        {
          "name": "lzhuff.h",
          "type": "blob",
          "size": 1.310546875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\nextern void (*LZH_CompressDisplayVector)();\r\nextern void (*LZH_DecompressDisplayVector)();\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\t\tPROTOTYPES\r\n//\r\n//===========================================================================\r\n\r\n\r\nlong lzhCompress(void far *infile, void far *outfile,unsigned long DataLength,unsigned PtrTypes);\r\nlong lzhDecompress(void far *infile, void far *outfile, unsigned long OrginalLength, unsigned long CompressLength, unsigned PtrTypes);\r\n\r\n\r\n\r\n"
        },
        {
          "name": "lzw.h",
          "type": "blob",
          "size": 1.50390625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//--------------------------------------------------------------------------\r\n//\r\n//\t\t\t\t\tEXTERN DEFINITIONS FOR DISPLAY VEC ROUTINES\r\n//\r\n//--------------------------------------------------------------------------\r\n\r\n\r\nextern void (*LZW_CompressDisplayVector)();\r\nextern void (*LZW_DecompressDisplayVector)();\r\n\r\n\r\n//---------------------------------------------------------------------------\r\n//\r\n//\t\t\t\t\t\t\t\tFUNCTION PROTOTYPEING\r\n//\r\n//---------------------------------------------------------------------------\r\n\r\n\r\n\r\nunsigned long lzwCompress(void far *infile, void far *outfile,unsigned long DataLength,unsigned PtrTypes);\r\nvoid lzwDecompress(void far *infile, void far *outfile,unsigned long DataLength,unsigned PtrTypes);\r\n\r\n"
        },
        {
          "name": "sl_file.h",
          "type": "blob",
          "size": 3.078125,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n#ifndef _SL_FILE_H\r\n#define _SL_FILE_H\r\n\r\n\r\n//==========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\tDEFINES\r\n//\r\n//==========================================================================\r\n\r\n#ifndef MakeID\r\n#define MakeID(a,b,c,d)\t\t\t(((long)(d)<<24L)|((long)(c)<<16L)|((long)(b)<<8L)|(long)(a))\r\n#endif\r\n\r\n\r\n#define ID_SLIB\t\t\t\t\tMakeID('S','L','I','B')\r\n#define SLIB\t\t\t\t\t\t(\"SLIB\")\r\n#define SOFTLIB_VER\t\t\t\t2\r\n#define ID_CHUNK\t\t\t\t\tMakeID('C','U','N','K')\r\n\r\n\r\n\r\n//==========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\tTYPES\r\n//\r\n//==========================================================================\r\n\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n//\t\t\t\t\t\t\tSOFTLIB File Entry Types\r\n//--------------------------------------------------------------------------\r\ntypedef enum LibFileTypes\r\n{\r\n\tlib_DATA =0,\t\t\t\t\t// Just streight raw data\r\n//\tlib_AUDIO,\t\t\t\t\t\t// Multi chunk audio file\r\n\r\n} LibFileTypes;\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n//   \t\t\t\t\t\t\tSOFTLIB Library File header..\r\n//\r\n//\t\t\t\t\t\t   * This header will NEVER change! *\r\n//--------------------------------------------------------------------------\r\n\r\ntypedef struct SoftLibHdr\r\n{\r\n\tunsigned Version;\t\t\t\t\t\t\t\t\t// Library Version Num\r\n\tunsigned FileCount;\r\n} SoftlibHdr;\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n//   \t\t\t\t\t\t\tSOFTLIB Directory Entry Hdr\r\n//\r\n// This can change according to Version of SoftLib (Make sure we are\r\n// always downward compatable!\r\n//--------------------------------------------------------------------------\r\n\r\n#define SL_FILENAMESIZE\t\t16\r\n\r\ntypedef struct FileEntryHdr\r\n{\r\n\tchar FileName[SL_FILENAMESIZE];\t\t  \t// NOTE : May not be null terminated!\r\n\tunsigned long Offset;\r\n\tunsigned long ChunkLen;\r\n\tunsigned long OrginalLength;\r\n\tshort Compression;\t\t\t\t\t\t\t// ct_TYPES\r\n} FileEntryHdr;\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n//\t\t\t\t\t\t\t   SOFTLIB Entry Chunk Header\r\n//--------------------------------------------------------------------------\r\n\r\ntypedef struct ChunkHeader\r\n{\r\n\tunsigned long HeaderID;\r\n\tunsigned long OrginalLength;\r\n\tshort Compression;\t\t\t\t\t\t\t\t// ct_TYPES\r\n} ChunkHeader;\r\n\r\n\r\n\r\n#endif"
        },
        {
          "name": "soft.c",
          "type": "blob",
          "size": 10.2900390625,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include <alloc.h>\r\n#include <fcntl.h>\r\n#include <dos.h>\r\n#include <io.h>\r\n\r\n#include \"kd_def.h\"\r\n//#include \"gelib.h\"\r\n#include \"soft.h\"\r\n#include \"lzw.h\"\r\n#include \"lzhuff.h\"\r\n#include \"jam_io.h\"\r\n\r\n\r\nBufferedIO lzwBIO;\r\n\r\n\r\n\r\n\r\n//===========================================================================\r\n//\r\n//\t\t\t\t\t\t\t\t\t\tSWITCHES\r\n//\r\n//===========================================================================\r\n\r\n#define LZH_SUPPORT\t\t1\r\n#define LZW_SUPPORT\t\t0\r\n\r\n\r\n\r\n\r\n//=========================================================================\r\n//\r\n//\r\n//\t\t\t\t\t\t\t\tGENERAL LOAD ROUTINES\r\n//\r\n//\r\n//=========================================================================\r\n\r\n\r\n\r\n//--------------------------------------------------------------------------\r\n// BLoad()\t\t\t-- THIS HAS NOT BEEN FULLY TESTED!\r\n//\r\n// NOTICE : This version of BLOAD is compatable with JAMPak V3.0 and the\r\n//\t\t\t\tnew fileformat...\r\n//--------------------------------------------------------------------------\r\nunsigned long BLoad(char *SourceFile, memptr *DstPtr)\r\n{\r\n\tint handle;\r\n\r\n\tmemptr SrcPtr;\r\n\tunsigned long i, j, k, r, c;\r\n\tword flags;\r\n\tbyte Buffer[8];\r\n\tunsigned long SrcLen,DstLen;\r\n\tstruct CMP1Header CompHeader;\r\n\tboolean Compressed = false;\r\n\r\n\r\n\tmemset((void *)&CompHeader,0,sizeof(struct CMP1Header));\r\n\r\n\t//\r\n\t// Open file to load....\r\n\t//\r\n\r\n\tif ((handle = open(SourceFile, O_RDONLY|O_BINARY)) == -1)\r\n\t\treturn(0);\r\n\r\n\t//\r\n\t// Look for JAMPAK headers\r\n\t//\r\n\r\n\tread(handle,Buffer,4);\r\n\r\n\tif (!strncmp(Buffer,COMP,4))\r\n\t{\r\n\t\t//\r\n\t\t// Compressed under OLD file format\r\n\t\t//\r\n\r\n\t\tCompressed = true;\r\n\t\tSrcLen = Verify(SourceFile);\r\n\r\n\t\tread(handle,(void *)&CompHeader.OrginalLen,4);\r\n\t\tCompHeader.CompType = ct_LZW;\r\n\t\tMM_GetPtr(DstPtr,CompHeader.OrginalLen);\r\n\t\tif (!*DstPtr)\r\n\t\t\treturn(0);\r\n\t}\r\n\telse\r\n\tif (!strncmp(Buffer,CMP1,4))\r\n\t{\r\n\t\t//\r\n\t\t// Compressed under new file format...\r\n\t\t//\r\n\r\n\t\tCompressed = true;\r\n\t\tSrcLen = Verify(SourceFile);\r\n\r\n\t\tread(handle,(void *)&CompHeader,sizeof(struct CMP1Header));\r\n\t\tMM_GetPtr(DstPtr,CompHeader.OrginalLen);\r\n\t\tif (!*DstPtr)\r\n\t\t\treturn(0);\r\n\t}\r\n\telse\r\n\t\tDstLen = Verify(SourceFile);\r\n\r\n\r\n\t//\r\n\t// Load the file in memory...\r\n\t//\r\n\r\n\tif (Compressed)\r\n\t{\r\n\t\tDstLen = CompHeader.OrginalLen;\r\n\r\n\t\tif ((MM_TotalFree() < SrcLen) && (CompHeader.CompType))\r\n\t\t{\r\n\t\t\tif (!InitBufferedIO(handle,&lzwBIO))\r\n\t\t\t\tQuit(\"No memory for buffered I/O.\");\r\n\r\n\t\t\tswitch (CompHeader.CompType)\r\n\t\t\t{\r\n\t\t\t\t#if LZW_SUPPORT\r\n\t\t\t\tcase ct_LZW:\r\n\t\t\t\t\tlzwDecompress(&lzwBIO,MK_FP(*DstPtr,0),CompHeader.OrginalLen,(SRC_BFILE|DEST_MEM));\r\n\t\t\t\tbreak;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t#if LZH_SUPPORT\r\n\t\t\t\tcase ct_LZH:\r\n\t\t\t\t\tlzhDecompress(&lzwBIO,MK_FP(*DstPtr,0),CompHeader.OrginalLen,CompHeader.CompressLen,(SRC_BFILE|DEST_MEM));\r\n\t\t\t\tbreak;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tQuit(\"BLoad() - Unrecognized/Supported compression\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tFreeBufferedIO(&lzwBIO);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tCA_LoadFile(SourceFile,&SrcPtr);\r\n\t\t\tswitch (CompHeader.CompType)\r\n\t\t\t{\r\n\t\t\t\t#if LZW_SUPPORT\r\n\t\t\t\tcase ct_LZW:\r\n\t\t\t\t\tlzwDecompress(MK_FP(SrcPtr,8),MK_FP(*DstPtr,0),CompHeader.OrginalLen,(SRC_MEM|DEST_MEM));\r\n\t\t\t\tbreak;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t#if LZH_SUPPORT\r\n\t\t\t\tcase ct_LZH:\r\n\t\t\t\t\tlzhDecompress(MK_FP(SrcPtr,8),MK_FP(*DstPtr,0),CompHeader.OrginalLen,CompHeader.CompressLen,(SRC_MEM|DEST_MEM));\r\n\t\t\t\tbreak;\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tQuit(\"BLoad() - Unrecognized/Supported compression\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tMM_FreePtr(&SrcPtr);\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\tCA_LoadFile(SourceFile,DstPtr);\r\n\r\n\tclose(handle);\r\n\treturn(DstLen);\r\n}\r\n\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////\r\n//\r\n// LoadLIBShape()\r\n//\r\nint LoadLIBShape(char *SLIB_Filename, char *Filename,struct Shape *SHP)\r\n{\r\n\t#define CHUNK(Name)\t(*ptr == *Name) &&\t\t\t\\\r\n\t\t\t\t\t\t\t\t(*(ptr+1) == *(Name+1)) &&\t\\\r\n\t\t\t\t\t\t\t\t(*(ptr+2) == *(Name+2)) &&\t\\\r\n\t\t\t\t\t\t\t\t(*(ptr+3) == *(Name+3))\r\n\r\n\r\n\tint RT_CODE;\r\n\tFILE *fp;\r\n\tchar CHUNK[5];\r\n\tchar far *ptr;\r\n\tmemptr IFFfile = NULL;\r\n\tunsigned long FileLen, size, ChunkLen;\r\n\tint loop;\r\n\r\n\r\n\tRT_CODE = 1;\r\n\r\n\t// Decompress to ram and return ptr to data and return len of data in\r\n\t//\tpassed variable...\r\n\r\n\tif (!LoadLIBFile(SLIB_Filename,Filename,&IFFfile))\r\n\t\tQuit(\"Error Loading Compressed lib shape!\");\r\n\r\n\t// Evaluate the file\r\n\t//\r\n\tptr = MK_FP(IFFfile,0);\r\n\tif (!CHUNK(\"FORM\"))\r\n\t\tgoto EXIT_FUNC;\r\n\tptr += 4;\r\n\r\n\tFileLen = *(long far *)ptr;\r\n\tSwapLong((long far *)&FileLen);\r\n\tptr += 4;\r\n\r\n\tif (!CHUNK(\"ILBM\"))\r\n\t\tgoto EXIT_FUNC;\r\n\tptr += 4;\r\n\r\n\tFileLen += 4;\r\n\twhile (FileLen)\r\n\t{\r\n\t\tChunkLen = *(long far *)(ptr+4);\r\n\t\tSwapLong((long far *)&ChunkLen);\r\n\t\tChunkLen = (ChunkLen+1) & 0xFFFFFFFE;\r\n\r\n\t\tif (CHUNK(\"BMHD\"))\r\n\t\t{\r\n\t\t\tptr += 8;\r\n\t\t\tSHP->bmHdr.w = ((struct BitMapHeader far *)ptr)->w;\r\n\t\t\tSHP->bmHdr.h = ((struct BitMapHeader far *)ptr)->h;\r\n\t\t\tSHP->bmHdr.x = ((struct BitMapHeader far *)ptr)->x;\r\n\t\t\tSHP->bmHdr.y = ((struct BitMapHeader far *)ptr)->y;\r\n\t\t\tSHP->bmHdr.d = ((struct BitMapHeader far *)ptr)->d;\r\n\t\t\tSHP->bmHdr.trans = ((struct BitMapHeader far *)ptr)->trans;\r\n\t\t\tSHP->bmHdr.comp = ((struct BitMapHeader far *)ptr)->comp;\r\n\t\t\tSHP->bmHdr.pad = ((struct BitMapHeader far *)ptr)->pad;\r\n\t\t\tSwapWord(&SHP->bmHdr.w);\r\n\t\t\tSwapWord(&SHP->bmHdr.h);\r\n\t\t\tSwapWord(&SHP->bmHdr.x);\r\n\t\t\tSwapWord(&SHP->bmHdr.y);\r\n\t\t\tptr += ChunkLen;\r\n\t\t}\r\n\t\telse\r\n\t\tif (CHUNK(\"BODY\"))\r\n\t\t{\r\n\t\t\tptr += 4;\r\n\t\t\tsize = *((long far *)ptr);\r\n\t\t\tptr += 4;\r\n\t\t\tSwapLong((long far *)&size);\r\n\t\t\tSHP->BPR = (SHP->bmHdr.w+7) >> 3;\r\n\t\t\tMM_GetPtr(&SHP->Data,size);\r\n\t\t\tif (!SHP->Data)\r\n\t\t\t\tgoto EXIT_FUNC;\r\n\t\t\tmovedata(FP_SEG(ptr),FP_OFF(ptr),FP_SEG(SHP->Data),0,size);\r\n\t\t\tptr += ChunkLen;\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse\r\n\t\t\tptr += ChunkLen+8;\r\n\r\n\t\tFileLen -= ChunkLen+8;\r\n\t}\r\n\r\n\tRT_CODE = 0;\r\n\r\nEXIT_FUNC:;\r\n\tif (IFFfile)\r\n\t{\r\n//\t\tsegptr = (memptr)FP_SEG(IFFfile);\r\n\t\tMM_FreePtr(&IFFfile);\r\n\t}\r\n\r\n\treturn (RT_CODE);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n//----------------------------------------------------------------------------\r\n// LoadLIBFile() -- Copies a file from an existing archive to dos.\r\n//\r\n// PARAMETERS :\r\n//\r\n//\t\t\tLibName \t- Name of lib file created with SoftLib V1.0\r\n//\r\n//\t\t\tFileName - Name of file to load from lib file.\r\n//\r\n//\t\t\tMemPtr   - (IF !NULL) - Pointer to memory to load into ..\r\n//\t\t\t\t\t\t  (IF NULL)  - Routine allocates necessary memory and\r\n//\t\t\t\t\t\t\t\t\t\t\treturns a MEM(SEG) pointer to memory allocated.\r\n//\r\n// RETURN :\r\n//\r\n//   \t\t(IF !NULL) - A pointer to the loaded data.\r\n//\t\t\t(IF NULL)  - Error!\r\n//\r\n//----------------------------------------------------------------------------\r\nmemptr LoadLIBFile(char *LibName,char *FileName,memptr *MemPtr)\r\n{\r\n\tint handle;\r\n\tunsigned long header;\r\n\tstruct ChunkHeader Header;\r\n\tunsigned long ChunkLen;\r\n\tshort x;\r\n\tstruct FileEntryHdr FileEntry;     \t\t\t// Storage for file once found\r\n\tstruct FileEntryHdr FileEntryHeader;\t\t// Header used durring searching\r\n\tstruct SoftLibHdr LibraryHeader;\t\t\t\t// Library header - Version Checking\r\n\tboolean FileFound = false;\r\n\tunsigned long id_slib = ID_SLIB;\r\n\tunsigned long id_chunk = ID_CHUNK;\r\n\r\n\r\n\t//\r\n\t// OPEN SOFTLIB FILE\r\n\t//\r\n\r\n\tif ((handle = open(LibName,O_RDONLY|O_BINARY, S_IREAD)) == -1)\r\n\t\treturn(NULL);\r\n\r\n\r\n\t//\r\n\t//\tVERIFY it is a SOFTLIB (SLIB) file\r\n\t//\r\n\r\n\tif (read(handle,&header,4) == -1)\r\n\t{\r\n\t\tclose(handle);\r\n\t\treturn(NULL);\r\n\t}\r\n\r\n\tif (header != id_slib)\r\n\t{\r\n\t\tclose(handle);\r\n\t\treturn(NULL);\r\n\t}\r\n\r\n\r\n\t//\r\n\t// CHECK LIBRARY HEADER VERSION NUMBER\r\n\t//\r\n\r\n\tif (read(handle, &LibraryHeader,sizeof(struct SoftLibHdr)) == -1)\r\n\t\tQuit(\"read error in LoadSLIBFile()\\n\");\r\n\r\n\tif (LibraryHeader.Version > SOFTLIB_VER)\r\n\t\tQuit(\"Unsupported file ver \");\r\n\r\n\r\n\t//\r\n\t// MANAGE FILE ENTRY HEADERS...\r\n\t//\r\n\r\n\tfor (x = 1;x<=LibraryHeader.FileCount;x++)\r\n\t{\r\n\t\tif (read(handle, &FileEntryHeader,sizeof(struct FileEntryHdr)) == -1)\r\n\t\t{\r\n\t\t\tclose(handle);\r\n\t\t\treturn(NULL);\r\n\t\t}\r\n\r\n\t\tif (!stricmp(FileEntryHeader.FileName,FileName))\r\n\t\t{\r\n\t\t\tFileEntry = FileEntryHeader;\r\n\t\t\tFileFound = true;\r\n\t\t}\r\n\t}\r\n\r\n\t//\r\n\t// IF FILE HAS BEEN FOUND THEN SEEK TO POSITION AND EXTRACT\r\n\t//\tELSE RETURN WITH ERROR CODE...\r\n\t//\r\n\r\n\tif (FileFound)\r\n\t{\r\n\t\tif (lseek(handle,FileEntry.Offset,SEEK_CUR) == -1)\r\n\t\t{\r\n\t\t\tclose(handle);\r\n\t\t\treturn(NULL);\r\n\t\t}\r\n\r\n\t\t//\r\n\t\t// READ CHUNK HEADER - Verify we are at the beginning of a chunk..\r\n\t\t//\r\n\r\n\t\tif (read(handle,(char *)&Header,sizeof(struct ChunkHeader)) == -1)\r\n\t\t\tQuit(\"LIB File - Unable to read Header!\");\r\n\r\n\t\tif (Header.HeaderID != id_chunk)\r\n\t\t\tQuit(\"LIB File - BAD HeaderID!\");\r\n\r\n\t\t//\r\n\t\t// Allocate memory if Necessary...\r\n\t\t//\r\n\r\n\r\n\t\tif (!*MemPtr)\r\n\t\t\tMM_GetPtr(MemPtr,FileEntry.OrginalLength);\r\n\r\n\t\t//\r\n\t\t//\tCalculate the length of the data (without the chunk header).\r\n\t\t//\r\n\r\n\t\tChunkLen = FileEntry.ChunkLen - sizeof(struct ChunkHeader);\r\n\r\n\r\n\t\t//\r\n\t\t// Extract Data from file\r\n\t\t//\r\n\r\n\t\tswitch (Header.Compression)\r\n\t\t{\r\n\r\n\t\t\t#if LZW_SUPPORT\r\n\t\t\tcase ct_LZW:\r\n\t\t\t\tif (!InitBufferedIO(handle,&lzwBIO))\r\n\t\t\t\t\tQuit(\"No memory for buffered I/O.\");\r\n\t\t\t\tlzwDecompress(&lzwBIO,MK_FP(*MemPtr,0),FileEntry.OrginalLength,(SRC_BFILE|DEST_MEM));\r\n\t\t\t\tFreeBufferedIO(&lzwBIO);\r\n\t\t\t\tbreak;\r\n\t\t\t#endif\r\n\r\n\t\t\t#if LZH_SUPPORT\r\n\t\t\tcase ct_LZH:\r\n\t\t\t\tif (!InitBufferedIO(handle,&lzwBIO))\r\n\t\t\t\t\tQuit(\"No memory for buffered I/O.\");\r\n\t\t\t\tlzhDecompress(&lzwBIO, MK_FP(*MemPtr,0), FileEntry.OrginalLength, ChunkLen, (SRC_BFILE|DEST_MEM));\r\n\t\t\t\tFreeBufferedIO(&lzwBIO);\r\n\t\t\t\tbreak;\r\n\t\t\t#endif\r\n\r\n\t\t\tcase ct_NONE:\r\n\t\t\t\tif (!CA_FarRead(handle,MK_FP(*MemPtr,0),ChunkLen))\r\n\t\t\t\t{\r\n//\t\t\t\t\tclose(handle);\r\n\t\t\t\t\t*MemPtr = NULL;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tclose(handle);\r\n\t\t\t\tQuit(\"Unknown Chunk.Compression Type!\");\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t\t*MemPtr = NULL;\r\n\r\n\tclose(handle);\r\n\treturn(*MemPtr);\r\n}\r\n\r\n\r\n\r\n\r\n"
        },
        {
          "name": "soft.h",
          "type": "blob",
          "size": 1.1123046875,
          "content": "/* Keen Dreams Source Code\r\n * Copyright (C) 2014 Javier M. Chavez\r\n *\r\n * This program is free software; you can redistribute it and/or modify\r\n * it under the terms of the GNU General Public License as published by\r\n * the Free Software Foundation; either version 2 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * This program is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n * GNU General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU General Public License along\r\n * with this program; if not, write to the Free Software Foundation, Inc.,\r\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\r\n */\r\n\r\n//memptr InitBufferedIO(int handle, BufferedIO *bio);\r\n//void FreeBufferedIO(BufferedIO *bio);\r\n//byte bio_readch(BufferedIO *bio);\r\n\r\nunsigned long BLoad(char *SourceFile, memptr *DstPtr);\r\nmemptr LoadLIBFile(char *LibName,char *FileName,memptr *MemPtr);\r\nint LoadLIBShape(char *SLIB_Filename, char *Filename,struct Shape *SHP);\r\n"
        },
        {
          "name": "static",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}