{
  "metadata": {
    "timestamp": 1736710150767,
    "page": 812,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ionescu007/SimpleVisor",
      "stars": 1758,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.369140625,
          "content": "# Auto detect text files and perform LF normalization\n* text=auto\n\n# Custom for Visual Studio\n*.cs     diff=csharp\n\n# Standard to msysgit\n*.doc\t diff=astextplain\n*.DOC\t diff=astextplain\n*.docx diff=astextplain\n*.DOCX diff=astextplain\n*.dot  diff=astextplain\n*.DOT  diff=astextplain\n*.pdf  diff=astextplain\n*.PDF\t diff=astextplain\n*.rtf\t diff=astextplain\n*.RTF\t diff=astextplain\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.013671875,
          "content": "x64\n.vs\n.VC.db"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.6376953125,
          "content": "# SimpleVisor\n\nSimpleVisor is a simple, portable, Intel x64/EM64T VT-x specific hypervisor with two specific goals: using the least amount of assembly code (10 lines), and having the smallest amount of VMX-related code to support dynamic hyperjacking and unhyperjacking (that is, virtualizing the host state from within the host) while also supporting advanced features such as EPT and VPID. It currently runs on both Windows and in UEFI environments.\n\n## Introduction\n\nHave you always been curious on how to build a hypervisor? Has Intel's documentation (the many hundreds of pages) gotten you down? Have the samples you've found online just made things more confusing, or required weeks of reading through dozens of thousands of lines and code? If so, SimpleVisor might be the project for you.\n\nNot counting the exhaustive comments which explain every single line of code, and specific Windows-related or Intel-related idiosyncrasies, SimpleVisor clocks in at about 500 lines of C code, and 10 lines of x64 assembly code, all while containing the ability to run on every recent version of 64-bit Windows, and supporting dynamic load/unload at runtime.\n\nAdditionally, SimpleVisor utilizes a lightweight OS-library for Windows-specific functionality, separating out the hypervisor pieces from the Windows-specific pieces. Leveraging this portable design, a UEFI version of SimpleVisor is also now available. Note however, that it does not have robust support for MP environments due to issues with UEFI, and that loading an operating system will eventually result in a crash as the OS will hit unimplemented code paths due to its re-configuration of processor resources. Virtualizing the entire boot of the operating system from UEFI is beyond the scope of the project.\n\nSimpleVisor can be built with Visual Studio 2015 Update 3, and while older/newer compilers have not been tested and are not supported, it's likely that they can build the project as well. It's important, however, to keep the various compiler and linker settings as you see them, however.\n\nSimpleVisor has currently been tested on the following platforms successfully:\n\n* Windows 8.1 on a Haswell Processor (Custom Desktop)\n* Windows 10 Redstone 1 on a Sandy Bridge Processor (Samsung 930 Laptop)\n* Windows 10 Threshold 2/Redstone 1 on a Skylake Processor (Surface Pro 4 Tablet)\n* Windows 10 Threshold 2 on a Skylake Processor (Dell Inspiron 11-3153 w/ SGX)\n* VMWare Workstation 11, but without EPT (VMWare does not support 1GB EPTs)\n* UEFI 2.4 on an Asus Maximus VII Extreme Motherboard (Custom Desktop)\n\nAt this time, it has not been tested on Bochs, but there's no reason why SimpleVisor could not run in such an environment as well. However, if your machine is already running under a hypervisor such as Hyper-V or Xen, SimpleVisor will not load.\n\nKeep in mind that x86 versions of Windows are expressly not supported, nor are processors earlier than the Nehalem microarchitecture, nor is Windows 7. Support for the latter two is easy to add and exists in certain forks.\n\n## Motivation\n\nToo many hypervisor projects out there are either extremely complicated ([Xen][1], KVM, VirtualBox) and/or closed-source (VMware, Hyper-V), as well as heavily focused toward Linux-based development or system. Additionally, most (other than Hyper-V) of them are expressly built for the purpose of enabling the execution of virtual machines, and not the virtualization of a live, running system, in order to perform introspection or other security-related tasks on it.\n\nA few projects do stand out from the fold however, such as the original [Blue Pill][2] from Joanna, or projects such as [VirtDbg][3] and [HyperDbg][4]. Unfortunately, most of these have become quite old by now, and some only function on x86 processors, and don't support newer operating systems such as Windows 10. Another rather simple example, similar to Blue Pill in some aspects, but actually delivering a good example of EPT use for \"Split-TLB\" is [MoRE][7] from Jacob Torrey/AIS.\n\nThe closest project that actually delivers a Windows-centric, modern, and supported hypervisor is [HyperPlatform][5], and we strongly recommend its use as a starting place for more broadly usable research-type hypervisor development. However, in attempting to create a generic \"platform\" that is more broadly robust, HyperPlatform also suffers from a bit of bloat, making it harder to understand what truly are the basic needs of a hypervisor, and how to initialize one. In a similar vein, and showing an equal love for STL/C++, but also including an ELF loader and UEFI/Linux support alongside unit tests and even more robustness is [Bareflank][8], also from AIS. Beyond that, you're probably getting into Xen-level complexity.\n\nThe express goal of this project, as stated above, was to minimize code in any way possible, without causing negative side-effects, and focusing on the 'bare-metal' needs. This includes:\n\n* Minimizing use of assembly code. If it weren't for the lack of an __lgdt intrinsic, and a workaround for the behavior of a Windows API, only the first 4 instructions of the hypervisor's entry point would require assembly. As it stands, the project has a total of 10 instructions, spread throughout 3 functions. This is a massive departure from other hypervisor projects, which often have multiple hundreds of line of assembly code. A variety of OS-specific tricks and compiler shortcuts are used to achieve this result.\n* Reducing checks for errors which are unlikely to happen. Given a properly configured, and trusted, set of input data, instructions such as vmx_vmwrite and vmx_vmread should never fail, for example.\n* Removing support for x86, which complicates matters and causes special handling around 64-bit fields.\n* Expressly reducing all possible VM-Exits to only the Intel architecturally defined minimum (CPUID, INVD, VMX Instructions, and XSETBV). This is purposefully done to keep the hypervisor as small as possible, as well as the initialization code.\n* No support for VMCALL. Many hypervisors use VMCALL as a way to exit the hypervisor, which requires assembly programming (there is no intrinsic) and additional exit handling. SimpleVisor uses a CPUID trap instead.\n* Relying on little-known OS functions to simplify development of the hypervisor, such as Generic DPCs and hibernation contexts on Windows, or the PI MP protocol on UEFI.\n* Supporting EPT/VPID in a very simple fashion, to demonstrate a solid base of the simplest possible implementation of the feature.\n* Portability and isolation of OS-specific routines.\n\nAnother implied goal was to support the very latest in hardware features, as even [Bochs][6] doesn't always have the very-latest Intel VMX instructions and/or definitions. These are often found in header files such as \"vmcs.h\" and \"vmx.h\" that various projects have at various levels of definition. For example, Xen master has some unreleased VM Exit reasons, but not certain released ones, which Bochs does have, albeit it doesn't have the unreleased ones! One such example is the usage of 1GB EPT entries, which for example VMWare does not virtualize correctly.\n\nFinally, SimpleVisor is meant to be an educational tool -- it has exhaustive comments explaining all logic behind each line of code, and specific Windows or Intel VMX tips and tricks that allow it to achieve its desired outcome. Various bugs or poorly documented behaviors are called out explicitly.\n\n## Installation on Windows\n\nBecause x64 Windows requires all drivers to be signed, you must testsign the SimpleVisor binary. The Visual Studio project file can be setup to do so by using the \"Driver Signing\" options and enabling \"Test Sign\" with your own certificate. From the UI, you can also generate your own.\n\nSecondly, you must enable Test Signing Mode on your machine. To do so, first boot into UEFI to turn off \"Secure Boot\", otherwise Test Signing mode cannot be enabled. Alternatively, if you possess a valid KMCS certificate, you may \"Production Sign\" the driver to avoid this requirement.\n\nTo setup Test Signing Mode, you can use the following command:\n\n```bcdedit /set testsigning on```\n\nAfter a reboot, you can then setup the required Service Control Manager entries for SimpleVisor in the registry with the following command:\n\n```sc create simplevisor type= kernel binPath= \"<PATH_TO_SIMPLEVISOR.SYS>\"```\n\nYou can then launch SimpleVisor with\n\n```sc start simplevisor```\n\nAnd stop it with\n\n```sc stop simplevisor```\n\nYou must have administrative rights for usage of any of these commands.\n\n## References\n\nIf you would like to know more about my research or work, I invite you check out my blog at http://www.alex-ionescu.com as well as my training & consulting company, Winsider Seminars & Solutions Inc., at http://www.windows-internals.com.\n\nhttps://github.com/upring/virtdbg\n\nhttp://xenbits.xen.org/gitweb/?p=xen.git;a=summary\n\nhttps://github.com/svn2github/bochs\n\nhttps://github.com/rmusser01/hyperdbg\n\nhttp://invisiblethingslab.com/resources/bh07/nbp-0.32-public.zip\n\nhttps://github.com/tandasat/HyperPlatform\n\nhttps://github.com/ainfosec/MoRE\n\nhttps://github.com/Bareflank/hypervisor\n\n[3]:https://github.com/upring/virtdbg\n[1]:http://xenbits.xen.org/gitweb/?p=xen.git;a=summary \"Xen\"\n[6]:https://github.com/svn2github/bochs\n[4]:https://github.com/rmusser01/hyperdbg\n[2]:http://invisiblethingslab.com/resources/bh07/nbp-0.32-public.zip\n[5]:https://github.com/tandasat/HyperPlatform\n[7]:https://github.com/ainfosec/MoRE\n[8]:https://github.com/Bareflank/hypervisor\n\n## Caveats\n\nSimpleVisor is designed to minimize code size and complexity -- this does come at a cost of robustness. For example, even though many VMX operations performed by SimpleVisor \"should\" never fail, there are always unknown reasons, such as memory corruption, CPU errata, invalid host OS state, and potential bugs, which can cause certain operations to fail. For truly robust, commercial-grade software, these possibilities must be taken into account, and error handling, exception handling, and checks must be added to support them. Additionally, the vast array of BIOSes out there, and different CPU and chipset iterations, can each have specific incompatibilities or workarounds that must be checked for. ***SimpleVisor does not do any such error checking, validation, and exception handling. It is not robust software designed for production use, but rather a reference code base***.\n\n## License\n\n```\nCopyright 2016 Alex Ionescu. All rights reserved. \n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided\nthat the following conditions are met: \n1. Redistributions of source code must retain the above copyright notice, this list of conditions and\n   the following disclaimer. \n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions\n   and the following disclaimer in the documentation and/or other materials provided with the \n   distribution. \n\nTHIS SOFTWARE IS PROVIDED BY ALEX IONESCU ``AS IS'' AND ANY EXPRESS OR IMPLIED\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ALEX IONESCU\nOR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\nOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\nAND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nThe views and conclusions contained in the software and documentation are those of the authors and\nshould not be interpreted as representing official policies, either expressed or implied, of Alex Ionescu.\n```\n"
        },
        {
          "name": "nt",
          "type": "tree",
          "content": null
        },
        {
          "name": "ntint.h",
          "type": "blob",
          "size": 2.904296875,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nHeader Name:\n\n    ntint.h\n\nAbstract:\n\n    This header contains selected NT structures and functions from ntosp.h\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only.\n\n--*/\n\n#pragma once\n#pragma warning(disable:4201)\n#pragma warning(disable:4214)\n\n#define VOID                void\n#define DECLSPEC_ALIGN(x)   __declspec(align(x))\n#define DECLSPEC_NORETURN   __declspec(noreturn)\n#define FORCEINLINE         __forceinline\n#define C_ASSERT(x)         static_assert(x, \"Error\")\n#define UNREFERENCED_PARAMETER(x)   (x)\n\n#ifndef TRUE\n#define TRUE                1\n#define FALSE               0\n#endif\n\n#define KERNEL_STACK_SIZE   24 * 1024\n\ntypedef struct DECLSPEC_ALIGN(16) _M128A\n{\n    UINT64 Low;\n    INT64 High;\n} M128A, *PM128A;\n\ntypedef struct DECLSPEC_ALIGN(16) _XSAVE_FORMAT\n{\n    UINT16 ControlWord;\n    UINT16 StatusWord;\n    UINT8 TagWord;\n    UINT8 Reserved1;\n    UINT16 ErrorOpcode;\n    UINT32 ErrorOffset;\n    UINT16 ErrorSelector;\n    UINT16 Reserved2;\n    UINT32 DataOffset;\n    UINT16 DataSelector;\n    UINT16 Reserved3;\n    UINT32 MxCsr;\n    UINT32 MxCsr_Mask;\n    M128A FloatRegisters[8];\n    M128A XmmRegisters[16];\n    UINT8 Reserved4[96];\n} XSAVE_FORMAT, *PXSAVE_FORMAT;\ntypedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;\n\ntypedef struct DECLSPEC_ALIGN(16) _CONTEXT\n{\n    UINT64 P1Home;\n    UINT64 P2Home;\n    UINT64 P3Home;\n    UINT64 P4Home;\n    UINT64 P5Home;\n    UINT64 P6Home;\n    UINT32 ContextFlags;\n    UINT32 MxCsr;\n    UINT16 SegCs;\n    UINT16 SegDs;\n    UINT16 SegEs;\n    UINT16 SegFs;\n    UINT16 SegGs;\n    UINT16 SegSs;\n    UINT32 EFlags;\n    UINT64 Dr0;\n    UINT64 Dr1;\n    UINT64 Dr2;\n    UINT64 Dr3;\n    UINT64 Dr6;\n    UINT64 Dr7;\n    UINT64 Rax;\n    UINT64 Rcx;\n    UINT64 Rdx;\n    UINT64 Rbx;\n    UINT64 Rsp;\n    UINT64 Rbp;\n    UINT64 Rsi;\n    UINT64 Rdi;\n    UINT64 R8;\n    UINT64 R9;\n    UINT64 R10;\n    UINT64 R11;\n    UINT64 R12;\n    UINT64 R13;\n    UINT64 R14;\n    UINT64 R15;\n    UINT64 Rip;\n    union\n    {\n        XMM_SAVE_AREA32 FltSave;\n        struct\n        {\n            M128A Header[2];\n            M128A Legacy[8];\n            M128A Xmm0;\n            M128A Xmm1;\n            M128A Xmm2;\n            M128A Xmm3;\n            M128A Xmm4;\n            M128A Xmm5;\n            M128A Xmm6;\n            M128A Xmm7;\n            M128A Xmm8;\n            M128A Xmm9;\n            M128A Xmm10;\n            M128A Xmm11;\n            M128A Xmm12;\n            M128A Xmm13;\n            M128A Xmm14;\n            M128A Xmm15;\n        };\n    };\n    M128A VectorRegister[26];\n    UINT64 VectorControl;\n    UINT64 DebugControl;\n    UINT64 LastBranchToRip;\n    UINT64 LastBranchFromRip;\n    UINT64 LastExceptionToRip;\n    UINT64 LastExceptionFromRip;\n} CONTEXT, *PCONTEXT;\n\ntypedef union _LARGE_INTEGER\n{\n    struct\n    {\n        UINT32 LowPart;\n        INT32 HighPart;\n    };\n    UINT64 QuadPart;\n} LARGE_INTEGER, *PLARGE_INTEGER;\n"
        },
        {
          "name": "shv.c",
          "type": "blob",
          "size": 2.0556640625,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nModule Name:\n\n    shv.c\n\nAbstract:\n\n    This module implements the Driver Entry/Unload for the Simple Hyper Visor.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only.\n\n--*/\n\n#include \"shv.h\"\n\nVOID\nShvUnload (\n    VOID\n    )\n{\n    //\n    // Attempt to exit VMX root mode on all logical processors. This will\n    // broadcast an interrupt which will execute the callback routine in\n    // parallel on the LPs.\n    //\n    // Note that if SHV is not loaded on any of the LPs, this routine will not\n    // perform any work, but will not fail in any way.\n    //\n    ShvOsRunCallbackOnProcessors(ShvVpUnloadCallback, NULL);\n\n    //\n    // Indicate unload\n    //\n    ShvOsDebugPrint(\"The SHV has been uninstalled.\\n\");\n}\n\nINT32\nShvLoad (\n    VOID\n    )\n{\n    SHV_CALLBACK_CONTEXT callbackContext;\n\n    //\n    // Attempt to enter VMX root mode on all logical processors. This will\n    // broadcast a DPC interrupt which will execute the callback routine in\n    // parallel on the LPs. Send the callback routine the physical address of\n    // the PML4 of the system process, which is what this driver entrypoint\n    // should be executing in.\n    //\n    callbackContext.Cr3 = __readcr3();\n    callbackContext.FailureStatus = SHV_STATUS_SUCCESS;\n    callbackContext.FailedCpu = -1;\n    callbackContext.InitCount = 0;\n    ShvOsRunCallbackOnProcessors(ShvVpLoadCallback, &callbackContext);\n\n    //\n    // Check if all LPs are now hypervised. Return the failure code of at least\n    // one of them. \n    //\n    // Note that each VP is responsible for freeing its VP data on failure.\n    //\n    if (callbackContext.InitCount != ShvOsGetActiveProcessorCount())\n    {\n        ShvOsDebugPrint(\"The SHV failed to initialize (0x%lX) Failed CPU: %d\\n\",\n                        callbackContext.FailureStatus, callbackContext.FailedCpu);\n        return callbackContext.FailureStatus;\n    }\n\n    //\n    // Indicate success.\n    //\n    ShvOsDebugPrint(\"The SHV has been installed.\\n\");\n    return SHV_STATUS_SUCCESS;\n}\n"
        },
        {
          "name": "shv.h",
          "type": "blob",
          "size": 2.62109375,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nHeader Name:\n\n    shv.h\n\nAbstract:\n\n    This header defines the structures and functions of the Simple Hyper Visor.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 14-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only.\n\n--*/\n\n#pragma once\n#pragma warning(disable:4201)\n#pragma warning(disable:4214)\n\n#ifndef __BASE_H__\n#include <basetsd.h>\n#endif\n#define _INC_MALLOC\n#include <intrin.h>\n#include \"ntint.h\"\n#include \"shv_x.h\"\n\ntypedef struct _SHV_VP_STATE\n{\n    PCONTEXT VpRegs;\n    uintptr_t GuestRip;\n    uintptr_t GuestRsp;\n    uintptr_t GuestEFlags;\n    UINT16 ExitReason;\n    UINT8 ExitVm;\n} SHV_VP_STATE, *PSHV_VP_STATE;\n\ntypedef struct _SHV_CALLBACK_CONTEXT\n{\n    UINT64 Cr3;\n    volatile long InitCount;\n    INT32 FailedCpu;\n    INT32 FailureStatus;\n} SHV_CALLBACK_CONTEXT, *PSHV_CALLBACK_CONTEXT;\n\nSHV_CPU_CALLBACK ShvVpLoadCallback;\nSHV_CPU_CALLBACK ShvVpUnloadCallback;\n\nVOID\nShvVmxEntry (\n    VOID\n    );\n\nINT32\nShvVmxLaunchOnVp (\n    _In_ PSHV_VP_DATA VpData\n    );\n\nVOID\nShvUtilConvertGdtEntry (\n    _In_ VOID* GdtBase,\n    _In_ UINT16 Offset,\n    _Out_ PVMX_GDTENTRY64 VmxGdtEntry\n    );\n\nUINT32\nShvUtilAdjustMsr (\n    _In_ LARGE_INTEGER ControlValue,\n    _In_ UINT32 DesiredValue\n    );\n\nPSHV_VP_DATA\nShvVpAllocateData (\n    _In_ UINT32 CpuCount\n    );\n\nVOID\nShvVpFreeData  (\n    _In_ PSHV_VP_DATA Data,\n    _In_ UINT32 CpuCount\n    );\n\nINT32\nShvVmxLaunch (\n    VOID\n    );\n\nUINT8\nShvVmxProbe (\n    VOID\n    );\n\nVOID\nShvVmxEptInitialize (\n    _In_ PSHV_VP_DATA VpData\n    );\n\nDECLSPEC_NORETURN\nVOID\nShvVpRestoreAfterLaunch (\n    VOID\n    );\n\n//\n// OS Layer\n//\nDECLSPEC_NORETURN\nVOID\n__cdecl\nShvOsRestoreContext (\n    _In_ PCONTEXT ContextRecord\n    );\n\nVOID\nShvOsCaptureContext (\n    _In_ PCONTEXT ContextRecord\n    );\n\nVOID\nShvOsUnprepareProcessor (\n    _In_ PSHV_VP_DATA VpData\n    );\n\nINT32\nShvOsPrepareProcessor (\n    _In_ PSHV_VP_DATA VpData\n    );\n\nINT32\nShvOsGetActiveProcessorCount (\n    VOID\n    );\n\nINT32\nShvOsGetCurrentProcessorNumber (\n    VOID\n    );\n\nVOID\nShvOsFreeContiguousAlignedMemory (\n    _In_ VOID* BaseAddress,\n    _In_ size_t Size\n    );\n\nVOID*\nShvOsAllocateContigousAlignedMemory (\n    _In_ size_t Size\n    );\n\nUINT64\nShvOsGetPhysicalAddress (\n    _In_ VOID* BaseAddress\n    );\n\n#ifndef __BASE_H__\nVOID\nShvOsDebugPrint (\n    _In_ const char* Format,\n    ...\n    );\n#else\nVOID\nShvOsDebugPrintWide (\n    _In_ const CHAR16* Format,\n    ...\n    );\n#define ShvOsDebugPrint(format, ...) ShvOsDebugPrintWide(_CRT_WIDE(format), __VA_ARGS__)\n#endif\n\nVOID\nShvOsRunCallbackOnProcessors (\n    _In_ PSHV_CPU_CALLBACK Routine,\n    _In_opt_ VOID* Context\n    );\n\nextern PSHV_VP_DATA* ShvGlobalData;\n\n"
        },
        {
          "name": "shv.sln",
          "type": "blob",
          "size": 1.0009765625,
          "content": "﻿\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 15\nVisualStudioVersion = 15.0.26823.1\nMinimumVisualStudioVersion = 10.0.40219.1\nProject(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"shv\", \"shv.vcxproj\", \"{4C048BB2-7E8D-43BF-B29D-942461275023}\"\nEndProject\nGlobal\n\tGlobalSection(SolutionConfigurationPlatforms) = preSolution\n\t\tUEFI|x64 = UEFI|x64\n\t\tWindows NT|x64 = Windows NT|x64\n\tEndGlobalSection\n\tGlobalSection(ProjectConfigurationPlatforms) = postSolution\n\t\t{4C048BB2-7E8D-43BF-B29D-942461275023}.UEFI|x64.ActiveCfg = UEFI|x64\n\t\t{4C048BB2-7E8D-43BF-B29D-942461275023}.UEFI|x64.Build.0 = UEFI|x64\n\t\t{4C048BB2-7E8D-43BF-B29D-942461275023}.Windows NT|x64.ActiveCfg = NT|x64\n\t\t{4C048BB2-7E8D-43BF-B29D-942461275023}.Windows NT|x64.Build.0 = NT|x64\n\tEndGlobalSection\n\tGlobalSection(SolutionProperties) = preSolution\n\t\tHideSolutionNode = FALSE\n\tEndGlobalSection\n\tGlobalSection(ExtensibilityGlobals) = postSolution\n\t\tSolutionGuid = {638D3E2C-5547-469D-B2E2-43ED56005273}\n\tEndGlobalSection\nEndGlobal\n"
        },
        {
          "name": "shv.vcxproj",
          "type": "blob",
          "size": 2.0341796875,
          "content": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"12.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"NT|x64\">\n      <Configuration>NT</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"UEFI|x64\">\n      <Configuration>UEFI</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <Keyword>Win32Proj</Keyword>\n    <ProjectGuid>{4C048BB2-7E8D-43BF-B29D-942461275023}</ProjectGuid>\n    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <Import Project=\"$(Configuration)\\$(Configuration).default.props\" />\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)'=='UEFI'\">\n    <Import Project=\"$(VCTargetsPath)\\BuildCustomizations\\masm.props\" />\n  </ImportGroup>\n  <Import Project=\"$(Configuration)\\$(Configuration).props\" />\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)'=='UEFI'\">\n    <Import Project=\"$(VCTargetsPath)\\BuildCustomizations\\masm.targets\" />\n  </ImportGroup>\n  <PropertyGroup>\n    <IncludePath>$(IncludePath);$(VC_IncludePath)</IncludePath>\n  </PropertyGroup>\n  <ItemGroup>\n    <ClCompile Include=\"shv.c\" />\n    <ClCompile Include=\"shvutil.c\" />\n    <ClCompile Include=\"shvvmx.c\" />\n    <ClCompile Include=\"shvvmxhv.c\" />\n    <ClCompile Include=\"shvvp.c\" />\n    <ClCompile Include=\"$(Configuration)\\shvos.c\"/>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"shv.h\" />\n    <ClInclude Include=\"ntint.h\" />\n    <ClInclude Include=\"shv_x.h\" />\n    <ClInclude Include=\"vmx.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <MASM Include=\"shvvmxhvx64.asm\" />\n    <MASM Include=\"$(Configuration)\\shvosx64.asm\"/>\n  </ItemGroup>\n</Project>"
        },
        {
          "name": "shv_x.h",
          "type": "blob",
          "size": 2.509765625,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nHeader Name:\n\n    shv_x.h\n\nAbstract:\n\n    This header defines the externally visible structures and functions of the\n    Simple Hyper Visor which are visible between the OS layer and SimpleVisor.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 29-Aug-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only.\n\n--*/\n\n#pragma once\n\n#include \"vmx.h\"\n\n#define SHV_STATUS_SUCCESS          0\n#define SHV_STATUS_NOT_AVAILABLE    -1\n#define SHV_STATUS_NO_RESOURCES     -2\n#define SHV_STATUS_NOT_PRESENT      -3\n\n#define _1GB                        (1 * 1024 * 1024 * 1024)\n#define _2MB                        (2 * 1024 * 1024)\n\nstruct _SHV_CALLBACK_CONTEXT;\n\ntypedef\nvoid\nSHV_CPU_CALLBACK (\n    _In_ struct _SHV_CALLBACK_CONTEXT* Context\n    );\ntypedef SHV_CPU_CALLBACK *PSHV_CPU_CALLBACK;\n\ntypedef struct _SHV_SPECIAL_REGISTERS\n{\n    UINT64 Cr0;\n    UINT64 Cr3;\n    UINT64 Cr4;\n    UINT64 MsrGsBase;\n    UINT16 Tr;\n    UINT16 Ldtr;\n    UINT64 DebugControl;\n    UINT64 KernelDr7;\n    KDESCRIPTOR Idtr;\n    KDESCRIPTOR Gdtr;\n} SHV_SPECIAL_REGISTERS, *PSHV_SPECIAL_REGISTERS;\n\ntypedef struct _SHV_MTRR_RANGE\n{\n    UINT32 Enabled;\n    UINT32 Type;\n    UINT64 PhysicalAddressMin;\n    UINT64 PhysicalAddressMax;\n} SHV_MTRR_RANGE, *PSHV_MTRR_RANGE;\n\ntypedef struct _SHV_VP_DATA\n{\n    union\n    {\n        DECLSPEC_ALIGN(PAGE_SIZE) UINT8 ShvStackLimit[KERNEL_STACK_SIZE];\n        struct\n        {\n            SHV_SPECIAL_REGISTERS SpecialRegisters;\n            CONTEXT ContextFrame;\n            UINT64 SystemDirectoryTableBase;\n            LARGE_INTEGER MsrData[17];\n            SHV_MTRR_RANGE MtrrData[16];\n            UINT64 VmxOnPhysicalAddress;\n            UINT64 VmcsPhysicalAddress;\n            UINT64 MsrBitmapPhysicalAddress;\n            UINT64 EptPml4PhysicalAddress;\n            UINT32 EptControls;\n        };\n    };\n\n    DECLSPEC_ALIGN(PAGE_SIZE) UINT8 MsrBitmap[PAGE_SIZE];\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_EPML4E Epml4[PML4E_ENTRY_COUNT];\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_PDPTE Epdpt[PDPTE_ENTRY_COUNT];\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_LARGE_PDE Epde[PDPTE_ENTRY_COUNT][PDE_ENTRY_COUNT];\n\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_VMCS VmxOn;\n    DECLSPEC_ALIGN(PAGE_SIZE) VMX_VMCS Vmcs;\n} SHV_VP_DATA, *PSHV_VP_DATA;\n\nC_ASSERT(sizeof(SHV_VP_DATA) == (KERNEL_STACK_SIZE + (512 + 5) * PAGE_SIZE));\n\nVOID\n_sldt (\n    _In_ UINT16* Ldtr\n    );\n\nVOID\n_ltr (\n    _In_ UINT16 Tr\n    );\n\nVOID\n_str (\n    _In_ UINT16* Tr\n    );\n\nVOID\n__lgdt (\n    _In_ VOID* Gdtr\n    );\n\nINT32\nShvLoad (\n    VOID\n    );\n\nVOID\nShvUnload (\n    VOID\n    );"
        },
        {
          "name": "shvutil.c",
          "type": "blob",
          "size": 2.62890625,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nModule Name:\n\n    shvutil.c\n\nAbstract:\n\n    This module implements utility functions for the Simple Hyper Visor.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only.\n\n--*/\n\n#include \"shv.h\"\n\nVOID\nShvUtilConvertGdtEntry (\n    _In_ VOID* GdtBase,\n    _In_ UINT16 Selector,\n    _Out_ PVMX_GDTENTRY64 VmxGdtEntry\n    )\n{\n    PKGDTENTRY64 gdtEntry;\n\n    //\n    // Reject LDT or NULL entries\n    //\n    if ((Selector == 0) ||\n        (Selector & SELECTOR_TABLE_INDEX) != 0)\n    {\n        VmxGdtEntry->Limit = VmxGdtEntry->AccessRights = 0;\n        VmxGdtEntry->Base = 0;\n        VmxGdtEntry->Selector = 0;\n        VmxGdtEntry->Bits.Unusable = TRUE;\n        return;\n    }\n\n    //\n    // Read the GDT entry at the given selector, masking out the RPL bits.\n    //\n    gdtEntry = (PKGDTENTRY64)((uintptr_t)GdtBase + (Selector & ~RPL_MASK));\n\n    //\n    // Write the selector directly \n    //\n    VmxGdtEntry->Selector = Selector;\n\n    //\n    // Use the LSL intrinsic to read the segment limit\n    //\n    VmxGdtEntry->Limit = __segmentlimit(Selector);\n\n    //\n    // Build the full 64-bit effective address, keeping in mind that only when\n    // the System bit is unset, should this be done.\n    //\n    // NOTE: The Windows definition of KGDTENTRY64 is WRONG. The \"System\" field\n    // is incorrectly defined at the position of where the AVL bit should be.\n    // The actual location of the SYSTEM bit is encoded as the highest bit in\n    // the \"Type\" field.\n    //\n    VmxGdtEntry->Base = ((gdtEntry->Bytes.BaseHigh << 24) |\n                         (gdtEntry->Bytes.BaseMiddle << 16) |\n                         (gdtEntry->BaseLow)) & 0xFFFFFFFF;\n    VmxGdtEntry->Base |= ((gdtEntry->Bits.Type & 0x10) == 0) ?\n                         ((uintptr_t)gdtEntry->BaseUpper << 32) : 0;\n\n    //\n    // Load the access rights\n    //\n    VmxGdtEntry->AccessRights = 0;\n    VmxGdtEntry->Bytes.Flags1 = gdtEntry->Bytes.Flags1;\n    VmxGdtEntry->Bytes.Flags2 = gdtEntry->Bytes.Flags2;\n\n    //\n    // Finally, handle the VMX-specific bits\n    //\n    VmxGdtEntry->Bits.Reserved = 0;\n    VmxGdtEntry->Bits.Unusable = !gdtEntry->Bits.Present;\n}\n\nUINT32\nShvUtilAdjustMsr (\n    _In_ LARGE_INTEGER ControlValue,\n    _In_ UINT32 DesiredValue\n    )\n{\n    //\n    // VMX feature/capability MSRs encode the \"must be 0\" bits in the high word\n    // of their value, and the \"must be 1\" bits in the low word of their value.\n    // Adjust any requested capability/feature based on these requirements.\n    //\n    DesiredValue &= ControlValue.HighPart;\n    DesiredValue |= ControlValue.LowPart;\n    return DesiredValue;\n}\n\n"
        },
        {
          "name": "shvvmx.c",
          "type": "blob",
          "size": 18.4892578125,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nModule Name:\n\n    shvvmx.c\n\nAbstract:\n\n    This module implements Intel VMX (Vanderpool/VT-x)-specific routines.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only, IRQL DISPATCH_LEVEL.\n\n--*/\n\n#include \"shv.h\"\n\nVOID\nShvVmxMtrrInitialize (\n    _In_ PSHV_VP_DATA VpData\n    )\n{\n    UINT32 i;\n    MTRR_CAPABILITIES mtrrCapabilities;\n    MTRR_VARIABLE_BASE mtrrBase;\n    MTRR_VARIABLE_MASK mtrrMask;\n    unsigned long bit;\n\n    //\n    // Read the capabilities mask\n    //\n    mtrrCapabilities.AsUlonglong = __readmsr(MTRR_MSR_CAPABILITIES);\n\n    //\n    // Iterate over each variable MTRR\n    //\n    for (i = 0; i < mtrrCapabilities.VarCnt; i++)\n    {\n        //\n        // Capture the value\n        //\n        mtrrBase.AsUlonglong = __readmsr(MTRR_MSR_VARIABLE_BASE + i * 2);\n        mtrrMask.AsUlonglong = __readmsr(MTRR_MSR_VARIABLE_MASK + i * 2);\n\n        //\n        // Check if the MTRR is enabled\n        //\n        VpData->MtrrData[i].Type = (UINT32)mtrrBase.Type;\n        VpData->MtrrData[i].Enabled = (UINT32)mtrrMask.Enabled;\n        if (VpData->MtrrData[i].Enabled != FALSE)\n        {\n            //\n            // Set the base\n            //\n            VpData->MtrrData[i].PhysicalAddressMin = mtrrBase.PhysBase *\n                                                     MTRR_PAGE_SIZE;\n\n            //\n            // Compute the length\n            //\n            _BitScanForward64(&bit, mtrrMask.PhysMask * MTRR_PAGE_SIZE);\n            VpData->MtrrData[i].PhysicalAddressMax = VpData->MtrrData[i].\n                                                     PhysicalAddressMin +\n                                                     (1ULL << bit) - 1;\n        }\n    }\n}\n\nUINT32\nShvVmxMtrrAdjustEffectiveMemoryType (\n    _In_ PSHV_VP_DATA VpData,\n    _In_ UINT64 LargePageAddress,\n    _In_ UINT32 CandidateMemoryType\n    )\n{\n    UINT32 i;\n\n    //\n    // Loop each MTRR range\n    //\n    for (i = 0; i < sizeof(VpData->MtrrData) / sizeof(VpData->MtrrData[0]); i++)\n    {\n        //\n        // Check if it's active\n        //\n        if (VpData->MtrrData[i].Enabled != FALSE)\n        {\n            //\n            // Check if this large page falls within the boundary. If a single\n            // physical page (4KB) touches it, we need to override the entire 2MB.\n            //\n            if (((LargePageAddress + (_2MB - 1)) >= VpData->MtrrData[i].PhysicalAddressMin) &&\n                (LargePageAddress <= VpData->MtrrData[i].PhysicalAddressMax))\n            {\n                //\n                // Override candidate type with MTRR type\n                //\n                CandidateMemoryType = VpData->MtrrData[i].Type;\n            }\n        }\n    }\n\n    //\n    // Return the correct type needed\n    //\n    return CandidateMemoryType;\n}\n\nVOID\nShvVmxEptInitialize (\n    _In_ PSHV_VP_DATA VpData\n    )\n{\n    UINT32 i, j;\n    VMX_PDPTE tempEpdpte;\n    VMX_LARGE_PDE tempEpde;\n\n    //\n    // Fill out the EPML4E which covers the first 512GB of RAM\n    //\n    VpData->Epml4[0].Read = 1;\n    VpData->Epml4[0].Write = 1;\n    VpData->Epml4[0].Execute = 1;\n    VpData->Epml4[0].PageFrameNumber = ShvOsGetPhysicalAddress(&VpData->Epdpt) / PAGE_SIZE;\n\n    //\n    // Fill out a RWX PDPTE\n    //\n    tempEpdpte.AsUlonglong = 0;\n    tempEpdpte.Read = tempEpdpte.Write = tempEpdpte.Execute = 1;\n\n    //\n    // Construct EPT identity map for every 1GB of RAM\n    //\n    __stosq((UINT64*)VpData->Epdpt, tempEpdpte.AsUlonglong, PDPTE_ENTRY_COUNT);\n    for (i = 0; i < PDPTE_ENTRY_COUNT; i++)\n    {\n        //\n        // Set the page frame number of the PDE table\n        //\n        VpData->Epdpt[i].PageFrameNumber = ShvOsGetPhysicalAddress(&VpData->Epde[i][0]) / PAGE_SIZE;\n    }\n\n    //\n    // Fill out a RWX Large PDE\n    //\n    tempEpde.AsUlonglong = 0;\n    tempEpde.Read = tempEpde.Write = tempEpde.Execute = 1;\n    tempEpde.Large = 1;\n\n    //\n    // Loop every 1GB of RAM (described by the PDPTE)\n    //\n    __stosq((UINT64*)VpData->Epde, tempEpde.AsUlonglong, PDPTE_ENTRY_COUNT * PDE_ENTRY_COUNT);\n    for (i = 0; i < PDPTE_ENTRY_COUNT; i++)\n    {\n        //\n        // Construct EPT identity map for every 2MB of RAM\n        //\n        for (j = 0; j < PDE_ENTRY_COUNT; j++)\n        {\n            VpData->Epde[i][j].PageFrameNumber = (i * 512) + j;\n            VpData->Epde[i][j].Type = ShvVmxMtrrAdjustEffectiveMemoryType(VpData,\n                                                                          VpData->Epde[i][j].PageFrameNumber * _2MB,\n                                                                          MTRR_TYPE_WB);\n        }\n    }\n}\n\nUINT8\nShvVmxEnterRootModeOnVp (\n    _In_ PSHV_VP_DATA VpData\n    )\n{\n    PSHV_SPECIAL_REGISTERS Registers = &VpData->SpecialRegisters;\n\n    //\n    // Ensure the the VMCS can fit into a single page\n    //\n    if (((VpData->MsrData[0].QuadPart & VMX_BASIC_VMCS_SIZE_MASK) >> 32) > PAGE_SIZE)\n    {\n        return FALSE;\n    }\n\n    //\n    // Ensure that the VMCS is supported in writeback memory\n    //\n    if (((VpData->MsrData[0].QuadPart & VMX_BASIC_MEMORY_TYPE_MASK) >> 50) != MTRR_TYPE_WB)\n    {\n        return FALSE;\n    }\n\n    //\n    // Ensure that true MSRs can be used for capabilities\n    //\n    if (((VpData->MsrData[0].QuadPart) & VMX_BASIC_DEFAULT1_ZERO) == 0)\n    {\n        return FALSE;\n    }\n\n    //\n    // Ensure that EPT is available with the needed features SimpleVisor uses\n    //\n    if (((VpData->MsrData[12].QuadPart & VMX_EPT_PAGE_WALK_4_BIT) != 0) &&\n        ((VpData->MsrData[12].QuadPart & VMX_EPTP_WB_BIT) != 0) &&\n        ((VpData->MsrData[12].QuadPart & VMX_EPT_2MB_PAGE_BIT) != 0))\n    {\n        //\n        // Enable EPT if these features are supported\n        //\n        VpData->EptControls = SECONDARY_EXEC_ENABLE_EPT | SECONDARY_EXEC_ENABLE_VPID;\n    }\n\n    //\n    // Capture the revision ID for the VMXON and VMCS region\n    //\n    VpData->VmxOn.RevisionId = VpData->MsrData[0].LowPart;\n    VpData->Vmcs.RevisionId = VpData->MsrData[0].LowPart;\n\n    //\n    // Store the physical addresses of all per-LP structures allocated\n    //\n    VpData->VmxOnPhysicalAddress = ShvOsGetPhysicalAddress(&VpData->VmxOn);\n    VpData->VmcsPhysicalAddress = ShvOsGetPhysicalAddress(&VpData->Vmcs);\n    VpData->MsrBitmapPhysicalAddress = ShvOsGetPhysicalAddress(VpData->MsrBitmap);\n    VpData->EptPml4PhysicalAddress = ShvOsGetPhysicalAddress(&VpData->Epml4);\n\n    //\n    // Update CR0 with the must-be-zero and must-be-one requirements\n    //\n    Registers->Cr0 &= VpData->MsrData[7].LowPart;\n    Registers->Cr0 |= VpData->MsrData[6].LowPart;\n\n    //\n    // Do the same for CR4\n    //\n    Registers->Cr4 &= VpData->MsrData[9].LowPart;\n    Registers->Cr4 |= VpData->MsrData[8].LowPart;\n\n    //\n    // Update host CR0 and CR4 based on the requirements above\n    //\n    __writecr0(Registers->Cr0);\n    __writecr4(Registers->Cr4);\n\n    //\n    // Enable VMX Root Mode\n    //\n    if (__vmx_on(&VpData->VmxOnPhysicalAddress))\n    {\n        return FALSE;\n    }\n\n    //\n    // Clear the state of the VMCS, setting it to Inactive\n    //\n    if (__vmx_vmclear(&VpData->VmcsPhysicalAddress))\n    {\n        __vmx_off();\n        return FALSE;\n    }\n\n    //\n    // Load the VMCS, setting its state to Active\n    //\n    if (__vmx_vmptrld(&VpData->VmcsPhysicalAddress))\n    {\n        __vmx_off();\n        return FALSE;\n    }\n\n    //\n    // VMX Root Mode is enabled, with an active VMCS.\n    //\n    return TRUE;\n}\n\nVOID\nShvVmxSetupVmcsForVp (\n    _In_ PSHV_VP_DATA VpData\n    )\n{\n    PSHV_SPECIAL_REGISTERS state = &VpData->SpecialRegisters;\n    PCONTEXT context = &VpData->ContextFrame;\n    VMX_GDTENTRY64 vmxGdtEntry;\n    VMX_EPTP vmxEptp;\n\n    //\n    // Begin by setting the link pointer to the required value for 4KB VMCS.\n    //\n    __vmx_vmwrite(VMCS_LINK_POINTER, ~0ULL);\n\n    //\n    // Enable EPT features if supported\n    //\n    if (VpData->EptControls != 0)\n    {\n        //\n        // Configure the EPTP\n        //\n        vmxEptp.AsUlonglong = 0;\n        vmxEptp.PageWalkLength = 3;\n        vmxEptp.Type = MTRR_TYPE_WB;\n        vmxEptp.PageFrameNumber = VpData->EptPml4PhysicalAddress / PAGE_SIZE;\n\n        //\n        // Load EPT Root Pointer\n        //\n        __vmx_vmwrite(EPT_POINTER, vmxEptp.AsUlonglong);\n\n        //\n        // Set VPID to one\n        //\n        __vmx_vmwrite(VIRTUAL_PROCESSOR_ID, 1);\n    }\n\n    //\n    // Load the MSR bitmap. Unlike other bitmaps, not having an MSR bitmap will\n    // trap all MSRs, so we allocated an empty one.\n    //\n    __vmx_vmwrite(MSR_BITMAP, VpData->MsrBitmapPhysicalAddress);\n\n    //\n    // Enable support for RDTSCP and XSAVES/XRESTORES in the guest. Windows 10\n    // makes use of both of these instructions if the CPU supports it. By using\n    // ShvUtilAdjustMsr, these options will be ignored if this processor does\n    // not actually support the instructions to begin with.\n    //\n    // Also enable EPT support, for additional performance and ability to trap\n    // memory access efficiently.\n    //\n    __vmx_vmwrite(SECONDARY_VM_EXEC_CONTROL,\n                           ShvUtilAdjustMsr(VpData->MsrData[11],\n                                            SECONDARY_EXEC_ENABLE_RDTSCP |\n                                            SECONDARY_EXEC_ENABLE_INVPCID |\n                                            SECONDARY_EXEC_XSAVES |\n                                            VpData->EptControls));\n\n    //\n    // Enable no pin-based options ourselves, but there may be some required by\n    // the processor. Use ShvUtilAdjustMsr to add those in.\n    //\n    __vmx_vmwrite(PIN_BASED_VM_EXEC_CONTROL,\n                           ShvUtilAdjustMsr(VpData->MsrData[13], 0));\n\n    //\n    // In order for our choice of supporting RDTSCP and XSAVE/RESTORES above to\n    // actually mean something, we have to request secondary controls. We also\n    // want to activate the MSR bitmap in order to keep them from being caught.\n    //\n    __vmx_vmwrite(CPU_BASED_VM_EXEC_CONTROL,\n                           ShvUtilAdjustMsr(VpData->MsrData[14],\n                                            CPU_BASED_ACTIVATE_MSR_BITMAP |\n                                            CPU_BASED_ACTIVATE_SECONDARY_CONTROLS));\n\n    //\n    // Make sure to enter us in x64 mode at all times.\n    //\n    __vmx_vmwrite(VM_EXIT_CONTROLS,\n                           ShvUtilAdjustMsr(VpData->MsrData[15],\n                                            VM_EXIT_IA32E_MODE));\n\n    //\n    // As we exit back into the guest, make sure to exist in x64 mode as well.\n    //\n    __vmx_vmwrite(VM_ENTRY_CONTROLS,\n                           ShvUtilAdjustMsr(VpData->MsrData[16],\n                                            VM_ENTRY_IA32E_MODE));\n\n    //\n    // Load the CS Segment (Ring 0 Code)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, context->SegCs, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_CS_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_CS_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_CS_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_CS_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_CS_SELECTOR, context->SegCs & ~RPL_MASK);\n\n    //\n    // Load the SS Segment (Ring 0 Data)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, context->SegSs, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_SS_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_SS_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_SS_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_SS_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_SS_SELECTOR, context->SegSs & ~RPL_MASK);\n\n    //\n    // Load the DS Segment (Ring 3 Data)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, context->SegDs, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_DS_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_DS_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_DS_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_DS_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_DS_SELECTOR, context->SegDs & ~RPL_MASK);\n\n    //\n    // Load the ES Segment (Ring 3 Data)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, context->SegEs, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_ES_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_ES_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_ES_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_ES_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_ES_SELECTOR, context->SegEs & ~RPL_MASK);\n\n    //\n    // Load the FS Segment (Ring 3 Compatibility-Mode TEB)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, context->SegFs, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_FS_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_FS_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_FS_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_FS_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_FS_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_FS_SELECTOR, context->SegFs & ~RPL_MASK);\n\n    //\n    // Load the GS Segment (Ring 3 Data if in Compatibility-Mode, MSR-based in Long Mode)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, context->SegGs, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_GS_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_GS_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_GS_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_GS_BASE, state->MsrGsBase);\n    __vmx_vmwrite(HOST_GS_BASE, state->MsrGsBase);\n    __vmx_vmwrite(HOST_GS_SELECTOR, context->SegGs & ~RPL_MASK);\n\n    //\n    // Load the Task Register (Ring 0 TSS)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, state->Tr, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_TR_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_TR_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_TR_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_TR_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_TR_BASE, vmxGdtEntry.Base);\n    __vmx_vmwrite(HOST_TR_SELECTOR, state->Tr & ~RPL_MASK);\n\n    //\n    // Load the Local Descriptor Table (Ring 0 LDT on Redstone)\n    //\n    ShvUtilConvertGdtEntry(state->Gdtr.Base, state->Ldtr, &vmxGdtEntry);\n    __vmx_vmwrite(GUEST_LDTR_SELECTOR, vmxGdtEntry.Selector);\n    __vmx_vmwrite(GUEST_LDTR_LIMIT, vmxGdtEntry.Limit);\n    __vmx_vmwrite(GUEST_LDTR_AR_BYTES, vmxGdtEntry.AccessRights);\n    __vmx_vmwrite(GUEST_LDTR_BASE, vmxGdtEntry.Base);\n\n    //\n    // Now load the GDT itself\n    //\n    __vmx_vmwrite(GUEST_GDTR_BASE, (uintptr_t)state->Gdtr.Base);\n    __vmx_vmwrite(GUEST_GDTR_LIMIT, state->Gdtr.Limit);\n    __vmx_vmwrite(HOST_GDTR_BASE, (uintptr_t)state->Gdtr.Base);\n\n    //\n    // And then the IDT\n    //\n    __vmx_vmwrite(GUEST_IDTR_BASE, (uintptr_t)state->Idtr.Base);\n    __vmx_vmwrite(GUEST_IDTR_LIMIT, state->Idtr.Limit);\n    __vmx_vmwrite(HOST_IDTR_BASE, (uintptr_t)state->Idtr.Base);\n\n    //\n    // Load CR0\n    //\n    __vmx_vmwrite(CR0_READ_SHADOW, state->Cr0);\n    __vmx_vmwrite(HOST_CR0, state->Cr0);\n    __vmx_vmwrite(GUEST_CR0, state->Cr0);\n\n    //\n    // Load CR3 -- do not use the current process' address space for the host,\n    // because we may be executing in an arbitrary user-mode process right now\n    // as part of the DPC interrupt we execute in.\n    //\n    __vmx_vmwrite(HOST_CR3, VpData->SystemDirectoryTableBase);\n    __vmx_vmwrite(GUEST_CR3, state->Cr3);\n\n    //\n    // Load CR4\n    //\n    __vmx_vmwrite(HOST_CR4, state->Cr4);\n    __vmx_vmwrite(GUEST_CR4, state->Cr4);\n    __vmx_vmwrite(CR4_READ_SHADOW, state->Cr4);\n\n    //\n    // Load debug MSR and register (DR7)\n    //\n    __vmx_vmwrite(GUEST_IA32_DEBUGCTL, state->DebugControl);\n    __vmx_vmwrite(GUEST_DR7, state->KernelDr7);\n\n    //\n    // Finally, load the guest stack, instruction pointer, and rflags, which\n    // corresponds exactly to the location where RtlCaptureContext will return\n    // to inside of ShvVpInitialize.\n    //\n    __vmx_vmwrite(GUEST_RSP, (uintptr_t)VpData->ShvStackLimit + KERNEL_STACK_SIZE - sizeof(CONTEXT));\n    __vmx_vmwrite(GUEST_RIP, (uintptr_t)ShvVpRestoreAfterLaunch);\n    __vmx_vmwrite(GUEST_RFLAGS, context->EFlags);\n\n    //\n    // Load the hypervisor entrypoint and stack. We give ourselves a standard\n    // size kernel stack (24KB) and bias for the context structure that the\n    // hypervisor entrypoint will push on the stack, avoiding the need for RSP\n    // modifying instructions in the entrypoint. Note that the CONTEXT pointer\n    // and thus the stack itself, must be 16-byte aligned for ABI compatibility\n    // with AMD64 -- specifically, XMM operations will fail otherwise, such as\n    // the ones that RtlCaptureContext will perform.\n    //\n    C_ASSERT((KERNEL_STACK_SIZE - sizeof(CONTEXT)) % 16 == 0);\n    __vmx_vmwrite(HOST_RSP, (uintptr_t)VpData->ShvStackLimit + KERNEL_STACK_SIZE - sizeof(CONTEXT));\n    __vmx_vmwrite(HOST_RIP, (uintptr_t)ShvVmxEntry);\n}\n\nUINT8\nShvVmxProbe (\n    VOID\n    )\n{\n    INT32 cpu_info[4];\n    UINT64 featureControl;\n\n    //\n    // Check the Hypervisor Present-bit\n    //\n    __cpuid(cpu_info, 1);\n    if ((cpu_info[2] & 0x20) == FALSE)\n    {\n        return FALSE;\n    }\n\n    //\n    // Check if the Feature Control MSR is locked. If it isn't, this means that\n    // BIOS/UEFI firmware screwed up, and we could go around locking it, but\n    // we'd rather not mess with it.\n    //\n    featureControl = __readmsr(IA32_FEATURE_CONTROL_MSR);\n    if (!(featureControl & IA32_FEATURE_CONTROL_MSR_LOCK))\n    {\n        return FALSE;\n    }\n\n    //\n    // The Feature Control MSR is locked-in (valid). Is VMX enabled in normal\n    // operation mode?\n    //\n    if (!(featureControl & IA32_FEATURE_CONTROL_MSR_ENABLE_VMXON_OUTSIDE_SMX))\n    {\n        return FALSE;\n    }\n\n    //\n    // Both the hardware and the firmware are allowing us to enter VMX mode.\n    //\n    return TRUE;\n}\n\nINT32\nShvVmxLaunchOnVp (\n    _In_ PSHV_VP_DATA VpData\n    )\n{\n    UINT32 i;\n\n    //\n    // Initialize all the VMX-related MSRs by reading their value\n    //\n    for (i = 0; i < sizeof(VpData->MsrData) / sizeof(VpData->MsrData[0]); i++)\n    {\n        VpData->MsrData[i].QuadPart = __readmsr(MSR_IA32_VMX_BASIC + i);\n    }\n\n    //\n    // Initialize all the MTRR-related MSRs by reading their value and build\n    // range structures to describe their settings\n    //\n    ShvVmxMtrrInitialize(VpData);\n\n    //\n    // Initialize the EPT structures\n    //\n    ShvVmxEptInitialize(VpData);\n\n    //\n    // Attempt to enter VMX root mode on this processor.\n    //\n    if (ShvVmxEnterRootModeOnVp(VpData) == FALSE)\n    {\n        //\n        // We could not enter VMX Root mode\n        //\n        return SHV_STATUS_NOT_AVAILABLE;\n    }\n\n    //\n    // Initialize the VMCS, both guest and host state.\n    //\n    ShvVmxSetupVmcsForVp(VpData);\n\n    //\n    // Launch the VMCS, based on the guest data that was loaded into the\n    // various VMCS fields by ShvVmxSetupVmcsForVp. This will cause the\n    // processor to jump to ShvVpRestoreAfterLaunch on success, or return\n    // back to the caller on failure.\n    //\n    return ShvVmxLaunch();\n}\n"
        },
        {
          "name": "shvvmxhv.c",
          "type": "blob",
          "size": 9.693359375,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nModule Name:\n\n    shvvmxhv.c\n\nAbstract:\n\n    This module implements the Simple Hyper Visor itself.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Hypervisor mode only, IRQL MAX_IRQL\n\n--*/\n\n#include \"shv.h\"\n\nDECLSPEC_NORETURN\nVOID\nShvVmxResume (\n    VOID\n    )\n{\n    //\n    // Issue a VMXRESUME. The reason that we've defined an entire function for\n    // this sole instruction is both so that we can use it as the target of the\n    // VMCS when re-entering the VM After a VM-Exit, as well as so that we can\n    // decorate it with the DECLSPEC_NORETURN marker, which is not set on the\n    // intrinsic (as it can fail in case of an error).\n    //\n    __vmx_vmresume();\n}\n\nuintptr_t\nFORCEINLINE\nShvVmxRead (\n    _In_ UINT32 VmcsFieldId\n    )\n{\n    size_t FieldData;\n\n    //\n    // Because VMXREAD returns an error code, and not the data, it is painful\n    // to use in most circumstances. This simple function simplifies it use.\n    //\n    __vmx_vmread(VmcsFieldId, &FieldData);\n    return FieldData;\n}\n\nINT32\nShvVmxLaunch (\n    VOID\n    )\n{\n    INT32 failureCode;\n\n    //\n    // Launch the VMCS\n    //\n    __vmx_vmlaunch();\n\n    //\n    // If we got here, either VMCS setup failed in some way, or the launch\n    // did not proceed as planned.\n    //\n    failureCode = (INT32)ShvVmxRead(VM_INSTRUCTION_ERROR);\n    __vmx_off();\n\n    //\n    // Return the error back to the caller\n    //\n    return failureCode;\n}\n\nVOID\nShvVmxHandleInvd (\n    VOID\n    )\n{\n    //\n    // This is the handler for the INVD instruction. Technically it may be more\n    // correct to use __invd instead of __wbinvd, but that intrinsic doesn't\n    // actually exist. Additionally, the Windows kernel (or HAL) don't contain\n    // any example of INVD actually ever being used. Finally, Hyper-V itself\n    // handles INVD by issuing WBINVD as well, so we'll just do that here too.\n    //\n    __wbinvd();\n}\n\nVOID\nShvVmxHandleCpuid (\n    _In_ PSHV_VP_STATE VpState\n    )\n{\n    INT32 cpu_info[4];\n\n    //\n    // Check for the magic CPUID sequence, and check that it is coming from\n    // Ring 0. Technically we could also check the RIP and see if this falls\n    // in the expected function, but we may want to allow a separate \"unload\"\n    // driver or code at some point.\n    //\n    if ((VpState->VpRegs->Rax == 0x41414141) &&\n        (VpState->VpRegs->Rcx == 0x42424242) &&\n        ((ShvVmxRead(GUEST_CS_SELECTOR) & RPL_MASK) == DPL_SYSTEM))\n    {\n        VpState->ExitVm = TRUE;\n        return;\n    }\n\n    //\n    // Otherwise, issue the CPUID to the logical processor based on the indexes\n    // on the VP's GPRs.\n    //\n    __cpuidex(cpu_info, (INT32)VpState->VpRegs->Rax, (INT32)VpState->VpRegs->Rcx);\n\n    //\n    // Check if this was CPUID 1h, which is the features request.\n    //\n    if (VpState->VpRegs->Rax == 1)\n    {\n        //\n        // Set the Hypervisor Present-bit in RCX, which Intel and AMD have both\n        // reserved for this indication.\n        //\n        cpu_info[2] |= HYPERV_HYPERVISOR_PRESENT_BIT;\n    }\n    else if (VpState->VpRegs->Rax == HYPERV_CPUID_INTERFACE)\n    {\n        //\n        // Return our interface identifier\n        //\n        cpu_info[0] = ' vhS';\n    }\n\n    //\n    // Copy the values from the logical processor registers into the VP GPRs.\n    //\n    VpState->VpRegs->Rax = cpu_info[0];\n    VpState->VpRegs->Rbx = cpu_info[1];\n    VpState->VpRegs->Rcx = cpu_info[2];\n    VpState->VpRegs->Rdx = cpu_info[3];\n}\n\nVOID\nShvVmxHandleXsetbv (\n    _In_ PSHV_VP_STATE VpState\n    )\n{\n    //\n    // Simply issue the XSETBV instruction on the native logical processor.\n    //\n\n    _xsetbv((UINT32)VpState->VpRegs->Rcx,\n            VpState->VpRegs->Rdx << 32 |\n            VpState->VpRegs->Rax);\n}\n\nVOID\nShvVmxHandleVmx (\n    _In_ PSHV_VP_STATE VpState\n    )\n{\n    //\n    // Set the CF flag, which is how VMX instructions indicate failure\n    //\n    VpState->GuestEFlags |= 0x1; // VM_FAIL_INVALID\n\n    //\n    // RFLAGs is actually restored from the VMCS, so update it here\n    //\n    __vmx_vmwrite(GUEST_RFLAGS, VpState->GuestEFlags);\n}\n\nVOID\nShvVmxHandleExit (\n    _In_ PSHV_VP_STATE VpState\n    )\n{\n    //\n    // This is the generic VM-Exit handler. Decode the reason for the exit and\n    // call the appropriate handler. As per Intel specifications, given that we\n    // have requested no optional exits whatsoever, we should only see CPUID,\n    // INVD, XSETBV and other VMX instructions. GETSEC cannot happen as we do\n    // not run in SMX context.\n    //\n    switch (VpState->ExitReason)\n    {\n    case EXIT_REASON_CPUID:\n        ShvVmxHandleCpuid(VpState);\n        break;\n    case EXIT_REASON_INVD:\n        ShvVmxHandleInvd();\n        break;\n    case EXIT_REASON_XSETBV:\n        ShvVmxHandleXsetbv(VpState);\n        break;\n    case EXIT_REASON_VMCALL:\n    case EXIT_REASON_VMCLEAR:\n    case EXIT_REASON_VMLAUNCH:\n    case EXIT_REASON_VMPTRLD:\n    case EXIT_REASON_VMPTRST:\n    case EXIT_REASON_VMREAD:\n    case EXIT_REASON_VMRESUME:\n    case EXIT_REASON_VMWRITE:\n    case EXIT_REASON_VMXOFF:\n    case EXIT_REASON_VMXON:\n        ShvVmxHandleVmx(VpState);\n        break;\n    default:\n        break;\n    }\n\n    //\n    // Move the instruction pointer to the next instruction after the one that\n    // caused the exit. Since we are not doing any special handling or changing\n    // of execution, this can be done for any exit reason.\n    //\n    VpState->GuestRip += ShvVmxRead(VM_EXIT_INSTRUCTION_LEN);\n    __vmx_vmwrite(GUEST_RIP, VpState->GuestRip);\n}\n\nDECLSPEC_NORETURN\nVOID\nShvVmxEntryHandler (\n    _In_ PCONTEXT Context\n    )\n{\n    SHV_VP_STATE guestContext;\n    PSHV_VP_DATA vpData;\n\n    //\n    // Because we had to use RCX when calling ShvOsCaptureContext, its value\n    // was actually pushed on the stack right before the call. Go dig into the\n    // stack to find it, and overwrite the bogus value that's there now.\n    //\n    Context->Rcx = *(UINT64*)((uintptr_t)Context - sizeof(Context->Rcx));\n\n    //\n    // Get the per-VP data for this processor.\n    //\n    vpData = (VOID*)((uintptr_t)(Context + 1) - KERNEL_STACK_SIZE);\n\n    //\n    // Build a little stack context to make it easier to keep track of certain\n    // guest state, such as the RIP/RSP/RFLAGS, and the exit reason. The rest\n    // of the general purpose registers come from the context structure that we\n    // captured on our own with RtlCaptureContext in the assembly entrypoint.\n    //\n    guestContext.GuestEFlags = ShvVmxRead(GUEST_RFLAGS);\n    guestContext.GuestRip = ShvVmxRead(GUEST_RIP);\n    guestContext.GuestRsp = ShvVmxRead(GUEST_RSP);\n    guestContext.ExitReason = ShvVmxRead(VM_EXIT_REASON) & 0xFFFF;\n    guestContext.VpRegs = Context;\n    guestContext.ExitVm = FALSE;\n\n    //\n    // Call the generic handler\n    //\n    ShvVmxHandleExit(&guestContext);\n\n    //\n    // Did we hit the magic exit sequence, or should we resume back to the VM\n    // context?\n    //\n    if (guestContext.ExitVm != FALSE)\n    {\n        //\n        // Return the VP Data structure in RAX:RBX which is going to be part of\n        // the CPUID response that the caller (ShvVpUninitialize) expects back.\n        // Return confirmation in RCX that we are loaded\n        //\n        Context->Rax = (uintptr_t)vpData >> 32;\n        Context->Rbx = (uintptr_t)vpData & 0xFFFFFFFF;\n        Context->Rcx = 0x43434343;\n\n        //\n        // Perform any OS-specific CPU uninitialization work\n        //\n        ShvOsUnprepareProcessor(vpData);\n\n        //\n        // Our callback routine may have interrupted an arbitrary user process,\n        // and therefore not a thread running with a systemwide page directory.\n        // Therefore if we return back to the original caller after turning off\n        // VMX, it will keep our current \"host\" CR3 value which we set on entry\n        // to the PML4 of the SYSTEM process. We want to return back with the\n        // correct value of the \"guest\" CR3, so that the currently executing\n        // process continues to run with its expected address space mappings.\n        //\n        __writecr3(ShvVmxRead(GUEST_CR3));\n\n        //\n        // Finally, restore the stack, instruction pointer and EFLAGS to the\n        // original values present when the instruction causing our VM-Exit\n        // execute (such as ShvVpUninitialize). This will effectively act as\n        // a longjmp back to that location.\n        //\n        Context->Rsp = guestContext.GuestRsp;\n        Context->Rip = (UINT64)guestContext.GuestRip;\n        Context->EFlags = (UINT32)guestContext.GuestEFlags;\n\n        //\n        // Turn off VMX root mode on this logical processor. We're done here.\n        //\n        __vmx_off();\n    }\n    else\n    {\n        //\n        // Because we won't be returning back into assembly code, nothing will\n        // ever know about the \"pop rcx\" that must technically be done (or more\n        // accurately \"add rsp, 4\" as rcx will already be correct thanks to the\n        // fixup earlier. In order to keep the stack sane, do that adjustment\n        // here.\n        //\n        Context->Rsp += sizeof(Context->Rcx);\n\n        //\n        // Return into a VMXRESUME intrinsic, which we broke out as its own\n        // function, in order to allow this to work. No assembly code will be\n        // needed as RtlRestoreContext will fix all the GPRs, and what we just\n        // did to RSP will take care of the rest.\n        //\n        Context->Rip = (UINT64)ShvVmxResume;\n    }\n\n    //\n    // Restore the context to either ShvVmxResume, in which case the CPU's VMX\n    // facility will do the \"true\" return back to the VM (but without restoring\n    // GPRs, which is why we must do it here), or to the original guest's RIP,\n    // which we use in case an exit was requested. In this case VMX must now be\n    // off, and this will look like a longjmp to the original stack and RIP.\n    //\n    ShvOsRestoreContext(Context);\n}\n\n"
        },
        {
          "name": "shvvmxhvx64.asm",
          "type": "blob",
          "size": 1.3369140625,
          "content": ";++\n;\n; Copyright (c) Alex Ionescu.  All rights reserved.\n;\n; Module:\n;\n;    shvvmxhvx64.asm\n;\n; Abstract:\n;\n;    This module implements the AMD64-specific SimpleVisor VMENTRY routine.\n;\n; Author:\n;\n;    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n;\n; Environment:\n;\n;    Kernel mode only.\n;\n;--\n\n    .code\n\n    extern ShvVmxEntryHandler:proc\n    extern ShvOsCaptureContext:proc\n\n    ShvVmxEntry PROC\n    push    rcx                 ; save the RCX register, which we spill below\n    lea     rcx, [rsp+8h]       ; store the context in the stack, bias for\n                                ; the return address and the push we just did.\n    call    ShvOsCaptureContext ; save the current register state.\n                                ; note that this is a specially written function\n                                ; which has the following key characteristics:\n                                ;   1) it does not taint the value of RCX\n                                ;   2) it does not spill any registers, nor\n                                ;      expect home space to be allocated for it\n    jmp     ShvVmxEntryHandler  ; jump to the C code handler. we assume that it\n                                ; compiled with optimizations and does not use\n                                ; home space, which is true of release builds.\n    ShvVmxEntry ENDP\n\n    end\n"
        },
        {
          "name": "shvvp.c",
          "type": "blob",
          "size": 7.158203125,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nModule Name:\n\n    shvvp.c\n\nAbstract:\n\n    This module implements Virtual Processor (VP) management for the Simple Hyper Visor.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only, IRQL DISPATCH_LEVEL.\n\n--*/\n\n#include \"shv.h\"\n\nUINT8\nShvIsOurHypervisorPresent (\n    VOID\n    )\n{\n    INT32 cpuInfo[4];\n\n    //\n    // Check if ECX[31h] (\"Hypervisor Present Bit\") is set in CPUID 1h\n    //\n    __cpuid(cpuInfo, 1);\n    if (cpuInfo[2] & HYPERV_HYPERVISOR_PRESENT_BIT)\n    {\n        //\n        // Next, check if this is a compatible Hypervisor, and if it has the\n        // SimpleVisor signature\n        //\n        __cpuid(cpuInfo, HYPERV_CPUID_INTERFACE);\n        if (cpuInfo[0] == ' vhS')\n        {\n            //\n            // It's us!\n            //\n            return TRUE;\n        }\n    }\n\n    //\n    // No Hypervisor, or someone else's\n    //\n    return FALSE;\n}\n\nVOID\nShvCaptureSpecialRegisters (\n    _In_ PSHV_SPECIAL_REGISTERS SpecialRegisters\n    )\n{\n    //\n    // Use compiler intrinsics to get the data we need\n    //\n    SpecialRegisters->Cr0 = __readcr0();\n    SpecialRegisters->Cr3 = __readcr3();\n    SpecialRegisters->Cr4 = __readcr4();\n    SpecialRegisters->DebugControl = __readmsr(MSR_DEBUG_CTL);\n    SpecialRegisters->MsrGsBase = __readmsr(MSR_GS_BASE);\n    SpecialRegisters->KernelDr7 = __readdr(7);\n    _sgdt(&SpecialRegisters->Gdtr.Limit);\n    __sidt(&SpecialRegisters->Idtr.Limit);\n\n    //\n    // Use OS-specific functions to get these two\n    //\n    _str(&SpecialRegisters->Tr);\n    _sldt(&SpecialRegisters->Ldtr);\n}\n\nDECLSPEC_NORETURN\nVOID\nShvVpRestoreAfterLaunch (\n    VOID\n    )\n{\n    PSHV_VP_DATA vpData;\n\n    //\n    // Get the per-processor data. This routine temporarily executes on the\n    // same stack as the hypervisor (using no real stack space except the home\n    // registers), so we can retrieve the VP the same way the hypervisor does.\n    //\n    vpData = (PSHV_VP_DATA)((uintptr_t)_AddressOfReturnAddress() +\n                            sizeof(CONTEXT) -\n                            KERNEL_STACK_SIZE);\n\n    //\n    // Record that VMX is now enabled by returning back to ShvVpInitialize with\n    // the Alignment Check (AC) bit set.\n    //\n    vpData->ContextFrame.EFlags |= EFLAGS_ALIGN_CHECK;\n\n    //\n    // And finally, restore the context, so that all register and stack\n    // state is finally restored.\n    //\n    ShvOsRestoreContext(&vpData->ContextFrame);\n}\n\nINT32\nShvVpInitialize (\n    _In_ PSHV_VP_DATA Data\n    )\n{\n    INT32 status;\n\n    //\n    // Prepare any OS-specific CPU data\n    //\n    status = ShvOsPrepareProcessor(Data);\n    if (status != SHV_STATUS_SUCCESS)\n    {\n        return status;\n    }\n\n    // Read the special control registers for this processor\n    // Note: KeSaveStateForHibernate(&Data->HostState) can be used as a Windows\n    // specific undocumented function that can also get this data.\n    //\n    ShvCaptureSpecialRegisters(&Data->SpecialRegisters);\n\n    //\n    // Then, capture the entire register state. We will need this, as once we\n    // launch the VM, it will begin execution at the defined guest instruction\n    // pointer, which we set to ShvVpRestoreAfterLaunch, with the registers set\n    // to whatever value they were deep inside the VMCS/VMX initialization code.\n    // By using RtlRestoreContext, that function sets the AC flag in EFLAGS and\n    // returns here with our registers restored.\n    //\n    ShvOsCaptureContext(&Data->ContextFrame);\n    if ((__readeflags() & EFLAGS_ALIGN_CHECK) == 0)\n    {\n        //\n        // If the AC bit is not set in EFLAGS, it means that we have not yet\n        // launched the VM. Attempt to initialize VMX on this processor.\n        //\n        status = ShvVmxLaunchOnVp(Data);\n    }\n\n    //\n    // If we got here, the hypervisor is running :-)\n    //\n    return status;\n}\n\nVOID\nShvVpUnloadCallback (\n    _In_ PSHV_CALLBACK_CONTEXT Context\n    )\n{\n    INT32 cpuInfo[4];\n    PSHV_VP_DATA vpData;\n    UNREFERENCED_PARAMETER(Context);\n\n    //\n    // Send the magic shutdown instruction sequence. It will return in EAX:EBX\n    // the VP data for the current CPU, which we must free.\n    //\n    cpuInfo[0] = cpuInfo[1] = 0;\n    __cpuidex(cpuInfo, 0x41414141, 0x42424242);\n\n    //\n    // If SimpleVisor is disabled for some reason, CPUID will return the values\n    // of the highest valid CPUID. We use a magic value to make sure we really\n    // are loaded and returned something valid.\n    //\n    if (cpuInfo[2] == 0x43434343)\n    {\n        __analysis_assume((cpuInfo[0] != 0) && (cpuInfo[1] != 0));\n        vpData = (PSHV_VP_DATA)((UINT64)cpuInfo[0] << 32 | (UINT32)cpuInfo[1]);\n        ShvOsFreeContiguousAlignedMemory(vpData, sizeof(*vpData));\n    }\n}\n\nPSHV_VP_DATA\nShvVpAllocateData (\n    _In_ UINT32 CpuCount\n    )\n{\n    PSHV_VP_DATA data;\n\n    //\n    // Allocate a contiguous chunk of RAM to back this allocation\n    //\n    data = ShvOsAllocateContigousAlignedMemory(sizeof(*data) * CpuCount);\n    if (data != NULL)\n    {\n        //\n        // Zero out the entire data region\n        //\n        __stosq((UINT64*)data, 0, (sizeof(*data) / sizeof(UINT64)) * CpuCount);\n    }\n\n    //\n    // Return what is hopefully a valid pointer, otherwise NULL.\n    //\n    return data;\n}\n\nVOID\nShvVpFreeData (\n    _In_ PSHV_VP_DATA Data,\n    _In_ UINT32 CpuCount\n    )\n{\n    //\n    // Free the contiguous chunk of RAM\n    //\n    ShvOsFreeContiguousAlignedMemory(Data, sizeof(*Data) * CpuCount);\n}\n\nVOID\nShvVpLoadCallback (\n    _In_ PSHV_CALLBACK_CONTEXT Context\n    )\n{\n    PSHV_VP_DATA vpData;\n    INT32 status;\n\n    vpData = NULL;\n\n    //\n    // Detect if the hardware appears to support VMX root mode to start.\n    // No attempts are made to enable this if it is lacking or disabled.\n    //\n    if (!ShvVmxProbe())\n    {\n        status = SHV_STATUS_NOT_AVAILABLE;\n        goto Failure;\n    }\n\n    //\n    // Allocate the per-VP data for this logical processor\n    //\n    vpData = ShvVpAllocateData(1);\n    if (vpData == NULL)\n    {\n        status = SHV_STATUS_NO_RESOURCES;\n        goto Failure;\n    }\n\n    //\n    // First, capture the value of the PML4 for the SYSTEM process, so that all\n    // virtual processors, regardless of which process the current LP has\n    // interrupted, can share the correct kernel address space.\n    //\n    vpData->SystemDirectoryTableBase = Context->Cr3;\n\n    //\n    // Initialize the virtual processor\n    //\n    status = ShvVpInitialize(vpData);\n    if (status != SHV_STATUS_SUCCESS)\n    {\n        //\n        // Bail out, free the allocated per-processor data\n        //\n        goto Failure;\n    }\n\n    //\n    // Our hypervisor should now be seen as present on this LP, as the SHV\n    // correctly handles CPUID ECX features register.\n    //\n    if (ShvIsOurHypervisorPresent() == FALSE)\n    {\n        //\n        // Free the per-processor data\n        //\n        status = SHV_STATUS_NOT_PRESENT;\n        goto Failure;\n    }\n\n    //\n    // This CPU is hyperjacked!\n    //\n    _InterlockedIncrement((volatile long*)&Context->InitCount);\n    return;\n\nFailure:\n    //\n    // Return failure\n    //\n    if (vpData != NULL)\n    {\n        ShvVpFreeData(vpData, 1);\n    }\n    Context->FailedCpu = ShvOsGetCurrentProcessorNumber();\n    Context->FailureStatus = status;\n    return;\n}\n"
        },
        {
          "name": "uefi",
          "type": "tree",
          "content": null
        },
        {
          "name": "vmx.h",
          "type": "blob",
          "size": 23.2431640625,
          "content": "/*++\n\nCopyright (c) Alex Ionescu.  All rights reserved.\n\nHeader Name:\n\n    vmx.h\n\nAbstract:\n\n    This header defines the MSRs and VMCS fields for Intel x64 VT-x support.\n\nAuthor:\n\n    Alex Ionescu (@aionescu) 16-Mar-2016 - Initial version\n\nEnvironment:\n\n    Kernel mode only.\n\n--*/\n\n#pragma once\n#pragma warning(disable:4201)\n#pragma warning(disable:4214)\n\n#define DPL_USER                3\n#define DPL_SYSTEM              0\n#define MSR_GS_BASE             0xC0000101\n#define MSR_DEBUG_CTL           0x1D9\n#define RPL_MASK                3\n#define MTRR_TYPE_UC            0\n#define MTRR_TYPE_USWC          1\n#define MTRR_TYPE_WT            4\n#define MTRR_TYPE_WP            5\n#define MTRR_TYPE_WB            6\n#define MTRR_TYPE_MAX           7\n#define SELECTOR_TABLE_INDEX    0x04\n#define EFLAGS_ALIGN_CHECK      0x40000\n#define AMD64_TSS               9\n#ifndef PAGE_SIZE\n#define PAGE_SIZE               4096\n#endif\n#define MTRR_MSR_CAPABILITIES   0x0fe\n#define MTRR_MSR_DEFAULT        0x2ff\n#define MTRR_MSR_VARIABLE_BASE  0x200\n#define MTRR_MSR_VARIABLE_MASK  (MTRR_MSR_VARIABLE_BASE+1)\n#define MTRR_PAGE_SIZE          4096\n#define MTRR_PAGE_MASK          (~(MTRR_PAGE_SIZE-1))\n\ntypedef struct _KDESCRIPTOR\n{\n    UINT16 Pad[3];\n    UINT16 Limit;\n    void* Base;\n} KDESCRIPTOR, *PKDESCRIPTOR;\n\ntypedef union _KGDTENTRY64\n{\n    struct\n    {\n        UINT16 LimitLow;\n        UINT16 BaseLow;\n        union\n        {\n            struct\n            {\n                UINT8 BaseMiddle;\n                UINT8 Flags1;\n                UINT8 Flags2;\n                UINT8 BaseHigh;\n            } Bytes;\n            struct\n            {\n                UINT32 BaseMiddle : 8;\n                UINT32 Type : 5;\n                UINT32 Dpl : 2;\n                UINT32 Present : 1;\n                UINT32 LimitHigh : 4;\n                UINT32 System : 1;\n                UINT32 LongMode : 1;\n                UINT32 DefaultBig : 1;\n                UINT32 Granularity : 1;\n                UINT32 BaseHigh : 8;\n            } Bits;\n        };\n        UINT32 BaseUpper;\n        UINT32 MustBeZero;\n    };\n    struct\n    {\n        INT64 DataLow;\n        INT64 DataHigh;\n    };\n} KGDTENTRY64, *PKGDTENTRY64;\n\n#pragma pack(push,4)\ntypedef struct _KTSS64\n{\n    UINT32 Reserved0;\n    UINT64 Rsp0;\n    UINT64 Rsp1;\n    UINT64 Rsp2;\n    UINT64 Ist[8];\n    UINT64 Reserved1;\n    UINT16 Reserved2;\n    UINT16 IoMapBase;\n} KTSS64, *PKTSS64;\n#pragma pack(pop)\n\ntypedef struct _MTRR_CAPABILITIES\n{\n    union\n    {\n        struct\n        {\n            UINT64 VarCnt : 8;\n            UINT64 FixedSupported : 1;\n            UINT64 Reserved : 1;\n            UINT64 WcSupported : 1;\n            UINT64 SmrrSupported : 1;\n            UINT64 Reserved_2 : 52;\n        };\n        UINT64 AsUlonglong;\n    };\n} MTRR_CAPABILITIES, *PMTRR_CAPABILITIES;\nC_ASSERT(sizeof(MTRR_CAPABILITIES) == sizeof(UINT64));\n\ntypedef struct _MTRR_VARIABLE_BASE\n{\n    union\n    {\n        struct\n        {\n            UINT64 Type : 8;\n            UINT64 Reserved : 4;\n            UINT64 PhysBase : 36;\n            UINT64 Reserved2 : 16;\n        };\n        UINT64 AsUlonglong;\n    };\n} MTRR_VARIABLE_BASE, *PMTRR_VARIABLE_BASE;\nC_ASSERT(sizeof(MTRR_VARIABLE_BASE) == sizeof(UINT64));\n\ntypedef struct _MTRR_VARIABLE_MASK\n{\n    union\n    {\n        struct\n        {\n            UINT64 Reserved : 11;\n            UINT64 Enabled : 1;\n            UINT64 PhysMask : 36;\n            UINT64 Reserved2 : 16;\n        };\n        UINT64 AsUlonglong;\n    };\n} MTRR_VARIABLE_MASK, *PMTRR_VARIABLE_MASK;\nC_ASSERT(sizeof(MTRR_VARIABLE_MASK) == sizeof(UINT64));\n\n#define CPU_BASED_VIRTUAL_INTR_PENDING          0x00000004\n#define CPU_BASED_USE_TSC_OFFSETING             0x00000008\n#define CPU_BASED_HLT_EXITING                   0x00000080\n#define CPU_BASED_INVLPG_EXITING                0x00000200\n#define CPU_BASED_MWAIT_EXITING                 0x00000400\n#define CPU_BASED_RDPMC_EXITING                 0x00000800\n#define CPU_BASED_RDTSC_EXITING                 0x00001000\n#define CPU_BASED_CR3_LOAD_EXITING              0x00008000\n#define CPU_BASED_CR3_STORE_EXITING             0x00010000\n#define CPU_BASED_CR8_LOAD_EXITING              0x00080000\n#define CPU_BASED_CR8_STORE_EXITING             0x00100000\n#define CPU_BASED_TPR_SHADOW                    0x00200000\n#define CPU_BASED_VIRTUAL_NMI_PENDING           0x00400000\n#define CPU_BASED_MOV_DR_EXITING                0x00800000\n#define CPU_BASED_UNCOND_IO_EXITING             0x01000000\n#define CPU_BASED_ACTIVATE_IO_BITMAP            0x02000000\n#define CPU_BASED_MONITOR_TRAP_FLAG             0x08000000\n#define CPU_BASED_ACTIVATE_MSR_BITMAP           0x10000000\n#define CPU_BASED_MONITOR_EXITING               0x20000000\n#define CPU_BASED_PAUSE_EXITING                 0x40000000\n#define CPU_BASED_ACTIVATE_SECONDARY_CONTROLS   0x80000000\n\n#define PIN_BASED_EXT_INTR_MASK                 0x00000001\n#define PIN_BASED_NMI_EXITING                   0x00000008\n#define PIN_BASED_VIRTUAL_NMIS                  0x00000020\n#define PIN_BASED_PREEMPT_TIMER                 0x00000040\n#define PIN_BASED_POSTED_INTERRUPT              0x00000080\n\n#define VM_EXIT_SAVE_DEBUG_CNTRLS               0x00000004\n#define VM_EXIT_IA32E_MODE                      0x00000200\n#define VM_EXIT_LOAD_PERF_GLOBAL_CTRL           0x00001000\n#define VM_EXIT_ACK_INTR_ON_EXIT                0x00008000\n#define VM_EXIT_SAVE_GUEST_PAT                  0x00040000\n#define VM_EXIT_LOAD_HOST_PAT                   0x00080000\n#define VM_EXIT_SAVE_GUEST_EFER                 0x00100000\n#define VM_EXIT_LOAD_HOST_EFER                  0x00200000\n#define VM_EXIT_SAVE_PREEMPT_TIMER              0x00400000\n#define VM_EXIT_CLEAR_BNDCFGS                   0x00800000\n\n#define VM_ENTRY_IA32E_MODE                     0x00000200\n#define VM_ENTRY_SMM                            0x00000400\n#define VM_ENTRY_DEACT_DUAL_MONITOR             0x00000800\n#define VM_ENTRY_LOAD_PERF_GLOBAL_CTRL          0x00002000\n#define VM_ENTRY_LOAD_GUEST_PAT                 0x00004000\n#define VM_ENTRY_LOAD_GUEST_EFER                0x00008000\n#define VM_ENTRY_LOAD_BNDCFGS                   0x00010000\n\n#define SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES 0x00000001\n#define SECONDARY_EXEC_ENABLE_EPT               0x00000002\n#define SECONDARY_EXEC_DESCRIPTOR_TABLE_EXITING 0x00000004\n#define SECONDARY_EXEC_ENABLE_RDTSCP            0x00000008\n#define SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE   0x00000010\n#define SECONDARY_EXEC_ENABLE_VPID              0x00000020\n#define SECONDARY_EXEC_WBINVD_EXITING           0x00000040\n#define SECONDARY_EXEC_UNRESTRICTED_GUEST       0x00000080\n#define SECONDARY_EXEC_APIC_REGISTER_VIRT       0x00000100\n#define SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY    0x00000200\n#define SECONDARY_EXEC_PAUSE_LOOP_EXITING       0x00000400\n#define SECONDARY_EXEC_ENABLE_INVPCID           0x00001000\n#define SECONDARY_EXEC_ENABLE_VM_FUNCTIONS      0x00002000\n#define SECONDARY_EXEC_ENABLE_VMCS_SHADOWING    0x00004000\n#define SECONDARY_EXEC_ENABLE_PML               0x00020000\n#define SECONDARY_EXEC_ENABLE_VIRT_EXCEPTIONS   0x00040000\n#define SECONDARY_EXEC_XSAVES                   0x00100000\n#define SECONDARY_EXEC_PCOMMIT                  0x00200000\n#define SECONDARY_EXEC_TSC_SCALING              0x02000000\n\n#define VMX_BASIC_REVISION_MASK                 0x7fffffff\n#define VMX_BASIC_VMCS_SIZE_MASK                (0x1fffULL << 32)\n#define VMX_BASIC_32BIT_ADDRESSES               (1ULL << 48)\n#define VMX_BASIC_DUAL_MONITOR                  (1ULL << 49)\n#define VMX_BASIC_MEMORY_TYPE_MASK              (0xfULL << 50)\n#define VMX_BASIC_INS_OUT_INFO                  (1ULL << 54)\n#define VMX_BASIC_DEFAULT1_ZERO                 (1ULL << 55)\n\n#define VMX_EPT_EXECUTE_ONLY_BIT                (1ULL)\n#define VMX_EPT_PAGE_WALK_4_BIT                 (1ULL << 6)\n#define VMX_EPTP_UC_BIT                         (1ULL << 8)\n#define VMX_EPTP_WB_BIT                         (1ULL << 14)\n#define VMX_EPT_2MB_PAGE_BIT                    (1ULL << 16)\n#define VMX_EPT_1GB_PAGE_BIT                    (1ULL << 17)\n#define VMX_EPT_INVEPT_BIT                      (1ULL << 20)\n#define VMX_EPT_AD_BIT                          (1ULL << 21)\n#define VMX_EPT_EXTENT_CONTEXT_BIT              (1ULL << 25)\n#define VMX_EPT_EXTENT_GLOBAL_BIT               (1ULL << 26)\n\n/* MSRs & bits used for VMX enabling */\n#define MSR_IA32_VMX_BASIC                      0x480\n#define MSR_IA32_VMX_PINBASED_CTLS              0x481\n#define MSR_IA32_VMX_PROCBASED_CTLS             0x482\n#define MSR_IA32_VMX_EXIT_CTLS                  0x483\n#define MSR_IA32_VMX_ENTRY_CTLS                 0x484\n#define MSR_IA32_VMX_MISC                       0x485\n#define MSR_IA32_VMX_CR0_FIXED0                 0x486\n#define MSR_IA32_VMX_CR0_FIXED1                 0x487\n#define MSR_IA32_VMX_CR4_FIXED0                 0x488\n#define MSR_IA32_VMX_CR4_FIXED1                 0x489\n#define MSR_IA32_VMX_VMCS_ENUM                  0x48a\n#define MSR_IA32_VMX_PROCBASED_CTLS2            0x48b\n#define MSR_IA32_VMX_EPT_VPID_CAP               0x48c\n#define MSR_IA32_VMX_TRUE_PINBASED_CTLS         0x48d\n#define MSR_IA32_VMX_TRUE_PROCBASED_CTLS        0x48e\n#define MSR_IA32_VMX_TRUE_EXIT_CTLS             0x48f\n#define MSR_IA32_VMX_TRUE_ENTRY_CTLS            0x490\n#define IA32_FEATURE_CONTROL_MSR                0x3a\n#define IA32_FEATURE_CONTROL_MSR_LOCK                     0x0001\n#define IA32_FEATURE_CONTROL_MSR_ENABLE_VMXON_INSIDE_SMX  0x0002\n#define IA32_FEATURE_CONTROL_MSR_ENABLE_VMXON_OUTSIDE_SMX 0x0004\n#define IA32_FEATURE_CONTROL_MSR_SENTER_PARAM_CTL         0x7f00\n#define IA32_FEATURE_CONTROL_MSR_ENABLE_SENTER            0x8000\n\n#define HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS   0x40000000\n#define HYPERV_CPUID_INTERFACE                  0x40000001\n#define HYPERV_CPUID_VERSION                    0x40000002\n#define HYPERV_CPUID_FEATURES                   0x40000003\n#define HYPERV_CPUID_ENLIGHTMENT_INFO           0x40000004\n#define HYPERV_CPUID_IMPLEMENT_LIMITS           0x40000005\n\n#define HYPERV_HYPERVISOR_PRESENT_BIT           0x80000000\n#define HYPERV_CPUID_MIN                        0x40000005\n#define HYPERV_CPUID_MAX                        0x4000ffff\n\nenum vmcs_field {\n    VIRTUAL_PROCESSOR_ID            = 0x00000000,\n    POSTED_INTR_NOTIFICATION_VECTOR = 0x00000002,\n    EPTP_INDEX                      = 0x00000004,\n    GUEST_ES_SELECTOR               = 0x00000800,\n    GUEST_CS_SELECTOR               = 0x00000802,\n    GUEST_SS_SELECTOR               = 0x00000804,\n    GUEST_DS_SELECTOR               = 0x00000806,\n    GUEST_FS_SELECTOR               = 0x00000808,\n    GUEST_GS_SELECTOR               = 0x0000080a,\n    GUEST_LDTR_SELECTOR             = 0x0000080c,\n    GUEST_TR_SELECTOR               = 0x0000080e,\n    GUEST_INTR_STATUS               = 0x00000810,\n    GUEST_PML_INDEX                 = 0x00000812,\n    HOST_ES_SELECTOR                = 0x00000c00,\n    HOST_CS_SELECTOR                = 0x00000c02,\n    HOST_SS_SELECTOR                = 0x00000c04,\n    HOST_DS_SELECTOR                = 0x00000c06,\n    HOST_FS_SELECTOR                = 0x00000c08,\n    HOST_GS_SELECTOR                = 0x00000c0a,\n    HOST_TR_SELECTOR                = 0x00000c0c,\n    IO_BITMAP_A                     = 0x00002000,\n    IO_BITMAP_B                     = 0x00002002,\n    MSR_BITMAP                      = 0x00002004,\n    VM_EXIT_MSR_STORE_ADDR          = 0x00002006,\n    VM_EXIT_MSR_LOAD_ADDR           = 0x00002008,\n    VM_ENTRY_MSR_LOAD_ADDR          = 0x0000200a,\n    PML_ADDRESS                     = 0x0000200e,\n    TSC_OFFSET                      = 0x00002010,\n    VIRTUAL_APIC_PAGE_ADDR          = 0x00002012,\n    APIC_ACCESS_ADDR                = 0x00002014,\n    PI_DESC_ADDR                    = 0x00002016,\n    VM_FUNCTION_CONTROL             = 0x00002018,\n    EPT_POINTER                     = 0x0000201a,\n    EOI_EXIT_BITMAP0                = 0x0000201c,\n    EPTP_LIST_ADDR                  = 0x00002024,\n    VMREAD_BITMAP                   = 0x00002026,\n    VMWRITE_BITMAP                  = 0x00002028,\n    VIRT_EXCEPTION_INFO             = 0x0000202a,\n    XSS_EXIT_BITMAP                 = 0x0000202c,\n    TSC_MULTIPLIER                  = 0x00002032,\n    GUEST_PHYSICAL_ADDRESS          = 0x00002400,\n    VMCS_LINK_POINTER               = 0x00002800,\n    GUEST_IA32_DEBUGCTL             = 0x00002802,\n    GUEST_PAT                       = 0x00002804,\n    GUEST_EFER                      = 0x00002806,\n    GUEST_PERF_GLOBAL_CTRL          = 0x00002808,\n    GUEST_PDPTE0                    = 0x0000280a,\n    GUEST_BNDCFGS                   = 0x00002812,\n    HOST_PAT                        = 0x00002c00,\n    HOST_EFER                       = 0x00002c02,\n    HOST_PERF_GLOBAL_CTRL           = 0x00002c04,\n    PIN_BASED_VM_EXEC_CONTROL       = 0x00004000,\n    CPU_BASED_VM_EXEC_CONTROL       = 0x00004002,\n    EXCEPTION_BITMAP                = 0x00004004,\n    PAGE_FAULT_ERROR_CODE_MASK      = 0x00004006,\n    PAGE_FAULT_ERROR_CODE_MATCH     = 0x00004008,\n    CR3_TARGET_COUNT                = 0x0000400a,\n    VM_EXIT_CONTROLS                = 0x0000400c,\n    VM_EXIT_MSR_STORE_COUNT         = 0x0000400e,\n    VM_EXIT_MSR_LOAD_COUNT          = 0x00004010,\n    VM_ENTRY_CONTROLS               = 0x00004012,\n    VM_ENTRY_MSR_LOAD_COUNT         = 0x00004014,\n    VM_ENTRY_INTR_INFO              = 0x00004016,\n    VM_ENTRY_EXCEPTION_ERROR_CODE   = 0x00004018,\n    VM_ENTRY_INSTRUCTION_LEN        = 0x0000401a,\n    TPR_THRESHOLD                   = 0x0000401c,\n    SECONDARY_VM_EXEC_CONTROL       = 0x0000401e,\n    PLE_GAP                         = 0x00004020,\n    PLE_WINDOW                      = 0x00004022,\n    VM_INSTRUCTION_ERROR            = 0x00004400,\n    VM_EXIT_REASON                  = 0x00004402,\n    VM_EXIT_INTR_INFO               = 0x00004404,\n    VM_EXIT_INTR_ERROR_CODE         = 0x00004406,\n    IDT_VECTORING_INFO              = 0x00004408,\n    IDT_VECTORING_ERROR_CODE        = 0x0000440a,\n    VM_EXIT_INSTRUCTION_LEN         = 0x0000440c,\n    VMX_INSTRUCTION_INFO            = 0x0000440e,\n    GUEST_ES_LIMIT                  = 0x00004800,\n    GUEST_CS_LIMIT                  = 0x00004802,\n    GUEST_SS_LIMIT                  = 0x00004804,\n    GUEST_DS_LIMIT                  = 0x00004806,\n    GUEST_FS_LIMIT                  = 0x00004808,\n    GUEST_GS_LIMIT                  = 0x0000480a,\n    GUEST_LDTR_LIMIT                = 0x0000480c,\n    GUEST_TR_LIMIT                  = 0x0000480e,\n    GUEST_GDTR_LIMIT                = 0x00004810,\n    GUEST_IDTR_LIMIT                = 0x00004812,\n    GUEST_ES_AR_BYTES               = 0x00004814,\n    GUEST_CS_AR_BYTES               = 0x00004816,\n    GUEST_SS_AR_BYTES               = 0x00004818,\n    GUEST_DS_AR_BYTES               = 0x0000481a,\n    GUEST_FS_AR_BYTES               = 0x0000481c,\n    GUEST_GS_AR_BYTES               = 0x0000481e,\n    GUEST_LDTR_AR_BYTES             = 0x00004820,\n    GUEST_TR_AR_BYTES               = 0x00004822,\n    GUEST_INTERRUPTIBILITY_INFO     = 0x00004824,\n    GUEST_ACTIVITY_STATE            = 0x00004826,\n    GUEST_SMBASE                    = 0x00004828,\n    GUEST_SYSENTER_CS               = 0x0000482a,\n    GUEST_PREEMPTION_TIMER          = 0x0000482e,\n    HOST_SYSENTER_CS                = 0x00004c00,\n    CR0_GUEST_HOST_MASK             = 0x00006000,\n    CR4_GUEST_HOST_MASK             = 0x00006002,\n    CR0_READ_SHADOW                 = 0x00006004,\n    CR4_READ_SHADOW                 = 0x00006006,\n    CR3_TARGET_VALUE0               = 0x00006008,\n    EXIT_QUALIFICATION              = 0x00006400,\n    GUEST_LINEAR_ADDRESS            = 0x0000640a,\n    GUEST_CR0                       = 0x00006800,\n    GUEST_CR3                       = 0x00006802,\n    GUEST_CR4                       = 0x00006804,\n    GUEST_ES_BASE                   = 0x00006806,\n    GUEST_CS_BASE                   = 0x00006808,\n    GUEST_SS_BASE                   = 0x0000680a,\n    GUEST_DS_BASE                   = 0x0000680c,\n    GUEST_FS_BASE                   = 0x0000680e,\n    GUEST_GS_BASE                   = 0x00006810,\n    GUEST_LDTR_BASE                 = 0x00006812,\n    GUEST_TR_BASE                   = 0x00006814,\n    GUEST_GDTR_BASE                 = 0x00006816,\n    GUEST_IDTR_BASE                 = 0x00006818,\n    GUEST_DR7                       = 0x0000681a,\n    GUEST_RSP                       = 0x0000681c,\n    GUEST_RIP                       = 0x0000681e,\n    GUEST_RFLAGS                    = 0x00006820,\n    GUEST_PENDING_DBG_EXCEPTIONS    = 0x00006822,\n    GUEST_SYSENTER_ESP              = 0x00006824,\n    GUEST_SYSENTER_EIP              = 0x00006826,\n    HOST_CR0                        = 0x00006c00,\n    HOST_CR3                        = 0x00006c02,\n    HOST_CR4                        = 0x00006c04,\n    HOST_FS_BASE                    = 0x00006c06,\n    HOST_GS_BASE                    = 0x00006c08,\n    HOST_TR_BASE                    = 0x00006c0a,\n    HOST_GDTR_BASE                  = 0x00006c0c,\n    HOST_IDTR_BASE                  = 0x00006c0e,\n    HOST_SYSENTER_ESP               = 0x00006c10,\n    HOST_SYSENTER_EIP               = 0x00006c12,\n    HOST_RSP                        = 0x00006c14,\n    HOST_RIP                        = 0x00006c16,\n};\n\n#define EXIT_REASON_EXCEPTION_NMI       0\n#define EXIT_REASON_EXTERNAL_INTERRUPT  1\n#define EXIT_REASON_TRIPLE_FAULT        2\n#define EXIT_REASON_INIT                3\n#define EXIT_REASON_SIPI                4\n#define EXIT_REASON_IO_SMI              5\n#define EXIT_REASON_OTHER_SMI           6\n#define EXIT_REASON_PENDING_VIRT_INTR   7\n#define EXIT_REASON_PENDING_VIRT_NMI    8\n#define EXIT_REASON_TASK_SWITCH         9\n#define EXIT_REASON_CPUID               10\n#define EXIT_REASON_GETSEC              11\n#define EXIT_REASON_HLT                 12\n#define EXIT_REASON_INVD                13\n#define EXIT_REASON_INVLPG              14\n#define EXIT_REASON_RDPMC               15\n#define EXIT_REASON_RDTSC               16\n#define EXIT_REASON_RSM                 17\n#define EXIT_REASON_VMCALL              18\n#define EXIT_REASON_VMCLEAR             19\n#define EXIT_REASON_VMLAUNCH            20\n#define EXIT_REASON_VMPTRLD             21\n#define EXIT_REASON_VMPTRST             22\n#define EXIT_REASON_VMREAD              23\n#define EXIT_REASON_VMRESUME            24\n#define EXIT_REASON_VMWRITE             25\n#define EXIT_REASON_VMXOFF              26\n#define EXIT_REASON_VMXON               27\n#define EXIT_REASON_CR_ACCESS           28\n#define EXIT_REASON_DR_ACCESS           29\n#define EXIT_REASON_IO_INSTRUCTION      30\n#define EXIT_REASON_MSR_READ            31\n#define EXIT_REASON_MSR_WRITE           32\n#define EXIT_REASON_INVALID_GUEST_STATE 33\n#define EXIT_REASON_MSR_LOADING         34\n#define EXIT_REASON_MWAIT_INSTRUCTION   36\n#define EXIT_REASON_MONITOR_TRAP_FLAG   37\n#define EXIT_REASON_MONITOR_INSTRUCTION 39\n#define EXIT_REASON_PAUSE_INSTRUCTION   40\n#define EXIT_REASON_MCE_DURING_VMENTRY  41\n#define EXIT_REASON_TPR_BELOW_THRESHOLD 43\n#define EXIT_REASON_APIC_ACCESS         44\n#define EXIT_REASON_ACCESS_GDTR_OR_IDTR 46\n#define EXIT_REASON_ACCESS_LDTR_OR_TR   47\n#define EXIT_REASON_EPT_VIOLATION       48\n#define EXIT_REASON_EPT_MISCONFIG       49\n#define EXIT_REASON_INVEPT              50\n#define EXIT_REASON_RDTSCP              51\n#define EXIT_REASON_VMX_PREEMPTION_TIMER_EXPIRED     52\n#define EXIT_REASON_INVVPID             53\n#define EXIT_REASON_WBINVD              54\n#define EXIT_REASON_XSETBV              55\n#define EXIT_REASON_APIC_WRITE          56\n#define EXIT_REASON_RDRAND              57\n#define EXIT_REASON_INVPCID             58\n#define EXIT_REASON_RDSEED              61\n#define EXIT_REASON_PML_FULL            62\n#define EXIT_REASON_XSAVES              63\n#define EXIT_REASON_XRSTORS             64\n#define EXIT_REASON_PCOMMIT             65\n\n#define GUEST_ACTIVITY_ACTIVE           0\n#define GUEST_ACTIVITY_HLT              1\n\ntypedef struct _VMX_GDTENTRY64\n{\n    UINT64 Base;\n    UINT32 Limit;\n    union\n    {\n        struct\n        {\n            UINT8 Flags1;\n            UINT8 Flags2;\n            UINT8 Flags3;\n            UINT8 Flags4;\n        } Bytes;\n        struct\n        {\n            UINT16 SegmentType : 4;\n            UINT16 DescriptorType : 1;\n            UINT16 Dpl : 2;\n            UINT16 Present : 1;\n\n            UINT16 Reserved : 4;\n            UINT16 System : 1;\n            UINT16 LongMode : 1;\n            UINT16 DefaultBig : 1;\n            UINT16 Granularity : 1;\n\n            UINT16 Unusable : 1;\n            UINT16 Reserved2 : 15;\n        } Bits;\n        UINT32 AccessRights;\n    };\n    UINT16 Selector;\n} VMX_GDTENTRY64, *PVMX_GDTENTRY64;\n\ntypedef struct _VMX_VMCS\n{\n    UINT32 RevisionId;\n    UINT32 AbortIndicator;\n    UINT8 Data[PAGE_SIZE - 8];\n} VMX_VMCS, *PVMX_VMCS;\n\ntypedef struct _VMX_EPTP\n{\n    union\n    {\n        struct\n        {\n            UINT64 Type : 3;\n            UINT64 PageWalkLength : 3;\n            UINT64 EnableAccessAndDirtyFlags : 1;\n            UINT64 Reserved : 5;\n            UINT64 PageFrameNumber : 36;\n            UINT64 ReservedHigh : 16;\n        };\n        UINT64 AsUlonglong;\n    };\n} VMX_EPTP, *PVMX_EPTP;\n\ntypedef struct _VMX_EPML4E\n{\n    union\n    {\n        struct\n        {\n            UINT64 Read : 1;\n            UINT64 Write : 1;\n            UINT64 Execute : 1;\n            UINT64 Reserved : 5;\n            UINT64 Accessed : 1;\n            UINT64 SoftwareUse : 1;\n            UINT64 UserModeExecute : 1;\n            UINT64 SoftwareUse2 : 1;\n            UINT64 PageFrameNumber : 36;\n            UINT64 ReservedHigh : 4;\n            UINT64 SoftwareUseHigh : 12;\n        };\n        UINT64 AsUlonglong;\n    };\n} VMX_EPML4E, *PVMX_EPML4E;\n\ntypedef struct _VMX_HUGE_PDPTE\n{\n    union\n    {\n        struct\n        {\n            UINT64 Read : 1;\n            UINT64 Write : 1;\n            UINT64 Execute : 1;\n            UINT64 Type : 3;\n            UINT64 IgnorePat : 1;\n            UINT64 Large : 1;\n            UINT64 Accessed : 1;\n            UINT64 Dirty : 1;\n            UINT64 UserModeExecute : 1;\n            UINT64 SoftwareUse : 1;\n            UINT64 Reserved : 18;\n            UINT64 PageFrameNumber : 18;\n            UINT64 ReservedHigh : 4;\n            UINT64 SoftwareUseHigh : 11;\n            UINT64 SupressVme : 1;\n        };\n        UINT64 AsUlonglong;\n    };\n} VMX_HUGE_PDPTE, *PVMX_HUGE_PDPTE;\n\ntypedef struct _VMX_PDPTE\n{\n    union\n    {\n        struct\n        {\n            UINT64 Read : 1;\n            UINT64 Write : 1;\n            UINT64 Execute : 1;\n            UINT64 Reserved : 5;\n            UINT64 Accessed : 1;\n            UINT64 SoftwareUse : 1;\n            UINT64 UserModeExecute : 1;\n            UINT64 SoftwareUse2 : 1;\n            UINT64 PageFrameNumber : 36;\n            UINT64 ReservedHigh : 4;\n            UINT64 SoftwareUseHigh : 12;\n        };\n        UINT64 AsUlonglong;\n    };\n} VMX_PDPTE, *PVMX_PDPTE;\n\ntypedef struct _VMX_LARGE_PDE\n{\n    union\n    {\n        struct\n        {\n            UINT64 Read : 1;\n            UINT64 Write : 1;\n            UINT64 Execute : 1;\n            UINT64 Type : 3;\n            UINT64 IgnorePat : 1;\n            UINT64 Large : 1;\n            UINT64 Accessed : 1;\n            UINT64 Dirty : 1;\n            UINT64 UserModeExecute : 1;\n            UINT64 SoftwareUse : 1;\n            UINT64 Reserved : 9;\n            UINT64 PageFrameNumber : 27;\n            UINT64 ReservedHigh : 4;\n            UINT64 SoftwareUseHigh : 11;\n            UINT64 SupressVme : 1;\n        };\n        UINT64 AsUlonglong;\n    };\n} VMX_LARGE_PDE, *PVMX_LARGE_PDE;\n\nstatic_assert(sizeof(VMX_EPTP) == sizeof(UINT64), \"EPTP Size Mismatch\");\nstatic_assert(sizeof(VMX_EPML4E) == sizeof(UINT64), \"EPML4E Size Mismatch\");\nstatic_assert(sizeof(VMX_PDPTE) == sizeof(UINT64), \"EPDPTE Size Mismatch\");\n\n#define PML4E_ENTRY_COUNT   512\n#define PDPTE_ENTRY_COUNT   512\n#define PDE_ENTRY_COUNT     512\n\n"
        }
      ]
    }
  ]
}