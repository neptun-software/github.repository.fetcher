{
  "metadata": {
    "timestamp": 1736709948093,
    "page": 487,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "googleprojectzero/winafl",
      "stars": 2381,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.017578125,
          "content": "build32\r\nbuild64\r\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.3427734375,
          "content": "[submodule \"third_party/winipt\"]\n\tpath = third_party/winipt\n\turl = https://github.com/ionescu007/winipt\n[submodule \"third_party/processor-trace\"]\n\tpath = third_party/processor-trace\n\turl = https://github.com/01org/processor-trace\n[submodule \"third_party/TinyInst\"]\n\tpath = third_party/TinyInst\n\turl = https://github.com/googleprojectzero/TinyInst.git\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 4.2470703125,
          "content": "cmake_minimum_required(VERSION 2.6)\n\nif (${USE_COLOR})\n    add_definitions(-DUSE_COLOR)\nendif()\n\nif (${USE_DRSYMS})\n    add_definitions(-DUSE_DRSYMS)\nendif()\n\nif (${INTELPT})\n    add_definitions(-DINTELPT)\nendif()\n\nif (${INTELPT})\n  add_subdirectory(third_party/processor-trace)\nendif()\n\nif (${TINYINST})\n    add_definitions(-DTINYINST)\nendif()\n\nif (${TINYINST})\n  add_subdirectory(third_party/TinyInst)\nendif()\n\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)\n\nproject(test)\n\nadd_executable(test\n  test.cpp\n  )\n\nproject(test_netmode)\n\nadd_executable(test_netmode test_netmode.cpp)\n\nadd_executable(test_servermode test_simple_winsock_client.cpp)\n\nif(NOT (\"${CMAKE_GENERATOR}\" MATCHES \"(Win64)\" OR \"${CMAKE_GENERATOR_PLATFORM}\" MATCHES \"(64)\"))\n\n  project(test_static)\n\n  add_executable(test_static\n    test_static.cpp\n    afl-staticinstr.c\n    )\n\n  target_link_libraries(test_static \"psapi.lib\")\n\n  set_target_properties(test_static PROPERTIES COMPILE_FLAGS \"/EHsc\")\n  set_target_properties(test_static PROPERTIES LINK_FLAGS \"/PROFILE\")\n\nendif()\n\nproject(test_gdiplus)\n\nadd_executable(test_gdiplus\n  gdiplus.cpp\n  )\n\ntarget_link_libraries(test_gdiplus gdiplus)\n\nproject(afl-analyze)\nadd_executable(afl-analyze\n  afl-analyze.c\n  )\n\nproject(afl-showmap)\n\nadd_executable(afl-showmap\n  afl-showmap.c\n  )\n\nproject(afl-tmin)\n\nadd_executable(afl-tmin\n  afl-tmin.c\n  )\n\nadd_library(custom_winafl_server SHARED custom_winafl_server.c custom_winafl_server.def)\n\nadd_library(custom_net_fuzzer SHARED custom_net_fuzzer.c custom_net_fuzzer.def)\n\nif (${INTELPT})\n\n  project(winipt)\n\n  include_directories(third_party/winipt/inc)\n\n  ADD_LIBRARY(winipt STATIC\n    ipttool.c\n    third_party/winipt/libipt/win32.c\n    )\n\n  target_compile_definitions(winipt PRIVATE UNICODE _UNICODE)\n\n  project(winaflpt-debug)\n\n  include_directories(third_party/winipt/inc)\n  include_directories(third_party/processor-trace/libipt/internal/include)\n  include_directories(${CMAKE_CURRENT_BINARY_DIR}/third_party/processor-trace/libipt/include)\n\n  SET(PT_ADDITIONAL_SOURCES\n    winaflpt.c\n    ptdecode.c\n    third_party/processor-trace/libipt/src/pt_cpu.c\n    third_party/processor-trace/libipt/src/windows/pt_cpuid.c\n    )\n\n  ADD_EXECUTABLE(winaflpt-debug\n    winaflpt-debug.c\n    ${PT_ADDITIONAL_SOURCES}\n    )\n\n  target_link_libraries(winaflpt-debug winipt)\n  target_link_libraries(winaflpt-debug libipt)\n\n  target_link_libraries(winaflpt-debug \"psapi.lib\")\n  target_link_libraries(winaflpt-debug \"Dbghelp.lib\")\n\nendif()\n\nif (${TINYINST})\n  ADD_LIBRARY(winafl_tinyinst STATIC\n    tinyinst_covmap.h\n    tinyinst_covmap.cpp\n    tinyinst_afl.h\n    tinyinst_afl.cpp\n    )\n\n  target_link_libraries(winafl_tinyinst tinyinst)\n  target_link_libraries(winafl_tinyinst \"onecore.lib\")\n\nendif()\n\n\nproject(afl-fuzz)\n\nSET(AFL_FUZZ_SOURCES afl-fuzz.c)\n\nif (${INTELPT})\n\n  include_directories(third_party/winipt/inc)\n  include_directories(third_party/processor-trace/libipt/internal/include)\n  include_directories(${CMAKE_CURRENT_BINARY_DIR}/third_party/processor-trace/libipt/include)\n\n  SET(AFL_FUZZ_SOURCES ${AFL_FUZZ_SOURCES} ${PT_ADDITIONAL_SOURCES})\n\nendif()\n\nadd_executable(afl-fuzz\n  ${AFL_FUZZ_SOURCES}\n  )\n\nif (${INTELPT})\n\n  target_link_libraries(afl-fuzz winipt)\n  target_link_libraries(afl-fuzz libipt)\n\n  target_link_libraries(afl-fuzz \"psapi.lib\")\n  target_link_libraries(afl-fuzz \"Dbghelp.lib\")\n\nendif()\n\nif (${TINYINST})\n  target_link_libraries(afl-fuzz winafl_tinyinst)\nendif()\n\nif (NOT \"${DynamoRIO_DIR}\" STREQUAL \"\")\n\n  project(WinAFL)\n\n  set(DynamoRIO_LOG_COMPATIBILITY on)\n\n  find_package(DynamoRIO)\n  if (NOT DynamoRIO_FOUND)\n    message(FATAL_ERROR \"DynamoRIO package required to build\")\n  endif(NOT DynamoRIO_FOUND)\n\n  if (STATIC_LIBRARY)\n    set(libtype STATIC)\n  else()\n    set(libtype SHARED)\n  endif ()\n\n  add_library(winafl ${libtype}\n    winafl.c\n    modules.c\n    )\n  configure_DynamoRIO_client(winafl)\n  use_DynamoRIO_extension(winafl drmgr)\n  use_DynamoRIO_extension(winafl drx)\n  use_DynamoRIO_extension(winafl drcontainers)\n  use_DynamoRIO_extension(winafl drreg)\n  use_DynamoRIO_extension(winafl drwrap)\n  if (${USE_DRSYMS})\n    use_DynamoRIO_extension(winafl drsyms)\n  endif()\n\n  # VS2015 Fix\n  if (NOT (MSVC_VERSION LESS 1900))\n    target_link_libraries(winafl \"libucrt.lib\")\n    target_link_libraries(winafl \"libvcruntime.lib\")\n  endif()\n\nendif()\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.0361328125,
          "content": "# How to contribute\n\nWe'd love to accept your patches and contributions to this project. There are\njust a few small guidelines you need to follow.\n\n## Contributor License Agreement\n\nContributions to any Google project must be accompanied by a Contributor License\nAgreement. This is necessary because you own the copyright to your changes, even\nafter your contribution becomes part of this project. So this agreement simply\ngives us permission to use and redistribute your contributions as part of the\nproject. Head over to <https://cla.developers.google.com/> to see your current\nagreements on file or to sign a new one.\n\nYou generally only need to submit a CLA once, so if you've already submitted one\n(even if it was for a different project), you probably don't need to do it\nagain.\n\n## Code reviews\n\nAll submissions, including submissions by project members, require review. We\nuse GitHub pull requests for this purpose. Consult [GitHub Help] for more\ninformation on using pull requests.\n\n[GitHub Help]: https://help.github.com/articles/about-pull-requests/\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 7.4111328125,
          "content": "=========\nChangeLog\n=========\n\n-----------------------------------\nVersion 1.16b (based on afl 2.43b):\n-----------------------------------\n\n  - Fixed an issue with Intel PT mode where target processes were not\n    terminated properly.\n    Reported by Jason Shirk\n    \n  - Added a port of afl-analyze\n    Contributed by L4ys\n\n  - DynamoRIO version update - started building prebuilt binaries with\n    DynamoRIO 7.1\n \n----------------------------------\nVersion 1.16 (based on afl 2.43b):\n----------------------------------\n\n  - Intel PT support.\n\n  - Fix target_path in afl-showmap in drioless mode\n    Contributed by L4ys\n\n----------------------------------\nVersion 1.15 (based on afl 2.43b):\n----------------------------------\n\n  - Added -p flag which persists DynamoRIO cache across process restarts.\n    This might have a slight positive impact on performance in some scenarios,\n    such as where WinAFL persistece can't be used effectively, or\n    with very complex targets.\n\n  - Fix custom_net_fuzzer to avoid consuming system resources by\n    unclosed sockets.\n    Contributed by MostafaSoliman\n\n----------------------------------\nVersion 1.14 (based on afl 2.43b):\n----------------------------------\n  \n  - Added support for third-party DLLs for custom test cases processing\n    This currently comes with (experimental) network fuzzing implementation\n    (both server- and client- side)\n    Contributed by Maksim Shudrak\n\n  - New \"In App Persistence\" mode that relaxes target_method restrictions\n    if the target process can be made to loop on its own\n    Contributed by Guy Inbar\n    \n  - Implemented setup_post on Windows\n    Contributed by Quang Nguyá»…n\n\n  - Added separate timeout for process initialization and the first run\n    Contributed by Netanel Ben Simon\n\n  - Added color support to afl-showmap & afl-tmin\n    Contributed by Yoav Alon\n\n  - added winafl-plot.py a winafl replacement for afl-plot\n    Contributed by Yoav Alon\n\n  - added winafl-whatsup.py a winafl replacement for afl-whatsup\n    Contributed by Yoav Alon\n\n  - Fixed compilation issue on newer versions of DynamoRIO\n    Contributed by Yoav Alon\n    \n  - Other minor fixes and improvements\n    Contributed by L4ys, Yoav Alon, Netanel Ben Simon and others\n\n----------------------------------\nVersion 1.13 (based on afl 2.43b):\n----------------------------------\n\n  - Added support for catching failfast-type issues\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n  \n  - Added support for catching Application Verifier errors\n    Contributed by yoava333\n\n  - Added support for processor affinity for afl-fuzz and target process\n    Contributed by yoava333\n\n  - Added support for ansi terminal on windows 10\n    Contributed by yoava333\n\n  - Make sure names of the output files generated by inafl-cmin.py are unique\n    Contributed by x9090\n\n  - Fixed a crash on zero sized input files\n    Contributed by yoava333\n\n  - Fixed a bug in load_extra that could cause errors or incorrect behavior when reading extras directory\n  \n  - Fixed a race condition where afl-fuzz could attempt to fuzz the target process while it was getting killed\n  \n  - fuzzer_pid now gets reported correctly in the fuzzer_stats file\n    \n----------------------------------\nVersion 1.12 (based on afl 2.43b):\n----------------------------------\n\n  - Windows port of afl-tmin\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n\n----------------------------------\nVersion 1.11 (based on afl 2.43b):\n----------------------------------\n\n  - Add support for setting a memory limit (-m flag)\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n\n----------------------------------\nVersion 1.10 (based on afl 2.43b):\n----------------------------------\n\n  - Add static instrumentation mode\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n\n-----------------------------------\nVersion 1.09b (based on afl 2.43b):\n-----------------------------------\n\n  - Fixed slave mode (broken by 1.09 update)\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n\n  - Fixed missing last_crash_time (broken by 1.09 update)\n    Contributed by x9090\n\n----------------------------------\nVersion 1.09 (based on afl 2.43b):\n----------------------------------\n\n  - Bringing WinAFL up to speed with AFL 2.43b\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n\n  - Fixed a memory leak in fuzz_one\n    Contributed by juanvazquez\n\n----------------------------------\nVersion 1.08 (based on afl 1.96b):\n----------------------------------\n\n  - It is now possible to collect coverage only from a thread that executed\n    target function using -thread_coverage flag\n\n  - When -target_method flag is used, symbols are now looked up from pdb files\n    in addition to exported symbols\n\n  - Added a missing call to classify_counts() from run_target()\n\n----------------------------------\nVersion 1.07 (based on afl 1.96b):\n----------------------------------\n\n  - Previous_offset is now stored in TLS.\n    Edge coverage for multithreaded targets should now be more usable.\n\n----------------------------------\nVersion 1.06 (based on afl 1.96b):\n----------------------------------\n\n  - Windows port of afl-cmin\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n  - Use exe_name instead of the preferred name\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n  - Add option to choose the calling convention\n    Contributed by shawndenbow\n  - Fix for building on VS2015\n    Contributed by b1ack0wl\n\n----------------------------------\nVersion 1.05 (based on afl 1.96b):\n----------------------------------\n\n  - Windows port of afl-showmap\n    Contributed by Axel \"0vercl0k\" Souchet of MSRC Vulnerabilities and Mitigations Team\n  - Expaded README a bit.\n\n----------------------------------\nVersion 1.04 (based on afl 1.96b):\n----------------------------------\n\n  Various fixes / improvements contributed by Axel \"0vercl0k\" Souchet:\n  - Mute stdout/stderr unless AFL_NO_SINKHOLE env variable is set.\n  - Allow several slaveless instances to be run on the same machine.\n  - Fix getopt to properly handle options without parameters.\n  - Automatically remove the child pid file.\n  - Case insensitive module name comparison.\n  - More debugging messages.\n\n----------------------------------\nVersion 1.03 (based on afl 1.96b):\n----------------------------------\n\n  - Fixed dictionary loading.\n\tReported by Hugo Meier.\n\n----------------------------------\nVersion 1.02 (based on afl 1.96b):\n----------------------------------\n\n  - Fixed incorrect quoting of target command line arguments.\n\n  - Debug mode now reports encountered exceptions.\n\n----------------------------------\nVersion 1.01 (based on afl 1.96b):\n----------------------------------\n\n  - Fixed a bug where previous offset wasn't updated in the edge coverage\n    instrumentation mode. This effectively caused edge coverage to behave\n\tthe same as basic block coverage.\n\tReported by Rodrigo Axel Monroy.\n\n  - Changed the default coverage mode to basic block in order for the default\n    configuration to work better with muti-threaded apps.\n\n  - Added -no_follow_children to DR runtime flags. This can fix problems if the\n    target process creates a child process.\n\n  - More data in now written to the debug log\n\n----------------------------------\nVersion 1.00 (based on afl 1.96b):\n----------------------------------\n\n  - Initial release.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.076171875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2016 Google Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 30.318359375,
          "content": "# WinAFL\n\n```\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n```\n\n## Background\n\nAFL is a popular fuzzing tool for coverage-guided fuzzing. The tool combines\nfast target execution with clever heuristics to find new execution paths in\nthe target binary. It has been successfully used to find a large number of\nvulnerabilities in real products. For more info about the original project,\nplease refer to the original documentation at:\n\nhttp://lcamtuf.coredump.cx/afl/\n\nUnfortunately, the original AFL does not work on Windows due to very\n*nix-specific design (e.g. instrumentation, forkserver etc.). This project is\na fork of AFL that uses different instrumentation approach which works on\nWindows even for black box binary fuzzing.\n\n## The WinAFL approach\n\nInstead of instrumenting the code at compilation time, WinAFL supports the\nfollowing instrumentation modes:\n - Dynamic instrumentation using DynamoRIO (http://dynamorio.org/)\n - Dynamic instrumentation using TinyInst (https://github.com/googleprojectzero/TinyInst)\n - Hardware tracing using Intel PT\n - Static instrumentation via Syzygy\n\nThese instrumentation modes are described in more detail in the separate\ndocuments.\n\n<p align=\"center\">\n<img alt=\"afl-fuzz.exe\" src=\"screenshots/afl-fuzz.gif\"/>\n</p>\n\nTo improve the process startup time, WinAFL relies heavily on persistent\nfuzzing mode, that is, executing multiple input samples without restarting the\ntarget process. This is accomplished by selecting a target function (that the\nuser wants to fuzz) and instrumenting it so that it runs in a loop.\n\n#### Known CVEs\n\nWinAFL has been successfully used to identify bugs in Windows software, such as the following:\n\n| Software | Bugs | Found by |\n| - | - | - |\n| Adobe | [CVE-2018-4985](https://cpr-zero.checkpoint.com/vulns/cprid-2046/), [CVE-2018-5063](https://cpr-zero.checkpoint.com/vulns/cprid-2047/), [CVE-2018-5064](https://cpr-zero.checkpoint.com/vulns/cprid-2048/), [CVE-2018-5065](https://cpr-zero.checkpoint.com/vulns/cprid-2049/), [CVE-2018-5068](https://cpr-zero.checkpoint.com/vulns/cprid-2050/), [CVE-2018-5069](https://cpr-zero.checkpoint.com/vulns/cprid-2051/), [CVE-2018-5070](https://cpr-zero.checkpoint.com/vulns/cprid-2052/), [CVE-2018-12754](https://cpr-zero.checkpoint.com/vulns/cprid-2053/), [CVE-2018-12755](https://cpr-zero.checkpoint.com/vulns/cprid-2054/), [CVE-2018-12764](https://cpr-zero.checkpoint.com/vulns/cprid-2055/), [CVE-2018-12765](https://cpr-zero.checkpoint.com/vulns/cprid-2056/), [CVE-2018-12766](https://cpr-zero.checkpoint.com/vulns/cprid-2057/), [CVE-2018-12767](https://cpr-zero.checkpoint.com/vulns/cprid-2058/), [CVE-2018-12768](https://cpr-zero.checkpoint.com/vulns/cprid-2059/), [CVE-2018-12839](https://cpr-zero.checkpoint.com/vulns/cprid-2060/), [CVE-2018-12840](https://cpr-zero.checkpoint.com/vulns/cprid-2061/), [CVE-2018-12848](https://cpr-zero.checkpoint.com/vulns/cprid-2062/), [CVE-2018-12849](https://cpr-zero.checkpoint.com/vulns/cprid-2063/), [CVE-2018-12850](https://cpr-zero.checkpoint.com/vulns/cprid-2064/), [CVE-2018-12857](https://cpr-zero.checkpoint.com/vulns/cprid-2065/), [CVE-2018-12859](https://cpr-zero.checkpoint.com/vulns/cprid-2066/), [CVE-2018-12860](https://cpr-zero.checkpoint.com/vulns/cprid-2067/), [CVE-2018-12861](https://cpr-zero.checkpoint.com/vulns/cprid-2068/), [CVE-2018-12862](https://cpr-zero.checkpoint.com/vulns/cprid-2069/), [CVE-2018-12863](https://cpr-zero.checkpoint.com/vulns/cprid-2070/), [CVE-2018-12864](https://cpr-zero.checkpoint.com/vulns/cprid-2071/), [CVE-2018-12865](https://cpr-zero.checkpoint.com/vulns/cprid-2072/), [CVE-2018-12866](https://cpr-zero.checkpoint.com/vulns/cprid-2073/), [CVE-2018-12867](https://cpr-zero.checkpoint.com/vulns/cprid-2074/), [CVE-2018-12869](https://cpr-zero.checkpoint.com/vulns/cprid-2075/), [CVE-2018-12870](https://cpr-zero.checkpoint.com/vulns/cprid-2076/), [CVE-2018-12871](https://cpr-zero.checkpoint.com/vulns/cprid-2077/), [CVE-2018-12872](https://cpr-zero.checkpoint.com/vulns/cprid-2078/), [CVE-2018-12873](https://cpr-zero.checkpoint.com/vulns/cprid-2079/), [CVE-2018-12874](https://cpr-zero.checkpoint.com/vulns/cprid-2080/), [CVE-2018-12875](https://cpr-zero.checkpoint.com/vulns/cprid-2081/), [CVE-2018-15927](https://cpr-zero.checkpoint.com/vulns/cprid-2082/), CVE-2018-15928, [CVE-2018-15929](https://cpr-zero.checkpoint.com/vulns/cprid-2083/), [CVE-2018-15930](https://cpr-zero.checkpoint.com/vulns/cprid-2084/), [CVE-2018-15931](https://cpr-zero.checkpoint.com/vulns/cprid-2085/), [CVE-2018-15932](https://cpr-zero.checkpoint.com/vulns/cprid-2086/), [CVE-2018-15933](https://cpr-zero.checkpoint.com/vulns/cprid-2087/), [CVE-2018-15934](https://cpr-zero.checkpoint.com/vulns/cprid-2088/), [CVE-2018-15935](https://cpr-zero.checkpoint.com/vulns/cprid-2089/), [CVE-2018-15936](https://cpr-zero.checkpoint.com/vulns/cprid-2090/), [CVE-2018-15937](https://cpr-zero.checkpoint.com/vulns/cprid-2091/), [CVE-2018-15938](https://cpr-zero.checkpoint.com/vulns/cprid-2092/), [CVE-2018-15952](https://cpr-zero.checkpoint.com/vulns/cprid-2093/), [CVE-2018-15953](https://cpr-zero.checkpoint.com/vulns/cprid-2094/), [CVE-2018-15954](https://cpr-zero.checkpoint.com/vulns/cprid-2095/), [CVE-2018-15955](https://cpr-zero.checkpoint.com/vulns/cprid-2096/), [CVE-2018-15956](https://cpr-zero.checkpoint.com/vulns/cprid-2097/) | Yoav Alon ([@yoavalon](https://twitter.com/yoavalon)) and Netanel Ben-Simon ([@NetanelBenSimon](https://twitter.com/netanelbensimon)) of Check Point Software Technologies\n| Adobe | CVE-2018-12853, CVE-2018-16024, CVE-2018-16023, CVE-2018-15995 | Guy Inbar ([@guyio_](https://twitter.com/guyio_))\n| Adobe | CVE-2018-16004, CVE-2018-16005, CVE-2018-16007, CVE-2018-16009, CVE-2018-16010, CVE-2018-16043, CVE-2018-16045, CVE-2018-16046, CVE-2018-19719, CVE-2018-19720, CVE-2019-7045 | Sebastian Apelt ([@bitshifter123](https://twitter.com/bitshifter123))\n| Microsoft | [CVE-2016-7212](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2016-7212) | Aral Yaman of Noser Engineering AG\n| Microsoft | [CVE-2017-0073](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0073), [CVE-2017-0190](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-0190), [CVE-2017-11816](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2017-11816), [CVE-2018-8472](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2018-8472), [CVE-2019-1311](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1311) | Symeon Paraschoudis ([@symeonp](https://twitter.com/symeonp))\n| Microsoft | [CVE-2018-8494](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2018-8494) | Guy Inbar ([@guyio_](https://twitter.com/guyio_))\n| Microsoft | [CVE-2018-8464](https://cpr-zero.checkpoint.com/vulns/cprid-2098/) | Yoav Alon ([@yoavalon](https://twitter.com/yoavalon)) and Netanel Ben-Simon ([@NetanelBenSimon](https://twitter.com/netanelbensimon)) of Check Point Research\n| Microsoft | [CVE-2019-0538](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0538), [CVE-2019-0576](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0576), [CVE-2019-0577](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0577), [CVE-2019-0579](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0579), [CVE-2019-0580](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0580), [CVE-2019-0879](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0879), [CVE-2019-0889](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0889), [CVE-2019-0891](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0891), [CVE-2019-0899](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0899), [CVE-2019-0902](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-0902), [CVE-2019-1243](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1243), [CVE-2019-1250](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2019-1250), [CVE-2020-0687](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0687), [CVE-2020-0744](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0744), [CVE-2020-0879](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0879), [CVE-2020-0964](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0964), [CVE-2020-0995](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-0995), [CVE-2020-1141](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1141), [CVE-2020-1145](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1145), [CVE-2020-1160](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1160), [CVE-2020-1179](https://msrc.microsoft.com/update-guide/en-US/vulnerability/CVE-2020-1179), [CVE-2021-1665](https://www.mcafee.com/blogs/other-blogs/mcafee-labs/analyzing-cve-2021-1665-remote-code-execution-vulnerability-in-windows-gdi/) | Hardik Shah ([@hardik05](https://twitter.com/hardik05)) of McAfee\n| Microsoft | [CVE-2021-42276](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-42276), [CVE-2021-28350](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28350), [CVE-2021-28349](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28349), [CVE-2021-28348](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-28348) | Simon Barsky ([expend20](https://twitter.com/expend20))\n| Microsoft | [CVE-2022-21903](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-21903), [CVE-2022-21904](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_setdibitstodevice-record/), [CVE-2022-21915](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_stretchdibits-record/), [CVE-2022-26934](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_createdibpatternbrushpt-record/), [CVE-2022-29112](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_bitblt-record/), [CVE-2022-35837](https://www.seljan.hu/posts/arbitrary-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_startdoc-record/), [CVE-2022-34728](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_setpixelv-record/), [CVE-2022-38006](https://www.seljan.hu/posts/out-of-bounds-read-information-disclosure-vulnerability-in-microsoft-windows-gdi-emr_stretchdibits-record-again/) | [GÃ¡bor SeljÃ¡n](https://twitter.com/GaborSeljan)\n| Microsoft | [CVE-2021-38665](https://thalium.github.io/blog/posts/leaking-aslr-through-rdp-printer-cache-registry/), [CVE-2021-38666](https://thalium.github.io/blog/posts/deserialization-bug-through-rdp-smart-card-extension/) | Valentino Ricotta with Thalium\n| Microsoft | [CVE-2022-26929](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-26929), [CVE-2022-30130](https://msrc.microsoft.com/update-guide/vulnerability/CVE-2022-30130) | Eran Zimmerman Gonen ([@3r4nz](https://twitter.com/3r4nz))\n| FreeRDP | [CVE-2021-37594](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-37594), [CVE-2021-37595](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-37595) | Valentino Ricotta with Thalium\n| Kollective | CVE-2018-11672 | Maksim Shudrak ([@MShudrak](https://twitter.com/MShudrak)) of Salesforce\n| Mozilla | [CVE-2018-5177](https://bugzilla.mozilla.org/show_bug.cgi?id=1451908) | Guy Inbar ([@guyio_](https://twitter.com/guyio_))\n| libxml2 | CVE-2018-14404 | Guy Inbar ([@guyio_](https://twitter.com/guyio_))\n| WinRAR | [CVE-2018-20250, CVE-2018-20251, CVE-2018-20252, CVE-2018-20253](https://research.checkpoint.com/2019/extracting-code-execution-from-winrar/) | Nadav Grossman ([@NadavGrossman](https://twitter.com/NadavGrossman)) of Check Point Software Technologies\n| XnView | [CVE-2019-13083](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x384e2a.md), [CVE-2019-13084](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x26b739.md), [CVE-2019-13085](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x30ecfa.md), [CVE-2019-13253](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000385474.md), [CVE-2019-13254](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x000000000032e808.md), [CVE-2019-13255](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000327464.md), [CVE-2019-13256](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x000000000032e849.md), [CVE-2019-13257](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x00000000003273aa.md), [CVE-2019-13258](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000328165.md), [CVE-2019-13259](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x000000000032e566.md), [CVE-2019-13260](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000327a07.md), [CVE-2019-13261](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x0000000000328384.md), [CVE-2019-13262](https://github.com/apriorit/pentesting/blob/master/bugs/xnview/0x00000000003283eb.md) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit\n| IrfanView | [CVE-2019-13242](https://github.com/apriorit/pentesting/blob/master/bugs/irfanview/0x0000000000013a98.md), [CVE-2019-13243](https://github.com/apriorit/pentesting/blob/master/bugs/irfanview/0x00000000000249c6.md) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit\n| FastStone | [CVE-2019-13244](https://github.com/apriorit/pentesting/blob/master/bugs/fsview/0x0000000000002d7d.md), [CVE-2019-13245](https://github.com/apriorit/pentesting/blob/master/bugs/fsview/0x00000000001a95b1.md), [CVE-2019-13246](https://github.com/apriorit/pentesting/blob/master/bugs/fsview/0x00000000001a9601.md) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit\n| ACDSee | [CVE-2019-13247](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000024ed.md), [CVE-2019-13248](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x0000000000002450.md), [CVE-2019-13249](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000b9e7a.md), [CVE-2019-13250](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000b9c2f.md), [CVE-2019-13251](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000000c47ff.md), [CVE-2019-13252](https://github.com/apriorit/pentesting/blob/master/bugs/acdsee/0x00000000001172b0.md), [CVE-2019-15293](https://www.apriorit.com/dev-blog/640-qa-fuzzing-for-closed-source-windows-software) | [@expend20](https://twitter.com/expend20) and Anton Kukoba of Apriorit\n| Foxit | [CVE-2019-13330](https://www.zerodayinitiative.com/advisories/ZDI-19-853/), [CVE-2019-13331](https://www.zerodayinitiative.com/advisories/ZDI-19-854/), [CVE-2020-8844](https://www.zerodayinitiative.com/advisories/ZDI-20-200/) | Natnael Samson ([@NattiSamson](https://twitter.com/NattiSamson))\n| Rockwell Automation | [CVE-2020-12034, CVE-2020-12038](https://www.us-cert.gov/ics/advisories/icsa-20-140-01) | [Sharon Brizinov](https://sharonbrizinov.com/) and Amir Preminger of Claroty\n| F-Secure & WithSecure | CVE-2021-33599, CVE-2021-33602, CVE-2021-40836, CVE-2021-40837, CVE-2022-28875, CVE-2022-28876, CVE-2022-28879, CVE-2022-28881, CVE-2022-28882, CVE-2022-28883, CVE-2022-28884, CVE-2022-28886, CVE-2022-28887 | [@faty420](https://twitter.com/faty420)\n\n(Let me know if you know of any others, and I'll include them in the list)\n\n## Building WinAFL\n\n1. If you are building with DynamoRIO support, download and build\nDynamoRIO sources or download DynamoRIO Windows binary package from\nhttps://github.com/DynamoRIO/dynamorio/releases\n\n2. If you are building with Intel PT support, pull third party dependencies by running `git submodule update --init --recursive` from the WinAFL source directory\n\n3. Open Visual Studio Command Prompt (or Visual Studio x64 Win64 Command Prompt\nif you want a 64-bit build). Note that you need a 64-bit winafl.dll build if\nyou are fuzzing 64-bit targets and vice versa.\n\n4. Go to the directory containing the source\n\n5. Type the following commands. Modify the -DDynamoRIO_DIR flag to point to the\nlocation of your DynamoRIO cmake files (either full path or relative to the\nsource directory).\n\n### For a 32-bit build:\n\n```\nmkdir build32\ncd build32\ncmake -G\"Visual Studio 16 2019\" -A Win32 .. -DDynamoRIO_DIR=C:\\path\\to\\DynamoRIO\\cmake -DINTELPT=1\ncmake --build . --config Release\n```\n\n### For a 64-bit build:\n\n```\nmkdir build64\ncd build64\ncmake -G\"Visual Studio 16 2019\" -A x64 .. -DDynamoRIO_DIR=C:\\path\\to\\DynamoRIO\\cmake -DINTELPT=1\ncmake --build . --config Release\n```\n\n### Build configuration options\n\nThe following cmake configuration options are supported:\n\n - `-DDynamoRIO_DIR=..\\path\\to\\DynamoRIO\\cmake` - Needed to build the\n   winafl.dll DynamoRIO client\n\n - `-DTINYINST=1` - Enable TinyInst mode. For more information see\n   https://github.com/googleprojectzero/winafl/blob/master/readme_tinyinst.md\n\n - `-DINTELPT=1` - Enable Intel PT mode. For more information see\n   https://github.com/googleprojectzero/winafl/blob/master/readme_pt.md\n\n - `-DUSE_COLOR=1` - color support (Windows 10 Anniversary edition or higher)\n\n - `-DUSE_DRSYMS=1` - Drsyms support (use symbols when available to obtain\n   -target_offset from -target_method). Enabling this has been known to cause\n   issues on Windows 10 v1809, though there are workarounds,\n   see https://github.com/googleprojectzero/winafl/issues/145\n\n## Using WinAFL\n\nThe command line for afl-fuzz on Windows is different than on Linux. Instead of:\n\n```\n%s [ afl options ] -- target_cmd_line\n```\n\nit now looks like this:\n\n```\nafl-fuzz [afl options] -- [instrumentation options] -- target_cmd_line\n```\n\nThe following afl-fuzz options are supported:\n\n```\n  -i dir        - input directory with test cases\n  -o dir        - output directory for fuzzer findings\n  -t msec       - timeout for each run\n  -s            - deliver sample via shared memory\n  -D dir        - directory containing DynamoRIO binaries (drrun, drconfig)\n  -w path       - path to winafl.dll\n  -e            - expert mode to run WinAFL as a DynamoRIO tool\n  -P            - use Intel PT tracing mode\n  -Y            - enable the static instrumentation mode\n  -f file       - location read by the fuzzed program\n  -m limit      - memory limit for the target process\n  -p            - persist DynamoRIO cache across target process restarts\n  -c cpu        - the CPU to run the fuzzed program\n  -d            - quick & dirty mode (skips deterministic steps)\n  -n            - fuzz without instrumentation (dumb mode)\n  -x dir        - optional fuzzer dictionary\n  -I msec       - timeout for process initialization and first run\n  -T text       - text banner to show on the screen\n  -M \\\\ -S id   - distributed mode\n  -C            - crash exploration mode (the peruvian rabbit thing)\n  -l path       - a path to user-defined DLL for custom test cases processing\n  -A module     - a module identifying a unique process to attach to\n```\n\nPlease refer to the original AFL documentation for more info on these flags.\n\nTo see the supported instrumentation flags, please refer to the documentation\non the specific instrumentation mode you are interested in (see \"Instrumentation modes\" below).\n\n## How does my target run under WinAFL\n\nWhen you select a target function and fuzz an application the following happens:\n\n1. Your target runs normally until your target function is reached.\n2. WinAFL starts recording coverage\n3. Your target function runs until return\n4. WinAFL reports coverage, rewrites the input file and patches EIP\n   so that the execution jumps back to step 2\n5. After your target function runs for the specified number of iterations,\n   the target process is killed and restarted. Note that anything that runs\n   after the target function returns is never reached.\n\n## How to select a target function\n\nThe target function should do these things during its lifetime:\n\n1. Open the input file. This needs to happen within the target function so\n   that you can read a new input file for each iteration as the input file is\n   rewritten between target function runs.\n2. Parse it (so that you can measure coverage of file parsing)\n3. Close the input file. This is important because if the input file is\n   not closed WinAFL won't be able to rewrite it.\n4. Return normally (So that WinAFL can \"catch\" this return and redirect\n   execution. \"returning\" via ExitProcess() and such won't work)\n\n## Instrumentation modes\n\nThe following documents provide information on using different instrumentation\nmodes with WinAFL:\n\n - [Dynamic instrumentation using DynamoRIO](https://github.com/googleprojectzero/winafl/blob/master/readme_dr.md)\n - [Dynamic instrumentation using TinyInst](https://github.com/googleprojectzero/winafl/blob/master/readme_tinyinst.md)\n - [Hardware tracing using Intel PT](https://github.com/googleprojectzero/winafl/blob/master/readme_pt.md)\n - [Static instrumentation via Syzygy](https://github.com/googleprojectzero/winafl/blob/master/readme_syzygy.md)\n\nBefore using WinAFL for the first time, you should read the documentation for\nthe specific instrumentation mode you are interested in. These also contain\nusage examples.\n\n## Attaching to a running process\n\nThe DynamoRIO instrumentation mode supports dynamically attaching to running processes. This option can be used to fuzz processes that cannot be directly launched by WinAFL, such as system services.\n\nTo use it, specify the `-A <module>` option to `afl-fuzz.exe`, where `<module>` is the name of a module loaded only by the target process (if the module is loaded by more than one process WinAFL will terminate).\n\nWinAFL will attach to the target process, and fuzz it normally. When the target process terminates (regardless of the reason), WinAFL will not restart it, but simply try to reattach. It is assumed that the target process will be restarted by an external script (or by the system itself). If WinAFL will not find the new target process within 10 seconds, it will terminate.\n\n## Sample delivery via shared memory\n\nWinAFL supports delivering samples via shared memory (as opposed to via a file, which is the default). This can be enabled by giving `-s` option to `afl-fuzz.exe`. Shared memory is faster and can avoid some problems with files (e.g. unable to overwrite the sample file because a target maintains a lock on it). \nIf you are using shared memory for sample delivery then you need to make sure that in your harness you specifically read data from shared memory instead of file. Check a simple harness here:\n\nhttps://github.com/googleprojectzero/Jackalope/blob/6d92931b2cf614699e2a023254d5ee7e20f6e34b/test.cpp#L41  \nhttps://github.com/googleprojectzero/Jackalope/blob/6d92931b2cf614699e2a023254d5ee7e20f6e34b/test.cpp#L111  \n\n## Corpus minimization\n\nWinAFL includes the windows port of afl-cmin in winafl-cmin.py. Please run the\nbelow command to see the options and usage examples:\n\n```\nD:\\Codes\\winafl>python winafl-cmin.py -h\n[...]\nExamples of use:\n * Typical use\n  winafl-cmin.py -D D:\\DRIO\\bin32 -t 100000 -i in -o minset -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n * Dry-run, keep crashes only with 4 workers with a working directory:\n  winafl-cmin.py -C --dry-run -w 4 --working-dir D:\\dir -D D:\\DRIO\\bin32 -t 10000 -i in -i C:\\fuzz\\in -o out_mini -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n * Read from specific file\n  winafl-cmin.py -D D:\\DRIO\\bin32 -t 100000 -i in -o minset -f foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n * Read from specific file with pattern\n  winafl-cmin.py -D D:\\DRIO\\bin32 -t 100000 -i in -o minset -f prefix-@@-foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n * Typical use with static instrumentation\n   winafl-cmin.py -Y -t 100000 -i in -o minset -- test.exe @@\n```\n\n<p align=\"center\">\n<img alt=\"winafl-cmin.py\" src=\"screenshots/winafl-cmin.py.png\"/>\n</p>\n\n## Custom test cases processing\n\nWinAFL supports third party DLLs that can be used to define custom test-cases processing (e.g. to send test cases over network). To enable this option, you need to specify ```-l <path>``` argument.\nThe DLL should export the following two functions:\n```\ndll_init()\ndll_run(char *data, long size, int fuzz_iterations)\ndata - content of test case\nsize - size of test case\nfuzz_iterations - defines a current fuzzing iteration number\n```\n\nWe have implemented two sample DLLs for network-based applications fuzzing that you can customize for your own purposes.\n\n### Network fuzzing\n\nWinAFL's ```custom_net_fuzzer.dll``` allows winAFL to perform network-based applications fuzzing that receive and parse network data. There are several options supported by this DLL that should be provided via the environment variable ```AFL_CUSTOM_DLL_ARGS```:\n\n```\n  -a IP address - IP address to send data in\n  -U            - use UDP protocol instead of TCP to send data (default TCP)\n  -p port       - port to send data in\n  -w msec       - delay in milliseconds before actually start fuzzing\n```\nFor example, if your application receives network packets via UDP protocol at port 7714 you should set up the environment variable in the following way: ```set AFL_CUSTOM_DLL_ARGS=-U -p 7714 -a 127.0.0.1 -w 1000 ```\n\nYou still need to find target function and make sure that this function receives data from the network, parses it, and returns normally. Also, you can use In App Persistence mode described above if your application runs the target function in a loop by its own.\n\nAdditionally, this mode is considered as experimental since we have experienced some problems with stability and performance. However, we found this option very useful and managed to find several vulnerabilities in network-based applications (e.g. in Kollective Kontiki listed above).\n\nThere is a second DLL ```custom_winafl_server.dll``` that allows winAFL to act as a server and perform fuzzing of client-based applications. All you need is to set up the port to listen on for incoming connections from your target application. The environment variable ```AFL_CUSTOM_DLL_ARGS=<port_id>``` should be used for this purpose.\n\n#### Note\n\nIn case of server fuzzing, if the server socket has the `SO_REUSEADDR` option set like the following code, then this may case `10055` error after some time fuzzing due to the accumulation of `TIME_WAIT` sockets when WinAFL restart the fuzzing process. \n```\nsetsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(int));\n```\n\nTo avoid this, replace the `SO_REUSEADDR` option by `SO_LINGER` option in the server source code if available.\n```\nsetsockopt(s, SOL_SOCKET, SO_LINGER, (char*)&opt, sizeof(int));\n```\n\n## Custom mutators\n\nWinAFL supports loading a custom mutator from a third-party DLL.  You need to implement `dll_mutate_testcase` or `dll_mutate_testcase_with_energy` in your DLL and provide the DLL path to WinAFL via `-l <path>` argument.  WinAFL invokes the custom mutator before all the built-in mutations, and the custom mutator can skip all the built-in mutations by returning a non-zero value.  The `dll_mutate_testcase_with_energy` function is additionally provided an energy value that is equivalent to the number of iterations expected to run in the havoc stage without deterministic mutations. The custom mutator should invoke `common_fuzz_stuff` to run and make WinAFL aware of each new test case.  Below is an example mutator that increments every byte by one: \n\n```c\nu8 dll_mutate_testcase(char **argv, u8 *buf, u32 len, u8 (*common_fuzz_stuff)(char**, u8*, u32))\n{\n    u8 bailout = 0;\n    u8 *newbuf;\n    u32 i;\n    // duplicate the input buffer\n    newbuf = malloc(len);\n    if (!newbuf) return bailout;\n    memcpy(newbuf, buf, len);\n    // increment every byte by one and call common_fuzz_stuff for every new test case\n    for (i = 0; i < len; i++) {\n       newbuf[i] += 1;\n       if (common_fuzz_stuff(argv, newbuf, len)) {\n           bailout = 1; // skip the rest of the mutation per common_fuzz_stuff\n           break;\n       }\n    }\n    free(newbuf);\n    return bailout;\n}\n```\n\n## FAQ\n\n```\nQ: WinAFL reports timeouts while processing initial testcases.\nA: You should run your target in debug mode first (-debug flag) and only\n   run WinAFL once you get a message in the debug log that everything\n   appears to be running normally.\n\nQ: WinAFL runs slower than expected\nA: This can commonly happen for several reasons\n - Your target function loads a dll for every iteration. This causes\n   DynamoRIO to translate the same code for every iteration which causes\n   slowdowns. You will be able to see this in the debug log. To\n   resolve, select (or write) your target function differently.\n - Your target function does not close the input file properly, which\n   causes WinAFL to kill the process in order to rewrite it. Please refer to\n   \"How to select a target function\" for what a target function should look like.\n\nQ: Can I fuzz DLLs with WinAFL\nA: Yes, if you can write a harness that loads a library and runs some\n   function within. Write your target function according to \"How to select\n   a target function\" and for best performance, load the dll outside of\n   your target function (see the previous question).\n\nQ: Can I fuzz GUI apps with WinAFL\nA: Yes, provided that\n - There is a target function that behaves as explained in \"How to select\n   a target function\"\n - The target function is reachable without user interaction\n - The target function runs and returns without user interaction\n If these conditions are not satisfied, you might need to make custom changes\n to WinAFL and/or your target.\n```\n\n## Special Thanks\n\nSpecial thanks to Axel \"[0vercl0k](https://twitter.com/0vercl0k)\" Souchet of MSRC Vulnerabilities and\nMitigations Team for his contributions!\n"
        },
        {
          "name": "afl-analyze.c",
          "type": "blob",
          "size": 31.84765625,
          "content": "/*\n   american fuzzy lop - file format analyzer\n   -----------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written by @_L4ys\n\n   Based on afl-showmap by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\n\n   Copyright 2016, 2017 Google Inc. All rights reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at:\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   A nifty utility that grabs an input file and takes a stab at explaining\n   its structure by observing how changes to it affect the execution path.\n\n   If the output scrolls past the edge of the screen, pipe it to 'less -r'.\n\n */\n\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_RAND_S\n#define VERSION             \"2.52b\"\n\n#define AFL_MAIN\n\n#include <windows.h>\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <io.h>\n#include <direct.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <fcntl.h>\n#include <ctype.h>\n\n#include <sys/stat.h>\n\nstatic s32 child_pid;                 /* PID of the tested program         */\n\nstatic HANDLE child_handle,\nchild_thread_handle;\nstatic char *dynamorio_dir;\nstatic char *client_params;\n\nstatic CRITICAL_SECTION critical_section;\nstatic u64 watchdog_timeout_time;\nstatic u8 watchdog_enabled;\nstatic u8 *target_cmd;                /* command line of target           */\n\nstatic HANDLE shm_handle;             /* Handle of the SHM region         */\nstatic HANDLE pipe_handle;            /* Handle of the name pipe          */\nstatic u64    name_seed;              /* Random integer to have a unique shm/pipe name */\nstatic HANDLE devnul_handle;          /* Handle of the nul device         */\nstatic u8     sinkhole_stds = 1;      /* Sink-hole stdout/stderr messages?*/\nstatic char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized\n                                         seed allowing multiple instances */\n\nstatic u8* trace_bits;                /* SHM with instrumentation bitmap   */\n\nstatic u8 *in_file,                   /* Analyzer input test case          */\n          *prog_in,                   /* Targeted program input file       */\n          *target_path,               /* Path to target binary             */\n          *doc_path;                  /* Path to docs                      */\n\nstatic u8 *in_data;                   /* Input data for analysis           */\n\nstatic u32 in_len,                    /* Input data length                 */\n           orig_cksum,                /* Original checksum                 */\n           total_execs,               /* Total number of execs             */\n           exec_hangs,                /* Total number of hangs             */\n           exec_tmout = EXEC_TIMEOUT; /* Exec timeout (ms)                 */\n\nstatic u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */\n\nstatic s32 shm_id,                    /* ID of the SHM region              */\n           dev_null_fd = -1;          /* FD to /dev/null                   */\n\nstatic u8  edges_only,                /* Ignore hit counts?                */\n           use_hex_offsets,           /* Show hex offsets?                 */\n           use_stdin = 1,             /* Use stdin for program input?      */\n           drioless = 0;              /* Running without DRIO?             */\n\n\nstatic volatile u8\n           stop_soon,                 /* Ctrl-C pressed?                   */\n           child_timed_out;           /* Child timed out?                  */\n\n\n/* Constants used for describing byte behavior. */\n\n#define RESP_NONE       0x00          /* Changing byte is a no-op.         */\n#define RESP_MINOR      0x01          /* Some changes have no effect.      */\n#define RESP_VARIABLE   0x02          /* Changes produce variable paths.   */\n#define RESP_FIXED      0x03          /* Changes produce fixed patterns.   */\n\n#define RESP_LEN        0x04          /* Potential length field            */\n#define RESP_CKSUM      0x05          /* Potential checksum                */\n#define RESP_SUSPECT    0x06          /* Potential \"suspect\" blob          */\n\n\n/* Classify tuple counts. This is a slow & naive version, but good enough here. */\n#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)\n#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)\n#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)\n#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)\n#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)\n#define AREP128(_sym) AREP64(_sym), AREP64(_sym)\nstatic u8 count_class_lookup[256] = {\n\n  /* 0 - 3:       4 */ 0, 1, 2, 4,\n  /* 4 - 7:      +4 */ AREP4(8),\n  /* 8 - 15:     +8 */ AREP8(16),\n  /* 16 - 31:   +16 */ AREP16(32),\n  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),\n  /* 128+:     +128 */ AREP128(128)\n\n};\n\nstatic void classify_counts(u8* mem) {\n\n  u32 i = MAP_SIZE;\n\n  if (edges_only) {\n\n    while (i--) {\n      if (*mem) *mem = 1;\n      mem++;\n    }\n\n  } else {\n\n    while (i--) {\n      *mem = count_class_lookup[*mem];\n      mem++;\n    }\n\n  }\n\n}\n\n\n/* See if any bytes are set in the bitmap. */\n\nstatic inline u8 anything_set(void) {\n\n  u32* ptr = (u32*)trace_bits;\n  u32  i   = (MAP_SIZE >> 2);\n\n  while (i--) if (*(ptr++)) return 1;\n\n  return 0;\n\n}\n\n\n/* Get unix time in milliseconds */\n\nstatic u64 get_cur_time(void) {\n\n    u64 ret;\n    FILETIME filetime;\n    GetSystemTimeAsFileTime(&filetime);\n\n    ret = (((u64)filetime.dwHighDateTime) << 32) + (u64)filetime.dwLowDateTime;\n\n    return ret / 10000;\n\n}\n\n\nchar *alloc_printf(const char *_str, ...) {\n\n  va_list argptr;\n  char* _tmp;\n  s32 _len;\n\n  va_start(argptr, _str);\n  _len = vsnprintf(NULL, 0, _str, argptr);\n  if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\");\n  _tmp = ck_alloc(_len + 1);\n  vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);\n  va_end(argptr);\n  return _tmp;\n\n}\n\n\n/* Get rid of shared memory and temp files (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  UnmapViewOfFile(trace_bits);\n  CloseHandle(shm_handle);\n  if (prog_in) _unlink(prog_in); /* Ignore errors */\n\n}\n\n\n/* Configure shared memory. */\n\nstatic void setup_shm(void) {\n\n  char* shm_str = NULL;\n  unsigned int seeds[2];\n  u64 name_seed;\n  u8 attempts = 0;\n\n  while(attempts < 5) {\n    if(fuzzer_id == NULL) {\n      // If it is null, it means we have to generate a random seed to name the instance\n      rand_s(&seeds[0]);\n      rand_s(&seeds[1]);\n      name_seed = ((u64)seeds[0] << 32) | seeds[1];\n      fuzzer_id = (char *)alloc_printf(\"%I64x\", name_seed);\n    }\n\n    shm_str = (char *)alloc_printf(\"afl_shm_%s\", fuzzer_id);\n\n    shm_handle = CreateFileMapping(\n                   INVALID_HANDLE_VALUE,    // use paging file\n                   NULL,                    // default security\n                   PAGE_READWRITE,          // read/write access\n                   0,                       // maximum object size (high-order DWORD)\n                   MAP_SIZE,                // maximum object size (low-order DWORD)\n                   (char *)shm_str);        // name of mapping object\n\n    if(shm_handle == NULL) {\n      if(GetLastError() == ERROR_ALREADY_EXISTS) {\n        // We need another attempt to find a unique section name\n        attempts++;\n        ck_free(shm_str);\n        ck_free(fuzzer_id);\n        fuzzer_id = NULL;\n        continue;\n      }\n      else {\n        PFATAL(\"CreateFileMapping failed\");\n      }\n    }\n\n    // We found a section name that works!\n    break;\n  }\n\n  if(attempts == 5) {\n    FATAL(\"Could not find a section name.\\n\");\n  }\n\n  atexit(remove_shm);\n\n  ck_free(shm_str);\n\n  trace_bits = (u8 *)MapViewOfFile(\n    shm_handle,          // handle to map object\n    FILE_MAP_ALL_ACCESS, // read/write permission\n    0,\n    0,\n    MAP_SIZE\n  );\n\n  if (!trace_bits) PFATAL(\"MapViewOfFile() failed\");\n\n}\n\n\n/* Read initial file. */\n\nstatic void read_initial_file(void) {\n\n  struct stat st;\n  s32 fd = _open(in_file, O_RDONLY | O_BINARY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", in_file);\n\n  if (fstat(fd, &st) || !st.st_size)\n    FATAL(\"Zero-sized input file.\");\n\n  if (st.st_size >= TMIN_MAX_FILE)\n    FATAL(\"Input file is too large (%u MB max)\", TMIN_MAX_FILE / 1024 / 1024);\n\n  in_len  = st.st_size;\n  in_data = ck_alloc_nozero(in_len);\n\n  ck_read(fd, in_data, in_len, in_file);\n\n  _close(fd);\n\n  OKF(\"Read %u byte%s from '%s'.\", in_len, in_len == 1 ? \"\" : \"s\", in_file);\n\n}\n\n\n/* Write output file. */\n\nstatic void write_to_file(u8* path, u8* mem, u32 len) {\n\n  s32 ret;\n\n  ret = _open(path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, DEFAULT_PERMISSION);\n\n  if (ret < 0) PFATAL(\"Unable to create '%s'\", path);\n\n  ck_write(ret, mem, len, path);\n\n  _close(ret);\n\n}\n\n\n/* Handle timeout signal. */\n\n/*static void handle_timeout(int sig) {\n\n  child_timed_out = 1;\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}*/\n\n\n//quoting on Windows is weird\nsize_t ArgvQuote(char *in, char *out) {\n  int needs_quoting = 0;\n  size_t size = 0;\n  char *p = in;\n  size_t i;\n\n  //check if quoting is necessary\n  if(strchr(in, ' ')) needs_quoting = 1;\n  if(strchr(in, '\\\"')) needs_quoting = 1;\n  if(strchr(in, '\\t')) needs_quoting = 1;\n  if(strchr(in, '\\n')) needs_quoting = 1;\n  if(strchr(in, '\\v')) needs_quoting = 1;\n  if(!needs_quoting) {\n    size = strlen(in);\n    if(out) memcpy(out, in, size);\n    return size;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  while(*p) {\n    size_t num_backslashes = 0;\n    while((*p) && (*p == '\\\\')) {\n      p++;\n      num_backslashes++;\n    }\n\n    if(*p == 0) {\n      for(i = 0; i < (num_backslashes*2); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      break;\n    } else if(*p == '\\\"') {\n      for(i = 0; i < (num_backslashes*2 + 1); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    } else {\n      for(i = 0; i < num_backslashes; i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    }\n\n    p++;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  return size;\n}\n\n\nchar *argv_to_cmd(char** argv) {\n  u32 len = 0, i;\n  u8* buf, *ret;\n\n  //todo shell-escape\n\n  for (i = 0; argv[i]; i++)\n    len += ArgvQuote(argv[i], NULL) + 1;\n  \n  if(!len) FATAL(\"Error creating command line\");\n\n  buf = ret = ck_alloc(len);\n\n  for (i = 0; argv[i]; i++) {\n\n    u32 l = ArgvQuote(argv[i], buf);\n\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  ret[len-1] = 0;\n\n  return ret;\n}\n\nstatic void create_target_process(char** argv) {\n  char* cmd;\n  char* pipe_name;\n  char *buf;\n  char *pidfile = NULL;\n  FILE *fp;\n  size_t pidsize;\n  BOOL inherit_handles = TRUE;\n  HANDLE hJob = NULL;\n  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;\n\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n\n  pipe_name = (char *)alloc_printf(\"\\\\\\\\.\\\\pipe\\\\afl_pipe_%s\", fuzzer_id);\n\n  pipe_handle = CreateNamedPipe(\n    pipe_name,                // pipe name\n    PIPE_ACCESS_DUPLEX,       // read/write access\n    0,\n    1,                        // max. instances\n    512,                      // output buffer size\n    512,                      // input buffer size\n    20000,                    // client time-out\n    NULL);                    // default security attribute\n\n  if (pipe_handle == INVALID_HANDLE_VALUE) {\n    FATAL(\"CreateNamedPipe failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  target_cmd = argv_to_cmd(argv);\n\n  if (drioless) {\n    char *static_config = alloc_printf(\"%s:1\", fuzzer_id);\n\n    if (static_config == NULL) {\n      FATAL(\"Cannot allocate static_config.\");\n    }\n\n    SetEnvironmentVariable(\"AFL_STATIC_CONFIG\", static_config);\n    cmd = alloc_printf(\"%s\", target_cmd);\n    ck_free(static_config);\n  } else {\n    pidfile = alloc_printf(\"childpid_%s.txt\", fuzzer_id);\n    cmd = alloc_printf(\n      \"%s\\\\drrun.exe -pidfile %s -no_follow_children -c winafl.dll %s -fuzz_iterations 1 -fuzzer_id %s -- %s\",\n      dynamorio_dir, pidfile, client_params, fuzzer_id, target_cmd\n    );\n  }\n\n  ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof(si);\n  ZeroMemory(&pi, sizeof(pi));\n\n  if (sinkhole_stds) {\n    si.hStdOutput = si.hStdError = devnul_handle;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n  } else {\n    inherit_handles = FALSE;\n  }\n\n  if (mem_limit != 0) {\n    hJob = CreateJobObject(NULL, NULL);\n    if (hJob == NULL) {\n      FATAL(\"CreateJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    ZeroMemory(&job_limit, sizeof(job_limit));\n    job_limit.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_MEMORY;\n    job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;\n\n    if (!SetInformationJobObject(\n      hJob,\n      JobObjectExtendedLimitInformation,\n      &job_limit,\n      sizeof(job_limit)\n    )) {\n      FATAL(\"SetInformationJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  if (!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {\n    FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  child_handle = pi.hProcess;\n  child_thread_handle = pi.hThread;\n\n  if (mem_limit != 0) {\n    if (!AssignProcessToJobObject(hJob, child_handle)) {\n      FATAL(\"AssignProcessToJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  ResumeThread(child_thread_handle);\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n  watchdog_enabled = 1;\n\n  if (!ConnectNamedPipe(pipe_handle, NULL)) {\n    if (GetLastError() != ERROR_PIPE_CONNECTED) {\n      FATAL(\"ConnectNamedPipe failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  watchdog_enabled = 0;\n\n  if (drioless == 0) {\n    //by the time pipe has connected the pidfile must have been created\n    fp = fopen(pidfile, \"rb\");\n    if (!fp) {\n      FATAL(\"Error opening pidfile.txt\");\n    }\n    fseek(fp,0,SEEK_END);\n    pidsize = ftell(fp);\n    fseek(fp,0,SEEK_SET);\n    buf = (char *)malloc(pidsize+1);\n    if (!buf) {\n        FATAL(\"Error allocating %Iu bytes\", pidsize + 1);\n    }\n    fread(buf, pidsize, 1, fp);\n    buf[pidsize] = 0;\n    fclose(fp);\n    remove(pidfile);\n    child_pid = atoi(buf);\n    free(buf);\n    ck_free(pidfile);\n  }\n  else {\n    child_pid = pi.dwProcessId;\n  }\n\n  ck_free(target_cmd);\n  ck_free(cmd);\n  ck_free(pipe_name);\n}\n\n\nstatic void destroy_target_process(int wait_exit) {\n  char* kill_cmd;\n  BOOL still_alive = TRUE;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n\n  EnterCriticalSection(&critical_section);\n\n  if(!child_handle) {\n    goto leave;\n  }\n\n  if(WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {\n    goto done;\n  }\n\n  // nudge the child process only if dynamorio is used\n  if(drioless) {\n    TerminateProcess(child_handle, 0);\n  } else {\n    kill_cmd = alloc_printf(\"%s\\\\drconfig.exe -nudge_pid %d 0 1\", dynamorio_dir, child_pid);\n\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n\n    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n      FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    ck_free(kill_cmd);\n  }\n\n  still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;\n\n  if(still_alive) {\n    //wait until the child process exits\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n\n    kill_cmd = alloc_printf(\"taskkill /PID %d /F\", child_pid);\n\n    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n      FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    ck_free(kill_cmd);\n\n    if(WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {\n      FATAL(\"Cannot kill child process\\n\");\n    }\n  }\n\n  done:\n  CloseHandle(child_handle);\n  CloseHandle(child_thread_handle);\n\n  child_handle = NULL;\n  child_thread_handle = NULL;\n\n  leave:\n  //close the pipe\n  if(pipe_handle) {\n    DisconnectNamedPipe(pipe_handle);\n    CloseHandle(pipe_handle);\n\n    pipe_handle = NULL;\n  }\n\n  LeaveCriticalSection(&critical_section);\n}\n\n\nDWORD WINAPI watchdog_timer( LPVOID lpParam ) {\n  u64 current_time;\n  while(1) {\n    Sleep(1000);\n    current_time = get_cur_time();\n    if(watchdog_enabled && (current_time > watchdog_timeout_time)) {\n      child_timed_out = 1;\n      destroy_target_process(0);\n    }\n  }\n}\n\n\nstatic void setup_watchdog_timer() {\n  watchdog_enabled = 0;\n  InitializeCriticalSection(&critical_section);\n  CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);\n}\n\n\nstatic int is_child_running() {\n   return (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));\n}\n\n/* Execute target application. Returns exec checksum, or 0 if program\n   times out. */\n\nstatic u32 run_target(char** argv, u8* mem, u32 len, u8 first_run) {\n\n  int status = 0;\n  char command[] = \"F\";\n  DWORD num_read;\n  char result = 0;\n  u32 cksum;\n\n  memset(trace_bits, 0, MAP_SIZE);\n  MemoryBarrier();\n\n  write_to_file(prog_in, mem, len);\n\n  if (!is_child_running()) {\n      destroy_target_process(0);\n      create_target_process(argv);\n  }\n\n  child_timed_out = 0;\n  memset(trace_bits, 0, MAP_SIZE);\n  MemoryBarrier();\n\n  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  if (result == 'K')\n  {\n      //a workaround for first cycle\n      ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  }\n  if (result != 'P')\n  {\n      FATAL(\"Unexpected result from pipe! expected 'P', instead received '%c'\\n\", result);\n  }\n  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  WriteFile(\n      pipe_handle,  // handle to pipe\n      command,      // buffer to write from\n      1,            // number of bytes to write\n      &num_read,    // number of bytes written\n      NULL);        // not overlapped I/O\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n\n  if (exec_tmout) {\n      watchdog_enabled = 1;\n  }\n\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n\n  if (exec_tmout) {\n      watchdog_enabled = 0;\n  }\n\n  MemoryBarrier();\n\n  /* Clean up bitmap, analyze exit condition, etc. */\n\n  classify_counts(trace_bits);\n  total_execs++;\n\n  destroy_target_process(2000);\n\n  if (stop_soon) {\n    SAYF(cRST cLRD \"\\n+++ Analysis aborted by user +++\\n\" cRST);\n    exit(1);\n  }\n\n  /* Always discard inputs that time out. */\n\n  if (child_timed_out) {\n\n    exec_hangs++;\n    return 0;\n\n  }\n\n  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n  /* We don't actually care if the target is crashing or not,\n     except that when it does, the checksum should be different. */\n\n  cksum ^= 0xffffffff;\n\n  if (first_run) orig_cksum = cksum;\n\n  return cksum;\n\n}\n\n\n#ifdef USE_COLOR\n\n/* Helper function to display a human-readable character. */\n\nstatic void show_char(u8 val) {\n\n  if (val <= 32 || val >= 127)\n    SAYF(\"#%02x\", val);\n  else\n    SAYF(\" %c \", val);\n\n}\n\n\n/* Show the legend */\n\nstatic void show_legend(void) {\n\n  SAYF(\"    \" cLGR bgGRA \" 01 \" cRST \" - no-op block              \"\n              cBLK bgLGN \" 01 \" cRST \" - suspected length field\\n\"\n       \"    \" cBRI bgGRA \" 01 \" cRST \" - superficial content      \"\n              cBLK bgYEL \" 01 \" cRST \" - suspected cksum or magic int\\n\"\n       \"    \" cBLK bgCYA \" 01 \" cRST \" - critical stream          \"\n              cBLK bgLRD \" 01 \" cRST \" - suspected checksummed block\\n\"\n       \"    \" cBLK bgMGN \" 01 \" cRST \" - \\\"magic value\\\" section\\n\\n\");\n\n}\n\n#endif /* USE_COLOR */\n\n\n/* Interpret and report a pattern in the input file. */\n\nstatic void dump_hex(u8* buf, u32 len, u8* b_data) {\n\n  u32 i;\n\n  for (i = 0; i < len; i++) {\n\n#ifdef USE_COLOR\n    u32 rlen = 1, off;\n#else\n    u32 rlen = 1;\n#endif /* ^USE_COLOR */\n\n    u8  rtype = b_data[i] & 0x0f;\n\n    /* Look ahead to determine the length of run. */\n\n    while (i + rlen < len && (b_data[i] >> 7) == (b_data[i + rlen] >> 7)) {\n\n      if (rtype < (b_data[i + rlen] & 0x0f)) rtype = b_data[i + rlen] & 0x0f;\n      rlen++;\n\n    }\n\n    /* Try to do some further classification based on length & value. */\n\n    if (rtype == RESP_FIXED) {\n\n      switch (rlen) {\n\n        case 2: {\n\n            u16 val = *(u16*)(in_data + i);\n\n            /* Small integers may be length fields. */\n\n            if (val && (val <= in_len || SWAP16(val) <= in_len)) {\n              rtype = RESP_LEN;\n              break;\n            }\n\n            /* Uniform integers may be checksums. */\n\n            if (val && abs(in_data[i] - in_data[i + 1]) > 32) {\n              rtype = RESP_CKSUM;\n              break;\n            }\n\n            break;\n\n          }\n\n        case 4: {\n\n            u32 val = *(u32*)(in_data + i);\n\n            /* Small integers may be length fields. */\n\n            if (val && (val <= in_len || SWAP32(val) <= in_len)) {\n              rtype = RESP_LEN;\n              break;\n            }\n\n            /* Uniform integers may be checksums. */\n\n            if (val && (in_data[i] >> 7 != in_data[i + 1] >> 7 ||\n                in_data[i] >> 7 != in_data[i + 2] >> 7 ||\n                in_data[i] >> 7 != in_data[i + 3] >> 7)) {\n              rtype = RESP_CKSUM;\n              break;\n            }\n\n            break;\n\n          }\n\n        default: \n            if (rtype == 1 || rtype == 3 || (rtype >= 5 && rtype <= MAX_AUTO_EXTRA - 1))\n                break;\n            rtype = RESP_SUSPECT;\n\n      }\n\n    }\n\n    /* Print out the entire run. */\n\n#ifdef USE_COLOR\n\n    for (off = 0; off < rlen; off++) {\n\n      /* Every 16 digits, display offset. */\n\n      if (!((i + off) % 16)) {\n\n        if (off) SAYF(cRST cLCY \">\");\n\n        if (use_hex_offsets)\n          SAYF(cRST cGRA \"%s[%06x] \" cRST, (i + off) ? \"\\n\" : \"\", i + off);\n        else\n          SAYF(cRST cGRA \"%s[%06u] \" cRST, (i + off) ? \"\\n\" : \"\", i + off);\n\n      }\n\n      switch (rtype) {\n\n        case RESP_NONE:     SAYF(cLGR bgGRA); break;\n        case RESP_MINOR:    SAYF(cBRI bgGRA); break;\n        case RESP_VARIABLE: SAYF(cBLK bgCYA); break;\n        case RESP_FIXED:    SAYF(cBLK bgMGN); break;\n        case RESP_LEN:      SAYF(cBLK bgLGN); break;\n        case RESP_CKSUM:    SAYF(cBLK bgYEL); break;\n        case RESP_SUSPECT:  SAYF(cBLK bgLRD); break;\n\n      }\n\n      show_char(in_data[i + off]);\n\n      if (off != rlen - 1 && (i + off + 1) % 16) SAYF(\" \"); else SAYF(cRST \" \");\n\n    }\n\n#else\n\n    if (use_hex_offsets)\n      SAYF(\"    Offset %x, length %u: \", i, rlen);\n    else\n      SAYF(\"    Offset %u, length %u: \", i, rlen);\n\n    switch (rtype) {\n\n      case RESP_NONE:     SAYF(\"no-op block\\n\"); break;\n      case RESP_MINOR:    SAYF(\"superficial content\\n\"); break;\n      case RESP_VARIABLE: SAYF(\"critical stream\\n\"); break;\n      case RESP_FIXED:    SAYF(\"\\\"magic value\\\" section\\n\"); break;\n      case RESP_LEN:      SAYF(\"suspected length field\\n\"); break;\n      case RESP_CKSUM:    SAYF(\"suspected cksum or magic int\\n\"); break;\n      case RESP_SUSPECT:  SAYF(\"suspected checksummed block\\n\"); break;\n\n    }\n\n#endif /* ^USE_COLOR */\n\n    i += rlen - 1;\n\n  }\n\n#ifdef USE_COLOR\n  SAYF(cRST \"\\n\");\n#endif /* USE_COLOR */\n\n}\n\n\n\n/* Actually analyze! */\n\nstatic void analyze(char** argv) {\n\n  u32 i;\n  u32 boring_len = 0, prev_xff = 0, prev_x01 = 0, prev_s10 = 0, prev_a10 = 0;\n\n  u8* b_data = ck_alloc(in_len + 1);\n  u8  seq_byte = 0;\n\n  b_data[in_len] = 0xff; /* Intentional terminator. */\n\n  ACTF(\"Analyzing input file (this may take a while)...\\n\");\n\n#ifdef USE_COLOR\n  show_legend();\n#endif /* USE_COLOR */\n\n  for (i = 0; i < in_len; i++) {\n\n    u32 xor_ff, xor_01, sub_10, add_10;\n    u8  xff_orig, x01_orig, s10_orig, a10_orig;\n\n    /* Perform walking byte adjustments across the file. We perform four\n       operations designed to elicit some response from the underlying\n       code. */\n\n    in_data[i] ^= 0xff;\n    xor_ff = run_target(argv, in_data, in_len, 0);\n\n    in_data[i] ^= 0xfe;\n    xor_01 = run_target(argv, in_data, in_len, 0);\n\n    in_data[i] = (in_data[i] ^ 0x01) - 0x10;\n    sub_10 = run_target(argv, in_data, in_len, 0);\n\n    in_data[i] += 0x20;\n    add_10 = run_target(argv, in_data, in_len, 0);\n    in_data[i] -= 0x10;\n\n    /* Classify current behavior. */\n\n    xff_orig = (xor_ff == orig_cksum);\n    x01_orig = (xor_01 == orig_cksum);\n    s10_orig = (sub_10 == orig_cksum);\n    a10_orig = (add_10 == orig_cksum);\n\n    if (xff_orig && x01_orig && s10_orig && a10_orig) {\n\n      b_data[i] = RESP_NONE;\n      boring_len++;\n\n    } else if (xff_orig || x01_orig || s10_orig || a10_orig) {\n\n      b_data[i] = RESP_MINOR;\n      boring_len++;\n\n    } else if (xor_ff == xor_01 && xor_ff == sub_10 && xor_ff == add_10) {\n\n      b_data[i] = RESP_FIXED;\n\n    } else b_data[i] = RESP_VARIABLE;\n\n    /* When all checksums change, flip most significant bit of b_data. */\n\n    if (prev_xff != xor_ff && prev_x01 != xor_01 &&\n        prev_s10 != sub_10 && prev_a10 != add_10) seq_byte ^= 0x80;\n\n    b_data[i] |= seq_byte;\n\n    prev_xff = xor_ff;\n    prev_x01 = xor_01;\n    prev_s10 = sub_10;\n    prev_a10 = add_10;\n\n  } \n\n  dump_hex(in_data, in_len, b_data);\n\n  SAYF(\"\\n\");\n\n  OKF(\"Analysis complete. Interesting bits: %0.02f%% of the input file.\",\n      100.0 - ((double)boring_len * 100) / in_len);\n\n  if (exec_hangs)\n    WARNF(cLRD \"Encountered %u timeouts - results may be skewed.\" cRST,\n          exec_hangs);\n\n  ck_free(b_data);\n\n}\n\n\n\n/* Handle Ctrl-C and the like. */\n\n/*static void handle_stop_sig(int sig) {\n\n  stop_soon = 1;\n\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n\n}*/\n\n\n/* Do basic preparations - persistent fds, filenames, etc. */\n\nstatic void set_up_environment(void) {\n\n    if (sinkhole_stds) {\n        devnul_handle = CreateFile(\n            \"nul\",\n            GENERIC_READ | GENERIC_WRITE,\n            FILE_SHARE_READ | FILE_SHARE_WRITE,\n            NULL,\n            OPEN_EXISTING,\n            0,\n            NULL\n        );\n\n        if (devnul_handle == INVALID_HANDLE_VALUE) {\n            PFATAL(\"Unable to open the nul device.\");\n        }\n    }\n\n    if (!prog_in) {\n\n        u8* use_dir = getenv(\"TMP\");\n        prog_in = alloc_printf(\"%s\\\\.afl-analyze-temp-%u\", use_dir, GetCurrentProcessId());\n\n    }\n\n}\n\n/* Setup signal handlers, duh. */\n\nstatic void setup_signal_handlers(void) {\n  //not implemented on Windows\n}\n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = _getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      aa_subst = prog_in;\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      //if (prog_in[0] != '/') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  SAYF(\"\\n%s [ options ] -- [instrumentation options] -- \\\\path\\\\to\\\\target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i file       - input test case to be analyzed by the tool\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - input file read by the tested program (stdin)\\n\"\n       \"  -t msec       - timeout for each run (%u ms)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n\n       \"Analysis settings:\\n\\n\"\n\n       \"  -e            - look for edge coverage only, ignore hit counts\\n\\n\"\n\n       \"Other stuff:\\n\\n\"\n\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"For additional tips, please consult %s/README.\\n\\n\",\n\n       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Find binary. */\n\nstatic void find_binary(u8* fname) {\n  // Not implemented on Windows\n}\n\n\n/* Fix up argv for QEMU. */\n\nstatic char** get_qemu_argv(u8* own_loc, char** argv, int argc) {\n  //not implemented on Windows\n  return NULL;\n}\n\n\nstatic unsigned int optind;\nstatic char *optarg;\n\nint getopt(int argc, char **argv, char *optstring) {\n  char *c;\n\n  optarg = NULL;\n\n  while(1) {\n    if(optind == argc) return -1;\n    if(strcmp(argv[optind], \"--\") == 0) return -1;\n    if(argv[optind][0] != '-') {\n      optind++;\n      continue;\n    }\n    if(!argv[optind][1]) {\n      optind++;\n      continue;\n    }\n\n    c = strchr(optstring, argv[optind][1]);\n    if(!c) return -1;\n    optind++;\n    if(c[1] == ':') {\n      if(optind == argc) return -1;\n      optarg = argv[optind];\n      optind++;\n    }\n\n    return (int)(c[0]);\n  }\n}\n\nstatic void extract_client_params(u32 argc, char** argv) {\n  u32 len = 1, i;\n  u32 nclientargs = 0;\n  u8* buf;\n  u32 opt_start, opt_end;\n\n  if(!argv[optind] || optind >= argc) usage(argv[0]);\n  if(strcmp(argv[optind],\"--\")) usage(argv[0]);\n\n  if(drioless) return;\n  optind++;\n  opt_start = optind;\n\n  for (i = optind; i < argc; i++) {\n    if(strcmp(argv[i],\"--\") == 0) break;\n    nclientargs++;\n    len += strlen(argv[i]) + 1;\n  }\n\n  if(i == argc) usage(argv[0]);\n  opt_end = i;\n\n  buf = client_params = ck_alloc(len);\n\n  for (i = opt_start; i < opt_end; i++) {\n\n    u32 l = strlen(argv[i]);\n\n    memcpy(buf, argv[i], l);\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  if(buf != client_params) {\n    buf--;\n  }\n\n  *buf = 0;\n\n  optind = opt_end;\n\n}\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0, qemu_mode = 0;\n  char** use_argv;\n\n  doc_path = \"docs\";\n\n#ifdef USE_COLOR\n  enable_ansi_console();\n#endif\n\n  SAYF(cCYA \"afl-analyze for Windows \" cBRI VERSION cRST \" by <l4ys.tw@gmail.com>\\n\");\n  SAYF(\"Based on WinAFL \" cBRI VERSION cRST \" by <ifratric@google.com>\\n\");\n  SAYF(\"Based on AFL \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n  \n  while ((opt = getopt(argc,argv,\"+i:f:m:t:D:eQYV\")) > 0)\n\n    switch (opt) {\n\n      case 'D': /* dynamorio dir */\n\n        if(dynamorio_dir) FATAL(\"Multiple -D options not supported\");\n        dynamorio_dir = optarg;\n        break;\n\n      case 'i':\n\n        if (in_file) FATAL(\"Multiple -i options not supported\");\n        in_file = optarg;\n        break;\n\n      case 'f':\n\n        if (prog_in) FATAL(\"Multiple -f options not supported\");\n        use_stdin = 0;\n        prog_in   = optarg;\n        break;\n\n      case 'e':\n\n        if (edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if (timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        exec_tmout = atoi(optarg);\n\n        if (exec_tmout < 10 || optarg[0] == '-')\n          FATAL(\"Dangerously low value of -t\");\n\n        break;\n\n      case 'Q':\n\n        FATAL(\"QEMU mode not supported on Windows\");\n        break;\n        \n      case 'Y':\n\n        if (dynamorio_dir) FATAL(\"Dynamic-instrumentation (DRIO) is uncompatible with static-instrumentation\");\n        drioless = 1;\n\n        break;\n\n      case 'V': /* Show version number */\n\n        /* Version number has been printed already, just quit. */\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (!in_file) usage(argv[0]);\n  if(!drioless) {\n    if(optind == argc || !dynamorio_dir) usage(argv[0]);\n  }\n\n  extract_client_params(argc, argv);\n  optind++;\n\n  if (getenv(\"AFL_NO_SINKHOLE\")) sinkhole_stds = 0;\n  \n  use_hex_offsets = !!getenv(\"AFL_ANALYZE_HEX\");\n\n  setup_shm();\n  setup_watchdog_timer();\n  setup_signal_handlers();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n  detect_file_args(argv + optind);\n\n  use_argv = argv + optind;\n\n  SAYF(\"\\n\");\n  read_initial_file();\n\n  ACTF(\"Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...\",\n       mem_limit, exec_tmout, edges_only ? \", edges only\" : \"\");\n\n  run_target(use_argv, in_data, in_len, 1);\n\n  if (child_timed_out)\n    FATAL(\"Target binary times out (adjusting -t may help).\");\n\n  if (!anything_set()) FATAL(\"No instrumentation detected.\");\n\n  analyze(use_argv);\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}\n"
        },
        {
          "name": "afl-fuzz.c",
          "type": "blob",
          "size": 218.546875,
          "content": "/*\n   american fuzzy lop - fuzzer code\n   --------------------------------\n\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n#define _CRT_SECURE_NO_WARNINGS\n\n#define AFL_MAIN\n#define MESSAGES_TO_STDOUT\n\n#define _GNU_SOURCE\n#define _FILE_OFFSET_BITS 64\n\n#define WIN32_LEAN_AND_MEAN /* prevent winsock.h to be included in windows.h */\n\n#define _CRT_RAND_S\n#define MAX_SAMPLE_SIZE 1000000\n\n#include <windows.h>\n#include <TlHelp32.h>\n#include <stdarg.h>\n#include <io.h>\n#include <direct.h>\n#include <pdh.h>\n#include <pdhmsg.h>\n#pragma comment(lib, \"pdh.lib\")\n\n#define VERSION \"2.43b\"\n#define WINAFL_VERSION \"1.17\"\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <ctype.h>\n#include <fcntl.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#ifdef TINYINST\nint tinyinst_init(int argc, char** argv);\nvoid tinyinst_set_fuzzer_id(char* fuzzer_id);\nint tinyinst_run(char** argv, uint32_t timeout);\nvoid tinyinst_killtarget();\n#endif\n\n#if defined(__APPLE__) || defined(__FreeBSD__) || defined (__OpenBSD__)\n#  include <sys/sysctl.h>\n#endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */\n\n/* Lots of globals, but mostly for the status UI and other things where it\n   really makes no sense to haul them around as function parameters. */\nBOOL use_sample_shared_memory = FALSE;\nstatic u8 *in_dir,                    /* Input directory with test cases  */\n          *out_file,                  /* File to fuzz, if any             */\n          *out_dir,                   /* Working & output directory       */\n          *sync_dir,                  /* Synchronization directory        */\n          *sync_id,                   /* Fuzzer ID                        */\n          *use_banner,                /* Display banner                   */\n          *in_bitmap,                 /* Input bitmap                     */\n          *doc_path,                  /* Path to documentation dir        */\n          *target_path,               /* Path to target binary            */\n          *target_cmd,                /* command line of target           */\n          *orig_cmdline;              /* Original command line            */\n\n\nstatic u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */\nstatic u32 init_tmout = 0;            /* Configurable init timeout (ms)   */\nstatic u32 hang_tmout = EXEC_TIMEOUT; /* Timeout used for hang det (ms)   */\n\nu64 mem_limit  = MEM_LIMIT;           /* Memory cap for child (MB)        */\n\nstatic u32 stats_update_freq = 1,     /* Stats update frequency (execs)   */\n           drattachpid = 0;\t          /* running process id for attach    */\n\nstatic u8  skip_deterministic,        /* Skip deterministic stages?       */\n           force_deterministic,       /* Force deterministic stages?      */\n           use_splicing,              /* Recombine input files?           */\n           dumb_mode,                 /* Run in non-instrumented mode?    */\n           score_changed,             /* Scoring for favorites changed?   */\n           kill_signal,               /* Signal that killed the child     */\n           resuming_fuzz,             /* Resuming an older fuzzing job?   */\n           timeout_given,             /* Specific timeout given?          */\n           not_on_tty,                /* stdout is not a tty              */\n           term_too_small,            /* terminal dimensions too small    */\n           uses_asan,                 /* Target uses ASAN?                */\n           no_forkserver,             /* Disable forkserver?              */\n           crash_mode,                /* Crash mode! Yeah!                */\n           in_place_resume,           /* Attempt in-place resume?         */\n           autoresume,                /* Resume if out_dir exists?        */\n           auto_changed,              /* Auto-generated tokens changed?   */\n           no_cpu_meter_red,          /* Feng shui on the status screen   */\n           no_arith,                  /* Skip most arithmetic ops         */\n           shuffle_queue,             /* Shuffle input queue?             */\n           bitmap_changed = 1,        /* Time to update bitmap?           */\n           qemu_mode,                 /* Running in QEMU mode?            */\n           skip_requested,            /* Skip request, via SIGUSR1        */\n           run_over10m,               /* Run time over 10 minutes?        */\n           persistent_mode,           /* Running in persistent mode?      */\n           drioless = 0,              /* Running without DRIO?            */\n           drattach = 0;\t            /* attaching to a running process   */\n           use_intelpt = 0;           /* Using Intel PT instrumentation   */\n           use_tinyinst = 0;          /* Using TinyInst instrumentation   */\n           custom_dll_defined = 0;    /* Custom DLL path defined?         */\n           persist_dr_cache = 0;      /* Enable persisting code caches?   */\n           expert_mode = 0;           /* Running in expert mode with DRIO?*/\n\nstatic s32 out_fd,                    /* Persistent fd for out_file       */\n           dev_urandom_fd = -1,       /* Persistent fd for /dev/urandom   */\n           dev_null_fd = -1,          /* Persistent fd for /dev/null      */\n           fsrv_ctl_fd,               /* Fork server control pipe (write) */\n           fsrv_st_fd;                /* Fork server status pipe (read)   */\n\n           child_pid = -1,            /* PID of the fuzzed program        */\n           out_dir_fd = -1;           /* FD of the lock file              */\n\nHANDLE child_handle, child_thread_handle;\nchar *dynamorio_dir;\nchar *drattach_identifier;\nchar *client_params;\nchar *winafl_dll_path;\nint fuzz_iterations_max = 5000, fuzz_iterations_current;\nDWORD ret_exception_code = 0;\n\nCRITICAL_SECTION critical_section;\nu64 watchdog_timeout_time;\nint watchdog_enabled;\n\nPDH_HQUERY cpuQuery;\nPDH_HCOUNTER cpuTotal;\n\nu8* trace_bits;                       /* SHM with instrumentation bitmap  */\n\nstatic u8  virgin_bits[MAP_SIZE],     /* Regions yet untouched by fuzzing */\n           virgin_tmout[MAP_SIZE],    /* Bits we haven't seen in tmouts   */\n           virgin_crash[MAP_SIZE];    /* Bits we haven't seen in crashes  */\n\nstatic u8  var_bytes[MAP_SIZE];       /* Bytes that appear to be variable */\n\nstatic HANDLE shm_handle;             /* Handle of the SHM region         */\n\nstatic HANDLE sample_shm_handle;         /* Handle of the use SHM region         */\nchar* sample_shm_str;\n\nstatic HANDLE pipe_handle;            /* Handle of the name pipe          */\nstatic OVERLAPPED pipe_overlapped;    /* Overlapped structure of pipe     */\n\nstatic char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized \n                                         seed allowing multiple instances */\nstatic HANDLE devnul_handle;          /* Handle of the nul device         */\nu8     sinkhole_stds = 1;             /* Sink-hole stdout/stderr messages?*/\nu8* shm_sample;\n\nstatic volatile u8 stop_soon,         /* Ctrl-C pressed?                  */\n                   clear_screen = 1,  /* Window resized?                  */\n                   child_timed_out;   /* Traced process timed out?        */\n\nstatic u32 queued_paths,              /* Total number of queued testcases */\n           queued_variable,           /* Testcases with variable behavior */\n           queued_at_start,           /* Total number of initial inputs   */\n           queued_discovered,         /* Items discovered during this run */\n           queued_imported,           /* Items imported via -S            */\n           queued_favored,            /* Paths deemed favorable           */\n           queued_with_cov,           /* Paths with new coverage bytes    */\n           pending_not_fuzzed,        /* Queued but not done yet          */\n           pending_favored,           /* Pending favored paths            */\n           cur_skipped_paths,         /* Abandoned inputs in cur cycle    */\n           cur_depth,                 /* Current path depth               */\n           max_depth,                 /* Max path depth                   */\n           useless_at_start,          /* Number of useless starting paths */\n           var_byte_count,            /* Bitmap bytes with var behavior   */\n           current_entry,             /* Current queue entry ID           */\n           havoc_div = 1;             /* Cycle count divisor for havoc    */\n\nstatic u64 total_crashes,             /* Total number of crashes          */\n           unique_crashes,            /* Crashes with unique signatures   */\n           total_tmouts,              /* Total number of timeouts         */\n           unique_tmouts,             /* Timeouts with unique signatures  */\n           unique_hangs,              /* Hangs with unique signatures     */\n           total_execs,               /* Total execve() calls             */\n           start_time,                /* Unix start time (ms)             */\n           prev_run_time,             /* Runtime read from prev stats file*/\n           last_path_time,            /* Time for most recent path (ms)   */\n           last_crash_time,           /* Time for most recent crash (ms)  */\n           last_hang_time,            /* Time for most recent hang (ms)   */\n           last_crash_execs,          /* Exec counter at last crash       */\n           queue_cycle,               /* Queue round counter              */\n           cycles_wo_finds,           /* Cycles without any new paths     */\n           trim_execs,                /* Execs done to trim input files   */\n           bytes_trim_in,             /* Bytes coming into the trimmer    */\n           bytes_trim_out,            /* Bytes coming outa the trimmer    */\n           blocks_eff_total,          /* Blocks subject to effector maps  */\n           blocks_eff_select;         /* Blocks selected as fuzzable      */\n\nstatic u32 subseq_tmouts;             /* Number of timeouts in a row      */\n\nstatic u8 *stage_name = \"init\",       /* Name of the current fuzz stage   */\n          *stage_short,               /* Short stage name                 */\n          *syncing_party;             /* Currently syncing with...        */\n\nstatic s32 stage_cur, stage_max;      /* Stage progression                */\nstatic s32 splicing_with = -1;        /* Splicing with which test case?   */\n\nstatic u32 master_id, master_max;     /* Master instance job splitting    */\n\nstatic u32 syncing_case;              /* Syncing with case #...           */\n\nstatic s32 stage_cur_byte,            /* Byte offset of current stage op  */\n           stage_cur_val;             /* Value used for stage op          */\n\nstatic u8  stage_val_type;            /* Value type (STAGE_VAL_*)         */\n\nstatic u64 stage_finds[32],           /* Patterns found per fuzz stage    */\n           stage_cycles[32];          /* Execs per fuzz stage             */\n\nstatic u32 rand_cnt;                  /* Random number counter            */\n\nstatic u64 total_cal_us,              /* Total calibration time (us)      */\n           total_cal_cycles;          /* Total calibration cycles         */\n\nstatic u64 total_bitmap_size,         /* Total bit count for all bitmaps  */\n           total_bitmap_entries;      /* Number of bitmaps counted        */\n\nstatic u32 cpu_core_count;            /* CPU core count                   */\n\nu64 cpu_aff = 0;       \t              /* Selected CPU core                */\n\nstatic FILE* plot_file;               /* Gnuplot output file              */\n\nstruct queue_entry {\n\n  u8* fname;                          /* File name for the test case      */\n  u32 len;                            /* Input length                     */\n\n  u8  cal_failed,                     /* Calibration failed?              */\n      trim_done,                      /* Trimmed?                         */\n      was_fuzzed,                     /* Had any fuzzing done yet?        */\n      passed_det,                     /* Deterministic stages passed?     */\n      has_new_cov,                    /* Triggers new coverage?           */\n      var_behavior,                   /* Variable behavior?               */\n      favored,                        /* Currently favored?               */\n      fs_redundant;                   /* Marked as redundant in the fs?   */\n\n  u32 bitmap_size,                    /* Number of bits set in bitmap     */\n      exec_cksum;                     /* Checksum of the execution trace  */\n\n  u64 exec_us,                        /* Execution time (us)              */\n      handicap,                       /* Number of queue cycles behind    */\n      depth;                          /* Path depth                       */\n\n  u8* trace_mini;                     /* Trace bytes, if kept             */\n  u32 tc_ref;                         /* Trace bytes ref count            */\n\n  struct queue_entry *next,           /* Next element, if any             */\n                     *next_100;       /* 100 elements ahead               */\n\n};\n\nstatic struct queue_entry *queue,     /* Fuzzing queue (linked list)      */\n                          *queue_cur, /* Current offset within the queue  */\n                          *queue_top, /* Top of the list                  */\n                          *q_prev100; /* Previous 100 marker              */\n\nstatic struct queue_entry*\n  top_rated[MAP_SIZE];                /* Top entries for bitmap bytes     */\n\nstruct extra_data {\n  u8* data;                           /* Dictionary token data            */\n  u32 len;                            /* Dictionary token length          */\n  u32 hit_cnt;                        /* Use count in the corpus          */\n};\n\nstatic struct extra_data* extras;     /* Extra tokens to fuzz with        */\nstatic u32 extras_cnt;                /* Total number of tokens read      */\n\nstatic struct extra_data* a_extras;   /* Automatically selected extras    */\nstatic u32 a_extras_cnt;              /* Total number of tokens available */\n\nstatic u8* (*post_handler)(u8* buf, u32* len);\n\n/* Interesting values, as per config.h */\n\nstatic s8  interesting_8[]  = { INTERESTING_8 };\nstatic s16 interesting_16[] = { INTERESTING_8, INTERESTING_16 };\nstatic s32 interesting_32[] = { INTERESTING_8, INTERESTING_16, INTERESTING_32 };\n\n/* Fuzzing stages */\n\nenum {\n  /* 00 */ STAGE_FLIP1,\n  /* 01 */ STAGE_FLIP2,\n  /* 02 */ STAGE_FLIP4,\n  /* 03 */ STAGE_FLIP8,\n  /* 04 */ STAGE_FLIP16,\n  /* 05 */ STAGE_FLIP32,\n  /* 06 */ STAGE_ARITH8,\n  /* 07 */ STAGE_ARITH16,\n  /* 08 */ STAGE_ARITH32,\n  /* 09 */ STAGE_INTEREST8,\n  /* 10 */ STAGE_INTEREST16,\n  /* 11 */ STAGE_INTEREST32,\n  /* 12 */ STAGE_EXTRAS_UO,\n  /* 13 */ STAGE_EXTRAS_UI,\n  /* 14 */ STAGE_EXTRAS_AO,\n  /* 15 */ STAGE_HAVOC,\n  /* 16 */ STAGE_SPLICE\n};\n\n/* Stage value types */\n\nenum {\n  /* 00 */ STAGE_VAL_NONE,\n  /* 01 */ STAGE_VAL_LE,\n  /* 02 */ STAGE_VAL_BE\n};\n\n/* Execution status fault codes */\n\nenum {\n  /* 00 */ FAULT_NONE,\n  /* 01 */ FAULT_TMOUT,\n  /* 02 */ FAULT_CRASH,\n  /* 03 */ FAULT_ERROR,\n  /* 04 */ FAULT_NOINST,\n  /* 05 */ FAULT_NOBITS\n};\n\n\n\n/* Get unix time in milliseconds */\n\nu64 get_cur_time(void) {\n\n  u64 ret;\n  FILETIME filetime;\n  GetSystemTimeAsFileTime(&filetime);\n\n  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;\n\n  return ret / 10000;\n\n}\n\n\n/* Get unix time in microseconds */\n\nstatic u64 get_cur_time_us(void) {\n\n  u64 ret;\n  FILETIME filetime;\n  GetSystemTimeAsFileTime(&filetime);\n\n  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;\n\n  return ret / 10;\n\n}\n\n\n/* Generate a random number (from 0 to limit - 1). This may\n   have slight bias. */\n\nstatic inline u32 UR(u32 limit) {\n\n  if (!rand_cnt--) {\n\n    u32 seed[2];\n\n    rand_s(&seed[0]);\n    rand_s(&seed[1]);\n\n    srand(seed[0]);\n    rand_cnt = (RESEED_RNG / 2) + (seed[1] % RESEED_RNG);\n\n  }\n\n  return rand() % limit;\n\n}\n\n\n/* Shuffle an array of pointers. Might be slightly biased. */\n\nstatic void shuffle_ptrs(void** ptrs, u32 cnt) {\n\n  u32 i;\n\n  for (i = 0; i < cnt - 2; i++) {\n\n    u32 j = i + UR(cnt - i);\n    void *s = ptrs[i];\n    ptrs[i] = ptrs[j];\n    ptrs[j] = s;\n\n  }\n\n}\n\n\nstatic u64 get_process_affinity(u32 process_id) {\n\n  /* if we can't get process affinity we treat it as if he doesn't have affinity */\n  u64 affinity = -1ULL;\n  DWORD_PTR process_affinity_mask = 0;\n  DWORD_PTR system_affinity_mask = 0;\n\n  HANDLE process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, process_id);\n  if (process == NULL) {\n    return affinity;\n  }\n\n  if (GetProcessAffinityMask(process, &process_affinity_mask, &system_affinity_mask)) {\n    affinity = (u64)process_affinity_mask;\n  }\n\n  CloseHandle(process);\n\n  return affinity;\n}\n\nstatic u32 count_mask_bits(u64 mask) {\n\n  u32 count = 0;\n\n  while (mask) {\n    if (mask & 1) {\n      count++;\n    }\n    mask >>= 1;\n  }\n\n  return count;\n}\n\nstatic u32 get_bit_idx(u64 mask) {\n\n  u32 i;\n\t\n  for (i = 0; i < 64; i++) {\n    if (mask & (1ULL << i)) {\n      return i;\n    }\n  }\n\n  return 0;\n}\n\nstatic void bind_to_free_cpu(void) {\n\n  u8 cpu_used[64];\n  u32 i = 0;\n  PROCESSENTRY32 process_entry;\n  HANDLE process_snap = INVALID_HANDLE_VALUE;\n\n  memset(cpu_used, 0, sizeof(cpu_used));\n\n  if (cpu_core_count < 2) return;\n\n  if (getenv(\"AFL_NO_AFFINITY\")) {\n\n    WARNF(\"Not binding to a CPU core (AFL_NO_AFFINITY set).\");\n    return;\n  }\n\n  /* Currently winafl doesn't support more than 64 cores */\n  if (cpu_core_count > 64) {\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n    \"Uh-oh, looks like you have %u CPU cores on your system\\n\"\n    \"    winafl doesn't support more than 64 cores at the moment\\n\"\n    \"    you can set AFL_NO_AFFINITY and try again.\\n\",\n    cpu_core_count);\n    FATAL(\"Too many cpus for automatic binding\");\n  }\n\n  if (!cpu_aff) {\n    ACTF(\"Checking CPU core loadout...\");\n\n    /* Introduce some jitter, in case multiple AFL tasks are doing the same\n    thing at the same time... */\n\n    srand(GetTickCount() + GetCurrentProcessId());\n    Sleep(R(1000) * 3);\n\n    process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (process_snap == INVALID_HANDLE_VALUE) {\n      FATAL(\"Failed to create snapshot\");\n    }\n\n    process_entry.dwSize = sizeof(PROCESSENTRY32);\n    if (!Process32First(process_snap, &process_entry)) {\n      CloseHandle(process_snap);\n      FATAL(\"Failed to enumerate processes\");\n    }\n\n    do {\n      unsigned long cpu_idx = 0;\n      u64 affinity = get_process_affinity(process_entry.th32ProcessID);\n\n      if ((affinity == 0) || (count_mask_bits(affinity) > 1)) continue;\n\n      cpu_idx = get_bit_idx(affinity);\n      cpu_used[cpu_idx] = 1;\n    } while (Process32Next(process_snap, &process_entry));\n\n    CloseHandle(process_snap);\n\n    /* If the user only uses subset of the core, prefer non-sequential cores\n       to avoid pinning two hyper threads of the same core */\n    for(i = 0; i < cpu_core_count; i += 2) if (!cpu_used[i]) break;\n\n    /* Fallback to the sequential scan */\n    if (i >= cpu_core_count) {\n      for(i = 0; i < cpu_core_count; i++) if (!cpu_used[i]) break;\n    }\n\n    if (i == cpu_core_count) {\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n      \"Uh-oh, looks like all %u CPU cores on your system are allocated to\\n\"\n      \"    other instances of afl-fuzz (or similar CPU-locked tasks). Starting\\n\"\n      \"    another fuzzer on this machine is probably a bad plan, but if you are\\n\"\n      \"    absolutely sure, you can set AFL_NO_AFFINITY and try again.\\n\",\n      cpu_core_count);\n\n      FATAL(\"No more free CPU cores\");\n\n    }\n\n    OKF(\"Found a free CPU core, binding to #%u.\", i);\n\n    cpu_aff = 1ULL << i;\n  }\n\n  if (!SetProcessAffinityMask(GetCurrentProcess(), (DWORD_PTR)cpu_aff)) {\n    FATAL(\"Failed to set process affinity\");\n  }\n\n  OKF(\"Process affinity is set to %I64x.\", cpu_aff);\n}\n\n\n#ifndef IGNORE_FINDS\n\n/* Helper function to compare buffers; returns first and last differing offset. We\n   use this to find reasonable locations for splicing two files. */\n\nstatic void locate_diffs(u8* ptr1, u8* ptr2, u32 len, s32* first, s32* last) {\n\n  s32 f_loc = -1;\n  s32 l_loc = -1;\n  u32 pos;\n\n  for (pos = 0; pos < len; pos++) {\n\n    if (*(ptr1++) != *(ptr2++)) {\n\n      if (f_loc == -1) f_loc = pos;\n      l_loc = pos;\n\n    }\n\n  }\n\n  *first = f_loc;\n  *last = l_loc;\n\n  return;\n\n}\n\n#endif /* !IGNORE_FINDS */\n\n\n/* Describe integer. Uses 12 cyclic static buffers for return values. The value\n   returned should be five characters or less for all the integers we reasonably\n   expect to see. */\n\nstatic u8* DI(u64 val) {\n\n  static u8 tmp[12][16];\n  static u8 cur;\n\n  cur = (cur + 1) % 12;\n\n#define CHK_FORMAT(_divisor, _limit_mult, _fmt, _cast) do { \\\n    if (val < (_divisor) * (_limit_mult)) { \\\n      sprintf(tmp[cur], _fmt, ((_cast)val) / (_divisor)); \\\n      return tmp[cur]; \\\n    } \\\n  } while (0)\n\n  /* 0-9999 */\n  CHK_FORMAT(1, 10000, \"%llu\", u64);\n\n  /* 10.0k - 99.9k */\n  CHK_FORMAT(1000, 99.95, \"%0.01fk\", double);\n\n  /* 100k - 999k */\n  CHK_FORMAT(1000, 1000, \"%lluk\", u64);\n\n  /* 1.00M - 9.99M */\n  CHK_FORMAT(1000 * 1000, 9.995, \"%0.02fM\", double);\n\n  /* 10.0M - 99.9M */\n  CHK_FORMAT(1000 * 1000, 99.95, \"%0.01fM\", double);\n\n  /* 100M - 999M */\n  CHK_FORMAT(1000 * 1000, 1000, \"%lluM\", u64);\n\n  /* 1.00G - 9.99G */\n  CHK_FORMAT(1000LL * 1000 * 1000, 9.995, \"%0.02fG\", double);\n\n  /* 10.0G - 99.9G */\n  CHK_FORMAT(1000LL * 1000 * 1000, 99.95, \"%0.01fG\", double);\n\n  /* 100G - 999G */\n  CHK_FORMAT(1000LL * 1000 * 1000, 1000, \"%lluG\", u64);\n\n  /* 1.00T - 9.99G */\n  CHK_FORMAT(1000LL * 1000 * 1000 * 1000, 9.995, \"%0.02fT\", double);\n\n  /* 10.0T - 99.9T */\n  CHK_FORMAT(1000LL * 1000 * 1000 * 1000, 99.95, \"%0.01fT\", double);\n\n  /* 100T+ */\n  strcpy(tmp[cur], \"infty\");\n  return tmp[cur];\n\n}\n\n\n/* Describe float. Similar to the above, except with a single \n   static buffer. */\n\nstatic u8* DF(double val) {\n\n  static u8 tmp[16];\n\n  if (val < 99.995) {\n    sprintf(tmp, \"%0.02f\", val);\n    return tmp;\n  }\n\n  if (val < 999.95) {\n    sprintf(tmp, \"%0.01f\", val);\n    return tmp;\n  }\n\n  return DI((u64)val);\n\n}\n\n\n/* Describe integer as memory size. */\n\nstatic u8* DMS(u64 val) {\n\n  static u8 tmp[12][16];\n  static u8 cur;\n\n  cur = (cur + 1) % 12;\n\n  /* 0-9999 */\n  CHK_FORMAT(1, 10000, \"%llu B\", u64);\n\n  /* 10.0k - 99.9k */\n  CHK_FORMAT(1024, 99.95, \"%0.01f kB\", double);\n\n  /* 100k - 999k */\n  CHK_FORMAT(1024, 1000, \"%llu kB\", u64);\n\n  /* 1.00M - 9.99M */\n  CHK_FORMAT(1024 * 1024, 9.995, \"%0.02f MB\", double);\n\n  /* 10.0M - 99.9M */\n  CHK_FORMAT(1024 * 1024, 99.95, \"%0.01f MB\", double);\n\n  /* 100M - 999M */\n  CHK_FORMAT(1024 * 1024, 1000, \"%llu MB\", u64);\n\n  /* 1.00G - 9.99G */\n  CHK_FORMAT(1024LL * 1024 * 1024, 9.995, \"%0.02f GB\", double);\n\n  /* 10.0G - 99.9G */\n  CHK_FORMAT(1024LL * 1024 * 1024, 99.95, \"%0.01f GB\", double);\n\n  /* 100G - 999G */\n  CHK_FORMAT(1024LL * 1024 * 1024, 1000, \"%llu GB\", u64);\n\n  /* 1.00T - 9.99G */\n  CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 9.995, \"%0.02f TB\", double);\n\n  /* 10.0T - 99.9T */\n  CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 99.95, \"%0.01f TB\", double);\n\n#undef CHK_FORMAT\n\n  /* 100T+ */\n  strcpy(tmp[cur], \"infty\");\n  return tmp[cur];\n\n}\n\n\n/* Describe time delta. Returns one static buffer, 34 chars of less. */\n\nstatic u8* DTD(u64 cur_ms, u64 event_ms) {\n\n  static u8 tmp[64];\n  u64 delta;\n  s32 t_d, t_h, t_m, t_s;\n\n  if (!event_ms) return \"none seen yet\";\n\n  delta = cur_ms - event_ms;\n\n  t_d = (s32)(delta / 1000 / 60 / 60 / 24);\n  t_h = (s32)((delta / 1000 / 60 / 60) % 24);\n  t_m = (s32)((delta / 1000 / 60) % 60);\n  t_s = (s32)((delta / 1000) % 60);\n\n  sprintf(tmp, \"%s days, %u hrs, %u min, %u sec\", DI(t_d), t_h, t_m, t_s);\n  return tmp;\n\n}\n\n\nchar *alloc_printf(const char *_str, ...) {\n\tva_list argptr;\n    char* _tmp;\n\ts32 _len;\n\n    va_start(argptr, _str);\n    _len = vsnprintf(NULL, 0, _str, argptr);\n    if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\");\n    _tmp = ck_alloc(_len + 1);\n    vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);\n    va_end(argptr);\n    return _tmp;\n  }\n\n\n/* Mark deterministic checks as done for a particular queue entry. We use the\n   .state file to avoid repeating deterministic fuzzing when resuming aborted\n   scans. */\n\nstatic void mark_as_det_done(struct queue_entry* q) {\n\n  u8* fn = strrchr(q->fname, '\\\\');\n  s32 fd;\n\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\deterministic_done\\\\%s\", out_dir, fn + 1);\n\n  fd = _open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n  _close(fd);\n\n  ck_free(fn);\n\n  q->passed_det = 1;\n\n}\n\n\n/* Mark as variable. Create symlinks if possible to make it easier to examine\n   the files. */\n\nstatic void mark_as_variable(struct queue_entry* q) {\n\n  u8 *fn = strrchr(q->fname, '\\\\') + 1, *ldest;\n\n  ldest = alloc_printf(\"..\\\\..\\\\%s\", fn);\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\variable_behavior\\\\%s\", out_dir, fn);\n\n  ck_free(ldest);\n  ck_free(fn);\n\n  q->var_behavior = 1;\n\n}\n\n\n/* Mark / unmark as redundant (edge-only). This is not used for restoring state,\n   but may be useful for post-processing datasets. */\n\nstatic void mark_as_redundant(struct queue_entry* q, u8 state) {\n\n  u8* fn;\n  s32 fd;\n\n  if (state == q->fs_redundant) return;\n\n  q->fs_redundant = state;\n\n  fn = strrchr(q->fname, '\\\\');\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\redundant_edges\\\\%s\", out_dir, fn + 1);\n\n  if (state) {\n\n    fd = _open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n    _close(fd);\n\n  } else {\n\n    if (_unlink(fn)) PFATAL(\"Unable to remove '%s'\", fn);\n\n  }\n\n  ck_free(fn);\n\n}\n\n\n/* Append new test case to the queue. */\n\nstatic void add_to_queue(u8* fname, u32 len, u8 passed_det) {\n\n  cycles_wo_finds = 0;\n\n  struct queue_entry* q = ck_alloc(sizeof(struct queue_entry));\n\n  q->fname        = fname;\n  q->len          = len;\n  q->depth        = (u64)cur_depth + 1;\n  q->passed_det   = passed_det;\n\n  if (q->depth > max_depth) max_depth = (u32)(q->depth);\n\n  if (queue_top) {\n\n    queue_top->next = q;\n    queue_top = q;\n\n  } else q_prev100 = queue = queue_top = q;\n\n  queued_paths++;\n  pending_not_fuzzed++;\n\n  /* Set next_100 pointer for every 100th element (index 0, 100, etc) to allow faster iteration. */\n  if ((queued_paths - 1) % 100 == 0 && queued_paths > 1) {\n\n    q_prev100->next_100 = q;\n    q_prev100 = q;\n\n  }\n\n  last_path_time = get_cur_time();\n\n}\n\n\n/* Destroy the entire queue. */\n\nstatic void destroy_queue(void) {\n\n  struct queue_entry *q = queue, *n;\n\n  while (q) {\n\n    n = q->next;\n    ck_free(q->fname);\n    ck_free(q->trace_mini);\n    ck_free((char *)q);\n    q = n;\n\n  }\n\n}\n\n\n/* Write bitmap to file. The bitmap is useful mostly for the secret\n   -B option, to focus a separate fuzzing session on a particular\n   interesting input without rediscovering all the others. */\n\nstatic void write_bitmap(void) {\n\n  u8* fname;\n  s32 fd;\n\n  if (!bitmap_changed) return;\n  bitmap_changed = 0;\n\n  fname = alloc_printf(\"%s\\\\fuzz_bitmap\", out_dir);\n  fd = _open(fname, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", fname);\n\n  ck_write(fd, virgin_bits, MAP_SIZE, fname);\n\n  _close(fd);\n  ck_free(fname);\n\n}\n\n\n/* Read bitmap from file. This is for the -B option again. */\n\nstatic void read_bitmap(u8* fname) {\n\n  s32 fd = _open(fname, O_RDONLY | O_BINARY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", fname);\n\n  ck_read(fd, virgin_bits, MAP_SIZE, fname);\n\n  _close(fd);\n\n}\n\n\n/* Check if the current execution path brings anything new to the table.\n   Update virgin bits to reflect the finds. Returns 1 if the only change is\n   the hit-count for a particular tuple; 2 if there are new tuples seen. \n   Updates the map, so subsequent calls will always return 0.\n\n   This function is called after every exec() on a fairly large buffer, so\n   it needs to be fast. We do this in 32-bit and 64-bit flavors. */\n\nstatic inline u8 has_new_bits(u8* virgin_map) {\n\n\n#ifdef _WIN64\n\n  u64* current = (u64*)trace_bits;\n  u64* virgin  = (u64*)virgin_map;\n\n  u32  i = (MAP_SIZE >> 3);\n\n#else\n\n  u32* current = (u32*)trace_bits;\n  u32* virgin  = (u32*)virgin_map;\n\n  u32  i = (MAP_SIZE >> 2);\n\n#endif /* ^_WIN64 */\n\n  u8   ret = 0;\n\n  while (i--) {\n\n    /* Optimize for (*current & *virgin) == 0 - i.e., no bits in current bitmap\n       that have not been already cleared from the virgin map - since this will\n       almost always be the case. */\n\n    if (*current && (*current & *virgin)) {\n\n      if (ret < 2) {\n\n        u8* cur = (u8*)current;\n        u8* vir = (u8*)virgin;\n\n        /* Looks like we have not found any new bytes yet; see if any non-zero\n           bytes in current[] are pristine in virgin[]. */\n\n#ifdef _WIN64\n\n        if ((cur[0] && vir[0] == 0xff) || (cur[1] && vir[1] == 0xff) ||\n            (cur[2] && vir[2] == 0xff) || (cur[3] && vir[3] == 0xff) ||\n            (cur[4] && vir[4] == 0xff) || (cur[5] && vir[5] == 0xff) ||\n            (cur[6] && vir[6] == 0xff) || (cur[7] && vir[7] == 0xff)) ret = 2;\n        else ret = 1;\n\n#else\n\n        if ((cur[0] && vir[0] == 0xff) || (cur[1] && vir[1] == 0xff) ||\n            (cur[2] && vir[2] == 0xff) || (cur[3] && vir[3] == 0xff)) ret = 2;\n        else ret = 1;\n\n#endif /* ^_WIN64 */\n\n      }\n\n      *virgin &= ~*current;\n\n    }\n\n    current++;\n    virgin++;\n\n  }\n\n  if (ret && virgin_map == virgin_bits) bitmap_changed = 1;\n\n  return ret;\n\n}\n\n\n/* Count the number of bits set in the provided bitmap. Used for the status\n   screen several times every second, does not have to be fast. */\n\nstatic u32 count_bits(u8* mem) {\n\n  u32* ptr = (u32*)mem;\n  u32  i   = (MAP_SIZE >> 2);\n  u32  ret = 0;\n\n  while (i--) {\n\n    u32 v = *(ptr++);\n\n    /* This gets called on the inverse, virgin bitmap; optimize for sparse\n       data. */\n\n    if (v == 0xffffffff) {\n      ret += 32;\n      continue;\n    }\n\n    v -= ((v >> 1) & 0x55555555);\n    v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n    ret += (((v + (v >> 4)) & 0xF0F0F0F) * 0x01010101) >> 24;\n\n  }\n\n  return ret;\n\n}\n\n#define FF(_b)  (0xff << ((_b) << 3))\n\n/* Count the number of bytes set in the bitmap. Called fairly sporadically,\n   mostly to update the status screen or calibrate and examine confirmed\n   new paths. */\n\nstatic u32 count_bytes(u8* mem) {\n\n  u32* ptr = (u32*)mem;\n  u32  i   = (MAP_SIZE >> 2);\n  u32  ret = 0;\n\n  while (i--) {\n\n    u32 v = *(ptr++);\n\n    if (!v) continue;\n    if (v & FF(0)) ret++;\n    if (v & FF(1)) ret++;\n    if (v & FF(2)) ret++;\n    if (v & FF(3)) ret++;\n\n  }\n\n  return ret;\n\n}\n\n\n/* Count the number of non-255 bytes set in the bitmap. Used strictly for the\n   status screen, several calls per second or so. */\n\nstatic u32 count_non_255_bytes(u8* mem) {\n\n  u32* ptr = (u32*)mem;\n  u32  i   = (MAP_SIZE >> 2);\n  u32  ret = 0;\n\n  while (i--) {\n\n    u32 v = *(ptr++);\n\n    /* This is called on the virgin bitmap, so optimize for the most likely\n       case. */\n\n    if (v == 0xffffffff) continue;\n    if ((v & FF(0)) != FF(0)) ret++;\n    if ((v & FF(1)) != FF(1)) ret++;\n    if ((v & FF(2)) != FF(2)) ret++;\n    if ((v & FF(3)) != FF(3)) ret++;\n\n  }\n\n  return ret;\n\n}\n\n\n/* Destructively simplify trace by eliminating hit count information\n   and replacing it with 0x80 or 0x01 depending on whether the tuple\n   is hit or not. Called on every new crash or timeout, should be\n   reasonably fast. */\n\n#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)\n#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)\n#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)\n#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)\n#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)\n#define AREP128(_sym) AREP64(_sym), AREP64(_sym)\n\nstatic const u8 simplify_lookup[256] = {\n\n  /*    4 */ 1, 128, 128, 128,\n  /*   +4 */ AREP4(128),\n  /*   +8 */ AREP8(128),\n  /*  +16 */ AREP16(128),\n  /*  +32 */ AREP32(128),\n  /*  +64 */ AREP64(128),\n  /* +128 */ AREP128(128)\n\n};\n\n#ifdef _WIN64\n\nstatic void simplify_trace(u64* mem) {\n\n  u32 i = MAP_SIZE >> 3;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (*mem) {\n\n      u8* mem8 = (u8*)mem;\n\n      mem8[0] = simplify_lookup[mem8[0]];\n      mem8[1] = simplify_lookup[mem8[1]];\n      mem8[2] = simplify_lookup[mem8[2]];\n      mem8[3] = simplify_lookup[mem8[3]];\n      mem8[4] = simplify_lookup[mem8[4]];\n      mem8[5] = simplify_lookup[mem8[5]];\n      mem8[6] = simplify_lookup[mem8[6]];\n      mem8[7] = simplify_lookup[mem8[7]];\n\n    } else *mem = 0x0101010101010101ULL;\n\n    mem++;\n\n  }\n\n}\n\n#else\n\nstatic void simplify_trace(u32* mem) {\n\n  u32 i = MAP_SIZE >> 2;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (*mem) {\n\n      u8* mem8 = (u8*)mem;\n\n      mem8[0] = simplify_lookup[mem8[0]];\n      mem8[1] = simplify_lookup[mem8[1]];\n      mem8[2] = simplify_lookup[mem8[2]];\n      mem8[3] = simplify_lookup[mem8[3]];\n\n    } else *mem = 0x01010101;\n\n    mem++;\n  }\n\n}\n\n#endif /* ^_WIN64 */\n\n\n/* Destructively classify execution counts in a trace. This is used as a\n   preprocessing step for any newly acquired traces. Called on every exec,\n   must be fast. */\n\nstatic const u8 count_class_lookup8[256] = {\n\n  /* 0 - 3:       4 */ 0, 1, 2, 4,\n  /* 4 - 7:      +4 */ AREP4(8),\n  /* 8 - 15:     +8 */ AREP8(16),\n  /* 16 - 31:   +16 */ AREP16(32),\n  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),\n  /* 128+:     +128 */ AREP128(128)\n\n};\n\nstatic u16 count_class_lookup16[65536];\n\n\nstatic void init_count_class16(void) {\n\n  u32 b1, b2;\n\n  for (b1 = 0; b1 < 256; b1++)\n    for (b2 = 0; b2 < 256; b2++)\n      count_class_lookup16[(b1 << 8) + b2] =\n        (count_class_lookup8[b1] << 8) |\n        count_class_lookup8[b2];\n\n}\n\n\n#ifdef _WIN64\n\nstatic inline void classify_counts(u64* mem) {\n\n  u32 i = MAP_SIZE >> 3;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (*mem) {\n\n      u16* mem16 = (u16*)mem;\n\n      mem16[0] = count_class_lookup16[mem16[0]];\n      mem16[1] = count_class_lookup16[mem16[1]];\n      mem16[2] = count_class_lookup16[mem16[2]];\n      mem16[3] = count_class_lookup16[mem16[3]];\n\n    }\n\n    mem++;\n\n  }\n\n}\n\n#else\n\nstatic inline void classify_counts(u32* mem) {\n\n  u32 i = MAP_SIZE >> 2;\n\n  while (i--) {\n\n    /* Optimize for sparse bitmaps. */\n\n    if (*mem) {\n\n      u16* mem16 = (u16*)mem;\n\n      mem16[0] = count_class_lookup16[mem16[0]];\n      mem16[1] = count_class_lookup16[mem16[1]];\n\n    }\n\n    mem++;\n\n  }\n\n}\n\n#endif /* ^_WIN64 */\n\n\n/* Get rid of shared memory (atexit handler). */\n\nstatic void remove_shm(void) {\n\n     UnmapViewOfFile(trace_bits);\n  \t CloseHandle(shm_handle);\n     \t\n\t if (use_sample_shared_memory) {\n\t   UnmapViewOfFile(shm_sample);\t\n\t   CloseHandle(sample_shm_handle);\n\t }\n\t\n}\n\n\n/* Compact trace bytes into a smaller bitmap. We effectively just drop the\n   count information here. This is called only sporadically, for some\n   new paths. */\n\nstatic void minimize_bits(u8* dst, u8* src) {\n\n  u32 i = 0;\n\n  while (i < MAP_SIZE) {\n\n    if (*(src++)) dst[i >> 3] |= 1 << (i & 7);\n    i++;\n\n  }\n\n}\n\n\n/* When we bump into a new path, we call this to see if the path appears\n   more \"favorable\" than any of the existing ones. The purpose of the\n   \"favorables\" is to have a minimal set of paths that trigger all the bits\n   seen in the bitmap so far, and focus on fuzzing them at the expense of\n   the rest.\n\n   The first step of the process is to maintain a list of top_rated[] entries\n   for every byte in the bitmap. We win that slot if there is no previous\n   contender, or if the contender has a more favorable speed x size factor. */\n\nstatic void update_bitmap_score(struct queue_entry* q) {\n\n  u32 i;\n  u64 fav_factor = q->exec_us * q->len;\n\n  /* For every byte set in trace_bits[], see if there is a previous winner,\n     and how it compares to us. */\n\n  for (i = 0; i < MAP_SIZE; i++)\n\n    if (trace_bits[i]) {\n\n       if (top_rated[i]) {\n\n         /* Faster-executing or smaller test cases are favored. */\n\n         if (fav_factor > top_rated[i]->exec_us * top_rated[i]->len) continue;\n\n         /* Looks like we're going to win. Decrease ref count for the\n            previous winner, discard its trace_bits[] if necessary. */\n\n         if (!--top_rated[i]->tc_ref) {\n           ck_free(top_rated[i]->trace_mini);\n           top_rated[i]->trace_mini = 0;\n         }\n\n       }\n\n       /* Insert ourselves as the new winner. */\n\n       top_rated[i] = q;\n       q->tc_ref++;\n\n       if (!q->trace_mini) {\n         q->trace_mini = ck_alloc(MAP_SIZE >> 3);\n         minimize_bits(q->trace_mini, trace_bits);\n       }\n\n       score_changed = 1;\n\n     }\n\n}\n\n\n/* The second part of the mechanism discussed above is a routine that\n   goes over top_rated[] entries, and then sequentially grabs winners for\n   previously-unseen bytes (temp_v) and marks them as favored, at least\n   until the next run. The favored entries are given more air time during\n   all fuzzing steps. */\n\nstatic void cull_queue(void) {\n\n  struct queue_entry* q;\n  static u8 temp_v[MAP_SIZE >> 3];\n  u32 i;\n\n  if (dumb_mode || !score_changed) return;\n\n  score_changed = 0;\n\n  memset(temp_v, 255, MAP_SIZE >> 3);\n\n  queued_favored  = 0;\n  pending_favored = 0;\n\n  q = queue;\n\n  while (q) {\n    q->favored = 0;\n    q = q->next;\n  }\n\n  /* Let's see if anything in the bitmap isn't captured in temp_v.\n     If yes, and if it has a top_rated[] contender, let's use it. */\n\n  for (i = 0; i < MAP_SIZE; i++)\n    if (top_rated[i] && (temp_v[i >> 3] & (1 << (i & 7)))) {\n\n      u32 j = MAP_SIZE >> 3;\n\n      /* Remove all bits belonging to the current entry from temp_v. */\n\n      while (j--) \n        if (top_rated[i]->trace_mini[j])\n          temp_v[j] &= ~top_rated[i]->trace_mini[j];\n\n      top_rated[i]->favored = 1;\n      queued_favored++;\n\n      if (!top_rated[i]->was_fuzzed) pending_favored++;\n\n    }\n\n  q = queue;\n\n  while (q) {\n    mark_as_redundant(q, !q->favored);\n    q = q->next;\n  }\n\n}\n\n\nstatic void setup_sample_shm() {\n\t unsigned int seeds[2];\n\t u64 name_seed;\n\n  SECURITY_DESCRIPTOR sd;\n  SECURITY_ATTRIBUTES sa;\n\n  // give everyone access, to allow attached processes to communicate\n  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);\n  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);\n\n  sa.nLength = sizeof(sa);\n  sa.lpSecurityDescriptor = &sd;\n  sa.bInheritHandle = FALSE;\n\n\t if (fuzzer_id == NULL) {\n\t   // If it is null, it means we have to generate a random seed to name the instance\n\t\t rand_s(&seeds[0]);\n\t\t rand_s(&seeds[1]);\n\t\t name_seed = ((u64)seeds[0] << 32) | seeds[1];\n\t\t fuzzer_id = (char*)alloc_printf(\"%I64x\", name_seed);\n\t }\n\t\n  sample_shm_str = (char*)alloc_printf(\"sample_afl_shm_%s\", fuzzer_id);\n\t//SAYF(\"sample_shm_str:\\r\\n\", sample_shm_str);\t\n\n\tsample_shm_handle = CreateFileMapping(\n\t\t\tINVALID_HANDLE_VALUE,    // use paging file\n\t\t\t&sa,                     // allow access to everyone\n\t\t\tPAGE_READWRITE,          // read/write access\n\t\t\t0,                       // maximum object size (high-order DWORD)\n\t\t\tMAX_SAMPLE_SIZE + sizeof(uint32_t),                // maximum object size (low-order DWORD)\n\t\t  sample_shm_str);        // name of mapping object\n\t\t\n\tif (sample_shm_handle == NULL) {\n\t\tFATAL(\"CreateFileMapping failed doe shm sample, %x\", GetLastError());\n\t}\n\n\tshm_sample = (u8*)MapViewOfFile(\n\t\t\tsample_shm_handle,          // handle to map object\n\t\t\tFILE_MAP_ALL_ACCESS, // read/write permission\n\t\t\t0,\n\t\t\t0,\n\t\t\tMAX_SAMPLE_SIZE + sizeof(uint32_t)\n\t\t);\n\t//ck_free(use_shm_str);\n\tif (!shm_sample) PFATAL(\"shmat() for sample failed\");\t\n\n}\n\n/* Configure shared memory and virgin_bits. This is called at startup. */\n\nstatic void setup_shm(void) {\n\n  char* shm_str;\n  unsigned int seeds[2];\n  u64 name_seed;\n  u8 attempts = 0;\n\n  SECURITY_DESCRIPTOR sd;\n  SECURITY_ATTRIBUTES sa;\n\n  // give everyone access, to allow attached processes to communicate\n  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);\n  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);\n\n  sa.nLength = sizeof(sa);\n  sa.lpSecurityDescriptor = &sd;\n  sa.bInheritHandle = FALSE;\n\n  while(attempts < 5) {\n    if(fuzzer_id == NULL) {\n      // If it is null, it means we have to generate a random seed to name the instance\n      rand_s(&seeds[0]);\n      rand_s(&seeds[1]);\n      name_seed = ((u64)seeds[0] << 32) | seeds[1];\n      fuzzer_id = (char *)alloc_printf(\"%I64x\", name_seed);\n    }\n\n    shm_str = (char *)alloc_printf(\"afl_shm_%s\", fuzzer_id);\n\n    shm_handle = CreateFileMapping(\n                   INVALID_HANDLE_VALUE,    // use paging file\n                   &sa,                     // allow access to everyone\n                   PAGE_READWRITE,          // read/write access\n                   0,                       // maximum object size (high-order DWORD)\n                   MAP_SIZE,                // maximum object size (low-order DWORD)\n                   (char *)shm_str);        // name of mapping object\n\n    if(shm_handle == NULL) {\n      if(sync_id) {\n        PFATAL(\"CreateFileMapping failed (check slave id)\");\n      }\n\n      if(GetLastError() == ERROR_ALREADY_EXISTS) {\n        // We need another attempt to find a unique section name\n        attempts++;\n        ck_free(shm_str);\n        ck_free(fuzzer_id);\n        fuzzer_id = NULL;\n        continue;\n      }\n      else {\n        PFATAL(\"CreateFileMapping failed\");\n      }\n    }\n\n    // We found a section name that works!\n    break;\n  }\n\n  if(attempts == 5) {\n    FATAL(\"Could not find a section name.\\n\");\n  }\n\n  atexit(remove_shm);\n\n  ck_free(shm_str);\n\n  trace_bits = (u8 *)MapViewOfFile(\n    shm_handle,          // handle to map object\n    FILE_MAP_ALL_ACCESS, // read/write permission\n    0,\n    0,\n    MAP_SIZE\n  );\n\n  if (!trace_bits) PFATAL(\"shmat() failed\");\n\n}\n\nchar* dlerror(){\n    static char msg[1024] = {0};\n    DWORD errCode = GetLastError();\n    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, errCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR) msg, sizeof(msg)/sizeof(msg[0]), NULL);\n    return msg;\n}\n/* Load postprocessor, if available. */\n\nstatic void setup_post(void) {\n    HMODULE dh;\n    u8* fn = getenv(\"AFL_POST_LIBRARY\");\n    u32 tlen = 6;\n\n    if (!fn) return;\n    ACTF(\"Loading postprocessor from '%s'...\", fn);\n    dh = LoadLibraryA(fn);\n    if (!dh) FATAL(\"%s\", dlerror());\n    post_handler = (u8* (*)(u8*,u32*))GetProcAddress(dh, \"afl_postprocess\");\n    if (!post_handler) FATAL(\"Symbol 'afl_postprocess' not found.\");\n\n    /* Do a quick test. It's better to segfault now than later =) */\n    post_handler(\"hello\", &tlen);\n    OKF(\"Postprocessor installed successfully.\");\n}\n\nint compare_filename(const void *a, const void *b) {\n\treturn strcmp(*((char **)a), *((char **)b));\n}\n\nint scandir_sorted(char *in_dir, char ***out) {\n\tunsigned int cnt=0, cnt2=0;\n\tWIN32_FIND_DATA fd;\n    HANDLE h;\n\tchar *pattern;\n\n\tif(in_dir[strlen(in_dir)-1] == '\\\\') {\n\t\tpattern = alloc_printf(\"%s*\", in_dir);\n\t} else {\n\t\tpattern = alloc_printf(\"%s\\\\*\", in_dir);\n\t}\n\n\th = FindFirstFile(pattern, &fd);\n\tif(h == INVALID_HANDLE_VALUE) return -1;\n\n    do {\n\t\tif(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) continue;\n\t\tif(strcmp(fd.cFileName, \"README.txt\") == 0) continue;\n\n\t\tcnt++;\n    } while(FindNextFile(h, &fd));\n\n\tFindClose(h);\n\n\t*out = (char **)malloc(cnt*sizeof(char *));\n\n\th = FindFirstFile(pattern, &fd);\n\tif(h == INVALID_HANDLE_VALUE) return -1;\n\n    do {\n\t\tif(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) continue;\n\t\tif(strcmp(fd.cFileName, \"README.txt\") == 0) continue;\n\n\t\tcnt2++;\n\t\tif(cnt2>cnt) break;\n\n\t\t(*out)[cnt2-1] = (char *)malloc(strlen(fd.cFileName)+1);\n\t\tstrcpy((*out)[cnt2-1], fd.cFileName);\n    } while(FindNextFile(h, &fd));\n\n\tFindClose(h);\n\n\tif(cnt2 != cnt) return -1;\n\n\tqsort(*out, cnt, sizeof(char *), compare_filename);\n\n\tck_free(pattern);\n\n\treturn cnt;\n}\n\n\n__int64 FileSize(char *name) {\n    WIN32_FILE_ATTRIBUTE_DATA fad;\n    if (!GetFileAttributesEx(name, GetFileExInfoStandard, &fad))\n        return -1; // error condition, could call GetLastError to find out more\n\treturn (((__int64)fad.nFileSizeHigh) << 32) + fad.nFileSizeLow;\n}\n\n\n/* Read all testcases from the input directory, then queue them for testing.\n   Called at startup. */\n\n\nstatic void read_testcases(void) {\n\n  char **nl;\n  s32 nl_cnt;\n  s32 i;\n  u8* fn;\n\n  /* Auto-detect non-in-place resumption attempts. */\n\n  fn = alloc_printf(\"%s\\\\queue\", in_dir);\n  if (!_access(fn, 0)) in_dir = fn; else ck_free(fn);\n\n  ACTF(\"Scanning '%s'...\", in_dir);\n\n  /* We use scandir() + alphasort() rather than readdir() because otherwise,\n     the ordering  of test cases would vary somewhat randomly and would be\n     difficult to control. */\n\n  nl_cnt = scandir_sorted((char *)in_dir, &nl);\n\n  if (nl_cnt < 0) {\n\n    if (errno == ENOENT || errno == ENOTDIR)\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"The input directory does not seem to be valid - try again. The fuzzer needs\\n\"\n           \"    one or more test case to start with - ideally, a small file under 1 kB\\n\"\n           \"    or so. The cases must be stored as regular files directly in the input\\n\"\n           \"    directory.\\n\");\n\n    PFATAL(\"Unable to open '%s'\", in_dir);\n\n  }\n\n  if (shuffle_queue && nl_cnt > 1) {\n\n    ACTF(\"Shuffling queue...\");\n    shuffle_ptrs((void**)nl, nl_cnt);\n\n  }\n\n  for (i = 0; i < nl_cnt; i++) {\n\n    __int64 st_size;\n\n    u8* fn = alloc_printf(\"%s\\\\%s\", in_dir, nl[i]);\n    u8* dfn = alloc_printf(\"%s\\\\.state\\\\deterministic_done\\\\%s\", in_dir, nl[i]);\n\n    u8  passed_det = 0;\n\n    free(nl[i]); /* not tracked */\n \n\tst_size = FileSize(fn);\n\n    if (_access(fn, 0) || (st_size < 0))\n      PFATAL(\"Unable to access '%s'\", fn);\n\n    if (st_size == 0) {\n      ck_free(fn);\n      ck_free(dfn);\n      continue;\n    }\n\n    if (st_size > MAX_FILE) \n      FATAL(\"Test case '%s' is too big (%s, limit is %s)\", fn,\n            DMS(st_size), DMS(MAX_FILE));\n\n    /* Check for metadata that indicates that deterministic fuzzing\n       is complete for this entry. We don't want to repeat deterministic\n       fuzzing when resuming aborted scans, because it would be pointless\n       and probably very time-consuming. */\n\n    if (!_access(dfn, 0)) passed_det = 1;\n    ck_free(dfn);\n\n    add_to_queue(fn, st_size, passed_det);\n\n  }\n\n  free(nl); /* not tracked */\n\n  if (!queued_paths) {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Looks like there are no valid test cases in the input directory! The fuzzer\\n\"\n         \"    needs one or more test case to start with - ideally, a small file under\\n\"\n         \"    1 kB or so. The cases must be stored as regular files directly in the\\n\"\n         \"    input directory.\\n\");\n\n    FATAL(\"No usable test cases in '%s'\", in_dir);\n\n  }\n\n  last_path_time = 0;\n  queued_at_start = queued_paths;\n\n}\n\n\n/* Helper function for load_extras. */\n\nstatic int compare_extras_len(const void* p1, const void* p2) {\n  struct extra_data *e1 = (struct extra_data*)p1,\n                    *e2 = (struct extra_data*)p2;\n\n  return e1->len - e2->len;\n}\n\nstatic int compare_extras_use_d(const void* p1, const void* p2) {\n  struct extra_data *e1 = (struct extra_data*)p1,\n                    *e2 = (struct extra_data*)p2;\n\n  return e2->hit_cnt - e1->hit_cnt;\n}\n\n\n/* Read extras from a file, sort by size. */\n\nstatic void load_extras_file(u8* fname, u32* min_len, u32* max_len,\n                             u32 dict_level) {\n\n  FILE* f;\n  u8  buf[MAX_LINE];\n  u8  *lptr;\n  u32 cur_line = 0;\n\n  f = fopen(fname, \"r\");\n\n  if (!f) PFATAL(\"Unable to open '%s'\", fname);\n\n  while ((lptr = fgets(buf, MAX_LINE, f))) {\n\n    u8 *rptr, *wptr;\n    u32 klen = 0;\n\n    cur_line++;\n\n    /* Trim on left and right. */\n\n    while (isspace(*lptr)) lptr++;\n\n    rptr = lptr + strlen(lptr) - 1;\n    while (rptr >= lptr && isspace(*rptr)) rptr--;\n    rptr++;\n    *rptr = 0;\n\n    /* Skip empty lines and comments. */\n\n    if (!*lptr || *lptr == '#') continue;\n\n    /* All other lines must end with '\"', which we can consume. */\n\n    rptr--;\n\n    if (rptr < lptr || *rptr != '\"')\n      FATAL(\"Malformed name=\\\"value\\\" pair in line %u.\", cur_line);\n\n    *rptr = 0;\n\n    /* Skip alphanumerics and dashes (label). */\n\n    while (isalnum(*lptr) || *lptr == '_') lptr++;\n\n    /* If @number follows, parse that. */\n\n    if (*lptr == '@') {\n\n      lptr++;\n      if ((unsigned)atoi(lptr) > dict_level) continue;\n      while (isdigit(*lptr)) lptr++;\n\n    }\n\n    /* Skip whitespace and = signs. */\n\n    while (isspace(*lptr) || *lptr == '=') lptr++;\n\n    /* Consume opening '\"'. */\n\n    if (*lptr != '\"')\n      FATAL(\"Malformed name=\\\"keyword\\\" pair in line %u.\", cur_line);\n\n    lptr++;\n\n    if (!*lptr) FATAL(\"Empty keyword in line %u.\", cur_line);\n\n    /* Okay, let's allocate memory and copy data between \"...\", handling\n       \\xNN escaping, \\\\, and \\\". */\n\n    extras = ck_realloc_block(extras, (extras_cnt + 1) *\n               sizeof(struct extra_data));\n\n    wptr = extras[extras_cnt].data = ck_alloc(rptr - lptr);\n\n    while (*lptr) {\n\n      char* hexdigits = \"0123456789abcdef\";\n\n\t  if(((*lptr)<32)||((*lptr)>127)) {\n          FATAL(\"Non-printable characters in line %u.\", cur_line);\n\t  }\n\n      switch (*lptr) {\n        case '\\\\':\n\n          lptr++;\n\n          if (*lptr == '\\\\' || *lptr == '\"') {\n            *(wptr++) = *(lptr++);\n            klen++;\n            break;\n          }\n\n          if (*lptr != 'x' || !isxdigit(lptr[1]) || !isxdigit(lptr[2]))\n            FATAL(\"Invalid escaping (not \\\\xNN) in line %u.\", cur_line);\n\n          *(wptr++) =\n            ((strchr(hexdigits, tolower(lptr[1])) - hexdigits) << 4) |\n            (strchr(hexdigits, tolower(lptr[2])) - hexdigits);\n\n          lptr += 3;\n          klen++;\n\n          break;\n\n        default:\n\n          *(wptr++) = *(lptr++);\n          klen++;\n\n      }\n\n    }\n\n    extras[extras_cnt].len = klen;\n\n    if (extras[extras_cnt].len > MAX_DICT_FILE)\n      FATAL(\"Keyword too big in line %u (%s, limit is %s)\", cur_line,\n            DMS(klen), DMS(MAX_DICT_FILE));\n\n    if (*min_len > klen) *min_len = klen;\n    if (*max_len < klen) *max_len = klen;\n\n    extras_cnt++;\n\n  }\n\n  fclose(f);\n\n}\n\n\n/* Read extras from the extras directory and sort them by size. */\n\nstatic void load_extras(u8* dir) {\n\n  WIN32_FIND_DATA fdata;\n  HANDLE h;\n  u32 min_len = MAX_DICT_FILE, max_len = 0, dict_level = 0;\n  u8* x;\n  char *pattern;\n\n  /* If the name ends with @, extract level and continue. */\n\n  if ((x = strchr(dir, '@'))) {\n\n    *x = 0;\n    dict_level = atoi(x + 1);\n\n  }\n\n  ACTF(\"Loading extra dictionary from '%s' (level %u)...\", dir, dict_level);\n\n  if(dir[strlen(dir)-1] == '\\\\') {\n    pattern = alloc_printf(\"%s*\", dir);\n  } else {\n    pattern = alloc_printf(\"%s\\\\*\", dir);\n  }\n\n  h = FindFirstFile(pattern, &fdata);\n\n  if (h == INVALID_HANDLE_VALUE) {\n    load_extras_file(dir, &min_len, &max_len, dict_level);\n    goto check_and_sort;\n  }\n\n  if (x) FATAL(\"Dictionary levels not supported for directories.\");\n\n  do {\n\tu8* fn = alloc_printf(\"%s\\\\%s\", dir, fdata.cFileName);\n    s32 fd;\n\n\tif(fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {\n      ck_free(fn);\n      continue;\n\t}\n\n    if (_access(fn, 0))\n      PFATAL(\"Unable to access '%s'\", fn);\n\n\tif ((fdata.nFileSizeHigh > 0) || (fdata.nFileSizeLow > MAX_DICT_FILE))\n      FATAL(\"Extra '%s' is too big (%s, limit is %s)\", fn,\n            DMS(fdata.nFileSizeLow), DMS(MAX_DICT_FILE));\n\n    if (min_len > fdata.nFileSizeLow) min_len = fdata.nFileSizeLow;\n    if (max_len < fdata.nFileSizeLow) max_len = fdata.nFileSizeLow;\n\n    extras = ck_realloc_block(extras, (extras_cnt + 1) *\n               sizeof(struct extra_data));\n\n    extras[extras_cnt].data = ck_alloc(fdata.nFileSizeLow);\n    extras[extras_cnt].len  = fdata.nFileSizeLow;\n\n    fd = _open(fn, O_RDONLY | O_BINARY);\n\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", fn);\n\n    ck_read(fd, extras[extras_cnt].data, fdata.nFileSizeLow, fn);\n\n    _close(fd);\n    ck_free(fn);\n\n    extras_cnt++;\n\n  } while(FindNextFile(h, &fdata));\n\n  ck_free(pattern);\n  FindClose(h);\n\ncheck_and_sort:\n\n  if (!extras_cnt) FATAL(\"No usable files in '%s'\", dir);\n\n  qsort(extras, extras_cnt, sizeof(struct extra_data), compare_extras_len);\n\n  OKF(\"Loaded %u extra tokens, size range %s to %s.\", extras_cnt,\n      DMS(min_len), DMS(max_len));\n\n  if (max_len > 32)\n    WARNF(\"Some tokens are relatively large (%s) - consider trimming.\",\n          DMS(max_len));\n\n  if (extras_cnt > MAX_DET_EXTRAS)\n    WARNF(\"More than %u tokens - will use them probabilistically.\",\n          MAX_DET_EXTRAS);\n\n}\n\n\n\n\n/* Helper function for maybe_add_auto() */\n\nstatic inline u8 memcmp_nocase(u8* m1, u8* m2, u32 len) {\n\n  while (len--) if (tolower(*(m1++)) ^ tolower(*(m2++))) return 1;\n  return 0;\n\n}\n\n\n/* Maybe add automatic extra. */\n\nstatic void maybe_add_auto(u8* mem, u32 len) {\n\n  u32 i;\n\n  /* Allow users to specify that they don't want auto dictionaries. */\n\n  if (!MAX_AUTO_EXTRAS || !USE_AUTO_EXTRAS) return;\n\n  /* Skip runs of identical bytes. */\n\n  for (i = 1; i < len; i++)\n    if (mem[0] ^ mem[i]) break;\n\n  if (i == len) return;\n\n  /* Reject builtin interesting values. */\n\n  if (len == 2) {\n\n    i = sizeof(interesting_16) >> 1;\n\n    while (i--) \n      if (*((u16*)mem) == interesting_16[i] ||\n          *((u16*)mem) == SWAP16(interesting_16[i])) return;\n\n  }\n\n  if (len == 4) {\n\n    i = sizeof(interesting_32) >> 2;\n\n    while (i--) \n      if (*((u32*)mem) == interesting_32[i] ||\n          *((u32*)mem) == SWAP32(interesting_32[i])) return;\n\n  }\n\n  /* Reject anything that matches existing extras. Do a case-insensitive\n     match. We optimize by exploiting the fact that extras[] are sorted\n     by size. */\n\n  for (i = 0; i < extras_cnt; i++)\n    if (extras[i].len >= len) break;\n\n  for (; i < extras_cnt && extras[i].len == len; i++)\n    if (!memcmp_nocase(extras[i].data, mem, len)) return;\n\n  /* Last but not least, check a_extras[] for matches. There are no\n     guarantees of a particular sort order. */\n\n  auto_changed = 1;\n\n  for (i = 0; i < a_extras_cnt; i++) {\n\n    if (a_extras[i].len == len && !memcmp_nocase(a_extras[i].data, mem, len)) {\n\n      a_extras[i].hit_cnt++;\n      goto sort_a_extras;\n\n    }\n\n  }\n\n  /* At this point, looks like we're dealing with a new entry. So, let's\n     append it if we have room. Otherwise, let's randomly evict some other\n     entry from the bottom half of the list. */\n\n  if (a_extras_cnt < MAX_AUTO_EXTRAS) {\n\n    a_extras = ck_realloc_block(a_extras, (a_extras_cnt + 1) *\n                                sizeof(struct extra_data));\n\n    a_extras[a_extras_cnt].data = ck_memdup(mem, len);\n    a_extras[a_extras_cnt].len  = len;\n    a_extras_cnt++;\n\n  } else {\n\n    i = MAX_AUTO_EXTRAS / 2 +\n        UR((MAX_AUTO_EXTRAS + 1) / 2);\n\n    ck_free(a_extras[i].data);\n\n    a_extras[i].data    = ck_memdup(mem, len);\n    a_extras[i].len     = len;\n    a_extras[i].hit_cnt = 0;\n\n  }\n\nsort_a_extras:\n\n  /* First, sort all auto extras by use count, descending order. */\n\n  qsort(a_extras, a_extras_cnt, sizeof(struct extra_data),\n        compare_extras_use_d);\n\n  /* Then, sort the top USE_AUTO_EXTRAS entries by size. */\n\n  qsort(a_extras, MIN(USE_AUTO_EXTRAS, a_extras_cnt),\n        sizeof(struct extra_data), compare_extras_len);\n\n}\n\n\n/* Save automatically generated extras. */\n\nstatic void save_auto(void) {\n\n  u32 i;\n\n  if (!auto_changed) return;\n  auto_changed = 0;\n\n  for (i = 0; i < MIN(USE_AUTO_EXTRAS, a_extras_cnt); i++) {\n\n    u8* fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\auto_extras\\\\auto_%06u\", out_dir, i);\n    s32 fd;\n\n    fd = _open(fn, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n\n    ck_write(fd, a_extras[i].data, a_extras[i].len, fn);\n\n    _close(fd);\n    ck_free(fn);\n\n  }\n\n}\n\n\n/* Load automatically generated extras. */\n\nstatic void load_auto(void) {\n\n  u32 i;\n\n  for (i = 0; i < USE_AUTO_EXTRAS; i++) {\n\n    u8  tmp[MAX_AUTO_EXTRA + 1];\n    u8* fn = alloc_printf(\"%s\\\\.state\\\\auto_extras\\\\auto_%06u\", in_dir, i);\n    s32 fd, len;\n\n    fd = _open(fn, O_RDONLY | O_BINARY, DEFAULT_PERMISSION);\n\n    if (fd < 0) {\n\n      if (errno != ENOENT) PFATAL(\"Unable to open '%s'\", fn);\n      ck_free(fn);\n      break;\n\n    }\n\n    /* We read one byte more to cheaply detect tokens that are too\n       long (and skip them). */\n\n    len = _read(fd, tmp, MAX_AUTO_EXTRA + 1);\n\n    if (len < 0) PFATAL(\"Unable to read from '%s'\", fn);\n\n    if (len >= MIN_AUTO_EXTRA && len <= MAX_AUTO_EXTRA)\n      maybe_add_auto(tmp, len);\n\n    _close(fd);\n    ck_free(fn);\n\n  }\n\n  if (i) OKF(\"Loaded %u auto-discovered dictionary tokens.\", i);\n  else OKF(\"No auto-generated dictionary tokens to reuse.\");\n\n}\n\n\n/* Destroy extras. */\n\nstatic void destroy_extras(void) {\n\n  u32 i;\n\n  for (i = 0; i < extras_cnt; i++) \n    ck_free(extras[i].data);\n\n  ck_free((char *)extras);\n\n  for (i = 0; i < a_extras_cnt; i++) \n    ck_free(a_extras[i].data);\n\n  ck_free((char *)a_extras);\n\n}\n\n\n/* Spin up fork server (instrumented mode only). The idea is explained here:\n\n   http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html\n\n   In essence, the instrumentation allows us to skip execve(), and just keep\n   cloning a stopped child. So, we just execute once, and then send commands\n   through a pipe. The other part of this logic is in afl-as.h. */\n\nstatic void init_forkserver(char** argv) {\n  //not implemented on Windows\n}\n\n//quoting on Windows is weird\nsize_t ArgvQuote(char *in, char *out) {\n\tint needs_quoting = 0;\n\tsize_t size = 0;\n\tchar *p = in;\n\tsize_t i;\n\n\t//check if quoting is necessary\n\tif(strchr(in, ' ')) needs_quoting = 1;\n\tif(strchr(in, '\\\"')) needs_quoting = 1;\n\tif(strchr(in, '\\t')) needs_quoting = 1;\n\tif(strchr(in, '\\n')) needs_quoting = 1;\n\tif(strchr(in, '\\v')) needs_quoting = 1;\n\tif(!needs_quoting) {\n\t\tsize = strlen(in);\n\t\tif(out) memcpy(out, in, size);\n\t\treturn size;\n\t}\n\n\tif(out) out[size] = '\\\"';\n\tsize++;\n\n\twhile(*p) {\n\t\tsize_t num_backslashes = 0;\n\t\twhile((*p) && (*p == '\\\\')) {\n\t\t\tp++;\n\t\t\tnum_backslashes++;\n\t\t}\n\n\t\tif(*p == 0) {\n\t\t\tfor(i = 0; i < (num_backslashes*2); i++) {\n\t\t\t\tif(out) out[size] = '\\\\';\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tbreak;\n\t\t} else if(*p == '\\\"') {\n\t\t\tfor(i = 0; i < (num_backslashes*2 + 1); i++) {\n\t\t\t\tif(out) out[size] = '\\\\';\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tif(out) out[size] = *p;\n\t\t\tsize++;\n\t\t} else {\n\t\t\tfor(i = 0; i < num_backslashes; i++) {\n\t\t\t\tif(out) out[size] = '\\\\';\n\t\t\t\tsize++;\n\t\t\t}\n\t\t\tif(out) out[size] = *p;\n\t\t\tsize++;\n\t\t}\n\n\t\tp++;\n\t}\n\n\tif(out) out[size] = '\\\"';\n\tsize++;\n\n\treturn size;\n}\n\nchar *argv_to_cmd(char** argv) {\n  u32 len = 0, i;\n  u8* buf, *ret;\n\n  //todo shell-escape\n\n  for (i = 0; argv[i]; i++)\n    len += ArgvQuote(argv[i], NULL) + 1;\n  \n  if(!len) FATAL(\"Error creating command line\");\n\n  buf = ret = ck_alloc(len);\n\n  for (i = 0; argv[i]; i++) {\n\n    u32 l = ArgvQuote(argv[i], buf);\n\n\tbuf += l;\n\n\t*(buf++) = ' ';\n  }\n\n  ret[len-1] = 0;\n\n  return ret;\n}\n\n/*Initialazing overlapped structure and connecting*/\nstatic BOOL OverlappedConnectNamedPipe(HANDLE pipe_h, LPOVERLAPPED overlapped)\n{\n\tZeroMemory(overlapped, sizeof(*overlapped));\n\t\n\toverlapped->hEvent = CreateEvent(\n\t\tNULL,    // default security attribute \n\t\tTRUE,    // manual-reset event \n\t\tTRUE,    // initial state = signaled \n\t\tNULL);   // unnamed event object \n\n\tif (overlapped->hEvent == NULL)\n\t{\n\t\treturn FALSE;\n\t}\n\n\tif (ConnectNamedPipe(pipe_h, overlapped))\n\t{\n\t\treturn FALSE;\n\t}\n\tswitch (GetLastError())\n\t{\n\t\t// The overlapped connection in progress. \n\tcase ERROR_IO_PENDING:\n\t\tWaitForSingleObject(overlapped->hEvent, INFINITE);\n\t\treturn TRUE;\n\t\t// Client is already connected\n\tcase ERROR_PIPE_CONNECTED:\n\t\treturn TRUE;\n\tdefault:\n\t{\n\t\treturn FALSE;\n\t}\n\t}\n}\n\nstatic BOOL module_loaded_to_pid(u32 pid, char * module_name)\n{\n  BOOL found = FALSE;\n  MODULEENTRY32 module_entry;\n  HANDLE module_snap = INVALID_HANDLE_VALUE;\n  char current_module[MAX_PATH];\n  size_t chars_converted;\n\n  module_snap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid);\n  if (module_snap == INVALID_HANDLE_VALUE) {\n    return FALSE;\n  }\n\n  module_entry.dwSize = sizeof(MODULEENTRY32);\n\n  if (!Module32First(module_snap, &module_entry)) {\n    CloseHandle(module_snap);\n    return FALSE;\n  }\n\n  do {\n    if (strcmp(module_entry.szModule, module_name) == 0) {\n      found = TRUE;\n    }\n  } while(!found && Module32Next(module_snap, &module_entry));\n\n  CloseHandle(module_snap);\n  return found;\n}\n\nstatic u32 find_attach_pid(char * module_name)\n{\n  u32 attach_pid = 0;\n  u8 found = FALSE;\n  u32 attempt = 0;\n\n  PROCESSENTRY32 process_entry;\n  HANDLE process_snap = INVALID_HANDLE_VALUE;\n\n  do {\n    process_snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (process_snap == INVALID_HANDLE_VALUE) {\n      FATAL(\"Failed to create snapshot\");\n    }\n\n    process_entry.dwSize = sizeof(PROCESSENTRY32);\n    if (!Process32First(process_snap, &process_entry)) {\n      CloseHandle(process_snap);\n      FATAL(\"Failed to enumerate processes\");\n    }\n\n    do {\n      if (module_loaded_to_pid(process_entry.th32ProcessID, module_name)) {\n        if (found) {\n          FATAL(\"Attach module loaded to more than one process\");\n        }\n        found = TRUE;\n        attach_pid = process_entry.th32ProcessID;\n      }\n    } while (Process32Next(process_snap, &process_entry));\n\n    CloseHandle(process_snap);\n\n    Sleep(1000);\n  } while (!found && (++attempt < MAX_ATTACH_ATTEMPTS));\n\n  return attach_pid;\n}\n\nstatic void create_target_process(char** argv) {\n  char *cmd;\n  char *pipe_name;\n  char *buf;\n  char *pidfile;\n  char *client_invocation;\n  FILE *fp;\n  size_t pidsize;\n  BOOL inherit_handles = TRUE;\n\n  HANDLE hJob = NULL;\n  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n\n  SECURITY_DESCRIPTOR sd;\n  SECURITY_ATTRIBUTES sa;\n\n  // give everyone access, to allow attached processes to communicate\n  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);\n  SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);\n\n  sa.nLength = sizeof(sa);\n  sa.lpSecurityDescriptor = &sd;\n  sa.bInheritHandle = FALSE;\n\n  pipe_name = (char *)alloc_printf(\"\\\\\\\\.\\\\pipe\\\\afl_pipe_%s\", fuzzer_id);\n\n  pipe_handle = CreateNamedPipe(\n    pipe_name,                // pipe name\n    PIPE_ACCESS_DUPLEX |      // read/write access \n    FILE_FLAG_OVERLAPPED,     // overlapped mode \n    0,\n    1,                        // max. instances\n    512,                      // output buffer size\n    512,                      // input buffer size\n    20000,                    // client time-out\n    &sa);                     // allow access to everyone\n\n  if (pipe_handle == INVALID_HANDLE_VALUE) {\n    FATAL(\"CreateNamedPipe failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  target_cmd = argv_to_cmd(argv);\n\n  ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof(si);\n  ZeroMemory(&pi, sizeof(pi));\n\n  if(sinkhole_stds) {\n    si.hStdOutput = si.hStdError = devnul_handle;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n  } else {\n    inherit_handles = FALSE;\n  }\n\n  if (expert_mode) {\n    client_invocation = alloc_printf(\"-t winafl\");\n  } else {\n    client_invocation = alloc_printf(\"-c %s\", winafl_dll_path);\n  }\n\n  if(drioless) {\n    char *static_config = alloc_printf(\"%s:%d\", fuzzer_id, fuzz_iterations_max);\n\n    if (static_config == NULL) {\n      FATAL(\"Cannot allocate static_config.\");\n    }\n\n    SetEnvironmentVariable(\"AFL_STATIC_CONFIG\", static_config);\n    cmd = alloc_printf(\"%s\", target_cmd);\n    ck_free(static_config);\n  }\n  else {\n    if (drattach) {\n      drattachpid = find_attach_pid(drattach_identifier);\n      cmd = alloc_printf(\n        \"%s\\\\drrun.exe -attach %ld -no_follow_children %s %s -fuzzer_id %s\",\n        dynamorio_dir, drattachpid, client_invocation, client_params, fuzzer_id);\n    } else {\n      pidfile = alloc_printf(\"childpid_%s.txt\", fuzzer_id);\n      if (persist_dr_cache) {\n        cmd = alloc_printf(\n          \"%s\\\\drrun.exe -pidfile %s -no_follow_children -persist -persist_dir \\\"%s\\\\drcache\\\" %s %s -fuzzer_id %s -drpersist -- %s\",\n          dynamorio_dir, pidfile, out_dir, client_invocation, client_params, fuzzer_id, target_cmd);\n      } else {\n        cmd = alloc_printf(\n          \"%s\\\\drrun.exe -pidfile %s -no_follow_children %s %s -fuzzer_id %s -- %s\",\n          dynamorio_dir, pidfile, client_invocation, client_params, fuzzer_id, target_cmd);\n      }\n    }\n  }\n  if(mem_limit || cpu_aff) {\n    hJob = CreateJobObject(NULL, NULL);\n    if(hJob == NULL) {\n      FATAL(\"CreateJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    ZeroMemory(&job_limit, sizeof(job_limit));\n    if (mem_limit) {\n      job_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;\n      job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;\n    }\n\t\n    if (cpu_aff) {\n      job_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;\n      job_limit.BasicLimitInformation.Affinity = (DWORD_PTR)cpu_aff;\n    }\n\n    if(!SetInformationJobObject(\n      hJob,\n      JobObjectExtendedLimitInformation,\n      &job_limit,\n      sizeof(job_limit)\n    )) {\n      FATAL(\"SetInformationJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  if(!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {\n    FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  child_handle = pi.hProcess;\n  child_thread_handle = pi.hThread;\n\n  if(mem_limit || cpu_aff) {\n    if(!AssignProcessToJobObject(hJob, child_handle)) {\n      FATAL(\"AssignProcessToJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n    CloseHandle(hJob);\n  }\n\n  ResumeThread(child_thread_handle);\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n  watchdog_enabled = 1;\n\n  if(!OverlappedConnectNamedPipe(pipe_handle, &pipe_overlapped)) {\n      FATAL(\"ConnectNamedPipe failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  watchdog_enabled = 0;\n\n  if (drattach) {\n    child_pid = drattachpid;\n\n    CloseHandle(child_handle);\n    child_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, child_pid);\n    if (child_handle == NULL)\n    {\n      FATAL(\"OpenProcess failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(child_thread_handle);\n    child_thread_handle = NULL;\n  }\n  else if (drioless == 0) {\n    //by the time pipe has connected the pidfile must have been created\n    fp = fopen(pidfile, \"rb\");\n    if(!fp) {\n      FATAL(\"Error opening pidfile.txt\");\n    }\n    fseek(fp,0,SEEK_END);\n    pidsize = ftell(fp);\n    fseek(fp,0,SEEK_SET);\n    buf = (char *)malloc(pidsize+1);\n    if (!buf) {\n        FATAL(\"Error allocating %Iu bytes\", pidsize + 1);\n    }\n    fread(buf, pidsize, 1, fp);\n    buf[pidsize] = 0;\n    fclose(fp);\n    remove(pidfile);\n    child_pid = atoi(buf);\n    free(buf);\n    ck_free(pidfile);\n  }\n  else {\n    child_pid = pi.dwProcessId;\n  }\n\n  ck_free(client_invocation);\n  ck_free(target_cmd);\n  ck_free(cmd);\n  ck_free(pipe_name);\n}\n\n\nstatic void destroy_target_process(int wait_exit) {\n\tchar* kill_cmd;\n\tBOOL still_alive = TRUE;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\n#ifdef TINYINST\n  if (use_tinyinst) {\n    tinyinst_killtarget();\n    return;\n  }\n#endif\n\n\tEnterCriticalSection(&critical_section);\n\n  if (drattach) {\n    // reset the attach pid for next round\n    drattachpid = 0;\n  }\n\n\tif (!child_handle) {\n\t\tgoto leave;\n\t}\n\n\tif (WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {\n\t\tgoto done;\n\t}\n\n\t// nudge the child process only if dynamorio is used\n\tif (drioless) {\n\t\tTerminateProcess(child_handle, 0);\n\t}\n\telse {\n\t\tkill_cmd = alloc_printf(\"%s\\\\drconfig.exe -nudge_pid %d 0 1\", dynamorio_dir, child_pid);\n\n\t\tZeroMemory(&si, sizeof(si));\n\t\tsi.cb = sizeof(si);\n\t\tZeroMemory(&pi, sizeof(pi));\n\n\t\tif (!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n\t\t\tFATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n\t\t}\n\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\n\t\tck_free(kill_cmd);\n\t}\n\n\tstill_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;\n\n\tif (still_alive) {\n\t\t//wait until the child process exits\n\t\tZeroMemory(&si, sizeof(si));\n\t\tsi.cb = sizeof(si);\n\t\tZeroMemory(&pi, sizeof(pi));\n\n\t\tkill_cmd = alloc_printf(\"taskkill /PID %d /F\", child_pid);\n\n\t\tif (!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n\t\t\tFATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n\t\t}\n\n\t\tCloseHandle(pi.hProcess);\n\t\tCloseHandle(pi.hThread);\n\n\t\tck_free(kill_cmd);\n\n\t\tif (WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {\n\t\t\tFATAL(\"Cannot kill child process\\n\");\n\t\t}\n\t}\n\ndone:\n  if (child_handle) {\n    CloseHandle(child_handle);\n    child_handle = NULL;\n  }\n  if (child_thread_handle) {\n    CloseHandle(child_thread_handle);\n    child_thread_handle = NULL;\n  }\n\nleave:\n\t//close the pipe\n\tif (pipe_handle) {\n\t\tDisconnectNamedPipe(pipe_handle);\n\t\tCloseHandle(pipe_handle);\n\t\tCloseHandle(pipe_overlapped.hEvent);\n\n\t\tpipe_handle = NULL;\n\t}\n\n\tLeaveCriticalSection(&critical_section);\n}\n\nDWORD WINAPI watchdog_timer( LPVOID lpParam ) {\n\tu64 current_time;\n\twhile(1) {\n\t\tSleep(1000);\n\t\tcurrent_time = get_cur_time();\n\t\tif(watchdog_enabled && (current_time > watchdog_timeout_time)) {\n\t\t\tdestroy_target_process(0);\n\t\t}\n\t}\n}\n\nchar ReadCommandFromPipe(u32 timeout)\n{\n\tDWORD num_read;\n\tchar result = 0;\n\tif (!is_child_running())\n\t{\n\t\treturn 0;\n\t}\n\n\tif (ReadFile(pipe_handle, &result, 1, &num_read, &pipe_overlapped) || GetLastError() == ERROR_IO_PENDING)\n\t{\n\t\t//ACTF(\"ReadFile success or GLE IO_PENDING\", result);\n\t\tif (WaitForSingleObject(pipe_overlapped.hEvent, timeout) != WAIT_OBJECT_0) {\n\t\t\t// took longer than specified timeout or other error - cancel read\n\t\t\tCancelIo(pipe_handle);\n\t\t\tWaitForSingleObject(pipe_overlapped.hEvent, INFINITE); //wait for cancelation to finish properly.\n\t\t\tresult = 0;\n\t\t}\n\t}\n\t//ACTF(\"ReadFile GLE %d\", GetLastError());\n\t//ACTF(\"read from pipe '%c'\", result);\n\treturn result;\n}\n\nDWORD ReadDWORDFromPipe(u32 timeout)\n{\n\tDWORD num_read;\n\tDWORD result = 0;\n\n\t//char result = 0;\n\tif (!is_child_running())\n\t{\n\t\treturn 0;\n\t}\n\t\tif (ReadFile(pipe_handle, &result, sizeof(DWORD), &num_read, &pipe_overlapped) || GetLastError() == ERROR_IO_PENDING)\n\t\t{\n\t\t\t//ACTF(\"ReadFile success or GLE IO_PENDING\");\n\t\t\tif (WaitForSingleObject(pipe_overlapped.hEvent, timeout) != WAIT_OBJECT_0) {\n\t\t\t\t// took longer than specified timeout or other error - cancel read\n\t\t\t\tCancelIo(pipe_handle);\n\t\t\t\tWaitForSingleObject(pipe_overlapped.hEvent, INFINITE); //wait for cancelation to finish properly.\n\t\t\t\tresult = 0;\n\t\t\t}\n\t\t}\n\t\n\t//ACTF(\"ReadFile GLE: %d\", GetLastError());\n\t//ACTF(\"result: '%lu'\\r\\n\", result);\n\t//ACTF(\"read so far '%lu'\\r\\n\", read_so_far);\n\treturn result;\n}\n\nvoid WriteCommandToPipe(char cmd)\n{\n\tDWORD num_written;\n\t//ACTF(\"write to pipe '%c'\", cmd);\n\tWriteFile(pipe_handle, &cmd, 1, &num_written, &pipe_overlapped);\n}\n\nstatic void setup_watchdog_timer() {\n\twatchdog_enabled = 0;\n\tInitializeCriticalSection(&critical_section);\n\tCreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);\n}\n\nstatic int is_child_running() {\n  int ret;\n\n  EnterCriticalSection(&critical_section);\n  ret = (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));\n  LeaveCriticalSection(&critical_section);\n\n  return ret;\n}\n\n//Define the function prototypes\ntypedef int (APIENTRY* dll_run)(char*, long, int);\ntypedef int (APIENTRY* dll_init)();\ntypedef u8 (APIENTRY* dll_run_target)(char**, u32, char*, u32);\ntypedef void (APIENTRY *dll_write_to_testcase)(char*, s32, const void*, u32);\ntypedef u8 (APIENTRY* dll_mutate_testcase)(char**, u8*, u32, u8 (*)(char **, u8*, u32));\ntypedef u8 (APIENTRY* dll_trim_testcase)(u32*, u32, u8*, u8*, void (*)(void*, u32), u8 (*)(char**, u32), char**, u32);\n\n// Parameters: argv, in_buf, buffer_length, mutation_iterations, common_fuzz_stuff\ntypedef u8 (APIENTRY* dll_mutate_testcase_with_energy)(char**, u8*, u32, u32, u8 (*)(char **, u8*, u32));\n\n// custom server functions\ndll_run dll_run_ptr = NULL;\ndll_init dll_init_ptr = NULL;\ndll_run_target dll_run_target_ptr = NULL;\ndll_write_to_testcase dll_write_to_testcase_ptr = NULL;\ndll_mutate_testcase dll_mutate_testcase_ptr = NULL;\ndll_trim_testcase dll_trim_testcase_ptr = NULL;\ndll_mutate_testcase_with_energy dll_mutate_testcase_with_energy_ptr = NULL;\n\nchar *get_test_case(long *fsize)\n{\n  /* open generated file */\n  s32 fd = out_fd;\n  if (out_file != NULL)\n    fd = open(out_file, O_RDONLY | O_BINARY);\n\n  *fsize = lseek(fd, 0, SEEK_END);\n  lseek(fd, 0, SEEK_SET);\n\n  /* allocate buffer to read the file */\n  char *buf = malloc(*fsize);\n  ck_read(fd, buf, *fsize, \"input file\");\n\n  if(out_file != NULL)\n    close(fd);\n\n  return buf;\n}\n\n/* This function is used to call user-defined server routine to send data back into sample */\nstatic int process_test_case_into_dll(int fuzz_iterations)\n{\n  int result;\n  long fsize;\n\n  char *buf = get_test_case(&fsize);\n\n  result = dll_run_ptr(buf, fsize, fuzz_iterations); /* caller should copy the buffer */\n\n  free(buf);\n\n  if (result == 0)\n    FATAL(\"Unable to process test case, the user-defined DLL returned 0\");\n\n  return 1;\n}\n\n/* Execute target application, monitoring for timeouts. Return status\n   information. The called program will update trace_bits[]. */\n\nstatic u8 run_target(char** argv, u32 timeout) {\n\ttotal_execs++;\n\n  memset(trace_bits, 0, MAP_SIZE);\n  MemoryBarrier();\n\n  if (dll_run_target_ptr) {\n    return dll_run_target_ptr(argv, timeout, trace_bits, MAP_SIZE);\n  }\n\n#ifdef INTELPT\n\tif (use_intelpt) {\n\t\treturn run_target_pt(argv, timeout);\n\t}\n#endif\n\n#ifdef TINYINST\n  if (use_tinyinst) {\n    return tinyinst_run(argv, timeout);\n  }\n#endif\n\n  //todo watchdog timer to detect hangs\n  DWORD num_read, dwThreadId;\n  char result = 0;\n  \n \n  if(sinkhole_stds && devnul_handle == INVALID_HANDLE_VALUE) {\n    devnul_handle = CreateFile(\n        \"nul\",\n        GENERIC_READ | GENERIC_WRITE,\n        FILE_SHARE_READ | FILE_SHARE_WRITE,\n        NULL,\n        OPEN_EXISTING,\n        0,\n        NULL);\n\n    if(devnul_handle == INVALID_HANDLE_VALUE) {\n      PFATAL(\"Unable to open the nul device.\");\n    }\n  }\n\n  if (dll_init_ptr) {\n    if (!dll_init_ptr())\n      PFATAL(\"User-defined custom initialization routine returned 0\");\n  }\n\n  if(!is_child_running()) {\n    destroy_target_process(0);\n    create_target_process(argv);\n    fuzz_iterations_current = 0;\n  }\n\n  if (dll_run_ptr)\n    process_test_case_into_dll(fuzz_iterations_current);\n\n  child_timed_out = 0;\n  if (fuzz_iterations_current == 0 && init_tmout != 0) {\n\t  watchdog_timeout_time = get_cur_time() + init_tmout;\n  }\n  else {\n\t  watchdog_timeout_time = get_cur_time() + timeout;\n  }\n  watchdog_enabled = 1;\n  result = ReadCommandFromPipe(timeout);\n  if (result == 'K')\n  {\n\t  //a workaround for first cycle in app persistent mode\n\t  result = ReadCommandFromPipe(timeout);\n  }\n  if (result == 0) \n  {\n\t  //saves us from getting stuck in corner case.\n\t  MemoryBarrier();\n\t  watchdog_enabled = 0;\n\n      destroy_target_process(0);\n      return FAULT_TMOUT;\n  }\n  if (result != 'P')\n  {\n\t  FATAL(\"Unexpected result from pipe! expected 'P', instead received '%c'\\n\", result);\n  }\n  WriteCommandToPipe('F');\n\n  result = ReadCommandFromPipe(timeout); //no need to check for \"error(0)\" since we are exiting anyway\n  //ACTF(\"result: '%c'\", result);\n  MemoryBarrier();\n  watchdog_enabled = 0;\n\n#ifdef _WIN64\n  classify_counts((u64*)trace_bits);\n#else\n  classify_counts((u32*)trace_bits);\n#endif /* ^_WIN64 */\n\n  fuzz_iterations_current++;\n\n  if(fuzz_iterations_current == fuzz_iterations_max) {\n\t  destroy_target_process(2000);\n  }\n\n  if (result == 'K') return FAULT_NONE;\n\n  if (result == 'C') {\n\t  ret_exception_code = ReadDWORDFromPipe(timeout);\n\t // ACTF(\"destroying target process\");\n\t  destroy_target_process(2000);\n\t  return FAULT_CRASH;\n  }\n\n  destroy_target_process(0);\n  return FAULT_TMOUT;\n}\n\n\n/* Write modified data to file for testing. If out_file is set, the old file\n   is unlinked and a new one is created. Otherwise, out_fd is rewound and\n   truncated. */\n\nstatic void write_to_testcase(void* mem, u32 len) {\n\n  if (dll_write_to_testcase_ptr) {\t  \n      dll_write_to_testcase_ptr(out_file, out_fd, mem, len);\n      return;\n  } else if (use_sample_shared_memory) {        \n      //this writes fuzzed data to shared memory, so that it is available to harnes program.\n      uint32_t* size_ptr = (uint32_t*)shm_sample;\n      unsigned char* data_ptr = shm_sample + 4;\n     \n      if (len > MAX_SAMPLE_SIZE) len = MAX_SAMPLE_SIZE;\n     \n      *size_ptr = len;\n      memcpy(data_ptr, mem, len);\n     \n      return;\n    }\n\n  s32 fd = out_fd;\n\n  if (out_file) {\n\n    fd = open(out_file, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\n    if (fd < 0) {\n      destroy_target_process(0);\n      \n\t  fd = open(out_file, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\t\t\n      if (fd < 0) PFATAL(\"Unable to create '%s'\", out_file);\n\n\t}\n\n  } else lseek(fd, 0, SEEK_SET);\n\n  ck_write(fd, mem, len, out_file);\n\n  if (!out_file) {\n\n    if (_chsize(fd, len)) PFATAL(\"ftruncate() failed\");\n    lseek(fd, 0, SEEK_SET);\n\n  } else close(fd);\n\n}\n\n\n/* The same, but with an adjustable gap. Used for trimming. */\n\nstatic void write_with_gap(char* mem, u32 len, u32 skip_at, u32 skip_len) {\n  \n  char* trimmed_mem = malloc(len - skip_len);\n  memcpy(trimmed_mem, mem, skip_at); //copy start\n  memcpy(trimmed_mem + skip_at, mem + skip_at + skip_len, len - (skip_at + skip_len));\n  write_to_testcase(trimmed_mem, len - skip_len);\n  free(trimmed_mem);\n}\n\n\nstatic void show_stats(void);\n\n/* Calibrate a new test case. This is done when processing the input directory\n   to warn about flaky or otherwise problematic test cases early on; and when\n   new paths are discovered to detect variable behavior and so on. */\n\nstatic u8 calibrate_case(char** argv, struct queue_entry* q, u8* use_mem,\n                         u32 handicap, u8 from_queue) {\n\n  static u8 first_trace[MAP_SIZE];\n\n  u8  fault = 0, new_bits = 0, var_detected = 0, hnb = 0,\n      first_run = (q->exec_cksum == 0);\n\n  u64 start_us, stop_us;\n\n  s32 old_sc = stage_cur, old_sm = stage_max;\n  u32 use_tmout = exec_tmout;\n  u8* old_sn = stage_name;\n\n  /* Be a bit more generous about timeouts when resuming sessions, or when\n     trying to calibrate already-added finds. This helps avoid trouble due\n     to intermittent latency. */\n\n  if (!from_queue || resuming_fuzz)\n    use_tmout = MAX(exec_tmout + CAL_TMOUT_ADD,\n                    exec_tmout * CAL_TMOUT_PERC / 100);\n\n  q->cal_failed++;\n\n  stage_name = \"calibration\";\n  stage_max  = CAL_CYCLES;\n\n  /* Make sure the forkserver is up before we do anything, and let's not\n     count its spin-up time toward binary calibration. */\n\n  if (q->exec_cksum) {\n\n    memcpy(first_trace, trace_bits, MAP_SIZE);\n    hnb = has_new_bits(virgin_bits);\n    if (hnb > new_bits) new_bits = hnb;\n\n  }\n\n  start_us = get_cur_time_us();\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    u32 cksum;\n\n    if (!first_run && !(stage_cur % stats_update_freq)) show_stats();\n\n    write_to_testcase(use_mem, q->len);\n\n    fault = run_target(argv, use_tmout);\n\n    /* stop_soon is set by the handler for Ctrl+C. When it's pressed,\n       we want to bail out quickly. */\n\n    if (stop_soon || fault != crash_mode) goto abort_calibration;\n\n    if (!dumb_mode && !stage_cur && !count_bytes(trace_bits)) {\n      fault = FAULT_NOINST;\n      goto abort_calibration;\n    }\n\n    cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n    if (q->exec_cksum != cksum) {\n\n      hnb = has_new_bits(virgin_bits);\n      if (hnb > new_bits) new_bits = hnb;\n\n      if (q->exec_cksum) {\n\n        u32 i;\n\n        for (i = 0; i < MAP_SIZE; i++)\n          if (!var_bytes[i] && first_trace[i] != trace_bits[i]) {\n            var_bytes[i] = 1;\n            stage_max    = CAL_CYCLES_LONG;\n          }\n\n        var_detected = 1;\n\n      } else {\n\n        q->exec_cksum = cksum;\n        memcpy(first_trace, trace_bits, MAP_SIZE);\n\n      }\n\n    }\n\n  }\n\n  stop_us = get_cur_time_us();\n\n  total_cal_us     += stop_us - start_us;\n  total_cal_cycles += stage_max;\n\n  /* OK, let's collect some stats about the performance of this test case.\n     This is used for fuzzing air time calculations in calculate_score(). */\n\n  q->exec_us     = (stop_us - start_us) / stage_max;\n  q->bitmap_size = count_bytes(trace_bits);\n  q->handicap    = handicap;\n  q->cal_failed  = 0;\n\n  total_bitmap_size += q->bitmap_size;\n  total_bitmap_entries++;\n\n  update_bitmap_score(q);\n\n  /* If this case didn't result in new output from the instrumentation, tell\n     parent. This is a non-critical problem, but something to warn the user\n     about. */\n\n  if (!dumb_mode && first_run && !fault && !new_bits) fault = FAULT_NOBITS;\n\nabort_calibration:\n\n  if (new_bits == 2 && !q->has_new_cov) {\n    q->has_new_cov = 1;\n    queued_with_cov++;\n  }\n\n  /* Mark variable paths. */\n\n  if (var_detected) {\n\n    var_byte_count = count_bytes(var_bytes);\n\n    if (!q->var_behavior) {\n      mark_as_variable(q);\n      queued_variable++;\n    }\n\n  }\n\n  stage_name = old_sn;\n  stage_cur  = old_sc;\n  stage_max  = old_sm;\n\n  if (!first_run) show_stats();\n\n  return fault;\n\n}\n\n\n/* Examine map coverage. Called once, for first test case. */\n\nstatic void check_map_coverage(void) {\n\n  u32 i;\n\n  if (count_bytes(trace_bits) < 100) return;\n\n  for (i = (1 << (MAP_SIZE_POW2 - 1)); i < MAP_SIZE; i++)\n    if (trace_bits[i]) return;\n\n  WARNF(\"Recompile binary with newer version of afl to improve coverage!\");\n\n}\n\n\n/* Perform dry run of all test cases to confirm that the app is working as\n   expected. This is done only for the initial inputs, and only once. */\n\nstatic void perform_dry_run(char** argv) {\n\n  struct queue_entry* q = queue;\n  u32 cal_failures = 0;\n  u8* skip_crashes = getenv(\"AFL_SKIP_CRASHES\");\n\n  while (q) {\n\n    u8* use_mem;\n    u8  res;\n    s32 fd;\n\n    u8* fn = strrchr(q->fname, '\\\\') + 1;\n\n    ACTF(\"Attempting dry run with '%s'...\", fn);\n\n    fd = open(q->fname, O_RDONLY | O_BINARY);\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", q->fname);\n\n    use_mem = ck_alloc_nozero(q->len);\n\n    if (read(fd, use_mem, q->len) != q->len)\n      FATAL(\"Short read from '%s'\", q->fname);\n\n    close(fd);\n\n    res = calibrate_case(argv, q, use_mem, 0, 1);\n    ck_free(use_mem);\n\n    if (stop_soon) return;\n\n    if (res == crash_mode || res == FAULT_NOBITS)\n      SAYF(cGRA \"    len = %u, map size = %u, exec speed = %llu us\\n\" cRST, \n           q->len, q->bitmap_size, q->exec_us);\n\n    switch (res) {\n\n      case FAULT_NONE:\n\n        if (q == queue) check_map_coverage();\n\n        if (crash_mode) FATAL(\"Test case '%s' does *NOT* crash\", fn);\n\n        break;\n\n      case FAULT_TMOUT:\n\n        if (timeout_given) {\n\n          /* The -t nn+ syntax in the command line sets timeout_given to '2' and\n             instructs afl-fuzz to tolerate but skip queue entries that time\n             out. */\n\n          if (timeout_given > 1) {\n            WARNF(\"Test case results in a timeout (skipping)\");\n            q->cal_failed = CAL_CHANCES;\n            cal_failures++;\n            break;\n          }\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"The program took more than %u ms to process one of the initial test cases.\\n\"\n               \"    In WinAFL, this error could also mean incorrect instrumentation params.\\n\"\n               \"    Please make sure instrumentation runs correctly using the debug mode\\n\"\n               \"    (see the README) before attempting to run afl-fuzz.\\n\", exec_tmout);\n\n          FATAL(\"Test case '%s' results in a timeout\", fn);\n\n        } else {\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"The program took more than %u ms to process one of the initial test cases.\\n\"\n               \"    This is bad news; raising the limit with the -t option is possible, but\\n\"\n               \"    will probably make the fuzzing process extremely slow.\\n\\n\"\n\n               \"    If this test case is just a fluke, the other option is to just avoid it\\n\"\n               \"    altogether, and find one that is less of a CPU hog.\\n\", exec_tmout);\n\n          FATAL(\"Test case '%s' results in a timeout\", fn);\n\n        }\n\n      case FAULT_CRASH:  \n\n        if (crash_mode) break;\n\n        if (skip_crashes) {\n          WARNF(\"Test case results in a crash (skipping)\");\n          q->cal_failed = CAL_CHANCES;\n          cal_failures++;\n          break;\n        }\n\n        if (mem_limit) {\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"Oops, the program crashed with one of the test cases provided. There are\\n\"\n               \"    several possible explanations:\\n\\n\"\n\n               \"    - The test case causes known crashes under normal working conditions. If\\n\"\n               \"      so, please remove it. The fuzzer should be seeded with interesting\\n\"\n               \"      inputs - but not ones that cause an outright crash.\\n\\n\"\n\n               \"    - The current memory limit (%s) is too low for this program, causing\\n\"\n               \"      it to die due to OOM when parsing valid files. To fix this, try\\n\"\n               \"      bumping it up with the -m setting in the command line. If in doubt,\\n\"\n               \"      try something along the lines of:\\n\\n\"\n\n               \"      ( ulimit -Sd $[%llu << 10]; \\\\path\\\\to\\\\binary [...] <testcase )\\n\\n\"\n\n               \"      Tip: you can use http:\\\\\\\\jwilk.net\\\\software\\\\recidivm to quickly\\n\"\n               \"      estimate the required amount of virtual memory for the binary. Also,\\n\"\n               \"      if you are using ASAN, see %s\\\\notes_for_asan.txt.\\n\\n\"\n\n               \"    - Least likely, there is a horrible bug in the fuzzer. If other options\\n\"\n               \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\",\n               DMS(mem_limit << 20), mem_limit - 1, doc_path);\n\n        } else {\n\n          SAYF(\"\\n\" cLRD \"[-] \" cRST\n               \"Oops, the program crashed with one of the test cases provided. There are\\n\"\n               \"    several possible explanations:\\n\\n\"\n\n               \"    - The test case causes known crashes under normal working conditions. If\\n\"\n               \"      so, please remove it. The fuzzer should be seeded with interesting\\n\"\n               \"      inputs - but not ones that cause an outright crash.\\n\\n\"\n\n               \"    - Least likely, there is a horrible bug in the fuzzer. If other options\\n\"\n               \"      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\\n\");\n\n        }\n\n        FATAL(\"Test case '%s' results in a crash\", fn);\n\n      case FAULT_ERROR:\n\n        FATAL(\"Unable to execute target application ('%s')\", argv[0]);\n\n      case FAULT_NOINST:\n\n        FATAL(\"No instrumentation detected\");\n\n      case FAULT_NOBITS: \n\n        useless_at_start++;\n\n        if (!in_bitmap && !shuffle_queue)\n          WARNF(\"No new instrumentation output, test case may be useless.\");\n\n        break;\n\n    }\n\n    if (q->var_behavior) WARNF(\"Instrumentation output varies across runs.\");\n\n    q = q->next;\n\n  }\n\n  if (cal_failures) {\n\n    if (cal_failures == queued_paths)\n      FATAL(\"All test cases time out%s, giving up!\",\n            skip_crashes ? \" or crash\" : \"\");\n\n    WARNF(\"Skipped %u test cases (%0.02f%%) due to timeouts%s.\", cal_failures,\n          ((double)cal_failures) * 100 / queued_paths,\n          skip_crashes ? \" or crashes\" : \"\");\n\n    if (cal_failures * 5 > queued_paths)\n      WARNF(cLRD \"High percentage of rejected test cases, check settings!\");\n\n  }\n\n  OKF(\"All test cases processed.\");\n\n}\n\n\n/* Helper function: link() if possible, copy otherwise. */\n\nstatic void link_or_copy(u8* old_path, u8* new_path) {\n\n  s32 i;\n  s32 sfd, dfd;\n  u8* tmp;\n\n  sfd = open(old_path, O_RDONLY | O_BINARY);\n  if (sfd < 0) PFATAL(\"Unable to open '%s'\", old_path);\n\n  dfd = open(new_path, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);\n  if (dfd < 0) PFATAL(\"Unable to create '%s'\", new_path);\n\n  tmp = ck_alloc(64 * 1024);\n\n  while ((i = read(sfd, tmp, 64 * 1024)) > 0) \n    ck_write(dfd, tmp, i, new_path);\n\n  if (i < 0) PFATAL(\"read() failed\");\n\n  ck_free(tmp);\n  close(sfd);\n  close(dfd);\n\n}\n\n\nstatic void nuke_resume_dir(void);\n\n/* Create hard links for input test cases in the output directory, choosing\n   good names and pivoting accordingly. */\n\nstatic void pivot_inputs(void) {\n\n  struct queue_entry* q = queue;\n  u32 id = 0;\n\n  ACTF(\"Creating hard links for all input files...\");\n\n  while (q) {\n\n    u8  *nfn, *rsl = strrchr(q->fname, '\\\\');\n    u32 orig_id;\n\n    if (!rsl) rsl = q->fname; else rsl++;\n\n    /* If the original file name conforms to the syntax and the recorded\n       ID matches the one we'd assign, just use the original file name.\n       This is valuable for resuming fuzzing runs. */\n\n#ifndef SIMPLE_FILES\n#  define CASE_PREFIX \"id:\"\n#else\n#  define CASE_PREFIX \"id_\"\n#endif /* ^!SIMPLE_FILES */\n\n    if (!strncmp(rsl, CASE_PREFIX, 3) &&\n        sscanf(rsl + 3, \"%06u\", &orig_id) == 1 && orig_id == id) {\n\n      u8* src_str;\n      u32 src_id;\n\n      resuming_fuzz = 1;\n      nfn = alloc_printf(\"%s\\\\queue\\\\%s\", out_dir, rsl);\n\n      /* Since we're at it, let's also try to find parent and figure out the\n         appropriate depth for this entry. */\n\n      src_str = strchr(rsl + 3, ':');\n\n      if (src_str && sscanf(src_str + 1, \"%06u\", &src_id) == 1) {\n\n        struct queue_entry* s = queue;\n        while (src_id-- && s) s = s->next;\n        if (s) q->depth = s->depth + 1;\n\n        if (max_depth < q->depth) max_depth = q->depth;\n\n      }\n\n    } else {\n\n      /* No dice - invent a new name, capturing the original one as a\n         substring. */\n\n#ifndef SIMPLE_FILES\n\n      u8* use_name = strstr(rsl, \",orig:\");\n\n      if (use_name) use_name += 6; else use_name = rsl;\n      nfn = alloc_printf(\"%s\\\\queue\\\\id:%06u,orig:%s\", out_dir, id, use_name);\n\n#else\n\n      nfn = alloc_printf(\"%s\\\\queue\\\\id_%06u\", out_dir, id);\n\n#endif /* ^!SIMPLE_FILES */\n\n    }\n\n    /* Pivot to the new queue entry. */\n\n    link_or_copy(q->fname, nfn);\n    ck_free(q->fname);\n    q->fname = nfn;\n\n    /* Make sure that the passed_det value carries over, too. */\n\n    if (q->passed_det) mark_as_det_done(q);\n\n    q = q->next;\n    id++;\n\n  }\n\n  if (in_place_resume) nuke_resume_dir();\n\n}\n\n\n#ifndef SIMPLE_FILES\n\n/* Construct a file name for a new test case, capturing the operation\n   that led to its discovery. Uses a static buffer. */\n\nstatic u8* describe_op(u8 hnb) {\n\n  static u8 ret[256];\n\n  if (syncing_party) {\n\n    sprintf(ret, \"sync:%s,src:%06u\", syncing_party, syncing_case);\n\n  } else {\n\n    sprintf(ret, \"src:%06u\", current_entry);\n\n    if (splicing_with >= 0)\n      sprintf(ret + strlen(ret), \"+%06u\", splicing_with);\n\n    sprintf(ret + strlen(ret), \",op:%s\", stage_short);\n\n    if (stage_cur_byte >= 0) {\n\n      sprintf(ret + strlen(ret), \",pos:%u\", stage_cur_byte);\n\n      if (stage_val_type != STAGE_VAL_NONE)\n        sprintf(ret + strlen(ret), \",val:%s%+d\", \n                (stage_val_type == STAGE_VAL_BE) ? \"be:\" : \"\",\n                stage_cur_val);\n\n    } else sprintf(ret + strlen(ret), \",rep:%u\", stage_cur_val);\n\n  }\n\n  if (hnb == 2) strcat(ret, \",+cov\");\n\n  return ret;\n\n}\n\n#endif /* !SIMPLE_FILES */\n\n\n/* Write a message accompanying the crash directory :-) */\n\nstatic void write_crash_readme(void) {\n\n  u8* fn = alloc_printf(\"%s\\\\crashes\\\\README.txt\", out_dir);\n  s32 fd;\n  FILE* f;\n\n  fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);\n  ck_free(fn);\n\n  /* Do not die on errors here - that would be impolite. */\n\n  if (fd < 0) return;\n\n  f = fdopen(fd, \"w\");\n\n  if (!f) {\n    close(fd);\n    return;\n  }\n\n  fprintf(f, \"Command line used to find this crash:\\n\\n\"\n\n             \"%s\\n\\n\"\n\n             \"If you can't reproduce a bug outside of afl-fuzz, be sure to set the same\\n\"\n             \"memory limit. The limit used for this fuzzing session was %s.\\n\\n\"\n\n             \"Need a tool to minimize test cases before investigating the crashes or sending\\n\"\n             \"them to a vendor? Check out the afl-tmin that comes with the fuzzer!\\n\\n\"\n\n             \"Found any cool bugs in open-source tools using afl-fuzz? If yes, please drop\\n\"\n             \"me a mail at <lcamtuf@coredump.cx> once the issues are fixed - I'd love to\\n\"\n             \"add your finds to the gallery at:\\n\\n\"\n\n             \"  http:\\\\\\\\lcamtuf.coredump.cx\\\\afl\\\\\\n\\n\"\n\n             \"Thanks :-)\\n\",\n\n             orig_cmdline, DMS(mem_limit << 20)); /* ignore errors */\n\n  fclose(f);\n\n}\n\n\n/* Check if the result of an execve() during routine fuzzing is interesting,\n   save or queue the input test case for further analysis if so. Returns 1 if\n   entry is saved, 0 otherwise. */\n\nstatic u8 save_if_interesting(char** argv, void* mem, u32 len, u8 fault) {\n\n  u8  *fn,*exception_name = \"\";\n  u8  hnb;\n  s32 fd;\n  u8  keeping = 0, res;\n\n  if (fault == crash_mode) {\n\n    /* Keep only if there are new bits in the map, add to queue for\n       future fuzzing, etc. */\n\n    if (!(hnb = has_new_bits(virgin_bits))) {\n      if (crash_mode) total_crashes++;\n      return 0;\n    }    \n\n#ifndef SIMPLE_FILES\n\n    fn = alloc_printf(\"%s\\\\queue\\\\id:%06u,%s\", out_dir, queued_paths,\n                      describe_op(hnb));\n\n#else\n\n    fn = alloc_printf(\"%s\\\\queue\\\\id_%06u\", out_dir, queued_paths);\n\n#endif /* ^!SIMPLE_FILES */\n\n    add_to_queue(fn, len, 0);\n\n    if (hnb == 2) {\n      queue_top->has_new_cov = 1;\n      queued_with_cov++;\n    }\n\n    queue_top->exec_cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n    /* Try to calibrate inline; this also calls update_bitmap_score() when\n       successful. */\n\n    res = calibrate_case(argv, queue_top, mem, queue_cycle - 1, 0);\n\n    if (res == FAULT_ERROR)\n      FATAL(\"Unable to execute target application\");\n\n    fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n    ck_write(fd, mem, len, fn);\n    close(fd);\n\n    keeping = 1;\n\n  }\n\n  switch (fault) {\n\n    case FAULT_TMOUT:\n\n      /* Timeouts are not very interesting, but we're still obliged to keep\n         a handful of samples. We use the presence of new bits in the\n         hang-specific bitmap as a signal of uniqueness. In \"dumb\" mode, we\n         just keep everything. */\n\n      total_tmouts++;\n\n      if (unique_hangs >= KEEP_UNIQUE_HANG) return keeping;\n\n      if (!dumb_mode) {\n\n#ifdef _WIN64\n        simplify_trace((u64*)trace_bits);\n#else\n        simplify_trace((u32*)trace_bits);\n#endif /* ^_WIN64 */\n\n        if (!has_new_bits(virgin_tmout)) return keeping;\n\n      }\n\n      unique_tmouts++;\n\n      /* Before saving, we make sure that it's a genuine hang by re-running\n         the target with a more generous timeout (unless the default timeout\n         is already generous). */\n\n      if (exec_tmout < hang_tmout) {\n\n        u8 new_fault;\n        write_to_testcase(mem, len);\n        new_fault = run_target(argv, hang_tmout);\n\n        if (stop_soon || new_fault != FAULT_TMOUT) return keeping;\n\n       }\n\n#ifndef SIMPLE_FILES\n\n      fn = alloc_printf(\"%s\\\\hangs\\\\id:%06llu,%s\", out_dir,\n                        unique_hangs, describe_op(0));\n\n#else\n\n      fn = alloc_printf(\"%s\\\\hangs\\\\id_%06llu\", out_dir,\n                        unique_hangs);\n\n#endif /* ^!SIMPLE_FILES */\n\n      unique_hangs++;\n\n      last_hang_time = get_cur_time();\n\n      break;\n\n    case FAULT_CRASH:\n\n\t\tswitch (ret_exception_code) {\n\t\tcase EXCEPTION_ACCESS_VIOLATION:\n\t\t\texception_name = alloc_printf(\"%s\", \"EXCEPTION_ACCESS_VIOLATION\");\n\t\t\tbreak;\n\n\t\tcase EXCEPTION_ILLEGAL_INSTRUCTION:\n\t\t\texception_name = alloc_printf(\"%s\", \"EXCEPTION_ILLEGAL_INSTRUCTION\");\n\t\t\tbreak;\n\n\t\tcase EXCEPTION_PRIV_INSTRUCTION:\n\t\t\texception_name = alloc_printf(\"%s\", \"EXCEPTION_PRIV_INSTRUCTION\");\n\t\t\tbreak;\n\n\t\tcase EXCEPTION_INT_DIVIDE_BY_ZERO:\n\t\t\texception_name = alloc_printf(\"%s\", \"EXCEPTION_INT_DIVIDE_BY_ZERO\");\n\t\t\tbreak;\n\n\t\tcase STATUS_HEAP_CORRUPTION:\n\t\t\texception_name = alloc_printf(\"%s\", \"STATUS_HEAP_CORRUPTION\");\n\t\t\tbreak;\n\n\t\tcase EXCEPTION_STACK_OVERFLOW:\n\t\t\texception_name = alloc_printf(\"%s\", \"EXCEPTION_STACK_OVERFLOW\");\n\t\t\tbreak;\n\n\t\tcase STATUS_STACK_BUFFER_OVERRUN:\n\t\t\texception_name = alloc_printf(\"%s\", \"STATUS_STACK_BUFFER_OVERRUN\");\n\t\t\tbreak;\n\n\t\tcase STATUS_FATAL_APP_EXIT:\n\t\t\texception_name = alloc_printf(\"%s\", \"STATUS_FATAL_APP_EXIT\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texception_name = alloc_printf(\"%s\", \"EXCEPTION_NAME_NOT_AVAILABLE\");\n\t\t}\n      /* This is handled in a manner roughly similar to timeouts,\n         except for slightly different limits and no need to re-run test\n         cases. */\n\n      total_crashes++;\n\n      if (unique_crashes >= KEEP_UNIQUE_CRASH) return keeping;\n\n      if (!dumb_mode) {\n\n#ifdef _WIN64\n        simplify_trace((u64*)trace_bits);\n#else\n        simplify_trace((u32*)trace_bits);\n#endif /* ^_WIN64 */\n\n        if (!has_new_bits(virgin_crash)) return keeping;\n\n      }\n\n      if (!unique_crashes) write_crash_readme();\n\n#ifndef SIMPLE_FILES\n\n      fn = alloc_printf(\"%s\\\\crashes\\\\id:%06llu,sig:%02u,%s\", out_dir,\n                        unique_crashes, kill_signal, describe_op(0));\n\n#else\n\n      fn = alloc_printf(\"%s\\\\crashes\\\\id_%06llu_%02u_%s\", out_dir, unique_crashes,\n                        kill_signal, exception_name);\n\n#endif /* ^!SIMPLE_FILES */\n\n      unique_crashes++;\n\n      last_crash_time = get_cur_time();\n\n      last_crash_execs = total_execs;\n\n\t  ck_free(exception_name);\n\t\n\t  break;\n\n    case FAULT_ERROR: FATAL(\"Unable to execute target application\");\n\n    default: return keeping;\n\n  }\n\n  /* If we're here, we apparently want to save the crash or hang\n     test case, too. */\n\n  fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_EXCL, DEFAULT_PERMISSION);\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n  ck_write(fd, mem, len, fn);\n  close(fd);\n\n  ck_free(fn);\n\n  return keeping;\n\n}\n\n\n/* When resuming, try to find the queue position to start from. This makes sense\n   only when resuming, and when we can find the original fuzzer_stats. */\n\nstatic u32 find_start_position(void) {\n\n  static u8 tmp[4096]; /* Ought to be enough for anybody. */\n\n  u8  *fn, *off;\n  s32 fd, i;\n  u32 ret;\n\n  if (!resuming_fuzz) return 0;\n\n  if (in_place_resume) fn = alloc_printf(\"%s\\\\fuzzer_stats\", out_dir);\n  else fn = alloc_printf(\"%s\\\\..\\\\fuzzer_stats\", in_dir);\n\n  fd = open(fn, O_RDONLY | O_BINARY);\n  ck_free(fn);\n\n  if (fd < 0) return 0;\n\n  i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */\n  close(fd);\n\n  off = strstr(tmp, \"cur_path          : \");\n  if (!off) return 0;\n\n  ret = atoi(off + 20);\n  if (ret >= queued_paths) ret = 0;\n  return ret;\n\n}\n\n\n/* The same, but for timeouts. The idea is that when resuming sessions without\n   -t given, we don't want to keep auto-scaling the timeout over and over\n   again to prevent it from growing due to random flukes. */\n\nstatic void find_timeout(void) {\n\n  static u8 tmp[4096]; /* Ought to be enough for anybody. */\n\n  u8  *fn, *off;\n  s32 fd, i;\n  u32 ret;\n\n  if (!resuming_fuzz) return;\n\n  if (in_place_resume) fn = alloc_printf(\"%s\\\\fuzzer_stats\", out_dir);\n  else fn = alloc_printf(\"%s\\\\..\\\\fuzzer_stats\", in_dir);\n\n  fd = open(fn, O_RDONLY | O_BINARY);\n  ck_free(fn);\n\n  if (fd < 0) return;\n\n  i = read(fd, tmp, sizeof(tmp) - 1); (void)i; /* Ignore errors */\n  close(fd);\n\n  off = strstr(tmp, \"exec_timeout      : \");\n  if (!off) return;\n\n  ret = atoi(off + 20);\n  if (ret <= 4) return;\n\n  exec_tmout = ret;\n  timeout_given = 3;\n\n}\n\n/* Load some of the existing stats file when resuming. */\n\nvoid load_stats_file(void) {\n\n    FILE* f;\n    u8    buf[MAX_LINE];\n    u8* lptr;\n    u8    fn[MAX_PATH];\n    u32   lineno = 0;\n\n    snprintf(fn, MAX_PATH, \"%s\\\\fuzzer_stats\", out_dir);\n    f = fopen(fn, \"r\");\n    if (!f) {\n\n        WARNF(\"Unable to load stats file '%s'\", fn);\n        return;\n\n    }\n\n    while ((lptr = fgets(buf, MAX_LINE, f))) {\n\n        lineno++;\n        u8* lstartptr = lptr;\n        u8* rptr = lptr + strlen(lptr) - 1;\n        u8  keystring[MAX_LINE];\n        while (*lptr != ':' && lptr < rptr) {\n\n            lptr++;\n\n        }\n\n        if (*lptr == '\\n' || !*lptr) {\n\n            WARNF(\"Unable to read line %d of stats file\", lineno);\n            continue;\n\n        }\n\n        if (*lptr == ':') {\n\n            *lptr = 0;\n            strcpy(keystring, lstartptr);\n            lptr++;\n            char* nptr;\n            switch (lineno) {\n\n            case 3:\n                if (!strcmp(keystring, \"run_time          \"))\n                    prev_run_time = 1000 * strtoull(lptr, &nptr, 10);\n                break;\n            case 5:\n                if (!strcmp(keystring, \"cycles_done       \"))\n                    queue_cycle = strtoull(lptr, &nptr, 10) ? strtoull(lptr, &nptr, 10) + 1 : 0;\n                break;\n            case 6:\n                if (!strcmp(keystring, \"execs_done        \"))\n                    total_execs = strtoull(lptr, &nptr, 10);\n                break;\n            case 8:\n                if (!strcmp(keystring, \"paths_total       \")) {\n\n                    u32 paths_total = strtoul(lptr, &nptr, 10);\n                    if (paths_total != queued_paths) {\n                        WARNF(\"Queue has been modified, so things might not work, you're on your own!\");\n                    }\n\n                }\n                break;\n            case 10:\n                if (!strcmp(keystring, \"paths_found       \"))\n                    queued_discovered = strtoul(lptr, &nptr, 10);\n                break;\n            case 11:\n                if (!strcmp(keystring, \"paths_imported    \"))\n                    queued_imported = strtoul(lptr, &nptr, 10);\n                break;\n            case 12:\n                if (!strcmp(keystring, \"max_depth         \"))\n                    max_depth = strtoul(lptr, &nptr, 10);\n                break;\n            case 19:\n                if (!strcmp(keystring, \"unique_crashes    \"))\n                    unique_crashes = strtoull(lptr, &nptr, 10);\n                break;\n            case 20:\n                if (!strcmp(keystring, \"unique_hangs      \"))\n                    unique_hangs = strtoull(lptr, &nptr, 10);\n                break;\n            default:\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (unique_crashes) { write_crash_readme(); }\n\n    return;\n}\n\n/* Update stats file for unattended monitoring. */\n\nstatic void write_stats_file(double bitmap_cvg, double stability, double eps) {\n\n  static double last_bcvg, last_stab, last_eps;\n\n  u64 cur_time = get_cur_time();\n  u8* fn = alloc_printf(\"%s\\\\fuzzer_stats\", out_dir);\n  s32 fd;\n  FILE* f;\n\n  fd = open(fn, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\n  if (fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n\n  ck_free(fn);\n\n  f = fdopen(fd, \"w\");\n\n  if (!f) PFATAL(\"fdopen() failed\");\n\n  /* Keep last values in case we're called from another context\n     where exec/sec stats and such are not readily available. */\n\n  if (!bitmap_cvg && !stability && !eps) {\n    bitmap_cvg = last_bcvg;\n    stability  = last_stab;\n    eps        = last_eps;\n  } else {\n    last_bcvg = bitmap_cvg;\n    last_stab = stability;\n    last_eps  = eps;\n  }\n\n  fprintf(f, \"start_time        : %llu\\n\"\n             \"last_update       : %llu\\n\"\n             \"run_time          : %llu\\n\"\n             \"fuzzer_pid        : %u\\n\"\n             \"cycles_done       : %llu\\n\"\n             \"execs_done        : %llu\\n\"\n             \"execs_per_sec     : %0.02f\\n\"\n             \"paths_total       : %u\\n\"\n             \"paths_favored     : %u\\n\"\n             \"paths_found       : %u\\n\"\n             \"paths_imported    : %u\\n\"\n             \"max_depth         : %u\\n\"\n             \"cur_path          : %u\\n\"\n             \"pending_favs      : %u\\n\"\n             \"pending_total     : %u\\n\"\n             \"variable_paths    : %u\\n\"\n             \"stability         : %0.02f%%\\n\"\n             \"bitmap_cvg        : %0.02f%%\\n\"\n             \"unique_crashes    : %llu\\n\"\n             \"unique_hangs      : %llu\\n\"\n             \"last_path         : %llu\\n\"\n             \"last_crash        : %llu\\n\"\n             \"last_hang         : %llu\\n\"\n             \"execs_since_crash : %llu\\n\"\n             \"exec_timeout      : %u\\n\"\n             \"afl_banner        : %s\\n\"\n             \"afl_version       : \" VERSION \"\\n\"\n             \"command_line      : %s\\n\",\n             (start_time - prev_run_time) / 1000, cur_time / 1000, (prev_run_time + cur_time - start_time) / 1000, GetCurrentProcessId(),\n             queue_cycle ? (queue_cycle - 1) : 0, total_execs, total_execs / ((double)(prev_run_time + cur_time - start_time) / 1000),\n             queued_paths, queued_favored, queued_discovered, queued_imported,\n             max_depth, current_entry, pending_favored, pending_not_fuzzed,\n             queued_variable, stability, bitmap_cvg, unique_crashes,\n             unique_hangs, last_path_time / 1000, last_crash_time / 1000,\n             last_hang_time / 1000, total_execs - last_crash_execs,\n             exec_tmout, use_banner, orig_cmdline);\n             /* ignore errors */\n\n  fclose(f);\n\n}\n\n\n/* Update the plot file if there is a reason to. */\n\nstatic void maybe_update_plot_file(double bitmap_cvg, double eps) {\n\n  static u32 prev_qp, prev_pf, prev_pnf, prev_ce, prev_md;\n  static u64 prev_qc, prev_uc, prev_uh;\n\n  if ((prev_qp == queued_paths && prev_pf == pending_favored &&\n      prev_pnf == pending_not_fuzzed && prev_ce == current_entry &&\n      prev_qc == queue_cycle && prev_uc == unique_crashes &&\n      prev_uh == unique_hangs && prev_md == max_depth) ||\n      (get_cur_time() - start_time <= 60)) return;\n\n  prev_qp  = queued_paths;\n  prev_pf  = pending_favored;\n  prev_pnf = pending_not_fuzzed;\n  prev_ce  = current_entry;\n  prev_qc  = queue_cycle;\n  prev_uc  = unique_crashes;\n  prev_uh  = unique_hangs;\n  prev_md  = max_depth;\n\n  /* Fields in the file:\n\n     relative_time, cycles_done, cur_path, paths_total, paths_not_fuzzed,\n     favored_not_fuzzed, unique_crashes, unique_hangs, max_depth,\n     execs_per_sec */\n\n  fprintf(plot_file, \n          \"%llu, %llu, %u, %u, %u, %u, %0.02f%%, %llu, %llu, %u, %0.02f\\n\",\n          ((prev_run_time + get_cur_time() - start_time) / 1000), queue_cycle - 1, current_entry, queued_paths,\n          pending_not_fuzzed, pending_favored, bitmap_cvg, unique_crashes,\n          unique_hangs, max_depth, eps); /* ignore errors */\n\n  fflush(plot_file);\n\n}\n\n\n\n/* A helper function for maybe_delete_out_dir(), deleting all prefixed\n   files in a directory. */\n\nstatic u8 delete_files(u8* path, u8* prefix) {\n  char *pattern;\n  WIN32_FIND_DATA fd;\n  HANDLE h;\n\n  if(_access(path, 0)) return 0;\n\n  if(!prefix) {\n\t pattern = alloc_printf(\"%s\\\\*\", path);\n  } else {\n\t pattern = alloc_printf(\"%s\\\\%s*\", path, prefix);\n  }\n\n  h = FindFirstFile(pattern, &fd);\n  if(h == INVALID_HANDLE_VALUE) {\n\t  ck_free(pattern);\n      return !!_rmdir(path);\n  }\n\n  do {\n\t  if (fd.cFileName[0] != '.' && (!prefix ||\n        !strncmp(fd.cFileName, prefix, strlen(prefix)))) {\n\n      u8* fname = alloc_printf(\"%s\\\\%s\", path, fd.cFileName);\n      if (unlink(fname)) PFATAL(\"Unable to delete '%s'\", fname);\n      ck_free(fname);\n\n    }\n\n  } while(FindNextFile(h, &fd));\n\n  FindClose(h);\n\n  ck_free(pattern);\n\n  return !!_rmdir(path);\n\n}\n\n\nstatic u8 delete_subdirectories(u8* path) {\n\tchar *pattern;\n\tWIN32_FIND_DATA fd;\n\tHANDLE h;\n\n\tif (_access(path, 0)) return 0;\n\n\tpattern = alloc_printf(\"%s\\\\*\", path);\n\n\th = FindFirstFile(pattern, &fd);\n\tif (h == INVALID_HANDLE_VALUE) {\n\t\tck_free(pattern);\n\t\treturn !!_rmdir(path);\n\t}\n\n\tdo {\n\t\tif (fd.cFileName[0] != '.') {\n\n\t\t\tu8* fname = alloc_printf(\"%s\\\\%s\", path, fd.cFileName);\n\t\t\tif (delete_files(fname, NULL)) PFATAL(\"Unable to delete '%s'\", fname);\n\t\t\tck_free(fname);\n\n\t\t}\n\n\t} while (FindNextFile(h, &fd));\n\n\tFindClose(h);\n\n\tck_free(pattern);\n\n\treturn !!_rmdir(path);\n\n}\n\n\n/* Get the average usage of all processors. */\n\nstatic double get_cur_utilization(void) {\n    PDH_FMT_COUNTERVALUE cpuCounter;\n\n    PdhCollectQueryData(cpuQuery);\n    PdhGetFormattedCounterValue(cpuTotal, PDH_FMT_DOUBLE, NULL, &cpuCounter);\n\n    return cpuCounter.doubleValue;\n}\n\n\n/* Delete the temporary directory used for in-place session resume. */\n\nstatic void nuke_resume_dir(void) {\n\n  u8* fn;\n\n  fn = alloc_printf(\"%s\\\\_resume\\\\.state\\\\deterministic_done\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\_resume\\\\.state\\\\auto_extras\", out_dir);\n  if (delete_files(fn, \"auto_\")) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\_resume\\\\.state\\\\redundant_edges\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\_resume\\\\.state\\\\variable_behavior\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\_resume\\\\.state\", out_dir);\n  if (rmdir(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\_resume\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  return;\n\ndir_cleanup_failed:\n\n  FATAL(\"_resume directory cleanup failed\");\n\n}\n\n\n/* Delete fuzzer output directory if we recognize it as ours, if the fuzzer\n   is not currently running, and if the last run time isn't too great. */\n\nstatic void maybe_delete_out_dir(void) {\n\n  FILE* f;\n  u8 *fn = alloc_printf(\"%s\\\\fuzzer_stats\", out_dir);\n\n  /* See if the output directory is locked. If yes, bail out. If not,\n     create a lock that will persist for the lifetime of the process\n     (this requires leaving the descriptor open).*/\n\n  //out_dir_fd = open(out_dir, O_RDONLY | O_BINARY);\n  //if (out_dir_fd < 0) PFATAL(\"Unable to open '%s'\", out_dir);\n\n  f = fopen(fn, \"r\");\n\n  if (f) {\n\n    u64 start_time, last_update;\n\n    if (fscanf(f, \"start_time     : %llu\\n\"\n                  \"last_update    : %llu\\n\", &start_time, &last_update) != 2)\n      FATAL(\"Malformed data in '%s'\", fn);\n\n    fclose(f);\n\n    /* Autoresume treats a normal run as in_place_resume if a valid out dir\n       already exists. */\n\n    if (!in_place_resume && autoresume) in_place_resume = 1;\n\n    /* Let's see how much work is at stake. */\n\n    if (!in_place_resume && last_update - start_time > OUTPUT_GRACE * 60) {\n\n      SAYF(\"\\n\" cLRD \"[-] \" cRST\n           \"The job output directory already exists and contains the results of more\\n\"\n           \"    than %u minutes worth of fuzzing. To avoid data loss, afl-fuzz will *NOT*\\n\"\n           \"    automatically delete this data for you.\\n\\n\"\n\n           \"    If you wish to start a new session, remove or rename the directory manually,\\n\"\n           \"    or specify a different output location for this job. To resume the old\\n\"\n           \"    session, put '-' as the input directory in the command line ('-i -') or\\n\"\n           \"    set the AFL_AUTORESUME=1 env variable and try again.\\n\", OUTPUT_GRACE);\n\n       FATAL(\"At-risk data found in '%s'\", out_dir);\n\n    }\n\n  }\n\n  ck_free(fn);\n\n  /* The idea for in-place resume is pretty simple: we temporarily move the old\n     queue/ to a new location that gets deleted once import to the new queue/\n     is finished. If _resume/ already exists, the current queue/ may be\n     incomplete due to an earlier abort, so we want to use the old _resume/\n     dir instead, and we let rename() fail silently. */\n\n  if (in_place_resume) {\n\n    u8* orig_q = alloc_printf(\"%s\\\\queue\", out_dir);\n\n    in_dir = alloc_printf(\"%s\\\\_resume\", out_dir);\n\n    (void)rename(orig_q, in_dir); /* Ignore errors */\n\n    OKF(\"Output directory exists, will attempt session resume.\");\n\n    ck_free(orig_q);\n\n  } else {\n\n    OKF(\"Output directory exists but deemed OK to reuse.\");\n\n  }\n\n  ACTF(\"Deleting old session data...\");\n\n  /* Okay, let's get the ball rolling! First, we need to get rid of the entries\n     in <out_dir>/.synced/.../id:*, if any are present. */\n  if (!in_place_resume) {\n\n    fn = alloc_printf(\"%s\\\\.synced\", out_dir);\n    if (delete_files(fn, NULL)) goto dir_cleanup_failed;\n    ck_free(fn);\n\n  }\n\n  /* Next, we need to clean up <out_dir>/queue/.state/ subdirectories: */\n\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\deterministic_done\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\auto_extras\", out_dir);\n  if (delete_files(fn, \"auto_\")) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\redundant_edges\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\\\\variable_behavior\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  /* Then, get rid of the .state subdirectory itself (should be empty by now)\n     and everything matching <out_dir>/queue/id:*. */\n\n  fn = alloc_printf(\"%s\\\\queue\\\\.state\", out_dir);\n  if (rmdir(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\queue\", out_dir);\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  /* All right, let's do <out_dir>/crashes/id:* and <out_dir>/hangs/id:*. */\n\n  if (!in_place_resume) {\n\n    fn = alloc_printf(\"%s\\\\crashes\\\\README.txt\", out_dir);\n    unlink(fn); /* Ignore errors */\n    ck_free(fn);\n\n  }\n\n  fn = alloc_printf(\"%s\\\\crashes\", out_dir);\n\n  /* Make backup of the crashes directory if it's not empty and if we're\n     doing in-place resume. */\n\n  if (in_place_resume && rmdir(fn)) {\n\n    time_t cur_t = time(0);\n    struct tm* t = localtime(&cur_t);\n\n#ifndef SIMPLE_FILES\n\n    u8* nfn = alloc_printf(\"%s.%04u-%02u-%02u-%02u:%02u:%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#else\n\n    u8* nfn = alloc_printf(\"%s_%04u%02u%02u%02u%02u%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#endif /* ^!SIMPLE_FILES */\n\n    (void)rename(fn, nfn); /* Ignore errors. */\n    ck_free(nfn);\n\n  }\n\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\hangs\", out_dir);\n\n  /* Backup hangs, too. */\n\n  if (in_place_resume && rmdir(fn)) {\n\n    time_t cur_t = time(0);\n    struct tm* t = localtime(&cur_t);\n\n#ifndef SIMPLE_FILES\n\n    u8* nfn = alloc_printf(\"%s.%04u-%02u-%02u-%02u:%02u:%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#else\n\n    u8* nfn = alloc_printf(\"%s_%04u%02u%02u%02u%02u%02u\", fn,\n                           t->tm_year + 1900, t->tm_mon + 1, t->tm_mday,\n                           t->tm_hour, t->tm_min, t->tm_sec);\n\n#endif /* ^!SIMPLE_FILES */\n\n    (void)rename(fn, nfn); /* Ignore errors. */\n    ck_free(nfn);\n\n  }\n\n  if (delete_files(fn, CASE_PREFIX)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  /* And now, for some finishing touches. */\n\n  fn = alloc_printf(\"%s\\\\.cur_input\", out_dir);\n  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\fuzz_bitmap\", out_dir);\n  if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  if (!in_place_resume) {\n    fn  = alloc_printf(\"%s\\\\fuzzer_stats\", out_dir);\n    if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n    ck_free(fn);\n  }\n\n  if (!in_place_resume) {\n    fn = alloc_printf(\"%s\\\\plot_data\", out_dir);\n    if (unlink(fn) && errno != ENOENT) goto dir_cleanup_failed;\n    ck_free(fn);\n  }\n\n  fn = alloc_printf(\"%s\\\\drcache\", out_dir);\n  if(delete_subdirectories(fn)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  fn = alloc_printf(\"%s\\\\ptmodules\", out_dir);\n  if (delete_files(fn, NULL)) goto dir_cleanup_failed;\n  ck_free(fn);\n\n  OKF(\"Output dir cleanup successful.\");\n\n  /* Wow... is that all? If yes, celebrate! */\n\n  return;\n\ndir_cleanup_failed:\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Whoops, the fuzzer tried to reuse your output directory, but bumped into\\n\"\n       \"    some files that shouldn't be there or that couldn't be removed - so it\\n\"\n       \"    decided to abort! This happened while processing this path:\\n\\n\"\n\n       \"    %s\\n\\n\"\n       \"    Please examine and manually delete the files, or specify a different\\n\"\n       \"    output location for the tool.\\n\", fn);\n\n  FATAL(\"Output directory cleanup failed\");\n\n}\n\n\nstatic void check_term_size(void);\n\n\n/* A spiffy retro stats screen! This is called every stats_update_freq\n   execve() calls, plus in several other circumstances. */\n\nstatic void show_stats(void) {\n\n  static u64 last_stats_ms, last_plot_ms, last_ms, last_execs;\n  static double avg_exec;\n  double t_byte_ratio, stab_ratio;\n\n  u64 cur_ms;\n  u32 t_bytes, t_bits;\n\n  u32 banner_len, banner_pad;\n  u8  tmp[256];\n\n  cur_ms = get_cur_time();\n\n  /* If not enough time has passed since last UI update, bail out. */\n\n  if (cur_ms - last_ms < 1000 / UI_TARGET_HZ) return;\n\n  /* Check if we're past the 10 minute mark. */\n\n  if (cur_ms - start_time > 10 * 60 * 1000) run_over10m = 1;\n\n  /* Calculate smoothed exec speed stats. */\n\n  if (!last_execs) {\n  \n    avg_exec = ((double)total_execs) * 1000 / (prev_run_time + cur_ms - start_time);\n\n  } else {\n\n    double cur_avg = ((double)(total_execs - last_execs)) * 1000 /\n                     (cur_ms - last_ms);\n\n    /* If there is a dramatic (5x+) jump in speed, reset the indicator\n       more quickly. */\n\n    if (cur_avg * 5 < avg_exec || cur_avg / 5 > avg_exec)\n      avg_exec = cur_avg;\n\n    avg_exec = avg_exec * (1.0 - 1.0 / AVG_SMOOTHING) +\n               cur_avg * (1.0 / AVG_SMOOTHING);\n\n  }\n\n  last_ms = cur_ms;\n  last_execs = total_execs;\n\n  /* Tell the callers when to contact us (as measured in execs). */\n\n  stats_update_freq = avg_exec / (UI_TARGET_HZ * 10);\n  if (!stats_update_freq) stats_update_freq = 1;\n\n  /* Do some bitmap stats. */\n\n  t_bytes = count_non_255_bytes(virgin_bits);\n  t_byte_ratio = ((double)t_bytes * 100) / MAP_SIZE;\n\n  if (t_bytes)\n    stab_ratio = 100 - ((double)var_byte_count) * 100 / t_bytes;\n  else\n    stab_ratio = 100;\n\n  /* Roughly every minute, update fuzzer stats and save auto tokens. */\n\n  if (cur_ms - last_stats_ms > STATS_UPDATE_SEC * 1000) {\n\n    last_stats_ms = cur_ms;\n    write_stats_file(t_byte_ratio, stab_ratio, avg_exec);\n    save_auto();\n    write_bitmap();\n\n  }\n\n  /* Every now and then, write plot data. */\n\n  if (cur_ms - last_plot_ms > PLOT_UPDATE_SEC * 1000) {\n\n    last_plot_ms = cur_ms;\n    maybe_update_plot_file(t_byte_ratio, avg_exec);\n \n  }\n\n  /* Honor AFL_EXIT_WHEN_DONE. */\n\n  if (!dumb_mode && cycles_wo_finds > 50 && !pending_not_fuzzed &&\n      getenv(\"AFL_EXIT_WHEN_DONE\")) stop_soon = 2;\n\n  /* If we're not on TTY, bail out. */\n\n  //if (not_on_tty) return;\n\n  /* Compute some mildly useful bitmap stats. */\n\n  t_bits = (MAP_SIZE << 3) - count_bits(virgin_bits);\n\n  /* Now, for the visuals... */\n\n  if (clear_screen) {\n\n    SAYF(TERM_CLEAR CURSOR_HIDE);\n    clear_screen = 0;\n\n    check_term_size();\n\n  }\n\n  SAYF(TERM_HOME);\n\n  if (term_too_small) {\n\n    SAYF(cBRI \"Your terminal is too small to display the UI.\\n\"\n         \"Please resize terminal window to at least 80x25.\\n\" cRST);\n\n    return;\n\n  }\n\n  /* Let's start by drawing a centered banner. */\n\n  banner_len = 24 + strlen(VERSION) + strlen(WINAFL_VERSION) + strlen(use_banner);\n  banner_pad = (80 - banner_len) / 2;\n  memset(tmp, ' ', banner_pad);\n\n  sprintf(tmp + banner_pad, \"WinAFL \" WINAFL_VERSION \" based on %s \"\n          cLCY VERSION cLGN \" (%s)\",  crash_mode ? cPIN \"PWR\" : \n          cYEL \"AFL\", use_banner);\n\n  SAYF(\"\\n%s\\n\\n\", tmp);\n\n  /* \"Handy\" shortcuts for drawing boxes... */\n\n#define bSTG    bSTART cGRA\n#define bH2     bH bH\n#define bH5     bH2 bH2 bH\n#define bH10    bH5 bH5\n#define bH20    bH10 bH10\n#define bH30    bH20 bH10\n#define SP5     \"     \"\n#define SP10    SP5 SP5\n#define SP20    SP10 SP10\n\n  /* Lord, forgive me this. */\n\n  SAYF(SET_G1 bSTG bLT bH bSTOP cCYA \" process timing \" bSTG bH30 bH5 bH2 bHB\n       bH bSTOP cCYA \" overall results \" bSTG bH2 bH2 bRT \"\\n\");\n\n  if (dumb_mode) {\n\n    strcpy(tmp, cRST);\n\n  } else {\n    u64 min_wo_finds = (cur_ms - last_path_time) / 1000 / 60;\n\n    /* First queue cycle: don't stop now! */\n    if (queue_cycle == 1 || min_wo_finds < 15) strcpy(tmp, cMGN); else\n\n    /* Subsequent cycles, but we're still making finds. */\n    if (cycles_wo_finds < 25 || min_wo_finds < 30) strcpy(tmp, cYEL); else\n\n    /* No finds for a long time and no test cases to try. */\n    if (cycles_wo_finds > 100 && !pending_not_fuzzed && min_wo_finds > 120)\n      strcpy(tmp, cLGN);\n\n    /* Default: cautiously OK to stop? */\n    else strcpy(tmp, cLBL);\n\n  }\n\n  SAYF(bV bSTOP \"        run time : \" cRST \"%-34s \" bSTG bV bSTOP\n       \"  cycles done : %s%-4s  \" bSTG bV \"\\n\",\n       DTD(prev_run_time + cur_ms, start_time), tmp, DI(queue_cycle - 1));\n\n  /* We want to warn people about not seeing new paths after a full cycle,\n     except when resuming fuzzing or running in non-instrumented mode. */\n\n  if (!dumb_mode && (last_path_time || resuming_fuzz || queue_cycle == 1 ||\n      in_bitmap || crash_mode)) {\n\n    SAYF(bV bSTOP \"   last new path : \" cRST \"%-34s \",\n         DTD(cur_ms, last_path_time));\n\n  } else {\n\n    if (dumb_mode)\n\n      SAYF(bV bSTOP \"   last new path : \" cPIN \"n/a\" cRST \n           \" (non-instrumented mode)        \");\n\n     else\n\n      SAYF(bV bSTOP \"   last new path : \" cRST \"none yet \" cLRD\n           \"(odd, check syntax!)      \");\n\n  }\n\n  SAYF(bSTG bV bSTOP \"  total paths : \" cRST \"%-4s  \" bSTG bV \"\\n\",\n       DI(queued_paths));\n\n  /* Highlight crashes in red if found, denote going over the KEEP_UNIQUE_CRASH\n     limit with a '+' appended to the count. */\n\n  sprintf(tmp, \"%s%s\", DI(unique_crashes),\n          (unique_crashes >= KEEP_UNIQUE_CRASH) ? \"+\" : \"\");\n\n  SAYF(bV bSTOP \" last uniq crash : \" cRST \"%-34s \" bSTG bV bSTOP\n       \" uniq crashes : %s%-5s \" bSTG bV \"\\n\",\n       DTD(cur_ms, last_crash_time), unique_crashes ? cLRD : cRST,\n       tmp);\n\n  sprintf(tmp, \"%s%s\", DI(unique_hangs),\n         (unique_hangs >= KEEP_UNIQUE_HANG) ? \"+\" : \"\");\n\n  SAYF(bV bSTOP \"  last uniq hang : \" cRST \"%-34s \" bSTG bV bSTOP \n       \"   uniq hangs : \" cRST \"%-5s \" bSTG bV \"\\n\",\n       DTD(cur_ms, last_hang_time), tmp);\n\n  SAYF(bVR bH bSTOP cCYA \" cycle progress \" bSTG bH20 bHB bH bSTOP cCYA\n       \" map coverage \" bSTG bH bHT bH20 bH2 bVL \"\\n\");\n\n  /* This gets funny because we want to print several variable-length variables\n     together, but then cram them into a fixed-width field - so we need to\n     put them in a temporary buffer first. */\n\n  sprintf(tmp, \"%s%s (%0.02f%%)\", DI(current_entry),\n          queue_cur->favored ? \"\" : \"*\",\n          ((double)current_entry * 100) / queued_paths);\n\n  SAYF(bV bSTOP \"  now processing : \" cRST \"%-17s \" bSTG bV bSTOP, tmp);\n\n\n  sprintf(tmp, \"%0.02f%% / %0.02f%%\", ((double)queue_cur->bitmap_size) *\n          100 / MAP_SIZE, t_byte_ratio);\n\n  SAYF(\"    map density : %s%-20s \" bSTG bV \"\\n\", t_byte_ratio > 70 ? cLRD : \n       ((t_bytes < 200 && !dumb_mode) ? cPIN : cRST), tmp);\n\n  sprintf(tmp, \"%s (%0.02f%%)\", DI(cur_skipped_paths),\n          ((double)cur_skipped_paths * 100) / queued_paths);\n\n  SAYF(bV bSTOP \" paths timed out : \" cRST \"%-17s \" bSTG bV, tmp);\n\n  sprintf(tmp, \"%0.02f bits/tuple\",\n          t_bytes ? (((double)t_bits) / t_bytes) : 0);\n\n  SAYF(bSTOP \" count coverage : \" cRST \"%-20s \" bSTG bV \"\\n\", tmp);\n\n  SAYF(bVR bH bSTOP cCYA \" stage progress \" bSTG bH20 bX bSTOP cCYA\n       \" findings in depth \" bSTG bH20 bVL \"\\n\");\n\n  sprintf(tmp, \"%s (%0.02f%%)\", DI(queued_favored),\n          ((double)queued_favored) * 100 / queued_paths);\n\n  /* Yeah... it's still going on... halp? */\n\n  SAYF(bV bSTOP \"  now trying : \" cRST \"%-21s \" bSTG bV bSTOP \n       \" favored paths : \" cRST \"%-21s \" bSTG bV \"\\n\", stage_name, tmp);\n\n  if (!stage_max) {\n\n    sprintf(tmp, \"%s/-\", DI(stage_cur));\n\n  } else {\n\n    sprintf(tmp, \"%s/%s (%0.02f%%)\", DI(stage_cur), DI(stage_max),\n            ((double)stage_cur) * 100 / stage_max);\n\n  }\n\n  SAYF(bV bSTOP \" stage execs : \" cRST \"%-21s \" bSTG bV bSTOP, tmp);\n\n  sprintf(tmp, \"%s (%0.02f%%)\", DI(queued_with_cov),\n          ((double)queued_with_cov) * 100 / queued_paths);\n\n  SAYF(\"  new edges on : \" cRST \"%-21s \" bSTG bV \"\\n\", tmp);\n\n  sprintf(tmp, \"%s (%s%s unique)\", DI(total_crashes), DI(unique_crashes),\n          (unique_crashes >= KEEP_UNIQUE_CRASH) ? \"+\" : \"\");\n\n  if (crash_mode) {\n\n    SAYF(bV bSTOP \" total execs : \" cRST \"%-21s \" bSTG bV bSTOP\n         \"   new crashes : %s%-21s \" bSTG bV \"\\n\", DI(total_execs),\n         unique_crashes ? cLRD : cRST, tmp);\n\n  } else {\n\n    SAYF(bV bSTOP \" total execs : \" cRST \"%-21s \" bSTG bV bSTOP\n         \" total crashes : %s%-21s \" bSTG bV \"\\n\", DI(total_execs),\n         unique_crashes ? cLRD : cRST, tmp);\n\n  }\n\n  /* Show a warning about slow execution. */\n\n  if (avg_exec < 100) {\n\n    sprintf(tmp, \"%s/sec (%s)\", DF(avg_exec), avg_exec < 20 ?\n            \"zzzz...\" : \"slow!\");\n\n    SAYF(bV bSTOP \"  exec speed : \" cLRD \"%-21s \", tmp);\n\n  } else {\n\n    sprintf(tmp, \"%s/sec\", DF(avg_exec));\n    SAYF(bV bSTOP \"  exec speed : \" cRST \"%-21s \", tmp);\n\n  }\n\n  sprintf(tmp, \"%s (%s%s unique)\", DI(total_tmouts), DI(unique_tmouts),\n          (unique_hangs >= KEEP_UNIQUE_HANG) ? \"+\" : \"\");\n\n  SAYF (bSTG bV bSTOP \"  total tmouts : \" cRST \"%-21s \" bSTG bV \"\\n\", tmp);\n\n  /* Aaaalmost there... hold on! */\n\n  SAYF(bVR bH cCYA bSTOP \" fuzzing strategy yields \" bSTG bH10 bH bHT bH10\n       bH5 bHB bH bSTOP cCYA \" path geometry \" bSTG bH5 bH2 bVL \"\\n\");\n\n  if (skip_deterministic) {\n\n    strcpy(tmp, \"n/a, n/a, n/a\");\n\n  } else {\n\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_FLIP1]), DI(stage_cycles[STAGE_FLIP1]),\n            DI(stage_finds[STAGE_FLIP2]), DI(stage_cycles[STAGE_FLIP2]),\n            DI(stage_finds[STAGE_FLIP4]), DI(stage_cycles[STAGE_FLIP4]));\n\n  }\n\n  SAYF(bV bSTOP \"   bit flips : \" cRST \"%-37s \" bSTG bV bSTOP \"    levels : \"\n       cRST \"%-9s \" bSTG bV \"\\n\", tmp, DI(max_depth));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_FLIP8]), DI(stage_cycles[STAGE_FLIP8]),\n            DI(stage_finds[STAGE_FLIP16]), DI(stage_cycles[STAGE_FLIP16]),\n            DI(stage_finds[STAGE_FLIP32]), DI(stage_cycles[STAGE_FLIP32]));\n\n  SAYF(bV bSTOP \"  byte flips : \" cRST \"%-37s \" bSTG bV bSTOP \"   pending : \"\n       cRST \"%-9s \" bSTG bV \"\\n\", tmp, DI(pending_not_fuzzed));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_ARITH8]), DI(stage_cycles[STAGE_ARITH8]),\n            DI(stage_finds[STAGE_ARITH16]), DI(stage_cycles[STAGE_ARITH16]),\n            DI(stage_finds[STAGE_ARITH32]), DI(stage_cycles[STAGE_ARITH32]));\n\n  SAYF(bV bSTOP \" arithmetics : \" cRST \"%-37s \" bSTG bV bSTOP \"  pend fav : \"\n       cRST \"%-9s \" bSTG bV \"\\n\", tmp, DI(pending_favored));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_INTEREST8]), DI(stage_cycles[STAGE_INTEREST8]),\n            DI(stage_finds[STAGE_INTEREST16]), DI(stage_cycles[STAGE_INTEREST16]),\n            DI(stage_finds[STAGE_INTEREST32]), DI(stage_cycles[STAGE_INTEREST32]));\n\n  SAYF(bV bSTOP \"  known ints : \" cRST \"%-37s \" bSTG bV bSTOP \" own finds : \"\n       cRST \"%-9s \" bSTG bV \"\\n\", tmp, DI(queued_discovered));\n\n  if (!skip_deterministic)\n    sprintf(tmp, \"%s/%s, %s/%s, %s/%s\",\n            DI(stage_finds[STAGE_EXTRAS_UO]), DI(stage_cycles[STAGE_EXTRAS_UO]),\n            DI(stage_finds[STAGE_EXTRAS_UI]), DI(stage_cycles[STAGE_EXTRAS_UI]),\n            DI(stage_finds[STAGE_EXTRAS_AO]), DI(stage_cycles[STAGE_EXTRAS_AO]));\n\n  SAYF(bV bSTOP \"  dictionary : \" cRST \"%-37s \" bSTG bV bSTOP\n       \"  imported : \" cRST \"%-9s \" bSTG bV \"\\n\", tmp,\n       sync_id ? DI(queued_imported) : (u8*)\"n/a\");\n\n  sprintf(tmp, \"%s/%s, %s/%s\",\n          DI(stage_finds[STAGE_HAVOC]), DI(stage_cycles[STAGE_HAVOC]),\n          DI(stage_finds[STAGE_SPLICE]), DI(stage_cycles[STAGE_SPLICE]));\n\n  SAYF(bV bSTOP \"       havoc : \" cRST \"%-37s \" bSTG bV bSTOP, tmp);\n\n  if (t_bytes) sprintf(tmp, \"%0.02f%%\", stab_ratio);\n    else strcpy(tmp, \"n/a\");\n\n  SAYF(\" stability : %s%-9s \" bSTG bV \"\\n\", (stab_ratio < 85 && var_byte_count > 40)\n       ? cLRD : ((queued_variable && (!persistent_mode || var_byte_count > 20))\n       ? cMGN : cRST), tmp);\n\n  if (!bytes_trim_out) {\n\n    sprintf(tmp, \"n/a, \");\n\n  } else {\n\n    sprintf(tmp, \"%0.02f%%/%s, \",\n            ((double)(bytes_trim_in - bytes_trim_out)) * 100 / bytes_trim_in,\n            DI(trim_execs));\n\n  }\n\n  if (!blocks_eff_total) {\n\n    u8 tmp2[128];\n\n    sprintf(tmp2, \"n/a\");\n    strcat(tmp, tmp2);\n\n  } else {\n\n    u8 tmp2[128];\n\n    sprintf(tmp2, \"%0.02f%%\",\n            ((double)(blocks_eff_total - blocks_eff_select)) * 100 /\n            blocks_eff_total);\n\n    strcat(tmp, tmp2);\n\n  }\n\n  SAYF(bV bSTOP \"        trim : \" cRST \"%-37s \" bSTG bVR bH20 bH2 bH bRB \"\\n\"\n       bLB bH30 bH20 bH2 bH bRB bSTOP cRST RESET_G1, tmp);\n\n  /* Provide some CPU utilization stats. */\n\n  if (cpu_core_count) {\n\n    u32 cur_utilization = (u32)get_cur_utilization();\n\n    u8* cpu_color = cCYA;\n\n    /* If we could still run one or more processes, use green. */\n\n    if (cpu_core_count > 1 && cur_utilization < 90)\n      cpu_color = cLGN;\n\n    /* If we're clearly oversubscribed, use red. */\n\n    if (!no_cpu_meter_red && cur_utilization >= 90) cpu_color = cLRD;\n\n    if (cpu_aff >= 0) {\n\n      SAYF(\"   \" cGRA \"[cpu%06I64u: %s%3u%%\" cGRA \"]\\r\" cRST,\n        cpu_aff, cpu_color, cur_utilization < 999 ? cur_utilization : 999);\n\n    }\n    else {\n\n      SAYF(SP10 cGRA \"[cpu: %s%3u%%\" cGRA \"]\\r\" cRST,\n        cpu_color, cur_utilization < 999 ? cur_utilization : 999);\n\n    }\n\n  } else SAYF(\"\\r\");\n\n  /* Hallelujah! */\n\n  fflush(0);\n\n}\n\n/* Display quick statistics at the end of processing the input directory,\n   plus a bunch of warnings. Some calibration stuff also ended up here,\n   along with several hardcoded constants. Maybe clean up eventually. */\n\nstatic void show_init_stats(void) {\n\n  struct queue_entry* q = queue;\n  u32 min_bits = 0, max_bits = 0;\n  u64 min_us = 0, max_us = 0;\n  u64 avg_us = 0;\n  u32 max_len = 0;\n\n  if (total_cal_cycles) avg_us = total_cal_us / total_cal_cycles;\n\n  while (q) {\n\n    if (!min_us || q->exec_us < min_us) min_us = q->exec_us;\n    if (q->exec_us > max_us) max_us = q->exec_us;\n\n    if (!min_bits || q->bitmap_size < min_bits) min_bits = q->bitmap_size;\n    if (q->bitmap_size > max_bits) max_bits = q->bitmap_size;\n\n    if (q->len > max_len) max_len = q->len;\n\n    q = q->next;\n\n  }\n\n  SAYF(\"\\n\");\n\n  if (avg_us > (qemu_mode ? 50000 : 10000)) \n    WARNF(cLRD \"The target binary is pretty slow! See %s\\\\perf_tips.txt.\",\n          doc_path);\n\n  /* Let's keep things moving with slow binaries. */\n\n  if (avg_us > 50000) havoc_div = 10;     /* 0-19 execs/sec   */\n  else if (avg_us > 20000) havoc_div = 5; /* 20-49 execs/sec  */\n  else if (avg_us > 10000) havoc_div = 2; /* 50-100 execs/sec */\n\n  if (!resuming_fuzz) {\n\n    if (max_len > 50 * 1024)\n      WARNF(cLRD \"Some test cases are huge (%s) - see %s\\\\perf_tips.txt!\",\n            DMS(max_len), doc_path);\n    else if (max_len > 10 * 1024)\n      WARNF(\"Some test cases are big (%s) - see %s\\\\perf_tips.txt.\",\n            DMS(max_len), doc_path);\n\n    if (useless_at_start && !in_bitmap)\n      WARNF(cLRD \"Some test cases look useless. Consider using a smaller set.\");\n\n    if (queued_paths > 100)\n      WARNF(cLRD \"You probably have far too many input files! Consider trimming down.\");\n    else if (queued_paths > 20)\n      WARNF(\"You have lots of input files; try starting small.\");\n\n  }\n\n  OKF(\"Here are some useful stats:\\n\\n\"\n\n      cGRA \"    Test case count : \" cRST \"%u favored, %u variable, %u total\\n\"\n      cGRA \"       Bitmap range : \" cRST \"%u to %u bits (average: %0.02f bits)\\n\"\n      cGRA \"        Exec timing : \" cRST \"%s to %s us (average: %s us)\\n\",\n      queued_favored, queued_variable, queued_paths, min_bits, max_bits, \n      ((double)total_bitmap_size) / (total_bitmap_entries ? total_bitmap_entries : 1),\n      DI(min_us), DI(max_us), DI(avg_us));\n\n  if (!timeout_given) {\n\n    /* Figure out the appropriate timeout. The basic idea is: 5x average or\n       1x max, rounded up to EXEC_TM_ROUND ms and capped at 1 second.\n\n       If the program is slow, the multiplier is lowered to 2x or 3x, because\n       random scheduler jitter is less likely to have any impact, and because\n       our patience is wearing thin =) */\n\n    if (avg_us > 50000) exec_tmout = avg_us * 2 / 1000;\n    else if (avg_us > 10000) exec_tmout = avg_us * 3 / 1000;\n    else exec_tmout = avg_us * 5 / 1000;\n\n    exec_tmout = MAX(exec_tmout, max_us / 1000);\n    exec_tmout = (exec_tmout + EXEC_TM_ROUND) / EXEC_TM_ROUND * EXEC_TM_ROUND;\n\n    if (exec_tmout > EXEC_TIMEOUT) exec_tmout = EXEC_TIMEOUT;\n\n    ACTF(\"No -t option specified, so I'll use exec timeout of %u ms.\", \n         exec_tmout);\n\n    timeout_given = 1;\n\n  } else if (timeout_given == 3) {\n\n    ACTF(\"Applying timeout settings from resumed session (%u ms).\", exec_tmout);\n\n  }\n\n  /* In dumb mode, re-running every timing out test case with a generous time\n     limit is very expensive, so let's select a more conservative default. */\n\n  if (dumb_mode && !getenv(\"AFL_HANG_TMOUT\"))\n    hang_tmout = MIN(EXEC_TIMEOUT, exec_tmout * 2 + 100);\n\n  OKF(\"All set and ready to roll!\");\n\n}\n\n\n/* Find first power of two greater or equal to val. */\n\nstatic u32 next_p2(u32 val) {\n\n  u32 ret = 1;\n  while (val > ret) ret <<= 1;\n  return ret;\n\n} \n\n\n/* Trim all new test cases to save cycles when doing deterministic checks. The\n   trimmer uses power-of-two increments somewhere between 1/16 and 1/1024 of\n   file size, to keep the stage short and sweet. */\n\nstatic u8 trim_case(char** argv, struct queue_entry* q, u8* in_buf) {\n\n  static u8 tmp[64];\n  static u8 clean_trace[MAP_SIZE];\n\n  u8  needs_write = 0, fault = 0;\n  u32 trim_exec = 0;\n  u32 remove_len;\n  u32 len_p2;\n\n  /* Although the trimmer will be less useful when variable behavior is\n     detected, it will still work to some extent, so we don't check for\n     this. */\n\n  if (q->len < 5) return 0;\n\n  if (dll_trim_testcase_ptr) {\n    // Call the custom trimming function.\n    // The trimmed data will be set in in_buf and its length in q->len.\n    // The implementation can test for changes in the trace after calling run_target\n    // by calculating the hash for trace_bits and comparing it to q->exec_cksum.\n    // Checksum function is declared in hash.h.\n    // The return value will determine if the trimmed data will be written to a file.\n    needs_write = dll_trim_testcase_ptr(&q->len, q->exec_cksum,\n      in_buf, trace_bits, write_to_testcase, run_target, argv, exec_tmout);\n    goto write_trimmed;\n  }\n\n  stage_name = tmp;\n  bytes_trim_in += q->len;\n\n  /* Select initial chunk len, starting with large steps. */\n\n  len_p2 = next_p2(q->len);\n\n  remove_len = MAX(len_p2 / TRIM_START_STEPS, TRIM_MIN_BYTES);\n\n  /* Continue until the number of steps gets too high or the stepover\n     gets too small. */\n\n  while (remove_len >= MAX(len_p2 / TRIM_END_STEPS, TRIM_MIN_BYTES)) {\n\n    u32 remove_pos = remove_len;\n\n    sprintf(tmp, \"trim %s\\\\%s\", DI(remove_len), DI(remove_len));\n\n    stage_cur = 0;\n    stage_max = q->len / remove_len;\n\n    while (remove_pos < q->len) {\n\n      u32 trim_avail = MIN(remove_len, q->len - remove_pos);\n      u32 cksum;\n\n      write_with_gap(in_buf, q->len, remove_pos, trim_avail);\n\n      fault = run_target(argv, exec_tmout);\n      trim_execs++;\n\n      if (stop_soon || fault == FAULT_ERROR) goto abort_trimming;\n\n      /* Note that we don't keep track of crashes or hangs here; maybe TODO? */\n\n      cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n      /* If the deletion had no impact on the trace, make it permanent. This\n         isn't perfect for variable-path inputs, but we're just making a\n         best-effort pass, so it's not a big deal if we end up with false\n         negatives every now and then. */\n\n      if (cksum == q->exec_cksum) {\n\n        u32 move_tail = q->len - remove_pos - trim_avail;\n\n        q->len -= trim_avail;\n        len_p2  = next_p2(q->len);\n\n        memmove(in_buf + remove_pos, in_buf + remove_pos + trim_avail, \n                move_tail);\n\n        /* Let's save a clean trace, which will be needed by\n           update_bitmap_score once we're done with the trimming stuff. */\n\n        if (!needs_write) {\n\n          needs_write = 1;\n          memcpy(clean_trace, trace_bits, MAP_SIZE);\n\n        }\n\n      } else remove_pos += remove_len;\n\n      /* Since this can be slow, update the screen every now and then. */\n\n      if (!(trim_exec++ % stats_update_freq)) show_stats();\n      stage_cur++;\n\n    }\n\n    remove_len >>= 1;\n\n  }\n\n  /* If we have made changes to in_buf, we also need to update the on-disk\n     version of the test case. */\nwrite_trimmed:\n  if (needs_write) {\n\n    s32 fd;\n\n    fd = open(q->fname, O_WRONLY | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", q->fname);\n\n    ck_write(fd, in_buf, q->len, q->fname);\n    close(fd);\n\n    memcpy(trace_bits, clean_trace, MAP_SIZE);\n    update_bitmap_score(q);\n\n  }\n\n\n\nabort_trimming:\n\n  bytes_trim_out += q->len;\n  return fault;\n\n}\n\n\n/* Write a modified test case, run program, process results. Handle\n   error conditions, returning 1 if it's time to bail out. This is\n   a helper function for fuzz_one(). */\n\nstatic u8 common_fuzz_stuff(char** argv, u8* out_buf, u32 len) {\n\n  u8 fault;\n\n  if (post_handler) {\n\n    out_buf = post_handler(out_buf, &len);\n    if (!out_buf || !len) return 0;\n\n  }\n\n  write_to_testcase(out_buf, len);\n\n  fault = run_target(argv, exec_tmout);\n\n  if (stop_soon) return 1;\n\n  if (fault == FAULT_TMOUT) {\n\n    if (subseq_tmouts++ > TMOUT_LIMIT) {\n      cur_skipped_paths++;\n      return 1;\n    }\n\n  } else subseq_tmouts = 0;\n\n  /* Users can hit us with SIGUSR1 to request the current input\n     to be abandoned. */\n\n  if (skip_requested) {\n\n     skip_requested = 0;\n     cur_skipped_paths++;\n     return 1;\n\n  }\n\n  /* This handles FAULT_ERROR for us: */\n \n  queued_discovered += save_if_interesting(argv, out_buf, len, fault);\n\n  if (!(stage_cur % stats_update_freq) || stage_cur + 1 == stage_max)\n    show_stats();\n\n  return 0;\n\n}\n\n\n/* Helper to choose random block len for block operations in fuzz_one().\n   Doesn't return zero, provided that max_len is > 0. */\n\nstatic u32 choose_block_len(u32 limit) {\n\n  u32 min_value, max_value;\n  u32 rlim = MIN(queue_cycle, 3);\n\n  if (!run_over10m) rlim = 1;\n\n  switch (UR(rlim)) {\n\n    case 0:  min_value = 1;\n             max_value = HAVOC_BLK_SMALL;\n             break;\n\n    case 1:  min_value = HAVOC_BLK_SMALL;\n             max_value = HAVOC_BLK_MEDIUM;\n             break;\n\n    default:\n\n             if (UR(10)) {\n\n               min_value = HAVOC_BLK_MEDIUM;\n               max_value = HAVOC_BLK_LARGE;\n\n             } else {\n\n               min_value = HAVOC_BLK_LARGE;\n               max_value = HAVOC_BLK_XL;\n\n             }\n\n  }\n\n  if (min_value >= limit) min_value = 1;\n\n  return min_value + UR(MIN(max_value, limit) - min_value + 1);\n\n}\n\n\n/* Calculate case desirability score to adjust the length of havoc fuzzing.\n   A helper function for fuzz_one(). Maybe some of these constants should\n   go into config.h. */\n\nstatic u32 calculate_score(struct queue_entry* q) {\n\n  u32 avg_exec_us = total_cal_us / total_cal_cycles;\n  u32 avg_bitmap_size = total_bitmap_size / total_bitmap_entries;\n  u32 perf_score = 100;\n\n  /* Adjust score based on execution speed of this path, compared to the\n     global average. Multiplier ranges from 0.1x to 3x. Fast inputs are\n     less expensive to fuzz, so we're giving them more air time. */\n\n  if (q->exec_us * 0.1 > avg_exec_us) perf_score = 10;\n  else if (q->exec_us * 0.25 > avg_exec_us) perf_score = 25;\n  else if (q->exec_us * 0.5 > avg_exec_us) perf_score = 50;\n  else if (q->exec_us * 0.75 > avg_exec_us) perf_score = 75;\n  else if (q->exec_us * 4 < avg_exec_us) perf_score = 300;\n  else if (q->exec_us * 3 < avg_exec_us) perf_score = 200;\n  else if (q->exec_us * 2 < avg_exec_us) perf_score = 150;\n\n  /* Adjust score based on bitmap size. The working theory is that better\n     coverage translates to better targets. Multiplier from 0.25x to 3x. */\n\n  if (q->bitmap_size * 0.3 > avg_bitmap_size) perf_score *= 3;\n  else if (q->bitmap_size * 0.5 > avg_bitmap_size) perf_score *= 2;\n  else if (q->bitmap_size * 0.75 > avg_bitmap_size) perf_score *= 1.5;\n  else if (q->bitmap_size * 3 < avg_bitmap_size) perf_score *= 0.25;\n  else if (q->bitmap_size * 2 < avg_bitmap_size) perf_score *= 0.5;\n  else if (q->bitmap_size * 1.5 < avg_bitmap_size) perf_score *= 0.75;\n\n  /* Adjust score based on handicap. Handicap is proportional to how late\n     in the game we learned about this path. Latecomers are allowed to run\n     for a bit longer until they catch up with the rest. */\n\n  if (q->handicap >= 4) {\n\n    perf_score *= 4;\n    q->handicap -= 4;\n\n  } else if (q->handicap) {\n\n    perf_score *= 2;\n    q->handicap--;\n\n  }\n\n  /* Final adjustment based on input depth, under the assumption that fuzzing\n     deeper test cases is more likely to reveal stuff that can't be\n     discovered with traditional fuzzers. */\n\n  if(q->depth >= 4) {\n\t  if(q->depth < 8) perf_score *= 2;\n\t  else if(q->depth < 14) perf_score *= 3;\n\t  else if(q->depth < 26) perf_score *= 4;\n\t  else perf_score *= 5;\n  }\n\n  /* Make sure that we don't go over limit. */\n\n  if (perf_score > HAVOC_MAX_MULT * 100) perf_score = HAVOC_MAX_MULT * 100;\n\n  return perf_score;\n\n}\n\n\n/* Helper function to see if a particular change (xor_val = old ^ new) could\n   be a product of deterministic bit flips with the lengths and stepovers\n   attempted by afl-fuzz. This is used to avoid dupes in some of the\n   deterministic fuzzing operations that follow bit flips. We also\n   return 1 if xor_val is zero, which implies that the old and attempted new\n   values are identical and the exec would be a waste of time. */\n\nstatic u8 could_be_bitflip(u32 xor_val) {\n\n  u32 sh = 0;\n\n  if (!xor_val) return 1;\n\n  /* Shift left until first bit set. */\n\n  while (!(xor_val & 1)) { sh++; xor_val >>= 1; }\n\n  /* 1-, 2-, and 4-bit patterns are OK anywhere. */\n\n  if (xor_val == 1 || xor_val == 3 || xor_val == 15) return 1;\n\n  /* 8-, 16-, and 32-bit patterns are OK only if shift factor is\n     divisible by 8, since that's the stepover for these ops. */\n\n  if (sh & 7) return 0;\n\n  if (xor_val == 0xff || xor_val == 0xffff || xor_val == 0xffffffff)\n    return 1;\n\n  return 0;\n\n}\n\n\n/* Helper function to see if a particular value is reachable through\n   arithmetic operations. Used for similar purposes. */\n\nstatic u8 could_be_arith(u32 old_val, u32 new_val, u8 blen) {\n\n  u32 i, ov = 0, nv = 0, diffs = 0;\n\n  if (old_val == new_val) return 1;\n\n  /* See if one-byte adjustments to any byte could produce this result. */\n\n  for (i = 0; i < blen; i++) {\n\n    u8 a = old_val >> (8 * i),\n       b = new_val >> (8 * i);\n\n    if (a != b) { diffs++; ov = a; nv = b; }\n\n  }\n\n  /* If only one byte differs and the values are within range, return 1. */\n\n  if (diffs == 1) {\n\n    if ((u8)(ov - nv) <= ARITH_MAX ||\n        (u8)(nv - ov) <= ARITH_MAX) return 1;\n\n  }\n\n  if (blen == 1) return 0;\n\n  /* See if two-byte adjustments to any byte would produce this result. */\n\n  diffs = 0;\n\n  for (i = 0; i < blen / 2; i++) {\n\n    u16 a = old_val >> (16 * i),\n        b = new_val >> (16 * i);\n\n    if (a != b) { diffs++; ov = a; nv = b; }\n\n  }\n\n  /* If only one word differs and the values are within range, return 1. */\n\n  if (diffs == 1) {\n\n    if ((u16)(ov - nv) <= ARITH_MAX ||\n        (u16)(nv - ov) <= ARITH_MAX) return 1;\n\n    ov = SWAP16(ov); nv = SWAP16(nv);\n\n    if ((u16)(ov - nv) <= ARITH_MAX ||\n        (u16)(nv - ov) <= ARITH_MAX) return 1;\n\n  }\n\n  /* Finally, let's do the same thing for dwords. */\n\n  if (blen == 4) {\n\n    if ((u32)(old_val - new_val) <= ARITH_MAX ||\n        (u32)(new_val - old_val) <= ARITH_MAX) return 1;\n\n    new_val = SWAP32(new_val);\n    old_val = SWAP32(old_val);\n\n    if ((u32)(old_val - new_val) <= ARITH_MAX ||\n        (u32)(new_val - old_val) <= ARITH_MAX) return 1;\n\n  }\n\n  return 0;\n\n}\n\n\n/* Last but not least, a similar helper to see if insertion of an \n   interesting integer is redundant given the insertions done for\n   shorter blen. The last param (check_le) is set if the caller\n   already executed LE insertion for current blen and wants to see\n   if BE variant passed in new_val is unique. */\n\nstatic u8 could_be_interest(u32 old_val, u32 new_val, u8 blen, u8 check_le) {\n\n  u32 i, j;\n\n  if (old_val == new_val) return 1;\n\n  /* See if one-byte insertions from interesting_8 over old_val could\n     produce new_val. */\n\n  for (i = 0; i < blen; i++) {\n\n    for (j = 0; j < sizeof(interesting_8); j++) {\n\n      u32 tval = (old_val & ~(0xff << (i * 8))) |\n                 (((u8)interesting_8[j]) << (i * 8));\n\n      if (new_val == tval) return 1;\n\n    }\n\n  }\n\n  /* Bail out unless we're also asked to examine two-byte LE insertions\n     as a preparation for BE attempts. */\n\n  if (blen == 2 && !check_le) return 0;\n\n  /* See if two-byte insertions over old_val could give us new_val. */\n\n  for (i = 0; i < blen - 1; i++) {\n\n    for (j = 0; j < sizeof(interesting_16) / 2; j++) {\n\n      u32 tval = (old_val & ~(0xffff << (i * 8))) |\n                 (((u16)interesting_16[j]) << (i * 8));\n\n      if (new_val == tval) return 1;\n\n      /* Continue here only if blen > 2. */\n\n      if (blen > 2) {\n\n        tval = (old_val & ~(0xffff << (i * 8))) |\n               (SWAP16(interesting_16[j]) << (i * 8));\n\n        if (new_val == tval) return 1;\n\n      }\n\n    }\n\n  }\n\n  if (blen == 4 && check_le) {\n\n    /* See if four-byte insertions could produce the same result\n       (LE only). */\n\n    for (j = 0; j < sizeof(interesting_32) / 4; j++)\n      if (new_val == (u32)interesting_32[j]) return 1;\n\n  }\n\n  return 0;\n\n}\n\n\n/* Take the current entry from the queue, fuzz it for a while. This\n   function is a tad too long... returns 0 if fuzzed successfully, 1 if\n   skipped or bailed out. */\n\nstatic u8 fuzz_one(char** argv) {\n\n  s32 len, fd, temp_len, i, j;\n  u8  *in_buf, *out_buf, *orig_in, *ex_tmp, *eff_map = 0;\n  u64 havoc_queued,  orig_hit_cnt, new_hit_cnt;\n  u32 splice_cycle = 0, perf_score = 100, orig_perf, prev_cksum, eff_cnt = 1;\n\n  u8  ret_val = 1, doing_det = 0;\n\n  u8  a_collect[MAX_AUTO_EXTRA];\n  u32 a_len = 0;\n\n#ifdef IGNORE_FINDS\n\n  /* In IGNORE_FINDS mode, skip any entries that weren't in the\n     initial data set. */\n\n  if (queue_cur->depth > 1) return 1;\n\n#else\n\n  if (pending_favored) {\n\n    /* If we have any favored, non-fuzzed new arrivals in the queue,\n       possibly skip to them at the expense of already-fuzzed or non-favored\n       cases. */\n\n    if ((queue_cur->was_fuzzed || !queue_cur->favored) &&\n        UR(100) < SKIP_TO_NEW_PROB) return 1;\n\n  } else if (!dumb_mode && !queue_cur->favored && queued_paths > 10) {\n\n    /* Otherwise, still possibly skip non-favored cases, albeit less often.\n       The odds of skipping stuff are higher for already-fuzzed inputs and\n       lower for never-fuzzed entries. */\n\n    if (queue_cycle > 1 && !queue_cur->was_fuzzed) {\n\n      if (UR(100) < SKIP_NFAV_NEW_PROB) return 1;\n\n    } else {\n\n      if (UR(100) < SKIP_NFAV_OLD_PROB) return 1;\n\n    }\n\n  }\n\n#endif /* ^IGNORE_FINDS */\n\n  if (not_on_tty)\n    ACTF(\"Fuzzing test case #%u (%u total)...\", current_entry, queued_paths);\n\n  /* Map the test case into memory. */\n\n  fd = open(queue_cur->fname, O_RDONLY | O_BINARY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", queue_cur->fname);\n\n  len = queue_cur->len;\n\n  orig_in = in_buf = (u8 *)ck_alloc_nozero(len);\n  _read(fd, in_buf, len);\n\n  close(fd);\n\n  /* We could mmap() out_buf as MAP_PRIVATE, but we end up clobbering every\n     single byte anyway, so it wouldn't give us any performance or memory usage\n     benefits. */\n\n  out_buf = ck_alloc_nozero(len);\n\n  subseq_tmouts = 0;\n\n  cur_depth = queue_cur->depth;\n\n  /*******************************************\n   * CALIBRATION (only if failed earlier on) *\n   *******************************************/\n\n  if (queue_cur->cal_failed) {\n\n    u8 res = FAULT_TMOUT;\n\n    if (queue_cur->cal_failed < CAL_CHANCES) {\n\n      /* Reset exec_cksum to tell calibrate_case to re-execute the testcase\n         avoiding the usage of an invalid trace_bits.\n         For more info: https://github.com/AFLplusplus/AFLplusplus/pull/425 */\n\n      queue_cur->exec_cksum = 0;\n\n      res = calibrate_case(argv, queue_cur, in_buf, queue_cycle - 1, 0);\n\n      if (res == FAULT_ERROR)\n        FATAL(\"Unable to execute target application\");\n\n    }\n\n    if (stop_soon || res != crash_mode) {\n      cur_skipped_paths++;\n      goto abandon_entry;\n    }\n\n  }\n\n  /************\n   * TRIMMING *\n   ************/\n\n  if (!dumb_mode && !queue_cur->trim_done) {\n\n    u8 res = trim_case(argv, queue_cur, in_buf);\n\n    if (res == FAULT_ERROR)\n      FATAL(\"Unable to execute target application\");\n\n    if (stop_soon) {\n      cur_skipped_paths++;\n      goto abandon_entry;\n    }\n\n    /* Don't retry trimming, even if it failed. */\n\n    queue_cur->trim_done = 1;\n\n    if (len != queue_cur->len) len = queue_cur->len;\n\n  }\n\n  memcpy(out_buf, in_buf, len);\n\n  /*********************\n   * PERFORMANCE SCORE *\n   *********************/\n\n  orig_perf = perf_score = calculate_score(queue_cur);\n\n  /******************\n   * CUSTOM MUTATOR *\n   *****************/\n\n  // Prefer a custom mutator that accepts the performance score as an energy value.\n  if (dll_mutate_testcase_with_energy_ptr) {\n    if (dll_mutate_testcase_with_energy_ptr(argv, in_buf, len, perf_score, common_fuzz_stuff))\n      goto abandon_entry;\n  }\n  else if (dll_mutate_testcase_ptr) {\n    if (dll_mutate_testcase_ptr(argv, in_buf, len, common_fuzz_stuff))\n      goto abandon_entry;\n  }\n\n  /* Skip right away if -d is given, if we have done deterministic fuzzing on\n     this entry ourselves (was_fuzzed), or if it has gone through deterministic\n     testing in earlier, resumed runs (passed_det). */\n\n  if (skip_deterministic || queue_cur->was_fuzzed || queue_cur->passed_det)\n    goto havoc_stage;\n\n  /* Skip deterministic fuzzing if exec path checksum puts this out of scope\n     for this master instance. */\n\n  if (master_max && (queue_cur->exec_cksum % master_max) != master_id - 1)\n    goto havoc_stage;\n\n  doing_det = 1;\n\n  /*********************************************\n   * SIMPLE BITFLIP (+dictionary construction) *\n   *********************************************/\n\n#define FLIP_BIT(_ar, _b) do { \\\n    u8* _arf = (u8*)(_ar); \\\n    u32 _bf = (_b); \\\n    _arf[(_bf) >> 3] ^= (128 >> ((_bf) & 7)); \\\n  } while (0)\n\n  /* Single walking bit. */\n\n  stage_short = \"flip1\";\n  stage_max   = len << 3;\n  stage_name  = \"bitflip 1\\\\1\";\n\n  stage_val_type = STAGE_VAL_NONE;\n\n  orig_hit_cnt = queued_paths + unique_crashes;\n\n  prev_cksum = queue_cur->exec_cksum;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur >> 3;\n\n    FLIP_BIT(out_buf, stage_cur);\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    FLIP_BIT(out_buf, stage_cur);\n\n    /* While flipping the least significant bit in every byte, pull of an extra\n       trick to detect possible syntax tokens. In essence, the idea is that if\n       you have a binary blob like this:\n\n       xxxxxxxxIHDRxxxxxxxx\n\n       ...and changing the leading and trailing bytes causes variable or no\n       changes in program flow, but touching any character in the \"IHDR\" string\n       always produces the same, distinctive path, it's highly likely that\n       \"IHDR\" is an atomically-checked magic value of special significance to\n       the fuzzed format.\n\n       We do this here, rather than as a separate stage, because it's a nice\n       way to keep the operation approximately \"free\" (i.e., no extra execs).\n       \n       Empirically, performing the check when flipping the least significant bit\n       is advantageous, compared to doing it at the time of more disruptive\n       changes, where the program flow may be affected in more violent ways.\n\n       The caveat is that we won't generate dictionaries in the -d mode or -S\n       mode - but that's probably a fair trade-off.\n\n       This won't work particularly well with paths that exhibit variable\n       behavior, but fails gracefully, so we'll carry out the checks anyway.\n\n      */\n\n    if (!dumb_mode && (stage_cur & 7) == 7) {\n\n      u32 cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n\n      if (stage_cur == stage_max - 1 && cksum == prev_cksum) {\n\n        /* If at end of file and we are still collecting a string, grab the\n           final character and force output. */\n\n        if (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> 3];\n        a_len++;\n\n        if (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)\n          maybe_add_auto(a_collect, a_len);\n\n      } else if (cksum != prev_cksum) {\n\n        /* Otherwise, if the checksum has changed, see if we have something\n           worthwhile queued up, and collect that if the answer is yes. */\n\n        if (a_len >= MIN_AUTO_EXTRA && a_len <= MAX_AUTO_EXTRA)\n          maybe_add_auto(a_collect, a_len);\n\n        a_len = 0;\n        prev_cksum = cksum;\n\n      }\n\n      /* Continue collecting string, but only if the bit flip actually made\n         any difference - we don't want no-op tokens. */\n\n      if (cksum != queue_cur->exec_cksum) {\n\n        if (a_len < MAX_AUTO_EXTRA) a_collect[a_len] = out_buf[stage_cur >> 3];        \n        a_len++;\n\n      }\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP1]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP1] += stage_max;\n\n  /* Two walking bits. */\n\n  stage_name  = \"bitflip 2\\\\1\";\n  stage_short = \"flip2\";\n  stage_max   = (len << 3) - 1;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur >> 3;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP2]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP2] += stage_max;\n\n  /* Four walking bits. */\n\n  stage_name  = \"bitflip 4\\\\1\";\n  stage_short = \"flip4\";\n  stage_max   = (len << 3) - 3;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur >> 3;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n    FLIP_BIT(out_buf, stage_cur + 2);\n    FLIP_BIT(out_buf, stage_cur + 3);\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    FLIP_BIT(out_buf, stage_cur);\n    FLIP_BIT(out_buf, stage_cur + 1);\n    FLIP_BIT(out_buf, stage_cur + 2);\n    FLIP_BIT(out_buf, stage_cur + 3);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP4]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP4] += stage_max;\n\n  /* Effector map setup. These macros calculate:\n\n     EFF_APOS      - position of a particular file offset in the map.\n     EFF_ALEN      - length of a map with a particular number of bytes.\n     EFF_SPAN_ALEN - map span for a sequence of bytes.\n\n   */\n\n#define EFF_APOS(_p)          ((_p) >> EFF_MAP_SCALE2)\n#define EFF_REM(_x)           ((_x) & ((1 << EFF_MAP_SCALE2) - 1))\n#define EFF_ALEN(_l)          (EFF_APOS(_l) + !!EFF_REM(_l))\n#define EFF_SPAN_ALEN(_p, _l) (EFF_APOS((_p) + (_l) - 1) - EFF_APOS(_p) + 1)\n\n  /* Initialize effector map for the next step (see comments below). Always\n     flag first and last byte as doing something. */\n\n  eff_map    = ck_alloc(EFF_ALEN(len));\n  eff_map[0] = 1;\n\n  if (EFF_APOS(len - 1) != 0) {\n    eff_map[EFF_APOS(len - 1)] = 1;\n    eff_cnt++;\n  }\n\n  /* Walking byte. */\n\n  stage_name  = \"bitflip 8\\\\8\";\n  stage_short = \"flip8\";\n  stage_max   = len;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    stage_cur_byte = stage_cur;\n\n    out_buf[stage_cur] ^= 0xFF;\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n    /* We also use this stage to pull off a simple trick: we identify\n       bytes that seem to have no effect on the current execution path\n       even when fully flipped - and we skip them during more expensive\n       deterministic stages, such as arithmetics or known ints. */\n\n    if (!eff_map[EFF_APOS(stage_cur)]) {\n\n      u32 cksum;\n\n      /* If in dumb mode or if the file is very short, just flag everything\n         without wasting time on checksums. */\n\n      if (!dumb_mode && len >= EFF_MIN_LEN)\n        cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n      else\n        cksum = ~queue_cur->exec_cksum;\n\n      if (cksum != queue_cur->exec_cksum) {\n        eff_map[EFF_APOS(stage_cur)] = 1;\n        eff_cnt++;\n      }\n\n    }\n\n    out_buf[stage_cur] ^= 0xFF;\n\n  }\n\n  /* If the effector map is more than EFF_MAX_PERC dense, just flag the\n     whole thing as worth fuzzing, since we wouldn't be saving much time\n     anyway. */\n\n  if (eff_cnt != EFF_ALEN(len) &&\n      eff_cnt * 100 / EFF_ALEN(len) > EFF_MAX_PERC) {\n\n    memset(eff_map, 1, EFF_ALEN(len));\n\n    blocks_eff_select += EFF_ALEN(len);\n\n  } else {\n\n    blocks_eff_select += eff_cnt;\n\n  }\n\n  blocks_eff_total += EFF_ALEN(len);\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP8]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP8] += stage_max;\n\n  /* Two walking bytes. */\n\n  if (len < 2) goto skip_bitflip;\n\n  stage_name  = \"bitflip 16\\\\8\";\n  stage_short = \"flip16\";\n  stage_cur   = 0;\n  stage_max   = len - 1;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 1; i++) {\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {\n      stage_max--;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    *(u16*)(out_buf + i) ^= 0xFFFF;\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n    stage_cur++;\n\n    *(u16*)(out_buf + i) ^= 0xFFFF;\n\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP16]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP16] += stage_max;\n\n  if (len < 4) goto skip_bitflip;\n\n  /* Four walking bytes. */\n\n  stage_name  = \"bitflip 32\\\\8\";\n  stage_short = \"flip32\";\n  stage_cur   = 0;\n  stage_max   = len - 3;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 3; i++) {\n\n    /* Let's consult the effector map... */\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&\n        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {\n      stage_max--;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    *(u32*)(out_buf + i) ^= 0xFFFFFFFF;\n\n    if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n    stage_cur++;\n\n    *(u32*)(out_buf + i) ^= 0xFFFFFFFF;\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_FLIP32]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_FLIP32] += stage_max;\n\nskip_bitflip:\n\n  if (no_arith) goto skip_arith;\n\n  /**********************\n   * ARITHMETIC INC/DEC *\n   **********************/\n\n  /* 8-bit arithmetics. */\n\n  stage_name  = \"arith 8\\\\8\";\n  stage_short = \"arith8\";\n  stage_cur   = 0;\n  stage_max   = 2 * len * ARITH_MAX;\n\n  stage_val_type = STAGE_VAL_LE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len; i++) {\n\n    u8 orig = out_buf[i];\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)]) {\n      stage_max -= 2 * ARITH_MAX;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 1; j <= ARITH_MAX; j++) {\n\n      u8 r = orig ^ (orig + j);\n\n      /* Do arithmetic operations only if the result couldn't be a product\n         of a bitflip. */\n\n      if (!could_be_bitflip(r)) {\n\n        stage_cur_val = j;\n        out_buf[i] = orig + j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      r =  orig ^ (orig - j);\n\n      if (!could_be_bitflip(r)) {\n\n        stage_cur_val = -j;\n        out_buf[i] = orig - j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      out_buf[i] = orig;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_ARITH8]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_ARITH8] += stage_max;\n\n  /* 16-bit arithmetics, both endians. */\n\n  if (len < 2) goto skip_arith;\n\n  stage_name  = \"arith 16\\\\8\";\n  stage_short = \"arith16\";\n  stage_cur   = 0;\n  stage_max   = 4 * (len - 1) * ARITH_MAX;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 1; i++) {\n\n    u16 orig = *(u16*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {\n      stage_max -= 4 * ARITH_MAX;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 1; j <= ARITH_MAX; j++) {\n\n      u16 r1 = orig ^ (orig + j),\n          r2 = orig ^ (orig - j),\n          r3 = orig ^ SWAP16(SWAP16(orig) + j),\n          r4 = orig ^ SWAP16(SWAP16(orig) - j);\n\n      /* Try little endian addition and subtraction first. Do it only\n         if the operation would affect more than one byte (hence the \n         & 0xff overflow checks) and if it couldn't be a product of\n         a bitflip. */\n\n      stage_val_type = STAGE_VAL_LE; \n\n      if ((orig & 0xff) + j > 0xff && !could_be_bitflip(r1)) {\n\n        stage_cur_val = j;\n        *(u16*)(out_buf + i) = orig + j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n \n      } else stage_max--;\n\n      if ((orig & 0xff) < j && !could_be_bitflip(r2)) {\n\n        stage_cur_val = -j;\n        *(u16*)(out_buf + i) = orig - j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      /* Big endian comes next. Same deal. */\n\n      stage_val_type = STAGE_VAL_BE;\n\n\n      if ((orig >> 8) + j > 0xff && !could_be_bitflip(r3)) {\n\n        stage_cur_val = j;\n        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) + j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((orig >> 8) < j && !could_be_bitflip(r4)) {\n\n        stage_cur_val = -j;\n        *(u16*)(out_buf + i) = SWAP16(SWAP16(orig) - j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      *(u16*)(out_buf + i) = orig;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_ARITH16]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_ARITH16] += stage_max;\n\n  /* 32-bit arithmetics, both endians. */\n\n  if (len < 4) goto skip_arith;\n\n  stage_name  = \"arith 32\\\\8\";\n  stage_short = \"arith32\";\n  stage_cur   = 0;\n  stage_max   = 4 * (len - 3) * ARITH_MAX;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 3; i++) {\n\n    u32 orig = *(u32*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&\n        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {\n      stage_max -= 4 * ARITH_MAX;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 1; j <= ARITH_MAX; j++) {\n\n      u32 r1 = orig ^ (orig + j),\n          r2 = orig ^ (orig - j),\n          r3 = orig ^ SWAP32(SWAP32(orig) + j),\n          r4 = orig ^ SWAP32(SWAP32(orig) - j);\n\n      /* Little endian first. Same deal as with 16-bit: we only want to\n         try if the operation would have effect on more than two bytes. */\n\n      stage_val_type = STAGE_VAL_LE; \n\n      if ((orig & 0xffff) + j > 0xffff && !could_be_bitflip(r1)) {\n\n        stage_cur_val = j;\n        *(u32*)(out_buf + i) = orig + j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((orig & 0xffff) < j && !could_be_bitflip(r2)) {\n\n        stage_cur_val = -j;\n        *(u32*)(out_buf + i) = orig - j;\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      /* Big endian next. */\n\n      stage_val_type = STAGE_VAL_BE;\n\n      if ((SWAP32(orig) & 0xffff) + j > 0xffff && !could_be_bitflip(r3)) {\n\n        stage_cur_val = j;\n        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) + j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((SWAP32(orig) & 0xffff) < j && !could_be_bitflip(r4)) {\n\n        stage_cur_val = -j;\n        *(u32*)(out_buf + i) = SWAP32(SWAP32(orig) - j);\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      *(u32*)(out_buf + i) = orig;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_ARITH32]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_ARITH32] += stage_max;\n\nskip_arith:\n\n  /**********************\n   * INTERESTING VALUES *\n   **********************/\n\n  stage_name  = \"interest 8\\\\8\";\n  stage_short = \"int8\";\n  stage_cur   = 0;\n  stage_max   = len * sizeof(interesting_8);\n\n  stage_val_type = STAGE_VAL_LE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  /* Setting 8-bit integers. */\n\n  for (i = 0; i < len; i++) {\n\n    u8 orig = out_buf[i];\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)]) {\n      stage_max -= sizeof(interesting_8);\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < sizeof(interesting_8); j++) {\n\n      /* Skip if the value could be a product of bitflips or arithmetics. */\n\n      if (could_be_bitflip(orig ^ (u8)interesting_8[j]) ||\n          could_be_arith(orig, (u8)interesting_8[j], 1)) {\n        stage_max--;\n        continue;\n      }\n\n      stage_cur_val = interesting_8[j];\n      out_buf[i] = interesting_8[j];\n\n      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n      out_buf[i] = orig;\n      stage_cur++;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_INTEREST8]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_INTEREST8] += stage_max;\n\n  /* Setting 16-bit integers, both endians. */\n\n  if (no_arith || len < 2) goto skip_interest;\n\n  stage_name  = \"interest 16\\\\8\";\n  stage_short = \"int16\";\n  stage_cur   = 0;\n  stage_max   = 2 * (len - 1) * (sizeof(interesting_16) >> 1);\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 1; i++) {\n\n    u16 orig = *(u16*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)]) {\n      stage_max -= sizeof(interesting_16);\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < sizeof(interesting_16) / 2; j++) {\n\n      stage_cur_val = interesting_16[j];\n\n      /* Skip if this could be a product of a bitflip, arithmetics,\n         or single-byte interesting value insertion. */\n\n      if (!could_be_bitflip(orig ^ (u16)interesting_16[j]) &&\n          !could_be_arith(orig, (u16)interesting_16[j], 2) &&\n          !could_be_interest(orig, (u16)interesting_16[j], 2, 0)) {\n\n        stage_val_type = STAGE_VAL_LE;\n\n        *(u16*)(out_buf + i) = interesting_16[j];\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((u16)interesting_16[j] != SWAP16(interesting_16[j]) &&\n          !could_be_bitflip(orig ^ SWAP16(interesting_16[j])) &&\n          !could_be_arith(orig, SWAP16(interesting_16[j]), 2) &&\n          !could_be_interest(orig, SWAP16(interesting_16[j]), 2, 1)) {\n\n        stage_val_type = STAGE_VAL_BE;\n\n        *(u16*)(out_buf + i) = SWAP16(interesting_16[j]);\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n    }\n\n    *(u16*)(out_buf + i) = orig;\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_INTEREST16]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_INTEREST16] += stage_max;\n\n  if (len < 4) goto skip_interest;\n\n  /* Setting 32-bit integers, both endians. */\n\n  stage_name  = \"interest 32\\\\8\";\n  stage_short = \"int32\";\n  stage_cur   = 0;\n  stage_max   = 2 * (len - 3) * (sizeof(interesting_32) >> 2);\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len - 3; i++) {\n\n    u32 orig = *(u32*)(out_buf + i);\n\n    /* Let's consult the effector map... */\n\n    if (!eff_map[EFF_APOS(i)] && !eff_map[EFF_APOS(i + 1)] &&\n        !eff_map[EFF_APOS(i + 2)] && !eff_map[EFF_APOS(i + 3)]) {\n      stage_max -= sizeof(interesting_32) >> 1;\n      continue;\n    }\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < sizeof(interesting_32) / 4; j++) {\n\n      stage_cur_val = interesting_32[j];\n\n      /* Skip if this could be a product of a bitflip, arithmetics,\n         or word interesting value insertion. */\n\n      if (!could_be_bitflip(orig ^ (u32)interesting_32[j]) &&\n          !could_be_arith(orig, interesting_32[j], 4) &&\n          !could_be_interest(orig, interesting_32[j], 4, 0)) {\n\n        stage_val_type = STAGE_VAL_LE;\n\n        *(u32*)(out_buf + i) = interesting_32[j];\n\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n      if ((u32)interesting_32[j] != SWAP32(interesting_32[j]) &&\n          !could_be_bitflip(orig ^ SWAP32(interesting_32[j])) &&\n          !could_be_arith(orig, SWAP32(interesting_32[j]), 4) &&\n          !could_be_interest(orig, SWAP32(interesting_32[j]), 4, 1)) {\n\n        stage_val_type = STAGE_VAL_BE;\n\n        *(u32*)(out_buf + i) = SWAP32(interesting_32[j]);\n        if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n        stage_cur++;\n\n      } else stage_max--;\n\n    }\n\n    *(u32*)(out_buf + i) = orig;\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_INTEREST32]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_INTEREST32] += stage_max;\n\nskip_interest:\n\n  /********************\n   * DICTIONARY STUFF *\n   ********************/\n\n  if (!extras_cnt) goto skip_user_extras;\n\n  /* Overwrite with user-supplied extras. */\n\n  stage_name  = \"user extras (over)\";\n  stage_short = \"ext_UO\";\n  stage_cur   = 0;\n  stage_max   = extras_cnt * len;\n\n  stage_val_type = STAGE_VAL_NONE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len; i++) {\n\n    u32 last_len = 0;\n\n    stage_cur_byte = i;\n\n    /* Extras are sorted by size, from smallest to largest. This means\n       that we don't have to worry about restoring the buffer in\n       between writes at a particular offset determined by the outer\n       loop. */\n\n    for (j = 0; j < extras_cnt; j++) {\n\n      /* Skip extras probabilistically if extras_cnt > MAX_DET_EXTRAS. Also\n         skip them if there's no room to insert the payload, if the token\n         is redundant, or if its entire span has no bytes set in the effector\n         map. */\n\n      if ((extras_cnt > MAX_DET_EXTRAS && UR(extras_cnt) >= MAX_DET_EXTRAS) ||\n          extras[j].len > len - i ||\n          !memcmp(extras[j].data, out_buf + i, extras[j].len) ||\n          !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, extras[j].len))) {\n\n        stage_max--;\n        continue;\n\n      }\n\n      last_len = extras[j].len;\n      memcpy(out_buf + i, extras[j].data, last_len);\n\n      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n      stage_cur++;\n\n    }\n\n    /* Restore all the clobbered memory. */\n    memcpy(out_buf + i, in_buf + i, last_len);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_EXTRAS_UO]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_EXTRAS_UO] += stage_max;\n\n  /* Insertion of user-supplied extras. */\n\n  stage_name  = \"user extras (insert)\";\n  stage_short = \"ext_UI\";\n  stage_cur   = 0;\n  stage_max   = extras_cnt * (len + 1);\n\n  orig_hit_cnt = new_hit_cnt;\n\n  ex_tmp = ck_alloc(len + MAX_DICT_FILE);\n\n  for (i = 0; i <= len; i++) {\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < extras_cnt; j++) {\n\n      if (len + extras[j].len > MAX_FILE) {\n        stage_max--;\n        continue;\n      }\n\n      /* Insert token */\n      memcpy(ex_tmp + i, extras[j].data, extras[j].len);\n\n      /* Copy tail */\n      memcpy(ex_tmp + i + extras[j].len, out_buf + i, len - i);\n\n      if (common_fuzz_stuff(argv, ex_tmp, len + extras[j].len)) {\n        ck_free(ex_tmp);\n        goto abandon_entry;\n      }\n\n      stage_cur++;\n\n    }\n\n    /* Copy head */\n    ex_tmp[i] = out_buf[i];\n\n  }\n\n  ck_free(ex_tmp);\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_EXTRAS_UI]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_EXTRAS_UI] += stage_max;\n\nskip_user_extras:\n\n  if (!a_extras_cnt) goto skip_extras;\n\n  stage_name  = \"auto extras (over)\";\n  stage_short = \"ext_AO\";\n  stage_cur   = 0;\n  stage_max   = MIN(a_extras_cnt, USE_AUTO_EXTRAS) * len;\n\n  stage_val_type = STAGE_VAL_NONE;\n\n  orig_hit_cnt = new_hit_cnt;\n\n  for (i = 0; i < len; i++) {\n\n    u32 last_len = 0;\n\n    stage_cur_byte = i;\n\n    for (j = 0; j < MIN(a_extras_cnt, USE_AUTO_EXTRAS); j++) {\n\n      /* See the comment in the earlier code; extras are sorted by size. */\n\n      if (a_extras[j].len > len - i ||\n          !memcmp(a_extras[j].data, out_buf + i, a_extras[j].len) ||\n          !memchr(eff_map + EFF_APOS(i), 1, EFF_SPAN_ALEN(i, a_extras[j].len))) {\n\n        stage_max--;\n        continue;\n\n      }\n\n      last_len = a_extras[j].len;\n      memcpy(out_buf + i, a_extras[j].data, last_len);\n\n      if (common_fuzz_stuff(argv, out_buf, len)) goto abandon_entry;\n\n      stage_cur++;\n\n    }\n\n    /* Restore all the clobbered memory. */\n    memcpy(out_buf + i, in_buf + i, last_len);\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  stage_finds[STAGE_EXTRAS_AO]  += new_hit_cnt - orig_hit_cnt;\n  stage_cycles[STAGE_EXTRAS_AO] += stage_max;\n\nskip_extras:\n\n  /* If we made this to here without jumping to havoc_stage or abandon_entry,\n     we're properly done with deterministic steps and can mark it as such\n     in the .state/ directory. */\n\n  if (!queue_cur->passed_det) mark_as_det_done(queue_cur);\n\n  /****************\n   * RANDOM HAVOC *\n   ****************/\n\nhavoc_stage:\n\n  stage_cur_byte = -1;\n\n  /* The havoc stage mutation code is also invoked when splicing files; if the\n     splice_cycle variable is set, generate different descriptions and such. */\n\n  if (!splice_cycle) {\n\n    stage_name  = \"havoc\";\n    stage_short = \"havoc\";\n    stage_max = (doing_det ? HAVOC_CYCLES_INIT : HAVOC_CYCLES) *\n                 perf_score / havoc_div / 100;\n  } else {\n\n    static u8 tmp[32];\n\n    perf_score = orig_perf;\n\n    sprintf(tmp, \"splice %u\", splice_cycle);\n    stage_name  = tmp;\n    stage_short = \"splice\";\n    stage_max   = SPLICE_HAVOC * perf_score / havoc_div / 100;\n\n  }\n\n  if (stage_max < HAVOC_MIN) stage_max = HAVOC_MIN;\n\n  temp_len = len;\n\n  orig_hit_cnt = queued_paths + unique_crashes;\n\n  havoc_queued = queued_paths;\n\n  /* We essentially just do several thousand runs (depending on perf_score)\n     where we take the input file and make random stacked tweaks. */\n\n  for (stage_cur = 0; stage_cur < stage_max; stage_cur++) {\n\n    u32 use_stacking = 1 << (1 + UR(HAVOC_STACK_POW2));\n\n    stage_cur_val = use_stacking;\n \n    for (i = 0; i < use_stacking; i++) {\n\n      switch (UR(15 + ((extras_cnt + a_extras_cnt) ? 2 : 0))) {\n\n        case 0:\n\n          /* Flip a single bit somewhere. Spooky! */\n\n          FLIP_BIT(out_buf, UR(temp_len << 3));\n          break;\n\n        case 1: \n\n          /* Set byte to interesting value. */\n\n          out_buf[UR(temp_len)] = interesting_8[UR(sizeof(interesting_8))];\n          break;\n\n        case 2:\n\n          /* Set word to interesting value, randomly choosing endian. */\n\n          if (temp_len < 2) break;\n\n          if (UR(2)) {\n\n            *(u16*)(out_buf + UR(temp_len - 1)) =\n              interesting_16[UR(sizeof(interesting_16) >> 1)];\n\n          } else {\n\n            *(u16*)(out_buf + UR(temp_len - 1)) = SWAP16(\n              interesting_16[UR(sizeof(interesting_16) >> 1)]);\n\n          }\n\n          break;\n\n        case 3:\n\n          /* Set dword to interesting value, randomly choosing endian. */\n\n          if (temp_len < 4) break;\n\n          if (UR(2)) {\n  \n            *(u32*)(out_buf + UR(temp_len - 3)) =\n              interesting_32[UR(sizeof(interesting_32) >> 2)];\n\n          } else {\n\n            *(u32*)(out_buf + UR(temp_len - 3)) = SWAP32(\n              interesting_32[UR(sizeof(interesting_32) >> 2)]);\n\n          }\n\n          break;\n\n        case 4:\n\n          /* Randomly subtract from byte. */\n\n          out_buf[UR(temp_len)] -= 1 + UR(ARITH_MAX);\n          break;\n\n        case 5:\n\n          /* Randomly add to byte. */\n\n          out_buf[UR(temp_len)] += 1 + UR(ARITH_MAX);\n          break;\n\n        case 6:\n\n          /* Randomly subtract from word, random endian. */\n\n          if (temp_len < 2) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 1);\n\n            *(u16*)(out_buf + pos) -= 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 1);\n            u16 num = 1 + UR(ARITH_MAX);\n\n            *(u16*)(out_buf + pos) =\n              SWAP16(SWAP16(*(u16*)(out_buf + pos)) - num);\n\n          }\n\n          break;\n\n        case 7:\n\n          /* Randomly add to word, random endian. */\n\n          if (temp_len < 2) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 1);\n\n            *(u16*)(out_buf + pos) += 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 1);\n            u16 num = 1 + UR(ARITH_MAX);\n\n            *(u16*)(out_buf + pos) =\n              SWAP16(SWAP16(*(u16*)(out_buf + pos)) + num);\n\n          }\n\n          break;\n\n        case 8:\n\n          /* Randomly subtract from dword, random endian. */\n\n          if (temp_len < 4) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 3);\n\n            *(u32*)(out_buf + pos) -= 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 3);\n            u32 num = 1 + UR(ARITH_MAX);\n\n            *(u32*)(out_buf + pos) =\n              SWAP32(SWAP32(*(u32*)(out_buf + pos)) - num);\n\n          }\n\n          break;\n\n        case 9:\n\n          /* Randomly add to dword, random endian. */\n\n          if (temp_len < 4) break;\n\n          if (UR(2)) {\n\n            u32 pos = UR(temp_len - 3);\n\n            *(u32*)(out_buf + pos) += 1 + UR(ARITH_MAX);\n\n          } else {\n\n            u32 pos = UR(temp_len - 3);\n            u32 num = 1 + UR(ARITH_MAX);\n\n            *(u32*)(out_buf + pos) =\n              SWAP32(SWAP32(*(u32*)(out_buf + pos)) + num);\n\n          }\n\n          break;\n\n        case 10:\n\n          /* Just set a random byte to a random value. Because,\n             why not. We use XOR with 1-255 to eliminate the\n             possibility of a no-op. */\n\n          out_buf[UR(temp_len)] ^= 1 + UR(255);\n          break;\n\n\t\tcase 11:\n\t\tcase 12:\n\n\t\t  {\n\n            /* Delete bytes. We're making this a bit more likely\n               than insertion (the next option) in hopes of keeping\n               files reasonably small. */\n\n            u32 del_from, del_len;\n\n            if (temp_len < 2) break;\n\n            /* Don't delete too much. */\n\n            del_len = choose_block_len(temp_len - 1);\n\n            del_from = UR(temp_len - del_len + 1);\n\n            memmove(out_buf + del_from, out_buf + del_from + del_len,\n                    temp_len - del_from - del_len);\n\n            temp_len -= del_len;\n\n            break;\n\n          }\n\n        case 13:\n\n          if (temp_len + HAVOC_BLK_XL < MAX_FILE) {\n\n            /* Clone bytes (75%) or insert a block of constant bytes (25%). */\n\n            u8  actually_clone = UR(4);\n            u32 clone_from, clone_to, clone_len;\n            u8* new_buf;\n\n            if (actually_clone) {\n\n              clone_len  = choose_block_len(temp_len);\n              clone_from = UR(temp_len - clone_len + 1);\n\n            } else {\n\n              clone_len = choose_block_len(HAVOC_BLK_XL);\n              clone_from = 0;\n\n            }\n\n            clone_to   = UR(temp_len);\n\n            new_buf = ck_alloc_nozero(temp_len + clone_len);\n\n            /* Head */\n\n            memcpy(new_buf, out_buf, clone_to);\n\n            /* Inserted part */\n\n            if (actually_clone)\n              memcpy(new_buf + clone_to, out_buf + clone_from, clone_len);\n            else\n              memset(new_buf + clone_to,\n                     UR(2) ? UR(256) : out_buf[UR(temp_len)], clone_len);\n\n            /* Tail */\n            memcpy(new_buf + clone_to + clone_len, out_buf + clone_to,\n                   temp_len - clone_to);\n\n            ck_free(out_buf);\n            out_buf = new_buf;\n            temp_len += clone_len;\n\n          }\n\n          break;\n\n        case 14: {\n\n            /* Overwrite bytes with a randomly selected chunk (75%) or fixed\n               bytes (25%). */\n\n            u32 copy_from, copy_to, copy_len;\n\n            if (temp_len < 2) break;\n\n            copy_len  = choose_block_len(temp_len - 1);\n\n            copy_from = UR(temp_len - copy_len + 1);\n            copy_to   = UR(temp_len - copy_len + 1);\n\n            if (UR(4)) {\n\n              if (copy_from != copy_to)\n                memmove(out_buf + copy_to, out_buf + copy_from, copy_len);\n\n            } else memset(out_buf + copy_to,\n                          UR(2) ? UR(256) : out_buf[UR(temp_len)], copy_len);\n\n            break;\n\n          }\n\n        /* Values 15 and 16 can be selected only if there are any extras\n           present in the dictionaries. */\n\n        case 15: {\n\n            /* Overwrite bytes with an extra. */\n\n            if (!extras_cnt || (a_extras_cnt && UR(2))) {\n\n              /* No user-specified extras or odds in our favor. Let's use an\n                 auto-detected one. */\n\n              u32 use_extra = UR(a_extras_cnt);\n              u32 extra_len = a_extras[use_extra].len;\n              u32 insert_at;\n\n              if (extra_len > temp_len) break;\n\n              insert_at = UR(temp_len - extra_len + 1);\n              memcpy(out_buf + insert_at, a_extras[use_extra].data, extra_len);\n\n            } else {\n\n              /* No auto extras or odds in our favor. Use the dictionary. */\n\n              u32 use_extra = UR(extras_cnt);\n              u32 extra_len = extras[use_extra].len;\n              u32 insert_at;\n\n              if (extra_len > temp_len) break;\n\n              insert_at = UR(temp_len - extra_len + 1);\n              memcpy(out_buf + insert_at, extras[use_extra].data, extra_len);\n\n            }\n\n            break;\n\n          }\n\n        case 16: {\n\n            u32 use_extra, extra_len, insert_at = UR(temp_len + 1);\n            u8* new_buf;\n\n            /* Insert an extra. Do the same dice-rolling stuff as for the\n               previous case. */\n\n            if (!extras_cnt || (a_extras_cnt && UR(2))) {\n\n              use_extra = UR(a_extras_cnt);\n              extra_len = a_extras[use_extra].len;\n\n              if (temp_len + extra_len >= MAX_FILE) break;\n\n              new_buf = ck_alloc_nozero(temp_len + extra_len);\n\n              /* Head */\n              memcpy(new_buf, out_buf, insert_at);\n\n              /* Inserted part */\n              memcpy(new_buf + insert_at, a_extras[use_extra].data, extra_len);\n\n            } else {\n\n              use_extra = UR(extras_cnt);\n              extra_len = extras[use_extra].len;\n\n              if (temp_len + extra_len >= MAX_FILE) break;\n\n              new_buf = ck_alloc_nozero(temp_len + extra_len);\n\n              /* Head */\n              memcpy(new_buf, out_buf, insert_at);\n\n              /* Inserted part */\n              memcpy(new_buf + insert_at, extras[use_extra].data, extra_len);\n\n            }\n\n            /* Tail */\n            memcpy(new_buf + insert_at + extra_len, out_buf + insert_at,\n                   temp_len - insert_at);\n\n            ck_free(out_buf);\n            out_buf   = new_buf;\n            temp_len += extra_len;\n\n            break;\n\n          }\n\n      }\n\n    }\n\n    if (common_fuzz_stuff(argv, out_buf, temp_len))\n      goto abandon_entry;\n\n    /* out_buf might have been mangled a bit, so let's restore it to its\n       original size and shape. */\n\n    if (temp_len < len) out_buf = ck_realloc(out_buf, len);\n    temp_len = len;\n    memcpy(out_buf, in_buf, len);\n\n    /* If we're finding new stuff, let's run for a bit longer, limits\n       permitting. */\n\n    if (queued_paths != havoc_queued) {\n\n      if (perf_score <= HAVOC_MAX_MULT * 100) {\n        stage_max  *= 2;\n        perf_score *= 2;\n      }\n\n      havoc_queued = queued_paths;\n\n    }\n\n  }\n\n  new_hit_cnt = queued_paths + unique_crashes;\n\n  if (!splice_cycle) {\n    stage_finds[STAGE_HAVOC]  += new_hit_cnt - orig_hit_cnt;\n    stage_cycles[STAGE_HAVOC] += stage_max;\n  } else {\n    stage_finds[STAGE_SPLICE]  += new_hit_cnt - orig_hit_cnt;\n    stage_cycles[STAGE_SPLICE] += stage_max;\n  }\n\n#ifndef IGNORE_FINDS\n\n  /************\n   * SPLICING *\n   ************/\n\n  /* This is a last-resort strategy triggered by a full round with no findings.\n     It takes the current input file, randomly selects another input, and\n     splices them together at some offset, then relies on the havoc\n     code to mutate that blob. */\n\nretry_splicing:\n\n  if (use_splicing && splice_cycle++ < SPLICE_CYCLES &&\n      queued_paths > 1 && queue_cur->len > 1) {\n\n    struct queue_entry* target;\n    u32 tid, split_at;\n    u8* new_buf;\n    s32 f_diff, l_diff;\n\n    /* First of all, if we've modified in_buf for havoc, let's clean that\n       up... */\n\n    if (in_buf != orig_in) {\n      ck_free(in_buf);\n      in_buf = orig_in;\n      len = queue_cur->len;\n    }\n\n    /* Pick a random queue entry and seek to it. Don't splice with yourself. */\n\n    do { tid = UR(queued_paths); } while (tid == current_entry);\n\n    splicing_with = tid;\n    target = queue;\n\n    while (tid >= 100) { target = target->next_100; tid -= 100; }\n    while (tid--) target = target->next;\n\n    /* Make sure that the target has a reasonable length. */\n\n    while (target && (target->len < 2 || target == queue_cur)) {\n      target = target->next;\n      splicing_with++;\n    }\n\n    if (!target) goto retry_splicing;\n\n    /* Read the testcase into a new buffer. */\n\n    fd = open(target->fname, O_RDONLY | O_BINARY);\n\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", target->fname);\n\n    new_buf = ck_alloc_nozero(target->len);\n\n    ck_read(fd, new_buf, target->len, target->fname);\n\n    close(fd);\n\n    /* Find a suitable splicing location, somewhere between the first and\n       the last differing byte. Bail out if the difference is just a single\n       byte or so. */\n\n    locate_diffs(in_buf, new_buf, MIN(len, target->len), &f_diff, &l_diff);\n\n    if (f_diff < 0 || l_diff < 2 || f_diff == l_diff) {\n      ck_free(new_buf);\n      goto retry_splicing;\n    }\n\n    /* Split somewhere between the first and last differing byte. */\n\n    split_at = f_diff + UR(l_diff - f_diff);\n\n    /* Do the thing. */\n\n    len = target->len;\n    memcpy(new_buf, in_buf, split_at);\n    in_buf = new_buf;\n\n    ck_free(out_buf);\n    out_buf = ck_alloc_nozero(len);\n    memcpy(out_buf, in_buf, len);\n\n    goto havoc_stage;\n\n  }\n\n#endif /* !IGNORE_FINDS */\n\n  ret_val = 0;\n\nabandon_entry:\n\n  splicing_with = -1;\n\n  /* Update pending_not_fuzzed count if we made it through the calibration\n     cycle and have not seen this entry before. */\n\n  if (!stop_soon && !queue_cur->cal_failed && !queue_cur->was_fuzzed) {\n    queue_cur->was_fuzzed = 1;\n    pending_not_fuzzed--;\n    if (queue_cur->favored) pending_favored--;\n  }\n\n  if (in_buf != orig_in) ck_free(in_buf);\n  ck_free(orig_in);\n  ck_free(out_buf);\n  ck_free(eff_map);\n\n  return ret_val;\n\n#undef FLIP_BIT\n\n}\n\n\n/* Grab interesting test cases from other fuzzers. */\n\nstatic void sync_fuzzers(char** argv) {\n\n  WIN32_FIND_DATA sd;\n  HANDLE h;\n  char *find_pattern;\n\n  u32 sync_cnt = 0;\n\n  find_pattern = alloc_printf(\"%s\\\\*\", sync_dir);\n  h = FindFirstFile(find_pattern, &sd);\n  if(h == INVALID_HANDLE_VALUE) {\n    PFATAL(\"Unable to open '%s'\", sync_dir);\n  }\n\n  stage_max = stage_cur = 0;\n  cur_depth = 0;\n\n  /* Look at the entries created for every other fuzzer in the sync directory. */\n\n  do {\n\n    static u8 stage_tmp[128];\n\n\tWIN32_FIND_DATA qd;\n    HANDLE h2;\n    u8 *qd_path, *qd_synced_path, *qd_path_pattern;\n    u32 min_accept = 0, next_min_accept;\n\n    s32 id_fd;\n\n    /* Skip dot files and our own output directory. */\n\n\tif (sd.cFileName[0] == '.' || !strcmp(sync_id, sd.cFileName)) continue;\n\n    /* Skip anything that doesn't have a queue/ subdirectory. */\n\n\tqd_path = alloc_printf(\"%s\\\\%s\\\\queue\", sync_dir, sd.cFileName);\n\tqd_path_pattern = alloc_printf(\"%s\\\\*\", qd_path);\n\n\th2 = FindFirstFile(qd_path_pattern, &qd);\n\tif(h2 == INVALID_HANDLE_VALUE) {\n      ck_free(qd_path_pattern);\n      ck_free(qd_path);\n      continue;\n\t}\n\n    /* Retrieve the ID of the last seen test case. */\n\n\tqd_synced_path = alloc_printf(\"%s\\\\.synced\\\\%s\", out_dir, sd.cFileName);\n\n    id_fd = open(qd_synced_path, O_RDWR | O_BINARY | O_CREAT, DEFAULT_PERMISSION);\n\n    if (id_fd < 0) PFATAL(\"Unable to create '%s'\", qd_synced_path);\n\n    if (read(id_fd, &min_accept, sizeof(u32)) > 0) \n      lseek(id_fd, 0, SEEK_SET);\n\n    next_min_accept = min_accept;\n\n    /* Show stats */    \n\n    sprintf(stage_tmp, \"sync %u\", ++sync_cnt);\n    stage_name = stage_tmp;\n    stage_cur  = 0;\n    stage_max  = 0;\n\n    /* For every file queued by this fuzzer, parse ID and see if we have looked at\n       it before; exec a test case if not. */\n\n    do {\n\n      u8* path;\n      s32 fd;\n      struct stat st;\n\n      if (qd.cFileName[0] == '.' ||\n\t\t  sscanf(qd.cFileName, CASE_PREFIX \"%06u\", &syncing_case) != 1 || \n          syncing_case < min_accept) continue;\n\n      /* OK, sounds like a new one. Let's give it a try. */\n\n      if (syncing_case >= next_min_accept)\n        next_min_accept = syncing_case + 1;\n\n      path = alloc_printf(\"%s\\\\%s\", qd_path, qd.cFileName);\n\n      fd = open(path, O_RDONLY | O_BINARY);\n\n      /* Allow this to fail in case the other fuzzer is resuming or so... */\n\n      if (fd < 0) {\n         ck_free(path);\n         continue;\n      }\n \n      if (fstat(fd, &st)) PFATAL(\"fstat() failed\");\n\n      /* Ignore zero-sized or oversized files. */\n\n      if (st.st_size && st.st_size <= MAX_FILE) {\n\n        u8  fault;\n        u8* mem = malloc(st.st_size);\n        read(fd, mem, st.st_size);\n\t\t\t\n        /* See what happens. We rely on save_if_interesting() to catch major\n           errors and save the test case. */\n\n        write_to_testcase(mem, st.st_size);\n\n        fault = run_target(argv, exec_tmout);\n\n        if (stop_soon) return;\n\n        syncing_party = sd.cFileName;\n        queued_imported += save_if_interesting(argv, mem, st.st_size, fault);\n        syncing_party = 0;\n\n        free(mem);\n\n        if (!(stage_cur++ % stats_update_freq)) show_stats();\n\n      }\n\n      ck_free(path);\n      close(fd);\n\n    } while(FindNextFile(h2, &qd));\n\n    ck_write(id_fd, &next_min_accept, sizeof(u32), qd_synced_path);\n\n    close(id_fd);\n    FindClose(h2);\n    ck_free(qd_path);\n    ck_free(qd_synced_path);\n\tck_free(qd_path_pattern);\n    \n  } while(FindNextFile(h, &sd));\n\n  FindClose(h);\n  ck_free(find_pattern);\n\n}\n\n\n/* Handle stop signal (Ctrl-C, etc). */\n\n/*static void handle_stop_sig(int sig) {\n\n  stop_soon = 1; \n\n  if (child_pid > 0) kill(child_pid, SIGKILL);\n  if (forksrv_pid > 0) kill(forksrv_pid, SIGKILL);\n\n}*/\n\n\n/* Handle skip request (SIGUSR1). */\n\nstatic void handle_skipreq(int sig) {\n\n  skip_requested = 1;\n\n}\n\n/* Handle timeout (SIGALRM). */\n\n/*static void handle_timeout(int sig) {\n\n  if (child_pid > 0) {\n\n    child_timed_out = 1; \n    kill(child_pid, SIGKILL);\n\n  } else if (child_pid == -1 && forksrv_pid > 0) {\n\n    child_timed_out = 1; \n    kill(forksrv_pid, SIGKILL);\n\n  }\n\n}*/\n\n\n/* Do a PATH search and find target binary to see that it exists and\n   isn't a shell script - a common and painful mistake. We also check for\n   a valid ELF header and for evidence of AFL instrumentation. */\n\nstatic void check_binary(u8* fname) {\n\t//not implemented on Windows\n}\n\n\n/* Trim and possibly create a banner for the run. */\n\nstatic void fix_up_banner(u8* name) {\n\n  if (!use_banner) {\n\n    if (sync_id) {\n\n      use_banner = sync_id;\n\n    } else {\n\n      u8* trim = strrchr(name, '\\\\');\n      if (!trim) use_banner = name; else use_banner = trim + 1;\n\n    }\n\n  }\n\n  if (strlen(use_banner) > 40) {\n\n    u8* tmp = ck_alloc(44);\n    sprintf(tmp, \"%.40s...\", use_banner);\n    use_banner = tmp;\n\n  }\n\n}\n\n\n/* Check if we're on TTY. */\n\nstatic void check_if_tty(void) {\n#ifndef USE_COLOR\n  not_on_tty = 1;\n#endif\n}\n\n\n/* Check terminal dimensions after resize. */\n\nstatic void check_term_size(void) {\n  //not implemented on Windows\n}\n\n\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  SAYF(\"\\n%s [ afl options ] -- [instrumentation options] -- \"\n\t   \"\\\\path\\\\to\\\\fuzzed_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i dir        - input directory with test cases\\n\"\n       \"  -o dir        - output directory for fuzzer findings\\n\"\n       \"  -t msec       - timeout for each run\\n\\n\"\n\n       \"Instrumentation type:\\n\\n\"\n        \"  -D dir       - directory with DynamoRIO binaries (drrun, drconfig)\\n\"\n        \"  -w winafl    - Path to winafl.dll\\n\"\n        \"  -P           - use Intel PT tracing mode\\n\"\n        \"  -y           - use TinyInst tracing mode\\n\"\n        \"  -Y           - enable the static instrumentation mode\\n\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - location read by the fuzzed program (stdin)\\n\"\n       \"  -m limit      - memory limit for the target process\\n\"\n       \"  -p            - persist DynamoRIO cache across target process restarts\\n\"\n       \"  -c cpu        - the CPU to run the fuzzed program\\n\\n\"\n \n       \"Fuzzing behavior settings:\\n\\n\"\n\n       \"  -d            - quick & dirty mode (skips deterministic steps)\\n\"\n       \"  -n            - fuzz without instrumentation (dumb mode)\\n\"\n       \"  -x dir        - optional fuzzer dictionary (see README)\\n\\n\"\n\n       \"Other stuff:\\n\\n\"\n\n       \"  -I msec       - timeout for process initialization and first run\\n\"\n       \"  -T text       - text banner to show on the screen\\n\"\n       \"  -M \\\\ -S id   - distributed mode (see parallel_fuzzing.txt)\\n\"\n       \"  -C            - crash exploration mode (the peruvian rabbit thing)\\n\"\n       \"  -e            - expert mode to run WinAFL as a DynamoRIO tool\\n\"\n       \"  -l path       - a path to user-defined DLL for custom test cases processing\\n\"\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"Attach:\\n\\n\"\n       \"  -A module     - attach to the process that loaded the provided module\\n\\n\"\n\n       \"For additional tips, please consult %s\\\\README.\\n\\n\",\n\n       argv0, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Prepare output directories and fds. */\n\nstatic void setup_dirs_fds(void) {\n\n  u8* tmp;\n  s32 fd;\n\n  ACTF(\"Setting up output directories...\");\n\n  if (sync_id && mkdir(sync_dir) && errno != EEXIST)\n      PFATAL(\"Unable to create '%s'\", sync_dir);\n\n  if (mkdir(out_dir)) {\n\n    if (errno != EEXIST) PFATAL(\"Unable to create '%s'\", out_dir);\n\n    maybe_delete_out_dir();\n\n  } else {\n\n    if (in_place_resume)\n      FATAL(\"Resume attempted but old output directory not found\");\n\n    //out_dir_fd = open(out_dir, O_RDONLY | O_BINARY);\n\n  }\n\n  /* Queue directory for any starting & discovered paths. */\n\n  tmp = alloc_printf(\"%s\\\\queue\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Top-level directory for queue metadata used for session\n     resume and related tasks. */\n\n  tmp = alloc_printf(\"%s\\\\queue\\\\.state\\\\\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Directory for flagging queue entries that went through\n     deterministic fuzzing in the past. */\n\n  tmp = alloc_printf(\"%s\\\\queue\\\\.state\\\\deterministic_done\\\\\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Directory with the auto-selected dictionary entries. */\n\n  tmp = alloc_printf(\"%s\\\\queue\\\\.state\\\\auto_extras\\\\\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* The set of paths currently deemed redundant. */\n\n  tmp = alloc_printf(\"%s\\\\queue\\\\.state\\\\redundant_edges\\\\\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* The set of paths showing variable behavior. */\n\n  tmp = alloc_printf(\"%s\\\\queue\\\\.state\\\\variable_behavior\\\\\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Sync directory for keeping track of cooperating fuzzers. */\n\n  if (sync_id) {\n\n    tmp = alloc_printf(\"%s\\\\.synced\\\\\", out_dir);\n    \n    if (mkdir(tmp) && (!in_place_resume || errno != EEXIST)) \n      PFATAL(\"Unable to create '%s'\", tmp);\n\n    ck_free(tmp);\n\n  }\n\n  /* All recorded crashes. */\n\n  tmp = alloc_printf(\"%s\\\\crashes\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* All recorded hangs. */\n\n  tmp = alloc_printf(\"%s\\\\hangs\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  /* Generally useful file descriptors. */\n\n  //dev_null_fd = open(\"\\\\dev\\\\null\", O_RDWR | O_BINARY);\n  //if (dev_null_fd < 0) PFATAL(\"Unable to open \\\\dev\\\\null\");\n\n  //dev_urandom_fd = open(\"\\\\dev\\\\urandom\", O_RDONLY | O_BINARY);\n  //if (dev_urandom_fd < 0) PFATAL(\"Unable to open \\\\dev\\\\urandom\");\n\n  /* Gnuplot output file. */\n\n  int oflag = O_WRONLY | O_BINARY | O_CREAT;\n  tmp = alloc_printf(\"%s\\\\plot_data\", out_dir);\n\n  if(!in_place_resume) {\n\n    fd = _open(tmp, oflag | O_EXCL, DEFAULT_PERMISSION);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", tmp);\n    ck_free(tmp);\n\n    plot_file = fdopen(fd, \"w\");\n    if (!plot_file) PFATAL(\"fdopen() failed\");\n\n    fprintf(plot_file, \"# relative_time, cycles_done, cur_path, paths_total, \"\n                     \"pending_total, pending_favs, map_size, unique_crashes, \"\n                     \"unique_hangs, max_depth, execs_per_sec\\n\");\n                     /* ignore errors */\n  } else {\n\n    fd = _open(tmp, oflag, DEFAULT_PERMISSION);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", tmp);\n    ck_free(tmp);\n\n    plot_file = fdopen(fd, \"w\");\n    if (!plot_file) PFATAL(\"fdopen() failed\");\n\n    fseek(plot_file, 0, SEEK_END);\n\n  }\n\n  fflush(plot_file);\n\n  tmp = alloc_printf(\"%s\\\\drcache\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n  tmp = alloc_printf(\"%s\\\\ptmodules\", out_dir);\n  if (mkdir(tmp)) PFATAL(\"Unable to create '%s'\", tmp);\n  ck_free(tmp);\n\n}\n\n\n/* Setup the output file for fuzzed data, if not using -f. */\n\nstatic void setup_stdio_file(void) {\n\n  if (use_sample_shared_memory) {\n    // if using shared memory we dont need to set any file.so we just return.\n    return;\n  }\n  \n  u8* fn = alloc_printf(\"%s\\\\.cur_input\", out_dir);\n\n  out_fd = open(fn, O_RDWR | O_BINARY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n\n  if (out_fd < 0) PFATAL(\"Unable to create '%s'\", fn);\n\n  ck_free(fn);\n\n}\n\n\n/* Make sure that core dumps don't go to a program. */\n\nstatic void check_crash_handling(void) {\n\n#ifdef __APPLE__\n\n  /* Yuck! There appears to be no simple C API to query for the state of \n     loaded daemons on MacOS X, and I'm a bit hesitant to do something\n     more sophisticated, such as disabling crash reporting via Mach ports,\n     until I get a box to test the code. So, for now, we check for crash\n     reporting the awful way. */\n  \n  if (system(\"launchctl list 2>\\\\dev\\\\null | grep -q '\\\\.ReportCrash$'\")) return;\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Whoops, your system is configured to forward crash notifications to an\\n\"\n       \"    external crash reporting utility. This will cause issues due to the\\n\"\n       \"    extended delay between the fuzzed binary malfunctioning and this fact\\n\"\n       \"    being relayed to the fuzzer via the standard waitpid() API.\\n\\n\"\n       \"    To avoid having crashes misinterpreted as timeouts, please run the\\n\"\n       \"    following commands:\\n\\n\"\n\n       \"    SL=\\\\System\\\\Library; PL=com.apple.ReportCrash\\n\"\n       \"    launchctl unload -w ${SL}\\\\LaunchAgents\\\\${PL}.plist\\n\"\n       \"    sudo launchctl unload -w ${SL}\\\\LaunchDaemons\\\\${PL}.Root.plist\\n\");\n\n  if (!getenv(\"AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES\"))\n    FATAL(\"Crash reporter detected\");\n\n#else\n\n  /* This is Linux specific, but I don't think there's anything equivalent on\n     *BSD, so we can just let it slide for now. */\n\n  s32 fd = open(\"\\\\proc\\\\sys\\\\kernel\\\\core_pattern\", O_RDONLY | O_BINARY);\n  u8  fchar;\n\n  if (fd < 0) return;\n\n  ACTF(\"Checking core_pattern...\");\n\n  if (read(fd, &fchar, 1) == 1 && fchar == '|') {\n\n    SAYF(\"\\n\" cLRD \"[-] \" cRST\n         \"Hmm, your system is configured to send core dump notifications to an\\n\"\n         \"    external utility. This will cause issues due to an extended delay\\n\"\n         \"    between the fuzzed binary malfunctioning and this information being\\n\"\n         \"    eventually relayed to the fuzzer via the standard waitpid() API.\\n\\n\"\n\n         \"    To avoid having crashes misinterpreted as timeouts, please log in as root\\n\"\n         \"    and temporarily modify \\\\proc\\\\sys\\\\kernel\\\\core_pattern, like so:\\n\\n\"\n\n         \"    echo core >\\\\proc\\\\sys\\\\kernel\\\\core_pattern\\n\");\n\n    if (!getenv(\"AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES\"))\n      FATAL(\"Pipe at the beginning of 'core_pattern'\");\n\n  }\n \n  close(fd);\n\n#endif /* ^__APPLE__ */\n\n}\n\n\n/* Check CPU governor. */\n\nstatic void check_cpu_governor(void) {\n\n  FILE* f;\n  u8 tmp[128];\n  u64 min = 0, max = 0;\n\n  if (getenv(\"AFL_SKIP_CPUFREQ\")) return;\n\n  f = fopen(\"\\\\sys\\\\devices\\\\system\\\\cpu\\\\cpu0\\\\cpufreq\\\\scaling_governor\", \"r\");\n  if (!f) return;\n\n  ACTF(\"Checking CPU scaling governor...\");\n\n  if (!fgets(tmp, 128, f)) PFATAL(\"fgets() failed\");\n\n  fclose(f);\n\n  if (!strncmp(tmp, \"perf\", 4)) return;\n\n  f = fopen(\"\\\\sys\\\\devices\\\\system\\\\cpu\\\\cpu0\\\\cpufreq\\\\scaling_min_freq\", \"r\");\n\n  if (f) {\n    if (fscanf(f, \"%llu\", &min) != 1) min = 0;\n    fclose(f);\n  }\n\n  f = fopen(\"\\\\sys\\\\devices\\\\system\\\\cpu\\\\cpu0\\\\cpufreq\\\\scaling_max_freq\", \"r\");\n\n  if (f) {\n    if (fscanf(f, \"%llu\", &max) != 1) max = 0;\n    fclose(f);\n  }\n\n  if (min == max) return;\n\n  SAYF(\"\\n\" cLRD \"[-] \" cRST\n       \"Whoops, your system uses on-demand CPU frequency scaling, adjusted\\n\"\n       \"    between %llu and %llu MHz. Unfortunately, the scaling algorithm in the\\n\"\n       \"    kernel is imperfect and can miss the short-lived processes spawned by\\n\"\n       \"    afl-fuzz. To keep things moving, run these commands as root:\\n\\n\"\n\n       \"    cd \\\\sys\\\\devices\\\\system\\\\cpu\\n\"\n       \"    echo performance | tee cpu*\\\\cpufreq\\\\scaling_governor\\n\\n\"\n\n       \"    You can later go back to the original state by replacing 'performance' with\\n\"\n       \"    'ondemand'. If you don't want to change the settings, set AFL_SKIP_CPUFREQ\\n\"\n       \"    to make afl-fuzz skip this check - but expect some performance drop.\\n\",\n       min / 1024, max / 1024);\n\n  FATAL(\"Suboptimal CPU scaling governor\");\n\n}\n\n\n/* Count the number of logical CPU cores. */\n\nstatic void get_core_count(void) {\n\n  u32 cur_utilization = 0;\n  SYSTEM_INFO sys_info = { 0 };\n  GetSystemInfo(&sys_info);\n  cpu_core_count = sys_info.dwNumberOfProcessors;\n\n  if (cpu_core_count) {\n\tPdhOpenQuery(NULL, (DWORD_PTR)NULL, &cpuQuery);\n\tPdhAddCounter(cpuQuery, TEXT(\"\\\\Processor(_Total)\\\\% Processor Time\"), (DWORD_PTR)NULL, &cpuTotal);\n\tPdhCollectQueryData(cpuQuery);\n\tSleep(1000);\n\n\tcur_utilization = (u32)get_cur_utilization();\n\n\tOKF(\"You have %u CPU cores with average utilization of %.1u%%.\",\n\t  cpu_core_count, cur_utilization);\n\n    if (cpu_core_count > 1) {\n\n      if (cur_utilization >= 90) {\n\n        WARNF(\"System under apparent load, performance may be spotty.\");\n\n      } else {\n\n        OKF(\"Try parallel jobs - see %s\\\\parallel_fuzzing.txt.\", doc_path);\n  \n      }\n\n    }\n\n  } else WARNF(\"Unable to figure out the number of CPU cores.\");\n\n}\n\n\n/* Validate and fix up out_dir and sync_dir when using -S. */\n\nstatic void fix_up_sync(void) {\n\n  u8* x = sync_id;\n\n  if (dumb_mode)\n    FATAL(\"-S \\\\ -M and -n are mutually exclusive\");\n\n  if (skip_deterministic) {\n\n    if (force_deterministic)\n      FATAL(\"use -S instead of -M -d\");\n    else\n      FATAL(\"-S already implies -d\");\n\n  }\n\n  while (*x) {\n\n    if (!isalnum(*x) && *x != '_' && *x != '-')\n      FATAL(\"Non-alphanumeric fuzzer ID specified via -S or -M\");\n\n    x++;\n\n  }\n\n  if (strlen(sync_id) > 32) FATAL(\"Fuzzer ID too long\");\n\n  x = alloc_printf(\"%s\\\\%s\", out_dir, sync_id);\n\n  sync_dir = out_dir;\n  out_dir  = x;\n\n  if (!force_deterministic) {\n    skip_deterministic = 1;\n    use_splicing = 1;\n  }\n\n}\n\n\n/* Handle screen resize (SIGWINCH). */\n\nstatic void handle_resize(int sig) {\n  clear_screen = 1;\n}\n\n\n/* Check ASAN options. */\n\nstatic void check_asan_opts(void) {\n  u8* x = getenv(\"ASAN_OPTIONS\");\n\n  if (x && !strstr(x, \"abort_on_error=1\"))\n    FATAL(\"Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!\");\n\n  x = getenv(\"MSAN_OPTIONS\");\n\n  if (x && !strstr(x, \"exit_code=\" STRINGIFY(MSAN_ERROR)))\n    FATAL(\"Custom MSAN_OPTIONS set without exit_code=\"\n          STRINGIFY(MSAN_ERROR) \" - please fix!\");\n\n} \n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      /* If we don't have a file name chosen yet, use a safe default. */\n\n      if (!out_file)\n\t\t  if (!use_sample_shared_memory) {\n\t\t\t  out_file = alloc_printf(\"%s\\\\.cur_input\", out_dir);\n\t\t  } else {\n\t\t\t    //this sets output file as shared memory name which is used by harness program.\n\t\t\t    out_file = sample_shm_str;\n\t\t  }\n\t  \n      /* Be sure that we're always using fully-qualified paths. */\n\n      //if (out_file[0] == '\\\\') aa_subst = out_file;\n      //else aa_subst = alloc_printf(\"%s\\\\%s\", cwd, out_file);\n\t  aa_subst = out_file;\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      //if (out_file[0] != '\\\\') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Set up signal handlers. More complicated that needs to be, because libc on\n   Solaris doesn't resume interrupted reads(), sets SA_RESETHAND when you call\n   siginterrupt(), and does other stupid things. */\n\nstatic void setup_signal_handlers(void) {\n  //not implemented on Windows\n}\n\n\n/* Rewrite argv for QEMU. */\n\nstatic char** get_qemu_argv(u8* own_loc, char** argv, int argc) {\n  //not implemented on Windows\n  return NULL;\n}\n\n\n/* Make a copy of the current command line. */\n\nstatic void save_cmdline(u32 argc, char** argv) {\n\n  u32 len = 1, i;\n  u8* buf;\n\n  for (i = 0; i < argc; i++)\n    len += strlen(argv[i]) + 1;\n  \n  buf = orig_cmdline = ck_alloc(len);\n\n  for (i = 0; i < argc; i++) {\n\n    u32 l = strlen(argv[i]);\n\n    memcpy(buf, argv[i], l);\n    buf += l;\n\n    if (i != argc - 1) *(buf++) = ' ';\n\n  }\n\n  *buf = 0;\n\n}\n\nstatic int optind;\nstatic char *optarg;\n\nstatic void extract_client_params(u32 argc, char** argv) {\n  u32 len = 1, i;\n  u32 nclientargs = 0;\n  u8* buf;\n  u32 opt_start, opt_end;\n\n  if(!argv[optind] || optind >= argc) usage(argv[0]);\n  if(strcmp(argv[optind],\"--\")) usage(argv[0]);\n\n  optind++;\n  opt_start = optind;\n\n  for (i = optind; i < argc; i++) {\n    if(strcmp(argv[i],\"--\") == 0) break;\n    nclientargs++;\n    len += strlen(argv[i]) + 1;\n  }\n\n  if(i == argc) usage(argv[0]);\n  opt_end = i;\n\n  buf = client_params = ck_alloc(len);\n\n  for (i = opt_start; i < opt_end; i++) {\n\n    u32 l = strlen(argv[i]);\n\n    memcpy(buf, argv[i], l);\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  if(buf != client_params) {\n    buf--;\n  }\n\n  *buf = 0;\n\n  optind = opt_end;\n\n  //extract the number of fuzz iterations from client params\n  fuzz_iterations_max = 1000;\n  for (i = opt_start; i < opt_end; i++) {\n    if((strcmp(argv[i], \"-fuzz_iterations\") == 0) && ((i + 1) < opt_end)) {\n      fuzz_iterations_max = atoi(argv[i+1]);\n    }\n  }\n\n}\n\n\n//extracts client and target command line params\n/*static void parse_cmd_line(char *argv0) {\n\tchar *cmd;\n\tchar *p1, *p2, *p3;\n\tint client_params_sz;\n\n\tcmd = GetCommandLine();\n\t\n\tp1 = strstr(cmd, \" -- \");\n\tif(!p1) usage(argv0);\n\tp1 += 4;\n\n\tp2 = strstr(cmd, \" -- \");\n\tif(!p2) usage(argv0);\n\tp3 = p2 + 4;\n\n\tclient_params_sz = p2 - p1 + 1;\n\tclient_params = (char *)malloc(client_params_sz);\n\tmemcpy(client_params, p1, client_params_sz);\n\tclient_params[client_params_sz] = 0;\n}*/\n\n\nint getopt(int argc, char **argv, char *optstring) {\n  char *c;\n\n  optarg = NULL;\n\n  while(1) {\n    if(optind == argc) return -1;\n    if(strcmp(argv[optind], \"--\") == 0) return -1;\n    if(argv[optind][0] != '-') {\n      optind++;\n      continue;\n    }\n    if(!argv[optind][1]) {\n      optind++;\n      continue;\n    }\n\n    c = strchr(optstring, argv[optind][1]);\n    if(!c) return -1;\n    optind++;\n    if(c[1] == ':') {\n      if(optind == argc) return -1;\n      optarg = argv[optind];\n      optind++;\n    }\n\n    return (int)(c[0]);\n  }\n}\n\n/* This routine is designed to load user-defined library for custom test cases processing */\nvoid load_custom_library(const char *libname)\n{\n  int result = 0;\n  SAYF(\"Loading custom winAFL server library\\n\");\n  HMODULE hLib = LoadLibraryEx(libname, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);\n  if (hLib == NULL)\n    FATAL(\"Unable to load custom server library, GetLastError = 0x%x\", GetLastError());\n\n  /* init the custom server */\n  // Get pointer to user-defined server initialization function using GetProcAddress:\n  dll_init_ptr = (dll_init)GetProcAddress(hLib, \"dll_init\");\n  SAYF(\"dll_init %s defined.\\n\", dll_init_ptr ? \"is\" : \"isn't\");\n\n  // Get pointer to user-defined test cases sending function using GetProcAddress:\n  dll_run_ptr = (dll_run)GetProcAddress(hLib, \"dll_run\");\n  SAYF(\"dll_run_ptr %s defined.\\n\", dll_run_ptr ? \"is\" : \"isn't\");\n\n  // Get pointer to user-defined run_target function using GetProcAddress:\n  dll_run_target_ptr = (dll_run_target)GetProcAddress(hLib, \"dll_run_target\");\n  SAYF(\"dll_run_target %s defined.\\n\", dll_run_target_ptr ? \"is\" : \"isn't\");\n\n  // Get pointer to user-defined write_to_testcase function using GetProcAddress:\n  dll_write_to_testcase_ptr = (dll_write_to_testcase)GetProcAddress(hLib, \"dll_write_to_testcase\");\n  SAYF(\"dll_write_to_testcase %s defined.\\n\", dll_write_to_testcase_ptr ? \"is\" : \"isn't\");\n\n  // Get pointer to user-defined mutate_testcase function using GetProcAddress:\n  dll_mutate_testcase_ptr = (dll_mutate_testcase)GetProcAddress(hLib, \"dll_mutate_testcase\");\n  SAYF(\"dll_mutate_testcase %s defined.\\n\", dll_mutate_testcase_ptr ? \"is\" : \"isn't\");\n\n  // Get pointer to user-defined trim_testcase function using GetProcAddress:\n  dll_trim_testcase_ptr = (dll_trim_testcase)GetProcAddress(hLib, \"dll_trim_testcase\");\n  SAYF(\"dll_trim_testcase %s defined.\\n\", dll_mutate_testcase_ptr ? \"is\" : \"isn't\");\n\n  // Get pointer to user-defined dll_mutate_testcase_with_energy_ptr function using GetProcAddress:\n  dll_mutate_testcase_with_energy_ptr = (dll_mutate_testcase_with_energy)GetProcAddress(hLib, \"dll_mutate_testcase_with_energy\");\n  SAYF(\"dll_mutate_testcase_with_energy %s defined.\\n\", dll_mutate_testcase_with_energy_ptr ? \"is\" : \"isn't\");\n\n  SAYF(\"Sucessfully loaded and initalized\\n\");\n}\n\n/* Main entry point */\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u64 prev_queued = 0;\n  u32 sync_interval_cnt = 0, seek_to;\n  u8  *extras_dir = 0;\n  u8  mem_limit_given = 0;\n\n  char** use_argv;\n\n  setup_watchdog_timer();\n\n#ifdef USE_COLOR\n  enable_ansi_console();\n#endif\n\n  SAYF(\"WinAFL \" WINAFL_VERSION \" by <ifratric@google.com>\\n\");\n  SAYF(\"Based on AFL \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  doc_path = \"afl_docs\";\n\n  optind = 1;\n\n  in_dir = NULL;\n  out_dir = NULL;\n  dynamorio_dir = NULL;\n  client_params = NULL;\n  winafl_dll_path = NULL;\n\n  while ((opt = getopt(argc, argv, \"+i:o:f:m:t:I:T:sdyYnCB:S:M:x:QD:b:l:pPc:w:A:eV\")) > 0)\n\n    switch (opt) {\n      case 's':\n        \n        if (use_sample_shared_memory) FATAL(\"Multiple -s options not supported\");\n        use_sample_shared_memory = TRUE;\n        ACTF(\"using shared memory mode...\");\n        break;\n\n      case 'i':\n\n        if (in_dir) FATAL(\"Multiple -i options not supported\");\n        in_dir = optarg;\n\n        if (!strcmp(in_dir, \"-\")) in_place_resume = 1;\n\n        break;\n\n      case 'o': /* output dir */\n\n        if (out_dir) FATAL(\"Multiple -o options not supported\");\n        out_dir = optarg;\n        break;\n\n      case 'w': /* winafl.dll path */\n\n        if (winafl_dll_path) FATAL(\"Multiple -w options not supported\");\n        winafl_dll_path = optarg;\n        break;\n\n      case 'D': /* dynamorio dir */\n\n        if (dynamorio_dir) FATAL(\"Multiple -D options not supported\");\n        dynamorio_dir = optarg;\n        break;\n\n      case 'M': { /* master sync ID */\n\n          u8* c;\n\n          if (sync_id) FATAL(\"Multiple -S or -M options not supported\");\n          sync_id = optarg;\n\n          if ((c = strchr(sync_id, ':'))) {\n\n            *c = 0;\n\n            if (sscanf(c + 1, \"%u/%u\", &master_id, &master_max) != 2 ||\n                !master_id || !master_max || master_id > master_max ||\n                master_max > 1000000) FATAL(\"Bogus master ID passed to -M\");\n\n          }\n\n          force_deterministic = 1;\n          fuzzer_id = sync_id;\n\n        }\n        break;\n\n      case 'S':\n\n        if (sync_id) FATAL(\"Multiple -S or -M options not supported\");\n        sync_id = ck_strdup(optarg);\n        break;\n\n      case 'f': /* target file */\n\n        if (out_file) FATAL(\"Multiple -f options not supported\");\n        out_file = optarg;\n        break;\n\n      case 'x':\n\n        if (extras_dir) FATAL(\"Multiple -x options not supported\");\n        extras_dir = optarg;\n        break;\n\n      case 't': {\n\n          u8 suffix = 0;\n\n          if (timeout_given) FATAL(\"Multiple -t options not supported\");\n\n          if (sscanf(optarg, \"%u%c\", &exec_tmout, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -t\");\n\n          if (exec_tmout < 5) FATAL(\"Dangerously low value of -t\");\n\n          if (suffix == '+') timeout_given = 2; else timeout_given = 1;\n\n          break;\n\n      }\n\n      case 'I': {\n\n        if (sscanf(optarg, \"%u\", &init_tmout) < 1) FATAL(\"Bad syntax used for -I\");\n\n        if (init_tmout < 5) FATAL(\"Dangerously low value of -I\");\n\n        break;\n\n      }\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          break;\n      }\n\n      case 'd':\n\n        if (skip_deterministic) FATAL(\"Multiple -d options not supported\");\n        skip_deterministic = 1;\n        use_splicing = 1;\n        break;\n\n      case 'B':\n\n        /* This is a secret undocumented option! It is useful if you find\n           an interesting test case during a normal fuzzing process, and want\n           to mutate it without rediscovering any of the test cases already\n           found during an earlier run.\n\n           To use this mode, you need to point -B to the fuzz_bitmap produced\n           by an earlier run for the exact same binary... and that's it.\n\n           I only used this once or twice to get variants of a particular\n           file, so I'm not making this an official setting. */\n\n        if (in_bitmap) FATAL(\"Multiple -B options not supported\");\n\n        in_bitmap = optarg;\n        read_bitmap(in_bitmap);\n        break;\n\n      case 'C':\n\n        if (crash_mode) FATAL(\"Multiple -C options not supported\");\n        crash_mode = FAULT_CRASH;\n        break;\n\n      case 'n':\n\n        if (dumb_mode) FATAL(\"Multiple -n options not supported\");\n        if (getenv(\"AFL_DUMB_FORKSRV\")) dumb_mode = 2; else dumb_mode = 1;\n\n        break;\n\n      case 'T':\n\n        if (use_banner) FATAL(\"Multiple -T options not supported\");\n        use_banner = optarg;\n        break;\n\n      case 'Q':\n\n        if (qemu_mode) FATAL(\"Multiple -Q options not supported\");\n        qemu_mode = 1;\n\n        if (!mem_limit_given) mem_limit = MEM_LIMIT_QEMU;\n\n        break;\n\n      case 'Y':\n\n        if (dynamorio_dir) FATAL(\"Dynamic-instrumentation via DRIO is uncompatible with static-instrumentation\");\n        drioless = 1;\n\n        break;\n\n      case 'l':\n        custom_dll_defined = 1;\n        load_custom_library(optarg);\n\n        break;\n\n\t  case 'p':\n\t\t  persist_dr_cache = 1;\n\n\t\t  break;\n\n    case 'P':\n#ifdef INTELPT\n      use_intelpt = 1;\n#else\n      FATAL(\"afl-fuzz was not compiled with Intel PT support\");\n#endif\n\n      break;\n\n    case 'y':\n#ifdef TINYINST\n      use_tinyinst = 1;\n#else\n      FATAL(\"afl-fuzz was not compiled with TinyInst support\");\n#endif\n\n      break;\n\n    case 'c':\n\n        if (getenv(\"AFL_NO_AFFINITY\")) FATAL(\"-c and AFL_NO_AFFINITY are mutually exclusive.\");\n\n        if (cpu_aff) {\n          FATAL(\"Multiple -c options not supported\");\n        } else {\n          int cpunum = 0;\n\n          if (sscanf(optarg, \"%d\", &cpunum) < 1 ||\n              cpunum < 0) FATAL(\"Bad syntax used for -c\");\n\n          if (cpunum >= 64)\n            FATAL(\"Uh-oh, winafl doesn't support more than 64 cores at the moment\\n\");\n\n          cpu_aff = 1ULL << cpunum;\n        }\n\n        break;\n\n      case 'A':\n        // attaching to a running process with the specified module\n        drattach = 1;\n        drattach_identifier = optarg;\n        break;\n\n      case 'e':\n        // use WinAFL as a tool to run alongside DynamoRIO\n        if (use_intelpt || use_tinyinst || drioless) FATAL(\"Expert mode is only available for DynamoRIO\");\n        if (expert_mode) FATAL(\"Multiple -e options not supported\");\n        expert_mode = 1;\n        break;\n\n     case 'V': /* Show version number */\n\n        /* Version number has been printed already, just quit. */\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if (!in_dir || !out_dir || !timeout_given || (!drioless && !dynamorio_dir && !use_intelpt && !use_tinyinst)) usage(argv[0]);\n\n  if (!winafl_dll_path) {\n    winafl_dll_path = \"winafl.dll\";\n  } else if (expert_mode) {\n    FATAL(\"-w and -e are mutually exclusive\");\n  }\n\n  setup_signal_handlers();\n  check_asan_opts();\n\n  if (sync_id) fix_up_sync();\n\n  if (use_intelpt) {\n#ifdef INTELPT\n\t  char *modules_dir = alloc_printf(\"%s\\\\ptmodules\", out_dir);\n\t  int pt_options = pt_init(argc - optind, argv + optind, modules_dir);\n\t  ck_free(modules_dir);\n\t  if (!pt_options) usage(argv[0]);\n\t  optind += pt_options;\n#endif\n  } else if (use_tinyinst) {\n#ifdef TINYINST\n    int tinyinst_options = tinyinst_init(argc - optind, argv + optind);\n    if (!tinyinst_options) usage(argv[0]);\n    optind += tinyinst_options;\n#endif\n  } else {\n\t  extract_client_params(argc, argv);\n  }\n  optind++;\n  \n  if (!strcmp(in_dir, out_dir))\n    FATAL(\"Input and output directories can't be the same\");\n\n  if (dumb_mode) {\n\n    if (crash_mode) FATAL(\"-C and -n are mutually exclusive\");\n    if (qemu_mode)  FATAL(\"-Q and -n are mutually exclusive\");\n\n  }\n\n  if (getenv(\"AFL_NO_FORKSRV\"))    no_forkserver    = 1;\n  if (getenv(\"AFL_NO_CPU_RED\"))    no_cpu_meter_red = 1;\n  if (getenv(\"AFL_NO_ARITH\"))      no_arith = 1;\n  if (getenv(\"AFL_SHUFFLE_QUEUE\")) shuffle_queue    = 1;\n  if (getenv(\"AFL_NO_SINKHOLE\"))   sinkhole_stds    = 0;\n  if (getenv(\"AFL_AUTORESUME\"))    autoresume       = 1;\n\n  if (dumb_mode == 2 && no_forkserver)\n    FATAL(\"AFL_DUMB_FORKSRV and AFL_NO_FORKSRV are mutually exclusive\");\n\n  save_cmdline(argc, argv);\n\n  fix_up_banner(argv[optind]);\n\n  check_if_tty();\n\n  get_core_count();\n\n  bind_to_free_cpu();\n\n  check_crash_handling();\n  check_cpu_governor();\n\n  setup_post();\n\n  if (!in_bitmap) memset(virgin_bits, 255, MAP_SIZE);\n  memset(virgin_tmout, 255, MAP_SIZE);\n  memset(virgin_crash, 255, MAP_SIZE);\n\n  if (use_intelpt) {\n\t  trace_bits = VirtualAlloc(0, MAP_SIZE, MEM_COMMIT, PAGE_READWRITE);\n  } else {\n\t  setup_shm();\n  }\n\n  if (use_tinyinst) {\n#ifdef TINYINST\n    tinyinst_set_fuzzer_id(fuzzer_id);\n#endif\n  }\n  \n  if (use_sample_shared_memory) {\n    setup_sample_shm();\n  }\n  \n  init_count_class16();\n  child_handle = NULL;\n  pipe_handle = NULL;\n\n  devnul_handle = INVALID_HANDLE_VALUE;\n\n  setup_dirs_fds();\n  read_testcases();\n  load_auto();\n\n  pivot_inputs();\n\n  if (extras_dir) load_extras(extras_dir);\n\n  if (!timeout_given) find_timeout();\n\n  detect_file_args(argv + optind + 1);\n\n  if (!out_file) setup_stdio_file();\n\n  check_binary(argv[optind]);\n\n  start_time = get_cur_time();\n\n  if (qemu_mode)\n    use_argv = get_qemu_argv(argv[0], argv + optind, argc - optind);\n  else\n    use_argv = argv + optind;\n\n  perform_dry_run(use_argv);\n\n  cull_queue();\n\n  show_init_stats();\n\n  seek_to = find_start_position();\n\n  start_time = get_cur_time();\n  if (in_place_resume || autoresume) load_stats_file();\n  write_stats_file(0, 0, 0);\n  save_auto();\n\n  if (stop_soon) goto stop_fuzzing;\n\n  /* Woop woop woop */\n\n  while (1) {\n\n    u8 skipped_fuzz;\n\n    cull_queue();\n\n    if (!queue_cur) {\n\n      queue_cycle++;\n      current_entry     = 0;\n      cur_skipped_paths = 0;\n      queue_cur         = queue;\n\n      while (seek_to) {\n        current_entry++;\n        seek_to--;\n        queue_cur = queue_cur->next;\n      }\n\n      show_stats();\n\n      if (not_on_tty) {\n        ACTF(\"Entering queue cycle %llu.\", queue_cycle);\n        fflush(stdout);\n      }\n\n      /* If we had a full queue cycle with no new finds, try\n         recombination strategies next. */\n\n      if (queued_paths == prev_queued) {\n\n        if (use_splicing) cycles_wo_finds++; else use_splicing = 1;\n\n      } else cycles_wo_finds = 0;\n\n      prev_queued = queued_paths;\n\n      if (sync_id && queue_cycle == 1 && getenv(\"AFL_IMPORT_FIRST\"))\n        sync_fuzzers(use_argv);\n\n    }\n\n    skipped_fuzz = fuzz_one(use_argv);\n\n    if (!stop_soon && sync_id && !skipped_fuzz) {\n      \n      if (!(sync_interval_cnt++ % SYNC_INTERVAL))\n        sync_fuzzers(use_argv);\n\n    }\n\n    if (stop_soon) break;\n\n    queue_cur = queue_cur->next;\n    current_entry++;\n\n  }\n\n  if (queue_cur) show_stats();\n\n  write_bitmap();\n  write_stats_file(0, 0, 0);\n  save_auto();\n\nstop_fuzzing:\n\n  SAYF(CURSOR_SHOW cLRD \"\\n\\n+++ Testing %s +++\\n\" cRST,\n       stop_soon == 2 ? \"ended via AFL_EXIT_WHEN_DONE\" : \"aborted by user\");\n\n  /* Running for more than 30 minutes but still doing first cycle? */\n\n  if (queue_cycle == 1 && get_cur_time() - start_time > 30 * 60 * 1000) {\n\n    SAYF(\"\\n\" cYEL \"[!] \" cRST\n           \"Stopped during the first cycle, results may be incomplete.\\n\"\n           \"    (For info on resuming, see %s\\\\README.)\\n\", doc_path);\n\n  }\n\n  if(devnul_handle != INVALID_HANDLE_VALUE) {\n    CloseHandle(devnul_handle);\n  }\n\n  fclose(plot_file);\n  destroy_queue();\n  destroy_extras();\n  ck_free(target_path);\n\n  if(fuzzer_id != NULL && fuzzer_id != sync_id)\n    ck_free(fuzzer_id);\n\n  alloc_report();\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}\n"
        },
        {
          "name": "afl-showmap.c",
          "type": "blob",
          "size": 25.634765625,
          "content": "/*\n   american fuzzy lop - map display utility\n   ----------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\n\n   Copyright 2017 Google Inc. All rights reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at:\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   A very simple tool that runs the targeted binary and displays\n   the contents of the trace bitmap in a human-readable form. Useful in\n   scripts to eliminate redundant inputs and perform other checks.\n\n   Exit code is 2 if the target program crashes; 1 if it times out or\n   there is a problem executing it; or 0 if execution is successful.\n\n*/\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_RAND_S  \n#define VERSION             \"2.36b\"\n\n#define AFL_MAIN\n\n#include <windows.h>\n#include <stdarg.h>\n#include <io.h>\n#include <direct.h>\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic s32 child_pid;                 /* PID of the tested program         */\n\nstatic HANDLE child_handle,\n              child_thread_handle;\nstatic char *dynamorio_dir;\nstatic char *client_params;\n\nstatic CRITICAL_SECTION critical_section;\nstatic u64 watchdog_timeout_time;\nstatic u8 watchdog_enabled;\nstatic u8 *target_cmd;                /* command line of target           */\n\nstatic HANDLE shm_handle;             /* Handle of the SHM region         */\nstatic HANDLE pipe_handle;            /* Handle of the name pipe          */\nstatic u64    name_seed;              /* Random integer to have a unique shm/pipe name */\nstatic HANDLE devnul_handle;          /* Handle of the nul device         */\nstatic char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized \n                                         seed allowing multiple instances */\n\nstatic u8* trace_bits;                /* SHM with instrumentation bitmap   */\n\nstatic u8 *out_file,                  /* Trace output file                 */\n          *doc_path,                  /* Path to docs                      */\n          *target_path,               /* Path to target binary             */\n          *at_file;                   /* Substitution string for @@        */\n\nstatic u32 exec_tmout;                /* Exec timeout (ms)                 */\n\nstatic u64 mem_limit = MEM_LIMIT;     /* Memory limit (MB)                 */\n\n// static s32 shm_id;                    /* ID of the SHM region              */\n\nstatic u8  quiet_mode,                /* Hide non-essential messages?      */\n           edges_only,                /* Ignore hit counts?                */\n           cmin_mode,                 /* Generate output in afl-cmin mode? */\n           binary_mode,               /* Write output as a binary map      */\n           drioless = 0;              /* Running without DRIO?             */\n\nstatic volatile u8\n           stop_soon,                 /* Ctrl-C pressed?                   */\n           child_timed_out,           /* Child timed out?                  */\n           child_crashed;             /* Child crashed?                    */\n\n/* Classify tuple counts. Instead of mapping to individual bits, as in\n   afl-fuzz.c, we map to more user-friendly numbers between 1 and 8. */\n\n#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)\n#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)\n#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)\n#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)\n#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)\n#define AREP128(_sym) AREP64(_sym), AREP64(_sym)\n\nstatic const u8 count_class_human[256] = {\n\n  /* 0 - 3:       4 */ 0, 1, 2, 3,\n  /* 4 - 7:      +4 */ AREP4(4),\n  /* 8 - 15:     +8 */ AREP8(5),\n  /* 16 - 31:   +16 */ AREP16(6),\n  /* 32 - 127:  +96 */ AREP64(7), AREP32(7),\n  /* 128+:     +128 */ AREP128(8)\n\n};\n\nstatic const u8 count_class_binary[256] = {\n\n  /* 0 - 3:       4 */ 0, 1, 2, 4,\n  /* 4 - 7:      +4 */ AREP4(8),\n  /* 8 - 15:     +8 */ AREP8(16),\n  /* 16 - 31:   +16 */ AREP16(32),\n  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),\n  /* 128+:     +128 */ AREP128(128)\n\n};\n\nstatic void classify_counts(u8* mem, const u8* map) {\n\n  u32 i = MAP_SIZE;\n\n  if (edges_only) {\n\n    while (i--) {\n      if (*mem) *mem = 1;\n      mem++;\n    }\n\n  } else {\n\n    while (i--) {\n     *mem = map[*mem];\n      mem++;\n    }\n\n  }\n\n}\n\n\n/* Get unix time in milliseconds */\n\nstatic u64 get_cur_time(void) {\n\n  u64 ret;\n  FILETIME filetime;\n  GetSystemTimeAsFileTime(&filetime);\n\n  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;\n\n  return ret / 10000;\n\n}\n\n\n/* Get unix time in microseconds */\n\nstatic u64 get_cur_time_us(void) {\n\n  u64 ret;\n  FILETIME filetime;\n  GetSystemTimeAsFileTime(&filetime);\n\n  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;\n\n  return ret / 10;\n\n}\n\n\nchar *alloc_printf(const char *_str, ...) {\n\n  va_list argptr;\n  char* _tmp;\n  s32 _len;\n\n  va_start(argptr, _str);\n  _len = vsnprintf(NULL, 0, _str, argptr);\n  if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\");\n  _tmp = ck_alloc(_len + 1);\n  vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);\n  va_end(argptr);\n  return _tmp;\n\n}\n\n\n/* Get rid of shared memory (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  UnmapViewOfFile(trace_bits);\n  CloseHandle(shm_handle);\n\n}\n\n\n/* Configure shared memory. */\n\nstatic void setup_shm(void) {\n\n  char* shm_str = NULL;\n  unsigned int seeds[2];\n  u64 name_seed;\n  u8 attempts = 0;\n\n  while(attempts < 5) {\n    if(fuzzer_id == NULL) {\n      // If it is null, it means we have to generate a random seed to name the instance\n      rand_s(&seeds[0]);\n      rand_s(&seeds[1]);\n      name_seed = ((u64)seeds[0] << 32) | seeds[1];\n      fuzzer_id = (char *)alloc_printf(\"%I64x\", name_seed);\n    }\n\n    shm_str = (char *)alloc_printf(\"afl_shm_%s\", fuzzer_id);\n\n    shm_handle = CreateFileMapping(\n                   INVALID_HANDLE_VALUE,    // use paging file\n                   NULL,                    // default security\n                   PAGE_READWRITE,          // read/write access\n                   0,                       // maximum object size (high-order DWORD)\n                   MAP_SIZE,                // maximum object size (low-order DWORD)\n                   (char *)shm_str);        // name of mapping object\n\n    if(shm_handle == NULL) {\n      if(GetLastError() == ERROR_ALREADY_EXISTS) {\n        // We need another attempt to find a unique section name\n        attempts++;\n        ck_free(shm_str);\n        ck_free(fuzzer_id);\n        fuzzer_id = NULL;\n        continue;\n      }\n      else {\n        PFATAL(\"CreateFileMapping failed\");\n      }\n    }\n\n    // We found a section name that works!\n    break;\n  }\n\n  if(attempts == 5) {\n    FATAL(\"Could not find a section name.\\n\");\n  }\n\n  atexit(remove_shm);\n\n  ck_free(shm_str);\n\n  trace_bits = (u8 *)MapViewOfFile(\n    shm_handle,          // handle to map object\n    FILE_MAP_ALL_ACCESS, // read/write permission\n    0,\n    0,\n    MAP_SIZE\n  );\n\n  if (!trace_bits) PFATAL(\"MapViewOfFile() failed\");\n\n}\n\n\n/* Write results. */\n\nstatic u32 write_results(void) {\n\n  s32 fd;\n  u32 i, ret = 0;\n\n  u8  cco = !!getenv(\"AFL_CMIN_CRASHES_ONLY\"),\n      caa = !!getenv(\"AFL_CMIN_ALLOW_ANY\");\n\n  if (!strncmp(out_file, \"/dev/\", 5)) {\n\n    fd = _open(out_file, O_WRONLY, DEFAULT_PERMISSION);\n    if (fd < 0) PFATAL(\"Unable to open '%s'\", out_file);\n\n  } else if (!strcmp(out_file, \"-\")) {\n\n    fd = _dup(1);\n    if (fd < 0) PFATAL(\"Unable to open stdout\");\n\n  } else {\n\n    fd = _open(out_file, O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_PERMISSION);\n    if (fd < 0) PFATAL(\"Unable to create '%s'\", out_file);\n\n  }\n\n  if (binary_mode) {\n\n    for (i = 0; i < MAP_SIZE; i++)\n      if (trace_bits[i]) ret++;\n\n    ck_write(fd, trace_bits, MAP_SIZE, out_file);\n    close(fd);\n\n  } else {\n\n\n    FILE* f = fdopen(fd, \"w\");\n\n    if (!f) PFATAL(\"fdopen() failed\");\n\n    for (i = 0; i < MAP_SIZE; i++) {\n\n      if (!trace_bits[i]) continue;\n      ret++;\n\n      if (cmin_mode) {\n\n        if (child_timed_out) break;\n        if (!caa && child_crashed != cco) break;\n\n        fprintf(f, \"%u%u\\n\", trace_bits[i], i);\n\n      } else fprintf(f, \"%06u:%u\\n\", i, trace_bits[i]);\n\n    }\n  \n    fclose(f);\n\n  }\n\n  return ret;\n\n}\n\n\n//quoting on Windows is weird\nsize_t ArgvQuote(char *in, char *out) {\n  int needs_quoting = 0;\n  size_t size = 0;\n  char *p = in;\n  size_t i;\n\n  //check if quoting is necessary\n  if(strchr(in, ' ')) needs_quoting = 1;\n  if(strchr(in, '\\\"')) needs_quoting = 1;\n  if(strchr(in, '\\t')) needs_quoting = 1;\n  if(strchr(in, '\\n')) needs_quoting = 1;\n  if(strchr(in, '\\v')) needs_quoting = 1;\n  if(!needs_quoting) {\n    size = strlen(in);\n    if(out) memcpy(out, in, size);\n    return size;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  while(*p) {\n    size_t num_backslashes = 0;\n    while((*p) && (*p == '\\\\')) {\n      p++;\n      num_backslashes++;\n    }\n\n    if(*p == 0) {\n      for(i = 0; i < (num_backslashes*2); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      break;\n    } else if(*p == '\\\"') {\n      for(i = 0; i < (num_backslashes*2 + 1); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    } else {\n      for(i = 0; i < num_backslashes; i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    }\n\n    p++;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  return size;\n}\n\n\nchar *argv_to_cmd(char** argv) {\n  u32 len = 0, i;\n  u8* buf, *ret;\n\n  //todo shell-escape\n\n  for (i = 0; argv[i]; i++)\n    len += ArgvQuote(argv[i], NULL) + 1;\n  \n  if(!len) FATAL(\"Error creating command line\");\n\n  buf = ret = ck_alloc(len);\n\n  for (i = 0; argv[i]; i++) {\n\n    u32 l = ArgvQuote(argv[i], buf);\n\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  ret[len-1] = 0;\n\n  return ret;\n}\n\n\nstatic void create_target_process(char** argv) {\n  char *cmd;\n  char *pipe_name;\n  char *buf;\n  char *pidfile;\n  FILE *fp;\n  size_t pidsize;\n  BOOL inherit_handles = TRUE;\n\n  HANDLE hJob = NULL;\n  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n\n  pipe_name = (char *)alloc_printf(\"\\\\\\\\.\\\\pipe\\\\afl_pipe_%s\", fuzzer_id);\n\n  pipe_handle = CreateNamedPipe(\n    pipe_name,                // pipe name\n    PIPE_ACCESS_DUPLEX,       // read/write access\n    0,\n    1,                        // max. instances\n    512,                      // output buffer size\n    512,                      // input buffer size\n    20000,                    // client time-out\n    NULL);                    // default security attribute\n\n  if (pipe_handle == INVALID_HANDLE_VALUE) {\n    FATAL(\"CreateNamedPipe failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  target_cmd = argv_to_cmd(argv);\n\n  ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof(si);\n  ZeroMemory(&pi, sizeof(pi));\n\n  if(quiet_mode) {\n    si.hStdOutput = si.hStdError = devnul_handle;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n  } else {\n    inherit_handles = FALSE;\n  }\n\n  if(drioless) {\n    char *static_config = alloc_printf(\"%s:1\", fuzzer_id);\n\n    if (static_config == NULL) {\n      FATAL(\"Cannot allocate static_config.\");\n    }\n\n    SetEnvironmentVariable(\"AFL_STATIC_CONFIG\", static_config);\n    cmd = alloc_printf(\"%s\", target_cmd);\n    ck_free(static_config);\n  } else {\n    pidfile = alloc_printf(\"childpid_%s.txt\", fuzzer_id);\n    cmd = alloc_printf(\n      \"%s\\\\drrun.exe -pidfile %s -no_follow_children -c winafl.dll %s -fuzz_iterations 1 -fuzzer_id %s -- %s\",\n      dynamorio_dir, pidfile, client_params, fuzzer_id, target_cmd\n    );\n  }\n\n  if(mem_limit != 0) {\n    hJob = CreateJobObject(NULL, NULL);\n    if(hJob == NULL) {\n      FATAL(\"CreateJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    ZeroMemory(&job_limit, sizeof(job_limit));\n    job_limit.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_MEMORY;\n    job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;\n\n    if(!SetInformationJobObject(\n      hJob,\n      JobObjectExtendedLimitInformation,\n      &job_limit,\n      sizeof(job_limit)\n    )) {\n      FATAL(\"SetInformationJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  if(!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {\n    FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  child_handle = pi.hProcess;\n  child_thread_handle = pi.hThread;\n\n  if(mem_limit != 0) {\n    if(!AssignProcessToJobObject(hJob, child_handle)) {\n      FATAL(\"AssignProcessToJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  ResumeThread(child_thread_handle);\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n  watchdog_enabled = 1;\n\n  if(!ConnectNamedPipe(pipe_handle, NULL)) {\n    if(GetLastError() != ERROR_PIPE_CONNECTED) {\n      FATAL(\"ConnectNamedPipe failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  watchdog_enabled = 0;\n\n  if(drioless == 0) {\n    //by the time pipe has connected the pidfile must have been created\n    fp = fopen(pidfile, \"rb\");\n    if(!fp) {\n      FATAL(\"Error opening pidfile.txt\");\n    }\n    fseek(fp,0,SEEK_END);\n    pidsize = ftell(fp);\n    fseek(fp,0,SEEK_SET);\n    buf = (char *)malloc(pidsize+1);\n    if (!buf) {\n        FATAL(\"Error allocating %Iu bytes\", pidsize + 1);\n    }\n    fread(buf, pidsize, 1, fp);\n    buf[pidsize] = 0;\n    fclose(fp);\n    remove(pidfile);\n    child_pid = atoi(buf);\n    free(buf);\n    ck_free(pidfile);\n  }\n  else {\n    child_pid = pi.dwProcessId;\n  }\n\n  ck_free(target_cmd);\n  ck_free(cmd);\n  ck_free(pipe_name);\n}\n\n\nstatic void destroy_target_process(int wait_exit) {\n  char* kill_cmd;\n  BOOL still_alive = TRUE;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n\n  EnterCriticalSection(&critical_section);\n\n  if(!child_handle) {\n    goto leave;\n  }\n\n  if(WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {\n    goto done;\n  }\n\n  // nudge the child process only if dynamorio is used\n  if(drioless) {\n    TerminateProcess(child_handle, 0);\n  } else {\n    kill_cmd = alloc_printf(\"%s\\\\drconfig.exe -nudge_pid %d 0 1\", dynamorio_dir, child_pid);\n\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n\n    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n      FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    ck_free(kill_cmd);\n  }\n\n  still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;\n\n  if(still_alive) {\n    //wait until the child process exits\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n\n    kill_cmd = alloc_printf(\"taskkill /PID %d /F\", child_pid);\n\n    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n      FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    ck_free(kill_cmd);\n\n    if(WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {\n      FATAL(\"Cannot kill child process\\n\");\n    }\n  }\n\n  done:\n  CloseHandle(child_handle);\n  CloseHandle(child_thread_handle);\n\n  child_handle = NULL;\n  child_thread_handle = NULL;\n\n  leave:\n  //close the pipe\n  if(pipe_handle) {\n    DisconnectNamedPipe(pipe_handle); \n    CloseHandle(pipe_handle);\n\n    pipe_handle = NULL;\n  }\n\n  LeaveCriticalSection(&critical_section);\n}\n\n\nDWORD WINAPI watchdog_timer( LPVOID lpParam ) {\n  u64 current_time;\n  while(1) {\n    Sleep(1000);\n    current_time = get_cur_time();\n    if(watchdog_enabled && (current_time > watchdog_timeout_time)) {\n      child_timed_out = 1;\n      destroy_target_process(0);\n    }\n  }\n}\n\n\nstatic void setup_watchdog_timer() {\n  watchdog_enabled = 0;\n  InitializeCriticalSection(&critical_section);\n  CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);\n}\n\n\nstatic int is_child_running() {\n   return (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));\n}\n\n\n/* Execute target application. */\n\nstatic void run_target(char** argv) {\n\n  char command[] = \"F\";\n  DWORD num_read;\n  char result = 0;\n\n  if(!quiet_mode)\n    SAYF(\"-- Program output begins --\\n\" cRST);\n\n  if(quiet_mode && devnul_handle == INVALID_HANDLE_VALUE) {\n    devnul_handle = CreateFile(\n      \"nul\",\n      GENERIC_READ | GENERIC_WRITE,\n      FILE_SHARE_READ | FILE_SHARE_WRITE,\n      NULL,\n      OPEN_EXISTING,\n      0,\n      NULL);\n\n    if(devnul_handle == INVALID_HANDLE_VALUE) {\n      PFATAL(\"Unable to open the nul device.\");\n    }\n  }\n\n  if(!is_child_running()) {\n    destroy_target_process(0);\n    create_target_process(argv);\n  }\n\n  child_timed_out = 0;\n  memset(trace_bits, 0, MAP_SIZE);\n\n  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  if (result == 'K')\n  {\n\t  //a workaround for first cycle\n\t  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  }\n  if (result != 'P')\n  {\n\t  FATAL(\"Unexpected result from pipe! expected 'P', instead received '%c'\\n\", result);\n  }\n  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  WriteFile( \n    pipe_handle,  // handle to pipe \n    command,      // buffer to write from \n    1,            // number of bytes to write \n    &num_read,    // number of bytes written \n    NULL);        // not overlapped I/O \n\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n\n  if(exec_tmout) {\n    watchdog_enabled = 1;\n  }\n\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n\n  if(exec_tmout) {\n    watchdog_enabled = 0;\n  }\n\n  classify_counts(trace_bits, binary_mode ?\n                  count_class_binary : count_class_human);\n\n  if(!quiet_mode)\n    SAYF(cRST \"-- Program output ends --\\n\");\n\n  child_crashed = result == 'C';\n\n  if(!quiet_mode) {\n    if(result == 'K')\n      SAYF(cLRD \"\\n--- Program finished properly ---\\n\" cRST);\n    else if(child_timed_out)\n      SAYF(cLRD \"\\n+++ Program timed off +++\\n\" cRST);\n    else if(stop_soon)\n      SAYF(cLRD \"\\n+++ Program aborted by user +++\\n\" cRST);\n    else if(child_crashed)\n      SAYF(cLRD \"\\n+++ Program crashed +++\\n\" cRST);\n  }\n\n\n}\n\n\n/* Do basic preparations - persistent fds, filenames, etc. */\n\nstatic void set_up_environment(void) {\n  // Not supported on Windows\n}\n\n\n/* Setup signal handlers, duh. */\n\nstatic void setup_signal_handlers(void) {\n  // not implemented on Windows\n}\n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = _getcwd(NULL, 0);\n\n  if(!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if(aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      if(!at_file) FATAL(\"@@ syntax is not supported by this tool.\");\n\n      /* Be sure that we're always using fully-qualified paths. */\n\n      // if(at_file[0] == '/') aa_subst = at_file;\n      // else aa_subst = alloc_printf(\"%s/%s\", cwd, at_file);\n      aa_subst = out_file;\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      // if(at_file[0] != '/') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Show banner. */\n\nstatic void show_banner(void) {\n\n  SAYF(cCYA \"afl-showmap for Windows \" cBRI VERSION cRST \" by <0vercl0k@tuxfamily.org>\\n\");\n  SAYF(\"Based on WinAFL \" cBRI VERSION cRST \" by <ifratric@google.com>\\n\");\n  SAYF(\"Based on AFL \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n}\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  show_banner();\n\n  SAYF(\"\\n%s [ options ] -- [instrumentation options] -- \\\\path\\\\to\\\\target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -o file       - file to write the trace data to\\n\"\n\n       \"Instrumentation type:\\n\\n\"\n       \"  -D dir        - directory with DynamoRIO binaries (drrun, drconfig)\\n\"\n       \"  -Y            - enable the static instrumentation mode\\n\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -t msec       - timeout for each run (none)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n\n       \"Other settings:\\n\\n\"\n\n       \"  -q            - sink program's output and don't show messages\\n\"\n       \"  -e            - show edge coverage only, ignore hit counts\\n\"\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"This tool displays raw tuple data captured by AFL instrumentation.\\n\"\n       \"For additional help, consult %s\\\\README.\\n\\n\" cRST,\n\n       argv0, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Find binary. */\n\nstatic void find_binary(u8* fname) {\n  // Not implemented on Windows\n}\n\nstatic unsigned int optind;\nstatic char *optarg;\n\nint getopt(int argc, char **argv, char *optstring) {\n  char *c;\n\n  optarg = NULL;\n\n  while(1) {\n    if(optind == argc) return -1;\n    if(strcmp(argv[optind], \"--\") == 0) return -1;\n    if(argv[optind][0] != '-') {\n      optind++;\n      continue;\n    }\n    if(!argv[optind][1]) {\n      optind++;\n      continue;\n    }\n\n    c = strchr(optstring, argv[optind][1]);\n    if(!c) return -1;\n    optind++;\n    if(c[1] == ':') {\n      if(optind == argc) return -1;\n      optarg = argv[optind];\n      optind++;\n    }\n\n    return (int)(c[0]);\n  }\n}\n\nstatic void extract_client_params(u32 argc, char** argv) {\n  u32 len = 1, i;\n  u32 nclientargs = 0;\n  u8* buf;\n  u32 opt_start, opt_end;\n\n  if(!argv[optind] || optind >= argc) usage(argv[0]);\n  if(strcmp(argv[optind],\"--\")) usage(argv[0]);\n\n  if(drioless) return;\n  optind++;\n  opt_start = optind;\n\n  for (i = optind; i < argc; i++) {\n    if(strcmp(argv[i],\"--\") == 0) break;\n    nclientargs++;\n    len += strlen(argv[i]) + 1;\n  }\n\n  if(i == argc) usage(argv[0]);\n  opt_end = i;\n\n  buf = client_params = ck_alloc(len);\n\n  for (i = opt_start; i < opt_end; i++) {\n\n    u32 l = strlen(argv[i]);\n\n    memcpy(buf, argv[i], l);\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  if(buf != client_params) {\n    buf--;\n  }\n\n  *buf = 0;\n\n  optind = opt_end;\n\n}\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0;\n  u32 tcnt;\n  int i = 0, counter = 0;\n  char** use_argv;\n\n  doc_path = \"docs\";\n  optind = 1;\n  dynamorio_dir = NULL;\n  client_params = NULL;\n\n#ifdef USE_COLOR\n  enable_ansi_console();\n#endif\n\n  while ((opt = getopt(argc, argv, \"+o:m:t:A:D:eqZQbY\")) > 0)\n\n    switch (opt) {\n\n      case 'D': /* dynamorio dir */\n\n        if(dynamorio_dir) FATAL(\"Multiple -D options not supported\");\n        dynamorio_dir = optarg;\n        break;\n\n      case 'o':\n\n        if(out_file) FATAL(\"Multiple -o options not supported\");\n        out_file = optarg;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if(mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if(!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if(sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if(mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          if(sizeof(int) == 4 && mem_limit > 2000)\n            FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if(timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        if(strcmp(optarg, \"none\")) {\n          exec_tmout = atoi(optarg);\n\n          if(exec_tmout < 20 || optarg[0] == '-')\n            FATAL(\"Dangerously low value of -t\");\n\n        }\n\n        break;\n\n      case 'e':\n\n        if(edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'q':\n\n        if(quiet_mode) FATAL(\"Multiple -q options not supported\");\n        quiet_mode = 1;\n        break;\n\n      case 'Z':\n\n        /* This is an undocumented option to write data in the syntax expected\n           by afl-cmin. Nobody else should have any use for this. */\n\n        cmin_mode  = 1;\n        quiet_mode = 1;\n        break;\n\n      case 'A':\n\n        FATAL(\"-A option not supported on Windows\");\n        /* Another afl-cmin specific feature. */\n        at_file = optarg;\n        break;\n\n      case 'Q':\n        FATAL(\"QEMU mode not supported on Windows\");\n        break;\n\n      case 'b':\n\n        /* Secret undocumented mode. Writes output in raw binary format\n           similar to that dumped by afl-fuzz in <out_dir/queue/fuzz_bitmap. */\n\n        binary_mode = 1;\n\n      case 'Y':\n\n        if (dynamorio_dir) FATAL(\"Dynamic-instrumentation (DRIO) is uncompatible with static-instrumentation\");\n        drioless = 1;\n        break;\n\n      case 'V':\n\n        show_banner();\n        exit(0);\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if(!out_file) usage(argv[0]);\n  if(!drioless) {\n    if(optind == argc || !dynamorio_dir) usage(argv[0]);\n  }\n\n  extract_client_params(argc, argv);\n  optind++;\n\n  setup_shm();\n  setup_watchdog_timer();\n  setup_signal_handlers();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n\n  if(!quiet_mode) {\n    show_banner();\n    // Find the name of the target executable in the arguments\n    for(; i < argc; i++) {\n      if(strcmp(argv[i], \"--\") == 0) counter++;\n      if(counter == (drioless ? 1:2)) {\n        if(i != (argc - 1)) {\n          target_path = argv[i + 1];\n        }\n        break;\n      }\n    }\n    ACTF(\"Executing '%s'...\\n\", target_path);\n  }\n\n  detect_file_args(argv + optind);\n\n  use_argv = argv + optind;\n\n  run_target(use_argv);\n\n  tcnt = write_results();\n\n  if(!quiet_mode) {\n\n    if(!tcnt) SAYF(\"No instrumentation detected\");\n    OKF(\"Captured %u tuples in '%s'.\" cRST, tcnt, out_file);\n\n  }\n\n  exit(child_crashed * 2 + child_timed_out);\n\n}\n"
        },
        {
          "name": "afl-staticinstr.c",
          "type": "blob",
          "size": 21.705078125,
          "content": "/*\r\n   WinAFL persistent loop implementation for statically instrumented target\r\n   -----------------------------------------------------------------------\r\n\r\n   Written by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at:\r\n\r\n     http://www.apache.org/licenses/LICENSE-2.0\r\n*/\r\n#include \"afl-staticinstr.h\"\r\n#include <stdio.h>\r\n#include <psapi.h>\r\n#include <stdlib.h>\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\n#define MAP_SIZE 65536\r\n#define STATIC_COV_SECTION_NAME \".syzyafl\"\r\n#define STATIC_COV_SECTION_NAME_LEN 8\r\n#define AFL_STATIC_CONFIG_ENV TEXT(\"AFL_STATIC_CONFIG\")\r\n#define AFL_VARIABLE_BEHAVIOR_TRACES_BASE_DIR TEXT(\"C:\\\\traces\")\r\n#define AFL_VARIABLE_BEHAVIOR_ITERATIONS 10\r\n#define MAX_STRING_SIZE 64\r\n\r\n#pragma pack(push, 1)\r\ntypedef struct {\r\n    UINT32 __tls_index;\r\n    UINT32 __tls_slot_offset;\r\n    PUINT32 __afl_prev_loc;\r\n    PUCHAR __afl_area_ptr;\r\n    CHAR __afl_area[MAP_SIZE];\r\n} STATIC_COVERAGE_DATA, *PSTATIC_COVERAGE_DATA;\r\n#pragma pack(pop)\r\n\r\n//\r\n// The handle to the pipe used to talk with afl-fuzz.exe\r\n//\r\n\r\nHANDLE g_winafl_pipe = INVALID_HANDLE_VALUE;\r\n\r\n//\r\n// The no fuzzing mode is enabled when a binary is run without\r\n// passing the fuzzing configuration in the AFL_STATIC_CONFIG\r\n// environment variable (running a binary by itself, without\r\n// being run via afl-fuzz.exe will enable this mode for example).\r\n// Under this mode, the persistent loop exits after a single\r\n// iteration.\r\n//\r\n\r\nBOOL g_nofuzzing_mode = FALSE;\r\n\r\n//\r\n// The no instrumentation mode means the binary is running\r\n// without an AFL instrumented module in its address-space.\r\n// As a result, it means there is no coverage information\r\n// available (g_static_coverage_data is empty). This happens\r\n// when the persistent loop is run without instrumenting any\r\n// modules.\r\n//\r\n\r\nBOOL g_noinstrumentation = TRUE;\r\n\r\n//\r\n// The number of instrumented modules available in the\r\n// address space.\r\n//\r\n\r\nSIZE_T g_ninstrumented_modules = 0;\r\n\r\n//\r\n// The coverage data is a pointer to a structure that\r\n// can be found in an instrumented binary, in its '.syzyafl'\r\n// section. A pointer to the coverage map can be found in it,\r\n// but also what type of instrumentation it is using (single/multi thread).\r\n// Note that, it is NULL when g_noinstrumentation is TRUE.\r\n\r\n#define kMaximumInstrumentedModules 10\r\nSTATIC_COVERAGE_DATA *g_static_coverage_data[kMaximumInstrumentedModules];\r\n\r\n//\r\n// The current iterations track the number of iterations the persistent\r\n// loop has been through.\r\n//\r\n\r\nSIZE_T g_current_iterations = 0;\r\n\r\n//\r\n// The n iterations is the total number total iterations that\r\n// afl-fuzz.exe wants to be run every time the target process is\r\n// spawned. This is configured via the AFL_STATIC_CONFIG environment\r\n// variable.\r\n//\r\n\r\nSIZE_T g_niterations = 0;\r\n\r\n//\r\n// Some synchronization primitives.\r\n//\r\n\r\nCRITICAL_SECTION g_crit_section;\r\nINIT_ONCE g_init_once = INIT_ONCE_STATIC_INIT, g_init_once_bareminimum = INIT_ONCE_STATIC_INIT;\r\n\r\nLONG CALLBACK __afl_VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Catch exceptions and let afl-fuzz.exe know when an interesting\r\n    one happened.\r\n\r\nArguments:\r\n\r\n    ExceptionInfo - A structure with information about the exception\r\n    that triggered the invocation of the vectored exception handler.\r\n\r\nReturn Value:\r\n\r\n    EXCEPTION_CONTINUE_SEARCH if exception not handled.\r\n\r\n--*/\r\n\r\n\r\n{\r\n    DWORD Dummy;\r\n    EnterCriticalSection(&g_crit_section);\r\n\r\n    if(\r\n        ExceptionInfo->ExceptionRecord->ExceptionCode == DBG_PRINTEXCEPTION_C\r\n#ifdef DBG_PRINTEXCEPTION_WIDE_C\r\n\r\n        //\r\n        // This define has been introduced in the Windows 10 SDK and doesn't\r\n        // exist in older SDKs.\r\n        //\r\n\r\n        || ExceptionInfo->ExceptionRecord->ExceptionCode == DBG_PRINTEXCEPTION_WIDE_C\r\n#endif\r\n    ) {\r\n        _tprintf(TEXT(\"[*] Received an OutputDebugString exception.\\n\"));\r\n    }\r\n    else if(ExceptionInfo->ExceptionRecord->ExceptionCode == 0xE06D7363) {\r\n\r\n        //\r\n        // https://support.microsoft.com/fr-fr/help/185294/prb-exception-code-0xe06d7363-when-calling-win32-seh-apis\r\n        // https://blogs.msdn.microsoft.com/oldnewthing/20100730-00/?p=13273\r\n        //\r\n\r\n        _tprintf(TEXT(\"[*] Received an MSVC C++ exception.\\n\"));\r\n    }\r\n    else {\r\n        _tprintf(TEXT(\"[*] The program just crashed.\\n\"));\r\n        if(g_nofuzzing_mode == FALSE) {\r\n            WriteFile(g_winafl_pipe, \"C\", 1, &Dummy, NULL);\r\n            TerminateProcess(GetCurrentProcess(), 0);\r\n        }\r\n    }\r\n\r\n    LeaveCriticalSection(&g_crit_section);\r\n    _tprintf(TEXT(\"[+] Passing it to the program (might trigger a JIT debugger if it can't handle it).\\n\"));\r\n    return EXCEPTION_CONTINUE_SEARCH;\r\n}\r\n\r\nVOID __afl_display_banner()\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Displays the AFL persistent loop banner.\r\n\r\nArguments:\r\n\r\n    None.\r\n\r\nReturn Value:\r\n\r\n    None.\r\n\r\n--*/\r\n\r\n{\r\n    _tprintf(TEXT(\"Persistent loop implementation by <0vercl0k@tuxfamily.org>\\n\"));\r\n    _tprintf(TEXT(\"Based on WinAFL by <ifratric@google.com>\\n\"));\r\n}\r\n\r\nBOOL CALLBACK __afl_set_it_up(\r\n    PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context\r\n)\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Sets up the environment: creates the pipe to talk with afl-fuzz.exe,\r\n    maps the coverage byte-map that afl-fuzz.exe will map in and fix-up\r\n    the instrumented module so that its coverage byte-map pointer points\r\n    inside the shared memory section.\r\n\r\nArguments:\r\n\r\n    InitOnce - Unused.\r\n\r\n    Parameter - Unused.\r\n\r\n    Context - Unused.\r\n\r\nReturn Value:\r\n\r\n    TRUE on success, FALSE otherwise.\r\n\r\n--*/\r\n\r\n{\r\n    BOOL Status = TRUE;\r\n    HANDLE MappedFile = NULL;\r\n    PVOID AreaPtr = NULL;\r\n    DWORD SizeNeeded;\r\n    HMODULE Modules[128];\r\n    SIZE_T i = 0;\r\n    TCHAR PipeName[MAX_STRING_SIZE], ShmName[MAX_STRING_SIZE],\r\n          FuzzerId[MAX_STRING_SIZE], StaticConfig[MAX_STRING_SIZE],\r\n          InstrumentedModuleName[MAX_STRING_SIZE];\r\n\r\n    UNREFERENCED_PARAMETER(InitOnce);\r\n    UNREFERENCED_PARAMETER(Parameter);\r\n    UNREFERENCED_PARAMETER(Context);\r\n\r\n    EnterCriticalSection(&g_crit_section);\r\n\r\n    //\r\n    // Let's first figure out if we are running with any instrumented module,\r\n    // in the address space.\r\n    // If not, we turn on the no instrumentation switch.\r\n    //\r\n\r\n    Status = EnumProcessModulesEx(GetCurrentProcess(), Modules, sizeof(Modules), &SizeNeeded, LIST_MODULES_32BIT);\r\n\r\n    if(Status == FALSE) {\r\n        _tprintf(TEXT(\"[-] EnumProcessModulesEx failed - too many modules loaded?.\\n\"));\r\n        TerminateProcess(GetCurrentProcess(), 0);\r\n    }\r\n\r\n    for(i = 0; i < SizeNeeded / sizeof(Modules[0]); ++i) {\r\n        PVOID Base = (PVOID)Modules[i];\r\n        PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)((PUCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);\r\n        PIMAGE_SECTION_HEADER Sections = (PIMAGE_SECTION_HEADER)(NtHeaders + 1);\r\n        USHORT j = 0;\r\n\r\n        for(j = 0; j < NtHeaders->FileHeader.NumberOfSections; ++j) {\r\n            if(memcmp(Sections[j].Name, STATIC_COV_SECTION_NAME, STATIC_COV_SECTION_NAME_LEN) != 0) {\r\n                continue;\r\n            }\r\n\r\n            //\r\n            // Make sure we haven't exhausted the number of slots for the static coverage\r\n            // information.\r\n            //\r\n\r\n            if(g_ninstrumented_modules == ARRAYSIZE(g_static_coverage_data)) {\r\n                _tprintf(\r\n                    TEXT(\"[!] You have exhausted the number of instrumented modules (%d).\\n\"),\r\n                    g_ninstrumented_modules\r\n                );\r\n                break;\r\n            }\r\n\r\n            GetModuleBaseName(GetCurrentProcess(), Modules[i], InstrumentedModuleName, MAX_STRING_SIZE);\r\n            g_static_coverage_data[g_ninstrumented_modules] = (STATIC_COVERAGE_DATA*)(\r\n                Sections[j].VirtualAddress + (DWORD)Base\r\n            );\r\n\r\n            _tprintf(\r\n                TEXT(\"[+] Found a statically instrumented module: %s (%s thread mode).\\n\"),\r\n                InstrumentedModuleName,\r\n                (g_static_coverage_data[g_ninstrumented_modules]->__tls_slot_offset == 0) ?\r\n                TEXT(\"single\") : TEXT(\"multi\")\r\n            );\r\n            g_ninstrumented_modules++;\r\n            g_noinstrumentation = FALSE;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if(g_noinstrumentation == TRUE) {\r\n        _tprintf(TEXT(\"[-] No instrumented module found.\\n\"));\r\n        Status = FALSE;\r\n    }\r\n\r\n    //\r\n    // Let's figure out, if afl-fuzz.exe spawned us or not?\r\n    // If not, we can switch on the no fuzzing mode and exit.\r\n    //\r\n\r\n    if(GetEnvironmentVariable(AFL_STATIC_CONFIG_ENV, StaticConfig, MAX_STRING_SIZE) == 0) {\r\n        _tprintf(TEXT(\"[-] Not running under afl-fuzz.exe.\\n\"));\r\n        g_nofuzzing_mode = TRUE;\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    //\r\n    // We are running under afl-fuzz.exe; let's open the pipe used for\r\n    // communication, create a named shared memory section to store the coverage\r\n    // data and fix-up the instrumented module so that its instrumentation writes\r\n    // in the shared memory section's content.\r\n    //\r\n\r\n    memset(PipeName, 0, MAX_STRING_SIZE * sizeof(PipeName[0]));\r\n    memset(ShmName, 0, MAX_STRING_SIZE * sizeof(ShmName[0]));\r\n\r\n    _tprintf(TEXT(\"[*] Setting up the environment (%s)..\\n\"), StaticConfig);\r\n    if(_stscanf_s(StaticConfig, TEXT(\"%[a-zA-Z0-9]:%u\"), FuzzerId, _countof(FuzzerId), &g_niterations) != 2) {\r\n        _tprintf(\r\n            TEXT(\"[-] The \") AFL_STATIC_CONFIG_ENV TEXT(\" environment variable isn't properly formated.\\n\")\r\n        );\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    _stprintf_s(PipeName, _countof(PipeName), TEXT(\"\\\\\\\\.\\\\pipe\\\\afl_pipe_%s\"), FuzzerId);\r\n    _stprintf_s(ShmName, _countof(ShmName), TEXT(\"afl_shm_%s\"), FuzzerId);\r\n\r\n    //\r\n    // Connect to the named pipe.\r\n    //\r\n\r\n    g_winafl_pipe = CreateFile(\r\n        PipeName,                      // pipe name\r\n        GENERIC_READ | GENERIC_WRITE,  // read and write access\r\n        0,                             // no sharing\r\n        NULL,                          // default security attributes\r\n        OPEN_EXISTING,                 // opens existing pipe\r\n        0,                             // default attributes\r\n        NULL                           // no template file\r\n    );\r\n\r\n    if(g_winafl_pipe == INVALID_HANDLE_VALUE) {\r\n        _tprintf(TEXT(\"[-] Opening the named pipe failed.\\n\"));\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    //\r\n    // Get the named shared memory section mapped.\r\n    //\r\n\r\n    MappedFile = OpenFileMapping(\r\n        FILE_MAP_ALL_ACCESS,\r\n        FALSE,\r\n        ShmName\r\n    );\r\n\r\n    if(MappedFile == NULL) {\r\n        _tprintf(TEXT(\"[-] Opening the file mapping failed.\\n\"));\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    AreaPtr = MapViewOfFile(\r\n        MappedFile,\r\n        FILE_MAP_ALL_ACCESS,\r\n        0,\r\n        0,\r\n        MAP_SIZE\r\n    );\r\n\r\n    if(AreaPtr == NULL) {\r\n        _tprintf(TEXT(\"[-] Mapping a view of the shared memory section failed.\\n\"));\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    //\r\n    // Fix up the instrumented modules so that the pointer storing the base\r\n    // of the coverage map points to the shared memory section we just mapped in.\r\n    // The instrumented code will now write the coverage information directly\r\n    // in the shared section.\r\n    //\r\n\r\n    for(i = 0; i < g_ninstrumented_modules; ++i) {\r\n        g_static_coverage_data[i]->__afl_area_ptr = (PUCHAR)AreaPtr;\r\n    }\r\n\r\n    _tprintf(TEXT(\"[+] Fixed-up the %d instrumented modules.\\n\"), g_ninstrumented_modules);\r\n\r\n    clean:\r\n\r\n    if(g_nofuzzing_mode == FALSE && g_noinstrumentation == TRUE) {\r\n\r\n        //\r\n        // It means there is no instrumented module in the address space,\r\n        // and we are being run through AFL..weird. Display a pop-up!\r\n        //\r\n\r\n        _tprintf(TEXT(\"[-] You are running without instrumentation under afl-fuzz.exe.\\n\"));\r\n\r\n        MessageBox(\r\n            NULL,\r\n            TEXT(\"You are running without instrumentation under afl-fuzz.exe.\"),\r\n            NULL,\r\n            MB_OK | MB_ICONERROR\r\n        );\r\n    }\r\n\r\n    if(MappedFile != NULL) {\r\n        CloseHandle(MappedFile);\r\n    }\r\n\r\n    LeaveCriticalSection(&g_crit_section);\r\n    return Status;\r\n}\r\n\r\nBOOL CALLBACK __afl_set_up_bareminimum(\r\n    PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context\r\n)\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Installs the vectored exception handler to ease reproducability.\r\n    The VEH gets installed even if running without afl-fuzz.exe, or\r\n    if running a non-instrumented module. This is particularly useful\r\n    for debugging issues found by afl-fuzz.exe on a vanilla target (in\r\n    the case the debugging symbols are a bit funky on an instrumented\r\n    binary for example). Also initialize the critical section.\r\n\r\nArguments:\r\n\r\n    InitOnce - Unused.\r\n\r\n    Parameter - Unused.\r\n\r\n    Context - Unused.\r\n\r\nReturn Value:\r\n\r\n    TRUE.\r\n\r\n--*/\r\n\r\n{\r\n    UNREFERENCED_PARAMETER(InitOnce);\r\n    UNREFERENCED_PARAMETER(Parameter);\r\n    UNREFERENCED_PARAMETER(Context);\r\n\r\n    InitializeCriticalSection(&g_crit_section);\r\n\r\n    //\r\n    // Set up the exception handler.\r\n    //\r\n\r\n    AddVectoredExceptionHandler(0, __afl_VectoredHandler);\r\n\r\n    //\r\n    // Display the banner to know the persistent loop is here.\r\n    //\r\n\r\n    __afl_display_banner();\r\n    return TRUE;\r\n}\r\n\r\nBOOL __afl_persistent_loop()\r\n\r\n/*++\r\n\r\nRoutine Description:\r\n\r\n    Persistent loop implementation.\r\n\r\nArguments:\r\n\r\n    None.\r\n\r\nReturn Value:\r\n\r\n    TRUE until the iteration count gets hit, and then FALSE.\r\n\r\n--*/\r\n\r\n{\r\n    BOOL Status;\r\n    CHAR Command = 0;\r\n    DWORD Dummy;\r\n    SIZE_T i = 0;\r\n\r\n    if(g_nofuzzing_mode == TRUE) {\r\n\r\n        //\r\n        // Force exit at the first iteration when afl-fuzz isn't detected\r\n        // to fake \"normal\" execution of instrumented binary.\r\n        //\r\n\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    Status = InitOnceExecuteOnce(\r\n        &g_init_once_bareminimum,\r\n        __afl_set_up_bareminimum,\r\n        NULL,\r\n        NULL\r\n    );\r\n\r\n    Status = InitOnceExecuteOnce(\r\n        &g_init_once,\r\n        __afl_set_it_up,\r\n        NULL,\r\n        NULL\r\n    );\r\n\r\n    if(Status == FALSE) {\r\n        _tprintf(TEXT(\"[+] Enabling the no fuzzing mode.\\n\"));\r\n        g_nofuzzing_mode = TRUE;\r\n        Status = TRUE;\r\n        goto clean;\r\n    }\r\n\r\n    //\r\n    // If this not the first time, it means we have to signal afl-fuzz that\r\n    // the previous test-case ended.\r\n    //\r\n\r\n    if(g_current_iterations > 0) {\r\n        WriteFile(g_winafl_pipe, \"K\", 1, &Dummy, NULL);\r\n    }\r\n\r\n    if(g_current_iterations == g_niterations) {\r\n\r\n        //\r\n        // It is time to stop the machine!\r\n        //\r\n\r\n        CloseHandle(g_winafl_pipe);\r\n        g_winafl_pipe = INVALID_HANDLE_VALUE;\r\n\r\n        UnmapViewOfFile(g_static_coverage_data[0]->__afl_area_ptr);\r\n\r\n        //\r\n        // Redirect the coverage map back into the instrumented binary's\r\n        // .syzyafl section so that the program doesn't crash while exiting.\r\n        //\r\n\r\n        for(i = 0; i < g_ninstrumented_modules; ++i) {\r\n            g_static_coverage_data[i]->__afl_area_ptr = (PUCHAR)g_static_coverage_data[i]->__afl_area;\r\n        }\r\n\r\n        Status = FALSE;\r\n        goto clean;\r\n    }\r\n\r\n    //\r\n    // Tell afl-fuzz that we are ready for the next iteration.\r\n    //\r\n\r\n    WriteFile(g_winafl_pipe, \"P\", 1, &Dummy, NULL);\r\n\r\n    //\r\n    // Wait until we have the go from afl-fuzz to go ahead (below call is blocking).\r\n    //\r\n\r\n    ReadFile(g_winafl_pipe, &Command, 1, &Dummy, NULL);\r\n    if(Command != 'F') {\r\n        if(Command == 'Q') {\r\n            _tprintf(TEXT(\"[+] Received the quit signal, exiting.\\n\"));\r\n        } else {\r\n            _tprintf(TEXT(\"[-] Received an unknown command from afl-fuzz, exiting (%.2x).\\n\"), Command);\r\n        }\r\n\r\n        TerminateProcess(GetCurrentProcess(), 0);\r\n    }\r\n\r\n    clean:\r\n\r\n    g_current_iterations++;\r\n\r\n#ifdef AFL_STATIC_VARIABLE_BEHAVIOR_DEBUG\r\n\r\n    {\r\n        //\r\n        // To ease debugging of variable behavior, we fake a configuration\r\n        // where we run 10 iterations through the persistent loop, and\r\n        // we save to disk the coverage map at every iterations.\r\n        // You can then diff them and understand what parts of the map\r\n        // get changed, and you can then set hardware write access breakpoints\r\n        // to see what is the code writing in the coverage map.\r\n        //\r\n\r\n        FILE *CoverageFile = NULL;\r\n        TCHAR CoverageFilename[MAX_STRING_SIZE];\r\n\r\n        if(g_current_iterations == 1) {\r\n\r\n            //\r\n            // Check various things on the first iteration. This is the\r\n            // only time this block will get executed.\r\n            //\r\n\r\n            //\r\n            // We cannot run in this mode if no instrumentation has been found, as\r\n            // there won't be any coverage map.\r\n            //\r\n\r\n            if(g_noinstrumentation == TRUE) {\r\n                _tprintf(TEXT(\r\n                    \"[-] Cannot run the variable behavior debugging mode without an instrumented module.\\n\"\r\n                ));\r\n                Status = FALSE;\r\n                goto end;\r\n            }\r\n\r\n            //\r\n            // We cannot run in this mode if we are fuzzing right now, display a message\r\n            // box as - most likely - afl-fuzz.exe is sink-holing stdout messages.\r\n            //\r\n\r\n            if(g_nofuzzing_mode == FALSE) {\r\n                MessageBox(\r\n                    NULL,\r\n                    TEXT(\"You are running the target under afl-fuzz.exe with the variable behavior debugging mode.\"),\r\n                    NULL,\r\n                    MB_OK | MB_ICONERROR\r\n                );\r\n                Status = FALSE;\r\n                goto end;\r\n            }\r\n\r\n            //\r\n            // Let the user knows that the variable behavior debugging mode is enabled,\r\n            // and configure the number of iterations.\r\n            //\r\n\r\n            _tprintf(TEXT(\"[+] Enabled the variable behavior debugging mode.\\n\"));\r\n            g_niterations = AFL_VARIABLE_BEHAVIOR_ITERATIONS;\r\n\r\n            //\r\n            // Fix-up all the coverage maps to point into the first one's.\r\n            //\r\n\r\n            for(i = 1; i < g_ninstrumented_modules; ++i) {\r\n                g_static_coverage_data[i]->__afl_area_ptr = (PUCHAR)g_static_coverage_data[0]->__afl_area;\r\n            }\r\n\r\n            if(IsDebuggerPresent()) {\r\n\r\n                //\r\n                // If we are under a debugger, let's give to the user the\r\n                // coverage map base address as it is useful to break on write\r\n                // access to certain bytes in the map to investigate variable\r\n                // behaviors test-cases.\r\n                //\r\n\r\n                _tprintf(\r\n                    TEXT(\"[+] Coverage map base: %p.\\n\"),\r\n                    g_static_coverage_data[0]->__afl_area_ptr\r\n                );\r\n\r\n                //\r\n                // Also breaking so that the user can set its breakpoints before\r\n                // we start running the persistent loop.\r\n                //\r\n\r\n                __debugbreak();\r\n            }\r\n        }\r\n\r\n        //\r\n        // Force the persistent loop to run again if we need it to.\r\n        //\r\n\r\n        if(g_current_iterations == g_niterations) {\r\n\r\n            //\r\n            // We are done!\r\n            //\r\n\r\n            Status = FALSE;\r\n        } else {\r\n\r\n            //\r\n            // Force re-entering the persistent loop again.\r\n            //\r\n\r\n            g_nofuzzing_mode = FALSE;\r\n        }\r\n\r\n        if(g_current_iterations > 1 && !IsDebuggerPresent()) {\r\n\r\n            //\r\n            // Write the coverage map to disk if this is not the first\r\n            // iteration as the instrumented code didn't get a chance\r\n            // to be executed yet. We also don't overwrite the traces if a\r\n            // debugger is attached, as it most likely means that an\r\n            // investigation is on-going.\r\n            //\r\n\r\n            _stprintf_s(\r\n                CoverageFilename, _countof(CoverageFilename),\r\n                AFL_VARIABLE_BEHAVIOR_TRACES_BASE_DIR \"\\\\%u.bin\", g_current_iterations - 1\r\n            );\r\n\r\n            if(_tfopen_s(&CoverageFile, CoverageFilename, TEXT(\"wb\"))) {\r\n                _tprintf(TEXT(\"[-] Cannot open %s.\\n\"), CoverageFilename);\r\n            } else {\r\n                fwrite(g_static_coverage_data[0]->__afl_area_ptr, MAP_SIZE, 1, CoverageFile);\r\n                fclose(CoverageFile);\r\n            }\r\n        }\r\n    }\r\n\r\n    end:\r\n\r\n#endif\r\n\r\n    if(g_noinstrumentation == FALSE) {\r\n\r\n        //\r\n        // Reset the global state only if we have found an instrumented\r\n        // module earlier - otherwise the g_static_coverage_data array\r\n        // is empty.\r\n        //\r\n\r\n        for(i = 0; i < g_ninstrumented_modules; ++i) {\r\n            PUINT32 PerThreadPrevLoc;\r\n            STATIC_COVERAGE_DATA *CurrentCoverageData = g_static_coverage_data[i];\r\n            if(CurrentCoverageData->__tls_slot_offset != 0) {\r\n\r\n                //\r\n                // TLS version if we are fuzzing a multithread instrumented binary.\r\n                //\r\n\r\n                PUINT32 Base = (PUINT32)(__readfsdword(0x2C) + (4 * CurrentCoverageData->__tls_index));\r\n                PerThreadPrevLoc = (PUINT32)(*Base + CurrentCoverageData->__tls_slot_offset);\r\n            } else {\r\n                PerThreadPrevLoc = (PUINT32)(&CurrentCoverageData->__afl_prev_loc);\r\n            }\r\n\r\n            *PerThreadPrevLoc = 0;\r\n        }\r\n\r\n        memset(g_static_coverage_data[0]->__afl_area_ptr, 0, MAP_SIZE);\r\n    }\r\n\r\n#ifdef AFL_STATIC_VARIABLE_BEHAVIOR_DEBUG\r\n\r\n    //\r\n    // Make sure to reinitialize the counter to 0 in order\r\n    // to not exhaust all the slots.\r\n    //\r\n\r\n    g_ninstrumented_modules = 0;\r\n\r\n#endif\r\n\r\n    return Status;\r\n}\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n"
        },
        {
          "name": "afl-staticinstr.h",
          "type": "blob",
          "size": 1.4833984375,
          "content": "/*\r\n   WinAFL persistent loop implementation for statically instrumented target\r\n   -----------------------------------------------------------------------\r\n\r\n   Written by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at:\r\n\r\n     http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   This header is the glue you need to make afl-fuzz and your statically\r\n   instrumented target play nice together.\r\n\r\n   The entry-point __afl_persistent_loop is meant to be called at the start of the harness,\r\n   in a loop like below. The function will set up everything needed to communicate\r\n   and synchronize with afl-fuzz - if it is present (named pipe, shm, etc).\r\n\r\n      while(__afl_persistent_loop()) {\r\n          // init state\r\n          // exercise target\r\n          // clear state\r\n      }\r\n\r\n   If afl-fuzz isn't detected, then the function will simply return TRUE the first\r\n   time so that the body gets executed once.\r\n*/\r\n#pragma once\r\n#include <Windows.h>\r\n#include <stdint.h>\r\n#include <tchar.h>\r\n\r\n#if defined(_M_X64) || defined(__amd64__)\r\n#error Static instrumentation is only available for 32 bit binaries\r\n#endif\r\n\r\n//\r\n// Enable the variable behavior debugging mode.\r\n//\r\n\r\n// #define AFL_STATIC_VARIABLE_BEHAVIOR_DEBUG\r\n\r\n#ifdef __cplusplus\r\nextern \"C\" {\r\n#endif\r\n\r\nBOOL __afl_persistent_loop();\r\n\r\n#ifdef __cplusplus\r\n}\r\n#endif\r\n"
        },
        {
          "name": "afl-tmin.c",
          "type": "blob",
          "size": 38.1455078125,
          "content": "/*\n   american fuzzy lop - test case minimizer\n   ----------------------------------------\n\n   Written and maintained by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\n\n   Copyright 2017 Google Inc. All rights reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at:\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   A simple test case minimizer that takes an input file and tries to remove\n   as much data as possible while keeping the binary in a crashing state\n   *or* producing consistent instrumentation output (the mode is auto-selected\n   based on the initially observed behavior).\n\n */\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRT_RAND_S\n#define AFL_MAIN\n#define VERSION             \"2.51b\"\n\n#include <windows.h>\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n#include \"alloc-inl.h\"\n#include \"hash.h\"\n\n#include <io.h>\n#include <direct.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <errno.h>\n#include <signal.h>\n#include <fcntl.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\nstatic s32 child_pid;                 /* PID of the tested program         */\n\nstatic HANDLE child_handle,\n              child_thread_handle;\nstatic char *dynamorio_dir;\nstatic char *client_params;\nstatic char *winafl_dll_path;\nstatic const char *winafl_dll_path_default = \"winafl.dll\";\nint fuzz_iterations_max = 1, fuzz_iterations_current;\n\nstatic CRITICAL_SECTION critical_section;\nstatic u64 watchdog_timeout_time;\nstatic u8 watchdog_enabled;\nstatic u8 *target_cmd;                /* command line of target           */\n\nstatic u8 *trace_bits,                /* SHM with instrumentation bitmap   */\n          *mask_bitmap;               /* Mask for trace bits (-B)          */\n\nstatic u8 *in_file,                   /* Minimizer input test case         */\n          *out_file,                  /* Minimizer output file             */\n          *prog_in,                   /* Targeted program input file       */\n          *target_path,               /* Path to target binary             */\n          *doc_path,                  /* Path to docs                      */\n          *at_file;                   /* Substitution string for @@        */\n\nstatic u8 *in_data,                   /* Input data for trimming           */\n          *prev_data;                 /* Data of previous attempt          */\n\nstatic u32 in_len,                    /* Input data length                 */\n           prev_len,                  /* Data length of previous attempt   */\n           orig_cksum,                /* Original checksum                 */\n           total_execs,               /* Total number of execs             */\n           missed_hangs,              /* Misses due to hangs               */\n           missed_crashes,            /* Misses due to crashes             */\n           missed_paths,              /* Misses due to exec path diffs     */\n           exec_tmout = EXEC_TIMEOUT; /* Exec timeout (ms)                 */\n           del_len_limit = 1;         /* Minimum block deletion length     */\n\nstatic u64 mem_limit = MEM_LIMIT,     /* Memory limit (MB)                 */\n           start_time;                /* Tick count at the beginning       */\n\nstatic HANDLE shm_handle;             /* Handle of the SHM region         */\nstatic HANDLE pipe_handle;            /* Handle of the name pipe          */\nstatic u64    name_seed;              /* Random integer to have a unique shm/pipe name */\nstatic HANDLE devnul_handle;          /* Handle of the nul device         */\nstatic u8     sinkhole_stds = 1;      /* Sink-hole stdout/stderr messages?*/\nstatic char   *fuzzer_id = NULL;      /* The fuzzer ID or a randomized\n                                         seed allowing multiple instances */\n\nstatic u8  crash_mode,                /* Crash-centric mode?               */\n           exit_crash,                /* Treat non-zero exit as crash?     */\n           edges_only,                /* Ignore hit counts?                */\n           exact_mode,                /* Require path match for crashes?   */\n           no_minimize = 0,           /* Skip minimization phase           */\n           no_normalize = 0,          /* Skip normalization phases         */\n           single_pass = 0,           /* Run only a single pass            */\n           dump_on_abort = 1,         /* Dump partial results to a file on Ctrl+C */\n           use_stdin = 1,             /* Use stdin for program input?      */\n           drioless = 0;\n\nstatic volatile u8\n           stop_soon,                 /* Ctrl-C pressed?                   */\n           child_timed_out;           /* Child timed out?                  */\n\n\n/* Classify tuple counts. This is a slow & naive version, but good enough here. */\n#define AREP4(_sym)   (_sym), (_sym), (_sym), (_sym)\n#define AREP8(_sym)   AREP4(_sym), AREP4(_sym)\n#define AREP16(_sym)  AREP8(_sym), AREP8(_sym)\n#define AREP32(_sym)  AREP16(_sym), AREP16(_sym)\n#define AREP64(_sym)  AREP32(_sym), AREP32(_sym)\n#define AREP128(_sym) AREP64(_sym), AREP64(_sym)\n\nstatic const u8 count_class_lookup[256] = {\n\n  /* 0 - 3:       4 */ 0, 1, 2, 4,\n  /* 4 - 7:      +4 */ AREP4(8),\n  /* 8 - 15:     +8 */ AREP8(16),\n  /* 16 - 31:   +16 */ AREP16(32),\n  /* 32 - 127:  +96 */ AREP64(64), AREP32(64),\n  /* 128+:     +128 */ AREP128(128)\n\n};\n\nstatic void classify_counts(u8* mem) {\n\n  u32 i = MAP_SIZE;\n\n  if (edges_only) {\n\n    while (i--) {\n      if (*mem) *mem = 1;\n      mem++;\n    }\n\n  } else {\n\n    while (i--) {\n      *mem = count_class_lookup[*mem];\n      mem++;\n    }\n\n  }\n\n}\n\n\n/* Apply mask to classified bitmap (if set). */\n\nstatic void apply_mask(u32* mem, u32* mask) {\n\n  u32 i = (MAP_SIZE >> 2);\n\n  if (!mask) return;\n\n  while (i--) {\n\n    *mem &= ~*mask;\n    mem++;\n    mask++;\n\n  }\n\n}\n\n\n/* See if any bytes are set in the bitmap. */\n\nstatic inline u8 anything_set(void) {\n\n  u32* ptr = (u32*)trace_bits;\n  u32  i   = (MAP_SIZE >> 2);\n\n  while (i--) if (*(ptr++)) return 1;\n\n  return 0;\n\n}\n\n\n/* Get unix time in milliseconds */\n\nstatic u64 get_cur_time(void) {\n\n  u64 ret;\n  FILETIME filetime;\n  GetSystemTimeAsFileTime(&filetime);\n\n  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;\n\n  return ret / 10000;\n\n}\n\n\n/* Get unix time in microseconds */\n\nstatic u64 get_cur_time_us(void) {\n\n  u64 ret;\n  FILETIME filetime;\n  GetSystemTimeAsFileTime(&filetime);\n\n  ret = (((u64)filetime.dwHighDateTime)<<32) + (u64)filetime.dwLowDateTime;\n\n  return ret / 10;\n\n}\n\n\nchar *alloc_printf(const char *_str, ...) {\n\n  va_list argptr;\n  char* _tmp;\n  s32 _len;\n\n  va_start(argptr, _str);\n  _len = vsnprintf(NULL, 0, _str, argptr);\n  if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\");\n  _tmp = ck_alloc(_len + 1);\n  vsnprintf(_tmp, (size_t)_len + 1, _str, argptr);\n  va_end(argptr);\n  return _tmp;\n\n}\n\n\n/* Get rid of shared memory and temp files (atexit handler). */\n\nstatic void remove_shm(void) {\n\n  UnmapViewOfFile(trace_bits);\n  CloseHandle(shm_handle);\n  if (prog_in) unlink(prog_in); /* Ignore errors */\n\n}\n\n\n/* Configure shared memory. */\n\nstatic void setup_shm(void) {\n\n  char* shm_str = NULL;\n  unsigned int seeds[2];\n  u64 name_seed;\n  u8 attempts = 0;\n\n  while(attempts < 5) {\n    if(fuzzer_id == NULL) {\n      // If it is null, it means we have to generate a random seed to name the instance\n      rand_s(&seeds[0]);\n      rand_s(&seeds[1]);\n      name_seed = ((u64)seeds[0] << 32) | seeds[1];\n      fuzzer_id = (char *)alloc_printf(\"%I64x\", name_seed);\n    }\n\n    shm_str = (char *)alloc_printf(\"afl_shm_%s\", fuzzer_id);\n\n    shm_handle = CreateFileMapping(\n                   INVALID_HANDLE_VALUE,    // use paging file\n                   NULL,                    // default security\n                   PAGE_READWRITE,          // read/write access\n                   0,                       // maximum object size (high-order DWORD)\n                   MAP_SIZE,                // maximum object size (low-order DWORD)\n                   (char *)shm_str);        // name of mapping object\n\n    if(shm_handle == NULL) {\n      if(GetLastError() == ERROR_ALREADY_EXISTS) {\n        // We need another attempt to find a unique section name\n        attempts++;\n        ck_free(shm_str);\n        ck_free(fuzzer_id);\n        fuzzer_id = NULL;\n        continue;\n      }\n      else {\n        PFATAL(\"CreateFileMapping failed\");\n      }\n    }\n\n    // We found a section name that works!\n    break;\n  }\n\n  if(attempts == 5) {\n    FATAL(\"Could not find a section name.\\n\");\n  }\n\n  atexit(remove_shm);\n\n  ck_free(shm_str);\n\n  trace_bits = (u8 *)MapViewOfFile(\n    shm_handle,          // handle to map object\n    FILE_MAP_ALL_ACCESS, // read/write permission\n    0,\n    0,\n    MAP_SIZE\n  );\n\n  if (!trace_bits) PFATAL(\"MapViewOfFile() failed\");\n\n}\n\n\n/* Read initial file. */\n\nstatic void read_initial_file(void) {\n\n  struct stat st;\n  s32 fd = _open(in_file, O_RDONLY | O_BINARY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", in_file);\n\n  if (fstat(fd, &st) || !st.st_size)\n    FATAL(\"Zero-sized input file.\");\n\n  if (st.st_size >= TMIN_MAX_FILE)\n    FATAL(\"Input file is too large (%u MB max)\", TMIN_MAX_FILE / 1024 / 1024);\n\n  in_len  = st.st_size;\n  in_data = ck_alloc_nozero(in_len);\n  prev_len = -1;\n  prev_data = ck_alloc_nozero(in_len);\n\n  ck_read(fd, in_data, in_len, in_file);\n\n  _close(fd);\n\n  OKF(\"Read %u byte%s from '%s'.\", in_len, in_len == 1 ? \"\" : \"s\", in_file);\n\n}\n\n\n/* Write output file. */\n\nstatic void write_to_file(u8* path, u8* mem, u32 len) {\n\n  s32 ret;\n\n  ret = _open(path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, DEFAULT_PERMISSION);\n\n  if (ret < 0) PFATAL(\"Unable to create '%s'\", path);\n\n  ck_write(ret, mem, len, path);\n\n  _close(ret);\n\n}\n\n//quoting on Windows is weird\nsize_t ArgvQuote(char *in, char *out) {\n  int needs_quoting = 0;\n  size_t size = 0;\n  char *p = in;\n  size_t i;\n\n  //check if quoting is necessary\n  if(strchr(in, ' ')) needs_quoting = 1;\n  if(strchr(in, '\\\"')) needs_quoting = 1;\n  if(strchr(in, '\\t')) needs_quoting = 1;\n  if(strchr(in, '\\n')) needs_quoting = 1;\n  if(strchr(in, '\\v')) needs_quoting = 1;\n  if(!needs_quoting) {\n    size = strlen(in);\n    if(out) memcpy(out, in, size);\n    return size;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  while(*p) {\n    size_t num_backslashes = 0;\n    while((*p) && (*p == '\\\\')) {\n      p++;\n      num_backslashes++;\n    }\n\n    if(*p == 0) {\n      for(i = 0; i < (num_backslashes*2); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      break;\n    } else if(*p == '\\\"') {\n      for(i = 0; i < (num_backslashes*2 + 1); i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    } else {\n      for(i = 0; i < num_backslashes; i++) {\n        if(out) out[size] = '\\\\';\n        size++;\n      }\n      if(out) out[size] = *p;\n      size++;\n    }\n\n    p++;\n  }\n\n  if(out) out[size] = '\\\"';\n  size++;\n\n  return size;\n}\n\n\nchar *argv_to_cmd(char** argv) {\n  u32 len = 0, i;\n  u8* buf, *ret;\n\n  //todo shell-escape\n\n  for (i = 0; argv[i]; i++)\n    len += ArgvQuote(argv[i], NULL) + 1;\n\n  if(!len) FATAL(\"Error creating command line\");\n\n  buf = ret = ck_alloc(len);\n\n  for (i = 0; argv[i]; i++) {\n\n    u32 l = ArgvQuote(argv[i], buf);\n\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  ret[len-1] = 0;\n\n  return ret;\n}\n\n\nstatic void create_target_process(char** argv) {\n  char* cmd;\n  char* pipe_name;\n  char *buf;\n  char *pidfile = NULL;\n  FILE *fp;\n  size_t pidsize;\n  BOOL inherit_handles = TRUE;\n  HANDLE hJob = NULL;\n  JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;\n\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n\n  pipe_name = (char *)alloc_printf(\"\\\\\\\\.\\\\pipe\\\\afl_pipe_%s\", fuzzer_id);\n\n  pipe_handle = CreateNamedPipe(\n    pipe_name,                // pipe name\n    PIPE_ACCESS_DUPLEX,       // read/write access\n    0,\n    1,                        // max. instances\n    512,                      // output buffer size\n    512,                      // input buffer size\n    20000,                    // client time-out\n    NULL);                    // default security attribute\n\n  if (pipe_handle == INVALID_HANDLE_VALUE) {\n    FATAL(\"CreateNamedPipe failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  target_cmd = argv_to_cmd(argv);\n\n  if (drioless) {\n    char *static_config = alloc_printf(\"%s:1\", fuzzer_id);\n\n    if (static_config == NULL) {\n      FATAL(\"Cannot allocate static_config.\");\n    }\n\n    SetEnvironmentVariable(\"AFL_STATIC_CONFIG\", static_config);\n    cmd = alloc_printf(\"%s\", target_cmd);\n    ck_free(static_config);\n  } else {\n    pidfile = alloc_printf(\"childpid_%s.txt\", fuzzer_id);\n    if (winafl_dll_path == NULL) {\n      winafl_dll_path = winafl_dll_path_default;\n    }\n    cmd = alloc_printf(\n      \"%s\\\\drrun.exe -pidfile %s -no_follow_children -c %s %s -fuzz_iterations 1 -fuzzer_id %s -- %s\",\n      dynamorio_dir, pidfile, winafl_dll_path, client_params, fuzzer_id, target_cmd\n    );\n  }\n\n  ZeroMemory(&si, sizeof(si));\n  si.cb = sizeof(si);\n  ZeroMemory(&pi, sizeof(pi));\n\n  if (sinkhole_stds) {\n    si.hStdOutput = si.hStdError = devnul_handle;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n  } else {\n    inherit_handles = FALSE;\n  }\n\n  if (mem_limit != 0) {\n    hJob = CreateJobObject(NULL, NULL);\n    if (hJob == NULL) {\n      FATAL(\"CreateJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    ZeroMemory(&job_limit, sizeof(job_limit));\n    job_limit.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_PROCESS_MEMORY;\n    job_limit.ProcessMemoryLimit = mem_limit * 1024 * 1024;\n\n    if (!SetInformationJobObject(\n      hJob,\n      JobObjectExtendedLimitInformation,\n      &job_limit,\n      sizeof(job_limit)\n    )) {\n      FATAL(\"SetInformationJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  if (!CreateProcess(NULL, cmd, NULL, NULL, inherit_handles, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {\n    FATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\n  }\n\n  child_handle = pi.hProcess;\n  child_thread_handle = pi.hThread;\n\n  if (mem_limit != 0) {\n    if (!AssignProcessToJobObject(hJob, child_handle)) {\n      FATAL(\"AssignProcessToJobObject failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  ResumeThread(child_thread_handle);\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n  watchdog_enabled = 1;\n\n  if (!ConnectNamedPipe(pipe_handle, NULL)) {\n    if (GetLastError() != ERROR_PIPE_CONNECTED) {\n      FATAL(\"ConnectNamedPipe failed, GLE=%d.\\n\", GetLastError());\n    }\n  }\n\n  watchdog_enabled = 0;\n\n  if (drioless == 0) {\n    //by the time pipe has connected the pidfile must have been created\n    fp = fopen(pidfile, \"rb\");\n    if (!fp) {\n      FATAL(\"Error opening pidfile.txt\");\n    }\n    fseek(fp,0,SEEK_END);\n    pidsize = ftell(fp);\n    fseek(fp,0,SEEK_SET);\n    buf = (char *)malloc(pidsize+1);\n    if (!buf) {\n        FATAL(\"Error allocating %Iu bytes\", pidsize + 1);\n    }\n    fread(buf, pidsize, 1, fp);\n    buf[pidsize] = 0;\n    fclose(fp);\n    remove(pidfile);\n    child_pid = atoi(buf);\n    free(buf);\n    ck_free(pidfile);\n  }\n  else {\n    child_pid = pi.dwProcessId;\n  }\n\n  ck_free(target_cmd);\n  ck_free(cmd);\n  ck_free(pipe_name);\n}\n\n\nstatic void destroy_target_process(int wait_exit) {\n  char* kill_cmd;\n  BOOL still_alive = TRUE;\n  STARTUPINFO si;\n  PROCESS_INFORMATION pi;\n  BOOL no_hang = (wait_exit == -1);\n\n  // Hack, to allow telling this function not to hang.\n  // If the target process is terminating and still has pending I/O, it won't actually finish.\n  //  Calling DisconnectNamedPipe or CloseHandle on the pipe handle may hang indefinitely.\n  //  Skipping those calls might leak the target process (for a while or indefinitely),\n  //  but at least the current process would be allowed to finish.\n  if (wait_exit == -1) {\n    wait_exit = 0;\n  }\n  EnterCriticalSection(&critical_section);\n\n  if(!child_handle) {\n    goto leave;\n  }\n\n  if(WaitForSingleObject(child_handle, wait_exit) != WAIT_TIMEOUT) {\n    goto done;\n  }\n\n  // nudge the child process only if dynamorio is used\n  if(drioless) {\n    TerminateProcess(child_handle, 0);\n  } else {\n    kill_cmd = alloc_printf(\"%s\\\\drconfig.exe -nudge_pid %d 0 1\", dynamorio_dir, child_pid);\n\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n\n    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n      FATAL(\"CreateProcess(drconfig) failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    ck_free(kill_cmd);\n  }\n\n  still_alive = WaitForSingleObject(child_handle, 2000) == WAIT_TIMEOUT;\n\n  if(still_alive) {\n    //wait until the child process exits\n    ZeroMemory( &si, sizeof(si) );\n    si.cb = sizeof(si);\n    ZeroMemory( &pi, sizeof(pi) );\n\n    kill_cmd = alloc_printf(\"taskkill /PID %d /F\", child_pid);\n\n    if(!CreateProcess(NULL, kill_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n      FATAL(\"CreateProcess(taskkill) failed, GLE=%d.\\n\", GetLastError());\n    }\n\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    ck_free(kill_cmd);\n\n    if(WaitForSingleObject(child_handle, 20000) == WAIT_TIMEOUT) {\n      FATAL(\"Cannot kill child process\\n\");\n    }\n  }\n\n  done:\n  CloseHandle(child_handle);\n  CloseHandle(child_thread_handle);\n\n  child_handle = NULL;\n  child_thread_handle = NULL;\n\n  leave:\n  //close the pipe\n  if(pipe_handle) {\n    if (!no_hang) {\n      DisconnectNamedPipe(pipe_handle);\n      CloseHandle(pipe_handle);\n    }\n\n    pipe_handle = NULL;\n  }\n\n  LeaveCriticalSection(&critical_section);\n}\n\n\nDWORD WINAPI watchdog_timer( LPVOID lpParam ) {\n  u64 current_time;\n  while(1) {\n    Sleep(1000);\n    current_time = get_cur_time();\n    if(watchdog_enabled && (current_time > watchdog_timeout_time)) {\n      child_timed_out = 1;\n      destroy_target_process(0);\n    }\n  }\n}\n\n\nstatic void setup_watchdog_timer() {\n  watchdog_enabled = 0;\n  InitializeCriticalSection(&critical_section);\n  CreateThread(NULL, 0, watchdog_timer, 0, 0, NULL);\n}\n\n\nstatic int is_child_running() {\n   return (child_handle && (WaitForSingleObject(child_handle, 0 ) == WAIT_TIMEOUT));\n}\n\n\n/* Execute target application. Returns 0 if the changes are a dud, or\n   1 if they should be kept. */\n\nstatic u8 run_target(char** argv, u8* mem, u32 len, u8 first_run) {\n\n  char command[] = \"F\";\n  DWORD num_read;\n  char result = 0;\n  u8 child_crashed;\n  u32 cksum;\n\n  // Skip run if buffer is identical to previous run\n  if ((len == prev_len) && (0 == memcmp(prev_data, mem, len))) return 0;\n\n  prev_len = len;\n  memcpy(prev_data, mem, len);\n\n  write_to_file(prog_in, mem, len);\n\n  if(!is_child_running()) {\n    destroy_target_process(0);\n    create_target_process(argv);\n    fuzz_iterations_current = 0;\n  }\n\n  child_timed_out = 0;\n  memset(trace_bits, 0, MAP_SIZE);\n  MemoryBarrier();\n\n  //TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  if (result == 'K')\n  {\n\t  //a workaround for first cycle\n\t  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n  }\n  if (result != 'P')\n  {\n      if (result == 0) {\n          FATAL(\"Reading from pipe failed! GLE=%lu\\n\", GetLastError()); // This may happen if the target process crashes before reaching the target function\n      }\n\t  FATAL(\"Unexpected result from pipe! expected 'P', instead received '%c'\\n\", result);\n  }\n  //END OF TEMPORARY FIX FOR REGULAR USAGE OF AFL-TMIN\n  WriteFile(\n    pipe_handle,  // handle to pipe\n    command,      // buffer to write from\n    1,            // number of bytes to write\n    &num_read,    // number of bytes written\n    NULL);        // not overlapped I/O\n\n  watchdog_timeout_time = get_cur_time() + exec_tmout;\n\n  if(exec_tmout) {\n    watchdog_enabled = 1;\n  }\n\n  ReadFile(pipe_handle, &result, 1, &num_read, NULL);\n\n  if(exec_tmout) {\n    watchdog_enabled = 0;\n  }\n\n  MemoryBarrier();\n\n  /* Clean up bitmap, analyze exit condition, etc. */\n\n  classify_counts(trace_bits);\n  apply_mask((u32*)trace_bits, (u32*)mask_bitmap);\n  total_execs++;\n  fuzz_iterations_current++;\n\n  if(fuzz_iterations_current == fuzz_iterations_max) {\n    destroy_target_process(2000);\n  }\n\n  if (stop_soon) {\n    SAYF(cRST cLRD \"\\n+++ Minimization aborted by user +++\\n\" cRST);\n    Sleep(200); // Allow time to dump partial results\n    exit(1);\n  }\n\n  child_crashed = result == 'C';\n\n  /* Always discard inputs that time out. */\n\n  if (child_timed_out) {\n\n    missed_hangs++;\n    return 0;\n\n  }\n\n  /* Handle crashing inputs depending on current mode. */\n\n  if (child_crashed) {\n\n    if (first_run) crash_mode = 1;\n\n    if (crash_mode) {\n\n      if (!exact_mode) return 1;\n\n    } else {\n\n      missed_crashes++;\n      return 0;\n\n    }\n\n  } else\n\n  /* Handle non-crashing inputs appropriately. */\n\n  if (crash_mode) {\n\n    missed_paths++;\n    return 0;\n\n  }\n\n  cksum = hash32(trace_bits, MAP_SIZE, HASH_CONST);\n  if (first_run) orig_cksum = cksum;\n\n  if (orig_cksum == cksum) return 1;\n\n  missed_paths++;\n  return 0;\n\n}\n\n\n/* Find first power of two greater or equal to val. */\n\nstatic u32 next_p2(u32 val) {\n\n  u32 ret = 1;\n  while (val > ret) ret <<= 1;\n  return ret;\n\n}\n\n\n/* Actually minimize! */\n\nstatic void minimize(char** argv) {\n\n  static u32 alpha_map[256];\n\n  u8* tmp_buf = ck_alloc_nozero(in_len);\n  u32 orig_len = in_len, stage_o_len;\n\n  u32 del_len, set_len, del_pos, set_pos, i, alpha_size, cur_pass = 0;\n  u32 syms_removed, alpha_del0 = 0, alpha_del1, alpha_del2, alpha_d_total = 0;\n  u8  changed_any, prev_del;\n\n  /***********************\n   * BLOCK NORMALIZATION *\n   ***********************/\n\n  if (no_normalize) goto next_pass;\n  set_len    = next_p2(in_len / TMIN_SET_STEPS);\n  set_pos    = 0;\n\n  if (set_len < TMIN_SET_MIN_SIZE) set_len = TMIN_SET_MIN_SIZE;\n\n  ACTF(cBRI \"Stage #0: \" cRST \"One-time block normalization...\");\n\n  while (set_pos < in_len) {\n\n    u8  res;\n    u32 use_len = MIN(set_len, in_len - set_pos);\n\n    for (i = 0; i < use_len; i++)\n      if (in_data[set_pos + i] != '0') break;\n\n    if (i != use_len) {\n\n      memcpy(tmp_buf, in_data, in_len);\n      memset(tmp_buf + set_pos, '0', use_len);\n\n      res = run_target(argv, tmp_buf, in_len, 0);\n\n      if (res) {\n\n        memset(in_data + set_pos, '0', use_len);\n        changed_any = 1;\n        alpha_del0 += use_len;\n\n      }\n\n    }\n\n    set_pos += set_len;\n\n  }\n\n  alpha_d_total += alpha_del0;\n\n  OKF(\"Block normalization complete, %u byte%s replaced.\", alpha_del0,\n      alpha_del0 == 1 ? \"\" : \"s\");\n\nnext_pass:\n\n  ACTF(cYEL \"--- \" cBRI \"Pass #%u \" cYEL \"---\", ++cur_pass);\n  changed_any = 0;\n\n  /******************\n   * BLOCK DELETION *\n   ******************/\n\n  if (no_minimize) goto alphabet_minimization;\n  del_len = next_p2(in_len / TRIM_START_STEPS);\n  stage_o_len = in_len;\n\n  ACTF(cBRI \"Stage #1: \" cRST \"Removing blocks of data...\");\n\nnext_del_blksize:\n\n  if (!del_len) del_len = 1;\n  del_pos  = 0;\n  prev_del = 1;\n\n  SAYF(cGRA \"    Block length = %u, remaining size = %u\\n\" cRST,\n       del_len, in_len);\n\n  while (del_pos < in_len) {\n\n    u8  res;\n    s32 tail_len;\n\n    tail_len = in_len - del_pos - del_len;\n    if (tail_len < 0) tail_len = 0;\n\n    /* If we have processed at least one full block (initially, prev_del == 1),\n       and we did so without deleting the previous one, and we aren't at the\n       very end of the buffer (tail_len > 0), and the current block is the same\n       as the previous one... skip this step as a no-op. */\n\n    if (!prev_del && tail_len && !memcmp(in_data + del_pos - del_len,\n        in_data + del_pos, del_len)) {\n\n      del_pos += del_len;\n      continue;\n\n    }\n\n    prev_del = 0;\n\n    /* Head */\n    memcpy(tmp_buf, in_data, del_pos);\n\n    /* Tail */\n    memcpy(tmp_buf + del_pos, in_data + del_pos + del_len, tail_len);\n\n    res = run_target(argv, tmp_buf, del_pos + tail_len, 0);\n\n    if (res) {\n\n      memcpy(in_data, tmp_buf, (size_t)del_pos + tail_len);\n      prev_del = 1;\n      in_len   = del_pos + tail_len;\n\n      changed_any = 1;\n\n    } else del_pos += del_len;\n\n  }\n\n  if (del_len > del_len_limit && in_len >= 1) {\n\n    del_len /= 2;\n    goto next_del_blksize;\n\n  }\n\n  OKF(\"Block removal complete, %u bytes deleted.\", stage_o_len - in_len);\n\n  if (!in_len && changed_any)\n    WARNF(cLRD \"Down to zero bytes - check the command line and mem limit!\" cRST);\n\n  if (cur_pass > 1 && !changed_any) goto finalize_all;\n\n  /*************************\n   * ALPHABET MINIMIZATION *\n   *************************/\n\nalphabet_minimization:\n  if (no_normalize) goto finalize_all;\n  alpha_size   = 0;\n  alpha_del1   = 0;\n  syms_removed = 0;\n\n  memset(alpha_map, 0, 256 * sizeof(u32));\n\n  for (i = 0; i < in_len; i++) {\n    if (!alpha_map[in_data[i]]) alpha_size++;\n    alpha_map[in_data[i]]++;\n  }\n\n  ACTF(cBRI \"Stage #2: \" cRST \"Minimizing symbols (%u code point%s)...\",\n       alpha_size, alpha_size == 1 ? \"\" : \"s\");\n\n  for (i = 0; i < 256; i++) {\n\n    u32 r;\n    u8 res;\n\n    if (i == '0' || !alpha_map[i]) continue;\n\n    memcpy(tmp_buf, in_data, in_len);\n\n    for (r = 0; r < in_len; r++)\n      if (tmp_buf[r] == i) tmp_buf[r] = '0';\n\n    res = run_target(argv, tmp_buf, in_len, 0);\n\n    if (res) {\n\n      memcpy(in_data, tmp_buf, in_len);\n      syms_removed++;\n      alpha_del1 += alpha_map[i];\n      changed_any = 1;\n\n    }\n\n  }\n\n  alpha_d_total += alpha_del1;\n\n  OKF(\"Symbol minimization finished, %u symbol%s (%u byte%s) replaced.\",\n      syms_removed, syms_removed == 1 ? \"\" : \"s\",\n      alpha_del1, alpha_del1 == 1 ? \"\" : \"s\");\n\n  /**************************\n   * CHARACTER MINIMIZATION *\n   **************************/\n\n  alpha_del2 = 0;\n\n  ACTF(cBRI \"Stage #3: \" cRST \"Character minimization...\");\n\n  memcpy(tmp_buf, in_data, in_len);\n\n  for (i = 0; i < in_len; i++) {\n\n    u8 res, orig = tmp_buf[i];\n\n    if (orig == '0') continue;\n    tmp_buf[i] = '0';\n\n    res = run_target(argv, tmp_buf, in_len, 0);\n\n    if (res) {\n\n      in_data[i] = '0';\n      alpha_del2++;\n      changed_any = 1;\n\n    } else tmp_buf[i] = orig;\n\n  }\n\n  alpha_d_total += alpha_del2;\n\n  OKF(\"Character minimization done, %u byte%s replaced.\",\n      alpha_del2, alpha_del2 == 1 ? \"\" : \"s\");\n\n  if (changed_any && !single_pass) goto next_pass;\n\nfinalize_all:\n\n  SAYF(\"\\n\"\n       cGRA \"      Finished minimizing : \" cRST \"%hs\\n\"\n       cGRA \"     File size reduced by : \" cRST \"%0.02f%% (to %u byte%s)\\n\"\n       cGRA \"    Characters simplified : \" cRST \"%0.02f%%\\n\"\n       cGRA \"     Number of execs done : \" cRST \"%u\\n\"\n       cGRA \"          Fruitless execs : \" cRST \"path=%u crash=%u hang=%s%u\\n\"\n       cGRA \"             Elapsed time : \" cRST \"%.3f secs\\n\\n\",\n       in_file,\n       100 - ((double)in_len) * 100 / orig_len, in_len, in_len == 1 ? \"\" : \"s\",\n       ((double)(alpha_d_total)) * 100 / (in_len ? in_len : 1),\n       total_execs,\n       missed_paths, missed_crashes, missed_hangs ? cLRD : \"\", missed_hangs,\n       (GetTickCount64() - start_time) / 1000.0);\n\n  if (total_execs > 50 && missed_hangs * 10 > total_execs)\n    WARNF(cLRD \"Frequent timeouts - results may be skewed.\" cRST);\n\n}\n\n\n/* Do basic preparations - persistent fds, filenames, etc. */\n\nstatic void set_up_environment(void) {\n\n  if (sinkhole_stds) {\n    devnul_handle = CreateFile(\n      \"nul\",\n      GENERIC_READ | GENERIC_WRITE,\n      FILE_SHARE_READ | FILE_SHARE_WRITE,\n      NULL,\n      OPEN_EXISTING,\n      0,\n      NULL\n    );\n\n    if (devnul_handle == INVALID_HANDLE_VALUE) {\n      PFATAL(\"Unable to open the nul device.\");\n    }\n  }\n\n  if (!prog_in) {\n\n    u8* use_dir = getenv(\"TMP\");\n    prog_in = alloc_printf(\"%s\\\\.afl-tmin-temp-%u\", use_dir, getpid());\n\n  }\n\n}\n\n\n/* Handle stop signal (Ctrl-C, etc). */\n\nstatic void handle_stop_sig(int sig) {\n\n  u8 dump_path[MAX_PATH];\n  DWORD num_read = 0;\n\n  stop_soon = 1;\n\n  destroy_target_process(-1);\n\n  if (dump_on_abort) {\n    // Dump to a file whatever was achieved so far - even if we're not done\n    strcpy_s(dump_path, MAX_PATH, out_file);\n    strcat_s(dump_path, MAX_PATH, \".dmp\");\n\n    write_to_file(dump_path, in_data, in_len);\n\n    ACTF(\"Dumped partially-minimized file to: %hs\", dump_path);\n  }\n  Sleep(200); // Allow time for other cleanup\n\n  exit(1);\n\n}\n\n\n/* Setup signal handlers, duh. */\n\nstatic void setup_signal_handlers(void) {\n  signal(SIGINT, handle_stop_sig);\n  //signal(SIGTERM, handle_stop_sig);\n  //signal(SIGBREAK, handle_stop_sig);\n  //signal(SIGABRT, handle_stop_sig);\n}\n\n\n/* Detect @@ in args. */\n\nstatic void detect_file_args(char** argv) {\n\n  u32 i = 0;\n  u8* cwd = getcwd(NULL, 0);\n\n  if (!cwd) PFATAL(\"getcwd() failed\");\n\n  while (argv[i]) {\n\n    u8* aa_loc = strstr(argv[i], \"@@\");\n\n    if (aa_loc) {\n\n      u8 *aa_subst, *n_arg;\n\n      aa_subst = prog_in;\n\n      /* Construct a replacement argv value. */\n\n      *aa_loc = 0;\n      n_arg = alloc_printf(\"%s%s%s\", argv[i], aa_subst, aa_loc + 2);\n      argv[i] = n_arg;\n      *aa_loc = '@';\n\n      //if (out_file[0] != '\\\\') ck_free(aa_subst);\n\n    }\n\n    i++;\n\n  }\n\n  free(cwd); /* not tracked */\n\n}\n\n\n/* Display usage hints. */\n\nstatic void usage(u8* argv0) {\n\n  SAYF(\"\\n%s [ options ] -- [instrumentation options] -- \\\\path\\\\to\\\\target_app [ ... ]\\n\\n\"\n\n       \"Required parameters:\\n\\n\"\n\n       \"  -i file       - input test case to be shrunk by the tool\\n\"\n       \"  -o file       - final output location for the minimized data\\n\\n\"\n\n       \"Instrumentation type:\\n\\n\"\n       \"  -D dir        - directory with DynamoRIO binaries (drrun, drconfig)\\n\"\n       \"  -w winafl     - Path to winafl.dll\\n\"\n       \"  -Y            - enable the static instrumentation mode\\n\\n\"\n\n       \"Execution control settings:\\n\\n\"\n\n       \"  -f file       - input file read by the tested program (stdin)\\n\"\n       \"  -t msec       - timeout for each run (%u ms)\\n\"\n       \"  -m megs       - memory limit for child process (%u MB)\\n\"\n\n       \"Minimization settings:\\n\\n\"\n\n       \"  -e            - solve for edge coverage only, ignore hit counts\\n\"\n       \"  -l bytes      - set minimum block deletion length to speed up minimization\\n\"\n       \"  -x            - treat non-zero exit codes as crashes\\n\"\n       \"  -N            - only normalize, skip length minimization. Implies -S\\n\"\n       \"  -M            - only minimize length, skip normalization. Implies -S\\n\"\n       \"  -S            - single pass only\\n\\n\"\n\n       \"Other stuff:\\n\\n\"\n\n       \"  -V            - show version number and exit\\n\\n\"\n\n       \"For additional tips, please consult %s/README.\\n\\n\",\n\n       argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);\n\n  exit(1);\n\n}\n\n\n/* Find binary. */\n\nstatic void find_binary(u8* fname) {\n  // Not implemented on Windows\n}\n\n\n/* Read mask bitmap from file. This is for the -B option. */\n\nstatic void read_bitmap(u8* fname) {\n\n  s32 fd = _open(fname, O_RDONLY | O_BINARY);\n\n  if (fd < 0) PFATAL(\"Unable to open '%s'\", fname);\n\n  ck_read(fd, mask_bitmap, MAP_SIZE, fname);\n\n  _close(fd);\n\n}\n\nstatic unsigned int optind;\nstatic char *optarg;\n\nint getopt(int argc, char **argv, char *optstring) {\n  char *c;\n\n  optarg = NULL;\n\n  while(1) {\n    if(optind == argc) return -1;\n    if(strcmp(argv[optind], \"--\") == 0) return -1;\n    if(argv[optind][0] != '-') {\n      optind++;\n      continue;\n    }\n    if(!argv[optind][1]) {\n      optind++;\n      continue;\n    }\n\n    c = strchr(optstring, argv[optind][1]);\n    if(!c) return -1;\n    optind++;\n    if(c[1] == ':') {\n      if(optind == argc) return -1;\n      optarg = argv[optind];\n      optind++;\n    }\n\n    return (int)(c[0]);\n  }\n}\n\n\nstatic void extract_client_params(u32 argc, char** argv) {\n  u32 len = 1, i;\n  u32 nclientargs = 0;\n  u8* buf;\n  u32 opt_start, opt_end;\n\n  if(!argv[optind] || optind >= argc) usage(argv[0]);\n  if(strcmp(argv[optind],\"--\")) usage(argv[0]);\n\n  if(drioless) return;\n  optind++;\n  opt_start = optind;\n\n  for (i = optind; i < argc; i++) {\n    if(strcmp(argv[i],\"--\") == 0) break;\n    nclientargs++;\n    len += strlen(argv[i]) + 1;\n  }\n\n  if(i == argc) usage(argv[0]);\n  opt_end = i;\n\n  buf = client_params = ck_alloc(len);\n\n  for (i = opt_start; i < opt_end; i++) {\n\n    u32 l = strlen(argv[i]);\n\n    memcpy(buf, argv[i], l);\n    buf += l;\n\n    *(buf++) = ' ';\n  }\n\n  if(buf != client_params) {\n    buf--;\n  }\n\n  *buf = 0;\n\n  optind = opt_end;\n\n}\n\n\n/* Main entry point */\n\nint main(int argc, char** argv) {\n\n  s32 opt;\n  u8  mem_limit_given = 0, timeout_given = 0, del_limit_given = 0;\n  char** use_argv;\n  errno_t status;\n\n  start_time = GetTickCount64();\n  doc_path = \"docs\";\n  optind = 1;\n  dynamorio_dir = NULL;\n  client_params = NULL;\n  winafl_dll_path = NULL;\n\n#ifdef USE_COLOR\n  enable_ansi_console();\n#endif\n\n  SAYF(cCYA \"afl-tmin for Windows \" cBRI VERSION cRST \" by <0vercl0k@tuxfamily.org>\\n\");\n  SAYF(\"Based on WinAFL \" cBRI VERSION cRST \" by <ifratric@google.com>\\n\");\n  SAYF(\"Based on AFL \" cBRI VERSION cRST \" by <lcamtuf@google.com>\\n\");\n\n  while ((opt = getopt(argc,argv,\"+i:o:w:f:m:t:B:D:l:xeQYVNMS\")) > 0)\n\n    switch (opt) {\n\n      case 'D': /* dynamorio dir */\n\n        if(dynamorio_dir) FATAL(\"Multiple -D options not supported\");\n        dynamorio_dir = optarg;\n        break;\n\n      case 'i':\n\n        if (in_file) FATAL(\"Multiple -i options not supported\");\n        in_file = optarg;\n        break;\n\n      case 'o':\n\n        if (out_file) FATAL(\"Multiple -o options not supported\");\n        out_file = optarg;\n        status = _access_s(out_file, 2); // Check writability\n        if (status != 0 && GetLastError() != ERROR_FILE_NOT_FOUND)\n        {\n            if (status == ENOENT && GetLastError() == ERROR_PATH_NOT_FOUND) FATAL(\"Output folder doesn't exist\");\n            FATAL(\"Output path not writable. status=%d, GLE=%lu\", status, GetLastError());\n        }\n        break;\n\n      case 'w': /* winafl.dll path */\n\n        if (winafl_dll_path) FATAL(\"Multiple -w options not supported\");\n        winafl_dll_path = optarg;\n        break;\n\n      case 'f':\n\n        if (prog_in) FATAL(\"Multiple -f options not supported\");\n        use_stdin = 0;\n        prog_in   = optarg;\n        break;\n\n      case 'e':\n\n        if (edges_only) FATAL(\"Multiple -e options not supported\");\n        edges_only = 1;\n        break;\n\n      case 'x':\n\n        if (exit_crash) FATAL(\"Multiple -x options not supported\");\n        exit_crash = 1;\n        break;\n\n      case 'm': {\n\n          u8 suffix = 'M';\n\n          if (mem_limit_given) FATAL(\"Multiple -m options not supported\");\n          mem_limit_given = 1;\n\n          if (!strcmp(optarg, \"none\")) {\n\n            mem_limit = 0;\n            break;\n\n          }\n\n          if (sscanf(optarg, \"%llu%c\", &mem_limit, &suffix) < 1 ||\n              optarg[0] == '-') FATAL(\"Bad syntax used for -m\");\n\n          switch (suffix) {\n\n            case 'T': mem_limit *= 1024 * 1024; break;\n            case 'G': mem_limit *= 1024; break;\n            case 'k': mem_limit /= 1024; break;\n            case 'M': break;\n\n            default:  FATAL(\"Unsupported suffix or bad syntax for -m\");\n\n          }\n\n          if (mem_limit < 5) FATAL(\"Dangerously low value of -m\");\n\n          if (sizeof(int) == 4 && mem_limit > 2000)\n            FATAL(\"Value of -m out of range on 32-bit systems\");\n\n        }\n\n        break;\n\n      case 't':\n\n        if (timeout_given) FATAL(\"Multiple -t options not supported\");\n        timeout_given = 1;\n\n        exec_tmout = atoi(optarg);\n\n        if (exec_tmout < 10 || optarg[0] == '-')\n          FATAL(\"Dangerously low value of -t\");\n\n        break;\n\n      case 'l':\n        if (del_limit_given) FATAL(\"Multiple -l options not supported\");\n        del_limit_given = 1;\n\n        if (no_minimize) FATAL(\"-M and -l incompatible\");\n\n        if (!optarg) FATAL(\"Wrong usage of -l\");\n        if (optarg[0] == '-') FATAL(\"Dangerously low value of -l\");\n\n        del_len_limit = atoi(optarg);\n        if (del_len_limit < 1 || del_len_limit > TMIN_MAX_FILE) FATAL(\"Value of -l out of range between 1 and TMIN_MAX_FILE\");\n\n        break;\n\n      case 'B': /* load bitmap */\n\n        /* This is a secret undocumented option! It is speculated to be useful\n           if you have a baseline \"boring\" input file and another \"interesting\"\n           file you want to minimize.\n\n           You can dump a binary bitmap for the boring file using\n           afl-showmap -b, and then load it into afl-tmin via -B. The minimizer\n           will then minimize to preserve only the edges that are unique to\n           the interesting input file, but ignoring everything from the\n           original map.\n\n           The option may be extended and made more official if it proves\n           to be useful. */\n\n        if (mask_bitmap) FATAL(\"Multiple -B options not supported\");\n        mask_bitmap = ck_alloc(MAP_SIZE);\n        read_bitmap(optarg);\n        break;\n\n      case 'Q':\n        FATAL(\"QEMU mode not supported on Windows\");\n        break;\n\n      case 'Y':\n\n        if (dynamorio_dir) FATAL(\"Dynamic-instrumentation via DRIO is uncompatible with static-instrumentation\");\n        drioless = 1;\n\n        break;\n\n      case 'V': /* Show version number */\n\n        /* Version number has been printed already, just quit. */\n        exit(0);\n\n      case 'N':\n\n        if (no_minimize) FATAL(\"Multiple -N options not supported\");\n        if (no_normalize) FATAL(\"-N and -M mutually exclusive\");\n        no_minimize = 1;\n        break;\n\n      case 'M':\n\n        if (no_normalize) FATAL(\"Multiple -M options not supported\");\n        if (no_minimize) FATAL(\"-N and -M mutually exclusive\");\n        if (del_limit_given) FATAL(\"-M and -l incompatible\");\n        no_normalize = 1;\n        break;\n\n      case 'S':\n\n        if (single_pass) FATAL(\"Multiple -S options not supported\");\n        single_pass = 1;\n        break;\n\n\n      default:\n\n        usage(argv[0]);\n\n    }\n\n  if(!in_file || !out_file) usage(argv[0]);\n  if(!drioless) {\n    if(optind == argc || !dynamorio_dir) usage(argv[0]);\n  }\n  if (no_normalize || no_minimize) single_pass = 1;\n\n  extract_client_params(argc, argv);\n  optind++;\n\n  if (getenv(\"AFL_NO_SINKHOLE\")) sinkhole_stds = 0;\n  if (getenv(\"AFL_TMIN_EXACT\")) exact_mode = 1;\n  if (getenv(\"AFL_TMIN_DONT_DUMP_ON_ABORT\")) dump_on_abort = 0;\n\n  setup_shm();\n  setup_watchdog_timer();\n\n  set_up_environment();\n\n  find_binary(argv[optind]);\n  detect_file_args(argv + optind);\n\n  use_argv = argv + optind;\n\n  SAYF(\"\\n\");\n\n  read_initial_file();\n  setup_signal_handlers();\n\n  ACTF(\"Performing dry run (mem limit = %llu MB, timeout = %u ms%s)...\",\n       mem_limit, exec_tmout, edges_only ? \", edges only\" : \"\");\n\n  run_target(use_argv, in_data, in_len, 1);\n\n  if (child_timed_out)\n    FATAL(\"Target binary times out (adjusting -t may help).\");\n\n  if (!crash_mode) {\n\n     OKF(\"Program terminates normally, minimizing in \"\n         cCYA \"instrumented\" cRST \" mode.\");\n\n     if (!anything_set()) FATAL(\"No instrumentation detected.\");\n\n  } else {\n\n     OKF(\"Program exits with a signal, minimizing in \" cMGN \"%scrash\" cRST\n         \" mode.\", exact_mode ? \"EXACT \" : \"\");\n\n  }\n\n  minimize(use_argv);\n\n  ACTF(\"Writing output to '%s'...\", out_file);\n\n  unlink(prog_in);\n  prog_in = NULL;\n\n  write_to_file(out_file, in_data, in_len);\n\n  OKF(\"We're done here. Have a nice day!\\n\");\n\n  exit(0);\n\n}\n"
        },
        {
          "name": "afl_docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "afl_post_library",
          "type": "tree",
          "content": null
        },
        {
          "name": "alloc-inl.h",
          "type": "blob",
          "size": 12.48046875,
          "content": "/*\n   american fuzzy lop - error-checking, memory-zeroing alloc routines\n   ------------------------------------------------------------------\n\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\n#ifndef _HAVE_ALLOC_INL_H\n#define _HAVE_ALLOC_INL_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"config.h\"\n#include \"types.h\"\n#include \"debug.h\"\n\n/* User-facing macro to sprintf() to a dynamically allocated buffer. */\n/*\n#define alloc_printf(_str, ...) ({ \\\n    u8* _tmp; \\\n    s32 _len = snprintf(NULL, 0, _str); \\\n    if (_len < 0) FATAL(\"Whoa, snprintf() fails?!\"); \\\n    _tmp = ck_alloc(_len + 1); \\\n    snprintf((char*)_tmp, _len + 1, _str); \\\n    _tmp; \\\n  })\n*/\n\n/* Macro to enforce allocation limits as a last-resort defense against\n   integer overflows. */\n\n#define ALLOC_CHECK_SIZE(_s) do { \\\n    if ((_s) > MAX_ALLOC) \\\n      ABORT(\"Bad alloc request: %u bytes\", (_s)); \\\n  } while (0)\n\n/* Macro to check malloc() failures and the like. */\n\n#define ALLOC_CHECK_RESULT(_r, _s) do { \\\n    if (!(_r)) \\\n      ABORT(\"Out of memory: can't allocate %u bytes\", (_s)); \\\n  } while (0)\n\n/* Magic tokens used to mark used / freed chunks. */\n\n#define ALLOC_MAGIC_C1  0xFF00FF00 /* Used head (dword)  */\n#define ALLOC_MAGIC_F   0xFE00FE00 /* Freed head (dword) */\n#define ALLOC_MAGIC_C2  0xF0       /* Used tail (byte)   */\n\n/* Positions of guard tokens in relation to the user-visible pointer. */\n\n#define ALLOC_C1(_ptr)  (((u32*)(_ptr))[-2])\n#define ALLOC_S(_ptr)   (((u32*)(_ptr))[-1])\n#define ALLOC_C2(_ptr)  (((u8*)(_ptr))[ALLOC_S(_ptr)])\n\n#define ALLOC_OFF_HEAD  8\n#define ALLOC_OFF_TOTAL (ALLOC_OFF_HEAD + 1)\n\n/* Allocator increments for ck_realloc_block(). */\n\n#define ALLOC_BLK_INC    256\n\n/* Sanity-checking macros for pointers. */\n\n#define CHECK_PTR(_p) do { \\\n    if (_p) { \\\n      if (ALLOC_C1(_p) ^ ALLOC_MAGIC_C1) {\\\n        if (ALLOC_C1(_p) == ALLOC_MAGIC_F) \\\n          ABORT(\"Use after free.\"); \\\n        else ABORT(\"Corrupted head alloc canary.\"); \\\n      } \\\n      if (ALLOC_C2(_p) ^ ALLOC_MAGIC_C2) \\\n        ABORT(\"Corrupted tail alloc canary.\"); \\\n    } \\\n  } while (0)\n\n#define CHECK_PTR_EXPR(_p) ({ \\\n    typeof (_p) _tmp = (_p); \\\n    CHECK_PTR(_tmp); \\\n    _tmp; \\\n  })\n\n\n/* Allocate a buffer, explicitly not zeroing it. Returns NULL for zero-sized\n   requests. */\n\nstatic inline void* DFL_ck_alloc_nozero(u32 size) {\n\n  char* ret;\n\n  if (!size) return NULL;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc((size_t)size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  return ret;\n\n}\n\n\n/* Allocate a buffer, returning zeroed memory. */\n\nstatic inline void* DFL_ck_alloc(u32 size) {\n\n  void* mem;\n\n  if (!size) return NULL;\n  mem = DFL_ck_alloc_nozero(size);\n\n  return memset(mem, 0, size);\n\n}\n\n\n/* Free memory, checking for double free and corrupted heap. When DEBUG_BUILD\n   is set, the old memory will be also clobbered with 0xFF. */\n\nstatic inline void DFL_ck_free(char* mem) {\n\n  if (!mem) return;\n\n  CHECK_PTR(mem);\n\n#ifdef DEBUG_BUILD\n\n  /* Catch pointer issues sooner. */\n  memset(mem, 0xFF, ALLOC_S(mem));\n\n#endif /* DEBUG_BUILD */\n\n  ALLOC_C1(mem) = ALLOC_MAGIC_F;\n\n  free(mem - ALLOC_OFF_HEAD);\n\n}\n\n\n/* Re-allocate a buffer, checking for issues and zeroing any newly-added tail.\n   With DEBUG_BUILD, the buffer is always reallocated to a new addresses and the\n   old memory is clobbered with 0xFF. */\n\nstatic inline void* DFL_ck_realloc(char* orig, u32 size) {\n\n  char* ret;\n  u32   old_size = 0;\n\n  if (!size) {\n\n    DFL_ck_free(orig);\n    return NULL;\n\n  }\n\n  if (orig) {\n\n    CHECK_PTR(orig);\n\n#ifndef DEBUG_BUILD\n    ALLOC_C1(orig) = ALLOC_MAGIC_F;\n#endif /* !DEBUG_BUILD */\n\n    old_size  = ALLOC_S(orig);\n    orig     -= ALLOC_OFF_HEAD;\n\n    ALLOC_CHECK_SIZE(old_size);\n\n  }\n\n  ALLOC_CHECK_SIZE(size);\n\n#ifndef DEBUG_BUILD\n\n  ret = realloc(orig, (size_t)size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n#else\n\n  /* Catch pointer issues sooner: force relocation and make sure that the\n     original buffer is wiped. */\n\n  ret = malloc(size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n  if (orig) {\n\n    memcpy(ret + ALLOC_OFF_HEAD, orig + ALLOC_OFF_HEAD, MIN(size, old_size));\n    memset(orig + ALLOC_OFF_HEAD, 0xFF, old_size);\n\n    ALLOC_C1(orig + ALLOC_OFF_HEAD) = ALLOC_MAGIC_F;\n\n    free(orig);\n\n  }\n\n#endif /* ^!DEBUG_BUILD */\n\n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  if (size > old_size)\n    memset(ret + old_size, 0, size - old_size);\n\n  return ret;\n\n}\n\n\n/* Re-allocate a buffer with ALLOC_BLK_INC increments (used to speed up\n   repeated small reallocs without complicating the user code). */\n\nstatic inline void* DFL_ck_realloc_block(void* orig, u32 size) {\n\n#ifndef DEBUG_BUILD\n\n  if (orig) {\n\n    CHECK_PTR(orig);\n\n    if (ALLOC_S(orig) >= size) return orig;\n\n    size += ALLOC_BLK_INC;\n\n  }\n\n#endif /* !DEBUG_BUILD */\n\n  return DFL_ck_realloc(orig, size);\n\n}\n\n\n/* Create a buffer with a copy of a string. Returns NULL for NULL inputs. */\n\nstatic inline u8* DFL_ck_strdup(u8* str) {\n\n  char* ret;\n  u32   size;\n\n  if (!str) return NULL;\n\n  size = strlen((char*)str) + 1;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc((size_t)size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n\n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  return memcpy(ret, str, size);\n\n}\n\n\n/* Create a buffer with a copy of a memory block. Returns NULL for zero-sized\n   or NULL inputs. */\n\nstatic inline void* DFL_ck_memdup(void* mem, u32 size) {\n\n  char* ret;\n\n  if (!mem || !size) return NULL;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc((size_t)size + ALLOC_OFF_TOTAL);\n  ALLOC_CHECK_RESULT(ret, size);\n  \n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  return memcpy(ret, mem, size);\n\n}\n\n\n/* Create a buffer with a block of text, appending a NUL terminator at the end.\n   Returns NULL for zero-sized or NULL inputs. */\n\nstatic inline u8* DFL_ck_memdup_str(u8* mem, u32 size) {\n\n  u8* ret;\n\n  if (!mem || !size) return NULL;\n\n  ALLOC_CHECK_SIZE(size);\n  ret = malloc((size_t)size + ALLOC_OFF_TOTAL + 1);\n  ALLOC_CHECK_RESULT(ret, size);\n  \n  ret += ALLOC_OFF_HEAD;\n\n  ALLOC_C1(ret) = ALLOC_MAGIC_C1;\n  ALLOC_S(ret)  = size;\n  ALLOC_C2(ret) = ALLOC_MAGIC_C2;\n\n  memcpy(ret, mem, size);\n  ret[size] = 0;\n\n  return ret;\n\n}\n\n\n#ifndef DEBUG_BUILD\n\n/* In non-debug mode, we just do straightforward aliasing of the above functions\n   to user-visible names such as ck_alloc(). */\n\n#define ck_alloc          DFL_ck_alloc\n#define ck_alloc_nozero   DFL_ck_alloc_nozero\n#define ck_realloc        DFL_ck_realloc\n#define ck_realloc_block  DFL_ck_realloc_block\n#define ck_strdup         DFL_ck_strdup\n#define ck_memdup         DFL_ck_memdup\n#define ck_memdup_str     DFL_ck_memdup_str\n#define ck_free           DFL_ck_free\n\n#define alloc_report()\n\n#else\n\n/* In debugging mode, we also track allocations to detect memory leaks, and the\n   flow goes through one more layer of indirection. */\n\n/* Alloc tracking data structures: */\n\n#define ALLOC_BUCKETS     4096\n\nstruct TRK_obj {\n  void *ptr;\n  char *file, *func;\n  u32  line;\n};\n\n#ifdef AFL_MAIN\n\nstruct TRK_obj* TRK[ALLOC_BUCKETS];\nu32 TRK_cnt[ALLOC_BUCKETS];\n\n#  define alloc_report() TRK_report()\n\n#else\n\nextern struct TRK_obj* TRK[ALLOC_BUCKETS];\nextern u32 TRK_cnt[ALLOC_BUCKETS];\n\n#  define alloc_report()\n\n#endif /* ^AFL_MAIN */\n\n/* Bucket-assigning function for a given pointer: */\n\n#define TRKH(_ptr) (((((u32)(_ptr)) >> 16) ^ ((u32)(_ptr))) % ALLOC_BUCKETS)\n\n\n/* Add a new entry to the list of allocated objects. */\n\nstatic inline void TRK_alloc_buf(void* ptr, const char* file, const char* func,\n                                 u32 line) {\n\n  u32 i, bucket;\n\n  if (!ptr) return;\n\n  bucket = TRKH(ptr);\n\n  /* Find a free slot in the list of entries for that bucket. */\n\n  for (i = 0; i < TRK_cnt[bucket]; i++)\n\n    if (!TRK[bucket][i].ptr) {\n\n      TRK[bucket][i].ptr  = ptr;\n      TRK[bucket][i].file = (char*)file;\n      TRK[bucket][i].func = (char*)func;\n      TRK[bucket][i].line = line;\n      return;\n\n    }\n\n  /* No space available - allocate more. */\n\n  TRK[bucket] = DFL_ck_realloc_block(TRK[bucket],\n    (TRK_cnt[bucket] + 1) * sizeof(struct TRK_obj));\n\n  TRK[bucket][i].ptr  = ptr;\n  TRK[bucket][i].file = (char*)file;\n  TRK[bucket][i].func = (char*)func;\n  TRK[bucket][i].line = line;\n\n  TRK_cnt[bucket]++;\n\n}\n\n\n/* Remove entry from the list of allocated objects. */\n\nstatic inline void TRK_free_buf(void* ptr, const char* file, const char* func,\n                                u32 line) {\n\n  u32 i, bucket;\n\n  if (!ptr) return;\n\n  bucket = TRKH(ptr);\n\n  /* Find the element on the list... */\n\n  for (i = 0; i < TRK_cnt[bucket]; i++)\n\n    if (TRK[bucket][i].ptr == ptr) {\n\n      TRK[bucket][i].ptr = 0;\n      return;\n\n    }\n\n  WARNF(\"ALLOC: Attempt to free non-allocated memory in %s (%s:%u)\",\n        func, file, line);\n\n}\n\n\n/* Do a final report on all non-deallocated objects. */\n\nstatic inline void TRK_report(void) {\n\n  u32 i, bucket;\n\n  fflush(0);\n\n  for (bucket = 0; bucket < ALLOC_BUCKETS; bucket++)\n    for (i = 0; i < TRK_cnt[bucket]; i++)\n      if (TRK[bucket][i].ptr)\n        WARNF(\"ALLOC: Memory never freed, created in %s (%s:%u)\",\n              TRK[bucket][i].func, TRK[bucket][i].file, TRK[bucket][i].line);\n\n}\n\n\n/* Simple wrappers for non-debugging functions: */\n\nstatic inline void* TRK_ck_alloc(u32 size, const char* file, const char* func,\n                                 u32 line) {\n\n  void* ret = DFL_ck_alloc(size);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_realloc(void* orig, u32 size, const char* file,\n                                   const char* func, u32 line) {\n\n  void* ret = DFL_ck_realloc(orig, size);\n  TRK_free_buf(orig, file, func, line);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_realloc_block(void* orig, u32 size, const char* file,\n                                         const char* func, u32 line) {\n\n  void* ret = DFL_ck_realloc_block(orig, size);\n  TRK_free_buf(orig, file, func, line);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_strdup(u8* str, const char* file, const char* func,\n                                  u32 line) {\n\n  void* ret = DFL_ck_strdup(str);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_memdup(void* mem, u32 size, const char* file,\n                                  const char* func, u32 line) {\n\n  void* ret = DFL_ck_memdup(mem, size);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void* TRK_ck_memdup_str(void* mem, u32 size, const char* file,\n                                      const char* func, u32 line) {\n\n  void* ret = DFL_ck_memdup_str(mem, size);\n  TRK_alloc_buf(ret, file, func, line);\n  return ret;\n\n}\n\n\nstatic inline void TRK_ck_free(void* ptr, const char* file,\n                                const char* func, u32 line) {\n\n  TRK_free_buf(ptr, file, func, line);\n  DFL_ck_free(ptr);\n\n}\n\n/* Aliasing user-facing names to tracking functions: */\n\n#define ck_alloc(_p1) \\\n  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_alloc_nozero(_p1) \\\n  TRK_ck_alloc(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_realloc(_p1, _p2) \\\n  TRK_ck_realloc(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_realloc_block(_p1, _p2) \\\n  TRK_ck_realloc_block(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_strdup(_p1) \\\n  TRK_ck_strdup(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_memdup(_p1, _p2) \\\n  TRK_ck_memdup(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_memdup_str(_p1, _p2) \\\n  TRK_ck_memdup_str(_p1, _p2, __FILE__, __FUNCTION__, __LINE__)\n\n#define ck_free(_p1) \\\n  TRK_ck_free(_p1, __FILE__, __FUNCTION__, __LINE__)\n\n#endif /* ^!DEBUG_BUILD */\n\n#endif /* ! _HAVE_ALLOC_INL_H */\n"
        },
        {
          "name": "config.h",
          "type": "blob",
          "size": 11.3388671875,
          "content": "/*\n   american fuzzy lop - vaguely configurable bits\n   ----------------------------------------------\n\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\n#ifndef _HAVE_CONFIG_H\n#define _HAVE_CONFIG_H\n\n#define inline __inline\n\n#include \"types.h\"\n\n/******************************************************\n *                                                    *\n *  Settings that may be of interest to power users:  *\n *                                                    *\n ******************************************************/\n\n/* Default file permission umode when creating files (default: 0600) */\n#define DEFAULT_PERMISSION  0600\n\n/* Comment out to disable terminal colors: */\n\n// #define USE_COLOR\n\n/* Comment out to disable fancy ANSI boxes and use poor man's 7-bit UI: */\n\n//#define FANCY_BOXES\n\n/* Default timeout for fuzzed code (milliseconds). This is the upper bound,\n   also used for detecting hangs; the actual value is auto-scaled: */\n\n#define EXEC_TIMEOUT        1000\n\n/* Timeout rounding factor when auto-scaling (milliseconds): */\n\n#define EXEC_TM_ROUND       20\n\n/* Default memory limit for child process (MB): */\n\n#ifndef _WIN64 \n#  define MEM_LIMIT         0\n#else\n#  define MEM_LIMIT         0\n#endif /* ^!_WIN64 */\n\n/* Default memory limit when running in QEMU mode (MB): */\n\n#define MEM_LIMIT_QEMU      200\n\n/* Number of calibration cycles per every new test case (and for test\n   cases that show variable behavior): */\n\n#define CAL_CYCLES          8\n#define CAL_CYCLES_LONG     40\n\n/* Number of subsequent timeouts before abandoning an input file: */\n\n#define TMOUT_LIMIT         250\n\n/* Maximum number of unique hangs or crashes to record: */\n\n#define KEEP_UNIQUE_HANG    500\n#define KEEP_UNIQUE_CRASH   5000\n\n/* Baseline number of random tweaks during a single 'havoc' stage: */\n\n#define HAVOC_CYCLES        256\n#define HAVOC_CYCLES_INIT   1024\n\n\n/* Maximum multiplier for the above (should be a power of two, beware\n   of 32-bit int overflows): */\n\n#define HAVOC_MAX_MULT      16\n\n/* Absolute minimum number of havoc cycles (after all adjustments): */\n\n#define HAVOC_MIN           16\n\n/* Maximum stacking for havoc-stage tweaks. The actual value is calculated\n   like this: \n\n   n = random between 1 and HAVOC_STACK_POW2\n   stacking = 2^n\n\n   In other words, the default (n = 7) produces 2, 4, 8, 16, 32, 64, or\n   128 stacked tweaks: */\n\n#define HAVOC_STACK_POW2    7\n\n/* Caps on block sizes for cloning and deletion operations. Each of these\n   ranges has a 33% probability of getting picked, except for the first\n   two cycles where smaller blocks are favored: */\n\n#define HAVOC_BLK_SMALL     32\n#define HAVOC_BLK_MEDIUM    128\n#define HAVOC_BLK_LARGE     1500\n\n/* Extra-large blocks, selected very rarely (<5% of the time): */\n\n#define HAVOC_BLK_XL        32768\n\n/* Probabilities of skipping non-favored entries in the queue, expressed as\n   percentages: */\n\n#define SKIP_TO_NEW_PROB    99 /* ...when there are new, pending favorites */\n#define SKIP_NFAV_OLD_PROB  95 /* ...no new favs, cur entry already fuzzed */\n#define SKIP_NFAV_NEW_PROB  75 /* ...no new favs, cur entry not fuzzed yet */\n\n/* Splicing cycle count: */\n\n#define SPLICE_CYCLES       15\n\n/* Nominal per-splice havoc cycle length: */\n\n#define SPLICE_HAVOC        32\n\n/* Maximum offset for integer addition / subtraction stages: */\n\n#define ARITH_MAX           35\n\n/* Limits for the test case trimmer. The absolute minimum chunk size; and\n   the starting and ending divisors for chopping up the input file: */\n\n#define TRIM_MIN_BYTES      4\n#define TRIM_START_STEPS    16\n#define TRIM_END_STEPS      1024\n\n/* Maximum size of input file, in bytes (keep under 100MB): */\n\n#define MAX_FILE            (1 * 1024 * 1024)\n\n/* The same, for the test case minimizer: */\n\n#define TMIN_MAX_FILE       (10 * 1024 * 1024)\n\n/* Block normalization steps for afl-tmin: */\n\n#define TMIN_SET_MIN_SIZE   4\n#define TMIN_SET_STEPS      128\n\n/* Maximum dictionary token size (-x), in bytes: */\n\n#define MAX_DICT_FILE       128\n\n/* Length limits for auto-detected dictionary tokens: */\n\n#define MIN_AUTO_EXTRA      3\n#define MAX_AUTO_EXTRA      32\n\n/* Maximum number of user-specified dictionary tokens to use in deterministic\n   steps; past this point, the \"extras/user\" step will be still carried out,\n   but with proportionally lower odds: */\n\n#define MAX_DET_EXTRAS      200\n\n/* Maximum number of auto-extracted dictionary tokens to actually use in fuzzing\n   (first value), and to keep in memory as candidates. The latter should be much\n   higher than the former. */\n\n#define USE_AUTO_EXTRAS     50\n#define MAX_AUTO_EXTRAS     (USE_AUTO_EXTRAS * 10)\n\n/* Scaling factor for the effector map used to skip some of the more\n   expensive deterministic steps. The actual divisor is set to\n   2^EFF_MAP_SCALE2 bytes: */\n\n#define EFF_MAP_SCALE2      3\n\n/* Minimum input file length at which the effector logic kicks in: */\n\n#define EFF_MIN_LEN         128\n\n/* Maximum effector density past which everything is just fuzzed\n   unconditionally (%): */\n\n#define EFF_MAX_PERC        90\n\n/* UI refresh frequency (Hz): */\n\n#define UI_TARGET_HZ        1\n\n/* Fuzzer stats file and plot update intervals (sec): */\n\n#define STATS_UPDATE_SEC    60\n#define PLOT_UPDATE_SEC     5\n\n/* Smoothing divisor for CPU load and exec speed stats (1 - no smoothing). */\n\n#define AVG_SMOOTHING       16\n\n/* Sync interval (every n havoc cycles): */\n\n#define SYNC_INTERVAL       5\n\n/* Output directory reuse grace period (minutes): */\n\n#define OUTPUT_GRACE        25\n\n/* Uncomment to use simple file names (id_NNNNNN): */\n\n#define SIMPLE_FILES\n\n/* List of interesting values to use in fuzzing. */\n\n#define INTERESTING_8 \\\n  -128,          /* Overflow signed 8-bit when decremented  */ \\\n  -1,            /*                                         */ \\\n   0,            /*                                         */ \\\n   1,            /*                                         */ \\\n   16,           /* One-off with common buffer size         */ \\\n   32,           /* One-off with common buffer size         */ \\\n   64,           /* One-off with common buffer size         */ \\\n   100,          /* One-off with common buffer size         */ \\\n   127           /* Overflow signed 8-bit when incremented  */\n\n#define INTERESTING_16 \\\n  -32768,        /* Overflow signed 16-bit when decremented */ \\\n  -129,          /* Overflow signed 8-bit                   */ \\\n   128,          /* Overflow signed 8-bit                   */ \\\n   255,          /* Overflow unsig 8-bit when incremented   */ \\\n   256,          /* Overflow unsig 8-bit                    */ \\\n   512,          /* One-off with common buffer size         */ \\\n   1000,         /* One-off with common buffer size         */ \\\n   1024,         /* One-off with common buffer size         */ \\\n   4096,         /* One-off with common buffer size         */ \\\n   32767         /* Overflow signed 16-bit when incremented */\n\n#define INTERESTING_32 \\\n  -2147483648LL, /* Overflow signed 32-bit when decremented */ \\\n  -100663046,    /* Large negative number (endian-agnostic) */ \\\n  -32769,        /* Overflow signed 16-bit                  */ \\\n   32768,        /* Overflow signed 16-bit                  */ \\\n   65535,        /* Overflow unsig 16-bit when incremented  */ \\\n   65536,        /* Overflow unsig 16 bit                   */ \\\n   100663045,    /* Large positive number (endian-agnostic) */ \\\n   2147483647    /* Overflow signed 32-bit when incremented */\n\n/***********************************************************\n *                                                         *\n *  Really exotic stuff you probably don't want to touch:  *\n *                                                         *\n ***********************************************************/\n\n/* Call count interval between reseeding the libc PRNG from /dev/urandom: */\n\n#define RESEED_RNG          10000\n\n/* Maximum line length passed from GCC to 'as' and used for parsing\n   configuration files: */\n\n#define MAX_LINE            8192\n\n/* Environment variable used to pass SHM ID to the called program. */\n\n#define SHM_ENV_VAR         \"__AFL_SHM_ID\"\n\n/* Other less interesting, internal-only variables. */\n\n#define CLANG_ENV_VAR       \"__AFL_CLANG_MODE\"\n#define AS_LOOP_ENV_VAR     \"__AFL_AS_LOOPCHECK\"\n#define PERSIST_ENV_VAR     \"__AFL_PERSISTENT\"\n#define DEFER_ENV_VAR       \"__AFL_DEFER_FORKSRV\"\n\n/* In-code signatures for deferred and persistent mode. */\n\n#define PERSIST_SIG         \"##SIG_AFL_PERSISTENT##\"\n#define DEFER_SIG           \"##SIG_AFL_DEFER_FORKSRV##\"\n\n/* Distinctive bitmap signature used to indicate failed execution: */\n\n#define EXEC_FAIL_SIG       0xfee1dead\n\n/* Distinctive exit code used to indicate MSAN trip condition: */\n\n#define MSAN_ERROR          86\n\n/* Designated file descriptors for forkserver commands (the application will\n   use FORKSRV_FD and FORKSRV_FD + 1): */\n\n#define FORKSRV_FD          198\n\n/* Fork server init timeout multiplier: we'll wait the user-selected\n   timeout plus this much for the fork server to spin up. */\n\n#define FORK_WAIT_MULT      10\n\n/* Calibration timeout adjustments, to be a bit more generous when resuming\n   fuzzing sessions or trying to calibrate already-added internal finds.\n   The first value is a percentage, the other is in milliseconds: */\n\n#define CAL_TMOUT_PERC      125\n#define CAL_TMOUT_ADD       50\n\n/* Number of chances to calibrate a case before giving up: */\n\n#define CAL_CHANCES         3\n\n/* Map size for the traced binary (2^MAP_SIZE_POW2). Must be greater than\n   2; you probably want to keep it under 18 or so for performance reasons\n   (adjusting AFL_INST_RATIO when compiling is probably a better way to solve\n   problems with complex programs). You need to recompile the target binary\n   after changing this - otherwise, SEGVs may ensue. */\n\n#define MAP_SIZE_POW2       16\n#define MAP_SIZE            (1 << MAP_SIZE_POW2)\n\n/* Maximum allocator request size (keep well under INT_MAX): */\n\n#define MAX_ALLOC           0x40000000\n\n/* A made-up hashing seed: */\n\n#define HASH_CONST          0xa5b35705\n\n/* Constants for afl-gotcpu to control busy loop timing: */\n\n#define  CTEST_TARGET_MS    5000\n#define  CTEST_BUSY_CYCLES  (10 * 1000 * 1000)\n\n/* Uncomment this to use inferior block-coverage-based instrumentation. Note\n   that you need to recompile the target binary for this to have any effect: */\n\n// #define COVERAGE_ONLY\n\n/* Uncomment this to ignore hit counts and output just one bit per tuple.\n   As with the previous setting, you will need to recompile the target\n   binary: */\n\n// #define SKIP_COUNTS\n\n/* Uncomment this to use instrumentation data to record newly discovered paths,\n   but do not use them as seeds for fuzzing. This is useful for conveniently\n   measuring coverage that could be attained by a \"dumb\" fuzzing algorithm: */\n\n// #define IGNORE_FINDS\n\n#define MAX_ATTACH_ATTEMPTS 10\n\n#endif /* ! _HAVE_CONFIG_H */\n"
        },
        {
          "name": "custom_net_fuzzer.c",
          "type": "blob",
          "size": 7.21875,
          "content": "/*\ncustom_net_fuzzer - a shared DLL to enable network fuzzing in winAFL\n-------------------------------------------------------------\n\nWritten and maintained by Maksim Shudrak <mxmssh@gmail.com>\n\nCopyright 2018 Salesforce Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n#include \"custom_winafl_server.h\"\n\nstatic u8  enable_socket_fuzzing = 0; /* Enable network fuzzing           */\nstatic u8  is_TCP = 1;                /* TCP or UDP                       */\nstatic u32 target_port = 0x0;         /* Target port to send test cases   */\nstatic u32 socket_init_delay = SOCKET_INIT_DELAY; /* Socket init delay    */\nstatic u8 *target_ip_address = NULL;  /* Target IP to send test cases     */\n\n\nstatic SOCKET ListenSocket = INVALID_SOCKET;\nstatic SOCKET ClientSocket = INVALID_SOCKET;\n\nstatic void send_data_tcp(const char *buf, const int buf_len, int first_time) {\n    static struct sockaddr_in si_other;\n    static int slen = sizeof(si_other);\n    static WSADATA wsa;\n    int s;\n\n    if (first_time == 0x0) {\n        /* wait while the target process open the socket */\n        Sleep(socket_init_delay);\n\n        if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)\n            FATAL(\"WSAStartup failed. Error Code : %d\", WSAGetLastError());\n\n        // setup address structure\n        memset((char *)&si_other, 0, sizeof(si_other));\n        si_other.sin_family = AF_INET;\n        si_other.sin_port = htons(target_port);\n        si_other.sin_addr.S_un.S_addr = inet_addr((char *)target_ip_address);\n    }\n\n    /* In case of TCP we need to open a socket each time we want to establish\n    * connection. In theory we can keep connections always open but it might\n    * cause our target behave differently (probably there are a bunch of\n    * applications where we should apply such scheme to trigger interesting\n    * behavior).\n    */\n    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP)) == SOCKET_ERROR)\n        FATAL(\"socket() failed with error code : %d\", WSAGetLastError());\n\n    // Connect to server.\n    if (connect(s, (SOCKADDR *)& si_other, slen) == SOCKET_ERROR)\n        FATAL(\"connect() failed with error code : %d\", WSAGetLastError());\n\n    // Send our buffer\n    if (send(s, buf, buf_len, 0) == SOCKET_ERROR)\n        FATAL(\"send() failed with error code : %d\", WSAGetLastError());\n\n    // shutdown the connection since no more data will be sent\n    if (shutdown(s, 0x1/*SD_SEND*/) == SOCKET_ERROR)\n        FATAL(\"shutdown failed with error: %d\\n\", WSAGetLastError());\n    // close the socket to avoid consuming much resources\n    if (closesocket(s) == SOCKET_ERROR)\n        FATAL(\"closesocket failed with error: %d\\n\", WSAGetLastError());\n}\n\nstatic void send_data_udp(const char *buf, const int buf_len, int first_time) {\n    static struct sockaddr_in si_other;\n    static int s, slen = sizeof(si_other);\n    static WSADATA wsa;\n\n    if (first_time == 0x0) {\n        /* wait while the target process open the socket */\n        Sleep(socket_init_delay);\n\n        if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0)\n            FATAL(\"WSAStartup failed. Error Code : %d\", WSAGetLastError());\n\n        if ((s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == SOCKET_ERROR)\n            FATAL(\"socket() failed with error code : %d\", WSAGetLastError());\n\n        // setup address structure\n        memset((char *)&si_other, 0, sizeof(si_other));\n        si_other.sin_family = AF_INET;\n        si_other.sin_port = htons(target_port);\n        si_other.sin_addr.S_un.S_addr = inet_addr((char *)target_ip_address);\n    }\n\n    // send the data\n    if (sendto(s, buf, buf_len, 0, (struct sockaddr *) &si_other, slen) == SOCKET_ERROR)\n        FATAL(\"sendto() failed with error code : %d\", WSAGetLastError());\n}\n\n#define DEFAULT_BUFLEN 4096\n\nCUSTOM_SERVER_API int APIENTRY dll_run(char *data, long size, int fuzz_iterations) {\n    if (is_TCP)\n        send_data_tcp(data, size, fuzz_iterations);\n    else\n        send_data_udp(data, size, fuzz_iterations);\n    return 1;\n}\n\nstatic int optind;\nstatic u8 *optarg;\n\nint getopt(int argc, char **argv, char *optstring) {\n    char *c;\n    optarg = NULL;\n    int i = 0;\n\n    while (1) {\n        if (optind == argc) return -1;\n\n        if (argv[optind][0] != '-') {\n            optind++;\n            continue;\n        }\n        if (!argv[optind][1]) {\n            optind++;\n            continue;\n        }\n\n        c = strchr(optstring, argv[optind][1]);\n        if (!c) {\n            optind++;\n            continue;\n        }\n\n        optind++;\n        if (c[1] == ':') {\n            if (optind == argc) return -1;\n            optarg = argv[optind];\n            optind++;\n        }\n\n        return (int)(c[0]);\n    }\n}\n\nvoid usage() {\n    printf(\"Network fuzzing options:\\n\\n\"\\\n    \"  -a            - IP address to send data in\\n\"\\\n    \"  -U            - Use UDP (default TCP)\\n\"\\\n    \"  -p            - Port to send data in\\n\"\\\n    \"  -w            - Delay in milliseconds before start sending data\\n\");\n    exit(1);\n}\nstatic int optind;\nstatic u8 *optarg;\n\n#define MAX_ARGS 28\n\nchar **convert_to_array(char *args, int *argc) {\n    int element_id = 0;\n    int last_element_offset = 0;\n    char *c = NULL;\n\n    int length = strlen(args);\n    char **argv = malloc(MAX_ARGS * sizeof (char *));\n\n    while (args) {\n        c = strchr(args, ' ');\n        if (!c)\n            break;\n\n        int len = c - args;\n        if (len <= 0)\n            break;\n\n        char *element = malloc(len);\n        memcpy(element, args, len);\n        element[len] = '\\0';\n\n        argv[element_id] = element;\n\n        element_id++;\n        if (element_id >= MAX_ARGS) {\n            usage();\n            break;\n        }\n\n        args = c + 1;\n    }\n    argv[element_id] = strdup(args);\n\n    *argc = element_id + 1;\n    return argv;\n}\n\nCUSTOM_SERVER_API int APIENTRY dll_init() {\n    s32 opt;\n    static int iSendResult;\n    static int first_time = 0x1;\n    int argc;\n\n    if (!first_time)\n        return 1;\n\n    char *args = getenv(\"AFL_CUSTOM_DLL_ARGS\");\n\n    char **argv = convert_to_array(args, &argc);\n\n    if (args == NULL)\n        usage();\n\n    while ((opt = getopt(argc, argv, \"Ua:p:w:\")) > 0) {\n        switch (opt) {\n        case 'a':\n            target_ip_address = ck_strdup(optarg);\n\n            break;\n\n        case 'U':\n            is_TCP = 0;\n\n            break;\n\n        case 'p':\n            if (sscanf(optarg, \"%u\", &target_port) < 1 ||\n                optarg[0] == '-') FATAL(\"Bad syntax used for -p\");\n\n            break;\n\n        case 'w':\n            if (sscanf(optarg, \"%u\", &socket_init_delay) < 1 ||\n                optarg[0] == '-') FATAL(\"Bad syntax used for -w\");\n\n            break;\n        default:\n            break;\n        }\n    }\n\n    if (target_ip_address == NULL || target_port == 0)\n        usage();\n\n    printf(\"Ready to begin fuzzing. Target IP= %s, target port = %d\\n\",\n           target_ip_address, target_port);\n    first_time = 0x0;\n    return 1;\n}\n"
        },
        {
          "name": "custom_net_fuzzer.def",
          "type": "blob",
          "size": 0.0244140625,
          "content": "EXPORTS\ndll_init\ndll_run\n"
        },
        {
          "name": "custom_winafl_server.c",
          "type": "blob",
          "size": 5.8134765625,
          "content": "/*\ncustom_winafl_server - a shared DLL to enable server-mode fuzzing in winAFL:\n-------------------------------------------------------------\n\nWritten and maintained by Maksim Shudrak <mxmssh@gmail.com>\n\nCopyright 2018 Salesforce Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n#include \"custom_winafl_server.h\"\n\nstatic SOCKET ListenSocket = INVALID_SOCKET;\nstatic SOCKET ClientSocket = INVALID_SOCKET;\n\n#define DEFAULT_BUFLEN 4096\n\n//#define DEBUG_SERVER 1\n\n/* open data and send it back into TCP/UDP socket (winAFL is a server) */\nstatic int send_response(char *buf, long fsize, SOCKET ClientSocket) {\n\t/* send our test case */\n#ifdef DEBUG_SERVER\n    printf(\"Sending %s\\n\", buf);\n#endif\n    int iSendResult = send(ClientSocket, buf, fsize, 0);\n\tif (iSendResult == SOCKET_ERROR) {\n\t\tprintf(\"send failed with error: %d\\n\", WSAGetLastError());\n\t\tclosesocket(ClientSocket);\n\t\tWSACleanup();\n\t\tExitProcess(-1);\n\t\treturn 0;\n\t}\n#ifdef DEBUG_SERVER\n\tprintf(\"Bytes sent: %d\\n\", iSendResult);\n#endif\n\n\treturn 1;\n}\n\nstatic int recv_loop(SOCKET ClientSocket) {\n\tint iResult;\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint recvbuflen = DEFAULT_BUFLEN;\n\n\tdo {\n\t\tiResult = recv(ClientSocket, recvbuf, recvbuflen, 0);\n\t\tif (iResult > 0) {\n#ifdef DEBUG_SERVER\n\t\t\tprintf(\"Bytes received: %d\\n\", iResult);\n#endif\n\t\t}\n\t\telse if (iResult == 0) {\n#ifdef DEBUG_SERVER\n\t\t\tprintf(\"Connection closing...\\n\");\n#endif\n\t\t}\n\t\telse {\n\t\t\tprintf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\t\t\tclosesocket(ClientSocket);\n\t\t\tWSACleanup();\n\t\t\tExitProcess(-1);\n\t\t\treturn 0;\n\t\t}\n\t} while (iResult > 0);\n\treturn 1;\n}\n\n#define DEFAULT_BUFLEN 4096\n\ntypedef struct _test_case_struct {\n\tlong size;\n\tchar *data;\n} test_case_struct;\n\n/* server-mode routings */\nDWORD WINAPI handle_incoming_connection(LPVOID lpParam) {\n\tstatic int iResult;\n\ttest_case_struct *test_case = (test_case_struct *)lpParam;\n\n#ifdef DEBUG_SERVER\n\tprintf(\"Handling incoming connections\\n\");\n#endif\n\n\t// Accept a client socket\n\tClientSocket = accept(ListenSocket, NULL, NULL);\n\tif (ClientSocket == INVALID_SOCKET) {\n\t\tprintf(\"accept failed with error: %d\\n\", WSAGetLastError());\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\tExitProcess(-1);\n\t\treturn 0;\n\t}\n\n\trecv_loop(ClientSocket);\n\n\t/* answer with test case to our client */\n\tint res = send_response(test_case->data, test_case->size, ClientSocket);\n\n\tif (!res) {\n\t\tprintf(\"Failed to send response\");\n\t\tExitProcess(-1);\n\t\treturn 0;\n\t}\n\n\t// shutdown the connection since we're done\n\tiResult = shutdown(ClientSocket, SD_SEND);\n\tif (iResult == SOCKET_ERROR) {\n\t\tprintf(\"shutdown failed with error: %d\\n\", WSAGetLastError());\n\t\tclosesocket(ClientSocket);\n\t\tWSACleanup();\n\t\tExitProcess(-1);\n\t\treturn 0;\n\t}\n\tfree(test_case->data);\n\tfree(test_case);\n\treturn 1;\n}\n\nHANDLE hr = NULL;\n\nCUSTOM_SERVER_API int APIENTRY dll_run(char *data, long size, int fuzz_iterations) {\n\tDWORD dwThreadId;\n\ttest_case_struct *test_case = (test_case_struct *)malloc(sizeof(test_case_struct));\n\ttest_case->data = (char *)malloc(size);\n\n\tmemcpy(test_case->data, data, size);\n\ttest_case->size = size;\n\n\t/* we have to create a second thread to avoid blocking winAFL in recv */\n\tif (hr != NULL)\n\t\tWaitForSingleObject(hr, INFINITE); /* we have to wait our previous thread to finish exec */\n\thr = CreateThread(NULL, 0, handle_incoming_connection, (LPVOID)test_case, 0, &dwThreadId);\n\tif (hr == NULL)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid usage() {\n\tprintf(\"Please setup AFL_CUSTOM_DLL_ARGS=<port_number>\\n\");\n\texit(1);\n}\n\n/* winAFL is a TCP server now (TODO: implement UDP server) */\nCUSTOM_SERVER_API int APIENTRY dll_init() {\n\tstatic WSADATA wsaData;\n\tstatic int iResult;\n    s32 opt;\n\tstatic struct addrinfo *result = NULL;\n\tstatic struct addrinfo hints;\n\tstatic int iSendResult;\n\n\tstatic int first_time = 0x1;\n    unsigned char *server_bind_port = NULL;\n\n\tif (!first_time)\n\t\treturn 1;\n\n    server_bind_port = getenv(\"AFL_CUSTOM_DLL_ARGS\");\n    if (server_bind_port == NULL)\n        usage();\n\n\tprintf(\"Initializing custom winAFL server\\n\");\n\n\t// Initialize Winsock\n\tiResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\tif (iResult != 0) {\n\t\tprintf(\"WSAStartup failed with error: %d\\n\", iResult);\n\t\treturn 0;\n\t}\n\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_INET;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\thints.ai_flags = AI_PASSIVE;\n\n\t// Resolve the server address and port\n\tiResult = getaddrinfo(NULL, server_bind_port, &hints, &result);\n\tif (iResult != 0) {\n\t\tprintf(\"getaddrinfo failed with error: %d\\n\", iResult);\n\t\tWSACleanup();\n\t\treturn 0;\n\t}\n\n\t// Create a SOCKET for connecting to server\n\tListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);\n\tif (ListenSocket == INVALID_SOCKET) {\n\t\tprintf(\"socket failed with error: %ld\\n\", WSAGetLastError());\n\t\tfreeaddrinfo(result);\n\t\tWSACleanup();\n\t\treturn 0;\n\t}\n\n\t// Setup the TCP listening socket\n\tiResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);\n\tif (iResult == SOCKET_ERROR) {\n\t\tprintf(\"bind failed with error: %d\\n\", WSAGetLastError());\n\t\tfreeaddrinfo(result);\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\treturn 0;\n\t}\n\n\tfreeaddrinfo(result);\n\n\tiResult = listen(ListenSocket, SOMAXCONN);\n\tif (iResult == SOCKET_ERROR) {\n\t\tprintf(\"listen failed with error: %d\\n\", WSAGetLastError());\n\t\tclosesocket(ListenSocket);\n\t\tWSACleanup();\n\t\tExitProcess(-1);\n\t\treturn 0;\n\t}\n\n\tprintf(\"WinAFL server is listening on port %s\\n\", server_bind_port);\n\tfirst_time = 0x0;\n\n\treturn 1;\n}"
        },
        {
          "name": "custom_winafl_server.def",
          "type": "blob",
          "size": 0.0244140625,
          "content": "EXPORTS\ndll_init\ndll_run\n"
        },
        {
          "name": "custom_winafl_server.h",
          "type": "blob",
          "size": 1.45703125,
          "content": "/*\ncustom_winafl_server - a shared DLL to enable server-mode fuzzing in winAFL:\n-------------------------------------------------------------\n\nWritten and maintained by Maksim Shudrak <mxmssh@gmail.com>\n\nCopyright 2018 Salesforce Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n#pragma once\n\n#define WIN32_LEAN_AND_MEAN /* prevent winsock.h to be included in windows.h */\n\n#include <stdio.h>\n#include <tchar.h>\n#include <Windows.h>\n#include <wininet.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n\n#pragma comment(lib,\"ws2_32.lib\") //Winsock Library\n#pragma comment( lib, \"wininet\")\n\n#include \"alloc-inl.h\"\n\n#define CUSTOM_SERVER_API __declspec(dllexport)\n\nCUSTOM_SERVER_API int APIENTRY dll_init();\nCUSTOM_SERVER_API int APIENTRY dll_run(char *data, long size, int fuzz_iterations);\n\n/* Default delay in milliseconds to let the target open a socket and start listen for\n * incoming packages.\n*/\n#define SOCKET_INIT_DELAY 30000"
        },
        {
          "name": "debug.h",
          "type": "blob",
          "size": 7.5263671875,
          "content": "/*\n   american fuzzy lop - debug / error handling macros\n   --------------------------------------------------\n\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\n#ifndef _HAVE_DEBUG_H\n#define _HAVE_DEBUG_H\n\n#include <errno.h>\n\n#include \"types.h\"\n#include \"config.h\"\n\n#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING\n#define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004\n#endif\n\n/*******************\n * Terminal colors *\n *******************/\n\n#ifdef USE_COLOR\n\n#  define cBLK \"\\x1b[0;30m\"\n#  define cRED \"\\x1b[0;31m\"\n#  define cGRN \"\\x1b[0;32m\"\n#  define cBRN \"\\x1b[0;33m\"\n#  define cBLU \"\\x1b[0;34m\"\n#  define cMGN \"\\x1b[0;35m\"\n#  define cCYA \"\\x1b[0;36m\"\n#  define cLGR \"\\x1b[0;37m\"\n#  define cGRA \"\\x1b[1;30m\"\n#  define cLRD \"\\x1b[1;31m\"\n#  define cLGN \"\\x1b[1;32m\"\n#  define cYEL \"\\x1b[1;33m\"\n#  define cLBL \"\\x1b[1;34m\"\n#  define cPIN \"\\x1b[1;35m\"\n#  define cLCY \"\\x1b[1;36m\"\n#  define cBRI \"\\x1b[1;37m\"\n#  define cRST \"\\x1b[0m\"\n\n#  define bgBLK \"\\x1b[40m\"\n#  define bgRED \"\\x1b[41m\"\n#  define bgGRN \"\\x1b[42m\"\n#  define bgBRN \"\\x1b[43m\"\n#  define bgBLU \"\\x1b[44m\"\n#  define bgMGN \"\\x1b[45m\"\n#  define bgCYA \"\\x1b[46m\"\n#  define bgLGR \"\\x1b[47m\"\n#  define bgGRA \"\\x1b[100m\"\n#  define bgLRD \"\\x1b[101m\"\n#  define bgLGN \"\\x1b[102m\"\n#  define bgYEL \"\\x1b[103m\"\n#  define bgLBL \"\\x1b[104m\"\n#  define bgPIN \"\\x1b[105m\"\n#  define bgLCY \"\\x1b[106m\"\n#  define bgBRI \"\\x1b[107m\"\n\n#else\n\n#  define cBLK \"\"\n#  define cRED \"\"\n#  define cGRN \"\"\n#  define cBRN \"\"\n#  define cBLU \"\"\n#  define cMGN \"\"\n#  define cCYA \"\"\n#  define cLGR \"\"\n#  define cGRA \"\"\n#  define cLRD \"\"\n#  define cLGN \"\"\n#  define cYEL \"\"\n#  define cLBL \"\"\n#  define cPIN \"\"\n#  define cLCY \"\"\n#  define cBRI \"\"\n#  define cRST \"\"\n\n#  define bgBLK \"\"\n#  define bgRED \"\"\n#  define bgGRN \"\"\n#  define bgBRN \"\"\n#  define bgBLU \"\"\n#  define bgMGN \"\"\n#  define bgCYA \"\"\n#  define bgLGR \"\"\n#  define bgGRA \"\"\n#  define bgLRD \"\"\n#  define bgLGN \"\"\n#  define bgYEL \"\"\n#  define bgLBL \"\"\n#  define bgPIN \"\"\n#  define bgLCY \"\"\n#  define bgBRI \"\"\n\n#endif /* ^USE_COLOR */\n\n/*************************\n * Box drawing sequences *\n *************************/\n\n#ifdef FANCY_BOXES\n\n#  define SET_G1   \"\\x1b)0\"       /* Set G1 for box drawing    */\n#  define RESET_G1 \"\\x1b)B\"       /* Reset G1 to ASCII         */\n#  define bSTART   \"\\x0e\"         /* Enter G1 drawing mode     */\n#  define bSTOP    \"\\x0f\"         /* Leave G1 drawing mode     */\n#  define bH       \"q\"            /* Horizontal line           */\n#  define bV       \"x\"            /* Vertical line             */\n#  define bLT      \"l\"            /* Left top corner           */\n#  define bRT      \"k\"            /* Right top corner          */\n#  define bLB      \"m\"            /* Left bottom corner        */\n#  define bRB      \"j\"            /* Right bottom corner       */\n#  define bX       \"n\"            /* Cross                     */\n#  define bVR      \"t\"            /* Vertical, branch right    */\n#  define bVL      \"u\"            /* Vertical, branch left     */\n#  define bHT      \"v\"            /* Horizontal, branch top    */\n#  define bHB      \"w\"            /* Horizontal, branch bottom */\n\n#else\n\n#  define SET_G1   \"\"\n#  define RESET_G1 \"\"\n#  define bSTART   \"\"\n#  define bSTOP    \"\"\n#  define bH       \"-\"\n#  define bV       \"|\"\n#  define bLT      \"+\"\n#  define bRT      \"+\"\n#  define bLB      \"+\"\n#  define bRB      \"+\"\n#  define bX       \"+\"\n#  define bVR      \"+\"\n#  define bVL      \"+\"\n#  define bHT      \"+\"\n#  define bHB      \"+\"\n\n#endif /* ^FANCY_BOXES */\n\n/***********************\n * Misc terminal codes *\n ***********************/\n\n#ifdef USE_COLOR\n\n#define TERM_HOME     \"\\x1b[H\"\n#define TERM_CLEAR    TERM_HOME \"\\x1b[2J\"\n#define cEOL          \"\\x1b[0K\"\n#define CURSOR_HIDE   \"\\x1b[?25l\"\n#define CURSOR_SHOW   \"\\x1b[?25h\"\n\n#else\n\n#define TERM_HOME     \"\"\n#define TERM_CLEAR    \"\"\n#define cEOL          \"\"\n#define CURSOR_HIDE   \"\"\n#define CURSOR_SHOW   \"\"\n\n#endif /* ^USE_COLORS */\n\n/************************\n * Debug & error macros *\n ************************/\n\n/* Just print stuff to the appropriate stream. */\n\n#ifdef MESSAGES_TO_STDOUT\n#  define SAYF(...)    printf(__VA_ARGS__)\n#else \n#  define SAYF(...)    fprintf(stderr, __VA_ARGS__)\n#endif /* ^MESSAGES_TO_STDOUT */\n\n/* Show a prefixed warning. */\n\n#define WARNF(...) do { \\\n    SAYF(cYEL \"[!] \" cBRI \"WARNING: \" cRST __VA_ARGS__); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Show a prefixed \"doing something\" message. */\n\n#define ACTF(...) do { \\\n    SAYF(cLBL \"[*] \" cRST __VA_ARGS__); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Show a prefixed \"success\" message. */\n\n#define OKF(...) do { \\\n    SAYF(cLGN \"[+] \" cRST __VA_ARGS__); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Show a prefixed fatal error message (not used in afl). */\n\n#define BADF(...) do { \\\n    SAYF(cLRD \"\\n[-] \" cRST __VA_ARGS__); \\\n    SAYF(cRST \"\\n\"); \\\n  } while (0)\n\n/* Die with a verbose non-OS fatal error message. */\n\n#define FATAL(...) do { \\\n    SAYF(bSTOP RESET_G1 CURSOR_SHOW cLRD \"\\n[-] PROGRAM ABORT : \" cBRI __VA_ARGS__); \\\n    SAYF(cLRD \"\\n         Location : \" cRST \"%s(), %s:%u\\n\\n\", \\\n         __FUNCTION__, __FILE__, __LINE__); \\\n    exit(1); \\\n  } while (0)\n\n/* Die by calling abort() to provide a core dump. */\n\n#define ABORT(...) do { \\\n    SAYF(bSTOP RESET_G1 CURSOR_SHOW cLRD \"\\n[-] PROGRAM ABORT : \" cBRI __VA_ARGS__); \\\n    SAYF(cLRD \"\\n    Stop location : \" cRST \"%s(), %s:%u\\n\\n\", \\\n         __FUNCTION__, __FILE__, __LINE__); \\\n    abort(); \\\n  } while (0)\n\n/* Die while also including the output of perror(). */\n\n#define PFATAL(...) do { \\\n    fflush(stdout); \\\n    SAYF(bSTOP RESET_G1 CURSOR_SHOW cLRD \"\\n[-]  SYSTEM ERROR : \" cBRI __VA_ARGS__); \\\n    SAYF(cLRD \"\\n    Stop location : \" cRST \"%s(), %s:%u\\n\", \\\n         __FUNCTION__, __FILE__, __LINE__); \\\n    SAYF(cLRD \"       OS message : \" cRST \"%s\\n\", strerror(errno)); \\\n    exit(1); \\\n  } while (0)\n\n/* Die with FAULT() or PFAULT() depending on the value of res (used to\n   interpret different failure modes for read(), write(), etc). */\n\n#define RPFATAL(res, ...) do { \\\n    if (res < 0) PFATAL(__VA_ARGS__); else FATAL(__VA_ARGS__); \\\n  } while (0)\n\n/* Error-checking versions of read() and write() that call RPFATAL() as\n   appropriate. */\n\n#define ck_write(fd, buf, len, fn) do { \\\n    u32 _len = (len); \\\n    s32 _res = _write(fd, buf, _len); \\\n    if (_res != _len) RPFATAL(_res, \"Short write to %s\", fn); \\\n  } while (0)\n\n#define ck_read(fd, buf, len, fn) do { \\\n    u32 _len = (len); \\\n    s32 _res = _read(fd, buf, _len); \\\n    if (_res != _len) RPFATAL(_res, \"Short read from %s\", fn); \\\n  } while (0)\n\n\nstatic void enable_ansi_console(void) {\n  // Set output mode to handle virtual terminal sequences\n  DWORD mode = 0;\n  HANDLE console_handle = GetStdHandle(STD_OUTPUT_HANDLE);\n  if (console_handle == INVALID_HANDLE_VALUE) {\n    return;\n  }\n\n  if (!GetConsoleMode(console_handle, &mode)) {\n    return;\n  }\n\n  mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;\n  // Ignore errors\n  SetConsoleMode(console_handle, mode);\n}\n\n\n#endif /* ! _HAVE_DEBUG_H */\n"
        },
        {
          "name": "gdiplus.cpp",
          "type": "blob",
          "size": 1.673828125,
          "content": "/*\n   WinAFL - GDI+ test binary (image parsing)\n   -----------------------------------------\n\n   Written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#include <stdio.h>\n#include <windows.h>\n#include <gdiplus.h>\n\nusing namespace Gdiplus;\n\nwchar_t* charToWChar(const char* text)\n{\n    size_t size = strlen(text) + 1;\n    wchar_t* wa = new wchar_t[size];\n    mbstowcs(wa,text,size);\n    return wa;\n}\n\nint main(int argc, char** argv)\n{\n\tif(argc < 2) {\n\t\tprintf(\"Usage: %s <image file>\\n\", argv[0]);\n\t\treturn 0;\n\t}\n\n\tGdiplusStartupInput gdiplusStartupInput;\n\tULONG_PTR gdiplusToken;\n\tGdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);\n\n\tImage *image = NULL;\n\t//*thumbnail=NULL;\n\n\timage = new Image(charToWChar(argv[1]));\n\tif(image && (Ok == image->GetLastStatus())) {\n\t\t//printf(\"Image loaded\\n\");\n\t\t/*thumbnail = image->GetThumbnailImage(100, 100, NULL, NULL);\n\t\tif(thumbnail && (Ok == thumbnail->GetLastStatus())) {\n\t\t\t//printf(\"Thumbnail created\\n\");\n\t\t}*/\n\t}\n\n\t//printf(\"Done\\n\");\n\n\tif(image) delete image;\n\t//if(thumbnail) delete thumbnail;\n\n\tGdiplusShutdown(gdiplusToken);\n\n\treturn 0;\n}\n\n"
        },
        {
          "name": "hash.h",
          "type": "blob",
          "size": 2.3994140625,
          "content": "/*\n   american fuzzy lop - hashing function\n   -------------------------------------\n\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n/* \n   The hash32() function is a variant of MurmurHash3, a good\n   non-cryptosafe hashing function developed by Austin Appleby.\n\n   For simplicity, this variant does *NOT* accept buffer lengths\n   that are not divisible by 8 bytes. The 32-bit version is otherwise\n   similar to the original; the 64-bit one is a custom hack with\n   mostly-unproven properties.\n\n   Austin's original code is public domain.\n\n*/\n\n#ifndef _HAVE_HASH_H\n#define _HAVE_HASH_H\n\n#include \"types.h\"\n\n#ifdef _WIN64\n\n#define ROL64(_x, _r)  ((((u64)(_x)) << (_r)) | (((u64)(_x)) >> (64 - (_r))))\n\nstatic inline u32 hash32(const void* key, u32 len, u32 seed) {\n\n  const u64* data = (u64*)key;\n  u64 h1 = seed ^ len;\n\n  len >>= 3;\n\n  while (len--) {\n\n    u64 k1 = *data++;\n\n    k1 *= 0x87c37b91114253d5ULL;\n    k1  = ROL64(k1, 31);\n    k1 *= 0x4cf5ad432745937fULL;\n\n    h1 ^= k1;\n    h1  = ROL64(h1, 27);\n    h1  = h1 * 5 + 0x52dce729;\n\n  }\n\n  h1 ^= h1 >> 33;\n  h1 *= 0xff51afd7ed558ccdULL;\n  h1 ^= h1 >> 33;\n  h1 *= 0xc4ceb9fe1a85ec53ULL;\n  h1 ^= h1 >> 33;\n\n  return h1;\n\n}\n\n#else \n\n#define ROL32(_x, _r)  ((((u32)(_x)) << (_r)) | (((u32)(_x)) >> (32 - (_r))))\n\nstatic inline u32 hash32(const void* key, u32 len, u32 seed) {\n\n  const u32* data  = (u32*)key;\n  u32 h1 = seed ^ len;\n\n  len >>= 2;\n\n  while (len--) {\n\n    u32 k1 = *data++;\n\n    k1 *= 0xcc9e2d51;\n    k1  = ROL32(k1, 15);\n    k1 *= 0x1b873593;\n\n    h1 ^= k1;\n    h1  = ROL32(h1, 13);\n    h1  = h1 * 5 + 0xe6546b64;\n\n  }\n\n  h1 ^= h1 >> 16;\n  h1 *= 0x85ebca6b;\n  h1 ^= h1 >> 13;\n  h1 *= 0xc2b2ae35;\n  h1 ^= h1 >> 16;\n\n  return h1;\n\n}\n\n#endif /* ^_WIN64 */\n\n#endif /* !_HAVE_HASH_H */\n"
        },
        {
          "name": "ipttool.c",
          "type": "blob",
          "size": 20.166015625,
          "content": "ï»¿/*\r\nCopyright 2018 Alex Ionescu. All rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without modification, are permitted provided\r\nthat the following conditions are met:\r\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and\r\n   the following disclaimer.\r\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions\r\n   and the following disclaimer in the documentation and/or other materials provided with the\r\n   distribution.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY ALEX IONESCU ``AS IS'' AND ANY EXPRESS OR IMPLIED\r\nWARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ALEX IONESCU\r\nOR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\r\nOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\r\nAND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\nThe views and conclusions contained in the software and documentation are those of the authors and\r\nshould not be interpreted as representing official policies, either expressed or implied, of Alex Ionescu.\r\n*/\r\n\r\n#include <Windows.h>\r\n#include <stdio.h>\r\n#include <libipt.h>\r\n\r\n#define IPT_TOOL_USE_MTC_TIMING_PACKETS     0x01\r\n#define IPT_TOOL_USE_CYC_TIMING_PACKETS     0x02\r\n#define IPT_TOOL_TRACE_KERNEL_MODE          0x04\r\n#define IPT_TOOL_TRACE_ALL_MODE             0x08\r\n\r\n#define IPT_TOOL_VALID_FLAGS                \\\r\n    (IPT_TOOL_USE_MTC_TIMING_PACKETS |      \\\r\n     IPT_TOOL_USE_CYC_TIMING_PACKETS |      \\\r\n     IPT_TOOL_TRACE_KERNEL_MODE |           \\\r\n     IPT_TOOL_TRACE_ALL_MODE)\r\n\r\nFORCEINLINE\r\nDWORD\r\nConvertToPASizeToSizeOption (\r\n    _In_ DWORD dwSize\r\n    )\r\n{\r\n    DWORD dwIndex;\r\n\r\n    //\r\n    // Cap the size to 128MB. Sizes below 4KB will result in 0 anyway.\r\n    //\r\n    if (dwSize > (128 * 1024 * 1024))\r\n    {\r\n        dwSize = 128 * 1024 * 1024;\r\n    }\r\n\r\n    //\r\n    // Find the nearest power of two that's set (align down)\r\n    //\r\n    BitScanReverse(&dwIndex, dwSize);\r\n\r\n    //\r\n    // The value starts at 4KB\r\n    //\r\n    dwIndex -= 12;\r\n    return dwIndex;\r\n}\r\n\r\nBOOL\r\nEnableIpt (\r\n    VOID\r\n    )\r\n{\r\n    SC_HANDLE hScm, hSc;\r\n    BOOL bRes;\r\n    bRes = FALSE;\r\n\r\n    //\r\n    // Open a handle to the SCM\r\n    //\r\n    hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);\r\n    if (hScm != NULL)\r\n    {\r\n        //\r\n        // Open a handle to the IPT Service\r\n        //\r\n        hSc = OpenService(hScm, L\"Ipt\", SERVICE_START);\r\n        if (hSc != NULL)\r\n        {\r\n            //\r\n            // Start it\r\n            //\r\n            bRes = StartService(hSc, 0, NULL);\r\n            if ((bRes == FALSE) &&\r\n                (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING))\r\n            {\r\n                //\r\n                // If it's already started, that's OK\r\n                //\r\n                bRes = TRUE;\r\n            }\r\n            else if (bRes == FALSE)\r\n            {\r\n                wprintf(L\"[-] Unable to start IPT Service (err=%d)\\n\",\r\n                        GetLastError());\r\n                if (GetLastError() == ERROR_NOT_SUPPORTED)\r\n                {\r\n                    wprintf(L\"[-] This is likely due to missing PT support\\n\");\r\n                }\r\n            }\r\n\r\n            //\r\n            // Done with the service\r\n            //\r\n            CloseServiceHandle(hSc);\r\n        }\r\n        else\r\n        {\r\n            wprintf(L\"[-] Unable to open IPT Service (err=%d). \"\r\n                    L\"Are you running Windows 10 1809?\\n\",\r\n                    GetLastError());\r\n        }\r\n\r\n        //\r\n        // Done with the SCM\r\n        //\r\n        CloseServiceHandle(hScm);\r\n    }\r\n    else\r\n    {\r\n        wprintf(L\"[-] Unable to open a handle to the SCM (err=%d)\\n\",\r\n                GetLastError());\r\n    }\r\n\r\n    //\r\n    // Return the result\r\n    //\r\n    return bRes;\r\n}\r\n\r\nBOOL\r\nEnableAndValidateIptServices (\r\n    VOID\r\n    )\r\n{\r\n    WORD wTraceVersion;\r\n    DWORD dwBufferVersion;\r\n    BOOL bRes;\r\n\r\n    //\r\n    // First enable IPT\r\n    //\r\n    bRes = EnableIpt();\r\n    if (bRes == FALSE)\r\n    {\r\n        wprintf(L\"[-] Intel PT Service could not be started!\\n\");\r\n        goto Cleanup;\r\n    }\r\n\r\n    //\r\n    // Next, check if the driver uses a dialect we understand\r\n    //\r\n    bRes = GetIptBufferVersion(&dwBufferVersion);\r\n    if (bRes == FALSE)\r\n    {\r\n        wprintf(L\"[-] Failed to communicate with IPT Service: (err=%d)\\n\",\r\n                GetLastError());\r\n        goto Cleanup;\r\n    }\r\n    if (dwBufferVersion != IPT_BUFFER_MAJOR_VERSION_CURRENT)\r\n    {\r\n        wprintf(L\"[-] IPT Service buffer version is not supported: %d\\n\",\r\n                dwBufferVersion);\r\n        goto Cleanup;\r\n    }\r\n\r\n    //\r\n    // Then, check if the driver uses trace versions we speak\r\n    //\r\n    bRes = GetIptTraceVersion(&wTraceVersion);\r\n    if (bRes == FALSE)\r\n    {\r\n        wprintf(L\"[-] Failed to get Trace Version from IPT Service (err=%d)\\n\",\r\n                GetLastError());\r\n        goto Cleanup;\r\n    }\r\n    if (wTraceVersion != IPT_TRACE_VERSION_CURRENT)\r\n    {\r\n        wprintf(L\"[-] IPT Service trace version is not supported %d\\n\",\r\n                wTraceVersion);\r\n        goto Cleanup;\r\n    }\r\n\r\nCleanup:\r\n    //\r\n    // Return result\r\n    //\r\n    return bRes;\r\n}\r\n\r\nBOOL\r\nConfigureTraceFlags (\r\n    _In_ DWORD dwFlags,\r\n    _Inout_ PIPT_OPTIONS pOptions\r\n    )\r\n{\r\n    BOOL bRes;\r\n    bRes = FALSE;\r\n\r\n    if (dwFlags & ~IPT_TOOL_VALID_FLAGS)\r\n    {\r\n        wprintf(L\"[-] Invalid flags: %x\\n\", dwFlags);\r\n        goto Cleanup;\r\n    }\r\n\r\n    //\r\n    // If the user didn't specify MTC, but wants CYC, set MTC too as the IPT\r\n    // driver wil enable those packets anyway.\r\n    //\r\n    if ((dwFlags & IPT_TOOL_USE_CYC_TIMING_PACKETS) &&\r\n        !(dwFlags & IPT_TOOL_USE_MTC_TIMING_PACKETS))\r\n    {\r\n        wprintf(L\"[*] CYC Packets require MTC packets, adjusting flags!\\n\");\r\n        dwFlags |= IPT_TOOL_USE_MTC_TIMING_PACKETS;\r\n    }\r\n\r\n    //\r\n    // If the user didn't specify MTC, but wants CYC, set MTC too as the IPT\r\n    // driver wil enable those packets anyway.\r\n    //\r\n    if ((dwFlags & (IPT_TOOL_TRACE_KERNEL_MODE | IPT_TOOL_TRACE_ALL_MODE)) ==\r\n        (IPT_TOOL_TRACE_KERNEL_MODE | IPT_TOOL_TRACE_ALL_MODE))\r\n    {\r\n        wprintf(L\"[-] Cannot enable both `kernel` and `user + kernel` tracing.\"\r\n                L\" Please pick a single flag to use!\\n\");\r\n        goto Cleanup;\r\n    }\r\n\r\n    //\r\n    // There are no matching options for process tradces\r\n    //\r\n    pOptions->MatchSettings = IptMatchByAnyApp;\r\n\r\n    //\r\n    // Choose the right timing setting\r\n    //\r\n    if (dwFlags & IPT_TOOL_USE_MTC_TIMING_PACKETS)\r\n    {\r\n        pOptions->TimingSettings = IptEnableMtcPackets;\r\n        pOptions->MtcFrequency = 3; // FIXME\r\n    }\r\n    else if (dwFlags & IPT_TOOL_USE_CYC_TIMING_PACKETS)\r\n    {\r\n        pOptions->TimingSettings = IptEnableCycPackets;\r\n        pOptions->CycThreshold = 1; // FIXME\r\n    }\r\n    else\r\n    {\r\n        pOptions->TimingSettings = IptNoTimingPackets;\r\n    }\r\n\r\n    //\r\n    // Choose the right mode setting\r\n    //\r\n    if (dwFlags & IPT_TOOL_TRACE_KERNEL_MODE)\r\n    {\r\n        pOptions->ModeSettings = IptCtlKernelModeOnly;\r\n    }\r\n    else if (dwFlags & IPT_TOOL_TRACE_ALL_MODE)\r\n    {\r\n        pOptions->ModeSettings = IptCtlUserAndKernelMode;\r\n    }\r\n    else\r\n    {\r\n        pOptions->ModeSettings = IptCtlUserModeOnly;\r\n    }\r\n\r\n    //\r\n    // Print out chosen options\r\n    //\r\n    bRes = TRUE;\r\n    /*wprintf(L\"[+] Tracing Options:\\n\"\r\n            L\"           Match by: %s\\n\"\r\n            L\"         Trace mode: %s\\n\"\r\n            L\"     Timing packets: %s\\n\",\r\n            L\"Any process\",\r\n            (pOptions->ModeSettings == IptCtlUserAndKernelMode) ?\r\n            L\"Kernel and user-mode\" :\r\n            (pOptions->ModeSettings == IptCtlKernelModeOnly) ?\r\n            L\"Kernel-mode only\" : L\"User-mode only\",\r\n            (pOptions->TimingSettings == IptEnableMtcPackets) ?\r\n            L\"MTC Packets\" :\r\n            (pOptions->TimingSettings == IptEnableCycPackets) ?\r\n            L\"CYC Packets\" : L\"No  Packets\");*/\r\n\r\nCleanup:\r\n    //\r\n    // Return result\r\n    //\r\n    return bRes;\r\n}\r\n\r\nBOOL\r\nConfigureBufferSize (\r\n    _In_ DWORD dwSize,\r\n    _Inout_ PIPT_OPTIONS pOptions\r\n    )\r\n{\r\n    BOOL bRes;\r\n    bRes = FALSE;\r\n\r\n    //\r\n    // Warn the user about incorrect values\r\n    //\r\n    if (!((dwSize) && ((dwSize & (~dwSize + 1)) == dwSize)))\r\n    {\r\n        wprintf(L\"[*] Size will be aligned to a power of 2\\n\");\r\n    }\r\n    else if (dwSize < 4096)\r\n    {\r\n        wprintf(L\"[*] Size will be set to minimum of 4KB\\n\");\r\n    }\r\n    else if (dwSize > (128 * 1024 * 1024))\r\n    {\r\n        wprintf(L\"[*] Size will be set to a maximum of 128MB\\n\");\r\n    }\r\n\r\n    //\r\n    // Compute the size option\r\n    //\r\n    pOptions->TopaPagesPow2 = ConvertToPASizeToSizeOption(dwSize);\r\n    bRes = TRUE;\r\n    /*wprintf(L\"[+] Using size: %d bytes\\n\",\r\n            1 << (pOptions->TopaPagesPow2 + 12));*/\r\n\r\n    //\r\n    // Return result\r\n    //\r\n    return bRes;\r\n}\r\n\r\nPIPT_TRACE_DATA GetIptTrace(HANDLE hProcess)\r\n{\r\n\tBOOL bRes;\r\n\tDWORD dwTraceSize;\r\n\tPIPT_TRACE_DATA pTraceData;\r\n\r\n\t//\r\n\t// Get the size of the trace\r\n\t//\r\n\tbRes = GetProcessIptTraceSize(hProcess, &dwTraceSize);\r\n\tif (bRes == FALSE)\r\n\t{\r\n\t\twprintf(L\"[-] Failed to query trace size (err=%d). \"\r\n\t\t\tL\"Are you sure one is active?\\n\",\r\n\t\t\tGetLastError());\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t//\r\n\t// Allocate a local buffer\r\n\t//\r\n\tpTraceData = HeapAlloc(GetProcessHeap(),\r\n\t\tHEAP_ZERO_MEMORY,\r\n\t\tdwTraceSize);\r\n\tif (pTraceData == NULL)\r\n\t{\r\n\t\twprintf(L\"[-] Out of memory while trying to allocate trace data\\n\");\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\t//\r\n\t// Query the trace\r\n\t//\r\n\t// wprintf(L\"[+] Found active trace with %d bytes so far\\n\", dwTraceSize);\r\n\tbRes = GetProcessIptTrace(hProcess, pTraceData, dwTraceSize);\r\n\tif (bRes == FALSE)\r\n\t{\r\n\t\twprintf(L\"[-] Failed to query trace (err=%d)\\n\",\r\n\t\t\tGetLastError());\r\n\t\treturn NULL;\r\n\t}\r\n\r\n\treturn pTraceData;\r\n}"
        },
        {
          "name": "ipttool.h",
          "type": "blob",
          "size": 0.23828125,
          "content": "BOOL EnableAndValidateIptServices(VOID);\r\nBOOL ConfigureBufferSize(_In_ DWORD dwSize, _Inout_ PIPT_OPTIONS pOptions);\r\nBOOL ConfigureTraceFlags(_In_ DWORD dwFlags, _Inout_ PIPT_OPTIONS pOptions);\r\nPIPT_TRACE_DATA GetIptTrace(HANDLE hProcess);\r\n"
        },
        {
          "name": "modules.c",
          "type": "blob",
          "size": 9.048828125,
          "content": "/* ***************************************************************************\n * Copyright (c) 2012-2013 Google, Inc.  All rights reserved.\n * ***************************************************************************/\n\n/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of Google, Inc. nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n */\n\n/*\nUtilities for keeping track of (un)loaded modules in DynamoRIO clients.\nCopied from the DyanmoRIO project, http://dynamorio.org/\n*/\n\n#include \"modules.h\"\n#include \"utils.h\"\n\n#include <string.h>\n\n/* we use direct map cache to avoid locking */\nstatic inline void\nglobal_module_cache_add(module_entry_t **cache, module_entry_t *entry)\n{\n    cache[entry->id % NUM_GLOBAL_MODULE_CACHE] = entry;\n}\n\n/* Maintains LRU order in thread-private caches. A new/recent entry is moved to\n * the front, and all other entries are shifted back to make place. For new\n * entries, shifting results in the oldest entry being discarded.\n */\nstatic inline void\nthread_module_cache_adjust(module_entry_t **cache,\n                           module_entry_t  *entry,\n                           uint pos,\n                           uint max_pos)\n{\n    uint i;\n    ASSERT(pos < max_pos, \"wrong pos\");\n    for (i = pos; i > 0; i--)\n        cache[i] = cache[i-1];\n    cache[0] = entry;\n}\n\nstatic inline void\nthread_module_cache_add(module_entry_t **cache, uint cache_size,\n                        module_entry_t *entry)\n{\n    thread_module_cache_adjust(cache, entry, cache_size - 1, cache_size);\n}\n\nstatic void\nmodule_table_entry_free(void *entry)\n{\n    dr_free_module_data(((module_entry_t *)entry)->data);\n    dr_global_free(entry, sizeof(module_entry_t));\n}\n\nvoid\nmodule_table_load(module_table_t *table, const module_data_t *data)\n{\n    module_entry_t *entry = NULL;\n    module_data_t  *mod;\n    int i;\n    /* Some apps repeatedly unload and reload the same module,\n     * so we will try to re-use the old one.\n     */\n    ASSERT(data != NULL, \"data must not be NULL\");\n    drvector_lock(&table->vector);\n    /* Assuming most recently loaded entries are most likely to be unloaded,\n     * we iterate the module table in a backward way for better performance.\n     */\n    for (i = table->vector.entries-1; i >= 0; i--) {\n        entry = drvector_get_entry(&table->vector, i);\n        mod   = entry->data;\n        if (entry->unload &&\n            /* If the same module is re-loaded at the same address,\n             * we will try to use the existing entry.\n             */\n            mod->start       == data->start        &&\n            mod->end         == data->end          &&\n            mod->entry_point == data->entry_point  &&\n#ifdef WINDOWS\n            mod->checksum    == data->checksum     &&\n            mod->timestamp   == data->timestamp    &&\n#endif\n            /* If a module w/ no name (there are some) is loaded, we will\n             * keep making new entries.\n             */\n            dr_module_preferred_name(data) != NULL &&\n            dr_module_preferred_name(mod)  != NULL &&\n            strcmp(dr_module_preferred_name(data),\n                   dr_module_preferred_name(mod)) == 0) {\n            entry->unload = false;\n            break;\n        }\n        entry = NULL;\n    }\n    if (entry == NULL) {\n        entry = dr_global_alloc(sizeof(*entry));\n        entry->id = table->vector.entries;\n        entry->unload = false;\n        entry->data = dr_copy_module_data(data);\n        drvector_append(&table->vector, entry);\n    }\n    drvector_unlock(&table->vector);\n    global_module_cache_add(table->cache, entry);\n}\n\nstatic inline bool\npc_is_in_module(module_entry_t *entry, app_pc pc)\n{\n    if (entry != NULL && !entry->unload && entry->data != NULL) {\n        module_data_t *mod = entry->data;\n        if (pc >= mod->start && pc < mod->end)\n            return true;\n    }\n    return false;\n}\n\nmodule_entry_t *\nmodule_table_lookup(module_entry_t **cache, int cache_size,\n                    module_table_t *table, app_pc pc)\n{\n    module_entry_t *entry;\n    int i;\n\n    /* We assume we never change an entry's data field, even on unload,\n     * and thus it is ok to check its value without a lock.\n     */\n    /* lookup thread module cache */\n    if (cache != NULL) {\n        for (i = 0; i < cache_size; i++) {\n            entry = cache[i];\n            if (pc_is_in_module(entry, pc)) {\n                if (i > 0)\n                    thread_module_cache_adjust(cache, entry, i, cache_size);\n                return entry;\n            }\n        }\n    }\n    /* lookup global module cache */\n    /* we use a direct map cache, so it is ok to access it without lock */\n    for (i = 0; i < NUM_GLOBAL_MODULE_CACHE; i++) {\n        entry = table->cache[i];\n        if (pc_is_in_module(entry, pc))\n            return entry;\n    }\n    /* lookup module table */\n    entry = NULL;\n    drvector_lock(&table->vector);\n    for (i = table->vector.entries - 1; i >= 0; i--) {\n        entry = drvector_get_entry(&table->vector, i);\n        ASSERT(entry != NULL, \"fail to get module entry\");\n        if (pc_is_in_module(entry, pc)) {\n            global_module_cache_add(table->cache, entry);\n            if (cache != NULL)\n                thread_module_cache_add(cache, cache_size, entry);\n            break;\n        }\n        entry = NULL;\n    }\n    drvector_unlock(&table->vector);\n    return entry;\n}\n\nvoid\nmodule_table_unload(module_table_t *table, const module_data_t *data)\n{\n    module_entry_t *entry = module_table_lookup(NULL, 0, table, data->start);\n    if (entry != NULL) {\n        entry->unload = true;\n    } else {\n        ASSERT(false, \"fail to find the module to be unloaded\");\n    }\n}\n\n/* assuming caller holds the lock */\nvoid\nmodule_table_entry_print(module_entry_t *entry, file_t log, bool print_all_info)\n{\n    const char *name;\n    module_data_t *data;\n    const char *full_path = \"<unknown>\";\n    data = entry->data;\n    name = dr_module_preferred_name(data);\n    if (data->full_path != NULL && data->full_path[0] != '\\0')\n        full_path = data->full_path;\n\n    if (print_all_info) {\n        dr_fprintf(log, \"%3u, \"PFX\", \"PFX\", \"PFX\", %s, %s\",\n                   entry->id, data->start, data->end, data->entry_point,\n                   (name == NULL || name[0] == '\\0') ? \"<unknown>\" : name,\n                   full_path);\n#ifdef WINDOWS\n        dr_fprintf(log, \", 0x%08x, 0x%08x\", data->checksum, data->timestamp);\n#endif /* WINDOWS */\n        dr_fprintf(log, \"\\n\");\n    } else {\n        dr_fprintf(log, \" %u, %llu, %s\\n\", entry->id,\n                   (uint64)(data->end - data->start), full_path);\n    }\n}\n\nvoid\nmodule_table_print(module_table_t *table, file_t log, bool print_all_info)\n{\n    uint i;\n    module_entry_t *entry;\n    if (log == INVALID_FILE) {\n        /* It is possible that failure on log file creation is caused by the\n         * running process not having enough privilege, so this is not a\n         * release-build fatal error\n         */\n        ASSERT(false, \"invalid log file\");\n        return;\n    }\n    drvector_lock(&table->vector);\n    dr_fprintf(log, \"Module Table: %u\\n\", table->vector.entries);\n\n    if (print_all_info) {\n        dr_fprintf(log, \"Module Table: id, base, end, entry, unload, name, path\");\n#ifdef WINDOWS\n        dr_fprintf(log, \", checksum, timestamp\");\n#endif\n        dr_fprintf(log, \"\\n\");\n    }\n\n    for (i = 0; i < table->vector.entries; i++) {\n        entry = drvector_get_entry(&table->vector, i);\n        module_table_entry_print(entry, log, print_all_info);\n    }\n    drvector_unlock(&table->vector);\n}\n\nmodule_table_t *\nmodule_table_create()\n{\n    module_table_t *table = dr_global_alloc(sizeof(*table));\n    memset(table->cache, 0, sizeof(table->cache));\n    drvector_init(&table->vector, 16, false, module_table_entry_free);\n    return table;\n}\n\nvoid\nmodule_table_destroy(module_table_t *table)\n{\n    drvector_delete(&table->vector);\n    dr_global_free(table, sizeof(*table));\n}\n"
        },
        {
          "name": "modules.h",
          "type": "blob",
          "size": 3.07421875,
          "content": "/* ***************************************************************************\n * Copyright (c) 2012-2013 Google, Inc.  All rights reserved.\n * ***************************************************************************/\n\n/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of Google, Inc. nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n */\n\n/*\nUtilities for keeping track of (un)loaded modules in DynamoRIO clients.\nCopied from the DyanmoRIO project, http://dynamorio.org/\n*/\n\n#ifndef CLIENTS_COMMON_MODULES_H_\n#define CLIENTS_COMMON_MODULES_H_\n\n#include \"dr_api.h\"\n#include \"drvector.h\"\n\n#define NUM_GLOBAL_MODULE_CACHE 8\n\ntypedef struct _module_entry_t {\n    int  id;\n    bool unload; /* if the module is unloaded */\n    module_data_t *data;\n} module_entry_t;\n\ntypedef struct _module_table_t {\n    drvector_t vector;\n    /* for quick query without lock, assuming pointer-aligned */\n    module_entry_t *cache[NUM_GLOBAL_MODULE_CACHE];\n} module_table_t;\n\nvoid\nmodule_table_load(module_table_t *table, const module_data_t *data);\n\n/* To avoid data race, proper sychronization on module table is required for\n * accessing module table entry.\n */\nmodule_entry_t *\nmodule_table_lookup(module_entry_t **cache, int cache_size,\n                    module_table_t *table, app_pc pc);\n\n/* To avoid data race, proper sychronization on module table is required for\n * accessing module table entry.\n */\nvoid\nmodule_table_entry_print(module_entry_t *entry, file_t log, bool print_all_info);\n\nvoid\nmodule_table_unload(module_table_t *table, const module_data_t *data);\n\nvoid\nmodule_table_print(module_table_t *table, file_t log, bool print_all_info);\n\nmodule_table_t *\nmodule_table_create();\n\nvoid\nmodule_table_destroy(module_table_t *table);\n\n#endif /* CLIENTS_COMMON_MODULES_H_ */\n"
        },
        {
          "name": "ptdecode.c",
          "type": "blob",
          "size": 45.5390625,
          "content": "/*\r\n  WinAFL - Intel PT decoding\r\n  ------------------------------------------------\r\n\r\n  Written and maintained by Ivan Fratric <ifratric@google.com>\r\n\r\n  Copyright 2016 Google Inc. All Rights Reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdbool.h>\r\n#include \"windows.h\"\r\n\r\n#include \"intel-pt.h\"\r\n#include \"pt_cpu.h\"\r\n#include \"pt_cpuid.h\"\r\n#include \"pt_opcodes.h\"\r\n#include \"pt_retstack.h\"\r\n#include \"pt_block_decoder.h\"\r\n\r\n#include \"types.h\"\r\n#include \"config.h\"\r\n#include \"debug.h\"\r\n\r\n#include \"winaflpt.h\"\r\n#include \"ptdecode.h\"\r\n\r\n#define PPT_EXT 0xFF\r\n\r\nuint32_t previous_offset;\r\nuint64_t previous_ip;\r\n\r\nextern address_range* coverage_ip_ranges;\r\nextern size_t num_ip_ranges;\r\nstatic address_range* current_range;\r\n\r\nextern u8 *trace_bits;\r\n\r\n#define MAX_TRACELET_SIZE 100 // just a hint, the tracelets could end up larger\r\n#define MIN_TRACELET_SIZE 20 // just a hint, the tracelets could end up smaller\r\n\r\nunsigned char opc_lut[] = {\r\n\t0x02, 0x08, 0xff, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,\r\n\t0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x0f, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,\r\n\t0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,\r\n\t0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,\r\n\t0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,\r\n\t0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x11, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,\r\n\t0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,\r\n\t0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,\r\n\t0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,\r\n\t0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x0b, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x08, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x06, 0x09, 0x12,\r\n\t0x09, 0x07, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x05, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12,\r\n\t0x09, 0x00, 0x09, 0x12, 0x09, 0x00, 0x09, 0x12\r\n};\r\n\r\nunsigned char ext_lut[] = {\r\n\t0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x18, 0x04, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x03, 0x13, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x19, 0x0a, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x17, 0xff, 0x00, 0x00, 0x00, 0x00,\r\n\t0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\n\r\nunsigned char opc_size_lut[] = {\r\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n\t0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\r\n\t0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01,\r\n\t0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x01, 0x01,\r\n\t0x01, 0x05, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01,\r\n\t0x01, 0x05, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x02, 0x01, 0x01, 0x01, 0x05, 0x01, 0x01,\r\n\t0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,\r\n\t0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,\r\n\t0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,\r\n\t0x01, 0x07, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x02, 0x01, 0x01, 0x01, 0x07, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x09, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01,\r\n\t0x01, 0x09, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x09, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01,\r\n\t0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01\r\n};\r\n\r\nunsigned char ext_size_lut[] = {\r\n\t0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00,\r\n\t0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,\r\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\r\n};\r\n\r\nunsigned char psb[16] = {\r\n\t0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,\r\n\t0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82\r\n};\r\n\r\nstatic unsigned char psb_and_psbend[18] = {\r\n\t0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,\r\n\t0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,\r\n\t0x02, 0x23\r\n};\r\n\r\ntypedef struct decoder_state_t {\r\n\tuint64_t query_ip;\r\n\tuint64_t block_ip;\r\n\tuint8_t mode;\r\n} decoder_state;\r\n\r\ntypedef struct tracelet_cache_node_t {\r\n\tuint64_t hash;\r\n\tsize_t size;\r\n\r\n\tstruct tracelet_cache_node_t *hash_prev;\r\n\tstruct tracelet_cache_node_t *hash_next;\r\n\r\n\tstruct tracelet_cache_node_t *lru_prev;\r\n\tstruct tracelet_cache_node_t *lru_next;\r\n\r\n\tdecoder_state state_prev;\r\n\tdecoder_state state_next;\r\n\r\n\tuint8_t stack_removed;\r\n\tuint8_t stack_added;\r\n\r\n\tuint64_t *stack_prev;\r\n\tuint64_t *stack_next;\r\n\r\n\tuint32_t tracelet_size;\r\n\tunsigned char * tracelet;\r\n\r\n\tuint32_t map_update_size;\r\n\tuint32_t *map_offsets;\r\n\tuint8_t *map_updates;\r\n\r\n} tracelet_cache_node;\r\n\r\nstruct tracelet_cahe_t {\r\n\ttracelet_cache_node **hashtable;\r\n\r\n\ttracelet_cache_node *lru_first;\r\n\ttracelet_cache_node *lru_last;\r\n\r\n\tsize_t size;\r\n\tsize_t num_entries;\r\n\r\n\tsize_t max_size;\r\n\tsize_t max_entries;\r\n};\r\n\r\nstatic struct tracelet_cahe_t tracelet_cache;\r\n\r\nstruct coverage_cache_t {\r\n\tuint32_t index_buffer[MAP_SIZE];\r\n\t// need + 2 for edge coverage\r\n\tuint32_t map_offsets[MAP_SIZE + 2];\r\n\tuint8_t counters[MAP_SIZE + 2];\r\n\tuint32_t size;\r\n};\r\n\r\nvoid tracelet_coverage_init(struct coverage_cache_t *coverage_cache) {\r\n\tmemset(coverage_cache->index_buffer, 0, MAP_SIZE * sizeof(coverage_cache->index_buffer[0]));\r\n\tcoverage_cache->size = 0;\r\n}\r\n\r\nvoid tracelet_coverage_clear(struct coverage_cache_t *coverage_cache, int coverage_kind) {\r\n\tif (!coverage_cache->size) return;\r\n\r\n\tuint32_t from = 0;\r\n\tuint32_t to = coverage_cache->size;\r\n\r\n\tif (coverage_kind == COVERAGE_EDGE) {\r\n\t\t// the first and the last value have special meaning\r\n\t\t// in the case of edge coverage\r\n\t\tfrom++;\r\n\t\tto--;\r\n\t}\r\n\r\n\tfor (uint32_t i = from; i < to; i++) {\r\n\t\tcoverage_cache->index_buffer[coverage_cache->map_offsets[i]] = 0;\r\n\t}\r\n\tcoverage_cache->size = 0;\r\n}\r\n\r\nvoid tracelet_coverage_add_bb(struct coverage_cache_t *coverage_cache, uint32_t offset) {\r\n\toffset = offset % MAP_SIZE;\r\n\r\n\tif (coverage_cache->index_buffer[offset]) {\r\n\t\tcoverage_cache->counters[coverage_cache->index_buffer[offset] - 1]++;\r\n\t} else {\r\n\t\tcoverage_cache->index_buffer[offset] = coverage_cache->size + 1;\r\n\t\tcoverage_cache->map_offsets[coverage_cache->size] = offset;\r\n\t\tcoverage_cache->counters[coverage_cache->size] = 1;\r\n\t\tcoverage_cache->size++;\r\n\t}\r\n}\r\n\r\nvoid tracelet_coverage_add_edge(struct coverage_cache_t *coverage_cache, uint32_t offset) {\r\n\tuint32_t edge;\r\n\t// don't touch the global previous_offset while building the cache\r\n\t// we'll update everything once the cache gets replayed\r\n\tuint32_t previous_offset;\r\n\r\n\tif (!coverage_cache->size) {\r\n\t\t// store the first offset as the first value\r\n\t\tcoverage_cache->map_offsets[0] = offset;\r\n\t\tcoverage_cache->counters[0] = 0;\r\n\t\tcoverage_cache->size = 2;\r\n\t} else {\r\n\t\tprevious_offset = coverage_cache->map_offsets[coverage_cache->size - 1];\r\n\r\n\t\tedge = (offset ^ previous_offset) % MAP_SIZE;\r\n\r\n\t\tif (coverage_cache->index_buffer[edge]) {\r\n\t\t\tcoverage_cache->counters[coverage_cache->index_buffer[edge]]++;\r\n\t\t} else {\r\n\t\t\tcoverage_cache->index_buffer[edge] = coverage_cache->size - 1;\r\n\t\t\tcoverage_cache->map_offsets[coverage_cache->size - 1] = edge;\r\n\t\t\tcoverage_cache->counters[coverage_cache->size - 1] = 1;\r\n\t\t\tcoverage_cache->size++;\r\n\t\t}\r\n\t}\r\n\r\n\t// always store the previous offset as the last value\r\n\tprevious_offset = offset >> 1;\r\n\tcoverage_cache->map_offsets[coverage_cache->size - 1] = previous_offset;\r\n\tcoverage_cache->counters[coverage_cache->size - 1] = 0;\r\n}\r\n\r\nstatic inline uint64_t djb2(unsigned char *data, size_t size) {\r\n\tuint64_t hash = 5381;\r\n\r\n\tfor (size_t i = 0; i < size; i++) {\r\n\t\thash = (hash << 5) + hash + data[i];\r\n\t}\r\n\r\n\treturn hash;\r\n}\r\n\r\nvoid tracelet_cache_init(size_t max_entries, size_t max_size) {\r\n\ttracelet_cache.max_entries = max_entries;\r\n\ttracelet_cache.max_size = max_size;\r\n\r\n\ttracelet_cache.hashtable = (tracelet_cache_node **)calloc(max_entries, sizeof(tracelet_cache_node *));\r\n\r\n\ttracelet_cache.lru_first = NULL;\r\n\ttracelet_cache.lru_last = NULL;\r\n\r\n\ttracelet_cache.size = 0;\r\n\ttracelet_cache.num_entries = 0;\r\n}\r\n\r\n// sets the node as the least recently used\r\nvoid cache_node_touch(tracelet_cache_node *node) {\r\n\t// printf(\"accessing %p in cache\\n\", node);\r\n\r\n\tif (!node->lru_prev) return; //already at the beginning\r\n\telse node->lru_prev->lru_next = node->lru_next;\r\n\r\n\tif (node->lru_next) node->lru_next->lru_prev = node->lru_prev;\r\n\telse tracelet_cache.lru_last = node->lru_prev;\r\n\r\n\tnode->lru_prev = NULL;\r\n\tnode->lru_next = tracelet_cache.lru_first;\r\n\tif (node->lru_next) node->lru_next->lru_prev = node;\r\n\ttracelet_cache.lru_first = node;\r\n}\r\n\r\nvoid cache_node_remove(tracelet_cache_node *node) {\r\n\t// printf(\"removing %p from cache\\n\", node);\r\n\r\n\tif (node->lru_prev) node->lru_prev->lru_next = node->lru_next;\r\n\telse tracelet_cache.lru_first = node->lru_next;\r\n\r\n\tif (node->lru_next) node->lru_next->lru_prev = node->lru_prev;\r\n\telse tracelet_cache.lru_last = node->lru_prev;\r\n\r\n\tif (node->hash_prev) node->hash_prev->hash_next = node->hash_next;\r\n\telse tracelet_cache.hashtable[node->hash % tracelet_cache.max_entries] = node->hash_next;\r\n\r\n\tif (node->hash_next) node->hash_next->hash_prev = node->hash_prev;\r\n\r\n\ttracelet_cache.num_entries--;\r\n\ttracelet_cache.size -= node->size;\r\n\r\n\tfree(node);\r\n}\r\n\r\nvoid cache_remove_lru() {\r\n\ttracelet_cache_node *node = tracelet_cache.lru_last;\r\n\tif (node) cache_node_remove(node);\r\n}\r\n\r\nvoid cache_node_add(tracelet_cache_node *node) {\r\n\t// printf(\"adding %p to cache\\n\", node);\r\n\r\n\twhile (tracelet_cache.num_entries >= tracelet_cache.max_entries) cache_remove_lru();\r\n\twhile ((tracelet_cache.size + node->size) >= tracelet_cache.max_size) cache_remove_lru();\r\n\r\n\ttracelet_cache_node *prev_first;\r\n\r\n\tprev_first = tracelet_cache.hashtable[node->hash % tracelet_cache.max_entries];\r\n\ttracelet_cache.hashtable[node->hash % tracelet_cache.max_entries] = node;\r\n\r\n\tnode->hash_prev = NULL;\r\n\tnode->hash_next = prev_first;\r\n\tif (prev_first) prev_first->hash_prev = node;\r\n\r\n\tprev_first = tracelet_cache.lru_first;\r\n\ttracelet_cache.lru_first = node;\r\n\r\n\tnode->lru_prev = NULL;\r\n\tnode->lru_next = prev_first;\r\n\tif (prev_first) prev_first->lru_prev = node;\r\n\telse tracelet_cache.lru_last = node;\r\n\r\n\ttracelet_cache.num_entries++;\r\n\ttracelet_cache.size += node->size;\r\n}\r\n\r\ntracelet_cache_node *cache_find_node(uint64_t hash, decoder_state *state, unsigned char *tracelet, size_t tracelet_size, struct pt_retstack *retstack) {\r\n\ttracelet_cache_node *node = tracelet_cache.hashtable[hash % tracelet_cache.max_entries];\r\n\r\n\twhile (node) {\r\n\t\tif ((node->hash == hash) &&\r\n\t\t\t(node->state_prev.block_ip == state->block_ip) &&\r\n\t\t\t(node->state_prev.query_ip == state->query_ip) &&\r\n\t\t\t(node->state_prev.mode == state->mode) &&\r\n\t\t\t(node->tracelet_size == tracelet_size) &&\r\n\t\t\t(memcmp(node->tracelet, tracelet, tracelet_size) == 0))\r\n\t\t{\r\n\r\n\t\t\tuint8_t top = retstack->top;\r\n\t\t\tsize_t i;\r\n\t\t\tfor (i = 0; i < node->stack_removed; i++) {\r\n\t\t\t\tif (top == retstack->bottom) break;\r\n\t\t\t\ttop = (!top ? pt_retstack_size : top - 1);\r\n\t\t\t\tif (retstack->stack[top] != node->stack_prev[i]) break;\r\n\t\t\t}\r\n\t\t\tif (i == node->stack_removed) return node; // finally\r\n\r\n\t\t}\r\n\t\tnode = node->hash_next;\r\n\t}\r\n\r\n\treturn NULL;\r\n}\r\n\r\nvoid dump_lut(unsigned char *lut, char *lutname) {\r\n\tprintf(\"unsigned char %s[] = {\\n\", lutname);\r\n\tfor (int i = 0; i<32; i++) {\r\n\t\tprintf(\"\\t\");\r\n\t\tfor (int j = 0; j<8; j++) {\r\n\t\t\tprintf(\"0x%02x\", lut[i * 8 + j]);\r\n\t\t\tif (j != 7) printf(\", \");\r\n\t\t}\r\n\t\tif (i != 31) printf(\",\\n\");\r\n\t\telse printf(\"\\n\");\r\n\t}\r\n\tprintf(\"};\\n\\n\");\r\n}\r\n\r\n// function that was used to build the lookup tables for the packet decoder\r\nvoid build_luts() {\r\n\tfor (int i = 0; i<256; i++) {\r\n\t\topc_lut[i] = ppt_invalid;\r\n\t}\r\n\r\n\tfor (int i = 0; i<256; i++) {\r\n\t\text_lut[i] = ppt_invalid;\r\n\t}\r\n\r\n\tfor (int i = 0; i<256; i++) {\r\n\t\topc_size_lut[i] = 0;\r\n\t\text_size_lut[i] = 0;\r\n\t}\r\n\r\n\t//ext packets\r\n\topc_lut[pt_opc_ext] = PPT_EXT;\r\n\topc_size_lut[pt_opc_ext] = 1; // not really important\r\n\r\n\t\t\t\t\t\t\t\t  //pad packet\r\n\topc_lut[pt_opc_pad] = ppt_pad;\r\n\topc_size_lut[pt_opc_pad] = 1;\r\n\r\n\t//tip packet\r\n\tfor (int i = 0; i<8; i++) {\r\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0xd);\r\n\r\n\t\tif (i == 0) {\r\n\t\t\topc_lut[opcode] = ppt_tip;\r\n\t\t\topc_size_lut[opcode] = 1;\r\n\t\t}\r\n\t\telse if (i == 1) {\r\n\t\t\topc_lut[opcode] = ppt_tip;\r\n\t\t\topc_size_lut[opcode] = 1 + 2;\r\n\t\t}\r\n\t\telse if (i == 2) {\r\n\t\t\topc_lut[opcode] = ppt_tip;\r\n\t\t\topc_size_lut[opcode] = 1 + 4;\r\n\t\t}\r\n\t\telse if ((i == 3) || (i == 4)) {\r\n\t\t\topc_lut[opcode] = ppt_tip;\r\n\t\t\topc_size_lut[opcode] = 1 + 6;\r\n\t\t}\r\n\t\telse if (i == 6) {\r\n\t\t\topc_lut[opcode] = ppt_tip;\r\n\t\t\topc_size_lut[opcode] = 1 + 8;\r\n\t\t}\r\n\t}\r\n\r\n\t//tip.pge packet\r\n\tfor (int i = 0; i<8; i++) {\r\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0x11);\r\n\r\n\t\tif (i == 0) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pge;\r\n\t\t\topc_size_lut[opcode] = 1;\r\n\t\t}\r\n\t\telse if (i == 1) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pge;\r\n\t\t\topc_size_lut[opcode] = 1 + 2;\r\n\t\t}\r\n\t\telse if (i == 2) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pge;\r\n\t\t\topc_size_lut[opcode] = 1 + 4;\r\n\t\t}\r\n\t\telse if ((i == 3) || (i == 4)) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pge;\r\n\t\t\topc_size_lut[opcode] = 1 + 6;\r\n\t\t}\r\n\t\telse if (i == 6) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pge;\r\n\t\t\topc_size_lut[opcode] = 1 + 8;\r\n\t\t}\r\n\t}\r\n\r\n\t//tip.pgd packet\r\n\tfor (int i = 0; i<8; i++) {\r\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0x1);\r\n\r\n\t\tif (i == 0) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\r\n\t\t\topc_size_lut[opcode] = 1;\r\n\t\t}\r\n\t\telse if (i == 1) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\r\n\t\t\topc_size_lut[opcode] = 1 + 2;\r\n\t\t}\r\n\t\telse if (i == 2) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\r\n\t\t\topc_size_lut[opcode] = 1 + 4;\r\n\t\t}\r\n\t\telse if ((i == 3) || (i == 4)) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\r\n\t\t\topc_size_lut[opcode] = 1 + 6;\r\n\t\t}\r\n\t\telse if (i == 6) {\r\n\t\t\topc_lut[opcode] = ppt_tip_pgd;\r\n\t\t\topc_size_lut[opcode] = 1 + 8;\r\n\t\t}\r\n\t}\r\n\r\n\t//fup packet\r\n\tfor (int i = 0; i<8; i++) {\r\n\t\tunsigned char opcode = (unsigned char)((i << 5) + 0x1d);\r\n\r\n\t\tif (i == 0) {\r\n\t\t\topc_lut[opcode] = ppt_fup;\r\n\t\t\topc_size_lut[opcode] = 1;\r\n\t\t}\r\n\t\telse if (i == 1) {\r\n\t\t\topc_lut[opcode] = ppt_fup;\r\n\t\t\topc_size_lut[opcode] = 1 + 2;\r\n\t\t}\r\n\t\telse if (i == 2) {\r\n\t\t\topc_lut[opcode] = ppt_fup;\r\n\t\t\topc_size_lut[opcode] = 1 + 4;\r\n\t\t}\r\n\t\telse if ((i == 3) || (i == 4)) {\r\n\t\t\topc_lut[opcode] = ppt_fup;\r\n\t\t\topc_size_lut[opcode] = 1 + 6;\r\n\t\t}\r\n\t\telse if (i == 6) {\r\n\t\t\topc_lut[opcode] = ppt_fup;\r\n\t\t\topc_size_lut[opcode] = 1 + 8;\r\n\t\t}\r\n\t}\r\n\r\n\t//mode packet\r\n\topc_lut[pt_opc_mode] = ppt_mode;\r\n\topc_size_lut[pt_opc_mode] = 2;\r\n\r\n\t//tsc packet\r\n\topc_lut[pt_opc_tsc] = ppt_tsc;\r\n\topc_size_lut[pt_opc_tsc] = 8;\r\n\r\n\t//mtc packet\r\n\topc_lut[pt_opc_mtc] = ppt_mtc;\r\n\topc_size_lut[pt_opc_mtc] = 2;\r\n\r\n\t//cyc packet\r\n\tfor (int i = 0; i<64; i++) {\r\n\t\tunsigned char opcode = (unsigned char)((i << 2) + 0x3);\r\n\t\topc_lut[opcode] = ppt_cyc;\r\n\t\topc_size_lut[opcode] = 1;\r\n\t}\r\n\r\n\t//tnt packets\r\n\tfor (int i = 1; i <= 6; i++) {\r\n\t\tfor (int bits = 0; bits<(1 << i); bits++) {\r\n\t\t\tunsigned char opcode = (unsigned char)((1 << (i + 1)) + (bits << 1));\r\n\t\t\topc_lut[opcode] = ppt_tnt_8;\r\n\t\t\topc_size_lut[opcode] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t//////extensions///////\r\n\r\n\t//psb packet\r\n\text_lut[pt_ext_psb] = ppt_psb;\r\n\text_size_lut[pt_ext_psb] = 16;\r\n\r\n\t//long tnt packet\r\n\text_lut[pt_ext_tnt_64] = ppt_tnt_64;\r\n\text_size_lut[pt_ext_tnt_64] = 8;\r\n\r\n\t//pip packet\r\n\text_lut[pt_ext_pip] = ppt_pip;\r\n\text_size_lut[pt_ext_pip] = 8;\r\n\r\n\t//ovf packet\r\n\text_lut[pt_ext_ovf] = ppt_ovf;\r\n\text_size_lut[pt_ext_ovf] = 2;\r\n\r\n\t//psbend packet\r\n\text_lut[pt_ext_psbend] = ppt_psbend;\r\n\text_size_lut[pt_ext_psbend] = 2;\r\n\r\n\t//cbr packet\r\n\text_lut[pt_ext_cbr] = ppt_cbr;\r\n\text_size_lut[pt_ext_cbr] = 4;\r\n\r\n\t//tma packet\r\n\text_lut[pt_ext_tma] = ppt_tma;\r\n\text_size_lut[pt_ext_tma] = 7;\r\n\r\n\t//stop packet\r\n\text_lut[pt_ext_stop] = ppt_stop;\r\n\text_size_lut[pt_ext_stop] = 2;\r\n\r\n\t//vmcs packet\r\n\text_lut[pt_ext_vmcs] = ppt_vmcs;\r\n\text_size_lut[pt_ext_vmcs] = 7;\r\n\r\n\t//exstop packet\r\n\text_lut[pt_ext_exstop] = ppt_exstop;\r\n\text_size_lut[pt_ext_exstop] = 2;\r\n\r\n\t//exstop-ip packet\r\n\text_lut[pt_ext_exstop_ip] = ppt_exstop;\r\n\text_size_lut[pt_ext_exstop_ip] = 2;\r\n\r\n\t//mwait packet\r\n\text_lut[pt_ext_mwait] = ppt_mwait;\r\n\text_size_lut[pt_ext_mwait] = 10;\r\n\r\n\t//pwre packet\r\n\text_lut[pt_ext_pwre] = ppt_pwre;\r\n\text_size_lut[pt_ext_pwre] = 4;\r\n\r\n\t//pwrx packet\r\n\text_lut[pt_ext_pwrx] = ppt_pwrx;\r\n\text_size_lut[pt_ext_pwrx] = 7;\r\n\r\n\t//ptw packet\r\n\tfor (int i = 0; i<2; i++) {\r\n\t\tfor (int j = 0; j<2; j++) {\r\n\t\t\tunsigned char opcode = (unsigned char)((i << 7) + (j << 5) + 0x12);\r\n\t\t\text_lut[opcode] = ppt_ptw;\r\n\t\t\tif (j == 0) {\r\n\t\t\t\text_size_lut[opcode] = 6;\r\n\t\t\t}\r\n\t\t\telse if (j == 1) {\r\n\t\t\t\text_size_lut[opcode] = 10;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//ext2\r\n\text_lut[pt_ext_ext2] = PPT_EXT;\r\n\text_size_lut[pt_ext_ext2] = 1; // not really important\r\n\r\n\tdump_lut(opc_lut, \"opc_lut\");\r\n\tdump_lut(ext_lut, \"ext_lut\");\r\n\tdump_lut(opc_size_lut, \"opc_size_lut\");\r\n\tdump_lut(ext_size_lut, \"ext_size_lut\");\r\n}\r\n\r\n// sign extend\r\ninline static uint64_t sext(uint64_t val, uint8_t sign) {\r\n\tuint64_t signbit, mask;\r\n\r\n\tsignbit = 1ull << (sign - 1);\r\n\tmask = ~0ull << sign;\r\n\r\n\treturn val & signbit ? val | mask : val & ~mask;\r\n}\r\n\r\n// finds the next psb packet in the data buffer\r\nbool findpsb(unsigned char **data, size_t *size) {\r\n\tif (*size < 16) return false;\r\n\r\n\tif (memcmp(*data, psb, sizeof(psb)) == 0) return true;\r\n\r\n\tfor (size_t i = 0; i < (*size - sizeof(psb) - 1); i++) {\r\n\t\tif (((*data)[i] == psb[0]) && ((*data)[i+1] == psb[1])) {\r\n\t\t\tif (memcmp((*data) + i, psb, sizeof(psb)) == 0) {\r\n\t\t\t\t*data = *data + i;\r\n\t\t\t\t*size = *size - i;\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false;\r\n}\r\n\r\n// checks if the IP address is in one of the modules we are interested in\r\n// and updates the coverage map\r\ninline static int update_coverage_map(uint64_t next_ip, int coverage_kind) {\r\n\tuint32_t offset;\r\n\r\n\tif (next_ip < current_range->start) {\r\n\t\tdo {\r\n\t\t\tcurrent_range--;\r\n\t\t} while (next_ip < current_range->start);\r\n\t} else if (next_ip > current_range->end) {\r\n\t\tdo {\r\n\t\t\tcurrent_range++;\r\n\t\t} while (next_ip > current_range->end);\r\n\t}\r\n\r\n\tif (!current_range->collect) return 0;\r\n\r\n\t// printf(\"ip: %p\\n\", (void*)next_ip);\r\n\r\n\toffset = (uint32_t)(next_ip - current_range->start);\r\n\r\n\tswitch (coverage_kind) {\r\n\tcase COVERAGE_BB:\r\n\t\ttrace_bits[offset % MAP_SIZE]++;\r\n\t\tbreak;\r\n\tcase COVERAGE_EDGE:\r\n\t\ttrace_bits[(offset ^ previous_offset) % MAP_SIZE]++;\r\n\t\tprevious_offset = offset >> 1;\r\n\tbreak;\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\n// checks if the IP address is in one of the modules we are interested in\r\n// and updates the coverage_cache datastructure\r\ninline static int update_coverage_cache(struct coverage_cache_t *coverage_cache,\r\n\tuint64_t next_ip, int coverage_kind)\r\n{\r\n\r\n\tuint32_t offset;\r\n\r\n\tif (next_ip < current_range->start) {\r\n\t\tdo {\r\n\t\t\tcurrent_range--;\r\n\t\t} while (next_ip < current_range->start);\r\n\t}\r\n\telse if (next_ip > current_range->end) {\r\n\t\tdo {\r\n\t\t\tcurrent_range++;\r\n\t\t} while (next_ip > current_range->end);\r\n\t}\r\n\r\n\tif (!current_range->collect) return 0;\r\n\r\n\t// printf(\"ip: %p\\n\", (void*)next_ip);\r\n\r\n\toffset = (uint32_t)(next_ip - current_range->start);\r\n\r\n\tswitch (coverage_kind) {\r\n\tcase COVERAGE_BB:\r\n\t\ttracelet_coverage_add_bb(coverage_cache, offset);\r\n\t\tbreak;\r\n\tcase COVERAGE_EDGE:\r\n\t\ttracelet_coverage_add_edge(coverage_cache, offset);\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn 1;\r\n}\r\n\r\n// gets the opcode and the size of the next packet in the trace buffer\r\nstatic inline int get_next_opcode(unsigned char **data_p, size_t *size_p, \r\n\tunsigned char *opcode_p, unsigned char *opcodesize_p)\r\n{\r\n\r\n\tunsigned char *data = *data_p;\r\n\tsize_t size = *size_p;\r\n\r\n\tunsigned char opcode = opc_lut[*data];\r\n\tunsigned char opcodesize = opc_size_lut[*data];\r\n    \r\n    // handle extensions\r\n    if(opcode == PPT_EXT) {\r\n      if(size < 2) return 0;\r\n\r\n      opcode = ext_lut[*(data+1)];\r\n      opcodesize = ext_size_lut[*(data+1)];\r\n\r\n      // second-level extension\r\n      if(opcode == PPT_EXT) {\r\n        if(size < 3) return 0;\r\n        \r\n        // currently there is only one possibility\r\n        if((*(data+2)) == 0x88) {\r\n          opcode = ppt_mnt;\r\n          opcodesize = 11;\r\n        } else {\r\n          opcode = ppt_invalid;\r\n          opcodesize = 0;\r\n        }\r\n      }\r\n    } else if(opcode == ppt_cyc) {\r\n      // special handling for cyc packets since\r\n      // they don't have a predetermined size\r\n      if(*data & 4) {\r\n        opcodesize = 2;\r\n\r\n        while(1) {\r\n          if(size < opcodesize) return 0;\r\n          if(!((*(data + (opcodesize - 1))) & 1)) break;\r\n          opcodesize++;\r\n        }\r\n      }\r\n    }\r\n\r\n\tif (size < opcodesize) return 0;\r\n\r\n\t*opcode_p = opcode;\r\n\t*opcodesize_p = opcodesize;\r\n\r\n\treturn 1;\r\n}\r\n\r\nstatic inline uint64_t decode_ip(unsigned char *data) {\r\n\tuint64_t next_ip;\r\n\r\n\tswitch ((*data) >> 5) {\r\n\tcase 0:\r\n\t\tnext_ip = previous_ip;\r\n\t\tbreak;\r\n\tcase 1:\r\n\t\tnext_ip = (previous_ip & 0xFFFFFFFFFFFF0000ULL) | *((uint16_t *)(data + 1));\r\n\t\tbreak;\r\n\tcase 2:\r\n\t\tnext_ip = (previous_ip & 0xFFFFFFFF00000000ULL) | *((uint32_t *)(data + 1));\r\n\t\tbreak;\r\n\tcase 3:\r\n\t\tnext_ip = sext(*((uint32_t *)(data + 1)) | ((uint64_t)(*((uint16_t *)(data + 5))) << 32), 48);\r\n\t\tbreak;\r\n\tcase 4:\r\n\t\tnext_ip = (previous_ip & 0xFFFF000000000000ULL) | *((uint32_t *)(data + 1)) | ((uint64_t)(*((uint16_t *)(data + 5))) << 32);\r\n\t\tbreak;\r\n\tcase 6:\r\n\t\tnext_ip = *((uint64_t *)(data + 1));\r\n\t\tbreak;\r\n\t}\r\n\tprevious_ip = next_ip;\r\n\r\n\treturn next_ip;\r\n}\r\n\r\n// returns the type of the first packet or ppt_invalid\r\nint get_next_tracelet(unsigned char **data, size_t *size,\r\n\tunsigned char **tracelet_data, size_t *tracelet_size)\r\n{\r\n\tunsigned char opcode;\r\n\tunsigned char opcodesize;\r\n\tunsigned char previous_opcode = ppt_invalid;\r\n\tint ret = ppt_tnt_8;\r\n\r\n\twhile (*size) {\r\n\r\n\t\tif (!get_next_opcode(data, size, &opcode, &opcodesize))\r\n\t\t\treturn ppt_invalid;\r\n\r\n\t\tif (opcode == ppt_invalid) return ppt_invalid;\r\n\r\n\t\t// printf(\"packet type: %d\\n\", opcode);\r\n\r\n\t\tswitch (opcode) {\r\n\t\tcase ppt_tnt_8:\r\n\t\tcase ppt_tnt_64:\r\n\t\t\t// merge tiny tracelets\r\n\t\t\tif (*tracelet_size > MIN_TRACELET_SIZE) {\r\n\t\t\t\t// always cut before tnt preceeded by non-tnt\r\n\t\t\t\tif (previous_opcode != ppt_invalid &&\r\n\t\t\t\t\tprevious_opcode != ppt_tnt_8 &&\r\n\t\t\t\t\tprevious_opcode != ppt_tnt_64)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\t\t\t\t// cut very long streams of tnt packets\r\n\t\t\t\tif (*tracelet_size > MAX_TRACELET_SIZE) {\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tmemcpy(*tracelet_data, *data, opcodesize);\r\n\t\t\t*tracelet_data += opcodesize;\r\n\t\t\t*tracelet_size += opcodesize;\r\n\t\t\t*size -= opcodesize;\r\n\t\t\t*data += opcodesize;\r\n\t\t\tprevious_opcode = opcode;\r\n\t\t\tbreak;\r\n\t\tcase ppt_psb:\r\n\t\t\t// let the caller know there is a psb in this tracelet\r\n\t\t\tret = ppt_psb;\r\n\t\tcase ppt_psbend:\r\n\t\tcase ppt_fup:\r\n\t\tcase ppt_tip:\r\n\t\tcase ppt_tip_pge:\r\n\t\tcase ppt_tip_pgd:\r\n\t\tcase ppt_ovf:\r\n\t\tcase ppt_mode:\r\n\t\t\t// just copy these packets\r\n\t\t\tmemcpy(*tracelet_data, *data, opcodesize);\r\n\t\t\t*tracelet_data += opcodesize;\r\n\t\t\t*tracelet_size += opcodesize;\r\n\t\t\t*size -= opcodesize;\r\n\t\t\t*data += opcodesize;\r\n\t\t\tprevious_opcode = opcode;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\t// skip over all other packets\r\n\t\t\t*size -= opcodesize;\r\n\t\t\t*data += opcodesize;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\n// checks if the trace starts with the expected IP address\r\nint check_trace_start(unsigned char *data, size_t size, uint64_t expected_ip) {\r\n\tunsigned char opcode;\r\n\tunsigned char opcodesize;\r\n\r\n\tprevious_ip = 0;\r\n\r\n\twhile (size) {\r\n\t\tif (!get_next_opcode(&data, &size, &opcode, &opcodesize)) return 0;\r\n\r\n\t\tswitch (opcode) {\r\n\t\tcase ppt_tip_pge:\r\n\t\t\tif (decode_ip(data) == expected_ip) return 1;\r\n\t\t\telse return 0;\r\n\t\tcase ppt_fup:\r\n\t\tcase ppt_tip:\r\n\t\tcase ppt_tnt_8:\r\n\t\tcase ppt_tnt_64:\r\n\t\tcase ppt_tip_pgd:\r\n\t\tcase ppt_invalid:\r\n\t\t\treturn 0;\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tsize -= opcodesize;\r\n\t\tdata += opcodesize;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n\r\n// fast decoder that decodes only tip (and related packets)\r\n// and skips over the reset\r\nvoid decode_trace_tip_fast(unsigned char *data, size_t size, int coverage_kind) {\r\n  uint64_t next_ip;\r\n\r\n  unsigned char opcode;\r\n  unsigned char opcodesize;\r\n\r\n  previous_offset = 0;\r\n  previous_ip = 0;\r\n  current_range = &(coverage_ip_ranges[0]);\r\n\r\n  if (size < sizeof(psb)) return;\r\n\r\n  if (!findpsb(&data, &size)) {\r\n\t  FATAL(\"No sync packets in trace\\n\");\r\n\t  return;\r\n  }\r\n\r\n  while(size) {\r\n\r\n\tif (!get_next_opcode(&data, &size, &opcode, &opcodesize)) return;\r\n\r\n    if(opcode == ppt_invalid) {\r\n      printf(\"Decoding error\\n\");\r\n\t  if (findpsb(&data, &size)) continue;\r\n\t  else return;\r\n    }\r\n\r\n\t// printf(\"packet type: %d\\n\", opcode);\r\n\r\n    switch (opcode) {\r\n    case ppt_fup:\r\n    case ppt_tip:\r\n    case ppt_tip_pge:\r\n    case ppt_tip_pgd:\r\n\t  next_ip = decode_ip(data);\r\n      break;\r\n    default:\r\n      break;\r\n    }\r\n\r\n\tif (opcode == ppt_tip) {\r\n\t\t// printf(\"ip: %p\\n\", (void*)next_ip);\r\n\t\tupdate_coverage_map(next_ip, coverage_kind);\r\n\t}\r\n\r\n    size -= opcodesize;\r\n    data += opcodesize;\r\n  }\r\n}\r\n\r\n// process a sinle IPT packet and update AFL map\r\ninline static void process_packet(struct pt_packet *packet, int coverage_kind) {\r\n\t// printf(\"packet type: %d\\n\", packet->type);\r\n\r\n\tif ((packet->type != ppt_tip) && (packet->type != ppt_tip_pge) && (packet->type != ppt_tip_pgd) && (packet->type != ppt_fup)) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tuint64_t next_ip;\r\n\tswitch (packet->payload.ip.ipc) {\r\n\tcase pt_ipc_update_16:\r\n\t\tnext_ip = (previous_ip & 0xFFFFFFFFFFFF0000ULL) | (packet->payload.ip.ip & 0xFFFF);\r\n\t\tbreak;\r\n\tcase pt_ipc_update_32:\r\n\t\tnext_ip = (previous_ip & 0xFFFFFFFF00000000ULL) | (packet->payload.ip.ip & 0xFFFFFFFF);\r\n\t\tbreak;\r\n\tcase pt_ipc_update_48:\r\n\t\tnext_ip = (previous_ip & 0xFFFF000000000000ULL) | (packet->payload.ip.ip & 0xFFFFFFFFFFFF);\r\n\t\tbreak;\r\n\tcase pt_ipc_sext_48:\r\n\t\tnext_ip = sext(packet->payload.ip.ip, 48);\r\n\t\tbreak;\r\n\tcase pt_ipc_full:\r\n\t\tnext_ip = packet->payload.ip.ip;\r\n\t\tbreak;\r\n\tdefault:\r\n\t\treturn;\r\n\t}\r\n\r\n\tprevious_ip = next_ip;\r\n\r\n\tif (packet->type == ppt_tip) {\r\n\t\t// printf(\"ip: %p\\n\", (void*)next_ip);\r\n\t\tupdate_coverage_map(next_ip, coverage_kind);\r\n\t}\r\n}\r\n\r\n// decodes only TIP packets using the reference implementation\r\nvoid decode_trace_tip_reference(unsigned char *trace_data, size_t trace_size,\r\n\tint coverage_kind)\r\n{\r\n\t// printf(\"analyzing trace\\n\");\r\n\r\n\tstruct pt_packet_decoder *decoder;\r\n\tstruct pt_config ptc;\r\n\tstruct pt_packet packet;\r\n\r\n\tprevious_offset = 0;\r\n\tprevious_ip = 0;\r\n\tcurrent_range = &(coverage_ip_ranges[0]);\r\n\r\n\tpt_config_init(&ptc);\r\n\tpt_cpu_read(&ptc.cpu);\r\n\tpt_cpu_errata(&ptc.errata, &ptc.cpu);\r\n\tptc.begin = trace_data;\r\n\tptc.end = trace_data + trace_size;\r\n\r\n\tdecoder = pt_pkt_alloc_decoder(&ptc);\r\n\tif (!decoder) {\r\n\t\tFATAL(\"Error allocating decoder\\n\");\r\n\t}\r\n\r\n\tfor (;;) {\r\n\t\tif (pt_pkt_sync_forward(decoder) < 0) {\r\n\t\t\t// printf(\"No more sync packets\\n\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tfor (;;) {\r\n\t\t\tif (pt_pkt_next(decoder, &packet, sizeof(packet)) < 0) {\r\n\t\t\t\t// printf(\"Error reding packet\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tprocess_packet(&packet, coverage_kind);\r\n\t\t}\r\n\t}\r\n\r\n\tpt_pkt_free_decoder(decoder);\r\n}\r\n\r\n\r\n// looks up if we already have the tracelet in cache and if so update\r\n// the state and coverage from the cache entry\r\ninline static bool process_tracelet_from_cache(uint64_t hash,\r\n\tdecoder_state *state, unsigned char *tracelet, \r\n\tsize_t tracelet_size, struct pt_retstack *retstack,\r\n\tint coverage_kind)\r\n{\r\n\r\n\ttracelet_cache_node *cache_node = cache_find_node(hash, state, tracelet, tracelet_size, retstack);\r\n\r\n\tif (!cache_node) return false;\r\n\r\n\t// mark the node as least recently used\r\n\tcache_node_touch(cache_node);\r\n\r\n\t// update state from cache\r\n\t*state = cache_node->state_next;\r\n\r\n\t// update stack if needed\r\n\tif (cache_node->stack_removed || cache_node->stack_added) {\r\n\t\tuint8_t top, bottom;\r\n\t\ttop = retstack->top;\r\n\t\tbottom = retstack->bottom;\r\n\r\n\t\tfor (uint32_t i = 0; i < cache_node->stack_removed; i++) {\r\n\t\t\ttop = (!top ? pt_retstack_size : top - 1);\r\n\t\t}\r\n\r\n\t\tfor (uint32_t i = 0; i < cache_node->stack_added; i++) {\r\n\t\t\tretstack->stack[top] = cache_node->stack_next[i];\r\n\t\t\ttop = (top == pt_retstack_size ? 0 : top + 1);\r\n\t\t\tif (bottom == top) bottom = (bottom == pt_retstack_size ? 0 : bottom + 1);\r\n\t\t}\r\n\r\n\t\tretstack->top = top;\r\n\t\tretstack->bottom = bottom;\r\n\t}\r\n\r\n\t// update trace_bits\r\n\tswitch (coverage_kind) {\r\n\tcase COVERAGE_BB:\r\n\t\tfor (uint32_t i = 0; i < cache_node->map_update_size; i++) {\r\n\t\t\ttrace_bits[cache_node->map_offsets[i]] += cache_node->map_updates[i];\r\n\t\t}\r\n\t\tbreak;\r\n\tcase COVERAGE_EDGE:\r\n\t\tif (cache_node->map_update_size) {\r\n\t\t\ttrace_bits[(cache_node->map_offsets[0] ^ previous_offset) % MAP_SIZE]++;\r\n\t\t\tfor (uint32_t i = 1; i < cache_node->map_update_size - 1; i++) {\r\n\t\t\t\ttrace_bits[cache_node->map_offsets[i]] += cache_node->map_updates[i];\r\n\t\t\t}\r\n\t\t\tprevious_offset = cache_node->map_offsets[cache_node->map_update_size - 1];\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n// processes a tracelet using the reference decoder\r\ninline static int process_tracelet_reference(struct pt_block_decoder *decoder,\r\n\tuint8_t *tracelet_end, decoder_state *state_before, decoder_state *state_after,\r\n\tstruct pt_retstack *retstack_before, int *stack_added, int *stack_removed,\r\n\tstruct coverage_cache_t *coverage_cache, int coverage_kind,\r\n\tbool first_tracelet, bool track_stack, bool *skip_next)\r\n{\r\n\r\n\tint stack_last;\r\n\tint status;\r\n\r\n\tstruct pt_event event;\r\n\tstruct pt_block block;\r\n\r\n\tdecoder->query.config.end = tracelet_end;\r\n\tstatus = pt_blk_sync_set(decoder, 0);\r\n\r\n\tif (status < 0) return status;\r\n\r\n\t// restore state\r\n\tif (!first_tracelet) {\r\n\t\tdecoder->query.ip.ip = state_before->query_ip;\r\n\t\tdecoder->query.ip.have_ip = 1;\r\n\t\tdecoder->query.ip.suppressed = 0;\r\n\t\tdecoder->enabled = 1;\r\n\t\tdecoder->mode = state_before->mode;\r\n\t\tdecoder->ip = state_before->block_ip;\r\n\t\tdecoder->retstack = *retstack_before;\r\n\t}\r\n\r\n\tstack_last = retstack_before->top;\r\n\r\n\t*stack_added = 0;\r\n\t*stack_removed = 0;\r\n\r\n\ttracelet_coverage_clear(coverage_cache, coverage_kind);\r\n\r\n\tfor (;;) {\r\n\t\t// we aren't really interested in events\r\n\t\t// but have to empty the event queue\r\n\t\twhile (status & pts_event_pending) {\r\n\t\t\tstatus = pt_blk_event(decoder, &event, sizeof(event));\r\n\t\t\tif (status < 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t// printf(\"event %d\\n\", event.type);\r\n\t\t}\r\n\r\n\t\tif (status < 0) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tstatus = pt_blk_next(decoder, &block, sizeof(block));\r\n\r\n\t\tif (track_stack) {\r\n\t\t\tif (decoder->retstack.top != stack_last) {\r\n\t\t\t\tif ((decoder->retstack.top == stack_last - 1) ||\r\n\t\t\t\t\t(decoder->retstack.top == 64) && (stack_last == 0)) {\r\n\t\t\t\t\t*stack_added -= 1;\r\n\t\t\t\t\tif (*stack_added < *stack_removed) *stack_removed = *stack_added;\r\n\t\t\t\t}\r\n\t\t\t\telse if ((decoder->retstack.top == stack_last + 1) ||\r\n\t\t\t\t\t(decoder->retstack.top == 0) && (stack_last == 64)) {\r\n\t\t\t\t\t*stack_added += 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tFATAL(\"Error: unexpected stack change\");\r\n\t\t\t\t}\r\n\t\t\t\tstack_last = decoder->retstack.top;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (status < 0) {\r\n\t\t\t// printf(\"status: %d\\n\", status);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (!*skip_next) {\r\n\t\t\t*skip_next = false;\r\n\t\t\tupdate_coverage_cache(coverage_cache, block.ip, coverage_kind);\r\n\t\t\t// printf(\"ip: %p, %d %d\\n\", (void *)block.ip, status, block.iclass);\r\n\t\t}\r\n\r\n\t\t// Sometimes, due to asynchronous events and other reasons (?)\r\n\t\t// the tracing of a basic block will break in the middle of it\r\n\t\t// and the subsequent basic block will continue where the previous\r\n\t\t// one was broken, resulting in new coverage detected where there\r\n\t\t// was none.\r\n\t\t// Currently, this is resolved by examining the instruction class of\r\n\t\t// the last instruction in the basic block. If it is not one of the \r\n\t\t// instructions that normally terminate a basic block, we will simply\r\n\t\t// ignore the subsequent block.\r\n\t\t// Another way to do this could be to compute the address of the next\r\n\t\t// instruction after the basic block, and only ignore a subsequent block\r\n\t\t// if it starts on that address\r\n\t\tif (block.iclass == ptic_other) *skip_next = true;\r\n\t\telse *skip_next = false;\r\n\t}\r\n\r\n\tstate_after->query_ip = decoder->query.ip.ip;\r\n\tstate_after->mode = decoder->mode;\r\n\tstate_after->block_ip = block.ip;\r\n\r\n\tswitch (coverage_kind) {\r\n\tcase COVERAGE_BB:\r\n\t\tfor (uint32_t i = 0; i < coverage_cache->size; i++) {\r\n\t\t\ttrace_bits[coverage_cache->map_offsets[i]] += coverage_cache->counters[i];\r\n\t\t}\r\n\t\tbreak;\r\n\tcase COVERAGE_EDGE:\r\n\t\tif (coverage_cache->size) {\r\n\t\t\ttrace_bits[(coverage_cache->map_offsets[0] ^ previous_offset) % MAP_SIZE]++;\r\n\t\t\tfor (uint32_t i = 1; i < coverage_cache->size - 1; i++) {\r\n\t\t\t\ttrace_bits[coverage_cache->map_offsets[i]] += coverage_cache->counters[i];\r\n\t\t\t}\r\n\t\t\tprevious_offset = coverage_cache->map_offsets[coverage_cache->size - 1];\r\n\t\t}\r\n\t\tbreak;\r\n\t}\r\n\r\n\treturn status;\r\n}\r\n\r\n\r\n// constructs the cache node from the decoder state, tracelet etc\r\n// and adds it to the cache\r\nstatic inline void add_cache_node(\r\n\tuint8_t *tracelet, size_t tracelet_size, uint64_t hash,\r\n\tdecoder_state *state_before, decoder_state *state_after,\r\n\tstruct pt_retstack *retstack_before, struct pt_retstack *retstack_after,\r\n\tint stack_added, int stack_removed,\r\n\tstruct coverage_cache_t *coverage_cache)\r\n{\r\n\tstack_removed = -stack_removed;\r\n\tstack_added += stack_removed;\r\n\r\n\tif (stack_removed > (pt_retstack_size + 1)) stack_removed = (pt_retstack_size + 1);\r\n\r\n\tif (stack_added < 0) stack_added = 0;\r\n\tif (stack_added >(pt_retstack_size + 1)) stack_added = (pt_retstack_size + 1);\r\n\r\n\tsize_t node_size = sizeof(tracelet_cache_node) +\r\n\t\tstack_removed * sizeof(uint64_t) + stack_added * sizeof(uint64_t) +\r\n\t\tcoverage_cache->size * sizeof(uint32_t) + coverage_cache->size * sizeof(uint8_t) +\r\n\t\ttracelet_size;\r\n\r\n\ttracelet_cache_node *cache_node = (tracelet_cache_node *)malloc(node_size);\r\n\r\n\tcache_node->size = node_size;\r\n\tcache_node->hash = hash;\r\n\r\n\tuint8_t* ptr = (uint8_t*)cache_node + sizeof(tracelet_cache_node);\r\n\tcache_node->stack_prev = (uint64_t *)ptr;\r\n\tcache_node->stack_removed = stack_removed;\r\n\tptr += stack_removed * sizeof(uint64_t);\r\n\tcache_node->stack_next = (uint64_t *)ptr;\r\n\tcache_node->stack_added = stack_added;\r\n\tptr += stack_added * sizeof(uint64_t);\r\n\tcache_node->map_offsets = (uint32_t *)ptr;\r\n\tptr += coverage_cache->size * sizeof(uint32_t);\r\n\tcache_node->map_updates = ptr;\r\n\tcache_node->map_update_size = coverage_cache->size;\r\n\tptr += coverage_cache->size * sizeof(uint8_t);\r\n\tcache_node->tracelet = ptr;\r\n\tcache_node->tracelet_size = (uint32_t)tracelet_size;\r\n\r\n\tuint8_t top;\r\n\ttop = retstack_before->top;\r\n\tfor (int i = 0; i < stack_removed; i++) {\r\n\t\ttop = (!top ? pt_retstack_size : top - 1);\r\n\t\tcache_node->stack_prev[i] = retstack_before->stack[top];\r\n\t}\r\n\r\n\ttop = retstack_after->top;\r\n\tfor (int i = 0; i < stack_added; i++) {\r\n\t\ttop = (!top ? pt_retstack_size : top - 1);\r\n\t\tcache_node->stack_next[stack_added - i - 1] = retstack_after->stack[top];\r\n\t}\r\n\r\n\tmemcpy(cache_node->map_offsets, coverage_cache->map_offsets, coverage_cache->size * sizeof(uint32_t));\r\n\tmemcpy(cache_node->map_updates, coverage_cache->counters, coverage_cache->size * sizeof(uint8_t));\r\n\r\n\tmemcpy(cache_node->tracelet, tracelet, tracelet_size);\r\n\r\n\tcache_node->state_prev = *state_before;\r\n\tcache_node->state_next = *state_after;\r\n\r\n\tcache_node_add(cache_node);\r\n}\r\n\r\n// uses a faster basic block decoder to decode the full trace\r\n// tl;dr the faster decoder is essentially a caching layer on top of the\r\n// reference decoder\r\n// needs to have access to executable memory of the process that generated\r\n// the trace (passed through pt_image)\r\nvoid analyze_trace_full_fast(unsigned char *trace_data, size_t trace_size,\r\n\tint coverage_kind, struct pt_image *image, bool skip_first_bb)\r\n{\r\n\t// some stats\r\n\tint num_tracelets=0, num_cache_hits=0;\r\n\r\n\tsize_t tracelet_buffer_size = trace_size + sizeof(psb_and_psbend);\r\n\tunsigned char *tracelet_buffer = malloc(tracelet_buffer_size);\r\n\tsize_t tracelet_size;\r\n\r\n\tmemcpy(tracelet_buffer, psb_and_psbend, sizeof(psb_and_psbend));\r\n\tunsigned char *buffer_after_psb = tracelet_buffer + sizeof(psb_and_psbend);\r\n\tunsigned char *tracelet_start;\r\n\r\n\tdecoder_state state, state_next;\r\n\tstruct pt_retstack retstack;\r\n\tretstack.top = 0;\r\n\tretstack.bottom = 0;\r\n\r\n\tuint64_t hash;\r\n\r\n\tint stack_removed;\r\n\tint stack_added;\r\n\r\n\tstruct pt_block_decoder *decoder;\r\n\tstruct pt_config config;\r\n\r\n\tbool skip_next = skip_first_bb;\r\n\tbool first_tracelet = true;\r\n\tbool use_cache = false;\r\n\r\n\tprevious_offset = 0;\r\n\tprevious_ip = 0;\r\n\tcurrent_range = &(coverage_ip_ranges[0]);\r\n\r\n\tstruct coverage_cache_t *coverage_cache =\r\n\t\t(struct coverage_cache_t *)malloc(sizeof(struct coverage_cache_t));\r\n\ttracelet_coverage_init(coverage_cache);\r\n\r\n\tpt_config_init(&config);\r\n\tpt_cpu_read(&config.cpu);\r\n\tpt_cpu_errata(&config.errata, &config.cpu);\r\n\tconfig.begin = tracelet_buffer;\r\n\tconfig.end = tracelet_buffer + tracelet_buffer_size;\r\n\r\n\t// This is important not only for accurate coverage, but also because\r\n\t// if we don't set it, the decoder is sometimes going to break\r\n\t// blocks on these instructions anyway, resulting in new coverage being\r\n\t// detected where there in fact was none.\r\n\t// See also skip_next comment below\r\n\tconfig.flags.variant.block.end_on_call = 1;\r\n\tconfig.flags.variant.block.end_on_jump = 1;\r\n\r\n\tdecoder = pt_blk_alloc_decoder(&config);\r\n\tif (!decoder) {\r\n\t\tFATAL(\"Error allocating decoder\\n\");\r\n\t}\r\n\r\n\tint ret = pt_blk_set_image(decoder, image);\r\n\r\n\tint status;\r\n\r\n\tif (!findpsb(&trace_data, &trace_size)) {\r\n\t\tFATAL(\"No sync packets in trace\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tfor (;;) {\r\n\t\ttracelet_start = buffer_after_psb;\r\n\t\ttracelet_size = 0;\r\n\r\n\t\tint ret = get_next_tracelet(&trace_data, &trace_size, &tracelet_start, &tracelet_size);\r\n\r\n\t\tif (!tracelet_size) break;\r\n\r\n\t\tif (ret == ppt_invalid) {\r\n\t\t\tif (!findpsb(&trace_data, &trace_size)) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tfirst_tracelet = true;\r\n\t\t\tskip_next = true;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse if (ret == ppt_psb) {\r\n\t\t\t// don't use cache for tracelets containing psb\r\n\t\t\t// psbs are going to mess up our stack tracking\r\n\t\t\tuse_cache = false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tuse_cache = true;\r\n\t\t}\r\n\r\n\t\tif (skip_next) {\r\n\t\t\tuse_cache = false;\r\n\t\t}\r\n\r\n\t\tnum_tracelets++;\r\n\r\n\t\t// printf(\"tracelet size: %llu\\n\", tracelet_size);\r\n\r\n\t\thash = djb2(buffer_after_psb, tracelet_size);\r\n\r\n\t\t// printf(\"hash: %llx\\n\", hash);\r\n\r\n\t\tif (use_cache &&\r\n\t\t\tprocess_tracelet_from_cache(hash, &state, buffer_after_psb,\r\n\t\t\t\ttracelet_size, &retstack, coverage_kind))\r\n\t\t{\r\n\t\t\tnum_cache_hits++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tstatus = process_tracelet_reference(decoder, tracelet_start,\r\n\t\t\t&state, &state_next, &retstack, &stack_added, &stack_removed,\r\n\t\t\tcoverage_cache, coverage_kind, first_tracelet, use_cache,\r\n\t\t\t&skip_next);\r\n\r\n\t\tfirst_tracelet = false;\r\n\r\n\t\tif ((status < 0) && (status != -pte_eos)) {\r\n\t\t\tif (!findpsb(&trace_data, &trace_size)) {\r\n\t\t\t\tprintf(\"cant't sync\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tskip_next = true;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (use_cache && !skip_next) {\r\n\t\t\t// create a new cache node and add it to the cache\r\n\t\t\tadd_cache_node(buffer_after_psb, tracelet_size, hash,\r\n\t\t\t\t&state, &state_next, &retstack, &decoder->retstack,\r\n\t\t\t\tstack_added, stack_removed, coverage_cache);\r\n\t\t}\r\n\r\n\t\t// switch state\r\n\t\tstate = state_next;\r\n\t\tretstack = decoder->retstack;\r\n\t}\r\n\r\n\tfree(coverage_cache);\r\n\tfree(tracelet_buffer);\r\n\r\n\tpt_blk_free_decoder(decoder);\r\n\r\n\t// printf(\"Cache hits: %d/%d (%g%%)\\n\", num_cache_hits, num_tracelets,\r\n\t// \t((float)num_cache_hits / num_tracelets) * 100);\r\n\t// printf(\"tracelet cache num entries: %llu, size: %llu\\n\",\r\n\t// \ttracelet_cache.num_entries, tracelet_cache.size);\r\n}\r\n\r\n// uses Intel's reference basic block decoder to decode the full trace\r\n// needs to have access to executable memory of the process that generated\r\n// the trace (passed through pt_image)\r\nvoid analyze_trace_full_reference(unsigned char *trace_data, size_t trace_size,\r\n\tint coverage_kind, struct pt_image *image, bool skip_first_bb) {\r\n\r\n\tstruct pt_block_decoder *decoder;\r\n\tstruct pt_config config;\r\n\tstruct pt_event event;\r\n\tstruct pt_block block;\r\n\r\n\tbool skip_next = skip_first_bb;\r\n\r\n\tprevious_offset = 0;\r\n\tprevious_ip = 0;\r\n\tcurrent_range = &(coverage_ip_ranges[0]);\r\n\r\n\tpt_config_init(&config);\r\n\tpt_cpu_read(&config.cpu);\r\n\tpt_cpu_errata(&config.errata, &config.cpu);\r\n\tconfig.begin = trace_data;\r\n\tconfig.end = trace_data + trace_size;\r\n\r\n\t// This is important not only for accurate coverage, but also because\r\n\t// if we don't set it, the decoder is sometimes going to break\r\n\t// blocks on these instructions anyway, resulting in new coverage being\r\n\t// detected where there in fact was none.\r\n\t// See also skip_next comment below\r\n\tconfig.flags.variant.block.end_on_call = 1;\r\n\tconfig.flags.variant.block.end_on_jump = 1;\r\n\r\n\tdecoder = pt_blk_alloc_decoder(&config);\r\n\tif (!decoder) {\r\n\t\tFATAL(\"Error allocating decoder\\n\");\r\n\t}\r\n\r\n\tint ret = pt_blk_set_image(decoder, image);\r\n\r\n\tint status;\r\n\r\n\tfor (;;) {\r\n\t\tstatus = pt_blk_sync_forward(decoder);\r\n\t\tif (status < 0) {\r\n\t\t\t// printf(\"cant't sync\\n\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tfor (;;) {\r\n\r\n\t\t\t// we aren't really interested in events\r\n\t\t\t// but have to empty the event queue\r\n\t\t\twhile (status & pts_event_pending) {\r\n\t\t\t\tstatus = pt_blk_event(decoder, &event, sizeof(event));\r\n\t\t\t\tif (status < 0)\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t// printf(\"event %d\\n\", event.type);\r\n\t\t\t}\r\n\r\n\t\t\tif (status < 0)\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tstatus = pt_blk_next(decoder, &block, sizeof(block));\r\n\r\n\t\t\tif (status < 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (!skip_next) {\r\n\t\t\t\tskip_next = false;\r\n\t\t\t\tupdate_coverage_map(block.ip, coverage_kind);\r\n\t\t\t\t// printf(\"ip: %p, %d %d\\n\", (void *)block.ip, status, block.iclass);\r\n\t\t\t}\r\n\r\n\t\t\t// Sometimes, due to asynchronous events and other reasons (?)\r\n\t\t\t// the tracing of a basic block will break in the middle of it\r\n\t\t\t// and the subsequent basic block will continue where the previous\r\n\t\t\t// one was broken, resulting in new coverage detected where there\r\n\t\t\t// was none.\r\n\t\t\t// Currently, this is resolved by examining the instruction class of\r\n\t\t\t// the last instruction in the basic block. If it is not one of the \r\n\t\t\t// instructions that normally terminate a basic block, we will simply\r\n\t\t\t// ignore the subsequent block.\r\n\t\t\t// Another way to do this could be to compute the address of the next\r\n\t\t\t// instruction after the basic block, and only ignore a subsequent block\r\n\t\t\t// if it starts on that address\r\n\t\t\tif (block.iclass == ptic_other) skip_next = true;\r\n\t\t\telse skip_next = false;\r\n\t\t}\r\n\t}\r\n\r\n\tpt_blk_free_decoder(decoder);\r\n}\r\n"
        },
        {
          "name": "ptdecode.h",
          "type": "blob",
          "size": 1.4765625,
          "content": "/*\r\n  WinAFL - Intel PT decoding\r\n  ------------------------------------------------\r\n\r\n  Written and maintained by Ivan Fratric <ifratric@google.com>\r\n\r\n  Copyright 2016 Google Inc. All Rights Reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\ntypedef struct _address_range {\r\n\tuint64_t start;\r\n\tuint64_t end;\r\n\tchar collect; // collect coverage for range or not\r\n} address_range;\r\n\r\nint check_trace_start(unsigned char *data, size_t size, uint64_t expected_ip);\r\n\r\nvoid tracelet_cache_init(size_t max_entries, size_t max_size);\r\n\r\nvoid analyze_trace_full_reference(unsigned char *trace_data, size_t trace_size, int coverage_kind, struct pt_image *image, bool skip_first_bb);\r\nvoid analyze_trace_full_fast(unsigned char *trace_data, size_t trace_size, int coverage_kind, struct pt_image *image, bool skip_first_bb);\r\nvoid decode_trace_tip_fast(unsigned char *data, size_t size, int coverage_kind);\r\nvoid decode_trace_tip_reference(unsigned char *trace_data, size_t trace_size, int coverage_kind);"
        },
        {
          "name": "readme_dr.md",
          "type": "blob",
          "size": 9.2705078125,
          "content": "# Dynamorio Instrumentation mode\n\n## How it works\n\nThis mode relies on dynamic instrumentation using DynamoRIO\n(http://dynamorio.org/) to measure and extract target coverage. This approach\nhas been found to introduce an overhead about 2x compared to the native\nexecution speed, which is comparable to the original AFL in binary\ninstrumentation mode.\n\nIn order to use it you need to\n\n - download and build DynamoRIO sources or download DynamoRIO Windows binary\npackage from https://github.com/DynamoRIO/dynamorio/wiki/Downloads\n\n - Specify the `-DDynamoRIO_DIR` option when building WinAFL\n\n## Supported instrumentation flags\n\nThe following instrumentation options are supported in the DynamoRIO mode:\n\n```\n  -covtype         - the type of coverage being recorded. Supported options are\n                     bb (basic block, default) or edge.\n\n  -coverage_module - module for which to record coverage. Multiple module flags\n                     are supported.\n\n  -target_module   - module which contains the target function to be fuzzed.\n                     Either -target_method or -target_offset need to be\n                     specified together with this option.\n\n  -target_method   - name of the method to fuzz in persistent mode. For this to\n                     work either the method needs to be exported or the symbols\n                     for target_module need to be available. Otherwise use\n                     -target_offset instead.\n\n  -target_offset   - offset of the method to fuzz from the start of the module.\n\n  -fuzz_iterations - Maximum number of iterations for the target function to run\n                     before restarting the target process.\n\n  -nargs           - Number of arguments the fuzzed method takes. This is used\n                     to save/restore the arguments between runs.\n\n  -call_convention - The default calling convention is cdecl on 32-bit x86\n                     platforms and Microsoft x64 for Visual Studio 64-bit\n                     applications. Possible values:\n                         * fastcall: fastcall\n                         * ms64: Microsoft x64 (Visual Studio)\n                         * stdcall: cdecl or stdcall\n                         * thiscall: thiscall\n\n  -debug           - Debug mode. Does not try to connect to the server. Outputs\n                     a log file containing loaded modules, opened files and\n                     coverage information.\n\n  -logdir          - specifies in which directory the log file will be written\n                     (only to be used with -debug).\n\n  -thread_coverage - If set, WinAFL will only collect coverage from a thread\n                     that executed the target function\n```\n\n## Using\n\nNote: If you are using pre-built binaries you'll need to download DynamoRIO\nrelease 7.1.0-1 from https://github.com/DynamoRIO/dynamorio/wiki/Downloads.\nIf you built WinAFL from source, you can use whatever version of DynamoRIO\nyou used to build WinAFL.\n\nIn general, you should perform the following steps when fuzzing a new target:\n\n1. Make sure your target is running correctly without instrumentations.\n\n2. Open the target binary in WinDbg and locate the function you want to fuzz.\nNote the offset of the function from the start of the module. For example, if\nyou want to fuzz the main function and happen to have symbols around, you can\nuse the following windbg command:\n\n```\nx test!main\n```\n\n3. Make sure that the target is running correctly under DynamoRIO. For this\npurpose you can use the standalone debug mode of WinAFL client which does not\nrequire connecting to afl-fuzz. Make sure you use the drrun.exe and winafl.dll\nversion which corresponds to your target (32 vs. 64 bit).\n\nExample command line:\n\n```\npath\\to\\DynamoRIO\\bin64\\drrun.exe -c winafl.dll -debug\n-target_module test_gdiplus.exe -target_offset 0x16e0 -fuzz_iterations 10\n-nargs 2 -- test_gdiplus.exe input.bmp\n```\n\nYou should see the output corresponding to your target function being run 10\ntimes after which the target executable will exit. A .log file should be\ncreated in the current directory. The log file contains useful information\nsuch as the files and modules loaded by the target as well as the dump of AFL\ncoverage map. In the log you should see pre_fuzz_handler and post_fuzz_handler\nbeing run exactly 10 times as well as your input file being open in each\niteration. Note the list of loaded modules for setting the -coverage_module\nflag. Note that you must use the same values for module names as seen in the\nlog file (not case sensitive).\n\n4. Now you should be ready to fuzz the target. First, make sure that both\nafl-fuzz.exe and winafl.dll are in the current directory. As stated earlier,\nthe command line for afl-fuzz on Windows is:\n\n```\nafl-fuzz [afl options] -- [instrumentation options] -- target_cmd_line\n```\n\nPlease refer above for the list of supported AFL and instrumentation options.\n\nIn AFL options, you must specify the DynamoRIO binaries directory via the new\n-D option. You need to match the DynamoRIO and winafl.dll build (32 vs. 64 bit)\nto the target binary. -t (timeout) option is mandatory for WinAFL as execution\ntime can vary significantly under instrumentation so it's not a good idea to\nrely on the auto-determined values.\n\nYou can use the same WinAFL options as in step 2 but remember to exclude the\n-debug flag and you'll probably want to increase the iteration count.\n\nAs in afl-fuzz on Linux you can replace the input file parameter of the target\nbinary with @@.\n\nAn example command line would look like:\n\n```\nafl-fuzz.exe -i in -o out -D C:\\work\\winafl\\DynamoRIO\\bin64 -t 20000 --\n-coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll\n-fuzz_iterations 5000 -target_module test_gdiplus.exe -target_offset 0x16e0\n-nargs 2 -- test_gdiplus.exe @@\n```\n\nAlternately, if symbols for test_gdiplus.exe are available, you can use\n-target_method instead of -target_offset like so:\n\n```\nafl-fuzz.exe -i in -o out -D C:\\work\\winafl\\DynamoRIO\\bin64 -t 20000 --\n-coverage_module gdiplus.dll -coverage_module WindowsCodecs.dll\n-fuzz_iterations 5000 -target_module test_gdiplus.exe -target_method main\n-nargs 2 -- test_gdiplus.exe @@\n```\n\nThat's it. Happy fuzzing!\n\n\n## In App Persistence mode\n\nThis feature is a tweak for the traditional \"target function\" approach and aims\nto loosen the requirements of the target function to do both reading\nan input file and processing the input file.\n\nIn some applications it's quite challenging to find a target function\nthat with a simple execution redirection won't break global states and will do\nboth reading and processing of inputs.\n\nThis mode assumes that the target application will actually loop\nthe target function by itself, and will handle properly its global state.\nFor example a udp server handling packets or a js interpreter running inside\na while loop.\n\nThis mode works as following:\n1. Your target runs until hitting the target function.\n2. The afl server starts instrumenting the target.\n3. Your target runs until hitting the target function again.\n4. The afl server stops instrumenting current cycle and starts a new one.\n\nUsage:\n\nAdd the following option to the winafl arguments:\n`-persistence_mode in_app`\n\n`-nargs` isn't necessary in this mode.\n\nExample usage on the supplied test.exe:\n\n```\nafl-fuzz.exe -i in -o out -D <dynamorio bin path> -t 100+ -- -coverage_module test.exe -fuzz_iterations 5000 -target_module test.exe -target_offset 0x1000 -persistence_mode in_app -- test.exe @@ loop\n```\n\n\n## Expert mode\n\nThe DynamoRIO client implemented in the `winafl.dll` can be packaged up with\nDynamoRIO to create an end-user tool, hence using `drrun` for WinAFL is made\nsimpler by the `-t` option. This is possible by running `afl-fuzz.exe` in\nexpert mode enabled by the `-e` switch.\n\nFirst, create a file in the `tools` subdirectory of the root of DynamoRIO called\n`winafl.drrun32` or `winafl.drrun64`, depending on the target architecture. The\n`CLIENT_REL` or `CLIENT_ABS` options enable `drrun` to locate the WinAFL client\nlibrary. This file can also modify the default DynamoRIO runtime options (see\nDynamoRIO Runtime Options) via `DR_OP=` lines. As an example for a 32-bit build,\nthis file should contain at least the following line:\n\n```\nCLIENT_REL=tools/lib32/release/winafl.dll\n```\n\nThe `-msgbox_mask` option controls whether DynamoRIO uses pop-up message boxes\nwhen presenting information. As an example, append the following lines to this\nfile to disable out of memory notices in case the target process reaches the\nmemory limit specified with the `-m` option:\n\n```\nDR_OP=-msgbox_mask\nDR_OP=0x0\n```\n\nTool options can also be specified via `TOOL_OP=` lines. As an example, append\nthe following lines to this file for a complete configuration to start fuzzing\nusing the supplied `test_gdiplus.exe`:\n\n```\nTOOL_OP=-covtype\nTOOL_OP=edge\nTOOL_OP=-coverage_module\nTOOL_OP=gdiplus.dll\nTOOL_OP=-fuzz_iterations\nTOOL_OP=1000\nTOOL_OP=-target_module\nTOOL_OP=test_gdiplus.exe\nTOOL_OP=-target_method\nTOOL_OP=main\nTOOL_OP=-nargs\nTOOL_OP=2\n```\n\nNow you can omit the client parameters from the command line as all the required\noptions are set in the tool configuration file.\n\nMake sure that the target is running correctly using WinAFL as a DynamoRIO tool:\n\n```\ndrrun.exe -t winafl -debug -- test_gdiplus.exe input.bmp\n```\n\nIf everything appears to be working correctly, launch `afl-fuzz.exe` in expert\nmode using the `-e` switch:\n\n```\nafl-fuzz.exe -e -i in -o out -D <dynamorio bin path> -t 100+ -- -- test_gdiplus.exe @@\n```\n"
        },
        {
          "name": "readme_pt.md",
          "type": "blob",
          "size": 9.6640625,
          "content": "# WinAFL Intel PT mode\n\n## How it works\n\nIntel PT (Processor Tracing) is a feature on modern Intel CPUs that allows tracing code executed by the CPU. If the trace collection is enabled, the CPU generates a highly compressed trace of the instructions executed. This trace can be retrieved and decoded in software later.\n\nWindows from Windows 10 v1809 include an Intel PT driver. Although this is, at this time, undocumented and there is no official API, Alex Ionescu wrote the [WinIPT library](https://github.com/ionescu007/winipt) for interacting with it. This is what WinAFL uses for trace collection.\n\nWhen a target is fuzzed with WinAFL in Intel PT mode, WinAFL opens the target in a debugger. The debugger implenents the WinAFL persistence (looping over target function without the need to restart the process for every iteration), monitors for crashes, loaded modules etc. Before every iteration, the debugger enables Intel PT tracing for the target process and, after the iteration finishes, the trace is retrived and analyzed, updating the AFL coverage map.\n\n## Building and using\n\nTo build WinAFL with Intel PT support `-DINTELPT=1` must be added to the build options.\n\nTo use the Intel PT mode set the -P flag (without any arguments) instead of -D flag (for DynamoRIO) when calling afl-fuzz.exe. Intel PT tracing mode understands the same instrumentation flags as the [DynamoRIO mode](https://github.com/googleprojectzero/winafl/blob/master/readme_dr.md), as well as several others:\n\n - `-trace_size <size>` The size (in bytes) of trace information to collect for every iteration. See remarks below. The size *must* be a factor of two larger than 4096.\n \n - `-decoder <decoder>` The decoder to use to process the trace. Supported options are `tip`, `tip_ref` and `full` (default). For more info, see the separate section on decoders below.\n \n - `-nopersistent_trace` By default, due to large performance hit associated, WinAFL will not restart tracing for each iteration. If this optimization ever causes problems, it can be turned off via this flag. Mostly here for debugging reasons.\n\n - `-trace_cache_size <size>` The size (in bytes) of trace cache. Used only in combination with the `full` decorer.\n\nLike the DynamoRIO mode, Intel PT mode also has the \"debug\" option which can be used to check if the target is running correctly under instrumentation. In general, before starting a new fuzzing session, you should use this to check if your instrumentation flags are correct for a given target. In the case of Intel PT mode, this is done via a separate binary, `winaflpt-debug.exe`. The usage is\n\n```\nwinaflpt-debug.exe -debug [instrumentation options] -- [target command line]\n```\n\nif the `-debug` flag is specified, `winaflpt-debug.exe` will generate a log file (`debug.log`) which contains information about how your target was running under instrumentation (specifically, which modules are loaded, how many iterations were executed etc.)\n\nExample:\n\n```\nwinaflpt-debug.exe -debug -coverage_module test.exe -fuzz_iterations 10 -target_module test.exe -target_method main -nargs 2 -- test.exe @@\n```\n\nWhen you verified that there weren't any problems in this step, you should be ready to fuzz your target. You can use the same instrumentation flags, but remember to remove the `-debug` flag and you'll probably want to increase the `-fuzz_iterations` count.\n\nFuzzing example:\n\n```\nafl-fuzz.exe -i testin -o testout -P -t 20000 -- -coverage_module test.exe -fuzz_iterations 2000 -target_module test.exe -target_method main -nargs 2 -- test.exe @@\n```\n\n## Limitations and other remarks\n\n - A relatively recent Intel CPU with the Processor Tracing feature is needed for this mode and Windows 10 v1809 is needed to be able to interact with it. Running WinAFL inside a VM won't work unless the VM software explicitly supports Intel PT.\n\n - The CPU writes trace information into a ring buffer. If the space in the ring buffer is not sufficient to store the full trace of the iteration execution, the buffer will wrap around and only the last `trace_size` bytes (or a little less, depending on the synchronization packets) will be available for processing. You should set the `trace_size` flags to be able to contain the full trace for a sample that exhibits full target behavior. The default `trace_size` should be sufficient for most targets, however reducing it might increase performance for small targets and you might want to increase it if you get trace buffer overflow warnings.\n \n - Currently, WinAFL will only record the trace from a thread that executes the target function. In most cases this is desirable, but not always. Currently, Intel PT driver does collect information from all threads and the debugger gets information about threads being created and threads exiting. However, when the debugger gets the EXIT_THREAD_DEBUG_EVENT, it is too late and the trace information for this thread is already lost. WinAFL could read out the trace while the thread is still running, however there would be a gap between the last time the trace was read out and the time the thread exited. This would result in a non-deterministic trace with a part of it cut off and, likely, not recording trace for very short threads. Thus, to address this problem deterministically, a better way of tracking thread exits is needed.\n\n## Decoders\n\nThe following trace decoders are available:\n \n - `full_ref` Uses [Intel's reference implementation](https://github.com/01org/processor-trace) to fully decode the trace. Note that full trace decoding introduces a significant overhead. Full trace decoding requires information about the code being executed. WinAFL accomplishes this by saving the memory from all executable modules in the process once they are loaded. However, if the instruction pointer ever ends up outside of an executable module (e.g. due to target using some kind of JIT), the decoding is going to fail and the trace will be decoded only partially. Additinally, if the target modifies executable modules on the fly, the result of the decoding is going to be unpredictable.\n\n - `full` (default) A custom decoder that adds a trace caching layer on top of Intel's reference decoder. Like the `full_ref` decoder it fully decodes all basic blocks in the trace (also provided that code is't generated / modified dynamically), but is significantly faster. For technical details on how this decoder works, see the separate section below.\n   \n - `tip_ref` Uses Intel's reference decoder implementation and decodes only the packets that contain the raw IP address (emitted for e.g. indirect jumps and calls, sometimes returns) but don't decode other packets, e.g. containing info about indirect jumps. This option does not require having any information on the code being executed and is much faster than full decoding. This is similar to how Intel PT is used in [Honggfuzz](https://github.com/google/honggfuzz).\n   \n - `tip` A faster custom implementation of the `tip_ref` decoder. It should behave the same as `tip_ref`\n\n## The fast full decoder\n\nNote: This section contains technical details about the `full` decoder, and is not a required reading if you are only interested in using WinAFL.\n\nThe \"fast\" decoder is in fact a caching layer on top of the Intel's reference decoder. It exploits the fact that, when fuzzing, most of the iterations (especially subsequent iterations) will have mostly identical coverage. At the same time, they wonâ€™t have completely identical coverage (due to e.g. not the same paths taken in allocators) or completely identical trace (due to e.g. asynchronous events occurring at different times). However, large parts of the trace are going to be the same.\n\nThe fast decoder splits the trace into parts (called tracelets) and processes each tracelet separately. When a tracelet is seen for the first time, it is processed using the reference decoder, and, on the high level, the following information is stored and cached:\n - the tracelet itself\n - decoder state before executing the tracelet\n - coverage corresponding to tracelet\n - decoder state after executing the tracelet\n\nNext time the same tracelet is seen *and* the decoder state is the same, coverage and the decoder state are updated from cache.\n\nNote however that traces can't be split into tracelets at random points, partly because of the reference decoder implementation details but also due to out-of-order packet feature of Intel PT: If the CPU has a TNT packet that is not full (and thus not yet sent), to save space CPU is also going to delay other packets (e.g. TIP packets) until the TNT packet gets filled. At the point when TNT packet gets filled, the TNT packet is going to get sent together with all delayed packets. To resolve this issue, tracelets are always cut *before* a TNT packet (which implies that the previous TNT packet was sent togerher with all the delayed packets). This approach seems to also play nicely with the reference decoder implementation.\n\nAnother issue that the decoder must solve is the return address compression: Intel PT expects the decoder to keep track of the call stack and, when the return instruction is encountered, if the actual return address matches the one on the decoder stack, instead of emitting the entire return address, Intel PT is only going to emit a single bit that indicates the return address should be taken from the decoder call stack. To support this feature, the \"fast\" decoder monitors call stack changes when the tracelet is first executed and the relevant changes are saved together with the \"before\" and \"after\" state. Specifically, each tracelet cache entry contains the data consumed from the stack during the traclet execution (these need to match the top of the decoder stack in order for the states to \"match\") and the values added to the stack during the tracelet execution (these are used to update the decoder state).\n"
        },
        {
          "name": "readme_syzygy.md",
          "type": "blob",
          "size": 6.8359375,
          "content": "# Statically instrument a binary via [syzygy](https://github.com/google/syzygy)\n\n## Background\n\n[syzygy](https://github.com/google/syzygy) provides a framework able to _decompose_\nPE32 binaries with full PDB. _Decomposing_ a binary is the term used to mean taking\nin input a PE32 binary and its PDB, analyze and decompose every functions, every blocks\nof code / data in a safe way and present it to transformation \"passes\".\nA transformation pass is a class that transforms the binary in some way; an example is the [syzyasan](https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/asan_transform.h)\ntransformation for example. Once the pass has transformed the binary, it passes it back\nto the framework which is able to _relink_ an output binary (with the transformations applied\nof course).\n\n[AFL instrumentation](https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/afl_transform.cc) has been added to [syzygy](https://github.com/google/syzygy)'s instrumenter allowing users to instrument PE32\nbinaries with private symbols statically.\n\n<p align=\"center\">\n<img alt=\"afl instrumentation under IDA\" src=\"screenshots/afl-instr.png\"/>\n</p>\n\n## How to write a target function\n\nIn order to prepare your target, you need to first include `afl-staticinstr.h` then invoke `__afl_persistent_loop` like in `test_static.cpp`:\n\n```\nint fuzz(int argc, char**argv) {\n  while(__afl_persistent_loop()) {\n    test(argc, argv);\n  }\n  return 1;\n}\n```\n\n`__afl_persistent_loop`'s implementation lives inside `afl-staticinstr.c` and basically reproduces what the DynamoRIO plugin is doing in `pre_fuzz_handler` and `post_fuzz_handler`. Every points mentioned in \"How to select a target function\" applies here too.\n\nYou can invoke AFL tools with the flag `-Y` to enable the static instrumentation mode during fuzzing, corpus minimizing or during test-case minimizing:\n\n```\nafl-fuzz.exe -Y -i minset -o o1 -t 10000 -- -fuzz_iterations 5000 -- test_static.instr.exe @@\nwinafl-cmin.py -Y -t 100000 -i in -o minset -- test_static.instr.exe @@\nafl-tmin.exe -Y -i ..\\testcases\\tests\\big.txt -o big.min.txt -- test_static.instr.exe @@\n```\n\n## Building instrument.exe\n\nFor convenience, a version of instrument.exe confirmed to work with WinAFL is included in the bin32 directory. If you want to build it yourself follow the instructions below.\n\nIn order to clone [syzygy](https://github.com/google/syzygy/)'s repository you can follow the instructions outlined here: [SyzygyDevelopmentGuide](https://github.com/google/syzygy/wiki/SyzygyDevelopmentGuide). Once you have `depot_tools` and the repository cloned, you can compile instrument.exe like this:\n\n```\nC:\\syzygy\\src>ninja -C out\\Release instrument\n```\n\nThe current recommended revision of the instrumenter is the following: [190dbfe](https://github.com/google/syzygy/commit/190dbfe74c6f5b5913820fa66d9176877924d7c5)(v0.8.32.0).\n\n## Registering msdia140\n\nMake sure to register `msdia140.dll` on your system by executing once the below command:\n\n```\nregsvr32 /s msdia140.dll\n```\n\n## Instrumenting a target\n\nYour target binary must have been compiled with the [/PROFILE](https://msdn.microsoft.com/en-us/library/ays5x7b0.aspx) linker flag in order to generate a full PDB.\n\n```\nC:\\>instrument.exe --mode=afl --input-image=test_static.exe --output-image=test_static.instr.exe --force-decompose --multithread --cookie-check-hook\n[0718/224840:INFO:application_impl.h(46)] Syzygy Instrumenter Version 0.8.32.0 (0000000).\n[0718/224840:INFO:application_impl.h(48)] Copyright (c) Google Inc. All rights reserved.\n[0718/224840:INFO:afl_instrumenter.cc(116)] Force decomposition mode enabled.\n[0718/224840:INFO:afl_instrumenter.cc(122)] Thread-safe instrumentation mode enabled.\n[0718/224840:INFO:afl_instrumenter.cc(128)] Cookie check hook mode enabled.\n[...]\n[0718/224840:INFO:security_cookie_check_hook_transform.cc(67)] Found a __report_gsfailure implementation, hooking it now.\n[0718/224840:INFO:add_implicit_tls_transform.cc(77)] The binary doesn't have any implicit TLS slot defined, injecting one.\n[0718/224840:INFO:afl_transform.cc(144)] Placing TLS slot at offset +4.\n[0718/224840:INFO:afl_transform.cc(237)] Code Blocks instrumented: 92 (95%)\n[...]\n[0718/224841:INFO:pe_relinker.cc(240)] PE relinker finished.\n\nC:\\>test_static.instr.exe test\nPersistent loop implementation by <0vercl0k@tuxfamily.org>\nBased on WinAFL by <ifratric@google.com>\n[+] Found a statically instrumented module: test_static.instr.exe (multi thread mode).\n[-] Not running under afl-fuzz.exe.\n[+] Enabling the no fuzzing mode.\nError opening file\n```\n\n### Available options\n\n```\n--config=<path>         Specifies a JSON file describing, either\n                        a whitelist of functions to instrument or\n                        a blacklist of functions to not instrument.\n--cookie-check-hook     Hooks __security_cookie_check.\n--force-decompose       Forces block decomposition.\n--multithread           Uses a thread-safe instrumentation.\n```\n\n* config: The JSON file allows you to scope down the instrumentation to a set of function\nnames. You can either [white list](https://github.com/google/syzygy/blob/master/syzygy/instrument/test_data/afl-good-whitelist.json), or [black list](https://github.com/google/syzygy/blob/master/syzygy/instrument/test_data/afl-good-blacklist.json) functions. It can be very useful to blacklist\nfunctions generating variable behaviors.\n\n* cookie-check-hook: This ensures that the /GS cookie check function generates an exception that\nour [VEH](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681420(v=vs.85).aspx) can catch. Failfast exceptions are not catchable by any EH mechanisms in-proc, so we leverage\n[syzygy](https://github.com/google/syzygy) to rewrite the cookie check function in order to generate\n[an exception we can catch](https://github.com/google/syzygy/blob/master/syzygy/instrument/transforms/security_cookie_check_hook_transform.cc#L81).\n\n* force-decompose: This switch lets you override the decision that [syzygy](https://github.com/google/syzygy/blob/master/syzygy/pe/pe_transform_policy.cc#L175) makes when evaluating\nif a function is safe to decompose. If you turn on this flag, your instrumentation coverage will be\nhigher but you might end-up in an executable that *crashes* in weird ways. Only use if you know what you\nare doing.\n\n* multithread: This switch turns on the thread-safe instrumentation. The major difference with the single\nthread instrumentation is that `__afl_prev_loc` will be stored in a TLS slot.\n\n## Limitations\n\nWith great power comes great responsibility, so here is the list of limitations:\n\n1. Instrumentation is limited to PE 32bits binaries with full PDB symbols (linker flag `/PROFILE`).\n\n2. [syzygy](https://github.com/google/syzygy/) defines [several pre-requirements](https://github.com/google/syzygy/blob/master/syzygy/pe/pe_transform_policy.cc#L175) for being able to decompose safely a block; this might explain why your instrumentation percentage is low.\n\n"
        },
        {
          "name": "readme_tinyinst.md",
          "type": "blob",
          "size": 5.052734375,
          "content": "# TinyInst instrumentation\n\nTinyInst is a lightweight dynamic instrumentation library that can be used to instrument only selected module(s) in the process, while leaving the rest of the process to run natively. WinAFL includes a custom TinyInst client that can collect both basic block and edge coverage into an AFL coverage map.\n\n## Building and using\n\nTo build WinAFL with TinyInst support, `-DTINYINST=1` must be added to the build options. For the full building instructions, see the main readme.\n\nSimilar to other modes, the usage is\n\n```\nafl-fuzz -y [afl options] -- [instrumentation options] -- target_cmd_line\n```\n\nwhere the `-y` flag is used to select TinyInst mode.\n\nThe full list of instrumentation options can be found in the [TinyInst readme](https://github.com/googleprojectzero/TinyInst). Note that, while these options are mostly similar to instrumentation options in DynamoRIO mode:\n  - Some flags have differen names, e.g. `-instrument_module` (TinyInst) vs. `-coverage_module` (DynamoRIO).\n  - Some additional flags are needed to take advantage of persistence mode, specifically `-persist` and `-loop` flags.\n\nInstead of listing all of the options from TinyInst readme, let's examine a basic usage example\n\n```\nafl-fuzz.exe -y -i in -o out -t 20000 -- -instrument_module gdiplus.dll -instrument_module WindowsCodecs.dll -target_module test_gdiplus.exe -target_method main -nargs 2 -iterations 5000 -persist -loop -- C:\\work\\winafl\\build64\\bin\\RelWithDebInfo\\test_gdiplus.exe @@\n```\n\nwhich fuzzes the `test_gdiplus` harness included with WinAFL. As stated previously, `-y` is used to select the TinyInst mode. `-i in -o out -t 20000` are standard afl flags used to set input and output directories as well as the timeout, respectively.\n\n`-instrument_module` specifies which module to instrument. This is similar to `-coverage_module` flag in DynamoRIO mode. There can be multiple `-instrument_module` flags for different modules. In our example, we'll be instrumenting (collecting coverage from) two modules, `gdiplus.dll` and `WindowsCodecs.dll`\n\n`-target_module` and `-target_method` specify which function to run in WinAFL's persistent mode. `-target_module` identifies the module where the function is located (`test_gdiplus.exe` in the example), while `-target_method` specifies the name of the function (main in this case). In case where the symbols (function names) aren't available for the target module, `-target_offset` can be used instead, which specifies the offset in memory from start of the module to the target function (for example `-target_offset 0x16a0`).\n\n`nargs` specifies how many arguments the target function takes in order to be able to restore the arguments for every run.\n\n`-persist` instructs TinyInst to use the persistent mode and keep the target process alive when the target function returns.\n\n`-loop` instructs TinyInst to jump to the start of target function after it returns. `-persist` and `-loop` together enable the \"classic\" WinAFL persistent mode. However there might be cases where one of these flags is desirable without the other, for example in case where the target process calls the target function repeatedly on its own, `-persist` flag can be used without `-loop`\n\n`-iterations` specifies how many times to run the target function in persistent mode without restarting the target process.\n\nTo debug issues, it might be useful to run the target under TinyInst but without the fuzzer. This can be done using `litecov.exe` tool that comes with TinyInst. For example, running `litecov.exe` with the same instrumentation optios as above (except the number of iteration reduced)\n\n```\nlitecov.exe -instrument_module gdiplus.dll -instrument_module WindowsCodecs.dll -target_module test_gdiplus.exe -target_method main -nargs 2 -iterations 10 -persist -loop -- C:\\work\\winafl\\build64\\bin\\RelWithDebInfo\\test_gdiplus.exe in\\in.txt\n```\n\nmight produce the following output\n\n```\nInstrumented module gdiplus.dll, code size: 1409024\nTarget function returned normally\nFound 1094 new offsets in gdiplus.dll\nTarget function returned normally\nFound 1 new offsets in gdiplus.dll\nTarget function returned normally\nTarget function returned normally\nTarget function returned normally\nTarget function returned normally\nTarget function returned normally\nTarget function returned normally\nTarget function returned normally\nTarget function returned normally\n```\n\nThis lets us know that\n - There was code executing in the gdiplus.dll module and TinyInst collected some coverage from it.\n - The target function ran 10 times (as expected) and returned normally every time (i.e. no crashes or hangs)\n\nSo it gives us a good indication that the instrumentation options are set correctly and the target is running correctly under TinyInst.\n\nThere are additional flags that can be useful for debugging such as `-trace_debug_events` which, among other things, lists modules loaded by the target process. Note that `-trace_debug_events` might report exceptions in the target process, but these don't necessarily mean crashes or errors (as long as you don't see a message about the process crashing) as TinyInst uses exceptions under the hood.\n\n"
        },
        {
          "name": "screenshots",
          "type": "tree",
          "content": null
        },
        {
          "name": "test.cpp",
          "type": "blob",
          "size": 2.646484375,
          "content": "/*\n   WinAFL - A simple test binary that crashes on certain inputs:\n     - 'test1' with a normal write access violation at NULL\n     - 'test2' with a /GS stack cookie violation\n   -------------------------------------------------------------\n\n   Written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <windows.h>\n#include <string.h>\n\n\nint __declspec(noinline) test_target(char* input_file_path, char* argv_0)\n{\n\tchar *crash = NULL;\n\tFILE *fp = fopen(input_file_path, \"rb\");\n\tchar c;\n\tif (!fp) {\n\t\tprintf(\"Error opening file\\n\");\n\t\treturn 0;\n\t}\n\tif (fread(&c, 1, 1, fp) != 1) {\n\t\tprintf(\"Error reading file\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (c != 't') {\n\t\tprintf(\"Error 1\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (fread(&c, 1, 1, fp) != 1) {\n\t\tprintf(\"Error reading file\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (c != 'e') {\n\t\tprintf(\"Error 2\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (fread(&c, 1, 1, fp) != 1) {\n\t\tprintf(\"Error reading file\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (c != 's') {\n\t\tprintf(\"Error 3\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (fread(&c, 1, 1, fp) != 1) {\n\t\tprintf(\"Error reading file\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (c != 't') {\n\t\tprintf(\"Error 4\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tprintf(\"!!!!!!!!!!OK!!!!!!!!!!\\n\");\n\n\tif (fread(&c, 1, 1, fp) != 1) {\n\t\tprintf(\"Error reading file\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tif (c == '1') {\n\t\t// cause a crash\n\t\tcrash[0] = 1;\n\t}\n\telse if (c == '2') {\n\t\tchar buffer[5] = { 0 };\n\t\t// stack-based overflow to trigger the GS cookie corruption\n\t\tfor (int i = 0; i < 5; ++i)\n\t\t\tstrcat(buffer, argv_0);\n\t\tprintf(\"buffer: %s\\n\", buffer);\n\t}\n\telse {\n\t\tprintf(\"Error 5\\n\");\n\t}\n\tfclose(fp);\n\treturn 0;\n}\n\nint main(int argc, char** argv)\n{\n    if(argc < 2) {\n        printf(\"Usage: %s <input file>\\n\", argv[0]);\n        return 0;\n    }\n\n\tif (argc == 3 && !strcmp(argv[2], \"loop\"))\n\t{\n\t\t//loop inside application and call target infinitey\n\t\twhile (true)\n\t\t{\n\t\t\ttest_target(argv[1], argv[0]);\n\t\t}\n\t}\n\telse\n\t{\n\t\t//regular single target call\n\t\treturn test_target(argv[1], argv[0]);\n\t}\n}\n"
        },
        {
          "name": "test_netmode.cpp",
          "type": "blob",
          "size": 2.9306640625,
          "content": "/*\n   WinAFL - A simple binary to test winAFL ability perform fuzzing over network:\n   -------------------------------------------------------------\n\n   Written and maintained by Maksim Shudrak <mxmssh@gmail.com>\n\n   Copyright 2018 Salesforce Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n/* cmd line to find the crash:\n * set AFL_CUSTOM_DLL_ARGS=-U -p 7714 -a 127.0.0.1 -w 1000\n * C:\\Users\\max\\Desktop\\winafl\\winafl_fork\\build\\Debug>afl-fuzz.exe -l custom_net_fuzzer.dll \n * -i in -o out -D ..\\..\\dr_release\\bin32 -t 20000 -- -target_module test_netmode.exe -target_method \n * recv_func -coverage_module test_netmode.exe -fuzz_iterations 5000 -nargs 1 -- test_netmode.exe\n */\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <windows.h>\n#include <string.h>\n#include <stdlib.h>\n\n#pragma comment(lib,\"ws2_32.lib\") //Winsock Library\n\n#define DEFAULT_PORT 7714\n#define BUFSIZE 4096\n\n/* TODO: test for TCP */\n\nvoid error(const char *msg) {\n\tprintf(\"[ERROR] %s %d\\n\", msg, WSAGetLastError());\n    exit(-1);\n}\n\nstruct sockaddr_in serveraddr;\t  /* server's addr */\n\nvoid recv_func(int sockfd)\n{\t\n    char *buf;\n\tstruct sockaddr_in clientaddr;\t  /* client addr */\n\tint clientlen = sizeof(clientaddr);\n    int n = 0;\n\n    buf = (char *)malloc(BUFSIZE);\n\n    /* receiving over UDP */\n    n = recvfrom(sockfd, buf, BUFSIZE, 0, (struct sockaddr *)&clientaddr, &clientlen);\n    if (n < 0)\n        error(\"ERROR in recvfrom\");\n\n    if (buf[0] == 'P') {\n\t\tif (buf[1] == 'W') {\n\t\t\tif (buf[2] == 'N') {\n\t\t\t\tif (buf[3] == 'I') {\n\t\t\t\t\tif (buf[4] == 'T') {\n\t\t\t\t\t\tprintf(\"Found it!\\n\");\n\t\t\t\t\t\t((VOID(*)())0x0)();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n    printf(\"Received %d bytes, content = %s\\n\", n, buf);\n    free(buf);\n}\n\nint main(int argc, char** argv)\n{\n\tint sockfd;\n\tint portno = DEFAULT_PORT;\n\tint optval;\n\tstatic WSADATA wsaData;\n\tstatic int iResult;\n\n\t// Initialize Winsock\n\tiResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\n\tsockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\tif (sockfd < 0)\n\t\terror(\"ERROR opening socket\");\n\n\toptval = 1;\n    /* UDP */\n\tsetsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char *)&optval, sizeof(int));\n\n\tmemset((char *)&serveraddr, 0, sizeof(serveraddr));\n\tserveraddr.sin_family = AF_INET;\n\tserveraddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tserveraddr.sin_port = htons((unsigned short)portno);\n\n\tif (bind(sockfd, (struct sockaddr *)&serveraddr, sizeof(serveraddr)) < 0)\n\t\terror(\"ERROR on binding\");\n\twhile (1) {\n\t\trecv_func(sockfd);\n\t}\n    return 0;\n}\n"
        },
        {
          "name": "test_simple_winsock_client.cpp",
          "type": "blob",
          "size": 4.46484375,
          "content": "/*\nA client to test winAFL ability act as a TCP/IP fuzzing server:\n-------------------------------------------------------------\n\nWritten and maintained by Maksim Shudrak <mxmssh@gmail.com>\n\nCopyright 2018 Salesforce Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/* cmd line to launch the fuzzer:\n * set AFL_CUSTOM_DLL_ARGS=1337\n * afl-fuzz.exe -l custom_winafl_server.dll -i in -o out -D ..\\..\\dr_release\\bin32 \n * -t 20000 -- -target_module test_servermode.exe -target_method main -coverage_module\n * test_servermode.exe -fuzz_iterations 5000 -nargs 2 -- test_servermode.exe 127.0.0.1\n */\n\n/* TODO: improve performance of this client under fuzzer */\n\n#pragma once\n\n#define WIN32_LEAN_AND_MEAN\n\n#include <stdio.h>\n#include <tchar.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <stdlib.h>\n\n// Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib\n#pragma comment (lib, \"Ws2_32.lib\")\n#pragma comment (lib, \"Mswsock.lib\")\n#pragma comment (lib, \"AdvApi32.lib\")\n\n#define DEFAULT_BUFLEN 512\n#define DEFAULT_PORT \"1337\"\n\nvoid parse_buffer(char *buf) {\n\tif (buf[0] == 'P') {\n\t\tif (buf[1] == 'W') {\n\t\t\tif (buf[2] == 'N') {\n\t\t\t\tif (buf[3] == 'I') {\n\t\t\t\t\tif (buf[4] == 'T') {\n\t\t\t\t\t\tprintf(\"Found it!\\n\");\n\t\t\t\t\t\t((VOID(*)())0x0)();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid recv_loop(SOCKET ConnectSocket) {\n\tchar recvbuf[DEFAULT_BUFLEN];\n\tint iResult;\n\tint recvbuflen = DEFAULT_BUFLEN;\n\t// Receive until the peer closes the connection\n\tdo {\n\n\t\tiResult = recv(ConnectSocket, recvbuf, recvbuflen, 0);\n\t\tif (iResult > 0)\n\t\t\tprintf(\"Bytes received: %d\\n\", iResult);\n\t\telse if (iResult == 0)\n\t\t\tprintf(\"Connection closed\\n\");\n\t\telse\n\t\t\tprintf(\"recv failed with error: %d\\n\", WSAGetLastError());\n\n\t} while (iResult > 0);\n\tparse_buffer(recvbuf);\n\n}\n\ntypedef struct _test_case_struct {\n\tlong size;\n\tchar *data;\n} test_case_struct;\n\nint __cdecl main(int argc, char **argv)\n{\n\tWSADATA wsaData;\n\tSOCKET ConnectSocket = INVALID_SOCKET;\n\tstruct addrinfo *result = NULL,\n\t\t*ptr = NULL,\n\t\thints;\n\tchar *sendbuf = \"this is a test\";\n\tint iResult;\n\n\t// Validate the parameters\n\tif (argc != 2) {\n\t\tprintf(\"usage: %s server-name\\n\", argv[0]);\n\t\treturn 1;\n\t}\n\n\t// Initialize Winsock\n\tiResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n\tif (iResult != 0) {\n\t\tprintf(\"WSAStartup failed with error: %d\\n\", iResult);\n\t\treturn 1;\n\t}\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\t// Resolve the server address and port\n\tiResult = getaddrinfo(argv[1], DEFAULT_PORT, &hints, &result);\n\tif (iResult != 0) {\n\t\tprintf(\"getaddrinfo failed with error: %d\\n\", iResult);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\t// Attempt to connect to an address until one succeeds\n\tfor (ptr = result; ptr != NULL; ptr = ptr->ai_next) {\n\n\t\t// Create a SOCKET for connecting to server\n\t\tConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,\n\t\t\tptr->ai_protocol);\n\t\tif (ConnectSocket == INVALID_SOCKET) {\n\t\t\tprintf(\"socket failed with error: %ld\\n\", WSAGetLastError());\n\t\t\tWSACleanup();\n\t\t\treturn 1;\n\t\t}\n\n\t\t// Connect to server.\n\t\tiResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);\n\t\tif (iResult == SOCKET_ERROR) {\n\t\t\tclosesocket(ConnectSocket);\n\t\t\tConnectSocket = INVALID_SOCKET;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo(result);\n\n\tif (ConnectSocket == INVALID_SOCKET) {\n\t\tprintf(\"Unable to connect to server!\\n\");\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\t// Send an initial buffer\n\tiResult = send(ConnectSocket, sendbuf, (int)strlen(sendbuf), 0);\n\tif (iResult == SOCKET_ERROR) {\n\t\tprintf(\"send failed with error: %d\\n\", WSAGetLastError());\n\t\tclosesocket(ConnectSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\tprintf(\"Bytes Sent: %ld\\n\", iResult);\n\n\t// shutdown the connection since no more data will be sent\n\tiResult = shutdown(ConnectSocket, SD_SEND);\n\tif (iResult == SOCKET_ERROR) {\n\t\tprintf(\"shutdown failed with error: %d\\n\", WSAGetLastError());\n\t\tclosesocket(ConnectSocket);\n\t\tWSACleanup();\n\t\treturn 1;\n\t}\n\n\trecv_loop(ConnectSocket);\n\n\t// cleanup\n\tclosesocket(ConnectSocket);\n\tWSACleanup();\n\n\treturn 0;\n}\n\n"
        },
        {
          "name": "test_static.cpp",
          "type": "blob",
          "size": 3.4931640625,
          "content": "/*\r\n   WinAFL - A simple test binary that exercises various behaviors\r\n   depending on inputs:\r\n     - 'test1' crashes with a normal write access violation at NULL\r\n     - 'test2' crashes with a /GS stack cookie violation\r\n     - 'test3' triggers a hang\r\n     - 'test4' triggers an exception that is caught and handled\r\n     - 'test5' triggers an OutputDebugString\r\n     - 'test6' triggers an allocation of 120MB (and a crash if the\r\n               allocation fails)\r\n   -------------------------------------------------------------\r\n\r\n   Written by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\r\n\r\n   Copyright 2017 Google Inc. All Rights Reserved.\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n*/\r\n\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#include <windows.h>\r\n#include <string.h>\r\n#include \"afl-staticinstr.h\"\r\n\r\nint test(int argc, char **argv) {\r\n    char *crash = NULL;\r\n    FILE *fp = fopen(argv[1], \"rb\");\r\n    char c;\r\n    if (!fp) {\r\n        printf(\"Error opening file\\n\");\r\n        goto end;\r\n    }\r\n    if (fread(&c, 1, 1, fp) != 1) {\r\n        printf(\"Error reading file\\n\");\r\n        goto clean;\r\n    }\r\n    if (c != 't') {\r\n        printf(\"Error 1\\n\");\r\n        goto clean;\r\n    }\r\n    if (fread(&c, 1, 1, fp) != 1) {\r\n        printf(\"Error reading file\\n\");\r\n        goto clean;\r\n    }\r\n    if (c != 'e') {\r\n        printf(\"Error 2\\n\");\r\n        goto clean;\r\n    }\r\n    if (fread(&c, 1, 1, fp) != 1) {\r\n        printf(\"Error reading file\\n\");\r\n        goto clean;\r\n    }\r\n    if (c != 's') {\r\n        printf(\"Error 3\\n\");\r\n        goto clean;\r\n    }\r\n    if (fread(&c, 1, 1, fp) != 1) {\r\n        printf(\"Error reading file\\n\");\r\n        goto clean;\r\n    }\r\n    if (c != 't') {\r\n        printf(\"Error 4\\n\");\r\n        goto clean;\r\n    }\r\n    printf(\"!!!!!!!!!!OK!!!!!!!!!!\\n\");\r\n\r\n    if (fread(&c, 1, 1, fp) != 1) {\r\n        printf(\"Error reading file\\n\");\r\n        goto clean;\r\n    }\r\n    if (c == '1') {\r\n        crash[0] = 1;\r\n    }\r\n    else if (c == '2') {\r\n        char buffer[5] = { 0 };\r\n        strcat(buffer, argv[0]);\r\n    }\r\n    else if (c == '3') {\r\n        printf(\"triggering a hang\\n\");\r\n        Sleep(50 * 1000);\r\n    }\r\n    else if (c == '4') {\r\n        try {\r\n            throw int(1337);\r\n        }\r\n        catch (...) {\r\n            printf(\"Caught its ok!\\n\");\r\n        }\r\n    }\r\n    else if (c == '5') {\r\n        OutputDebugString(TEXT(\"hello!\"));\r\n    }\r\n    else if (c == '6') {\r\n        printf(\"allocating 120MB\\n\");\r\n        char *buffer = (char*)malloc((1024 * 1024) * 120);\r\n        *buffer = 0;\r\n        free(buffer);\r\n    }\r\n    else {\r\n        printf(\"Error 5\\n\");\r\n    }\r\n\r\n    clean:\r\n    fclose(fp);\r\n\r\n    end:\r\n    return EXIT_SUCCESS;\r\n}\r\n\r\n#pragma optimize(\"\", off)\r\nint fuzz(int argc, char**argv) {\r\n    while(__afl_persistent_loop()) {\r\n        test(argc, argv);\r\n    }\r\n    return 1;\r\n}\r\n#pragma optimize(\"\", on)\r\n\r\nint main(int argc, char** argv)\r\n{\r\n    if(argc < 2) {\r\n        printf(\"Usage: %s <input file>\\n\", argv[0]);\r\n        return 0;\r\n    }\r\n\r\n    return fuzz(argc, argv);\r\n}\r\n"
        },
        {
          "name": "testcases",
          "type": "tree",
          "content": null
        },
        {
          "name": "third_party",
          "type": "tree",
          "content": null
        },
        {
          "name": "tinyinst_afl.cpp",
          "type": "blob",
          "size": 4.1552734375,
          "content": "/*\nCopyright 2023 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttps ://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n#include \"tinyinst_covmap.h\"\n#include \"tinyinst_afl.h\"\n#include \"common.h\"\n\nstatic TinyInstCovMap* instrumentation;\nstatic bool persist;\nstatic int num_iterations;\nstatic int cur_iteration;\n\nenum {\n  /* 00 */ FAULT_NONE,\n  /* 01 */ FAULT_TMOUT,\n  /* 02 */ FAULT_CRASH,\n  /* 03 */ FAULT_ERROR,\n  /* 04 */ FAULT_NOINST,\n  /* 05 */ FAULT_NOBITS\n};\n\nextern \"C\" int tinyinst_init(int argc, char** argv) {\n  int lastoption = -1;\n  for (int i = 1; i < argc; i++) {\n    if (strcmp(argv[i], \"--\") == 0) {\n      lastoption = i;\n      break;\n    }\n  }\n\n  if (lastoption <= 0) return 0;\n\n  instrumentation = new TinyInstCovMap();\n  instrumentation->Init(lastoption - 1, argv + 1);\n\n  persist = GetBinaryOption(\"-persist\", lastoption - 1, argv + 1, false);\n  num_iterations = GetIntOption(\"-iterations\", lastoption - 1, argv + 1, 1);\n  cur_iteration = 0;\n\n  return lastoption;\n}\n\nextern \"C\" void tinyinst_set_fuzzer_id(char *fuzzer_id) {\n  std::string shm_name = \"afl_shm_default\";\n  if (fuzzer_id) {\n    shm_name = std::string(\"afl_shm_\") + std::string(fuzzer_id);\n  }\n  instrumentation->SetSHMName(shm_name);\n}\n\nint get_argc(char** argv) {\n  int argc = 0;\n  while (1) {\n    if (!(*argv)) break;\n    argv++;\n    argc++;\n  }\n  return argc;\n}\n\nextern \"C\" int tinyinst_run(char** argv, uint32_t timeout) {\n  uint32_t init_timeout = timeout;\n  DebuggerStatus status;\n  int ret = FAULT_ERROR;\n\n  if (instrumentation->IsTargetFunctionDefined()) {\n    if (cur_iteration == num_iterations) {\n      instrumentation->Kill();\n      cur_iteration = 0;\n    }\n  }\n\n  uint32_t timeout1 = timeout;\n  if (instrumentation->IsTargetFunctionDefined()) {\n    timeout1 = init_timeout;\n  }\n\n  if (instrumentation->IsTargetAlive() && persist) {\n    status = instrumentation->Continue(timeout1);\n  } else {\n    instrumentation->Kill();\n    cur_iteration = 0;\n    status = instrumentation->Run(get_argc(argv), argv, timeout1);\n  }\n\n  // if target function is defined,\n  // we should wait until it is hit\n  if (instrumentation->IsTargetFunctionDefined()) {\n    if (status != DEBUGGER_TARGET_START) {\n      // try again with a clean process\n      WARN(\"Target function not reached, retrying with a clean process\\n\");\n      instrumentation->Kill();\n      cur_iteration = 0;\n      status = instrumentation->Run(get_argc(argv), argv, init_timeout);\n    }\n\n    if (status != DEBUGGER_TARGET_START) {\n      switch (status) {\n      case DEBUGGER_CRASHED:\n        FATAL(\"Process crashed before reaching the target method\\n\");\n        break;\n      case DEBUGGER_HANGED:\n        FATAL(\"Process hanged before reaching the target method\\n\");\n        break;\n      case DEBUGGER_PROCESS_EXIT:\n        FATAL(\"Process exited before reaching the target method\\n\");\n        break;\n      default:\n        FATAL(\"An unknown problem occured before reaching the target method\\n\");\n        break;\n      }\n    }\n\n    status = instrumentation->Continue(timeout);\n  }\n\n  switch (status) {\n  case DEBUGGER_CRASHED:\n    ret = FAULT_CRASH;\n    instrumentation->Kill();\n    break;\n  case DEBUGGER_HANGED:\n    ret = FAULT_TMOUT;\n    instrumentation->Kill();\n    break;\n  case DEBUGGER_PROCESS_EXIT:\n    ret = FAULT_NONE;\n    if (instrumentation->IsTargetFunctionDefined()) {\n      WARN(\"Process exit during target function\\n\");\n      ret = FAULT_TMOUT;\n    }\n    break;\n  case DEBUGGER_TARGET_END:\n    if (instrumentation->IsTargetFunctionDefined()) {\n      ret = FAULT_NONE;\n      cur_iteration++;\n    }\n    else {\n      FATAL(\"Unexpected status received from the debugger\\n\");\n    }\n    break;\n  default:\n    FATAL(\"Unexpected status received from the debugger\\n\");\n    break;\n  }\n\n  return ret;\n}\n\nextern \"C\" void tinyinst_killtarget() {\n  instrumentation->Kill();\n}"
        },
        {
          "name": "tinyinst_afl.h",
          "type": "blob",
          "size": 0.818359375,
          "content": "/*\nCopyright 2023 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttps ://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n#ifndef TINYINST_AFL_H\n#define TINYINST_AFL_H\n\nextern \"C\" int tinyinst_init(int argc, char** argv);\nextern \"C\" void tinyinst_set_fuzzer_id(char* fuzzer_id);\nextern \"C\" int tinyinst_run(char** argv, uint32_t timeout);\nextern \"C\" void tinyinst_killtarget();\n\n#endif // TINYINST_AFL_H\n"
        },
        {
          "name": "tinyinst_covmap.cpp",
          "type": "blob",
          "size": 5.0439453125,
          "content": "/*\nCopyright 2023 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttps ://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n#include \"windows.h\"\n#include \"tinyinst_covmap.h\"\n#include \"common.h\"\n\nvoid TinyInstCovMap::Init(int argc, char **argv) {\n  TinyInst::Init(argc, argv);\n\n  coverage_type = COVTYPE_BB;\n  char *option = GetOption(\"-covtype\", argc, argv);\n  if (option) {\n    if (strcmp(option, \"bb\") == 0)\n      coverage_type = COVTYPE_BB;\n    else if (strcmp(option, \"edge\") == 0)\n      coverage_type = COVTYPE_EDGE;\n    else\n      FATAL(\"Unknown coverage type\");\n  }\n\n  map_address = NULL;\n}\n\nvoid TinyInstCovMap::SetSHMName(std::string &shm_name) {\n  this->shm_name = shm_name;\n}\n\nvoid TinyInstCovMap::OnModuleInstrumented(ModuleInfo* module) {\n  EnsureSharedMemory();\n}\n\nvoid TinyInstCovMap::EnsureSharedMemory() {\n  if (map_address) return;\n\n  if (shm_name.empty()) FATAL(\"Shared memory name is not set\");\n\n  HANDLE map_file;\n\n  map_file = OpenFileMapping(\n    FILE_MAP_ALL_ACCESS,\n    FALSE,\n    shm_name.c_str());\n\n  if (map_file == NULL) FATAL(\"Error mapping shared memory\");\n\n  map_address = MapViewOfFile2(map_file,\n    GetChildProcessHandle(),\n    0,\n    0,\n    MAP_SIZE,\n    0,\n    PAGE_READWRITE);\n\n  if (!map_address) FATAL(\"Error mapping shared memory\");\n\n  CloseHandle(map_file);\n}\n\nvoid TinyInstCovMap::EmitCoverageInstrumentation(ModuleInfo *module,\n                                          uint32_t map_offset) {\n\n  // common x86 assembly codes\n  unsigned char PUSH_F[] = { 0x9c };\n  unsigned char POP_F[] = { 0x9d };\n  unsigned char PUSH_RAX[] = { 0x50 };\n  unsigned char POP_RAX[] = { 0x58 };\n  unsigned char INC_ADDR[] = { 0xFE, 0x05, 0xAA, 0xAA, 0xAA, 0xAA };\n  unsigned char MOV_RAX_IMM64[] = { 0x48, 0xB8, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };\n  unsigned char INC_MEM_RAX[] = { 0xFE, 0x00 };\n\n  size_t address = (size_t)map_address + map_offset;\n\n  if (sp_offset) {\n    assembler_->OffsetStack(module, -sp_offset);\n  }\n\n  // pushf\n  WriteCode(module, PUSH_F, sizeof(PUSH_F));\n\n  if (child_ptr_size == 4) {\n\n    // inc byte ptr[addr]\n    WriteCode(module, INC_ADDR, sizeof(INC_ADDR));\n    *(uint32_t*)(module->instrumented_code_local +\n      module->instrumented_code_allocated - 4) =\n      (uint32_t)address;\n\n  } else {\n\n    // push rax\n    WriteCode(module, PUSH_RAX, sizeof(PUSH_RAX));\n\n    // mov rax, addr\n    WriteCode(module, MOV_RAX_IMM64, sizeof(MOV_RAX_IMM64));\n    *(uint64_t*)(module->instrumented_code_local +\n      module->instrumented_code_allocated - 8) =\n      (uint64_t)address;\n\n    // inc byte ptr[rax]\n    WriteCode(module, INC_MEM_RAX, sizeof(INC_MEM_RAX));\n\n    // pop rax\n    WriteCode(module, POP_RAX, sizeof(POP_RAX));\n\n  }\n\n  // popf\n  WriteCode(module, POP_F, sizeof(POP_F));\n\n  if (sp_offset) {\n    assembler_->OffsetStack(module, sp_offset);\n  }\n}\n\nvoid TinyInstCovMap::InstrumentBasicBlock(ModuleInfo *module, size_t bb_address) {\n  if (coverage_type != COVTYPE_BB) return;\n\n  uint32_t offset = GetBBOffset(module, bb_address);\n\n  EmitCoverageInstrumentation(module, offset);\n}\n\nvoid TinyInstCovMap::InstrumentEdge(ModuleInfo *previous_module,\n                             ModuleInfo *next_module, size_t previous_address,\n                             size_t next_address) {\n  if (coverage_type != COVTYPE_EDGE) return;\n\n  uint32_t coverage_code =\n      GetEdgeOffset(previous_module, next_module, previous_address, next_address);\n\n  EmitCoverageInstrumentation(previous_module, coverage_code);\n}\n\nuint32_t TinyInstCovMap::GetBBOffset(ModuleInfo *module, size_t bb_address) {\n  uint32_t offset = (uint32_t)((size_t)bb_address - (size_t)module->min_address);\n  return offset % MAP_SIZE;\n}\n\nuint32_t TinyInstCovMap::GetEdgeOffset(ModuleInfo *module1,\n                                     ModuleInfo *module2,\n                                     size_t edge_address1,\n                                     size_t edge_address2)\n{\n  uint32_t offset1 = 0;\n  if (module1 && edge_address1)\n    offset1 = (uint32_t)((size_t)edge_address1 - (size_t)module1->min_address);\n  uint32_t offset2 = 0;\n  if (module2 && edge_address2)\n    offset2 = (uint32_t)((size_t)edge_address2 - (size_t)module2->min_address);\n\n  return ((offset1 >> 1) ^ offset2) % MAP_SIZE;\n}\n\nvoid TinyInstCovMap::OnModuleEntered(ModuleInfo *module, size_t entry_address) {\n  if (coverage_type == COVTYPE_BB) return;\n\n  if (!map_address) return;\n\n  uint8_t map_byte = 0;\n  uint32_t map_offset = GetEdgeOffset(0, module, 0, entry_address);\n\n  RemoteRead((char*)map_address + map_offset, &map_byte, sizeof(map_byte));\n  map_byte++;\n  RemoteWrite((char*)map_address + map_offset, &map_byte, sizeof(map_byte));\n}\n\nvoid TinyInstCovMap::OnProcessExit() {\n  map_address = NULL;\n  TinyInst::OnProcessExit();\n}\n"
        },
        {
          "name": "tinyinst_covmap.h",
          "type": "blob",
          "size": 1.8125,
          "content": "/*\nCopyright 2023 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttps ://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n#ifndef TINYINST_COVMAP_H\n#define TINYINST_COVMAP_H\n\n#include <string>\n#include \"tinyinst.h\"\n\n#define MAP_SIZE 65536\n\nenum CovType {\n  COVTYPE_BB,\n  COVTYPE_EDGE\n};\n\nclass TinyInstCovMap : public TinyInst {\npublic:\n  virtual void Init(int argc, char **argv) override;\n  void SetSHMName(std::string& shm_name);\n\nprotected:\n  virtual void OnProcessExit() override;\n\n  virtual void OnModuleInstrumented(ModuleInfo* module) override;\n  virtual void OnModuleEntered(ModuleInfo *module, size_t entry_address) override;\n\n  virtual void InstrumentBasicBlock(ModuleInfo *module, size_t bb_address) override;\n  virtual void InstrumentEdge(ModuleInfo *previous_module,\n                              ModuleInfo *next_module,\n                              size_t previous_address,\n                              size_t next_address) override;\n\n  void EmitCoverageInstrumentation(ModuleInfo *module, uint32_t map_offset);\n\n  uint32_t GetBBOffset(ModuleInfo* module, size_t bb_address);\n  uint32_t GetEdgeOffset(ModuleInfo* module1,\n                         ModuleInfo* module2,\n                         size_t edge_address1,\n                         size_t edge_address2);\n\nprivate:\n  void EnsureSharedMemory();\n\n  CovType coverage_type;\n  void* map_address;\n  std::string shm_name;\n};\n\n#endif // TINYINST_COVMAP_H\n"
        },
        {
          "name": "types.h",
          "type": "blob",
          "size": 2.3076171875,
          "content": "/*\n   american fuzzy lop - type definitions and minor macros\n   ------------------------------------------------------\n\n   Original AFL code written by Michal Zalewski <lcamtuf@google.com>\n\n   Windows fork written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\n#ifndef _HAVE_TYPES_H\n#define _HAVE_TYPES_H\n\n#include <stdint.h>\n#include <stdlib.h>\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\n\n/*\n\n   Ugh. There is an unintended compiler / glibc #include glitch caused by\n   combining the u64 type an %llu in format strings, necessitating a workaround.\n\n   In essence, the compiler is always looking for 'unsigned long long' for %llu.\n   On 32-bit systems, the u64 type (aliased to uint64_t) is expanded to\n   'unsigned long long' in <bits/types.h>, so everything checks out.\n\n   But on 64-bit systems, it is #ifdef'ed in the same file as 'unsigned long'.\n   Now, it only happens in circumstances where the type happens to have the\n   expected bit width, *but* the compiler does not know that... and complains\n   about 'unsigned long' being unsafe to pass to %llu.\n\n */\n\n#ifdef _WIN64\ntypedef unsigned long long u64;\n#else\ntypedef uint64_t u64;\n#endif /* ^sizeof(...) */\n\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\ntypedef int64_t  s64;\n\n#ifndef MIN\n#  define MIN(_a,_b) ((_a) > (_b) ? (_b) : (_a))\n#  define MAX(_a,_b) ((_a) > (_b) ? (_a) : (_b))\n#endif /* !MIN */\n\n#define SWAP16(x) (((x) >> 8) | ((x) << 8))\n#define SWAP32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | ((x) << 24))\n\n#define R(x) (rand() % (x))\n\n#define STRINGIFY_INTERNAL(x) #x\n#define STRINGIFY(x) STRINGIFY_INTERNAL(x)\n\n#define MEM_BARRIER() \\\n  asm volatile(\"\" ::: \"memory\")\n\n#endif /* ! _HAVE_TYPES_H */\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 2.9375,
          "content": "/* ***************************************************************************\n * Copyright (c) 2012-2013 Google, Inc.  All rights reserved.\n * ***************************************************************************/\n\n/*\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice,\n *   this list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of Google, Inc. nor the names of its contributors may be\n *   used to endorse or promote products derived from this software without\n *   specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE, INC. OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n * DAMAGE.\n */\n\n/*\nDynamoRIO utility macros. Copied from the DyanmoRIO project,\nhttp://dynamorio.org/\n*/\n\n\n#ifndef CLIENTS_COMMON_UTILS_H_\n#define CLIENTS_COMMON_UTILS_H_\n\n#include \"dr_api.h\"\n\n#ifdef DEBUG\n# define ASSERT(x, msg) DR_ASSERT_MSG(x, msg)\n# define IF_DEBUG(x) x\n#else\n# define ASSERT(x, msg) /* nothing */\n# define IF_DEBUG(x) /* nothing */\n#endif\n\n/* XXX: should be moved to DR API headers? */\n#define BUFFER_SIZE_BYTES(buf)      sizeof(buf)\n#define BUFFER_SIZE_ELEMENTS(buf)   (BUFFER_SIZE_BYTES(buf) / sizeof((buf)[0]))\n#define BUFFER_LAST_ELEMENT(buf)    (buf)[BUFFER_SIZE_ELEMENTS(buf) - 1]\n#define NULL_TERMINATE_BUFFER(buf)  BUFFER_LAST_ELEMENT(buf) = 0\n#define ALIGNED(x, alignment) ((((ptr_uint_t)x) & ((alignment)-1)) == 0)\n#define TESTANY(mask, var) (((mask) & (var)) != 0)\n#define TEST  TESTANY\n\n#ifdef WINDOWS\n# define IF_WINDOWS(x) x\n# define IF_UNIX_ELSE(x,y) y\n#else\n# define IF_WINDOWS(x)\n# define IF_UNIX_ELSE(x,y) x\n#endif\n\n/* Checks for both debug and release builds: */\n#define USAGE_CHECK(x, msg) DR_ASSERT_MSG(x, msg)\n\nstatic inline generic_func_t\ncast_to_func(void *p)\n{\n#ifdef WINDOWS\n#  pragma warning(push)\n#  pragma warning(disable : 4055)\n#endif\n    return (generic_func_t) p;\n#ifdef WINDOWS\n#  pragma warning(pop)\n#endif\n}\n\n#endif /* CLIENTS_COMMON_UTILS_H_ */\n"
        },
        {
          "name": "winafl-cmin.py",
          "type": "blob",
          "size": 28.4287109375,
          "content": "#\n#    american fuzzy lop - corpus minimization tool\n#    ----------------------------------------\n#\n#    Original code written by Michal Zalewski <lcamtuf@google.com>\n#\n#    Windows fork written by Axel \"0vercl0k\" Souchet <0vercl0k@tuxfamily.org>\n#\n#    Copyright 2017 Google Inc. All rights reserved.\n#\n#    Licensed under the Apache License, Version 2.0 (the \"License\");\n#    you may not use this file except in compliance with the License.\n#    You may obtain a copy of the License at:\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n#\nfrom __future__ import print_function\n\nimport argparse\nimport collections\nimport logging\nimport multiprocessing\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport time\nimport re\nfrom textwrap import dedent, wrap\n\nnul = open(os.devnull, 'wb')\n\nAFLShowMapResult = collections.namedtuple(\n    'AFLShowMapResult', [\n        'returncode', 'path', 'filesize', 'tuples'\n    ]\n)\n\n\nclass AFLShowMapWorker(object):\n    '''This class abstracts away the interaction with afl-showmap.exe\n    and plays nice with the multiprocessing module'''\n    def __init__(self, args):\n        self.args = args\n\n    @staticmethod\n    def _to_showmap_options(args, trace_name = '-'):\n        '''Takes the argparse namespace, and convert it to the list of options used\n        to invoke afl-showmap.exe'''\n        r = [\n            'afl-showmap.exe', '-o', trace_name, '-m', args.memory_limit\n        ]\n\n        if os.getenv('AFL_NO_SINKHOLE') is None:\n            r.append('-q')\n\n        if args.edges_only:\n            r.append('-e')\n\n        if args.time_limit > 0:\n            r.extend(['-t', '%d' % args.time_limit])\n        else:\n            r.extend(['-t', 'none'])\n\n        if args.static_instr:\n            r.append('-Y')\n        else:\n            r.extend(['-D', args.dynamorio_dir])\n            r.append('--')\n            r.extend(['-target_module', args.target_module])\n\n            if args.target_method is None:\n                r.extend(['-target_offset', '0x%x' % args.target_offset])\n            else:\n                r.extend(['-target_method', args.target_method])\n\n            r.extend(['-nargs', '%d' % args.nargs])\n            r.extend(['-covtype', args.covtype])\n            if args.call_convention is not None:\n                r.extend(['-call_convention', args.call_convention])\n\n            for mod in args.coverage_modules:\n                r.extend(['-coverage_module', mod])\n\n        r.append('--')\n        r.extend(args.target_cmdline)\n        return r\n\n    def __call__(self, input_file):\n        '''Runs afl-showmap.exe on a specific target and extracts\n        the tuples from the generated trace'''\n        current_process = multiprocessing.current_process()\n        fileread = None\n        if self.args.file_read is not None:\n            # It means that the target expects to have '@@' replaced with a\n            # constant path file. First step, is to copy the input to\n            # this location\n            fileread = self.args.file_read.replace(\n                '@@', current_process.name\n            )\n            if os.path.isfile(fileread):\n                os.remove(fileread)\n            shutil.copyfile(input_file, fileread)\n\n        trace_name = 'worker.%d.trace.bin' % current_process.pid\n        opts = AFLShowMapWorker._to_showmap_options(self.args, trace_name)\n        # If we have a '@@' marker in the command line, it has to be replaced\n        # by an actual file. It is either directly the input testcase, or the\n        # file specified by the -f option.\n        if opts.count('@@') > 0:\n            # TODO(0vercl0k): handle inputs via stdin as opposed to '@@' & -f\n            idx = opts.index('@@')\n            opts[idx] = input_file if fileread is None else fileread\n\n        # Make sure there isn't a trace that hasn't been properly cleaned\n        if os.path.isfile(trace_name):\n            os.remove(trace_name)\n\n        p = subprocess.Popen(opts, close_fds = True)\n        p.wait()\n\n        if fileread is not None:\n            # Clean it up\n            os.remove(fileread)\n\n        # Read the trace file and populate the tuple store\n        tuples = {}\n        if os.path.isfile(trace_name):\n            with open(trace_name, 'r') as f:\n                for line in f.readlines():\n                    tuple_id, hitcount = map(int, line.split(':', 1))\n                    tuples[tuple_id] = hitcount\n\n            # Clean it up\n            os.remove(trace_name)\n        return AFLShowMapResult(\n            p.returncode, input_file,\n            os.path.getsize(input_file), tuples\n        )\n\n\ndef target_offset(opt):\n    '''Validates that the target_offset is actually an integer, else\n    raises an ArgumentTypeError exception back to the argparse parser.'''\n    try:\n        return int(opt, 0)\n    except ValueError:\n        raise argparse.ArgumentTypeError('must be an integer')\n\n\ndef memory_limit(opt):\n    '''Validates that the -m parameter is properly formatted, else\n    raises an ArgumentTypeError exception back to the argparse parser.'''\n    if re.match(r'^\\d+[TGkM]?$', opt) or opt == 'none':\n        return opt\n    raise argparse.ArgumentTypeError('must be an integer followed by either: '\n                                     'T, G, M, k or nothing; or none')\n\n\ndef setup_argparse():\n    '''Sets up the argparse configuration.'''\n    parser = argparse.ArgumentParser(\n        formatter_class = argparse.RawDescriptionHelpFormatter,\n        epilog = '\\n'.join(wrap(dedent(\n            '''\n            Examples of use:\n             * Typical use\n              winafl-cmin.py -D D:\\\\DRIO\\\\bin32 -t 100000 -i in -o minset -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n             * Dry-run, keep crashes only with 4 workers with a working directory:\n              winafl-cmin.py -C --dry-run -w 4 --working-dir D:\\\\dir -D D:\\\\DRIO\\\\bin32 -t 10000 -i in -i C:\\\\fuzz\\\\in -o out_mini -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n             * Read from specific file\n              winafl-cmin.py -D D:\\\\DRIO\\\\bin32 -t 100000 -i in -o minset -f foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n             * Read from specific file with pattern\n              winafl-cmin.py -D D:\\\\DRIO\\\\bin32 -t 100000 -i in -o minset -f prefix-@@-foo.ext -covtype edge -coverage_module m.dll -target_module test.exe -target_method fuzz -nargs 2 -- test.exe @@\n\n             * Typical use with static instrumentation\n              winafl-cmin.py -Y -t 100000 -i in -o minset -- test.instr.exe @@\n            '''\n        ), 100, replace_whitespace = False))\n    )\n\n    group = parser.add_argument_group('basic parameters')\n    group.add_argument(\n        '-i', '--input', action = 'append', required = True,\n        metavar = 'dir', help = 'input directory with the starting corpus.'\n        ' Multiple input directories are supported'\n    )\n    group.add_argument(\n        '-o', '--output', required = True,\n        metavar = 'dir', help = 'output directory for minimized files'\n    )\n    group.add_argument(\n        '--crash-dir', required=False,\n        metavar='dir', help='output directory for crashing files'\n    )\n    group.add_argument(\n        '--hang-dir', required=False,\n        metavar='dir', help='output directory for hanging files'\n    )\n    group.add_argument(\n        '-n', '--dry-run', action = 'store_true', default = False,\n        help = 'do not really populate the output directory'\n    )\n    group.add_argument(\n        '--working-dir', default = os.getcwd(),\n        metavar = 'dir', help = 'directory containing afl-showmap.exe,'\n        'winafl.dll, the target binary, etc.'\n    )\n    group.add_argument(\n        '-v', '--verbose', action = 'store_const',\n        default = logging.INFO, const = logging.DEBUG\n    )\n\n    group = parser.add_argument_group('instrumentation settings')\n    instr_type = group.add_mutually_exclusive_group(required = True)\n    instr_type.add_argument(\n        '-Y', '--static-instr', action = 'store_true',\n        help = 'use the static instrumentation mode'\n    )\n\n    instr_type.add_argument(\n        '-D', '--dynamorio_dir',\n        metavar = 'dir', help = 'directory containing DynamoRIO binaries (drrun, drconfig)'\n    )\n\n    group.add_argument(\n        '-covtype', choices = ('edge', 'bb'), default = 'bb',\n        help = 'the type of coverage being recorded (defaults to bb)'\n    )\n    group.add_argument(\n        '-call_convention', choices = ('stdcall', 'fastcall', 'thiscall', 'ms64'),\n        default = 'stdcall', help = 'the calling convention of the target_method'\n    )\n    group.add_argument(\n        '-coverage_module', dest = 'coverage_modules', default = None,\n        action = 'append', metavar = 'module', help = 'module for which to record coverage.'\n        ' Multiple module flags are supported'\n    )\n    group.add_argument(\n        '-target_module', default = None, metavar = 'module',\n        help = 'module which contains the target function to be fuzzed'\n    )\n    group.add_argument(\n        '-nargs', type = int, default = None, metavar = 'nargs',\n        help = 'number of arguments the fuzzed method takes. This is used to save/restore'\n        ' the arguments between runs'\n    )\n\n    group = group.add_mutually_exclusive_group()\n    group.add_argument(\n        '-target_method', default = None, metavar = 'method',\n        help = 'name of the method to fuzz in persistent mode.'\n        ' A symbol for the method needs to be exported for this to work'\n    )\n    group.add_argument(\n        '-target_offset', default = None, type = target_offset, metavar = 'rva offset',\n        help = 'offset of the method to fuzz from the start of the module'\n    )\n\n    group = parser.add_argument_group('execution control settings')\n    group.add_argument(\n        '-t', '--time-limit', type = int, default = 0,\n        metavar = 'msec', help = 'timeout for each run (none)'\n    )\n    group.add_argument(\n        '-m', '--memory-limit', default = 'none', type = memory_limit,\n        metavar = 'megs', help = 'memory limit for child process'\n    )\n    # Note(0vercl0k): If you use -f, which means you want the input file at\n    # a specific location (and a specific name), we have to force the pool\n    # process to contain only a single worker as there is a unique location\n    # specified by -f.. unless you provide a pattern with @@ like\n    # c:\\dir\\prefix@@suffix where @@ will be replaced with a unique identifier.\n    group.add_argument(\n        '-f', '--file-read', default = None,\n        metavar = 'file', help = 'location read by the fuzzed program. '\n        'Usage of @@ is encouraged to keep parallelization possible'\n    )\n\n    group = parser.add_argument_group('minimization settings')\n    group.add_argument(\n        '-C', '--crash-only', action = 'store_true', default = False,\n        help = 'keep crashing inputs in output directory, reject everything else'\n    )\n    group.add_argument(\n        '-e', '--edges-only', action = 'store_true', default = False,\n        help = 'solve for edge coverage only, ignore hit counts'\n    )\n    group.add_argument(\n        '-w', '--workers', type = int, default = multiprocessing.cpu_count(),\n        metavar = 'n', help = 'The number of worker processes (default: cpu count)'\n    )\n    group.add_argument(\n        '--skip-dry-run', action = 'store_true', default = False,\n        help = 'Skip the dry-run step even if it failed'\n    )\n    parser.add_argument(\n        'target_cmdline', nargs = argparse.REMAINDER,\n        help = 'target command line'\n    )\n    return parser.parse_args()\n\n\ndef validate_args(args):\n    '''Validate command-line arguments'''\n    # Validate that the first argument is an executable\n    if not os.path.isfile(args.target_cmdline[0]):\n        logging.error(\n            '[!] The target command line\\'s first argument needs to'\n            ' be an existing executable file.'\n        )\n        return False\n\n    # If we are not seeing the '@@' marker somewhere and that we are not\n    # specifying an input file with -f, then it means something is wrong\n    if args.file_read is None and '@@' not in args.target_cmdline:\n        logging.error(\n            '[!] The target command line needs to include the \"@@\" marker'\n            ' or -f to specify the input file.'\n        )\n        return False\n\n    # Another sanity check on the root of crash directory\n    if args.crash_dir and os.path.isdir(os.path.split(args.crash_dir)[0]) is False:\n        logging.error(\n            '[!] The output crash directory %r is not a directory', args.crash_dir\n        )\n        return False\n\n    # Another sanity check on the root of hang directory\n    if args.hang_dir and os.path.isdir(os.path.split(args.hang_dir)[0]) is False:\n        logging.error(\n            '[!] The output hangs directory %r is not a directory', args.hang_dir\n        )\n        return False\n\n    if os.path.isdir(args.working_dir) is False:\n        logging.error(\n            '[!] The working directory %r is not a directory', args.working_dir\n        )\n        return False\n\n    # Regardless of DRIO being used or not, we need afl-showmap.exe\n    afl_showmap_path = os.path.join(args.working_dir, 'afl-showmap.exe')\n    if not os.path.isfile(afl_showmap_path):\n        logging.error('[!] afl-showmap.exe needs to be in %s.', args.working_dir)\n        return False\n\n    # Make sure the output directory doesn't exist yet, or exists but is empty\n    if os.path.isabs(args.output):\n        output_dir_path = args.output\n    else:\n        output_dir_path = os.path.join(args.working_dir, args.output)\n    if args.dry_run is False:\n        if os.path.isdir(output_dir_path) and os.listdir(output_dir_path):\n            logging.error(\n                '[!] %s already exists, please remove it to avoid data loss.',\n                args.output\n            )\n            return False\n        if os.path.lexists(output_dir_path) and not os.path.isdir(output_dir_path):\n            logging.error(\n                '[!] File %s already exists, can\\'t create a directory with the same name.',\n                args.output\n            )\n            return False\n\n    if not args.static_instr:\n        # Make sure we have all the arguments we need\n        if len(args.coverage_modules) == 0:\n            logging.error(\n                '[!] -coverage_module is a required option to use'\n                'the dynamic instrumentation'\n            )\n            return False\n\n        if None in [args.target_module, args.nargs]:\n            logging.error(\n                '[!] , -target_module and -nargs are required'\n                ' options to use the dynamic instrumentation mode.'\n            )\n            return False\n\n        if args.target_method is None and args.target_offset is None:\n            logging.error(\n                '[!] -target_method or -target_offset is required to use the'\n                ' dynamic instrumentation mode'\n            )\n            return False\n\n        # If we are using DRIO, one of the thing we need is the DRIO client\n        winafl_path = os.path.join(args.working_dir, 'winafl.dll')\n        if not os.path.isfile(winafl_path):\n            logging.error(\n                '[!] winafl.dll needs to be in %s.', args.working_dir\n            )\n            return False\n\n    if args.file_read is not None and '@@' not in args.file_read:\n        # When a particular input file is specified, first\n        # check if the file already exists, because we don't want to overwrite\n        # a potentially interesting test case.\n        if os.path.isabs(args.file_read):\n            file_read_path = args.file_read\n        else:\n            file_read_path = os.path.join(args.working_dir, args.file_read)\n        if os.path.isfile(file_read_path):\n            logging.error(\n                '[!] %s already exists, please remove it to avoid data loss.',\n                args.file_read\n            )\n            return False\n\n    for i in args.input:\n        if os.path.isabs(i):\n            dir_path = i\n        else:\n            dir_path = os.path.join(args.working_dir, i)\n\n        if not os.path.isdir(dir_path):\n            logging.error(\n                '[!] Specified input directory \"%s\" does not exist',\n                i\n            )\n            return False\n\n    return True\n\n\ndef target_dry_run(args, test_input):\n    logging.info('[*] Testing the target binary...')\n    f = AFLShowMapWorker(args)\n    results = list(map(f, (test_input, test_input)))\n    if results[0] != results[1]:\n        logging.error('[!] Dry-run failed, 2 executions resulted differently:')\n        logging.error(\n            '  Tuples matching? %r',\n            results[0].tuples == results[1].tuples\n        )\n        logging.error(\n            '  Return codes matching? %r',\n            results[0].returncode == results[1].returncode\n        )\n\n        if not args.skip_dry_run:\n            return False\n\n    logging.info('[+] OK, %d tuples recorded.', len(results[0].tuples))\n    return True\n\n\ndef run_all_inputs(args, inputs):\n    nprocesses = args.workers\n    if args.file_read is not None and '@@' not in args.file_read:\n        # If you are providing -f, but doesn't specify '@@' in the command line\n        # of the target, it might be a sign that you are doing something wrong.\n        if '@@' not in args.target_cmdline:\n            logging.warn(\n                \"[ ] You specified the -f option without using '@@' in your \"\n                \"command line, this does not sound right.\"\n            )\n\n        logging.info('[+] Worker pool size: 1 (because no \"@@\" in the -f option)..')\n        # Keep in mind that if you want the input files to be named and placed\n        # by your liking by specifying -f path/foo.ext we have to set the pool\n        # size to 1 in order to make it work.\n        nprocesses = 1\n\n    # Record stats about the original input set.\n    #  The aggregated size of every input files.\n    totalsize = 0\n    #  The size of the input set.\n    inputs_len = len(inputs)\n\n    logging.info(\n        '[+] Found %d test cases across: %s.',\n        inputs_len, ', '.join(args.input)\n    )\n\n    logging.info('[*] Instantiating %d worker processes.', nprocesses)\n    p = multiprocessing.Pool(processes = nprocesses)\n    # This tracks every unique tuples and their popularities\n    uniq_tuples = collections.Counter()\n    # This will associate a tuple with the currently fittest file exercising\n    # this particular tuple.\n    candidates = {}\n    # This tracks every files that triggered a hang.\n    hang_files = []\n    # This tracks every files that triggered a crash.\n    crash_files = []\n    # This tracks every files that generated an empty set of tuples.\n    # You might get those if the dynamically instrumented target module doesn't\n    # get hit because the testcase is so malformed that it won't pass a\n    # function called before for example; hence will return an empty tuple set.\n    empty_tuple_files = []\n    # The default return code is no crash.\n    wanted_returncode = 0\n    if args.crash_only:\n        logging.info('[+] Crash only mode enabled.')\n        wanted_returncode = 2\n\n    # Counter tracking how many files we have been through already.\n    i = 1\n    for result in p.imap_unordered(\n        AFLShowMapWorker(args),\n        inputs\n    ):\n        print('\\rProcessing file %d/%d...' % (i, inputs_len), end=' ')\n        i += 1\n        # If the set of tuples is empty, something weird happened\n        if len(result.tuples) == 0:\n            logging.debug(\n                '[x] The input file %s generated an empty set of tuples,'\n                ' skipping it (ret = %d).',\n                result.path, result.returncode\n            )\n            empty_tuple_files.append(result.path)\n            continue\n\n        if result.returncode != wanted_returncode:\n            if result.returncode == 1:\n                hang_files.append(result.path)\n\n            # If the mode crash only is enabled, we track the non-crashing\n            # test cases in the same tuple.\n            if (result.returncode == 2 and args.crash_only is False) or \\\n               (result.returncode == 0 and args.crash_only):\n                crash_files.append(result.path)\n\n            if args.crash_only is False:\n                logging.debug(\n                    '[x] The input file %s triggered a %s, skipping it.',\n                    result.path,\n                    'hang' if result.returncode == 1 else 'crash'\n                )\n            else:\n                logging.debug(\n                    '[x] The input file %s triggered a %s, skipping it.',\n                    result.path,\n                    'hang' if result.returncode == 1 else 'non crash'\n                )\n\n            continue\n\n        totalsize += result.filesize\n\n        # Generate the list of unique tuples while processing the results,\n        # also keep track of their popularities.\n        uniq_tuples.update(result.tuples.keys())\n\n        # Keep an updated dictionary mapping a tuple to the fittest file\n        # of all the paths.\n        for tuple_id, tuple_hitcount in result.tuples.items():\n            fileinfo = {\n                'size' : result.filesize,\n                'path' : result.path,\n                'tuples' : result.tuples,\n                'hitcount' : tuple_hitcount\n            }\n\n            if tuple_id in candidates:\n                candidate = candidates[tuple_id]\n                # If the candidate has a higher hitcount, we keep it.\n                if tuple_hitcount > candidate['hitcount']:\n                    candidates[tuple_id] = fileinfo\n                elif tuple_hitcount == candidate['hitcount']:\n                    # If the candidate has the same hitcount, but a\n                    # smaller size, we keep it.\n                    if result.filesize < candidate['size']:\n                        candidates[tuple_id] = fileinfo\n                    elif result.filesize == candidate['size']:\n                        # If the candidate has the same hitcount and\n                        # size, but exercise a bigger number of tuples,\n                        # we keep it.\n                        if len(result.tuples) > len(candidate['tuples']):\n                            candidate[tuple_id] = fileinfo\n            else:\n                candidates[tuple_id] = fileinfo\n    p.close()\n\n    len_crash_files, len_hang_files, len_empty_tuple_files = map(\n        len, (crash_files, hang_files, empty_tuple_files)\n    )\n    effective_len = len(inputs) - (\n        len_crash_files + len_hang_files + len_empty_tuple_files\n    )\n    print()\n\n    logging.info(\n        '[+] Found %d unique tuples across %d files',\n        len(uniq_tuples), effective_len\n    )\n    if len_hang_files > 0:\n        logging.info('  - %d files triggered a hang', len_hang_files)\n        for hang_file in hang_files:\n            logging.debug('    - %s generated a hang', hang_file)\n\n    if len_crash_files > 0:\n        logging.info(\n            '  - %d files %s a crash',\n            len_crash_files,\n            'did not trigger' if args.crash_only else 'triggered'\n        )\n        for crash_file in crash_files:\n            logging.debug('    - %s generated a crash', crash_file)\n\n    if len_empty_tuple_files > 0:\n        logging.info(\n            '  - %d files resulted in an empty tuple set',\n            len_empty_tuple_files\n        )\n        for empty_tuple_file in empty_tuple_files:\n            logging.debug('    - %s generated an empty tuple', empty_tuple_file)\n\n    return uniq_tuples, candidates, effective_len, totalsize, crash_files, hang_files\n\n\ndef find_best_candidates(uniq_tuples, candidates):\n    # Using the same strategy as in afl-cmin, quoting lcamtuf:\n    # '''\n    # The \"best\" part is understood simply as the smallest input that\n    # includes a particular tuple in its trace. Empirical evidence\n    # suggests that this produces smaller datasets than more involved\n    # algorithms that could be still pulled off in a shell script.\n    # '''\n    minset = []\n    minsetsize = 0\n    remaining_tuples = list(uniq_tuples)\n    len_uniq_tuples = len(uniq_tuples)\n    for tuple_ in uniq_tuples:\n        if tuple_ not in remaining_tuples:\n            # It means we already deleted this tuple, as it was exercised\n            # as part of another test case.\n            continue\n\n        # Pick the current best file candidate for this tuple.\n        candidate = candidates[tuple_]\n\n        # Remove the other tuples also exercised by the candidate\n        # from the remaining_tuples list.\n        for tuple_exercised in candidate['tuples']:\n            # Remove the tuples exercised if we have not\n            # removed them already from the\n            # remaining_tuples list.\n            if tuple_exercised in remaining_tuples:\n                remaining_tuples.remove(tuple_exercised)\n\n        # Keep track of the final minset and its size.\n        minset.append(candidate['path'])\n        minsetsize += candidate['size']\n\n        # We are now done with this tuple, we can get rid of it.\n        del candidates[tuple_]\n\n        print('\\rProcessing tuple %d/%d...' % (\n            len_uniq_tuples - len(remaining_tuples),\n            len_uniq_tuples\n        ), end=' ')\n\n        # If we don't have any more tuples left, we are done.\n        if len(remaining_tuples) == 0:\n            break\n\n    return minset, minsetsize\n\n\ndef do_unique_copy(filepaths, dest_dir):\n    try:\n        os.makedirs(dest_dir)\n    except Exception:\n        if not os.path.isdir(dest_dir):\n            raise\n    num_digits = len(str(len(filepaths)-1))\n    for i, fpath in enumerate(filepaths):\n        filename = os.path.basename(fpath)\n        dest_path = os.path.join(dest_dir, 'id_' + str(i).zfill(num_digits) + \"_\" + filename)\n        shutil.copy(fpath, dest_path)\n\n\ndef main(argc, argv):\n    print('corpus minimization tool for WinAFL by <0vercl0k@tuxfamily.org>')\n    print('Based on WinAFL by <ifratric@google.com>')\n    print('Based on AFL by <lcamtuf@google.com>')\n\n    logging.basicConfig(\n        filename = 'winafl-cmin.log',\n        level = logging.DEBUG,\n        format = '%(asctime)s [%(levelname)-5.5s] [%(funcName)s] %(message)s'\n    )\n\n    args = setup_argparse()\n    cli_handler = logging.StreamHandler(sys.stdout)\n    cli_handler.setLevel(args.verbose)\n    logging.getLogger().addHandler(cli_handler)\n\n    # Interestingly enough, if the user uses '.. -- target.exe -option foo ..'\n    # argparse will add '--' in the target_cmdline option, so we need to\n    # strip it off manually here.\n    if args.target_cmdline[0] == '--':\n        del args.target_cmdline[0]\n\n    logging.debug(\n                    '[+] winafl-cmin launched with the following arguments: %s',\n                    ' '.join(sys.argv)\n                )\n\n    if not validate_args(args):\n        return 1\n\n    os.chdir(args.working_dir)\n    logging.info('[+] CWD changed to %s.', args.working_dir)\n    if args.static_instr is True:\n        logging.info('[+] Dynamorio-less mode is enabled.')\n\n    # Go get all the input files we want to have a look at\n    logging.debug(\n        'Inspecting the following directories: %s',\n        ', '.join(args.input)\n    )\n    inputs = []\n    for path in args.input:\n        for root, dirs, files in os.walk(path):\n            for file_ in files:\n                inputs.append(os.path.join(root, file_))\n\n    if not inputs:\n        logging.error('  Input directories do not contain any files!')\n        return 1\n\n    # Do a dry run with the first file in the set\n    if not target_dry_run(args, inputs[0]):\n        return 1\n\n    t0 = time.time()\n    uniq_tuples, candidates, effective_len, totalsize, crash_files, hang_files = run_all_inputs(args, inputs)\n\n    logging.info('[*] Finding best candidates for each tuple...')\n\n    minset, minsetsize = find_best_candidates(uniq_tuples, candidates)\n\n    print()\n    logging.info('[+] Original set was composed of %d files', len(inputs))\n    logging.info(\n        '[+] Effective set was composed of %d files (total size %.2f MB).',\n        effective_len, (totalsize / 1024.) / 1024.\n    )\n    logging.info(\n        '[+] Narrowed down to %d files (total size %.2f MB).',\n        len(minset), (minsetsize / 1024.) / 1024.\n    )\n\n    if args.dry_run is False:\n        logging.info(\n            '[*] Saving the minset in %s...', os.path.abspath(args.output)\n        )\n        do_unique_copy(minset, args.output)\n\n        if args.crash_dir and crash_files:\n            logging.info(\n                '[+] Saving %d crashing files to %s',\n                len(crash_files), args.crash_dir\n            )\n            do_unique_copy(crash_files, args.crash_dir)\n\n        if args.hang_dir and hang_files:\n            logging.info(\n                '[+] Saving %d hanging files to %s',\n                len(hang_files), args.hang_dir\n            )\n            do_unique_copy(hang_files, args.hang_dir)\n\n    logging.info('[+] Time elapsed: %d seconds', time.time() - t0)\n    return 0\n\n\nif __name__ == '__main__':\n    sys.exit(main(len(sys.argv), sys.argv))\n"
        },
        {
          "name": "winafl-plot.py",
          "type": "blob",
          "size": 4.4541015625,
          "content": "import os\nimport argparse\nimport tempfile\nimport time\nimport subprocess\nimport re\n\nFUZZER_STATS_RX = re.compile('([a-zA-Z_]+)\\s+:\\s+(.+?)\\n')\n\nTEMPLATE = r'''\n<table style=\"font-family: 'Trebuchet MS', 'Tahoma', 'Arial', 'Helvetica'\">\n<tr><td style=\"width: 18ex\"><b>Banner:</b></td><td>{banner}</td></tr>\n<tr><td><b>Directory:</b></td><td>{fuzzer_dir}</td></tr>\n<tr><td><b>Generated on:</b></td><td>{date}</td></tr>\n</table>\n<p>\n<img src=\"high_freq.png\" width=1000 height=300><p>\n<img src=\"low_freq.png\" width=1000 height=200><p>\n<img src=\"exec_speed.png\" width=1000 height=200>\n'''.strip()\n\nGNUPLOT_CMDS = '''\nset terminal png truecolor enhanced size 1000,300 butt\n\nset output '{outdir}/high_freq.png'\n\n#set xdata time\n#set timefmt '%s'\n#set format x \"%b %d\\\\n%H:%M\"\nset tics font 'small'\nunset mxtics\nunset mytics\n\nset grid xtics linetype 0 linecolor rgb '#e0e0e0'\nset grid ytics linetype 0 linecolor rgb '#e0e0e0'\nset border linecolor rgb '#50c0f0'\nset tics textcolor rgb '#000000'\nset key outside\n\nset autoscale xfixmin\nset autoscale xfixmax\n\nset xlabel \"relative time in seconds\" font \"small\"\n\nplot '{fuzzer_dir}/plot_data' using 1:4 with filledcurve x1 title 'total paths' linecolor rgb '#000000' fillstyle transparent solid 0.2 noborder, \\\\\n     '' using 1:3 with filledcurve x1 title 'current path' linecolor rgb '#f0f0f0' fillstyle transparent solid 0.5 noborder, \\\\\n     '' using 1:5 with lines title 'pending paths' linecolor rgb '#0090ff' linewidth 3, \\\\\n     '' using 1:6 with lines title 'pending favs' linecolor rgb '#c00080' linewidth 3, \\\\\n     '' using 1:2 with lines title 'cycles done' linecolor rgb '#c000f0' linewidth 3\n\nset terminal png truecolor enhanced size 1000,200 butt\nset output '{outdir}/low_freq.png'\n\nplot '{fuzzer_dir}/plot_data' using 1:8 with filledcurve x1 title '' linecolor rgb '#c00080' fillstyle transparent solid 0.2 noborder, \\\\\n     '' using 1:8 with lines title ' uniq crashes' linecolor rgb '#c00080' linewidth 3, \\\\\n     '' using 1:9 with lines title 'uniq hangs' linecolor rgb '#c000f0' linewidth 3, \\\\\n     '' using 1:10 with lines title 'levels' linecolor rgb '#0090ff' linewidth 3\n\nset terminal png truecolor enhanced size 1000,200 butt\nset output '{outdir}/exec_speed.png'\n\nplot '{fuzzer_dir}/plot_data' using 1:11 with filledcurve x1 title '' linecolor rgb '#0090ff' fillstyle transparent solid 0.2 noborder, \\\\\n     '{fuzzer_dir}/plot_data' using 1:11 with lines title '    execs/sec' linecolor rgb '#0090ff' linewidth 3 smooth bezier;\n'''\n\n\ndef parse_arguments():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('sync_dir', help='sync directory for afl')\n    parser.add_argument('out_dir', help='output directory for plot')\n\n    args = parser.parse_args()\n    return args\n\n\ndef parse_fuzzer_stats(path):\n    data = ''\n    with open(path, 'rb') as f:\n        data = f.read().decode('utf-8')\n\n    stats = dict(FUZZER_STATS_RX.findall(data))\n\n    # parse to int / float\n    for key, value in stats.items():\n        if not value.isdecimal():\n            continue\n\n        if not value.isnumeric():\n            stats[key] = float(value)\n            continue\n\n        stats[key] = int(value)\n\n    return stats\n\n\ndef main():\n    args = parse_arguments()\n\n    # get banner\n    stats_path = os.path.join(args.sync_dir, 'fuzzer_stats')\n    stats = parse_fuzzer_stats(stats_path)\n    banner = stats['afl_banner']\n\n    # format date in a compatible manner\n    date = time.strftime('%a %b %d %H:%M:%S DST %Y', time.localtime())\n\n    try:\n        os.makedirs(args.out_dir)\n    except OSError:\n        pass\n\n    # write html file\n    index_html = os.path.join(args.out_dir, 'index.html')\n    with open(index_html, 'wb') as f:\n        f.write(TEMPLATE.format(outdir=args.out_dir,\n                                fuzzer_dir=args.sync_dir,\n                                date=date,\n                                banner=banner).encode('utf-8'))\n\n    tmp_file = tempfile.NamedTemporaryFile(delete=False)\n    tmp_file.write(GNUPLOT_CMDS.format(outdir=args.out_dir,\n                                       fuzzer_dir=args.sync_dir).encode('utf-8'))\n    tmp_file.flush()\n\n    # run gnuplot\n    try:\n        subprocess.check_output(['gnuplot', '-c', tmp_file.name])\n    except subprocess.CalledProcessError as e:\n        print(\"Error: failed to run gnuplot, output = {}\".format(e))\n    except OSError:\n        print(\"Error: gnuplot was not found, make sure that gnuplot is installed and in PATH\")\n\n    try:\n        os.unlink(tmp_file.name)\n    except OSError:\n        pass\n\n\nif __name__ == '__main__':\n    main()\n"
        },
        {
          "name": "winafl-whatsup.py",
          "type": "blob",
          "size": 5.67578125,
          "content": "import os\nimport re\nimport sys\nimport glob\nimport ctypes\nimport argparse\n\nFUZZER_STATS_RX = re.compile(r'([a-zA-Z_]+)\\s+:\\s+(.+?)\\n')\n\n\ndef parse_arguments():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-s', '--summary', default=False, action='store_true',\n                        help='skip all per-fuzzer trivia and show just the \\\n                        summary results.'\n                        )\n    parser.add_argument('afl_sync_dir', help='path to afl sync directory')\n\n    args = parser.parse_args()\n    return args\n\n\ndef get_cur_time():\n    class FileTime(ctypes.Structure):\n        _pack_ = 1\n        _fields_ = [('dwLowDateTime', ctypes.c_uint32),\n                    ('dwHighDateTime', ctypes.c_uint32)]\n\n    file_time = FileTime()\n    GetSystemTimeAsFileTime = ctypes.windll.kernel32.GetSystemTimeAsFileTime\n    GetSystemTimeAsFileTime(ctypes.byref(file_time))\n\n    ret = (file_time.dwHighDateTime << 32) + file_time.dwLowDateTime\n\n    return ret / 10000000\n\n\ndef is_process_running(pid):\n    # not very pythonic, but I didn't want to require external dependencies\n    OpenProcess = ctypes.windll.kernel32.OpenProcess\n    CloseHandle = ctypes.windll.kernel32.CloseHandle\n\n    SYNCHRONIZE = 0x00100000\n    process = OpenProcess(SYNCHRONIZE, False, ctypes.c_uint32(pid))\n    if not process:\n        return False\n\n    CloseHandle(process)\n    return True\n\n\ndef parse_fuzzer_stats(path):\n    data = ''\n    with open(path, 'rb') as f:\n        data = f.read().decode('utf-8')\n\n    stats = dict(FUZZER_STATS_RX.findall(data))\n\n    # parse to int / float\n    for key, value in stats.items():\n        if not value.isdecimal():\n            continue\n\n        if not value.isnumeric():\n            stats[key] = float(value)\n            continue\n\n        stats[key] = int(value)\n\n    return stats\n\n\ndef main():\n    args = parse_arguments()\n\n    if not os.path.isdir(args.afl_sync_dir):\n        print(\"error: {} is not a directory\".format(args.afl_sync_dir))\n        return 1\n\n    if os.path.isdir(os.path.join(args.afl_sync_dir, 'queue')):\n        print(\"[-] Error: parameter is an individual output directory, not a sync dir.\")\n        return 1\n\n    print(\"status check tool for afl-fuzz by <lcamtuf@google.com>\\n\")\n\n    verbose = not args.summary\n\n    # stats for all fuzzers\n    alive_count = 0\n    dead_count = 0\n    total_time = 0\n    total_execs = 0\n    total_eps = 0\n    total_crashes = 0\n    total_pfav = 0\n    total_pending = 0\n\n    if verbose:\n        print(\"Individual fuzzers\")\n        print(\"==================\\n\")\n\n    fuzzer_stats_path = os.path.join(args.afl_sync_dir, '*', 'fuzzer_stats')\n    for stats_path in glob.glob(fuzzer_stats_path):\n        try:\n            stats = parse_fuzzer_stats(stats_path)\n\n            start_time = stats['start_time']\n            run_time = get_cur_time() - start_time\n            run_days = int(((run_time / 60) / 60) / 24)\n            run_hours = int((run_time / 60 / 60) % 24)\n\n            if verbose:\n                print(\">>> {} ({} days, {} hours) <<<\\n\".\n                      format(stats['afl_banner'], run_days, run_hours))\n\n            if not is_process_running(stats['fuzzer_pid']):\n                if verbose:\n                    print(\"  Instance is dead_count or running remotely, skipping.\\n\")\n                dead_count += 1\n                continue\n\n            alive_count += 1\n            execs_done = stats['execs_done']\n            exec_sec = float(execs_done) / run_time\n            path_percent = (float(stats['cur_path']) * 100) / stats['paths_total']\n\n            total_time += run_time\n            total_eps += exec_sec\n            total_execs += execs_done\n            total_crashes += stats['unique_crashes']\n            total_pending += stats['pending_total']\n            total_pfav += stats['pending_favs']\n\n            if verbose:\n                print(\"  cycle {}, lifetime speed {:.2f} exec/sec, path {}/{} {:.2f}%\".\n                      format(stats['cycles_done'], exec_sec, stats['cur_path'],\n                             stats['paths_total'], path_percent))\n\n                if stats['unique_crashes'] == 0:\n                    print(\"  pending {}/{}, coverage {}, no crashes yet\".\n                          format(stats['pending_favs'], stats['pending_total'],\n                                 stats['bitmap_cvg']))\n                else:\n                    print(\"  pending {}/{}, coverage {}, crash count {} (!)\".\n                          format(stats['pending_favs'], stats['pending_total'],\n                                 stats['bitmap_cvg'], stats['unique_crashes']))\n\n                print(\"\")\n        except UnicodeDecodeError:\n            print(\"error in parsing fuzzer_stat: {}, seems to be corrupt?\".format(stats_path))\n            continue\n\n    total_days = int(total_time / 60 / 60 / 24)\n    total_hours = int((total_time / 60 / 60) % 24)\n\n    print(\"Summary stats\")\n    print(\"=============\")\n    print(\"\")\n\n    print(\"       Fuzzers alive : {}\".format(alive_count))\n\n    if dead_count > 0:\n        print(\"      Dead or remote : {} (excluded from stats)\".format(dead_count))\n\n    print(\"      Total run time : {} days, {} hours\".format(total_days, total_hours))\n    print(\"         Total execs : {} million\".format(int(total_execs / 1000 / 1000)))\n    print(\"    Cumulative speed : {:.2f} execs/sec\".format(total_eps))\n    print(\"       Pending paths : {} faves, {} total\".format(total_pfav, total_pending))\n    if alive_count > 0:\n        print(\"  Pending per fuzzer : {:.2f} faves, {:.2f} total (on average)\".\n              format(total_pfav / float(alive_count),\n                     total_pending / float(alive_count)))\n\n        print(\"       Crashes found : {} locally unique\".format(total_crashes))\n\n    print(\"\")\n\n    return 0\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n"
        },
        {
          "name": "winafl.c",
          "type": "blob",
          "size": 33.265625,
          "content": "/*\n   WinAFL - DynamoRIO client (instrumentation) code\n   ------------------------------------------------\n\n   Written and maintained by Ivan Fratric <ifratric@google.com>\n\n   Copyright 2016 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#define MAP_SIZE 65536\n\n#include \"dr_api.h\"\n#include \"drmgr.h\"\n#include \"drx.h\"\n#include \"drreg.h\"\n#include \"drwrap.h\"\n\n#ifdef USE_DRSYMS\n#include \"drsyms.h\"\n#endif\n\n#include \"modules.h\"\n#include \"utils.h\"\n#include \"hashtable.h\"\n#include \"drtable.h\"\n#include \"limits.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <windows.h>\n\n#define UNKNOWN_MODULE_ID USHRT_MAX\n\n#ifndef PF_FASTFAIL_AVAILABLE\n#define PF_FASTFAIL_AVAILABLE 23\n#endif\n\n#ifndef STATUS_FATAL_APP_EXIT\n#define STATUS_FATAL_APP_EXIT ((DWORD)0x40000015L)\n#endif\n\n#ifndef STATUS_HEAP_CORRUPTION\n#define STATUS_HEAP_CORRUPTION 0xC0000374\n#endif\n\nstatic uint verbose;\n\n#define NOTIFY(level, fmt, ...) do {          \\\n    if (verbose >= (level))                   \\\n        dr_fprintf(STDERR, fmt, __VA_ARGS__); \\\n} while (0)\n\n#define OPTION_MAX_LENGTH MAXIMUM_PATH\n\n#define COVERAGE_BB 0\n#define COVERAGE_EDGE 1\n\n#ifndef INOUT\n#define INOUT\n#endif\n\n//fuzz modes\nenum persistence_mode_t { native_mode = 0,\tin_app = 1,};\n\ntypedef struct _target_module_t {\n    char module_name[MAXIMUM_PATH];\n    struct _target_module_t *next;\n} target_module_t;\n\ntypedef struct _winafl_option_t {\n    /* Use nudge to notify the process for termination so that\n     * event_exit will be called.\n     */\n    bool nudge_kills;\n    bool debug_mode;\n\t  int persistence_mode;\n    int coverage_kind;\n    char logdir[MAXIMUM_PATH];\n    target_module_t *target_modules;\n    char fuzz_module[MAXIMUM_PATH];\n    char fuzz_method[MAXIMUM_PATH];\n    char pipe_name[MAXIMUM_PATH];\n    char shm_name[MAXIMUM_PATH];\n    unsigned long fuzz_offset;\n    int fuzz_iterations;\n    void **func_args;\n    int num_fuz_args;\n    drwrap_callconv_t callconv;\n    bool thread_coverage;\n    bool no_loop;\n\tbool dr_persist_cache;\n} winafl_option_t;\nstatic winafl_option_t options;\n\n#define NUM_THREAD_MODULE_CACHE 4\n\ntypedef struct _winafl_data_t {\n    module_entry_t *cache[NUM_THREAD_MODULE_CACHE];\n    file_t  log;\n    unsigned char *fake_afl_area; //used for thread_coverage\n    unsigned char *afl_area;\n} winafl_data_t;\nstatic winafl_data_t winafl_data;\n\nstatic int winafl_tls_field;\n\ntypedef struct _fuzz_target_t {\n    reg_t xsp;            /* stack level at entry to the fuzz target */\n    app_pc func_pc;\n    int iteration;\n} fuzz_target_t;\nstatic fuzz_target_t fuzz_target;\n\ntypedef struct _debug_data_t {\n    int pre_handler_called;\n    int post_handler_called;\n} debug_data_t;\nstatic debug_data_t debug_data;\n\nstatic module_table_t *module_table;\nstatic client_id_t client_id;\n\nstatic volatile bool go_native;\n\nstatic void\nevent_exit(void);\n\nstatic void\nevent_thread_exit(void *drcontext);\n\nstatic HANDLE pipe;\n\n/****************************************************************************\n * Nudges\n */\n\nenum {\n    NUDGE_TERMINATE_PROCESS = 1,\n};\n\nstatic void\nevent_nudge(void *drcontext, uint64 argument)\n{\n    int nudge_arg = (int)argument;\n    int exit_arg  = (int)(argument >> 32);\n    if (nudge_arg == NUDGE_TERMINATE_PROCESS) {\n        static int nudge_term_count;\n        /* handle multiple from both NtTerminateProcess and NtTerminateJobObject */\n        uint count = dr_atomic_add32_return_sum(&nudge_term_count, 1);\n        if (count == 1) {\n            dr_exit_process(exit_arg);\n        }\n    }\n    ASSERT(nudge_arg == NUDGE_TERMINATE_PROCESS, \"unsupported nudge\");\n    ASSERT(false, \"should not reach\"); /* should not reach */\n}\n\nstatic bool\nevent_soft_kill(process_id_t pid, int exit_code)\n{\n    /* we pass [exit_code, NUDGE_TERMINATE_PROCESS] to target process */\n    dr_config_status_t res;\n    res = dr_nudge_client_ex(pid, client_id,\n                             NUDGE_TERMINATE_PROCESS | (uint64)exit_code << 32,\n                             0);\n    if (res == DR_SUCCESS) {\n        /* skip syscall since target will terminate itself */\n        return true;\n    }\n    /* else failed b/c target not under DR control or maybe some other\n     * error: let syscall go through\n     */\n    return false;\n}\n\n/****************************************************************************\n * Event Callbacks\n */\n\nchar ReadCommandFromPipe()\n{\n\tDWORD num_read;\n\tchar result;\n\tReadFile(pipe, &result, 1, &num_read, NULL);\n\treturn result;\n}\n\nvoid WriteCommandToPipe(char cmd)\n{\n\tDWORD num_written;\n\tWriteFile(pipe, &cmd, 1, &num_written, NULL);\n}\n\nvoid WriteDWORDCommandToPipe(DWORD data)\n{\n\tDWORD num_written;\n\tWriteFile(pipe, &data, sizeof(DWORD), &num_written, NULL);\n}\n\n\nstatic void\ndump_winafl_data()\n{\n    dr_write_file(winafl_data.log, winafl_data.afl_area, MAP_SIZE);\n}\n\nstatic bool\nonexception(void *drcontext, dr_exception_t *excpt) {\n    DWORD exception_code = excpt->record->ExceptionCode;\n\n    if(options.debug_mode)\n        dr_fprintf(winafl_data.log, \"Exception caught: %x\\n\", exception_code);\n\n    if((exception_code == EXCEPTION_ACCESS_VIOLATION) ||\n       (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION) ||\n       (exception_code == EXCEPTION_PRIV_INSTRUCTION) ||\n       (exception_code == EXCEPTION_INT_DIVIDE_BY_ZERO) ||\n       (exception_code == STATUS_HEAP_CORRUPTION) ||\n       (exception_code == EXCEPTION_STACK_OVERFLOW) ||\n       (exception_code == STATUS_STACK_BUFFER_OVERRUN) ||\n       (exception_code == STATUS_FATAL_APP_EXIT)) {\n            if(options.debug_mode) {\n                dr_fprintf(winafl_data.log, \"crashed\\n\");\n            } else {\n\t\t\t\tWriteCommandToPipe('C');\n\t\t\t\tWriteDWORDCommandToPipe(exception_code);\t\t\t\t\n            }\n            dr_exit_process(1);\n    }\n    return true;\n}\n\nstatic void event_thread_init(void *drcontext)\n{\n  void **thread_data;\n\n  thread_data = (void **)dr_thread_alloc(drcontext, 2 * sizeof(void *));\n  thread_data[0] = 0;\n  if(options.thread_coverage) {\n    thread_data[1] = winafl_data.fake_afl_area;\n  } else {\n    thread_data[1] = winafl_data.afl_area;\n  }\n  drmgr_set_tls_field(drcontext, winafl_tls_field, thread_data);\n}\n\nstatic void event_thread_exit(void *drcontext)\n{\n  void *data = drmgr_get_tls_field(drcontext, winafl_tls_field);\n  dr_thread_free(drcontext, data, 2 * sizeof(void *));\n}\n\nstatic dr_emit_flags_t\ninstrument_bb_coverage(void *drcontext, void *tag, instrlist_t *bb, instr_t *inst,\n                      bool for_trace, bool translating, void *user_data)\n{\n    static bool debug_information_output = false;\n    app_pc start_pc;\n    module_entry_t **mod_entry_cache;\n    module_entry_t *mod_entry;\n    const char *module_name;\n    uint offset;\n    target_module_t *target_modules;\n    bool should_instrument;\n    unsigned char *afl_map;\n\tdr_emit_flags_t ret;\n\n    if (!drmgr_is_first_instr(drcontext, inst))\n        return DR_EMIT_DEFAULT;\n\n    start_pc = dr_fragment_app_pc(tag);\n\n    mod_entry_cache = winafl_data.cache;\n    mod_entry = module_table_lookup(mod_entry_cache,\n                                                NUM_THREAD_MODULE_CACHE,\n                                                module_table, start_pc);\n\n    if (mod_entry == NULL || mod_entry->data == NULL) return DR_EMIT_DEFAULT;\n\n    module_name = dr_module_preferred_name(mod_entry->data);\n\n    should_instrument = false;\n    target_modules = options.target_modules;\n    while(target_modules) {\n        if(_stricmp(module_name, target_modules->module_name) == 0) {\n            should_instrument = true;\n            if(options.debug_mode && debug_information_output == false) {\n                dr_fprintf(winafl_data.log, \"Instrumenting %s with the 'bb' mode\\n\", module_name);\n                debug_information_output = true;\n            }\n            break;\n        }\n        target_modules = target_modules->next;\n    }\n    if(!should_instrument) return DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;\n\n    offset = (uint)(start_pc - mod_entry->data->start);\n    offset &= MAP_SIZE - 1;\n\n    afl_map = winafl_data.afl_area;\n\n    drreg_reserve_aflags(drcontext, bb, inst);\n\n    if(options.thread_coverage || options.dr_persist_cache) {\n      reg_id_t reg;\n      opnd_t opnd1, opnd2;\n      instr_t *new_instr;\n\n      drreg_reserve_register(drcontext, bb, inst, NULL, &reg);\n\n      drmgr_insert_read_tls_field(drcontext, winafl_tls_field, bb, inst, reg);\n\n      opnd1 = opnd_create_reg(reg);\n      opnd2 = OPND_CREATE_MEMPTR(reg, sizeof(void *));\n      new_instr = INSTR_CREATE_mov_ld(drcontext, opnd1, opnd2);\n      instrlist_meta_preinsert(bb, inst, new_instr);\n\n      opnd1 = OPND_CREATE_MEM8(reg, offset);\n      new_instr = INSTR_CREATE_inc(drcontext, opnd1);\n      instrlist_meta_preinsert(bb, inst, new_instr);\n\n      drreg_unreserve_register(drcontext, bb, inst, reg);\n\n\t  ret = DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;\n\n\t} else {\n\n      instrlist_meta_preinsert(bb, inst,\n          INSTR_CREATE_inc(drcontext, OPND_CREATE_ABSMEM\n          (&(afl_map[offset]), OPSZ_1)));\n\n\t  ret = DR_EMIT_DEFAULT;\n    }\n\n    drreg_unreserve_aflags(drcontext, bb, inst);\n\n    return ret;\n}\n\nstatic dr_emit_flags_t\ninstrument_edge_coverage(void *drcontext, void *tag, instrlist_t *bb, instr_t *inst,\n                      bool for_trace, bool translating, void *user_data)\n{\n    static bool debug_information_output = false;\n    app_pc start_pc;\n    module_entry_t **mod_entry_cache;\n    module_entry_t *mod_entry;\n    reg_id_t reg, reg2, reg3;\n    opnd_t opnd1, opnd2;\n    instr_t *new_instr;\n    const char *module_name;\n    uint offset;\n    target_module_t *target_modules;\n    bool should_instrument;\n\tdr_emit_flags_t ret;\n\n    if (!drmgr_is_first_instr(drcontext, inst))\n        return DR_EMIT_DEFAULT;\n\n    start_pc = dr_fragment_app_pc(tag);\n\n    mod_entry_cache = winafl_data.cache;\n    mod_entry = module_table_lookup(mod_entry_cache,\n                                                NUM_THREAD_MODULE_CACHE,\n                                                module_table, start_pc);\n\n     if (mod_entry == NULL || mod_entry->data == NULL) return DR_EMIT_DEFAULT;\n\n    module_name = dr_module_preferred_name(mod_entry->data);\n\n    should_instrument = false;\n    target_modules = options.target_modules;\n    while(target_modules) {\n        if(_stricmp(module_name, target_modules->module_name) == 0) {\n            should_instrument = true;\n            if(options.debug_mode && debug_information_output == false) {\n                dr_fprintf(winafl_data.log, \"Instrumenting %s with the 'edge' mode\\n\", module_name);\n                debug_information_output = true;\n            }\n            break;\n        }\n        target_modules = target_modules->next;\n    }\n    if(!should_instrument) return DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;\n\n    offset = (uint)(start_pc - mod_entry->data->start);\n    offset &= MAP_SIZE - 1;\n\n    drreg_reserve_aflags(drcontext, bb, inst);\n    drreg_reserve_register(drcontext, bb, inst, NULL, &reg);\n    drreg_reserve_register(drcontext, bb, inst, NULL, &reg2);\n    drreg_reserve_register(drcontext, bb, inst, NULL, &reg3);\n\n    //reg2 stores AFL area, reg 3 stores previous offset\n\n    //load the pointer to previous offset in reg3\n    drmgr_insert_read_tls_field(drcontext, winafl_tls_field, bb, inst, reg3);\n\n    //load address of shm into reg2\n    if(options.thread_coverage || options.dr_persist_cache) {\n      opnd1 = opnd_create_reg(reg2);\n      opnd2 = OPND_CREATE_MEMPTR(reg3, sizeof(void *));\n      new_instr = INSTR_CREATE_mov_ld(drcontext, opnd1, opnd2);\n      instrlist_meta_preinsert(bb, inst, new_instr);\n\n\t  ret = DR_EMIT_DEFAULT | DR_EMIT_PERSISTABLE;\n\n\t} else {\n      opnd1 = opnd_create_reg(reg2);\n      opnd2 = OPND_CREATE_INTPTR((uint64)winafl_data.afl_area);\n      new_instr = INSTR_CREATE_mov_imm(drcontext, opnd1, opnd2);\n      instrlist_meta_preinsert(bb, inst, new_instr);\n\n\t  ret = DR_EMIT_DEFAULT;\n    }\n\n    //load previous offset into register\n    opnd1 = opnd_create_reg(reg);\n    opnd2 = OPND_CREATE_MEMPTR(reg3, 0);\n    new_instr = INSTR_CREATE_mov_ld(drcontext, opnd1, opnd2);\n    instrlist_meta_preinsert(bb, inst, new_instr);\n\n    //xor register with the new offset\n    opnd1 = opnd_create_reg(reg);\n    opnd2 = OPND_CREATE_INT32(offset);\n    new_instr = INSTR_CREATE_xor(drcontext, opnd1, opnd2);\n    instrlist_meta_preinsert(bb, inst, new_instr);\n\n    //increase the counter at reg + reg2\n    opnd1 = opnd_create_base_disp(reg2, reg, 1, 0, OPSZ_1);\n    new_instr = INSTR_CREATE_inc(drcontext, opnd1);\n    instrlist_meta_preinsert(bb, inst, new_instr);\n\n    //store the new value\n    offset = (offset >> 1)&(MAP_SIZE - 1);\n    opnd1 = OPND_CREATE_MEMPTR(reg3, 0);\n    opnd2 = OPND_CREATE_INT32(offset);\n    new_instr = INSTR_CREATE_mov_st(drcontext, opnd1, opnd2);\n    instrlist_meta_preinsert(bb, inst, new_instr);\n\n    drreg_unreserve_register(drcontext, bb, inst, reg3);\n    drreg_unreserve_register(drcontext, bb, inst, reg2);\n    drreg_unreserve_register(drcontext, bb, inst, reg);\n    drreg_unreserve_aflags(drcontext, bb, inst);\n\n    return ret;\n}\n\nstatic void\npre_loop_start_handler(void *wrapcxt, INOUT void **user_data)\n{\n\tvoid *drcontext = drwrap_get_drcontext(wrapcxt);\n\n\tif (!options.debug_mode) {\n\t\t//let server know we finished a cycle, redundunt on first cycle.\n\t\tWriteCommandToPipe('K');\n\n\t\tif (fuzz_target.iteration == options.fuzz_iterations) {\n\t\t\tdr_exit_process(0);\n\t\t}\n\t\tfuzz_target.iteration++;\n\n\t\t//let server know we are starting a new cycle\n\t\tWriteCommandToPipe('P'); \n\n\t\t//wait for server acknowledgement for cycle start\n\t\tchar command = ReadCommandFromPipe(); \n\n\t\tif (command != 'F') {\n\t\t\tif (command == 'Q') {\n\t\t\t\tdr_exit_process(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchar errorMessage[] = \"unrecognized command received over pipe: \";\n\t\t\t\terrorMessage[sizeof(errorMessage)-2] = command;\n\t\t\t\tDR_ASSERT_MSG(false, errorMessage);\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tdebug_data.pre_handler_called++;\n\t\tdr_fprintf(winafl_data.log, \"In pre_loop_start_handler: %d\\n\", debug_data.pre_handler_called);\n\t}\n\n\tmemset(winafl_data.afl_area, 0, MAP_SIZE);\n\n\tif (options.coverage_kind == COVERAGE_EDGE || options.thread_coverage) {\n\t\tvoid **thread_data = (void **)drmgr_get_tls_field(drcontext, winafl_tls_field);\n\t\tthread_data[0] = 0;\n\t\tthread_data[1] = winafl_data.afl_area;\n\t}\n}\n\nstatic void\npre_fuzz_handler(void *wrapcxt, INOUT void **user_data)\n{\n    char command = 0;\n    int i;\n    void *drcontext;\n\n    app_pc target_to_fuzz = drwrap_get_func(wrapcxt);\n    dr_mcontext_t *mc = drwrap_get_mcontext_ex(wrapcxt, DR_MC_ALL);\n    drcontext = drwrap_get_drcontext(wrapcxt);\n\n    fuzz_target.xsp = mc->xsp;\n    fuzz_target.func_pc = target_to_fuzz;\n\n    if(!options.debug_mode) {\n\t\tWriteCommandToPipe('P');\n\t\tcommand = ReadCommandFromPipe();\n\n        if(command != 'F') {\n            if(command == 'Q') {\n                dr_exit_process(0);\n            } else {\n                DR_ASSERT_MSG(false, \"unrecognized command received over pipe\");\n            }\n        }\n    } else {\n        debug_data.pre_handler_called++;\n        dr_fprintf(winafl_data.log, \"In pre_fuzz_handler\\n\");\n    }\n\n    //save or restore arguments\n    if (!options.no_loop) {\n        if (fuzz_target.iteration == 0) {\n            for (i = 0; i < options.num_fuz_args; i++)\n                options.func_args[i] = drwrap_get_arg(wrapcxt, i);\n        } else {\n            for (i = 0; i < options.num_fuz_args; i++)\n                drwrap_set_arg(wrapcxt, i, options.func_args[i]);\n        }\n    }\n\n    memset(winafl_data.afl_area, 0, MAP_SIZE);\n\n    if(options.coverage_kind == COVERAGE_EDGE || options.thread_coverage) {\n        void **thread_data = (void **)drmgr_get_tls_field(drcontext, winafl_tls_field);\n        thread_data[0] = 0;\n        thread_data[1] = winafl_data.afl_area;\n    }\n}\n\nstatic void\npost_fuzz_handler(void *wrapcxt, void *user_data)\n{\n    dr_mcontext_t *mc;\n    void *drcontext;\n    mc = drwrap_get_mcontext(wrapcxt);\n\n    if(options.no_loop && (options.coverage_kind == COVERAGE_EDGE || options.thread_coverage)) {\n        // no_loo and thread_coverage are enabled.\n        // It is possible that the thread will return to a thread queue\n        // in which case it can later call other functions than the target.\n        // Therefore, coverage measurement must be stopped for this thread.\n        drcontext = drwrap_get_drcontext(wrapcxt);\n        void **thread_data = (void **)drmgr_get_tls_field(drcontext, winafl_tls_field);\n        thread_data[1] = winafl_data.fake_afl_area;\n    }\n\n\n    if(!options.debug_mode) {\n\t\tWriteCommandToPipe('K');\n    } else {\n        debug_data.post_handler_called++;\n        dr_fprintf(winafl_data.log, \"In post_fuzz_handler\\n\");\n    }\n\n    /* We don't need to reload context in case of network-based fuzzing. */\n    if (options.no_loop)\n        return;\n\n    fuzz_target.iteration++;\n    if(fuzz_target.iteration == options.fuzz_iterations) {\n        dr_exit_process(0);\n    }\n\n    mc->xsp = fuzz_target.xsp;\n    mc->pc = fuzz_target.func_pc;\n\tdrwrap_redirect_execution(wrapcxt);\n}\n\nstatic void\ncreatefilew_interceptor(void *wrapcxt, INOUT void **user_data)\n{\n    wchar_t *filenamew = (wchar_t *)drwrap_get_arg(wrapcxt, 0);\n    if(options.debug_mode)\n        dr_fprintf(winafl_data.log, \"In OpenFileW, reading %ls\\n\", filenamew);\n}\n\nstatic void\ncreatefilea_interceptor(void *wrapcxt, INOUT void **user_data)\n{\n    char *filename = (char *)drwrap_get_arg(wrapcxt, 0);\n    if(options.debug_mode)\n        dr_fprintf(winafl_data.log, \"In OpenFileA, reading %s\\n\", filename);\n}\n\nstatic void\nverfierstopmessage_interceptor_pre(void *wrapctx, INOUT void **user_data)\n{\n    EXCEPTION_RECORD exception_record = { 0 };\n    dr_exception_t dr_exception = { 0 };\n    dr_exception.record = &exception_record;\n    exception_record.ExceptionCode = STATUS_HEAP_CORRUPTION;\n\n    onexception(NULL, &dr_exception);\n}\n\nstatic void\nrecvfrom_interceptor(void *wrapcxt, INOUT void **user_data)\n{\n    if (options.debug_mode)\n        dr_fprintf(winafl_data.log, \"In recvfrom\\n\");\n}\n\nstatic void\nrecv_interceptor(void *wrapcxt, INOUT void **user_data)\n{\n    if (options.debug_mode)\n        dr_fprintf(winafl_data.log, \"In recv\\n\");\n}\n\nstatic void\nisprocessorfeaturepresent_interceptor_pre(void *wrapcxt, INOUT void **user_data)\n{\n    DWORD feature = (DWORD)drwrap_get_arg(wrapcxt, 0);\n    *user_data = (void*)feature;\n}\n\nstatic void\nisprocessorfeaturepresent_interceptor_post(void *wrapcxt, void *user_data)\n{\n    DWORD feature = (DWORD)user_data;\n    if(feature == PF_FASTFAIL_AVAILABLE) {\n        if(options.debug_mode) {\n            dr_fprintf(winafl_data.log, \"About to make IsProcessorFeaturePresent(%d) returns 0\\n\", feature);\n        }\n\n        // Make the software thinks that _fastfail() is not supported.\n        drwrap_set_retval(wrapcxt, (void*)0);\n    }\n}\n\nstatic void\nunhandledexceptionfilter_interceptor_pre(void *wrapcxt, INOUT void **user_data)\n{\n    PEXCEPTION_POINTERS exception = (PEXCEPTION_POINTERS)drwrap_get_arg(wrapcxt, 0);\n    dr_exception_t dr_exception = { 0 };\n\n    // Fake an exception\n    dr_exception.record = exception->ExceptionRecord;\n    onexception(NULL, &dr_exception);\n}\n\nstatic void\nevent_module_unload(void *drcontext, const module_data_t *info)\n{\n    module_table_unload(module_table, info);\n}\n\nstatic void\nevent_module_load(void *drcontext, const module_data_t *info, bool loaded)\n{\n    const char *module_name = info->names.exe_name;\n    app_pc to_wrap = 0;\n\n    if (module_name == NULL) {\n        // In case exe_name is not defined, we will fall back on the preferred name.\n        module_name = dr_module_preferred_name(info);\n    }\n\n    if(options.debug_mode)\n        dr_fprintf(winafl_data.log, \"Module loaded, %s\\n\", module_name);\n\n    if(options.fuzz_module[0]) {\n        if(_stricmp(module_name, options.fuzz_module) == 0) {\n            if(options.fuzz_offset) {\n                to_wrap = info->start + options.fuzz_offset;\n            } else {\n                //first try exported symbols\n                to_wrap = (app_pc)dr_get_proc_address(info->handle, options.fuzz_method);\n                if(!to_wrap) {\n                    //if that fails, try with the symbol access library\n#ifdef USE_DRSYMS\n                    drsym_init(0);\n                    drsym_lookup_symbol(info->full_path, options.fuzz_method, (size_t *)(&to_wrap), 0);\n                    drsym_exit();\n#endif\n                    DR_ASSERT_MSG(to_wrap, \"Can't find specified method in target_module\");\n                    to_wrap += (size_t)info->start;\n                }\n            }\n\t\t\tif (options.persistence_mode == native_mode)\n\t\t\t{\n\t\t\t\tdrwrap_wrap_ex(to_wrap, pre_fuzz_handler, post_fuzz_handler, NULL, options.callconv);\n\t\t\t}\n\t\t\tif (options.persistence_mode == in_app)\n\t\t\t{\n\t\t\t\tdrwrap_wrap_ex(to_wrap, pre_loop_start_handler, NULL, NULL, options.callconv);\n\t\t\t}\n        }\n\n        if (options.debug_mode && (_stricmp(module_name, \"WS2_32.dll\") == 0)) {\n            to_wrap = (app_pc)dr_get_proc_address(info->handle, \"recvfrom\");\n            bool result = drwrap_wrap(to_wrap, recvfrom_interceptor, NULL);\n            to_wrap = (app_pc)dr_get_proc_address(info->handle, \"recv\");\n            result = drwrap_wrap(to_wrap, recv_interceptor, NULL);\n        }\n\n        if(options.debug_mode && (_stricmp(module_name, \"KERNEL32.dll\") == 0)) {\n            to_wrap = (app_pc)dr_get_proc_address(info->handle, \"CreateFileW\");\n            drwrap_wrap(to_wrap, createfilew_interceptor, NULL);\n            to_wrap = (app_pc)dr_get_proc_address(info->handle, \"CreateFileA\");\n            drwrap_wrap(to_wrap, createfilea_interceptor, NULL);\n        }\n\n        if(_stricmp(module_name, \"kernelbase.dll\") == 0) {\n            // Since Win8, software can use _fastfail() to trigger an exception that cannot be caught.\n            // This is a problem for winafl as it also means DR won't be able to see it. Good thing is that\n            // usually those routines (__report_gsfailure for example) accounts for platforms that don't\n            // have support for fastfail. In those cases, they craft an exception record and pass it\n            // to UnhandledExceptionFilter.\n            //\n            // To work around this we set up two hooks:\n            //   (1) IsProcessorFeaturePresent(PF_FASTFAIL_AVAILABLE): to lie and pretend that the\n            //       platform doesn't support fastfail.\n            //   (2) UnhandledExceptionFilter: to intercept the exception record and forward it\n            //       to winafl's exception handler.\n            to_wrap = (app_pc)dr_get_proc_address(info->handle, \"IsProcessorFeaturePresent\");\n            drwrap_wrap(to_wrap, isprocessorfeaturepresent_interceptor_pre, isprocessorfeaturepresent_interceptor_post);\n            to_wrap = (app_pc)dr_get_proc_address(info->handle, \"UnhandledExceptionFilter\");\n            drwrap_wrap(to_wrap, unhandledexceptionfilter_interceptor_pre, NULL);\n        }\n    }\n\n    if (_stricmp(module_name, \"verifier.dll\") == 0) {\n        to_wrap = (app_pc)dr_get_proc_address(info->handle, \"VerifierStopMessage\");\n        drwrap_wrap(to_wrap, verfierstopmessage_interceptor_pre, NULL);\n    }\n\n    module_table_load(module_table, info);\n}\n\nstatic void\nevent_exit(void)\n{\n    if(options.debug_mode) {\n        if(debug_data.pre_handler_called == 0) {\n            dr_fprintf(winafl_data.log, \"WARNING: Target function was never called. Incorrect target_offset?\\n\");\n        } else if(debug_data.post_handler_called == 0 && options.persistence_mode != in_app) {\n            dr_fprintf(winafl_data.log, \"WARNING: Post-fuzz handler was never reached. Did the target function return normally?\\n\");\n        } else if(debug_data.pre_handler_called == 1 && options.persistence_mode == in_app) {\n            dr_fprintf(winafl_data.log, \"WARNING: Only hit pre_loop_start_handler once, Is your target function in a loop?\\n\");\n        } else {\n            dr_fprintf(winafl_data.log, \"Everything appears to be running normally.\\n\");\n        }\n\n        dr_fprintf(winafl_data.log, \"Coverage map follows:\\n\");\n        dump_winafl_data();\n        dr_close_file(winafl_data.log);\n    }\n\n    /* destroy module table */\n    module_table_destroy(module_table);\n\n    drx_exit();\n    drmgr_exit();\n}\n\nstatic void\nevent_init(void)\n{\n    char buf[MAXIMUM_PATH];\n\n    module_table = module_table_create();\n\n    memset(winafl_data.cache, 0, sizeof(winafl_data.cache));\n    memset(winafl_data.afl_area, 0, MAP_SIZE);\n\n    if(options.debug_mode) {\n        debug_data.pre_handler_called = 0;\n        debug_data.post_handler_called = 0;\n\n        winafl_data.log =\n            drx_open_unique_appid_file(options.logdir, dr_get_process_id(),\n                                   \"afl\", \"proc.log\",\n                                   DR_FILE_ALLOW_LARGE,\n                                   buf, BUFFER_SIZE_ELEMENTS(buf));\n        if (winafl_data.log != INVALID_FILE) {\n            dr_log(NULL, LOG_ALL, 1, \"winafl: log file is %s\\n\", buf);\n            NOTIFY(1, \"<created log file %s>\\n\", buf);\n        }\n    }\n\n    fuzz_target.iteration = 0;\n}\n\n\nstatic void\nsetup_pipe() {\n    pipe = CreateFile(\n         options.pipe_name,   // pipe name\n         GENERIC_READ |  // read and write access\n         GENERIC_WRITE,\n         0,              // no sharing\n         NULL,           // default security attributes\n         OPEN_EXISTING,  // opens existing pipe\n         0,              // default attributes\n         NULL);          // no template file\n\n    if (pipe == INVALID_HANDLE_VALUE) DR_ASSERT_MSG(false, \"error connecting to pipe\");\n}\n\nstatic void\nsetup_shmem() {\n   HANDLE map_file;\n\n   map_file = OpenFileMapping(\n                   FILE_MAP_ALL_ACCESS,   // read/write access\n                   FALSE,                 // do not inherit the name\n                   options.shm_name);            // name of mapping object\n\n   if (map_file == NULL) DR_ASSERT_MSG(false, \"error accesing shared memory\");\n\n   winafl_data.afl_area = (unsigned char *) MapViewOfFile(map_file, // handle to map object\n               FILE_MAP_ALL_ACCESS,  // read/write permission\n               0,\n               0,\n               MAP_SIZE);\n\n   if (winafl_data.afl_area == NULL) DR_ASSERT_MSG(false, \"error accesing shared memory\");\n}\n\nstatic void\noptions_init(client_id_t id, int argc, const char *argv[])\n{\n    int i;\n    const char *token;\n    target_module_t *target_modules;\n    /* default values */\n\toptions.persistence_mode = native_mode;\n    options.nudge_kills = true;\n    options.debug_mode = false;\n    options.thread_coverage = false;\n    options.coverage_kind = COVERAGE_BB;\n    options.target_modules = NULL;\n    options.fuzz_module[0] = 0;\n    options.fuzz_method[0] = 0;\n    options.fuzz_offset = 0;\n    options.fuzz_iterations = 1000;\n    options.no_loop = false;\n    options.func_args = NULL;\n    options.num_fuz_args = 0;\n    options.callconv = DRWRAP_CALLCONV_DEFAULT;\n\toptions.dr_persist_cache = false;\n    dr_snprintf(options.logdir, BUFFER_SIZE_ELEMENTS(options.logdir), \".\");\n\n    strcpy(options.pipe_name, \"\\\\\\\\.\\\\pipe\\\\afl_pipe_default\");\n    strcpy(options.shm_name, \"afl_shm_default\");\n\n    for (i = 1/*skip client*/; i < argc; i++) {\n        token = argv[i];\n        if (strcmp(token, \"-no_nudge_kills\") == 0)\n            options.nudge_kills = false;\n        else if (strcmp(token, \"-nudge_kills\") == 0)\n            options.nudge_kills = true;\n        else if (strcmp(token, \"-thread_coverage\") == 0)\n            options.thread_coverage = true;\n        else if (strcmp(token, \"-debug\") == 0)\n            options.debug_mode = true;\n        else if (strcmp(token, \"-logdir\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing logdir path\");\n            strncpy(options.logdir, argv[++i], BUFFER_SIZE_ELEMENTS(options.logdir));\n        }\n        else if (strcmp(token, \"-fuzzer_id\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing fuzzer id\");\n            strcpy(options.pipe_name, \"\\\\\\\\.\\\\pipe\\\\afl_pipe_\");\n            strcpy(options.shm_name, \"afl_shm_\");\n            strcat(options.pipe_name, argv[i+1]);\n            strcat(options.shm_name, argv[i+1]);\n            i++;\n        }\n        else if (strcmp(token, \"-covtype\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing coverage type\");\n            token = argv[++i];\n            if(strcmp(token, \"bb\")==0) options.coverage_kind = COVERAGE_BB;\n            else if (strcmp(token, \"edge\")==0) options.coverage_kind = COVERAGE_EDGE;\n            else USAGE_CHECK(false, \"invalid coverage type\");\n        }\n        else if (strcmp(token, \"-coverage_module\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing module\");\n            target_modules = options.target_modules;\n            options.target_modules = (target_module_t *)dr_global_alloc(sizeof(target_module_t));\n            options.target_modules->next = target_modules;\n            strncpy(options.target_modules->module_name, argv[++i], BUFFER_SIZE_ELEMENTS(options.target_modules->module_name));\n        }\n        else if (strcmp(token, \"-target_module\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing module\");\n            strncpy(options.fuzz_module, argv[++i], BUFFER_SIZE_ELEMENTS(options.fuzz_module));\n        }\n        else if (strcmp(token, \"-target_method\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing method\");\n            strncpy(options.fuzz_method, argv[++i], BUFFER_SIZE_ELEMENTS(options.fuzz_method));\n        }\n        else if (strcmp(token, \"-fuzz_iterations\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing number of iterations\");\n            options.fuzz_iterations = atoi(argv[++i]);\n        }\n        else if (strcmp(token, \"-nargs\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing number of arguments\");\n            options.num_fuz_args = atoi(argv[++i]);\n        }\n        else if (strcmp(token, \"-target_offset\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing offset\");\n            options.fuzz_offset = strtoul(argv[++i], NULL, 0);\n        }\n        else if (strcmp(token, \"-verbose\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing -verbose number\");\n            token = argv[++i];\n            if (dr_sscanf(token, \"%u\", &verbose) != 1) {\n                USAGE_CHECK(false, \"invalid -verbose number\");\n            }\n        }\n        else if (strcmp(token, \"-call_convention\") == 0) {\n            USAGE_CHECK((i + 1) < argc, \"missing calling convention\");\n            ++i;\n            if (strcmp(argv[i], \"stdcall\") == 0)\n                options.callconv = DRWRAP_CALLCONV_CDECL;\n            else if (strcmp(argv[i], \"fastcall\") == 0)\n                options.callconv = DRWRAP_CALLCONV_FASTCALL;\n            else if (strcmp(argv[i], \"thiscall\") == 0)\n                options.callconv = DRWRAP_CALLCONV_THISCALL;\n            else if (strcmp(argv[i], \"ms64\") == 0)\n                options.callconv = DRWRAP_CALLCONV_MICROSOFT_X64;\n            else\n                NOTIFY(0, \"Unknown calling convention, using default value instead.\\n\");\n\t\t}\n\t\telse if (strcmp(token, \"-no_loop\") == 0) {\n\t\t\toptions.no_loop = true;\n\t\t}\n\t\telse if (strcmp(token, \"-drpersist\") == 0) {\n\t\t\toptions.dr_persist_cache = true;\n\t\t}\n\t\telse if (strcmp(token, \"-persistence_mode\") == 0) {\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing mode arg: '-fuzz_mode' arg\");\n\t\t\tconst char* mode = argv[++i];\n\t\t\tif (strcmp(mode, \"in_app\") == 0)\n\t\t\t{\n\t\t\t\toptions.persistence_mode = in_app;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\toptions.persistence_mode = native_mode;\n\t\t\t}\n\t\t}\n        else {\n            NOTIFY(0, \"UNRECOGNIZED OPTION: \\\"%s\\\"\\n\", token);\n            USAGE_CHECK(false, \"invalid option\");\n        }\n    }\n\n    if(options.fuzz_module[0] && (options.fuzz_offset == 0) && (options.fuzz_method[0] == 0)) {\n       USAGE_CHECK(false, \"If target_module is specified, then either target_method or target_offset must be as well\");\n    }\n\n    if(options.num_fuz_args) {\n        options.func_args = (void **)dr_global_alloc(options.num_fuz_args * sizeof(void *));\n    }\n}\n\nDR_EXPORT void\ndr_client_main(client_id_t id, int argc, const char *argv[])\n{\n    drreg_options_t ops = {sizeof(ops), 2 /*max slots needed: aflags*/, false};\n\n    dr_set_client_name(\"WinAFL\", \"https://github.com/googleprojectzero/winafl/issues\");\n\n    drmgr_init();\n    drx_init();\n    drreg_init(&ops);\n    drwrap_init();\n\n    options_init(id, argc, argv);\n\n    dr_register_exit_event(event_exit);\n\n    drmgr_register_exception_event(onexception);\n\n    if(options.coverage_kind == COVERAGE_BB) {\n        drmgr_register_bb_instrumentation_event(NULL, instrument_bb_coverage, NULL);\n    } else if(options.coverage_kind == COVERAGE_EDGE) {\n        drmgr_register_bb_instrumentation_event(NULL, instrument_edge_coverage, NULL);\n    }\n\n    drmgr_register_module_load_event(event_module_load);\n    drmgr_register_module_unload_event(event_module_unload);\n    dr_register_nudge_event(event_nudge, id);\n\n    client_id = id;\n\n    if (options.nudge_kills)\n        drx_register_soft_kills(event_soft_kill);\n\n    if(options.thread_coverage) {\n        winafl_data.fake_afl_area = (unsigned char *)dr_global_alloc(MAP_SIZE);\n    }\n\n    if(!options.debug_mode) {\n        setup_pipe();\n        setup_shmem();\n    } else {\n        winafl_data.afl_area = (unsigned char *)dr_global_alloc(MAP_SIZE);\n    }\n\n    if(options.coverage_kind == COVERAGE_EDGE || options.thread_coverage || options.dr_persist_cache) {\n        winafl_tls_field = drmgr_register_tls_field();\n        if(winafl_tls_field == -1) {\n            DR_ASSERT_MSG(false, \"error reserving TLS field\");\n        }\n        drmgr_register_thread_init_event(event_thread_init);\n        drmgr_register_thread_exit_event(event_thread_exit);\n    }\n\n    event_init();\n}\n"
        },
        {
          "name": "winaflpt-debug.c",
          "type": "blob",
          "size": 2.47265625,
          "content": "#include <stdio.h>\r\n#include <stdbool.h>\r\n#include <direct.h>\r\n#include \"windows.h\"\r\n\r\n#include \"types.h\"\r\n#include \"config.h\"\r\n#include \"debug.h\"\r\n#include \"alloc-inl.h\"\r\n\r\n#include \"winaflpt.h\"\r\n\r\nu8 *trace_bits;\r\n\r\nu8 sinkhole_stds = 0;\r\nu64 mem_limit = 0;\r\nu64 cpu_aff = 0;\r\n\r\n// todo the below functions are copied from afl-fuzz.c\r\n// they should be taken out to a separate file to avoid duplication\r\n\r\nu64 get_cur_time(void) {\r\n\r\n\tu64 ret;\r\n\tFILETIME filetime;\r\n\tGetSystemTimeAsFileTime(&filetime);\r\n\r\n\tret = (((u64)filetime.dwHighDateTime) << 32) + (u64)filetime.dwLowDateTime;\r\n\r\n\treturn ret / 10000;\r\n\r\n}\r\n\r\n//quoting on Windows is weird\r\nsize_t ArgvQuote(char *in, char *out) {\r\n\tint needs_quoting = 0;\r\n\tsize_t size = 0;\r\n\tchar *p = in;\r\n\tsize_t i;\r\n\r\n\t//check if quoting is necessary\r\n\tif (strchr(in, ' ')) needs_quoting = 1;\r\n\tif (strchr(in, '\\\"')) needs_quoting = 1;\r\n\tif (strchr(in, '\\t')) needs_quoting = 1;\r\n\tif (strchr(in, '\\n')) needs_quoting = 1;\r\n\tif (strchr(in, '\\v')) needs_quoting = 1;\r\n\tif (!needs_quoting) {\r\n\t\tsize = strlen(in);\r\n\t\tif (out) memcpy(out, in, size);\r\n\t\treturn size;\r\n\t}\r\n\r\n\tif (out) out[size] = '\\\"';\r\n\tsize++;\r\n\r\n\twhile (*p) {\r\n\t\tsize_t num_backslashes = 0;\r\n\t\twhile ((*p) && (*p == '\\\\')) {\r\n\t\t\tp++;\r\n\t\t\tnum_backslashes++;\r\n\t\t}\r\n\r\n\t\tif (*p == 0) {\r\n\t\t\tfor (i = 0; i < (num_backslashes * 2); i++) {\r\n\t\t\t\tif (out) out[size] = '\\\\';\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\telse if (*p == '\\\"') {\r\n\t\t\tfor (i = 0; i < (num_backslashes * 2 + 1); i++) {\r\n\t\t\t\tif (out) out[size] = '\\\\';\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t\tif (out) out[size] = *p;\r\n\t\t\tsize++;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (i = 0; i < num_backslashes; i++) {\r\n\t\t\t\tif (out) out[size] = '\\\\';\r\n\t\t\t\tsize++;\r\n\t\t\t}\r\n\t\t\tif (out) out[size] = *p;\r\n\t\t\tsize++;\r\n\t\t}\r\n\r\n\t\tp++;\r\n\t}\r\n\r\n\tif (out) out[size] = '\\\"';\r\n\tsize++;\r\n\r\n\treturn size;\r\n}\r\n\r\n\r\nchar *argv_to_cmd(char** argv) {\r\n\tu32 len = 0, i;\r\n\tu8* buf, *ret;\r\n\r\n\t//todo shell-escape\r\n\r\n\tfor (i = 0; argv[i]; i++)\r\n\t\tlen += ArgvQuote(argv[i], NULL) + 1;\r\n\r\n\tif (!len) FATAL(\"Error creating command line\");\r\n\r\n\tbuf = ret = ck_alloc(len);\r\n\r\n\tfor (i = 0; argv[i]; i++) {\r\n\r\n\t\tu32 l = ArgvQuote(argv[i], buf);\r\n\r\n\t\tbuf += l;\r\n\r\n\t\t*(buf++) = ' ';\r\n\t}\r\n\r\n\tret[len - 1] = 0;\r\n\r\n\treturn ret;\r\n}\r\n\r\n\r\nint main(int argc, char **argv)\r\n{\r\n\t_mkdir(\".\\\\ptmodules\");\r\n\tint target_opt_ind = pt_init(argc, argv, \".\\\\ptmodules\");\r\n\tif (!target_opt_ind) {\r\n\t\tprintf(\"Usage: %s <instrumentation-options> -- <target command line>\\n\", argv[0]);\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tdebug_target_pt(argv + target_opt_ind + 1);\r\n\r\n\treturn 0;\r\n}\r\n"
        },
        {
          "name": "winaflpt.c",
          "type": "blob",
          "size": 51.5888671875,
          "content": "/*\r\n  WinAFL - Intel PT instrumentation and presistence via debugger code \r\n  ------------------------------------------------\r\n\r\n  Written and maintained by Ivan Fratric <ifratric@google.com>\r\n\r\n  Copyright 2016 Google Inc. All Rights Reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n#define  _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <stdio.h>\r\n#include <stdbool.h>\r\n#include \"windows.h\"\r\n#include \"psapi.h\"\r\n#include \"dbghelp.h\"\r\n\r\n#include \"libipt.h\"\r\n#include \"ipttool.h\"\r\n\r\n#include \"intel-pt.h\"\r\n\r\n#include \"types.h\"\r\n#include \"config.h\"\r\n#include \"debug.h\"\r\n#include \"alloc-inl.h\"\r\n\r\n#include \"winaflpt.h\"\r\n\r\n#include \"ptdecode.h\"\r\n\r\n// tests the custom decoders gainst the corresponding\r\n// reference implementatopns from Intel\r\n// used only for debugging\r\n// #define DECODER_CORRECTNESS_TEST\r\n\r\nu64 get_cur_time(void);\r\nchar *argv_to_cmd(char** argv);\r\n\r\n#define CALLCONV_MICROSOFT_X64 0\r\n#define CALLCONV_THISCALL 1\r\n#define CALLCONV_FASTCALL 2\r\n#define CALLCONV_CDECL 3\r\n#define CALLCONV_DEFAULT 4\r\n\r\n#define BREAKPOINT_UNKNOWN 0\r\n#define BREAKPOINT_ENTRYPOINT 1\r\n#define BREAKPOINT_MODULELOADED 2\r\n#define BREAKPOINT_FUZZMETHOD 3\r\n\r\n#define WINAFL_LOOP_EXCEPTION 0x0AF1\r\n\r\n#define DEBUGGER_PROCESS_EXIT 0\r\n#define DEBUGGER_FUZZMETHOD_REACHED 1\r\n#define DEBUGGER_FUZZMETHOD_END 2\r\n#define DEBUGGER_CRASHED 3\r\n#define DEBUGGER_HANGED 4\r\n\r\n#define DECODER_TIP_FAST 0\r\n#define DECODER_TIP_REFERENCE 1\r\n#define DECODER_FULL_FAST 2\r\n#define DECODER_FULL_REFERENCE 3\r\n\r\nstatic HANDLE child_handle, child_thread_handle;\r\nstatic HANDLE devnul_handle = INVALID_HANDLE_VALUE;\r\nstatic int fuzz_iterations_current;\r\n\r\nstatic DWORD fuzz_thread_id;\r\n\r\nstatic DEBUG_EVENT dbg_debug_event;\r\nstatic DWORD dbg_continue_status;\r\nstatic bool dbg_continue_needed;\r\nstatic uint64_t dbg_timeout_time;\r\n\r\nstatic bool child_entrypoint_reached;\r\n\r\nstatic unsigned char *trace_buffer;\r\nstatic size_t trace_size;\r\n\r\nextern u8 *trace_bits;\r\n\r\nextern HANDLE child_handle, child_thread_handle;\r\nextern int fuzz_iterations_current;\r\n\r\nextern HANDLE devnul_handle;\r\nextern u8 sinkhole_stds;\r\n\r\nextern u64 mem_limit;\r\nextern u64 cpu_aff;\r\n\r\nextern char *fuzzer_id;\r\n\r\nstatic FILE *debug_log = NULL;\r\n\r\nstatic struct pt_image_section_cache *section_cache;\r\nstatic char section_cache_dir[MAX_PATH];\r\n\r\nstatic int wow64_target = 0;\r\nstatic size_t child_ptr_size = sizeof(void *);\r\n\r\naddress_range* coverage_ip_ranges = NULL;\r\nsize_t num_ip_ranges = 0;\r\nstatic bool need_build_ranges = true;\r\n\r\nstatic size_t last_ring_buffer_offset = 0;\r\n\r\n#define USAGE_CHECK(condition, message) if(!(condition)) FATAL(\"%s\\n\", message);\r\n\r\nenum {\r\n\t/* 00 */ FAULT_NONE,\r\n\t/* 01 */ FAULT_TMOUT,\r\n\t/* 02 */ FAULT_CRASH,\r\n\t/* 03 */ FAULT_ERROR,\r\n\t/* 04 */ FAULT_NOINST,\r\n\t/* 05 */ FAULT_NOBITS\r\n};\r\n\r\ntypedef struct _module_info_t {\r\n\tchar module_name[MAX_PATH];\r\n\tint isid;\r\n\tvoid *base;\r\n\tsize_t size;\r\n\tstruct _module_info_t *next;\r\n} module_info_t;\r\n\r\nstatic module_info_t *all_modules = NULL;\r\n\r\ntypedef struct _winafl_option_t {\r\n\tbool debug_mode;\r\n\tint coverage_kind;\r\n\tmodule_info_t *coverage_modules;\r\n\tchar fuzz_module[MAX_PATH];\r\n\tchar fuzz_method[MAX_PATH];\r\n\tunsigned long fuzz_offset;\r\n\tint fuzz_iterations;\r\n\tint num_fuz_args;\r\n\tint callconv;\r\n\tint decoder;\r\n\tbool thread_coverage;\r\n\tunsigned long trace_buffer_size;\r\n\tunsigned long trace_cache_size;\r\n\tbool persistent_trace;\r\n\r\n\tvoid **func_args;\r\n\tvoid *sp;\r\n\tvoid *fuzz_address;\r\n} winafl_option_t;\r\nstatic winafl_option_t options;\r\n\r\nstruct winafl_breakpoint {\r\n\tvoid *address;\r\n\tint type;\r\n\tunsigned char original_opcode;\r\n\tchar module_name[MAX_PATH];\r\n\tvoid *module_base;\r\n\tstruct winafl_breakpoint *next;\r\n};\r\nstruct winafl_breakpoint *breakpoints;\r\n\r\nstatic void\r\nwinaflpt_options_init(int argc, const char *argv[])\r\n{\r\n\tint i;\r\n\tconst char *token;\r\n\tmodule_info_t *coverage_modules;\r\n\t/* default values */\r\n\toptions.debug_mode = false;\r\n\toptions.coverage_kind = COVERAGE_BB;\r\n\toptions.coverage_modules = NULL;\r\n\toptions.fuzz_module[0] = 0;\r\n\toptions.fuzz_method[0] = 0;\r\n\toptions.fuzz_offset = 0;\r\n\toptions.fuzz_iterations = 1000;\r\n\toptions.func_args = NULL;\r\n\toptions.num_fuz_args = 0;\r\n\toptions.thread_coverage = true;\r\n\toptions.callconv = CALLCONV_DEFAULT;\r\n\toptions.decoder = DECODER_FULL_FAST;\r\n\toptions.trace_buffer_size = TRACE_BUFFER_SIZE_DEFAULT;\r\n\toptions.trace_cache_size = 0;\r\n\toptions.persistent_trace = true;\r\n\r\n\tfor (i = 0; i < argc; i++) {\r\n\t\ttoken = argv[i];\r\n\t\tif (strcmp(token, \"-thread_coverage\") == 0)\r\n\t\t\toptions.thread_coverage = true;\r\n\t\telse if (strcmp(token, \"-debug\") == 0)\r\n\t\t\toptions.debug_mode = true;\r\n\t\telse if (strcmp(token, \"-nopersistent_trace\") == 0)\r\n\t\t\toptions.persistent_trace = false;\r\n\t\telse if (strcmp(token, \"-covtype\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing coverage type\");\r\n\t\t\ttoken = argv[++i];\r\n\t\t\tif (strcmp(token, \"bb\") == 0) options.coverage_kind = COVERAGE_BB;\r\n\t\t\telse if (strcmp(token, \"edge\") == 0) options.coverage_kind = COVERAGE_EDGE;\r\n\t\t\telse USAGE_CHECK(false, \"invalid coverage type\");\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-coverage_module\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing module\");\r\n\t\t\tcoverage_modules = options.coverage_modules;\r\n\t\t\toptions.coverage_modules = (module_info_t *)malloc(sizeof(module_info_t));\r\n\t\t\toptions.coverage_modules->next = coverage_modules;\r\n\t\t\toptions.coverage_modules->isid = 0;\r\n\t\t\toptions.coverage_modules->base = NULL;\r\n\t\t\toptions.coverage_modules->size = 0;\r\n\t\t\tstrncpy(options.coverage_modules->module_name, argv[++i], MAX_PATH);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-target_module\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing module\");\r\n\t\t\tstrncpy(options.fuzz_module, argv[++i], MAX_PATH);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-target_method\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing method\");\r\n\t\t\tstrncpy(options.fuzz_method, argv[++i], MAX_PATH);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-fuzz_iterations\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing number of iterations\");\r\n\t\t\toptions.fuzz_iterations = atoi(argv[++i]);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-nargs\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing number of arguments\");\r\n\t\t\toptions.num_fuz_args = atoi(argv[++i]);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-target_offset\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing offset\");\r\n\t\t\toptions.fuzz_offset = strtoul(argv[++i], NULL, 0);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-trace_size\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing trace size\");\r\n\t\t\toptions.trace_buffer_size = strtoul(argv[++i], NULL, 0);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-trace_cache_size\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing trace cache size\");\r\n\t\t\toptions.trace_cache_size = strtoul(argv[++i], NULL, 0);\r\n\t\t}\r\n\t\telse if (strcmp(token, \"-call_convention\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing calling convention\");\r\n\t\t\t++i;\r\n\t\t\tif (strcmp(argv[i], \"stdcall\") == 0)\r\n\t\t\t\toptions.callconv = CALLCONV_CDECL;\r\n\t\t\telse if (strcmp(argv[i], \"fastcall\") == 0)\r\n\t\t\t\toptions.callconv = CALLCONV_FASTCALL;\r\n\t\t\telse if (strcmp(argv[i], \"thiscall\") == 0)\r\n\t\t\t\toptions.callconv = CALLCONV_THISCALL;\r\n\t\t\telse if (strcmp(argv[i], \"ms64\") == 0)\r\n\t\t\t\toptions.callconv = CALLCONV_MICROSOFT_X64;\r\n\t\t\telse\r\n\t\t\t\tFATAL(\"Unknown calling convention\");\r\n\t\t} else if (strcmp(token, \"-decoder\") == 0) {\r\n\t\t\tUSAGE_CHECK((i + 1) < argc, \"missing decoder\");\r\n\t\t\t++i;\r\n\t\t\tif (strcmp(argv[i], \"tip\") == 0)\r\n\t\t\t\toptions.decoder = DECODER_TIP_FAST;\r\n\t\t\telse if (strcmp(argv[i], \"tip_ref\") == 0)\r\n\t\t\t\toptions.decoder = DECODER_TIP_REFERENCE;\r\n\t\t\telse if (strcmp(argv[i], \"full\") == 0)\r\n\t\t\t\toptions.decoder = DECODER_FULL_FAST;\r\n\t\t\telse if (strcmp(argv[i], \"full_ref\") == 0)\r\n\t\t\t\toptions.decoder = DECODER_FULL_REFERENCE;\r\n\t\t\telse\r\n\t\t\t\tFATAL(\"Unknown decoder value\");\r\n\t\t} else {\r\n\t\t\tFATAL(\"UNRECOGNIZED OPTION: \\\"%s\\\"\\n\", token);\r\n\t\t}\r\n\t}\r\n\r\n\tif (options.fuzz_module[0] && (options.fuzz_offset == 0) && (options.fuzz_method[0] == 0)) {\r\n\t\tFATAL(\"If fuzz_module is specified, then either fuzz_method or fuzz_offset must be as well\");\r\n\t}\r\n\r\n\tif (options.num_fuz_args) {\r\n\t\toptions.func_args = (void **)malloc(options.num_fuz_args * sizeof(void *));\r\n\t}\r\n}\r\n\r\nint address_range_compare(const void * a, const void * b) {\r\n\tif (((address_range *)a)->start >= ((address_range *)b)->start) return 1;\r\n\telse return -1;\r\n}\r\n\r\nvoid build_address_ranges() {\r\n\tint num_loaded_modules;\r\n\tmodule_info_t *current_module;\r\n\r\n\tif (coverage_ip_ranges) free(coverage_ip_ranges);\r\n\r\n\tif (!options.coverage_modules) {\r\n\t\tnum_ip_ranges = 1;\r\n\t\tcoverage_ip_ranges = (address_range*)malloc(num_ip_ranges * sizeof(address_range));\r\n\t\tcoverage_ip_ranges[0].start = 0;\r\n\t\tcoverage_ip_ranges[0].end = 0xFFFFFFFFFFFFFFFFULL;\r\n\t\tcoverage_ip_ranges[0].collect = 1;\r\n\t\treturn;\r\n\t}\r\n\t\r\n\t// count loaded modules\r\n\tnum_loaded_modules = 0;\r\n\tcurrent_module = options.coverage_modules;\r\n\twhile (current_module) {\r\n\t\tif (current_module->size > 0) {\r\n\t\t\tnum_loaded_modules++;\r\n\t\t}\r\n\t\tcurrent_module = current_module->next;\r\n\t}\r\n\r\n\taddress_range* tmp_buf = (address_range*)malloc(num_loaded_modules * sizeof(address_range));\r\n\r\n\tnum_loaded_modules = 0;\r\n\tcurrent_module = options.coverage_modules;\r\n\twhile (current_module) {\r\n\t\tif (current_module->size > 0) {\r\n\t\t\ttmp_buf[num_loaded_modules].start = (uint64_t)current_module->base;\r\n\t\t\ttmp_buf[num_loaded_modules].end = (uint64_t)current_module->base + current_module->size - 1;\r\n\t\t\ttmp_buf[num_loaded_modules].collect = 1;\r\n\t\t\tnum_loaded_modules++;\r\n\t\t}\r\n\t\tcurrent_module = current_module->next;\r\n\t}\r\n\r\n\tqsort(tmp_buf, num_loaded_modules, sizeof(address_range), address_range_compare);\r\n\r\n\tnum_ip_ranges = (size_t)num_loaded_modules * 2 + 1;\r\n\tcoverage_ip_ranges = (address_range*)malloc(num_ip_ranges * sizeof(address_range));\r\n\r\n\tuint64_t current_address = 0;\r\n\tfor (int i = 0; i < num_loaded_modules; i++) {\r\n\t\tcoverage_ip_ranges[2 * i].start = current_address;\r\n\t\tcoverage_ip_ranges[2 * i].end = tmp_buf[i].start - 1;\r\n\t\tcoverage_ip_ranges[2 * i].collect = 0;\r\n\t\tcoverage_ip_ranges[2 * i + 1] = tmp_buf[i];\r\n\t\tcurrent_address = tmp_buf[i].end + 1;\r\n\t}\r\n\tcoverage_ip_ranges[2 * num_loaded_modules].start = current_address;\r\n\tcoverage_ip_ranges[2 * num_loaded_modules].end = 0xFFFFFFFFFFFFFFFFULL;\r\n\tcoverage_ip_ranges[2 * num_loaded_modules].collect = 0;\r\n\r\n\tfree(tmp_buf);\r\n}\r\n\r\n// appends new data to the trace_buffer\r\nvoid append_trace_data(unsigned char *trace_data, size_t append_size) {\r\n\tsize_t space_left = options.trace_buffer_size - trace_size;\r\n\r\n\tif (!space_left) {\r\n\t\t// stop collecting trace if the trace buffer is full;\r\n\t\tprintf(\"Warning: Trace buffer is full\\n\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (append_size > space_left) {\r\n\t\tappend_size = space_left;\r\n\t}\r\n\r\n\tif (append_size == 0) return;\r\n\r\n\tmemcpy(trace_buffer + trace_size, trace_data, append_size);\r\n\ttrace_size += append_size;\r\n}\r\n\r\n\r\n// returns true if the ring buffer was overflowed\r\nbool collect_thread_trace(PIPT_TRACE_HEADER traceHeader) {\r\n\t// printf(\"ring offset: %u\\n\", traceHeader->RingBufferOffset);\r\n\r\n\tbool trace_buffer_overflow = false;\r\n\r\n\tunsigned char psb_and_psbend[] = {\r\n\t\t0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,\r\n\t\t0x02, 0x82, 0x02, 0x82, 0x02, 0x82, 0x02, 0x82,\r\n\t\t0x02, 0x23\r\n\t};\r\n\r\n\ttrace_size = 0;\r\n\r\n\tif (options.persistent_trace) {\r\n\r\n\t\t// an ugly hack: trace might not start with a psb (synchronization) packet\r\n\t\t// so we are just adding one. This assumes the state has been properly\r\n\t\t// flushed when a breakpoint between two iterations has been hit\r\n\t\t// which does appear to be the case. However, if this doesn't occur\r\n\t\t// persistent tracing will not work properly\r\n\t\tappend_trace_data(psb_and_psbend, sizeof(psb_and_psbend));\r\n\r\n\t\t// first, optimistically assume the buffer didn't overflow\r\n\t\tif (traceHeader->RingBufferOffset > last_ring_buffer_offset) {\r\n\t\t\tappend_trace_data(traceHeader->Trace + last_ring_buffer_offset, traceHeader->RingBufferOffset - last_ring_buffer_offset);\r\n\t\t}\r\n\t\telse if (traceHeader->RingBufferOffset < last_ring_buffer_offset) {\r\n\t\t\tappend_trace_data(traceHeader->Trace + last_ring_buffer_offset, traceHeader->TraceSize - last_ring_buffer_offset);\r\n\t\t\tappend_trace_data(traceHeader->Trace, traceHeader->RingBufferOffset);\r\n\t\t}\r\n\r\n\t\tif (!check_trace_start(trace_buffer, trace_size, (uint64_t)options.fuzz_address)) {\r\n\t\t\t// most likely the ring buffer overflowd, extract what we can (trace tail)\r\n\r\n\t\t\ttrace_size = 0;\r\n\t\t\ttrace_buffer_overflow = true;\r\n\r\n\t\t\tprintf(\"Warning: Trace buffer overflowed, trace will be truncated\\n\");\r\n\t\t\tif (options.debug_mode) fprintf(debug_log, \"Trace buffer overflowed, trace will be truncated\\n\");\r\n\r\n\t\t\tchar *trailing_data = traceHeader->Trace + traceHeader->RingBufferOffset;\r\n\t\t\tsize_t trailing_size = traceHeader->TraceSize - traceHeader->RingBufferOffset;\r\n\t\t\tappend_trace_data(trailing_data, trailing_size);\r\n\r\n\t\t\tappend_trace_data(traceHeader->Trace, traceHeader->RingBufferOffset);\r\n\r\n\t\t}\r\n\r\n\t\tlast_ring_buffer_offset = traceHeader->RingBufferOffset;\r\n\r\n\t} else {\r\n\r\n\t\t// check if the trace buffer overflowed\r\n\r\n\t\tchar *trailing_data = traceHeader->Trace + traceHeader->RingBufferOffset;\r\n\t\tsize_t trailing_size = traceHeader->TraceSize - traceHeader->RingBufferOffset;\r\n\t\tif (findpsb(&trailing_data, &trailing_size)) {\r\n\t\t\ttrace_buffer_overflow = true;\r\n\t\t\tprintf(\"Warning: Trace buffer overflowed, trace will be truncated\\n\");\r\n\t\t\tif (options.debug_mode) fprintf(debug_log, \"Trace buffer overflowed, trace will be truncated\\n\");\r\n\t\t\tappend_trace_data(trailing_data, trailing_size);\r\n\t\t}\r\n\r\n\t\tappend_trace_data(traceHeader->Trace, traceHeader->RingBufferOffset);\r\n\t}\r\n\r\n\treturn trace_buffer_overflow;\r\n}\r\n\r\n// parse PIPT_TRACE_DATA, extract trace bits and add them to the trace_buffer\r\n// returns true if the trace ring buffer overflowed\r\nbool collect_trace(PIPT_TRACE_DATA pTraceData)\r\n{\r\n\tbool trace_buffer_overflow = false;\r\n\r\n\tPIPT_TRACE_HEADER traceHeader;\r\n\tDWORD dwTraceSize;\r\n\r\n\tdwTraceSize = pTraceData->TraceSize;\r\n\r\n\ttraceHeader = (PIPT_TRACE_HEADER)pTraceData->TraceData;\r\n\r\n\twhile (dwTraceSize > (unsigned)(FIELD_OFFSET(IPT_TRACE_HEADER, Trace))) {\r\n\t\tif (traceHeader->ThreadId == fuzz_thread_id) {\r\n\t\t\ttrace_buffer_overflow = collect_thread_trace(traceHeader);\r\n\t\t}\r\n\r\n\t\tdwTraceSize -= (FIELD_OFFSET(IPT_TRACE_HEADER, Trace) + traceHeader->TraceSize);\r\n\r\n\t\ttraceHeader = (PIPT_TRACE_HEADER)(traceHeader->Trace +\r\n\t\t\ttraceHeader->TraceSize);\r\n\t}\r\n\r\n\treturn trace_buffer_overflow;\r\n}\r\n\r\n// returns an array of handles for all modules loaded in the target process\r\nDWORD get_all_modules(HMODULE **modules) {\r\n\tDWORD module_handle_storage_size = 1024 * sizeof(HMODULE);\r\n\tHMODULE *module_handles = (HMODULE *)malloc(module_handle_storage_size);\r\n\tDWORD hmodules_size;\r\n\twhile (true) {\r\n\t\tif (!EnumProcessModulesEx(child_handle, module_handles, module_handle_storage_size, &hmodules_size, LIST_MODULES_ALL)) {\r\n\t\t\tFATAL(\"EnumProcessModules failed, %x\\n\", GetLastError());\r\n\t\t}\r\n\t\tif (hmodules_size <= module_handle_storage_size) break;\r\n\t\tmodule_handle_storage_size *= 2;\r\n\t\tmodule_handles = (HMODULE *)realloc(module_handles, module_handle_storage_size);\r\n\t}\r\n\t*modules = module_handles;\r\n\treturn hmodules_size / sizeof(HMODULE);\r\n}\r\n\r\n// parses PE headers and gets the module entypoint\r\nvoid *get_entrypoint(void *base_address) {\r\n\tunsigned char headers[4096];\r\n\tsize_t num_read = 0;\r\n\tif (!ReadProcessMemory(child_handle, base_address, headers, 4096, &num_read) || (num_read != 4096)) {\r\n\t\tFATAL(\"Error reading target memory\\n\");\r\n\t}\r\n\tDWORD pe_offset;\r\n\tpe_offset = *((DWORD *)(headers + 0x3C));\r\n\tchar *pe = headers + pe_offset;\r\n\tDWORD signature = *((DWORD *)pe);\r\n\tif (signature != 0x00004550) {\r\n\t\tFATAL(\"PE signature error\\n\");\r\n\t}\r\n\tpe = pe + 0x18;\r\n\tWORD magic = *((WORD *)pe);\r\n\tif ((magic != 0x10b) && (magic != 0x20b)) {\r\n\t\tFATAL(\"Unknown PE magic value\\n\");\r\n\t} \r\n\tDWORD entrypoint_offset = *((DWORD *)(pe + 16));\r\n\tif (entrypoint_offset == 0) return NULL;\r\n\treturn (char *)base_address + entrypoint_offset;\r\n}\r\n\r\n// adds a breakpoint at a specified address\r\n// type, module_name and module_base are all additional information\r\n// that can be accessed later when the breakpoint gets hit\r\nvoid add_breakpoint(void *address, int type, char *module_name, void *module_base) {\r\n\tstruct winafl_breakpoint *new_breakpoint = (struct winafl_breakpoint *)malloc(sizeof(struct winafl_breakpoint));\r\n\tsize_t rwsize = 0;\r\n\tif(!ReadProcessMemory(child_handle, address, &(new_breakpoint->original_opcode), 1, &rwsize) || (rwsize != 1)) {\r\n\t\tFATAL(\"Error reading target memory\\n\");\r\n\t}\r\n\trwsize = 0;\t\r\n\tunsigned char cc = 0xCC;\r\n\tif (!WriteProcessMemory(child_handle, address, &cc, 1, &rwsize) || (rwsize != 1)) {\r\n\t\tFATAL(\"Error writing target memory\\n\");\r\n\t}\r\n\tFlushInstructionCache(child_handle, address, 1);\r\n\tnew_breakpoint->address = address;\r\n\tnew_breakpoint->type = type;\r\n\tif (module_name) {\r\n\t\tstrcpy(new_breakpoint->module_name, module_name);\r\n\t} else {\r\n\t\tnew_breakpoint->module_name[0] = 0;\r\n\t}\r\n\tnew_breakpoint->module_base = module_base;\r\n\tnew_breakpoint->next = breakpoints;\r\n\tbreakpoints = new_breakpoint;\r\n}\r\n\r\n\r\n// damn it Windows, why don't you have a GetProcAddress\r\n// that works on another process\r\nDWORD get_proc_offset(char *data, char *name) {\r\n\tDWORD pe_offset;\r\n\tpe_offset = *((DWORD *)(data + 0x3C));\r\n\tchar *pe = data + pe_offset;\r\n\tDWORD signature = *((DWORD *)pe);\r\n\tif (signature != 0x00004550) {\r\n\t\treturn 0;\r\n\t}\r\n\tpe = pe + 0x18;\r\n\tWORD magic = *((WORD *)pe);\r\n\tDWORD exporttableoffset;\r\n\tif (magic == 0x10b) {\r\n\t\texporttableoffset = *(DWORD *)(pe + 96);\r\n\t} else if (magic == 0x20b) {\r\n\t\texporttableoffset = *(DWORD *)(pe + 112);\r\n\t} else {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!exporttableoffset) return 0;\r\n\tchar *exporttable = data + exporttableoffset;\r\n\r\n\tDWORD numentries = *(DWORD *)(exporttable + 24);\r\n\tDWORD addresstableoffset = *(DWORD *)(exporttable + 28);\r\n\tDWORD nameptrtableoffset = *(DWORD *)(exporttable + 32);\r\n\tDWORD ordinaltableoffset = *(DWORD *)(exporttable + 36);\r\n\tDWORD *nameptrtable = (DWORD *)(data + nameptrtableoffset);\r\n\tWORD *ordinaltable = (WORD *)(data + ordinaltableoffset);\r\n\tDWORD *addresstable = (DWORD *)(data + addresstableoffset);\r\n\r\n\tDWORD i;\r\n\tfor (i = 0; i < numentries; i++) {\r\n\t\tchar *nameptr = data + nameptrtable[i];\r\n\t\tif (strcmp(name, nameptr) == 0) break;\r\n\t}\r\n\r\n\tif (i == numentries) return 0;\r\n\r\n\tWORD oridnal = ordinaltable[i];\r\n\tDWORD offset = addresstable[oridnal];\r\n\r\n\treturn offset;\r\n}\r\n\r\n// attempt to obtain the fuzz_offset in various ways\r\nchar *get_fuzz_method_offset(HMODULE module) {\r\n\tMODULEINFO module_info;\r\n\tGetModuleInformation(child_handle, module, &module_info, sizeof(module_info));\r\n\r\n\t// if fuzz_offset is defined, use that\r\n\tif (options.fuzz_offset) {\r\n\t\treturn (char *)module_info.lpBaseOfDll + options.fuzz_offset;\r\n\t}\r\n\r\n\t// try the exported symbols next\r\n\tBYTE *modulebuf = (BYTE *)malloc(module_info.SizeOfImage);\r\n\tsize_t num_read;\r\n\tif (!ReadProcessMemory(child_handle, module_info.lpBaseOfDll, modulebuf, module_info.SizeOfImage, &num_read) || (num_read != module_info.SizeOfImage)) {\r\n\t\tFATAL(\"Error reading target memory\\n\");\r\n\t}\r\n\tDWORD fuzz_offset = get_proc_offset(modulebuf, options.fuzz_method);\r\n\tfree(modulebuf);\r\n\tif (fuzz_offset) {\r\n\t\treturn (char *)module + fuzz_offset;\r\n\t}\r\n\r\n\t// finally, try the debug symbols\r\n\tchar *fuzz_method = NULL;\r\n\tchar base_name[MAX_PATH];\r\n\tGetModuleBaseNameA(child_handle, module, (LPSTR)(&base_name), sizeof(base_name));\r\n\r\n\tchar module_path[MAX_PATH];\r\n\tif(!GetModuleFileNameExA(child_handle, module, module_path, sizeof(module_path))) return NULL;\r\n\t\r\n\tULONG64 buffer[(sizeof(SYMBOL_INFO) +\r\n\t\tMAX_SYM_NAME * sizeof(TCHAR) +\r\n\t\tsizeof(ULONG64) - 1) /\r\n\t\tsizeof(ULONG64)];\r\n\tPSYMBOL_INFO pSymbol = (PSYMBOL_INFO)buffer;\r\n\tpSymbol->SizeOfStruct = sizeof(SYMBOL_INFO);\r\n\tpSymbol->MaxNameLen = MAX_SYM_NAME;\r\n\tSymInitialize(child_handle, NULL, false);\r\n\tDWORD64 sym_base_address = SymLoadModuleEx(child_handle, NULL, module_path, NULL, 0, 0, NULL, 0);\r\n\tif (SymFromName(child_handle, options.fuzz_method, pSymbol)) {\r\n\t\toptions.fuzz_offset = (unsigned long)(pSymbol->Address - sym_base_address);\r\n\t\tfuzz_method = (char *)module_info.lpBaseOfDll + options.fuzz_offset;\r\n\t}\r\n\tSymCleanup(child_handle);\r\n\r\n\treturn fuzz_method;\r\n}\r\n\r\n// should we collect coverage for this module\r\nmodule_info_t *is_coverage_module(char *module_name) {\r\n\tmodule_info_t *current_module = options.coverage_modules;\r\n\twhile (current_module) {\r\n\t\tif (_stricmp(module_name, current_module->module_name) == 0) {\r\n\t\t\treturn current_module;\r\n\t\t}\r\n\t\tcurrent_module = current_module->next;\r\n\t}\r\n\treturn NULL;\r\n}\r\n\r\n// check if the same module was already loaded\r\nmodule_info_t *get_loaded_module(char *module_name, void *base) {\r\n\tmodule_info_t *current_module = all_modules;\r\n\twhile (current_module) {\r\n\t\tif (_stricmp(module_name, current_module->module_name) == 0) {\r\n\t\t\tif (base == NULL || base == current_module->base) {\r\n\t\t\t\treturn current_module;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcurrent_module = current_module->next;\r\n\t}\r\n\treturn NULL;\r\n}\r\n\r\n// find if there is a *different* module that previously occupied\r\n// the same space\r\nmodule_info_t *get_intersecting_module(char *module_name, void *base, DWORD size) {\r\n\tmodule_info_t *current_module = all_modules;\r\n\twhile (current_module) {\r\n\t\tif (((uint64_t)current_module->base + current_module->size <= (uint64_t)base) || \r\n\t\t\t((uint64_t)base + size <= (uint64_t)current_module->base)) {\r\n\t\t\tcurrent_module = current_module->next;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\treturn current_module;\r\n\t}\r\n\treturn NULL;\r\n}\r\n\r\n\r\nvoid on_coverage_module_loaded(HMODULE module, module_info_t *target_module) {\r\n\tMODULEINFO module_info;\r\n\tGetModuleInformation(child_handle, module, &module_info, sizeof(module_info));\r\n\r\n\ttarget_module->base = module_info.lpBaseOfDll;\r\n\ttarget_module->size = module_info.SizeOfImage;\r\n\r\n\tneed_build_ranges = true;\r\n}\r\n\r\nsize_t ReadProcessMemory_tolerant(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize) {\r\n\tLPCVOID end_address = (char *)lpBaseAddress + nSize;\r\n\tLPCVOID cur_address = lpBaseAddress;\r\n\tMEMORY_BASIC_INFORMATION meminfobuf;\r\n\tsize_t size_read;\r\n\tsize_t total_size_read = 0;\r\n\r\n\twhile (cur_address < end_address) {\r\n\t\tsize_t ret = VirtualQueryEx(hProcess, (LPCVOID)cur_address, &meminfobuf, sizeof(MEMORY_BASIC_INFORMATION));\r\n\t\tif (!ret) break;\r\n\r\n\t\tsize_t offset = (size_t)meminfobuf.BaseAddress - (size_t)lpBaseAddress;\r\n\t\tsize_t to_read = meminfobuf.RegionSize;\r\n\t\tif ((offset + to_read) > nSize) {\r\n\t\t\tto_read = nSize - offset;\r\n\t\t}\r\n\r\n\t\tif (ReadProcessMemory(child_handle, meminfobuf.BaseAddress, (char *)lpBuffer + offset, to_read, &size_read)) {\r\n\t\t\ttotal_size_read += size_read;\r\n\t\t}\r\n\r\n\t\tcur_address = (char *)meminfobuf.BaseAddress + meminfobuf.RegionSize;\r\n\t}\r\n\r\n\treturn total_size_read;\r\n}\r\n\r\nvoid add_module_to_section_cache(HMODULE module, char *module_name) {\r\n\tmodule_info_t *loaded_module;\r\n\tMODULEINFO module_info;\r\n\tGetModuleInformation(child_handle, module, &module_info, sizeof(module_info));\r\n\r\n\t// handle the case where module was loaded previously\r\n\tloaded_module = get_loaded_module(module_name, module_info.lpBaseOfDll);\r\n\tif (loaded_module) {\r\n\t\t// same module loaded on the same address, skip\r\n\t\treturn;\r\n\t}\r\n\r\n\t// this will *probably* never happen but check for it anyway\r\n\tloaded_module = get_intersecting_module(module_name, module_info.lpBaseOfDll, module_info.SizeOfImage);\r\n\tif (loaded_module) {\r\n\t\tFATAL(\"Module %s loaded in the address range that module %s previously occupied. This is currently unsupported.\",\r\n\t\t\tmodule_name, loaded_module->module_name);\r\n\t}\r\n\r\n\tloaded_module = (module_info_t *)malloc(sizeof(module_info_t));\r\n\tstrcpy(loaded_module->module_name, module_name);\r\n\tloaded_module->base = module_info.lpBaseOfDll;\r\n\tloaded_module->size = module_info.SizeOfImage;\r\n\r\n\t// todo put these files in a separate directory and clean it periodically\r\n\tchar tmpfilename[MAX_PATH];\r\n\tsprintf(tmpfilename, \"%s\\\\sectioncache_%p.dat\", section_cache_dir, module_info.lpBaseOfDll);\r\n\r\n\tBYTE *modulebuf = (BYTE *)malloc(module_info.SizeOfImage);\r\n\tsize_t num_read;\r\n\tif (!ReadProcessMemory(child_handle, module_info.lpBaseOfDll, modulebuf, module_info.SizeOfImage, &num_read) || (num_read != module_info.SizeOfImage)) {\r\n\t\tif (!ReadProcessMemory_tolerant(child_handle, module_info.lpBaseOfDll, modulebuf, module_info.SizeOfImage)) {\r\n\t\t\tFATAL(\"Error reading memory for module %s\", module_name);\r\n\t\t}\r\n\t}\r\n\r\n\t// this is pretty horrible, writing a file only to be read again\r\n\t// but libipt only supports reading sections from file, not memory\r\n\tFILE *fp = fopen(tmpfilename, \"wb\");\r\n\tif (!fp) {\r\n\t\tFATAL(\"Error opening image cache file.\");\r\n\t}\r\n\tfwrite(modulebuf, 1, module_info.SizeOfImage, fp);\r\n\tfclose(fp);\r\n\r\n\tloaded_module->isid = pt_iscache_add_file(section_cache, tmpfilename, 0, module_info.SizeOfImage, (uint64_t)module_info.lpBaseOfDll);\r\n\r\n\tfree(modulebuf);\r\n\r\n\tif (loaded_module->isid <= 0) {\r\n\t\tFATAL(\"Error adding file to pt cache.\");\r\n\t}\r\n\r\n\tloaded_module->next = all_modules;\r\n\tall_modules = loaded_module;\r\n}\r\n\r\n// called when a potentialy interesting module gets loaded\r\nvoid on_module_loaded(HMODULE module, char *module_name) {\r\n\tMODULEINFO module_info;\r\n\tGetModuleInformation(child_handle, module, &module_info, sizeof(module_info));\r\n\t// printf(\"In on_module_loaded, name: %s, base: %p\\n\", module_name, module_info.lpBaseOfDll);\r\n\r\n\tmodule_info_t *coverage_module = is_coverage_module(module_name);\r\n\tif (coverage_module) {\r\n\t\ton_coverage_module_loaded(module, coverage_module);\r\n\t}\r\n\r\n\tif (options.decoder == DECODER_FULL_FAST || options.decoder == DECODER_FULL_REFERENCE) {\r\n\t\tadd_module_to_section_cache(module, module_name);\r\n\t}\r\n\r\n\tif (_stricmp(module_name, options.fuzz_module) == 0) {\r\n\t\tchar * fuzz_address = get_fuzz_method_offset(module);\r\n\t\tif (!fuzz_address) {\r\n\t\t\tFATAL(\"Error determining target method address\\n\");\r\n\t\t}\r\n\r\n\t\t// printf(\"Fuzz method address: %p\\n\", fuzz_address);\r\n\t\toptions.fuzz_address = fuzz_address;\r\n\r\n\t\tadd_breakpoint(fuzz_address, BREAKPOINT_FUZZMETHOD, NULL, 0);\r\n\t}\r\n}\r\n\r\nvoid read_stack(void *stack_addr, void **buffer, size_t numitems) {\r\n\tsize_t numrw = 0;\r\n#ifdef _WIN64\r\n\tif (wow64_target) {\r\n\t\tuint32_t *buf32 = (uint32_t *)malloc(numitems * child_ptr_size);\r\n\t\tReadProcessMemory(child_handle, stack_addr, buf32, numitems * child_ptr_size, &numrw);\r\n\t\tfor (size_t i = 0; i < numitems; i++) {\r\n\t\t\tbuffer[i] = (void *)((size_t)buf32[i]);\r\n\t\t}\r\n\t\tfree(buf32);\r\n\t\treturn;\r\n\t}\r\n#endif\r\n\tReadProcessMemory(child_handle, stack_addr, buffer, numitems * child_ptr_size, &numrw);\r\n}\r\n\r\nvoid write_stack(void *stack_addr, void **buffer, size_t numitems) {\r\n\tsize_t numrw = 0;\r\n#ifdef _WIN64\r\n\tif (wow64_target) {\r\n\t\tuint32_t *buf32 = (uint32_t *)malloc(numitems * child_ptr_size);\r\n\t\tfor (size_t i = 0; i < numitems; i++) {\r\n\t\t\tbuf32[i] = (uint32_t)((size_t)buffer[i]);\r\n\t\t}\r\n\t\tWriteProcessMemory(child_handle, stack_addr, buf32, numitems * child_ptr_size, &numrw);\r\n\t\tfree(buf32);\r\n\t\treturn;\r\n\t}\r\n#endif\r\n\tWriteProcessMemory(child_handle, stack_addr, buffer, numitems * child_ptr_size, &numrw);\r\n}\r\n\r\n// called when the target method is called *for the first time only*\r\nvoid on_target_method(DWORD thread_id) {\r\n\t// printf(\"in OnTargetMethod\\n\");\r\n\r\n\tfuzz_thread_id = thread_id;\r\n\r\n\tsize_t numrw = 0;\r\n\r\n\tCONTEXT lcContext;\r\n\tlcContext.ContextFlags = CONTEXT_ALL;\r\n\tHANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_id);\r\n\tGetThreadContext(thread_handle, &lcContext);\r\n\r\n\t// read out and save the params\r\n#ifdef _WIN64\r\n\toptions.sp = (void *)lcContext.Rsp;\r\n#else\r\n\toptions.sp = (void *)lcContext.Esp;\r\n#endif\r\n\r\n\tswitch (options.callconv) {\r\n#ifdef _WIN64\r\n\tcase CALLCONV_DEFAULT:\r\n\tcase CALLCONV_MICROSOFT_X64:\r\n\t\tif (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Rcx;\r\n\t\tif (options.num_fuz_args > 1) options.func_args[1] = (void *)lcContext.Rdx;\r\n\t\tif (options.num_fuz_args > 2) options.func_args[2] = (void *)lcContext.R8;\r\n\t\tif (options.num_fuz_args > 3) options.func_args[3] = (void *)lcContext.R9;\r\n\t\tif (options.num_fuz_args > 4) {\r\n\t\t\tread_stack((void *)(lcContext.Rsp + 5 * child_ptr_size), options.func_args + 4, options.num_fuz_args - 4);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_CDECL:\r\n\t\tif (options.num_fuz_args > 0) {\r\n\t\t\tread_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args, options.num_fuz_args);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_FASTCALL:\r\n\t\tif (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Rcx;\r\n\t\tif (options.num_fuz_args > 1) options.func_args[1] = (void *)lcContext.Rdx;\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\tread_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_THISCALL:\r\n\t\tif (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Rcx;\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\tread_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);\r\n\t\t}\r\n\t\tbreak;\r\n#else\r\n\tcase CALLCONV_MICROSOFT_X64:\r\n\t\tFATAL(\"X64 callong convention not supported for 32-bit targets\");\r\n\t\tbreak;\r\n\tcase CALLCONV_DEFAULT:\r\n\tcase CALLCONV_CDECL:\r\n\t\tif (options.num_fuz_args > 0) {\r\n\t\t\tread_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args, options.num_fuz_args);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_FASTCALL:\r\n\t\tif (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Ecx;\r\n\t\tif (options.num_fuz_args > 1) options.func_args[1] = (void *)lcContext.Edx;\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\tread_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_THISCALL:\r\n\t\tif (options.num_fuz_args > 0) options.func_args[0] = (void *)lcContext.Ecx;\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\tread_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);\r\n\t\t}\r\n\t\tbreak;\r\n#endif\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\t// todo store any target-specific additional context here\r\n\r\n\t// modify the return address on the stack so that an exception is triggered\r\n\t// when the target function finishes executing\r\n\t// another option would be to allocate a block of executable memory\r\n\t// and point return address over there, but this is quicker\r\n\tsize_t return_address = WINAFL_LOOP_EXCEPTION;\r\n\tWriteProcessMemory(child_handle, options.sp, &return_address, child_ptr_size, &numrw);\r\n\r\n\tCloseHandle(thread_handle);\r\n}\r\n\r\n// called every time the target method returns\r\nvoid on_target_method_ended(DWORD thread_id) {\r\n\t// printf(\"in OnTargetMethodEnded\\n\");\r\n\r\n\tCONTEXT lcContext;\r\n\tlcContext.ContextFlags = CONTEXT_ALL;\r\n\tHANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_id);\r\n\tGetThreadContext(thread_handle, &lcContext);\r\n\r\n\t// restore params\r\n#ifdef _WIN64\r\n\tlcContext.Rip = (size_t)options.fuzz_address;\r\n\tlcContext.Rsp = (size_t)options.sp;\r\n#else\r\n\tlcContext.Eip = (size_t)options.fuzz_address;\r\n\tlcContext.Esp = (size_t)options.sp;\r\n#endif\r\n\r\n\tswitch (options.callconv) {\r\n#ifdef _WIN64\r\n\tcase CALLCONV_DEFAULT:\r\n\tcase CALLCONV_MICROSOFT_X64:\r\n\t\tif (options.num_fuz_args > 0) lcContext.Rcx = (size_t)options.func_args[0];\r\n\t\tif (options.num_fuz_args > 1) lcContext.Rdx = (size_t)options.func_args[1];\r\n\t\tif (options.num_fuz_args > 2) lcContext.R8 = (size_t)options.func_args[2];\r\n\t\tif (options.num_fuz_args > 3) lcContext.R9 = (size_t)options.func_args[3];\r\n\t\tif (options.num_fuz_args > 4) {\r\n\t\t\twrite_stack((void *)(lcContext.Rsp + 5 * child_ptr_size), options.func_args + 4, options.num_fuz_args - 4);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_CDECL:\r\n\t\tif (options.num_fuz_args > 0) {\r\n\t\t\twrite_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args, options.num_fuz_args);\r\n\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_FASTCALL:\r\n\t\tif (options.num_fuz_args > 0) lcContext.Rcx = (size_t)options.func_args[0];\r\n\t\tif (options.num_fuz_args > 1) lcContext.Rdx = (size_t)options.func_args[1];\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\twrite_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_THISCALL:\r\n\t\tif (options.num_fuz_args > 0) lcContext.Rcx = (size_t)options.func_args[0];\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\twrite_stack((void *)(lcContext.Rsp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);\r\n\t\t}\r\n\t\tbreak;\r\n#else\r\n\tcase CALLCONV_MICROSOFT_X64:\r\n\t\tFATAL(\"X64 callong convention not supported for 32-bit targets\");\r\n\t\tbreak;\r\n\tcase CALLCONV_DEFAULT:\r\n\tcase CALLCONV_CDECL:\r\n\t\tif (options.num_fuz_args > 0) {\r\n\t\t\twrite_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args, options.num_fuz_args);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_FASTCALL:\r\n\t\tif (options.num_fuz_args > 0) lcContext.Ecx = (size_t)options.func_args[0];\r\n\t\tif (options.num_fuz_args > 1) lcContext.Edx = (size_t)options.func_args[1];\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\twrite_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 2, options.num_fuz_args - 2);\r\n\t\t}\r\n\t\tbreak;\r\n\tcase CALLCONV_THISCALL:\r\n\t\tif (options.num_fuz_args > 0) lcContext.Ecx = (size_t)options.func_args[0];\r\n\t\tif (options.num_fuz_args > 3) {\r\n\t\t\twrite_stack((void *)(lcContext.Esp + child_ptr_size), options.func_args + 1, options.num_fuz_args - 1);\r\n\t\t}\r\n\t\tbreak;\r\n#endif\r\n\tdefault:\r\n\t\tbreak;\r\n\t}\r\n\r\n\t// todo restore any target-specific additional context here\r\n\r\n\tSetThreadContext(thread_handle, &lcContext);\r\n\tCloseHandle(thread_handle);\r\n}\r\n\r\n// called when process entrypoint gets reached\r\nvoid on_entrypoint() {\r\n\t// printf(\"Entrypoint\\n\");\r\n\r\n\tHMODULE *module_handles = NULL;\r\n\tDWORD num_modules = get_all_modules(&module_handles);\r\n\tfor (DWORD i = 0; i < num_modules; i++) {\r\n\t\tchar base_name[MAX_PATH];\r\n\t\tGetModuleBaseNameA(child_handle, module_handles[i], (LPSTR)(&base_name), sizeof(base_name));\r\n\t\tif(options.debug_mode) fprintf(debug_log, \"Module loaded: %s\\n\", base_name);\r\n\t\ton_module_loaded(module_handles[i], base_name);\r\n\t}\r\n\tif(module_handles) free(module_handles);\r\n\r\n\tchild_entrypoint_reached = true;\r\n}\r\n\r\n// called when the debugger hits a breakpoint\r\nint handle_breakpoint(void *address, DWORD thread_id) {\r\n\tint ret = BREAKPOINT_UNKNOWN;\r\n\tsize_t rwsize = 0;\r\n\tstruct winafl_breakpoint *previous = NULL;\r\n\tstruct winafl_breakpoint *current = breakpoints;\r\n\twhile (current) {\r\n\t\tif (current->address == address) {\r\n\t\t\t// unlink the breakpoint\r\n\t\t\tif (previous) previous->next = current->next;\r\n\t\t\telse breakpoints = current->next;\r\n\t\t\t// restore address\r\n\t\t\tif (!WriteProcessMemory(child_handle, address, &current->original_opcode, 1, &rwsize) || (rwsize != 1)) {\r\n\t\t\t\tFATAL(\"Error writing child memory\\n\");\r\n\t\t\t}\r\n\t\t\tFlushInstructionCache(child_handle, address, 1);\r\n\t\t\t// restore context\r\n\t\t\tCONTEXT lcContext;\r\n\t\t\tlcContext.ContextFlags = CONTEXT_ALL;\r\n\t\t\tHANDLE thread_handle = OpenThread(THREAD_ALL_ACCESS, FALSE, thread_id);\r\n\t\t\tGetThreadContext(thread_handle, &lcContext);\r\n#ifdef _WIN64\r\n\t\t\tlcContext.Rip--;\r\n#else\r\n\t\t\tlcContext.Eip--;\r\n#endif\r\n\t\t\tSetThreadContext(thread_handle, &lcContext);\r\n\t\t\tCloseHandle(thread_handle);\r\n\t\t\t// handle breakpoint\r\n\t\t\tswitch (current->type) {\r\n\t\t\tcase BREAKPOINT_ENTRYPOINT:\r\n\t\t\t\ton_entrypoint();\r\n\t\t\t\tbreak;\r\n\t\t\tcase BREAKPOINT_MODULELOADED:\r\n\t\t\t\ton_module_loaded((HMODULE)current->module_base, current->module_name);\r\n\t\t\t\tbreak;\r\n\t\t\tcase BREAKPOINT_FUZZMETHOD:\r\n\t\t\t\ton_target_method(thread_id);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// return the brekpoint type\r\n\t\t\tret = current->type;\r\n\t\t\t// delete the breakpoint object\r\n\t\t\tfree(current);\r\n\t\t\t//done\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tprevious = current;\r\n\t\tcurrent = current->next;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// standard debugger loop that listens to relevant events in the target process\r\nint debug_loop()\r\n{\r\n\tbool alive = true;\r\n\r\n\tLPDEBUG_EVENT DebugEv = &dbg_debug_event;\r\n\r\n\twhile(alive)\r\n\t{\r\n\r\n\t\tBOOL wait_ret = WaitForDebugEvent(DebugEv, 100);\r\n\r\n\t\t// printf(\"time: %lld\\n\", get_cur_time_us());\r\n\r\n\t\tif (wait_ret) {\r\n\t\t\tdbg_continue_needed = true;\r\n\t\t} else {\r\n\t\t\tdbg_continue_needed = false;\r\n\t\t}\r\n\r\n\t\tif (get_cur_time() > dbg_timeout_time) return DEBUGGER_HANGED;\r\n\r\n\t\tif (!wait_ret) {\r\n\t\t\t//printf(\"WaitForDebugEvent returned 0\\n\");\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tdbg_continue_status = DBG_CONTINUE;\r\n\r\n\t\t// printf(\"eventCode: %x\\n\", DebugEv->dwDebugEventCode);\r\n\r\n\t\tswitch (DebugEv->dwDebugEventCode)\r\n\t\t{\r\n\t\tcase EXCEPTION_DEBUG_EVENT:\r\n\t\t\t// printf(\"exception code: %x\\n\", DebugEv->u.Exception.ExceptionRecord.ExceptionCode);\r\n\r\n\t\t\tswitch (DebugEv->u.Exception.ExceptionRecord.ExceptionCode)\r\n\t\t\t{\r\n\t\t\tcase EXCEPTION_BREAKPOINT:\r\n\t\t\tcase 0x4000001f: //STATUS_WX86_BREAKPOINT\r\n\t\t\t{\r\n\t\t\t\tvoid *address = DebugEv->u.Exception.ExceptionRecord.ExceptionAddress;\r\n\t\t\t\t// printf(\"Breakpoint at address %p\\n\", address);\r\n\t\t\t\tint breakpoint_type = handle_breakpoint(address, DebugEv->dwThreadId);\r\n\t\t\t\tif (breakpoint_type == BREAKPOINT_UNKNOWN) {\r\n\t\t\t\t\tdbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;\r\n\t\t\t\t} else if (breakpoint_type == BREAKPOINT_FUZZMETHOD) {\r\n\t\t\t\t\tdbg_continue_status = DBG_CONTINUE;\r\n\t\t\t\t\treturn DEBUGGER_FUZZMETHOD_REACHED;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdbg_continue_status = DBG_CONTINUE;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase EXCEPTION_ACCESS_VIOLATION: {\r\n\t\t\t\tif ((size_t)DebugEv->u.Exception.ExceptionRecord.ExceptionAddress == WINAFL_LOOP_EXCEPTION) {\r\n\t\t\t\t\ton_target_method_ended(DebugEv->dwThreadId);\r\n\t\t\t\t\tdbg_continue_status = DBG_CONTINUE;\r\n\t\t\t\t\treturn DEBUGGER_FUZZMETHOD_END;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;\r\n\t\t\t\t\treturn DEBUGGER_CRASHED;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcase EXCEPTION_ILLEGAL_INSTRUCTION:\r\n\t\t\tcase EXCEPTION_PRIV_INSTRUCTION:\r\n\t\t\tcase EXCEPTION_INT_DIVIDE_BY_ZERO:\r\n\t\t\tcase EXCEPTION_STACK_OVERFLOW:\r\n\t\t\tcase STATUS_HEAP_CORRUPTION:\r\n\t\t\tcase STATUS_STACK_BUFFER_OVERRUN:\r\n\t\t\tcase STATUS_FATAL_APP_EXIT:\r\n\t\t\t\tdbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;\r\n\t\t\t\treturn DEBUGGER_CRASHED;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tdbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase CREATE_THREAD_DEBUG_EVENT:\r\n\t\t\tbreak;\r\n\r\n\t\tcase CREATE_PROCESS_DEBUG_EVENT: {\r\n\t\t\t// add a brekpoint to the process entrypoint\r\n\t\t\tvoid *entrypoint = get_entrypoint(DebugEv->u.CreateProcessInfo.lpBaseOfImage);\r\n\t\t\tadd_breakpoint(entrypoint, BREAKPOINT_ENTRYPOINT, NULL, 0);\r\n\t\t\tCloseHandle(DebugEv->u.CreateProcessInfo.hFile);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase EXIT_THREAD_DEBUG_EVENT:\r\n\t\t\tbreak;\r\n\r\n\t\tcase EXIT_PROCESS_DEBUG_EVENT:\r\n\t\t\talive = false;\r\n\t\t\tbreak;\r\n\r\n\t\tcase LOAD_DLL_DEBUG_EVENT: {\r\n\t\t\t// Don't do anything until the processentrypoint is reached.\r\n\t\t\t// Before that time we can't do much anyway, a lot of calls are going to fail\r\n\t\t\t// Modules loaded before entrypoint is reached are going to be enumerated at that time\r\n\t\t\tif (child_entrypoint_reached) {\r\n\t\t\t\tchar filename[MAX_PATH];\r\n\t\t\t\tGetFinalPathNameByHandleA(DebugEv->u.LoadDll.hFile, (LPSTR)(&filename), sizeof(filename), 0);\r\n\t\t\t\tchar *base_name = strrchr(filename, '\\\\');\r\n\t\t\t\tif (base_name) base_name += 1;\r\n\t\t\t\telse base_name = filename;\r\n\t\t\t\t// printf(\"Module loaded: %s %p\\n\", base_name, DebugEv->u.LoadDll.lpBaseOfDll);\r\n\t\t\t\tif (options.debug_mode) fprintf(debug_log, \"Module loaded: %s\\n\", base_name);\r\n\t\t\t\t// module isn't fully loaded yet. Instead of processing it now,\r\n\t\t\t\t// add a breakpoint to the module's entrypoint\r\n\t\t\t\tif ((_stricmp(base_name, options.fuzz_module) == 0) || \r\n\t\t\t\t\tis_coverage_module(base_name) ||\r\n\t\t\t\t\toptions.decoder == DECODER_FULL_REFERENCE ||\r\n\t\t\t\t\toptions.decoder == DECODER_FULL_FAST)\r\n\t\t\t\t{\r\n\t\t\t\t\tvoid *entrypoint = get_entrypoint(DebugEv->u.LoadDll.lpBaseOfDll);\r\n\t\t\t\t\t// printf(\"module %s entrypoint %p\\n\", base_name, entrypoint);\r\n\t\t\t\t\t// if there is no entrypoint assume resource-only dll\r\n\t\t\t\t\tif (entrypoint) {\r\n\t\t\t\t\t\tadd_breakpoint(entrypoint, BREAKPOINT_MODULELOADED,\r\n\t\t\t\t\t\t\tbase_name, DebugEv->u.LoadDll.lpBaseOfDll);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tprintf(\"Warning: module %s has no entrypoint, \"\r\n\t\t\t\t\t\t\t\"assuming resource-only. \"\r\n\t\t\t\t\t\t\t\"If you believe this is not the case, \"\r\n\t\t\t\t\t\t\t\"please file a bug\\n\", base_name);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tCloseHandle(DebugEv->u.LoadDll.hFile);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tcase UNLOAD_DLL_DEBUG_EVENT:\r\n\t\t\tbreak;\r\n\r\n\t\tcase OUTPUT_DEBUG_STRING_EVENT:\r\n\t\t\tbreak;\r\n\r\n\t\tcase RIP_EVENT:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tContinueDebugEvent(DebugEv->dwProcessId,\r\n\t\t\tDebugEv->dwThreadId,\r\n\t\t\tdbg_continue_status);\r\n\t}\r\n\r\n\treturn DEBUGGER_PROCESS_EXIT;\r\n}\r\n\r\n// a simpler debugger loop that just waits for the process to exit\r\nvoid wait_process_exit()\r\n{\r\n\tbool alive = true;\r\n\r\n\tLPDEBUG_EVENT DebugEv = &dbg_debug_event;\r\n\r\n\twhile (alive)\r\n\t{\r\n\t\tdbg_continue_status = DBG_CONTINUE;\r\n\r\n\t\tif (!WaitForDebugEvent(DebugEv, 100)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t//printf(\"eventCode: %x\\n\", DebugEv->dwDebugEventCode);\r\n\r\n\t\tswitch (DebugEv->dwDebugEventCode)\r\n\t\t{\r\n\t\tcase EXCEPTION_DEBUG_EVENT:\r\n\t\t\tdbg_continue_status = DBG_EXCEPTION_NOT_HANDLED;\r\n\t\t\tbreak;\r\n\r\n\t\tcase CREATE_PROCESS_DEBUG_EVENT:\r\n\t\t\tCloseHandle(DebugEv->u.CreateProcessInfo.hFile);\r\n\t\t\tbreak;\r\n\r\n\t\tcase EXIT_PROCESS_DEBUG_EVENT:\r\n\t\t\talive = false;\r\n\t\t\tbreak;\r\n\r\n\t\tcase LOAD_DLL_DEBUG_EVENT:\r\n\t\t\tCloseHandle(DebugEv->u.LoadDll.hFile);\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tContinueDebugEvent(DebugEv->dwProcessId,\r\n\t\t\tDebugEv->dwThreadId,\r\n\t\t\tdbg_continue_status);\r\n\t}\r\n}\r\n\r\n// starts the target process\r\nvoid start_process(char *cmd) {\r\n\tSTARTUPINFOA si;\r\n\tPROCESS_INFORMATION pi;\r\n\tHANDLE hJob = NULL;\r\n\tJOBOBJECT_EXTENDED_LIMIT_INFORMATION job_limit;\r\n\r\n\tbreakpoints = NULL;\r\n\r\n\tif (sinkhole_stds && devnul_handle == INVALID_HANDLE_VALUE) {\r\n\t\tdevnul_handle = CreateFile(\r\n\t\t\t\"nul\",\r\n\t\t\tGENERIC_READ | GENERIC_WRITE,\r\n\t\t\tFILE_SHARE_READ | FILE_SHARE_WRITE,\r\n\t\t\tNULL,\r\n\t\t\tOPEN_EXISTING,\r\n\t\t\t0,\r\n\t\t\tNULL);\r\n\r\n\t\tif (devnul_handle == INVALID_HANDLE_VALUE) {\r\n\t\t\tPFATAL(\"Unable to open the nul device.\");\r\n\t\t}\r\n\t}\r\n\tBOOL inherit_handles = TRUE;\r\n\r\n\tZeroMemory(&si, sizeof(si));\r\n\tsi.cb = sizeof(si);\r\n\tZeroMemory(&pi, sizeof(pi));\r\n\r\n\t// todo the below is duplicating code from afl-fuzz.c a lot\r\n\t// this should be taken out to a separate function\r\n\tif (sinkhole_stds) {\r\n\t\tsi.hStdOutput = si.hStdError = devnul_handle;\r\n\t\tsi.dwFlags |= STARTF_USESTDHANDLES;\r\n\t}\r\n\telse {\r\n\t\tinherit_handles = FALSE;\r\n\t}\r\n\r\n\tif (mem_limit || cpu_aff) {\r\n\t\thJob = CreateJobObject(NULL, NULL);\r\n\t\tif (hJob == NULL) {\r\n\t\t\tFATAL(\"CreateJobObject failed, GLE=%d.\\n\", GetLastError());\r\n\t\t}\r\n\r\n\t\tZeroMemory(&job_limit, sizeof(job_limit));\r\n\t\tif (mem_limit) {\r\n\t\t\tjob_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_PROCESS_MEMORY;\r\n\t\t\tjob_limit.ProcessMemoryLimit = (size_t)(mem_limit * 1024 * 1024);\r\n\t\t}\r\n\r\n\t\tif (cpu_aff) {\r\n\t\t\tjob_limit.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_AFFINITY;\r\n\t\t\tjob_limit.BasicLimitInformation.Affinity = (DWORD_PTR)cpu_aff;\r\n\t\t}\r\n\r\n\t\tif (!SetInformationJobObject(\r\n\t\t\thJob,\r\n\t\t\tJobObjectExtendedLimitInformation,\r\n\t\t\t&job_limit,\r\n\t\t\tsizeof(job_limit)\r\n\t\t)) {\r\n\t\t\tFATAL(\"SetInformationJobObject failed, GLE=%d.\\n\", GetLastError());\r\n\t\t}\r\n\t}\r\n\r\n\tif (!CreateProcessA(NULL, cmd, NULL, NULL, inherit_handles, DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS, NULL, NULL, &si, &pi)) {\r\n\t\tFATAL(\"CreateProcess failed, GLE=%d.\\n\", GetLastError());\r\n\t}\r\n\r\n\tchild_handle = pi.hProcess;\r\n\tchild_thread_handle = pi.hThread;\r\n\tchild_entrypoint_reached = false;\r\n\r\n\tif (mem_limit || cpu_aff) {\r\n\t\tif (!AssignProcessToJobObject(hJob, child_handle)) {\r\n\t\t\tFATAL(\"AssignProcessToJobObject failed, GLE=%d.\\n\", GetLastError());\r\n\t\t}\r\n\t}\r\n\r\n\tBOOL wow64current, wow64remote;\r\n\tif (!IsWow64Process(child_handle, &wow64remote)) {\r\n\t\tFATAL(\"IsWow64Process failed\");\r\n\t}\r\n\tif (wow64remote) {\r\n\t\twow64_target = 1;\r\n\t\tchild_ptr_size = 4;\r\n\t\tif (options.callconv == CALLCONV_DEFAULT) {\r\n\t\t\toptions.callconv = CALLCONV_CDECL;\r\n\t\t}\r\n\t}\r\n\tif (!IsWow64Process(GetCurrentProcess(), &wow64current)) {\r\n\t\tFATAL(\"IsWow64Process failed\");\r\n\t}\r\n\tif (wow64current && wow64remote && (options.decoder == DECODER_FULL_REFERENCE || options.decoder == DECODER_FULL_FAST)) {\r\n\t\tFATAL(\"For full Intel PT decoding on 64-bit windows, you must use a 64-bit WinAFL build even on 32-bit targets\");\r\n\t}\r\n}\r\n\r\n// called to resume the target process if it is waiting on a debug event\r\nvoid resumes_process() {\r\n\tContinueDebugEvent(dbg_debug_event.dwProcessId,\r\n\t\tdbg_debug_event.dwThreadId,\r\n\t\tdbg_continue_status);\r\n}\r\n\r\nvoid kill_process() {\r\n\t// end tracing\r\n\tif (options.persistent_trace) {\r\n\t\tif (!StopProcessIptTracing(child_handle)) {\r\n\t\t\tprintf(\"Error stopping ipt trace\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\tTerminateProcess(child_handle, 0);\r\n\r\n\tif(dbg_continue_needed) resumes_process();\r\n\r\n\twait_process_exit();\r\n\r\n\tCloseHandle(child_handle);\r\n\tCloseHandle(child_thread_handle);\r\n\r\n\tchild_handle = NULL;\r\n\tchild_thread_handle = NULL;\r\n\r\n\t// delete any breakpoints that weren't hit\r\n\tstruct winafl_breakpoint *breakpoint = breakpoints;\r\n\twhile (breakpoint) {\r\n\t\tstruct winafl_breakpoint *tmp = breakpoint;\r\n\t\tbreakpoint = breakpoint->next;\r\n\t\tfree(tmp);\r\n\t}\r\n\tbreakpoints = NULL;\r\n}\r\n\r\nint run_target_pt(char **argv, uint32_t timeout) {\r\n\tint debugger_status;\r\n\tint ret;\r\n\r\n\tif (!child_handle) {\r\n\r\n\t\tchar *cmd = argv_to_cmd(argv);\r\n\t\tstart_process(cmd);\r\n\t\tck_free(cmd);\r\n\r\n\t\t// wait until the target method is reached\r\n\t\tdbg_timeout_time = get_cur_time() + timeout;\r\n\t\tdebugger_status = debug_loop();\r\n\r\n\t\tif (debugger_status != DEBUGGER_FUZZMETHOD_REACHED) {\r\n\t\t\tswitch (debugger_status) {\r\n\t\t\tcase DEBUGGER_CRASHED:\r\n\t\t\t\tFATAL(\"Process crashed before reaching the target method\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase DEBUGGER_HANGED:\r\n\t\t\t\tFATAL(\"Process hanged before reaching the target method\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tcase DEBUGGER_PROCESS_EXIT:\r\n\t\t\t\tFATAL(\"Process exited before reaching the target method\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tFATAL(\"An unknown problem occured before reaching the target method\\n\");\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfuzz_iterations_current = 0;\r\n\t}\r\n\r\n\tif(options.debug_mode) fprintf(debug_log, \"iteration %d\\n\", fuzz_iterations_current);\r\n\r\n\t// start tracing\r\n\tif ((!options.persistent_trace) || (fuzz_iterations_current == 0)) {\r\n\t\tIPT_OPTIONS ipt_options;\r\n\t\tmemset(&ipt_options, 0, sizeof(IPT_OPTIONS));\r\n\t\tipt_options.OptionVersion = 1;\r\n\t\tConfigureBufferSize(options.trace_buffer_size, &ipt_options);\r\n\t\tConfigureTraceFlags(0, &ipt_options);\r\n\t\tif (!StartProcessIptTracing(child_handle, ipt_options)) {\r\n\t\t\tFATAL(\"ipt tracing error\\n\");\r\n\t\t}\r\n\t\tlast_ring_buffer_offset = 0;\r\n\t}\r\n\r\n\tdbg_timeout_time = get_cur_time() + timeout;\r\n\r\n\t// printf(\"iteration start\\n\");\r\n\r\n\tresumes_process();\r\n\tdebugger_status = debug_loop();\r\n\r\n\t// printf(\"iteration end\\n\");\r\n\r\n\t// collect trace\r\n\tbool trace_buffer_overflowed = false;\r\n\tPIPT_TRACE_DATA trace_data = GetIptTrace(child_handle);\r\n\tif (!trace_data) {\r\n\t\tprintf(\"Error getting ipt trace\\n\");\r\n\t} else {\r\n\t\ttrace_buffer_overflowed = collect_trace(trace_data);\r\n\t\tHeapFree(GetProcessHeap(), 0, trace_data);\r\n\t}\r\n\r\n\t// end tracing\r\n\tif (!options.persistent_trace) {\r\n\t\tif (!StopProcessIptTracing(child_handle)) {\r\n\t\t\tprintf(\"Error stopping ipt trace\\n\");\r\n\t\t}\r\n\t}\r\n\r\n\tif (need_build_ranges) {\r\n\t\tbuild_address_ranges();\r\n\t\tneed_build_ranges = false;\r\n\t}\r\n\r\n\t// process trace\r\n\r\n\t// printf(\"decoding trace of %llu bytes\\n\", trace_size);\r\n\r\n\tstruct pt_image *image = NULL;\r\n\tif ((options.decoder == DECODER_FULL_FAST) || (options.decoder == DECODER_FULL_REFERENCE)) {\r\n\t\timage = pt_image_alloc(\"winafl_image\");\r\n\t\tmodule_info_t *cur_module = all_modules;\r\n\t\twhile (cur_module) {\r\n\t\t\tif (cur_module->isid > 0) {\r\n\t\t\t\tint ret = pt_image_add_cached(image, section_cache, cur_module->isid, NULL);\r\n\t\t\t}\r\n\t\t\tcur_module = cur_module->next;\r\n\t\t}\r\n\t}\r\n\r\n\tif (options.decoder == DECODER_TIP_FAST) {\r\n\t\tdecode_trace_tip_fast(trace_buffer, trace_size, options.coverage_kind);\r\n#ifdef DECODER_CORRECTNESS_TEST\r\n\t\tprintf(\"Testing decoder correctness\\n\");\r\n\t\tunsigned char *fast_trace_bits = (unsigned char *)malloc(MAP_SIZE);\r\n\t\tmemcpy(fast_trace_bits, trace_bits, MAP_SIZE);\r\n\t\tmemset(trace_bits, 0, MAP_SIZE);\r\n\t\tdecode_trace_tip_reference(trace_buffer, trace_size, options.coverage_kind);\r\n\t\tif (memcmp(fast_trace_bits, trace_bits, MAP_SIZE)) {\r\n\t\t\tFATAL(\"Fast decoder returned different coverage than the reference decoder\");\r\n\t\t}\r\n\t\tfree(fast_trace_bits);\r\n#endif\r\n\t} else if (options.decoder == DECODER_TIP_REFERENCE) {\r\n\t\tdecode_trace_tip_reference(trace_buffer, trace_size, options.coverage_kind);\r\n\t} else if (options.decoder == DECODER_FULL_FAST) {\r\n\t\tanalyze_trace_full_fast(trace_buffer, trace_size, options.coverage_kind, image, trace_buffer_overflowed);\r\n#ifdef DECODER_CORRECTNESS_TEST\r\n\t\tprintf(\"Testing decoder correctness\\n\");\r\n\t\tunsigned char *fast_trace_bits = (unsigned char *)malloc(MAP_SIZE);\r\n\t\tmemcpy(fast_trace_bits, trace_bits, MAP_SIZE);\r\n\t\tmemset(trace_bits, 0, MAP_SIZE);\r\n\t\tanalyze_trace_full_reference(trace_buffer, trace_size, options.coverage_kind, image, trace_buffer_overflowed);\r\n\t\tif (memcmp(fast_trace_bits, trace_bits, MAP_SIZE)) {\r\n\t\t\tFATAL(\"Fast decoder returned different coverage than the reference decoder\");\r\n\t\t}\r\n\t\tfree(fast_trace_bits);\r\n#endif\r\n\t} else if (options.decoder == DECODER_FULL_REFERENCE) {\r\n\t\tanalyze_trace_full_reference(trace_buffer, trace_size, options.coverage_kind, image, trace_buffer_overflowed);\r\n\t}\r\n\r\n\tif(image) pt_image_free(image);\r\n\r\n\tif (debugger_status == DEBUGGER_PROCESS_EXIT) {\r\n\t\tCloseHandle(child_handle);\r\n\t\tCloseHandle(child_thread_handle);\r\n\t\tchild_handle = NULL;\r\n\t\tchild_thread_handle = NULL;\r\n\t\tret = FAULT_TMOUT; //treat it as a hang\r\n\t} else if (debugger_status == DEBUGGER_HANGED) {\r\n\t\tkill_process();\r\n\t\tret = FAULT_TMOUT;\r\n\t} else if (debugger_status == DEBUGGER_CRASHED) {\r\n\t\tkill_process();\r\n\t\tret = FAULT_CRASH;\r\n\t} else if (debugger_status == DEBUGGER_FUZZMETHOD_END) {\r\n\t\tret = FAULT_NONE;\r\n\t}\r\n\r\n\tfuzz_iterations_current++;\r\n\tif (fuzz_iterations_current == options.fuzz_iterations && child_handle != NULL) {\r\n\t\tkill_process();\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\nint pt_init(int argc, char **argv, char *module_dir) {\r\n\tchild_handle = NULL;\r\n\tchild_thread_handle = NULL;\r\n\r\n\tint lastoption = -1;\r\n\tfor (int i = 1; i < argc; i++) {\r\n\t\tif (strcmp(argv[i], \"--\") == 0) {\r\n\t\t\tlastoption = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (lastoption <= 0) return 0;\r\n\r\n\twinaflpt_options_init(lastoption - 1, argv + 1);\r\n\ttrace_buffer = (unsigned char *)malloc(options.trace_buffer_size);\r\n\r\n\tif (!EnableAndValidateIptServices()) {\r\n\t\tFATAL(\"No IPT\\n\");\r\n\t} else {\r\n\t\tprintf(\"IPT service enebled\\n\");\r\n\t}\r\n\r\n\tif (options.debug_mode) {\r\n\t\tdebug_log = fopen(\"debug.log\", \"w\");\r\n\t\tif (!debug_log) {\r\n\t\t\tFATAL(\"Can't open debug log for writing\");\r\n\t\t}\r\n\t}\r\n\r\n\tif (options.decoder == DECODER_FULL_FAST || options.decoder == DECODER_FULL_REFERENCE) {\r\n\t\tsection_cache = pt_iscache_alloc(\"winafl_cache\");\r\n\t}\r\n\tstrcpy(section_cache_dir, module_dir);\r\n\r\n\tif (options.decoder == DECODER_FULL_FAST) {\r\n\t\tif (!options.trace_cache_size) {\r\n\t\t\t// simple heuristics for determining tracelet cache size\r\n\t\t\t// within reasonable bounds\r\n\t\t\toptions.trace_cache_size = options.trace_buffer_size * 10;\r\n\t\t\tif (options.trace_cache_size < TRACE_CACHE_SIZE_MIN)\r\n\t\t\t\toptions.trace_cache_size = TRACE_CACHE_SIZE_MIN;\r\n\t\t\tif (options.trace_cache_size > TRACE_CACHE_SIZE_MAX)\r\n\t\t\t\toptions.trace_cache_size = TRACE_CACHE_SIZE_MAX;\r\n\r\n\t\t}\r\n\t\ttracelet_cache_init(options.trace_cache_size / 100, options.trace_cache_size);\r\n\t}\r\n\r\n\treturn lastoption;\r\n}\r\n\r\nvoid debug_target_pt(char **argv) {\r\n\ttrace_bits = (u8 *)malloc(MAP_SIZE);\r\n\tu8 * trace_bits_saved = (u8 *)malloc(MAP_SIZE);\r\n\r\n\tfor (int i = 0; i < options.fuzz_iterations; i++) {\r\n\t\tint ret = run_target_pt(argv, 0xFFFFFFFF);\r\n\r\n\t\t// detect variable coverage, could indicate a decoding issue\r\n\t\t// skip 1st iteration, will likely hit more coverage\r\n\t\tif (i == 1) {\r\n\t\t\tmemcpy(trace_bits_saved, trace_bits, MAP_SIZE);\r\n\t\t} else if(i > 1) {\r\n\t\t\tif (memcmp(trace_bits_saved, trace_bits, MAP_SIZE)) {\r\n\t\t\t\t// printf(\"Info: Variable coverage detected\\n\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tswitch (ret) {\r\n\t\tcase FAULT_NONE:\r\n\t\t\tif(debug_log) fprintf(debug_log, \"Iteration finished normally\\n\");\r\n\t\t\tbreak;\r\n\t\tcase FAULT_CRASH:\r\n\t\t\tif (debug_log) fprintf(debug_log, \"Target crashed\\n\");\r\n\t\t\tbreak;\r\n\t\tcase FAULT_TMOUT:\r\n\t\t\tif (debug_log) fprintf(debug_log, \"Target hanged\\n\");\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tif (debug_log) {\r\n\t\tfprintf(debug_log, \"Coverage map (hex): \\n\");\r\n\t\tsize_t map_pos = 0;\r\n\t\twhile (1) {\r\n\t\t\tfor (int i = 0; i < 16; i++) {\r\n\t\t\t\tif (map_pos == MAP_SIZE) break;\r\n\t\t\t\tfprintf(debug_log, \"%02X\", trace_bits[map_pos]);\r\n\t\t\t\tmap_pos++;\r\n\t\t\t}\r\n\t\t\tfprintf(debug_log, \"\\n\");\r\n\t\t\tif (map_pos == MAP_SIZE) break;\r\n\t\t}\r\n\t}\r\n\r\n\tif (debug_log) fclose(debug_log);\r\n}\r\n"
        },
        {
          "name": "winaflpt.h",
          "type": "blob",
          "size": 1.169921875,
          "content": "/*\r\n  WinAFL - Intel PT instrumentation and presistence via debugger code\r\n  ------------------------------------------------\r\n\r\n  Written and maintained by Ivan Fratric <ifratric@google.com>\r\n\r\n  Copyright 2016 Google Inc. All Rights Reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n*/\r\n\r\n#define COVERAGE_BB 0\r\n#define COVERAGE_EDGE 1\r\n\r\n#define TRACE_BUFFER_SIZE_DEFAULT (128*1024) //should be a power of 2\r\n\r\n#define TRACE_CACHE_SIZE_MIN 10000000\r\n#define TRACE_CACHE_SIZE_MAX 100000000\r\n\r\nbool findpsb(unsigned char **data, size_t *size);\r\n\r\nint run_target_pt(char **argv, uint32_t timeout);\r\nint pt_init(int argc, char **argv, char *module_dir);\r\nvoid debug_target_pt(char **argv);"
        }
      ]
    }
  ]
}