{
  "metadata": {
    "timestamp": 1736709829376,
    "page": 294,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "slact/nchan",
      "stars": 3029,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENCE",
          "type": "blob",
          "size": 1.091796875,
          "content": "This work is distributed under the MIT Licence.\n\nWritten by Leo Ponomarev (slact) 2009-2015.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above authorship notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "NchanSubscriber.js",
          "type": "blob",
          "size": 35.61328125,
          "content": "/*\n * NchanSubscriber\n * usage: var sub = new NchanSubscriber(url, opt);\n * \n * opt = {\n *   subscriber: 'longpoll', 'eventsource', or 'websocket',\n *     //or an array of the above indicating subscriber type preference\n *   reconnect: undefined or 'session' or 'persist'\n *     //if the HTML5 sessionStore or localStore should be used to resume\n *     //connections interrupted by a page load\n *   shared: true or undefined\n *     //share connection to same subscriber url between browser \n *     //windows and tabs using localStorage. In shared mode, \n *     //only 1 running subscriber is allowed per url per window/tab.\n * }\n * \n * sub.on(\"transportSetup\", function(opt, subscriberName) {\n *   // opt is a hash/object - not all transports support all options equally. Only longpoll supports arbitrary headers\n *   // subscriberName is a string\n *   //\n *   // longpoll transport supports:\n *   //   opt.longpoll.pollDelay - delay in milliseconds between successful requests\n *   // eventsource transport supports:\n *   //   opt.eventsource.withCredentials - boolean enabling the withCredentials CORS setting\n * });\n * \n * sub.on(\"transportNativeCreated\", function(nativeTransportObject, subscriberName) {\n *   // nativeTransportObject is the native transport object and depends on the subscriber type\n *   // subscriberName is a string\n * });\n *\n * sub.on(\"transportNativeBeforeDestroy\", function(nativeTransportObject, subscriberName) {\n *   // nativeTransportObject is the native transport object and depends on the subscriber type\n *   // subscriberName is a string\n * });\n *\n * sub.on(\"message\", function(message, message_metadata) {\n *   // message is a string\n *   // message_metadata may contain 'id' and 'content-type'\n * });\n * \n * sub.on('connect', function(evt) {\n *   //fired when first connected. \n * });\n * \n * sub.on('disconnect', function(evt) {\n *   // when disconnected.\n * });\n * \n * sub.on('error', function(code, message) {\n *   //error callback. not sure about the parameters yet\n * });\n * \n * sub.reconnect; // should subscriber try to reconnect? true by default.\n * sub.reconnectTimeout; //how long to wait to reconnect? does not apply to EventSource, which reconnects on its own.\n * sub.lastMessageId; //last message id. useful for resuming a connection without loss or repetition.\n * \n * sub.start(); // begin (or resume) subscribing\n * sub.stop(); // stop subscriber. do not reconnect.\n */\n\n//Thanks Darren Whitlen ( @prawnsalad ) for your feedback\n\n\n;(function (global, moduleName, factory) { // eslint-disable-line\n  \"use strict\";\n  /* eslint-disable no-undef */\n  var newModule = factory(global);\n  if (typeof module === \"object\" && module != null && module.exports) {\n    module.exports = newModule;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(function () { return newModule; });\n  } else {\n    global[moduleName] = newModule;\n  }\n  /* eslint-enable no-undef */\n})(typeof window !== \"undefined\" ? window : this, \"NchanSubscriber\", function factory(global, undefined) { // eslint-disable-line\n\n  // https://github.com/yanatan16/nanoajax\n  var nanoajax={};\n  (function(){var e=[\"responseType\",\"withCredentials\",\"timeout\",\"onprogress\"];nanoajax.ajax=function(r,o){var a=r.headers||{},u=r.body,s=r.method||(u?\"POST\":\"GET\"),i=false;var f=t(r.cors);function l(e,t){return function(){if(!i){o(f.status===undefined?e:f.status,f.status===0?\"Error\":f.response||f.responseText||t,f);i=true}}}f.open(s,r.url,true);var d=f.onload=l(200);f.onreadystatechange=function(){if(f.readyState===4)d()};f.onerror=l(null,\"Error\");f.ontimeout=l(null,\"Timeout\");f.onabort=l(null,\"Abort\");if(u){n(a,\"X-Requested-With\",\"XMLHttpRequest\");if(!global.FormData||!(u instanceof global.FormData)){n(a,\"Content-Type\",\"application/x-www-form-urlencoded\")}}for(var p=0,c=e.length,g;p<c;p++){g=e[p];if(r[g]!==undefined)f[g]=r[g]}for(var g in a)f.setRequestHeader(g,a[g]);f.send(u);return f};function t(e){if(e&&global.XDomainRequest&&!/MSIE 1/.test(navigator.userAgent))return new XDomainRequest;if(global.XMLHttpRequest)return new XMLHttpRequest}function n(e,t,n){e[t]=e[t]||n}})(); // eslint-disable-line\n\n\n  // https://github.com/component/emitter\n  function Emitter(t){return t?mixin(t):void 0}function mixin(t){for(var e in Emitter.prototype)t[e]=Emitter.prototype[e];return t}Emitter.prototype.on=Emitter.prototype.addEventListener=function(t,e){return this._callbacks=this._callbacks||{},(this._callbacks[\"$\"+t]=this._callbacks[\"$\"+t]||[]).push(e),this},Emitter.prototype.once=function(t,e){function i(){this.off(t,i),e.apply(this,arguments)}return i.fn=e,this.on(t,i),this},Emitter.prototype.off=Emitter.prototype.removeListener=Emitter.prototype.removeAllListeners=Emitter.prototype.removeEventListener=function(t,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var i=this._callbacks[\"$\"+t];if(!i)return this;if(1==arguments.length)return delete this._callbacks[\"$\"+t],this;for(var r,s=0;s<i.length;s++)if(r=i[s],r===e||r.fn===e){i.splice(s,1);break}return this},Emitter.prototype.emit=function(t){this._callbacks=this._callbacks||{};var e=[].slice.call(arguments,1),i=this._callbacks[\"$\"+t];if(i){i=i.slice(0);for(var r=0,s=i.length;s>r;++r)i[r].apply(this,e)}return this},Emitter.prototype.listeners=function(t){return this._callbacks=this._callbacks||{},this._callbacks[\"$\"+t]||[]},Emitter.prototype.hasListeners=function(t){return!!this.listeners(t).length};// eslint-disable-line\n\n  var ughbind = (Function.prototype.bind\n    ? function ughbind(fn, thisObj) {\n      return fn.bind(thisObj);\n    }\n    : function ughbind(fn, thisObj) {\n      return function() {\n        fn.apply(thisObj, arguments);\n      };\n    }\n  );\n\n  var sharedSubscriberTable={};\n\n  \"use strict\"; \n  function NchanSubscriber(url, opt) {\n    if(typeof window !== \"undefined\" && this === window) {\n      throw \"use 'new NchanSubscriber(...)' to initialize\";\n    }\n    \n    this.url = url;\n    opt = opt || {};\n    \n    //which transport should i use?\n    if(typeof opt === \"string\") {\n      opt = {subscriber: opt}; \n    }\n    if(opt.transport && !opt.subscriber) {\n      opt.subscriber = opt.transport;\n    }\n    if(typeof opt.subscriber === \"string\") {\n      opt.subscriber = [ opt.subscriber ];\n    }\n    this.desiredTransport = opt.subscriber;\n    \n    if(opt.shared) {\n      if (!(\"localStorage\" in global)) {\n        throw \"localStorage unavailable for use in shared NchanSubscriber\";\n      }\n      \n      var pre = \"NchanSubscriber:\" + this.url + \":shared:\";\n      var sharedKey = function(key) { return pre + key; };\n      var localStorage = global.localStorage;\n      this.shared = {\n        id: \"\" + Math.random() + Math.random(),\n        key: sharedKey,\n        get: function(key) {\n          return localStorage.getItem(sharedKey(key));\n        },\n        set: function(key, val) {\n          return localStorage.setItem(sharedKey(key), val);\n        },\n        setWithId: ughbind(function(key, val) {\n          return this.shared.set(key, \"##\" + this.shared.id + \":\" + val);\n        }, this),\n        getWithId: ughbind(function(key) {\n          return this.shared.stripIdFromVal(this.shared.get(key));\n        }, this),\n        stripIdFromVal: function(val) {\n          if(!val) {\n            return val;\n          }\n          var sep = val.indexOf(\":\");\n          if(val[0]!=val[1] || val[0]!=\"#\" || !sep) {\n            //throw \"not an event value with id\";\n            return val; //for backwards-compatibility\n          }\n          return val.substring(sep+1, val.length);\n        },\n        remove: function(key) {\n          return localStorage.removeItem(sharedKey(key));\n        },\n        matchEventKey: ughbind(function(ev, key) {\n          if(ev.storageArea && ev.storageArea != localStorage){\n            return false;\n          }\n          return ev.key == sharedKey(key);\n        }, this),\n        matchEventKeyWithId: ughbind(function(ev, key) {\n          if(this.shared.matchEventKey(ev, key)) {\n            var val = ev.newValue;\n            var sep = val.indexOf(\":\");\n            if(val[0]!=val[1] || val[0]!=\"#\" || !sep) {\n              //throw \"not an event value with id\";\n              return true; //for backwards-compatibility\n            }\n            var id = val.substring(2, sep);\n            return (id != this.shared.id); //ignore own events (accomodations for IE. Fuckin' IE, even after all these years...)\n          }\n          else {\n            return false;\n          }\n        }, this),\n        setRole: ughbind(function(role) {\n          //console.log(this.url, \"set shared role to \", role);\n          if(role == \"master\" && this.shared.role != \"master\") {\n            var now = new Date().getTime()/1000;\n            this.shared.setWithId(\"master:created\", now);\n            this.shared.setWithId(\"master:lastSeen\", now);\n          }\n          if(role == \"slave\" && !this.lastMessageId) {\n            this.lastMessageId = this.shared.get(\"msg:id\");\n          }\n          this.shared.role = role;\n          return this;\n        }, this),\n        \n        demoteToSlave: ughbind(function() {\n          //console.log(\"demote to slave\");\n          if(this.shared.role != \"master\") {\n            throw \"can't demote non-master to slave\";\n          }\n          if(this.running) {\n            this.stop();\n            this.shared.setRole(\"slave\");\n            this.initializeTransport();\n            this.start();\n          }\n          else {\n            this.initializeTransport();\n          }\n        }, this),\n        \n        maybePromoteToMaster: ughbind(function() {\n          if(!(this.running || this.starting)) {\n            //console.log(this.url, \"stopped Subscriber won't be promoted to master\");\n            return this;\n          }\n          if(this.shared.maybePromotingToMaster) {\n            //console.log(this.url, \" already maybePromotingToMaster\");\n            return;\n          }\n          this.shared.maybePromotingToMaster = true;\n          \n          //console.log(this.url, \"maybe promote to master\");\n          var processRoll;\n          \n          var lotteryRoundDuration = 2000;\n          var currentContenders = 0;\n          \n          //roll the dice\n          var roll = Math.random();\n          var bestRoll = roll;\n          \n          var checkRollInterval;\n          var checkRoll = ughbind(function(dontProcess) {\n            var latestSharedRollTime = parseFloat(this.shared.getWithId(\"lotteryTime\"));\n            var latestSharedRoll = parseFloat(this.shared.getWithId(\"lottery\"));\n            var notStale = !latestSharedRollTime || (latestSharedRollTime > (new Date().getTime() - lotteryRoundDuration * 2));\n            if(notStale && latestSharedRoll && (!bestRoll || latestSharedRoll > bestRoll)) {\n              bestRoll = latestSharedRoll;\n            }\n            if(!dontProcess) {\n              processRoll();\n            }\n          }, this);\n          \n          checkRoll(true);\n          this.shared.setWithId(\"lottery\", roll);\n          this.shared.setWithId(\"lotteryTime\", new Date().getTime() / 1000);\n          \n          var rollCallback = ughbind(function(ev) {\n            if(this.shared.matchEventKeyWithId(ev, \"lottery\") && ev.newValue) {\n              currentContenders += 1;\n              var newVal = parseFloat(this.shared.stripIdFromVal(ev.newValue));\n              var oldVal = parseFloat(this.shared.stripIdFromVal(ev.oldValue));\n              if(oldVal > newVal) {\n                this.shared.setWithId(\"lottery\", oldVal);\n              }\n              \n              if(!bestRoll || newVal >= bestRoll) {\n                //console.log(\"new bestRoll\", newVal);\n                bestRoll = newVal;\n              }\n            }\n          }, this);\n          global.addEventListener(\"storage\", rollCallback);\n          \n          var finish = ughbind(function() {\n            //console.log(\"finish\");\n            this.shared.maybePromotingToMaster = false;\n            //console.log(this.url, this.shared.role);\n            global.removeEventListener(\"storage\", rollCallback);\n            if(checkRollInterval) {\n              clearInterval(checkRollInterval);\n            }\n            if(this.shared && this.shared.role == \"master\") {\n              this.shared.remove(\"lottery\");\n              this.shared.remove(\"lotteryTime\");\n            }\n            if(this.running) {\n              this.stop();\n              this.initializeTransport();\n              this.start();\n            }\n            else {\n              this.initializeTransport();\n              if(this.starting) {\n                this.start();\n              }\n            }\n          }, this);\n          \n          processRoll = ughbind(function() {\n            //console.log(\"roll, bestroll\", roll, bestRoll);\n            if(roll < bestRoll) {\n              //console.log(this.url, \"loser\");\n              this.shared.setRole(\"slave\");\n              finish();\n            }\n            else if(roll >= bestRoll) {\n              //var now = new Date().getTime() / 1000;\n              //var lotteryTime = parseFloat(this.shared.getWithId(\"lotteryTime\"));\n              //console.log(lotteryTime, now - lotteryRoundDuration/1000);\n              if(currentContenders == 0) {\n                //console.log(\"winner, no more contenders!\");\n                this.shared.setRole(\"master\");\n                finish();\n              }\n              else {\n                //console.log(\"winning, but have contenders\", currentContenders);\n                currentContenders = 0;\n              }\n            }\n          }, this);\n          \n          checkRollInterval = global.setInterval(checkRoll, lotteryRoundDuration);\n        }, this),\n        masterCheckInterval: 10000\n      };\n    }\n    \n    this.lastMessageId = opt.id || opt.msgId;\n    this.reconnect = typeof opt.reconnect == \"undefined\" ? true : opt.reconnect;\n    this.reconnectTimeout = opt.reconnectTimeout || 1000;\n    \n    \n    var saveConnectionState;\n    if(!opt.reconnect) {\n      saveConnectionState = function() {};\n    }\n    else {\n      var index = \"NchanSubscriber:\" + url + \":lastMessageId\";\n      var storage;\n      if(opt.reconnect == \"persist\") {\n        storage = (\"localStorage\" in global) && global.localStorage;\n        if(!storage)\n          throw \"can't use reconnect: 'persist' option: localStorage not available\";\n      }\n      else if(opt.reconnect == \"session\") {\n        storage = (\"sessionStorage\" in global) && global.sessionStorage;\n        if(!storage)\n          throw \"can't use reconnect: 'session' option: sessionStorage not available\";\n      }\n      else {\n        throw \"invalid 'reconnect' option value \" + opt.reconnect;\n      }\n      saveConnectionState = ughbind(function(msgid) {\n        if(this.shared && this.shared.role == \"slave\") return;\n        storage.setItem(index, msgid);\n      }, this);\n      this.lastMessageId = storage.getItem(index);\n    }\n    \n    var onUnloadEvent = ughbind(function() {\n      if(this.running) {\n        this.stop();\n      }\n      if(this.shared && this.shared.role == \"master\") {\n        this.shared.setWithId(\"status\", \"disconnected\");\n      }\n    }, this);\n    global.addEventListener(\"beforeunload\", onUnloadEvent, false);\n    // swap `beforeunload` to `unload` after DOM is loaded\n    global.addEventListener(\"DOMContentLoaded\", function() {\n      global.removeEventListener(\"beforeunload\", onUnloadEvent, false);\n      global.addEventListener(\"unload\", onUnloadEvent, false);\n    }, false);\n    \n    \n    var notifySharedSubscribers;\n    if(this.shared) {\n      notifySharedSubscribers = ughbind(function(name, data) {\n        if(this.shared.role != \"master\") {\n          return;\n        }\n        \n        if(name == \"message\") {\n          this.shared.set(\"msg:id\", data[1] && data[1].id || \"\");\n          this.shared.set(\"msg:content-type\", data[1] && data[1][\"content-type\"] || \"\");\n          this.shared.set(\"msg\", data[0]);\n        }\n        else if(name == \"error\") {\n          //TODO \n        }\n        else if(name == \"connecting\") {\n          this.shared.setWithId(\"status\", \"connecting\");\n        }\n        else if(name == \"connect\") {\n          this.shared.setWithId(\"status\", \"connected\");\n        }\n        else if(name == \"reconnect\") {\n          this.shared.setWithId(\"status\", \"reconnecting\");\n        }\n        else if(name == \"disconnect\") {\n          this.shared.setWithId(\"status\", \"disconnected\");\n        }\n      }, this);\n    }\n    else {\n      notifySharedSubscribers = function(){};\n    }\n    \n    var restartTimeoutIndex;\n    var stopHandler = ughbind(function() {\n      if(!restartTimeoutIndex && this.running && this.reconnect && !this.transport.reconnecting && !this.transport.doNotReconnect) {\n        //console.log(\"stopHAndler reconnect plz\", this.running, this.reconnect);\n        notifySharedSubscribers(\"reconnect\");\n        restartTimeoutIndex = global.setTimeout(ughbind(function() {\n          restartTimeoutIndex = null;\n          this.stop();\n          this.start();\n        }, this), this.reconnectTimeout);\n      }\n      else {\n        notifySharedSubscribers(\"disconnect\");\n      }\n    }, this);\n    \n    this.on(\"message\", function msg(msg, meta) {\n      this.lastMessageId=meta.id;\n      if(meta.id) {\n        saveConnectionState(meta.id);\n      }\n      notifySharedSubscribers(\"message\", [msg, meta]);\n      //console.log(msg, meta);\n    });\n    this.on(\"error\", function fail(code, text) {\n      stopHandler(code, text);\n      notifySharedSubscribers(\"error\", [code, text]);\n      //console.log(\"failure\", code, text);\n    });\n    this.on(\"connect\", function() {\n      this.connected = true;\n      notifySharedSubscribers(\"connect\");\n    });\n    this.on(\"__disconnect\", function fail(code, text) {\n      this.connected = false;\n      this.emit(\"disconnect\", code, text);\n      stopHandler(code, text);\n      //console.log(\"__disconnect\", code, text);\n    });\n  }\n\n  Emitter(NchanSubscriber.prototype);\n\n  var defaultTransportOptions = function() {\n    var opt = {\n      url: null,\n      msgid: null,\n      headers : {}\n    };\n    for(var n in NchanSubscriber.prototype.SubscriberClass) {\n      if(n != \"__slave\") {\n        opt[n]={};\n      }\n    }\n    return opt;\n  };\n  \n  NchanSubscriber.prototype.initializeTransport = function(possibleTransports) {\n    if(possibleTransports) {\n      this.desiredTransport = possibleTransports;\n    }\n    if(this.shared && this.shared.role == \"slave\") {\n      this.transport = new this.SubscriberClass[\"__slave\"](ughbind(this.emit, this)); //try it\n    }\n    else {\n      var tryInitializeTransport = ughbind(function(name) {\n        if(!this.SubscriberClass[name]) {\n          throw \"unknown subscriber type \" + name;\n        }\n        try {\n          this.transport = new this.SubscriberClass[name](ughbind(this.emit, this)); //try it\n          return this.transport;\n        } catch(err) { /*meh...*/ }\n      }, this);\n      \n      var i;\n      if(this.desiredTransport) {\n        for(i=0; i<this.desiredTransport.length; i++) {\n          if(tryInitializeTransport(this.desiredTransport[i])) {\n            break;\n          }\n        }\n      }\n      else {\n        for(i in this.SubscriberClass) {\n          if (this.SubscriberClass.hasOwnProperty(i) && i[0] != \"_\" && tryInitializeTransport(i)) {\n            break;\n          }\n        }\n      }\n    }\n    if(! this.transport) {\n      throw \"can't use any transport type\";\n    }\n  };\n\n  var storageEventListener;\n\n  NchanSubscriber.prototype.start = function() {\n    if(this.running)\n      throw \"Can't start NchanSubscriber, it's already started.\";\n    \n    this.starting = true;\n    \n    if(this.shared) {\n      if(sharedSubscriberTable[this.url] && sharedSubscriberTable[this.url] != this) {\n        throw \"Only 1 shared subscriber allowed per url per window/tab.\";\n      }\n      sharedSubscriberTable[this.url] = this;\n      \n      if(!this.shared.role) {\n        var status = this.shared.getWithId(\"status\");\n        storageEventListener = ughbind(function(ev) {\n          if(this.shared.matchEventKeyWithId(ev, \"status\")) {\n            var newValue = this.shared.stripIdFromVal(ev.newValue);\n            if(newValue == \"disconnected\") {\n              if(this.shared.role == \"slave\") {\n                //play the promotion lottery\n                //console.log(this.url, \"status changed to disconnected, maybepromotetomaster\", ev.newValue, ev.oldValue);\n                this.shared.maybePromoteToMaster();\n              }\n              else if(this.shared.role == \"master\") {\n                //do nothing\n                //console.log(this.url, \"current role is master, do nothing?...\");\n              }\n            }\n          }\n          else if(this.shared.role == \"master\" && this.shared.matchEventKeyWithId(ev, \"master:created\") && ev.newValue) {\n            //a new master has arrived. demote to slave.\n            this.shared.demoteToSlave();\n          }\n        }, this);\n        global.addEventListener(\"storage\", storageEventListener);\n        if(status == \"disconnected\") {\n          //console.log(this.url, \"status == disconnected, maybepromotetomaster\");\n          this.shared.maybePromoteToMaster();\n        }\n        else {\n          this.shared.setRole(status ? \"slave\" : \"master\");\n          this.initializeTransport();\n        }\n      }\n      \n      if(this.shared.role == \"master\") {\n        this.shared.setWithId(\"status\", \"connecting\");\n        this.transport.listen(this.url, this.lastMessageId);\n        this.running = true;\n        delete this.starting;\n        \n        //master checkin interval\n        this.shared.masterIntervalCheckID = global.setInterval(ughbind(function() {\n          this.shared.setWithId(\"master:lastSeen\", new Date().getTime() / 1000);\n        }, this), this.shared.masterCheckInterval * 0.8);\n      }\n      else if(this.shared.role == \"slave\") {\n        this.transport.listen(this.url, this.shared);\n        this.running = true;\n        delete this.starting;\n        \n        //slave check if master is around\n        this.shared.masterIntervalCheckID = global.setInterval(ughbind(function() {\n          var lastCheckin = parseFloat(this.shared.getWithId(\"master:lastSeen\"));\n          if(!lastCheckin || lastCheckin < (new Date().getTime() / 1000) - this.shared.masterCheckInterval / 1000) {\n            //master hasn't checked in for too long. assume it's gone.\n            this.shared.maybePromoteToMaster();\n          }\n        }, this), this.shared.masterCheckInterval);\n      }\n    }\n    else {\n      if(!this.transport) {\n        this.initializeTransport();\n      }\n      this.transport.listen(this.url, this.lastMessageId);\n      this.running = true;\n      delete this.starting;\n    }\n    return this;\n  };\n\n  NchanSubscriber.prototype.stop = function() {\n    if(!this.running)\n      throw \"Can't stop NchanSubscriber, it's not running.\";\n    \n    this.running = false;\n    if(storageEventListener) {\n      global.removeEventListener(\"storage\", storageEventListener);\n    }\n    this.transport.cancel();\n    if(this.shared) {\n      delete sharedSubscriberTable[this.url];\n      if(this.shared.masterIntervalCheckID) {\n        clearInterval(this.shared.masterIntervalCheckID);\n        delete this.shared.masterIntervalCheckID;\n      }\n    }\n    return this;\n  };\n\n  function addLastMsgIdToQueryString(url, msgid) {\n    if(msgid) {\n      var m = url.match(/(\\?.*)$/);\n      url += (m ? \"&\" : \"?\") + \"last_event_id=\" + encodeURIComponent(msgid);\n    }\n    return url;\n  }\n\n  NchanSubscriber.prototype.SubscriberClass = {\n    \"websocket\": (function() {\n      function WSWrapper(emit) {\n        WebSocket;\n        this.emit = emit;\n        this.name = \"websocket\";\n        this.opt = defaultTransportOptions()\n        this.opt.headers[\"Sec-WebSocket-Protocol\"]=\"ws+meta.nchan\"\n      };\n\n      WSWrapper.prototype.setup = function() {\n        this.emit(\"transportSetup\", this.opt, this.name);\n        var count = 0;\n        var property;\n        for ( property in this.opt.headers ) count++;\n        if (count != 1 && \"Sec-WebSocket-Protocol\" in this.opt.headers) {\n          throw \"WebSocket only supports one header; Sec-WebSocket-Protocol\";\n        }\n      };\n\n      WSWrapper.prototype.websocketizeURL = function(url) {\n        var m = url.match(/^((\\w+:)?\\/\\/([^/]+))?(\\/)?(.*)/);\n        var protocol = m[2];\n        var host = m[3];\n        var absolute = m[4];\n        var path = m[5];\n        \n        var loc;\n        if(typeof window == \"object\") {\n          loc = window.location;\n        }\n        else if(typeof document == \"object\") {\n          loc = document.location;\n        }\n        \n        if(!protocol && loc) {\n          protocol = loc.protocol;\n        }\n        if(protocol == \"https:\") {\n          protocol = \"wss:\";\n        }\n        else if(protocol == \"http:\") {\n          protocol = \"ws:\";\n        }\n        else if(protocol != \"ws:\") {\n          protocol = \"wss:\"; //default setting: secure, unless \"ws:\" explicitly specified\n        }\n        \n        if(!host && loc) {\n          host = loc.host;\n        }\n        \n        if(!absolute) {\n          path = loc ? loc.pathname.match(/(.*\\/)[^/]*/)[1] + path : \"/\" + path;\n        }\n        else {\n          path = \"/\" + path;\n        }\n        \n        return protocol + \"//\" + host + path;\n      };\n      \n      WSWrapper.prototype.listen = function(url, msgid) {\n        if(this.listener) {\n          throw \"websocket already listening\";\n        }\n        this.opt.url = url;\n        this.opt.msgid = msgid;\n        this.setup();\n        url = this.websocketizeURL(this.opt.url);\n        url = addLastMsgIdToQueryString(url, this.opt.msgid);\n        //console.log(url);\n        this.listener = new WebSocket(url, this.opt.headers[\"Sec-WebSocket-Protocol\"]);\n        var l = this.listener;\n        this.emit(\"transportNativeCreated\", l, this.name);\n        l.onmessage = ughbind(function(evt) {\n          if (evt.data instanceof Blob) {\n            //extract header, preserve rest of blob.\n            //let's assume the header ends in the first 255 chars\n            var headerSlice = evt.data.slice(0, 255);\n            var reader = new FileReader();\n            reader.addEventListener(\"loadend\", ughbind(function() {\n              var m = reader.result.match(/^id: (.*)\\n(content-type: (.*)\\n)?\\n/m);\n              this.emit(\"message\", evt.data.slice(m[0].length), {\"id\": m[1], \"content-type\": m[3]});\n            }, this));\n            reader.readAsText(headerSlice)\n          } else {\n            var m = evt.data.match(/^id: (.*)\\n(content-type: (.*)\\n)?\\n/m);\n            this.emit(\"message\", evt.data.substr(m[0].length), {\"id\": m[1], \"content-type\": m[3]});\n          }\n        }, this);\n        \n        l.onopen = ughbind(function(evt) {\n          this.emit(\"connect\", evt);\n          //console.log(\"connect\", evt);\n        }, this);\n        \n        l.onerror = ughbind(function(evt) {\n          //console.log(\"error\", evt);\n          this.emit(\"error\", evt, l);\n          delete this.listener;\n        }, this);\n        \n        l.onclose = ughbind(function(evt) {\n          this.emit(\"__disconnect\", evt);\n          delete this.listener;\n        }, this);\n      };\n      \n      WSWrapper.prototype.cancel = function() {\n        if(this.listener) {\n          this.emit(\"transportNativeBeforeDestroy\", this.listener, this.name);\n          this.listener.close();\n          delete this.listener;\n        }\n      };\n      \n      return WSWrapper;\n    })(),\n  \n    \"eventsource\": (function() {\n      function ESWrapper(emit) {\n        EventSource;\n        this.emit = emit;\n        this.name = \"eventsource\";\n        this.opt = defaultTransportOptions();\n        this.opt.eventsource.withCredentials = false;\n      }\n\n      ESWrapper.prototype.setup = function() {\n        this.emit(\"transportSetup\", this.opt, this.name);\n        var count = 0;\n        var property;\n        for ( property in this.opt.headers ) count++;\n        if (count != 0) {\n          throw \"EventSource does not support headers\";\n        }\n      };\n\n      ESWrapper.prototype.listen= function(url, msgid) {\n        if(this.listener) {\n          throw \"there's a ES listener running already\";\n        }\n        this.opt.url = url;\n        this.opt.msgid = msgid;\n        this.setup();\n        url = addLastMsgIdToQueryString(this.opt.url, this.opt.msgid);\n        this.listener = new EventSource(url, this.opt.eventsource);\n        var l = this.listener;\n        this.emit(\"transportNativeCreated\", l, this.name);\n        l.onmessage = ughbind(function(evt){\n          //console.log(\"message\", evt);\n          this.emit(\"message\", evt.data, {id: evt.lastEventId});\n        }, this);\n        \n        l.onopen = ughbind(function(evt) {\n          this.reconnecting = false;\n          //console.log(\"connect\", evt);\n          this.emit(\"connect\", evt);\n        }, this);\n        \n        l.onerror = ughbind(function(evt) {\n          //EventSource will try to reconnect by itself\n          //console.log(\"onerror\", this.listener.readyState, evt);\n          if(this.listener.readyState == EventSource.CONNECTING && !this.reconnecting) {\n            if(!this.reconnecting) {\n              this.reconnecting = true;\n              this.emit(\"__disconnect\", evt);\n            }\n          }\n          else {\n            this.emit(\"__disconnect\", evt);\n            //console.log('other __disconnect', evt);\n          }\n        }, this);\n      };\n      \n      ESWrapper.prototype.cancel= function() {\n        if(this.listener) {\n          this.emit(\"transportNativeBeforeDestroy\", this.listener, this.name);\n          this.listener.close();\n          delete this.listener;\n        }\n      };\n      \n      return ESWrapper;\n    })(),\n    \n    \"longpoll\": (function () {\n      function Longpoll(emit) {\n        this.pollingRequest = null;\n        this.nextRequestTimer = null;\n        this.longPollStartTime = null;\n        this.maxLongPollTime = 5*60*1000; //5 minutes\n        this.emit = emit;\n        this.name = \"longpoll\";\n        this.opt = defaultTransportOptions();\n        this.opt.longpoll.pollDelay = 0;\n      }\n\n      Longpoll.prototype.setup = function() {\n        this.emit(\"transportSetup\", this.opt, this.name);\n        var count = 0;\n        var property;\n        for ( property in this.opt.headers ) count++;\n      };\n\n      Longpoll.prototype.listen = function(url, msgid) {\n        if(this.req) {\n          throw \"already listening\";\n        }\n        this.opt.url = url;\n        this.opt.msgid = msgid;\n        if(msgid) {\n          this.opt.headers[\"Etag\"] = msgid;\n        }\n        this.setup();\n\n        var setHeader = ughbind(function(incoming, name) {\n          if(incoming) { this.opt.headers[name]= incoming; }\n        }, this);\n\n        this.pollingRequest = ughbind(function() {\n          if (this.req) {\n            this.emit(\"transportNativeBeforeDestroy\", this.req, this.name);\n          }\n          this.nextRequestTimer = null;\n          this.reqStartTime = new Date().getTime();\n          this.req = nanoajax.ajax({url: this.opt.url, headers: this.opt.headers}, requestCallback);\n          this.emit(\"transportNativeCreated\", this.req, this.name);\n        }, this);\n        var  requestCallback;\n        requestCallback = ughbind(function (code, response_text, req) {\n          setHeader(req.getResponseHeader(\"Last-Modified\"), \"If-Modified-Since\");\n          setHeader(req.getResponseHeader(\"Etag\"), \"If-None-Match\");\n          \n          if(code >= 200 && code <= 210) {\n            //legit reply\n            var content_type = req.getResponseHeader(\"Content-Type\");\n            if (!this.parseMultipartMixedMessage(content_type, response_text, req)) {\n              this.emit(\"message\", response_text || \"\", {\"content-type\": content_type, \"id\": this.msgIdFromResponseHeaders(req)});\n            }\n            \n            if (this.req) { //this check is needed because stop() may have been called in the message callback\n              if (this.opt.longpoll.pollDelay == 0) {\n                this.pollingRequest();\n              } else {\n                this.nextRequestTimer = global.setTimeout(this.pollingRequest, this.opt.longpoll.pollDelay);\n              }\n            }\n          }\n          else if((code == 0 && response_text == \"Error\" && req.readyState == 4) || (code === null && response_text != \"Abort\")) {\n            //console.log(\"abort!!!\");\n            this.emit(\"__disconnect\", code || 0, response_text);\n            this.cancel();\n          }\n          else if(code !== null) {\n            //HTTP error\n            this.emit(\"error\", code, response_text);\n            this.cancel();\n          }\n          else {\n            //don't care about abortions \n            this.cancel();\n            this.emit(\"__disconnect\");\n            //console.log(\"abort!\");\n          }\n        }, this);\n        \n        this.pollingRequest();\n        this.emit(\"connect\");\n        \n        return this;\n      };\n      \n      Longpoll.prototype.parseMultipartMixedMessage = function(content_type, text, req) {\n        var m = content_type && content_type.match(/^multipart\\/mixed;\\s+boundary=(.*)$/);\n        if(!m) { \n          return false;\n        }\n        var boundary = m[1];\n        \n        var msgs = text.split(\"--\" + boundary);\n        if(msgs[0] != \"\" || !msgs[msgs.length-1].match(/--\\r?\\n/)) { throw \"weird multipart/mixed split\"; }\n        \n        msgs = msgs.slice(1, -1);\n        for(var i in msgs) {\n          m = msgs[i].match(/^(.*)\\r?\\n\\r?\\n([\\s\\S]*)\\r?\\n$/m);\n          var hdrs = m[1].split(\"\\n\");\n          \n          var meta = {};\n          for(var j in hdrs) {\n            var hdr = hdrs[j].match(/^([^:]+):\\s+(.*)/);\n            if(hdr && hdr[1] == \"Content-Type\") {\n              meta[\"content-type\"] = hdr[2];\n            }\n          }\n          \n          if(i == msgs.length - 1) {\n            meta[\"id\"] = this.msgIdFromResponseHeaders(req);\n          }\n          this.emit(\"message\", m[2], meta);\n        }\n        return true;\n      };\n      \n      Longpoll.prototype.msgIdFromResponseHeaders = function(req) {\n        var lastModified, etag;\n        lastModified = req.getResponseHeader(\"Last-Modified\");\n        etag = req.getResponseHeader(\"Etag\");\n        if(lastModified) {\n          return \"\" + Date.parse(lastModified)/1000 + \":\" + (etag || \"0\");\n        }\n        else if(etag) {\n          return etag;\n        }\n        else {\n          return null;\n        }\n      };\n      \n      Longpoll.prototype.cancel = function() {\n        if(this.req) {\n          this.emit(\"transportNativeBeforeDestroy\", this.req, this.name);\n          this.req.abort();\n          delete this.req;\n        }\n        this.cancelPendingPollRequest();\n        return this; \n      };\n\n      Longpoll.prototype.cancelPendingPollRequest = function() {\n        if (this.nextRequestTimer) {\n          global.clearTimeout(this.nextRequestTimer);\n          this.nextRequestTimer = null;\n        }\n      };\n\n      return Longpoll;\n    })(),\n    \n    \"__slave\": (function() {\n      function LocalStoreSlaveTransport(emit) {\n        this.emit = emit;\n        this.doNotReconnect = true;\n        this.shared = null;\n        this.name = \"__slave\";\n        this.opt = defaultTransportOptions();\n      }\n\n      LocalStoreSlaveTransport.prototype.setup = function() {\n        this.emit(\"transportSetup\", this.opt, this.name);\n        var count = 0;\n        var property;\n        for ( property in this.opt.headers ) count++;\n        if (count != 0) {\n          throw \"__slave does not support headers\";\n        }\n      };\n\n      LocalStoreSlaveTransport.prototype.listen = function(url, shared) {\n        this.shared = shared;\n        this.opt.url = url;  \n        this.setup();\n        this.statusChangeChecker = ughbind(function(ev) {\n          if(this.shared.matchEventKey(ev, \"msg\")) {\n            var msgId = this.shared.get(\"msg:id\");\n            var contentType = this.shared.get(\"msg:content-type\");\n            var msg = this.shared.get(\"msg\");\n            this.emit(\"message\", msg, {\"id\": msgId == \"\" ? undefined : msgId, \"content-type\": contentType == \"\" ? undefined : contentType});\n          }\n        }, this);\n        global.addEventListener(\"storage\", this.statusChangeChecker);\n        //this.emit(\"transportNativeCreated\", this, this.name);\n      };\n        \n      LocalStoreSlaveTransport.prototype.cancel = function() {\n        global.removeEventListener(\"storage\", this.statusChangeChecker);\n      };\n      \n      return LocalStoreSlaveTransport;\n    })()\n\n  };\n\n  return NchanSubscriber;\n});\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 84.974609375,
          "content": "<img class=\"logo\" alt=\"NCHAN\" src=\"https://nchan.io/github-logo.png\" />\n\nhttps://nchan.io\n\nNchan is a scalable, flexible pub/sub server for the modern web, built as a module for the [Nginx](http://nginx.org) web server. It can be configured as a standalone server, or as a shim between your application and hundreds, thousands, or millions of live subscribers. It can buffer messages in memory, on-disk, or via [Redis](http://redis.io). All connections are handled asynchronously and distributed among any number of worker processes. It can also scale to many Nginx servers with [Redis](http://redis.io).\n\nMessages are [published](#publisher-endpoints) to channels with HTTP `POST` requests or Websocket, and [subscribed](#subscriber-endpoint) also through [Websocket](#websocket), [long-polling](#long-polling), [EventSource](#eventsource) (SSE), old-fashioned [interval polling](#interval-polling), [and](#http-chunked-transfer) [more](#http-multipart-mixed).\n\nIn a web browser, you can use Websocket or EventSource natively, or the [NchanSubscriber.js](https://github.com/slact/nchan.js) wrapper library. It supports Long-Polling, EventSource, and resumable Websockets, and has a few other added convenience options. It's also available on [NPM](https://www.npmjs.com/package/nchan).\n\n## Features\n - RESTful, HTTP-native [API](#publishing-messages).\n - Supports [Websocket](#websocket), [EventSource (Server-Sent Events)](#eventsource), [Long-Polling](#long-polling) and other HTTP-based subscribers.\n - Per-channel configurable message buffers with no-repeat, no-loss message delivery guarantees.\n - Subscribe to [hundreds of channels](#channel-multiplexing) over a single subscriber connection.\n - HTTP request [callbacks and hooks](#hooks-and-callbacks) for easy integration.\n - Introspection with [channel events](#channel-events) and [url for monitoring performance statistics](#nchan_stub_status-stats).\n - Channel [group](#channel-groups) usage [accounting and limits](#limits-and-accounting).\n - Fast, nonblocking [shared-memory local message storage](#memory-storage) and optional, slower, persistent storage with [Redis](#redis).\n - Horizontally scalable (using [Redis](#redis)).\n - Auto-failover and [high availability](#high-availability) with no single point of failure using [Redis Cluster](#redis-cluster).\n\n## Status and History\n\nThe latest Nchan release is 1.3.7 (September 19, 2024) ([changelog](https://nchan.io/changelog)).\n\nThe first iteration of Nchan was written in 2009-2010 as the [Nginx HTTP Push Module](https://pushmodule.slact.net), and was vastly refactored into its present state in 2014-2016.\n\n#### Upgrade from Nginx HTTP Push Module\n\nAlthough Nchan is backwards-compatible with all Push Module configuration directives, some of the more unusual and rarely used settings have been disabled and will be ignored (with a warning). See the [upgrade page](https://nchan.io/upgrade) for a detailed list of changes and improvements, as well as a full list of incompatibilities.\n\n\n## Does it scale?\n\n<img class=\"benchmark_graph\" alt=\"benchmarking internal subscriber response times\" src=\"https://nchan.io/img/benchmark_internal_total.png\" />\n\nYes it does. Like Nginx, Nchan can easily handle as much traffic as you can throw at it. I've tried to benchmark it, but my benchmarking tools are much slower than Nchan. The data I've gathered is on how long Nchan itself takes to respond to every subscriber after publishing a message -- this excludes TCP handshake times and internal HTTP request parsing. Basically, it measures how Nchan scales assuming all other components are already tuned for scalability. The graphed data are averages of 5 runs with 50-byte messages.\n\nWith a well-tuned OS and network stack on commodity server hardware, expect to handle upwards of 300K concurrent subscribers per second at minimal CPU load. Nchan can also be scaled out to multiple Nginx instances using the [Redis storage engine](#nchan_use_redis), and that too can be scaled up beyond a single-point-of-failure by using [Redis Cluster](#redis-cluster).\n\n\n## Install\n\n#### Download Packages\n - [Arch Linux](https://archlinux.org): [nginx-mod-nchan](https://aur.archlinux.org/packages/nginx-mod-nchan/) and [nginx-mainline-mod-nchan](https://aur.archlinux.org/packages/nginx-mainline-mod-nchan/) are available in the Arch User Repository.\n - Mac OS X: a [homebrew](http://brew.sh) package is available. `brew tap denji/nginx; brew install nginx-full --with-nchan-module`\n - [Debian](https://www.debian.org/): A dynamic module build is available in the Debian package repository: [libnginx-mod-nchan](https://packages.debian.org/sid/libnginx-mod-nchan).  \n Additionally, you can use the pre-built static module packages [nginx-common.deb](https://nchan.io/download/nginx-common.deb) and [nginx-extras.deb](https://nchan.io/download/nginx-extras.deb). Download both and install them with `dpkg -i`, followed by `sudo apt-get -f install`.\n - [Ubuntu](http://www.ubuntu.com/):  [nginx-common.ubuntu.deb](https://nchan.io/download/nginx-common.ubuntu.deb) and [nginx-extras.ubuntu.deb](https://nchan.io/download/nginx-extras.ubuntu.deb). Download both and install them with `dpkg -i`, followed by `sudo apt-get -f install`. Who knows when Ubuntu will add Nchan to their repository?...\n - [Fedora](https://fedoraproject.org): Dynamic module builds for Nginx > 1.10.0 are available: [nginx-mod-nchan.x86_64.rpm](https://nchan.io/download/nginx-mod-nchan.x86-64.rpm), [nginx-mod-nchan.src.rpm](https://nchan.io/download/nginx-mod-nchan.src.rpm). \n - [Heroku](https://heroku.com): A buildpack for compiling Nchan into Nginx is available: [nchan-buildpack](https://github.com/andjosh/nchan-buildpack). A one-click, readily-deployable app is also available: [nchan-heroku](https://github.com/andjosh/nchan-heroku).\n - A statically compiled binary and associated linux nginx installation files are also [available as a tarball](https://nchan.io/download/nginx-nchan-latest.tar.gz).\n\n\n#### Build From Source\nGrab the latest copy of Nginx from [nginx.org](http://nginx.org). Grab the latest Nchan source from [github](https://github.com/slact/nchan/releases). Follow the instructions for [building Nginx](https://www.nginx.com/resources/wiki/start/topics/tutorials/install/#source-releases), except during the `configure` stage, add\n```\n./configure --add-module=path/to/nchan ...\n```\n\nIf you're using Nginx  > 1.9.11, you can build Nchan as a [dynamic module](https://www.nginx.com/blog/dynamic-modules-nginx-1-9-11/) with `--add-dynamic-module=path/to/nchan`\n\nRun `make`, then `make install`.\n\n## Getting Started\n\nOnce you've built and installed Nchan, it's very easy to start using. Add two locations to your nginx config:\n\n```nginx\n#...\nhttp {  \n  server {\n    #...\n    \n    location = /sub {\n      nchan_subscriber;\n      nchan_channel_id $arg_id;\n    }\n    \n    location = /pub {\n      nchan_publisher;\n      nchan_channel_id $arg_id;\n    }\n  }\n}\n```\n\nYou can now publish messages to channels by `POST`ing data to `/pub?id=channel_id` , and subscribe by pointing Websocket, EventSource, or [NchanSubscriber.js](https://github.com/slact/nchan.js) to `sub/?id=channel_id`. It's that simple.\n\nBut Nchan is very flexible and highly configurable. So, of course, it can get a lot more complicated...\n\n### Conceptual Overview\n\nThe basic unit of most pub/sub solutions is the messaging *channel*. Nchan is no different. Publishers send messages to channels with a certain *channel id*, and subscribers subscribed to those channels receive them. Some number of messages may be buffered for a time in a channel's message buffer before they are deleted. Pretty simple, right? \n\nWell... the trouble is that nginx configuration does not deal with channels, publishers, and subscribers. Rather, it has several sections for incoming requests to match against *server* and *location* sections. **Nchan configuration directives map servers and locations onto channel publishing and subscribing endpoints**:\n\n```nginx\n#very basic nchan config\nworker_processes 5;\n\nhttp {  \n  server {\n    listen       80;\n    \n    location = /sub {\n      nchan_subscriber;\n      nchan_channel_id foobar;\n    }\n    \n    location = /pub {\n      nchan_publisher;\n      nchan_channel_id foobar;\n    }\n  }\n}\n```\n\nThe above maps requests to the URI `/sub` onto the channel `foobar`'s *subscriber endpoint* , and similarly `/pub` onto channel `foobar`'s *publisher endpoint*.\n\n\n## Publisher Endpoints\n\nPublisher endpoints are Nginx config *locations* with the [*`nchan_publisher`*](#nchan_publisher) directive.\n\nMessages can be published to a channel by sending HTTP **POST** requests with the message contents to the *publisher endpoint* locations. You can also publish messages through a **Websocket** connection to the same location.\n\n```nginx\n  location /pub {\n    #example publisher location\n    nchan_publisher;\n    nchan_channel_id foo;\n    nchan_channel_group test;\n    nchan_message_buffer_length 50;\n    nchan_message_timeout 5m;\n  }\n```\n\n<!-- tag:publisher -->\n\n### Publishing Messages\n\nRequests and websocket messages are responded to with information about the channel at time of message publication. Here's an example from publishing with `curl`:\n\n```console\n>  curl --request POST --data \"test message\" http://127.0.0.1:80/pub\n\n queued messages: 5\n last requested: 18 sec. ago\n active subscribers: 0\n last message id: 1450755280:0\n```\n\nThe response can be in plaintext (as above), JSON, or XML, based on the request's *`Accept`* header:\n\n```console\n> curl --request POST --data \"test message\" -H \"Accept: text/json\" http://127.0.0.2:80/pub\n\n {\"messages\": 5, \"requested\": 18, \"subscribers\": 0, \"last_message_id\": \"1450755280:0\" }\n```\n\nWebsocket publishers also receive the same responses when publishing, with the encoding determined by the *`Accept`* header present during the handshake.\n\nThe response code for an HTTP request is *`202` Accepted* if no subscribers are present at time of publication, or *`201` Created* if at least 1 subscriber was present.\n\nMetadata can be added to a message when using an HTTP POST request for publishing. A `Content-Type` header will be associated as the message's content type (and output to Long-Poll, Interval-Poll, and multipart/mixed subscribers). A `X-EventSource-Event` header can also be used to associate an EventSource `event:` line value with a message.\n\n### Other Publisher Endpoint Actions\n\n**HTTP `GET`** requests return channel information without publishing a message. The response code is `200` if the channel exists, and `404` otherwise:  \n```console\n> curl --request POST --data \"test message\" http://127.0.0.2:80/pub\n  ...\n\n> curl -v --request GET -H \"Accept: text/json\" http://127.0.0.2:80/pub\n\n {\"messages\": 1, \"requested\": 7, \"subscribers\": 0, \"last_message_id\": \"1450755421:0\" }\n```\n\n\n**HTTP `DELETE`** requests delete a channel and end all subscriber connections. Like the `GET` requests, this returns a `200` status response with channel info if the channel existed, and a `404` otherwise.\n\n### How Channel Settings Work\n\n*A channel's configuration is set to the that of its last-used publishing location.*\nSo, if you want a channel to behave consistently, and want to publish to it from multiple locations, *make sure those locations have the same configuration*.\n\nYou can also can use differently-configured publisher locations to dynamically update a channel's message buffer settings. This can be used to erase messages or to scale an existing channel's message buffer as desired.\n\n## Subscriber Endpoints\n\nSubscriber endpoints are Nginx config *locations* with the [*`nchan_subscriber`*](#nchan_subscriber) directive.\n\nNchan supports several different kinds of subscribers for receiving messages: [*Websocket*](#websocket), [*EventSource*](#eventsource) (Server Sent Events),  [*Long-Poll*](#long-polling), [*Interval-Poll*](#interval-polling). [*HTTP chunked transfer*](#http-chunked-transfer), and [*HTTP multipart/mixed*](#http-multipart-mixed).\n\n```nginx\n  location /sub {\n    #example subscriber location\n    nchan_subscriber;\n    nchan_channel_id foo;\n    nchan_channel_group test;\n    nchan_subscriber_first_message oldest;\n  }\n```\n\n<!-- tag:subscriber -->\n\n- ### Long-Polling\n  The tried-and-true server-push method supported by every browser out there.  \n  Initiated by sending an HTTP `GET` request to a channel subscriber endpoint.  \n  The long-polling subscriber walks through a channel's message queue via the built-in cache mechanism of HTTP clients, namely with the \"`Last-Modified`\" and \"`Etag`\" headers. Explicitly, to receive the next message for given a long-poll subscriber response, send a request with the \"`If-Modified-Since`\" header set to the previous response's \"`Last-Modified`\" header, and \"`If-None-Match`\" likewise set to the previous response's \"`Etag`\" header.  \n  Sending a request without a \"`If-Modified-Since`\" or \"`If-None-Match`\" headers returns the oldest message in a channel's message queue, or waits until the next published message, depending on the value of the `nchan_subscriber_first_message` config directive.  \n  A message's associated content type, if present, will be sent to this subscriber with the `Content-Type` header.\n  <!-- tag:subscriber-longpoll -->\n  \n- ### Interval-Polling\n  Works just like long-polling, except if the requested message is not yet available, immediately responds with a `304 Not Modified`.\n  Nchan cannot automatically distinguish between long-poll and interval-poll subscriber requests, so long-polling must be disabled for a subscriber location if you wish to use interval-polling.\n\n- ### Websocket\n  Bidirectional communication for web browsers. Part of the [HTML5 spec](http://www.w3.org/TR/2014/REC-html5-20141028/single-page.html). Nchan supports the latest protocol version 13 ([RFC 6455](https://tools.ietf.org/html/rfc6455)).  \n  Initiated by sending a websocket handshake to the desired subscriber endpoint location.  \n  If the websocket connection is closed by the server, the `close` frame will contain the HTTP response code and status line describing the reason for closing the connection. Server-initiated keep-alive pings can be configured with the [`nchan_websocket_ping_interval`](#nchan_websocket_ping_interval) config directive.\n  Messages are delivered to subscribers in `text` websocket frames, except if a message's `content-type` is \"`application/octet-stream`\" -- then it is delivered in a `binary` frame.\n  <br />\n  Websocket subscribers can use the custom `ws+meta.nchan` subprotocol to receive message metadata with messages, making websocket connections resumable. Messages received with this subprotocol are of the form\n  <pre>\n  id: message_id\n  content-type: message_content_type\n  \\n\n  message_data\n  </pre>   \n  The `content-type:` line may be omitted.\n  <br />\n  #### Websocket Publisher\n  Messages published through a websocket connection can be forwarded to an upstream application with the [`nchan_publisher_upstream_request`](#nchan_publisher_upstream_request) config directive.   \n  Messages published in a binary frame are automatically given the `content-type` \"`application/octet-stream`\".\n  #### Permessage-deflate\n  Nchan version 1.1.8 and above supports the [permessage-deflate protocol extension](https://tools.ietf.org/html/rfc7692). Messages are deflated once when they are published, and then can be broadcast to any number of compatible websocket subscribers. Message deflation is enabled by setting the [`nchan_deflate_message_for_websocket on;`](#nchan_deflate_message_for_websocket) directive in a publisher location.\n  <br />\n  The deflated data is stored alongside the original message in memory, or, if large enough, on disk. This means more [shared memory](#nchan_shared_memory_size) is necessary when using `nchan_deflate_message_for_websocket`.\n  <br />\n  Deflation parameters (speed, memory use, strategy, etc.), can be tweaked using the [`nchan_permessage_deflate_compression_window`](#nchan_permessage_deflate_compression_window), [`nchan_permessage_deflate_compression_level`](#nchan_permessage_deflate_compression_level),\n  [`nchan_permessage_deflate_compression_strategy`](#nchan_permessage_deflate_compression_strategy), and \n  [`nchan_permessage_deflate_compression_window`](#nchan_permessage_deflate_compression_window) settings.\n  <br />\n  Nchan also supports the (deprecated) [perframe-deflate extension](https://tools.ietf.org/html/draft-tyoshino-hybi-websocket-perframe-deflate-06) still in use by Safari as `x-webkit-perframe-deflate`.\n  <br />\n  <!-- tag:subscriber-websocket -->\n  \n- ### EventSource\n  Also known as [Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) or SSE, it predates Websockets in the [HTML5 spec](http://www.w3.org/TR/2014/REC-html5-20141028/single-page.html), and is a [very simple protocol](http://www.w3.org/TR/eventsource/#event-stream-interpretation).  \n  Initiated by sending an HTTP `GET` request to a channel subscriber endpoint with the \"`Accept: text/event-stream`\" header.    \n  Each message `data: ` segment will be prefaced by the message `id: `.  \n  To resume a closed EventSource connection from the last-received message, one *should* start the connection with the \"`Last-Event-ID`\" header set to the last message's `id`.  \n  Unfortunately, browsers [don't support setting](http://www.w3.org/TR/2011/WD-eventsource-20111020/#concept-event-stream-last-event-id) this header for an `EventSource` object, so by default the last message id is set either from the \"`Last-Event-Id`\" header or the `last_event_id` url query string argument.  \n  This behavior can be configured via the [`nchan_subscriber_last_message_id`](#nchan_subscriber_last_message_id) config.  \n  A message's `content-type` will not be received by an EventSource subscriber, as the protocol makes no provisions for this metadata.\n  A message's associated `event` type, if present, will be sent to this subscriber with the `event:` line.  \n  <!-- tag:subscriber-eventsource -->\n  \n- ### HTTP [multipart/mixed](http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html#z0)\n  The `multipart/mixed` MIMEtype was conceived for emails, but hey, why not use it for HTTP? It's easy to parse and includes metadata with each message.  \n  Initiated by including an `Accept: multipart/mixed` header.  \n  The response headers and the unused \"preamble\" portion of the response body are sent right away, with the boundary string generated randomly for each subscriber.  Each subsequent message will be sent as one part of the multipart message, and will include the message time and tag (`Last-Modified` and `Etag`) as well as the optional `Content-Type` headers.  \n  Each message is terminated with the next multipart message's boundary **without a trailing newline**. While this conforms to the multipart spec, it is unusual as multipart messages are defined as *starting*, rather than ending with a boundary.  \n  A message's associated content type, if present, will be sent to this subscriber with the `Content-Type` header.\n  <!-- tag:subscriber-multipart -->\n  \n- ### HTTP Raw Stream\n  A simple subscription method similar to the [streaming subscriber](https://github.com/wandenberg/nginx-push-stream-module/blob/master/docs/directives/subscribers.textile#push_stream_subscriber) of the [Nginx HTTP Push Stream Module](https://github.com/wandenberg/nginx-push-stream-module). Messages are appended to the response body, separated by a newline or configurable by `nchan_subscriber_http_raw_stream_separator`.\n  <!-- tag:subscriber-rawstream -->\n\n- ### HTTP [Chunked Transfer](http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1)\n  This subscription method uses the `chunked` `Transfer-Encoding` to receive messages.   \n  Initiated by explicitly including `chunked` in the [`TE` header](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.39):  \n  `TE: chunked` (or `TE: chunked;q=??` where the qval > 0)  \n  The response headers are sent right away, and each message will be sent as an individual chunk. Note that because a zero-length chunk terminates the transfer, **zero-length messages will not be sent** to the subscriber.  \n  Unlike the other subscriber types, the `chunked` subscriber cannot be used with http/2 because it disallows chunked encoding.\n  <!-- tag:subscriber-chunked -->\n\n## PubSub Endpoint  \n\nPubSub endpoints are Nginx config *locations* with the [*`nchan_pubsub`*](#nchan_pubsub) directive.\n\nA combination of *publisher* and *subscriber* endpoints, this location treats all HTTP `GET`\nrequests as subscribers, and all HTTP `POST` as publishers. Channels cannot be deleted through a pubsub endpoing with an HTTP `DELETE` request.\n\nOne simple use case is an echo server:\n\n```nginx\n  location = /pubsub {\n    nchan_pubsub;\n    nchan_channel_id foo;\n    nchan_channel_group test;\n  }\n```\n\nA more interesting setup may set different publisher and subscriber channel ids:\n\n```nginx\n  location = /pubsub {\n    nchan_pubsub;\n    nchan_publisher_channel_id foo;\n    nchan_subscriber_channel_id bar;\n    nchan_channel_group test;\n  }\n```\n\nHere, subscribers will listen for messages on channel `foo`, and publishers will publish messages to channel `bar`. This can be useful when setting up websocket proxying between web clients and your application.\n<!-- tag:pubsub -->\n\n## The Channel ID\n\nSo far the examples have used static channel ids, which is not very useful. In practice, the channel id can be set to any nginx *variable*, such as a querystring argument, a header value, or a part of the location url:\n\n```nginx\n  location = /sub_by_ip {\n    #channel id is the subscriber's IP address\n    nchan_subscriber;\n    nchan_channel_id $remote_addr;\n  }\n  \n  location /sub_by_querystring {\n    #channel id is the query string parameter chanid\n    # GET /sub/sub_by_querystring?foo=bar&chanid=baz will have the channel id set to 'baz'\n    nchan_subscriber;\n    nchan_channel_id $arg_chanid;\n  }\n\n  location ~ /sub/(\\w+)$ {\n    #channel id is the word after /sub/\n    # GET /sub/foobar_baz will have the channel id set to 'foobar_baz'\n    # I hope you know your regular expressions...\n    nchan_subscriber;\n    nchan_channel_id $1; #first capture of the location match\n  }\n```\n\nI recommend using the last option, a channel id derived from the request URL via a regular expression. It makes things nice and RESTful.\n\n<!-- tag:channel-id -->\n\n### Channel Multiplexing\n\nWith channel multiplexing, subscribers can subscribe to up to 255 channels per connection. Messages published to all the specified channels will be delivered in-order to the subscriber. There are two ways to enable multiplexing:\n\nUp to 7 channel ids can be specified for the `nchan_channel_id` or `nchan_channel_subscriber_id` config directive:\n\n```nginx\n  location ~ /multisub/(\\w+)/(\\w+)$ {\n    nchan_subscriber;\n    nchan_channel_id \"$1\" \"$2\" \"common_channel\";\n    #GET /multisub/foo/bar will be subscribed to:\n    # channels 'foo', 'bar', and 'common_channel',\n    #and will receive messages from all of the above.\n  }\n```\n\nFor more than 7 channels, `nchan_channel_id_split_delimiter` can be used to split the `nchan_channel_id` or `nchan_channel_subscriber_id` into up to 255 individual channel ids:\n\n```nginx\n  location ~ /multisub-split/(.*)$ {\n    nchan_subscriber;\n    nchan_channel_id \"$1\";\n    nchan_channel_id_split_delimiter \",\";\n    #GET /multisub-split/foo,bar,baz,a will be subscribed to:\n    # channels 'foo', 'bar', 'baz', and 'a'\n    #and will receive messages from all of the above.\n  }\n```\n\nIt is also possible to publish to multiple channels with a single request as well as delete multiple channels with a single request, with similar configuration:\n\n```nginx\n  location ~ /multipub/(\\w+)/(\\w+)$ {\n    nchan_publisher;\n    nchan_channel_id \"$1\" \"$2\" \"another_channel\";\n    #POST /multipub/foo/bar will publish to:\n    # channels 'foo', 'bar', 'another_channel'\n    #DELETE /multipub/foo/bar will delete:\n    # channels 'foo', 'bar', 'another_channel'\n  }\n```\n\nWhen a channel is deleted, all of its messages are deleted, and all of its subscribers' connection are closed -- including ones subscribing through a multiplexed location. For example, suppose a subscriber is subscribed to channels \"foo\" and \"bar\" via a single multiplexed connection. If \"foo\" is deleted, the connection is closed, and the subscriber therefore loses the \"bar\" subscription as well.\n\nSee the [Channel Security](#securing-channels) section about using good IDs and keeping private channels secure.\n\n<!-- tag:channel-multiplexing -->\n\n### Channel Groups\n\nChannels can be associated with groups to avoid channel ID conflicts:\n\n```nginx\n  location /test_pubsub {\n    nchan_pubsub;\n    nchan_channel_group \"test\";\n    nchan_channel_id \"foo\";\n  }\n  \n  location /pubsub {\n    nchan_pubsub;\n    nchan_channel_group \"production\";\n    nchan_channel_id \"foo\";\n    #same channel id, different channel group. Thus, different channel.\n  }\n  \n  location /flexgroup_pubsub {\n    nchan_pubsub;\n    nchan_channel_group $arg_group;\n    nchan_channel_id \"foo\";\n    #group can be set with request variables too\n  }\n```\n\n#### Limits and Accounting\n\nGroups can be used to track aggregate channel usage, as well as set limits on the number of channels, subscribers, stored messages, memory use, etc:\n\n```nginx\n  #enable group accounting\n  nchan_channel_group_accounting on;\n  \n  location ~ /pubsub/(\\w+)$ {\n    nchan_pubsub;\n    nchan_channel_group \"limited\";\n    nchan_channel_id $1;\n  }\n  \n  location ~ /prelimited_pubsub/(\\w+)$ {\n    nchan_pubsub;\n    nchan_channel_group \"limited\";\n    nchan_channel_id $1;\n    nchan_group_max_subscribers 100;\n    nchan_group_max_messages_memory 50M;\n  }\n  \n  location /group {\n    nchan_channel_group limited;\n    nchan_group_location;\n    nchan_group_max_channels $arg_max_channels;\n    nchan_group_max_messages $arg_max_messages;\n    nchan_group_max_messages_memory $arg_max_messages_mem;\n    nchan_group_max_messages_disk $arg_max_messages_disk;\n    nchan_group_max_subscribers $arg_max_subs;\n  }\n```\n\nHere, `/group` is an `nchan_group_location`, which is used for accessing and modifying group data. To get group data, send a `GET` request to a `nchan_group_location`:\n\n```sh\n>  curl http://localhost/group\n\nchannels: 10\nsubscribers: 0\nmessages: 219\nshared memory used by messages: 42362 bytes\ndisk space used by messages: 0 bytes\nlimits:\n  max channels: 0\n  max subscribers: 0\n  max messages: 0\n  max messages shared memory: 0\n  max messages disk space: 0  \n```\n\nBy default, the data is returned in human-readable plaintext, but can also be formatted as JSON, XML, or YAML:\n\n```sh\n>  curl -H \"Accept: text/json\" http://localhost/group\n\n{\n  \"channels\": 21,\n  \"subscribers\": 40,\n  \"messages\": 53,\n  \"messages_memory\": 19941,\n  \"messages_disk\": 0,\n  \"limits\": {\n    \"channels\": 0,\n    \"subscribers\": 0,\n    \"messages\": 0,\n    \"messages_memory\": 0,\n    \"messages_disk\": 0\n  }\n}\n```\n\nThe data in the response are for the single Nchan instance only, regardless of whether Redis is used. A limit of 0 means 'unlimited'.\n\nLimits can be set per-location, as with the above `/prelimited_pubsub/...` location, or with a POST request to the `nchan_group_location`:\n```sh\n>  curl -X POST \"http://localhost/group?max_channels=15&max_subs=1000&max_messages_disk=0.5G\"\n\nchannels: 0\nsubscribers: 0\nmessages: 0\nshared memory used by messages: 0 bytes\ndisk space used by messages: 0 bytes\nlimits:\n  max channels: 15\n  max subscribers: 1000\n  max messages: 0\n  max messages shared memory: 0\n  max messages disk space: 536870912\n\n```\n\nLimits are only applied locally, regardless of whether Redis is enabled. \nIf a publisher or subscriber request exceeds a group limit, Nchan will respond to it with a `403 Forbidden` response.\n\n<!-- tag:group -->\n\n## Hooks and Callbacks\n\n<!-- tag:hook -->\n  \n### Request Authorization\n\nThis feature, configured with [`nchan_authorize_request`](#nchan_authorize_request), behaves just like the Nginx [http_auth_request module](http://nginx.org/en/docs/http/ngx_http_auth_request_module.html#auth_request_set).\n\nConsider the configuration:\n```nginx\n  upstream my_app {\n    server 127.0.0.1:8080;\n  }\n  location = /auth {\n    proxy_pass http://my_app/pubsub_authorize;\n    proxy_pass_request_body off;\n    proxy_set_header Content-Length \"\";\n    proxy_set_header X-Subscriber-Type $nchan_subscriber_type;\n    proxy_set_header X-Publisher-Type $nchan_publisher_type;\n    proxy_set_header X-Prev-Message-Id $nchan_prev_message_id;\n    proxy_set_header X-Channel-Id $nchan_channel_id;\n    proxy_set_header X-Original-URI $request_uri;\n    proxy_set_header X-Forwarded-For $remote_addr;\n  }\n  \n  location ~ /pubsub/auth/(\\w+)$ {\n    nchan_channel_id $1;\n    nchan_authorize_request /auth;\n    nchan_pubsub;\n    nchan_channel_group test;\n  }\n```\n\nHere, any request to the location `/pubsub/auth/<...>` will need to be authorized by your application (`my_app`). Nginx will generate a `GET /pubsub_authorize` request to the application, with additional headers set by the `proxy_set_header` directives. Note that Nchan-specific variables are available for this authorization request. Once your application receives this request, it should decide whether or not to authorize the subscriber. This can be done based on a forwarded session cookie, IP address, or any set of parameters of your choosing. If authorized, it should respond with an empty `200 OK` response.  \nAll non-`2xx` response codes (such as `403 Forbidden`) are interpreted as authorization failures. In this case, the failing response is proxied to the client. \n\nNote that Websocket and EventSource clients will only try to authorize during the initial handshake request, whereas Long-Poll and Interval-Poll subscribers will need to be authorized each time they request the next message, which may flood your application with too many authorization requests.\n\n<!-- commands: nchan_authorize_request -->\n\n### Subscriber Presence\n\nSubscribers can notify an application when they have subscribed and unsubscribed to a channel using the [`nchan_subscribe_request`](#nchan_subscribe_request)\nand [`nchan_unsubscribe_request`](#nchan_unsubscribe_request) settings. \nThese should point to Nginx locations configured to forward requests to an upstream proxy (your application):\n\n```nginx\n  location ~ /sub/(\\w+)$ {\n    nchan_channel_id $1;\n    nchan_subscribe_request /upstream/sub;\n    nchan_unsubscribe_request /upstream/unsub;\n    nchan_subscriber;\n    nchan_channel_group test;\n  }\n\n  location = /upstream/unsub {\n    proxy_pass http://127.0.0.1:9292/unsub;\n    proxy_ignore_client_abort on;  #!!!important!!!!\n    proxy_set_header X-Subscriber-Type $nchan_subscriber_type;\n    proxy_set_header X-Channel-Id $nchan_channel_id;\n    proxy_set_header X-Original-URI $request_uri;\n  } \n  location = /upstream/sub {\n    proxy_pass http://127.0.0.1:9292/sub;\n    proxy_set_header X-Subscriber-Type $nchan_subscriber_type;\n    proxy_set_header X-Message-Id $nchan_message_id;\n    proxy_set_header X-Channel-Id $nchan_channel_id;\n    proxy_set_header X-Original-URI $request_uri;\n  } \n```\n\nIn order for `nchan_unsubscribe_request` to work correctly, the location it points to must have `proxy_ignore_client_abort on;`. Otherwise, suddenly aborted subscribers may not trigger an unsubscribe request.\n\nNote that the subscribe/unsubscribe hooks are **disabled for long-poll and interval-poll clients**, because they would trigger these hooks each time they receive a message.\n\n<!-- commands: nchan_subscribe_request nchan_unsubscribe_request -->\n\n### Message Forwarding\n\nMessages can be forwarded to an upstream application before being published using the `nchan_publisher_upstream_request` setting:\n\n```nginx\n  location ~ /pub/(\\w+)$ {\n    #publisher endpoint\n    nchan_channel_id $1;\n    nchan_pubsub;\n    nchan_publisher_upstream_request /upstream_pub;\n  }\n  \n  location = /upstream_pub {\n    proxy_pass http://127.0.0.1:9292/pub;\n    proxy_set_header X-Publisher-Type $nchan_publisher_type;\n    proxy_set_header X-Prev-Message-Id $nchan_prev_message_id;\n    proxy_set_header X-Channel-Id $nchan_channel_id;\n    proxy_set_header X-Original-URI $request_uri;\n  } \n```\nWith this configuration, incoming messages are first `POST`ed to `http://127.0.0.1:9292/pub`.\nThe upstream response code determines how publishing will proceed:\n  - `304 Not Modified` publishes the message as received, without modifification.\n  - `204 No Content` discards the message\n  - `200 OK` is used for modifying the message. Instead of the original incoming message, the message contained in this HTTP response is published.\n\nThere are two main use cases for `nchan_publisher_upstream_request`: forwarding incoming data from Websocket publishers to an application, and mutating incoming messages.\n\n<!-- commands: nchan_publisher_upstream_request -->\n\n## Storage\n\nNchan can stores messages in memory, on disk, or via Redis. Memory storage is much faster, whereas Redis has additional overhead as is considerably slower for publishing messages, but offers near unlimited scalability for broadcast use cases with far more subscribers than publishers.\n\n### Memory Storage\n\nThis default storage method uses a segment of shared memory to store messages and channel data. Large messages as determined by Nginx's caching layer are stored on-disk. The size of the memory segment is configured with `nchan_shared_memory_size`. Data stored here is not persistent, and is lost if Nginx is restarted or reloaded.\n\n<!-- tag:memstore -->\n\n### Redis\n\n[Redis](http://redis.io) can be used to add **data persistence** and **horizontal scalability**, **failover** and **high availability** to your Nchan setup. \n\n<!-- tag:redis -->\n\n#### Connecting to a Redis Server\nTo connect to a single Redis master server, use an `upstream` with `nchan_redis_server` and `nchan_redis_pass` settings:\n\n```nginx\nhttp {\n  upstream my_redis_server {\n    nchan_redis_server 127.0.0.1;\n  }\n  server {\n    listen 80;\n    \n    location ~ /redis_sub/(\\w+)$ {\n      nchan_subscriber;\n      nchan_channel_id $1;\n      nchan_redis_pass my_redis_server;\n    }\n    location ~ /redis_pub/(\\w+)$ {\n      nchan_redis_pass my_redis_server;\n      nchan_publisher;\n      nchan_channel_id $1;\n    }\n  }\n} \n```\n\nAll servers with the above configuration connecting to the same redis server share channel and message data.\n\nChannels that don't use Redis can be configured side-by-side with Redis-backed channels, provided the endpoints never overlap. (This can be ensured, as above, by setting separate `nchan_channel_group`s.). Different locations can also connect to different Redis servers.\n\nNchan can work with a single Redis master. It can also auto-discover and use Redis slaves to balance PUBSUB traffic.\n\n<!-- commands: nchan_redis_server nchan_redis_pass -->\n\n#### Redis Cluster\nNchan also supports using Redis Cluster, which adds scalability via sharding channels among cluster nodes. Redis cluster also provides **automatic failover**, **high availability**, and eliminates the single point of failure of one shared Redis server. It is configured and used like so:\n\n```nginx\nhttp {\n  upstream redis_cluster {\n    nchan_redis_server redis://127.0.0.1:7000;\n    nchan_redis_server redis://127.0.0.1:7001;\n    nchan_redis_server redis://127.0.0.1:7002;\n    # you don't need to specify all the nodes, they will be autodiscovered\n    # however, it's recommended that you do specify at least a few master nodes.\n  }\n  server {\n    listen 80;\n    \n    location ~ /sub/(\\w+)$ {\n      nchan_subscriber;\n      nchan_channel_id $1;\n      nchan_redis_pass redis_cluster;\n    }\n    location ~ /pub/(\\w+)$ {\n      nchan_publisher;\n      nchan_channel_id $1;\n      nchan_redis_pass redis_cluster;\n    }\n  }\n} \n```\n\n<!-- commands: nchan_redis_server nchan_redis_pass -->\n\n##### High Availability\nRedis Cluster connections are designed to be resilient and try to recover from errors. Interrupted connections will have their commands queued until reconnection, and Nchan will publish any messages it successfully received while disconnected. Nchan is also adaptive to cluster modifications. It will add new nodes and remove them as needed.\n\nAll Nchan servers sharing a Redis server or cluster should have their times synchronized (via ntpd or your favorite ntp daemon). Failure to do so may result in missed or duplicate messages.\n\n##### Failover Recovery\nStarting with version 1.3.0, Nchan will attempt to recover from cluster node failures, keyslot errors, and cluster epoch changes without disconnecting from the entire cluster. It will attempt to do this until [`nchan_redis_cluster_max_failing_time`](#nchan_redis_cluster_max_failing_time) is exceeded. Additionally, [recovery attempt delays](#nchan_redis_cluster_recovery_delay) have configurable [jitter](#nchan_redis_cluster_recovery_delay_jitter), [exponential backoff](#nchan_redis_cluster_recovery_delay_backoff), and [maximum](#nchan_redis_cluster_recovery_delay_max) values.\n\n#### Using Redis securely\n\nRedis servers can be connected to via TLS by using the [`nchan_redis_ssl`](#nchan_redis_ssl) config setting in an `upstream` block, or by using the `rediss://`  schema for the server URLs.\n\nA password and optional username for the `AUTH` command can be set by the [`nchan_redis_username`](#nchan_redis_username) and [`nchan_redis_password`](#nchan_redis_password) config settings in an `upstream` block, or by using the `redis://<username>:<password>@hostname` server URL schema.\n\nNote that autodiscovered Redis nodes inherit their parent's SSL, username, and password settings.\n\n#### Tweaks and Optimizations\n\nAs of version 1.2.0, Nchan uses Redis slaves to load-balance PUBSUB traffic. By default, there is an equal chance that a channel's PUBSUB subscription will go to any master or slave. The [`nchan_redis_subscribe_weights`](#nchan_redis_subscribe_weights) setting is available to fine-tune this load-balancing.\n\nAlso from 1.2.0 onward, [`nchan_redis_optimize_target`](#nchan_redis_optimize_target) can be used to prefer optimizing Redis slaves for CPU or bandwidth. For heavy publishing loads, the tradeoff is very roughly 35% replication bandwidth per slave to 30% CPU load on slaves.\n\n#### Performance Statistics\n\nRedis command statistics were added in version 1.3.5. These provide total number of times different Redis commands were run on, and the total amount of time they took. The stats are for a given Nchan server, *not* all servers connected to a Redis upstream. They are grouped by each upstream, and totaled per node.\n\n```nginx\nhttp {\n  upstream my_redis_cluster {\n    nchan_redis_server 127.0.0.1;\n  }\n  \n  server {\n    #[...]\n    \n    location ~ /nchan_redis_cluster_stats$ {\n      nchan_redis_upstream_stats my_redis_cluster;\n    }\n  }\n\n```\n\nTo get the stats, send a GET request to the stats location.\n\n```console\n  curl http://localhost/nchan_redis_cluster_stats\n```\n\nThe response is JSON of the form:\n\n```js\n{\n  \"upstream\": \"redis_cluster\",\n  \"nodes\": [\n    {\n      \"address\"        : \"127.0.0.1:7000\",\n      \"id\"             : \"f13d71b1d14d8bf92b72cebee61421294e95dc72\",\n      \"command_totals\" : {\n        \"connect\"    : {\n          \"msec\"     : 357,\n          \"times\"    : 5\n        },\n        \"pubsub_subscribe\": {\n          \"msec\"     : 749,\n          \"times\"    : 37\n        },\n        \"pubsub_unsubsribe\": {\n          \"msec\"     : 332,\n          \"times\"    : 37\n        }\n        /*[...]*/\n      }\n    },\n    {\n      \"address\"        : \"127.0.0.1:7001\",\n      \"id\"             : \"b768ecb4152912bed6dc927e8f70284191a79ed7\",\n      \"command_totals\" : {\n        \"connect\"    : {\n          \"msec\"     : 4281,\n          \"times\"    : 5\n        },\n        \"pubsub_subscribe\": {\n          \"msec\"     : 309,\n          \"times\"    : 33\n        },\n        \"pubsub_unsubsribe\": {\n          \"msec\"     : 307,\n          \"times\"    : 30\n        },\n        /*[...]*/\n      },\n    }\n    /*[...]*/\n  ]\n}\n```\n\nFor brevity, the entire `command_totals` hash is omitted in this documentation.\n\n<!-- commands: nchan_redis_upstream_stats nchan_redis_upstream_stats_disconnected_timeout nchan_redis_upstream_stats_enabled -->\n\n## Introspection\n\nThere are several ways to see what's happening inside Nchan. These are useful for debugging application integration and for measuring performance.\n\n### Channel Events\n\nChannel events are messages automatically published by Nchan when certain events occur in a channel. These are very useful for debugging the use of channels. However, they carry a significant performance overhead and should be used during development, and not in production.\n\nChannel events are published to special 'meta' channels associated with normal channels. Here's how to configure them:\n\n```nginx\nlocation ~ /pubsub/(.+)$ {\n  nchan_pubsub;\n  nchan_channel_id $1;\n  nchan_channel_events_channel_id $1; #enables channel events for this location\n}\n\nlocation ~ /channel_events/(.+) {\n  #channel events subscriber location\n  nchan_subscriber;\n  nchan_channel_group meta; #\"meta\" is a SPECIAL channel group\n  nchan_channel_id $1;\n}\n```\n\nNote the `/channel_events/...` location has a *special* `nchan_channel_group`, `meta`. This group is reserved for accessing \"channel events channels\", or\"metachannels\".\n\nNow, say I subscribe to `/channel_events/foo` I will refer to this as the channel events subscriber.\n\nLet's see what this channel events subscriber receives when I publish messages to \n\nSubscribing to `/pubsub/foo` produces the channel event\n```\nsubscriber_enqueue foo\n```\n\nPublishing a message to `/pubsub/foo`:\n```\nchannel_publish foo\n```\n\nUnsubscribing from `/pubsub/foo`:\n```\nsubscriber_dequeue foo\n```\n\nDeleting `/pubsub/foo` (with HTTP `DELETE /pubsub/foo`):\n```\nchannel_delete foo\n```\n\nThe event string itself is configirable with [nchan_channel_event_string](#nchan_channel_event_string). By default, it is set to `$nchan_channel_event $nchan_channel_id`. \nThis string can use any Nginx and [Nchan variables](/#variables).\n\n\n### nchan_stub_status Stats\n\nLike Nginx's [stub_status](https://nginx.org/en/docs/http/ngx_http_stub_status_module.html),\n`nchan_stub_status` is used to get performance metrics.\n\n```nginx\n  location /nchan_stub_status {\n    nchan_stub_status;\n  }\n```\n\nSending a GET request to this location produces the response:\n\n```text\ntotal published messages: 1906\nstored messages: 1249\nshared memory used: 1824K\nchannels: 80\nsubscribers: 90\nredis pending commands: 0\nredis connected servers: 0\nredis unhealthy upstreams: 0\ntotal redis commands sent: 0\ntotal interprocess alerts received: 1059634\ninterprocess alerts in transit: 0\ninterprocess queued alerts: 0\ntotal interprocess send delay: 0\ntotal interprocess receive delay: 0\nnchan version: 1.1.5\n```\n\nHere's what each line means, and how to interpret it:\n  - `total published messages`: Number of messages published to all channels through this Nchan server.\n  - `stored messages`: Number of messages currently buffered in memory\n  - `shared memory used`: Total shared memory used for buffering messages, storing channel information, and other purposes. This value should be comfortably below `nchan_shared_memory_size`.\n  - `channels`: Number of channels present on this Nchan server.\n  - `subscribers`: Number of subscribers to all channels on this Nchan server.\n  - `redis pending commands`: Number of commands sent to Redis that are awaiting a reply. May spike during high load, especially if the Redis server is overloaded. Should tend towards 0.\n  - `redis connected servers`: Number of redis servers to which Nchan is currently connected.\n  - `redis unhealthy upstreams`: Number of redis upstreams (individual server or cluster mode) that are currently not usable for publishing and subscribing.\n  - `total redis commands sent`: Total number of commands this Nchan instance sent to Redis.\n  - `total interprocess alerts received`: Number of interprocess communication packets transmitted between Nginx workers processes for Nchan. Can grow at 100-10000 per second at high load.\n  - `interprocess alerts in transit`: Number of interprocess communication packets in transit between Nginx workers. May be nonzero during high load, but should always tend toward 0 over time.\n  - `interprocess queued alerts`: Number of interprocess communication packets waiting to be sent. May be nonzero during high load, but should always tend toward 0 over time.\n  - `total interprocess send delay`: Total amount of time interprocess communication packets spend being queued if delayed. May increase during high load.\n  - `total interprocess receive delay`: Total amount of time interprocess communication packets spend in transit if delayed. May increase during high load.\n  - `nchan_version`: current version of Nchan. Available for version 1.1.5 and above.\n\nAdditionally, when there is at least one `nchan_stub_status` location, this data is also available [through variables](#variables).\n  \n## Securing Channels\n\n### Securing Publisher Endpoints\nConsider the use case of an application where authenticated users each use a private, dedicated channel for live updates. The configuration might look like this:\n\n```nginx\nhttp {\n  server {\n    #available only on localhost\n    listen  127.0.0.1:8080;\n    location ~ /pub/(\\w+)$ {\n      nchan_publisher;\n      nchan_channel_group my_app_group;\n      nchan_channel_id $1;\n    }\n  }\n  \n  server {\n    #available to the world\n    listen 80;\n    \n    location ~ /sub/(\\w+)$ {\n      nchan_subscriber;\n      nchan_channel_group my_app_group;\n      nchan_channel_id $1;\n    }\n  }\n}\n\n```\n\nHere, the subscriber endpoint is available on a public-facing port 80, and the publisher endpoint is only available on localhost, so can be accessed only by applications residing on that machine. Another way to limit access to the publisher endpoint is by using the allow/deny settings:\n\n```nginx\n\n  server {\n    #available to the world\n    listen 80; \n    location ~ /pub/(\\w+)$ {\n      allow 127.0.0.1;\n      deny all;\n      nchan_publisher;\n      nchan_channel_group my_app_group;\n      nchan_channel_id $1;\n    }\n```\n\nHere, only the local IP 127.0.0.1 is allowed to use the publisher location, even though it is defined in a non-localhost server block.\n\n### Keeping a Channel Private\n\nA Channel ID that is meant to be private should be treated with the same care as a session ID token. Considering the above use case of one-channel-per-user, how can we ensure that only the authenticated user, and no one else, is able to access his channel? \n\nFirst, if you intend on securing the channel contents, you must use TLS/SSL:\n\n```nginx \nhttp {\n  server {\n    #available only on localhost\n    listen  127.0.0.1:8080;\n    #...publisher endpoint config\n  }\n  server {\n    #available to the world\n    listen 443 ssl;\n    #SSL config goes here\n    location ~ /sub/(\\w+)$ {\n      nchan_subscriber;\n      nchan_channel_group my_app_group;\n      nchan_channel_id $1;\n    }\n  }\n}\n```\n\nNow that you have a secure connection between the subscriber client and the server, you don't need to worry about the channel ID or messages being passively intercepted. This is a minimum requirement for secure message delivery, but it is not sufficient. \n\nYou must also take care to do at least one of the following:\n  - [Generate good, high-entropy Channel IDs](#good-ids).\n  - [Authorize all subscribers with the `nchan_authorize_request` config directive](#request-authorization).\n  - [Authorize subscribers and hide channel IDs with the \"`X-Accel-Redirect`\" mechanism](#x-accel-redirect).\n  \n#### Good IDs\n\nAn ID that can be guessed is an ID that can be hijacked. If you are not authenticating subscribers (as described below), a channel ID should be impossible to guess. Use at least 128 bits of entropy to generate a random token, associate it with the authenticated user, and share it only with the user's client. Do not reuse tokens, just as you would not reuse session IDs.\n\n#### X-Accel-Redirect\n\nThis feature uses the [X-Accel feature](https://www.nginx.com/resources/wiki/start/topics/examples/x-accel) of Nginx upstream proxies to perform an internal request to a subscriber endpoint.\nIt allows a subscriber client to be authenticated by your application, and then redirected by nginx internally to a location chosen by your application (such as a publisher or subscriber endpoint). This makes it possible to have securely authenticated clients that are unaware of the channel id they are subscribed to.\n\nConsider the following configuration:\n```nginx \nupstream upstream_app {\n  server 127.0.0.1:8080;\n}\n\nserver {\n  listen 80; \n  \n  location = /sub_upstream {\n    proxy_pass http://upstream_app/subscriber_x_accel_redirect;\n    proxy_set_header X-Forwarded-For $remote_addr;\n  }\n  \n  location ~ /sub/internal/(\\w+)$ {\n    internal; #this location only accessible for internal nginx redirects\n    nchan_subscriber;\n    nchan_channel_id $1;\n    nchan_channel_group test;\n  }\n}\n```\n\nAs commented, `/sub/internal/` is inaccessible from the outside:\n```console\n> curl  -v  http://127.0.0.1/sub/internal/foo\n  \n  < HTTP/1.1 404 Not Found\n  < Server: nginx/1.9.5\n  <\n  <html>\n  <head><title>404 Not Found</title></head>\n  <body bgcolor=\"white\">\n  <center><h1>404 Not Found</h1></center>\n  <hr><center>nginx/1.9.5</center>\n  </body>\n  </html>\n```\n\nBut if a request is made to `/sub_upstream`, it gets forwarded to your application (`my_app`) on port 8080 with the url `/subscriber_x_accel_redirect`.\nNote that you can set any forwarded headers here like any [`proxy_pass`](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass) Nginx location, \nbut unlike the case with `nchan_authorize_request`, Nchan-specific variables are not available.\n\nNow, your application must be set up to handle the request to `/subscriber_x_accel_redirect`. You should make sure the client is properly authenticated (maybe using a session cookie), and generate an associated channel id. If authentication fails, respond with a normal `403 Forbidden` response. You can also pass extra information about the failure in the response body and headers.\n\nIf your application successfully authenticates the subscriber request, you now need to instruct Nginx to issue an internal redirect to `/sub/internal/my_channel_id`.\nThis is accomplished by responding with an empty `200 OK` response that includes two headers:\n- `X-Accel-Redirect: /sub/internal/my_channel_id`\n- `X-Accel-Buffering: no`\n\nIn the presence of these headers, Nginx will not forward your app's response to the client, and instead will *internally* redirect to `/sub/internal/my_channel_id`. \nThis will behave as if the client had requested the subscriber endpoint location directly.\n\nThus using X-Accel-Redirect it is possible to both authenticate all subscribers *and* keep channel IDs completely hidden from subscribers.\n\nThis method is especially useful for EventSource and Websocket subscribers. Long-Polling subscribers will need to be re-authenticated for every new message, which may flood your application with too many authentication requests.\n\n### Revoking Channel Authorization\n\nIn some cases, you may want to revoke a particular subscriber's authorization for a given channel (e.g., if the user's permissions are changed). If the channel is unique to the subscriber, this is simply accomplished by deleting the channel. The same can be achieved for shared channels by subscribing each subscriber to both the shared channel and a subscriber-specific channel via a multiplexed connection. Deleting the subscriber-specific channel will terminate the subscriber''s connection, thereby also terminating their subscription to the shared channel. Consider the following configuration:\n\n```nginx\nlocation ~ /sub/(\\w+) {\n  nchan_subscriber;\n  nchan_channel_id shared_$1 user_$arg_userid;\n  nchan_authorize_request /authorize;\n}\n\nlocation /pub/user {\n  nchan_publisher;\n  nchan_channel_id user_$arg_userid;\n}\n```\n\nA request to `/sub/foo?userid=1234` will subscribe to channels \"shared_foo\" and \"user_1234\" via a multiplexed connection. If you later send a `DELETE` request to `/pub/user?userid=1234`, this subscriber will be disconnected and therefore unsubscribed from both \"user_1234\" and \"shared_foo\".\n  \n## Variables\n\nNchan makes several variables usabled in the config file:\n \n- `$nchan_channel_id`  \n  The channel id extracted from a publisher or subscriber location request. For multiplexed locations, this is the first channel id in the list.\n\n- `$nchan_channel_id1`, `$nchan_channel_id2`, `$nchan_channel_id3`, `$nchan_channel_id4`  \n  As above, but for the nth channel id in multiplexed channels.\n\n- `$nchan_subscriber_type`  \n  For subscriber locations, this variable is set to the subscriber type (websocket, longpoll, etc.).\n\n- `$nchan_channel_subscriber_last_seen`  \n  For publisher locations, this variable is set to the timestamp for the last connected subscriber.\n  \n- `$nchan_channel_subscriber_count`  \n  For publisher locations, this variable is set to the number of subscribers in the published channel.\n  \n- `$nchan_channel_message_count`  \n  For publisher locations, this variable is set to the number of messages buffered in the published channel.\n  \n- `$nchan_publisher_type`  \n  For publisher locations, this variable is set to the subscriber type (http or websocket).\n  \n- `$nchan_prev_message_id`, `$nchan_message_id`  \n  The current and previous (if applicable) message id for publisher request or subscriber response.\n\n- `$nchan_channel_event`  \n  For channel events, this is the event name. Useful when configuring `nchan_channel_event_string`.\n\n- `$nchan_version`  \n  Current Nchan version. Available since 1.1.5.\n  \nAdditionally, `nchan_stub_status` data is also exposed as variables. These are available only when `nchan_stub_status` is enabled on at least one location:\n\n- `$nchan_stub_status_total_published_messages`  \n- `$nchan_stub_status_stored_messages`  \n- `$nchan_stub_status_shared_memory_used`  \n- `$nchan_stub_status_channels`  \n- `$nchan_stub_status_subscribers`  \n- `$nchan_stub_status_redis_pending_commands`  \n- `$nchan_stub_status_redis_connected_servers`  \n- `$nchan_stub_status_redis_unhealthy_upstreams`  \n- `$nchan_stub_status_total_ipc_alerts_received`  \n- `$nchan_stub_status_ipc_queued_alerts`  \n- `$nchan_stub_status_total_ipc_send_delay`  \n- `$nchan_stub_status_total_ipc_receive_delay`  \n\n\n## Configuration Directives\n\n- **nchan_channel_id**  \n  arguments: 1 - 7  \n  default: `(none)`  \n  context: server, location, if  \n  > Channel id for a publisher or subscriber location. Can have up to 4 values to subscribe to up to 4 channels.    \n  [more details](#the-channel-id)  \n\n- **nchan_channel_id_split_delimiter**  \n  arguments: 1  \n  default: `(none)`  \n  context: server, location, if  \n  > Split the channel id into several ids for multiplexing using the delimiter string provided.    \n  [more details](#channel-multiplexing)  \n\n- **nchan_deflate_message_for_websocket** `[ on | off ]`  \n  arguments: 1  \n  default: `off`  \n  context: server, location  \n  > Store a compressed (deflated) copy of the message along with the original to be sent to websocket clients supporting the permessage-deflate protocol extension    \n\n- **nchan_eventsource_event**  \n  arguments: 1  \n  default: `(none)`  \n  context: server, location, if  \n  > Set the EventSource `event:` line to this value. When used in a publisher location, overrides the published message's `X-EventSource-Event` header and associates the message with the given value. When used in a subscriber location, overrides all messages' associated `event:` string with the given value.    \n\n- **nchan_eventsource_ping_comment**  \n  arguments: 1  \n  default: `(empty)`  \n  context: server, location, if  \n  > Set the EventSource comment `: ...` line for periodic pings from server to client. Newlines are not allowed. If empty, no comment is sent with the ping.    \n\n- **nchan_eventsource_ping_data**  \n  arguments: 1  \n  default: `(empty)`  \n  context: server, location, if  \n  > Set the EventSource `data:` line for periodic pings from server to client. Newlines are not allowed. If empty, no data is sent with the ping.    \n\n- **nchan_eventsource_ping_event**  \n  arguments: 1  \n  default: `ping`  \n  context: server, location, if  \n  > Set the EventSource `event:` line for periodic pings from server to client. Newlines are not allowed. If empty, no event type is sent with the ping.    \n\n- **nchan_eventsource_ping_interval** `<number> (seconds)`  \n  arguments: 1  \n  default: `0 (none)`  \n  context: server, location, if  \n  > Interval for sending ping messages to EventSource subscribers. Disabled by default.    \n\n- **nchan_longpoll_multipart_response** `[ off | on | raw ]`  \n  arguments: 1  \n  default: `off`  \n  context: server, location, if  \n  > when set to 'on', enable sending multiple messages in a single longpoll response, separated using the multipart/mixed content-type scheme. If there is only one available message in response to a long-poll request, it is sent unmodified. This is useful for high-latency long-polling connections as a way to minimize round-trips to the server. When set to 'raw', sends multiple messages using the http-raw-stream message separator.    \n\n- **nchan_permessage_deflate_compression_level** `[ 0-9 ]`  \n  arguments: 1  \n  default: `6`  \n  context: http  \n  > Compression level for the `deflate` algorithm used in websocket's permessage-deflate extension. 0: no compression, 1: fastest, worst, 9: slowest, best    \n\n- **nchan_permessage_deflate_compression_memlevel** `[ 1-9 ]`  \n  arguments: 1  \n  default: `8`  \n  context: http  \n  > Memory level for the `deflate` algorithm used in websocket's permessage-deflate extension. How much memory should be allocated for the internal compression state. 1 - minimum memory, slow and reduces compression ratio; 9 - maximum memory for optimal speed    \n\n- **nchan_permessage_deflate_compression_strategy** `[ default | filtered | huffman-only | rle | fixed ]`  \n  arguments: 1  \n  default: `default`  \n  context: http  \n  > Compression strategy for the `deflate` algorithm used in websocket's permessage-deflate extension. Use 'default' for normal data, For details see [zlib's section on copression strategies](http://zlib.net/manual.html#Advanced)    \n\n- **nchan_permessage_deflate_compression_window** `[ 9-15 ]`  \n  arguments: 1  \n  default: `10`  \n  context: http  \n  > Compression window for the `deflate` algorithm used in websocket's permessage-deflate extension. The base two logarithm of the window size (the size of the history buffer). The bigger the window, the better the compression, but the more memory used by the compressor.    \n\n- **nchan_publisher** `[ http | websocket ]`  \n  arguments: 0 - 2  \n  default: `http websocket`  \n  context: server, location, if  \n  legacy name: push_publisher  \n  > Defines a server or location as a publisher endpoint. Requests to a publisher location are treated as messages to be sent to subscribers. See the protocol documentation for a detailed description.    \n  [more details](#publisher-endpoints)  \n\n- **nchan_publisher_channel_id**  \n  arguments: 1 - 7  \n  default: `(none)`  \n  context: server, location, if  \n  > Channel id for publisher location.    \n\n- **nchan_publisher_upstream_request** `<url>`  \n  arguments: 1  \n  context: server, location, if  \n  > Send POST request to internal location (which may proxy to an upstream server) with published message in the request body. Useful for bridging websocket publishers with HTTP applications, or for transforming message via upstream application before publishing to a channel.    \n  > The upstream response code determines how publishing will proceed. A `200 OK` will publish the message from the upstream response's body. A `304 Not Modified` will publish the message as it was received from the publisher. A `204 No Content` will result in the message not being published.    \n  [more details](#message-forwarding)  \n\n- **nchan_pubsub** `[ http | websocket | eventsource | longpoll | intervalpoll | chunked | multipart-mixed | http-raw-stream ]`  \n  arguments: 0 - 6  \n  default: `http websocket eventsource longpoll chunked multipart-mixed`  \n  context: server, location, if  \n  > Defines a server or location as a pubsub endpoint. For long-polling, GETs subscribe. and POSTs publish. For Websockets, publishing data on a connection does not yield a channel metadata response. Without additional configuration, this turns a location into an echo server.    \n  [more details](#pubsub-endpoint)  \n\n- **nchan_subscribe_request** `<url>`  \n  arguments: 1  \n  context: server, location, if  \n  > Send GET request to internal location (which may proxy to an upstream server) after subscribing. Disabled for longpoll and interval-polling subscribers.    \n  [more details](#subscriber-presence)  \n\n- **nchan_subscriber** `[ websocket | eventsource | longpoll | intervalpoll | chunked | multipart-mixed | http-raw-stream ]`  \n  arguments: 0 - 5  \n  default: `websocket eventsource longpoll chunked multipart-mixed`  \n  context: server, location, if  \n  legacy name: push_subscriber  \n  > Defines a server or location as a channel subscriber endpoint. This location represents a subscriber's interface to a channel's message queue. The queue is traversed automatically, starting at the position defined by the `nchan_subscriber_first_message` setting.    \n  >  The value is a list of permitted subscriber types.    \n  [more details](#subscriber-endpoints)  \n\n- **nchan_subscriber_channel_id**  \n  arguments: 1 - 7  \n  default: `(none)`  \n  context: server, location, if  \n  > Channel id for subscriber location. Can have up to 4 values to subscribe to up to 4 channels.    \n\n- **nchan_subscriber_compound_etag_message_id**  \n  arguments: 1  \n  default: `off`  \n  context: server, location, if  \n  > Override the default behavior of using both `Last-Modified` and `Etag` headers for the message id.    \n  > Enabling this option packs the entire message id into the `Etag` header, and discards  \n  > `Last-Modified` and `If-Modified-Since` headers.    \n  [more details]()  \n\n- **nchan_subscriber_first_message** `[ oldest | newest | <number> ]`  \n  arguments: 1  \n  default: `oldest`  \n  context: server, location, if  \n  > Controls the first message received by a new subscriber. 'oldest' starts at the oldest available message in a channel's message queue, 'newest' waits until a message arrives. If a number `n` is specified, starts at `n`th message from the oldest. (`-n` starts at `n`th from now). 0 is equivalent to 'newest'.    \n\n- **nchan_subscriber_http_raw_stream_separator** `<string>`  \n  arguments: 1  \n  default: `\\n`  \n  context: server, location, if  \n  > Message separator string for the http-raw-stream subscriber. Automatically terminated with a newline character if not explicitly set to an empty string.    \n\n- **nchan_subscriber_info**  \n  arguments: 0  \n  context: location  \n  > A subscriber location for debugging the state of subscribers on a given channel. The subscribers of the channel specified by `nchan_channel_id` evaluate `nchan_subscriber_info_string` and send it back to the requested on this location. This is useful to see where subscribers are in an Nchan cluster, as well as debugging subscriber connection issues.    \n\n- **nchan_subscriber_info_string**  \n  arguments: 1  \n  default: `$nchan_subscriber_type $remote_addr:$remote_port $http_user_agent $server_name $request_uri $pid`  \n  context: server, location  \n  > this string is evaluated by each subscriber on a given channel and sent to the requester of a `nchan_subscriber_info` location    \n\n- **nchan_subscriber_last_message_id**  \n  arguments: 1 - 5  \n  default: `$http_last_event_id $arg_last_event_id`  \n  context: server, location, if  \n  > If `If-Modified-Since` and `If-None-Match` headers are absent, set the message id to the first non-empty of these values. Used primarily as a workaround for the inability to set the first `Last-Message-Id` of a web browser's EventSource object.     \n\n- **nchan_subscriber_message_id_custom_etag_header**  \n  arguments: 1  \n  default: `(none)`  \n  context: server, location, if  \n  > Use a custom header instead of the Etag header for message ID in subscriber responses. This setting is a hack, useful when behind a caching proxy such as Cloudflare that under some conditions (like using gzip encoding) swallow the Etag header.    \n\n- **nchan_subscriber_timeout** `<number> (seconds)`  \n  arguments: 1  \n  default: `0 (none)`  \n  context: http, server, location, if  \n  legacy name: push_subscriber_timeout  \n  > Maximum time a subscriber may wait for a message before being disconnected. If you don't want a subscriber's connection to timeout, set this to 0. When possible, the subscriber will get a response with a `408 Request Timeout` status; otherwise the subscriber will simply be disconnected.    \n\n- **nchan_unsubscribe_request** `<url>`  \n  arguments: 1  \n  context: server, location, if  \n  > Send GET request to internal location (which may proxy to an upstream server) after unsubscribing. Disabled for longpoll and interval-polling subscribers.    \n  [more details](#subscriber-presence)  \n\n- **nchan_websocket_client_heartbeat** `<heartbeat_in> <heartbeat_out>`  \n  arguments: 2  \n  default: `none (disabled)`  \n  context: server, location, if  \n  > Most browser Websocket clients do not allow manually sending PINGs to the server. To overcome this limitation, this setting can be used to set up a PING/PONG message/response connection heartbeat. When the client sends the server message *heartbeat_in* (PING), the server automatically responds with *heartbeat_out* (PONG).    \n\n- **nchan_websocket_ping_interval** `<number> (seconds)`  \n  arguments: 1  \n  default: `0 (none)`  \n  context: server, location, if  \n  > Interval for sending websocket ping frames. Disabled by default.    \n\n- **nchan_access_control_allow_credentials**  \n  arguments: 1  \n  default: `on`  \n  context: http, server, location, if  \n  > When enabled, sets the [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) `Access-Control-Allow-Credentials` header to `true`.    \n\n- **nchan_access_control_allow_origin** `<string>`  \n  arguments: 1  \n  default: `$http_origin`  \n  context: http, server, location, if  \n  > Set the [Cross-Origin Resource Sharing (CORS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) `Access-Control-Allow-Origin` header to this value. If the incoming request's `Origin` header does not match this value, respond with a `403 Forbidden`. Multiple origins can be provided in a single argument separated with a space.    \n\n- **nchan_authorize_request** `<url>`  \n  arguments: 1  \n  context: server, location, if  \n  > Send GET request to internal location (which may proxy to an upstream server) for authorization of a publisher or subscriber request. A 200 response authorizes the request, a 403 response forbids it.    \n  [more details](#request-authorization)  \n\n- **nchan_channel_group** `<string>`  \n  arguments: 1  \n  default: `(none)`  \n  context: server, location, if  \n  legacy name: push_channel_group  \n  > The accounting and security group a channel belongs to. Works like a prefix string to the channel id. Can be set with nginx variables.    \n\n- **nchan_channel_group_accounting**  \n  arguments: 1  \n  default: `off`  \n  context: server, location  \n  > Enable tracking channel, subscriber, and message information on a per-channel-group basis. Can be used to place upper limits on channel groups.    \n\n- **nchan_group_location** `[ get | set | delete | off ]`  \n  arguments: 0 - 3  \n  default: `get set delete`  \n  context: location  \n  > Group information and configuration location. GET request for group info, POST to set limits, DELETE to delete all channels in group.    \n\n- **nchan_group_max_channels** `<number>`  \n  arguments: 1  \n  default: `0 (unlimited)`  \n  context: location  \n  > Maximum number of channels allowed in the group.    \n\n- **nchan_group_max_messages** `<number>`  \n  arguments: 1  \n  default: `0 (unlimited)`  \n  context: location  \n  > Maximum number of messages allowed for all the channels in the group.    \n\n- **nchan_group_max_messages_disk** `<number>`  \n  arguments: 1  \n  default: `0 (unlimited)`  \n  context: location  \n  > Maximum amount of disk space allowed for the messages of all the channels in the group.    \n\n- **nchan_group_max_messages_memory** `<number>`  \n  arguments: 1  \n  default: `0 (unlimited)`  \n  context: location  \n  > Maximum amount of shared memory allowed for the messages of all the channels in the group.    \n\n- **nchan_group_max_subscribers** `<number>`  \n  arguments: 1  \n  default: `0 (unlimited)`  \n  context: location  \n  > Maximum number of subscribers allowed for the messages of all the channels in the group.    \n\n- **nchan_max_channel_id_length** `<number>`  \n  arguments: 1  \n  default: `1024`  \n  context: http, server, location  \n  legacy name: push_max_channel_id_length  \n  > Maximum permissible channel id length (number of characters). This settings applies to ids before they may be split by the `nchan_channel_id_split_delimiter` Requests with a channel id that is too long will receive a `403 Forbidden` response.    \n\n- **nchan_max_channel_subscribers** `<number>`  \n  arguments: 1  \n  default: `0 (unlimited)`  \n  context: http, server, location  \n  legacy name: push_max_channel_subscribers  \n  > Maximum concurrent subscribers to the channel on this Nchan server. Does not include subscribers on other Nchan instances when using a shared Redis server.    \n\n- **nchan_subscribe_existing_channels_only** `[ on | off ]`  \n  arguments: 1  \n  default: `off`  \n  context: http, server, location  \n  legacy name: push_authorized_channels_only  \n  > Whether or not a subscriber may create a channel by sending a request to a subscriber location. If set to on, a publisher must send a POST or PUT request before a subscriber can request messages on the channel. Otherwise, all subscriber requests to nonexistent channels will get a 403 Forbidden response.    \n\n- **nchan_message_buffer_length** `[ <number> | <variable> ]`  \n  arguments: 1  \n  default: `10`  \n  context: http, server, location  \n  legacy names: push_max_message_buffer_length, push_message_buffer_length  \n  > Publisher configuration setting the maximum number of messages to store per channel. A channel's message buffer will retain a maximum of this many most recent messages. An Nginx variable can also be used to set the buffer length dynamically.    \n\n- **nchan_message_temp_path** `<path>`  \n  arguments: 1  \n  default: `<client_body_temp_path>`  \n  context: http  \n  > Large messages are stored in temporary files in the `client_body_temp_path` or the `nchan_message_temp_path` if the former is unavailable. Default is the built-in default `client_body_temp_path`    \n\n- **nchan_message_timeout** `[ <time> | <variable> ]`  \n  arguments: 1  \n  default: `1h`  \n  context: http, server, location  \n  legacy name: push_message_timeout  \n  > Publisher configuration setting the length of time a message may be queued before it is considered expired. If you do not want messages to expire, set this to 0. Note that messages always expire from oldest to newest, so an older message may prevent a newer one with a shorter timeout from expiring. An Nginx variable can also be used to set the timeout dynamically.    \n\n- **nchan_redis_accurate_subscriber_count**  \n  arguments: 1  \n  default: `off`  \n  context: upstream  \n  > When disabled, use fast but potentially inaccurate subscriber counts. These may become inaccurate if Nginx workers exit uncleanly or are terminated. When enabled, use a slightly slower but completely accurate subscriber count. Defaults to 'off' for legacy reasons, but will be enabled by default in the future.    \n\n- **nchan_redis_cluster_check_interval_backoff** `<floating point> >= 0, ratio of current delay`  \n  arguments: 1  \n  default: `2 (increase delay by 200% each try)`  \n  context: upstream  \n  > Add an exponentially increasing delay to the Redis cluster check interval. `Delay[n] = (Delay[n-1] + jitter) * (nchan_redis_cluster_check_interval_backoff + 1)`.    \n\n- **nchan_redis_cluster_check_interval_jitter** `<floating point> >= 0, (0 to disable)`  \n  arguments: 1  \n  default: `0.2 (20% of interval value)`  \n  context: upstream  \n  > Introduce random jitter to Redis cluster check interval, where the range is `(cluster_check_interval * nchan_redis_cluster_check_interval_jitter) / 2`.    \n\n- **nchan_redis_cluster_check_interval_max** `<time> (0 to disable)`  \n  arguments: 1  \n  default: `30s`  \n  context: upstream  \n  > Maximum Redis cluster check interval after backoff and jitter.    \n\n- **nchan_redis_cluster_check_interval_min** `<time>`  \n  arguments: 1  \n  default: `1s (0 to disable)`  \n  context: upstream  \n  > When connected to a cluster, periodically check the cluster state and layout via a random master node.    \n\n- **nchan_redis_cluster_connect_timeout**  \n  arguments: 1  \n  default: `15s`  \n  context: upstream  \n  > Redis cluster connection timeout.    \n\n- **nchan_redis_cluster_max_failing_time**  \n  arguments: 1  \n  default: `30s`  \n  context: upstream  \n  > Maximum time a Redis cluster can be in a failing state before Nchan disconnects from it. During this time, Nchan will try to recover from a cluster or node failure without disconnecting the entire cluster.    \n\n- **nchan_redis_cluster_recovery_delay** `<time>`  \n  arguments: 1  \n  default: `100ms`  \n  context: upstream  \n  > After a cluster recovery failure, wait this long to try again.    \n\n- **nchan_redis_cluster_recovery_delay_backoff** `<floating point> >= 0, ratio of current delay`  \n  arguments: 1  \n  default: `0.5 (increase delay by 50% each try)`  \n  context: upstream  \n  > Add an exponentially increasing delay to Redis cluster recovery retries. `Delay[n] = (Delay[n-1] + jitter) * (nchan_redis_cluster_recovery_delay_backoff + 1)`.    \n\n- **nchan_redis_cluster_recovery_delay_jitter** `<floating point> >= 0, (0 to disable)`  \n  arguments: 1  \n  default: `0.5 (50% of delay value)`  \n  context: upstream  \n  > Introduce random jitter to Redis cluster recovery retry time, where the range is `(recovery_delay * nchan_redis_cluster_recovery_delay_jitter) / 2`.    \n\n- **nchan_redis_cluster_recovery_delay_max** `<time> (0 to disable)`  \n  arguments: 1  \n  default: `2s`  \n  context: upstream  \n  > Maximum Redis cluster recovery delay after backoff and jitter.    \n\n- **nchan_redis_command_timeout** `<time> (0 to leave unlimited)`  \n  arguments: 1  \n  default: `5s`  \n  context: upstream  \n  > If a Redis server exceeds this time to produce a command reply, it is considered unhealthy and is disconnected.    \n\n- **nchan_redis_connect_timeout**  \n  arguments: 1  \n  default: `10s`  \n  context: upstream  \n  > Redis server connection timeout.    \n\n- **nchan_redis_discovered_ip_range_blacklist** `<CIDR range>`  \n  arguments: 1 - 7  \n  context: upstream  \n  > do not attempt to connect to **autodiscovered** nodes with IPs in the specified ranges. Useful for blacklisting private network ranges for clusters and Redis slaves. NOTE that this blacklist applies only to autodiscovered nodes, and not ones specified in the upstream block    \n\n- **nchan_redis_idle_channel_cache_timeout** `<time>`  \n  arguments: 1  \n  default: `30s`  \n  context: http, server, location  \n  > A Redis-stored channel and its messages are removed from memory (local cache) after this timeout, provided there are no local subscribers.    \n\n- **nchan_redis_namespace** `<string>`  \n  arguments: 1  \n  context: http, server, upstream, location  \n  > Prefix all Redis keys with this string. All Nchan-related keys in redis will be of the form \"nchan_redis_namespace:*\" . Default is empty.    \n\n- **nchan_redis_nostore_fastpublish** `[ on | off ]`  \n  arguments: 1  \n  default: `off`  \n  context: http, server, upstream  \n  > Increases publishing capacity by 2-3x for Redis nostore mode at the expense of inaccurate subscriber counts in the publisher response.    \n\n- **nchan_redis_optimize_target** `[ cpu | bandwidth ]`  \n  arguments: 1  \n  default: `bandwidth`  \n  context: upstream  \n  > This tweaks whether [effect replication](https://redis.io/commands/eval#replicating-commands-instead-of-scripts) is enabled. This setting is obsolete, as effect replication is now always enabled to support other features    \n\n- **nchan_redis_pass** `<upstream-name>`  \n  arguments: 1  \n  context: http, server, location  \n  > Use an upstream config block for Redis servers.    \n  [more details](#connecting-to-a-redis-server)  \n\n- **nchan_redis_password**  \n  arguments: 1  \n  default: `<none>`  \n  context: upstream  \n  > Set Redis password for AUTH command. All servers in the upstream block will use this password _unless_ a different password is specified by a server URL.    \n\n- **nchan_redis_ping_interval**  \n  arguments: 1  \n  default: `4m`  \n  context: http, server, upstream, location  \n  > Send a keepalive command to redis to keep the Nchan redis clients from disconnecting. Set to 0 to disable.    \n\n- **nchan_redis_reconnect_delay** `<time>`  \n  arguments: 1  \n  default: `500ms`  \n  context: upstream  \n  > After a connection failure, wait this long before trying to reconnect to Redis.    \n\n- **nchan_redis_reconnect_delay_backoff** `<floating point> >= 0 (0 to disable)`  \n  arguments: 1  \n  default: `0.5 (increase delay by 50% each try)`  \n  context: upstream  \n  > Add an exponentially increasing delay to Redis connection retries. `Delay[n] = (Delay[n-1] + jitter) * (nchan_redis_reconnect_delay_backoff + 1)`.    \n\n- **nchan_redis_reconnect_delay_jitter** `<floating point> >= 0 (0 to disable)`  \n  arguments: 1  \n  default: `0.1 (10% of delay value)`  \n  context: upstream  \n  > Introduce random jitter to Redis reconnection time, where the range is `(reconnect_delay * nchan_redis_reconnect_delay_jitter) / 2`.    \n\n- **nchan_redis_reconnect_delay_max** `<time> (0 to disable)`  \n  arguments: 1  \n  default: `10s`  \n  context: upstream  \n  > Maximum Redis reconnection delay after backoff and jitter.    \n\n- **nchan_redis_retry_commands**  \n  arguments: 1  \n  default: `on`  \n  context: upstream  \n  > Allow Nchan to retry some Redis commands on keyslot errors and cluster unavailability. Queuing up a lot of commands while the cluster is unavailable may lead to excessive memory use, but it can also defer commands during transient failures.    \n\n- **nchan_redis_retry_commands_max_wait** `<time> (0 to leave unlimited)`  \n  arguments: 1  \n  default: `500ms`  \n  context: upstream  \n  > When `nchan_redis_retry_commands` is on, the maximum time a command will stayed queued to be retried.    \n\n- **nchan_redis_server** `<redis-url> <optional-forced-role>`  \n  arguments: 1 - 2  \n  default: `<redis-url>`  \n  context: upstream  \n  > Used in upstream { } blocks to set redis servers. Redis url is in the form 'redis://:password@hostname:6379/0'. Shorthands 'host:port' or 'host' are permitted. A role may optionally be provided as well to force a server to be treated as 'master' or 'slave'.  \n  >       uri:     \n\n- **nchan_redis_ssl** `[ on | off ]`  \n  arguments: 1  \n  default: `off`  \n  context: upstream  \n  > Enables SSL/TLS for all connections to Redis servers in this upstream block. When enabled, no unsecured connections are permitted    \n\n- **nchan_redis_ssl_ciphers**  \n  arguments: 1  \n  default: `<system default>`  \n  context: upstream  \n  > Acceptable ciphers when using TLS for Redis connections    \n\n- **nchan_redis_ssl_client_certificate**  \n  arguments: 1  \n  context: upstream  \n  > Path to client certificate when using TLS for Redis connections    \n\n- **nchan_redis_ssl_client_certificate_key**  \n  arguments: 1  \n  context: upstream  \n  > Path to client certificate key when using TLS for Redis connections    \n\n- **nchan_redis_ssl_server_name**  \n  arguments: 1  \n  context: upstream  \n  > Server name to verify (CN) when using TLS for Redis connections    \n\n- **nchan_redis_ssl_trusted_certificate**  \n  arguments: 1  \n  context: upstream  \n  > Trusted certificate (CA) when using TLS for Redis connections    \n\n- **nchan_redis_ssl_trusted_certificate_path**  \n  arguments: 1  \n  default: `<system default>`  \n  context: upstream  \n  > Trusted certificate (CA) when using TLS for Redis connections. Defaults to the system's SSL cert path unless nchan_redis_ssl_trusted_certificate is set    \n\n- **nchan_redis_ssl_verify_certificate** `[ on | off ]`  \n  arguments: 1  \n  default: `on`  \n  context: upstream  \n  > Should the server certificate be verified when using TLS for Redis connections? Useful to disable when testing with a self-signed server certificate.    \n\n- **nchan_redis_storage_mode** `[ distributed | backup | nostore ]`  \n  arguments: 1  \n  default: `distributed`  \n  context: http, server, upstream, location  \n  > The mode of operation of the Redis server. In `distributed` mode, messages are published directly to Redis, and retrieved in real-time. Any number of Nchan servers in distributed mode can share the Redis server (or cluster). Useful for horizontal scalability, but suffers the latency penalty of all message publishing going through Redis first.  \n  >   \n  > In `backup` mode, messages are published locally first, then later forwarded to Redis, and are retrieved only upon channel initialization. Only one Nchan server should use a Redis server (or cluster) in this mode. Useful for data persistence without sacrificing response times to the latency of a round-trip to Redis.  \n  >   \n  > In `nostore` mode, messages are published as in `distributed` mode, but are not stored. Thus Redis is used to broadcast messages to many Nchan instances with no delivery guarantees during connection failure, and only local in-memory storage. This means that there are also no message delivery guarantees for subscribers switching from one Nchan instance to another connected to the same Redis server or cluster. Nostore mode increases Redis publishing capacity by an order of magnitude.    \n\n- **nchan_redis_subscribe_weights** `master=<integer> slave=<integer>`  \n  arguments: 1 - 2  \n  default: `master=1 slave=1`  \n  context: upstream  \n  > Determines how subscriptions to Redis PUBSUB channels are distributed between master and slave nodes. The higher the number, the more likely that each node of that type will be chosen for each new channel. The weights for slave nodes are cumulative, so an equal 1:1 master:slave weight ratio with two slaves would have a 1/3 chance of picking a master, and 2/3 chance of picking one of the slaves. The weight must be a non-negative integer.    \n\n- **nchan_redis_upstream_stats** `<upstream_name>`  \n  arguments: 1  \n  default: `(none)`  \n  context: server, location  \n  > Defines a location as redis statistics endpoint. GET requests to this location produce a JSON response with detailed listings of total Redis command times and number of calls, broken down by node and command type. Useful for making graphs about Redis performance. Can be set with nginx variables.    \n\n- **nchan_redis_upstream_stats_disconnected_timeout**  \n  arguments: 1  \n  default: `5m`  \n  context: upstream  \n  > Keep stats for disconnected nodes around for this long. Useful for tracking stats for nodes that have intermittent connectivity issues.    \n\n- **nchan_redis_upstream_stats_enabled** `[ on | off ]`  \n  arguments: 1  \n  default: `<on> if at least 1 redis stats location is configured, otherwise <off>`  \n  context: upstream  \n  > Gather Redis node command timings for this upstream    \n\n- **nchan_redis_url** `<redis-url>`  \n  arguments: 1  \n  default: `127.0.0.1:6379`  \n  context: http, server, location  \n  > Use of this command is discouraged in favor of upstreams blocks with [`nchan_redis_server`](#nchan_redis_server). The path to a redis server, of the form 'redis://:password@hostname:6379/0'. Shorthand of the form 'host:port' or just 'host' is also accepted.    \n  [more details](#connecting-to-a-redis-server)  \n\n- **nchan_redis_username**  \n  arguments: 1  \n  default: `<none>`  \n  context: upstream  \n  > Set Redis username for AUTH command (available when using ACLs on the Redis server). All servers in the upstream block will use this username _unless_ a different username is specified by a server URL.    \n\n- **nchan_shared_memory_size** `<size>`  \n  arguments: 1  \n  default: `128M`  \n  context: http  \n  legacy names: push_max_reserved_memory, nchan_max_reserved_memory  \n  > Shared memory slab pre-allocated for Nchan. Used for channel statistics, message storage, and interprocess communication.    \n  [more details](#memory-storage)  \n\n- **nchan_store_messages** `[ on | off ]`  \n  arguments: 1  \n  default: `on`  \n  context: http, server, location, if  \n  legacy name: push_store_messages  \n  > Publisher configuration. \"`off`\" is equivalent to setting `nchan_message_buffer_length 0`, which disables the buffering of old messages. Using this setting is not recommended when publishing very quickly, as it may result in missed messages.    \n\n- **nchan_use_redis** `[ on | off ]`  \n  arguments: 1  \n  default: `off`  \n  context: http, server, location  \n  > Use of this command is discouraged in favor of (`nchan_redis_pass`)[#nchan_redis_pass]. Use Redis for message storage at this location.    \n  [more details](#connecting-to-a-redis-server)  \n\n- **nchan_channel_event_string** `<string>`  \n  arguments: 1  \n  default: `\"$nchan_channel_event $nchan_channel_id\"`  \n  context: server, location, if  \n  > Contents of channel event message    \n\n- **nchan_channel_events_channel_id**  \n  arguments: 1  \n  context: server, location, if  \n  > Channel id where `nchan_channel_id`'s events should be sent. Events like subscriber enqueue/dequeue, publishing messages, etc. Useful for application debugging. The channel event message is configurable via nchan_channel_event_string. The channel group for events is hardcoded to 'meta'.    \n  [more details](#channel-events)  \n\n- **nchan_stub_status**  \n  arguments: 0  \n  context: location  \n  > Similar to Nginx's stub_status directive, requests to an `nchan_stub_status` location get a response with some vital Nchan statistics. This data does not account for information from other Nchan instances, and monitors only local connections, published messages, etc.    \n  [more details](#nchan_stub_status)  \n\n- **nchan_channel_timeout**  \n  arguments: 1  \n  context: http, server, location  \n  legacy name: push_channel_timeout  \n  > Amount of time an empty channel hangs around. Don't mess with this setting unless you know what you are doing!    \n\n- **nchan_storage_engine** `[ memory | redis ]`  \n  arguments: 1  \n  default: `memory`  \n  context: http, server, location  \n  > Development directive to completely replace default storage engine. Don't use unless you are an Nchan developer.    \n\n## Contribute\nPlease support this project with a donation to keep me warm through the winter. I accept bitcoin at 15dLBzRS4HLRwCCVjx4emYkxXcyAPmGxM3 . Other donation methods can be found at https://nchan.io\n"
        },
        {
          "name": "changelog.txt",
          "type": "blob",
          "size": 34.0166015625,
          "content": "1.3.7 (Sep. 19 2024)\n fix: repeated DELETE requests can leave unresponsive subscribers connected to a channel\n fix: channel info subscriber count incorrect when using Redis following unclean worker exit\n      (Thanks, Steven Green)\n feature: manually set Redis server roles to master or slave\n fix: Redis server blacklist was only applied in cluster mode\n      (Thanks, piotr-lwks)\n fix: Nchan may fail to connect to non-cluster Redis if more than 1 server is specified\n      (Thanks, Mike Baroukh)\n fix: Some invalid message IDs may result in a worker crash\n fix: Nchan may fail to reconnect ro a Redis cluster when using many workers due to a race condition\n      (Thanks, Fabio Urquiza)\n fix: subscriber info may be incorrect for Redis version >=7\n fix: Redis cluster may fail to reconnect to a cluster without consensus\n      (Thanks, Fabio Urquiza)\n1.3.6 (Jan. 6 2023)\n fix: reloading Nginx with nchan_stub_status enabled may result in a crash (introduced in v1.3.1) \n fix: nchan_redis_upstream_stats_enabled incorrectly documented as having \"yes/no\" values instead of \"on/off\"\n fix: compilation erros for Nginx 1.23.2\n1.3.5 (Oct. 27 2022)\n feature: track Redis upstreams statistics with nchan_redis_upstream_stats\n fix: possible invalid memory access after Redis cluster node discovery\n fix: GET publisher location request may return incorrect subscriber count when using Redis\n fix: possible to log invalid string for rare error\n1.3.4 (Sep. 1 2022)\n fix: Redis cluster slave failover may result in crash\n1.3.3 (Aug. 29 2022)\n fix: incorrect timeout handling for new nchan_redis_accurate_subscriber_count resulted in inaccurate subscriber counts\n1.3.2 (Aug. 23 2022)\n feature: stub status now shows the total number of commands sent to Redis\n fix: Redis cluster checks may not time out\n fix: Redis cluster may not be marked unhealthy if a required node is marked in the node list as 'fail'\n fix: simultaneous creating many Redis-backed channels may result in CPU usage spikes on Redis server\n1.3.1 (Aug. 1 2022)\n fix: Nchan may become unresponsive after a worker is uncleanly terminated\n change: nchan_redis_optimize_setting is now obsolete\n feature: nchan_redis_accurate_subscriber_count that doesn't corrupt Redis\n          subscriber counts when nginx workers are killed\n feature: added \"redis unhealthy upstreams\" to nchan_stub_status\n fix: incorrect nchan_stub_status variables after a worker is uncleanly terminated\n fix: build errors with Nginx >= 1.20.1\n feature: Redis >=7.0.1 SMESSAGE support\n fix: Redis cluster slot assignments may not be reconfigured correctly\n fix: discovery of Redis slave nodes in cluster may be incomplete\n1.3.0 (May 26 2022)\n feature: configurable Redis command timeouts with nchan_redis_command_timeout\n feature: configurable Redis command retries with nchan_redis_retry_commands and nchan_redis_retry_commands_max_wait\n fix: Redis cluster status checks can now discover new slaves\n fix: Redis 7 cluster keyslot errors not recognized on Redis 7\n feature: Redis 7 sharded pubsub support\n feature: configurable Redis cluster recovery time, backoff, and jitter\n feature: Redis cluster failure recovery without disconnection\n feature: configurable Redis reconnection time, backoff, and jitter\n fix: Redis scripts are now loaded only when missing\n1.2.15 (Dec. 27 2021)\n fix: publishing to >255 string-delimitered channels could result in a crash\n fix: Redis connection failures (since 1 2.14)\n1.2.14 [WITHDRAWN] (Dec. 20 2021)\n fix: compiler warnings from the use of the 'typeof' macro\n fix: Nchan can't be built without the Nginx SSL module (bug introduced in 1.2.13)\n update: hiredis updated to 1.0.2\n fix: some Redis connection failures could result in a crash (bug introduced in 1.2.13)\n fix: upstream subrequests crashed with Nginx >= 1.19.9\n1.2.13 [WITHDRAWN] (Dec. 13 2021)\n feature: Redis ACL support with username and passwword\n feature: Redis TLS support\n1.2.12 (Sep. 22 2021)\n fix: better Redis cluster connection logging\n fix: redundant method to discover Redis slave nodes in cluster mode could result in receiving unreachable IPs\n1.2.11 (Sep. 17 2021)\n feature: nchan_redis_discovered_ip_range_blacklist for ignoring autotiscoreved nodes\n feature: nchan_redis_storage_mode is now configurable in location contexts \n1.2.10 (Aug. 25 2021)\n fix: Nchan could not be built without openssl due to hiredis dependency\n      (introduced in v1.2.9)\n feature: allow no separator for http-raw-stream (thanks @sclem)\n1.2.9 (Aug. 12 2021)\n feature: Redis cluster reconfiguration check timer,\n      nchan_redis_cluster_check_interval setting\n fix: detect Redis cluster reconfiguration when publishing messages in \"nostore\" mode\n update: hiredis updated to v1.0.0 \n fix: segfault on out-of-shared-memory condition for multiplexed publishers\n1.2.8 (Apr. 12 2021)\n feature: nchan_subscriber_info locations for receiving customizable info from \n      subscribers of a given channel.\n fix: incorrect lgging of disconnected subscribers with 400 error instead of 499\n      (bug introduced in v1.2.7)\n feature: add $nchan_channel_subscriber_last_seen, $nchan_channel_subscriber_count \n      and $nchan_channel_message_count variables\n fix: GCC 10 compatibility\n1.2.7 (Mar. 17 2020)\n fix: unidirectional subscribers have their connection terminated if they send any data to the server\n      after the initial request handshake. This applies to all subscribers except Websocket\n feature: periodic pings for EventSource subscribers\n fix: Redis pending commands count may be incorrect in nchan's stub status page\n fix: channel deletion fails to propagate to Redis slaves\n fix: possible stack overflow when using websocket subscribers\n1.2.6 (Jun. 18 2019)\n fix: when using Redis, a channel can stop receiving new messages if \n      they are published faster than they can be sent to subscribers and the \n      message buffer is sufficiently small\n fix: websocket PONG response did not contain PING frame data\n fix: multiplexed channels may stop receiving messages\n fix (security): specially crafted websocket publisher requests when using Redis\n      may result in use-after-free memory access\n fix: Nginx config reload may result in crash when using Redis cluster\n1.2.5 (Mar. 20 2019)\n fix: using multiplexed channels with Redis in backup mode may result in worker crash\n fix: nchan_publisher_channel_id could not be set exclusively in a publisher location\n fix: Google pagespeed module compatibility\n fix: nchan prevents nginx from starting if no http {} block is configured\n1.2.4 (Feb. 25 2019)\n fix: Redis cluster info with zero-length hostname may result in worker crash\n fix: build problems with included hiredis lib in FreeBSD\n feature: nchan_redis_namespace and nchan_redis_ping_interval now work in upstream blocks\n fix: websocket publisher did not publishing channel events\n fix: Redis namespace was limited to 8 bytes\n1.2.3 (Oct. 15 2018)\n fix: possible invalid memory access when the initial connection to a Redis cluster node times out\n1.2.2 (Oct. 9 2018)\n fix (security): using an unresponsive, overloaded Redis server may result in invalid memory access\n fix: incorrect logging of discovered Redis cluster nodes\n fix: better handling of connection loss when Redis server is unresponsive\n fix: presence of Redis cluster nodes with no known address (\"noaddr\") nodes could result in worker crash\n fix (security): subscriber may erroneously receive a 400 Bad Request or crash a worker \n      based on data from a previous subscriber\n feature: built-in backend benchmark\n feature: add optimized fastpublish option to Redis nostore mode for maximum\n      message publishing thoroughput via Redis\n feature: add no-store Redis mode that uses Redis for broadcasting messages, not storage\n fix: connecting to load-balancing Redis proxy resulted in crash\n fix: using longpoll-multipart in \"raw\" mode cound result in worker crash\n fix: channel events used with Redis resulted in segfault\n1.2.1 (Aug. 2 2018)\n fix: channel last_requested was set to 0 instead of -1 on channel creation\n fix: authentication failure body not forwarded for Nginx > 1.13.10\n fix: possible invalid memory access for websocket unsubscribe requests\n fix: building Nchan could interfere with building other modules\n1.2.0 (Jul. 23 2018)\n feature: configurable support for CORS Access-Control-Allow-Credentials header\n fix: better compliance with RFC7692  Websocket permessage-deflate parameter negotiation\n fix (security): possible busy-loop denial-of-service for specially crafted \n      handshakes from Websocket subscribers using permessage-deflate\n      (Thanks, Benjamin Michle)\n fix: nchan_permessage_deflate_compression_memlevel was not applied when set\n refactor: all publisher and subscriber upstream requests are now more memory-efficient\n fix: Using websocket publisher upstream requests may result in invalid memory access\n fix: publishing Redis-backed messages with 1-second expiration may fail after\n      cluster restart\n change: nchan_redis_wait_after_connecting directive is now obsolete, and is ignored\n feature: nchan_redis_optimize_target for \"cpu\" or \"bandwidth\". Trades off CPU\n      load on Redis slaves for syncronization bandwidth.\n feature: configurable Redis master/slave channel subscribe weights with\n      nchan_redis_subscribe_weights\n fix: Compilation issues on OS X and systems lacking non-POSIX memrchr()\n fix: nchan_pubsub CORS Allowed headers did not include headers used by subscribers\n fix: Redis-backed channel buffer length could exceed nchan_message_buffer_length\n fix: Publisher upstream compatibility for Nginx > 1.13.10\n feature: nchan_redis_connect_timeout to configure maximum connection time \n      to Redis servers\n feature: Offload Redis SUBSCRIBE traffic to slaves \n      (one SUBSCRIBE per channel per worker)\n fix: Redis cluster and master/slave failover and reconnection issues\n refactor: Redis connection handling rewritten from scratch\n fix: subscribers may not receive new messages after reconnecting to Redis\n fix: publishing to an unavailable Redis-backed channel may result in a \n      following 400 Bad Request\n change: Old Redis-backed channel messages are now delivered after the message\n      buffer is fully loaded into memory. Previously they were delivered\n      incrementally while the buffer loaded.\n fix: multiplexed Redis-backed channels may not deliver messages if one or\n      more channels' messages all expire\n fix: possible crash when catching up to reconnected Redis channel with\n      subscribers waiting for consecutive messages\n fix: possible crash from rapidly creating and deleting channels\n1.1.15 (Apr. 27 2018)\n fix: A disconnect from a Redis cluster node can result in a segfault\n fix: Using Redis-backed multiplexed channels can result in a segfault\n1.1.14 (Jan. 10 2018)\n feature: added nchan_redis_wait_after_connecting setting\n fix: compatibility with Redis >= 4.0 cluster\n1.1.13 (Dec. 4 2017)\n fix: added Redis backwards compatibility with Nchan 1.1.7 and below\n      for online upgrades with mixed-version Nchan cluster\n1.1.12 (Dec. 1 2017)\n fix: possible \"Unexpected spool == nuspool\" worker crash\n fix: subscriber messages delivered during active nchan_subscribe subrequest\n      may be garbled\n1.1.11 (Nov. 29 2017)\n fix: Redis backup-mode not working (since 1.1.9)\n fix: incorrect handling of Redis permessage-deflated messages results in\n      missing first char of eventsource event type\n fix: worker crash when unable to create temp file for large websocket\n      permessage-deflate message\n fix: CPU-bound overloaded Nginx may result in worker crashes\n      (may occur with large Openresty Lua load)\n change: default nchan_shared_memory_size is now 128M\n fix: some channel info from publisher GET requests may be incorrect with Redis\n fix: file descriptor leak when reconnecting to Redis\n1.1.10 (Nov. 13 2017)\n feature: nchan_authorize_request failure response forwarded back to subscriber\n      Sponsored by Symless (https://symless.com/)\n fix: allow nchan_access_control_allow_origin in if blocks\n fix: longpoll-multipart may read uninitialized memory when receiving \n      zero-length message\n fix (security): invalid memory access for aborted websocket subscriber \n      after channel existence check via Redis\n fix: websocket handhshake failure handled incorrectly when messages \n      are available\n fix (security): websocket subscriber disconnecting before handshake may\n      result in invalid memory access\n fix (security): possible invalid memory access for disappearing longpoll sub\n feature: add \"shared memory limit\" to nchan_stub_status output\n1.1.9 (Oct. 30 2017)\n fix: more proper websocket extension negotiation with more \n      informative failure messages\n fix: websocket handshake failure response included superfluous CLOSE frame\n feature: websocket deflate-frame and x-webkit-deflate-frame support\n1.1.8 (Oct. 26 2017)\n feature: websocket permessage-deflate support\n      Sponsored by HYFN (https://hyfn.com/)\n fix (security): websocket publisher may crash worker when publishing with\n      channel group accounting on to a new group\n fix: messages published to Nchan via websocket binary frames \n      should have content-type set to \"application/octet-stream\"\n fix: accept websocket publisher binary frames (thanks @rponczkowski)\n fix: multiplexing over exactly 255 channels results in worker crash\n fix (security): Specially crafted invalid subscriber msgid may crash worker\n fix: nchan_subscriber_first_message <= 0 (newest) with existing Redis data\n      incorrectly treated as \"oldest\" for initial subscribers\n fix: 0-length channel name may crash worker\n fix: subscribe/unsubscribe callback requests do not work when used with\n      authorization callback request\n fix (security): Messages published with Redis through websocket publisher \n      may result in worker crash (bug introduced in 1.1.5)\n fix: nchan_pubsub setting may not be parsed correctly\n1.1.7 (Jul. 3 2017)\n fix: possible read-after-free after redis disconnect\n fix: publishing to redis cluster before it is connected results in worker crash\n fix: possible use-after-free for suddenly disconnected longpoll-multipart subscriber\n fix: possible use-after-free when using nchan_authorize_request for slow subscribers and slow upstream\n fix: nchan_stub_status \"stored messages\" value could be incorrect when using Redis\n1.1.6 (May 9 2017)\n fix: messages published through Redis may crash worker (introduced in 1.1.5)\n fix (security): urlencoded message id in url parsed incorrectly can result in worker crash\n1.1.5 (May 3 2017)\n feature: get current Nchan version through $nchan_version variable \n      and nchan_stub_status\n fix (security): invalid memory access for multiplexed channel subscribers \n      with buffered output (Thanks Casey Forbes (@caseyf) for debugging.)\n fix: \"redis pending commands\" nchan_stub_status stat could be wrong after \n      deleting channels\n fix: invalid memory access when using Redis under high load\n fix: possible \"message from the past\" errors under high publishing load\n fix: graceful publisher/subscriber notifications when out of shared memory\n      (via HTTP 507 Insufficient Storage status code)\n fix: compatibility with limit_except directive\n1.1.4 (Apr. 25 2017)\n fix (security): possible memory corruption using multiplexed channels \n      at high load (Thanks Giovanni Caporaletti (@TrustNoOne) for debugging.)\n fix: possible crash when reconnecting to Redis cluster (introduced in 1.1.3)\n1.1.3 (Mar. 25 2017)\n fix (security): incorrect handling of WS optimization could trigger SIGABRT\n fix: Redis cluster reconnect readiness verification\n1.1.2 (Mar. 1 2017)\n change: \"interprocess alert X delayed by Y sec\" log messages downgraded \n      from ERROR to NOTICE\n fix: \"group info string too short\" error\n fix: Incorrect handling of connections to Redis cluster nodes with round-robin\n      DNS hostnames (Thanks to ring.com for sponsoring this fix!)\n1.1.1 (Feb. 8 2017)\n fix: incorrect stats for nchan_stub_status after reload.\n      (Stats are no longer reset after reload)\n fix: websocket subscriber may receive two CLOSE frames\n fix: websocket with ws+meta.nchan subprotocol did not receive empty messages\n feature: websocket client heartbeats with nchan_websocket_client_heartbeat\n fix: websocket now echoes code and reason when connection close initiated from client\n1.1.0 (Jan. 4 2017)\n feature: websocket subscribers now receive \"application/octet-stream\" messages\n      in binary frame rather than text\n fix: publisher request variables not always passed to nchan_publisher_upstream_request\n feature: Redis storage 'backup' mode strictly for data persistence\n fix: possible lingering subscriber if connection is closed just before subscribing\n fix: possible memory leak when using multiplexed channels\n security fix: subscribing with If-Modified-Since and without If-None-Match headers\n      crashed the Nginx worker (thanks @supertong)\n security fix: sending an empty message to multipart/mixed subscriber crashed Nginx worker\n fix: publisher & subscriber response codes were logged incorrectly\n fix: websocket subscriber memory leak on upstream authentication failure\n fix: possible crash after reloading when using several instances of Nchan with Redis\n feature: nchan_access_control_allow_origin can accept nginx variables\n feature: Redis key namespaces\n feature: all size configurations can now parse decimal values\n fix: off-by-one subscriber count when using multiplexed channels\n feature: accounting and dynamic limits for channel groups\n1.0.8 (Nov. 28 2016)\n fix: possible crash under severely heavy load, introduced in 1.0.7 with stack-overflow fix\n1.0.7 (Nov. 27 2016)\n fix: memory leak after websocket publisher uncleanly aborts connection\n fix: misbehaving websocket publisher with nchan_publisher_upstream_request\n fix: potential stack overflow with very large message buffers\n fix: invalid memory access with empty nchan_publisher_upstream_request for websocket publisher\n fix: incorrect handling of chunked response from nchan_publisher_upstream_request\n fix: publishing through websocket too fast may result in buffered messages that never arrive\n fix: DELETE to multiplexed channel should delete all listed channels\n fix: abort if publishing to multiple channels while using redis\n1.0.6 (Nov. 15 2016)\n fix: large messages were sometimes incorrectly cleaned up, leaving behind temp files\n fix: file descriptor leak when listening on a unix socket and suddenly \n      aborting client connections\n fix: invalid memory access after reloading twice with redis enabled\n fix: crash after shutting down nginx when 'master_process' set to 'off'\n change: nchan_max_channel_subscribers now always refers to subscribers on this instance of\n      Nchan, even when using Redis.\n feature: subscribe/unsubscribe callbacks with nchan_subscribe_request and nchan_unsubscribe_request\n1.0.4 (Oct. 28 2016)\n security: fix crash when receiving large messages over websocket with ws+nchan subprotocol\n1.0.3 (Sept. 3 2016)\n feature: nchan_message_timeout and nchan_message_buffer_length \n      can now use nginx variables for dynamic values\n fix: unsolicited websocket PONGs disconnected the subscriber in violation of RFC6455\n fix: possible script error when getting channel from Redis\n fix: possible incorrect message IDs when using Redis (thanks @supertong)\n security: possible invalid memory access on publisher GET, POST, or DELETE when\n      using Redis and the publisher connection is terminated before receiving\n      a response\n fix: correct publisher response code when nchan_authorize_request is unavailable\n      (502 instead of 500)\n security: crash if publisher POSTs request with no Content-Length header when \n      using nchan_authorize_request\n1.0.2 (Aug. 29 2016)\n fix: more informative missed-message warnings\n fix: invalid memory access when Redis enabled without setting server URL\n fix: incomplete redis channel deletion\n fix: Redis command responses may not be processed after large message\n      until next command\n feature: catch up with missed messages after reconnecting to Redis cluster\n fix: possible invalid memory access after disconnecting from Redis cluster\n fix: Redis-stored unbuffered messages may not be delivered\n fix: possible invalid memory access when using previously idling channels\n fix: invalid memory access if publisher POST request's connection terminates\n      before receiving response\n fix: messages published rapidly to Redis via different Ncnan servers may\n      be received out of order\n fix: possible stack overflow when receiving messages through Redis\n      for multiplexed channels\n fix: channels with 'nchan_store_messages off' published 1 message per second\n fix: issue warning when out-of-order published message is detected\n fix: Redis cluster compatibility with channel ids containing '}' character\n fix: Redis-stored channel deleted too quickly when publishing short-lived messages\n1.0.1 (Aug. 22 2016)\n feature: nchan_stub_status shared memory accounting\n fix: various compiler warnings\n1.0.0 (Aug. 20 2016)\n fix: incorrectly repeated subscriber_enqueue channel events\n fix: badly handled Redis messages with TTL < 1 (again)\n fix: websocket didn't close connection on PING fail\n feature: nchan_stub_status stats location\n fix: bad memory access for Redis channels when unsubscribing and very busy\n optimize: SSE2 & AVX2 optimizations for websocket frame unmasking\n feature: Redis Cluster support\n (WARNING:) data in Redis from previous versions will be inaccessible\n feature: different locations can use different Redis servers\n feature: nchan_subscriber_first_message can take a number (positive or negative) \n      for nth message (from first or last)\n feature: expire Redis-stored idle channels with nchan_redis_idle_channel_cache_timeout\n fix: some multiplexed channels never garbage-collected when inactive\n fix: unbuffered message garbage collector was too lazy\n fix: update nchan_message_buffer_length correctly when using Redis (thanks @supertong)\n fix: incorrect handling of missing/expired messages in multiplexed channels\n fix: memory leak when publishing via Websocket on a pubsub location\n fix: multiplexed channel DELETE when using Redis handled incorrectly\n fix: rare Redis script error when publishing message\n fix: Redis connection ping infinite loop when reloading\n fix: crash if Redis message TTL less than 1 sec\n fix: message delivery occasionally stopped when using Redis \n      and rapidly publishing messages\n fix: logpoll-multipart sometimes failed to respond when using Redis \n      and rapidly publishing messages\n fix: don't crash if Redis server is busy loading data\n0.99.16 (Jun 10 2016)\n fix: invalid memory access when upstream subscriber authorize request failed\n fix: longpoll-multipart subscriber was managed incorrectly on channel deletion\n fix: subscribers may not receive messages after Redis reconnection\n0.99.15 (May 31 2016)\n feature: Redis client keepalive configurable with nchan_redis_ping_interval\n feature: try to reconnect to Redis after lost connection to Redis\n fix: invalid memory access after lost connection to Redis\n fix: use-after-free error if subscriber disconnects before response \n      from upstream authorize server (thanks Filip Jenicek)\n fix: corrupt longpoll-multipart boundary data with long messages\n feature: 'raw' mode for longpoll-multipart\n feature: http-raw-stream client, like Push Stream Module's 'stream' mode\n fix: incomplete longpoll-multipart response when using Redis\n fix: \"subrequests cycle\" error for websocket publisher for nginx > 1.9.4\n fix: nchan_channel_id_split_delimiter inheritance\n fix: subscriber memory leak from 0.99.8\n fix: reload crash from 0.99.14\n0.99.14 (May 4 2016)\n fix: trailing NULL character in Publisher response content-type for json, xml, and yaml\n fix: don't crash when out of shared memory\n fix: invalid memory access when using nchan_publisher_upstream_request with websocket \n fix: incorrect stored messages count when using Redis store\n fix: incorrect last_message_id on publisher GETs (memstore and Redis)\n fix: incorrect behavior when subscribing right after startup before all workers are ready\n fix: some internal event loop timers were not being canceled, leading to slow shutdown\n fix: resuming some subscribers with valid message ids didn't work when using Redis store\n fix: possible invalid memory access when restarting Nginx after using multiplexed channels\n fix: accept url-encoded message ids\n feature: add ws+meta.nchan websocket subprotocol that include message metadata\n fix: all requests after X-Accel-Redirect from upstream were treated as GETs\n0.99.13 (Apr. 20 2016)\n fix: invalid content-length for nchan_authorize_request publisher requests\n fix: \"subrequests cycle\" error after 200 websocket publish requests\n fix: zero-size buf warning when publishing empty messages via websocket\n fix: nchan_max_channel_subscribers was ignored\n fix: use a blocking Redis connection for commands during shutdown to ensure commands are sent\n fix: better TTL handling for Redis keys\n0.99.12 (Apr. 10 2016)\n fix: SPDY compatibility with EventSource and multipart/mixed subscribers\n fix: warnings when shutting down Redis storage\n feature: use system's hiredis library if present\n fix: incorrect handling of missing messages when publishing to Redis\n0.99.11 (Apr. 3 2016)\n feature: nchan can be built as a dynamic module (for nginx >= 1.9.11)\n0.99.10 (Apr. 2 2016)\n fix: messages not freed until expired after being deleted from channel\n fix: buffering and output issues for large messages\n update: hiredis updated to v0.13.3\n fix: Redis publishing and subscribing memory leaks\n optimize: per-channel Redis subscriber counts batched into 100-ms intervals\n    to prevent Redis roundtrip floods\n fix: Redis subscriber memory leak\n refactor: extracted shared subscriber and message store logic\n fix: use-after-free error for Redis channels without subscribers\n fix: channel readying logic sometimes got confused and tripped up assert()s\n fix: even more proper handling of websocket close frames\n change: 408 Request Timeout instead of 304 No Content status code for timed out subscribers\n0.99.8 (Mar. 13 2016)\n fix: multipart/mixed subscriber output issues\n fix: memory leak for multiplexed > 4 channels\n fix: invalid memory access for aborted subscriber connection with Redis\n      and nchan_subscribe_existing_channels_only\n fix: accept websocket binary data frames\n fix: proper handling of websocket close frames\n fix: incorrect expire calculation for cached Redis-stored messages\n fix: double free for multiplexed >4 websocket subs\n0.99.7 (Mar. 10 2016)\n fix: websocket infinite ping loop after reload\n feature: nchan_subscriber_message_id_custom_etag_header for misbehaving proxies that eat etags\n fix: 100% cpu after lost Redis connection\n fix: refined CORS cross-origin access control headers and logic\n fix: longpoll subscriber in multipart mode didn't output all messages\n fix: longpoll subscriber in multipart mode could access invalid memory\n fix: compatibility with supported Redis versions < 2.8.14\n fix: nchan_message_timeout 0 should not expire messages\n0.99.6 (Feb. 22 2016)\n fix: SIGHUP reloading under load\n0.99.5 (Feb 15 2016)\n fix: publishing with client_body_in_file_only enabled\n0.99.4 (Feb 12 2016)\n fix: invalid memory access in channel DELETE response\n fix: race condition in IPC during channel creation (thanks vtslothy)\n0.99.3 (Feb 10 2016)\n fix: SIGHUP reloading\n fix: startup with insufficient file descriptors shouldn't crash\n fix: longpoll-multipart failure to immediately respond\n fix: longpoll-multipart abort handling\n fix: Redis-store cached message timeouts\n fix: Redis connection-lost handling\n fix: startup with 'master_process off' (single-process mode)\n feature: EventSource 'event:' line support with custom header or config\n0.98 (Jan 21 2016)\n feature: publish to multiple channels with one request\n feature: nchan_longpoll_multipart_response config setting\n fix: large message (in-file) handling for multipart/mixed and chunked subscribers\n fix: 400 Bad Request error on 32-bit systems\n fix: memory allocation error for >8 multi-channel subscribers\n0.97 (Jan 5 2016) \n fix: build issues with debian\n fix: compatibility with nginx versions down to 1.0.15\n fix: publishing bug introduced in 0.96\n0.961 (Jan 4 2016)\n fix: compiler warning\n0.96 (Jan 1. 2016)\n feature: websocket ping with nchan_websocket_ping_interval\n fix: unsafe memory access for Redis publisher\n feature: nchan_publisher_upstream_request\n fix: http/2 compatibility for EventSource and multipart/mixed\n fix: nchan_authorize_request for publisher location endpoints\n fix: publishing long (stored in file) messages to Redis-store\n0.95 (Dec. 24 2015)\n feature: configurable nchan_access_control_origin_header, default to *\n fix: recognize non-preflighted CORS requests\n fix: Redis invalid memory access after timeout\n0.94 (Dec. 22 2015)\n feature: last mesage id in channel info response\n feature: subscribe up to 255 channel ids using nchan_channel_id_split_delimiter\n fix: tried connecting to Redis when not needed\n change: \"last requested\" no longer has a -1 value for 'never requested'.\n fix: \"last requested\" in channel info sometimes not updated\n fix: deleting empty channels\n change: more compact message ids\n0.931 (Dec. 14 2015)\n optimize: inter-process internal subscriber fetched too many messages\n0.93 (Dec. 12 2015)\n feature: optionally only use Etag for subscriber message id\n feature: optionally get requested message id from variable config\n0.92 (Dec. 11 2015)\n feature: HTTP multipart/mixed subscriber\n fix: EventSource bad memory access on disconnect\n feature: HTTP chunked encoding subscriber\n fix: resolved some strict compiler warnings\n fix: more stringent out-of-memory detection during response output. thanks @woodyhymns\n fix: less-than-optimal cache filename handling. thanks @ZhouBox\n fix: incorrect EventSource charset in header. thanks @eschultz\n fix: segfault when websocket publishes message and immediately disconnects\n fix: Duplicate \"Connection: Upgrade\" header for websocket handshake. thanks @eschultz \n0.904 (Dec. 7 2015)\n fix: more flexible Websocket handshake for \"Connection\" header. thanks @eschultz\n fix: out-of-memory safety check. thanks @woodyhymns\n0.903 (Dec 3 2015)\n fix: better Redis engine connection initializer\n change: simpler message buffer settings\n fix: more backwards-compatibility for pushmodule config settings\n0.9 (Dec. 2 2015) - first beta pre-release tag after rebranding as Nchan\n feature: meta channel events: track when subscribers connect and disconnect, and when messages are\n          published, with configurable event strings\n feature: request authorization: send upstream request before publishing or subscribing.\n          works just like the auth_request module.\n feature: channel multiplexing. up to 4 channels can be subscribed to from a single location\n fix: channel ids were not set within if statements in the nginx config\n feature: hybrid memstore + Redis storage. local caching + distributed message publishing, the best\n          of both worlds. (still slower than pure memstore though)\n feature: pubsub locations, optional separate publisher and subscriber channel ids per location\n feature: websocket publisher support\n name change: we're nchan now. code renamed, and cleaned up. config options are backwards-compatible.\n feature: websocket subscriber support\n huge refactor: completely new in-memory storage engine. No more global lock.\n    Actually, no more locks at all!\n feature: Redis storage engine. \n0.73 (Sep. 2 2014)\n fix: turning on gzip cleared Etag subscriber response header\n fix: channels incorrectly deleted when overwhelmed with connections\n feature: CORS support via OPTIONS request method response\n fix: file descriptor leak when restarting nginx via SIGHUP\n improve: concurrency for interprocess notifications\n refactor: completely encapsulated message store\n fix: slow memory leak introduced in 0.7\n fix: memory leak when not using message buffer\n0.712 (Mar. 21 2014)\n fix: intermittently dropped long-polling connections on internal redirects\n fix: unable to proxy long-polling subscribers. (thanks wandenberg and sanmai)\n0.711 (Mar. 13 2014)\n fix: incompatibility with cache manager (proxy_cache and fastcgi_cache directives)\n0.71 (Mar. 1 2014)\n fix: removed unused variables and functions to quiet down GCC\n0.7: (Feb. 20 2014)\n fix: last-in concurrency setting wasn't working reliably\n refactor: partially separated message storage. add a test harness.\n fix: segfault from concurrency bug while garbage-collecting channels\n fix: some large messages got lost\n0.692 (Feb. 3 2010)\n fix: error log reported failed close() for some publisher requests with large messages\n fix: occasional memory leak during message deletion\n fix: worker messages intended for dead worker processes were not deleted\n0.691 (Feb. 2 2010)\n fix: server reload (via SIGHUP signal) was failing\n fix: segfault on messages longer than client_body_buffer_size (thanks wfelipe)\n change: removed push_min_message_recipients, added push_delete_oldest_received_message\n0.69 (Nov. 17 2009)\n fix: publisher got a 201 Created response even if the channel had no subscribers at the time (should be 202 Accepted)\n fix: small memory leak after each message broadcast to a channel\n feature: optional push_max_channel_subscribers setting added\n fix: first-in concurrency setting wasn't responding to subscribers with a correct status code on conflict\n fix: reused subscriber connections sometimes failed to receive messages\n unfeature: no more nginx 0.6 support. not worth the hassle.\n0.683 (Nov. 10 2009)\n change: default max. reserved memory size changed form 16MB to 32 MB\n change: unused node garbage collection made a little more aggressive (max. 3 unused channels per channel search instead of 1)\n fix: unused nodes were deleted only on channel id hash collision (very rare)\n fix: segmentation fault from allocating insufficient memory for interprocess messaging\n0.681 (Nov. 6 2009)\n feature: added push_message_buffer_length setting, which sets push_message_max_buffer_length and push_message_min_buffer_length at once.\n fix: publisher channel info text/json response now uses double quotes instead of single.\n fix: interprocess messages were not removed from shared memory correctly, causing weird errors\n0.68 (Nov. 5 2009)\n change: default push_subscriber_concurrency value is now \"broadcast\"\n fix: incorrect error messages for invalid push_pubscriber and push_subscriber_concurrency settings\n change: removed deprecated push_buffer_size and push_queue_messages settings\n feature: rudimentary content-type negotiation for publisher channel info response.\n   support text/plain, text/json, text/yaml and application/xml (and mimetype equivalents)\n fix: publisher GET response has HTTP status 0\n0.67beta (Nov. 4 2009) and older\n see git repository\n"
        },
        {
          "name": "cloc-exclude.txt",
          "type": "blob",
          "size": 0.3076171875,
          "content": "src/uthash.h\nsrc/hiredis\nsrc/util/ngx_nchan_hacked_slab.c\nsrc/util/hdr_histogram.c\nsrc/util/hdr_histogram.h\nsrc/store/redis/cmp.c\nsrc/store/redis/cmp.h\nsrc/store/redis/redis_lua_commands.h\nsrc/nginx-source\nsrc/nchan_config_commands.c\ndev/bench\ndev/nginx-pkg\ndev/clang-analyzer\ndev/package\ndev/src\ndev/redis-trib.rb\n"
        },
        {
          "name": "config",
          "type": "blob",
          "size": 5.2138671875,
          "content": "ngx_addon_name=ngx_nchan_module\n\nnchan_libs=\"\"\n#do we have hiredis on the platform?\n# it's currently no longer possible to link the platform's hiredis lib, \n# because we now use a hacked connect function\n# maybe it can be brought back at some later time...\nngx_feature=\"hiredis with stored sockaddr\"\nngx_feature_name=\"NCHAN_HAVE_HIREDIS_WITH_SOCKADDR\"\nngx_feature_run=yes\nngx_feature_path=\nngx_feature_incs=\" \\\n  #include <hiredis/hiredis.h>\n  #include <sys/socket.h>\n\"\nngx_feature_libs=\"-lhiredis\"\nngx_feature_test=\" \\\n  redisContext c; \\\n  if(HIREDIS_SONAME < 0.13) { return 1; } \\\n  if(sizeof(c.sockaddr) != sizeof(struct sockaddr)) { return 1;} \\\n\"\n. auto/feature\nif [ $ngx_found = no ]; then\n  _NCHAN_HIREDIS_SRCS=\"\\\n    ${ngx_addon_dir}/src/store/redis/hiredis/alloc.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/async.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/dict.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/hiredis.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/net.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/read.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/sds.c \\\n    ${ngx_addon_dir}/src/store/redis/hiredis/sockcompat.c \\\n  \"\n  \n  if [ $USE_OPENSSL = YES ]; then\n    _NCHAN_HIREDIS_SRCS=\"$_NCHAN_HIREDIS_SRCS\\\n      ${ngx_addon_dir}/src/store/redis/hiredis/ssl.c \\\n    \"\n  fi\n  \n  ngx_feature_libs=\"\"\nelse\n  nchan_libs=\"$nchan_libs $ngx_feature_libs\"\n  _NCHAN_HIREDIS_SRCS=\"\"\nfi\n\nngx_feature=\"math lib\"\nngx_feature_name=\"NCHAN_HAVE_MATH\"\nngx_feature_run=yes\nngx_feature_path=\nngx_feature_incs=\"#include <math.h>\"\nngx_feature_libs=\"-lm\"\nngx_feature_test=\"sqrt(20);\"\n. auto/feature\nif [ $ngx_found = yes ]; then\n  nchan_libs=\"$nchan_libs $ngx_feature_libs\"\nfi\n\n#do we have memrchr() on the platform?\nngx_feature=\"memrchr()\"\nngx_feature_name=\"NCHAN_HAVE_MEMRCHR\"\nngx_feature_run=yes\nngx_feature_path=\nngx_feature_libs=\nngx_feature_incs=\" \\\n  #include <string.h> \n  #include <stddef.h> \n\"\nngx_feature_test=\" \\\n  const char *str = \\\"aboobar\\\"; \\\n  const void *place = &str[4]; \\\n  const void *found = memrchr(str, 'b', strlen(str)); \\\n  if(place != found) { return 1; } \\\n\"\n. auto/feature\n\n_NCHAN_SUBSCRIBERS_SRCS=\"\\\n  ${ngx_addon_dir}/src/subscribers/common.c \\\n  ${ngx_addon_dir}/src/subscribers/longpoll.c \\\n  ${ngx_addon_dir}/src/subscribers/intervalpoll.c \\\n  ${ngx_addon_dir}/src/subscribers/eventsource.c \\\n  ${ngx_addon_dir}/src/subscribers/http-chunked.c \\\n  ${ngx_addon_dir}/src/subscribers/http-multipart-mixed.c \\\n  ${ngx_addon_dir}/src/subscribers/http-raw-stream.c \\\n  ${ngx_addon_dir}/src/subscribers/websocket.c \\\n  ${ngx_addon_dir}/src/nchan_websocket_publisher.c \\\n  ${ngx_addon_dir}/src/subscribers/internal.c \\\n  ${ngx_addon_dir}/src/subscribers/memstore_ipc.c \\\n  ${ngx_addon_dir}/src/subscribers/memstore_multi.c \\\n  ${ngx_addon_dir}/src/subscribers/memstore_redis.c \\\n  ${ngx_addon_dir}/src/subscribers/getmsg_proxy.c \\\n  ${ngx_addon_dir}/src/subscribers/benchmark.c \\\n\"\n\n_NCHAN_REDIS_STORE_SRCS=\"\\\n  ${_NCHAN_HIREDIS_SRCS} \\\n  ${ngx_addon_dir}/src/store/redis/cmp.c \\\n  ${ngx_addon_dir}/src/store/redis/redis_lua_commands.c \\\n  ${ngx_addon_dir}/src/store/redis/redis_nodeset_parser.c \\\n  ${ngx_addon_dir}/src/store/redis/redis_nodeset.c \\\n  ${ngx_addon_dir}/src/store/redis/redis_nodeset_stats.c \\\n  ${ngx_addon_dir}/src/store/redis/rdsstore.c \\\n  ${ngx_addon_dir}/src/store/redis/redis_nginx_adapter.c \\\n\"\n_NCHAN_MEMORY_STORE_SRCS=\"\\\n  ${ngx_addon_dir}/src/store/memory/ipc.c \\\n  ${ngx_addon_dir}/src/store/memory/ipc-handlers.c \\\n  ${ngx_addon_dir}/src/store/memory/groups.c \\\n  ${ngx_addon_dir}/src/store/memory/memstore.c \\\n\"\n\n_nchan_util_dir=\"${ngx_addon_dir}/src/util\"\n_NCHAN_UTIL_SRCS=\" \\\n  $_nchan_util_dir/nchan_debug.c \\\n  $_nchan_util_dir/nchan_list.c \\\n  $_nchan_util_dir/nchan_slist.c \\\n  $_nchan_util_dir/ngx_nchan_hacked_slab.c \\\n  $_nchan_util_dir/shmem.c \\\n  $_nchan_util_dir/nchan_rbtree.c \\\n  $_nchan_util_dir/nchan_reuse_queue.c \\\n  $_nchan_util_dir/nchan_output.c \\\n  $_nchan_util_dir/nchan_util.c \\\n  $_nchan_util_dir/nchan_fake_request.c \\\n  $_nchan_util_dir/nchan_bufchainpool.c \\\n  $_nchan_util_dir/nchan_channel_id.c \\\n  $_nchan_util_dir/nchan_output_info.c \\\n  $_nchan_util_dir/nchan_msg.c \\\n  $_nchan_util_dir/nchan_thingcache.c \\\n  $_nchan_util_dir/nchan_reaper.c \\\n  $_nchan_util_dir/nchan_subrequest.c \\\n  $_nchan_util_dir/nchan_benchmark.c \\\n  $_nchan_util_dir/nchan_stats.c \\\n  $_nchan_util_dir/nchan_accumulator.c \\\n  $_nchan_util_dir/nchan_timequeue.c \\\n  $_nchan_util_dir/hdr_histogram.c \\\n\"\n\n_NCHAN_STORE_SRCS=\"\\\n  ${ngx_addon_dir}/src/store/spool.c \\\n  ${ngx_addon_dir}/src/store/ngx_rwlock.c \\\n  ${ngx_addon_dir}/src/store/store_common.c \\\n  $_NCHAN_MEMORY_STORE_SRCS \\\n  $_NCHAN_REDIS_STORE_SRCS \\\n\"\n\n_NCHAN_SRCS=\"\\\n  ${ngx_addon_dir}/src/nchan_defs.c \\\n  ${ngx_addon_dir}/src/nchan_variables.c \\\n  ${ngx_addon_dir}/src/nchan_module.c \\\n  $_NCHAN_UTIL_SRCS \\\n  $_NCHAN_SUBSCRIBERS_SRCS \\\n  $_NCHAN_STORE_SRCS \\\n\"\n\nngx_module_incs=$ngx_addon_dir/src\n\nhave=NGX_HTTP_HEADERS . auto/have\n\nif test -n \"$ngx_module_link\"; then\n  ngx_module_type=HTTP\n  ngx_module_name=$ngx_addon_name\n  ngx_module_srcs=\"$_NCHAN_SRCS\"\n  ngx_module_libs=$nchan_libs\n  . auto/module\nelse\n  NGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $_NCHAN_SRCS\"\n  CORE_LIBS=\"$CORE_LIBS $nchan_libs\"\n  CORE_INCS=\"$CORE_INCS $ngx_module_incs\"\n  HTTP_MODULES=\"$HTTP_MODULES $ngx_addon_name\"\nfi\n"
        },
        {
          "name": "dev",
          "type": "tree",
          "content": null
        },
        {
          "name": "nchan_logo.png",
          "type": "blob",
          "size": 24.0009765625,
          "content": null
        },
        {
          "name": "src",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}