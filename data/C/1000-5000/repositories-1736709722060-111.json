{
  "metadata": {
    "timestamp": 1736709722060,
    "page": 111,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "icholy/ttygif",
      "stars": 3962,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0322265625,
          "content": "*.o\n*.swp\n*.gif\nttyrecord\nttygif\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2025 Ilia Choly\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5205078125,
          "content": "CC = gcc\nVERSION = '\"1.4.0\"'\nCFLAGS += -O2 -Wall -DVERSION=$(VERSION)\nPREFIX ?= /usr/local\n\nUNAME := $(shell uname)\nifeq ($(UNAME), Darwin)\n\tCFLAGS += -DOS_DARWIN\nendif\nifeq ($(UNAME), Linux)\n\tCFLAGS += -DOS_LINUX\nendif\n\nall: ttygif\n\nttygif: ttygif.o io.o string_builder.o utils.o\n\t$(CC) $(CFLAGS) -o ttygif ttygif.o io.o string_builder.o utils.o\n\ninstall: ttygif\n\tinstall -d $(PREFIX)/bin\n\tinstall -m755 ttygif $(PREFIX)/bin/ttygif\n\nuninstall: $(PREFIX)/bin/ttygif\n\trm -f $(PREFIX)/bin/ttygif\n\nclean:\n\trm -f *.o ttygif ttyrecord *~\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.0771484375,
          "content": "![](ttygif.png)\n\n> ttygif converts a ttyrec file into gif files.\n> It's a stripped down version of ttyplay that screenshots every frame.\n\n## Demo\n\n![gif](http://i.imgur.com/nvEHTgn.gif)\n\n## Setup\n\n### Debian/Ubuntu\n``` sh\n$ sudo apt-get install imagemagick ttyrec gcc x11-apps make git\n$ git clone https://github.com/icholy/ttygif.git\n$ cd ttygif\n$ make\n$ sudo make install\n```\n\n### Fedora/CentOS/RHEL\n``` sh\n$ sudo dnf install ImageMagick gcc xorg-x11-apps\n$ # install ttyrec from source patched ~> https://github.com/mattwilmott/ttyrec\n$ git clone https://github.com/icholy/ttygif.git\n$ cd ttygif\n$ make\n$ sudo make install\n```\n\n### OpenSUSE Leap\n```sh\n$ zypper addrepo http://download.opensuse.org/repositories/utilities/openSUSE_Leap_42.2/utilities.repo\n$ zypper refresh\n$ zypper install ttygif\n```\n\n### Arch Linux\n``` sh\n$ git clone https://aur.archlinux.org/ttyrec.git\n$ cd ttyrec\n$ makepkg -i\n$ cd ..\n$ git clone https://aur.archlinux.org/ttygif.git\n$ cd ttygif\n$ makepkg -is\n```\n\nWith yaourt installed:\n```sh\n$ yaourt -S ttyrec ttygif\n```\n\n### macOS\n``` sh\n$ brew install ttygif\n```\n\n## Usage:\n\n**1. Create ttyrec recording**\n\n``` sh\n$ ttyrec myrecording\n```\n\n* Hit CTRL-D or type `exit` when done recording.\n\n**2. Convert to gif**\n\n``` sh\n$ ttygif myrecording\n```\n\nOn OSX optionally you can set a -f flag which will bypass cropping which is needed for terminal apps which aren't full screen.\nBoth standard Terminal and iTerm apps are supported.\n\n``` sh\n$ ttygif myrecording -f\n```\n\n## Additional Notes\n\nIf you're getting `Error: WINDOWID environment variable was empty.`, then you need to manually set `WINDOWID`.\n\n``` sh\nexport WINDOWID=23068679\n```\n\nIf you're on Ubuntu, you can use `xdotool` to find the WINDOWID\n``` sh\n$ sudo apt-get install xdotool\n$ export WINDOWID=$(xdotool getwindowfocus)\n```\n\n## Debugging\n\nIf you're having issues, then export the `TTYGIF_DEBUG` env variable.\n\n``` sh\nexport TTYGIF_DEBUG=1\n```\n\nThis will print out all the commands it's trying to run.\n\n## Credits\n\nThe idea and approach was adapted from [tty2gif](https://bitbucket.org/antocuni/tty2gif)\n\n![](http://i.imgur.com/9et8daN.jpg)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.37109375,
          "content": "## Reporting a Vulnerability\n\nIf you have discovered a security vulnerability in this software, we appreciate your help in disclosing it to us responsibly. \n\nTo report a security vulnerability, please email us at [ilia.choly@gmail.com](mailto:ilia.choly@gmail.com). \n\nPlease include:\n- A brief description of what you believe the vulnerability is.\n- Steps to reproduce the issue.\n"
        },
        {
          "name": "Slackbuild",
          "type": "tree",
          "content": null
        },
        {
          "name": "io.c",
          "type": "blob",
          "size": 4.0947265625,
          "content": "/*\n * Copyright (c) 2000 Satoru Takabayashi <satoru@namazu.org>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *\tThis product includes software developed by the University of\n *\tCalifornia, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <assert.h>\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"ttyrec.h\"\n\n#define SWAP_ENDIAN(val) ((unsigned int) ( \\\n    (((unsigned int) (val) & (unsigned int) 0x000000ffU) << 24) | \\\n    (((unsigned int) (val) & (unsigned int) 0x0000ff00U) <<  8) | \\\n    (((unsigned int) (val) & (unsigned int) 0x00ff0000U) >>  8) | \\\n    (((unsigned int) (val) & (unsigned int) 0xff000000U) >> 24)))\n\nstatic int \nis_little_endian ()\n{\n  static int retval = -1;\n\n  if (retval == -1) {\n    int n = 1;\n    char *p = (char *)&n;\n    char x[] = {1, 0, 0, 0};\n\n    assert(sizeof(int) == 4);\n\n    if (memcmp(p, x, 4) == 0) {\n      retval = 1;\n    } else {\n      retval = 0;\n    }\n  }\n\n  return retval;\n}\n\nstatic int\nconvert_to_little_endian (int x)\n{\n  if (is_little_endian()) {\n    return x;\n  } else {\n    return SWAP_ENDIAN(x);\n  }\n}\n\nint\nread_header (FILE *fp, Header *h)\n{\n  int buf[3];\n\n  if (fread(buf, sizeof(int), 3, fp) == 0) {\n    return 0;\n  }\n\n  h->tv.tv_sec  = convert_to_little_endian(buf[0]);\n  h->tv.tv_usec = convert_to_little_endian(buf[1]);\n  h->len        = convert_to_little_endian(buf[2]);\n\n  return 1;\n}\n\nint\nwrite_header (FILE *fp, Header *h)\n{\n  int buf[3];\n\n  buf[0] = convert_to_little_endian(h->tv.tv_sec);\n  buf[1] = convert_to_little_endian(h->tv.tv_usec);\n  buf[2] = convert_to_little_endian(h->len);\n\n  if (fwrite(buf, sizeof(int), 3, fp) == 0) {\n    return 0;\n  }\n\n  return 1;\n}\n\nstatic char *progname = \"\";\nvoid\nset_progname (const char *name)\n{\n    progname = strdup(name);\n}\n\nFILE *\nefopen (const char *path, const char *mode)\n{\n  FILE *fp = fopen(path, mode);\n  if (fp == NULL) {\n    fprintf(stderr, \"%s: %s: %s\\n\", progname, path, strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n  return fp;\n}\n\nint\nedup (int oldfd)\n{\n  int fd = dup(oldfd);\n  if (fd == -1) {\n    fprintf(stderr, \"%s: dup failed: %s\\n\", progname, strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n  return fd;\n}\n\nint\nedup2 (int oldfd, int newfd)\n{\n  int fd = dup2(oldfd, newfd);\n  if (fd == -1) {\n    fprintf(stderr, \"%s: dup2 failed: %s\\n\", progname, strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n  return fd;\n}\n\nFILE *\nefdopen (int fd, const char *mode)\n{\n  FILE *fp = fdopen(fd, mode);\n  if (fp == NULL) {\n    fprintf(stderr, \"%s: fdopen failed: %s\\n\", progname, strerror(errno));\n    exit(EXIT_FAILURE);\n  }\n  return fp;\n}\n"
        },
        {
          "name": "io.h",
          "type": "blob",
          "size": 0.4052734375,
          "content": "#ifndef __TTYREC_IO_H__\n#define __TTYREC_IO_H__\n\n#include \"ttyrec.h\"\n\nint     read_header     (FILE *fp, Header *h);\nint     write_header    (FILE *fp, Header *h);\nFILE*   efopen          (const char *path, const char *mode);\nvoid    set_progname    (const char *name);\nint     edup            (int oldfd);\nint     edup2           (int oldfd, int newfd);\nFILE*   efdopen         (int fd, const char *mode);\n\n#endif\n"
        },
        {
          "name": "string_builder.c",
          "type": "blob",
          "size": 1.3046875,
          "content": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"string_builder.h\"\n\nvoid *\nStringBuilder_malloc(size_t size)\n{\n    void *p = malloc(size);\n    if (p == NULL) {\n        fprintf(stderr, \"StringBuilder: OUT OF MEMORY\\n\");\n        exit(EXIT_FAILURE);\n    }\n    return p;\n}\n\nStringBuilder *\nStringBuilder_new(void)\n{\n    StringBuilder *sb = StringBuilder_malloc(sizeof(StringBuilder));\n    sb->size = 1;\n    sb->cap = INITIAL_CAPACITY;\n\n    char *s = StringBuilder_malloc(sizeof(char) * INITIAL_CAPACITY);\n    s[0] = '\\0';\n    sb->s = s;\n\n    return sb;\n}\n\nvoid\nStringBuilder_free(StringBuilder *sb)\n{\n    free(sb->s);\n    free(sb);\n}\n\nvoid\nStringBuilder_resize(StringBuilder *sb, size_t capacity)\n{\n    char *s = StringBuilder_malloc(sizeof(char) * capacity);\n    strncpy(s, sb->s, sb->size);\n    free(sb->s);\n    sb->s = s;\n    sb->cap = capacity;\n}\n\nchar *\nStringBuilder_str(StringBuilder *sb)\n{\n    return sb->s;\n}\n\nvoid\nStringBuilder_write_char(StringBuilder *sb, char c)\n{\n    size_t size = sb->size;\n    if (size >= sb->cap) {\n        StringBuilder_resize(sb, sb->cap * 2);\n    }\n    sb->s[size - 1] = c;\n    sb->s[size - 0] = '\\0';\n    sb->size++;\n}\n\nvoid\nStringBuilder_write(StringBuilder *sb, const char *s)\n{\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        StringBuilder_write_char(sb, s[i]);\n    }\n}\n"
        },
        {
          "name": "string_builder.h",
          "type": "blob",
          "size": 0.431640625,
          "content": "#ifndef STRING_BUILDER_H\n#define STRING_BUILDER_H\n\ntypedef struct {\n    size_t size;\n    size_t cap;\n    char *s;\n} StringBuilder;\n\n#define INITIAL_CAPACITY 256\n\nStringBuilder * StringBuilder_new(void);\nvoid StringBuilder_free(StringBuilder *sb);\nchar * StringBuilder_str(StringBuilder *sb);\nvoid StringBuilder_write_char(StringBuilder *sb, char c);\nvoid StringBuilder_write(StringBuilder *sb, const char *s);\n\n#endif /* STRING_BUILDER_H */\n\n"
        },
        {
          "name": "ttygif.c",
          "type": "blob",
          "size": 10.2568359375,
          "content": "/*\n * Copyright (c) 2000 Satoru Takabayashi <satoru@namazu.org>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. All advertising materials mentioning features or use of this software\n *    must display the following acknowledgement:\n *  This product includes software developed by the University of\n *  California, Berkeley and its contributors.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <unistd.h>\n#include <termios.h>\n#include <sys/time.h>\n#include <string.h>\n#include <stdbool.h>\n\n#include \"ttyrec.h\"\n#include \"io.h\"\n#include \"string_builder.h\"\n#include \"utils.h\"\n\ntypedef struct {\n    bool fullscreen;\n    bool debug;\n    int skip_limit;       // Skip at most this many consecutive frames\n    int skip_threshold;   // Skip frames shown for at most this long (because they're intermediate states)\n    int last_frame_delay; // How long to show the last frame before looping, in milliseconds\n    double speed;         // Speed to replay the recording defaults to 1.0\n    const char *window_id;\n    const char *img_ext;\n    const char *img_dir;\n    const char *out_file;\n} Options;\n\ntypedef int    (*ReadFunc)    (FILE *fp, Header *h, char **buf);\ntypedef void   (*WriteFunc)   (char *buf, int len);\ntypedef void   (*ProcessFunc) (FILE *fp, ReadFunc read_func, Options o);\n\nstruct timeval\ntimeval_diff (struct timeval tv1, struct timeval tv2)\n{\n    struct timeval diff;\n\n    diff.tv_sec = tv2.tv_sec - tv1.tv_sec;\n    diff.tv_usec = tv2.tv_usec - tv1.tv_usec;\n\n    if (diff.tv_usec < 0) {\n        diff.tv_sec--;\n        diff.tv_usec += 1000000;\n    }\n\n    return diff;\n}\n\nint\nttydelay (struct timeval prev, struct timeval cur)\n{\n    struct timeval diff = timeval_diff(prev, cur);\n    if (diff.tv_sec < 0) {\n        diff.tv_sec = diff.tv_usec = 0;\n    }\n    return (diff.tv_sec * 1000) + (diff.tv_usec / 1000);\n}\n\nint\nttyread (FILE *fp, Header *h, char **buf)\n{\n    if (read_header(fp, h) == 0) {\n        return 0;\n    }\n\n    *buf = malloc(h->len);\n    if (*buf == NULL) {\n        fatalf(\"Error: Out of memory (malloc)\");\n    }\n\n    if (fread(*buf, 1, h->len, fp) == 0) {\n        fatalf(\"Error: Failed to read (fread)\");\n    }\n    return 1;\n}\n\nvoid\nttywrite (char *buf, int len)\n{\n    fwrite(buf, 1, len, stdout);\n    fflush(stdout);\n}\n\nvoid\nclear_screen (void) {\n    printf(\"\\e[1;1H\\e[2J\");\n}\n\nvoid\nsystem_exec(const char *cmd, Options o)\n{\n    if (o.debug) {\n        printf(\"DEBUG: %s\\n\", cmd);\n        return;\n    }\n    if (system(cmd) != 0) {\n        fatalf(\"failed to execute: %s\\n\", cmd);\n    }\n}\n\nint\ntake_snapshot_darwin(const char *img_path, Options o)\n{\n    static char cmd [256];\n\n    if (sprintf(cmd,\n            \"screencapture -x -l%s -o -m %s &> /dev/null\",\n            o.window_id, img_path) < 0) {\n        return -1;\n    }\n\n    system_exec(cmd, o);\n\n    if (!o.fullscreen) {\n        if (sprintf(cmd,\n                \"convert %s -background white -quiet -flatten +matte -crop +0+22 -crop +4+0 -crop -4-0 +repage %s &> /dev/null\",\n                img_path, img_path) < 0) {\n            return -1;\n        }\n    }\n\n    system_exec(cmd, o);\n\n    return 0;\n}\n\nint\ntake_snapshot_linux(const char *img_path, Options o)\n{\n    static char cmd [256];\n\n    // ensure text has been written before taking screenshot\n    usleep(50000);\n\n    if (sprintf(cmd, \"xwd -id %s -out %s\", o.window_id, img_path) < 0) {\n        return -1;\n    }\n\n    system_exec(cmd, o);\n    return 0;\n}\n\nint\ntake_snapshot(const char *img_path, Options o)\n{\n#ifdef OS_DARWIN\n    return take_snapshot_darwin(img_path, o);\n#else\n    return take_snapshot_linux(img_path, o);\n#endif\n}\n\nvoid\nttyplay (FILE *fp, ReadFunc read_func, WriteFunc write_func, Options o)\n{\n    int index = 0;\n    int delay = 0;\n    struct timeval prev;\n\n    if (!o.debug) {\n        clear_screen();\n    }\n\n    setbuf(stdout, NULL);\n    setbuf(fp, NULL);\n\n    StringBuilder *sb = StringBuilder_new();\n    StringBuilder_write(sb, \"convert -loop 0 \");\n\n    int nskipped = 0;\n    bool skip = false;\n\n    char img_path[256] = \"\";\n    char arg_buffer[256] = \"\";\n    \n    while (true) {\n\n        char *buf;\n        Header h;\n\n        if (read_func(fp, &h, &buf) == 0) {\n            snprintf(arg_buffer, sizeof(arg_buffer), \" -delay %f %s\", o.last_frame_delay*0.1, img_path);\n            StringBuilder_write(sb, arg_buffer);\n\n            break;\n        }\n\n        if (!o.debug) {\n            write_func(buf, h.len);\n        }\n\n        if (index != 0) {\n            delay = ttydelay(prev, h.tv) / o.speed;\n        }\n\n        if (index > 0 && delay <= o.skip_threshold) {\n            skip = true;\n            nskipped++;\n        } else {\n            skip = false;\n            nskipped = 0;\n        }\n\n        if (skip && nskipped > o.skip_limit) {\n            nskipped = 0;\n            skip = false;\n        }\n\n        if (!skip && index != 0) {\n            if (sprintf(arg_buffer, \" -delay %f %s\", delay * 0.1, img_path) < 0) {\n                fatalf(\"Error: Failed to format 'convert' parameters\");\n            }\n            StringBuilder_write(sb, arg_buffer);\n        }\n        if (!skip) {\n            if (sprintf(img_path, \"%s/%d.%s\", o.img_dir, index, o.img_ext) < 0) {\n                fatalf(\"Error: Failed to format filename\");\n            }\n            if (take_snapshot(img_path, o) != 0) {\n                fatalf(\"Error: Failed to take snapshot\");\n            }\n        }\n        \n        if (index == 0 || !skip) {\n            index++;\n        }\n\n        prev = h.tv;\n        free(buf);\n    }\n\n    StringBuilder_write(sb, \" -layers Optimize \");\n    StringBuilder_write(sb, \"GIF:\");\n    StringBuilder_write(sb, o.out_file);\n    StringBuilder_write(sb, \" 2>&1\");\n    \n    printf(\"Creating Animated GIF ... this can take a while\\n\");\n    system_exec(sb->s, o);\n    printf(\"Created: %s in the current directory!\\n\", o.out_file);\n\n    StringBuilder_free(sb);\n}\n\nvoid ttyplayback (FILE *fp, ReadFunc read_func, Options o)\n{\n    ttyplay(fp, ttyread, ttywrite, o);\n}\n\nvoid\nusage (void)\n{\n#ifdef OS_DARWIN\n    printf(\"Usage: ttygif [FILE] [-f]\\n\");\n    printf(\"  -f, --fullscreen : include window border\\n\");\n#else\n    printf(\"Usage: ttygif [FILE]\\n\");\n#endif\n    printf(\"  -s, --speed : Set speed [1.0]\\n\");\n    printf(\"  -h, --help : print this help\\n\");\n    printf(\"  -v, --version : print version\\n\");\n}\n\nint\nmain (int argc, char **argv)\n{\n    ReadFunc read_func  = ttyread;\n    ProcessFunc process = ttyplayback;\n    FILE *input = NULL;\n    struct termios old, new;\n\n    Options options;\n    options.fullscreen = false;\n    options.skip_limit = 5;\n    options.skip_threshold = 0;\n    options.last_frame_delay = 1000;\n    options.debug = getenv(\"TTYGIF_DEBUG\") != NULL;\n    options.out_file = \"tty.gif\";\n    options.speed = 1.0;\n\n    char dir_template[] = \"/tmp/ttygif.XXXXXX\";\n    options.img_dir = mkdtemp(dir_template);\n    if (options.img_dir == NULL) {\n        fatalf(\"Error: Failed to create tmp directory.\");\n    }\n\n\n#ifdef OS_DARWIN\n    options.img_ext = \"png\";\n    const char *terminal_app = getenv(\"TERM_PROGRAM\");\n    if (terminal_app == NULL || !strlen(terminal_app)) {\n        fatalf(\"Error: TERM_PROGRAM environment variable was empty.\");\n    }\n    if (strcmp(terminal_app, \"Apple_Terminal\") == 0) {\n        terminal_app = \"Terminal.app\";\n    }\n    int window_id = osx_get_window_id(terminal_app);\n    char window_id_buffer[256];\n    sprintf(window_id_buffer, \"%d\", window_id);\n    options.window_id = window_id_buffer;\n#else\n    options.img_ext = \"xwd\";\n    options.window_id = getenv(\"WINDOWID\");\n    if (options.window_id == NULL || !strlen(options.window_id)) {\n        fatalf(\"Error: WINDOWID environment variable was empty.\");\n    }\n#endif\n\n    if (options.debug) {\n        printf(\"window_id: %s\\n\", options.window_id);\n    }\n\n    if (argc < 2) {\n        usage();\n\n        exit(EXIT_FAILURE);\n    }\n\n    if (argc == 2) {\n        if (strstr(argv[1], \"-h\") || strstr(argv[1], \"--help\")) {\n            usage();\n            exit(EXIT_SUCCESS);\n        }\n\n        if (strstr(argv[1], \"-v\") || strstr(argv[1], \"--version\")) {\n            printf(VERSION\"\\n\");\n            exit(EXIT_SUCCESS);\n        }\n    }\n\n    if (argc >= 3) {\n        \n        int i;\n\n        for (i=0; i<argc; i++)\n        {\n            if (strstr(argv[i], \"-f\") || strstr(argv[i], \"--fullscreen\")) {\n                options.fullscreen = true;\n            }\n\n            if ((strstr(argv[i], \"-s\") || strstr(argv[i], \"--speed\")) && argc > i+1) {\n                char *end;\n                double speed = strtod(argv[i+1], &end);\n                if (end > argv[i+1])\n                    options.speed = speed;\n            }\n        }\n    }\n\n    set_progname(argv[0]);\n    input = efopen(argv[1], \"r\");\n\n    assert(input != NULL);\n\n    tcgetattr(0, &old); /* Get current terminal state */\n    new = old;          /* Make a copy */\n    new.c_lflag &= ~(ICANON | ECHO | ECHONL); /* unbuffered, no echo */\n    tcsetattr(0, TCSANOW, &new); /* Make it current */\n\n    process(input, read_func, options);\n    tcsetattr(0, TCSANOW, &old);  /* Return terminal state */\n\n    return 0;\n}\n"
        },
        {
          "name": "ttygif.png",
          "type": "blob",
          "size": 1.01953125,
          "content": null
        },
        {
          "name": "ttyrec.h",
          "type": "blob",
          "size": 0.1416015625,
          "content": "#ifndef __TTYREC_H__\n#define __TTYREC_H__\n\n#include \"sys/time.h\"\n\ntypedef struct header {\n    struct timeval tv;\n    int len;\n} Header;\n\n\n#endif\n"
        },
        {
          "name": "utils.c",
          "type": "blob",
          "size": 1.0400390625,
          "content": "#include <stdio.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include \"string_builder.h\"\n\nvoid fatalf(const char *format, ...)\n{\n    va_list args;\n    va_start(args, format);\n    vfprintf(stderr, format, args);\n    va_end(args);\n    exit(EXIT_FAILURE);\n}\n\nint osx_get_window_id(const char *app_name)\n{\n    char command[1024];\n    sprintf(command,\n            \"osascript -so -e 'tell app \\\"%s\\\" to id of window 1' 2> /dev/null\",\n            app_name);\n\n    FILE *fp = popen(command, \"r\");\n    if (fp == NULL) {\n        fatalf(\"Error: failed to run command: %s\", command);\n    }\n\n    int window_id;\n    if (fscanf(fp, \"%d\", &window_id) != 1) {\n        fatalf(\"Error: failed to parse window id: %s\", command);\n    }\n\n    pclose(fp);\n\n    return window_id;\n}\n\nint exec_with_output(const char *command)\n{\n    FILE *fp = popen(command, \"r\");\n    if (fp == NULL) {\n        fatalf(\"Error: failed to run command: %s\", command);\n    }\n\n    char buffer[1024];\n    while (fgets(buffer, sizeof(buffer), fp) != NULL) {\n        printf(\"%s\", buffer);\n    }\n\n    return pclose(fp);\n}\n"
        },
        {
          "name": "utils.h",
          "type": "blob",
          "size": 0.1806640625,
          "content": "\n#ifndef _UTILS_H\n#define _UTILS_H\n\nvoid fatalf(const char *format, ...);\nint osx_get_window_id(const char *app_name);\nint exec_with_output(const char *command);\n\n#endif /* _UTILS_H */\n"
        }
      ]
    }
  ]
}