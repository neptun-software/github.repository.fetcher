{
  "metadata": {
    "timestamp": 1736709911840,
    "page": 422,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "adrianlopezroche/fdupes",
      "stars": 2565,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.197265625,
          "content": "fdupes\n*.o\n/Makefile\n/Makefile.in\n/aclocal.m4\n/autom4te.cache\n/compile\n/config.h\n/config.h.in\n/config.h.in~\n/config.log\n/config.status\n/configure\n/depcomp\n/install-sh\n/missing\n/stamp-h1\n.deps\n.dirstamp\n"
        },
        {
          "name": "CHANGES",
          "type": "blob",
          "size": 6.3798828125,
          "content": "The following list, organized by fdupes version, documents changes\nto fdupes. Every item on the list includes, inside square brackets,\na list of indentifiers referring to the people who contributed\nthat particular item. When more than one person is listed the person\nwho contributed the patch or idea appears first, followed by\nthose who've otherwise worked on that item. For a list of \ncontributors names and identifiers please see the CONTRIBUTORS file.\n\nChanges from 2.3.1 to 2.3.2:\n\n - Keep cursor as close to current group as possible after deleting files.\n - Omit endian.h when building on AIX.\n\nChanges from 2.3.0 to 2.3.1:\n\n - Fix buffer overflow bug in getrealpath() function.\n\nChanges from 2.2.1 to 2.3.0:\n\n - Add --cache option to speed up file comparisons.\n - Use nanosecond precision for file times, if available.\n - Fix compilation issue on OpenBSD.\n - Other changes like fixing typos, wording, etc.\n\nChanges from 2.2.0 to 2.2.1:\n\n - Fix bug in code meant to skip over the current log file when --log\n   option is given.\n - Updates to copyright notices in source code.\n\nChanges from 2.1.2 to 2.2.0:\n\n - Add --deferconfirmation option.\n - Check that files marked as duplicates haven't changed during program\n   execution before deleting them.\n - Update documentation to indicate units for SIZE in command-line options.\n - Move some configuration settings to configure.ac file.\n\nChanges from 2.1.1 to 2.1.2:\n\n - Do not enter ncurses mode when --immediate option given.\n - Fix logging/memory corruption bug when using --log with --immediate.\n\nChanges from 2.1.0 to 2.1.1:\n\n - Break mtime ties using ctime when sorting by time.\n - Reduce number of calls to stat(), for speed.\n - Clear last command status when new command is entered.\n\nChanges from 2.0.0 to 2.1.0:\n\n - Rename cs command (\"clear all selections\") from cs to csel.\n - Rename igs command (\"invert selections\") from igs to isel.\n - Add \"prune\" command as synonym for DELETE key.\n - Clear selections after deleting files via prune/DELETE.\n - Fix dependency issues when fdupes is configured to not use ncurses.\n\nChanges from 1.6.1 to 2.0.0:\n\n- Add ncurses mode for interactive file deletion (plain mode still available\n  via --plain or ./configure).\n- Add --minsize option.\n- Add --maxsize option.\n- Add --time option.\n- Add --order=ctime option.\n- Add --log option.\n- Use configure script for installation (Autotools/Automake).\n\nChanges from 1.6.0 to 1.6.1:\n\n- Fix 'invalid option' error for -I. [AL]\n\nChanges from 1.51 to 1.6.0:\n\n- Add --nohidden option. [MC]\n- Add --permissions option. [MV]\n- Add --order option. [SB]\n- Add --reverse option. [AL]\n- Add --immediate option. [AL]\n- Speed up file comparison. [SB, ST]\n- Fix bug where fdupes fails to consistently ignore hardlinks, depending on\n  file processing order, when F_CONSIDERHARDLINKS flag is not set. [AL]\n- Fix bug in is_hardlink(): Proper traversal of duplicates is done via \n  dupe->duplicates, not via dupe->next. [AL]\n- Revise md5.c to compile under OSX. [TH]\n- Remove EXTERNAL_MD5 configuration option. [ID]\n- Various other changes (see git log).\n\nChanges from 1.50 to 1.51\n\n- Added support for 64-bit file offsets on 32-bit systems.\n- Using tty for interactive input instead of regular stdin. This is to\n  allow  feeding filenames via stdin in future versions of fdupes without\n  breaking interactive deletion feature.\n- Fixed some typos in --help.\n- Turned C++ style comments into C style comments.\n\nChanges from 1.40 to 1.50-PR2\n\n- Fixed memory leak. [JB]\n- Added \"--summarize\" option. [AL]\n- Added \"--recurse:\" selective recursion option. [AL]\n- Added \"--noprompt\" option for totally automated deletion of\n  duplicate files.\n- Now sorts duplicates (old to new) for consistent order when\n  listing or deleteing duplicate files.\n- Now tests for early matching of files, which should help speed up\n  the matching process when large files are involved.\n- Added warning whenever a file cannot be deleted. [CHL, AL]\n- Fixed bug where some files would not be closed after failure. [AL]\n- Fixed bug where confirmmatch() function wouldn't always deal\n  properly with zero-length files. [AL]\n- Fixed bug where progress indicator would not be cleared\n  when no files were found. [AL]\n- Removed experimental red-black tree code (it was slower on\n  my system than the default code). [AL]\n- Modified md5/md5.c to avoid compiler warning. [CHL]\n- Changes to fdupes.c for compilation under platforms where\n  getopt_long is unavailable. [LR, AL]\n- Changes to help text for clarity. [AL]\n- Various changes and improvements to Makefile. [PB, AL]\n\nChanges from 1.31 to 1.40\n\n- Added option to omit the first file in each group \n  of matches. [LM, AL]\n- Added escaping of filenames containing spaces when\n  sameline option is specified. [AL]\n- Changed version indicator format from \"fdupes version X.Y\"\n  to the simpler \"fdupes X.Y\". [AL]\n- Changed ordering of options appearing in the help\n  text (--help), manpage, and README file. [AL]\n\nChanges from 1.30 to 1.31\n\n- Added interactive option to preserve all files during\n  delete procedure (something similar was already in \n  place, but now it's official). [AL]\n- Updated delete procedure prompt format. [AL]\n- Cosmetic code changes. [AL]\n\nChanges from 1.20 to 1.30\n\n- Added size option to display size of duplicates. [LB, AL]\n- Added missing typecast for proper compilation under g++. [LB]\n- Better handling of errors occurring during retrieval\n  of a file's signature. [KK, AL]\n- No longer displays an error message when specified\n  directories contain no files. [AL]\n- Added red-black tree structure (experimental compile-time\n  option, disabled by default). [AL]\n\nChanges from 1.12 to 1.20\n\n- Fixed bug where program would crash when files being\n  scanned were named pipes or sockets. [FD]\n- Fix against security risk resulting from the use of a\n  temporary file to store md5sum output. [FD, AL]\n- Using an external md5sum program is now optional. Started \n  using L. Peter Deutsh's MD5 library instead. [FD, AL]\n- Added hardlinks option to distinguish between hard links\n  and actual duplicate files. [FD, AL]\n- Added noempty option to exclude zero-length files\n  from consideration [AL]\n\nChanges from 1.11 to 1.12\n\n- Improved handling of extremely long input on preserve \n  prompt (delete option). [SSD, AL]\n\nChanges from 1.1 to 1.11\n\n- Started checking file sizes before signatures\n  for better performance.  [AB, AL]\n- Added fdupes manpage. [AB, AL]\n\nChanges from 1.0 to 1.1\n\n- Added delete option for semi-automatic deletion\n  of duplicate files. [AL]\n\n"
        },
        {
          "name": "CONTRIBUTORS",
          "type": "blob",
          "size": 0.9404296875,
          "content": "The following people have contributed in some way to the development \nof fdupes. Please see the CHANGES file for detailed information\non their contributions. Names are listed in alphabetical order.\n\n [AB] Adrian Bridgett <adrian.bridgett@iname.com>\n [AL] Adrian Lopez <adrian2@caribe.net>\n[CHL] Charles Longeau <chl@tuxfamily.org>\n [FD] Frank DENIS, a.k.a. \n      Jedi/Sector One, a.k.a. \n      DJ Chrysalis \t\t<j@4u.net>\n [JB] Jean-Baptiste\n [KK] Kresimir Kukulj <madmax@pc-hrvoje.srce.hr>\n [LB] Laurent Bonnaud <Laurent.Bonnaud@iut2.upmf-grenoble.fr>\n [LM] Luca Montecchiani <m.luca@iname.com>\n [LR] Lukas Ruf <lukas@lpr.ch>\n [PB] Peter Bray (Sydney, Australia)\n[SSD] Steven S. Dick <ssd@nevets.oau.org>\n [MC] Maximiliano Curia <maxy@debian.org>\n [MV] Michal Vyskocil <mvyskocil@suse.cz>\n [SB] Stefan Br√ºns <stefan.bruens@rwth-aachen.de>\n [ST] Sandro Tosi <matrixhasu@gmail.com>\n [ID] Ivan Diorditsa <ivan.diorditsa@gmail.com>\n [TH] Tom Hoover <tom@hisword.net>"
        },
        {
          "name": "INSTALL",
          "type": "blob",
          "size": 1.263671875,
          "content": "Installing fdupes\n--------------------------------------------------------------------\nYou're looking at a DEVELOPMENT version of fdupes. If you're not a software\ndeveloper or you just want to install the program, this is probably not the\nversion you want. This version of fdupes is currently in development and\nsubject to change. The features and functionality present in this version\nmay not reflect the features and functionality in the final release.\n\nThe easiest way to install fdupes is to use your operating system's package\nmanager, if available. If that's not an option or you'd prefer to compile\nthe program yourself (which may sometimes be the only way to obtain the\nlatest version), you should download a RELEASE version of fdupes and follow\nthe installation instructions provided with it.\n\nAs of this writing, fdupes releases may be downloaded from:\n\n\thttps://github.com/adrianlopezroche/fdupes/releases\n\nIf you're a programmer and you wish to use or work on this version of fdupes\nyou will need to install autoconf and automake on your system and run\n\n\tautoreconf --install\n\nto generate the configure script and other files needed for compilation and\ninstallation. After that you may compile fdupes by running:\n\n\t./configure\n\tmake\n\nand install it by running:\n\n\tsudo make install\n\n"
        },
        {
          "name": "INSTALL.enduser",
          "type": "blob",
          "size": 1.5048828125,
          "content": "Installing fdupes\n--------------------------------------------------------------------\nTo build and install the program, issue the following commands:\n\n\t./configure\n\tmake\n\tsudo make install\n\nStarting with fdupes 2.0.0, a full-featured installation requires\nthe following libraries to be installed on your system:\n\n  - ncursesw (ncurses with support for wide characters)\n  - PCRE2 (Perl Compatible Regular Expressions library)\n\nSource code for these libraries is available at:\n\n  https://www.gnu.org/software/ncurses/\n  https://www.pcre.org/\n\nIf these libraries are not available on your system or you want to\nbuild fdupes without them, you may instead call configure as:\n\n\t./configure --without-ncurses\n\nfollowed by \"make\" and \"sudo make install\" as before.\n\nPlease note that compiling fdupes without these libraries will\ndisable the new screen-mode interface for choosing which files to\nkeep or delete. Without them, fdupes will use an interface like\nthe one used in previous versions.\n\nThe commands above will build and install fdupes and its\ndocumentation under /usr/local by default. You may change the\ninstall location using:\n\n\t./configure --prefix=/your/chosen/path\n\nfollowed by \"make\" and \"sudo make install\" as before.\n\nA test directory is included so that you may familiarise yourself\nwith the way fdupes operates. You may test the program before\ninstalling it by issuing a command such as \"./fdupes testdir\" \nor \"./fdupes -r testdir\", just to name a couple of examples. Refer\nto the documentation for information on valid options.\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 1.162109375,
          "content": "bin_PROGRAMS = fdupes\n\nfdupes_SOURCES = fdupes.c\\\n fdupes.h\\\n errormsg.c\\\n errormsg.h\\\n dir.c\\\n dir.h\\\n log.c\\\n log.h\\\n fmatch.c\\\n fmatch.h\\\n sigint.c\\\n sigint.h\\\n flags.c\\\n flags.h\\\n confirmmatch.c\\\n confirmmatch.h\\\n removeifnotchanged.c\\\n removeifnotchanged.h\\\n mbstowcs_escape_invalid.c\\\n mbstowcs_escape_invalid.h\\\n md5/md5.c\\\n md5/md5.h\ndist_man1_MANS = fdupes.1\n\nif WITH_NCURSES\nfdupes_SOURCES += filegroup.h\\\n fileaction.h\\\n fileaction.c\\\n ncurses-commands.c\\\n ncurses-commands.h\\\n ncurses-getcommand.c\\\n ncurses-getcommand.h\\\n ncurses-interface.c\\\n ncurses-interface.h\\\n ncurses-print.c\\\n ncurses-print.h\\\n ncurses-prompt.c\\\n ncurses-prompt.h\\\n ncurses-status.c\\\n ncurses-status.h\\\n commandidentifier.c\\\n commandidentifier.h\\\n wcs.c\\\n wcs.h\\\n positive_wcwidth.c\\\n positive_wcwidth.h\ndist_man7_MANS = fdupes-help.7\nendif\n\nif WITH_SQLITE\nfdupes_SOURCES += getrealpath.c\\\n getrealpath.h\\\n sdirname.c\\\n sdirname.h\\\n sbasename.c\\\n sbasename.h\\\n xdgbase.c\\\n xdgbase.h\\\n hashdb.c\\\n hashdb.h\nendif\n\nEXTRA_DIST = testdir CHANGES CONTRIBUTORS\n\ndist-hook:\n\tif [ -f $(top_srcdir)/INSTALL.enduser ]; then chmod u+w $(distdir)/INSTALL; \\cp -f $(top_srcdir)/INSTALL.enduser $(distdir)/INSTALL; fi\n"
        },
        {
          "name": "README",
          "type": "blob",
          "size": 6.2900390625,
          "content": "Introduction\n--------------------------------------------------------------------\nFDUPES is a program for identifying duplicate files residing\nwithin specified directories. \n\n\nUsage\n--------------------------------------------------------------------\nUsage: fdupes [options] DIRECTORY...\n\n -r --recurse            for every directory given follow subdirectories\n                         encountered within\n -R --recurse:           for each directory given after this option follow\n                         subdirectories encountered within (note the ':' at the\n                         end of the option, manpage for more details)\n -s --symlinks           follow symlinks\n -H --hardlinks          normally, when two or more files point to the same\n                         disk area they are treated as non-duplicates; this\n                         option will change this behavior\n -G --minsize=SIZE       consider only files greater than or equal to SIZE bytes\n -L --maxsize=SIZE       consider only files less than or equal to SIZE bytes\n -c --cache              speed up file comparisons by keeping track of their\n                         signatures in a database; additional parameters may be\n                         provided using one or more cache parameters (as below)\n -x cache.OPTION         supply an optional cache parameter, where OPTION is one\n                         of the keywords below and multiple options may be\n                         supplied via successive -x arguments:\n    readonly             read but do not update file signatures\n    prune                look through entire cache and delete orphaned entries\n    clear                clear all entries from cache\n    vacuum               reduce size of DB file, if possible\n                         (note that the options prune, clear, and vacuum may be\n                         employed without supplying a DIRECTORY argument, and\n                         will take effect even if readonly is also specified)\n -n --noempty            exclude zero-length files from consideration\n -A --nohidden           exclude hidden files from consideration\n -f --omitfirst          omit the first file in each set of matches\n -1 --sameline           list each set of matches on a single line\n -S --size               show size of duplicate files\n -t --time               show modification time of duplicate files\n -m --summarize          summarize dupe information\n -q --quiet              hide progress indicator\n -d --delete             prompt user for files to preserve and delete all\n                         others; important: under particular circumstances,\n                         data may be lost when using this option together\n                         with -s or --symlinks, or when specifying a\n                         particular directory more than once; refer to the\n                         fdupes documentation for additional information\n -D --deferconfirmation  in interactive mode, defer byte-for-byte confirmation\n                         of duplicates until just before file deletion\n -P --plain              with --delete, use line-based prompt (as with older\n                         versions of fdupes) instead of screen-mode interface\n -N --noprompt           together with --delete, preserve the first file in\n                         each set of duplicates and delete the rest without\n                         prompting the user\n -I --immediate          delete duplicates as they are encountered, without\n                         grouping into sets; implies --noprompt\n -p --permissions        don't consider files with different owner/group or\n                         permission bits as duplicates\n -o --order=BY           select sort order for output and deleting; by file\n                         modification time (BY='time'; default), status\n                         change time (BY='ctime'), or filename (BY='name')\n -i --reverse            reverse order while sorting\n -l --log=LOGFILE        log file deletion choices to LOGFILE\n -v --version            display fdupes version\n -h --help               display this help message\n\nUnless -1 or --sameline is specified, duplicate files are listed\ntogether in groups, each file displayed on a separate line. The\ngroups are then separated from each other by blank lines.\n\nWhen -1 or --sameline is specified, spaces and backslash characters (\\)\nappearing in a filename are preceded by a backslash character. For\ninstance, \"with spaces\" becomes \"with\\ spaces\".\n\nWhen using -d or --delete, care should be taken to insure against\naccidental data loss. While no information will be immediately\nlost, using this option together with -s or --symlink can lead\nto confusing information being presented to the user when prompted\nfor files to preserve. Specifically, a user could accidentally\npreserve a symlink while deleting the file it points to. A similar\nproblem arises when specifying a particular directory more than\nonce. All files within that directory will be listed as their own\nduplicates, leading to data loss should a user preserve a file\nwithout its \"duplicate\" (the file itself!).\n\n\nContact Information for Adrian Lopez\n--------------------------------------------------------------------\nemail: adrianlopezroche@gmail.com\n\n\nLegal Information\n--------------------------------------------------------------------\nFDUPES Copyright (c) 1999-2019 Adrian Lopez\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation files\n(the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "commandidentifier.c",
          "type": "blob",
          "size": 5.66015625,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include <stdlib.h>\n#include \"commandidentifier.h\"\n\n/* insert new node into command identifier tree */\nint insert_command_identifier_command(struct command_identifier_node *tree, struct command_map *command, size_t ch)\n{\n  struct command_identifier_node *child;\n  struct command_identifier_node **alloc_children;\n  int returned_command;\n  int c;\n\n  /* find node for current character in command name */\n  child = 0;\n  for (c = 0; c < tree->num_children; ++c)\n  {\n    if (tree->children[c]->character == command->command_name[ch])\n    {\n      child = tree->children[c];\n      break;\n    }\n  }\n\n  /* if sought node does not exist, create it */\n  if (child == 0)\n  {\n    child = (struct command_identifier_node*) malloc(sizeof(struct command_identifier_node));\n    if (child == 0)\n      return COMMAND_RECOGNIZER_OUT_OF_MEMORY;\n\n    child->command = COMMAND_UNDEFINED;\n    child->character = command->command_name[ch];\n    child->children = 0;\n    child->num_children = 0;\n\n    alloc_children = realloc(tree->children, sizeof(struct command_identifier_node*) * (tree->num_children + 1));\n    if (alloc_children == 0)\n      return COMMAND_RECOGNIZER_OUT_OF_MEMORY;\n\n    tree->children = alloc_children;\n\n    tree->children[tree->num_children++] = child;\n  }\n\n  /* if last character in command name, make child a leaf node */\n  if (command->command_name[ch] == L'\\0')\n  {\n    child->command = command->command;\n    return child->command;\n  }\n  else /* grow the tree */\n  {\n    returned_command = insert_command_identifier_command(child, command, ch + 1);\n\n    /* record whether the tree at this point leads to a single command (abbreviation) or many (ambiguous) */\n    if (tree->command == COMMAND_UNDEFINED)\n      tree->command = returned_command;\n    else\n      tree->command = COMMAND_AMBIGUOUS;\n  }\n\n  return tree->command;\n}\n\n/* compare two command identifier nodes by the characters they match */\nint compare_command_identifier_nodes(const void *a, const void *b)\n{\n  const struct command_identifier_node *aa;\n  const struct command_identifier_node *bb;\n\n  aa = *(struct command_identifier_node**)a;\n  bb = *(struct command_identifier_node**)b;\n\n  if (aa->character > bb->character)\n    return 1;\n  else if (aa->character < bb->character)\n    return -1;\n  else\n    return 0;\n}\n\n/* sort command identifier nodes in alphabetical order */\nvoid sort_command_identifier_nodes(struct command_identifier_node *root)\n{\n  int c;\n\n  if (root->num_children > 1)\n    qsort(root->children, root->num_children, sizeof(struct command_identifier_node *), compare_command_identifier_nodes);\n\n  for (c = 0; c < root->num_children; ++c)\n    sort_command_identifier_nodes(root->children[c]);\n}\n\n/* build tree to identify command names through state transitions */\nstruct command_identifier_node *build_command_identifier_tree(struct command_map *commands)\n{\n  struct command_identifier_node *root;\n  int c;\n\n  root = (struct command_identifier_node*) malloc(sizeof(struct command_identifier_node));\n  if (root == 0)\n    return 0;\n\n  root->command = COMMAND_UNDEFINED;\n  root->character = L'\\0';\n  root->children = 0;\n  root->num_children = 0;\n\n  c = 0;\n  while (commands[c].command_name != 0)\n  {\n    insert_command_identifier_command(root, commands + c, 0);\n    ++c;\n  }\n\n  sort_command_identifier_nodes(root);\n\n  return root;\n}\n\n/* free memory used by command identifier tree structure */\nvoid free_command_identifier_tree(struct command_identifier_node *tree)\n{\n  int c;\n\n  for (c = 0; c < tree->num_children; ++c)\n    free_command_identifier_tree(tree->children[c]);\n\n  free(tree->children);\n  free(tree);\n}\n\n/* find command identifier node matching given character */\nstruct command_identifier_node *find_command_identifier_node(struct command_identifier_node *root, wchar_t character)\n{\n  long min;\n  long max;\n  long mid;\n\n  if (root->num_children == 0)\n    return 0;\n\n  min = 0;\n  max = root->num_children - 1;\n\n  do\n  {\n    mid = (min + max) / 2;\n\n    if (character > root->children[mid]->character)\n      min = mid + 1;\n    else if (character < root->children[mid]->character)\n      max = mid - 1;\n    else\n      return root->children[mid];\n  } while (min <= max);\n\n  return 0;\n}\n\n/* determine ID for given command string (possibly abbreviated), if found */\nint identify_command(struct command_identifier_node *tree, wchar_t *command_buffer, size_t ch)\n{\n  struct command_identifier_node *found;\n\n  if (command_buffer[ch] != L' ')\n    found = find_command_identifier_node(tree, command_buffer[ch]);\n  else\n    found = find_command_identifier_node(tree, L'\\0');\n\n  if (found)\n  {\n    if (command_buffer[ch] == L'\\0' || command_buffer[ch] == L' ')\n      return found->command;\n    else\n      return identify_command(found, command_buffer, ch + 1);\n  }\n  else\n  {\n    if (command_buffer[ch] == L'\\0' || command_buffer[ch] == L' ')\n      return tree->command;\n    else\n      return COMMAND_UNDEFINED;\n  }\n}\n"
        },
        {
          "name": "commandidentifier.h",
          "type": "blob",
          "size": 1.6044921875,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef COMMANDIDENTIFIER_H\n#define COMMANDIDENTIFIER_H\n\n#include <wchar.h>\n\n#define COMMAND_RECOGNIZER_OUT_OF_MEMORY -2\n#define COMMAND_AMBIGUOUS -1\n#define COMMAND_UNDEFINED 0\n\n/* command name to command ID map structure */\nstruct command_map {\n  wchar_t *command_name;\n  int command;\n};\n\n/* command identifier node structure */\nstruct command_identifier_node\n{\n  int command;\n  wchar_t character;\n  struct command_identifier_node **children;\n  size_t num_children;\n};\n\nint identify_command(struct command_identifier_node *tree, wchar_t *command_buffer, size_t ch);\nstruct command_identifier_node *build_command_identifier_tree(struct command_map *commands);\nvoid free_command_identifier_tree(struct command_identifier_node *tree);\n\n#endif"
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 3.02734375,
          "content": "AC_INIT([fdupes], [2.3.2])\n\nAM_INIT_AUTOMAKE([foreign subdir-objects])\n\nAC_CONFIG_HEADERS([config.h])\n\nAC_ARG_PROGRAM\n\nPKG_PROG_PKG_CONFIG\n\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n\t#define _XOPEN_SOURCE 700\n\t#include <sys/types.h>\n\t#include <sys/stat.h>\n\t#include <unistd.h>\n]], [[\n\tstruct stat st;\n\tst.st_ctim.tv_nsec = 0;\n\tst.st_mtim.tv_nsec = 0;\n]])],\n\t[AC_DEFINE([HAVE_NSEC_TIMES], [1], [stat supports nanosecond precision])]\n\t[AC_DEFINE([_XOPEN_SOURCE], [700], [enable certain X/Open and POSIX features])]\n)\n\n#\n# NCURSES library\n#\nAC_ARG_WITH([ncurses], AS_HELP_STRING([--without-ncurses], [Do not use ncurses interface]))\n\nAC_CHECK_HEADERS([getopt.h ncursesw/curses.h])\nAS_IF([test x\"$with_ncurses\" != x\"no\"],\n\t[PKG_CHECK_MODULES([NCURSES], [ncursesw],\n\t\t[LIBS=\"$LIBS $NCURSES_LIBS\"],\n\t\t[AC_SEARCH_LIBS([wget_wch], [ncursesw ncurses curses], [], [AC_ERROR([ncurses library not found (or lacks wide character support)])])]\n\t\t[AC_SEARCH_LIBS([keypad], [ncursesw tinfow ncurses tinfo curses], [], [AC_ERROR([ncurses library not found (lacks keypad support)])])]\n\t)]\n\t[AC_DEFINE([_XOPEN_SOURCE], [700], [enable certain X/Open and POSIX features])]\n\t[AC_DEFINE([_XOPEN_SOURCE_EXTENDED], [], [enable certain functions in curses.h])]\n\t[AC_DEFINE([_ISOC99_SOURCE], [], [enable strtoll])]\n\t[AC_SEARCH_LIBS([pcre2_match_32], [pcre2-32], [], [AC_ERROR([pcre2 library not found])])]\n\t[AC_DEFINE([PCRE2_CODE_UNIT_WIDTH], [32], [PCRE2 Code Unit Width])],\n\n\t[AC_DEFINE([NO_NCURSES], [], [Do not compile against ncurses])]\n\t)\n\nAM_CONDITIONAL([WITH_NCURSES], [test x\"$with_ncurses\" != x\"no\"])\n\n#\n# SQLITE library\n#\nAC_ARG_WITH([sqlite], AS_HELP_STRING([--without-sqlite], [Do not use sqlite database]))\n\nAS_IF([test x\"$with_sqlite\" != x\"no\"],\n\t[AC_SEARCH_LIBS([sqlite3_prepare_v2], [sqlite3], [], [AC_ERROR([sqlite3 library not found])])],\n\n\t[AC_DEFINE([NO_SQLITE], [], [Do not compile against sqlite])]\n\t)\n\nAM_CONDITIONAL([WITH_SQLITE], [test x\"$with_sqlite\" != x\"no\"])\n\nunescaped_program_transform_name=`echo \"${program_transform_name}\"|sed -e \"s&\\\\\\\\$\\\\\\\\$&\\\\\\\\$&g\"`\ntransformed_program_name=`echo \"${PACKAGE_NAME}\"|sed -e \"${unescaped_program_transform_name}\"|sed -e \"s&\\\\\\\\\\\\\\\\&\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&g\"`\ntransformed_manpage_name=`echo \"${PACKAGE_NAME}-help\"|sed -e \"${unescaped_program_transform_name}\"`\n\nAC_DEFINE_UNQUOTED([HELP_COMMAND_STRING], \"man 7 ${transformed_manpage_name}\", [fdupes help file])\n\nAC_DEFINE([_FILE_OFFSET_BITS], [64], [allow fdupes to handle files greater than (2<<31)-1 bytes])\n\nAC_DEFINE([CHUNK_SIZE], [8192], [number of bytes to read per read call])\nAC_DEFINE([PARTIAL_MD5_SIZE], [4096], [maximum number of bytes to use when calculating partial hashes])\nAC_DEFINE([INPUT_SIZE], [256], [size of command buffer (plain interactive mode only)])\n\nAC_DEFINE([FDUPES_CACHE_DIRECTORY], [\"fdupes\"], [default subdirectory for fdupes config files])\nAC_DEFINE([FDUPES_CACHE_DIRECTORY_PERMISSIONS], [0700], [directory permissions for fdupes config directory])\nAC_DEFINE([FDUPES_HASH_DATABASE_NAME], [\"hash.db\"], [filename for fdupes hash database])\n\nAC_CONFIG_FILES([Makefile])\nAC_PROG_CC\nAC_OUTPUT\n"
        },
        {
          "name": "confirmmatch.c",
          "type": "blob",
          "size": 1.89453125,
          "content": "/* FDUPES Copyright (c) 1999-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include \"sigint.h\"\n#include \"confirmmatch.h\"\n#include <stdlib.h>\n#include <memory.h>\n\n/* Do a bit-for-bit comparison in case two different files produce the\n   same signature. Unlikely, but better safe than sorry. */\n\nint confirmmatch(FILE *file1, FILE *file2)\n{\n  unsigned char c1[CHUNK_SIZE];\n  unsigned char c2[CHUNK_SIZE];\n  size_t r1;\n  size_t r2;\n\n  fseek(file1, 0, SEEK_SET);\n  fseek(file2, 0, SEEK_SET);\n\n  do {\n    if (got_sigint) {\n      fclose(file1);\n      fclose(file2);\n      exit(0);\n    }\n\n    r1 = fread(c1, sizeof(unsigned char), sizeof(c1), file1);\n    r2 = fread(c2, sizeof(unsigned char), sizeof(c2), file2);\n\n    if (r1 != r2) return 0; /* file lengths are different */\n    if (memcmp (c1, c2, r1)) return 0; /* file contents are different */\n  } while (r2);\n\n  return 1;\n}\n"
        },
        {
          "name": "confirmmatch.h",
          "type": "blob",
          "size": 1.2119140625,
          "content": "/* FDUPES Copyright (c) 1999-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef CONFIRMMATCH_H\n#define CONFIRMMATCH_H\n\n#include <stdio.h>\n\nint confirmmatch(FILE *file1, FILE *file2);\n\n#endif"
        },
        {
          "name": "dir.c",
          "type": "blob",
          "size": 1.4208984375,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include <errno.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"dir.h\"\n\nchar *getworkingdirectory()\n{\n  size_t size;\n  char *result;\n  char *new_result;\n  char *cwd;\n  \n  size = 1024;\n\n  result = 0;\n  do\n  {\n    new_result = (char*) realloc(result, size);\n    if (new_result == 0)\n    {\n      if (result != 0)\n        free(result);\n\n      return 0;\n    }\n\n    result = new_result;\n\n    cwd = getcwd(result, size);\n\n    size *= 2;\n  } while (cwd == 0 && errno == ERANGE);\n\n  if (cwd == 0)\n  {\n    free(result);\n    return 0;\n  }\n\n  return result;\n}\n"
        },
        {
          "name": "dir.h",
          "type": "blob",
          "size": 0.9443359375,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef DIR_H\n#define DIR_H\n\nchar *getworkingdirectory();\n\n#endif"
        },
        {
          "name": "errormsg.c",
          "type": "blob",
          "size": 1.1494140625,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include \"errormsg.h\"\n\nextern char *program_name;\n\nvoid errormsg(char *message, ...)\n{\n  va_list ap;\n\n  va_start(ap, message);\n\n  fprintf(stderr, \"\\r%40s\\r%s: \", \"\", program_name);\n  vfprintf(stderr, message, ap);\n}\n"
        },
        {
          "name": "errormsg.h",
          "type": "blob",
          "size": 0.9599609375,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef ERRORMSG_H\n#define ERRORMSG_H\n\nvoid errormsg(char *message, ...);\n\n#endif"
        },
        {
          "name": "fdupes-help.7",
          "type": "blob",
          "size": 8.2724609375,
          "content": ".TH FDUPES-HELP 7\n\n.SH NAME\nfdupes-help \\- fdupes interactive mode reference\n\n.SH \"INTRODUCTION\"\n.PP\nWhen run interactively\n.RB ( \"\" \"as \" \"fdupes --delete\" ),\nfdupes\nwill show a list of duplicates and prompt the user for further action.\n.PP\nThe user can tell fdupes which files to keep or delete by tagging them accordingly. Once tagged, the user can instruct fdupes to delete any files that have been tagged for deletion. This can be done incrementally, if desired, successively tagging and deleting a limited number of files at a time until no more duplicates remain to be processed.\n\nThere are several ways to tag files in fdupes: individually using the\n.IR cursor ,\nby providing a list of files to keep, or by selecting files that match particular search criteria and tagging those as desired. Each of these approaches is discussed in detail in the sections below.\n\n.SH \"SCROLLING THE LIST\"\n.PP\nThe list of duplicates can be scrolled as follows:\n.B \n.IP \"PAGE DOWN\"\nScroll down to the next page.\n\n.B \n.IP \"PAGE UP\"\nScroll up to preceding page.\n\n.B \n.IP \"SHIFT + DOWN\"\nScroll down by one line. Not supported on some terminals.\n\n.B\n.IP \"SHIFT + UP\"\nScroll up by one line. Not supported on some terminals.\n\n.SH \"MOVING THE CURSOR\"\n.PP\nThe cursor tells fdupes which file and/or set of duplicates to act on, as described in the next section. The cursor's position can be changed as follows:\n\n.B \n.IP \"DOWN\"\nAdvance cursor to the next file on the list.\n\n.B \n.IP \"UP\"\nMove cursor back to the previous file.\n\n.B \n.IP \"TAB\"\nAdvance cursor to the next set of duplicates.\n\n.B \n.IP \"BACKSPACE\"\nMove cursor back to the previous set.\n\n.B\n.IP \"F3\"\nAdvance cursor to the next\n.I selected\nset, if any.\n\n.B\n.IP \"F2\"\nMove cursor back to the previous\n.I selected\nset, if any.\n\n.PP\nIt is also possible to jump directly to a particular set:\n\n.B\n.IP \"'goto <index>'\"\nMove cursor to the top of the set indicated by\n.IR index .\n\n.SH \"TAGGING FILES USING THE CURSOR\"\n.PP\nIndividual files can be tagged using the keys below. These keys all act on the current file, as identified by the cursor.\n\n.B \n.IP \"SHIFT + RIGHT\"\nTag current file for keeping.\n\n.B \n.IP \"SHIFT + LEFT\"\nTag current file for deletion.\n\n.B\n.IP \"'?'\"\nRemove tag from current file.\n\n.PP\nEntire sets of files can be tagged by providing a list of indices in a comma-separated list. Files in the current set whose indices appear on the list will be tagged for keeping, while any other files in that set will be tagged for deletion. As with individual files, the current set is identified by the cursor.\n\n.PP\nAs an example, given the following list of duplicates:\n.PP\n.RS\n.B\nSet 1 of 5:\n\n  1 [ ] path/to/file_a\n  2 [ ] path/to/file_b\n  3 [ ] path/to/file_c\n.RE\n\n.PP\nTyping\n.B\n\\|'1, 3\\|'\nat the prompt and pressing ENTER will tell fdupes to tag\n.I\nfile_a\nand\n.I\nfile_c\nfor keeping, and\n.I\nfile_b\nfor deletion. The special command\n.B\n\\|'all\\|'\nwill tag all files for keeping.\n\n.PP\nThere is one more command to deal with files in the current set:\n.B\n.IP \"'rg'\"\nRemove tags from all files in current set.\n\n.SH \"FILE SELECTION COMMANDS\"\n.PP\nAnother way to tag files is to first select them according to particular search criteria and then tell fdupes what to do with them. The following commands can be used to select files for tagging:\n\n.B\n.IP \"'sel <text>'\"\nSelect any files whose paths contain the given text.\n\n.B\n.IP \"'selb <text>'\"\nSelect any files whose paths begin with the given text.\n\n.B\n.IP \"'sele <text>'\"\nSelect any files whose paths end with the given text.\n\n.B\n.IP \"'selm <text>'\"\nSelect any file whose path matches the given text exactly.\n\n.B\n.IP \"'selr <expression>'\"\nSelect any files whose paths match the given\n.I\nregular expression\n(see below).\n\n.B\n.IP \"'dsel <text>'\"\nDeselect any files whose paths contain the given text.\n\n.B\n.IP \"'dselb <text>'\"\nDeselect any files whose paths begin with the given text.\n\n.B\n.IP \"'dsele <text>'\"\nDeselect any files whose paths end with the given text.\n\n.B\n.IP \"'dselm <text>'\"\nDeselect any file whose path matches the given text exactly.\n\n.B\n.IP \"'dselr <expression>'\"\nDeselect any files whose paths match the given\n.I\nregular expression\n(see below).\n\n.B\n.IP \"'csel'\"\nClear all selections.\n\n.B\n.IP \"'isel'\"\nInvert selections within selected sets. For example, if files 1 and 4 in a set of 5 are selected,\n.B\nisel\nwill deselect files 1 and 4, and select files 2, 3, and 5. Immediately repeating the same command will deselect files 2, 3, and 5, and select files 1 and 4, restoring selections to their previous state.\n\n.SH \"TAGGING SELECTED FILES\"\n.PP\nOnce some files have been selected using the commands described above, the following commands can be used to tag selected files as desired:\n.B\n.IP \"'ks'\"\nTag selected files for keeping.\n\n.B\n.IP \"'ds'\"\nTag selected files for deletion.\n\n.B\n.IP \"'rs'\"\nRemove all tags from selected files.\n\n.SH \"DELETING DUPLICATES\"\nOnce tagged for deletion, files can be deleted by pressing\n.B\nDELETE\nor using the\n.B 'prune'\ncommand. Fdupes will delete any files that are tagged for deletion and delist any sets whose remaining files have been tagged for keeping. For safety, fdupes will refuse to act on sets for which all files have been tagged for deletion. To handle these cases, tag at least one file for keeping and run the delete command again.\n\n.SH \"OTHER COMMANDS\"\n.B\n.IP \"'exit', 'quit'\"\nExit the program.\n\n.B\n.IP \"'help'\"\nDisplay this help text.\n\n.SH \"REGULAR EXPRESSIONS\"\n.PP\nA regular expression is a sequence of characters defining a search pattern against which other character sequences can be compared. Strings of characters that follow the pattern defined by an expression are said to\n.I\nmatch\nthe expression, whereas strings that break the pattern do not.\n.PP\nThe syntax for regular expressions used by fdupes is known as the\n.B\nPerl Compatible Regular Expression\nsyntax. A detailed description of regular expression syntax is beyond the scope of this document. For detailed information the user is encouraged to consult the\n.I\nPCRE2\ndocumentation:\n.PP\n.RS\nhttps://www.pcre.org/current/doc/html/pcre2syntax.html\n.RE\n\n.PP\nBriefly, here are some examples of regular expressions:\n\n.B\n.IP \"abc123\"\nWill match any string containing the sequence\n.IR abc123 ,\nsuch as\n.IR abc123 ,\n.IR abc123x ,\n.IR xabc123 ,\nand\n.IR xabc123x .\n\n.B\n.IP \"^abc123\"\nWill match any string beginning with\n.IR abc123 ,\nsuch as \n.IR abc123 \" and \" abc123x ,\nbut not\n.IR xabc123 \" or \" xabc123x .\nThe character '^' has special meaning, telling the program to match only those strings that begin with the pattern that follows.\n\n.B\n.IP \"abc123$\"\nWill match any string that ends with\n.IR abc123 ,\nsuch as\n.IR abc123 \" and \" xabc123 ,\nbut not\n.IR abc123x \" or \" xabc123x .\nThe character '$' has special meaning, telling the program to match only those strings that end with the preceding pattern.\n\n.B\n.IP \"^abc123$\"\nWill match the string\n.I abc123\nand no other.\n\n.B\n.IP \"ab.123\"\nWill match any string containing\n.I abc123\nas in the first example, but it will also match strings containing\n.IR abz123 , \n.IR ab0123 , \n.IR ab_123 ,\netc. The character '.' has special meaning, acting as a placeholder that will match any character in that position.\n\n.B\n.IP \"^a.*3$\"\nWill match any string beginning with the letter a and ending with the number 3, such as\n.IR abc123 ,\n.IR a3 ,\nand\n.IR a0b1c2d3 .\nHere the character '*' tells the program to accept any number of appearances (including none) for the preceding item (here, any character matching the placeholder character '.'). The characters '^' and '$' have the same meaning as in previous examples.\n\n.B\n.IP \"abc\\ed+\"\nWill match any string containing the characters\n.B abc\nfollowed immediately by one or more decimal digits, such as\n.IR abc123 \" and \" abc3210 ,\nbut not\n.IR abcd123\nor\n.I \"abc 123\"\n(note the space). Here \\ed is a placeholder for any decimal digit, while the character '+' tells the program to match one or more appearances of the preceding character or placeholder (here, \\ed).\n\n.B\n.IP \"\\ew+\\ed+\"\nWill match any string containing one or more \"word\" characters followed immediately by one or more decimal digits, such as\n.IR abc123 \" and \" abcd3210 ,\nbut not\n.IR \"abc 123\"\n(note the space). Here \\ew is a placeholder for a \"word\" character, and \\ed and '+' have the same meaning as in the preceding example.\n\n.PP\nThis is just scratching the surface of what can be done with regular expressions. Consult the PCRE2 documentation for a complete reference.\n\n.SH \"SEE ALSO\"\nThe fdupes man page,\n.BR fdupes (1).\n"
        },
        {
          "name": "fdupes.1",
          "type": "blob",
          "size": 4.6806640625,
          "content": ".TH FDUPES 1\n.\\\" NAME should be all caps, SECTION should be 1-8, maybe w/ subsection\n.\\\" other parms are allowed: see man(7), man(1)\n.SH NAME\nfdupes \\- finds duplicate files in a given set of directories\n.SH SYNOPSIS\n.B fdupes\n[\n.I options\n]\n.I DIRECTORY\n\\|.\\|.\\|.\n\n.SH \"DESCRIPTION\"\nSearches the given path for duplicate files. Such files are found by\ncomparing file sizes and MD5 signatures, followed by a \nbyte-by-byte comparison.\n\n.SH OPTIONS\n.TP\n.B -r --recurse\nFor every directory given follow subdirectories encountered within.\n.TP\n.B -R --recurse:\nFor each directory given after this option follow subdirectories\nencountered within (note the ':' at the end of option; see the\nExamples section below for further explanation).\n.TP\n.B -s --symlinks\nFollow symlinked directories.\n.TP\n.B -H --hardlinks\nNormally, when two or more files point to the same disk area they are\ntreated as non-duplicates; this option will change this behavior.\n.TP\n.B -G --minsize\\fR=\\fISIZE\\fR\nConsider only files greater than or equal to SIZE in bytes.\n.TP\n.B -L --maxsize\\fR=\\fISIZE\\fR\nConsider only files less than or equal to SIZE in bytes.\n.TP\n.B -c --cache\nSpeed up file comparisons by keeping track of their signatures in a\ndatabase; additional parameters may be provided using one or more\ncache parameters (as indicated below). Please note that this option\nmay not be available on some systems.\n.TP\n.B -x cache.\\fIOPTION\\fR\nSupply an optional cache parameter, where OPTION is one of the keywords\nbelow and multiple options may be supplied via successive -x arguments:\n\n  \\fIreadonly\\fR\n    read but do not update file signatures\n\n  \\fIprune\\fR\n    look through entire cache and delete orphaned entries\n\n  \\fIclear\\fR\n    clear all entries from cache\n\n  \\fIvacuum\\fR\n    reduce size of DB file, if possible\n\nThe options prune, clear, and vacuum may be employed without\nsupplying a DIRECTORY argument, and will take effect even if readonly\nis also specified. The order of operations is always clear, prune,\nupdate signatures (unless readonly), and vacuum.\n.TP\n.B -n --noempty\nExclude zero-length files from consideration.\n.TP\n.B -A --nohidden\nExclude hidden files from consideration.\n.TP\n.B -f --omitfirst\nOmit the first file in each set of matches.\n.TP\n.B -1 --sameline\nList each set of matches on a single line.\n.TP\n.B -S --size\nShow size of duplicate files.\n.TP\n.B  -t --time\nShow modification time of duplicate files.\n.TP\n.B -m --summarize\nSummarize duplicate file information.\n.TP\n.B -q --quiet\nHide progress indicator.\n.TP\n.B -d --delete\nPrompt user for files to preserve, deleting all others (see\n.B CAVEATS\nbelow).\n.TP\n.B -D --deferconfirmation\nIn interactive mode, defer byte-for-byte confirmation of\nduplicates until just before file deletion.\n.TP\n.B -P --plain\nWith --delete, use a line-based prompt (as with older versions of\nfdupes) instead of the new screen-mode interface. On installations\nwhere the screen-mode interface is not supported, fdupes will\ndefault to a line-based prompt.\n.TP\n.B -N --noprompt\nWhen used together with \\-\\-delete, preserve the first file in each\nset of duplicates and delete the others without prompting the user.\n.TP\n.B -I --immediate\nDelete duplicates as they are encountered, without\ngrouping into sets; implies --noprompt.\n.TP\n.B -p --permissions\nDon't consider files with different owner/group or permission bits as duplicates.\n.TP\n.B -o --order\\fR=\\fIWORD\\fR\nOrder files according to WORD:\ntime - sort by modification time, ctime - sort by status change time, name - sort by\nfilename.\n.TP\n.B -i --reverse\nReverse order while sorting.\n.TP\n.B -l --log\\fR=\\fILOGFILE\\fR\nLog file deletion choices to LOGFILE.\n.TP\n.B -v --version\nDisplay fdupes version.\n.TP\n.B -h --help\nDisplay help.\n.SH NOTES\nUnless\n.B -1\nor\n.B --sameline\nis specified, duplicate files are listed\ntogether in groups, each file displayed on a separate line. The\ngroups are then separated from each other by blank lines.\n\nWhen\n.B -1\nor\n.B --sameline\nis specified, spaces and backslash characters  (\\fB\\e\\fP) appearing\nin a filename are preceded by a backslash character.\n\n.SH EXAMPLES\n.TP\n.B fdupes a --recurse: b\nWill follow subdirectories under b, but not those under a.\n.TP\n.B fdupes a --recurse b\nWill follow subdirectories under both a and b.\n\n.SH CAVEATS\nWhen using\n.B \\-d\nor\n.BR \\-\\-delete ,\ncare should be taken to insure against\naccidental data loss.\n\nWhen used together with options\n.B \\-s\nor\n.BR \\-\\-symlink ,\na user could accidentally\npreserve a symlink while deleting the file it points to.\n\nFurthermore, when specifying a particular directory more than\nonce, all files within that directory will be listed as their\nown duplicates, leading to data loss should a user preserve a\nfile without its \"duplicate\" (the file itself!).\n\n.SH AUTHOR\nAdrian Lopez <adrianlopezroche@gmail.com>\n\n"
        },
        {
          "name": "fdupes.c",
          "type": "blob",
          "size": 47.5341796875,
          "content": "/* FDUPES Copyright (c) 1999-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/stat.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <time.h>\n#ifdef HAVE_GETOPT_H\n#include <getopt.h>\n#endif\n#include <errno.h>\n#include <libgen.h>\n#include <locale.h>\n#ifndef NO_NCURSES\n#ifdef HAVE_NCURSESW_CURSES_H\n  #include <ncursesw/curses.h>\n#else\n  #include <curses.h>\n#endif\n#include \"ncurses-interface.h\"\n#endif\n#include \"fdupes.h\"\n#include \"confirmmatch.h\"\n#include \"errormsg.h\"\n#include \"log.h\"\n#include \"sigint.h\"\n#include \"flags.h\"\n#include \"removeifnotchanged.h\"\n#ifndef NO_SQLITE\n#define FDUPES_DATABASE_DIRECTORY FDUPES_CACHE_DIRECTORY \"/\" FDUPES_HASH_DATABASE_NAME\n  #include \"hashdb.h\"\n  #include \"getrealpath.h\"\n  #include \"xdgbase.h\"\n#endif\n\nchar *program_name;\n\nlong long minsize = -1;\nlong long maxsize = -1;\n\n#ifndef NO_SQLITE\nsqlite3 *db;\n#endif\n\nstruct log_info *loginfo;\n\ntypedef enum {\n  ORDER_MTIME = 0,\n  ORDER_CTIME,\n  ORDER_NAME\n} ordertype_t;\n\nordertype_t ordertype = ORDER_MTIME;\n\n#define MD5_DIGEST_LENGTH 16\n\ntypedef struct _filetree {\n  file_t *file; \n  struct _filetree *left;\n  struct _filetree *right;\n} filetree_t;\n\nvoid escapefilename(char *escape_list, char **filename_ptr)\n{\n  int x;\n  int tx;\n  char *tmp;\n  char *filename;\n\n  filename = *filename_ptr;\n\n  tmp = (char*) malloc(strlen(filename) * 2 + 1);\n  if (tmp == NULL) {\n    errormsg(\"out of memory!\\n\");\n    exit(1);\n  }\n\n  for (x = 0, tx = 0; x < strlen(filename); x++) {\n    if (strchr(escape_list, filename[x]) != NULL) tmp[tx++] = '\\\\';\n    tmp[tx++] = filename[x];\n  }\n\n  tmp[tx] = '\\0';\n\n  if (x != tx) {\n    *filename_ptr = realloc(*filename_ptr, strlen(tmp) + 1);\n    if (*filename_ptr == NULL) {\n      errormsg(\"out of memory!\\n\");\n      exit(1);\n    }\n    strcpy(*filename_ptr, tmp);\n  }\n}\n\ndev_t getdevice(char *filename) {\n  struct stat s;\n\n  if (stat(filename, &s) != 0) return 0;\n\n  return s.st_dev;\n}\n\nino_t getinode(char *filename) {\n  struct stat s;\n   \n  if (stat(filename, &s) != 0) return 0;\n\n  return s.st_ino;   \n}\n\nchar *fmttime(time_t t) {\n  static char buf[64];\n\n  strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M\", localtime(&t));\n\n  return buf;\n}\n\nchar **cloneargs(int argc, char **argv)\n{\n  int x;\n  char **args;\n\n  args = (char **) malloc(sizeof(char*) * argc);\n  if (args == NULL) {\n    errormsg(\"out of memory!\\n\");\n    exit(1);\n  }\n\n  for (x = 0; x < argc; x++) {\n    args[x] = (char*) malloc(strlen(argv[x]) + 1);\n    if (args[x] == NULL) {\n      free(args);\n      errormsg(\"out of memory!\\n\");\n      exit(1);\n    }\n\n    strcpy(args[x], argv[x]);\n  }\n\n  return args;\n}\n\nint findarg(char *arg, int start, int argc, char **argv)\n{\n  int x;\n  \n  for (x = start; x < argc; x++)\n    if (strcmp(argv[x], arg) == 0) \n      return x;\n\n  return x;\n}\n\n/* Find the first non-option argument after specified option. */\nint nonoptafter(char *option, int argc, char **oldargv,\n\t\t      char **newargv, int optind, int *foundoption)\n{\n  int x;\n  int targetind;\n  int testind;\n  int startat = 1;\n\n  targetind = findarg(option, 1, argc, oldargv);\n\n  *foundoption = targetind < argc;\n\n  for (x = optind; x < argc; x++) {\n    testind = findarg(newargv[x], startat, argc, oldargv);\n    if (testind > targetind) return x;\n    else startat = testind;\n  }\n\n  return x;\n}\n\nvoid getfilestats(file_t *file, struct stat *info, struct stat *linfo)\n{\n  file->size = info->st_size;;\n  file->inode = info->st_ino;\n  file->device = info->st_dev;\n  file->ctime = info->st_ctime;\n  file->mtime = info->st_mtime;\n#ifdef HAVE_NSEC_TIMES\n  file->ctime_nsec = info->st_ctim.tv_nsec;\n  file->mtime_nsec = info->st_mtim.tv_nsec;\n#else\n  file->ctime_nsec = 0;\n  file->mtime_nsec = 0;\n#endif\n}\n\n#ifndef NO_SQLITE\nint delist_hash_if_orphaned(const sqlite3_int64 directoryid, const char *filename, const char *directory)\n{\n  const char *path;\n  char *fullpath;\n\n  if (got_sigint)\n    return 0;\n\n  fullpath = malloc(strlen(directory) + strlen(filename) + 2);\n  if (fullpath == 0) {\n    errormsg(\"out of memory!\\n\");\n    exit(1);\n  }\n\n  strcpy(fullpath, directory);\n  strcat(fullpath, \"/\");\n  strcat(fullpath, filename);\n\n  if (access(fullpath, F_OK) != 0)\n    hashdb_deletehash(db, directoryid, filename);\n\n  free(fullpath);\n\n  return 1;\n}\n\nint delist_directory_if_missing(const sqlite3_int64 directoryid, const char *name, const char *full_path, const sqlite3_int64 parent)\n{\n  struct stat st;\n\n  if (got_sigint)\n    return 0;\n\n  if (lstat(full_path, &st) != 0 || !S_ISDIR(st.st_mode))\n    return hashdb_deletedirectory(db, directoryid);\n\n  return 1;\n}\n#endif\n\nint grokdir(char *dir, file_t **filelistp, struct stat *logfile_status)\n{\n  DIR *cd;\n  file_t *newfile;\n  struct dirent *dirinfo;\n  int lastchar;\n  int filecount = 0;\n  int filesadded;\n  struct stat info;\n  struct stat linfo;\n  static int progress = 0;\n  static char indicator[] = \"-\\\\|/\";\n  char *fullname, *name;\n  char *fullpath = 0;\n#ifndef NO_SQLITE\n  sqlite3_int64 pathid = 0;\n#endif\n\n  cd = opendir(dir);\n\n  if (!cd) {\n    errormsg(\"could not chdir to %s\\n\", dir);\n    return 0;\n  }\n\n#ifndef NO_SQLITE\n  if (db != 0) {\n    fullpath = getrealpath(dir, 0);\n\n    if (fullpath && !ISFLAG(flags, F_READONLYCACHE)) {\n      if (hashdb_getdirectoryid(db, fullpath, &pathid)) {\n        hashdb_foreachdirectory(db, &pathid, delist_directory_if_missing);\n        hashdb_foreachhash(db, &pathid, delist_hash_if_orphaned);\n      }\n    }\n  }\n#endif\n\n  while ((dirinfo = readdir(cd)) != NULL) {\n    if (got_sigint) {\n      closedir(cd);\n      printf(\"\\n\");\n      exit(0);\n    }\n\n    if (strcmp(dirinfo->d_name, \".\") && strcmp(dirinfo->d_name, \"..\")) {\n      if (!ISFLAG(flags, F_HIDEPROGRESS)) {\n\tfprintf(stderr, \"\\rBuilding file list %c \", indicator[progress]);\n\tprogress = (progress + 1) % 4;\n      }\n\n      newfile = (file_t*) malloc(sizeof(file_t));\n\n      if (!newfile) {\n\terrormsg(\"out of memory!\\n\");\n\tclosedir(cd);\n\texit(1);\n      } else newfile->next = *filelistp;\n\n      newfile->device = 0;\n      newfile->inode = 0;\n      newfile->crcsignature = NULL;\n      newfile->crcpartial = NULL;\n      newfile->duplicates = NULL;\n      newfile->hasdupes = 0;\n\n      newfile->d_name = (char*)malloc(strlen(dir)+strlen(dirinfo->d_name)+2);\n\n      if (!newfile->d_name) {\n\terrormsg(\"out of memory!\\n\");\n\tfree(newfile);\n\tclosedir(cd);\n\texit(1);\n      }\n\n      strcpy(newfile->d_name, dir);\n      lastchar = strlen(dir) - 1;\n      if (lastchar >= 0 && dir[lastchar] != '/')\n\tstrcat(newfile->d_name, \"/\");\n      strcat(newfile->d_name, dirinfo->d_name);\n      \n      if (ISFLAG(flags, F_EXCLUDEHIDDEN)) {\n\tfullname = strdup(newfile->d_name);\n\tif (fullname == 0)\n\t{\n\t  errormsg(\"out of memory!\\n\");\n\t  free(newfile);\n\t  closedir(cd);\n\t  exit(1);\n\t}\n\tname = basename(fullname);\n\tif (name[0] == '.' && strcmp(name, \".\") && strcmp(name, \"..\") ) {\n\t  free(newfile->d_name);\n\t  free(newfile);\n\t  free(fullname);\n\t  continue;\n\t}\n\tfree(fullname);\n      }\n\n      if (stat(newfile->d_name, &info) == -1) {\n        free(newfile->d_name);\n        free(newfile);\n        continue;\n      }\n      \n      if (!S_ISDIR(info.st_mode) && (((info.st_size == 0 && ISFLAG(flags, F_EXCLUDEEMPTY)) || info.st_size < minsize || (info.st_size > maxsize && maxsize != -1)))) {\n        free(newfile->d_name);\n        free(newfile);\n        continue;\n      }\n\n      /* ignore logfile */\n      if (logfile_status != 0 && info.st_dev == logfile_status->st_dev && info.st_ino == logfile_status->st_ino)\n      {\n        free(newfile->d_name);\n        free(newfile);\n        continue;\n      }\n\n      if (lstat(newfile->d_name, &linfo) == -1) {\n\tfree(newfile->d_name);\n\tfree(newfile);\n\tcontinue;\n      }\n\n      if (S_ISDIR(info.st_mode)) {\n        if (ISFLAG(flags, F_RECURSE) && (ISFLAG(flags, F_FOLLOWLINKS) || !S_ISLNK(linfo.st_mode)))\n        {\n          filesadded = grokdir(newfile->d_name, filelistp, logfile_status);\n          filecount += filesadded;\n\n#ifndef NO_SQLITE\n          if (db != 0 && pathid == 0 && !ISFLAG(flags, F_READONLYCACHE) && filesadded > 0)\n              hashdb_savedirectory(db, fullpath);\n#endif\n        }\n\tfree(newfile->d_name);\n\tfree(newfile);\n      } else {\n\tif (S_ISREG(linfo.st_mode) || (S_ISLNK(linfo.st_mode) && ISFLAG(flags, F_FOLLOWLINKS))) {\n\t  getfilestats(newfile, &info, &linfo);\n\t  *filelistp = newfile;\n\t  filecount++;\n\t} else {\n\t  free(newfile->d_name);\n\t  free(newfile);\n\t}\n      }\n    }\n  }\n\n  if (fullpath)\n    free(fullpath);\n\n  closedir(cd);\n\n  return filecount;\n}\n\nmd5_byte_t *getcrcsignatureuntil(char *filename, off_t fsize, off_t max_read)\n{\n  off_t toread;\n  md5_state_t state;\n  md5_byte_t *digest;\n  static md5_byte_t chunk[CHUNK_SIZE];\n  FILE *file;\n\n  digest = (md5_byte_t*) malloc(MD5_DIGEST_LENGTH * sizeof(md5_byte_t));\n  if (digest == NULL) {\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  md5_init(&state);\n\n  if (max_read != 0 && fsize > max_read)\n    fsize = max_read;\n\n  file = fopen(filename, \"rb\");\n  if (file == NULL) {\n    errormsg(\"error opening file %s\\n\", filename);\n    return NULL;\n  }\n\n  while (fsize > 0) {\n    if (got_sigint) {\n      fclose(file);\n      printf(\"\\n\");\n      exit(0);\n    }\n\n    toread = (fsize >= CHUNK_SIZE) ? CHUNK_SIZE : fsize;\n    if (fread(chunk, toread, 1, file) != 1) {\n      errormsg(\"error reading from file %s\\n\", filename);\n      fclose(file);\n      return NULL;\n    }\n    md5_append(&state, chunk, toread);\n    fsize -= toread;\n  }\n\n  md5_finish(&state, digest);\n\n  fclose(file);\n\n  return digest;\n}\n\nmd5_byte_t *getcrcsignature(char *filename, off_t fsize)\n{\n  return getcrcsignatureuntil(filename, fsize, 0);\n}\n\nmd5_byte_t *getcrcpartialsignature(char *filename, off_t fsize)\n{\n  return getcrcsignatureuntil(filename, fsize, PARTIAL_MD5_SIZE);\n}\n\nint md5cmp(const md5_byte_t *a, const md5_byte_t *b)\n{\n  int x;\n\n  for (x = 0; x < MD5_DIGEST_LENGTH; ++x)\n  {\n    if (a[x] < b[x])\n      return -1;\n    else if (a[x] > b[x])\n      return 1;\n  }\n\n  return 0;\n}\n\nvoid md5copy(md5_byte_t *to, const md5_byte_t *from)\n{\n  int x;\n\n  for (x = 0; x < MD5_DIGEST_LENGTH; ++x)\n    to[x] = from[x];\n}\n\nvoid purgetree(filetree_t *checktree)\n{\n  if (checktree->left != NULL) purgetree(checktree->left);\n    \n  if (checktree->right != NULL) purgetree(checktree->right);\n    \n  free(checktree);\n}\n\nint registerfile(filetree_t **branch, file_t *file)\n{\n  *branch = (filetree_t*) malloc(sizeof(filetree_t));\n  if (*branch == NULL) {\n    errormsg(\"out of memory!\\n\");\n    exit(1);\n  }\n  \n  (*branch)->file = file;\n  (*branch)->left = NULL;\n  (*branch)->right = NULL;\n\n  return 1;\n}\n\nint same_permissions(char* name1, char* name2)\n{\n    struct stat s1, s2;\n\n    if (stat(name1, &s1) != 0) return -1;\n    if (stat(name2, &s2) != 0) return -1;\n\n    return (s1.st_mode == s2.st_mode &&\n            s1.st_uid == s2.st_uid &&\n            s1.st_gid == s2.st_gid);\n}\n\nint is_hardlink(filetree_t *checktree, file_t *file)\n{\n  file_t *dupe;\n\n  if ((file->inode == checktree->file->inode) &&\n      (file->device == checktree->file->device))\n        return 1;\n\n  if (checktree->file->hasdupes)\n  {\n    dupe = checktree->file->duplicates;\n\n    do {\n      if ((file->inode == dupe->inode) &&\n          (file->device == dupe->device))\n            return 1;\n\n      dupe = dupe->duplicates;\n    } while (dupe != NULL);\n  }\n\n  return 0;\n}\n\n/* check whether two paths represent the same file (deleting one would delete the other) */\nint is_same_file(file_t *file_a, file_t *file_b)\n{\n  char *filename_a;\n  char *filename_b;\n  char *dirname_a;\n  char *dirname_b;\n  char *basename_a;\n  char *basename_b;\n  struct stat dirstat_a;\n  struct stat dirstat_b;\n\n  /* if files on different devices and/or different inodes, they are not the same file */\n  if (file_a->device != file_b->device || file_a->inode != file_b->inode)\n    return 0;\n\n  /* copy filenames (basename and dirname may modify these) */\n  filename_a = strdup(file_a->d_name);\n  if (filename_a == 0)\n    return -1;\n\n  filename_b = strdup(file_b->d_name);\n  if (filename_b == 0)\n    return -1;\n\n  /* get file basenames */\n  basename_a = basename(filename_a);\n  memmove(filename_a, basename_a, strlen(basename_a) + 1);\n\n  basename_b = basename(filename_b);\n  memmove(filename_b, basename_b, strlen(basename_b) + 1);\n\n  /* if files have different names, they are not the same file */\n  if (strcmp(filename_a, filename_b) != 0)\n  {\n    free(filename_b);\n    free(filename_a);\n    return 0;\n  }\n\n  /* restore paths */\n  strcpy(filename_a, file_a->d_name);\n  strcpy(filename_b, file_b->d_name);\n\n  /* get directory names */\n  dirname_a = dirname(filename_a);\n  if (stat(dirname_a, &dirstat_a) != 0)\n  {\n    free(filename_b);\n    free(filename_a);\n    return -1;\n  }\n\n  dirname_b = dirname(filename_b);\n  if (stat(dirname_b, &dirstat_b) != 0)\n  {\n    free(filename_b);\n    free(filename_a);\n    return -1;\n  }\n\n  free(filename_b);\n  free(filename_a);\n\n  /* if directories on which files reside are different, they are not the same file */\n  if (dirstat_a.st_dev != dirstat_b.st_dev || dirstat_a.st_ino != dirstat_b.st_ino)\n    return 0;\n\n  /* same device, inode, filename, and directory; therefore, same file */\n  return 1;\n}\n\n/* check whether given tree node already contains a copy of given file */\nint has_same_file(filetree_t *checktree, file_t *file)\n{\n  file_t *dupe;\n\n  if (is_same_file(checktree->file, file))\n    return 1;\n\n  if (checktree->file->hasdupes)\n  {\n    dupe = checktree->file->duplicates;\n\n    do {\n      if (is_same_file(dupe, file))\n        return 1;\n\n      dupe = dupe->duplicates;\n    } while (dupe != NULL);\n  }\n\n  return 0;\n}\n\nfile_t **checkmatch(filetree_t **root, filetree_t *checktree, file_t *file)\n{\n  int cmpresult;\n  char *fullpath;\n\n  if (ISFLAG(flags, F_CONSIDERHARDLINKS))\n  {\n    /* If node already contains file, we don't want to add it again.\n    */\n    if (has_same_file(checktree, file))\n      return NULL;\n  }\n  else\n  {\n    /* If device and inode fields are equal one of the files is a\n       hard link to the other or the files have been listed twice\n       unintentionally. We don't want to flag these files as\n       duplicates unless the user specifies otherwise.\n    */\n    if (is_hardlink(checktree, file))\n      return NULL;\n  }\n\n  if (file->size < checktree->file->size)\n    cmpresult = -1;\n  else\n    if (file->size > checktree->file->size) cmpresult = 1;\n  else\n    if (ISFLAG(flags, F_PERMISSIONS) &&\n        !same_permissions(file->d_name, checktree->file->d_name))\n        cmpresult = -1;\n  else {\n    if (checktree->file->crcpartial == NULL) {\n#ifndef NO_SQLITE\n      if (ISFLAG(flags, F_CACHESIGNATURES))\n        hashdb_loadhash(db, checktree->file, &checktree->file->crcpartial, &checktree->file->crcsignature);\n#endif\n\n      if (checktree->file->crcpartial == NULL)\n      {\n        checktree->file->crcpartial = getcrcpartialsignature(checktree->file->d_name, checktree->file->size);\n        if (checktree->file->crcpartial == NULL) {\n          errormsg (\"cannot read file %s\\n\", checktree->file->d_name);\n          return NULL;\n        }\n\n#ifndef NO_SQLITE\n        if (ISFLAG(flags, F_CACHESIGNATURES) && !ISFLAG(flags, F_READONLYCACHE))\n          hashdb_savehash(db, checktree->file, checktree->file->crcpartial, checktree->file->crcsignature);\n#endif\n      }\n    }\n\n    if (file->crcpartial == NULL) {\n#ifndef NO_SQLITE\n      if (ISFLAG(flags, F_CACHESIGNATURES))\n        hashdb_loadhash(db, file, &file->crcpartial, &file->crcsignature);\n#endif\n\n      if (file->crcpartial == NULL)\n      {\n        file->crcpartial = getcrcpartialsignature(file->d_name, file->size);\n        if (file->crcpartial == NULL) {\n          errormsg (\"cannot read file %s\\n\", file->d_name);\n          return NULL;\n        }\n\n#ifndef NO_SQLITE\n        if (ISFLAG(flags, F_CACHESIGNATURES) && !ISFLAG(flags, F_READONLYCACHE))\n          hashdb_savehash(db, file, file->crcpartial, file->crcsignature);\n#endif\n      }\n    }\n\n    cmpresult = md5cmp(file->crcpartial, checktree->file->crcpartial);\n\n    if (cmpresult == 0) {\n      if (checktree->file->crcsignature == NULL) {\n        checktree->file->crcsignature = getcrcsignature(checktree->file->d_name, checktree->file->size);\n        if (checktree->file->crcsignature == NULL)\n          return NULL;\n#ifndef NO_SQLITE\n        if (ISFLAG(flags, F_CACHESIGNATURES) && !ISFLAG(flags, F_READONLYCACHE))\n          hashdb_savehash(db, checktree->file, checktree->file->crcpartial, checktree->file->crcsignature);\n#endif\n      }\n\n      if (file->crcsignature == NULL) {\n        file->crcsignature = getcrcsignature(file->d_name, file->size);\n        if (file->crcsignature == NULL)\n          return NULL;\n#ifndef NO_SQLITE\n        if (ISFLAG(flags, F_CACHESIGNATURES) && !ISFLAG(flags, F_READONLYCACHE))\n          hashdb_savehash(db, file, file->crcpartial, file->crcsignature);\n#endif\n      }\n\n      cmpresult = md5cmp(file->crcsignature, checktree->file->crcsignature);\n    }\n  }\n\n  if (cmpresult < 0) {\n    if (checktree->left != NULL) {\n      return checkmatch(root, checktree->left, file);\n    } else {\n      registerfile(&(checktree->left), file);\n      return NULL;\n    }\n  } else if (cmpresult > 0) {\n    if (checktree->right != NULL) {\n      return checkmatch(root, checktree->right, file);\n    } else {\n      registerfile(&(checktree->right), file);\n      return NULL;\n    }\n  } else\n  {\n    return &checktree->file;\n  }\n}\n\nvoid summarizematches(file_t *files)\n{\n  int numsets = 0;\n  double numbytes = 0.0;\n  int numfiles = 0;\n  file_t *tmpfile;\n\n  while (files != NULL)\n  {\n    if (files->hasdupes)\n    {\n      numsets++;\n\n      tmpfile = files->duplicates;\n      while (tmpfile != NULL)\n      {\n\tnumfiles++;\n\tnumbytes += files->size;\n\ttmpfile = tmpfile->duplicates;\n      }\n    }\n\n    files = files->next;\n  }\n\n  if (numsets == 0)\n    printf(\"No duplicates found.\\n\\n\");\n  else\n  {\n    if (numbytes < 1024.0)\n      printf(\"%d duplicate files (in %d sets), occupying %.0f bytes.\\n\\n\", numfiles, numsets, numbytes);\n    else if (numbytes <= (1000.0 * 1000.0))\n      printf(\"%d duplicate files (in %d sets), occupying %.1f kilobytes\\n\\n\", numfiles, numsets, numbytes / 1000.0);\n    else\n      printf(\"%d duplicate files (in %d sets), occupying %.1f megabytes\\n\\n\", numfiles, numsets, numbytes / (1000.0 * 1000.0));\n \n  }\n}\n\nvoid printmatches(file_t *files)\n{\n  file_t *tmpfile;\n\n  while (files != NULL) {\n    if (files->hasdupes) {\n      if (!ISFLAG(flags, F_OMITFIRST)) {\n\tif (ISFLAG(flags, F_SHOWSIZE)) printf(\"%lld byte%seach:\\n\", (long long int)files->size,\n\t (files->size != 1) ? \"s \" : \" \");\n        if (ISFLAG(flags, F_SHOWTIME))\n          printf(\"%s \", fmttime(files->mtime));\n\tif (ISFLAG(flags, F_DSAMELINE)) escapefilename(\"\\\\ \", &files->d_name);\n\tprintf(\"%s%c\", files->d_name, ISFLAG(flags, F_DSAMELINE)?' ':'\\n');\n      }\n      tmpfile = files->duplicates;\n      while (tmpfile != NULL) {\n        if (ISFLAG(flags, F_SHOWTIME))\n          printf(\"%s \", fmttime(tmpfile->mtime));\n\tif (ISFLAG(flags, F_DSAMELINE)) escapefilename(\"\\\\ \", &tmpfile->d_name);\n\tprintf(\"%s%c\", tmpfile->d_name, ISFLAG(flags, F_DSAMELINE)?' ':'\\n');\n\ttmpfile = tmpfile->duplicates;\n      }\n      printf(\"\\n\");\n\n    }\n      \n    files = files->next;\n  }\n}\n\n/*\n#define REVISE_APPEND \"_tmp\"\nchar *revisefilename(char *path, int seq)\n{\n  int digits;\n  char *newpath;\n  char *scratch;\n  char *dot;\n\n  digits = numdigits(seq);\n  newpath = malloc(strlen(path) + strlen(REVISE_APPEND) + digits + 1);\n  if (!newpath) return newpath;\n\n  scratch = malloc(strlen(path) + 1);\n  if (!scratch) return newpath;\n\n  strcpy(scratch, path);\n  dot = strrchr(scratch, '.');\n  if (dot) \n  {\n    *dot = 0;\n    sprintf(newpath, \"%s%s%d.%s\", scratch, REVISE_APPEND, seq, dot + 1);\n  }\n\n  else\n  {\n    sprintf(newpath, \"%s%s%d\", path, REVISE_APPEND, seq);\n  }\n\n  free(scratch);\n\n  return newpath;\n} */\n\nint relink(char *oldfile, char *newfile)\n{\n  dev_t od;\n  dev_t nd;\n  ino_t oi;\n  ino_t ni;\n\n  od = getdevice(oldfile);\n  oi = getinode(oldfile);\n\n  if (link(oldfile, newfile) != 0)\n    return 0;\n\n  /* make sure we're working with the right file (the one we created) */\n  nd = getdevice(newfile);\n  ni = getinode(newfile);\n\n  if (nd != od || oi != ni)\n    return 0; /* file is not what we expected */\n\n  return 1;\n}\n\nvoid deletefiles(file_t *files, int prompt, FILE *tty, char *logfile)\n{\n  int counter;\n  int groups = 0;\n  int curgroup = 0;\n  file_t *tmpfile;\n  file_t *curfile;\n  file_t **dupelist;\n  int *preserve;\n  int firstpreserved;\n  char *preservestr;\n  char *token;\n  char *tstr;\n  int number;\n  int sum;\n  int max = 0;\n  int x;\n  int i;\n  struct log_info *loginfo;\n  int log_error;\n  FILE *file1;\n  FILE *file2;\n  int ismatch;\n  char *deletepath;\n  char *errorstring;\n\n  curfile = files;\n  \n  while (curfile) {\n    if (curfile->hasdupes) {\n      counter = 1;\n      groups++;\n\n      tmpfile = curfile->duplicates;\n      while (tmpfile) {\n\tcounter++;\n\ttmpfile = tmpfile->duplicates;\n      }\n      \n      if (counter > max) max = counter;\n    }\n    \n    curfile = curfile->next;\n  }\n\n  max++;\n\n  dupelist = (file_t**) malloc(sizeof(file_t*) * max);\n  preserve = (int*) malloc(sizeof(int) * max);\n  preservestr = (char*) malloc(INPUT_SIZE);\n\n  if (!dupelist || !preserve || !preservestr) {\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  loginfo = 0;\n  if (logfile != 0)\n    loginfo = log_open(logfile, &log_error);\n\n#ifndef NO_SQLITE\n  if (!prompt)\n    hashdb_begintransaction(db);\n#endif\n\n  while (files) {\n    if (files->hasdupes) {\n      curgroup++;\n      counter = 1;\n      dupelist[counter] = files;\n\n      if (prompt) \n      {\n        if (ISFLAG(flags, F_SHOWTIME))\n          printf(\"[%d] [%s] %s\\n\", counter, fmttime(files->mtime), files->d_name);\n        else\n          printf(\"[%d] %s\\n\", counter, files->d_name);\n      }\n\n      tmpfile = files->duplicates;\n\n      while (tmpfile) {\n\tdupelist[++counter] = tmpfile;\n        if (prompt)\n        {\n          if (ISFLAG(flags, F_SHOWTIME))\n            printf(\"[%d] [%s] %s\\n\", counter, fmttime(tmpfile->mtime), tmpfile->d_name);\n          else\n            printf(\"[%d] %s\\n\", counter, tmpfile->d_name);\n        }\n\ttmpfile = tmpfile->duplicates;\n      }\n\n      if (prompt) printf(\"\\n\");\n\n      if (!prompt) /* preserve only the first file */\n      {\n         preserve[1] = 1;\n\t for (x = 2; x <= counter; x++) preserve[x] = 0;\n      }\n\n      else /* prompt for files to preserve */\n\n      do {\n\tprintf(\"Set %d of %d, preserve files [1 - %d, all, quit]\",\n          curgroup, groups, counter);\n\tif (ISFLAG(flags, F_SHOWSIZE)) printf(\" (%lld byte%seach)\", (long long int)files->size,\n\t  (files->size != 1) ? \"s \" : \" \");\n\tprintf(\": \");\n\tfflush(stdout);\n\n\tif (!fgets(preservestr, INPUT_SIZE, tty))\n\t{\n\t  preservestr[0] = '\\n'; /* treat fgets() failure as if nothing was entered */\n\t  preservestr[1] = '\\0';\n\n\t  if (got_sigint)\n\t  {\n\t    free(dupelist);\n\t    free(preserve);\n\t    free(preservestr);\n\n\t    exit(0);\n\t  }\n\t}\n\n\ti = strlen(preservestr) - 1;\n\n\twhile (preservestr[i]!='\\n'){ /* tail of buffer must be a newline */\n\t  tstr = (char*)\n\t    realloc(preservestr, strlen(preservestr) + 1 + INPUT_SIZE);\n\t  if (!tstr) { /* couldn't allocate memory, treat as fatal */\n\t    errormsg(\"out of memory!\\n\");\n\t    exit(1);\n\t  }\n\n\t  preservestr = tstr;\n\t  if (!fgets(preservestr + i + 1, INPUT_SIZE, tty))\n\t  {\n\t    preservestr[0] = '\\n'; /* treat fgets() failure as if nothing was entered */\n\t    preservestr[1] = '\\0';\n\t    break;\n\t  }\n\t  i = strlen(preservestr)-1;\n\t}\n\n\tif (strcmp(preservestr, \"q\\n\") == 0 || strcmp(preservestr, \"quit\\n\") == 0)\n\t{\n\t  free(dupelist);\n\t  free(preserve);\n\t  free(preservestr);\n\n\t  printf(\"\\n\");\n\n\t  exit(0);\n\t}\n\n\tfor (x = 1; x <= counter; x++) preserve[x] = 0;\n\t\n\ttoken = strtok(preservestr, \" ,\\n\");\n\t\n\twhile (token != NULL) {\n\t  if (strcasecmp(token, \"all\") == 0 || strcasecmp(token, \"a\") == 0)\n\t    for (x = 0; x <= counter; x++) preserve[x] = 1;\n\t  \n\t  number = 0;\n\t  sscanf(token, \"%d\", &number);\n\t  if (number > 0 && number <= counter) preserve[number] = 1;\n\t  \n\t  token = strtok(NULL, \" ,\\n\");\n\t}\n      \n\tfor (sum = 0, x = 1; x <= counter; x++) sum += preserve[x];\n      } while (sum < 1); /* make sure we've preserved at least one file */\n\n      printf(\"\\n\");\n\n      if (loginfo)\n        log_begin_set(loginfo);\n\n#ifndef NO_SQLITE\n      if (prompt)\n        hashdb_begintransaction(db);\n#endif\n\n      for (x = 1; x <= counter; x++) { \n\tif (preserve[x])\n        {\n\t  printf(\"   [+] %s\\n\", dupelist[x]->d_name);\n\n          if (loginfo)\n            log_file_remaining(loginfo, dupelist[x]->d_name);\n        }\n\telse {\n    if (ISFLAG(flags, F_DEFERCONFIRMATION))\n    {\n      firstpreserved = 0;\n      for (i = 1; i <= counter; ++i)\n      {\n        if (preserve[i])\n        {\n          firstpreserved = i;\n          break;\n        }\n      }\n\n      file1 = fopen(dupelist[x]->d_name, \"rb\");\n      file2 = fopen(dupelist[firstpreserved]->d_name, \"rb\");\n\n      if (file1 && file2)\n        ismatch = confirmmatch(file1, file2);\n      else\n        ismatch = 0;\n\n      if (file2)\n        fclose(file2);\n\n      if (file1)\n        fclose(file1);\n    }\n    else\n    {\n      ismatch = 1;\n    }\n\n    if (ismatch) {\n      if (removeifnotchanged(dupelist[x], &errorstring) == 0) {\n        printf(\"   [-] %s\\n\", dupelist[x]->d_name);\n\n#ifndef NO_SQLITE\n        if (db)\n        {\n          deletepath = getrealpath(dupelist[x]->d_name, GETREALPATH_IGNORE_MISSING_BASENAME);\n          if (deletepath != 0)\n          {\n            if (!ISFLAG(flags, F_READONLYCACHE))\n              hashdb_deletehashforpath(db, deletepath);\n\n            free(deletepath);\n          }\n        }\n#endif\n\n        if (loginfo)\n          log_file_deleted(loginfo, dupelist[x]->d_name);\n      }\n      else {\n        printf(\"   [!] %s \", dupelist[x]->d_name);\n        printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n        if (loginfo)\n          log_file_remaining(loginfo, dupelist[x]->d_name);\n      }\n    }\n    else {\n      printf(\"   [!] %s\\n\", dupelist[x]->d_name);\n      printf(\" -- unable to confirm match; file not deleted!\\n\");\n\n      if (loginfo)\n        log_file_remaining(loginfo, dupelist[x]->d_name);\n    }\n\t}\n      }\n      printf(\"\\n\");\n\n      if (loginfo)\n        log_end_set(loginfo);\n\n#ifndef NO_SQLITE\n      if (prompt)\n        hashdb_committransaction(db);\n#endif\n    }\n    \n    files = files->next;\n  }\n\n#ifndef NO_SQLITE\n  if (!prompt)\n    hashdb_committransaction(db);\n#endif\n\n  if (loginfo) {\n    log_close(loginfo);\n    loginfo = 0;\n  }\n\n  free(dupelist);\n  free(preserve);\n  free(preservestr);\n}\n\nint sort_pairs_by_arrival(file_t *f1, file_t *f2)\n{\n  if (f2->duplicates != 0)\n    return !ISFLAG(flags, F_REVERSE) ? 1 : -1;\n\n  return !ISFLAG(flags, F_REVERSE) ? -1 : 1;\n}\n\nint sort_pairs_by_ctime(file_t *f1, file_t *f2)\n{\n  if (f1->ctime < f2->ctime)\n    return !ISFLAG(flags, F_REVERSE) ? -1 : 1;\n  else if (f1->ctime > f2->ctime)\n    return !ISFLAG(flags, F_REVERSE) ? 1 : -1;\n  else if (f1->ctime_nsec < f2->ctime_nsec)\n    return !ISFLAG(flags, F_REVERSE) ? -1 : 1;\n  else if (f1->ctime_nsec > f2->ctime_nsec)\n    return !ISFLAG(flags, F_REVERSE) ? 1 : -1;\n\n  return 0;\n}\n\nint sort_pairs_by_mtime(file_t *f1, file_t *f2)\n{\n  if (f1->mtime < f2->mtime)\n    return !ISFLAG(flags, F_REVERSE) ? -1 : 1;\n  else if (f1->mtime > f2->mtime)\n    return !ISFLAG(flags, F_REVERSE) ? 1 : -1;\n  else if (f1->mtime_nsec < f2->mtime_nsec)\n    return !ISFLAG(flags, F_REVERSE) ? -1 : 1;\n  else if (f1->mtime_nsec > f2->mtime_nsec)\n    return !ISFLAG(flags, F_REVERSE) ? 1 : -1;\n  else\n    return sort_pairs_by_ctime(f1, f2);\n}\n\nint sort_pairs_by_filename(file_t *f1, file_t *f2)\n{\n  int strvalue = strcmp(f1->d_name, f2->d_name);\n  return !ISFLAG(flags, F_REVERSE) ? strvalue : -strvalue;\n}\n\nvoid registerpair(file_t **matchlist, file_t *newmatch, \n\t\t  int (*comparef)(file_t *f1, file_t *f2))\n{\n  file_t *traverse;\n  file_t *back;\n\n  (*matchlist)->hasdupes = 1;\n\n  back = 0;\n  traverse = *matchlist;\n  while (traverse)\n  {\n    if (comparef(newmatch, traverse) <= 0)\n    {\n      newmatch->duplicates = traverse;\n      \n      if (back == 0)\n      {\n\t*matchlist = newmatch; /* update pointer to head of list */\n\n\tnewmatch->hasdupes = 1;\n\ttraverse->hasdupes = 0; /* flag is only for first file in dupe chain */\n      }\n      else\n\tback->duplicates = newmatch;\n\n      break;\n    }\n    else\n    {\n      if (traverse->duplicates == 0)\n      {\n\ttraverse->duplicates = newmatch;\n\t\n\tif (back == 0)\n\t  traverse->hasdupes = 1;\n\t\n\tbreak;\n      }\n    }\n    \n    back = traverse;\n    traverse = traverse->duplicates;\n  }\n}\n\nvoid deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  char *deletepath;\n  char *errorstring;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n\n    *existing = duplicate;\n  }\n\n  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n\n  if (loginfo)\n    log_begin_set(loginfo);\n\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (removeifnotchanged(to_delete, &errorstring) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n#ifndef NO_SQLITE\n      if (db)\n      {\n        deletepath = getrealpath(to_delete->d_name, GETREALPATH_IGNORE_MISSING_BASENAME);\n        if (deletepath != 0)\n        {\n          if (!ISFLAG(flags, F_READONLYCACHE))\n            hashdb_deletehashforpath(db, deletepath);\n\n          free(deletepath);\n        }\n      }\n#endif\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n\n    if (loginfo)\n      log_file_remaining(loginfo, to_delete->d_name);\n  }\n\n  if (loginfo)\n    log_end_set(loginfo);\n\n  printf(\"\\n\");\n}\n\nvoid help_text()\n{\n  printf(\"Usage: fdupes [options] DIRECTORY...\\n\\n\");\n\n  /*     0        1 0       2 0       3 0       4 0       5 0       6 0       7 0       8 0\n  -------\"---------|---------|---------|---------|---------|---------|---------|---------|\"\n  */\n  printf(\" -r --recurse            for every directory given follow subdirectories\\n\");\n  printf(\"                         encountered within\\n\");\n  printf(\" -R --recurse:           for each directory given after this option follow\\n\");\n  printf(\"                         subdirectories encountered within (note the ':' at the\\n\");\n  printf(\"                         end of the option, manpage for more details)\\n\");\n  printf(\" -s --symlinks           follow symlinks\\n\");\n  printf(\" -H --hardlinks          normally, when two or more files point to the same\\n\");\n  printf(\"                         disk area they are treated as non-duplicates; this\\n\");\n  printf(\"                         option will change this behavior\\n\");\n  printf(\" -G --minsize=SIZE       consider only files greater than or equal to SIZE bytes\\n\");\n  printf(\" -L --maxsize=SIZE       consider only files less than or equal to SIZE bytes\\n\");\n#ifndef NO_SQLITE\n  printf(\" -c --cache              speed up file comparisons by keeping track of their\\n\");\n  printf(\"                         signatures in a database; additional parameters may be\\n\");\n  printf(\"                         provided using one or more cache parameters (as below)\\n\");\n  printf(\" -x cache.OPTION         supply an optional cache parameter, where OPTION is one\\n\");\n  printf(\"                         of the keywords below and multiple options may be\\n\");\n  printf(\"                         supplied via successive -x arguments:\\n\");\n  printf(\"    readonly             read but do not update file signatures\\n\");\n  printf(\"    prune                look through entire cache and delete orphaned entries\\n\");\n  printf(\"    clear                clear all entries from cache\\n\");\n  printf(\"    vacuum               reduce size of DB file, if possible\\n\");\n  printf(\"                         (note that the options prune, clear, and vacuum may be\\n\");\n  printf(\"                         employed without supplying a DIRECTORY argument, and\\n\");\n  printf(\"                         will take effect even if readonly is also specified)\\n\");\n#endif\n  printf(\" -n --noempty            exclude zero-length files from consideration\\n\");\n  printf(\" -A --nohidden           exclude hidden files from consideration\\n\");\n  printf(\" -f --omitfirst          omit the first file in each set of matches\\n\");\n  printf(\" -1 --sameline           list each set of matches on a single line\\n\");\n  printf(\" -S --size               show size of duplicate files\\n\");\n  printf(\" -t --time               show modification time of duplicate files\\n\");\n  printf(\" -m --summarize          summarize dupe information\\n\");\n  printf(\" -q --quiet              hide progress indicator\\n\");\n  printf(\" -d --delete             prompt user for files to preserve and delete all\\n\");\n  printf(\"                         others; important: under particular circumstances,\\n\");\n  printf(\"                         data may be lost when using this option together\\n\");\n  printf(\"                         with -s or --symlinks, or when specifying a\\n\");\n  printf(\"                         particular directory more than once; refer to the\\n\");\n  printf(\"                         fdupes documentation for additional information\\n\");\n  printf(\" -D --deferconfirmation  in interactive mode, defer byte-for-byte confirmation\\n\");\n  printf(\"                         of duplicates until just before file deletion\\n\");\n#ifndef NO_NCURSES\n  printf(\" -P --plain              with --delete, use line-based prompt (as with older\\n\");\n  printf(\"                         versions of fdupes) instead of screen-mode interface\\n\");\n#endif\n  printf(\" -N --noprompt           together with --delete, preserve the first file in\\n\");\n  printf(\"                         each set of duplicates and delete the rest without\\n\");\n  printf(\"                         prompting the user\\n\");\n  printf(\" -I --immediate          delete duplicates as they are encountered, without\\n\");\n  printf(\"                         grouping into sets; implies --noprompt\\n\");\n  printf(\" -p --permissions        don't consider files with different owner/group or\\n\");\n  printf(\"                         permission bits as duplicates\\n\");\n  printf(\" -o --order=BY           select sort order for output and deleting; by file\\n\");\n  printf(\"                         modification time (BY='time'; default), status\\n\");\n  printf(\"                         change time (BY='ctime'), or filename (BY='name')\\n\");\n  printf(\" -i --reverse            reverse order while sorting\\n\");\n  printf(\" -l --log=LOGFILE        log file deletion choices to LOGFILE\\n\");\n  printf(\" -v --version            display fdupes version\\n\");\n  printf(\" -h --help               display this help message\\n\\n\");\n#ifndef HAVE_GETOPT_H\n  printf(\"Note: Long options are not supported in this fdupes build.\\n\\n\");\n#endif\n}\n\nvoid close_log_on_exit()\n{\n  if (loginfo) {\n    log_close(loginfo);\n    loginfo = 0;\n  }\n}\n\n#ifndef NO_SQLITE\nvoid close_db_on_exit()\n{\n  if (db != 0)\n  {\n    if (!sqlite3_get_autocommit(db))\n      hashdb_committransaction(db);\n\n    if (ISFLAG(flags, F_VACUUMCACHE) && !got_sigint)\n      hashdb_vacuum(db);\n\n    hashdb_close(db);\n\n    db = 0;\n  }\n}\n#endif\n\nint main(int argc, char **argv) {\n  int x;\n  int opt;\n  FILE *file1;\n  FILE *file2;\n  file_t *files = NULL;\n  file_t *curfile;\n  file_t **match = NULL;\n  filetree_t *checktree = NULL;\n  int filecount = 0;\n  int progress = 0;\n  char **oldargv;\n  int firstrecurse;\n  int foundoption;\n  char *logfile = 0;\n  int log_error;\n  struct stat logfile_status;\n  char *endptr;\n  char *cachehome;\n  char *cachepath;\n\n#ifdef HAVE_GETOPT_H\n  static struct option long_options[] = \n  {\n    { \"omitfirst\", 0, 0, 'f' },\n    { \"recurse\", 0, 0, 'r' },\n    { \"recurse:\", 0, 0, 'R' },\n    { \"quiet\", 0, 0, 'q' },\n    { \"sameline\", 0, 0, '1' },\n    { \"size\", 0, 0, 'S' },\n    { \"time\", 0, 0, 't' },\n    { \"symlinks\", 0, 0, 's' },\n    { \"hardlinks\", 0, 0, 'H' },\n    { \"minsize\", 1, 0, 'G' },\n    { \"maxsize\", 1, 0, 'L' },\n    { \"noempty\", 0, 0, 'n' },\n    { \"nohidden\", 0, 0, 'A' },\n    { \"delete\", 0, 0, 'd' },\n    { \"plain\", 0, 0, 'P' },\n    { \"version\", 0, 0, 'v' },\n    { \"help\", 0, 0, 'h' },\n    { \"noprompt\", 0, 0, 'N' },\n    { \"immediate\", 0, 0, 'I'},\n    { \"summarize\", 0, 0, 'm'},\n    { \"summary\", 0, 0, 'm' },\n    { \"permissions\", 0, 0, 'p' },\n    { \"order\", 1, 0, 'o' },\n    { \"reverse\", 0, 0, 'i' },\n    { \"log\", 1, 0, 'l' },\n    { \"deferconfirmation\", 0, 0, 'D' },\n    { \"cache\", 0, 0, 'c' },\n    { 0, 0, 0, 0 }\n  };\n#define GETOPT getopt_long\n#else\n#define GETOPT getopt\n#endif\n\n  program_name = argv[0];\n\n  setlocale(LC_CTYPE, \"\");\n\n  oldargv = cloneargs(argc, argv);\n\n  while ((opt = GETOPT(argc, argv, \"frRq1StsHG:L:nAdPvhNImpo:il:Dcx:\"\n#ifdef HAVE_GETOPT_H\n          , long_options, NULL\n#endif\n          )) != EOF) {\n    switch (opt) {\n    case 'f':\n      SETFLAG(flags, F_OMITFIRST);\n      break;\n    case 'r':\n      SETFLAG(flags, F_RECURSE);\n      break;\n    case 'R':\n      SETFLAG(flags, F_RECURSEAFTER);\n      break;\n    case 'q':\n      SETFLAG(flags, F_HIDEPROGRESS);\n      break;\n    case '1':\n      SETFLAG(flags, F_DSAMELINE);\n      break;\n    case 'S':\n      SETFLAG(flags, F_SHOWSIZE);\n      break;\n    case 't':\n      SETFLAG(flags, F_SHOWTIME);\n      break;\n    case 's':\n      SETFLAG(flags, F_FOLLOWLINKS);\n      break;\n    case 'H':\n      SETFLAG(flags, F_CONSIDERHARDLINKS);\n      break;\n    case 'G':\n      minsize = strtoll(optarg, &endptr, 10);\n      if (optarg[0] == '\\0' || *endptr != '\\0' || minsize < 0)\n      {\n        errormsg(\"invalid value for --minsize: '%s'\\n\", optarg);\n        exit(1);\n      }\n      break;\n    case 'L':\n      maxsize = strtoll(optarg, &endptr, 10);\n      if (optarg[0] == '\\0' || *endptr != '\\0' || maxsize < 0)\n      {\n        errormsg(\"invalid value for --maxsize: '%s'\\n\", optarg);\n        exit(1);\n      }\n      break;\n    case 'n':\n      SETFLAG(flags, F_EXCLUDEEMPTY);\n      break;\n    case 'A':\n      SETFLAG(flags, F_EXCLUDEHIDDEN);\n      break;\n    case 'd':\n      SETFLAG(flags, F_DELETEFILES);\n      break;\n    case 'P':\n      SETFLAG(flags, F_PLAINPROMPT);\n      break;\n    case 'v':\n      printf(\"fdupes %s\\n\", VERSION);\n      exit(0);\n    case 'h':\n      help_text();\n      exit(1);\n    case 'N':\n      SETFLAG(flags, F_NOPROMPT);\n      break;\n    case 'I':\n      SETFLAG(flags, F_IMMEDIATE);\n      break;\n    case 'm':\n      SETFLAG(flags, F_SUMMARIZEMATCHES);\n      break;\n    case 'p':\n      SETFLAG(flags, F_PERMISSIONS);\n      break;\n    case 'o':\n      if (!strcasecmp(\"name\", optarg)) {\n        ordertype = ORDER_NAME;\n      } else if (!strcasecmp(\"time\", optarg)) {\n        ordertype = ORDER_MTIME;\n      } else if (!strcasecmp(\"ctime\", optarg)) {\n        ordertype = ORDER_CTIME;\n      } else {\n        errormsg(\"invalid value for --order: '%s'\\n\", optarg);\n        exit(1);\n      }\n      break;\n    case 'i':\n      SETFLAG(flags, F_REVERSE);\n      break;\n    case 'l':\n      logfile = optarg;\n      break;\n    case 'D':\n      SETFLAG(flags, F_DEFERCONFIRMATION);\n      break;\n    case 'c':\n      SETFLAG(flags, F_CACHESIGNATURES);\n      break;\n    case 'x':\n      if (strcmp(\"cache.readonly\", optarg) == 0)\n        SETFLAG(flags, F_READONLYCACHE);\n      else if (strcmp(\"cache.prune\", optarg) == 0)\n        SETFLAG(flags, F_PRUNECACHE);\n      else if (strcmp(\"cache.clear\", optarg) == 0)\n        SETFLAG(flags, F_CLEARCACHE);\n      else if (strcmp(\"cache.vacuum\", optarg) == 0)\n        SETFLAG(flags, F_VACUUMCACHE);\n      else {\n        errormsg(\"unrecognized option '-x %s'\\n\", optarg);\n        fprintf(stderr, \"Try `fdupes --help' for more information.\\n\");\n        exit(1);\n      }\n      break;\n    default:\n      fprintf(stderr, \"Try `fdupes --help' for more information.\\n\");\n      exit(1);\n    }\n  }\n\n  if (optind >= argc && !(ISFLAG(flags, F_CLEARCACHE) || ISFLAG(flags, F_PRUNECACHE) || ISFLAG(flags, F_VACUUMCACHE))) {\n    errormsg(\"no directories specified\\n\");\n    exit(1);\n  }\n\n#ifdef NO_SQLITE\n  if (\n      ISFLAG(flags, F_CACHESIGNATURES) ||\n      ISFLAG(flags, F_CLEARCACHE) ||\n      ISFLAG(flags, F_PRUNECACHE) ||\n      ISFLAG(flags, F_READONLYCACHE) ||\n      ISFLAG(flags, F_VACUUMCACHE)\n  ) {\n    errormsg(\"file signature database is not supported in this fdupes build\\n\");\n    exit(1);\n  }\n#else\n  if (!ISFLAG(flags, F_CACHESIGNATURES)) {\n    if (\n      ISFLAG(flags, F_CLEARCACHE) ||\n      ISFLAG(flags, F_PRUNECACHE) ||\n      ISFLAG(flags, F_READONLYCACHE) ||\n      ISFLAG(flags, F_VACUUMCACHE)\n    ) {\n      errormsg(\"-xcache parameters must be accompanied by --cache option\\n\");\n      exit(1);\n    }\n  }\n#endif\n\n  if (ISFLAG(flags, F_RECURSE) && ISFLAG(flags, F_RECURSEAFTER)) {\n    errormsg(\"options --recurse and --recurse: are not compatible\\n\");\n    exit(1);\n  }\n\n  if (ISFLAG(flags, F_SUMMARIZEMATCHES) && ISFLAG(flags, F_DELETEFILES)) {\n    errormsg(\"options --summarize and --delete are not compatible\\n\");\n    exit(1);\n  }\n\n  if (ISFLAG(flags, F_DEFERCONFIRMATION) && (!ISFLAG(flags, F_DELETEFILES) || ISFLAG(flags, F_NOPROMPT)))\n  {\n    errormsg(\"--deferconfirmation only works with interactive deletion modes\\n\");\n    exit(1);\n  }\n\n  if (!ISFLAG(flags, F_DELETEFILES)) {\n    logfile = 0;\n    loginfo = 0;\n  }\n\n  if (logfile != 0)\n  {\n    atexit(close_log_on_exit);\n\n    loginfo = log_open(logfile, &log_error);\n    if (loginfo == 0)\n    {\n      if (log_error == LOG_ERROR_NOT_A_LOG_FILE)\n        errormsg(\"%s: doesn't look like an fdupes log file\\n\", logfile);\n      else\n        errormsg(\"%s: could not open log file\\n\", logfile);\n\n      exit(1);\n    }\n\n    if (stat(logfile, &logfile_status) != 0)\n    {\n      errormsg(\"could not read log file status\\n\");\n      exit(1);\n    }\n  }\n\n#ifndef NO_SQLITE\n  if (ISFLAG(flags, F_CACHESIGNATURES)) {\n    cachehome = getcachehome(1);\n    if (cachehome == 0)\n    {\n      errormsg(\"could not open cache directory.\\n\");\n      exit(1);\n    }\n\n    cachepath = malloc(strlen(cachehome) + strlen(FDUPES_DATABASE_DIRECTORY) + 2);\n    if (cachepath == 0)\n    {\n      free(cachehome);\n      errormsg(\"could not open cache directory.\\n\");\n      exit(1);\n    }\n\n    strcpy(cachepath, cachehome);\n    strcat(cachepath, \"/\");\n    strcat(cachepath, FDUPES_CACHE_DIRECTORY);\n\n    mkdir(cachepath, FDUPES_CACHE_DIRECTORY_PERMISSIONS);\n\n    strcpy(cachepath, cachehome);\n    strcat(cachepath, \"/\");\n    strcat(cachepath, FDUPES_DATABASE_DIRECTORY);\n\n    db = hashdb_open(cachepath);\n    if (db == 0)\n    {\n      errormsg(\"could not open hash database at %s\\n\", cachepath);\n      free(cachehome);\n      free(cachepath);\n      exit(1);\n    }\n\n    atexit(close_db_on_exit);\n\n    free(cachehome);\n    free(cachepath);\n  }\n  else {\n    db = 0;\n  }\n\n  if (db != 0)\n  {\n    hashdb_begintransaction(db);\n\n    if (ISFLAG(flags, F_CLEARCACHE))\n      hashdb_cleardirectories(db);\n    else if (ISFLAG(flags, F_PRUNECACHE)) {\n      hashdb_foreachdirectory(db, 0, delist_directory_if_missing);\n      hashdb_foreachhash(db, 0, delist_hash_if_orphaned);\n    }\n  }\n#endif\n\n  register_sigint_handler();\n\n  if (ISFLAG(flags, F_RECURSEAFTER)) {\n    firstrecurse = nonoptafter(\"--recurse:\", argc, oldargv, argv, optind, &foundoption);\n\n    if (!foundoption)\n      firstrecurse = nonoptafter(\"-R\", argc, oldargv, argv, optind, &foundoption);\n\n    if (!foundoption) {\n      errormsg(\"-R option must be isolated from other options\\n\");\n      exit(1);\n    }\n    else if (firstrecurse == argc && optind != argc)\n    {\n      errormsg(\"-R option must be followed by at least one directory\\n\");\n      exit(1);\n    }\n\n    /* F_RECURSE is not set for directories before --recurse: */\n    for (x = optind; x < firstrecurse; x++)\n      filecount += grokdir(argv[x], &files, logfile ? &logfile_status : 0);\n\n    /* Set F_RECURSE for directories after --recurse: */\n    SETFLAG(flags, F_RECURSE);\n\n    for (x = firstrecurse; x < argc; x++)\n      filecount += grokdir(argv[x], &files, logfile ? &logfile_status : 0);\n  } else {\n    for (x = optind; x < argc; x++)\n      filecount += grokdir(argv[x], &files, logfile ? &logfile_status : 0);\n  }\n\n  if (!files) {\n    if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n    exit(0);\n  }\n\n  curfile = files;\n\n  while (curfile) {\n    if (got_sigint) {\n      printf(\"\\n\");\n      exit(0);\n    }\n\n    if (!checktree) \n      registerfile(&checktree, curfile);\n    else \n      match = checkmatch(&checktree, checktree, curfile);\n\n    if (match != NULL) {\n      file1 = fopen(curfile->d_name, \"rb\");\n      if (!file1) {\n\tcurfile = curfile->next;\n\tcontinue;\n      }\n      \n      file2 = fopen((*match)->d_name, \"rb\");\n      if (!file2) {\n\tfclose(file1);\n\tcurfile = curfile->next;\n\tcontinue;\n      }\n\n      if (ISFLAG(flags, F_DELETEFILES) && ISFLAG(flags, F_IMMEDIATE))\n      {\n          deletesuccessor(match, curfile, confirmmatch(file1, file2),\n              ordertype == ORDER_MTIME ? sort_pairs_by_mtime :\n              ordertype == ORDER_CTIME ? sort_pairs_by_ctime :\n                                         sort_pairs_by_filename, loginfo );\n      }\n      else if (ISFLAG(flags, F_DEFERCONFIRMATION) || confirmmatch(file1, file2))\n        registerpair(match, curfile,\n            ordertype == ORDER_MTIME ? sort_pairs_by_mtime :\n            ordertype == ORDER_CTIME ? sort_pairs_by_ctime :\n                                       sort_pairs_by_filename );\n\n      fclose(file1);\n      fclose(file2);\n    }\n\n    curfile = curfile->next;\n\n    if (!ISFLAG(flags, F_HIDEPROGRESS)) {\n      fprintf(stderr, \"\\rProgress [%d/%d] %d%% \", progress, filecount,\n       (int)((float) progress / (float) filecount * 100.0));\n      progress++;\n    }\n  }\n\n  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n\n  if (loginfo != 0)\n  {\n    log_close(loginfo);\n    loginfo = 0;\n  }\n\n#ifndef NO_SQLITE\n  if (db != 0)\n    hashdb_committransaction(db);\n#endif\n\n  if (ISFLAG(flags, F_DELETEFILES))\n  {\n    if (ISFLAG(flags, F_NOPROMPT) || ISFLAG(flags, F_IMMEDIATE))\n    {\n      deletefiles(files, 0, 0, logfile);\n    }\n    else\n    {\n#ifndef NO_NCURSES\n      if (!ISFLAG(flags, F_PLAINPROMPT))\n      {\n        if (newterm(getenv(\"TERM\"), stdout, stdin) != 0)\n        {\n          deletefiles_ncurses(files, logfile);\n        }\n        else\n        {\n          errormsg(\"could not enter screen mode; falling back to plain mode\\n\\n\");\n          SETFLAG(flags, F_PLAINPROMPT);\n        }\n      }\n\n      if (ISFLAG(flags, F_PLAINPROMPT))\n      {\n        if (freopen(\"/dev/tty\", \"r\", stdin) == NULL)\n        {\n          errormsg(\"could not open terminal for input\\n\");\n          exit(1);\n        }\n\n        deletefiles(files, 1, stdin, logfile);\n      }\n#else\n      if (freopen(\"/dev/tty\", \"r\", stdin) == NULL)\n      {\n        errormsg(\"could not open terminal for input\\n\");\n        exit(1);\n      }\n\n      deletefiles(files, 1, stdin, logfile);\n#endif\n    }\n  }\n\n  else \n\n    if (ISFLAG(flags, F_SUMMARIZEMATCHES))\n      summarizematches(files);\n      \n    else\n\n      printmatches(files);\n\n  while (files) {\n    curfile = files->next;\n    free(files->d_name);\n    free(files->crcsignature);\n    free(files->crcpartial);\n    free(files);\n    files = curfile;\n  }\n\n  for (x = 0; x < argc; x++)\n    free(oldargv[x]);\n\n  free(oldargv);\n\n  purgetree(checktree);\n\n  return 0;\n}\n"
        },
        {
          "name": "fdupes.h",
          "type": "blob",
          "size": 1.5341796875,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef FDUPES_H\n#define FDUPES_H\n\n#include \"config.h\"\n#include <sys/stat.h>\n#include \"md5/md5.h\"\n\ntypedef struct _file {\n  char *d_name;\n  off_t size;\n  md5_byte_t *crcpartial;\n  md5_byte_t *crcsignature;\n  dev_t device;\n  ino_t inode;\n  time_t mtime;\n  time_t ctime;\n  long mtime_nsec;\n  long ctime_nsec;\n  int hasdupes; /* true only if file is first on duplicate chain */\n  struct _file *duplicates;\n  struct _file *next;\n} file_t;\n\n#endif"
        },
        {
          "name": "fileaction.c",
          "type": "blob",
          "size": 1.44921875,
          "content": "/* FDUPES Copyright (c) 1999-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"fileaction.h\"\n\nchar getfileactionchar(int action)\n{\n    switch (action)\n    {\n        case FILEACTION_UNRESOLVED:\n            return ' ';\n        case FILEACTION_KEEP:\n            return '+';\n        case FILEACTION_DELETE:\n            return '-';\n        case FILEACTION_ERROR:\n            return '!';\n        default:\n            return '?';\n    }\n}"
        },
        {
          "name": "fileaction.h",
          "type": "blob",
          "size": 1.337890625,
          "content": "/* FDUPES Copyright (c) 1999-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef FILEACTION_H\n#define FILEACTION_H\n\n#define FILEACTION_UNRESOLVED 0\n#define FILEACTION_KEEP       1\n#define FILEACTION_DELETE    -1\n#define FILEACTION_DELIST    -2\n#define FILEACTION_ERROR     -3\n\nchar getfileactionchar(int action);\n\n#endif"
        },
        {
          "name": "filegroup.h",
          "type": "blob",
          "size": 1.3515625,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef FILEGROUP_H\n#define FILEGROUP_H\n\n#include \"fdupes.h\"\n\nstruct groupfile\n{\n  file_t *file;\n  int action;\n  int selected;\n};\n\nstruct filegroup\n{\n  struct groupfile *files;\n  size_t filecount;\n  int startline;\n  int endline;\n  int selected;\n};\n\n#endif"
        },
        {
          "name": "flags.c",
          "type": "blob",
          "size": 0.04296875,
          "content": "#include \"flags.h\"\n\nunsigned long flags = 0;"
        },
        {
          "name": "flags.h",
          "type": "blob",
          "size": 0.96484375,
          "content": "#ifndef FLAGS_H\n#define FLAGS_H\n\n#define ISFLAG(a,b) ((a & b) == b)\n#define SETFLAG(a,b) (a |= b)\n\n#define F_RECURSE           0x0001\n#define F_HIDEPROGRESS      0x0002\n#define F_DSAMELINE         0x0004\n#define F_FOLLOWLINKS       0x0008\n#define F_DELETEFILES       0x0010\n#define F_EXCLUDEEMPTY      0x0020\n#define F_CONSIDERHARDLINKS 0x0040\n#define F_SHOWSIZE          0x0080\n#define F_OMITFIRST         0x0100\n#define F_RECURSEAFTER      0x0200\n#define F_NOPROMPT          0x0400\n#define F_SUMMARIZEMATCHES  0x0800\n#define F_EXCLUDEHIDDEN     0x1000\n#define F_PERMISSIONS       0x2000\n#define F_REVERSE           0x4000\n#define F_IMMEDIATE         0x8000\n#define F_PLAINPROMPT       0x10000\n#define F_SHOWTIME          0x20000\n#define F_DEFERCONFIRMATION 0x40000\n#define F_CACHESIGNATURES   0x80000\n#define F_CLEARCACHE        0x100000\n#define F_PRUNECACHE        0x200000\n#define F_READONLYCACHE     0x400000\n#define F_VACUUMCACHE       0x800000\n\nextern unsigned long flags;\n\n#endif\n"
        },
        {
          "name": "fmatch.c",
          "type": "blob",
          "size": 1.341796875,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include <string.h>\n#include \"fmatch.h\"\n\n/* Test whether given string matches text at current file position.\n*/\nvoid fmatch(FILE *file, char *matchstring, int *is_match, size_t *chars_read)\n{\n  size_t len;\n  int x;\n  int c;\n\n  *is_match = 0;\n  *chars_read = 0;\n\n  len = strlen(matchstring);\n  for (x = 0; x < len; ++x)\n  {\n    c = fgetc(file);\n    if (c == EOF)\n      return;\n\n    (*chars_read)++;\n\n    if ((char)c != matchstring[x])\n      return;\n  }\n\n  *is_match = 1;\n}\n"
        },
        {
          "name": "fmatch.h",
          "type": "blob",
          "size": 1.01953125,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef FMATCH_H\n#define FMATCH_H\n\n#include <stdio.h>\n\nvoid fmatch(FILE *file, char *matchstring, int *is_match, size_t *chars_read);\n\n#endif\n"
        },
        {
          "name": "getrealpath.c",
          "type": "blob",
          "size": 10.8642578125,
          "content": "/* Copyright (c) 2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include \"config.h\"\n#include \"getrealpath.h\"\n#include \"dir.h\"\n#include \"sdirname.h\"\n#include \"sbasename.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#define ISFLAG(a,b) ((a & b) == b)\n\n#ifndef GETREALPATH_MAXSYMLINKS\n#define GETREALPATH_MAXSYMLINKS 40\n#endif\n\n#define DEFAULT_LINK_ALLOCATION_SIZE 16\n\n/* read link contents into buffer allocated via malloc() */\nchar *getlink(const char *path, struct stat *s)\n{\n    char *link;\n    char *buffer;\n    size_t allocated;\n    int linksize;\n\n    if (s->st_size > 0)\n        allocated = s->st_size + 1;\n    else\n        allocated = DEFAULT_LINK_ALLOCATION_SIZE;\n\n    buffer = malloc(allocated);\n    if (buffer == 0)\n        return 0;\n\n    do\n    {\n        link = buffer;\n\n        linksize = readlink(path, link, allocated);\n        if (linksize == -1)\n        {\n            free(link);\n            return 0;\n        }\n\n        if (linksize < allocated)\n        {\n            link[linksize] = '\\0';\n            return link;\n        }\n\n        if (stat(path, s) != 0)\n        {\n            free(link);\n            return 0;\n        }\n\n        if (s->st_size != 0)\n            allocated = s->st_size + 1;\n        else\n            allocated *= 2;\n    } while (buffer = realloc(link, allocated));\n\n    free(link);\n\n    return 0;\n}\n\n/* replace dest[from .. through] with contents of src */\nint replacestring(char *dest, size_t from, size_t through, size_t max, const char *src)\n{\n    size_t srclength;\n    size_t destlength;\n    size_t moveto;\n    size_t newlength;\n\n    destlength = strlen(dest);\n\n    if (through >= destlength || from > through)\n        return 0;\n\n    srclength = strlen(src);\n\n    newlength = destlength + srclength - (through - from + 1);\n    if (newlength > max)\n        return 0;\n\n    memmove(dest + from + srclength, dest + through + 1, destlength - through);\n\n    memcpy(dest + from, src, srclength);\n\n    return 1;\n}\n\n/* print the resolved absolute file name for the specified path */\nchar *getrealpath(const char *path, unsigned int options)\n{\n    char *scratch;\n    char *cwd;\n    char *link;\n    char *newmem;\n    char *dirname;\n    char *basename;\n    char save;\n    size_t tail;\n    size_t next;\n    size_t pathlength;\n    size_t linklength;\n    size_t cwdlength;\n    size_t allocated;\n    size_t links;\n    size_t x;\n    struct stat st;\n    struct stat st0;\n    int pathexists;\n\n    /* run stat on unmodified path, for later use */\n    pathexists = stat(path, &st0) == 0;\n    if (!pathexists && !ISFLAG(options, GETREALPATH_IGNORE_MISSING_BASENAME))\n        return 0;\n\n    /* optionally ignore the last component if it does not exist */\n    if (ISFLAG(options, GETREALPATH_IGNORE_MISSING_BASENAME) && !pathexists)\n    {\n        dirname = malloc(strlen(path) + 1);\n        if (dirname == 0)\n            return 0;\n\n        basename = malloc(strlen(path) + 1);\n        if (basename == 0)\n            return 0;\n\n        sdirname(dirname, path);\n        sbasename(basename, path);\n\n        if (stat(dirname, &st0) != 0)\n            return 0;\n\n        link = getrealpath(dirname, options ^ GETREALPATH_IGNORE_MISSING_BASENAME);\n        if (link == 0)\n        {\n            free(basename);\n            free(dirname);\n            return 0;\n        }\n\n        scratch = malloc(strlen(link) + strlen(basename) + 2);\n        if (scratch == 0)\n        {\n            free(basename);\n            free(dirname);\n            return 0;\n        }\n\n        strcpy(scratch, link);\n        strcat(scratch, \"/\");\n        strcat(scratch, basename);\n\n        if (stat(dirname, &st) != 0)\n        {\n            free(link);\n            free(basename);\n            free(dirname);\n            free(scratch);\n            return 0;\n        }\n\n        free(link);\n        free(basename);\n        free(dirname);\n\n        if\n        (\n        st.st_dev != st0.st_dev ||\n        st.st_ino != st0.st_ino\n        )\n        {\n            free(scratch);\n            return 0;\n        }\n\n        return scratch;\n    }\n\n    if (path[0] == '/')\n    /* if path is an absolute path, copy its contents to scratch buffer */\n    {\n        allocated = strlen(path) + 1;\n\n        scratch = malloc(allocated);\n        if (scratch == 0)\n            return 0;\n\n        memcpy(scratch, path, allocated);\n    }\n    else\n    /* if path is a relative path, combine cwd and path into scratch buffer */\n    {\n        cwd = getworkingdirectory();\n        if (cwd == 0)\n            return 0;\n\n        pathlength = strlen(path);\n        cwdlength = strlen(cwd);\n\n        allocated = pathlength + cwdlength + 2;\n\n        scratch = malloc(allocated);\n        if (scratch == 0)\n        {\n            free(cwd);\n            return 0;\n        }\n\n        memcpy(scratch, cwd, cwdlength);\n\n        scratch[cwdlength] = '/';\n\n        memcpy(scratch + cwdlength + 1, path, pathlength + 1);\n\n        free(cwd);\n    }\n\n    tail = 0;\n    next = 0;\n    links = 0;\n\n    while (scratch[next] != '\\0')\n    {\n        if (scratch[next] == '/')\n        /* advance to start of filename */\n        {\n            /* keep the first slash */\n            scratch[tail++] = scratch[next++];\n\n            /* skip the rest */\n            while (scratch[next] == '/')\n                ++next;\n\n            continue;\n        }\n        else if (scratch[next] == '.')\n        /* handle filenames beginning with \".\" */\n        {\n            switch (scratch[next + 1])\n            {\n                case '/':\n                    /* collapse /./ down to / */\n                    do\n                        ++next;\n                    while (scratch[next] == '/');\n\n                    continue;\n\n                case '\\0':\n                    /* truncate trailing /. down to / */\n                    ++next;\n                    continue;\n\n                case '.':\n                    if (scratch[next + 2] == '/')\n                    /* go up one directory from /../ */\n                    {\n                        if (tail > 1)\n                            tail -= 2;\n                        else\n                            tail = 0;\n\n                        while (scratch[tail] != '/')\n                            --tail;\n\n                        if (tail == 0)\n                        {\n                            tail = 1;\n                            ++next;\n                        }\n                        else\n                        {\n                            next += 2;\n                        }\n                    }\n                    else if (scratch[next + 2] == '\\0')\n                    /* go up one directory from trailing /.. */\n                    {\n                        if (tail > 1)\n                            tail -= 2;\n                        else\n                            tail = 0;\n\n                        while (scratch[tail] != '/')\n                            --tail;\n\n                        if (tail == 0)\n                        {\n                            tail = 1;\n                            ++next;\n                        }\n                        else\n                        {\n                            next += 2;\n                        }\n                    }\n                    else\n                    /* process .. of regular filename beginning with .. */\n                    {\n                        do\n                            scratch[tail++] = scratch[next++];\n                        while (scratch[next] == '.');\n                    }\n\n                    break;\n\n                default:\n                    /* process . of regular filename begining with . */\n                    scratch[tail++] = scratch[next++];\n                    break;\n            }\n        }\n        else\n        /* process regular filename characters */\n        {\n            do\n                scratch[tail++] = scratch[next++];\n            while (scratch[next] != '\\0' && scratch[next] != '/');\n        }\n\n        save = scratch[tail];\n\n        scratch[tail] = '\\0';\n\n        if (lstat(scratch, &st) != 0)\n        {\n            free(scratch);\n            return 0;\n        }\n\n        if (S_ISLNK(st.st_mode))\n        {\n            if (links++ > GETREALPATH_MAXSYMLINKS)\n            {\n                free(scratch);\n                return 0;\n            }\n\n            link = getlink(scratch, &st);\n            if (link == 0)\n            {\n                free(scratch);\n                return 0;\n            }\n\n            pathlength = strlen(scratch) + strlen(scratch + next);\n\n            linklength = strlen(link);\n\n            if (pathlength + linklength + 1 > allocated)\n            {\n                allocated += pathlength + linklength + 1;\n\n                newmem = realloc(scratch, allocated);\n                if (newmem == 0)\n                {\n                    free(scratch);\n                    return 0;\n                }\n\n                scratch = newmem;\n            }\n\n            scratch[tail] = save;\n\n            if (link[0] == '/')\n            /* link represents an absolute path */\n            {\n                memmove(scratch + tail, scratch + next, strlen(scratch + next) + 1);\n\n                replacestring(scratch, 0, tail - 1, allocated, link);\n\n                /* start over */\n                tail = 0;\n                next = 0;\n            }\n            else\n            /* link represents a relative path */\n            {\n                memmove(scratch + tail, scratch + next, strlen(scratch + next) + 1);\n\n                x = tail;\n\n                while (scratch[x] != '/')\n                    --x;\n\n                replacestring(scratch, x + 1, tail - 1, allocated, link);\n\n                tail = x;\n                next = x;\n            }\n\n            free(link);\n        }\n        else\n        {\n            scratch[tail] = save;\n        }\n    }\n\n    /* terminate path */\n    if (tail > 1 && scratch[tail - 1] == '/')\n        scratch[tail - 1] = '\\0';\n    else\n        scratch[tail] = '\\0';\n\n    /* confirm that scratch and path both point to the same file */\n    if (stat(scratch, &st) != 0)\n    {\n        free(scratch);\n        return 0;\n    }\n\n    if\n    (\n    st.st_dev != st0.st_dev ||\n    st.st_ino != st0.st_ino\n    )\n    {\n        free(scratch);\n        return 0;\n    }\n\n    return scratch;\n}\n"
        },
        {
          "name": "getrealpath.h",
          "type": "blob",
          "size": 1.0791015625,
          "content": "/* Copyright (c) 2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef GETREALPATH_H\n#define GETREALPATH_H\n\n#define GETREALPATH_NONE                    0b0\n#define GETREALPATH_IGNORE_MISSING_BASENAME 0b1\n\nchar *getrealpath(const char *path, unsigned int options);\n\n#endif"
        },
        {
          "name": "hashdb.c",
          "type": "blob",
          "size": 18.7333984375,
          "content": "/* FDUPES Copyright (c) 2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"hashdb.h\"\n#include \"getrealpath.h\"\n#include \"sbasename.h\"\n#include \"sdirname.h\"\n#include \"errormsg.h\"\n\n#define DATABASE_VERSION 1\n\n#define HASH_FUNCTION_MD5 1\n\n#define HASH_FUNCTION HASH_FUNCTION_MD5\n#define HASH_FUNCTION_OUTPUT_LENGTH 16\n\nvoid md5copy(md5_byte_t *to, const md5_byte_t *from);\n\n#define PREPARE_STATEMENT(a, b) sqlite3_prepare_v2(db, a, -1, hashdb__newstatement(&b), 0)\n\n#define HASHDB_MAX_STATEMENTS 32\n\nsqlite3_stmt **hashdb_statements[HASHDB_MAX_STATEMENTS];\n\nsize_t hashdb_statements_top;\n\nsqlite3_stmt *query_begintransaction = 0;\nsqlite3_stmt *query_committransaction = 0;\nsqlite3_stmt *query_rollbacktransaction = 0;\nsqlite3_stmt *query_vacuum = 0;\nsqlite3_stmt *query_getdirectoryid = 0;\nsqlite3_stmt *query_insertdirectory = 0;\nsqlite3_stmt *query_deletedirectory = 0;\nsqlite3_stmt *query_cleardirectories = 0;\nsqlite3_stmt *query_foreachdirectory = 0;\nsqlite3_stmt *query_foreachdirectorywithin = 0;\nsqlite3_stmt *query_loadhash = 0;\nsqlite3_stmt *query_savehash = 0;\nsqlite3_stmt *query_deletehash = 0;\nsqlite3_stmt *query_deletehashforpath = 0;\nsqlite3_stmt *query_foreachhash = 0;\nsqlite3_stmt *query_foreachhashwithin = 0;\n\nsqlite3_stmt **hashdb__newstatement(sqlite3_stmt **statement)\n{\n  assert(hashdb_statements_top + 1 <= HASHDB_MAX_STATEMENTS);\n\n  hashdb_statements[hashdb_statements_top++] = statement;\n\n  return statement;\n}\n\nint hashdb__createtables(sqlite3 *db)\n{\n  int result;\n\n  hashdb_begintransaction(db);\n\n  result = sqlite3_exec(db,\n    \"CREATE TABLE IF NOT EXISTS directories (\"\n    \"  id INTEGER PRIMARY KEY,\"\n    \"  name TEXT,\"\n    \"  full_path TEXT UNIQUE,\"\n    \"  parent INTEGER REFERENCES directories(id) ON DELETE CASCADE\"\n    \")\",\n    0, 0, 0);\n\n  if (result != SQLITE_OK)\n    return result;\n\n  result = sqlite3_exec(db,\n    \"CREATE TABLE IF NOT EXISTS hashes (\"\n    \"  directory_id INTEGER REFERENCES directories(id) ON DELETE CASCADE,\"\n    \"  filename TEXT,\"\n    \"  inode BLOB,\"\n    \"  size INTEGER,\"\n    \"  ctime BLOB,\"\n    \"  mtime BLOB,\"\n    \"  ctime_nsec INTEGER,\"\n    \"  mtime_nsec INTEGER,\"\n    \"  partial_hash BLOB,\"\n    \"  partial_hash_bytes INTEGER,\"\n    \"  hash BLOB,\"\n    \"  hash_function INTEGER,\"\n    \"  PRIMARY KEY (directory_id, filename)\"\n    \")\",\n    0, 0, 0);\n\n  if (result != SQLITE_OK) {\n    hashdb_rollbacktransaction(db);\n    return result;\n  }\n\n  hashdb_committransaction(db);\n\n  return SQLITE_OK;\n}\n\nint hashdb__preparestatements(sqlite3 *db)\n{\n  int result;\n\n  /* standard SQL commands */\n  result = PREPARE_STATEMENT(\"BEGIN\", query_begintransaction);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"COMMIT\", query_committransaction);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"ROLLBACK\", query_rollbacktransaction);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"VACUUM\", query_vacuum);\n  if (result != SQLITE_OK)\n    return result;\n\n  /* directory operations */\n  result = PREPARE_STATEMENT(\"SELECT id FROM directories WHERE full_path = ?\", query_getdirectoryid);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"INSERT INTO directories (name, full_path, parent) VALUES (?, ?, ?)\", query_insertdirectory);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"DELETE FROM directories WHERE id = ?\", query_deletedirectory);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"DELETE FROM directories\", query_cleardirectories);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"SELECT id, name, full_path, parent FROM directories\", query_foreachdirectory);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"SELECT id, name, full_path, parent FROM directories WHERE parent = :parent\", query_foreachdirectorywithin);\n  if (result != SQLITE_OK)\n    return result;\n\n  /* hash operations */\n  result = PREPARE_STATEMENT(\"SELECT hashes.partial_hash, hashes.hash FROM hashes INNER JOIN directories ON hashes.directory_id = directories.id WHERE directories.full_path = ? AND hashes.filename = ? AND hashes.inode = ? AND hashes.size = ? AND hashes.ctime = ? AND hashes.mtime = ? AND hashes.ctime_nsec = ? AND hashes.mtime_nsec = ? AND hashes.partial_hash_bytes = ? AND hashes.hash_function = ?\", query_loadhash);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"INSERT OR REPLACE INTO hashes (directory_id, filename, inode, size, ctime, mtime, ctime_nsec, mtime_nsec, partial_hash, partial_hash_bytes, hash, hash_function) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\", query_savehash);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"DELETE FROM hashes WHERE directory_id = ? AND filename = ?\", query_deletehash);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"DELETE FROM hashes WHERE filename = ? AND directory_id IN (SELECT id FROM directories WHERE full_path = ?)\", query_deletehashforpath);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"SELECT hashes.directory_id, hashes.filename, directories.full_path AS directory FROM hashes INNER JOIN directories ON hashes.directory_id = directories.id\", query_foreachhash);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = PREPARE_STATEMENT(\"SELECT hashes.directory_id, hashes.filename, directories.full_path AS directory FROM hashes INNER JOIN directories ON hashes.directory_id = directories.id WHERE directories.id = :directory_id\", query_foreachhashwithin);\n  if (result != SQLITE_OK)\n    return result;\n\n  return SQLITE_OK;\n}\n\nvoid hashdb__finalizestatements()\n{\n  size_t s;\n\n  for (s = 0; s < hashdb_statements_top; ++s) {\n    sqlite3_finalize(*hashdb_statements[s]);\n    *hashdb_statements[s] = 0;\n  }\n\n  hashdb_statements_top = 0;\n}\n\nint hashdb__getdatabaseversion(sqlite3 *db, int *version)\n{\n  sqlite3_stmt *statement;\n  int result;\n\n  result = sqlite3_prepare_v2(db, \"PRAGMA user_version\", -1, &statement, 0);\n  if (result != SQLITE_OK)\n    return result;\n\n  result = sqlite3_step(statement);\n  if (result != SQLITE_ROW)\n    return result;\n\n  *version = sqlite3_column_int(statement, 0);\n\n  result = sqlite3_finalize(statement);\n  if (result != SQLITE_OK)\n    return result;\n\n  return SQLITE_OK;\n}\n\nint hashdb__setdatabaseversion(sqlite3 *db, int version)\n{\n  char query[64];\n  int written;\n\n  written = snprintf(query, sizeof(query), \"PRAGMA user_version = %d\", version);\n  if (written >= sizeof(query))\n      return SQLITE_ERROR;\n\n  return sqlite3_exec(db, query, 0, 0, 0);\n}\n\nint hashdb__iscompatible(int major)\n{\n  return major <= DATABASE_VERSION;\n}\n\nint hashdb__insertdirectory(sqlite3 *db, const char *name, const char *full_path, const sqlite3_int64 *parent)\n{\n  int result;\n\n  sqlite3_bind_text(query_insertdirectory, 1, name, strlen(name), SQLITE_TRANSIENT);\n  sqlite3_bind_text(query_insertdirectory, 2, full_path, strlen(full_path), SQLITE_TRANSIENT);\n\n  if (parent != 0)\n    sqlite3_bind_int64(query_insertdirectory, 3, *parent);\n  else\n    sqlite3_bind_null(query_insertdirectory, 3);\n\n  result = sqlite3_step(query_insertdirectory);\n\n  sqlite3_reset(query_insertdirectory);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb__enable_foreign_keys(sqlite3 *db)\n{\n  return sqlite3_exec(db, \"PRAGMA foreign_keys = ON\", 0, 0, 0) == SQLITE_OK;\n}\n\nint hashdb__foreign_keys_enabled(sqlite3 *db)\n{\n  sqlite3_stmt *statement;\n  int value;\n  int result;\n\n  result = sqlite3_prepare_v2(db, \"PRAGMA foreign_keys\", -1, &statement, 0);\n  if (result != SQLITE_OK)\n    return 0;\n\n  result = sqlite3_step(statement);\n  if (result != SQLITE_ROW)\n    return 0;\n\n  value = sqlite3_column_int(statement, 0);\n\n  result = sqlite3_finalize(statement);\n  if (result != SQLITE_OK)\n    return 0;\n\n  return value;\n}\n\nint hashdb__enable_write_ahead(sqlite3 *db)\n{\n  return sqlite3_exec(db, \"PRAGMA journal_mode = WAL\", 0, 0, 0) == SQLITE_OK;\n}\n\nsqlite3 *hashdb_open(const char *path)\n{\n  sqlite3 *db;\n  int result;\n  int version;\n\n  result = sqlite3_open_v2(path, &db, SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);\n  if (result != SQLITE_OK)\n    return 0;\n\n  if (!hashdb__enable_write_ahead(db)) {\n    sqlite3_close_v2(db);\n    return 0;\n  }\n\n  if (!hashdb__enable_foreign_keys(db)) {\n    sqlite3_close_v2(db);\n    return 0;\n  }\n\n  if (!hashdb__foreign_keys_enabled(db)) {\n    sqlite3_close_v2(db);\n    return 0;\n  }\n\n  result = hashdb__getdatabaseversion(db, &version);\n  if (result != SQLITE_OK || !hashdb__iscompatible(version)) {\n    sqlite3_close_v2(db);\n    return 0;\n  }\n\n  if (version == 0) /* this is a new database */ {\n    result = hashdb__createtables(db);\n    if (result != SQLITE_OK) {\n      sqlite3_close_v2(db);\n      return 0;\n    }\n\n    result = hashdb__setdatabaseversion(db, DATABASE_VERSION);\n    if (result != SQLITE_OK) {\n      sqlite3_close_v2(db);\n      return 0;\n    }\n  }\n\n  if (hashdb__preparestatements(db) != SQLITE_OK) {\n    sqlite3_close_v2(db);\n    return 0;\n  }\n\n  return db;\n}\n\nint hashdb_close(sqlite3 *db)\n{\n  hashdb__finalizestatements();\n\n  return sqlite3_close_v2(db);\n}\n\nint hashdb_begintransaction(sqlite3 *db)\n{\n  int result;\n\n  result = sqlite3_step(query_begintransaction);\n\n  sqlite3_reset(query_begintransaction);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_committransaction(sqlite3 *db)\n{\n  int result;\n\n  result = sqlite3_step(query_committransaction);\n\n  sqlite3_reset(query_committransaction);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_rollbacktransaction(sqlite3 *db)\n{\n  int result;\n\n  result = sqlite3_step(query_rollbacktransaction);\n\n  sqlite3_reset(query_rollbacktransaction);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_vacuum(sqlite3 *db)\n{\n  int result;\n\n  result = sqlite3_step(query_vacuum);\n\n  sqlite3_reset(query_vacuum);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_getdirectoryid(sqlite3 *db, const char *path, sqlite_int64 *directory_id)\n{\n  int result;\n\n  sqlite3_bind_text(query_getdirectoryid, 1, path, strlen(path), SQLITE_TRANSIENT);\n\n  result = sqlite3_step(query_getdirectoryid);\n\n  if (result == SQLITE_ROW)\n    *directory_id = sqlite3_column_int64(query_getdirectoryid, 0);\n\n  sqlite3_reset(query_getdirectoryid);\n\n  return result == SQLITE_ROW;\n}\n\nint hashdb_savedirectory(sqlite3 *db, const char *path)\n{\n  int result;\n  char *dir;\n  char *base;\n  sqlite3_int64 parentid;\n\n  dir = sdirname(0, path);\n  if (!dir)\n    return 0;\n\n  base = sbasename(0, path);\n  if (!base)\n  {\n    free(dir);\n    return 0;\n  }\n\n  if (!hashdb_getdirectoryid(db, dir, &parentid))\n  {\n    if (strcmp(path, \"/\") == 0)\n    {\n      result = hashdb__insertdirectory(db, \"/\", \"/\", 0);\n\n      free(base);\n      free(dir);\n\n      return result;\n    }\n\n    if (!hashdb_savedirectory(db, dir))\n    {\n      free(base);\n      free(dir);\n\n      return 0;\n    }\n\n    parentid = sqlite3_last_insert_rowid(db);\n  }\n\n  result = hashdb__insertdirectory(db, base, path, &parentid);\n\n  free(base);\n  free(dir);\n\n  return result;\n}\n\nint hashdb_deletedirectory(sqlite3 *db, sqlite3_int64 id)\n{\n  int result;\n\n  sqlite3_bind_int64(query_deletedirectory, 1, id);\n\n  result = sqlite3_step(query_deletedirectory);\n\n  sqlite3_reset(query_deletedirectory);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_cleardirectories(sqlite3 *db)\n{\n  int result;\n\n  result = sqlite3_step(query_cleardirectories);\n\n  sqlite3_reset(query_cleardirectories);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_foreachdirectory(sqlite3 *db, const sqlite3_int64 *parent, int (*callback)(const sqlite3_int64, const char*, const char*, const sqlite3_int64))\n{\n  int result;\n  sqlite3_stmt *query;\n\n  if (parent != 0) {\n    query = query_foreachdirectorywithin;\n    sqlite3_bind_int64(query, 1, *parent);\n  } else {\n    query = query_foreachdirectory;\n    sqlite3_bind_null(query, 1);\n  }\n\n  result = sqlite3_step(query);\n\n  while (result == SQLITE_ROW)\n  {\n    result = callback(\n      sqlite3_column_int64(query, 0),\n      sqlite3_column_text(query, 1),\n      sqlite3_column_text(query, 2),\n      sqlite3_column_int64(query, 3)\n    );\n\n    if (result == 0) {\n      sqlite3_reset(query);\n      return 1;\n    }\n\n    result = sqlite3_step(query);\n  }\n\n  sqlite3_reset(query);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_loadhash(sqlite3 *db, const file_t *entry, md5_byte_t **partialhash, md5_byte_t **fullhash)\n{\n  int result;\n  int hashsize;\n  char *realpath;\n  char *name;\n\n  realpath = getrealpath(entry->d_name, 0);\n  if (realpath == 0)\n    return 0;\n\n  name = malloc(strlen(realpath) + 1);\n  if (name == 0)\n  {\n    free(realpath);\n    return 0;\n  }\n\n  sdirname(name, realpath);\n  sqlite3_bind_text(query_loadhash, 1, name, strlen(name), SQLITE_TRANSIENT);\n\n  sbasename(name, realpath);\n  sqlite3_bind_text(query_loadhash, 2, name, strlen(name), SQLITE_TRANSIENT);\n\n  sqlite3_bind_blob(query_loadhash, 3, &entry->inode, sizeof(entry->inode), SQLITE_TRANSIENT);\n  sqlite3_bind_int64(query_loadhash, 4, entry->size);\n  sqlite3_bind_blob(query_loadhash, 5, &entry->ctime, sizeof(entry->ctime), SQLITE_TRANSIENT);\n  sqlite3_bind_blob(query_loadhash, 6, &entry->mtime, sizeof(entry->mtime), SQLITE_TRANSIENT);\n  sqlite3_bind_int64(query_loadhash, 7, entry->ctime_nsec);\n  sqlite3_bind_int64(query_loadhash, 8, entry->mtime_nsec);\n  sqlite3_bind_int64(query_loadhash, 9, PARTIAL_MD5_SIZE);\n  sqlite3_bind_int(query_loadhash, 10, HASH_FUNCTION);\n\n  result = sqlite3_step(query_loadhash);\n\n  free(name);\n  free(realpath);\n\n  if (result != SQLITE_ROW)\n  {\n    sqlite3_reset(query_loadhash);\n    return 0;\n  }\n\n  hashsize = sqlite3_column_bytes(query_loadhash, 0);\n\n  if (hashsize == HASH_FUNCTION_OUTPUT_LENGTH * sizeof(md5_byte_t))\n  {\n      *partialhash = (md5_byte_t*) malloc(HASH_FUNCTION_OUTPUT_LENGTH * sizeof(md5_byte_t));\n      if (*partialhash == NULL) {\n          errormsg(\"out of memory\\n\");\n          exit(1);\n      }\n\n      md5copy(*partialhash, sqlite3_column_blob(query_loadhash, 0));\n  }\n  else\n  {\n      *partialhash = 0;\n  }\n\n  hashsize = sqlite3_column_bytes(query_loadhash, 1);\n\n  if (hashsize == HASH_FUNCTION_OUTPUT_LENGTH * sizeof(md5_byte_t))\n  {\n      *fullhash = (md5_byte_t*) malloc(HASH_FUNCTION_OUTPUT_LENGTH * sizeof(md5_byte_t));\n      if (*fullhash == NULL) {\n          errormsg(\"out of memory\\n\");\n          exit(1);\n      }\n\n      md5copy(*fullhash, sqlite3_column_blob(query_loadhash, 1));\n  }\n  else\n  {\n      *fullhash = 0;\n  }\n\n  sqlite3_reset(query_loadhash);\n\n  return *partialhash || *fullhash;\n}\n\nint hashdb_savehash(sqlite3 *db, const file_t *entry, md5_byte_t *partialhash, md5_byte_t *fullhash)\n{\n  int result;\n  char *realpath;\n  char *name;\n  sqlite3_int64 directoryid;\n\n  realpath = getrealpath(entry->d_name, 0);\n  if (realpath == 0)\n    return 0;\n\n  name = malloc(strlen(realpath) + 1);\n  if (name == 0)\n  {\n    free(realpath);\n    return 0;\n  }\n\n  sdirname(name, realpath);\n\n  if (!hashdb_getdirectoryid(db, name, &directoryid))\n  {\n    if (!hashdb_savedirectory(db, name))\n    {\n      free(name);\n      free(realpath);\n      return 0;\n    }\n\n    directoryid = sqlite3_last_insert_rowid(db);\n  }\n\n  sbasename(name, realpath);\n\n  sqlite3_bind_int64(query_savehash, 1, directoryid);\n  sqlite3_bind_text(query_savehash, 2, name, strlen(name), SQLITE_TRANSIENT);\n  sqlite3_bind_blob(query_savehash, 3, &entry->inode, sizeof(entry->inode), SQLITE_TRANSIENT);\n  sqlite3_bind_int64(query_savehash, 4, entry->size);\n  sqlite3_bind_blob(query_savehash, 5, &entry->ctime, sizeof(entry->ctime), SQLITE_TRANSIENT);\n  sqlite3_bind_blob(query_savehash, 6, &entry->mtime, sizeof(entry->mtime), SQLITE_TRANSIENT);\n  sqlite3_bind_int64(query_savehash, 7, entry->ctime_nsec);\n  sqlite3_bind_int64(query_savehash, 8, entry->mtime_nsec);\n\n  if (partialhash)\n    sqlite3_bind_blob(query_savehash, 9, partialhash, HASH_FUNCTION_OUTPUT_LENGTH * sizeof(md5_byte_t), SQLITE_TRANSIENT);\n  else\n    sqlite3_bind_null(query_savehash, 9);\n\n  sqlite3_bind_int64(query_savehash, 10, PARTIAL_MD5_SIZE);\n\n  if (fullhash)\n    sqlite3_bind_blob(query_savehash, 11, fullhash, HASH_FUNCTION_OUTPUT_LENGTH * sizeof(md5_byte_t), SQLITE_TRANSIENT);\n  else\n    sqlite3_bind_null(query_savehash, 11);\n\n  sqlite3_bind_int(query_savehash, 12, HASH_FUNCTION);\n\n  result = sqlite3_step(query_savehash);\n\n  free(name);\n  free(realpath);\n\n  sqlite3_reset(query_savehash);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_foreachhash(sqlite3 *db, sqlite3_int64 *directoryid, int (*callback)(const sqlite3_int64, const char*, const char*))\n{\n  int result;\n  sqlite3_stmt *query;\n\n  if (directoryid != 0) {\n    query = query_foreachhashwithin;\n    sqlite3_bind_int64(query, 1, *directoryid);\n  } else {\n    query = query_foreachhash;\n    sqlite3_bind_null(query, 1);\n  }\n\n  result = sqlite3_step(query);\n  while (result == SQLITE_ROW)\n  {\n    result = callback(\n      sqlite3_column_int64(query, 0),\n      sqlite3_column_text(query, 1),\n      sqlite3_column_text(query, 2)\n    );\n\n    if (result == 0) {\n      sqlite3_reset(query);\n      return 1;\n    }\n\n    result = sqlite3_step(query);\n  }\n\n  sqlite3_reset(query);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_deletehash(sqlite3 *db, sqlite3_int64 directoryid, const char *filename)\n{\n  int result;\n\n  sqlite3_bind_int64(query_deletehash, 1, directoryid);\n  sqlite3_bind_text(query_deletehash, 2, filename, strlen(filename), SQLITE_TRANSIENT);\n\n  result = sqlite3_step(query_deletehash);\n\n  sqlite3_reset(query_deletehash);\n\n  return result == SQLITE_DONE;\n}\n\nint hashdb_deletehashforpath(sqlite3 *db, const char *path)\n{\n  int result;\n  char *name;\n  sqlite3_int64 pathid;\n\n  name = malloc(strlen(path) + 1);\n  if (name == 0)\n    return 0;\n\n  sbasename(name, path);\n  sqlite3_bind_text(query_deletehashforpath, 1, name, strlen(name), SQLITE_TRANSIENT);\n\n  sdirname(name, path);\n  sqlite3_bind_text(query_deletehashforpath, 2, name, strlen(name), SQLITE_TRANSIENT);\n\n  free(name);\n\n  result = sqlite3_step(query_deletehashforpath);\n\n  sqlite3_reset(query_deletehashforpath);\n\n  return result == SQLITE_DONE;\n}"
        },
        {
          "name": "hashdb.h",
          "type": "blob",
          "size": 2.263671875,
          "content": "/* FDUPES Copyright (c) 2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef HASHDB_H\n#define HASHDB_H\n\n#include \"fdupes.h\"\n#include <sqlite3.h>\n\nsqlite3 *hashdb_open(const char *path);\nint hashdb_close(sqlite3 *db);\nint hashdb_begintransaction(sqlite3 *db);\nint hashdb_committransaction(sqlite3 *db);\nint hashdb_rollbacktransaction(sqlite3 *db);\nint hashdb_vacuum(sqlite3 *db);\nint hashdb_getdirectoryid(sqlite3 *db, const char *path, sqlite3_int64 *directoryid);\nint hashdb_savedirectory(sqlite3 *db, const char *path);\nint hashdb_deletedirectory(sqlite3 *db, sqlite3_int64 id);\nint hashdb_cleardirectories(sqlite3 *db);\nint hashdb_foreachdirectory(sqlite3 *db, const sqlite3_int64 *parentid, int (*callback)(const sqlite3_int64, const char*, const char*, const sqlite3_int64));\nint hashdb_loadhash(sqlite3 *db, const file_t *entry, md5_byte_t **partialhash, md5_byte_t **fullhash);\nint hashdb_savehash(sqlite3 *db, const file_t *entry, md5_byte_t *partialhash, md5_byte_t *fullhash);\nint hashdb_foreachhash(sqlite3 *db, sqlite3_int64 *directoryid, int (*callback)(const sqlite3_int64, const char*, const char*));\nint hashdb_deletehash(sqlite3 *db, sqlite3_int64 directoryid, const char *filename);\nint hashdb_deletehashforpath(sqlite3 *db, const char *path);\n\n#endif"
        },
        {
          "name": "log.c",
          "type": "blob",
          "size": 4.283203125,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include \"fmatch.h\"\n#include \"dir.h\"\n#include \"log.h\"\n\n#define LOG_HEADER \"[fdupes log]\\n\"\n\n/* Open log file in append mode. If file exists, make sure it is a valid fdupes log file. \n*/\nstruct log_info *log_open(char *filename, int *error)\n{\n  struct log_info *info;\n  int is_match;\n  size_t read;\n\n  info = (struct log_info*) malloc(sizeof(struct log_info));\n  if (info == 0)\n  {\n    if (error != 0)\n      *error = LOG_ERROR_OUT_OF_MEMORY;\n\n    return 0;\n  }\n\n  info->file = fopen(filename, \"a+\");\n  if (info->file == 0)\n  {\n    if (error != 0)\n      *error = LOG_ERROR_FOPEN_FAILED;\n\n    free(info);\n    return 0;\n  }\n\n  fmatch(info->file, LOG_HEADER, &is_match, &read);\n  if (!is_match && read > 0)\n  {\n    if (error != 0)\n      *error = LOG_ERROR_NOT_A_LOG_FILE;\n\n    free(info);\n    return 0;\n  }\n\n  info->append = read > 0;\n\n  info->log_start = 1;\n  info->deleted = 0;\n  info->remaining = 0;\n\n  if (error != 0)\n    *error = LOG_ERROR_NONE;\n\n  return info;\n}\n\n/* Free linked lists holding set of deleted and remaining files.\n*/\nvoid log_free_set(struct log_info *info)\n{\n  struct log_file *f;\n  struct log_file *next;\n\n  f = info->deleted;\n  while (f != 0)\n  {\n    next = f->next;\n\n    free(f);\n\n    f = next;\n  }\n\n  f = info->remaining;\n  while (f != 0)\n  {\n    next = f->next;\n\n    free(f);\n\n    f = next;\n  }\n\n  info->deleted = 0;\n  info->remaining = 0;\n}\n\n/* Signal beginning of duplicate set.\n*/\nvoid log_begin_set(struct log_info *info)\n{\n  log_free_set(info);\n}\n\n/* Add deleted file to log.\n*/\nint log_file_deleted(struct log_info *info, char *name)\n{\n  struct log_file *file;\n\n  file = (struct log_file*) malloc(sizeof(struct log_file));\n  if (file == 0)\n    return 0;\n\n  file->next = info->deleted;\n  file->filename = name;\n\n  info->deleted = file;\n\n  return 1;\n}\n\n/* Add remaining file to log.\n*/\nint log_file_remaining(struct log_info *info, char *name)\n{\n  struct log_file *file;\n\n  file = (struct log_file*) malloc(sizeof(struct log_file));\n  if (file == 0)\n    return 0;\n\n  file->next = info->remaining;\n  file->filename = name;\n\n  info->remaining = file;\n\n  return 1;\n}\n\n/* Output log header.\n*/\nvoid log_header(FILE *file)\n{\n  fprintf(file, \"%s\\n\", LOG_HEADER);\n}\n\n/* Output log timestamp.\n*/\nvoid log_timestamp(FILE *file)\n{\n  time_t t = time(NULL);\n  struct tm tm = *localtime(&t);\n\n  fprintf(file, \"Log entry for %d-%02d-%02d %02d:%02d:%02d\\n\\n\", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);\n}\n\n/* Output current working directory.\n*/\nvoid log_cwd(FILE *file)\n{\n  char *cwd = getworkingdirectory();\n\n  fprintf(file, \"working directory:\\n  %s\\n\\n\", cwd);\n\n  free(cwd);\n}\n\n/* Signal the end of a duplicate set.\n*/\nvoid log_end_set(struct log_info *info)\n{\n  struct log_file *f;\n\n  if (info->deleted == 0)\n    return;\n\n  if (info->log_start)\n  {\n    if (info->append)\n      fprintf(info->file, \"---\\n\\n\");\n    else\n      log_header(info->file);\n\n    log_timestamp(info->file);\n    log_cwd(info->file);\n\n    info->log_start = 0;\n  }\n\n  f = info->deleted;\n  do\n  {\n    fprintf(info->file, \"deleted %s\\n\", f->filename);\n    f = f->next;\n  } while (f != 0);\n\n  f = info->remaining;\n  while (f != 0)\n  {\n    fprintf(info->file, \"   left %s\\n\", f->filename);\n    f = f->next;\n  }\n\n  fprintf(info->file, \"\\n\");\n\n  fflush(info->file);\n}\n\n/* Close log and free all memory.\n*/\nvoid log_close(struct log_info *info)\n{\n  fclose(info->file);\n\n  log_free_set(info);\n\n  free(info);\n}\n"
        },
        {
          "name": "log.h",
          "type": "blob",
          "size": 1.533203125,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef LOG_H\n#define LOG_H\n\n#include <stdio.h>\n\n#define LOG_ERROR_NONE 0\n#define LOG_ERROR_OUT_OF_MEMORY 1\n#define LOG_ERROR_FOPEN_FAILED 2\n#define LOG_ERROR_NOT_A_LOG_FILE 3\n\nstruct log_file\n{\n  char *filename;\n  struct log_file *next;\n};\n\nstruct log_info\n{\n  FILE *file;\n  int append;\n  int log_start;\n  struct log_file *deleted;\n  struct log_file *remaining;\n};\n\nstruct log_info *log_open(char *filename, int *error);\nvoid log_begin_set(struct log_info *info);\nint log_file_deleted(struct log_info *info, char *name);\nint log_file_remaining(struct log_info *info, char *name);\nvoid log_end_set(struct log_info *info);\nvoid log_close(struct log_info *info);\n\n#endif"
        },
        {
          "name": "mbstowcs_escape_invalid.c",
          "type": "blob",
          "size": 3.4228515625,
          "content": "/* Copyright (c) 2019-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include \"config.h\"\n#include \"mbstowcs_escape_invalid.h\"\n#include <wchar.h>\n#include <string.h>\n#include <stdio.h>\n\nvoid reset_mbstate(mbstate_t *state)\n{\n    memset(state, 0, sizeof(mbstate_t));\n}\n\nsize_t putoctal(wchar_t *dest, char c)\n{\n    swprintf(dest, 5, L\"\\\\%03o\", (unsigned char) c);\n    return 4;\n}\n\nsize_t put_invalid_sequence(wchar_t *dest, const char *src, size_t *destination_index, size_t count, size_t max)\n{\n    size_t x;\n\n    for (x = 0; x < count; ++x)\n    {\n        if (dest != 0)\n        {\n            if (*destination_index + 5 > max)\n                return x;\n\n            putoctal(dest + *destination_index, src[x]);\n        }\n\n        *destination_index += 4;\n    }\n\n    return count;\n}\n\nsize_t mbstowcs_escape_invalid(wchar_t *dest, const char *src, size_t n)\n{\n    mbstate_t state;\n    wchar_t wc;\n    size_t x;\n    size_t i;\n    size_t dx;\n    size_t write;\n    size_t written;\n    size_t result;\n\n    reset_mbstate(&state);\n\n    x = 0;\n    i = 0;\n    dx = 0;\n\n    while (src[x] != '\\0')\n    {\n        result = mbrtowc(&wc, src + x, 1, &state);\n\n        if (result == -2)\n        /* sequence is not yet complete */\n        {\n            ++x;\n            ++i;\n        }\n        else if (result == -1)\n        /* invalid sequence */\n        {\n            write = i == 0 ? 1 : i;\n\n            if (dest != 0)\n            {\n                written = put_invalid_sequence(dest, src + (x - i), &dx, write, n);\n\n                if (written != write)\n                    return -1;\n            }\n            else\n                put_invalid_sequence(0, src + (x - i), &dx, write, 0);\n\n            if (i == 0)\n                ++x;\n    \n            i = 0;\n\n            reset_mbstate(&state);\n        }\n        else if (result != 0)\n        /* OK, add character */\n        {\n            if (dest != 0)\n            {\n                if (dx < n)\n                    dest[dx++] = wc;\n                else\n                    return -1;\n            }\n            else\n                ++dx;\n\n            ++x;\n\n            i = 0;\n        }\n        \n        if (src[x] == L'\\0' && i > 0)\n        /* output final incomplete sequence */\n        {\n            if (dest != 0)\n            {\n                written = put_invalid_sequence(dest, src + (x - i), &dx, i, n);\n\n                if (written != i)\n                    return -1;\n            }\n            else\n                put_invalid_sequence(0, src + (x - i), &dx, i, 0);\n        }        \n    }\n\n    if (dest != 0)\n    {\n        if (dx < n)\n            dest[dx] = L'\\0';\n        else\n            return -1;\n    }\n\n    return dx + 1;\n}\n"
        },
        {
          "name": "mbstowcs_escape_invalid.h",
          "type": "blob",
          "size": 1.046875,
          "content": "/* Copyright (c) 2019-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef MBSTOWCS_ESCAPE_INVALID_H\n#define MBSTOWCS_ESCAPE_INVALID_H\n\n#include <wchar.h>\n\nsize_t mbstowcs_escape_invalid(wchar_t *dest, const char *src, size_t n);\n\n#endif"
        },
        {
          "name": "md5",
          "type": "tree",
          "content": null
        },
        {
          "name": "ncurses-commands.c",
          "type": "blob",
          "size": 24.6748046875,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include \"ncurses-status.h\"\n#include \"ncurses-commands.h\"\n#include \"fileaction.h\"\n#include \"flags.h\"\n#include \"confirmmatch.h\"\n#include \"errormsg.h\"\n#include \"wcs.h\"\n#include \"mbstowcs_escape_invalid.h\"\n#include \"log.h\"\n#include \"removeifnotchanged.h\"\n#ifndef NO_SQLITE\n  #include \"hashdb.h\"\n  #include \"getrealpath.h\"\n#endif\n#include <wchar.h>\n#include <pcre2.h>\n\n#ifndef NO_SQLITE\nextern sqlite3 *db;\n#endif\n\nvoid set_file_action(struct groupfile *file, int new_action, size_t *deletion_tally);\n\nstruct command_map command_list[] = {\n  {L\"sel\", COMMAND_SELECT_CONTAINING},\n  {L\"selb\", COMMAND_SELECT_BEGINNING},\n  {L\"sele\", COMMAND_SELECT_ENDING},\n  {L\"selm\", COMMAND_SELECT_MATCHING},\n  {L\"selr\", COMMAND_SELECT_REGEX},\n  {L\"dsel\", COMMAND_CLEAR_SELECTIONS_CONTAINING},\n  {L\"dselb\", COMMAND_CLEAR_SELECTIONS_BEGINNING},\n  {L\"dsele\", COMMAND_CLEAR_SELECTIONS_ENDING},\n  {L\"dselm\", COMMAND_CLEAR_SELECTIONS_MATCHING},\n  {L\"dselr\", COMMAND_CLEAR_SELECTIONS_REGEX},\n  {L\"csel\", COMMAND_CLEAR_ALL_SELECTIONS},\n  {L\"isel\", COMMAND_INVERT_GROUP_SELECTIONS},\n  {L\"ks\", COMMAND_KEEP_SELECTED},\n  {L\"ds\", COMMAND_DELETE_SELECTED},\n  {L\"rs\", COMMAND_RESET_SELECTED},\n  {L\"rg\", COMMAND_RESET_GROUP},\n  {L\"all\", COMMAND_PRESERVE_ALL},\n  {L\"goto\", COMMAND_GOTO_SET},\n  {L\"prune\", COMMAND_PRUNE},\n  {L\"exit\", COMMAND_EXIT},\n  {L\"quit\", COMMAND_EXIT},\n  {L\"help\", COMMAND_HELP},\n  {0, COMMAND_UNDEFINED}\n};\n\nstruct command_map confirmation_keyword_list[] = {\n  {L\"yes\", COMMAND_YES},\n  {L\"no\", COMMAND_NO},\n  {0, COMMAND_UNDEFINED}\n};\n\n/* select files containing string */\nint cmd_select_containing(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int selectedgroupcount = 0;\n  int selectedfilecount = 0;\n  int groupselected;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupselected = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsinmbcs(groups[g].files[f].file->d_name, commandarguments))\n        {\n          groups[g].selected = 1;\n          groups[g].files[f].selected = 1;\n\n          groupselected = 1;\n          ++selectedfilecount;\n        }\n      }\n\n      if (groupselected)\n        ++selectedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", selectedfilecount, selectedgroupcount);\n\n  return 1;\n}\n\n/* select files beginning with string */\nint cmd_select_beginning(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int selectedgroupcount = 0;\n  int selectedfilecount = 0;\n  int groupselected;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupselected = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsbeginmbcs(groups[g].files[f].file->d_name, commandarguments))\n        {\n          groups[g].selected = 1;\n          groups[g].files[f].selected = 1;\n\n          groupselected = 1;\n          ++selectedfilecount;\n        }\n      }\n\n      if (groupselected)\n        ++selectedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", selectedfilecount, selectedgroupcount);\n\n  return 1;\n}\n\n/* select files ending with string */\nint cmd_select_ending(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int selectedgroupcount = 0;\n  int selectedfilecount = 0;\n  int groupselected;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupselected = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsendsmbcs(groups[g].files[f].file->d_name, commandarguments))\n        {\n          groups[g].selected = 1;\n          groups[g].files[f].selected = 1;\n\n          groupselected = 1;\n          ++selectedfilecount;\n        }\n      }\n\n      if (groupselected)\n        ++selectedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", selectedfilecount, selectedgroupcount);\n\n  return 1;\n}\n\n/* select files matching string */\nint cmd_select_matching(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int selectedgroupcount = 0;\n  int selectedfilecount = 0;\n  int groupselected;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupselected = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsmbcscmp(commandarguments, groups[g].files[f].file->d_name) == 0)\n        {\n          groups[g].selected = 1;\n          groups[g].files[f].selected = 1;\n\n          groupselected = 1;\n          ++selectedfilecount;\n        }\n      }\n\n      if (groupselected)\n        ++selectedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", selectedfilecount, selectedgroupcount);\n\n  return 1;\n}\n\n/* select files matching pattern */\nint cmd_select_regex(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  size_t size;\n  wchar_t *wcsfilename;\n  size_t needed;\n  int errorcode;\n  PCRE2_SIZE erroroffset;\n  pcre2_code *code;\n  pcre2_match_data *md;\n  int matches;\n  int g;\n  int f;\n  int selectedgroupcount = 0;\n  int selectedfilecount = 0;\n  int groupselected;\n\n  code = pcre2_compile((PCRE2_SPTR)commandarguments, PCRE2_ZERO_TERMINATED, PCRE2_UTF | PCRE2_UCP, &errorcode, &erroroffset, 0);\n\n  if (code == 0)\n    return -1;\n\n  pcre2_jit_compile(code, PCRE2_JIT_COMPLETE);\n\n  md = pcre2_match_data_create(1, 0);\n  if (md == 0)\n    return -1;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    groupselected = 0;\n\n    for (f = 0; f < groups[g].filecount; ++f)\n    {\n      needed = mbstowcs_escape_invalid(0, groups[g].files[f].file->d_name, 0);\n\n      wcsfilename = (wchar_t*) malloc(needed * sizeof(wchar_t));\n      if (wcsfilename == 0)\n        continue;\n\n      mbstowcs_escape_invalid(wcsfilename, groups[g].files[f].file->d_name, needed);\n\n      matches = pcre2_match(code, (PCRE2_SPTR)wcsfilename, PCRE2_ZERO_TERMINATED, 0, 0, md, 0);\n\n      free(wcsfilename);\n\n      if (matches > 0)\n      {\n        groups[g].selected = 1;\n        groups[g].files[f].selected = 1;\n\n        groupselected = 1;\n        ++selectedfilecount;\n      }\n    }\n\n    if (groupselected)\n      ++selectedgroupcount;\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", selectedfilecount, selectedgroupcount);\n\n  pcre2_code_free(code);\n\n  return 1;\n}\n\n/* clear selections containing string */\nint cmd_clear_selections_containing(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int matchedgroupcount = 0;\n  int matchedfilecount = 0;\n  int groupmatched;\n  int filedeselected;\n  int selectionsremaining;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupmatched = 0;\n      filedeselected = 0;\n      selectionsremaining = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsinmbcs(groups[g].files[f].file->d_name, commandarguments))\n        {\n          if (groups[g].files[f].selected)\n          {\n            groups[g].files[f].selected = 0;\n            filedeselected = 1;\n          }\n\n          groupmatched = 1;\n          ++matchedfilecount;\n        }\n\n        if (groups[g].files[f].selected)\n          selectionsremaining = 1;\n      }\n\n      if (filedeselected && !selectionsremaining)\n        groups[g].selected = 0;\n\n      if (groupmatched)\n        ++matchedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", matchedfilecount, matchedgroupcount);\n\n  return 1;\n}\n\n/* clear selections beginning with string */\nint cmd_clear_selections_beginning(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int matchedgroupcount = 0;\n  int matchedfilecount = 0;\n  int groupmatched;\n  int filedeselected;\n  int selectionsremaining;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupmatched = 0;\n      filedeselected = 0;\n      selectionsremaining = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsbeginmbcs(groups[g].files[f].file->d_name, commandarguments))\n        {\n          if (groups[g].files[f].selected)\n          {\n            groups[g].files[f].selected = 0;\n            filedeselected = 1;\n          }\n\n          groupmatched = 1;\n          ++matchedfilecount;\n        }\n\n        if (groups[g].files[f].selected)\n          selectionsremaining = 1;\n      }\n\n      if (filedeselected && !selectionsremaining)\n        groups[g].selected = 0;\n\n      if (groupmatched)\n        ++matchedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", matchedfilecount, matchedgroupcount);\n\n  return 1;\n}\n\n/* clear selections ending with string */\nint cmd_clear_selections_ending(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int matchedgroupcount = 0;\n  int matchedfilecount = 0;\n  int groupmatched;\n  int filedeselected;\n  int selectionsremaining;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupmatched = 0;\n      filedeselected = 0;\n      selectionsremaining = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsendsmbcs(groups[g].files[f].file->d_name, commandarguments))\n        {\n          if (groups[g].files[f].selected)\n          {\n            groups[g].files[f].selected = 0;\n            filedeselected = 1;\n          }\n\n          groupmatched = 1;\n          ++matchedfilecount;\n        }\n\n        if (groups[g].files[f].selected)\n          selectionsremaining = 1;\n      }\n\n      if (filedeselected && !selectionsremaining)\n        groups[g].selected = 0;\n\n      if (groupmatched)\n        ++matchedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", matchedfilecount, matchedgroupcount);\n\n  return 1;\n}\n\n/* clear selections matching string */\nint cmd_clear_selections_matching(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int matchedgroupcount = 0;\n  int matchedfilecount = 0;\n  int groupmatched;\n  int filedeselected;\n  int selectionsremaining;\n\n  if (wcscmp(commandarguments, L\"\") != 0)\n  {\n    for (g = 0; g < groupcount; ++g)\n    {\n      groupmatched = 0;\n      filedeselected = 0;\n      selectionsremaining = 0;\n\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (wcsmbcscmp(commandarguments, groups[g].files[f].file->d_name) == 0)\n        {\n          if (groups[g].files[f].selected)\n          {\n            groups[g].files[f].selected = 0;\n            filedeselected = 1;\n          }\n\n          groupmatched = 1;\n          ++matchedfilecount;\n        }\n\n        if (groups[g].files[f].selected)\n          selectionsremaining = 1;\n      }\n\n      if (filedeselected && !selectionsremaining)\n        groups[g].selected = 0;\n\n      if (groupmatched)\n        ++matchedgroupcount;\n    }\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", matchedfilecount, matchedgroupcount);\n\n  return 1;\n}\n\n/* clear selection matching pattern */\nint cmd_clear_selections_regex(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  size_t size;\n  wchar_t *wcsfilename;\n  size_t needed;\n  int errorcode;\n  PCRE2_SIZE erroroffset;\n  pcre2_code *code;\n  pcre2_match_data *md;\n  int matches;\n  int g;\n  int f;\n  int matchedgroupcount = 0;\n  int matchedfilecount = 0;\n  int groupmatched;\n  int filedeselected;\n  int selectionsremaining;\n\n  code = pcre2_compile((PCRE2_SPTR)commandarguments, PCRE2_ZERO_TERMINATED, PCRE2_UTF | PCRE2_UCP, &errorcode, &erroroffset, 0);\n\n  if (code == 0)\n    return -1;\n\n  pcre2_jit_compile(code, PCRE2_JIT_COMPLETE);\n\n  md = pcre2_match_data_create(1, 0);\n  if (md == 0)\n    return -1;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    groupmatched = 0;\n    filedeselected = 0;\n    selectionsremaining = 0;\n\n    for (f = 0; f < groups[g].filecount; ++f)\n    {\n      needed = mbstowcs_escape_invalid(0, groups[g].files[f].file->d_name, 0);\n\n      wcsfilename = (wchar_t*) malloc(needed * sizeof(wchar_t));\n      if (wcsfilename == 0)\n        continue;\n\n      mbstowcs_escape_invalid(wcsfilename, groups[g].files[f].file->d_name, needed);\n\n      matches = pcre2_match(code, (PCRE2_SPTR)wcsfilename, PCRE2_ZERO_TERMINATED, 0, 0, md, 0);\n\n      free(wcsfilename);\n\n      if (matches > 0)\n      {\n        if (groups[g].files[f].selected)\n        {\n          groups[g].files[f].selected = 0;\n          filedeselected = 1;\n        }\n\n        groupmatched = 1;\n        ++matchedfilecount;\n      }\n\n      if (groups[g].files[f].selected)\n        selectionsremaining = 1;\n    }\n\n    if (filedeselected && !selectionsremaining)\n      groups[g].selected = 0;\n\n    if (groupmatched)\n      ++matchedgroupcount;\n  }\n\n  format_status_left(status, L\"Matched %d files in %d groups.\", matchedfilecount, matchedgroupcount);\n\n  pcre2_code_free(code);\n\n  return 1;\n}\n\n/* clear all selections and selected groups */\nint cmd_clear_all_selections(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    for (f = 0; f < groups[g].filecount; ++f)\n      groups[g].files[f].selected = 0;\n\n    groups[g].selected = 0;\n  }\n\n  if (status)\n    format_status_left(status, L\"Cleared all selections.\");\n\n  return 1;\n}\n\n/* invert selections within selected groups */\nint cmd_invert_group_selections(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)\n{\n  int g;\n  int f;\n  int selectedcount = 0;\n  int deselectedcount = 0;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    if (groups[g].selected)\n    {\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        groups[g].files[f].selected = !groups[g].files[f].selected;\n\n        if (groups[g].files[f].selected)\n          ++selectedcount;\n        else\n          ++deselectedcount;\n      }\n    }\n  }\n\n  format_status_left(status, L\"Selected %d files. Deselected %d files.\", selectedcount, deselectedcount);\n\n  return 1;\n}\n\n/* mark selected files for preservation */\nint cmd_keep_selected(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, struct status_text *status)\n{\n  int g;\n  int f;\n  int keepfilecount = 0;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    for (f = 0; f < groups[g].filecount; ++f)\n    {\n      if (groups[g].files[f].selected)\n      {\n        set_file_action(&groups[g].files[f], FILEACTION_KEEP, deletiontally);\n        ++keepfilecount;\n      }\n    }\n  }\n\n  format_status_left(status, L\"Marked %d files for preservation.\", keepfilecount);\n\n  return 1;\n}\n\n/* mark selected files for deletion */\nint cmd_delete_selected(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, struct status_text *status)\n{\n  int g;\n  int f;\n  int deletefilecount = 0;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    for (f = 0; f < groups[g].filecount; ++f)\n    {\n      if (groups[g].files[f].selected)\n      {\n        set_file_action(&groups[g].files[f], FILEACTION_DELETE, deletiontally);\n        ++deletefilecount;\n      }\n    }\n  }\n\n  format_status_left(status, L\"Marked %d files for deletion.\", deletefilecount);\n\n  return 1;\n}\n\n/* mark selected files as unresolved */\nint cmd_reset_selected(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, struct status_text *status)\n{\n  int g;\n  int f;\n  int resetfilecount = 0;\n\n  for (g = 0; g < groupcount; ++g)\n  {\n    for (f = 0; f < groups[g].filecount; ++f)\n    {\n      if (groups[g].files[f].selected)\n      {\n        set_file_action(&groups[g].files[f], FILEACTION_UNRESOLVED, deletiontally);\n        ++resetfilecount;\n      }\n    }\n  }\n\n  format_status_left(status, L\"Unmarked %d files.\", resetfilecount);\n\n  return 1;\n}\n\nint filerowcount(file_t *file, const int columns, int group_file_count);\n\n/* delete files tagged for deletion, delist sets with no untagged files */\nint cmd_prune(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, int *totalgroups, int *cursorgroup, int *cursorfile, int *topline, char *logfile, WINDOW *filewin, WINDOW *statuswin, struct status_text *status)\n{\n  int deletecount;\n  int preservecount;\n  int unresolvedcount;\n  int totaldeleted = 0;\n  int totalfailed = 0;\n  int cursordecrement = 0;\n  double deletedbytes = 0;\n  struct log_info *loginfo;\n  int g;\n  int f;\n  int to;\n  int adjusttopline;\n  int toplineoffset;\n  int groupfirstline;\n  FILE *file1;\n  FILE *file2;\n  int ismatch;\n  wchar_t *statuscopy;\n  struct groupfile *firstnotdeleted;\n  char *deletepath;\n\n  if (logfile != 0)\n    loginfo = log_open(logfile, 0);\n  else\n    loginfo = 0;\n\n  for (g = 0; g < *totalgroups; ++g)\n  {\n    preservecount = 0;\n    deletecount = 0;\n    unresolvedcount = 0;\n    firstnotdeleted = 0;\n\n    for (f = 0; f < groups[g].filecount; ++f)\n    {\n      switch (groups[g].files[f].action)\n      {\n        case FILEACTION_DELETE:\n          ++deletecount;\n          break;\n\n        case FILEACTION_UNRESOLVED:\n        case FILEACTION_ERROR:\n          ++unresolvedcount;\n\n          if (firstnotdeleted == 0)\n            firstnotdeleted = &groups[g].files[f];\n\n          break;\n\n        case FILEACTION_KEEP:\n          ++preservecount;\n\n          if (firstnotdeleted == 0)\n            firstnotdeleted = &groups[g].files[f];\n\n          break;\n      }\n    }\n\n    if (loginfo)\n      log_begin_set(loginfo);\n\n#ifndef NO_SQLITE\n    hashdb_begintransaction(db);\n#endif\n\n    /* delete files marked for deletion unless no files left undeleted */\n    if (deletecount < groups[g].filecount)\n    {\n      for (f = 0; f < groups[g].filecount; ++f)\n      {\n        if (groups[g].files[f].action == FILEACTION_DELETE)\n        {\n          if (ISFLAG(flags, F_DEFERCONFIRMATION))\n          {\n            format_status_left(status, L\"Confirming duplicates...\");\n            print_status(statuswin, status);\n            wrefresh(statuswin);\n\n            file1 = fopen(groups[g].files[f].file->d_name, \"rb\");\n            file2 = fopen(firstnotdeleted->file->d_name, \"rb\");\n\n            if (file1 && file2)\n              ismatch = confirmmatch(file1, file2);\n            else\n              ismatch = 0;\n\n            if (file2)\n              fclose(file2);\n\n            if (file1)\n              fclose(file1);\n          }\n          else\n          {\n            ismatch = 1;\n          }\n\n#ifndef NO_SQLITE\n          if (ismatch && db)\n          {\n            deletepath = getrealpath(groups[g].files[f].file->d_name, GETREALPATH_IGNORE_MISSING_BASENAME);\n            if (deletepath != 0)\n            {\n              if (!ISFLAG(flags, F_READONLYCACHE))\n                hashdb_deletehashforpath(db, deletepath);\n\n              free(deletepath);\n            }\n          }\n#endif\n\n          if (ismatch && removeifnotchanged(groups[g].files[f].file, 0) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;\n\n            if (loginfo)\n              log_file_deleted(loginfo, groups[g].files[f].file->d_name);\n          }\n          else\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_ERROR, deletiontally);\n            unresolvedcount++;\n            totalfailed++;\n          }\n        }\n      }\n\n      if (loginfo)\n      {\n        for (f = 0; f < groups[g].filecount; ++f)\n        {\n          if (groups[g].files[f].action != FILEACTION_DELETE &&\n              groups[g].files[f].action != FILEACTION_DELIST)\n            log_file_remaining(loginfo, groups[g].files[f].file->d_name);\n        }\n      }\n\n      deletecount = 0;\n    }\n\n#ifndef NO_SQLITE\n    hashdb_committransaction(db);\n#endif\n\n    if (loginfo)\n      log_end_set(loginfo);\n\n    /* if no files left unresolved, mark preserved files for delisting */\n    if (unresolvedcount == 0)\n    {\n      for (f = 0; f < groups[g].filecount; ++f)\n        if (groups[g].files[f].action == FILEACTION_KEEP)\n          set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n      preservecount = 0;\n    }\n    /* if only one file left unresolved, mark it for delesting */\n    else if (unresolvedcount == 1 && preservecount + deletecount == 0)\n    {\n      for (f = 0; f < groups[g].filecount; ++f)\n        if (groups[g].files[f].action == FILEACTION_UNRESOLVED || groups[g].files[f].action == FILEACTION_ERROR)\n          set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n    }\n\n    /* delist any files marked for delisting */\n    to = 0;\n    for (f = 0; f < groups[g].filecount; ++f)\n      if (groups[g].files[f].action != FILEACTION_DELIST)\n        groups[g].files[to++] = groups[g].files[f];\n\n    groups[g].filecount = to;\n\n    /* reposition cursor, if necessary */\n    if (*cursorgroup == g && *cursorfile > 0 && *cursorfile >= groups[g].filecount)\n      *cursorfile = groups[g].filecount - 1;\n  }\n\n  if (loginfo != 0)\n    log_close(loginfo);\n\n  if (deletedbytes < 1000.0)\n    format_status_left(status, L\"Deleted %ld files (occupying %.0f bytes)%c\", totaldeleted, deletedbytes, totalfailed ? ';' : '.');\n  else if (deletedbytes <= (1000.0 * 1000.0))\n    format_status_left(status, L\"Deleted %ld files (occupying %.1f KB)%c\", totaldeleted, deletedbytes / 1000.0, totalfailed ? ';' : '.');\n  else if (deletedbytes <= (1000.0 * 1000.0 * 1000.0))\n    format_status_left(status, L\"Deleted %ld files (occupying %.1f MB)%c\", totaldeleted, deletedbytes / (1000.0 * 1000.0), totalfailed ? ';' : '.');\n  else\n    format_status_left(status, L\"Deleted %ld files (occupying %.1f GB)%c\", totaldeleted, deletedbytes / (1000.0 * 1000.0 * 1000.0), totalfailed ? ';' : '.');\n\n  if (totalfailed > 0)\n  {\n    statuscopy = malloc(sizeof(wchar_t) * (wcslen(status->left) + 1));\n    if (!statuscopy)\n    {\n      endwin();\n      errormsg(\"out of memory\\n\");\n      exit(1);\n    }\n\n    wcsncpy(statuscopy, status->left, wcslen(status->left) + 1);\n\n    format_status_left(status, L\"%S %d failed.\", statuscopy, totalfailed);\n\n    free(statuscopy);\n  }\n\n  /* delist empty groups */\n  to = 0;\n  for (g = 0; g < *totalgroups; ++g)\n  {\n    if (groups[g].filecount > 0)\n    {\n      groups[to] = groups[g];\n\n      ++to;\n    }\n    else\n    {\n      /* reset cursor position within group if current group has been deleted */\n      if (g == *cursorgroup)\n        *cursorfile = 0;\n\n      else\n\n      /* decrement cursor if deleted group precedes current group */\n      if (g < *cursorgroup)\n        ++cursordecrement;\n\n      free(groups[g].files);\n    }\n  }\n\n  *totalgroups = to;\n\n  /* update cursor position */\n  *cursorgroup -= cursordecrement;\n\n  if (*totalgroups == 0)\n    *cursorgroup = 0;\n  else if (*cursorgroup >= *totalgroups)\n    *cursorgroup = *totalgroups - 1;\n\n  /* recalculate line boundaries */\n  adjusttopline = 1;\n  toplineoffset = 0;\n  groupfirstline = 0;\n\n  for (g = 0; g < *totalgroups; ++g)\n  {\n    if (adjusttopline && groups[g].endline >= *topline)\n      toplineoffset = groups[g].endline - *topline;\n\n    groups[g].startline = groupfirstline;\n    groups[g].endline = groupfirstline + 2;\n\n    for (f = 0; f < groups[g].filecount; ++f)\n      groups[g].endline += filerowcount(groups[g].files[f].file, COLS, groups[g].filecount);\n\n    if (adjusttopline && toplineoffset > 0)\n    {\n      *topline = groups[g].endline - toplineoffset;\n\n      if (*topline < 0)\n        *topline = 0;\n\n      adjusttopline = 0;\n    }\n\n    groupfirstline = groups[g].endline + 1;\n  }\n\n  if (*totalgroups > 0 && groups[*totalgroups-1].endline <= *topline)\n  {\n    *topline = groups[*totalgroups-1].endline - getmaxy(filewin) + 1;\n\n    if (*topline < 0)\n      *topline = 0;\n  }\n\n  return cmd_clear_all_selections(groups, *totalgroups, commandarguments, 0);\n}\n"
        },
        {
          "name": "ncurses-commands.h",
          "type": "blob",
          "size": 4.287109375,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef NCURSESCOMMANDS_H\n#define NCURSESCOMMANDS_H\n\n#include \"commandidentifier.h\"\n#include \"filegroup.h\"\n\n/* command IDs */\n#define COMMAND_SELECT_CONTAINING 1\n#define COMMAND_SELECT_BEGINNING 2\n#define COMMAND_SELECT_ENDING 3\n#define COMMAND_SELECT_MATCHING 4\n#define COMMAND_CLEAR_SELECTIONS_CONTAINING 5\n#define COMMAND_CLEAR_SELECTIONS_BEGINNING 6\n#define COMMAND_CLEAR_SELECTIONS_ENDING 7\n#define COMMAND_CLEAR_SELECTIONS_MATCHING 8\n#define COMMAND_CLEAR_ALL_SELECTIONS 9\n#define COMMAND_INVERT_GROUP_SELECTIONS 10\n#define COMMAND_KEEP_SELECTED 11\n#define COMMAND_DELETE_SELECTED 12\n#define COMMAND_RESET_SELECTED 13\n#define COMMAND_RESET_GROUP 14\n#define COMMAND_PRESERVE_ALL 15\n#define COMMAND_EXIT 16\n#define COMMAND_HELP 17\n#define COMMAND_YES 18\n#define COMMAND_NO 19\n#define COMMAND_SELECT_REGEX 20\n#define COMMAND_CLEAR_SELECTIONS_REGEX 21\n#define COMMAND_GOTO_SET 22\n#define COMMAND_PRUNE 23\n\nextern struct command_map command_list[];\nextern struct command_map confirmation_keyword_list[];\n\nstruct filegroup;\nstruct status_text;\n\nint cmd_select_containing(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_select_beginning(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_select_ending(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_select_matching(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_select_regex(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_clear_selections_containing(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_clear_selections_beginning(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_clear_selections_ending(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_clear_selections_matching(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_clear_selections_regex(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_clear_all_selections(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_invert_group_selections(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status);\nint cmd_keep_selected(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, struct status_text *status);\nint cmd_delete_selected(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, struct status_text *status);\nint cmd_reset_selected(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, struct status_text *status);\nint cmd_prune(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, int *totalgroups, int *cursorgroup, int *cursorfile, int *topline, char *logfile, WINDOW *filewin, WINDOW *statuswin, struct status_text *status);;\n\n#endif"
        },
        {
          "name": "ncurses-getcommand.c",
          "type": "blob",
          "size": 6.11328125,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <stdlib.h>\n#include <signal.h>\n#include <wctype.h>\n#include \"ncurses-getcommand.h\"\n\n#define KEY_ESCAPE 27\n\nextern volatile sig_atomic_t got_sigint;\n\n/* get command and arguments from user input */\nvoid get_command_arguments(wchar_t **arguments, wchar_t *input)\n{\n  size_t l;\n  size_t x;\n\n  l = wcslen(input);\n\n  for (x = 0; x < l; ++x)\n    if (input[x] == L' ')\n      break;\n\n  if (input[x] == L' ')\n    *arguments = input + x + 1;\n  else\n    *arguments = input + x;\n}\n\nint get_command_text(wchar_t **commandbuffer, size_t *commandbuffersize, WINDOW *promptwin, struct prompt_info *prompt, int cancel_on_erase, int append)\n{\n  int docommandinput;\n  int keyresult;\n  wint_t wch;\n  wint_t oldch;\n  size_t length;\n  size_t newsize;\n  wchar_t *realloccommandbuffer;\n  size_t c;\n\n  set_prompt_active_state(prompt, 1);\n  wrefresh(promptwin);\n\n  if (*commandbuffer == 0)\n  {\n    *commandbuffersize = 80;\n    *commandbuffer = malloc(*commandbuffersize * sizeof(wchar_t));\n    if (*commandbuffer == 0)\n    {\n      set_prompt_active_state(prompt, 0);\n      return GET_COMMAND_ERROR_OUT_OF_MEMORY;\n    }\n  }\n\n  if (!append)\n  {\n    (*commandbuffer)[0] = L'\\0';\n  }\n  else\n  {\n    print_prompt(promptwin, prompt, *commandbuffer);\n\n    prompt->cursor = wcswidth(*commandbuffer, wcslen(*commandbuffer));\n\n    wmove(promptwin, 0, wcslen(prompt->text) + prompt->cursor - prompt->offset);\n\n    wrefresh(promptwin);\n  }\n\n  docommandinput = 1;\n  do\n  {\n    do\n    {\n      keyresult = wget_wch(promptwin, &wch);\n\n      if (got_sigint)\n      {\n        got_sigint = 0;\n\n        (*commandbuffer)[0] = '\\0';\n\n        set_prompt_active_state(prompt, 0);\n\n        return GET_COMMAND_CANCELED;\n      }\n    } while (keyresult == ERR);\n\n    if (keyresult == OK)\n    {\n      switch (wch)\n      {\n        case KEY_ESCAPE:\n          prompt->offset = 0;\n          prompt->cursor = 0;\n          docommandinput = 0;\n\n          (*commandbuffer)[0] = '\\0';\n\n          set_prompt_active_state(prompt, 0);\n\n          return GET_COMMAND_CANCELED;\n\n        case '\\n':\n          prompt->offset = 0;\n          prompt->cursor = 0;\n          docommandinput = 0;\n          continue;\n\n        case '\\t':\n          continue;\n\n        default:\n          if (!iswprint(wch))\n            continue;\n\n          length = wcslen(*commandbuffer);\n\n          if (length + 1 >= *commandbuffersize)\n          {\n            newsize = *commandbuffersize * 2;\n\n            realloccommandbuffer = (wchar_t*)realloc(*commandbuffer, newsize * sizeof(wchar_t));\n            if (realloccommandbuffer == 0)\n            {\n              set_prompt_active_state(prompt, 0);\n              return GET_COMMAND_ERROR_OUT_OF_MEMORY;\n            }\n\n            *commandbuffer = realloccommandbuffer;\n            *commandbuffersize = newsize;\n          }\n\n          for (c = length + 1; c >= prompt->cursor + 1; --c)\n            (*commandbuffer)[c] = (*commandbuffer)[c-1];\n\n          (*commandbuffer)[prompt->cursor] = wch;\n\n          set_prompt_active_state(prompt, 1);\n\n          update_prompt(promptwin, prompt, *commandbuffer, wcwidth(wch));\n\n          break;\n      }\n    }\n    else if (keyresult == KEY_CODE_YES)\n    {\n      switch (wch)\n      {\n        case KEY_BACKSPACE:\n          length = wcslen(*commandbuffer);\n\n          if (length == 0)\n          {\n            set_prompt_active_state(prompt, 0);\n\n            if (cancel_on_erase)\n              return GET_COMMAND_CANCELED;\n          }\n\n          oldch = (*commandbuffer)[prompt->cursor];\n\n          if (prompt->cursor > 0)\n            for (c = prompt->cursor; c <= length; ++c)\n              (*commandbuffer)[c-1] = (*commandbuffer)[c];\n\n          update_prompt(promptwin, prompt, *commandbuffer, oldch != 0 ? -wcwidth(oldch) : -1);\n\n          break;\n\n        case KEY_DC:\n          length = wcslen(*commandbuffer);\n\n          if (prompt->cursor < length)\n            for (c = prompt->cursor; c <= length; ++c)\n              (*commandbuffer)[c] = (*commandbuffer)[c+1];\n\n          break;\n\n        case KEY_LEFT:\n          length = wcslen(*commandbuffer);\n\n          oldch = (*commandbuffer)[prompt->cursor];\n\n          update_prompt(promptwin, prompt, *commandbuffer, oldch != 0 ? -wcwidth(oldch) : -1);\n\n          break;\n\n        case KEY_RIGHT:\n          length = wcslen(*commandbuffer);\n\n          oldch = (*commandbuffer)[prompt->cursor];\n\n          if (prompt->cursor + wcwidth((*commandbuffer)[prompt->cursor]) <= length)\n            update_prompt(promptwin, prompt, *commandbuffer, wcwidth(oldch));\n\n          break;\n\n        case KEY_NPAGE:\n          return GET_COMMAND_KEY_NPAGE;\n\n        case KEY_PPAGE:\n          return GET_COMMAND_KEY_PPAGE;\n\n        case KEY_SF:\n          return GET_COMMAND_KEY_SF;\n\n        case KEY_SR:\n          return GET_COMMAND_KEY_SR;\n\n        case KEY_RESIZE:\n          return GET_COMMAND_RESIZE_REQUESTED;\n      }\n    }\n\n    print_prompt(promptwin, prompt, *commandbuffer);\n\n    wmove(promptwin, 0, wcslen(prompt->text) + prompt->cursor - prompt->offset);\n\n    wrefresh(promptwin);\n  } while (docommandinput);\n\n  set_prompt_active_state(prompt, 0);\n\n  return GET_COMMAND_OK;\n}"
        },
        {
          "name": "ncurses-getcommand.h",
          "type": "blob",
          "size": 1.7734375,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef NCURSESGETCOMMAND_H\n#define NCURSESGETCOMMAND_H\n\n#include <wchar.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n  #include <ncursesw/curses.h>\n#else\n  #include <curses.h>\n#endif\n#include \"ncurses-prompt.h\"\n\n#define GET_COMMAND_OK 1\n#define GET_COMMAND_CANCELED 2\n#define GET_COMMAND_ERROR_OUT_OF_MEMORY 3\n#define GET_COMMAND_RESIZE_REQUESTED 4\n#define GET_COMMAND_KEY_NPAGE 5\n#define GET_COMMAND_KEY_PPAGE 6\n#define GET_COMMAND_KEY_SF 7\n#define GET_COMMAND_KEY_SR 8\n\nvoid get_command_arguments(wchar_t **arguments, wchar_t *input);\nint get_command_text(wchar_t **commandbuffer, size_t *commandbuffersize, WINDOW *promptwin, struct prompt_info *prompt, int cancel_on_erase, int append);\n\n#endif"
        },
        {
          "name": "ncurses-interface.c",
          "type": "blob",
          "size": 36.962890625,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <wchar.h>\n#include <wctype.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n  #include <ncursesw/curses.h>\n#else\n  #include <curses.h>\n#endif\n#include \"ncurses-interface.h\"\n#include \"ncurses-getcommand.h\"\n#include \"ncurses-commands.h\"\n#include \"ncurses-prompt.h\"\n#include \"ncurses-status.h\"\n#include \"ncurses-print.h\"\n#include \"fileaction.h\"\n#include \"mbstowcs_escape_invalid.h\"\n#include \"positive_wcwidth.h\"\n#include \"commandidentifier.h\"\n#include \"filegroup.h\"\n#include \"errormsg.h\"\n#include \"log.h\"\n#include \"sigint.h\"\n#include \"flags.h\"\n\nchar *fmttime(time_t t);\n\nenum linestyle\n{\n  linestyle_groupheader = 0,\n  linestyle_groupheaderspacing,\n  linestyle_filename,\n  linestyle_groupfooterspacing\n};\n\nenum linestyle getlinestyle(struct filegroup *group, int line)\n{\n  if (line <= group->startline)\n    return linestyle_groupheader;\n  else if (line == group->startline + 1)\n    return linestyle_groupheaderspacing;\n  else if (line >= group->endline)\n    return linestyle_groupfooterspacing;\n  else\n    return linestyle_filename;\n}\n\n#define FILENAME_INDENT_EXTRA 5\n#define FILE_INDEX_MIN_WIDTH 3\n\nint filerowcount(file_t *file, const int columns, int group_file_count)\n{\n  int lines;\n  int line_remaining;\n  size_t x = 0;\n  size_t read;\n  size_t filename_bytes;\n  wchar_t ch;\n  mbstate_t mbstate;\n  int index_width;\n  int timestamp_width;\n  size_t needed;\n  wchar_t *wcfilename;\n\n  memset(&mbstate, 0, sizeof(mbstate));\n\n  needed = mbstowcs_escape_invalid(0, file->d_name, 0);\n\n  wcfilename = (wchar_t*)malloc(sizeof(wchar_t) * needed);\n  if (wcfilename == 0)\n    return 0;\n\n  mbstowcs_escape_invalid(wcfilename, file->d_name, needed);\n\n  index_width = get_num_digits(group_file_count);\n  if (index_width < FILE_INDEX_MIN_WIDTH)\n    index_width = FILE_INDEX_MIN_WIDTH;\n\n  timestamp_width = ISFLAG(flags, F_SHOWTIME) ? 19 : 0;\n\n  lines = (index_width + timestamp_width + FILENAME_INDENT_EXTRA) / columns + 1;\n\n  line_remaining = columns - (index_width + timestamp_width + FILENAME_INDENT_EXTRA) % columns;\n\n  while (wcfilename[x] != L'\\0')\n  {\n    if (positive_wcwidth(wcfilename[x]) <= line_remaining)\n    {\n      line_remaining -= positive_wcwidth(wcfilename[x]);\n    }\n    else\n    {\n      line_remaining = columns - positive_wcwidth(wcfilename[x]);\n      ++lines;\n    }\n\n    ++x;\n  }\n\n  free(wcfilename);\n\n  return lines;\n}\n\nint getgroupindex(struct filegroup *groups, int group_count, int group_hint, int line)\n{\n  int group = group_hint;\n\n  while (group > 0 && line < groups[group].startline)\n    --group;\n\n  while (group < group_count && line > groups[group].endline)\n    ++group;\n\n  return group;\n}\n\nint getgroupfileindex(int *row, struct filegroup *group, int line, int columns)\n{\n  int l;\n  int f = 0;\n  int rowcount;\n\n  l = group->startline + 2;\n\n  while (f < group->filecount)\n  {\n    rowcount = filerowcount(group->files[f].file, columns, group->filecount);\n\n    if (line <= l + rowcount - 1)\n    {\n      *row = line - l;\n      return f;\n    }\n\n    l += rowcount;\n    ++f;\n  }\n\n  return -1;\n}\n\nint getgroupfileline(struct filegroup *group, int fileindex, int columns)\n{\n  int l;\n  int f = 0;\n  int rowcount;\n\n  l = group->startline + 2;\n\n  while (f < fileindex && f < group->filecount)\n  {\n    rowcount = filerowcount(group->files[f].file, columns, group->filecount);\n    l += rowcount;\n    ++f;\n  }\n\n  return l;\n}\n\nvoid set_file_action(struct groupfile *file, int new_action, size_t *deletion_tally)\n{\n  switch (file->action)\n  {\n    case FILEACTION_DELETE:\n      if (new_action != FILEACTION_DELETE)\n        --*deletion_tally;\n      break;\n\n    default:\n      if (new_action == FILEACTION_DELETE)\n        ++*deletion_tally;\n      break;\n  }\n\n  file->action = new_action;\n}\n\nvoid scroll_to_group(int *topline, int group, int tail, struct filegroup *groups, WINDOW *filewin)\n{\n  if (*topline < groups[group].startline)\n  {\n    if (groups[group].endline >= *topline + getmaxy(filewin))\n    {\n      if (groups[group].endline - groups[group].startline < getmaxy(filewin))\n        *topline = groups[group].endline - getmaxy(filewin) + 1;\n      else\n        *topline = groups[group].startline;\n    }\n  }\n  else\n  {\n    if (groups[group].endline - groups[group].startline < getmaxy(filewin) || !tail)\n      *topline = groups[group].startline;\n    else\n      *topline = groups[group].endline - getmaxy(filewin);\n  }\n}\n\nvoid move_to_next_group(int *topline, int *cursorgroup, int *cursorfile, struct filegroup *groups, WINDOW *filewin)\n{\n  *cursorgroup += 1;\n\n  *cursorfile = 0;\n\n  scroll_to_group(topline, *cursorgroup, 0, groups, filewin);\n}\n\nint move_to_next_selected_group(int *topline, int *cursorgroup, int *cursorfile, struct filegroup *groups, int totalgroups, WINDOW *filewin)\n{\n  size_t g;\n\n  for (g = *cursorgroup + 1; g < totalgroups; ++g)\n  {\n    if (groups[g].selected)\n    {\n      *cursorgroup = g;\n      *cursorfile = 0;\n\n      scroll_to_group(topline, *cursorgroup, 0, groups, filewin);\n\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nvoid move_to_next_file(int *topline, int *cursorgroup, int *cursorfile, struct filegroup *groups, WINDOW *filewin)\n{\n  *cursorfile += 1;\n\n  if (getgroupfileline(&groups[*cursorgroup], *cursorfile, COLS) >= *topline + getmaxy(filewin))\n  {\n      if (groups[*cursorgroup].endline - getgroupfileline(&groups[*cursorgroup], *cursorfile, COLS) < getmaxy(filewin))\n        *topline = groups[*cursorgroup].endline - getmaxy(filewin) + 1;\n      else\n        *topline = getgroupfileline(&groups[*cursorgroup], *cursorfile, COLS);\n  }\n}\n\nvoid move_to_previous_group(int *topline, int *cursorgroup, int *cursorfile, struct filegroup *groups, WINDOW *filewin)\n{\n  *cursorgroup -= 1;\n\n  *cursorfile = groups[*cursorgroup].filecount - 1;\n\n  scroll_to_group(topline, *cursorgroup, 1, groups, filewin);\n}\n\nint move_to_previous_selected_group(int *topline, int *cursorgroup, int *cursorfile, struct filegroup *groups, int totalgroups, WINDOW *filewin)\n{\n  size_t g;\n\n  for (g = *cursorgroup; g > 0; --g)\n  {\n    if (groups[g - 1].selected)\n    {\n      *cursorgroup = g - 1;\n      *cursorfile = 0;\n\n      scroll_to_group(topline, *cursorgroup, 0, groups, filewin);\n\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nvoid move_to_previous_file(int *topline, int *cursorgroup, int *cursorfile, struct filegroup *groups, WINDOW *filewin)\n{\n  *cursorfile -= 1;\n\n  if (getgroupfileline(&groups[*cursorgroup], *cursorfile, COLS) < *topline)\n  {\n      if (getgroupfileline(&groups[*cursorgroup], *cursorfile, COLS) - groups[*cursorgroup].startline < getmaxy(filewin))\n        *topline -= getgroupfileline(&groups[*cursorgroup], *cursorfile, COLS) - groups[*cursorgroup].startline + 1;\n      else\n        *topline -= getmaxy(filewin);\n  }\n}\n\n#define FILE_LIST_OK 1\n#define FILE_LIST_ERROR_INDEX_OUT_OF_RANGE -1\n#define FILE_LIST_ERROR_LIST_CONTAINS_INVALID_INDEX -2\n#define FILE_LIST_ERROR_UNKNOWN_COMMAND -3\n#define FILE_LIST_ERROR_OUT_OF_MEMORY -4\n\nint validate_file_list(struct filegroup *currentgroup, wchar_t *commandbuffer_in)\n{\n  wchar_t *commandbuffer;\n  wchar_t *token;\n  wchar_t *wcsptr;\n  wchar_t *wcstolcheck;\n  long int number;\n  int parts = 0;\n  int parse_error = 0;\n  int out_of_bounds_error = 0;\n\n  commandbuffer = malloc(sizeof(wchar_t) * (wcslen(commandbuffer_in)+1));\n  if (commandbuffer == 0)\n    return FILE_LIST_ERROR_OUT_OF_MEMORY;\n\n  wcscpy(commandbuffer, commandbuffer_in);\n\n  token = wcstok(commandbuffer, L\",\", &wcsptr);\n\n  while (token != NULL)\n  {\n    ++parts;\n\n    number = wcstol(token, &wcstolcheck, 10);\n    if (wcstolcheck == token || *wcstolcheck != '\\0')\n      parse_error = 1;\n\n    if (number > currentgroup->filecount || number < 1)\n      out_of_bounds_error = 1;\n\n    token = wcstok(NULL, L\",\", &wcsptr);\n  }\n\n  free(commandbuffer);\n\n  if (parts == 1 && parse_error)\n    return FILE_LIST_ERROR_UNKNOWN_COMMAND;\n  else if (parse_error)\n    return FILE_LIST_ERROR_LIST_CONTAINS_INVALID_INDEX;\n  else if (out_of_bounds_error)\n    return FILE_LIST_ERROR_INDEX_OUT_OF_RANGE;\n\n  return FILE_LIST_OK;\n}\n\nvoid deletefiles_ncurses(file_t *files, char *logfile)\n{\n  WINDOW *filewin;\n  WINDOW *promptwin;\n  WINDOW *statuswin;\n  file_t *curfile;\n  file_t *dupefile;\n  struct filegroup *groups;\n  struct filegroup *reallocgroups;\n  size_t groupfilecount;\n  int topline = 0;\n  int cursorgroup = 0;\n  int cursorfile = 0;\n  int cursor_x;\n  int cursor_y;\n  int groupfirstline = 0;\n  int totallines = 0;\n  int allocatedgroups = 0;\n  int totalgroups = 0;\n  size_t groupindex = 0;\n  enum linestyle linestyle;\n  int preservecount;\n  int deletecount;\n  int unresolvedcount;\n  size_t globaldeletiontally = 0;\n  int row;\n  int x;\n  int g;\n  wint_t wch;\n  int keyresult;\n  int cy;\n  int f;\n  wchar_t *commandbuffer;\n  size_t commandbuffersize;\n  wchar_t *commandarguments;\n  struct command_identifier_node *commandidentifier;\n  struct command_identifier_node *confirmationkeywordidentifier;\n  int doprune;\n  wchar_t *token;\n  wchar_t *wcsptr;\n  wchar_t *wcstolcheck;\n  long int number;\n  struct status_text *status;\n  struct prompt_info *prompt;\n  int dupesfound;\n  int intresult;\n  int resumecommandinput = 0;\n  int index_width;\n  int timestamp_width;\n\n  noecho();\n  cbreak();\n  halfdelay(5);\n\n  filewin = newwin(LINES - 2, COLS, 0, 0);\n  statuswin = newwin(1, COLS, LINES - 1, 0);\n  promptwin = newwin(1, COLS, LINES - 2, 0);\n\n  scrollok(filewin, FALSE);\n  scrollok(statuswin, FALSE);\n  scrollok(promptwin, FALSE);\n\n  wattron(statuswin, A_REVERSE);\n\n  keypad(promptwin, 1);\n\n  commandbuffersize = 80;\n  commandbuffer = malloc(commandbuffersize * sizeof(wchar_t));\n  if (commandbuffer == 0)\n  {\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  allocatedgroups = 1024;\n  groups = malloc(sizeof(struct filegroup) * allocatedgroups);\n  if (groups == 0)\n  {\n    free(commandbuffer);\n\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  commandidentifier = build_command_identifier_tree(command_list);\n  if (commandidentifier == 0)\n  {\n    free(groups);\n    free(commandbuffer);\n\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  confirmationkeywordidentifier = build_command_identifier_tree(confirmation_keyword_list);\n  if (confirmationkeywordidentifier == 0)\n  {\n    free(groups);\n    free(commandbuffer);\n    free_command_identifier_tree(commandidentifier);\n\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  curfile = files;\n  while (curfile)\n  {\n    if (!curfile->hasdupes)\n    {\n      curfile = curfile->next;\n      continue;\n    }\n\n    if (totalgroups + 1 > allocatedgroups)\n    {\n      allocatedgroups *= 2;\n\n      reallocgroups = realloc(groups, sizeof(struct filegroup) * allocatedgroups);\n      if (reallocgroups == 0)\n      {\n        for (g = 0; g < totalgroups; ++g)\n          free(groups[g].files);\n\n        free(groups);\n        free(commandbuffer);\n        free_command_identifier_tree(commandidentifier);\n        free_command_identifier_tree(confirmationkeywordidentifier);\n\n        endwin();\n        errormsg(\"out of memory\\n\");\n        exit(1);\n      }\n\n      groups = reallocgroups;\n    }\n\n    groups[totalgroups].startline = groupfirstline;\n    groups[totalgroups].endline = groupfirstline + 2;\n    groups[totalgroups].selected = 0;\n\n    groupfilecount = 0;\n\n    dupefile = curfile;\n    do\n    {\n      ++groupfilecount;\n\n      dupefile = dupefile->duplicates;\n    } while(dupefile);\n\n    dupefile = curfile;\n    do\n    {\n      groups[totalgroups].endline += filerowcount(dupefile, COLS, groupfilecount);\n\n      dupefile = dupefile->duplicates;\n    } while (dupefile);\n\n    groups[totalgroups].files = malloc(sizeof(struct groupfile) * groupfilecount);\n    if (groups[totalgroups].files == 0)\n    {\n      for (g = 0; g < totalgroups; ++g)\n        free(groups[g].files);\n\n      free(groups);\n      free(commandbuffer);\n      free_command_identifier_tree(commandidentifier);\n      free_command_identifier_tree(confirmationkeywordidentifier);\n\n      endwin();\n      errormsg(\"out of memory\\n\");\n      exit(1);\n    }\n\n    groupfilecount = 0;\n\n    dupefile = curfile;\n    do\n    {\n      groups[totalgroups].files[groupfilecount].file = dupefile;\n      groups[totalgroups].files[groupfilecount].action = FILEACTION_UNRESOLVED;\n      groups[totalgroups].files[groupfilecount].selected = 0;\n      ++groupfilecount;\n\n      dupefile = dupefile->duplicates;\n    } while (dupefile);\n\n    groups[totalgroups].filecount = groupfilecount;\n\n    groupfirstline = groups[totalgroups].endline + 1;\n\n    ++totalgroups;\n\n    curfile = curfile->next;\n  }\n\n  dupesfound = totalgroups > 0;\n\n  status = status_text_alloc(0, COLS);\n  if (status == 0)\n  {\n    for (g = 0; g < totalgroups; ++g)\n      free(groups[g].files);\n\n    free(groups);\n    free(commandbuffer);\n    free_command_identifier_tree(commandidentifier);\n    free_command_identifier_tree(confirmationkeywordidentifier);\n\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  format_status_left(status, L\"Ready\");\n\n  prompt = prompt_info_alloc(80);\n  if (prompt == 0)\n  {\n    free_status_text(status);\n\n    for (g = 0; g < totalgroups; ++g)\n      free(groups[g].files);\n\n    free(groups);\n    free(commandbuffer);\n    free_command_identifier_tree(commandidentifier);\n    free_command_identifier_tree(confirmationkeywordidentifier);\n\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  doprune = 1;\n  do\n  {\n    wmove(filewin, 0, 0);\n    werase(filewin);\n\n    if (totalgroups > 0)\n      totallines = groups[totalgroups-1].endline;\n    else\n      totallines = 0;\n\n    for (x = topline; x < topline + getmaxy(filewin); ++x)\n    {\n      if (x >= totallines)\n      {\n        wclrtoeol(filewin);\n        continue;\n      }\n\n      groupindex = getgroupindex(groups, totalgroups, groupindex, x);\n\n      index_width = get_num_digits(groups[groupindex].filecount);\n\n      if (index_width < FILE_INDEX_MIN_WIDTH)\n        index_width = FILE_INDEX_MIN_WIDTH;\n\n      timestamp_width = ISFLAG(flags, F_SHOWTIME) ? 19 : 0;\n\n      linestyle = getlinestyle(groups + groupindex, x);\n      \n      if (linestyle == linestyle_groupheader)\n      {\n        wattron(filewin, A_BOLD);\n        if (groups[groupindex].selected)\n          wattron(filewin, A_REVERSE);\n        wprintw(filewin, \"Set %d of %d:\\n\", groupindex + 1, totalgroups);\n        if (groups[groupindex].selected)\n          wattroff(filewin, A_REVERSE);\n        wattroff(filewin, A_BOLD);\n      }\n      else if (linestyle == linestyle_groupheaderspacing)\n      {\n        wprintw(filewin, \"\\n\");\n      }\n      else if (linestyle == linestyle_filename)\n      {\n        f = getgroupfileindex(&row, groups + groupindex, x, COLS);\n\n        if (cursorgroup != groupindex)\n        {\n          if (row == 0)\n          {\n            print_spaces(filewin, index_width);\n\n            wprintw(filewin, \" [%c] \", getfileactionchar(groups[groupindex].files[f].action));\n\n            if (ISFLAG(flags, F_SHOWTIME))\n              wprintw(filewin, \"[%s] \", fmttime(groups[groupindex].files[f].file->mtime));\n          }\n\n          cy = getcury(filewin);\n\n          if (groups[groupindex].files[f].selected)\n            wattron(filewin, A_REVERSE);\n          putline(filewin, groups[groupindex].files[f].file->d_name, row, COLS, index_width + timestamp_width + FILENAME_INDENT_EXTRA);\n          if (groups[groupindex].files[f].selected)\n            wattroff(filewin, A_REVERSE);\n\n          wclrtoeol(filewin);\n          wmove(filewin, cy+1, 0);\n        }\n        else\n        {\n          if (row == 0)\n          {\n            print_right_justified_int(filewin, f+1, index_width);\n            wprintw(filewin, \" \");\n\n            if (cursorgroup == groupindex && cursorfile == f)\n              wattron(filewin, A_REVERSE);\n            wprintw(filewin, \"[%c]\", getfileactionchar(groups[groupindex].files[f].action));\n            if (cursorgroup == groupindex && cursorfile == f)\n              wattroff(filewin, A_REVERSE);\n            wprintw(filewin, \" \");\n\n            if (ISFLAG(flags, F_SHOWTIME))\n              wprintw(filewin, \"[%s] \", fmttime(groups[groupindex].files[f].file->mtime));\n          }\n\n          cy = getcury(filewin);\n\n          if (groups[groupindex].files[f].selected)\n            wattron(filewin, A_REVERSE);\n          putline(filewin, groups[groupindex].files[f].file->d_name, row, COLS, index_width + timestamp_width + FILENAME_INDENT_EXTRA);\n          if (groups[groupindex].files[f].selected)\n            wattroff(filewin, A_REVERSE);\n\n          wclrtoeol(filewin);\n          wmove(filewin, cy+1, 0);\n        }\n      }\n      else if (linestyle == linestyle_groupfooterspacing)\n      {\n        wprintw(filewin, \"\\n\");\n      }\n    }\n\n    if (totalgroups > 0)\n      format_status_right(status, L\"Set %d of %d\", cursorgroup+1, totalgroups);\n    else\n      format_status_right(status, L\"Finished\");\n\n    print_status(statuswin, status);\n\n    if (totalgroups > 0)\n      format_prompt(prompt, L\"( Preserve files [1 - %d, all, help] )\", groups[cursorgroup].filecount);\n    else if (dupesfound)\n      format_prompt(prompt, L\"( No duplicates remaining; type 'exit' to exit program )\");\n    else\n      format_prompt(prompt, L\"( No duplicates found; type 'exit' to exit program )\");\n\n    print_prompt(promptwin, prompt, L\"\");\n\n    /* refresh windows (using wrefresh instead of wnoutrefresh to avoid bug in gnome-terminal) */\n    wrefresh(filewin);\n    wrefresh(statuswin);\n    wrefresh(promptwin);\n\n    /* wait for user input */\n    if (!resumecommandinput)\n    {\n      do\n      {\n        keyresult = wget_wch(promptwin, &wch);\n\n        if (got_sigint)\n        {\n          getyx(promptwin, cursor_y, cursor_x);\n\n          format_status_left(status, L\"Type 'exit' to exit fdupes.\");\n          print_status(statuswin, status);\n\n          wmove(promptwin, cursor_y, cursor_x);\n\n          got_sigint = 0;\n\n          wrefresh(statuswin);\n        }\n      } while (keyresult == ERR);\n\n      if (keyresult == OK && iswprint(wch))\n      {\n        commandbuffer[0] = wch;\n        commandbuffer[1] = '\\0';\n      }\n      else\n      {\n        commandbuffer[0] = '\\0';\n      }\n    }\n\n    if (resumecommandinput || (keyresult == OK && iswprint(wch) && ((wch != '\\t' && wch != '\\n' && wch != '?'))))\n    {\n      resumecommandinput = 0;\n\n      switch (get_command_text(&commandbuffer, &commandbuffersize, promptwin, prompt, 1, 1))\n      {\n        case GET_COMMAND_OK:\n          format_status_left(status, L\"Ready\");\n\n          get_command_arguments(&commandarguments, commandbuffer);\n\n          switch (identify_command(commandidentifier, commandbuffer, 0))\n          {\n            case COMMAND_SELECT_CONTAINING:\n              cmd_select_containing(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_SELECT_BEGINNING:\n              cmd_select_beginning(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_SELECT_ENDING:\n              cmd_select_ending(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_SELECT_MATCHING:\n              cmd_select_matching(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_SELECT_REGEX:\n              cmd_select_regex(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_CLEAR_SELECTIONS_CONTAINING:\n              cmd_clear_selections_containing(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_CLEAR_SELECTIONS_BEGINNING:\n              cmd_clear_selections_beginning(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_CLEAR_SELECTIONS_ENDING:\n              cmd_clear_selections_ending(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_CLEAR_SELECTIONS_MATCHING:\n              cmd_clear_selections_matching(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_CLEAR_SELECTIONS_REGEX:\n              cmd_clear_selections_regex(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_CLEAR_ALL_SELECTIONS:\n              cmd_clear_all_selections(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_INVERT_GROUP_SELECTIONS:\n              cmd_invert_group_selections(groups, totalgroups, commandarguments, status);\n              break;\n\n            case COMMAND_KEEP_SELECTED:\n              cmd_keep_selected(groups, totalgroups, commandarguments, &globaldeletiontally, status);\n              break;\n\n            case COMMAND_DELETE_SELECTED:\n              cmd_delete_selected(groups, totalgroups, commandarguments, &globaldeletiontally, status);\n              break;\n\n            case COMMAND_RESET_SELECTED:\n              cmd_reset_selected(groups, totalgroups, commandarguments, &globaldeletiontally, status);\n              break;\n\n            case COMMAND_RESET_GROUP:\n              for (x = 0; x < groups[cursorgroup].filecount; ++x)\n                set_file_action(&groups[cursorgroup].files[x], FILEACTION_UNRESOLVED, &globaldeletiontally);\n\n              format_status_left(status, L\"Reset all files in current group.\");\n\n              break;\n\n            case COMMAND_PRESERVE_ALL:\n              /* mark all files for preservation */\n              for (x = 0; x < groups[cursorgroup].filecount; ++x)\n                set_file_action(&groups[cursorgroup].files[x], FILEACTION_KEEP, &globaldeletiontally);\n\n              format_status_left(status, L\"%d files marked for preservation\", groups[cursorgroup].filecount);\n\n              if (cursorgroup < totalgroups - 1)\n                move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n              break;\n\n            case COMMAND_GOTO_SET:\n              number = wcstol(commandarguments, &wcstolcheck, 10);\n              if (wcstolcheck != commandarguments && *wcstolcheck == '\\0')\n              {\n                if (number >= 1 && number <= totalgroups)\n                {\n                  scroll_to_group(&topline, number - 1, 0, groups, filewin);\n\n                  cursorgroup = number - 1;\n                  cursorfile = 0;\n                }\n                else\n                {\n                  format_status_left(status, L\"Group index out of range.\");\n                }\n              }\n              else\n              {\n                format_status_left(status, L\"Invalid group index.\");\n              }\n\n              break;\n\n            case COMMAND_HELP:\n              endwin();\n\n              if (system(HELP_COMMAND_STRING) == -1)\n                format_status_left(status, L\"Could not display help text.\");\n\n              refresh();\n\n              break;\n\n            case COMMAND_PRUNE:\n              cmd_prune(groups, totalgroups, commandarguments, &globaldeletiontally, &totalgroups, &cursorgroup, &cursorfile, &topline, logfile, filewin, statuswin, status);\n              break;\n\n            case COMMAND_EXIT: /* exit program */\n              if (totalgroups == 0)\n              {\n                doprune = 0;\n                continue;\n              }\n              else\n              {\n                if (globaldeletiontally != 0)\n                  format_prompt(prompt, L\"( There are files marked for deletion. Exit without deleting? )\");\n                else\n                  format_prompt(prompt, L\"( There are duplicates remaining. Exit anyway? )\");\n\n                print_prompt(promptwin, prompt, L\"\");\n\n                wrefresh(promptwin);\n\n                switch (get_command_text(&commandbuffer, &commandbuffersize, promptwin, prompt, 0, 0))\n                {\n                  case GET_COMMAND_OK:\n                    switch (identify_command(confirmationkeywordidentifier, commandbuffer, 0))\n                    {\n                      case COMMAND_YES:\n                        doprune = 0;\n                        continue;\n\n                      case COMMAND_NO:\n                      case COMMAND_UNDEFINED:\n                        commandbuffer[0] = '\\0';\n                        continue;\n                    }\n                    break;\n\n                  case GET_COMMAND_CANCELED:\n                    commandbuffer[0] = '\\0';\n                    continue;\n\n                  case GET_COMMAND_RESIZE_REQUESTED:\n                    /* resize windows */\n                    wresize(filewin, LINES - 2, COLS);\n\n                    wresize(statuswin, 1, COLS);\n                    wresize(promptwin, 1, COLS);\n                    mvwin(statuswin, LINES - 1, 0);\n                    mvwin(promptwin, LINES - 2, 0);\n\n                    status_text_alloc(status, COLS);\n\n                    /* recalculate line boundaries */\n                    groupfirstline = 0;\n\n                    for (g = 0; g < totalgroups; ++g)\n                    {\n                      groups[g].startline = groupfirstline;\n                      groups[g].endline = groupfirstline + 2;\n\n                      for (f = 0; f < groups[g].filecount; ++f)\n                        groups[g].endline += filerowcount(groups[g].files[f].file, COLS, groups[g].filecount);\n\n                      groupfirstline = groups[g].endline + 1;\n                    }\n\n                    commandbuffer[0] = '\\0';\n\n                    break;\n\n                  case GET_COMMAND_ERROR_OUT_OF_MEMORY:\n                    for (g = 0; g < totalgroups; ++g)\n                      free(groups[g].files);\n\n                    free(groups);\n                    free(commandbuffer);\n                    free_command_identifier_tree(commandidentifier);\n                    free_command_identifier_tree(confirmationkeywordidentifier);\n\n                    endwin();\n                    errormsg(\"out of memory\\n\");\n                    exit(1);\n                    break;\n                }\n              }\n              break;\n\n            default: /* parse list of files to preserve and mark for preservation */\n              intresult = validate_file_list(groups + cursorgroup, commandbuffer);\n              if (intresult != FILE_LIST_OK)\n              {\n                if (intresult == FILE_LIST_ERROR_UNKNOWN_COMMAND)\n                {\n                  format_status_left(status, L\"Unrecognized command\");\n                  break;\n                }\n                else if (intresult == FILE_LIST_ERROR_INDEX_OUT_OF_RANGE)\n                {\n                  format_status_left(status, L\"Index out of range (1 - %d).\", groups[cursorgroup].filecount);\n                  break;\n                }\n                else if (intresult == FILE_LIST_ERROR_LIST_CONTAINS_INVALID_INDEX)\n                {\n                  format_status_left(status, L\"Invalid index\");\n                  break;\n                }\n                else if (intresult == FILE_LIST_ERROR_OUT_OF_MEMORY)\n                {\n                  free(commandbuffer);\n\n                  free_command_identifier_tree(commandidentifier);\n\n                  for (g = 0; g < totalgroups; ++g)\n                    free(groups[g].files);\n\n                  free(groups);\n\n                  endwin();\n                  errormsg(\"out of memory\\n\");\n                  exit(1);\n                }\n                else\n                {\n                  format_status_left(status, L\"Could not interpret command\");\n                  break;\n                }\n              }\n\n              token = wcstok(commandbuffer, L\",\", &wcsptr);\n\n              while (token != NULL)\n              {\n                number = wcstol(token, &wcstolcheck, 10);\n                if (wcstolcheck != token && *wcstolcheck == '\\0')\n                {\n                  if (number > 0 && number <= groups[cursorgroup].filecount)\n                    set_file_action(&groups[cursorgroup].files[number - 1], FILEACTION_KEEP, &globaldeletiontally);\n                }\n\n                token = wcstok(NULL, L\",\", &wcsptr);\n              }\n\n              /* mark remaining files for deletion */\n              preservecount = 0;\n              deletecount = 0;\n\n              for (x = 0; x < groups[cursorgroup].filecount; ++x)\n              {\n                if (groups[cursorgroup].files[x].action == FILEACTION_KEEP)\n                  ++preservecount;\n                if (groups[cursorgroup].files[x].action == FILEACTION_DELETE)\n                  ++deletecount;\n              }\n\n              if (preservecount > 0)\n              {\n                for (x = 0; x < groups[cursorgroup].filecount; ++x)\n                {\n                  if (groups[cursorgroup].files[x].action == FILEACTION_UNRESOLVED || \n                      groups[cursorgroup].files[x].action == FILEACTION_ERROR\n                  )\n                  {\n                    set_file_action(&groups[cursorgroup].files[x], FILEACTION_DELETE, &globaldeletiontally);\n                    ++deletecount;\n                  }\n                }\n              }\n\n              format_status_left(status, L\"%d files marked for preservation, %d for deletion\", preservecount, deletecount);\n\n              if (cursorgroup < totalgroups - 1 && preservecount > 0)\n                move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n              break;\n          }\n\n          break;\n\n        case GET_COMMAND_KEY_SF:\n          ++topline;\n\n          resumecommandinput = 1;\n\n          continue;\n\n        case GET_COMMAND_KEY_SR:\n          if (topline > 0)\n            --topline;\n\n          resumecommandinput = 1;\n\n          continue;\n\n        case GET_COMMAND_KEY_NPAGE:\n          topline += getmaxy(filewin);\n\n          resumecommandinput = 1;\n\n          continue;\n\n        case GET_COMMAND_KEY_PPAGE:\n          topline -= getmaxy(filewin);\n\n          if (topline < 0)\n            topline = 0;\n\n          resumecommandinput = 1;\n\n          continue;\n\n        case GET_COMMAND_CANCELED:\n          break;\n\n        case GET_COMMAND_RESIZE_REQUESTED:\n          /* resize windows */\n          wresize(filewin, LINES - 2, COLS);\n\n          wresize(statuswin, 1, COLS);\n          wresize(promptwin, 1, COLS);\n          mvwin(statuswin, LINES - 1, 0);\n          mvwin(promptwin, LINES - 2, 0);\n\n          status_text_alloc(status, COLS);\n\n          /* recalculate line boundaries */\n          groupfirstline = 0;\n\n          for (g = 0; g < totalgroups; ++g)\n          {\n            groups[g].startline = groupfirstline;\n            groups[g].endline = groupfirstline + 2;\n\n            for (f = 0; f < groups[g].filecount; ++f)\n              groups[g].endline += filerowcount(groups[g].files[f].file, COLS, groups[g].filecount);\n\n            groupfirstline = groups[g].endline + 1;\n          }\n\n          commandbuffer[0] = '\\0';\n\n          break;\n\n        case GET_COMMAND_ERROR_OUT_OF_MEMORY:\n          for (g = 0; g < totalgroups; ++g)\n            free(groups[g].files);\n\n          free(groups);\n          free(commandbuffer);\n          free_command_identifier_tree(commandidentifier);\n          free_command_identifier_tree(confirmationkeywordidentifier);\n\n          endwin();\n          errormsg(\"out of memory\\n\");\n          exit(1);\n\n          break;\n      }\n\n      commandbuffer[0] = '\\0';\n    }\n    else if (keyresult == KEY_CODE_YES)\n    {\n      switch (wch)\n      {\n      case KEY_DOWN:\n        if (cursorfile < groups[cursorgroup].filecount - 1)\n          move_to_next_file(&topline, &cursorgroup, &cursorfile, groups, filewin);\n        else if (cursorgroup < totalgroups - 1)\n          move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n        break;\n\n      case KEY_UP:\n        if (cursorfile > 0)\n          move_to_previous_file(&topline, &cursorgroup, &cursorfile, groups, filewin);\n        else if (cursorgroup > 0)\n          move_to_previous_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n        break;\n\n      case KEY_SF:\n        ++topline;\n        break;\n\n      case KEY_SR:\n        if (topline > 0)\n          --topline;\n        break;\n\n      case KEY_NPAGE:\n        topline += getmaxy(filewin);\n        break;\n\n      case KEY_PPAGE:\n        topline -= getmaxy(filewin);\n\n        if (topline < 0)\n          topline = 0;\n\n        break;\n\n      case KEY_SRIGHT:\n        set_file_action(&groups[cursorgroup].files[cursorfile], FILEACTION_KEEP, &globaldeletiontally);\n\n        format_status_left(status, L\"1 file marked for preservation.\");\n\n        if (cursorfile < groups[cursorgroup].filecount - 1)\n          move_to_next_file(&topline, &cursorgroup, &cursorfile, groups, filewin);\n        else if (cursorgroup < totalgroups - 1)\n          move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n        break;\n\n      case KEY_SLEFT:\n        deletecount = 0;\n\n        set_file_action(&groups[cursorgroup].files[cursorfile], FILEACTION_DELETE, &globaldeletiontally);\n\n        format_status_left(status, L\"1 file marked for deletion.\");\n\n        for (x = 0; x < groups[cursorgroup].filecount; ++x)\n          if (groups[cursorgroup].files[x].action == FILEACTION_DELETE)\n            ++deletecount;\n\n        if (deletecount < groups[cursorgroup].filecount)\n        {\n          if (cursorfile < groups[cursorgroup].filecount - 1)\n            move_to_next_file(&topline, &cursorgroup, &cursorfile, groups, filewin);\n          else if (cursorgroup < totalgroups - 1)\n            move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n        }\n\n        break;\n\n      case KEY_BACKSPACE:\n        if (cursorgroup > 0)\n          --cursorgroup;\n\n        cursorfile = 0;\n\n        scroll_to_group(&topline, cursorgroup, 0, groups, filewin);\n\n        break;\n\n      case KEY_F(3):\n        move_to_next_selected_group(&topline, &cursorgroup, &cursorfile, groups, totalgroups, filewin);\n        break;\n\n      case KEY_F(2):\n        move_to_previous_selected_group(&topline, &cursorgroup, &cursorfile, groups, totalgroups, filewin);\n        break;\n\n      case KEY_DC:\n        cmd_prune(groups, totalgroups, commandarguments, &globaldeletiontally, &totalgroups, &cursorgroup, &cursorfile, &topline, logfile, filewin, statuswin, status);\n        break;\n\n      case KEY_RESIZE:\n        /* resize windows */\n        wresize(filewin, LINES - 2, COLS);\n\n        wresize(statuswin, 1, COLS);\n        wresize(promptwin, 1, COLS);\n        mvwin(statuswin, LINES - 1, 0);\n        mvwin(promptwin, LINES - 2, 0);\n\n        status_text_alloc(status, COLS);\n\n        /* recalculate line boundaries */\n        groupfirstline = 0;\n\n        for (g = 0; g < totalgroups; ++g)\n        {\n          groups[g].startline = groupfirstline;\n          groups[g].endline = groupfirstline + 2;\n\n          for (f = 0; f < groups[g].filecount; ++f)\n            groups[g].endline += filerowcount(groups[g].files[f].file, COLS, groups[g].filecount);\n\n          groupfirstline = groups[g].endline + 1;\n        }\n\n        break;\n      }\n    }\n    else if (keyresult == OK)\n    {\n      switch (wch)\n      {\n      case '?':\n        if (groups[cursorgroup].files[cursorfile].action == FILEACTION_UNRESOLVED)\n          break;\n\n        set_file_action(&groups[cursorgroup].files[cursorfile], FILEACTION_UNRESOLVED, &globaldeletiontally);\n\n        if (cursorfile < groups[cursorgroup].filecount - 1)\n          move_to_next_file(&topline, &cursorgroup, &cursorfile, groups, filewin);\n        else if (cursorgroup < totalgroups - 1)\n          move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n        break;\n\n      case '\\n':\n        deletecount = 0;\n        preservecount = 0;\n\n        for (x = 0; x < groups[cursorgroup].filecount; ++x)\n        {\n          if (groups[cursorgroup].files[x].action == FILEACTION_KEEP)\n            ++preservecount;\n        }\n\n        if (preservecount == 0)\n          break;\n\n        for (x = 0; x < groups[cursorgroup].filecount; ++x)\n        {\n          if (groups[cursorgroup].files[x].action == FILEACTION_UNRESOLVED)\n            set_file_action(&groups[cursorgroup].files[x], FILEACTION_DELETE, &globaldeletiontally);\n\n          if (groups[cursorgroup].files[x].action == FILEACTION_DELETE)\n            ++deletecount;\n        }\n\n        if (cursorgroup < totalgroups - 1 && deletecount < groups[cursorgroup].filecount)\n          move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n        break;\n\n      case '\\t':\n        if (cursorgroup < totalgroups - 1)\n          move_to_next_group(&topline, &cursorgroup, &cursorfile, groups, filewin);\n\n        break;\n      }\n    }\n  } while (doprune);\n\n  endwin();\n\n  free(commandbuffer);\n\n  free_prompt_info(prompt);\n\n  free_status_text(status);\n\n  free_command_identifier_tree(commandidentifier);\n  free_command_identifier_tree(confirmationkeywordidentifier);\n\n  for (g = 0; g < totalgroups; ++g)\n    free(groups[g].files);\n\n  free(groups);\n}\n"
        },
        {
          "name": "ncurses-interface.h",
          "type": "blob",
          "size": 1.23828125,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef NCURSESINTERFACE_H\n#define NCURSESINTERFACE_H\n\n#include \"fdupes.h\"\n\nvoid deletefiles_ncurses(file_t *files, char *logfile);\n\n#endif"
        },
        {
          "name": "ncurses-print.c",
          "type": "blob",
          "size": 3.8603515625,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <stdlib.h>\n#include <wchar.h>\n#include \"ncurses-print.h\"\n#include \"errormsg.h\"\n#include \"mbstowcs_escape_invalid.h\"\n#include \"positive_wcwidth.h\"\n\nvoid putline(WINDOW *window, const char *str, const int line, const int columns, const int compensate_indent)\n{\n  wchar_t *dest = 0;\n  int inputlength;\n  int linestart;\n  int linelength;\n  int linewidth;\n  int first_line_columns;\n  int l;\n\n  inputlength = mbstowcs_escape_invalid(0, str, 0);\n  if (inputlength == 0)\n    return;\n\n  dest = (wchar_t *) malloc((inputlength + 1) * sizeof(wchar_t));\n  if (dest == NULL)\n  {\n    endwin();\n    errormsg(\"out of memory\\n\");\n    exit(1);\n  }\n\n  mbstowcs_escape_invalid(dest, str, inputlength);\n  dest[inputlength] = L'\\0';\n\n  first_line_columns = columns - compensate_indent;\n\n  linestart = 0;\n\n  if (line > 0)\n  {\n    linewidth = positive_wcwidth(dest[linestart]);\n\n    while (linestart + 1 < inputlength && linewidth + positive_wcwidth(dest[linestart + 1]) <= first_line_columns)\n      linewidth += positive_wcwidth(dest[++linestart]);\n\n    if (++linestart == inputlength)\n      return;\n\n    for (l = 1; l < line; ++l)\n    {\n      linewidth = positive_wcwidth(dest[linestart]);\n\n      while (linestart + 1 < inputlength && linewidth + positive_wcwidth(dest[linestart + 1]) <= columns)\n        linewidth += positive_wcwidth(dest[++linestart]);\n\n      if (++linestart == inputlength)\n        return;\n    }\n  }\n\n  linewidth = positive_wcwidth(dest[linestart]);\n  linelength = 1;\n\n  if (line == 0)\n  {\n    while (linestart + linelength < inputlength && linewidth + positive_wcwidth(dest[linestart + linelength]) <= first_line_columns)\n    {\n      linewidth += positive_wcwidth(dest[linestart + linelength]);\n      ++linelength;\n    }\n  }\n  else\n  {\n    while (linestart + linelength < inputlength && linewidth + positive_wcwidth(dest[linestart + linelength]) <= columns)\n    {\n      linewidth += positive_wcwidth(dest[linestart + linelength]);\n      ++linelength;\n    }    \n  }\n\n  waddnwstr(window, dest + linestart, linelength);\n\n  free(dest);\n}\n\nvoid print_spaces(WINDOW *window, int spaces)\n{\n  int x;\n\n  for (x = 0; x < spaces; ++x)\n    waddch(window, L' ');\n}\n\nvoid print_right_justified_int(WINDOW *window, int number, int width)\n{\n  int length;\n\n  length = get_num_digits(number);\n  if (number < 0)\n    ++length;\n\n  if (length < width)\n    print_spaces(window, width - length);\n\n  wprintw(window, \"%d\", number);\n}\n\nint vwprintflength(const wchar_t *format, va_list args)\n{\n  FILE *fp;\n  int size;\n\n  fp = fopen(\"/dev/null\", \"w\");\n  if (fp == 0)\n    return 0;\n\n  size = vfwprintf(fp, format, args);\n\n  fclose(fp);\n\n  return size;\n}\n\nint get_num_digits(int value)\n{\n  int digits = 0;\n\n  if (value < 0)\n    value = -value;\n\n  do {\n    value /= 10;\n    ++digits;\n  } while (value > 0);\n\n  return digits;\n}\n"
        },
        {
          "name": "ncurses-print.h",
          "type": "blob",
          "size": 1.59765625,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef NCURSESPRINT_H\n#define NCURSESPRINT_H\n\n#include <wchar.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n  #include <ncursesw/curses.h>\n#else\n  #include <curses.h>\n#endif\n#include <stdarg.h>\n\nvoid putline(WINDOW *window, const char *str, const int line, const int columns, const int compensate_indent);\nvoid print_spaces(WINDOW *window, int spaces);\nvoid print_right_justified_int(WINDOW *window, int number, int width);\nint vwprintflength(const wchar_t *format, va_list args);\nint get_num_digits(int value);\n\n#endif"
        },
        {
          "name": "ncurses-prompt.c",
          "type": "blob",
          "size": 3.875,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <stdlib.h>\n#include \"ncurses-print.h\"\n#include \"ncurses-prompt.h\"\n\nstruct prompt_info *prompt_info_alloc(size_t initial_size)\n{\n  struct prompt_info *out;\n\n  if (initial_size < 1)\n    return 0;\n\n  out = (struct prompt_info*) malloc(sizeof(struct prompt_info));\n  if (out == 0)\n    return 0;\n\n  out->text = malloc(initial_size * sizeof(wchar_t));\n  if (out->text == 0)\n  {\n    free(out);\n    return 0;\n  }\n\n  out->text[0] = L'\\0';\n  out->allocated = initial_size;\n  out->offset = 0;\n  out->cursor = 0;\n  out->active = 0;\n\n  return out;\n}\n\nvoid free_prompt_info(struct prompt_info *info)\n{\n  free(info->text);\n  free(info);\n}\n\nint format_prompt(struct prompt_info *prompt, wchar_t *format, ...)\n{\n  va_list ap;\n  va_list aq;\n  int size;\n  wchar_t *newtext;\n\n  va_start(ap, format);\n  va_copy(aq, ap);\n\n  size = vwprintflength(format, aq);\n\n  if (size + 3 > prompt->allocated)\n  {\n    newtext = (wchar_t*)realloc(prompt->text, (size + 3) * sizeof(wchar_t));\n\n    if (newtext == 0)\n      return 0;\n\n    prompt->text = newtext;\n    prompt->allocated = size + 1;\n  }\n\n  vswprintf(prompt->text, prompt->allocated, format, ap);\n\n  size = wcslen(prompt->text);\n\n  prompt->text[size + 0] = L':';\n  prompt->text[size + 1] = L' ';\n  prompt->text[size + 2] = L'\\0';\n\n  va_end(aq);\n  va_end(ap);\n\n  return 1;\n}\n\nvoid set_prompt_active_state(struct prompt_info *prompt, int active)\n{\n  prompt->active = active;\n}\n\nvoid update_prompt(WINDOW *promptwin, struct prompt_info *prompt, wchar_t *commandbuffer, int cursor_delta)\n{\n  const size_t cursor_stop = wcslen(prompt->text);\n  const size_t right_edge = getmaxx(promptwin);\n  const size_t cursor_position = cursor_stop + prompt->cursor - prompt->offset;\n\n  if (cursor_delta > 0)\n  {\n    if (prompt->cursor + cursor_delta > wcslen(commandbuffer))\n     cursor_delta = wcslen(commandbuffer) - prompt->cursor;\n\n    if (cursor_position + cursor_delta >= right_edge)\n      prompt->offset += cursor_delta;\n  }\n  else if (cursor_delta < 0)\n  {\n    if (-cursor_delta > prompt->cursor)\n      cursor_delta = -(int)prompt->cursor;\n\n    if (cursor_position + cursor_delta < cursor_stop)\n      prompt->offset += cursor_delta;\n  }\n\n  prompt->cursor += cursor_delta;\n}\n\nvoid print_prompt(WINDOW *promptwin, struct prompt_info *prompt, wchar_t *commandbuffer)\n{\n  if (prompt->active)\n    prompt->text[wcslen(prompt->text) - 2] = '=';\n  else\n    prompt->text[wcslen(prompt->text) - 2] = ':';\n\n  werase(promptwin);\n\n  if (prompt->offset <= wcslen(prompt->text))\n  {\n    wattron(promptwin, A_BOLD);\n    waddwstr(promptwin, prompt->text + prompt->offset);\n    wattroff(promptwin, A_BOLD);\n\n    waddwstr(promptwin, commandbuffer);\n  }\n  else if (prompt->offset < wcslen(prompt->text) + wcslen(commandbuffer))\n  {\n    waddwstr(promptwin, commandbuffer + prompt->offset - wcslen(prompt->text));\n  }\n}"
        },
        {
          "name": "ncurses-prompt.h",
          "type": "blob",
          "size": 1.814453125,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef NCURSESPROMPT_H\n#define NCURSESPROMPT_H\n\n#include <wchar.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n  #include <ncursesw/curses.h>\n#else\n  #include <curses.h>\n#endif\n\nstruct prompt_info\n{\n  wchar_t *text;\n  size_t allocated;\n  size_t offset;\n  size_t cursor;\n  int active;\n};\n\nstruct prompt_info *prompt_info_alloc(size_t initial_size);\nvoid free_prompt_info(struct prompt_info *info);\nint format_prompt(struct prompt_info *prompt, wchar_t *format, ...);\nvoid set_prompt_active_state(struct prompt_info *prompt, int active);\nvoid update_prompt(WINDOW *promptwin, struct prompt_info *prompt, wchar_t *commandbuffer, int cursor_delta);\nvoid print_prompt(WINDOW *promptwin, struct prompt_info *prompt, wchar_t *commandbuffer);\n\n#endif"
        },
        {
          "name": "ncurses-status.c",
          "type": "blob",
          "size": 3.6240234375,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include <stdlib.h>\n#include \"ncurses-print.h\"\n#include \"ncurses-status.h\"\n\nstruct status_text *status_text_alloc(struct status_text *status, size_t width)\n{\n  struct status_text *result;\n  wchar_t *newleft;\n  wchar_t *newright;\n\n  if (status == 0)\n  {\n    result = (struct status_text*) malloc(sizeof(struct status_text));\n    if (result == 0)\n      return 0;\n\n    result->left = (wchar_t*) malloc((width+1) * sizeof(wchar_t));\n    if (result->left == 0)\n    {\n      free(result);\n      return 0;\n    }\n\n    result->right = (wchar_t*) malloc((width+1) * sizeof(wchar_t));\n    if (result->right == 0)\n    {\n      free(result->left);\n      free(result);\n      return 0;\n    }\n\n    result->left[0] = '\\0';\n    result->right[0] = '\\0';\n\n    result->width = width;\n  }\n  else\n  {\n    if (status->width >= width)\n      return status;\n\n    newleft = (wchar_t*) realloc(status->left, (width+1) * sizeof(wchar_t));\n    if (newleft == 0)\n      return 0;\n\n    newright = (wchar_t*) realloc(status->right, (width+1) * sizeof(wchar_t));\n    if (newright == 0)\n    {\n      free(newleft);\n      return 0;\n    }\n\n    result = status;\n    result->left = newleft;\n    result->right = newright;\n    result->width = width;\n  }\n\n  return result;\n}\n\nvoid free_status_text(struct status_text *status)\n{\n  free(status->left);\n  free(status->right);\n  free(status);\n}\n\nvoid format_status_left(struct status_text *status, wchar_t *format, ...)\n{\n  va_list ap;\n  va_list aq;\n  int size;\n\n  va_start(ap, format);\n  va_copy(aq, ap);\n\n  size = vwprintflength(format, aq);\n\n  status_text_alloc(status, size);\n\n  vswprintf(status->left, status->width + 1, format, ap);\n\n  va_end(aq);\n  va_end(ap);\n}\n\nvoid format_status_right(struct status_text *status, wchar_t *format, ...)\n{\n  va_list ap;\n  va_list aq;\n  int size;\n\n  va_start(ap, format);\n  va_copy(aq, ap);\n\n  size = vwprintflength(format, aq);\n\n  status_text_alloc(status, size);\n\n  vswprintf(status->right, status->width + 1, format, ap);\n\n  va_end(aq);\n  va_end(ap);\n}\n\nvoid print_status(WINDOW *statuswin, struct status_text *status)\n{\n  wchar_t *text;\n  size_t cols;\n  size_t x;\n  size_t l;\n\n  cols = getmaxx(statuswin);\n\n  text = (wchar_t*)malloc((cols + 1) * sizeof(wchar_t));\n\n  l = wcslen(status->left);\n  for (x = 0; x < l && x < cols; ++x)\n    text[x] = status->left[x];\n  for (x = l; x < cols; ++x)\n    text[x] = L' ';\n\n  l = wcslen(status->right);\n  for (x = cols; x >= 1 && l >= 1; --x, --l)\n    text[x - 1] = status->right[l - 1];\n\n  text[cols] = L'\\0';\n\n  mvwaddnwstr(statuswin, 0, 0, text, wcslen(text));\n\n  free(text);\n}"
        },
        {
          "name": "ncurses-status.h",
          "type": "blob",
          "size": 1.685546875,
          "content": "/* FDUPES Copyright (c) 2018-2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY \n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef NCURSESSTATUS_H\n#define NCURSESSTATUS_H\n\n#include <wchar.h>\n#ifdef HAVE_NCURSESW_CURSES_H\n  #include <ncursesw/curses.h>\n#else\n  #include <curses.h>\n#endif\n\nstruct status_text\n{\n  wchar_t *left;\n  wchar_t *right;\n  size_t width;\n};\n\nstruct status_text *status_text_alloc(struct status_text *status, size_t width);\nvoid free_status_text(struct status_text *status);\nvoid format_status_left(struct status_text *status, wchar_t *format, ...);\nvoid format_status_right(struct status_text *status, wchar_t *format, ...);\nvoid print_status(WINDOW *statuswin, struct status_text *status);\n\n#endif"
        },
        {
          "name": "positive_wcwidth.c",
          "type": "blob",
          "size": 1.04296875,
          "content": "/* Copyright (c) 2019-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include \"config.h\"\n#include \"positive_wcwidth.h\"\n\nint positive_wcwidth(wchar_t ch)\n{\n  int w;\n\n  w = wcwidth(ch);\n\n  if (w >= 0)\n    return w;\n  else\n    return 1;\n}"
        },
        {
          "name": "positive_wcwidth.h",
          "type": "blob",
          "size": 0.994140625,
          "content": "/* Copyright (c) 2019-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef POSITIVE_WCWIDTH_H\n#define POSITIVE_WCWIDTH_H\n\n#include <wchar.h>\n\nint positive_wcwidth(wchar_t ch);\n\n#endif"
        },
        {
          "name": "removeifnotchanged.c",
          "type": "blob",
          "size": 2.0419921875,
          "content": "/* FDUPES Copyright (c) 2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#include \"config.h\"\n#include \"removeifnotchanged.h\"\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n\nint removeifnotchanged(const file_t *file, char **errorstring)\n{\n  int result;\n  struct stat st;\n\n  static char *filechanged = \"File contents changed during processing\";\n  static char *unknownerror = \"Unknown error\";\n\n  stat(file->d_name, &st);\n\n  if (file->device != st.st_dev ||\n      file->inode != st.st_ino ||\n      file->ctime != st.st_ctime ||\n      file->mtime != st.st_mtime ||\n#ifdef HAVE_NSEC_TIMES\n      file->ctime_nsec != st.st_ctim.tv_nsec ||\n      file->mtime_nsec != st.st_mtim.tv_nsec ||\n#endif\n      file->size != st.st_size)\n  {\n    if (errorstring != 0)\n        *errorstring = filechanged;\n\n    return -2;\n  }\n  else\n  {\n    result = remove(file->d_name);\n\n    if (result != 0 && errorstring != 0)\n    {\n      *errorstring = strerror(errno);\n\n      if (*errorstring == 0)\n        *errorstring = unknownerror;\n    }\n\n    return result;\n  }\n}\n"
        },
        {
          "name": "removeifnotchanged.h",
          "type": "blob",
          "size": 1.2392578125,
          "content": "/* FDUPES Copyright (c) 2022 Adrian Lopez\n\n   Permission is hereby granted, free of charge, to any person\n   obtaining a copy of this software and associated documentation files\n   (the \"Software\"), to deal in the Software without restriction,\n   including without limitation the rights to use, copy, modify, merge,\n   publish, distribute, sublicense, and/or sell copies of the Software,\n   and to permit persons to whom the Software is furnished to do so,\n   subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */\n\n#ifndef REMOVEIFNOTCHANGED_H\n#define REMOVEIFNOTCHANGED_H\n\n#include \"fdupes.h\"\n\nint removeifnotchanged(const file_t *file, char **errorstring);\n\n#endif"
        },
        {
          "name": "sbasename.c",
          "type": "blob",
          "size": 0.421875,
          "content": "/* The contents of this file are in the public domain.\n*/\n#include \"sbasename.h\"\n#include <string.h>\n#include <libgen.h>\n#include <stdlib.h>\n\nchar *sbasename(char *str, const char *path)\n{\n    char *name;\n\n    if (str == 0)\n    {\n        str = malloc(strlen(path) + 1);\n        if (str == 0)\n            return 0;\n    }\n\n    strcpy(str, path);\n\n    name = basename(str);\n\n    memmove(str, name, strlen(name) + 1);\n\n    return str;\n}"
        },
        {
          "name": "sbasename.h",
          "type": "blob",
          "size": 0.1708984375,
          "content": "/* The contents of this file are in the public domain.\n*/\n#ifndef SNBASENAME_H\n#define SNBASENAME_H\n\n#include <stddef.h>\n\nchar *sbasename(char *str, const char *path);\n\n#endif"
        },
        {
          "name": "sdirname.c",
          "type": "blob",
          "size": 0.4189453125,
          "content": "/* The contents of this file are in the public domain.\n*/\n#include \"sdirname.h\"\n#include <string.h>\n#include <libgen.h>\n#include <stdlib.h>\n\nchar *sdirname(char *str, const char *path)\n{\n    char *name;\n\n    if (str == 0)\n    {\n        str = malloc(strlen(path) + 1);\n        if (str == 0)\n            return 0;\n    }\n\n    strcpy(str, path);\n\n    name = dirname(str);\n\n    memmove(str, name, strlen(name) + 1);\n\n    return str;\n}"
        },
        {
          "name": "sdirname.h",
          "type": "blob",
          "size": 0.16796875,
          "content": "/* The contents of this file are in the public domain.\n*/\n#ifndef SNDIRNAME_H\n#define SNDIRNAME_H\n\n#include <stddef.h>\n\nchar *sdirname(char *str, const char *path);\n\n#endif"
        },
        {
          "name": "sigint.c",
          "type": "blob",
          "size": 1.19140625,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include <string.h>\n#include \"sigint.h\"\n\nvolatile sig_atomic_t got_sigint = 0;\n\nvoid sigint_handler(int signal)\n{\n  got_sigint = 1;\n}\n\nvoid register_sigint_handler()\n{\n  struct sigaction action;\n\n  memset(&action, 0, sizeof(struct sigaction));\n\n  action.sa_handler = sigint_handler;\n  sigaction(SIGINT, &action, 0);\t\n}"
        },
        {
          "name": "sigint.h",
          "type": "blob",
          "size": 1.0146484375,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef SIGINT_H\n#define SIGINT_H\n\n#include <signal.h>\n\nextern volatile sig_atomic_t got_sigint;\n\nvoid register_sigint_handler();\n\n#endif"
        },
        {
          "name": "testdir",
          "type": "tree",
          "content": null
        },
        {
          "name": "wcs.c",
          "type": "blob",
          "size": 3.1357421875,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#include <stdlib.h>\n#include \"wcs.h\"\n#include \"mbstowcs_escape_invalid.h\"\n\n/* compare wide and multibyte strings */\nint wcsmbcscmp(wchar_t *s1, char *s2)\n{\n  wchar_t *s2w;\n  size_t size;\n  int result;\n\n  size = mbstowcs_escape_invalid(0, s2, 0) + 1;\n\n  s2w = (wchar_t*) malloc(size * sizeof(wchar_t));\n  if (s2w == 0)\n    return -1;\n\n  mbstowcs_escape_invalid(s2w, s2, size);\n\n  result = wcscmp(s1, s2w);\n\n  free(s2w);\n\n  return result;\n}\n\n/* wide character needle is contained in multibyte haystack */\nint wcsinmbcs(char *haystack, wchar_t *needle)\n{\n  wchar_t *haystackw;\n  size_t size;\n  int result;\n\n  size = mbstowcs_escape_invalid(0, haystack, 0) + 1;\n\n  haystackw = (wchar_t*) malloc(size * sizeof(wchar_t));\n  if (haystackw == 0)\n    return -1;\n\n  mbstowcs_escape_invalid(haystackw, haystack, size);\n\n  if (wcsstr(haystackw, needle) == 0)\n    result = 0;\n  else\n    result = 1;\n\n  free(haystackw);\n\n  return result;\n}\n\n/* wide character needle at beginning of multibyte haystack */\nint wcsbeginmbcs(char *haystack, wchar_t *needle)\n{\n  wchar_t *haystackw;\n  size_t size;\n  int result;\n\n  size = mbstowcs_escape_invalid(0, haystack, 0);\n\n  haystackw = (wchar_t*) malloc(size * sizeof(wchar_t));\n  if (haystackw == 0)\n    return -1;\n\n  mbstowcs_escape_invalid(haystackw, haystack, size);\n\n  if (wcsncmp(haystackw, needle, wcslen(needle)) == 0)\n    result = 1;\n  else\n    result = 0;\n\n  free(haystackw);\n\n  return result;\n}\n\n/* wide character needle at end of multibyte haystack */\nint wcsendsmbcs(char *haystack, wchar_t *needle)\n{\n  wchar_t *haystackw;\n  size_t size;\n  int result;\n\n  size = mbstowcs_escape_invalid(0, haystack, 0) + 1;\n\n  haystackw = (wchar_t*) malloc(size * sizeof(wchar_t));\n  if (haystackw == 0)\n    return -1;\n\n  mbstowcs_escape_invalid(haystackw, haystack, size);\n\n  if (wcsrstr(haystackw, needle) != 0 && wcscmp(wcsrstr(haystackw, needle), needle) == 0)\n    result = 1;\n  else\n    result = 0;\n\n  free(haystackw);\n\n  return result;\n}\n\n/* wide character reverse string search */\nwchar_t *wcsrstr(wchar_t *haystack, wchar_t *needle)\n{\n  wchar_t *found = 0;\n  wchar_t *next = 0;\n\n  found = wcsstr(haystack, needle);\n  if (found)\n  {\n    do {\n      next = wcsstr(found + 1, needle);\n      if (next != 0)\n        found = next;\n    } while (next);\n\n    return found;\n  }\n\n  return 0;\n}"
        },
        {
          "name": "wcs.h",
          "type": "blob",
          "size": 1.171875,
          "content": "/* Copyright (c) 2018-2022 Adrian Lopez\n\n   This software is provided 'as-is', without any express or implied\n   warranty. In no event will the authors be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this software must not be misrepresented; you must not\n      claim that you wrote the original software. If you use this software\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original software.\n   3. This notice may not be removed or altered from any source distribution. */\n\n#ifndef WCS_H\n#define WCS_H\n\n#include <wchar.h>\n\nint wcsmbcscmp(wchar_t *s1, char *s2);\nint wcsinmbcs(char *haystack, wchar_t *needle);\nint wcsbeginmbcs(char *haystack, wchar_t *needle);\nint wcsendsmbcs(char *haystack, wchar_t *needle);\nwchar_t *wcsrstr(wchar_t *haystack, wchar_t *needle);\n\n#endif"
        },
        {
          "name": "xdgbase.c",
          "type": "blob",
          "size": 1.5146484375,
          "content": "/* The contents of this file are in the public domain.\n*/\n#include \"config.h\"\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <string.h>\n\n#define XDG_CACHE_HOME_BASENAME \".cache\"\n#define XDG_CACHE_HOME_PERMISSIONS 0700\n\nchar *getcachehome(int createdefault)\n{\n    char *cachedir;\n    char *homedir;\n    char *result;\n    size_t pathlength;\n    size_t defaultdirlength;\n    struct passwd *pw;\n    struct stat st;\n\n    cachedir = getenv(\"XDG_CACHE_HOME\");\n    if (cachedir != 0)\n    {\n        pathlength = strlen(cachedir);\n\n        result = malloc(pathlength + 1);\n        if (result == 0)\n            return 0;\n\n        strcpy(result, cachedir);\n    }\n    else\n    {\n        homedir = getenv(\"HOME\");\n        if (homedir == 0)\n        {\n            pw = getpwuid(getuid());\n            if (pw == 0)\n                return 0;\n\n            homedir = pw->pw_dir;\n        }\n\n        if (homedir == 0)\n            return 0;\n\n        pathlength = strlen(homedir);\n\n        defaultdirlength = strlen(XDG_CACHE_HOME_BASENAME);\n\n        result = malloc(pathlength + defaultdirlength + 2);\n        if (result == 0)\n            return 0;\n\n        memmove(result, homedir, pathlength);\n        memmove(result + pathlength + 1, XDG_CACHE_HOME_BASENAME, defaultdirlength);\n\n        result[pathlength] = '/';\n        result[pathlength + defaultdirlength + 1] = '\\0';\n\n        if (createdefault && stat(result, &st) != 0)\n            mkdir(result, XDG_CACHE_HOME_PERMISSIONS);\n    }\n\n    return result;\n}"
        },
        {
          "name": "xdgbase.h",
          "type": "blob",
          "size": 0.1474609375,
          "content": "/* The contents of this file are in the public domain.\n*/\n#ifndef GETCONFIGDIR_H\n#define GETCONFIGDIR_H\n\nchar *getcachehome(int createdefault);\n\n#endif"
        }
      ]
    }
  ]
}