{
  "metadata": {
    "timestamp": 1736710108604,
    "page": 736,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "woai3c/MIT6.828",
      "stars": 1862,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".dir-locals.el",
          "type": "blob",
          "size": 0.208984375,
          "content": "((nil\n  (indent-tabs-mode . t)\n  (tab-width . 8))\n (c-mode\n  (c-file-style . \"bsd\")\n  (c-basic-offset . 8))\n (shell-mode\n  (sh-basic-offset . 8)\n  (sh-indentation . 8))\n (python-mode\n  (indent-tabs-mode . nil))\n )\n"
        },
        {
          "name": ".gdbinit.tmpl",
          "type": "blob",
          "size": 0.8369140625,
          "content": "set $lastcs = -1\n\ndefine hook-stop\n  # There doesn't seem to be a good way to detect if we're in 16- or\n  # 32-bit mode, but we always run with CS == 8 in 32-bit mode.\n  if $cs == 8 || $cs == 27\n    if $lastcs != 8 && $lastcs != 27\n      set architecture i386\n    end\n    x/i $pc\n  else\n    if $lastcs == -1 || $lastcs == 8 || $lastcs == 27\n      set architecture i8086\n    end\n    # Translate the segment:offset into a physical address\n    printf \"[%4x:%4x] \", $cs, $eip\n    x/i $cs*16+$eip\n  end\n  set $lastcs = $cs\nend\n\necho + target remote localhost:1234\\n\ntarget remote localhost:1234\n\n# If this fails, it's probably because your GDB doesn't support ELF.\n# Look at the tools page at\n#  http://pdos.csail.mit.edu/6.828/2009/tools.html\n# for instructions on building GDB with ELF support.\necho + symbol-file obj/kern/kernel\\n\nsymbol-file obj/kern/kernel\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.17578125,
          "content": "/obj\n/jos.in\n/jos.log\n/jos.out\n/jos.out.*\n/jos.cmd\n/.gdbinit\n/wget.log\n/qemu.pcap\n/qemu.pcap.*\n/qemu.out\n/qemu.log\n/gradelib.pyc\n/lab*-handin.tar.gz\n/lab?/\n/sol?/\n/myapi.key\n/.suf\n"
        },
        {
          "name": "CODING",
          "type": "blob",
          "size": 1.18359375,
          "content": "JOS CODING STANDARDS\n\nIt's easier on everyone if all authors working on a shared\ncode base are consistent in the way they write their programs.\nWe have the following conventions in our code:\n\n* No space after the name of a function in a call\n  For example, printf(\"hello\") not printf (\"hello\").\n\n* One space after keywords \"if\", \"for\", \"while\", \"switch\".\n  For example, if (x) not if(x).\n\n* Space before braces.\n  For example, if (x) { not if (x){.\n\n* Function names are all lower-case separated by underscores.\n\n* Beginning-of-line indentation via tabs, not spaces.\n\n* Preprocessor macros are always UPPERCASE.\n  There are a few grandfathered exceptions: assert, panic,\n  static_assert, offsetof.\n\n* Pointer types have spaces: (uint16_t *) not (uint16_t*).\n\n* Multi-word names are lower_case_with_underscores.\n\n* Comments in imported code are usually C /* ... */ comments.\n  Comments in new code are C++ style //.\n\n* In a function definition, the function name starts a new line.\n  Then you can grep -n '^foo' */*.c to find the definition of foo.\n\n* Functions that take no arguments are declared f(void) not f().\n\nThe included .dir-locals.el file will automatically set up the basic\nindentation style in Emacs.\n"
        },
        {
          "name": "GNUmakefile",
          "type": "blob",
          "size": 10.4208984375,
          "content": "#\n# This makefile system follows the structuring conventions\n# recommended by Peter Miller in his excellent paper:\n#\n#\tRecursive Make Considered Harmful\n#\thttp://aegis.sourceforge.net/auug97.pdf\n#\nOBJDIR := obj\n\n# Run 'make V=1' to turn on verbose commands, or 'make V=0' to turn them off.\nifeq ($(V),1)\noverride V =\nendif\nifeq ($(V),0)\noverride V = @\nendif\n\n-include conf/lab.mk\n\n-include conf/env.mk\n\nLABSETUP ?= ./\n\nTOP = .\n\n# Cross-compiler jos toolchain\n#\n# This Makefile will automatically use the cross-compiler toolchain\n# installed as 'i386-jos-elf-*', if one exists.  If the host tools ('gcc',\n# 'objdump', and so forth) compile for a 32-bit x86 ELF target, that will\n# be detected as well.  If you have the right compiler toolchain installed\n# using a different name, set GCCPREFIX explicitly in conf/env.mk\n\n# try to infer the correct GCCPREFIX\nifndef GCCPREFIX\nGCCPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \\\n\tthen echo 'i386-jos-elf-'; \\\n\telif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \\\n\tthen echo ''; \\\n\telse echo \"***\" 1>&2; \\\n\techo \"*** Error: Couldn't find an i386-*-elf version of GCC/binutils.\" 1>&2; \\\n\techo \"*** Is the directory with i386-jos-elf-gcc in your PATH?\" 1>&2; \\\n\techo \"*** If your i386-*-elf toolchain is installed with a command\" 1>&2; \\\n\techo \"*** prefix other than 'i386-jos-elf-', set your GCCPREFIX\" 1>&2; \\\n\techo \"*** environment variable to that prefix and run 'make' again.\" 1>&2; \\\n\techo \"*** To turn off this error, run 'gmake GCCPREFIX= ...'.\" 1>&2; \\\n\techo \"***\" 1>&2; exit 1; fi)\nendif\n\n# try to infer the correct QEMU\nifndef QEMU\nQEMU := $(shell if which qemu >/dev/null 2>&1; \\\n\tthen echo qemu; exit; \\\n        elif which qemu-system-i386 >/dev/null 2>&1; \\\n        then echo qemu-system-i386; exit; \\\n\telse \\\n\tqemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \\\n\tif test -x $$qemu; then echo $$qemu; exit; fi; fi; \\\n\techo \"***\" 1>&2; \\\n\techo \"*** Error: Couldn't find a working QEMU executable.\" 1>&2; \\\n\techo \"*** Is the directory containing the qemu binary in your PATH\" 1>&2; \\\n\techo \"*** or have you tried setting the QEMU variable in conf/env.mk?\" 1>&2; \\\n\techo \"***\" 1>&2; exit 1)\nendif\n\n# try to generate a unique GDB port\nGDBPORT\t:= $(shell expr `id -u` % 5000 + 25000)\n\nCC\t:= $(GCCPREFIX)gcc -pipe\nGDB\t:= $(GCCPREFIX)gdb\nAS\t:= $(GCCPREFIX)as\nAR\t:= $(GCCPREFIX)ar\nLD\t:= $(GCCPREFIX)ld\nOBJCOPY\t:= $(GCCPREFIX)objcopy\nOBJDUMP\t:= $(GCCPREFIX)objdump\nNM\t:= $(GCCPREFIX)nm\n\n# Native commands\nNCC\t:= gcc $(CC_VER) -pipe\nNATIVE_CFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -I$(TOP) -MD -Wall\nTAR\t:= gtar\nPERL\t:= perl\n\n# Compiler flags\n# -fno-builtin is required to avoid refs to undefined functions in the kernel.\n# Only optimize to -O1 to discourage inlining, which complicates backtraces.\nCFLAGS := $(CFLAGS) $(DEFS) $(LABDEFS) -O1 -fno-builtin -I$(TOP) -MD\nCFLAGS += -fno-omit-frame-pointer\nCFLAGS += -std=gnu99\nCFLAGS += -static\nCFLAGS += -fno-pie\nCFLAGS += -Wall -Wno-format -Wno-unused -Werror -gstabs -m32\n# -fno-tree-ch prevented gcc from sometimes reordering read_ebp() before\n# mon_backtrace()'s function prologue on gcc version: (Debian 4.7.2-5) 4.7.2\nCFLAGS += -fno-tree-ch\n\nCFLAGS += -I$(TOP)/net/lwip/include \\\n\t  -I$(TOP)/net/lwip/include/ipv4 \\\n\t  -I$(TOP)/net/lwip/jos\n\n# Add -fno-stack-protector if the option exists.\nCFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)\n\n# Common linker flags\nLDFLAGS := -m elf_i386\n\n# Linker flags for JOS user programs\nULDFLAGS := -T user/user.ld\n\nGCC_LIB := $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)\n\n# Lists that the */Makefrag makefile fragments will add to\nOBJDIRS :=\n\n# Make sure that 'all' is the first target\nall:\n\n# Eliminate default suffix rules\n.SUFFIXES:\n\n# Delete target files if there is an error (or make is interrupted)\n.DELETE_ON_ERROR:\n\n# make it so that no intermediate .o files are ever deleted\n.PRECIOUS: %.o $(OBJDIR)/boot/%.o $(OBJDIR)/kern/%.o \\\n\t   $(OBJDIR)/lib/%.o $(OBJDIR)/fs/%.o $(OBJDIR)/net/%.o \\\n\t   $(OBJDIR)/user/%.o\n\nKERN_CFLAGS := $(CFLAGS) -DJOS_KERNEL -gstabs\nUSER_CFLAGS := $(CFLAGS) -DJOS_USER -gstabs\n\n# Update .vars.X if variable X has changed since the last make run.\n#\n# Rules that use variable X should depend on $(OBJDIR)/.vars.X.  If\n# the variable's value has changed, this will update the vars file and\n# force a rebuild of the rule that depends on it.\n$(OBJDIR)/.vars.%: FORCE\n\t$(V)echo \"$($*)\" | cmp -s $@ || echo \"$($*)\" > $@\n.PRECIOUS: $(OBJDIR)/.vars.%\n.PHONY: FORCE\n\n\n# Include Makefrags for subdirectories\ninclude boot/Makefrag\ninclude kern/Makefrag\ninclude lib/Makefrag\ninclude user/Makefrag\ninclude fs/Makefrag\ninclude net/Makefrag\n\n\nCPUS ?= 1\n\nPORT7\t:= $(shell expr $(GDBPORT) + 1)\nPORT80\t:= $(shell expr $(GDBPORT) + 2)\n\nQEMUOPTS = -drive file=$(OBJDIR)/kern/kernel.img,index=0,media=disk,format=raw -serial mon:stdio -gdb tcp::$(GDBPORT)\nQEMUOPTS += $(shell if $(QEMU) -nographic -help | grep -q '^-D '; then echo '-D qemu.log'; fi)\nIMAGES = $(OBJDIR)/kern/kernel.img\nQEMUOPTS += -smp $(CPUS)\nQEMUOPTS += -drive file=$(OBJDIR)/fs/fs.img,index=1,media=disk,format=raw\nIMAGES += $(OBJDIR)/fs/fs.img\nQEMUOPTS += -net user -net nic,model=e1000 -redir tcp:$(PORT7)::7 \\\n\t   -redir tcp:$(PORT80)::80 -redir udp:$(PORT7)::7 -net dump,file=qemu.pcap\nQEMUOPTS += $(QEMUEXTRA)\n\n.gdbinit: .gdbinit.tmpl\n\tsed \"s/localhost:1234/localhost:$(GDBPORT)/\" < $^ > $@\n\ngdb:\n\t$(GDB) -n -x .gdbinit\n\npre-qemu: .gdbinit\n#\tQEMU doesn't truncate the pcap file.  Work around this.\n\t@rm -f qemu.pcap\n\nqemu: $(IMAGES) pre-qemu\n\t$(QEMU) $(QEMUOPTS)\n\nqemu-nox: $(IMAGES) pre-qemu\n\t@echo \"***\"\n\t@echo \"*** Use Ctrl-a x to exit qemu\"\n\t@echo \"***\"\n\t$(QEMU) -nographic $(QEMUOPTS)\n\nqemu-gdb: $(IMAGES) pre-qemu\n\t@echo \"***\"\n\t@echo \"*** Now run 'make gdb'.\" 1>&2\n\t@echo \"***\"\n\t$(QEMU) $(QEMUOPTS) -S\n\nqemu-nox-gdb: $(IMAGES) pre-qemu\n\t@echo \"***\"\n\t@echo \"*** Now run 'make gdb'.\" 1>&2\n\t@echo \"***\"\n\t$(QEMU) -nographic $(QEMUOPTS) -S\n\nprint-qemu:\n\t@echo $(QEMU)\n\nprint-gdbport:\n\t@echo $(GDBPORT)\n\n# For deleting the build\nclean:\n\trm -rf $(OBJDIR) .gdbinit jos.in qemu.log\n\nrealclean: clean\n\trm -rf lab$(LAB).tar.gz \\\n\t\tjos.out $(wildcard jos.out.*) \\\n\t\tqemu.pcap $(wildcard qemu.pcap.*) \\\n\t\tmyapi.key\n\ndistclean: realclean\n\trm -rf conf/gcc.mk\n\nifneq ($(V),@)\nGRADEFLAGS += -v\nendif\n\ngrade:\n\t@echo $(MAKE) clean\n\t@$(MAKE) clean || \\\n\t  (echo \"'make clean' failed.  HINT: Do you have another running instance of JOS?\" && exit 1)\n\t./grade-lab$(LAB) $(GRADEFLAGS)\n\ngit-handin: handin-check\n\t@if test -n \"`git config remote.handin.url`\"; then \\\n\t\techo \"Hand in to remote repository using 'git push handin HEAD' ...\"; \\\n\t\tif ! git push -f handin HEAD; then \\\n            echo ; \\\n\t\t\techo \"Hand in failed.\"; \\\n\t\t\techo \"As an alternative, please run 'make tarball'\"; \\\n\t\t\techo \"and visit http://pdos.csail.mit.edu/6.828/submit/\"; \\\n\t\t\techo \"to upload lab$(LAB)-handin.tar.gz.  Thanks!\"; \\\n\t\t\tfalse; \\\n\t\tfi; \\\n    else \\\n\t\techo \"Hand-in repository is not configured.\"; \\\n\t\techo \"Please run 'make handin-prep' first.  Thanks!\"; \\\n\t\tfalse; \\\n\tfi\n\nWEBSUB := https://6828.scripts.mit.edu/2018/handin.py\n\nhandin: tarball-pref myapi.key\n\t@SUF=$(LAB); \\\n\ttest -f .suf && SUF=`cat .suf`; \\\n\tcurl -f -F file=@lab$$SUF-handin.tar.gz -F key=\\<myapi.key $(WEBSUB)/upload \\\n\t    > /dev/null || { \\\n\t\techo ; \\\n\t\techo Submit seems to have failed.; \\\n\t\techo Please go to $(WEBSUB)/ and upload the tarball manually.; }\n\nhandin-check:\n\t@if ! test -d .git; then \\\n\t\techo No .git directory, is this a git repository?; \\\n\t\tfalse; \\\n\tfi\n\t@if test \"$$(git symbolic-ref HEAD)\" != refs/heads/lab$(LAB); then \\\n\t\tgit branch; \\\n\t\tread -p \"You are not on the lab$(LAB) branch.  Hand-in the current branch? [y/N] \" r; \\\n\t\ttest \"$$r\" = y; \\\n\tfi\n\t@if ! git diff-files --quiet || ! git diff-index --quiet --cached HEAD; then \\\n\t\tgit status -s; \\\n\t\techo; \\\n\t\techo \"You have uncomitted changes.  Please commit or stash them.\"; \\\n\t\tfalse; \\\n\tfi\n\t@if test -n \"`git status -s`\"; then \\\n\t\tgit status -s; \\\n\t\tread -p \"Untracked files will not be handed in.  Continue? [y/N] \" r; \\\n\t\ttest \"$$r\" = y; \\\n\tfi\n\nUPSTREAM := $(shell git remote -v | grep \"pdos.csail.mit.edu/6.828/2018/jos.git (fetch)\" | awk '{split($$0,a,\" \"); print a[1]}')\n\ntarball-pref: handin-check\n\t@SUF=$(LAB); \\\n\tif test $(LAB) -eq 3 -o $(LAB) -eq 4; then \\\n\t\tread -p \"Which part would you like to submit? [a, b, c (c for lab 4 only)]\" p; \\\n\t\tif test \"$$p\" != a -a \"$$p\" != b; then \\\n\t\t\tif test ! $(LAB) -eq 4 -o ! \"$$p\" = c; then \\\n\t\t\t\techo \"Bad part \\\"$$p\\\"\"; \\\n\t\t\t\texit 1; \\\n\t\t\tfi; \\\n\t\tfi; \\\n\t\tSUF=\"$(LAB)$$p\"; \\\n\t\techo $$SUF > .suf; \\\n\telse \\\n\t\trm -f .suf; \\\n\tfi; \\\n\tgit archive --format=tar HEAD > lab$$SUF-handin.tar; \\\n\tgit diff $(UPSTREAM)/lab$(LAB) > /tmp/lab$$SUF-diff.patch; \\\n\ttar -rf lab$$SUF-handin.tar /tmp/lab$$SUF-diff.patch; \\\n\tgzip -c lab$$SUF-handin.tar > lab$$SUF-handin.tar.gz; \\\n\trm lab$$SUF-handin.tar; \\\n\trm /tmp/lab$$SUF-diff.patch; \\\n\nmyapi.key:\n\t@echo Get an API key for yourself by visiting $(WEBSUB)/\n\t@read -p \"Please enter your API key: \" k; \\\n\tif test `echo \"$$k\" |tr -d '\\n' |wc -c` = 32 ; then \\\n\t\tTF=`mktemp -t tmp.XXXXXX`; \\\n\t\tif test \"x$$TF\" != \"x\" ; then \\\n\t\t\techo \"$$k\" |tr -d '\\n' > $$TF; \\\n\t\t\tmv -f $$TF $@; \\\n\t\telse \\\n\t\t\techo mktemp failed; \\\n\t\t\tfalse; \\\n\t\tfi; \\\n\telse \\\n\t\techo Bad API key: $$k; \\\n\t\techo An API key should be 32 characters long.; \\\n\t\tfalse; \\\n\tfi;\n\n#handin-prep:\n#\t@./handin-prep\n\n# For test runs\nprep-net_%: override INIT_CFLAGS+=-DTEST_NO_NS\n\nprep-%:\n\t$(V)$(MAKE) \"INIT_CFLAGS=${INIT_CFLAGS} -DTEST=`case $* in *_*) echo $*;; *) echo user_$*;; esac`\" $(IMAGES)\n\nrun-%-nox-gdb: prep-% pre-qemu\n\t$(QEMU) -nographic $(QEMUOPTS) -S\n\nrun-%-gdb: prep-% pre-qemu\n\t$(QEMU) $(QEMUOPTS) -S\n\nrun-%-nox: prep-% pre-qemu\n\t$(QEMU) -nographic $(QEMUOPTS)\n\nrun-%: prep-% pre-qemu\n\t$(QEMU) $(QEMUOPTS)\n\n# For network connections\nwhich-ports:\n\t@echo \"Local port $(PORT7) forwards to JOS port 7 (echo server)\"\n\t@echo \"Local port $(PORT80) forwards to JOS port 80 (web server)\"\n\nnc-80:\n\tnc localhost $(PORT80)\n\nnc-7:\n\tnc localhost $(PORT7)\n\ntelnet-80:\n\ttelnet localhost $(PORT80)\n\ntelnet-7:\n\ttelnet localhost $(PORT7)\n\n# This magic automatically generates makefile dependencies\n# for header files included from C source files we compile,\n# and keeps those dependencies up-to-date every time we recompile.\n# See 'mergedep.pl' for more information.\n$(OBJDIR)/.deps: $(foreach dir, $(OBJDIRS), $(wildcard $(OBJDIR)/$(dir)/*.d))\n\t@mkdir -p $(@D)\n\t@$(PERL) mergedep.pl $@ $^\n\n-include $(OBJDIR)/.deps\n\nalways:\n\t@:\n\n.PHONY: all always \\\n\thandin git-handin tarball tarball-pref clean realclean distclean grade handin-prep handin-check\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.9033203125,
          "content": "# [MIT6.828官网](https://pdos.csail.mit.edu/6.828/2018/schedule.html)\nMIT6.828 是 MIT 开源的一门操作系统课程--理论与实践相结合的经典。只要你跟着项目一步一步走，做完 6 个实验，就能实现一个简单的操作系统内核。\n\n每个实验都有对应的知识点供你学习（也可以自行查找资料)，学完理论知识后会有相应的练习，大多数都需要你手写代码。\n\n边学边做，学习效果更加高效。\n\n做这个项目之前建议看看下列资料：\n* [x86汇编语言:从实模式到保护模式](https://book.douban.com/subject/20492528/)\n* [xv6-chinese](https://github.com/ranxian/xv6-chinese)\n* [操作系统导论](https://book.douban.com/subject/33463930/)或任意一本操作系统书籍\n\n具体的实验代码请切换到对应的分支查看。\n\n## 实验参考资料\n### 0. [MIT6.828 实验环境安装教程](https://github.com/woai3c/MIT6.828/blob/master/docs/install.md)\n### 1. Lab1 参考资料\n* [Lab1:Booting a PC](https://www.cnblogs.com/gatsby123/p/9759153.html)\n* [《MIT 6.828 Lab 1 Exercise 12》实验报告](https://www.cnblogs.com/wuhualong/p/lab01_exercise12_print_more_info.html)\n* [MIT6.828操作系统工程Lab1-Booting a PC实验报告](https://blog.codedragon.tech/2017/12/09/MIT6-828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8BLab1-Booting-a-PC%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/)\n* [MIT6.828操作系统实验—之启动PC](https://liu-jianhao.github.io/2018/08/mit6.828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B9%8B%E5%90%AF%E5%8A%A8pc/)\n* [Linux-C逆向工程基础：简单的栈溢出漏洞展示](http://www.xumenger.com/linux-c-asm-5-20180606/)\n* [《MIT JOS Lab1: Booting a PC》实验报告](https://blog.csdn.net/qq_32473685/article/details/93626548#9.4%20%C2%A0%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8eip%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%A1%8C%E5%8F%B7)\n\n### 2. Lab2 参考资料\n* [MIT-6.828 Lab 2: Memory Management实验报告](https://www.cnblogs.com/gatsby123/p/9832223.html)\n* [《MIT JOS Lab2: Memory Management》实验报告](https://blog.csdn.net/qq_32473685/article/details/99625128)\n* [MIT6.828操作系统工程Lab2-Memory Management实验报告](https://blog.codedragon.tech/2018/02/20/MIT6-828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8BLab2-Memory-Management%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/)\n### 3. Lab3 参考资料\n* [Lab 3: User Environments实验报告](https://www.cnblogs.com/gatsby123/p/9838304.html)\n* [MIT6.828操作系统工程Lab3-User Environments实验报告](https://blog.codedragon.tech/2018/02/23/MIT6-828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8BLab3-User-Environments%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/)\n### 4. Lab4 参考资料\n* [Lab 4: Preemptive Multitasking](https://www.cnblogs.com/gatsby123/p/9930630.html)\n* [MIT6.828操作系统工程Lab4-Preemptive Multitasking实验报告](https://blog.codedragon.tech/2018/02/26/MIT6-828%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E7%A8%8BLab4-Preemptive-Multitasking%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/)\n\n### 5. Lab5 参考资料\n* [Lab 5: File system, Spawn and Shell](https://www.cnblogs.com/gatsby123/p/9950705.html)\n\n### 6. Lab6 参考资料\n* [MIT-6.828 Lab 6: Network Driver (default final project)](https://www.cnblogs.com/gatsby123/p/10080311.html)\n\n## 总结\n* [Lab1](https://github.com/woai3c/MIT6.828/blob/master/docs/lab1.md)\n* [Lab2](https://github.com/woai3c/MIT6.828/blob/master/docs/lab2.md)\n* [Lab3](https://github.com/woai3c/MIT6.828/blob/master/docs/lab3.md)\n* [Lab4](https://github.com/woai3c/MIT6.828/blob/master/docs/lab4.md)\n* [Lab5](https://github.com/woai3c/MIT6.828/blob/master/docs/lab5.md)\n\n## 其他参考资料\n* [IA-32处理器常用整数指令分类一览](http://www5.zzu.edu.cn/qwfw/info/1042/2434.htm)\n* [Intel 80386 程序员参考手册](https://www.kancloud.cn/wizardforcel/intel-80386-ref-manual/123813)\n* [STABS](https://sourceware.org/gdb/onlinedocs/stabs.html#Overview)\n"
        },
        {
          "name": "boot",
          "type": "tree",
          "content": null
        },
        {
          "name": "conf",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "fs",
          "type": "tree",
          "content": null
        },
        {
          "name": "grade-lab1",
          "type": "blob",
          "size": 1.322265625,
          "content": "#!/usr/bin/env python\n\nimport re\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\n@test(0, \"running JOS\")\ndef test_jos():\n    r.run_qemu()\n\n@test(20, parent=test_jos)\ndef test_printf():\n    r.match(\"6828 decimal is 15254 octal!\")\n\nBACKTRACE_RE = r\"^ *ebp +f01[0-9a-z]{5} +eip +f0100[0-9a-z]{3} +args +([0-9a-z]+)\"\n\n@test(10, parent=test_jos)\ndef test_backtrace_count():\n    matches = re.findall(BACKTRACE_RE, r.qemu.output, re.MULTILINE)\n    assert_equal(len(matches), 8)\n\n@test(10, parent=test_jos)\ndef test_backtrace_arguments():\n    matches = re.findall(BACKTRACE_RE, r.qemu.output, re.MULTILINE)\n    assert_equal(\"\\n\".join(matches[:7]),\n                 \"\\n\".join(\"%08x\" % n for n in [0,0,1,2,3,4,5]))\n\n@test(5, parent=test_jos)\ndef test_backtrace_symbols():\n    matches = re.findall(r\"kern/init.c:[0-9]+: +([^+]*)\\+\", r.qemu.output)\n    assert_equal(\"\\n\".join(matches[:7]),\n                 \"\\n\".join([\"test_backtrace\"] * 6 + [\"i386_init\"]))\n\n@test(5, parent=test_jos)\ndef test_backtrace_lines():\n    matches = re.findall(r\"([^ ]*init.c:([0-9]+):) +test_backtrace\\+\", r.qemu.output)\n    assert matches, \"No line numbers\"\n    if any(int(m[1]) < 5 or int(m[1]) > 50 for m in matches):\n        assert_equal(\"\\n\".join(m[0] for m in matches),\n                     \"Line numbers between 5 and 50\")\n\nrun_tests()\n"
        },
        {
          "name": "grade-lab2",
          "type": "blob",
          "size": 0.689453125,
          "content": "#!/usr/bin/env python\n\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\n@test(0, \"running JOS\")\ndef test_jos():\n    r.run_qemu()\n\n@test(20, \"Physical page allocator\", parent=test_jos)\ndef test_check_page_alloc():\n    r.match(r\"check_page_alloc\\(\\) succeeded!\")\n\n@test(20, \"Page management\", parent=test_jos)\ndef test_check_page():\n    r.match(r\"check_page\\(\\) succeeded!\")\n\n@test(20, \"Kernel page directory\", parent=test_jos)\ndef test_check_kern_pgdir():\n    r.match(r\"check_kern_pgdir\\(\\) succeeded!\")\n\n@test(10, \"Page management 2\", parent=test_jos)\ndef test_check_page_installed_pgdir():\n    r.match(r\"check_page_installed_pgdir\\(\\) succeeded!\")\n\nrun_tests()\n"
        },
        {
          "name": "grade-lab3",
          "type": "blob",
          "size": 4.1142578125,
          "content": "#!/usr/bin/env python\n\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\n@test(10)\ndef test_divzero():\n    r.user_test(\"divzero\")\n    r.match('Incoming TRAP frame at 0xefffff..',\n            'TRAP frame at 0xf.......',\n            '  trap 0x00000000 Divide error',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            '.00001000. free env 00001000',\n            no=['1/0 is ........!'])\n\n@test(10)\ndef test_softint():\n    r.user_test(\"softint\")\n    r.match('Welcome to the JOS kernel monitor!',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000d General Protection',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            '.00001000. free env 0000100')\n\n@test(10)\ndef test_badsegment():\n    r.user_test(\"badsegment\")\n    r.match('Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000d General Protection',\n            '  err  0x00000028',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            '.00001000. free env 0000100')\n\nend_part(\"A\")\n\n@test(5)\ndef test_faultread():\n    r.user_test(\"faultread\")\n    r.match('.00001000. user fault va 00000000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000004.*',\n            '.00001000. free env 0000100',\n            no=['I read ........ from location 0!'])\n\n@test(5)\ndef test_faultreadkernel():\n    r.user_test(\"faultreadkernel\")\n    r.match('.00001000. user fault va f0100000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000005.*',\n            '.00001000. free env 00001000',\n            no=['I read ........ from location 0xf0100000!'])\n\n@test(5)\ndef test_faultwrite():\n    r.user_test(\"faultwrite\")\n    r.match('.00001000. user fault va 00000000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000006.*',\n            '.00001000. free env 0000100')\n\n@test(5)\ndef test_faultwritekernel():\n    r.user_test(\"faultwritekernel\")\n    r.match('.00001000. user fault va f0100000 ip 008.....',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x0000000e Page Fault',\n            '  err  0x00000007.*',\n            '.00001000. free env 0000100')\n\n@test(5)\ndef test_breakpoint():\n    r.user_test(\"breakpoint\")\n    r.match('Welcome to the JOS kernel monitor!',\n            'Incoming TRAP frame at 0xefffffbc',\n            'TRAP frame at 0xf.......',\n            '  trap 0x00000003 Breakpoint',\n            '  eip  0x008.....',\n            '  ss   0x----0023',\n            no=['.00001000. free env 00001000'])\n\n@test(5)\ndef test_testbss():\n    r.user_test(\"testbss\")\n    r.match('Making sure bss works right...',\n            'Yes, good.  Now doing a wild write off the end...',\n            '.00001000. user fault va 00c..... ip 008.....',\n            '.00001000. free env 0000100')\n\n@test(5)\ndef test_hello():\n    r.user_test(\"hello\")\n    r.match('.00000000. new env 00001000',\n            'hello, world',\n            'i am environment 00001000',\n            '.00001000. exiting gracefully',\n            '.00001000. free env 00001000',\n            'Destroyed the only environment - nothing more to do!')\n\n@test(5)\ndef test_buggyhello():\n    r.user_test(\"buggyhello\")\n    r.match('.00001000. user_mem_check assertion failure for va 00000001',\n            '.00001000. free env 00001000')\n\n@test(5)\ndef test_buggyhello2():\n    r.user_test(\"buggyhello2\")\n    r.match('.00001000. user_mem_check assertion failure for va 0....000',\n            '.00001000. free env 00001000',\n            no=['hello, world'])\n\n@test(5)\ndef test_evilhello():\n    r.user_test(\"evilhello\")\n    r.match('.00001000. user_mem_check assertion failure for va f0100...',\n            '.00001000. free env 00001000')\n\nend_part(\"B\")\n\nrun_tests()\n"
        },
        {
          "name": "grade-lab4",
          "type": "blob",
          "size": 5.9736328125,
          "content": "#!/usr/bin/env python\n\nimport re\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\ndef E(s, trim=False):\n    \"\"\"Expand $En in s to the environment ID of the n'th user\n    environment.\"\"\"\n\n    tmpl = \"%x\" if trim else \"%08x\"\n    return re.sub(r\"\\$E([0-9]+)\",\n                  lambda m: tmpl % (0x1000 + int(m.group(1))-1), s)\n\n@test(5)\ndef test_dumbfork():\n    r.user_test(\"dumbfork\")\n    r.match(E(\".00000000. new env $E1\"),\n            E(\".$E1. new env $E2\"),\n            \"0: I am the parent.\",\n            \"9: I am the parent.\",\n            \"0: I am the child.\",\n            \"9: I am the child.\",\n            \"19: I am the child.\",\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E1. free env $E1\"),\n            E(\".$E2. exiting gracefully\"),\n            E(\".$E2. free env $E2\"))\n\nend_part(\"A\")\n\n@test(5)\ndef test_faultread():\n    r.user_test(\"faultread\")\n    r.match(E(\".$E1. user fault va 00000000 ip 008.....\"),\n            \"TRAP frame at 0xf....... from CPU .\",\n            \"  trap 0x0000000e Page Fault\",\n            \"  err  0x00000004.*\",\n            E(\".$E1. free env $E1\"),\n            no=[\"I read ........ from location 0.\"])\n\n@test(5)\ndef test_faultwrite():\n    r.user_test(\"faultwrite\")\n    r.match(E(\".$E1. user fault va 00000000 ip 008.....\"),\n            \"TRAP frame at 0xf....... from CPU .\",\n            \"  trap 0x0000000e Page Fault\",\n            \"  err  0x00000006.*\",\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_faultdie():\n    r.user_test(\"faultdie\")\n    r.match(\"i faulted at va deadbeef, err 6\",\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_faultregs():\n    r.user_test(\"faultregs\")\n    r.match(\"Registers in UTrapframe OK\",\n            \"Registers after page-fault OK\",\n            no=[\"Registers in UTrapframe MISMATCH\",\n                \"Registers after page-fault MISMATCH\"])\n\n@test(5)\ndef test_faultalloc():\n    r.user_test(\"faultalloc\")\n    r.match(\"fault deadbeef\",\n            \"this string was faulted in at deadbeef\",\n            \"fault cafebffe\",\n            \"fault cafec000\",\n            \"this string was faulted in at cafebffe\",\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_faultallocbad():\n    r.user_test(\"faultallocbad\")\n    r.match(E(\".$E1. user_mem_check assertion failure for va deadbeef\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_faultnostack():\n    r.user_test(\"faultnostack\")\n    r.match(E(\".$E1. user_mem_check assertion failure for va eebfff..\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_faultbadhandler():\n    r.user_test(\"faultbadhandler\")\n    r.match(E(\".$E1. user_mem_check assertion failure for va (deadb|eebfe)...\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_faultevilhandler():\n    r.user_test(\"faultevilhandler\")\n    r.match(E(\".$E1. user_mem_check assertion failure for va (f0100|eebfe)...\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_forktree():\n    r.user_test(\"forktree\")\n    r.match(\"....: I am .0.\",\n            \"....: I am .1.\",\n            \"....: I am .000.\",\n            \"....: I am .100.\",\n            \"....: I am .110.\",\n            \"....: I am .111.\",\n            \"....: I am .011.\",\n            \"....: I am .001.\",\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E2. exiting gracefully\"),\n            \".0000200.. exiting gracefully\",\n            \".0000200.. free env 0000200.\")\n\nend_part(\"B\")\n\n@test(5)\ndef test_spin():\n    r.user_test(\"spin\")\n    r.match(E(\".00000000. new env $E1\"),\n            \"I am the parent.  Forking the child...\",\n            E(\".$E1. new env $E2\"),\n            \"I am the parent.  Running the child...\",\n            \"I am the child.  Spinning...\",\n            \"I am the parent.  Killing the child...\",\n            E(\".$E1. destroying $E2\"),\n            E(\".$E1. free env $E2\"),\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E1. free env $E1\"))\n\n@test(5)\ndef test_stresssched():\n    r.user_test(\"stresssched\", make_args=[\"CPUS=4\"])\n    r.match(\".000010... stresssched on CPU 0\",\n            \".000010... stresssched on CPU 1\",\n            \".000010... stresssched on CPU 2\",\n            \".000010... stresssched on CPU 3\",\n            no=[\".*ran on two CPUs at once\"])\n\n@test(5)\ndef test_sendpage():\n    r.user_test(\"sendpage\", make_args=[\"CPUS=2\"])\n    r.match(\".00000000. new env 00001000\",\n            E(\".00000000. new env $E1\"),\n            E(\".$E1. new env $E2\"),\n            E(\"$E1 got message: hello child environment! how are you?\", trim=True),\n            E(\"child received correct message\", trim=True),\n            E(\"$E2 got message: hello parent environment! I'm good\", trim=True),\n            E(\"parent received correct message\", trim=True),\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E1. free env $E1\"),\n            E(\".$E2. exiting gracefully\"),\n            E(\".$E2. free env $E2\"))\n\n@test(5)\ndef test_pingpong():\n    r.user_test(\"pingpong\", make_args=[\"CPUS=4\"])\n    r.match(E(\".00000000. new env $E1\"),\n            E(\".$E1. new env $E2\"),\n            E(\"send 0 from $E1 to $E2\", trim=True),\n            E(\"$E2 got 0 from $E1\", trim=True),\n            E(\"$E1 got 1 from $E2\", trim=True),\n            E(\"$E2 got 8 from $E1\", trim=True),\n            E(\"$E1 got 9 from $E2\", trim=True),\n            E(\"$E2 got 10 from $E1\", trim=True),\n            E(\".$E1. exiting gracefully\"),\n            E(\".$E1. free env $E1\"),\n            E(\".$E2. exiting gracefully\"),\n            E(\".$E2. free env $E2\"))\n\n@test(5)\ndef test_primes():\n    r.user_test(\"primes\", stop_on_line(\"CPU .: 1877\"), stop_on_line(\".*panic\"),\n                make_args=[\"CPUS=4\"], timeout=60)\n    r.match(E(\".00000000. new env $E1\"),\n            E(\".$E1. new env $E2\"),\n            E(\"CPU .: 2 .$E2. new env $E3\"),\n            E(\"CPU .: 3 .$E3. new env $E4\"),\n            E(\"CPU .: 5 .$E4. new env $E5\"),\n            E(\"CPU .: 7 .$E5. new env $E6\"),\n            E(\"CPU .: 11 .$E6. new env $E7\"),\n            E(\"CPU .: 1877 .$E289. new env $E290\"))\n\nend_part(\"C\")\n\nrun_tests()\n"
        },
        {
          "name": "grade-lab5",
          "type": "blob",
          "size": 3.1806640625,
          "content": "#!/usr/bin/env python\n\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\ndef matchtest(parent, name, *args, **kw):\n    def do_test():\n        r.match(*args, **kw)\n    test(5, name, parent=parent)(do_test)\n\n@test(5, \"internal FS tests [fs/test.c]\")\ndef test_fs():\n    r.user_test(\"hello\")\nmatchtest(test_fs, \"fs i/o\",\n          \"FS can do I/O\")\nmatchtest(test_fs, \"check_bc\",\n          \"block cache is good\")\nmatchtest(test_fs, \"check_super\",\n          \"superblock is good\")\nmatchtest(test_fs, \"check_bitmap\",\n          \"bitmap is good\")\nmatchtest(test_fs, \"alloc_block\",\n          \"alloc_block is good\")\nmatchtest(test_fs, \"file_open\",\n          \"file_open is good\")\nmatchtest(test_fs, \"file_get_block\",\n          \"file_get_block is good\")\nmatchtest(test_fs, \"file_flush/file_truncate/file rewrite\",\n          \"file_flush is good\",\n          \"file_truncate is good\",\n          \"file rewrite is good\")\n\n@test(10, \"testfile\")\ndef test_testfile():\n    r.user_test(\"testfile\")\nmatchtest(test_testfile, \"serve_open/file_stat/file_close\",\n          \"serve_open is good\",\n          \"file_stat is good\",\n          \"file_close is good\",\n          \"stale fileid is good\")\nmatchtest(test_testfile, \"file_read\",\n          \"file_read is good\")\nmatchtest(test_testfile, \"file_write\",\n          \"file_write is good\")\nmatchtest(test_testfile, \"file_read after file_write\",\n          \"file_read after file_write is good\")\nmatchtest(test_testfile, \"open\",\n          \"open is good\")\nmatchtest(test_testfile, \"large file\",\n          \"large file is good\")\n\n@test(10, \"spawn via spawnhello\")\ndef test_spawn():\n    r.user_test(\"spawnhello\")\n    r.match('i am parent environment 00001001',\n            'hello, world',\n            'i am environment 00001002',\n            'No runnable environments in the system!')\n\n@test(5, \"Protection I/O space\")\ndef test_faultio():\n    r.user_test(\"spawnfaultio\")\n    r.match('TRAP')\n\n@test(10, \"PTE_SHARE [testpteshare]\")\ndef test_pte_share():\n    r.user_test(\"testpteshare\")\n    r.match('fork handles PTE_SHARE right',\n            'spawn handles PTE_SHARE right')\n\n@test(5, \"PTE_SHARE [testfdsharing]\")\ndef test_fd_share():\n    r.user_test(\"testfdsharing\")\n    r.match('read in child succeeded',\n            'read in parent succeeded')\n\n@test(10, \"start the shell [icode]\")\ndef test_icode():\n    r.user_test(\"icode\")\n    r.match('icode: read /motd',\n            'This is /motd, the message of the day.',\n            'icode: spawn /init',\n            'init: running',\n            'init: data seems okay',\n            'icode: exiting',\n            'init: bss seems okay',\n            \"init: args: 'init' 'initarg1' 'initarg2'\",\n            'init: running sh',\n            '\\$ ')\n\n@test(15)\ndef test_testshell():\n    r.user_test(\"testshell\", timeout=60)\n    r.match(\"shell ran correctly\")\n\ndef gen_primes(n):\n    rest = range(2, n)\n    while rest:\n        yield rest[0]\n        rest = [n for n in rest if n % rest[0]]\n\n@test(10)\ndef test_primespipe():\n    r.user_test(\"primespipe\", stop_on_line(\"[0-9]{4}$\"), timeout=120)\n    primes = set(gen_primes(1000))\n    nonprimes = set(range(1000)) - primes\n    r.match(no=[\"%d$\" % np for np in nonprimes],\n            *[\"%d$\" % p for p in primes])\n\nrun_tests()\n"
        },
        {
          "name": "grade-lab6",
          "type": "blob",
          "size": 7.7412109375,
          "content": "#!/usr/bin/env python\n\nimport os, re, threading, socket, time, shutil, struct, difflib\ntry:\n    from urllib2 import urlopen, HTTPError\nexcept ImportError:\n    # Python 3\n    from urllib.request import urlopen\n    from urllib.error import HTTPError\nfrom gradelib import *\n\nr = Runner(save(\"jos.out\"),\n           stop_breakpoint(\"readline\"))\n\ndef match_packet_seq(got, expect):\n    got, expect = list(got), list(expect)\n    s = difflib.SequenceMatcher(None, got, [d for n, d in expect])\n    msgs, bad = [], False\n    for tag, i1, i2, j1, j2 in s.get_opcodes():\n        wrong = []\n        if tag in (\"delete\", \"replace\"):\n            wrong.append([(\"unexpected packet:\", pkt) for pkt in got[i1:i2]])\n        if tag in (\"insert\", \"replace\"):\n            wrong.append([(\"missing %s:\" % n, pkt) for n, pkt in expect[j1:j2]])\n        for seq in wrong:\n            bad = True\n            for msg, pkt in seq[:3]:\n                msgs.append(color(\"red\", msg) + \"\\n\" + hexdump(pkt))\n            if seq[3:]:\n                msgs.append(\"... plus %d more\" % len(seq[3:]))\n\n        if tag == \"equal\":\n            msgs.append(color(\"green\", \"got \") + expect[j1][0])\n            if j1 + 1 < j2:\n                msgs[-1] += \" through \" + expect[j2 - 1][0]\n    assert not bad, \"\\n\".join(msgs)\n\ndef save_pcap_on_fail():\n    def save_pcap(fail):\n        save_path = \"qemu.pcap.\" + get_current_test().__name__[5:]\n        if fail and os.path.exists(\"qemu.pcap\"):\n            shutil.copyfile(\"qemu.pcap\", save_path)\n            print(\"    Packet capture saved to %s\" % save_path)\n        elif not fail and os.path.exists(save_path):\n            os.unlink(save_path)\n            print(\"    (Old %s failed packet capture deleted)\" % save_path)\n    get_current_test().on_finish.append(save_pcap)\n\ndef read_pcap():\n    f = open(\"qemu.pcap\", \"rb\")\n    s = struct.Struct(\"=IHHiIII\")\n    hdr = s.unpack(f.read(s.size))\n    assert_equal(hdr[0], 0xa1b2c3d4, \"Bad pcap magic number\")\n    assert_equal((hdr[1], hdr[2]), (2, 4), \"Bad pcap version number\")\n    s = struct.Struct(\"=iiII\")\n    while True:\n        hdr_data = f.read(s.size)\n        if not len(hdr_data):\n            return\n        hdr = s.unpack(hdr_data)\n        yield bytes(f.read(hdr[2]))\n\ndef ascii_to_bytes(s):\n    if bytes == str:\n        # Python 2\n        return s\n    else:\n        # Python 3\n        return bytes(s, \"ascii\")\n\ndef hexdump(data):\n    data = bytearray(data)\n    buf = []\n    for i in range(0, len(data), 16):\n        chunk = data[i:i+16]\n        hd = \"\".join(\"%02x\" % b for b in chunk)\n        hd = \" \".join(hd[j:j+4] for j in range(0, len(hd), 4))\n        ad = \"\".join(chr(c) if chr(c).isalnum() else \".\" for c in chunk)\n        buf.append(\"%04x   %-40s  %s\" % (i, hd, ad))\n    return \"\\n\".join(buf)\n\necho_port = QEMU.get_gdb_port() + 1\nhttp_port = QEMU.get_gdb_port() + 2\n\nsocket.setdefaulttimeout(5)\n\n#\n# Basic tests\n#\n\n@test(5)\ndef test_testtime():\n    r.user_test(\"testtime\", make_args=[\"INIT_CFLAGS=-DTEST_NO_NS\"])\n    r.match(r'starting count down: 5 4 3 2 1 0 ')\n\n@test(5)\ndef test_pci_attach():\n    r.user_test(\"hello\", make_args=[\"INIT_CFLAGS=-DTEST_NO_NS\"])\n    r.match(r'PCI function 00:03.0 \\(8086:100e\\) enabled')\n\n#\n# testoutput\n#\n\ndef test_testoutput_helper(count):\n    save_pcap_on_fail()\n\n    maybe_unlink(\"qemu.pcap\")\n    r.user_test(\"net_testoutput\",\n                make_args=[\"NET_CFLAGS=-DTESTOUTPUT_COUNT=%d\" % count])\n\n    # Check the packet capture\n    got = list(read_pcap())\n    expect = [(\"packet %d/%d\" % (i+1, count), ascii_to_bytes(\"Packet %02d\" % i))\n              for i in range(count)]\n    match_packet_seq(got, expect)\n\n@test(15, \"testoutput [5 packets]\")\ndef test_testoutput_5():\n    test_testoutput_helper(5)\n\n@test(10, \"testoutput [100 packets]\")\ndef test_testoutput_100():\n    test_testoutput_helper(100)\n\nend_part(\"A\")\n\n#\n# testinput\n#\n\ndef test_testinput_helper(count):\n    save_pcap_on_fail()\n    maybe_unlink(\"qemu.pcap\")\n\n    def send_packets():\n        # Send 'count' UDP packets\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.connect((\"127.0.0.1\", echo_port))\n        for i in range(count):\n            sock.send(ascii_to_bytes(\"Packet %03d\" % i))\n    send_thread = threading.Thread(target=send_packets)\n\n    # When we see the final packet, we can stop QEMU\n    digits = \"%03d\" % (count-1)\n    final = \"input: 0030   203%s 3%s3%s\" % tuple(\"%03d\" % (count-1))\n\n    r.user_test(\"net_testinput\",\n                call_on_line(\"Waiting for packets\",\n                              lambda _: send_thread.start()),\n                stop_on_line(final))\n    if send_thread.isAlive():\n        send_thread.join()\n\n    # Parse testinput hexdumps for received packets\n    got = []\n    for off, dump in re.findall(\"input: ([0-9a-f]{4})   ([0-9a-f ]*)\\n\",\n                                r.qemu.output):\n        if off == \"0000\" or not got:\n            got.append(bytearray())\n        dump = dump.replace(\" \", \"\")\n        for i in range(0, len(dump), 2):\n            got[-1].append(int(dump[i:i+2], 16))\n    got = map(bytes, got)\n\n    # Get the packets QEMU actually received, since there's some\n    # header information we can't easily guess.\n    pcap = list(read_pcap())\n    if len(pcap) != count + 2:\n        raise RuntimeError(\"pcap contains only %d packets\" % len(pcap))\n    # Strip transmitted ARP request\n    assert pcap.pop(0)[:6] == b\"\\xff\" * 6, \"First packet is not ARP request\"\n    # The E1000 pads packets out to a 60 byte frame\n    pcap = [pkt.ljust(60, b\"\\0\") for pkt in pcap]\n\n    names = [\"ARP reply\"] + [\"packet %d/%d\" % (i+1, count)\n                             for i in range(count)]\n    match_packet_seq(got, zip(names, pcap))\n\n@test(15, \"testinput [5 packets]\")\ndef test_testinput_5():\n    test_testinput_helper(5)\n\n@test(10, \"testinput [100 packets]\")\ndef test_testinput_100():\n    test_testinput_helper(100)\n\n#\n# Servers\n#\n\n@test(15, \"tcp echo server [echosrv]\")\ndef test_echosrv():\n    def ready(line):\n        expect = ascii_to_bytes(\"%s: network server works\" % time.time())\n        got = bytearray()\n        sock = socket.socket()\n        try:\n            sock.settimeout(5)\n            sock.connect((\"127.0.0.1\", echo_port))\n            sock.sendall(expect)\n            while got != expect:\n                data = sock.recv(4096)\n                if not data:\n                    break\n                got += data\n        except socket.error as e:\n            got += \"[Socket error: %s]\" % e\n        finally:\n            sock.close()\n        assert_equal(got, expect)\n        raise TerminateTest\n\n    save_pcap_on_fail()\n    r.user_test(\"echosrv\", call_on_line(\"bound\", ready))\n    r.match(\"bound\", no=[\".*panic\"])\n\n@test(0, \"web server [httpd]\")\ndef test_httpd():\n    pass\n\ndef mk_test_httpd(url, expect_code, expect_data):\n    fullurl = \"http://localhost:%d%s\" % (http_port, url)\n    def test_httpd_test():\n        def ready(line):\n            try:\n                # This uses the default socket timeout (5 seconds)\n                res = urlopen(fullurl)\n                got = \"(Status 200)\\n\" + \\\n                    res.read().decode('utf-8')\n            except HTTPError as e:\n                got = \"(Status %d)\" % e.code\n            except IOError as e:\n                got = \"(Error: %s)\" % e\n            expect = \"(Status %d)\" % expect_code\n            if expect_data:\n                expect += \"\\n\" + expect_data\n            assert_equal(got, expect)\n            raise TerminateTest\n        save_pcap_on_fail()\n        r.user_test(\"httpd\",\n                    call_on_line('Waiting for http connections', ready))\n        r.match('Waiting for http connections',\n                no=[\".*panic\"])\n    test_httpd_test.__name__ += url.replace(\"/\", \"-\")\n    return test(10, fullurl, parent=test_httpd)(test_httpd_test)\nmk_test_httpd(\"/\", 404, \"\")\nmk_test_httpd(\"/index.html\", 200, open(\"fs/index.html\").read())\nmk_test_httpd(\"/random_file.txt\", 404, \"\")\n\nend_part(\"B\")\n\nrun_tests()\n"
        },
        {
          "name": "gradelib.py",
          "type": "blob",
          "size": 16.544921875,
          "content": "from __future__ import print_function\n\nimport sys, os, re, time, socket, select, subprocess, errno, shutil, traceback\nfrom subprocess import check_call, Popen\nfrom optparse import OptionParser\n\n__all__ = []\n\n##################################################################\n# Test structure\n#\n\n__all__ += [\"test\", \"end_part\", \"run_tests\", \"get_current_test\"]\n\nTESTS = []\nTOTAL = POSSIBLE = 0\nPART_TOTAL = PART_POSSIBLE = 0\nCURRENT_TEST = None\n\ndef test(points, title=None, parent=None):\n    \"\"\"Decorator for declaring test functions.  If title is None, the\n    title of the test will be derived from the function name by\n    stripping the leading \"test_\" and replacing underscores with\n    spaces.\"\"\"\n\n    def register_test(fn, title=title):\n        if not title:\n            assert fn.__name__.startswith(\"test_\")\n            title = fn.__name__[5:].replace(\"_\", \" \")\n        if parent:\n            title = \"  \" + title\n\n        def run_test():\n            global TOTAL, POSSIBLE, CURRENT_TEST\n\n            # Handle test dependencies\n            if run_test.complete:\n                return\n            run_test.complete = True\n            if parent:\n                parent()\n\n            # Run the test\n            fail = None\n            start = time.time()\n            CURRENT_TEST = run_test\n            sys.stdout.write(\"%s: \" % title)\n            sys.stdout.flush()\n            try:\n                fn()\n            except AssertionError as e:\n                fail = \"\".join(traceback.format_exception_only(type(e), e))\n\n            # Display and handle test result\n            POSSIBLE += points\n            if points:\n                print(\"%s\" % \\\n                    (color(\"red\", \"FAIL\") if fail else color(\"green\", \"OK\")), end=' ')\n            if time.time() - start > 0.1:\n                print(\"(%.1fs)\" % (time.time() - start), end=' ')\n            print()\n            if fail:\n                print(\"    %s\" % fail.replace(\"\\n\", \"\\n    \"))\n            else:\n                TOTAL += points\n            for callback in run_test.on_finish:\n                callback(fail)\n            CURRENT_TEST = None\n\n        # Record test metadata on the test wrapper function\n        run_test.__name__ = fn.__name__\n        run_test.title = title\n        run_test.complete = False\n        run_test.on_finish = []\n        TESTS.append(run_test)\n        return run_test\n    return register_test\n\ndef end_part(name):\n    def show_part():\n        global PART_TOTAL, PART_POSSIBLE\n        print(\"Part %s score: %d/%d\" % \\\n            (name, TOTAL - PART_TOTAL, POSSIBLE - PART_POSSIBLE))\n        print()\n        PART_TOTAL, PART_POSSIBLE = TOTAL, POSSIBLE\n    show_part.title = \"\"\n    TESTS.append(show_part)\n\ndef run_tests():\n    \"\"\"Set up for testing and run the registered test functions.\"\"\"\n\n    # Handle command line\n    global options\n    parser = OptionParser(usage=\"usage: %prog [-v] [filters...]\")\n    parser.add_option(\"-v\", \"--verbose\", action=\"store_true\",\n                      help=\"print commands\")\n    parser.add_option(\"--color\", choices=[\"never\", \"always\", \"auto\"],\n                      default=\"auto\", help=\"never, always, or auto\")\n    (options, args) = parser.parse_args()\n\n    # Start with a full build to catch build errors\n    make()\n\n    # Clean the file system if there is one\n    reset_fs()\n\n    # Run tests\n    limit = list(map(str.lower, args))\n    try:\n        for test in TESTS:\n            if not limit or any(l in test.title.lower() for l in limit):\n                test()\n        if not limit:\n            print(\"Score: %d/%d\" % (TOTAL, POSSIBLE))\n    except KeyboardInterrupt:\n        pass\n    if TOTAL < POSSIBLE:\n        sys.exit(1)\n\ndef get_current_test():\n    if not CURRENT_TEST:\n        raise RuntimeError(\"No test is running\")\n    return CURRENT_TEST\n\n##################################################################\n# Assertions\n#\n\n__all__ += [\"assert_equal\", \"assert_lines_match\"]\n\ndef assert_equal(got, expect, msg=\"\"):\n    if got == expect:\n        return\n    if msg:\n        msg += \"\\n\"\n    raise AssertionError(\"%sgot:\\n  %s\\nexpected:\\n  %s\" %\n                         (msg, str(got).replace(\"\\n\", \"\\n  \"),\n                          str(expect).replace(\"\\n\", \"\\n  \")))\n\ndef assert_lines_match(text, *regexps, **kw):\n    \"\"\"Assert that all of regexps match some line in text.  If a 'no'\n    keyword argument is given, it must be a list of regexps that must\n    *not* match any line in text.\"\"\"\n\n    def assert_lines_match_kw(no=[]):\n        return no\n    no = assert_lines_match_kw(**kw)\n\n    # Check text against regexps\n    lines = text.splitlines()\n    good = set()\n    bad = set()\n    for i, line in enumerate(lines):\n        if any(re.match(r, line) for r in regexps):\n            good.add(i)\n            regexps = [r for r in regexps if not re.match(r, line)]\n        if any(re.match(r, line) for r in no):\n            bad.add(i)\n\n    if not regexps and not bad:\n        return\n\n    # We failed; construct an informative failure message\n    show = set()\n    for lineno in good.union(bad):\n        for offset in range(-2, 3):\n            show.add(lineno + offset)\n    if regexps:\n        show.update(n for n in range(len(lines) - 5, len(lines)))\n\n    msg = []\n    last = -1\n    for lineno in sorted(show):\n        if 0 <= lineno < len(lines):\n            if lineno != last + 1:\n                msg.append(\"...\")\n            last = lineno\n            msg.append(\"%s %s\" % (color(\"red\", \"BAD \") if lineno in bad else\n                                  color(\"green\", \"GOOD\") if lineno in good\n                                  else \"    \",\n                                  lines[lineno]))\n    if last != len(lines) - 1:\n        msg.append(\"...\")\n    if bad:\n        msg.append(\"unexpected lines in output\")\n    for r in regexps:\n        msg.append(color(\"red\", \"MISSING\") + \" '%s'\" % r)\n    raise AssertionError(\"\\n\".join(msg))\n\n##################################################################\n# Utilities\n#\n\n__all__ += [\"make\", \"maybe_unlink\", \"reset_fs\", \"color\"]\n\nMAKE_TIMESTAMP = 0\n\ndef pre_make():\n    \"\"\"Delay prior to running make to ensure file mtimes change.\"\"\"\n    while int(time.time()) == MAKE_TIMESTAMP:\n        time.sleep(0.1)\n\ndef post_make():\n    \"\"\"Record the time after make completes so that the next run of\n    make can be delayed if needed.\"\"\"\n    global MAKE_TIMESTAMP\n    MAKE_TIMESTAMP = int(time.time())\n\ndef make(*target):\n    pre_make()\n    if Popen((\"make\",) + target).wait():\n        sys.exit(1)\n    post_make()\n\ndef show_command(cmd):\n    from pipes import quote\n    print(\"\\n$\", \" \".join(map(quote, cmd)))\n\ndef maybe_unlink(*paths):\n    for path in paths:\n        try:\n            os.unlink(path)\n        except EnvironmentError as e:\n            if e.errno != errno.ENOENT:\n                raise\n\nCOLORS = {\"default\": \"\\033[0m\", \"red\": \"\\033[31m\", \"green\": \"\\033[32m\"}\n\ndef color(name, text):\n    if options.color == \"always\" or (options.color == \"auto\" and os.isatty(1)):\n        return COLORS[name] + text + COLORS[\"default\"]\n    return text\n\ndef reset_fs():\n    if os.path.exists(\"obj/fs/clean-fs.img\"):\n        shutil.copyfile(\"obj/fs/clean-fs.img\", \"obj/fs/fs.img\")\n\n##################################################################\n# Controllers\n#\n\n__all__ += [\"QEMU\", \"GDBClient\"]\n\nclass QEMU(object):\n    _GDBPORT = None\n\n    def __init__(self, *make_args):\n        # Check that QEMU is not currently running\n        try:\n            GDBClient(self.get_gdb_port(), timeout=0).close()\n        except socket.error:\n            pass\n        else:\n            print(\"\"\"\\\nGDB stub found on port %d.\nQEMU appears to already be running.  Please exit it if possible or use\n'killall qemu' or 'killall qemu.real'.\"\"\" % self.get_gdb_port(), file=sys.stderr)\n            sys.exit(1)\n\n        if options.verbose:\n            show_command((\"make\",) + make_args)\n        cmd = (\"make\", \"-s\", \"--no-print-directory\") + make_args\n        self.proc = Popen(cmd, stdout=subprocess.PIPE,\n                          stderr=subprocess.STDOUT,\n                          stdin=subprocess.PIPE)\n        # Accumulated output as a string\n        self.output = \"\"\n        # Accumulated output as a bytearray\n        self.outbytes = bytearray()\n        self.on_output = []\n\n    @staticmethod\n    def get_gdb_port():\n        if QEMU._GDBPORT is None:\n            p = Popen([\"make\", \"-s\", \"--no-print-directory\", \"print-gdbport\"],\n                      stdout=subprocess.PIPE)\n            (out, _) = p.communicate()\n            if p.returncode:\n                raise RuntimeError(\n                    \"Failed to get gdbport: make exited with %d\" %\n                    p.returncode)\n            QEMU._GDBPORT = int(out)\n        return QEMU._GDBPORT\n\n    def fileno(self):\n        if self.proc:\n            return self.proc.stdout.fileno()\n\n    def handle_read(self):\n        buf = os.read(self.proc.stdout.fileno(), 4096)\n        self.outbytes.extend(buf)\n        self.output = self.outbytes.decode(\"utf-8\", \"replace\")\n        for callback in self.on_output:\n            callback(buf)\n        if buf == b\"\":\n            self.wait()\n            return\n\n    def wait(self):\n        if self.proc:\n            self.proc.wait()\n            self.proc = None\n\n    def kill(self):\n        if self.proc:\n            self.proc.terminate()\n\nclass GDBClient(object):\n    def __init__(self, port, timeout=15):\n        start = time.time()\n        while True:\n            self.sock = socket.socket()\n            try:\n                self.sock.settimeout(1)\n                self.sock.connect((\"localhost\", port))\n                break\n            except socket.error:\n                if time.time() >= start + timeout:\n                    raise\n        self.__buf = \"\"\n\n    def fileno(self):\n        if self.sock:\n            return self.sock.fileno()\n\n    def handle_read(self):\n        try:\n            data = self.sock.recv(4096).decode(\"ascii\", \"replace\")\n        except socket.error:\n            data = \"\"\n        if data == \"\":\n            self.sock.close()\n            self.sock = None\n            return\n        self.__buf += data\n\n        while True:\n            m = re.search(r\"\\$([^#]*)#[0-9a-zA-Z]{2}\", self.__buf)\n            if not m:\n                break\n            pkt = m.group(1)\n            self.__buf = self.__buf[m.end():]\n\n            if pkt.startswith(\"T05\"):\n                # Breakpoint\n                raise TerminateTest\n\n    def __send(self, cmd):\n        packet = \"$%s#%02x\" % (cmd, sum(map(ord, cmd)) % 256)\n        self.sock.sendall(packet.encode(\"ascii\"))\n\n    def __send_break(self):\n        self.sock.sendall(b\"\\x03\")\n\n    def close(self):\n        if self.sock:\n            self.sock.close()\n            self.sock = None\n\n    def cont(self):\n        self.__send(\"c\")\n\n    def breakpoint(self, addr):\n        self.__send(\"Z1,%x,1\" % addr)\n\n\n##################################################################\n# QEMU test runner\n#\n\n__all__ += [\"TerminateTest\", \"Runner\"]\n\nclass TerminateTest(Exception):\n    pass\n\nclass Runner():\n    def __init__(self, *default_monitors):\n        self.__default_monitors = default_monitors\n\n    def run_qemu(self, *monitors, **kw):\n        \"\"\"Run a QEMU-based test.  monitors should functions that will\n        be called with this Runner instance once QEMU and GDB are\n        started.  Typically, they should register callbacks that throw\n        TerminateTest when stop events occur.  The target_base\n        argument gives the make target to run.  The make_args argument\n        should be a list of additional arguments to pass to make.  The\n        timeout argument bounds how long to run before returning.\"\"\"\n\n        def run_qemu_kw(target_base=\"qemu\", make_args=[], timeout=30):\n            return target_base, make_args, timeout\n        target_base, make_args, timeout = run_qemu_kw(**kw)\n\n        # Start QEMU\n        pre_make()\n        self.qemu = QEMU(target_base + \"-nox-gdb\", *make_args)\n        self.gdb = None\n\n        try:\n            # Wait for QEMU to start or make to fail.  This will set\n            # self.gdb if QEMU starts.\n            self.qemu.on_output = [self.__monitor_start]\n            self.__react([self.qemu], timeout=30)\n            self.qemu.on_output = []\n            if self.gdb is None:\n                print(\"Failed to connect to QEMU; output:\")\n                print(self.qemu.output)\n                sys.exit(1)\n            post_make()\n\n            # QEMU and GDB are up\n            self.reactors = [self.qemu, self.gdb]\n\n            # Start monitoring\n            for m in self.__default_monitors + monitors:\n                m(self)\n\n            # Run and react\n            self.gdb.cont()\n            self.__react(self.reactors, timeout)\n        finally:\n            # Shutdown QEMU\n            try:\n                if self.gdb is None:\n                    sys.exit(1)\n                self.qemu.kill()\n                self.__react(self.reactors, 5)\n                self.gdb.close()\n                self.qemu.wait()\n            except:\n                print(\"\"\"\\\nFailed to shutdown QEMU.  You might need to 'killall qemu' or\n'killall qemu.real'.\n\"\"\")\n                raise\n\n    def __monitor_start(self, output):\n        if b\"\\n\" in output:\n            try:\n                self.gdb = GDBClient(self.qemu.get_gdb_port(), timeout=30)\n                raise TerminateTest\n            except socket.error:\n                pass\n        if not len(output):\n            raise TerminateTest\n\n    def __react(self, reactors, timeout):\n        deadline = time.time() + timeout\n        try:\n            while True:\n                timeleft = deadline - time.time()\n                if timeleft < 0:\n                    sys.stdout.write(\"Timeout! \")\n                    sys.stdout.flush()\n                    return\n\n                rset = [r for r in reactors if r.fileno() is not None]\n                if not rset:\n                    return\n\n                rset, _, _ = select.select(rset, [], [], timeleft)\n                for reactor in rset:\n                    reactor.handle_read()\n        except TerminateTest:\n            pass\n\n    def user_test(self, binary, *monitors, **kw):\n        \"\"\"Run a user test using the specified binary.  Monitors and\n        keyword arguments are as for run_qemu.  This runs on a disk\n        snapshot unless the keyword argument 'snapshot' is False.\"\"\"\n\n        maybe_unlink(\"obj/kern/init.o\", \"obj/kern/kernel\")\n        if kw.pop(\"snapshot\", True):\n            kw.setdefault(\"make_args\", []).append(\"QEMUEXTRA+=-snapshot\")\n        self.run_qemu(target_base=\"run-%s\" % binary, *monitors, **kw)\n\n    def match(self, *args, **kwargs):\n        \"\"\"Shortcut to call assert_lines_match on the most recent QEMU\n        output.\"\"\"\n\n        assert_lines_match(self.qemu.output, *args, **kwargs)\n\n##################################################################\n# Monitors\n#\n\n__all__ += [\"save\", \"stop_breakpoint\", \"call_on_line\", \"stop_on_line\"]\n\ndef save(path):\n    \"\"\"Return a monitor that writes QEMU's output to path.  If the\n    test fails, copy the output to path.test-name.\"\"\"\n\n    def setup_save(runner):\n        f.seek(0)\n        f.truncate()\n        runner.qemu.on_output.append(f.write)\n        get_current_test().on_finish.append(save_on_finish)\n\n    def save_on_finish(fail):\n        f.flush()\n        save_path = path + \".\" + get_current_test().__name__[5:]\n        if fail:\n            shutil.copyfile(path, save_path)\n            print(\"    QEMU output saved to %s\" % save_path)\n        elif os.path.exists(save_path):\n            os.unlink(save_path)\n            print(\"    (Old %s failure log removed)\" % save_path)\n\n    f = open(path, \"wb\")\n    return setup_save\n\ndef stop_breakpoint(addr):\n    \"\"\"Returns a monitor that stops when addr is reached.  addr may be\n    a number or the name of a symbol.\"\"\"\n\n    def setup_breakpoint(runner):\n        if isinstance(addr, str):\n            addrs = [int(sym[:8], 16) for sym in open(\"obj/kern/kernel.sym\")\n                     if sym[11:].strip() == addr]\n            assert len(addrs), \"Symbol %s not found\" % addr\n            runner.gdb.breakpoint(addrs[0])\n        else:\n            runner.gdb.breakpoint(addr)\n    return setup_breakpoint\n\ndef call_on_line(regexp, callback):\n    \"\"\"Returns a monitor that calls 'callback' when QEMU prints a line\n    matching 'regexp'.\"\"\"\n\n    def setup_call_on_line(runner):\n        buf = bytearray()\n        def handle_output(output):\n            buf.extend(output)\n            while b\"\\n\" in buf:\n                line, buf[:] = buf.split(b\"\\n\", 1)\n                line = line.decode(\"utf-8\", \"replace\")\n                if re.match(regexp, line):\n                    callback(line)\n        runner.qemu.on_output.append(handle_output)\n    return setup_call_on_line\n\ndef stop_on_line(regexp):\n    \"\"\"Returns a monitor that stops when QEMU prints a line matching\n    'regexp'.\"\"\"\n\n    def stop(line):\n        raise TerminateTest\n    return call_on_line(regexp, stop)\n"
        },
        {
          "name": "inc",
          "type": "tree",
          "content": null
        },
        {
          "name": "kern",
          "type": "tree",
          "content": null
        },
        {
          "name": "lib",
          "type": "tree",
          "content": null
        },
        {
          "name": "mergedep.pl",
          "type": "blob",
          "size": 2.2763671875,
          "content": "#!/usr/bin/perl\n# Copyright 2003 Bryan Ford\n# Distributed under the GNU General Public License.\n#\n# Usage: mergedep <main-depfile> [<new-depfiles> ...]\n#\n# This script merges the contents of all <new-depfiles> specified\n# on the command line into the single file <main-depfile>,\n# which may or may not previously exist.\n# Dependencies in the <new-depfiles> will override\n# any existing dependencies for the same targets in <main-depfile>.\n# The <new-depfiles> are deleted after <main-depfile> is updated.\n#\n# The <new-depfiles> are typically generated by GCC with the -MD option,\n# and the <main-depfile> is typically included from a Makefile,\n# as shown here for GNU 'make':\n#\n#\t.deps: $(wildcard *.d)\n#\t\tperl mergedep $@ $^\n#\t-include .deps\n#\n# This script properly handles multiple dependencies per <new-depfile>,\n# including dependencies having no target,\n# so it is compatible with GCC3's -MP option.\n#\n\nsub readdeps {\n\tmy $filename = shift;\n\n\topen(DEPFILE, $filename) or return 0;\n\twhile (<DEPFILE>) {\n\t\tif (/([^:]*):([^\\\\:]*)([\\\\]?)$/) {\n\t\t\tmy $target = $1;\n\t\t\tmy $deplines = $2;\n\t\t\tmy $slash = $3;\n\t\t\twhile ($slash ne '') {\n\t\t\t\t$_ = <DEPFILE>;\n\t\t\t\tdefined($_) or die\n\t\t\t\t\t\"Unterminated dependency in $filename\";\n\t\t\t\t/(^[ \\t][^\\\\]*)([\\\\]?)$/ or die\n\t\t\t\t\t\"Bad continuation line in $filename\";\n\t\t\t\t$deplines = \"$deplines\\\\\\n$1\";\n\t\t\t\t$slash = $2;\n\t\t\t}\n\t\t\t#print \"DEPENDENCY [[$target]]: [[$deplines]]\\n\";\n\t\t\t$dephash{$target} = $deplines;\n\t\t} elsif (/^[#]?[ \\t]*$/) {\n\t\t\t# ignore blank lines and comments\n\t\t} else {\n\t\t\tdie \"Bad dependency line in $filename: $_\";\n\t\t}\n\t}\n\tclose DEPFILE;\n\treturn 1;\n}\n\n\nif ($#ARGV < 0) {\n\tprint \"Usage: mergedep <main-depfile> [<new-depfiles> ..]\\n\";\n\texit(1);\n}\n\n%dephash = ();\n\n# Read the main dependency file\n$maindeps = $ARGV[0];\nreaddeps($maindeps);\n\n# Read and merge in the new dependency files\nforeach $i (1 .. $#ARGV) {\n\treaddeps($ARGV[$i]) or die \"Can't open $ARGV[$i]\";\n}\n\n# Update the main dependency file\nopen(DEPFILE, \">$maindeps.tmp\") or die \"Can't open output file $maindeps.tmp\";\nforeach $target (keys %dephash) {\n\tprint DEPFILE \"$target:$dephash{$target}\";\n}\nclose DEPFILE;\nrename(\"$maindeps.tmp\", \"$maindeps\") or die \"Can't overwrite $maindeps\";\n\n# Finally, delete the new dependency files\nforeach $i (1 .. $#ARGV) {\n\tunlink($ARGV[$i]) or print \"Error removing $ARGV[$i]\\n\";\n}\n\n"
        },
        {
          "name": "net",
          "type": "tree",
          "content": null
        },
        {
          "name": "user",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}