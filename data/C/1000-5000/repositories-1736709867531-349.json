{
  "metadata": {
    "timestamp": 1736709867531,
    "page": 349,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "leahneukirchen/nq",
      "stars": 2825,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.017578125,
          "content": "*~\nnq\nnqtail\n,*.*\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 0.2138671875,
          "content": "nq is in the public domain.\n\nTo the extent possible under law, Leah Neukirchen <leah@vuxu.org>\nhas waived all copyright and related or neighboring rights to this work.\n\nhttp://creativecommons.org/publicdomain/zero/1.0/\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.3818359375,
          "content": "ALL=nq nqtail nqterm\n\nCFLAGS=-g -Wall -O2\n\nDESTDIR=\nPREFIX=/usr/local\nBINDIR=$(PREFIX)/bin\nMANDIR=$(PREFIX)/share/man\n\nINSTALL=install\n\nall: $(ALL)\n\nclean: FRC\n\trm -f nq nqtail\n\ncheck: FRC all\n\tprove -v ./tests\n\ninstall: FRC all\n\tmkdir -p $(DESTDIR)$(BINDIR) $(DESTDIR)$(MANDIR)/man1\n\t$(INSTALL) -m0755 $(ALL) $(DESTDIR)$(BINDIR)\n\t$(INSTALL) -m0644 $(ALL:=.1) $(DESTDIR)$(MANDIR)/man1\n\nFRC:\n"
        },
        {
          "name": "NEWS.md",
          "type": "blob",
          "size": 1.3642578125,
          "content": "## 1.0 (2024-07-03)\n\n* **Incompatible change:** The fq utility has been renamed to nqtail.\n* **Incompatible change:** The tq utility has been renamed to nqterm.\n* nq: add support for a $NQFAILDIR\n\n## 0.5 (2022-03-26)\n\n* **Notable change:** nq now creates files with permissions 0666 and\n  subject to your umask (like most programs that create new files).\n  If your queue needs to remain secret, prohibit access to the whole\n  directory.\n* Support for nq in a multi-user environment: having read permission\n  for queued tasks in the directory is enough to wait for them.\n* Makefile: support INSTALL variable.\n* Bugfix: create $NQDONEDIR properly\n\n## 0.4 (2021-03-15)\n\n* nq: now scales a lot better\n* nq: set $NQDONEDIR to move finished jobs there\n* fq: add kevent/kqueue support\n* Bugfixes\n\n## 0.3.1 (2018-03-07)\n\n* Fix build on FreeBSD, OpenBSD and macOS.\n\n## 0.3 (2018-03-06)\n\n* nq: add `-c` to clean job file when the process succeeded.\n* nq: avoid unnecessary quoting for the exec line.\n* Bugfix when `-q` was used with empty command lines.\n\n## 0.2.2 (2017-12-21)\n\n* fq: fix when `$NQDIR` is set and inotify is used.  (Thanks to Sebastian Reu√üe)\n* Support for NetBSD 7.\n\n## 0.2.1 (2017-04-27)\n\n* fq: `-q` erroneously was on by default.\n\n## 0.2 (2017-04-26)\n\n* fq: add `-n` to not wait\n* Support for platforms without O_DIRECTORY.\n* Support for SmartOS.\n\n## 0.1 (2015-08-28)\n\n* Initial release\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.9794921875,
          "content": "## nq: queue utilities\n\nThese small utilities allow creating very lightweight job queue\nsystems which require no setup, maintenance, supervision, or any\nlong-running processes.\n\n`nq` should run on any POSIX.1-2008 compliant system which also\nprovides a working flock(2).  Tested on Linux 2.6.37, Linux 4.1,\nOpenBSD 5.7, FreeBSD 10.1, NetBSD 7.0.2, Mac OS X 10.3 and\nSmartOS joyent_20160304T005100Z.\n\nThe intended purpose is ad-hoc queuing of command lines (e.g., for\nbuilding several targets of a Makefile, downloading multiple files one\nat a time, running benchmarks in several configurations, or simply as\na glorified `nohup`). But as any good Unix tool, it can be abused for\nwhatever you like.\n\nJob order is enforced by a timestamp `nq` gets immediately when\nstarted.  Synchronization happens on file-system level.  Timer\nresolution is milliseconds.  No sub-second file system time stamps are\nrequired.  Polling is not used.  Exclusive execution is maintained\nstrictly.\n\nEnforcing job order works like this:\n- every job has a flock(2)ed output file, ala `,TIMESTAMP.PID`\n- every job starts only after all earlier flock(2)ed files are unlocked\n- Why flock(2)? Because it locks the file handle, which is shared\n  across exec(2) with the child process (the actual job), and it will\n  unlock when the file is closed (usually when the job terminates).\n\nYou enqueue (get it?) new jobs using `nq CMDLINE...`.  The job ID is\noutput (unless suppressed using `-q`) and `nq` detaches immediately,\nrunning the job in the background.  STDOUT and STDERR are redirected\ninto the log file.\n\n`nq` tries hard (but does not guarantee) to ensure the log file of the\ncurrently running job has `+x` bit set.  Thus you can use `ls -F` to get\na quick overview of the state of your queue.\n\nThe \"file extension\" of the log file is actually the PID, so you can\nkill jobs easily.  Before the job is started, it is the PID of `nq`,\nso you can cancel a queued job by killing it as well.\n\nDue to the initial `exec` line in the log files, you can resubmit a\njob by executing it as a shell command file (i.e. running `sh $jobid`).\n\nYou can wait for jobs to finish using `nq -w`, possibly listing job\nIDs you want to wait for; the default is all of them.  Likewise, you\ncan test if there are jobs which need to be waited upon using `-t`.\n\nBy default, job IDs are per-directory, but you can set `$NQDIR` to put\nthem elsewhere.  Creating `nq` wrappers setting `$NQDIR` to provide\ndifferent queues for different purposes is encouraged.\n\nAll these operations take worst-case quadratic time in the amount of\nlock files produced, so you should clean them regularly.\n\n## Examples\n\nBuild targets `clean`, `depends`, `all`, without occupying the terminal:\n\n\t% nq make clean\n\t% nq make depends\n\t% nq make all\n\t% nqtail\n\t... look at output, can interrupt with C-c any time\n\twithout stopping the build ...\n\nSimple download queue, accessible from multiple terminals:\n\n\t% mkdir -p /tmp/downloads\n\t% alias qget='NQDIR=/tmp/downloads nq wget'\n\t% alias qwait='NQDIR=/tmp/downloads nqtail -q'\n\twindow1% qget http://mymirror/big1.iso\n\twindow2% qget http://mymirror/big2.iso\n\twindow3% qget http://mymirror/big3.iso\n\t% qwait\n\t... wait for all downloads to finish ...\n\nAs `nohup` replacement (The benchmark will run in background, every run\ngets a different output file, and the command line you ran is logged,\ntoo!):\n\n\t% ssh remote\n\tremote% nq ./run-benchmark\n\t,14f6f3034f8.17035\n\tremote% ^D\n\t% ssh remote\n\tremote% nqtail\n\t... see output, nqtail exits when job finished ...\n\n## Assumptions\n\n`nq` will only work correctly when:\n- `$NQDIR` (respectively `.`) is writable.\n- `flock(2)` works in `$NQDIR` (respectively `.`).\n- `gettimeofday` behaves monotonic (using `CLOCK_MONOTONIC` would\n  create confusing file names).  Else job order can be confused and\n  multiple tasks can run at once due to race conditions.\n- No other programs put files matching `,*` into `$NQDIR` (respectively `.`).\n\n## nq helpers\n\nTwo helper programs are provided:\n\n**`nqtail`** outputs the log of the currently running jobs, exiting\nwhen the jobs are done.  If no job is running, the output of the last\njob is shown.  `nqtail -a` shows the output of all jobs, `nqtail -q`\nonly shows one line per job.  `nqtail` uses `inotify` on Linux and\nfalls back to polling for size change else.  (`nqtail.sh` is a similar\ntool, not quite as robust, implemented as shell-script calling\n`tail`.)\n\n**`nqterm`** wraps `nq` and displays the `nqtail` output in a new\n`tmux` or screen window.\n\n(A pure shell implementation of `nq` is provided as `nq.sh`.  It needs\n`flock` from util-linux, and only has a timer resolution of 1s.\nLock files from `nq` and `nq.sh` should not be mixed.)\n\n## Installation\n\nUse `make all` to build, `make install` to install relative to `PREFIX`\n(`/usr/local` by default).  The `DESTDIR` convention is respected.\nYou can also just copy the binaries into your `PATH`.\n\nYou can use `make check` to run a simple test suite, if you have\nPerl's `prove` installed.\n\n## Comparison to `at`, `batch`, and `task-spooler`\n\n* `at` runs jobs at a given time.\n  `batch` runs jobs \"when system load levels permit\".\n  `nq` and [`task-spooler`](https://vicerveza.homeunix.net/~viric/soft/ts/)\n  run jobs in sequence with no regard to the system's load average.\n\n* `at` and `batch` have 52 built-in queues: a-z and A-Z.\n  Any directory can be a queue for `nq`.\n  `task-spooler` can have different queues for different terminals.\n\n* You can follow the output of an `nq` queue tail-style with `nqtail`.\n\n* The syntax is different: `at` and `batch` take whole scripts from\n  the standard input or a file; `nq` takes a single command as its\n  command line arguments.\n\n* `nq` doesn't rely on a daemon, and uses a directory to manage the queue.\n  `task-spooler` automatically launches a daemon to manage a queue.\n\n* `task-spooler` can set a maximum number of simultaneous jobs.\n\n## Copyright\n\n`nq` is in the public domain.\n\nTo the extent possible under law,\nLeah Neukirchen <leah@vuxu.org>\nhas waived all copyright and related or\nneighboring rights to this work.\n\nhttp://creativecommons.org/publicdomain/zero/1.0/\n"
        },
        {
          "name": "_nq",
          "type": "blob",
          "size": 0.5078125,
          "content": "#compdef nq nqtail nqterm\n\n_nq_job() {\n\tcompadd \"$@\" -- ${NQDIR:-.}/,*.*(:t)\n}\n\n_nq() {\n\tcase \"$service\" in\n\tnqtail)\t_arguments -s -A : \\\n\t\t\t'-q[show only one line per job]' \\\n\t\t\t'-a[output for all jobs]' \\\n\t\t\t'*::job:_nq_job'\n\t\t;;\n\tnq)\t_arguments -A : \\\n\t\t\t'-w[wait for jobs]:*:job:_nq_job' \\\n\t\t\t'-t[check jobs]:*:job:_nq_job' \\\n\t\t\t'(-):command name: _command_names -e' \\\n\t\t\t'*::arguments:_normal'\n\t\t;;\n\tnqterm)\t_arguments : \\\n\t\t\t'(-):command name: _command_names -e' \\\n\t\t\t'*::arguments:_normal'\n\t\t;;\n\tesac\n}\n\n_nq \"$@\"\n"
        },
        {
          "name": "nq.1",
          "type": "blob",
          "size": 5.3740234375,
          "content": ".Dd July 3, 2024\n.Dt NQ 1\n.Os\n.Sh NAME\n.Nm nq\n.Nd job queue utility\n.Sh SYNOPSIS\n.Nm\n.Op Fl c\n.Op Fl q\n.Ar command\\ line ...\n.Nm\n.Fl t\n.Ar job\\ id ...\n.Nm\n.Fl w\n.Ar job\\ id ...\n.Sh DESCRIPTION\nThe\n.Nm\nutility provides a very lightweight queuing system without\nrequiring setup,\nmaintenance,\nsupervision\nor any long-running processes.\n.Pp\nJob order is enforced by a timestamp\n.Nm\ngets immediately when started.\nSynchronization happens on file-system level.\nTimer resolution is milliseconds.\nNo sub-second file system time stamps are required.\nPolling is not used.\nExclusive execution is maintained strictly.\n.Pp\nYou enqueue(!) new jobs into the queue by running\n.Pp\n.Dl nq Ar command line ...\n.Pp\nThe job id (a file name relative to\n.Ev NQDIR ,\nwhich defaults to the current directory) is\noutput (unless suppressed using\n.Fl q )\nand\n.Nm\ndetaches from the terminal immediately,\nrunning the job in the background.\nStandard output and standard error are redirected into the job id file.\n.Xr nqtail 1\ncan be used to conveniently watch the log files.\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl c\nClean up job id file when process exited with status 0.\n.It Fl q\nSuppress output of the job id after spawning new job.\n.It Fl t\nEnter\n.Em test mode :\nexit with status 0 when\n.Em all\nof the listed job ids are already done, else with status 1.\n.It Fl w\nEnter\n.Em waiting mode :\nwait in the foreground until\n.Em all\nlisted job ids are done.\n.El\n.Sh ENVIRONMENT\n.Bl -hang -width \"NQDONEDIR\"\n.It Ev NQDIR\nDirectory where lock files/job output resides.\nEach\n.Ev NQDIR\ncan be considered a separate queue.\nThe current working directory is used when\n.Ev NQDIR\nis unset.\n.Ev NQDIR\nis created if needed.\n.It Ev NQDONEDIR\nWhen set, specifies a directory\n.Po\nmust be on the same file system as\n.Ev NQDIR\n.Pc\nwhere lock files/job output is moved\nto after successful execution of the job.\n.Pp\nIgnored when\n.Fl c\nis used.\n.It Ev NQFAILDIR\nWhen set, specifies a directory\n.Po\nmust be on the same file system as\n.Ev NQDIR\n.Pc\nwhere lock files/job output is moved\nto after unsuccessful execution of the job.\n.It Ev NQJOBID\nThe job id of the currently running job,\nexposed to the job itself.\n.El\n.Sh FILES\n.Nm\nexpects to control all files in\n.Ev NQDIR\n(respectively\n.Pa \\&. )\nwhich start with\n.Dq Li \\&,\nor\n.Dq Li ., .\nThese files are created according to the following scheme:\n.Pp\n.Dl ,hexadecimal-time-stamp.pid\n.Sh EXIT STATUS\nThe\n.Nm\nutility exits 0 on success, and >0 if an error occurs;\nunless\n.Em test mode\nis used, in which case exit status 1 means there is a job running.\n.Pp\nOn fatal errors, exit codes 111 and 222 are used.\n.Sh EXAMPLES\nBuild\n.Xr make 1\ntargets\n.Ic clean ,\n.Ic depends ,\n.Ic all ,\nwithout occupying the terminal:\n.Bd -literal -offset indent\n% nq make clean\n% nq make depends\n% nq make all\n% nqtail\n\\&... look at output, can interrupt with C-c any time\nwithout stopping the build ...\n.Ed\n.Pp\nSimple download queue, accessible from multiple terminals:\n.Bd -literal -offset indent\n% alias qget='NQDIR=/tmp/downloads nq wget'\n% alias qwait='NQDIR=/tmp/downloads nqtail -q'\nwindow1% qget http://mymirror/big1.iso\nwindow2% qget http://mymirror/big2.iso\nwindow3% qget http://mymirror/big3.iso\n% qwait\n\\&... wait for all downloads to finish ...\n.Ed\n.Pp\nAs\n.Xr nohup 1\nreplacement\n(The benchmark will run in background,\nevery run gets a different output file,\nand the command line you ran is logged too.):\n.Bd -literal -offset indent\n% ssh remote\nremote% nq ./run-benchmark\n,14f6f3034f8.17035\nremote% ^D\n% ssh remote\nremote% nqtail\n\\&... see output, nqtail exits when job finished ...\n.Ed\n.Sh TRICKS\nThe \"file extension\" of the log file is actually the PID of the job.\n.Nm\nruns all jobs in a separate process group,\nso you can kill an entire job process tree at once using\n.Xr kill 1\nwith a negative PID.\nBefore the job is started, it is the PID of\n.Nm ,\nso you can cancel a queued job by killing it as well.\n.Pp\nThanks to the initial\n.Li exec\nline in the log files, you can resubmit a\njob by executing it as a shell command file,\ni.e. running\n.Pp\n.Dl sh Em job\\ id\n.Pp\nCreating\n.Nm\nwrappers setting\n.Ev NQDIR\nto provide different queues for different purposes is encouraged.\n.Sh INTERNALS\nEnforcing job order works like this:\n.Bl -dash -compact\n.It\nevery job has an\noutput file locked using\n.Xr flock 2\nand named according to\n.Sx FILES .\n.It\nevery job starts only after all earlier\nflocked files are unlocked.\n.It\nthe lock is released by the kernel after the job terminates.\n.El\n.Sh ASSUMPTIONS\n.Nm\nwill only work correctly when:\n.Bl -dash\n.It\n.Ev NQDIR\n(respectively\n.Pa \\&. )\nis writable.\n.It\n.Xr flock 2\nworks correctly in\n.Ev NQDIR\n(respectively\n.Pa \\&. ) .\n.It\n.Xr gettimeofday 2\nbehaves monotonic (using\n.Dv CLOCK_MONOTONIC\nwould create confusing file names after reboot).\n.It\nNo other programs put files matching\n.Li ,*\ninto\n.Ev NQDIR\n(respectively\n.Pa \\&. ) .\n.El\n.Sh SEE ALSO\n.Xr nqtail 1 ,\n.Xr nqterm 1 .\n.Pp\nAlternatives to the\n.Nm\nsystem include\n.Xr batch 1 ,\n.Xr qsub 1 ,\n.Xr schedule 1 ,\n.Xr srun 1 ,\nand\n.Xr ts 1 .\n.\\\" .Sh STANDARDS\n.\\\" .Sh HISTORY\n.Sh AUTHORS\n.An Leah Neukirchen Aq Mt leah@vuxu.org\n.Sh CAVEATS\nAll reliable queue status information is in main memory only,\nwhich makes restarting a job queue after a reboot difficult.\n.Sh LICENSE\n.Nm\nis in the public domain.\n.Pp\nTo the extent possible under law,\nthe creator of this work\nhas waived all copyright and related or\nneighboring rights to this work.\n.Pp\n.Lk http://creativecommons.org/publicdomain/zero/1.0/\n.\\\" .Sh BUGS\n"
        },
        {
          "name": "nq.c",
          "type": "blob",
          "size": 8.0966796875,
          "content": "/*\n * nq CMD... - run CMD... in background and in order, saving output\n * -w ...  wait for all jobs/listed jobs queued so far to finish\n * -t ...  exit 0 if no (listed) job needs waiting\n * -q      quiet, do not output job id\n * -c      clean, don't keep output if job exited with status 0\n *\n * - requires POSIX.1-2008 and having flock(2)\n * - enforcing order works like this:\n *   - every job has a flock(2)ed output file ala \",TIMESTAMP.PID\"\n *   - every job starts only after all earlier flock(2)ed files finished\n *   - the lock is released when job terminates\n *   - no sub-second file system time stamps are required, jobs are started\n *     with millisecond precision\n * - we try hard to make the currently running ,* file have +x bit\n * - you can re-queue jobs using \"sh ,jobid\"\n *\n * To the extent possible under law, Leah Neukirchen <leah@vuxu.org>\n * has waived all copyright and related or neighboring rights to this work.\n * http://creativecommons.org/publicdomain/zero/1.0/\n*/\n\n/* for FreeBSD.  */\n#define _WITH_DPRINTF\n\n#if defined(__sun) && defined(__SVR4) && !defined(HAVE_DPRINTF)\n#define NEED_DPRINTF\n#endif\n\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#ifndef O_DIRECTORY\n#define O_DIRECTORY 0\n#endif\n\n#ifdef NEED_DPRINTF\n#include <stdarg.h>\nstatic int\ndprintf(int fd, const char *fmt, ...)\n{\n\tchar buf[128];  // good enough for usage in nq\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vsnprintf(buf, sizeof buf, fmt, ap);\n\tva_end(ap);\n\tif (r >= 0 && r < sizeof buf)\n\t\treturn write(fd, buf, r);\n\treturn -1;\n}\n#endif\n\nstatic void\nswrite(int fd, char *str)\n{\n\tsize_t l = strlen(str);\n\n\tif (write(fd, str, l) != l) {\n\t\tperror(\"write\");\n\t\texit(222);\n\t}\n}\n\nstatic void\nwrite_execline(int fd, int argc, char *argv[])\n{\n\tint i;\n\tchar *s;\n\n\tswrite(fd, \"exec\");\n\n\tfor (i = 0; i < argc; i++) {\n\t\tif (!strpbrk(argv[i],\n\t\t\t\t\"\\001\\002\\003\\004\\005\\006\\007\\010\"\n\t\t\t\t\"\\011\\012\\013\\014\\015\\016\\017\\020\"\n\t\t\t\t\"\\021\\022\\023\\024\\025\\026\\027\\030\"\n\t\t\t\t\"\\031\\032\\033\\034\\035\\036\\037\\040\"\n\t\t\t\t\"`^#*[]=|\\\\?${}()'\\\"<>&;\\177\")) {\n\t\t\tswrite(fd, \" \");\n\t\t\tswrite(fd, argv[i]);\n\t\t} else {\n\t\t\tswrite(fd, \" '\");\n\t\t\tfor (s = argv[i]; *s; s++) {\n\t\t\t\tif (*s == '\\'')\n\t\t\t\t\tswrite(fd, \"'\\\\''\");\n\t\t\t\telse\n\t\t\t\t\twrite(fd, s, 1);\n\t\t\t}\n\t\t\tswrite(fd, \"'\");\n\t\t}\n\t}\n}\n\nstatic void\nsetx(int fd, int executable)\n{\n\tstruct stat st;\n\tfstat(fd, &st);\n\tif (executable)\n\t\tst.st_mode |= 0100;\n\telse\n\t\tst.st_mode &= ~0100;\n\tfchmod(fd, st.st_mode);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tint64_t ms;\n\tint dirfd = -1, donedirfd = -1, faildirfd = -1, lockfd = -1;\n\tint opt = 0, cflag = 0, qflag = 0, tflag = 0, wflag = 0;\n\tint pipefd[2];\n\tchar lockfile[64], newestlocked[64];\n\tpid_t child;\n\tstruct timeval started;\n\tstruct dirent *ent;\n\tDIR *dir;\n\n\t/* timestamp is milliseconds since epoch.  */\n\tgettimeofday(&started, NULL);\n\tms = (int64_t)started.tv_sec*1000 + started.tv_usec/1000;\n\n\twhile ((opt = getopt(argc, argv, \"+chqtw\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'c':\n\t\t\tcflag = 1;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\twflag = 1;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\ttflag = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tqflag = 1;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\tdefault:\n\t\t\tgoto usage;\n\t\t}\n\t}\n\n\tif (!tflag && !wflag && argc <= optind) {\nusage:\n\t\tswrite(2, \"usage: nq [-c] [-q] [-w ... | -t ... | CMD...]\\n\");\n\t\texit(1);\n\t}\n\n\tchar *path = getenv(\"NQDIR\");\n\tif (!path)\n\t\tpath = \".\";\n\n\tif (mkdir(path, 0777) < 0) {\n\t\tif (errno != EEXIST) {\n\t\t\tperror(\"mkdir $NQDIR\");\n\t\t\texit(111);\n\t\t}\n\t}\n\n\tdirfd = open(path, O_RDONLY | O_DIRECTORY);\n\tif (dirfd < 0) {\n\t\tperror(\"dir open\");\n\t\texit(111);\n\t}\n\n\tchar *donepath = getenv(\"NQDONEDIR\");\n\tif (donepath) {\n\t\tif (mkdir(donepath, 0777) < 0) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tperror(\"mkdir $NQDONEDIR\");\n\t\t\t\texit(111);\n\t\t\t}\n\t\t}\n\n\t\tdonedirfd = open(donepath, O_RDONLY | O_DIRECTORY);\n\t\tif (donedirfd < 0) {\n\t\t\tperror(\"dir open\");\n\t\t\texit(111);\n\t\t}\n\t}\n\n\tchar *failpath = getenv(\"NQFAILDIR\");\n\tif (failpath) {\n\t\tif (mkdir(failpath, 0777) < 0) {\n\t\t\tif (errno != EEXIST) {\n\t\t\t\tperror(\"mkdir $NQFAILDIR\");\n\t\t\t\texit(111);\n\t\t\t}\n\t\t}\n\n\t\tfaildirfd = open(failpath, O_RDONLY | O_DIRECTORY);\n\t\tif (faildirfd < 0) {\n\t\t\tperror(\"dir open\");\n\t\t\texit(111);\n\t\t}\n\t}\n\n\tif (tflag || wflag) {\n\t\tsnprintf(lockfile, sizeof lockfile,\n\t\t    \".,%011\" PRIx64 \".%d\", ms, getpid());\n\t\tgoto wait;\n\t}\n\n\tif (pipe(pipefd) < 0) {\n\t\tperror(\"pipe\");\n\t\texit(111);\n\t};\n\n\t/* first fork, parent exits to run in background.  */\n\tchild = fork();\n\tif (child == -1) {\n\t\tperror(\"fork\");\n\t\texit(111);\n\t}\n\telse if (child > 0) {\n\t\tchar c;\n\n\t\t/* wait until child has backgrounded.  */\n\t\tclose(pipefd[1]);\n\t\tread(pipefd[0], &c, 1);\n\n\t\texit(0);\n\t}\n\n\tclose(pipefd[0]);\n\n\t/* second fork, child later execs the job, parent collects status.  */\n\tchild = fork();\n\tif (child == -1) {\n\t\tperror(\"fork\");\n\t\texit(111);\n\t}\n\telse if (child > 0) {\n\t\tint status;\n\n\t\t/* output expected lockfile name.  */\n\t\tsnprintf(lockfile, sizeof lockfile,\n\t\t    \",%011\" PRIx64 \".%d\", ms, child);\n\t\tif (!qflag)\n\t\t\tdprintf(1, \"%s\\n\", lockfile);\n\t\tclose(0);\n\t\tclose(1);\n\t\tclose(2);\n\n\t\t/* signal parent to exit.  */\n\t\tclose(pipefd[1]);\n\n\t\twait(&status);\n\n\t\tlockfd = openat(dirfd, lockfile, O_RDWR | O_APPEND);\n\t\tif (lockfd < 0) {\n\t\t\tperror(\"open\");\n\t\t\texit(222);\n\t\t}\n\n\t\tsetx(lockfd, 0);\n\t\tif (WIFEXITED(status)) {\n\t\t\tdprintf(lockfd, \"\\n[exited with status %d.]\\n\",\n\t\t\t    WEXITSTATUS(status));\n\t\t\tif (WEXITSTATUS(status) == 0) {\n\t\t\t\tif (cflag)\n\t\t\t\t\tunlinkat(dirfd, lockfile, 0);\n\t\t\t\telse if (donepath)\n\t\t\t\t\trenameat(dirfd, lockfile,\n\t\t\t\t\t    donedirfd, lockfile);\n\t\t\t}\n\t\t\tif (WEXITSTATUS(status) != 0) {\n\t\t\t\tif (failpath)\n\t\t\t\t\trenameat(dirfd, lockfile, faildirfd, lockfile);\n\t\t\t\t/* errors above are ignored */\n\t\t\t}\n\t\t} else {\n\t\t\tdprintf(lockfd, \"\\n[killed by signal %d.]\\n\",\n\t\t\t    WTERMSIG(status));\n\t\t}\n\n\t\texit(0);\n\t}\n\n\tclose(pipefd[1]);\n\n\t/* create and lock lockfile.  since this cannot be done in one step,\n\t   use a different filename first.  */\n\tsnprintf(lockfile, sizeof lockfile,\n\t    \".,%011\" PRIx64 \".%d\", ms, getpid());\n\tlockfd = openat(dirfd, lockfile,\n\t    O_CREAT | O_EXCL | O_RDWR | O_APPEND, 0666);\n\tif (lockfd < 0) {\n\t\tperror(\"open\");\n\t\texit(222);\n\t}\n\tif (flock(lockfd, LOCK_EX) < 0) {\n\t\tperror(\"flock\");\n\t\texit(222);\n\t}\n\n\t/* drop leading '.' */\n\trenameat(dirfd, lockfile, dirfd, lockfile+1);\n\n\t/* block until rename is committed */\n\tfsync(dirfd);\n\n\twrite_execline(lockfd, argc, argv);\n\n\tif (dup2(lockfd, 2) < 0 ||\n\t    dup2(lockfd, 1) < 0) {\n\t\tperror(\"dup2\");\n\t\texit(222);\n\t}\n\nwait:\n\tif ((tflag || wflag) && argc - optind > 0) {\n\t\t/* wait for files passed as command line arguments.  */\n\n\t\tint i;\n\t\tfor (i = optind; i < argc; i++) {\n\t\t\tint fd;\n\n\t\t\tif (strchr(argv[i], '/'))\n\t\t\t\tfd = open(argv[i], O_RDONLY);\n\t\t\telse\n\t\t\t\tfd = openat(dirfd, argv[i], O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (flock(fd, LOCK_SH | LOCK_NB) == -1 &&\n\t\t\t    errno == EWOULDBLOCK) {\n\t\t\t\tif (tflag)\n\t\t\t\t\texit(1);\n\t\t\t\tflock(fd, LOCK_SH);   /* sit it out.  */\n\t\t\t}\n\n\t\t\tsetx(fd, 0);\n\t\t\tclose(fd);\n\t\t}\n\t} else {\n\t\tdir = fdopendir(dirfd);\n\t\tif (!dir) {\n\t\t\tperror(\"fdopendir\");\n\t\t\texit(111);\n\t\t}\n\nagain:\n\t\t*newestlocked = 0;\n\n\t\twhile ((ent = readdir(dir))) {\n\t\t\t/* wait for all older ,* files than ours.  */\n\n\t\t\tif (!(ent->d_name[0] == ',' &&\n\t\t\t    strcmp(ent->d_name, lockfile+1) < 0 &&\n\t\t\t    strlen(ent->d_name) < sizeof(newestlocked)))\n\t\t\t\tcontinue;\n\n\t\t\tint fd = openat(dirfd, ent->d_name, O_RDONLY);\n\t\t\tif (fd < 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (flock(fd, LOCK_SH | LOCK_NB) == -1 &&\n\t\t\t    errno == EWOULDBLOCK) {\n\t\t\t\tif (tflag)\n\t\t\t\t\texit(1);\n\t\t\t\tif (strcmp(ent->d_name, newestlocked) > 0)\n\t\t\t\t\tstrcpy(newestlocked, ent->d_name);\n\t\t\t} else {\n\t\t\t\tsetx(fd, 0);\n\t\t\t}\n\n\t\t\tclose(fd);\n\t\t}\n\n\t\tif (*newestlocked) {\n\t\t\tint fd = openat(dirfd, newestlocked, O_RDONLY);\n\t\t\tif (fd >= 0) {\n\t\t\t\tflock(fd, LOCK_SH);   /* sit it out.  */\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\trewinddir(dir);\n\t\t\tgoto again;\n\t\t}\n\n\t\tclosedir(dir);          /* closes dirfd too.  */\n\t}\n\n\tif (tflag || wflag)\n\t\texit(0);\n\n\t/* ready to run.  */\n\n\tswrite(lockfd, \"\\n\\n\");\n\tsetx(lockfd, 1);\n\n\tclose(lockfd);\n\n\tsetenv(\"NQJOBID\", lockfile+1, 1);\n\tsetsid();\n\texecvp(argv[optind], argv+optind);\n\n\tperror(\"execvp\");\n\treturn 222;\n}\n"
        },
        {
          "name": "nq.sh",
          "type": "blob",
          "size": 1.71484375,
          "content": "#!/bin/sh\n# nq CMD... - run CMD... in background and in order, saving output to ,* files\n#\n# - needs POSIX sh + util-linux flock(1) (see nq.c for portable version)\n# - when run from tmux, display output in a new window (needs\n#   GNU tail, C-c to abort the job.)\n# - we try hard to make the currently running ,* file have +x bit\n# - enforcing order works like this:\n#   - every job has a flock(2)ed file\n#   - every job starts only after all earlier flock(2)ed files finished\n#   - the lock is released when job terminates\n#\n# To the extent possible under law, Leah Neukirchen <leah@vuxu.org>\n# has waived all copyright and related or neighboring rights to this work.\n# http://creativecommons.org/publicdomain/zero/1.0/\n\nif [ -z \"$NQ\" ]; then\n\texport NQ=$(date +%s)\n\t\"$0\" \"$@\" & c=$!\n\t(\n\t\t# wait for job to finish\n\t\tflock -x .,$NQ.$c -c true\n\t\tflock -x ,$NQ.$c -c true\n\t\tchmod -x ,$NQ.$c\n\t) &\n\texit\nfi\n\nus=\",$NQ.$$\"\n\nexec 9>>.$us\n# first flock(2) the file, then make it known under the real name\nflock -x 9\nmv .$us $us\n\nprintf \"## nq $*\" 1>&9\n\nif [ -n \"$TMUX\" ]; then\n\ttmux new-window -a -d -n '<' -c '#{pane_current_path}' \\\n\t\t\"trap true INT QUIT TERM EXIT;\n                 tail -F --pid=$$ $us || kill $$;\n\t\t printf '\\n[%d exited, ^D to exit.]\\n' $$;\n\t\t cat >/dev/null\"\nfi\n    \nwaiting=true\nwhile $waiting; do\n\twaiting=false\n\t# this must traverse in lexical (= numerical) order:\n        # check all older locks are released\n\tfor f in ,*; do\n\t\t# reached the current lock, good to go\n\t\t[ $f = $us ] && break\n\n\t\tif ! flock -x -n $f -c \"chmod -x $f\"; then\n\t\t\t# force retrying all locks again;\n\t\t\t# an earlier lock could just now have really appeared\n\t\t\twaiting=true\n\t\t\tflock -x $f -c true\n\t\tfi\n\tdone\ndone\n\nprintf '\\n' 1>&9\n\nchmod +x $us\nexec \"$@\" 2>&1 1>&9\n"
        },
        {
          "name": "nqtail.1",
          "type": "blob",
          "size": 1.3134765625,
          "content": ".Dd July 3, 2024\n.Dt NQTAIL 1\n.Os\n.Sh NAME\n.Nm nqtail\n.Nd job queue log viewer\n.Sh SYNOPSIS\n.Nm\n.Op Fl a\n.Op Fl n\n.Op Fl q\n.Op Ar job\\ id ...\n.Sh DESCRIPTION\n.Nm\nis a simple utility for\n.Dq following\nthe output of\n.Xr nq 1\njobs.\n.Pp\nWithout arguments, the output of the currently running and queued\nas-of-now jobs is emitted; else the presented job ids are used.\n.Pp\n.Nm\nautomatically terminates after the corresponding jobs are done.\n.Pp\nThe options are as follows:\n.Bl -tag -width Ds\n.It Fl a\nOutput all log files, even of already finished jobs.\n.It Fl n\nDon't wait for new output.\nCan be used to look at enqueued commands.\n.It Fl q\nOnly print the first line of each job output\n(i.e. the\n.Li exec\nline).\n.El\n.Sh ENVIRONMENT\n.Bl -hang -width Ds\n.It Ev NQDIR\nDirectory where lock files/job output resides, see\n.Xr nq 1 .\n.El\n.Sh EXIT STATUS\n.Ex -std\n.Sh INTERNALS\nOn Linux,\n.Xr inotify 7\nis used to monitor job output.\nOn FreeBSD and macOS,\n.Xr kqueue 2\nis used.\nOn other operating systems, polling is used.\n.Sh SEE ALSO\n.Xr nq 1 ,\n.Xr nqterm 1\n.Sh AUTHORS\n.An Leah Neukirchen Aq Mt leah@vuxu.org\n.Sh LICENSE\n.Nm\nis in the public domain.\n.Pp\nTo the extent possible under law,\nthe creator of this work\nhas waived all copyright and related or\nneighboring rights to this work.\n.Pp\n.Lk http://creativecommons.org/publicdomain/zero/1.0/\n.\\\" .Sh BUGS\n"
        },
        {
          "name": "nqtail.c",
          "type": "blob",
          "size": 4.736328125,
          "content": "/*\n * nqtail [FILES...] - follow output of nq jobs, quitting when they are done\n *\n * To the extent possible under law, Leah Neukirchen <leah@vuxu.org>\n * has waived all copyright and related or neighboring rights to this work.\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\n#include <sys/file.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define DELAY 250000\n\n#ifdef __linux__\n#define USE_INOTIFY\n#endif\n\n#if defined(__FreeBSD__) || defined(__APPLE__)\n#define USE_KEVENT\n#endif\n\n#ifdef USE_INOTIFY\n#include <sys/inotify.h>\nchar ibuf[8192];\n#endif\n\n#ifdef USE_KEVENT\n#include <sys/event.h>\n#endif\n\nchar buf[8192];\n\nstatic int\nislocked(int fd)\n{\n\tif (flock(fd, LOCK_SH | LOCK_NB) == -1) {\n\t\treturn (errno == EWOULDBLOCK);\n\t} else {\n\t\tflock(fd, LOCK_UN);\n\t\treturn 0;\n\t}\n}\n\nstatic int\nalphabetic(const void *a, const void *b)\n{\n\treturn strcmp(*(char **)a, *(char **)b);\n}\n\nint\nmain(int argc, char *argv[])\n{\n\tint i, fd, dirfd;\n\toff_t off, loff;\n\tssize_t rd;\n\tint didsth = 0, seen_nl = 0;\n\tint opt = 0, aflag = 0, nflag = 0, qflag = 0;\n\tchar *path;\n\n#ifdef USE_INOTIFY\n\tint ifd, wd;\n#endif\n#ifdef USE_KEVENT\n\tint kq, note;\n\tstruct kevent kev;\n#endif\n\n\tclose(0);\n\n\twhile ((opt = getopt(argc, argv, \"+anq\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'a':\n\t\t\taflag = 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnflag = 1;\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\tqflag = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfputs(\"usage: nqtail [-anq] [JOBID...]\\n\", stderr);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tpath = getenv(\"NQDIR\");\n\tif (!path)\n\t\tpath = \".\";\n\n#ifdef O_DIRECTORY\n\tdirfd = open(path, O_RDONLY | O_DIRECTORY);\n#else\n\tdirfd = open(path, O_RDONLY);\n#endif\n\tif (dirfd < 0) {\n\t\tperror(\"open dir\");\n\t\texit(111);\n\t}\n\n\tif (optind == argc) {   /* behave as if $NQDIR/,* was passed. */\n\t\tDIR *dir;\n\t\tstruct dirent *d;\n\t\tint len = 0;\n\n\t\targc = 0;\n\t\targv = 0;\n\t\toptind = 0;\n\n\t\tdir = fdopendir(dirfd);\n\t\tif (!dir) {\n\t\t\tperror(\"fdopendir\");\n\t\t\texit(111);\n\t\t}\n\n\t\twhile ((d = readdir(dir))) {\n\t\t\tif (d->d_name[0] != ',')\n\t\t\t\tcontinue;\n\t\t\tif (argc >= len) {\n\t\t\t\tlen = 2*len + 1;\n\t\t\t\targv = realloc(argv, len * sizeof (char *));\n\t\t\t\tif (!argv)\n\t\t\t\t\texit(222);\n\t\t\t}\n\t\t\targv[argc] = strdup(d->d_name);\n\t\t\tif (!argv[argc])\n\t\t\t\texit(222);\n\t\t\targc++;\n\t\t}\n\n\t\tqsort(argv, argc, sizeof (char *), alphabetic);\n\t}\n\n#ifdef USE_INOTIFY\n\tifd = inotify_init();\n\tif (ifd < 0)\n\t\texit(111);\n#endif\n#ifdef USE_KEVENT\n\tkq = kqueue();\n\tif (kq < 0)\n\t\texit(111);\n#endif\n\n\tfor (i = optind; i < argc; i++) {\n\t\tloff = 0;\n\t\tseen_nl = 0;\n\n\t\tfd = openat(dirfd, argv[i], O_RDONLY);\n\t\tif (fd < 0)\n\t\t\tcontinue;\n\n\t\t/* skip not running jobs, unless -a was passed, or we did not\n\t\t * output anything yet and are at the last argument.  */\n\t\tif (!aflag && !islocked(fd) && (didsth || i != argc - 1)) {\n\t\t\tclose(fd);\n\t\t\tcontinue;\n\t\t}\n\n\t\twrite(1, \"==> \", 4);\n\t\twrite(1, argv[i], strlen(argv[i]));\n\t\twrite(1, qflag ? \" \" : \"\\n\", 1);\n\n\t\tdidsth = 1;\n\n#ifdef USE_INOTIFY\n\t\tchar fullpath[PATH_MAX];\n\t\tsnprintf(fullpath, sizeof fullpath, \"%s/%s\", path, argv[i]);\n\t\twd = inotify_add_watch(ifd, fullpath, IN_MODIFY | IN_CLOSE_WRITE);\n\t\tif (wd == -1) {\n\t\t\tperror(\"inotify_add_watch\");\n\t\t\texit(111);\n\t\t}\n#endif\n#ifdef USE_KEVENT\n\t\tnote = NOTE_WRITE;\n#ifdef __APPLE__\n\t\tnote |= NOTE_FUNLOCK;\n#endif\n#ifdef __FreeBSD__\n\t\tnote |= NOTE_CLOSE_WRITE;\n#endif\n\t\tEV_SET(&kev, fd, EVFILT_VNODE, EV_ADD | EV_CLEAR, note, 0, NULL);\n\t\tif (kevent(kq, &kev, 1, NULL, 0, NULL) < 0) {\n\t\t\tperror(\"kevent\");\n\t\t\texit(111);\n\t\t}\n#endif\n\n\t\twhile (1) {\n\t\t\toff = lseek(fd, 0, SEEK_END);\n\n\t\t\tif (off < loff)\n\t\t\t\tloff = off;               /* file truncated */\n\n\t\t\tif (off == loff) {\n\t\t\t\tif (nflag && islocked(fd))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (flock(fd, LOCK_SH | LOCK_NB) == -1 &&\n\t\t\t\t    errno == EWOULDBLOCK) {\n#if defined(USE_INOTIFY)\n\t\t\t\t\t/* any inotify event is good */\n\t\t\t\t\tread(ifd, ibuf, sizeof ibuf);\n#elif defined(USE_KEVENT)\n\t\t\t\t\tkevent(kq, NULL, 0, &kev, 1, NULL);\n#else\n\t\t\t\t\t/* poll for size change */\n\t\t\t\t\twhile (off == lseek(fd, 0, SEEK_END))\n\t\t\t\t\t\tusleep(DELAY);\n#endif\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tflock(fd, LOCK_UN);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (off - loff > sizeof buf)\n\t\t\t\toff = loff + sizeof buf;\n\n\t\t\trd = pread(fd, &buf, off - loff, loff);\n\t\t\tif (qflag) {\n\t\t\t\tif (!seen_nl) {\n\t\t\t\t\tchar *s;\n\t\t\t\t\tif ((s = memchr(buf, '\\n', rd))) {\n\t\t\t\t\t\twrite(1, buf, s+1-buf);\n\t\t\t\t\t\tseen_nl = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twrite(1, buf, rd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twrite(1, buf, rd);\n\t\t\t}\n\n\t\t\tloff += rd;\n\t\t}\n\n\t\tif (qflag && !seen_nl)\n\t\t\twrite(1, \"\\n\", 1);\n\n#ifdef USE_INOTIFY\n\t\tinotify_rm_watch(ifd, wd);\n#endif\n#ifdef USE_KEVENT\n\t\tEV_SET(&kev, fd, EVFILT_VNODE, EV_DELETE, 0, 0, NULL);\n\t\tkevent(kq, &kev, 1, NULL, 0, NULL);\n#endif\n\t\tclose(fd);\n\t}\n\n#ifdef USE_INOTIFY\n\tclose(ifd);\n#endif\n#ifdef USE_KEVENT\n\tclose(kq);\n#endif\n\treturn 0;\n}\n"
        },
        {
          "name": "nqtail.sh",
          "type": "blob",
          "size": 0.255859375,
          "content": "#!/bin/sh\n# nqtail - tail -F the queue outputs, quitting when the job finishes\n\ntailed=false\nfor f in ${NQDIR:-.}/,*; do\n\tif ! nq -t $f; then\n\t\ttailed=true\n\t\tprintf '==> %s\\n' \"$f\"\n\t\ttail -F $f & p=$!\n\t\tnq -w $f\n\t\tkill $p\n\tfi\ndone\n\nif ! $tailed; then\n\tcat $f\nfi\n"
        },
        {
          "name": "nqterm",
          "type": "blob",
          "size": 0.55078125,
          "content": "#!/bin/sh\n# nqterm CMD... - tmux/screen wrapper for nq to display output in new window\n\nset -e\n\ns=$(nq \"$@\")\np=${s##*.}\n\nprintf '%s\\n' \"$s\"\n\nif [ -n \"$p\" ]; then\n       \tif [ -n \"$TMUX\" ]; then\n\t\ttmux new-window -a -d -n '<' -c '#{pane_current_path}' \\\n\t\t\t\"trap true INT QUIT TERM EXIT;\n\t\t\tnqtail $s || kill $p;\n\t\t\tprintf '[%d exited, ^D to exit.]\\n' $p;\n\t\t\tcat >/dev/null\"\n\telif [ -n \"$STY\" ]; then\n\t\tscreen -t '<' sh -c \"trap true INT QUIT TERM EXIT;\n\t\t\tnqtail $s || kill $p\n\t\t\tprintf '[%d exited, ^D to exit.]\\n' $p;\n\t\t\tcat >/dev/null\"\n\t\tscreen -X other\n\tfi\nfi\n"
        },
        {
          "name": "nqterm.1",
          "type": "blob",
          "size": 0.947265625,
          "content": ".Dd July 3, 2024\n.Dt NQTERM 1\n.Os\n.Sh NAME\n.Nm nqterm\n.Nd job queue wrapper for tmux/screen\n.Sh SYNOPSIS\n.Nm\n.Ar command\\ line ...\n.Sh DESCRIPTION\n.Nm\nis a tiny wrapper around the\n.Xr nq 1\njob queue which automatically spawns a corresponding\n.Xr nqtail 1\nwatching process in a new\n.Xr tmux 1\nor\n.Xr screen 1\nwindow.\n.Pp\nYou can cancel the\n.Xr nq 1\njob by pressing\n.Ic C-c\nin the job output window.\n.Pp\nAfter the job has finished, the window will\nclose on\n.Ic C-d .\n.Sh ENVIRONMENT\n.Bl -hang -width Ds\n.It Ev NQDIR\nDirectory where lock files/job output resides, see\n.Xr nq 1 .\n.El\n.Sh EXIT STATUS\n.Ex -std\n.Sh SEE ALSO\n.Xr nq 1 ,\n.Xr nqtail 1 ,\n.Xr screen 1 ,\n.Xr tmux 1\n.Sh AUTHORS\n.An Leah Neukirchen Aq Mt leah@vuxu.org\n.Sh LICENSE\n.Nm\nis in the public domain.\n.Pp\nTo the extent possible under law,\nthe creator of this work\nhas waived all copyright and related or\nneighboring rights to this work.\n.Pp\n.Lk http://creativecommons.org/publicdomain/zero/1.0/\n.\\\" .Sh BUGS\n"
        },
        {
          "name": "tests",
          "type": "blob",
          "size": 2.453125,
          "content": "#!/bin/sh\n\n: ${NQ:=../nq}\n: ${NQTAIL:=../nqtail}\n\nset -e\n\ncheck() {\n  msg=$1\n  shift\n  if eval \"$@\" 2>/dev/null 1>&2; then\n    printf 'ok - %s\\n' \"$msg\"\n  else\n    printf 'not ok - %s\\n' \"$msg\"\n    false\n  fi\n  true\n}\n\nprintf '1..36\\n'\n\nrm -rf test.dir\nmkdir test.dir\n(\ncd test.dir\n\nprintf '# nq tests\\n'\ncheck 'fails with no arguments' ! $NQ\ncheck 'succeeds enqueuing true' 'f=$($NQ true)'\nsleep 1\ncheck 'generated a lockfile' test -f $f\ncheck 'lockfile contains exec line' grep -q exec.*nq.*true $f\ncheck 'lockfile contains status line' grep -q exited.*status.*0 $f\ncheck 'lockfile is not executable' ! test -x $f\n)\n\nrm -rf test.dir\nmkdir test.dir\n(\ncd test.dir\n\nprintf '# queue tests\\n'\ncheck 'enqueing true' f1=$($NQ true)\ncheck 'enqueing sleep 500' f2=$($NQ sleep 500)\ncheck 'first job is done already' $NQ -t $f1\ncheck 'not all jobs are done already' ! $NQ -t\ncheck 'running job is executable' test -x $f2\ncheck 'running job not done already' ! $NQ -t $f\ncheck 'can kill running job' kill ${f2##*.}\nsleep 1\ncheck 'killed job is not executable anymore' ! test -x $f2\ncheck 'killed job contains status line' grep -q killed.*signal.*15 $f2\n)\n\nrm -rf test.dir\nmkdir test.dir\n(\ncd test.dir\n\nprintf '# env tests\\n'\ncheck 'enqueing env' f1=$($NQ env)\n$NQ -w\ncheck 'NQJOBID is set' grep -q NQJOBID=$f1 $f1\n)\n\nrm -rf test.dir\nmkdir test.dir\n(\ncd test.dir\n\nprintf '# killing tests\\n'\ncheck 'spawning four jobs' 'f1=$($NQ sleep 100)'\ncheck 'spawning four jobs' 'f2=$($NQ sleep 1)'\ncheck 'spawning four jobs' 'f3=$($NQ sleep 100)'\ncheck 'spawning four jobs' 'f4=$($NQ sleep 1)'\ncheck 'killing first job' kill ${f1##*.}\ncheck 'killing third job' kill ${f3##*.}\ncheck 'second job is running' ! $NQ -t $f2\n$NQ -w $f2\ncheck 'fourth job is running' ! $NQ -t $f4\ncheck 'all jobs are done' $NQ -w\n)\n\nrm -rf test.dir\nmkdir test.dir\n(\ncd test.dir\n\nprintf '# nqtail tests\\n'\ncheck 'spawning four jobs' 'f1=$($NQ sleep 100)'\ncheck 'spawning four jobs' 'f2=$($NQ echo two)'\ncheck 'spawning four jobs' 'f3=$($NQ sleep 300)'\ncheck 'spawning four jobs' 'f4=$($NQ sleep 400)'\ncheck 'nqtail tracks first job' '($NQTAIL ,* & p=$!; sleep 1; kill $p) | sed 3q | grep -q sleep.*100'\ncheck 'killing first job' kill ${f1##*.}\ncheck 'killing fourth job' kill ${f4##*.}\nsleep 1\ncheck 'nqtail tracks third job' '($NQTAIL ,* & p=$!; sleep 1; kill $p) | sed 3q | grep -q sleep.*300'\ncheck 'killing third job' kill ${f3##*.}\nsleep 1\ncheck 'nqtail outputs last job when no job running' '$NQTAIL ,* | sed 3q | grep -q sleep.*400'\n)\n\nrm -rf test.dir\n"
        }
      ]
    }
  ]
}