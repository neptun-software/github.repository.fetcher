{
  "metadata": {
    "timestamp": 1736710201865,
    "page": 908,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cyd01/KiTTY",
      "stars": 1628,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".ccls",
          "type": "blob",
          "size": 0.4619140625,
          "content": "clang\n%c -std=c11\n-D__WINE__\n-DMOD_PERSO\n-DMOD_STARTBUTTON\n-DMOD_SAVEDUMP\n-DMOD_DISABLEALTGR\n-DMOD_KEYMAPPING\n-DMOD_PUTTYX\n-DMOD_PORTKNOCKING\n-DMOD_HYPERLINK\n-DMOD_PRINTCLIP\n-DMOD_LAUNCHER\n-DMOD_RECONNECT\n-DMOD_WTS\n-DMOD_TUTTY\n-DMOD_RUTTY\n-DMOD_ADB\n-DMOD_BACKGROUNDIMAGE\n-I0.73_My_PuTTY/\n-I.\n-I0.73_My_PuTTY/charset/\n-I0.73_My_PuTTY/windows/\n-I0.73_My_PuTTY/unix/\n-I0.73_My_PuTTY/mac/\n-I0.73_My_PuTTY/macosx/\n-Ibase64/\n-Ibcrypt/\n-Imd5/\n-Iregex/\n-Iurl/\n-Iwincrypt/\n-Irutty/\n"
        },
        {
          "name": ".devcontainer",
          "type": "tree",
          "content": null
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": "*.o\n*.map\n*.exe\n"
        },
        {
          "name": "0.76_My_PuTTY",
          "type": "tree",
          "content": null
        },
        {
          "name": "0.76b_My_PuTTY",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENCE.TXT",
          "type": "blob",
          "size": 1.0322265625,
          "content": "KiTTY is copyright 2007-2013 Cyril Dupont.\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation files\n(the \"Software\"), to deal in the Software without restriction,\nincluding without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software,\nand to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE\nFOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.6728515625,
          "content": "# Welcome to the KiTTY introduction web site\r\n\r\n<p style=\"text-align: center;\">\r\nAll KiTTY documentation is available on the official website<br/>\r\nhttps://www.9bis.com/kitty/\r\n</p>\r\n\r\n## What is KiTTY ?\r\nKiTTY is a fork from version 0.76 of **PuTTY**, the best telnet / SSH client in the world.\r\nKiTTY is only designed for the Microsoft(c) Windows(c) platform. For more information about the original software, or pre-compiled binaries on other systems, you can go to the [Simon Tatham PuTTY page](http://www.chiark.greenend.org.uk/~sgtatham/putty/ \"PuTTY\").\r\n\r\nKiTTY has all the features from the original software, and adds many others as described below:\r\n\r\n### The very first requested features\r\n* Sessions filter\r\n* Portability\r\n* Shortcuts for pre-defined command\r\n* The session launcher\r\n* Automatic logon script\r\n* Automatic logon script with the RuTTY patch\r\n* URL hyperlinks\r\n\r\n### Technical features\r\n* Automatic password\r\n* Automatic command\r\n* Running a locally saved script on a remote session\r\n\r\n### Graphical features\r\n* An icon for each session\r\n* Send to tray\r\n* Transparency\r\n* Protection against unfortunate keyboard input\r\n* Roll-up\r\n* Always visible\r\n* Quick start of a duplicate session\r\n* Enhanced Configuration Box\r\n\r\n### Other features\r\n* Automatic saving\r\n* SSH Handler: Internet Explorer integration\r\n* pscp.exe and WinSCP integration\r\n* Binary compression\r\n* Clipboard printing\r\n* Cygwin and cmd.exe integration\r\n* File association\r\n* Other settings\r\n* New command-line options\r\n\r\n### Bonus\r\n* A light chat server is hidden in KiTTY\r\n* A hidden text editor is integrated into KiTTY\r\n\r\n## Official download page\r\n\r\nKiTTY is available at our main CDN: [Fosshub](https://www.fosshub.com/KiTTY.html).\r\n\r\n## How to compile\r\nInside your MSYS & MinGW32 environment jump into the x.yy_My_PuTTY\\windows directory then run the command:\r\n\r\n    make -f MAKEFILE.MINGW putty.exe\r\n\r\n### How to install the MSYS/MinGW32 environment\r\nSimple guide to setup the compile environment:\r\n\r\n- Download the `mingw-builds-install.exe` from https://sourceforge.net/projects/mingwbuilds/files/host-windows/releases/4.8.0/32-bit/\r\n- Execute the installer and select the **GUI**.\r\n- After installing it, only the \"packager manager\" it's in fact installed, so execute `$MinGW\\libexec\\mingw-get\\guimain.exe` and select in the Basic Setup the packages: **\"mingwg-developer-tools\", \"mingw32-base\", \"mingw32-gcc-g++\" and \"msys-base\"**.\r\n- When all is installed, to open the SHELL execute `$MinGW\\msys\\1.0\\msys.bat`. Then from from this shell you can compile. Example: `cd $KiTTY_DIR/0.74_My_PuTTY/windows` and `make -f MAKEFILE.MINGW 9bis`.\r\n\r\nOriginal website is [https://www.9bis.com/kitty/](https://www.9bis.com/kitty/ \"KiTTY website\").\r\n"
        },
        {
          "name": "adb",
          "type": "tree",
          "content": null
        },
        {
          "name": "base64",
          "type": "tree",
          "content": null
        },
        {
          "name": "bcrypt",
          "type": "tree",
          "content": null
        },
        {
          "name": "blocnote",
          "type": "tree",
          "content": null
        },
        {
          "name": "cthelper",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "far2l",
          "type": "tree",
          "content": null
        },
        {
          "name": "jpeg",
          "type": "tree",
          "content": null
        },
        {
          "name": "kitty.c",
          "type": "blob",
          "size": 209.6279296875,
          "content": "/*************************************************\n** DEFINITION DES INCLUDES\n*************************************************/\n// Includes classiques\n#include <dirent.h>\n#include <io.h>\n#include <process.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/locking.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n// Includes de PuTTY\n#include \"putty.h\"\n#include \"terminal.h\"\n//#include \"ldisc.h\"\n//#include \"win_res.h\"\n#include \"putty-rc.h\"\n\n// Include specifiques Windows (windows.h doit imperativement etre declare en premier)\n#include <windows.h>\n#include <psapi.h>\n#include <iphlpapi.h>\n\n// Includes de KiTTY\n#include \"kitty.h\"\n#include \"kitty_commun.h\"\n#include \"kitty_image.h\"\n#include \"kitty_crypt.h\"\n#include \"kitty_registry.h\"\n#include \"kitty_tools.h\"\n#include \"kitty_win.h\"\n#include \"kitty_launcher.h\"\n#include \"MD5check.h\"\n/*************************************************\n** FIN DE LA DEFINITION DES INCLUDES\n*************************************************/\n\n\n/*************************************************\n** DEFINITION DE LA STRUCTURE DE CONFIGURATION\n*************************************************/\n// La structure de configuration est instanciee dans window.c\nextern Conf *conf ;\n\n#ifndef SAVEMODE_REG\n#define SAVEMODE_REG 0\n#endif\n#ifndef SAVEMODE_FILE\n#define SAVEMODE_FILE 1\n#endif\n#ifndef SAVEMODE_DIR\n#define SAVEMODE_DIR 2\n#endif\n\n// Flag pour le fonctionnement en mode \"portable\" (gestion par fichiers), defini dans kitty_commun.c\nextern int IniFileFlag ;\n\n// Flag permettant la gestion de l'arborscence (dossier=folder) dans le cas d'un savemode=dir, defini dans kitty_commun.c\nextern int DirectoryBrowseFlag ;\nint GetDirectoryBrowseFlag(void) { return DirectoryBrowseFlag ; }\nvoid SetDirectoryBrowseFlag( const int flag ) { DirectoryBrowseFlag = flag ; }\n\n\n#define SI_INIT 0\n#define SI_NEXT 1\n#define SI_RANDOM 2\n\n// Stuff for drag-n-drop transfers\n#define TIMER_DND 8777\nint dnd_delay = 250;\nHDROP hDropInf = NULL;\n\n// Delai avant d'envoyer le password et d'envoyer vers le tray (automatiquement à la connexion) (en milliseconde)\nint init_delay = 2000 ;\n// Delai entre chaque ligne de la commande automatique (en milliseconde)\nint autocommand_delay = 5 ;\n// Delai entre chaque caracteres d'une commande (en millisecondes)\nint between_char_delay = 0 ;\n// Delai entre deux lignes d'une meme commande et entre deux raccourcis \\x \\k\nint internal_delay = 10 ;\n\n// Pointeur sur la commande autocommand\nchar * AutoCommand = NULL ;\n\n// Contenu d'un script a envoyer à l'ecran\nchar * ScriptCommand = NULL ;\n\n// Pointeur sur la commande a passer ligne a ligne\nchar * PasteCommand = NULL ;\n\n// Flag pour utiliser la commande paste ligne a ligne (shift+bouton droit au lieu de bouton droit seul) dans le cas de serveur lent\nstatic int PasteCommandFlag = 0 ;\nint GetPasteCommandFlag(void) { return PasteCommandFlag ; }\n\n// paste size limit (number of characters). Above the limit a confirmation is requested. (0 means unlimited)\nstatic int PasteSize = 0 ;\nint GetPasteSize(void) { return PasteSize ; }\nvoid SetPasteSize( const int size ) { PasteSize = size ; }\n\n// Flag de gestion de la fonction hyperlink\n#ifdef FLJ\nint HyperlinkFlag = 1 ;\n#else\n#ifdef MOD_HYPERLINK\nint HyperlinkFlag = 1 ;\n#else\nint HyperlinkFlag = 0 ;\n#endif\n#endif\nint GetHyperlinkFlag(void) { return HyperlinkFlag ; }\nvoid SetHyperlinkFlag( const int flag ) { HyperlinkFlag = flag ; }\n\n// Flag de gestion de la fonction \"rutty\" (script automatique)\nstatic int RuttyFlag = 1 ;\nint GetRuttyFlag(void) { return RuttyFlag ; } \nvoid SetRuttyFlag( const int flag ) { RuttyFlag = flag ; }\n\n// Flag de gestion de la Transparence\n#ifdef FLJ\nstatic int TransparencyFlag = 1 ;\n#else\nstatic int TransparencyFlag = 1 ;\n#endif\nint GetTransparencyFlag(void) { return TransparencyFlag ; }\nvoid SetTransparencyFlag( const int flag ) { TransparencyFlag = flag ; }\n\n// Gestion du script file au lancement\nchar * ScriptFileContent = NULL ;\n\n// Flag pour la protection contre les saisies malheureuses\nstatic int ProtectFlag = 0 ; \nint GetProtectFlag(void) { return ProtectFlag ; }\nvoid SetProtectFlag( const int flag ) { ProtectFlag = flag ; }\n\n// Flags de definition du mode de sauvegarde\n#ifndef SAVEMODE_REG\n#define SAVEMODE_REG 0\n#endif\n#ifndef SAVEMODE_FILE\n#define SAVEMODE_FILE 1\n#endif\n#ifndef SAVEMODE_DIR\n#define SAVEMODE_DIR 2\n#endif\n\n// Definition de la section du fichier de configuration\n#if (defined MOD_PERSO) && (!defined FLJ)\n#ifndef INIT_SECTION\n#define INIT_SECTION \"KiTTY\"\n#endif\n#ifndef DEFAULT_INIT_FILE\n#define DEFAULT_INIT_FILE \"kitty.ini\"\n#endif\n#ifndef DEFAULT_SAV_FILE\n#define DEFAULT_SAV_FILE \"kitty.sav\"\n#endif\n#ifndef DEFAULT_EXE_FILE\n#define DEFAULT_EXE_FILE \"kitty.exe\"\n#endif\n#else\n#ifndef INIT_SECTION\n#define INIT_SECTION \"PuTTY\"\n#endif\n#ifndef DEFAULT_INIT_FILE\n#define DEFAULT_INIT_FILE \"putty.ini\"\n#endif\n#ifndef DEFAULT_SAV_FILE\n#define DEFAULT_SAV_FILE \"putty.sav\"\n#endif\n#ifndef DEFAULT_EXE_FILE\n#define DEFAULT_EXE_FILE \"putty.exe\"\n#endif\n#endif\n\n#ifndef VISIBLE_NO\n#define VISIBLE_NO 0\n#endif\n#ifndef VISIBLE_YES\n#define VISIBLE_YES 1\n#endif\n#ifndef VISIBLE_TRAY\n#define VISIBLE_TRAY -1\n#endif\n\n// Flag de definition de la visibilite d'une fenetres\nstatic int VisibleFlag = VISIBLE_YES ;\nint GetVisibleFlag(void) { return VisibleFlag ; }\nvoid SetVisibleFlag( const int flag ) { VisibleFlag = flag ; }\n\n// Flag pour inhiber les raccourcis clavier\n#ifdef FLJ\nstatic int ShortcutsFlag = 0 ;\n#else\nstatic int ShortcutsFlag = 1 ;\n#endif\nint GetShortcutsFlag(void) { return ShortcutsFlag ; }\nvoid SetShortcutsFlag( const int flag ) { ShortcutsFlag = flag ; }\n\n// Flag pour inhiber les raccourcis souris\nstatic int MouseShortcutsFlag = 1 ;\nint GetMouseShortcutsFlag(void) { return MouseShortcutsFlag  ; }\nvoid SetMouseShortcutsFlag( const int flag ) { MouseShortcutsFlag  = flag ; }\n\n// Flag pour permettre la definition d'icone de connexion\nstatic int IconeFlag = 0 ;\nint GetIconeFlag(void) { return IconeFlag ; }\nvoid SetIconeFlag( const int flag ) { IconeFlag = flag ; }\n\n// Nombre d'icones differentes (identifiant commence a 1 dans le fichier .rc)\n#ifndef MOD_PERSO\n#define NB_ICONES 1\n#define IDI_MAINICON_0 1\n#define IDC_RESULT 1008\n#endif\nstatic int NumberOfIcons = NB_ICONES ;\nint GetNumberOfIcons(void) { return NumberOfIcons ; }\nvoid SetNumberOfIcons( const int flag ) { NumberOfIcons = flag ; }\n\nstatic int IconeNum = 0 ;\nint GetIconeNum(void) { return IconeNum ; }\nvoid SetIconeNum( const int num ) { IconeNum = num ; }\n\n// La librairie dans laquelle chercher les icones (fichier defini dans kitty.ini, sinon kitty.dll s'il existe, sinon kitty.exe)\nstatic HINSTANCE hInstIcons =  NULL ;\nHINSTANCE GethInstIcons(void) { return hInstIcons ; }\nvoid SethInstIcons( const HINSTANCE h ) { hInstIcons = h ; }\n\n// Fichier contenant les icones à charger\nstatic char * IconFile = NULL ;\n\n// Flag pour l'affichage de la taille de la fenetre\nstatic int SizeFlag = 0 ;\nint GetSizeFlag(void) { return SizeFlag ; }\nvoid SetSizeFlag( const int flag ) { SizeFlag = flag ; }\n\n// Flag pour imposer le passage en majuscule\nstatic int CapsLockFlag = 0 ;\nint GetCapsLockFlag(void) { return CapsLockFlag ; }\nvoid SetCapsLockFlag( const int flag ) { CapsLockFlag = flag ; }\n\n// Flag pour gerer la presence de la barre de titre\nstatic int TitleBarFlag = 1 ;\nint GetTitleBarFlag(void) { return TitleBarFlag ; }\nvoid SetTitleBarFlag( const int flag ) { TitleBarFlag = flag ; }\n\n// Hauteur de la fenetre pour la fonction WinHeight\nstatic int WinHeight = -1 ;\nint GetWinHeight(void) { return WinHeight ; }\nvoid SetWinHeight( const int num ) { WinHeight = num ; }\n// Flag pour inhiber le Winrol\nstatic int WinrolFlag = 1 ;\nint GetWinrolFlag(void) { return WinrolFlag ; }\nvoid SetWinrolFlag( const int num ) { WinrolFlag  = num ; }\n\n// Password de protection de la configuration (registry)\nstatic char PasswordConf[256] = \"\" ;\n\n// Renvoi automatiquement dans le tray (pour les tunnel), fonctionne avec le l'option -send-to-tray\nstatic int AutoSendToTray = 0 ;\nint GetAutoSendToTray( void ) { return AutoSendToTray ; }\nvoid SetAutoSendToTray( const int flag ) { AutoSendToTray = flag ; }\n\n// Flag pour ne pas creer les fichiers kitty.ini et kitty.sav\nstatic int NoKittyFileFlag = 0 ;\nint GetNoKittyFileFlag(void) { return NoKittyFileFlag ; }\nvoid SetNoKittyFileFlag( const int flag ) { NoKittyFileFlag = flag ; }\n\n// Hauteur de la boite de configuration\nstatic int ConfigBoxHeight = 21 ;\nint GetConfigBoxHeight(void) { return ConfigBoxHeight ; }\nvoid SetConfigBoxHeight( const int num ) { ConfigBoxHeight = num ; }\n\n// Hauteur de la fenetre de la boite de configuration (0=valeur par defaut)\nstatic int ConfigBoxWindowHeight = 0 ;\nint GetConfigBoxWindowHeight(void) { return ConfigBoxWindowHeight ; }\nvoid SetConfigBoxWindowHeight( const int num ) { ConfigBoxWindowHeight = num ; }\n\n// Flag pour retourner à la Config Box en fin d'execution\nstatic int ConfigBoxNoExitFlag = 0 ;\nint GetConfigBoxNoExitFlag(void) { return ConfigBoxNoExitFlag ; }\nvoid SetConfigBoxNoExitFlag( const int flag ) { ConfigBoxNoExitFlag = flag ; }\n\n// ConfigBox X-position\nstatic int ConfigBoxLeft = -1 ;\nint GetConfigBoxLeft() { return ConfigBoxLeft ; }\nvoid SetConfigBoxLeft( const int val ) { ConfigBoxLeft = val ; }\n\n// ConfigBox Y-position\nstatic int ConfigBoxTop = -1 ;\nint GetConfigBoxTop() { return ConfigBoxTop ; }\nvoid SetConfigBoxTop( const int val ) { ConfigBoxTop= val ; }\n\n// Flag pour inhiber la gestion du CTRL+TAB\nstatic int CtrlTabFlag = 1 ;\nint GetCtrlTabFlag(void) { return CtrlTabFlag  ; }\nvoid SetCtrlTabFlag( const int flag ) { CtrlTabFlag  = flag ; }\n\n#ifdef MOD_RECONNECT\n// Flag pour inhiber le mécanisme de reconnexion automatique\nstatic int AutoreconnectFlag = 1 ;\nint GetAutoreconnectFlag( void ) { return AutoreconnectFlag ; }\nvoid SetAutoreconnectFlag( const int flag ) { AutoreconnectFlag = flag ; }\n// Delai avant de tenter une reconnexion automatique\nstatic int ReconnectDelay = 5 ;\nint GetReconnectDelay(void) { return ReconnectDelay ; }\nvoid SetReconnectDelay( const int flag ) { ReconnectDelay = flag ; }\n#endif\n\n// Flag pour inhiber le comportement ou toutes les sessions appartiennent au folder defaut\nstatic int SessionsInDefaultFlag = 1 ;\nint GetSessionsInDefaultFlag(void) { return SessionsInDefaultFlag ; }\nvoid SetSessionsInDefaultFlag( const int flag ) { SessionsInDefaultFlag = flag ; }\n\n// Flag pour inhiber la creation automatique de la session Default Settings\n// [ConfigBox] defaultsettings=yes\nstatic int DefaultSettingsFlag = 1 ;\nint GetDefaultSettingsFlag(void) { return DefaultSettingsFlag ; }\nvoid SetDefaultSettingsFlag( const int flag ) { DefaultSettingsFlag = flag ; }\n\n// Flag pour définir l'action a executer sur un double clic sur une session de la liste des sessions\n// [ConfigBox] dblclick=open\nstatic int DblClickFlag = 0 ;\nint GetDblClickFlag(void) { return DblClickFlag ; }\nvoid SetDblClickFlag( const int flag ) { DblClickFlag = flag ; }\n\n// Flag pour inhiber le filtre sur la liste des sessions de la boite de configuration\nstatic int SessionFilterFlag = 1 ;\nint GetSessionFilterFlag(void) { return SessionFilterFlag ; }\nvoid SetSessionFilterFlag( const int flag ) { SessionFilterFlag = flag ; }\n\n// Flag pour passer en mode visualiseur d'images\nstatic int ImageViewerFlag = 0 ;\nint GetImageViewerFlag(void) { return ImageViewerFlag  ; }\nvoid SetImageViewerFlag( const int flag ) { ImageViewerFlag = flag ; }\n\n// Duree (en secondes) pour switcher l'image de fond d'ecran (<=0 pas de slide)\nint ImageSlideDelay = - 1 ;\n\n// Nombre de clignotements max de l'icone dans le systeme tray lors de la reception d'un BELL\nint MaxBlinkingTime = 0 ;\n\n// Compteur pour l'envoi de anti-idle\nint AntiIdleCount = 0 ;\nint AntiIdleCountMax = 6 ;\nchar AntiIdleStr[128] = \"\" ;  // Ex: \" \\x08\"   => Fait un espace et le retire tout de suite\n\n// Chemin vers le programme cthelper.exe\nchar * CtHelperPath = NULL ;\n\n// Chemin vers le programme WinSCP\nchar * WinSCPPath = NULL ;\n\n// Chemin vers le programme pscp.exe\nchar * PSCPPath = NULL ;\n\n// Chemin vers le programme plink.exe\nchar * PlinkPath = NULL ;\n\n// Repertoire de lancement\nchar InitialDirectory[4096]=\"\" ;\n\n// Chemin complet des fichiers de configuration kitty.ini et kitty.sav\nstatic char * KittyIniFile = NULL ;\nstatic char * KittySavFile = NULL ;\n\n// Nom de la classe de l'application\nchar KiTTYClassName[128] = \"\" ;\n\n// Parametres de l'impression\nextern int PrintCharSize ;\nextern int PrintMaxLinePerPage ;\nextern int PrintMaxCharPerLine ;\n\nextern char puttystr[1024] ;\n\n#ifdef MOD_PROXY\n#include \"kitty_proxy.h\"\n#endif\n\n// Handle sur la fenetre principale\nHWND MainHwnd ;\nHWND GetMainHwnd(void) { return MainHwnd ; }\n\n// Decompte du nombre de fenetres en cours de KiTTY\nstatic int NbWindows = 0 ;\n\nNOTIFYICONDATA TrayIcone ;\n#define MYWM_NOTIFYICON\t\t(WM_USER+3)\n\n#define TIMER_INIT 8701\n#define TIMER_AUTOCOMMAND 8702\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n#define TIMER_SLIDEBG 8703\n#endif\n#define TIMER_REDRAW 8704\n#define TIMER_AUTOPASTE 8705\n#define TIMER_BLINKTRAYICON 8706\n#define TIMER_LOGROTATION 8707\n#define TIMER_ANTIIDLE 8708\n\n/*\n#define TIMER_INIT 12341\n#define TIMER_AUTOCOMMAND 12342\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n#define TIMER_SLIDEBG 12343\n#endif\n#define TIMER_REDRAW 12344\n#define TIMER_AUTOPASTE 12345\n#define TIMER_BLINKTRAYICON 12346\n#define TIMER_LOGROTATION 12347\n*/\n\n\n#ifndef BUILD_TIME\n#define BUILD_TIME \"Undefined\"\n#endif\n\n#ifndef BUILD_VERSION\n#define BUILD_VERSION \"0.0\"\n#endif\n\n#ifndef BUILD_SUBVERSION\n#define BUILD_SUBVERSION 0\n#endif\n\nchar BuildVersionTime[256] = \"0.0.0.0 @ 0\" ;\n\n// Gestion des raccourcis\n#define SHIFTKEY 500\n#define CONTROLKEY 1000\n#define ALTKEY 2000\n#define ALTGRKEY 4000\n#define WINKEY 8000\n\n// F1=0x70 (112) => F12=0x7B (123)\n\t\nstatic struct TShortcuts {\n\tint autocommand ;\n\tint command ;\n\tint editor ;\n\tint editorclipboard ;\n\tint getfile ;\n\tint imagechange ;\n\tint input ;\n\tint inputm ;\n\tint print ;\n\tint printall ;\n\tint protect ;\n\tint script ;\n\tint sendfile ;\n\tint rollup ;\n\tint tray ;\n\tint viewer ;\n\tint visible ;\n\tint winscp ;\n\tint switchlogmode ;\n\tint showportforward ;\n\tint resetterminal ;\n\tint duplicate ;\n\tint opennew ;\n\tint opennewcurrent ;\n\tint changesettings ;\n\tint clearscrollback ;\n\tint clearlogfile ;\n\tint closerestart ;\n\tint eventlog ;\n\tint fullscreen ;\n\tint fontup ;\n\tint fontdown ;\n\tint copyall ;\n\tint fontnegative ;\n\tint fontblackandwhite ;\n\tint keyexchange ;\n\t} shortcuts_tab ;\n\nstatic int NbShortCuts = 0 ;\nstatic struct TShortcuts2 { int num ; char * st ; } shortcuts_tab2[512] ;\n\nstatic char * InputBoxResult = NULL ;\n\n// Procedure de debug\nvoid debug_log( const char *fmt, ... ) {\n\tchar filename[4096]=\"\" ;\n\tva_list ap;\n\tFILE *fp ;\n\n\tif( (InitialDirectory!=NULL) && (strlen(InitialDirectory)>0) )\n\t\tsprintf(filename,\"%s\\\\kitty.log\",InitialDirectory);\n\telse strcpy(filename,\"kitty.log\");\n\n\tva_start( ap, fmt ) ;\n\t//vfprintf( stdout, fmt, ap ) ; // Ecriture a l'ecran\n\tif( ( fp = fopen( filename, \"ab\" ) ) != NULL ) {\n\t\tvfprintf( fp, fmt, ap ) ; // ecriture dans un fichier\n\t\tfclose( fp ) ;\n\t}\n \n\tva_end( ap ) ;\n}\n\n// Procedure d'affichage d'un message\nvoid debug_msg( const char *fmt, ... ) {\n\tchar buffer[4096]=\"\" ;\n\tva_list ap;\n\tva_start( ap, fmt ) ;\n\tvsprintf( buffer, fmt, ap ) ;\n\tMessageBox( NULL, buffer, \"Debug\", MB_OK ) ;\n\tva_end( ap ) ;\n}\n\t\n// Affiche un message avec l'usage memoire\nvoid debug_mem( const char *fmt, ... ) {\n\tchar buffer[4096]=\"\" ;\n\tva_list ap;\n\tva_start( ap, fmt ) ;\n\tvsprintf( buffer, fmt, ap ) ; strcat(buffer,\" \");\n\t\n/*\tHANDLE hProcess;\n\tPROCESS_MEMORY_COUNTERS_EX pmc;\n\n\thProcess = OpenProcess(  PROCESS_QUERY_INFORMATION |\n                                    PROCESS_VM_READ,\n                                    FALSE, GetCurrentProcessId() );\n\tif (NULL == hProcess)\n\t\treturn;\n\n\tif ( GetProcessMemoryInfo( hProcess, &pmc, sizeof(pmc)) ) {\n\t\tsprintf( buffer+strlen(buffer), \"%ld %ld\", pmc.WorkingSetSize, pmc.PrivateUsage );\n\t\t}\n\tCloseHandle( hProcess );\n*/\n\t\n/*\n\t\nhttp://stackoverflow.com/questions/548819/how-to-determine-a-process-virtual-size-winxp\t\nAccording to MSDN: Memory Performance Information PROCESS_MEMORY_COUNTERS_EX.PrivateUsage is the same as VM Size in Task Manager in Windows XP. GetProcessMemoryInfo should work:\nPROCESS_MEMORY_COUNTERS_EX pmcx = {};\npmcx.cb = sizeof(pmcx);\nGetProcessMemoryInfo(GetCurrentProcess(),\n    reinterpret_cast<PROCESS_MEMORY_COUNTERS*>(&pmcx), pmcx.cb);\nNow pmcx.PrivateUsage holds the VM Size of the process.\n\nhttp://msdn.microsoft.com/en-us/library/ms683219%28VS.85%29.aspx\nhttp://msdn.microsoft.com/en-us/library/ms682050%28v=vs.85%29.aspx\n\nvoid PrintMemoryInfo( DWORD processID )\n{\n    HANDLE hProcess;\n    PROCESS_MEMORY_COUNTERS pmc;\n\n    // Print the process identifier.\n\n    printf( \"\\nProcess ID: %u\\n\", processID );\n\n    // Print information about the memory usage of the process.\n\n    hProcess = OpenProcess(  PROCESS_QUERY_INFORMATION |\n                                    PROCESS_VM_READ,\n                                    FALSE, processID );\n    if (NULL == hProcess)\n        return;\n\n    if ( GetProcessMemoryInfo( hProcess, &pmc, sizeof(pmc)) )\n    {\n        printf( \"\\tPageFaultCount: 0x%08X\\n\", pmc.PageFaultCount );\n        printf( \"\\tPeakWorkingSetSize: 0x%08X\\n\", \n                  pmc.PeakWorkingSetSize );\n        printf( \"\\tWorkingSetSize: 0x%08X\\n\", pmc.WorkingSetSize );\n        printf( \"\\tQuotaPeakPagedPoolUsage: 0x%08X\\n\", \n                  pmc.QuotaPeakPagedPoolUsage );\n        printf( \"\\tQuotaPagedPoolUsage: 0x%08X\\n\", \n                  pmc.QuotaPagedPoolUsage );\n        printf( \"\\tQuotaPeakNonPagedPoolUsage: 0x%08X\\n\", \n                  pmc.QuotaPeakNonPagedPoolUsage );\n        printf( \"\\tQuotaNonPagedPoolUsage: 0x%08X\\n\", \n                  pmc.QuotaNonPagedPoolUsage );\n        printf( \"\\tPagefileUsage: 0x%08X\\n\", pmc.PagefileUsage ); \n        printf( \"\\tPeakPagefileUsage: 0x%08X\\n\", \n                  pmc.PeakPagefileUsage );\n    }\n\n    CloseHandle( hProcess );\n}\t\n*/\n\n\tMessageBox( NULL, buffer, \"Debug\", MB_OK ) ;\n\tva_end( ap ) ;\n\t}\n\t\n// Procedure de debug socket\nstatic int debug_sock_fd = 0 ;\nstatic va_list ap;\nstatic char bief[1024];\nvoid debug_sock( const char *fmt, ...) {\n\nreturn ;\n\t\n\tif( debug_sock_fd == -1 ) {return; }\n\t\n\tif( debug_sock_fd == 0 ) {\n\t\tstruct sockaddr_in sin ;\n\t\tstruct hostent * remote_host ;\n\t\tif( (debug_sock_fd = socket( AF_INET, SOCK_STREAM, 0 ))>0 ) {\n\t\t\tif( (remote_host = gethostbyname( \"localhost\" ))!=0 ) {\n\t\t\t\tmemset( &sin, 0, sizeof( sin ) ) ;\n\t\t\t\tsin.sin_family = AF_INET ;\n\t\t\t\tsin.sin_addr.s_addr = INADDR_ANY ;\n\t\t\t\tsin.sin_port = htons( (u_short)9669 ) ;\n\t\t\t\tmemcpy( (char*)&sin.sin_addr, remote_host->h_addr, remote_host->h_length ) ;\n\t\t\t\tmemset( sin.sin_zero, 0, 8 ) ;\n\t\t\t\tif( connect( debug_sock_fd, (struct sockaddr *)&sin, sizeof( sin )) < 0 ) { debug_sock_fd=0 ; }\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { debug_sock_fd=-1 ; }\n\t\t}\n\tif( debug_sock_fd > 0 ) {\n\t\tva_start( ap, fmt ) ;\n\t\tbief[0]='\\0';\n\t\tvsprintf( bief, fmt, ap ) ;\n\t\tbief[1024]='\\0';\n\t\tsend( debug_sock_fd, (char*)bief, strlen(bief), 0 ) ;\n\t\tva_end( ap ) ;\n\t\t}\n\t}\n\nchar *dupvprintf(const char *fmt, va_list ap) ;\n\t\n// Procedure de recuperation de la valeur d'un flag\nint get_param( const char * val ) {\n\tif( !stricmp( val, \"PUTTY\" ) ) return GetPuttyFlag() ;\n\telse if( !stricmp( val, \"INIFILE\" ) ) return IniFileFlag ;\n\telse if( !stricmp( val, \"DIRECTORYBROWSE\" ) ) return DirectoryBrowseFlag ;\n\telse if( !stricmp( val, \"HYPERLINK\" ) ) return HyperlinkFlag ;\n\telse if( !stricmp( val, \"TRANSPARENCY\" ) )return TransparencyFlag ;\n#ifdef MOD_ZMODEM\n\telse if( !stricmp( val, \"ZMODEM\" ) ) return GetZModemFlag() ;\n#endif\n#ifdef MOD_BACKGROUNDIMAGE\n\telse if( !stricmp( val, \"BACKGROUNDIMAGE\" ) ) return GetBackgroundImageFlag() ;\n#endif\n\t// else if( !stricmp( val, \"CONFIGBOXHEIGHT\" ) ) return ConfigBoxHeight ;\n\t// else if( !stricmp( val, \"AUTOSTORESSHKEY\" ) ) return AutoStoreSSHKeyFlag ;\n\t// else if( !stricmp( val, \"CONFIGBOXWINDOWHEIGHT\" ) ) return ConfigBoxWindowHeight ;\n\t// else if( !stricmp( val, \"NUMBEROFICONS\" ) ) return NumberOfIcons ;\t// ==> Remplace par GetNumberOfIcons()\n\t// else if( !stricmp( val, \"ICON\" ) ) return IconeFlag ; // ==> Remplace par GetIconeFlag()\n\t// else if( !stricmp( val, \"SESSIONFILTER\" ) ) return SessionFilterFlag ;\n\treturn 0 ;\n\t}\n\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\t/* Le patch Background image ne marche plus bien sur la version PuTTY 0.61\n\t\t- il est en erreur lorsqu'on passe par la config box\n\t\t- il est ok lorsqu'on demarrer par -load ou par duplicate session\n\t   On le desactive dans la config box (fin du fichier WINCFG.C)\n\t*/\nvoid DisableBackgroundImage( void ) { SetBackgroundImageFlag(0) ; }\n#endif\n\n// Procedure de recuperation de la valeur d'une chaine\nchar * get_param_str( const char * val ) {\n\tif( !stricmp( val, \"INI\" ) ) return KittyIniFile ;\n\telse if( !stricmp( val, \"SAV\" ) ) return KittySavFile ;\n\telse if( !stricmp( val, \"NAME\" ) ) return INIT_SECTION ;\n\telse if( !stricmp( val, \"CLASS\" ) ) return KiTTYClassName ;\n\treturn NULL ;\n\t}\n\n#ifdef MOD_ZMODEM\nvoid xyz_updateMenuItems(Terminal *term) {\n\tif( !GetZModemFlag() ) return ;\n\tHMENU m = GetSystemMenu(MainHwnd, FALSE);\n//\tEnableMenuItem(m, IDM_XYZSTART, term->xyz_transfering?MF_GRAYED:MF_ENABLED);\n\tEnableMenuItem(m, IDM_XYZSTART, term->xyz_transfering?MF_GRAYED:MF_DISABLED);\n\tEnableMenuItem(m, IDM_XYZUPLOAD, term->xyz_transfering?MF_GRAYED:MF_ENABLED);\n\tEnableMenuItem(m, IDM_XYZABORT, !term->xyz_transfering?MF_GRAYED:MF_ENABLED);\n\n}\n#endif\n\nchar * kitty_current_dir() { \n\t\n\nreturn NULL ;  /* Ce code est tres specifique et ne marche pas partout */\n\t/*\n\tstatic char cdir[1024]; \n\tchar * dir = strstr(term->osc_string, \":\") ; \n\tif(dir) { \n\t\tif( strlen(dir) > 1 ) {\n\t\t\tdir = dir + 1 ;\n\t\t\tif(*dir == '~') {\n\t\t\t\tif(strlen(conf_get_str(conf,CONF_username))>0) { \n\t\t\t\t\tsnprintf(cdir, 1024, \"\\\"/home/%s/%s\\\"\", conf_get_str(conf,CONF_username), dir + 1); \n\t\t\t\t\treturn cdir; \n\t\t\t\t}\n\t\t\t} else if(*dir == '/') { \n\t\t\t\tsnprintf(cdir, 1024, \"\\\"%s\\\"\", dir); \n\t\t\t\treturn cdir; \n\t\t\t} \n\t\t} \n\t}\n\treturn NULL; \n\t*/\n} \n\n// Liste des folder\nchar **FolderList=NULL ;\n\nint readINI( const char * filename, const char * section, const char * key, char * pStr) ;\nint writeINI( const char * filename, const char * section, const char * key, char * pStr) ;\nint delINI( const char * filename, const char * section, const char * key ) ;\n// Initialise la liste des folders a partir des sessions deja existantes et du fichier kitty.ini\nvoid InitFolderList( void ) {\n\tchar * pst, fList[4096], buffer[4096] ;\n\tint i ;\n\tFolderList=(char**)malloc( 1024*sizeof(char*) );\n\tFolderList[0] = NULL ;\n\tStringList_Add( FolderList, \"Default\" ) ;\n\t//if( GetValueData(HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), \"Folders\", fList) == NULL ) return ;\n\t//if( ReadParameter( \"KiTTY\", \"Folders\", fList ) == 0 ) return ;\n\tReadParameter( INIT_SECTION, \"Folders\", fList ) ;\n\tif( strlen( fList ) != 0 ) {\n\t\tpst = fList ;\n\t\twhile( strlen( pst ) > 0 ) {\n\t\t\ti = 0 ;\n\t\t\twhile( ( pst[i] != ',' ) && ( pst[i] != '\\0' ) ) {\n\t\t\t\tbuffer[i] = pst[i] ;\n\t\t\t\ti++ ;\n\t\t\t\t}\n\t\t\tbuffer[i] = '\\0' ;\n\t\t\tStringList_Add( FolderList, buffer ) ;\n\t\t\tif( pst[i] == '\\0' ) pst = pst + i ;\n\t\t\telse pst = pst + i + 1 ;\n\t\t\t}\n\t\t//free( fList ) ; fList = NULL ;\n\t\t}\n\t\n\tif( (IniFileFlag==SAVEMODE_REG)||(IniFileFlag==SAVEMODE_FILE) ) {\n\t\tHKEY hKey ;\n\t\tTCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name\n\t\tDWORD    cbName;                   // size of name string \n\t\tTCHAR    achClass[MAX_PATH] = TEXT(\"\");  // buffer for class name \n\t\tDWORD    cchClassName = MAX_PATH;  // size of class string \n\t\tDWORD    cSubKeys=0;               // number of subkeys \n\t\tDWORD    cbMaxSubKey;              // longest subkey size \n\t\tDWORD    cchMaxClass;              // longest class string \n\t\tDWORD    cValues;              // number of values for key \n\t\tDWORD    cchMaxValue;          // longest value name \n\t\tDWORD    cbMaxValueData;       // longest value data \n\t\tDWORD    cbSecurityDescriptor; // size of security descriptor \n\t\tFILETIME ftLastWriteTime;      // last write time \n\t\tDWORD retCode; \n\n\t\tsprintf( buffer, \"%s\\\\\\\\Sessions\", PUTTY_REG_POS );\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, buffer, 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n\t\n\t\tretCode = RegQueryInfoKey(\n\t\thKey,                    // key handle \n\t\tachClass,                // buffer for class name \n\t\t&cchClassName,           // size of class string \n\t\tNULL,                    // reserved \n\t\t&cSubKeys,               // number of subkeys \n\t\t&cbMaxSubKey,            // longest subkey size \n\t\t&cchMaxClass,            // longest class string \n\t\t&cValues,                // number of values for this key \n\t\t&cchMaxValue,            // longest value name \n\t\t&cbMaxValueData,         // longest value data \n\t\t&cbSecurityDescriptor,   // security descriptor \n\t\t&ftLastWriteTime);       // last write time \n\t\t// Enumerate the subkeys, until RegEnumKeyEx fails.\n\t\tif (cSubKeys) {\n\t\t\tfor (i=0; i<cSubKeys; i++) { \n\t\t\t\tcbName = MAX_KEY_LENGTH;\n\t\t\t\tretCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime); \n\t\t\t\tif (retCode == ERROR_SUCCESS) {\n\t\t\t\t\tchar nValue[1024] ;\n\t\t\t\t\tsprintf( nValue, \"%s\\\\%s\", buffer, achKey ) ;\n\t\t\t\t\tif( GetValueData(HKEY_CURRENT_USER, nValue, \"Folder\", fList ) != NULL ) {\n\t\t\t\t\t\tif( strlen( fList ) > 0 ) \n\t\t\t\t\t\t\tStringList_Add( FolderList, fList ) ;\n\t\t\t\t\t\t//free( fList ) ; fList = NULL ;\n\t\t\t\t\t\t}\n\t\t\t\n\t\t}\n\t\t\t\t}\n\t\t\t} \n\t\tRegCloseKey( hKey ) ;\n\t\t}\n\telse if( (IniFileFlag == SAVEMODE_DIR)&&(!DirectoryBrowseFlag) ) {\n\t\tDIR * dir ;\n\t\tstruct dirent * de ;\n\t\tsprintf( buffer, \"%s\\\\Sessions\", ConfigDirectory ) ;\n\t\tif( (dir=opendir(buffer)) != NULL ) {\n\t\t\twhile( (de=readdir(dir)) != NULL ) \n\t\t\tif( strcmp(de->d_name, \".\")&&strcmp(de->d_name, \"..\") ) {\n\t\t\t\tunmungestr( de->d_name, fList, 1024 ) ;\n\t\t\t\tGetSessionFolderName( fList, buffer ) ;\n\t\t\t\tif( strlen(buffer)>0 ) StringList_Add( FolderList, buffer ) ;\n\t\t\t\t}\n\t\t\tclosedir( dir ) ;\n\t\t\t}\n\t\t}\n\t\n\tif( readINI( KittyIniFile, \"Folder\", \"new\", buffer ) ) {\n\t\tif( strlen( buffer ) > 0 ) {\n\t\t\tfor( i=0; i<strlen(buffer); i++ ) if( buffer[i]==',' ) buffer[i]='\\0' ;\n\t\t\tStringList_Add( FolderList, buffer ) ;\n\t\t\t}\n\t\tdelINI( KittyIniFile, \"Folder\", \"new\" ) ;\n\t\t}\n\t\n\t}\n\nint GetSessionFolderNameInSubDir( const char * session, const char * subdir, char * folder ) {\n\tint return_code=0;\n\tchar buffer[2048], buf[2048] ;\n\tDIR * dir ;\n\tstruct dirent * de ;\n\tif( !strcmp(subdir,\"\") ) sprintf( buffer, \"%s\\\\Sessions\", ConfigDirectory ) ;\n\telse sprintf(buffer,\"%s\\\\Sessions\\\\%s\",ConfigDirectory, subdir ) ;\n\tif( (dir=opendir(buffer))!=NULL ) {\n\t\twhile( (de=readdir(dir)) != NULL ) \n\t\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") )\t{\n\t\t\t\tif( !strcmp(subdir,\"\") ) sprintf(buf,\"%s\\\\Sessions\\\\%s\",ConfigDirectory,de->d_name ) ;\n\t\t\t\telse sprintf(buf,\"%s\\\\Sessions\\\\%s\\\\%s\",ConfigDirectory, subdir,de->d_name ) ;\n\t\t\t\tif( existdirectory( buf ) ) {\n\t\t\t\t\tif( !strcmp(subdir,\"\") ) sprintf( buf, \"%s\", de->d_name ) ;\n\t\t\t\t\telse sprintf( buf, \"%s\\\\%s\", subdir, de->d_name ) ;\n\t\t\t\t\treturn_code = GetSessionFolderNameInSubDir( session, buf, folder ) ;\n\t\t\t\t\tif( return_code ) break ;\n\t\t\t\t} else if( !strcmp(session,de->d_name) ) {\n\t\t\t\t\tstrcpy( folder, subdir ) ;\n\t\t\t\t\treturn_code=1;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t}\t\t\t\n\t\tclosedir(dir) ;\n\t}\n\t\t\n\treturn return_code ;\n}\n\n// Recupere le nom du folder associe à une session\nvoid GetSessionFolderName( const char * session_in, char * folder ) {\n\tHKEY hKey ;\n\tchar buffer[1024], session[1024] ;\n\tFILE *fp ;\n\t\n\tstrcpy( folder, \"\" ) ;\n\tif( session_in == NULL ) return ;\n\tif( strlen(session_in)==0 ) return ;\n\t\n\tstrcpy( buffer, session_in ) ;\n\t//if( (p = strrchr(buffer, '[')) != NULL ) *(p-1) = '\\0' ;\n\n\tif( (IniFileFlag==SAVEMODE_REG)||(IniFileFlag==SAVEMODE_FILE) ) {\n\t\tmungestr(buffer, session) ;\n\t\tsprintf( buffer, \"%s\\\\Sessions\\\\%s\", PUTTY_REG_POS, session ) ;\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, buffer, 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\t\tDWORD lpType ;\n\t\t\tunsigned char lpData[1024] ;\n\t\t\tDWORD dwDataSize = 1024 ;\n\t\t\tif( RegQueryValueEx( hKey, \"Folder\", 0, &lpType, lpData, &dwDataSize ) == ERROR_SUCCESS ) {\n\t\t\t\tstrcpy( folder, (char*)lpData ) ;\n\t\t\t}\n\t\t\tRegCloseKey( hKey ) ;\n\t\t}\n\t} else if( IniFileFlag==SAVEMODE_DIR ) {\n\t\tmungestr(session_in, session ) ;\n\t\tif( DirectoryBrowseFlag ) {\n\t\t\tGetSessionFolderNameInSubDir( session, \"\", folder ) ;\n\t\t} else {\n\t\t\tsprintf(buffer,\"%s\\\\Sessions\\\\%s\", ConfigDirectory, session );\n\t\t\tif( (fp=fopen(buffer,\"r\"))!=NULL ) {\n\t\t\t\twhile( fgets(buffer,1024,fp)!=NULL ) {\n\t\t\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) \n\t\t\t\t\t\tbuffer[strlen(buffer)-1]='\\0' ;\n\t\t\t\t\tif( buffer[strlen(buffer)-1]=='\\\\' )\n\t\t\t\t\t\tif( strstr( buffer, \"Folder\" ) == buffer ) {\n\t\t\t\t\t\t\tif( buffer[6]=='\\\\' ) strcpy( folder, buffer+7 ) ;\n\t\t\t\t\t\t\tfolder[strlen(folder)-1] = '\\0' ;\n\t\t\t\t\t\t\tunmungestr(folder, buffer, MAX_PATH) ;\n\t\t\t\t\t\t\tstrcpy( folder, buffer) ;\n\t\t\t\t\t\t\tbreak  ;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Recupere une entree d'une session ( retourne 1 si existe )\nint GetSessionField( const char * session_in, const char * folder_in, const char * field, char * result ) {\n\tHKEY hKey ;\n\tchar buffer[1024], session[1024], folder[1024], *p ;\n\tint res = 0 ;\n\tFILE * fp ;\n\n\tif( session_in == NULL ) return 0 ;\n\tif( strlen(session_in)==0 ) return 0 ;\n\t\n\tstrcpy( result, \"\" ) ;\n\tstrcpy( buffer, session_in ) ;\n\tif( (p = strrchr(buffer, '[')) != NULL ) *(p-1) = '\\0' ;\n\tmungestr(buffer, session) ;\n\tsprintf( buffer, \"%s\\\\Sessions\\\\%s\", PUTTY_REG_POS, session ) ;\n\tstrcpy( folder, folder_in );\n\tCleanFolderName( folder );\n\n\tif( (IniFileFlag==SAVEMODE_REG)||(IniFileFlag==SAVEMODE_FILE) ) {\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, buffer, 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\t\tDWORD lpType ;\n\t\t\tunsigned char lpData[1024] ;\n\t\t\tDWORD dwDataSize = 1024 ;\n\t\t\tif( RegQueryValueEx( hKey, field, 0, &lpType, lpData, &dwDataSize ) == ERROR_SUCCESS ) {\n\t\t\t\tstrcpy( result, (char*)lpData ) ;\n\t\t\t\tres = 1 ;\n\t\t\t\t}\n\t\t\tRegCloseKey( hKey ) ;\n\t\t\t}\n\t\t}\n\telse if( IniFileFlag==SAVEMODE_DIR ) {\n\t\tif( DirectoryBrowseFlag ) {\n\t\t\tif( !strcmp(folder,\"Default\") || !strcmp(folder,\"\") ) sprintf(buffer,\"%s\\\\Sessions\\\\%s\", ConfigDirectory, session ) ;\n\t\t\telse sprintf(buffer,\"%s\\\\Sessions\\\\%s\\\\%s\", ConfigDirectory, folder, session ) ;\n\t\t\t}\n\t\telse {\n\t\t\tsprintf(buffer,\"%s\\\\Sessions\\\\%s\", ConfigDirectory, session ) ;\n\t\t\t}\n\n\t\tif( debug_flag ) { debug_logevent( \"GetSessionField(%s,%s,%s,%s)=%s\", ConfigDirectory, session, folder, field, buffer ) ; }\n\t\tif( (fp=fopen(buffer,\"r\"))!=NULL ) {\n\t\t\twhile( fgets(buffer,1024,fp)!=NULL ) {\n\t\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\t\t\tif( buffer[strlen(buffer)-1]=='\\\\' )\n\t\t\t\t\tif( (strstr( buffer, field )==buffer) && ((buffer+strlen(field))[0]=='\\\\') ) {\n\t\t\t\t\t\tif( buffer[strlen(field)]=='\\\\' ) strcpy( result, buffer+strlen(field)+1 ) ;\n\t\t\t\t\t\tresult[strlen(result)-1] = '\\0' ;\n\t\t\t\t\t\tunmungestr(result, buffer,MAX_PATH) ;\n\t\t\t\t\t\tstrcpy( result, buffer) ;\n\t\t\t\t\t\tif( debug_flag ) debug_logevent( \"Result=%s\", result );\n\t\t\t\t\t\tres = 1 ;\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tfclose(fp);\n\t\t\t}\n\t\t}\n\treturn res ;\n\t}\n\t\nvoid RenewPassword( Conf *conf ) {\n\treturn ;\n\tif( !GetUserPassSSHNoSave() )\n\tif( strlen( conf_get_str(conf,CONF_password) ) == 0 ) {\n\t\tchar buffer[1024] = \"\", host[1024], termtype[1024] ;\n\t\tif( GetSessionField( conf_get_str(conf,CONF_sessionname), conf_get_str(conf,CONF_folder), \"Password\", buffer ) ) {\n\t\t\tGetSessionField( conf_get_str(conf,CONF_sessionname), conf_get_str(conf,CONF_folder), \"HostName\", host );\n\t\t\tGetSessionField( conf_get_str(conf,CONF_sessionname), conf_get_str(conf,CONF_folder), \"TerminalType\", termtype );\n\t\t\tdecryptpassword( GetCryptSaltFlag(), buffer, host, termtype ) ;\n\t\t\tMASKPASS(GetCryptSaltFlag(),buffer);\n\t\t\tconf_set_str(conf,CONF_password,buffer) ;\n\t\t\tmemset(buffer,0,strlen(buffer) );\n\t\t\t}\n\t\t}\n\t}\n\nint DebugAddPassword( const char*fct, const char*pwd ) ;\nvoid SetPasswordInConfig( const char * password ) {\n\tint len ;\n\tchar bufpass[1024] ;\n\tif( (!GetUserPassSSHNoSave())&&(password!=NULL) ) {\n\t\tlen = strlen( password ) ;\n\t\tif( len > 126 ) len = 126 ;\n\t\tif( len>0 ) {\n\t\t\tmemcpy( bufpass, password, len+1 ) ;\n\t\t\tbufpass[len]='\\0' ;\n\t\t\twhile( ((bufpass[strlen(bufpass)-1]=='n')&&(bufpass[strlen(bufpass)-2]=='\\\\')) || ((bufpass[strlen(bufpass)-1]=='r')&&(bufpass[strlen(bufpass)-2]=='\\\\')) ) { \n\t\t\t\tbufpass[strlen(bufpass)-2]='\\0'; \n\t\t\t\tbufpass[strlen(bufpass)-1]='\\0'; \n\t\t\t}\n\t\t\twhile( (bufpass[strlen(bufpass)-1]=='\\n') || (bufpass[strlen(bufpass)-1]=='\\r') || (bufpass[strlen(bufpass)-1]=='\\t') || (bufpass[strlen(bufpass)-1]==' ') ) { bufpass[strlen(bufpass)-1]='\\0' ; }\n\t\t\tDebugAddPassword( \"SetPasswordInConfig(before mask)\", bufpass ) ;\n\t\t\tMASKPASS(GetCryptSaltFlag(),bufpass) ;\n\t\t\tDebugAddPassword( \"SetPasswordInConfig(after mask)\", bufpass ) ;\n\t\t} else {\n\t\t\tstrcpy( bufpass, \"\" ) ;\n\t\t}\n\t\tconf_set_str(conf,CONF_password,bufpass);\n\t\tmemset( bufpass, 0, strlen(bufpass) ) ;\n\t}\n}\n\nvoid SetUsernameInConfig( const char * username ) {\n\tint len ;\n\tif( (!GetUserPassSSHNoSave())&&(username!=NULL) ) {\n\t\tlen = strlen( username ) ;\n\t\tif( len > 126 ) { len = 126 ; }\n\t\tchar *b = (char*) malloc( len+1 ) ;\n\t\tmemcpy( (void*)b, (const void*)username, len+1 ) ;\n\t\tb[len] = '\\0' ;\n\t\tconf_set_str(conf,CONF_username,b);\n\t\tfree(b);\n\t\t}\n\t}\n\n// Sauvegarde la liste des folders\nvoid SaveFolderList( void ) {\n\tint i = 0 ;\n\tchar buffer[4096] = \"\" ;\n\twhile( FolderList[i] != NULL ) {\n\t\tif( strlen( FolderList[i] ) > 0 )\n\t\t\tstrcat( buffer, FolderList[i] ) ;\n\t\tif( FolderList[i+1] != NULL ) \n\t\t\tif( strlen( FolderList[i+1] ) > 0 )\n\t\t\t\tstrcat( buffer, \",\" ) ;\n\t\ti++;\n\t\t}\n\n\tif( strlen( buffer ) > 0 ) \n\t\tWriteParameter( INIT_SECTION, \"Folders\", buffer ) ;\n\t}\n\n// Sauvegarde une cle de registre dans un fichier\nvoid QueryKey( HKEY hMainKey, LPCTSTR lpSubKey, FILE * fp_out ) { \n\tHKEY hKey ;\n    TCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name\n    DWORD    cbName;                   // size of name string \n    TCHAR    achClass[MAX_PATH] = TEXT(\"\");  // buffer for class name \n    DWORD    cchClassName = MAX_PATH;  // size of class string \n    DWORD    cSubKeys=0;               // number of subkeys \n    DWORD    cbMaxSubKey;              // longest subkey size \n    DWORD    cchMaxClass;              // longest class string \n    DWORD    cValues;              // number of values for key \n    DWORD    cchMaxValue;          // longest value name \n    DWORD    cbMaxValueData;       // longest value data \n    DWORD    cbSecurityDescriptor; // size of security descriptor \n    FILETIME ftLastWriteTime;      // last write time \n \n    DWORD i,j, retCode; \n \n    TCHAR  achValue[MAX_VALUE_NAME]; \n    DWORD cchValue = MAX_VALUE_NAME; \n\t\n    char str[4096], b[2] =\" \" ;\n\t\n\tDWORD lpType, dwDataSize = 1024 ;\n\tchar * buffer = NULL ;\n\t\n\t// On ouvre la cle\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n \n    // Get the class name and the value count. \n    retCode = RegQueryInfoKey(\n        hKey,                    // key handle \n        achClass,                // buffer for class name \n        &cchClassName,           // size of class string \n        NULL,                    // reserved \n        &cSubKeys,               // number of subkeys \n        &cbMaxSubKey,            // longest subkey size \n        &cchMaxClass,            // longest class string \n        &cValues,                // number of values for this key \n        &cchMaxValue,            // longest value name \n        &cbMaxValueData,         // longest value data \n        &cbSecurityDescriptor,   // security descriptor \n        &ftLastWriteTime);       // last write time \n \n\t//fprintf( fp_out, \"\\r\\n[HKEY_CURRENT_USER\\\\%s]\\r\\n\" TEXT(lpSubKey) ) ;\n\tsprintf( str, \"[HKEY_CURRENT_USER\\\\%s]\", TEXT(lpSubKey) ) ;\n\tif( strlen( PasswordConf ) > 0 ) { cryptstring( GetCryptSaltFlag(), str, PasswordConf ) ; }\n\tfprintf( fp_out, \"\\r\\n%s\\r\\n\", str ) ;\n\n    // Enumerate the key values. \n    if (cValues) \n    {\n        //printf( \"\\nNumber of values: %d\\n\", cValues);\n\n        for (i=0, retCode=ERROR_SUCCESS; i<cValues; i++) \n        { \n            cchValue = MAX_VALUE_NAME; \n            achValue[0] = '\\0'; \n            retCode = RegEnumValue(hKey, i, \n                achValue, \n                &cchValue, \n                NULL, \n                NULL,\n                NULL,\n                NULL);\n \n            if (retCode == ERROR_SUCCESS ) \n            { \n                //fprintf( fp_out, \"\\\"%s\\\"=\",  achValue ) ;\n\t\t\t\tunsigned char lpData[1024] ;\n\t\t\t\tdwDataSize = 1024 ;\n\t\t\t\tRegQueryValueEx( hKey, TEXT( achValue ), 0, &lpType, lpData, &dwDataSize ) ;\n\t\t\t\tswitch ((int)lpType){\n\t\t\t\t\tcase REG_BINARY:\n\t\t\t\t\t\t\t// A FAIRE\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\tcase REG_DWORD:\n\t\t\t\t\t\t//sprintf( str, \"\\\"%s\\\"=dword:%08x\", achValue, (unsigned int)*lpData ) ;\n\t\t\t\t\t\tsprintf( str, \"\\\"%s\\\"=dword:%08x\", achValue, (unsigned int) *((DWORD*)lpData) ) ; // Ca ca marchait bien mais avec une erreur de compilation\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase REG_EXPAND_SZ:\n\t\t\t\t\tcase REG_MULTI_SZ:\n\t\t\t\t\tcase REG_SZ:\n\t\t\t\t\t\t//fprintf( fp_out, \"\\\"\" ) ;\n\t\t\t\t\t\tsprintf( str, \"\\\"%s\\\"=\\\"\", achValue ) ;\n\t\t\t\t\t\tfor( j=0; j<strlen((char*)lpData) ; j++ ) {\n\t\t\t\t\t\t\t//fprintf( fp_out, \"%c\", lpData[j] ) ;\n\t\t\t\t\t\t\tb[0]=lpData[j] ;\n\t\t\t\t\t\t\tstrcat( str, b ) ;\n\t\t\t\t\t\t\t//if( lpData[j]=='\\\\' ) fprintf( fp_out, \"\\\\\" ) ;\n\t\t\t\t\t\t\tif( lpData[j]=='\\\\' ) strcat( str,\"\\\\\" ) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t//fprintf( fp_out, \"\\\"\" ) ;\n\t\t\t\t\t\tstrcat( str, \"\\\"\" ) ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t//fprintf( fp_out, \"\\r\\n\");\n\t\t\t\tif( strlen( PasswordConf ) > 0 ) { cryptstring( GetCryptSaltFlag(), str, PasswordConf ) ; }\n\t\t\t\tfprintf( fp_out, \"%s\\r\\n\", str ) ;\n            } \n        }\n    }\n\t\n    // Enumerate the subkeys, until RegEnumKeyEx fails.\n    if (cSubKeys)\n    {\n        //printf( \"\\nNumber of subkeys: %d\\n\", cSubKeys);\n\n        for (i=0; i<cSubKeys; i++) \n        { \n            cbName = MAX_KEY_LENGTH;\n            retCode = RegEnumKeyEx(hKey, i,\n                     achKey, \n                     &cbName, \n                     NULL, \n                     NULL, \n                     NULL, \n                     &ftLastWriteTime); \n            if (retCode == ERROR_SUCCESS) \n            {\n\t\t\t\tbuffer = (char*) malloc( strlen( TEXT(lpSubKey) ) + strlen( achKey ) + 3 ) ;\n                sprintf( buffer, \"%s\\\\%s\", TEXT(lpSubKey), achKey ) ;\n\t\t\t\tQueryKey( hMainKey, buffer, fp_out ) ;\n\t\t\t\tfree( buffer );\t\t\t\t\n            }\n        }\n    } \n \n\tRegCloseKey( hKey ) ;\n}\n\n// Renomme une Cle de registre\nvoid RegRenameTree( HWND hdlg, HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR lpDestKey ) { // hdlg boite d'information\n\tif( RegTestKey( hMainKey, lpDestKey ) ) {\n\t\tif( hdlg != NULL ) InfoBoxSetText( hdlg, \"Cleaning backup registry\" ) ;\n\t\tRegDelTree( hMainKey, lpDestKey ) ;\n\t\t}\n\tif( hdlg != NULL ) InfoBoxSetText( hdlg, \"Saving registry\" ) ;\n\tRegCopyTree( hMainKey, lpSubKey, lpDestKey ) ;\n\tif( hdlg != NULL ) InfoBoxSetText( hdlg, \"Preparing local registry\" ) ;\n\tRegDelTree( hMainKey, lpSubKey ) ;\n\t}\n\n// Permet de recuperer les sessions KiTTY dans PuTTY  (PUTTY_REG_POS)\nvoid RepliqueToPuTTY( LPCTSTR Key ) { \n\tchar buffer[1024] ;\n#ifdef FLJ\nreturn ;\n#endif\n\tif( IniFileFlag == SAVEMODE_REG )\n\tif( readINI( KittyIniFile, \"PuTTY\", \"keys\", buffer ) ) {\n\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r')||(buffer[strlen(buffer)-1]==' ')||(buffer[strlen(buffer)-1]=='\\t') ) buffer[strlen(buffer)-1]='\\0';\n\t\tif( !stricmp( buffer, \"load\" ) ) {\n\t\t\tsprintf( buffer, \"%s\\\\Sessions\", Key ) ;\n\t\t\tRegDelTree (HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\" ) ;\n\t\t\tRegCopyTree( HKEY_CURRENT_USER, buffer, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\" ) ;\n\t\t\tsprintf( buffer, \"%s\\\\SshHostKeys\", Key ) ;\n\t\t\tRegCopyTree( HKEY_CURRENT_USER, buffer, \"Software\\\\SimonTatham\\\\PuTTY\\\\SshHostKeys\" ) ;\n\t\t\t}\n\t\t//delINI( KittyIniFile, \"PuTTY\", \"keys\" ) ;\n\t\tRegCleanPuTTY() ;\n\t\t}\n\t}\n\nint license_make_with_first( char * license, int length, int modulo, int result ) ;\nvoid license_form( char * license, char sep, int size ) ;\nint license_test( char * license, char sep, int modulo, int result ) ;\n\n// Augmente le compteur d'utilisation dans la base de registre\nvoid CountUp( void ) {\n\tchar buffer[4096] = \"0\", *pst ;\n\tlong int n ;\n\tint len = 1024 ;\n\t\n\tif( ReadParameter( INIT_SECTION, \"KiCount\", buffer ) == 0 ) { strcpy( buffer, \"0\" ) ; }\n\tn = atol( buffer ) + 1 ;\n\tsprintf( buffer, \"%ld\", n ) ;\n\tWriteParameter( INIT_SECTION, \"KiCount\", buffer) ;\n\t\n\tif( ReadParameter( INIT_SECTION, \"KiLastUp\", buffer ) == 0 ) { sprintf( buffer, \"%ld/\", time(0) ) ; }\n\tbuffer[2048]='\\0';\n\tif( (pst=strstr(buffer,\"/\"))==NULL ) { strcat(buffer,\"/\") ; pst=buffer+strlen(buffer)-1 ; }\n\tsprintf( pst+1, \"%ld\", time(0) ) ;\n\tWriteParameter( INIT_SECTION, \"KiLastUp\", buffer) ;\n\t\n\tif( GetUserName( buffer, (void*)&len ) ) { \n\t\tstrcat( buffer, \"@\" ) ;\n\t\tlen = 1024 ;\n\t\tif( GetComputerName( buffer+strlen(buffer), (void*)&len ) ) {\n\t\t\tcryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ;\n\t\t\tWriteParameter( INIT_SECTION, \"KiLastUH\", buffer) ;\n\t\t\t}\n\t\t}\n\t\t\n\tif( IniFileFlag != SAVEMODE_DIR ) {\n\t\tsprintf( buffer, \"%s\\\\Sessions\", PUTTY_REG_POS ) ;\n\t\tn = (long int) RegCountKey( HKEY_CURRENT_USER, buffer ) ;\n\t\tsprintf( buffer, \"%ld\", n ) ;\n\t\tWriteParameter( INIT_SECTION, \"KiSess\", buffer) ;\n\t} else {\n\t\tsprintf( buffer, \"0 (Not in registry mode)\" ) ;\n\t\tWriteParameter( INIT_SECTION, \";KiSess\", buffer) ;\n\t}\n\t\t\t\n\tGetOSInfo( buffer ) ;\n\tcryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ;\n\tWriteParameter( INIT_SECTION, \"KiVers\", buffer) ;\n\t\t\n\tif( GetModuleFileName( NULL, (LPTSTR)buffer, 1024 ) ) \n\t\tif( strlen( buffer ) > 0 ) \n\t\t\t{ WriteParameter( INIT_SECTION, \"KiPath\", buffer) ; }\n\t\t\t\n\tif( ReadParameter( INIT_SECTION, \"KiLic\", buffer ) == 0 ) { \n\t\tstrcpy( buffer, \"KI67\" ) ;\n\t\tlicense_make_with_first( buffer, 25, 97, 0 )  ;\n\t\tlicense_form( buffer, '-', 5 ) ;\n\t\tWriteParameter( INIT_SECTION, \"KiLic\", buffer) ; \n\t\t}\n\telse if( !license_test( buffer, '-', 97, 0 ) ) {\n\t\tstrcpy( buffer, \"KI67\" ) ;\n\t\tlicense_make_with_first( buffer, 25, 97, 0 )  ;\n\t\tlicense_form( buffer, '-', 5 ) ;\n\t\tWriteParameter( INIT_SECTION, \"KiLic\", buffer) ; \n\t\t}\n\t}\n\n#include \"../../kitty_help.h\"\nchar * GetHelpMessage(void) {\n\treturn default_help_file_content ;\n}\n\n// Si le fichier kitty.ini n'existe pas => creation du fichier par defaut\n#include \"kitty_ini.h\"\nvoid CreateIniFile( const char * filename ) {\n\tFILE *fp;\n\tif( (fp=fopen(filename,\"w\")) != NULL ) {\n\t\tif( IniFileFlag == SAVEMODE_DIR ) {\n\t\t\tint p = poss( \";savemode=registry\", default_init_file_content );\n\t\t\tdel( default_init_file_content, p, 18 );\n\t\t\tinsert( default_init_file_content, \"savemode=dir\", p );\n\t\t}\n\t\tfputs(default_init_file_content,fp);\n\t\tfclose(fp);\n\t}\n}\nvoid CreateDefaultIniFile( void ) {\n\tif( !NoKittyFileFlag ) if( !GetReadOnlyFlag() ) {\n\t\tif( KittyIniFile==NULL ) return ;\n\t\tif( strlen(KittyIniFile)==0 ) return ;\n\t\tif( !existfile( KittyIniFile ) ) {\n\t\t\tCreateIniFile( KittyIniFile ) ;\n\t\t}\n\t\tif( !existfile( KittyIniFile ) ) { MessageBox( NULL, \"Unable to create configuration file !\", \"Error\", MB_OK|MB_ICONERROR ) ; }\n\t}\n}\n\nvoid CreateDefaultIniFile_old( void ) {\n\tchar buffer[4096] ;\n\tif( !NoKittyFileFlag ) if( !GetReadOnlyFlag() ) {\n\t\tif( KittyIniFile==NULL ) return ;\n\t\tif( strlen(KittyIniFile)==0 ) return ;\n\t\tif( !existfile( KittyIniFile ) ) {\n\t\t\n\t\t\twriteINI( KittyIniFile, \"Agent\", \"#messageonkeyusage\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Agent\", \"#askconfirmation\", \"auto\" ) ;\n\t\t\t\n\t\t\twriteINI( KittyIniFile, \"ConfigBox\", \"#default\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, \"ConfigBox\", \"#defaultsettings\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, \"ConfigBox\", \"filter\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, \"ConfigBox\", \"height\", \"21\" ) ;\n\t\t\twriteINI( KittyIniFile, \"ConfigBox\", \"#noexit\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, \"ConfigBox\", \"#windowheight\", \"600\" ) ;\n\n#ifdef MOD_ADB\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#adb\", \"yes\" ) ;\n#endif\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#antiidle=\", \" \\\\k08\\\\\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#antiidledelay\", \"60\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#autostoresshkey\", \"no\" ) ;\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"bgimage\", \"no\" ) ;\n#endif\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#bcdelay\", \"0\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"capslock\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"conf\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#configdir\", \"\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#CtHelperPath\", \"\" ) ;\n//\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"debug\", \"#no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#downloaddir\", \"\" ) ;\n#ifdef MOD_HYPERLINK\n#ifdef FLJ\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"hyperlink\", \"yes\" ) ;\n#else\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"hyperlink\", \"no\" ) ;\n#endif\n#endif\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"icon\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#iconfile\", DEFAULT_EXE_FILE ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"mouseshortcuts\", \"yes\" ) ;\n\t\t\tsprintf( buffer, \"%d\", NB_ICONES ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#numberoficons\", buffer ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"paste\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#PlinkPath\", \"\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#PSCPPath\", \"\" ) ;\n#ifdef MOD_PORTABLE\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"savemode\", \"dir\" ) ;\n#else\n\t\t\tsprintf( buffer, \"%s\\\\%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION, DEFAULT_SAV_FILE );\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"sav\", buffer ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"savemode\", \"registry\" ) ;\n#endif\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#scriptfilefilter\", \"All files (*.*)|*.*\" ) ;\n#ifdef FLJ\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"shortcuts\", \"no\" ) ;\n#else\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"shortcuts\", \"yes\" ) ;\n#endif\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"size\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#sshversion\", \"OpenSSH_5.5\" ) ;\n#ifndef MOD_NOTRANSPARENCY\n#ifdef FLJ\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"transparency\", \"yes\" ) ;\n#else\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"transparency\", \"no\" ) ;\n#endif\n#endif\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#uploaddir\", \".\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#userpasssshnosave\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#WinSCPPath\", \"\" ) ;\n#ifdef MOD_ZMODEM\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"zmodem\", \"yes\" ) ;\n#endif\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#ctrltab\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#KiClassName\", \"PuTTY\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"maxblinkingtime\", \"5\" ) ;\n#ifdef MOD_RECONNECT\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#autoreconnect\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#ReconnectDelay\", \"5\" ) ;\n#endif\n#ifdef MOD_RUTTY\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#scriptmode\", \"yes\" ) ;\n#endif\n\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#commanddelay\", \"0.05\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#initdelay\", \"2.0\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#internaldelay\", \"10\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"#readonly\", \"no\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"slidedelay\", \"0\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"winroll\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, INIT_SECTION, \"wintitle\", \"yes\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Print\", \"height\", \"100\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Print\", \"maxline\", \"60\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Print\", \"maxchar\", \"85\" ) ;\n\n\t\t\twriteINI( KittyIniFile, \"Folder\", \"\", \"\" ) ;\n\t\n\t\t\twriteINI( KittyIniFile, \"Launcher\", \"reload\", \"yes\" ) ;\n\t\t\t\n\t\t\t\n\t\t\twriteINI( KittyIniFile, \"Shortcuts\", \"#switchlogmode\", \"{SHIFT}{F5}\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Shortcuts\", \"#showportforward\", \"{SHIFT}{F6}\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Shortcuts\", \"print\", \"{SHIFT}{F7}\" ) ;\n\t\t\twriteINI( KittyIniFile, \"Shortcuts\", \"printall\", \"{F7}\" ) ;\n\t\t\t}\n\t\tif( !existfile( KittyIniFile ) ) { MessageBox( NULL, \"Unable to create configuration file !\", \"Error\", MB_OK|MB_ICONERROR ) ; }\n\t\t}\n\t}\n\n// Ecrit un parametre soit en registre soit dans le fichier de configuration\nint WriteParameter( const char * key, const char * name, char * value ) {\n\tint ret = 1 ;\n\tchar buffer[4096] ;\n\tif( IniFileFlag == SAVEMODE_DIR ) { \n\t\tif( !GetReadOnlyFlag() ) {\n\t\t\tret = writeINI( KittyIniFile, key, name, value ) ; \n\t\t}\n\t} else { \n\t\tsprintf( buffer, \"%s\\\\%s\", TEXT(PUTTY_REG_PARENT), key ) ;\n\t\tRegTestOrCreate( HKEY_CURRENT_USER, buffer, name, value ) ; \n\t}\n\treturn ret ;\n}\n\n// Lit un parametre soit dans le fichier de configuration, soit dans le registre\nint ReadParameter( const char * key, const char * name, char * value ) {\n\tchar buffer[4096] ;\n\tstrcpy( buffer, \"\" ) ;\n\tif( GetValueData( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), name, buffer ) == NULL ) {\n\t\tif( !readINI( KittyIniFile, key, name, buffer ) ) {\n\t\t\tstrcpy( buffer, \"\" ) ;\n\t\t\t}\n\t\t}\n\tbuffer[4095] = '\\0' ;\n\tstrcpy( value, buffer ) ;\n\treturn strcmp( buffer, \"\" ) ;\n\t}\n\t\n// Supprime un parametre\nint DelParameter( const char * key, const char * name ) {\n\tchar buffer[4096] ;\n\tif( !GetReadOnlyFlag() ) { delINI( KittyIniFile, key, name ) ; }\n\tsprintf( buffer, \"%s\\\\%s\", TEXT(PUTTY_REG_PARENT), key ) ;\n\tRegDelValue( HKEY_CURRENT_USER, buffer, (char*)name ) ;\n\treturn 1 ;\n\t}\n\t\n// Test la configuration (mode file ou registry) et charge le fichier kitty.sav si besoin\nvoid GetSaveMode( void ) {\n\tchar buffer[256] ;\n\tif( readINI( KittyIniFile, INIT_SECTION, \"savemode\", buffer ) ) {\n\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r')||(buffer[strlen(buffer)-1]==' ')||(buffer[strlen(buffer)-1]=='\\t') ) buffer[strlen(buffer)-1]='\\0';\n\t\tif( !stricmp( buffer, \"registry\" ) ) IniFileFlag = SAVEMODE_REG ;\n\t\telse if( !stricmp( buffer, \"file\" ) ) IniFileFlag = SAVEMODE_FILE ;\n\t\telse if( !stricmp( buffer, \"dir\" ) ) { IniFileFlag = SAVEMODE_DIR ; DirectoryBrowseFlag = 1 ; }\n\t}\n\tif( IniFileFlag!=SAVEMODE_DIR ) DirectoryBrowseFlag = 0 ;\n}\n\n// Sauvegarde de la cle de registre\nvoid SaveRegistryKeyEx( HKEY hMainKey, LPCTSTR lpSubKey, const char * filename ) {\n\tFILE * fp_out ;\n\t//FILE * fp_out1 ;\n\tchar buffer[4096] ;\n\n\tif( ( fp_out=fopen( filename, \"wb\" ) ) == NULL ) return ;\n\tif( _locking( fileno(fp_out) , LK_LOCK, 10000000L ) == -1 ) { fclose(fp_out); return ; }\n\t\n\tstrcpy( buffer, \"Windows Registry Editor Version 5.00\" ) ;\n\n\tif( strlen( PasswordConf ) > 0 ) cryptstring( GetCryptSaltFlag(), buffer, PasswordConf ) ;\n\tfprintf( fp_out, \"%s\\r\\n\", buffer ); \n\n\tQueryKey( hMainKey, lpSubKey, fp_out ) ;\n\t\n\t_locking( fileno(fp_out) , LK_UNLCK, 10000000L );\n\tfclose( fp_out ) ;\n\t}\n\nvoid SaveRegistryKey( void ) {\n\tif( IniFileFlag == SAVEMODE_DIR ) return ;\n\tif( NoKittyFileFlag || (KittySavFile==NULL) ) return ;\n\tif( strlen(KittySavFile)==0 ) return ;\n\n\tif( GetValueData( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), \"password\", PasswordConf ) == NULL ) \n\t\t{ strcpy( PasswordConf, \"\" ) ; }\n\n\tif( strlen( PasswordConf ) > 0 ) \n\t\t{ WriteParameter( INIT_SECTION, \"password\", PasswordConf ) ; }\n\n\tSaveRegistryKeyEx( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), KittySavFile ) ;\n\t}\n\nvoid routine_SaveRegistryKey( void * st ) { SaveRegistryKey() ; }\n\n// Charge la cle de registre\nvoid LoadRegistryKey( HWND hdlg ) { // hdlg est la boite de dialogue d'information de l'avancement (si null pas d'info)\n\tFILE *fp ;\n\tHKEY hKey = NULL ;\n\tchar buffer[4096], KeyName[1024] = \"\", ValueName[1024], *Value ;\n\tint nb=0 ;\n\t\n\tif( KittySavFile==NULL ) return ;\n\tif( strlen(KittySavFile)==0 ) return ;\n\t\n\tif( ( fp = fopen( KittySavFile,\"rb\" ) ) == NULL ) return ;\n\twhile( fgets( buffer, 4096, fp ) != NULL ) {\n\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r')||(buffer[strlen(buffer)-1]==' ')||(buffer[strlen(buffer)-1]=='\\t') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\t\n\t\t// Test si on a un fichier crypte\n\t\tif( nb == 0 ) {\n\t\t\tif( strcmp( buffer, \"Windows Registry Editor Version 5.00\" ) ) {\n\t\t\t\tGetAndSendLinePassword( NULL ) ;\n\t\t\t\tif( InputBoxResult == NULL ) exit(0) ;\n\t\t\t\tif( strlen( InputBoxResult ) == 0 ) exit(0) ;\n\t\t\t\tstrcpy( PasswordConf, InputBoxResult ) ;\n\t\t\t\tdecryptstring( GetCryptSaltFlag(), buffer, PasswordConf ) ;\n\t\t\t\tif( strcmp( buffer, \"Windows Registry Editor Version 5.00\" ) ) {\n\t\t\t\t\tMessageBox( NULL, \"Wrong password\", \"Error\", MB_OK|MB_ICONERROR ) ;\n\t\t\t\t\texit(1) ;\n\t\t\t\t\t}\n\t\t\t\tif( strlen(PasswordConf) > 0 )\n\t\t\t\t\tWriteParameter( INIT_SECTION, \"password\", PasswordConf ) ;\n\t\t\t\t}\n\t\t\t}\n\t\tnb++ ;\n\t\tif( strlen( PasswordConf ) > 0 ) {\n\t\t\tdecryptstring( GetCryptSaltFlag(), buffer, PasswordConf ) ;\n\t\t\t}\n\t\t\t\n\t\tif( strlen( buffer ) == 0 ) ;\n\t\tif( (buffer[0]=='[') && (buffer[strlen(buffer)-1]==']') ) {\n\t\t\tstrcpy( KeyName, buffer+19 ) ; // +19 pour supprimer [HKEY_CURRENT_USER\n\t\t\tKeyName[strlen(KeyName)-1] = '\\0' ;\n\t\t\tif( hKey != NULL ) { RegCloseKey( hKey ) ; hKey = NULL ; }\n\t\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(KeyName), 0, KEY_WRITE, &hKey) != ERROR_SUCCESS ) \n\t\t\t\t{\n\t\t\t\t\tif( hdlg != NULL ) {\n\t\t\t\t\t\tsprintf( buffer, \"Loading %s\", KeyName ) ;\n\t\t\t\t\t\tInfoBoxSetText( hdlg, buffer ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\tRegCreateKey( HKEY_CURRENT_USER, TEXT(KeyName), &hKey ) ; \n\t\t\t\t\t}\n\t\t\t}\n\t\telse {\n\t\t\tif( ( Value = strstr( buffer, \"=\" ) ) != NULL ) {\n\t\t\t\tstrcpy( ValueName, buffer+1 ) ;\n\t\t\t\tValueName[ (int)(Value-buffer-2) ] = '\\0' ;\n\t\t\t\tValue++;\n\t\t\tif( Value[0] == '\\\"' ) { // REG_SZ\n\t\t\t  \tValue++;\n\t\t\t  \tValue[strlen(Value)-1] = '\\0' ;\n\t\t\t\tDelDoubleBackSlash( Value ) ;\n\t\t\t  \tRegSetValueEx( hKey, TEXT( ValueName ), 0, REG_SZ, (LPBYTE)Value, strlen(Value)+1 ) ;\n\t\t\t  \t}\n\t\t\telse if( strstr(Value,\"dword:\") == Value ) { //REG_DWORD\n\t\t\t\tint dwData = 0 ;\t\t\t  \t\n\t\t\t\tValue = Value + 6 ;\n\t\t\t\tsscanf( Value, \"%08x\", (int*)&dwData ) ;\n\t\t\t\tRegSetValueEx( hKey, TEXT( ValueName ), 0, REG_DWORD, (LPBYTE)&dwData, sizeof(DWORD) ) ;\n\t\t\t\t}\n\t\t\telse { // erreur\n\t\t\t\tMessageBox( NULL, \"Unknown value type\", \"Error\", MB_OK|MB_ICONERROR ); \n\t\t\t\texit( 1 ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t}\n\tif( hKey != NULL ) { RegCloseKey( hKey ) ; hKey = NULL ; }\n\tfclose( fp ) ;\n\t}\n\nvoid DelRegistryKey( void ) {\n\tRegDelTree( HKEY_CURRENT_USER, TEXT(PUTTY_REG_PARENT) ) ;\n\t}\n\n//extern const int Default_Port ;\n//void server_run_routine( const int port, const int timeout ) ;\n\n//extern int PORT ; int main_m1( void ) ;\n//void routine_server( void * st ) { main_m1() ; }\n\ntypedef void (CALLBACK* LPFNDLLFUNC1)( void ) ;\nvoid routine_server( void * st ) {\n\tHMODULE lphDLL ;               // Handle to DLL\n\tLPFNDLLFUNC1 lpfnDllFunc1 ;    // Function pointer\n\t\n\tchar buffer[MAX_PATH] ; sprintf( buffer, \"%s\\\\kchat.dll\", InitialDirectory ) ;\n\tlphDLL = LoadLibrary( TEXT( buffer ) ) ;\n\t//lphDLL = LoadLibrary( TEXT(\"kchat.dll\") ) ;\n\tif( lphDLL == NULL ) {\n\t\tMessageBox( MainHwnd, \"Unable to load library kchat.dll\", \"Error\", MB_OK|MB_ICONERROR ) ;\n\t\treturn ;\n\t\t}\n\tif( !( lpfnDllFunc1 = (LPFNDLLFUNC1) GetProcAddress( lphDLL, TEXT(\"main_m1\") ) ) ) {\n\t\tMessageBox( NULL, \"Unable to load main chat function from library kchat.dll\", \"Error\", MB_OK|MB_ICONERROR  );\n\t\tFreeLibrary( lphDLL ) ;\n\t\treturn ;\n\t\t}\n\t(lpfnDllFunc1) () ;\n\tFreeLibrary( lphDLL ) ;\n\treturn ;\n}\n\nvoid SendStrToTerminal( const char * str, const int len ) ;\n\nvoid SendKeyboard( HWND hwnd, const char * buffer ) {\n\tint i ; \n\tif( strlen( buffer) > 0 ) {\n\t\tfor( i=0; i< strlen( buffer ) ; i++ ) {\n\t\t\tif( buffer[i] == '\\n' ) {\n\t\t\t\tSendMessage(hwnd, WM_KEYDOWN, VK_RETURN, 0) ;\n\t\t\t\t}\n\t\t\telse if( buffer[i] == '\\r' ) {\n\t\t\t\t}\n\t\t\telse \n\t\t\t\t//lpage_send(ldisc, CP_ACP, buffer+i, 1, 1);\n\t\t\t\tSendMessage(hwnd, WM_CHAR, buffer[i], 0) ;\n\t\t\tif( between_char_delay > 0 ) Sleep( between_char_delay ) ;\n\t\t\t}\n\t\t}\n\t}\n\n/*\nSetForegroundWindow(hwnd);\nkeybd_event(VK_CONTROL, 0x1D, 0, 0);\nkeybd_event(0x58, 0x47, 0, 0);\nkeybd_event(0x58, 0x47, KEYEVENTF_KEYUP, 0);\nkeybd_event(VK_CONTROL, 0x1D, KEYEVENTF_KEYUP, 0);\n*/\n\t\nstatic int keyb_control_flag = 0 ;\nstatic int keyb_shift_flag = 0 ;\nstatic int keyb_win_flag = 0 ;\nstatic int keyb_alt_flag = 0 ;\nstatic int keyb_altgr_flag = 0 ;\n\t\nvoid SendKeyboardPlus( HWND hwnd, const char * st ) {\n\tif( strlen(st) <= 0 ) return ;\n\tint i=0, j=0;\n\t//int internal_delay = 10 ;\n\tchar *buffer = NULL, stb[6] ;\n\tif( ( buffer = (char*) malloc( 2*strlen( st ) ) ) != NULL ) {\n\t\tbuffer[0] = '\\0' ;\n\t\tdo {\n\t\tif( st[i] == '\\\\' ) {\n\t\t\tif( st[i+1] == '\\\\' ) { buffer[j] = '\\\\' ; i++ ; j++ ;\n\t\t\t} else if( (st[i+1] == '/') && (i==0) ) { buffer[j] = '/' ; i++ ; j++ ; \n\t\t\t} else if( st[i+1] == 't' ) { buffer[j] = '\\t' ; i++ ; j++ ; \n\t\t\t} else if( st[i+1] == 'r' ) { buffer[j] = '\\r' ; i++ ; j++ ; \n\t\t\t} else if( st[i+1] == 'h' ) { buffer[j] = 8 ; i++ ; j++ ; \n\t\t\t} else if( st[i+1] == 'n' ) {\n\t\t\t\tSendKeyboard( hwnd, buffer ) ; SendKeyboard( hwnd, \"\\n\" ) ;\n\t\t\t\tSleep( internal_delay ) ;\n\t\t\t\tbuffer[0] = '\\0' ; j = 0 ;\n\t\t\t\ti++ ;\n\t\t\t} else if( st[i+1] == 'p' ) { \t\t\t// \\p pause une seconde\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\tSleep(1000);\n\t\t\t\tbuffer[0] = '\\0' ; j = 0 ;\n\t\t\t\ti++ ; \n\t\t\t} else if( st[i+1] == 's' ) { \t\t\t// \\s03 pause 3 secondes\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\tj = 1 ;\n\t\t\t\tif( (st[i+2]>='0')&&(st[i+2]<='9')&&(st[i+3]>='0')&&(st[i+3]<='9') ) {\n\t\t\t\t\tstb[0]=st[i+2];stb[1]=st[i+3];stb[2]='\\0' ;\n\t\t\t\t\tj=atoi(stb) ;\n\t\t\t\t\ti++ ; i++ ;\n\t\t\t\t}\n\t\t\t\tSleep(j*1000);\n\t\t\t\tbuffer[0] = '\\0' ; j = 0 ;\n\t\t\t\ti++ ; \n\t\t\t} else if( st[i+1] == 'c' ) { \n\t\t\t\tkeybd_event(VK_CONTROL, 0x1D, 0, 0) ;\n\t\t\t\tkeybd_event(VK_CANCEL, 0x1D, 0, 0) ;\n\t\t\t\tkeybd_event(VK_CANCEL, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\tkeybd_event(VK_CONTROL, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\tbuffer[0] = '\\0' ; j = 0 ;\n\t\t\t\ti++ ; \n\t\t\t} else if( st[i+1] == 'k' ) {\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\tsprintf( stb, \"0x%c%c\", st[i+2],st[i+3] ) ;\n\t\t\t\tsscanf( stb, \"%x\", &j ) ;\n\t\t\t\t//SendMessage(hwnd, WM_KEYDOWN, j, 0) ;\n\t\t\t\tif( j==VK_CONTROL ) keyb_control_flag = abs( keyb_control_flag - 1 ) ;\n\t\t\t\telse if( j==VK_SHIFT ) keyb_shift_flag = abs( keyb_shift_flag - 1 ) ;\n\t\t\t\telse if( (j==VK_MENU)||(j==VK_LMENU) ) keyb_alt_flag = abs( keyb_alt_flag - 1 ) ;\n\t\t\t\telse if( j==VK_RMENU ) keyb_altgr_flag = abs( keyb_altgr_flag - 1 ) ;\n\t\t\t\telse if( (j==VK_RWIN)||(j==VK_LWIN) ) keyb_win_flag = abs( keyb_win_flag - 1 ) ;\n\t\t\t\telse {\n\t\t\t\t\tif( keyb_control_flag || keyb_shift_flag || keyb_win_flag || keyb_alt_flag || keyb_altgr_flag ) {\n\t\t\t\t\t\tSetForegroundWindow(hwnd) ; Sleep( internal_delay ) ;\n\t\t\t\t\t\tif( keyb_control_flag )\tkeybd_event(VK_CONTROL, 0x1D, 0, 0) ;\n\t\t\t\t\t\tif( keyb_shift_flag )\tkeybd_event(VK_SHIFT , 0x1D, 0, 0) ;\n\t\t\t\t\t\tif( keyb_alt_flag )\tkeybd_event(VK_LMENU , 0x1D, 0, 0) ;\n\t\t\t\t\t\tif( keyb_altgr_flag )\tkeybd_event(VK_RMENU , 0x1D, 0, 0) ;\n\t\t\t\t\t\tif( keyb_win_flag )\tkeybd_event(VK_LWIN , 0x1D, 0, 0) ;\n\t\t\t\t\t\tkeybd_event( j, 0x47, 0, 0); \n\t\t\t\t\t\tkeybd_event( j, 0x47, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t\tif( keyb_win_flag )\tkeybd_event(VK_LWIN, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t\tif( keyb_altgr_flag )\tkeybd_event(VK_RMENU, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t\tif( keyb_alt_flag )\tkeybd_event(VK_LMENU, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t\tif( keyb_shift_flag )\tkeybd_event(VK_SHIFT, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t\tif( keyb_control_flag )\tkeybd_event(VK_CONTROL, 0x1D, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t} else if( j==VK_ESCAPE ) {\n\t\t\t\t\t\tkeybd_event( VK_ESCAPE, 1, 0, 0); \n\t\t\t\t\t\tkeybd_event( VK_ESCAPE, 1, KEYEVENTF_KEYUP, 0) ;\n\t\t\t\t\t} else if( (j==VK_END) || (j==VK_HOME) ) {\n\t\t\t\t\t\tkeybd_event( j ,0, KEYEVENTF_EXTENDEDKEY, 0 ) ;\n\t\t\t\t\t\tkeybd_event( j, 0, KEYEVENTF_EXTENDEDKEY|KEYEVENTF_KEYUP, 0 ) ; \n\t\t\t\t\t} else {\n\t\t\t\t\t\tsprintf( stb, \"%c\", j ) ;\n\t\t\t\t\t\tSendStrToTerminal( stb, 1 ) ;\n\t\t\t\t\t\t//SendMessage(hwnd, WM_CHAR, j, 0) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSleep( internal_delay ) ;\n\t\t\t\tbuffer[0] = '\\0' ; j = 0 ;\n\t\t\t\ti++ ; i++ ; i++ ;\n\t\t\t} else if( st[i+1] == 'x' ) {\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\tsprintf( stb, \"0x%c%c\", st[i+2],st[i+3] ) ;\n\t\t\t\tsscanf( stb, \"%X\", &j ) ;\n\t\t\t\tstb[0]=j ; stb[1] = '\\0' ;\n\t\t\t\tSendStrToTerminal( stb, 1 ) ;\n\t\t\t\tSleep( internal_delay ) ;\n\t\t\t\tbuffer[0] = '\\0' ; j = 0 ;\n\t\t\t\ti++ ; i++ ; i++ ;\n\t\t\t} else { buffer[j] = '\\\\' ; j++ ; \n\t\t\t}\n\t\t} else { buffer[j] = st[i] ; j++ ; }\n\t\tbuffer[j] = '\\0' ;\n\t\ti++ ; \n\t\t} while( st[i] != '\\0' ) ;\n\t\t\n\t\tif( strlen( buffer ) > 0 ) {\n\t\t\tif( buffer[strlen(buffer)-1]=='\\\\' ) { // si la command se termine par \\ on n'envoie pas de retour charriot\n\t\t\t\tbuffer[strlen(buffer)-1]='\\0' ;\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t} else {\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\tif( buffer[strlen(buffer)-1] != '\\n' ) // On ajoute un retour charriot au besoin\n\t\t\t\t\tSendKeyboard( hwnd, \"\\n\" ) ;\n\t\t\t}\n\t\t}\n\t\tfree( buffer ) ;\n\t}\n}\n\nvoid SendAutoCommand( HWND hwnd, const char * cmd ) {\n\tif( strlen( cmd ) > 0 ) {\n\t\t/*FILE * fp ;\n\t\tif( ( fp = fopen( cmd, \"r\" ) ) != NULL ){\n\t\t\tchar buffer[4096] ;\n\t\t\twhile( fgets( buffer, 4096, fp) != NULL ) {\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\t}\n\t\t\tSendKeyboard( hwnd, \"\\n\" ) ;\n\t\t\tfclose( fp ) ;\n\t\t\t}*/\n\t\tchar *buf;\n\t\tbuf=(char*)malloc( strlen(cmd)+30 ) ;\n\t\tstrcpy( buf, \"Send automatic command\" ) ;\n\t\tif( debug_flag ) { strcat( buf, \": \") ; strcat( buf, cmd ) ; }\n\t\tif( conf_get_int(conf,CONF_protocol) != PROT_TELNET ) debug_logevent( buf ) ; // On logue que si on est pas en telnet (à cause du password envoyé en clair)\n\t\tfree(buf);\n\t\tif( existfile( cmd ) ) { \n\t\t\tRunScriptFile( hwnd, cmd ) ; \n\t\t} else if( (toupper(cmd[0])=='C')&&(toupper(cmd[1])==':')&&(toupper(cmd[2])=='\\\\') ) { \n\t\t\t//MessageBox( NULL, cmd,\"Info\", MB_OK );\n\t\t\treturn ;\n\t\t} else { \n\t\t\tSendKeyboardPlus( hwnd, cmd ) ; \n\t\t}\n\t} else { \n\t\tif( debug_flag ) debug_logevent( \"No automatic command !\" ) ; \n\t}\n}\n\n// Command sender (send a command to all windows)\nBOOL CALLBACK SendCommandProc( HWND hwnd, LPARAM lParam ) {\n\tchar buffer[256] ;\n\tGetClassName( hwnd, buffer, 256 ) ;\n\tif( !strcmp( buffer, KiTTYClassName ) ) {\n\t\tif( hwnd != MainHwnd ) {\n\t\t\tCOPYDATASTRUCT data;\n\t\t\tdata.dwData = 1 ;\n\t\t\tdata.cbData = strlen( (char*)lParam ) + 1 ;\n\t\t\tdata.lpData = (char*)lParam ;\n\t\t\tSendMessage( hwnd, WM_COPYDATA, (WPARAM)(HWND)MainHwnd, (LPARAM) (LPVOID)&data ) ;\n\t\t\tNbWindows++ ;\n\t\t}\n\t}\n\treturn TRUE ;\n}\n\nint SendCommandAllWindows( HWND hwnd, char * cmd ) {\n\tNbWindows=0 ;\n\tif( cmd==NULL ) return 0 ;\n\tif( strlen(cmd) > 0 ) {\n\t\tEnumWindows( SendCommandProc, (LPARAM)cmd ) ;\n\t}\n\treturn NbWindows ;\n}\n\t\n// Gestion de la taille des fenetres de la meme classe\nBOOL CALLBACK ResizeWinListProc( HWND hwnd, LPARAM lParam ) {\n\tchar buffer[256] ;\n\tGetClassName( hwnd, buffer, 256 ) ;\n\t\n\tif( !strcmp( buffer, KiTTYClassName ) )\n\tif( hwnd != MainHwnd ) {\n\t\tRECT * rc = (RECT*) lParam ;\n\t\tLPARAM pos = MAKELPARAM( rc->left, rc->top ) ;\n\t\tLPARAM size = MAKELPARAM( rc->right, rc->bottom ) ;\n\t\t//SendNotifyMessage( hwnd, WM_COMMAND, IDM_RESIZE, size ) ;\n\t\t//SendNotifyMessage( hwnd, WM_COMMAND, IDM_REPOS, pos ) ;\n\t\tPostMessage( hwnd, WM_COMMAND, IDM_REPOS, pos ) ;\n\t\tPostMessage( hwnd, WM_COMMAND, IDM_RESIZE, size ) ;\n\t\t//PostMessage( hwnd, WM_COMMAND, IDM_RESIZEH, rc->bottom ) ;\n\t\t//SetWindowPos( hwnd, 0, 0, 0, rc->right-rc->left+1, rc->bottom-rc->top+1, SWP_NOZORDER|SWP_NOMOVE|SWP_NOREPOSITION|SWP_NOACTIVATE ) ;\n\t\t//SetWindowPos( hwnd, 0, 0, 0, 50,50, SWP_NOZORDER|SWP_NOMOVE|SWP_NOREPOSITION|SWP_NOACTIVATE);\n\t\tNbWindows++ ;\n\t}\n\n\treturn TRUE ;\n}\n\nint ResizeWinList( HWND hwnd, int width, int height ) {\n\tNbWindows=0 ;\n\tRECT rc;\n\tGetWindowRect(hwnd, &rc) ;\n\trc.right = width ;\n\trc.bottom = height ;\n\tEnumWindows( ResizeWinListProc, (LPARAM)&rc ) ;\n\tSetForegroundWindow( hwnd ) ;\n\treturn NbWindows ;\n}\n\nvoid set_title( TermWin *tw, const char *title ) { return win_set_title(tw,title) ; } // Disparue avec la version 0.71\nvoid ManageProtect( HWND hwnd, TermWin *tw, char * title ) {\n\tHMENU m ;\n\tif( ( m = GetSystemMenu (hwnd, FALSE) ) != NULL ) {\n\t\tDWORD fdwMenu = GetMenuState( m, (UINT) IDM_PROTECT, MF_BYCOMMAND); \n\t\tif (!(fdwMenu & MF_CHECKED)) {\n\t\t\tCheckMenuItem( m, (UINT)IDM_PROTECT, MF_BYCOMMAND|MF_CHECKED ) ;\n\t\t\tProtectFlag = 1 ;\n\t\t\tset_title(tw, title) ;\n\t\t} else {\n\t\t\tCheckMenuItem( m, (UINT)IDM_PROTECT, MF_BYCOMMAND|MF_UNCHECKED ) ;\n\t\t\tProtectFlag = 0 ;\n\t\t\tset_title(tw, title);\n\t\t}\n\t}\n}\n\n// Affiche un menu dans le systeme Tray\nvoid DisplaySystemTrayMenu( HWND hwnd ) {\n\tHMENU menu ;\n\tPOINT pt;\n\n\tmenu = CreatePopupMenu () ;\n\tAppendMenu( menu, MF_ENABLED, IDM_FROMTRAY, \"&Restore\" ) ;\n\tAppendMenu( menu, MF_SEPARATOR, 0, 0 ) ;\n\tAppendMenu( menu, MF_ENABLED, IDM_ABOUT, \"&About\" ) ;\n\tAppendMenu( menu, MF_ENABLED, IDM_QUIT, \"&Quit\" ) ;\n\t\t\n\tSetForegroundWindow( hwnd ) ;\n\tGetCursorPos (&pt);\n\tTrackPopupMenu (menu, TPM_LEFTALIGN, pt.x, pt.y, 0, hwnd, NULL);\n\t}\n\t\n// Gere l'envoi dans le System Tray\nint ManageToTray( HWND hwnd ) {\n\t//SendMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);\n\t//MessageBox( NULL, \"To tray\", \"Tray\", MB_OK ) ;\n\t//SendMessage( hwnd, WM_SETICON, ICON_SMALL, (LPARAM)LoadIcon( hInstIcons, MAKEINTRESOURCE(IDI_MAINICON_0 + IconeNum ) ) );\n\t//Message MYWM_NOTIFYICON pour faire reapparaitre\n\n\tint ResShell ;\n\tchar buffer[4096] ;\n\tTrayIcone.hWnd = hwnd;\n\t//TrayIcone.hIcon = LoadIcon((HINSTANCE) GetModuleHandle(NULL), MAKEINTRESOURCE(IDI_MAINICON_0 + IconeNum));\n\tResShell = Shell_NotifyIcon(NIM_ADD, &TrayIcone);\n\t\t\t\t\t\t\n\tif( ResShell ) {\n\t\tGetWindowText( hwnd, buffer, 4096 ) ;\n\t\t//buffer[strlen(buffer)-21] = '\\0' ;\n\t\tstrcpy( TrayIcone.szTip, buffer ) ;\n\t\tResShell = Shell_NotifyIcon(NIM_MODIFY, &TrayIcone);\n\t\tif (IsWindowVisible(hwnd)) ShowWindow(hwnd, SW_HIDE);\n\t\tVisibleFlag = VISIBLE_TRAY ;\n\t\t//SendMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);\n\t\treturn 1 ;\n\t\t}\n\telse return 0 ;\n\t}\n\n// Gere l'option always visible\nvoid ManageVisible( HWND hwnd, TermWin *tw, char * title ) {\n\tHMENU m ;\n\tif( ( m = GetSystemMenu (hwnd, FALSE) ) != NULL ) {\n\t\tDWORD fdwMenu = GetMenuState( m, (UINT) IDM_VISIBLE, MF_BYCOMMAND); \n\t\tif (!(fdwMenu & MF_CHECKED)) {\n\t\t\tCheckMenuItem( m, (UINT)IDM_VISIBLE, MF_BYCOMMAND|MF_CHECKED ) ;\n\t\t\tSetWindowPos(hwnd,(HWND)-1,0,0,0,0,  SWP_NOMOVE |SWP_NOSIZE ) ;\n\t\t\tconf_set_bool( conf, CONF_alwaysontop, true ) ;\n\t\t\tset_title(tw, title) ;\n\t\t} else {\n\t\t\tCheckMenuItem( m, (UINT)IDM_VISIBLE, MF_BYCOMMAND|MF_UNCHECKED ) ;\n\t\t\tSetWindowPos(hwnd,(HWND)-2,0,0,0,0,  SWP_NOMOVE |SWP_NOSIZE ) ;\n\t\t\tconf_set_bool( conf, CONF_alwaysontop, false ) ;\n\t\t\tset_title(tw, title) ;\n\t\t}\n\t}\n}\n\nvoid ManageShortcutsFlag( HWND hwnd ) {\n\tHMENU m ;\n\tSetShortcutsFlag( abs(GetShortcutsFlag()-1) ) ;\n\tif( ( m = GetSystemMenu (hwnd, FALSE) ) != NULL ) {\n\t\tif( GetShortcutsFlag() ) {\n\t\t\tCheckMenuItem( m, (UINT)IDM_SHORTCUTSTOGGLE, MF_BYCOMMAND|MF_CHECKED ) ;\n\t\t} else {\n\t\t\tCheckMenuItem( m, (UINT)IDM_SHORTCUTSTOGGLE, MF_BYCOMMAND|MF_UNCHECKED ) ;\n\t\t}\n\t}\n}\n\t\n// Gere la demande de relance de l'application\nvoid ManageRestart( HWND hwnd ) {\n\tSendMessage( hwnd, WM_COMMAND, IDM_RESTART, 0 ) ;\n}\n\n// Lance une configbox avec les paramètres courants (mais sans hostname)\nvoid del_settings(const char *sessionname);\nvoid RunSessionWithCurrentSettings( HWND hwnd, Conf *conf, const char * host, const char * user, const char * pass, const int port, const char * remotepath ) ;\n\n// Modification de l'icone de l'application\n//SendMessage( hwnd, WM_SETICON, ICON_SMALL, (LPARAM)LoadIcon( hInstIcons, MAKEINTRESOURCE(IDI_MAINICON_0 + IconeNum ) ) );\nvoid SetNewIcon( HWND hwnd, char * iconefile, int icone, const int mode ) {\n\t\n\tHICON hIcon = NULL, hIconBig = NULL ;\n\tif( (strlen(iconefile)>0) && existfile(iconefile) ) {\n\t\thIcon = LoadImage(NULL, iconefile, IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_LOADFROMFILE|LR_SHARED) ; \n\t\thIconBig = LoadImage(NULL, iconefile, IMAGE_ICON, 0, 0, LR_LOADFROMFILE|LR_SHARED|LR_DEFAULTSIZE) ; \n\t}\n\n\tif( hIcon || hIconBig ) {\n\t\tif(!hIcon) hIcon = hIconBig ;\n\t\tif(!hIconBig) hIconBig = hIcon ;\n\t\tSendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIconBig) ; \n\t\tSendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon) ;\n\t\tTrayIcone.hIcon = hIcon ;\n\t\t//DeleteObject( hIcon ) ; \n\t} else {\n\t\tif( mode == SI_INIT ) {\n\t\t\tif( icone!=0 ) IconeNum = icone - 1 ;\n\t\t\thIcon = LoadIcon( hInstIcons, MAKEINTRESOURCE(IDI_MAINICON_0 + IconeNum ) ) ;\n\t\t\tSendMessage( hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon );\n\t\t\tSendMessage( hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon );\n\t\t\tTrayIcone.hIcon = hIcon ;\n\t\t} else {\n\t\t\tif( IconeFlag==0 ) return ;\n\t\t\tif( IconeFlag <= 0 ) { IconeNum = 0 ; \n\t\t\t} else {\n\t\t\t\tif( mode == SI_RANDOM ) { \n\t\t\t\t\tSYSTEMTIME st ;\n\t\t\t\t\tGetSystemTime( &st ) ;\n\t\t\t\t\tIconeNum = ( GetCurrentProcessId() * time( NULL ) ) % NumberOfIcons ; \n\t\t\t\t} else { \n\t\t\t\t\tIconeNum++ ; if( IconeNum >= NumberOfIcons ) IconeNum = 0 ; \n\t\t\t\t}\n\t\t\t}\n\t\t\thIcon = LoadIcon( hInstIcons, MAKEINTRESOURCE(IDI_MAINICON_0 + IconeNum ) ) ;\n\t\t\tSendMessage( hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon );\t\n\t\t\tSendMessage( hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon );\n\t\t\tTrayIcone.hIcon = hIcon ;\n\t\t}\n\t}\n\tShell_NotifyIcon(NIM_MODIFY, &TrayIcone);\n}\n\n// Modification de l'icone pour mettre l'icone de perte de connexion\nvoid SetConnBreakIcon( HWND hwnd ) {\n#ifdef MOD_PERSO\n\tHICON hIcon = NULL ;\n\thIcon = LoadIcon( hInstIcons, MAKEINTRESOURCE(IDI_NOCON) ) ;\n\tSendMessage( hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon );\t\n\tSendMessage( hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon );\n\tTrayIcone.hIcon = hIcon ;\n\tShell_NotifyIcon(NIM_MODIFY, &TrayIcone);\n#endif\n//Pour remettre\n//SetNewIcon( hwnd, conf_get_filename(conf,CONF_iconefile)->path, 0, SI_INIT ) ;\n}\n\n// Envoi d'un fichier de script local\nvoid RunScriptFile( HWND hwnd, const char * filename ) {\n\tlong len = 0 ; size_t lread ;\n\tchar * oldcmd = NULL ;\n\tFILE * fp ;\n\t\t/*\n\t\tstrcpy( buffer, \"\" ) ;\n\t\tif( ( fp = fopen( filename, \"r\" ) ) != NULL ){\n\t\t\twhile( fgets( buffer, 4096, fp) != NULL ) {\n\t\t\t\tSendKeyboard( hwnd, buffer ) ;\n\t\t\t\t}\n\t\t\tSendKeyboard( hwnd, \"\\n\" ) ;\n\t\t\tfclose( fp ) ;\n\t\t\t}\n\t\t*/\n\tif( ScriptCommand != NULL ) { free( ScriptCommand ) ; ScriptCommand = NULL ; }\n\t\tif( existfile( filename ) ) {\n\n\t\tlen = filesize( filename ) ;\n\t\tif( (AutoCommand!=NULL)&&(strlen(AutoCommand)>0) ) {\n\t\t\toldcmd=(char*)malloc(strlen(AutoCommand)+3) ;\n\t\t\tsprintf( oldcmd, \"\\\\n%s\", AutoCommand );\n\t\t\t}\n\t\tif( oldcmd==NULL ) ScriptCommand = (char*) malloc( len + 1 ) ; \n\t\telse ScriptCommand = (char*) malloc( len + strlen(oldcmd) + 2 ) ; \n\t\tif( ( fp = fopen( filename, \"r\" ) ) != NULL ) {\n\t\t\tlread = fread( ScriptCommand, 1, len, fp ) ;\n\t\t\tScriptCommand[lread]='\\0' ;\n\t\t\tfclose( fp ) ;\n\t\t\tif( oldcmd!=NULL ) strcat( ScriptCommand, oldcmd ) ;\n\t\t\tif( strlen( ScriptCommand) > 0 ) {\n\t\t\t\tif( AutoCommand!= NULL ) { free(AutoCommand); AutoCommand=NULL; }\n\t\t\t\tAutoCommand = (char*) malloc( strlen(ScriptCommand) + 10 ) ;\n\t\t\t\tstrcpy( AutoCommand, ScriptCommand ) ;//AutoCommand = ScriptCommand ;\n\t\t\t\tSetTimer(hwnd, TIMER_AUTOCOMMAND, autocommand_delay, NULL) ;\n\t\t\t\t}\n\t\t\t}\n\t\tif( oldcmd!=NULL ) free( oldcmd ) ;\n\t\t}\n\t}\n\nvoid OpenAndSendScriptFile( HWND hwnd ) {\n    char filename[4096], buffer[4096] ;\n    if( ReadParameter( INIT_SECTION, \"scriptfilefilter\", buffer ) ) {\n        buffer[4090]='\\0';\n    } else { \n        strcpy( buffer, \"Script files (*.ksh,*.sh)|*.ksh;*.sh|SQL files (*.sql)|*.sql|All files (*.*)|*.*|\" ) ;\n    }\n    if( buffer[strlen(buffer)-1]!='|' ) strcat( buffer, \"|\" ) ;\n    if( OpenFileName( hwnd, filename, \"Open file...\", buffer ) ) {\n        RunScriptFile( hwnd, filename ) ;\n    }\n}\n\n// Envoi d'un fichier par SCP vers la racine du compte\nint SearchPSCP( void ) ;\nstatic int nb_pscp_run = 0 ;\nvoid SendOneFile( HWND hwnd, char * directory, char * filename, char * distantdir) {\n\tchar buffer[4096], pscppath[4096]=\"\", pscpport[4096]=\"22\", remotedir[4096]=\".\",dir[4096], b1[256] ;\n\tint p ;\n\t\n\tif( distantdir == NULL ) { distantdir = kitty_current_dir() ; } \n\tif( PSCPPath==NULL ) {\n\t\tif( IniFileFlag == SAVEMODE_REG ) return ;\n\t\telse if( !SearchPSCP() ) return ;\n\t}\n\tif( !existfile( PSCPPath ) ) {\n\t\tif( IniFileFlag == SAVEMODE_REG ) return ;\n\t\telse if( !SearchPSCP() ) return ;\n\t}\n\t\t\n\tif( !GetShortPathName( PSCPPath, pscppath, 4095 ) ) return ;\n\t\n\tif( ReadParameter( INIT_SECTION, \"uploaddir\", dir ) ) {\n\t\tif( !existdirectory( dir ) ) \n\t\t\tstrcpy( dir, InitialDirectory ) ;\n\t}\n\tif (strlen( dir ) == 0) strcpy( dir, InitialDirectory ) ;\n\n\tif( (distantdir != NULL ) && ( strlen(distantdir)>0 ) ) {\n\t\tstrcpy( remotedir, distantdir ) ;\n\t} else if( strlen(conf_get_str(conf,CONF_pscpremotedir))>0 ) {\n\t\tstrcpy( remotedir, conf_get_str(conf,CONF_pscpremotedir) ) ;\n\t} else { strcpy( remotedir, \".\" ) ; \n\t}\n\tif( strlen( remotedir ) == 0 ) strcpy( remotedir, \".\" ) ;\n\n\tstrcpy( buffer, \"\" ) ;\n\t\n\tif( nb_pscp_run<4 ) { sprintf( buffer, \"start %s \", pscppath ) ; nb_pscp_run++ ; }\n\telse { sprintf( buffer, \"%s \", pscppath ) ; nb_pscp_run = 0 ; }\n\t\n\tif( strlen(conf_get_str(conf, CONF_pscpoptions))>0 ) {\n\t\tstrcat( buffer, conf_get_str(conf, CONF_pscpoptions) ) ; strcat( buffer, \" \" ) ;\n\t}\n\tif( conf_get_int(conf, CONF_winscpprot)==0 ) { strcat( buffer, \"-scp \" ) ; }\n\telse { strcat( buffer, \"-sftp \" ) ; }\n\t\n\t//if( GetAutoStoreSSHKeyFlag() ) strcat( buffer, \"-auto-store-sshkey \" ) ;\n\t\n\tif( ReadParameter( INIT_SECTION, \"pscpport\", pscpport ) ) {\n\t\tpscpport[17]='\\0';\n\t\tif( !strcmp( pscpport,\"*\" ) ) sprintf( pscpport, \"%d\", conf_get_int(conf, CONF_port) ) ;\n\t\tstrcat( buffer, \"-P \" ) ;\n\t\tstrcat( buffer, pscpport ) ;\n\t\tstrcat( buffer, \" \" ) ;\n\t} else {\n\t\tif( (p=poss(\":\",conf_get_str(conf, CONF_sftpconnect) )) > 0 ) {\n\t\t\tsprintf( b1, \"-P %d \", atoi(conf_get_str(conf, CONF_sftpconnect)+p) ) ;\n\t\t} else {\n\t\t\tsprintf( b1, \"-P %d \", conf_get_int(conf, CONF_port) ) ;\n\t\t}\n\t\tstrcat( buffer, b1 ) ;\n\t}\n\n\tif( conf_get_int(conf, CONF_sshprot) == 3 ) { // SSH-2 Only (voir putty.h)\n\t\tstrcat( buffer, \"-2 \" ) ;\n\t}\n\tif( strlen( conf_get_str(conf,CONF_password)) > 0 ) {\n\t\tstrcat( buffer, \"-pw \\\"\" ) ;\n\t\tchar bufpass[1024] ;\n\t\tstrcpy( bufpass, conf_get_str(conf,CONF_password) ) ;\n\t\tMASKPASS(GetCryptSaltFlag(),bufpass) ; strcat( buffer, bufpass ) ; memset( bufpass, 0, strlen(bufpass) ) ;\n\t\tstrcat( buffer, \"\\\" \" ) ;\n\t}\n\tif( strlen( conf_get_str(conf,CONF_portknockingoptions)) > 0 ) {\n\t\tstrcat( buffer, \"-knock \\\"\" ) ;\n\t\tstrcat( buffer, conf_get_str(conf,CONF_portknockingoptions) ) ;\n\t\tstrcat( buffer, \"\\\" \" ) ;\n\t}\n\tif( strlen( conf_get_filename(conf, CONF_keyfile)->path ) > 0 ) {\n\t\tstrcat( buffer, \"-i \\\"\" ) ;\n\t\tstrcat( buffer, conf_get_filename(conf, CONF_keyfile)->path ) ;\n\t\tstrcat( buffer, \"\\\" \" ) ;\n\t}\n\tstrcat( buffer, \"\\\"\" ) ; //strcat( buffer, filename ) ; \n\tif( (strlen(directory)>0) && (strlen(filename)>0) ) {\n\t\tstrcat( buffer, directory ) ; \n\t\tstrcat( buffer, \"\\\\\" ) ; \n\t\tstrcat( buffer, filename ) ;\n\t} else if( (directory!=NULL)&&(strlen(directory)>0) ) { \n\t\tstrcat(buffer, directory ) ; \n\t} else { \n\t\tstrcat(buffer, filename ) ; \n\t}\n\tstrcat( buffer, \"\\\" \" ) ;\n\t\n\tif( strlen( conf_get_str(conf, CONF_sftpconnect) ) > 0 ) {\n\t\tstrcpy( b1, conf_get_str(conf, CONF_sftpconnect) ) ;\n\t\tif( (p=poss(\":\",b1)) > 0 ) { b1[p-1]='\\0'; }\n\t\tstrcat( buffer, b1 ) ;\n\t} else {\n\t\tstrcat( buffer, conf_get_str(conf,CONF_username) ) ; strcat( buffer, \"@\" ) ;\n\t\tif( poss( \":\", conf_get_str(conf,CONF_host))>0 ) { strcat( buffer, \"[\" ) ; strcat( buffer, conf_get_str(conf,CONF_host ) ) ; strcat( buffer, \"]\" ) ; }\n\t\telse { strcat( buffer, conf_get_str(conf,CONF_host) ) ; }\n\t}\n\t\n\tstrcat( buffer, \":\" ) ; strcat( buffer, remotedir ) ;\n\t\n\tchdir( InitialDirectory ) ;\n\tif( debug_flag ) { debug_logevent( \"Run: %s\", buffer ) ; }\n\tif( system( buffer ) ) MessageBox( NULL, buffer, \"Transfer problem\", MB_OK|MB_ICONERROR  ) ;\n\t\n\t//debug_log(\"%s\\n\",buffer);MessageBox( NULL, buffer, \"Info\",MB_OK );\n\t\n\tmemset(buffer,0,strlen(buffer));\n\t}\n\nvoid SendFileList( HWND hwnd, char * filelist ) {\n\tchar *pname=NULL,dir[4096] ;\n\tint i;\n\n\tif( filelist==NULL ) return ;\n\tif( strlen( filelist ) == 0 ) return ;\n\n\tif( (filelist[strlen(filelist)]=='\\0') && (filelist[strlen(filelist)+1]=='\\0') ) {\n\t\ti=strlen(filelist) ;\n\t\twhile( i>0 ) {\n\t\t\ti--;\n\t\t\tif( (filelist[i]=='/')||(filelist[i]=='\\\\') ) { filelist[i]='\\0' ; break ; }\n\t\t\t}\n\t\t}\n\tstrcpy( dir, filelist ) ;\n\n\tpname=filelist+strlen(filelist)+1;\n\t\n\ti = 0 ;\n\twhile( pname[i] != '\\0' ){\n\t\t\t\n\t\twhile( (pname[i] != '\\0') && (pname[i] != '\\n') && (pname[i] != '\\r') ) { i++ ; }\n\t\tpname[i]='\\0';\n\t\tSendOneFile( hwnd, dir, pname, NULL ) ;\n\t\tpname=pname+i+1 ; i=0;\n\t\t}\n\t\t\n\t}\n\nvoid SendFile( HWND hwnd ) {\n\tchar filename[32768] ;\n\n\tif( conf_get_int(conf,CONF_protocol) != PROT_SSH ) {\n\t\tMessageBox( hwnd, \"This function is only available with SSH connections.\", \"Error\", MB_OK|MB_ICONERROR ) ;\n\t\treturn ;\n\t\t}\n\n\tif( OpenFileName( hwnd, filename, \"Send file...\", \"All files (*.*)|*.*|\" ) ) \n\t\tif( strlen( filename ) > 0 ) {\n\t\t\tSendFileList( hwnd, filename ) ;\n\t\t}\n\t}\n\n\n// Start a plink command\n/*\nrun() { printf \"\\033]0;__pl:$*\\007\" ; }\n*/\nint SearchPlink( void ) ;\nvoid RunExternPlink( HWND hwnd, const char * cmd ) {\n    char buffer[4096], plinkpath[4096]=\"\", b1[256] ;\n\n    if( PlinkPath==NULL ) {\n        if( IniFileFlag == SAVEMODE_REG ) return ;\n        else if( !SearchPlink() ) return ;\n    }\n    if( !existfile( PlinkPath ) ) {\n        if( IniFileFlag == SAVEMODE_REG ) return ;\n        else if( !SearchPlink() ) return ;\n    }\n\n    if( !GetShortPathName( PlinkPath, plinkpath, 4095 ) ) return ;\n\n    strcpy( buffer, \"\" ) ;\n    sprintf( buffer, \"%s \", plinkpath ) ;\n\n    //if( GetAutoStoreSSHKeyFlag() ) strcat( buffer, \"-auto-store-sshkey \" ) ;\n\n    if( strlen( conf_get_str(conf, CONF_sftpconnect) ) == 0 ) {\n        sprintf( b1, \"-P %d \", conf_get_int(conf, CONF_port)) ;\n        strcat( buffer, b1 ) ;\n    }\n\n    if( conf_get_int(conf,CONF_sshprot) == 3 ) { // SSH-2 Only (voir putty.h)\n        strcat( buffer, \"-2 \" ) ;\n    }\n\n    if( strlen( conf_get_str(conf,CONF_password) ) > 0 ) {\n        strcat( buffer, \"-pw \\\"\" ) ;\n        char bufpass[1024] ;\n        strcpy( bufpass,conf_get_str(conf,CONF_password) ) ;\n        MASKPASS(GetCryptSaltFlag(),bufpass); strcat( buffer, bufpass ) ; memset(bufpass,0,strlen(bufpass));\n        strcat( buffer, \"\\\" \" ) ;\n    }\n\n    if( strlen( conf_get_filename(conf,CONF_keyfile)->path ) > 0 ) {\n        strcat( buffer, \"-i \\\"\" ) ;\n        strcat( buffer, conf_get_filename(conf,CONF_keyfile)->path ) ;\n        strcat( buffer, \"\\\" \" ) ;\n    }\n\n    strcat( buffer, \"\\\"\" ) ;\n\n    if( strlen( conf_get_str(conf, CONF_sftpconnect) ) > 0 ) {\n        strcat( buffer, conf_get_str(conf, CONF_sftpconnect) ) ;\n    } else {\n        strcat( buffer, conf_get_str(conf,CONF_username) ) ; strcat( buffer, \"@\" ) ;\n        if( poss( \":\", conf_get_str(conf,CONF_host) )>0 ) { strcat( buffer, \"[\" ) ; strcat( buffer, conf_get_str(conf,CONF_host) ) ; strcat( buffer, \"]\" ) ; }\n        else { strcat( buffer, conf_get_str(conf,CONF_host) ) ; }\n    }\n    strcat( buffer, \"\\\" \" );\n\n    strcat( buffer, \"\\\"\" ) ; strcat( buffer, cmd ) ; strcat(buffer,\"\\\"\") ;\n\n    chdir( InitialDirectory ) ;\n    if( debug_flag ) { debug_logevent( \"Run: %s\", buffer) ; }\n    if( system( buffer ) ) { MessageBox( NULL, buffer, \"Execute problem\", MB_OK|MB_ICONERROR  ) ; }\n}\n\n// Get a remote file throught scp\n/*\nget()\n{\necho \"\\033]0;__pw:\"`pwd`\"\\007\"\nfor file in ${*} ; do echo \"\\033]0;__rv:\"${file}\"\\007\" ; done\n}\n*/\nvoid GetOneFile( HWND hwnd, char * directory, const char * filename ) {\n    char buffer[4096], pscppath[4096]=\"\", pscpport[4096]=\"22\", dir[4096]=\".\", b1[256] ;\n    int p;\n\n    if( PSCPPath==NULL ) {\n        if( IniFileFlag == SAVEMODE_REG ) return ;\n        else if( !SearchPSCP() ) return ;\n    }\n    if( !existfile( PSCPPath ) ) {\n        if( IniFileFlag == SAVEMODE_REG ) return ;\n        else if( !SearchPSCP() ) return ;\n    }\n\n    if( !GetShortPathName( PSCPPath, pscppath, 4095 ) ) return ;\n\n    if( ReadParameter( INIT_SECTION, \"downloaddir\", dir ) ) {\n        if( !existdirectory( dir ) ) { strcpy( dir, InitialDirectory ) ; }\n    }\n\n    if(strlen( dir ) == 0) { strcpy( dir, InitialDirectory ) ; }\n\n    strcpy( buffer, \"\" ) ;\n\n    if( nb_pscp_run<4 ) {\n        sprintf( buffer, \"start %s \", pscppath ) ;\n        nb_pscp_run++ ; \n    } else {\n        sprintf( buffer, \"%s \", pscppath ) ;\n        nb_pscp_run = 0 ; \n    }\n\n    if( strlen(conf_get_str(conf, CONF_pscpoptions))>0 ) {\n        strcat( buffer, conf_get_str(conf, CONF_pscpoptions) ) ;\n        strcat( buffer, \" \" ) ;\n    }\n    if( conf_get_int(conf, CONF_winscpprot)==0 ) {\n        strcat( buffer, \"-scp \" ) ; \n    } else {\n        strcat( buffer, \"-sftp \" ) ;\n    }\n\n    //if( GetAutoStoreSSHKeyFlag() ) strcat( buffer, \"-auto-store-sshkey \" ) ;\n\n    if( ReadParameter( INIT_SECTION, \"pscpport\", pscpport ) ) {\n        pscpport[17]='\\0';\n        if( !strcmp( pscpport,\"*\" ) ) sprintf( pscpport, \"%d\", conf_get_int(conf,CONF_port) ) ;\n        strcat( buffer, \"-P \" ) ;\n        strcat( buffer, pscpport ) ;\n        strcat( buffer, \" \" ) ;\n    } else {\n        if( (p=poss(\":\",conf_get_str(conf, CONF_sftpconnect) )) > 0 ) {\n            sprintf( b1, \"-P %d \", atoi(conf_get_str(conf, CONF_sftpconnect)+p) ) ;\n        } else {\n            sprintf( b1, \"-P %d \", conf_get_int(conf, CONF_port) ) ;\n        }\n        strcat( buffer, b1 ) ;\n    }\n\n    if( conf_get_int(conf,CONF_sshprot) == 3 ) { // SSH-2 Only (voir putty.h)\n        strcat( buffer, \"-2 \" ) ;\n        }\n    if( strlen( conf_get_str(conf,CONF_password) ) > 0 ) {\n        strcat( buffer, \"-pw \\\"\" ) ;\n        char bufpass[1024] ;\n        strcpy( bufpass,conf_get_str(conf,CONF_password) ) ;\n        MASKPASS(GetCryptSaltFlag(),bufpass); strcat( buffer, bufpass ) ; memset(bufpass,0,strlen(bufpass));\n        strcat( buffer, \"\\\" \" ) ;\n    }\n    if( strlen( conf_get_str(conf,CONF_portknockingoptions)) > 0 ) {\n        strcat( buffer, \"-knock \\\"\" ) ;\n        strcat( buffer, conf_get_str(conf,CONF_portknockingoptions) ) ;\n        strcat( buffer, \"\\\" \" ) ;\n    }\n    if( strlen( conf_get_filename(conf,CONF_keyfile)->path ) > 0 ) {\n        strcat( buffer, \"-i \\\"\" ) ;\n        strcat( buffer, conf_get_filename(conf,CONF_keyfile)->path ) ;\n        strcat( buffer, \"\\\" \" ) ;\n    }\n\n    strcat( buffer, \"\\\"\" ) ; \n    if( strlen( conf_get_str(conf, CONF_sftpconnect) ) > 0 ) {\n        strcpy( b1, conf_get_str(conf, CONF_sftpconnect) ) ;\n        if( (p=poss(\":\",b1)) > 0 ) { b1[p-1]='\\0'; }\n        strcat( buffer, b1 ) ;\n    } else {\n        strcat( buffer, conf_get_str(conf,CONF_username) ) ; strcat( buffer, \"@\" ) ;\n        if( poss( \":\", conf_get_str(conf,CONF_host) )>0 ) {\n            strcat( buffer, \"[\" ) ;\n            strcat( buffer, conf_get_str(conf,CONF_host) ) ;\n            strcat( buffer, \"]\" ) ; \n        } else { \n            strcat( buffer, conf_get_str(conf,CONF_host) ) ; \n        }\n    }\n    strcat( buffer, \":\" ) ; \n\n    if( filename[0]=='/' ) {\n        strcat(buffer, filename ) ;\n    } else {\n        if( (directory!=NULL) && (strlen(directory)>0) && (strlen(filename)>0) ) {\n            strcat( buffer, directory ) ; strcat( buffer, \"/\" ) ; strcat( buffer, filename ) ;\n        } else if( (directory!=NULL) && (strlen(directory)>0) ) {\n            strcat(buffer, directory ) ; strcat( buffer, \"/*\") ; \n        } else { \n            strcat(buffer, filename ) ; \n        }\n    }\n    strcat( buffer, \"\\\" \\\"\" ) ; strcat( buffer, dir ) ; strcat( buffer, \"\\\"\" ) ;\n    //strcat( buffer, \" > kitty.log 2>&1\" ) ; //if( !system( buffer ) ) unlink( \"kitty.log\" ) ;\n\n    chdir( InitialDirectory ) ;\n\n    if( debug_flag ) { debug_logevent( \"Get on file: %s\", buffer) ; }\n    if( system( buffer ) ) { MessageBox( NULL, buffer, \"Transfer problem\", MB_OK|MB_ICONERROR  ) ; }\n\n    //debug_log(\"%s\\n\",buffer);//MessageBox( NULL, buffer, \"Info\",MB_OK );\n\n    memset(buffer,0,strlen(buffer));\n}\n\n// Get a remote file throught SCP\nvoid GetFile( HWND hwnd ) {\n    char buffer[4096]=\"\", b1[256], *pst ;\n    char dir[4096], pscppath[4096]=\"\", pscpport[4096]=\"22\" ;\n    int p;\n\n    if( conf_get_int(conf,CONF_protocol) != PROT_SSH ) {\n        MessageBox( hwnd, \"This function is only available with SSH connections.\", \"Error\", MB_OK|MB_ICONERROR ) ;\n        return ;\n    }\n\n    if( PSCPPath==NULL ) {\n        if( IniFileFlag == SAVEMODE_REG ) return ;\n        else if( !SearchPSCP() ) return ;\n    }\n\n    if( !existfile( PSCPPath ) ) {\n        if( IniFileFlag == SAVEMODE_REG ) return ;\n        else if( !SearchPSCP() ) return ;\n    }\n\n    if( !GetShortPathName( PSCPPath, pscppath, 4095 ) ) return ;\n\n    if (!IsClipboardFormatAvailable(CF_TEXT)) return ;\n\n    if( OpenClipboard(NULL) ) {\n        HGLOBAL hglb ;\n\n        if( (hglb = GetClipboardData( CF_TEXT ) ) != NULL ) {\n            if( ( pst = GlobalLock( hglb ) ) != NULL ) {\n//sprintf(buffer,\"#%s#%d\",pst,strlen(pst));MessageBox(hwnd,buffer,\"Info\",MB_OK);\n                while( (pst[strlen(pst)-1]=='\\n')||(pst[strlen(pst)-1]=='\\r')||(pst[strlen(pst)-1]==' ')||(pst[strlen(pst)-1]=='\\t') ) { pst[strlen(pst)-1]='\\0' ; }\n//sprintf(buffer,\"#%s#%d\",pst,strlen(pst));MessageBox(hwnd,buffer,\"Info\",MB_OK);\n                strcpy( buffer, \"\" ) ;\n                if( strlen( pst ) > 0 ) {\n                    if( ReadParameter( INIT_SECTION, \"downloaddir\", dir ) ) {\n                        if( !existdirectory( dir ) ) {\n                            strcpy( dir, InitialDirectory ) ;\n                        }\n                    } else if( OpenDirName( hwnd, dir ) ) {\n                        if( !existdirectory( dir ) ) { GlobalUnlock( hglb ) ; CloseClipboard(); return ; }\n                        //strcpy( dir, InitialDirectory ) ;\n                    } else { \n                        return ; \n                    }\n                    //else { strcpy( dir, InitialDirectory ) ; }\n\n                    sprintf( buffer, \"start %s \", pscppath ) ;\n                    if( strlen(conf_get_str(conf, CONF_pscpoptions))>0 ) {\n                        strcat( buffer, conf_get_str(conf, CONF_pscpoptions) ) ;\n                        strcat( buffer, \" \" ) ;\n                    }\n                    if( conf_get_int(conf, CONF_winscpprot)==0 ) {\n                        strcat( buffer, \"-scp \" ) ; \n                    } else {\n                        strcat( buffer, \"-sftp \" ) ; \n                    }\n                    if( conf_get_int(conf,CONF_sshprot) == 3 ) { // SSH-2 Only (voir putty.h)\n                        strcat( buffer, \"-2 \" ) ;\n                    }\n                    if( ReadParameter( INIT_SECTION, \"pscpport\", pscpport ) ) {\n                        pscpport[17]='\\0';\n                        if( !strcmp( pscpport,\"*\" ) ) { sprintf( pscpport, \"%d\", conf_get_int(conf,CONF_port) ) ; }\n                        strcat( buffer, \"-P \" ) ;\n                        strcat( buffer, pscpport ) ;\n                        strcat( buffer, \" \" ) ;\n                    } else {\n                        if( (p=poss(\":\",conf_get_str(conf, CONF_sftpconnect) )) > 0 ) {\n                            sprintf( b1, \"-P %d \", atoi(conf_get_str(conf, CONF_sftpconnect)+p) ) ;\n                        } else {\n                            sprintf( b1, \"-P %d \", conf_get_int(conf, CONF_port) ) ;\n                        }\n                        strcat( buffer, b1 ) ;\n                    }\n                    if( strlen( conf_get_str(conf,CONF_password) ) > 0 ) {\n                        strcat( buffer, \"-pw \\\"\" ) ;\n                        char bufpass[1024] ;\n                        strcpy( bufpass, conf_get_str(conf,CONF_password) ) ;\n                        MASKPASS(GetCryptSaltFlag(),bufpass); strcat( buffer, bufpass ) ; memset(bufpass,0,strlen(bufpass));\n                        strcat( buffer, \"\\\" \" ) ;\n                    }\n                    if( strlen( conf_get_filename(conf,CONF_keyfile)->path ) > 0 ) {\n                        strcat( buffer, \"-i \\\"\" ) ;\n                        strcat( buffer, conf_get_filename(conf,CONF_keyfile)->path ) ;\n                        strcat( buffer, \"\\\" \" ) ;\n                    }\n                    if( strlen( conf_get_str(conf, CONF_sftpconnect) ) > 0 ) {\n                        strcpy( b1, conf_get_str(conf, CONF_sftpconnect) ) ;\n                        if( (p=poss(\":\",b1)) > 0 ) { b1[p-1]='\\0'; }\n                        strcat( buffer, b1 ) ;\n                    } else {\n                        strcat( buffer, conf_get_str(conf,CONF_username) ) ; strcat( buffer, \"@\" ) ;\n                        if( poss( \":\", conf_get_str(conf,CONF_host))>0 ) { \n                            strcat( buffer, \"[\" ) ; strcat( buffer, conf_get_str(conf,CONF_host) ) ; strcat( buffer, \"]\" ) ; \n                        } else { \n                            strcat( buffer, conf_get_str(conf,CONF_host) ) ; \n                        }\n                    }\n                    strcat( buffer, \":\" ) ;\n                    strcat( buffer, pst ) ; strcat( buffer, \" \\\"\" ) ;\n                    strcat( buffer, dir ) ; strcat( buffer, \"\\\"\" ) ;\n                }\n                GlobalUnlock( hglb ) ;\n            }\n        }\n        CloseClipboard();\n    }\n    if( strlen( buffer ) > 0 ) {\n        chdir( InitialDirectory ) ;\n        if( debug_flag ) { debug_logevent(\"Get file: %s\", buffer) ; }\n        if( system( buffer ) ) { MessageBox( NULL, buffer, \"Transfer problem\", MB_OK|MB_ICONERROR  ) ; }\n        //if( !system( buffer ) ) unlink( \"kitty.log\" ) ;\n    }\n}\n\n// Start a locale commande (Internet Explorer for example)\nvoid RunCmd( HWND hwnd ) {\n    char buffer[4096]=\"\", * pst = NULL ;\n    if (!IsClipboardFormatAvailable(CF_TEXT)) return ;\n    if( OpenClipboard(NULL) ) {\n        HGLOBAL hglb ;\n\n        if( (hglb = GetClipboardData( CF_TEXT ) ) != NULL ) {\n            if( ( pst = GlobalLock( hglb ) ) != NULL ) {\n                sprintf( buffer, \"%s\", pst ) ;\n                GlobalUnlock( hglb ) ;\n            }\n        }\n        CloseClipboard();\n    }\n    if( strlen( buffer ) > 0 ) {\n        chdir( InitialDirectory ) ;\n        //system( buffer ) ;\n        STARTUPINFO si ;\n        PROCESS_INFORMATION pi ;\n        ZeroMemory( &si, sizeof(si) );\n        si.cb = sizeof(si);\n        ZeroMemory( &pi, sizeof(pi) );\n        if( !CreateProcess(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi) ) {\n            ShellExecute(hwnd, \"open\", buffer,0, 0, SW_SHOWDEFAULT);\n        }\n    }\n}\n\n// Manage local commands\nstatic char * RemotePath = NULL ;\nchar * GetRemotePath() { return RemotePath ; }\n/* Save remote path in RemotePath variable\npw() { printf \"\\033]0;__pw:`pwd`\\007\" ; }\n*/\n/* Execute a local command\ncmd()\n{\nif [ $# -eq 0 ] ; then echo \"Usage: cmd command\" ; return 0 ; fi\nprintf \"\\033]0;__cm:\"$@\"\\007\"\n}\n*/\n/* Send a file that is present locally\nscriptfile()\n{\nif [ $# -eq 0 ] ; then echo \"Usage: scriptfile filename\" ; return 0 ; fi\nprintf \"\\033]0;__ls:\"$@\"\\007\"\n}\n*/\n/* Start default browser\nie()\n{\nif [ $# -eq 0 ] ; then echo \"Usage: ie url\" ; return 0 ; fi\nprintf \"\\033]0;__ie:\"$@\"\\007\"\n}\n*/\n/* Copy stdin into clipboard\nfunction wcl {\n  echo -ne '\\e''[5i'\n  cat $*\n  echo -ne '\\e''[4i'\n  echo \"Copied to Windows clipboard\" 1>&2\n}\n*/\n/* Start WinSCP pointing into the same directory\nwinscp() { printf \"\\033]0;__ws:\"`pwd`\"\\007\" ; printf \"\\033]0;__ti\\007\" ; }\nwinscp() { echo -ne \"\\033];__ws:${PWD}\\007\" ; }\n*/\n/* Start WinSCP with specific user, host and directory\nwt() { printf \"\\033]0;__wt:\"$(hostname)\":\"${USER}\":\"`pwd`\"\\007\" ; printf \"\\033]0;__ti\\007\" ; }\n*/\n/* Start a duplicated session into the same directory\nds() { printf \"\\033]0;__ds:`pwd`\\007\" ; }\n# Start a duplicated session with specific user, host and directory\ndt() { printf \"\\033]0;__dt:\"$(hostname)\":\"${USER}\":\"`pwd`\"\\007\" ; }\n*/\nstatic int LocalCmdFlag = 1 ;\nstatic int LocalUnsecureCmdFlag = 0 ;\nint ManageLocalCmd( HWND hwnd, const char * cmd ) {\n\n    if( !LocalCmdFlag ) { return 0 ; } // Disable all __xy commands\n    \n    char buffer[1024] = \"\", title[1024] = \"\" ;\n    if( debug_flag ) { debug_logevent( \"Local command: %s\", cmd ) ; }\n    if( cmd == NULL ) return 0 ;\n    if( (cmd[2] != ':')&&(cmd[2] != '\\0') ) return 0 ;\n    if( (cmd[2] == ':')&&( strlen( cmd ) <= 3 ) ) return 0 ;\n    \n    if( (cmd[0]=='d')&&(cmd[1]=='t')&&(cmd[2]==':') ) { // __dt: start a duplicated session in same directory, same host and same user : dt() { printf \"\\033]0;__dt:\"$(hostname)\":\"${USER}\":\"`pwd`\"\\007\" ; }\n        char host[1024]=\"\";char user[256]=\"\";\n        int i;\n        if( RemotePath!= NULL ) free( RemotePath ) ;\n        RemotePath = (char*) malloc( strlen( cmd ) - 2 ) ;\n        strcpy(host,cmd+3);i=poss(\":\",host);\n        strcpy(user,host+i);\n        host[i-1]='\\0';\n        i=poss(\":\",user);\n        strcpy( RemotePath, user+i ) ;\n        user[i-1]='\\0';\n        RunSessionWithCurrentSettings( hwnd, conf, host, user, NULL, 0, RemotePath ) ;\n        return 1 ;\n    } else if( (cmd[0]=='i')&&(cmd[1]=='n')&&(cmd[2]==':') ) { // __in: print informations in log\n        debug_logevent(cmd+3) ;\n        return 1 ;\n    } else if( (cmd[0]=='l')&&(cmd[1]=='s')&&(cmd[2]==':') ) { // __ls: start a local script in remote session\n        RunScriptFile( hwnd, cmd+3 ) ;\n        return 1 ;\n    } else if( (cmd[0]=='p')&&(cmd[1]=='w')&&(cmd[2]==':') ) { // __pw: new remote directory\n        if( RemotePath!= NULL ) free( RemotePath ) ;\n        RemotePath = (char*) malloc( strlen( cmd ) - 2 ) ;\n        strcpy( RemotePath, cmd+3 ) ;\n        return 1 ;\n    } else if( (cmd[0]=='r')&&(cmd[1]=='v')&&(cmd[2]==':') ) { // __rv: getting one file\n        GetOneFile( hwnd, RemotePath, cmd+3 ) ;\n        return 1 ;\n    } else if( (cmd[0]=='t')&&(cmd[1]=='i')&&(cmd[2]=='\\0') ) { // __ti: getting remote window title\n        GetWindowText( hwnd, buffer, 1024 ) ;\n        sprintf( title, \"printf \\\"\\\\033]0;%s\\\\007\\\"\\n\", buffer ) ;\n        SendStrToTerminal( title, strlen(title) ) ;\n        return 1 ;\n    } else if( (cmd[0]=='w')&&(cmd[1]=='s')&&(cmd[2]==':') ) { // __ws: start WinSCP into provided directory\n        if( RemotePath!= NULL ) free( RemotePath ) ;\n        RemotePath = (char*) malloc( strlen( cmd ) - 2 ) ;\n        strcpy( RemotePath, cmd+3 ) ;\n        StartWinSCP( hwnd, RemotePath, NULL, NULL ) ;\n        return 1 ;\n    } else if( (cmd[0]=='w')&&(cmd[1]=='t')&&(cmd[2]==':') ) { // __wt: start WinSCP on a provided host, with a specific user and in a directory\n        char host[1024]=\"\";char user[256]=\"\";\n        int i;\n        if( RemotePath!= NULL ) free( RemotePath ) ;\n        RemotePath = (char*) malloc( strlen( cmd ) - 2 ) ;\n        strcpy(host,cmd+3);i=poss(\":\",host);\n        strcpy(user,host+i);\n        host[i-1]='\\0';\n        i=poss(\":\",user);\n        strcpy( RemotePath, user+i ) ;\n        user[i-1]='\\0';\n        StartWinSCP( hwnd, RemotePath, host, user ) ;\n        // free( RemotePath ) ; RemotePath = NULL ;\n        return 1 ;\n    }\n    \n    if( !LocalUnsecureCmdFlag ) { return 0 ; } // Disable only unsecure __xy commands\n    if( (cmd[0]=='c')&&(cmd[1]=='m')&&(cmd[2]==':') ) { // __cm: run an external command locally\n        RunCommand( hwnd, cmd+3 ) ;\n        return 1 ;\n    } else if( (cmd[0]=='d')&&(cmd[1]=='s')&&(cmd[2]==':') ) { // __ds: start a duplicated session un same directory : ds() { printf \"\\033]0;__ds:`pwd`\\007\" ; }\n        if( RemotePath!= NULL ) free( RemotePath ) ;\n        RemotePath = (char*) malloc( strlen( cmd ) - 2 ) ;\n        strcpy( RemotePath, cmd+3 ) ;\n        if( debug_flag ) { debug_logevent( \"Start the same session in remote path: %s\", RemotePath ) ; }\n        RunSessionWithCurrentSettings( hwnd, conf, NULL, NULL, NULL, 0, RemotePath ) ;\n        return 1 ;\n    } else if( (cmd[0]=='i')&&(cmd[1]=='e')&&(cmd[2]==':') ) { // __ie: start default browser on provided URL\n        if( strlen(cmd+3)>0 ) {\n            urlhack_launch_url(!conf_get_int(conf,CONF_url_defbrowser)?conf_get_filename(conf,CONF_url_browser)->path:NULL, (const char *)(cmd+3));\n            return 1;\n        }\n    } else if( (cmd[0]=='p')&&(cmd[1]=='l')&&(cmd[2]==':') ) { // __pl: start a plink command\n        RunExternPlink( hwnd, cmd+3 ) ;\n        return 1 ;\n    }\n    \n    return 0 ;\n}\n\n// Get window coodinates\nvoid GetWindowCoord( HWND hwnd ) {\n    RECT rc ;\n    GetWindowRect( hwnd, &rc ) ;\n\n    conf_set_int(conf,CONF_xpos,rc.left);\n    conf_set_int(conf,CONF_ypos,rc.top);\n\n    conf_set_int(conf,CONF_windowstate,IsZoomed( hwnd ));\n}\n\n// Save window coordinates\nvoid SaveWindowCoord( Conf * conf ) {\n    char key[1024], session[1024] ;\n    if( conf_get_bool(conf,CONF_saveonexit) )\n    if( conf_get_str(conf,CONF_sessionname)!= NULL )\n    if( strlen( conf_get_str(conf,CONF_sessionname) ) > 0 ) {\n        if( IniFileFlag == SAVEMODE_REG ) {\n            mungestr( conf_get_str(conf,CONF_sessionname), session ) ;\n            sprintf( key, \"%s\\\\Sessions\\\\%s\", TEXT(PUTTY_REG_POS), session ) ;\n            RegTestOrCreateDWORD( HKEY_CURRENT_USER, key, \"TermXPos\", conf_get_int(conf,CONF_xpos) ) ;\n            RegTestOrCreateDWORD( HKEY_CURRENT_USER, key, \"TermYPos\", conf_get_int(conf,CONF_ypos) ) ;\n            RegTestOrCreateDWORD( HKEY_CURRENT_USER, key, \"TermWidth\", conf_get_int(conf,CONF_width) ) ;\n            RegTestOrCreateDWORD( HKEY_CURRENT_USER, key, \"TermHeight\", conf_get_int(conf,CONF_height) ) ;\n            RegTestOrCreateDWORD( HKEY_CURRENT_USER, key, \"WindowState\", conf_get_int(conf,CONF_windowstate) ) ;\n            RegTestOrCreateDWORD( HKEY_CURRENT_USER, key, \"TransparencyValue\", conf_get_int(conf,CONF_transparencynumber) ) ;\n        } else { \n            int xpos=conf_get_int(conf,CONF_xpos)\n                , ypos=conf_get_int(conf,CONF_ypos)\n                , width=conf_get_int(conf,CONF_width)\n                , height=conf_get_int(conf,CONF_height)\n                , windowstate=conf_get_int(conf,CONF_windowstate)\n                , transparency=conf_get_int(conf,CONF_transparencynumber);\n            load_settings( conf_get_str(conf,CONF_sessionname), conf ) ;\n            conf_set_int(conf,CONF_xpos,xpos) ; \n            conf_set_int(conf,CONF_ypos,ypos) ; \n            conf_set_int(conf,CONF_width,width) ;\n            conf_set_int(conf,CONF_height,height) ;\n            conf_set_int(conf,CONF_windowstate,windowstate) ; \n            conf_set_int(conf,CONF_transparencynumber,transparency) ; \n            save_settings( conf_get_str(conf,CONF_sessionname), conf ) ;\n        }\n    }\n}\n\n// Gestion de la fonction winroll\nvoid ManageWinrol( HWND hwnd, int resize_action ) {\n    RECT rcClient ;\n    int mode = -1 ;\n\n    if( resize_action==RESIZE_DISABLED ) {\n        mode = GetWindowLong(hwnd, GWL_STYLE) ;\n        resize_action = RESIZE_TERM ;\n        SetWindowLongPtr( hwnd, GWL_STYLE, mode|WS_THICKFRAME|WS_MAXIMIZEBOX ) ;\n        SetWindowPos( hwnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER ) ;\n    }\n\n    if( WinHeight == -1 ) {\n        GetWindowRect(hwnd, &rcClient) ;\n        WinHeight  = rcClient.bottom-rcClient.top ;\n        resize(0, rcClient.right-rcClient.left) ;\n        MoveWindow( hwnd, rcClient.left, rcClient.top, rcClient.right-rcClient.left, 0, TRUE ) ;\n    } else {\n        GetWindowRect(hwnd, &rcClient) ;\n        rcClient.bottom = rcClient.top + WinHeight ;\n        resize(WinHeight, -1) ;\n        MoveWindow( hwnd, rcClient.left, rcClient.top, rcClient.right-rcClient.left, WinHeight, TRUE ) ;\n        WinHeight = -1 ;\n    }\n\n    if( mode != -1 ) {\n        //winmode &= ~(WS_THICKFRAME | WS_MAXIMIZEBOX);\n        SetWindowLongPtr(hwnd, GWL_STYLE, mode ) ;\n        SetWindowPos( hwnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER ) ;\n        resize_action = RESIZE_DISABLED ;\n    }\n\n    InvalidateRect(hwnd, NULL, TRUE);\n}\n\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\nBOOL load_bg_bmp() ;\nvoid clean_bg( void ) ;\nvoid RedrawBackground( HWND hwnd ) ;\n#endif\n\nvoid RefreshBackground( HWND hwnd ) {\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( GetBackgroundImageFlag() ) RedrawBackground( hwnd ) ;\n\telse\n#endif\n\tInvalidateRect( hwnd, NULL, true ) ;\n}\n\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n/* Changement du fond d'ecran */\nint GetExt( const char * filename, char * ext) {\n\tint i;\n\tstrcpy( ext, \"\" ) ;\n\tif( filename==NULL ) return 0;\n\tif( strlen(filename)<=0 ) return 0;\n\tfor( i=(strlen(filename)-1) ; i>=0 ; i-- ) \n\t\tif( filename[i]=='.' ) strcpy( ext, filename+i+1 ) ;\n\tif( i<0 ) return 0;\n\treturn 1;\n\t}\n\nint PreviousBgImage( HWND hwnd ) {\n\tchar buffer[1024], basename[1024], ext[10], previous[1024]=\"\" ;\n\tint i ;\n\tDIR * dir ;\n\tstruct dirent * de ;\n\n\tstrcpy( basename, conf_get_filename(conf,CONF_bg_image_filename)->path ) ;\n\n\tfor( i=(strlen(basename)-1) ; i>=0 ; i-- ) \n\t\tif( (basename[i]=='\\\\')||(basename[i]=='/') ) { basename[i]='\\0' ; break ; }\n\tif( i<0 ) strcpy( basename, \".\") ;\n\n\tif( ( dir = opendir( basename ) ) == NULL ) { return 0 ; }\n\t\n\twhile( ( de = readdir(dir) ) != NULL ) {\n\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") ) {\n\t\t\tsprintf( buffer,\"%s\\\\%s\", basename, de->d_name ) ;\n\t\t\tif( !(GetFileAttributes( buffer ) & FILE_ATTRIBUTE_DIRECTORY) ) {\n\t\t\t\tif( !strcmp(buffer, conf_get_filename(conf,CONF_bg_image_filename)->path ) )\n\t\t\t\t\tif( strcmp( previous, \"\" ) ) break ;\n\t\t\n\t\t\t\tGetExt( de->d_name, ext ) ;\n\t\t\t\tif( (!stricmp(ext,\"BMP\"))||(!stricmp(ext,\"JPG\"))||(!stricmp(ext,\"JPEG\"))) \n\t\t\t\t\t{ sprintf( previous,\"%s\\\\%s\", basename, de->d_name ) ; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif( strcmp( previous, \"\" ) ){\n\t\tFilename * fn = filename_from_str( previous ) ;\n\t\tconf_set_filename(conf,CONF_bg_image_filename,fn); \n\t\tfilename_free(fn);\n\t\tRefreshBackground( hwnd ) ;\n\t\t}\n\treturn 1 ;\n\t}\n\nint NextBgImage( HWND hwnd ) {\n\tchar buffer[1024], basename[1024], ext[10] ;\n\tint i ;\n\tDIR * dir ;\n\tstruct dirent * de ;\n\n\tstrcpy( basename, conf_get_filename(conf,CONF_bg_image_filename)->path ) ;\n\n\tfor( i=(strlen(basename)-1) ; i>=0 ; i-- ) \n\t\tif( (basename[i]=='\\\\')||(basename[i]=='/') ) { basename[i]='\\0' ; break ; }\n\tif( i<0 ) strcpy( basename, \".\") ;\n\n\tif( ( dir = opendir( basename ) ) == NULL ) { return 0 ; }\n\t\n\twhile( ( de = readdir(dir) ) != NULL ) {\n\t\tGetExt( de->d_name, ext ) ;\n\n\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") \n\t\t\t&& ( (!stricmp(ext,\"BMP\"))||(!stricmp(ext,\"JPG\"))||(!stricmp(ext,\"JPEG\"))) \n\t\t\t) {\n\t\t\tsprintf( buffer,\"%s\\\\%s\", basename, de->d_name ) ;\n\t\t\tif( !(GetFileAttributes( buffer ) & FILE_ATTRIBUTE_DIRECTORY) ) {\n\t\t\t\tif( !stricmp( buffer, conf_get_filename(conf,CONF_bg_image_filename)->path ) ) {\n\t\t\t\t\tif( ( de = readdir(dir) ) != NULL ) \n\t\t\t\t\t\tGetExt( de->d_name, ext ) ; \n\t\t\t\t\telse \n\t\t\t\t\t\tstrcpy( ext, \"\" ) ;\n\t\t\t\t\t\t\n\t\t\t\t\twhile( (de!=NULL)&&stricmp(ext,\"BMP\")&&stricmp(ext,\"JPG\")&&stricmp(ext,\"JPEG\") ) {\n\t\t\t\t\t\tif( ( de = readdir(dir) ) != NULL ) \n\t\t\t\t\t\t\tGetExt( de->d_name, ext ) ; \n\t\t\t\t\t\telse \n\t\t\t\t\t\t\tstrcpy( ext, \"\" ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tif( de==NULL ) { rewinddir( dir ) ; do { de = readdir(dir) ; } while( (!strcmp(de->d_name,\".\")) || (!strcmp(de->d_name,\"..\")) ) ; }\n\tif( de!=NULL ) GetExt( de->d_name, ext ) ; else strcpy( ext, \"\" ) ;\n\tif( de!=NULL )\n\twhile( (de!=NULL)&&stricmp(ext,\"BMP\")&&stricmp(ext,\"JPG\")&&stricmp(ext,\"JPEG\") ) {\n\t\tif( ( de = readdir(dir) ) != NULL ) GetExt( de->d_name, ext ) ; else { strcpy( ext, \"\" ) ; break ; }\n\t\t}\n\tif( de != NULL  ) {\n\t\tsprintf( buffer,\"%s\\\\%s\", basename, de->d_name ) ;\n\t\tFilename * fn = filename_from_str( buffer ) ;\n\t\tconf_set_filename( conf,CONF_bg_image_filename,fn);\n\t\tfilename_free(fn);\n\t\tRefreshBackground( hwnd );\n\t\t}\n\telse { closedir(dir) ; return 0 ; }\n\n\tclosedir( dir ) ;\n\treturn 1 ;\n\t}\n#endif\n\t\n// Boite de dialogue d'information\nstatic LRESULT CALLBACK InfoCallBack( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam ) {\n\tswitch(message) {\n\t\tcase WM_INITDIALOG: SetWindowText( GetDlgItem(hwnd,IDC_RESULT), \"\" ) ; break;\n\t\tcase WM_COMMAND:\n\t\t\tif( LOWORD(wParam) == 1001 ) {\n\t\t\t\tSetWindowText( GetDlgItem(hwnd,IDC_RESULT), (char*)lParam ) ;\n\t\t\t\t}\n\n\t\t\tif (LOWORD(wParam) == IDCANCEL)\n\t\t\t{\n\t\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\tbreak;\n\n\t\treturn DefWindowProc (hwnd, message, wParam, lParam);\n\t\t}\n\treturn 0;\n\t}\n\t\nHWND InfoBox( HINSTANCE hInstance, HWND hwnd ) {\n\tHWND hdlg = CreateDialog( hInstance, (LPCTSTR)120, hwnd, (DLGPROC)InfoCallBack ) ;\n\treturn hdlg ;\n\t}\n\t\nvoid InfoBoxSetText( HWND hwnd, char * st ) { SendMessage( hwnd, WM_COMMAND, 1001, (LPARAM) st ) ; SendMessage( hwnd, WM_PAINT, 0,0 ) ; }\n\nvoid InfoBoxClose( HWND hwnd ) { EndDialog(hwnd, LOWORD(0)) ; DestroyWindow( hwnd ) ; }\n\n//CallBack du dialog InputBox\nstatic int InputBox_Flag = 0 ;\n\nstatic LRESULT CALLBACK InputCallBack(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam ) {\n\tHWND handle;\n\tswitch (message) {\n\t\tcase WM_INITDIALOG:\n\t\t\tif( IniFileFlag == SAVEMODE_DIR ) {\n\t\t\t\tSetWindowText(hwnd,\"Text input (portable mode)\");\n\t\t\t}\n\t\t\thandle = GetDlgItem(hwnd,IDC_RESULT);\n\t\t\tif( InputBoxResult == NULL ) SetWindowText(handle,\"\") ;\n\t\t\telse SetWindowText( handle, InputBoxResult ) ;\n\t\t\tbreak;\n\t\tcase WM_COMMAND:\n\t\t\tif (LOWORD(wParam) == IDOK)\n\t\t\t{\n\t\t\t\thandle = GetDlgItem(hwnd,IDC_RESULT);\n\t\t\t\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\t\t\tsize_t length = GetWindowTextLength( handle ) ;\n\t\t\t\tInputBoxResult = (char*) malloc( length + 10 ) ;\n\t\t\t\tGetWindowText(handle,InputBoxResult,length+1);\n\t\t\t\t//EndDialog(hwnd, LOWORD(1));\n\t\t\t\tif( !InternalCommand( hwnd, InputBoxResult ) )\n\t\t\t\t\tSendKeyboardPlus( MainHwnd, InputBoxResult );\n\t\t\t\tSetWindowText(handle,\"\") ;\n\t\t\t\t\n\t\t\t}\n\t\t\tif (LOWORD(wParam) == IDCANCEL)\n\t\t\t{\n\t\t\t\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\tbreak;\n\n\t\treturn DefWindowProc (hwnd, message, wParam, lParam);\n\t}\n\treturn 0;\n}\n\nstatic LRESULT CALLBACK InputCallBackPassword(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam){\n\tHWND handle;\n\tswitch (message) {\n\t\tcase WM_INITDIALOG:\n\t\t\thandle = GetDlgItem(hwnd,IDC_RESULT);\n\t\t\tif( InputBoxResult == NULL ) SetWindowText(handle,\"\");\n\t\t\telse SetWindowText( handle, InputBoxResult ) ;\n\t\t\tbreak;\n\n\t\tcase WM_COMMAND:\n\t\t\tif (LOWORD(wParam) == IDOK)\n\t\t\t{\n\t\t\t\thandle = GetDlgItem(hwnd,IDC_RESULT);\n\t\t\t\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\t\t\tsize_t length = GetWindowTextLength( handle ) ;\n\t\t\t\tInputBoxResult = (char*) malloc( length + 10 ) ;\n\t\t\t\tGetWindowText(handle,InputBoxResult,length+1);\n\t\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\t}\n\t\t\tif (LOWORD(wParam) == IDCANCEL)\n\t\t\t{\n\t\t\t\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase WM_CLOSE:\n\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\tbreak;\n\n\t\treturn DefWindowProc (hwnd, message, wParam, lParam);\n\t}\n\treturn 0;\n}\n\n// Procedure specifique à la editbox multiligne (SHIFT+F8)\nFARPROC lpfnOldEditProc ;\nBOOL FAR PASCAL EditMultilineCallBack(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {\n\tchar buffer[4096], key_name[1024] ;\n\tswitch (message) {\n\t\tcase WM_KEYDOWN:\n\t\t\tif( (wParam==VK_RETURN) && (GetKeyState( VK_SHIFT )& 0x8000) ){\n\t\t\t\tSendMessage(GetParent(hwnd),WM_COMMAND,IDB_OK,0 ) ;\n\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\telse if( (wParam==VK_F12) && (GetKeyState( VK_SHIFT )& 0x8000) ){\n\t\t\t\tGetWindowText( hwnd, buffer, 4096 ) ;\n\t\t\t\tcryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ;\n\t\t\t\tSetWindowText( hwnd, buffer ) ;\n\t\t\t\treturn 0 ;\n\t\t\t\t}\n\t\t\telse if( (wParam==VK_F11) && (GetKeyState( VK_SHIFT )& 0x8000) ){\n\t\t\t\tGetWindowText( hwnd, buffer, 4096 ) ;\n\t\t\t\tdecryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ;\n\t\t\t\tSetWindowText( hwnd, buffer ) ;\n\t\t\t\treturn 0 ;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\treturn CallWindowProc((WNDPROC)lpfnOldEditProc, hwnd, message, wParam, lParam);\n\t\t\tbreak;\n\t\tcase WM_KEYUP:\n\t\tcase WM_CHAR:\n\t\tcase WM_SYSKEYDOWN:\n\t\tcase WM_SYSKEYUP:\n\t\t\tif( (wParam==VK_RETURN) && (GetKeyState( VK_SHIFT )& 0x8000) )\n\t\t\t\treturn 0;\n\t\t\telse if( (wParam==VK_F2) && (GetKeyState( VK_SHIFT )& 0x8000) ) { // Charge une Notes\n\t\t\t\tsprintf( key_name, \"%s\\\\Sessions\\\\%s\", TEXT(PUTTY_REG_POS), conf_get_str(conf,CONF_sessionname) ) ;\n\t\t\t\tif( GetValueData(HKEY_CURRENT_USER, key_name, \"Notes\", buffer) != NULL ) {\n\t\t\t\t\tif( GetWindowTextLength(hwnd) > 0 ) \n\t\t\t\t\t\tif( MessageBox(hwnd, \"Are you sure you want to load Notes\\nand erase this edit box ?\",\"Load Warning\", MB_YESNO|MB_ICONWARNING ) != IDYES ) break ;\n\t\t\t\t\tSetWindowText( hwnd, buffer ) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if( (wParam==VK_F3) && (GetKeyState( VK_SHIFT )& 0x8000) ) { // Sauve une Notes\n\t\t\t\tGetSessionField( conf_get_str(conf,CONF_sessionname), conf_get_str(conf,CONF_folder), \"Notes\", buffer ) ;\n\t\t\t\tif( strlen( buffer ) > 0 ) \n\t\t\t\t\tif( MessageBox(hwnd, \"Are you sure you want to save Edit box\\ninto Notes registry ?\",\"Save Warning\", MB_YESNO|MB_ICONWARNING ) != IDYES ) break ;\n\t\t\t\tGetWindowText( hwnd, buffer, 4096 ) ;\n\t\t\t\tsprintf( key_name, \"%s\\\\Sessions\\\\%s\", TEXT(PUTTY_REG_POS), conf_get_str(conf,CONF_sessionname) ) ;\n\t\t\t\tRegTestOrCreate( HKEY_CURRENT_USER, key_name, \"Notes\", buffer ) ;\n\t\t\t\t}\n\t\t\telse \n\t\t\t\treturn CallWindowProc((WNDPROC)lpfnOldEditProc, hwnd, message, wParam, lParam);\t\n\t\t\tbreak ;\n            \tdefault:\n\t\t\treturn CallWindowProc((WNDPROC)lpfnOldEditProc, hwnd, message, wParam, lParam);\n\t\t\tbreak;\n\t\t}\n\treturn TRUE ;\n\t}\n\nstatic int EditReadOnly = 0 ;\n#ifndef GWL_WNDPROC\n#define GWL_WNDPROC GWLP_WNDPROC\n#endif\nstatic LRESULT CALLBACK InputMultilineCallBack (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n\tHWND handle;\n\n\tswitch (message)\n\t{\n\t\tcase WM_INITDIALOG: {\n\t\t\tchar * buffer ;\n\t\t\tbuffer=(char*)malloc(1024);\n\t\t\tsprintf( buffer, \"%s - Text input\", conf_get_str(conf,CONF_wintitle) ) ;\n\t\t\tSetWindowText( hwnd, buffer ) ;\n\t\t\tfree(buffer);\n\t\t\thandle = GetDlgItem(hwnd,IDC_RESULT) ;\n\t\t\tif( EditReadOnly ) SendMessage(handle, EM_SETREADONLY, 1, 0);\n\t\t\tif( InputBoxResult == NULL ) SetWindowText(handle,\"\");\n\t\t\telse {\n\t\t\t\tint i,j=0;\n\t\t\t\tbuffer=(char*)malloc(2*strlen(InputBoxResult)+10);\n\t\t\t\tfor( i=0; i<=strlen(InputBoxResult);i++ ) {\n\t\t\t\t\tif( (InputBoxResult[i]=='\\n') && (buffer[j-1]!='\\r') ) \n\t\t\t\t\t\t{ buffer[j]='\\r';j++;}\n\t\t\t\t\tbuffer[j]=InputBoxResult[i];\n\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\tSetWindowText( handle, buffer ) ;\n\t\t\t\tfree(buffer);\n\t\t\t\t}\n\t\t\t\n\t\t\tFARPROC lpfnSubClassProc = MakeProcInstance( EditMultilineCallBack, hInst );\n\t\t\tif( lpfnSubClassProc )\n\t\t\t\tlpfnOldEditProc = (FARPROC)SetWindowLong( handle, GWL_WNDPROC, (DWORD)(FARPROC)lpfnSubClassProc );\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_COMMAND:\n\t\t\tif (LOWORD(wParam) == IDB_OK) {\n\t\t\t\thandle = GetDlgItem(hwnd,IDC_RESULT);\n\t\t\t\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\t\t\tsize_t length = GetWindowTextLength( handle ) ;\n\t\t\t\tInputBoxResult = (char*) malloc( length + 10 ) ;\n\n\t\t\t\tGetWindowText(handle,InputBoxResult,length+1);\n\n\t\t\t\t// Si il y un texte selectionne, on ne recupere que celui-ci\n\t\t\t\tDWORD result = SendMessage( handle, EM_GETSEL, (WPARAM)0, (LPARAM)NULL );\n\t\t\t\tif( LOWORD(result) != HIWORD(result) ) {\n\t\t\t\t\tint i ;\n\t\t\t\t\tInputBoxResult[HIWORD(result)] = '\\0' ;\n\t\t\t\t\tif( LOWORD(result) > 0 ) \n\t\t\t\t\t\tfor( i=0 ; i<=(HIWORD(result)-LOWORD(result)) ; i++ )\n\t\t\t\t\t\tInputBoxResult[i]=InputBoxResult[i+LOWORD(result)];\n\t\t\t\t\t}\n\t\t\t\tif( InputBoxResult[strlen(InputBoxResult)-1] != '\\n' ) \n\t\t\t\t\tstrcat( InputBoxResult, \"\\n\" ) ;\n\n\t\t\t\tSendKeyboard( MainHwnd, InputBoxResult ) ;\n\t\t\t\tShowWindow( MainHwnd, SW_RESTORE ) ;\n\t\t\t\tBringWindowToTop( MainHwnd ) ;\n\t\t\t\tSetFocus( handle ) ;\n\t\t\t\t}\n\t\t\telse if (LOWORD(wParam) == IDCANCEL) {\n\t\t\t\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\t\t\tEditReadOnly = 0 ;\n\t\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\t\t}\n\t\t\telse if( HIWORD( wParam ) == EN_SETFOCUS ) {\n\t\t\t\tShowWindow( MainHwnd, SW_SHOWNOACTIVATE ) ;\n\t\t\t\tDefWindowProc (hwnd, message, wParam, lParam) ;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase WM_CHAR: {\n\t\t\tDefWindowProc (hwnd, message, wParam, lParam) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\tcase WM_SIZE: {\n\t\t\tint h = HIWORD(lParam),w = LOWORD(lParam) ;\n\t\t\thandle = GetDlgItem( hwnd, IDC_RESULT ) ;\n\t\t\tSetWindowPos( handle, HWND_TOP, 7, 35, w-15, h-43, 0 ) ;\n\t\t\tDefWindowProc (hwnd, message, wParam, lParam) ;\n\t\t\t} \n\t\t\tbreak ;\n\t\tcase WM_CLOSE:\n\t\t\tEditReadOnly = 0 ;\n\t\t\tEndDialog(hwnd, LOWORD(0));\n\t\t\tbreak;\n\t\t\n\t\treturn DefWindowProc(hwnd, message, wParam, lParam);\n\t}\n\treturn 0;\n}\n\nchar * InputBox( HINSTANCE hInstance, HWND hwnd ) {\n\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\tDialogBox(hInstance, (LPCTSTR)117, hwnd, (DLGPROC)InputCallBack) ;\n\treturn InputBoxResult ;\n\t}\n\nchar * InputBoxMultiline( HINSTANCE hInstance, HWND hwnd ) {\n\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\t\n\tif( IsClipboardFormatAvailable(CF_TEXT) ) {\n\t\tchar * pst = NULL ;\n\t\tif( OpenClipboard(NULL) ) {\n\t\t\tHGLOBAL hglb ;\n\t\t\tif( (hglb = GetClipboardData( CF_TEXT ) ) != NULL ) {\n\t\t\t\tif( ( pst = GlobalLock( hglb ) ) != NULL ) {\n\t\t\t\t\tInputBoxResult = (char*) malloc( strlen( pst ) +1 ) ;\n\t\t\t\t\tstrcpy( InputBoxResult, pst ) ;\n\t\t\t\t\tGlobalUnlock( hglb ) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tCloseClipboard();\n\t\t\t}\n\t\t}\n\n\tDialogBox(hInstance, (LPCTSTR)118, NULL, (DLGPROC)InputMultilineCallBack) ;\n\treturn InputBoxResult ;\n\t}\n\t\nchar * InputBoxPassword( HINSTANCE hInstance, HWND hwnd ) {\n\tif( InputBoxResult != NULL ) { free( InputBoxResult ) ; InputBoxResult = NULL ; }\n\tDialogBox(hInstance, (LPCTSTR)119, hwnd, (DLGPROC)InputCallBackPassword) ;\n\treturn InputBoxResult ;\n\t}\n\nvoid GetAndSendLine( HWND hwnd ) {\n\tif( InputBox_Flag == 1 ) return ;\n\tInputBox_Flag = 1 ;\n\tInputBox( hinst, hwnd ) ; // Essayer avec GetModuleHandle(NULL)\n\tInputBox_Flag = 0 ;\n\t}\n\t\nvoid GetAndSendMultiLine( HWND hwnd ) {\n\tif( InputBox_Flag == 1 ) return ;\n\n\tInputBox_Flag = 1 ;\n\tInputBoxMultiline( hinst, hwnd ) ;\n\tInputBox_Flag = 0 ;\n\t}\n\nvoid GetAndSendLinePassword( HWND hwnd ) {\n\tif( InputBox_Flag == 1 ) return ;\n\tInputBox_Flag = 1 ;\n\tInputBoxPassword( hinst, hwnd ) ; // Essayer avec GetModuleHandle(NULL)\n\tInputBox_Flag = 0 ;\n\t}\n\nvoid routine_inputbox( void * phwnd ) { \n\tGetAndSendLine( MainHwnd ) ;\n\t}\n\nvoid routine_inputbox_multiline( void * phwnd ) { \n\tGetAndSendMultiLine( MainHwnd ) ;\n\t}\n\nvoid routine_inputbox_password( void * phwnd ) { \n\tGetAndSendLinePassword( MainHwnd ) ;\n\t}\n\n// Demarre le timer d'autocommand a la connexion\nvoid CreateTimerInit( void ) {\n\tSetTimer(MainHwnd, TIMER_INIT, init_delay, NULL) ; \n\t}\n\n// Positionne le repertoire ou se trouve la configuration \nvoid SetConfigDirectory( const char * Directory ) {\n\tchar *buf ;\n\tif( ConfigDirectory != NULL ) { \n\t\tfree( ConfigDirectory ) ; \n\t\tConfigDirectory = NULL ; \n\t}\n\tif( (Directory!=NULL)&&(strlen(Directory)>0) ) {\n\t\tif( IsPathAbsolute(Directory) ) {\n\t\t\tbuf = (char*) malloc(strlen(Directory)+1) ;\n\t\t\tstrcpy( buf, Directory ) ;\n\t\t} else {\n\t\t\tbuf = (char*)malloc(strlen(InitialDirectory)+strlen(Directory)+2) ;\n\t\t\tsprintf( buf, \"%s\\\\%s\", InitialDirectory, Directory ) ;\n\t\t}\n\t\tif( existdirectory(buf) ) {\n\t\t\tConfigDirectory = (char*)malloc( strlen(buf)+1 ) ; \n\t\t\tstrcpy( ConfigDirectory, buf ) ; \n\t\t}\n\t\tfree( buf ) ;\n\t}\n\tif( ConfigDirectory==NULL ) { \n\t\tConfigDirectory = (char*)malloc( strlen(InitialDirectory)+1 ) ; \n\t\tstrcpy( ConfigDirectory, InitialDirectory ) ; \n\t}\n}\n\t\nvoid GetInitialDirectory( char * InitialDirectory ) {\n\tint i ;\n\tif( GetModuleFileName( NULL, (LPTSTR)InitialDirectory, 4096 ) ) {\n\t\tif( strlen( InitialDirectory ) > 0 ) {\n\t\t\ti = strlen( InitialDirectory ) -1 ;\n\t\t\tdo {\n\t\t\t\tif( InitialDirectory[i] == '\\\\' ) { InitialDirectory[i]='\\0' ; i = 0 ; }\n\t\t\t\ti-- ;\n\t\t\t} while( i >= 0 ) ;\n\t\t}\n\t} else { \n\t\tstrcpy( InitialDirectory, \"\" ) ; \n\t}\n\t\n\tSetConfigDirectory( InitialDirectory ) ;\n}\n\t\nvoid GotoInitialDirectory( void ) { chdir( InitialDirectory ) ; }\nvoid GotoConfigDirectory( void ) { if( ConfigDirectory!=NULL ) chdir( ConfigDirectory ) ; }\n\n#define NB_MENU_MAX 1024\nstatic char *SpecialMenu[NB_MENU_MAX] ;\nint ReadSpecialMenu( HMENU menu, char * KeyName, int * nbitem, int separator ) {\n\tHKEY hKey ;\n\tHMENU SubMenu ;\n\tchar buffer[4096], fullpath[1024], *p ;\n\tint i, nb ;\n\tint local_nb = 0 ;\n\tif( (IniFileFlag == SAVEMODE_REG)||(IniFileFlag == SAVEMODE_FILE) ) {\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(KeyName), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tTCHAR achValue[MAX_VALUE_NAME], achClass[MAX_PATH] = TEXT(\"\");\n\t\tDWORD  cchClassName=MAX_PATH,cSubKeys=0,cbMaxSubKey,cchMaxClass,cValues,cchMaxValue,cbMaxValueData,cbSecurityDescriptor;\n\t\tFILETIME ftLastWriteTime;\n\n\t\tRegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime);\n\t\tnb = (*nbitem) ;\n\n\t\tif( cSubKeys>0 ) { // Recuperation des sous-menu\n\t\tfor (i=0; (i<cSubKeys)&&(nb<NB_MENU_MAX); i++) {\n\t\t\tDWORD cchValue = MAX_VALUE_NAME; \n\t\t\tchar lpData[4096] ;\n\t\t\tachValue[0] = '\\0';\n\n\t\t\tif( RegEnumKeyEx(hKey, i, lpData, &cchValue, NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\t\tSubMenu = CreateMenu() ;\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", KeyName, lpData ) ;\n\t\t\t\tReadSpecialMenu( SubMenu, buffer, nbitem, 0 ) ;\n\t\t\t\tunmungestr( lpData, buffer, MAX_PATH ) ;\n\t\t\t\tAppendMenu( menu, MF_POPUP, (UINT_PTR)SubMenu, buffer ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tnb = (*nbitem) ;\n\t\t\n\t\tif (cValues) { // Recuperation des item de menu\n\t\tif( separator ) AppendMenu( menu, MF_SEPARATOR, 0, 0 ) ;\n\t\t\n\t\tif( nb<NB_MENU_MAX )\n\t        for (i=0; (i<cValues)&&(nb<NB_MENU_MAX); i++) {\n\t\t\tDWORD cchValue = MAX_VALUE_NAME; \n\t\t\tDWORD lpType,dwDataSize=4096 ;\n\t\t\tunsigned char lpData[4096] ;\n\t\t\tdwDataSize = 4096 ;\n\t\t\tachValue[0] = '\\0';\n\n\t\t\tif( RegEnumValue(hKey,i,achValue,&cchValue,NULL,&lpType,lpData,&dwDataSize) == ERROR_SUCCESS ) {\n\t\t\tif( strcmp(achValue,\"Default Settings\") || strcmp(KeyName,\"Software\\\\9bis.com\\\\KiTTY\\\\Launcher\") ) { \n\t\t\t\tif( ShortcutsFlag ) {\n\t\t\t\t\tif( nb < 26 ) \n\t\t\t\t\t\tsprintf( buffer, \"%s\\tCtrl+Shift+%c\", achValue, ('A'+nb) ) ;\n\t\t\t\t\telse \n\t\t\t\t\t\tsprintf( buffer, \"%s\", achValue ) ;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsprintf( buffer, \"%s\", achValue ) ;\n\t\t\t\tAppendMenu(menu, MF_ENABLED, IDM_USERCMD+nb, buffer ) ;\n\t\t\t\tSpecialMenu[nb]=(char*)malloc( strlen( (char*)lpData ) + 1 ) ;\n\t\t\t\tstrcpy( SpecialMenu[nb], (char*)lpData ) ;\n\t\t\t\tnb++ ;\n\t\t\t\tlocal_nb++ ;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n    \t\t}\n\n\t\t(*nbitem)=nb ;\n\t\t\n\t\tRegCloseKey( hKey ) ;\n\t\t}\n\t\t}\n\telse if( IniFileFlag == SAVEMODE_DIR ) {\n\t\tsprintf( fullpath, \"%s\\\\%s\", ConfigDirectory, KeyName ) ;\n\t\tDIR * dir ;\n\t\tstruct dirent * de ;\n\t\tFILE *fp ;\n\t\tif( ( dir = opendir( fullpath ) ) != NULL ) {\n\t\t\tif( separator ) AppendMenu( menu, MF_SEPARATOR, 0, 0 ) ;\n\t\t\tnb = (*nbitem) ;\n\t\t\twhile( ( de = readdir(dir) ) != NULL ) { // Recherche de sous-cle (repertoire)\n\t\t\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") ) {\n\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\", fullpath, de->d_name ) ;\n\t\t\t\t\tif( GetFileAttributes( buffer ) & FILE_ATTRIBUTE_DIRECTORY ) {\n\t\t\t\t\t\tSubMenu = CreateMenu() ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\", KeyName, de->d_name ) ;\n\t\t\t\t\t\tReadSpecialMenu( SubMenu, buffer, nbitem, 0 ) ;\n\t\t\t\t\t\tunmungestr( de->d_name, buffer, MAX_PATH ) ;\n\t\t\t\t\t\tAppendMenu( menu, MF_POPUP, (UINT_PTR)SubMenu, buffer ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t/*if( stat( buffer, &statBuf ) != -1 ) {\n\t\t\t\t\t\tif( ( statBuf.st_mode & S_IFMT) == S_IFDIR ) {\n\t\t\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\", KeyName, de->d_name ) ;\n\t\t\t\t\t\t\tReadSpecialMenu( menu, buffer, nbitem, separator ) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\trewinddir( dir ) ;\n\n\t\t\tnb = (*nbitem) ;\n\t\t\twhile( ( de = readdir(dir) ) != NULL ) { // Recherche de cle\n\t\t\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") ) {\n\t\t\t\tif( strcmp(de->d_name,\"Default%20Settings\") || strcmp(KeyName,\"Launcher\") ) { // Default Settings ne doit pas apparaitre dans le Launcher\n\t\t\t\t\t\n\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\", fullpath, de->d_name ) ;\n\t\t\t\t\tif( !(GetFileAttributes( buffer ) & FILE_ATTRIBUTE_DIRECTORY) ) {\n\t\t\t\t\t\tif( ( fp=fopen(buffer,\"rb\")) != NULL ) {\n\t\t\t\t\t\t\twhile( fgets( buffer, 4096, fp )!=NULL ){\n\t\t\t\t\t\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')\n\t\t\t\t\t\t\t\t\t||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0';\n\t\t\t\t\t\t\t\tif( buffer[strlen(buffer)-1]=='\\\\' ) {\n\t\t\t\t\t\t\t\t\tbuffer[strlen(buffer)-1]='\\0' ;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif( (p=strstr(buffer,\"\\\\\"))!=NULL ){\n\t\t\t\t\t\t\t\t\t\tp[0]='\\0';\n\t\t\t\t\t\t\t\t\t\tAppendMenu(menu, MF_ENABLED, IDM_USERCMD+nb, buffer ) ;\n\t\t\t\t\t\t\t\t\t\tSpecialMenu[nb]=(char*)malloc( strlen( p+1 ) + 1 ) ;\n\t\t\t\t\t\t\t\t\t\tstrcpy( SpecialMenu[nb], p+1 ) ;\n\t\t\t\t\t\t\t\t\t\tnb++ ;\n\t\t\t\t\t\t\t\t\t\tlocal_nb++ ;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfclose(fp) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\tif( stat( buffer, &statBuf ) != -1 ) {\n\t\t\t\t\t\tif( ( statBuf.st_mode & S_IFMT ) == S_IFREG ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}*/\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t(*nbitem)=nb ;\n\t\t\tclosedir( dir ) ;\n\t\t\t}\n\t\t}\n\treturn local_nb ;\n\t}\n\nvoid InitSpecialMenu( HMENU m, const char * folder, const char * sessionname ) {\n\tchar KeyName[1024], buffer[1024] ;\n\tint nbitem = 0 ;\n\n\tHMENU menu ;\n\tmenu = CreateMenu() ;\n\t\n\tif( IniFileFlag == SAVEMODE_DIR ) {\n\t\tstrcpy( KeyName, \"Commands\" ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 0 ) ;\n\t\t\n\t\tmungestr( folder, buffer ) ;\n\t\tsprintf( KeyName, \"Folders\\\\%s\\\\Commands\", buffer ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 1 ) ;\n\t\t\n\t\tmungestr( sessionname, buffer ) ;\n\t\tsprintf( KeyName, \"Sessions_Commands\\\\%s\", buffer ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 1 ) ;\n\n\t\t}\n\telse {\n\t\tsprintf( KeyName, \"%s\\\\Commands\", TEXT(PUTTY_REG_POS) ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 0 ) ;\n\t\t\n\t\tmungestr( folder, buffer ) ;\n\t\tsprintf( KeyName, \"%s\\\\Folders\\\\%s\\\\Commands\", TEXT(PUTTY_REG_POS), buffer ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 1 ) ;\n\n\t\tmungestr( sessionname, buffer ) ;\n\t\tsprintf( KeyName, \"%s\\\\Sessions\\\\%s\\\\Commands\", TEXT(PUTTY_REG_POS), buffer ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 1 ) ;\n\t\t}\n\n\tif( GetMenuItemCount( menu ) > 0 )\n\t\tAppendMenu( m, MF_POPUP, (UINT_PTR)menu, \"&User Command\" ) ;\n\n\t}\n\nvoid ManageSpecialCommand( HWND hwnd, int menunum ) {\n\tchar buffer[4096] ;\n\tFILE *fp ;\n\tif( menunum < NB_MENU_MAX ) {\n\tif( SpecialMenu[menunum] != NULL ) \n\t\tif( strlen( SpecialMenu[menunum] ) > 0 ) {\n\t\t\tif( ( fp=fopen( SpecialMenu[menunum], \"r\") ) != NULL ) {\n\t\t\t\twhile( fgets( buffer, 4095, fp ) != NULL ) {\n\t\t\t\t\tSendKeyboardPlus( hwnd, buffer ) ;\n\t\t\t\t\t}\n\t\t\t\tfclose( fp ) ; \n\t\t\t\t}\n\t\t\telse SendKeyboardPlus( hwnd, SpecialMenu[menunum] ) ;\n\t\t\t}\n\t\t}\n\t}\n\nBOOL CALLBACK EnumWindowsProc( HWND hwnd, LPARAM lParam ) {\n\tchar buffer[256] ;\n\tGetClassName( hwnd, buffer, 256 ) ;\n\t\n\tif( (!strcmp( buffer, appname )) || (!strcmp( buffer, \"PuTTYConfigBox\" )) ) {\n\t\tNbWindows++ ;\n\t}\n\t\n\treturn TRUE ;\n}\n\n// Decompte le nombre de fenetre de la meme classe que KiTTY\nint WindowsCount( HWND hwnd ) {\n\tchar buffer[256] ;\n\tNbWindows = 0 ;\n\t\n\tif( GetClassName( hwnd, buffer, 256 ) == 0 ) {\n\t\tNbWindows = 1 ;\n\t} else {\n\t\tif( !strcmp( buffer, \"\" ) ) {\n\t\t\tNbWindows = 1 ;\n\t\t}\n\t}\n\n\tEnumWindows( EnumWindowsProc, 0 ) ;\n\treturn NbWindows ;\n}\n\n\t\n// Gestion de la fenetre d'affichage des portforward\n// Mettre la liste des port forward dans le presse-papier et l'afficher a l'ecran\n// [C] en Listen dans le process courant, [X] en listen dans un autre process, [-] absent\nDWORD (WINAPI *pGetExtendedTcpTable)(\n  PVOID pTcpTable,\n  PDWORD pdwSize,\n  BOOL bOrder,\n  ULONG ulAf,\n  TCP_TABLE_CLASS TableClass,\n  ULONG Reserved\n) ;\n\nint GetPortFwdState( const int port, const DWORD pid ) {\n\tint result = -1 ;\n\tMIB_TCPTABLE_OWNER_PID *pTCPInfo ;\n\tMIB_TCPROW_OWNER_PID *owner ;\n\tDWORD size ;\n\tDWORD dwResult ;\n\tDWORD dwLoop ;\n\t\n\tHMODULE hLib = LoadLibrary( \"iphlpapi.dll\" );\n\n\tif( hLib ) {\n\t\tpGetExtendedTcpTable = (DWORD (WINAPI *)(PVOID,PDWORD,BOOL,ULONG,TCP_TABLE_CLASS,ULONG)) \n\t\tGetProcAddress(hLib, \"GetExtendedTcpTable\") ;\n\t\tdwResult = pGetExtendedTcpTable(NULL, &size, 0, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0) ;\n\t\tpTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size) ;\n\t\tdwResult = pGetExtendedTcpTable(pTCPInfo, &size, 0, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0) ;\n\t\tif( pGetExtendedTcpTable && (dwResult == NO_ERROR) ) {\n\t\t\tif( pTCPInfo->dwNumEntries > 0 ) {\n\t\t\t\tfor (dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++) {\n\t\t\t\t\towner = &pTCPInfo->table[dwLoop];\n\t\t\t\t\tif ( owner->dwState == MIB_TCP_STATE_LISTEN ) {\n\t\t\t\t\t\tif( ntohs(owner->dwLocalPort) == port ) {\n\t\t\t\t\t\t\tif( pid == owner->dwOwningPid ) { \n\t\t\t\t\t\t\t\tresult = 0 ; \n\t\t\t\t\t\t\t} else { \n\t\t\t\t\t\t\t\tresult = owner->dwOwningPid ; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfree(pTCPInfo) ;\n\t\tFreeLibrary( hLib ) ;\n\t}\n\treturn result ;\n}\n\nint ShowPortfwd( HWND hwnd, Conf * conf ) {\n\tchar pf[2100]=\"\" ;\n\tchar *key, *val;\n\tfor (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key) ;\n\t\tval != NULL;\n\t\tval = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\t\tchar *p;\n\t\tif (( key[0]=='R' ) || ( key[1]=='R' )) {\n\t\t\tp = dupprintf(\"[-] %s \\t\\t<-- \\t%s\\n\", (key[1]=='R')? key+2 : key+1,val) ;\n\t\t} else if (( key[0]=='L' ) || ( key[1]=='L' )) {\n\t\t\tchar *key_pos = (key[1]=='L')? key+2 : key+1 ;\n\t\t\tint res ;\n\t\t\tswitch( res=GetPortFwdState( atoi(key_pos), GetCurrentProcessId() ) ) {\n\t\t\t\tcase -1:\n\t\t\t\t\tp = dupprintf(\"[-] %s \\t\\t--> \\t%s\\n\", key_pos,val) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase 0:\n\t\t\t\t\tp = dupprintf(\"[C] %s \\t\\t--> \\t%s\\n\", key_pos,val) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tdefault:\n\t\t\t\t\tp = dupprintf(\"[X] %s(%u)\\t--> \\t%s\\n\", key_pos,(unsigned int)res,val) ;\n\t\t\t}\n\t\t} else if (( key[0]=='D' ) || ( key[1]=='D' )) {\n\t\t\tp = dupprintf(\"D%s\\t\\n\", key+1) ;\n\t\t} else {\n\t\t\tp = dupprintf(\"%s\\t%s\\n\", key, val) ;\n\t\t}\n\t\tif( (strlen(pf)+strlen(p))<2000 ) {\n\t\t\tstrcat( pf, p ) ;\n\t\t\tsfree(p) ;\n\t\t} else {\n\t\t\tstrcat( pf, \"...\\n\" ) ;\n\t\t\tbreak ;\n\t\t}\n\t}\n\t/*\n\tMIB_TCPTABLE_OWNER_PID *pTCPInfo;\n\tMIB_TCPROW_OWNER_PID *owner;\n\tDWORD size;\n\tDWORD dwResult;\n\tDWORD dwLoop;\n\n\tHMODULE hLib = LoadLibrary( \"iphlpapi.dll\" );\n\n\tif( hLib ) {\n\t\tpGetExtendedTcpTable = (DWORD (WINAPI *)(PVOID,PDWORD,BOOL,ULONG,TCP_TABLE_CLASS,ULONG))\n\t\tGetProcAddress(hLib, \"GetExtendedTcpTable\");\n\t}\n\tdwResult = pGetExtendedTcpTable(NULL, &size, 0, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);\n\tpTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size);\n\tdwResult = pGetExtendedTcpTable(pTCPInfo, &size, 0, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);\n\n\tfor (val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key);\n\t\tval != NULL;\n\t\tval = conf_get_str_strs(conf, CONF_portfwd, key, &key)) {\n\t\tchar *p;\n\t\t\n\t\tif (( key[0]=='R' ) || ( key[1]=='R' )) {\n\t\t\tp = dupprintf(\"[-] %s \\t\\t<-- \\t%s\\n\", (key[1]=='R')? key+2 : key+1,val);\n\t\t} else if (( key[0]=='L' ) || ( key[1]=='L' )) {\n\t\t\tchar *key_pos = (key[1]=='L')? key+2 : key+1;\n\t\t\tif( pGetExtendedTcpTable && (dwResult == NO_ERROR) ) {\n\t\t\t\tint found=0 ;\n\t\t\t\tif( pTCPInfo->dwNumEntries > 0 ) {\n\t\t\t\t\tfor (dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++) {\n\t\t\t\t\t\towner = &pTCPInfo->table[dwLoop];\n\t\t\t\t\t\tif ( owner->dwState == MIB_TCP_STATE_LISTEN ) {\n\t\t\t\t\t\t\tif( ntohs(owner->dwLocalPort) == atoi(key_pos) ) {\n\t\t\t\t\t\t\t\tif( GetCurrentProcessId() == owner->dwOwningPid ) p = dupprintf(\"[C] %s \\t\\t--> \\t%s\\n\", key_pos,val);\n\t\t\t\t\t\t\t\telse p = dupprintf(\"[X] %s(%u)\\t--> \\t%s\\n\", key_pos,(unsigned int)owner->dwOwningPid,val) ;\n\t\t\t\t\t\t\t\tfound=1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( !found ) { p = dupprintf(\"[-] %s \\t\\t--> \\t%s\\n\", key_pos,val); }\n\t\t\t} else {\n\t\t\t\tp = dupprintf(\"[-] %s \\t\\t--> \\t%s\\n\", key_pos,val);\n\t\t\t}\n\t\t} else if (( key[0]=='D' ) || ( key[1]=='D' )) {\n\t\t\tp = dupprintf(\"D%s\\t\\n\", key+1) ;\n\t\t} else {\n\t\t\tp = dupprintf(\"%s\\t%s\\n\", key, val) ;\n\t\t}\n\t\t\n\t\tstrcat( pf, p ) ;\n\t\tsfree(p);\n\t}\n\t\n\tif( hLib ) { FreeLibrary( hLib ) ; }\n\t*/\n\tstrcat( pf, \"\\n[C] Listening in the current process\\n[X] Listening in another process\\n[-] No Listening\\n\" );\n\tMessageBox( NULL, pf, \"Port forwarding\", MB_OK ) ;\n\treturn SetTextToClipboard( pf ) ;\n}\n\t\nvoid SaveCurrentSetting( HWND hwnd ) {\n\tchar filename[4096], buffer[4096] ;\n\tif( strlen(FileExtension)>0 ) {\n\t\tstrcpy( buffer, \"Connection files (*\" ) ;\n\t\tstrcat( buffer, FileExtension ) ; strcat( buffer, \")|*\" ) ;\n\t\tstrcat( buffer, FileExtension ) ; strcat( buffer, \"|\" ) ;\n\t} else {\n\t\tstrcpy( buffer, \"Connection files (*.ktx)|*.ktx|\" ) ;\n\t}\n\tstrcat( buffer, \"All files (*.*)|*.*|\" ) ;\n\tif( buffer[strlen(buffer)-1]!='|' ) strcat( buffer, \"|\" ) ;\n\tif( SaveFileName( hwnd, filename, \"Save file...\", buffer ) ) {\n\t\tsave_open_settings_forced( filename, conf ) ;\n\t\t}\n\t}\n\n// Procedures de generation du dump \"memoire\" (/savedump)\n#ifdef MOD_SAVEDUMP\n#include \"kitty_savedump.c\"\n#endif\nvoid InitShortcuts( void ) ;\n\nint InternalCommand( HWND hwnd, char * st ) {\n\tchar buffer[4096] ;\n\tif( strstr( st, \"/message \" ) == st ) { \n\t\tMessageBox( hwnd, st+9, \"Info\", MB_OK ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/copytoputty\" ) ) {\n\t\tRegDelTree (HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\" ) ;\n\t\tsprintf( buffer, \"%s\\\\Sessions\", PUTTY_REG_POS ) ;\n\t\tRegCopyTree( HKEY_CURRENT_USER, buffer, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\" ) ;\n\t\tsprintf( buffer, \"%s\\\\SshHostKeys\", PUTTY_REG_POS ) ;\n\t\tRegCopyTree( HKEY_CURRENT_USER, buffer, \"Software\\\\SimonTatham\\\\PuTTY\\\\SshHostKeys\" ) ;\n\t\tRegCleanPuTTY() ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/copytokitty\" ) ) {\n\t\tRegCopyTree( HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\", PUTTY_REG_POS ) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/backgroundimage\" ) ) { \n\t\tSetBackgroundImageFlag( abs( GetBackgroundImageFlag() - 1 ) ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/debug\" ) ) { \n\t\tdebug_flag = abs( debug_flag - 1 ) ; \n\t\treturn 1 ;\n#ifdef MOD_HYPERLINK\n\t} else if( !strcmp( st, \"/hyperlink\" ) ) { \n\t\tHyperlinkFlag = abs( HyperlinkFlag - 1 ) ; \n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/urlregex\" ) ) { \n\t\tchar b[1024] ;\n\t\tsprintf(b,\"%d: %s\",conf_get_int(conf,CONF_url_defregex),conf_get_str(conf,CONF_url_regex));\n\t\tMessageBox( NULL, b, \"URL regex\", MB_OK ) ; return 1 ; \n#endif\n\t} else if( !strcmp( st, \"/save\" ) ) { \n\t\tSaveCurrentSetting(hwnd);\n\t\treturn 1 ; \n#ifdef MOD_SAVEDUMP\n\t} else if( !strcmp( st, \"/savedump\" ) ) { SaveDump() ; return 1 ; \n#endif\n\t} else if( !strcmp( st, \"/screenshot\" ) ) { \n\t\tchar screenShotFile[1024] ;\n\t\tsprintf( screenShotFile, \"%s\\\\screenshot-%d-%ld.jpg\", InitialDirectory, getpid(), time(0) );\n\t\tscreenCaptureClientRect( GetParent(hwnd), screenShotFile, 100 ) ;\n\t\t//screenCaptureWinRect( GetParent(hwnd), screenShotFile, 100 ) ;\n\t\t//screenCaptureAll( screenShotFile, 100 ) ;\n\t\t//MakeScreenShot() ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/fileassoc\" ) ) { \n\t\tCreateFileAssoc() ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/savereg\" ) ) {\n\t\tchdir( InitialDirectory ) ; \n\t\tSaveRegistryKey() ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/savesessions\" ) ) { \n\t\tchdir( InitialDirectory ) ; \n\t\tsprintf( buffer, \"%s\\\\Sessions\", PUTTY_REG_POS ) ;\n\t\tSaveRegistryKeyEx( HKEY_CURRENT_USER, buffer, \"kitty.ses\" ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/loadinitscript\" ) ) { \n\t\tReadInitScript( NULL ) ; \n\t\treturn 1 ; \n\t} else if( strstr( st, \"/loadinitscript \" ) == st ) { \n\t\tReadInitScript( st+16 ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/loadreg\" ) ) { \n\t\tchdir( InitialDirectory ) ; \n\t\tLoadRegistryKey(NULL) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/delreg\" ) ) { \n\t\tRegDelTree (HKEY_CURRENT_USER, TEXT(PUTTY_REG_PARENT)) ; \n\t\treturn 1 ; \n\t} else if( strstr( st, \"/delfolder \" ) == st ) { \n\t\tStringList_Del( FolderList, st+11 ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/noshortcuts\" ) ) { \n\t\tShortcutsFlag = 0 ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/nomouseshortcuts\" ) ) { \n\t\tMouseShortcutsFlag = 0 ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/icon\" ) ) { \n\t\t//sprintf( buffer, \"%d / %d = %d\", IconeNum, NB_ICONES, NumberOfIcons );\n\t\t//MessageBox( hwnd, buffer, \"info\", MB_OK ) ;\n\t\tIconeFlag = abs( IconeFlag - 1 ) ; conf_set_int(conf,CONF_icone,IconeNum) ; return 1 ; \n\t} else if( !strcmp( st, \"/savemode\" ) ) {\n\t\t//IniFileFlag = abs( IniFileFlag - 1 ) ;\n\t\tIniFileFlag++ ; if( IniFileFlag>SAVEMODE_DIR ) IniFileFlag = 0 ;\n\t\tif( IniFileFlag == SAVEMODE_REG )  {\n\t\t\tdelINI( KittyIniFile, INIT_SECTION, \"savemode\" ) ;\n\t\t\tMessageBox( NULL, \"Savemode is \\\"registry\\\"\", \"Info\", MB_OK ) ;\n\t\t} else if( IniFileFlag == SAVEMODE_FILE ) {\n\t\t\tif(!NoKittyFileFlag) writeINI( KittyIniFile, INIT_SECTION, \"savemode\", \"file\" ) ;\n\t\t\tMessageBox( NULL, \"Savemode is \\\"file\\\"\", \"Info\", MB_OK ) ;\n\t\t} else if( IniFileFlag == SAVEMODE_DIR ) {\n\t\t\tdelINI( KittyIniFile, INIT_SECTION, \"savemode\" ) ;\n\t\t\tMessageBox( NULL, \"Savemode is \\\"dir\\\"\", \"Info\", MB_OK ) ;\n\t\t}\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/capslock\" ) ) { \n\t\tCapsLockFlag = abs( CapsLockFlag - 1 ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/init\" ) ) { \n\t\tchar buffer[4096] ;\n\t\tsprintf( buffer,\"ConfigDirectory=%s\\nIniFileFlag=%d\\nDirectoryBrowseFlag=%d\\nInitialDirectory=%s\\nKittyIniFile=%s\\nKittySavFile=%s\\nKiTTYClassName=%s\\n\"\n\t\t\t,ConfigDirectory,IniFileFlag,DirectoryBrowseFlag,InitialDirectory,KittyIniFile,KittySavFile,KiTTYClassName ) ;\n\t\tMessageBox(hwnd,buffer,\"Configuration infomations\",MB_OK);\n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/capslock\" ) ) { \n\t\tconf_set_int( conf, CONF_xpos, 10 ) ;\n\t\tconf_set_int( conf, CONF_ypos, 10 ) ;\n\t\tSetWindowPos( hwnd, 0, 10, 10, 0, 0, SWP_NOSIZE|SWP_NOZORDER|SWP_NOOWNERZORDER|SWP_NOACTIVATE ) ;\n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/size\" ) ) { \n\t\tSizeFlag = abs( SizeFlag - 1 ) ; \n\t\tset_title( NULL, conf_get_str(conf,CONF_wintitle) ) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/transparency\" ) ) {\n#ifndef MOD_NOTRANSPARENCY\n\t\tif( (conf_get_int(conf,CONF_transparencynumber) == -1) || (TransparencyFlag == 0 ) ) {\n\t\t\tTransparencyFlag = 1 ;\n\t\t\tSetWindowLongPtr(MainHwnd, GWL_EXSTYLE, GetWindowLong(MainHwnd, GWL_EXSTYLE) | WS_EX_LAYERED ) ;\n\t\t\tSetWindowPos( MainHwnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER ) ;\n\t\t\tif( conf_get_int(conf,CONF_transparencynumber) == -1 ) conf_set_int(conf,CONF_transparencynumber,0) ; \n\t\t\tSetTransparency( MainHwnd, 255-conf_get_int(conf,CONF_transparencynumber) ) ;\n\t\t\tSetForegroundWindow( hwnd ) ;\n\t\t} else {\n\t\t\tTransparencyFlag = 0 ;\n\t\t\tSetTransparency( MainHwnd, 255 ) ;\n\t\t\tSetWindowLongPtr(MainHwnd, GWL_EXSTYLE, GetWindowLong(hwnd, GWL_EXSTYLE) & ~WS_EX_LAYERED ) ;\n\t\t\tRedrawWindow(MainHwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);\n\t\t\tSetWindowPos( MainHwnd, 0, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER ) ;\n\t\t\tSetForegroundWindow( hwnd ) ;\n\t\t}\n#endif\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/bcdelay\" ) ) {\n\t\tbetween_char_delay=3 ;\n\t\treturn 1 ; \n\t} else if( strstr( st, \"/bcdelay \" ) == st ) { \n\t\tbetween_char_delay=atoi( st+9 ) ; \n\t\treturn 1 ; \n\t} else if( strstr( st, \"/title \" ) == st ) { \n\t\tset_title( NULL, st+7 ) ; \n\t\treturn 1 ; \n\t} else if( !strcmp( st, \"/session\" ) ) {\n\t\tif( strlen( conf_get_str(conf,CONF_sessionname) ) > 0 ) {\n\t\t\tchar buffer[1024] ;\n\t\t\tsprintf( buffer, \"Your session name is\\n-%s-\", conf_get_str(conf,CONF_sessionname) ) ;\n\t\t\tMessageBox( hwnd, buffer, \"Session name\", MB_OK|MB_ICONWARNING ) ;\n\t\t} else\n\t\t\tMessageBox( hwnd, \"No session name.\", \"Session name\", MB_OK|MB_ICONWARNING ) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/passwd\" ) && debug_flag ) {\n\t\tif( strlen( conf_get_str(conf,CONF_password) ) > 0 ) {\n\t\t\tchar bufpass[4096], buffer[4096] ;\n\t\t\tstrcpy( bufpass, conf_get_str(conf,CONF_password) ) ;\n\t\t\tMASKPASS(GetCryptSaltFlag(),bufpass);\n\t\t\tsprintf( buffer, \"Your password is\\n-%s-\", bufpass ) ;\n\t\t\tSetTextToClipboard( bufpass ) ;\n\t\t\tmemset(bufpass,0,strlen(bufpass));\n\t\t\tMessageBox( hwnd, buffer, \"Password\", MB_OK|MB_ICONWARNING ) ;\n\t\t\tmemset(buffer,0,strlen(buffer));\n\t\t} else\n\t\t\tMessageBox( hwnd, \"No password.\", \"Password\", MB_OK|MB_ICONWARNING ) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/configpassword\" ) ) {\n\t\tstrcpy( PasswordConf, \"\" ) ;\n\t\tRegDelValue( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), \"password\" ) ;\n\t\tdelINI( KittyIniFile, INIT_SECTION, \"password\" ) ;\n\t\tSaveRegistryKey() ;\n\t\tMessageBox( NULL, \"At next launch,\\ndon't forget to check your configuration save mode\\n(file or registry ?)\", \"Info\", MB_OK );\n\t\treturn 1 ;\n\t} else if( strstr( st, \"/configpassword \" ) == st ) {\n\t\tstrcpy( PasswordConf, st+16 ) ;\n\t\tif( strlen(PasswordConf) > 0 ) {\n\t\t\tstrcpy( buffer, PasswordConf ) ;\n\t\t\tWriteParameter( INIT_SECTION, \"password\", PasswordConf ) ;\n\t\t\tSaveRegistryKey() ;\n\t\t\tcryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ;\n\t\t\t// On passe automatiquement en mode de sauvegarde par fichier\n\t\t\tif(!NoKittyFileFlag) writeINI( KittyIniFile, INIT_SECTION, \"savemode\", \"file\" ) ;\n\t\t\tIniFileFlag = SAVEMODE_FILE ;\n\t\t\tif(!NoKittyFileFlag) writeINI( KittyIniFile, INIT_SECTION, \"password\", buffer ) ;\n\t\t}\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/-configpassword\" ) ) {\n\t\tif( ReadParameter( INIT_SECTION, \"password\", buffer ) ) {\n\t\t\tif( decryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ) {\n\t\t\t\tMessageBox( hwnd, buffer, \"Your password is ...\", MB_OK|MB_ICONWARNING ) ;\n\t\t\t}\n\t\t}\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/shortcuts\" ) ) {\n\t\tInitShortcuts() ; \n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/switchcrypt\" ) ) {\n\t\tSwitchCryptFlag() ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/redraw\" ) ) {\n\t\tInvalidateRect( MainHwnd, NULL, TRUE ) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/refresh\" ) ) {\n\t\tRefreshBackground( MainHwnd ) ;\n\t\treturn 1 ;\n\t} else if( strstr( st, \"/PrintCharSize \" ) == st ) {\n\t\tPrintCharSize=atoi( st+15 ) ;\n\t\treturn 1 ;\n\t} else if( strstr( st, \"/PrintMaxLinePerPage \" ) == st ) { \n\t\tPrintMaxLinePerPage=atoi( st+21 ) ;\n\t\treturn 1 ;\n\t} else if( strstr( st, \"/PrintMaxCharPerLine \" ) == st ) {\n\t\tPrintMaxCharPerLine=atoi( st+21 ) ;\n\t\treturn 1 ;\n#ifdef MOD_LAUNCHER\n\t} else if( !strcmp( st, \"/initlauncher\" ) ) {\n\t\tInitLauncherRegistry() ;\n\t\treturn 1 ; \n#endif\n\t} else if( !strcmp( st, \"/winroll\" ) ) { \n\t\tWinrolFlag = abs(WinrolFlag-1) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/wintitle\" ) ) { \n\t\tTitleBarFlag = abs(TitleBarFlag-1) ; \n\t\treturn 1 ;\n\t} else if( strstr( st, \"/command \" ) == st ) {\n\t\tSendCommandAllWindows( hwnd, st+9 ) ;\n\t\treturn 1 ;\n\t} else if( !strcmp( st, \"/sizeall\" ) ) {\n\t\tResizeWinList( hwnd, conf_get_int(conf,CONF_width), conf_get_int(conf,CONF_height) ) ; \n\t\treturn 1 ;\n#ifdef MOD_ZMODEM\n\t} else if( !strcmp( st, \"/zmodem\" ) ) {\n\t\tSetZModemFlag( abs(GetZModemFlag()-1) ) ; \n#endif\n\t}\n\treturn 0 ;\n}\n\n\n// Recherche le chemin vers le programme cthelper.exe\nint SearchCtHelper( void ) {\n\tchar buffer[4096] ;\n\tif( CtHelperPath!=NULL ) { \n\t\tfree(CtHelperPath) ; \n\t\tCtHelperPath=NULL ; \n\t}\n\tif( ReadParameter( INIT_SECTION, \"CtHelperPath\", buffer ) != 0 ) {\n\t\tif( existfile( buffer ) ) { \n\t\t\tCtHelperPath = (char*) malloc( strlen(buffer) + 1 ) ; \n\t\t\tstrcpy( CtHelperPath, buffer ) ; \n\t\t\tset_env( \"CTHELPER_PATH\", CtHelperPath ) ;\n\t\t\treturn 1 ;\n\t\t} else { \n\t\t\tDelParameter( INIT_SECTION, \"CtHelperPath\" ) ; \n\t\t}\n\t}\n\tsprintf( buffer, \"%s\\\\cthelper.exe\", InitialDirectory ) ;\n\tif( existfile( buffer ) ) { \n\t\tCtHelperPath = (char*) malloc( strlen(buffer) + 1 ) ; \n\t\tstrcpy( CtHelperPath, buffer ) ; \n\t\tset_env( \"CTHELPER_PATH\", CtHelperPath) ;\n\t\tWriteParameter( INIT_SECTION, \"CtHelperPath\", CtHelperPath ) ;\n\t\treturn 1 ;\n\t}\n\treturn 0 ;\n}\n\t\n// Recherche le chemin vers le programme WinSCP\nint SearchWinSCP( void ) {\n\tchar buffer[4096] ;\n\tif( WinSCPPath!=NULL) { free(WinSCPPath) ; WinSCPPath = NULL ; }\n\tif( ReadParameter( INIT_SECTION, \"WinSCPPath\", buffer ) != 0 ) {\n\t\tif( existfile( buffer ) ) { \n\t\t\tWinSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( WinSCPPath, buffer ) ; \n\t\t\treturn 1 ;\n\t\t} else { \n\t\t\tDelParameter( INIT_SECTION, \"WinSCPPath\" ) ; \n\t\t}\n\t}\n\t//strcpy( buffer, \"C:\\\\Program Files\\\\WinSCP\\\\WinSCP.exe\" ) ;\n\tsprintf( buffer, \"%s\\\\WinSCP\\\\WinSCP.exe\", getenv(\"ProgramFiles\") ) ;\n\tif( existfile( buffer ) ) { \n\t\tWinSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( WinSCPPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"WinSCPPath\", WinSCPPath ) ;\n\t\treturn 1 ;\n\t}\n\t//strcpy( buffer, \"C:\\\\Program Files\\\\WinSCP3\\\\WinSCP3.exe\" ) ;\n\tsprintf( buffer, \"%s\\\\WinSCP3\\\\WinSCP3.exe\", getenv(\"ProgramFiles\") ) ;\n\tif( existfile( buffer ) ) { \n\t\tWinSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( WinSCPPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"WinSCPPath\", WinSCPPath ) ;\n\t\treturn 1 ;\n\t}\n\tsprintf( buffer, \"%s\\\\WinSCP.exe\", InitialDirectory ) ;\n\tif( existfile( buffer ) ) { \n\t\tWinSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( WinSCPPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"WinSCPPath\", WinSCPPath ) ;\n\t\treturn 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"winscpdir\", buffer ) ) {\n\t\tbuffer[4076]='\\0';\n\t\tstrcat( buffer, \"\\\\\" ) ; strcat( buffer, \"WinSCP.exe\" ) ;\n\t\tif( existfile( buffer ) ) { \n\t\t\tWinSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( WinSCPPath, buffer ) ; \n\t\t\tWriteParameter( INIT_SECTION, \"WinSCPPath\", WinSCPPath ) ;\n\t\t\treturn 1 ;\n\t\t}\n\t}\n\treturn 0 ;\n}\n\n// Lance WinSCP à partir de la sesson courante eventuellement dans le repertoire courant\n/* ALIAS UNIX A DEFINIR POUR DEMARRER WINSCP Dans le repertoire courant\nwinscp()\n{\necho \"\\033]0;__ws:\"`pwd`\"\\007\"\n}\nIl faut ensuite simplement taper: winscp\nC'est traite dans KiTTY par la fonction ManageLocalCmd\n\nLe chemin vers l'exécutable WinSCP est défini dans la variable WInSCPPath. Elle peut pointer sur un fichier .BAT pour passer des options supplémentaires.\n@ECHO OFF\nstart \"C:\\Program Files\\WinSCP\\WinSCP.exe\" \"%1\" \"%2\" \"%3\" \"%4\" \"%5\" \"%6\" \"%7\" \"%8\" \"%9\"\n*/\t\n// winscp.exe [(sftp|ftp|scp)://][user[:password]@]host[:port][/path/[file]] [/privatekey=key_file] [/rawsettings (ProxyMethod=1) (Compression=1)]\nvoid StartWinSCP( HWND hwnd, char * directory, char * host, char * user ) {\n\tchar cmd[4096], shortpath[1024], buffer[4096], proto[10] ;\n\tint raw = 0;\n\t\n\tif( directory == NULL ) { directory = kitty_current_dir(); } \n\tif( WinSCPPath==NULL ) {\n\t\tif( IniFileFlag == SAVEMODE_REG ) return ;\n\t\telse if( !SearchWinSCP() ) return ;\n\t}\n\tif( !existfile( WinSCPPath ) ) {\n\t\tif( IniFileFlag == SAVEMODE_REG ) return ;\n\t\telse if( !SearchWinSCP() ) return ;\n\t}\n\t\t\n\tif( !GetShortPathName( WinSCPPath, shortpath, 4095 ) ) return ;\n\n\tswitch( conf_get_int(conf, CONF_winscpprot) ) {\n\t\tcase 0: strcpy( proto, \"scp\" ) ; break ;\n\t\tcase 2: strcpy( proto, \"ftp\" ) ; break ;\n\t\tcase 3: strcpy( proto, \"ftps\" ) ; break ;\n\t\tcase 4: strcpy( proto, \"ftpes\" ) ; break ;\n\t\tcase 5: strcpy( proto, \"http\" ) ; break ;\n\t\tcase 6: strcpy( proto, \"https\" ) ; break ;\n\t\tdefault: strcpy( proto, \"sftp\" ) ;\n\t}\n\t\n\tif( conf_get_int(conf,CONF_protocol) == PROT_SSH ) {\n\t\tsprintf( cmd, \"\\\"%s\\\" %s://\", shortpath, proto ) ;\n\t\t\t\n\t\tif( strlen( conf_get_str(conf, CONF_sftpconnect) ) > 0 ) {\n\t\t\tstrcat( cmd, conf_get_str(conf, CONF_sftpconnect) ) ;\n\t\t} else {\n\t\t\tif( user!=NULL ) {\n\t\t\t\tstrcat( cmd, user ) ; \n\t\t\t} else { \n\t\t\t\tstrcat( cmd, conf_get_str(conf,CONF_username) ) ; \n\t\t\t}\n\t\t\tif( strlen( conf_get_str(conf,CONF_password) ) > 0 ) { \n\t\t\t\tchar bufpass[1024] ;\n\t\t\t\tstrcat( cmd, \":\" ); \n\t\t\t\tstrcpy(bufpass,conf_get_str(conf,CONF_password));\n\t\t\t\tMASKPASS(GetCryptSaltFlag(),bufpass);\n\t\t\t\tstrcat(cmd,bufpass);\n\t\t\t\tmemset(bufpass,0,strlen(bufpass));\n\t\t\t}\n\t\t\tstrcat( cmd, \"@\" ) ; \n\t\t\tif( host!=NULL ) {\n\t\t\t\tstrcat( cmd, host ) ; \n\t\t\t} else {\n\t\t\t\tstrcat( cmd, conf_get_str(conf,CONF_host) ) ; \n\t\t\t}\n\t\t\tstrcat( cmd, \":\" ) ; sprintf( buffer, \"%d\", conf_get_int(conf,CONF_port) ); strcat( cmd, buffer ) ;\n\t\t}\n\t\t\n\t\tif( directory!=NULL ) if( strlen(directory)>0 ) {\n\t\t\tstrcat( cmd, directory ) ;\n\t\t\tif( directory[strlen(directory)-1]!='/' ) strcat( cmd, \"/\" ) ;\n\t\t}\n\t\tif( strlen( conf_get_filename(conf,CONF_keyfile)->path ) > 0 ) {\n\t\t\tif( GetShortPathName( conf_get_filename(conf,CONF_keyfile)->path, shortpath, 4095 ) ) {\n\t\t\t\tstrcat( cmd, \" \\\"/privatekey=\" ) ;\n\t\t\t\tstrcat( cmd, shortpath ) ;\n\t\t\t\tstrcat( cmd, \"\\\"\" ) ;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsprintf( cmd, \"\\\"%s\\\" %s://%s\", shortpath, proto, conf_get_str(conf,CONF_username) ) ;\n\t\tif( strlen( conf_get_str(conf,CONF_password) ) > 0 ) {\n\t\t\tchar bufpass[1024] ;\n\t\t\tstrcat( cmd, \":\" ); \n\t\t\tstrcpy(bufpass,conf_get_str(conf,CONF_password));\n\t\t\tMASKPASS(GetCryptSaltFlag(),bufpass);\n\t\t\tstrcat(cmd,bufpass);\n\t\t\tmemset(bufpass,0,strlen(bufpass));\n\t\t}\n\t\tstrcat( cmd, \"@\" ) ; \n\t\tif( poss( \":\", conf_get_str(conf,CONF_host) )>0 ) { strcat( cmd, \"[\" ) ; strcat( cmd, conf_get_str(conf,CONF_host) ) ; strcat( cmd, \"]\" ) ; }\n\t\telse { strcat( cmd, conf_get_str(conf,CONF_host) ) ; }\n\t\tstrcat( cmd, \":21\" ) ;\n\t\tif( directory!=NULL ) if( strlen(directory)>0 ) {\n\t\t\tstrcat( cmd, directory ) ;\n\t\t\tif( directory[strlen(directory)-1]!='/' ) strcat( cmd, \"/\" ) ;\n\t\t}\n\t}\n\t\n\tif( strlen(conf_get_str(conf, CONF_winscpoptions))>0 ) {\n\t\tstrcat( cmd, \" \" ) ; strcat( cmd, conf_get_str(conf, CONF_winscpoptions) ) ;\n\t}\n\t\n\tif( (conf_get_int(conf,CONF_proxy_type) != PROXY_NONE) && (strlen( conf_get_str(conf, CONF_sftpconnect) )==0) ) {\n\t\tif( raw == 0 ) { strcat( cmd, \" /rawsettings\" ) ; raw++ ; }\n\t\tswitch( conf_get_int(conf,CONF_proxy_type) ) {\n\t\t\tcase 2: strcat( cmd, \" ProxyMethod=2\" ) ; break ;\n\t\t\tcase 3: strcat( cmd, \" ProxyMethod=3\" ) ; break ;\n\t\t\tcase 4: strcat( cmd, \" ProxyMethod=4\" ) ; break ;\n\t\t\tcase 5: strcat( cmd, \" ProxyMethod=5\" ) ; break ;\n\t\t\tdefault: strcat( cmd, \" ProxyMethod=1\" ) ; break ;\n\t\t}\n\t\tif( strlen(conf_get_str(conf,CONF_proxy_host))>0 ) { strcat( cmd, \" ProxyHost=\" ) ; strcat( cmd, conf_get_str(conf,CONF_proxy_host) ) ; }\n\t\tsprintf( buffer, \" ProxyPort=%d\", conf_get_int(conf,CONF_proxy_port)) ; strcat( cmd, buffer ) ;\n\t\tif( strlen(conf_get_str(conf,CONF_proxy_username))>0 ) { strcat( cmd, \" ProxyUsername=\" ) ; strcat( cmd, conf_get_str(conf,CONF_proxy_username) ) ; }\n\t\tif( strlen(conf_get_str(conf,CONF_proxy_password))>0 ) { strcat( cmd, \" ProxyPassword=\" ) ; strcat( cmd, conf_get_str(conf,CONF_proxy_password) ) ; }\n\t\tif( strlen(conf_get_str(conf,CONF_proxy_telnet_command))>0 ) { strcat( cmd, \" ProxyTelnetCommand=\\\"\" ) ; strcat( cmd, conf_get_str(conf,CONF_proxy_telnet_command) ) ; strcat( cmd, \"\\\"\") ; }\n\t}\n\t\n\tif( conf_get_bool(conf,CONF_compression) ) {\n\t\tif( raw == 0 ) { strcat( cmd, \" /rawsettings\" ) ; raw++ ; }\n\t\tstrcat( cmd, \" Compression=1\" ) ;\n\t}\n\t\n\tif( conf_get_bool(conf, CONF_agentfwd) ) {\n\t\tif( raw == 0 ) { strcat( cmd, \" /rawsettings\" ) ; raw++ ; }\n\t\tstrcat( cmd, \" AgentFwd=1\" ) ;\n\t}\n\t\n\tif( strlen(conf_get_str(conf, CONF_winscprawsettings))>0 ) {\n\t\tif( raw == 0 ) { strcat( cmd, \" /rawsettings\" ) ; raw++ ; }\n\t\tstrcat( cmd, \" \" ) ; strcat( cmd, conf_get_str(conf, CONF_winscprawsettings) ) ;\n\t}\n\t\n\tif( !strcmp(proto,\"scp\") && (strlen(conf_get_str(conf, CONF_pscpshell))>0) ) {\n\t\tif( raw == 0 ) { strcat( cmd, \" /rawsettings\" ) ; raw++ ; }\n\t\tstrcat( cmd, \" \" ) ; strcat( cmd, \"Shell=\\\"\" ) ; strcat( cmd, conf_get_str(conf, CONF_pscpshell) ) ; strcat( cmd, \"\\\"\" ) ;\n\t}\n\t\n\tif( debug_flag ) { debug_logevent( \"Start WinSCP: %s\", cmd ) ; }\n\tRunCommand( hwnd, cmd ) ;\n\tmemset(cmd,0,strlen(cmd));\n}\n\n\t\n// Recherche le chemin vers le programme PSCP\nint SearchPSCP( void ) {\n\tchar buffer[4096], ki[10]=\"kscp.exe\", pu[10]=\"pscp.exe\" ;\n\n\tif( PSCPPath!=NULL ) { free(PSCPPath) ; PSCPPath = NULL ; }\n\t// Dans la base de registre\n\tif( ReadParameter( INIT_SECTION, \"PSCPPath\", buffer ) != 0 ) {\n\t\tif( existfile( buffer ) ) { \n\t\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ; return 1 ;\n\t\t} else { \n\t\t\tDelParameter( INIT_SECTION, \"PSCPPath\" ) ; \n\t\t}\n\t}\n\n\t// Dans le fichier ini\n\tif( ReadParameter( INIT_SECTION, \"pscpdir\", buffer ) ) {\n\t\tbuffer[4076]='\\0';\n\t\tstrcat( buffer, \"\\\\\" ) ; strcat( buffer, ki ) ;\n\t\tif( existfile( buffer ) ) { \n\t\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ; \n\t\t\tWriteParameter( INIT_SECTION, \"PSCPPath\", PSCPPath ) ;\n\t\t\treturn 1 ;\n\t\t} else {\n\t\t\tReadParameter( INIT_SECTION, \"pscpdir\", buffer ) ;\n\t\t\tbuffer[4076]='\\0';\n\t\t\tstrcat( buffer, \"\\\\\" ) ; strcat( buffer, pu ) ;\n\t\t\tif( existfile( buffer ) ) { \n\t\t\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ; \n\t\t\t\tWriteParameter( INIT_SECTION, \"PSCPPath\", PSCPPath ) ;\n\t\t\t\treturn 1 ;\n\t\t\t}\n\t\t}\n\t}\n#ifndef FLJ\n\t// kscp dans le meme repertoire\n\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, ki ) ;\n\tif( existfile( buffer ) ) { \n\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"PSCPPath\", PSCPPath ) ;\n\t\treturn 1 ;\n\t}\n#endif\n\t// pscp dans le repertoire normal de PuTTY\n\tsprintf( buffer, \"%s\\\\PuTTY\\\\%s\", getenv(\"ProgramFiles\"), pu ) ;\n\tif( existfile( buffer ) ) { \n\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"PSCPPath\", PSCPPath ) ;\n\t\treturn 1 ;\n\t}\n\n\t// pscp dans le meme repertoire\n\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, pu ) ;\n\tif( existfile( buffer ) ) { \n\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"PSCPPath\", PSCPPath ) ;\n\t\treturn 1 ;\n\t}\n\n\treturn 0 ;\n}\n\t\n// Recherche le chemin vers le programme Plink.exe\nint SearchPlink( void ) {\n\tchar buffer[4096], ki[10]=\"klink.exe\", pu[10]=\"plink.exe\" ;\n\n\tif( PlinkPath!=NULL ) { free(PlinkPath) ; PlinkPath = NULL ; }\n\t// Dans la base de registre\n\tif( ReadParameter( INIT_SECTION, \"PlinkPath\", buffer ) != 0 ) {\n\t\tbuffer[4076]='\\0';\n\t\tif( existfile( buffer ) ) { \n\t\t\tPlinkPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PlinkPath, buffer ) ; return 1 ;\n\t\t} else { \n\t\t\tDelParameter( INIT_SECTION, \"PlinkPath\" ) ; \n\t\t}\n\t}\n\n#ifndef FLJ\n\t// klink dans le meme repertoire\n\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, ki ) ;\n\tif( existfile( buffer ) ) { \n\t\tPlinkPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PlinkPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"PlinkPath\", PlinkPath ) ;\n\t\treturn 1 ;\n\t}\n#endif\n\n\t// plink dans le repertoire normal de PuTTY\n\tsprintf( buffer, \"%s\\\\PuTTY\\\\%s\", getenv(\"ProgramFiles\"), pu ) ;\n\tif( existfile( buffer ) ) { \n\t\tPlinkPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PlinkPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"PlinkPath\", PlinkPath ) ;\n\t\treturn 1 ;\n\t}\n\n\t// plink dans le meme repertoire\n\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, pu ) ;\n\tif( existfile( buffer ) ) { \n\t\tPlinkPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PlinkPath, buffer ) ; \n\t\tWriteParameter( INIT_SECTION, \"PlinkPath\", PlinkPath ) ;\n\t\treturn 1 ;\n\t}\n\t\n\treturn 0 ;\n}\n\t\n// Gestion du drap and drop\nvoid recupNomFichierDragDrop(HWND hwnd, HDROP* leDrop ) {\n        HDROP hDropInfo = *leDrop ;\n        int nb,taille,i;\n        taille=0;\n        nb=0;\n\tif( leDrop==NULL ) return ;\n        nb=DragQueryFile( hDropInfo, 0xFFFFFFFF, NULL, 0 ) ;\n        char *fic ;\n\tif( nb>0 ) for( i = 0; i < nb; i++ ) {\n                taille = DragQueryFile(hDropInfo, i, NULL, 0 )+1;\n\t\tfic = (char*)malloc(taille+1) ;\n                DragQueryFile( hDropInfo, i, fic, taille ) ;\n\t\tif( !strcmp( fic+strlen(fic)-10,\"\\\\kitty.ini\" ) ) { // On charge le fichier de config dans l'editeur interne\n\t\t\tchar buffer[1024]=\"\", shortname[1024]=\"\" ;\n\t\t\tif( GetModuleFileName( NULL, (LPTSTR)buffer, 1023 ) ) \n\t\t\t\tif( GetShortPathName( buffer, shortname, 1023 ) ) {\n\t\t\t\t\tsprintf( buffer, \"\\\"%s\\\" -ed %s\", shortname, fic ) ;\n\t\t\t\t\tRunCommand( hwnd, buffer ) ;\n\t\t\t\t}\n\t\t} else { \n\t\t\tif( conf_get_int( conf, CONF_scp_auto_pwd ) != 1 ) { SendOneFile( hwnd, \"\", fic, NULL ) ; }\n\t\t\telse { SendOneFile( hwnd, \"\", fic, RemotePath  ) ; }\n\t\t}\n\t\tfree(fic);\n\t}\n\tDragFinish(hDropInfo) ;  //vidage de la mem...\n        *leDrop = hDropInfo ;  //TOCHECK : transmistion de param...\n}\n\nvoid OnDropFiles(HWND hwnd, HDROP hDropInfo) {\n\tif( conf_get_int(conf,CONF_protocol) != PROT_SSH ) {\n\t\tMessageBox( hwnd, \"This function is only available with SSH connections.\", \"Error\", MB_OK|MB_ICONERROR ) ;\n\t\treturn ;\n\t}\n\tif( conf_get_int( conf, CONF_scp_auto_pwd ) != 1 ) { \n\t\trecupNomFichierDragDrop(hwnd, &hDropInfo) ; \n\t} else { \n\t\tif( RemotePath != NULL ) { free( RemotePath ) ; RemotePath = NULL ; }\n\t\tif( hDropInf != NULL ) { free(hDropInf) ; hDropInf = NULL ; }\n\t\tchar cmd[1024] = \"printf \\\"\\\\033]0;__pw:%s\\\\007\\\" `pwd`\\\\n\" ;\n\t\tif( AutoCommand != NULL ) { free(AutoCommand) ; AutoCommand = NULL ; }\n\t\tAutoCommand = (char*) malloc( strlen(cmd) + 10 ) ;\n\t\tstrcpy( AutoCommand, cmd );\n\t\tSetTimer(hwnd, TIMER_AUTOCOMMAND, autocommand_delay, NULL) ;\n\t\thDropInf = hDropInfo ;\n\t\tSetTimer(hwnd, TIMER_DND, dnd_delay, NULL) ;\n\t}\n}\n\n\t\n// Appel d'une DLL\n/*\ntypedef int (CALLBACK* LPFNDLLFUNC1)(int,char**); \nint calldll( HWND hwnd, char * filename, char * functionname ) {\n\tint return_code = 0 ;\n\tchar buffer[1024] ;\n\tHMODULE lphDLL ;               // Handle to DLL\n\tLPFNDLLFUNC1 lpfnDllFunc1 ;    // Function pointer\n\t\n\tlphDLL = LoadLibrary( TEXT(filename) ) ;\n\tif( lphDLL == NULL ) {\n\t\t//print_error( \"Unable to load library %s\\n\", filename ) ;\n\t\tsprintf( buffer, \"Unable to load library %s\\n\", filename ) ;\n\t\tMessageBox( hwnd, buffer, \"Error\" , MB_OK|MB_ICONERROR ) ;\n\t\treturn -1 ;\n\t\t}\n\t\t\n\tif( !( lpfnDllFunc1 = (LPFNDLLFUNC1) GetProcAddress( lphDLL, TEXT(functionname) ) ) ) {\n\t\t//print_error( \"Unable to load function %s from library %s (%d)\\n\", functionname, filename, GetLastError() );\n\t\tsprintf(buffer,\"Unable to load function %s from library %s (%d)\\n\", functionname, filename, (int)GetLastError() ) ;\n\t\tMessageBox( hwnd, buffer, \"Error\" , MB_OK|MB_ICONERROR ) ;\n\t\tFreeLibrary( lphDLL ) ;\n\t\treturn -1 ;\n\t\t}\n\t\n\tchar **tab ;\n\ttab=(char**)malloc( 10*sizeof(char* ) ) ;\n\tint i ;\n\tfor(i=0;i<10;i++) tab[i]=(char*)malloc(256) ;\n\tstrcpy( tab[0], \"pscp.exe\" ) ; \n\tstrcpy( tab[1], \"-2\" ) ;\n\tstrcpy( tab[2], \"-scp\" ) ;\n\tstrcpy( tab[3], \"c:\\\\tmp\\\\putty.exe\" ) ;\n\tstrcpy( tab[4], \"xxxxxx@xxxxxx.xxx.xx:.\" ) ;\n\tint tabn = 5 ;\n\t\t\n\treturn_code = (lpfnDllFunc1) ( tabn, tab ) ;\n\t\n\tfor(i=0;i<10;i++) free(tab[i]) ;\n\tfree(tab);\n\t\n\tFreeLibrary( lphDLL ) ;\n\t\n\treturn return_code ;\n\t}\n*/\n\n// Gestion du script au lancement\nvoid ManageInitScript( const char * input_str, const int len ) {\n\tint i, l ;\n\tchar * st = NULL ;\n\n\n\tif( ScriptFileContent==NULL ) return ;\n\tif( strlen( ScriptFileContent ) == 0 ) { free( ScriptFileContent ) ; ScriptFileContent = NULL ; return ; }\n\n\tst = (char*) malloc( len+2 ) ;\n\tmemcpy( st, input_str, len+1 ) ;\n\tfor( i=0 ; i<len ; i++ ) if( st[i]=='\\0' ) st[i]=' ' ;\n\t\n\t//if( debug_flag ) { debug_log( \">%d|\", len ) ; debug_log( \"%s|\\n\", st ) ; }\n\n\tif( strstr( st, ScriptFileContent ) != NULL ) {\n\t\tSendKeyboardPlus( MainHwnd, ScriptFileContent+strlen(ScriptFileContent)+1 ) ;\n\t\tl = strlen( ScriptFileContent ) + strlen( ScriptFileContent+strlen(ScriptFileContent)+1 ) + 2 ;\n\t\t\n\t\t//if( debug_flag ) { debug_log( \"<%d|\", l ) ; debug_log( \"%s|\\n\", ScriptFileContent+strlen(ScriptFileContent)+1 ) ; }\n\t\t\n\t\tScriptFileContent[0]=ScriptFileContent[l] ;\n\t\ti = 0 ;\n\t\tdo {\n\t\t\ti++ ;\n\t\t\tScriptFileContent[i]=ScriptFileContent[i+l] ;\n\t\t} while( (ScriptFileContent[i]!='\\0')||(ScriptFileContent[i-1]!='\\0') ) ;\n\t}\n\t\t\n\tfree( st ) ;\n}\n\t\nvoid ReadAutoCommandFromFile( const char * filename ) {\n\tFILE *fp ;\n\tlong l;\n\tint n;\n\tchar *pst, * buffer = NULL ;\n\tif( existfile( filename ) ) {\n\t\tl=filesize(filename) ;\n\t\tbuffer=(char*)malloc(5*l);\n\t\tpst = buffer ;\n\t\tif( ( fp = fopen( filename,\"rb\") ) != NULL ) {\n\t\t\twhile( fgets( pst, 1024, fp ) != NULL ) {\n\t\t\t\tpst = buffer + strlen(buffer) ;\n\t\t\t}\n\t\t\tfclose( fp ) ;\n\t\t}\n\t}\n\twhile( (n=poss(\"\\r\",buffer))>0 ) { del(buffer,n,1) ; }\t\n\twhile( buffer[strlen(buffer)-1]=='\\n' ) { buffer[strlen(buffer)-1]='\\0' ; }\n\twhile( (n=poss(\"\\n\",buffer))>0 ) { buffer[n-1]='n' ; insert(buffer,\"\\\\\",n) ; }\n\tconf_set_str(conf, CONF_autocommand, buffer );\n\tfree(buffer);\n}\n\nvoid ReadInitScript( const char * filename ) {\n\tchar * pst, *buffer=NULL, *name=NULL ;\n\tFILE *fp ;\n\tlong l ; \n\n\tif( filename != NULL )\n\t\tif( strlen( filename ) > 0 ) {\n\t\t\tname = (char*) malloc( strlen( filename ) + 1 ) ;\n\t\t\tstrcpy( name, filename ) ;\n\t\t}\n\tif( name == NULL ) {\n\t\tif( strlen(conf_get_str(conf,CONF_scriptfilecontent)) >0 ) {\n\t\t\tname = (char*) malloc( strlen( conf_get_str(conf,CONF_scriptfilecontent) ) + 1 ) ;\n\t\t\tstrcpy( name, conf_get_str(conf,CONF_scriptfilecontent) ) ;\n\t\t}\n\t}\n\tif( name != NULL ) {\n\t\tif( existfile( name ) ) {\n\t\t\tl=filesize(name) ;\n\t\t\tbuffer=(char*)malloc(5*l);\n\t\t\tif( ( fp = fopen( name,\"rb\") ) != NULL ) {\n\t\t\t\tif( ScriptFileContent!= NULL ) free( ScriptFileContent ) ;\n\t\t\t\tl = 0 ;\n\n\t\t\t\tScriptFileContent = (char*) malloc( filesize(name)+10 ) ;\n\t\t\t\tScriptFileContent[0] = '\\0' ;\n\t\t\t\tpst=ScriptFileContent ;\n\t\t\t\twhile( fgets( buffer, 1024, fp ) != NULL ) {\n\t\t\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\t\t\t\tif( strlen( buffer ) > 0 ) {\n\t\t\t\t\t\tstrcpy( pst, buffer ) ;\n\t\t\t\t\t\tpst = pst + strlen( pst ) + 1 ;\n\t\t\t\t\t\tl = l + strlen( buffer ) + 1 ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpst[0] = '\\0' ;\n\t\t\t\tl++ ;\n\t\t\t\tfclose( fp ) ;\n\t\t\t\tbcrypt_string_base64( ScriptFileContent, buffer, l, MASTER_PASSWORD, 0 ) ;\n\t\t\t\tif( IniFileFlag==SAVEMODE_REG ) {\n\t\t\t\t\t//WriteParameter( INIT_SECTION, \"KiCrSt\", buffer ) ;\n\t\t\t\t}\n\t\t\t\tconf_set_str(conf, CONF_scriptfilecontent, buffer );\n\t\t\t}\n\t\t\tif( buffer!=NULL ) { free(buffer); buffer=NULL; }\n\t\t} else {\n\t\t\tif( (buffer=(char*)malloc(strlen(name)+1))!=NULL ) {\n\t\t\t\tstrcpy( buffer, name ) ;\n\t\t\t\tl = decryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ;\n\t\t\t\tif( ScriptFileContent!= NULL ) free( ScriptFileContent ) ;\n\t\t\t\tScriptFileContent = (char*) malloc( l + 1 ) ;\n\t\t\t\tmemcpy( ScriptFileContent, buffer, l ) ;\n\t\t\t\tfree(buffer);buffer=NULL;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n#include \"kitty_launcher.c\"\n\n// Creer une arborescence de repertoire à partir du registre\nint MakeDirTree( const char * Directory, const char * s, const char * sd ) {\n\tchar buffer[MAX_VALUE_NAME], fullpath[MAX_VALUE_NAME] ;\n\tHKEY hKey;\n\tint retCode, i ;\n\tunsigned char lpData[1024] ;\n\tDWORD lpType, dwDataSize = 1024, cchValue = MAX_VALUE_NAME ;\n\tFILE * fp ;\n\n\tTCHAR achClass[MAX_PATH] = TEXT(\"\"), achKey[MAX_KEY_LENGTH], achValue[MAX_VALUE_NAME] ;\n\tDWORD cchClassName = MAX_PATH, cSubKeys=0, cbMaxSubKey, cchMaxClass, cValues, cchMaxValue, cbMaxValueData, cbSecurityDescriptor, cbName;\n\tFILETIME ftLastWriteTime; \n\t\n\tsprintf( fullpath, \"%s\\\\%s\", Directory, sd ) ; \n\tif( !MakeDir( fullpath ) ) {\n\t\tsprintf( fullpath,\"Unable to create directory: %s\\\\%s !\",Directory, sd);\n\t\tMessageBox(NULL,fullpath,\"Error\",MB_OK|MB_ICONERROR); \n\t\treturn 0 ;\n\t}\n\t\n\tsprintf( buffer, \"%s\\\\%s\", TEXT(PUTTY_REG_POS), s ) ;\n\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(buffer), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tif( RegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey\n\t\t\t,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\tif (cSubKeys) for (i=0; i<cSubKeys; i++) {\n\t\t\t\tcbName = MAX_KEY_LENGTH;\n\t\t\t\tretCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime) ;\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", s, achKey ) ;\n\t\t\t\tsprintf( fullpath, \"%s\\\\%s\", sd, achKey ) ;\n\t\t\t\tMakeDirTree( Directory, buffer, fullpath ) ;\n\t\t\t\t}\n\t\t\tretCode = ERROR_SUCCESS ;\n\t\t\tif(cValues) for (i=0, retCode=ERROR_SUCCESS; i<cValues; i++) {\n\t\t\t\tcchValue = MAX_VALUE_NAME; \n\t\t\t\tachValue[0] = '\\0'; \n\t\t\t\tif( (retCode = RegEnumValue(hKey, i, achValue, &cchValue, NULL, NULL,NULL,NULL) ) == ERROR_SUCCESS ){\n\t\t\t\t\tdwDataSize = 1024 ;\n\t\t\t\t\tRegQueryValueEx( hKey, TEXT( achValue ), 0, &lpType, lpData, &dwDataSize ) ;\n\t\t\t\t\tif( (int)lpType == REG_SZ ) {\n\t\t\t\t\t\tmungestr( achValue, buffer ) ;\n\t\t\t\t\t\tsprintf( fullpath, \"%s\\\\%s\\\\%s\", Directory, sd, buffer ) ;\n\t\t\t\t\t\tif( ( fp=fopen( fullpath, \"wb\") ) != NULL ) {\n\t\t\t\t\t\t\tfprintf( fp, \"%s\\\\%s\\\\\",achValue,lpData );\n\t\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tRegCloseKey( hKey ) ;\n\t\t}\n\treturn 1;\n\t}\n\n// Convertit la base de registre en repertoire pour le mode savemode=dir\nint Convert2Dir( const char * Directory ) {\n\tchar buffer[MAX_VALUE_NAME], fullpath[MAX_VALUE_NAME] ;\n\tHKEY hKey;\n\tint retCode, i, delkeyflag=0 ;\n\tFILE *fp ;\n\n\tunsigned char lpData[1024] ;\n\tTCHAR achClass[MAX_PATH] = TEXT(\"\"), achKey[MAX_KEY_LENGTH], achValue[MAX_VALUE_NAME] ; \n\tDWORD cchClassName = MAX_PATH, cSubKeys=0, cbMaxSubKey, cchMaxClass, cValues, cchMaxValue, cbMaxValueData, cbSecurityDescriptor, cbName,cchValue = MAX_VALUE_NAME , dwDataSize, lpType;\n\tFILETIME ftLastWriteTime; \n\t\n\tif( !RegTestKey( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS) ) ) // Si la cle de KiTTY n'existe pas on recupere celle de PuTTY\n\t\t{ TestRegKeyOrCopyFromPuTTY( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS) ) ; delkeyflag = 1 ; }\n\t\n\tsprintf( buffer, \"%s\\\\Commands\", Directory ) ; DelDir( buffer) ; MakeDirTree( Directory, \"Commands\", \"Commands\" ) ;\n\tsprintf( buffer, \"%s\\\\Launcher\", Directory ) ; DelDir( buffer) ; MakeDirTree( Directory, \"Launcher\", \"Launcher\" ) ;\n\tsprintf( buffer, \"%s\\\\Folders\", Directory ) ; DelDir( buffer) ; MakeDirTree( Directory, \"Folders\", \"Folders\" ) ;\n\tsprintf( buffer, \"%s\\\\Commands\", Directory ) ; DelDir( buffer) ; MakeDirTree( Directory, \"Commands\", \"Commands\" ) ;\n\t\n\tsprintf( buffer, \"%s\\\\Sessions\", Directory ) ; DelDir( buffer) ; { \n\t\tif(!MakeDir( buffer )) MessageBox(NULL,\"Unable to create directory for storing sessions\",\"Error\",MB_OK|MB_ICONERROR); \n\t}\n\tsprintf( buffer, \"%s\\\\Sessions\", TEXT(PUTTY_REG_POS) ) ;\n\t\t\n\tsprintf( fullpath, \"%s\\\\Sessions_Commands\", Directory ) ; DelDir( fullpath ) ; \n\tif(!MakeDir( fullpath )) { \n\t\tMessageBox(NULL,\"Unable to create directory for storing session commands\",\"Error\",MB_OK|MB_ICONERROR); \n\t}\n\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(buffer), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tif( RegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey\n\t\t\t,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\tif (cSubKeys) for (i=0; i<cSubKeys; i++) {\n\t\t\t\tcbName = MAX_KEY_LENGTH;\n\t\t\t\tretCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime) ;\n\t\t\t\tunmungestr( achKey, buffer,MAX_PATH) ;\n\t\t\t\tIniFileFlag = SAVEMODE_REG ;\n\t\t\t\tload_settings( buffer, conf ) ;\n\t\t\t\tIniFileFlag = SAVEMODE_DIR ;\n\t\t\t\tSetInitialSessPath() ;\n\t\t\t\tSetCurrentDirectory( Directory ) ;\n\t\t\t\t\n\t\t\t\tif( DirectoryBrowseFlag ) if( strcmp(conf_get_str(conf,CONF_folder), \"Default\")&&strcmp(conf_get_str(conf,CONF_folder), \"\") ) {\n\t\t\t\t\tsprintf( fullpath, \"%s\\\\Sessions\\\\%s\", Directory, conf_get_str(conf,CONF_folder)) ;\n\t\t\t\t\tif( !MakeDir( fullpath ) ) { MessageBox(NULL,\"Unable to create directory for storing session informations\",\"Error\",MB_OK|MB_ICONERROR); }\n\t\t\t\t\tSetSessPath( conf_get_str(conf,CONF_folder) ) ; \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsave_settings( buffer, conf) ;\n\n\t\t\t\tsprintf( buffer, \"%s\\\\Sessions\\\\%s\\\\Commands\", TEXT(PUTTY_REG_POS), achKey ) ;\n\t\t\t\tif( RegTestKey( HKEY_CURRENT_USER, buffer ) ) {\n\t\t\t\t\tsprintf( buffer, \"Sessions\\\\%s\\\\Commands\", achKey ) ;\n\t\t\t\t\tsprintf( fullpath, \"Sessions_Commands\\\\%s\", achKey ) ;\n\t\t\t\t\tMakeDirTree( Directory, buffer, fullpath ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tRegCloseKey( hKey ) ;\n\t}\n\t\n\tsprintf( buffer, \"%s\\\\SshHostKeys\", Directory ) ; DelDir( buffer) ; if( !MakeDir( buffer ) ) { \n\t\tMessageBox(NULL,\"Unable to create directory for storing ssh host keys\",\"Error\",MB_OK|MB_ICONERROR) ; \n\t}\n\tsprintf( buffer, \"%s\\\\SshHostKeys\", TEXT(PUTTY_REG_POS) ) ;\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(buffer), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tif( RegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey\n\t\t\t,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\tretCode = ERROR_SUCCESS ;\n\t\t\tif(cValues) for (i=0, retCode=ERROR_SUCCESS; i<cValues; i++) {\n\t\t\t\tcchValue = MAX_VALUE_NAME; \n\t\t\t\tachValue[0] = '\\0'; \n\t\t\t\tif( (retCode = RegEnumValue(hKey, i, achValue, &cchValue, NULL, NULL,NULL,NULL) ) == ERROR_SUCCESS ) {\n\t\t\t\t\tdwDataSize = 1024 ;\n\t\t\t\t\tRegQueryValueEx( hKey, TEXT( achValue ), 0, &lpType, lpData, &dwDataSize ) ;\n\t\t\t\t\tif( (int)lpType == REG_SZ ) {\n\t\t\t\t\t\tmungestr( achValue, buffer ) ;\n\t\t\t\t\t\tsprintf( fullpath, \"%s\\\\SshHostKeys\\\\%s\", Directory, buffer ) ;\n\t\t\t\t\t\tif( ( fp=fopen( fullpath, \"wb\") ) != NULL ) {\n\t\t\t\t\t\t\tfprintf( fp, \"%s\",lpData ) ;\n\t\t\t\t\t\t\tfclose(fp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tRegCloseKey( hKey ) ;\n\t}\n#ifdef MOD_PROXY\n\tsprintf( buffer, \"%s\\\\Proxies\", Directory ) ; DelDir( buffer) ; if( !MakeDir( buffer ) ) { \n\t\tMessageBox(NULL,\"Unable to create directory for storing proxies definition\",\"Error\",MB_OK|MB_ICONERROR) ; \n\t}\n\tsprintf( buffer, \"%s\\\\Proxies\", TEXT(PUTTY_REG_POS) ) ;\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(buffer), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tif( RegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey\n\t\t\t,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\tif (cSubKeys) for (i=0; i<cSubKeys; i++) {\n\t\t\t\tcbName = MAX_KEY_LENGTH;\n\t\t\t\tretCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime) ;\n\t\t\t\tExportSubKeyToFile( HKEY_CURRENT_USER, buffer, achKey, ConfigDirectory, \"Proxies\" ) ;\n\t\t\t}\n\t\t}\n\t\tRegCloseKey( hKey ) ;\n\t}\n#endif\n\t\n\tif( delkeyflag ) { RegDelTree (HKEY_CURRENT_USER, TEXT(PUTTY_REG_PARENT) ) ; }\n\t\n\treturn 0;\n}\n\n// Convertit une sauvegarde en mode savemode=dir vers la base de registre\n\t// NE FONCTIONNE PAS\n\t// PREFERER LA FONCTION Convert1Reg() fichier par fichier\n\t// A appeler avec le parametre -convert1reg\nvoid ConvertDir2Reg( const char * Directory, HKEY hKey, char * path )  {\n\tchar directory[MAX_VALUE_NAME], buffer[MAX_VALUE_NAME], session[MAX_VALUE_NAME] ;\n\tDIR * dir ;\n\tstruct dirent * de ;\n\tif( strlen(path)>0 ) {\n\t\tsprintf( directory, \"%s\\\\Sessions\\\\%s\", Directory, path ) ;\n\t} else {\n\t\tsprintf( directory, \"%s\\\\Sessions\", Directory ) ;\n\t}\n\tif( ( dir = opendir( directory ) ) != NULL ) {\n\t\twhile( (de=readdir(dir)) != NULL ) \n\t\tif( strcmp(de->d_name,\".\")&&strcmp(de->d_name,\"..\")  ) {\n\t\t\tsprintf( buffer, \"%s\\\\%s\", directory, de->d_name ) ;\n\t\t\tif( GetFileAttributes( buffer ) & FILE_ATTRIBUTE_DIRECTORY ) {\n\t\t\t\tif( strlen(path)>0 ) sprintf( buffer, \"%s\\\\%s\", path, de->d_name ) ;\n\t\t\t\telse strcpy( buffer, de->d_name ) ;\n\t\t\t\t\n//debug_log(\"Directory=%s|\\n\",buffer);\n\t\t\t\tConvertDir2Reg( Directory, hKey, buffer ) ;\n\t\t\t} else {\n\t\t\t\tSetSessPath( path ) ;\n\t\t\t\tIniFileFlag = SAVEMODE_DIR ;\n//debug_log(\"Session=%s|\\n\",de->d_name);\n\t\t\t\tunmungestr( de->d_name, session, MAX_PATH) ;\n//debug_log(\"\tnew\\n\");\n\t\t\t\tConf * tmpConf = conf_new() ;\n//debug_log(\"\tload\\n\");\n\t\t\t\tload_settings( session, tmpConf ) ;\n\t\t\t\tIniFileFlag = SAVEMODE_REG ;\n\t\t\t\tstrcpy( conf_get_str( tmpConf, CONF_folder ), path ) ;\n//debug_log(\"\tsave\\n\");\n\t\t\t\tsave_settings( session, tmpConf ) ;\n//debug_log(\"\tfree\\n\");\n\t\t\t\tconf_free( tmpConf ) ;\n//debug_log(\"\tend\\n\");\n\t\t\t}\n\t\t}\n\t\tclosedir( dir ) ;\n\t}\n}\n \nint Convert2Reg( const char * Directory ) {\n\tchar buffer[MAX_VALUE_NAME] ;\n\tHKEY hKey;\n \n\tsprintf( buffer, \"%s\\\\Sessions\", TEXT(PUTTY_REG_POS) ) ;\n\tif( RegTestKey( HKEY_CURRENT_USER, buffer ) ) \n\t\t{ RegDelTree (HKEY_CURRENT_USER, buffer ) ; }\n \n\tSetCurrentDirectory( Directory ) ;\n\tsprintf( buffer, \"%s\\\\Sessions\", TEXT(PUTTY_REG_POS) ) ;\n\tRegTestOrCreate( HKEY_CURRENT_USER, buffer, NULL, NULL ) ;\n \n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(buffer), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tstrcpy( buffer, \"\" ) ;\n\t\tConvertDir2Reg( Directory, hKey, buffer ) ;\n\t\tRegCloseKey( hKey ) ;\n\t\t}\n \n\treturn 0 ;\n\t}\n\nchar *dirname(char *path);\nint Convert1Reg( const char * filename ) {\n\tchar buffer[MAX_VALUE_NAME] = \"\", session[MAX_VALUE_NAME], dname[MAX_VALUE_NAME], *bname ;\n\tHKEY hKey;\n\tint i;\n\tif( (filename==NULL)||(strlen(filename)==0) ) { return 1 ; }\n\tsprintf( buffer, \"%s\\\\Sessions\", TEXT(PUTTY_REG_POS) ) ;\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(buffer), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tstrcpy(buffer,filename);\n\t\tbname = buffer ;\n\t\tfor( i=0; i<strlen(buffer); i++ ) { \n\t\t\tif(buffer[i]=='/') buffer[i]='\\\\' ;\n\t\t\tif( (buffer[i]=='\\\\')&&(buffer[i+1]!='\\0') ) { bname = buffer+i+1 ; }\n\t\t}\n\t\tstrcpy(dname,buffer);\n\t\tstrcpy(dname,dirname(dname));\n\t\tSetCurrentDirectory( dname ) ;\n\t\tSetSessPath(\".\");\n\t\tIniFileFlag = SAVEMODE_DIR ;\n\t\tunmungestr( bname, session, MAX_PATH) ;\n\t\tConf * tmpConf = conf_new() ;\n\t\tload_settings( session, tmpConf ) ;\n\t\tIniFileFlag = SAVEMODE_REG ;\n\t\tstrcpy( conf_get_str( tmpConf, CONF_folder ), dname ) ;\n\t\tsave_settings( session, tmpConf ) ;\n\t\tRegCloseKey( hKey ) ;\n\t} else {\n\t\tMessageBox(NULL,\"Unable to open sessions registry key\",\"Error\",MB_OK|MB_ICONERROR) ;\n\t}\n\treturn 0 ;\n}\n\nvoid ResetWindow(int reinit) ;\n#ifndef IDM_RECONF    \n#define IDM_RECONF    0x0050\n#endif\n\nvoid NegativeColours(HWND hwnd) {\n\tint i ;\n#ifdef MOD_TUTTYCOLOR\n    for (i = 0; i < 34; i++) {\n#else\n    for (i = 0; i < 22; i++) {\n#endif\n\tconf_set_int_int(conf, CONF_colours, i*3+0, 256-conf_get_int_int(conf, CONF_colours, i*3+0));\n\tconf_set_int_int(conf, CONF_colours, i*3+1, 256-conf_get_int_int(conf, CONF_colours, i*3+1));\n\tconf_set_int_int(conf, CONF_colours, i*3+2, 256-conf_get_int_int(conf, CONF_colours, i*3+2));\n    }\n    force_reconf = 0 ;\n    PostMessage( hwnd, WM_COMMAND, IDM_RECONF, 0 ) ;\n    \n    RefreshBackground( hwnd ) ;\n}\n\nstatic int * BlackOnWhiteColoursSave = NULL ;\nvoid BlackOnWhiteColours(HWND hwnd) {\n\tif( BlackOnWhiteColoursSave==NULL ) {\n\t\tBlackOnWhiteColoursSave = (int*) malloc( 6*sizeof(int) ) ;\n\t\tBlackOnWhiteColoursSave[0]=conf_get_int_int(conf, CONF_colours, 0); conf_set_int_int(conf, CONF_colours, 0, 0);\n\t\tBlackOnWhiteColoursSave[1]=conf_get_int_int(conf, CONF_colours, 1); conf_set_int_int(conf, CONF_colours, 1, 0);\n\t\tBlackOnWhiteColoursSave[2]=conf_get_int_int(conf, CONF_colours, 2); conf_set_int_int(conf, CONF_colours, 2, 0);\n\t\tBlackOnWhiteColoursSave[3]=conf_get_int_int(conf, CONF_colours, 6); conf_set_int_int(conf, CONF_colours, 6, 255);\n\t\tBlackOnWhiteColoursSave[4]=conf_get_int_int(conf, CONF_colours, 7); conf_set_int_int(conf, CONF_colours, 7, 255);\n\t\tBlackOnWhiteColoursSave[5]=conf_get_int_int(conf, CONF_colours, 8); conf_set_int_int(conf, CONF_colours, 8, 255);\n\t} else {\n\t\tif(conf_get_int_int(conf, CONF_colours, 0)==0) {\n\t\t\tconf_set_int_int(conf, CONF_colours, 0, 255);\n\t\t\tconf_set_int_int(conf, CONF_colours, 1, 255);\n\t\t\tconf_set_int_int(conf, CONF_colours, 2, 255);\n\t\t\tconf_set_int_int(conf, CONF_colours, 6, 0);\n\t\t\tconf_set_int_int(conf, CONF_colours, 7, 0);\n\t\t\tconf_set_int_int(conf, CONF_colours, 8, 0);\n\t\t} else {\n\t\t\tconf_set_int_int(conf, CONF_colours, 0, BlackOnWhiteColoursSave[0]) ;\n\t\t\tconf_set_int_int(conf, CONF_colours, 1, BlackOnWhiteColoursSave[1]) ;\n\t\t\tconf_set_int_int(conf, CONF_colours, 2, BlackOnWhiteColoursSave[2]) ;\n\t\t\tconf_set_int_int(conf, CONF_colours, 6, BlackOnWhiteColoursSave[3]) ;\n\t\t\tconf_set_int_int(conf, CONF_colours, 7, BlackOnWhiteColoursSave[4]) ;\n\t\t\tconf_set_int_int(conf, CONF_colours, 8, BlackOnWhiteColoursSave[5]) ;\n\t\t\tfree(BlackOnWhiteColoursSave) ; \n\t\t\tBlackOnWhiteColoursSave=NULL ;\n\t\t}\n\t}\n\tforce_reconf = 0 ;\n\tPostMessage( hwnd, WM_COMMAND, IDM_RECONF, 0 ) ;\n\n\tResetWindow(2);\n}\n\nstatic int original_fontsize = -1 ;\nvoid ChangeFontSize(Terminal *term, Conf *conf,HWND hwnd, int dec) {\n\tFontSpec *fontspec = conf_get_fontspec(conf, CONF_font);\n\tif( original_fontsize<0 ) original_fontsize = fontspec->height ;\n\tif( dec == 0 ) { fontspec->height = original_fontsize ; }\n\telse {\n\t\tfontspec->height = fontspec->height + dec ;\n\t\tif(fontspec->height <=0 ) fontspec->height = 1 ;\n\t}\n\tconf_set_fontspec(conf, CONF_font, fontspec);\n        fontspec_free(fontspec);\n\tforce_reconf = 0 ;\n\tterm_size(term,\n\t\t\t\tconf_get_int(conf, CONF_height),\n\t\t\t\tconf_get_int(conf, CONF_width),\n\t\t\t\tconf_get_int(conf, CONF_savelines));\n\t//PostMessage( hwnd, WM_COMMAND, IDM_RECONF, 0 ) ;\n\n\tResetWindow(2);\n}\nvoid ChangeSettings(HWND hwnd) {\n\t//NegativeColours(hwnd);\n\tBlackOnWhiteColours(hwnd);\n\t//ChangeFontSize(hwnd,1);\n\t//ChangeFontSize(hwnd,-1);\n}\n\t\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n// Gestion de l'image viewer\nint ManageViewer( HWND hwnd, WORD wParam ) { // Gestion du mode image\n\tif( wParam==VK_BACK ) \n\t\t{ if( PreviousBgImage( hwnd ) ) InvalidateRect(hwnd, NULL, TRUE) ; \n\t\tset_title(NULL, conf_get_str(conf,CONF_wintitle) ) ; \n\t\treturn 1 ; \n\t\t}\n\telse if( wParam==VK_SPACE ) \n\t\t{ if( NextBgImage( hwnd ) ) InvalidateRect(hwnd, NULL, TRUE) ;\n\t\tset_title(NULL, conf_get_str(conf,CONF_wintitle)) ; \n\t\treturn 1 ; \n\t\t}\n\telse if( wParam == VK_DOWN ) \t// Augmenter l'opacite de l'image de fond\n\t\t{ if( conf_get_int(conf,CONF_bg_type) != 0 ) {\n\t\t\tint n=conf_get_int(conf,CONF_bg_opacity) ;\n\t\t\tn += 5 ; if( n>100 ) n = 0 ;\n\t\t\tconf_set_int( conf, CONF_bg_opacity, n ) ;\n\t\t\tRefreshBackground( hwnd ) ;\n\t\t\treturn 1 ; \n\t\t\t}\n\t\t}\n\telse if( wParam == VK_UP ) \t\t// Diminuer l'opacite de l'image de fond\n\t\t{ if( conf_get_int(conf,CONF_bg_type) != 0 ) {\n\t\t\tint n=conf_get_int(conf,CONF_bg_opacity) ;\n\t\t\tn -= 5 ;\n\t\t\tif( n<0 ) n = 100 ;\n\t\t\tconf_set_int( conf, CONF_bg_opacity, n ) ;\n\t\t\tRefreshBackground( hwnd ) ; \n\t\t\treturn 1 ; \n\t\t\t}\n\t\t}\n\telse if( wParam == VK_RETURN ) {\n\t\t  if (IsZoomed(hwnd)) { ShowWindow(hwnd, SW_RESTORE); } \n\t\t  else { ShowWindow(hwnd, SW_MAXIMIZE); }\n\t\treturn 1 ;\n\t\t}\n\treturn 0 ;\n\t}\n#endif\n\t\n// Shortcuts managment\nint DefineShortcuts( char * buf ) {\n\tchar * pst = buf ;\n\tif( strlen(buf)==0 ) return 0 ;\n\tint key = 0 ;\n\t// Special keys\n\twhile( (strstr(pst,\"{SHIFT}\")==pst) || (strstr(pst,\"{CONTROL}\")==pst) || (strstr(pst,\"{ALT}\")==pst) || (strstr(pst,\"{ALTGR}\")==pst) || (strstr(pst,\"{WIN}\")==pst) ) {\n\t\twhile( strstr(pst,\"{ALT}\")==pst ) { key += ALTKEY ; pst += 5 ; }\n\t\twhile( strstr(pst,\"{ALTGR}\")==pst ) { key += ALTGRKEY ; pst += 7 ; }\n\t\twhile( strstr(pst,\"{WIN}\")==pst ) { key += WINKEY ; pst += 5 ; }\n\t\twhile( strstr(pst,\"{SHIFT}\")==pst ) { key += SHIFTKEY ; pst += 7 ; }\n\t\twhile( strstr(pst,\"{CONTROL}\")==pst ) { key += CONTROLKEY ; pst += 9 ; }\n\t}\n\t\n\tif( strstr( pst, \"{F12}\" )==pst ) { key = key + VK_F12 ; pst += 5 ; }\n\telse if( strstr( pst, \"{F11}\" )==pst ) { key = key + VK_F11 ; pst += 5 ; }\n\telse if( strstr( pst, \"{F10}\" )==pst ) { key = key + VK_F10 ; pst += 5 ; }\n\telse if( strstr( pst, \"{F9}\" )==pst ) { key = key + VK_F9 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F8}\" )==pst ) { key = key + VK_F8 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F7}\" )==pst ) { key = key + VK_F7 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F6}\" )==pst ) { key = key + VK_F6 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F5}\" )==pst ) { key = key + VK_F5 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F4}\" )==pst ) { key = key + VK_F4 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F3}\" )==pst ) { key = key + VK_F3 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F2}\" )==pst ) { key = key + VK_F2 ; pst += 4 ; }\n\telse if( strstr( pst, \"{F1}\" )==pst ) { key = key + VK_F1 ; pst += 4 ; }\n\telse if( strstr( pst, \"{RETURN}\" )==pst ) { key = key + VK_RETURN ; pst += 8 ; }\n\telse if( strstr( pst, \"{ESCAPE}\" )==pst ) { key = key + VK_ESCAPE ; pst += 8 ; }\n\telse if( strstr( pst, \"{SPACE}\" )==pst ) { key = key + VK_SPACE ; pst += 7 ; }\n\telse if( strstr( pst, \"{PRINT}\" )==pst ) { key = key + VK_SNAPSHOT ; pst += 7 ; }\n\telse if( strstr( pst, \"{PAUSE}\" )==pst ) { key = key + VK_PAUSE ; pst += 7 ; }\n\telse if( strstr( pst, \"{PRIOR}\" )==pst ) { key = key + VK_PRIOR ; pst += 7 ; }\n\telse if( strstr( pst, \"{RIGHT}\" )==pst ) { key = key + VK_RIGHT ; pst += 7 ; }\n\telse if( strstr( pst, \"{LEFT}\" )==pst ) { key = key + VK_LEFT ; pst += 6 ; }\n\telse if( strstr( pst, \"{NEXT}\" )==pst ) { key = key + VK_NEXT ; pst += 6 ; }\n\telse if( strstr( pst, \"{BACK}\" )==pst ) { key = key + VK_BACK ; pst += 6 ; }\n\telse if( strstr( pst, \"{HOME}\" )==pst ) { key = key + VK_HOME ; pst += 6 ; }\n\telse if( strstr( pst, \"{DOWN}\" )==pst ) { key = key + VK_DOWN ; pst += 6 ; }\n\telse if( strstr( pst, \"{ATTN}\" )==pst ) { key = key + VK_ATTN ; pst += 6 ; }\n\telse if( strstr( pst, \"{END}\" )==pst ) { key = key + VK_END ; pst += 5 ; }\n\telse if( strstr( pst, \"{TAB}\" )==pst ) { key = key + VK_TAB ; pst += 5 ; }\n\telse if( strstr( pst, \"{INS}\" )==pst ) { key = key + VK_INSERT ; pst += 5 ; }\n\telse if( strstr( pst, \"{DEL}\" )==pst ) { key = key + VK_DELETE ; pst += 5 ; }\n\telse if( strstr( pst, \"{UP}\" )==pst ) { key = key + VK_UP ; pst += 4 ; }\n\telse if( strstr( pst, \"{NUMPAD0}\" )==pst ) { key = key + VK_NUMPAD0 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD1}\" )==pst ) { key = key + VK_NUMPAD1 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD2}\" )==pst ) { key = key + VK_NUMPAD2 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD3}\" )==pst ) { key = key + VK_NUMPAD3 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD4}\" )==pst ) { key = key + VK_NUMPAD4 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD5}\" )==pst ) { key = key + VK_NUMPAD5 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD6}\" )==pst ) { key = key + VK_NUMPAD6 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD7}\" )==pst ) { key = key + VK_NUMPAD7 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD8}\" )==pst ) { key = key + VK_NUMPAD8 ; pst += 9 ; }\n\telse if( strstr( pst, \"{NUMPAD9}\" )==pst ) { key = key + VK_NUMPAD9 ; pst += 9 ; }\n\telse if( strstr( pst, \"{DECIMAL}\" )==pst ) { key = key + VK_DECIMAL ; pst += 9 ; }\n\telse if( strstr( pst, \"{BREAK}\" )==pst ) { key = key + VK_CANCEL ; pst += 7 ; }\n\telse if( strstr( pst, \"{NUMLOCK}\" )==pst ) { key = key + VK_NUMLOCK ; pst += 9 ; }\n\telse if( strstr( pst, \"{SCROLL}\" )==pst ) { key = key + VK_SCROLL ; pst += 8 ; }\n\telse if( strstr( pst, \"{ADD}\" )==pst ) { key = key + VK_ADD ; pst += 5 ; }\n\telse if( strstr( pst, \"{MULTIPLY}\" )==pst ) { key = key + VK_MULTIPLY ; pst += 10 ; }\n\telse if( strstr( pst, \"{SEPARATOR}\" )==pst ) { key = key + VK_SEPARATOR ; pst += 11 ; }\n\telse if( strstr( pst, \"{SUBTRACT}\" )==pst ) { key = key + VK_SUBTRACT ; pst += 10 ; }\n\telse if( strstr( pst, \"{DECIMAL}\" )==pst ) { key = key + VK_DECIMAL ; pst += 9 ; }\n\telse if( strstr( pst, \"{DIVIDE}\" )==pst ) { key = key + VK_DIVIDE ; pst += 8 ; }\n\telse if( strstr( pst, \"{ATTN}\" )==pst ) { key = key + VK_ATTN ; pst += 6 ; }\n\t\n\telse if( strstr( pst, \"{OEM_PLUS}\" )==pst ) { key = key + VK_OEM_PLUS  ; pst += 10 ; } // +\n\telse if( strstr( pst, \"{OEM_COMMA}\" )==pst ) { key = key + VK_OEM_COMMA  ; pst += 11 ; } // ,\n\telse if( strstr( pst, \"{OEM_MINUS}\" )==pst ) { key = key + VK_OEM_MINUS  ; pst += 11 ; } // -\n\telse if( strstr( pst, \"{OEM_PERIOD}\" )==pst ) { key = key + VK_OEM_PERIOD  ; pst += 12 ; } // .\n\t\n/* \nExample to change automatically , in .\n[Shortcuts]\nlist={OEM_COMMA}\n{OEM_COMMA}=.\\\n*/\n\t\n\telse if( pst[0] == '{' ) { key = 0 ; }\n\telse { key = key + toupper(pst[0]) ; }\n\t\n\tif( key==0 ) { key = -1 ; }\n\treturn key ;\n}\n\t\nvoid TranslateShortcuts( char * st ) {\n\tint i,j,k,r ;\n\tchar *buffer;\n\tif( st==NULL ) return ;\n\tif( strlen(st)==0 ) return ;\n\tbuffer = (char*) malloc( strlen(st)+1 ) ;\n\tfor( i=0 ; i<strlen(st) ; i++ ) {\n\t\tif( st[i]=='{' ) {\n\t\t\tif( strstr(st+i,\"{{\")==(st+i) ) {\n\t\t\t\tdel(st,i+1,1);\n\t\t\t} else if( strstr(st+i,\"{END}\")==(st+i) ) {\n\t\t\t\tdel(st,i+1,1);st[i]='\\\\';st[i+1]='k';st[i+2]='2';st[i+3]='3';\n\t\t\t\ti=i+3;\n\t\t\t} else if( strstr(st+i,\"{HOME}\")==(st+i) ) {\n\t\t\t\tdel(st,i+1,2);st[i]='\\\\';st[i+1]='k';st[i+2]='2';st[i+3]='4';\n\t\t\t\ti=i+3;\n\t\t\t} else if( strstr(st+i,\"{ESCAPE}\")==(st+i) ) {\n\t\t\t\tdel(st,i+1,4);st[i]='\\\\';st[i+1]='k';st[i+2]='1';st[i+3]='b';\n\t\t\t\ti=i+3;\n\t\t\t} else if( (j=poss( \"}\", st+i )) > 3 ) {\n\t\t\t\tfor( k=i ; k<(i+j) ; k++ ) {\n\t\t\t\t\tbuffer[k-i]=st[k] ;\n\t\t\t\t\tbuffer[k-i+1]='\\0' ;\n\t\t\t\t}\n\t\t\t\tr=DefineShortcuts( buffer ) ;\n\t\t\t\tdel(st,i+1,j-1);\n\t\t\t\tst[i]=r ;\n\t\t\t}\n\t\t}\n\t}\n\tfree(buffer);\n}\n\n// Init shortcuts map at startup\nvoid InitShortcuts( void ) {\n\tchar buffer[4096], list[4096], *pl ;\n\tint i, t=0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"editor\",buffer) || ( (shortcuts_tab.editor=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.editor = SHIFTKEY+VK_F2 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"editorclipboard\",buffer) || ( (shortcuts_tab.editorclipboard=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.editorclipboard = CONTROLKEY+SHIFTKEY+VK_F2 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"winscp\",buffer) || ( (shortcuts_tab.winscp=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.winscp = SHIFTKEY+VK_F3 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"switchlogmode\",buffer) || ( (shortcuts_tab.switchlogmode=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.switchlogmode = SHIFTKEY+VK_F5 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"showportforward\",buffer) || ( (shortcuts_tab.showportforward=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.showportforward = SHIFTKEY+VK_F6 ;\n//\tif( !IsWow64() ) {\n\t\tif( !readINI(KittyIniFile,\"Shortcuts\",\"print\",buffer) || ( (shortcuts_tab.print=DefineShortcuts(buffer))<0 ) )\n\t\t\tshortcuts_tab.print = SHIFTKEY+VK_F7 ;\n\t\tif( !readINI(KittyIniFile,\"Shortcuts\",\"printall\",buffer) || ( (shortcuts_tab.printall=DefineShortcuts(buffer))<0 ) )\n\t\t\tshortcuts_tab.printall = VK_F7 ;\n//\t}\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"inputm\",buffer) || ( (shortcuts_tab.inputm=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.inputm = SHIFTKEY+VK_F8 ;\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"viewer\",buffer) || ( (shortcuts_tab.viewer=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.viewer = SHIFTKEY+VK_F11 ;\n#endif\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"autocommand\",buffer) || ( (shortcuts_tab.autocommand=DefineShortcuts(buffer))<0 ) ) \n\t\tshortcuts_tab.autocommand = SHIFTKEY+VK_F12 ;\n\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"script\",buffer) || ( (shortcuts_tab.script=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.script = CONTROLKEY+VK_F2 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"sendfile\",buffer) || ( (shortcuts_tab.sendfile=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.sendfile = CONTROLKEY+VK_F3 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"getfile\",buffer) || ( (shortcuts_tab.getfile=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.getfile = CONTROLKEY+VK_F4 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"command\",buffer) || ( (shortcuts_tab.command=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.command = CONTROLKEY+VK_F5 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"tray\",buffer) || ( (shortcuts_tab.tray=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.tray = CONTROLKEY+VK_F6 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"visible\",buffer) || ( (shortcuts_tab.visible=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.visible = CONTROLKEY+VK_F7 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"input\",buffer) || ( (shortcuts_tab.input=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.input = CONTROLKEY+VK_F8 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"protect\",buffer) || ( (shortcuts_tab.protect=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.protect = CONTROLKEY+VK_F9 ;\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"imagechange\",buffer) || ( (shortcuts_tab.imagechange=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.imagechange = CONTROLKEY+VK_F11 ;\n#endif\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"rollup\",buffer) || ( (shortcuts_tab.rollup=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.rollup = CONTROLKEY+VK_F12 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"resetterminal\",buffer) || ( (shortcuts_tab.resetterminal=DefineShortcuts(buffer))<0 ) ) \n\t\tshortcuts_tab.resetterminal = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"duplicate\",buffer) || ( (shortcuts_tab.duplicate=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.duplicate = CONTROLKEY+ALTKEY+84 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"opennew\",buffer) || ( (shortcuts_tab.opennew=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.opennew = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"opennewcurrent\",buffer) || ( (shortcuts_tab.opennewcurrent=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.opennewcurrent = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"changesettings\",buffer) || ( (shortcuts_tab.changesettings=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.changesettings = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"clearscrollback\",buffer) || ( (shortcuts_tab.clearscrollback=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.clearscrollback = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"clearlogfile\",buffer) || ( (shortcuts_tab.clearlogfile=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.clearlogfile = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"closerestart\",buffer) || ( (shortcuts_tab.closerestart=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.closerestart = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"eventlog\",buffer) || ( (shortcuts_tab.eventlog=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.eventlog = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"fullscreen\",buffer) || ( (shortcuts_tab.fullscreen=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.fullscreen = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"fontup\",buffer) || ( (shortcuts_tab.fontup=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.fontup = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"fontdown\",buffer) || ( (shortcuts_tab.fontdown=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.fontdown = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"copyall\",buffer) || ( (shortcuts_tab.copyall=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.copyall = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"fontnegative\",buffer) || ( (shortcuts_tab.fontnegative=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.fontnegative = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"fontblackandwhite\",buffer) || ( (shortcuts_tab.fontblackandwhite=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.fontblackandwhite = 0 ;\n\tif( !readINI(KittyIniFile,\"Shortcuts\",\"keyexchange\",buffer) || ( (shortcuts_tab.keyexchange=DefineShortcuts(buffer))<0 ) )\n\t\tshortcuts_tab.keyexchange = 0 ;\n\n\t\n\tif( NbShortCuts>0 ) for( i=0 ; i<NbShortCuts ; i++ ) { if( shortcuts_tab2[i].st!=NULL ) { free(shortcuts_tab2[i].st) ; } }\n\tNbShortCuts=0 ;\n\tif( ReadParameter( \"Shortcuts\", \"list\", list ) ) {\n\t\tpl=list ;\n\t\twhile( strlen(pl) > 0 ) {\n\t\t\ti=0;\n\t\t\twhile( (i<strlen(pl))&&(pl[i]!=' ') ) { i++ ; }\n\t\t\tif( pl[i]==' ' ) { pl[i]='\\0' ; t=1 ; }\n\t\t\tif( strlen(pl)>0 )\n\t\t\tif( ReadParameter( \"Shortcuts\", pl, buffer ) ) {\n\t\t\t\tif( (pl[0]<'0')||(pl[0]>'9') ) {\n\t\t\t\t\tshortcuts_tab2[NbShortCuts].num = DefineShortcuts( pl );\n\t\t\t\t} else {\n\t\t\t\t\tshortcuts_tab2[NbShortCuts].num = atoi(pl) ;\n\t\t\t\t}\n\t\t\t\tTranslateShortcuts( buffer ) ;\n\t\t\t\tif( debug_flag ) { debug_logevent( \"Remap key %s to %s\", pl, buffer ) ; }\n\n\t\t\t\tshortcuts_tab2[NbShortCuts].st=(char*)malloc( strlen(buffer)+1 ) ;\n\t\t\t\tstrcpy( shortcuts_tab2[NbShortCuts].st, buffer ) ;\n\t\t\t\tNbShortCuts++;\n\t\t\t}\n\t\t\tif( t==1 ) { pl[i]=' ' ; t = 0 ; pl=pl+i+1 ; }\n\t\t\telse pl=pl+i ;\n\n\t\t\twhile( pl[0]==' ' ) pl++ ;\n\t\t}\n\t}\n}\n\nint SwitchLogMode(void) ;\nint ManageShortcuts( Terminal *term, Conf *conf, HWND hwnd, const int* clips_system, int key_num, int shift_flag, int control_flag, int alt_flag, int altgr_flag, int win_flag ) {\n\tint key, i ;\n\tkey = key_num ;\n\tif( alt_flag ) key = key + ALTKEY ;\n\tif( altgr_flag ) key = key + ALTGRKEY ;\n\tif( shift_flag ) key = key + SHIFTKEY ;\n\tif( control_flag ) key = key + CONTROLKEY ;\n\tif( win_flag ) key = key + WINKEY ;\n\n//if( (key_num!=VK_SHIFT)&&(key_num!=VK_CONTROL) ) {char b[256] ; sprintf( b, \"alt=%d altgr=%d shift=%d control=%d key_num=%d key=%d action=%d\", alt_flag, altgr_flag, shift_flag, control_flag, key_num, key, shortcuts_tab.duplicate ); MessageBox(hwnd, b, \"Info\", MB_OK);}\n\n\tif( key == shortcuts_tab.protect )\t\t\t\t// Protection\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_PROTECT, 0 ) ; InvalidateRect( hwnd, NULL, TRUE ) ; return 1 ; }\n\tif( key == shortcuts_tab.rollup ) \t\t\t\t// Winroll\n\t\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_WINROL, 0 ) ; return 1 ; }\n\tif( key == shortcuts_tab.switchlogmode ) {\n\t\ti = SwitchLogMode() ;\n\t\tif( i==1 ) { debug_logevent( \"Enable logging\" ) ; } else { debug_logevent( \"Disable logging\" ) ; }\n\t\treturn 1 ;\n\t}\n\tif( key == shortcuts_tab.showportforward ) \t\t\t\t// Fonction show port forward\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_SHOWPORTFWD, 0 ) ; return 1 ; }\n\n\tif( (ProtectFlag == 1) || (WinHeight != -1) ) return 1 ;\n\t\t\n\tif( NbShortCuts ) {\n\t\tfor( i=0 ; i<NbShortCuts ; i++ )\n\t\tif( shortcuts_tab2[i].num == key ) {\n\t\t\tSendKeyboardPlus( hwnd, shortcuts_tab2[i].st ) ;\n\t\t\treturn 1 ; \n\t\t}\n\t}\n\t\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( GetBackgroundImageFlag() && ImageViewerFlag ) { // Gestion du mode image\n\t\tif( ManageViewer( hwnd, key_num ) ) return 1 ;\n\t\t}\n#endif\n\tif( control_flag && shift_flag && (key_num==VK_F12) ) {\n\t\tResizeWinList( hwnd, conf_get_int(conf,CONF_width), conf_get_int(conf,CONF_height) ) ; return 1 ; \n\t} // Resize all PuTTY windows to the size of the current one\n\n\tif( key == shortcuts_tab.printall ) {\t\t\n\t\tSendMessage( hwnd, WM_COMMAND, IDM_COPYALL, 0 ) ;\n\t\tSendMessage( hwnd, WM_COMMAND, IDM_PRINT, 0 ) ;\n\t\treturn 1 ;\n\t}\n\n\tif( ( IniFileFlag != SAVEMODE_DIR ) && shift_flag && control_flag ) {\t\t\n\t\tif( ( key_num >= 'A' ) && ( key_num <= 'Z' ) ) // Raccourci commandes speciales (SpecialMenu) CTRL+SHIFT+'A' ... CTRL+SHIFT+'Z'\n\t\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_USERCMD+key_num-'A', 0 ) ; return 1 ; }\n\t}\n\t\t\n\tif( key == shortcuts_tab.editor ) {\t\t\t// Lancement d'un putty-ed\n\t\tif( debug_flag ) { debug_logevent( \"Start empty internal editor\" ) ; }\n\t\tRunPuttyEd( hwnd, NULL ) ; \n\t\treturn 1 ; \n\t}\n\tif( key == (shortcuts_tab.editorclipboard ) ) {\t\t// Lancement d'un putty-ed qui charge le contenu du presse-papier\n\t\tif( debug_flag ) { debug_logevent( \"Start internal editor fullfiled with clipboard\" ) ; }\n\t\t//term_copyall(term,clips_system,lenof(clips_system)) /* Full term clipboard */\n\t\tRunPuttyEd( hwnd, \"1\" ) ; \n\t\treturn 1 ; \n\t} else if( key == shortcuts_tab.winscp ) {\t\t\t// Lancement de WinSCP\n\t\tSendMessage( hwnd, WM_COMMAND, IDM_WINSCP, 0 ) ; return 1 ;\n\t} else if( key == shortcuts_tab.autocommand ) { \t\t// Rejouer la commande de demarrage\n\t\t\tRenewPassword( conf ) ; \n\t\t\tSetTimer(hwnd, TIMER_AUTOCOMMAND,autocommand_delay, NULL) ;\n\t\t\treturn 1 ; \n\t} if( key == shortcuts_tab.print ) {\t\t\t// Impression presse papier\n\t\tSendMessage( hwnd, WM_COMMAND, IDM_PRINT, 0 ) ; \n\t\treturn 1 ; \n\t}\n#ifndef FLJ\n\tif( key == shortcuts_tab.inputm )\t \t\t// Fenetre de controle\n\t\t{\n\t\tMainHwnd = hwnd ; _beginthread( routine_inputbox_multiline, 0, (void*)&hwnd ) ;\n\t\treturn 1 ;\n\t\t}\n#endif\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( GetBackgroundImageFlag() && (key == shortcuts_tab.viewer) ) \t// Switcher le mode visualiseur d'image\n\t\t{ ImageViewerFlag = abs(ImageViewerFlag-1) ; set_title(NULL, conf_get_str(conf,CONF_wintitle) ) ; return 1 ; }\n#endif\n\tif( key == shortcuts_tab.script ) \t\t\t// Chargement d'un fichier de script\n\t\t{ OpenAndSendScriptFile( hwnd ) ; return 1 ; }\n\telse if( key == shortcuts_tab.sendfile ) \t\t// Envoi d'un fichier par SCP\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_PSCP, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.getfile ) \t\t// Reception d'un fichier par SCP\n\t\t{ GetFile( hwnd ) ; return 1 ; }\n\telse if( key == shortcuts_tab.command )\t\t\t// Execution d'une commande locale\n\t\t{ RunCmd( hwnd ) ; return 1 ; }\n\telse if( key == shortcuts_tab.tray ) \t\t// Send to tray\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_TOTRAY, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.visible )  \t\t// Always visible \n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_VISIBLE, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.resetterminal ) \t\t// Envoi d'un fichier par SCP\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_RESET, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.duplicate ) \t\t// Duplicate session\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_DUPSESS, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.opennew ) \t\t// Open new session\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_NEWSESS, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.opennewcurrent ) \t\t// Open new config box with current settings\n\t\t{ RunSessionWithCurrentSettings( hwnd, conf, NULL, NULL, NULL, 0, NULL ) ; return 1 ; }\n\telse if( key == shortcuts_tab.changesettings ) \t\t// Change settings\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_RECONF, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.clearscrollback )\t\t// Clear scrollback\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_CLRSB, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.clearlogfile )\t\t// Clear log file\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_CLEARLOGFILE, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.closerestart )\t\t// Close + restart\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_RESTARTSESSION, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.eventlog )\t\t// Event log\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_SHOWLOG, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.fullscreen )\t\t// Full screen\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_FULLSCREEN, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.fontup )\t\t\t// Font up\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_FONTUP, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.fontdown )\t\t// Font down\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_FONTDOWN, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.copyall )\t\t\t// Copy all to clipboard\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_COPYALL, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.fontnegative )\t\t// Font negative\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_FONTNEGATIVE, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.fontblackandwhite )\t// Font black and white\n\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_FONTBLACKANDWHITE, 0 ) ; return 1 ; }\n\telse if( key == shortcuts_tab.keyexchange )\t\t// Repeat key exchange\n\t\t{ SendMessage( hwnd, WM_COMMAND, 1328, 0 ) ; return 1 ; }\n\t\t\n#ifndef FLJ\n\telse if( key == shortcuts_tab.input ) \t\t\t// Fenetre de controle\n\t\t{ \n\t\t\tMainHwnd = hwnd ; _beginthread( routine_inputbox, 0, (void*)&hwnd ) ;\n\t\t\tInvalidateRect( hwnd, NULL, TRUE ) ; return 1 ;\n\t\t}\n#endif\n\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\telse if( GetBackgroundImageFlag() && (key == shortcuts_tab.imagechange) ) \t\t// Changement d'image de fond\n\t\t{ if( NextBgImage( hwnd ) ) InvalidateRect(hwnd, NULL, TRUE) ; return 1 ; }\n#endif\n/*\n\tif( control_flag && shift_flag ) {\n\t\tif(key_num == VK_UP) { SendMessage( hwnd, WM_COMMAND, IDM_FONTUP, 0 ) ; return 1 ; }\n\t\tif(key_num == VK_DOWN) { SendMessage( hwnd, WM_COMMAND, IDM_FONTDOWN, 0 ) ; return 1 ; }\n\t\tif(key_num == VK_LEFT ) {  ChangeFontSize(hwnd,0) ; return 1 ; }\n\t}*/\n\tif( control_flag && !shift_flag ) {\n\t\tif( TransparencyFlag && (conf_get_int(conf,CONF_transparencynumber)!=-1)&&(key_num == VK_UP) ) // Augmenter l'opacite (diminuer la transparence)\n\t\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_TRANSPARUP, 0 ) ; return 1 ; }\n\t\tif( TransparencyFlag && (conf_get_int(conf,CONF_transparencynumber)!=-1)&&(key_num == VK_DOWN) ) // Diminuer l'opacite (augmenter la transparence)\n\t\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_TRANSPARDOWN, 0 ) ; return 1 ; }\n\n\t\tif (key_num == VK_ADD) { SendMessage( hwnd, WM_COMMAND, IDM_FONTUP, 0 ) ; return 1 ; }\n\t\tif (key_num == VK_SUBTRACT) { SendMessage( hwnd, WM_COMMAND, IDM_FONTDOWN, 0 ) ; return 1 ; }\n\t\tif (key_num == VK_NUMPAD0) { ChangeFontSize(term,conf,hwnd,0) ; return 1 ; }\n#ifdef MOD_LAUNCHER\n\t\t/*    ====> Ne fonctionne pas !!!\n\t\tif (key_num == VK_LEFT ) //Fenetre KiTTY precedente\n\t\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_GOPREVIOUS, 0 ) ; return 1 ; }\n\t\tif (key_num == VK_RIGHT ) //Fenetre KiTTY Suivante\n\t\t\t{ SendMessage( hwnd, WM_COMMAND, IDM_GONEXT, 0 ) ; return 1 ; }\n\t\t*/\n#endif\n\t}\n\treturn 0 ;\n}\n\n// shift+bouton droit => paste ameliore pour serveur \"lent\"\n// Le paste utilise la methode \"autocommand\"\nvoid SetPasteCommand( HWND hwnd ) {\n\tif( !PasteCommandFlag ) return ;\n\tif( PasteCommand != NULL ) { free( PasteCommand ) ; PasteCommand = NULL ; }\n\tchar *pst = NULL ;\n\tif( OpenClipboard(NULL) ) {\n\t\tHGLOBAL hglb ;\n\t\tif( (hglb = GetClipboardData( CF_TEXT ) ) != NULL ) {\n\t\t\tif( ( pst = GlobalLock( hglb ) ) != NULL ) {\n\t\t\t\tPasteCommand = (char*) malloc( strlen(pst)+1 ) ;\n\t\t\t\tstrcpy( PasteCommand, pst ) ;\n\t\t\t\tSetTimer(hwnd, TIMER_AUTOPASTE, autocommand_delay, NULL) ;\n\t\t\t\tdebug_logevent( \"Sent paste command\" ) ;\n\t\t\t\tGlobalUnlock( hglb ) ;\n\t\t\t\t}\n\t\t\t}\n\t\tCloseClipboard();\n\t\t}\n\t}\n\t\n// Initialisation des parametres a partir du fichier kitty.ini\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\nvoid SetShrinkBitmapEnable(int) ;\n#endif\n\nvoid LoadParameters( void ) {\n\tchar buffer[4096] ;\n\n\t/* A lire en premier */\n\tif( ReadParameter( INIT_SECTION, \"debug\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) debug_flag = 1 ; }\n\t\n\tif( ReadParameter( \"Agent\", \"scrumble\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetScrumbleKeyFlag(1) ; }\n\n#ifdef MOD_ADB\n\tif( ReadParameter( INIT_SECTION, \"adb\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"YES\" ) ) SetADBFlag( 1 ) ; \n\t\tif( !stricmp( buffer, \"NO\" ) ) SetADBFlag( 0 ) ; \n\t}\n#endif\n\tif( ReadParameter( INIT_SECTION, \"antiidle\", buffer ) ) { buffer[127]='\\0'; strcpy( AntiIdleStr, buffer ) ; }\n\tif( ReadParameter( INIT_SECTION, \"antiidledelay\", buffer ) ) \n\t\t{ AntiIdleCountMax = (int)floor(atoi(buffer)/10.0) ; if( AntiIdleCountMax<=0 ) AntiIdleCountMax =1 ; }\n\tif( ReadParameter( INIT_SECTION, \"autostoresshkey\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetAutoStoreSSHKeyFlag( 1 ) ; }\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\t//if( debug_flag )\n\tif( ReadParameter( INIT_SECTION, \"bgimage\", buffer ) ) {\t\n\t\tif( !stricmp( buffer, \"NO\" ) ) SetBackgroundImageFlag( 0 ) ; \n\t\tif( !stricmp( buffer, \"YES\" ) ) SetBackgroundImageFlag( 1 ) ;  // Broken en 0.71 ==> on desactive\n\t}\n#endif\n\tif( ReadParameter( INIT_SECTION, \"bcdelay\", buffer ) ) { between_char_delay = atoi( buffer ) ; }\n\tif( ReadParameter( INIT_SECTION, \"browsedirectory\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"NO\" ) ) { DirectoryBrowseFlag = 0 ; }\n\t\telse if( (!stricmp( buffer, \"YES\" )) && (IniFileFlag==SAVEMODE_DIR) ) DirectoryBrowseFlag = 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"capslock\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) CapsLockFlag = 1 ; }\n\tif( ReadParameter( INIT_SECTION, \"commanddelay\", buffer ) ) {\n\t\tautocommand_delay = (int)(1000*atof( buffer )) ;\n\t\tif(autocommand_delay<5) autocommand_delay = 5 ; \n\t}\n\tif( ReadParameter( INIT_SECTION, \"conf\", buffer ) ) { if( !stricmp( buffer, \"NO\" ) ) NoKittyFileFlag = 1 ; }\n\tif( ReadParameter( INIT_SECTION, \"configdir\", buffer ) ) { \n\t\tif( strlen( buffer ) > 0 ) { if( existdirectory(buffer) ) SetConfigDirectory( buffer ) ; }\n\t}\n\tif( ReadParameter( INIT_SECTION, \"cryptsalt\", buffer ) ) { SetCryptSaltFlag( atoi(buffer) ) ; }\n\tif( ReadParameter( INIT_SECTION, \"ctrltab\", buffer ) ) { if( !stricmp( buffer, \"NO\" ) ) SetCtrlTabFlag( 0 ) ; }\n#ifdef MOD_HYPERLINK\n#ifndef MOD_NOHYPERLINK\n\tif( ReadParameter( INIT_SECTION, \"hyperlink\", buffer ) ) {  \n\t\tif( !stricmp( buffer, \"NO\" ) ) HyperlinkFlag = 0 ; \n\t\tif( !stricmp( buffer, \"YES\" ) ) HyperlinkFlag = 1 ;\n\t}\n#endif\n#endif\n\tif( ReadParameter( INIT_SECTION, \"icon\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) IconeFlag = 1 ; }\n\tif( ReadParameter( INIT_SECTION, \"iconfile\", buffer ) ) {\n\t\tif( existfile( buffer ) ) {\n\t\t\tif( IconFile != NULL ) free( IconFile ) ;\n\t\t\tIconFile = (char*) malloc( strlen(buffer)+1 ) ;\n\t\t\tstrcpy( IconFile, buffer ) ;\n\t\t\tif( ReadParameter( INIT_SECTION, \"numberoficons\", buffer ) ) { NumberOfIcons = atof( buffer ) ; }\n\t\t}\n\t}\n\tif( ReadParameter( INIT_SECTION, \"initdelay\", buffer ) ) { \n\t\tinit_delay = (int)(1000*atof( buffer )) ;\n\t\tif( init_delay < 0 ) init_delay = 2000 ; \n\t}\n\tif( ReadParameter( INIT_SECTION, \"internaldelay\", buffer ) ) { \n\t\tinternal_delay = atoi( buffer ) ; \n\t\tif( internal_delay < 1 ) internal_delay = 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"fileextension\", buffer ) ) {\n\t\tif( strlen(buffer) > 0 ) {\n\t\t\tif( buffer[0] != '.' ) { strcpy( FileExtension, \".\" ) ; } else { strcpy( FileExtension, \"\" ) ; }\n\t\t\tstrcat( FileExtension, buffer ) ;\n\t\t\twhile( FileExtension[strlen(FileExtension)-1]==' ' ) { FileExtension[strlen(FileExtension)-1] = '\\0' ; }\n\t\t}\t\t\t\t\n\t}\n\tif( ReadParameter( INIT_SECTION, \"hostkeyextension\", buffer ) ) {\n\t\tif( strlen(buffer) > 0 ) { SetHostKeyExtension(buffer) ; }\n\t}\n\tif( ReadParameter( INIT_SECTION, \"KiPP\", buffer ) != 0 ) {\n\t\tif( decryptstring( GetCryptSaltFlag(), buffer, MASTER_PASSWORD ) ) ManagePassPhrase( buffer ) ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"localcmd\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) LocalCmdFlag = 0 ;\n\t\tif( !stricmp( buffer, \"YES\" ) ) LocalCmdFlag = 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"localunsecurecmd\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) LocalUnsecureCmdFlag = 0 ;\n\t\tif( !stricmp( buffer, \"YES\" ) ) LocalUnsecureCmdFlag = 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"maxblinkingtime\", buffer ) ) { MaxBlinkingTime=2*atoi(buffer);if(MaxBlinkingTime<0) MaxBlinkingTime=0; }\n\tif( ReadParameter( INIT_SECTION, \"mouseshortcuts\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"NO\" ) ) MouseShortcutsFlag = 0 ;\n\t\tif( !stricmp( buffer, \"YES\" ) ) MouseShortcutsFlag = 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"paste\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) PasteCommandFlag = 1 ; }\n\tif( ReadParameter( INIT_SECTION, \"pastesize\", buffer ) ) { if( atoi(buffer)>0 ) SetPasteSize( atoi(buffer) ) ; }\n\tif( ReadParameter( INIT_SECTION, \"PSCPPath\", buffer ) ) {\n\t\tif( existfile( buffer ) ) { \n\t\t\tif( PSCPPath!=NULL) { free(PSCPPath) ; PSCPPath = NULL ; }\n\t\t\tPSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( PSCPPath, buffer ) ;\n\t\t}\n\t}\n\tif( ReadParameter( INIT_SECTION, \"readonly\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetReadOnlyFlag(1) ; }\n\tif( ReadParameter( INIT_SECTION, \"sav\", buffer ) ) { \n\t\tif( strlen( buffer ) > 0 ) {\n\t\t\tif( KittySavFile!=NULL ) free( KittySavFile ) ;\n\t\t\tKittySavFile=(char*)malloc( strlen(buffer)+1 ) ;\n\t\t\tstrcpy( KittySavFile, buffer) ;\n\t\t}\n\t}\n\tif( ReadParameter( INIT_SECTION, \"shortcuts\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"NO\" ) ) ShortcutsFlag = 0 ; \n\t\tif( !stricmp( buffer, \"YES\" ) ) ShortcutsFlag = 1 ; \n\t}\n\tif( ReadParameter( INIT_SECTION, \"size\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SizeFlag = 1 ; }\n\tif( ReadParameter( INIT_SECTION, \"slidedelay\", buffer ) ) { ImageSlideDelay = atoi( buffer ) ; }\n\tif( ReadParameter( INIT_SECTION, \"sshversion\", buffer ) ) { set_sshver( buffer ) ; }\n\tif( ReadParameter( INIT_SECTION, \"userpasssshnosave\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"no\" ) ) SetUserPassSSHNoSave(0) ;\n\t\tif( !stricmp( buffer, \"yes\" ) ) SetUserPassSSHNoSave(1) ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"winroll\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"no\" ) ) WinrolFlag = 0 ;\n\t\tif( !stricmp( buffer, \"yes\" ) ) WinrolFlag = 1 ;\n\t}\n\tif( ReadParameter( INIT_SECTION, \"WinSCPPath\", buffer ) ) {\n\t\tif( existfile( buffer ) ) { \n\t\t\tif( WinSCPPath!=NULL) { free(WinSCPPath) ; WinSCPPath = NULL ; }\n\t\t\tWinSCPPath = (char*) malloc( strlen(buffer) + 1 ) ; strcpy( WinSCPPath, buffer ) ;\n\t\t}\n\t}\n\tif( ReadParameter( INIT_SECTION, \"wintitle\", buffer ) ) { if( !stricmp( buffer, \"NO\" ) ) TitleBarFlag = 0 ; }\n#ifdef MOD_PROXY\n\tif( ReadParameter( \"ConfigBox\", \"proxyselection\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"YES\" ) ) { SetProxySelectionFlag(1) ; }\n\t}\n#endif\n#ifdef MOD_ZMODEM\n\tif( ReadParameter( INIT_SECTION, \"zmodem\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"NO\" ) ) SetZModemFlag( 0 ) ; \n//\t\tif( !stricmp( buffer, \"YES\" ) ) SetZModemFlag( 1 ) ; // ZModem ne marche plsu: on peut réactiver pour tester en passant -zmodem\n\t\t}\n#endif\n#ifdef MOD_RECONNECT\n\tif( ReadParameter( INIT_SECTION, \"autoreconnect\", buffer ) ) { if( !stricmp( buffer, \"NO\" ) ) AutoreconnectFlag = 0 ; }\n\tif( ReadParameter( INIT_SECTION, \"ReconnectDelay\", buffer ) ) { \n\t\tReconnectDelay = atoi( buffer ) ;\n\t\tif( ReconnectDelay < 1 ) ReconnectDelay = 1 ;\n\t}\n#endif\n#ifdef MOD_RUTTY\n\tif( ReadParameter( INIT_SECTION, \"scriptmode\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"YES\" ) ) RuttyFlag = 1 ;\n\t\tif( !stricmp( buffer, \"NO\" ) ) RuttyFlag = 0 ;\n\t}\n#endif\n#ifndef MOD_NOTRANSPARENCY\n\tif( ReadParameter( INIT_SECTION, \"transparency\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"YES\" ) ) { TransparencyFlag = 1 ; }\n\t\telse { TransparencyFlag = 0 ; } \n\t}\n#endif\n\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( ReadParameter( INIT_SECTION, \"shrinkbitmap\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetShrinkBitmapEnable(1) ; else SetShrinkBitmapEnable(0) ; }\n#endif\n\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"dblclick\", buffer ) ) {\n\t\tif( !strcmp(buffer,\"open\") ) { SetDblClickFlag(0) ; }\n\t\tif( !strcmp(buffer,\"start\") ) { SetDblClickFlag(1) ; }\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"height\", buffer ) ) {\n\t\tConfigBoxHeight = atoi( buffer ) ;\n#ifdef MOD_PROXY\n\t\tif( GetProxySelectionFlag() ) { ConfigBoxHeight-=1 ; }\n#endif\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"windowheight\", buffer ) ) {\n\t\tConfigBoxWindowHeight = atoi( buffer ) ;\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"noexit\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"YES\" ) ) ConfigBoxNoExitFlag = 1 ;\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"filter\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) SessionFilterFlag = 0 ;\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"default\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) SessionsInDefaultFlag = 0 ;\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"defaultsettings\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) DefaultSettingsFlag = 0 ;\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"left\", buffer ) ) {\n\t\tSetConfigBoxLeft( atoi(buffer) ) ;\n\t}\n\tif( readINI( KittyIniFile, \"ConfigBox\", \"top\", buffer ) ) {\n\t\tSetConfigBoxTop( atoi(buffer) ) ;\n\t}\n\t\n\t// Param RandomActiveFlag défini dans kitty_commun.c\n\t// Pour gérer le bug sur certaines machines:  https://github.com/cyd01/KiTTY/issues/113\n\tif( readINI( KittyIniFile, \"Debug\", \"randomactive\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) SetRandomActiveFlag( 0 ) ;\n\t\tif( !stricmp( buffer, \"YES\" ) ) SetRandomActiveFlag( 1 ) ;\n\t}\n\n\tif( readINI( KittyIniFile, \"Print\", \"height\", buffer ) ) {\n\t\tPrintCharSize = atoi( buffer ) ;\n\t}\n\tif( readINI( KittyIniFile, \"Print\", \"maxline\", buffer ) ) {\n\t\tPrintMaxLinePerPage = atoi( buffer ) ;\n\t}\n\tif( readINI( KittyIniFile, \"Print\", \"maxchar\", buffer ) ) {\n\t\tPrintMaxCharPerLine = atoi( buffer ) ;\n\t}\n\tif( readINI( KittyIniFile, \"Folder\", \"del\", buffer ) ) {\n\t\tStringList_Del( FolderList, buffer ) ;\n\t\tdelINI( KittyIniFile, \"Folder\", \"del\" ) ;\n\t}\n}\n\n// Initialisation de noms de fichiers de configuration kitty.ini et kitty.sav\n// APPDATA = \tC:\\Documents and Settings\\U502190\\Application Data sur XP\n//\t\tC:\\Users\\Cyril\\AppData\\Roaming sur Vista\n//\n// En mode base de registre on cherche le fichier de configuration\n// - dans la variable d'environnement KITTY_INI_FILE\n// - kitty.ini dans le repertoire de lancement de kitty.exe s'il existe\n// - sinon putty.ini dans le repertoire de lancement de kitty.exe s'il existe\n// - sinon kitty.ini dans le repertoire %APPDATA%/KiTTY s'il existe\n//\n// En mode portable on cherche le fichier de configuration\n// - kitty.ini dans le repertoire de lancement de kitty.exe s'il existe\n// - sinon putty.ini dans le repertoire de lancement de kitty.exe s'il existe\n// \nvoid InitNameConfigFile( void ) {\n\tchar buffer[4096] ;\n\tif( KittyIniFile != NULL ) { free( KittyIniFile ) ; }\n\tKittyIniFile=NULL ;\n\n\tif( getenv(\"KITTY_INI_FILE\") != NULL ) { strcpy( buffer, getenv(\"KITTY_INI_FILE\") ) ; }\n\tif( !existfile( buffer ) ) {\n\t\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, DEFAULT_INIT_FILE ) ;\n\t\tif( !existfile( buffer ) ) {\n\t\t\tsprintf( buffer, \"%s\\\\putty.ini\", InitialDirectory ) ;\n\t\t\tif( !existfile( buffer ) ) {\n\t\t\t\tif( IniFileFlag != SAVEMODE_DIR ) {\n\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION, DEFAULT_INIT_FILE ) ;\n\t\t\t\t\tif( !existfile( buffer ) ) {\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION ) ;\n\t\t\t\t\t\tCreateDirectory( buffer, NULL ) ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION, DEFAULT_INIT_FILE ) ;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, DEFAULT_INIT_FILE ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tKittyIniFile=(char*)malloc( strlen( buffer)+2 ) ; strcpy( KittyIniFile, buffer) ;\n\n\tif( KittySavFile != NULL ) { free( KittySavFile ) ; } \n\tKittySavFile=NULL ;\n\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, DEFAULT_SAV_FILE ) ;\n\tif( !existfile( buffer ) ) {\n\t\tif( IniFileFlag != SAVEMODE_DIR ) {\n\t\t\tsprintf( buffer, \"%s\\\\%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION, DEFAULT_SAV_FILE ) ;\n\t\t\tif( !existfile( buffer ) ) {\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION ) ;\n\t\t\t\tCreateDirectory( buffer, NULL ) ;\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\\\\%s\", getenv(\"APPDATA\"), INIT_SECTION, DEFAULT_SAV_FILE ) ;\n\t\t\t}\n\t\t}\n\t}\n\tKittySavFile=(char*)malloc( strlen( buffer)+2 ) ; strcpy( KittySavFile, buffer) ;\n\t\n\tsprintf( buffer, \"%s\\\\kitty.dft\", InitialDirectory ) ;\n\tif( existfile( KittyIniFile ) && existfile( buffer ) )  unlink( buffer ) ;\n\tif( !existfile( KittyIniFile ) )\n\t\tif( existfile( buffer ) ) rename( buffer, KittyIniFile ) ;\n}\n\t\n// Ecriture de l'increment de compteurs\nvoid WriteCountUpAndPath( void ) {\n\t// Sauvegarde la liste des folders\n\tSaveFolderList() ;\n\t\t\n\t// Incremente le compteur d'utilisation\n\tCountUp() ;\n\n\t// Positionne la version du binaire\n\tWriteParameter( INIT_SECTION, \"Build\", BuildVersionTime ) ;\n\t\n\t// Recherche cthelper.exe s'il existe\n\tSearchCtHelper() ;\n\t\t\n\t// Recherche pscp s'il existe\n\tSearchPSCP() ;\n\t\n\t// Recherche plink s'il existe\n\tSearchPlink() ;\n\n\t// Recherche WinSCP s'il existe\n\tSearchWinSCP() ;\n\t}\n\n// Initialisation specifique a KiTTY\nvoid appendPath(const char *append) ;\nextern char sesspath[];\nint loadPath() ;\nvoid InitWinMain( void ) {\n\tchar buffer[4096];\n\tint i ;\n\t\n\tsrand(time(NULL));\n\t\n\tif( existfile(\"kitty.log\") ) { unlink( \"kitty.log\" ) ; }\n\t\n#ifdef FLJ\n\tCreateSSHHandler();\n\tCreateFileAssoc() ;\n\tSetADBFlag(0) ;\n#else\n\t//if( !RegTestKey(HKEY_CLASSES_ROOT,\"kitty.connect.1\") ) { CreateFileAssoc() ; }\n#endif\n\n\t// Initialisation de la version binaire\n\tsprintf( BuildVersionTime, \"%s.%d @ %s\", BUILD_VERSION, BUILD_SUBVERSION, BUILD_TIME ) ;\n#ifdef MOD_PORTABLE\n\tsprintf( BuildVersionTime, \"%s.%dp @ %s\", BUILD_VERSION, BUILD_SUBVERSION, BUILD_TIME ) ;\n#endif\n#ifdef MOD_NOTRANSPARENCY\n\tsprintf( BuildVersionTime, \"%s.%dn @ %s\", BUILD_VERSION, BUILD_SUBVERSION, BUILD_TIME ) ;\n#endif\t\n\n\t// Initialisation de la librairie de cryptage\n\tbcrypt_init( 0 ) ;\n\t\n\t// Recupere le repertoire de depart et le repertoire de la configuration pour savemode=dir\n\tGetInitialDirectory( InitialDirectory ) ;\n\t\n\t// Initialise les noms des fichier de configuration kitty.ini et kitty.sav\n\tInitNameConfigFile() ;\n\n\t// Initialisation du nom de la classe\n\tstrcpy( KiTTYClassName, appname ) ;\n\n#if (defined MOD_PERSO) && (!defined FLJ)\n\tif( ReadParameter( INIT_SECTION, \"KiClassName\", buffer ) ) \n\t\t{ if( (strlen(buffer)>0) && (strlen(buffer)<128) ) { buffer[127]='\\0'; strcpy( KiTTYClassName, buffer ) ; } }\n\tappname = KiTTYClassName ;\n#endif\n\n\t// Initialise le tableau des menus\n\tfor( i=0 ; i < NB_MENU_MAX ; i++ ) SpecialMenu[i] = NULL ;\n\t\n\t// Test le mode de fonctionnement de la sauvegarde des sessions\n\tGetSaveMode() ;\n\n\t// Initialisation des parametres à partir du fichier kitty.ini\n\tLoadParameters() ;\n\n\t// Ajoute les répertoires InitialDirectory et ConfigDirectory au PATH\n\n\t// Initialisation des shortcuts\n\tInitShortcuts() ;\n\n\t// Chargement de la base de registre si besoin\n\tif( IniFileFlag == SAVEMODE_REG ) { // Mode de sauvegarde registry\n\t\t// Si la cle n'existe pas ...\n\t\tif( !RegTestKey( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS) ) ) { \n\t\t\tHWND hdlg = InfoBox( hinst, NULL ) ;\n\t\t\tif( existfile( KittySavFile ) ) {// ... et que le fichier kitty.sav existe on le charge ...\n\t\t\t\tInfoBoxSetText( hdlg, \"Initializing registry.\" ) ;\n\t\t\t\tInfoBoxSetText( hdlg, \"Loading saved sessions from file.\" ) ;\n\t\t\t\tLoadRegistryKey( hdlg ) ; \n\t\t\t\tInfoBoxClose( hdlg ) ;\n\t\t\t} else { // Sinon on regarde si il y a la cle de PuTTY et on la recupere\n\t\t\t\tInfoBoxSetText( hdlg, \"Initializing registry.\" ) ;\n\t\t\t\tInfoBoxSetText( hdlg, \"First time running. Loading saved sessions from PuTTY registry.\" ) ;\n\t\t\t\tTestRegKeyOrCopyFromPuTTY( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS) ) ; \n\t\t\t\tInfoBoxClose( hdlg ) ;\n\t\t\t}\n\t\t}\n\t} else if( IniFileFlag == SAVEMODE_FILE ){ // Mode de sauvegarde fichier\n\t\tif( !RegTestKey( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS) ) ) { // la cle de registre n'existe pas \n\t\t\tHWND hdlg = InfoBox( hinst, NULL ) ;\n\t\t\tInfoBoxSetText( hdlg, \"Initializing registry.\" ) ;\n\t\t\tInfoBoxSetText( hdlg, \"Loading saved sessions from file.\" ) ;\n\t\t\tLoadRegistryKey( hdlg ) ; \n\t\t\tInfoBoxClose( hdlg ) ;\n\t\t\t}\n#ifdef MOD_PERSO\n\t\telse { // la cle de registre existe deja\n\t\t\tif( WindowsCount( MainHwnd ) == 1 ) { // Si c'est le 1er kitty on sauvegarde la cle de registre avant de charger le fichier kitty.sav\n\t\t\t\tHWND hdlg = InfoBox( hinst, NULL ) ;\n\t\t\t\tInfoBoxSetText( hdlg, \"Initializing registry.\" ) ;\n\t\t\t\tRegRenameTree( hdlg, HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), TEXT(PUTTY_REG_POS_SAVE) ) ;\n\t\t\t\tInfoBoxSetText( hdlg, \"Loading saved sessions.\" ) ;\n\t\t\t\tLoadRegistryKey( hdlg ) ;\n\t\t\t\tInfoBoxClose( hdlg ) ;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\telse if( IniFileFlag == SAVEMODE_DIR ){ // Mode de sauvegarde directory\n\t\tif( strlen(sesspath) == 0 ) { loadPath() ; }\n\t\t/* Test Default Settings */\n\t\t/*\n\t\tchar * defaultfile = (char*)malloc( strlen(sesspath)+20 ) ;\n\t\tsprintf( defaultfile, \"%s\\\\Default Settings\", sesspath ) ;\n\t\tif( !existfile(defaultfile) && GetDefaultSettingsFlag() ) {\n\t\t\tcreate_settings(\"Default Settings\") ;\n\t\t}\n\t\tfree( defaultfile ) ;\n\t\t*/\n\t}\n\n\t// Make mandatory registry keys\n\tsprintf( buffer, \"%s\\\\%s\", TEXT(PUTTY_REG_POS), \"Commands\" ) ;\n\tif( (IniFileFlag == SAVEMODE_REG)||( IniFileFlag == SAVEMODE_FILE) ) \n\t\tRegTestOrCreate( HKEY_CURRENT_USER, buffer, NULL, NULL ) ;\n\n#ifdef MOD_PROXY\n\t// Initiate proxies list\n\tInitProxyList() ;\n#endif\n#ifdef MOD_LAUNCHER\n\t// Initiate launcher\n\tsprintf( buffer, \"%s\\\\%s\", TEXT(PUTTY_REG_POS), \"Launcher\" ) ;\n\tif( (IniFileFlag == SAVEMODE_REG)||( IniFileFlag == SAVEMODE_FILE) )  \n\t\tif( !RegTestKey( HKEY_CURRENT_USER, buffer ) ) { InitLauncherRegistry() ; }\n#endif\n\t// Initiate folders list\n\tInitFolderList() ;\n\n\t// Incremente et ecrit les compteurs\n\tif( IniFileFlag == SAVEMODE_REG ) {\n\t\tWriteCountUpAndPath() ;\n\t}\n\n\t// Initialise la gestion des icones depuis la librairie kitty.dll si elle existe\n\tif( !GetPuttyFlag() ) {\n\t\tif( IconFile != NULL )\n\t\tif( existfile( IconFile ) ) \n\t\t\t{ HMODULE hDll ; if( ( hDll = LoadLibrary( TEXT(IconFile) ) ) != NULL ) hInstIcons = hDll ; }\n\t\tif( hInstIcons==NULL )\n\t\tif( existfile( \"kitty.dll\" ) ) \n\t\t\t{ HMODULE hDll ; if( ( hDll = LoadLibrary( TEXT(\"kitty.dll\") ) ) != NULL ) hInstIcons = hDll ; }\n\t\t}\n\n\t// Teste la presence d'une note et l'affiche\n\tif( GetValueData( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), \"Notes\", buffer ) ) \n\t\t{ if( strlen( buffer ) > 0 ) MessageBox( NULL, buffer, \"Notes\", MB_OK ) ; }\n\t\t\n\t// Genere un fichier (4096ko max) d'initialisation de toute les Sessions\n\tsprintf( buffer, \"%s\\\\%s.ses.updt\", InitialDirectory, appname ) ;\n\tif( existfile( buffer ) ) { InitAllSessions( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), \"Sessions\", buffer ) ; }\n\t/* Format: registry like => UTF-8 encoded !!!\n\t\"ProxyUsername\"=\"mylogin\"\n\t\"ProxyPassword\"=\"mypassword\"\n\t*/\n\t\n\t// Initialise les logs\n\tchar hostname[4096], username[4096] ;\n\tGetUserName( username, (void*)&i ) ;\n\ti = 4095 ;\n\tGetComputerName( hostname, (void*)&i ) ;\n\tsprintf( buffer, \"Starting %ld from %s@%s\", GetCurrentProcessId(), username, hostname ) ;\n\tdebug_logevent(buffer) ;\n}\n\n\n/* Pour compilation 64bits */\n/*\nvoid bzero (void *s, size_t n){ memset (s, 0, n); }\nvoid bcopy (const void *src, void *dest, size_t n){ memcpy (dest, src, n); }\nint bcmp (const void *s1, const void *s2, size_t n){ return memcmp (s1, s2, n); }\n*/\n\n\n\n// Commandes internes\nint InternalCommand( HWND hwnd, char * st ) ;\n\n// Positionne le repertoire ou se trouve la configuration \nvoid SetConfigDirectory( const char * Directory ) ;\n\n// Creation du fichier kitty.ini par defaut si besoin\nvoid CreateDefaultIniFile( void ) ;\n\n// Initialisation des parametres a partir du fichier kitty.ini\nvoid LoadParameters( void ) ;\n\n// Initialisation de noms de fichiers de configuration kitty.ini et kitty.sav\nvoid InitNameConfigFile( void ) ;\n\n// Ecriture de l'increment de compteurs\nvoid WriteCountUpAndPath( void ) ;\n\n// Initialisation spécifique a KiTTY\nvoid InitWinMain( void ) ;\n\n// Initialisation des shortcuts\nvoid InitShortcuts( void ) ;\nint DefineShortcuts( char * buf ) ;\n\n// Gestion de commandes a distance\nint ManageLocalCmd( HWND hwnd, const char * cmd ) ;\n\n// Gestion des raccourcis\nint ManageShortcuts( Terminal *term, Conf *conf, HWND hwnd, const int* clips_system, int key_num, int shift_flag, int control_flag, int alt_flag, int altgr_flag, int win_flag ) ;\n\n// Nettoie la clé de PuTTY pour enlever les clés et valeurs spécifique à KiTTY\n// Se trouve dans le fichier kitty_registry.c\nBOOL RegCleanPuTTY( void ) ;\n\n// Envoi de caractères\nvoid SendKeyboardPlus( HWND hwnd, const char * st ) ;\n\n// Envoi d'une commande à l'écran\nvoid SendAutoCommand( HWND hwnd, const char * cmd ) ;\n"
        },
        {
          "name": "kitty.h",
          "type": "blob",
          "size": 19.771484375,
          "content": "#ifndef KITTY_H\n#define KITTY_H\n#include <math.h>\n#include <sys/types.h>\n#include <process.h>\n#include <time.h>\n\n// Handle sur la fenetre principale\n//extern HWND MainHwnd ;\nHWND GetMainHwnd(void) ;\n\n\n/*****************************************************\n** DEFINITION DES VARIABLES STATIQUE DE kitty.c\n** ET DE LEUR FONCTIONS D'ACCES ET DE MODIFICATION\n*****************************************************/\n// Flag pour retourner à la Config Box en fin d'execution\n// extern int ConfigBoxNoExitFlag ;\nint GetConfigBoxNoExitFlag(void) ;\n\n// ConfigBox X-position\nint GetConfigBoxLeft() ;\nvoid SetConfigBoxLeft( const int val ) ;\n\n// ConfigBox Y-position\nint GetConfigBoxTop();\nvoid SetConfigBoxTop( const int val ) ;\n\n// Flag pour inhiber la gestion du CTRL+TAB\nint GetCtrlTabFlag(void) ;\nvoid SetCtrlTabFlag( const int flag ) ;\n\n// Flag pour afficher l'image de fond\n//extern int BackgroundImageFlag ;\nint GetBackgroundImageFlag(void) ;\nvoid SetBackgroundImageFlag( const int flag ) ;\n\n#ifdef MOD_RECONNECT\n// Flag pour inhiber le mécanisme de reconnexion automatique\nint GetAutoreconnectFlag( void ) ;\nvoid SetAutoreconnectFlag( const int flag ) ;\n// Delai avant de tenter une reconnexion automatique\nint GetReconnectDelay(void) ;\n#endif\n\n// Delai avant d'envoyer le password et d'envoyer vers le tray (automatiquement à la connexion) (en milliseconde)\nextern int init_delay ;\n\n// Delai entre chaque ligne de la commande automatique (en milliseconde)\nextern int autocommand_delay ;\n\n// Delai entre chaque caracteres d'une commande (en millisecondes)\nextern int between_char_delay ;\n\n// Delai entre deux lignes d'une meme commande et entre deux raccourcis \\x \\k\nextern int internal_delay ;\n\n// Nom de la classe de l'application\nextern char KiTTYClassName[128] ;\n\n// Flag pour imposer le passage en majuscule\n// extern int CapsLockFlag ;\nint GetCapsLockFlag(void) ;\nvoid SetCapsLockFlag( const int flag ) ;\n\n// Flag pour gerer la presence de la barre de titre\n// extern int TitleBarFlag ;\nint GetTitleBarFlag(void) ;\nvoid SetTitleBarFlag( const int flag ) ;\n\n// Flag pour passer en mode visualiseur d'images\n// extern int ImageViewerFlag ;\nint GetImageViewerFlag(void) ;\nvoid SetImageViewerFlag( const int flag ) ;\n\n#ifdef MOD_PROXY\n// Flag pour ajouter la fonction Proxy Selector\n// extern int ProxySelectionFlag ;\nint GetProxySelectionFlag() ;\nvoid SetProxySelectionFlag( const int flag ) ;\n#endif\n\n// Duree (en secondes) pour switcher l'image de fond d'ecran (<=0 pas de slide)\nextern int ImageSlideDelay ;\n\n// Nombre de clignotements max de l'icone dans le systeme tray lors de la reception d'un BELL\nextern int MaxBlinkingTime ;\n\n// Flag pour l'affichage de la taille de la fenetre\n// extern int SizeFlag ;\nint GetSizeFlag(void) ;\nvoid SetSizeFlag( const int flag ) ;\n\n// Flag pour la protection contre les saisies malheureuses\n// extern int ProtectFlag ; \nint GetProtectFlag(void) ;\nvoid SetProtectFlag( const int flag ) ;\n\n// Flag de definition de la visibilite d'une fenetres\n// extern int VisibleFlag ;\nint GetVisibleFlag(void) ;\nvoid SetVisibleFlag( const int flag ) ;\n\n// Gestion du script file au lancement\nextern char * ScriptFileContent ;\n\n// Flag pour inhiber les raccourcis clavier\n// extern int ShortcutsFlag ;\nint GetShortcutsFlag(void) ;\nvoid SetShortcutsFlag( const int flag ) ;\n\n// Flag pour inhiber les raccourcis souris\n// extern int MouseShortcutsFlag ;\nint GetMouseShortcutsFlag(void) ;\nvoid SetMouseShortcutsFlag( const int flag ) ;\n\n// Stuff for drag-n-drop\n#ifndef TIMER_DND\n#define TIMER_DND 8777\n#endif\nextern HDROP hDropInf;\nvoid recupNomFichierDragDrop(HWND hwnd, HDROP* leDrop) ;\n\n// Pointeur sur la commande autocommand\nextern char * AutoCommand ;\n\n// Contenu d'un script a envoyer à l'ecran\nextern char * ScriptCommand ;\n\n// Pointeur sur la commande a passer ligne a ligne\nextern char * PasteCommand ;\nint GetPasteCommandFlag(void) ;\n\n// paste size limit (number of characters). Above the limit a confirmation is requested. (0 means unlimited)\nint GetPasteSize(void) ;\nvoid SetPasteSize( const int size ) ;\n\n// Flag de gestion de la fonction hyperlink\nextern int HyperlinkFlag ;\nint GetHyperlinkFlag(void) ;\nvoid SetHyperlinkFlag( const int flag ) ;\n\n// Flag de gestion de la fonction \"rutty\" (script automatique)\n//extern int RuttyFlag ;\nint GetRuttyFlag(void) ;\nvoid SetRuttyFlag( const int flag ) ;\n\n// Flag pour le fonctionnement en mode \"portable\" (gestion par fichiers), defini dans kitty_commun.c\nextern int IniFileFlag ;\nint GetIniFileFlag(void) ;\nvoid SetIniFileFlag( const int flag ) ;\nvoid SwitchIniFileFlag(void) ;\n\n// Flag permettant la gestion de l'arborscence (dossier=folder) dans le cas d'un savemode=dir, defini dans kitty_commun.c\n//extern int DirectoryBrowseFlag ;\nint GetDirectoryBrowseFlag(void) ;\nvoid SetDirectoryBrowseFlag( const int flag ) ;\n\n// Renvoi automatiquement dans le tray (pour les tunnel), fonctionne avec le l'option -send-to-tray\n//extern int AutoSendToTray ;\nint GetAutoSendToTray( void ) ;\nvoid SetAutoSendToTray( const int flag ) ;\n\n// Flag de gestion de la Transparence\n// extern int TransparencyFlag ;\nint GetTransparencyFlag(void) ;\nvoid SetTransparencyFlag( const int flag ) ;\n\n#ifdef MOD_ZMODEM\n// Flag pour inhiber les fonctions ZMODEM\n// extern int ZModemFlag ;\nint GetZModemFlag(void) ;\nvoid SetZModemFlag( const int flag ) ;\n#endif\n\n// Flag pour ne pas creer les fichiers kitty.ini et kitty.sav\n// extern int NoKittyFileFlag ;\nint GetNoKittyFileFlag(void) ;\nvoid SetNoKittyFileFlag( const int flag ) ;\n\n// Hauteur de la boite de configuration\n// extern int ConfigBoxHeight ;\nint GetConfigBoxHeight(void) ;\nvoid SetConfigBoxHeight( const int num ) ;\n\n// Hauteur de la fenetre de la boite de configuration (0=valeur par defaut)\n// static int ConfigBoxWindowHeight = 0 ;\nint GetConfigBoxWindowHeight(void) ;\nvoid SetConfigBoxWindowHeight( const int num ) ;\n\n// Hauteur de la fenetre pour la fonction winrol\n// extern int WinHeight ;\nint GetWinHeight(void) ;\nvoid SetWinHeight( const int num ) ;\n// Flag pour inhiber le Winrol\n// extern int WinrolFlag = 1 \nint GetWinrolFlag(void) ;\nvoid SetWinrolFlag( const int num ) ;\n\n// Flag permettant de desactiver la sauvegarde automatique des informations de connexion (user/password) à la connexion SSH\n// extern int UserPassSSHNoSave ; ==> Defini dans kitty_commun.c\nint GetUserPassSSHNoSave(void) ;\nvoid SetUserPassSSHNoSave( const int flag ) ;\n\n// Flag pour inhiber le filtre sur la liste des sessions de la boite de configuration\n// extern int SessionFilterFlag ;\n// [ConfigBox] filter=yes\nint GetSessionFilterFlag(void) ;\nvoid SetSessionFilterFlag( const int flag ) ;\n\n// Flag pour inhiber le comportement ou toutes les sessions appartiennent au folder defaut\n// [ConfigBox] default=yes\nint GetSessionsInDefaultFlag(void) ;\nvoid SetSessionsInDefaultFlag( const int flag ) ;\n\n// Flag pour inhiber la création automatique de la session Default Settings\n// [ConfigBox] defaultsettings=yes\nint GetDefaultSettingsFlag(void) ;\nvoid SetDefaultSettingsFlag( const int flag ) ;\n\n// Flag pour définir l'action a executer sur un double clic sur une session de la liste des sessions\n// [ConfigBox] dblclick=open\nint GetDblClickFlag(void) ;\nvoid SetDblClickFlag( const int flag ) ;\n\n#ifdef MOD_ADB\n// Flag pour inhiber le support d'ADB\nint GetADBFlag(void) ;\nvoid SetADBFlag( const int flag ) ;\n#endif\n\n// Chemin vers le programme cthelper.exe\nextern char * CtHelperPath ;\n\n// Chemin vers le programme WinSCP\nextern char * WinSCPPath ;\n\n// Chemin vers le programme pscp.exe\nextern char * PSCPPath  ;\n\n// Repertoire de lancement\nextern char InitialDirectory[4096] ;\n\n// Extention pour les fichiers de session en mode portable (peut être ktx)\nextern char FileExtension[15] ;\n\n// Répertoire de sauvegarde de la configuration (savemode=dir)\nextern char * ConfigDirectory ;\n\n// Positionne un flag permettant de determiner si on est connecte\nextern int is_backend_connected ;\n\n#ifdef MOD_RECONNECT\n/* Variable permettant de savoir qu'on a deja ete connecte */\nextern int is_backend_first_connected ; \n#endif\n\n/* Flag pour interdire l'ouverture de boite configuration */\nextern int force_reconf ; \n\n// Compteur pour l'envoi de anti-idle\nextern int AntiIdleCount ;\nextern int AntiIdleCountMax ;\nextern char AntiIdleStr[128] ;\n\nNOTIFYICONDATA TrayIcone ;\n#ifndef MYWM_NOTIFYICON\n#define MYWM_NOTIFYICON\t\t(WM_USER+3)\n#endif\n\n// Flag pour permettre la definition d'icone de connexion\n// extern int IconeFlag ;\nint GetIconeFlag(void) ;\nvoid SetIconeFlag( const int flag ) ;\n\n// Nombre d'icones differentes (identifiant commence a 1 dans le fichier .rc)\n// extern int NumberOfIcons ;\nint GetNumberOfIcons(void) ;\nvoid SetNumberOfIcons( const int flag ) ;\n\n// extern int IconeNum ;\nint GetIconeNum(void) ;\nvoid SetIconeNum( const int num ) ;\n\n// La librairie dans laquelle chercher les icones (fichier defini dans kitty.ini, sinon kitty.dll s'il existe, sinon kitty.exe)\n// extern HINSTANCE hInstIcons ;\nHINSTANCE GethInstIcons(void) ;\nvoid SethInstIcons( const HINSTANCE h ) ;\n\nextern int debug_flag ;\n\nextern int PORT ;\n\n// Declaration de prototypes de fonction\nvoid InitFolderList( void ) ;\nvoid SaveFolderList( void ) ;\nvoid InfoBoxSetText( HWND hwnd, char * st ) ;\nvoid InfoBoxClose( HWND hwnd ); \nvoid routine_server( void * st ) ;\nvoid routine_SaveRegistryKey( void * st ) ;\nvoid SetNewIcon( HWND hwnd, char * iconefile, int icone, const int mode ) ;\nint WINAPI Notepad_WinMain(HINSTANCE hinstance, HINSTANCE hPrevInstance,LPSTR lpCmdLine, int nCmdShow) ;\nvoid InitWinMain( void ) ;\nchar * getcwd (char * buf, int size);\nint chdir(const char *path); \nchar * InputBox( HINSTANCE hInstance, HWND hwnd ) ;\nchar *itoa(int value, char *string, int radix);\nvoid GetAndSendLinePassword( HWND hwnd ) ;\nint unlink(const char *pathname);\nvoid RunScriptFile( HWND hwnd, const char * filename ) ;\nvoid InfoBoxSetText( HWND hwnd, char * st ) ;\nvoid ReadInitScript( const char * filename ) ;\nint ReadParameter( const char * key, const char * name, char * value ) ;\nint WriteParameter( const char * key, const char * name, char * value ) ;\nint DelParameter( const char * key, const char * name ) ;\nvoid GetSessionFolderName( const char * session_in, char * folder ) ;\nint MakeDirTree( const char * Directory, const char * s, const char * sd ) ;\nint ManageShortcuts( Terminal *term, Conf *conf, HWND hwnd, const int* clips_system, int key_num, int shift_flag, int control_flag, int alt_flag, int altgr_flag, int win_flag ) ;\nvoid print_log( const char *fmt, ...) ;\nchar * SetInitialSessPath( void ) ;\nchar * SetSessPath( const char * dec ) ;\nvoid CleanFolderName( char * folder ) ;\nvoid SetInitCurrentFolder( const char * name ) ;\nint print_event_log( FILE * fp, int i ) ;\nvoid set_sshver( const char * vers ) ;\nint ResizeWinList( HWND hwnd, int width, int height ) ;\nint SendCommandAllWindows( HWND hwnd, char * cmd ) ;\nint decode64 (char *buffer) ;\nvoid RunCommand( HWND hwnd, const char * cmd ) ;\nvoid timestamp_change_filename( void ) ;\nint InternalCommand( HWND hwnd, char * st ) ;\n// Convertit la base de registre en repertoire pour le mode savemode=dir\nint Convert2Dir( const char * Directory ) ;\n// Convertit une sauvegarde en mode savemode=dir vers la base de registre\nvoid ConvertDir2Reg( const char * Directory, HKEY hKey, char * path ) ;\nint Convert2Reg( const char * Directory ) ;\nvoid load_open_settings_forced(char *filename, Conf *conf) ;\nvoid save_open_settings_forced(char *filename, Conf *conf) ;\nint SwitchCryptFlag( void ) ;\nvoid CreateDefaultIniFile( void ) ;\nvoid InitSpecialMenu( HMENU m, const char * folder, const char * sessionname ) ;\n// Recupere une entree d'une session ( retourne 1 si existe )\nint GetSessionField( const char * session_in, const char * folder_in, const char * field, char * result ) ;\n// Sauve les coordonnees de la fenetre\nvoid SaveWindowCoord( Conf * conf ) ;\n// Permet de recuperer les sessions KiTTY dans PuTTY  (PUTTY_REG_POS)\nvoid RepliqueToPuTTY( LPCTSTR Key ) ;\n// Decompte le nombre de fenetre de la meme classe que KiTTY\nint WindowsCount( HWND hwnd ) ;\nHWND InfoBox( HINSTANCE hInstance, HWND hwnd ) ;\n// Renomme une Cle de registre\nvoid RegRenameTree( HWND hdlg, HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR lpDestKey ) ;\nvoid DelRegistryKey( void ) ;\nvoid RenewPassword( Conf *conf ) ;\n// Gere l'envoi dans le System Tray\nint ManageToTray( HWND hwnd ) ;\nvoid RefreshBackground( HWND hwnd ) ;\nvoid SendAutoCommand( HWND hwnd, const char * cmd ) ;\nint NextBgImage( HWND hwnd ) ;\nint PreviousBgImage( HWND hwnd ) ;\nvoid ManageSpecialCommand( HWND hwnd, int menunum ) ;\nint fileno(FILE *stream) ;\n// Sauvegarde de la cle de registre\nvoid SaveRegistryKeyEx( HKEY hMainKey, LPCTSTR lpSubKey, const char * filename ) ;\nvoid ManageProtect( HWND hwnd, TermWin *tw, char * title ) ;\n// Gere l'option always visible\nvoid ManageVisible( HWND hwnd, TermWin *tw, char * title ) ;\n// Sauvegarde de la cle de registre\nvoid SaveRegistryKeyEx( HKEY hMainKey, LPCTSTR lpSubKey, const char * filename ) ;\nvoid SaveRegistryKey( void ) ;\nvoid ManageWinrol( HWND hwnd, int resize_action ) ;\nvoid resize( int height, int width ) ;\nvoid OpenAndSendScriptFile( HWND hwnd ) ;\nvoid SaveCurrentSetting( HWND hwnd ) ;\nvoid SendFile( HWND hwnd ) ;\nvoid StartWinSCP( HWND hwnd, char * directory, char * host, char * user ) ;\nvoid StartNewSession( HWND hwnd, char * directory, char * host, char * user ) ;\nvoid urlhack_launch_url(const char* app, const char *url) ;\nint GetPortFwdState( const int port, const DWORD pid ) ;\nint ShowPortfwd( HWND hwnd, Conf * conf ) ;\nvoid OnDropFiles(HWND hwnd, HDROP hDropInfo) ;\n// Affiche un menu dans le systeme Tray\nvoid DisplaySystemTrayMenu( HWND hwnd ) ;\n// shift+bouton droit => paste ameliore pour serveur \"lent\"\n// Le paste utilise la methode \"autocommand\"\nvoid SetPasteCommand( HWND hwnd ) ;\n// Recupere les coordonnees de la fenetre\nvoid GetWindowCoord( HWND hwnd ) ;\nint ManageLocalCmd( HWND hwnd, const char * cmd ) ;\n// Gestion du script au lancement\nvoid ManageInitScript( const char * input_str, const int len ) ;\nvoid SetNewIcon( HWND hwnd, char * iconefile, int icone, const int mode ) ;\nvoid GotoInitialDirectory( void ) ;\nvoid GotoConfigDirectory( void ) ;\n\n// Prototype de function de kitty_savedump.c\nvoid addkeypressed( UINT message, WPARAM wParam, LPARAM lParam, int shift_flag, int control_flag, int alt_flag, int altgr_flag, int win_flag ) ;\n\nchar * get_param_str( const char * val ) ;\n\n// Fonctions permettant de formatter les chaînes de caractères avec %XY\t\nvoid mungestr( const char *in, char *out ) ;\nvoid unmungestr( const char *in, char *out, int outlen ) ;\n\t\nvoid NegativeColours(HWND hwnd) ;\nvoid BlackOnWhiteColours(HWND hwnd) ;\nvoid ChangeFontSize(Terminal *term, Conf *conf,HWND hwnd, int dec) ;\n\nvoid create_settings( const char * name ) ;\nvoid SetHostKeyExtension( const char* ext ) ;\n\nchar * GetHelpMessage(void) ;\nvoid CreateIniFile( const char * filename ) ;\nvoid SendKeyboard( HWND hwnd, const char * buffer ) ;\nchar * GetRemotePath() ;\nvoid ManageShortcutsFlag( HWND hwnd ) ;\n\n#ifdef MOD_LAUNCHER\nvoid InitLauncherRegistry( void ) ;\n#endif\n\nint getpid(void) ;\n\n// Definition de la section du fichier de configuration\n#if (defined MOD_PERSO) && (!defined FLJ)\n\n#ifndef INIT_SECTION\n#define INIT_SECTION \"KiTTY\"\n#endif\n#ifndef DEFAULT_INIT_FILE\n#define DEFAULT_INIT_FILE \"kitty.ini\"\n#endif\n#ifndef DEFAULT_SAV_FILE\n#define DEFAULT_SAV_FILE \"kitty.sav\"\n#endif\n#ifndef DEFAULT_EXE_FILE\n#define DEFAULT_EXE_FILE \"kitty.exe\"\n#endif\n\n#else\n\n#ifndef INIT_SECTION\n#define INIT_SECTION \"PuTTY\"\n#endif\n#ifndef DEFAULT_INIT_FILE\n#define DEFAULT_INIT_FILE \"putty.ini\"\n#endif\n#ifndef DEFAULT_SAV_FILE\n#define DEFAULT_SAV_FILE \"putty.sav\"\n#endif\n#ifndef DEFAULT_EXE_FILE\n#define DEFAULT_EXE_FILE \"putty.exe\"\n#endif\n\n#endif\n\n#ifndef SI_INIT\n#define SI_INIT 0\n#endif\n#ifndef SI_NEXT\n#define SI_NEXT 1\n#endif\n#ifndef SI_RANDOM\n#define SI_RANDOM 2\n#endif\n\n\n#ifndef TIMER_INIT\n#define TIMER_INIT 8701\n#endif\n\n#ifndef TIMER_AUTOCOMMAND\n#define TIMER_AUTOCOMMAND 8702\n#endif\n\n#ifndef TIMER_SLIDEBG\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n#define TIMER_SLIDEBG 8703\n#endif\n#endif\n#ifndef TIMER_REDRAW\n#define TIMER_REDRAW 8704\n#endif\n#ifndef TIMER_AUTOPASTE\n#define TIMER_AUTOPASTE 8705\n#endif\n#ifndef TIMER_BLINKTRAYICON\n#define TIMER_BLINKTRAYICON 8706\n#endif\n#ifndef TIMER_LOGROTATION\n#define TIMER_LOGROTATION 8707\n#endif\n#ifndef TIMER_ANTIIDLE\n#define TIMER_ANTIIDLE 8708\n#endif\n#ifndef TIMER_RECONNECT\n#define TIMER_RECONNECT 8709\n#endif\n\n#ifndef VISIBLE_NO\n#define VISIBLE_NO 0\n#endif\n#ifndef VISIBLE_YES\n#define VISIBLE_YES 1\n#endif\n#ifndef VISIBLE_TRAY\n#define VISIBLE_TRAY -1\n#endif\n\n/*************************************************\n** DEFINITION DES DEFINES\n*************************************************/\n#ifdef MOD_ZMODEM\n#ifndef IDM_XYZSTART\n#define IDM_XYZSTART  0xA810\n#endif\n#ifndef IDM_XYZUPLOAD\n#define IDM_XYZUPLOAD 0xA820\n#endif\n#ifndef IDM_XYZABORT\n#define IDM_XYZABORT  0xA830\n#endif\nint xyz_Process(Backend *back, void *backhandle, Terminal *term) ;\nvoid xyz_ReceiveInit(Terminal *term) ;\nvoid xyz_StartSending(Terminal *term) ;\nvoid xyz_Cancel(Terminal *term) ;\nvoid xyz_updateMenuItems(Terminal *term) ;\n#endif\n\n#ifndef IDM_QUIT\n#define IDM_QUIT 0xA840\n#endif\n#ifndef IDM_VISIBLE\n#define IDM_VISIBLE   0xA850\n#endif\n#ifndef IDM_PROTECT\n#define IDM_PROTECT   0xA860\n#endif\n#ifndef IDM_PRINT\n#define IDM_PRINT   0xA870\n#endif\n#ifndef IDM_TRANSPARUP\n#define IDM_TRANSPARUP\t0xA880\n#endif\n#ifndef IDM_TRANSPARDOWN\n#define IDM_TRANSPARDOWN\t0xA890\n#endif\n#ifndef IDM_WINROL\n#define IDM_WINROL   0xA900\n#endif\n#ifndef IDM_PSCP\n#define IDM_PSCP\t0xA910\n#endif\n#ifndef IDM_WINSCP\n#define IDM_WINSCP\t0xA920\n#endif\n#ifndef IDM_TOTRAY\n#define IDM_TOTRAY   0xA930\n#endif\n#ifndef IDM_FROMTRAY\n#define IDM_FROMTRAY   0xA940\n#endif\n#ifndef IDM_SHOWPORTFWD\n#define IDM_SHOWPORTFWD\t0xA950\n#endif\n#ifndef IDM_HIDE\n#define IDM_HIDE\t0xA960\n#endif\n#ifndef IDM_UNHIDE\n#define IDM_UNHIDE\t0xA970\n#endif\n#ifndef IDM_SWITCH_HIDE\n#define IDM_SWITCH_HIDE 0xA980\n#endif\n#ifndef IDM_GONEXT\n#define IDM_GONEXT\t0xA990\n#endif\n#ifndef IDM_GOPREVIOUS\n#define IDM_GOPREVIOUS\t0xB000\n#endif\n#ifndef IDM_SCRIPTFILE\n#define IDM_SCRIPTFILE 0xB010\n#endif\n#ifndef IDM_RESIZE\n#define IDM_RESIZE 0xB020\n#endif\n#ifndef IDM_REPOS\n#define IDM_REPOS 0xB030\n#endif\n#ifndef IDM_EXPORTSETTINGS\n#define IDM_EXPORTSETTINGS 0xB040\n#endif\n\n#ifndef IDM_FONTUP\n#define IDM_FONTUP 0xB050\n#endif\n#ifndef IDM_FONTDOWN\n#define IDM_FONTDOWN 0xB060\n#endif\n#ifndef IDM_FONTBLACKANDWHITE\n#define IDM_FONTBLACKANDWHITE 0xB070\n#endif\n#ifndef IDM_FONTNEGATIVE\n#define IDM_FONTNEGATIVE 0xB080\n#endif\n\n#ifndef IDM_PORTKNOCK\n#define IDM_PORTKNOCK\t0xB090\n#endif\n#ifndef IDM_CLEARLOGFILE\n#define IDM_CLEARLOGFILE 0xB100\n#endif\n\n#ifdef MOD_RECONNECT\n#ifndef IDM_RESTARTSESSION\n#define IDM_RESTARTSESSION 0xB110\n#endif\n#endif\n\n#ifndef IDM_SHORTCUTSTOGGLE\n#define IDM_SHORTCUTSTOGGLE 0xB120\n#endif\n\n// Doit etre le dernier\n#ifndef IDM_LAUNCHER\n#define IDM_LAUNCHER\t0xB130\n#endif\n\n// USERCMD doit etre la plus grande valeur pour permettre d'avoir autant de raccourcis qu'on le souhaite\n#ifndef IDM_USERCMD\n#define IDM_USERCMD   0x8000\n#endif\n\n// Idem USERCMD\n#ifndef IDM_GOHIDE\n#define IDM_GOHIDE    0x9000\n#endif\n\n/*************************************************\n** FIN DE DEFINITION DES DEFINES\n*************************************************/\n\n\n\n#ifndef IDB_OK\n#define IDB_OK\t1098\n#endif\n\n\n#ifndef SAVEMODE_REG\n#define SAVEMODE_REG 0\n#endif\n#ifndef SAVEMODE_FILE\n#define SAVEMODE_FILE 1\n#endif\n#ifndef SAVEMODE_DIR\n#define SAVEMODE_DIR 2\n#endif\n\n#ifndef NB_MENU_MAX\n#define NB_MENU_MAX 1024\n#endif\n\n\n\n// Liste de define recupere de WINDOW.C necessaires a kitty.c\n#ifndef IDM_ABOUT\n#define IDM_ABOUT     0x0150\n#endif\n#ifndef IDM_RESET\n#define IDM_RESET     0x0070\n#endif\n#ifndef IDM_COPYALL\n#define IDM_COPYALL   0x0170\n#endif\n#ifndef IDM_SHOWLOG\n#define IDM_SHOWLOG   0x0010\n#endif\n#ifndef IDM_RESTART\n#define IDM_RESTART   0x0040\n#endif\n#ifndef IDM_NEWSESS\n#define IDM_NEWSESS   0x0020\n#endif\n#ifndef IDM_DUPSESS\n#define IDM_DUPSESS   0x0030\n#endif\n#ifndef IDM_RECONF\n#define IDM_RECONF   0x0050\n#endif\n#ifndef IDM_CLRSB\n#define IDM_CLRSB     0x0060\n#endif\n#ifndef IDM_FULLSCREEN\n#define IDM_FULLSCREEN\t0x0180\n#endif\n#ifndef IDM_COPYALL\n#define IDM_COPYALL\t0x0170\n#endif\n\n#endif // KITTY_H\n"
        },
        {
          "name": "kitty.ico",
          "type": "blob",
          "size": 51.08984375,
          "content": null
        },
        {
          "name": "kitty_commun.c",
          "type": "blob",
          "size": 15.04296875,
          "content": "/*\n * Fichier contenant les procedures communes à tous les programmes putty, pscp, psftp, plink, pageant\n */\n\n#include \"kitty_commun.h\"\n#include \"kitty_tools.h\"\n\n// Flag permettant d'activer l'acces a du code particulier permettant d'avoir plus d'info dans le kitty.dmp\nint debug_flag = 0 ;\n\n#ifdef MOD_PERSO\n\n#ifndef SAVEMODE_REG\n#define SAVEMODE_REG 0\n#endif\n#ifndef SAVEMODE_FILE\n#define SAVEMODE_FILE 1\n#endif\n#ifndef SAVEMODE_DIR\n#define SAVEMODE_DIR 2\n#endif\n\n// Flag pour le fonctionnement en mode \"portable\" (gestion par fichiers)\n#ifdef MOD_PORTABLE\nint IniFileFlag = SAVEMODE_DIR ;\n#else\nint IniFileFlag = SAVEMODE_REG ;\n#endif\nint GetIniFileFlag(void) { return IniFileFlag ; }\nvoid SetIniFileFlag( const int flag ) { IniFileFlag = flag ; }\nvoid SwitchIniFileFlag(void) { if( IniFileFlag == SAVEMODE_REG ) { IniFileFlag = SAVEMODE_DIR ; } else if ( IniFileFlag == SAVEMODE_DIR ) { IniFileFlag = SAVEMODE_REG ; } }\n\n// Flag permettant la gestion de l'arborscence (dossier=folder) dans le cas d'un savemode=dir\n#ifdef MOD_PORTABLE\nint DirectoryBrowseFlag = 1 ;\n#else\nint DirectoryBrowseFlag = 0 ;\n#endif\n\n// Flag pour repasser en mode Putty basic\nint PuttyFlag = 0 ;\nint GetPuttyFlag(void) { return PuttyFlag ; }\nvoid SetPuttyFlag( const int flag ) { PuttyFlag = flag ; }\n\n// Flag permettant de sauvegarder automatique les cles SSH des serveurs\nstatic int AutoStoreSSHKeyFlag = 0 ;\nint GetAutoStoreSSHKeyFlag(void) { return AutoStoreSSHKeyFlag ; }\nvoid SetAutoStoreSSHKeyFlag( const int flag ) { AutoStoreSSHKeyFlag = flag ; }\n\n// Flag permettant de desactiver la sauvegarde automatique des informations de connexion (user/password) Ã  la connexion SSH\nstatic int UserPassSSHNoSave = 0 ;\nint GetUserPassSSHNoSave(void) { return UserPassSSHNoSave ; }\nvoid SetUserPassSSHNoSave( const int flag ) { UserPassSSHNoSave = flag ; }\n\n// Flag permettant de gérer la demande confirmation à l'usage d'une clé privée (1=always; 0=never; 2=based on \"comment\")\nstatic int AskConfirmationFlag=2 ;\nint GetAskConfirmationFlag(void) { return AskConfirmationFlag ; }\nvoid SetAskConfirmationFlag( const int flag ) { AskConfirmationFlag = flag ; }\n\n// Flag pour empêcher l'écriture des fichiers (default settings, jump file list ...)\n// [KiTTY] readonly=no\nstatic int ReadOnlyFlag = 0 ;\nint GetReadOnlyFlag(void) { return ReadOnlyFlag ; }\nvoid SetReadOnlyFlag( const int flag ) { ReadOnlyFlag = flag ; }\n\n// Flag pour gérer le \"mélange\" des clés dans pageant\nstatic int ScrumbleKeyFlag = 0 ;\nint GetScrumbleKeyFlag(void) { return ScrumbleKeyFlag ; }\nvoid SetScrumbleKeyFlag( const int flag ) { ScrumbleKeyFlag = flag ; }\n\n#ifdef MOD_ADB\n// Flag pour inhiber le support d'ADB\nstatic int ADBFlag = 1 ;\nint GetADBFlag(void) { return ADBFlag ; }\nvoid SetADBFlag( const int flag ) { ADBFlag = flag ; }\n#endif\n\n#ifdef MOD_ZMODEM\n// Flag pour inhiber les fonctions ZMODEM\nstatic int ZModemFlag = 0 ;\nint GetZModemFlag(void) { return ZModemFlag ; }\nvoid SetZModemFlag( const int flag ) { ZModemFlag = flag ; }\n#endif\n\n// Flag pour afficher l'image de fond\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n// Suite à PuTTY 0.61, le patch covidimus ne fonctionne plus tres bien\n// Il impose de demarrer les sessions avec -load meme depuis la config box (voir CONFIG.C)\n// Le patch est desactive par defaut\nint BackgroundImageFlag = 0 ;\n#else\nint BackgroundImageFlag = 0 ;\n#endif\nint GetBackgroundImageFlag(void) { return BackgroundImageFlag ; }\nvoid SetBackgroundImageFlag( const int flag ) { BackgroundImageFlag = flag ; }\n\n// Pour supprimer le salt dans la cryptography: issue: https://github.com/cyd01/KiTTY/issues/113\nint RandomActiveFlag = 1 ;\nint GetRandomActiveFlag() { return RandomActiveFlag ; }\nvoid SetRandomActiveFlag( const int flag ) { RandomActiveFlag = flag ; }\n\n// Pour supprimer le sel dans le cryptage du mot de passe\nint CryptSaltFlag = 0 ;\nint GetCryptSaltFlag() { return CryptSaltFlag ; }\nvoid SetCryptSaltFlag( int flag ) { CryptSaltFlag = flag ; }\n\n// Répertoire de sauvegarde de la configuration (savemode=dir)\nchar * ConfigDirectory = NULL ;\n\nchar * GetConfigDirectory( void ) { return ConfigDirectory ; }\n\nint stricmp(const char *s1, const char *s2) ;\nint readINI( const char * filename, const char * section, const char * key, char * pStr) ;\nchar * SetSessPath( const char * dec ) ;\n\n// Nettoie les noms de folder en remplaçant les \"/\" par des \"\\\" et les \" \\ \" par des \" \\\"\nvoid CleanFolderName( char * folder ) {\n\tint i, j ;\n\tif( folder == NULL ) return ;\n\tif( strlen( folder ) == 0 ) return ;\n\tfor( i=0 ; i<strlen(folder) ; i++ ) if( folder[i]=='/' ) folder[i]='\\\\' ;\n\tfor( i=0 ; i<(strlen(folder)-1) ; i++ ) \n\t\tif( folder[i]=='\\\\' ) \n\t\t\twhile( folder[i+1]==' ' ) for( j=i+1 ; j<strlen(folder) ; j++ ) folder[j]=folder[j+1] ;\n\tfor( i=(strlen(folder)-1) ; i>0 ; i-- )\n\t\tif( folder[i]=='\\\\' )\n\t\t\twhile( folder[i-1]==' ' ) {\n\t\t\t\tfor( j=i-1 ; j<strlen(folder) ; j++ ) folder[j]=folder[j+1] ;\n\t\t\t\ti-- ;\n\t\t\t\t}\n\t}\n\n#include <sys/types.h>\n#include <dirent.h>\n#define MAX_VALUE_NAME 16383\n// Supprime une arborescence\nint _rmdir( const char *dirname ) ;\nvoid DelDir( const char * directory ) {\n\tDIR * dir ;\n\tstruct dirent * de ;\n\tchar fullpath[MAX_VALUE_NAME] ;\n\n\tif( (dir=opendir(directory)) != NULL ) {\n\t\twhile( (de=readdir( dir ) ) != NULL ) \n\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") ) {\n\t\t\tsprintf( fullpath, \"%s\\\\%s\", directory, de->d_name ) ;\n\t\t\tif( GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY ) { DelDir( fullpath ) ; }\n\t\t\telse if( !(GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY) ) { unlink( fullpath ) ; }\n\t\t\t}\n\t\tclosedir( dir ) ;\n\t\t_rmdir( directory ) ;\n\t\t}\n\t}\n\n// Lit un parametre soit dans le fichier de configuration, soit dans le registre\nchar  * IniFile = NULL ;\nchar INIT_SECTION[10];\nint ReadParameterLight( const char * key, const char * name, char * value ) {\n\tchar buffer[4096] ;\n\tstrcpy( buffer, \"\" ) ;\n\n\tif( GetValueData( HKEY_CURRENT_USER, TEXT(PUTTY_REG_POS), name, buffer ) == NULL ) {\n\t\tif( !readINI( IniFile, key, name, buffer ) ) {\n\t\t\tstrcpy( buffer, \"\" ) ;\n\t\t\t}\n\t\t}\n\tstrcpy( value, buffer ) ;\n\treturn strcmp( buffer, \"\" ) ;\n\t}\n\n/* test if we are in portable mode by looking for putty.ini or kitty.ini in running directory */\nint LoadParametersLight( void ) {\n\tFILE * fp = NULL ;\n\tint ret = 0 ;\n\tchar buffer[4096] ;\n\n#ifndef FLJ\n\tif( (getenv(\"KITTY_INI_FILE\")!=NULL) && ((fp = fopen( getenv(\"KITTY_INI_FILE\"), \"r\" )) != NULL) ) {\n\t\tfclose(fp ) ;\n\t\tIniFile = (char*)malloc(strlen(getenv(\"KITTY_INI_FILE\"))+1) ; \n\t\tstrcpy( IniFile,getenv(\"KITTY_INI_FILE\") ) ;\n\t\tstrcpy(INIT_SECTION,\"KiTTY\");\n\t\tif( readINI( IniFile, \"KiTTY\", \"savemode\", buffer ) ) {\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r')\n\t\t\t\t||(buffer[strlen(buffer)-1]==' ')\n\t\t\t\t||(buffer[strlen(buffer)-1]=='\\t') ) buffer[strlen(buffer)-1]='\\0';\n\t\t\tif( !stricmp( buffer, \"registry\" ) ) IniFileFlag = SAVEMODE_REG ;\n\t\t\telse if( !stricmp( buffer, \"file\" ) ) IniFileFlag = SAVEMODE_FILE ;\n\t\t\telse if( !stricmp( buffer, \"dir\" ) ) { IniFileFlag = SAVEMODE_DIR ; ret = 1 ; }\n\t\t}\n\t\tif(  IniFileFlag == SAVEMODE_DIR ) {\n\t\t\tif( readINI( IniFile, \"KiTTY\", \"browsedirectory\", buffer ) ) { \n\t\t\t\tif( !stricmp( buffer, \"NO\" )&&(IniFileFlag==SAVEMODE_DIR) ) DirectoryBrowseFlag = 0 ; \n\t\t\t\telse DirectoryBrowseFlag = 1 ;\n\t\t\t}\n\t\t\tif( readINI( IniFile, \"KiTTY\", \"configdir\", buffer ) ) {\n\t\t\t\tif( strlen( buffer ) > 0 ) { \n\t\t\t\t\tConfigDirectory = (char*)malloc( strlen(buffer) + 1 ) ;\n\t\t\t\t\tstrcpy( ConfigDirectory, buffer ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t} else  DirectoryBrowseFlag = 0 ;\n\t} else if( (fp = fopen( \"kitty.ini\", \"r\" )) != NULL ) {\n\t\tIniFile = (char*)malloc(11) ; strcpy(IniFile,\"kitty.ini\");\n\t\tstrcpy(INIT_SECTION,\"KiTTY\");\n\t\tfclose(fp ) ;\n\t\tif( readINI( \"kitty.ini\", \"KiTTY\", \"savemode\", buffer ) ) {\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r')\n\t\t\t\t||(buffer[strlen(buffer)-1]==' ')\n\t\t\t\t||(buffer[strlen(buffer)-1]=='\\t') ) buffer[strlen(buffer)-1]='\\0';\n\t\t\tif( !stricmp( buffer, \"registry\" ) ) IniFileFlag = SAVEMODE_REG ;\n\t\t\telse if( !stricmp( buffer, \"file\" ) ) IniFileFlag = SAVEMODE_FILE ;\n\t\t\telse if( !stricmp( buffer, \"dir\" ) ) { IniFileFlag = SAVEMODE_DIR ; ret = 1 ; }\n\t\t}\n\t\tif(  IniFileFlag == SAVEMODE_DIR ) {\n\t\t\tif( readINI( \"kitty.ini\", \"KiTTY\", \"browsedirectory\", buffer ) ) { \n\t\t\t\tif( !stricmp( buffer, \"NO\" )&&(IniFileFlag==SAVEMODE_DIR) ) DirectoryBrowseFlag = 0 ; \n\t\t\t\telse DirectoryBrowseFlag = 1 ;\n\t\t\t}\n\t\t\tif( readINI( \"kitty.ini\", \"KiTTY\", \"configdir\", buffer ) ) { \n\t\t\t\tif( strlen( buffer ) > 0 ) { \n\t\t\t\t\tConfigDirectory = (char*)malloc( strlen(buffer) + 1 ) ;\n\t\t\t\t\tstrcpy( ConfigDirectory, buffer ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t} else  DirectoryBrowseFlag = 0 ;\n\t} else \n#endif\n\tif( (fp = fopen( \"putty.ini\", \"r\" )) != NULL ) {\n\t\tIniFile = (char*)malloc(11) ; strcpy(IniFile,\"putty.ini\");\n\t\tstrcpy(INIT_SECTION,\"PuTTY\");\n\t\tfclose(fp ) ;\n\t\tif( readINI( \"putty.ini\", \"PuTTY\", \"savemode\", buffer ) ) {\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r')\n\t\t\t\t||(buffer[strlen(buffer)-1]==' ')\n\t\t\t\t||(buffer[strlen(buffer)-1]=='\\t') ) buffer[strlen(buffer)-1]='\\0';\n\t\t\tif( !stricmp( buffer, \"registry\" ) ) IniFileFlag = SAVEMODE_REG ;\n\t\t\telse if( !stricmp( buffer, \"file\" ) ) IniFileFlag = SAVEMODE_FILE ;\n\t\t\telse if( !stricmp( buffer, \"dir\" ) ) { IniFileFlag = SAVEMODE_DIR ; DirectoryBrowseFlag = 1 ; ret = 1 ; }\n\t\t}\n\t\tif(  IniFileFlag == SAVEMODE_DIR ) {\n\t\t\tif( readINI( \"putty.ini\", \"PuTTY\", \"browsedirectory\", buffer ) ) {\n\t\t\t\tif( !stricmp( buffer, \"NO\" )&&(IniFileFlag==SAVEMODE_DIR) ) DirectoryBrowseFlag = 0 ; \n\t\t\t\telse DirectoryBrowseFlag = 1 ;\n\t\t\t}\n\t\t\tif( readINI( \"putty.ini\", \"PuTTY\", \"configdir\", buffer ) ) { \n\t\t\t\tif( strlen( buffer ) > 0 ) { \n\t\t\t\t\tConfigDirectory = (char*)malloc( strlen(buffer) + 1 ) ;\n\t\t\t\t\tstrcpy( ConfigDirectory, buffer ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t} else  DirectoryBrowseFlag = 0 ;\n\t} else {\n#ifndef FLJ\n\t\tsprintf( buffer, \"%s/KiTTY/kitty.ini\", getenv(\"APPDATA\") );\n\t\tif( (fp = fopen( buffer, \"r\" )) != NULL ) {\n\t\t\tIniFile = (char*)malloc(strlen(buffer)+1) ; \n\t\t\tstrcpy(IniFile,buffer);\n\t\t\tstrcpy(INIT_SECTION,\"KiTTY\");\n\t\t\tfclose(fp);\n\t\t} else {\n#endif\n\t\t\tsprintf( buffer, \"%s/PuTTY/putty.ini\", getenv(\"APPDATA\") );\n\t\t\tif( (fp = fopen( buffer, \"r\" )) != NULL ) {\n\t\t\t\tIniFile = (char*)malloc(strlen(buffer)+1) ; \n\t\t\t\tstrcpy(IniFile,buffer);\n\t\t\t\tstrcpy(INIT_SECTION,\"PuTTY\");\n\t\t\t\tfclose(fp);\n\t\t\t} \n#ifndef FLJ\n\t\t}\n#endif\n\t}\n\tif( ReadParameterLight( INIT_SECTION, \"fileextension\", buffer ) ) {\n\t\tif( strlen(buffer) > 0 ) {\n\t\t\tif( buffer[0] != '.' ) { strcpy( FileExtension, \".\" ) ; } else { strcpy( FileExtension, \"\" ) ; }\n\t\t\tstrcat( FileExtension, buffer ) ;\n\t\t\twhile( FileExtension[strlen(FileExtension)-1]==' ' ) { FileExtension[strlen(FileExtension)-1] = '\\0' ; }\n\t\t}\t\t\t\t\n\t}\n\tif( ReadParameterLight( INIT_SECTION, \"autostoresshkey\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetAutoStoreSSHKeyFlag( 1 ) ; }\n\tif( ReadParameterLight( \"Agent\", \"messageonkeyusage\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetShowBalloonOnKeyUsage() ; }\n\tif( ReadParameterLight( \"Agent\", \"askconfirmation\", buffer ) ) { \n\t\tif( !stricmp( buffer, \"YES\" ) ) SetAskConfirmationFlag(1) ; \n\t\tif( !stricmp( buffer, \"NO\" ) ) SetAskConfirmationFlag(0) ;\n\t\tif( !stricmp( buffer, \"AUTO\" ) ) SetAskConfirmationFlag(2) ;\n\t}\n\tif( ReadParameterLight( \"Agent\", \"scrumble\", buffer ) ) { if( !stricmp( buffer, \"YES\" ) ) SetScrumbleKeyFlag(1) ; }\n\n\treturn ret ;\n}\n\n// Positionne un flag permettant de determiner si on est connecte\nint is_backend_connected = 0 ;\n\n#ifdef MOD_RECONNECT\nint is_backend_first_connected = 0 ; \nvoid SetSSHConnected( int flag ) {\n\tis_backend_connected = flag ; \n\tif( flag ) is_backend_first_connected = 1 ; \n\t}\n#else\nvoid SetSSHConnected( int flag ) { \n\tis_backend_connected = flag ; \n\t}\n#endif\n\n//PVOID SecureZeroMemory( PVOID ptr, SIZE_T cnt) { return memset( ptr, 0, cnt ) ; }\n\n// Fonction permettant de changer le statut du stockage automatique des ssh host keys\nvoid SetAutoStoreSSHKey( void ) {\n\tAutoStoreSSHKeyFlag = 1 ;\n\t}\n\t\n/* Fonction permettant de changer le statut de la generation d'un affichage de balloon dans le system tray lorsqu'une clé privée est utilisée */\nstatic int PrintBalloonOnKeyUsageFlag = 0 ;\nvoid SetShowBalloonOnKeyUsage( void ) {\n\tPrintBalloonOnKeyUsageFlag = 1 ;\n}\nint GetShowBalloonOnKeyUsage( void ) { return PrintBalloonOnKeyUsageFlag ; } \n\t\n/* Fonction permettant d'affiche un message sur l'icone dans le tray */\nchar *strncpy(  \n   char *strDest,  \n   const char * strSource,  \n   size_t count   \n);   \nint ShowBalloonTip( NOTIFYICONDATA tnid, TCHAR  title[], TCHAR msg[] ) {\n\tif( PrintBalloonOnKeyUsageFlag==0 ) return 0 ;\n\tBOOL res;\n\t//NOTIFYICONDATA tnid;\n\t//tnid.cbSize = sizeof(NOTIFYICONDATA) ;\n\t//tnid.hWnd = hwnd ;\n\ttnid.uFlags = NIF_INFO ;\n\ttnid.dwInfoFlags = NIIF_INFO ;\n\ttnid.uTimeout = 3000 ; /*timeout*/\n\tstrncpy( tnid.szInfo, msg, sizeof( tnid.szInfo ) );\n\tstrncpy( tnid.szInfoTitle, title, sizeof( tnid.szInfoTitle ) );\n\tres = Shell_NotifyIcon(NIM_MODIFY, &tnid);\n\tSleep(3000); \n\ttnid.szInfo[0] = 0 ;\n\tres = Shell_NotifyIcon(NIM_MODIFY, &tnid);\n\treturn res ;\t\n}\n\n// Fonctions permettant de formatter les chaînes de caractères avec %XY\t\nvoid mungestr( const char *in, char *out ) {\n\tchar hex[16] = \"0123456789ABCDEF\";\n\tint candot = 0 ;\n\twhile( *in ) {\n\t\tif( *in == ' ' || *in == '\\\\' || *in == '*' || *in == '?' ||\n\t\t\t*in ==':' || *in =='/' || *in =='\\\"' || *in =='<' || *in =='>' || *in =='|' ||\n\t\t\t*in == '%' || *in < ' ' || *in > '~' || (*in == '.'\n\t\t\t&& !candot) ) {\n\t\t\t*out++ = '%' ;\n\t\t\t*out++ = hex[((unsigned char) *in) >> 4] ;\n\t\t\t*out++ = hex[((unsigned char) *in) & 15] ;\n\t\t} else {\n\t\t\t*out++ = *in ;\n\t\t}\n\t\tin++ ;\n\t\tcandot = 1 ;\n\t}\n\t*out = '\\0' ;\n\treturn ;\n}\nvoid unmungestr( const char *in, char *out, int outlen ) {\n\twhile (*in) {\n\t\tif( *in == '%' && in[1] && in[2] ) {\n\t\t\tint i, j ;\n\t\t\ti = in[1] - '0' ;\n\t\t\ti -= (i > 9 ? 7 : 0) ;\n\t\t\tj = in[2] - '0' ;\n\t\t\tj -= (j > 9 ? 7 : 0) ;\n\t\t\t*out++ = (i << 4) + j ;\n\t\t\tif( !--outlen )\n\t\t\t\treturn ;\n\t\t\tin += 3\t;\n\t\t} else {\n\t\t\t*out++ = *in++ ;\n\t\t\tif( !--outlen )\n\t\t\t\treturn;\n\t\t}\n\t}\n\t*out = '\\0' ;\n\treturn ;\n}\n\n// Fonctions de gestion du mot de passe\nextern Conf *conf;\nvoid GetPasswordInConfig( char * p ) {\n\tif( strlen(conf_get_str(conf,CONF_password)) == 0 ) return ;\n\t/* On decrypte le password */\n\tchar bufpass[4096] ;\n\tint len = strlen( conf_get_str(conf,CONF_password) ) ;\n\tif( len>4095 ) { len = 4095 ; }\n\tmemcpy( bufpass, conf_get_str(conf,CONF_password), len ) ; \n\tbufpass[len]='\\0';\n\tMASKPASS(GetCryptSaltFlag(),bufpass) ;\n\t//DebugAddPassword( \"GetPasswordInConfig\", bufpass ) ; // in settings.c\n\tmemcpy( p, bufpass, strlen(bufpass)+1 ) ;\n\tmemset( bufpass,0,strlen(bufpass) ) ;\n}\n\nint IsPasswordInConf(void) {\n\tint len = 0 ;\n\tif( strlen(conf_get_str(conf,CONF_password)) == 0 ) return 0 ;\n\t/* On decrypte le password */\n\tchar bufpass[4096] ;\n\tlen = strlen( conf_get_str(conf,CONF_password) ) ;\n\tif( len>4095 ) { len = 4095 ; }\n\tmemcpy( bufpass, conf_get_str(conf,CONF_password), len ) ; \n\tbufpass[len]='\\0';\n\tMASKPASS(GetCryptSaltFlag(),bufpass);\n\t//DebugAddPassword( \"IsPasswordInConf\", bufpass ) ; // in settings.c\n\tlen = strlen( bufpass ) ;\n\tmemset(bufpass,0,strlen(bufpass));\n\treturn len ;\n}\n\nvoid CleanPassword( char * p ) { memset(p,0,strlen(p)); }\n\n// Extention pour les fichiers de session en mode portable (peut être ktx)\nchar FileExtension[15] = \"\" ;\n\n// Répertoire courant pourle mode portable\nchar CurrentFolder[1024] = \"Default\" ;\n\n#endif\n"
        },
        {
          "name": "kitty_commun.h",
          "type": "blob",
          "size": 4.505859375,
          "content": "#ifndef KITTY_COMMUN\n#define KITTY_COMMUN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"putty.h\"\n\n#include \"platform.h\"\n#include <windows.h>\n\n// Flag permettant d'activer l'acces a du code particulier permettant d'avoir plus d'info dans le kitty.dmp\nextern int debug_flag ;\n\n// Flag pour repasser en mode Putty basic\nint GetPuttyFlag(void) ;\nvoid SetPuttyFlag( const int flag ) ;\n\n// Flag pour le fonctionnement en mode \"portable\" (gestion par fichiers)\nint GetIniFileFlag(void) ;\nvoid SetIniFileFlag( const int flag ) ;\nvoid SwitchIniFileFlag(void) ;\n\n// Flag permettant de sauvegarder automatique les cles SSH des serveurs\n// extern int AutoStoreSSHKeyFlag  ;\nint GetAutoStoreSSHKeyFlag(void) ;\nvoid SetAutoStoreSSHKeyFlag( const int flag ) ;\n\n// Flag permettant de desactiver la sauvegarde automatique des informations de connexion (user/password) Ã  la connexion SSH\n// extern int UserPassSSHNoSave ;\nint GetUserPassSSHNoSave(void) ;\nvoid SetUserPassSSHNoSave( const int flag ) ;\n\n// Flag permettant de gérer la demande confirmation à l'usage d'une clé privée (1=always; 0=never; 2=based on \"comment\")\n// extern int AskConfirmationFlag=2 ;\nint GetAskConfirmationFlag(void) ;\nvoid SetAskConfirmationFlag( const int flag ) ;\n\n// Flag pour empêcher l'écriture des fichiers (default settings, jump file list ...)\n// [KiTTY] readonly=no\nint GetReadOnlyFlag(void) ;\nvoid SetReadOnlyFlag( const int flag ) ;\n\n// Flag pour gérer le \"mélange\" des clés dans pageant\nint GetScrumbleKeyFlag(void) ;\nvoid SetScrumbleKeyFlag( const int flag ) ;\n\n// Flag pour afficher l'image de fond\n//extern int BackgroundImageFlag ;\nint GetBackgroundImageFlag(void) ;\nvoid SetBackgroundImageFlag( const int flag ) ;\n\n// Pour supprimer le salt dans la cryptography: issue:https://github.com/cyd01/KiTTY/issues/113\n// extern int RandomActiveFlag ;\nint GetRandomActiveFlag() ;\nvoid SetRandomActiveFlag( const int flag ) ;\n\n// Pour supprimer le sel dans le cryptage du mot de passe\nint GetCryptSaltFlag() ;\nvoid SetCryptSaltFlag( int flag ) ;\n\n#ifdef MOD_ADB\n// Flag pour inhiber le support d'ADB\nint GetADBFlag(void) ;\nvoid SetADBFlag( const int flag ) ;\n#endif\n\n#ifdef MOD_ZMODEM\n// Flag pour inhiber les fonctions ZMODEM\nint GetZModemFlag(void) ;\nvoid SetZModemFlag( const int flag ) ;\n#endif\n\n// Répertoire de sauvegarde de la configuration (savemode=dir)\nextern char * ConfigDirectory ;\n\nchar * GetConfigDirectory( void ) ;\n\nint stricmp(const char *s1, const char *s2) ;\nchar * GetValueData(HKEY hkTopKey, char * lpSubKey, const char * lpValueName, char * rValue) ;\nint readINI( const char * filename, const char * section, const char * key, char * pStr) ;\nchar * SetSessPath( const char * dec ) ;\n\n// Nettoie les noms de folder en remplaçant les \"/\" par des \"\\\" et les \" \\ \" par des \" \\\"\nvoid CleanFolderName( char * folder ) ;\n\n// Supprime une arborescence\nvoid DelDir( const char * directory ) ;\n\n// Lit un parametre soit dans le fichier de configuration, soit dans le registre\nint ReadParameterLight( const char * key, const char * name, char * value ) ;\n\n/* test if we are in portable mode by looking for putty.ini or kitty.ini in running directory */\nint LoadParametersLight( void ) ;\n\n// Positionne un flag permettant de determiner si on est connecte\nextern int is_backend_connected ;\n#ifdef MOD_RECONNECT\nextern int is_backend_first_connected ;\n#endif\n\nvoid SetSSHConnected( int flag ) ;\n\n//PVOID WINAPI SecureZeroMemory( PVOID ptr, SIZE_T cnt) ;\n\n// Fonction permettant de changer le statut du stockage automatique des ssh host keys\nvoid SetAutoStoreSSHKey( void ) ;\n\n/* Fonctions permettant de changer ou d'obtenir le statut de la generation d'un affichage de balloon dans le system tray lorsqu'une clé privée est utilisée */\nvoid SetShowBalloonOnKeyUsage( void ) ;\nint GetShowBalloonOnKeyUsage( void ) ;\n\n/* Fonction permettant d'affiche un message sur l'icone dans le tray */\nint ShowBalloonTip( NOTIFYICONDATA tnid, TCHAR  title[], TCHAR msg[] ) ;\n\n// Fonctions permettant de formatter les chaînes de caractères avec %XY\t\nvoid mungestr( const char *in, char *out ) ;\nvoid unmungestr( const char *in, char *out, int outlen ) ;\n\n// Fonctions de gestion du mot de passe\nvoid MASKPASS( const int mode, char * password ) ;\nvoid GetPasswordInConfig( char * p ) ;\nint IsPasswordInConf(void) ;\nvoid CleanPassword( char * p ) ;\n\nint _rmdir(const char *) ;\n\n// Extention pour les fichiers de session en mode portable (peut être ktx)\nextern char FileExtension[15] ;\n\n// Répertoire courant pourle mode portable\nextern char CurrentFolder[1024] ;\n\n//int DebugAddPassword( const char*fct, const char*pwd ) ;\n#endif\n"
        },
        {
          "name": "kitty_crypt.c",
          "type": "blob",
          "size": 9.41796875,
          "content": "#include \"kitty_crypt.h\"\n\nint cryptstring( const int mode, char * st, const char * key ) {\n\tif( mode>1 ) return strlen(st);\n\tif( strlen(st)==0 ) { return 0 ; }\n\treturn bcrypt_string_base64( st, st, strlen( st ), key, 0 ) ; \n}\n\nint decryptstring( const int mode, char * st, const char * key ) { \n\tif( mode>1 ) return strlen(st);\n\tif( strlen(st)==0 ) { return 0 ; }\n\tint res = buncrypt_string_base64( st, st, strlen( st ), key ) ; \n\tif( res == 0 ) strcpy( st, \"\" ) ;\n\treturn res ;\n\t}\n\nvoid dopasskey( int mode, char * passkey, const char * host, const char * termtype ) {\n    if( mode > 0 ) {\n\tstrcpy( passkey, \"KiTTY\" ) ;\n    } else {\n\tif( strlen(host)>0 ) {\n\t\tif( (strlen(host)+strlen(termtype)) < 1000 ) { \n\t\t\tsprintf( passkey, \"%s%sKiTTY\", host, termtype ) ;\n\t\t} else {\n\t\t\tstrcpy( passkey, \"\" ) ;\n\t\t}\n\t} else { \n\t\tif( strlen(termtype) < 1000 ) { \n\t\t\tsprintf( passkey, \"%sKiTTY\", termtype ) ;\n\t\t} else {\n\t\t\tstrcpy( passkey, \"\" ) ;\n\t\t}\n\t}\n    }\n}\n\nint cryptpassword( const int mode, char * password, const char * host, const char * termtype ) {\n\tchar PassKey[1024] = \"\" ;\n\tint ret ;\n\tdopasskey( mode, PassKey, host, termtype ) ;\n\tret = cryptstring( mode, password, PassKey ) ;\n\treturn ret ;\n}\n\nint decryptpassword( const int mode, char * password, const char * host, const char * termtype ) {\n\tchar PassKey[1024] = \"\" ;\n\tint ret ;\n\tdopasskey( mode, PassKey, host, termtype ) ;\n\tret = decryptstring( mode, password, PassKey ) ;\n\treturn ret ;\n}\n\n//static char MASKKEY[128] = MASTER_PASSWORD ;\nstatic char MASKKEY[128] = \"¤¥©ª³¼½¾\" ;\n\nvoid MASKPASS( const int mode, char * password ) {\n\tif( mode > 0 ) return ;\n\tif( password==NULL ) return ;\n\tif( strlen(password)==0) return ;\n\t\n\tint i,j=0, len=strlen(password) ;\n\tchar c, *buffer ;\n\tbuffer=(char*)malloc(strlen(password)+1);\n\tbuffer[0]='\\0' ;\n\tif( (len>0)&&(strlen(MASKKEY)>0) )\n\tfor( i=0 ; i<len ; i++ ) {\n\t\tc = password[i]^MASKKEY[j] ;\n\t\tif( c==0 ) { free(buffer) ; return ; }\n\t\tbuffer[i]=c ; buffer[i+1] = '\\0' ;\n\t\tj++ ; if(MASKKEY[j]=='\\0') j=0 ;\n\t\t}\n\tstrcpy( password, buffer ) ;\n\tmemset(buffer,0,strlen(password) );\n\tfree(buffer) ;\n}\n\n// Passphrase (entree registry KiPP)\nstatic char PassPhrase[256] = \"\" ;\n\t\n// Procedure de management de la passphrase\nchar * ManagePassPhrase( const char * st ) {\n\tif( !GetUserPassSSHNoSave() && (st != NULL) ) {\n\t\tstrcpy( PassPhrase, st ) ;\n\t}\n\tif( GetUserPassSSHNoSave() ) { return \"\" ; }\n\treturn PassPhrase ;\n}\n\n\n\n/* ISO-8859-1 to UTF-8 mapper \n * return 0 for success, and need buffer size otherwise\n */\nsize_t iso8859_1_to_utf8(char *content, size_t max_size) {\n//https://codereview.stackexchange.com/questions/40780/function-to-convert-iso-8859-1-to-utf-8\n    char *src, *dst;\n\n    //first run to see if there's enough space for the new bytes\n    for (src = dst = content; *src; src++, dst++) {\n        if (*src & 0x80) {\n            // If the high bit is set in the ISO-8859-1 representation, then\n            // the UTF-8 representation requires two bytes (one more than usual).\n            ++dst;\n        }\n    }\n\n    if (dst - content + 1 > max_size) {\n        // Inform caller of the space required\n        return dst - content + 1;\n    }\n\n    *(dst + 1) = '\\0';\n    while (dst > src) {\n        if (*src & 0x80) {\n            *dst-- = 0x80 | (*src & 0x3f);                     // trailing byte\n            *dst-- = 0xc0 | (*((unsigned char *)src--) >> 6);  // leading byte\n        } else {\n            *dst-- = *src--;\n        }\n    }\n    return 0;  // SUCCESS\n}\n\n/* UTF-8 to ISO-8859-1/ISO-8859-15 mapper.\n* Return 0..255 for valid ISO-8859-15 code points, 256 otherwise.\n*/\nstatic inline unsigned int to_latin9(const unsigned int code) {\n    /* Code points 0 to U+00FF are the same in both. */\n    if (code < 256U)\n        return code;\n    switch (code) {\n        case 0x0152U: return 188U; /* U+0152 = 0xBC: OE ligature */\n        case 0x0153U: return 189U; /* U+0153 = 0xBD: oe ligature */\n        case 0x0160U: return 166U; /* U+0160 = 0xA6: S with caron */\n        case 0x0161U: return 168U; /* U+0161 = 0xA8: s with caron */\n        case 0x0178U: return 190U; /* U+0178 = 0xBE: Y with diaresis */\n        case 0x017DU: return 180U; /* U+017D = 0xB4: Z with caron */\n        case 0x017EU: return 184U; /* U+017E = 0xB8: z with caron */\n        case 0x20ACU: return 164U; /* U+20AC = 0xA4: Euro */\n        default:      return 256U;\n    }\n}\n\n/* Convert an UTF-8 string to ISO-8859-15.\n* All invalid sequences are ignored.\n* Note: output == input is allowed,\n* but   input < output < input + length\n* is not.\n* Output has to have room for (length+1) chars, including the trailing NUL byte.\n*/\nsize_t utf8_to_iso8859_15(char *const output, const char *const input, const size_t length) {\n//https://askcodez.com/est-il-un-moyen-de-convertir-en-utf-8-en-iso-8859-1.html\n    unsigned char             *out = (unsigned char *)output;\n    const unsigned char       *in  = (const unsigned char *)input;\n    const unsigned char *const end = (const unsigned char *)input + length;\n    unsigned int               c;\n    while (in < end)\n        if (*in < 128)\n            *(out++) = *(in++); /* Valid codepoint */\n        else\n            if (*in < 192)\n                in++;               /* 10000000 .. 10111111 are invalid */\n            else\n                if (*in < 224) {        /* 110xxxxx 10xxxxxx */\n                    if (in + 1 >= end)\n                    break;\n                    if ((in[1] & 192U) == 128U) {\n                        c = to_latin9( (((unsigned int)(in[0] & 0x1FU)) << 6U)\n                            |  ((unsigned int)(in[1] & 0x3FU)) );\n                        if (c < 256)\n                            *(out++) = c;\n                    }\n                    in += 2;\n                } else\n                    if (*in < 240) {        /* 1110xxxx 10xxxxxx 10xxxxxx */\n                        if (in + 2 >= end)\n                            break;\n                        if ((in[1] & 192U) == 128U &&\n                            (in[2] & 192U) == 128U) {\n\t\t\t    c = to_latin9( (((unsigned int)(in[0] & 0x0FU)) << 12U)\n                                | (((unsigned int)(in[1] & 0x3FU)) << 6U)\n                                |  ((unsigned int)(in[2] & 0x3FU)) );\n                            if (c < 256)\n                                *(out++) = c;\n                        }\n                        in += 3;\n                    } else\n                        if (*in < 248) {        /* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */\n                            if (in + 3 >= end)\n                                break;\n\t\t    \t    if ((in[1] & 192U) == 128U &&\n                                (in[2] & 192U) == 128U &&\n                                (in[3] & 192U) == 128U) {\n                                    c = to_latin9( (((unsigned int)(in[0] & 0x07U)) << 18U)\n                                        | (((unsigned int)(in[1] & 0x3FU)) << 12U)\n                                        | (((unsigned int)(in[2] & 0x3FU)) << 6U)\n                                        |  ((unsigned int)(in[3] & 0x3FU)) );\n                                    if (c < 256)\n                                        *(out++) = c;\n\t\t\t    }\n                            in += 4;\n                        } else\n                            if (*in < 252) {        /* 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n                                if (in + 4 >= end)\n                                    break;\n                                if ((in[1] & 192U) == 128U &&\n                                    (in[2] & 192U) == 128U &&\n                                    (in[3] & 192U) == 128U &&\n                                    (in[4] & 192U) == 128U) {\n                                    c = to_latin9( (((unsigned int)(in[0] & 0x03U)) << 24U)\n                                        | (((unsigned int)(in[1] & 0x3FU)) << 18U)\n                                        | (((unsigned int)(in[2] & 0x3FU)) << 12U)\n                                        | (((unsigned int)(in[3] & 0x3FU)) << 6U)\n                                        |  ((unsigned int)(in[4] & 0x3FU)) );\n                                    if (c < 256)\n                                        *(out++) = c;\n\t\t\t\t}\n                                in += 5;\n                            } else\n                                if (*in < 254) {        /* 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx */\n                                    if (in + 5 >= end)\n                                        break;\n                                if ((in[1] & 192U) == 128U &&\n                                    (in[2] & 192U) == 128U &&\n                                    (in[3] & 192U) == 128U &&\n\t\t\t\t    (in[4] & 192U) == 128U &&\n                                    (in[5] & 192U) == 128U) {\n\t\t\t\t    c = to_latin9( (((unsigned int)(in[0] & 0x01U)) << 30U)\n                                            | (((unsigned int)(in[1] & 0x3FU)) << 24U)\n                                            | (((unsigned int)(in[2] & 0x3FU)) << 18U)\n                                            | (((unsigned int)(in[3] & 0x3FU)) << 12U)\n                                            | (((unsigned int)(in[4] & 0x3FU)) << 6U)\n                                            |  ((unsigned int)(in[5] & 0x3FU)) );\n                                    if (c < 256)\n                                        *(out++) = c;\n\t\t\t\t}\n                                in += 6;\n                            } else\n                                in++;               /* 11111110 and 11111111 are invalid */\n    /* Terminate the output string. */\n    *out = '\\0';\n    return (size_t)(out - (unsigned char *)output);\n}\n"
        },
        {
          "name": "kitty_crypt.h",
          "type": "blob",
          "size": 0.78515625,
          "content": "#ifndef KITTYCRYPT_H\n#define KITTYCRYPT_H\n\n#include \"nbcrypt.h\"\n#include <windows.h>\n\nint cryptstring( const int mode, char * st, const char * key ) ;\nint decryptstring( const int mode, char * st, const char * key ) ;\nint cryptpassword( const int mode, char * password, const char * host, const char * termtype ) ;\nint decryptpassword( const int mode, char * password, const char * host, const char * termtype ) ;\n\nvoid MASKPASS( const int mode, char * password ) ;\n\n// Procedure de management de la passphrase\nint GetUserPassSSHNoSave(void) ;\nchar * ManagePassPhrase( const char * st ) ;\nsize_t iso8859_1_to_utf8(char *content, size_t max_size) ; \t\t\t\t\t// Latin-1 = iso8859-1\nsize_t utf8_to_iso8859_15(char *const output, const char *const input, const size_t length) ;   // Latin-9 = iso8859-15\n\n#endif\n"
        },
        {
          "name": "kitty_dll.c",
          "type": "blob",
          "size": 0.44140625,
          "content": "// g++ -shared -o kitty.dll kitty_dll.res.o ../../kitty_dll.c -Wl,--whole-archive ../../base64.a -Wl,--no-whole-archive -DBUILD_DLL -static-libgcc\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <windows.h>\n\n#ifdef BUILD_DLL\n#define LINKDLL extern \"C\" __declspec(dllimport)\n#else\n#define LINKDLL \n#endif\n\nextern \"C\" const char * get_param_str( const char * val ) {\n\tif( !stricmp( val, \"CLASS\" ) ) return \"KiTTY\" ;\n\treturn NULL ;\n\t}\n"
        },
        {
          "name": "kitty_dll.rc",
          "type": "blob",
          "size": 3.1455078125,
          "content": "// windres kitty_dll.c kitty_dll.res.o\r\n// gcc -shared -o kitty.dll kitty_dll.res.o\r\n// upx --best --compress-icons=2 kitty.dll\r\n\r\n#define IDI_MAINICON     200\r\n\r\n#define NB_ICONES\t44\r\n\r\n#define IDI_MAINICON_0   300\r\n#define IDI_MAINICON_1   301\r\n#define IDI_MAINICON_2   302\r\n#define IDI_MAINICON_3   303\r\n#define IDI_MAINICON_4   304\r\n#define IDI_MAINICON_5   305\r\n#define IDI_MAINICON_6   306\r\n#define IDI_MAINICON_7   307\r\n#define IDI_MAINICON_8   308\r\n#define IDI_MAINICON_9   309\r\n#define IDI_MAINICON_10   310\r\n#define IDI_MAINICON_11   311\r\n#define IDI_MAINICON_12   312\r\n#define IDI_MAINICON_13   313\r\n#define IDI_MAINICON_14   314\r\n#define IDI_MAINICON_15   315\r\n#define IDI_MAINICON_16   316\r\n#define IDI_MAINICON_17   317\r\n#define IDI_MAINICON_18   318\r\n#define IDI_MAINICON_19   319\r\n#define IDI_MAINICON_20   320\r\n#define IDI_MAINICON_21   321\r\n#define IDI_MAINICON_22   322\r\n#define IDI_MAINICON_23   323\r\n#define IDI_MAINICON_24   324\r\n#define IDI_MAINICON_25   325\r\n#define IDI_MAINICON_26   326\r\n#define IDI_MAINICON_27   327\r\n#define IDI_MAINICON_28   328\r\n#define IDI_MAINICON_29   329\r\n#define IDI_MAINICON_30   330\r\n#define IDI_MAINICON_31   331\r\n#define IDI_MAINICON_32   332\r\n#define IDI_MAINICON_33   333\r\n#define IDI_MAINICON_34   334\r\n#define IDI_MAINICON_35   335\r\n#define IDI_MAINICON_36   336\r\n#define IDI_MAINICON_37   337\r\n#define IDI_MAINICON_38   338\r\n#define IDI_MAINICON_39   339\r\n#define IDI_MAINICON_40   340\r\n#define IDI_MAINICON_41   341\r\n#define IDI_MAINICON_42   342\r\n#define IDI_MAINICON_43   343\r\n\r\nIDI_MAINICON ICON \"putty.ico\"\r\n\r\nIDI_MAINICON_0 ICON \"../../kitty.ico\"\r\nIDI_MAINICON_1 ICON \"putty.ico\"\r\nIDI_MAINICON_2 ICON \"res/puttyprd.ico\"\r\nIDI_MAINICON_3 ICON \"res/putty2.ico\"\r\nIDI_MAINICON_4 ICON \"res/putty3.ico\"\r\n\r\nIDI_MAINICON_5 ICON \"res/coyote.ico\"\r\nIDI_MAINICON_6 ICON \"res/daffy.ico\"\r\nIDI_MAINICON_7 ICON \"res/tweety.ico\"\r\nIDI_MAINICON_8 ICON \"res/sylvester.ico\"\r\n\r\nIDI_MAINICON_9 ICON \"res/0.ico\"\r\nIDI_MAINICON_10 ICON \"res/1.ico\"\r\nIDI_MAINICON_11 ICON \"res/2.ico\"\r\nIDI_MAINICON_12 ICON \"res/3.ico\"\r\nIDI_MAINICON_13 ICON \"res/4.ico\"\r\nIDI_MAINICON_14 ICON \"res/5.ico\"\r\nIDI_MAINICON_15 ICON \"res/6.ico\"\r\nIDI_MAINICON_16 ICON \"res/7.ico\"\r\nIDI_MAINICON_17 ICON \"res/8.ico\"\r\nIDI_MAINICON_18 ICON \"res/9.ico\"\r\n\r\nIDI_MAINICON_19 ICON \"res/porky.ico\"\r\nIDI_MAINICON_20 ICON \"res/taz.ico\"\r\nIDI_MAINICON_21 ICON \"res/coq.ico\"\r\nIDI_MAINICON_22 ICON \"res/elmer.ico\"\r\nIDI_MAINICON_23 ICON \"res/mars.ico\"\r\nIDI_MAINICON_24 ICON \"res/speedy.ico\"\r\nIDI_MAINICON_25 ICON \"res/rocky.ico\"\r\nIDI_MAINICON_26 ICON \"res/pepepu.ico\"\r\nIDI_MAINICON_27 ICON \"res/general.ico\"\r\nIDI_MAINICON_28 ICON \"res/hagar.ico\"\r\nIDI_MAINICON_29 ICON \"res/jerry.ico\"\r\nIDI_MAINICON_30 ICON \"res/tom.ico\"\r\nIDI_MAINICON_31 ICON \"res/snoopy.ico\"\r\nIDI_MAINICON_32 ICON \"res/woods.ico\"\r\nIDI_MAINICON_33 ICON \"res/yogi.ico\"\r\nIDI_MAINICON_34 ICON \"res/scooby.ico\"\r\nIDI_MAINICON_35 ICON \"res/shaggy.ico\"\r\nIDI_MAINICON_36 ICON \"res/freddie.ico\"\r\nIDI_MAINICON_37 ICON \"res/velma.ico\"\r\nIDI_MAINICON_38 ICON \"res/daphne.ico\"\r\nIDI_MAINICON_39 ICON \"res/woody.ico\"\r\nIDI_MAINICON_40 ICON \"res/sam.ico\"\r\nIDI_MAINICON_41 ICON \"res/runner.ico\"\r\nIDI_MAINICON_42 ICON \"res/bunny.ico\"\r\nIDI_MAINICON_43 ICON \"res/hellokitty.ico\"\r\n\r\n"
        },
        {
          "name": "kitty_image.c",
          "type": "blob",
          "size": 46.322265625,
          "content": "#ifdef FLJ\n#undef MOD_BACKGROUNDIMAGE\n#endif\n\n#include <setjmp.h>\n#include \"jpeg/jpeglib.h\"\n#include <stdio.h>\n\n#include <windows.h>\n\n#ifdef MOD_BACKGROUNDIMAGE\n\n#include <math.h>\n#include \"putty.h\"\n#include \"terminal.h\"\n\n#include \"kitty_image.h\"\n\nextern Conf *conf ;// extern Config cfg;\n//extern int offset_width, offset_height ;\n//extern int font_width, font_height ;\n\n#ifndef NCFGCOLOURS\n#define NCFGCOLOURS 24\n#endif\n#ifndef NEXTCOLOURS\n#define NEXTCOLOURS 240\n#endif\n#ifndef NALLCOLOURS\n#define NALLCOLOURS (NCFGCOLOURS + NEXTCOLOURS)\n#endif\n\n//extern COLORREF colours[NALLCOLOURS] ;\nextern HWND MainHwnd ;\n\nint stricmp(const char *s1, const char *s2) ;\nint GetSessionField( const char * session_in, const char * folder_in, const char * field, char * result ) ;\nint get_param( const char * val ) ;\n\nint return_offset_height(void) ;\nint return_offset_width(void) ;\nint return_font_height(void) ;\nint return_font_width(void) ;\nCOLORREF return_colours258(void) ;\n\n\nstatic BOOL (WINAPI * pAlphaBlend)( HDC, int, int, int, int, HDC, int, int, int, int, BLENDFUNCTION ) = 0 ;\n\n//static HWND hwnd;\n\nHDC textdc = NULL ;\nHBITMAP textbm = NULL ;\nCOLORREF colorinpixel;\nHDC colorinpixeldc = NULL ;\nHBITMAP colorinpixelbm = NULL;\nHDC backgrounddc = NULL ;\nHBITMAP backgroundbm = NULL ;\nHDC backgroundblenddc = NULL ;\nHBITMAP backgroundblendbm = NULL;\nBOOL bBgRelToTerm;\nbool resizing;\nRECT size_before;\n\n\n#ifdef DLL\n#define TARGET extern __declspec(dllexport)\n#else\n#define TARGET\n#endif\n\nstatic int ShrinkBitmapEnable = 1 ;\nvoid SetShrinkBitmapEnable( int v ) {\n\tif( v ) ShrinkBitmapEnable = 1 ;\n\telse ShrinkBitmapEnable = 0 ;\n}\n\t\n\n//\n// Fonctions de shrink de bitmap\n//\n#define Alloc(p,t) (t *)malloc((p)*sizeof(t))\n#define For(i,n) for ((i)=0;(i)<(n);(i)++)\n#define iFor(n) For (i,n)\n#define jFor(n) For (j,n)\n\ntypedef struct {\n\tWORD x, y ;\t// dimensions\n\tWORD l ;\t// bytes per scan-line (32-bit allignment)\n\tBYTE *b ;\t// bits of bitmap,3 bytes/pixel, BGR\n} tWorkBMP ;\t\t// 24-bit working bitmap\n\nvoid CreateWorkingBitmap( WORD dx, WORD dy, tWorkBMP *w ) {\n\tw->x=dx ;\n\tw->y=dy ;\n\tw->l=(dx+1)*3&0xfffc ;\n\tw->b=Alloc( w->l*dy, BYTE ) ;\n}\n\nHBITMAP CreateEmptyBitmap( WORD dx, WORD dy ) {\n\tHDC h = GetDC( NULL ) ;\n\tHBITMAP b = CreateCompatibleBitmap( h, dx, dy ) ;\n\tReleaseDC( NULL, h ) ;\n\treturn(b) ;\n}\n\nvoid SetBMIHeader( BITMAPINFO *b, short dx, short dy ) {\n\tb->bmiHeader.biSize = sizeof(BITMAPINFOHEADER) ;\n\tb->bmiHeader.biWidth = dx ;\n\tb->bmiHeader.biHeight = -dy ;\n\tb->bmiHeader.biPlanes = 1 ;\n\tb->bmiHeader.biBitCount = 24 ;\n\tb->bmiHeader.biCompression = BI_RGB ;\n\tb->bmiHeader.biSizeImage = 0 ;\n\tb->bmiHeader.biXPelsPerMeter = 1 ;\n\tb->bmiHeader.biYPelsPerMeter = 1 ;\n\tb->bmiHeader.biClrUsed = 0 ;\n\tb->bmiHeader.biClrImportant = 0 ;\n}\n\nPOINT GetBitmapSize( HBITMAP h ) {\n\tPOINT p ;\n\tBITMAP o ;\n\tGetObject( h, sizeof(o), &o ) ;\n\tp.x = o.bmWidth ;\n\tp.y = o.bmHeight ;\n\treturn(p) ;\n}\n\nvoid OpenBitmapForWork( HBITMAP b, tWorkBMP *w ) {\n\tBITMAPINFO s ;\n\tHDC h = GetDC( NULL ) ;\n\tPOINT v = GetBitmapSize( b ) ;\n\tCreateWorkingBitmap( v.x, v.y, w ) ;\n\tSetBMIHeader( &s,w->x, w->y ) ;\n\tGetDIBits( h, b, 0, w->y, w->b, &s, DIB_RGB_COLORS ) ;\n\tReleaseDC( NULL, h ) ;\n}\n\nvoid SaveWorkingBitmap( tWorkBMP *w, HBITMAP b ) {\n\tBITMAPINFO s ;\n\tHDC h = GetDC( NULL ) ;\n\tSetBMIHeader( &s, w->x, w->y ) ;\n\tSetDIBits( h, b, 0, w->y, w->b, &s, DIB_RGB_COLORS ) ;\n\tReleaseDC( NULL, h ) ;\n}\n\nvoid ShrinkWorkingBitmap( tWorkBMP *a, tWorkBMP *b, WORD bx, WORD by ) {\n\tBYTE *uy = a->b, *ux, i ;\n\tWORD x, y, nx, ny = 0 ;\n\tDWORD df = 3*bx, nf = df*by, j ;\n\tfloat k, qx[2], qy[2], q[4], *f = Alloc( nf, float ) ;\n\n\tCreateWorkingBitmap( bx, by, b) ;\n\n\tjFor (nf) f[j]=0;\n\tj=0;\n\n\tFor( y, a->y ) {\n\t\tux=uy;\n\t\tuy+=a->l;\n\t\tnx=0;\n\t\tny+=by;\n\t\tif (ny>a->y) {\n\t\t\tqy[0]=1-(qy[1]=(ny-a->y)/(float)by);\n\t\t\tFor (x,a->x) {\n\t\t\t\tnx+=bx;\n\t\t\t\tif (nx>a->x) {\n\t\t\t\t\tqx[0]=1-(qx[1]=(nx-a->x)/(float)bx);\n\t\t\t\t\tiFor (4) q[i]=qx[i&1]*qy[i>>1];\n\t\t\t\t\tiFor (3) {\n\t\t\t\t\t\tf[j]+=(*ux)*q[0];\n\t\t\t\t\t\tf[j+3]+=(*ux)*q[1];\n\t\t\t\t\t\tf[j+df]+=(*ux)*q[2];\n\t\t\t\t\t\tf[(j++)+df+3]+=(*(ux++))*q[3];\n\t\t\t\t\t}\n\t\t\t\t} else iFor (3) {\n\t\t\t\t\tf[j+i]+=(*ux)*qy[0];\n\t\t\t\t\tf[j+df+i]+=(*(ux++))*qy[1];\n\t\t\t\t}\n\t\t\t\tif (nx>=a->x) nx-=a->x;\n\t\t\t\tif (!nx) j+=3;\n\t\t\t}\n\t\t} else {\n\t\t\tFor (x,a->x) {\n\t\t\t\tnx+=bx;\n\t\t\t\tif (nx>a->x) {\n\t\t\t\t\tqx[0]=1-(qx[1]=(nx-a->x)/(float)bx);\n\t\t\t\t\tiFor (3) {\n\t\t\t\t\t\tf[j]+=(*ux)*qx[0];\n\t\t\t\t\t\tf[(j++)+3]+=(*(ux++))*qx[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse iFor (3) f[j+i]+=*(ux++);\n\t\t\t\tif (nx>=a->x) nx-=a->x;\n\t\t\t\tif (!nx) j+=3;\n\t\t\t}\n\t\t\tif (ny<a->y) j-=df;\n\t\t}\n\t\tif (ny>=a->y) ny-=a->y;\n\t}\n\n\tnf=0;\n\tk=bx*by/(float)(a->x*a->y);\n\tuy=b->b;\n\n\tFor (y,by) {\n\t\tjFor (df) uy[j]=(unsigned char)(f[nf++]*k+.5);\n\t\tuy+=b->l;\n\t}\n\n\tfree (f);\n}\n\nTARGET HBITMAP ShrinkBitmap( HBITMAP a, WORD bx, WORD by )\n// creates and returns new bitmap with dimensions of\n// [bx,by] by shrinking bitmap a both [bx,by] must be less or equal\n// than the dims of a, unless the result is nonsense\n{\n\ttWorkBMP in, out ;\n\tHBITMAP b=CreateEmptyBitmap( bx, by ) ;\n\tOpenBitmapForWork( a, &in ) ;\n\tShrinkWorkingBitmap( &in, &out, bx, by ) ;\n\tfree( in.b ) ;\n\tSaveWorkingBitmap( &out, b ) ;\n\tfree( out.b ) ;\n\treturn( b ) ;\n}\n\n\n\n\n\n\nHBITMAP ResizeBmp( HBITMAP hBmpSrc, WORD bx, WORD by ) {\n\tSIZE newSize ;\n\tnewSize.cx = bx;\n\tnewSize.cy = by;\n\t// taille actuelle\n\tBITMAP bmpInfo;\n\tGetObject(hBmpSrc, sizeof(BITMAP), &bmpInfo);\n\tSIZE oldSize;\n\toldSize.cx = bmpInfo.bmWidth;\n\toldSize.cy = bmpInfo.bmHeight;\n\n\t// selection source ds un DC\n\tHDC hdc = GetDC(NULL);\n\tHDC hDCSrc = CreateCompatibleDC(hdc);\n\tHBITMAP hOldBmpSrc = (HBITMAP)SelectObject(hDCSrc, hBmpSrc);\n\n\t// création bitmap dest et sélection ds un DC\n\tHDC hDCDst = CreateCompatibleDC(hdc);\n\tHBITMAP hBmpDst = CreateCompatibleBitmap(hdc, newSize.cx, newSize.cy);\n\tHBITMAP hOldBmpDst = (HBITMAP)SelectObject(hDCDst, hBmpDst);\n\n\t// resize\n\tStretchBlt(hDCDst, 0, 0, newSize.cx, newSize.cy, hDCSrc, 0, 0, oldSize.cx, oldSize.cy, SRCCOPY);\n\t\n\t// libération ressources\n\tSelectObject(hDCSrc, hOldBmpSrc);\n\tSelectObject(hDCDst, hOldBmpDst);\n\tDeleteDC(hDCSrc);\n\tDeleteDC(hDCDst);\n\tReleaseDC(NULL, hdc);\n\treturn hBmpDst;\n}\n\nstatic void fill_dc(HDC dc, int width, int height, COLORREF color)\n{\n    HBRUSH clrBrush = CreateSolidBrush(color);\n    HPEN clrPen = CreatePen(PS_SOLID, 0, color);\n\n    HBRUSH oldBrush;\n    HPEN oldPen;\n\n    oldBrush = SelectObject(dc, clrBrush);\n    oldPen = SelectObject(dc, clrPen);\n\n    Rectangle(dc, 0, 0, width, height);\n\n    SelectObject(dc, oldBrush);\n    SelectObject(dc, oldPen);\n}\n\nstatic BOOL load_wallpaper_bmp(HBITMAP* rawImage, int* style, int* x, int* y)\n{\n    LONG lRes;\n    HKEY kDesktop;\n    DWORD pathLen = MAX_PATH;\n    DWORD numBufLen = 10;\n    char wpPath[MAX_PATH];\n    char wpStyleBuf[10];\n    char wpTileBuf[10];\n\n    int wpStyle = -1;\n    int wpTile = -1;\n\n    // NOTE: In the non-wallpaper case (i.e., load_file_bmp), we load parameters\n    // like x, y and style from cfg, but in the wallpaper case we ignore our\n    // stored configuration and get that information from the system.\n\n    // ENHANCE: It's possible to set WallpaperOriginX and WallpaperOriginY to\n    // specify an exact position for the start of the wallpaper, but this\n    // function doesn't support that yet.  I don't think it's possible to set\n    // it through the normal UI anyway, you have to hack the registry to do it.\n    // For now, we'll never return an (x,y) positioning request to the caller.\n    *x = *y = 0;\n\n    lRes = RegOpenKeyEx(\n        HKEY_CURRENT_USER, \"Control Panel\\\\Desktop\", 0, KEY_READ, &kDesktop\n    );\n    if(lRes != ERROR_SUCCESS)\n    {\n        RegCloseKey(kDesktop);\n        return FALSE; // TODO: Should the error be reported to the user here?\n    }\n\n    lRes = RegQueryValueEx(kDesktop, \"Wallpaper\", NULL, NULL, (LPBYTE)wpPath, &pathLen);\n    if(lRes != ERROR_SUCCESS)\n    {\n        RegCloseKey(kDesktop);\n        return FALSE; // TODO: Should the error be reported to the user here?\n    }\n\n    lRes = RegQueryValueEx( kDesktop, \"WallpaperStyle\", NULL, NULL, (LPBYTE)wpStyleBuf, &numBufLen );\n    if(lRes == ERROR_SUCCESS)\n        wpStyle = atoi(wpStyleBuf);\n\n    lRes = RegQueryValueEx( kDesktop, \"TileWallpaper\", NULL, NULL, (LPBYTE)wpTileBuf, &numBufLen );\n    if(lRes == ERROR_SUCCESS)\n        wpTile = atoi(wpTileBuf);\n\n    if(wpStyle < 0 && wpStyle > 3)\n        wpStyle = 0;  // Default to tile.\n    else if(wpTile > 0)\n        wpStyle = 0;  // Force tile.\n    else if(wpStyle == 0 && wpTile == 0)\n        wpStyle = 1;  // For Explorer, wpStyle == wpTile == 0 means center, and\n                      // it doesn't ever set wpStyle to 1.  We call wpStyle == 1\n                      // center and don't use wpTile, to simplify things after\n                      // this point.\n\n    RegCloseKey(kDesktop);\n \n    if( *rawImage!=NULL ) { DeleteObject( *rawImage ) ; *rawImage=NULL ; }\n    *rawImage = LoadImage(\n        NULL, wpPath, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE\n    );\n    if(*rawImage == 0)\n        return FALSE; // TODO: Should the error be reported to the user here?\n\n    *style = wpStyle;\n\n    return TRUE;\n}\n\nstatic BOOL load_file_bmp(HBITMAP* rawImage, int* style, int* x, int* y)\n{\n    *x = conf_get_int( conf,CONF_bg_image_abs_x); \n    *y = conf_get_int( conf,CONF_bg_image_abs_y );\n    *style = conf_get_int( conf,CONF_bg_image_style);\n\n    if( *rawImage!=NULL ) { DeleteObject( *rawImage ) ; *rawImage=NULL ; }\n    *rawImage = LoadImage(\n        NULL, conf_get_filename( conf, CONF_bg_image_filename )->path, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE\n    );\n    if(*rawImage == 0)\n        return FALSE; // TODO: Should the error be reported to the user here?\n\n    return TRUE;\n}\n\njmp_buf JPEG_bailout;\nint usePalette = 0;\nchar *loadError = NULL;\t\nCOLORREF skycolour = RGB(0, 0, 255);\n\nHBITMAP CreateHBitmap(int w, int h, LPVOID *lpBits)\n{\n\tHBITMAP bitmap;\n\tBITMAPINFOHEADER BIH ;\n\tint iSize = sizeof(BITMAPINFOHEADER) ;\n\tmemset(&BIH, 0, iSize);\n\n\t// Fill in the header info.\n\tBIH.biSize = iSize;\n\tBIH.biWidth = w;\n\tBIH.biHeight = h;\n\tBIH.biPlanes = 1;\n\tBIH.biBitCount = 24;\n\tBIH.biCompression = BI_RGB;\n\tHDC hDC = CreateCompatibleDC(NULL);\n\tbitmap = CreateDIBSection(hDC,\n\t\t\t\t\t\t\t(BITMAPINFO*)&BIH,\n\t\t\t\t\t\t\tDIB_RGB_COLORS,\n\t\t\t\t\t\t\tlpBits,\n\t\t\t\t\t\t\tNULL,\n\t\t\t\t\t\t\t0);\n\tDeleteDC(hDC);\n\treturn bitmap;\n}\n\n//  LOADJPEGIMAGE  --  Load JPEG image into memory\nHBITMAP loadJPEGimage(FILE *input_file, HGLOBAL *LimageBitmap, int *LsizeX, int *LsizeY)\n{\n\tint i;\n\tLPBITMAPINFOHEADER bh;\n\tDWORD bmpsize;\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct jpeg_error_mgr jerr;\n\tJSAMPARRAY colormap;\n\tLPBYTE pix;\n\tint linewid;\n\tint pixbytes;\n\tstatic LPBYTE sl = NULL;\n\tstatic HGLOBAL imageBitmap = NULL;\t\t// In-memory bitmap\n\n\tsl = NULL;\n\timageBitmap = NULL;\n\tif (setjmp(JPEG_bailout) != 0) {\n\t\t/*\tSince we arrive here via longjmp() from\n\t\t\tparts unknown, we may have allocated\n\t\t\tthe line buffer or bitmap prior to bailing\n\t\t\tout.  If they've been allocated, release them.  */\n\n\t\tif (sl != NULL) {\n\t\t\tGlobalFree(sl);\n\t\t\tsl = NULL;\n\t\t}\n\t\tif (imageBitmap != NULL) {\n\t\t\tGlobalFree(imageBitmap);\n\t\t\timageBitmap = NULL;\n\t\t}\n\t\treturn NULL;\n\t}\n\tcinfo.err = jpeg_std_error(&jerr);\n\tjpeg_create_decompress(&cinfo);\n\tjpeg_stdio_src(&cinfo, input_file);\n\tjpeg_read_header(&cinfo, TRUE);\n\tcinfo.desired_number_of_colors = 254;\n\tcinfo.quantize_colors = usePalette;\n\tjpeg_start_decompress(&cinfo);\n\n\tpixbytes = (usePalette ? 1 : 3);\n\tsl = GlobalAlloc(GMEM_FIXED, cinfo.output_width * pixbytes);\n\tif (sl == NULL) {\n\t\tloadError = \"Cannot allocate JPEG decoder row buffer\";\n\t\treturn NULL;\n\t}\n\n\tlinewid = ((((cinfo.output_width * pixbytes) + (sizeof(LONG) - 1)) / sizeof(LONG)) * sizeof(LONG));\n\tbmpsize = sizeof(BITMAPINFOHEADER) +\n\t\t(usePalette ? (256 * sizeof(RGBQUAD)) : 0) +\n\t\t(linewid * cinfo.output_height);\n\n\timageBitmap = GlobalAlloc(GMEM_FIXED, bmpsize);\n\tif (imageBitmap == NULL) {\n\t\tloadError = \"Cannot allocate bitmap for decoded JPEG image\";\n\t\tGlobalFree(sl);\n\t\treturn NULL;\n\t}\n\n\t//\tPlug in header fields with information from cinfo\n\n\tbh = (LPBITMAPINFOHEADER) imageBitmap;\n\tpix = ((LPBYTE) imageBitmap) + sizeof(BITMAPINFOHEADER) +\n\t\t\t(usePalette ? (256 * sizeof(RGBQUAD)) : 0);\n\tpix = pix + 0 ; // Pour eviter un warning de compilation\n\tbh->biSize = sizeof(BITMAPINFOHEADER);\n\tbh->biWidth = cinfo.output_width;\n\tbh->biHeight = cinfo.output_height;\n\tbh->biPlanes = 1;\n\tbh->biBitCount = usePalette ? 8 : 24;\n\tbh->biCompression = BI_RGB;\n\tbh->biSizeImage = 0;\n\tbh->biXPelsPerMeter = bh->biYPelsPerMeter = 2835;\n\tbh->biClrUsed = 0;\n\tbh->biClrImportant = 0;\n\n\t/*\tConstruct the palette from the colour map optimised\n\t\tfor the JPEG file.  */\n\n\tif (usePalette) {\n\t\tcolormap = cinfo.colormap;\n\t\tfor (i = 0; i < cinfo.actual_number_of_colors; i++) {\n\t\t\tif (cinfo.num_components == 1) {\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbRed =\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbGreen =\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbBlue = GETJSAMPLE(colormap[0][i]);\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbReserved = 0;\n\t\t\t} else {\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbRed = GETJSAMPLE(colormap[0][i]);\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbGreen = GETJSAMPLE(colormap[1][i]);\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbBlue = GETJSAMPLE(colormap[2][i]);\n\t\t\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[i])->rgbReserved = 0;\n\t\t\t}\n\t\t}\n\n\t\t/*\tPlug black and our text colour in the last two slots\n\t\t\tof the palette so we canbe sure they're available.  */\n\t\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[254])->rgbRed =\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[254])->rgbGreen =\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[254])->rgbBlue =\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[254])->rgbReserved = 0;\n\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[255])->rgbRed = GetRValue(skycolour);\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[255])->rgbGreen = GetGValue(skycolour);\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[255])->rgbBlue = GetBValue(skycolour);\n\t\t((LPRGBQUAD) &((LPBITMAPINFO) bh)->bmiColors[255])->rgbReserved = 0;\n\t}\n\n\t//\tReturn scan lines and transfer to the pixel array\n\n\tBYTE *pDst = NULL;\n\tHBITMAP hBitmap = CreateHBitmap(bh->biWidth, bh->biHeight, (void**)&pDst);\n\tint nStorageWidth = ((bh->biWidth * 24 + 31) & ~31) >> 3; //dword alignment\n\tJSAMPARRAY ppDst = &pDst;\n/*\n\tLPBYTE px = pix + (linewid * (bh->biHeight - 1));\n\tfor (i = 0; i < (int) cinfo.output_height; i++) {\n\t\tunsigned char *slp[1] = { sl };\n\t\tjpeg_read_scanlines(&cinfo, slp, 1);\n\t\tif (usePalette) {\n\t\t\tmemcpy(px, sl, cinfo.output_width);\n\t\t} else {\n\t\t\tint j, k;\n\n\t\t\tif (cinfo.num_components == 3) {\n\t\t\t\tfor (j = k = 0; j < (int) cinfo.output_width; j++, k += 3) {\n\t\t\t\t\tpx[k] = sl[k + 2];\n\t\t\t\t\tpx[k + 1] = sl[k + 1];\n\t\t\t\t\tpx[k + 2] = sl[k];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (j = k = 0; j < (int) cinfo.output_width; j++, k += 3) {\n\t\t\t\t\tpx[k] = sl[j];\n\t\t\t\t\tpx[k + 1] = sl[j];\n\t\t\t\t\tpx[k + 2] = sl[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpx -= linewid;\n\t}\n*/\npDst = pDst + (cinfo.output_height-1)*nStorageWidth ;\nwhile (cinfo.output_scanline < cinfo.output_height) {\n      jpeg_read_scanlines (&cinfo, ppDst, 1);\n\n\t  if(cinfo.out_color_components==3) {\n\t\t  //swap R & B\n\t\t  BYTE* p = pDst;\n\t\t  int i ;\n\t\t  for( i=0;i<bh->biWidth;i++) {\n\t\t\t  BYTE r = p[0];\n\t\t\t  p[0] = p[2];\n\t\t\t  p[2] = r;\n\t\t\t  p += 3;\n\t\t  }\n\t  }\n\n\t  //pDst += nStorageWidth;\n\t  pDst -= nStorageWidth;\n\t}\n\n\tGlobalFree(sl);\n\tjpeg_finish_decompress(&cinfo);\n\tjpeg_destroy_decompress(&cinfo);\n\t \n\t*LsizeX = (int) bh->biWidth;\n\t*LsizeY = (int) bh->biHeight;\n\t*LimageBitmap = imageBitmap;\n\treturn hBitmap;\n}\n\n\nstatic BOOL load_file_jpeg(HBITMAP* rawImage, int* style, int* x, int* y) {\n    *x = conf_get_int( conf, CONF_bg_image_abs_x );\n    *y = conf_get_int( conf, CONF_bg_image_abs_y );\n    *style = conf_get_int( conf, CONF_bg_image_style );\n    int res=TRUE, LsizeX, LsizeY ;\n    FILE *fp ;\n    HGLOBAL LimageBitmap = NULL ;\n\n\t\n    if(  ( fp=fopen( conf_get_filename( conf,CONF_bg_image_filename)->path, \"rb\" ) ) == NULL ) return FALSE ;\n    \n    if( *rawImage!=NULL ) { DeleteObject( *rawImage ) ; *rawImage=NULL ; }\n*rawImage = loadJPEGimage(fp, &LimageBitmap,&LsizeX, &LsizeY) ;\nif( rawImage == NULL ) res =FALSE ;    \n     fclose( fp ) ;\n\n    GlobalFree(LimageBitmap);\n    \n    return res;\n}\n\nstatic HBITMAP CreateDIBSectionWithFileMapping(HDC dc, int width, int height, HANDLE fmap)\n{\n    BITMAPINFOHEADER BMI;\n    \n    BMI.biSize = sizeof(BITMAPINFOHEADER);\n    BMI.biWidth = width;\n    BMI.biHeight = height;\n    BMI.biPlanes = 1;\n    BMI.biBitCount = 32;\n    BMI.biCompression = BI_RGB;\n    BMI.biSizeImage = 0;\n    BMI.biXPelsPerMeter = 0;\n    BMI.biYPelsPerMeter = 0;\n    BMI.biClrUsed = 0;\n    BMI.biClrImportant = 0;\n    \n    return(CreateDIBSection(dc, (BITMAPINFO *)&BMI, DIB_RGB_COLORS, 0, fmap, 0));\n}\n\n\n/***********SCREEN CAPTURE*******************/\n\n/******************************/\n\nvoid init_dc_blend(void) {\n    //HMODULE * msimg32_dll = LoadLibrary(\"msimg32.dll\");\n    HMODULE msimg32_dll = LoadLibrary(\"msimg32.dll\");\n    \n    if(msimg32_dll) \n        pAlphaBlend = GetProcAddress(msimg32_dll, \"AlphaBlend\");\n    \n    if(pAlphaBlend) {\n    \tHDC hdc = GetDC(MainHwnd);\n    \t\n    \t// Create one pixel size bitmap for use in color_blend.\n        if( colorinpixeldc !=NULL ) { DeleteDC(colorinpixeldc ) ; } colorinpixeldc = CreateCompatibleDC(hdc);\n        if( colorinpixelbm!=NULL ) { DeleteObject(colorinpixelbm) ; } colorinpixelbm = CreateCompatibleBitmap(hdc, 1, 1);\n        SelectObject(colorinpixeldc, colorinpixelbm);\n        colorinpixel = 0;\n        SetPixelV(colorinpixeldc, 0, 0, colorinpixel);\n        \n        ReleaseDC(MainHwnd, hdc);\n    }\n}\n\nvoid color_blend(\n    HDC destDc, int x, int y, int width, int height, \n    COLORREF alphacolor, int opacity)\n{\n    if(pAlphaBlend) {\n    \t// Fast alpha blending for Win98&2000 and newer...\n        BLENDFUNCTION blender;\n\n        // Create one pixel size bitmap for use in color_blend.\n        if(colorinpixel != alphacolor) \n        {\n            colorinpixel = alphacolor;\n            SetPixelV(colorinpixeldc, 0, 0, alphacolor);\n        }\n        \n        blender.BlendOp = AC_SRC_OVER;\n        blender.BlendFlags = 0;\n        blender.SourceConstantAlpha = (0xff * opacity) / 100;\n        blender.AlphaFormat = 0;\n        \n        (*pAlphaBlend)(destDc, x, y, width, height, colorinpixeldc, 0, 0, 1, 1, blender);\n    } \n    else\n    {\n        // Slow alpha blending for Win95&NT...\n        // Note: Only tested with WinXP, should work on 95/NT.. probably.\n        int i, alphacolorR, alphacolorG, alphacolorB, bk_opacity;\n        HBITMAP tmpbm;\n        HDC tmpdc;\n        static HANDLE fmap;\n        static int fmap_size;\n        static unsigned char * pRGB;\n        \n        if(fmap_size < width * height * 4)\n        {\n            if(fmap) {\n            \tUnmapViewOfFile(pRGB);\n                CloseHandle(fmap);\n            }\n            fmap_size = width * height * 4;\n            fmap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, fmap_size, NULL);\n            pRGB = MapViewOfFile(fmap, FILE_MAP_ALL_ACCESS, 0, 0, fmap_size);\n        }\n        \n        // Create DIBSection so we get pixels easily.\n        tmpdc = CreateCompatibleDC(destDc);\n        tmpbm = CreateDIBSectionWithFileMapping(destDc, width, height, fmap);\n        SelectObject(tmpdc, tmpbm);\n        \n        // Copy bitmap to temporary bitmap for easy pixel access.\n        BitBlt(tmpdc, 0, 0, width, height, destDc, x, y, SRCCOPY);\n\n        // Moved stuff out from the loop\n        alphacolorR = GetRValue(alphacolor) * opacity;\n        alphacolorG = GetGValue(alphacolor) * opacity;\n        alphacolorB = GetBValue(alphacolor) * opacity;\n\tbk_opacity = 100 - opacity;\n\n        for(i=0; i<width*height*4; i+=4)\n        {\n\t    pRGB[i + 0] = (pRGB[i + 0] * bk_opacity + alphacolorB) / 100;\n            pRGB[i + 1] = (pRGB[i + 1] * bk_opacity + alphacolorG) / 100;\n            pRGB[i + 2] = (pRGB[i + 2] * bk_opacity + alphacolorR) / 100;\n        }\n        \n        // Copy temporary bitmap back to original\n        BitBlt(destDc, x, y, width, height, tmpdc, 0, 0, SRCCOPY);\n        \n        DeleteObject(tmpbm);\n        DeleteDC(tmpdc);\n    }\n}\n\nstatic void color_opacity_gradient( HDC destDc, int x, int y, int width, int height, COLORREF alphacolor, int style ) {\n\tint i, alphacolorR, alphacolorG, alphacolorB, bk_opacity, opacity, h, w ;\n\tdouble l ;\n        HBITMAP tmpbm;\n        HDC tmpdc;\n        static HANDLE fmap;\n        static int fmap_size;\n        static unsigned char * pRGB;\n\tint OpacityMin = 0, OpacityMax = 100 ;\n\t\n\tchar buf[256] = \"\" ;\n\tif( GetSessionField( conf_get_str(conf,CONF_sessionname), conf_get_str(conf,CONF_folder), \"BgOpacityRange\", buf ) ) { \n\t\tsscanf( buf, \"%d-%d\", &OpacityMin, &OpacityMax ) ; \n\t\tif( OpacityMin == OpacityMax ) { OpacityMin = 0 ; OpacityMax = 100 ; }\n\t\t}\n        \n        if(fmap_size < width * height * 4) {\n\t\tif(fmap) { UnmapViewOfFile(pRGB) ; CloseHandle(fmap) ; }\n\t\tfmap_size = width * height * 4;\n\t\tfmap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, fmap_size, NULL);\n\t\tpRGB = MapViewOfFile(fmap, FILE_MAP_ALL_ACCESS, 0, 0, fmap_size);\n\t\t}\n        \n        // Create DIBSection so we get pixels easily.\n        tmpdc = CreateCompatibleDC(destDc);\n        tmpbm = CreateDIBSectionWithFileMapping(destDc, width, height, fmap);\n        SelectObject(tmpdc, tmpbm);\n        \n        // Copy bitmap to temporary bitmap for easy pixel access.\n        BitBlt(tmpdc, 0, 0, width, height, destDc, x, y, SRCCOPY);\n\n        opacity = 0 ; bk_opacity = 100 ; alphacolorR = 0 ; alphacolorG = 0 ; alphacolorB = 0 ;\n\tw = 0 ; h = 0 ;\n\n        for(i=0; i<width*height*4; i+=4) {\n\t\t\n\t\tswitch( style ) {\n\t\t\tcase 2: // De bas en haut\n\t\t\tif( (i%(4*width)) == 0 ) {\n\t\t\t\th++ ;\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * (1.0*h)/(1.0*height) ;\n\t\t\t\topacity = 100 - opacity ;\n\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\tcase 3: // De gauche a droite\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * (1.0*w)/(1.0*width) ;\n\t\t\t\tbreak ;\n\t\t\tcase 4: // De droite a gauche\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * (1.0*w)/(1.0*width) ;\n\t\t\t\topacity = 100 - opacity ;\n\t\t\t\tbreak ;\n\t\t\tcase 5: // Du centre vers l'exterieur\n\t\t\t\tif( (i%(4*width)) == 0 ) { h++ ; }\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\tl = sqrt( pow(1.0*width/2.0-w,2.0)+pow(1.0*height/2.0-h,2.0) ) / \n\t\t\t\t\tsqrt( pow(1.0*width/2.0,2.0)+pow(1.0*height/2.0,2.0) );\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * l ;\n\t\t\t\tbreak ;\n\t\t\tcase 6: // De l'exterieur vers le centre\n\t\t\t\tif( (i%(4*width)) == 0 ) { h++ ; }\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\tl = sqrt( pow(1.0*width/2.0-w,2.0)+pow(1.0*height/2.0-h,2.0) ) / \n\t\t\t\t\tsqrt( pow(1.0*width/2.0,2.0)+pow(1.0*height/2.0,2.0) );\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * l ;\n\t\t\t\topacity = 100 - opacity ;\t\t\t\t\t\n\t\t\t\tbreak ;\n\t\t\tcase 7:\n\t\t\t\tif( (i%(4*width)) == 0 ) { h++ ; }\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\tl = sqrt( pow(1.0*w,2.0)+pow(1.0*h,2.0) )/sqrt( pow(1.0*width,2.0)+pow(1.0*height,2.0) ) ;\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * l ;\n\t\t\t\tbreak ;\n\t\t\tcase 8:\n\t\t\t\tif( (i%(4*width)) == 0 ) { h++ ; }\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\tl = sqrt( pow(1.0*w,2.0)+pow(1.0*h,2.0) )/sqrt( pow(1.0*width,2.0)+pow(1.0*height,2.0) ) ;\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * l ;\n\t\t\t\topacity = 100 - opacity ;\n\t\t\t\tbreak ;\n\t\t\tcase 9:\n\t\t\t\tif( (i%(4*width)) == 0 ) { h++ ; }\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\tl = sqrt( pow(1.0*(width-w),2.0)+pow(1.0*h,2.0) )/sqrt( pow(1.0*width,2.0)+pow(1.0*height,2.0) ) ;\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * l ;\n\t\t\t\tbreak ;\n\t\t\tcase 10:\n\t\t\t\tif( (i%(4*width)) == 0 ) { h++ ; }\n\t\t\t\tw++ ; if( w >= width ) { w = 0 ; }\n\t\t\t\tl = sqrt( pow(1.0*(width-w),2.0)+pow(1.0*h,2.0) )/sqrt( pow(1.0*width,2.0)+pow(1.0*height,2.0) ) ;\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * l ;\n\t\t\t\topacity = 100 - opacity ;\n\t\t\t\tbreak ;\n\t\t\tdefault: // De haut en bas\n\t\t\tif( (i%(4*width)) == 0 ) {\n\t\t\t\th++ ;\n\t\t\t\topacity = OpacityMin + 1.0*( OpacityMax-OpacityMin ) * (1.0*h)/(1.0*height) ;\n\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\t}\n\t\tif( opacity < 0 ) opacity = 0 ;\n\t\tif( opacity > 100 ) opacity = 100 ;\n\n\t\talphacolorR = GetRValue(alphacolor) * opacity;\n\t\talphacolorG = GetGValue(alphacolor) * opacity;\n\t\talphacolorB = GetBValue(alphacolor) * opacity;\n\t\tbk_opacity = 100 - opacity ;\n\n\t\tpRGB[i + 0] = (pRGB[i + 0] * bk_opacity + alphacolorB) / 100;\n\t\tpRGB[i + 1] = (pRGB[i + 1] * bk_opacity + alphacolorG) / 100;\n\t\tpRGB[i + 2] = (pRGB[i + 2] * bk_opacity + alphacolorR) / 100;\n\t\t}\n        \n        // Copy temporary bitmap back to original\n        BitBlt(destDc, x, y, width, height, tmpdc, 0, 0, SRCCOPY);\n        \n        DeleteObject(tmpbm);\n        DeleteDC(tmpdc);\n\t}\n\nvoid CreateBlankBitmap( HBITMAP * rawImage, const int width, const int height ) {\n\tHDC dc= CreateCompatibleDC(NULL);\n\tBITMAPINFO bi;\n\tZeroMemory( &bi.bmiHeader, sizeof(BITMAPINFOHEADER) );\n\tbi.bmiHeader.biWidth=width;     // Set size you need\n\tbi.bmiHeader.biHeight=height;    // Set size you need\n\tbi.bmiHeader.biPlanes=1;\n\tbi.bmiHeader.biBitCount=24; // Can be 8, 16, 32 bpp or\n\tbi.bmiHeader.biSizeImage=0;\n\tbi.bmiHeader.biSize=sizeof(BITMAPINFOHEADER);\n\tbi.bmiHeader.biClrUsed= 0;\n\tbi.bmiHeader.biClrImportant= 0;\n\tVOID *pvBits;\n\t\n\tif( *rawImage!=NULL ) { DeleteObject( *rawImage ) ; *rawImage=NULL ; }\n\t*rawImage = CreateDIBSection( dc,&bi,DIB_RGB_COLORS,&pvBits,NULL,0 );\n\tReleaseDC(NULL, dc) ;\n\n\tHDC hDC = GetDC(MainHwnd);\n\tHDC hDCDst = CreateCompatibleDC(hDC); // memory device context for dest\tbitmap\n\tReleaseDC(NULL, hDC);\n\n\t// hdcMem contains your rendered particle\n\t\n\tHBRUSH hBrush = CreateSolidBrush(RGB(255,0,0));\n\t// Paints the rectangular band with the brush\n\tRECT Rect = {0, 0, width-1, height-1};\n\tFillRect(hDCDst, &Rect, hBrush);\n\t// Deletes the brush\n\tDeleteObject(hBrush);\n\n\tHGDIOBJ holdDIBDst = SelectObject(hDCDst, *rawImage);\t\n\t\n\t// transfer the image to your DIB bitmap\n\tBitBlt(hDCDst, 0, 0 ,width, height, hDC, 0, 0, SRCCOPY);\n\n\t// clean up\n\tSelectObject(hDCDst, holdDIBDst);\n\tDeleteDC(hDCDst);\n\t}\n\t\nBOOL load_bg_bmp()\n{\n    HBITMAP rawImage = NULL;\n    BITMAP rawImageInfo;\n    HDC hdcPrimary;\n    HDC bmpdc;\n    int deskWidth, deskHeight, clientWidth, clientHeight;\n    int x, y;\n    int style;\n\n    //COLORREF backgroundcolor = colours[258]; // Default Background\n    COLORREF backgroundcolor = return_colours258() ;\n    COLORREF alphacolor = backgroundcolor;\n\n    // Start off assuming this is true.\n    bBgRelToTerm = conf_get_int( conf,CONF_bg_image_abs_fixed);\n\t\n    RECT clientRect;\n    GetWindowRect( MainHwnd, &clientRect ) ;\n    clientWidth = clientRect.right-clientRect.left+1 ;\n    clientHeight = clientRect.bottom-clientRect.top+1 ;\n\n    switch( conf_get_int( conf,CONF_bg_type) )\n    {\n        // Solid\n    case 0:\n        // No bitmap file to load.  We'll handle this case below.\n        break;\n\n        // Wallpaper\n    case 1:\n        backgroundcolor = GetSysColor(COLOR_BACKGROUND);\n        bBgRelToTerm = FALSE; // Wallpaper is never positioned relative to term.\n        if(!load_wallpaper_bmp(&rawImage, &style, &x, &y))\n            rawImage = NULL; // Make sure rawImage is still NULL.\n        break;\n\n        // Image\n    case 2:\n    \t{\n\tbackgroundcolor = GetSysColor(COLOR_BACKGROUND) ;\n\tif( conf_get_filename(conf,CONF_bg_image_filename)->path[0] == '#' ) {\n\t\tint r=0,g=0,b=0;\n\t\tsscanf( conf_get_filename(conf,CONF_bg_image_filename)->path, \"#%02X%02X%02X\", &r, &g, &b ) ;\n\t\tbackgroundcolor = RGB( r, g, b ) ;\n\t\tBYTE *pDst = NULL;\n\t\trawImage = CreateHBitmap(10, 10, (void**)&pDst);\n\t\tstyle = 4 ;\n\t\t}\n    \telse if( !stricmp( conf_get_filename(conf,CONF_bg_image_filename)->path+strlen(conf_get_filename(conf,CONF_bg_image_filename)->path)-4, \".jpg\" ) ) {\n    \t\tif(!load_file_jpeg(&rawImage, &style, &x, &y))\n        \t    rawImage = NULL; // Make sure rawImage is still NULL.\n    \t\t}\n    \telse if( !stricmp( conf_get_filename(conf,CONF_bg_image_filename)->path+strlen(conf_get_filename(conf,CONF_bg_image_filename)->path)-5, \".jpeg\" ) ) {\n    \t\tif(!load_file_jpeg(&rawImage, &style, &x, &y))\n        \t    rawImage = NULL; // Make sure rawImage is still NULL.\n    \t\t}\n    \telse \n        if(!load_file_bmp(&rawImage, &style, &x, &y))\n            rawImage = NULL; // Make sure rawImage is still NULL.\n        break;\n\t}\n    }\n\n    hdcPrimary = GetDC(MainHwnd);\n    deskWidth = GetDeviceCaps(hdcPrimary, HORZRES);\n    deskHeight = GetDeviceCaps(hdcPrimary, VERTRES);\n\n\n\t// Securite pour ne pas depacer les limites de l'ecran principal\n\tif( (bBgRelToTerm == 0) \n\t\t&&((clientRect.right>deskWidth)||(clientRect.bottom>deskHeight)) ) {\n\t\t//DeleteObject(rawImage); rawImage = NULL ;\n\t\tbBgRelToTerm = 1 ;\n\t\t}\n\n    if(rawImage == NULL)\n    {\n        // Create a solid bitmap.  We'll get here in two cases: either the user\n        // selected the Solid background option, or the attempt to do something\n        // fancier (use the system wallpaper or an image file) failed.\n        /*\n        if( backgrounddc!=NULL ) DeleteDC(backgrounddc) ; backgrounddc = CreateCompatibleDC(hdcPrimary);\n        if( backgroundbm!=NULL ) DeleteObject(backgroundbm); backgroundbm\n            = CreateCompatibleBitmap(hdcPrimary, deskWidth, deskHeight);\n        SelectObject(backgrounddc, backgroundbm);\n        */\n        // Do not create anything, use default 'no background'-code instead.\n    }\n    else\n    {\n        // We've managed to load a good image.  Now, we need to manipulate it to\n        // the right size, location, etc.\n\n        // Find the width and height of the image we just loaded.\n        GetObject(rawImage, sizeof(rawImageInfo), &rawImageInfo);\n\n        // Create a temporary DC to wrap the raw image.\n        bmpdc = CreateCompatibleDC(hdcPrimary);\n        SelectObject(bmpdc, rawImage);\n\n        // Create a memory DC that has a new bitmap of the appropriate final\n        // image size.\n        if( textdc!=NULL ) { DeleteDC(textdc) ; } textdc = CreateCompatibleDC(hdcPrimary);\n        if( textbm!= NULL ) { DeleteObject(textbm) ; } textbm = CreateCompatibleBitmap(hdcPrimary, deskWidth, deskHeight);\n        SelectObject(textdc, textbm);\n\n        if( backgrounddc!=NULL ) { DeleteDC(backgrounddc) ; } backgrounddc = CreateCompatibleDC(hdcPrimary);\n        if( backgroundbm!=NULL ) { DeleteObject(backgroundbm) ; } backgroundbm = CreateCompatibleBitmap(hdcPrimary, deskWidth, deskHeight) ;\n        SelectObject(backgrounddc, backgroundbm);\n\n\tswitch(style)\n        {\n        case 0: { // Tile\n             for(y = 0; y < deskHeight; y += rawImageInfo.bmHeight)\n            {\n                for(x = 0; x < deskWidth; x += rawImageInfo.bmWidth)\n                {\n                    BitBlt(\n                        backgrounddc,\n                        x, y, rawImageInfo.bmWidth, rawImageInfo.bmHeight,\n                        bmpdc, 0, 0, SRCCOPY\n                    );\n                }\n            }\n           }\n           break;\n\n        case 1:    // Center\n\n            // Calculate x & y, ignoring values they may already have, then drop\n            // down to the (X,Y) placement case below.\n\n            x = (deskWidth - rawImageInfo.bmWidth) / 2;\n            y = (deskHeight - rawImageInfo.bmHeight) / 2;\n\n        case 3: {  // Absolute Place at given (X,Y)\n            // Start out with a background color fill.\n            fill_dc(backgrounddc, deskWidth, deskHeight, backgroundcolor);\n\n            BitBlt(\n                backgrounddc,\n                x, y, rawImageInfo.bmWidth, rawImageInfo.bmHeight,\n                bmpdc, 0, 0, SRCCOPY\n            );\n            break;\n            }\n\n        case 2: // Stretch\n            StretchBlt(\n                backgrounddc, 0, 0, deskWidth, deskHeight,\n                bmpdc, 0, 0, rawImageInfo.bmWidth, rawImageInfo.bmHeight,\n                SRCCOPY\n            );\n\n            break;\n\n\tcase 4: // blank background\n\t\tfill_dc(backgrounddc, deskWidth, deskHeight, backgroundcolor) ;\n\t\tbreak ;\n\t\n\tcase 5: // Stretch a la taille de la fenetre\n\t\t{\n\t\tif( (ShrinkBitmapEnable)&&(clientWidth<rawImageInfo.bmWidth)&&(clientHeight<rawImageInfo.bmHeight) ) {\n\t\t\tHBITMAP newhbmpBMP ;\n\t\t\tif( (newhbmpBMP = ShrinkBitmap( rawImage,clientWidth,clientHeight)) != NULL ) {\n\t\t\t//if( (newhbmpBMP = ResizeBmp( rawImage,clientWidth,clientHeight)) != NULL ) {\n\t\t\t\tDeleteDC(bmpdc) ;\n\t\t\t\tbmpdc = CreateCompatibleDC(0) ;\n\t\t\t\tDeleteDC(backgrounddc); backgrounddc = GetDC(MainHwnd);\n\t\t\t\tSelectObject(bmpdc, newhbmpBMP ) ;\n\t\t\t\tBitBlt(backgrounddc, 0, 0,clientWidth,clientHeight, bmpdc, 0, 0, SRCCOPY ) ;\n\t\t\t\tDeleteObject(newhbmpBMP);\n\t\t\t\t}\n\t\t\telse\n\t\t\tStretchBlt( backgrounddc,0,0,clientWidth,clientHeight,bmpdc,0,0,rawImageInfo.bmWidth,rawImageInfo.bmHeight,SRCCOPY);\n\t\t\t}\n\t\telse\n\t\t\tStretchBlt( backgrounddc,0,0,clientWidth,clientHeight,bmpdc,0,0,rawImageInfo.bmWidth,rawImageInfo.bmHeight,SRCCOPY);\n\t\t}\n\t\tbreak ;\n        }\n\n        // Create a version of the background DC with opacity already applied\n        // for fast screen fill in areas with no text.\n\n        if( backgroundblenddc!=NULL ) { DeleteDC(backgroundblenddc) ; } backgroundblenddc = CreateCompatibleDC(hdcPrimary);\n        if( backgroundblendbm!=NULL ) { DeleteObject(backgroundblendbm) ; } backgroundblendbm = CreateCompatibleBitmap( hdcPrimary, deskWidth, deskHeight );\n        \n        DeleteObject(rawImage);\n        DeleteDC(bmpdc);\n\t\n\tSelectObject(backgroundblenddc, backgroundblendbm);\n\tBitBlt(\n            backgroundblenddc, 0, 0, deskWidth, deskHeight,\n            backgrounddc, 0, 0, SRCCOPY\n        );\n\t\n\tif( conf_get_int(conf,CONF_bg_opacity) >= 0 ) \n\t\t{ color_blend( backgroundblenddc, 0, 0, deskWidth, deskHeight, alphacolor, conf_get_int(conf,CONF_bg_opacity)); }\n\telse \n\t\t{ \n\t\tif( bBgRelToTerm == 1 ) {\n\t\t\tdeskWidth = clientWidth ;\n\t\t\tdeskHeight = clientHeight ;\n\t\t\t}\n\t\t\n\t\tcolor_opacity_gradient( backgroundblenddc, 0, 0, deskWidth, deskHeight, alphacolor, -conf_get_int(conf,CONF_bg_opacity) ); \n\t\t}\n    }\n\n    ReleaseDC(MainHwnd, hdcPrimary);\n\n//DeleteDC(hdcPrimary);\n    return TRUE;\n}\n\nvoid paint_term_edges(Terminal*term, HDC hdc, LONG paint_left, LONG paint_top, LONG paint_right, LONG paint_bottom) \n{\n    if(backgrounddc == 0)\n        load_bg_bmp();\n\n    if(backgrounddc)\n    {\n        LONG topLeftX = paint_left;\n        LONG topLeftY = paint_top;\n        LONG width = (paint_right - paint_left);\n        LONG height = (paint_bottom - paint_top);\n        HDC srcdc = backgroundblenddc;\n        POINT srcTopLeft;\n        RECT size_now;\n        srcTopLeft.x = topLeftX;\n        srcTopLeft.y = topLeftY;\n\t\t\n        if(!bBgRelToTerm)\n            ClientToScreen(MainHwnd, &srcTopLeft);\n\n        if(!srcdc)\n            srcdc = backgrounddc;\n\n\tif(resizing)\n\t{\n\t    GetClientRect(MainHwnd, &size_now);\n\t    if(size_now.bottom > size_before.bottom || size_now.right > size_before.right)\n\t    {\n\t    \t// Draw on full area on resize.\n\t        BitBlt(hdc, topLeftX, topLeftY, width, height, srcdc, srcTopLeft.x, srcTopLeft.y, SRCCOPY);\n\t        \n\t        return;\n            }\n\t}\n//debug_log(\"1: %d %d %d %d\\n\",size_before.top,size_before.bottom,size_before.left,size_before.right) ;\n//debug_log(\"2: %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %d\\n\",topLeftX,topLeftY,width,height,srcTopLeft.x,srcTopLeft.y,size_now.top,size_now.bottom,size_now.left,size_now.right,resizing) ;\n\t\n        // Draw top edge\n        BitBlt(\n            hdc, topLeftX, topLeftY, width, return_offset_height(),\n            srcdc, srcTopLeft.x, srcTopLeft.y, SRCCOPY\n        );\n        // Draw left edge\n        BitBlt(\n            hdc, topLeftX, topLeftY+1, return_offset_width(), height-2,\n            srcdc, srcTopLeft.x, srcTopLeft.y+1, SRCCOPY\n        );\n        // Draw right edge (extra width for clean resizing)\n        BitBlt(\n            hdc, topLeftX+width-1, topLeftY+1, return_offset_width(), height-2,\n            srcdc, srcTopLeft.x+width-1, srcTopLeft.y+1, SRCCOPY\n        );\n        // Draw bottom edge (extra height for clean resizing)\n        BitBlt(\n            hdc, topLeftX, topLeftY+height-1, width, return_offset_height(),\n            srcdc, srcTopLeft.x, srcTopLeft.y+height-1, SRCCOPY\n        );\n    }\n    else\n    {\n        HBRUSH bgbrush, oldbrush;\n        HPEN edge, oldpen;\n        //COLORREF backgroundcolor = colours[258];\n\tCOLORREF backgroundcolor = return_colours258() ;\n        \n        bgbrush = CreateSolidBrush(backgroundcolor);\n        edge = CreatePen(PS_SOLID, 0, backgroundcolor);\n        \n        oldbrush = SelectObject(hdc, bgbrush);\n        oldpen = SelectObject(hdc, edge);\n\n        /*\n         * Jordan Russell reports that this apparently\n         * ineffectual IntersectClipRect() call masks a\n         * Windows NT/2K bug causing strange display\n         * problems when the PuTTY window is taller than\n         * the primary monitor. It seems harmless enough...\n         */\n        IntersectClipRect(hdc,\n        \tpaint_left, paint_top,\n        \tpaint_right, paint_bottom);\n\t\n        ExcludeClipRect(hdc, \n        \treturn_offset_width(), return_offset_height(),\n        \treturn_offset_width()+return_font_width()*(term->cols),\n        \treturn_offset_height()+return_font_height()*(term->rows));\n\n//debug_log(\"3: %d %d %d %d %d %d %d\\n\",resizing,paint_left, paint_top, paint_right, paint_bottom,offset_width,offset_height ) ;\n//debug_log(\"4: %d %d %d %d\\n\",size_before.top,size_before.bottom,size_before.left,size_before.right) ;\n//debug_log(\"5: %d %d %d %d %d %d\\n\",paint_top,paint_bottom,paint_left,paint_right,term->cols,term->rows);\n\n        Rectangle(hdc, paint_left, paint_top,\n            paint_right, paint_bottom);\n\n        SelectObject(hdc, oldpen);\n        DeleteObject(edge);\n        SelectObject(hdc, oldbrush);\n        DeleteObject(bgbrush);\n    }\n}\n\n/*\nvoid original_paint_term_edges(HDC hdc, LONG paint_left, LONG paint_top, LONG paint_right, LONG paint_bottom) \n{\n    if(backgrounddc == 0)\n        load_bg_bmp();\n\n    if(backgrounddc)\n    {\n        LONG topLeftX = paint_left;\n        LONG topLeftY = paint_top;\n        LONG width = (paint_right - paint_left);\n        LONG height = (paint_bottom - paint_top);\n        HDC srcdc = backgroundblenddc;\n        POINT srcTopLeft;\n        RECT size_now;\n        srcTopLeft.x = topLeftX;\n        srcTopLeft.y = topLeftY;\n\t\t\n        if(!bBgRelToTerm)\n            ClientToScreen(hwnd, &srcTopLeft);\n\n        if(!srcdc)\n            srcdc = backgrounddc;\n\n\tif(resizing)\n\t{\n\t    GetClientRect(hwnd, &size_now);\n\t    if(size_now.bottom > size_before.bottom || size_now.right > size_before.right)\n\t    {\n\t    \t// Draw on full area on resize.\n\t        BitBlt(hdc, topLeftX, topLeftY, width, height, srcdc, srcTopLeft.x, srcTopLeft.y, SRCCOPY);\n\t        \n\t        return;\n            }\n\t}\n//debug_log(\"1: %d %d %d %d\\n\",size_before.top,size_before.bottom,size_before.left,size_before.right) ;\n//debug_log(\"2: %ld %ld %ld %ld %ld %ld %ld %ld %ld %ld %d\\n\",topLeftX,topLeftY,width,height,srcTopLeft.x,srcTopLeft.y,size_now.top,size_now.bottom,size_now.left,size_now.right,resizing) ;\n\t\n        // Draw top edge\n        BitBlt(\n            hdc, topLeftX, topLeftY, width, offset_height,\n            srcdc, srcTopLeft.x, srcTopLeft.y, SRCCOPY\n        );\n        // Draw left edge\n        BitBlt(\n            hdc, topLeftX, topLeftY+1, offset_width, height-2,\n            srcdc, srcTopLeft.x, srcTopLeft.y+1, SRCCOPY\n        );\n        // Draw right edge (extra width for clean resizing)\n        BitBlt(\n            hdc, topLeftX+width-1, topLeftY+1, offset_width, height-2,\n            srcdc, srcTopLeft.x+width-1, srcTopLeft.y+1, SRCCOPY\n        );\n        // Draw bottom edge (extra height for clean resizing)\n        BitBlt(\n            hdc, topLeftX, topLeftY+height-1, width, offset_height,\n            srcdc, srcTopLeft.x, srcTopLeft.y+height-1, SRCCOPY\n        );\n    }\n    else\n    {\n        HBRUSH bgbrush, oldbrush;\n        HPEN edge, oldpen;\n        COLORREF backgroundcolor = colours[258];\n        \n        bgbrush = CreateSolidBrush(backgroundcolor);\n        edge = CreatePen(PS_SOLID, 0, backgroundcolor);\n        \n        oldbrush = SelectObject(hdc, bgbrush);\n        oldpen = SelectObject(hdc, edge);\n\n        //\n        // * Jordan Russell reports that this apparently\n        // * ineffectual IntersectClipRect() call masks a\n        // * Windows NT/2K bug causing strange display\n        // * problems when the PuTTY window is taller than\n        // * the primary monitor. It seems harmless enough...\n\t\n        IntersectClipRect(hdc,\n        \tpaint_left, paint_top,\n        \tpaint_right, paint_bottom);\n\t\n        ExcludeClipRect(hdc, \n        \toffset_width, offset_height,\n        \toffset_width+font_width*(term->cols),\n        \toffset_height+font_height*(term->rows));\n\n//debug_log(\"3: %d %d %d %d %d %d %d\\n\",resizing,paint_left, paint_top, paint_right, paint_bottom,offset_width,offset_height ) ;\n//debug_log(\"4: %d %d %d %d\\n\",size_before.top,size_before.bottom,size_before.left,size_before.right) ;\n//debug_log(\"5: %d %d %d %d %d %d\\n\",paint_top,paint_bottom,paint_left,paint_right,term->cols,term->rows);\n\n        Rectangle(hdc, paint_left, paint_top,\n            paint_right, paint_bottom);\n\n        SelectObject(hdc, oldpen);\n        DeleteObject(edge);\n        SelectObject(hdc, oldbrush);\n        DeleteObject(bgbrush);\n    }\n}\n*/\n\nvoid clean_bg(void) {\n\tDeleteDC(textdc);textdc=NULL;\n\tDeleteObject(textbm);textbm=NULL;\n\t//DeleteObject(colorinpixel);\n\t//DeleteDC(colorinpixeldc);\n\t//DeleteObject(colorinpixelbm);\n\tDeleteDC(backgrounddc);backgrounddc=NULL;\n\tDeleteObject(backgroundbm);backgroundbm=NULL;\n\tDeleteDC(backgroundblenddc);backgroundblenddc=NULL;\n\tDeleteObject(backgroundblendbm);backgroundblendbm=NULL;\n\t}\n\nvoid RedrawBackground( HWND hwnd ) {\n\tif(\n\t\t1 && // On inhibe cette fonction a cause du probleme de fuite memoire due a l'image de fond !!!  , mais probleme de rafraichissement ?\n\t\t(get_param(\"BACKGROUNDIMAGE\"))&&(!get_param(\"PUTTY\"))&&(conf_get_int(conf,CONF_bg_type) != 0) ) \n\t\t\t{\n\t\t\tclean_bg() ;\n\t\t\tload_bg_bmp();   // Apparement c'est ça qui faisait la fuite memoire !!!\n\t\t\t}\n\t/*\n\tInvalidateRect(hwnd, NULL, true) ;\n\tRedrawWindow(hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);\n\t*/\n\tRedrawWindow( hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN | RDW_UPDATENOW ) ;\n\t\n\t}\n\n\n#ifdef MOD_STARTBUTTON\n/*\n * Patch permettant de gerer le probleme de chargement de l'image de fond arrive avec putty 0.61\n */\nvoid BackgroundImagePatch( int num ) {\n\tint key=0x47 ;  \n\n\tif( num == 1 ) { // Double-clic sur une session, on fait ALT-G + Down + ALT-O\n\t\tkey = 0x47 ; /* VK_G 71 */\n\t\tkeybd_event(VK_LMENU , 0, 0, 0) ;\n\t\tkeybd_event( key, 0, 0, 0); \n\t\tkeybd_event( key, 0, KEYEVENTF_KEYUP, 0) ;\n\t\tkeybd_event(VK_LMENU, 0, KEYEVENTF_KEYUP, 0) ;\n\t\n\t\tkeybd_event(VK_DOWN, 0, 0, 0) ;\n\t\tkeybd_event(VK_DOWN, 0, KEYEVENTF_KEYUP, 0) ;\n\n\t\tkey=0x4F ;  /* VK_O */\n\t\tkeybd_event(VK_LMENU , 0, 0, 0) ;\n\t\tkeybd_event( key, 0, 0, 0); \n\t\tkeybd_event( key, 0, KEYEVENTF_KEYUP, 0) ;\n\t\tkeybd_event(VK_LMENU, 0, KEYEVENTF_KEYUP, 0) ;\n\t\t}\n\t}\n#endif\n\n#endif\n\nHBITMAP HWND_to_HBITMAP(HWND hWnd)\n{\n  RECT    r;\n  HDC     hdcMem, hdcScr;\n  HBITMAP hbmMem, hbmOld;\n \n  GetWindowRect(hWnd, &r);\n  hdcScr = GetWindowDC(hWnd);\n  hdcMem = CreateCompatibleDC(hdcScr);\n  hbmMem = CreateCompatibleBitmap(hdcScr, r.right -= r.left, r.bottom -= r.top) ;\n  hbmOld = (HBITMAP)SelectObject(hdcMem, hbmMem);\n  BitBlt(hdcMem, 0, 0, r.right, r.bottom, hdcScr, 0, 0, SRCCOPY);\n  SelectObject(hdcMem, hbmOld);\n  ReleaseDC(hWnd, hdcScr);\n  DeleteDC(hdcMem);\n  return hbmMem;\n}\n\nBOOL HBITMAP_to_JPG(HBITMAP hbm, LPCTSTR jpgfile, int quality)\n{\n  BITMAP      bm;\n  BITMAPINFO  bi;\n  BYTE       *pPixels;\n  JSAMPROW    jrows[1], jrow;\n  HDC         hdcScr, hdcMem1, hdcMem2;\n  HBITMAP     hbmMem, hbmOld1, hbmOld2;\n  FILE       *fp = fopen(jpgfile, \"wb\");\n  struct jpeg_compress_struct jpeg;\n  struct jpeg_error_mgr       jerr;\n \n  if(!hbm)\n    return 0;\n  if(!GetObject(hbm, sizeof(bm), &bm))\n    return 0;\n  if(!fp)\n    return 0;\n \n  ZeroMemory(&bi, sizeof(bi));\n  bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);\n  bi.bmiHeader.biWidth       = bm.bmWidth;\n  bi.bmiHeader.biHeight      = bm.bmHeight;\n  bi.bmiHeader.biPlanes      = 1;\n  bi.bmiHeader.biBitCount    = 24;\n  bi.bmiHeader.biCompression = BI_RGB;\n \n  hdcScr  = GetDC(0);\n  hdcMem1 = CreateCompatibleDC(hdcScr);\n  hbmOld1 =  (HBITMAP)SelectObject(hdcMem1,hbm);\n  hdcMem2 = CreateCompatibleDC(hdcScr);\n  hbmMem  = CreateDIBSection(hdcScr, &bi, DIB_RGB_COLORS, (VOID **)&pPixels, 0, 0);\n  hbmOld2 = (HBITMAP)SelectObject(hdcMem2, hbmMem);\n \n  BitBlt(hdcMem2, 0, 0, bm.bmWidth, bm.bmHeight, hdcMem1, 0, 0, SRCCOPY);\n \n  SelectObject(hdcMem1, hbmOld1);\n  SelectObject(hdcMem2, hbmOld2);\n  ReleaseDC(0, hdcScr);\n  DeleteDC(hdcMem1);\n  DeleteDC(hdcMem2);\n \n  jpeg.err = jpeg_std_error(&jerr);\n  jpeg_create_compress(&jpeg);\n  jpeg_stdio_dest(&jpeg, fp);\n  jpeg.image_width      = bm.bmWidth;\n  jpeg.image_height     = bm.bmHeight;\n  jpeg.input_components = 3;\n  jpeg.in_color_space   = JCS_RGB;\n  jpeg.dct_method       = JDCT_FLOAT;\n  jpeg_set_defaults(&jpeg);\n  jpeg_set_quality(&jpeg, (quality < 0 || quality > 100) ? 100 : quality, TRUE);\n  jpeg_start_compress(&jpeg, TRUE);\n \n  char *comment=NULL ;\n  if( comment ) {\n\tjpeg_write_marker(&jpeg, JPEG_COM, (const JOCTET*)comment, strlen(comment));\n  }\n\n  while(jpeg.next_scanline < jpeg.image_height)\n  {\n    unsigned int i, j, tmp;\n \n    jrow = &pPixels[(jpeg.image_height - jpeg.next_scanline - 1) * ((((bm.bmWidth * 24) + 31) / 32) * 4)];\n \n    for(i = 0; i < jpeg.image_width; i++)\n    {\n      j           = i * 3;\n      tmp         = jrow[j];\n      jrow[j]     = jrow[j + 2];\n      jrow[j + 2] = tmp;\n    }\n    jrows[0] = jrow;\n    jpeg_write_scanlines(&jpeg, jrows, 1);\n  }\n \n  jpeg_finish_compress(&jpeg);\n  jpeg_destroy_compress(&jpeg);\n  DeleteObject(hbmMem);\n  fclose(fp);\n  return 1;\n}\n\nvoid MakeScreenShot() {\nHBITMAP hbm = HWND_to_HBITMAP(GetDesktopWindow());\n   if(hbm) {\n    HBITMAP_to_JPG(hbm, \"screenshot.jpg\", 85) ;\n    DeleteObject(hbm);\n  }\n}\n\nint screenCapturePart(int x, int y, int w, int h, LPCSTR fname,int quality) {\n    int return_code = 0 ;\n    HDC hdcSource = GetDC(NULL);\n    HDC hdcMemory = CreateCompatibleDC(hdcSource);\n\n    //int capX = GetDeviceCaps(hdcSource, HORZRES);\n    //int capY = GetDeviceCaps(hdcSource, VERTRES);\n\n    HBITMAP hBitmap = CreateCompatibleBitmap(hdcSource, w, h);\n    HBITMAP hBitmapOld = (HBITMAP)SelectObject(hdcMemory, hBitmap);\n\n    BitBlt(hdcMemory, 0, 0, w, h, hdcSource, x, y, SRCCOPY);\n    hBitmap = (HBITMAP)SelectObject(hdcMemory, hBitmapOld);\n\n    DeleteDC(hdcSource);\n    DeleteDC(hdcMemory);\n\n    //HPALETTE hpal = NULL;\n    if( HBITMAP_to_JPG( hBitmap,fname, quality) ) { return_code = 1 ; }\n    DeleteObject(hBitmap);\n\t\n    return return_code ;\n}\n\nint screenCaptureClientRect( HWND hwnd, LPCSTR fname, int quality ) {\n\tRECT rc;\n\tPOINT p;\n\tGetClientRect(hwnd, &rc);\n\tp.x=rc.left; p.y=rc.top,\n\tClientToScreen(hwnd,&p);\n\trc.left=p.x;rc.top=p.y;\n\treturn screenCapturePart(rc.left,rc.top,rc.right,rc.bottom,fname,quality) ;\n}\nint screenCaptureWinRect( HWND hwnd, LPCSTR fname, int quality ) {\n\tRECT r;\n\tGetWindowRect(hwnd, &r);\n\treturn screenCapturePart(r.left,r.top,r.right-r.left,r.bottom-r.top,fname,quality) ;\n}\nint screenCaptureAll( LPCSTR fname, int quality ) {\n\treturn screenCapturePart(0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics (SM_CYSCREEN),fname,quality) ;\n}\n"
        },
        {
          "name": "kitty_image.h",
          "type": "blob",
          "size": 0.96875,
          "content": "#ifdef MOD_BACKGROUNDIMAGE\n\n#include <stdbool.h>\n\nextern HDC textdc;\nextern HBITMAP textbm;\nextern HBITMAP backgroundbm;\nextern HDC backgroundblenddc;\nextern HBITMAP backgroundblendbm;\n\nextern COLORREF colorinpixel;\nextern HDC colorinpixeldc;\nextern HBITMAP colorinpixelbm;\nextern HDC backgrounddc;\nextern BOOL bBgRelToTerm;\n\nextern bool resizing;\nextern RECT size_before;\n\nvoid color_blend(HDC destDc, int x, int y, int width, int height, COLORREF alphacolor, int opacity) ;\nvoid paint_term_edges(Terminal *term, HDC hdc, LONG paint_left, LONG paint_top, LONG paint_right, LONG paint_bottom)  ;\nvoid init_dc_blend(void);\n\nint screenCapturePart(int x, int y, int w, int h, LPCSTR fname,int quality) ;\nint screenCaptureClientRect( HWND hwnd, LPCSTR fname, int quality ) ;\nint screenCaptureWinRect( HWND hwnd, LPCSTR fname, int quality ) ;\nint screenCaptureAll( LPCSTR fname, int quality ) ;\n\n#endif\n\nvoid MakeScreenShot();\nint screenCaptureClientRect( HWND hwnd, LPCSTR fname, int quality ) ;\n"
        },
        {
          "name": "kitty_ini.txt",
          "type": "blob",
          "size": 8.537109375,
          "content": "[Agent]\n\n; askconfirmation: ask for confirmation on private key usage\n;    See http://people.mpi-klsb.mpg.de/~pcernko/pageant.html for information\n;    - yes : always\n;    - no  : never\n;    - auto: only is private key comment contains 'needs confirm'\n;askconfirmation=auto\n\n; messageonkeyusage: allow notification bullet on private key usage\n;messageonkeyusage=no\n\n\n\n[ConfigBox]\n\n; dblclick: define the default action when double click on a session in session list\n;    Allowed values are:\n;    - open: press open button\n;    - start: press start button\ndblclick=open\n\n; default: if yes all the sessions belong to their own folder and the default folder too\n;default=yes\n\n; defaultsettings: enable/disable the automatic creation of the 'Default Settings' session\n;defaultsettings=yes\n\n; filter: enable/disable filter in saved sessions selection box\nfilter=yes\n\n; height: the number of visible lines into the saved sessions selection box (in main window)\nheight=21\n\n; left: X position of the confuguration box (-1 means center)\n;left=-1\n\n; proxyselection: add a proxy selection feature in the main configuration box\n;proxyselection=no\n\n; noexit: if set to yes, return to the configuration box at main program exit\n;noexit=no\n\n; top: Y position of the confuguration box (-1 means center)\n;top=-1\n\n; windowheight: the size of the configuration box\n;windowheight=800\n\n\n\n[KiTTY]\n\n; adb: enable/disable adb support\nadb=yes\n\n; antiidle: character string regularly sent to maintain the connection alive\n;antiidle== \\k08\\\n\n; antiidledelay: time delay between two sending\n;antiidledelay=60\n\n; autoreconnect: enable/disable the automatic reconnection feature\nautoreconnect=yes\n\n; autostoresshkey: enable/disable the automatic ssh key store feature (no confirmation window)\n;autostoresshkey=no\n\n; backgroundimage: enable/disable the background image feature\nbgimage=no\n\n; bcdelay: time delay between each character in automatic features (autocommand, login script, user function ...)\n;bcdelay=0\n\n; capslock: force upper case\ncapslock=no\n\n; commanddelay: delay in milliseconds between two lines of the automatic start command script (Connection/Data/Command setting)\n;commanddelay=0.05\n\n; conf: enable/disable the automatic creation of the default configuration file\nconf=yes\n\n; configdir: set the configuration directory\n;    In portable mode it is the place where to find settings files directories: Sessions, SshHostKeys, ...\n;    Usually it is the same directory where kitty.exe is\n;configdir=\n\n; cryptsalt: set salt mode for password encryption \n;cryptsalt=1\n\n; CtHelperPath: the full path to the cthelper.exe binary (Wrapper for Cygwin feature)\n;CtHelperPath=\n\n; ctrltab: switch between PuTTY windows with CTRL+Tab\nctrltab=yes\n\n; cygterm: enable/disable the cygterm feature\ncygterm=no\n\n; debug: for debug purpose only\n;debug=no\n\n; downloaddir: this is the local directory where files are downloaded with the pscp integration\n;downloaddir=\n\n; fileextension: the extension for session settings files in portable mode\n;fileextension=.ktx\n\n; hostkeyextension: the extension for server host key files\n;hostkeyextension=.khk\n\n; hyperlink: enable/disable the hyperlink feature\nhyperlink=yes\n\n; icon: enable/disable the icon management feature (a particular icon for specific session)\nicon=yes\n\n; iconfile: point to a file where internal icons are located\n;iconfile=kitty.exe\n\n; initdelay: initial delay in seconds before automatic sending of password, or auto command\n;initdelay=2.0\n\n; KiClassName: change the internal software name to be the same as PuTTY\n;KiClassName=PuTTY\n\n; localcmd: manage local commands (starting with __)\n;localcmd=yes\n\n; localunsecurecmd: manage local unsecure commands ( ___pl, __ds, __cm, __ie )\n;localunsecurecmd=no\n\n; maxblinkingtime: maximum blinks (in system tray) where receiving bell signal\nmaxblinkingtime=5\n\n; mouseshortcuts: enable/disable mouse shortcuts\nmouseshortcuts=yes\n\n; numberoficons: total number of internal icons\n;numberoficons=45\n\n; paste: enable/disable one line at a time feature in paste action (useful on slow servers only)\npaste=no\n\n; pastesize: paste size limit (number of characters). Above the limit a confirmation is requested. (0 means unlimited)\n;pastesize=0\n\n; PlinkPath: the full path to the plink.exe (or klink.exe) binary\n;PlinkPath=\n\n; PSCPPath: the full path to the pscp.exe (or kscp.exe) binary\n;PSCPPath=\n\n; ReconnectDelay: the delay before trying to reconnect automatically (in seconds)\nReconnectDelay=5\n\n; sav: path to the save file of the KiTTY registry. In most cases it is located here %APPDATA%/KiTTY/kitty.sav\n;\n\n; savemode: specify the save mode for sessions settings\n;    Allowed values are:\n;    - registry : to save sessions into windows registry\n;    - file : to save sessions into one unique file (currently not maintained)\n;    - dir : to save sessions into files in the directory structure\n;savemode=registry\n\n; scriptfilefilter: specify the local script files extension\n;    Default value is (*.ksh,*.sh)|*.ksh;*.sh|SQL files (*.sql)|*.sql|All files (*.*)|*.*|\n;scriptfilefilter=All files (*.*)|*.*|\n\n; scriptmode: enable/disable RuTTY scripting mode\n;scriptmode=yes\n\n; shortcuts: enable/disable keyboard shortcuts\nshortcuts=yes\n\n; size: enable/disable window size in the window title\nsize=no\n\n; slidedelay: delay in seconds before automatic image switching in slideshow mode\n;    0 means no automatic slide, waiting for keyboard event\n;slidedelay=0\n\n; sshversion: Force the SSH version title. \n;    Default value: PuTTY-KiTTY\n;    KiTTY claims it is PuTTY-KiTTY. But sometimes there are servers that do not allow non standard values.\n;    So it is possible to redefine it\n;sshversion=OpenSSH_5.5\n\n; transparency: enable/disable the transparency feature\ntransparency=yes\n\n; userpasssshnosave: if yes, SSH password will not be saved internally (and can't be reused automatically) \nuserpasssshnosave=no\n\n; winrol: enable/disable the rolling feature (rolling into the title bar)\nwinrol=yes\n\n; WinSCPPath: the full path to the winscp.exe binary: \n;WinSCPPath=\n\n; wintitle: enable/disable the enhanced title feature (for protected mode and window size)\nwintitle=yes\n\n; zmodem: enable/disable zmodem feature (to send/receive files with sz/rz commands)\nzmodem=yes\n\n\n\n[Shortcuts]\n\n; Shortcuts: definition for the menu shortcuts keys\n\n; (re)send automatic command (default is SHIFT+F12)\n;autocommand=\n\n; Change settings ...\n;changesettings=\n\n; Clear scrollback\n;clearscrollback=\n\n; Clear log file\n;clearlogfile=\n\n; Close and restart current session\n;closerestart=\n\n; run a local command (default is CONTROL+F5)\n;command=\n\n; Copy all window buffers to clipboard\n;copyall=\n\n; Open a duplicate window (with same session settings)\n;duplicate=\n\n; open text editor connected to the main window (default is SHIFT+F2)\n;editor=\n\n; open text editor with clipboard content, connected to the main window (default is CONTROL+SHIFT+F2)\n;editorclipboard=\n\n; Show event log\n;eventlog=\n\n; Switch font to black on white colors\n;fontblackandwhite=\n\n; Decrease font size\n;fontdown=\n\n; Switch font to negative colors\n;fontnegative=\n\n; Increase font size\n;fontup=\n\n; Switch to full screen\n;fullscreen=\n\n; receive a remote file with pscp.exe: the full path must be selected in clipboard (default is CONTROL+F4)\n;getfile=\n\n; change the background image (default is CONTROL+F11)\n;imagechange=\n\n; special command box (default is CONTROL+F8)\n;input=\n\n; special command with multi-line editor (default is SHIFT+F8)\n;inputm=\n\n; Repeat key exchange\n;keyexchange=\n\n; New session ...\n;opennew=\n\n; Start a new configuration box with current settings but without hostname\n;opennewcurrent=\n\n; Print current clipboard content (default if SHIFT+F7)\n;print=\n\n; Print all window buffer content (default is F7)\n;printall=\n\n; Protect the window, disable keyboard and mouse input (default is CONTROL+F9)\n;protect=\n\n; Reset terminal\n;resetterminal=\n\n; Roll-up the window into the title bar (default is CONTROL+F12)\n;rollup=\n\n; Load a local script and run it remotely (default is CONTROL+F2)\n;script=\n\n; Send a local file with pscp.exe (default is CONTROL+F3)\n;sendfile=\n\n; Show current port forwarding definition (default is SHIFT+F6)\n;showportforward=\n\n; Enable or disable logging (default is SHIFT+F5)\n;switchlogmode=\n\n; Send the window to the system tray (default is CONTROL+F6)\n;tray=\n\n; Switch to embedded image viewer (default SHIFT+F11)\n;viewer=\n\n; Switch to always visible (default is CONTROL+F7)\n;visible=\n\n; Start WinSCP (default is SHIFT+F3)\n;winscp=\n\n\n\n[Print]\n\n; height: characters size (Printing)\nheight=100\n\n; maxline: maximum number of lines per page\nmaxline=60\n\n; maxchar: maximum number of characters per line\nmaxchar=85\n\n\n\n[Launcher]\n\n; reload: enable session list reload on each menu respawn\nreload=yes\n"
        },
        {
          "name": "kitty_keygen.c",
          "type": "blob",
          "size": 0.1044921875,
          "content": "int get_param( const char * val ) { return 0 ; }\r\nvoid debug_logevent( const char *fmt, ... ) { return ; }\n"
        },
        {
          "name": "kitty_launcher.c",
          "type": "blob",
          "size": 27.7216796875,
          "content": "#ifdef MOD_LAUNCHER\n\n// define recupere de WIN_RES.H\n#ifndef IDI_PUTTY_LAUNCH\n#define IDI_PUTTY_LAUNCH 9901\n#endif\n#ifndef IDI_BLACKBALL\n#define IDI_BLACKBALL 9902\n#endif\n\n#define KLWM_NOTIFYICON\t\t(WM_USER+2)\nstatic HMENU MenuLauncher = NULL ;\nstatic HMENU HideMenu ;\nstatic int LauncherConfReload = 1 ;\nstatic HBITMAP bmpCheck, bmpUnCheck ;\n\n// Gestion Hide/UnHide all\nstatic struct THWin { HWND hwnd ; char name[128] ; } TabWin[100] ;\nstatic int oldIconFlag = 0 ;\nstatic int NbWin = 0 ;\nstatic int IsUnique = 0 ;\nint RefreshWinList( HWND hwnd ) ;\n\n#ifndef OBM_CHECKBOXES\n#define OBM_CHECKBOXES 32759\n#endif\n\n// Creation de bitmap coche\nHBITMAP GetMyCheckBitmaps(UINT fuCheck) \n{ \n    COLORREF crBackground;  // background color                  \n    HBRUSH hbrBackground;   // background brush                  \n    HBRUSH hbrTargetOld;    // original background brush         \n    HDC hdcSource;          // source device context             \n    HDC hdcTarget;          // target device context             \n    HBITMAP hbmpCheckboxes; // handle to check-box bitmap        \n    BITMAP bmCheckbox;      // structure for bitmap data         \n    HBITMAP hbmpSourceOld;  // handle to original source bitmap  \n    HBITMAP hbmpTargetOld;  // handle to original target bitmap  \n    HBITMAP hbmpCheck;      // handle to check-mark bitmap       \n    RECT rc;                // rectangle for check-box bitmap    \n    WORD wBitmapX;          // width of check-mark bitmap        \n    WORD wBitmapY;          // height of check-mark bitmap       \n \n    // Get the menu background color and create a solid brush \n    // with that color. \n \n    crBackground = GetSysColor(COLOR_MENU); \n    hbrBackground = CreateSolidBrush(crBackground); \n \n    // Create memory device contexts for the source and \n    // destination bitmaps. \n \n    hdcSource = CreateCompatibleDC((HDC) NULL); \n    hdcTarget = CreateCompatibleDC(hdcSource); \n \n    // Get the size of the system default check-mark bitmap and \n    // create a compatible bitmap of the same size. \n \n    wBitmapX = GetSystemMetrics(SM_CXMENUCHECK); \n    wBitmapY = GetSystemMetrics(SM_CYMENUCHECK); \n \n    hbmpCheck = CreateCompatibleBitmap(hdcSource, wBitmapX, \n        wBitmapY); \n \n    // Select the background brush and bitmap into the target DC. \n \n    hbrTargetOld = SelectObject(hdcTarget, hbrBackground); \n    hbmpTargetOld = SelectObject(hdcTarget, hbmpCheck); \n \n    // Use the selected brush to initialize the background color \n    // of the bitmap in the target device context. \n \n    PatBlt(hdcTarget, 0, 0, wBitmapX, wBitmapY, PATCOPY); \n \n    // Load the predefined check box bitmaps and select it \n    // into the source DC. \n \n    hbmpCheckboxes = LoadBitmap((HINSTANCE) NULL, \n        (LPTSTR) OBM_CHECKBOXES); \n \n    hbmpSourceOld = SelectObject(hdcSource, hbmpCheckboxes); \n \n    // Fill a BITMAP structure with information about the \n    // check box bitmaps, and then find the upper-left corner of \n    // the unchecked check box or the checked check box. \n \n    GetObject(hbmpCheckboxes, sizeof(BITMAP), &bmCheckbox); \n \n    if (fuCheck == 2 /*UNCHECK*/) \n    { \n        rc.left = 0; \n        rc.right = (bmCheckbox.bmWidth / 4); \n    } \n    else \n    { \n        rc.left = (bmCheckbox.bmWidth / 4); \n        rc.right = (bmCheckbox.bmWidth / 4) * 2; \n    } \n \n    rc.top = 0; \n    rc.bottom = (bmCheckbox.bmHeight / 3); \n \n    // Copy the appropriate bitmap into the target DC. If the \n    // check-box bitmap is larger than the default check-mark \n    // bitmap, use StretchBlt to make it fit; otherwise, just \n    // copy it. \n \n    if (((rc.right - rc.left) > (int) wBitmapX) || \n            ((rc.bottom - rc.top) > (int) wBitmapY)) \n    {\n        StretchBlt(hdcTarget, 0, 0, wBitmapX, wBitmapY, \n            hdcSource, rc.left, rc.top, rc.right - rc.left, \n            rc.bottom - rc.top, SRCCOPY); \n    }\n \n    else \n    {\n        BitBlt(hdcTarget, 0, 0, rc.right - rc.left, \n            rc.bottom - rc.top, \n            hdcSource, rc.left, rc.top, SRCCOPY); \n    }\n \n    // Select the old source and destination bitmaps into the \n    // source and destination DCs, and then delete the DCs and \n    // the background brush. \n \n    SelectObject(hdcSource, hbmpSourceOld); \n    SelectObject(hdcTarget, hbrTargetOld); \n    hbmpCheck = SelectObject(hdcTarget, hbmpTargetOld); \n \n    DeleteObject(hbrBackground); \n    DeleteObject(hdcSource); \n    DeleteObject(hdcTarget); \n \n    // Return a handle to the new check-mark bitmap.  \n \n    return hbmpCheck; \n} \n\n// Procedure de creation de menu à partir d'une clé de registre\nHMENU InitLauncherMenu( char * Key ) {\n\tHMENU menu ;\n\tmenu = CreatePopupMenu() ;\n\tchar KeyName[1024] ;\n\tint nbitem = 0,i ;\n\t\n\tDeleteObject( bmpCheck ) ; bmpCheck = GetMyCheckBitmaps( 1 ) ;\n\tDeleteObject( bmpUnCheck ) ; bmpUnCheck = GetMyCheckBitmaps( 2 ) ;\n\t\n\tif( (IniFileFlag == SAVEMODE_REG)||(IniFileFlag == SAVEMODE_FILE) ) {\n\t\tsprintf( KeyName, \"%s\\\\%s\", TEXT(PUTTY_REG_POS), Key ) ;\n\t\tReadSpecialMenu( menu, KeyName, &nbitem, 0 ) ;\n\t} else if( IniFileFlag == SAVEMODE_DIR ) {\n\t\tReadSpecialMenu( menu, Key, &nbitem, 0 ) ;\n\t}\n\n\tif( GetMenuItemCount( menu ) > 0 )\n\t\tAppendMenu( menu, MF_SEPARATOR, 0, 0 ) ;\n\n\t// Creation du menu bouton gauche\n\tDestroyMenu( HideMenu ) ;\n\tHideMenu = CreatePopupMenu() ;\n\tif( !IsUnique ) {\n\t\tAppendMenu( HideMenu, MF_ENABLED, IDM_LAUNCHER+3, \"&Hide all\" ) ;\n\t\tAppendMenu( HideMenu, MF_ENABLED, IDM_LAUNCHER+4, \"&Unhide all\" ) ;\n\t\t//AppendMenu( HideMenu, MF_ENABLED, IDM_LAUNCHER+5, \"&Refresh list\" ) ;\n\t\tAppendMenu( HideMenu, MF_ENABLED, IDM_LAUNCHER+6, \"&Window unique\" ) ;\n\t\tCheckMenuItem( HideMenu, IDM_LAUNCHER+6, MF_BYCOMMAND | MF_UNCHECKED) ;\n\t} else {\n\t\tAppendMenu( HideMenu, MF_ENABLED, IDM_LAUNCHER+6, \"&Window unique\" ) ;\n\t\tCheckMenuItem( HideMenu, IDM_LAUNCHER+6, MF_BYCOMMAND | MF_CHECKED) ;\n\t}\n\t//AppendMenu( HideMenu, MF_ENABLED, IDM_GONEXT, \"&Next\" ) ;\n\t//AppendMenu( HideMenu, MF_ENABLED, IDM_GOPREVIOUS, \"&Previous\" ) ;\n\tif( RefreshWinList( MainHwnd ) > 0 ) {\n\t\tAppendMenu( HideMenu, MF_SEPARATOR, 0, 0 ) ;\n\t\tfor( i=0 ; i<NbWin ; i++ ) {\n\t\t\tAppendMenu( HideMenu, MF_ENABLED, IDM_GOHIDE+i, TabWin[i].name ) ;\n\t\t\tSetMenuItemBitmaps ( HideMenu, IDM_GOHIDE+i, MF_BYCOMMAND, bmpUnCheck, bmpCheck ) ;\n\t\t\tif( IsWindowVisible( TabWin[i].hwnd ) ) \n\t\t\t\tCheckMenuItem( HideMenu, IDM_GOHIDE+i, MF_BYCOMMAND | MF_CHECKED) ;\n\t\t\telse \n\t\t\t\tCheckMenuItem( HideMenu, IDM_GOHIDE+i, MF_BYCOMMAND | MF_UNCHECKED) ;\n\t\t}\n\t}\n\tAppendMenu( HideMenu, MF_SEPARATOR, 0, 0 ) ;\n\tAppendMenu( HideMenu, MF_ENABLED, IDM_ABOUT, \"&About\" ) ;\n\tAppendMenu( HideMenu, MF_ENABLED, IDM_QUIT, \"&Quit\" ) ;\n\n\t\n\tAppendMenu( menu, MF_POPUP, (UINT_PTR)HideMenu, \"&Opened sessions\" ) ;\n\tAppendMenu( menu, MF_SEPARATOR, 0, 0 ) ;\n\t\n\tAppendMenu( menu, MF_ENABLED, IDM_LAUNCHER+7, \"&Refresh\" ) ;\n\tAppendMenu( menu, MF_ENABLED, IDM_LAUNCHER+1, \"&Configuration\" ) ;\n\tAppendMenu( menu, MF_ENABLED, IDM_LAUNCHER+2, \"&TTY-ed\" ) ;\n\tAppendMenu( menu, MF_SEPARATOR, 0, 0 ) ;\n\tAppendMenu( menu, MF_ENABLED, IDM_ABOUT, \"&About\" ) ;\n\tAppendMenu( menu, MF_ENABLED, IDM_QUIT, \"&Quit\" ) ;\n\n\treturn menu ;\n}\n\nvoid RefreshMenuLauncher( void ) {\n\tDestroyMenu( MenuLauncher ) ; \n\tMenuLauncher = NULL ;\n\tMenuLauncher = InitLauncherMenu( \"Launcher\" ) ;\n}\n\t\n// Nettoie les noms de folder en remplaçant les \"/\" par des \"\\\" et les \" \\ \" par des \" \\\"\n// Deplace dans kitty_commun.c\n/*\nvoid CleanFolderName( char * folder ) {\n\tint i, j ;\n\tif( folder == NULL ) return ;\n\tif( strlen( folder ) == 0 ) return ;\n\tfor( i=0 ; i<strlen(folder) ; i++ ) if( folder[i]=='/' ) folder[i]='\\\\' ;\n\tfor( i=0 ; i<(strlen(folder)-1) ; i++ ) \n\t\tif( folder[i]=='\\\\' ) \n\t\t\twhile( folder[i+1]==' ' ) for( j=i+1 ; j<strlen(folder) ; j++ ) folder[j]=folder[j+1] ;\n\tfor( i=(strlen(folder)-1) ; i>0 ; i-- )\n\t\tif( folder[i]=='\\\\' )\n\t\t\twhile( folder[i-1]==' ' ) {\n\t\t\t\tfor( j=i-1 ; j<strlen(folder) ; j++ ) folder[j]=folder[j+1] ;\n\t\t\t\ti-- ;\n\t\t\t\t}\n\t}\n*/\n\n// Supprime une arborescence   ==> deplace dans kitty_commun.c\n/*\nvoid DelDir( const char * directory ) {\n\tDIR * dir ;\n\tstruct dirent * de ;\n\tchar fullpath[MAX_VALUE_NAME] ;\n\n\tif( (dir=opendir(directory)) != NULL ) {\n\t\twhile( (de=readdir( dir ) ) != NULL ) \n\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") ) {\n\t\t\tsprintf( fullpath, \"%s\\\\%s\", directory, de->d_name ) ;\n\t\t\tif( GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY ) { DelDir( fullpath ) ; }\n\t\t\telse if( !(GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY) ) { unlink( fullpath ) ; }\n\t\t\t}\n\t\tclosedir( dir ) ;\n\t\t_rmdir( directory ) ;\n\t\t}\n\t}\n*/\n\n// Initialise l'arborescence Launcher en mode savemode=dir avec arborescence\nvoid InitLauncherDir( const char * directory ) {\n\tchar fullpath[MAX_VALUE_NAME], buffer[MAX_VALUE_NAME] ;\n\tDIR * dir ;\n\tstruct dirent * de ;\n\tFILE * fp ;\n\t\n\tif( strlen(directory)>0 ) {\n\t\tsprintf( fullpath, \"%s\\\\Sessions\\\\%s\", ConfigDirectory, directory ) ;\n\t\tsprintf( buffer, \"%s\\\\Launcher\\\\%s\", ConfigDirectory, directory ) ;\n\t} else {\n\t\tsprintf( fullpath, \"%s\\\\Sessions\", ConfigDirectory ) ;\n\t\tsprintf( buffer, \"%s\\\\Launcher\", ConfigDirectory ) ;\n\t}\n\tif( !MakeDir( buffer ) ) { \n\t\t//MessageBox(NULL,buffer,\"Error\",MB_OK|MB_ICONERROR); \n\t\tMessageBox(NULL,\"Unable to create the menu launcher directory\",\"Error\",MB_OK|MB_ICONERROR); \n\t}\n\tif( (dir=opendir(fullpath)) != NULL ) {\n\t\twhile( (de=readdir(dir)) != NULL ) \n\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") )\t{\n\t\t\tsprintf( fullpath, \"%s\\\\Sessions\\\\%s\\\\%s\", ConfigDirectory, directory, de->d_name ) ;\n\t\t\tif( !(GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY) ) {\n\t\t\t\tsprintf( buffer, \"%s\\\\Launcher\\\\%s\\\\%s\", ConfigDirectory, directory, de->d_name ) ;\n\t\t\t\tif( (fp=fopen(buffer,\"wb\")) != NULL ) {\n\t\t\t\t\tunmungestr( de->d_name, buffer, MAX_VALUE_NAME) ;\n\t\t\t\t\tfprintf( fp, \"%s\\\\%s\\\\\", buffer, directory ) ;\n\t\t\t\t\tfclose( fp ) ; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse if( (GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY) ) {\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", directory, de->d_name ) ;\n\t\t\t\tif( buffer[0]=='\\\\' ) InitLauncherDir( buffer+1 ) ;\n\t\t\t\telse InitLauncherDir( buffer ) ;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\tclosedir( dir ) ;\n\t}\n\n// Inititalise la clé de registre Launcher avec les sessions enregistrées\nvoid InitLauncherRegistry( void ) {\n\tHKEY hKey ;\n\tchar buffer[MAX_VALUE_NAME] ;\n\tint i;\n\t\n\tif( (IniFileFlag == SAVEMODE_REG)||(IniFileFlag == SAVEMODE_FILE) ) {\n\t\tTCHAR folder[MAX_VALUE_NAME], achClass[MAX_PATH] = TEXT(\"\");\n\t\tDWORD   cchClassName=MAX_PATH,cSubKeys=0,cbMaxSubKey,cchMaxClass;\n\t\tDWORD\tcValues,cchMaxValue,cbMaxValueData,cbSecurityDescriptor;\n\t\tFILETIME ftLastWriteTime;\n\t\n\t\tsprintf( buffer, \"%s\\\\Launcher\", PUTTY_REG_POS ) ;\n\t\tRegDelTree (HKEY_CURRENT_USER, buffer ) ;\n\t\tRegTestOrCreate( HKEY_CURRENT_USER, buffer, NULL, NULL ) ;\n\t\tsprintf( buffer, \"%s\\\\Sessions\", PUTTY_REG_POS ) ;\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, buffer, 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n\n\t\tRegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime);\n\n\t\tif( cSubKeys>0 )\n\t\t\tfor (i=0; i<cSubKeys; i++) {\n\t\t\t\tDWORD cchValue = MAX_VALUE_NAME; \n\t\t\t\tchar lpData[4096] ;\n\t\t\t\tif( RegEnumKeyEx(hKey, i, lpData, &cchValue, NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\t\t\tsprintf( buffer,\"%s\\\\Sessions\\\\%s\", TEXT(PUTTY_REG_POS), lpData ) ;\n\t\t\t\t\tif( !GetValueData(HKEY_CURRENT_USER, buffer, \"Folder\", folder ) ) \n\t\t\t\t\t\t{ strcpy( folder, \"Default\" ) ; }\n\t\t\t\t\tCleanFolderName( folder ) ;\n\t\t\t\t\tif( !strcmp( folder, \"Default\" ) || (strlen(folder)<=0) ) \n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\Launcher\", TEXT(PUTTY_REG_POS) ) ;\n\t\t\t\t\telse \n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\Launcher\\\\%s\", TEXT(PUTTY_REG_POS), folder ) ;\n\t\t\t\t\tstrcpy( folder, \"\" ) ;\n\t\t\t\t\tunmungestr( lpData, folder, MAX_VALUE_NAME ) ;\n\t\t\t\t\tif( strlen(folder) > 0 )\n\t\t\t\t\t\tRegTestOrCreate( HKEY_CURRENT_USER, buffer, folder, folder ) ;\n\t\t\t\t}\n\t\t\t}\n\t\tRegCloseKey( hKey ) ;\n\t} else if( (IniFileFlag == SAVEMODE_DIR)&&(DirectoryBrowseFlag==0) ) {\n\t\tchar fullpath[MAX_VALUE_NAME], folder[MAX_VALUE_NAME] ;\n\t\tDIR * dir ;\n\t\tstruct dirent * de ;\n\t\tFILE * fp ;\n\t\tsprintf( fullpath, \"%s\\\\Launcher\", ConfigDirectory ) ;\n\t\tDelDir( fullpath ) ;\n\t\tif(!MakeDir( fullpath ) ) { MessageBox(NULL,\"Unable to create the menu launcher directory\",\"Error\",MB_OK|MB_ICONERROR); }\n\t\tsprintf( fullpath, \"%s\\\\Sessions\", ConfigDirectory ) ;\n\t\tif( (dir=opendir(fullpath)) != NULL ) {\n\t\t\twhile( (de=readdir(dir)) != NULL ) \n\t\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") )\t{\n\t\t\t\tsprintf( fullpath, \"%s\\\\Sessions\\\\%s\", ConfigDirectory, de->d_name ) ;\n\t\t\t\tif( !(GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY) ) {\n\t\t\t\t\tstrcpy( folder, \"\" ) ;\n\t\t\t\t\tunmungestr( de->d_name, buffer, MAX_VALUE_NAME) ;\n\t\t\t\t\tGetSessionFolderName( buffer, folder ) ;\n\t\t\t\t\tCleanFolderName( folder ) ;\n\t\t\t\t\tsprintf( buffer, \"%s\\\\Launcher\\\\%s\", ConfigDirectory, folder ) ;\n\t\t\t\t\tif( strcmp(folder,\"Default\") ) {\n\t\t\t\t\t\tMakeDir( buffer ) ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\Launcher\\\\%s\\\\%s\", ConfigDirectory, folder, de->d_name ) ;\n\t\t\t\t\t} else sprintf( buffer, \"%s\\\\Launcher\\\\%s\", ConfigDirectory, de->d_name ) ;\n\t\t\t\t\tif( (fp=fopen(buffer,\"wb\")) != NULL ) {\n\t\t\t\t\t\tunmungestr( de->d_name, buffer, MAX_VALUE_NAME) ;\n\t\t\t\t\t\tfprintf( fp, \"%s\\\\%s\\\\\", buffer, buffer ) ;\n\t\t\t\t\t\tfclose( fp ) ; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir) ;\n\t\t}\n\t} else if( (IniFileFlag == SAVEMODE_DIR)&&DirectoryBrowseFlag ) {\n\t\tchar fullpath[MAX_VALUE_NAME] ;\n\t\tsprintf( fullpath, \"%s\\\\Launcher\", ConfigDirectory ) ;\n\t\tDelDir( fullpath ) ;\n\t\tif( !MakeDir( fullpath ) ) { MessageBox(NULL,\"Unable to create the menu launcher directory\",\"Error\",MB_OK|MB_ICONERROR); }\n\t\tInitLauncherDir( \"\" ) ;\n\t}\n}\n\nvoid DisplayContextMenu( HWND hwnd, HMENU menu ) {\n\tHMENU hMenuPopup = menu ;\n\tPOINT pt;\n\t\n\tSetForegroundWindow( hwnd ) ;\n\tGetCursorPos (&pt);\n\tTrackPopupMenu (hMenuPopup, TPM_LEFTALIGN, pt.x, pt.y, 0, hwnd, NULL);\n}\n\t\n// Gestion Hide/UnHide all\nstatic int CurrentVisibleWin = -1 ; /* -1 = toutes visibles */\n\nvoid ManageHideOne( HWND hwnd ) { PostMessage( hwnd, WM_COMMAND, IDM_HIDE, 0 ) ; }\nvoid ManageUnHideOne( HWND hwnd ) { PostMessage( hwnd, WM_COMMAND, IDM_UNHIDE, 0 ) ; }\n\nBOOL CALLBACK RefreshWinListProc( HWND hwnd, LPARAM lParam ) {\n\tchar buffer[256] ;\n\tGetClassName( hwnd, buffer, 256 ) ;\n\t\n\tif( !strcmp( buffer, KiTTYClassName ) )\n\tif( hwnd != MainHwnd ) {\n\t\tTabWin[NbWin].hwnd=hwnd ;\n\t\tGetWindowText( hwnd, TabWin[NbWin].name, 127 ) ;\n\t\tNbWin++ ;\n\t}\n\n\treturn TRUE ;\n}\n\nint RefreshWinList( HWND hwnd ) {\n\tNbWin=0 ;\n\tEnumWindows( RefreshWinListProc, 0 ) ;\n\treturn NbWin ;\n}\n\t\nvoid GoNext( HWND hwnd ) {\n\tint i ;\n\tif( RefreshWinList( hwnd ) > 1 ) \n\tfor( i=0 ; i<NbWin ; i++ ) {\n\t\tif( hwnd == TabWin[i].hwnd ) {\n\t\t\tManageHideOne( hwnd ) ;\n\t\t\tif( i == (NbWin-1) ) {\n\t\t\t\tManageUnHideOne( TabWin[0].hwnd ) ;\n\t\t\t\tSetFocus( TabWin[0].hwnd ) ;\n\t\t\t} else {\n\t\t\t\tManageUnHideOne( TabWin[i+1].hwnd ) ;\n\t\t\t\tSetFocus( TabWin[i+1].hwnd ) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\t}\n\t}\n}\n\nvoid GoPrevious( HWND hwnd ) {\n\tint i ;\n\tif( RefreshWinList( hwnd ) > 1 ) \n\tfor( i=0 ; i<NbWin ; i++ ) {\n\t\tif( hwnd == TabWin[i].hwnd ) {\n\t\t\tManageHideOne( hwnd ) ;\n\t\t\tif( i == 0 ) {\n\t\t\t\tManageUnHideOne( TabWin[NbWin-1].hwnd ) ;\n\t\t\t\tSetFocus( TabWin[NbWin-1].hwnd ) ;\n\t\t\t} else {\n\t\t\t\tManageUnHideOne( TabWin[i-1].hwnd ) ;\n\t\t\t\tSetFocus( TabWin[i-1].hwnd ) ;\n\t\t\t}\n\t\t\tbreak ;\n\t\t}\n\t}\n}\n\nvoid ManageHideAll( HWND hwnd ) {\n\tint i ;\n\tif( RefreshWinList( hwnd ) > 0 ) {\n\t\tfor( i=0 ; i<NbWin ; i++ ) {\n\t\t\tManageHideOne( TabWin[i].hwnd ) ;\n\t\t}\n\t}\n\tCurrentVisibleWin = 0 ;\n}\n\nvoid ManageUnHideAll( HWND hwnd ) {\n\tint i ;\n\tif( RefreshWinList( hwnd ) > 0 ) {\n\t\tfor( i=0 ; i<NbWin ; i++ ) ManageUnHideOne( TabWin[i].hwnd ) ;\n\t}\n\tCurrentVisibleWin = -1 ;\n}\n\t\nvoid ManageGoNext( HWND hwnd ) {\n\tif( CurrentVisibleWin == -1 ) return ;\n\tManageHideOne( TabWin[CurrentVisibleWin].hwnd ) ;\n\tCurrentVisibleWin++ ;\n\tif( CurrentVisibleWin>=NbWin ) CurrentVisibleWin=0 ;\n\tManageUnHideOne( TabWin[CurrentVisibleWin].hwnd ) ;\n}\n\nvoid ManageGoPrevious( HWND hwnd ) {\n\tif( CurrentVisibleWin == -1 ) return ;\n\tManageHideOne( TabWin[CurrentVisibleWin].hwnd ) ;\n\tCurrentVisibleWin-- ;\n\tif( CurrentVisibleWin<0 ) CurrentVisibleWin=NbWin-1 ;\n\tManageUnHideOne( TabWin[CurrentVisibleWin].hwnd ) ;\n}\n\t\nvoid ManageGo( const int n ) {\n\tif( CurrentVisibleWin == -1 ) return ;\n\tif( (n<0)||(n>=100) ) return ;\n\tManageHideOne( TabWin[CurrentVisibleWin].hwnd ) ;\n\tCurrentVisibleWin = n ;\n\tManageUnHideOne( TabWin[CurrentVisibleWin].hwnd ) ;\n}\n\t\nvoid ManageSwitch( const int n ) { \n\tSendMessage( TabWin[n].hwnd, WM_COMMAND, IDM_SWITCH_HIDE, 0 ) ; \n\tSetForegroundWindow( TabWin[n].hwnd ) ;\n\tSetFocus( TabWin[n].hwnd ) ;\n}\n\t\n// Procedures principales du launcher\nLRESULT CALLBACK Launcher_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n\tint ResShell ;\n\tstatic UINT s_uTaskbarRestart;\n\t\n\tswitch( uMsg ) {\n\t\tcase WM_CREATE:\n\t\ts_uTaskbarRestart = RegisterWindowMessage(TEXT(\"TaskbarCreated\"));\n\t\tMenuLauncher = InitLauncherMenu( \"Launcher\" ) ;\n        \n\t// Initialisation de la structure NOTIFYICONDATA\n\tTrayIcone.cbSize = sizeof(TrayIcone);\t// On alloue la taille nécessaire pour la structure\n\tif( oldIconFlag ) {\n\t\tTrayIcone.uID = IDI_BLACKBALL ;\t// On lui donne un ID\n\t\tTrayIcone.hIcon = LoadIcon((HINSTANCE) GetModuleHandle (NULL), MAKEINTRESOURCE(IDI_BLACKBALL));\n\t} else {\n\t\tTrayIcone.uID = IDI_PUTTY_LAUNCH ;\t// On lui donne un ID\n\t\tTrayIcone.hIcon = LoadIcon((HINSTANCE) GetModuleHandle (NULL), MAKEINTRESOURCE(IDI_PUTTY_LAUNCH));\n\t}\n\tTrayIcone.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;\t// On lui indique les champs valables\n\t// On lui dit qu'il devra \"écouter\" son environement (clique de souris, etc)\n\tTrayIcone.uCallbackMessage = KLWM_NOTIFYICON;\n#ifdef FLJ\n\tTrayIcone.szTip[1024] = (TCHAR*)\"PuTTY\\0\" ;\t\t\t// Le tooltip par défaut, soit rien\n#else\n\t//TrayIcone.szTip[1024] = \"KiTTY That\\'s all folks!\\0\" ;\t\t\t// Le tooltip par défaut, soit rien\n\tstrcpy( TrayIcone.szTip, \"KiTTY That\\'s all folks!\\0\" ) ;\t\t\t// Le tooltip par défaut, soit rien\n#endif\n\tTrayIcone.hWnd = hwnd ;\n\tResShell = Shell_NotifyIcon(NIM_ADD, &TrayIcone);\n\tif( ResShell ) {\n#ifdef FLJ\n\t\tstrcpy( TrayIcone.szTip, \"PuTTY\\0\" ) ;\n#else\n\t\tstrcpy( TrayIcone.szTip, \"KiTTY That\\'s all folks!\\0\" ) ;\n#endif\n\t\tResShell = Shell_NotifyIcon(NIM_MODIFY, &TrayIcone);\n\t\tif (IsWindowVisible(hwnd)) ShowWindow(hwnd, SW_HIDE);\n\t\t//SendMessage(hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0);\n\t\treturn 1 ;\n\t} else \n\t\treturn 0 ;\n\t\t\tbreak ;\n\t\n\t\tcase KLWM_NOTIFYICON :\n\t\t\tswitch (lParam)\t{\n\t\t\t\t/*\n\t\t\t\tcase WM_LBUTTONDBLCLK : \n\t\t\t\t\tShowWindow(hwnd, SW_SHOWNORMAL);\n\t\t\t\t\tSetForegroundWindow( hwnd ) ;\n\t\t\t\t\tint ResShell;\n\t\t\t\t\tResShell = Shell_NotifyIcon(NIM_DELETE, &TrayIcone);\n\t\t\t\t\tif( ResShell ) return 1 ;\n\t\t\t\t\telse return 0 ;\n\t\t\t\tbreak ;\n\t\t\t\t*/\n\t\t\t\tcase WM_RBUTTONUP:\n\t\t\t\t\t{\n\t\t\t\t\tif ( (wParam == IDI_PUTTY_LAUNCH) || (wParam == IDI_BLACKBALL) ) {\n\t\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\t\tDisplayContextMenu( hwnd, HideMenu ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\t\tcase WM_LBUTTONUP: \n\t\t\t\t\t{\n\t\t\t\t\tif ( (wParam == IDI_PUTTY_LAUNCH) || (wParam == IDI_BLACKBALL) ) {\n\t\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\t\tDisplayContextMenu( hwnd, MenuLauncher ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\tbreak ;\n\t\n\t\tcase WM_DESTROY: \n\t\t\tManageUnHideAll( hwnd ) ;\n\t\t\tPostQuitMessage( 0 ) ;\n\t\t\tbreak ;\n\t\tcase WM_CLOSE:\n\t\t\tPostMessage(hwnd, WM_DESTROY,0,0) ;\n\t\t\tbreak ;\n\t\tcase WM_COMMAND: {//Commandes du menu\n\t\t\tswitch( LOWORD(wParam) ) {\n\t\t\t\tcase IDM_ABOUT:\n\t\t\t\t\tMessageBox(hwnd,\"     TTY Launcher\\nSession launcher for TTY terminal emulator\\n(c), 2009-2023\",\"About\", MB_OK ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_QUIT:\n\t\t\t\t\tResShell = Shell_NotifyIcon(NIM_DELETE, &TrayIcone) ;\n\t\t\t\t\tManageUnHideAll( hwnd ) ;\n\t\t\t\t\tPostQuitMessage( 0 ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER:\n\t\t\t\t\tDestroyMenu( MenuLauncher ) ; \n\t\t\t\t\tMenuLauncher = NULL ;\n\t\t\t\t\tMenuLauncher = InitLauncherMenu( \"Launcher\" ) ;\n\t\t\t\t\tShell_NotifyIcon(NIM_DELETE, &TrayIcone);\n\t\t\t\t\tShell_NotifyIcon(NIM_ADD, &TrayIcone);\n\t\t\t\t\tShell_NotifyIcon(NIM_MODIFY, &TrayIcone);\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+1:\n\t\t\t\t\tRunPuTTY( hwnd, \"\" ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+2:\n\t\t\t\t\tRunPuTTY( hwnd, \"-ed\" ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+3:\n\t\t\t\t\tManageHideAll( hwnd ) ;\n\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+4:\n\t\t\t\t\tManageUnHideAll( hwnd ) ;\n\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+5:\n\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+6:\n\t\t\t\t\tIsUnique = abs( IsUnique -1 ) ;\n\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_LAUNCHER+7:\n\t\t\t\t\tif( LauncherConfReload ) InitLauncherRegistry() ;\n\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_GONEXT:\n\t\t\t\t\tManageGoNext( hwnd ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\tcase IDM_GOPREVIOUS:\n\t\t\t\t\tManageGoPrevious( hwnd ) ;\n\t\t\t\t\tbreak ;\n\t\t\t\t}\n\t\t\t\tint nb ;\n\t\t\t\tnb = LOWORD(wParam)-IDM_USERCMD ;\n\t\t\t\tif( ( nb >= 0 ) && ( nb<NB_MENU_MAX ) ) {\n\t\t\t\t\tif( SpecialMenu[nb]!= NULL )\n\t\t\t\t\t//if( strlen( SpecialMenu[nb] ) > 0 ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\tif( DirectoryBrowseFlag ) {\n\t\t\t\t\t\t\tchar buffer[1024]=\"\" ;\n\t\t\t\t\t\t\tGetMenuString( MenuLauncher, nb+IDM_USERCMD, buffer, 1024, MF_BYCOMMAND ) ;\n\t\t\t\t\t\t\tRunSession( hwnd, SpecialMenu[nb], buffer ) ;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\telse RunSession( hwnd, SpecialMenu[nb], SpecialMenu[nb] ) ;\n\t\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\t\t}\n\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\tnb = LOWORD(wParam)-IDM_GOHIDE ;\n\t\t\t\tif( ( nb >= 0 ) && ( nb<100 ) ) {\n\t\t\t\t\tif( !IsUnique )\tManageSwitch( nb ) ;\n\t\t\t\t\telse { \n\t\t\t\t\t\tManageHideAll( hwnd ) ; \n\t\t\t\t\t\tManageUnHideOne( TabWin[nb].hwnd ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\tRefreshMenuLauncher() ;\n\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak ;\n\t\tdefault: // Message par défaut\n\t\t\tif( uMsg == s_uTaskbarRestart ) { // On reaffiche l'icone après un crash de l'explorateur windows\n\t\t\t\tShell_NotifyIcon(NIM_DELETE, &TrayIcone);\n\t\t\t\tShell_NotifyIcon(NIM_ADD, &TrayIcone);\n\t\t\t\tShell_NotifyIcon(NIM_MODIFY, &TrayIcone);\n\t\t\t}\n\t\t\treturn DefWindowProc(hwnd, uMsg, wParam, lParam);\n\t}\n\treturn -1 ;\n}\n\t\nint WINAPI Launcher_WinMain(HINSTANCE inst, HINSTANCE prev, LPSTR cmdline, int show) {\n\thinst = inst ;\n\tWNDCLASS wndclass ;\n\tMSG msg;\n\tchar buffer[4096] ;\n\tchar className[1024] = \"KiTTYLauncher\" ;\n\t\n\tif( strcmp(KiTTYClassName,appname) ) { strcpy(className,KiTTYClassName) ; }\n\telse if( strcmp(KiTTYClassName,\"KiTTY\") ) { strcpy(className,KiTTYClassName) ; }\n\tif( ReadParameter( \"Launcher\", \"classname\", buffer ) ) {\n\t\tbuffer[1023]='\\0' ;\n\t\tif( strlen(buffer)>0 ) { strcpy(className,buffer) ; }\n\t}\n\t\n\tif( FindWindow(className,className) ) {\n\t\tif( ReadParameter( \"Launcher\", \"alreadyRunCheck\", buffer ) ) {\n\t\t\tif( !stricmp( buffer, \"yes\" ) ) return 0 ;\n\t\t} else { \n\t\t\treturn 0 ; \n\t\t}\n\t}\n\n\tif( strstr( cmdline, \"-putty\" ) != NULL ) SetPuttyFlag(1) ;\n\n\twndclass.style = 0;\n\twndclass.lpfnWndProc = Launcher_WndProc;\n\twndclass.cbClsExtra = 0;\n\twndclass.cbWndExtra = 0;\n\twndclass.hInstance = inst;\n\tif( strstr( cmdline, \"-oldicon\" ) != NULL ) { oldIconFlag = 1 ; } \n\tif( oldIconFlag ) { wndclass.hIcon = LoadIcon(inst, MAKEINTRESOURCE(IDI_BLACKBALL) ); }\n\telse { wndclass.hIcon = LoadIcon(inst, MAKEINTRESOURCE(IDI_PUTTY_LAUNCH) ); }\n\twndclass.hCursor = LoadCursor(NULL, IDC_IBEAM) ;\n\twndclass.hbrBackground = NULL;\n\twndclass.lpszMenuName = NULL;\n\twndclass.lpszClassName = className ;\n\n\tif( !RegisterClass(&wndclass) ) return 1 ;\n\n\tif( ReadParameter( \"Launcher\", \"reload\", buffer ) ) {\n\t\tif( !stricmp( buffer, \"NO\" ) ) LauncherConfReload = 0 ;\n\t}\n\tif( LauncherConfReload ) InitLauncherRegistry() ;\n\t\t\n\tMainHwnd = CreateWindowEx(0, className, \"KiTTYLauncher\",\n\t\t\t\t0,//WS_OVERLAPPEDWINDOW,\n\t\t\t\tCW_USEDEFAULT, CW_USEDEFAULT,\n\t\t\t\tCW_USEDEFAULT, CW_USEDEFAULT,\n\t\t\t\tNULL, NULL, inst, NULL);\n\t\n\t//ShowWindow(hwnd, show) ; UpdateWindow(hwnd) ;\n\n\twhile (GetMessage(&msg, NULL, 0, 0)) {\n\t\t//if(!TranslateAccelerator(hwnd, hAccel, &msg)){\n\t\t\tTranslateMessage(&msg);\n\t\t\tDispatchMessage(&msg);\n\t\t//\t}\n\t}\n\treturn msg.wParam;\n}\n\n#endif\nvoid RunConfig( Conf * conf ) {\n\tchar b[2048];\n\t//char c[180];\n\t//int freecl = FALSE;\n\tchar *cl;\n\tconst char *argprefix;\n\tBOOL inherit_handles;\n\tSTARTUPINFO si;\n\tPROCESS_INFORMATION pi;\n\tHANDLE filemap = NULL;\n\t\n\tchar bufpass[1024] ;\n\tstrcpy( bufpass, conf_get_str(conf,CONF_password)) ;\n\tMASKPASS(GetCryptSaltFlag(),bufpass) ;\n\tconf_set_str(conf,CONF_password,bufpass) ;\n\t\n\tif (restricted_acl) {\n\t\targprefix = \"&R\";\n\t} else {\n\t\targprefix = \"\";\n\t}\n\t/*\n\t * Allocate a file-mapping memory chunk for the\n\t * config structure.\n\t */\n\tSECURITY_ATTRIBUTES sa;\n\tstrbuf *serbuf;\n\tvoid *p;\n\tint size;\n\n\tserbuf = strbuf_new();\n\tconf_serialise(BinarySink_UPCAST(serbuf), conf);\n\tsize = serbuf->len;\n\n\tsa.nLength = sizeof(sa);\n\tsa.lpSecurityDescriptor = NULL;\n\tsa.bInheritHandle = TRUE;\n\tfilemap = CreateFileMapping(INVALID_HANDLE_VALUE,\n\t\t&sa,\n\t\tPAGE_READWRITE,\n\t\t0, size, NULL);\n\tif (filemap && filemap != INVALID_HANDLE_VALUE) {\n\t\tp = MapViewOfFile(filemap, FILE_MAP_WRITE, 0, 0, size);\n\t\tif (p) {\n\t\t\tmemcpy(p, serbuf->s, size);\n\t\t\tUnmapViewOfFile(p);\n\t\t}\n\t}\n\tstrbuf_free(serbuf);\n\tinherit_handles = true;\n\tcl = dupprintf(\"putty %s&%p:%u\", argprefix,\n\t\tfilemap, (unsigned)size);\n\t\t    \n\tMASKPASS(GetCryptSaltFlag(),bufpass);\n\tconf_set_str(conf,CONF_password,bufpass);\n\tmemset(bufpass,0,strlen(bufpass));\n\t\t    \n\tGetModuleFileName(NULL, b, sizeof(b) - 1);\n\tsi.cb = sizeof(si);\n\tsi.lpReserved = NULL;\n\tsi.lpDesktop = NULL;\n\tsi.lpTitle = NULL;\n\tsi.dwFlags = 0;\n\tsi.cbReserved2 = 0;\n\tsi.lpReserved2 = NULL;\n\tCreateProcess(b, cl, NULL, NULL, inherit_handles,\n\t\tNORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi);\n\tCloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n\n\tif (filemap)\n\t\tCloseHandle(filemap);\n\tsfree(cl);\n}\n\nvoid RunPuTTY( HWND hwnd, char * param ) {\n\tchar buffer[4096]=\"\",shortname[1024]=\"\" ; ;\n\tif( GetModuleFileName( NULL, (LPTSTR)buffer, 1023 ) ) \n\t\tif( GetShortPathName( buffer, shortname, 1023 ) ) {\n\t\t\tif( strlen(param) > 0 ) \n\t\t\t\tsprintf( buffer, \"%s %s\", shortname, param ) ;\n\t\t\telse \n\t\t\t\tstrcpy( buffer, shortname ) ;\n\t\t\tRunCommand( hwnd, buffer ) ;\n\t\t}\n}\n\nint RunSession( HWND hwnd, const char * folder_in, char * session_in ) {\n\tchar buffer[4096]=\"\", shortname[1024]=\"\" ;\n\tchar *session=NULL ;\n\tint return_code=0 ;\n\t\n\tif( session_in==NULL ) return 0 ;\n\tif( strlen(session_in) <= 0 ) return 0 ;\n\t\t\n\tif( !GetModuleFileName( NULL, (LPTSTR)buffer, 1023 ) ) return 0 ;\n\tif( !GetShortPathName( buffer, shortname, 1023 ) ) return 0 ;\n\n\tsession = (char*)malloc(strlen(session_in)+100) ;\n\t\n\tif( (IniFileFlag==SAVEMODE_REG)||(IniFileFlag==SAVEMODE_FILE) ) {\n\t\tmungestr(session_in, session) ;\n\t\tsprintf( buffer, \"%s\\\\Sessions\\\\%s\", TEXT(PUTTY_REG_POS), session ) ;\n\t\tif( RegTestKey(HKEY_CURRENT_USER, buffer) ) {\n\t\t\tstrcpy( session, session_in ) ;\n\t\t\tif( session[strlen(session)-1] == '&' ) {\n\t\t\t\tsession[strlen(session)-1]='\\0' ;\n\t\t\t\twhile( (session[strlen(session)-1]==' ')||(session[strlen(session)-1]=='\\t') ) session[strlen(session)-1]='\\0' ;\n\t\t\t\tif( GetPuttyFlag() )\tsprintf( buffer, \"%s -putty -load \\\"%s\\\" -send-to-tray\", shortname, session ) ;\n\t\t\t\telse sprintf( buffer, \"%s -load \\\"%s\\\" -send-to-tray\", shortname, session ) ;\n\t\t\t} else {\n\t\t\t\tif( GetPuttyFlag() )\tsprintf( buffer, \"%s -putty -load \\\"%s\\\"\", shortname, session ) ;\n\t\t\t\telse sprintf( buffer, \"%s -load \\\"%s\\\"\", shortname, session ) ;\n\t\t\t}\n\t\t\tRunCommand( hwnd, buffer ) ;\n\t\t\treturn_code = 1 ;\n\t\t} else { \n\t\t\tRunCommand( hwnd, session_in ) ; \n\t\t}\n\t} else if( IniFileFlag==SAVEMODE_DIR ) {\n\t\tif( DirectoryBrowseFlag ) {\n\t\t\tif( (folder_in!=NULL)&&strcmp(folder_in,\"\")&&strcmp(folder_in,\"Default\") ) {\n\t\t\t\tstrcat( shortname, \" -folder \\\"\" ) ;\n\t\t\t\tstrcat( shortname, folder_in ) ;\n\t\t\t\tstrcat( shortname, \"\\\"\" ) ;\n\t\t\t}\n\t\t}\n\t\tstrcpy( session, session_in ) ;\n\t\tif( session[strlen(session)-1] == '&' ) {\n\t\t\tsession[strlen(session)-1]='\\0' ;\n\t\t\twhile( (session[strlen(session)-1]==' ')||(session[strlen(session)-1]=='\\t') ) session[strlen(session)-1]='\\0' ;\n\t\t\tif( GetPuttyFlag() )\tsprintf( buffer, \"%s -putty -load \\\"%s\\\" -send-to-tray\", shortname, session ) ;\n\t\t\telse sprintf( buffer, \"%s -load \\\"%s\\\" -send-to-tray\", shortname, session ) ;\n\t\t} else {\n\t\t\tif( GetPuttyFlag() )\tsprintf( buffer, \"%s -putty -load \\\"%s\\\"\", shortname, session ) ;\n\t\t\telse sprintf( buffer, \"%s -load \\\"%s\\\"\", shortname, session ) ;\n\t\t\t//else sprintf( buffer, \"%s @%s\", shortname, session ) ;\n\t\t}\n/*\t\tif( DirectoryBrowseFlag ) {\n\t\t\tif( strcmp(folder_in,\"\")&&strcmp(folder_in,\"Default\") ) {\n\t\t\t\tstrcat( buffer, \" -folder \\\"\" ) ;\n\t\t\t\tstrcat( buffer, folder_in ) ;\n\t\t\t\tstrcat( buffer, \"\\\"\" ) ;\n\t\t\t\t}\n\t\t\t}*/\n//MessageBox( hwnd, buffer, \"Info\", MB_OK ) ;\n\t\tRunCommand( hwnd, buffer ) ;\n\t\treturn_code = 1 ;\n\t}\n\n\tfree( session ) ;\n\treturn return_code ;\n}\n"
        },
        {
          "name": "kitty_launcher.h",
          "type": "blob",
          "size": 0.333984375,
          "content": "#ifndef KITTY_LAUNCHER_H\n#define KITTY_LAUNCHER_H\n\n#include <windows.h>\n\nvoid GoNext( HWND hwnd ) ;\nvoid GoPrevious( HWND hwnd ) ;\nvoid RunPuTTY( HWND hwnd, char * param ) ;\nint RunSession( HWND hwnd, const char * folder_in, char * session_in ) ;\nint WINAPI Launcher_WinMain(HINSTANCE inst, HINSTANCE prev, LPSTR cmdline, int show) ;\n\n#endif\n"
        },
        {
          "name": "kitty_light.c",
          "type": "blob",
          "size": 0.099609375,
          "content": "/* \n * Devrait etre vide en temps normal\n * Sert juste a reussir la compilation en phase de debug\n */\n"
        },
        {
          "name": "kitty_proxy.c",
          "type": "blob",
          "size": 7.8720703125,
          "content": "#include \"putty.h\"\n#include \"kitty.h\"\n#include \"kitty_tools.h\"\n#include \"kitty_registry.h\"\n#include \"kitty_proxy.h\"\n#include \"kitty_store.h\"\n#include \"dialog.h\"\n#include \"storage.h\"\n#include <sys/types.h>\n#include <dirent.h>\n#include <windows.h>\n\n\n// Flag pour ajouter la fonction Proxy Selector\nstatic int ProxySelectionFlag = 0 ;\nint GetProxySelectionFlag() { return ProxySelectionFlag ; }\nvoid SetProxySelectionFlag( const int flag ) { ProxySelectionFlag = flag ; }\n\nvoid debug_logevent( const char *fmt, ... ) ;\n\nstruct Proxies proxies[MAX_PROXY] ;\n    \nvoid InitProxyList(void) {\n\tHKEY hKey ;\n\tint i,j;\n\tchar buffer[MAX_VALUE_NAME] ;\n\tfor( i=0; i<lenof(proxies); i++) {\n\t\tproxies[i].name = NULL;\n\t\tproxies[i].val = i;\n\t}\n\tproxies[0].name=(char*)malloc(26); strcpy(proxies[0].name,\"- Session defined proxy -\");\n\tproxies[1].name=(char*)malloc(13); strcpy(proxies[1].name,\"- No proxy -\");\n\tj=2;\n\tif( (IniFileFlag == SAVEMODE_REG)||(IniFileFlag == SAVEMODE_FILE) ) {\n\t\tTCHAR \tachClass[MAX_PATH] = TEXT(\"\");\n\t\tDWORD   cchClassName=MAX_PATH,cSubKeys=0,cbMaxSubKey,cchMaxClass;\n\t\tDWORD\tcValues,cchMaxValue,cbMaxValueData,cbSecurityDescriptor;\n\t\tFILETIME ftLastWriteTime;\n\t\tsprintf( buffer, \"%s\\\\Proxies\", PUTTY_REG_POS ) ;\n\t\tRegTestOrCreate( HKEY_CURRENT_USER, buffer, NULL, NULL ) ;\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, buffer, 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n\t\tRegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime);\n\t\tif( cSubKeys>0 )\n\t\t\tfor (i=0; i<cSubKeys; i++) {\n\t\t\t\tDWORD cchValue = MAX_VALUE_NAME; \n\t\t\t\tchar lpData[4096] ;\n\t\t\t\tif( RegEnumKeyEx(hKey, i, lpData, &cchValue, NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\t\t\t\tif( strcmp(lpData,\"None\") && strcmp(lpData,\"Default\") ) {\n\t\t\t\t\t\tproxies[j].name=(char*)malloc(strlen(lpData)+1);\n\t\t\t\t\t\tunmungestr( lpData, proxies[j].name, MAX_VALUE_NAME ) ;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tRegCloseKey( hKey ) ;\n\t} else if( IniFileFlag == SAVEMODE_DIR ) {\n\t\tchar fullpath[MAX_VALUE_NAME];\n\t\tDIR * dir ;\n\t\tstruct dirent * de ;\n\t\tsprintf( fullpath, \"%s\\\\Proxies\", ConfigDirectory ) ;\n\t\tif(!MakeDir( fullpath ) ) { MessageBox(NULL,\"Unable to create the proxy definitions directory\",\"Error\",MB_OK|MB_ICONERROR); }\n\t\tif( (dir=opendir(fullpath)) != NULL ) {\n\t\t\twhile( (de=readdir(dir)) != NULL )\n\t\t\tif( strcmp(de->d_name,\".\") && strcmp(de->d_name,\"..\") )\t{\n\t\t\t\tsprintf( fullpath, \"%s\\\\Proxies\\\\%s\", ConfigDirectory, de->d_name ) ;\n\t\t\t\tif( !(GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_NORMAL) ) {\n\t\t\t\t\tif( strcmp(de->d_name,\"None\") && strcmp(de->d_name,\"Default\") ) {\n\t\t\t\t\t\tproxies[j].name=(char*)malloc(strlen(de->d_name)+1);\n\t\t\t\t\t\tunmungestr( de->d_name, proxies[j].name, MAX_VALUE_NAME ) ;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclosedir(dir) ;\n\t\t}\n\t}\n}\n\nint LoadProxyInfo( Conf * conf, const char * name ) {\n\tchar buffer[MAX_VALUE_NAME] ;\n\tif( !strcmp(name,\"- Session defined proxy -\") ) { return 0 ; }\n\tif( !strcmp(name,\"- No proxy -\") ) { \n\t\tdebug_logevent( \"Remove proxy definition\" ) ;\n\t\tconf_set_int(conf, CONF_proxy_type, PROXY_NONE) ; \n\t\treturn 1 ;\n\t}\n\tdebug_logevent( \"Load proxy \\\"%s\\\" definition\", name ) ;\n\tif( (IniFileFlag == SAVEMODE_REG)||(IniFileFlag == SAVEMODE_FILE) ) {\n\t\tHKEY hKey ;\n\t\tsprintf( buffer, \"%s\\\\Proxies\\\\\", PUTTY_REG_POS ) ;\n\t\tchar *b = (char*)malloc(4*strlen(name)+1);\n\t\tmungestr(name,b);\n\t\tstrcat(buffer,b);\n\t\tfree(b);\n\t\tif( RegOpenKeyEx( HKEY_CURRENT_USER, buffer, 0, KEY_READ, &hKey) != ERROR_SUCCESS ) {\n\t\t\tdebug_logevent( \"Unable to load proxy definition\" ) ;\n\t\t\treturn 0;\n\t\t}\n\t\tchar lpData[4096] ;\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyExcludeList\", lpData ) ) { \n\t\t\tconf_set_str( conf, CONF_proxy_exclude_list, lpData ) ; \n\t\t}\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyDNS\", lpData ) ) {\n\t\t\tint i=atoi(lpData);\n\t\t\tconf_set_int(conf, CONF_proxy_dns, (i+1)%3);\n\t\t}\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyLocalhost\", lpData ) ) { \n\t\t\tif( atoi(lpData) == 0 ) { conf_set_bool( conf, CONF_even_proxy_localhost, false ) ; \n\t\t\t} else { conf_set_bool( conf, CONF_even_proxy_localhost, true ) ;\n\t\t\t}\t\t\t\n\t\t}\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyMethod\", lpData ) ) {\n\t\t\tint i = atoi(lpData) ;\n\t\t\tif (i == 0) conf_set_int(conf, CONF_proxy_type, PROXY_NONE);\n\t\t\telse if (i == 1) conf_set_int(conf, CONF_proxy_type, PROXY_SOCKS4) ;\n\t\t\telse if (i == 2) conf_set_int(conf, CONF_proxy_type, PROXY_SOCKS5) ;\n\t\t\telse if (i == 3) conf_set_int(conf, CONF_proxy_type, PROXY_HTTP) ;\n\t\t\telse if (i == 4) conf_set_int(conf, CONF_proxy_type, PROXY_TELNET) ;\n\t\t\telse if (i == 5) conf_set_int(conf, CONF_proxy_type, PROXY_CMD) ;\n\t\t\telse conf_set_int(conf, CONF_proxy_type, PROXY_NONE) ; \n\t\t}\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyHost\", lpData ) ) { conf_set_str( conf, CONF_proxy_host, lpData ) ; }\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyPort\", lpData ) ) { conf_set_int( conf, CONF_proxy_port, atoi(lpData) ) ; }\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyUsername\", lpData ) ) { conf_set_str( conf, CONF_proxy_username, lpData ) ; }\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyPassword\", lpData ) ) { conf_set_str( conf, CONF_proxy_password, lpData ) ; }\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyTelnetCommand\", lpData ) ) { conf_set_str( conf, CONF_proxy_telnet_command, lpData ) ; }\n\t\tif( GetValueData(HKEY_CURRENT_USER, buffer, \"ProxyLogToTerm\", lpData ) ) { conf_set_int( conf, CONF_proxy_log_to_term, atoi(lpData) ) ; }\n\t\tRegCloseKey( hKey ) ;\n\t} else if( IniFileFlag == SAVEMODE_DIR ) {\n\t\tchar fullpath[MAX_VALUE_NAME] ;\n\t\tchar *filename = (char*) malloc( 4*strlen(name)+1 ) ;\n\t\tmungestr( name, filename ) ;\n\t\tsprintf( fullpath, \"%s\\\\Proxies\\\\%s\", ConfigDirectory, filename ) ;\n\t\tif( existfile(fullpath) ) {\n\t\t\tFILE *fp;\n\t\t\tif( (fp=fopen(fullpath,\"r\")) != NULL ) {\n\t\t\t\tchar buf2[MAX_VALUE_NAME]=\"\";\n\t\t\t\twhile( fgets(buffer,MAX_VALUE_NAME,fp)!=NULL ) {\n\t\t\t\t\tif( ReadPortableValue(buffer, \"ProxyExcludeList\", buf2, MAX_VALUE_NAME) ) {\n\t\t\t\t\t\tconf_set_str( conf, CONF_proxy_exclude_list, buf2 ) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyDNS\", buf2, MAX_VALUE_NAME) ) {\n\t\t\t\t\t\tint i=atoi(buf2);\n\t\t\t\t\t\tconf_set_int(conf, CONF_proxy_dns, (i+1)%3);\n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyLocalhost\", buf2, MAX_VALUE_NAME) ) {\n\t\t\t\t\t\tif( atoi(buf2) == 0 ) { conf_set_bool( conf, CONF_even_proxy_localhost, false ) ; \n\t\t\t\t\t\t} else { conf_set_bool( conf, CONF_even_proxy_localhost, true ) ;\n\t\t\t\t\t\t}\t\n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyMethod\", buf2, MAX_VALUE_NAME) ) {\n\t\t\t\t\t\tint i = atoi(buf2) ;\n\t\t\t\t\t\tif (i == 0) conf_set_int(conf, CONF_proxy_type, PROXY_NONE);\n\t\t\t\t\t\telse if (i == 1) conf_set_int(conf, CONF_proxy_type, PROXY_SOCKS4) ;\n\t\t\t\t\t\telse if (i == 2) conf_set_int(conf, CONF_proxy_type, PROXY_SOCKS5) ;\n\t\t\t\t\t\telse if (i == 3) conf_set_int(conf, CONF_proxy_type, PROXY_HTTP) ;\n\t\t\t\t\t\telse if (i == 4) conf_set_int(conf, CONF_proxy_type, PROXY_TELNET) ;\n\t\t\t\t\t\telse if (i == 5) conf_set_int(conf, CONF_proxy_type, PROXY_CMD) ;\n\t\t\t\t\t\telse conf_set_int(conf, CONF_proxy_type, PROXY_NONE) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyHost\", buf2, MAX_VALUE_NAME) ) { \n\t\t\t\t\t\tconf_set_str( conf, CONF_proxy_host, buf2 ) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyPort\", buf2, MAX_VALUE_NAME) ) { \n\t\t\t\t\t\tconf_set_int( conf, CONF_proxy_port, atoi(buf2) ) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyUsername\", buf2, MAX_VALUE_NAME) ) { \n\t\t\t\t\t\tconf_set_str( conf, CONF_proxy_username, buf2 ) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyPassword\", buf2, MAX_VALUE_NAME) ) { \n\t\t\t\t\t\tconf_set_str( conf, CONF_proxy_password, buf2 ) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyTelnetCommand\", buf2, MAX_VALUE_NAME) ) {\n\t\t\t\t\t\tconf_set_str( conf, CONF_proxy_telnet_command, buf2 ) ; \n\t\t\t\t\t} else if( ReadPortableValue(buffer, \"ProxyLogToTerm\", buf2, MAX_VALUE_NAME) ) { \n\t\t\t\t\t\tconf_set_int( conf, CONF_proxy_log_to_term, atoi(buf2) ) ; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfclose(fp);\n\t\t\t}\n\t\t}\n\t\tfree( filename ) ;\n\t}\n\treturn 1;\n}\n"
        },
        {
          "name": "kitty_proxy.h",
          "type": "blob",
          "size": 0.3642578125,
          "content": "#ifndef KITTY_PROXY\n#define KITTY_PROXY\n\n#define MAX_PROXY 100\nstruct Proxies {\n\tchar *name;\n\tint val;\n};\nextern struct Proxies proxies[MAX_PROXY] ;\n    \nint GetProxySelectionFlag() ;\nvoid SetProxySelectionFlag( const int flag ) ;\nint LoadProxyInfo( Conf * conf, const char * name ) ;\nvoid InitProxyList(void) ;\nint LoadProxyInfo( Conf * conf, const char * name ) ;\n#endif\n"
        },
        {
          "name": "kitty_puttytray.c",
          "type": "blob",
          "size": 52.634765625,
          "content": "// Saved sessions enumeration.\nstruct enumsettings {\n    HKEY key;\n    int i;\n\tint fromFile;\n\tHANDLE hFile;\n};\n\n// Random seed functions enumeration\nenum { DEL, OPEN_R, OPEN_W };\n\n// PUTTY Tray / PuTTY File - global storage type\nstatic int storagetype = 0;\t// 0 = registry, 1 = file\n\n// PUTTY Tray / PuTTY File - extra variables / structs for file\nstatic char seedpath[2 * MAX_PATH + 10] = \"\\0\";\nstatic char sesspath[2 * MAX_PATH] = \"\\0\";\nstatic char sshkpath[2 * MAX_PATH] = \"\\0\";\nstatic char oldpath[2 * MAX_PATH] = \"\\0\";\nstatic char sessionsuffix[16] = \"\\0\";\nstatic char keysuffix[16] = \"\\0\";\n\n/* JK: structures for handling settings in memory as linked list */\nstruct setItem {\n\tchar* key;\n\tchar* value;\n\tstruct setItem* next;\n};\nstruct setPack {\n\tunsigned int fromFile;\n\tvoid* handle;\n\tchar* fileBuf;\n};\n\n// Forward declarations for helper functions\nvoid mungestr(const char *in, char *out);\nvoid unmungestr(const char *in, char *out, int outlen);\nstatic void registry_recursive_remove(HKEY key);\n\n// Forward declarations for file functions\nvoid *file_open_settings_w(const char *sessionname, char **errmsg);\nvoid file_write_setting_s(void *handle, const char *key, const char *value);\nvoid file_write_setting_i(void *handle, const char *key, int value);\nvoid file_write_setting_filename(void *handle, const char *key, Filename value);\nvoid file_write_setting_fontspec(void *handle, const char *key, FontSpec font);\nvoid file_close_settings_w(void *handle);\nvoid *file_open_settings_r(const char *sessionname);\nchar *file_read_setting_s(void *handle, const char *key, char *buffer, int buflen);\nint file_read_setting_i(void *handle, const char *key, int defvalue);\nint file_read_setting_filename(void *handle, const char *key, Filename *value);\nint file_read_setting_fontspec(void *handle, const char *key, FontSpec *font);\nvoid file_close_settings_r(void *handle);\nvoid file_del_settings(const char *sessionname);\nvoid *file_enum_settings_start();\nchar *file_enum_settings_next(void *handle, char *buffer, int buflen);\nvoid file_enum_settings_finish(void *handle);\nint file_verify_host_key(const char *hostname, int port, const char *keytype, const char *key);\nvoid file_store_host_key(const char *hostname, int port, const char *keytype, const char *key);\n\n// Forward declarations for registry functions\nvoid *reg_open_settings_w(const char *sessionname, char **errmsg);\nvoid reg_write_setting_s(void *handle, const char *key, const char *value);\nvoid reg_write_setting_i(void *handle, const char *key, int value);\nvoid reg_write_setting_filename(void *handle, const char *key, Filename value);\nvoid reg_write_setting_fontspec(void *handle, const char *key, FontSpec font);\nvoid reg_close_settings_w(void *handle);\nvoid *reg_open_settings_r(const char *sessionname);\nchar *reg_read_setting_s(void *handle, const char *key, char *buffer, int buflen);\nint reg_read_setting_i(void *handle, const char *key, int defvalue);\nint reg_read_setting_filename(void *handle, const char *key, Filename *value);\nint reg_read_setting_fontspec(void *handle, const char *key, FontSpec *font);\nvoid reg_close_settings_r(void *handle);\nvoid reg_del_settings(const char *sessionname);\nvoid *reg_enum_settings_start();\nchar *reg_enum_settings_next(void *handle, char *buffer, int buflen);\nvoid reg_enum_settings_finish(void *handle);\nint reg_verify_host_key(const char *hostname, int port, const char *keytype, const char *key);\nvoid reg_store_host_key(const char *hostname, int port, const char *keytype, const char *key);\n\n\n/*\n * Sets storage type\n */\nvoid set_storagetype(int new_storagetype)\n{\n\tstoragetype = new_storagetype;\n}\n\n\n/*\n * Write a saved session. The caller is expected to call\n * open_setting_w() to get a `void *' handle, then pass that to a\n * number of calls to write_setting_s() and write_setting_i(), and\n * then close it using close_settings_w(). At the end of this call\n * sequence the settings should have been written to the PuTTY\n * persistent storage area.\n *\n * A given key will be written at most once while saving a session.\n * Keys may be up to 255 characters long.  String values have no length\n * limit.\n * \n * Any returned error message must be freed after use.\n *\n * STORAGETYPE SWITCHER\n */\nvoid *open_settings_w(const char *sessionname, char **errmsg)\n{\n\tif (storagetype == 1) {\n\t\treturn file_open_settings_w(sessionname, errmsg);\n\t} else {\n\t\treturn reg_open_settings_w(sessionname, errmsg);\n\t}\n}\n\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid write_setting_s(void *handle, const char *key, const char *value)\n{\n\tif (storagetype == 1) {\n\t\tfile_write_setting_s(handle, key, value);\n\t} else {\n\t\treg_write_setting_s(handle, key, value);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid write_setting_i(void *handle, const char *key, int value)\n{\n\tif (storagetype == 1) {\n\t\tfile_write_setting_i(handle, key, value);\n\t} else {\n\t\treg_write_setting_i(handle, key, value);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid write_setting_filename(void *handle, const char *name, Filename result)\n{\n\tif (storagetype == 1) {\n\t\tfile_write_setting_filename(handle, name, result);\n\t} else {\n\t\treg_write_setting_filename(handle, name, result);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid write_setting_fontspec(void *handle, const char *name, FontSpec font)\n{\n\tif (storagetype == 1) {\n\t\tfile_write_setting_fontspec(handle, name, font);\n\t} else {\n\t\treg_write_setting_fontspec(handle, name, font);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid close_settings_w(void *handle)\n{\n\tif (storagetype == 1) {\n\t\tfile_close_settings_w(handle);\n\t} else {\n\t\treg_close_settings_w(handle);\n\t}\n}\n\n/*\n * Read a saved session. The caller is expected to call\n * open_setting_r() to get a `void *' handle, then pass that to a\n * number of calls to read_setting_s() and read_setting_i(), and\n * then close it using close_settings_r().\n * \n * read_setting_s() writes into the provided buffer and returns a\n * pointer to the same buffer.\n * \n * If a particular string setting is not present in the session,\n * read_setting_s() can return NULL, in which case the caller\n * should invent a sensible default. If an integer setting is not\n * present, read_setting_i() returns its provided default.\n * \n * read_setting_filename() and read_setting_fontspec() each read into\n * the provided buffer, and return zero if they failed to.\n *\n * STORAGETYPE SWITCHER\n */\nvoid *open_settings_r(const char *sessionname)\n{\n\tif (storagetype == 1) {\n\t\treturn file_open_settings_r(sessionname);\n\t} else {\n\t\treturn reg_open_settings_r(sessionname);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nchar *read_setting_s(void *handle, const char *key, char *buffer, int buflen)\n{\n\tif (storagetype == 1) {\n\t\treturn file_read_setting_s(handle, key, buffer, buflen);\n\t} else {\n\t\treturn reg_read_setting_s(handle, key, buffer, buflen);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nint read_setting_i(void *handle, const char *key, int defvalue)\n{\n\tif (storagetype == 1) {\n\t\treturn file_read_setting_i(handle, key, defvalue);\n\t} else {\n\t\treturn reg_read_setting_i(handle, key, defvalue);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nint read_setting_fontspec(void *handle, const char *name, FontSpec *result)\n{\n\tif (storagetype == 1) {\n\t\treturn file_read_setting_fontspec(handle, name, result);\n\t} else {\n\t\treturn reg_read_setting_fontspec(handle, name, result);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nint read_setting_filename(void *handle, const char *name, Filename *result)\n{\n\tif (storagetype == 1) {\n\t\treturn file_read_setting_filename(handle, name, result);\n\t} else {\n\t\treturn reg_read_setting_filename(handle, name, result);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid close_settings_r(void *handle)\n{\n\tif (storagetype == 1) {\n\t\treturn file_close_settings_r(handle);\n\t} else {\n\t\treturn reg_close_settings_r(handle);\n\t}\n}\n\n/*\n * Delete a whole saved session.\n *\n * STORAGETYPE SWITCHER\n */\nvoid del_settings(const char *sessionname)\n{\n\tif (storagetype == 1) {\n\t\tfile_del_settings(sessionname);\n\t} else {\n\t\treg_del_settings(sessionname);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid *enum_settings_start(int new_storagetype)\n{\n\tstoragetype = new_storagetype;\n\n\tif (storagetype == 1) {\n\t\treturn file_enum_settings_start();\n\t} else {\n\t\treturn reg_enum_settings_start();\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nchar *enum_settings_next(void *handle, char *buffer, int buflen)\n{\n\tif (storagetype == 1) {\n\t\treturn file_enum_settings_next(handle, buffer, buflen);\n\t} else {\n\t\treturn reg_enum_settings_next(handle, buffer, buflen);\n\t}\n}\n\n/*\n * STORAGETYPE SWITCHER\n */\nvoid enum_settings_finish(void *handle)\n{\n\tif (storagetype == 1) {\n\t\tfile_enum_settings_finish(handle);\n\t} else {\n\t\treg_enum_settings_finish(handle);\n\t}\n}\n\n\n/* ----------------------------------------------------------------------\n * Functions to access PuTTY's host key database.\n */\n\n/*\n * Helper for hostkey functions (not part of storage.h)\n * NO HACK: PuttyTray / PuTTY File - This is an original function (not patched)\n */\nstatic void hostkey_regname(char *buffer, const char *hostname, int port, const char *keytype)\n{\n    int len;\n    strcpy(buffer, keytype);\n    strcat(buffer, \"@\");\n    len = strlen(buffer);\n    len += sprintf(buffer + len, \"%d:\", port);\n    mungestr(hostname, buffer + strlen(buffer));\n}\n\n/*\n * See if a host key matches the database entry. Return values can\n * be 0 (entry matches database), 1 (entry is absent in database),\n * or 2 (entry exists in database and is different).\n *\n * STORAGETYPE SWITCHER\n */\nint verify_host_key(const char *hostname, int port, const char *keytype, const char *key)\n{\n\tif (storagetype == 1) {\n\t\treturn file_verify_host_key(hostname, port, keytype, key);\n\t} else {\n\t\treturn reg_verify_host_key(hostname, port, keytype, key);\n\t}\n}\n\n/*\n * Write a host key into the database, overwriting any previous\n * entry that might have been there.\n *\n * STORAGETYPE SWITCHER\n */\n/*void store_host_key(const char *hostname, int port, const char *keytype, const char *key)\n{\n\tif (storagetype == 1) {\n\t\tfile_store_host_key(hostname, port, keytype, key);\n\t} else {\n\t\treg_store_host_key(hostname, port, keytype, key);\n\t}\n}\n*/\n\n/* ----------------------------------------------------------------------\n * Functions to access PuTTY's random number seed file.\n */\n/*\n * HELPER FOR RANDOM SEED FUNCTIONS (not part of storage.h)\n * Open (or delete) the random seed file.\n *\n * NO HACK: PuttyTray / PuTTY File - This is an original function (not patched)\n */\nstatic int try_random_seed(char const *path, int action, HANDLE *ret)\n{\n    if (action == DEL) {\n\tremove(path);\n\t*ret = INVALID_HANDLE_VALUE;\n\treturn FALSE;\t\t       /* so we'll do the next ones too */\n    }\n\n    *ret = CreateFile(path,\n\t\t      action == OPEN_W ? GENERIC_WRITE : GENERIC_READ,\n\t\t      action == OPEN_W ? 0 : (FILE_SHARE_READ |\n\t\t\t\t\t      FILE_SHARE_WRITE),\n\t\t      NULL,\n\t\t      action == OPEN_W ? CREATE_ALWAYS : OPEN_EXISTING,\n\t\t      action == OPEN_W ? FILE_ATTRIBUTE_NORMAL : 0,\n\t\t      NULL);\n\n    return (*ret != INVALID_HANDLE_VALUE);\n}\n\n /*\n  * HELPER FOR RANDOM SEED FUNCTIONS (not part of storage.h)\n  * \n  * PARTLY HACKED: PuttyTray / PuTTY File - This is an original function (only first lines patched)\n  */\nstatic HANDLE access_random_seed(int action)\n{\n    HKEY rkey;\n    DWORD type, size;\n    HANDLE rethandle;\n    char seedpath[2 * MAX_PATH + 10] = \"\\0\";\n\n\t/* PuttyTray / PuTTY File - HACK STARTS HERE */\n\tif (seedpath != '\\0') {\n\t\t/* JK: In PuTTY 0.58 this won't ever happen - this function was called only if (!seedpath[0])\n\t\t * This changed in PuTTY 0.59 - read the long comment below\n\t\t */\n\t\treturn;\n\t}\n\t/* PuttyTray / PuTTY File - HACK ENDS HERE */\n\n    /*\n     * Iterate over a selection of possible random seed paths until\n     * we find one that works.\n     * \n     * We do this iteration separately for reading and writing,\n     * meaning that we will automatically migrate random seed files\n     * if a better location becomes available (by reading from the\n     * best location in which we actually find one, and then\n     * writing to the best location in which we can _create_ one).\n     */\n\n    /*\n     * First, try the location specified by the user in the\n     * Registry, if any.\n     */\n    size = sizeof(seedpath);\n    if (RegOpenKey(HKEY_CURRENT_USER, PUTTY_REG_POS, &rkey) ==\n\tERROR_SUCCESS) {\n\tint ret = RegQueryValueEx(rkey, \"RandSeedFile\",\n\t\t\t\t  0, &type, seedpath, &size);\n\tif (ret != ERROR_SUCCESS || type != REG_SZ)\n\t    seedpath[0] = '\\0';\n\tRegCloseKey(rkey);\n\n\tif (*seedpath && try_random_seed(seedpath, action, &rethandle))\n\t    return rethandle;\n    }\n\n    /*\n     * Next, try the user's local Application Data directory,\n     * followed by their non-local one. This is found using the\n     * SHGetFolderPath function, which won't be present on all\n     * versions of Windows.\n     */\n    if (!tried_shgetfolderpath) {\n\t/* This is likely only to bear fruit on systems with IE5+\n\t * installed, or WinMe/2K+. There is some faffing with\n\t * SHFOLDER.DLL we could do to try to find an equivalent\n\t * on older versions of Windows if we cared enough.\n\t * However, the invocation below requires IE5+ anyway,\n\t * so stuff that. */\n\tshell32_module = LoadLibrary(\"SHELL32.DLL\");\n\tif (shell32_module) {\n\t    p_SHGetFolderPath = (p_SHGetFolderPath_t)\n\t\tGetProcAddress(shell32_module, \"SHGetFolderPathA\");\n\t}\n    }\n    if (p_SHGetFolderPath) {\n\tif (SUCCEEDED(p_SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA,\n\t\t\t\t\tNULL, SHGFP_TYPE_CURRENT, seedpath))) {\n\t    strcat(seedpath, \"\\\\PUTTY.RND\");\n\t    if (try_random_seed(seedpath, action, &rethandle))\n\t\treturn rethandle;\n\t}\n\n\tif (SUCCEEDED(p_SHGetFolderPath(NULL, CSIDL_APPDATA,\n\t\t\t\t\tNULL, SHGFP_TYPE_CURRENT, seedpath))) {\n\t    strcat(seedpath, \"\\\\PUTTY.RND\");\n\t    if (try_random_seed(seedpath, action, &rethandle))\n\t\treturn rethandle;\n\t}\n    }\n\n    /*\n     * Failing that, try %HOMEDRIVE%%HOMEPATH% as a guess at the\n     * user's home directory.\n     */\n    {\n\tint len, ret;\n\n\tlen =\n\t    GetEnvironmentVariable(\"HOMEDRIVE\", seedpath,\n\t\t\t\t   sizeof(seedpath));\n\tret =\n\t    GetEnvironmentVariable(\"HOMEPATH\", seedpath + len,\n\t\t\t\t   sizeof(seedpath) - len);\n\tif (ret != 0) {\n\t    strcat(seedpath, \"\\\\PUTTY.RND\");\n\t    if (try_random_seed(seedpath, action, &rethandle))\n\t\treturn rethandle;\n\t}\n    }\n\n    /*\n     * And finally, fall back to C:\\WINDOWS.\n     */\n    GetWindowsDirectory(seedpath, sizeof(seedpath));\n    strcat(seedpath, \"\\\\PUTTY.RND\");\n    if (try_random_seed(seedpath, action, &rethandle))\n\treturn rethandle;\n\n    /*\n     * If even that failed, give up.\n     */\n    return INVALID_HANDLE_VALUE;\n}\n\n\n/*\n * Read PuTTY's random seed file and pass its contents to a noise\n * consumer function.\n *\n * NO HACK: PuttyTray / PuTTY File - This is an original function (not patched)\n */\nvoid read_random_seed(noise_consumer_t consumer)\n{\n    HANDLE seedf = access_random_seed(OPEN_R);\n\n    if (seedf != INVALID_HANDLE_VALUE) {\n\twhile (1) {\n\t    char buf[1024];\n\t    DWORD len;\n\n\t    if (ReadFile(seedf, buf, sizeof(buf), &len, NULL) && len)\n\t\tconsumer(buf, len);\n\t    else\n\t\tbreak;\n\t}\n\tCloseHandle(seedf);\n    }\n}\n\n/*\n * Write PuTTY's random seed file from a given chunk of noise.\n *\n * NO HACK: PuttyTray / PuTTY File - This is an original function (not patched)\n */\nvoid write_random_seed(void *data, int len)\n{\n    HANDLE seedf = access_random_seed(OPEN_W);\n\n    if (seedf != INVALID_HANDLE_VALUE) {\n\tDWORD lenwritten;\n\n\tWriteFile(seedf, data, len, &lenwritten, NULL);\n\tCloseHandle(seedf);\n    }\n}\n\n\n/* ----------------------------------------------------------------------\n * Cleanup function: remove all of PuTTY's persistent state.\n *\n * NO HACK: PuttyTray / PuTTY File - This is an original function (not patched)\n */\nvoid cleanup_all(void)\n{\n    HKEY key;\n    int ret;\n    char name[MAX_PATH + 1];\n\n    /* ------------------------------------------------------------\n     * Wipe out the random seed file, in all of its possible\n     * locations.\n     */\n    access_random_seed(DEL);\n\n    /* ------------------------------------------------------------\n     * Destroy all registry information associated with PuTTY.\n     */\n\n    /*\n     * Open the main PuTTY registry key and remove everything in it.\n     */\n    if (RegOpenKey(HKEY_CURRENT_USER, PUTTY_REG_POS, &key) ==\n\tERROR_SUCCESS) {\n\tregistry_recursive_remove(key);\n\tRegCloseKey(key);\n    }\n    /*\n     * Now open the parent key and remove the PuTTY main key. Once\n     * we've done that, see if the parent key has any other\n     * children.\n     */\n    if (RegOpenKey(HKEY_CURRENT_USER, PUTTY_REG_PARENT,\n\t\t   &key) == ERROR_SUCCESS) {\n\tRegDeleteKey(key, PUTTY_REG_PARENT_CHILD);\n\tret = RegEnumKey(key, 0, name, sizeof(name));\n\tRegCloseKey(key);\n\t/*\n\t * If the parent key had no other children, we must delete\n\t * it in its turn. That means opening the _grandparent_\n\t * key.\n\t */\n\tif (ret != ERROR_SUCCESS) {\n\t    if (RegOpenKey(HKEY_CURRENT_USER, PUTTY_REG_GPARENT,\n\t\t\t   &key) == ERROR_SUCCESS) {\n\t\tRegDeleteKey(key, PUTTY_REG_GPARENT_CHILD);\n\t\tRegCloseKey(key);\n\t    }\n\t}\n    }\n    /*\n     * Now we're done.\n     */\n}\n\n\n/* ----------------------------------------------------------------------\n * PUTTY FILE HELPERS (not part of storage.h)\n */\n/* JK: my generic function for simplyfing error reporting */\nDWORD errorShow(const char* pcErrText, const char* pcErrParam) {\n\n\tHWND hwRodic;\n\tDWORD erChyba;\n\tchar pcBuf[16];\n\tchar* pcHlaska = snewn(strlen(pcErrParam) + strlen(pcErrText) + 31, char);\n\t\n\terChyba = GetLastError();\t\t\n\tltoa(erChyba, pcBuf, 10);\n\n\tstrcpy(pcHlaska, \"Error: \");\n\tstrcat(pcHlaska, pcErrText);\n\tstrcat(pcHlaska, \"\\n\");\t\n\n\tif (pcErrParam) {\n\t\tstrcat(pcHlaska, pcErrParam);\n\t\tstrcat(pcHlaska, \"\\n\");\n\t}\n    strcat(pcHlaska, \"Error code: \");\n\tstrcat(pcHlaska, pcBuf);\n\n    /* JK: get parent-window and show */\n    hwRodic = GetActiveWindow();\n    if (hwRodic != NULL) { hwRodic = GetLastActivePopup(hwRodic);}\n  \n\tif (MessageBox(hwRodic, pcHlaska, \"Error\", MB_OK|MB_APPLMODAL|MB_ICONEXCLAMATION) == 0) {\n        /* JK: this is really bad -> just ignore */\n        return 0;\n    }\n\n\tsfree(pcHlaska);\n\treturn erChyba;\n};\n\n/* JK: pack string for use as filename - pack < > : \" / \\ | */\nstatic void packstr(const char *in, char *out) {\n    while (*in) {\n\t\tif (*in == '<' || *in == '>' || *in == ':' || *in == '\"' ||\n\t    *in == '/' || *in == '|') {\n\t    *out++ = '%';\n\t    *out++ = hex[((unsigned char) *in) >> 4];\n\t    *out++ = hex[((unsigned char) *in) & 15];\n\t} else\n\t    *out++ = *in;\n\tin++;\n    }\n    *out = '\\0';\n    return;\n}\n\n/*\n * JK: create directory if specified as dir1\\dir2\\dir3 and dir1|2 doesn't exists\n * handle if part of path already exists\n*/\nint createPath(char* dir) {\n    char *p;\n\n\tp = strrchr(dir, '\\\\');\n\n\tif (p == NULL) {\n\t\t/* what if it already exists */\n\t\tif (!SetCurrentDirectory(dir)) {\n\t\t\tCreateDirectory(dir, NULL);\n\t\t\treturn SetCurrentDirectory(dir);\n\t\t}\n\t\treturn 1;\n\t}\n\t\n\t*p = '\\0';\n\tcreatePath(dir);\n\t*p = '\\\\';\n\t++p;\n\n\t/* what if it already exists */\n\tif (!SetCurrentDirectory(dir)) {\n\t\tCreateDirectory(p, NULL);\n\t\treturn SetCurrentDirectory(p);\n\t}\n\treturn 1;\n}\n\n/*\n * JK: join path pcMain.pcSuf solving extra cases to pcDest\n * expecting - pcMain as path from WinAPI ::GetCurrentDirectory()/GetModuleFileName()\n *           - pcSuf as user input path from config (at least MAX_PATH long)\n*/\nchar* joinPath(char* pcDest, char* pcMain, char* pcSuf) {\n\n\tchar* pcBuf = snewn(MAX_PATH+1, char);\n\n\t/* at first ExpandEnvironmentStrings */\n\tif (0 == ExpandEnvironmentStrings(pcSuf, pcBuf, MAX_PATH)) {\n\t\t/* JK: failure -> revert back - but it ussualy won't work, so report error to user! */\n\t\terrorShow(\"Unable to ExpandEnvironmentStrings for session path\", pcSuf);\n\t\tstrncpy(pcBuf, pcSuf, strlen(pcSuf));\n\t}\n\t/* now ExpandEnvironmentStringsForUser - only on win2000Pro and above */\n\t/* It's much more tricky than I've expected, so it's ToDo */\n\t/*\n\tstatic HMODULE userenv_module = NULL;\n\ttypedef BOOL (WINAPI *p_ExpandESforUser_t) (HANDLE, LPCTSTR, LPTSTR, DWORD);\n\tstatic p_ExpandESforUser_t p_ExpandESforUser = NULL;\n\t\n\tHMODULE userenv_module = LoadLibrary(\"USERENV.DLL\");\n\n\tif (userenv_module) {\n\t    p_ExpandESforUser = (p_ExpandESforUser_t) GetProcAddress(shell32_module, \"ExpandEnvironmentStringsForUserA\");\n\t\t\n\t\tif (p_ExpandESforUser) {\n\n\t\t\tTOKEN_IMPERSONATE\n\n\t\t\tif (0 == (p_ExpandESforUser(NULL, pcSuf, pcBuf,\tMAX_PATH))) {\n\t    \t\t/* JK: failure -> revert back - but it ussualy won't work, so report error to user! *//*\n\t\t\t\terrorShow(\"Unable to ExpandEnvironmentStringsForUser for session path\", pcBuf);\n\t\t\t\tstrncpy(pcSuf, pcBuf, strlen(pcSuf));\n\t\t\t}\n\t\t}\n\t}*/\n\n\t/* expand done, resutl in pcBuf */\n\n\tif ((*pcBuf == '/') || (*pcBuf == '\\\\')) {\n\t\t/* everything ok */\n\t\tstrcpy(pcDest, pcMain);\n\t\tstrcat(pcDest, pcBuf);\n\t}\n\telse {\n\t\tif (*(pcBuf+1) == ':') {\n\t\t\t/* absolute path */\n\t\t\tstrcpy(pcDest, pcBuf);\n\t\t}\n\t\telse {\n\t\t\t/* some weird relative path - add '\\' */\n\t\t\tstrcpy(pcDest, pcMain);\n\t\t\tstrcat(pcDest, \"\\\\\");\n\t\t\tstrcat(pcDest, pcBuf);\n\t\t}\n\t}\n\tsfree(pcBuf);\n\treturn pcDest;\n}\n\n/*\n * JK: init path variables from config or otherwise\n * as of 1.5 GetModuleFileName solves our currentDirectory problem\n*/\nint loadPath() {\n\n\tchar *fileCont = NULL;\n\tDWORD fileSize;\n\tDWORD bytesRead;\n\tchar *p = NULL;\n\tchar *p2 = NULL;\n\tHANDLE hFile;\n\n\tchar* puttypath = snewn( (MAX_PATH*2), char);\n\n\t/* JK:  save path/curdir */\n\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\n\t/* JK: get where putty.exe is */\n\tif (GetModuleFileName(NULL, puttypath, (MAX_PATH*2)) != 0)\n\t{\n\t\tp = strrchr(puttypath, '\\\\');\n\t\tif (p)\n\t\t{\n\t\t\t*p = '\\0';\n\t\t}\n\t\tSetCurrentDirectory(puttypath);\n\t}\n\telse GetCurrentDirectory( (MAX_PATH*2), puttypath);\n\n\t/* JK: set default values - if there is a config file, it will be overwitten */\n\tstrcpy(sesspath, puttypath);\n\tstrcat(sesspath, \"\\\\sessions\");\n\tstrcpy(sshkpath, puttypath);\n\tstrcat(sshkpath, \"\\\\sshhostkeys\");\n\tstrcpy(seedpath, puttypath);\n\tstrcat(seedpath, \"\\\\putty.rnd\");\n\n\thFile = CreateFile(\"putty.conf\",GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n\n\t/* JK: now we can pre-clean-up */\n\tSetCurrentDirectory(oldpath);\n\n\tif (hFile != INVALID_HANDLE_VALUE) {\n\t\tfileSize = GetFileSize(hFile, NULL);\n\t\tfileCont = snewn(fileSize+16, char);\n\n\t\tif (!ReadFile(hFile, fileCont, fileSize, &bytesRead, NULL)) {\n\t\t\terrorShow(\"Unable to read configuration file, falling back to defaults\", NULL);\n\t\t\n\t\t\t/* JK: default values are already there and clean-up at end */\n\t\t}\n\t\telse {\n\t\t\t/* JK: parse conf file to path variables */\n\t\t\t*(fileCont+fileSize) = '\\0';\n\t\t\tp = fileCont;\n\t\t\twhile (p) {\n\t\t\t\tif (*p == ';') {\t/* JK: comment -> skip line */\n\t\t\t\t\tp = strchr(p, '\\n');\n\t\t\t\t\t++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp2 = strchr(p, '=');\n\t\t\t\tif (!p2) break;\n\t\t\t\t*p2 = '\\0';\n\t\t\t\t++p2;\n\n\t\t\t\tif (!strcmp(p, \"sessions\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(sesspath, puttypath, p2);\n\t\t\t\t\tp2 = sesspath+strlen(sesspath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"sshhostkeys\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(sshkpath, puttypath, p2);\n\t\t\t\t\tp2 = sshkpath+strlen(sshkpath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"seedfile\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(seedpath, puttypath, p2);\t\t\t\n\t\t\t\t\tp2 = seedpath+strlen(seedpath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"sessionsuffix\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstrcpy(sessionsuffix, p2);\n\t\t\t\t\tp2 = sessionsuffix+strlen(sessionsuffix)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"keysuffix\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstrcpy(keysuffix, p2);\n\t\t\t\t\tp2 = keysuffix+strlen(keysuffix)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t}\n\t\t}\n\t\tCloseHandle(hFile);\n\t\tsfree(fileCont);\n\t}\n\t/* else - INVALID_HANDLE {\n\t\t * JK: unable to read conf file - probably doesn't exists\n\t\t * we won't create one, user wants putty light, just fall back to defaults\n\t\t * and defaults are already there\n\t}*/\n\n\tsfree(puttypath);\n\treturn 1;\n}\n\n\n/* ----------------------------------------------------------------------\n * OTHER HELPERS (not part of storage.h)\n *\n * NO HACK: PuttyTray / PuTTY File - these are original functions (not patched)\n */\n\nvoid mungestr(const char *in, char *out)\n{\n    int candot = 0;\n\n    while (*in) {\n\tif (*in == ' ' || *in == '\\\\' || *in == '*' || *in == '?' ||\n\t    *in == '%' || *in < ' ' || *in > '~' || (*in == '.'\n\t\t\t\t\t\t     && !candot)) {\n\t    *out++ = '%';\n\t    *out++ = hex[((unsigned char) *in) >> 4];\n\t    *out++ = hex[((unsigned char) *in) & 15];\n\t} else\n\t    *out++ = *in;\n\tin++;\n\tcandot = 1;\n    }\n    *out = '\\0';\n    return;\n}\n\nvoid unmungestr(const char *in, char *out, int outlen)\n{\n    while (*in) {\n\tif (*in == '%' && in[1] && in[2]) {\n\t    int i, j;\n\n\t    i = in[1] - '0';\n\t    i -= (i > 9 ? 7 : 0);\n\t    j = in[2] - '0';\n\t    j -= (j > 9 ? 7 : 0);\n\n\t    *out++ = (i << 4) + j;\n\t    if (!--outlen)\n\t\treturn;\n\t    in += 3;\n\t} else {\n\t    *out++ = *in++;\n\t    if (!--outlen)\n\t\treturn;\n\t}\n    }\n    *out = '\\0';\n    return;\n}\n\n/*\n * Recursively delete a registry key and everything under it.\n */\nstatic void registry_recursive_remove(HKEY key)\n{\n    DWORD i;\n    char name[MAX_PATH + 1];\n    HKEY subkey;\n\n    i = 0;\n    while (RegEnumKey(key, i, name, sizeof(name)) == ERROR_SUCCESS) {\n\tif (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS) {\n\t    registry_recursive_remove(subkey);\n\t    RegCloseKey(subkey);\n\t}\n\tRegDeleteKey(key, name);\n    }\n}\n\n\n/* ---------------------------------------------------------------------------------------------------------\n * ---------------------------------------------------------------------------------------------------------\n * FILE FUNCTIONS\n * ---------------------------------------------------------------------------------------------------------\n * -------------------------------------------------------------------------------------------------------*/\nvoid *file_open_settings_w(const char *sessionname, char **errmsg)\n{\n    char *p;\n\tstruct setPack* sp;\n    *errmsg = NULL;\n\n\tif (!sessionname || !*sessionname) {\n\t\tsessionname = \"Default Settings\";\n\t}\n\n\t/* JK: if sessionname contains [registry] -> cut it off */\n\t/*if ( *(sessionname+strlen(sessionname)-1) == ']') {\n\t\tp = strrchr(sessionname, '[');\n\t\t*(p-1) = '\\0';\n\t}*/\n\n    p = snewn(3 * strlen(sessionname) + 1, char);\n    mungestr(sessionname, p);\n\n\tsp = snew( struct setPack );\n\tsp->fromFile = 0;\n\tsp->handle = NULL;\n\n\t/* JK: secure pack for filename */\n\tsp->fileBuf = snewn(3 * strlen(p) + 1 + 16, char);\n    packstr(p, sp->fileBuf);\n\tstrcat(sp->fileBuf, sessionsuffix);\n\tsfree(p);\n\n\treturn sp;\n}\n\nvoid file_write_setting_s(void *handle, const char *key, const char *value)\n{\n\tstruct setItem *st;\n\n\tif (handle) {\n\t\t/* JK: counting max lenght of keys/values */\n\t\t((struct setPack*) handle)->fromFile = max(((struct setPack*) handle)->fromFile, strlen(key)+1);\n\t\t((struct setPack*) handle)->fromFile = max(((struct setPack*) handle)->fromFile, strlen(value)+1);\n\n\t\tst = ((struct setPack*) handle)->handle;\n\t\twhile (st) {\n\t\t\tif ( strcmp(st->key, key) == 0) {\n\t\t\t\t/* this key already set -> reset */\n\t\t\t\tsfree(st->value);\n\t\t\t\tst->value = snewn( strlen(value)+1, char);\n\t\t\t\tstrcpy(st->value, value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst = st->next;\n\t\t}\n\t\t/* JK: key not found -> add to begin */\n\t\tst = snew( struct setItem );\n\t\tst->key = snewn( strlen(key)+1, char);\n\t\tstrcpy(st->key, key);\n\t\tst->value = snewn( strlen(value)+1, char);\n\t\tstrcpy(st->value, value);\n\t\tst->next = ((struct setPack*) handle)->handle;\n\t\t((struct setPack*) handle)->handle = st;\n\t}\n}\n\nvoid file_write_setting_i(void *handle, const char *key, int value)\n{\n\tstruct setItem *st;\n\n\tif (handle) {\n\t\t/* JK: counting max lenght of keys/values */\n\t\t((struct setPack*) handle)->fromFile = max(((struct setPack*) handle)->fromFile, strlen(key)+1);\n\n\t\tst = ((struct setPack*) handle)->handle;\n\t\twhile (st) {\n\t\t\tif ( strcmp(st->key, key) == 0) {\n\t\t\t\t/* this key already set -> reset */\n\t\t\t\tsfree(st->value);\n\t\t\t\tst->value = snewn(16, char);\n\t\t\t\titoa(value, st->value, 10);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tst = st->next;\n\t\t}\n\t\t/* JK: key not found -> add to begin */\n\t\tst = snew( struct setItem );\n\t\tst->key = snewn( strlen(key)+1, char);\n\t\tstrcpy(st->key, key);\n\t\tst->value = snewn(16, char);\n\t\titoa(value, st->value, 10);\n\t\tst->next = ((struct setPack*) handle)->handle;\n\t\t((struct setPack*) handle)->handle = st;\n\t}\n}\n\nvoid file_close_settings_w(void *handle)\n{\n\tHANDLE hFile;\n\tDWORD written;\n\tWIN32_FIND_DATA FindFile;\n\tchar *p;\n\tstruct setItem *st1,*st2;\n\tint writeok;\n\n\tif (!handle) return;\n\n\t/* JK: we will write to disk now - open file, filename stored in handle already packed */\n\tif ((hFile = FindFirstFile(sesspath, &FindFile)) == INVALID_HANDLE_VALUE) {\n\t\tif (!createPath(sesspath)) {\n\t\t\terrorShow(\"Unable to create directory for storing sessions\", sesspath);\n\t\t\treturn;\n\t\t}\n\t}\n\tFindClose(hFile);\n\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\tSetCurrentDirectory(sesspath);\n\n\thFile = CreateFile( ((struct setPack*) handle)->fileBuf, GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\terrorShow(\"Unable to open file for writing\", ((struct setPack*) handle)->fileBuf );\n\t\treturn;\n\t}\n\n\t/* JK: allocate enough memory for all keys/values */\n\tp = snewn( max( 3* ((struct setPack*) handle)->fromFile ,16), char);\n\n\t/* JK: process linked list */\n\tst1 = ((struct setPack*) handle)->handle;\n\twriteok = 1;\n\n\twhile (st1) {\n\t\tmungestr(st1->key, p);\n\t\twriteok = writeok && WriteFile( (HANDLE) hFile, p, strlen(p), &written, NULL);\n\t\twriteok = writeok && WriteFile( (HANDLE) hFile, \"\\\\\", 1, &written, NULL);\n\n\t\tmungestr(st1->value, p);\n\t\twriteok = writeok && WriteFile( (HANDLE) hFile, p, strlen(p), &written, NULL);\n\t\twriteok = writeok && WriteFile( (HANDLE) hFile, \"\\\\\\n\", 2, &written, NULL);\n\n\t\tif (!writeok) {\n\t\t\terrorShow(\"Unable to save settings\", st1->key);\n\t\t\treturn;\n\t\t\t/* JK: memory should be freed here - fixme */\n\t\t}\n\n\t\tst2 = st1->next;\n\t\tsfree(st1->key);\n\t\tsfree(st1->value);\n\t\tsfree(st1);\n\t\tst1 = st2;\n\t}\n\n\tsfree(((struct setPack*) handle)->fileBuf);\n\tCloseHandle( (HANDLE)hFile );\n\tSetCurrentDirectory(oldpath);\n}\n\nvoid *file_open_settings_r(const char *sessionname)\n{\n    HKEY subkey1, sesskey;\n    char *p;\n\tchar *ses;\n\tchar *fileCont;\n\tDWORD fileSize;\n\tDWORD bytesRead;\n\tHANDLE hFile;\n\tstruct setPack* sp;\n\tstruct setItem *st1, *st2;\n\n\tsp = snew( struct setPack );\n\n\tif (!sessionname || !*sessionname) {\n\t\tsessionname = \"Default Settings\";\n\t}\n\n\t/* JK: in the first call of this function we initialize path variables */\n\tif (*sesspath == '\\0') {\n\t\tloadPath();\n\t}\n\n\t/* JK: if sessionname contains [registry] -> cut it off in another buffer */\n\t/*if ( *(sessionname+strlen(sessionname)-1) == ']') {\n\t\tses = snewn(strlen(sessionname)+1, char);\n\t\tstrcpy(ses, sessionname);\n\n\t\tp = strrchr(ses, '[');\n\t\t*(p-1) = '\\0';\n\n\t\tp = snewn(3 * strlen(ses) + 1, char);\n\t\tmungestr(ses, p);\n\t\tsfree(ses);\n\n\t\tsp->fromFile = 0;\n\t}\n\telse {*/\n\t\tp = snewn(3 * strlen(sessionname) + 1 + 16, char);\n\t\tmungestr(sessionname, p);\n\t\tstrcat(p, sessionsuffix);\n\n\t\tsp->fromFile = 1;\n\t//}\n\n\t/* JK: default settings must be read from registry */\n\t/* 8.1.2007 - 0.1.6 try to load them from file if exists - nasty code duplication */\n\tif (!strcmp(sessionname, \"Default Settings\")) {\n\t\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\t\tif (SetCurrentDirectory(sesspath)) {\n\t\t\thFile = CreateFile(p, GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n\t\t}\n\t\telse {\n\t\t\thFile = INVALID_HANDLE_VALUE;\n\t\t}\n\t\tSetCurrentDirectory(oldpath);\n\t\t\n\t\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\t\tsp->fromFile = 0;\n\t\t}\n\t\telse {\n\t\t\tsp->fromFile = 1;\n\t\t\tCloseHandle(hFile);\n\t\t}\n\t}\n\n\tif (sp->fromFile) {\n\t\t/* JK: session is in file -> open dir/file */\n\t\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\t\tif (SetCurrentDirectory(sesspath)) {\n\t\t\thFile = CreateFile(p, GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n\t\t}\n\t\telse {\n\t\t\thFile = INVALID_HANDLE_VALUE;\n\t\t}\n\t\tSetCurrentDirectory(oldpath);\n\t\t\n\t\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\t\t/* JK: some error occured -> just report and fail */\n\n\t\t\t/* JK: PSCP/PLINK always try to load settings for sessionname=hostname (to what PSCP/PLINK is just connecting)\n\t\t\t   These settings usually doesn't exist.\n\t\t\t   So for PSCP/PLINK, do not report error - so when compiling PSCP/PLINK, comment line below\n\t\t\t   (errorShow(\"Unable to load file for reading\", p);)\n\t\t\t*/\n//#error read comment above\n\t\t\terrorShow(\"Unable to load file for reading\", p);\n\n\t\t\tsfree(p);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t/* JK: succes -> load structure setPack from file */\n\t\tfileSize = GetFileSize(hFile, NULL);\n\t\tfileCont = snewn(fileSize+16, char);\n\n\t\tif (!ReadFile(hFile, fileCont, fileSize, &bytesRead, NULL)) {\n\t\t\terrorShow(\"Unable to read session from file\", p);\n\t\t\tsfree(p);\n\t\t\treturn NULL;\n\t\t}\n\t\tsfree(p);\n\n\t\tst1 = snew( struct setItem );\n\t\tsp->fromFile = 1;\n\t\tsp->handle = st1;\n\t\t\n\t\tp = fileCont;\n\t\tsp->fileBuf = fileCont; /* JK: remeber for memory freeing */\n\n\t\t/* pJK: arse file in format:\n\t\t * key1\\value1\\\n\t\t * ...\n\t\t*/\n\t\twhile (p < (fileCont+fileSize)) {\n\t\t\tst1->key = p;\n\t\t\tp = strchr(p, '\\\\');\n\t\t\tif (!p) break;\n\t\t\t*p = '\\0';\n\t\t\t++p;\n\t\t\tst1->value = p;\n\t\t\tp = strchr(p, '\\\\');\n\t\t\tif (!p) break;\n\t\t\t*p = '\\0';\n\t\t\t++p;\n\t\t\t++p; /* for \"\\\\\\n\" - human readable files */\n\n\t\t\tst2 = snew( struct setItem );\n\t\t\tst2->next = NULL;\n\t\t\tst2->key = NULL;\n\t\t\tst2->value = NULL;\n\n\t\t\tst1->next = st2;\n\t\t\tst1 = st2;\n\t\t}\n\t\tCloseHandle(hFile);\n\t}\n\telse {\n\t\t/* JK: session is in registry */\n\t\tif (RegOpenKey(HKEY_CURRENT_USER, puttystr, &subkey1) != ERROR_SUCCESS) {\n\t\t\tsesskey = NULL;\n\t\t}\n\t\telse {\n\t\t\tif (RegOpenKey(subkey1, p, &sesskey) != ERROR_SUCCESS) {\n\t\t\t\tsesskey = NULL;\n\t\t\t}\n\t\t\tRegCloseKey(subkey1);\n\t\t}\n\t\tsp->fromFile = 0;\n\t\tsp->handle = sesskey;\n\t\tsfree(p);\n\t}\n\n\treturn sp;\n}\n\nchar *file_read_setting_s(void *handle, const char *key, char *buffer, int buflen)\n{\n    DWORD type;\n\tstruct setItem *st;\n\tchar *p;\n\tDWORD size = buflen;\n\n\tif (!handle) return NULL;\t/* JK: new in 0.1.3 */\n\n\tif (((struct setPack*) handle)->fromFile) {\n\t\t\n\t\tp = snewn(3 * strlen(key) + 1, char);\n\t\tmungestr(key, p);\n\n\t\tst = ((struct setPack*) handle)->handle;\n\t\twhile (st->key) {\n\t\t\tif ( strcmp(st->key, p) == 0) {\n\t\t\t\tunmungestr(st->value, buffer, buflen);\n\t\t\t\treturn st->value;\t\t\t\t\n\t\t\t}\n\t\t\tst = st->next;\n\t\t}\n\t}\n\telse {\n\t\thandle = ((struct setPack*) handle)->handle;\n\n\t\tif (!handle || RegQueryValueEx((HKEY) handle, key, 0, &type, buffer, &size) != ERROR_SUCCESS ||\ttype != REG_SZ) {\n\t\t\treturn NULL;\n\t\t}\n\t\telse {\n\t\t\treturn buffer;\n\t\t}\n\t}\n\t/* JK: should not end here -> value not found in file */\n\treturn NULL;\n}\n\nint file_read_setting_i(void *handle, const char *key, int defvalue)\n{\n    DWORD type, val, size;\n\tstruct setItem *st;\n    size = sizeof(val);\n\n\tif (!handle) return 0;\t/* JK: new in 0.1.3 */\n\n\tif (((struct setPack*) handle)->fromFile) {\n\t\tst = ((struct setPack*) handle)->handle;\n\t\twhile (st->key) {\n\t\t\tif ( strcmp(st->key, key) == 0) {\n\t\t\t\treturn atoi(st->value);\t\t\t\t\n\t\t\t}\n\t\t\tst = st->next;\n\t\t}\n\t}\n\telse {\n\t\thandle = ((struct setPack*) handle)->handle;\n\n\t\tif (!handle || RegQueryValueEx((HKEY) handle, key, 0, &type, (BYTE *) &val, &size) != ERROR_SUCCESS || size != sizeof(val) || type != REG_DWORD) {\n\t\t\treturn defvalue;\n\t\t}\n\t\telse {\n\t\t\treturn val;\n\t\t}\n\t}\n\t/* JK: should not end here -> value not found in file */\n\treturn defvalue;\n}\n\nint file_read_setting_fontspec(void *handle, const char *name, FontSpec *result)\n{\n    char *settingname;\n    FontSpec ret;\n\n    if (!file_read_setting_s(handle, name, ret.name, sizeof(ret.name)))\n\treturn 0;\n    settingname = dupcat(name, \"IsBold\", NULL);\n    ret.isbold = file_read_setting_i(handle, settingname, -1);\n    sfree(settingname);\n    if (ret.isbold == -1) return 0;\n    settingname = dupcat(name, \"CharSet\", NULL);\n    ret.charset = file_read_setting_i(handle, settingname, -1);\n    sfree(settingname);\n    if (ret.charset == -1) return 0;\n    settingname = dupcat(name, \"Height\", NULL);\n    ret.height = file_read_setting_i(handle, settingname, INT_MIN);\n    sfree(settingname);\n    if (ret.height == INT_MIN) return 0;\n    *result = ret;\n    return 1;\n}\n\nvoid file_write_setting_fontspec(void *handle, const char *name, FontSpec font)\n{\n    char *settingname;\n\n    file_write_setting_s(handle, name, font.name);\n    settingname = dupcat(name, \"IsBold\", NULL);\n    file_write_setting_i(handle, settingname, font.isbold);\n    sfree(settingname);\n    settingname = dupcat(name, \"CharSet\", NULL);\n    file_write_setting_i(handle, settingname, font.charset);\n    sfree(settingname);\n    settingname = dupcat(name, \"Height\", NULL);\n    file_write_setting_i(handle, settingname, font.height);\n    sfree(settingname);\n}\n\nint file_read_setting_filename(void *handle, const char *name, Filename *result)\n{\n    return !!file_read_setting_s(handle, name, result->path, sizeof(result->path));\n}\n\nvoid file_write_setting_filename(void *handle, const char *name, Filename result)\n{\n    file_write_setting_s(handle, name, result.path);\n}\n\nvoid file_close_settings_r(void *handle)\n{\n\tif (!handle) return;\t/* JK: new in 0.1.3 */\n\n\tif (((struct setPack*) handle)->fromFile) {\n\t\tstruct setItem *st1, *st2;\n\n\t\tst1 = ((struct setPack*) handle)->handle;\n\t\twhile (st1) {\n\t\t\tst2 = st1->next;\n\t\t\tsfree(st1);\n\t\t\tst1 = st2;\n\t\t}\n\t\tsfree( ((struct setPack*) handle)->fileBuf );\n\t\tsfree(handle);\n\t}\n\telse {\n\t\thandle = ((struct setPack*) handle)->handle;\n\t    RegCloseKey((HKEY) handle);\n\t}\n}\n\nvoid file_del_settings(const char *sessionname)\n{\n    HKEY subkey1;\n    char *p;\n\tchar *p2;\n\n\t/* JK: if sessionname contains [registry] -> cut it off and delete from registry */\n\t/*if ( *(sessionname+strlen(sessionname)-1) == ']') {\n\n\t\tp = strrchr(sessionname, '[');\n\t\t*(p-1) = '\\0';\n\n\t\tp = snewn(3 * strlen(sessionname) + 1, char);\n\t\tmungestr(sessionname, p);\n\t\t\n\t\tif (RegOpenKey(HKEY_CURRENT_USER, puttystr, &subkey1) != ERROR_SUCCESS)\treturn;\n\n\t\tRegDeleteKey(subkey1, p);\n\t\tRegCloseKey(subkey1);\n\t}\n\telse {*/\n\t\t/* JK: delete from file - file itself */\n\n\t\tp = snewn(3 * strlen(sessionname) + 1, char);\n\t\tmungestr(sessionname, p);\n\t\tp2 = snewn(3 * strlen(p) + 1, char);\n\t\tpackstr(p, p2);\n\n\t\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\t\tif (SetCurrentDirectory(sesspath)) {\n\t\t\tif (!DeleteFile(p2))\n\t\t\t{\n\t\t\t\terrorShow(\"Unable to delete settings.\", NULL);\n\t\t\t}\n\t\t\tSetCurrentDirectory(oldpath);\n\t\t}\n\t//}\n\n\tsfree(p);\n}\n\nvoid *file_enum_settings_start(void)\n{\n    struct enumsettings *ret;\n    HKEY key;\n\n\t/* JK: in the first call of this function we can initialize path variables */\n\tif (*sesspath == '\\0') {\n\t\tloadPath();\n\t}\n\t/* JK: we have path variables */\n\t\n\t/* JK: let's do what this function should normally do */\n\tret = snew(struct enumsettings);\n\n\tif (RegOpenKey(HKEY_CURRENT_USER, puttystr, &key) != ERROR_SUCCESS) {\n\t\t/*\n\t\t * JK: nothing in registry -> pretend we found it, first call to file_enum_settings_next\n\t\t * will solve this by starting scanning dir sesspath\n\t\t*/\n\t}\n\tret->key = key;\n\tret->fromFile = 0;\n\tret->hFile = NULL;\n\tret->i = 0;\n\n    return ret;\n}\n\nchar *file_enum_settings_next(void *handle, char *buffer, int buflen)\n{\n\tstruct enumsettings *e = (struct enumsettings *) handle;\n    WIN32_FIND_DATA FindFileData;\n\tHANDLE hFile;\n\tchar *otherbuf;\n\t\n\tif (!handle) return NULL;\t/* JK: new in 0.1.3 */\n\t\n\totherbuf = snewn( (3*buflen)+1, char); /* must be here */\n\n\tif (! ((struct enumsettings *)handle)->fromFile ) {\n\n\t    /*if (RegEnumKey(e->key, e->i++, otherbuf, 3 * buflen) == ERROR_SUCCESS) {\n\t\t\tunmungestr(otherbuf, buffer, buflen);\n\t\t\tstrcat(buffer, \" [registry]\");\n\t\t\tsfree(otherbuf);\n\t\t\treturn buffer;\n\t\t}\n\t\telse {*/\n\t\t\t/* JK: registry scanning done, starting scanning directory \"sessions\" */\n\t\t\t((struct enumsettings *)handle)->fromFile = 1;\n\t\t\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\t\t\tif (!SetCurrentDirectory(sesspath)) {\n\t\t\t\tsfree(otherbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\thFile = FindFirstFile(\"*\", &FindFileData);\n\n\t\t\t/* JK: skip directories (extra check for \".\" and \"..\" too, seems to bug on some machines) */\n\t\t\twhile ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || FindFileData.cFileName[0] == '.') { // HACK: PUTTY TRAY / PUTTY FILE: Fixed directory check\n\t\t\t\tif (!FindNextFile(hFile,&FindFileData)) {\n\t\t\t\t\tsfree(otherbuf);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* JK: a file found */\n\t\t\tif (hFile != INVALID_HANDLE_VALUE && !((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || FindFileData.cFileName[0] == '.')) { // HACK: PUTTY TRAY / PUTTY FILE: Fixed directory check\n\t\t\t\t((struct enumsettings *)handle)->hFile = hFile;\n\t\t\t\tunmungestr(FindFileData.cFileName, buffer, buflen);\n\t\t\t\tsfree(otherbuf);\n\t\t\t\t/* JK: cut off sessionsuffix */\n\t\t\t\totherbuf = buffer + strlen(buffer) - strlen(sessionsuffix);\n\t\t\t\tif (strncmp(otherbuf, sessionsuffix, strlen(sessionsuffix)) == 0) {\n\t\t\t\t\t*otherbuf = '\\0';\n\t\t\t\t}\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* JK: not a single file found -> give up */\n\t\t\t\tsfree(otherbuf);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t//}\n\t}\n\telse if ( ((struct enumsettings *)handle)->fromFile ) {\n\t\tif (FindNextFile(((struct enumsettings *)handle)->hFile,&FindFileData) && !((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || FindFileData.cFileName[0] == '.')) { // HACK: PUTTY TRAY / PUTTY FILE: Fixed directory check\n\t\t\tunmungestr(FindFileData.cFileName, buffer, buflen);\n\t\t\tsfree(otherbuf);\n\t\t\t/* JK: cut off sessionsuffix */\n\t\t\totherbuf = buffer + strlen(buffer) - strlen(sessionsuffix);\n\t\t\tif (strncmp(otherbuf, sessionsuffix, strlen(sessionsuffix)) == 0) {\n\t\t\t\t*otherbuf = '\\0';\n\t\t\t}\n\t\t\treturn buffer;\n\t\t}\n\t\telse {\n\t\t\tsfree(otherbuf);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\t/* JK: should not end here */\n\tsfree(otherbuf);\n\treturn NULL;\n}\n\nvoid file_enum_settings_finish(void *handle)\n{\n    struct enumsettings *e = (struct enumsettings *) handle;\n\tif (!handle) return;\t/* JK: new in 0.1.3 */\n\n    RegCloseKey(e->key);\n\tif (((struct enumsettings *)handle)->hFile != NULL) { FindClose(((struct enumsettings *)handle)->hFile); }\n\tSetCurrentDirectory(oldpath);\n\tsfree(e);\n}\n\nint file_verify_host_key(const char *hostname, int port,\n\t\t    const char *keytype, const char *key)\n{\n    char *otherstr, *regname;\n    int len;\n\tHKEY rkey;\n    DWORD readlen;\n    DWORD type;\n    int ret, compare, userMB;\n\n\tDWORD fileSize;\n\tDWORD bytesRW;\n\tchar *p;\n\tHANDLE hFile;\n\tWIN32_FIND_DATA FindFile;\n\n    len = 1 + strlen(key);\n\n    /* Now read a saved key in from the registry and see what it says. */\n    otherstr = snewn(len, char);\n    regname = snewn(3 * (strlen(hostname) + strlen(keytype)) + 15, char);\n\n    hostkey_regname(regname, hostname, port, keytype);\n\n\t/* JK: settings on disk - every hostkey as file in dir */\n\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\tif (SetCurrentDirectory(sshkpath)) {\n\t\t\n\t\tp = snewn(3 * strlen(regname) + 1 + 16, char);\n\t\tpackstr(regname, p);\n\t\tstrcat(p, keysuffix);\n\n\t\thFile = CreateFile(p, GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n\t\tSetCurrentDirectory(oldpath);\n\n\t\tif (hFile != INVALID_HANDLE_VALUE) {\n\t\t\t/* JK: ok we got it -> read it to otherstr */\n\t\t\tfileSize = GetFileSize(hFile, NULL);\n\t\t\totherstr = snewn(fileSize+1, char);\n\t\t\tReadFile(hFile, otherstr, fileSize, &bytesRW, NULL);\n\t\t\t*(otherstr+fileSize) = '\\0';\n\n\t\t\tcompare = strcmp(otherstr, key);\n\n\t\t\tCloseHandle(hFile);\n\t\t\tsfree(otherstr);\n\t\t\tsfree(regname);\n\t\t\tsfree(p);\n\n\t\t\tif (compare) { /* key is here, but different */\n\t\t\t\treturn 2;\n\t\t\t}\n\t\t\telse { /* key is here and match */\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t/* not found as file -> try registry */\n\t\t\tsfree(p);\n\t\t}\n\t}\n\telse {\n\t\t/* JK: there are no hostkeys as files -> try registry -> nothing to do here now */\n\t}\n\t\n\t/* JK: directory/file not found -> try registry */\n\tif (RegOpenKey(HKEY_CURRENT_USER, PUTTY_REG_POS \"\\\\SshHostKeys\", &rkey) != ERROR_SUCCESS) {\n\t\treturn 1;\t\t       /* key does not exist in registry */\n\t}\n\n    readlen = len;\n    ret = RegQueryValueEx(rkey, regname, NULL, &type, otherstr, &readlen);\n\n    if (ret != ERROR_SUCCESS && ret != ERROR_MORE_DATA &&\n\t!strcmp(keytype, \"rsa\")) {\n\t/*\n\t * Key didn't exist. If the key type is RSA, we'll try\n\t * another trick, which is to look up the _old_ key format\n\t * under just the hostname and translate that.\n\t */\n\tchar *justhost = regname + 1 + strcspn(regname, \":\");\n\tchar *oldstyle = snewn(len + 10, char);\t/* safety margin */\n\treadlen = len;\n\tret = RegQueryValueEx(rkey, justhost, NULL, &type,\n\t\t\t      oldstyle, &readlen);\n\n\tif (ret == ERROR_SUCCESS && type == REG_SZ) {\n\t    /*\n\t     * The old format is two old-style bignums separated by\n\t     * a slash. An old-style bignum is made of groups of\n\t     * four hex digits: digits are ordered in sensible\n\t     * (most to least significant) order within each group,\n\t     * but groups are ordered in silly (least to most)\n\t     * order within the bignum. The new format is two\n\t     * ordinary C-format hex numbers (0xABCDEFG...XYZ, with\n\t     * A nonzero except in the special case 0x0, which\n\t     * doesn't appear anyway in RSA keys) separated by a\n\t     * comma. All hex digits are lowercase in both formats.\n\t     */\n\t    char *p = otherstr;\n\t    char *q = oldstyle;\n\t    int i, j;\n\n\t    for (i = 0; i < 2; i++) {\n\t\tint ndigits, nwords;\n\t\t*p++ = '0';\n\t\t*p++ = 'x';\n\t\tndigits = strcspn(q, \"/\");\t/* find / or end of string */\n\t\tnwords = ndigits / 4;\n\t\t/* now trim ndigits to remove leading zeros */\n\t\twhile (q[(ndigits - 1) ^ 3] == '0' && ndigits > 1)\n\t\t    ndigits--;\n\t\t/* now move digits over to new string */\n\t\tfor (j = 0; j < ndigits; j++)\n\t\t    p[ndigits - 1 - j] = q[j ^ 3];\n\t\tp += ndigits;\n\t\tq += nwords * 4;\n\t\tif (*q) {\n\t\t    q++;\t       /* eat the slash */\n\t\t    *p++ = ',';\t       /* add a comma */\n\t\t}\n\t\t*p = '\\0';\t       /* terminate the string */\n\t    }\n\n\t    /*\n\t     * Now _if_ this key matches, we'll enter it in the new\n\t     * format. If not, we'll assume something odd went\n\t     * wrong, and hyper-cautiously do nothing.\n\t     */\n\t    if (!strcmp(otherstr, key))\n\t\tRegSetValueEx(rkey, regname, 0, REG_SZ, otherstr,\n\t\t\t      strlen(otherstr) + 1);\n\t\t/* JK: session is not saved to file - fixme */\n\t}\n    }\n\n    compare = strcmp(otherstr, key);\n\n\tif (ret == ERROR_MORE_DATA || (ret == ERROR_SUCCESS && type == REG_SZ && compare)) {\n\t\tRegCloseKey(rkey);\n\t\treturn 2;\t\t       /* key is different in registry */\n\t}\n\telse if (ret != ERROR_SUCCESS || type != REG_SZ) {\n\t\tRegCloseKey(rkey);\n\t\treturn 1;\t\t       /* key does not exist in registry */\n\t}\n\telse { /* key matched OK in registry */\n\t\t/* JK: matching key found in registry -> warn user, ask what to do */\n\t\tp = snewn(256, char);\n\t\tuserMB = MessageBox(NULL, \"The host key is cached in the Windows registry. \"\n\t\t\t\"Do you want to move it to a file? \\n\\n\"\n\t\t\t\"Yes \\t-> Move to file (and delete from registry)\\n\"\n\t\t\t\"No \\t-> Copy to file (and keep in registry)\\n\"\n\t\t\t\"Cancel \\t-> nothing will be done\\n\", \"Security risk\", MB_YESNOCANCEL|MB_ICONWARNING);\n\n\t\tif ((userMB == IDYES) || (userMB == IDNO)) {\n\t\t\t/* JK: save key to file */\n\t\t\tif ((hFile = FindFirstFile(sshkpath, &FindFile)) == INVALID_HANDLE_VALUE) {\n\t\t\t\tcreatePath(sshkpath);\n\t\t\t}\n\t\t\tFindClose(hFile);\n\t\t\tSetCurrentDirectory(sshkpath);\n\n\t\t\tp = snewn(3*strlen(regname) + 1 + 16, char);\n\t\t\tpackstr(regname, p);\n\t\t\tstrcat(p, keysuffix);\n\t\t\t\n\t\t\thFile = CreateFile(p, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n\t\t\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\t\t\terrorShow(\"Unable to create file (key won't be deleted from registry)\", p);\n\t\t\t\tuserMB = IDNO;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!WriteFile(hFile, key, strlen(key), &bytesRW, NULL)) {\n\t\t\t\t\terrorShow(\"Unable to save key to file (key won't be deleted from registry)\", NULL);\n\t\t\t\t\tuserMB = IDNO;\n\t\t\t\t}\n\t\t\t\tCloseHandle(hFile);\n\t\t\t}\n\t\t}\n\t\tif (userMB == IDYES) {\n\t\t\t/* delete from registry */\n\t\t\tif (RegDeleteValue(rkey, regname) != ERROR_SUCCESS) {\n\t\t\t\terrorShow(\"Unable to delete registry value\", regname);\n\t\t\t}\n\t\t}\n\t\t/* JK: else (Cancel) -> nothing to be done right now */\n\t\t\n\t\tRegCloseKey(rkey);\n\n\t\tsfree(otherstr);\n\t\tsfree(regname);\n\t\treturn 0;\t\t       \n\t}\n}\n\nvoid file_store_host_key(const char *hostname, int port,\n\t\t    const char *keytype, const char *key)\n{\n    char *regname = NULL;\n\tWIN32_FIND_DATA FindFile;\n    HANDLE hFile = NULL;\n\tchar* p = NULL;\n\tDWORD bytesWritten;\n\n    regname = snewn(3 * (strlen(hostname) + strlen(keytype)) + 15, char);\n    hostkey_regname(regname, hostname, port, keytype);\n\n\t/* JK: save hostkey to file in dir */\n\tif ((hFile = FindFirstFile(sshkpath, &FindFile)) == INVALID_HANDLE_VALUE) {\n\t\tcreatePath(sshkpath);\n\t}\n\tFindClose(hFile);\n\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\tSetCurrentDirectory(sshkpath);\n\n\tp = snewn(3*strlen(regname) + 1, char);\n\tpackstr(regname, p);\n\tstrcat(p, keysuffix);\n\thFile = CreateFile(p, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n\n\tif (hFile == INVALID_HANDLE_VALUE) {\n\t\terrorShow(\"Unable to create file\", p);\n\t}\n\telse {\n\t\tif (!WriteFile(hFile, key, strlen(key), &bytesWritten, NULL)) {\n\t\t\terrorShow(\"Unable to save key to file\", NULL);\n\t\t}\n\t\tCloseHandle(hFile);\n\t}\n\tSetCurrentDirectory(oldpath);\n\n    sfree(p);\n\tsfree(regname);\n}\n\n\n/* ---------------------------------------------------------------------------------------------------------\n * ---------------------------------------------------------------------------------------------------------\n * REGISTRY FUNCTIONS\n * ---------------------------------------------------------------------------------------------------------\n * -------------------------------------------------------------------------------------------------------*/\nvoid *reg_open_settings_w(const char *sessionname, char **errmsg)\n{\n    HKEY subkey1, sesskey;\n    int ret;\n      return (void *) sesskey;\n  }\n  \nvoid reg_write_setting_s(void *handle, const char *key, const char *value)\n  {\n      if (handle)\n  \tRegSetValueEx((HKEY) handle, key, 0, REG_SZ, value,\n  \t\t      1 + strlen(value));\n  }\n  \nvoid reg_write_setting_i(void *handle, const char *key, int value)\n  {\n      if (handle)\n  \tRegSetValueEx((HKEY) handle, key, 0, REG_DWORD,\n  \t\t      (CONST BYTE *) &value, sizeof(value));\n  }\n  \nvoid reg_close_settings_w(void *handle)\n  {\n      RegCloseKey((HKEY) handle);\n  }\n  \nvoid *reg_open_settings_r(const char *sessionname)\n  {\n      HKEY subkey1, sesskey;\n      char *p;\n      return (void *) sesskey;\n  }\n  \nchar *reg_read_setting_s(void *handle, const char *key, char *buffer, int buflen)\n  {\n      DWORD type, size;\n      size = buflen;\n  \treturn buffer;\n  }\n  \nint reg_read_setting_i(void *handle, const char *key, int defvalue)\n  {\n      DWORD type, val, size;\n      size = sizeof(val);\n  \treturn val;\n  }\n\nint reg_read_setting_fontspec(void *handle, const char *name, FontSpec *result)\n{\n    char *settingname;\n    FontSpec ret;\n  \n    if (!reg_read_setting_s(handle, name, ret.name, sizeof(ret.name)))\n\treturn 0;\n    settingname = dupcat(name, \"IsBold\", NULL);\n    ret.isbold = reg_read_setting_i(handle, settingname, -1);\n    sfree(settingname);\n    if (ret.isbold == -1) return 0;\n    settingname = dupcat(name, \"CharSet\", NULL);\n    ret.charset = reg_read_setting_i(handle, settingname, -1);\n    sfree(settingname);\n    if (ret.charset == -1) return 0;\n    settingname = dupcat(name, \"Height\", NULL);\n    ret.height = reg_read_setting_i(handle, settingname, INT_MIN);\n    sfree(settingname);\n    if (ret.height == INT_MIN) return 0;\n    *result = ret;\n    return 1;\n}\n\nvoid reg_write_setting_fontspec(void *handle, const char *name, FontSpec font)\n{\n    char *settingname;\n\n    reg_write_setting_s(handle, name, font.name);\n    settingname = dupcat(name, \"IsBold\", NULL);\n    reg_write_setting_i(handle, settingname, font.isbold);\n    sfree(settingname);\n    settingname = dupcat(name, \"CharSet\", NULL);\n    reg_write_setting_i(handle, settingname, font.charset);\n    sfree(settingname);\n    settingname = dupcat(name, \"Height\", NULL);\n    reg_write_setting_i(handle, settingname, font.height);\n    sfree(settingname);\n}\n  \nint reg_read_setting_filename(void *handle, const char *name, Filename *result)\n{\n    return !!reg_read_setting_s(handle, name, result->path, sizeof(result->path));\n}\n\nvoid reg_write_setting_filename(void *handle, const char *name, Filename result)\n{\n    reg_write_setting_s(handle, name, result.path);\n}\n  \nvoid reg_close_settings_r(void *handle)\n{\n    RegCloseKey((HKEY) handle);\n}\n  \nvoid reg_del_settings(const char *sessionname)\n{\n    HKEY subkey1;\n    char *p;\n    RegCloseKey(subkey1);\n}\n\n/*\nstruct enumsettings {\n    HKEY key;\n    int i;\n};\n*/\nvoid *reg_enum_settings_start(int storagetype)\n{\n    struct enumsettings *ret;\n    HKEY key;\n    return ret;\n}\n  \nchar *reg_enum_settings_next(void *handle, char *buffer, int buflen)\n{\n    struct enumsettings *e = (struct enumsettings *) handle;\n    char *otherbuf;\n}\n  \nvoid reg_enum_settings_finish(void *handle)\n{\n    struct enumsettings *e = (struct enumsettings *) handle;\n    RegCloseKey(e->key);\n    sfree(e);\n}\n  \nint reg_verify_host_key(const char *hostname, int port,\n\t\t    const char *keytype, const char *key)\n{\n    char *otherstr, *regname;\n\treturn 0;\t\t       /* key matched OK in registry */\n}\n\nvoid reg_store_host_key(const char *hostname, int port,\n  \t\t    const char *keytype, const char *key)\n{\n    char *regname;\n\treturn 0;\t\t       /* key matched OK in registry */\n}\n\nvoid store_host_key(const char *hostname, int port,\n\t\t    const char *keytype, const char *key)\n{\n    char *regname;\n    HKEY rkey;\n\n    regname = snewn(3 * (strlen(hostname) + strlen(keytype)) + 15, char);\n\n    hostkey_regname(regname, hostname, port, keytype);\n\n    if (RegCreateKey(HKEY_CURRENT_USER, PUTTY_REG_POS \"\\\\SshHostKeys\",\n\t\t     &rkey) == ERROR_SUCCESS) {\n\tRegSetValueEx(rkey, regname, 0, REG_SZ, key, strlen(key) + 1);\n\tRegCloseKey(rkey);\n\n      } /* else key does not exist in registry */\n  \n      sfree(regname);\n }\n"
        },
        {
          "name": "kitty_regex.c",
          "type": "blob",
          "size": 0.30078125,
          "content": "#include \"kitty_regex.h\"\n\nint strgrep( const char * pattern, const char * str ) {\n\tint return_code = 1 ;\n\tregex_t preg ;\n\n\tif( (return_code = regcomp (&preg, pattern, REG_NOSUB | REG_EXTENDED ) ) == 0 ) {\n\t\treturn_code = regexec( &preg, str, 0, NULL, 0 ) ;\n\t\tregfree( &preg ) ;\n\t\t}\n\n\treturn return_code ;\n\t}\n"
        },
        {
          "name": "kitty_regex.h",
          "type": "blob",
          "size": 0.138671875,
          "content": "#ifndef KITTY_REGEX\n#define KITTY_REGEX\n#include <stdlib.h>\n#include \"regex.h\"\nint strgrep( const char * pattern, const char * str ) ;\n#endif\n"
        },
        {
          "name": "kitty_registry.c",
          "type": "blob",
          "size": 29.630859375,
          "content": "#include \"kitty_registry.h\"\n\n//static const int cstMaxRegLength = 1024;\n#define cstMaxRegLength 1024\n\nchar * itoa (int __val, char *__s, int __radix) ;\nchar * GetValueData(HKEY hkTopKey, char * lpSubKey, const char * lpValueName, char * rValue){\n    HKEY hkKey;\n    DWORD lpType, dwDataSize = cstMaxRegLength;\n  \n  //Receptionne la valeur de réception lecture clé registre\n    //unsigned char * lpData = new unsigned char[cstMaxRegLength];\n\tunsigned char * lpData = (unsigned char*) malloc( cstMaxRegLength );\n    \n  //Receptionne la valeur de réception lecture clé registre\n    //char * rValue = (char*) malloc( cstMaxRegLength );\n    rValue[0] = '\\0';\n  //Lecture de la clé registre si ok passe à la suite...\n    if (RegOpenKeyEx(hkTopKey,lpSubKey,0,KEY_READ,&hkKey) == ERROR_SUCCESS){\n  \n      if (RegQueryValueEx(hkKey,lpValueName,NULL,&lpType,lpData,&dwDataSize) == ERROR_SUCCESS){\n      //déchiffrage des différents type de clé dans registry\n        switch ((int)lpType){\n  \n          case REG_BINARY:\n               itoa((u_int)(lpData[0]),rValue, 10);\n               strcat(rValue,\".\");\n               itoa((u_int)(lpData[1]),(char*)(rValue+strlen(rValue)),10);\n               strcat(rValue,\".\");\n               itoa((u_int)(lpData[2]),(char*)(rValue+strlen(rValue)),10);\n               strcat(rValue,\".\");\n               itoa((u_int)(lpData[3]),(char*)(rValue+strlen(rValue)),10);\n               break;\n  \n          case REG_DWORD:\n               itoa(*(int*)(lpData),rValue,10);\n               break;\n  \n          case REG_EXPAND_SZ:\n               //rValue=(char *)lpData;\n               strcpy( rValue, (char*)lpData ) ;\n               break;\n  \n          case REG_MULTI_SZ:\n               //rValue=(char *)lpData;\n               strcpy( rValue, (char*)lpData ) ;\n               break;\n  \n          case REG_SZ:\n               //rValue=(char *)lpData;\n               strcpy( rValue, (char*)lpData ) ;\n               break;\n        }//end switch\n      }//end if\n      else { RegCloseKey(hkKey); free(lpData); return NULL ; }\n       free(lpData); // libère la mémoire\n       RegCloseKey(hkKey); \n      \n    }//end if\n    else { return NULL ; }\n    return rValue;\n  }//end function\n\n// Teste l'existance d'une clé\nint RegTestKey( HKEY hMainKey, LPCTSTR lpSubKey ) {\n\tHKEY hKey ;\n\tif( lpSubKey == NULL ) return 1 ;\n\tif( strlen( lpSubKey ) == 0 ) return 1 ;\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_WRITE, &hKey) != ERROR_SUCCESS ) return 0 ;\n\tRegCloseKey( hKey ) ;\n\treturn 1 ;\n\t}\n\t\n// Retourne le nombre de sous-keys\nint RegCountKey( HKEY hMainKey, LPCTSTR lpSubKey ) {\n\tHKEY hKey ;\n\tTCHAR    achClass[MAX_PATH] = TEXT(\"\");\n\tDWORD    cchClassName = MAX_PATH, cSubKeys=0, cbMaxSubKey, cchMaxClass, cValues, cchMaxValue, cbMaxValueData, cbSecurityDescriptor ;\n\tFILETIME ftLastWriteTime;\n\n\tint nb = 0 ;\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return 0 ;\n\t\n\tRegQueryInfoKey( hKey, achClass, &cchClassName, NULL, &cSubKeys, &cbMaxSubKey, &cchMaxClass\n\t\t, &cValues, &cchMaxValue, &cbMaxValueData, &cbSecurityDescriptor, &ftLastWriteTime) ;\n\tnb = cSubKeys ;\n\tRegCloseKey( hKey ) ;\n\treturn nb ;\n\t}\n\n\t// Teste l'existance d'une clé ou bien d'une valeur et la crée sinon\nvoid RegTestOrCreate( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR name, LPCTSTR value ) {\n\tHKEY hKey ;\n\tif( lpSubKey == NULL ) return ;\n\tif( strlen( lpSubKey ) == 0 ) return ;\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_WRITE, &hKey) != ERROR_SUCCESS ) {\n\t\tRegCreateKey( hMainKey, lpSubKey, &hKey ) ;\n\t\t}\n\tif( name != NULL ) {\n\t\tRegSetValueEx( hKey, TEXT( name ), 0, REG_SZ, (const BYTE *)value, strlen(value)+1 ) ;\n\t\t}\n\tRegCloseKey( hKey ) ;\n\t}\n\t\n// Test l'existance d'une clé ou bien d'une valeur DWORD et la crée sinon\nvoid RegTestOrCreateDWORD( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR name, DWORD value ) {\n\tHKEY hKey ;\n\tif( lpSubKey == NULL ) return ;\n\tif( strlen( lpSubKey ) == 0 ) return ;\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_WRITE, &hKey) != ERROR_SUCCESS ) {\n\t\tRegCreateKey( hMainKey, lpSubKey, &hKey ) ;\n\t\t}\n\tif( name != NULL ) {\n\t\tRegSetValueEx( hKey, TEXT( name ), 0, REG_DWORD, (LPBYTE)&value, sizeof(DWORD) ) ;\n\t\t}\n\tRegCloseKey( hKey ) ;\n\t}\n\t\n\n// Initialise toutes les sessions avec une valeur (si oldvalue==NULL) ou uniquement celles qui ont la valeur oldvalue\nvoid RegUpdateAllSessions( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR name, LPCTSTR oldvalue, LPCTSTR value  ) {\n\tHKEY hKey ;\n\tTCHAR    achClass[MAX_PATH] = TEXT(\"\"), achKey[MAX_KEY_LENGTH]; \n\tDWORD    cchClassName = MAX_PATH, cSubKeys=0, cbMaxSubKey, cbName=MAX_KEY_LENGTH, cchMaxClass, cValues, cchMaxValue, cbMaxValueData, cbSecurityDescriptor ;\n\tFILETIME ftLastWriteTime;\n\t\n\tint i, retCode ;\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n\tRegQueryInfoKey( hKey, achClass, &cchClassName, NULL, &cSubKeys, &cbMaxSubKey, &cchMaxClass\n\t\t, &cValues, &cchMaxValue, &cbMaxValueData, &cbSecurityDescriptor, &ftLastWriteTime) ;\n\n\tif (cSubKeys) {\n\t\tfor (i=0; i<cSubKeys; i++) {\n\t\t\tretCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime); \n\t\t\tif (retCode == ERROR_SUCCESS) {\n\t\t\t\tchar buffer[MAX_KEY_LENGTH] ;\n\t\t\t\tchar previousvalue[1024] ;\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", lpSubKey, achKey ) ;\n\t\t\t\tGetValueData( hMainKey, buffer, name, previousvalue ) ;\n\t\t\t\tif( (oldvalue==NULL) || ( !strcmp(previousvalue,oldvalue)) )\n\t\t\t\t\tMessageBox(NULL,achKey,\"Info\",MB_OK);\n\t\t\t\t\t//RegTestOrCreate( hMainKey, buffer, name, value ) ;\n\t\t\t}\n\t\t}\n\t}\n}\n\t\n// Exporte toute une cle de registre\nvoid QuerySubKey( HKEY hMainKey, LPCTSTR lpSubKey, FILE * fp_out, char * text  ) { \n\tHKEY hKey ;\n    TCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name\n    DWORD    cbName;                   // size of name string \n    TCHAR    achClass[MAX_PATH] = TEXT(\"\");  // buffer for class name \n    DWORD    cchClassName = MAX_PATH;  // size of class string \n    DWORD    cSubKeys=0;               // number of subkeys \n    DWORD    cbMaxSubKey;              // longest subkey size \n    DWORD    cchMaxClass;              // longest class string \n    DWORD    cValues;              // number of values for key \n    DWORD    cchMaxValue;          // longest value name \n    DWORD    cbMaxValueData;       // longest value data \n    DWORD    cbSecurityDescriptor; // size of security descriptor \n    FILETIME ftLastWriteTime;      // last write time \n    DWORD i, retCode; \n\t\n\tchar * buffer = NULL ;\n\n\t// On ouvre la clé\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n\n    // Get the class name and the value count. \n    retCode = RegQueryInfoKey(\n        hKey,                    // key handle \n        achClass,                // buffer for class name \n        &cchClassName,           // size of class string \n        NULL,                    // reserved \n        &cSubKeys,               // number of subkeys \n        &cbMaxSubKey,            // longest subkey size \n        &cchMaxClass,            // longest class string \n        &cValues,                // number of values for this key \n        &cchMaxValue,            // longest value name \n        &cbMaxValueData,         // longest value data \n        &cbSecurityDescriptor,   // security descriptor \n        &ftLastWriteTime);       // last write time \n \n\t// Enumerate the subkeys, until RegEnumKeyEx fails.\n\tif (cSubKeys) {\n\t\tfor (i=0; i<cSubKeys; i++) { \n\t\t\tcbName = MAX_KEY_LENGTH;\n\t\t\tretCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime); \n\t\t\tif (retCode == ERROR_SUCCESS) {\n\t\t\t\tbuffer = (char*) malloc( strlen( TEXT(lpSubKey) ) + strlen( achKey ) + 100 ) ;\n\t\t\t\tsprintf( buffer, \"[HKEY_CURRENT_USER\\\\%s\\\\%s]\", TEXT(lpSubKey), achKey ) ;\n\t\t\t\tfprintf( fp_out, \"\\r\\n%s\\r\\n\", buffer ) ;\n\t\t\t\tif( text!=NULL ) \n\t\t\t\t\tif( strlen( text ) > 0 ) fprintf( fp_out, \"%s\\r\\n\", text ) ;\n\t\t\t\tfree( buffer );\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\tRegCloseKey( hKey ) ;\n\t}\n\nvoid InitRegistryAllSessions( HKEY hMainKey, LPCTSTR lpSubKey, char * SubKeyName, char * filename, char * text ) {\n\tFILE * fp;\n\tchar buf[1024] = \"\" ;\n\tif( (fp=fopen( filename, \"wb\" )) != NULL ) {\n\t\tfprintf( fp, \"Windows Registry Editor Version 5.00\\r\\n\" ) ;\n\t\tsprintf( buf, \"%s\\\\%s\", lpSubKey, SubKeyName ); \n\t\tQuerySubKey( hMainKey, (LPCTSTR)buf, fp, text ) ;\n\t\tfclose( fp ) ;\n\t\t}\n\t}\n\t\nvoid InitAllSessions( HKEY hMainKey, LPCTSTR lpSubKey, char * SubKeyName, char * filename ) {\n\tchar text[4096], f[1024] ;\n\tFILE * fp ;\n\tint len ;\n\tif( (fp=fopen(filename, \"rb\")) != NULL ) {\n\t\tlen = fread( text, 1, 4096, fp ) ;\n\t\tfclose( fp ) ;\n\t\ttext[4095]='\\0'; text[len] = '\\0' ;\n\t\twhile( (text[strlen(text)-1]=='\\n')||(text[strlen(text)-1]=='\\r') ) text[strlen(text)-1]='\\0' ;\n\t\tsprintf( f, \"%s.reg\", filename ) ;\n\t\tInitRegistryAllSessions( hMainKey, lpSubKey, SubKeyName, f, text ) ;\n\t\tunlink(filename);\n\t\t}\n\t}\n\t\n// Détruit une valeur de clé de registre \nBOOL RegDelValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValue ) {\n\tHKEY hKey;\n\tLONG lResult;\n\tif( (lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_WRITE, &hKey)) == ERROR_SUCCESS ) {\n\t\tRegDeleteValue( hKey, lpValue ) ;\n\t\tRegCloseKey(hKey) ;\n\t\t}\n\treturn TRUE;   \n\t}\n\n// Detruit une clé de registre et ses sous-clé\nBOOL RegDelTree (HKEY hKeyRoot, LPCTSTR lpSubKey) {\n    TCHAR lpEnd[MAX_PATH];\n    LONG lResult;\n    DWORD dwSize;\n    TCHAR szName[MAX_PATH];\n    HKEY hKey;\n    FILETIME ftWrite;\n\n    // First, see if we can delete the key without having\n    // to recurse.\n    lResult = RegDeleteKey(hKeyRoot, lpSubKey);\n    if (lResult == ERROR_SUCCESS) return TRUE;\n\n    lResult = RegOpenKeyEx (hKeyRoot, lpSubKey, 0, KEY_READ, &hKey) ;\n\n    if (lResult != ERROR_SUCCESS) {\n        if (lResult == ERROR_FILE_NOT_FOUND) { \n\t\t//printf(\"Key not found.\\n\") ;\n\t\treturn TRUE ; \n\t} else {\n\t\t//printf(\"Error opening key.\\n\") ;\n\t\treturn FALSE ;\n\t}\n    }\n\n    // Enumerate the keys\n    dwSize = MAX_PATH;\n    lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL, NULL, NULL, &ftWrite) ;\n\n    if (lResult == ERROR_SUCCESS) \n    {\n        do {\n            //StringCchCopy (lpEnd, MAX_PATH*2, szName);\n            sprintf(lpEnd, \"%s\\\\%s\", lpSubKey, szName);\n\n            //if( !RegDelTree( hKeyRoot, lpSubKey ) ) { break ; }\n            if( !RegDelTree( hKeyRoot, lpEnd ) ) { break ; }\n            dwSize = MAX_PATH;\n            lResult = RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL, NULL, NULL, &ftWrite) ;\n        } while ( lResult == ERROR_SUCCESS ) ;\n    }\n\n\tRegCloseKey(hKey) ;\n\n\t// Try again to delete the key.\n\tlResult = RegDeleteKey(hKeyRoot, lpSubKey);\n\n\tif (lResult == ERROR_SUCCESS) return TRUE;\n\treturn FALSE;\n\t}\n\n// Copie une clé de registre vers une autre\nvoid RegCopyTree( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR lpDestKey ) { \n\tHKEY hKey, hDestKey ;\n    TCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name\n    DWORD    cbName;                   // size of name string \n    TCHAR    achClass[MAX_PATH] = TEXT(\"\");  // buffer for class name \n    DWORD    cchClassName = MAX_PATH;  // size of class string \n    DWORD    cSubKeys=0;               // number of subkeys \n    DWORD    cbMaxSubKey;              // longest subkey size \n    DWORD    cchMaxClass;              // longest class string \n    DWORD    cValues;              // number of values for key \n    DWORD    cchMaxValue;          // longest value name \n    DWORD    cbMaxValueData;       // longest value data \n    DWORD    cbSecurityDescriptor; // size of security descriptor \n    FILETIME ftLastWriteTime;      // last write time \n \n    DWORD i, retCode; \n \n    TCHAR  achValue[MAX_VALUE_NAME]; \n    DWORD cchValue = MAX_VALUE_NAME; \n\t\n\tDWORD lpType, dwDataSize = 1024 ;\n\tchar * buffer = NULL, * destbuffer = NULL ;\n\t\n\t// On ouvre la clé\n\tif( RegOpenKeyEx( hMainKey, TEXT(lpSubKey), 0, KEY_READ, &hKey) != ERROR_SUCCESS ) return ;\n\tif( RegCreateKey( hMainKey, TEXT(lpDestKey), &hDestKey ) == ERROR_SUCCESS )\n\t\t\t\t\tRegCloseKey( hDestKey ) ;\n\n    // Get the class name and the value count. \n    retCode = RegQueryInfoKey(\n        hKey,                    // key handle \n        achClass,                // buffer for class name \n        &cchClassName,           // size of class string \n        NULL,                    // reserved \n        &cSubKeys,               // number of subkeys \n        &cbMaxSubKey,            // longest subkey size \n        &cchMaxClass,            // longest class string \n        &cValues,                // number of values for this key \n        &cchMaxValue,            // longest value name \n        &cbMaxValueData,         // longest value data \n        &cbSecurityDescriptor,   // security descriptor \n        &ftLastWriteTime);       // last write time \n \n    // Enumerate the key values. \n    if (cValues) \n    {\n        //printf( \"\\nNumber of values: %d\\n\", cValues);\n\n        for (i=0, retCode=ERROR_SUCCESS; i<cValues; i++) \n        { \n            cchValue = MAX_VALUE_NAME; \n            achValue[0] = '\\0'; \n            retCode = RegEnumValue(hKey, i, \n                achValue, \n                &cchValue, \n                NULL, \n                NULL,\n                NULL,\n                NULL);\n \n            if (retCode == ERROR_SUCCESS ) \n            { \n\t\t\t\tunsigned char lpData[1024] ;\n\t\t\t\tdwDataSize = 1024 ;\n\t\t\t\tRegQueryValueEx( hKey, TEXT( achValue ), 0, &lpType, lpData, &dwDataSize ) ;\n\t\t\t\t\n\t\t\t\tif( RegOpenKeyEx( hMainKey, TEXT(lpDestKey), 0, KEY_WRITE, &hDestKey) != ERROR_SUCCESS ) return ;\n\t\t\t\t\n\t\t\t\tRegSetValueEx( hDestKey, TEXT( achValue ), 0, lpType, lpData, dwDataSize );\n\t\t\t\t\t\n\t\t\t\tRegCloseKey( hDestKey ) ;\n            } \n        }\n    }\n\t\n    // Enumerate the subkeys, until RegEnumKeyEx fails.\n    if (cSubKeys)\n    {\n        //printf( \"\\nNumber of subkeys: %d\\n\", cSubKeys);\n\n        for (i=0; i<cSubKeys; i++) \n        { \n            cbName = MAX_KEY_LENGTH;\n            retCode = RegEnumKeyEx(hKey, i,\n                     achKey, \n                     &cbName, \n                     NULL, \n                     NULL, \n                     NULL, \n                     &ftLastWriteTime); \n            if (retCode == ERROR_SUCCESS) \n            {\n\t\t\t\tbuffer = (char*) malloc( strlen( TEXT(lpSubKey) ) + strlen( achKey ) + 3 ) ;\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", TEXT(lpSubKey), achKey ) ;\n\t\t\t\tdestbuffer = (char*) malloc( strlen( TEXT(lpDestKey) ) + strlen( achKey ) + 3 ) ;\n\t\t\t\tsprintf( destbuffer, \"%s\\\\%s\", TEXT(lpDestKey), achKey ) ;\n\t\t\t\tif( RegCreateKey( hMainKey, destbuffer, &hDestKey ) == ERROR_SUCCESS )\n\t\t\t\t\tRegCloseKey( hDestKey ) ;\n\t\t\t\t\t\n\t\t\t\tRegCopyTree( hMainKey, buffer, destbuffer ) ;\n\t\t\t\tfree( buffer );\n\t\t\t\tfree( destbuffer );\n            }\n        }\n    } \n \n\tRegCloseKey( hKey ) ;\n}\n\n// Nettoie la clé de PuTTY pour enlever les clés et valeurs spécifique à KiTTY\nBOOL RegCleanPuTTY( void ) {\n\tHKEY hKey, hSubKey ;\n\tDWORD retCode, i;\n\tTCHAR    achKey[MAX_KEY_LENGTH];   // buffer for subkey name\n\tDWORD    cbName;                   // size of name string \n\tTCHAR    achClass[MAX_PATH] = TEXT(\"\");  // buffer for class name \n\tDWORD    cchClassName = MAX_PATH;  // size of class string \n\tDWORD    cSubKeys=0;               // number of subkeys \n\tDWORD    cbMaxSubKey;              // longest subkey size \n\tDWORD    cchMaxClass;              // longest class string \n\tDWORD    cValues;              // number of values for key \n\tDWORD    cchMaxValue;          // longest value name \n\tDWORD    cbMaxValueData;       // longest value data \n\tDWORD    cbSecurityDescriptor; // size of security descriptor \n\tFILETIME ftLastWriteTime;      // last write time \n\tchar *buffer = NULL ;\n#ifdef FLJ\nreturn 1 ;\n#endif\n\tif( (retCode = RegOpenKeyEx ( HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\", 0, KEY_WRITE, &hSubKey)) == ERROR_SUCCESS ) {\n\t\tRegDeleteValue( hSubKey, \"Build\" ) ;\n\t\tRegDeleteValue( hSubKey, \"Folders\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiCount\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiLastSe\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiLastUH\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiLastUp\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiPath\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiSess\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiVers\" ) ;\n\t\tRegDeleteValue( hSubKey, \"CtHelperPath\" ) ;\n\t\tRegDeleteValue( hSubKey, \"PSCPPath\" ) ;\n\t\tRegDeleteValue( hSubKey, \"WinSCPPath\" ) ;\n\t\tRegDeleteValue( hSubKey, \"KiClassName\" ) ;\n\t\tRegCloseKey(hSubKey) ;\n\t\t}\n\t\n\tRegDelTree (HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\\\\Commands\" ) ;\n\tRegDelTree (HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\\\\Folders\" ) ;\n\tRegDelTree (HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\\\\Launcher\" ) ;\n\t\n\t// On ouvre la clé\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\", 0, KEY_READ|KEY_WRITE, &hKey) != ERROR_SUCCESS ) return 0;\n\t\n\tretCode = RegQueryInfoKey(\n        hKey,                    // key handle \n        achClass,                // buffer for class name \n        &cchClassName,           // size of class string \n        NULL,                    // reserved \n        &cSubKeys,               // number of subkeys \n        &cbMaxSubKey,            // longest subkey size \n        &cchMaxClass,            // longest class string \n        &cValues,                // number of values for this key \n        &cchMaxValue,            // longest value name \n        &cbMaxValueData,         // longest value data \n        &cbSecurityDescriptor,   // security descriptor \n        &ftLastWriteTime);\n\t\n\t// Enumerate the subkeys, until RegEnumKeyEx fails.\n\tif (cSubKeys) {  //printf( \"\\nNumber of subkeys: %d\\n\", cSubKeys);\n\t\tfor (i=0; i<cSubKeys; i++) { \n\t\t\tcbName = MAX_KEY_LENGTH;\n\t\t\tif( ( retCode = RegEnumKeyEx(hKey, i, achKey, &cbName,NULL,NULL,NULL, &ftLastWriteTime) ) == ERROR_SUCCESS ) {\n\t\t\t\tbuffer = (char*) malloc( strlen( achKey ) + 50 ) ;\n\t\t\t\tsprintf( buffer, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\\\\%s\\\\Commands\", achKey ) ;\n\t\t\t\tRegDelTree( HKEY_CURRENT_USER, buffer );\n\t\t\t\tsprintf( buffer, \"Software\\\\SimonTatham\\\\PuTTY\\\\Sessions\\\\%s\", achKey ) ;\n\t\t\t\tif( (retCode = RegOpenKeyEx ( HKEY_CURRENT_USER, buffer, 0, KEY_WRITE, &hSubKey)) == ERROR_SUCCESS ) {\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BCDelay\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgOpacity\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgSlideshow\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgType\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgImageFile\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgImageStyle\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgImageAbsoluteX\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgImageAbsoluteY\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BgImagePlacement\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Fullscreen\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Maximize\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SendToTray\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SaveOnExit\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Folder\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Icone\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"IconeFile\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WinSCPProtocol\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SFTPConnect\" ) ;\n    \t\t\t\t\tRegDeleteValue( hSubKey, \"PSCPOptions\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"PSCPShell\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"PSCPRemoteDir\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WinSCPOptions\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WinSCPRawSettings\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"InitDelay\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Password\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Autocommand\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"AutocommandOut\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"AntiIdle\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"LogTimestamp\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Notes\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"CygtermCommand\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"CygtermAltMetabit\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"CygtermAutoPath\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Cygterm64\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WakeupReconnect\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"FailureReconnect\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Scriptfile\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptfileContent\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HostAlt\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"TransparencyValue\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"TermXPos\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"TermYPos\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"AuthPKCS11\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"PKCS11LibFile\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"PKCS11TokenLabel\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"PKCS11CertLabel\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"CopyURLDetection\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HyperlinkUnderline\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HyperlinkUseCtrlClick\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HyperlinkBrowserUseDefault\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HyperlinkBrowser\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HyperlinkRegularExpressionUseDefault\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"HyperlinkRegularExpression\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"rzCommand\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"rzOptions\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"szCommand\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"szOptions\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"zDownloadDir\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SaveWindowPos\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WindowState\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ForegroundOnBell\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"CtrlTabSwitch\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"Comment\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"LogTimeRotation\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"PortKnocking\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WindowClosable\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WindowMinimizable\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WindowMaximizable\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"WindowHasSysMenu\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"DisableBottomButtons\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"BoldAsColour\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"UnderlinedAsColour\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SelectedAsColour\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptFileName\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptMode\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptLineDelay\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptCharDelay\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptCondLine\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptCondUse\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptCRLF\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptEnable\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptExcept\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptTimeout\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptWait\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ScriptHalt\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SSHTunnelInTitle\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"SCPAutoPwd\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"NoFocusReporting\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"LinesAtAScroll\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"DisableAltGr\" ) ;\n\t\t\t\t\tRegDeleteValue( hSubKey, \"ProxySelection\" ) ;\n\t\t\t\t\t//RegDeleteValue( hSubKey, \"\" ) ;\n \t\t\t\t\tRegCloseKey(hSubKey) ;\n\t\t\t\t\t}\n\t\t\t\tfree( buffer );\n\t\t\t\t}\n\t\t\t}\n\t\t} \n \n\tRegCloseKey( hKey ) ;\n\t\n\treturn 1;\n\t}\n\n// Creation du SSH Handler\nvoid CreateSSHHandler() {\n\tchar path[1024], buffer[1024] ;\n\n\tGetModuleFileName( NULL, (LPTSTR)path, 1024 ) ;\n\n\t// Telnet\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"telnet\", \"\", \"URL:Telnet Protocol\") ;\n\tRegTestOrCreateDWORD( HKEY_CLASSES_ROOT, \"telnet\", \"EditFlags\", 2) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"telnet\", \"FriendlyTypeName\", \"@ieframe.dll,-907\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"telnet\", \"URL Protocol\", \"\") ;\n\tRegTestOrCreateDWORD( HKEY_CLASSES_ROOT, \"telnet\", \"BrowserFlags\", 8) ;\n\n\tsprintf(buffer, \"%s,0\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"telnet\\\\DefaultIcon\", \"\", buffer ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"telnet\\\\shell\", \"\", \"\") ;\n\n\tsprintf(buffer, \"\\\"%s\\\" %%1\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"telnet\\\\shell\\\\open\\\\command\", \"\", buffer ) ;\n\n\t// SSH\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"ssh\", \"\", \"URL:SSH Protocol\") ;\n\tRegTestOrCreateDWORD( HKEY_CLASSES_ROOT, \"ssh\", \"EditFlags\", 2) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"ssh\", \"FriendlyTypeName\", \"@ieframe.dll,-907\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"ssh\", \"URL Protocol\", \"\") ;\n\tRegTestOrCreateDWORD( HKEY_CLASSES_ROOT, \"ssh\", \"BrowserFlags\", 8) ;\n\n\tsprintf(buffer, \"%s,0\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"ssh\\\\DefaultIcon\", \"\", buffer ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"ssh\\\\shell\", \"\", \"\") ;\n\n\tsprintf(buffer, \"\\\"%s\\\" %%1\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"ssh\\\\shell\\\\open\\\\command\", \"\", buffer ) ;\n\n\t// PuTTY\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"putty\", \"\", \"URL:PuTTY Protocol\") ;\n\tRegTestOrCreateDWORD( HKEY_CLASSES_ROOT, \"putty\", \"EditFlags\", 2) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"putty\", \"FriendlyTypeName\", \"@ieframe.dll,-907\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"putty\", \"URL Protocol\", \"\") ;\n\tRegTestOrCreateDWORD( HKEY_CLASSES_ROOT, \"putty\", \"BrowserFlags\", 8) ;\n\n\tsprintf(buffer, \"%s,0\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"putty\\\\DefaultIcon\", \"\", buffer ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"putty\\\\shell\", \"\", \"\") ;\n\n\tsprintf(buffer, \"\\\"%s\\\" -load \\\"%%1\\\"\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"putty\\\\shell\\\\open\\\\command\", \"\", buffer ) ;\n}\n\n// Creation de l'association de fichiers *.ktx\nvoid CreateFileAssoc() {\n\tchar path[1024], buffer[1024] ;\n\tchar ext[15] ;\n\tif( strlen( FileExtension ) > 0 ) { strcpy( ext, FileExtension ) ; } else { strcpy( ext, \".ktx\") ; }\n\n\tGetModuleFileName( NULL, (LPTSTR)path, 1024 ) ;\n\n\t// Association des fichers .ktx avec l'application KiTTY\n\t// Création d l'application\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"kitty.connect.1\", \"\", \"KiTTY connection manager\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"kitty.connect.1\", \"FriendlyTypeName\", \"@KiTTY, -120\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"kitty.connect.1\\\\CurVer\", \"\", \"kitty.connect.1\") ;\n\tsprintf(buffer, \"%s\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"kitty.connect.1\\\\DefaultIcon\", \"\", buffer);\n\tsprintf(buffer, \"\\\"%s\\\" -kload \\\"%%1\\\"\", path ) ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, \"kitty.connect.1\\\\shell\\\\open\\\\command\", \"\", buffer) ;\n\t// Création de l'association de fichiers\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, ext, \"\", \"kitty.connect.1\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, ext, \"PerceivedType\", \"Connection\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, ext, \"Content Type\", \"connection/ssh\") ;\n\tRegTestOrCreate( HKEY_CLASSES_ROOT, ext, \"OpenWithProgids\", \"kitty.connect.1\") ;\n}\n\t\n// Check for KiTTY registry key. If not, copy from PuTTY one\nvoid TestRegKeyOrCopyFromPuTTY( HKEY hMainKey, char * KeyName ) { \n\tHKEY hKey ;\n\tif( RegOpenKeyEx( hMainKey, TEXT(KeyName), 0, KEY_READ, &hKey) == ERROR_SUCCESS ) {\n\t\tRegCloseKey( hKey ) ;\n\t} else {\n\t\tRegCreateKey( hMainKey, TEXT(KeyName), &hKey ) ;\n\t\tRegCloseKey( hKey ) ;\n#ifndef FLJ\n\t\tRegCopyTree( hMainKey, \"Software\\\\SimonTatham\\\\PuTTY\", TEXT(KeyName) ) ;\n#endif\n\t}\n}\n\n// Exporte une clé de registre dans un fichier au format PuTTY (  name\\value\\ )\nint ExportSubKeyToFile( HKEY hkey, const char *subkey, const char *keyname, const char *maindir, const char *subdir ) {\n\tchar *fullkey, *fullpath ;\n\tFILE *fp;\n\tHKEY hKey;\n\t\n\tint retCode, i;\n\tunsigned char lpData[1024], unlpData[1024] ;\n\tTCHAR achClass[MAX_PATH] = TEXT(\"\"), achValue[MAX_VALUE_NAME] ; \n\tDWORD cchClassName = MAX_PATH, cSubKeys=0, cbMaxSubKey, cchMaxClass, cValues, cchMaxValue, cbMaxValueData, cbSecurityDescriptor, cchValue = MAX_VALUE_NAME , dwDataSize, lpType;\n\tFILETIME ftLastWriteTime; \n\t\n\tif( subkey!=NULL ) {\n\t\tif( keyname!=NULL ) {\n\t\t\tfullkey = (char*) malloc( strlen(subkey)+strlen(keyname)+2 ) ;\n\t\t\tsprintf( fullkey, \"%s\\\\%s\", subkey, keyname ) ;\n\t\t} else {\n\t\t\tfullkey = (char*) malloc( strlen(subkey)+1 ) ;\n\t\t\tsprintf( fullkey, \"%s\", subkey ) ;\n\t\t}\n\t} else {\n\t\tfullkey = (char*) malloc( strlen(keyname)+1 ) ;\n\t\tsprintf( fullkey, \"%s\", keyname ) ;\n\t}\n\t\n\tif( maindir!=NULL ) {\n\t\tif( subdir!=NULL ) {\n\t\t\tfullpath = (char*) malloc( strlen(maindir)+strlen(subdir)+strlen(keyname)+3 ) ;\n\t\t\tsprintf( fullpath, \"%s\\\\%s\\\\%s\", maindir, subdir, keyname ) ;\n\t\t} else {\n\t\t\tfullpath = (char*) malloc( strlen(maindir)+strlen(keyname)+2 ) ;\n\t\t\tsprintf( fullpath, \"%s\\\\%s\", maindir, keyname ) ;\n\t\t}\n\t} else {\n\t\tfullpath = (char*) malloc( strlen(subdir)+strlen(keyname)+2 ) ;\n\t\tsprintf( fullpath, \"%s\\\\%s\", subdir, keyname ) ;\n\t}\n\tif( (fp=fopen(fullpath,\"wb\"))==NULL ) { free( fullpath ) ; free( fullkey ) ; return 1 ; }\n\tif( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT(fullkey), 0, KEY_READ, &hKey) != ERROR_SUCCESS ) { free( fullpath ) ; free( fullkey ) ; return 2 ; }\n\t\n\tif( RegQueryInfoKey(hKey,achClass,&cchClassName,NULL,&cSubKeys,&cbMaxSubKey\n\t\t,&cchMaxClass,&cValues,&cchMaxValue,&cbMaxValueData,&cbSecurityDescriptor,&ftLastWriteTime) == ERROR_SUCCESS ) {\n\t\tretCode = ERROR_SUCCESS ;\n\t\tif(cValues) for (i=0, retCode=ERROR_SUCCESS; i<cValues; i++) {\n\t\t\tcchValue = MAX_VALUE_NAME; \n\t\t\tachValue[0] = '\\0';\n\t\t\tif( (retCode = RegEnumValue(hKey, i, achValue, &cchValue, NULL, NULL,NULL,NULL) ) == ERROR_SUCCESS ) {\n\t\t\t\tchar *buffer=NULL;\n\t\t\t\tdwDataSize = 1024 ;\n\t\t\t\tRegQueryValueEx( hKey, TEXT( achValue ), 0, &lpType, lpData, &dwDataSize ) ;\n\t\t\t\tswitch ((int)lpType) {\n\t\t\t\t\tcase REG_BINARY:\n\t\t\t\t\t\tbuffer = (char*) malloc( strlen( achValue ) + 50 ) ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\\", achValue ) ;\n\t\t\t\t\t\titoa((u_int)(lpData[0]),buffer+strlen(buffer), 10);\n\t\t\t\t\t\tstrcat(buffer,\".\");\n\t\t\t\t\t\titoa((u_int)(lpData[1]),buffer+strlen(buffer),10);\n\t\t\t\t\t\tstrcat(buffer,\".\");\n\t\t\t\t\t\titoa((u_int)(lpData[2]),buffer+strlen(buffer),10);\n\t\t\t\t\t\tstrcat(buffer,\".\");\n\t\t\t\t\t\titoa((u_int)(lpData[3]),buffer+strlen(buffer),10);\n\t\t\t\t\t\tstrcat( buffer, \"\\\\\" ) ;\n\t\t\t\t\t\tbreak;\n  \n\t\t\t\t\tcase REG_DWORD:\n\t\t\t\t\t\tbuffer = (char*) malloc( strlen( achValue ) + 13 ) ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\\", achValue ) ;\n\t\t\t\t\t\titoa(*(int*)(lpData),buffer+strlen(buffer),10) ;\n\t\t\t\t\t\tstrcat( buffer, \"\\\\\" ) ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase REG_EXPAND_SZ:\n\t\t\t\t\tcase REG_MULTI_SZ:\n\t\t\t\t\tcase REG_SZ:\n\t\t\t\t\t\tmungestr( (const char*)lpData, (char*)unlpData ) ;\n\t\t\t\t\t\tbuffer = (char*) malloc( strlen( achValue ) + strlen( (char*)unlpData ) + 3 ) ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\\\\\", achValue, unlpData ) ;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif( buffer!=NULL ) { fprintf(fp,\"%s\\r\\n\",buffer) ; free( buffer ) ; }\n\t\t\t}\n\t\t}\n\t}\n\tfclose( fp );\n\tfree( fullpath ) ;\n\tfree( fullkey ) ;\n\treturn 0 ;\n}\n\n\t\n/******\nSupprimer toute trace de KiTTY dans le registre.\nEcrire et exécuter un fichier utf-8 .reg contenant les lignes:\n\nWindows Registry Editor Version 5.00\n\n[-HKEY_CURRENT_USER\\Software\\9bis.com\\KiTTY]\n\n[-HKEY_CLASSES_ROOT\\telnet]\n\n[-HKEY_CLASSES_ROOT\\ssh]\n\n[-HKEY_CLASSES_ROOT\\putty]\n\n[-HKEY_CLASSES_ROOT\\kitty.connect.1]\n\n[-HKEY_CLASSES_ROOT\\.ktx]\n\n******/\n"
        },
        {
          "name": "kitty_registry.h",
          "type": "blob",
          "size": 2.50390625,
          "content": "#ifndef KITTY_REGISTRY\n#define KITTY_REGISTRY\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <windows.h>\n\n#ifndef MAX_KEY_LENGTH \n#define MAX_KEY_LENGTH 255\n#endif\n#ifndef MAX_VALUE_NAME\n#define MAX_VALUE_NAME 16383\n#endif\n\n\n\nchar * GetValueData(HKEY hkTopKey, char * lpSubKey, const char * lpValueName, char * rValue) ;\n\n// Extention pour les fichiers de session en mode portable (peut être ktx)\nextern char FileExtension[15] ;\n\n// Teste l'existance d'une clé\nint RegTestKey( HKEY hMainKey, LPCTSTR lpSubKey ) ;\n\n// Retourne le nombre de sous-keys\nint RegCountKey( HKEY hMainKey, LPCTSTR lpSubKey ) ;\n\n// Teste l'existance d'une clé ou bien d'une valeur et la crée sinon\nvoid RegTestOrCreate( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR name, LPCTSTR value ) ;\n\t\n// Test l'existance d'une clé ou bien d'une valeur DWORD et la crée sinon\nvoid RegTestOrCreateDWORD( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR name, DWORD value ) ;\n\n// Initialise toutes les sessions avec une valeur (si oldvalue==NULL) ou uniquement celles qui ont la valeur oldvalue\nvoid RegUpdateAllSessions( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR name, LPCTSTR oldvalue, LPCTSTR value  ) ;\n\n// Exporte toute une cle de registre\nvoid QuerySubKey( HKEY hMainKey, LPCTSTR lpSubKey, FILE * fp_out, char * text  ) ;\n\n// Détruit une valeur de clé de registre \nBOOL RegDelValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValue ) ;\n\n// Detruit une clé de registre et ses sous-clé\nBOOL RegDelTree (HKEY hKeyRoot, LPCTSTR lpSubKey) ;\n\n// Copie une clé de registre vers une autre\nvoid RegCopyTree( HKEY hMainKey, LPCTSTR lpSubKey, LPCTSTR lpDestKey ) ;\n\n// Nettoie la clé de PuTTY pour enlever les clés et valeurs spécifique à KiTTY\nBOOL RegCleanPuTTY( void ) ;\n\n// Creation du SSH Handler\nvoid CreateSSHHandler() ;\n\n// Creation de l'association de fichiers *.ktx\nvoid CreateFileAssoc() ;\n\n// Vérifie l'existance de la clé de KiTTY sinon la copie depuis PuTTY\nvoid TestRegKeyOrCopyFromPuTTY( HKEY hMainKey, char * KeyName ) ;\n\nvoid InitRegistryAllSessions( HKEY hMainKey, LPCTSTR lpSubKey, char * SubKeyName, char * filename, char * text ) ;\n\n// Permet d'initialiser toutes les sessions avec des valeurs contenu dans un fichier kitty.ses.updt\nvoid InitAllSessions( HKEY hMainKey, LPCTSTR lpSubKey, char * SubKeyName, char * filename ) ;\n\n// Exporte une clé de registre dans un fichier au format PuTTY (  name\\value\\ )\nvoid mungestr( const char *in, char *out ) ;\nint ExportSubKeyToFile( HKEY hkey, const char *subkey, const char *keyname, const char *maindir, const char *subdir ) ;\n\n#endif\n"
        },
        {
          "name": "kitty_savedump.c",
          "type": "blob",
          "size": 47.4072265625,
          "content": "\nstatic char SaveKeyPressed[4096] = \"\" ;\n\nvoid WriteCountUpAndPath(void) ;\nvoid SaveDumpPortableConfig( FILE * fp ) ;\nint GetAutoStoreSSHKeyFlag(void) ;\nint GetUserPassSSHNoSave(void) ;\nint GetCryptSaltFlag() ;\n\nextern int is_backend_connected ;\nextern int is_backend_first_connected ;\n\n// String contenant la ligne de commande\nstatic char * CmdLine = NULL ;\nvoid set_cmd_line( const char * st ) {\n\tif( st != NULL ) {\n\t\tif( CmdLine != NULL ) { free( CmdLine ) ; CmdLine = NULL ; }\n\t\tCmdLine = (char*) malloc( strlen(st) + 1 ) ;\n\t\tstrcpy( CmdLine, st ) ;\n\t}\n}\n\n// Buffer contenant du texte a ecrire au besoin dans le fichier kitty.dmp\nstatic char * DebugText = NULL ;\n\nvoid set_debug_text( const char * txt ) {\n\tif( DebugText!=NULL ) { free( DebugText ) ; DebugText = NULL ; }\n\tif( txt != NULL ) {\n\t\tDebugText = (char*) malloc( strlen(txt)+1 ) ;\n\t\tstrcpy( DebugText, txt ) ;\n\t\t}\n\t}\n\nvoid addkeypressed( UINT message, WPARAM wParam, LPARAM lParam, int shift_flag, int control_flag, int alt_flag, int altgr_flag, int win_flag ) {\n\tchar buffer[256], c=' ' ;\n\tint p ;\n\t\n\tif( message==WM_KEYDOWN ) c='v' ; else if( message==WM_KEYUP ) c='^' ;\n\t\n\tif( shift_flag ) shift_flag = 1 ;\n\tif( control_flag ) control_flag = 1 ;\n\tif( alt_flag ) alt_flag = 1 ;\n\tif( altgr_flag ) altgr_flag = 1 ;\n\tif( win_flag ) win_flag = 1 ;\n\t\n\tif( wParam=='\\r' ) \n\t\tsprintf( buffer, \"%d%d%d%d%d %d%c %03d(%02X)/%d (\\\\r)\\n\",shift_flag,control_flag,alt_flag,altgr_flag,win_flag, message,c, wParam, wParam, 0 ) ;\n\telse if( wParam=='\\n' )\n \t\tsprintf( buffer, \"%d%d%d%d%d %d%c %03d(%02X)/%d (\\\\n)\\n\",shift_flag,control_flag,alt_flag,altgr_flag,win_flag, message,c, wParam, wParam, 0 ) ;\n\telse if( (wParam>=32) && (wParam<=111 ) ) \n\t\tsprintf( buffer, \"%d%d%d%d%d %d%c %03d(%02X)/%d (%c)\\n\",shift_flag,control_flag,alt_flag,altgr_flag,win_flag, message,c, wParam, wParam, 0, wParam ) ;\n\telse if( (wParam>=VK_F1 /*70 112*/) && (wParam<=VK_F24 /*87 135*/) )\n\t\tsprintf( buffer, \"%d%d%d%d%d %d%c %03d(%02X)/%d (F%d)\\n\",shift_flag,control_flag,alt_flag,altgr_flag,win_flag, message,c, wParam, wParam, 0, wParam-VK_F1+1 ) ;\n\telse\n\t\tsprintf( buffer, \"%d%d%d%d%d %d%c %03d(%02X)/%d\\n\",shift_flag,control_flag,alt_flag,altgr_flag,win_flag, message,c, wParam, wParam, 0 ) ;\n\t\n\tif( strlen(SaveKeyPressed) > 4000 ) {\n\t\tif( (p=poss(\"\\n\",SaveKeyPressed)) > 0 ) {\n\t\t\tdel( SaveKeyPressed, 1, p );\n\t\t\t}\n\t\t}\n\tstrcat( SaveKeyPressed, buffer ) ;\n\t}\n\n#include <psapi.h>\nvoid PrintProcessNameAndID( DWORD processID, FILE * fp  ) {\n\tTCHAR szProcessName[MAX_PATH] = TEXT(\"<unknown>\");\n\tDWORD SizeOfImage = 0 ;\n\t\n\t// Get a handle to the process.\n\tHANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID );\n\n\t// Get the process name.\n\tif (NULL != hProcess ) {\n\t\tHMODULE hMod;\n\t\tDWORD cbNeeded;\n\t\tMODULEINFO modinfo ;\n\t\tif ( EnumProcessModules( hProcess, &hMod, sizeof(hMod), &cbNeeded) ) { \n\t\t\tGetModuleBaseName( hProcess, hMod, szProcessName, sizeof(szProcessName)/sizeof(TCHAR) ) ; \n\t\t\tGetModuleInformation( hProcess, hMod, &modinfo, sizeof( modinfo ) ) ;\n\t\t\tSizeOfImage = modinfo.SizeOfImage ;\n\t\t\t}\n\t\t}\n\n\t// Print the process name and identifier.\n\tfprintf( fp, TEXT(\"%05u %u \\t%s\\n\"), (unsigned int)processID, (unsigned int)SizeOfImage, szProcessName ) ;\n\tCloseHandle( hProcess );\n}\n\nvoid PrintOSInfo( FILE * fp ) {\n    DWORD dwVersion = 0; \n    DWORD dwMajorVersion = 0;\n    DWORD dwMinorVersion = 0; \n    DWORD dwBuild = 0;\n\n    dwVersion = GetVersion();\n \n    // Get the Windows version.\n\n    dwMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));\n    dwMinorVersion = (DWORD)(HIBYTE(LOWORD(dwVersion)));\n\n    // Get the build number.\n\n    if (dwVersion < 0x80000000)              \n        dwBuild = (DWORD)(HIWORD(dwVersion));\n\n    fprintf( fp, \"Version is %lu.%lu (%lu)\\n\",  dwMajorVersion, dwMinorVersion, dwBuild ) ;\n\n}\n\nvoid PrintSystemInfo( FILE * fp ) {\n\t// https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/ns-sysinfoapi-system_info\n\tSYSTEM_INFO si;\n\tGetSystemInfo( &si );\n\tfprintf( fp, \"wProcessorArchitecture=%lu \",si.wProcessorArchitecture ) ;\n\tswitch(si.wProcessorArchitecture) {\n\t\tcase PROCESSOR_ARCHITECTURE_ARM: fprintf(fp,\"(PROCESSOR_ARCHITECTURE_ARM: ARM)\\n\") ; break ;\n//\t\tcase PROCESSOR_ARCHITECTURE_ARM64: fprintf(fp,\"(PROCESSOR_ARCHITECTURE_ARM64: ARM64)\\n\") ; break ;\n\t\tcase PROCESSOR_ARCHITECTURE_AMD64: fprintf(fp,\"(PROCESSOR_ARCHITECTURE_AMD64: x64 (AMD or Intel))\\n\") ; break ;\n\t\tcase PROCESSOR_ARCHITECTURE_IA64: fprintf(fp,\"(PROCESSOR_ARCHITECTURE_IA64: Intel Itanium-based)\\n\") ; break ;\n\t\tcase PROCESSOR_ARCHITECTURE_INTEL: fprintf(fp,\"(PROCESSOR_ARCHITECTURE_INTEL: x86)\\n\") ; break ;\n\t\tcase PROCESSOR_ARCHITECTURE_UNKNOWN: fprintf(fp,\"(PROCESSOR_ARCHITECTURE_UNKNOWN: unknown)\\n\") ; break ;\n\t}\n\tfprintf( fp, \"wProcessorLevel=%d\\n\",si.wProcessorLevel ) ;\n\tfprintf( fp, \"wProcessorRevision=%d\\n\",si.wProcessorRevision ) ;\n\tfprintf( fp, \"dwNumberOfProcessors=%d\\n\",si.dwNumberOfProcessors ) ;\n}\n\nvoid PrintWindowSettings( FILE * fp ) {\n\tint ret ;\n\tRECT r ;\n\tchar buffer[MAX_VALUE_NAME] ;\n\t\n\tfprintf( fp, \"CmdLine=%s\\n\", CmdLine ) ;\n\t\n\tGetOSInfo( buffer ) ;\n\tfprintf( fp, \"OSVersion=%s\\n\", buffer ) ;\n\tif( IsWow64() ) { fprintf( fp, \"64 bits System\\n\" ) ; } else { fprintf( fp, \"32 bits System\\n\" ) ; }\n\t\n\tret = GetWindowText( MainHwnd, buffer, MAX_VALUE_NAME ) ; buffer[ret]='\\0';\n\tret = GetWindowTextLength( MainHwnd ) ;\n\tfprintf( fp, \"Title (length)=%s (%d)\\n\", buffer, ret ) ;\n\tif( GetWindowRect( MainHwnd, &r ) ) {\n\t\tfprintf( fp, \"WindowRect.left=%ld\\n\", r.left ) ;\n\t\tfprintf( fp, \"WindowRect.right=%ld\\n\", r.right ) ;\n\t\tfprintf( fp, \"WindowRect.top=%ld\\n\", r.top ) ;\n\t\tfprintf( fp, \"WindowRect.bottom=%ld\\n\", r.bottom ) ;\n\t\t}\n\tif( GetClientRect( MainHwnd, &r ) ) {\n\t\tfprintf( fp, \"ClientRect.left=%ld\\n\", r.left ) ;\n\t\tfprintf( fp, \"ClientRect.right=%ld\\n\", r.right ) ;\n\t\tfprintf( fp, \"ClientRect.top=%ld\\n\", r.top ) ;\n\t\tfprintf( fp, \"ClientRect.bottom=%ld\\n\", r.bottom ) ;\n\t\t}\n\t\n\tret = GetWindowModuleFileName( MainHwnd, buffer, MAX_VALUE_NAME ) ; buffer[ret]='\\0';\n\tfprintf( fp, \"WindowModuleFileName=%s\\n\", buffer ) ;\n\t\n\tWINDOWINFO wi ;\n\twi.cbSize = sizeof( WINDOWINFO ) ;\n\tif( GetWindowInfo( MainHwnd, &wi ) ) {\n\t\tfprintf( fp, \"WindowInfo.cbSize=%lu\\n\", wi.cbSize ) ;\n\t\tfprintf( fp, \"WindowInfo.rcWindow.left=%ld\\n\", wi.rcWindow.left ) ;\n\t\tfprintf( fp, \"WindowInfo.rcWindow.right=%ld\\n\", wi.rcWindow.right ) ;\n\t\tfprintf( fp, \"WindowInfo.rcWindow.top=%ld\\n\", wi.rcWindow.top ) ;\n\t\tfprintf( fp, \"WindowInfo.rcWindow.bottom=%ld\\n\", wi.rcWindow.bottom ) ;\n\t\tfprintf( fp, \"WindowInfo.rcClient.left=%ld\\n\", wi.rcWindow.left ) ;\n\t\tfprintf( fp, \"WindowInfo.rcClient.right=%ld\\n\", wi.rcWindow.right ) ;\n\t\tfprintf( fp, \"WindowInfo.rcClient.top=%ld\\n\", wi.rcWindow.top ) ;\n\t\tfprintf( fp, \"WindowInfo.rcClient.bottom=%ld\\n\", wi.rcWindow.bottom ) ;\n\t\tfprintf( fp, \"WindowInfo.dwStyle=%lu\\n\", wi.dwStyle ) ;\n\t\tfprintf( fp, \"WindowInfo.dwExStyle=%lu\\n\", wi.dwExStyle ) ;\n\t\tfprintf( fp, \"WindowInfo.dwWindowStatus=%lu\\n\", wi.dwWindowStatus ) ;\n\t\tfprintf( fp, \"WindowInfo.cxWindowBorders=%u\\n\", wi.cxWindowBorders ) ;\n\t\tfprintf( fp, \"WindowInfo.cyWindowBorders=%u\\n\", wi.cyWindowBorders ) ;\n\t\tfprintf( fp, \"WindowInfo.wCreatorVersion=%d\\n\", wi.wCreatorVersion ) ;\n\t\t}\n\t\n\tWINDOWPLACEMENT wp;\n\twp.length=sizeof(WINDOWPLACEMENT) ;\n\tif( GetWindowPlacement( MainHwnd, &wp ) ) {\n\t\tfprintf( fp, \"WindowPlacement.length=%u\\n\", wp.length ) ;\n\t\tfprintf( fp, \"WindowPlacement.flags=%u\\n\", wp.flags ) ;\n\t\tfprintf( fp, \"WindowPlacement.showCmd=%u\\n\", wp.showCmd ) ;\n\t\tfprintf( fp, \"WindowPlacement.ptMinPosition.x=%ld\\n\", wp.ptMinPosition.x ) ;\n\t\tfprintf( fp, \"WindowPlacement.ptMinPosition.y=%ld\\n\", wp.ptMinPosition.y ) ;\n\t\tfprintf( fp, \"WindowPlacement.ptMaxPosition.x=%ld\\n\", wp.ptMaxPosition.x ) ;\n\t\tfprintf( fp, \"WindowPlacement.ptMaxPosition.y=%ld\\n\", wp.ptMaxPosition.y ) ;\n\t\tfprintf( fp, \"WindowPlacement.rcNormalPosition.left=%ld\\n\", wp.rcNormalPosition.left ) ;\n\t\tfprintf( fp, \"WindowPlacement.rcNormalPosition.right=%ld\\n\", wp.rcNormalPosition.right ) ;\n\t\tfprintf( fp, \"WindowPlacement.rcNormalPosition.top=%ld\\n\", wp.rcNormalPosition.top ) ;\n\t\tfprintf( fp, \"WindowPlacement.rcNormalPosition.bottom=%ld\\n\", wp.rcNormalPosition.bottom ) ;\n\t\t}\n\t\n\tfprintf( fp, \"IsIconic=%d\\n\", IsIconic( MainHwnd ) ) ;\n\tfprintf( fp, \"IsWindow=%d\\n\", IsWindow( MainHwnd ) ) ;\n\tfprintf( fp, \"IsWindowUnicode=%d\\n\", IsWindowUnicode( MainHwnd ) ) ;\n\tfprintf( fp, \"IsWindowVisible=%d\\n\", IsWindowVisible( MainHwnd ) ) ;\n\tfprintf( fp, \"IsZoomed=%d\\n\", IsZoomed( MainHwnd ) ) ;\n\n\tfprintf( fp, \"ScaleX=%d\\n\", GetDeviceCaps(GetDC(MainHwnd),LOGPIXELSX) ) ;\n\tfprintf( fp, \"ScaleY=%d\\n\", GetDeviceCaps(GetDC(MainHwnd),LOGPIXELSY) ) ;\n\t}\n\nDWORD PrintAllProcess( FILE * fp ) {\n\tDWORD aProcesses[1024], cbNeeded, cProcesses;\n\tunsigned int i;\n\n\tif ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) ) return 0 ;\n\n\t// Calculate how many process identifiers were returned.\n\tcProcesses = cbNeeded / sizeof(DWORD);\n\n\t// Print the name and process identifier for each process.\n\tprintf( \"ID    MEM   \\tMODULE\\n\" );\n\tif( cProcesses > 0 )\n\tfor ( i = 0; i < cProcesses; i++ )\n\t\tif( aProcesses[i] != 0 )\n\t\t\tPrintProcessNameAndID( aProcesses[i], fp ) ;\n\treturn cProcesses ;\n\t}\n\nvoid SaveDumpListFile( FILE * fp, const char * directory ) {\n\tDIR *dir ;\n\tstruct dirent *de ;\n\tchar buffer[MAX_VALUE_NAME] ;\n\t\n\t/* fprintf( fp, \"\t===> Listing directory %s\\n\", directory ) ; */\n\tif( ( dir=opendir( directory ) ) != NULL ) {\n\t\twhile( ( de=readdir( dir ) ) != NULL ) {\n\t\t\tif( strcmp(de->d_name,\".\")&&strcmp(de->d_name,\"..\") ) {\n\t\t\t\tsprintf( buffer, \"%s\\\\%s\", directory, de->d_name ) ;\n\t\t\t\tif( GetFileAttributes( buffer ) & FILE_ATTRIBUTE_DIRECTORY ) {  \n\t\t\t\t\tstrcat( buffer, \"\\\\\" ) ; \n\t\t\t\t\tfprintf( fp, \"%s\\n\", buffer ) ;\n\t\t\t\t\tSaveDumpListFile( fp, buffer ) ;\n\t\t\t\t}\n\t\t\t\telse { fprintf( fp, \"%s\\n\", buffer ) ; }\n\t\t\t}\n\t\t}\n\t\tclosedir( dir ) ;\n\t}\n}\n\nvoid SaveDumpListConf( FILE *fp, const char *directory ) {\n\tchar buffer[4096], fullpath[MAX_VALUE_NAME] ;\n\tFILE *fp2 ;\n\tDIR *dir ;\n\tstruct dirent *de ;\n\tif( ( dir=opendir( directory ) ) != NULL ) {\n\t\twhile( ( de=readdir( dir ) ) != NULL ) {\n\t\t\tif( strcmp(de->d_name,\".\")&&strcmp(de->d_name,\"..\") ) {\n\t\t\t\tsprintf( fullpath, \"%s\\\\%s\", directory, de->d_name ) ;\n\t\t\t\tif( GetFileAttributes( fullpath ) & FILE_ATTRIBUTE_DIRECTORY )\n\t\t\t\t\tSaveDumpListConf( fp, fullpath ) ;\n\t\t\t\telse {\n\t\t\t\t\tfprintf( fp, \"[%s]\\n\", fullpath ) ;\n\t\t\t\t\tif( ( fp2 = fopen( fullpath, \"r\" ) ) != NULL ) {\n\t\t\t\t\t\twhile( fgets( buffer, 4095, fp2 ) != NULL ) fputs( buffer, fp ) ;\n\t\t\t\t\t\tfclose( fp2 ) ;\n\t\t\t\t\t\t}\n\t\t\t\t\tfprintf( fp, \"\\n\\n\" ) ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tclosedir( dir ) ;\n\t\t}\n\t}\n\nTerminal* GetTerminal() ;\nvoid kitty_term_copyall(Terminal *term) ;\nvoid SaveDumpClipBoard( FILE *fp ) {\n\tchar *pst = NULL ;\n\tif( GetTerminal()==NULL ) return ;\n\tkitty_term_copyall(GetTerminal()) ;\n\tif( OpenClipboard(NULL) ) {\n\t\tHGLOBAL hglb ;\n\t\tif( (hglb = GetClipboardData( CF_TEXT ) ) != NULL ) {\n\t\t\tif( ( pst = GlobalLock( hglb ) ) != NULL ) {\n\t\t\t\t//fputs( pst, fp ) ;\n\t\t\t\tfwrite( pst, 1, strlen(pst), fp ) ;\n\t\t\t\tGlobalUnlock( hglb ) ;\n\t\t\t\t}\n\t\t\t}\n\t\tCloseClipboard();\n\t\t}\n\t}\n\n//#include <unistd.h>\nvoid SaveDumpEnvironment( FILE *fp ) {\n\tint i = 0 ;\n\twhile( environ[i] ) {\n\t\tfprintf( fp, \"%s\\n\", environ[i] ) ;\n\t\ti++;\n\t\t}\n\t}\n\nvoid SaveDumpConfig( FILE *fp, Conf * conf ) {\n\tchar *buf=NULL ;\n\tCountUp();\n\tfprintf( fp, \"MASTER_PASSWORD=%s\\n\", MASTER_PASSWORD ) ;\n\tfprintf( fp, \"[[PuTTY structure configuration]]\\n\" ) ;\n\n\t/* Basic options */\n\tfprintf( fp, \"host=%s\\n\", \t\t\tconf_get_str(conf,CONF_host) ) ;\n\tfprintf( fp, \"host_alt=%s\\n\", \t\t\tconf_get_str(conf,CONF_host_alt) ) ;\n\tfprintf( fp, \"port=%d\\n\", \t\t\tconf_get_int(conf,CONF_port) ) ;\n\tfprintf( fp, \"protocol=%d\\n\", \t\t\tconf_get_int(conf,CONF_protocol) ) ;\n\tfprintf( fp, \"addressfamily=%d\\n\",\t\tconf_get_int(conf,CONF_addressfamily) ) ;\n\tfprintf( fp, \"close_on_exit=%d\\n\",\t\tconf_get_int(conf,CONF_close_on_exit) ) ;\n\tfprintf( fp, \"warn_on_close=%d\\n\",\t\tconf_get_bool(conf,CONF_warn_on_close) ) ;\n\tfprintf( fp, \"ping_interval=%d\\n\", \t\tconf_get_int(conf,CONF_ping_interval) ) ;\n\tfprintf( fp, \"tcp_nodelay=%d\\n\", \t\tconf_get_bool(conf,CONF_tcp_nodelay) ) ;\n\tfprintf( fp, \"tcp_keepalives=%d\\n\", \t\tconf_get_bool(conf,CONF_tcp_keepalives) ) ;\n\tfprintf( fp, \"loghost=%s\\n\", \t\t\tconf_get_str(conf,CONF_loghost) ) ;\n\t\n\t/* Proxy options */\n\tfprintf( fp, \"proxy_exclude_list=%s\\n\",\t\tconf_get_str(conf,CONF_proxy_exclude_list) ) ;\n\tfprintf( fp, \"proxy_dns=%d\\n\", \t\t\tconf_get_int(conf,CONF_proxy_dns) ) ;\n\tfprintf( fp, \"even_proxy_localhost=%d\\n\",\tconf_get_bool(conf,CONF_even_proxy_localhost) ) ;\n\tfprintf( fp, \"proxy_type=%d\\n\",\t\t\tconf_get_int(conf,CONF_proxy_type) ) ;\n\tfprintf( fp, \"proxy_host=%s\\n\", \t\tconf_get_str(conf,CONF_proxy_host) ) ;\n\tfprintf( fp, \"proxy_port=%d\\n\", \t\tconf_get_int(conf,CONF_proxy_port) ) ;\n\tfprintf( fp, \"proxy_username=%s\\n\", \t\tconf_get_str(conf,CONF_proxy_username) ) ;\n\tfprintf( fp, \"proxy_password=%s\\n\", \t\tconf_get_str(conf,CONF_proxy_password) ) ;\n\tfprintf( fp, \"proxy_telnet_command=%s\\n\", \tconf_get_str(conf,CONF_proxy_telnet_command) ) ;\n\tfprintf( fp, \"proxy_log_to_term=%d\\n\", \t\tconf_get_int(conf,CONF_proxy_log_to_term) ) ;\n\n\t/* SSH options */\n\tfprintf( fp, \"remote_cmd=%s\\n\",\t\t\tconf_get_str(conf,CONF_remote_cmd) ) ;\n\tfprintf( fp, \"remote_cmd2=%s\\n\",\t\tconf_get_str(conf,CONF_remote_cmd2) ) ;\n\tfprintf( fp, \"nopty=%d\\n\",\t\t\tconf_get_bool(conf,CONF_nopty) ) ;\n\tfprintf( fp, \"compression=%d\\n\",\t\tconf_get_bool(conf,CONF_compression) ) ;\n\t//fprintf( fp, \"ssh_kexlist=%d\\n\",\t\tconf_get_int(conf,CONF_ssh_kexlist) ) ;\n\t//fprintf( fp, \"ssh_hklist=%d\\n\",\t\t\tconf_get_int(conf,CONF_ssh_hklist) ) ;\n\tfprintf( fp, \"ssh_prefer_known_hostkeys=%d\\n\", \t\t\tconf_get_bool(conf,CONF_ssh_prefer_known_hostkeys) ) ;\n    \tfprintf( fp, \"ssh_rekey_time=%d\\n\",\t\tconf_get_int(conf,CONF_ssh_rekey_time) ) ;\n\tfprintf( fp, \"ssh_rekey_data=%s\\n\",\t\tconf_get_str(conf,CONF_ssh_rekey_data) ) ;\n\tfprintf( fp, \"tryagent=%d\\n\",\t\t\tconf_get_bool(conf,CONF_tryagent) ) ;\n\tfprintf( fp, \"agentfwd=%d\\n\",\t\t\tconf_get_bool(conf,CONF_agentfwd) ) ;\n\tfprintf( fp, \"change_username=%d\\n\",\t\tconf_get_bool(conf,CONF_change_username) ) ;\n\t//fprintf( fp, \"ssh_cipherlist=%d\\n\",\t\tconf_get_int(conf,CONF_ssh_cipherlist) ) ;\n\tfprintf( fp, \"keyfile=%s\\n\",\t\t\tconf_get_filename(conf,CONF_keyfile)->path ) ;\n  \tfprintf( fp, \"sshprot=%d\\n\",\t\t\tconf_get_int(conf,CONF_sshprot) ) ;\n\tfprintf( fp, \"ssh2_des_cbc=%d\\n\",\t\tconf_get_bool(conf,CONF_ssh2_des_cbc) ) ;\n\tfprintf( fp, \"ssh_no_userauth=%d\\n\",\t\tconf_get_bool(conf,CONF_ssh_no_userauth) ) ;\n\tfprintf( fp, \"ssh_no_trivial_userauth=%d\\n\",\tconf_get_bool(conf,CONF_ssh_no_trivial_userauth) ) ;\n\tfprintf( fp, \"ssh_show_banner=%d\\n\",\t\tconf_get_bool(conf,CONF_ssh_show_banner) ) ;\n\tfprintf( fp, \"try_tis_auth=%d\\n\",\t\tconf_get_bool(conf,CONF_try_tis_auth) ) ;\n\tfprintf( fp, \"try_ki_auth=%d\\n\",\t\tconf_get_bool(conf,CONF_try_ki_auth) ) ;\n\tfprintf( fp, \"try_gssapi_auth=%d\\n\",\t\tconf_get_bool(conf,CONF_try_gssapi_auth) ) ;\n\tfprintf( fp, \"try_gssapi_kex=%d\\n\",\t\tconf_get_bool(conf,CONF_try_gssapi_kex) ) ;\n\tfprintf( fp, \"gssapifwd=%d\\n\",\t\t\tconf_get_bool(conf,CONF_gssapifwd) ) ;\n\tfprintf( fp, \"gssapirekey=%d\\n\",\t\tconf_get_int(conf,CONF_gssapirekey) ) ;\n\t//fprintf( fp, \"ssh_gsslist=%d\\n\",\t\tconf_get_int(conf,CONF_ssh_gsslist) ) ;\n\tfprintf( fp, \"ssh_gss_custom=%s\\n\",\t\tconf_get_filename(conf,CONF_ssh_gss_custom)->path ) ;\n\tfprintf( fp, \"ssh_subsys=%d\\n\",\t\t\tconf_get_bool(conf,CONF_ssh_subsys) ) ;\n\t//fprintf( fp, \"ssh_subsys2=%d\\n\",\t\tconf_get_bool(conf,CONF_ssh_subsys2) ) ; \t// N'est pas lu dans settings.c\n\tfprintf( fp, \"ssh_no_shell=%d\\n\",\t\tconf_get_bool(conf,CONF_ssh_no_shell) ) ;\n\t//fprintf( fp, \"ssh_nc_host=%s\\n\",\t\tconf_get_str(conf,CONF_ssh_nc_host) ) ;\t\t// N'est pas lu dans settings.c\n\t//fprintf( fp, \"ssh_nc_port=%d\\n\",\t\tconf_get_int(conf,CONF_ssh_nc_port) ) ;\t\t// N'est pas lu dans settings.c\n\n\t/* Telnet options */\n\tfprintf( fp, \"termtype=%s\\n\",\t\t\tconf_get_str(conf,CONF_termtype ) ) ;\n\tfprintf( fp, \"termspeed=%s\\n\",\t\t\tconf_get_str(conf,CONF_termspeed ) ) ;\n\t//fprintf( fp, \"ttymodes=%s\\n\",\t\t\tconf_get_str(conf,CONF_ttymodes ) ) ;\n\t//fprintf( fp, \"environmt=%s\\n\",\t\t\tconf_get_str(conf,CONF_environmt ) ) ;\n\tfprintf( fp, \"username=%s\\n\",\t\t\tconf_get_str(conf,CONF_username ) ) ;\n\tfprintf( fp, \"username_from_env=%d\\n\",\t\tconf_get_bool(conf,CONF_username_from_env) ) ;\n\tfprintf( fp, \"localusername=%s\\n\",\t\tconf_get_str(conf,CONF_localusername ) ) ;\n\tfprintf( fp, \"rfc_environ=%d\\n\",\t\tconf_get_bool(conf,CONF_rfc_environ) ) ;\n\tfprintf( fp, \"passive_telnet=%d\\n\",\t\tconf_get_bool(conf,CONF_passive_telnet) ) ;\n\n\t/* Serial port options */\n\tfprintf( fp, \"serline=%s\\n\", \t\t\tconf_get_str(conf,CONF_serline) ) ;\n\tfprintf( fp, \"serspeed=%d\\n\",\t\t\tconf_get_int(conf,CONF_serspeed) ) ;\n\tfprintf( fp, \"serdatabits=%d\\n\",\t\tconf_get_int(conf,CONF_serdatabits) ) ;\n\tfprintf( fp, \"serstopbits=%d\\n\",\t\tconf_get_int(conf,CONF_serstopbits) ) ;\n\tfprintf( fp, \"serparity=%d\\n\",\t\t\tconf_get_int(conf,CONF_serparity) ) ;\n\tfprintf( fp, \"serflow=%d\\n\",\t\t\tconf_get_int(conf,CONF_serflow) ) ;\n\n\t/* Keyboard options */\n\tfprintf( fp, \"bksp_is_delete=%d\\n\", \t\tconf_get_bool(conf,CONF_bksp_is_delete) ) ;\n\tfprintf( fp, \"enter_sends_crlf=%d\\n\", \t\tconf_get_int(conf,CONF_enter_sends_crlf) ) ;\n\tfprintf( fp, \"rxvt_homeend=%d\\n\", \t\tconf_get_int(conf,CONF_rxvt_homeend) ) ;\n\tfprintf( fp, \"funky_type=%d\\n\", \t\tconf_get_int(conf,CONF_funky_type) ) ;\n\tfprintf( fp, \"no_applic_c=%d\\n\", \t\tconf_get_bool(conf,CONF_no_applic_c) ) ;\n\tfprintf( fp, \"no_applic_k=%d\\n\", \t\tconf_get_bool(conf,CONF_no_applic_k) ) ;\n\tfprintf( fp, \"no_mouse_rep=%d\\n\", \t\tconf_get_bool(conf,CONF_no_mouse_rep) ) ;\n\tfprintf( fp, \"no_remote_resize=%d\\n\", \t\tconf_get_bool(conf,CONF_no_remote_resize) ) ;\n\tfprintf( fp, \"no_alt_screen=%d\\n\", \t\tconf_get_bool(conf,CONF_no_alt_screen) ) ;\n\tfprintf( fp, \"no_remote_wintitle=%d\\n\", \tconf_get_bool(conf,CONF_no_remote_wintitle) ) ;\n\tfprintf( fp, \"no_remote_clearscroll=%d\\n\", \tconf_get_bool(conf,CONF_no_remote_clearscroll) ) ;\n\tfprintf( fp, \"no_dbackspace=%d\\n\", \t\tconf_get_bool(conf,CONF_no_dbackspace) ) ;\n\tfprintf( fp, \"no_remote_charset=%d\\n\", \t\tconf_get_bool(conf,CONF_no_remote_charset) ) ;\n\tfprintf( fp, \"remote_qtitle_action=%d\\n\", \tconf_get_int(conf,CONF_remote_qtitle_action) ) ;\n\tfprintf( fp, \"app_cursor=%d\\n\", \t\tconf_get_bool(conf,CONF_app_cursor) ) ;\n\tfprintf( fp, \"app_keypad=%d\\n\", \t\tconf_get_bool(conf,CONF_app_keypad) ) ;\n\tfprintf( fp, \"nethack_keypad=%d\\n\", \t\tconf_get_bool(conf,CONF_nethack_keypad) ) ;\n\tfprintf( fp, \"telnet_keyboard=%d\\n\", \t\tconf_get_bool(conf,CONF_telnet_keyboard) ) ;\n\tfprintf( fp, \"telnet_newline=%d\\n\", \t\tconf_get_bool(conf,CONF_telnet_newline) ) ;\n\tfprintf( fp, \"alt_f4=%d\\n\", \t\t\tconf_get_bool(conf,CONF_alt_f4) ) ;\n\tfprintf( fp, \"alt_space=%d\\n\", \t\t\tconf_get_bool(conf,CONF_alt_space) ) ;\n\tfprintf( fp, \"alt_only=%d\\n\", \t\t\tconf_get_bool(conf,CONF_alt_only) ) ;\n\tfprintf( fp, \"localecho=%d\\n\", \t\t\tconf_get_int(conf,CONF_localecho) ) ;\n\tfprintf( fp, \"localedit=%d\\n\", \t\t\tconf_get_int(conf,CONF_localedit) ) ;\n\t\n\tfprintf( fp, \"alwaysontop=%d\\n\", \t\tconf_get_bool(conf,CONF_alwaysontop) ) ;\n\tfprintf( fp, \"fullscreenonaltenter=%d\\n\", \tconf_get_bool(conf,CONF_fullscreenonaltenter) ) ;\n\tfprintf( fp, \"scroll_on_key=%d\\n\", \t\tconf_get_bool(conf,CONF_scroll_on_key) ) ;\n\tfprintf( fp, \"scroll_on_disp=%d\\n\", \t\tconf_get_bool(conf,CONF_scroll_on_disp) ) ;\n\tfprintf( fp, \"erase_to_scrollback=%d\\n\",\tconf_get_bool(conf,CONF_erase_to_scrollback) ) ;\n\tfprintf( fp, \"compose_key=%d\\n\", \t\tconf_get_bool(conf,CONF_compose_key) ) ;\n\tfprintf( fp, \"ctrlaltkeys=%d\\n\", \t\tconf_get_bool(conf,CONF_ctrlaltkeys) ) ;\n\t//fprintf( fp, \"osx_option_meta=%d\\n\", \t\tconf_get_bool(conf,CONF_osx_option_meta) ) ; \t// N'est pas lu dans settings.c\n\t//fprintf( fp, \"osx_command_meta=%d\\n\", \t\tconf_get_bool(conf,CONF_osx_command_meta) ) ; \t// N'est pas lu dans settings.c\n\tfprintf( fp, \"wintitle=%s\\n\",\t\t\tconf_get_str(conf,CONF_wintitle) ) ;\n\n\t/* Terminal options */\n\tfprintf( fp, \"savelines=%d\\n\", \t\t\tconf_get_int(conf,CONF_savelines) ) ;\n\tfprintf( fp, \"dec_om=%d\\n\", \t\t\tconf_get_bool(conf,CONF_dec_om) ) ;\n\tfprintf( fp, \"wrap_mode=%d\\n\", \t\t\tconf_get_bool(conf,CONF_wrap_mode) ) ;\n\tfprintf( fp, \"lfhascr=%d\\n\", \t\t\tconf_get_bool(conf,CONF_lfhascr) ) ;\n\tfprintf( fp, \"cursor_type=%d\\n\", \t\tconf_get_int(conf,CONF_cursor_type) ) ;\n\tfprintf( fp, \"blink_cur=%d\\n\", \t\t\tconf_get_bool(conf,CONF_blink_cur) ) ;\n\tfprintf( fp, \"beep=%d\\n\", \t\t\tconf_get_int(conf,CONF_beep) ) ;\n\tfprintf( fp, \"beep_ind=%d\\n\", \t\t\tconf_get_int(conf,CONF_beep_ind) ) ;\n\tfprintf( fp, \"bellovl=%d\\n\", \t\t\tconf_get_bool(conf,CONF_bellovl) ) ;\n\tfprintf( fp, \"bellovl_n=%d\\n\", \t\t\tconf_get_int(conf,CONF_bellovl_n) ) ;\n\tfprintf( fp, \"bellovl_t=%d\\n\",\t\t\tconf_get_int(conf,CONF_bellovl_t) ) ;\n\tfprintf( fp, \"bellovl_s=%d\\n\",\t\t\tconf_get_int(conf,CONF_bellovl_s) ) ;\n\tfprintf( fp, \"bell_wavefile=%s\\n\",\t\tconf_get_filename(conf,CONF_bell_wavefile)->path ) ;\n\tfprintf( fp, \"scrollbar=%d\\n\",\t\t\tconf_get_bool(conf,CONF_scrollbar) ) ;\n\tfprintf( fp, \"scrollbar_in_fullscreen=%d\\n\",\tconf_get_bool(conf,CONF_scrollbar_in_fullscreen) ) ;\n\tfprintf( fp, \"resize_action=%d\\n\",\t\tconf_get_int(conf,CONF_resize_action) ) ;\n\tfprintf( fp, \"bce=%d\\n\",\t\t\tconf_get_bool(conf,CONF_bce) ) ;\n\tfprintf( fp, \"blinktext=%d\\n\",\t\t\tconf_get_bool(conf,CONF_blinktext) ) ;\n\tfprintf( fp, \"win_name_always=%d\\n\",\t\tconf_get_bool(conf,CONF_win_name_always) ) ;\n\tfprintf( fp, \"width=%d\\n\",\t\t\tconf_get_int(conf,CONF_width) ) ;\n\tfprintf( fp, \"height=%d\\n\",\t\t\tconf_get_int(conf,CONF_height) ) ;\n\tfprintf( fp, \"font_quality=%d\\n\",\t\tconf_get_int(conf,CONF_font_quality) ) ;\n\tfprintf( fp, \"logfilename=%s\\n\",\t\tconf_get_filename(conf,CONF_logfilename)->path ) ;\n\tfprintf( fp, \"logtype=%d\\n\",\t\t\tconf_get_int(conf,CONF_logtype) ) ;\n\tfprintf( fp, \"logxfovr=%d\\n\",\t\t\tconf_get_int(conf,CONF_logxfovr) ) ;\n\tfprintf( fp, \"logflush=%d\\n\",\t\t\tconf_get_bool(conf,CONF_logflush) ) ;\n\tfprintf( fp, \"logheader=%d\\n\",\t\t\tconf_get_bool(conf,CONF_logheader) ) ;\n\tfprintf( fp, \"logomitpass=%d\\n\",\t\tconf_get_bool(conf,CONF_logomitpass) ) ;\n\tfprintf( fp, \"logomitdata=%d\\n\",\t\tconf_get_bool(conf,CONF_logomitdata) ) ;\n\tfprintf( fp, \"hide_mouseptr=%d\\n\",\t\tconf_get_bool(conf,CONF_hide_mouseptr) ) ;\n\tfprintf( fp, \"sunken_edge=%d\\n\",\t\tconf_get_bool(conf,CONF_sunken_edge) ) ;\n\tfprintf( fp, \"window_border=%d\\n\",\t\tconf_get_int(conf,CONF_window_border) ) ;\n\tfprintf( fp, \"answerback=%s\\n\",\t\t\tconf_get_str(conf,CONF_answerback) ) ;\n\tfprintf( fp, \"printer=%s\\n\",\t\t\tconf_get_str(conf,CONF_printer) ) ;\n\tfprintf( fp, \"no_arabicshaping=%d\\n\",\t\tconf_get_bool(conf,CONF_no_arabicshaping) ) ;\n\tfprintf( fp, \"no_bidi=%d\\n\",\t\t\tconf_get_bool(conf,CONF_no_bidi) ) ;\n\t\t\n\t/* Colour options */\n\tfprintf( fp, \"ansi_colour=%d\\n\",\t\tconf_get_bool(conf,CONF_ansi_colour) ) ;\n\tfprintf( fp, \"xterm_256_colour=%d\\n\",\t\tconf_get_bool(conf,CONF_xterm_256_colour) ) ;\n\tfprintf( fp, \"true_colour=%d\\n\",\t\tconf_get_bool(conf,CONF_true_colour) ) ;\n\tfprintf( fp, \"system_colour=%d\\n\",\t\tconf_get_bool(conf,CONF_system_colour) ) ;\n\tfprintf( fp, \"try_palette%d\\n\",\t\t\tconf_get_bool(conf,CONF_try_palette) ) ;\n\tfprintf( fp, \"bold_style=%d\\n\",\t\t\tconf_get_int(conf,CONF_bold_style) ) ;\n\n\t/* Selection options */\n\tfprintf( fp, \"mouse_is_xterm=%d\\n\",\t\tconf_get_int(conf,CONF_mouse_is_xterm) ) ;\n\tfprintf( fp, \"rect_select=%d\\n\",\t\tconf_get_bool(conf,CONF_rect_select) ) ;\n\tfprintf( fp, \"rawcnp=%d\\n\",\t\t\tconf_get_bool(conf,CONF_rawcnp) ) ;\n\tfprintf( fp, \"utf8linedraw=%d\\n\",\t\tconf_get_bool(conf,CONF_utf8linedraw) ) ;\n\tfprintf( fp, \"rtf_paste=%d\\n\",\t\t\tconf_get_bool(conf,CONF_rtf_paste) ) ;\n\tfprintf( fp, \"mouse_override=%d\\n\",\t\tconf_get_bool(conf,CONF_mouse_override) ) ;\n\t//fprintf( fp, \"wordness=%d\\n\",\t\t\tconf_get_int(conf,CONF_wordness) ) ;\n\tfprintf( fp, \"mouseautocopy=%d\\n\",\t\tconf_get_bool(conf,CONF_mouseautocopy) ) ;\n\tfprintf( fp, \"mousepaste=%d\\n\",\t\t\tconf_get_int(conf,CONF_mousepaste) ) ;\n\tfprintf( fp, \"ctrlshiftins=%d\\n\",\t\tconf_get_int(conf,CONF_ctrlshiftins) ) ;\n\tfprintf( fp, \"ctrlshiftcv=%d\\n\",\t\tconf_get_int(conf,CONF_ctrlshiftcv) ) ;\n\tfprintf( fp, \"mousepaste_custom=%s\\n\",\t\tconf_get_str(conf,CONF_mousepaste_custom) ) ;\n\tfprintf( fp, \"ctrlshiftins_custom=%s\\n\",\tconf_get_str(conf,CONF_ctrlshiftins_custom) ) ;\n\tfprintf( fp, \"ctrlshiftcv_custom=%s\\n\",\t\tconf_get_str(conf,CONF_ctrlshiftcv_custom) ) ;\n  \n\t/* translations */\n\tfprintf( fp, \"vtmode=%d\\n\",\t\t\tconf_get_int(conf,CONF_vtmode) ) ;\n\tfprintf( fp, \"line_codepage=%s\\n\",\t\tconf_get_str(conf,CONF_line_codepage) ) ;\n\tfprintf( fp, \"cjk_ambig_wide=%d\\n\",\t\tconf_get_bool(conf,CONF_cjk_ambig_wide) ) ;\n\tfprintf( fp, \"utf8_override=%d\\n\",\t\tconf_get_bool(conf,CONF_utf8_override) ) ;\n\tfprintf( fp, \"xlat_capslockcyr=%d\\n\",\t\tconf_get_bool(conf,CONF_xlat_capslockcyr) ) ;\n\n\t/* X11 forwarding */\n\tfprintf( fp, \"x11_forward=%d\\n\",\t\tconf_get_bool(conf,CONF_x11_forward) ) ;\n\tfprintf( fp, \"x11_display=%s\\n\",\t\tconf_get_str(conf,CONF_x11_display) ) ;\n\tfprintf( fp, \"x11_auth=%d\\n\",\t\t\tconf_get_int(conf,CONF_x11_auth) ) ;\n\tfprintf( fp, \"xauthfile=%s\\n\",\t\t\tconf_get_filename(conf,CONF_xauthfile)->path ) ;\n\n\t/* port forwarding */\n\tfprintf( fp, \"lport_acceptall=%d\\n\",\t\tconf_get_bool(conf,CONF_lport_acceptall) ) ;\n\tfprintf( fp, \"rport_acceptall=%d\\n\",\t\tconf_get_bool(conf,CONF_rport_acceptall) ) ;\n\tfprintf( fp, \"portfwd=\\n\") ;\n\tchar *key, *val;\n\tfor( val = conf_get_str_strs(conf, CONF_portfwd, NULL, &key ) ;\n\t\tval != NULL;\n\t\tval = conf_get_str_strs(conf, CONF_portfwd, key, &key)\t) {\n\t\t\tif (!strcmp(val, \"D\")) fprintf( fp, \"\tD%s\\t\\n\", key+1 ) ;\n\t\t\telse fprintf( fp, \"\t%s\\t%s\\n\", key, val);\n\t}\n\n    \t/* SSH bug compatibility modes */\n\tfprintf( fp, \"sshbug_ignore1=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_ignore1) ) ;\n\tfprintf( fp, \"sshbug_plainpw1=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_plainpw1) ) ;\n\tfprintf( fp, \"sshbug_rsa1=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_rsa1) ) ;\n\tfprintf( fp, \"sshbug_hmac2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_hmac2) ) ;\n\tfprintf( fp, \"sshbug_derivekey2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_derivekey2) ) ;\n\tfprintf( fp, \"sshbug_rsapad2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_rsapad2) ) ;\n\tfprintf( fp, \"sshbug_pksessid2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_pksessid2) ) ;\n\tfprintf( fp, \"sshbug_rekey2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_rekey2) ) ;\n\tfprintf( fp, \"sshbug_maxpkt2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_maxpkt2) ) ;\n\tfprintf( fp, \"sshbug_ignore2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_ignore2) ) ;\n\tfprintf( fp, \"sshbug_oldgex2=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_oldgex2) ) ;\n\tfprintf( fp, \"sshbug_winadj=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_winadj) ) ;\n\tfprintf( fp, \"sshbug_chanreq=%d\\n\",\t\tconf_get_int(conf,CONF_sshbug_chanreq) ) ;\n\tfprintf( fp, \"ssh_simple=%d\\n\",\t\t\tconf_get_bool(conf,CONF_ssh_simple) ) ;\n\tfprintf( fp, \"ssh_connection_sharing=%d\\n\",\tconf_get_bool(conf,CONF_ssh_connection_sharing) ) ;\n\tfprintf( fp, \"ssh_connection_sharing_upstream=%d\\n\",\tconf_get_bool(conf,CONF_ssh_connection_sharing_upstream) ) ;\n\tfprintf( fp, \"ssh_connection_sharing_downstream=%d\\n\",\tconf_get_bool(conf,CONF_ssh_connection_sharing_downstream) ) ;\n\t//X(STR, STR, ssh_manual_hostkeys) \n\n\t/* Options for pterm. Should split out into platform-dependent part. */\n\tfprintf( fp, \"stamp_utmp=%d\\n\",\t\t\tconf_get_bool(conf,CONF_stamp_utmp) ) ;\n\tfprintf( fp, \"login_shell=%d\\n\",\t\tconf_get_bool(conf,CONF_login_shell) ) ;\n\tfprintf( fp, \"scrollbar_on_left=%d\\n\",\t\tconf_get_bool(conf,CONF_scrollbar_on_left) ) ;\n\tfprintf( fp, \"shadowbold=%d\\n\",\t\t\tconf_get_bool(conf,CONF_shadowbold) ) ;\n\t// X(FONT, NONE, boldfont) \n\t// X(FONT, NONE, widefont) \n\t// X(FONT, NONE, wideboldfont)\n\tfprintf( fp, \"shadowboldoffset=%d\\n\",\t\tconf_get_int(conf,CONF_shadowboldoffset) ) ;\n\tfprintf( fp, \"crhaslf=%d\\n\",\t\t\tconf_get_bool(conf,CONF_crhaslf) ) ;\n\tfprintf( fp, \"winclass=%s\\n\",\t\t\tconf_get_str(conf,CONF_winclass) ) ;\n\t\n\t/* PuTTY 0.75 \n\tfprintf( fp, \"supdup_location=%s\\n\",\t\tconf_get_str(conf,CONF_supdup_location) ) ;\n\tfprintf( fp, \"supdup_ascii_set=%d\\n\",\t\tconf_get_int(conf,CONF_supdup_ascii_set) ) ;\n\tfprintf( fp, \"supdup_more=%d\\n\",\t\tconf_get_bool(conf,CONF_supdup_more) ) ;\n\tfprintf( fp, \"supdup_scroll=%d\\n\",\t\tconf_get_bool(conf,CONF_supdup_scroll) ) ;\n*/\n\n#ifdef MOD_PERSO\n\t/* MOD_PERSO Options */\n\t//fprintf( fp, \"bcdelay=%d\\n\", \t\t\tconf_get_int(conf,CONF_bcdelay) ) ;\t\t// Non present systematiquement\n\t//fprintf( fp, \"initdelay=%d\\n\",\t\t\tconf_get_int(conf,CONF_initdelay) ) ;\t\t// Non present systematiquement\n\tfprintf( fp, \"transparencynumber=%d\\n\", \tconf_get_int(conf,CONF_transparencynumber) ) ;\n\tfprintf( fp, \"sendtotray=%d\\n\",\t\t\tconf_get_int(conf,CONF_sendtotray) ) ;\n\tfprintf( fp, \"maximize=%d\\n\",\t\t\tconf_get_int(conf,CONF_maximize) ) ;\n\tfprintf( fp, \"fullscreen=%d\\n\",\t\t\tconf_get_int(conf,CONF_fullscreen) ) ;\n\tfprintf( fp, \"saveonexit=%d\\n\",\t\t\tconf_get_bool(conf,CONF_saveonexit) ) ;\n\tfprintf( fp, \"icone=%d\\n\",\t\t\tconf_get_int(conf,CONF_icone) ) ;\n\tfprintf( fp, \"iconefile=%s\\n\",\t\t\tconf_get_filename(conf,CONF_iconefile)->path ) ;\n\tfprintf( fp, \"winscpprot=%d\\n\",\t\t\tconf_get_int(conf,CONF_winscpprot) ) ;\n\tfprintf( fp, \"sftpconnect=%s\\n\", \t\tconf_get_str(conf,CONF_sftpconnect) ) ;\n\tfprintf( fp, \"pscpoptions=%s\\n\", \t\tconf_get_str(conf,CONF_pscpoptions) ) ;\n\tfprintf( fp, \"pscpshell=%s\\n\", \t\t\tconf_get_str(conf,CONF_pscpshell) ) ;\n\tfprintf( fp, \"pscpremotedir=%s\\n\", \t\tconf_get_str(conf,CONF_pscpremotedir) ) ;\n\tfprintf( fp, \"winscpoptions=%s\\n\", \t\tconf_get_str(conf,CONF_winscpoptions) ) ;\n\tfprintf( fp, \"winscprawsettings=%s\\n\", \t\tconf_get_str(conf,CONF_winscprawsettings) ) ;\n\tfprintf( fp, \"folder=%s\\n\", \t\t\tconf_get_str(conf,CONF_folder) ) ;\n\t/* On decrypte le password */\n\tchar bufpass[4096] ;\n\tmemcpy( bufpass, conf_get_str(conf,CONF_password), 4095 ) ; bufpass[4095]='\\0';\n\tMASKPASS(GetCryptSaltFlag(),bufpass);\n\tfprintf( fp, \"password=%s\\n\",\t\t\tbufpass ) ;\n\tmemset(bufpass,0,strlen(bufpass));\n\n\tfprintf( fp, \"autocommand=%s\\n\",\t\tconf_get_str(conf,CONF_autocommand) ) ;\n\tfprintf( fp, \"autocommandout=%s\\n\",\t\tconf_get_str(conf,CONF_autocommandout) ) ;\n\tfprintf( fp, \"antiidle=%s\\n\",\t\t\tconf_get_str(conf,CONF_antiidle) ) ;\n\tfprintf( fp, \"sessionname=%s\\n\", \t\tconf_get_str(conf,CONF_sessionname) ) ;\n\tfprintf( fp, \"logtimerotation=%d\\n\", \t\tconf_get_int(conf,CONF_logtimerotation) ) ;\n\tfprintf( fp, \"logtimestamp=%s\\n\", \t\tconf_get_str(conf,CONF_logtimestamp) ) ;\n\tfprintf( fp, \"scriptfile=%s\\n\",\t\t\tconf_get_filename(conf,CONF_scriptfile)->path ) ;\n\tfprintf( fp, \"scriptfilecontent=%s\",\t\tconf_get_str(conf,CONF_scriptfilecontent) ) ;\n\t/* On decrypte le script */\n\tbuf=(char*)malloc( strlen(conf_get_str(conf,CONF_scriptfilecontent)) + 20 ) ;\n\tstrcpy( buf, conf_get_str(conf,CONF_scriptfilecontent) ) ;\n\tlong l=decryptstring( GetCryptSaltFlag(), buf, MASTER_PASSWORD ) ;\n\tint i;\n\tfor( i=0; i<l ; i++ ) { if( buf[i]=='\\0' ) buf[i]='\\n' ; }\n\tfprintf( fp, \" (%s)\\n\", buf ) ;\n\tfree(buf);\n\tbuf=NULL;\n\tfprintf( fp, \"save_windowpos=%d\\n\",\t\tconf_get_bool(conf,CONF_save_windowpos) ) ;\n\tfprintf( fp, \"xpos=%d\\n\",\t\t\tconf_get_int(conf,CONF_xpos) ) ;\n\tfprintf( fp, \"ypos=%d\\n\",\t\t\tconf_get_int(conf,CONF_ypos) ) ;\n\tfprintf( fp, \"windowstate=%d\\n\",\t\tconf_get_int(conf,CONF_windowstate) ) ;\n\tfprintf( fp, \"foreground_on_bell=%d\\n\",\t\tconf_get_bool(conf,CONF_foreground_on_bell) ) ;\n\tfprintf( fp, \"ctrl_tab_switch=%d\\n\", \t\tconf_get_int(conf, CONF_ctrl_tab_switch));\n\tfprintf( fp, \"comment=%s\\n\",\t\t\tconf_get_str(conf,CONF_comment) ) ;\n\tfprintf( fp, \"scp_auto_pwd=%d\\n\", \t\tconf_get_int(conf, CONF_scp_auto_pwd));\n\tfprintf( fp, \"no_focus_rep=%d\\n\",\t\tconf_get_bool(conf,CONF_no_focus_rep) ) ;\n\tfprintf( fp, \"scrolllines=%d\\n\",\t\tconf_get_int(conf,CONF_scrolllines) ) ;\n\tfprintf( fp, \"ssh_tunnel_print_in_title=%d\\n\",\tconf_get_bool(conf,CONF_ssh_tunnel_print_in_title) ) ;\n#endif\n#ifdef MOD_PRINTCLIP\n\tfprintf( fp, \"printclip=%d\\n\",\t\t\tconf_get_int(conf,CONF_printclip) ) ;\n#endif\n#ifdef MOD_PROXY\n\tfprintf( fp, \"proxyselection=%s\\n\",\t\tconf_get_str(conf,CONF_proxyselection) ) ;\n#endif\n#ifdef MOD_RUTTY\n\t/* rutty: scripting options */\n\tfprintf( fp, \"ScriptFileName=%s\\n\",\t\tconf_get_filename(conf,CONF_script_filename)->path ) ;\n\tfprintf( fp, \"ScriptMode=%d\\n\",\t\t\tconf_get_int(conf,CONF_script_mode) ) ;\n\tfprintf( fp, \"ScriptLineDelay=%d\\n\",\t\tconf_get_int(conf,CONF_script_line_delay) ) ;\n\tfprintf( fp, \"ScriptCharDelay=%d\\n\",\t\tconf_get_int(conf,CONF_script_char_delay) ) ;\n\tfprintf( fp, \"ScriptCondLine=%s\\n\",\t\tconf_get_str(conf,CONF_script_cond_line) ) ;\n\tfprintf( fp, \"ScriptCondUse=%d\\n\",\t\tconf_get_int(conf,CONF_script_cond_use) ) ;\n\tfprintf( fp, \"ScriptCRLF=%d\\n\",\t\t\tconf_get_int(conf,CONF_script_crlf) ) ;\n\tfprintf( fp, \"ScriptEnable=%d\\n\",\t\tconf_get_int(conf,CONF_script_enable) ) ;\n    \tfprintf( fp, \"ScriptExcept=%d\\n\",\t\tconf_get_int(conf,CONF_script_except) ) ;\n\tfprintf( fp, \"ScriptTimeout=%d\\n\",\t\tconf_get_int(conf,CONF_script_timeout) ) ;\n\tfprintf( fp, \"ScriptWait=%s\\n\",\t\t\tconf_get_str(conf,CONF_script_waitfor) ) ;\n\tfprintf( fp, \"ScriptHalt=%s\\n\",\t\t\tconf_get_str(conf,CONF_script_halton) ) ;\n#endif\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\t/* Image Options */\n\tfprintf( fp, \"bg_opacity=%d\\n\",\t\t\tconf_get_int(conf,CONF_bg_opacity) ) ;\n\tfprintf( fp, \"bg_slideshow=%d\\n\",\t\tconf_get_int(conf,CONF_bg_slideshow) ) ;\n\tfprintf( fp, \"bg_type=%d\\n\",\t\t\tconf_get_int(conf,CONF_bg_type) ) ;\n\tfprintf( fp, \"bg_image_filename=%s\\n\",\t\tconf_get_filename(conf,CONF_bg_image_filename)->path ) ;\n\tfprintf( fp, \"bg_image_style=%d\\n\",\t\tconf_get_int(conf,CONF_bg_image_style) ) ;\n\tfprintf( fp, \"bg_image_abs_x=%d\\n\",\t\tconf_get_int(conf,CONF_bg_image_abs_x) ) ;\n\tfprintf( fp, \"bg_image_abs_y=%d\\n\",\t\tconf_get_int(conf,CONF_bg_image_abs_y) ) ;\n\tfprintf( fp, \"bg_image_abs_fixed=%d\\n\",\t\tconf_get_int(conf,CONF_bg_image_abs_fixed) ) ;\n#endif\n#ifdef MOD_RECONNECT\n\t/* Reconnect Options */\n\tfprintf( fp, \"wakeup_reconnect=%d\\n\",\t\tconf_get_int(conf,CONF_wakeup_reconnect) ) ;\n\tfprintf( fp, \"failure_reconnect=%d\\n\",\t\tconf_get_int(conf,CONF_failure_reconnect) ) ;\n#endif\n#ifdef MOD_HYPERLINK\n\t/* Hyperlink Options */\n\tfprintf( fp, \"url_ctrl_click=%d\\n\",\t\tconf_get_int(conf,CONF_url_ctrl_click) ) ; \n\tfprintf( fp, \"url_underline=%d\\n\",\t\tconf_get_int(conf,CONF_url_underline) ) ; \n\tfprintf( fp, \"url_defbrowser=%d\\n\",\t\tconf_get_int(conf,CONF_url_defbrowser) ) ; \n\tfprintf( fp, \"url_defregex=%d\\n\",\t\tconf_get_int(conf,CONF_url_defregex) ) ; \n\tfprintf( fp, \"url_browser=%s\\n\",\t\tconf_get_filename(conf,CONF_url_browser)->path ) ; \n\tfprintf( fp, \"url_regex=%s\\n\",\t\t\tconf_get_str(conf,CONF_url_regex) ) ;\n\tfprintf( fp, \"urlhack_default_regex=%s\\n\",\turlhack_default_regex ) ;\n\tfprintf( fp, \"urlhack_liberal_regex=%s\\n\",\turlhack_liberal_regex ) ;\n#endif\n#ifdef MOD_TUTTY\n\t/* TuTTY port Options */\n\tfprintf( fp, \"window_closable=%d\\n\",\t\tconf_get_int(conf,CONF_window_closable) ) ; \n\tfprintf( fp, \"window_minimizable=%d\\n\",\t\tconf_get_int(conf,CONF_window_minimizable) ) ; \n\tfprintf( fp, \"window_maximizable=%d\\n\",\t\tconf_get_int(conf,CONF_window_maximizable) ) ; \n\tfprintf( fp, \"window_has_sysmenu=%d\\n\",\t\tconf_get_int(conf,CONF_window_has_sysmenu) ) ; \n\tfprintf( fp, \"bottom_buttons=%d\\n\",\t\tconf_get_int(conf,CONF_bottom_buttons) ) ; \n#endif\n#ifdef MOD_TUTTYCOLOR\n\tfprintf( fp, \"bold_colour=%d\\n\",\t\tconf_get_int(conf,CONF_bold_colour) ) ; \n\tfprintf( fp, \"under_colour=%d\\n\",\t\tconf_get_int(conf,CONF_under_colour) ) ; \n\tfprintf( fp, \"sel_colour=%d\\n\",\t\t\tconf_get_int(conf,CONF_sel_colour) ) ;\n#endif\n#ifdef MOD_ZMODEM\n\t/* ZModem Options */\n\tfprintf( fp, \"rzcommand=%s\\n\",\t\t\tconf_get_filename(conf,CONF_rzcommand)->path ) ;\n\tfprintf( fp, \"rzoptions=%s\\n\",\t\t\tconf_get_str(conf,CONF_rzoptions) ) ;\n\tfprintf( fp, \"szcommand=%s\\n\",\t\t\tconf_get_filename(conf,CONF_szcommand)->path ) ;\n\tfprintf( fp, \"szoptions=%s\\n\",\t\t\tconf_get_str(conf,CONF_szoptions) ) ;\n\tfprintf( fp, \"zdownloaddir=%s\\n\",\t\tconf_get_str(conf,CONF_zdownloaddir) ) ;\n#endif\n#ifdef MOD_PORTKNOCKING\n\t/* Port knocking Options */\n\tfprintf( fp, \"portknocking=%s\\n\",\t\tconf_get_str(conf,CONF_portknockingoptions) ) ;\n#endif\n#ifdef MOD_DISABLEALTGR\n\t/* Disable AltGr Options */\n\tfprintf( fp, \"disablealtgr=%d\\n\",\t\tconf_get_int(conf,CONF_disablealtgr) ) ;\n#endif\n\n\tfprintf( fp, \"\\n[[KiTTY specific configuration]]\\n\" ) ;\n\tfprintf( fp, \"IniFileFlag=%d - \",IniFileFlag) ;\n\tswitch(IniFileFlag) {\n\t\tcase 0: fprintf( fp, \"Registry\\n\" ) ; break ;\n\t\tcase 1: fprintf( fp, \"File\\n\" ) ; break ;\n\t\tcase 2: fprintf( fp, \"Directory\\n\" ) ; break ;\n\t}\n\t\n\tfprintf( fp, \"internal_delay=%d\\ninit_delay=%d\\nautocommand_delay=%d\\nbetween_char_delay=%d\\nProtectFlag=%d\\n\",internal_delay,init_delay,autocommand_delay,between_char_delay,ProtectFlag );\n\t\n\tfprintf( fp, \"HyperlinkFlag=%d\\n\", HyperlinkFlag );\n\tif( AutoCommand!= NULL ) fprintf( fp, \"AutoCommand=%s\\n\", AutoCommand ) ;\n\tif( ScriptCommand!= NULL ) fprintf( fp, \"ScriptCommand=%s\\n\", ScriptCommand ) ;\n\tif( PasteCommand!= NULL ) fprintf( fp, \"PasteCommand=%s\\n\", PasteCommand ) ;\n\tfprintf( fp, \"PasteCommandFlag=%d\\n\", PasteCommandFlag ) ;\n\tfprintf( fp, \"PasteSize=%d\\n\", GetPasteSize() ) ;\n\tif( ScriptFileContent!= NULL ) {\n\t\tchar * pst = ScriptFileContent ;\n\t\tfprintf( fp, \"ScriptFileContent=\" ) ;\n\t\twhile( strlen(pst) > 0 ) { fprintf( fp, \"%s|\", pst ) ; pst=pst+strlen(pst)+1 ; }\n\t\tfprintf( fp, \"\\n\" )  ;\n\t\t}\n\tif( IconFile!= NULL ) fprintf( fp, \"IconFile=%s\\n\", IconFile ) ;\n\tfprintf( fp, \"AutoStoreSSHKeyFlag=%d\\nDirectoryBrowseFlag=%d\\nVisibleFlag=%d\\nShortcutsFlag=%d\\nMouseShortcutsFlag=%d\\nIconeFlag=%d\\nNumberOfIcons=%d\\nSizeFlag=%d\\nCapsLockFlag=%d\\nTitleBarFlag=%d\\nCtrlTabFlag=%d\\nRuTTYFlag=%d\\n\"\n\t,GetAutoStoreSSHKeyFlag(),DirectoryBrowseFlag,VisibleFlag,ShortcutsFlag,MouseShortcutsFlag,IconeFlag,NumberOfIcons,SizeFlag,CapsLockFlag,TitleBarFlag,CtrlTabFlag,RuttyFlag);\n\t//static HINSTANCE hInstIcons =  NULL ;\n\tfprintf( fp, \"WinHeight=%d\\nWinrolFlag=%d\\nAutoSendToTray=%d\\nNoKittyFileFlag=%d\\nConfigBoxHeight=%d\\nConfigBoxWindowHeight=%d\\nConfigBoxNoExitFlag=%d\\nUserPassSSHNoSave=%d\\nPuttyFlag=%d\\n\",WinHeight,WinrolFlag,AutoSendToTray,NoKittyFileFlag,ConfigBoxHeight,ConfigBoxWindowHeight,ConfigBoxNoExitFlag,GetUserPassSSHNoSave(),GetPuttyFlag());\n\n\tfprintf( fp,\"BackgroundImageFlag=%d\\n\",GetBackgroundImageFlag() );\n\tfprintf( fp,\"RandomActiveFlag=%d\\n\",GetRandomActiveFlag() );\n\tfprintf( fp,\"CryptSaltFlag=%d\\n\",GetCryptSaltFlag() );\n\tfprintf( fp, \"ConfigBoxLeft=%d\\n\",GetConfigBoxLeft());\n\tfprintf( fp, \"ConfigBoxTop=%d\\n\",GetConfigBoxTop());\n#ifdef MOD_RECONNECT\n\tfprintf( fp,\"AutoreconnectFlag=%d\\nReconnectDelay=%d\\n\",AutoreconnectFlag,ReconnectDelay );\n#endif\n#ifdef MOD_ADB\n\tfprintf( fp,\"ADBFlag=%d\\n\",GetADBFlag() );\n#endif\n#ifdef MOD_PROXY\n\tfprintf( fp,\"ProxySelectionFlag=%d\\n\",GetProxySelectionFlag() );\n#endif\n\tif( PasswordConf!= NULL ) fprintf( fp, \"PasswordConf=%s\\n\", PasswordConf ) ;\n\tfprintf( fp, \"SessionFilterFlag=%d\\nSessionsInDefaultFlag=%d\\nDefaultSettingsFlag=%d\\nDblClickFlag=%d\\nImageViewerFlag=%d\\nImageSlideDelay=%d\\nMaxBlinkingTime=%d\\nPrintCharSize=%d\\nPrintMaxLinePerPage=%d\\nPrintMaxCharPerLine=%d\\nReadOnlyFlag=%d\\nScrumbleKeyFlag=%d\\n\"\n\t,SessionFilterFlag,SessionsInDefaultFlag,DefaultSettingsFlag,DblClickFlag,ImageViewerFlag,ImageSlideDelay,MaxBlinkingTime,PrintCharSize,PrintMaxLinePerPage,PrintMaxCharPerLine,GetReadOnlyFlag(),GetScrumbleKeyFlag());\n\tfprintf( fp, \"AntiIdleCount=%d\\nAntiIdleCountMax=%d\\nIconeNum=%d\\n\"\n\t,AntiIdleCount,AntiIdleCountMax,IconeNum);\n\tfprintf( fp, \"AntiIdleStr=%s\\nInitialDirectory=%s\\nFileExtension=%s\\nConfigDirectory=%s\\nBuildVersionTime=%s\\n\",AntiIdleStr,InitialDirectory,FileExtension,ConfigDirectory,BuildVersionTime);\n\tif( WinSCPPath!= NULL ) fprintf( fp, \"WinSCPPath=%s\\n\", WinSCPPath ) ;\n\tif( PSCPPath!= NULL ) fprintf( fp, \"PSCPPath=%s\\n\", PSCPPath ) ;\n\tif( PlinkPath!= NULL ) fprintf( fp, \"PlinkPath=%s\\n\", PlinkPath ) ;\n\tif( KittyIniFile!= NULL ) fprintf( fp, \"KittyIniFile=%s\\n\", KittyIniFile ) ;\n\tif( KittySavFile!= NULL ) fprintf( fp, \"KittySavFile=%s\\n\", KittySavFile ) ;\n\tif( KiTTYClassName != NULL ) fprintf( fp, \"KiTTYClassName=%s\\n\", KiTTYClassName ) ;\n\tif( CtHelperPath!= NULL ) fprintf( fp, \"CtHelperPath=%s\\n\", CtHelperPath ) ;\n\tif( strlen(ManagePassPhrase(NULL))>0 ) fprintf( fp, \"PassPhrase=%s\\n\", ManagePassPhrase(NULL)) ;\n\tfprintf( fp, \"is_backend_connected=%d\\n\", is_backend_connected ) ;\n\tfprintf( fp, \"is_backend_first_connected=%d\\n\", is_backend_first_connected ) ;\n}\n\n// Recupere la configuration de kitty_store\nextern char seedpath[2 * MAX_PATH + 10] ;\nextern char seedpath[2 * MAX_PATH + 10] ;\nextern char sesspath[2 * MAX_PATH] ;\nextern char initialsesspath[2 * MAX_PATH] ;\nextern char sshkpath[2 * MAX_PATH] ;\nextern char jumplistpath[2 * MAX_PATH] ;\nextern char oldpath[2 * MAX_PATH] ;\nextern char sessionsuffix[16] ;\nextern char keysuffix[16] ;\n\nvoid SaveKiTTYStore( FILE *fp ) {\n\tfprintf( fp, \"seedpath=%s\\n\", seedpath ) ;\n\tfprintf( fp, \"sesspath=%s\\n\", sesspath ) ;\n\tfprintf( fp, \"initialsesspath=%s\\n\", initialsesspath ) ;\n\tfprintf( fp, \"sshkpath=%s\\n\", sshkpath ) ;\n\tfprintf( fp, \"jumplistpath=%s\\n\", jumplistpath ) ;\n\tfprintf( fp, \"oldpath=%s\\n\", oldpath ) ;\n\tfprintf( fp, \"sessionsuffix=%s\\n\", sessionsuffix ) ;\n\tfprintf( fp, \"keysuffix=%s\\n\", keysuffix ) ;\n}\n\n// recupere la configuration des shortcuts\nvoid SaveShortCuts( FILE *fp ) {\n\tint i ;\n\tfprintf( fp, \"autocommand=%d\\n\", shortcuts_tab.autocommand ) ;\n\tfprintf( fp, \"command=%d\\n\", shortcuts_tab.command ) ;\n\tfprintf( fp, \"editor=%d\\n\", shortcuts_tab.editor ) ;\n\tfprintf( fp, \"editorclipboard=%d\\n\", shortcuts_tab.editorclipboard ) ;\n\tfprintf( fp, \"getfile=%d\\n\", shortcuts_tab.getfile ) ;\n\tfprintf( fp, \"imagechange=%d\\n\", shortcuts_tab.imagechange ) ;\n\tfprintf( fp, \"input=%d\\n\", shortcuts_tab.input ) ;\n\tfprintf( fp, \"inputm=%d\\n\", shortcuts_tab.inputm ) ;\n\tfprintf( fp, \"print=%d\\n\", shortcuts_tab.print ) ;\n\tfprintf( fp, \"printall=%d\\n\", shortcuts_tab.printall ) ;\n\tfprintf( fp, \"protect=%d\\n\", shortcuts_tab.protect ) ;\n\tfprintf( fp, \"script=%d\\n\", shortcuts_tab.script ) ;\n\tfprintf( fp, \"sendfile=%d\\n\", shortcuts_tab.sendfile ) ;\n\tfprintf( fp, \"rollup=%d\\n\", shortcuts_tab.rollup ) ;\n\tfprintf( fp, \"tray=%d\\n\", shortcuts_tab.tray ) ;\n\tfprintf( fp, \"viewer=%d\\n\", shortcuts_tab.viewer ) ;\n\tfprintf( fp, \"visible=%d\\n\", shortcuts_tab.visible ) ;\n\tfprintf( fp, \"winscp=%d\\n\", shortcuts_tab.winscp ) ;\n\tfprintf( fp, \"showportforward=%d\\n\", shortcuts_tab.showportforward ) ;\n\tfprintf( fp, \"duplicate=%d\\n\", shortcuts_tab.duplicate ) ;\n\t\n\tfprintf( fp, \"\\nNbShortCuts=%d\\n\", NbShortCuts ) ;\n\tif( NbShortCuts>0 ) {\n\t\tfor( i=0 ; i<NbShortCuts ; i++ ) \n\t\t\tfprintf( fp, \"%d=%s|\\n\",shortcuts_tab2[i].num, shortcuts_tab2[i].st );\n\t\t}\n\t}\n\t\n// Recupere le menu utilisateur\nvoid SaveSpecialMenu( FILE *fp ) {\n\tint i ;\n\tfor( i=0 ; i<NB_MENU_MAX ; i++ )\n\t\tif( SpecialMenu[i]!=NULL ) \n\t\t\tfprintf( fp, \"%d=%s\\n\", i, SpecialMenu[i] );\n\t}\n\n// Recupere une copie d'ecran\nvoid MakeScreenShot() ;\n\nvoid SaveScreenShot( FILE *fp ) {\n\tchar buf[128] ;\n\tFILE *fp2 ;\n\tMakeScreenShot() ;\n\tbcrypt_file_base64( \"screenshot.jpg\", \"screenshot.jpg.bcr\", MASTER_PASSWORD, 80 ) ;\n\tunlink( \"screenshot.jpg\" ) ;\n\tif( (fp2=fopen(\"screenshot.jpg.bcr\",\"r\"))!=NULL ) {\n\t\twhile( fgets( buf, 80, fp2 ) ) {\n\t\t\tfprintf( fp, \"%s\", buf ) ;\n\t\t}\n\t\tfclose(fp2);\n\t}\n\tunlink( \"screenshot.jpg.bcr\" ) ;\n}\n\t\n// Exporte la configuration courante\nvoid SaveCurrentConfig( FILE *fp, Conf * conf ) {\n\tchar buf[1028] ;\n\tFILE *fp2 ;\n\tsave_open_settings_forced( \"current.ktx\", conf ) ;\n\tbcrypt_file_base64( \"current.ktx\", \"current.ktx.bcr\", MASTER_PASSWORD, 80 ) ;\n\tunlink( \"current.ktx\" ) ;\n\tif( (fp2=fopen(\"current.ktx.bcr\",\"r\"))!=NULL ) {\n\t\twhile( fgets( buf, 1028, fp2 ) ) {\n\t\t\tfprintf( fp, \"%s\", buf ) ;\n\t\t}\n\t\tfclose(fp2);\n\t}\n\tunlink( \"current.ktx.bcr\" );\n}\n\n// Sauvegarde le contenu d'un fichier s'il existe\nvoid SaveDebugFile( char * filename, FILE *fpout ) {\n\tFILE *fp;\n\tchar buffer[4096];\n\tif( ( fp = fopen( filename, \"r\" ) ) != NULL ) {\n\t\twhile( fgets( buffer, 4095, fp ) != NULL ) fputs( buffer, fpout ) ;\n\t\tfclose( fp ) ;\n\t\t}\n\tfputs( \"\\n\", fpout ) ;\n\tfflush( fpout ) ;\n}\n\t\n// recupere toute la configuration en un seul fichier\nvoid SaveDumpFile( char * filename ) {\n\tFILE * fp, * fpout ;\n\tchar buffer[4096], buffer2[4096] ;\n\tint i;\n\tif( IniFileFlag != SAVEMODE_REG ) { WriteCountUpAndPath() ; }\n\t\n\tif( strlen(InitialDirectory)==0 ) { GetInitialDirectory( InitialDirectory ) ; }\n\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, filename ) ;\n\n\tif( ( fpout = fopen( buffer, \"w\" ) ) != NULL ) {\n\t\t\n\t\tfputs( \"\\n@@@ InitialDirectoryListing @@@\\n\\n\", fpout ) ;\n\t\tSaveDumpListFile( fpout, InitialDirectory ) ; fflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ Environment variables @@@\\n\\n\", fpout ) ;\n\t\tSaveDumpEnvironment( fpout ) ; fflush( fpout ) ;\n\t\t\n\t\tfputs( \"\\n@@@ KiTTYIniFile @@@\\n\\n\", fpout ) ;\n\t\tif( ( fp = fopen( KittyIniFile, \"r\" ) ) != NULL ) {\n\t\t\twhile( fgets( buffer, 4095, fp ) != NULL ) fputs( buffer, fpout ) ;\n\t\t\tfclose( fp ) ;\n\t\t\t}\n\t\tfputs( \"\\n\", fpout ) ;\n\t\tfflush( fpout ) ;\n\n\t\tif( RegTestKey( HKEY_CURRENT_USER, TEXT(\"Software\\\\SimonTatham\\\\PuTTY\") ) ) {\n\t\t\tfputs( \"\\n@@@ PuTTY RegistryBackup @@@\\n\\n\", fpout ) ;\n\t\t\tSaveRegistryKeyEx( HKEY_CURRENT_USER, TEXT(\"Software\\\\SimonTatham\\\\PuTTY\"), KittySavFile ) ;\n\t\t\tif( ( fp = fopen( KittySavFile, \"r\" ) ) != NULL ) {\n\t\t\t\twhile( fgets( buffer, 4095, fp ) != NULL ) fputs( buffer, fpout ) ;\n\t\t\t\tfclose( fp ) ;\n\t\t\t\t}\n\t\t\tunlink( KittySavFile ) ;\n\t\t\t}\n\t\tfflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ KiTTY RegistryBackup @@@\\n\\n\", fpout ) ;\n\t\tif( (IniFileFlag == SAVEMODE_REG)||(IniFileFlag == SAVEMODE_FILE) ) {\n\t\t\tSaveRegistryKey() ;\n\t\t\tif( ( fp = fopen( KittySavFile, \"r\" ) ) != NULL ) {\n\t\t\t\twhile( fgets( buffer, 4095, fp ) != NULL ) fputs( buffer, fpout ) ;\n\t\t\t\tfclose( fp ) ;\n\t\t\t\t}\n\t\t\t}\n\t\telse if( IniFileFlag == SAVEMODE_DIR ) {\n\t\t\tsprintf( buffer, \"%s\\\\Commands\", ConfigDirectory ) ; SaveDumpListConf( fpout, buffer ) ;\n\t\t\tsprintf( buffer, \"%s\\\\Folders\", ConfigDirectory ) ; SaveDumpListConf( fpout, buffer ) ;\n\t\t\tsprintf( buffer, \"%s\\\\Launcher\", ConfigDirectory ) ; SaveDumpListConf( fpout, buffer ) ;\n\t\t\tsprintf( buffer, \"%s\\\\Sessions\", ConfigDirectory ) ; SaveDumpListConf( fpout, buffer ) ;\n\t\t\tsprintf( buffer, \"%s\\\\Sessions_Commands\", ConfigDirectory ) ; SaveDumpListConf( fpout, buffer ) ;\n\t\t\tsprintf( buffer, \"%s\\\\SshHostKeys\", ConfigDirectory ) ; SaveDumpListConf( fpout, buffer ) ;\n\t\t\t}\n\t\tfflush( fpout ) ;\n\t\t\t\n\t\tfputs( \"\\n@@@ SystemInfos @@@\\n\\n\", fpout ) ;\n\t\tPrintSystemInfo( fpout ) ; fflush( fpout ) ;\n\t\t\t\n\t\tfputs( \"\\n@@@ OSInfos @@@\\n\\n\", fpout ) ;\n\t\tPrintOSInfo( fpout ) ; fflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ WindowSettings @@@\\n\\n\", fpout ) ;\n\t\tPrintWindowSettings( fpout ) ; fflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ RunningProcess @@@\\n\\n\", fpout ) ;\n\t\tPrintAllProcess( fpout ) ; fflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ CurrentEventLog @@@\\n\\n\", fpout ) ;\n\t\ti = 0 ; while( print_event_log( fpout, i ) ) { i++ ; }\n\t\tfflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ ClipBoardContent @@@\\n\\n\", fpout ) ;\n\t\tSaveDumpClipBoard( fpout ) ; fflush( fpout ) ;\n\n\t\tif( debug_flag ) {\n\t\t\tfputs( \"\\n@@@ KeyPressed @@@\\n\\n\", fpout ) ;\n\t\t\tfprintf( fpout, \"%d: WM_KEYDOWN\\n%d: WM_SYSKEYDOWN\\n%d: WM_KEYUP\\n%d: WM_SYSKEYUP\\n%d: WM_CHAR\\n\\n\", WM_KEYDOWN,WM_SYSKEYDOWN,WM_KEYUP,WM_SYSKEYUP,WM_CHAR);\n\t\t\tfprintf( fpout, \"SHIFT CONTROL ALT ALTGR WIN\\n\" ) ;\n\t\t\tfprintf( fpout, \"%s\\n\", SaveKeyPressed ) ;\n\t\t\t}\n\t\tfflush( fpout ) ;\n\n\t\tfputs( \"\\n@@@ RunningConfig @@@\\n\\n\", fpout ) ; fflush( fpout ) ;\n\t\tSaveDumpConfig( fpout, conf ) ; fflush( fpout ) ;\n\t\tSaveKiTTYStore( fpout ) ; fflush( fpout ) ;\n\t\t\t\n\t\tfputs( \"\\n@@@ RunningConfig in KTX file format @@@\\n\\n\", fpout ) ; fflush( fpout ) ;\n\t\tSaveCurrentConfig( fpout, conf ) ; fputs( \"\\n\", fpout ) ; fflush( fpout ) ;\n\t\t\t\t\n\t\tif( IniFileFlag==SAVEMODE_DIR ) {\n\t\t\tfputs( \"\\n@@@ RunningPortableConfig @@@\\n\\n\", fpout ) ;\n\t\t\tSaveDumpPortableConfig( fpout ) ;\n\t\t\t}\n\t\tfflush( fpout ) ;\n\t\t\t\n\t\tif( DebugText!= NULL ) {\n\t\t\tfputs( \"\\n@@@ Debug @@@\\n\\n\", fpout ) ;\n\t\t\tfprintf( fpout, \"%s\\n\",  DebugText ) ;\n\t\t\t}\n\t\t\n\t\tfputs( \"\\n@@@ Shortcuts @@@\\n\\n\", fpout ) ;\n\t\tSaveShortCuts( fpout ) ; fflush( fpout ) ;\n\t\t\n\t\tfputs( \"\\n@@@ SpecialMenu @@@\\n\\n\", fpout ) ;\n\t\tSaveSpecialMenu( fpout ) ; fflush( fpout ) ;\n\n\t\tif( existfile(\"kitty.log\") ) { \n\t\t\tfputs( \"\\n@@@ Debug log file @@@\\n\\n\", fpout ) ;\n\t\t\tSaveDebugFile( \"kitty.log\", fpout ) ; \n\t\t}\n\t\tif( existfile( conf_get_filename(conf,CONF_keyfile)->path ) ) { \n\t\t\tfputs( \"\\n@@@ Private key file @@@\\n\\n\", fpout ) ;\n\t\t\tSaveDebugFile( conf_get_filename(conf,CONF_keyfile)->path, fpout ) ;\n\t\t}\n#ifdef MOD_RUTTY\n\t\tif( existfile( conf_get_filename(conf,CONF_script_filename)->path ) ) { \n\t\t\tfputs( \"\\n@@@ RuTTY script file @@@\\n\\n\", fpout ) ;\n\t\t\tSaveDebugFile( conf_get_filename(conf,CONF_script_filename)->path, fpout ) ;\n\t\t}\n#endif\n\t\tfputs( \"\\n@@@ ScreenShot @@@\\n\\n\", fpout ) ;\n\t\tSaveScreenShot( fpout ) ; fflush( fpout ) ;\n\t\t\t\n\t\tfclose( fpout ) ;\n\n\t\tsprintf( buffer, \"%s\\\\%s\", InitialDirectory, filename ) ;\n\t\tsprintf( buffer2, \"%s\\\\%s\", InitialDirectory, \"kitty.dmp.bcr\" ) ;\n\t\tbcrypt_file_base64( buffer, buffer2, MASTER_PASSWORD, 80 ) ; unlink( buffer ) ; rename( buffer2, buffer ) ;\n\t\t}\n\t}\nvoid SaveDump(void) {\n\tSaveDumpFile(\"kitty.dmp\") ; \n}\n"
        },
        {
          "name": "kitty_settings.c",
          "type": "blob",
          "size": 77.6533203125,
          "content": "\n/****\nA partir du fichier SETTINGS.C\n- prendre le contenu de la fonction void save_open_settings(void *sesskey, Conf *conf) et le mettre dans la fonction ci-dessous void save_open_settings_forced(char *filename, Conf *conf) entre les commantaires // BEGIN COPY/PASTE et // END COPY/PASTE\n- remplacer les write_setting_b( par des write_setting_b_forced(\n- remplacer les write_setting_i( par des write_setting_i_forced(\n- remplacer les write_setting_s( par des write_setting_s_forced(\n- remplacer les write_setting_fontspec( par des write_setting_fontspec_forced(\n- remplacer les write_setting_filename( par des write_setting_filename_forced(\n- remplacer les wmap( par des wmap_forced(\n- remplacer les wprefs( par des wprefs_forced(\n- remplacer les write_clip_setting( par des write_clip_setting_forced(\n\nLES REMPLACEMENTS DOIVENT SE FAIRE SUR LA SELECTION ENTRE LES COMMENTAIRES UNIQUEMENT !\n\n- prendre le contenu de la fonction void load_open_settings(void *sesskey, Conf *conf) et le mettre dans la fonction ci-dessous void load_open_settings_forced(char *filename, Conf *conf) entre les commantaires // BEGIN COPY/PASTE et // END COPY/PASTE\n- remplacer en prenant bien en compte les (\n- remplacer les gppb_raw( par des gppb_raw_forced(\n- remplacer les gppb( par des gppb_forced(\n- remplacer les gppi_raw( par des gppi_raw_forced(\n- remplacer les gppi( par des gppi_forced(\n- remplacer les gpps_raw( par des gpps_raw_forced(\n- remplacer les gpps( par des gpps_forced(\n- remplacer les gppfile( par des gppfile_forced(\n- remplacer les gppfont( par des gppfont_forced(\n- remplacer les gppmap( par des gppmap_forced(\n- remplacer les gprefs( par des gprefs_forced(\n- remplacer les read_clip_setting( par des read_clip_setting_forced(\nLES REMPLACEMENTS DOIVENT SE FAIRE SUR LA SELECTION ENTRE LES COMMENTAIRES UNIQUEMENT !\n\nSUPPRIMER les sauvegarde/chargement du paramètre folder\n\nRemarque: ce fichier kitty_settings.c est inclus à la toute fin du fichier SETTINGS.C\n****/\n/* Fonctions prototypes */\nint cryptstring( char * st, const char * key ) ;\nint decryptstring( char * st, const char * key ) ;\n\nvoid write_setting_b_forced(void *handle, const char *key, bool value) ;\nvoid write_setting_i_forced(void *handle, const char *key, int value) ;\nvoid write_setting_s_forced(void *handle, const char *key, const char *value) ;\nvoid write_setting_filename_forced(void *handle, const char *key, Filename *value) ;\nvoid write_setting_fontspec_forced(void *handle, const char *key, FontSpec *font) ;\nstatic void wmap_forced(void *handle, char const *outkey, Conf *conf, int primary,int include_values) ;\nstatic void wprefs_forced(void *sesskey, const char *name, const struct keyvalwhere *mapping, int nvals, Conf *conf, int primary) ;\nstatic void write_clip_setting_forced(void *sesskey, const char *savekey, Conf *conf, int confkey, int strconfkey) ;\n\t\nint read_setting_i_forced(void *handle, const char *key, int defvalue) ;\nchar *read_setting_s_forced(void *handle, const char *key) ;\nFilename *read_setting_filename_forced(void *handle, const char *key) ;\n\nstatic bool gppb_raw_forced(void *sesskey, const char *name, bool def) ;\nstatic void gppb_forced(void *sesskey, const char *name, bool def, Conf *conf, int primary) ;\nstatic void gppi_forced(void *handle, const char *name, int def, Conf *conf, int primary) ;\nstatic int gppi_raw_forced(void *handle, const char *name, int def) ;\nstatic void gppfile_forced(void *handle, const char *name, Conf *conf, int primary) ;\nstatic void gpps_forced(void *handle, const char *name, const char *def, Conf *conf, int primary) ;\nstatic char *gpps_raw_forced(void *handle, const char *name, const char *def) ;\nstatic void gppfont_forced(void *handle, const char *name, Conf *conf, int primary)  ;\nstatic int gppmap_forced(void *handle, const char *name, Conf *conf, int primary) ;\nstatic void gprefs_forced(void *sesskey, const char *name, const char *def, const struct keyvalwhere *mapping, int nvals, Conf *conf, int primary) ;\nstatic void read_clip_setting_forced(void *sesskey, char *savekey, int def, Conf *conf, int confkey, int strconfkey) ;\n \n/* Fonction principale */\nvoid save_open_settings_forced(char *filename, Conf *conf) {\n\tFILE *sesskey ;\n\tif( (sesskey=fopen(filename,\"w\")) == NULL ) { return ; }\n// BEGIN COPY/PASTE\n    int i;\n    const char *p;\n    write_setting_i_forced(sesskey, \"Present\", 1);\n    write_setting_s_forced(sesskey, \"HostName\", conf_get_str(conf, CONF_host));\n    write_setting_filename_forced(sesskey, \"LogFileName\", conf_get_filename(conf, CONF_logfilename));\n    write_setting_i_forced(sesskey, \"LogType\", conf_get_int(conf, CONF_logtype));\n    write_setting_i_forced(sesskey, \"LogFileClash\", conf_get_int(conf, CONF_logxfovr));\n    write_setting_b_forced(sesskey, \"LogFlush\", conf_get_bool(conf, CONF_logflush));\n    write_setting_b_forced(sesskey, \"LogHeader\", conf_get_bool(conf, CONF_logheader));\n    write_setting_b_forced(sesskey, \"SSHLogOmitPasswords\", conf_get_bool(conf, CONF_logomitpass));\n    write_setting_b_forced(sesskey, \"SSHLogOmitData\", conf_get_bool(conf, CONF_logomitdata));\n    p = \"raw\";\n    {\n        const struct BackendVtable *vt =\n            backend_vt_from_proto(conf_get_int(conf, CONF_protocol));\n        if (vt)\n            p = vt->id;\n    }\n    write_setting_s_forced(sesskey, \"Protocol\", p);\n    write_setting_i_forced(sesskey, \"PortNumber\", conf_get_int(conf, CONF_port));\n    /* The CloseOnExit numbers are arranged in a different order from\n     * the standard FORCE_ON / FORCE_OFF / AUTO. */\n    write_setting_i_forced(sesskey, \"CloseOnExit\", (conf_get_int(conf, CONF_close_on_exit)+2)%3);\n    write_setting_b_forced(sesskey, \"WarnOnClose\", !!conf_get_bool(conf, CONF_warn_on_close));\n    write_setting_i_forced(sesskey, \"PingInterval\", conf_get_int(conf, CONF_ping_interval) / 60);\t/* minutes */\n    write_setting_i_forced(sesskey, \"PingIntervalSecs\", conf_get_int(conf, CONF_ping_interval) % 60);\t/* seconds */\n    write_setting_b_forced(sesskey, \"TCPNoDelay\", conf_get_bool(conf, CONF_tcp_nodelay));\n    write_setting_b_forced(sesskey, \"TCPKeepalives\", conf_get_bool(conf, CONF_tcp_keepalives));\n    write_setting_s_forced(sesskey, \"TerminalType\", conf_get_str(conf, CONF_termtype));\n    write_setting_s_forced(sesskey, \"TerminalSpeed\", conf_get_str(conf, CONF_termspeed));\n    wmap_forced(sesskey, \"TerminalModes\", conf, CONF_ttymodes, true);\n\n    /* Address family selection */\n    write_setting_i_forced(sesskey, \"AddressFamily\", conf_get_int(conf, CONF_addressfamily));\n\n    /* proxy settings */\n    write_setting_s_forced(sesskey, \"ProxyExcludeList\", conf_get_str(conf, CONF_proxy_exclude_list));\n    write_setting_i_forced(sesskey, \"ProxyDNS\", (conf_get_int(conf, CONF_proxy_dns)+2)%3);\n    write_setting_b_forced(sesskey, \"ProxyLocalhost\", conf_get_bool(conf, CONF_even_proxy_localhost));\n    write_setting_i_forced(sesskey, \"ProxyMethod\", conf_get_int(conf, CONF_proxy_type));\n    write_setting_s_forced(sesskey, \"ProxyHost\", conf_get_str(conf, CONF_proxy_host));\n    write_setting_i_forced(sesskey, \"ProxyPort\", conf_get_int(conf, CONF_proxy_port));\n    write_setting_s_forced(sesskey, \"ProxyUsername\", conf_get_str(conf, CONF_proxy_username));\n    write_setting_s_forced(sesskey, \"ProxyPassword\", conf_get_str(conf, CONF_proxy_password));\n    write_setting_s_forced(sesskey, \"ProxyTelnetCommand\", conf_get_str(conf, CONF_proxy_telnet_command));\n    write_setting_i_forced(sesskey, \"ProxyLogToTerm\", conf_get_int(conf, CONF_proxy_log_to_term));\n    wmap_forced(sesskey, \"Environment\", conf, CONF_environmt, true);\n    write_setting_s_forced(sesskey, \"UserName\", conf_get_str(conf, CONF_username));\n    write_setting_b_forced(sesskey, \"UserNameFromEnvironment\", conf_get_bool(conf, CONF_username_from_env));\n    write_setting_s_forced(sesskey, \"LocalUserName\", conf_get_str(conf, CONF_localusername));\n    write_setting_b_forced(sesskey, \"NoPTY\", conf_get_bool(conf, CONF_nopty));\n    write_setting_b_forced(sesskey, \"Compression\", conf_get_bool(conf, CONF_compression));\n    write_setting_b_forced(sesskey, \"TryAgent\", conf_get_bool(conf, CONF_tryagent));\n    write_setting_b_forced(sesskey, \"AgentFwd\", conf_get_bool(conf, CONF_agentfwd));\n#ifndef NO_GSSAPI\n    write_setting_b_forced(sesskey, \"GssapiFwd\", conf_get_bool(conf, CONF_gssapifwd));\n#endif\n    write_setting_b_forced(sesskey, \"ChangeUsername\", conf_get_bool(conf, CONF_change_username));\n    wprefs_forced(sesskey, \"Cipher\", ciphernames, CIPHER_MAX, conf, CONF_ssh_cipherlist);\n    wprefs_forced(sesskey, \"KEX\", kexnames, KEX_MAX, conf, CONF_ssh_kexlist);\n    wprefs_forced(sesskey, \"HostKey\", hknames, HK_MAX, conf, CONF_ssh_hklist);\n    write_setting_b_forced(sesskey, \"PreferKnownHostKeys\", conf_get_bool(conf, CONF_ssh_prefer_known_hostkeys));\n    write_setting_i_forced(sesskey, \"RekeyTime\", conf_get_int(conf, CONF_ssh_rekey_time));\n#ifndef NO_GSSAPI\n    write_setting_i_forced(sesskey, \"GssapiRekey\", conf_get_int(conf, CONF_gssapirekey));\n#endif\n    write_setting_s_forced(sesskey, \"RekeyBytes\", conf_get_str(conf, CONF_ssh_rekey_data));\n    write_setting_b_forced(sesskey, \"SshNoAuth\", conf_get_bool(conf, CONF_ssh_no_userauth));\n    write_setting_b_forced(sesskey, \"SshNoTrivialAuth\", conf_get_bool(conf, CONF_ssh_no_trivial_userauth));\n    write_setting_b_forced(sesskey, \"SshBanner\", conf_get_bool(conf, CONF_ssh_show_banner));\n    write_setting_b_forced(sesskey, \"AuthTIS\", conf_get_bool(conf, CONF_try_tis_auth));\n    write_setting_b_forced(sesskey, \"AuthKI\", conf_get_bool(conf, CONF_try_ki_auth));\n#ifndef NO_GSSAPI\n    write_setting_b_forced(sesskey, \"AuthGSSAPI\", conf_get_bool(conf, CONF_try_gssapi_auth));\n    write_setting_b_forced(sesskey, \"AuthGSSAPIKEX\", conf_get_bool(conf, CONF_try_gssapi_kex));\n    wprefs_forced(sesskey, \"GSSLibs\", gsslibkeywords, ngsslibs, conf, CONF_ssh_gsslist);\n    write_setting_filename_forced(sesskey, \"GSSCustom\", conf_get_filename(conf, CONF_ssh_gss_custom));\n#endif\n    write_setting_b_forced(sesskey, \"SshNoShell\", conf_get_bool(conf, CONF_ssh_no_shell));\n    write_setting_i_forced(sesskey, \"SshProt\", conf_get_int(conf, CONF_sshprot));\n    write_setting_s_forced(sesskey, \"LogHost\", conf_get_str(conf, CONF_loghost));\n    write_setting_b_forced(sesskey, \"SSH2DES\", conf_get_bool(conf, CONF_ssh2_des_cbc));\n    write_setting_filename_forced(sesskey, \"PublicKeyFile\", conf_get_filename(conf, CONF_keyfile));\n    write_setting_s_forced(sesskey, \"RemoteCommand\", conf_get_str(conf, CONF_remote_cmd));\n    write_setting_b_forced(sesskey, \"RFCEnviron\", conf_get_bool(conf, CONF_rfc_environ));\n    write_setting_b_forced(sesskey, \"PassiveTelnet\", conf_get_bool(conf, CONF_passive_telnet));\n    write_setting_b_forced(sesskey, \"BackspaceIsDelete\", conf_get_bool(conf, CONF_bksp_is_delete));\n    write_setting_i_forced(sesskey, \"EnterSendsCrLf\", conf_get_int(conf, CONF_enter_sends_crlf));\n    write_setting_i_forced(sesskey, \"RXVTHomeEnd\", conf_get_int(conf, CONF_rxvt_homeend));\n    write_setting_i_forced(sesskey, \"LinuxFunctionKeys\", conf_get_int(conf, CONF_funky_type));\n    write_setting_b_forced(sesskey, \"NoApplicationKeys\", conf_get_bool(conf, CONF_no_applic_k));\n    write_setting_b_forced(sesskey, \"NoApplicationCursors\", conf_get_bool(conf, CONF_no_applic_c));\n    write_setting_b_forced(sesskey, \"NoMouseReporting\", conf_get_bool(conf, CONF_no_mouse_rep));\n    write_setting_b_forced(sesskey, \"NoRemoteResize\", conf_get_bool(conf, CONF_no_remote_resize));\n    write_setting_b_forced(sesskey, \"NoAltScreen\", conf_get_bool(conf, CONF_no_alt_screen));\n    write_setting_b_forced(sesskey, \"NoRemoteWinTitle\", conf_get_bool(conf, CONF_no_remote_wintitle));\n    write_setting_b_forced(sesskey, \"NoRemoteClearScroll\", conf_get_bool(conf, CONF_no_remote_clearscroll));\n    write_setting_i_forced(sesskey, \"RemoteQTitleAction\", conf_get_int(conf, CONF_remote_qtitle_action));\n    write_setting_b_forced(sesskey, \"NoDBackspace\", conf_get_bool(conf, CONF_no_dbackspace));\n    write_setting_b_forced(sesskey, \"NoRemoteCharset\", conf_get_bool(conf, CONF_no_remote_charset));\n    write_setting_b_forced(sesskey, \"ApplicationCursorKeys\", conf_get_bool(conf, CONF_app_cursor));\n    write_setting_b_forced(sesskey, \"ApplicationKeypad\", conf_get_bool(conf, CONF_app_keypad));\n    write_setting_b_forced(sesskey, \"NetHackKeypad\", conf_get_bool(conf, CONF_nethack_keypad));\n    write_setting_b_forced(sesskey, \"AltF4\", conf_get_bool(conf, CONF_alt_f4));\n    write_setting_b_forced(sesskey, \"AltSpace\", conf_get_bool(conf, CONF_alt_space));\n    write_setting_b_forced(sesskey, \"AltOnly\", conf_get_bool(conf, CONF_alt_only));\n    write_setting_b_forced(sesskey, \"ComposeKey\", conf_get_bool(conf, CONF_compose_key));\n    write_setting_b_forced(sesskey, \"CtrlAltKeys\", conf_get_bool(conf, CONF_ctrlaltkeys));\n#ifdef OSX_META_KEY_CONFIG\n    write_setting_b_forced(sesskey, \"OSXOptionMeta\", conf_get_bool(conf, CONF_osx_option_meta));\n    write_setting_b_forced(sesskey, \"OSXCommandMeta\", conf_get_bool(conf, CONF_osx_command_meta));\n#endif\n    write_setting_b_forced(sesskey, \"TelnetKey\", conf_get_bool(conf, CONF_telnet_keyboard));\n    write_setting_b_forced(sesskey, \"TelnetRet\", conf_get_bool(conf, CONF_telnet_newline));\n    write_setting_i_forced(sesskey, \"LocalEcho\", conf_get_int(conf, CONF_localecho));\n    write_setting_i_forced(sesskey, \"LocalEdit\", conf_get_int(conf, CONF_localedit));\n    write_setting_s_forced(sesskey, \"Answerback\", conf_get_str(conf, CONF_answerback));\n    write_setting_b_forced(sesskey, \"AlwaysOnTop\", conf_get_bool(conf, CONF_alwaysontop));\n    write_setting_b_forced(sesskey, \"FullScreenOnAltEnter\", conf_get_bool(conf, CONF_fullscreenonaltenter));\n    write_setting_b_forced(sesskey, \"HideMousePtr\", conf_get_bool(conf, CONF_hide_mouseptr));\n    write_setting_b_forced(sesskey, \"SunkenEdge\", conf_get_bool(conf, CONF_sunken_edge));\n    write_setting_i_forced(sesskey, \"WindowBorder\", conf_get_int(conf, CONF_window_border));\n    write_setting_i_forced(sesskey, \"CurType\", conf_get_int(conf, CONF_cursor_type));\n    write_setting_b_forced(sesskey, \"BlinkCur\", conf_get_bool(conf, CONF_blink_cur));\n    write_setting_i_forced(sesskey, \"Beep\", conf_get_int(conf, CONF_beep));\n    write_setting_i_forced(sesskey, \"BeepInd\", conf_get_int(conf, CONF_beep_ind));\n    write_setting_filename_forced(sesskey, \"BellWaveFile\", conf_get_filename(conf, CONF_bell_wavefile));\n    write_setting_b_forced(sesskey, \"BellOverload\", conf_get_bool(conf, CONF_bellovl));\n    write_setting_i_forced(sesskey, \"BellOverloadN\", conf_get_int(conf, CONF_bellovl_n));\n    write_setting_i_forced(sesskey, \"BellOverloadT\", conf_get_int(conf, CONF_bellovl_t)\n#ifdef PUTTY_UNIX_H\n\t\t    * 1000\n#endif\n\t\t    );\n    write_setting_i_forced(sesskey, \"BellOverloadS\", conf_get_int(conf, CONF_bellovl_s)\n#ifdef PUTTY_UNIX_H\n\t\t    * 1000\n#endif\n\t\t    );\n    write_setting_i_forced(sesskey, \"ScrollbackLines\", conf_get_int(conf, CONF_savelines));\n    write_setting_b_forced(sesskey, \"DECOriginMode\", conf_get_bool(conf, CONF_dec_om));\n    write_setting_b_forced(sesskey, \"AutoWrapMode\", conf_get_bool(conf, CONF_wrap_mode));\n    write_setting_b_forced(sesskey, \"LFImpliesCR\", conf_get_bool(conf, CONF_lfhascr));\n    write_setting_b_forced(sesskey, \"CRImpliesLF\", conf_get_bool(conf, CONF_crhaslf));\n    write_setting_b_forced(sesskey, \"DisableArabicShaping\", conf_get_bool(conf, CONF_no_arabicshaping));\n    write_setting_b_forced(sesskey, \"DisableBidi\", conf_get_bool(conf, CONF_no_bidi));\n    write_setting_b_forced(sesskey, \"WinNameAlways\", conf_get_bool(conf, CONF_win_name_always));\n    write_setting_s_forced(sesskey, \"WinTitle\", conf_get_str(conf, CONF_wintitle));\n    write_setting_i_forced(sesskey, \"TermWidth\", conf_get_int(conf, CONF_width));\n    write_setting_i_forced(sesskey, \"TermHeight\", conf_get_int(conf, CONF_height));\n    write_setting_fontspec_forced(sesskey, \"Font\", conf_get_fontspec(conf, CONF_font));\n    write_setting_i_forced(sesskey, \"FontQuality\", conf_get_int(conf, CONF_font_quality));\n    write_setting_i_forced(sesskey, \"FontVTMode\", conf_get_int(conf, CONF_vtmode));\n    write_setting_b_forced(sesskey, \"UseSystemColours\", conf_get_bool(conf, CONF_system_colour));\n    write_setting_b_forced(sesskey, \"TryPalette\", conf_get_bool(conf, CONF_try_palette));\n    write_setting_b_forced(sesskey, \"ANSIColour\", conf_get_bool(conf, CONF_ansi_colour));\n    write_setting_b_forced(sesskey, \"Xterm256Colour\", conf_get_bool(conf, CONF_xterm_256_colour));\n    write_setting_b_forced(sesskey, \"TrueColour\", conf_get_bool(conf, CONF_true_colour));\n    write_setting_i_forced(sesskey, \"BoldAsColour\", conf_get_int(conf, CONF_bold_style)-1);\n\n#ifdef MOD_TUTTY\n    write_setting_i_forced(sesskey, \"WindowClosable\", conf_get_int(conf, CONF_window_closable) );\n    write_setting_i_forced(sesskey, \"WindowMinimizable\", conf_get_int(conf, CONF_window_minimizable) );\n    write_setting_i_forced(sesskey, \"WindowMaximizable\", conf_get_int(conf, CONF_window_maximizable) );\n    write_setting_i_forced(sesskey, \"WindowHasSysMenu\", conf_get_int(conf, CONF_window_has_sysmenu) );\n    write_setting_i_forced(sesskey, \"DisableBottomButtons\", conf_get_int(conf, CONF_bottom_buttons) );\n#endif\n#ifdef MOD_TUTTYCOLOR\n    write_setting_i_forced(sesskey, \"BoldAsColourTest\", conf_get_int(conf, CONF_bold_colour) );\n    write_setting_i_forced(sesskey, \"UnderlinedAsColour\", conf_get_int(conf, CONF_under_colour) );\n    write_setting_i_forced(sesskey, \"SelectedAsColour\", conf_get_int(conf, CONF_sel_colour) );\n    for (i = 0; i < 34; i++) {\n#else\n    for (i = 0; i < 22; i++) {\n#endif\n\tchar buf[20], buf2[30];\n\tsprintf(buf, \"Colour%d\", i);\n\tsprintf(buf2, \"%d,%d,%d\",\n\t\tconf_get_int_int(conf, CONF_colours, i*3+0),\n\t\tconf_get_int_int(conf, CONF_colours, i*3+1),\n\t\tconf_get_int_int(conf, CONF_colours, i*3+2));\n\twrite_setting_s_forced(sesskey, buf, buf2);\n    }\n    write_setting_b_forced(sesskey, \"RawCNP\", conf_get_bool(conf, CONF_rawcnp));\n    write_setting_b_forced(sesskey, \"UTF8linedraw\", conf_get_bool(conf, CONF_utf8linedraw));\n    write_setting_b_forced(sesskey, \"PasteRTF\", conf_get_bool(conf, CONF_rtf_paste));\n    write_setting_i_forced(sesskey, \"MouseIsXterm\", conf_get_int(conf, CONF_mouse_is_xterm));\n    write_setting_b_forced(sesskey, \"RectSelect\", conf_get_bool(conf, CONF_rect_select));\n    write_setting_b_forced(sesskey, \"PasteControls\", conf_get_bool(conf, CONF_paste_controls));\n    write_setting_b_forced(sesskey, \"MouseOverride\", conf_get_bool(conf, CONF_mouse_override));\n\n    for (i = 0; i < 256; i += 32) {\n\tchar buf[20], buf2[256];\n\tint j;\n\tsprintf(buf, \"Wordness%d\", i);\n\t*buf2 = '\\0';\n\tfor (j = i; j < i + 32; j++) {\n\t    sprintf(buf2 + strlen(buf2), \"%s%d\",\n\t\t    (*buf2 ? \",\" : \"\"),\n\t\t    conf_get_int_int(conf, CONF_wordness, j));\n\t}\n\twrite_setting_s_forced(sesskey, buf, buf2);\n    }\n\n    write_setting_b_forced(sesskey, \"MouseAutocopy\",\n                    conf_get_bool(conf, CONF_mouseautocopy));\n    write_clip_setting_forced(sesskey, \"MousePaste\", conf,\n                       CONF_mousepaste, CONF_mousepaste_custom);\n    write_clip_setting_forced(sesskey, \"CtrlShiftIns\", conf,\n                       CONF_ctrlshiftins, CONF_ctrlshiftins_custom);\n    write_clip_setting_forced(sesskey, \"CtrlShiftCV\", conf,\n                       CONF_ctrlshiftcv, CONF_ctrlshiftcv_custom);\n    write_setting_s_forced(sesskey, \"LineCodePage\", conf_get_str(conf, CONF_line_codepage));\n    write_setting_b_forced(sesskey, \"CJKAmbigWide\", conf_get_bool(conf, CONF_cjk_ambig_wide));\n    write_setting_b_forced(sesskey, \"UTF8Override\", conf_get_bool(conf, CONF_utf8_override));\n    write_setting_s_forced(sesskey, \"Printer\", conf_get_str(conf, CONF_printer));\n    write_setting_b_forced(sesskey, \"CapsLockCyr\", conf_get_bool(conf, CONF_xlat_capslockcyr));\n    write_setting_b_forced(sesskey, \"ScrollBar\", conf_get_bool(conf, CONF_scrollbar));\n    write_setting_b_forced(sesskey, \"ScrollBarFullScreen\", conf_get_bool(conf, CONF_scrollbar_in_fullscreen));\n    write_setting_b_forced(sesskey, \"ScrollOnKey\", conf_get_bool(conf, CONF_scroll_on_key));\n    write_setting_b_forced(sesskey, \"ScrollOnDisp\", conf_get_bool(conf, CONF_scroll_on_disp));\n    write_setting_b_forced(sesskey, \"EraseToScrollback\", conf_get_bool(conf, CONF_erase_to_scrollback));\n    write_setting_i_forced(sesskey, \"LockSize\", conf_get_int(conf, CONF_resize_action));\n    write_setting_b_forced(sesskey, \"BCE\", conf_get_bool(conf, CONF_bce));\n    write_setting_b_forced(sesskey, \"BlinkText\", conf_get_bool(conf, CONF_blinktext));\n    write_setting_b_forced(sesskey, \"X11Forward\", conf_get_bool(conf, CONF_x11_forward));\n    write_setting_s_forced(sesskey, \"X11Display\", conf_get_str(conf, CONF_x11_display));\n    write_setting_i_forced(sesskey, \"X11AuthType\", conf_get_int(conf, CONF_x11_auth));\n    write_setting_filename_forced(sesskey, \"X11AuthFile\", conf_get_filename(conf, CONF_xauthfile));\n    write_setting_b_forced(sesskey, \"LocalPortAcceptAll\", conf_get_bool(conf, CONF_lport_acceptall));\n    write_setting_b_forced(sesskey, \"RemotePortAcceptAll\", conf_get_bool(conf, CONF_rport_acceptall));\n    wmap_forced(sesskey, \"PortForwardings\", conf, CONF_portfwd, true);\n    write_setting_i_forced(sesskey, \"BugIgnore1\", 2-conf_get_int(conf, CONF_sshbug_ignore1));\n    write_setting_i_forced(sesskey, \"BugPlainPW1\", 2-conf_get_int(conf, CONF_sshbug_plainpw1));\n    write_setting_i_forced(sesskey, \"BugRSA1\", 2-conf_get_int(conf, CONF_sshbug_rsa1));\n    write_setting_i_forced(sesskey, \"BugIgnore2\", 2-conf_get_int(conf, CONF_sshbug_ignore2));\n    write_setting_i_forced(sesskey, \"BugHMAC2\", 2-conf_get_int(conf, CONF_sshbug_hmac2));\n    write_setting_i_forced(sesskey, \"BugDeriveKey2\", 2-conf_get_int(conf, CONF_sshbug_derivekey2));\n    write_setting_i_forced(sesskey, \"BugRSAPad2\", 2-conf_get_int(conf, CONF_sshbug_rsapad2));\n    write_setting_i_forced(sesskey, \"BugPKSessID2\", 2-conf_get_int(conf, CONF_sshbug_pksessid2));\n    write_setting_i_forced(sesskey, \"BugRekey2\", 2-conf_get_int(conf, CONF_sshbug_rekey2));\n    write_setting_i_forced(sesskey, \"BugMaxPkt2\", 2-conf_get_int(conf, CONF_sshbug_maxpkt2));\n    write_setting_i_forced(sesskey, \"BugOldGex2\", 2-conf_get_int(conf, CONF_sshbug_oldgex2));\n    write_setting_i_forced(sesskey, \"BugWinadj\", 2-conf_get_int(conf, CONF_sshbug_winadj));\n    write_setting_i_forced(sesskey, \"BugChanReq\", 2-conf_get_int(conf, CONF_sshbug_chanreq));\n    write_setting_b_forced(sesskey, \"StampUtmp\", conf_get_bool(conf, CONF_stamp_utmp));\n    write_setting_b_forced(sesskey, \"LoginShell\", conf_get_bool(conf, CONF_login_shell));\n    write_setting_b_forced(sesskey, \"ScrollbarOnLeft\", conf_get_bool(conf, CONF_scrollbar_on_left));\n    write_setting_fontspec_forced(sesskey, \"BoldFont\", conf_get_fontspec(conf, CONF_boldfont));\n    write_setting_fontspec_forced(sesskey, \"WideFont\", conf_get_fontspec(conf, CONF_widefont));\n    write_setting_fontspec_forced(sesskey, \"WideBoldFont\", conf_get_fontspec(conf, CONF_wideboldfont));\n    write_setting_b_forced(sesskey, \"ShadowBold\", conf_get_bool(conf, CONF_shadowbold));\n    write_setting_i_forced(sesskey, \"ShadowBoldOffset\", conf_get_int(conf, CONF_shadowboldoffset));\n    write_setting_s_forced(sesskey, \"SerialLine\", conf_get_str(conf, CONF_serline));\n    write_setting_i_forced(sesskey, \"SerialSpeed\", conf_get_int(conf, CONF_serspeed));\n    write_setting_i_forced(sesskey, \"SerialDataBits\", conf_get_int(conf, CONF_serdatabits));\n    write_setting_i_forced(sesskey, \"SerialStopHalfbits\", conf_get_int(conf, CONF_serstopbits));\n    write_setting_i_forced(sesskey, \"SerialParity\", conf_get_int(conf, CONF_serparity));\n    write_setting_i_forced(sesskey, \"SerialFlowControl\", conf_get_int(conf, CONF_serflow));\n    write_setting_s_forced(sesskey, \"WindowClass\", conf_get_str(conf, CONF_winclass));\n    write_setting_b_forced(sesskey, \"ConnectionSharing\", conf_get_bool(conf, CONF_ssh_connection_sharing));\n    write_setting_b_forced(sesskey, \"ConnectionSharingUpstream\", conf_get_bool(conf, CONF_ssh_connection_sharing_upstream));\n    write_setting_b_forced(sesskey, \"ConnectionSharingDownstream\", conf_get_bool(conf, CONF_ssh_connection_sharing_downstream));\n    wmap_forced(sesskey, \"SSHManualHostKeys\", conf, CONF_ssh_manual_hostkeys, false);\n    \n    /*\n     * PuTTY 0.75 SUPDUP settings\n\n    write_setting_s_forced(sesskey, \"SUPDUPLocation\", conf_get_str(conf, CONF_supdup_location));\n    write_setting_i_forced(sesskey, \"SUPDUPCharset\", conf_get_int(conf, CONF_supdup_ascii_set));\n    write_setting_b_forced(sesskey, \"SUPDUPMoreProcessing\", conf_get_bool(conf, CONF_supdup_more));\n    write_setting_b_forced(sesskey, \"SUPDUPScrolling\", conf_get_bool(conf, CONF_supdup_scroll));\n     */\n#ifdef MOD_PROXY\n    write_setting_s_forced(sesskey, \"ProxySelection\", conf_get_str(conf, CONF_proxyselection));\n#endif\n/* rutty: */\n#ifdef MOD_RUTTY\n    write_setting_filename_forced(sesskey, \"ScriptFileName\", conf_get_filename(conf, CONF_script_filename));\n    write_setting_i_forced(sesskey, \"ScriptMode\", (conf_get_int(conf, CONF_script_mode)!=SCRIPT_PLAY)?SCRIPT_STOP:conf_get_int(conf, CONF_script_mode));  /* dont save with record on */\n    write_setting_i_forced(sesskey, \"ScriptLineDelay\", conf_get_int(conf, CONF_script_line_delay));\n    write_setting_i_forced(sesskey, \"ScriptCharDelay\", conf_get_int(conf, CONF_script_char_delay));\n    write_setting_s_forced(sesskey, \"ScriptCondLine\", conf_get_str(conf, CONF_script_cond_line));\n    write_setting_i_forced(sesskey, \"ScriptCondUse\", conf_get_int(conf, CONF_script_cond_use));\n    write_setting_i_forced(sesskey, \"ScriptCRLF\", conf_get_int(conf, CONF_script_crlf));\n    write_setting_i_forced(sesskey, \"ScriptEnable\", conf_get_int(conf, CONF_script_enable));\n    write_setting_i_forced(sesskey, \"ScriptExcept\", conf_get_int(conf, CONF_script_except));\n    write_setting_i_forced(sesskey, \"ScriptTimeout\", conf_get_int(conf, CONF_script_timeout));\n    write_setting_s_forced(sesskey, \"ScriptWait\", conf_get_str(conf, CONF_script_waitfor));\n    write_setting_s_forced(sesskey, \"ScriptHalt\", conf_get_str(conf, CONF_script_halton));\n#endif  /* rutty */\n#ifdef MOD_RECONNECT\n    write_setting_i_forced(sesskey, \"WakeupReconnect\", conf_get_int(conf,CONF_wakeup_reconnect) );\n    write_setting_i_forced(sesskey, \"FailureReconnect\", conf_get_int(conf,CONF_failure_reconnect) );\n#endif\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n\tif( GetBackgroundImageFlag() ) {\n    write_setting_i_forced(sesskey, \"BgOpacity\", conf_get_int(conf, CONF_bg_opacity) );\n    write_setting_i_forced(sesskey, \"BgSlideshow\", conf_get_int(conf, CONF_bg_slideshow) );\n    write_setting_i_forced(sesskey, \"BgType\", conf_get_int(conf, CONF_bg_type) );\n    write_setting_filename_forced(sesskey, \"BgImageFile\", conf_get_filename(conf, CONF_bg_image_filename) );\n    write_setting_i_forced(sesskey, \"BgImageStyle\", conf_get_int(conf, CONF_bg_image_style) );\n    write_setting_i_forced(sesskey, \"BgImageAbsoluteX\", conf_get_int(conf, CONF_bg_image_abs_x) );\n    write_setting_i_forced(sesskey, \"BgImageAbsoluteY\", conf_get_int(conf, CONF_bg_image_abs_y) );\n    write_setting_i_forced(sesskey, \"BgImagePlacement\", conf_get_int(conf, CONF_bg_image_abs_fixed) );\n\t}\n#endif\n#ifdef MOD_HYPERLINK\n\t/*\n\t * HACK: PuttyTray / Nutty\n\t * Hyperlink stuff: Save hyperlink settings\n\t */\n\twrite_setting_i_forced(sesskey, \"HyperlinkUnderline\", conf_get_int(conf, CONF_url_underline));\n\twrite_setting_i_forced(sesskey, \"HyperlinkUseCtrlClick\", conf_get_int(conf, CONF_url_ctrl_click));\n\twrite_setting_i_forced(sesskey, \"HyperlinkBrowserUseDefault\", conf_get_int(conf, CONF_url_defbrowser));\n\twrite_setting_filename_forced(sesskey, \"HyperlinkBrowser\", conf_get_filename(conf, CONF_url_browser));\n\twrite_setting_i_forced(sesskey, \"HyperlinkRegularExpressionUseDefault\", conf_get_int(conf, CONF_url_defregex));\n#ifndef MOD_NOHYPERLINK\n\tif( !strcmp(conf_get_str(conf, CONF_url_regex),\"@°@°@NO REGEX--\") ) \n\t\twrite_setting_s_forced(sesskey, \"HyperlinkRegularExpression\", urlhack_default_regex ) ;\n\telse\n\t\twrite_setting_s_forced(sesskey, \"HyperlinkRegularExpression\", conf_get_str(conf, CONF_url_regex));\n#else\n\twrite_setting_s_forced(sesskey, \"HyperlinkRegularExpression\", conf_get_str(conf, CONF_url_regex));\n#endif\n#endif\n#ifdef MOD_ZMODEM\n    write_setting_filename_forced(sesskey, \"rzCommand\", conf_get_filename(conf, CONF_rzcommand) );\n    write_setting_s_forced(sesskey, \"rzOptions\", conf_get_str(conf, CONF_rzoptions) );\n    write_setting_filename_forced(sesskey, \"szCommand\", conf_get_filename(conf, CONF_szcommand) );\n    write_setting_s_forced(sesskey, \"szOptions\", conf_get_str(conf, CONF_szoptions) );\n    write_setting_s_forced(sesskey, \"zDownloadDir\", conf_get_str(conf, CONF_zdownloaddir) );\n#endif\n#ifdef MOD_PERSO\n    if( conf_get_int(conf, CONF_transparencynumber)<-1 ) conf_set_int(conf, CONF_transparencynumber,-1) ;\n    if( conf_get_int(conf, CONF_transparencynumber)>255 ) conf_set_int(conf, CONF_transparencynumber,255) ;\n    write_setting_s_forced(sesskey, \"HostAlt\", conf_get_str(conf, CONF_host_alt) );\n    write_setting_i_forced(sesskey, \"TransparencyValue\", conf_get_int(conf, CONF_transparencynumber) ) ;\n    write_setting_i_forced(sesskey, \"SendToTray\", conf_get_int(conf, CONF_sendtotray) );\n    write_setting_i_forced(sesskey, \"Maximize\", conf_get_int(conf, CONF_maximize) );\n    write_setting_i_forced(sesskey, \"Fullscreen\", conf_get_int(conf, CONF_fullscreen) );\n    write_setting_b_forced(sesskey, \"SaveOnExit\", conf_get_bool(conf, CONF_saveonexit) );\n    write_setting_i_forced(sesskey, \"Icone\", conf_get_int(conf, CONF_icone) );\n    write_setting_filename_forced(sesskey, \"IconeFile\", conf_get_filename(conf, CONF_iconefile) );\n    write_setting_i_forced(sesskey, \"WinSCPProtocol\", conf_get_int(conf, CONF_winscpprot) );\n    write_setting_s_forced(sesskey, \"SFTPConnect\", conf_get_str(conf, CONF_sftpconnect) );\n    write_setting_s_forced(sesskey, \"PSCPOptions\", conf_get_str(conf, CONF_pscpoptions) );\n    write_setting_s_forced(sesskey, \"PSCPShell\", conf_get_str(conf, CONF_pscpshell) );\n    write_setting_s_forced(sesskey, \"PSCPRemoteDir\", conf_get_str(conf, CONF_pscpremotedir) );\n    write_setting_s_forced(sesskey, \"WinSCPOptions\", conf_get_str(conf, CONF_winscpoptions) );\n    write_setting_s_forced(sesskey, \"WinSCPRawSettings\", conf_get_str(conf, CONF_winscprawsettings) );\n    Filename * fn = filename_from_str( \"\" ) ;\n    conf_set_filename(conf,CONF_scriptfile,fn);\n    write_setting_filename_forced(sesskey, \"Scriptfile\", conf_get_filename(conf, CONF_scriptfile) );  // C'est le contenu uniquement qui est important a sauvegarder\n    filename_free(fn);\n    write_setting_s_forced(sesskey, \"ScriptfileContent\", conf_get_str(conf, CONF_scriptfilecontent) );\n    write_setting_s_forced(sesskey, \"AntiIdle\", conf_get_str(conf, CONF_antiidle) );\n    write_setting_s_forced(sesskey, \"LogTimestamp\", conf_get_str(conf, CONF_logtimestamp) );\n    write_setting_s_forced(sesskey, \"Autocommand\", conf_get_str(conf, CONF_autocommand) );\n    write_setting_s_forced(sesskey, \"AutocommandOut\", conf_get_str(conf, CONF_autocommandout) );\n    write_setting_s_forced(sesskey, \"Folder\", conf_get_str(conf, CONF_folder) ) ;\n    write_setting_i_forced(sesskey, \"LogTimeRotation\", conf_get_int(conf, CONF_logtimerotation) ) ;\n    write_setting_i_forced(sesskey, \"TermXPos\", conf_get_int(conf, CONF_xpos) ) ;\n    write_setting_i_forced(sesskey, \"TermYPos\", conf_get_int(conf, CONF_ypos) ) ;\n    write_setting_i_forced(sesskey, \"WindowState\", conf_get_int(conf, CONF_windowstate) ) ;\n    write_setting_b_forced(sesskey, \"SaveWindowPos\", conf_get_bool(conf, CONF_save_windowpos) ); /* BKG */\n    write_setting_b_forced(sesskey, \"ForegroundOnBell\", conf_get_bool(conf, CONF_foreground_on_bell) );\n\n#ifndef MOD_NOPASSWORD\n    char pst[4096] ;\n    strcpy( pst, conf_get_str(conf, CONF_password ) );\n    MASKPASS(GetCryptSaltFlag(),pst);\n    cryptpassword( GetCryptSaltFlag(), pst, conf_get_str(conf, CONF_host), conf_get_str(conf, CONF_termtype) ) ;\n    write_setting_s_forced(sesskey, \"Password\", pst);\n    memset(pst,0,strlen(pst));\n#endif\n    write_setting_i_forced(sesskey, \"CtrlTabSwitch\", conf_get_int(conf, CONF_ctrl_tab_switch));\n    write_setting_s_forced(sesskey, \"Comment\", conf_get_str(conf, CONF_comment) );\n    write_setting_i_forced(sesskey, \"SCPAutoPwd\", conf_get_int(conf, CONF_scp_auto_pwd));\n    write_setting_b_forced(sesskey, \"NoFocusReporting\", conf_get_bool(conf, CONF_no_focus_rep));\n    write_setting_i_forced(sesskey, \"LinesAtAScroll\", conf_get_int(conf, CONF_scrolllines));\n    write_setting_b_forced(sesskey, \"SSHTunnelInTitle\", conf_get_bool(conf, CONF_ssh_tunnel_print_in_title));\n    write_setting_b_forced(sesskey, \"OSC52WarnBeforeClipboardSync\", conf_get_bool(conf, CONF_osc52_warn_before_cliboard_sync));\n#endif\n#ifdef MOD_PORTKNOCKING\n\twrite_setting_s_forced(sesskey, \"PortKnocking\", conf_get_str(conf, CONF_portknockingoptions) );\n#endif\n#ifdef MOD_DISABLEALTGR\n\twrite_setting_i_forced(sesskey, \"DisableAltGr\", conf_get_int(conf, CONF_disablealtgr));\n#endif\n// END COPY/PASTE\n\tfclose(sesskey) ;\n}\n\n\n\nvoid load_open_settings_forced(char *filename, Conf *conf) {\n\tFILE *sesskey ;\n\tif( (sesskey=fopen(filename,\"r\")) == NULL ) { \n\t\tchar buffer[1024] ;\n\t\tsprintf(buffer,\"File %s not found !\",filename);\n\t\tMessageBox(NULL, buffer, \"Error\", MB_OK|MB_ICONERROR) ; return ; \n\t\t}\n\tConf * confDef ;\n\tconfDef = conf_new() ;\n\tdo_defaults( \"Default Settings\" , confDef);\n\t\t\n// BEGIN COPY/PASTE\n    int i;\n    char *prot;\n#ifdef MOD_PERSO\n    /*\n     * HACK: PuTTY-url\n     * Set font quality to cleartype on Windows Vista and above\n     */\n    OSVERSIONINFO versioninfo;\n    versioninfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n    GetVersionEx(&versioninfo);\n#endif\n    conf_set_bool(conf, CONF_ssh_subsys, false); /* FIXME: load this properly */\n    conf_set_str(conf, CONF_remote_cmd, \"\");\n    conf_set_str(conf, CONF_remote_cmd2, \"\");\n    conf_set_str(conf, CONF_ssh_nc_host, \"\");\n\n    gpps_forced(sesskey, \"HostName\", \"\", conf, CONF_host);\n    gppfile_forced(sesskey, \"LogFileName\", conf, CONF_logfilename);\n    gppi_forced(sesskey, \"LogType\", 0, conf, CONF_logtype);\n    gppi_forced(sesskey, \"LogFileClash\", LGXF_ASK, conf, CONF_logxfovr);\n    gppb_forced(sesskey, \"LogFlush\", true, conf, CONF_logflush);\n    gppb_forced(sesskey, \"LogHeader\", true, conf, CONF_logheader);\n    gppb_forced(sesskey, \"SSHLogOmitPasswords\", true, conf, CONF_logomitpass);\n    gppb_forced(sesskey, \"SSHLogOmitData\", false, conf, CONF_logomitdata);\n\n    prot = gpps_raw_forced(sesskey, \"Protocol\", \"default\");\n    conf_set_int(conf, CONF_protocol, default_protocol);\n    conf_set_int(conf, CONF_port, default_port);\n    {\n        const struct BackendVtable *vt = backend_vt_from_name(prot);\n        if (vt) {\n            conf_set_int(conf, CONF_protocol, vt->protocol);\n\t    gppi_forced(sesskey, \"PortNumber\", default_port, conf, CONF_port);\n\t}\n    }\n    sfree(prot);\n\n    /* Address family selection */\n    gppi_forced(sesskey, \"AddressFamily\", ADDRTYPE_UNSPEC, conf, CONF_addressfamily);\n\n    /* The CloseOnExit numbers are arranged in a different order from\n     * the standard FORCE_ON / FORCE_OFF / AUTO. */\n    i = gppi_raw_forced(sesskey, \"CloseOnExit\", 1); conf_set_int(conf, CONF_close_on_exit, (i+1)%3);\n    gppb_forced(sesskey, \"WarnOnClose\", true, conf, CONF_warn_on_close);\n    {\n\t/* This is two values for backward compatibility with 0.50/0.51 */\n\tint pingmin, pingsec;\n\tpingmin = gppi_raw_forced(sesskey, \"PingInterval\", 0);\n\tpingsec = gppi_raw_forced(sesskey, \"PingIntervalSecs\", 0);\n\tconf_set_int(conf, CONF_ping_interval, pingmin * 60 + pingsec);\n    }\n    gppb_forced(sesskey, \"TCPNoDelay\", true, conf, CONF_tcp_nodelay);\n    gppb_forced(sesskey, \"TCPKeepalives\", false, conf, CONF_tcp_keepalives);\n    gpps_forced(sesskey, \"TerminalType\", \"xterm\", conf, CONF_termtype);\n    gpps_forced(sesskey, \"TerminalSpeed\", \"38400,38400\", conf, CONF_termspeed);\n    if (gppmap_forced(sesskey, \"TerminalModes\", conf, CONF_ttymodes)) {\n\t/*\n\t * Backwards compatibility with old saved settings.\n\t *\n\t * From the invention of this setting through 0.67, the set of\n\t * terminal modes was fixed, and absence of a mode from this\n\t * setting meant the user had explicitly removed it from the\n\t * UI and we shouldn't send it.\n\t *\n\t * In 0.68, the IUTF8 mode was added, and in handling old\n\t * settings we inadvertently removed the ability to not send\n\t * a mode. Any mode not mentioned was treated as if it was\n\t * set to 'auto' (A).\n\t *\n\t * After 0.68, we added explicit notation to the setting format\n\t * when the user removes a known terminal mode from the list.\n\t *\n\t * So: if any of the modes from the original set is missing, we\n\t * assume this was an intentional removal by the user and add\n\t * an explicit removal ('N'); but if IUTF8 (or any other mode\n\t * added after 0.67) is missing, we assume that its absence is\n\t * due to the setting being old rather than intentional, and\n\t * add it with its default setting.\n\t *\n\t * (This does mean that if a 0.68 user explicitly removed IUTF8,\n\t * we add it back; but removing IUTF8 had no effect in 0.68, so\n\t * we're preserving behaviour, which is the best we can do.)\n\t */\n\tfor (i = 0; ttymodes[i]; i++) {\n\t    if (!conf_get_str_str_opt(conf, CONF_ttymodes, ttymodes[i])) {\n\t\t/* Mode not mentioned in setting. */\n\t\tconst char *def;\n\t\tif (!strcmp(ttymodes[i], \"IUTF8\")) {\n\t\t    /* Any new modes we add in future should be treated\n\t\t     * this way too. */\n\t\t    def = \"A\";  /* same as new-setting default below */\n\t\t} else {\n\t\t    /* One of the original modes. Absence is probably\n\t\t     * deliberate. */\n\t\t    def = \"N\";  /* don't send */\n\t\t}\n\t\tconf_set_str_str(conf, CONF_ttymodes, ttymodes[i], def);\n\t    }\n\t}\n    } else {\n\t/* This hardcodes a big set of defaults in any new saved\n\t * sessions. Let's hope we don't change our mind. */\n\tfor (i = 0; ttymodes[i]; i++)\n\t    conf_set_str_str(conf, CONF_ttymodes, ttymodes[i], \"A\");\n    }\n\n    /* proxy settings */\n    gpps_forced(sesskey, \"ProxyExcludeList\", \"\", conf, CONF_proxy_exclude_list);\n    i = gppi_raw_forced(sesskey, \"ProxyDNS\", 1); conf_set_int(conf, CONF_proxy_dns, (i+1)%3);\n    gppb_forced(sesskey, \"ProxyLocalhost\", false, conf, CONF_even_proxy_localhost);\n    gppi_forced(sesskey, \"ProxyMethod\", -1, conf, CONF_proxy_type);\n    if (conf_get_int(conf, CONF_proxy_type) == -1) {\n        int i;\n        i = gppi_raw_forced(sesskey, \"ProxyType\", 0);\n        if (i == 0)\n            conf_set_int(conf, CONF_proxy_type, PROXY_NONE);\n        else if (i == 1)\n            conf_set_int(conf, CONF_proxy_type, PROXY_HTTP);\n        else if (i == 3)\n            conf_set_int(conf, CONF_proxy_type, PROXY_TELNET);\n        else if (i == 4)\n            conf_set_int(conf, CONF_proxy_type, PROXY_CMD);\n        else {\n            i = gppi_raw_forced(sesskey, \"ProxySOCKSVersion\", 5);\n            if (i == 5)\n                conf_set_int(conf, CONF_proxy_type, PROXY_SOCKS5);\n            else\n                conf_set_int(conf, CONF_proxy_type, PROXY_SOCKS4);\n        }\n    }\n    gpps_forced(sesskey, \"ProxyHost\", \"proxy\", conf, CONF_proxy_host);\n    gppi_forced(sesskey, \"ProxyPort\", 80, conf, CONF_proxy_port);\n    gpps_forced(sesskey, \"ProxyUsername\", \"\", conf, CONF_proxy_username);\n    gpps_forced(sesskey, \"ProxyPassword\", \"\", conf, CONF_proxy_password);\n    gpps_forced(sesskey, \"ProxyTelnetCommand\", \"connect %host %port\\\\n\",\n\t conf, CONF_proxy_telnet_command);\n    gppi_forced(sesskey, \"ProxyLogToTerm\", FORCE_OFF, conf, CONF_proxy_log_to_term);\n    gppmap_forced(sesskey, \"Environment\", conf, CONF_environmt);\n    gpps_forced(sesskey, \"UserName\", \"\", conf, CONF_username);\n    gppb_forced(sesskey, \"UserNameFromEnvironment\", false,\n         conf, CONF_username_from_env);\n    gpps_forced(sesskey, \"LocalUserName\", \"\", conf, CONF_localusername);\n    gppb_forced(sesskey, \"NoPTY\", false, conf, CONF_nopty);\n    gppb_forced(sesskey, \"Compression\", false, conf, CONF_compression);\n    gppb_forced(sesskey, \"TryAgent\", true, conf, CONF_tryagent);\n    gppb_forced(sesskey, \"AgentFwd\", false, conf, CONF_agentfwd);\n    gppb_forced(sesskey, \"ChangeUsername\", false, conf, CONF_change_username);\n#ifndef NO_GSSAPI\n    gppb_forced(sesskey, \"GssapiFwd\", false, conf, CONF_gssapifwd);\n#endif\n    gprefs_forced(sesskey, \"Cipher\", \"\\0\",\n\t   ciphernames, CIPHER_MAX, conf, CONF_ssh_cipherlist);\n    {\n\t/* Backward-compatibility: before 0.58 (when the \"KEX\"\n\t * preference was first added), we had an option to\n\t * disable gex under the \"bugs\" panel after one report of\n\t * a server which offered it then choked, but we never got\n\t * a server version string or any other reports. */\n\tconst char *default_kexes,\n\t\t   *normal_default = \"ecdh,dh-gex-sha1,dh-group14-sha1,rsa,\"\n\t\t       \"WARN,dh-group1-sha1\",\n\t\t   *bugdhgex2_default = \"ecdh,dh-group14-sha1,rsa,\"\n\t\t       \"WARN,dh-group1-sha1,dh-gex-sha1\";\n\tchar *raw;\n\ti = 2 - gppi_raw_forced(sesskey, \"BugDHGEx2\", 0);\n\tif (i == FORCE_ON)\n            default_kexes = bugdhgex2_default;\n\telse\n            default_kexes = normal_default;\n\t/* Migration: after 0.67 we decided we didn't like\n\t * dh-group1-sha1. If it looks like the user never changed\n\t * the defaults, quietly upgrade their settings to demote it.\n\t * (If they did, they're on their own.) */\n\traw = gpps_raw_forced(sesskey, \"KEX\", default_kexes);\n\tassert(raw != NULL);\n\t/* Lack of 'ecdh' tells us this was saved by 0.58-0.67\n\t * inclusive. If it was saved by a later version, we need\n\t * to leave it alone. */\n\tif (strcmp(raw, \"dh-group14-sha1,dh-group1-sha1,rsa,\"\n\t\t   \"WARN,dh-gex-sha1\") == 0) {\n\t    /* Previously migrated from BugDHGEx2. */\n\t    sfree(raw);\n\t    raw = dupstr(bugdhgex2_default);\n\t} else if (strcmp(raw, \"dh-gex-sha1,dh-group14-sha1,\"\n\t\t\t  \"dh-group1-sha1,rsa,WARN\") == 0) {\n\t    /* Untouched old default setting. */\n\t    sfree(raw);\n\t    raw = dupstr(normal_default);\n\t}\n\t/* (For the record: after 0.70, the default algorithm list\n\t * very briefly contained the string 'gss-sha1-krb5'; this was\n\t * never used in any committed version of code, but was left\n\t * over from a pre-commit version of GSS key exchange.\n\t * Mentioned here as it is remotely possible that it will turn\n\t * up in someone's saved settings in future.) */\n\n        gprefs_from_str(raw, kexnames, KEX_MAX, conf, CONF_ssh_kexlist);\n\tsfree(raw);\n    }\n    gprefs_forced(sesskey, \"HostKey\", \"ed25519,ecdsa,rsa,dsa,WARN\",\n           hknames, HK_MAX, conf, CONF_ssh_hklist);\n    gppb_forced(sesskey, \"PreferKnownHostKeys\", true, conf, CONF_ssh_prefer_known_hostkeys);\n    gppi_forced(sesskey, \"RekeyTime\", 60, conf, CONF_ssh_rekey_time);\n#ifndef NO_GSSAPI\n    gppi_forced(sesskey, \"GssapiRekey\", GSS_DEF_REKEY_MINS, conf, CONF_gssapirekey);\n#endif\n    gpps_forced(sesskey, \"RekeyBytes\", \"1G\", conf, CONF_ssh_rekey_data);\n    {\n\t/* SSH-2 only by default */\n\tint sshprot = gppi_raw_forced(sesskey, \"SshProt\", 3);\n\t/* Old sessions may contain the values corresponding to the fallbacks\n\t * we used to allow; migrate them */\n\tif (sshprot == 1)      sshprot = 0; /* => \"SSH-1 only\" */\n\telse if (sshprot == 2) sshprot = 3; /* => \"SSH-2 only\" */\n\tconf_set_int(conf, CONF_sshprot, sshprot);\n    }\n    gpps_forced(sesskey, \"LogHost\", \"\", conf, CONF_loghost);\n    gppb_forced(sesskey, \"SSH2DES\", false, conf, CONF_ssh2_des_cbc);\n    gppb_forced(sesskey, \"SshNoAuth\", false, conf, CONF_ssh_no_userauth);\n    gppb_forced(sesskey, \"SshNoTrivialAuth\", false, conf, CONF_ssh_no_trivial_userauth);\n    gppb_forced(sesskey, \"SshBanner\", true, conf, CONF_ssh_show_banner);\n    gppb_forced(sesskey, \"AuthTIS\", false, conf, CONF_try_tis_auth);\n    gppb_forced(sesskey, \"AuthKI\", true, conf, CONF_try_ki_auth);\n#ifndef NO_GSSAPI\n    gppb_forced(sesskey, \"AuthGSSAPI\", true, conf, CONF_try_gssapi_auth);\n    gppb_forced(sesskey, \"AuthGSSAPIKEX\", true, conf, CONF_try_gssapi_kex);\n    gprefs_forced(sesskey, \"GSSLibs\", \"\\0\",\n\t   gsslibkeywords, ngsslibs, conf, CONF_ssh_gsslist);\n    gppfile_forced(sesskey, \"GSSCustom\", conf, CONF_ssh_gss_custom);\n#endif\n    gppb_forced(sesskey, \"SshNoShell\", false, conf, CONF_ssh_no_shell);\n    gppfile_forced(sesskey, \"PublicKeyFile\", conf, CONF_keyfile);\n    gpps_forced(sesskey, \"RemoteCommand\", \"\", conf, CONF_remote_cmd);\n    gppb_forced(sesskey, \"RFCEnviron\", false, conf, CONF_rfc_environ);\n    gppb_forced(sesskey, \"PassiveTelnet\", false, conf, CONF_passive_telnet);\n    gppb_forced(sesskey, \"BackspaceIsDelete\", true, conf, CONF_bksp_is_delete);\n    gppi_forced(sesskey, \"EnterSendsCrLf\", 0, conf, CONF_enter_sends_crlf);\n    gppi_forced(sesskey, \"RXVTHomeEnd\", 0, conf, CONF_rxvt_homeend);\n    gppi_forced(sesskey, \"LinuxFunctionKeys\", 0, conf, CONF_funky_type);\n    gppb_forced(sesskey, \"NoApplicationKeys\", false, conf, CONF_no_applic_k);\n    gppb_forced(sesskey, \"NoApplicationCursors\", false, conf, CONF_no_applic_c);\n    gppb_forced(sesskey, \"NoMouseReporting\", false, conf, CONF_no_mouse_rep);\n    gppb_forced(sesskey, \"NoRemoteResize\", false, conf, CONF_no_remote_resize);\n    gppb_forced(sesskey, \"NoAltScreen\", false, conf, CONF_no_alt_screen);\n    gppb_forced(sesskey, \"NoRemoteWinTitle\", false, conf, CONF_no_remote_wintitle);\n    gppb_forced(sesskey, \"NoRemoteClearScroll\", false,\n         conf, CONF_no_remote_clearscroll);\n    {\n\t/* Backward compatibility */\n\tint no_remote_qtitle = gppi_raw_forced(sesskey, \"NoRemoteQTitle\", 1);\n\t/* We deliberately interpret the old setting of \"no response\" as\n\t * \"empty string\". This changes the behaviour, but hopefully for\n\t * the better; the user can always recover the old behaviour. */\n\tgppi_forced(sesskey, \"RemoteQTitleAction\",\n\t     no_remote_qtitle ? TITLE_EMPTY : TITLE_REAL,\n\t     conf, CONF_remote_qtitle_action);\n    }\n    gppb_forced(sesskey, \"NoDBackspace\", false, conf, CONF_no_dbackspace);\n    gppb_forced(sesskey, \"NoRemoteCharset\", false, conf, CONF_no_remote_charset);\n    gppb_forced(sesskey, \"ApplicationCursorKeys\", false, conf, CONF_app_cursor);\n    gppb_forced(sesskey, \"ApplicationKeypad\", false, conf, CONF_app_keypad);\n    gppb_forced(sesskey, \"NetHackKeypad\", false, conf, CONF_nethack_keypad);\n    gppb_forced(sesskey, \"AltF4\", true, conf, CONF_alt_f4);\n    gppb_forced(sesskey, \"AltSpace\", false, conf, CONF_alt_space);\n    gppb_forced(sesskey, \"AltOnly\", false, conf, CONF_alt_only);\n    gppb_forced(sesskey, \"ComposeKey\", false, conf, CONF_compose_key);\n    gppb_forced(sesskey, \"CtrlAltKeys\", true, conf, CONF_ctrlaltkeys);\n#ifdef OSX_META_KEY_CONFIG\n    gppb_forced(sesskey, \"OSXOptionMeta\", true, conf, CONF_osx_option_meta);\n    gppb_forced(sesskey, \"OSXCommandMeta\", false, conf, CONF_osx_command_meta);\n#endif\n    gppb_forced(sesskey, \"TelnetKey\", false, conf, CONF_telnet_keyboard);\n    gppb_forced(sesskey, \"TelnetRet\", true, conf, CONF_telnet_newline);\n    gppi_forced(sesskey, \"LocalEcho\", AUTO, conf, CONF_localecho);\n    gppi_forced(sesskey, \"LocalEdit\", AUTO, conf, CONF_localedit);\n#if (defined MOD_PERSO) && (!defined FLJ)\n    gpps_forced(sesskey, \"Answerback\", \"KiTTY\", conf, CONF_answerback);\n#else\n    gpps_forced(sesskey, \"Answerback\", \"PuTTY\", conf, CONF_answerback);\n#endif\n    gppb_forced(sesskey, \"AlwaysOnTop\", false, conf, CONF_alwaysontop);\n    gppb_forced(sesskey, \"FullScreenOnAltEnter\", false,\n         conf, CONF_fullscreenonaltenter);\n    gppb_forced(sesskey, \"HideMousePtr\", false, conf, CONF_hide_mouseptr);\n    gppb_forced(sesskey, \"SunkenEdge\", false, conf, CONF_sunken_edge);\n    gppi_forced(sesskey, \"WindowBorder\", 1, conf, CONF_window_border);\n#ifdef MOD_FAR2L\n    gppi_forced(sesskey, \"CurType\", 1, conf, CONF_cursor_type);\n    gppb_forced(sesskey, \"BlinkCur\", true, conf, CONF_blink_cur);\n#else\n    gppi_forced(sesskey, \"CurType\", 0, conf, CONF_cursor_type);\n    gppb_forced(sesskey, \"BlinkCur\", false, conf, CONF_blink_cur);\n#endif\n    /* pedantic compiler tells me I can't use conf, CONF_beep as an int * :-) */\n    gppi_forced(sesskey, \"Beep\", 1, conf, CONF_beep);\n    gppi_forced(sesskey, \"BeepInd\", 0, conf, CONF_beep_ind);\n    gppfile_forced(sesskey, \"BellWaveFile\", conf, CONF_bell_wavefile);\n    gppb_forced(sesskey, \"BellOverload\", true, conf, CONF_bellovl);\n    gppi_forced(sesskey, \"BellOverloadN\", 5, conf, CONF_bellovl_n);\n    i = gppi_raw_forced(sesskey, \"BellOverloadT\", 2*TICKSPERSEC\n#ifdef PUTTY_UNIX_H\n\t\t\t\t   *1000\n#endif\n\t\t\t\t   );\n    conf_set_int(conf, CONF_bellovl_t, i\n#ifdef PUTTY_UNIX_H\n\t\t / 1000\n#endif\n\t\t );\n    i = gppi_raw_forced(sesskey, \"BellOverloadS\", 5*TICKSPERSEC\n#ifdef PUTTY_UNIX_H\n\t\t\t\t   *1000\n#endif\n\t\t\t\t   );\n    conf_set_int(conf, CONF_bellovl_s, i\n#ifdef PUTTY_UNIX_H\n\t\t / 1000\n#endif\n\t\t );\n#ifdef MOD_HYPERLINK\n    gppi_forced(sesskey, \"ScrollbackLines\", 10000, conf, CONF_savelines);\n#else\n    gppi_forced(sesskey, \"ScrollbackLines\", 2000, conf, CONF_savelines);\n#endif\n    gppb_forced(sesskey, \"DECOriginMode\", false, conf, CONF_dec_om);\n    gppb_forced(sesskey, \"AutoWrapMode\", true, conf, CONF_wrap_mode);\n    gppb_forced(sesskey, \"LFImpliesCR\", false, conf, CONF_lfhascr);\n    gppb_forced(sesskey, \"CRImpliesLF\", false, conf, CONF_crhaslf);\n    gppb_forced(sesskey, \"DisableArabicShaping\", false, conf, CONF_no_arabicshaping);\n    gppb_forced(sesskey, \"DisableBidi\", false, conf, CONF_no_bidi);\n    gppb_forced(sesskey, \"WinNameAlways\", true, conf, CONF_win_name_always);\n    gpps_forced(sesskey, \"WinTitle\", \"\", conf, CONF_wintitle);\n    gppi_forced(sesskey, \"TermWidth\", 80, conf, CONF_width);\n    gppi_forced(sesskey, \"TermHeight\", 24, conf, CONF_height);\n    gppfont_forced(sesskey, \"Font\", conf, CONF_font);\n#ifdef MOD_PERSO\n    /*\n     * HACK: PuTTY-url\n     * Set font quality to cleartype on Windows Vista and higher\n     */\n    if (versioninfo.dwMajorVersion >= 6) {\n        gppi_forced(sesskey, \"FontQuality\", FQ_CLEARTYPE, conf, CONF_font_quality);\n    } else {\n        gppi_forced(sesskey, \"FontQuality\", FQ_DEFAULT, conf, CONF_font_quality);\n    }\n#else\n    gppi_forced(sesskey, \"FontQuality\", FQ_DEFAULT, conf, CONF_font_quality);\n#endif\n    gppi_forced(sesskey, \"FontVTMode\", VT_UNICODE, conf, CONF_vtmode);\n    gppb_forced(sesskey, \"UseSystemColours\", false, conf, CONF_system_colour);\n    gppb_forced(sesskey, \"TryPalette\", false, conf, CONF_try_palette);\n    gppb_forced(sesskey, \"ANSIColour\", true, conf, CONF_ansi_colour);\n    gppb_forced(sesskey, \"Xterm256Colour\", true, conf, CONF_xterm_256_colour);\n    gppb_forced(sesskey, \"TrueColour\", true, conf, CONF_true_colour);\n    i = gppi_raw_forced(sesskey, \"BoldAsColour\", 1); conf_set_int(conf, CONF_bold_style, i+1);\n\n#ifdef MOD_TUTTY\n    gppi_forced(sesskey, \"WindowClosable\", 1, conf, CONF_window_closable);\n    gppi_forced(sesskey, \"WindowMinimizable\", 1, conf, CONF_window_minimizable);\n    gppi_forced(sesskey, \"WindowMaximizable\", 1, conf, CONF_window_maximizable);\n    gppi_forced(sesskey, \"WindowHasSysMenu\", 1, conf, CONF_window_has_sysmenu);\n    gppi_forced(sesskey, \"DisableBottomButtons\", 1, conf, CONF_bottom_buttons);\n#endif\n#ifdef MOD_TUTTY\n    gppi_forced(sesskey, \"BoldAsColourTest\", 1, conf, CONF_bold_colour);\n    gppi_forced(sesskey, \"UnderlinedAsColour\", 0, conf, CONF_under_colour);\n    gppi_forced(sesskey, \"SelectedAsColour\", 0, conf, CONF_sel_colour);\n    for (i = 0; i < 34; i++) {\n\tstatic const char *const defaults[34] = {\n\t    \"187,187,187\", \"255,255,255\", \"0,0,0\", \"85,85,85\", \"0,0,0\",\n\t    \"0,255,0\", \"0,0,0\", \"85,85,85\", \"187,0,0\", \"255,85,85\",\n\t    \"0,187,0\", \"85,255,85\", \"187,187,0\", \"255,255,85\", \"0,0,187\",\n\t    \"85,85,255\", \"187,0,187\", \"255,85,255\", \"0,187,187\",\n\t    \"85,255,255\", \"187,187,187\", \"255,255,255\", \"187,187,187\",\n\t    \"0,0,0\", \"0,0,0\", \"187,0,0\", \"0,187,0\", \"187,187,0\", \"0,0,187\",\n\t    \"187,0,187\", \"0,187,187\", \"187,187,187\", \"0,0,0\", \"187,187,187\"\n\t};\n#else\n    for (i = 0; i < 22; i++) {\n\tstatic const char *const defaults[] = {\n\t    \"187,187,187\", \"255,255,255\", \"0,0,0\", \"85,85,85\", \"0,0,0\",\n\t    \"0,255,0\", \"0,0,0\", \"85,85,85\", \"187,0,0\", \"255,85,85\",\n\t    \"0,187,0\", \"85,255,85\", \"187,187,0\", \"255,255,85\", \"0,0,187\",\n\t    \"85,85,255\", \"187,0,187\", \"255,85,255\", \"0,187,187\",\n\t    \"85,255,255\", \"187,187,187\", \"255,255,255\"\n\t};\n#endif\n\tchar buf[20], *buf2;\n\tint c0, c1, c2;\n\tsprintf(buf, \"Colour%d\", i);\n\tbuf2 = gpps_raw_forced(sesskey, buf, defaults[i]);\n\tif (sscanf(buf2, \"%d,%d,%d\", &c0, &c1, &c2) == 3) {\n\t    conf_set_int_int(conf, CONF_colours, i*3+0, c0);\n\t    conf_set_int_int(conf, CONF_colours, i*3+1, c1);\n\t    conf_set_int_int(conf, CONF_colours, i*3+2, c2);\n\t}\n\tsfree(buf2);\n    }\n    gppb_forced(sesskey, \"RawCNP\", false, conf, CONF_rawcnp);\n    gppb_forced(sesskey, \"UTF8linedraw\", false, conf, CONF_utf8linedraw);\n    gppb_forced(sesskey, \"PasteRTF\", false, conf, CONF_rtf_paste);\n    gppi_forced(sesskey, \"MouseIsXterm\", 0, conf, CONF_mouse_is_xterm);\n    gppb_forced(sesskey, \"RectSelect\", false, conf, CONF_rect_select);\n    gppb_forced(sesskey, \"PasteControls\", false, conf, CONF_paste_controls);\n    gppb_forced(sesskey, \"MouseOverride\", true, conf, CONF_mouse_override);\n    for (i = 0; i < 256; i += 32) {\n\tstatic const char *const defaults[] = {\n\t    \"0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\",\n\t    \"0,1,2,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1\",\n\t    \"1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2\",\n\t    \"1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1\",\n\t    \"1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\",\n\t    \"1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\",\n\t    \"2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2\",\n\t    \"2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2\"\n\t};\n\tchar buf[20], *buf2, *p;\n\tint j;\n\tsprintf(buf, \"Wordness%d\", i);\n\tbuf2 = gpps_raw_forced(sesskey, buf, defaults[i / 32]);\n\tp = buf2;\n\tfor (j = i; j < i + 32; j++) {\n\t    char *q = p;\n\t    while (*p && *p != ',')\n\t\tp++;\n\t    if (*p == ',')\n\t\t*p++ = '\\0';\n\t    conf_set_int_int(conf, CONF_wordness, j, atoi(q));\n\t}\n\tsfree(buf2);\n    }\n    gppb_forced(sesskey, \"MouseAutocopy\", CLIPUI_DEFAULT_AUTOCOPY,\n         conf, CONF_mouseautocopy);\n    read_clip_setting_forced(sesskey, \"MousePaste\", CLIPUI_DEFAULT_MOUSE,\n                      conf, CONF_mousepaste, CONF_mousepaste_custom);\n    read_clip_setting_forced(sesskey, \"CtrlShiftIns\", CLIPUI_DEFAULT_INS,\n                      conf, CONF_ctrlshiftins, CONF_ctrlshiftins_custom);\n    read_clip_setting_forced(sesskey, \"CtrlShiftCV\", CLIPUI_NONE,\n                      conf, CONF_ctrlshiftcv, CONF_ctrlshiftcv_custom);\n    /*\n     * The empty default for LineCodePage will be converted later\n     * into a plausible default for the locale.\n     */\n    gpps_forced(sesskey, \"LineCodePage\", \"\", conf, CONF_line_codepage);\n    gppb_forced(sesskey, \"CJKAmbigWide\", false, conf, CONF_cjk_ambig_wide);\n    gppb_forced(sesskey, \"UTF8Override\", true, conf, CONF_utf8_override);\n    gpps_forced(sesskey, \"Printer\", \"\", conf, CONF_printer);\n#ifdef MOD_PRINTCLIP\n    if( !strcmp( conf_get_str(conf,CONF_printer),PRINT_TO_CLIPBOARD_STRING) ) { conf_set_int(conf,CONF_printclip,1) ; }\n    else { conf_set_int(conf,CONF_printclip,0) ; }\n#endif\n    gppb_forced(sesskey, \"CapsLockCyr\", false, conf, CONF_xlat_capslockcyr);\n    gppb_forced(sesskey, \"ScrollBar\", true, conf, CONF_scrollbar);\n    gppb_forced(sesskey, \"ScrollBarFullScreen\", false,\n         conf, CONF_scrollbar_in_fullscreen);\n    gppb_forced(sesskey, \"ScrollOnKey\", false, conf, CONF_scroll_on_key);\n    gppb_forced(sesskey, \"ScrollOnDisp\", true, conf, CONF_scroll_on_disp);\n    gppb_forced(sesskey, \"EraseToScrollback\", true, conf, CONF_erase_to_scrollback);\n    gppi_forced(sesskey, \"LockSize\", 0, conf, CONF_resize_action);\n    gppb_forced(sesskey, \"BCE\", true, conf, CONF_bce);\n    gppb_forced(sesskey, \"BlinkText\", false, conf, CONF_blinktext);\n    gppb_forced(sesskey, \"X11Forward\", false, conf, CONF_x11_forward);\n    gpps_forced(sesskey, \"X11Display\", \"\", conf, CONF_x11_display);\n    gppi_forced(sesskey, \"X11AuthType\", X11_MIT, conf, CONF_x11_auth);\n    gppfile_forced(sesskey, \"X11AuthFile\", conf, CONF_xauthfile);\n\n    gppb_forced(sesskey, \"LocalPortAcceptAll\", false, conf, CONF_lport_acceptall);\n    gppb_forced(sesskey, \"RemotePortAcceptAll\", false, conf, CONF_rport_acceptall);\n    gppmap_forced(sesskey, \"PortForwardings\", conf, CONF_portfwd);\n    i = gppi_raw_forced(sesskey, \"BugIgnore1\", 0); conf_set_int(conf, CONF_sshbug_ignore1, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugPlainPW1\", 0); conf_set_int(conf, CONF_sshbug_plainpw1, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugRSA1\", 0); conf_set_int(conf, CONF_sshbug_rsa1, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugIgnore2\", 0); conf_set_int(conf, CONF_sshbug_ignore2, 2-i);\n    {\n\tint i;\n\ti = gppi_raw_forced(sesskey, \"BugHMAC2\", 0); conf_set_int(conf, CONF_sshbug_hmac2, 2-i);\n\tif (2-i == AUTO) {\n\t    i = gppi_raw_forced(sesskey, \"BuggyMAC\", 0);\n\t    if (i == 1)\n\t\tconf_set_int(conf, CONF_sshbug_hmac2, FORCE_ON);\n\t}\n    }\n    i = gppi_raw_forced(sesskey, \"BugDeriveKey2\", 0); conf_set_int(conf, CONF_sshbug_derivekey2, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugRSAPad2\", 0); conf_set_int(conf, CONF_sshbug_rsapad2, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugPKSessID2\", 0); conf_set_int(conf, CONF_sshbug_pksessid2, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugRekey2\", 0); conf_set_int(conf, CONF_sshbug_rekey2, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugMaxPkt2\", 0); conf_set_int(conf, CONF_sshbug_maxpkt2, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugOldGex2\", 0); conf_set_int(conf, CONF_sshbug_oldgex2, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugWinadj\", 0); conf_set_int(conf, CONF_sshbug_winadj, 2-i);\n    i = gppi_raw_forced(sesskey, \"BugChanReq\", 0); conf_set_int(conf, CONF_sshbug_chanreq, 2-i);\n    conf_set_bool(conf, CONF_ssh_simple, false);\n    gppb_forced(sesskey, \"StampUtmp\", true, conf, CONF_stamp_utmp);\n    gppb_forced(sesskey, \"LoginShell\", true, conf, CONF_login_shell);\n    gppb_forced(sesskey, \"ScrollbarOnLeft\", false, conf, CONF_scrollbar_on_left);\n    gppb_forced(sesskey, \"ShadowBold\", false, conf, CONF_shadowbold);\n    gppfont_forced(sesskey, \"BoldFont\", conf, CONF_boldfont);\n    gppfont_forced(sesskey, \"WideFont\", conf, CONF_widefont);\n    gppfont_forced(sesskey, \"WideBoldFont\", conf, CONF_wideboldfont);\n    gppi_forced(sesskey, \"ShadowBoldOffset\", 1, conf, CONF_shadowboldoffset);\n    gpps_forced(sesskey, \"SerialLine\", \"\", conf, CONF_serline);\n    gppi_forced(sesskey, \"SerialSpeed\", 9600, conf, CONF_serspeed);\n    gppi_forced(sesskey, \"SerialDataBits\", 8, conf, CONF_serdatabits);\n    gppi_forced(sesskey, \"SerialStopHalfbits\", 2, conf, CONF_serstopbits);\n    gppi_forced(sesskey, \"SerialParity\", SER_PAR_NONE, conf, CONF_serparity);\n    gppi_forced(sesskey, \"SerialFlowControl\", SER_FLOW_XONXOFF, conf, CONF_serflow);\n    gpps_forced(sesskey, \"WindowClass\", \"\", conf, CONF_winclass);\n    gppb_forced(sesskey, \"ConnectionSharing\", false,\n         conf, CONF_ssh_connection_sharing);\n    gppb_forced(sesskey, \"ConnectionSharingUpstream\", true,\n         conf, CONF_ssh_connection_sharing_upstream);\n    gppb_forced(sesskey, \"ConnectionSharingDownstream\", true,\n         conf, CONF_ssh_connection_sharing_downstream);\n    gppmap_forced(sesskey, \"SSHManualHostKeys\", conf, CONF_ssh_manual_hostkeys);\n    \n    /*\n     * PuTTY 0.75 SUPDUP settings\n    gpps_forced(sesskey, \"SUPDUPLocation\", \"The Internet\", conf, CONF_supdup_location);\n    gppi_forced(sesskey, \"SUPDUPCharset\", false, conf, CONF_supdup_ascii_set);\n    gppb_forced(sesskey, \"SUPDUPMoreProcessing\", false, conf, CONF_supdup_more);\n    gppb_forced(sesskey, \"SUPDUPScrolling\", false, conf, CONF_supdup_scroll);\n     */\n\n/* rutty: */\n#ifdef MOD_RUTTY\n\tgppfile_forced(sesskey, \"ScriptFileName\", conf, CONF_script_filename);\n\tgppi_forced(sesskey, \"ScriptMode\", 0, conf, CONF_script_mode);\n\tgppi_forced(sesskey, \"ScriptLineDelay\", 0, conf, CONF_script_line_delay);\n\tgppi_forced(sesskey, \"ScriptCharDelay\", 0, conf, CONF_script_char_delay);\n\tgpps_forced(sesskey, \"ScriptCondLine\", \":\", conf, CONF_script_cond_line);\n\tgppi_forced(sesskey, \"ScriptCondUse\", 0, conf, CONF_script_cond_use);\n\tgppi_forced(sesskey, \"ScriptCRLF\", SCRIPT_NOLF, conf, CONF_script_crlf);\n\tgppi_forced(sesskey, \"ScriptEnable\", 0, conf, CONF_script_enable);\n\tgppi_forced(sesskey, \"ScriptExcept\", 0, conf, CONF_script_except);\n\tgppi_forced(sesskey, \"ScriptTimeout\", 30, conf, CONF_script_timeout);\n\tgpps_forced(sesskey, \"ScriptWait\", \"\", conf, CONF_script_waitfor);\n\tgpps_forced(sesskey, \"ScriptHalt\", \"\", conf, CONF_script_halton);\n#endif  /* rutty */\n#ifdef MOD_RECONNECT\n    gppi_forced(sesskey, \"WakeupReconnect\", 0, conf, CONF_wakeup_reconnect );\n    gppi_forced(sesskey, \"FailureReconnect\", 0, conf, CONF_failure_reconnect );\n#endif\n#if (defined MOD_BACKGROUNDIMAGE) && (!defined FLJ)\n    gppi_forced(sesskey, \"BgOpacity\", 50, conf, CONF_bg_opacity );\n    gppi_forced(sesskey, \"BgSlideshow\", 0, conf, CONF_bg_slideshow );\n    gppi_forced(sesskey, \"BgType\", 0, conf, CONF_bg_type );\n    gppfile_forced(sesskey, \"BgImageFile\", conf, CONF_bg_image_filename );\n    gppi_forced(sesskey, \"BgImageStyle\", 0, conf, CONF_bg_image_style );\n    gppi_forced(sesskey, \"BgImageAbsoluteX\", 0, conf, CONF_bg_image_abs_x );\n    gppi_forced(sesskey, \"BgImageAbsoluteY\", 0, conf, CONF_bg_image_abs_y );\n    gppi_forced(sesskey, \"BgImagePlacement\", 0, conf, CONF_bg_image_abs_fixed );\n#endif\n#ifdef MOD_HYPERLINK\n\t/*\n\t * HACK: PuttyTray / Nutty\n\t * Hyperlink stuff: Load hyperlink settings\n\t */\n\tgppi_forced(sesskey, \"HyperlinkUnderline\", 0, conf, CONF_url_underline);\n\tgppi_forced(sesskey, \"HyperlinkUseCtrlClick\", 1, conf, CONF_url_ctrl_click);\n\tgppi_forced(sesskey, \"HyperlinkBrowserUseDefault\", 1, conf, CONF_url_defbrowser);\n\tgppfile_forced(sesskey, \"HyperlinkBrowser\", conf, CONF_url_browser);\n\tgppi_forced(sesskey, \"HyperlinkRegularExpressionUseDefault\", 1, conf, CONF_url_defregex);\n\n#ifndef MOD_NOHYPERLINK\n\tgpps_forced(sesskey, \"HyperlinkRegularExpression\", urlhack_default_regex, conf, CONF_url_regex);\n#endif\n#endif\n#ifdef MOD_ZMODEM\n    gppfile_forced(sesskey, \"rzCommand\", conf, CONF_rzcommand );\n    gpps_forced(sesskey, \"rzOptions\", \"-e -v\", conf, CONF_rzoptions );\n    gppfile_forced(sesskey, \"szCommand\", conf, CONF_szcommand );\n    gpps_forced(sesskey, \"szOptions\", \"-e -v\", conf, CONF_szoptions );\n    gpps_forced(sesskey, \"zDownloadDir\", \"C:\\\\\", conf, CONF_zdownloaddir );\n#endif\n#ifdef MOD_PERSO\n    gpps_forced(sesskey, \"HostAlt\", \"\", conf, CONF_host_alt );\n    gppi_forced(sesskey, \"TransparencyValue\", 0, conf, CONF_transparencynumber ) ;\n    if( conf_get_int( conf, CONF_transparencynumber) < -1 ) conf_set_int( conf,CONF_transparencynumber,-1) ;\n    if( conf_get_int( conf, CONF_transparencynumber) > 255 ) conf_set_int( conf,CONF_transparencynumber,255) ;\n    gppi_forced(sesskey, \"SendToTray\", 0, conf, CONF_sendtotray );\n    gppi_forced(sesskey, \"Maximize\", 0, conf, CONF_maximize );\n    gppi_forced(sesskey, \"Fullscreen\", 0, conf, CONF_fullscreen );\n    gppb_forced(sesskey, \"SaveOnExit\", false, conf, CONF_saveonexit );\n    gppi_forced(sesskey, \"Icone\", 1, conf, CONF_icone );\n    gppfile_forced(sesskey, \"IconeFile\", conf, CONF_iconefile );\n    gppi_forced(sesskey, \"WinSCPProtocol\", 1, conf, CONF_winscpprot );\n    gpps_forced(sesskey, \"SFTPConnect\", \"\", conf, CONF_sftpconnect );\n    gpps_forced(sesskey, \"PSCPOptions\", \"-r\", conf, CONF_pscpoptions );\n    gpps_forced(sesskey, \"PSCPShell\", \"\", conf, CONF_pscpshell );\n    gpps_forced(sesskey, \"PSCPRemoteDir\", \"\", conf, CONF_pscpremotedir );\n    gpps_forced(sesskey, \"WinSCPOptions\", \"\", conf, CONF_winscpoptions );\n    gpps_forced(sesskey, \"WinSCPRawSettings\", \"\", conf, CONF_winscprawsettings );\n    gppfile_forced(sesskey, \"Scriptfile\", conf, CONF_scriptfile );\n    Filename * fn = filename_from_str( \"\" ) ;\n    conf_set_filename(conf,CONF_scriptfile,fn);\n    filename_free(fn);\n    gpps_forced(sesskey, \"ScriptfileContent\", \"\", conf, CONF_scriptfilecontent );\n    gpps_forced(sesskey, \"AntiIdle\", \"\", conf, CONF_antiidle );\n    gpps_forced(sesskey, \"LogTimestamp\", \"\", conf, CONF_logtimestamp );\n    gpps_forced(sesskey, \"Autocommand\", \"\", conf, CONF_autocommand );\n    gpps_forced(sesskey, \"AutocommandOut\", \"\", conf, CONF_autocommandout );\n    gpps_forced(sesskey, \"Folder\", \"\", conf, CONF_folder );\n    if( strlen(conf_get_str(conf, CONF_folder)) == 0 ) { conf_set_str( conf, CONF_folder, \"Default\" ) ; }\n    gppi_forced(sesskey, \"LogTimeRotation\", 0, conf, CONF_logtimerotation );\n    gppi_forced(sesskey, \"TermXPos\", -1, conf, CONF_xpos );\n    gppi_forced(sesskey, \"TermYPos\", -1, conf, CONF_ypos );\n    gppi_forced(sesskey, \"WindowState\", 0, conf, CONF_windowstate );\n    gppb_forced(sesskey, \"SaveWindowPos\", false, conf, CONF_save_windowpos ); /* BKG */\n    gppb_forced(sesskey, \"ForegroundOnBell\", false, conf, CONF_foreground_on_bell );\n#ifndef MOD_NOPASSWORD\n    gpps_forced(sesskey, \"Password\", \"\", conf, CONF_password ) ;\n    if( strlen(conf_get_str(conf, CONF_password))>0 ) {\n\tchar pst[4096] ;\n\tif( strlen(conf_get_str(conf, CONF_password))<=4095 ) { strcpy( pst, conf_get_str(conf, CONF_password) ) ; }\n\telse { memcpy( pst, conf_get_str( conf, CONF_password ), 4095 ) ; pst[4095] = '\\0' ; }\n\tdecryptpassword( GetCryptSaltFlag(), pst, conf_get_str(conf, CONF_host), conf_get_str(conf, CONF_termtype) ) ;\n\tif( strlen( pst ) > 0 ) { DebugGetPassword( conf, pst ) ; }\n\tMASKPASS(GetCryptSaltFlag(),pst);\n\tconf_set_str( conf, CONF_password, pst ) ;\n\tmemset(pst,0,strlen(pst));\n    }\n#else\n\tconf_set_str( conf, CONF_password, \"\" ) ;\n#endif\n    gppi_forced(sesskey, \"CtrlTabSwitch\", 0, conf, CONF_ctrl_tab_switch);\n    gpps_forced(sesskey, \"Comment\", \"\", conf, CONF_comment );\n    gppi_forced(sesskey, \"SCPAutoPwd\", 0, conf, CONF_scp_auto_pwd);\n    gppb_forced(sesskey, \"NoFocusReporting\", true, conf, CONF_no_focus_rep);\n    gppi_forced(sesskey, \"LinesAtAScroll\", 5, conf, CONF_scrolllines);\n    gppb_forced(sesskey, \"SSHTunnelInTitle\", false, conf, CONF_ssh_tunnel_print_in_title);\n    gppb_forced(sesskey, \"OSC52WarnBeforeClipboardSync\", false, conf, CONF_osc52_warn_before_cliboard_sync);\n#endif\n#ifdef MOD_PORTKNOCKING\n\tgpps_forced(sesskey, \"PortKnocking\", \"\", conf, CONF_portknockingoptions );\n#endif\n#ifdef MOD_DISABLEALTGR\n\tgppi_forced(sesskey, \"DisableAltGr\", 0, conf, CONF_disablealtgr);\n#endif\n#ifdef MOD_PROXY\n\tgpps_forced(sesskey, \"ProxySelection\", \"- Session defined proxy -\", conf, CONF_proxyselection);\n#endif\n// END COPY/PASTE\n\tconf_set_str( conf, CONF_folder, \"Default\") ;\n\tfclose(sesskey) ;\n\t\t\n\tconf_free( confDef ) ;\n}\n\n\n\n\n\n\n/*****\nFONCTIONS SUPPORT\n*****/\n\nstatic int CryptFileFlag = 0 ;\nint SwitchCryptFlag( void ) { CryptFileFlag = abs( CryptFileFlag -1 ) ; return CryptFileFlag ; }\n\nvoid mungestr(const char *in, char *out);\nvoid unmungestr(char *in, char *out, int outlen) ;\n\nvoid write_setting_b_forced(void *handle, const char *key, bool value) {\n\t write_setting_i_forced(handle, key, value ? 1 : 0);\n}\n\nvoid write_setting_i_forced(void *handle, const char *key, int value) {\n\tchar buf[1024] ;\n\tsprintf( buf, \"%s\\\\%i\\\\\", key, value ) ;\n\tif( CryptFileFlag ) { cryptstring(buf,MASTER_PASSWORD); }\n\t//fprintf( (FILE*)handle, \"%s\\\\%i\\\\\\n\", key, value ) ;\n\tfprintf( (FILE*)handle, \"%s\\n\", buf ) ;\n\tfflush(handle);\n}\n\nvoid write_setting_s_forced(void *handle, const char *key, const char *value) {\n\tchar *p ;\n\tp = (char*)malloc( 3*strlen(value)+256 );\n\tmungestr(value, p);\n\tchar * buf ;\n\tbuf = (char*) malloc( 2*(strlen(key)+strlen(p))+10 ) ;\n\tsprintf( buf, \"%s\\\\%s\\\\\", key, p ) ;\n\tif( CryptFileFlag ) { cryptstring(buf,MASTER_PASSWORD); }\n\tfprintf( (FILE*)handle, \"%s\\n\", buf ) ;\n\tfflush(handle);\n\tfree(buf);\n\tfree(p);\n}\n\nvoid write_setting_filename_forced(void *handle, const char *key, Filename *value) {\n\tchar *p ;\n\tp=(char*)malloc( 3*strlen(value->path)+256 );\n\tmungestr(value->path, p);\n\tchar * buf ;\n\tbuf = (char*) malloc( 2*(strlen(key)+strlen(p))+10 ) ;\n\tsprintf( buf, \"%s\\\\%s\\\\\", key, p ) ;\n\tif( CryptFileFlag ) { cryptstring(buf,MASTER_PASSWORD); }\n\tfprintf( (FILE*)handle, \"%s\\n\", buf ) ;\n\tfflush(handle);\n\tfree(buf) ;\n\tfree(p);\n}\n\nvoid write_setting_fontspec_forced(void *handle, const char *name, FontSpec *font) {\n\tchar *settingname;\n    write_setting_s_forced(handle, name, font->name);\n    settingname = dupcat(name, \"IsBold\", NULL);\n    write_setting_i_forced(handle, settingname, font->isbold);\n    sfree(settingname);\n    settingname = dupcat(name, \"CharSet\", NULL);\n    write_setting_i_forced(handle, settingname, font->charset);\n    sfree(settingname);\n    settingname = dupcat(name, \"Height\", NULL);\n    write_setting_i_forced(handle, settingname, font->height);\n    sfree(settingname);\n    fflush(handle);\n}\n\nstatic void wmap_forced(void *handle, char const *outkey, Conf *conf, int primary,int include_values) {\n    char *buf, *p, *key, *realkey;\n    const char *val, *q;\n    int len;\n\n    len = 1;\t\t\t       /* allow for NUL */\n\n    for (val = conf_get_str_strs(conf, primary, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, primary, key, &key))\n\tlen += 2 + 2 * (strlen(key) + strlen(val));   /* allow for escaping */\n\n    buf = snewn(len, char);\n    p = buf;\n\n    for (val = conf_get_str_strs(conf, primary, NULL, &key);\n\t val != NULL;\n\t val = conf_get_str_strs(conf, primary, key, &key)) {\n\n        if (primary == CONF_portfwd && !strcmp(val, \"D\")) {\n            /*\n             * Backwards-compatibility hack, as above: translate from\n             * the sensible internal representation of dynamic\n             * forwardings (key \"L<port>\", value \"D\") to the\n             * conceptually incoherent legacy storage format (key\n             * \"D<port>\", value empty).\n             */\n            char *L;\n\n            realkey = key;             /* restore it at end of loop */\n            val = \"\";\n            key = dupstr(key);\n            L = strchr(key, 'L');\n            if (L) *L = 'D';\n        } else {\n            realkey = NULL;\n        }\n\n\tif (p != buf)\n\t    *p++ = ',';\n\tfor (q = key; *q; q++) {\n\t    if (*q == '=' || *q == ',' || *q == '\\\\')\n\t\t*p++ = '\\\\';\n\t    *p++ = *q;\n\t}\n        if (include_values) {\n            *p++ = '=';\n            for (q = val; *q; q++) {\n                if (*q == '=' || *q == ',' || *q == '\\\\')\n                    *p++ = '\\\\';\n                *p++ = *q;\n            }\n        }\n\n        if (realkey) {\n            free(key);\n            key = realkey;\n        }\n    }\n    *p = '\\0';\n    write_setting_s_forced(handle, outkey, buf);\n    sfree(buf);\n}\n\nstatic void wprefs_forced(void *sesskey, const char *name, const struct keyvalwhere *mapping, int nvals, Conf *conf, int primary) {\n    char *buf, *p;\n    int i, maxlen;\n\n    for (maxlen = i = 0; i < nvals; i++) {\n\tconst char *s = val2key(mapping, nvals,\n                                conf_get_int_int(conf, primary, i));\n\tif (s) {\n            maxlen += (maxlen > 0 ? 1 : 0) + strlen(s);\n        }\n    }\n\n    buf = snewn(maxlen + 1, char);\n    p = buf;\n\n    for (i = 0; i < nvals; i++) {\n\tconst char *s = val2key(mapping, nvals,\n                                conf_get_int_int(conf, primary, i));\n\tif (s) {\n            p += sprintf(p, \"%s%s\", (p > buf ? \",\" : \"\"), s);\n\t}\n    }\n\n    assert(p - buf == maxlen);\n    *p = '\\0';\n\n    write_setting_s_forced(sesskey, name, buf);\n\n    sfree(buf);\n}\n\nstatic void write_clip_setting_forced(void *sesskey, const char *savekey, Conf *conf, int confkey, int strconfkey) {\n    int val = conf_get_int(conf, confkey);\n    switch (val) {\n      case CLIPUI_NONE:\n      default:\n        write_setting_s(sesskey, savekey, \"none\");\n        break;\n      case CLIPUI_IMPLICIT:\n        write_setting_s(sesskey, savekey, \"implicit\");\n        break;\n      case CLIPUI_EXPLICIT:\n        write_setting_s(sesskey, savekey, \"explicit\");\n        break;\n      case CLIPUI_CUSTOM: {\n            char *sval = dupcat(\"custom:\", conf_get_str(conf, strconfkey),\n                                (const char *)NULL);\n            write_setting_s_forced(sesskey, savekey, sval);\n            sfree(sval);\n        break;\n      }\n    }\n}\n\n\n\n\n\nint read_setting_i_forced(void *handle, const char *key, int defvalue) {\n\tint n = defvalue ;\n\tchar buffer[2048], name[256] ;\n\trewind(handle);\n\tsprintf( name, \"%s\\\\\", key ) ;\n\twhile( fgets(buffer,2047,handle)!=NULL ) {\n\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\tif( buffer[strlen(buffer)-1] != '\\\\' ) { decryptstring( buffer, MASTER_PASSWORD) ; }\n\t\tif( strstr( buffer, name ) == buffer ) {\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\\\')||(buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\t\tn = atoi( buffer+strlen(name) ) ;\n\t\t\tbreak ;\n\t\t}\n\t}\n\treturn n ;\n}\n\nchar *read_setting_s_forced(void *handle, const char *key) {\n\tchar * loadResult = NULL ;\n\tchar buffer[2048], name[256] ;\n\trewind(handle);\n\tsprintf( name, \"%s\\\\\", key ) ;\n\t\n\twhile( fgets(buffer,2047,handle)!=NULL ) {\n\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\tif( buffer[strlen(buffer)-1] != '\\\\' ) { decryptstring( buffer, MASTER_PASSWORD) ; }\n\t\tif( strstr( buffer, name ) == buffer ) {\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\\\')||(buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\t\tloadResult = (char*) malloc( strlen( buffer+strlen(name) ) + 1 ) ;\n\t\t\tunmungestr( buffer+strlen(name), loadResult, strlen( buffer+strlen(name) ) + 1 ) ;\n\t\t\tbreak ;\n\t\t}\n\t}\n\treturn loadResult ;\n}\n\nFilename *read_setting_filename_forced(void *handle, const char *key) {\n\tFilename * Result = NULL ;\n\tchar buffer[2048], name[256] ;\n\trewind(handle);\n\tsprintf( name, \"%s\\\\\", key ) ;\n\twhile( fgets(buffer,2047,handle)!=NULL ) {\n\t\twhile( (buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\tif( buffer[strlen(buffer)-1] != '\\\\' ) { decryptstring( buffer, MASTER_PASSWORD) ; }\n\t\tif( strstr( buffer, name ) == buffer ) {\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\\\')||(buffer[strlen(buffer)-1]=='\\n')||(buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1]='\\0' ;\n\t\t\tunmungestr( buffer+strlen(name), buffer, 2047 ) ;\n\t\t\tResult = filename_from_str( buffer ) ;\n\t\t\tbreak ;\n\t\t}\n\t}\n\treturn Result ;\n}\n\n#include <limits.h>\nFontSpec *read_setting_fontspec_forced(void *handle, const char *name)\n{\n    char *settingname;\n    char *fontname;\n    FontSpec *ret;\n    int isbold, height, charset;\n\n    fontname = read_setting_s_forced(handle, name);\n    if (!fontname)\n\treturn NULL;\n\n    settingname = dupcat(name, \"IsBold\", NULL);\n    isbold = read_setting_i_forced(handle, settingname, -1);\n    sfree(settingname);\n    if (isbold == -1) {\n        sfree(fontname);\n        return NULL;\n    }\n\n    settingname = dupcat(name, \"CharSet\", NULL);\n    charset = read_setting_i_forced(handle, settingname, -1);\n    sfree(settingname);\n    if (charset == -1) {\n        sfree(fontname);\n        return NULL;\n    }\n\n    settingname = dupcat(name, \"Height\", NULL);\n    height = read_setting_i_forced(handle, settingname, INT_MIN);\n    sfree(settingname);\n    if (height == INT_MIN) {\n        sfree(fontname);\n        return NULL;\n    }\n\n    ret = fontspec_new(fontname, isbold, height, charset);\n    sfree(fontname);\n    return ret;\n}\n\n\nstatic bool gppb_raw_forced(void *sesskey, const char *name, bool def) {\n    def = platform_default_b(name, def);\n    return sesskey ? read_setting_i_forced(sesskey, name, def) != 0 : def;\n}\n\nstatic void gppb_forced(void *sesskey, const char *name, bool def, Conf *conf, int primary) {\n    conf_set_bool(conf, primary, gppb_raw_forced(sesskey, name, def));\n}\n\nstatic void gppi_forced(void *handle, const char *name, int def, Conf *conf, int primary) {\n    conf_set_int(conf, primary, gppi_raw_forced(handle, name, def));\n}\n\nstatic int gppi_raw_forced(void *handle, const char *name, int def) {\n    def = platform_default_i(name, def);\n    return read_setting_i_forced(handle, name, def);\n}\n\nstatic void gppfile_forced(void *handle, const char *name, Conf *conf, int primary) {\n    Filename *result = read_setting_filename_forced(handle, name);\n    if (!result)\n\tresult = platform_default_filename(name);\n    conf_set_filename(conf, primary, result);\n    filename_free(result);\n}\n\nstatic void gpps_forced(void *handle, const char *name, const char *def, Conf *conf, int primary) {\n    char *val = gpps_raw_forced(handle, name, def);\n    conf_set_str(conf, primary, val);\n    sfree(val);\n}\n\nstatic char *gpps_raw_forced(void *handle, const char *name, const char *def) {\n    char *ret = read_setting_s_forced(handle, name);\n    if (!ret)\n\tret = platform_default_s(name);\n    if (!ret)\n\tret = def ? dupstr(def) : NULL;   /* permit NULL as final fallback */\n    return ret;\n}\n\nstatic void gppfont_forced(void *handle, const char *name, Conf *conf, int primary) {\n    FontSpec *result = read_setting_fontspec_forced(handle, name);\n    if (!result)\n        result = platform_default_fontspec(name);\n    conf_set_fontspec(conf, primary, result);\n    fontspec_free(result);\n}\n\nstatic int gppmap_forced(void *handle, const char *name, Conf *conf, int primary) {\n    char *buf, *p, *q, *key, *val;\n\n    /*\n     * Start by clearing any existing subkeys of this key from conf.\n     */\n    while ((key = conf_get_str_nthstrkey(conf, primary, 0)) != NULL)\n        conf_del_str_str(conf, primary, key);\n\n    /*\n     * Now read a serialised list from the settings and unmarshal it\n     * into its components.\n     */\n    buf = gpps_raw_forced(handle, name, NULL);\n    if (!buf)\n\treturn FALSE;\n\n    p = buf;\n    while (*p) {\n\tq = buf;\n\tval = NULL;\n\twhile (*p && *p != ',') {\n\t    int c = *p++;\n\t    if (c == '=')\n\t\tc = '\\0';\n\t    if (c == '\\\\')\n\t\tc = *p++;\n\t    *q++ = c;\n\t    if (!c)\n\t\tval = q;\n\t}\n\tif (*p == ',')\n\t    p++;\n\tif (!val)\n\t    val = q;\n\t*q = '\\0';\n\n        if (primary == CONF_portfwd && strchr(buf, 'D') != NULL) {\n            /*\n             * Backwards-compatibility hack: dynamic forwardings are\n             * indexed in the data store as a third type letter in the\n             * key, 'D' alongside 'L' and 'R' - but really, they\n             * should be filed under 'L' with a special _value_,\n             * because local and dynamic forwardings both involve\n             * _listening_ on a local port, and are hence mutually\n             * exclusive on the same port number. So here we translate\n             * the legacy storage format into the sensible internal\n             * form, by finding the D and turning it into a L.\n             */\n            char *newkey = dupstr(buf);\n            *strchr(newkey, 'D') = 'L';\n            conf_set_str_str(conf, primary, newkey, \"D\");\n            sfree(newkey);\n        } else {\n            conf_set_str_str(conf, primary, buf, val);\n        }\n    }\n    sfree(buf);\n\n    return TRUE;\n}\n\nstatic void gprefs_forced(void *sesskey, const char *name, const char *def, const struct keyvalwhere *mapping, int nvals, Conf *conf, int primary) {\n    /*\n     * Fetch the string which we'll parse as a comma-separated list.\n     */\n    char *value = gpps_raw_forced(sesskey, name, def);\n    gprefs_from_str(value, mapping, nvals, conf, primary);\n    sfree(value);\n}\n\nstatic void read_clip_setting_forced(void *sesskey, char *savekey, int def, Conf *conf, int confkey, int strconfkey) {\n    char *setting = read_setting_s_forced(sesskey, savekey);\n    int val;\n\n    conf_set_str(conf, strconfkey, \"\");\n    if (!setting) {\n        val = def;\n    } else if (!strcmp(setting, \"implicit\")) {\n        val = CLIPUI_IMPLICIT;\n    } else if (!strcmp(setting, \"explicit\")) {\n        val = CLIPUI_EXPLICIT;\n    } else if (!strncmp(setting, \"custom:\", 7)) {\n        val = CLIPUI_CUSTOM;\n        conf_set_str(conf, strconfkey, setting + 7);\n    } else {\n        val = CLIPUI_NONE;\n    }\n    conf_set_int(conf, confkey, val);\n    sfree(setting);\n}\n"
        },
        {
          "name": "kitty_ssh.c",
          "type": "blob",
          "size": 3.2353515625,
          "content": "#include \"kitty_ssh.h\"\n#include \"kitty_tools.h\"\n\n#ifdef MOD_PORTKNOCKING\nvoid vprint(char *fmt, ...)\n{\tchar buf[1024];\n\tva_list args;\n\tva_start(args, fmt);\n\tvsprintf(buf,fmt, args);\n\tif( buf[strlen(buf)-1]=='\\n' ) buf[strlen(buf)-1]='\\0';\n\tprintf(buf) ;\n\tva_end(args);\n}\n\nint knock( char *hostname, unsigned short port, unsigned short proto) {\n\tSOCKET sd;\n\tstruct hostent* host;\n\tstruct sockaddr_in addr;\n\n\thost = gethostbyname(hostname);\n\tif(host == NULL) { fprintf(stderr, \"Cannot resolve hostname\\n\") ; return 1 ; }\n\n\tif(proto == PROTO_UDP) { \n\t\tsd = socket(PF_INET, SOCK_DGRAM, 0); \n\t\tif(sd == -1) { fprintf(stderr, \"Cannot open socket\\n\") ; return 2 ; } \n\t} else {\n\t\tunsigned long arg = !0;\n\t\tsd = socket(PF_INET, SOCK_STREAM, 0); \n\t\tif(sd == -1) { fprintf(stderr, \"Cannot open socket\\n\") ; return 3 ; }\n\t\tioctlsocket(sd, FIONBIO, &arg);\n\t}\n\t\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = *((long*)host->h_addr_list[0]);\n\taddr.sin_port = htons(port);\n\t\n\tif( proto == PROTO_UDP) {\n\t\tvprint(\"Hitting udp %s:%u\\n\\n\", inet_ntoa(addr.sin_addr), port);\n\t\tconnect(sd, (struct sockaddr*)&addr, sizeof(struct sockaddr));\n\t\tsend(sd, NULL, 0, 0);\n\t} else {\n\t\tvprint(\"Hitting tcp %s:%u\\n\\n\", inet_ntoa(addr.sin_addr), port);\n\t\tconnect(sd, (struct sockaddr*)&addr, sizeof(struct sockaddr));\n\t}\n\n\tshutdown(sd, 2);\n\tclosesocket(sd);\n\t\t\n\treturn 0;\n\t}\n\t\nint ManagePortKnocking( char* host, char *portknockseqorig ) {\n\tchar portstr[256], protostr[256];\n\tshort port, proto ;\n\tint i,j;\n\tchar * portknockseq = NULL ;\n\t\n\tif( (host==NULL) || (portknockseqorig==NULL) ) return 0 ;\n\tif( (strlen(host)==0) || (strlen(portknockseqorig)==0) ) return 0 ;\n\t\n\tportknockseq = (char*)malloc( strlen(portknockseqorig)+1 ) ;\n\tstrcpy(portknockseq,portknockseqorig);\n\t\n\tfor(i=0;i<strlen(portknockseq);i++) \n\t\t{ if( (portknockseq[i]==' ')||(portknockseq[i]=='\t')||(portknockseq[i]==';')||(portknockseq[i]=='-') ) portknockseq[i]=','; }\n\twhile( portknockseq[0]==',' ) del(portknockseq,1,1);\n\twhile( portknockseq[strlen(portknockseq)-1]==',' ) portknockseq[strlen(portknockseq)-1]='\\0';\n\twhile( (i=poss(\",:\",portknockseq)) ) { del(portknockseq,i,1); }\n\twhile( (i=poss(\":,\",portknockseq)) ) { del(portknockseq,i+1,1); }\n\twhile( (i=poss(\",,\",portknockseq)) ) { del(portknockseq,i,1); }\n\t\n\twhile( strlen(portknockseq)>0 ) {\n\t\twhile( (portknockseq[0]==' ')||(portknockseq[0]=='\t')||(portknockseq[0]==',')||(portknockseq[0]==';') ) del(portknockseq,1,1);\n\t\tif( strlen(portknockseq)>0 ) {\n\t\t\ti=poss(\":\",portknockseq) ; if(i==0) i=strlen(portknockseq)+1;\n\t\t\tj=poss(\",\",portknockseq) ; if(j==0) j=strlen(portknockseq)+1; if(j<i) i=j;\n\t\t\tstrcpy(portstr,portknockseq); \n\t\t\tif( portstr[i-1]!=':' ) { \n\t\t\t\tportstr[i-1]='\\0'; del(portknockseq,1,i);\n\t\t\t\tstrcpy(protostr,\"tcp\");\n\t\t\t\t}\n\t\t\telse {\n\t\t\t\tportstr[i-1]='\\0'; del(portknockseq,1,i);\n\t\t\t\ti=poss(\",\",portknockseq) ; if(i==0) i=strlen(portknockseq)+1;\n\t\t\t\tstrcpy(protostr,portknockseq); protostr[i-1]='\\0'; del(portknockseq,1,i);\n\t\t\t\t}\n\t\t\tport=atoi(portstr);\n\t\t\tif( !stricmp(protostr,\"udp\") ) proto=PROTO_UDP ; else proto=PROTO_TCP ;\n\t\t\t\n\t\t\tif( !stricmp(protostr,\"s\") ) {\n\t\t\t\tSleep( atof(portstr)*1000 ) ; \n\t\t\t} else {\n\t\t\t\tif( knock(host,port,proto) ) fprintf(stderr, \"Unable to knock port\" ) ;\n\t\t\t\tSleep( 40 ) ;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfree(portknockseq);\n\treturn 1;\n\t}\n#endif\n"
        },
        {
          "name": "kitty_ssh.h",
          "type": "blob",
          "size": 0.236328125,
          "content": "#ifndef KITTY_SSH\n#define KITTY_SSH\n\n#ifdef MOD_PORTKNOCKING\n#define PROTO_TCP 1\n#define PROTO_UDP 2\nint knock( char *hostname, unsigned short port, unsigned short proto) ;\nint ManagePortKnocking( char* host, char *portstr ) ;\n#endif\n\n#endif\n"
        },
        {
          "name": "kitty_store.c",
          "type": "blob",
          "size": 21.1826171875,
          "content": "#include <limits.h>\n\n\n#include \"kitty_store.h\"\n#include \"kitty_commun.h\"\n#include \"kitty_tools.h\"\n\n\n#ifndef snewn\n#define snewn(n, type) ((type *)safemalloc((n), sizeof(type)))\n#endif\n#ifndef sfree\n#define sfree safefree\n#endif\n\nvoid debug_log( const char *fmt, ... ) ;\n\n\nvoid DelDir( const char * directory ) ;\nBOOL RegDelTree (HKEY hKeyRoot, LPCTSTR lpSubKey) ;\nvoid CleanFolderName( char * folder ) ;\nchar * GetConfigDirectory( void ) ;\nint GetReadOnlyFlag(void) ;\n\nchar * ltoa (long int __val, char *__s, int __radix) ;\nchar * itoa (int __val, char *__s, int __radix)  ;\nconst char *win_strerror(int error) ;\nchar seedpath[2 * MAX_PATH + 10] = \"\\0\";\nchar sesspath[2 * MAX_PATH] = \"\\0\";\nchar initialsesspath[2 * MAX_PATH] = \"\\0\";\nchar sshkpath[2 * MAX_PATH] = \"\\0\";\nchar jumplistpath[2 * MAX_PATH] = \"\\0\";\nchar oldpath[2 * MAX_PATH] = \"\\0\";\nchar sessionsuffix[16] = \"\\0\";\nchar keysuffix[16] = \"\\0\";\n\nstatic const char hex[16] = \"0123456789ABCDEF\";\n\nvoid fatal_error(const char *p, ...) { exit(0) ; }\n/*\nvoid *safemalloc(size_t n, size_t size) {\n    void *p;\n\n    if (n > INT_MAX / size) {\n\tp = NULL;\n    } else {\n\tsize *= n;\n\tif (size == 0) size = 1;\n#ifdef MINEFIELD\n\tp = minefield_c_malloc(size);\n#else\n\tp = malloc(size);\n#endif\n    }\n\n    if (!p)\n       fatal_error(\"out of memory\");\n\n    return p;\n}\nvoid safefree(void *ptr)\n{\n    if (ptr) {\n#ifdef MINEFIELD\n\tminefield_c_free(ptr);\n#else\n\tfree(ptr);\n#endif\n    }\n}\n*/\n\nvoid SetHostKeyExtension( const char* ext ) {\n\tchar * buffer ;\n\tbuffer = (char*)malloc(strlen(ext)+2);\n\tif( ext[0]!='.' ) { strcpy( buffer, \".\" ) ; } else { strcpy( buffer, \"\" ) ; }\n\tstrcat( buffer, ext ) ;\n\twhile( buffer[strlen(buffer)-1]==' ' ) { buffer[strlen(buffer)-1] = '\\0' ; }\n\tif( strlen(buffer)>15 ) { buffer[15]='\\0' ; }\n\tstrcpy( keysuffix, buffer ) ;\n\tfree( buffer ) ;\n}\n\n\n/* JK: my generic function for simplyfing error reporting */\nDWORD errorShow(const char* pcErrText, const char* pcErrParam) {\n\tHWND hwRodic;\n\tDWORD erChyba;\n\tchar pcBuf[16];\n\tchar* pcHlaska = snewn((pcErrParam?strlen(pcErrParam):0) + strlen(pcErrText) + 256, char);\n\t\n\terChyba = GetLastError();\t\t\n\tltoa(erChyba, pcBuf, 10);\n\n\tstrcpy(pcHlaska, \"Error: \");\n\tstrcat(pcHlaska, pcErrText);\n\tstrcat(pcHlaska, \"\\n\");\n\tstrcat(pcHlaska, \"Directory: \");\n\tchar currpath[2*MAX_PATH];\n\tGetCurrentDirectory( (MAX_PATH*2), currpath);\n\tstrcat(pcHlaska, currpath);\n\tstrcat(pcHlaska, \"\\n\");\n\n\tif (pcErrParam) {\n\t\tstrcat(pcHlaska, pcErrParam);\n\t\tstrcat(pcHlaska, \"\\n\");\n\t}\n    strcat(pcHlaska, \"Error code: \");\n\tstrcat(pcHlaska, pcBuf);\n\n    /* JK: get parent-window and show */\n    hwRodic = GetActiveWindow();\n    if (hwRodic != NULL) { hwRodic = GetLastActivePopup(hwRodic);}\n  \n\tif (MessageBox(hwRodic, pcHlaska, \"Error\", MB_OK|MB_APPLMODAL|MB_ICONEXCLAMATION) == 0) {\n        /* JK: this is really bad -> just ignore */\n\tsfree(pcHlaska);\n        return 0;\n    }\n    \n    //MessageBox(GetActiveWindow(),pcHlaska, \"Error\", MB_OK|MB_APPLMODAL|MB_ICONEXCLAMATION) ;\n    \n\n\tsfree(pcHlaska);\n\treturn erChyba;\n};\n\n/* JK: pack string for use as filename - pack < > : \" / \\ | */\nvoid packstr(const char *in, char *out) {\nEMERGENCY_INIT\n    while (*in) {\nEMERGENCY_BREAK\n\t\tif (*in == '<' || *in == '>' || *in == ':' || *in == '\"' ||\n\t    *in == '/' || *in == '|') {\n\t    *out++ = '%';\n\t    *out++ = hex[((unsigned char) *in) >> 4];\n\t    *out++ = hex[((unsigned char) *in) & 15];\n\t} else\n\t    *out++ = *in;\n\tin++;\n    }\n    *out = '\\0';\n    return;\n}\n\n/*\n * JK: create directory if specified as dir1\\dir2\\dir3 and dir1|2 doesn't exists\n * handle if part of path already exists\n*/\nint createPath(char* dir) {\n    char *p;\n\tif( GetReadOnlyFlag() ) { return 1 ; }\n\tp = strrchr(dir, '\\\\');\n\n\tif (p == NULL) {\n\t\t/* what if it already exists */\n\t\tif (!SetCurrentDirectory(dir)) {\n\t\t\tCreateDirectory(dir, NULL);\n\t\t\treturn SetCurrentDirectory(dir);\n\t\t}\n\t\treturn 1;\n\t}\n\t\n\t*p = '\\0';\n\tif( !createPath(dir) ) { MessageBox(NULL,\"Unable to create directory !\",\"Error\",MB_OK|MB_ICONERROR) ; }\n\t*p = '\\\\';\n\t++p;\n\t/* what if it already exists */\n\tif (!SetCurrentDirectory(dir)) {\n\t\tCreateDirectory(p, NULL);\n\t\treturn SetCurrentDirectory(p) ;\n\t}\n\treturn 1;\n}\n\n/*\n * JK: join path pcMain.pcSuf solving extra cases to pcDest\n * expecting - pcMain as path from WinAPI ::GetCurrentDirectory()/GetModuleFileName()\n *           - pcSuf as user input path from config (at least MAX_PATH long)\n*/\nchar* joinPath(char* pcDest, char* pcMain, char* pcSuf) {\n\n\tchar* pcBuf = snewn(MAX_PATH+1, char);\n\n\t/* at first ExpandEnvironmentStrings */\n\tif (0 == ExpandEnvironmentStrings(pcSuf, pcBuf, MAX_PATH)) {\n\t\t/* JK: failure -> revert back - but it ussualy won't work, so report error to user! */\n\t\terrorShow(\"Unable to ExpandEnvironmentStrings for session path\", pcSuf);\n\t\tstrncpy(pcBuf, pcSuf, strlen(pcSuf));\n\t}\n\t/* now ExpandEnvironmentStringsForUser - only on win2000Pro and above */\n\t/* It's much more tricky than I've expected, so it's ToDo */\n\t/*\n\tstatic HMODULE userenv_module = NULL;\n\ttypedef BOOL (WINAPI *p_ExpandESforUser_t) (HANDLE, LPCTSTR, LPTSTR, DWORD);\n\tstatic p_ExpandESforUser_t p_ExpandESforUser = NULL;\n\t\n\tHMODULE userenv_module = LoadLibrary(\"USERENV.DLL\");\n\n\tif (userenv_module) {\n\t    p_ExpandESforUser = (p_ExpandESforUser_t) GetProcAddress(shell32_module, \"ExpandEnvironmentStringsForUserA\");\n\t\t\n\t\tif (p_ExpandESforUser) {\n\n\t\t\tTOKEN_IMPERSONATE\n\n\t\t\tif (0 == (p_ExpandESforUser(NULL, pcSuf, pcBuf,\tMAX_PATH))) {\n\t    \t\t*//* JK: failure -> revert back - but it ussualy won't work, so report error to user! *//*\n\t\t\t\terrorShow(\"Unable to ExpandEnvironmentStringsForUser for session path\", pcBuf);\n\t\t\t\tstrncpy(pcSuf, pcBuf, strlen(pcSuf));\n\t\t\t}\n\t\t}\n\t}*/\n\n\t/* expand done, resutl in pcBuf */\n\n\tif ((*pcBuf == '/') || (*pcBuf == '\\\\')) {\n\t\t/* everything ok */\n\t\tstrcpy(pcDest, pcMain);\n\t\tstrcat(pcDest, pcBuf);\n\t}\n\telse {\n\t\tif (*(pcBuf+1) == ':') {\n\t\t\t/* absolute path */\n\t\t\tstrcpy(pcDest, pcBuf);\n\t\t}\n\t\telse {\n\t\t\t/* some weird relative path - add '\\' */\n\t\t\tstrcpy(pcDest, pcMain);\n\t\t\tstrcat(pcDest, \"\\\\\");\n\t\t\tstrcat(pcDest, pcBuf);\n\t\t}\n\t}\n\tsfree(pcBuf);\n\treturn pcDest;\n}\n\n/*\n * JK: init path variables from config or otherwise\n * as of 1.5 GetModuleFileName solves our currentDirectory problem\n*/\nint loadPath() {\n\tif( *sesspath != '\\0') { return 0 ; }\n\n\tchar *fileCont = NULL;\n\tDWORD fileSize;\n\tDWORD bytesRead;\n\tchar *p = NULL;\n\tchar *p2 = NULL;\n\tHANDLE hFile ;\n\n\tchar* puttypath = snewn( (MAX_PATH*2), char);\n\t\n\t/* JK:  save path/curdir */\n\tGetCurrentDirectory( (MAX_PATH*2), oldpath);\n\n\t/* JK: try curdir for putty.conf first */\n\thFile = CreateFile(\"putty.conf\",GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n\n\tif (hFile != INVALID_HANDLE_VALUE)\n\t{\n\t\t/* JK: there is a putty.conf in curdir - use it and use curdir as puttypath */\n\t\tGetCurrentDirectory( (MAX_PATH*2), puttypath);\n\t\tCloseHandle(hFile);\n\t} else {\n\t\t/* JK: get where putty.exe is */\n\t\tif (GetModuleFileName(NULL, puttypath, (MAX_PATH*2)) != 0)\n\t\t{\n\t\t\tp = strrchr(puttypath, '\\\\');\n\t\t\tif (p)\n\t\t\t{\n\t\t\t\t*p = '\\0';\n\t\t\t}\n\t\t\tSetCurrentDirectory(puttypath);\n\t\t}\n\t\telse GetCurrentDirectory( (MAX_PATH*2), puttypath);\n\t}\n\n\t/* JK: set default values - if there is a config file, it will be overwitten */\n\tif( GetConfigDirectory() != NULL ) { // Cas ou defini un autre repertoire de configuration\n\t\tstrcpy(sesspath, GetConfigDirectory());\n\t\tstrcat(sesspath, \"\\\\Sessions\");\n\t\tstrcpy(initialsesspath,sesspath);\n\t\tstrcpy(sshkpath, GetConfigDirectory());\n\t\tstrcat(sshkpath, \"\\\\SshHostKeys\");\n\t\tstrcpy(jumplistpath, GetConfigDirectory());\n\t\tstrcat(jumplistpath, \"\\\\Jumplist\");\n\t\tstrcpy(seedpath, GetConfigDirectory());\n\t\tstrcat(seedpath, \"\\\\putty.rnd\");\n\t\t}\n\telse {\n\t\tstrcpy(sesspath, puttypath);\n\t\tstrcat(sesspath, \"\\\\Sessions\");\n\t\tstrcpy(initialsesspath,sesspath);\n\t\tstrcpy(sshkpath, puttypath);\n\t\tstrcat(sshkpath, \"\\\\SshHostKeys\");\n\t\tstrcpy(jumplistpath, puttypath);\n\t\tstrcat(jumplistpath, \"\\\\Jumplist\");\n\t\tstrcpy(seedpath, puttypath);\n\t\tstrcat(seedpath, \"\\\\putty.rnd\");\n\t\t}\n\n\thFile = CreateFile(\"putty.conf\",GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n\t/* Test Sessions directory */\n\tif(get_param(\"INIFILE\")==SAVEMODE_DIR)\n\tif( !existdirectory(sesspath) ) {\n\t\tif( !MakeDir(sesspath) ) {\n\t\t\tMessageBox( NULL, \"Unable to create sessions directory !\", \"Error\", MB_OK|MB_ICONERROR ) ;\n\t\t}\n\t}\n\n\t/* JK: now we can pre-clean-up */\n\tSetCurrentDirectory(oldpath);\n\n\tif (hFile != INVALID_HANDLE_VALUE) {\n\t\tfileSize = GetFileSize(hFile, NULL);\n\t\tfileCont = snewn(fileSize+16, char);\n\n\t\tif (!ReadFile(hFile, fileCont, fileSize, &bytesRead, NULL))\n\t\t{\n\t\t\terrorShow(\"Unable to read configuration file, falling back to defaults\", NULL);\n\t\t\t/* JK: default values are already there and clean-up at end */\n\t\t}\n\t\telse {\n\t\t\t/* JK: parse conf file to path variables */\n\t\t\t*(fileCont+fileSize+1) = '\\0';\n\t\t\t*(fileCont+fileSize) = '\\n';\n\t\t\tp = fileCont;\nEMERGENCY_INIT\n\t\t\twhile (p) {\nEMERGENCY_BREAK\n\t\t\t\tif (*p == ';') {\t/* JK: comment -> skip line */\n\t\t\t\t\tp = strchr(p, '\\n');\n\t\t\t\t\t++p;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tp2 = strchr(p, '=');\n\t\t\t\tif (!p2) break;\n\t\t\t\t*p2 = '\\0';\n\t\t\t\t++p2;\n\n\t\t\t\tif (!strcmp(p, \"Sessions\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(sesspath, puttypath, p2);\n\t\t\t\t\tp2 = sesspath+strlen(sesspath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"SshHostKeys\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(sshkpath, puttypath, p2);\n\t\t\t\t\tp2 = sshkpath+strlen(sshkpath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"Jumplist\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(jumplistpath, puttypath, p2);\n\t\t\t\t\tp2 = jumplistpath+strlen(jumplistpath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"seedfile\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tjoinPath(seedpath, puttypath, p2);\t\t\t\n\t\t\t\t\tp2 = seedpath+strlen(seedpath)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"sessionsuffix\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstrcpy(sessionsuffix, p2);\n\t\t\t\t\tp2 = sessionsuffix+strlen(sessionsuffix)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\telse if (!strcmp(p, \"keysuffix\")) {\n\t\t\t\t\tp = strchr(p2, '\\n');\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tstrcpy(keysuffix, p2);\n\t\t\t\t\tp2 = keysuffix+strlen(keysuffix)-1;\n\t\t\t\t\twhile ((*p2 == ' ')||(*p2 == '\\n')||(*p2 == '\\r')||(*p2 == '\\t')) --p2;\n\t\t\t\t\t*(p2+1) = '\\0';\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t}\n\t\t}\n\t\tCloseHandle(hFile);\n\t\tsfree(fileCont);\n\t}\n\t/* else - INVALID_HANDLE {\n\t\t * JK: unable to read conf file - probably doesn't exists\n\t\t * we won't create one, user wants putty light, just fall back to defaults\n\t\t * and defaults are already there\n\t}*/\n\n\tsfree(puttypath);\n\treturn 1;\n}\nchar * SetSessPath( const char * dec ) {\n\tint i ;\n\tchar *pst ;\n\tif( !strcmp(dec,\"..\") ) {\n\t\tif( strcmp(sesspath, initialsesspath) ) {\n\t\t\ti=strlen(sesspath)-1 ;\n\t\t\twhile( (sesspath[i]!='\\\\') && (i>0) ) i--;\n\t\t\tsesspath[i]='\\0';\n\t\t}\n\t} else {\n\t\tstrcat( sesspath, \"\\\\\" ) ;\n\t\tstrcat( sesspath, dec ) ;\n\t}\n\tCleanFolderName( sesspath ) ;\n\tpst = sesspath+strlen(initialsesspath ) ;\n\twhile( pst[0]=='\\\\' ) pst++ ;\n\treturn pst ;\n}\n\t\nchar * SetInitialSessPath( void ) { return strcpy( sesspath, initialsesspath ) ; }\n\nchar * GetSessPath( void ) {\n\treturn sesspath ;\n}\n\nbool SessPathIsInitial( void ) {\n\tif( !strcmp( sesspath, initialsesspath ) ) { return true ; }\n\telse { return false ; }\n}\n\nbool IsThereDefaultSessionFile( void ) {\n\tbool t=false;\n\tchar *buf = (char*)malloc(strlen(sesspath)+strlen(\"Default%%20Settings\")+strlen(FileExtension)+2) ;\n\tif( !strcmp(FileExtension,\"\") ) {\n\t\tsprintf(buf,\"%s\\\\Default%%20Settings%s\",sesspath,FileExtension) ;\n\t} else {\n\t\tsprintf(buf,\"%s\\\\Default%%20Settings\",sesspath) ;\n\t}\n\tt = existfile(buf) ;\n\tfree(buf) ;\n\treturn t;\n}\n\nint CreateFolderInPath( const char * d ) {\n\tchar buf[MAX_PATH] ;\n\tint res = 0 ;\n\tsprintf( buf, \"%s\\\\%s\", sesspath, d ) ;\n\tres = createPath( buf ) ;\n\tif( !res ) { MessageBox(NULL,\"Unable to create directory\", \"Error\", MB_OK|MB_ICONERROR); }\n\treturn res ;\n}\n\nvoid SaveDumpPortableConfig( FILE * fp ) {\n\tfprintf( fp, \"seedpath=%s\\n\", seedpath ) ;\n\tfprintf( fp, \"sesspath=%s\\n\", sesspath ) ;\n\tfprintf( fp, \"initialsesspath=%s\\n\", initialsesspath ) ;\n\tfprintf( fp, \"sshkpath=%s\\n\", sshkpath ) ;\n\tfprintf( fp, \"jumplistpath=%s\\n\", jumplistpath ) ;\n\tfprintf( fp, \"oldpath=%s\\n\", oldpath ) ;\n\tfprintf( fp, \"sessionsuffix=%s\\n\", sessionsuffix ) ;\n\tfprintf( fp, \"keysuffix=%s\\n\", keysuffix ) ;\n}\n\n\nHSettingsItem SettingsNewItem( const char * name, const char * value ) {\n\tif( name==NULL ) return NULL ; \n\tHSettingsItem NewItem = malloc( sizeof( SettingsItem ) ) ;\n\tNewItem->pNext = NULL ;\n\tNewItem->pPrevious = NULL ;\n\tNewItem->name = malloc( strlen(name) + 1 ) ; strcpy( NewItem->name, name ) ;\n\tif( value == NULL ) { \n\t\tNewItem->value = NULL ;\n\t} else {\n\t\tNewItem->value = malloc( strlen(value) + 1 ) ; strcpy( NewItem->value, value ) ;\n\t}\n\treturn NewItem ;\n}\n\nHSettingsList SettingsInit() {\n\tHSettingsList list = (HSettingsList)malloc( sizeof(SettingsList) ) ;\n\tlist->filename = NULL ;\n\tlist->num = 0 ;\n\tlist->first = NULL ;\n\tlist->last = NULL ;\n\treturn list ;\n}\n\nHSettingsList PortableSettings ;\n\nvoid SettingsDelItem( HSettingsList list, const char * key ) {\n\tif( list != NULL ) {\n\t\tHSettingsItem current = list->first ;\n\t\twhile( current != NULL ) {\n\t\t\tif( current->name != NULL ) {\n\t\t\t\tif( !strcmp( current->name, key ) ) {\n\t\t\t\t\tif( current->value != NULL ) { free( current->value ) ; current->value = NULL ; }\n\t\t\t\t\tfree( current->name ) ; current->name = NULL ;\n\t\t\t\t\tif( current->pPrevious != NULL ) { \n\t\t\t\t\t\tcurrent->pPrevious->pNext = current->pNext ;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist->first = current->pNext ;\n\t\t\t\t\t}\n\t\t\t\t\tif( current->pNext != NULL )\t{\n\t\t\t\t\t\tcurrent->pNext->pPrevious = current->pPrevious ;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlist->last = current->pPrevious ;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t\tcurrent = current->pNext ;\n\t\t}\n\t}\n}\n\nvoid SettingsAddItem( HSettingsList list, const char * name, const char * value ) {\n\tif( list!=NULL ) {\n\t\tHSettingsItem NewItem = SettingsNewItem( name, value ) ;\n\t\tif( NewItem != NULL ) {\n\t\t\tHSettingsItem current = list->last ;\n\t\t\tif( current == NULL ) {\n\t\t\t\tlist->first = NewItem ;\n\t\t\t\tNewItem->pNext = NULL ;\n\t\t\t\tNewItem->pPrevious = NULL ;\n\t\t\t} else {\n\t\t\t\tSettingsDelItem( list, name ) ;\n\t\t\t\tcurrent->pNext = NewItem ;\n\t\t\t\tNewItem->pPrevious = current ;\n\t\t\t}\n\t\t\tlist->last = NewItem ;\n\t\t\tlist->num = list->num + 1 ;\n\t\t}\n\t}\n}\n\nvoid SettingsFreeItem( HSettingsItem item ) {\n\tif( item != NULL ) {\n//debug_log(\"%s=%s\\n\",item->name,item->value);\n\t\tif( item->value != NULL ) { free( item->value ) ; item->value = NULL ; } // POURQUOI CA PLANTE ???\n\t\tif( item->name != NULL ) { free( item->name ) ; item->name = NULL ; }\n\t\titem->pPrevious = NULL ;\n\t\titem->pNext = NULL ;\n\t\tfree( item ) ;\n\t}\n}\n\nvoid SettingsFree( HSettingsList list ) {\n\tif( list != NULL ) {\n\t\tHSettingsItem current = list->first, next ;\n\t\tif( current != NULL ) {\n\t\t\twhile( current != NULL ) {\n\t\t\t\tnext = current->pNext ;\n\t\t\t\tSettingsFreeItem( current ) ;\n\t\t\t\tcurrent = next ;\n\t\t\t} \n\t\t}\n\t\tlist->first = NULL ;\n\t\tlist->last = NULL ;\n\t\tif( list->filename != NULL ) { free( list->filename ) ; list->filename = NULL ; }\n\t\tlist->num = 0 ;\n\t\tfree( list ) ;\n\t}\n}\n\nchar * SettingsKey( HSettingsList list, const char * key ) {\n\tif( list != NULL ) {\n\t\tHSettingsItem current = list->first ;\n\t\twhile( current != NULL ) {\n\t\t\tif( current->name != NULL ) {\n\t\t\t\tif( !strcmp( current->name, key ) ) return current->value ;\n\t\t\t}\n\t\t\tcurrent = current->pNext ;\n\t\t}\n\t}\n\treturn NULL ;\n}\n\nchar * SettingsKey_str( HSettingsList list, const char * key ) {\n\tif( list != NULL ) {\n\t\tHSettingsItem current = list->first ;\n\t\twhile( current != NULL ) {\n\t\t\tif( current->name != NULL ) {\n\t\t\t\tif( !strcmp( current->name, key ) ) {\n\t\t\t\t\treturn dupstr( current->value ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current->pNext ;\n\t\t}\n\t}\n\treturn NULL ;\n}\n\nint SettingsKey_int( HSettingsList list, const char * key, const int defvalue ) {\n\tif( list != NULL ) {\n\t\tHSettingsItem current = list->first ;\n\t\twhile( current != NULL ) {\n\t\t\tif( current->name != NULL ) {\n\t\t\t\tif( !strcmp( current->name, key ) ) {\n\t\t\t\t\treturn atoi( current->value ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = current->pNext ;\n\t\t}\n\t}\n\treturn defvalue ;\n}\n\nvoid SettingsLoad( HSettingsList list, const char * filename ) {\n\tFILE * fp ;\n\tchar *buffer;\n\tint p ;\n\t\n//debug_log(\"filename=%s|\\n\",filename); int i=0;\n\t\n\tif( (fp=fopen(filename,\"rb\")) != NULL ) {\n\t\tlist->filename = (char*) malloc( strlen(filename)+1 ) ; strcpy( list->filename, filename ) ;\n\t\tbuffer = (char*)malloc(4096*sizeof(char)) ;\n\t\twhile( fgets(buffer,4096,fp) != NULL ) {\n//debug_log(\"\\nline %05d[%d]: %s|\\n\",++i,strlen(buffer),buffer);\n\t\t\twhile( buffer[strlen(buffer)-1]!='\\n' ) {\n\t\t\t\tbuffer = realloc( buffer, strlen(buffer) + 4096 ) ;\n\t\t\t\tif( fgets( buffer+strlen(buffer), 4096, fp ) == NULL ) { break ; }\n//debug_log(\"\\nline %05d[%d]: %s|\\n\",++i,strlen(buffer),buffer);\n\t\t\t}\n\n\t\t\tchar *name, *value, *value2 ;\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n') || (buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1] = '\\0' ;\n//debug_log(\"line %05d[%d]: %s|\\n\",i,strlen(buffer),buffer);\n//debug_log(\"\\t-2=%c -3=%c\\n\",buffer[strlen(buffer)-2],buffer[strlen(buffer)-3]);\n\t\t\twhile( buffer[strlen(buffer)-1]!='\\\\' ) {\n//debug_log(\"ici\\n\");\n\t\t\t\twhile( buffer[strlen(buffer)-1]=='\\r' ) { buffer[strlen(buffer)+1]='\\0' ; buffer[strlen(buffer)-1]='\\\\' ; buffer[strlen(buffer)] = 'r' ; }\n\t\t\t\twhile( buffer[strlen(buffer)-1]=='\\n' ) { buffer[strlen(buffer)+1]='\\0' ; buffer[strlen(buffer)-1]='\\\\' ; buffer[strlen(buffer)] = 'n' ; }\n\t\t\t\tif( fgets( buffer+strlen(buffer), 4096, fp ) == NULL ) { break ; }\n\t\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n') || (buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1] = '\\0' ;\n\t\t\t}\n//debug_log(\"line %05d[%d]: %s|\\n\",i,strlen(buffer),buffer);\n\t\t\twhile( (buffer[strlen(buffer)-1]=='\\n') || (buffer[strlen(buffer)-1]=='\\r') ) buffer[strlen(buffer)-1] = '\\0' ;\n//debug_log(\"line %05d[%d]: %s|\\n\",i,strlen(buffer),buffer);\n\t\t\tif( buffer[strlen(buffer)-1] != '\\\\' ) { strcat( buffer, \"\\\\\" ) ; }\n//debug_log(\"line %05d[%d]: %s|\\n\",i,strlen(buffer),buffer);\n\t\t\tp = poss( \"\\\\\", buffer ) ;\n\t\t\tif( p>1 ) {\n\t\t\t\tname = (char*) malloc( p+1 ) ;\n\t\t\t\tmemcpy( name, buffer, p-1 ) ; name[p-1]='\\0' ;\n\t\t\t\tvalue = (char*) malloc( strlen(buffer)-p+1 ) ;\n\t\t\t\tstrcpy( value, buffer+p ) ;\n\t\t\t\tvalue[strlen(value)-1]='\\0' ;\n//debug_log(\"line %05d: %s|%s|\\n\",i,name,value);\n\t\t\t\tvalue2 = (char*) malloc( strlen(value)+1 ) ;\n\t\t\t\tunmungestr( value, value2, strlen(value)+1 ) ;\n//debug_log(\"line %05d: %s|%s|%s|\\n\",i,name,value,value2);\n\t\t\t\tSettingsAddItem( list, name, value2 ) ;\n\t\t\t\tfree( value2 ) ;\n\t\t\t\tfree( value ) ;\n\t\t\t\tfree( name ) ;\n\t\t\t}\n\t\t}\n\t\tfree(buffer) ;\n\t\tfclose(fp );\n\t} else {\n\t\t//if( strcmp(filename,\"Default%20Settings\") ) MessageBox(NULL,\"Unable to open session file\", \"Error\", MB_OK);\n\t\terrorShow( \"Unable to read session file\", filename ) ;\n\t}\n}\n\nvoid SettingsSave( HSettingsList list, const char * filename ) {\n\tFILE * fp ;\n\tchar buffer[4096] ;\n\t\n\tif( (fp=fopen(filename,\"wb\")) != NULL ) {\n\t\tif( list != NULL ) {\n\t\t\tHSettingsItem current = list->first ;\n\t\t\twhile( current != NULL ) {\n\t\t\t\tif( current->name != NULL ) {\n\t\t\t\t\tif( current->value == NULL ) {\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\\\\\\\n\", current->value ) ;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchar * p = (char*) malloc( 3*strlen(current->value)+1 ) ;\n\t\t\t\t\t\tmungestr( current->value, p ) ;\n\t\t\t\t\t\tsprintf( buffer, \"%s\\\\%s\\\\\\n\", current->name, p ) ;\n\t\t\t\t\t\tfree( p ) ;\n\t\t\t\t\t}\n\t\t\t\t\tfputs( buffer, fp ) ;\n\t\t\t\t\tfflush( fp ) ;\n\t\t\t\t}\n\t\t\t\tcurrent = current->pNext ;\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t} else {\n\t\terrorShow( \"Unable to write session file\", filename ) ;\n\t}\n}\n\n\n/*\nvoid SettingsPrint( HSettingsList list ) {\n\tif( list != NULL ) {\n\t\tdebug_log( \"->filename=%s\\n\", list->filename ) ;\n\t\tdebug_log( \"->num=%d\\n\", list->num ) ;\n\t\tdebug_log( \"->first=%ld\\n\", list->first ) ;\n\t\tdebug_log( \"->last=%ld\\n\", list->last ) ;\n\t\tHSettingsItem current = list->first ;\n\t\twhile( current != NULL ) {\n\t\t\tif( current->name !=NULL ) {\n\t\t\t\tif( current->value !=NULL ) { debug_log( \"%s=%s\\n\", current->name, current->value ) ;\n\t\t\t\t} else { debug_log( \"%s=NULL\\n\", current->name ) ;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdebug_log(\"\tcurrent=%ld\\n\", current );\n\t\t\tif( current->pPrevious == NULL ) { debug_log( \"\tprevious=NULL\\n\" ) ; }\n\t\t\telse { debug_log( \"\tprevious=%ld\\n\", current->pPrevious ) ; }\n\t\t\tif( current->pNext == NULL ) { debug_log( \"\tnext=NULL\\n\" ) ; }\n\t\t\telse { debug_log( \"\tnext=%ld\\n\", current->pNext ) ; }\n\t\t\tcurrent = current->pNext ;\n\t\t}\n\t}\n\tdebug_log( \"NULL\\n\\n\" ) ;\n}\n\nvoid SettingTest( void ) {\n\tPortableSettings = SettingsInit() ;\n\tSettingsPrint( PortableSettings ) ;\n\tSettingsLoad( PortableSettings, \"Ken\" ) ;\n\tSettingsPrint( PortableSettings ) ;\n\tSettingsFree( PortableSettings ) ;\n\tdebug_log( \"FIN\\n\\n\" ) ;\n\n}\n*/\n\nbool ReadPortableValue(const char *buffer, const char * name, char * value, const int maxlen) {\n\tbool test = false ;\n\tif( (buffer==NULL) || (name==NULL) ) { return false ; }\n\tif( (strlen(buffer)==0) || (strlen(name)==0) ) { return false ; }\n\tif( maxlen<=0 ) { return false ; }\n\tchar *b = (char*)malloc(strlen(name)+2), *pst ;\n\tsprintf(b,\"%s\\\\\",name) ;\n\tif( strstr(buffer,b)==buffer ) {\n\t\tpst = (char*)buffer + strlen(b) ;\n\t\ttest = true ;\n\t\tvalue[0]='\\0';\n\t\tif( strlen(pst)>1 )\n\t\tif( (strlen(pst)<=maxlen) && (pst[strlen(pst)-2]=='\\\\') ) {\n\t\t\tmemcpy( value, pst, strlen(pst)-2 ) ;\n\t\t\tvalue[strlen(pst)-2] = '\\0' ;\n\t\t}\n\t\tunmungestr( value, value, MAX_VALUE_NAME ) ;\n\t}\n\tfree(b) ;\n\treturn test ;\n}\n"
        },
        {
          "name": "kitty_store.h",
          "type": "blob",
          "size": 2.2451171875,
          "content": "#ifndef SAVEMODE_REG\n#define SAVEMODE_REG 0\n#endif\n#ifndef SAVEMODE_FILE\n#define SAVEMODE_FILE 1\n#endif\n#ifndef SAVEMODE_DIR\n#define SAVEMODE_DIR 2\n#endif\n\n#define EMERGENCY_INIT int emergency_brake_count = 200000, while_iterations=0 ;\n#define EMERGENCY_BREAK if( while_iterations++ > emergency_brake_count ) { break ; }\n\n#include \"kitty_commun.h\"\n#include \"kitty_tools.h\"\n\nint get_param( const char * val ) ;\nvoid mungestr(const char *in, char *out);\nvoid unmungestr( const char *in, char *out, int outlen ) ;\nvoid packstr(const char *in, char *out) ;\nDWORD errorShow(const char* pcErrText, const char* pcErrParam) ;\nchar *itoa(int value, char *string, int radix);\nint createPath(char* dir) ;\nchar *dupstr(const char *s);\n\nextern char sesspath[2 * MAX_PATH] ;\nextern char oldpath[2 * MAX_PATH] ;\nextern char initialsesspath[2 * MAX_PATH] ;\nextern char sessionsuffix[16] ;\nextern char sshkpath[2 * MAX_PATH] ;\nextern char keysuffix[16] ;\nextern char jumplistpath[2 * MAX_PATH] ;\n\nstruct SettingsItem {\n\tchar * name ;\n\tchar * value ;\n\tstruct SettingsItem * pNext ; \n\tstruct SettingsItem * pPrevious ; \n} ;\ntypedef struct SettingsItem SettingsItem, *HSettingsItem ;\n\nstruct SettingsList {\n\tchar * filename ;\n\tint num ;\n\tHSettingsItem first ;\n\tHSettingsItem last ;\n} ;\ntypedef struct SettingsList SettingsList, *HSettingsList;\n\nextern HSettingsList PortableSettings ;\n\nHSettingsItem SettingsNewItem( const char * name, const char * value ) ;\nvoid SettingsFreeItem( HSettingsItem item ) ;\n\nHSettingsList SettingsInit() ;\nvoid SettingsDelItem( HSettingsList list, const char * key ) ;\nvoid SettingsAddItem( HSettingsList list, const char * name, const char * value ) ;\nvoid SettingsFree( HSettingsList list ) ;\nchar * SettingsKey( HSettingsList list, const char * key ) ;\nchar * SettingsKey_str( HSettingsList list, const char * key ) ;\nint SettingsKey_int( HSettingsList list, const char * key, const int defvalue ) ;\n\nvoid SettingsLoad( HSettingsList list, const char * filename ) ;\nvoid SettingsSave( HSettingsList list, const char * filename ) ;\n\nint loadPath() ;\nchar * SetInitialSessPath( void ) ;\nchar * GetSessPath( void ) ;\nbool SessPathIsInitial( void ) ;\nbool IsThereDefaultSessionFile( void ) ;\n\nbool ReadPortableValue(const char *buffer, const char * name, char * value, const int maxlen) ;\n"
        },
        {
          "name": "kitty_tools.c",
          "type": "blob",
          "size": 7.396484375,
          "content": "#include \"kitty_tools.h\"\n\nchar *stristr (const char *meule_de_foin, const char *aiguille) {\n\tchar *c1, *c2, *res = NULL ; int i ;\n\tc1=(char*)malloc( strlen(meule_de_foin) + 1 ) ; strcpy( c1, meule_de_foin ) ;\n\tc2=(char*)malloc( strlen(aiguille) + 1 ) ; strcpy( c2, aiguille ) ;\n\tif( strlen(c1)>0 ) {for( i=0; i<strlen(c1); i++ ) c1[i]=toupper( c1[i] ) ;}\n\tif( strlen(c2)>0 ) {for( i=0; i<strlen(c2); i++ ) c2[i]=toupper( c2[i] ) ;}\n\tres=strstr(c1,c2);\n\tif( res!=NULL ) res = (char*)(meule_de_foin+( res-c1 )) ;\n\tfree( c2 ) ;\n\tfree( c1 ) ;\n\treturn res ;\n}\n\n/* Fonction permettant d'inserer une chaine dans une autre */\nint insert( char * ch, const char * c, const int ipos ) {\n\tint i = ipos, len = strlen( c ), k ;\n\tif( ( ch == NULL ) || ( c == NULL ) ) return -1 ;\n\tif( len > 0 ) {\n\t\tif( (size_t) i > ( strlen( ch ) + 1 ) ) i = strlen( ch ) + 1 ;\n\t\tfor( k = strlen( ch ) ; k >= ( i - 1 ) ; k-- ) ch[k + len] = ch[k] ;\n\t\tfor( k = 0 ; k < len ; k++ ) ch[k + i - 1] = c[k] ; \n\t}\n\treturn strlen( ch ) ; \n}\n\n/* Fonction permettant de supprimer une partie d'une chaine de caracteres */\nint del( char * ch, const int start, const int length ) {\n\tint k, len = strlen( ch ) ;\n\tif( ch == NULL ) return -1 ;\n\tif( ( start == 1 ) && ( length >= len ) ) { ch[0] = '\\0' ; len = 0 ; }\n\tif( ( start > 0 ) && ( start <= len ) && ( length > 0 ) ) {\n\t\tfor( k = start - 1 ; k < ( len - length ) ; k++ ) {\n\t\t\tif( k < ( len - length ) ) {\n\t\t\t\tch[k] = ch[ k + length ] ;\n\t\t\t} else  {\n\t\t\t\tch[k] = '\\0' ;\n\t\t\t}\n\t\t}\n\t\tk = len - length ;\n\t\tif( ( start + length ) > len ) k = start - 1 ;\n\t\tch[k] = '\\0' ; \n\t}\n\treturn strlen( ch ) ; \n}\n\n/* Fonction permettant de retrouver la position d'une chaine dans une autre chaine */\nint poss( const char * c, const char * ch ) {\n\tchar * c1 , * ch1 , * cc ;\n\tint res ;\n\tif( ( ch == NULL ) || ( c == NULL ) ) return -1 ;\n\tif( ( c1 = (char *) malloc( strlen( c ) + 1 ) ) == NULL ) return -2 ;\n\tif( ( ch1 = (char *) malloc( strlen( ch ) + 1 ) ) == NULL ) { free( c1 ) ; return -3 ; }\n\tstrcpy( c1, c ) ; strcpy( ch1, ch ) ;\n\tcc = (char *) strstr( ch1, c1 ) ;\n\tif( cc == NULL ) res = 0 ;\n\telse res = (int) ( cc - ch1 ) + 1 ;\n\tif( (size_t) res > strlen( ch ) ) res = 0 ;\n\tfree( ch1 ) ;\n\tfree( c1 ) ;\n\treturn res ; \n}\n\t\n/* Fonction permettant de retrouver la position d'une chaîne de caracteres dans une chaine a partir d'une position donnee */\nint posi( const char * c, const char * ch, const int ipos ) {\n\tint res ;\n\tif( ( c == NULL ) || ( ch == NULL ) ) return -1 ;\n\tif( ( ipos <= 0 ) || ( (size_t) ipos > strlen( ch ) ) ) return 0 ;\n\tres = poss( c, ch + ( ipos - 1 ) ) ;\n\tif( res > 0 ) return res + ( ipos -1 ) ;\n\telse return 0 ;\n}\n\n// Teste l'existance d'un fichier\nint existfile( const char * filename ) {\n\tstruct _stat statBuf ;\n\t\n\tif( filename == NULL ) return 0 ;\n\tif( strlen(filename)==0 ) return 0 ;\n\tif( _stat( filename, &statBuf ) == -1 ) return 0 ;\n\t\n\tif( ( statBuf.st_mode & _S_IFMT ) == _S_IFREG ) { return 1 ; }\n\telse { return 0 ; }\n}\n\n// Teste l'existance d'un repertoire\nint existdirectory( const char * filename ) {\n\tstruct _stat statBuf ;\n\t\n\tif( filename == NULL ) return 0 ;\n\tif( strlen(filename)==0 ) return 0 ;\n\tif( _stat( filename, &statBuf ) == -1 ) return 0 ;\n\t\n\tif( ( statBuf.st_mode & _S_IFMT ) == _S_IFDIR ) { return 1 ; }\n\telse { return 0 ; }\n}\n\n/* Donne la taille d'un fichier */\nlong filesize( const char * filename ) {\n\tFILE * fp ;\n\tlong length ;\n\n\tif( filename == NULL ) return 0 ;\n\tif( strlen( filename ) <= 0 ) return 0 ;\n\t\n\tif( ( fp = fopen( filename, \"r\" ) ) == 0 ) return 0 ;\n\t\n\tfseek( fp, 0L, SEEK_END ) ;\n\tlength = ftell( fp ) ;\n\t\n\tfclose( fp ) ;\n\treturn length ;\n}\n\n// Supprime les double anti-slash\nvoid DelDoubleBackSlash( char * st ) {\n\tint i=0,j ;\n\twhile( st[i] != '\\0' ) {\n\t\tif( (st[i] == '\\\\' )&&(st[i+1]=='\\\\' ) ) {\n\t\t\tfor( j=i+1 ; j<strlen( st ) ; j++ ) st[j]=st[j+1] ;\n\t\t}\n\t\telse i++ ;\n\t}\n}\n\n// Ajoute une chaine dans une liste de chaines\nint StringList_Add( char **list, const char * name ) {\n\tint i = 0 ;\n\tif( name == NULL ) return 1 ;\n\twhile( list[i] != NULL ) {\n\t\tif( !stricmp( name, list[i] ) ) return 1 ;\n\t\ti++ ;\n\t}\n\tif( ( list[i] = (char*) malloc( strlen( name ) + 1 ) ) == NULL ) return 0 ;\n\tstrcpy( list[i], name ) ;\n\tlist[i+1] = NULL ;\n\treturn 1 ;\n}\n\n// Test si une chaine existe dans une liste de chaines\nint StringList_Exist( const char **list, const char * name ) {\n\tint i = 0 ;\n\twhile( list[i] != NULL ) {\n\t\tif( strlen( list[i] ) > 0 )\n\t\t\tif( !strcmp( list[i], name ) ) return 1 ;\n\t\ti++ ;\n\t}\n\treturn 0 ;\n}\n\t\n// Supprime une chaine d'une liste de chaines\nvoid StringList_Del( char **list, const char * name ) {\n\tint i = 0 ;\n\twhile( list[i] != NULL ) {\n\t\tif( strlen( list[i] ) > 0 )\n\t\t\tif( !strcmp( list[i], name ) ) {\n\t\t\t\tstrcpy( list[i], \"\" ) ;\n\t\t\t}\n\t\ti++;\n\t}\n}\n\n// Reorganise l'ordre d'une liste de chaines en montant la chaine selectionnee d'un cran\nvoid StringList_Up( char **list, const char * name ) {\n\tchar *buffer ;\n\tint i = 0 ;\n\twhile( list[i] != NULL ) {\n\t\tif( !strcmp( list[i], name ) ) {\n\t\t\tif( i > 0 ) {\n\t\t\t\tbuffer=(char*)malloc( strlen(list[i-1])+1 ) ;\n\t\t\t\tstrcpy( buffer, list[i-1] ) ;\n\t\t\t\tfree( list[i-1] ) ; list[i-1] = NULL ;\n\t\t\t\tlist[i-1]=(char*)malloc( strlen(list[i])+1 ) ;\n\t\t\t\tstrcpy( list[i-1], list[i] ) ;\n\t\t\t\tfree( list[i] ) ;\n\t\t\t\tlist[i] = (char*) malloc( strlen( buffer ) +1 ) ;\n\t\t\t\tstrcpy( list[i], buffer );\n\t\t\t\tfree( buffer );\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\ti++ ;\n\t}\n}\n\n// Positionne l'environnement\nint putenv (const char *string) ;\nint set_env( char * name, char * value ) {\n\tint res = 0 ;\n\tchar * buffer = NULL ;\n\tif( (buffer = (char*) malloc( strlen(name)+strlen(value)+2 ) ) == NULL ) return -1 ;\n\tsprintf( buffer,\"%s=%s\", name, value ) ; \n\tres = putenv( (const char *) buffer ) ;\n\tfree( buffer ) ;\n\treturn res ;\n}\n\nint add_env( char * name, char * value ) {\n\tint res = 0 ;\n\tchar * npst = getenv( name ), * vpst = NULL ;\n\tif( npst==NULL ) { \n\t\tres = set_env( name, value ) ; \n\t} else {\n\t\tvpst = (char*) malloc( strlen(npst)+strlen(value)+20 ) ; \n\t\tsprintf( vpst, \"%s=%s;%s\", name, npst, value ) ;\n\t\tres = set_env( name, vpst ) ;\n\t\tfree( vpst ) ;\n\t}\n\treturn res ;\n}\n\n// Creer un repertoire recurssif (rep1 / rep2 / ...)\nint _mkdir (const char*);\nint MakeDir( const char * directory ) {\n\tchar buffer[MAX_VALUE_NAME], fullpath[MAX_VALUE_NAME], *p, *pst ;\n\tint i,j ;\n\t\n\tif( directory==NULL ) { return 1 ; } \n\tif( strlen(directory)==0 ) { return 1 ; }\n\n\tfor( i=0, j=0 ; i<=strlen(directory) ; i++,j++ ) { // On supprime les espaces après un '\\' \n\t\tif( (directory[i]=='\\\\')||(directory[i]=='/') ) {\n\t\t\tfullpath[j]='\\\\' ;\n\t\t\twhile( (directory[i+1]==' ')||(directory[i+1]=='\t') ) i++ ;\n\t\t} else \n\t\t\tfullpath[j]=directory[i] ;\n\t}\n\tfullpath[j+1]='\\0' ;\n\t\t\n\t// On supprime les espaces, les / et les \\\\ à la fin\n\twhile( (fullpath[strlen(fullpath)-1]==' ')||(fullpath[strlen(fullpath)-1]=='\t')||(fullpath[strlen(fullpath)-1]=='/')||(fullpath[strlen(fullpath)-1]=='\\\\') ) fullpath[strlen(fullpath)-1]='\\0';\n\n\tfor( i=strlen(fullpath), j=strlen(fullpath) ; i>=0 ; i--, j-- ) { // On supprime les espaces avant un '\\'\n\t\tif( fullpath[i] == '\\\\' ) {\n\t\t\tbuffer[j]='\\\\' ;\n\t\t\twhile( (i>0)&&((fullpath[i-1]==' ')||(fullpath[i-1]=='\t')) ) i-- ;\n\t\t} else\n\t\t\tbuffer[j]=fullpath[i] ;\n\t}\n\tj++;\n\t\t\n\t// On supprime les espace au début\n\twhile( ((buffer+j)[0]==' ')||((buffer+j)[0]=='\t') ) j++ ;\n\tstrcpy( fullpath, buffer+j ) ;\n\t\n\t// On crée les répertoires\n\tif( !existdirectory(fullpath) ) {\n\t\tpst = fullpath ;\n\t\twhile( (strlen(pst)>0)&&((p=strstr(pst,\"\\\\\"))!=NULL) ) {\n\t\t\tp[0]='\\0' ;\n\t\t\t_mkdir( fullpath ) ;\n\t\t\tp[0]='\\\\' ;\n\t\t\tpst=p+1;\n\t\t}\n\t\t_mkdir( fullpath ) ;\n\t}\n\t\t\n\treturn existdirectory(fullpath) ;\n}\n"
        },
        {
          "name": "kitty_tools.h",
          "type": "blob",
          "size": 1.9208984375,
          "content": "#ifndef KITTY_TOOLS\n#define KITTY_TOOLS\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <windows.h>\n#include <sys/stat.h>\n#include <ctype.h>\n\n#ifndef MAX_VALUE_NAME\n#define MAX_VALUE_NAME 16383\n#endif\n\n// Procedures de traitement de chaines\nint stricmp(const char *s1, const char *s2) ;\n\nchar *stristr (const char *meule_de_foin, const char *aiguille) ;\n\n/* Fonction permettant d'inserer une chaine dans une autre */\nint insert( char * ch, const char * c, const int ipos ) ;\n\n/* Fonction permettant de supprimer une partie d'une chaine de caracteres */\nint del( char * ch, const int start, const int length ) ;\n\n/* Fonction permettant de retrouver la position d'une chaine dans une autre chaine */\nint poss( const char * c, const char * ch ) ;\n\n/* Fonction permettant de retrouver la position d'une chaîne de caracteres dans une chaine a partir d'une position donnee */\nint posi( const char * c, const char * ch, const int ipos ) ;\n\n// Teste l'existance d'un fichier\nint existfile( const char * filename ) ;\n\n// Teste l'existance d'un repertoire\nint existdirectory( const char * filename ) ;\n\n/* Donne la taille d'un fichier */\nlong filesize( const char * filename ) ;\n\n// Supprime les double anti-slash\nvoid DelDoubleBackSlash( char * st ) ;\n\t\n// Ajoute une chaine dans une liste de chaines\nint StringList_Add( char **list, const char *str ) ;\n\n// Test si une chaine existe dans une liste de chaines\nint StringList_Exist( const char **list, const char * name ) ;\n\n// Supprime une chaine d'une liste de chaines\nvoid StringList_Del( char **list, const char * name ) ;\n\n// Reorganise l'ordre d'une liste de chaines en montant la chaine selectionnee d'un cran\nvoid StringList_Up( char **list, const char * name ) ;\n\n// Positionne l'environnement\nint putenv (const char *string) ;\nint set_env( char * name, char * value ) ;\nint add_env( char * name, char * value ) ;\n\n// Creer un repertoire recurssif (rep1 / rep2 / ...)\nint MakeDir( const char * directory ) ;\n\n#endif\n"
        },
        {
          "name": "kitty_win.c",
          "type": "blob",
          "size": 15.6865234375,
          "content": "#include \"kitty_win.h\"\n\n// Modifie la transparence\nvoid SetTransparency( HWND hwnd, int value ) {\n#ifndef MOD_NOTRANSPARENCY\n\tSetLayeredWindowAttributes( hwnd, 0, value, LWA_ALPHA ) ;\n#endif\n\t}\n\n\n// Numéro de version de l'OS\nvoid GetOSInfo( char * version ) { // ==> Deprecated with version >= Windows 8.1\n\tOSVERSIONINFO osvi;\n\tZeroMemory(&osvi, sizeof(OSVERSIONINFO));\n\tosvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n\tGetVersionEx(&osvi);\n\tsprintf( version, \"%ld.%ld %ld %ld %s %dx%d\", osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber, osvi.dwPlatformId, osvi.szCSDVersion, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN) ) ;\n}\n/*\nhttp://msdn.microsoft.com/en-us/library/windows/desktop/ms724832%28v=vs.85%29.aspx\nOperating system \t\t\tVersion number\nWindows 10 Insider Preview\t\t10.0*\nWindows Server Technical Preview\t10.0*\nWindows Server 2019 \t\t\t10.0*\nWindows Server 2016 \t\t\t10.0*\nWindows 8.1\t\t\t\t6.3*\nWindows Server 2012 R2\t\t\t6.3*\nWindows 8\t\t\t\t6.2\nWindows Server 2012\t\t\t6.2\nWindows 7\t\t\t\t6.1\nWindows Server 2008 R2\t\t\t6.1\nWindows Server 2008\t\t\t6.0\nWindows Vista\t\t\t\t6.0\nWindows Server 2003 R2\t\t\t5.2\nWindows Server 2003\t\t\t5.2\nWindows XP 64-Bit Edition\t\t5.2\nWindows XP\t\t\t\t5.1\nWindows 2000\t\t\t\t5.0\n*/\n\n/*\nhttps://msdn.microsoft.com/en-us/library/aa383745%28v=vs.85%29.aspx#faster_builds_with_smaller_header_files\nMinimum system required\t\t\t\t\tMinimum value for _WIN32_WINNT and WINVER\nWindows 8.1\t\t\t\t\t\t_WIN32_WINNT_WINBLUE (0x0602)\nWindows 8\t\t\t\t\t\t_WIN32_WINNT_WIN8 (0x0602)\nWindows 7\t\t\t\t\t\t_WIN32_WINNT_WIN7 (0x0601)\nWindows Server 2008\t\t\t\t\t_WIN32_WINNT_WS08 (0x0600)\nWindows Vista\t\t\t\t\t\t_WIN32_WINNT_VISTA (0x0600)\nWindows Server 2003 with SP1, Windows XP with SP2\t_WIN32_WINNT_WS03 (0x0502)\nWindows Server 2003, Windows XP\t\t\t\t_WIN32_WINNT_WINXP (0x0501)\n\nMinimum version required\t\tMinimum value of _WIN32_IE\nInternet Explorer 10.0\t\t\t_WIN32_IE_IE100 (0x0A00)\nInternet Explorer 9.0\t\t\t_WIN32_IE_IE90 (0x0900)\nInternet Explorer 8.0\t\t\t_WIN32_IE_IE80 (0x0800)\nInternet Explorer 7.0\t\t\t_WIN32_IE_IE70 (0x0700)\nInternet Explorer 6.0 SP2\t\t_WIN32_IE_IE60SP2 (0x0603)\nInternet Explorer 6.0 SP1\t\t_WIN32_IE_IE60SP1 (0x0601)\nInternet Explorer 6.0\t\t\t_WIN32_IE_IE60 (0x0600)\nInternet Explorer 5.5\t\t\t_WIN32_IE_IE55 (0x0550)\nInternet Explorer 5.01\t\t\t_WIN32_IE_IE501 (0x0501)\nInternet Explorer 5.0, 5.0a, 5.0b\t_WIN32_IE_IE50 (0x0500)\n*/\n\ntypedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);\nLPFN_ISWOW64PROCESS fnIsWow64Process;\nBOOL IsWow64() {\n    BOOL bIsWow64 = FALSE;\n    //IsWow64Process is not available on all supported versions of Windows.\n    //Use GetModuleHandle to get a handle to the DLL that contains the function\n    //and GetProcAddress to get a pointer to the function if available.\n    fnIsWow64Process = (LPFN_ISWOW64PROCESS) GetProcAddress(\n        GetModuleHandle(TEXT(\"kernel32\")),\"IsWow64Process\");\n    if(NULL != fnIsWow64Process) {\n        if (!fnIsWow64Process(GetCurrentProcess(),&bIsWow64)) {\n            //handle error\n        }\n    }\n    return bIsWow64 ;\n}\n\nint OpenFileName( HWND hFrame, char * filename, char * Title, char * Filter ) {\n\tchar * szTitle = Title ;\n\tchar szFilter[256] ; strcpy( szFilter, Filter ) ;\n\t// on remplace les caractères '|' par des caractères NULL.\n\tint i = 0;\n\twhile(i < sizeof(szFilter) && szFilter[i] != '\\0')\n\t{\n\t\tif(szFilter[i] == '|')\n\t\t\tszFilter[i] = '\\0';\n\n\t\ti++;\n\t}\n\n\t// boîte de dialogue de demande d'ouverture de fichier\n\t//char szFileName[_MAX_PATH + 1] = \"\";\n\tchar * szFileName = filename ;\n\tszFileName[0] = '\\0' ;\n\tOPENFILENAME ofn\t= {0};\n\tofn.lStructSize\t\t= sizeof(OPENFILENAME);\n\tofn.hwndOwner\t\t= hFrame;\n\tofn.lpstrFilter\t\t= szFilter;\n\tofn.nFilterIndex\t= 1;\n\tofn.lpstrFile\t\t= szFileName;\n\t//ofn.nMaxFile\t\t= sizeof(szFileName);\n\tofn.nMaxFile\t\t= 4096 ;\n\tofn.lpstrTitle\t\t= szTitle;\n\tofn.Flags\t\t= OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST \n\t\t\t\t| OFN_HIDEREADONLY | OFN_LONGNAMES\n\t\t\t\t| OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_EXTENSIONDIFFERENT | OFN_DONTADDTORECENT\n\t\t\t\t;\n\n\t// si aucun nom de fichier n'a été sélectionné, on abandonne\n\tif(!GetOpenFileName(&ofn)) { return 0 ; }\n\telse { return 1 ; }\n\t}\n\nint SaveFileName( HWND hFrame, char * filename, char * Title, char * Filter ) {\n\tchar * szTitle = Title ;\n\tchar szFilter[256] ; strcpy( szFilter, Filter ) ;\n\t// on remplace les caractères '|' par des caractères NULL.\n\tint i = 0;\n\twhile(i < sizeof(szFilter) && szFilter[i] != '\\0')\n\t{\n\t\tif(szFilter[i] == '|')\n\t\t\tszFilter[i] = '\\0';\n\n\t\ti++;\n\t}\n\n\t// boîte de dialogue de demande d'ouverture de fichier\n\t//char szFileName[_MAX_PATH + 1] = \"\";\n\tchar * szFileName = filename ;\n\tszFileName[0] = '\\0' ;\n\tOPENFILENAME ofn\t= {0};\n\tofn.lStructSize\t\t= sizeof(OPENFILENAME);\n\tofn.hwndOwner\t\t= hFrame;\n\tofn.lpstrFilter\t\t= szFilter;\n\tofn.nFilterIndex\t= 1;\n\tofn.lpstrFile\t\t= szFileName;\n\t//ofn.nMaxFile\t\t= sizeof(szFileName);\n\tofn.nMaxFile\t\t= 4096 ;\n\tofn.lpstrTitle\t\t= szTitle;\n\tofn.lpstrDefExt \t= \".ktx\" ;\n\tofn.Flags\t\t= OFN_PATHMUSTEXIST \n\t\t\t\t| OFN_HIDEREADONLY | OFN_LONGNAMES | OFN_OVERWRITEPROMPT\n\t\t\t\t| OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_EXTENSIONDIFFERENT | OFN_DONTADDTORECENT\n\t\t\t\t;\n\n\t// si aucun nom de fichier n'a été sélectionné, on abandonne\n\tif(!GetSaveFileName(&ofn)) { return 0 ; }\n\telse { return 1 ; }\n\t}\n\n#include <shlobj.h>\nint OpenDirName( HWND hFrame, char * dirname ) {\n\tBROWSEINFO bi ;\n\tITEMIDLIST *il ;\n\tLPITEMIDLIST ol = NULL ;\n\tchar Buffer[4096],Result[4096]=\"\" ;\n\tdirname[0]='\\0' ;\n\n\tstrcpy( Buffer, getenv(\"ProgramFiles\") ) ;\n\t\n\t//SHGetSpecialFolderLocation( hFrame, CSIDL_MYDOCUMENTS, &ol );\n\t\n\tmemset(&bi,0,sizeof(BROWSEINFO));\n\tbi.hwndOwner = hFrame ;\n\t//bi.pidlRoot=NULL ; //\n\tbi.pidlRoot=ol ;\n\tbi.pszDisplayName=&Buffer[0];\n\tbi.lpszTitle=\"Select a folder...\";\n\tbi.ulFlags=0;\n\tbi.lpfn=NULL;\n\tif ((il=SHBrowseForFolder(&bi))!=NULL) {\n\t\tSHGetPathFromIDList(il,&Result[0]) ;\n\t\t//ILFree( il ) ; ILFree( ol ) ;\n\t\tGlobalFree(il);GlobalFree(ol);\n\t\tif( strlen( Result ) == 0 ) return 0 ;\n\t\tstrcpy( dirname, Result ) ;\n\t\treturn 1 ;\n\t\t}\n\t//ILFree( ol ) ;\n\tGlobalFree(ol);\n\treturn 0 ;\n\t}\n\n// Centre un dialog au milieu de la fenetre parent\nvoid CenterDlgInParent(HWND hDlg) {\n  RECT rcDlg;\n  HWND hParent;\n  RECT rcParent;\n  MONITORINFO mi;\n  HMONITOR hMonitor;\n\n  int xMin, yMin, xMax, yMax, x, y;\n\n  GetWindowRect(hDlg,&rcDlg);\n\n  hParent = GetParent(hDlg);\n  GetWindowRect(hParent,&rcParent);\n\n  hMonitor = MonitorFromRect(&rcParent,MONITOR_DEFAULTTONEAREST);\n  mi.cbSize = sizeof(mi);\n  GetMonitorInfo(hMonitor,&mi);\n\n  xMin = mi.rcWork.left;\n  yMin = mi.rcWork.top;\n\n  xMax = (mi.rcWork.right) - (rcDlg.right - rcDlg.left);\n  yMax = (mi.rcWork.bottom) - (rcDlg.bottom - rcDlg.top);\n\n  if ((rcParent.right - rcParent.left) - (rcDlg.right - rcDlg.left) > 20)\n    x = rcParent.left + (((rcParent.right - rcParent.left) - (rcDlg.right - rcDlg.left)) / 2);\n  else\n    x = rcParent.left + 70;\n\n  if ((rcParent.bottom - rcParent.top) - (rcDlg.bottom - rcDlg.top) > 20)\n    y = rcParent.top  + (((rcParent.bottom - rcParent.top) - (rcDlg.bottom - rcDlg.top)) / 2);\n  else\n    y = rcParent.top + 60;\n\n  SetWindowPos(hDlg,NULL,max(xMin,min(xMax,x)),max(yMin,min(yMax,y)),0,0,SWP_NOZORDER|SWP_NOSIZE);\n}\n\n\n//\n// Envoi vers l'imprimante\n//\n// Parametres de l'impression\nint PrintCharSize = 100 ;\nint PrintMaxLinePerPage = 60 ;\nint PrintMaxCharPerLine = 85 ;\n\nint PrintText( const char * Text ) {\n\tint return_code = 0 ; \n\tPRINTDLG\tpd;\n\tDOCINFO\t\tdi;\n\tint i, TextLen = 0, Index1 = 0, Index2 = 2;\n\t//int Exit = 0 ;\n\tchar*\t\tLinePrint = NULL ;\n\tchar*\t\tszMessage = NULL ;\n\n\tif( Text == NULL ) return 1 ;\n\tif( strlen( Text ) == 0 ) return 1 ;\n\n\tmemset (&pd, 0, sizeof(PRINTDLG));\n\tmemset (&di, 0, sizeof(DOCINFO));\n\n\tdi.cbSize = sizeof(DOCINFO);\n\tdi.lpszDocName = \"Test\";\n\n\tpd.lStructSize = sizeof(PRINTDLG);\n\tpd.Flags = PD_PAGENUMS | PD_RETURNDC;\n\tpd.nFromPage = 1;\n\tpd.nToPage = 1;\n\tpd.nMinPage = 1;\n\tpd.nMaxPage = 1;\n\tszMessage = 0;\n\n\tif( PrintDlg( &pd ) ) {\n\t\tif( pd.hDC ) {\n\t\t\tif (StartDoc (pd.hDC, &di) != SP_ERROR)\t{\n\t\t\t\tTextLen = strlen( Text ) ;\n\t\t\t\tif( TextLen > 0 ) {\n\t\t\t\t\tLinePrint = (char*) malloc( TextLen + 2 ) ;\n\t\t\t\t\tIndex1 = 0 ; Index2 = 2 ; \n\t\t\t\t\t//Exit = 0 ;\n\t\t\t\t\tfor( i = 0 ; i < TextLen ; i++ ) {\n\t\t\t\t\t\tif( Text[i]=='\\r' ) i++;\n                    \t\t\t\tLinePrint[Index1] = Text[i] ;\n                    \t\t\t\tif( Text[i] == '\\n' ) {\n                      \t\t\t\t\tIndex2++ ;\n\t\t\t\t\t\t\tLinePrint[Index1] = '\\0' ;\n                      \t\t\t\t\tTextOut(pd.hDC,100, Index2*PrintCharSize, LinePrint, strlen(LinePrint) ) ;\n\t\t\t\t\t\t\tIndex1 = 0 ;\n                    \t\t\t\t\t}\n\t\t\t\t\t\telse if( Index1>=PrintMaxCharPerLine ) {\n\t\t\t\t\t\t\tIndex2++ ;\n\t\t\t\t\t\t\tLinePrint[Index1+1] = '\\0' ;\n                      \t\t\t\t\tTextOut(pd.hDC,100, Index2*PrintCharSize, LinePrint, strlen(LinePrint) ) ;\n\t\t\t\t\t\t\tIndex1 = 0 ;\n\t\t\t\t\t\t\t}\n                    \t\t\t\telse { Index1++ ; }\n                    \t\t\t\tif( Index2 >= PrintMaxLinePerPage ) {\n                  \t   \t\t\t\tEndPage( pd.hDC ) ;\n                       \t\t\t\t\t//EndDoc(pd.hDC) ;\n                       \t\t\t\t\t//StartDoc(pd.hDC, &di) ;\n\t\t\t\t\t\t\tStartPage( pd.hDC ) ;\n                       \t\t\t\t\tIndex2 = 2 ;\n                       \t\t\t\t\t}\n                  \t\t\t\t}\n                  \t\t\tIndex2++ ; \n                  \t\t\tLinePrint[Index1] = '\\0'; // Impression de la dernière page\n                  \t\t\tTextOut(pd.hDC,100, Index2*PrintCharSize, LinePrint, strlen(LinePrint)) ;\n               \t  \t\t\tEndPage(pd.hDC) ;\n                  \t\t\tEndDoc(pd.hDC) ;\n                  \t\t\tszMessage = \"Print successful\";\n\t\t\t\t\tfree( LinePrint ) ;\n              \t\t\t\t}\n              \t\t\telse { return_code = 1 ;  /* Chaine vide */ }\n\t\t\t\t}\n\t\t\telse { // Problème StartDoc\n\t\t\t\tszMessage = \"ERROR Type 1\" ;\n\t\t\t\treturn_code = 2 ;\n\t\t\t\t}\n\t\t\t}\n\t\telse { // Probleme pd.hDC\n\t\t\tszMessage = \"ERROR Type 2.\" ;\n\t\t\treturn_code = 3 ;\n\t\t\t}\n\t\t}\n\telse { // Problème PrintDlg\n\t\t//szMessage = \"Impression annulée par l'utilisateur\" ;\n\t\treturn_code = 4 ;\n\t\t}\n\tif (szMessage) { MessageBox (NULL, szMessage, \"Print report\", MB_OK) ; }\n\t\n\treturn return_code ;\n\t}\n\n// Impression du texte dans le bloc-notes\nvoid ManagePrint( HWND hwnd ) {\n\tchar *pst = NULL ;\n\tif( OpenClipboard(NULL) ) {\n\t\tHGLOBAL hglb ;\n\t\tif( (hglb = GetClipboardData( CF_TEXT ) ) != NULL ) {\n\t\t\tif( ( pst = GlobalLock( hglb ) ) != NULL ) {\n\t\t\t\tPrintText( pst ) ;\n\t\t\t\tGlobalUnlock( hglb ) ;\n\t\t\t}\n\t\t}\n\t\tCloseClipboard();\n\t}\n}\n\n// Met un texte dans le press-papier\nint SetTextToClipboard( const char * buf ) {\n\tHGLOBAL hglbCopy ;\n\tLPTSTR lptstrCopy ;\n\tif( !IsClipboardFormatAvailable(CF_TEXT) ) return 0 ;\n\tif( !OpenClipboard(NULL) ) return 0 ;\n\tEmptyClipboard() ; \n\tif( (hglbCopy= GlobalAlloc(GMEM_MOVEABLE, (strlen(buf)+1) * sizeof(TCHAR)) ) == NULL ) {\n\t\tCloseClipboard() ; \n\t\treturn 0 ;\t\n\t}\n\tlptstrCopy = GlobalLock( hglbCopy ) ; \n\tmemcpy( lptstrCopy, buf, (strlen(buf)+1) * sizeof(TCHAR) ) ;\n\tGlobalUnlock( hglbCopy ) ; \n\tif( SetClipboardData(CF_TEXT, hglbCopy) == NULL ) {\n\t\tCloseClipboard() ;\n\t\treturn 0 ; \n\t}\n\tCloseClipboard() ;\n\treturn 1 ;\n}\n\n// Execute une commande\t\nvoid RunCommand( HWND hwnd, const char * cmd ) {\n\tPROCESS_INFORMATION ProcessInformation ;\n\tZeroMemory( &ProcessInformation, sizeof(ProcessInformation) );\n\t\n\tSTARTUPINFO StartUpInfo ;\n\tZeroMemory( &StartUpInfo, sizeof(StartUpInfo) );\n\tStartUpInfo.cb=sizeof(STARTUPINFO);\n\tStartUpInfo.lpReserved=0;\n\tStartUpInfo.lpDesktop=0;\n\tStartUpInfo.lpTitle=0;\n\tStartUpInfo.dwX=0;\n\tStartUpInfo.dwY=0;\n\tStartUpInfo.dwXSize=0;\n\tStartUpInfo.dwYSize=0;\n\tStartUpInfo.dwXCountChars=0;\n\tStartUpInfo.dwYCountChars=0;\n\tStartUpInfo.dwFillAttribute=0;\n\tStartUpInfo.dwFlags=0;\n\tStartUpInfo.wShowWindow=0;\n\tStartUpInfo.cbReserved2=0;\n\tStartUpInfo.lpReserved2=0;\n\tStartUpInfo.hStdInput=0;\n\tStartUpInfo.hStdOutput=0;\n\tStartUpInfo.hStdError=0;\n//MessageBox(hwnd,cmd,\"Info\",MB_OK);\n\n\tif( !CreateProcess(NULL,(CHAR*)cmd,NULL,NULL,FALSE,NORMAL_PRIORITY_CLASS,NULL,NULL,&StartUpInfo,&ProcessInformation) ) {\n\t\tShellExecute(hwnd, \"open\", cmd ,0 , 0, SW_SHOWDEFAULT);\n\t} else { \n\t\tWaitForInputIdle(ProcessInformation.hProcess, INFINITE ); \n\t\tCloseHandle( &StartUpInfo );\n\t\tCloseHandle( &ProcessInformation );\n\t}\n}\n\nvoid RunPuttyEd( HWND hwnd, char * filename ) {\n\tchar buffer[1024]=\"\", shortname[1024]=\"\" ;\n\tif( GetModuleFileName( NULL, (LPTSTR)buffer, 1023 ) ) if( GetShortPathName( buffer, shortname, 1023 ) ) {\n\t\tstrcat( shortname, \" -ed\" );\n\t\tif( filename!=NULL ) if( strlen(filename)>0 ) { \n\t\t\tstrcat( shortname, \"b \" ) ; \n\t\t\tstrcat( shortname, filename ) ; \n\t\t}\n\t\tdebug_logevent( shortname ) ;\n\t\tRunCommand( hwnd, shortname ) ; \n\t}\n}\n\n// Verifie si une mise a jour est disponible sur le site web\nextern char BuildVersionTime[256] ;\nvoid CheckVersionFromWebSite( HWND hwnd ) {\n\tchar buffer[1024]=\"\", vers[1024]=\"\" ;\n\tint i ;\n\tstrcpy( vers, BuildVersionTime ) ;\n\tfor( i = 0 ; i < strlen( vers ) ; i ++ ) {\n\t\tif( !(((vers[i]>='0')&&(vers[i]<='9'))||(vers[i]=='.')) ) { vers[i] = '\\0' ; break ; }\n\t\t}\n\tsprintf( buffer, \"http://www.9bis.net/kitty/check_update.php?version=%s\", vers ) ;\n\tShellExecute(hwnd, \"open\", buffer, 0, 0, SW_SHOWDEFAULT);\n}\n\n// Affichage d'un message dans l'event log\nvoid debug_logevent( const char *fmt, ... ) {\n\tva_list ap;\n\tchar *buf;\n\tva_start(ap, fmt);\n\tbuf = dupvprintf(fmt, ap) ;\n\tva_end(ap);\n\tdo_eventlog(buf) ;\n\tfree(buf);\n}\n\n// Test si un chemin est absolu\nbool IsPathAbsolute( const char * path ) {\n\tbool test = false ;\n\tif( path == NULL ) { return false ; }\n\tif( strlen( path ) < 3 ) { return false ; }\n\tif( ((path[0]>='a') && (path[0]<='z')) || ((path[0]>='A') && (path[0]<='Z')) ) \n\t\tif( path[1]==':' )\n\t\t\tif( (path[2]=='/') || (path[2]=='\\\\') ) test = true ;\n\treturn test ;\n}\n\nvoid PopUpSystemMenu( HWND hwnd, int npos ) {\n\tRECT rc ;\n\tGetWindowRect( hwnd, &rc ) ;\n\tHMENU m = GetSystemMenu( hwnd, FALSE) ;\n\tTrackPopupMenu( m, 0, rc.left, rc.top, 0, hwnd, NULL) ;\n\n\tif( npos>0 ) {\n\tint nb = GetMenuItemCount(m), i;\n\tMENUITEMINFO mi ;\n\tmi.cbSize = sizeof(MENUITEMINFO) ;\n\tfor( i=0; i<nb; i++ ) {\n\t\tmi.dwTypeData  = NULL ;\n\t\tGetMenuItemInfoA( m, i, TRUE, &mi);\n\t\tchar *txt = (char*)malloc(mi.cch+1);\n\t\tmi.dwTypeData  = txt ;\n\t\tmi.cch=\tmi.cch+1;\n\t\tGetMenuItemInfoA( m, i, FALSE, &mi);\n\t\tMessageBox(NULL,txt,\"info\",MB_OK);\n\t\tfree(txt);\n\t}\n\t}\n\t\n}\n\n// Description:\n//   Creates a tooltip for an item in a dialog box. \n// Parameters:\n//   idTool - identifier of an dialog box item.\n//   nDlg - window handle of the dialog box.\n//   pszText - string to use as the tooltip text.\n// Returns:\n//   The handle to the tooltip.\n//\nHWND CreateToolTip(int toolID, HWND hDlg, PTSTR pszText)\n{\n    if (!toolID || !hDlg || !pszText)\n    {\n        return FALSE;\n    }\n    // Get the window of the tool.\n    HWND hwndTool = GetDlgItem(hDlg, toolID);\n    \n    // Create the tooltip. g_hInst is the global instance handle.\n    HWND hwndTip = CreateWindowEx((DWORD)NULL, TOOLTIPS_CLASS, NULL,\n                              WS_POPUP |TTS_ALWAYSTIP | TTS_BALLOON,\n                              CW_USEDEFAULT, CW_USEDEFAULT,\n                              CW_USEDEFAULT, CW_USEDEFAULT,\n                              hDlg, NULL, \n                              hinst /*g_hInst*/, NULL);\n    \n   if (!hwndTool || !hwndTip)\n   {\n       return (HWND)NULL;\n   }                              \n                              \n    // Associate the tooltip with the tool.\n    TOOLINFO toolInfo = { 0 };\n    toolInfo.cbSize = sizeof(toolInfo);\n    toolInfo.hwnd = hDlg;\n    toolInfo.uFlags = TTF_IDISHWND | TTF_SUBCLASS;\n    toolInfo.uId = (UINT_PTR)hwndTool;\n    toolInfo.lpszText = pszText;\n    SendMessage(hwndTip, TTM_ADDTOOL, 0, (LPARAM)&toolInfo);\n\n    return hwndTip;\n}\n/*\nHWND CreateToolTip2(int toolID, HWND hDlg, PTSTR pszText) {\n    HWND hwndToolTips = CreateWindow(TOOLTIPS_CLASS, NULL, \n                            WS_POPUP | TTS_NOPREFIX | TTS_BALLOON, \n                            0, 0, 0, 0, NULL, NULL, GetModuleHandle(NULL), NULL);\n    if (hwndToolTips)\n{\n    TOOLINFO ti;\n\n    ti.cbSize   = sizeof(ti);\n    ti.uFlags   = TTF_TRANSPARENT | TTF_CENTERTIP;\n    ti.hwnd     = hDlg;\n    ti.uId      = toolID;\n    ti.hinst    = NULL;\n    ti.lpszText = pszText;\n\n    GetClientRect(hwnd, &ti.rect);\n\n    SendMessage(hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) &ti );\n\n}\nreturn hwndToolTips ;\n}\n*/\n"
        },
        {
          "name": "kitty_win.h",
          "type": "blob",
          "size": 1.357421875,
          "content": "#ifndef KITTY_WIN\n#define KITTY_WIN\n\n#include <stdlib.h>\n#include <stdio.h>\n#include \"putty.h\"\n#include <windows.h>\n\nvoid SetTransparency( HWND hwnd, int value ) ;\nvoid GetOSInfo( char * version ) ;\nBOOL IsWow64() ; // Test si on est en Windows 64 bits\nint OpenFileName( HWND hFrame, char * filename, char * Title, char * Filter ) ;\nint OpenDirName( HWND hFrame, char * dirname ) ;\nint SaveFileName( HWND hFrame, char * filename, char * Title, char * Filter ) ;\n\t\n// Centre un dialog au milieu de la fenetre parent\nvoid CenterDlgInParent(HWND hDlg) ;\n\n// Envoi vers l'imprimante\nint PrintText( const char * Text ) ;\n\n// Impression du texte dans le bloc-notes\nvoid ManagePrint( HWND hwnd ) ;\n\n// Met un texte dans le press-papier\nint SetTextToClipboard( const char * buf ) ;\n\n// Execute une commande\t\nvoid RunCommand( HWND hwnd, const char * cmd ) ;\n\n// Démarre l'éditeur embarqué\nvoid RunPuttyEd( HWND hwnd, char * filename ) ;\n\n// Verifie si une mise a jour est disponible sur le site web\nvoid CheckVersionFromWebSite( HWND hwnd ) ;\n\n// Affichage d'un message dans l'event log\nvoid debug_logevent( const char *fmt, ... ) ;\n\n// Test si un chemin est absolu\nbool IsPathAbsolute( const char * path ) ;\n\n// Affiche le menu system de l'application\nvoid PopUpSystemMenu( HWND hwnd, int npos  ) ;\n\n// Affiche une bulle tooltip\nHWND CreateToolTip(int toolID, HWND hDlg, PTSTR pszText) ;\n#endif\n"
        },
        {
          "name": "masterpassword.txt",
          "type": "blob",
          "size": 0.0126953125,
          "content": "\"ToBeDefined\""
        },
        {
          "name": "md5",
          "type": "tree",
          "content": null
        },
        {
          "name": "mini",
          "type": "tree",
          "content": null
        },
        {
          "name": "regex",
          "type": "tree",
          "content": null
        },
        {
          "name": "res",
          "type": "tree",
          "content": null
        },
        {
          "name": "rutty",
          "type": "tree",
          "content": null
        },
        {
          "name": "url",
          "type": "tree",
          "content": null
        },
        {
          "name": "void.c",
          "type": "blob",
          "size": 0.1640625,
          "content": "/* \n * Devrait etre vide en temps normal\n * Sert juste a reussir la compilation en phase de debug\n */\n\n#include <stdlib.h>\n#include \"putty.h\"\n#ifdef MOD_PERSO\n\n#endif \n"
        },
        {
          "name": "zmodem",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}