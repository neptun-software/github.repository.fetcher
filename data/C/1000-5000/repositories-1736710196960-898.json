{
  "metadata": {
    "timestamp": 1736710196960,
    "page": 898,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tideways/php-xhprof-extension",
      "stars": 1636,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".appveyor.yml",
          "type": "blob",
          "size": 2.7548828125,
          "content": "image: Visual Studio 2015\nversion: '{branch}.{build}'\n\ncache:\n  - c:\\build-cache -> .appveyor.yml, .appveyor/*.cmd\n\nenvironment:\n  PHP_BUILD_CACHE_BASE_DIR: c:\\build-cache\n  PHP_BUILD_OBJ_DIR: c:\\obj\n  PHP_BUILD_CACHE_SDK_DIR: c:\\build-cache\\sdk\n  PHP_BUILD_SDK_BRANCH: php-sdk-2.2.0\n  SDK_REMOTE: https://github.com/OSTC/php-sdk-binary-tools.git\n  SDK_BRANCH: php-sdk-2.2.0\n\n  matrix:\n    - PHP_REL: 8.0\n      ARCHITECTURE: x64\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      PHP_BUILD_CRT: vs16\n    - PHP_REL: 8.0\n      ARCHITECTURE: x64\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      PHP_BUILD_CRT: vs16\n    - PHP_REL: 8.0\n      ARCHITECTURE: x86\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      PHP_BUILD_CRT: vs16\n    - PHP_REL: 8.0\n      ARCHITECTURE: x86\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2019\n      PHP_BUILD_CRT: vs16\n    - PHP_REL: 7.4\n      ARCHITECTURE: x64\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.3\n      ARCHITECTURE: x64\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.2\n      ARCHITECTURE: x64\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.4\n      ARCHITECTURE: x64\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.3\n      ARCHITECTURE: x64\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.2\n      ARCHITECTURE: x64\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.4\n      ARCHITECTURE: x86\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.3\n      ARCHITECTURE: x86\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.2\n      ARCHITECTURE: x86\n      ZTS_STATE: enable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.4\n      ARCHITECTURE: x86\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.3\n      ARCHITECTURE: x86\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n    - PHP_REL: 7.2\n      ARCHITECTURE: x86\n      ZTS_STATE: disable\n      APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017\n      PHP_BUILD_CRT: vc15\n\ninstall:\n  - .appveyor\\install.cmd\n\nbuild_script:\n  - .appveyor\\build.cmd\n"
        },
        {
          "name": ".appveyor",
          "type": "tree",
          "content": null
        },
        {
          "name": ".buildkite",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.7109375,
          "content": "/.deps\n/Makefile\n/*.lo\n/*.loT\n/*.slo\n/*.mk\n/*.la\n/.libs\n/libs.mk\n/ac*.m4\n/build\n/config.h\n/config.h.in\n/config.nice\n/config.sub\n/configure\n/configure.in\n/configure.ac\n/config.status\n/config.cache\n/conftest\n/conftest.c\n/core\n/dynlib.m4\n/install-sh\n/ltmain.sh\n/include\n/Makefile.fragments\n/Makefile.global\n/Makefile.objects\n/missing\n/memory:\n/mkinstalldirs\n/modules\n/scan_makefile_in.awk\n/config.guess\n/*swo\n/*swp\n/*swn\ntags\n/tmp-php.ini\n/config.log\n/libtool\n/*.plg\n/*.patch\n/*.tgz\n/*.ncb\n/*.opt\n/*.dsw\n/autom4te.cache\n.svn\n/*~\ntests/*.diff\ntests/*.out\ntests/*.php\ntests/*.sh\ntests/*.log\ntests/*.exp\nrun-tests.php\nvendor/\n*.phar\nphp5/*.lo\nphp7/*.lo\nphp5/.libs\nphp7/.libs\n/.gdb_history\nsrc/Tideways/*.lo\nsrc/Tideways/.libs\n.vscode\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.2607421875,
          "content": "# 5.0.2\n\n- [#90](https://github.com/tideways/php-xhprof-extension/issues/90): Add packaging for PHP 7.4\n\n# 5.0.1\n\n- [#86](https://github.com/tideways/php-xhprof-extension/pull/86): Fix bug in Apple/MacOS timer code that prevented wall time measurements from working.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 9.935546875,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.841796875,
          "content": "Tideways PHP XHProf Profiler\nCopyright (c) 2014 - 2019 Tideways GmbH\n\nThis product includes work from the following third-party libraries:\n\n    - xhprof (https://github.com/phacility/xhprof)\n\n      Copyright (c) 2009 Facebook\n\n        Creators:\n          Changhao Jiang\n          Kannan Muthukkaruppan\n          Venkat Venkataramani\n          Haiping Zhao\n\n        Additional Contributors:\n          George Cabrera      - UI enhancements\n          Paul Saab           - FreeBSD port\n          Syseleven           - Function Arguments\n\n    - The PHP Group (https://github.com/php/php-src, http://php.net)\n\n      Copyright (c) 1997-2017 The PHP Group\n\n\n    - Xdebug (https://github.com/xdebug/xdebug)\n\n      Copyright (c) 2003-2018 Derick Rethans.\n\n      Appveyor Windows Testsuite Configuration\n\n    - Benjamin Carl (c) 2010-2012\n      Windows Support for XHProf\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.6103515625,
          "content": "> [!IMPORTANT]\n> This XHProf PHP extension fork has outlived its purpose and is archived in favor of the revitalized [PECL XHProf extension](https://pecl.php.net/package/xhprof) ([GitHub](https://github.com/longxinH/xhprof)) that is also using the modern PHP profiling abilities and performant timer APIs.\n>\n> If you are looking for a full-stack Profiling Experience from Trigger through the Browser to modern UI [try out Tideways](https://tideways.com).\n\n# Tideways XHProf Extension\n\nHome of the `tideways_xhprof` extension - a hierarchical Profiler for PHP.\n\n**This extensions is not compatible with our Tideways service. Are you looking\nfor `tideways` Extension to use with tideways.com?** [Download here](https://tideways.io/profiler/downloads).\n\nThis PHP extension is a complete, modernized open-source rewrite of the\noriginal XHProf extension, with a new core datastructure and specifically\noptimized for PHP 7. The result is an XHProf data-format compatible extension\nwith a much reduced overhead in the critical path that you are profiling.\n\nWe are committed to provide support for this extension and port it to as many\nplatforms as possible.\n\n**Note:** The public API is not compatible to previous xhprof extensions and\nforks, but function names are different. Only the data format is compatible.\n\n## About tideways and tideways_xhprof Extensions\n\nThis repository now contains an extension by the name of `tideways_xhprof`,\nwhich only contains the XHProf related (Callgraph) Profiler functionality.\n\nPreviously the `tideways` extension contained this functionality together with\nother functionality used in our Software as a Service.\n\nIf you want to use the SaaS, the current approach is to fetch the code using\nprecompiled binaries and packages from our [Downloads\npage](https://tideways.io/profiler/downloads).\n\n## Requirements\n\n- PHP >= 7.0\n- OS: Linux, MacOS, Windows ([Download DLLs](https://ci.appveyor.com/project/tideways/php-profiler-extension))\n- Architectures: x64/amd64, x86, ARM, PowerPC\n- Non-Threaded (NTS) or Threaded (ZTS) support\n\n## Installation\n\nYou can install the extension from source:\n\n    phpize\n    ./configure\n    make\n    sudo make install\n\nConfigure the extension to load with this PHP INI directive:\n\n    extension=tideways_xhprof.so\n\nRestart Apache or PHP-FPM.\n\n### Download Pre-Compiled Binaries\n\nWe pre-compile binaries for Linux AMD64 and for Windows. See the [releases page for the downloads](https://github.com/tideways/php-xhprof-extension/releases) for each tagged version.\n\nThe Debian and RPM packages install the PHP extension to `/usr/lib/tideways_xhprof` and doesn't automatically put it into your PHP installation extension directory.\nYou should link the package by full path for a simple installation:\n\n    extension=/usr/lib/tideways_xhprof/tideways_xhprof-7.3.so\n\n## Usage\n\nThe API is not compatible to previous xhprof extensions and forks,\nonly the data format is compatible:\n\n```php\n<?php\n\ntideways_xhprof_enable();\n\nmy_application();\n\nfile_put_contents(\n    sys_get_temp_dir() . DIRECTORY_SEPARATOR . uniqid() . '.myapplication.xhprof',\n    serialize(tideways_xhprof_disable())\n);\n\n```\n\nBy default only wall clock time is measured, you can enable\nthere additional metrics passing the `$flags` bitmask to `tideways_xhprof_enable`:\n\n```php\n<?php\n\ntideways_xhprof_enable(TIDEWAYS_XHPROF_FLAGS_MEMORY | TIDEWAYS_XHPROF_FLAGS_CPU);\n\nmy_application();\n\nfile_put_contents(\n    sys_get_temp_dir() . DIRECTORY_SEPARATOR . uniqid() . '.myapplication.xhprof',\n    serialize(tideways_xhprof_disable())\n);\n```\n\n## Data-Format\n\nThe XHProf data format records performance data for each parent => child\nfunction call that was made between the calls to `tideways_xhprof_enable` and\n`tideways_xhprof_disable`. It is formatted as an array with the parent and child\nfunction names as a key concatenated with ==> and an array value with 2 to 5 entries:\n\n- `wt` The summary wall time of all calls of this parent ==> child function pair.\n- `ct` The number of calls between this parent ==> child function pair.\n- `cpu` The cpu cycle time of all calls of thi sparent ==> child function pair.\n- `mu` The sum of increase in `memory_get_usage` for this parent ==> child function pair.\n- `pmu` The sum of increase in `memory_get_peak_usage` for this parent ==> child function pair.\n\nWhen `TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC` flag is set, the following additional values are set:\n- `mem.na` The sum of the number of all allocations in this function.\n- `mem.nf` The sum of the number of all frees in this function.\n- `mem.aa` The amount of allocated memory.\n\nIf `TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC_AS_MU` is set, `TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC` is activated\nand, if `TIDEWAYS_XHPROF_FLAGS_MEMORY_MU` is not set, `mem.aa` is additionally returned in `mu`.\n\nThere is a \"magic\" function call called \"main()\" that represents the entry into\nthe profiling.  The wall time on this performance data describes the full\ntimeframe that the profiling ran.\n\nExample:\n\n```php\n<?php\n\narray(\n    \"main()\" => array(\n        \"wt\" => 1000,\n        \"ct\" => 1,\n        \"cpu\" => 400,\n    ),\n    \"main()==>foo\" => array(\n        \"wt\" => 500,\n        \"ct\" => 2,\n        \"cpu\" => 200,\n    ),\n    \"foo==>bar\" => array(\n        \"wt\" => 200,\n        \"ct\" => 10,\n        \"cpu\" => 100,\n    ),\n)\n```\n\n## Clock Sources\n\nAny Profiler needs timer functions to calculate the duration of a function call\nand the `tideways_xhprof` extension is no different. On Linux you can collect\ntiming information through various means. The classic, most simple one is the\nfunction `gettimeofday`, which PHP uses when you call `microtime()`. This function\nis slower compared to other mechanisms that the kernel provides:\n\n- `clock_gettime(CLOCK_MONOTONIC)` returns a monotonically increasing number\n  (not a timestamp) at very high precision and much faster than\n  `gettimeofday()`. It is the preferred and recommended API to get high precision timestamps.\n  On Xen based virtualizations (such as AWS) this call is much slower than on bare-metal\n  or other virtualizations ([Blog post](https://blog.packagecloud.io/eng/2017/03/08/system-calls-are-much-slower-on-ec2/))\n- TSC (Time Stamp Counter) API is accessible in C using inline assembler. It\n  was the timing API that the original XHProf extension used and it is\n  generally very fast, however depending on the make and generation of the CPU\n  might not be synchronized between cores. On modern CPUs it is usually good to\n  use without having to force the current process to a specific CPU.\n\nTideways on Linux defaults to using `clock_gettime(CLOCK_MONOTONIC)`, but if\nyou are running on Xen based virtualization or Docker on Mac, you could try to\nreduce the overhead by setting `tideways_xhprof.clock_use_rdtsc=1\" in your\nPHP.ini.\n"
        },
        {
          "name": "config.m4",
          "type": "blob",
          "size": 6.693359375,
          "content": "PHP_ARG_ENABLE(tideways_xhprof, whether to enable tideways_xhprof support, [  --enable-tideways-xhprof           Enable tideways-xhprof support])\n\nAC_DEFUN([AC_TIDEWAYS_CLOCK],\n[\n  have_clock_gettime=no\n\n  AC_MSG_CHECKING([for clock_gettime])\n\n  AC_TRY_LINK([ #include <time.h> ], [struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);], [\n    have_clock_gettime=yes\n    AC_MSG_RESULT([yes])\n  ], [\n    AC_MSG_RESULT([no])\n  ])\n\n  if test \"$have_clock_gettime\" = \"no\"; then\n    AC_MSG_CHECKING([for clock_gettime in -lrt])\n\n    SAVED_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS -lrt\"\n\n    AC_TRY_LINK([ #include <time.h> ], [struct timespec ts; clock_gettime(CLOCK_MONOTONIC, &ts);], [\n      have_clock_gettime=yes\n      TIDEWAYS_SHARED_LIBADD=\"$TIDEWAYS_SHARED_LIBADD -lrt\"\n      AC_MSG_RESULT([yes])\n    ], [\n      LIBS=\"$SAVED_LIBS\"\n      AC_MSG_RESULT([no])\n    ])\n  fi\n\n  if test \"$have_clock_gettime\" = \"no\"; then\n    AC_MSG_CHECKING([for clock_get_time])\n\n    AC_TRY_RUN([ #include <mach/mach.h>\n      #include <mach/clock.h>\n      #include <mach/mach_error.h>\n\n      int main()\n      {\n        kern_return_t ret; clock_serv_t aClock; mach_timespec_t aTime;\n        ret = host_get_clock_service(mach_host_self(), REALTIME_CLOCK, &aClock);\n\n        if (ret != KERN_SUCCESS) {\n          return 1;\n        }\n\n        ret = clock_get_time(aClock, &aTime);\n        if (ret != KERN_SUCCESS) {\n          return 2;\n        }\n\n        return 0;\n      }\n    ], [\n      have_clock_gettime=yes\n      AC_DEFINE([HAVE_CLOCK_GET_TIME], 1, [do we have clock_get_time?])\n      AC_MSG_RESULT([yes])\n    ], [\n      AC_MSG_RESULT([no])\n    ])\n  fi\n\n  if test \"$have_clock_gettime\" = \"yes\"; then\n      AC_DEFINE([HAVE_CLOCK_GETTIME], 1, [do we have clock_gettime?])\n  fi\n\n  if test \"$have_clock_gettime\" = \"no\"; then\n      AC_MSG_ERROR([clock_gettime is missing, but required])\n  fi\n])\n\nif test \"$PHP_TIDEWAYS_XHPROF\" != \"no\"; then\n\n    PHP_ARG_ENABLE(developer-flags, whether to enable developer build flags,\n        [  --enable-developer-flags   Enable developer flags],, no)\n\n    if test \"$PHP_DEVELOPER_FLAGS\" = \"yes\"; then\n        dnl Warn about functions which might be candidates for format attributes\n        PHP_CHECK_GCC_ARG(-Wmissing-format-attribute,       _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wmissing-format-attribute\")\n        dnl Avoid duplicating values for an enum\n        PHP_CHECK_GCC_ARG(-Wduplicate-enum,                 _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wduplicate-enum\")\n        dnl Warns on mismatches between #ifndef and #define header guards\n        PHP_CHECK_GCC_ARG(-Wheader-guard,                   _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wheader-guard\")\n        dnl logical not of a non-boolean expression\n        PHP_CHECK_GCC_ARG(-Wlogical-not-parentheses,        _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wlogical-not-parentheses\")\n        dnl Warn about suspicious uses of logical operators in expressions\n        PHP_CHECK_GCC_ARG(-Wlogical-op,                     _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wlogical-op\")\n        dnl memory error detector.\n        dnl FIXME: -fsanitize=address,undefined for clang. The PHP_CHECK_GCC_ARG macro isn't happy about that string :(\n        PHP_CHECK_GCC_ARG(-fsanitize-address,               _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -fsanitize-address\")\n        dnl Enable frame debugging\n        PHP_CHECK_GCC_ARG(-fno-omit-frame-pointer,          _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -fno-omit-frame-pointer\")\n        dnl Make sure we don't optimize calls\n        PHP_CHECK_GCC_ARG(-fno-optimize-sibling-calls,      _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -fno-optimize-sibling-calls\")\n        PHP_CHECK_GCC_ARG(-Wlogical-op-parentheses,         _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wlogical-op-parentheses\")\n        PHP_CHECK_GCC_ARG(-Wbool-conversion,                _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wbool-conversion\")\n        PHP_CHECK_GCC_ARG(-Wloop-analysis,                  _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wloop-analysis\")\n        PHP_CHECK_GCC_ARG(-Wsizeof-array-argument,          _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wsizeof-array-argument\")\n        PHP_CHECK_GCC_ARG(-Wstring-conversion,              _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wstring-conversion\")\n        PHP_CHECK_GCC_ARG(-Wno-variadic-macros,             _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wno-variadic-macros\")\n        PHP_CHECK_GCC_ARG(-Wno-sign-compare,                _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wno-sign-compare\")\n        PHP_CHECK_GCC_ARG(-fstack-protector,                _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -fstack-protector\")\n        PHP_CHECK_GCC_ARG(-fno-exceptions,                  _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -fno-exceptions\")\n        PHP_CHECK_GCC_ARG(-Wformat-security,                _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wformat-security\")\n        PHP_CHECK_GCC_ARG(-Wformat-nonliteral,              _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wformat-nonliteral\")\n        PHP_CHECK_GCC_ARG(-Winit-self,                      _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Winit-self\")\n        PHP_CHECK_GCC_ARG(-Wwrite-strings,                  _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wwrite-strings\")\n        PHP_CHECK_GCC_ARG(-Wenum-compare,                   _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wenum-compare\")\n        PHP_CHECK_GCC_ARG(-Wempty-body,                     _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wempty-body\")\n        PHP_CHECK_GCC_ARG(-Wparentheses,                    _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wparentheses\")\n        PHP_CHECK_GCC_ARG(-Wdeclaration-after-statement,    _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wdeclaration-after-statement\")\n        PHP_CHECK_GCC_ARG(-Wmaybe-uninitialized,            _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wmaybe-uninitialized\")\n        PHP_CHECK_GCC_ARG(-Werror,                          _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Werror\")\n        PHP_CHECK_GCC_ARG(-Wextra,                          _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wextra\")\n        PHP_CHECK_GCC_ARG(-Wno-unused-parameter,            _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wno-unused-parameter\")\n        PHP_CHECK_GCC_ARG(-Wno-unused-but-set-variable,     _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wno-unused-but-set-variable\")\n        PHP_CHECK_GCC_ARG(-Wno-missing-field-initializers,  _MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS -Wno-missing-field-initializers\")\n\n        MAINTAINER_CFLAGS=\"$_MAINTAINER_CFLAGS\"\n        STD_CFLAGS=\"-g -O0 -Wall\"\n    fi\n\n    AC_CHECK_FUNCS(gettimeofday)\n    AC_CHECK_FUNCS(clock_gettime)\n    AC_TIDEWAYS_CLOCK\n\n    PHP_TIDEWAYS_XHPROF_CFLAGS=\"-DZEND_ENABLE_STATIC_TSRMLS_CACHE=1 $MAINTAINER_CFLAGS $STD_CFLAGS\"\n\n    PHP_SUBST([LIBS])\n    PHP_NEW_EXTENSION(tideways_xhprof, tideways_xhprof.c tracing.c, $ext_shared,, $PHP_TIDEWAYS_XHPROF_CFLAGS )\nfi\n"
        },
        {
          "name": "config.w32",
          "type": "blob",
          "size": 0.357421875,
          "content": "ARG_WITH(\"tideways_xhprof\", \"Tideways XHProf support\", \"no\");\n\nif (PHP_TIDEWAYS_XHPROF != 'no') {\n    EXTENSION(\"tideways_xhprof\", \"tideways_xhprof.c\", PHP_TIDEWAYS_XHPROF_SHARED, \"/DZEND_ENABLE_STATIC_TSRMLS_CACHE=1\");\n\n    ADD_SOURCES(configure_module_dirname, \"tracing.c\", \"tideways_xhprof\");\n\n    AC_DEFINE('HAVE_TIDEWAYS_XHPROF', 1, 'Have tideways support');\n}\n"
        },
        {
          "name": "php_tideways_xhprof.h",
          "type": "blob",
          "size": 5.6572265625,
          "content": "#ifndef PHP_TIDEWAYS_XHPROF_H\n#define PHP_TIDEWAYS_XHPROF_H\n\nextern zend_module_entry tideways_xhprof_module_entry;\n#define phpext_tideways_xhprof_ptr &tideways_xhprof_module_entry\n\n#define PHP_TIDEWAYS_XHPROF_VERSION \"5.0.4\"\n#define TIDEWAYS_XHPROF_CALLGRAPH_COUNTER_SIZE 1024\n#define TIDEWAYS_XHPROF_CALLGRAPH_SLOTS 8192\n#define TIDEWAYS_XHPROF_CLOCK_CGT 0\n#define TIDEWAYS_XHPROF_CLOCK_GTOD 1\n#define TIDEWAYS_XHPROF_CLOCK_TSC 2\n#define TIDEWAYS_XHPROF_CLOCK_MACH 3\n#define TIDEWAYS_XHPROF_CLOCK_QPC 4\n#define TIDEWAYS_XHPROF_CLOCK_NONE 255\n\n#ifndef TSRMLS_CC\n#define TSRMLS_FETCH()\n#define TSRMLS_CC\n#define TSRMLS_DC\n#define TSRMLS_D\n#define TSRMLS_C\n#endif\n\n#ifdef ZTS\n#include \"TSRM.h\"\n#endif\n\n#if !defined(uint32)\ntypedef unsigned int uint32;\n#endif\n\n#if !defined(uint64)\ntypedef unsigned long long uint64;\n#endif\n\ntypedef struct xhprof_frame_t xhprof_frame_t;\n\ntypedef struct xhprof_callgraph_bucket_t {\n    zend_ulong key;\n    zend_string *parent_class;\n    zend_string *parent_function;\n    int parent_recurse_level;\n    zend_string *child_class;\n    zend_string *child_function;\n    int child_recurse_level;\n    struct xhprof_callgraph_bucket_t *next;\n    zend_long count;\n    zend_long wall_time;\n    zend_long cpu_time;\n    zend_long memory;\n    zend_long memory_peak;\n    long int            num_alloc, num_free;\n    long int            amount_alloc;\n} xhprof_callgraph_bucket;\n\n/* Tracer maintains a stack of entries being profiled.\n *\n * This structure is a convenient place to track start time of a particular\n * profile operation, recursion depth, and the name of the function being\n * profiled. */\nstruct xhprof_frame_t {\n    struct xhprof_frame_t   *previous_frame;        /* ptr to prev entry being profiled */\n    zend_string         *function_name;\n    zend_string         *class_name;\n    uint64              wt_start;           /* start value for wall clock timer */\n    uint64              cpu_start;         /* start value for CPU clock timer */\n    long int            mu_start;                    /* memory usage */\n    long int            pmu_start;              /* peak memory usage */\n    long int            num_alloc, num_free;\n    long int            amount_alloc;\n    int                 recurse_level;\n    zend_ulong          hash_code;          /* hash_code for the function name  */\n};\n\nZEND_BEGIN_MODULE_GLOBALS(tideways_xhprof)\n    int enabled;\n    uint64 start_timestamp;\n    uint64 start_time;\n    int clock_source;\n    zend_bool clock_use_rdtsc;\n    double timebase_factor;\n    zend_string *root;\n    xhprof_frame_t *callgraph_frames;\n    xhprof_frame_t *frame_free_list;\n    zend_ulong function_hash_counters[TIDEWAYS_XHPROF_CALLGRAPH_COUNTER_SIZE];\n    xhprof_callgraph_bucket* callgraph_buckets[TIDEWAYS_XHPROF_CALLGRAPH_SLOTS];\n    zend_long flags;\n    long int num_alloc;\n    long int num_free;\n    long int amount_alloc;\nZEND_END_MODULE_GLOBALS(tideways_xhprof)\n\n#if defined(__GNUC__) && __GNUC__ >= 4\n#\tdefine PHP_TIDEWAYS_XHPROF_API __attribute__ ((visibility(\"default\")))\n#else\n#\tdefine PHP_TIDEWAYS_XHPROF_API\n#endif\n\n#define TIDEWAYS_LOGO_DATA_URI \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEYAAABGCAYAAABxLuKEAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4AMFEx0atoCzjwAABvtJREFUeNrtnH1sleUVwH/ned771dtLDYitFFBCcQ63VTNkA4JDbdSNrXR/mG5LXBYz3f5YzEQWMpINcWZ/KM4sQzecMfhBFheJzNSIMGapVojIKG1lQJHaT1ra8lXae2/vfd9nf7QwVm3Je3u/eulJ3j9u0vPc8/7ec85zznnuW5iSKZmSJIhc/sEYg4hgjFFACLBy/P7jwAURsccFMwJHAx8CtwB5OQ4mDDQAdwIRETFjeYwC9gKLr7LI2Ski944XSgVABxCMHHsNztSDqKR9u5pVhnd2mSudprcaObatEVFy5T82BscxlG2qwD8t4Na8IhHpvvhhdA6xLoXPmXro2gGSrDRjcPJvANyBOX20l6Y3GhCtxgViD9l8ffVylqy7C2/In4iBc4ExwVzmS2oYiuikgRFxryWWoCyNaPmiJREtXFNyLRXbf0x+0bSJGOiM9pC0bYBibNdaXp93eLcctU/EwzGKFs/m7j9VcN3XZiXd2rRux2Li7vOS538ea2wH4xiKl8/jtkeWMf++m1Nma1rB2LEIHrcwfQqMwdgOc+4u4b6X7idwTeqriPR6jD3oWmf6/Bnc8dRKSsoXEiouSJut6a1s4wOuVYqXzaN42by0FzYqrR6TAJhMSVrB2JHerLnx9vMt7GquyiQYGb7EgoKbswLKey3v8kDVSo71HU5BjjHOyGVfuhzlQ/JvQIVKUAULkNACVKAQAkWowMyMAzkbOcPvatewr7MGr/ZhMAmA0X7wTEOUFyMaUdbwU1cWaD/GX4gKzoa8uajQjUhoPtpXkJX5YsiO8u6Jf/Dkh2sJePLwal/iu5KvdC2YNYgojCgEBUoBmoRq+wzJoe4DPFH7GH2RHvI8wYlv12IFxh7aTAL5pKeOlxv+THXbDoKe0OdaiuyqY1Iuhv7oedZV/4L63o9Rogl6QpOgwEuh1HXtZ0vjc9R178dgUBOcCkxqMAOxC/ynt4HNBzfS0HuQgJWHiLgOm5wBE44N8tyBp6hu28FA7AIAASu5jeWkAdMX7mFv+x7ea93Bvs4alCgslTrzJwWYSDzCg29XcG7oLILg1d7c6pUSFb/lp8A/PSm5I6fAAJTOXETciecumMNHT9Dc2uFab8msFcSdWNrsTHqOiUaHOHmql86uHto7u2nr7Ka98xQt7SdpaTtJdGiI+8vLWL/mZ67WXTrnWzjGyTyYWCxO3LaHD7GMwYwcZhljGIxE6OruobOrl9b2Llo7umhu7eDTz9qJxeIorVBKoZVCLuurPB4Ly9J8sK8uIWO/NP0rtPU3ZxbMxudfobr2AAjE4za2bROLx4nF4ti2M3zDAoIgAiKC1hqtx684RYS+M+foHxgkFHRXeywqWpI2MGPmmP7+QU6fPce58xcYGAwTiQ5h2w5KqUtP3tIaPeId4qLj1lpz7HiLa2NvK0rfkXpGdiWtFUeOf+Za76bpC8cdLuXEdl1/uMm1TmFwFjMDhWmBkzEwdY1HE9J74Jafp2XbzhiYk929tHV0udb79vzv49d5uQvG6/Gwdds7rvU82uLLM76au2AsS/OvDz7GcdwWbULZjStTHk4Z7ZXC4Qhdp/pc66266QdosXIXzFAsxsGGIwnpPlz6KMaY3AQjIry4dXtCuvfOryBgBXITDEDTiTaaTrS61psRuJbF1y9P2Sgi42CCeX5eeb0qId0NdzybsvFmxsGICPsPHU44XzxcujollXBWTPBO9Zxm9/sfJaRbufAnhDzTkg4nK8B4vR42PP1CYjcgihe/82bS58FZM/MdisX45559CekWBov40cKfErWjuQdGRNiSYBIGeOjWX7J01gpIUkhl1SlB45HjVO2sSVj/9ys2URQsTspsOKvA+H0+/vCXrUQiiYWEV/v426qdzM6fO+GqOOvOlQYGw7xRtXtCa2z57lvMCc2bkOdkHRgRYePzr9LSfjLhNTzay6vlVZSXVBKOD+YGmOGQ8rLh6c0TDofHvrGezfe8Tp4VzA0wAPWHj/PX196c8DqlRbfz94rdPHr7b7DEImpHJjcYy9Jsfnkbhz45NvF+zJtP+YJKdv2wjvVLn+HW6xZTFCzGp8d+4Wv0q38zgB5A1j25iV01+654gJaOsKre/gLJ/olkzIkhyOVN6CIROZD1HnNRBsNRKh/6dQIj0CskaOUZtzPPejBKCc2tnaz+7TPp/V4mgSgl1H50iF89/uwUmNGitWb3+/tZ+8QfsR1nCszo8cSevf/mwUceT32hOWpXKgA6gbyqnTUc/bQVpbLvB/O27VB8/UwqV92DUkl7toUicmosMAqoBb7J1SXVInLnxX/68blQEhEHuAvYeRVBqQG+d7FP+0KPGfEaERFjjClk+LV+J4ehtF0ePlPy/44wBWFKkiD/BYCRXpsmVUP/AAAAAElFTkSuQmCC\"\n\n#if defined(ZTS) && defined(COMPILE_DL_TIDEWAYS_XHPROF)\nZEND_TSRMLS_CACHE_EXTERN()\n#endif\n\n#endif\t/* PHP_TIDEWAYS_XHPROF_H */\n\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tideways_xhprof.c",
          "type": "blob",
          "size": 8.431640625,
          "content": "#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"SAPI.h\"\n#include \"ext/standard/info.h\"\n#include \"php_tideways_xhprof.h\"\n\nZEND_DECLARE_MODULE_GLOBALS(tideways_xhprof)\n\n#include \"tracing.h\"\n#if PHP_VERSION_ID >= 80000\n#include \"tideways_xhprof_arginfo.h\"\n#else\n#include \"tideways_xhprof_legacy_arginfo.h\"\n#endif\n\nPHP_INI_BEGIN()\n    STD_PHP_INI_ENTRY(\"tideways_xhprof.clock_use_rdtsc\", \"0\", PHP_INI_SYSTEM, OnUpdateBool, clock_use_rdtsc, zend_tideways_xhprof_globals, tideways_xhprof_globals)\nPHP_INI_END()\n\nstatic void (*_zend_execute_internal) (zend_execute_data *execute_data, zval *return_value);\nZEND_DLEXPORT void tideways_xhprof_execute_internal(zend_execute_data *execute_data, zval *return_value);\n\n#if PHP_VERSION_ID >= 80000\n#include \"zend_observer.h\"\n\nstatic void tracer_observer_begin(zend_execute_data *ex) {\n    if (!TXRG(enabled)) {\n        return;\n    }\n\n    tracing_enter_frame_callgraph(NULL, ex);\n}\n\nstatic void tracer_observer_end(zend_execute_data *ex, zval *return_value) {\n    if (!TXRG(enabled)) {\n        return;\n    }\n\n    if (TXRG(callgraph_frames)) {\n        tracing_exit_frame_callgraph(TSRMLS_C);\n    }\n}\n\n\nstatic zend_observer_fcall_handlers tracer_observer(zend_execute_data *execute_data) {\n    zend_function *func = execute_data->func;\n\n    if (!func->common.function_name) {\n        return (zend_observer_fcall_handlers){NULL, NULL};\n    }\n\n    return (zend_observer_fcall_handlers){tracer_observer_begin, tracer_observer_end};\n}\n#else\nstatic void (*_zend_execute_ex) (zend_execute_data *execute_data);\n\nvoid tideways_xhprof_execute_ex (zend_execute_data *execute_data) {\n    zend_execute_data *real_execute_data = execute_data;\n    int is_profiling = 0;\n\n    if (!TXRG(enabled)) {\n        _zend_execute_ex(execute_data TSRMLS_CC);\n        return;\n    }\n\n    is_profiling = tracing_enter_frame_callgraph(NULL, real_execute_data TSRMLS_CC);\n\n    _zend_execute_ex(execute_data TSRMLS_CC);\n\n    if (is_profiling == 1 && TXRG(callgraph_frames)) {\n        tracing_exit_frame_callgraph(TSRMLS_C);\n    }\n}\n#endif\n\nPHP_FUNCTION(tideways_xhprof_enable)\n{\n    zend_long flags = 0;\n\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &flags) == FAILURE) {\n        return;\n    }\n\n    if (TXRG(enabled) == 1) {\n        return;\n    }\n\n    tracing_begin(flags TSRMLS_CC);\n    tracing_enter_root_frame(TSRMLS_C);\n}\n\nPHP_FUNCTION(tideways_xhprof_disable)\n{\n    tracing_end(TSRMLS_C);\n\n    array_init(return_value);\n\n    tracing_callgraph_append_to_array(return_value TSRMLS_CC);\n}\n\nPHP_GINIT_FUNCTION(tideways_xhprof)\n{\n#if defined(COMPILE_DL_TIDEWAYS_XHPROF) && defined(ZTS)\n     ZEND_TSRMLS_CACHE_UPDATE();\n#endif \n     tideways_xhprof_globals->root = NULL;\n     tideways_xhprof_globals->callgraph_frames = NULL;\n     tideways_xhprof_globals->frame_free_list = NULL;\n}\n\nPHP_MINIT_FUNCTION(tideways_xhprof)\n{\n    REGISTER_INI_ENTRIES();\n\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_MEMORY\", TIDEWAYS_XHPROF_FLAGS_MEMORY, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_MEMORY_MU\", TIDEWAYS_XHPROF_FLAGS_MEMORY_MU, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU\", TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_CPU\", TIDEWAYS_XHPROF_FLAGS_CPU, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS\", TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC\", TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC, CONST_CS | CONST_PERSISTENT);\n    REGISTER_LONG_CONSTANT(\"TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC_AS_MU\", TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC_AS_MU, CONST_CS | CONST_PERSISTENT);\n\n    _zend_execute_internal = zend_execute_internal;\n    zend_execute_internal = tideways_xhprof_execute_internal;\n\n#if PHP_VERSION_ID >= 80000\n    zend_observer_fcall_register(tracer_observer);\n#else\n    _zend_execute_ex = zend_execute_ex;\n    zend_execute_ex = tideways_xhprof_execute_ex;\n#endif\n\n    return SUCCESS;\n}\n\nPHP_MSHUTDOWN_FUNCTION(tideways_xhprof)\n{\n    return SUCCESS;\n}\n\nPHP_RINIT_FUNCTION(tideways_xhprof)\n{\n    TXRG(clock_source) = determine_clock_source(TXRG(clock_use_rdtsc));\n    tracing_request_init(TSRMLS_C);\n\n    CG(compiler_options) = CG(compiler_options) | ZEND_COMPILE_NO_BUILTINS;\n\n    return SUCCESS;\n}\n\nPHP_RSHUTDOWN_FUNCTION(tideways_xhprof)\n{\n    int i = 0;\n    xhprof_callgraph_bucket *bucket;\n\n    tracing_end(TSRMLS_C);\n\n    for (i = 0; i < TIDEWAYS_XHPROF_CALLGRAPH_SLOTS; i++) {\n        bucket = TXRG(callgraph_buckets)[i];\n\n        while (bucket) {\n            TXRG(callgraph_buckets)[i] = bucket->next;\n            tracing_callgraph_bucket_free(bucket);\n            bucket = TXRG(callgraph_buckets)[i];\n        }\n    }\n\n    tracing_request_shutdown();\n\n    return SUCCESS;\n}\n\nstatic int tideways_xhprof_info_print(const char *str) /* {{{ */\n{\n    return php_output_write(str, strlen(str));\n}\n\nPHP_MINFO_FUNCTION(tideways_xhprof)\n{\n    php_info_print_table_start();\n    php_info_print_table_row(2, \"Version\", PHP_TIDEWAYS_XHPROF_VERSION);\n\n    switch (TXRG(clock_source)) {\n        case TIDEWAYS_XHPROF_CLOCK_TSC:\n            php_info_print_table_row(2, \"Clock Source\", \"tsc\");\n            break;\n        case TIDEWAYS_XHPROF_CLOCK_CGT:\n            php_info_print_table_row(2, \"Clock Source\", \"clock_gettime\");\n            break;\n        case TIDEWAYS_XHPROF_CLOCK_GTOD:\n            php_info_print_table_row(2, \"Clock Source\", \"gettimeofday\");\n            break;\n        case TIDEWAYS_XHPROF_CLOCK_MACH:\n            php_info_print_table_row(2, \"Clock Source\", \"mach\");\n            break;\n        case TIDEWAYS_XHPROF_CLOCK_QPC:\n            php_info_print_table_row(2, \"Clock Source\", \"Query Performance Counter\");\n            break;\n        case TIDEWAYS_XHPROF_CLOCK_NONE:\n            php_info_print_table_row(2, \"Clock Source\", \"none\");\n            break;\n    }\n    php_info_print_table_end();\n\n    php_info_print_box_start(0);\n\n    if (!sapi_module.phpinfo_as_text) {\n        tideways_xhprof_info_print(\"<a href=\\\"https://tideways.io\\\"><img border=0 src=\\\"\");\n        tideways_xhprof_info_print(TIDEWAYS_LOGO_DATA_URI \"\\\" alt=\\\"Tideways logo\\\" /></a>\\n\");\n    }\n\n    tideways_xhprof_info_print(\"Tideways is a PHP Profiler, Monitoring and Exception Tracking Software.\");\n    tideways_xhprof_info_print(!sapi_module.phpinfo_as_text?\"<br /><br />\":\"\\n\\n\");\n    tideways_xhprof_info_print(\"The 'tideways_xhprof' extension provides a subset of the functionality of our commercial Tideways offering in a modern, optimized fork of the XHProf extension from Facebook as open-source. (c) Tideways GmbH 2014-2017, (c) Facebook 2009\");\n\n    if (!sapi_module.phpinfo_as_text) {\n        tideways_xhprof_info_print(\"<br /><br /><strong>Register for a free trial on <a style=\\\"background-color: inherit\\\" href=\\\"https://tideways.io\\\">https://tideways.io</a></strong>\");\n    } else {\n        tideways_xhprof_info_print(\"\\n\\nRegister for a free trial on https://tideways.io\\n\\n\");\n    }\n\n    php_info_print_box_end();\n\n}\n\nZEND_DLEXPORT void tideways_xhprof_execute_internal(zend_execute_data *execute_data, zval *return_value) {\n    int is_profiling = 1;\n\n    if (!TXRG(enabled) || (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS) > 0) {\n        execute_internal(execute_data, return_value TSRMLS_CC);\n        return;\n    }\n\n    is_profiling = tracing_enter_frame_callgraph(NULL, execute_data TSRMLS_CC);\n\n    if (!_zend_execute_internal) {\n        execute_internal(execute_data, return_value TSRMLS_CC);\n    } else {\n        _zend_execute_internal(execute_data, return_value TSRMLS_CC);\n    }\n\n    if (is_profiling == 1 && TXRG(callgraph_frames)) {\n        tracing_exit_frame_callgraph(TSRMLS_C);\n    }\n}\n\nconst zend_function_entry tideways_xhprof_functions[] = {\n    PHP_FE(tideways_xhprof_enable,\targinfo_tideways_xhprof_enable)\n    PHP_FE(tideways_xhprof_disable,\targinfo_tideways_xhprof_disable)\n    PHP_FE_END\n};\n\nzend_module_entry tideways_xhprof_module_entry = {\n    STANDARD_MODULE_HEADER,\n    \"tideways_xhprof\",\n    tideways_xhprof_functions,\n    PHP_MINIT(tideways_xhprof),\n    PHP_MSHUTDOWN(tideways_xhprof),\n    PHP_RINIT(tideways_xhprof),\n    PHP_RSHUTDOWN(tideways_xhprof),\n    PHP_MINFO(tideways_xhprof),\n    PHP_TIDEWAYS_XHPROF_VERSION,\n    PHP_MODULE_GLOBALS(tideways_xhprof),\n    PHP_GINIT(tideways_xhprof),\n    NULL,\n    NULL,\n    STANDARD_MODULE_PROPERTIES_EX\n};\n\n#ifdef COMPILE_DL_TIDEWAYS_XHPROF\n#ifdef ZTS\nZEND_TSRMLS_CACHE_DEFINE()\n#endif\nZEND_GET_MODULE(tideways_xhprof)\n#endif\n"
        },
        {
          "name": "tideways_xhprof.stub.php",
          "type": "blob",
          "size": 0.23046875,
          "content": "<?php\n\n/**\n * @param int|null $options\n * @return void\n *\n * @generate-legacy-arginfo\n */\nfunction tideways_xhprof_enable($options = null) {}\n/**\n * @return array\n *\n * @generate-legacy-arginfo\n */\nfunction tideways_xhprof_disable() {}\n"
        },
        {
          "name": "tideways_xhprof_arginfo.h",
          "type": "blob",
          "size": 0.3369140625,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: f2f525e0d154673c4369cd9a3bf6c84141fbfdc8 */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_tideways_xhprof_enable, 0, 0, 0)\n\tZEND_ARG_INFO_WITH_DEFAULT_VALUE(0, options, \"null\")\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_tideways_xhprof_disable, 0, 0, 0)\nZEND_END_ARG_INFO()\n"
        },
        {
          "name": "tideways_xhprof_legacy_arginfo.h",
          "type": "blob",
          "size": 0.310546875,
          "content": "/* This is a generated file, edit the .stub.php file instead.\n * Stub hash: f2f525e0d154673c4369cd9a3bf6c84141fbfdc8 */\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_tideways_xhprof_enable, 0, 0, 0)\n\tZEND_ARG_INFO(0, options)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_tideways_xhprof_disable, 0, 0, 0)\nZEND_END_ARG_INFO()\n"
        },
        {
          "name": "timer.h",
          "type": "blob",
          "size": 5.42578125,
          "content": "#ifndef TRACER_TIMER_H\n#define TRACER_TIMER_H\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef PHP_WIN32\n#include \"win32/time.h\"\n#include \"win32/unistd.h\"\n#include \"win32/getrusage.h\"\n#elif __APPLE__\n#include <mach/mach_init.h>\n#include <mach/mach_time.h>\n#else\n#include \"sys/time.h\"\n#include <sys/resource.h>\n#endif\n\nstatic int determine_clock_source(int clock_use_rdtsc) {\n#if defined(__APPLE__)\n    return TIDEWAYS_XHPROF_CLOCK_MACH;\n#elif defined(__powerpc__) || defined(__ppc__)\n    return TIDEWAYS_XHPROF_CLOCK_TSC;\n#elif defined(__s390__) // Covers both s390 and s390x.\n    return TIDEWAYS_XHPROF_CLOCK_TSC;\n#elif defined(__ARM_ARCH) && !defined(__aarch64__)\n    return TIDEWAYS_XHPROF_CLOCK_GTOD;\n#elif defined(PHP_WIN32)\n    return TIDEWAYS_XHPROF_CLOCK_QPC;\n#else\n    struct timespec res;\n\n    if (clock_use_rdtsc == 1) {\n        return TIDEWAYS_XHPROF_CLOCK_TSC;\n    }\n\n#if HAVE_CLOCK_GETTIME\n    if (clock_gettime(CLOCK_MONOTONIC, &res) == 0) {\n        return TIDEWAYS_XHPROF_CLOCK_CGT;\n    }\n#endif\n\n#if HAVE_GETTIMEOFDAY\n    return TIDEWAYS_XHPROF_CLOCK_GTOD;\n#endif\n\n    return TIDEWAYS_XHPROF_CLOCK_TSC;\n#endif\n}\n\nstatic zend_always_inline uint64 current_timestamp() {\n    struct timeval tv;\n\n    if (gettimeofday(&tv, NULL)) {\n        php_error(E_ERROR, \"tracer: Cannot acquire gettimeofday\");\n        zend_bailout();\n    }\n\n    return 1000 * (uint64) tv.tv_sec + (uint64) tv.tv_usec / 1000;\n}\n\nstatic zend_always_inline uint64 time_milliseconds_cgt()\n{\n#if HAVE_CLOCK_GETTIME\n    struct timespec s;\n\n    if (clock_gettime(CLOCK_MONOTONIC, &s) == 0) {\n        return s.tv_sec * 1000000 + s.tv_nsec / 1000;\n    }\n#endif\n\n    return 0;\n}\n\nstatic zend_always_inline uint64 time_milliseconds_gtod()\n{\n#if HAVE_GETTIMEOFDAY\n    struct timeval now;\n    if (gettimeofday(&now, NULL) == 0) {\n        return now.tv_sec * 1000000 + now.tv_usec;\n    }\n#endif\n\n    return 0;\n}\n\nstatic zend_always_inline uint64 time_milliseconds_tsc_query()\n{\n#if defined(__s390__) // Covers both s390 and s390x.\n\n    uint64_t tsc;\n    // Return the CPU clock.\n    asm(\"stck %0\" : \"=Q\" (tsc) : : \"cc\");\n\n    return tsc;\n#elif defined(__i386__)\n    int64_t ret;\n    __asm__ volatile(\"rdtsc\" : \"=A\"(ret));\n    return ret;\n#elif defined(__x86_64__) || defined(__amd64__)\n    uint64 val;\n    uint32 a, d;\n    asm volatile(\"rdtsc\" : \"=a\" (a), \"=d\" (d));\n    (val) = ((uint64)a) | (((uint64)d)<<32);\n    return val;\n#elif defined(__powerpc__) || defined(__ppc__)\n    uint64 val;\n    asm volatile (\"mftb %0\" : \"=r\" (val));\n    return val;\n#elif defined(__aarch64__)\n    uint64 val;\n    asm volatile(\"mrs %0, cntvct_el0\" : \"=r\" (val));\n    return val;\n#else\n    return 0;\n#endif\n}\n\n/**\n * Get the current wallclock timer\n *\n * @return 64 bit unsigned integer\n * @author cjiang\n */\nstatic zend_always_inline uint64 time_milliseconds(int source, double timebase_factor)\n{\n#if defined(__APPLE__)\n\n    return mach_absolute_time() / timebase_factor;\n#elif defined(PHP_WIN32)\n\n    LARGE_INTEGER count;\n\n    if (!QueryPerformanceCounter(&count)) {\n        return 0;\n    }\n\n    return (double)(count.QuadPart) / timebase_factor;\n#else\n\n    if (source == TIDEWAYS_XHPROF_CLOCK_TSC) {\n        return time_milliseconds_tsc_query() / timebase_factor;\n    } else if (source == TIDEWAYS_XHPROF_CLOCK_GTOD) {\n        return time_milliseconds_gtod();\n    } else if (source == TIDEWAYS_XHPROF_CLOCK_CGT) {\n        return time_milliseconds_cgt();\n    }\n\n#endif\n\n    return 0;\n}\n\n/**\n * Get time delta in microseconds.\n */\nstatic long get_us_interval(struct timeval *start, struct timeval *end)\n{\n    return (((end->tv_sec - start->tv_sec) * 1000000)\n            + (end->tv_usec - start->tv_usec));\n}\n\nstatic zend_always_inline double get_timebase_factor_tsc()\n{\n    struct timeval start;\n    struct timeval end;\n    uint64 tsc_start;\n    uint64 tsc_end;\n    volatile int i;\n\n    if (gettimeofday(&start, 0)) {\n        perror(\"gettimeofday\");\n        return 0.0;\n    }\n\n    tsc_start  = time_milliseconds_tsc_query();\n    /* Busy loop for 5 miliseconds. */\n    do {\n        for (i = 0; i < 1000000; i++);\n            if (gettimeofday(&end, 0)) {\n                perror(\"gettimeofday\");\n                return 0.0;\n            }\n        tsc_end = time_milliseconds_tsc_query();\n    } while (get_us_interval(&start, &end) < 5000);\n\n    return (tsc_end - tsc_start) * 1.0 / (get_us_interval(&start, &end));\n}\n\n/**\n * Get the timebase factor necessary to divide by in time_milliseconds()\n */\nstatic zend_always_inline double get_timebase_factor(int source)\n{\n#if defined(__APPLE__)\n    mach_timebase_info_data_t sTimebaseInfo;\n    (void) mach_timebase_info(&sTimebaseInfo);\n\n    return (sTimebaseInfo.numer / sTimebaseInfo.denom) * 1000;\n#elif defined(PHP_WIN32)\n    unsigned __int64 frequency;\n\n    if (!QueryPerformanceFrequency( (LARGE_INTEGER*)&frequency)) {\n        zend_error(E_ERROR, \"QueryPerformanceFrequency\");\n    }\n\n    return (double)frequency/1000000.0;\n#else\n    if (source == TIDEWAYS_XHPROF_CLOCK_TSC) {\n        return get_timebase_factor_tsc();\n    }\n\n    return 1.0;\n#endif\n}\n\n/**\n * Get the current real CPU clock timer\n */\nstatic uint64 cpu_timer() {\n    struct rusage ru;\n#if defined(CLOCK_PROCESS_CPUTIME_ID)\n    struct timespec s;\n\n    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &s) == 0) {\n        return s.tv_sec * 1000000 + s.tv_nsec / 1000;\n    }\n#endif\n\n    if (getrusage(RUSAGE_SELF, &ru) == 0) {\n        return ru.ru_utime.tv_sec * 1000000 + ru.ru_utime.tv_usec +\n            ru.ru_stime.tv_sec * 1000000 + ru.ru_stime.tv_usec;\n    }\n\n    return 0;\n}\n\n#endif\n"
        },
        {
          "name": "tracing.c",
          "type": "blob",
          "size": 9.64453125,
          "content": "#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"ext/standard/html.h\"\n#include \"php_tideways_xhprof.h\"\n\nextern ZEND_DECLARE_MODULE_GLOBALS(tideways_xhprof);\n\n#include \"tracing.h\"\n\nstatic const char digits[] = \"0123456789abcdef\";\n\nstatic void *(*_zend_malloc) (size_t);\nstatic void (*_zend_free) (void *);\nstatic void *(*_zend_realloc) (void *, size_t);\n\nvoid *tideways_malloc (size_t size);\nvoid tideways_free (void *ptr);\nvoid *tideways_realloc (void *ptr, size_t size);\n\n/**\n * Free any items in the free list.\n */\nstatic zend_always_inline void tracing_free_the_free_list(TSRMLS_D)\n{\n    xhprof_frame_t *frame = TXRG(frame_free_list);\n    xhprof_frame_t *current;\n\n    while (frame) {\n        current = frame;\n        frame = frame->previous_frame;\n        efree(current);\n    }\n}\n\nvoid tracing_enter_root_frame(TSRMLS_D)\n{\n    TXRG(start_time) = time_milliseconds(TXRG(clock_source), TXRG(timebase_factor));\n    TXRG(start_timestamp) = current_timestamp();\n    TXRG(enabled) = 1;\n    TXRG(root) = zend_string_init(TIDEWAYS_XHPROF_ROOT_SYMBOL, sizeof(TIDEWAYS_XHPROF_ROOT_SYMBOL)-1, 0);\n\n    tracing_enter_frame_callgraph(TXRG(root), NULL TSRMLS_CC);\n}\n\nvoid tracing_end(TSRMLS_D)\n{\n    if (TXRG(enabled) == 1) {\n        if (TXRG(root)) {\n            zend_string_release(TXRG(root));\n        }\n\n        while (TXRG(callgraph_frames)) {\n            tracing_exit_frame_callgraph(TSRMLS_C);\n        }\n\n        TXRG(enabled) = 0;\n        TXRG(callgraph_frames) = NULL;\n\n        if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC) {\n            zend_mm_heap *heap = zend_mm_get_heap();\n\n            if (_zend_malloc || _zend_free || _zend_realloc) {\n                zend_mm_set_custom_handlers(heap, _zend_malloc, _zend_free, _zend_realloc);\n                _zend_malloc = NULL;\n                _zend_free = NULL;\n                _zend_realloc = NULL;\n            } else {\n                // zend_mm_heap is incomplete type, hence one can not access it\n                //  the following line is equivalent to heap->use_custom_heap = 0;\n                *((int*) heap) = 0;\n            }\n        }\n    }\n}\n\nvoid tracing_callgraph_bucket_free(xhprof_callgraph_bucket *bucket)\n{\n    if (bucket->parent_class) {\n        zend_string_release(bucket->parent_class);\n    }\n\n    if (bucket->parent_function) {\n        zend_string_release(bucket->parent_function);\n    }\n\n    if (bucket->child_class) {\n        zend_string_release(bucket->child_class);\n    }\n\n    if (bucket->child_function) {\n        zend_string_release(bucket->child_function);\n    }\n\n    efree(bucket);\n}\n\nxhprof_callgraph_bucket *tracing_callgraph_bucket_find(xhprof_callgraph_bucket *bucket, xhprof_frame_t *current_frame, xhprof_frame_t *previous, zend_long key)\n{\n    while (bucket) {\n        if (bucket->key == key &&\n            bucket->child_recurse_level == current_frame->recurse_level &&\n            bucket->child_class == current_frame->class_name &&\n            zend_string_equals(bucket->child_function, current_frame->function_name)) {\n\n            if (previous == NULL && bucket->parent_class == NULL && bucket->parent_function == NULL ) {\n                // special handling for the root\n                return bucket;\n            } else if (previous &&\n                       previous->recurse_level == bucket->parent_recurse_level &&\n                       previous->class_name == bucket->parent_class &&\n                       zend_string_equals(previous->function_name, bucket->parent_function)) {\n                // parent matches as well\n                return bucket;\n            }\n        }\n\n        bucket = bucket->next;\n    }\n\n    return NULL;\n}\n\nzend_always_inline static zend_ulong hash_data(zend_ulong hash, char *data, size_t size)\n{\n    size_t i;\n\n    for (i = 0; i < size; ++i) {\n        hash = hash * 33 + data[i];\n    }\n\n    return hash;\n}\n\nzend_always_inline static zend_ulong hash_int(zend_ulong hash, int data)\n{\n    return hash_data(hash, (char*) &data, sizeof(data));\n}\n\nzend_ulong tracing_callgraph_bucket_key(xhprof_frame_t *frame)\n{\n    zend_ulong hash = 5381;\n    xhprof_frame_t *previous = frame->previous_frame;\n\n    if (previous) {\n        if (previous->class_name) {\n            hash = hash_int(hash, ZSTR_HASH(previous->class_name));\n        }\n\n        if (previous->function_name) {\n            hash = hash_int(hash, ZSTR_HASH(previous->function_name));\n        }\n        hash += previous->recurse_level;\n    }\n\n    if (frame->class_name) {\n        hash = hash_int(hash, ZSTR_HASH(frame->class_name));\n    }\n\n    if (frame->function_name) {\n        hash = hash_int(hash, ZSTR_HASH(frame->function_name));\n    }\n\n    hash += frame->recurse_level;\n\n    return hash;\n}\n\nvoid tracing_callgraph_get_parent_child_name(xhprof_callgraph_bucket *bucket, char *symbol, size_t symbol_len TSRMLS_DC)\n{\n    if (bucket->parent_class) {\n        if (bucket->parent_recurse_level > 0) {\n            snprintf(symbol, symbol_len, \"%s::%s@%d==>\", ZSTR_VAL(bucket->parent_class), ZSTR_VAL(bucket->parent_function), bucket->parent_recurse_level);\n        } else {\n            snprintf(symbol, symbol_len, \"%s::%s==>\", ZSTR_VAL(bucket->parent_class), ZSTR_VAL(bucket->parent_function));\n        }\n    } else if (bucket->parent_function) {\n        if (bucket->parent_recurse_level > 0) {\n            snprintf(symbol, symbol_len, \"%s@%d==>\", ZSTR_VAL(bucket->parent_function), bucket->parent_recurse_level);\n        } else {\n            snprintf(symbol, symbol_len, \"%s==>\", ZSTR_VAL(bucket->parent_function));\n        }\n    } else {\n        snprintf(symbol, symbol_len, \"\");\n    }\n\n    if (bucket->child_class) {\n        if (bucket->child_recurse_level > 0) {\n            snprintf(symbol, symbol_len, \"%s%s::%s@%d\", symbol, ZSTR_VAL(bucket->child_class), ZSTR_VAL(bucket->child_function), bucket->child_recurse_level);\n        } else {\n            snprintf(symbol, symbol_len, \"%s%s::%s\", symbol, ZSTR_VAL(bucket->child_class), ZSTR_VAL(bucket->child_function));\n        }\n    } else if (bucket->child_function) {\n        if (bucket->child_recurse_level > 0) {\n            snprintf(symbol, symbol_len, \"%s%s@%d\", symbol, ZSTR_VAL(bucket->child_function), bucket->child_recurse_level);\n        } else {\n            snprintf(symbol, symbol_len, \"%s%s\", symbol, ZSTR_VAL(bucket->child_function));\n        }\n    }\n}\n\nvoid tracing_callgraph_append_to_array(zval *return_value TSRMLS_DC)\n{\n    int i = 0;\n    xhprof_callgraph_bucket *bucket;\n    char symbol[512] = \"\";\n    zval stats_zv, *stats = &stats_zv;\n\n    int as_mu =\n        (TXRG(flags) & (TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC_AS_MU | TIDEWAYS_XHPROF_FLAGS_MEMORY_MU))\n            == TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC_AS_MU;\n\n    for (i = 0; i < TIDEWAYS_XHPROF_CALLGRAPH_SLOTS; i++) {\n        bucket = TXRG(callgraph_buckets)[i];\n\n        while (bucket) {\n            tracing_callgraph_get_parent_child_name(bucket, symbol, sizeof(symbol) TSRMLS_CC);\n\n            array_init(stats);\n            add_assoc_long(stats, \"ct\", bucket->count);\n            add_assoc_long(stats, \"wt\", bucket->wall_time);\n\n            if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC) {\n                add_assoc_long(stats, \"mem.na\", bucket->num_alloc);\n                add_assoc_long(stats, \"mem.nf\", bucket->num_free);\n                add_assoc_long(stats, \"mem.aa\", bucket->amount_alloc);\n\n                if (as_mu) {\n                    add_assoc_long(stats, \"mu\", bucket->amount_alloc);\n                }\n            }\n\n            if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_CPU) {\n                add_assoc_long(stats, \"cpu\", bucket->cpu_time);\n            }\n\n            if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_MU) {\n                add_assoc_long(stats, \"mu\", bucket->memory);\n            }\n\n            if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU) {\n                add_assoc_long(stats, \"pmu\", bucket->memory_peak);\n            }\n\n            add_assoc_zval(return_value, symbol, stats);\n\n            TXRG(callgraph_buckets)[i] = bucket->next;\n            tracing_callgraph_bucket_free(bucket);\n            bucket = TXRG(callgraph_buckets)[i];\n        }\n    }\n}\n\nvoid tracing_begin(zend_long flags TSRMLS_DC)\n{\n    int i;\n\n    TXRG(flags) = flags;\n    TXRG(callgraph_frames) = NULL;\n\n    for (i = 0; i < TIDEWAYS_XHPROF_CALLGRAPH_SLOTS; i++) {\n        TXRG(callgraph_buckets)[i] = NULL;\n    }\n\n    for (i = 0; i < TIDEWAYS_XHPROF_CALLGRAPH_COUNTER_SIZE; i++) {\n        TXRG(function_hash_counters)[i] = 0;\n    }\n\n    if (flags & TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC) {\n        zend_mm_heap *heap = zend_mm_get_heap();\n        zend_mm_get_custom_handlers (heap, &_zend_malloc, &_zend_free, &_zend_realloc);\n        zend_mm_set_custom_handlers (heap, &tideways_malloc, &tideways_free, &tideways_realloc);\n    }\n}\n\nvoid tracing_request_init(TSRMLS_D)\n{\n    TXRG(timebase_factor) = get_timebase_factor(TXRG(clock_source));\n    TXRG(enabled) = 0;\n    TXRG(flags) = 0;\n    TXRG(frame_free_list) = NULL;\n\n    TXRG(num_alloc) = 0;\n    TXRG(num_free) = 0;\n    TXRG(amount_alloc) = 0;\n}\n\nvoid tracing_request_shutdown()\n{\n    tracing_free_the_free_list(TSRMLS_C);\n}\n\nvoid *tideways_malloc (size_t size)\n{\n    TXRG(num_alloc) += 1;\n    TXRG(amount_alloc) += size;\n\n    if (_zend_malloc) {\n        return _zend_malloc(size);\n    }\n\n    zend_mm_heap *heap = zend_mm_get_heap();\n    return zend_mm_alloc(heap, size);\n}\n\nvoid tideways_free (void *ptr)\n{\n    TXRG(num_free) += 1;\n\n    if (_zend_free) {\n        return _zend_free(ptr);\n    }\n\n    zend_mm_heap *heap = zend_mm_get_heap();\n    return zend_mm_free(heap, ptr);\n}\n\nvoid *tideways_realloc (void *ptr, size_t size)\n{\n    TXRG(num_alloc) += 1;\n    TXRG(num_free) += 1;\n    TXRG(amount_alloc) += size;\n\n    if (_zend_realloc) {\n        return _zend_realloc(ptr, size);\n    }\n\n    zend_mm_heap *heap = zend_mm_get_heap();\n    return zend_mm_realloc(heap, ptr, size);\n}\n"
        },
        {
          "name": "tracing.h",
          "type": "blob",
          "size": 7.9111328125,
          "content": "#include \"timer.h\"\n\n#define TIDEWAYS_XHPROF_ROOT_SYMBOL \"main()\"\n#define TIDEWAYS_XHPROF_CALLGRAPH_COUNTER_SIZE 1024\n#define TIDEWAYS_XHPROF_CALLGRAPH_SLOTS 8192\n#define TIDEWAYS_XHPROF_FLAGS_CPU 1\n#define TIDEWAYS_XHPROF_FLAGS_MEMORY_MU 2\n#define TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU 4\n#define TIDEWAYS_XHPROF_FLAGS_MEMORY 6\n#define TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC 16\n#define TIDEWAYS_XHPROF_FLAGS_MEMORY_ALLOC_AS_MU (32|16)\n#define TIDEWAYS_XHPROF_FLAGS_NO_BUILTINS 8\n\nvoid tracing_callgraph_append_to_array(zval *return_value TSRMLS_DC);\nvoid tracing_callgraph_get_parent_child_name(xhprof_callgraph_bucket *bucket, char *symbol, size_t symbol_len TSRMLS_DC);\nzend_ulong tracing_callgraph_bucket_key(xhprof_frame_t *frame);\nxhprof_callgraph_bucket *tracing_callgraph_bucket_find(xhprof_callgraph_bucket *bucket, xhprof_frame_t *current_frame, xhprof_frame_t *previous, zend_long key);\nvoid tracing_callgraph_bucket_free(xhprof_callgraph_bucket *bucket);\nvoid tracing_begin(zend_long flags TSRMLS_DC);\nvoid tracing_end(TSRMLS_D);\nvoid tracing_enter_root_frame(TSRMLS_D);\nvoid tracing_request_init(TSRMLS_D);\nvoid tracing_request_shutdown();\nvoid tracing_determine_clock_source();\n\n#define TXRG(v) ZEND_MODULE_GLOBALS_ACCESSOR(tideways_xhprof, v)\n\n#if defined(ZTS) && defined(COMPILE_DL_TIDEWAYS_XHPROF)\nZEND_TSRMLS_CACHE_EXTERN()\n#endif\n\nstatic zend_always_inline void tracing_fast_free_frame(xhprof_frame_t *p TSRMLS_DC)\n{\n    if (p->function_name != NULL) {\n        zend_string_release(p->function_name);\n    }\n    if (p->class_name != NULL) {\n        zend_string_release(p->class_name);\n    }\n\n    /* we use/overload the previous_frame field in the structure to link entries in\n     * the free list. */\n    p->previous_frame = TXRG(frame_free_list);\n    TXRG(frame_free_list) = p;\n}\n\nstatic zend_always_inline xhprof_frame_t* tracing_fast_alloc_frame(TSRMLS_D)\n{\n    xhprof_frame_t *p;\n\n    p = TXRG(frame_free_list);\n\n    if (p) {\n        TXRG(frame_free_list) = p->previous_frame;\n        return p;\n    } else {\n        return (xhprof_frame_t *)emalloc(sizeof(xhprof_frame_t));\n    }\n}\n\nstatic zend_always_inline zend_string* tracing_get_class_name(zend_execute_data *data TSRMLS_DC)\n{\n    zend_function *curr_func;\n\n    if (!data) {\n        return NULL;\n    }\n\n    curr_func = data->func;\n\n    if (curr_func->common.scope != NULL) {\n        zend_string_addref(curr_func->common.scope->name);\n\n        return curr_func->common.scope->name;\n    }\n\n    return NULL;\n}\n\nstatic zend_always_inline zend_string* tracing_get_function_name(zend_execute_data *data TSRMLS_DC)\n{\n    zend_function *curr_func;\n\n    if (!data) {\n        return NULL;\n    }\n\n    curr_func = data->func;\n\n    if (!curr_func->common.function_name) {\n        // This branch includes execution of eval and include/require(_once) calls\n        // We assume it is not 1999 anymore and not much PHP code runs in the\n        // body of a file and if it is, we are ok with adding it to the caller's wt.\n        return NULL;\n    }\n\n    zend_string_addref(curr_func->common.function_name);\n\n    return curr_func->common.function_name;\n}\n\nzend_always_inline static int tracing_enter_frame_callgraph(zend_string *root_symbol, zend_execute_data *execute_data TSRMLS_DC)\n{\n    zend_string *function_name = (root_symbol != NULL) ? zend_string_copy(root_symbol) : tracing_get_function_name(execute_data TSRMLS_CC);\n    xhprof_frame_t *current_frame;\n    xhprof_frame_t *p;\n    int recurse_level = 0;\n\n    if (function_name == NULL) {\n        return 0;\n    }\n\n    current_frame = tracing_fast_alloc_frame(TSRMLS_C);\n    current_frame->class_name = (root_symbol == NULL) ? tracing_get_class_name(execute_data TSRMLS_CC) : NULL;\n    current_frame->function_name = function_name;\n    current_frame->previous_frame = TXRG(callgraph_frames);\n    current_frame->recurse_level = 0;\n    current_frame->wt_start = time_milliseconds(TXRG(clock_source), TXRG(timebase_factor));\n\n    if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_CPU) {\n        current_frame->cpu_start = cpu_timer();\n    }\n\n    if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU) {\n        current_frame->pmu_start = zend_memory_peak_usage(0 TSRMLS_CC);\n    }\n\n    if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_MU) {\n        current_frame->mu_start = zend_memory_usage(0 TSRMLS_CC);\n    }\n\n    current_frame->num_alloc = TXRG(num_alloc);\n    current_frame->num_free = TXRG(num_free);\n    current_frame->amount_alloc = TXRG(amount_alloc);\n\n    /* We only need to compute the hash for the function name,\n     * that should be \"good\" enough, we sort into 1024 buckets only anyways */\n    current_frame->hash_code = ZSTR_HASH(function_name) % TIDEWAYS_XHPROF_CALLGRAPH_COUNTER_SIZE;\n\n    /* Update entries linked list */\n    TXRG(callgraph_frames) = current_frame;\n\n    if (TXRG(function_hash_counters)[current_frame->hash_code] > 0) {\n        /* Find this symbols recurse level */\n        for(p = current_frame->previous_frame; p; p = p->previous_frame) {\n            if (zend_string_equals(current_frame->function_name, p->function_name) && (!current_frame->class_name || current_frame->class_name == p->class_name)) {\n                recurse_level = (p->recurse_level) + 1;\n                break;\n            }\n        }\n    }\n    TXRG(function_hash_counters)[current_frame->hash_code]++;\n\n    /* Init current function's recurse level */\n    current_frame->recurse_level = recurse_level;\n\n    return 1;\n}\n\nzend_always_inline static void tracing_exit_frame_callgraph(TSRMLS_D)\n{\n    xhprof_frame_t *current_frame = TXRG(callgraph_frames);\n    xhprof_frame_t *previous = current_frame->previous_frame;\n    zend_long duration = time_milliseconds(TXRG(clock_source), TXRG(timebase_factor)) - current_frame->wt_start;\n\n    zend_ulong key = tracing_callgraph_bucket_key(current_frame);\n    unsigned int slot = (unsigned int)key % TIDEWAYS_XHPROF_CALLGRAPH_SLOTS;\n    xhprof_callgraph_bucket *bucket = TXRG(callgraph_buckets)[slot];\n\n    bucket = tracing_callgraph_bucket_find(bucket, current_frame, previous, key);\n\n    if (bucket == NULL) {\n        bucket = emalloc(sizeof(xhprof_callgraph_bucket));\n        bucket->key = key;\n        bucket->child_class = current_frame->class_name ? zend_string_copy(current_frame->class_name) : NULL;\n        bucket->child_function = zend_string_copy(current_frame->function_name);\n\n        if (previous) {\n            bucket->parent_class = previous->class_name ? zend_string_copy(current_frame->previous_frame->class_name) : NULL;\n            bucket->parent_function = zend_string_copy(previous->function_name);\n            bucket->parent_recurse_level = previous->recurse_level;\n        } else {\n            bucket->parent_class = NULL;\n            bucket->parent_function = NULL;\n            bucket->parent_recurse_level = 0;\n        }\n\n        bucket->count = 0;\n        bucket->wall_time = 0;\n        bucket->cpu_time = 0;\n        bucket->memory = 0;\n        bucket->memory_peak = 0;\n        bucket->num_alloc = 0;\n        bucket->num_free = 0;\n        bucket->amount_alloc = 0;\n        bucket->child_recurse_level = current_frame->recurse_level;\n        bucket->next = TXRG(callgraph_buckets)[slot];\n\n        TXRG(callgraph_buckets)[slot] = bucket;\n    }\n\n    bucket->count++;\n    bucket->wall_time += duration;\n\n    bucket->num_alloc += TXRG(num_alloc) - current_frame->num_alloc;\n    bucket->num_free += TXRG(num_free) - current_frame->num_free;\n    bucket->amount_alloc += TXRG(amount_alloc) - current_frame->amount_alloc;\n\n    if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_CPU) {\n        bucket->cpu_time += (cpu_timer() - current_frame->cpu_start);\n    }\n\n    if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_MU) {\n        bucket->memory += (zend_memory_usage(0 TSRMLS_CC) - current_frame->mu_start);\n    }\n\n    if (TXRG(flags) & TIDEWAYS_XHPROF_FLAGS_MEMORY_PMU) {\n        bucket->memory_peak += (zend_memory_peak_usage(0 TSRMLS_CC) - current_frame->pmu_start);\n    }\n\n    TXRG(function_hash_counters)[current_frame->hash_code]--;\n\n    TXRG(callgraph_frames) = TXRG(callgraph_frames)->previous_frame;\n    tracing_fast_free_frame(current_frame TSRMLS_CC);\n}\n"
        }
      ]
    }
  ]
}