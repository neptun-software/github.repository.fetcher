{
  "metadata": {
    "timestamp": 1736709809987,
    "page": 264,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "namhyung/uftrace",
      "stars": 3103,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 4.0390625,
          "content": "# SPDX-License-Identifier: GPL-2.0\n#\n# clang-format configuration file. Intended for clang-format >= 11.\n#\n# For more information, see:\n#\n#   https://clang.llvm.org/docs/ClangFormat.html\n#   https://clang.llvm.org/docs/ClangFormatStyleOptions.html\n#\n---\nAccessModifierOffset: -4\nAlignAfterOpenBracket: Align\nAlignConsecutiveAssignments: false\nAlignConsecutiveDeclarations: false\nAlignEscapedNewlines: Right\nAlignOperands: true\nAlignTrailingComments: false\nAllowAllParametersOfDeclarationOnNextLine: false\nAllowShortBlocksOnASingleLine: false\nAllowShortCaseLabelsOnASingleLine: false\nAllowShortFunctionsOnASingleLine: None\nAllowShortIfStatementsOnASingleLine: false\nAllowShortLoopsOnASingleLine: false\nAlwaysBreakAfterDefinitionReturnType: None\nAlwaysBreakAfterReturnType: None\nAlwaysBreakBeforeMultilineStrings: false\nAlwaysBreakTemplateDeclarations: true\nBinPackArguments: true\nBinPackParameters: true\nBraceWrapping:\n  AfterClass: false\n  AfterControlStatement: false\n  AfterEnum: false\n  AfterFunction: true\n  AfterNamespace: false\n  AfterObjCDeclaration: false\n  AfterStruct: false\n  AfterUnion: false\n  AfterExternBlock: false\n  BeforeCatch: false\n  BeforeElse: true\n  IndentBraces: false\n  SplitEmptyFunction: true\n  SplitEmptyRecord: true\n  SplitEmptyNamespace: true\nBreakBeforeBinaryOperators: None\nBreakBeforeBraces: Custom\nBreakBeforeInheritanceComma: false\nBreakBeforeTernaryOperators: false\nBreakConstructorInitializersBeforeComma: false\nBreakConstructorInitializers: BeforeComma\nBreakAfterJavaFieldAnnotations: false\nBreakStringLiterals: false\nColumnLimit: 100\nCommentPragmas: '^ IWYU pragma:'\nCompactNamespaces: false\nConstructorInitializerAllOnOneLineOrOnePerLine: false\nConstructorInitializerIndentWidth: 8\nContinuationIndentWidth: 8\nCpp11BracedListStyle: false\nDerivePointerAlignment: false\nDisableFormat: false\nExperimentalAutoDetectBinPacking: false\nFixNamespaceComments: false\n\n# Taken from:\n#   git grep -h '^#define [^[:space:]]*for_each[^[:space:]]*(' utils/ \\\n#   | sed \"s,^#define \\([^[:space:]]*for_each[^[:space:]]*\\)(.*$,  - '\\1',\" \\\n#   | LC_ALL=C sort -u\nForEachMacros:\n  - 'elf_for_each_dynamic'\n  - 'elf_for_each_dynamic_symbol'\n  - 'elf_for_each_note'\n  - 'elf_for_each_phdr'\n  - 'elf_for_each_rel'\n  - 'elf_for_each_rela'\n  - 'elf_for_each_shdr'\n  - 'elf_for_each_symbol'\n  - 'for_each_map'\n  - 'list_for_each'\n  - 'list_for_each_entry'\n  - 'list_for_each_entry_continue'\n  - 'list_for_each_entry_continue_reverse'\n  - 'list_for_each_entry_from'\n  - 'list_for_each_entry_reverse'\n  - 'list_for_each_entry_safe'\n  - 'list_for_each_entry_safe_continue'\n  - 'list_for_each_entry_safe_from'\n  - 'list_for_each_entry_safe_reverse'\n  - 'list_for_each_prev'\n  - 'list_for_each_prev_safe'\n  - 'list_for_each_safe'\n  - 'strv_for_each'\n\nIncludeBlocks: Preserve\nIncludeCategories:\n  - Regex: '.*'\n    Priority: 1\nIncludeIsMainRegex: '(Test)?$'\nIndentCaseLabels: false\nIndentGotoLabels: false\nIndentPPDirectives: None\nIndentWidth: 8\nIndentWrappedFunctionNames: false\nJavaScriptQuotes: Leave\nJavaScriptWrapImports: true\nKeepEmptyLinesAtTheStartOfBlocks: false\nMacroBlockBegin: ''\nMacroBlockEnd: ''\nMaxEmptyLinesToKeep: 1\nNamespaceIndentation: None\nObjCBinPackProtocolList: Auto\nObjCBlockIndentWidth: 8\nObjCSpaceAfterProperty: true\nObjCSpaceBeforeProtocolList: true\n\n# Taken from git's rules\nPenaltyBreakAssignment: 10\nPenaltyBreakBeforeFirstCallParameter: 30\nPenaltyBreakComment: 10\nPenaltyBreakFirstLessLess: 0\nPenaltyBreakString: 10\nPenaltyExcessCharacter: 100\nPenaltyReturnTypeOnItsOwnLine: 60\n\nPointerAlignment: Right\nReflowComments: false\nSortIncludes: true\nSortUsingDeclarations: false\nSpaceAfterCStyleCast: false\nSpaceAfterTemplateKeyword: true\nSpaceBeforeAssignmentOperators: true\nSpaceBeforeCtorInitializerColon: true\nSpaceBeforeInheritanceColon: true\nSpaceBeforeParens: ControlStatementsExceptForEachMacros\nSpaceBeforeRangeBasedForLoopColon: true\nSpaceInEmptyParentheses: false\nSpacesBeforeTrailingComments: 1\nSpacesInAngles: false\nSpacesInContainerLiterals: false\nSpacesInCStyleCastParentheses: false\nSpacesInParentheses: false\nSpacesInSquareBrackets: false\nStandard: Cpp03\nTabWidth: 8\nUseTab: Always\n...\n"
        },
        {
          "name": ".codespell_ignore",
          "type": "blob",
          "size": 0.025390625,
          "content": "pevent\ncreat\nmmaped\not\nte\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.525390625,
          "content": "*.o\n*.op\n*.ot\n*.oy\na.out\nftrace\nuftrace\nftrace.dir\nftrace.dir.old\nftrace.data\nftrace.data.old\nuftrace.data\nuftrace.data.old\n!gdb/uftrace/*.py\nlibmcount.so\nlibmcount-*.so\nlibcygprof.so\nlibcygprof-nop.so\nuftrace_python.so\ngmon.out\ntests/t-*\ntests/arch/*/t-*\ntests/*.so\ncheck-deps/*\n!check-deps/*.c\n!check-deps/Makefile*\nFLAGS\nversion.h\n.config\n.cache\n.clangd/\n.vscode\n.build/\nGPATH\nGRTAGS\nGTAGS\nTAGS\ntags\ncscope.*\ncompile_commands.json\n*.pyc\n*.sw[opn]\n*.patch\n*.orig\n*.gcda\n*.gcno\n*.cstr\nmisc/demangler\nmisc/symbols\nmisc/dbginfo\nmisc/bench\n"
        },
        {
          "name": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 0.546875,
          "content": "repos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.0.1\n    hooks:\n    -   id: check-yaml\n    -   id: end-of-file-fixer\n    -   id: trailing-whitespace\n-   repo: https://github.com/PyCQA/isort\n    rev: 5.11.5\n    hooks:\n    -   id: isort\n-   repo: https://github.com/pre-commit/mirrors-clang-format\n    rev: v14.0.6\n    hooks:\n    -   id: clang-format\n-   repo: https://github.com/codespell-project/codespell\n    rev: v2.1.0\n    hooks:\n    -   id: codespell\n        args: ['-I', '.codespell_ignore']\n        exclude: \"libtraceevent/.*\"\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 4.22265625,
          "content": "Contributing to uftrace\n=======================\n\nThanks for considering contribution to uftrace.  You can git clone the\nuftrace source on the following address and send PR with your patch.  But,\nbefore doing that, I recommend you to read this to follow the conventions.\n\n  https://github.com/namhyung/uftrace\n\n\nCoding style\n------------\nThe uftrace is written in C and mostly follows\n[Linux kernel coding style](https://www.kernel.org/doc/Documentation/process/coding-style.rst)\nwith a few differences.\n\nThe uftrace repository provides a way to automatically apply formatting\nwith the help of [pre-commit](https://pre-commit.com) and\n[clang-format](https://clang.llvm.org/docs/ClangFormat.html) so that\nour source code has a consistent coding style at all times.\n\nYou need to install pre-commit package but please note that python version 3.7\nor higher is required.  The installation can be done as follows.\n\n    $ python3 -m pip install pre-commit\n\nThen you can simply install a pre-commit hook inside the uftrace source\ndirectory as follows.\n\n    $ pre-commit install\n    pre-commit installed at .git/hooks/pre-commit\n\nAfter pre-commit installation, coding style check is done automatically\nwhenever you try to create a commit as follows.\n\n    $ git commit -s\n        ...\n    clang-format.............................................................Failed\n    - hook id: clang-format\n    - files were modified by this hook\n\nIf your change doesn't follow the coding style, then clang-format check\nfails and also modifies your code to follow the pre-configured uftrace\ncoding style, which is written at [.clang-format](.clang-format).\n\nIf the code is modified by clang-format, then please run `git add -u`\nand create a commit again to include the changes made by clang-format.\n\nYou can also run coding style check by running pre-commit manually as\nfollows.\n\n    $ git add -u\n    $ pre-commit run\n\nIt will check the coding style only for the changes in the git staging\narea and automatically reformatted if the check fails.\n\n\nInclude subject word in message header\n--------------------------------------\n\nAlthough uftrace has a small codebase, I believe it's a good convention\nto prefix your subject line with colon.  This lets me and other\ndevelopers more easily distinguish patches from other subject.\n\n    $ git log --oneline --graph\n    *   fef4226 Merge branch 'misc-fix'\n    |\\\n    | * 54a4ef0 test: Fix to be able to call runtest.py directly\n    | * 6bbe4a0 graph: Skip kernel functions outside of user\n    | * a76c7cb kernel: Use real address for filter match\n    |/\n    ...\n\n\nSigning your patch\n------------------\n\nThe sign-off is a simple line at the end of the explanation for the\npatch, which certifies that you wrote it or otherwise have the right to\npass it on as an open-source patch.  The rules are pretty simple: if you\ncan certify the below:\n\n        Developer's Certificate of Origin 1.1\n\n        By making a contribution to this project, I certify that:\n\n        (a) The contribution was created in whole or in part by me and I\n            have the right to submit it under the open source license\n            indicated in the file; or\n\n        (b) The contribution is based upon previous work that, to the best\n            of my knowledge, is covered under an appropriate open source\n            license and I have the right under that license to submit that\n            work with modifications, whether created in whole or in part\n            by me, under the same open source license (unless I am\n            permitted to submit under a different license), as indicated\n            in the file; or\n\n        (c) The contribution was provided directly to me by some other\n            person who certified (a), (b) or (c) and I have not modified\n            it.\n\n        (d) I understand and agree that this project and the contribution\n            are public and that a record of the contribution (including all\n            personal information I submit with it, including my sign-off) is\n            maintained indefinitely and may be redistributed consistent with\n            this project or the open source license(s) involved.\n\nthen you just add a line saying\n\n\tSigned-off-by: Random J Developer <random@developer.example.org>\n\nusing your real name (sorry, no pseudonyms or anonymous contributions.)\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.66796875,
          "content": "                    GNU GENERAL PUBLIC LICENSE\n                       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n                            NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "INSTALL.md",
          "type": "blob",
          "size": 8.9287109375,
          "content": "QUICK GUIDE\n===========\n\nOn Linux distros, the following commands will build and install uftrace from source.\n\n    $ sudo misc/install-deps.sh    # optional for advanced features\n    $ ./configure                  # --prefix can be used to change install dir\n    $ make\n    $ sudo make install\n\nFor more information, please see below.\n\n\nGETTING THE SOURCE\n==================\nThe latest version of uftrace is available at Github.\n\n  https://github.com/namhyung/uftrace\n\n\nDEPENDENCY\n==========\n\nThe uftrace is written in C and tried to minimize external dependencies.\nCurrently, uftrace can be built without any external libraries.  But in order to\nuse more advanced features, it'd be better to install them like below.\n\nFirstly, please make sure `pkg-config` is installed on the system to properly\ndetect the dependencies of uftrace.  Otherwise, some packages may not be\ndetected even if they are already installed, causing some features of\nuftrace to be disabled.\n\nHistorically, uftrace depended on the `libelf` from elfutils project for ELF\nfile manipulation.  While it's not mandatory anymore, we recommend you to\ninstall it for better handling of ELF binaries.  Also `libdw` library is\nrecommended to be installed in order to process DWARF debug information.  The\nlibdw itself depends on the `libelf`, so you can just install `libdw`.\n\nOn debian based systems (like Ubuntu), `libdw-dev` package will provide the\nrequired libraries/files.\n\n    $ sudo apt-get install libdw-dev\n\nOn redhat based systems (like Fedora, RHEL), it'll be `elfutils-devel`.\n\n    $ sudo dnf install elfutils-devel\n\nuftrace also uses libstdc++ library to demangle C++ symbols in full detail.\nBut it's not mandatory as uftrace has its own demangler for shorter symbol\nname (it omits arguments, templates and so on).\n\nThe ncursesw library is used to implement text user interface (TUI) on console.\nThe ncurses(w) library provides terminal handling routines which `uftrace tui`\ncommand is built on top of.  As it improves user experience of trace data\nanalysis, you should consider installing it if you do things like `uftrace graph`\nor `uftrace report` frequently.\n\nAlso uftrace needs `pandoc` to build man pages from the markdown document.\n\n\nBUILD\n=====\n\nTo build uftrace, you need to install basic software development tools first -\nlike gcc and make.  And you also need to install dependent packages. Please\nsee DEPENDENCY section for more details.\n\nOnce you have installed the required software(s), you need to run `configure` to set\nthe install directory and other features.  It installs the uftrace under /usr/local\nby default. If you want install it to some other location, you can set the `prefix`\nvariable (see below).\n\n    $ ./configure --prefix=/usr\n\nIt will show the prefix directory and detected features like:\n\n    uftrace detected system features:\n    ...         prefix: /usr\n    ...         libelf: [ on  ] - more flexible ELF data handling\n    ...          libdw: [ on  ] - DWARF debug info support\n    ...      libpython: [ on  ] - python scripting support\n    ...      libluajit: [ OFF ] - luajit scripting support\n    ...    libncursesw: [ on  ] - TUI support\n    ...   cxa_demangle: [ on  ] - full demangler support with libstdc++\n    ...     perf_event: [ on  ] - perf (PMU) event support\n    ...       schedule: [ on  ] - scheduler event support\n    ...       capstone: [ on  ] - full dynamic tracing support\n    ...      libunwind: [ OFF ] - stacktrace support (optional for debugging)\n\nThen you can run `make` to build the source.\n\n    $ make\n\nIt builds uftrace, placing the resulting binaries in the current directory.\nThis is good for testing, but you'll want to install it for normal use.\n\n    $ sudo make install\n\nThe output of the build looks like linux kernel style, and users can see the original\nbuild command lines with V=1 (like kernel).\n\n    $ make V=1\n\n\nCONFIGURATION\n=============\n\nThe uftrace implements its own version of configure script to save user\npreferences.  The config file (named `.config`) is created, if it doesn't exist,\nat build time with default options.  User can set custom installation\ndirectories or build directory with this script.\n\n    $ ./configure --help\n    Usage: ./configure [<options>]\n\n      --help                print this message\n      --prefix=<DIR>        set install root dir as <DIR>        (default: /usr/local)\n      --bindir=<DIR>        set executable install dir as <DIR>  (default: ${prefix}/bin)\n      --libdir=<DIR>        set library install dir as <DIR>     (default: ${prefix}/lib/uftrace)\n      --mandir=<DIR>        set manual doc install dir as <DIR>  (default: ${prefix}/share/man)\n      --objdir=<DIR>        set build dir as <DIR>               (default: ${PWD})\n      --sysconfdir=<DIR>    override the etc dir as <DIR>\n\n      --with-elfutils=<DIR> search for elfutils in <DIR>/include and <DIR>/lib\n\n      --without-libelf      build without libelf (and libdw)     (even if found on the system)\n      --without-libdw       build without libdw                  (even if found on the system)\n      --without-libstdc++   build without libstdc++              (even if found on the system)\n      --without-libpython   build without libpython              (even if found on the system)\n      --without-libluajit   build without libluajit              (even if found on the system)\n      --without-libncurses  build without libncursesw            (even if found on the system)\n      --without-capstone    build without libcapstone            (even if found on the system)\n      --without-perf        build without perf event             (even if available)\n      --without-schedule    build without scheduler event        (even if available)\n\n      --arch=<ARCH>         set target architecture              (default: system default arch)\n                            e.g. x86_64, aarch64, i386, or arm\n      --cross-compile=<CROSS_COMPILE>\n                            Specify the compiler prefix during compilation\n                            e.g. CC is overridden by $(CROSS_COMPILE)gcc\n      --cflags=<CFLAGS>     pass extra C compiler flags\n      --ldflags=<LDFLAGS>   pass extra linker flags\n\n      -p                    preserve old setting\n\n      Some influential environment variables:\n        ARCH                Target architecture    e.g. x86_64, aarch64, i386, or arm\n        CROSS_COMPILE       Specify the compiler prefix during compilation\n                            e.g. CC is overridden by $(CROSS_COMPILE)gcc\n        CFLAGS              C compiler flags\n        LDFLAGS             linker flags\n\nAlso you can set the target architecture and compiler options like CC, CFLAGS.\n\nIt's also possible to disable some features that depend on external libraries or\nsystem behaviors.  For example --without-libpython option will disable scripting\nfeature - `uftrace script` command will still exist but won't work.\n\nFor cross compilation, you may want to setup the toolchain to something like below:\n\n    $ export CROSS_COMPILE=/path/to/cross/toolchain/arm-unknown-linux-gnueabihf-\n    $ ARCH=arm CFLAGS='--sysroot /path/to/sysroot' ./configure\n        or\n    $ ./configure --arch=arm --cflags='--sysroot /path/to/sysroot' \\\n          --cross-compile=/path/to/cross/toolchain/arm-unknown-linux-gnueabihf-\n\nThis assumes you already installed the cross-built `libelf` on the sysroot\ndirectory.  Otherwise, you can also build it from source (please see below) or\nuse it on a different path using `--with-elfutils=<PATH>`.\n\nTo compile for Android 9+, export the CC environment variable and disable the not\nyet implemented python and libstdc++ support. E.g. to configure for Android\nAArch64 do\n\n    $ export CC=$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android33-clang\n    $ export LD=$NDK/toolchains/llvm/prebuilt/linux-x86_64/bin/ld.lld\n    $ ./configure --arch=aarch64 --cross-compile=aarch64-linux-gnu- --without-libpython --without-libstdc++\n\nIt's recommended to compile instrumented program with\n`-fpatchable-function-entry` on Android. You could also use\n`-finstrument-functions` or `-pg` but in that case you also need to link program\nwith `-Wl,-z,undefs` because Android runtime does not include\n`__cyg_profile_func_enter` or `mcount`.\n\nNote that Android has been tested on AArch64 and x86\\_64 so far.\n\n\nBUILD WITH ELFUTILS (libelf)\n============================\n\nIt may be useful to manually compile libelf/libdw for uftrace build if the\ntarget system doesn't have them installed.  `misc/install-elfutils.sh` provides\na way to download and build libelf and libdw, which are libraries in elfutils.\n\nThe below is the way to compile uftrace together with libelf/libdw.\n\n    $ export CROSS_COMPILE=arm-linux-gnueabi-\n    $ export ARCH=arm\n    $ export CFLAGS=\"-march=armv7-a\"\n    $ ./misc/install-elfutils.sh --prefix=/path/to/install\n    $ ./configure --prefix=/path/to/install --with-elfutils=/path/to/install\n\n    $ make\n    $ make install\n\n`misc/install-elfutils.sh` downloads and builds elfutils and installs both\nlibelf and libdw to prefix directory.  The installed libelf and libdw can be\nfound using `--with-elfutils` in the `configure` script.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 19.6083984375,
          "content": "VERSION := 0.17\n\n# Makefiles suck: This macro sets a default value of $(2) for the\n# variable named by $(1), unless the variable has been set by\n# environment or command line. This is necessary for CC and AR\n# because make sets default values, so the simpler ?= approach\n# won't work as expected.\ndefine allow-override\n  $(if $(or $(findstring environment,$(origin $(1))),\\\n            $(findstring command line,$(origin $(1)))),,\\\n    $(eval $(1) = $(2)))\nendef\n\n# Allow setting CC and AR and LD, or setting CROSS_COMPILE as a prefix.\n$(call allow-override,CC,$(CROSS_COMPILE)gcc)\n$(call allow-override,AR,$(CROSS_COMPILE)ar)\n$(call allow-override,LD,$(CROSS_COMPILE)ld)\n\nuname_M := $(shell uname -m 2>/dev/null || echo not)\n\nARCH ?= $(shell echo $(uname_M) | sed -e s/i.86/i386/ -e s/arm.*/arm/ )\nifneq ($(findstring x86,$(ARCH)),)\n  ifneq ($(findstring m32,$(CC) $(CFLAGS)),)\n    override ARCH := i386\n  endif\nendif\n\nprefix ?= /usr/local\nbindir = $(prefix)/bin\nlibdir = $(prefix)/lib/uftrace\netcdir = $(prefix)/etc\nmandir = $(prefix)/share/man\ndocdir = $(srcdir)/doc\ncompletiondir = $(etcdir)/bash_completion.d\n\nifeq ($(DOCLANG), ko)\n  docdir = $(srcdir)/doc/ko\nendif\n\nsrcdir = $(CURDIR)\n# set objdir to $(O) by default (if any)\nifeq ($(objdir),)\n    ifneq ($(O),)\n        objdir = $(O)\n    else\n        objdir = $(CURDIR)\n    endif\nendif\n\nifneq ($(wildcard $(objdir)/.config),)\n  include $(objdir)/.config\nendif\n\nRM = rm -f\nINSTALL = install\n\nexport ARCH CC AR LD RM srcdir objdir LDFLAGS\n\nCOMMON_CFLAGS := -std=gnu11 -D_GNU_SOURCE $(CFLAGS) $(CPPFLAGS)\nCOMMON_CFLAGS += -iquote $(srcdir) -iquote $(objdir) -iquote $(srcdir)/arch/$(ARCH)\nCOMMON_CFLAGS += -W -Wall -Wno-unused-parameter -Wno-missing-field-initializers\nCOMMON_CFLAGS += -Wdeclaration-after-statement -Wstrict-prototypes\n\nCOMMON_LDFLAGS := -ldl -pthread -Wl,-z,noexecstack $(LDFLAGS)\nifeq ($(ANDROID),)\nCOMMON_LDFLAGS += -lrt\nelse\nCOMMON_LDFLAGS += -landroid\nendif\n\nifneq ($(elfdir),)\n  COMMON_CFLAGS  += -I$(elfdir)/include\n  COMMON_LDFLAGS += -L$(elfdir)/lib\nendif\n\nC_STR_TARGET = utils/mermaid.js utils/mermaid.html\nC_STR_EXTENSION = cstr\nC_STR_OBJS := $(patsubst %,$(objdir)/%.$(C_STR_EXTENSION),$(C_STR_TARGET))\n\n#\n# Note that the plain CFLAGS and LDFLAGS can be changed\n# by config/Makefile later but *_*FLAGS can not.\n#\nUFTRACE_CFLAGS     = $(COMMON_CFLAGS) $(CFLAGS_$@) $(CFLAGS_uftrace)\nDEMANGLER_CFLAGS   = $(COMMON_CFLAGS) $(CFLAGS_$@) $(CFLAGS_demangler)\nSYMBOLS_CFLAGS     = $(COMMON_CFLAGS) $(CFLAGS_$@) $(CFLAGS_symbols)\nDBGINFO_CFLAGS     = $(COMMON_CFLAGS) $(CFLAGS_$@) $(CFLAGS_dbginfo)\nBENCH_CFLAGS       = -D_GNU_SOURCE -g -pg $(CFLAGS_$@) $(CFLAGS_bench)\nTRACEEVENT_CFLAGS  = $(COMMON_CFLAGS) $(CFLAGS_$@) $(CFLAGS_traceevent)\nLIB_CFLAGS         = $(COMMON_CFLAGS) $(CFLAGS_$@) $(CFLAGS_lib)\nLIB_CFLAGS        += -fPIC -fvisibility=hidden -fno-omit-frame-pointer\nLIB_CFLAGS        += -fno-builtin -fno-tree-vectorize -DLIBMCOUNT\nTEST_CFLAGS        = $(COMMON_CFLAGS) -DUNIT_TEST\nPYTHON_CFLAGS      = $(COMMON_CFLAGS) -fPIC\n\nUFTRACE_LDFLAGS    = $(COMMON_LDFLAGS) $(LDFLAGS_$@) $(LDFLAGS_uftrace) -lm\nDEMANGLER_LDFLAGS  = $(COMMON_LDFLAGS) $(LDFLAGS_$@) $(LDFLAGS_demangler)\nSYMBOLS_LDFLAGS    = $(COMMON_LDFLAGS) $(LDFLAGS_$@) $(LDFLAGS_symbols)\nDBGINFO_LDFLAGS    = $(COMMON_LDFLAGS) $(LDFLAGS_$@) $(LDFLAGS_dbginfo)\nBENCH_LDFLAGS      = -Wl,-z,noexecstack $(LDFLAGS_$@) $(LDFLAGS_bench)\nLIB_LDFLAGS        = $(COMMON_LDFLAGS) $(LDFLAGS_$@) $(LDFLAGS_lib) -Wl,--no-undefined\nTEST_LDFLAGS       = $(COMMON_LDFLAGS) -lm\n\n_DEFAULT_SANITIZERS := address,leak\nifeq ($(ARCH), riscv64)\n  DEFAULT_SANITIZERS = $(_DEFAULT_SANITIZERS)\nelse\n  DEFAULT_SANITIZERS = $(_DEFAULT_SANITIZERS),undefined\nendif\n\nifeq ($(DEBUG), 1)\n  COMMON_CFLAGS += -O0 -g3 -DDEBUG_MODE=1 -Werror\nelse\n  COMMON_CFLAGS += -O2 -g -DDEBUG_MODE=0\nendif\n\nifeq ($(TRACE), 1)\n  TRACE_CFLAGS      := -pg -fno-omit-frame-pointer\n  UFTRACE_CFLAGS    += $(TRACE_CFLAGS)\n  DEMANGLER_CFLAGS  += $(TRACE_CFLAGS)\n  SYMBOLS_CFLAGS    += $(TRACE_CFLAGS)\n  DBGINFO_CFLAGS    += $(TRACE_CFLAGS)\n  TRACEEVENT_CFLAGS += $(TRACE_CFLAGS)\n  TEST_CFLAGS       += $(TRACE_CFLAGS)\n  # cannot add -pg to LIB_CFLAGS because mcount() is not reentrant\nendif\n\nifeq ($(COVERAGE), 1)\n  COVERAGE_CFLAGS := -O0 -g --coverage -U_FORTIFY_SOURCE\n  COMMON_CFLAGS   += $(COVERAGE_CFLAGS)\n  LIB_CFLAGS      += $(COVERAGE_CFLAGS)\n  TEST_CFLAGS     += $(COVERAGE_CFLAGS)\n\n  LIB_LDFLAGS   += --coverage\nendif\n\nifeq ($(ASAN), 1)\n  ASAN_CFLAGS       := -O0 -g -fsanitize=$(DEFAULT_SANITIZERS)\n  UFTRACE_CFLAGS    += $(ASAN_CFLAGS)\n  DEMANGLER_CFLAGS  += $(ASAN_CFLAGS)\n  SYMBOLS_CFLAGS    += $(ASAN_CFLAGS)\n  DBGINFO_CFLAGS    += $(ASAN_CFLAGS)\n  TRACEEVENT_CFLAGS += $(ASAN_CFLAGS)\n  TEST_CFLAGS       += $(ASAN_CFLAGS)\nendif\n\nifneq ($(SAN),)\n  ifeq ($(SAN), all)\n    SAN_CFLAGS := -O0 -g -fsanitize=$(DEFAULT_SANITIZERS)\n  else\n    SAN_CFLAGS := -O0 -g -fsanitize=$(SAN)\n  endif\n  UFTRACE_CFLAGS    += $(SAN_CFLAGS)\n  DEMANGLER_CFLAGS  += $(SAN_CFLAGS)\n  SYMBOLS_CFLAGS    += $(SAN_CFLAGS)\n  DBGINFO_CFLAGS    += $(SAN_CFLAGS)\n  TRACEEVENT_CFLAGS += $(SAN_CFLAGS)\n  TEST_CFLAGS       += $(SAN_CFLAGS)\nendif\n\nexport UFTRACE_CFLAGS LIB_CFLAGS TEST_CFLAGS TEST_LDFLAGS\n\nVERSION_GIT := $(shell git describe --tags 2> /dev/null || echo v$(VERSION))\n\nall:\n\nifneq ($(wildcard $(objdir)/check-deps/check-tstamp),)\n  include $(srcdir)/check-deps/Makefile.check\nendif\n\ninclude $(srcdir)/Makefile.include\n\n\nLIBMCOUNT_TARGETS := libmcount/libmcount.so libmcount/libmcount-fast.so\nLIBMCOUNT_TARGETS += libmcount/libmcount-single.so libmcount/libmcount-fast-single.so\n\n_TARGETS := uftrace python/uftrace_python.so\n_TARGETS += $(LIBMCOUNT_TARGETS) libmcount/libmcount-nop.so\n_TARGETS += misc/demangler misc/symbols misc/dbginfo\nTARGETS  := $(patsubst %,$(objdir)/%,$(_TARGETS))\n\nUFTRACE_SRCS := $(srcdir)/uftrace.c $(wildcard $(srcdir)/cmds/*.c $(srcdir)/utils/*.c)\nUFTRACE_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.o,$(UFTRACE_SRCS))\n\nUFTRACE_OBJS_VERSION := $(objdir)/cmds/script.o $(objdir)/cmds/tui.o\nUFTRACE_OBJS_VERSION += $(objdir)/cmds/dump.o $(objdir)/cmds/info.o\n\nDEMANGLER_SRCS := $(srcdir)/misc/demangler.c $(srcdir)/utils/demangle.c\nDEMANGLER_SRCS += $(srcdir)/utils/debug.c $(srcdir)/utils/utils.c\nDEMANGLER_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.o,$(DEMANGLER_SRCS))\n\nSYMBOLS_SRCS := $(srcdir)/misc/symbols.c $(srcdir)/utils/session.c\nSYMBOLS_SRCS += $(srcdir)/utils/demangle.c $(srcdir)/utils/rbtree.c\nSYMBOLS_SRCS += $(srcdir)/utils/utils.c $(srcdir)/utils/debug.c\nSYMBOLS_SRCS += $(srcdir)/utils/filter.c $(srcdir)/utils/dwarf.c\nSYMBOLS_SRCS += $(srcdir)/utils/auto-args.c $(srcdir)/utils/regs.c\nSYMBOLS_SRCS += $(srcdir)/utils/argspec.c\nSYMBOLS_SRCS += $(wildcard $(srcdir)/utils/symbol*.c)\nSYMBOLS_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.o,$(SYMBOLS_SRCS))\n\nDBGINFO_SRCS := $(srcdir)/misc/dbginfo.c $(srcdir)/utils/dwarf.c\nDBGINFO_SRCS += $(srcdir)/utils/auto-args.c $(srcdir)/utils/regs.c\nDBGINFO_SRCS += $(srcdir)/utils/utils.c $(srcdir)/utils/debug.c\nDBGINFO_SRCS += $(srcdir)/utils/argspec.c $(srcdir)/utils/rbtree.c\nDBGINFO_SRCS += $(srcdir)/utils/demangle.c $(srcdir)/utils/filter.c\nDBGINFO_SRCS += $(wildcard $(srcdir)/utils/symbol*.c)\nDBGINFO_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.o,$(DBGINFO_SRCS))\n\nBENCH_SRCS := $(srcdir)/misc/bench.c\nBENCH_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.o,$(BENCH_SRCS))\n\nPYTHON_SRCS := $(srcdir)/python/trace-python.c $(srcdir)/utils/debug.c\nPYTHON_SRCS += $(srcdir)/utils/utils.c $(srcdir)/utils/rbtree.c $(srcdir)/utils/shmem.c\nPYTHON_SRCS += $(wildcard $(srcdir)/utils/symbol-*.c)\nPYTHON_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.oy,$(PYTHON_SRCS))\n\nUFTRACE_ARCH_OBJS := $(objdir)/arch/$(ARCH)/uftrace.o\n\nUFTRACE_HDRS := $(filter-out $(srcdir)/version.h,$(wildcard $(srcdir)/*.h $(srcdir)/utils/*.h))\nUFTRACE_HDRS += $(srcdir)/libmcount/mcount.h $(wildcard $(srcdir)/arch/$(ARCH)/*.h)\n\nLIBMCOUNT_SRCS := $(filter-out %-nop.c,$(wildcard $(srcdir)/libmcount/*.c))\nLIBMCOUNT_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.op,$(LIBMCOUNT_SRCS))\nLIBMCOUNT_FAST_OBJS := $(patsubst $(objdir)/%.op,$(objdir)/%-fast.op,$(LIBMCOUNT_OBJS))\nLIBMCOUNT_SINGLE_OBJS := $(patsubst $(objdir)/%.op,$(objdir)/%-single.op,$(LIBMCOUNT_OBJS))\nLIBMCOUNT_FAST_SINGLE_OBJS := $(patsubst $(objdir)/%.op,$(objdir)/%-fast-single.op,$(LIBMCOUNT_OBJS))\n\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/debug.c $(srcdir)/utils/regs.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/rbtree.c $(srcdir)/utils/filter.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/demangle.c $(srcdir)/utils/utils.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/script.c $(srcdir)/utils/script-python.c $(srcdir)/utils/script-luajit.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/auto-args.c $(srcdir)/utils/dwarf.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/hashmap.c $(srcdir)/utils/argspec.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/tracefs.c $(srcdir)/utils/socket.c\nLIBMCOUNT_UTILS_SRCS += $(srcdir)/utils/shmem.c\nLIBMCOUNT_UTILS_SRCS += $(wildcard $(srcdir)/utils/symbol*.c)\nLIBMCOUNT_UTILS_OBJS := $(patsubst $(srcdir)/utils/%.c,$(objdir)/libmcount/%.op,$(LIBMCOUNT_UTILS_SRCS))\n\nLIBMCOUNT_NOP_SRCS := $(srcdir)/libmcount/mcount-nop.c\nLIBMCOUNT_NOP_OBJS := $(patsubst $(srcdir)/%.c,$(objdir)/%.op,$(LIBMCOUNT_NOP_SRCS))\n\nLIBMCOUNT_ARCH_OBJS := $(objdir)/arch/$(ARCH)/mcount-entry.op\n\nCOMMON_DEPS := $(objdir)/.config $(UFTRACE_HDRS)\nLIBMCOUNT_DEPS := $(COMMON_DEPS) $(srcdir)/libmcount/internal.h\n\nCFLAGS_$(objdir)/mcount.op = -pthread\nCFLAGS_$(objdir)/cmds/record.o = -DINSTALL_LIB_PATH='\"$(libdir)\"'\nCFLAGS_$(objdir)/cmds/live.o = -DINSTALL_LIB_PATH='\"$(libdir)\"'\n\nLIBMCOUNT_FAST_CFLAGS := -DDISABLE_MCOUNT_FILTER\nLIBMCOUNT_SINGLE_CFLAGS := -DSINGLE_THREAD\nLIBMCOUNT_FAST_SINGLE_CFLAGS := -DDISABLE_MCOUNT_FILTER -DSINGLE_THREAD\n\nCFLAGS_$(objdir)/utils/demangle.o  = -Wno-unused-value\nCFLAGS_$(objdir)/utils/demangle.op = -Wno-unused-value\n\nMAKEFLAGS += --no-print-directory\n\n\nall: $(objdir)/.config $(TARGETS)\n\n$(objdir)/.config: $(srcdir)/configure $(srcdir)/check-deps/Makefile\n\t$(error Please run 'configure' first)\n\nconfig: $(srcdir)/configure\n\t$(QUIET_GEN)$(srcdir)/configure --objdir=$(objdir) $(MAKEOVERRIDES)\n\n$(LIBMCOUNT_UTILS_OBJS): $(objdir)/libmcount/%.op: $(srcdir)/utils/%.c $(LIBMCOUNT_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(LIB_CFLAGS) -c -o $@ $<\n\n$(objdir)/libmcount/mcount.op: $(objdir)/version.h\n\n$(LIBMCOUNT_OBJS): $(objdir)/%.op: $(srcdir)/%.c $(LIBMCOUNT_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(LIB_CFLAGS) -c -o $@ $<\n\n$(LIBMCOUNT_FAST_OBJS): $(objdir)/%-fast.op: $(srcdir)/%.c $(LIBMCOUNT_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(LIB_CFLAGS) $(LIBMCOUNT_FAST_CFLAGS) -c -o $@ $<\n\n$(LIBMCOUNT_SINGLE_OBJS): $(objdir)/%-single.op: $(srcdir)/%.c $(LIBMCOUNT_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(LIB_CFLAGS) $(LIBMCOUNT_SINGLE_CFLAGS) -c -o $@ $<\n\n$(LIBMCOUNT_FAST_SINGLE_OBJS): $(objdir)/%-fast-single.op: $(srcdir)/%.c $(LIBMCOUNT_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(LIB_CFLAGS) $(LIBMCOUNT_FAST_SINGLE_CFLAGS) -c -o $@ $<\n\n$(LIBMCOUNT_NOP_OBJS): $(objdir)/%.op: $(srcdir)/%.c $(LIBMCOUNT_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(LIB_CFLAGS) -c -o $@ $<\n\n$(objdir)/libmcount/libmcount.so: $(LIBMCOUNT_OBJS) $(LIBMCOUNT_UTILS_OBJS) $(LIBMCOUNT_ARCH_OBJS)\n\t$(QUIET_LINK)$(CC) -shared -o $@ $^ $(LIB_LDFLAGS)\n\n$(objdir)/libmcount/libmcount-fast.so: $(LIBMCOUNT_FAST_OBJS) $(LIBMCOUNT_UTILS_OBJS) $(LIBMCOUNT_ARCH_OBJS)\n\t$(QUIET_LINK)$(CC) -shared -o $@ $^ $(LIB_LDFLAGS)\n\n$(objdir)/libmcount/libmcount-single.so: $(LIBMCOUNT_SINGLE_OBJS) $(LIBMCOUNT_UTILS_OBJS) $(LIBMCOUNT_ARCH_OBJS)\n\t$(QUIET_LINK)$(CC) -shared -o $@ $^ $(LIB_LDFLAGS)\n\n$(objdir)/libmcount/libmcount-fast-single.so: $(LIBMCOUNT_FAST_SINGLE_OBJS) $(LIBMCOUNT_UTILS_OBJS) $(LIBMCOUNT_ARCH_OBJS)\n\t$(QUIET_LINK)$(CC) -shared -o $@ $^ $(LIB_LDFLAGS)\n\n$(objdir)/libmcount/libmcount-nop.so: $(LIBMCOUNT_NOP_OBJS)\n\t$(QUIET_LINK)$(CC) -shared -o $@ $^ $(LIB_LDFLAGS)\n\n$(LIBMCOUNT_ARCH_OBJS): $(wildcard $(srcdir)/arch/$(ARCH)/*.[cS]) $(LIBMCOUNT_DEPS)\n\t@$(MAKE) -B -C $(srcdir)/arch/$(ARCH) $@\n\n$(UFTRACE_ARCH_OBJS): $(wildcard $(srcdir)/arch/$(ARCH)/*.[cS]) $(COMMON_DEPS)\n\t@$(MAKE) -B -C $(srcdir)/arch/$(ARCH) $@\n\n$(objdir)/uftrace.o: $(srcdir)/uftrace.c $(objdir)/version.h $(COMMON_DEPS)\n\t$(QUIET_CC)$(CC) $(UFTRACE_CFLAGS) -c -o $@ $<\n\n$(objdir)/misc/demangler.o: $(srcdir)/misc/demangler.c $(objdir)/version.h $(COMMON_DEPS)\n\t$(QUIET_CC)$(CC) $(DEMANGLER_CFLAGS) -c -o $@ $<\n\n$(objdir)/misc/symbols.o: $(srcdir)/misc/symbols.c $(objdir)/version.h $(COMMON_DEPS)\n\t$(QUIET_CC)$(CC) $(SYMBOLS_CFLAGS) -c -o $@ $<\n\n$(objdir)/misc/dbginfo.o: $(srcdir)/misc/dbginfo.c $(objdir)/version.h $(COMMON_DEPS)\n\t$(QUIET_CC)$(CC) $(DBGINFO_CFLAGS) -c -o $@ $<\n\n$(objdir)/misc/bench.o: $(srcdir)/misc/bench.c\n\t$(QUIET_CC)$(CC) $(BENCH_CFLAGS) -c -o $@ $<\n\n$(objdir)/cmds/dump.o: $(C_STR_OBJS)\n\n$(UFTRACE_OBJS_VERSION): $(objdir)/version.h\n\n$(filter-out $(objdir)/uftrace.o, $(UFTRACE_OBJS)): $(objdir)/%.o: $(srcdir)/%.c $(COMMON_DEPS)\n\t$(QUIET_CC)$(CC) $(UFTRACE_CFLAGS) -c -o $@ $<\n\n$(objdir)/version.h: PHONY\n\t@$(srcdir)/misc/version.sh $@ $(VERSION_GIT) $(ARCH) $(objdir)\n\n$(srcdir)/utils/auto-args.h: $(srcdir)/misc/prototypes.h $(srcdir)/misc/gen-autoargs.py\n\t$(QUIET_GEN)$(srcdir)/misc/gen-autoargs.py -i $< -o $@\n\n$(objdir)/uftrace: $(UFTRACE_OBJS) $(UFTRACE_ARCH_OBJS)\n\t$(QUIET_LINK)$(CC) $(UFTRACE_CFLAGS) -o $@ $(UFTRACE_OBJS) $(UFTRACE_ARCH_OBJS) $(UFTRACE_LDFLAGS)\n\n$(objdir)/misc/demangler: $(DEMANGLER_OBJS)\n\t$(QUIET_LINK)$(CC) $(DEMANGLER_CFLAGS) -o $@ $(DEMANGLER_OBJS) $(DEMANGLER_LDFLAGS)\n\n$(objdir)/misc/symbols: $(SYMBOLS_OBJS)\n\t$(QUIET_LINK)$(CC) $(SYMBOLS_CFLAGS) -o $@ $(SYMBOLS_OBJS) $(SYMBOLS_LDFLAGS)\n\n$(objdir)/misc/dbginfo: $(DBGINFO_OBJS)\n\t$(QUIET_LINK)$(CC) $(DBGINFO_CFLAGS) -o $@ $(DBGINFO_OBJS) $(DBGINFO_LDFLAGS)\n\n$(objdir)/misc/bench: $(BENCH_OBJS)\n\t$(QUIET_LINK)$(CC) $(BENCH_CFLAGS) -o $@ $(BENCH_OBJS) $(BENCH_LDFLAGS)\n\nifneq ($(findstring HAVE_LIBPYTHON, $(COMMON_CFLAGS)), )\n# Remove libelf/libdw dependency for the python extension\nPYTHON_CFLAGS := $(filter-out -DHAVE_LIBELF,$(PYTHON_CFLAGS))\n\n$(PYTHON_OBJS): $(objdir)/%.oy: $(srcdir)/%.c $(COMMON_DEPS)\n\t$(QUIET_CC_FPIC)$(CC) $(PYTHON_CFLAGS) -c -o $@ $<\n\n$(objdir)/python/uftrace_python.so: $(PYTHON_OBJS)\n\t$(QUIET_LINK)$(CC) -shared $(PYTHON_CFLAGS) -o $@ $(PYTHON_OBJS) $(PYTHON_LDFLAGS)\nelse\n$(objdir)/python/uftrace_python.so:\nendif\n\ninstall: all\n\t$(Q)$(INSTALL) -d -m 755 $(DESTDIR)$(bindir)\n\t$(Q)$(INSTALL) -d -m 755 $(DESTDIR)$(libdir)\n\t$(Q)$(INSTALL) -d -m 755 $(DESTDIR)$(completiondir)\nifneq ($(wildcard $(elfdir)/lib/libelf.so),)\nifeq ($(wildcard $(prefix)/lib/libelf.so),)\n\t# install libelf only when it's not in the install directory.\n\t$(call QUIET_INSTALL, libelf)\n\t$(Q)$(INSTALL) $(elfdir)/lib/libelf.so   $(DESTDIR)$(libdir)/libelf.so\nendif\nendif\n\t$(call QUIET_INSTALL, uftrace)\n\t$(Q)$(INSTALL) $(objdir)/uftrace         $(DESTDIR)$(bindir)/uftrace\n\t$(call QUIET_INSTALL, libmcount)\n\t$(Q)$(INSTALL) $(objdir)/libmcount/libmcount.so   $(DESTDIR)$(libdir)/libmcount.so\n\t$(Q)$(INSTALL) $(objdir)/libmcount/libmcount-nop.so $(DESTDIR)$(libdir)/libmcount-nop.so\n\t$(Q)$(INSTALL) $(objdir)/libmcount/libmcount-fast.so $(DESTDIR)$(libdir)/libmcount-fast.so\n\t$(Q)$(INSTALL) $(objdir)/libmcount/libmcount-single.so $(DESTDIR)$(libdir)/libmcount-single.so\n\t$(Q)$(INSTALL) $(objdir)/libmcount/libmcount-fast-single.so $(DESTDIR)$(libdir)/libmcount-fast-single.so\nifneq ($(findstring HAVE_LIBPYTHON, $(COMMON_CFLAGS)), )\n\t$(call QUIET_INSTALL, uftrace-python)\n\t$(Q)$(INSTALL) $(srcdir)/python/uftrace.py  $(DESTDIR)$(libdir)/uftrace.py\n\t$(Q)$(INSTALL) $(objdir)/python/uftrace_python.so  $(DESTDIR)$(libdir)/uftrace_python.so\nendif\n\t$(call QUIET_INSTALL, bash-completion)\n\t$(Q)$(INSTALL) -m 644 $(srcdir)/misc/bash-completion.sh $(DESTDIR)$(completiondir)/uftrace\n\t@$(MAKE) -sC $(docdir) install DESTDIR=$(DESTDIR)$(mandir)\n\t@if [ `id -u` = 0 ]; then ldconfig $(DESTDIR)$(libdir) || echo \"ldconfig failed\"; fi\n\nuninstall:\n\t$(call QUIET_UNINSTALL, uftrace)\n\t$(Q)$(RM) $(DESTDIR)$(bindir)/uftrace\n\t$(call QUIET_UNINSTALL, libmcount)\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/libmcount.so\n\t$(call QUIET_UNINSTALL, libmcount-nop)\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/libmcount-nop.so\n\t$(call QUIET_UNINSTALL, libmcount-fast)\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/libmcount-fast.so\n\t$(call QUIET_UNINSTALL, libmcount-single)\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/libmcount-single.so\n\t$(call QUIET_UNINSTALL, libmcount-fast-single)\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/libmcount-fast-single.so\nifneq ($(findstring HAVE_LIBPYTHON, $(COMMON_CFLAGS)), )\n\t$(call QUIET_UNINSTALL, uftrace-python)\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/uftrace.py\n\t$(Q)$(RM) $(DESTDIR)$(libdir)/uftrace_python.so\nendif\n\t$(call QUIET_UNINSTALL, bash-completion)\n\t$(Q)$(RM) $(DESTDIR)$(completiondir)/uftrace\n\t@$(MAKE) -sC $(docdir) uninstall DESTDIR=$(DESTDIR)$(mandir)\n\ntest: all\n\t@$(MAKE) -C $(srcdir)/tests TESTARG=\"$(TESTARG)\" UNITTESTARG=\"$(UNITTESTARG)\" RUNTESTARG=\"$(RUNTESTARG)\" PYTESTARG=\"$(PYTESTARG)\" test\n\nunittest: all\n\t@$(MAKE) -C $(srcdir)/tests TESTARG=\"$(TESTARG)\" UNITTESTARG=\"$(UNITTESTARG)\" test_unit\n\nruntest: all\n\t@$(MAKE) -C $(srcdir)/tests TESTARG=\"$(TESTARG)\" RUNTESTARG=\"$(RUNTESTARG)\" test_run\n\npytest: all\n\t@$(MAKE) -C $(srcdir)/tests TESTARG=\"$(TESTARG)\" PYTESTARG=\"$(PYTESTARG)\" test_python\n\nbench: all $(objdir)/misc/bench\n\t@cd $(srcdir)/misc && echo && ./bench.sh $(BENCHARG)\n\ndist:\n\t@git archive --prefix=uftrace-$(VERSION)/ $(VERSION_GIT) -o $(objdir)/uftrace-$(VERSION).tar\n\t@tar rf $(objdir)/uftrace-$(VERSION).tar --transform=\"s|^|uftrace-$(VERSION)/|\" $(objdir)/version.h\n\t@gzip $(objdir)/uftrace-$(VERSION).tar\n\ndoc:\n\t@$(MAKE) -C $(docdir)\n\nclean:\n\t$(call QUIET_CLEAN, uftrace)\n\t$(Q)$(RM) $(objdir)/*.o $(objdir)/*.op $(objdir)/*.so $(objdir)/*.a\n\t$(Q)$(RM) $(objdir)/cmds/*.o $(objdir)/utils/*.o $(objdir)/misc/*.o\n\t$(Q)$(RM) $(objdir)/utils/*.op $(objdir)/libmcount/*.op\n\t$(Q)$(RM) $(objdir)/utils/*.oy $(objdir)/python/*.oy\n\t$(Q)$(RM) $(objdir)/gmon.out $(srcdir)/scripts/*.pyc $(TARGETS)\n\t$(Q)$(RM) $(objdir)/uftrace-*.tar.gz $(objdir)/version.h\n\t$(Q)find -name \"*\\.gcda\" -o -name \"*\\.gcno\" | xargs $(RM)\n\t$(Q)$(RM) coverage.info $(C_STR_OBJS)\n\t@$(MAKE) -sC $(srcdir)/arch/$(ARCH) clean\n\t@$(MAKE) -sC $(srcdir)/tests ARCH=$(ARCH) clean\n\t@$(MAKE) -sC $(docdir) clean\n\nreset-coverage:\n\t$(Q)find -name \"*\\.gcda\" | xargs $(RM)\n\t$(Q)$(RM) coverage.info\n\nctags:\n\t@find . -name \"*\\.[chS]\" -o -path ./tests -prune -o -path ./check-deps -prune \\\n\t\t| xargs ctags --regex-asm='/^(GLOBAL|ENTRY|END)\\(([^)]*)\\).*/\\2/'\n\nhelp:\n\t@echo \"Available targets:\"\n\t@echo \"  all           - Build uftrace (default)\"\n\t@echo \"  config        - Configure uftrace\"\n\t@echo \"  install       - Install built uftrace\"\n\t@echo \"  uninstall     - Uninstall uftrace\"\n\t@echo \"  test          - Run all tests: unit test, integration test, python test\"\n\t@echo \"  unittest      - Run unit tests\"\n\t@echo \"  runtest       - Run integration tests\"\n\t@echo \"  pytest        - Run Python tests\"\n\t@echo \"  bench         - Run benchmark tests\"\n\t@echo \"  dist          - make *.tar file\"\n\t@echo \"  doc           - Build documentation\"\n\t@echo \"  clean         - Clean up built object files\"\n\t@echo \"  reset-coverage- Reset code coverage data (*.gcda)\"\n\t@echo \"  ctags         - Generate ctags\"\n\t@echo \"  help          - Print this help message\"\n\t@echo \"\"\n\t@echo \"Build options:\"\n\t@echo \"  make DEBUG=0|1 [targets]    - Set flags for debugging (default: 0)\"\n\t@echo \"  make TRACE=0|1 [targets]    - Set flags for tracing (default: 0)\"\n\t@echo \"  make COVERAGE=0|1 [targets] - Set flags for code coverage (default: 0)\"\n\t@echo \"  make ASAN=0|1 [targets]     - Set flags for AddressSanitizer (default: 0)\"\n\t@echo \"  make SAN=all [targets]      - Set flags for Sanitizer (default: none)\"\n\t@echo \"  make DOCLANG=ko [targets]   - Generate documentation in Korean (default: English)\"\n\t@echo \"  make V=0|1 [targets]        - Set verbose output (default: 0)\"\n\t@echo \"  make O=dir [targets]        - Set directory as objdir (default: $(srcdir))\"\n\t@echo \"\"\n\n$(C_STR_OBJS): $(objdir)/%.$(C_STR_EXTENSION): $(srcdir)/%\n\t$(QUIET_GEN)sed -e 's#\\\\#\\\\\\\\#g;s#\\\"#\\\\\"#g;s#$$#\\\\n\\\"#;s#^#\\\"#' $< > $@\n\n.PHONY: all config clean test dist doc ctags help PHONY\n"
        },
        {
          "name": "Makefile.include",
          "type": "blob",
          "size": 0.8193359375,
          "content": "#-*- mode: makefile -*-\nifneq ($(findstring $(MAKEFLAGS),s),s)\n  ifneq ($(V),1)\n\tQUIET_CC       = @echo '  CC       '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_CC_FPIC  = @echo '  CC FPIC  '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_AR       = @echo '  AR       '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_ASM      = @echo '  ASM      '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_LINK     = @echo '  LINK     '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_MKDIR    = @echo '  MKDIR    '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_GEN      = @echo '  GEN      '$(patsubst $(objdir)/%,%,$@);\n\tQUIET_FLEX     = @echo '  FLEX     '$@;\n\tQUIET_BISON    = @echo '  BISON    '$@;\n\tQUIET_TEST     = @echo '  TEST     '$@;\n\n\tQUIET_CLEAN    = @printf '  CLEAN    %s\\n' $1;\n\tQUIET_INSTALL  = @printf '  INSTALL  %s\\n' $1;\n\tQUIET_UNINSTALL= @printf '  REMOVE   %s\\n' $1;\n\n\tQ = @\n  endif\nendif\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 16.77734375,
          "content": "uftrace v0.17\n=============\n* New features\n  Support watchpoint for global variables (#661)\n  Show man pages for the given command (#1316)\n  Add utc_offset in the header info (#1916)\n\n* Bug fixes\n  Show arguments in libraries from dlopen (#842, #1981)\n  Save debug info for libraries from dlopen (#1312)\n  Protect FD of communication channel from being closed\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Daehyun Kim, Honggyu Kim, Kang Minchul, Michelle Jin, Rongsong Shen,\n  Seunghyeok Park, Sin Sohi, Yunseong Kim, zyxeeker\n\n\nuftrace v0.16\n=============\n* New features\n  Support for the separate debug file (#1144, #1880)\n  Add 'o' for octal integer argument format (#1892)\n  Add stdv (relative standard deviation) fields to report (#1897)\n\n* Bug fixes\n  Fix wrong debug info creation in Python tracing (#1858)\n  Do not hold a refcount for the Python code object (#1886)\n  Exception handling with static local variable (#1902)\n  Fix libcall tracing when DT_RELAENT is missing (#1903)\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Ameya Vikram Singh, Bernhard Kaindl, Dongjin Na, Honggyu Kim,\n  Kevin Williams, Michelle Jin, Paran Lee, Rongsong Shen, Yi Hong,\n  Ziming Zhou\n\n\nuftrace v0.15\n=============\n* New architecture support\n  Basic support for RISC-V (RV64G ABI) (#1815)\n  Arguments and return value recording (#1824)\n  PLT hooking for library call tracing (#1853)\n\n* Bug fixes\n  Support library call tracing with `-fno-plt` (#1777)\n  Reduce failures on `uftrace recv` test (#1767)\n  Fix tracefs check on qemu (#1753)\n  Skip offline CPUs for kernel tracing (#1849)\n  Ignore unpaired __cyg_profile_func_exit() to avoid crashes\n\n* other changes\n  Get rid of old copy of libtraceevent (#1728)\n  Use MAP_FIXED_NOREPLACE for dynamic tracing (#1798)\n  Many documentation updates (#1669, #1744, #1759, #1760, #1783, #1785, #1786, #1788, #1790, #1806)\n  Add misc/wget-pr.sh script to get patch files from github (#1808)\n  Add more unit test cases\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Bernhard Kaindl, ChoKyuWon, Chongyun Lee, Clment Guidi, Gichoel Choi,\n  Honggyu Kim, Jeonghwan In, Jin Jang, JungminKim, Kang Minchul,\n  Michelle Jin, Olivier Dion, Paran Lee, Robert Berger, SangGyuLee,\n  SeokMin Kwon, Seong Jin Kim, Soyeon Park, Stefan Hoffmeister,\n  Yoojung Nam, Yufeng Jin, kang-hyuck\n\n\nuftrace v0.14\n=============\n* new options\n  --trigger option is restored\n  --trace=(on|off) option to deprecate --disable\n  filters and triggers can be deleted with @clear action (with agent)\n\n* new features\n  python tracing  (#436, #1640, #1641, #1676)\n  change options at runtime with agent  (#1665, #1678, #1643, #1644, #1645, #1646)\n\n* bug fixes\n  Lots of fixes for the test infra  (#1628)\n\n* other changes\n  Android build support  (#1605)\n  Update symbol file format to add symbol size  (#1616)\n  Improve Rust symbol demangling  (#1625)\n  Change default library install path  (#1618)\n  Use C11 + GNU extensions for compilation  (#1642)\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Bernhard Kaindl, ChoKyuWon, Clment Guidi, Honggyu Kim, Kang Minchul,\n  Khem Raj, Michelle Jin, Namhyung Kim, Sangwon Hong, Yi Hong, Yuri Gribov\n\n\nuftrace v0.13\n=============\n* new options\n  -L/--loc-filter option to filter by source location  (#1395)\n  --mermaid option for uftrace dump  (#1511)\n  --no-sched-preempt option to disable preempted schedule events  (#1587)\n\n* new features\n  make -Z/--size-filter option work in general  (#1600)\n  optionally spawn a background agent to talk using a socket  (#1543)\n  add \"size\" field for uftrace report  (#1495)\n\n* bug fixes\n  handle different tracefs mount points  (#1476)\n  fix timestamp parsing for external data  (#1549)\n\n* other changes\n  add clang-format support\n  change to use Github actions\n  test both GCC and LLVM/clang  (#1523)\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Andrew Woo, Clment Guidi, Daero Lee, Euiseo Park, Eunseon Lee, Honggyu Kim,\n  JHH20, JaeSang Yoo, JeongWan Gho, Jia Ha, JongHyeon Hwang, Jonghyeon An,\n  Joonho Seo, Kang Minchul, Namhyung Kim, Paran Lee, Sangwon Hong, Seonghee Jin,\n  Seonghyun Park, Yuri Gribov, Yusun Choi, valdaarhun\n\n\nuftrace v0.12\n=============\n* new options\n  --no-args to hide arguments and return values\n  --clock option to set clock source other than monotonic\n\n* new features\n  support events in uftrace script\n  enable --with-syms for uftrace record\n  adjust sample time for flame graph dump  (#1257)\n\n* dynamic tracing updates\n  support binaries built with -fpatchable-function-entry  (#1238)\n  documentation updates\n\n* bug fixes\n  fix segfault in uftrace record on a large machine  (#1418)\n  various fixes for ARM build failures\n\n* other changes\n  allow -s option to set a sort key for TUI report\n  remove -L option for later use\n  add func-histogram.py script\n  a couple of update in the travis CI setup\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Eunseon Lee, Honggyu Kim, ihsinme, Kang Minchul, Nobuhiro Iwamatsu,\n  Paul Cannon, Sangwon Hong, Thomas Petazzoni\n\n\nuftrace v0.11\n=============\n* new options\n  --format=html to print a html page directly  (#1308)\n  --with-syms to replay/report with existing symbol data  (#1228)\n\n* new features\n  support note.txt in the data directory to put extra notes  (#1307)\n  improve debugging with stacktrace using libunwind  (#1177)\n  support customizing output fields in TUI report (#1270)\n\n* dynamic tracing updates\n  support -mfentry -mnop-mcount on i386  (#1296)\n  dynamic tracing for clang XRay v2  (#1265)\n  SONAME support for library patterns in dynamic tracing  (#1216)\n\n* bug fixes\n  fix two similar struct arguments are used  (#1281)\n  fix struct argument is used in uftrace script  (#1282)\n  fix TUI info mode crash in a large screen\n  fix crash in the USDT event tracing  (#1286)\n\n* other changes\n  update and fix build with python3  (#1271, #1344)\n  ignore remaining schedule events in replay  (#1293)\n  enable undefined-behavior sanitizer (ubsan) with ASAN=1  (#1295)\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Bernhard Kaindl, Gabriel-Andrew Pollo-Guilbert, Hanbum Park\n  Honggyu Kim, Kang Minchul, Kun-Chuan Hsieh, Michael Sartain\n  Sangwon Hong\n\n\nuftrace v0.10\n=============\n* new options\n  --estimate-return to avoid return address hooking\n  -H/--hide to not display unwanted symbols\n  --no-sched to suppress scheduler events\n  --srcline supports report/replay/graph (by Eunseon)\n\n* dynamic tracing update (mostly by Hanbum)\n  convert to hash map to find saved code\n  it can trace functions in libraries loaded by dlopen()\n  support patching MOV instruction in x86\n\n* other changes\n  convert from argparse to getopt_long\n  check binary build-id (for binaries have same name)\n  struct argument/return value (pass-by-value) support\n  support customizing output fields in TUI graph (by Sangwon)\n\n* bug fixes\n  fix floating-point register access on AArch64\n  fix issues with Intel CET technology on x86\n  handle zero PLT entry size on AArch64\n  fix crash when C++ object is passed indirectly\n\nAnd many other fixes and improvements.  Thanks all contributors:\n  Anas Blaboul, Daniel T. Lee, Dohyung Kim, Eunseon Lee,\n  Hanbum Park, Honggyu Kim, Kang Minchul, Lei Maohui,\n  Nathan Lanza, Sang-Heon Jeon, Sangwon Hong, SeokHoon Yoon,\n  Sungho Bae, Tim Gates\n\n\nuftrace v0.9.4\n--------------\n* dynamic tracing update\n  improve success rate on x86_64\n  dynamic unpatch on x86_64 (for -mfentry or -mrecord-mcount)\n  add -U/--unpatch option for dynamic tracing\n  experimental support for aarch64\n\n* script update\n  luaJIT (lua 5.1) support by Byeonggon\n  python3 support\n\n* build change\n  update configure script for better compatibility\n  handle common cross compile settings\n\n* tui change\n  add 's' key to sort column in tui report mode by Hyoungjong\n  use --report option to start tui with report mode\n\n* other changes\n  task level analysis for graph and info command\n  add Korean documentation\n  a lot of memory leak fixes\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Anas Balboul, Byeonggon Lee, Colin Lord, George Karlos, GwanYeong Kim,\n  Haeun Jeon, Hanbum Park, Handong Choi, Honggyu Kim, Hyoungjong Kim,\n  Jeesoo Min, Joonho Ryu, Jungkeun Cho, Jungwoo Jo, Junil Kim,\n  Minchul Kang, MinJeong Kim, Sang-Heon Jeon, Sangyun Han,\n  SeoYoung Kim, Sungho Yoon, Yeomin Nam\n\n\nuftrace v0.9.3\n--------------\n* dynamic tracing update\n  add (optional) dependency of capstone disassembly engine\n  support tracing executables w/o instrumentation on x86_64\n  add -Z/--size-filter option not to select small functions\n\n* external event support\n  support display user-defined events in uftrace.data/extern.dat\n  it's a text file which has timestamp and message for each line\n\n* other changes\n  allow tracing (system) binaries in the PATH\n  add --srcline option to save debug info only if necessary\n  apply --time-filter for analysis commands by default\n  allow tracing execution of shell (interpreter)\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Daniel T. Lee, Hanbum Park, Honggyu Kim, Taeung Song\n\n\nuftrace v0.9.2\n--------------\n* trigger update\n  add --signal option to support trigger by signal\n\n* TUI update\n  add C/E key to collapse/expand all child nodes\n  make R/r key to go to report window separately\n  add z key to align screen to center\n\n* other changes\n  display data symbols in argument/return value\n  trace library calls even without PLT\n  add -l short option for --nest-libcall\n  rudimentary support for Rust programs\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Anas Balboul, Claudia J. Kang, Daniel T. Lee, Honggyu Kim\n\n\nuftrace v0.9.1\n--------------\n* filter update\n  add --caller-filter option\n\n* script changes\n  rename context in uftrace_begin: \"args\" -> \"cmds\"\n  rename context in uftrace_begin: \"recording\" -> \"record\"\n\n* other changes\n  add --watch option to trace cpu task is running\n  add --graphviz option to produce output in DOT format\n  filter 'do_syscall_64' kernel function by default\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Ahn Seung-rye, Claudia J. Kang, Daniel T. Lee, GwanYeong Kim,\n  Hanbum Park, Honggyu Kim, Leah Neukirchen, Rikard Falkeborn\n\n\nuftrace v0.9\n============\n* argument update\n  automatic argument using DWARF debug info\n  display enum constants properly\n  add -a short option for --auto-args\n\n* TUI implementation\n  graph, report and info commands using ncurses\n  redraw graph for a selected function\n  fold/unfold and search nodes in graph\n\n* build changes\n  configure script shows status of dependencies\n  add --without-XXX option to the configure script\n  allow build without libelf\n\n* filter changes\n  add --match option to select pattern matching method: regex or glob\n  add --no-event option to disable default events\n  apply recover trigger for every function automatically\n\n* other changes\n  pass runtime info to script\n  add -h short option for help message\n  add --no-randomize-addr option to disable ASLR\n  enable task scheduling events by default\n  use gray color for comments and green for events\n  add basic gdb (python) script to help debugging\n  add misc/symbols tool to show symbol name from address\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  GwanYeong Kim, Hanbum Park, Honggyu Kim, Taeguk Kwon, Taeung Song,\n  Khem Raj\n\n\nuftrace v0.8.3\n--------------\n* i386 arch support (by Hanbum Park):\n  support arguments and dynamic tracing\n\n* graph update (by Honggyu Kim):\n  add -f/--output-fields option to control output\n  share common code/behavior with replay command\n\n* event update:\n  add task events (fork/comm/exit) using Linux perf subsystem\n  enable task events always if supported\n\n* trigger change:\n  change 'read' trigger action to read events twice (at entry and exit)\n  support some pmu-related events using read trigger (with perf syscall)\n  allow 'd' format specifier for default behavior with different size\n\n* other changes:\n  add misc/demangler to test demangling easily\n  add --libname option to show library names for PLT functions\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Hanbum Park, Honggyu Kim, Taeung Song\n\n\nuftrace v0.8.2\n--------------\n* trigger update\n  add 'p' format for function pointer\n  add --auto-args option for automatic argument/return value\n  support enum type for auto-args\n\n* diff change\n  add 'compact' policy and make it default\n  old behavior is supported on 'full' policy\n\n* graph change\n  show full graph when no function given\n  support fork+exec properly\n\n* script change\n  flush stdout buffer before fork\n  serialize execution using a mutex\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Andrew Slough, Hansuk Hong, Hanbum Park, Honggyu Kim, JangSoJin,\n  Myungjin Ko, MyungSik Ji, Sangwon Hong, Taeung Song,\n  Vincent LE GARREC, Yujeong Kim\n\n\nuftrace v0.8.1\n--------------\n* trigger update\n  apply filter/trigger to all libraries by default\n  save symbol tables of all libraries\n  -T/--trigger option supports filtering and argument/return value\n\n* other changes\n  make --nest-libcall option imply --force option\n  add --record option to script command\n  replay show 's' suffix for std::string arguments\n  allow reading data in current directory\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Honggyu Kim, Taeung Song\n\n\nuftrace v0.8\n============\n* event tracing support:\n  enable tracing events as well as functions.  following events are\n  supported using -E/--event option\n    - SystemTap SDT (x86_64 only)\n    - kernel tracepoint\n    - scheduler (using perf syscall)\n  list available events using --list-event option\n  new read trigger also creates 'proc/statm' and 'page-fault' events\n\n* libcall tracing update:\n  fix to trace already resolved functions too\n  trace nested calls from other libraries using --nest-libcall option\n  handle BIND-NOW + PIE properly\n\n* python scripting support:\n  add new 'script' command with -S/--script option\n  also support record-time scripting\n  support additional filter for script execution\n  allow to specify options for recording\n\n* report diff change:\n  sort by (absolute) diff\n  add --diff-policy option to control behavior\n  add 'func' sort key\n  change color setting\n\n* other changes:\n  std::string argument display\n  add elapsed time info\n  \"uftrace recv --run-cmd\" can execute user-given command\n  add \"finish\" trigger action to tracing\n  add --opt-file option to allow reading options from file\n  add --keep-pid option to preserve pid when running program\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Changhyeok Bae, Honggyu Kim, JeongBong Seo, SeongJae Park,\n  Taeung Song, Paul Cannon\n\n\nuftrace v0.7\n============\n* dynamic tracing support (x86_64 only)\n  enable tracing for selected functions with -P option\n  it needs some compiler support though\n  - gcc with -mnop-mcount option\n  - clang (X-ray) with -fxray-instrument option\n\n* AArch64 support\n  add preliminary support for ARM v8 (64-bit)\n  first integer argument is missing\n\n* kernel tracing change\n  show recorded kernel functions by default\n  partial support for event tracing\n  fix to send/receive kernel data via network\n  filter out sys_clock_gettime() for non-VDSO systems\n\n* dump change:\n  show arguments and return values properly\n  show more kernel tracing info\n  fix file offset printing\n\n* build change:\n  fix various problems on GCC 7\n  update configure script for better distro packaging\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Dridi Boukelmoune, Honggyu Kim, Taeung Song, Wonseok Ko\n\n\nuftrace v0.6.2\n--------------\n* dlopen() support:\n  can show functions from dynamic loaded library using dlopen()\n\n* kernel tracing update:\n  save kernel metadata so that it can be viewed from a different machine\n  adjust tracer settings to reduce lost kernel data\n\n* filter change:\n  remove '+' sign in elapsed time for --time-range option\n  allow to use 'm' or 'min' to specify elapsed time\n\nAnd many bug fixes and improvements.  Thanks for all contributors:\n  Abder Benbachir, Genevive Bastien, Honggyu Kim, Taeung Song,\n  Wonseok Ko\n\n\nuftrace v0.6.1\n--------------\n* kernel option change:\n  The -K option is same as --kernel-depth\n  The --kernel-skip-out is deprecated and use\n  The --kernel-full is to show kernel functions outside of user functions\n  The --kernel-only option was added\n\n* replay change:\n  add --output-fields option to customize the info on the left side\n  currently time, delta, elapsed, duration, tid and addr fields are supported\n\n* filter change:\n  apply time filter on replay\n  add --time-range option to limit data analysis\n  report, graph and dump honors same filter on replay\n  add 'time' trigger to set a different threshold on specific functions\n\n* flame-graph support:\n  \"uftrace dump --flame-graph\" creates a SVG file\n  use --sample-time option to control sampling frequency in the output\n\n* build change:\n  improve build process to facilitate distro packaging\n  configure script checks dependency and shows warning\n\n\nuftrace v0.6\n============\n* project open!\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 16.421875,
          "content": "[![Nightly test](https://github.com/namhyung/uftrace/actions/workflows/nightly-test.yml/badge.svg)](https://github.com/namhyung/uftrace/actions/workflows/nightly-test.yml)\n[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?logo=discord&logoColor=white)](https://discord.gg/MENMKaCWqD)\n\nuftrace\n=======\n\n<a href=\"https://repology.org/project/uftrace/versions\">\n    <img src=\"https://repology.org/badge/vertical-allrepos/uftrace.svg\" alt=\"Packaging status\" align=\"right\">\n</a>\n\nuftrace is a function call graph tracer for C, C++, Rust and Python programs.\n\nIt hooks into the entry and exit of each function, recording timestamps\nas well as the function's arguments and return values. uftrace is capable\nof tracing both user and kernel functions, as well as library functions and\nsystem events providing an integrated execution flow in a single timeline.\n\nInitially, uftrace only supported function tracing with compiler support.\nHowever, it now allows users to trace function calls without recompilation\nby analyzing instructions in each function prologue and dynamically and\nselectively patching those instructions.\n\nUsers can also write and run scripts for each function entry and exit using\npython/luajit APIs to create custom tools for their specific purposes.\n\nuftrace offers various filters to reduce the amount of trace data and provides\nvisualization using Chrome trace viewer and flame graph or call-graph diagrams\nfor graphviz and mermaid, allowing for a big picture view of the execution flow.\n\nIt was heavily inspired by the ftrace framework of the Linux kernel and\nthe name uftrace stems from the combination of user and ftrace.\n\nIt can record data from:\n- User space C/C++/Rust functions, by either dynamically patching functions\n  using `-P.`, or else selective NOP patching using code compiled with `-pg`,\n  `-finstrument-functions` or `-fpatchable-function-entry=N`.\n- C/C++/Rust Library functions (through PLT hooking)\n- Python functions (using Python's trace/profile infrastructure)\n- Kernel functions (using the ftrace framework in Linux kernel)\n- Kernel trace events (using event tracing framework in Linux kernel)\n- Task creation, termination and scheduling events (using Linux perf_event)\n- User space events in the target binary or libraries (using SystemTap SDT ABI)\n- PMU counter values for given functions (using Linux perf_event)\n\nWith the recorded data, uftrace can:\n- Show colored and nested function call graphs.\n- Show arguments and return values symbolically using libc function prototypes\n  and DWARF debug information.\n- Apply filters to minimize the amount of trace data in both record and replay time.\n- Extract metadata from traces. (e.g. system information on which the trace was taken)\n- Generate symbol tables and memory maps of the traced program and library functions.\n- Generate task relationship trees (parent and children) of nested programs in traces.\n\nIt supports many commands and filters such as filtering by function call\nduration for analysis of program execution and performance.\n\n![uftrace-live-demo](doc/uftrace-live-demo.gif)\n\n * Homepage: https://github.com/namhyung/uftrace\n * Tutorial: https://github.com/namhyung/uftrace/wiki/Tutorial\n * Chat: https://discord.gg/MENMKaCWqD (Discord)\n * Mailing list: [uftrace@googlegroups.com](https://groups.google.com/forum/#!forum/uftrace)\n * Lightning talk: https://youtu.be/LNav5qvyK7I\n\n\nFeatures\n========\n\nuftrace traces each function in the executable and shows time durations.\n\nUsually, for this to be possible, the program needs to be compiled with\n`-pg` or `-fpatchable-function-entry=5` (`=2` is enough on aarch64).\nWith full dynamic tracing (`-P.`|`--patch=.`), uftrace works on all executables (as\nlong they are not stripped, or symbol information is available from a separate file).\n\nuftrace hooks into the PLT in the given executable file to trace library calls and with\n(`-l`|`--nest-libcall`), it also hooks into the procedure linkage tables (PLTs) of shared\nlibraries. The depth can be limited using `-D<num>`, where 1 is flat call tracing.\n\nUsing (`-a`|`--auto-args`), uftrace automatically records arguments and\nreturn values of known functions. Without extra debug information, this\nincludes the API functions of standard (C language or system) libraries.\nThis can be combined with `-P.` or `-l`:\nFor example, `-la` traces nested library calls, even in stripped executables.\n\nIn addition, `-a` implies `--srcline`, so it records the source line location info, and\nthis info can be shown by `uftrace replay --srcline` and in `uftrace tui`. Users can directly\nopen the editor at the source location as shown in https://uftrace.github.io/slide/#120.\n\nIf debug information for the program (`gcc -g`) is available, `--auto-args`\nworks even on functions inside the user-compiled programs.\n\nIn case argument information is not available, argument specifications like\n(`-A udev_new@arg1/s`) can be passed on the command line or an options file.\n\nExample:\n```py\n$ uftrace record -la -A udev_new@arg1/s lsusb >/dev/null\n$ uftrace replay -f+module\nor simply:\n$ uftrace -la -A udev_new@arg1/s -f+module lsusb  # -f+module adds the module name\n# DURATION     TID        MODULE NAME   FUNCTION\n 306.339 us [ 23561]            lsusb | setlocale(LC_TYPE, \"\") = \"en_US.UTF-8\";\n   1.163 us [ 23561]            lsusb | getopt_long(1, 0x7fff7175f6a8, \"D:vtP:p:s:d:Vh\") = -1;\n            [ 23561]            lsusb | udev_new(\"POSIXLY_CORRECT\") {\n   0.406 us [ 23561] libudev.so.1.7.2 |   malloc(16) = 0x55e07277a7b0;\n   2.620 us [ 23561]            lsusb | } /* udev_new */\n            [ 23561]            lsusb | udev_hwdb_new() {\n   0.427 us [ 23561] libudev.so.1.7.2 |   calloc(1, 200) = 0x55e07277a7d0;\n   5.829 us [ 23561] libudev.so.1.7.2 |   fopen64(\"/etc/systemd/hwdb/hwdb.bin\", \"re\") = 0;\n```\n\nFurthermore, it can show detailed execution flow at function level, and report\nwhich functions had the longest execution time.  It also shows information about\nthe execution environment.\n\nYou can set up filters to exclude or include specific functions when tracing.\nIn addition, function arguments and return values can be saved and shown later.\n\nIt supports multi-process and/or multi-threaded applications.  With root\nprivileges and if the kernel was built with `CONFIG_FUNCTION_GRAPH_TRACER=y`,\nkernel functions can be traced as well.\n\nHow to build and install uftrace\n================================\n\nOn Linux distros, [misc/install-deps.sh](misc/install-deps.sh) can be used to\ninstall required software(s) for building uftrace.  Those are for optional\nand advanced features, but are highly recommended.\n\n    $ sudo misc/install-deps.sh\n\nOnce you installed required software(s) on your system, it can be built and\ninstalled like following:\n\n    $ ./configure\n    $ make\n    $ sudo make install\n\nFor details about installation and dependencies, please refer to [INSTALL.md](INSTALL.md)\n\n\nHow to use uftrace\n==================\nThese are the commands supported by uftrace:\n\n * [`record`](doc/uftrace-record.md) : runs a program and saves the trace data\n * [`replay`](doc/uftrace-replay.md) : shows program execution in the trace data\n * [`report`](doc/uftrace-report.md) : shows performance statistics in the trace data\n * [`live`  ](doc/uftrace-live.md)   : does record and replay in a row (default)\n * [`info`  ](doc/uftrace-info.md)   : shows system and program info in the trace data\n * [`dump`  ](doc/uftrace-dump.md)   : shows low-level trace data\n * [`recv`  ](doc/uftrace-recv.md)   : saves the trace data from network\n * [`graph` ](doc/uftrace-graph.md)  : shows function call graph in the trace data\n * [`script`](doc/uftrace-script.md) : runs a script for recorded trace data\n * [`tui`   ](doc/uftrace-tui.md)    : show text user interface for graph and report\n\nYou can use `-h` or `--help` option to see available [commands and options](doc/uftrace.md).\n\n    $ uftrace\n    uftrace -- function (graph) tracer for userspace\n\n     usage: uftrace [COMMAND] [OPTION...] [<program>]\n\n     COMMAND:\n       record          Run a program and saves the trace data\n       replay          Show program execution in the trace data\n       report          Show performance statistics in the trace data\n       live            Do record and replay in a row (default)\n       info            Show system and program info in the trace data\n       dump            Show low-level trace data\n       recv            Save the trace data from network\n       graph           Show function call graph in the trace data\n       script          Run a script for recorded trace data\n       tui             Show text user interface for graph and report\n\n    Try `uftrace --help' or `man uftrace [COMMAND]' for more information.\n\nIf omitted, it defaults to the `live` command which is almost same as running\nrecord and replay subcommand in a row (but does not record the trace info\nto files).\n\nFor recording, the executable needs to be compiled with the `-pg`\n(or `-finstrument-functions`) option which generates profiling code\n(calling mcount or __cyg_profile_func_enter/exit) for each function.\n\nNote that, there's an experimental support for dynamic tracing on\nx86_64 and AArch64(ARM64) which doesn't require such (re-)compilations.\nAlso, recent compilers have some options to help uftrace\nto reduce tracing overhead with similar way\n(although it still needs recompilation of your program).\nPlease see [dynamic tracing](doc/uftrace-record.md#dynamic-tracing) section\nfor more details.\n\n    $ uftrace tests/t-abc\n    # DURATION    TID     FUNCTION\n      16.134 us [ 1892] | __monstartup();\n     223.736 us [ 1892] | __cxa_atexit();\n                [ 1892] | main() {\n                [ 1892] |   a() {\n                [ 1892] |     b() {\n                [ 1892] |       c() {\n       2.579 us [ 1892] |         getpid();\n       3.739 us [ 1892] |       } /* c */\n       4.376 us [ 1892] |     } /* b */\n       4.962 us [ 1892] |   } /* a */\n       5.769 us [ 1892] | } /* main */\n\nFor more analysis, you'd be better recording it first so that it can run\nanalysis commands like replay, report, graph, dump and/or info multiple times.\n\n    $ uftrace record tests/t-abc\n\nIt'll create uftrace.data directory that contains trace data files.\nOther analysis commands expect the directory exists in the current directory,\nbut one can use another using `-d` option.\n\nThe `replay` command shows execution information like above.  As you can see,\n`t-abc` is a very simple program merely calls a, b and c functions.\nIn the c function it called getpid() which is a library function implemented\nin the C library (glibc) on normal systems - the same goes to __cxa_atexit().\n\nUsers can use various filter options to limit functions it records/prints.\nThe depth filter (`-D` option) is to omit functions under the given call depth.\nThe time filter (`-t` option) is to omit functions running less than the given\ntime. And the function filters (`-F` and `-N` options) are to show/hide functions\nunder the given function.\n\nThe `-k` option enables to trace kernel functions as well (needs root access).\nWith the classic hello world program, the output would look like below (Note,\nI changed it to use fprintf() with stderr rather than the plain printf() to make\nit invoke system call directly):\n\n    $ sudo uftrace -k tests/t-hello\n    Hello world\n    # DURATION    TID     FUNCTION\n       1.365 us [21901] | __monstartup();\n       0.951 us [21901] | __cxa_atexit();\n                [21901] | main() {\n                [21901] |   fprintf() {\n       3.569 us [21901] |     __do_page_fault();\n      10.127 us [21901] |     sys_write();\n      20.103 us [21901] |   } /* fprintf */\n      21.286 us [21901] | } /* main */\n\nYou can see the page fault handler and the system call handler for write() were called\ninside the fprintf() call.\n\nAlso, it can record and show function arguments and return value with `-A` and\n`-R` options respectively.  The following example records first argument and\nreturn value of 'fib' (Fibonacci number) function.\n\n    $ uftrace record -A fib@arg1 -R fib@retval tests/t-fibonacci 5\n\n    $ uftrace replay\n    # DURATION    TID     FUNCTION\n       2.853 us [22080] | __monstartup();\n       2.194 us [22080] | __cxa_atexit();\n                [22080] | main() {\n       2.706 us [22080] |   atoi();\n                [22080] |   fib(5) {\n                [22080] |     fib(4) {\n                [22080] |       fib(3) {\n       7.473 us [22080] |         fib(2) = 1;\n       0.419 us [22080] |         fib(1) = 1;\n      11.452 us [22080] |       } = 2; /* fib */\n       0.460 us [22080] |       fib(2) = 1;\n      13.823 us [22080] |     } = 3; /* fib */\n                [22080] |     fib(3) {\n       0.424 us [22080] |       fib(2) = 1;\n       0.437 us [22080] |       fib(1) = 1;\n       2.860 us [22080] |     } = 2; /* fib */\n      19.600 us [22080] |   } = 5; /* fib */\n      25.024 us [22080] | } /* main */\n\nThe `report` command lets you know which function spends the longest time\nincluding its children (total time).\n\n    $ uftrace report\n      Total time   Self time       Calls  Function\n      ==========  ==========  ==========  ====================================\n       25.024 us    2.718 us           1  main\n       19.600 us   19.600 us           9  fib\n        2.853 us    2.853 us           1  __monstartup\n        2.706 us    2.706 us           1  atoi\n        2.194 us    2.194 us           1  __cxa_atexit\n\n\nThe `graph` command shows function call graph of given function.  In the above\nexample, function graph of function 'main' looks like below:\n\n    $ uftrace graph  main\n    # Function Call Graph for 'main' (session: 073f1e84aa8b09d3)\n    =============== BACKTRACE ===============\n     backtrace #0: hit 1, time  25.024 us\n       [0] main (0x40066b)\n\n    ========== FUNCTION CALL GRAPH ==========\n      25.024 us : (1) main\n       2.706 us :  +-(1) atoi\n                :  |\n      19.600 us :  +-(1) fib\n      16.683 us :    (2) fib\n      12.773 us :    (4) fib\n       7.892 us :    (2) fib\n\n\nThe `dump` command shows raw output of each trace record.  You can see the result\nin the Chrome browser, once the data is processed with `uftrace dump --chrome`.\nBelow is a trace of clang (LLVM) compiling a small C++ template metaprogram.\n\n[![uftrace-chrome-dump](doc/uftrace-chrome.png)](https://uftrace.github.io/dump/clang.tmp.fib.html)\n\nIt also supports flame-graph output as well.  The data can be processed with\n`uftrace dump --flame-graph` and passed to\n[flamegraph.pl](https://github.com/brendangregg/FlameGraph/blob/master/flamegraph.pl).\nBelow is a flame graph result of gcc compiling a simple C program.\n\n[![uftrace-flame-graph-dump](https://uftrace.github.io/dump/gcc.svg)](https://uftrace.github.io/dump/gcc.svg)\n\nThe `info` command shows system and program information when recorded.\n\n    $ uftrace info\n    # system information\n    # ==================\n    # program version     : uftrace v0.8.1\n    # recorded on         : Tue May 24 11:21:59 2016\n    # cmdline             : uftrace record tests/t-abc\n    # cpu info            : Intel(R) Core(TM) i7-3930K CPU @ 3.20GHz\n    # number of cpus      : 12 / 12 (online / possible)\n    # memory info         : 20.1 / 23.5 GB (free / total)\n    # system load         : 0.00 / 0.06 / 0.06 (1 / 5 / 15 min)\n    # kernel version      : Linux 4.5.4-1-ARCH\n    # hostname            : sejong\n    # distro              : \"Arch Linux\"\n    #\n    # process information\n    # ===================\n    # number of tasks     : 1\n    # task list           : 5098\n    # exe image           : /home/namhyung/project/uftrace/tests/t-abc\n    # build id            : a3c50d25f7dd98dab68e94ef0f215edb06e98434\n    # exit status         : exited with code: 0\n    # elapsed time        : 0.003219479 sec\n    # cpu time            : 0.000 / 0.003 sec (sys / user)\n    # context switch      : 1 / 1 (voluntary / involuntary)\n    # max rss             : 3072 KB\n    # page fault          : 0 / 172 (major / minor)\n    # disk iops           : 0 / 24 (read / write)\n\nThe `script` command allows user to run a custom script on a data recorded.\nThe supported script types are Python 3, Python 2.7 and Lua 5.1 as of now.\n\nThe `tui` command is for interactive text-based user interface using ncurses.\nIt provides basic functionality of `graph`, `report` and `info` commands as of\nnow.\n\n\nLimitations\n===========\n- It can trace a C/C++/Rust/Python application on Linux and Android.\n- It *cannot* trace an already running process yet.\n- It was *not* designed for system-wide tracing in mind.\n- It mainly supports x86_64, AArch64 architectures.  It also works on x86 (32-bit), ARM (v6 and v7) but some features like dynamic tracing and automatic argument fetching might not work well.\n\n\nLicense\n=======\nThe uftrace program is released under GPL v2.  See [COPYING file](COPYING) for details.\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.7841796875,
          "content": "- cleanup task management\n- more trigger action\n- trigger filtering (ignore, count, at return, ...)\n- improve documentation\n- report w/ multi-thread\n- config file support\n- filter by argument value\n- filter by source location\n- SDT argument support\n- LTT-ng event (tracepoint) support\n- reading/watching external data (global variable, cpu, ...)\n- show kernel function argument and return value (with dynamic events)\n- different clock support (TSC on x86, ...)\n- generic field support for report\n- field and sort support for TUI\n- filtering on TUI\n- replay on TUI\n- python function tracing\n- write useful script examples\n- attach to existing process\n- process and display multiple data together\n- graph diff support\n- full demangling support\n- improve rust demangling\n- dynamic object naming (tagging?)\n"
        },
        {
          "name": "arch",
          "type": "tree",
          "content": null
        },
        {
          "name": "check-deps",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmds",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 9.50390625,
          "content": "#!/usr/bin/env bash\n#-*- mode: shell-script; -*-\n\nif [ $(uname -s) != \"Linux\" ]; then\n    echo \"uftrace is only supported on Linux\"\n    exit\nfi\n\nprefix=/usr/local\n\nsrcdir=$(readlink -f $(dirname $0))\nobjdir=$(readlink -f ${objdir:-${PWD}})\noutput=${output:-${objdir}/.config}\n\nusage() {\n    echo \"Usage: $0 [<options>]\n\n  --help                print this message\n  --prefix=<DIR>        set install root dir as <DIR>        (default: /usr/local)\n  --bindir=<DIR>        set executable install dir as <DIR>  (default: \\${prefix}/bin)\n  --libdir=<DIR>        set library install dir as <DIR>     (default: \\${prefix}/lib/uftrace)\n  --mandir=<DIR>        set manual doc install dir as <DIR>  (default: \\${prefix}/share/man)\n  --objdir=<DIR>        set build dir as <DIR>               (default: \\${PWD})\n  --sysconfdir=<DIR>    override the etc dir as <DIR>\n\n  --with-elfutils=<DIR> search for elfutils in <DIR>/include and <DIR>/lib\n\n  --without-libelf      build without libelf (and libdw)     (even if found on the system)\n  --without-libdw       build without libdw                  (even if found on the system)\n  --without-libstdc++   build without libstdc++              (even if found on the system)\n  --without-libpython   build without libpython              (even if found on the system)\n  --without-libluajit   build without libluajit              (even if found on the system)\n  --without-libncurses  build without libncursesw            (even if found on the system)\n  --without-libunwind   build without libunwind              (even if found on the system)\n  --without-capstone    build without libcapstone            (even if found on the system)\n  --without-perf        build without perf event             (even if available)\n  --without-schedule    build without scheduler event        (even if available)\n  --without-libtraceevent\n                        build without libtraceevent          (even if found on the system)\n\n  --arch=<ARCH>         set target architecture              (default: system default arch)\n                        e.g. x86_64, aarch64, i386, or arm\n  --cross-compile=<CROSS_COMPILE>\n                        Specify the compiler prefix during compilation\n                        e.g. CC is overridden by \\$(CROSS_COMPILE)gcc\n  --cflags=<CFLAGS>     pass extra C compiler flags\n  --ldflags=<LDFLAGS>   pass extra linker flags\n\n  -p                    preserve old setting\n  -o <NAME>             output filename\n\n  Some influential environment variables:\n    ARCH                Target architecture    e.g. x86_64, aarch64, i386, or arm\n    CROSS_COMPILE       Specify the compiler prefix during compilation\n                        e.g. CC is overridden by \\$(CROSS_COMPILE)gcc\n    CFLAGS              C compiler flags\n    LDFLAGS             linker flags\n\"\n    exit 1\n}\n\n# preserve old settings\npreserve() {\n    if [ -f ${output} ]; then\n\twhile read pre opt op val; do\n\t    # do not change directory settings (to prevent confusion)\n\t    if [ \"${opt:3}\" = \"dir\" ]; then\n\t\tcontinue\n\t    fi\n\n\t    if [ \"$op\" = \":=\" -o \"$op\" = \"=\" ]; then\n\t\teval \"$opt=\\\"$val\\\"\"\n\t    fi\n\tdone < ${output}\n    fi\n}\n\nIGNORE=\nwhile getopts \":ho:-:p\" opt; do\n    case \"$opt\" in\n        -)\n\t    # process --long-options\n\t    case \"$OPTARG\" in\n                help)            usage ;;\n                without-libelf)  IGNORE=\"${IGNORE} libelf libdw\" ;;\n                without-*)       IGNORE=\"${IGNORE} ${OPTARG#*-}\" ;;\n                *=*)             opt=${OPTARG%%=*}; val=${OPTARG#*=}\n                                 eval \"${opt/-/_}='$val'\" ;;\n                *)               ;;\n            esac\n\t    ;;\n        o)       output=$OPTARG ;;\n        p)       preserve ;;\n        *)       usage ;;\n    esac\ndone\nshift $((OPTIND - 1))\n\nfor arg; do\n    opt=${arg%%=*}\n    val=${arg#*=}\n    eval \"$opt='$val'\"\ndone\n\nif [ -z \"$ARCH\" ]; then\n    uname_M=$(uname -m 2>/dev/null || echo not)\n    ARCH=$(echo $uname_M | sed -e s/i.86/i386/ -e s/arm.*/arm/ )\nfi\nif [ \"$ARCH\" = \"x86_64\" -o \"$ARCH\" = \"x86\" ]; then\n    if echo \"$CC $CFLAGS\" | grep -w \"\\-m32\" > /dev/null; then\n        ARCH=i386\n    fi\nfi\n\n#\n# Support --arch, --cross-compile, --cflags and --ldflags options\n#\nif [ ! -z \"$arch\" ]; then\n    case $arch in\n    x86_64 | arm | aarch64 | riscv64)\n        export ARCH=$arch\n\t;;\n    i*86)\n        export ARCH=\"i386\"\n        export CFLAGS=\"-m32 $CFLAGS\"\n        export LDFLAGS=\"-m32 $LDFLAGS\"\n\t;;\n    *)\n        echo \"Error: '$arch' is not a supported architecture\" >&2\n        exit 1\n\t;;\n    esac\nfi\nif [ ! -z \"$cross_compile\" ]; then\n    export CROSS_COMPILE=$cross_compile\nfi\nif [ ! -z \"$cflags\" ]; then\n    export CFLAGS=\"$cflags $CFLAGS\"\nfi\nif [ ! -z \"$ldflags\" ]; then\n    export LDFLAGS=\"$ldflags $LDFLAGS\"\nfi\n\nbindir=${bindir:-${prefix}/bin}\nlibdir=${libdir:-${prefix}/lib/uftrace}\netcdir=${etcdir:-${prefix}/etc}\nmandir=${mandir:-${prefix}/share/man}\n\nif [ \"$etcdir\" = /usr/etc ]; then\n    etcdir=/etc\nfi\nif [ -n \"$sysconfdir\" ]; then\n    etcdir=$sysconfdir\nfi\n\nCC=${CC:-${CROSS_COMPILE}gcc}\nLD=${LD:-${CROSS_COMPILE}ld}\n\nif $CC --version | grep -q Android; then\n    ANDROID=1\nfi\n\n# objdir can be changed, reset output\nobjdir=$(readlink -f ${objdir})\noutput=${output:-${objdir}/.config}\n\n#\n# this is needed to suppress warning from make below.\n# otherwise it'll get the following warning\n# when called from make -jN.\n#\n# warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.\n#\nMAKEFLAGS=\nMAKEOVERRIDES=\n\nexport CC CFLAGS LD LDFLAGS\n\ncheck_command() {\n\tif ! command -v $1 &>/dev/null\n\tthen\n\t\techo \"Error: '$1' command is not found\" >&2\n\t\texit 1\n\tfi\n}\n\ncheck_command make\ncheck_command ${CC}\n\nmake -siC ${srcdir}/check-deps O=${objdir} check-clean\nmake -siC ${srcdir}/check-deps O=${objdir} check-build\n\nfor dep in $IGNORE; do\n    TARGET=\n    case \"$dep\" in\n        libelf)        TARGET=have_libelf        ;;\n        libdw)         TARGET=have_libdw         ;;\n        libpython*)    TARGET='have_libpython*'  ;;\n        libluajit*)    TARGET=have_libluajit     ;;\n        libncurse*)    TARGET=have_libncurses    ;;\n        libunwind)     TARGET=have_libunwind     ;;\n        libstdc++)     TARGET=cxa_demangle       ;;\n        capstone)      TARGET=have_libcapstone   ;;\n        perf*)         TARGET=perf_clockid       ;;\n        sched*)        TARGET=perf_context_switch;;\n        libtraceevent) TARGET=have_libtraceevent   ;;\n        *)             ;;\n    esac\n    if [ ! -z \"$TARGET\" ]; then\n        rm -f ${objdir}/check-deps/$TARGET\n    fi\ndone\n\necho \"uftrace detected system features:\"\n\nprint_feature()\n{\n    item=$1\n    file=$2\n    description=$3\n\n    if [ -t 1 -a \"$TERM\" != \"dumb\" ]; then\n        # use colored output only when stdout is tty\n        if [ -f ${objdir}/check-deps/${file} ]; then\n            onoff=\"\\033[32mon \\033[0m\"\n        else\n            onoff=\"\\033[91mOFF\\033[0m\"\n        fi\n    else\n        if [ -f ${objdir}/check-deps/${file} ]; then\n            onoff=\"on \"\n        else\n            onoff=\"OFF\"\n        fi\n    fi\n    printf \"...%15s: [ ${onoff} ] - %s\\n\" \"${item}\" \"${description}\"\n}\n\nprint_feature2()\n{\n    item=$1\n    file1=$2\n    file2=$3\n    description=$4\n\n    if [ -t 1 -a \"$TERM\" != \"dumb\" ]; then\n        # use colored output only when stdout is tty\n        if [ -f ${objdir}/check-deps/${file1} -o -f ${objdir}/check-deps/${file2} ]; then\n            onoff=\"\\033[32mon \\033[0m\"\n        else\n            onoff=\"\\033[91mOFF\\033[0m\"\n        fi\n    else\n        if [ -f ${objdir}/check-deps/${file} ]; then\n            onoff=\"on \"\n        else\n            onoff=\"OFF\"\n        fi\n    fi\n    printf \"...%15s: [ ${onoff} ] - %s\\n\" \"${item}\" \"${description}\"\n}\n\nprintf \"...%15s: %s\\n\" \"prefix\" \"${prefix}\"\nprint_feature \"libelf\" \"have_libelf\" \"more flexible ELF data handling\"\nprint_feature \"libdw\" \"have_libdw\" \"DWARF debug info support\"\nprint_feature2 \"libpython\" \"have_libpython2.7\" \"have_libpython3\" \"python tracing & scripting support\"\nprint_feature \"libluajit\" \"have_libluajit\" \"luajit scripting support\"\nprint_feature \"libncursesw\" \"have_libncurses\" \"TUI support\"\nprint_feature \"cxa_demangle\" \"cxa_demangle\" \"full demangler support with libstdc++\"\nprint_feature \"perf_event\" \"perf_clockid\" \"perf (PMU) event support\"\nprint_feature \"schedule\" \"perf_context_switch\" \"scheduler event support\"\nprint_feature \"capstone\" \"have_libcapstone\" \"full dynamic tracing support\"\nprint_feature \"libtraceevent\" \"have_libtraceevent\" \"kernel tracing support\"\nprint_feature \"libunwind\" \"have_libunwind\" \"stacktrace support (optional for debugging)\"\n\ncat >$output <<EOF\n# this file is generated automatically\noverride prefix := $prefix\noverride bindir := $bindir\noverride libdir := $libdir\noverride mandir := $mandir\noverride etcdir := $etcdir\nEOF\n\nif [ ! -z $with_elfutils ]; then\n    echo \"override elfdir := $with_elfutils\" >> $output\nfi\n\ncat >>$output <<EOF\n\noverride ARCH   := $ARCH\noverride CC     := $CC\noverride LD     := $LD\noverride CFLAGS  = $CFLAGS\noverride LDFLAGS = $LDFLAGS\noverride ANDROID = $ANDROID\n\noverride srcdir := $srcdir\noverride objdir := $objdir\nEOF\n\nif [ $(id -u) -eq 0 ]; then\n    chmod 666 $output\nfi\n\nif [ \"$srcdir\" != \"$objdir\" ]; then\n    cat > $objdir/Makefile <<EOF\nARCH := $ARCH\n\nsrcdir := $srcdir\nobjdir := $objdir\n\nexport ARCH srcdir objdir\n\nMAKEFLAGS = --no-print-directory\n\nall: prepare\n\t@\\$(MAKE) -C \\$(srcdir)\n\nclean:\n\t@rm -rf cmds arch libmcount libtraceevent utils misc python\n\t@rm -f uftrace version.h *.o *.op\n\nprepare:\n\t@mkdir -p cmds arch/\\$(ARCH) libmcount libtraceevent utils misc python\n\ninstall:\n\t@\\$(MAKE) -C \\$(srcdir) install\n\ntest: all\n\t@\\$(MAKE) -C \\$(srcdir) test TESTARG=\"\\$(TESTARG)\"\n\n.PHONY: all clean prepare test install\nEOF\n    if [ $(id -u) -eq 0 ]; then\n        chmod 666 $objdir/Makefile\n    fi\nfi\n"
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "gdb",
          "type": "tree",
          "content": null
        },
        {
          "name": "libmcount",
          "type": "tree",
          "content": null
        },
        {
          "name": "misc",
          "type": "tree",
          "content": null
        },
        {
          "name": "pyproject.toml",
          "type": "blob",
          "size": 0.1484375,
          "content": "[tool.isort]\nprofile = \"black\"\nlines_between_types = 0\nlines_after_imports = 1\ncombine_as_imports = true\nignore_whitespace = true\nskip_gitignore = true\n"
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "uftrace-gdb.py",
          "type": "blob",
          "size": 0.650390625,
          "content": "#\n# gdb helper commands and functions for uftrace debugging\n# copied from the Linux kernel source\n#\n#  loader module\n#\n# Copyright (c) Siemens AG, 2012, 2013\n#\n# Authors:\n#  Jan Kiszka <jan.kiszka@siemens.com>\n#\n# This work is licensed under the terms of the GNU GPL version 2.\n#\n\nimport os\n\nsys.path.insert(0, os.path.dirname(__file__) + \"/gdb\")\n\ntry:\n    gdb.parse_and_eval(\"0\")\n    gdb.execute(\"\", to_string=True)\nexcept:\n    gdb.write(\"NOTE: gdb 7.2 or later required for helper scripts to work.\\n\")\nelse:\n    import uftrace.lists\n    import uftrace.mcount\n    import uftrace.plthook\n    import uftrace.rbtree\n    import uftrace.trigger\n    import uftrace.utils\n"
        },
        {
          "name": "uftrace.c",
          "type": "blob",
          "size": 45.09375,
          "content": "/*\n * uftrace - Function (Graph) Tracer for Userspace\n *\n * Copyright (C) 2014-2018  LG Electronics\n * Author:  Namhyung Kim <namhyung@gmail.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#include <dirent.h>\n#include <fcntl.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n#include <time.h>\n#include <unistd.h>\n\n/* This should be defined before #include \"utils.h\" */\n#define PR_FMT \"uftrace\"\n\n#include \"uftrace.h\"\n#include \"utils/script.h\"\n#include \"utils/utils.h\"\n#include \"version.h\"\n\nstatic const char uftrace_version[] = \"uftrace \" UFTRACE_VERSION;\n\nstatic bool dbg_domain_set = false;\n\nstatic bool parsing_default_opts = false;\n\nenum uftrace_short_options {\n\tOPT_flat = 301,\n\tOPT_no_libcall,\n\tOPT_symbols,\n\tOPT_logfile,\n\tOPT_force,\n\tOPT_task,\n\tOPT_no_merge,\n\tOPT_nop,\n\tOPT_time,\n\tOPT_max_stack,\n\tOPT_host,\n\tOPT_port,\n\tOPT_nopager,\n\tOPT_avg_total,\n\tOPT_avg_self,\n\tOPT_color,\n\tOPT_disabled,\n\tOPT_trace,\n\tOPT_demangle,\n\tOPT_dbg_domain,\n\tOPT_report,\n\tOPT_column_view,\n\tOPT_column_offset,\n\tOPT_bind_not,\n\tOPT_task_newline,\n\tOPT_chrome_trace,\n\tOPT_flame_graph,\n\tOPT_graphviz,\n\tOPT_sample_time,\n\tOPT_diff,\n\tOPT_format,\n\tOPT_sort_column,\n\tOPT_tid_filter,\n\tOPT_num_thread,\n\tOPT_no_comment,\n\tOPT_libmcount_single,\n\tOPT_rt_prio,\n\tOPT_kernel_bufsize,\n\tOPT_kernel_skip_out,\n\tOPT_kernel_full,\n\tOPT_kernel_only,\n\tOPT_list_event,\n\tOPT_run_cmd,\n\tOPT_opt_file,\n\tOPT_keep_pid,\n\tOPT_diff_policy,\n\tOPT_event_full,\n\tOPT_record,\n\tOPT_no_args,\n\tOPT_libname,\n\tOPT_match_type,\n\tOPT_no_randomize_addr,\n\tOPT_no_event,\n\tOPT_no_sched,\n\tOPT_no_sched_preempt,\n\tOPT_signal,\n\tOPT_srcline,\n\tOPT_with_syms,\n\tOPT_clock,\n\tOPT_usage,\n\tOPT_libmcount_path,\n\tOPT_mermaid,\n\tOPT_library_path,\n\tOPT_loc_filter,\n};\n\n/* clang-format off */\n__used static const char uftrace_usage[] =\n\" uftrace -- function (graph) tracer for userspace\\n\"\n\"\\n\"\n\" usage: uftrace [COMMAND] [OPTION...] [<program>]\\n\"\n\"\\n\"\n\" COMMAND:\\n\"\n\"   record          Run a program and saves the trace data\\n\"\n\"   replay          Show program execution in the trace data\\n\"\n\"   report          Show performance statistics in the trace data\\n\"\n\"   live            Do record and replay in a row (default)\\n\"\n\"   info            Show system and program info in the trace data\\n\"\n\"   dump            Show low-level trace data\\n\"\n\"   recv            Save the trace data from network\\n\"\n\"   graph           Show function call graph in the trace data\\n\"\n\"   script          Run a script for recorded trace data\\n\"\n\"   tui             Show text user interface for graph and report\\n\"\n\"\\n\";\n\n__used static const char uftrace_help[] =\n\" OPTION:\\n\"\n\"      --avg-self             Show average/min/max of self function time\\n\"\n\"      --avg-total            Show average/min/max of total function time\\n\"\n\"  -a, --auto-args            Show arguments and return value of known functions\\n\"\n\"  -A, --argument=FUNC@arg[,arg,...]\\n\"\n\"                             Show function arguments\\n\"\n\"  -b, --buffer=SIZE          Size of tracing buffer (default: \"\n\tstringify(SHMEM_BUFFER_SIZE_KB) \"K)\\n\"\n\"      --chrome               Dump recorded data in chrome trace format\\n\"\n\"      --clock                Set clock source for timestamp (default: mono)\\n\"\n\"      --color=SET            Use color for output: yes, no, auto (default: auto)\\n\"\n\"      --column-offset=DEPTH  Offset of each column (default: \"\n\tstringify(OPT_COLUMN_OFFSET) \")\\n\"\n\"      --column-view          Print tasks in separate columns\\n\"\n\"  -C, --caller-filter=FUNC   Only trace callers of those FUNCs\\n\"\n\"  -d, --data=DATA            Use this DATA instead of uftrace.data\\n\"\n\"      --debug-domain=DOMAIN  Filter debugging domain\\n\"\n\"      --demangle=TYPE        C++ symbol demangling: full, simple, no\\n\"\n\"                             (default: simple)\\n\"\n\"      --diff=DATA            Report differences\\n\"\n\"      --diff-policy=POLICY   Control diff report policy\\n\"\n\"                             (default: 'abs,compact,no-percent')\\n\"\n\"      --disable              Start with tracing disabled (deprecated)\\n\"\n\"  -D, --depth=DEPTH          Trace functions within DEPTH\\n\"\n\"  -e, --estimate-return      Use only entry record type for safety\\n\"\n\"      --event-full           Show all events outside of function\\n\"\n\"  -E, --Event=EVENT          Enable EVENT to save more information\\n\"\n\"      --flame-graph          Dump recorded data in FlameGraph format\\n\"\n\"      --flat                 Use flat output format\\n\"\n\"      --force                Trace even if executable is not instrumented\\n\"\n\"      --format=FORMAT        Use FORMAT for output: normal, html (default: normal)\\n\"\n\"  -f, --output-fields=FIELD  Show FIELDs in the replay or graph output\\n\"\n\"  -F, --filter=FUNC          Only trace those FUNCs\\n\"\n\"  -g  --agent                Start an agent in mcount to listen to commands\\n\"\n\"      --graphviz             Dump recorded data in DOT format\\n\"\n\"  -H, --hide=FUNC            Hide FUNCs from trace\\n\"\n\"      --host=HOST            Send trace data to HOST instead of write to file\\n\"\n\"  -k, --kernel               Trace kernel functions also (if supported)\\n\"\n\"      --keep-pid             Keep same pid during execution of traced program\\n\"\n\"      --kernel-buffer=SIZE   Size of kernel tracing buffer (default: 1408K)\\n\"\n\"      --kernel-full          Show kernel functions outside of user\\n\"\n\"      --kernel-only          Dump kernel data only\\n\"\n\"      --kernel-skip-out      Skip kernel functions outside of user (deprecated)\\n\"\n\"  -K, --kernel-depth=DEPTH   Trace kernel functions within DEPTH\\n\"\n\"      --libmcount-single     Use single thread version of libmcount\\n\"\n\"      --list-event           List available events\\n\"\n\"  -L, --loc-filter=LOCATION  Only trace functions in the source LOCATION\\n\"\n\"      --logfile=FILE         Save log messages to this file\\n\"\n\"  -l, --nest-libcall         Show nested library calls\\n\"\n\"      --libname              Show libname name with symbol name\\n\"\n\"      --libmcount-path=PATH  Load libmcount libraries from this PATH\\n\"\n\"      --match=TYPE           Support pattern match: regex, glob (default:\\n\"\n\"                             regex)\\n\"\n\"      --max-stack=DEPTH      Set max stack depth to DEPTH (default: \"\n\tstringify(OPT_RSTACK_MAX) \")\\n\"\n\"      --no-args              Do not show arguments and return value\\n\"\n\"      --no-comment           Don't show comments of returned functions\\n\"\n\"      --no-event             Disable (default) events\\n\"\n\"      --no-sched             Disable schedule events\\n\"\n\"      --no-sched-preempt     Hide pre-emptive schedule event\\n\"\n\"                             but show regular(sleeping) schedule event\\n\"\n\"      --no-libcall           Don't trace library function calls\\n\"\n\"      --no-merge             Don't merge leaf functions\\n\"\n\"      --no-pager             Do not use pager\\n\"\n\"      --no-pltbind           Do not bind dynamic symbols (LD_BIND_NOT)\\n\"\n\"      --no-randomize-addr    Disable ASLR (Address Space Layout Randomization)\\n\"\n\"      --nop                  No operation (for performance test)\\n\"\n\"      --num-thread=NUM       Create NUM recorder threads\\n\"\n\"  -N, --notrace=FUNC         Don't trace those FUNCs\\n\"\n\"      --opt-file=FILE        Read command-line options from FILE\\n\"\n\"  -p  --pid=PID              PID of an interactive mcount instance\\n\"\n\"      --port=PORT            Use PORT for network connection (default: \"\n\tstringify(UFTRACE_RECV_PORT) \")\\n\"\n\"  -P, --patch=FUNC           Apply dynamic patching for FUNCs\\n\"\n\"      --record               Record a new trace data before running command\\n\"\n\"      --report               Show live report\\n\"\n\"      --rt-prio=PRIO         Record with real-time (FIFO) priority\\n\"\n\"  -r, --time-range=TIME~TIME Show output within the TIME(timestamp or elapsed time)\\n\"\n\"                             range only\\n\"\n\"      --run-cmd=CMDLINE      Command line that want to execute after tracing\\n\"\n\"                             data received\\n\"\n\"  -R, --retval=FUNC@retval   Show function return value\\n\"\n\"      --sample-time=TIME     Show flame graph with this sampling time\\n\"\n\"      --signal=SIG@act[,act,...]   Trigger action on those SIGnal\\n\"\n\"      --sort-column=INDEX    Sort diff report on column INDEX (default: 2)\\n\"\n\"      --srcline              Enable recording source line info\\n\"\n\"      --symbols              Print symbol tables\\n\"\n\"  -s, --sort=KEY[,KEY,...]   Sort reported functions by KEYs (default: \"\n\tstringify(OPT_SORT_COLUMN) \")\\n\"\n\"  -S, --script=SCRIPT        Run a given SCRIPT in function entry and exit\\n\"\n\"  -t, --time-filter=TIME     Hide small functions run less than the TIME\\n\"\n\"      --task                 Show task info instead\\n\"\n\"      --task-newline         Interleave a newline when task is changed\\n\"\n\"      --tid=TID[,TID,...]    Only replay those tasks\\n\"\n\"      --time                 Print time information\\n\"\n\"      --trace=STATE          Set the recording state: on, off (default: on)\\n\"\n\"  -T, --trigger=FUNC@act[,act,...]\\n\"\n\"                             Trigger action on those FUNCs\\n\"\n\"  -U, --unpatch=FUNC         Don't apply dynamic patching for FUNCs\\n\"\n\"  -v, --debug                Print debug messages\\n\"\n\"      --verbose              Print verbose (debug) messages\\n\"\n\"      --with-syms=DIR        Use symbol files in the DIR\\n\"\n\"  -W, --watch=POINT          Watch and report POINT if it's changed\\n\"\n\"  -Z, --size-filter=SIZE     Apply dynamic patching for functions bigger than SIZE\\n\"\n\"  -h, --help                 Give this help list\\n\"\n\"      --usage                Give a short usage message\\n\"\n\"  -V, --version              Print program version\\n\"\n\"\\n\"\n\" Try `man uftrace [COMMAND]' for more information.\\n\"\n\"\\n\";\n\n__used static const char uftrace_footer[] =\n\" Try `uftrace --help' or `man uftrace [COMMAND]' for more information.\\n\"\n\"\\n\";\n\nstatic const char uftrace_shopts[] =\n\t\"+aA:b:C:d:D:eE:f:F:ghH:kK:lL:N:p:P:r:R:s:S:t:T:U:vVW:Z:\";\n\n#define REQ_ARG(name, shopt) { #name, required_argument, 0, shopt }\n#define NO_ARG(name, shopt)  { #name, no_argument, 0, shopt }\n\nstatic const struct option uftrace_options[] = {\n\tREQ_ARG(libmcount-path, OPT_libmcount_path),\n\tREQ_ARG(library-path, OPT_libmcount_path),\n\tREQ_ARG(filter, 'F'),\n\tREQ_ARG(notrace, 'N'),\n\tREQ_ARG(depth, 'D'),\n\tREQ_ARG(time-filter, 't'),\n\tREQ_ARG(caller-filter, 'C'),\n\tREQ_ARG(argument, 'A'),\n\tREQ_ARG(trigger, 'T'),\n\tREQ_ARG(retval, 'R'),\n\tNO_ARG(auto-args, 'a'),\n\tNO_ARG(no-args, OPT_no_args),\n\tREQ_ARG(patch, 'P'),\n\tREQ_ARG(unpatch, 'U'),\n\tREQ_ARG(size-filter, 'Z'),\n\tNO_ARG(debug, 'v'),\n\tNO_ARG(verbose, 'v'),\n\tREQ_ARG(debug-domain, OPT_dbg_domain),\n\tNO_ARG(force, OPT_force),\n\tREQ_ARG(data, 'd'),\n\tNO_ARG(flat, OPT_flat),\n\tNO_ARG(symbols, OPT_symbols),\n\tREQ_ARG(buffer, 'b'),\n\tREQ_ARG(logfile, OPT_logfile),\n\tNO_ARG(task, OPT_task),\n\tREQ_ARG(tid, OPT_tid_filter),\n\tNO_ARG(no-merge, OPT_no_merge),\n\tNO_ARG(nop, OPT_nop),\n\tNO_ARG(time, OPT_time),\n\tREQ_ARG(max-stack, OPT_max_stack),\n\tREQ_ARG(host, OPT_host),\n\tREQ_ARG(port, OPT_port),\n\tNO_ARG(no-pager, OPT_nopager),\n\tREQ_ARG(sort, 's'),\n\tNO_ARG(avg-total, OPT_avg_total),\n\tNO_ARG(avg-self, OPT_avg_self),\n\tREQ_ARG(color, OPT_color),\n\tNO_ARG(disable, OPT_disabled),\n\tREQ_ARG(trace, OPT_trace),\n\tREQ_ARG(demangle, OPT_demangle),\n\tNO_ARG(record, OPT_record),\n\tNO_ARG(report, OPT_report),\n\tNO_ARG(column-view, OPT_column_view),\n\tREQ_ARG(column-offset, OPT_column_offset),\n\tNO_ARG(no-pltbind, OPT_bind_not),\n\tNO_ARG(task-newline, OPT_task_newline),\n\tNO_ARG(chrome, OPT_chrome_trace),\n\tNO_ARG(graphviz, OPT_graphviz),\n\tNO_ARG(flame-graph, OPT_flame_graph),\n\tNO_ARG(mermaid, OPT_mermaid),\n\tREQ_ARG(sample-time, OPT_sample_time),\n\tREQ_ARG(diff, OPT_diff),\n\tREQ_ARG(format, OPT_format),\n\tREQ_ARG(sort-column, OPT_sort_column),\n\tREQ_ARG(num-thread, OPT_num_thread),\n\tNO_ARG(no-comment, OPT_no_comment),\n\tNO_ARG(libmcount-single, OPT_libmcount_single),\n\tREQ_ARG(rt-prio, OPT_rt_prio),\n\tNO_ARG(kernel, 'k'),\n\tREQ_ARG(kernel-depth, 'K'),\n\tREQ_ARG(kernel-buffer, OPT_kernel_bufsize),\n\tNO_ARG(kernel-skip-out, OPT_kernel_skip_out),\n\tNO_ARG(kernel-full, OPT_kernel_full),\n\tNO_ARG(kernel-only, OPT_kernel_only),\n\tREQ_ARG(output-fields, 'f'),\n\tREQ_ARG(time-range, 'r'),\n\tREQ_ARG(Event, 'E'),\n\tNO_ARG(no-event, OPT_no_event),\n\tNO_ARG(no-sched, OPT_no_sched),\n\tNO_ARG(no-sched-preempt, OPT_no_sched_preempt),\n\tNO_ARG(list-event, OPT_list_event),\n\tREQ_ARG(run-cmd, OPT_run_cmd),\n\tREQ_ARG(opt-file, OPT_opt_file),\n\tNO_ARG(keep-pid, OPT_keep_pid),\n\tREQ_ARG(script, 'S'),\n\tREQ_ARG(diff-policy, OPT_diff_policy),\n\tNO_ARG(event-full, OPT_event_full),\n\tNO_ARG(no-libcall, OPT_no_libcall),\n\tNO_ARG(nest-libcall, 'l'),\n\tNO_ARG(libname, OPT_libname),\n\tREQ_ARG(match, OPT_match_type),\n\tNO_ARG(no-randomize-addr, OPT_no_randomize_addr),\n\tREQ_ARG(watch, 'W'),\n\tREQ_ARG(signal, OPT_signal),\n\tNO_ARG(srcline, OPT_srcline),\n\tREQ_ARG(hide, 'H'),\n\tREQ_ARG(loc-filter, OPT_loc_filter),\n\tREQ_ARG(loc-filter-warning, 'L'), /* the long option is dummy, will change later */\n\tREQ_ARG(clock, OPT_clock),\n\tNO_ARG(help, 'h'),\n\tNO_ARG(usage, OPT_usage),\n\tNO_ARG(version, 'V'),\n\tNO_ARG(estimate-return, 'e'),\n\tREQ_ARG(with-syms, OPT_with_syms),\n\tNO_ARG(agent, 'g'),\n\tREQ_ARG(pid, 'p'),\n\t{ 0 }\n};\n/* clang-format on */\n\n#undef REQ_ARG\n#undef NO_ARG\n\nstatic unsigned long parse_size(char *str)\n{\n\tunsigned long size;\n\tchar *unit;\n\n\tsize = strtoul(str, &unit, 0);\n\tswitch (*unit) {\n\tcase '\\0':\n\t\tbreak;\n\tcase 'k':\n\tcase 'K':\n\t\tsize <<= 10;\n\t\tbreak;\n\tcase 'm':\n\tcase 'M':\n\t\tsize <<= 20;\n\t\tbreak;\n\tcase 'g':\n\tcase 'G':\n\t\tsize <<= 30;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_use(\"invalid size: %s\\n\", str);\n\t\tsize = 0;\n\t\tbreak;\n\t}\n\n\treturn size;\n}\n\nstatic char *opt_add_string(char *old_opt, char *new_opt)\n{\n\treturn strjoin(old_opt, new_opt, \";\");\n}\n\nstatic char *opt_add_prefix_string(char *old_opt, char *prefix, char *new_opt)\n{\n\tnew_opt = strjoin(xstrdup(prefix), new_opt, \"\");\n\n\tif (old_opt) {\n\t\told_opt = strjoin(old_opt, new_opt, \";\");\n\t\tfree(new_opt);\n\t\tnew_opt = old_opt;\n\t}\n\n\treturn new_opt;\n}\n\nstatic const char *true_str[] = {\n\t\"true\", \"yes\", \"on\", \"y\", \"1\",\n};\n\nstatic const char *false_str[] = {\n\t\"false\", \"no\", \"off\", \"n\", \"0\",\n};\n\nstatic enum color_setting parse_color(char *arg)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(true_str); i++) {\n\t\tif (!strcmp(arg, true_str[i]))\n\t\t\treturn COLOR_ON;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(false_str); i++) {\n\t\tif (!strcmp(arg, false_str[i]))\n\t\t\treturn COLOR_OFF;\n\t}\n\n\tif (!strcmp(arg, \"auto\"))\n\t\treturn COLOR_AUTO;\n\n\treturn COLOR_UNKNOWN;\n}\n\nstatic int parse_demangle(char *arg)\n{\n\tsize_t i;\n\n\tif (!strcmp(arg, \"simple\"))\n\t\treturn DEMANGLE_SIMPLE;\n\n\tif (!strcmp(arg, \"full\")) {\n\t\tif (support_full_demangle())\n\t\t\treturn DEMANGLE_FULL;\n\t\treturn DEMANGLE_NOT_SUPPORTED;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(false_str); i++) {\n\t\tif (!strcmp(arg, false_str[i]))\n\t\t\treturn DEMANGLE_NONE;\n\t}\n\n\treturn DEMANGLE_ERROR;\n}\n\nstatic void parse_debug_domain(char *arg)\n{\n\tstruct strv strv = STRV_INIT;\n\tchar *tok, *tmp;\n\tint i;\n\n\tstrv_split(&strv, arg, \",\");\n\n\tstrv_for_each(&strv, tok, i) {\n\t\tint level = -1;\n\n\t\ttmp = strchr(tok, ':');\n\t\tif (tmp) {\n\t\t\t*tmp++ = '\\0';\n\t\t\tlevel = strtol(tmp, NULL, 0);\n\t\t}\n\n\t\tif (!strcmp(tok, \"ftrace\")) /* for backward compatibility */\n\t\t\tdbg_domain[DBG_UFTRACE] = level;\n\t\telse if (!strcmp(tok, \"uftrace\"))\n\t\t\tdbg_domain[DBG_UFTRACE] = level;\n\t\telse if (!strcmp(tok, \"symbol\"))\n\t\t\tdbg_domain[DBG_SYMBOL] = level;\n\t\telse if (!strcmp(tok, \"demangle\"))\n\t\t\tdbg_domain[DBG_DEMANGLE] = level;\n\t\telse if (!strcmp(tok, \"filter\"))\n\t\t\tdbg_domain[DBG_FILTER] = level;\n\t\telse if (!strcmp(tok, \"fstack\"))\n\t\t\tdbg_domain[DBG_FSTACK] = level;\n\t\telse if (!strcmp(tok, \"session\"))\n\t\t\tdbg_domain[DBG_SESSION] = level;\n\t\telse if (!strcmp(tok, \"kernel\"))\n\t\t\tdbg_domain[DBG_KERNEL] = level;\n\t\telse if (!strcmp(tok, \"mcount\"))\n\t\t\tdbg_domain[DBG_MCOUNT] = level;\n\t\telse if (!strcmp(tok, \"plthook\"))\n\t\t\tdbg_domain[DBG_PLTHOOK] = level;\n\t\telse if (!strcmp(tok, \"dynamic\"))\n\t\t\tdbg_domain[DBG_DYNAMIC] = level;\n\t\telse if (!strcmp(tok, \"event\"))\n\t\t\tdbg_domain[DBG_EVENT] = level;\n\t\telse if (!strcmp(tok, \"script\"))\n\t\t\tdbg_domain[DBG_SCRIPT] = level;\n\t\telse if (!strcmp(tok, \"dwarf\"))\n\t\t\tdbg_domain[DBG_DWARF] = level;\n\t\telse if (!strcmp(tok, \"wrap\"))\n\t\t\tdbg_domain[DBG_WRAP] = level;\n\t}\n\n\tdbg_domain_set = true;\n\tstrv_free(&strv);\n}\n\nstatic bool has_time_unit(const char *str)\n{\n\tif (isalpha(str[strlen(str) - 1]))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic uint64_t parse_any_timestamp(char *str, bool *elapsed)\n{\n\tif (*str == '\\0')\n\t\treturn 0;\n\n\tif (has_time_unit(str)) {\n\t\t*elapsed = true;\n\t\treturn parse_time(str, 3);\n\t}\n\n\t*elapsed = false;\n\treturn parse_timestamp(str);\n}\n\nstatic bool parse_time_range(struct uftrace_time_range *range, char *arg)\n{\n\tchar *str, *pos;\n\n\tstr = xstrdup(arg);\n\n\tpos = strchr(str, '~');\n\tif (pos == NULL) {\n\t\tfree(str);\n\t\treturn false;\n\t}\n\n\t*pos++ = '\\0';\n\n\trange->start = parse_any_timestamp(str, &range->start_elapsed);\n\trange->stop = parse_any_timestamp(pos, &range->stop_elapsed);\n\n\tfree(str);\n\treturn true;\n}\n\nstatic char *remove_trailing_slash(char *path)\n{\n\tsize_t len = strlen(path);\n\n\tif (path[len - 1] == '/')\n\t\tpath[len - 1] = '\\0';\n\n\treturn path;\n}\n\nstatic bool is_libmcount_directory(const char *path)\n{\n\tDIR *dp = NULL;\n\tstruct dirent *ent;\n\tint ret = false;\n\n\tdp = opendir(path);\n\tif (dp == NULL)\n\t\treturn false;\n\n\twhile ((ent = readdir(dp)) != NULL) {\n\t\tif ((ent->d_type == DT_DIR && !strcmp(ent->d_name, \"libmcount\")) ||\n\t\t    ((ent->d_type == DT_LNK || ent->d_type == DT_REG) &&\n\t\t     !strcmp(ent->d_name, \"libmcount.so\"))) {\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tclosedir(dp);\n\treturn ret;\n}\n\nstatic int parse_option(struct uftrace_opts *opts, int key, char *arg)\n{\n\tchar *pos;\n\n\tswitch (key) {\n\tcase 'F':\n\t\topts->filter = opt_add_string(opts->filter, arg);\n\t\tbreak;\n\n\tcase 'N':\n\t\topts->filter = opt_add_prefix_string(opts->filter, \"!\", arg);\n\t\tbreak;\n\n\tcase 'T':\n\t\topts->trigger = opt_add_string(opts->trigger, arg);\n\t\tbreak;\n\n\tcase 'D':\n\t\topts->depth = strtol(arg, NULL, 0);\n\t\tif (opts->depth <= 0 || opts->depth >= OPT_DEPTH_MAX) {\n\t\t\tpr_use(\"invalid depth given: %s (ignoring..)\\n\", arg);\n\t\t\topts->depth = OPT_DEPTH_DEFAULT;\n\t\t}\n\t\tbreak;\n\n\tcase 'C':\n\t\topts->caller = opt_add_string(opts->caller, arg);\n\t\t/*\n\t\t * caller filter focuses onto a given function,\n\t\t * displaying sched event with it is annoying.\n\t\t */\n\t\topts->no_sched = true;\n\t\tbreak;\n\n\tcase 'H':\n\t\topts->hide = opt_add_string(opts->hide, arg);\n\t\tbreak;\n\n\tcase 'L':\n\t\tif (is_libmcount_directory(arg))\n\t\t\tpr_warn(\"--libmcount-path option should be used to set libmcount path.\\n\");\n\t\t/* fall through */\n\tcase OPT_loc_filter:\n\t\tpos = strstr(arg, \"@hide\");\n\t\tif (!pos)\n\t\t\topts->loc_filter = opt_add_string(opts->loc_filter, arg);\n\t\telse {\n\t\t\t*pos = '\\0';\n\t\t\topts->loc_filter = opt_add_prefix_string(opts->loc_filter, \"!\", arg);\n\t\t}\n\t\t/*\n\t\t * location filter focuses onto a given location,\n\t\t * displaying sched event with it is annoying.\n\t\t */\n\t\topts->no_sched = true;\n\t\tbreak;\n\n\tcase 'v':\n\t\tdebug++;\n\t\tbreak;\n\n\tcase 'd':\n\t\topts->dirname = remove_trailing_slash(arg);\n\t\tbreak;\n\n\tcase 'b':\n\t\topts->bufsize = parse_size(arg);\n\t\tif (opts->bufsize & (getpagesize() - 1)) {\n\t\t\tpr_use(\"buffer size should be multiple of page size\\n\");\n\t\t\topts->bufsize = ROUND_UP(opts->bufsize, getpagesize());\n\t\t}\n\t\tbreak;\n\n\tcase 'k':\n\t\topts->kernel = true;\n\t\topts->kernel_depth = 1;\n\t\tbreak;\n\n\tcase 'K':\n\t\topts->kernel = true;\n\t\topts->kernel_depth = strtol(arg, NULL, 0);\n\t\tif (opts->kernel_depth < 1 || opts->kernel_depth > 50) {\n\t\t\tpr_use(\"invalid kernel depth: %s. Set depth to 1.\\n\", arg);\n\t\t\topts->kernel_depth = 1;\n\t\t}\n\t\tbreak;\n\n\tcase 's':\n\t\topts->sort_keys = opt_add_string(opts->sort_keys, arg);\n\t\tbreak;\n\n\tcase 'S':\n\t\topts->script_file = arg;\n\t\tbreak;\n\n\tcase 't':\n\t\t/* do not override time-filter or time-range if it's already set */\n\t\tif (parsing_default_opts) {\n\t\t\tif (opts->threshold || opts->range.start || opts->range.stop)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* add time-filter to uftrace.data/default.opts */\n\t\tstrv_append(&default_opts, \"-t\");\n\t\tstrv_append(&default_opts, arg);\n\n\t\topts->threshold = parse_time(arg, 3);\n\t\tif (opts->threshold >= OPT_THRESHOLD_MAX) {\n\t\t\tpr_use(\"invalid time given: %lu (ignoring..)\\n\", opts->threshold);\n\t\t\topts->threshold = OPT_THRESHOLD_MAX - 1;\n\t\t}\n\t\tif (opts->range.start || opts->range.stop) {\n\t\t\tpr_use(\"--time-range cannot be used with --time-filter\\n\");\n\t\t\topts->range.start = opts->range.stop = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 'A':\n\t\topts->args = opt_add_string(opts->args, arg);\n\t\tbreak;\n\n\tcase 'R':\n\t\topts->retval = opt_add_string(opts->retval, arg);\n\t\tbreak;\n\n\tcase 'a':\n\t\topts->auto_args = true;\n\t\tbreak;\n\n\tcase 'l':\n\t\t/* --nest-libcall implies --force option */\n\t\topts->force = true;\n\t\topts->nest_libcall = true;\n\t\tbreak;\n\n\tcase 'f':\n\t\topts->fields = arg;\n\t\tbreak;\n\n\tcase 'r':\n\t\tif (!parse_time_range(&opts->range, arg))\n\t\t\tpr_use(\"invalid time range: %s (ignoring...)\\n\", arg);\n\t\tif (opts->threshold) {\n\t\t\tpr_use(\"--time-filter cannot be used with --time-range\\n\");\n\t\t\topts->threshold = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 'P':\n\t\topts->patch = opt_add_string(opts->patch, arg);\n\t\tbreak;\n\n\tcase 'U':\n\t\topts->patch = opt_add_prefix_string(opts->patch, \"!\", arg);\n\t\tbreak;\n\n\tcase 'Z':\n\t\topts->size_filter = strtol(arg, NULL, 0);\n\t\tif (opts->size_filter <= 0) {\n\t\t\tpr_use(\"--size-filter should be positive\\n\");\n\t\t\topts->size_filter = 0;\n\t\t}\n\t\tbreak;\n\n\tcase 'E':\n\t\tif (!strcmp(arg, \"list\")) {\n\t\t\tpr_use(\"'-E list' is deprecated, use --list-event instead.\\n\");\n\t\t\topts->list_event = true;\n\t\t}\n\t\telse\n\t\t\topts->event = opt_add_string(opts->event, arg);\n\t\tbreak;\n\n\tcase 'W':\n\t\topts->watch = opt_add_string(opts->watch, arg);\n\t\tbreak;\n\n\tcase 'e':\n\t\topts->estimate_return = true;\n\t\tbreak;\n\n\tcase 'V':\n\t\tpr_out(\"%s\\n\", uftrace_version);\n\t\treturn -1;\n\n\tcase 'g':\n\t\topts->agent = true;\n\t\tbreak;\n\n\tcase 'h':\n\t\treturn -3;\n\n\tcase 'p':\n\t\topts->pid = strtol(arg, NULL, 0);\n\t\topts->exename = \"\";\n\t\tbreak;\n\n\tcase OPT_libmcount_path:\n\t\topts->lib_path = arg;\n\t\tbreak;\n\n\tcase OPT_usage:\n\t\treturn -2;\n\n\tcase OPT_flat:\n\t\topts->flat = true;\n\t\tbreak;\n\n\tcase OPT_no_libcall:\n\t\topts->libcall = false;\n\t\tbreak;\n\n\tcase OPT_symbols:\n\t\topts->print_symtab = true;\n\t\tbreak;\n\n\tcase OPT_logfile:\n\t\topts->logfile = arg;\n\t\tbreak;\n\n\tcase OPT_force:\n\t\topts->force = true;\n\t\tbreak;\n\n\tcase OPT_task:\n\t\topts->show_task = true;\n\t\tbreak;\n\n\tcase OPT_tid_filter:\n\t\tif (strtol(arg, NULL, 0) <= 0)\n\t\t\tpr_use(\"invalid thread id: %s\\n\", arg);\n\t\telse\n\t\t\topts->tid = opt_add_string(opts->tid, arg);\n\t\tbreak;\n\n\tcase OPT_no_merge:\n\t\topts->no_merge = true;\n\t\tbreak;\n\n\tcase OPT_nop:\n\t\topts->nop = true;\n\t\tbreak;\n\n\tcase OPT_time:\n\t\topts->time = true;\n\t\tbreak;\n\n\tcase OPT_max_stack:\n\t\topts->max_stack = strtol(arg, NULL, 0);\n\t\tif (opts->max_stack <= 0 || opts->max_stack > OPT_RSTACK_MAX) {\n\t\t\tpr_use(\"max stack depth should be >0 and <%d\\n\", OPT_RSTACK_MAX);\n\t\t\topts->max_stack = OPT_RSTACK_DEFAULT;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_host:\n\t\topts->host = arg;\n\t\tbreak;\n\n\tcase OPT_port:\n\t\topts->port = strtol(arg, NULL, 0);\n\t\tif (opts->port <= 0) {\n\t\t\tpr_use(\"invalid port number: %s (ignoring..)\\n\", arg);\n\t\t\topts->port = UFTRACE_RECV_PORT;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_nopager:\n\t\topts->use_pager = false;\n\t\tbreak;\n\n\tcase OPT_avg_total:\n\t\topts->avg_total = true;\n\t\tbreak;\n\n\tcase OPT_avg_self:\n\t\topts->avg_self = true;\n\t\tbreak;\n\n\tcase OPT_color:\n\t\topts->color = parse_color(arg);\n\t\tif (opts->color == COLOR_UNKNOWN) {\n\t\t\tpr_use(\"unknown color setting: %s (ignoring..)\\n\", arg);\n\t\t\topts->color = COLOR_AUTO;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_disabled:\n\t\tpr_use(\"'--disable' is deprecated, use --trace=off instead.\\n\");\n\t\topts->trace = TRACE_STATE_OFF;\n\t\tbreak;\n\n\tcase OPT_trace:\n\t\tif (!strcmp(arg, \"on\"))\n\t\t\topts->trace = TRACE_STATE_ON;\n\t\telse if (!strcmp(arg, \"off\"))\n\t\t\topts->trace = TRACE_STATE_OFF;\n\t\telse\n\t\t\tpr_use(\"unknown tracing state: %s (ignoring..)\\n\", arg);\n\t\tbreak;\n\n\tcase OPT_demangle:\n\t\tdemangler = parse_demangle(arg);\n\t\tif (demangler == DEMANGLE_ERROR) {\n\t\t\tpr_use(\"unknown demangle value: %s (ignoring..)\\n\", arg);\n\t\t\tdemangler = DEMANGLE_SIMPLE;\n\t\t}\n\t\telse if (demangler == DEMANGLE_NOT_SUPPORTED) {\n\t\t\tpr_use(\"'%s' demangler is not supported\\n\", arg);\n\t\t\tdemangler = DEMANGLE_SIMPLE;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_dbg_domain:\n\t\tparse_debug_domain(arg);\n\t\tbreak;\n\n\tcase OPT_report:\n\t\topts->report = true;\n\t\tbreak;\n\n\tcase OPT_column_view:\n\t\topts->column_view = true;\n\t\tbreak;\n\n\tcase OPT_column_offset:\n\t\topts->column_offset = strtol(arg, NULL, 0);\n\t\tif (opts->column_offset < 0)\n\t\t\topts->column_offset = OPT_COLUMN_OFFSET;\n\t\tbreak;\n\n\tcase OPT_bind_not:\n\t\topts->want_bind_not = true;\n\t\tbreak;\n\n\tcase OPT_task_newline:\n\t\topts->task_newline = true;\n\t\tbreak;\n\n\tcase OPT_chrome_trace:\n\t\topts->chrome_trace = true;\n\t\tbreak;\n\n\tcase OPT_flame_graph:\n\t\topts->flame_graph = true;\n\t\tbreak;\n\n\tcase OPT_graphviz:\n\t\topts->graphviz = true;\n\t\tbreak;\n\n\tcase OPT_diff:\n\t\topts->diff = arg;\n\t\tbreak;\n\n\tcase OPT_diff_policy:\n\t\topts->diff_policy = arg;\n\t\tbreak;\n\n\tcase OPT_format:\n\t\tif (!strcmp(arg, \"normal\"))\n\t\t\tformat_mode = FORMAT_NORMAL;\n\t\telse if (!strcmp(arg, \"html\")) {\n\t\t\tformat_mode = FORMAT_HTML;\n\t\t\tif (opts->color == COLOR_AUTO)\n\t\t\t\topts->color = COLOR_ON;\n\t\t}\n\t\telse {\n\t\t\tpr_use(\"invalid format argument: %s\\n\", arg);\n\t\t\tformat_mode = FORMAT_NORMAL;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_sort_column:\n\t\topts->sort_column = strtol(arg, NULL, 0);\n\t\tif (opts->sort_column < 0 || opts->sort_column > OPT_SORT_COLUMN) {\n\t\t\tpr_use(\"invalid column number: %d\\n\", opts->sort_column);\n\t\t\tpr_use(\"force to set it to --sort-column=%d for diff percentage\\n\",\n\t\t\t       OPT_SORT_COLUMN);\n\t\t\topts->sort_column = OPT_SORT_COLUMN;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_num_thread:\n\t\topts->nr_thread = strtol(arg, NULL, 0);\n\t\tif (opts->nr_thread < 0) {\n\t\t\tpr_use(\"invalid thread number: %s\\n\", arg);\n\t\t\topts->nr_thread = 0;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_no_comment:\n\t\topts->comment = false;\n\t\tbreak;\n\n\tcase OPT_libmcount_single:\n\t\topts->libmcount_single = true;\n\t\tbreak;\n\n\tcase OPT_rt_prio:\n\t\topts->rt_prio = strtol(arg, NULL, 0);\n\t\tif (opts->rt_prio < 1 || opts->rt_prio > 99) {\n\t\t\tpr_use(\"invalid rt prioity: %d (ignoring...)\\n\", opts->rt_prio);\n\t\t\topts->rt_prio = 0;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_kernel_bufsize:\n\t\topts->kernel_bufsize = parse_size(arg);\n\t\tif (opts->kernel_bufsize & (getpagesize() - 1)) {\n\t\t\tpr_use(\"buffer size should be multiple of page size\\n\");\n\t\t\topts->kernel_bufsize = ROUND_UP(opts->kernel_bufsize, getpagesize());\n\t\t}\n\t\tbreak;\n\n\tcase OPT_kernel_skip_out: /* deprecated */\n\t\topts->kernel_skip_out = true;\n\t\tbreak;\n\n\tcase OPT_kernel_full:\n\t\topts->kernel_skip_out = false;\n\t\t/* see setup_kernel_tracing() also */\n\t\tbreak;\n\n\tcase OPT_kernel_only:\n\t\topts->kernel_only = true;\n\t\tbreak;\n\n\tcase OPT_sample_time:\n\t\topts->sample_time = parse_time(arg, 9);\n\t\tbreak;\n\n\tcase OPT_list_event:\n\t\topts->list_event = true;\n\t\tbreak;\n\n\tcase OPT_run_cmd:\n\t\tif (opts->run_cmd) {\n\t\t\tpr_warn(\"intermediate --run-cmd argument is ignored.\\n\");\n\t\t\tfree_parsed_cmdline(opts->run_cmd);\n\t\t}\n\t\topts->run_cmd = parse_cmdline(arg, NULL);\n\t\tbreak;\n\n\tcase OPT_opt_file:\n\t\topts->opt_file = arg;\n\t\tbreak;\n\n\tcase OPT_keep_pid:\n\t\topts->keep_pid = true;\n\t\tbreak;\n\n\tcase OPT_event_full:\n\t\topts->event_skip_out = false;\n\t\tbreak;\n\n\tcase OPT_record:\n\t\topts->record = true;\n\t\tbreak;\n\n\tcase OPT_no_args:\n\t\topts->show_args = false;\n\t\tbreak;\n\n\tcase OPT_libname:\n\t\topts->libname = true;\n\t\tbreak;\n\n\tcase OPT_match_type:\n\t\topts->patt_type = parse_filter_pattern(arg);\n\t\tif (opts->patt_type == PATT_NONE) {\n\t\t\tpr_use(\"invalid match pattern: %s (ignoring...)\\n\", arg);\n\t\t\topts->patt_type = PATT_REGEX;\n\t\t}\n\t\tbreak;\n\n\tcase OPT_no_randomize_addr:\n\t\topts->no_randomize_addr = true;\n\t\tbreak;\n\n\tcase OPT_no_event:\n\t\topts->no_event = true;\n\t\tbreak;\n\n\tcase OPT_no_sched:\n\t\topts->no_sched = true;\n\t\tbreak;\n\n\tcase OPT_no_sched_preempt:\n\t\topts->no_sched_preempt = true;\n\t\tbreak;\n\n\tcase OPT_signal:\n\t\topts->sig_trigger = opt_add_string(opts->sig_trigger, arg);\n\t\tbreak;\n\n\tcase OPT_srcline:\n\t\topts->srcline = true;\n\t\tbreak;\n\n\tcase OPT_with_syms:\n\t\topts->with_syms = arg;\n\t\tbreak;\n\n\tcase OPT_clock:\n\t\tif (strcmp(arg, \"mono\") && strcmp(arg, \"mono_raw\") && strcmp(arg, \"boot\")) {\n\t\t\tpr_use(\"invalid clock source: '%s' \"\n\t\t\t       \"(force to use 'mono')\\n\",\n\t\t\t       arg);\n\t\t\targ = \"mono\";\n\t\t}\n\t\topts->clock = arg;\n\t\tbreak;\n\n\tcase OPT_mermaid:\n\t\topts->mermaid = true;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nstatic void update_subcmd(struct uftrace_opts *opts, char *cmd)\n{\n\tif (!strcmp(cmd, \"record\"))\n\t\topts->mode = UFTRACE_MODE_RECORD;\n\telse if (!strcmp(cmd, \"replay\"))\n\t\topts->mode = UFTRACE_MODE_REPLAY;\n\telse if (!strcmp(cmd, \"report\"))\n\t\topts->mode = UFTRACE_MODE_REPORT;\n\telse if (!strcmp(cmd, \"live\"))\n\t\topts->mode = UFTRACE_MODE_LIVE;\n\telse if (!strcmp(cmd, \"graph\"))\n\t\topts->mode = UFTRACE_MODE_GRAPH;\n\telse if (!strcmp(cmd, \"info\"))\n\t\topts->mode = UFTRACE_MODE_INFO;\n\telse if (!strcmp(cmd, \"dump\"))\n\t\topts->mode = UFTRACE_MODE_DUMP;\n\telse if (!strcmp(cmd, \"recv\"))\n\t\topts->mode = UFTRACE_MODE_RECV;\n\telse if (!strcmp(cmd, \"script\"))\n\t\topts->mode = UFTRACE_MODE_SCRIPT;\n\telse if (!strcmp(cmd, \"tui\"))\n\t\topts->mode = UFTRACE_MODE_TUI;\n\telse\n\t\topts->mode = UFTRACE_MODE_INVALID;\n}\n\nstatic void parse_opt_file(int *argc, char ***argv, char *filename, struct uftrace_opts *opts)\n{\n\tint file_argc;\n\tchar **file_argv;\n\tchar *buf;\n\tstruct stat stbuf;\n\tFILE *fp;\n\tchar *orig_exename = opts->exename;\n\tbool has_subcmd = false;\n\n\tif (stat(filename, &stbuf) < 0) {\n\t\tpr_use(\"Cannot use opt-file: %s: %m\\n\", filename);\n\t\texit(0);\n\t}\n\n\t/* prepend dummy string since getopt_long cannot process argv[0] */\n\tbuf = xmalloc(stbuf.st_size + 9);\n\tstrncpy(buf, \"uftrace \", 9);\n\n\tfp = fopen(filename, \"r\");\n\tif (fp == NULL)\n\t\tpr_err(\"Open failed: %s\", filename);\n\tfread_all(buf + 8, stbuf.st_size, fp);\n\tfclose(fp);\n\tbuf[stbuf.st_size + 8] = '\\0';\n\n\tfile_argv = parse_cmdline(buf, &file_argc);\n\n\t/* clear opt_file for error reporting */\n\topts->opt_file = NULL;\n\n\t/* re-initialize getopt as we start another round */\n\toptind = 0;\n\n\tif (file_argv[1][0] != '-') {\n\t\tint orig_mode = opts->mode;\n\n\t\tupdate_subcmd(opts, file_argv[1]);\n\n\t\tif (opts->mode == UFTRACE_MODE_INVALID) {\n\t\t\topts->mode = orig_mode;\n\t\t\thas_subcmd = true;\n\t\t}\n\t\telse {\n\t\t\tif (orig_mode != UFTRACE_MODE_INVALID && orig_mode != opts->mode) {\n\t\t\t\tpr_use(\"ignore uftrace command in opt-file\\n\");\n\t\t\t\topts->mode = orig_mode;\n\t\t\t}\n\t\t\telse {\n\t\t\t\thas_subcmd = true;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (true) {\n\t\tint key, tmp = 0;\n\n\t\tkey = getopt_long(file_argc, file_argv, uftrace_shopts, uftrace_options, &tmp);\n\t\tif (key == -1 || key == '?') {\n\t\t\tif (has_subcmd && optind == 1)\n\t\t\t\toptind++;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tparse_option(opts, key, optarg);\n\t}\n\n\t/* overwrite argv only if it's not given on command line */\n\tif (orig_exename == NULL && optind < file_argc) {\n\t\t*argc = file_argc;\n\t\t*argv = file_argv;\n\n\t\topts->idx = optind;\n\t\topts->exename = file_argv[optind];\n\n\t\t/* mark it to free at the end */\n\t\topts->opt_file = filename;\n\t}\n\telse {\n\t\topts->exename = orig_exename;\n\t\tfree_parsed_cmdline(file_argv);\n\t}\n\n\tfree(buf);\n}\n\n/*\n * Parse options in a script file header.  For example,\n *\n *   # uftrace-option: -F main -A malloc@arg1\n *   def uftrace_entry():\n *     pass\n *   ...\n *\n * Note that it only handles some options like filter, trigger,\n * argument, return values and maybe some more.\n */\nvoid parse_script_opt(struct uftrace_opts *opts)\n{\n\tFILE *fp;\n\tint opt_argc;\n\tchar **opt_argv;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tstatic const char optname[] = \"uftrace-option\";\n\tenum script_type_t script_type;\n\tconst char *comments[SCRIPT_TYPE_COUNT] = { \"\", \"#\", \"--\" };\n\tconst char *comment;\n\tsize_t comment_len;\n\n\tif (opts->script_file == NULL)\n\t\treturn;\n\n\tfp = fopen(opts->script_file, \"r\");\n\tif (fp == NULL)\n\t\tpr_err(\"cannot open script file: %s\", opts->script_file);\n\n\tscript_type = get_script_type(opts->script_file);\n\n\tif (script_type == SCRIPT_UNKNOWN) {\n\t\tfclose(fp);\n\t\tpr_err(\"unknown script type\");\n\t}\n\n\tcomment = comments[script_type];\n\tcomment_len = strlen(comment);\n\n\twhile (getline(&line, &len, fp) > 0) {\n\t\tchar *pos;\n\n\t\tif (strncmp(line, comment, comment_len))\n\t\t\tcontinue;\n\n\t\tpos = line + comment_len;\n\t\twhile (isspace(*pos))\n\t\t\tpos++;\n\n\t\tif (strncmp(pos, optname, strlen(optname)))\n\t\t\tcontinue;\n\n\t\t/* extract option value */\n\t\tpos = strchr(line, ':');\n\t\tif (pos == NULL)\n\t\t\tbreak;\n\n\t\tpr_dbg(\"adding record option from script: %s\", pos + 1);\n\n\t\t/* include ':' so that it can start with optind 1 */\n\t\topt_argv = parse_cmdline(pos, &opt_argc);\n\n\t\t/* re-initialize getopt as we start another round */\n\t\toptind = 0;\n\n\t\twhile (true) {\n\t\t\tint key, tmp = 0;\n\n\t\t\tkey = getopt_long(opt_argc, opt_argv, uftrace_shopts, uftrace_options,\n\t\t\t\t\t  &tmp);\n\t\t\tif (key == -1 || key == '?')\n\t\t\t\tbreak;\n\n\t\t\tparse_option(opts, key, optarg);\n\t\t}\n\n\t\tfree_parsed_cmdline(opt_argv);\n\t\tbreak;\n\t}\n\n\tfree(line);\n\tfclose(fp);\n}\n\nstatic void free_opts(struct uftrace_opts *opts)\n{\n\tfree(opts->filter);\n\tfree(opts->trigger);\n\tfree(opts->sig_trigger);\n\tfree(opts->sort_keys);\n\tfree(opts->args);\n\tfree(opts->retval);\n\tfree(opts->tid);\n\tfree(opts->event);\n\tfree(opts->patch);\n\tfree(opts->caller);\n\tfree(opts->watch);\n\tfree(opts->hide);\n\tfree(opts->loc_filter);\n\tfree_parsed_cmdline(opts->run_cmd);\n}\n\nstatic int parse_options(int argc, char **argv, struct uftrace_opts *opts)\n{\n\t/* initial option parsing index */\n\toptind = 1;\n\n\twhile (true) {\n\t\tint key, tmp = 0;\n\n\t\tkey = getopt_long(argc, argv, uftrace_shopts, uftrace_options, &tmp);\n\t\tif (key == -1 || key == '?') {\n\t\t\tif (optind < argc && opts->mode == UFTRACE_MODE_INVALID) {\n\t\t\t\tupdate_subcmd(opts, argv[optind]);\n\n\t\t\t\tif (opts->mode != UFTRACE_MODE_INVALID) {\n\t\t\t\t\toptind++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\ttmp = parse_option(opts, key, optarg);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (optind < argc) {\n\t\topts->idx = optind;\n\t\topts->exename = argv[optind];\n\t}\n\n\treturn 0;\n}\n\n__used static void apply_default_opts(int *argc, char ***argv, struct uftrace_opts *opts)\n{\n\tchar *basename = \"default.opts\";\n\tchar opts_file[PATH_MAX];\n\tstruct stat stbuf;\n\n\t/* default.opts is only for analysis commands */\n\tif (opts->mode == UFTRACE_MODE_RECORD || opts->mode == UFTRACE_MODE_LIVE ||\n\t    opts->mode == UFTRACE_MODE_RECV)\n\t\treturn;\n\n\t/* this is not to override user given time-filter by default opts */\n\tparsing_default_opts = true;\n\n\tsnprintf(opts_file, PATH_MAX, \"%s/%s\", opts->dirname, basename);\n\tif (!stat(opts_file, &stbuf) && stbuf.st_size > 0) {\n\t\tpr_dbg(\"apply '%s' option file\\n\", opts_file);\n\t\tparse_opt_file(argc, argv, opts_file, opts);\n\t}\n\telse if (!strcmp(opts->dirname, UFTRACE_DIR_NAME) && !access(\"./info\", F_OK)) {\n\t\t/* try again applying default.opts in the current dir */\n\t\tif (!stat(basename, &stbuf) && stbuf.st_size > 0) {\n\t\t\tpr_dbg(\"apply './%s' option file\\n\", basename);\n\t\t\tparse_opt_file(argc, argv, basename, opts);\n\t\t}\n\t}\n}\n\n__used static void show_man_page(char *cmd)\n{\n\tchar *cmdstr = NULL;\n\n\tif (cmd)\n\t\txasprintf(&cmdstr, \"uftrace-%s\", cmd);\n\telse\n\t\tcmdstr = xstrdup(\"uftrace\");\n\texeclp(\"man\", \"man\", cmdstr, (char *)NULL);\n\t/* fall through if man command itself is not found */\n\tfree(cmdstr);\n}\n\n#ifndef UNIT_TEST\nint main(int argc, char *argv[])\n{\n\tstruct uftrace_opts opts = {\n\t\t.mode = UFTRACE_MODE_INVALID,\n\t\t.dirname = UFTRACE_DIR_NAME,\n\t\t.libcall = true,\n\t\t.bufsize = SHMEM_BUFFER_SIZE,\n\t\t.max_stack = OPT_RSTACK_DEFAULT,\n\t\t.port = UFTRACE_RECV_PORT,\n\t\t.use_pager = true,\n\t\t.color = COLOR_AUTO, /* turn on if terminal */\n\t\t.column_offset = OPT_COLUMN_OFFSET,\n\t\t.comment = true,\n\t\t.kernel_skip_out = true,\n\t\t.fields = NULL,\n\t\t.sort_column = OPT_SORT_COLUMN,\n\t\t.event_skip_out = true,\n\t\t.patt_type = PATT_REGEX,\n\t\t.show_args = true,\n\t\t.clock = \"mono\",\n\t};\n\tint ret = -1;\n\tchar *pager = NULL;\n\n\t/* this must be done before calling pr_*() */\n\tlogfp = stderr;\n\toutfp = stdout;\n\n\tif (argc == 1) {\n\t\tpr_out(uftrace_usage);\n\t\tpr_out(uftrace_footer);\n\t\treturn 0;\n\t}\n\n\tswitch (parse_options(argc, argv, &opts)) {\n\tcase -1:\n\t\tret = 0;\n\t\tgoto cleanup;\n\tcase -2:\n\t\tpr_out(uftrace_usage);\n\t\tpr_out(uftrace_footer);\n\t\tret = 0;\n\t\tgoto cleanup;\n\tcase -3:\n\t\tif (opts.mode)\n\t\t\tshow_man_page(argv[1]);\n\t\tif (opts.use_pager)\n\t\t\tstart_pager(setup_pager());\n\t\tpr_out(uftrace_usage);\n\t\tpr_out(uftrace_help);\n\t\twait_for_pager();\n\t\tret = 0;\n\t\tgoto cleanup;\n\t}\n\n\tif (opts.opt_file)\n\t\tparse_opt_file(&argc, &argv, opts.opt_file, &opts);\n\n\tif (opts.exename == NULL && !opts.list_event) {\n\t\tswitch (opts.mode) {\n\t\tcase UFTRACE_MODE_RECORD:\n\t\tcase UFTRACE_MODE_LIVE:\n\t\tcase UFTRACE_MODE_INVALID:\n\t\t\tpr_out(uftrace_usage);\n\t\t\tpr_out(uftrace_footer);\n\t\t\tret = 1;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (opts.mode == UFTRACE_MODE_INVALID)\n\t\topts.mode = UFTRACE_MODE_DEFAULT;\n\n\tif (dbg_domain_set && !debug)\n\t\tdebug = 1;\n\n\tif (opts.logfile) {\n\t\tlogfp = fopen(opts.logfile, \"a\");\n\t\tif (logfp == NULL) {\n\t\t\tlogfp = stderr;\n\t\t\tpr_err(\"cannot open log file\");\n\t\t}\n\n\t\tsetvbuf(logfp, NULL, _IOLBF, 1024);\n\t}\n\telse if (debug) {\n\t\t/* ensure normal output is not mixed by debug message */\n\t\tsetvbuf(outfp, NULL, _IOLBF, 1024);\n\t}\n\n\tif (debug) {\n\t\tint d;\n\n\t\t/* set default debug level */\n\t\tfor (d = 0; d < DBG_DOMAIN_MAX; d++) {\n\t\t\tif (dbg_domain[d] == -1 || !dbg_domain_set)\n\t\t\t\tdbg_domain[d] = debug;\n\t\t}\n\t}\n\n\tpr_dbg(\"running %s\\n\", uftrace_version);\n\n\topts.range.kernel_skip_out = opts.kernel_skip_out;\n\topts.range.event_skip_out = opts.event_skip_out;\n\n\tif (opts.mode == UFTRACE_MODE_RECORD || opts.mode == UFTRACE_MODE_RECV ||\n\t    opts.mode == UFTRACE_MODE_TUI)\n\t\topts.use_pager = false;\n\tif (opts.nop)\n\t\topts.use_pager = false;\n\n\tif (opts.use_pager)\n\t\tpager = setup_pager();\n\n\tif (!opts.pid) { /* Keep uninitialized values in client mode */\n\t\tif (!opts.depth)\n\t\t\topts.depth = OPT_DEPTH_DEFAULT;\n\t}\n\n\tsetup_color(opts.color, pager);\n\tsetup_signal();\n\n\t/* 'live' will start pager at its replay time */\n\tif (opts.use_pager && opts.mode != UFTRACE_MODE_LIVE)\n\t\tstart_pager(pager);\n\n\t/* the srcline info is used for TUI status line by default */\n\tif (opts.mode == UFTRACE_MODE_TUI)\n\t\topts.srcline = true;\n\n\tif (!opts.pid) { /* Keep uninitialized values in client mode */\n\t\tif (opts.trace == TRACE_STATE_NONE)\n\t\t\topts.trace = TRACE_STATE_ON;\n\t}\n\n\t/* apply 'default.opts' options for analysis commands */\n\tapply_default_opts(&argc, &argv, &opts);\n\n\tif (opts.idx == 0)\n\t\topts.idx = argc;\n\n\targc -= opts.idx;\n\targv += opts.idx;\n\n\tif (!opts.libcall && opts.nest_libcall)\n\t\tpr_err_ns(\"cannot use --no-libcall and --nest-libcall options together\\n\");\n\n\tswitch (opts.mode) {\n\tcase UFTRACE_MODE_RECORD:\n\t\tret = command_record(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_REPLAY:\n\t\tret = command_replay(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_LIVE:\n\t\tret = command_live(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_REPORT:\n\t\tret = command_report(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_INFO:\n\t\tret = command_info(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_RECV:\n\t\tret = command_recv(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_DUMP:\n\t\tret = command_dump(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_GRAPH:\n\t\tret = command_graph(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_SCRIPT:\n\t\tret = command_script(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_TUI:\n\t\tret = command_tui(argc, argv, &opts);\n\t\tbreak;\n\tcase UFTRACE_MODE_INVALID:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\twait_for_pager();\n\ncleanup:\n\tif (opts.logfile)\n\t\tfclose(logfp);\n\n\tif (opts.opt_file)\n\t\tfree_parsed_cmdline(argv - opts.idx);\n\n\tfree_opts(&opts);\n\treturn ret;\n}\n#else\n\n#define OPT_FILE \"opt\"\n\nTEST_CASE(option_parsing1)\n{\n\tchar *stropt = NULL;\n\tint i;\n\tbool elapsed_time;\n\n\tpr_dbg(\"check parsing size suffix\\n\");\n\tTEST_EQ(parse_size(\"1234\"), 1234);\n\tTEST_EQ(parse_size(\"10k\"), 10240);\n\tTEST_EQ(parse_size(\"100M\"), 100 * 1024 * 1024);\n\n\tpr_dbg(\"check string list addition\\n\");\n\tstropt = opt_add_string(stropt, \"abc\");\n\tTEST_STREQ(stropt, \"abc\");\n\tstropt = opt_add_string(stropt, \"def\");\n\tTEST_STREQ(stropt, \"abc;def\");\n\n\tfree(stropt);\n\tstropt = NULL;\n\n\tpr_dbg(\"check string list addition with prefix\\n\");\n\tstropt = opt_add_prefix_string(stropt, \"!\", \"abc\");\n\tTEST_STREQ(stropt, \"!abc\");\n\tstropt = opt_add_prefix_string(stropt, \"?\", \"def\");\n\tTEST_STREQ(stropt, \"!abc;?def\");\n\n\tfree(stropt);\n\tstropt = NULL;\n\n\tpr_dbg(\"check parsing colors\\n\");\n\tTEST_EQ(parse_color(\"1\"), COLOR_ON);\n\tTEST_EQ(parse_color(\"true\"), COLOR_ON);\n\tTEST_EQ(parse_color(\"off\"), COLOR_OFF);\n\tTEST_EQ(parse_color(\"n\"), COLOR_OFF);\n\tTEST_EQ(parse_color(\"auto\"), COLOR_AUTO);\n\tTEST_EQ(parse_color(\"ok\"), COLOR_UNKNOWN);\n\n\tpr_dbg(\"check parsing demanglers\\n\");\n\tTEST_EQ(parse_demangle(\"simple\"), DEMANGLE_SIMPLE);\n\tTEST_EQ(parse_demangle(\"no\"), DEMANGLE_NONE);\n\tTEST_EQ(parse_demangle(\"0\"), DEMANGLE_NONE);\n\t/* full demangling might not supported */\n\tTEST_NE(parse_demangle(\"full\"), DEMANGLE_SIMPLE);\n\n\tfor (i = 0; i < DBG_DOMAIN_MAX; i++)\n\t\tdbg_domain[i] = 0;\n\n\tpr_dbg(\"check parsing debug domains\\n\");\n\tparse_debug_domain(\"mcount:1,uftrace:2,symbol:3\");\n\tTEST_EQ(dbg_domain[DBG_UFTRACE], 2);\n\tTEST_EQ(dbg_domain[DBG_MCOUNT], 1);\n\tTEST_EQ(dbg_domain[DBG_SYMBOL], 3);\n\n\tTEST_EQ(parse_any_timestamp(\"1ns\", &elapsed_time), 1ULL);\n\tTEST_EQ(parse_any_timestamp(\"2us\", &elapsed_time), 2000ULL);\n\tTEST_EQ(parse_any_timestamp(\"3ms\", &elapsed_time), 3000000ULL);\n\tTEST_EQ(parse_any_timestamp(\"4s\", &elapsed_time), 4000000000ULL);\n\tTEST_EQ(parse_any_timestamp(\"5m\", &elapsed_time), 300000000000ULL);\n\n\treturn TEST_OK;\n}\n\nTEST_CASE(option_parsing2)\n{\n\tstruct uftrace_opts opts = {\n\t\t.mode = UFTRACE_MODE_INVALID,\n\t};\n\tchar *argv[] = {\n\t\t\"uftrace\", \"replay\", \"-v\",  \"--data=abc.data\", \"--kernel\", \"-t\", \"1us\", \"-F\",\n\t\t\"foo\",\t   \"-N\",     \"bar\", \"-Abaz@kernel\",\n\t};\n\tint argc = ARRAY_SIZE(argv);\n\tint saved_debug = debug;\n\n\tpr_dbg(\"check parsing regular command line options\\n\");\n\tparse_options(argc, argv, &opts);\n\n\tTEST_EQ(opts.mode, UFTRACE_MODE_REPLAY);\n\tTEST_EQ(debug, saved_debug + 1);\n\tTEST_EQ(opts.kernel, 1);\n\tTEST_EQ(opts.threshold, (uint64_t)1000);\n\tTEST_STREQ(opts.dirname, \"abc.data\");\n\tTEST_STREQ(opts.filter, \"foo;!bar\");\n\tTEST_STREQ(opts.args, \"baz@kernel\");\n\n\tfree_opts(&opts);\n\treturn TEST_OK;\n}\n\nTEST_CASE(option_parsing3)\n{\n\tstruct uftrace_opts opts = {\n\t\t.mode = UFTRACE_MODE_INVALID,\n\t};\n\tchar *argv[] = {\n\t\t\"uftrace\",\n\t\t\"-v\",\n\t\t\"--opt-file\",\n\t\tOPT_FILE,\n\t};\n\tint argc = ARRAY_SIZE(argv);\n\tchar opt_file[] = \"-K 2\\n\"\n\t\t\t  \"-b4m\\n\"\n\t\t\t  \"--column-view\\n\"\n\t\t\t  \"--depth=3\\n\"\n\t\t\t  \"t-abc\";\n\tint file_argc;\n\tchar **file_argv;\n\tFILE *fp;\n\tint saved_debug = debug;\n\n\t/* create opt-file */\n\tfp = fopen(OPT_FILE, \"w\");\n\tTEST_NE(fp, NULL);\n\tfwrite(opt_file, strlen(opt_file), 1, fp);\n\tfclose(fp);\n\n\tpr_dbg(\"check parsing regular command line options\\n\");\n\tparse_options(argc, argv, &opts);\n\tTEST_STREQ(opts.opt_file, OPT_FILE);\n\n\tpr_dbg(\"check parsing option files\\n\");\n\tparse_opt_file(&file_argc, &file_argv, opts.opt_file, &opts);\n\tTEST_EQ(file_argc, 7); // +1 for dummy prefix\n\n\tunlink(OPT_FILE);\n\n\tTEST_EQ(opts.mode, UFTRACE_MODE_INVALID);\n\tTEST_EQ(debug, saved_debug + 1);\n\tTEST_EQ(opts.kernel, 1);\n\tTEST_EQ(opts.kernel_depth, 2);\n\tTEST_EQ(opts.depth, 3);\n\tTEST_EQ(opts.bufsize, 4 * 1024 * 1024);\n\tTEST_EQ(opts.column_view, 1);\n\tTEST_STREQ(opts.exename, \"t-abc\");\n\n\tfree_parsed_cmdline(file_argv);\n\tfree_opts(&opts);\n\treturn TEST_OK;\n}\n\nTEST_CASE(option_parsing4)\n{\n\tstruct uftrace_opts opts = {\n\t\t.mode = UFTRACE_MODE_INVALID,\n\t};\n\tchar *argv[] = {\n\t\t\"uftrace\",\n\t\t\"-v\",\n\t\t\"--opt-file\",\n\t\tOPT_FILE,\n\t};\n\tint argc = ARRAY_SIZE(argv);\n\tchar opt_file[] = \"-K 2\\n\"\n\t\t\t  \"# buffer size: 4 MB\\n\"\n\t\t\t  \"-b4m\\n\"\n\t\t\t  \"\\n\"\n\t\t\t  \"## show different thread with different indentation\\n\"\n\t\t\t  \"--column-view\\n\"\n\t\t\t  \"\\n\"\n\t\t\t  \"# limit maximum function call depth to 3\\n\"\n\t\t\t  \"--depth=3 # same as -D3 \\n\"\n\t\t\t  \"\\n\"\n\t\t\t  \"\\n\"\n\t\t\t  \"#test program\\n\"\n\t\t\t  \"t-abc\\n\"\n\t\t\t  \"\\n\";\n\tint file_argc;\n\tchar **file_argv;\n\tFILE *fp;\n\tint saved_debug = debug;\n\n\t/* create opt-file */\n\tfp = fopen(OPT_FILE, \"w\");\n\tTEST_NE(fp, NULL);\n\tfwrite(opt_file, strlen(opt_file), 1, fp);\n\tfclose(fp);\n\n\tpr_dbg(\"check parsing regular command line options\\n\");\n\tparse_options(argc, argv, &opts);\n\tTEST_STREQ(opts.opt_file, OPT_FILE);\n\n\tpr_dbg(\"check parsing option files\\n\");\n\tparse_opt_file(&file_argc, &file_argv, opts.opt_file, &opts);\n\tTEST_EQ(file_argc, 7); // +1 for dummy prefix\n\n\tunlink(OPT_FILE);\n\n\tpr_dbg(\"command mode should remain as is\\n\");\n\tTEST_EQ(opts.mode, UFTRACE_MODE_INVALID);\n\tTEST_EQ(debug, saved_debug + 1);\n\tTEST_EQ(opts.kernel, 1);\n\tTEST_EQ(opts.kernel_depth, 2);\n\tTEST_EQ(opts.depth, 3);\n\tTEST_EQ(opts.bufsize, 4 * 1024 * 1024);\n\tTEST_EQ(opts.column_view, 1);\n\tTEST_STREQ(opts.exename, \"t-abc\");\n\n\tfree_parsed_cmdline(file_argv);\n\tfree_opts(&opts);\n\treturn TEST_OK;\n}\n\nTEST_CASE(option_parsing5)\n{\n\tstruct uftrace_opts opts = {\n\t\t.mode = UFTRACE_MODE_INVALID,\n\t};\n\tchar *argv[] = { \"uftrace\", \"-v\", \"--opt-file\", OPT_FILE, \"hello\" };\n\tint argc = ARRAY_SIZE(argv);\n\tchar opt_file[] = \"record\\n\"\n\t\t\t  \"-F main\\n\"\n\t\t\t  \"--time-filter 1us\\n\"\n\t\t\t  \"--depth=3\\n\"\n\t\t\t  \"t-abc\";\n\tint file_argc = argc;\n\tchar **file_argv = argv;\n\tFILE *fp;\n\tint saved_debug = debug;\n\n\t/* create opt-file */\n\tfp = fopen(OPT_FILE, \"w\");\n\tTEST_NE(fp, NULL);\n\tfwrite(opt_file, strlen(opt_file), 1, fp);\n\tfclose(fp);\n\n\tpr_dbg(\"check parsing regular command line options\\n\");\n\tparse_options(argc, argv, &opts);\n\tTEST_STREQ(opts.opt_file, OPT_FILE);\n\n\tpr_dbg(\"check parsing option files\\n\");\n\tparse_opt_file(&file_argc, &file_argv, opts.opt_file, &opts);\n\n\tunlink(OPT_FILE);\n\n\tpr_dbg(\"opt file should update command mode\\n\");\n\tTEST_EQ(opts.mode, UFTRACE_MODE_RECORD);\n\tTEST_EQ(debug, saved_debug + 1);\n\t/* preserve original arg[cv] if command line is given */\n\tTEST_EQ(file_argc, argc);\n\tTEST_EQ(file_argv, (char **)argv);\n\tTEST_EQ(opts.threshold, (uint64_t)1000);\n\tTEST_EQ(opts.depth, 3);\n\tTEST_EQ(opts.idx, 4);\n\tTEST_STREQ(opts.filter, \"main\");\n\t/* it should not update exename to \"t-abc\" */\n\tTEST_STREQ(opts.exename, \"hello\");\n\n\tfree_opts(&opts);\n\treturn TEST_OK;\n}\n\n#endif /* UNIT_TEST */\n"
        },
        {
          "name": "uftrace.h",
          "type": "blob",
          "size": 17.8984375,
          "content": "#ifndef UFTRACE_H\n#define UFTRACE_H\n\n#include <fcntl.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\n#include \"utils/arch.h\"\n#include \"utils/filter.h\"\n#include \"utils/list.h\"\n#include \"utils/perf.h\"\n#include \"utils/rbtree.h\"\n#include \"utils/symbol.h\"\n\n#define UFTRACE_MAGIC_LEN 8\n#define UFTRACE_MAGIC_STR \"Ftrace!\"\n#define UFTRACE_FILE_VERSION 4\n#define UFTRACE_FILE_VERSION_MIN 3\n#define UFTRACE_DIR_NAME \"uftrace.data\"\n#define UFTRACE_DIR_OLD_NAME \"ftrace.dir\"\n\n#define UFTRACE_RECV_PORT 8090\n\n/* default option values */\n#define OPT_RSTACK_MAX 65535\n#define OPT_RSTACK_DEFAULT 1024\n#define OPT_DEPTH_MAX OPT_RSTACK_MAX\n#define OPT_THRESHOLD_MAX 0xFFFFFFFFFFFFFFFF /* max uint64 = 2^64-1 */\n#define OPT_DEPTH_DEFAULT OPT_RSTACK_DEFAULT\n#define OPT_COLUMN_OFFSET 8\n#define OPT_SORT_COLUMN 2\n#define OPT_SORT_KEYS \"total\"\n\n#define KB 1024\n#define MB (KB * 1024)\n\nstruct uftrace_file_header {\n\tchar magic[UFTRACE_MAGIC_LEN];\n\tuint32_t version;\n\tuint16_t header_size;\n\tuint8_t endian;\n\tuint8_t elf_class;\n\tuint64_t feat_mask;\n\tuint64_t info_mask;\n\tuint16_t max_stack;\n\tuint16_t unused1;\n\tuint32_t unused2;\n};\n\nenum uftrace_feat_bits {\n\t/* bit index */\n\tPLTHOOK_BIT,\n\tTASK_SESSION_BIT,\n\tKERNEL_BIT,\n\tARGUMENT_BIT,\n\tRETVAL_BIT,\n\tSYM_REL_ADDR_BIT,\n\tMAX_STACK_BIT,\n\tEVENT_BIT,\n\tPERF_EVENT_BIT,\n\tAUTO_ARGS_BIT,\n\tDEBUG_INFO_BIT,\n\tESTIMATE_RETURN_BIT,\n\tSYM_SIZE_BIT,\n\n\tFEAT_BIT_MAX,\n\n\t/* bit mask */\n\tPLTHOOK = (1U << PLTHOOK_BIT),\n\tTASK_SESSION = (1U << TASK_SESSION_BIT),\n\tKERNEL = (1U << KERNEL_BIT),\n\tARGUMENT = (1U << ARGUMENT_BIT),\n\tRETVAL = (1U << RETVAL_BIT),\n\tSYM_REL_ADDR = (1U << SYM_REL_ADDR_BIT),\n\tMAX_STACK = (1U << MAX_STACK_BIT),\n\tEVENT = (1U << EVENT_BIT),\n\tPERF_EVENT = (1U << PERF_EVENT_BIT),\n\tAUTO_ARGS = (1U << AUTO_ARGS_BIT),\n\tDEBUG_INFO = (1U << DEBUG_INFO_BIT),\n\tESTIMATE_RETURN = (1U << ESTIMATE_RETURN_BIT),\n\tSYM_SIZE = (1U << SYM_SIZE_BIT),\n};\n\nenum uftrace_info_bits {\n\t/* bit index */\n\tEXE_NAME_BIT,\n\tEXE_BUILD_ID_BIT,\n\tEXIT_STATUS_BIT,\n\tCMDLINE_BIT,\n\tCPUINFO_BIT,\n\tMEMINFO_BIT,\n\tOSINFO_BIT,\n\tTASKINFO_BIT,\n\tUSAGEINFO_BIT,\n\tLOADINFO_BIT,\n\tARG_SPEC_BIT,\n\tRECORD_DATE_BIT,\n\tPATTERN_TYPE_BIT,\n\tVERSION_BIT,\n\tUTC_OFFSET_BIT,\n\n\tINFO_BIT_MAX,\n\n\t/* bit mask */\n\tEXE_NAME = (1U << EXE_NAME_BIT),\n\tEXE_BUILD_ID = (1U << EXE_BUILD_ID_BIT),\n\tEXIT_STATUS = (1U << EXIT_STATUS_BIT),\n\tCMDLINE = (1U << CMDLINE_BIT),\n\tCPUINFO = (1U << CPUINFO_BIT),\n\tMEMINFO = (1U << MEMINFO_BIT),\n\tOSINFO = (1U << OSINFO_BIT),\n\tTASKINFO = (1U << TASKINFO_BIT),\n\tUSAGEINFO = (1U << USAGEINFO_BIT),\n\tLOADINFO = (1U << LOADINFO_BIT),\n\tARG_SPEC = (1U << ARG_SPEC_BIT),\n\tRECORD_DATE = (1U << RECORD_DATE_BIT),\n\tPATTERN_TYPE = (1U << PATTERN_TYPE_BIT),\n\tVERSION = (1U << VERSION_BIT),\n\tUTC_OFFSET = (1U << UTC_OFFSET_BIT),\n};\n\nstruct uftrace_info {\n\tchar *exename;\n\tunsigned char build_id[20];\n\tint exit_status;\n\tchar *cmdline;\n\tint nr_cpus_online;\n\tint nr_cpus_possible;\n\tchar *cpudesc;\n\tchar *meminfo;\n\tchar *kernel;\n\tchar *hostname;\n\tchar *distro;\n\tchar *argspec;\n\tchar *retspec;\n\tchar *autoarg;\n\tchar *autoret;\n\tchar *autoenum;\n\tbool auto_args_enabled;\n\tint nr_tid;\n\tint *tids;\n\tdouble stime;\n\tdouble utime;\n\tchar *record_date;\n\tchar *elapsed_time;\n\tchar *utc_offset;\n\tlong vctxsw;\n\tlong ictxsw;\n\tlong maxrss;\n\tlong major_fault;\n\tlong minor_fault;\n\tlong rblock;\n\tlong wblock;\n\tfloat load1;\n\tfloat load5;\n\tfloat load15;\n\tenum uftrace_pattern_type patt_type;\n\tchar *uftrace_version;\n};\n\nenum {\n\tUFTRACE_EXIT_SUCCESS = 0,\n\tUFTRACE_EXIT_FAILURE,\n\tUFTRACE_EXIT_SIGNALED,\n\tUFTRACE_EXIT_UNKNOWN,\n\tUFTRACE_EXIT_FINISHED = 1 << 16,\n};\n\nstruct kbuffer;\nstruct pevent;\nstruct uftrace_record;\nstruct uftrace_rstack_list;\nstruct uftrace_session;\nstruct uftrace_kernel_reader;\nstruct uftrace_perf_reader;\nstruct uftrace_extern_reader;\nstruct uftrace_module;\n\nstruct uftrace_session_link {\n\tstruct rb_root root;\n\tstruct rb_root tasks;\n\tstruct uftrace_session *first;\n\tstruct uftrace_task *first_task;\n};\n\nstruct uftrace_data {\n\tFILE *fp;\n\tint sock;\n\tconst char *dirname;\n\tenum uftrace_cpu_arch arch;\n\tstruct uftrace_file_header hdr;\n\tstruct uftrace_info info;\n\tstruct uftrace_kernel_reader *kernel;\n\tstruct uftrace_perf_reader *perf;\n\tstruct uftrace_extern_reader *extn;\n\tstruct uftrace_task_reader *tasks;\n\tstruct uftrace_session_link sessions;\n\tint nr_tasks;\n\tint nr_perf;\n\tint last_perf_idx;\n\tint depth;\n\tbool needs_byte_swap;\n\tbool needs_bit_swap;\n\tbool perf_event_processed;\n\tbool caller_filter;\n\tuint64_t time_filter;\n\tunsigned size_filter;\n\tstruct uftrace_time_range time_range;\n\tstruct list_head events;\n};\n\nbool data_is_lp64(struct uftrace_data *handle);\n\n#define UFTRACE_MODE_INVALID 0\n#define UFTRACE_MODE_RECORD 1\n#define UFTRACE_MODE_REPLAY 2\n#define UFTRACE_MODE_LIVE 3\n#define UFTRACE_MODE_REPORT 4\n#define UFTRACE_MODE_INFO 5\n#define UFTRACE_MODE_RECV 6\n#define UFTRACE_MODE_DUMP 7\n#define UFTRACE_MODE_GRAPH 8\n#define UFTRACE_MODE_SCRIPT 9\n#define UFTRACE_MODE_TUI 10\n\n#define UFTRACE_MODE_DEFAULT UFTRACE_MODE_LIVE\n\nstruct uftrace_opts {\n\tchar *lib_path;\n\tchar *filter;\n\tchar *trigger;\n\tchar *sig_trigger;\n\tchar *tid;\n\tchar *exename;\n\tchar *dirname;\n\tchar *logfile;\n\tchar *host;\n\tchar *sort_keys;\n\tchar *args;\n\tchar *retval;\n\tchar *diff;\n\tchar *fields;\n\tchar *patch;\n\tchar *event;\n\tchar *watch;\n\tchar **run_cmd;\n\tchar *opt_file;\n\tchar *script_file;\n\tchar *diff_policy;\n\tchar *caller;\n\tchar *extern_data;\n\tchar *hide;\n\tchar *loc_filter;\n\tchar *with_syms;\n\tchar *clock;\n\tint mode;\n\tint idx;\n\tint depth;\n\tint kernel_depth;\n\tint max_stack;\n\tint port;\n\tint color;\n\tint column_offset;\n\tint sort_column;\n\tint nr_thread;\n\tint rt_prio;\n\tint size_filter;\n\tint pid;\n\tunsigned long bufsize;\n\tunsigned long kernel_bufsize;\n\tuint64_t threshold;\n\tuint64_t sample_time;\n\tbool flat;\n\tbool libcall;\n\tbool print_symtab;\n\tbool force;\n\tbool show_task;\n\tbool no_merge;\n\tbool nop;\n\tbool time;\n\tbool backtrace;\n\tbool use_pager;\n\tbool avg_total;\n\tbool avg_self;\n\tbool report;\n\tbool column_view;\n\tbool want_bind_not;\n\tbool task_newline;\n\tbool chrome_trace;\n\tbool comment;\n\tbool flame_graph;\n\tbool libmcount_single;\n\tbool kernel;\n\tbool kernel_skip_out; /* also affects VDSO filter */\n\tbool kernel_only;\n\tbool keep_pid;\n\tbool list_event;\n\tbool event_skip_out;\n\tbool no_event;\n\tbool no_sched;\n\tbool no_sched_preempt;\n\tbool nest_libcall;\n\tbool record;\n\tbool auto_args;\n\tbool show_args;\n\tbool libname;\n\tbool no_randomize_addr;\n\tbool graphviz;\n\tbool srcline;\n\tbool estimate_return;\n\tbool mermaid;\n\tbool agent;\n\tstruct uftrace_time_range range;\n\tenum uftrace_pattern_type patt_type;\n\tenum uftrace_trace_state trace;\n};\n\nextern struct strv default_opts;\n\nstatic inline bool opts_has_filter(struct uftrace_opts *opts)\n{\n\treturn opts->filter || opts->trigger || opts->threshold || opts->depth != OPT_DEPTH_DEFAULT;\n}\n\nvoid parse_script_opt(struct uftrace_opts *opts);\n\nint command_record(int argc, char *argv[], struct uftrace_opts *opts);\nint command_replay(int argc, char *argv[], struct uftrace_opts *opts);\nint command_live(int argc, char *argv[], struct uftrace_opts *opts);\nint command_report(int argc, char *argv[], struct uftrace_opts *opts);\nint command_info(int argc, char *argv[], struct uftrace_opts *opts);\nint command_recv(int argc, char *argv[], struct uftrace_opts *opts);\nint command_dump(int argc, char *argv[], struct uftrace_opts *opts);\nint command_graph(int argc, char *argv[], struct uftrace_opts *opts);\nint command_script(int argc, char *argv[], struct uftrace_opts *opts);\nint command_tui(int argc, char *argv[], struct uftrace_opts *opts);\n\nextern volatile bool uftrace_done;\n\nint open_data_file(struct uftrace_opts *opts, struct uftrace_data *handle);\nint open_info_file(struct uftrace_opts *opts, struct uftrace_data *handle);\nvoid __close_data_file(struct uftrace_opts *opts, struct uftrace_data *handle, bool unload_modules);\nstatic inline void close_data_file(struct uftrace_opts *opts, struct uftrace_data *handle)\n{\n\t__close_data_file(opts, handle, true);\n}\n\nint read_task_file(struct uftrace_session_link *sess, char *dirname, bool needs_symtab,\n\t\t   bool sym_rel_addr, bool needs_srcline);\nint read_task_txt_file(struct uftrace_session_link *sess, char *dirname, char *symdir,\n\t\t       bool needs_symtab, bool sym_rel_addr, bool needs_srcline);\n\nchar *get_libmcount_path(struct uftrace_opts *opts);\nvoid put_libmcount_path(char *libpath);\n\n#define SESSION_ID_LEN 16\n#define TASK_COMM_LEN 16\n#define TASK_COMM_LAST (TASK_COMM_LEN - 1)\n#define TASK_ID_LEN 7\n\nstruct uftrace_session {\n\tstruct rb_node node;\n\tchar sid[SESSION_ID_LEN];\n\tuint64_t start_time;\n\tint pid, tid;\n\tstruct uftrace_sym_info sym_info;\n\tstruct rb_root filters;\n\tstruct rb_root fixups;\n\tstruct list_head dlopen_libs;\n\tint namelen;\n\tchar exename[];\n};\n\nstruct uftrace_sess_ref {\n\tstruct uftrace_sess_ref *next;\n\tstruct uftrace_session *sess;\n\tuint64_t start, end;\n};\n\nstruct uftrace_dlopen_list {\n\tstruct list_head list;\n\tuint64_t time;\n\tunsigned long base;\n\tstruct uftrace_module *mod;\n\tstruct rb_root filters;\n};\n\nstruct uftrace_task {\n\tint pid, tid, ppid;\n\tchar comm[TASK_COMM_LEN];\n\tstruct rb_node node;\n\tstruct uftrace_sess_ref sref;\n\tstruct uftrace_sess_ref *sref_last;\n\tstruct list_head children;\n\tstruct list_head siblings;\n\tstruct {\n\t\tuint64_t run;\n\t\tuint64_t idle;\n\t\tuint64_t stamp;\n\t} time;\n};\n\n#define UFTRACE_MSG_MAGIC 0xface\n\nenum uftrace_msg_type {\n\tUFTRACE_MSG_REC_START = 1,\n\tUFTRACE_MSG_REC_END,\n\tUFTRACE_MSG_TASK_START,\n\tUFTRACE_MSG_TASK_END,\n\tUFTRACE_MSG_FORK_START,\n\tUFTRACE_MSG_FORK_END,\n\tUFTRACE_MSG_SESSION,\n\tUFTRACE_MSG_LOST,\n\tUFTRACE_MSG_DLOPEN,\n\tUFTRACE_MSG_FINISH,\n\n\tUFTRACE_MSG_SEND_START = 100,\n\tUFTRACE_MSG_SEND_DIR_NAME,\n\tUFTRACE_MSG_SEND_DATA,\n\tUFTRACE_MSG_SEND_KERNEL_DATA,\n\tUFTRACE_MSG_SEND_PERF_DATA,\n\tUFTRACE_MSG_SEND_INFO,\n\tUFTRACE_MSG_SEND_META_DATA,\n\tUFTRACE_MSG_SEND_END,\n\n\tUFTRACE_MSG_AGENT_CLOSE = 200, /* close the connection */\n\tUFTRACE_MSG_AGENT_QUERY, /* perform connection handshake */\n\tUFTRACE_MSG_AGENT_GET_OPT, /* get current option value */\n\tUFTRACE_MSG_AGENT_SET_OPT, /* set new option value */\n\tUFTRACE_MSG_AGENT_OK, /* ack previous message */\n\tUFTRACE_MSG_AGENT_ERR, /* signal error on previous message */\n};\n\n/* msg format for communicating by pipe */\nstruct uftrace_msg {\n\tunsigned short magic; /* UFTRACE_MSG_MAGIC */\n\tunsigned short type; /* UFTRACE_MSG_* */\n\tunsigned int len;\n\tunsigned char data[];\n};\n\nstruct uftrace_msg_task {\n\tuint64_t time;\n\tint32_t pid;\n\tint32_t tid;\n};\n\nstruct uftrace_msg_sess {\n\tstruct uftrace_msg_task task;\n\tchar sid[16];\n\tint unused;\n\tint namelen;\n\tchar exename[];\n};\n\nstruct uftrace_msg_dlopen {\n\tstruct uftrace_msg_task task;\n\tuint64_t base_addr;\n\tchar sid[16];\n\tint unused;\n\tint namelen;\n\tchar exename[];\n};\n\nenum uftrace_agent_opt {\n\tUFTRACE_AGENT_OPT_TRACE = (1U << 0), /* turn tracing on/off */\n\tUFTRACE_AGENT_OPT_DEPTH = (1U << 1), /* mcount depth filter */\n\tUFTRACE_AGENT_OPT_THRESHOLD = (1U << 2), /* mcount time filter */\n\tUFTRACE_AGENT_OPT_PATTERN = (1U << 3), /* pattern match type */\n\tUFTRACE_AGENT_OPT_FILTER = (1U << 4), /* tracing filters */\n\tUFTRACE_AGENT_OPT_CALLER = (1U << 5), /* tracing caller filters */\n\tUFTRACE_AGENT_OPT_TRIGGER = (1U << 6), /* tracing trigger actions */\n};\n\nextern struct uftrace_session *first_session;\n\nvoid create_session(struct uftrace_session_link *sess, struct uftrace_msg_sess *msg, char *dirname,\n\t\t    char *symdir, char *exename, bool sym_rel_addr, bool needs_symtab,\n\t\t    bool needs_srcline);\nstruct uftrace_session *find_task_session(struct uftrace_session_link *sess,\n\t\t\t\t\t  struct uftrace_task *task, uint64_t timestamp);\nvoid create_task(struct uftrace_session_link *sess, struct uftrace_msg_task *msg, bool fork);\nstruct uftrace_task *find_task(struct uftrace_session_link *sess, int tid);\nvoid read_session_map(char *dirname, struct uftrace_sym_info *sinfo, char *sid);\nvoid delete_session_map(struct uftrace_sym_info *sinfo);\nvoid update_session_map(const char *filename);\nstruct uftrace_session *get_session_from_sid(struct uftrace_session_link *sess, char sid[]);\nvoid session_add_dlopen(struct uftrace_session *sess, uint64_t timestamp, unsigned long base_addr,\n\t\t\tconst char *libname, bool needs_srcline);\nvoid session_setup_dlopen_argspec(struct uftrace_session *sess,\n\t\t\t\t  struct uftrace_filter_setting *setting, bool is_retval);\nstruct uftrace_dlopen_list *session_find_dlopen(struct uftrace_session *sess, uint64_t timestamp,\n\t\t\t\t\t\tunsigned long addr);\nstruct uftrace_symbol *session_find_dlsym(struct uftrace_session *sess, uint64_t timestamp,\n\t\t\t\t\t  unsigned long addr);\nstruct uftrace_filter *session_find_filter(struct uftrace_session *sess, struct uftrace_record *rec,\n\t\t\t\t\t   struct uftrace_trigger *tr);\nvoid delete_sessions(struct uftrace_session_link *sess);\n\nstruct uftrace_record;\nstruct uftrace_symbol *task_find_sym(struct uftrace_session_link *sess,\n\t\t\t\t     struct uftrace_task_reader *task, struct uftrace_record *rec);\nstruct uftrace_symbol *task_find_sym_addr(struct uftrace_session_link *sess,\n\t\t\t\t\t  struct uftrace_task_reader *task, uint64_t time,\n\t\t\t\t\t  uint64_t addr);\nstruct uftrace_dbg_loc *task_find_loc_addr(struct uftrace_session_link *sess,\n\t\t\t\t\t   struct uftrace_task_reader *task, uint64_t time,\n\t\t\t\t\t   uint64_t addr);\n\ntypedef int (*walk_sessions_cb_t)(struct uftrace_session *session, void *arg);\nvoid walk_sessions(struct uftrace_session_link *sess, walk_sessions_cb_t callback, void *arg);\ntypedef int (*walk_tasks_cb_t)(struct uftrace_task *task, void *arg);\nvoid walk_tasks(struct uftrace_session_link *sess, walk_tasks_cb_t callback, void *arg);\n\nint setup_client_socket(struct uftrace_opts *opts);\nvoid send_trace_dir_name(int sock, char *name);\nvoid send_trace_data(int sock, int tid, void *data, size_t len);\nvoid send_trace_kernel_data(int sock, int cpu, void *data, size_t len);\nvoid send_trace_perf_data(int sock, int cpu, void *data, size_t len);\nvoid send_trace_metadata(int sock, const char *dirname, char *filename);\nvoid send_trace_info(int sock, struct uftrace_file_header *hdr, void *info, int len);\nvoid send_trace_end(int sock);\n\nvoid write_task_info(const char *dirname, struct uftrace_msg_task *tmsg);\nvoid write_fork_info(const char *dirname, struct uftrace_msg_task *tmsg);\nvoid write_session_info(const char *dirname, struct uftrace_msg_sess *smsg, const char *exename);\nvoid write_dlopen_info(const char *dirname, struct uftrace_msg_dlopen *dmsg, const char *libname);\n\nenum uftrace_record_type {\n\tUFTRACE_ENTRY,\n\tUFTRACE_EXIT,\n\tUFTRACE_LOST,\n\tUFTRACE_EVENT,\n};\n\n#define RECORD_MAGIC_V3 0xa\n#define RECORD_MAGIC_V4 0x5\n#define RECORD_MAGIC RECORD_MAGIC_V4\n\n/* reduced version of mcount_ret_stack */\nstruct uftrace_record {\n\tuint64_t time;\n\tuint64_t type : 2;\n\tuint64_t more : 1;\n\tuint64_t magic : 3;\n\tuint64_t depth : 10;\n\tuint64_t addr : 48; /* child ip or uftrace_event_id */\n};\n\nstatic inline bool is_v3_compat(struct uftrace_record *urec)\n{\n\t/* (RECORD_MAGIC_V4 << 1 | more) == RECORD_MAGIC_V3 */\n\treturn urec->magic == RECORD_MAGIC && urec->more == 0;\n}\n\nstruct uftrace_fstack_args {\n\tstruct list_head *args;\n\tunsigned len;\n\tvoid *data;\n};\n\nstruct uftrace_rstack_list {\n\tstruct list_head read;\n\tstruct list_head unused;\n\tint count;\n};\n\nstruct uftrace_rstack_list_node {\n\tstruct list_head list;\n\tstruct uftrace_record rstack;\n\tstruct uftrace_fstack_args args;\n};\n\nvoid setup_rstack_list(struct uftrace_rstack_list *list);\nvoid add_to_rstack_list(struct uftrace_rstack_list *list, struct uftrace_record *rstack,\n\t\t\tstruct uftrace_fstack_args *args);\nstruct uftrace_record *get_first_rstack_list(struct uftrace_rstack_list *);\nvoid consume_first_rstack_list(struct uftrace_rstack_list *list);\nvoid delete_last_rstack_list(struct uftrace_rstack_list *list);\nvoid reset_rstack_list(struct uftrace_rstack_list *list);\n\nenum uftrace_ext_type {\n\tFTRACE_ARGUMENT = 1,\n};\n\nstatic inline bool has_perf_data(struct uftrace_data *handle)\n{\n\treturn handle->perf != NULL;\n}\n\nstatic inline bool has_event_data(struct uftrace_data *handle)\n{\n\treturn handle->perf_event_processed;\n}\n\nstruct rusage;\n\nint fill_file_header(struct uftrace_opts *opts, int status, struct rusage *rusage,\n\t\t     char *elapsed_time);\nvoid fill_uftrace_info(uint64_t *info_mask, int fd, struct uftrace_opts *opts, int status,\n\t\t       struct rusage *rusage, char *elapsed_time);\nint read_uftrace_info(uint64_t info_mask, struct uftrace_data *handle);\nvoid process_uftrace_info(struct uftrace_data *handle, struct uftrace_opts *opts,\n\t\t\t  void (*process)(void *data, const char *fmt, ...), void *data);\nvoid clear_uftrace_info(struct uftrace_info *info);\n\nint arch_fill_cpuinfo_model(int fd);\n\nenum uftrace_event_id {\n\tEVENT_ID_KERNEL = 0U,\n\t/* kernel IDs are read from tracefs */\n\n\tEVENT_ID_BUILTIN = 100000U,\n\tEVENT_ID_READ_PROC_STATM,\n\tEVENT_ID_READ_PAGE_FAULT,\n\tEVENT_ID_DIFF_PROC_STATM,\n\tEVENT_ID_DIFF_PAGE_FAULT,\n\tEVENT_ID_READ_PMU_CYCLE,\n\tEVENT_ID_DIFF_PMU_CYCLE,\n\tEVENT_ID_READ_PMU_CACHE,\n\tEVENT_ID_DIFF_PMU_CACHE,\n\tEVENT_ID_READ_PMU_BRANCH,\n\tEVENT_ID_DIFF_PMU_BRANCH,\n\tEVENT_ID_WATCH_CPU,\n\tEVENT_ID_WATCH_VAR,\n\n\t/* supported perf events */\n\tEVENT_ID_PERF = 200000U,\n\tEVENT_ID_PERF_SCHED_IN,\n\tEVENT_ID_PERF_SCHED_OUT,\n\tEVENT_ID_PERF_SCHED_BOTH,\n\tEVENT_ID_PERF_TASK,\n\tEVENT_ID_PERF_EXIT,\n\tEVENT_ID_PERF_COMM,\n\tEVENT_ID_PERF_SCHED_OUT_PREEMPT,\n\tEVENT_ID_PERF_SCHED_BOTH_PREEMPT,\n\n\tEVENT_ID_USER = 1000000U,\n\n\tEVENT_ID_EXTERN_DATA = 2000000U,\n};\n\nstruct uftrace_event {\n\tstruct list_head list;\n\tenum uftrace_event_id id;\n\tchar *provider;\n\tchar *event;\n};\n\nstruct uftrace_watch_event {\n\tunion {\n\t\tint cpu;\n\t\tstruct {\n\t\t\tuint64_t addr;\n\t\t\tuint64_t data;\n\t\t} var;\n\t};\n};\n\n#define HTML_HEADER                                                                                \\\n\t\"<html>\\n\"                                                                                 \\\n\t\"<head></head>\\n\"                                                                          \\\n\t\"<body style='background-color:black;color:white;'>\\n\"                                     \\\n\t\"<pre>\\n\"\n\n#define HTML_FOOTER                                                                                \\\n\t\"</pre>\\n\"                                                                                 \\\n\t\"</body>\\n\"                                                                                \\\n\t\"</html>\\n\"\n\n/* for unit tests */\nint prepare_test_data(struct uftrace_opts *opts, struct uftrace_data *handle);\nint release_test_data(struct uftrace_opts *opts, struct uftrace_data *handle);\n\n#endif /* UFTRACE_H */\n"
        },
        {
          "name": "utils",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}