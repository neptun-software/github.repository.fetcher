{
  "metadata": {
    "timestamp": 1736710209180,
    "page": 921,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "SpenceKonde/ATTinyCore",
      "stars": 1621,
      "defaultBranch": "v2.0.0-devThis-is-the-head-submit-PRs-against-this",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.015625,
          "content": ".DS_Store\n.idea\n"
        },
        {
          "name": "Bounties.md",
          "type": "blob",
          "size": 4.41015625,
          "content": "# Policies w/regards to bounties for priority PRs\n\nIn recognition of the large number of issues that need to be fixed here, and of the fact that I've got a pile of inventory for my Tindie store, I've decided to begin offering bounties on priority issues. For now, this will be limited to documentation issues. If it works out I may expand it to code as well.\n\n## Available \"Bounties\" will be listed in Issues\nThese will list the requirements for successfully claiming the bounty. The value of the bounty will be listed in the title of the issue. These requirements will be quite specific, as the whole point is for me to avoid having to do extensive editing before merging the PR.\n\nAdditionally, two things not listed in issues are worth a bounty:\n* A demonstration of how to use the avr_gcc function attribute \"warning\" to produce a warning if and only if a function declared with that attribute is **reachable** (this is supposed to work like #error, which generates an error only if the function declared with the error attribute is reachable after preprocessing, link time optimization, and constant folding. This is very different from the #warning directive, which generated a warning if it is present anywhere in the code after preprocessing. See badArg() and badCall() in Arduino.h and examples of how I use it in wiring_digital.c. I want the same thing for warnings.\n* An investigation of the ADC on the tragic ATtiny828, because I am dying of curiosity. See [my unsolved mysteries page on it](https://github.com/SpenceKonde/AVR_Research/blob/main/UnsolvedMysteries.md#the-828-and-the-mystery-of-the-adc) - in short, there is extremely strong evidence to suggest that there is a very fancy differential ADC that was planned for that part, and scrubbed at the last moment, with signs of a hasty editing of the datasheet to remove refeences to it. The register layout is identical to the Tiny841's layout, and it had a VERY fancy differential ADC. Based on the huge number of pins with analog inputs, it seems like the ADC was to be the crown jewel of the 828. My theory is that the window for release of the last classic tinyAVRs was closing, and it came back from the fab and the ADC was busted. The engineers asked for a respin, and management said \"no\", and so they released it was is. I speculate that they would not have released it at all if there was not *some* semblance of the differential ADC functionality there - that there was a workaround - but it was too complicated or too embarrassing to describe in the errata; thus certain friendly customers (maybe ones involved in planning the part) know the trick to make the ADC run (or at least limp) in differential mode. I would love to close the book on this with either a conclusive proof that the unused mux options do nothing (A 27 level resistance ladder connected to every pin except the UART Tx pin, which can have it's ends swapped would be a good place to start - if you measure every unused option (use ADC_CH1, or information on the state of the ADC in production silicon.\n\n## All bounties will be in the form of free stuff from my Tindie store\nFree shipping via USPS first class mail is included for domestic bounty claimants. Due to the higher cost of international shipping, $8 will be debited from the value of the bounty if shipping internationally.\n\n## If you have any questions about the requirements, email me before you start working\nThat way you can save yourself time and trouble, and it will save me the awkward conversation if a submitted \"bounty\" PR ends up not meeting the requirements for inclusion in core. My email address is spencekonde@gmail.com\n\n## Offer void where prohibited\nThe world is full of dumb laws. I am not aware of any that prohibit this specifically as no purchace is required. You are responsible for paying any taxes, duties or other fees per your jurisdiction.\n\nObviously, we cannot honor bounties earned by persons residing in nations covered by applicable US economic sanctions, since awarding such a bounty would constitute a felony under US law (and that's where I live). Additionally, I cannot award a bounty to any person whom I have reason to suspect is planning to transfer it a nation or person covered by applicable sanctions. However, since I am not an international trade lawyer, I cannot assess whether sanctions are applicable, so to save my own skin, I have no choice but to assume that any sanction that could be construed as applying in any way (which is most of them) is applicable.\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 2.6552734375,
          "content": "# Contributor Code of Conduct\n\nAs contributors and maintainers of this project, we all pledge to treat\nall people who contribute through reporting issues, posting feature\nrequests, updating documentation, submitting pull requests or patches,\nand other activities with common decency at minimum.\n\nTo this end, there is to be no harassment, personal attacks, or other\ntrashtalking directed at any member of the community, whether over any\nracial, sexual, religious, national identity, over personal grudges\ntowards other members from here or elsewhere. In general, most of these\nforms of prohibited content involve either off topic posts, spam, or\nbeing an asshole or a plagerist - so stay on topic, don't post spam and\ndon't be an asshole either to others or in general.\n\nNote that mild trashtalk of organizations or companies as a whole (but\nnot individuals working there) - Microchip, Atmel, and Arduino are\ncertainly valid targets - but only insofar as it relates to a technical\nmatter already being discussed.\n\nAlso, obviously, images that are disturbing, sexual, or harassing (or\notherwise which have nothing to do with the repo) should not be posted.\nNo content that is illegal is to be included in any post, commit or PR.\nNo intimidating, threatening, advertising (whether goods, services or\npolitical opinions - this does not prohibit brief mentions of products\nsold by contributors which are that are relevant to an existing\ndiscussion - but only if it constitutes a small portion of the post,\nand the post is concerned primarily with the matter at hand, not your\ncommercial product).\n\nNo content that is not open source is to be submitted by anyone other\nthan the copyright holder. Open source code with a license incompatible\nwith LGPL 2.1 may be permitted, but only if it's particularly valuable,\nas was done for the code from adafruitNeopixel which became tinyNeopixel.\n\nProject maintainers have the right and responsibility to remove, edit,\nor reject comments, commits, code, issues, and other contributions that\nare not aligned to this Code of Conduct. Project maintainers or contributors\nwho do not follow the Code of Conduct may be banned temporarally or\npermanently, depending on the severity of the offence. To date we have not\nhad any instances of such behavior.\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may\nbe reported by emailing `spencekonde@gmail. com>` which only goes to to\nSpence Konde.\n\nThis Code of Conduct is adapted from the examples cited by GitHub, which was adapted from the `Contributor\nCovenant <http://contributor-covenant.org>` version 1.0.0, available at\n[http://contributor-covenant.org/version/1/0/0/](http://contributor-covenant.org/version/1/0/0/).\n"
        },
        {
          "name": "ChangeLog.md",
          "type": "blob",
          "size": 13.9990234375,
          "content": "# This document lists significant changes and bugfixes, including those not in yet in a release\nAny changes listed at the top, without a version number above thenm, have not been in a release yet, but can be downloaded from github for manual installation.\n## Planned 2.0.0\n* Refurbish and standardize all variant files.\n  * Add defines for all differential channels and gain options\n  * Remove legacy PIN_xn defines from parts that had them\n  * Ensure all parts have standard PIN_An and PIN_Pxn defines\n  * Ensure consistent defines for peripheral pins.\n  * Convert all PROGMEM arrays that contain PORT/PIN/etc registers to contain uint8_t's (all applicable registers are at address < 256) (this was always done on \"modern\" core).\n  * Add defines for the pins used for Serial in a consistent manner.\n  * Format variant files consistently.\n  * `An` (analog channel) defines and differential channels have high bit set, so the core can differentiate them from digital pin numbers.\n  * All reference defines get the bits shifted into position with the ADC_REF() macro, so the reference can be applied with less code at runtime. This saves time and flash (around 30 clocks, 24 bytes)\n  * Create variant files for 841, 828, 1634, including new pin mapping option for 1634 which is better than that awful old one\n* All functions that take a pin number or analog channel will test the high bit. They will interconvert as needed.\n* Add support for tuning based on values stored in flash (if bootloader in use - at end just before version number), or at end of EEPROM (if no bootloader - must set EESAVE for this to work)\n* Remove the second core that had been used for 841/828/1634\n* analogRead():\n  * Add support for ADC noise reduction mode on parts that have that functionality.\n  * Add support for analogRead() with differential channels and available gain options.\n  * analogReference() immediately sets the reference bits (necessary if using XREF option for x7 parts, probably helps whenever cap is used with first few readings, otherwise harmless) *\n  * Compile-time error checking for passing constants to analogRead() that aren't analog channels or digital pins with ACD input, calling analogRead() on x313 (with no ADC).\n  * Runtime error checking invalid ADC calls *\n* PWM and Timers:\n  * PWM with 841/441/828 will leave COM bits untouched, and just turn the TOCCMOE bits on and off, so it won't stomp on user code that changes the timer mapping or configuration. (#471)\n  * Code commenting has been edited for accuracy and improved. In the past, we were always trying to \"guess\" at what future parts might have for registers, and testing for registers rather than part identities. But this is now a core for a static set of parts (Well, except maybe the ATtiny26, which someone is paying me to add). Though we always should have done this, there's now no excuse for not putting comments indicating what parts these are trying to select for (at least where the #ifdef'ed code is dealing with some idiosyncrasy of specific parts. Which was like, most of the time this was done). This used to make wiring.c in particular very hard to read \"Okay, if TCCR1E exists, they're doing some really crazy shit. Which parts does this apply to? I'm here to change something on the ATtiny x5 parts - which pieces of this code should I be looking at?\"\n* Improve TinySoftwareSerial:\n  * setTxPin() now works correctly.\n  * x61 has three options for the RX pin.\n  * Add option to disable RX. TX is automatically disabled if you don't reference Serial.\n  * Tighten up the assembly by making use of SBIC, and make sure it waits until the start of the first stop bit always but never longer than necessary.\n  * Improve overall efficiency of initialization (it was guilty of SBI/CBI macro abuse)\n  * As of 2/2/22 it now appears to work.\n* Todo: Further platform.txt enhancements.\n* Adapt digitalI/O functions to use PUE registers if appropriate.\n* PWM on third channel on x61\n* Support REMAP and USIPP registers on x41 and x61 respectively.\n* Add some dumb IO pin related shit to ATTinyCore.h, see that README.md\n* Micronucleus\n  * Design hardware for testing with.\n  * Add pins to pins_usb.\n  * Implement new entry condition options.\n  * Create template bootloaderconfiguration with pins_usb content integrated\n  * Create configurations for each combination of board and entry condition:\n    * Both pin options for 84, 841\n    * Both LED options for 87, 167\n    * 861, 85, 88, 1634\n* ~Optiboot improvements~\n  * ~Support compile-time specification of soft serial pins, use to support the stock software serial pin options on x61.~\n  * ~Support REMAP register of 841/441.~\n  * ~Minor general code cleanup to get rid of crap that isn't related to ATTinyCore (ie, stop pretending that it would still work for non-tiny parts)~\n  * ~Makefile.tiny and makeall.tiny.bat are now autogenerated by create_boards_txt.py since they should match what boards.txt says.~\n* Quite possible that optiboot will be replaced with urboot - here's where we really need it.\n* Boards.txt refactor.\n  * Make most boards compile Bare Minimum example.\n  * Add support for external clock on all parts.\n  * Add support for 2 and 4 MHz from internal on all parts. This is done by dividing the 8 MHz clock. **THE BOOTLOADER RUNS AT 1 MHz IN THIS CASE - I am NOT going to build a million versions of Optiboot** Unfortunately it's looking like I will need to build a still ridiculous amount of them.\n  * boards.txt shallt not be manually edited, it is created with create_boards_txt.py. The file size is untenable to maintain by hand!\n* Attend to platform.txt and boards.txt UI constistancy issues from email\n* Deal with missing data from header files for some parts:\n  * SIGRD/RSIG,\n  * and PCMSK on 4313 which should have been PCMSK0 (#564)\n  * TIM/TIMER\n* Remove bloat from hardware serial due to CBI/SBI abuse; in multiple place the CBI or SBI macro was used in 4 lines back to back... but what they passed to it was a `_BV(member_variable)`. The calculation of the leftshifted value cannot be done ahead of time (classes kneecap the optimizer). That saved around 100 bytes. Saved over a hundred more for the 841, 441, and 1634 by doing the split file trick.\n* Todo: Optiboot\n  * Adjust optiboot upload speeds, they were not chosen well previously (sorry, this does mean burn bootloader may be required - that's why it's 2.0.0 not 1.x.x; they will work better, and in some cases, upload more quickly too - particularly where there is no hardware USART.\n  * Fix issue with ATtiny48 binaries not writing (something is clearly wrong with the size checking, they should *not* have built like that. (#575))\n  * Write script to generate new makefile. Each speed for each part needs two builds 1 second (autoreset, no run on POR), and 8 second (no autoreset, do run on POR).\n  * 441, 841, and 1634 need one for each of their two ports.\n* Programmers.txt\n  * Reorder the entries in descending order of usefulness.\n  * Add support for FTDI sync bitbang with those chinese adapters with the ISP headers\n* ATTinyCore.h now does more than just act as a placeholder.\n* Switch to gnu++17 standard instead of gnu++11.\n* Fix macros like constrain, min, max, etc so they do not do unexpected things when given arguments with sideffects\n\n\n## 1.5.0\n* Dramatic improvement in execution time and flash use with constant pins for digitalWrite/etc (thanks @yumkam!)\n* Improvements to millis and micros timing, as well as delayMicroseconds particularly for oddball frequencies. (big thanks to @cburstedde!)\n* Update to Micronucleus 2.5 upload tool, now available for all Arduino platforms (#465, #477)\n* Add new rationalized pinout for x61\n* Correct bug with pin definitions for I2C pins on the ATtiny x61 series (#455)\n* Improve timing calculations for Wire on USI devices (#455)\n* Correct critical regression introduced in 1.4.0 where PWM controlled by timer 1 would have 1/4th of the expected duty cycle and frequency (#470)\n* Fix Serial RX on parts that use tinySoftSerial - LTO broke this because the ring buffer was updated in the ISR but none of the variables were declared volatile... (#472)\n* Correct name of bootloader file for 841 Micronucleus\n* Add missing bootloader options for 841/441 parts\n* Correct documentation for x313 parts to correctly reflect number of available PWM pins\n* Clarify USBTinyISP programmer options (#507)\n* Add several missing programmers, improve programmers list\n* Fix Timer1 PLL clock source menu option on x5, x61 (1.4.0 fix still didn't do it!)\n* Fix x313 pinout image to reflect OC0B's existence\n* Add in new Adafruit_NeoPixel functions to tinyNeoPixel\n* Add Serial.setTxBit() for parts that use tinySoftSerial. Call it before Serial.begin() to move the Tx pin to another pin/bit on the same PORT (#443)\n* Correct PWM frequency on ATtiny x5 and x61 parts operating below 3 MHz (#463)\n* Move PWM on pin 1 (PB1) on x5 to timer1 instead of timer0\n* Select /32 prescaler where available when operating with a system clock between 3 and 8 MHz, moving PWM on those pins back to the targeted 500 Hz to 1 kHz range\n* Correct WGM for Timer 1 PWM on x7 to phase correct (0b0001) rather than fast (0b0101) pwm modes\n\n### 1.4.1\n* Correct severe regression in timekeeping on 841, 441, 1634, and 828 in version 1.4.0 (#445, 447)\n* Correct issue with included bootloaders for MH ET tiny88 micronucleus boards actually not working... re-bootload with ISP programmer to fix with the new bootloaders. (#439)\n* Add full suite of entry mode bootloaders for tiny88 micronucleus.\n* Fix issue with upgrading bootloader with Micronucleus.\n* Correct with timekeeping on x61 parts (1.4.0 regression in timer initialization).\n* Use learnings from Micronucleus f/w source code to safely change internal oscillator by dramatic amounts on the t841 (and others, but most relevant here)\n* Change \"USB tinyISP\" to \"USB tinyISP FAST\", and increase bit clock significantly. Previously we had the normal version at 200kHz and the SLOW at 125kHz, which was redundant, and made the USBtinyISP agonizingly slow, even with the tiny memory of these parts.\n* Add in ASCII art pinout to pins_arduino.c for TinyX8_MH pin mapping (#434 - thanks @AingeruJM!)\n\n### 1.4.0\n* Add support for MH-Tiny T88 pin mapping.\n* Add support for MH-Tiny T88 boards, because I just got a bunch and it didn't look too hard.\n* Add support for the DigiSpark Pro pin mapping for the ATtiny87/167 with other bootloader options.\n* Trim out references to unsupported parts from Servo library. I am almost positive it did not work on a significant number of parts! I think it should generally work now...\n* Servo will clean up after itself if you detach all the servos.\n* Fix ATtiny2313/2313A related issues (getting the #defines from the headers for the A, while still being able to upload)\n* PLL as Timer1 clock source now actually enables the PLL.\n* noTone() now correctly cleans up after Tone().\n* Significant cleanup in wiring.c\n* Included Servo library now works with PLL as Timer1 clock source (trivial fix - I clearly never looked into it when I merged in the 8-bit servo code!). Now it also lets you use Servo if you have external crystal running at unsupported speed if you use the PLL for Timer1...\n* Major improvements to part-specific documentation pages.\n* Remove the HAVE_BOOTLOADER mechanism, which existed to clean up timer registers that a bootloader may have left configured. Neither Optiboot not Micronucleus do this, so HAVE_BOOTLOADER had no function. Is now commented out in the pins_arduino's where it existed, as is the code it enabled. Saves a small amount of flash, and makes init() in wiring.c far easier to follow once the do-nothing code isn't visible.\n* Correct a number of typos in boards.txt\n* Fix several missing optiboot bootloaders\n* Add support for setting CLKPR so bootloaders off internal at speeds other than 8 and 1 MHz can work at less agonizing baud rates.\n* Fix inverted LED blinking on all parts\n* Fix LED blinking on x61 family (#264)\n* Add support for VUSB uploads to Digispark (t85, t167), Micronucleus/California STEAM (t84a)  Wattuino (841). Requires board manager installation, or another compatible board, in order tp pick up the support files.\n* Add support for 16 MHz with *INTERNAL* oscillator on ATtiny841, 441. Support is still experimental; there are a few caveats - see [ATtiny441, 841](avr/extras/ATtiny_x41.md)\n* Tested voltage dependence of internal oscillator, allowing significant simplification of the bootloader files for the ATtiny841/441,828,1643.\n* Support PIN_Pxn notation.\n* Document a few really odd GPIO features on ATtiny841, 441, 828.\n* Document minimum baud rate of builtin software serial \"Serial\" for parts without hardware serial.\n* Remove TUNED_OSCCAL_VALUE defines from pins_arduino.h for variants; this was set to OSCCAL in those files (despite the fact that we tested for whether it was defined before trying to use it!), leading to compiled binaries copying OSCCAL to a register and then writing it back. (thanks @ArminJo)\n* Fix bug when switching between I2C master and slave modes on USI devices (thanks @martin-schmied1)\n* Fix pulseIn(), both pulse length, and timeout (the latter is broken in official avr core too) (#384)\n* Add pulseInLong()\n* (untested) Don't generate .lst unless told to 'export compiled binary' (#379 - though note that that issue also appears to involve a problem with their compiler, or maybe just an extremely perverse username that's breaking things)\n\n### 1.3.3\n* Add support for external CLOCK on 48/88/828. Document how to use external clock on other parts via manual AVRdude step (#355).\n* Fix bug with using 32K ULP as clock source on 828.\n* A bit of boards.txt cleanup.\n* Serial hogged an unnecessary amount of ram on the 841/441/1634. Pulled in the latest version of HardwareSerial from the official AVR core; this sorts out that issue.\n* Add printf support to printable class.\n* Add CLOCK_SOURCE define to identify clock source (#358)\n* Add support for 4MHz internal on all boards (#358)\n* Add support for 16.5MHz on x5 and x61 (#349)\n* Documentation improvements (#373, #375)\n* Burn Bootloader now executes as a single command; this should fix issues with some programmers. (#372)\n\nPrior to 1.3.3, a proper changelog was not kept. See the releases for information about changes introduced during that timeframe.\n"
        },
        {
          "name": "HowToHelp.md",
          "type": "blob",
          "size": 5.244140625,
          "content": "# How you can help ATTinyCore\n\n## Report Bugs\nPlease report bugs! That's how things get fixed - I am almost never aware of a problem until it is reported. Use the GitHub issues system, preferably. If not that, either via email (spencekonde@gmail.com) or via post on the Arduino forum, Microcontrollers section. **The objective of these cores is to be the most thoroughly featured, best functioning core possible** for all supported parts.\n\n## Fix Bugs and PR\nIf you have already fixed a bug in my core for yourself, you can submit those changes via github as a \"pull request\". If you try to \"edit\" a file in this repo (and you're not me), it will automatically create a fork in your github account, where you can make changes, and then send them back to me as a PR. Just please don't forget to do that last step :-) I am also very happy to accept fixes via email or any other mode of communication short of wrapping them around bricks and throwing them through my window. Github just very clearly gives you credit for the submission :-)\n\nNote that the above includes spelling/grammar check - I write these in code editors without spell check, and I have a tendency to change how I structure sentences halfway through writing them, and not notice.\n\n## Library Listing\nThere are open issues on ATTinyCore and megaTinyCore for information on which libraries are and are not compatible. Thus far, I have not gotten any feedback on this, which is disappointing. It would be, I think, a great help to users if there were a list of which libraries do and do not work with these cores (and, for cases where they do not work - any information on alternatives to those libraries). For libraries that are particular priorities, I can intervene to try to add support or get support added (I recently did that with OneWire for the megaTinyCore parts (as well as non-4809 megaAVR 0-series and new Dx-series). Similarly, if you're a library designer wondering how to make their libraries work with any of my cores, I am more than happy to assist!\n\n## Spread the word\nThey say that \"big news travels fast\" - tinyNews needs all the help it can get. Tell your maker friends about ATTinyCore, megaTinyCore, and DxCore. There are a lot of tutorials and guides out there that point people to other cores, cores which are now minimally maintained, if they are maintained at all - so there's plenty of word-spreading to be done. The more people using ATTinyCore, the more people will be finding, reporting and/or fixing bugs, and the faster ATTinyCore will get better - so everyone wins here.\n\n## Last but by no means least - give me money\nI will be launching a Patreon in the near future. Additionally, you can support me buy buying things from my Tindie store. Everyone needs prototyping board - and even if **you** don't, they make a great gift for your loved ones who like electronics! And, for that matter, they're also great gifts for your unloved ones who don't do anything with electronics.\n\n## Rewards?\nWhile I can't promise anything beyond recognition for pull requests or other contributions - if you submit a particularly large or impactful contribution. that's a good way to get some free stuff from my Tindie store ;-) Which, naturally, is focused on things relating to the parts my cores supports, so it should be of particular use to you.\n\nTwo things are guaranteed to be worth a reward:\n* A demonstration of how to use the avr_gcc function attribute \"warning\" to produce a warning if and only if a function declared with that attribute is **reachable** (this is supposed to work like #error, which generates an error only if the function declared with the error attribute is reachable after preprocessing, link time optimization, and constant folding. This is very different from the #warning directive, which generated a warning if it is present anywhere in the code after preprocessing.\n* An investigation of the ADC on the tragic ATtiny828, because I am dying of curiosity. See [my unsolved mysteries page on it](https://github.com/SpenceKonde/AVR_Research/blob/main/UnsolvedMysteries.md#the-828-and-the-mystery-of-the-adc) - in short, there is extremely strong evidence to suggest that there is a very fancy differential ADC that was planned for that part, and scrubbed at the last moment, with signs of a hasty editing of the datasheet to remove refeences to it. The register layout is identical to the Tiny841's layout, and it had a VERY fancy differential ADC. Based on the huge number of pins with analog inputs, it seems like the ADC was to be the crown jewel of the 828. My theory is that the window for release of the last classic tinyAVRs was closing, and it came back from the fab and the ADC was busted. The engineers asked for a respin, and management said \"no\", and so they released it was is. I speculate that they would not have released it at all if there was not *some* semblance of the differential ADC functionality there - that there was a workaround - but it was too complicated or too embarrassing to describe in the errata; thus certain friendly customers (maybe ones involved in planning the part) know the trick to make the ADC run (or at least limp) in differential mode. I would love to close thebook on this with either a conclusive proof that no functionality at all existed there, or information on the state of the ADC in production silicon.\n"
        },
        {
          "name": "Installation.md",
          "type": "blob",
          "size": 1.7001953125,
          "content": "# Supported IDE versions\n\nATtinyCore (Universal) works with all versions of the official IDE (from arduino.cc ) from version 1.6.11 onwards (we have dropped support for versions prior to the fixes in 1.6.11 in 2.0.0), and it is known that manual installation would never work on older versions because they don't come with a toolchain that supports LTO, and the process of manually updating the toolchain is non-trivial. Plus - those versions are old as the hills now). Version 1.8.13 or newer is recommended. Version 1.9.x versions mostly did not work, however.  Version 2.0.4 might work, 2.0.3 does not.\n\nNote also that version 1.7.x versions are from the \"other\" arduino when arduino.cc and arduino.org got into a some sort of dustup, and arduino.org forked the IDE and increased the minor version to make theirs look newer. No 1.7.x version is supported.\n\n## Boards Manager Installation\n\nThis core can be installed using the boards manager. The boards manager URL is:\n\n`http://drazzy.com/package_drazzy.com_index.json`\n\n1. File->Preferences on a PC, or Arduino->Preferences on a Mac, enter the above URL in \"Additional Boards Manager URLs\n2. Tools -> Boards -> Boards Manager...\n3. Select \"ATTinyCore by Spence Konde\" and click \"Install\".\n\n## Manual Installation\n\nOption 1: Download the .zip, extract, and place in the hardware folder inside your sketchbook folder (if there is no hardware folder, create it). You can find/set the location of the sketchbook folder in the Arduino IDE at File > Preferences -> Sketchbook location.\n\nOption 2: Download the github client, and sync this repo to the hardware subfolder of your sketchbook folder.\n\n\n![core installation](http://drazzy.com/e/img/coreinstall.jpg \"You want it to look like this\")\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 26.3046875,
          "content": "# DxCore, megaTinyCore, and ATTinyCore are released under the LGPL version 2.1\nAll files included with these package are covered by this unless\notherwise noted. *Some included files and libraries are covered by other\nlicenses.* Any file licensed under terms other than the LGPL 2.1 will have\nprominent notice of such at the top of the file, including the full text\nof the boilerplate, as well as applicable license files in the directory.\n\nFiles licensed under the LGPL 2.1 may have that text abbreviated for\nreadability. The LGPL 2.1 license text is reproduced below verbatim\nwith no modifications beyond markdown formatting.\n\n## GNU LESSER GENERAL PUBLIC LICENSE\n\nVersion 2.1, February 1999\n\n    Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n    51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\n    Everyone is permitted to copy and distribute verbatim copies\n    of this license document, but changing it is not allowed.\n\n    [This is the first released version of the Lesser GPL.  It also counts\n     as the successor of the GNU Library Public License, version 2, hence\n     the version number 2.1.]\n\n## Preamble\n\nThe licenses for most software are designed to take away your freedom\nto share and change it. By contrast, the GNU General Public Licenses\nare intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.\n\nThis license, the Lesser General Public License, applies to some\nspecially designated software packages--typically libraries--of the\nFree Software Foundation and other authors who decide to use it. You\ncan use it too, but we suggest you first think carefully about whether\nthis license or the ordinary General Public License is the better\nstrategy to use in any particular case, based on the explanations\nbelow.\n\nWhen we speak of free software, we are referring to freedom of use,\nnot price. Our General Public Licenses are designed to make sure that\nyou have the freedom to distribute copies of free software (and charge\nfor this service if you wish); that you receive source code or can get\nit if you want it; that you can change the software and use pieces of\nit in new free programs; and that you are informed that you can do\nthese things.\n\nTo protect your rights, we need to make restrictions that forbid\ndistributors to deny you these rights or to ask you to surrender these\nrights. These restrictions translate to certain responsibilities for\nyou if you distribute copies of the library or if you modify it.\n\nFor example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou. You must make sure that they, too, receive or can get the source\ncode. If you link other code with the library, you must provide\ncomplete object files to the recipients, so that they can relink them\nwith the library after making changes to the library and recompiling\nit. And you must show them these terms so they know their rights.\n\nWe protect your rights with a two-step method: (1) we copyright the\nlibrary, and (2) we offer you this license, which gives you legal\npermission to copy, distribute and/or modify the library.\n\nTo protect each distributor, we want to make it very clear that there\nis no warranty for the free library. Also, if the library is modified\nby someone else and passed on, the recipients should know that what\nthey have is not the original version, so that the original author's\nreputation will not be affected by problems that might be introduced\nby others.\n\nFinally, software patents pose a constant threat to the existence of\nany free program. We wish to make sure that a company cannot\neffectively restrict the users of a free program by obtaining a\nrestrictive license from a patent holder. Therefore, we insist that\nany patent license obtained for a version of the library must be\nconsistent with the full freedom of use specified in this license.\n\nMost GNU software, including some libraries, is covered by the\nordinary GNU General Public License. This license, the GNU Lesser\nGeneral Public License, applies to certain designated libraries, and\nis quite different from the ordinary General Public License. We use\nthis license for certain libraries in order to permit linking those\nlibraries into non-free programs.\n\nWhen a program is linked with a library, whether statically or using a\nshared library, the combination of the two is legally speaking a\ncombined work, a derivative of the original library. The ordinary\nGeneral Public License therefore permits such linking only if the\nentire combination fits its criteria of freedom. The Lesser General\nPublic License permits more lax criteria for linking other code with\nthe library.\n\nWe call this license the \"Lesser\" General Public License because it\ndoes Less to protect the user's freedom than the ordinary General\nPublic License. It also provides other free software developers Less\nof an advantage over competing non-free programs. These disadvantages\nare the reason we use the ordinary General Public License for many\nlibraries. However, the Lesser license provides advantages in certain\nspecial circumstances.\n\nFor example, on rare occasions, there may be a special need to\nencourage the widest possible use of a certain library, so that it\nbecomes a de-facto standard. To achieve this, non-free programs must\nbe allowed to use the library. A more frequent case is that a free\nlibrary does the same job as widely used non-free libraries. In this\ncase, there is little to gain by limiting the free library to free\nsoftware only, so we use the Lesser General Public License.\n\nIn other cases, permission to use a particular library in non-free\nprograms enables a greater number of people to use a large body of\nfree software. For example, permission to use the GNU C Library in\nnon-free programs enables many more people to use the whole GNU\noperating system, as well as its variant, the GNU/Linux operating\nsystem.\n\nAlthough the Lesser General Public License is Less protective of the\nusers' freedom, it does ensure that the user of a program that is\nlinked with the Library has the freedom and the wherewithal to run\nthat program using a modified version of the Library.\n\nThe precise terms and conditions for copying, distribution and\nmodification follow. Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\". The\nformer contains code derived from the library, whereas the latter must\nbe combined with the library in order to run.\n\n## TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n**0.** This License Agreement applies to any software library or other\nprogram which contains a notice placed by the copyright holder or\nother authorized party saying it may be distributed under the terms of\nthis Lesser General Public License (also called \"this License\"). Each\nlicensee is addressed as \"you\".\n\nA \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\nThe \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms. A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language. (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n\"Source code\" for a work means the preferred form of the work for\nmaking modifications to it. For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control\ncompilation and installation of the library.\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope. The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it). Whether that is true depends on what the Library does and\nwhat the program that uses the Library does.\n\n**1.** You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a\nfee.\n\n**2.** You may modify your copy or copies of the Library or any\nportion of it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n- **a)** The modified work must itself be a software library.\n- **b)** You must cause the files modified to carry prominent\n    notices stating that you changed the files and the date of\n    any change.\n- **c)** You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n- **d)** If a facility in the modified Library refers to a function\n    or a table of data to be supplied by an application program that\n    uses the facility, other than as an argument passed when the\n    facility is invoked, then you must make a good faith effort to\n    ensure that, in the event an application does not supply such\n    function or table, the facility still operates, and performs\n    whatever part of its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of\n    the application. Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole. If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works. But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n**3.** You may opt to apply the terms of the ordinary GNU General\nPublic License instead of this License to a given copy of the Library.\nTo do this, you must alter all the notices that refer to this License,\nso that they refer to the ordinary GNU General Public License, version\n2, instead of to this License. (If a newer version than version 2 of\nthe ordinary GNU General Public License has appeared, then you can\nspecify that version instead if you wish.) Do not make any other\nchange in these notices.\n\nOnce this change is made in a given copy, it is irreversible for that\ncopy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\nThis option is useful when you wish to copy part of the code of the\nLibrary into a program that is not a library.\n\n**4.** You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\nIf distribution of object code is made by offering access to copy from\na designated place, then offering equivalent access to copy the source\ncode from the same place satisfies the requirement to distribute the\nsource code, even though third parties are not compelled to copy the\nsource along with the object code.\n\n**5.** A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\". Such a work,\nin isolation, is not a derivative work of the Library, and therefore\nfalls outside the scope of this License.\n\nHowever, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\". The executable is therefore covered by this License. Section\n6 states terms for distribution of such executables.\n\nWhen a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library. The\nthreshold for this to be true is not precisely defined by law.\n\nIf such an object file uses only numerical parameters, data structure\nlayouts and accessors, and small macros and small inline functions\n(ten lines or less in length), then the use of the object file is\nunrestricted, regardless of whether it is legally a derivative work.\n(Executables containing this object code plus portions of the Library\nwill still fall under Section 6.)\n\nOtherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\n**6.** As an exception to the Sections above, you may also combine or\nlink a \"work that uses the Library\" with the Library to produce a work\ncontaining portions of the Library, and distribute that work under\nterms of your choice, provided that the terms permit modification of\nthe work for the customer's own use and reverse engineering for\ndebugging such modifications.\n\nYou must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License. You must supply a copy of this License. If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License. Also, you must do one\nof these things:\n\n- **a)** Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library. (It is understood that\n    the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n- **b)** Use a suitable shared library mechanism for linking with\n    the Library. A suitable mechanism is one that (1) uses at run time\n    a copy of the library already present on the user's computer\n    system, rather than copying library functions into the executable,\n    and (2) will operate properly with a modified version of the\n    library, if the user installs one, as long as the modified version\n    is interface-compatible with the version that the work was\n    made with.\n- **c)** Accompany the work with a written offer, valid for at least\n    three years, to give the same user the materials specified in\n    Subsection 6a, above, for a charge no more than the cost of\n    performing this distribution.\n- **d)** If distribution of the work is made by offering access to\n    copy from a designated place, offer equivalent access to copy the\n    above specified materials from the same place.\n- **e)** Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\nFor an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it. However, as a special exception,\nthe materials to be distributed need not include anything that is\nnormally distributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\nIt may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system. Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\n**7.** You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n- **a)** Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other\n    library facilities. This must be distributed under the terms of\n    the Sections above.\n- **b)** Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n**8.** You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License. Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License. However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n**9.** You are not required to accept this License, since you have not\nsigned it. However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works. These actions are\nprohibited by law if you do not accept this License. Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n**10.** Each time you redistribute the Library (or any work based on\nthe Library), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions. You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties with\nthis License.\n\n**11.** If, as a consequence of a court judgment or allegation of\npatent infringement or for any other reason (not limited to patent\nissues), conditions are imposed on you (whether by court order,\nagreement or otherwise) that contradict the conditions of this\nLicense, they do not excuse you from the conditions of this License.\nIf you cannot distribute so as to satisfy simultaneously your\nobligations under this License and any other pertinent obligations,\nthen as a consequence you may not distribute the Library at all. For\nexample, if a patent license would not permit royalty-free\nredistribution of the Library by all those who receive copies directly\nor indirectly through you, then the only way you could satisfy both it\nand this License would be to refrain entirely from distribution of the\nLibrary.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply, and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices. Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n**12.** If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded. In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n**13.** The Free Software Foundation may publish revised and/or new\nversions of the Lesser General Public License from time to time. Such\nnew versions will be similar in spirit to the present version, but may\ndiffer in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number. If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation. If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\n**14.** If you wish to incorporate parts of the Library into other\nfree programs whose distribution conditions are incompatible with\nthese, write to the author to ask for permission. For software which\nis copyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this. Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n**NO WARRANTY**\n\n**15.** BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n**16.** IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n## END OF TERMS AND CONDITIONS\n\n## How to Apply These Terms to Your New Libraries\n\nIf you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change. You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms\nof the ordinary General Public License).\n\nTo apply these terms, attach the following notices to the library. It\nis safest to attach them to the start of each source file to most\neffectively convey the exclusion of warranty; and each file should\nhave at least the \"copyright\" line and a pointer to where the full\nnotice is found.\n\n    one line to give the library's name and an idea of what it does.\n    Copyright (C) year  name of author\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nAlso add information on how to contact you by electronic and paper\nmail.\n\nYou should also get your employer (if you work as a programmer) or\nyour school, if any, to sign a \"copyright disclaimer\" for the library,\nif necessary. Here is a sample; alter the names:\n\n    Yoyodyne, Inc., hereby disclaims all copyright interest in\n    the library `Frob' (a library for tweaking knobs) written\n    by James Random Hacker.\n\n    signature of Ty Coon, 1 April 1990\n    Ty Coon, President of Vice\n\nThat's all there is to it!\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 87.533203125,
          "content": "# ATTinyCore **Universal**\nArduino support for almost every classic tinyAVR device! Supports ATtiny 1634, 2313/4313, 24/44/84, 441/841, 25/45/85, 261/461/861, 87/167, 48/88, 43, 26 and 828.\n\nSupports programming via ISP, Serial (Optiboot) or VUSB (Micronucleus)\n## [Check it out, we have \"discussions\" now!](https://github.com/SpenceKonde/ATTinyCore/discussions)\nLet's use that, not gitter.\n\n## ATTinyCore 2.0.0 is available for public test. Things that don't work should be reported\n\n## ATTinyCore 2.0.0 - lots of changes, some of them big, a few of them may cause breakage\nI cobbled ATTinyCore together with far less experience than I have now (indeed, I'd barely covered the basics when I started trying to get a working ATtiny841 core). I like to think I have a much better idea of how a core should be designed now. But this meant some terrible decisions were made in the past. Decisions that we have been paying the price for ever since. I decided that the core should be advanced to a state where the bad decisions have been fixed, and everything that needs to be exposed on the parts is exposed in a consistent manner (too much was done incrementally, and not enough planning was done, ever). This core should not expect any significant new feature enhancements from here on out. The new feature development will be for megaTinyCore and DxCore, as those represent the future of the AVR architecture. Bug fixes will still be made.\nThe most significant changes are:\n1. **analogRead() and channel/pin numbers** ATTinyCore followed what the core it was based on did, which was to use analog channel numbers, not digital pin numbers for analogRead(). Originally, the An-constants were #defined as the number itself. Later, to make them work with the digital IO functions, I changed to  `#define An (n | 0x80)` - digital functions could check for the high bit, and if present, strip it off and use the analogInputToDigitalPin macro to find the digital pin number. I never did the inverse with analogRead() because it would have broken code which used the raw analog channel numbers. This is just absurd in this day and age, where every other core allows you to analogRead() digital pin numbers and it just works. As of 2.0.0, analogRead() takes either a digital pin number, a constant of the form An (one per analog pin, shown on pinout chart! corresponds directly to analog channels), one of the ADC_CHANNEL constants listed in the part-specific documentations pages (these are things like `ADC_TEMPERATURE` and `ADC_INTERNAL1V1`), or - assuming it has a differential ADC - one of the differential channels. If you were generating an analog channel at runtime, you can pass a number through the ADC_CH() macro to get a number that will be recognized as an analog **channel** number (this is preferred to directly setting the high bit, since it makes clear that you're doing it to get that analog channel). Several people to whom I have spoken about this to expressed disbelief that that was how it worked and unanimously favored this this change.\n2. **Differential channels!** Yeah - about half of the parts we support have them, and they can be useful for accurately measuring small differences in voltage. These vary per part - some are rather basic, while the t861 and t841 are very fancy - and are listed in full in the part-specific documentation. These are now fully supported. For parts that support both modes, there is also a way to select bipolar (-512 to 511) vs unipolar (0 to 1023) mode. Be warned that some parts only support one mode, and others only support the other, and some let you select it. *read the part specific docs for further information*.\n3. All the analog reference sources are named consistently, old (deprecated) names for references are still supported, but not recommended. **potential breakage** If you used to refer to a reference with a raw number, instead of the name (ie, if you did analogReference(0) instead of analogReference(DEFAULT), this will be totally broken for values other than zero (and 0 doesn't have a consistent meaning). The ADC_REF() macro can be used to convert from the REFS bits to a reference constant *if you must - but you shouldn't be using a raw number to select the reference if you want to be able to move it to different parts* - The 1.1v internal reference `INTERNAL1V1` is 2 on some parts, and 0 on others... almost everything has the 1.1v reference and everything can use Vcc, but that's really where the similarities end. If you are writing code that users might want to make work on any other part, you need to use the names, not numbers. With parts having at most 8 options for the analog reference, and most having fewer than that, I do not expect that this is a particularly burdensome requirement. .\n4. **Legacy PIN_xn constants gone** `PIN_An` constants have the standard meaning, ie, PIN_An is the digital pin that analog channel `An` is on. Previously some (but to my surprise and horror, not even all) parts had a set of `PIN_xn` constants defined that worked like the new `PIN_Pxn` ones do. I was reading pins_arduino.h from an official core a few weeks after implementing my `PIN_xn` constants for a bunch of parts and discovered that `PIN_An` was already in use meaning something different. Use `PIN_Pxn` where x is the letter of a port, and n is the number of a pin within that port.\n5. `PIN_Pxn` constants are in for all supported parts to refer to pins by port and bit. This is the recommended way to refer to pins, as it frees you from the need to consider which pin mapping is in use. If you soldered the LED to pin PB2, PIN_PB2 is going to control the LED no matter which pin mapping you have selected.\n6. For various historical reasons, some parts have up to 3 pin mappings. These are now named consistently, and listed and described in the part specific documentation - All parts have a recommended pin mapping, some of them have a second one for a specific VUSB board (digispark pro, MH-ET) with the pins numbered differently, and some of them have a \"legacy\" pin mapping with the pins in an order that makes less sense, and which makes converting between analog and digital pins harder (as in, if there is stuff determined at runtime, it uses more flash and is slower), but which has been widely used in the past and is what existing code may have been written for. A number of inconsistencies between these pin mappings (where information was missing from one or the other) have been fixed, and they are now formatted and commented consistently.\n7. The ATtiny1634 and ATtiny861 are now supported for Micronucleus. Test and demonstration boards will be available from my Tindie store. New versions of bootloader for all existing Micronucleus boards. Users should use the bootloader upgrade functionality to ensure that they have the latest version of the bootloader, and that it has their desired entry conditions (on reset pin, power on reset, power-on with pin held down, reset/power on w/reset held high (in case of disabled reset, holding the reset pin high during power on will make it enter bootloader - takes advantage of the fact that reset PIN bit always reads 0 when reset is not disabled... Actually, one wonders if it would work if you did PORTx |= 1 << RESETBIT; then test if that bit is set - does disabling reset actually make registers not store the value? If so, that would be even better - no dependence on hardware, clear the bit if could set it and run app, otherwise run bootloader. )\n\n## Main Documentation\nThe documentation, broadly, falls into two categories. The General Documentation applies to all parts.\n\nAdditionally, there are parameters that are specific to one or several families of parts. These cover the specifics of the peripherals on the parts (how Serial, I2C, and SPI are implemented on that hardware), the PWM frequencies that will be used at specific system clock frequencies, any additional options relating to the ADC such as differential inputs, and particularly notable or problematic errata, if any, applicable to this part. These are linked below.\n\nYou should **always review that part-specific documentation** before making any choice of parts. The time it takes to read them is far less than the time it takes to redesign with a different part when you're nearly done and then trip over some unexpected limitation... I try to catch the differences that might pose this hazard and describe them in these documents.\n\n### [General Documentation](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/README.md) - This applies to all supported parts\n### [Installation](Installation.md)\n### [Wiring and required external components](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Wiring.md)\n### [Using with Micronucleus boards](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Micronucleus.md)\n### [Programming Guide](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Programming.md)\n### [Migration Guide - moving to ATTinyCore from a different ATtiny board package, or to ATTinyCore 2.0.0 from an earlier version](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Migration.md)\n### Current **strongly** recommended IDE version: 1.8.13\n\n\n## Supported devices\nThis core supports the following processors - essentially every \"classic\" tinyAVR processor that makes sense to use with Arduino. The modern (post-2016 release) tinyAVR parts have [their own core](https://github.com/SpenceKonde/megaTinyCore), as there is practically zero code at the core level that can be shared with classic parts (porting application code (sketches) typically poses fewer challenges - code that did not stray from the Arduino API functions can be ported easily, while code that interacts with registers directly does need to be modified). Porting application code between different parts supported by this core is generally a matter of pin selection adapting to the different arrangement of peripherals among the pins on the two parts. Atmel seems to have picked their pin mappings with a dart board, so there's a lot of variation.\n\n* [ATtiny441, 841](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x41.md) (With or without Optiboot or Micronucleus bootloader) - One of the last classic tinyAVR parts released, and probably the single best of them. This has a second 16-bit timer (like Timer1) giving it a total of 6 PWM channels, two hardware serial ports, analog input on every pin with differential capability with programmable gain. On top of that, if you tune the internal oscillator to nearly the maximum, 90+% of these will run at 16 MHz.\n* [ATtiny1634](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_1634.md)  (With or without Optiboot bootloader - Micronucleus probably coming soon) - One of the last classic tinyAVR parts released. Sporting 16k of flash, 1k of RAM, and dual hardware serial ports spread across it's 18 I/O pins, this is one of the stars of the classic AVR line, though it would have really benefited if it got the same featureset that the 841 did.\n* [ATtiny87, 167](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x7.md) (with or without Optiboot or Micronucleus bootloader) - originally targeted at automotive applications, the x7-series offers 16 I/O pins, a hardware serial port with an advanced baud rate generator (it's intended for LIN, an automotive communication protocol, which requires flexible baud rate adjustment) and a differential ADC. TimerB is highly flexible about which pins it uses. A Digispark Pro was made with the Micronucleus bootloader (and the second-stupidest pin mapping I have ever seen on an AVR), and those are now available cheaply online. Before you ask - the stupidest pinpapping? That would be the one that the old ATTinyCore-with-167-support used before I took it over.\n* [ATtiny25, 45, 85](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x5.md) (With or without Optiboot or Micronucleus bootloader) - The most popular tinyAVR, with just 5 I/O pins, and available in a DIP package, this was popular even before the advent of the Digispark which paired it with the Micronucleus vUSB bootloader - those boards have now been widely cloned and are available for dirt cheap. This popularity is in spite of the tightly constrained pincount and weird Timer1 that is incompatible with many libraries. Can run from internal oscillator at 16 MHz using the on-chip PLL.\n* [ATtiny24, 44, 84](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x4.md) (With or without Optiboot or Micronucleus bootloader) - Probably the second most popular of the classic tinyAVR parts, being available in a 14-pin DIP package. There's nothing particularly exotic or standout about this, but it checks most of the boxes, having 2 PWM channels from each timer (both of which are normal and well-behaved), a modest differential ADC, and so on. No surprises really, either good or bad, and overall exactly what you'd expect from a 14-pin classic tinyAVR.\n* [ATtiny261, 461, 861](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x61.md) (With or without Optiboot bootloader - Micronucleus probably coming soon) - One of the stranger tinyAVR parts, this was designed with two tasks in mind: making differential ADC measurements, and controlling 3-phase BLDC motors. Timer1 is weird - a 10-bit variation on the high-speed timer that the x5 used (complete with the deadtime generator and PLL), with a third output compare channel. The differential ADC is arguably the best one on a classic tinyAVR (the t841 is the one one that could put up a fight, but lacks a separate AVCC pin, so I can't say I have much faith that the 100x gain isn't just amplifying noise), and until the release of the tinyAVR 2-series in 2021, was in the top tier of ADC capability (that top tier has now been replaced with a top tier composed of the 2-series alone, as they wait for the AVR EA's to join them)\n* [ATtiny26](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x61.md) (No bootloader. The predecessor of the already long-in-the-tooth x61-series). Added in 2.0.0 by commission from someone with a huge stash of them. Don't use these unless they're all you can get. Two PWM pins, and all the quirks of the x61, only more so. At least it's got a differential ADC that is on the same level as most classic tinyAVRs with differential ADC.\n* [ATtiny48, 88](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x8.md) (With or without Optiboot or Micronucleus bootloader) - a 32-pin (or 28-pin in DIP) tiny-ified version of the ATmega x8-series. Hardware TWI and SPI, lots of pins, and cheap - but no crystal, no hardware serial, and only timer1 can do PWM (at least it's a normal timer1). It should come as no surprise that the ADC the same boring 8-channel single-ended one the m328p has. Available with Micronucleus support as the \"MH-tiny\" or \"MHET tiny\" on eBay and Aliexpress.\n* [ATtiny828](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_828.md) (With or without Optiboot bootloader) - A 32-pin (28 I/O pin) part with hardware serial and an analog input on every pin - and a mysterious and tragic history that left it far less powerful than it could have been.\n* [ATtiny2313, 4313](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x313.md) (no bootloader) - An expensive, ancient chip with tiny amount of flash. For a long time it was the only tinyAVR with a USART. There are far better choices now.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n*\n\n* [ATtiny43U](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_43.md) (no bootloader) - An otherwise rather dismal part: 16 I/O pins, but only 2 PWM channels, timer1 is 8-bit not 16, and it only has a fe\n* w ADC channels - with one unique feature: *an on-chip boost converter* allowing operation from a single, partly discharged, alkaline battery. Unlike using an external boost converter, this can use it's knowledge of the chip state to inform the boost converter's tradeoff between power consumption and accurate regulation, saving significant power by letting running the DC-DC converter intermittantlty while the part is sleeping, allowing the voltage to droop nearly to the minimum voltage to retain data in RAM, instead of a stable 3V, and also lowers part count. It still requires an external schottky diode, inductor, and capacitor.\n\nVariants of these are also supported (such as the ATtiny1634R, ATtiny2313A or ATtiny85V)\n\n### Non-supported parts\nATTinyCore supports classic ATtiny parts. It does not support any other AVR devices - There is a different core for the ones that are practical for use with Arduino, depending on the product line:\n* [tinyAVR 0/1/2-series](https://github.com/SpenceKonde/megaTinyCore/) Modern tinyAVR (with 0, 1, or 2 as next-to-last digit) are supported by my megaTinyCore instead. They are totally different in every way except the \"t-word\" in the name, and many of them have a peripheral selection to make most classic AVRs turn gteen with envy (like a 3227 or 3226's peripera;s beat the stuffing out of many classic AVR parts, including the 328pb\n* [ATtiny13/13A](https://github.com/MCUdude/MicroCore/) are supported by MicroCore by @MCUdude - 2k of flash is the lower cutoff for ATTinyCore.\n* The ATtiny28L is not supported by any Arduino core. It is older than the hills, weirder than quantum physics... AND IT DOESN'T HAVE RAM! IT ONLY HAS REGISTERS! Put it back into the museum case where you got it before the security guards notice it missing from the \"prehistoric man and computing\" exhibit.\n\n* All AVR devices using the \"Reduced Core\" version of the processor (This includes the ATtiny 4/5/10/11, the tinyAVR 10x, and the tinyAVR 20 and 40). These parts are ill-suited to use with Arduino; their tiny flash and memory cannot handle the overhead of the arduino abstractions. The parts overall are thoroughly unimpressive devices: The peripherals are primitive, the memory is tiny, the processor has had half of it's general purpose working registers removed, and many of it's instructions are slower to execute than a normal AVR.\n* Despite the profound sacrifices made ostensibly to reduce the cost of the chip, they seem to have have little savings to show for it. Don't take my word for it, though - you can go try out [this core](https://github.com/technoblogy/attiny10core), which gives you an idea of what features can be fit into an arduino core for AVRrc (essentially nothing). \n* Anything with \"ATmega\" in the name - you want [one of MCUDude's cores](https://github.com/MCUdude/) - he has one for almost every ATmega part. '\n* The ATmegaXXcN and XXmN where X is the flash size and N is a small number. There is no core supporting these rarely seen or discussed classic AVRs. The c's are a follow-on to the ATCAN series (the older CAN parts are supported by some of MCUDude's cores) and the m series the follow-on to the PWM-centric parts of the same vintage (The more recent modern AVRs - namely the tinyAVR 1-series and Dx-series - have a Type D timer, which was clearly inspired by the PWM controller on those parts, making it interesting to those who study feature evolution semiconductors).\n* AVR Dx-series (AVR128DA64, etc) - [the crown jewel of the AVR product line](https://github.com/SpenceKonde/), supported by my DxCore.\n* AVR Ex-series (AVR64EA48, AVR32EB32, not yet for sale) will also be supported by DxCore ones the datasheets is available to clear up a few remaining questions about the EA and a ton of questions about the EB.\n\n## Quick Gotchas/FAQ list\n### Having trouble? read these first\n#### Windows users must install Micronucleus drivers manually\nIf you want to use Micronucleus (VUSB) boards on Windows, you must manually install the drivers - Arduino does not run \"post-install\" tasks for third party libraries, due to \"security\" considerations. This is of course nonsensical - if the core was malicious, it could do just as much by running the malicious command as part of a compile or upload recipe. I have gotten word that I am not the first person to raise this objection and that restriction will be removed from a future version of the IDE.\n\nDuring the install process it will print the path of a post_install.bat that it skipped running. Running that will install the drivers - it's easiest if you copy/paste it, as after installation the drivers will be located in `C:\\Users\\YourUserName\\AppData\\Local\\Arduino15\\packages\\ATTinyCore\\tools\\micronucleus\\2.5-azd1\\`  Or they can be downloaded from the following URL [https://azduino.com/bin/micronucleus/Drivers-Digistump(win).zip](https://azduino.com/bin/micronucleus/Drivers-Digistump%28win%29.zip) . Unzip, run the installation batch file.\n\n#### Timing or baud rates are wrong\nTypically 8x slower than expected - see below entry.\n\n#### When using an individual chip for the first time, or after changing the clock speed, EESAVE or BOD settings, you must do \"burn bootloader\" to set the fuses, even if you are not using the chip with a bootloader\nThe option should really be named \"Set fuses and install bootloader (if any)\" rather than \"burn bootloader\", which makes it sound irreversible (it's not), and by not mentioning the fuses, many users think that it isn't needed if a bootloader is being used. But it is, because this is the only time fuses are set; this is the same behavior as all other classic AVR cores, because it is possible to soft-brick the parts if the fuses are misconfigured, and so writing the .\n\n#### VUSB is not supported for USB functionality within the sketch\nIt has been persuasively argued to me that it is not possible to get these parts to meet USB timing constraints in an interrupt driven context without compromising on everything else. On the classical digispark, their core bent over backwards and got only mediocre results. The libraries floating around are stale, having rarely received updates, often dating back to the days of avr-gcc 4.8.x, and only ever worked on the digispark core - and even there they didn't work particularly well. USB timing constraints are very constraining. If anyone cared to put in the considerable amount of effort it would involve to port micronucleus and package the VUSB libraries, the pieces to make this viable *are actually present on the tinyAVR 0/1/2-series* (the key feature being the lvl 1 priority interrupt option though the improvements to instruction set timing don't hurt). But I don't know that anyone is showing much interest in taking that on.\n\nTo make matters worse, much of the functionality you want on Windows (namely, low speed CDC for a serial port) requires drivers that don't exist in a fully working form. Unfortunately, even if you found a solution to meet the USB constraint and made the drivers work, that's still not enough because you need to bend over backwards to install them if they haven't been blessed with a digital signaure from Microsoft, so it is difficult to get a solution you could share with the world\n\nI concluded that there are far too many obstacles here, and that it is dishonest to act as though this functionality works. There are a few cases that some people report success with (USB MIDI being one of them, IIRC); these are exceptions, not the rule. You may need to disable millis() timekeeping for reliable functioning.\n\n#### This core includes part specific documentation - click the links above for your family of chips and READ IT\nThe classic tinyAVR parts are a motley bunch - some of them are very mundane, with little to distinguish them other than the fact that they just work like you'd expect, while others are just bizarre. The part specific documentation covers most of the relevant topics that apply specifically to a given family of parts.\n\n\n#### Linux Package Manager versions should not be used\nThe maintainers of the package managers (despite being largely clueless about embedded software) frequently modify the IDE supplied with the package. Unfortunately this is done in ways that (because like I said, they are don't know what they're doing) which break the IDE. This breakage most often impacts third party hardware packages more severely (but not always). The Arduino IDE should always be installed from the tarball available from [http://arduino.cc](http://arduino.cc), never from a package manager.\n\n#### problems dynamically linking libusb-0.1 on linux\nSee above. This can occur if Arduino, or certain versions of Arduino, was installed through the Snap package manager.\n\n#### There are several problems encountered when using versions of Arduino older than 1.8.13\nThat version has been out for over a year and a half. While we do not intentionally break things on older IDE versions, we also do not test on older versions.\n\n#### Windows store version sometimes experiences strange issues\nThe windows store issues are difficult to reproduce on other systems, and no reliable solutions to them are currently known. We recommend using the .zip package or standard installer version of the IDE, not the Windows Store version.\n\n#### Problems programming some parts for first time, especially ATtiny841/441\nThese parts are less forgiving of the SCK clock rate being on the high edge of the spec.  Arduino as ISP or USBTinyISP SLOW will program without issue.\n\n#### Counterfeit/mismarked \"ATtiny85\" with wrong signatures\nEnable verbose upload output, and it will tell you what sig it actually saw. **0x1e9005** means you got scammed (all 0's or all F's is wiring problem, or bricked chip from choosing clock source that isn't present). Apparently one or more foreign sellers have been remarking the somewhat cheaper ATtiny13 as an 85 and ripping people off on ebay/etc. I am amazed that it is worth their effort.\n\n#### free(): invalid next size (normal) error\nThis error is due to a bug in AVRdude ( [https://savannah.nongnu.org/bugs/?48776](https://savannah.nongnu.org/bugs/?48776) ) - and it's a spurious error, as when it is displayed, the programming operation has actually completed successfully (you can see for yourself by enabling verbose upload, and noting the successful write before this error is shown. It is unknown under what conditions this error appears, though it has been recorded on a USBTinyISP on Linux when bootloading an attiny88 with optiboot.\n\n#### When using analogRead(), use the A# constant to refer to the pin\nPreviously (prior to 2.0.0) numbers were treated as analog channel numbers. Now they are treated as the digital pin number (the old behavior, when explained to people, generally got several incredulous clarifying questions, followed by something to the effect of \"I consider that behavior to be incorrect\", usually with some abbreviated profanity. Nobody liked the old behavior.\n\n#### When using I2C on anything other than the ATtiny48/88\nYou **must** use an I2C pullup resistor on SCL and SDA (if there isn't already one on the I2C device you're working with - many breakout boards include them). 4.7k or 10k is a good default value. On parts with real hardware I2C, the internal pullups are used, and this is sometimes good enough to work without external pullups; this is not the case for devices without hardware I2C (all devices supported by this core except 48/88) - the internal pullups can't be used here, so you must use external ones. **Even on the 48/88 you should always use external pullups** as the internal pullups are not nearly as strong as the specification requires.\n\n#### You cannot use the Pxn notation (ie, PB2, PA1, etc) to refer to pins\nthese are defined by the compiler-supplied headers, and not to what an arduino user would expect. To refer to pins by port and bit, use `PIN_Pxn` (ex, `PIN_PB2`); these are #defined to the Arduino pin number for the pin in question, and can be used wherever digital pin numbers can be used. We recommend this method of referring to pins, especially on parts with multiple pinmapping options\n\n#### All ATtiny chips (as well as the vast majority of digital integrated circuits) require a 0.1uF ceramic capacitor between Vcc and Gnd for decoupling\nthis should be located as close to the chip as possible (minimize length of wires to cap). Devices with multiple Vcc pins, or an AVcc pin, should use a cap on those pins too. Do not be fooled by poorly written tutorials or guides that omit these. Yes, I know that in some cases (ex, the x5-family) the datasheet doesn't mention these - but other users as well as myself have had problems when it was omitted on a t85.\n\n#### Extra aprox. 270 uA current during sleep mode\nTurn off the ADC before entering sleep mode.\n```c++\nADCSRA &= (~(1 << ADEN))\n```\notherwise it will waste 270 uA\n\n#### When in power down sleep mode, the clock is stopped - using a slower clock speed does not save power while sleeping\nI am asked very frequently about using very low clock speeds in low-power applications. Almost invariably, upon further interrogation, the user reveals that they plan to have the part in power-down sleep mode almost all the time. In this case, there is often little to be gained from running at a lower clock speed, since it only effects power use in the brief moments that the chip is awake - even more so because these moments may well be shorter when running at a higher clock speed. Halving the clock speed generally reduces power consumption by less than half while awake, so if you are spending almost all the time in sleep, you will in fact see very little change in battery life as you reduce the clock speed - and what change you do see will not be in the direction you were hoping for. Clock speeds below 1MHz can present problems while programming due to the programmer using an SCK clock speed too fast for the target chip running at such a low system clock speed.\n\n#### When using the WDT as a reset source and NOT using a bootloader\nRemember that after reset the WDT will be enabled with minimum timeout. The very first thing your application must do upon restart is reset the WDT (`wdt_reset()`), clear WDRF flag in MCUSR (`MCUSR &= ~(1 << WDRF)`) and then turn off or configure the WDT for your desired settings. If using the Optiboot bootloader, this is already done for you by the bootloader.\n\n## ATTinyCore Features\n\n### Optiboot Support - serial bootloader for ATtiny441/841, 44/84, 45/85, 461/861, 48/88, 828, 1634, 87, 167 only)\n\nThe Optiboot bootloader is included for the ATtiny441, 841, 44, 84, 45, 85, 461, 861, 48, 88, 1634, 828, 87 and 167. On parts with a hardware serial port, this is used (those lucky parts with two can choose the serial port from a tools submenu), other boards will use a software serial implementation (on these boards TX/RX pins are the same as the builtin software serial, the ones marked AIN0 (TX) and AIN1(RX)). The baud rate used depends on the system clock speed as shown in the table below.  Once the bootloader is programmed, the target can be programmed over serial; the bootloader will run after reset, just like on a normal Arduino. Bootloaders are not included for the 2k-flash versions of these parts - more than a quarter of the available flash would go to the bootloader, and the Arduino abstraction is already severely constrained with just 2k of flash. For these parts, we recommend ISP programming. Clock speeds lower than 1MHz are not supported because the resulting baud rates would be so low that it some serial adapters start having problems talking to them. At 1MHz, uploads are painfully slow. We recommend using the bootloader only at 8MHz or higher. If you are trying to save power, it is usually better to run at 8MHz and put the chip to sleep for most of the time.\n\nThe ATtiny441/841, ATtiny1634, ATtiny44/84, ATtiny45/85, ATtiny461/861, ATtiny48/88 and the ATtiny x7-family do not have hardware bootloader support. To make the bootloader work, the \"Virtual Boot\" functionality of Optiboot is used. Because of this, another vector is used to point to point to the start of the applications - this interrupt cannot be used by the application - under the hood, the bootloader rewrites the reset and \"save\" interrupt vectors, pointing the save vector at the start of the program (where the reset vector would have pointed), and the reset vector to the bootloader (as there is no BOOTRST fuse). Up until version 1.2.0 of this core, the WDT vector was used for this purpose. In 1.2.0 and later, the EE_RDY vector (which is not used by anything in Arduino-land - the EEPROM library uses a busy-wait) is used instead. **If the bootloader was burned with 1.1.5 or earlier of this core, the WDT cannot be used to generate an interrupt** (WDT as reset source is fine) - re-burning bootloader with 1.2.0 or later will resolve this.\n\n#### Big changes coming in 2.0.0\nThe baud rates used for uploading in 1.x were chosen poorly. 57600 baud at 8 MHz - and 115200 baud at 16 MHz - already has 2% baud rate error before accounting for any oscillator error - and it's in the direction that makes the most common oscillator error with the 841, 1634, and 828 worse rather than counteracting it. **Those baud rates were not appropriate** - they increased the chance that an internal oscillator would be too far off of the nominal frequency for serial communication, and this posed repeated headaches for users. The changes to the baud rates do mean that you need to reinstall the bootloader. These speeds were not changed for the 87/167: Those parts have a much better baud rate generator and do not suffer from baud rate accuracy problems like normal classic\nAVRs.\n\n 2.0.0 will use the following baud rates:\n\n| System Clock | Baud (UART) | Baud (softser) | Baud (LIN - 87/167 only) |\n|--------------|-------------|----------------|--------------------------|\n|       20 MHz |      115200 |          57600 |                   115200 |\n|     16.5 MHz |         n/a |            n/a |                      n/a |\n|       16 MHz |       76800 |          57600 |                   115200 |\n|     12.8 MHz |         n/a |            n/a |                      n/a |\n|       12 MHz |      115200 |          57600 |                   115200 |\n|        8 MHz |       76800 |          38400 |                   115200 |\n|        6 MHz |       57600 |          28800 |                    76800 |\n|   4 MHz xtal |       38400 |          14400 |                    56700 |\n|   4 MHz int. |       9600* |          4800* |                    9600* |\n|   2 MHz int. |       9600* |          4800* |                    9600* |\n|        1 MHz |        9600 |           4800 |                     9600 |\n|    3.686 MHz |       56700 |        14400** |                    56700 |\n|    7.372 MHz |      115200 |        38400** |                   115200 |\n|    9.216 MHz |      115200 |        38400** |                   115200 |\n|  11.0592 MHz |      115200 |        38400** |                   115200 |\n|  14.7456 MHz |      115200 |        57600** |                   115200 |\n|   18.432 MHz |      115200 |        57600** |                   115200 |\n\n`*` On these parts, the chip is started in 1 MHz mode via the CKDIV8 fuse, and that is the speed that Optiboot runs at, and only switched to the specified speed once the sketch starts running. One of the side benefits of this is that in many cases a single binary can be used for all of these speeds, as well as the 8 MHz (internal or xtal) or 4 MHz xtal cases, reducing the absurd number of bootloader binaries that we had to distribute.\n\n`**` These are USART crystals (they divide perfectly to common baud rates), and on parts with a hardware serial port, they eliminate calculation error in the baud rates. That's why can run the bootloader on parts with hardware serial at such high baud rates vs their clock speed - all the common baud rates come out perfectly (the limit on baud rate is from the calculation accuracy, not the speed of the target chip). The cost is that all other timekeeping is worse (takes longer to return and/or is less accurate). **there is no benefit to using a USART crystal on parts without hardware serial** as the math there doesn't have the factor-of-eight reduction in precision that comes with the hardware serial port. Software serial is a real hackjob anyway, and is not recommended for any purposes.\n\n16.5 and 12.8 MHz are not supported for Optiboot. Those speeds are achieved by tuning performed by the bootloader (if micronucleus, which of course isn't optiboot) or by the initialization code that runs before setup (but after the bootloader). Even when the target speed is 16.5 or 12.8 via tuning, Optiboot will run at 16.0 or 8.0 MHz.\n\n#### A warning about Virtual Boot\nVirtual boot relies on rewriting the vector table, such that the RESET vector points to the bootloader. This presents a potential issue: If the bootloader starts to write the first page, but then - for some reason - fails (such as a poorly timed reset right after the programming process begins), the page containing the reset vectors will be erased but not rewritten, with the result being that both the sketch and bootloader are hosed. The board will run neither the application nor bootloader until ISP programming is used to reinstall the bootloader. A solution is possible - and it is well known and tested on Micronucleus. But bringing that to optiboot is non-trivial.\n\n**Because of this issue, Optiboot should not be used for production systems**\n\nSee the [Programming Guide](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Programming.md) for more information on programming parts using Optiboot.\n\n### Micronucleus - VUSB bootloader for 841, 167, 85, 88 and 84/84a\nIt's finally here! As of 1.4.0, we now offer Micronucleus (aka Digispark) support for some of the more popular boards for these bootloaders. This allows sketches to be uploaded directly via USB, which many users find highly convenient. This comes at a cost in terms of flash - they typically use around 1.5k of flash, and they sometimes have problems connecting to specific USB ports. These boards are available from various vendors; see the part-specific documentation pages for more information on the implementation used on specific parts. For more information on using Micronucleus, see the [usage documentation](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Micronucleus.md).\n\n### Changing the ATtiny clock speed and other settings\n\nChanging the ATtiny clock speed, B.O.D. settings etc, is easy. When an ATTinyCore board is selected from the Tools -> Board menu, there will appear extra submenus under Tools menu where we can set several ATtiny properties:\n\n* Tools > Chip (Select the part being used )\n* Tools > Clock  (Select the desired clock speed and source)\n* Tools > Save EEPROM (Boards without bootloader only - controls whether EEPROM is erased during a chip erase cycle)\n* Tools > B.O.D Level (trigger voltage for Brown Out Detection - below this voltage, chip will be held in reset)\n* Tools > B.O.D. Mode (active): (441, 841, 1634, 828 only - see B. O. D. section below)\n* Tools > B.O.D. Mode (sleep): (441, 841, 1634, 828 only - see B. O. D. section below)\n\nAfter changing the clock source, BOD settings, or whether to save EEPROM on chip erase), you must do \"Burn Bootloader\" with an ISP programmer. See [Programming Guide](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Programming.md)\n\n#### Supported clock speeds\nSupported clock speeds are shown in the menus in approximate descending order of usefulness, ie, the popular clock speeds/sources are at the top, and the weird ones are at the bottom. See the notes for caveats specific to certain clock speeds.\n\nOptiboot is supported only on speeds of 1 MHz or more.\n\nMicronucleus boards have highly constrained options for clock speed, and the exact parameters depend on the part - refer to the part-specific documentation for more information.\nInternal:\n* 8 MHz\n* 1 MHz\n* 16 MHz (PLL clock, x5, x61 only)\n* 16 MHz (aggressively configured 441/841 only, including for vUSB support)\n* 4 MHz*** (except on x313, starts up at 1MHz and immediately switches to 4MHz before setup() is run)\n* 2 MHz*** (starts up at 1MHz and switches to 4MHz before setup() is run)\n* 16.5MHz † ! (PLL clock, tuned, x5, x61 only, for vUSB support)\n* 12 MHz † (Internal, tuned aggressively, for vUSB support)\n* 12.8MHz † (Internal, tuned aggressively, for vUSB support)\n* 0.5 MHz** ‼ (x313 only)\n* 512 kHz** ‼ ‡ (ULP - x41 only)\n* 256 kHz** ‼ ‡ (ULP - x41 only)\n* 128 kHz** ‼ ‡ (watchdog or ULP, all except 1643, 828)\n* 64 kHz** ‼ ‡ (ULP - x41 only)\n* 32 kHz** ‼ ‡ (ULP - 1634, 828, x41 only)\n\nExternal crystal (all except 828, 43 and x8-family):\n* 20 MHz !\n* 18.432 MHz* !\n* 16 MHz\n* 14.7456 MHz* !\n* 12 MHz !\n* 11.0592 MHz* !\n* 9.216 MHz* !\n* 8 MHz\n* 7.3728 MHz* !\n* 6 MHz !\n* 4 MHz\n* 3.6864 MHz* !\n\nExternal Clock:\n* 20 MHz !\n* 18.432 MHz* !\n* 16 MHz\n* 14.7456 MHz* !\n* 12 MHz !\n* 11.0592 MHz* !\n* 9.216 MHz* !\n* 8 MHz\n* 7.3728 MHz* !\n* 3.6864 MHz* !\n\n\nAll available clock options for the selected processor will be shown in the Tools -> Clock menu.\n\n`*` These weird crystals are \"UART frequencies\" - these divide evenly to common baud rates, so you can get a perfect match if this is required for your application - typical UART use cases do not require running at one of these UART frequencies, the usual caveats about software serial and baud rate accuracy on classic (pre-2016) AVR designs notwithstanding. These to not hold particular benefit for either the 87/167, nor parts without hardware serial ports. They are not recommended on parts without applicable hardware serial ports, as the odd clock speed imposes additional overhead.\n\n`**` These options are slow enough that many ISP programmers may not be able to program them. Depending on the ISP programmer (and in some cases the firmware on it), there may be a setting or jumper to slow the SCK frequency down for programming these parts, or it may automatically figure it out. The SCK frequency must be less than 1/6th of the system clock for ISP programming. Before using a such a low clock speed, consider whether you might be able to get lower power consumption by running at a higher base clock while staying in sleep most of the time - this results in fewer programming headaches, and in many (but not all) use cases results in comparable or lower power consumption.\n\n`***` The 4MHz internal option is useful if you are running near the minimum voltage - the lowest voltage for most of these parts is 1.8v, and at that voltage, they are only rated for 4MHz maximum. This starts up at 1 MHz and then switches to 4 MHz. Hence, bootloader performance is very slow, as it doesn't do this itself. The 2 MHz option serves the same purpose for the 841/441, which are within spec down to 1.7v - as long as the clock speed is kept to 2 MHz or below\n\n`†` These speeds support vUSB - 12 MHz and 16 MHz modes may not work reliably with aggressively tuned internal oscillators. 16.5 and 12.8 are much better - but 12.8 requires a very large amount of flash. Note that 64/12.8 is an integer, so this has inherrently better timekeeping capability than other odd speeds, though even the weird speeds do now work correctly. .\n\n`‡` The ULP is the \"Ultra Low Power\" oscillator that replaced the 128 kHz WDT oscillator on the 441/841/828/1634. Like the WDT oscillator, it is only calibrated very roughly - the spec is +/- 30% (over the whole operating range - so in practice it's usually not quite that bad). On the 1634 and 828, it always runs at 32 KHz, but on the 841, it can apparently clock the system up to 16 times that rate. Though there is a tuning register, and a nice looking tuning curve in the typical properties section of the datasheet, look more closely - there are only 4 points marked on the horizontal axis: Sure enough in the register, there are only 2 bits of tuning for it, and the fact that the graph shows curves instead of points is just a case study in how to lie with graphs and numbers.\n\n`!` Micros takes longer to return on these clocks - the math for micros is easiest if the prescaler used by the millis timer (almost always 64, except at extremely low clock speeds) can be evenly divided by the clock speed in MHz; in that case, we can just rightshift the number of ticks. When it can't, we use bitshift/addition ersatz division, which is slower (we never use actual division - We did VERY briefly, until someone noticed just how long micros() was taking to return)\n\n`‼` `micros()` and `delayMicroseconds()` require a system clock of 1 MHz or higher.\n\n**Warning** Particularly in versions prior to 1.5.0, When using weird clock frequencies (those other than 16MHz, 8MHz, 4MHz, 2MHz, 1MHz, 0.5MHz), micros() is significantly slower (~ 110 clocks) (It reports the time at the point when it was called, not the end, however, and the time it gives is pretty close to reality). This combination of performance and accuracy is the result of hand tuning for these clock speeds. For other clock speeds (for example, if you add your own), it will be slower still - hundreds of clock cycles - though the numbers will be reasonably accurate, and reflect the time when it was called. millis() is not effected, only micros() and delay().\n\nThis differs from the behavior of official Arduino core - the \"stock\" micros() executes equally fast at all clock speeds, and instead simply returns wrong values when  (64/(clock speed in microseconds) is not an integer. 12.8 MHz is a special case and is handled exactly by ATTinyCore (though not by the official one).\n\nThanks to @cburstedde for his work this his work towards making this suck far less in the 1.5.0 release!\n\n#### Using external CLOCK (instead of crystal) on other parts\nAll of these parts support using and external clock as clock source. It is the most basic of clock sources - whereas a crystal requires an internal inverting amplifier, typically one of the more demanding parts of the microcontroller, the external clock requires almost nothhing from the chip being clocked that way. What does this mean? On the few parts that do not support a crystal, it means you can get accurate timing. On everything else, it lets you get an extra pin as well. This comes at the cost of needing an additional part, external oscillator. These are available, but even the cheapest AliExpress sources I could find wantesd 40-80 cents each for them, and from reputable supply houses, they startt at around $1.40, likely making them the most expensive part on the board (or #2 if you cheap out and get random ones from china.). Many of them are in a fairly large 7050 (7mm x 5mm) package, though they are available in much smaller ones. They usually need their own decoupling capacitor (0.01uF is the norm) and like any high frequency trace, the path to the clock in pin must be short.\nWe now offer the option to use an external clock on all parts, at the same frequencies as a crystal is, except that especially slow speeds are dropped. External oscillators are power hogs! Don't use them if you care about power consumption!\n\n##### *\"oops! I thought my crystal was an external clock and now I can't program my chip!\"*\nNever fear. [Unbricking classic AVR parts bad clock setting](https://github.com/SpenceKonde/AVR-Guidance/tree/master/Troubleshooting/Unbricking)\n\n#### Determining clock speed and source from within the sketch\nThe clock speed is made available via the F_CPU #define - you can test this using #if macro. Note however that this tells you what speed it was compiled for. If the chip is in fact not running at that speed (because a different speed was selected when tyou last \"burned bootloader\", it has no way to know shhort of comparing to some other oscillator, (which sure, you could do with the RTC or something).\n\nIn version 1.3.3 and later, the clock source is also made available via the CLOCK_SOURCE #define. CLOCK_SOURCE can take one of the following values (as of 1.4.0, it is expanded to cover a few weird clocking situations: the low 4 bits identify the source, and high 4 bits identify special things regarding it:\n\n```text\n0 - Internal 8MHz oscillator, not prescaled, or prescaled to 1 MHz (ie, fully set by fuses)\n1 - External Crystal\n2 - External Clock\n3 - Internal WDT oscillator  (not available on the x41, 1634, and 828)\n4 - Internal ULP oscillator (available only on the x41, 1634, and 828)\n5 - Internal 4MHz oscillator (present only on the x313 parts - if the 8MHz internal oscillator is prescaled to 4MHz, CLOCK_SOURCE will be 0x10, not 5.)\n6 - Internal PLL (x5 and x61 only)\n16 or 0x10 (ie, 0x10 | 0) - Internal oscillator with prescaling not set by fuses (ie, not 1 MHz or 8 MHz - ie, 2 or 4 MHz)\n17 or 0x11 (ie, 0x10 | 1) - External crystal at 16MHz, which may be prescaled to get lower frequencies (for Digispark Pro ATtiny167)\n18 or 0x12 (ie, 0x10 | 2) - External clock  at 16MHz, which may be prescaled to get lower frequencies (for MH Tiny ATtiny88)\n22 or 0x16 (ie, 0x10 | 6) - Internal PLL prescaled to get a lower frequency (for Digispark et. al.)\n```\n### Assembler Listing generation\n\nIn version 1.2.2 and later, Sketch -> Export compiled binary will generate an assembly listing in the sketch folder; this is particularly useful when attempting to reduce flash usage, as you can see how much flash is used by different functions. In 2.0.0 and later it gemnerates a memory map. Tools submenu options which impact the compiled binary will be encoded in the name that the files are given.\n\n### Link-time Optimization (LTO) support\n\nLink time optimization is enabled by default. If compiling with very old versions of the IDE, this must be disabled. Cases do exist where this setting can change behavior of a sketch; in all cases where this has been observed, a bug in the code was hidden by one setting or the other, and/or undefined behavior was invoked. This is a problem with your code, not the core.\n\n### Makefile Support\n\nFor those who prefer to compile with a makefile instead of the IDE, sketches can be compiled with [https://github.com/sudar/Arduino-Makefile](https://github.com/sudar/Arduino-Makefile) - See the [makefile documentation](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Ref_Makefile.md) for more information on specific steps needed for this process.\n\n### I2C, SPI and Serial\nMost of these parts do not have hardware support for I2C, SPI, and/or UART (Serial) like an ATmega device would. **As much as possible we try to paper over the differences - you can include Wire.h or SPI.h and expect things to just work except as noted below** - this is achieved by a special version of Wire.h and SPI.h which presents the same API, but implements it very differebtly depending on the underlying hardeware. Hence **the use of libraries like USIWire, tinyWire, WireS, and so on is unnecessary** These libraries are also considered unsupported, as they should never be necessary. In the case of Serial/UART, where there is no hardware serial, the SoftwareSerial library can be used, but it is often undesirable because of how it takes over all the PCINTs. To address this, we provide a different software serial implementation which uses the analog comparator interrupt instead of a PCINT, allowing the PCINTs to be used freely. The RX pin is fixed, but the TX pin can be moved around to a limited subset of pins. See the serial section below for more information. The following table shows what hardware interface is available on each of these part.\n\n\n| Part(s)               | SPI           | I2C Master  | I2C Slave | Serial (TX* , RX) |\n|-----------------------|---------------|-------------|-----------|-------------------|\n| ATtiny x313           | USI           | USI         | USI       | 1x Hardware       |\n| ATtiny 43             | USI           | USI         | USI       | Software PA4, PA5 |\n| ATtiny x4             | USI           | USI         | USI       | Software PA1, PA2 |\n| ATtiny x5             | USI           | USI         | USI       | Software PB0, PA1 |\n| ATtiny 26             | USI           | USI         | USI       | Software PA6, PA7 |\n| ATtiny x61            | USI           | USI         | USI       | Software PA6, **  |\n| ATtiny x7             | Real SPI      | USI         | USI       | 1x Hardware (LIN) |\n| ATtiny x8             | Real SPI      | Real TWI    | Real TWI  | Software PD6, PD7 |\n| ATtiny x41            | Real SPI      | Software    | Slave TWI | 2x Hardware       |\n| ATtiny1634            | USI           | USI         | Slave TWI | 2x Hardware ***   |\n| ATtiny828             | Real SPI      | Software    | Slave TWI | 1x Hardware       |\n\n`*` - TX pin can be moved to any other pin on that port with Serial.setTxBit().\n`**` - RX can be on PA5, PA6, or PA7 (default), controlled by the tools submenu.\n`***` - Serial1 shares pins with the USI and slave TWI interface, which basically means you have to choose between USI (SPI or I2C master) or I2C slave, or a second serial port.\n\nThere are some specific considerations relevant to each of these interfaces, detailed below.\n\n#### SPI\nWhere real hardware SPI is available, SPI.h will behave identically to that on any classic AVR.\n\nOn USI parts, there are a few minor concerns, though most things will work without issue, and it should all be handled transparently via the SPI library.\n* **USI does not have MISO/MOSI, it has DI/DO**\n  * when operating in master mode, **DI is MISO, and DO is MOSI**.\n  * When operating in slave mode, **DI is MOSI and DO is MISO**. Note that like all other versions of SPI.h, slave mode is not supported. You must use a different library for that.\n  * The #defines for MISO and MOSI assume master mode, slave mode being unsupported). PIN_USI_DI, PIN_USI_DO, and PIN_USI_SCK are defined and can be used for operation in slave mode with some other library. Be careful to distinguish the MISO/MOSI/SCK pins marked as \"Programming Pins\" from the pins used for SPI from within the sketch - when programming a part via ISP, it is, after all, acting as a slave.\n* The clock dividers are implemented in software (a clock generator is one of the many things that USI lacks). Clock dividers of 2, 4, 8 and >=14 are implemented as separate routines; **call `SPISettings` or `setClockDivider` with a constant value to use less program space**, otherwise, all routines will be included along with 32-bit math. Clock dividers larger than 14 are only approximate because the routine is optimized for size, not exactness.\n* Interrupts are not disabled during data transfer. That means that an interrupt could fire in the middle of a byte, and one of the bits in that byte would be very long. This is usually fine. If it isn't, because you're working with devices that require consistent clocking, wrap calls to `transfer` in `ATOMIC_BLOCK` or disable interrupts in the normal ways.\n* Be aware that USI-based I2C is not available when USI-based SPI is in use (this should be obvious, as they used the same pins).\n\n\n#### I2C\nThe situation regarding I2C is more complicated; The ATtiny48 and ATtiny88 have real hardware I2C, which works like it does on ATmega devices. Like SPI.h, the Wire.h library will handle most of these differences, and most things will work the same way.\n\nMost other devices must use the USI for I2C. In these cases:\n* **You must have external pullup resistors installed** - unlike devices with a real hardware TWI port, the internal pullups cannot be used with USI-based I2C to make simple cases (short wires, small number of tolerant slave devices) work.\n* The option to set the clock as I2C master does not work. The SCL clock speed is fixed.\n\nA small number of devices have support for hardware slave I2C **but neither a USI nor hardware TWI for master operation**. On THOSE parts, some additional considerations apply:\n* I2C slave works great through the included Wire.h library.\n  * You can even do an alternate address or masked address (where several of the bits of the incoming address are ignored) by setting the `TWSAM` register. That register works the same way as it does on modern (post-2016) AVRs - however, no wrapper is provided around setting it, unlike the modern AVRs (ex, megaTinyCore and DxCore)\n  * On the ATtiny828, you must have the watchdog timer enabled in order for the USI to work in I2C mode; one of the pins in afflicted with one of the nastiest silicon bugs in a pre-2016 tinyAVR, and when the WDT is not enabled (interrupt mode with an empty interrupt is fine),\n* Software I2C Master, on the other hand is... a little flaky on these parts, most notably, it's not possible to tell whether a transaction timed out, or if the slave just responded with a bunch of 0's. There is no clock configuration functionality here either. If planning a new project, consider using a different device (might I recommend a [modern tinyAVR](https://github.com/SpenceKonde/megaTinyCore/)?) if I2C master mode is a big part of your application.\n\nRegardless of the implementation, simultaneously acting as both a master and a slave is never supported here. The hardware doesn't support it like it does on modern AVRs.\n\n##### Buffer size\nOn all parts with more than 128b of SRAM, the buffer size in 32 bytes. On smaller parts, it is 16 bytes, but I'm not sure you could make those work with the Wire library anyway due to flash size constraints so this may not be relevant. All official cores use 32b buffers, and it is for this reason that a 32b buffer is used even on parts where the pair of buffers leads to using a painfully large fraction of the RAM  - libraries implicitly depend on the buffer being at least 32b, often without the author even being aware of that fact.\n\n#### Serial Support\nTo most of us, the Serial interface is the most important of the big three serial protocols. All parts, whether or not they have hardware serial, will have an object named `Serial` that provides serial interface functionality. Where there is hardware serial, the Serial object is a normal fully featured, full duplex serial port that works just like any other AVR. The lucky chips that have two serial ports will also have Serial1 defined.\n\nUnfortunately, that's only 8 of the 21 parts supported by this core. The rest must use some form of software serial. While this core is fully compatible with the usual SoftwareSerial library, it comes with the usual disadvantages, most notably the fact that it grabs all the PCINT vectors for itself. To address that on the parts not blessed with hardware serial, we include a software serial implementation with a fixed (on the x61, there are three options, selected from a tools menu.) RX pin, and a TX pin with a limited number of options - but which leaves the PCINT vectors available. It uises the analog comparator interrupt, and requires that the RX pin be the AIN1 pin. TX defaults to the AIN0 pin.\n\nRegardless of how you achieve the software serial, however, you can still only transmit or receive on a single software serial instance at a time (SoftwareSerial or the builtin tinySoftSerial). Transmit is always blocking - a call that writes via software serial will not return until the data is sent unlike hardware serial which puts it into a buffer to send in the background.\n\n```c\n// In other words\nSerial.println(\"Hello World\");\n// on a part without hardware serial, which is hence using our builtin software implementation, is equivalent to:\nSerial.println(\"Hello World\");\nSerial.flush();\n```\n\n##### Moving builtin soft-serial TX pin\nThe builtin software serial port (\"Serial\" on parts without hardware serial) can be moved to any pin *as long as it is on the same port*. Use the `Serial.setTxBit(bit)` method. The 'bit' argument passed must be a number between 0 and 7, corresponding to the number within the port of the desired TX pin; **this should be called before** `Serial.begin()`. This option is only available on parts with the software serial.\n\n##### TX-only soft serial\nMany users have asked for a way to disable the receiving functionality of the builtin soft-serial entirely. New in 2.0.0, you can choose TX only the tools -> Software Serial menu. This will exclude everything except the transmit functionality. read() and peek() will always return -1, and available() will always return 0.\n\n##### Warning: Internal oscillator and Serial\nNote that when using the internal oscillator or pll clock, you may need to tune the chip (using one of many tiny tuning sketches) and set OSCCAL to the value the tuner gives you on startup in order to make serial (software or hardware) work at all - the internal clock is only calibrated to +/- 10% in most cases, while serial communication requires it to be within just a few percent. However, in practice, a larger portion of parts work without tuning than would be expected from the spec. That said, for the ATtiny x4, x5, x8, and x61-family I have yet to encounter a chip that was not close enough for serial using the internal oscillator at 3.3-5v at room temperature - This is consistent with the Typical Characteristics section of the datasheet, which indicates that the oscillator is fairly stable w/respect to voltage, but highly dependent on temperature.\n\nThe ATtiny x41-family, 1634R, and 828R have an internal oscillator factory calibrated to +/- 2% - but only at operating voltage below 4v. Above 4v, the oscillator gets significantly faster, and is no longer good enough for UART communication if the UART baud rate calculation error is in the same direction - See [the AVR baud rate chart](https://docs.google.com/spreadsheets/d/1uzU_HqWEpK-wQUo4Q7FBZGtHOo_eY4P_BAzmVbKCj6Y/edit?usp=sharing). These parts have a clock speed menu option for the internal oscillator when Vcc > 4v and when it is <= 4V; when the >4V option is selected, we'll takea guess at what the calibration should be lowered to, which should be enough to get serial working.. The 1634 and 828 (non-R) are not as tightly calibrated (so they may need tuning even at 3.3v) and are a few cents less expensive, but suffer from the same problem at higher voltages. Due to these complexities, **it is recommended that those planning to use serial (except on a x41, 1634R or 828R at 2.5~3.3v, or with a Micronucleus bootloader) use an external crystal** until a tuning solution is available.\n\n### ADC Support\nATTinyCore 2.0.0 introduces a major enhancement to the handling of analog and digital pin numbers: Now, in all the #defined constants that refer to an analog channel, the high bit is set. (ie, ADC channel 4, A4, is defined by a line `#define A4 (0x80 | 4));` (actually, we also define ADC_CH() macro as shorthand for the bitwise or with 0x80. This advantage of this that it makes it more obvious why we're doing this to the number; if you see (0x80 | 4) you'd be like \"wtf is this for? what does 0x80 have to do with anything?\", whereas if you hadn't read this, and you saw ADC_CH(4) - you might not know exactly what's going on, but just from the name you'd know it was something to do with an analog reading, maybe of channel 4). Because all the analog channel number defines are all distinct from things that aren't analog channel numbers, the core's analogRead and digitalRead functions can tell the two apart; digitalRead(A3) will now look up what digital pin analog channel 3 is on, and use digitalRead on that, while analogRead(7) will now go look up what analog channel is on digital pin 7, and use analogRead on that.\n\n#### Digispark Pro warning\nOn the ATtiny167 Digispark Pro pin mapping, \"An\" does not mean \"Analog Channel N\", it means \"The analog channel on the pin marked An on the Digispark Pro pinout chart\" - which is the same as digital pin n. Use ADC_CH(n) to choose analog inputs by channel number. This inconsistency sucks - but analogRead(A3) reading the pin marked A9 on the pinout chart that everyone uses for the Digispark Pro isn't great behavior either...\n\n#### Differential ADC support\nATTinyCore 2.0.0 includes proper support for using the differential ADC - which on many parts is as good as or better than the differential ADC found on ATmega parts of the same era (and in fact, in some use cases, is better than the one on the new AVR Dx-series parts!). Differential ADCs of varying sophistication are available on the following families of parts: x5, x7, x4, x61, x41. Refer to the part specific documentation for the details on how to use it - generally there will be constants you pass in place of the pin number (listed in a table on the part specific documentation page).\n\nSome parts will additionally have one or two additional configuration functions related to the differential mode:\n##### analogGain()\nanalogGain() is unique to the tiny841/441, which has too many differential channels and gain setting combinations to fit into a single byte. It is documented in the [ATtiny841/441 page](./https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/ATtiny_x41.md). as it only applies to those devices. All others with programmable gain pass the gain setting as part of the constant.\n\n##### setADCBipolarMode(bool bipolar)\nThis function is available on four families of parts including a total of 11 devices. These parts included an option to configure the differential ADC in either Unipolar mode or Bipolar mode. In bipolar mode, the value returned is signed. If reference was 1.0 V and you were looking at a pair of pins with voltages of 2.75 V and 2.5 V on them, your positive pin is 0.25 times the reference voltage above the negative pin and hence, the value returned would be 128. If the pins were reversed, it would be -128. In Unipolar mode, you gain an additional bit of precision.... if the positive pin is indeed larger. If it's not, you'll just get 0's back This is why some of the part have two options for a pair of pins, differing only in which one is positive vs negative - it's so you can swap the pins and use unipolar mode for higher accuracy. The argument is a boolean value indicating whether bipolar mode should be enabled (true = bipolar mode, false = unipolar mode. )\n\nNot all parts support the switch between unipolar and bipolar mode. The x4, x5, x61. and x7 do. The x41 supports only bipolar mode, while the 26 supports only unipolar mode. And obviously, devices without any differential ADC don't support this function either. Calling it for a part that doesn't support it will generate a compile error saying as much.\n\n##### ADC noise reduction mode\nNow that we've talked about ADC gain, which can be up to 100x on the 841 or 32x on the 861, we need to recognize that if you want to be measuring signal, rather than noise, you will need to take more care than usual. Some of this is in hardware - the AVCC pin (if present) should be connected with the inductor like the datasheet recommends rather than just being tied to Vcc like everyone in Arduinoland does normally. You should also probably be using the ADC noise reduction mode. This puts the processor to sleep during the conversion to reduce noise generated internally during that sensitive time.\n\nTo use ADC noise reduction mode, simply use `analogRead_NR()` instead of `analogRead()`. There are really only a few caveats here:\n* The I/O clock will be stopped. This means timers will lose time (13 ADC clocks per reading; the ADC clock is 100-200 kHz on these so that means between 65 and 130 us of time is lost by millis/micros per ADC reading) and PWM will stop.\n* If interrupts are enabled, pin change interrupts and the WDT interrupt will wake the part prematurely. This may impact the quality of the readings. You may wish to disable these interrupts if they are in use.\n* Do not disable interrupts globally though, because then the ADC interrupt won't be able to wake the part.\n* This uses the ADC interrupt vector. Hence if at other points in time, you wanted to, say, use the ADC in free running mode, and run your own interrupt when a new result is ready, this is not compatible with `analogRead_NR()`. However analogRead_NR is isolated in it's own file, along with the empty ISR, so unless you're using `analogRead_NR()`, you can freely define that vector yourself.\n\n### Timers and PWM\nAll of the supported parts have hardware PWM (timer with output compare functionality) on at least one pin. See the part-specific documentation pages for a chart showing which pins have PWM. In addition to PWM, the on-chip timers are also used for millis() (and other timekeeping functions) and tone() - as well as by many libraries to achieve other functionality. Typically, a timer can only be used for one purpose at a time.\n\nOn all supported parts, timekeeping functions are on timer0. This means that reconfiguring timer0 by manipulating it's registers will break `millis()` and `delay()`; this is not recommended unless millis is disabled entirely.\n\nOn all parts except the tiny841/441 `tone()` is on timer1; on 841/441. tone() is on Timer2 to improve compatibility; with Tone moved onto timer2, the many libraries that use timer1 (Servo, TimerOne, and many others) can be used alongside `tone()` on the 841/441. Using `tone()` will prevent PWM from working on PWM pins controlled by Timer1 (Timer2 for 841/441), and manipulating it's registers will break `tone()`.\n\nMost of the ATtiny parts only have two timers. The attiny841 has a third timer, timer2, which is an exact copy of the lovely 16-bit timer1, and completely different from the timer2 that most atmega devices have. Libraries designed to work with \"Timer2\" will not work on any of these parts, even the 841/441.\n\n### printf() support\nSerial and similar classes support the printf syntax. This feature, common on third party cores, is absent from the official cores. Unlike more modern cores we do not provide a menu to configure printf mode.\n\n### Built-in tinyNeoPixel library\n\nThe standard NeoPixel (WS2812/etc) libraries do not support all the clock speeds that this core supports, and some of them only support certain ports. This core includes two libraries for this, both of which are tightly based on the Adafruit_NeoPixel library, tinyNeoPixel and tinyNeoPixel_Static - the latter has a few differences from the standard library (beyond supporting more clocks speeds and ports), in order to save flash. Prior to 2.0.0, a tools submemu was needed to select the port. This is no longer required (the adafruit code was written with zero tolerance for any divergances from ideal timing; allowing for tiny divergences at points where it doesn't matter was all it took to reimplememt this without the need for that submenu. This code is not fully tested at \"odd\" clock speeds, but definitely works at 8/10/12/16/20 MHz, and will probably work at other speeds, as long as they are 7.3728 MHz or higher. See the [tinyNeoPixel documentation](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/tinyNeoPixel.md) and included examples for more information.\n\n### Additional configuration options\nThese are available from tools submenus\n\n#### Pin Remapping (x61, 441, 841 only, new in 2.0.0)\nThe x61-series can use either PORTA or PORTB pins for the USI. This must be chosen at compile time - implementing swap() like the megaAVR parts have would impose excess overhead.\n\nThe x41-series has two options for USART0 and two options for SPI. They are chosen independently, and the tools menu hence contains four options. (it's better than two menus, right?)\n\n#### Retain EEPROM\nAll non-bootloader board definitions have a menu option to control whether the contents of the EEPROM are erased when programming. This only applies to ISP programming, and you must \"burn bootloader\" to set the fuses to apply this. Because it only applies to ISP programming, it is not available for Bootloader board definitions. on Optiboot definitions, EESAVE is never enabled, but since only ISP programming will normally erase the EEPROM, the only time you'd be running into this is if you were \"rebootloading\" it - which should always return it to a known state - or were writing over the bootloader with a sketch (which you probably shouldn't be doing anyway). Meanwhile if that option was present, it would cause a great deal of confusion since it would apply only to an uploading use case that you shouldn't be doing, and to rebootloading, not to normal uploads.\n\n#### B. O. D. (brown out detect)\nBrown-out detection continuously monitors Vcc, and holds the chip in reset state (BOR) if the applied voltage is below a certain threshold. This is a good idea with slow-rising power supplies or where it is expected that the supply voltage could droop below the required operating voltage for the frequency it is running at (see the speed grade specification for the part you're using) - without BOD enabled, this can put the chip into a hung state until manually reset. However, BOD increases power consumption slightly, and hence may be inappropriate in low power applications.\n\nThe BOD voltage trigger level can be chosen from the tools -> BOD menu. The ATtiny441, 841, 828, and 1634 support independently configuring the BOD mode (active, sampled, disabled) for active and sleep modes (see the applicable datasheet for details). These are configured via the Tools -> BOD Mode (sleep) and Tools -> BOD Mode (active) menus.\n\nUnless the power consumption of the BOD is a show-stopper, **it is strongly recommended that BOD be enabled for any production system**. The failure mode from insufficient voltage is generally an ungraceful hang.\n\nIn all cases, the selected BOD option(s) is/are configured by the fuses, so after changing these, you must \"burn bootloader\" to set the fuses.\n\nBe aware that we do not check whether the clock speed and BOD threshold you selected make sense together. If you want to run at 16 MHz with a 1.8v BOD (which won't do a damned bit of good), we won't stop you.\n\n#### Option to disable millis()/micros()\n\nThe Tools -> millis()/micros() allows you to enable or disable the millis() and micros() timers. If set to enable (the default), millis(), micros() will be available. If set to disable, these will not be available, Serial methods which take a timeout as an argument will not have an accurate timeout (though the actual time will be proportional to the timeout supplied); delay will still work. Disabling millis() and micros() saves flash, and eliminates the millis interrupt every 1-2ms; this is especially useful on parts with very limited flash, as it saves a few hundred bytes. We do not support using alternate timers for millis like megaTinyCore and DxCore do - there, the timers are consistent - The same code on DxCore and megaTiny Core handles both the type A and Type B timers om those parts. Over here, except for the ubiquitous timer 0, there are almost as many versions of timer1 as there are parts.\n\n## Memory Lock Bits, disabling Reset\nATTinyCore will never set lock bits, nor will it set fuses to disable ISP programming (it is intentionally not made available as an option, since after doing that an HV programmer is needed to further reprogram the chip, and inexperienced users would be at risk of bricking their chips this way). The usual workflow when these bits are in use is Set other fuses -> Upload -> Test -> manually set the lockbits and/or fuses. This can be done from the command line using AVRdude. To expedite the process, you can enable \"Verbose Upload\" in preferences, do \"burn bootloader\" (the board and/or programmer does not need to be present), scroll to the top of the output window - the first line is the avrdude command used to burn the bootloader, including the paths to all the relevant files. It can be used as a template for the command you execute to set the fuse/lock bits.\n\nDisabling of reset is only an option for boards definitions with a bootloader which uses a sound flash-erase implementation (Optiboot presently does not, while the VUSB bootloaders which disable reset are in widespread use, seemingly without issue). We recommend against it in all cases. The 8 and 14 pin parts can be unbricked with a comparatively simple HVSP programmer (only 4-7 pins - 4 pins + reset for 8-pin, plus 3 more tied low on 14-pin). Everything with more pins needs an HVPP programmer, involving a wire connected to every pin or almost every pin on the chip. The sheer number of connections makes it unlikely that it could ever be unbricked in-system if the \"system\" is much more than a breakout board. HVPP is extremely exotic within the hobby community, such that I've never heard anyone talk about unbricking with HVPP.\n\n**USE EXTREME CAUTION WHEN USING THE USB UPDATE FOR MICRONUCLEUS** as you can update to a version of the bootloader that will not support your board.\n\n\n## Pin Mappings\n\n\n### ATtiny441/841\n![x41 pin mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x41.jpg \"Arduino Pin Mapping for ATtiny841/441\")\n\n### ATtiny1634\n![1634 pin mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_1634.jpg \"Arduino Pin Mapping for ATtiny1634\")\n\n### ATtiny828\n![828 Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_828.jpg \"Arduino Pin Mapping for ATtiny828\")\n\n### ATtiny25/45/85\n![x5 pin mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x5.jpg \"Arduino Pin Mapping for ATtiny85/45/25\")\n\n### ATtiny24/44/84\n![x4 Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x4.jpg \"Arduino Pin Mapping for ATtiny84/44/24\")\n\n### ATtiny261/461/861\n![x61 Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x61.jpg \"Arduino Pin Mapping for ATtiny861/461/261\")\n\n### ATtiny87/167\n![x7 Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x7.jpg \"Arduino Pin Mapping for ATtiny167/87\")\n\n### ATtiny48/88\n![x8 SMD Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x8.jpg \"Arduino Pin Mapping for ATtiny88/48 in TQFP\")\n![x8 DIP Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x8-PU.jpg \"Arduino Pin Mapping for ATtiny88/48 in DIP\")\n\n### ATtiny2313/4313\n![x313 Pin Mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_x313.jpg \"Arduino Pin Mapping for ATtiny4313/2313\")\n\n### ATtiny43U\n![ATtiny43U pin mapping](https://github.com/SpenceKonde/ATTinyCore/blob/v2.0.0-devThis-is-the-head-submit-PRs-against-this/avr/extras/Pinout_43.jpg \"Arduino Pin Mapping for ATtiny43\")\n\n\nNote that two pin mappings are supported for some devices to retain backwards compatibility with other cores - the pin mapping may be chosen from a menu.\n\nNote that analog pin numbers (ex A0 ) cannot be used with digitalWrite()/digitalRead()/analogWrite() - all pins have a digital pin number. Analog pin number should only be used for analogRead() - this represents a departure from the behavior used in the official AVR boards. This enables us to expose the advanced ADC functionality available on some of the ATtiny parts with minimal impact, as clearly written code is unlikely to fall afoul of this anyway.\n\n## Buy Breakout boards\nExcept for the x5, x4, x61, and x313-family, these are only available in surface mount packages. Breakout boards are available from my Tindie store (these are the breakout boards used for testing this core), which have the pins numbered to correspond with the pin numbers used in this core. Where applicable, all of these assembled boards have the bootloader installed, and all are set to run at the advertised speed (most are available with several speed/voltage combinations).\n* 841: [Bare boards](https://www.tindie.com/products/DrAzzy/attiny84184-breakout/) - [Assembled Boards]( https://www.tindie.com/products/DrAzzy/attiny841-dev-board-woptiboot/ )\n* 1634: [Bare boards](https://www.tindie.com/products/DrAzzy/attiny1634-breakout-wserial-header-bare-board/) - [Assembled Boards]( https://www.tindie.com/products/DrAzzy/attiny1634-dev-board-woptiboot-assembled/ )\n* 828: [Bare boards](https://www.tindie.com/products/DrAzzy/atmega-x8attiny-x8828atmega-x8pb-breakout/) [Assembled Boards]( https://www.tindie.com/products/DrAzzy/attiny88-or-828-breakout-board-assembled/ )\n* x61-family (861/461/261): [Bare boards](https://www.tindie.com/products/DrAzzy/attiny-16787861461261-breakout-bare-board/) [Assembled Boards](https://www.tindie.com/products/DrAzzy/attiny-861-or-167-development-board-assembled/)\n* x7-family (167/87): [Bare boards](https://www.tindie.com/products/DrAzzy/attiny-16787861461261-breakout-bare-board/) [Assembled Boards](https://www.tindie.com/products/DrAzzy/attiny-861-or-167-development-board-assembled/)\n* x8-family (48/88): [Bare boards](https://www.tindie.com/products/DrAzzy/atmega-x8attiny-x8828atmega-x8pb-breakout/) [Assembled Boards](https://www.tindie.com/products/DrAzzy/attiny88-or-828-breakout-board-assembled/)\n* ATtiny43 (including boost converter) [Assembled Boards](https://www.tindie.com/products/16617/)\n* SMD/DIP or DIP [ATtiny85 prototyping board](https://www.tindie.com/products/DrAzzy/attiny85-project-board/)\n* SMD or DIP [ATtiny84 prototyping board](https://www.tindie.com/products/DrAzzy/attiny84-project-board/)\n\n\n## Caveats\n* Some people have problems programming the 841 and 1634 with USBAsp and TinyISP - but this is not readily reproducible. ArduinoAsISP works reliably. In some cases, it has been found that connecting reset to ground while using the ISP programmer fixes things (particularly when using the USBAsp with eXtremeBurner AVR) - if doing this, you must release reset (at least momentarily) after each programming operation. This may be due to bugs in USBAsp firmware - See this thread on the Arduino forums for information on updated USBAsp firmware: [http://forum.arduino.cc/index.php?topic=363772](http://forum.arduino.cc/index.php?topic=363772) (Links to the new firmware are on pages 5-6 of that thread - the beginning is largely a discussion of the inadequacies of the existing firmware)\n* At >4v, the speed of the internal oscillator on 828, 1634 and 841 parts increases significantly - enough that serial (and hence the bootloader) does not work. Significant enhancements have been made on this front in 1.4.0; reburning bootloader should sort it out. These are further improved in 2.0.0. Avoid using 115200 baud and 57600 baud if using the internal oscillator and running an 828, 1634, or x41 at 4V or higher - those speeds are over 2% off due to baud calculation error in the same direction that the clock speed is off.\n* For that matter, don't use 115200 baud or 57600 baud on any classic AVR with a hardware serial port at 8/16 MHz, especially if they or the thing they are communicating with is using an internal oscillator. 115200 MHz is a failure prone baud rate at 16 MHz, as 57600 is at 8 MHz as well. Those speeds should be used only with a \"USART crystal\" as clock source, or a 12 MHz or 20 MHz clock source. For 8 and 16 MHz with hardware serial, 38400, 76800, and (at 16 MHz) 153600 get much better baud rate accuracy.\n* There is a right and a wrong way to perform a software reset.\n  * Unless you are using Optiboot and wish to reset *and* have the bootloader run, do not reset from software via `__asm__ __volatile__ (jmp 0)` - that performs a \"dirty reset\". Instead, enable the watchdog timer, set to reset the device on timeout, and then enter an infinite loop and wait for the reset 16ms later.\n  * Do not attempt to generate a software reset by connecting an I/O pin to reset and driving it low; this is specifically warned about in the datasheet.\n  * If using the WDT reset on an Optiboot board, no additional actions are necessary; The bootloader will see that the reset cause was the WDT, assume that it was the thing that generated the reset, turn off the WDT and start the application.\n  * If using the WDT reset on a non-optiboot board definition, you must turn it off at the very start of setup() - the chip will reset with the watchdog still running at the minimum timeout.\n  * Dirty resets are a Bad Thing. You want to do anything you can to avoid having to generate one, and to avoid accidentally generating one (a dirty reset is the normal result of smashing the stack or a number of other common programming errors - this is responsible most hangs caused by software bugs)\n  * The only time that a dirty reset is acceptable (it is never recommended) is when a bootloader is in use and you need to make the bootloader run from within the app. **if you do this you MUST ensure the following**\n    * (Optiboot) Timer1 and the UART (if any) used by the bootloader has been reset to the POR settings (all registers associated with peripheral set to 0).\n    * Interrupts must be disabled.\n    * If the chip is running at a prescaled or tuned clock speed, you must turn off the prescaling (unless chip was bootloaded with 1 MHz optiboot, which is used for 2 and 4 MHz internal on most parts), in which case it must be reset to divide by 8).\n    * You must point the stack pointer to the end of the flash (`SP = RAMEND - 1`).\n    * Failure to observe these precautions will likely result in the bootloader failing to function properly, and possibly leave you in a state where a physical reset button press is required!\n    * Whatever you do, don't try to bring this trick with you onto a modern AVR - there's no reason to do that over there (they finally have a software reset function) and the unintended dirty resets can be far more dangerous than they are here (a necessary tradeoff to get some very nice interrupt-related features). On my modern AVR cores (megaTinyCore and DxCore) I actually detect that a dirty reset has happened at the very early stages of the boot process, and fire software reset automatically.\n    * Seriously, don't do this unless you really have your back to the wall and there's just no other way.\n\n\n\n## License\nATTinyCore itself is released under the [LGPL 2.1](LICENSE.md). It may be used, modified, and distributed, and it may be used as part of an application which, itself, is not open source (though any modifications to these libraries must be released under the LGPL as well). Unlike LGPLv3, if this is used in a commercial product, you are not required to provide means for user to update it. A historical investigation has determined that versions of this core have been released under the LGPLv2.1 in the past - it was an oversight on our part that the license file was omitted from this core previously.\n\nThe ATTinyCore hardware package (and by extension this repository) contains ATTinyCore as well as libraries and bootloaders. These are released under the same license, *unless specified otherwise*. For example, tinyNeoPixel and tinyNeoPixel_Static, being based on Adafruit's library, is released under GPLv3, as described in the LICENSE.md in those subfolders and within the body of the library files themselves.\n\nTools and third party programs used by ATTinyCore are governed by their own licenses; this includes tools installed by board manager, such as AVRdude and avr-gcc.\n\n## Acknowledgements\n\nThis core was originally based on TCWorld's ATTinyCore, which is in turn based on the arduino-tiny core here: [http://code.google.com/p/arduino-tiny/](http://code.google.com/p/arduino-tiny/)\nThe ATtiny841 support is based on shimniok's ATtiny x41 core, and the 1634 support on Rambo's ATtiny1634 core.\n\n@per1234, who has been an invaluable resource for myself and others within the Arduino community, specifically having set up the Travis-based CI testing system (which will cease to be used once the other foot drops wrt. Travis terms) and his years of assistance with board manager releases and more.\n\nThe pinout diagrams are created by @MCUdude, who maintains a number of excellent cores for virtually every Microcontroller you might want to use with Arduino as as it has \"ATmega\" in the name - You can find them at [http://github.com/MCUdude](http://github.com/MCUdude)\n\nMany individuals have contributed various fixes and improvements via GitHub - see the [contributor list](https://github.com/SpenceKonde/ATTinyCore/graphs/contributors) for the full list.\n"
        },
        {
          "name": "Readme additions.txt",
          "type": "blob",
          "size": 7.3427734375,
          "content": "| Part Family     |   x4-series |  x41-series |   x5-series | ATtiny26 |    x61-series |  x7-series | x8-series | x313-series | ATtiny1634 | ATtiny828 | ATtiny43 |\n|-----------------|-------------|-------------|-------------|----------|---------------|------------|-----------|-------------|------------|-----------|----------|\n| Flash Size      |    2k/4k/8k |       4k/8k |    2k/4k/8k |     2048 |      2k/4k/8k |     8k/16k |     4k/8k |       2k/4k |      16384 |      8192 |     4096 |\n| EEPROM Size     | 128/256/512 |     256/512 | 128/256/512 |      128 |   128/256/512 |        512 |           |             |        256 |       512 |       64 |\n| RAM size        | 128/256/512 |     256/512 | 128/256/512 |      128 |   128/256/512 |        512 |           |             |       1024 |       512 |      256 |\n| Internal 16 MHz |          No |  via tuning |    Yes, PLL | Yes, PLL |      Yes, PLL |         No |        No |          No |         No |        No |       No |\n| Ext. Crystal    |         Yes |         Yes |         Yes |      Yes |           Yes |        Yes |        No |         Yes |        Yes |        No |       No |\n| Clock Switching |          No |         Yes |          No |       No |            No | yes, buggy |        No |          No |        Yes |       Yes |       No |\n| HV programming  |        HVSP |        HVSP |        HVSP | parallel |      parallel |   parallel |  parallel |    parallel |   parallel |  parallel | parallel |\n| I/O pins        |          12 |          12 |           6 |       16 |            16 |         16 |        28 |          18 |         18 |        28 |       16 |\n| Optiboot        |         Yes |         Yes |         Yes |       No |           Yes |        Yes |       Yes |          No |        Yes |       Yes |       No |\n| Micronucleus    |         Yes |         Yes |         Yes |       No |           Yes |        Yes |       Yes |          No |        Yes |        No |       No |\n| AREF Pin        |         Yes |         Yes |         Yes |          |           Yes |        Yes |        No |          No |        Yes |        No |       No |\n| PWM pins        |           4 |       6 (8) |           3 |        2 |             3 |       3(9) |         2 |           4 |          4 |     4 (8) |        4 |\n| Internal Refs   | 1V1         | 1V1,2V2,4V1 |   1V1, 2V56 |     2V56 |   1V1, 2V56   |   1V1,2V56 |       1V1 |         1V1 |        1V1 |       1V1 |      1V1 |\n| Analog Pins     |           8 |          12 |           4 |       11 |            11 |         11 |    6 or 8 |        none |         12 |        28 |        4 |\n| Diff. ADC pairs |          12 |  \"46\"* (18) |           2 |        8 |     \"16\" (10) |          8 |      none |        none |       none |      none |     none |\n| Diff. ADC gain  |     1x, 20x | 1x,20x,100x |     1x, 20x |  1x, 20x | 1, 8, 20, 32x |    8x, 20x |      none |        none |       none |      none |     none |\n\n`* Number in quotes is from the Atmel marketing material which are inconsistent with the counting methods used for other parts and the most basic of mathematcal concepts. Ex: on x41, for differential pairs, they counted every pair of pins twice (since you can reverse them) plus the 10 channels where the same input is used as both positive and negative, for offset calibration and that added up to 46. But historically, they only counted unique pairs, and didn't count channels that would read 0 except for offset error. That gets 18 pairs. Hence: \"46\" (18)`\n\nI/O pins *includes* reset in the count; reset can only be used as GPIO if you disable reset (in which case you need to have an HV programmer to reprogram the part).\n\nPWM pins where second number is shown in (parenthesis), the first number is the number of simultaneous, independent duty cycles that can be generated, and the one in parenethesis is the number of pins on which those can be output. See the part specific documentation for details, as the implementation and core integration (if any) varies.\n\nClock source switching is NEVER supported by ATTinyCore. The x7-series is impacted by scary errata with a very specific workaround.\n\n\n\nReadme additions\n* Document DIFF_Ax_Ay_gX defines\n* Document ADC_GROUND, ADC_INTERNAL, etc\nTo read from an analog pin, pass either the An constant, OR the digital pin number. As of 2.0.0, we have dropped support for an unadulterated analog channel number; analog channel numbers are distinguished by\nIn addition to the analog pins, we now have proper support for reading from differential ADC channels, and whatever other channels the chip supports; these vary between parts - refer to the part-specific documentation for the chip you are working with for the list of names. Differential channels are named as DIFF_Ap_An_gX where p is the positive channel, n is the negative one, and g is the gain. The options vary wildly between parts - the ATtiny85 has 12 options while the ATtiny861 has 81 combinations of gain and pins (though 10 are duplicates). There is an exception to this convention for the ATtiny441/841 (there are too many options) with 46 differential pairs each with 3 gain options and 16 single-ended channels. See the part-specific documentation for details.\n\n* Document existence of enhanced compile time error checking.\nAs I have learned new techniques, it is now possible for me to generate compile errors when functions are called in contexts where they cannot produce meaningful or coherent results, or where constant arguments are passed to them which will not give valid results. Now, instead of compiling and faiiling to work as intended (since errors can't be reported at runtime unless your code checks for them), these will now produce errors at compile time with a description of the problem so that it can be corrected. Two types of errors are shown, badArg() and badCall() - the former indicates that one of the arguments you are passing to it is both compile-time known and guaranteed not to produce meaningful results, while the latter indicates that the API function being called is inappropriate considering the part and options selected. Previously, these would generally result in an error that the function wasn't defined; if its defined for other parts, just not this one that doesn't have the support for that feature, now we tell you that.\n\nFor example:\n* digitalWrite(10,HIGH) on an ATtiny85 - it only has 6 I/O pins at most. You're probably adapting code for another part and missed a digitalWrite() - before this would compile, but the offending digitalWrite would have no effect.\n* analogRead(1) on an ATtiny4313, which has no ADC. This is now a compile error, previously it would.... attempt to look up the digital pin for that analog channel (and of course get NOT_A_PIN), digitalRead() the not-pin, and return 0 because it got a LOW back because we also didn't detect runtime bad pins carefully there either.\n\nThis doesn't stop you from using invalid values determined at runtime though Things like this will still compile - but this will catch a lot of mistakes while compiling, when we can show errors, instead of at runtime, when we can't.\n```\nfor (byte i = 4;i < x; i++) {\n  digitalWrite(i,HIGH)\n}\n// where x may exceed the number of pins\n```\n\n\n* Document ADC_NO_CHECK_STATUS option flash saver\n\n\n\n### Reading Temperature and Vcc voltage\n\n**Voltage**\n\nSet reference to `DEFAULT` and read the voltage reference (`ADC_INTERNAL1V1` is generally the only option on most parts). The result will be (1.1 / Vcc) * 1023\n"
        },
        {
          "name": "V2.0.0PinoutChanges.txt",
          "type": "blob",
          "size": 2.2373046875,
          "content": "Pinout Diagram Changes:\n\n* All parts without a hardware serial port:\n  * Add note that indicates that the TX pin may be set with Serial.setTXPin() to pins on the same port.\n* Add diagram for the ATtiny26 (mostly the same as a x61, but with less features. Only the new pin mapping is supported there. It has no third PWM pin)\n* x61:\n  * Alternate serial port locations: RX PA5, PA6. TX PA6, PA7.\n  * Possibly distinguish the non-standard PCINts (PCINT 8-11 are controlled by PCIE1, but PCINT12-16 are back to PCIE0 (wtf), or add note to that effect).\n  * Add note that between all PCINTs, there's only one interrupt vector (double wtf)).\n  * Possibly the above two can simply be combined into a note indicating that PCINT behavior is slightly different on these parts and to refer to the part specific documentation.\n  * Add alternate pin locations for DI, DO, SCK (non-ISP programming only) and hence SCL and SDA: they can now be moved from PB0-PB2 to PA0-PA2.\n* x5, x4, x41, x61, x7, x8, 1634:\n  * Add USB pins. Where there are multiple pin mappings, only one associated with vUSB boards (x8, x7, 1634), these should should be de-emphacized if they are shown at all\n  * Add alternate USB pins for x41 and x4 - boards have been made with PB0 = D-, PB1 = D+, the opposite, and with PB0 = D- and PB2 = D+. All boards of which I am aware put the LED on the unused PORTB pin.\n* All parts: Add LED pin (note: this pin is often different for different pin mappings)\n* x4, x5, x41, 26, x61, x7:\n  * Indicate pins that can be used for differential ADC measurements.\n  * A +/- symbol might be a good marker, with a footnote indicating that users should refer to the part-specific documentation more information.\n* 1634: Add new pin mapping as the recommended pin mapping (clockwise) The CCW pin mapping is strictly worse and only for compatibility.\n* x7: Add pin mapping diagram for the new QFN-24 package (the old QFN32 is not going to be used by anyone now that there's a QFN24 version - it uses more board space and is harder to solder).\n* x41: Mark PA5, PA7 as having High Sink Capability. Add alternate pin for UART0 (RX PB2, TX, PA7), SPI (SS: PA2 MOSI: PA1 MISO: PA0, SCK PA3). The default pins must be marked as being used for programming.\n* 828: Mark PORTC as having High Sink Capability.\n*\n"
        },
        {
          "name": "avr",
          "type": "tree",
          "content": null
        },
        {
          "name": "avrdude.conf",
          "type": "blob",
          "size": 173.52734375,
          "content": "# $Id: avrdude.conf.in 1236 2013-09-16 19:40:15Z joerg_wunsch $ -*- text -*-\n#\n# AVRDUDE Configuration File\n#\n# This file contains configuration data used by AVRDUDE which describes\n# the programming hardware pinouts and also provides part definitions.\n# AVRDUDE's \"-C\" command line option specifies the location of the\n# configuration file.  The \"-c\" option names the programmer configuration\n# which must match one of the entry's \"id\" parameter.  The \"-p\" option\n# identifies which part AVRDUDE is going to be programming and must match\n# one of the parts' \"id\" parameter.\n#\n# Possible entry formats are:\n#\n#   programmer\n#       parent <id>                                 # optional parent\n#       id       = <id1> [, <id2> [, <id3>] ...] ;  # <idN> are quoted strings\n#       desc     = <description> ;                  # quoted string\n#       type     = <type>;                          # programmer type, quoted string\n#                          # supported programmer types can be listed by \"-c ?type\"\n#       connection_type = parallel | serial | usb\n#       baudrate = <num> ;                          # baudrate for avr910-programmer\n#       vcc      = <num1> [, <num2> ... ] ;         # pin number(s)\n#       buff     = <num1> [, <num2> ... ] ;         # pin number(s)\n#       reset    = <num> ;                          # pin number\n#       sck      = <num> ;                          # pin number\n#       mosi     = <num> ;                          # pin number\n#       miso     = <num> ;                          # pin number\n#       errled   = <num> ;                          # pin number\n#       rdyled   = <num> ;                          # pin number\n#       pgmled   = <num> ;                          # pin number\n#       vfyled   = <num> ;                          # pin number\n#       usbvid   = <hexnum>;                        # USB VID (Vendor ID)\n#       usbpid   = <hexnum>;                        # USB PID (Product ID)\n#       usbdev   = <interface>;                     # USB interface or other device info\n#       usbvendor = <vendorname>;                   # USB Vendor Name\n#       usbproduct = <productname>;                 # USB Product Name\n#       usbsn    = <serialno>;                      # USB Serial Number\n#\n#        To invert a bit, use = ~ <num>, the spaces are important.\n#        For a pin list all pins must be inverted.\n#        A single pin can be specified as usual = ~ <num>, for lists\n#        specify it as follows = ~ ( <num> [, <num2> ... ] ) .\n#     ;\n#\n#   part\n#       id               = <id> ;                 # quoted string\n#       desc             = <description> ;        # quoted string\n#       has_jtag         = <yes/no> ;             # part has JTAG i/f\n#       has_debugwire    = <yes/no> ;             # part has debugWire i/f\n#       has_pdi          = <yes/no> ;             # part has PDI i/f\n#       has_tpi          = <yes/no> ;             # part has TPI i/f\n#       devicecode       = <num> ;            # deprecated, use stk500_devcode\n#       stk500_devcode   = <num> ;                # numeric\n#       avr910_devcode   = <num> ;                # numeric\n#       signature        = <num> <num> <num> ;    # signature bytes\n#       chip_erase_delay = <num> ;                # micro-seconds\n#       reset            = dedicated | io;\n#       retry_pulse      = reset | sck;\n#       pgm_enable       = <instruction format> ;\n#       chip_erase       = <instruction format> ;\n#       chip_erase_delay = <num> ;                # chip erase delay (us)\n#       # STK500 parameters (parallel programming IO lines)\n#       pagel            = <num> ;                # pin name in hex, i.e., 0xD7\n#       bs2              = <num> ;                # pin name in hex, i.e., 0xA0\n#       serial           = <yes/no> ;             # can use serial downloading\n#       parallel         = <yes/no/pseudo>;       # can use par. programming\n#       # STK500v2 parameters, to be taken from Atmel's XML files\n#       timeout          = <num> ;\n#       stabdelay        = <num> ;\n#       cmdexedelay      = <num> ;\n#       synchloops       = <num> ;\n#       bytedelay        = <num> ;\n#       pollvalue        = <num> ;\n#       pollindex        = <num> ;\n#       predelay         = <num> ;\n#       postdelay        = <num> ;\n#       pollmethod       = <num> ;\n#       mode             = <num> ;\n#       delay            = <num> ;\n#       blocksize        = <num> ;\n#       readsize         = <num> ;\n#       hvspcmdexedelay  = <num> ;\n#       # STK500v2 HV programming parameters, from XML\n#       pp_controlstack  = <num>, <num>, ...;   # PP only\n#       hvsp_controlstack = <num>, <num>, ...;  # HVSP only\n#       hventerstabdelay = <num>;\n#       progmodedelay    = <num>;               # PP only\n#       latchcycles      = <num>;\n#       togglevtg        = <num>;\n#       poweroffdelay    = <num>;\n#       resetdelayms     = <num>;\n#       resetdelayus     = <num>;\n#       hvleavestabdelay = <num>;\n#       resetdelay       = <num>;\n#       synchcycles      = <num>;               # HVSP only\n#       chiperasepulsewidth = <num>;            # PP only\n#       chiperasepolltimeout = <num>;\n#       chiperasetime    = <num>;               # HVSP only\n#       programfusepulsewidth = <num>;          # PP only\n#       programfusepolltimeout = <num>;\n#       programlockpulsewidth = <num>;          # PP only\n#       programlockpolltimeout = <num>;\n#       # JTAG ICE mkII parameters, also from XML files\n#       allowfullpagebitstream = <yes/no> ;\n#       enablepageprogramming = <yes/no> ;\n#       idr              = <num> ;                # IO addr of IDR (OCD) reg.\n#       rampz            = <num> ;                # IO addr of RAMPZ reg.\n#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg.\n#       eecr             = <num> ;                # mem addr of EECR reg.\n#                                                 # (only when != 0x3c)\n#       is_at90s1200     = <yes/no> ;             # AT90S1200 part\n#       is_avr32         = <yes/no> ;             # AVR32 part\n#\n#       memory <memtype>\n#           paged           = <yes/no> ;          # yes / no\n#           size            = <num> ;             # bytes\n#           page_size       = <num> ;             # bytes\n#           num_pages       = <num> ;             # numeric\n#           min_write_delay = <num> ;             # micro-seconds\n#           max_write_delay = <num> ;             # micro-seconds\n#           readback_p1     = <num> ;             # byte value\n#           readback_p2     = <num> ;             # byte value\n#           pwroff_after_write = <yes/no> ;       # yes / no\n#           read            = <instruction format> ;\n#           write           = <instruction format> ;\n#           read_lo         = <instruction format> ;\n#           read_hi         = <instruction format> ;\n#           write_lo        = <instruction format> ;\n#           write_hi        = <instruction format> ;\n#           loadpage_lo     = <instruction format> ;\n#           loadpage_hi     = <instruction format> ;\n#           writepage       = <instruction format> ;\n#         ;\n#     ;\n#\n# If any of the above parameters are not specified, the default value\n# of 0 is used for numerics or the empty string (\"\") for string\n# values.  If a required parameter is left empty, AVRDUDE will\n# complain.\n#\n# Parts can also inherit parameters from previously defined parts\n# using the following syntax. In this case specified integer and\n# string values override parameter values from the parent part. New\n# memory definitions are added to the definitions inherited from the\n# parent.\n#\n#   part parent <id>                              # quoted string\n#       id               = <id> ;                 # quoted string\n#       <any set of other parameters from the list above>\n#     ;\n#\n# NOTES:\n#   * 'devicecode' is the device code used by the STK500 (see codes\n#       listed below)\n#   * Not all memory types will implement all instructions.\n#   * AVR Fuse bits and Lock bits are implemented as a type of memory.\n#   * Example memory types are:\n#       \"flash\", \"eeprom\", \"fuse\", \"lfuse\" (low fuse), \"hfuse\" (high\n#       fuse), \"signature\", \"calibration\", \"lock\"\n#   * The memory type specified on the avrdude command line must match\n#     one of the memory types defined for the specified chip.\n#   * The pwroff_after_write flag causes avrdude to attempt to\n#     power the device off and back on after an unsuccessful write to\n#     the affected memory area if VCC programmer pins are defined.  If\n#     VCC pins are not defined for the programmer, a message\n#     indicating that the device needs a power-cycle is printed out.\n#     This flag was added to work around a problem with the\n#     at90s4433/2333's; see the at90s4433 errata at:\n#\n#         http://www.atmel.com/dyn/resources/prod_documents/doc1280.pdf\n#\n# INSTRUCTION FORMATS\n#\n#    Instruction formats are specified as a comma separated list of\n#    string values containing information (bit specifiers) about each\n#    of the 32 bits of the instruction.  Bit specifiers may be one of\n#    the following formats:\n#\n#       '1'  = the bit is always set on input as well as output\n#\n#       '0'  = the bit is always clear on input as well as output\n#\n#       'x'  = the bit is ignored on input and output\n#\n#       'a'  = the bit is an address bit, the bit-number matches this bit\n#              specifier's position within the current instruction byte\n#\n#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12\n#              is address bit 12 on input, a0 is address bit 0.\n#\n#       'i'  = the bit is an input data bit\n#\n#       'o'  = the bit is an output data bit\n#\n#    Each instruction must be composed of 32 bit specifiers.  The\n#    instruction specification closely follows the instruction data\n#    provided in Atmel's data sheets for their parts.\n#\n# See below for some examples.\n#\n#\n# The following are STK500 part device codes to use for the\n# \"devicecode\" field of the part.  These came from Atmel's software\n# section avr061.zip which accompanies the application note\n# AVR061 available from:\n#\n#      http://www.atmel.com/dyn/resources/prod_documents/doc2525.pdf\n#\n\n#define ATTINY10    0x10  /* the _old_ one that never existed! */\n#define ATTINY11    0x11\n#define ATTINY12    0x12\n#define ATTINY15    0x13\n#define ATTINY13    0x14\n\n#define ATTINY22    0x20\n#define ATTINY26    0x21\n#define ATTINY28    0x22\n#define ATTINY2313  0x23\n\n#define AT90S1200   0x33\n\n#define AT90S2313   0x40\n#define AT90S2323   0x41\n#define AT90S2333   0x42\n#define AT90S2343   0x43\n\n#define AT90S4414   0x50\n#define AT90S4433   0x51\n#define AT90S4434   0x52\n#define ATMEGA48    0x59\n\n#define AT90S8515   0x60\n#define AT90S8535   0x61\n#define AT90C8534   0x62\n#define ATMEGA8515  0x63\n#define ATMEGA8535  0x64\n\n#define ATMEGA8     0x70\n#define ATMEGA88    0x73\n#define ATMEGA168   0x86\n\n#define ATMEGA161   0x80\n#define ATMEGA163   0x81\n#define ATMEGA16    0x82\n#define ATMEGA162   0x83\n#define ATMEGA169   0x84\n\n#define ATMEGA323   0x90\n#define ATMEGA32    0x91\n\n#define ATMEGA64    0xA0\n\n#define ATMEGA103   0xB1\n#define ATMEGA128   0xB2\n#define AT90CAN128  0xB3\n#define AT90CAN64   0xB3\n#define AT90CAN32   0xB3\n\n#define AT86RF401   0xD0\n\n#define AT89START   0xE0\n#define AT89S51     0xE0\n#define AT89S52     0xE1\n\n# The following table lists the devices in the original AVR910\n# appnote:\n# |Device |Signature | Code |\n# +-------+----------+------+\n# |tiny12 | 1E 90 05 | 0x55 |\n# |tiny15 | 1E 90 06 | 0x56 |\n# |       |          |      |\n# | S1200 | 1E 90 01 | 0x13 |\n# |       |          |      |\n# | S2313 | 1E 91 01 | 0x20 |\n# | S2323 | 1E 91 02 | 0x48 |\n# | S2333 | 1E 91 05 | 0x34 |\n# | S2343 | 1E 91 03 | 0x4C |\n# |       |          |      |\n# | S4414 | 1E 92 01 | 0x28 |\n# | S4433 | 1E 92 03 | 0x30 |\n# | S4434 | 1E 92 02 | 0x6C |\n# |       |          |      |\n# | S8515 | 1E 93 01 | 0x38 |\n# | S8535 | 1E 93 03 | 0x68 |\n# |       |          |      |\n# |mega32 | 1E 95 01 | 0x72 |\n# |mega83 | 1E 93 05 | 0x65 |\n# |mega103| 1E 97 01 | 0x41 |\n# |mega161| 1E 94 01 | 0x60 |\n# |mega163| 1E 94 02 | 0x64 |\n\n# Appnote AVR109 also has a table of AVR910 device codes, which\n# lists:\n# dev         avr910   signature\n# ATmega8     0x77     0x1E 0x93 0x07\n# ATmega8515  0x3B     0x1E 0x93 0x06\n# ATmega8535  0x6A     0x1E 0x93 0x08\n# ATmega16    0x75     0x1E 0x94 0x03\n# ATmega162   0x63     0x1E 0x94 0x04\n# ATmega163   0x66     0x1E 0x94 0x02\n# ATmega169   0x79     0x1E 0x94 0x05\n# ATmega32    0x7F     0x1E 0x95 0x02\n# ATmega323   0x73     0x1E 0x95 0x01\n# ATmega64    0x46     0x1E 0x96 0x02\n# ATmega128   0x44     0x1E 0x97 0x02\n#\n# These codes refer to \"BOOT\" device codes which are apparently\n# different than standard device codes, for whatever reasons\n# (often one above the standard code).\n\n# There are several extended versions of AVR910 implementations around\n# in the Internet.  These add the following codes (only devices that\n# actually exist are listed):\n\n# ATmega8515  0x3A\n# ATmega128 0x43\n# ATmega64  0x45\n# ATtiny26  0x5E\n# ATmega8535  0x69\n# ATmega32  0x72\n# ATmega16  0x74\n# ATmega8 0x76\n# ATmega169 0x78\n\n#\n# Overall avrdude defaults; suitable for ~/.avrduderc\n#\ndefault_parallel   = \"lpt1\";\ndefault_serial     = \"com1\";\ndefault_bitclock = 5;\n\n# Turn off safemode by default\n#default_safemode  = no;\n\n\n#\n# PROGRAMMER DEFINITIONS\n#\n\n# http://wiring.org.co/\n# Basically STK500v2 protocol, with some glue to trigger the\n# bootloader.\nprogrammer\n  id    = \"wiring\";\n  desc  = \"Wiring\";\n  type  = \"wiring\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"arduino\";\n  desc  = \"Arduino\";\n  type  = \"arduino\";\n  connection_type = serial;\n;\n# this will interface with the chips on these programmers:\n#\n# http://real.kiev.ua/old/avreal/en/adapters\n# http://www.amontec.com/jtagkey.shtml, jtagkey-tiny.shtml\n# http://www.olimex.com/dev/arm-usb-ocd.html, arm-usb-tiny.html\n# http://www.ethernut.de/en/hardware/turtelizer/index.html\n# http://elk.informatik.fh-augsburg.de/hhweb/doc/openocd/usbjtag/usbjtag.html\n# http://dangerousprototypes.com/docs/FT2232_breakout_board\n# http://www.ftdichip.com/Products/Modules/DLPModules.htm,DLP-2232*,DLP-USB1232H\n# http://flashrom.org/FT2232SPI_Programmer\n#\n# The drivers will look for a specific device and use the first one found.\n# If you have multiple devices, then look for unique information (like SN)\n# And fill that in here.\n#\n# Note that the pin numbers for the main ISP signals (reset, sck,\n# mosi, miso) are fixed and cannot be changed, since they must match\n# the way the Multi-Protocol Synchronous Serial Engine (MPSSE) of\n# these FTDI ICs has been designed.\n\nprogrammer\n  id         = \"avrftdi\";\n  desc       = \"FT2232D based generic programmer\";\n  type       = \"avrftdi\";\n  connection_type = usb;\n  usbvid     = 0x0403;\n  usbpid     = 0x6010;\n  usbvendor  = \"\";\n  usbproduct = \"\";\n  usbdev     = \"A\";\n  usbsn      = \"\";\n#ISP-signals - lower ADBUS-Nibble (default)\n  reset  = 3;\n  sck    = 0;\n  mosi   = 1;\n  miso   = 2;\n#LED SIGNALs - higher ADBUS-Nibble\n#  errled = 4;\n#  rdyled = 5;\n#  pgmled = 6;\n#  vfyled = 7;\n#Buffer Signal - ACBUS - Nibble\n#  buff   = 8;\n;\n# This is an implementation of the above with a buffer IC (74AC244) and\n# 4 LEDs directly attached, all active low.\nprogrammer\n  id         = \"2232HIO\";\n  desc       = \"FT2232H based generic programmer\";\n  type       = \"avrftdi\";\n  connection_type = usb;\n  usbvid     = 0x0403;\n# Note: This PID is reserved for generic H devices and\n# should be programmed into the EEPROM\n#  usbpid     = 0x8A48;\n  usbpid     = 0x6010;\n  usbdev     = \"A\";\n  usbvendor  = \"\";\n  usbproduct = \"\";\n  usbsn      = \"\";\n#ISP-signals\n  reset  = 3;\n  sck    = 0;\n  mosi   = 1;\n  miso   = 2;\n  buff   = ~4;\n#LED SIGNALs\n  errled = ~ 11;\n  rdyled = ~ 14;\n  pgmled = ~ 13;\n  vfyled = ~ 12;\n;\n\n#The FT4232H can be treated as FT2232H, but it has a different USB\n#device ID of 0x6011.\nprogrammer parent \"avrftdi\"\n  id         = \"4232h\";\n  desc       = \"FT4232H based generic programmer\";\n  usbpid     = 0x6011;\n;\n\nprogrammer\n  id         = \"jtagkey\";\n  desc       = \"Amontec JTAGKey, JTAGKey-Tiny and JTAGKey2\";\n  type       = \"avrftdi\";\n  connection_type = usb;\n  usbvid     = 0x0403;\n# Note: This PID is used in all JTAGKey variants\n  usbpid     = 0xCFF8;\n  usbdev     = \"A\";\n  usbvendor  = \"\";\n  usbproduct = \"\";\n  usbsn      = \"\";\n#ISP-signals => 20 - Pin connector on JTAGKey\n  reset  = 3; # TMS 7 violet\n  sck    = 0; # TCK 9 white\n  mosi   = 1; # TDI 5 green\n  miso   = 2; # TDO 13 orange\n  buff   = ~4;\n# VTG           VREF 1 brown with red tip\n# GND           GND 20 black\n# The colors are on the 20 pin breakout cable\n# from Amontec\n;\n\n# On the adapter you can read \"O-Link\". On the PCB is printed \"OpenJTAG v3.1\"\n# You can find it as \"OpenJTAG ARM JTAG USB\" in the internet.\n# (But there are also several projects called Open JTAG, eg.\n# http://www.openjtag.org, which are completely different.)\n#   http://www.100ask.net/shop/english.html (website seems to be outdated)\n#   http://item.taobao.com/item.htm?id=1559277013\n#   http://www.micro4you.com/store/openjtag-arm-jtag-usb.html (schematics!)\n# some other sources which call it O-Link\n#   http://www.andahammer.com/olink/\n#   http://www.developmentboard.net/31-o-link-debugger.html\n#   http://armwerks.com/catalog/o-link-debugger-copy/\n# or just have a look at ebay ...\n# It is basically the same entry as jtagkey with different usb ids.\nprogrammer parent \"jtagkey\"\n  id         = \"o-link\";\n  desc       = \"O-Link, OpenJTAG from www.100ask.net\";\n  usbvid     = 0x1457;\n  usbpid     = 0x5118;\n  usbvendor  = \"www.100ask.net\";\n  usbproduct = \"USB<=>JTAG&RS232\";\n;\n\n# http://wiki.openmoko.org/wiki/Debug_Board_v3\nprogrammer\n  id    = \"openmoko\";\n  desc  = \"Openmoko debug board (v3)\";\n  type  = \"avrftdi\";\n  usbvid     = 0x1457;\n  usbpid    = 0x5118;\n  usbdev = \"A\";\n  usbvendor  = \"\";\n  usbproduct = \"\";\n  usbsn      = \"\";\n  reset  = 3; # TMS 7\n  sck    = 0; # TCK 9\n  mosi   = 1; # TDI 5\n  miso   = 2; # TDO 13\n;\n\n# Only Rev. A boards.\n# Schematic and user manual: http://www.cs.put.poznan.pl/wswitala/download/pdf/811EVBK.pdf\nprogrammer\n  id         = \"lm3s811\";\n  desc       = \"Luminary Micro LM3S811 Eval Board (Rev. A)\";\n  type       = \"avrftdi\";\n  connection_type = usb;\n  usbvid     = 0x0403;\n  usbpid     = 0xbcd9;\n  usbvendor  = \"LMI\";\n  usbproduct = \"LM3S811 Evaluation Board\";\n  usbdev     = \"A\";\n  usbsn      = \"\";\n#ISP-signals - lower ACBUS-Nibble (default)\n  reset  = 3;\n  sck    = 0;\n  mosi   = 1;\n  miso   = 2;\n# Enable correct buffers\n  buff   = 7;\n;\n\nprogrammer\n  id    = \"avrisp\";\n  desc  = \"Atmel AVR ISP\";\n  type  = \"stk500\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"avrispv2\";\n  desc  = \"Atmel AVR ISP V2\";\n  type  =  \"stk500v2\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"avrispmkII\";\n  desc  = \"Atmel AVR ISP mkII\";\n  type  =  \"stk500v2\";\n  connection_type = usb;\n;\n\nprogrammer parent \"avrispmkII\"\n  id    = \"avrisp2\";\n;\n\nprogrammer\n  id    = \"buspirate\";\n  desc  = \"The Bus Pirate\";\n  type  = \"buspirate\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"buspirate_bb\";\n  desc  = \"The Bus Pirate (bitbang interface, supports TPI)\";\n  type  = \"buspirate_bb\";\n  connection_type = serial;\n  # pins are bits in bitbang byte (numbers are 87654321)\n  # 1|POWER|PULLUP|AUX|MOSI|CLK|MISO|CS\n  reset  = 1;\n  sck    = 3;\n  mosi   = 4;\n  miso   = 2;\n  #vcc    = 7; This is internally set independent of this setting.\n;\n\n# This is supposed to be the \"default\" STK500 entry.\n# Attempts to select the correct firmware version\n# by probing for it.  Better use one of the entries\n# below instead.\nprogrammer\n  id    = \"stk500\";\n  desc  = \"Atmel STK500\";\n  type  = \"stk500generic\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"stk500v1\";\n  desc  = \"Atmel STK500 Version 1.x firmware\";\n  type  = \"stk500\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"mib510\";\n  desc  = \"Crossbow MIB510 programming board\";\n  type  = \"stk500\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"stk500v2\";\n  desc  = \"Atmel STK500 Version 2.x firmware\";\n  type  = \"stk500v2\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"stk500pp\";\n  desc  = \"Atmel STK500 V2 in parallel programming mode\";\n  type  = \"stk500pp\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"stk500hvsp\";\n  desc  = \"Atmel STK500 V2 in high-voltage serial programming mode\";\n  type  = \"stk500hvsp\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"stk600\";\n  desc  = \"Atmel STK600\";\n  type  = \"stk600\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"stk600pp\";\n  desc  = \"Atmel STK600 in parallel programming mode\";\n  type  = \"stk600pp\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"stk600hvsp\";\n  desc  = \"Atmel STK600 in high-voltage serial programming mode\";\n  type  = \"stk600hvsp\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"avr910\";\n  desc  = \"Atmel Low Cost Serial Programmer\";\n  type  = \"avr910\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"ft245r\";\n  desc  = \"FT245R Synchronous BitBang\";\n  type  = \"ftdi_syncbb\";\n  connection_type = usb;\n  miso  = 1; # D1\n  sck   = 0; # D0\n  mosi  = 2; # D2\n  reset = 4; # D4\n;\n\nprogrammer\n  id    = \"ft232r\";\n  desc  = \"FT232R Synchronous BitBang\";\n  type  = \"ftdi_syncbb\";\n  connection_type = usb;\n  miso  = 1;  # RxD\n  sck   = 0;  # RTS\n  mosi  = 2;  # TxD\n  reset = 4;  # DTR\n;\n\n# see http://www.bitwizard.nl/wiki/index.php/FTDI_ATmega\nprogrammer\n  id    = \"bwmega\";\n  desc  = \"BitWizard ftdi_atmega builtin programmer\";\n  type  = \"ftdi_syncbb\";\n  connection_type = usb;\n  miso  = 5;  # DSR\n  sck   = 6;  # DCD\n  mosi  = 3;  # CTS\n  reset = 7;  # RI\n;\n\n# see http://www.geocities.jp/arduino_diecimila/bootloader/index_en.html\n# Note: pins are numbered from 1!\nprogrammer\n  id    = \"arduino-ft232r\";\n  desc  = \"Arduino: FT232R connected to ISP\";\n  type  = \"ftdi_syncbb\";\n  connection_type = usb;\n  miso  = 3;  # CTS X3(1)\n  sck   = 5;  # DSR X3(2)\n  mosi  = 6;  # DCD X3(3)\n  reset = 7;  # RI  X3(4)\n;\n\n# website mentioned above uses this id\nprogrammer parent \"arduino-ft232r\"\n  id    = \"diecimila\";\n  desc  = \"alias for arduino-ft232r\";\n;\n\nprogrammer\n  id    = \"usbasp\";\n  desc  = \"USBasp, http://www.fischl.de/usbasp/\";\n  type  = \"usbasp\";\n  connection_type = usb;\n  usbvid     = 0x16C0; # VOTI\n  usbpid     = 0x05DC; # Obdev's free shared PID\n  usbvendor  = \"www.fischl.de\";\n  usbproduct = \"USBasp\";\n\n  # following variants are autodetected for id \"usbasp\"\n\n  # original usbasp from fischl.de\n  # see above \"usbasp\"\n\n  # old usbasp from fischl.de\n  #usbvid     = 0x03EB; # ATMEL\n  #usbpid     = 0xC7B4; # (unofficial) USBasp\n  #usbvendor  = \"www.fischl.de\";\n  #usbproduct = \"USBasp\";\n\n  # NIBObee (only if -P nibobee is given on command line)\n  # see below \"nibobee\"\n;\n\nprogrammer\n  id    = \"nibobee\";\n  desc  = \"NIBObee\";\n  type  = \"usbasp\";\n  connection_type = usb;\n  usbvid     = 0x16C0; # VOTI\n  usbpid     = 0x092F; # NIBObee PID\n  usbvendor  = \"www.nicai-systems.com\";\n  usbproduct = \"NIBObee\";\n;\n\nprogrammer\n  id    = \"usbasp-clone\";\n  desc  = \"Any usbasp clone with correct VID/PID\";\n  type  = \"usbasp\";\n  connection_type = usb;\n  usbvid    = 0x16C0; # VOTI\n  usbpid    = 0x05DC; # Obdev's free shared PID\n  #usbvendor  = \"\";\n  #usbproduct = \"\";\n;\n\nprogrammer\n  id    = \"usbtiny\";\n  desc  = \"USBtiny simple USB programmer, http://www.ladyada.net/make/usbtinyisp/\";\n  type  = \"usbtiny\";\n  connection_type = usb;\n  usbvid     = 0x1781;\n  usbpid     = 0x0c9f;\n;\n\nprogrammer\n  id    = \"arduinoisp\";\n  desc  = \" \";\n  type  = \"usbtiny\";\n  connection_type = usb;\n  usbvid     = 0x2341;\n  usbpid     = 0x0049;\n;\n\nprogrammer\n  id    = \"butterfly\";\n  desc  = \"Atmel Butterfly Development Board\";\n  type  = \"butterfly\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"avr109\";\n  desc  = \"Atmel AppNote AVR109 Boot Loader\";\n  type  = \"butterfly\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"avr911\";\n  desc  = \"Atmel AppNote AVR911 AVROSP\";\n  type  = \"butterfly\";\n  connection_type = serial;\n;\n\n# suggested in http://forum.mikrokopter.de/topic-post48317.html\nprogrammer\n  id    = \"mkbutterfly\";\n  desc  = \"Mikrokopter.de Butterfly\";\n  type  = \"butterfly_mk\";\n  connection_type = serial;\n;\n\nprogrammer parent \"mkbutterfly\"\n  id    = \"butterfly_mk\";\n;\n\nprogrammer\n  id    = \"jtagmkI\";\n  desc  = \"Atmel JTAG ICE (mkI)\";\n  baudrate = 115200;    # default is 115200\n  type  = \"jtagmki\";\n  connection_type = serial;\n;\n\n# easier to type\nprogrammer parent \"jtagmkI\"\n  id    = \"jtag1\";\n;\n\n# easier to type\nprogrammer parent \"jtag1\"\n  id    = \"jtag1slow\";\n  baudrate = 19200;\n;\n\n# The JTAG ICE mkII has both, serial and USB connectivity.  As it is\n# mostly used through USB these days (AVR Studio 5 only supporting it\n# that way), we make connection_type = usb the default.  Users are\n# still free to use a serial port with the -P option.\n\nprogrammer\n  id    = \"jtagmkII\";\n  desc  = \"Atmel JTAG ICE mkII\";\n  baudrate = 19200;    # default is 19200\n  type  = \"jtagmkii\";\n  connection_type = usb;\n;\n\n# easier to type\nprogrammer parent \"jtagmkII\"\n  id    = \"jtag2slow\";\n;\n\n# JTAG ICE mkII @ 115200 Bd\nprogrammer parent \"jtag2slow\"\n  id    = \"jtag2fast\";\n  baudrate = 115200;\n;\n\n# make the fast one the default, people will love that\nprogrammer parent \"jtag2fast\"\n  id    = \"jtag2\";\n;\n\n# JTAG ICE mkII in ISP mode\nprogrammer\n  id    = \"jtag2isp\";\n  desc  = \"Atmel JTAG ICE mkII in ISP mode\";\n  baudrate = 115200;\n  type  = \"jtagmkii_isp\";\n  connection_type = usb;\n;\n\n# JTAG ICE mkII in debugWire mode\nprogrammer\n  id    = \"jtag2dw\";\n  desc  = \"Atmel JTAG ICE mkII in debugWire mode\";\n  baudrate = 115200;\n  type  = \"jtagmkii_dw\";\n  connection_type = usb;\n;\n\n# JTAG ICE mkII in AVR32 mode\nprogrammer\n  id    = \"jtagmkII_avr32\";\n  desc  = \"Atmel JTAG ICE mkII im AVR32 mode\";\n  baudrate = 115200;\n  type  = \"jtagmkii_avr32\";\n  connection_type = usb;\n;\n\n# JTAG ICE mkII in AVR32 mode\nprogrammer\n  id    = \"jtag2avr32\";\n  desc  = \"Atmel JTAG ICE mkII im AVR32 mode\";\n  baudrate = 115200;\n  type  = \"jtagmkii_avr32\";\n  connection_type = usb;\n;\n\n# JTAG ICE mkII in PDI mode\nprogrammer\n  id    = \"jtag2pdi\";\n  desc  = \"Atmel JTAG ICE mkII PDI mode\";\n  baudrate = 115200;\n  type  = \"jtagmkii_pdi\";\n  connection_type = usb;\n;\n\n# AVR Dragon in JTAG mode\nprogrammer\n  id    = \"dragon_jtag\";\n  desc  = \"Atmel AVR Dragon in JTAG mode\";\n  baudrate = 115200;\n  type  = \"dragon_jtag\";\n  connection_type = usb;\n;\n\n# AVR Dragon in ISP mode\nprogrammer\n  id    = \"dragon_isp\";\n  desc  = \"Atmel AVR Dragon in ISP mode\";\n  baudrate = 115200;\n  type  = \"dragon_isp\";\n  connection_type = usb;\n;\n\n# AVR Dragon in PP mode\nprogrammer\n  id    = \"dragon_pp\";\n  desc  = \"Atmel AVR Dragon in PP mode\";\n  baudrate = 115200;\n  type  = \"dragon_pp\";\n  connection_type = usb;\n;\n\n# AVR Dragon in HVSP mode\nprogrammer\n  id    = \"dragon_hvsp\";\n  desc  = \"Atmel AVR Dragon in HVSP mode\";\n  baudrate = 115200;\n  type  = \"dragon_hvsp\";\n  connection_type = usb;\n;\n\n# AVR Dragon in debugWire mode\nprogrammer\n  id    = \"dragon_dw\";\n  desc  = \"Atmel AVR Dragon in debugWire mode\";\n  baudrate = 115200;\n  type  = \"dragon_dw\";\n  connection_type = usb;\n;\n\n# AVR Dragon in PDI mode\nprogrammer\n  id    = \"dragon_pdi\";\n  desc  = \"Atmel AVR Dragon in PDI mode\";\n  baudrate = 115200;\n  type  = \"dragon_pdi\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"jtag3\";\n  desc  = \"Atmel AVR JTAGICE3 in JTAG mode\";\n  type  = \"jtagice3\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"jtag3pdi\";\n  desc  = \"Atmel AVR JTAGICE3 in PDI mode\";\n  type  = \"jtagice3_pdi\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"jtag3dw\";\n  desc  = \"Atmel AVR JTAGICE3 in debugWIRE mode\";\n  type  = \"jtagice3_dw\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"jtag3isp\";\n  desc  = \"Atmel AVR JTAGICE3 in ISP mode\";\n  type  = \"jtagice3_isp\";\n  connection_type = usb;\n;\n\nprogrammer\n  id    = \"atmelice\";\n  desc  = \"Atmel-ICE (ARM/AVR) in JTAG mode\";\n  type  = \"jtagice3\";\n  connection_type = usb;\n  usbpid = 0x2141;\n;\n\nprogrammer\n  id    = \"atmelice_pdi\";\n  desc  = \"Atmel-ICE (ARM/AVR) in PDI mode\";\n  type  = \"jtagice3_pdi\";\n  connection_type = usb;\n  usbpid = 0x2141;\n;\n\n\nprogrammer\n  id    = \"atmelice_dw\";\n  desc  = \"Atmel-ICE (ARM/AVR) in debugWIRE mode\";\n  type  = \"jtagice3_dw\";\n  connection_type = usb;\n  usbpid = 0x2141;\n;\n\nprogrammer\n  id    = \"atmelice_isp\";\n  desc  = \"Atmel-ICE (ARM/AVR) in ISP mode\";\n  type  = \"jtagice3_isp\";\n  connection_type = usb;\n  usbpid = 0x2141;\n;\n\nprogrammer\n  id    = \"pavr\";\n  desc  = \"Jason Kyle's pAVR Serial Programmer\";\n  type  = \"avr910\";\n  connection_type = serial;\n;\n\nprogrammer\n  id    = \"pickit2\";\n  desc  = \"MicroChip's PICkit2 Programmer\";\n  type  = \"pickit2\";\n  connection_type = usb;\n;\n\n# Parallel port programmers.\n\nprogrammer\n  id    = \"bsd\";\n  desc  = \"Brian Dean's Programmer, http://www.bsdhome.com/avrdude/\";\n  type  = \"par\";\n  connection_type = parallel;\n  vcc   = 2, 3, 4, 5;\n  reset = 7;\n  sck   = 8;\n  mosi  = 9;\n  miso  = 10;\n;\n\nprogrammer\n  id    = \"stk200\";\n  desc  = \"STK200\";\n  type  = \"par\";\n  connection_type = parallel;\n  buff  = 4, 5;\n  sck   = 6;\n  mosi  = 7;\n  reset = 9;\n  miso  = 10;\n;\n\n# The programming dongle used by the popular Ponyprog\n# utility.  It is almost similar to the STK200 one,\n# except that there is a LED indicating that the\n# programming is currently in progress.\n\nprogrammer parent \"stk200\"\n  id    = \"pony-stk200\";\n  desc  = \"Pony Prog STK200\";\n  pgmled = 8;\n;\n\nprogrammer\n  id    = \"dt006\";\n  desc  = \"Dontronics DT006\";\n  type  = \"par\";\n  connection_type = parallel;\n  reset = 4;\n  sck   = 5;\n  mosi  = 2;\n  miso  = 11;\n;\n\nprogrammer parent \"dt006\"\n  id    = \"bascom\";\n  desc  = \"Bascom SAMPLE programming cable\";\n;\n\nprogrammer\n  id     = \"alf\";\n  desc   = \"Nightshade ALF-PgmAVR, http://nightshade.homeip.net/\";\n  type   = \"par\";\n  connection_type = parallel;\n  vcc    = 2, 3, 4, 5;\n  buff   = 6;\n  reset  = 7;\n  sck    = 8;\n  mosi   = 9;\n  miso   = 10;\n  errled = 1;\n  rdyled = 14;\n  pgmled = 16;\n  vfyled = 17;\n;\n\nprogrammer\n  id    = \"sp12\";\n  desc  = \"Steve Bolt's Programmer\";\n  type  = \"par\";\n  connection_type = parallel;\n  vcc   = 4,5,6,7,8;\n  reset = 3;\n  sck   = 2;\n  mosi  = 9;\n  miso  = 11;\n;\n\nprogrammer\n  id     = \"picoweb\";\n  desc   = \"Picoweb Programming Cable, http://www.picoweb.net/\";\n  type   = \"par\";\n  connection_type = parallel;\n  reset  = 2;\n  sck    = 3;\n  mosi   = 4;\n  miso   = 13;\n;\n\nprogrammer\n  id    = \"abcmini\";\n  desc  = \"ABCmini Board, aka Dick Smith HOTCHIP\";\n  type  = \"par\";\n  connection_type = parallel;\n  reset = 4;\n  sck   = 3;\n  mosi  = 2;\n  miso  = 10;\n;\n\nprogrammer\n  id    = \"futurlec\";\n  desc  = \"Futurlec.com programming cable.\";\n  type  = \"par\";\n  connection_type = parallel;\n  reset = 3;\n  sck   = 2;\n  mosi  = 1;\n  miso  = 10;\n;\n\n\n# From the contributor of the \"xil\" jtag cable:\n# The \"vcc\" definition isn't really vcc (the cable gets its power from\n# the programming circuit) but is necessary to switch one of the\n# buffer lines (trying to add it to the \"buff\" lines doesn't work in\n# avrdude versions before 5.5j).\n# With this, TMS connects to RESET, TDI to MOSI, TDO to MISO and TCK\n# to SCK (plus vcc/gnd of course)\nprogrammer\n  id    = \"xil\";\n  desc  = \"Xilinx JTAG cable\";\n  type  = \"par\";\n  connection_type = parallel;\n  mosi  = 2;\n  sck   = 3;\n  reset = 4;\n  buff  = 5;\n  miso  = 13;\n  vcc   = 6;\n;\n\n\nprogrammer\n  id = \"dapa\";\n  desc = \"Direct AVR Parallel Access cable\";\n  type = \"par\";\n  connection_type = parallel;\n  vcc   = 3;\n  reset = 16;\n  sck = 1;\n  mosi = 2;\n  miso = 11;\n;\n\nprogrammer\n  id    = \"atisp\";\n  desc  = \"AT-ISP V1.1 programming cable for AVR-SDK1 from <http://micro-research.co.th/> micro-research.co.th\";\n  type  = \"par\";\n  connection_type = parallel;\n  reset = ~6;\n  sck   = ~8;\n  mosi  = ~7;\n  miso  = ~10;\n;\n\nprogrammer\n  id    = \"ere-isp-avr\";\n  desc  = \"ERE ISP-AVR <http://www.ere.co.th/download/sch050713.pdf>\";\n  type  = \"par\";\n  connection_type = parallel;\n  reset = ~4;\n  sck   = 3;\n  mosi  = 2;\n  miso  = 10;\n;\n\nprogrammer\n  id    = \"blaster\";\n  desc  = \"Altera ByteBlaster\";\n  type  = \"par\";\n  connection_type = parallel;\n  sck   = 2;\n  miso  = 11;\n  reset = 3;\n  mosi  = 8;\n  buff  = 14;\n;\n\n# It is almost same as pony-stk200, except vcc on pin 5 to auto\n# disconnect port (download on http://electropol.free.fr/spip/spip.php?article27)\nprogrammer parent \"pony-stk200\"\n  id    = \"frank-stk200\";\n  desc  = \"Frank STK200\";\n  buff  = ; # delete buff pin assignment\n  vcc   = 5;\n;\n\n# The AT98ISP Cable is a simple parallel dongle for AT89 family.\n# http://www.atmel.com/dyn/products/tools_card.asp?tool_id=2877\nprogrammer\n  id = \"89isp\";\n  desc = \"Atmel at89isp cable\";\n  type = \"par\";\n  connection_type = parallel;\n  reset = 17;\n  sck = 1;\n  mosi = 2;\n  miso = 10;\n;\n\n\n#This programmer bitbangs GPIO lines using the Linux sysfs GPIO interface\n#\n#To enable it set the configuration below to match the GPIO lines connected to the\n#relevant ISP header pins and uncomment the entry definition. In case you don't\n#have the required permissions to edit this system wide config file put the\n#entry in a separate <your name>.conf file and use it with -C+<your name>.conf\n#on the command line.\n#\n#To check if your avrdude build has support for the linuxgpio programmer compiled in,\n#use -c?type on the command line and look for linuxgpio in the list. If it's not available\n#you need pass the --enable-linuxgpio=yes option to configure and recompile avrdude.\n#\n#programmer\n#  id    = \"linuxgpio\";\n#  desc  = \"Use the Linux sysfs interface to bitbang GPIO lines\";\n#  type  = \"linuxgpio\";\n#  reset = ?;\n#  sck   = ?;\n#  mosi  = ?;\n#  miso  = ?;\n#;\n\n# some ultra cheap programmers use bitbanging on the\n# serialport.\n#\n# PC - DB9 - Pins for RS232:\n#\n# GND   5   -- |O\n#              |   O| <-   9   RI\n# DTR   4   <- |O   |\n#              |   O| <-   8   CTS\n# TXD   3   <- |O   |\n#              |   O| ->   7   RTS\n# RXD   2   -> |O   |\n#              |   O| <-   6   DSR\n# DCD   1   -> |O\n#\n# Using RXD is currently not supported.\n# Using RI is not supported under Win32 but is supported under Posix.\n\n# serial ponyprog design (dasa2 in uisp)\n# reset=!txd sck=rts mosi=dtr miso=cts\n\nprogrammer\n  id    = \"ponyser\";\n  desc  = \"design ponyprog serial, reset=!txd sck=rts mosi=dtr miso=cts\";\n  type  = \"serbb\";\n  connection_type = serial;\n  reset = ~3;\n  sck   = 7;\n  mosi  = 4;\n  miso  = 8;\n;\n\n# Same as above, different name\n# reset=!txd sck=rts mosi=dtr miso=cts\n\nprogrammer parent \"ponyser\"\n  id    = \"siprog\";\n  desc  = \"Lancos SI-Prog <http://www.lancos.com/siprogsch.html>\";\n;\n\n# unknown (dasa in uisp)\n# reset=rts sck=dtr mosi=txd miso=cts\n\nprogrammer\n  id    = \"dasa\";\n  desc  = \"serial port banging, reset=rts sck=dtr mosi=txd miso=cts\";\n  type  = \"serbb\";\n  connection_type = serial;\n  reset = 7;\n  sck   = 4;\n  mosi  = 3;\n  miso  = 8;\n;\n\n# unknown (dasa3 in uisp)\n# reset=!dtr sck=rts mosi=txd miso=cts\n\nprogrammer\n  id    = \"dasa3\";\n  desc  = \"serial port banging, reset=!dtr sck=rts mosi=txd miso=cts\";\n  type  = \"serbb\";\n  connection_type = serial;\n  reset = ~4;\n  sck   = 7;\n  mosi  = 3;\n  miso  = 8;\n;\n\n# C2N232i (jumper configuration \"auto\")\n# reset=dtr sck=!rts mosi=!txd miso=!cts\n\nprogrammer\n  id    = \"c2n232i\";\n  desc  = \"serial port banging, reset=dtr sck=!rts mosi=!txd miso=!cts\";\n  type  = \"serbb\";\n  connection_type = serial;\n  reset = 4;\n  sck   = ~7;\n  mosi  = ~3;\n  miso  = ~8;\n;\n\n#------------------------------------------------------------\n# ATTiny841\n#------------------------------------------------------------\n\n\npart\n     id            = \"t841\";\n     desc          = \"ATtiny841\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x07, 0x17;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n               0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,\n               0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     ##avr910_devcode   = 0x20;\n     signature        = 0x1e 0x93 0x15;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout   = 200;\n    stabdelay   = 100;\n    cmdexedelay   = 25;\n    synchloops    = 32;\n    bytedelay   = 0;\n    pollindex   = 3;\n    pollvalue   = 0x53;\n    predelay    = 1;\n    postdelay   = 1;\n    pollmethod    = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 0;\n    resetdelayus        = 70;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    #ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 512;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n  loadpage_lo = \"  1   1   0   0      0   0   0   1\",\n        \"  0   0   0   0      0   0   0   0\",\n        \"  0   0   0   0      0   0  a1  a0\",\n        \"  i   i   i   i      i   i   i   i\";\n\n  writepage = \"  1   1   0   0      0   0   1   0\",\n        \"  0   0   x   x      x   x   x   x\",\n        \"  x  a6  a5  a4     a3  a2   0   0\",\n        \"  x   x   x   x      x   x   x   x\";\n\n  mode    = 0x41;\n  delay   = 6;\n  blocksize = 4;\n  readsize  = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 8192;\n         page_size       = 16;\n         num_pages       = 512;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  x   x  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   x  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1   1   0  0\",\n                           \"  0  0  0  0  a11 a10 a9 a8\",\n                           \" a7 a6 a5  a4  a3  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n  mode    = 0x41;\n  delay   = 12;\n  blocksize = 32;\n  readsize  = 256;\n       ;\n#   ATtiny841 has Signature Bytes: 0x1E 0x93 0x0C.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n\n#------------------------------------------------------------\n# ATTiny441\n#------------------------------------------------------------\n\n\npart\n     id            = \"t441\";\n     desc          = \"ATtiny441\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x07, 0x17;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n               0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,\n               0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     ##avr910_devcode   = 0x20;\n     signature        = 0x1e 0x92 0x15;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout   = 200;\n    stabdelay   = 100;\n    cmdexedelay   = 25;\n    synchloops    = 32;\n    bytedelay   = 0;\n    pollindex   = 3;\n    pollvalue   = 0x53;\n    predelay    = 1;\n    postdelay   = 1;\n    pollmethod    = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 0;\n    resetdelayus        = 70;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    #ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 512;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n  loadpage_lo = \"  1   1   0   0      0   0   0   1\",\n        \"  0   0   0   0      0   0   0   0\",\n        \"  0   0   0   0      0   0  a1  a0\",\n        \"  i   i   i   i      i   i   i   i\";\n\n  writepage = \"  1   1   0   0      0   0   1   0\",\n        \"  0   0   x   x      x   x   x   x\",\n        \"  x  a6  a5  a4     a3  a2   0   0\",\n        \"  x   x   x   x      x   x   x   x\";\n\n  mode    = 0x41;\n  delay   = 6;\n  blocksize = 4;\n  readsize  = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 4096;\n         page_size       = 16;\n         num_pages       = 256;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0  0 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0  0 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  x   x  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   x  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1   1   0  0\",\n                           \"  0  0  0  0  0 a10 a9 a8\",\n                           \" a7 a6 a5  a4  a3  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n  mode    = 0x41;\n  delay   = 12;\n  blocksize = 32;\n  readsize  = 256;\n       ;\n#   ATtiny441 has Signature Bytes: 0x1E 0x92 0x0C.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# BEGIN: ATtiny1634.\n#\n# From http://www.avrfreaks.net/index.php?name=PNphpBB2&file=viewtopic&p=983337#983337\n#------------------------------------------------------------\n\npart\n    id              = \"t1634\";\n    desc            = \"ATtiny1634\";\n     has_debugwire = yes;\n     flash_instr   = 0xB6, 0x01, 0x11;\n     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,\n                0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,\n                0x99, 0xF9, 0xBB, 0xAF;\n    stk500_devcode  = 0x86;\n    # avr910_devcode = 0x;\n    signature       = 0x1e 0x94 0x12;\n    pagel           = 0xd7;\n    bs2             = 0xc2;\n    chip_erase_delay = 15000;\n    pgm_enable       = \"1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1\",\n                       \"x x x x x x x x x x x x x x x x\";\n\n    chip_erase       = \"1 0 1 0 1 1 0 0 1 0 0 x x x x x\",\n                       \"x x x x x x x x x x x x x x x x\";\n\n    timeout         = 200;\n    stabdelay       = 100;\n    cmdexedelay     = 25;\n    synchloops      = 32;\n    bytedelay       = 0;\n    pollindex       = 3;\n    pollvalue       = 0x53;\n    predelay        = 1;\n    postdelay       = 1;\n    pollmethod      = 1;\n\n    pp_controlstack     =\n   0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,\n   0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,\n   0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,\n   0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    resetdelay          = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    memory \"eeprom\"\n        paged           = no;\n        page_size       = 4;\n        size            = 256;\n        min_write_delay = 3600;\n        max_write_delay = 3600;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read            = \" 1 0 1 0 0 0 0 0\",\n                          \" 0 0 0 x x x x a8\",\n                          \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                          \" o o o o o o o o\";\n\n        write           = \" 1 1 0 0 0 0 0 0\",\n                          \" 0 0 0 x x x x a8\",\n                          \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                          \" i i i i i i i i\";\n\n   loadpage_lo   = \"  1   1   0   0      0   0   0   1\",\n           \"  0   0   0   0      0   0   0   0\",\n           \"  0   0   0   0      0   0  a1  a0\",\n           \"  i   i   i   i      i   i   i   i\";\n\n   writepage   = \"  1   1   0   0      0   0   1   0\",\n           \"  0   0   x   x      x   x   x  a8\",\n           \" a7  a6  a5  a4     a3  a2   0   0\",\n           \"  x   x   x   x      x   x   x   x\";\n\n   mode      = 0x41;\n   delay      = 5;\n   blocksize   = 4;\n   readsize   = 256;\n        ;\n\n    memory \"flash\"\n        paged           = yes;\n        size            = 16384;\n        page_size       = 32;\n        num_pages       = 512;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read_lo         = \" 0 0 1 0 0 0 0 0\",\n                          \" 0 0 0 a12 a11 a10 a9 a8\",\n                          \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                          \" o o o o o o o o\";\n\n        read_hi          = \" 0 0 1 0 1 0 0 0\",\n                           \" 0 0 0 a12 a11 a10 a9 a8\",\n                           \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                           \" o o o o o o o o\";\n\n        loadpage_lo     = \" 0 1 0 0 0 0 0 0\",\n                          \" 0 0 0 x x x x x\",\n                          \" x x x x a3 a2 a1 a0\",\n                          \" i i i i i i i i\";\n\n        loadpage_hi     = \" 0 1 0 0 1 0 0 0\",\n                          \" 0 0 0 x x x x x\",\n                          \" x x x x a3 a2 a1 a0\",\n                          \" i i i i i i i i\";\n\n        writepage       = \" 0 1 0 0 1 1 0 0\",\n                          \" 0 0 0 a12 a11 a10 a9 a8\",\n                          \" a7 a6 a5 a4 x x x x\",\n                          \" x x x x x x x x\";\n\n        mode        = 0x41;\n        delay       = 6;\n        blocksize   = 128;\n        readsize    = 256;\n\n        ;\n\n    memory \"lfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0\",\n                          \"x x x x x x x x o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0\",\n                          \"x x x x x x x x i i i i i i i i\";\n        ;\n\n    memory \"hfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0\",\n                          \"x x x x x x x x o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0\",\n                          \"x x x x x x x x i i i i i i i i\";\n        ;\n\n    memory \"efuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 0 0 0 0   0 0 0 0 1 0 0 0\",\n                          \"x x x x x x x x   o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0   1 0 1 0 0 1 0 0\",\n                          \"x x x x x x x x   1 1 1 i i i i i\";\n        ;\n\n    memory \"lock\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 1 0 0 0   0 0 0 0 0 0 0 0\",\n                          \"x x x x x x x x   o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0   1 1 1 x x x x x\",\n                          \"x x x x x x x x   1 1 1 1 1 1 i i\";\n        ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0 0 1 1 1 0 0 0 0 0 0 x x x x x\",\n                          \"0 0 0 0 0 0 0 0 o o o o o o o o\";\n        ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0 0 1 1 0 0 0 0 0 0 0 x x x x x\",\n                          \"x x x x x x a1 a0 o o o o o o o o\";\n        ;\n;\n\n#------------------------------------------------------------\n# END: ATtiny1634.\n#------------------------------------------------------------\n\n\n#------------------------------------------------------------\n# BEGIN: ATtiny828.\n#\n#------------------------------------------------------------\n\npart\n    id              = \"t828\";\n    desc            = \"ATtiny828\";\n     has_debugwire = yes;\n     flash_instr   = 0xB6, 0x01, 0x11;\n     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,\n                0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,\n                0x99, 0xF9, 0xBB, 0xAF;\n    stk500_devcode  = 0x86;\n    # avr910_devcode = 0x;\n    signature       = 0x1e 0x93 0x14;\n    pagel           = 0xd7;\n    bs2             = 0xc2;\n    chip_erase_delay = 15000;\n    pgm_enable       = \"1 0 1 0 1 1 0 0 0 1 0 1 0 0 1 1\",\n                       \"x x x x x x x x x x x x x x x x\";\n\n    chip_erase       = \"1 0 1 0 1 1 0 0 1 0 0 x x x x x\",\n                       \"x x x x x x x x x x x x x x x x\";\n\n    timeout         = 200;\n    stabdelay       = 100;\n    cmdexedelay     = 25;\n    synchloops      = 32;\n    bytedelay       = 0;\n    pollindex       = 3;\n    pollvalue       = 0x53;\n    predelay        = 1;\n    postdelay       = 1;\n    pollmethod      = 1;\n\n    pp_controlstack     =\n   0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,\n   0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,\n   0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,\n   0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    resetdelay          = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    memory \"eeprom\"\n        paged           = no;\n        page_size       = 4;\n        size            = 256;\n        min_write_delay = 3600;\n        max_write_delay = 3600;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read            = \" 1 0 1 0 0 0 0 0\",\n                          \" 0 0 0 x x x x a8\",\n                          \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                          \" o o o o o o o o\";\n\n        write           = \" 1 1 0 0 0 0 0 0\",\n                          \" 0 0 0 x x x x a8\",\n                          \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                          \" i i i i i i i i\";\n\n   loadpage_lo   = \"  1   1   0   0      0   0   0   1\",\n                   \"  0   0   0   0      0   0   0   0\",\n                   \"  0   0   0   0      0   0  a1  a0\",\n                   \"  i   i   i   i      i   i   i   i\";\n\nwritepage   = \"  1   1   0   0      0   0   1   0\",\n              \"  0   0   x   x      x   x   x  a8\",\n              \" a7  a6  a5  a4     a3  a2   0   0\",\n              \"  x   x   x   x      x   x   x   x\";\n\n   mode      = 0x41;\n   delay      = 5;\n   blocksize   = 4;\n   readsize   = 256;\n        ;\n\n    memory \"flash\"\n        paged           = yes;\n        size            = 8192;\n        page_size       = 64;\n        num_pages       = 128;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read_lo         = \" 0 0 1 0 0 0 0 0\",\n                          \" 0 0 0 0 a11 a10 a9 a8\",\n                          \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                          \" o o o o o o o o\";\n\n        read_hi          = \" 0 0 1 0 1 0 0 0\",\n                           \" 0 0 0 0 a11 a10 a9 a8\",\n                           \" a7 a6 a5 a4 a3 a2 a1 a0\",\n                           \" o o o o o o o o\";\n\n        loadpage_lo     = \" 0 1 0 0 0 0 0 0\",\n                          \" 0 0 0 x x x x x\",\n                          \" x x x a4 a3 a2 a1 a0\",\n                          \" i i i i i i i i\";\n\n        loadpage_hi     = \" 0 1 0 0 1 0 0 0\",\n                          \" 0 0 0 x x x x x\",\n                          \" x x x a4 a3 a2 a1 a0\",\n                          \" i i i i i i i i\";\n\n        writepage       = \" 0 1 0 0 1 1 0 0\",\n                          \" 0 0 0 0 a11 a10 a9 a8\",\n                          \" a7 a6 a5 x x x x x\",\n                          \" x x x x x x x x\";\n\n        mode        = 0x41;\n        delay       = 6;\n        blocksize   = 128;\n        readsize    = 256;\n\n        ;\n\n    memory \"lfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0\",\n                          \"x x x x x x x x o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0 1 0 1 0 0 0 0 0\",\n                          \"x x x x x x x x i i i i i i i i\";\n        ;\n\n    memory \"hfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 1 0 0 0 0 0 0 0 1 0 0 0\",\n                          \"x x x x x x x x o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0 1 0 1 0 1 0 0 0\",\n                          \"x x x x x x x x i i i i i i i i\";\n        ;\n\n    memory \"efuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 0 0 0 0 0 0 0 0 1 0 0 0\",\n                          \"x x x x x x x x o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0 1 0 1 0 0 1 0 0\",\n                          \"x x x x x x x x 1 1 1 i i i i i\";\n        ;\n\n    memory \"lock\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1 1 0 0 0 0 0 0 0 0 0 0 0\",\n                          \"x x x x x x x x o o o o o o o o\";\n\n        write           = \"1 0 1 0 1 1 0 0 1 1 1 x x x x x\",\n                          \"x x x x x x x x 1 1 i i i i i i\";\n        ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0 0 1 1 1 0 0 0 0 0 0 x x x x x\",\n                          \"0 0 0 0 0 0 0 0 o o o o o o o o\";\n        ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0 0 1 1 0 0 0 0 0 0 0 x x x x x\",\n                          \"x x x x x x a1 a0 o o o o o o o o\";\n        ;\n;\n\n#------------------------------------------------------------\n# END: ATtiny828.\n#------------------------------------------------------------\n\n#------------------------------------------------------------\n# ATtiny87\n#------------------------------------------------------------\n\n# Changes against ATtiny167 (beside IDs)\n#    memory \"flash\"\n#        size            = 8192;\n#        num_pages       = 64;\n\npart\n     id            = \"t87\";\n     desc          = \"ATtiny87\";\n     has_debugwire = yes;\n     flash_instr   = 0xB6, 0x01, 0x11;\n     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4,\n               0x00, 0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB,\n               0xBF, 0x99, 0xF9, 0xBB, 0xAF;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x93 0x87;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout     = 200;\n    stabdelay       = 100;\n    cmdexedelay     = 25;\n    synchloops      = 32;\n    bytedelay       = 0;\n    pollindex       = 3;\n    pollvalue       = 0x53;\n    predelay        = 1;\n    postdelay       = 1;\n    pollmethod      = 0;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,\n        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,\n        0x06, 0x16, 0x46, 0x56, 0x0A, 0x1A, 0x4A, 0x5A,\n        0x1E, 0x7C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 20;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    idr                 = 0x00;\n    spmcr               = 0x57;\n    allowfullpagebitstream = no;\n\n     memory \"eeprom\"\n         size            = 512;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 x x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 x x  x x x a8\",\n                           \"a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n  loadpage_lo   = \"  1   1   0   0      0   0   0   1\",\n        \"  0   0   0   0      0   0   0   0\",\n        \"  0   0   0   0      0   0  a1  a0\",\n        \"  i   i   i   i      i   i   i   i\";\n\n  writepage = \"  1   1   0   0      0   0   1   0\",\n        \"  0   0   x   x      x   x   x   x\",\n        \"  0   0  a5  a4     a3  a2   0   0\",\n        \"  x   x   x   x      x   x   x   x\";\n\n  mode      = 0x41;\n  delay     = 10;\n  blocksize = 4;\n  readsize  = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 8192;\n         page_size       = 128;\n         num_pages       = 64;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0  a12  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2   a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0  a12  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2   a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x  a5  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x  a5  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1   1   0  0\",\n                           \"  0  0  0  0  a11 a10 a9 a8\",\n                           \" a7 a6 a5  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n  mode      = 0x41;\n  delay     = 10;\n  blocksize = 64;\n  readsize  = 256;\n       ;\n#   ATtiny87 has Signature Bytes: 0x1E 0x93 0x87.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny167\n#------------------------------------------------------------\n\npart\n     id            = \"t167\";\n     desc          = \"ATtiny167\";\n     has_debugwire = yes;\n     flash_instr   = 0xB6, 0x01, 0x11;\n     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4,\n               0x00, 0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB,\n               0xBF, 0x99, 0xF9, 0xBB, 0xAF;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x94 0x87;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout     = 200;\n    stabdelay       = 100;\n    cmdexedelay     = 25;\n    synchloops      = 32;\n    bytedelay       = 0;\n    pollindex       = 3;\n    pollvalue       = 0x53;\n    predelay        = 1;\n    postdelay       = 1;\n    pollmethod      = 0;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,\n        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,\n        0x06, 0x16, 0x46, 0x56, 0x0A, 0x1A, 0x4A, 0x5A,\n        0x1E, 0x7C, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 20;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    idr                 = 0x00;\n    spmcr               = 0x57;\n    allowfullpagebitstream = no;\n\n     memory \"eeprom\"\n         size            = 512;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 x x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 x x  x x x a8\",\n                           \"a8 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n  loadpage_lo   = \"  1   1   0   0      0   0   0   1\",\n        \"  0   0   0   0      0   0   0   0\",\n        \"  0   0   0   0      0   0  a1  a0\",\n        \"  i   i   i   i      i   i   i   i\";\n\n  writepage = \"  1   1   0   0      0   0   1   0\",\n        \"  0   0   x   x      x   x   x   x\",\n        \"  0   0  a5  a4     a3  a2   0   0\",\n        \"  x   x   x   x      x   x   x   x\";\n\n  mode      = 0x41;\n  delay     = 10;\n  blocksize = 4;\n  readsize  = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 16384;\n         page_size       = 128;\n         num_pages       = 128;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0  a12  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2   a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0  a12  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2   a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x  a5  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x  a5  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n          writepage       = \"  0  1  0  0   1   1   0  0\",\n                           \"  0  0  0  a12  a11 a10 a9 a8\",\n                           \" a7 a6 x  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n  mode      = 0x41;\n  delay     = 10;\n  blocksize = 64;\n  readsize  = 256;\n       ;\n#   ATtiny167 has Signature Bytes: 0x1E 0x94 0x87.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n\n#------------------------------------------------------------\n# ATtiny88\n#------------------------------------------------------------\n\npart\n    id               = \"t88\";\n    desc             = \"ATtiny88\";\n     has_debugwire = yes;\n     flash_instr   = 0xB6, 0x01, 0x11;\n     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,\n                     0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,\n                     0x99, 0xF9, 0xBB, 0xAF;\n    stk500_devcode   = 0x73;\n#    avr910_devcode   = 0x;\n    signature        = 0x1e 0x93 0x11;\n    pagel            = 0xd7;\n    bs2              = 0xc2;\n    chip_erase_delay = 15000;\n    pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                       \"x x x x  x x x x    x x x x  x x x x\";\n\n    chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                       \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,\n        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,\n        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,\n        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    resetdelay          = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    ocdrev              = 1;\n\n    memory \"eeprom\"\n        paged           = no;\n        page_size       = 4;\n        size            = 64;\n        min_write_delay = 3600;\n        max_write_delay = 3600;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read            = \"  1   0   1   0      0   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2  a1  a0\",\n                          \"  o   o   o   o      o   o   o   o\";\n\n        write           = \"  1   1   0   0      0   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 20;\n        blocksize       = 4;\n        readsize        = 64;\n      ;\n    memory \"flash\"\n        paged           = yes;\n        size            = 8192;\n        page_size       = 64;\n        num_pages       = 128;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read_lo         = \"  0   0   1   0    0   0   0   0\",\n                          \"  0   0   0   0  a11 a10  a9  a8\",\n                          \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                          \"  o   o   o   o    o   o   o   o\";\n\n        read_hi         = \"  0   0   1   0    1   0   0   0\",\n                          \"  0   0   0   0  a11 a10  a9  a8\",\n                          \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                          \"  o   o   o   o    o   o   o   o\";\n\n        loadpage_lo     = \"  0   1   0   0      0   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x   x   x  a4     a3  a2  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        loadpage_hi     = \"  0   1   0   0      1   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x   x   x  a4     a3  a2  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  0   1   0   0      1   1   0   0\",\n                          \"  0   0   0   0    a11 a10  a9  a8\",\n                          \" a7  a6  a5   x      x   x   x   x\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n      ;\n\n    memory \"lfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0\",\n                          \"x x x x  x x x x   i i i i  i i i i\";\n      ;\n\n    memory \"hfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0\",\n                          \"x x x x  x x x x   i i i i  i i i i\";\n      ;\n\n    memory \"efuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x i\";\n      ;\n\n    memory \"lock\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 1 1 x  x x x x\",\n                          \"x x x x  x x x x   x x i i  i i i i\";\n      ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x\",\n                          \"0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o\";\n      ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                          \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n      ;\n  ;\n\n\n\n\n\n#------------------------------------------------------------\n# ATtiny48\n#------------------------------------------------------------\n\npart\n    id               = \"t48\";\n    desc             = \"ATtiny48\";\n     has_debugwire = yes;\n     flash_instr   = 0xB6, 0x01, 0x11;\n     eeprom_instr  = 0xBD, 0xF2, 0xBD, 0xE1, 0xBB, 0xCF, 0xB4, 0x00,\n                     0xBE, 0x01, 0xB6, 0x01, 0xBC, 0x00, 0xBB, 0xBF,\n                     0x99, 0xF9, 0xBB, 0xAF;\n    stk500_devcode   = 0x73;\n#    avr910_devcode   = 0x;\n    signature        = 0x1e 0x92 0x09;\n    pagel            = 0xd7;\n    bs2              = 0xc2;\n    chip_erase_delay = 15000;\n    pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                       \"x x x x  x x x x    x x x x  x x x x\";\n\n    chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                       \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,\n        0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,\n        0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,\n        0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    resetdelay          = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    ocdrev              = 1;\n\n    memory \"eeprom\"\n        paged           = no;\n        page_size       = 4;\n        size            = 64;\n        min_write_delay = 3600;\n        max_write_delay = 3600;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read            = \"  1   0   1   0      0   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2  a1  a0\",\n                          \"  o   o   o   o      o   o   o   o\";\n\n        write           = \"  1   1   0   0      0   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 20;\n        blocksize       = 4;\n        readsize        = 64;\n      ;\n    memory \"flash\"\n        paged           = yes;\n        size            = 4096;\n        page_size       = 64;\n        num_pages       = 64;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n        read_lo         = \"  0   0   1   0    0   0   0   0\",\n                          \"  0   0   0   0  a11 a10  a9  a8\",\n                          \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                          \"  o   o   o   o    o   o   o   o\";\n\n        read_hi         = \"  0   0   1   0    1   0   0   0\",\n                          \"  0   0   0   0  a11 a10  a9  a8\",\n                          \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                          \"  o   o   o   o    o   o   o   o\";\n\n        loadpage_lo     = \"  0   1   0   0      0   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x   x   x  a4     a3  a2  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        loadpage_hi     = \"  0   1   0   0      1   0   0   0\",\n                          \"  0   0   0   x      x   x   x   x\",\n                          \"  x   x   x  a4     a3  a2  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  0   1   0   0      1   1   0   0\",\n                          \"  0   0   0   0    a11 a10  a9  a8\",\n                          \" a7  a6  a5   x      x   x   x   x\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n      ;\n\n    memory \"lfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 0 0 0\",\n                          \"x x x x  x x x x   i i i i  i i i i\";\n      ;\n\n    memory \"hfuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  1 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  1 0 0 0\",\n                          \"x x x x  x x x x   i i i i  i i i i\";\n      ;\n\n    memory \"efuse\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0\",\n                          \"x x x x  x x x x   1 1 1 1  1 1 1 i\";\n      ;\n\n    memory \"lock\"\n        size            = 1;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        read            = \"0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x   o o o o  o o o o\";\n\n        write           = \"1 0 1 0  1 1 0 0   1 1 1 x  x x x x\",\n                          \"x x x x  x x x x   1 1 i i  i i i i\";\n      ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0  0  1  1   1  0  0  0   0  0  0  x   x  x  x  x\",\n                          \"0  0  0  0   0  0  0  0   o  o  o  o   o  o  o  o\";\n      ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                          \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n      ;\n  ;\n\n\n#------------------------------------------------------------\n# ATtiny261\n#------------------------------------------------------------\n# Close to ATtiny26\n\npart\n    id                  = \"t261\";\n    desc                = \"ATtiny261\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x00, 0x10;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n#    stk500_devcode      = 0x21;\n#    avr910_devcode      = 0x5e;\n    signature           = 0x1e 0x91 0x0c;\n    pagel               = 0xb3;\n    bs2                 = 0xb2;\n    chip_erase_delay    = 15000;\n\n    pgm_enable          = \"1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1\",\n                          \"x x x x  x x x x   x x x x  x x x x\";\n\n    chip_erase          = \"1 0 1 0  1 1 0 0   1 0 0 x  x x x x\",\n                          \"x x x x  x x x x   x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 0;\n\n    pp_controlstack     =\n        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,\n        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,\n        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,\n        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 2;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    ocdrev              = 1;\n\n    memory \"eeprom\"\n        paged           = no;\n        size            = 128;\n        page_size       = 4;\n        num_pages       = 32;\n        min_write_delay = 4000;\n        max_write_delay = 4000;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read            = \"1  0  1  0   0  0  0  0    x x x x  x x x x\",\n                          \"x a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o\";\n\n        write           = \"1  1  0  0   0  0  0  0    x x x x  x x x x\",\n                          \"x a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 10;\n        blocksize       = 4;\n        readsize        = 256;\n    ;\n\n    memory \"flash\"\n        paged           = yes;\n        size            = 2048;\n        page_size       = 32;\n        num_pages       = 64;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read_lo         = \"  0  0  1  0   0  0  0  0\",\n                          \"  x  x  x  x   x  x a9 a8\",\n                          \" a7 a6 a5 a4  a3 a2 a1 a0\",\n                          \"  o  o  o  o   o  o  o  o\";\n\n        read_hi         = \"  0  0  1  0   1  0  0  0\",\n                          \"  x  x  x  x   x  x a9 a8\",\n                          \" a7 a6 a5 a4  a3 a2 a1 a0\",\n                          \"  o  o  o  o   o  o  o  o\";\n\n        loadpage_lo     = \"  0  1  0  0   0  0  0  0\",\n                          \"  x  x  x  x   x  x  x  x\",\n                          \"  x  x  x  x  a3 a2 a1 a0\",\n                          \"  i  i  i  i   i  i  i  i\";\n\n        loadpage_hi     = \"  0  1  0  0   1  0  0  0\",\n                          \"  x  x  x  x   x  x  x  x\",\n                          \"  x  x  x  x  a3 a2 a1 a0\",\n                          \"  i  i  i  i   i  i  i  i\";\n\n        writepage       = \"  0  1  0  0   1  1  0  0\",\n                          \"  x  x  x  x   x  x a9 a8\",\n                          \" a7 a6 a5 a4   x  x  x  x\",\n                          \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 32;\n        readsize        = 256;\n    ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0  0  1  1   0  0  0  0    x x x x  x x x x\",\n                          \"0  0  0  0   0  0 a1 a0    o o o o  o o o o\";\n    ;\n\n    memory \"lock\"\n        size            = 1;\n        read            = \"0  1  0  1   1  0  0  0    x x x x  x x x x\",\n                          \"x  x  x  x   x  x  x  x    x x x x  x x o o\";\n\n        write           = \"1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i\",\n                          \"x  x  x  x   x  x  x  x    x x x x  x x x x\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n    ;\n\n    memory \"lfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"hfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"efuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x i\";\n\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0  0  1  1   1  0  0  0    x x x x  x x x x\",\n                          \"0  0  0  0   0  0  0  0    o o o o  o o o o\";\n    ;\n\n;\n\n\n#------------------------------------------------------------\n# ATtiny461\n#------------------------------------------------------------\n# Close to ATtiny261\n\npart\n    id                  = \"t461\";\n    desc                = \"ATtiny461\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x00, 0x10;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n#    stk500_devcode      = 0x21;\n#    avr910_devcode      = 0x5e;\n    signature           = 0x1e 0x92 0x08;\n    pagel               = 0xb3;\n    bs2                 = 0xb2;\n    chip_erase_delay    = 15000;\n\n    pgm_enable          = \"1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1\",\n                          \"x x x x  x x x x   x x x x  x x x x\";\n\n    chip_erase          = \"1 0 1 0  1 1 0 0   1 0 0 x  x x x x\",\n                          \"x x x x  x x x x   x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 0;\n\n    pp_controlstack     =\n        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,\n        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,\n        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,\n        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 2;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    ocdrev              = 1;\n\n    memory \"eeprom\"\n        paged           = no;\n        size            = 256;\n        page_size       = 4;\n        num_pages       = 64;\n        min_write_delay = 4000;\n        max_write_delay = 4000;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read            = \" 1  0  1  0   0  0  0  0    x x x x  x x x x\",\n                          \"a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o o\";\n\n        write           = \" 1  1  0  0   0  0  0  0    x x x x  x x x x\",\n                          \"a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \" a7  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 10;\n        blocksize       = 4;\n        readsize        = 256;\n    ;\n\n    memory \"flash\"\n        paged           = yes;\n        size            = 4096;\n        page_size       = 64;\n        num_pages       = 64;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read_lo         = \"  0  0  1  0   0   0  0  0\",\n                          \"  x  x  x  x   x a10 a9 a8\",\n                          \" a7 a6 a5 a4  a3  a2 a1 a0\",\n                          \"  o  o  o  o   o   o  o  o\";\n\n        read_hi         = \"  0  0  1  0   1   0  0  0\",\n                          \"  x  x  x  x   x a10 a9 a8\",\n                          \" a7 a6 a5 a4  a3  a2 a1 a0\",\n                          \"  o  o  o  o   o   o  o  o\";\n\n        loadpage_lo     = \"  0  1  0  0   0  0  0  0\",\n                          \"  x  x  x  x   x  x  x  x\",\n                          \"  x  x  x a4  a3 a2 a1 a0\",\n                          \"  i  i  i  i   i  i  i  i\";\n\n        loadpage_hi     = \"  0  1  0  0   1  0  0  0\",\n                          \"  x  x  x  x   x  x  x  x\",\n                          \"  x  x  x a4  a3 a2 a1 a0\",\n                          \"  i  i  i  i   i  i  i  i\";\n\n        writepage       = \"  0  1  0  0   1   1  0  0\",\n                          \"  x  x  x  x   x a10 a9 a8\",\n                          \" a7 a6 a5  x   x   x  x  x\",\n                          \"  x  x  x  x   x   x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n    ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0  0  1  1   0  0  0  0    x x x x  x x x x\",\n                          \"0  0  0  0   0  0 a1 a0    o o o o  o o o o\";\n    ;\n\n    memory \"lock\"\n        size            = 1;\n        read            = \"0  1  0  1   1  0  0  0    x x x x  x x x x\",\n                          \"x  x  x  x   x  x  x  x    x x x x  x x o o\";\n\n        write           = \"1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i\",\n                          \"x  x  x  x   x  x  x  x    x x x x  x x x x\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n    ;\n\n    memory \"lfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"hfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"efuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x i\";\n\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0  0  1  1   1  0  0  0    x x x x  x x x x\",\n                          \"0  0  0  0   0  0  0  0    o o o o  o o o o\";\n    ;\n\n;\n\n\n#------------------------------------------------------------\n# ATtiny861\n#------------------------------------------------------------\n# Close to ATtiny461\n\npart\n    id                  = \"t861\";\n    desc                = \"ATtiny861\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x00, 0x10;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x00, 0xB4, 0x00, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n#    stk500_devcode      = 0x21;\n#    avr910_devcode      = 0x5e;\n    signature           = 0x1e 0x93 0x0d;\n    pagel               = 0xb3;\n    bs2                 = 0xb2;\n    chip_erase_delay    = 15000;\n\n    pgm_enable          = \"1 0 1 0  1 1 0 0   0 1 0 1  0 0 1 1\",\n                          \"x x x x  x x x x   x x x x  x x x x\";\n\n    chip_erase          = \"1 0 1 0  1 1 0 0   1 0 0 x  x x x x\",\n                          \"x x x x  x x x x   x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 0;\n\n    pp_controlstack     =\n        0xC4, 0xE4, 0xC4, 0xE4, 0xCC, 0xEC, 0xCC, 0xEC,\n        0xD4, 0xF4, 0xD4, 0xF4, 0xDC, 0xFC, 0xDC, 0xFC,\n        0xC8, 0xE8, 0xD8, 0xF8, 0x4C, 0x6C, 0x5C, 0x7C,\n        0xEC, 0xBC, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 2;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n    ocdrev              = 1;\n\n    memory \"eeprom\"\n        paged           = no;\n        size            = 512;\n        num_pages       = 128;\n        page_size       = 4;\n        min_write_delay = 4000;\n        max_write_delay = 4000;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read            = \" 1  0  1  0   0  0  0  0    x x x x  x x x a8\",\n                          \"a7 a6 a5 a4  a3 a2 a1 a0    o o o o  o o o  o\";\n\n        write           = \" 1  1  0  0   0  0  0  0    x x x x  x x x a8\",\n                          \"a7 a6 a5 a4  a3 a2 a1 a0    i i i i  i i i  i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x  a8\",\n                          \" a7  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 10;\n        blocksize       = 4;\n        readsize        = 256;\n    ;\n\n    memory \"flash\"\n        paged           = yes;\n        size            = 8192;\n        page_size       = 64;\n        num_pages       = 128;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read_lo         = \"  0  0  1  0   0   0  0  0\",\n                          \"  x  x  x  x a11 a10 a9 a8\",\n                          \" a7 a6 a5 a4  a3  a2 a1 a0\",\n                          \"  o  o  o  o   o   o  o  o\";\n\n        read_hi         = \"  0  0  1  0   1   0  0  0\",\n                          \"  x  x  x  x a11 a10 a9 a8\",\n                          \" a7 a6 a5 a4  a3  a2 a1 a0\",\n                          \"  o  o  o  o   o   o  o  o\";\n\n        loadpage_lo     = \"  0  1  0  0   0  0  0  0\",\n                          \"  x  x  x  x   x  x  x  x\",\n                          \"  x  x  x a4  a3 a2 a1 a0\",\n                          \"  i  i  i  i   i  i  i  i\";\n\n        loadpage_hi     = \"  0  1  0  0   1  0  0  0\",\n                          \"  x  x  x  x   x  x  x  x\",\n                          \"  x  x  x a4  a3 a2 a1 a0\",\n                          \"  i  i  i  i   i  i  i  i\";\n\n        writepage       = \"  0  1  0  0   1   1  0  0\",\n                          \"  x  x  x  x a11 a10 a9 a8\",\n                          \" a7 a6 a5  x   x   x  x  x\",\n                          \"  x  x  x  x   x   x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n    ;\n\n    memory \"signature\"\n        size            = 3;\n        read            = \"0  0  1  1   0  0  0  0    x x x x  x x x x\",\n                          \"0  0  0  0   0  0 a1 a0    o o o o  o o o o\";\n    ;\n\n    memory \"lock\"\n        size            = 1;\n        read            = \"0  1  0  1   1  0  0  0    x x x x  x x x x\",\n                          \"x  x  x  x   x  x  x  x    x x x x  x x o o\";\n\n        write           = \"1  0  1  0   1  1  0  0    1 1 1 1  1 1 i i\",\n                          \"x  x  x  x   x  x  x  x    x x x x  x x x x\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n    ;\n\n    memory \"lfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"hfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"efuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0   1 0 1 0  0 1 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x i\";\n\n        read            = \"0 1 0 1  0 0 0 0   0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x   x x x x  x x x o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n      ;\n\n    memory \"calibration\"\n        size            = 1;\n        read            = \"0  0  1  1   1  0  0  0    x x x x  x x x x\",\n                          \"0  0  0  0   0  0  0  0    o o o o  o o o o\";\n    ;\n\n;\n\n\n#------------------------------------------------------------\n# ATtiny25\n#------------------------------------------------------------\n\npart\n     id            = \"t25\";\n     desc          = \"ATtiny25\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x02, 0x12;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x91 0x08;\n     reset            = io;\n     chip_erase_delay = 400000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 128;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 12;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 2048;\n         page_size       = 32;\n         num_pages       = 64;\n         min_write_delay = 30000;\n         max_write_delay = 30000;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0   0  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0   0  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0  0 a9 a8\",\n                           \" a7 a6 a5 a4   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 12;\n        blocksize       = 32;\n        readsize        = 256;\n       ;\n#   ATtiny25 has Signature Bytes: 0x1E 0x91 0x08.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  1 1 i i  i i i i\";\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 2;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny45\n#------------------------------------------------------------\n\npart\n     id            = \"t45\";\n     desc          = \"ATtiny45\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x02, 0x12;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x92 0x06;\n     reset            = io;\n     chip_erase_delay = 400000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    hvsp_controlstack     =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 256;\n         page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x x\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x x\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \" a7  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 12;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 4096;\n         page_size       = 64;\n         num_pages       = 64;\n         min_write_delay = 30000;\n         max_write_delay = 30000;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0  a10 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0  a10 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0 a10 a9 a8\",\n                           \" a7 a6 a5  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 12;\n        blocksize       = 32;\n        readsize        = 256;\n       ;\n#   ATtiny45 has Signature Bytes: 0x1E 0x92 0x08. (Data sheet 2586C-AVR-06/05 (doc2586.pdf) indicates otherwise!)\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  1 1 i i  i i i i\";\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 2;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny85\n#------------------------------------------------------------\n\npart\n     id            = \"t85\";\n     desc          = \"ATtiny85\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x02, 0x12;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x02, 0xB4, 0x02, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x93 0x0b;\n     reset            = io;\n     chip_erase_delay = 400000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x00;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 512;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x  a8\",\n                          \" a7  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 12;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 8192;\n         page_size       = 64;\n         num_pages       = 128;\n         min_write_delay = 30000;\n         max_write_delay = 30000;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1   1   0  0\",\n                           \"  0  0  0  0  a11 a10 a9 a8\",\n                           \" a7 a6 a5  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 12;\n        blocksize       = 32;\n        readsize        = 256;\n       ;\n#   ATtiny85 has Signature Bytes: 0x1E 0x93 0x08.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  1 1 i i  i i i i\";\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 2;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n\n#------------------------------------------------------------\n# ATtiny24\n#------------------------------------------------------------\n\npart\n     id            = \"t24\";\n     desc          = \"ATtiny24\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x07, 0x17;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x91 0x0b;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 0;\n    resetdelayus        = 70;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 128;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 2048;\n         page_size       = 32;\n         num_pages       = 64;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0   0  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0   0  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0  0 a9 a8\",\n                           \" a7 a6 a5 a4   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 32;\n        readsize        = 256;\n       ;\n#   ATtiny24 has Signature Bytes: 0x1E 0x91 0x0B.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny44\n#------------------------------------------------------------\n\npart\n     id            = \"t44\";\n     desc          = \"ATtiny44\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x07, 0x17;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x92 0x07;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 0;\n    resetdelayus        = 70;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 256;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x x\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x x\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 4096;\n         page_size       = 64;\n         num_pages       = 64;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0  a10 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0  a10 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0 a10 a9 a8\",\n                           \" a7 a6 a5  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 32;\n        readsize        = 256;\n       ;\n#   ATtiny44 has Signature Bytes: 0x1E 0x92 0x07.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny84\n#------------------------------------------------------------\n\npart\n     id            = \"t84\";\n     desc          = \"ATtiny84\";\n     has_debugwire = yes;\n     flash_instr   = 0xB4, 0x07, 0x17;\n     eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n## no STK500 devcode in XML file, use the ATtiny45 one\n     stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n     avr910_devcode   = 0x20;\n     signature        = 0x1e 0x93 0x0c;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    hvsp_controlstack   =\n        0x4C, 0x0C, 0x1C, 0x2C, 0x3C, 0x64, 0x74, 0x66,\n        0x68, 0x78, 0x68, 0x68, 0x7A, 0x6A, 0x68, 0x78,\n        0x78, 0x7D, 0x6D, 0x0C, 0x80, 0x40, 0x20, 0x10,\n        0x11, 0x08, 0x04, 0x02, 0x03, 0x08, 0x04, 0x0F;\n    hventerstabdelay    = 100;\n    hvspcmdexedelay     = 0;\n    synchcycles         = 6;\n    latchcycles         = 1;\n    togglevtg           = 1;\n    poweroffdelay       = 25;\n    resetdelayms        = 0;\n    resetdelayus        = 70;\n    hvleavestabdelay    = 100;\n    resetdelay          = 25;\n    chiperasepolltimeout = 40;\n    chiperasetime       = 0;\n    programfusepolltimeout = 25;\n    programlockpolltimeout = 25;\n\n    ocdrev              = 1;\n\n     memory \"eeprom\"\n         size            = 512;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x a8\",\n                           \"a7 a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 8192;\n         page_size       = 64;\n         num_pages       = 128;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0  a11 a10  a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x  a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n         writepage       = \"  0  1  0  0   1   1   0  0\",\n                           \"  0  0  0  0  a11 a10 a9 a8\",\n                           \" a7 a6 a5  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 32;\n        readsize        = 256;\n       ;\n#   ATtiny84 has Signature Bytes: 0x1E 0x93 0x0C.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  x x x x  x x i i\";\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"0 0 0 0  0 0 0 0  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n\n     memory \"calibration\"\n         size            = 1;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny2313\n#------------------------------------------------------------\n\npart\n     id            = \"t2313a\";\n     desc          = \"ATtiny2313a\";\n     has_debugwire = yes;\n     flash_instr   = 0xB2, 0x0F, 0x1F;\n     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n     stk500_devcode   = 0x23;\n##   Use the ATtiny26 devcode:\n     avr910_devcode   = 0x5e;\n     signature        = 0x1e 0x91 0x0a;\n     pagel            = 0xD4;\n     bs2              = 0xD6;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,\n        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,\n        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,\n        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n     memory \"eeprom\"\n         size            = 256;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 2048;\n         page_size       = 32;\n         num_pages       = 64;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n\n#####\n\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0   0 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0   0 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0  0  a9 a8\",\n                           \" a7 a6 a5  a4   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n       ;\n#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  1 1 i i  i i i i\";\n         read           = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  x x o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.\n# The information in the data sheet of April/2004 is wrong, this works:\n\n     memory \"calibration\"\n         size            = 2;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\npart\n     id            = \"t2313\";\n     desc          = \"ATtiny2313a\";\n     has_debugwire = yes;\n     flash_instr   = 0xB2, 0x0F, 0x1F;\n     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n     stk500_devcode   = 0x23;\n##   Use the ATtiny26 devcode:\n     avr910_devcode   = 0x5e;\n     signature        = 0x1e 0x91 0x0a;\n     pagel            = 0xD4;\n     bs2              = 0xD6;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,\n        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,\n        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,\n        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n     memory \"eeprom\"\n         size            = 256;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 2048;\n         page_size       = 32;\n         num_pages       = 64;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n\n#####\n\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0   0 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0   0 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   x   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0  0  a9 a8\",\n                           \" a7 a6 a5  a4   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n       ;\n#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  1 1 i i  i i i i\";\n         read           = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  x x o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.\n# The information in the data sheet of April/2004 is wrong, this works:\n\n     memory \"calibration\"\n         size            = 2;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny4313\n#------------------------------------------------------------\n\npart\n     id            = \"t4313\";\n     desc          = \"ATtiny4313\";\n     has_debugwire = yes;\n     flash_instr   = 0xB2, 0x0F, 0x1F;\n     eeprom_instr  = 0xBB, 0xFE, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                     0xBA, 0x0F, 0xB2, 0x0F, 0xBA, 0x0D, 0xBB, 0xBC,\n                     0x99, 0xE1, 0xBB, 0xAC;\n     stk500_devcode   = 0x23;\n##   Use the ATtiny26 devcode:\n     avr910_devcode   = 0x5e;\n     signature        = 0x1e 0x92 0x0d;\n     pagel            = 0xD4;\n     bs2              = 0xD6;\n     reset            = io;\n     chip_erase_delay = 15000;\n\n     pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n     chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout             = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n\n    pp_controlstack     =\n        0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E,\n        0x4E, 0x5E, 0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E,\n        0x26, 0x36, 0x66, 0x76, 0x2A, 0x3A, 0x6A, 0x7A,\n        0x2E, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 15;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n\n     memory \"eeprom\"\n         size            = 256;\n        paged           = no;\n        page_size       = 4;\n         min_write_delay = 4000;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n         read            = \"1  0  1  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n         write           = \"1  1  0  0   0  0  0  0   0 0 0 x  x x x x\",\n                           \"x a6 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n        loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                          \"  0   0   0   0      0   0   0   0\",\n                          \"  0   0   0   0      0   0  a1  a0\",\n                          \"  i   i   i   i      i   i   i   i\";\n\n        writepage       = \"  1   1   0   0      0   0   1   0\",\n                          \"  0   0   x   x      x   x   x   x\",\n                          \"  x  a6  a5  a4     a3  a2   0   0\",\n                          \"  x   x   x   x      x   x   x   x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 4;\n        readsize        = 256;\n       ;\n     memory \"flash\"\n         paged           = yes;\n         size            = 4096;\n         page_size       = 64;\n         num_pages       = 64;\n         min_write_delay = 4500;\n         max_write_delay = 4500;\n         readback_p1     = 0xff;\n         readback_p2     = 0xff;\n\n#####\n\n         read_lo         = \"  0   0   1   0    0   0   0   0\",\n                           \"  0   0   0   0    0  a10 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n         read_hi         = \"  0   0   1   0    1   0   0   0\",\n                           \"  0   0   0   0    0  a10 a9  a8\",\n                           \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                           \"  o   o   o   o    o   o   o   o\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                           \"  0   0   0   x    x   x   x   x\",\n                           \"  x   x   x   a4   a3  a2  a1  a0\",\n                           \"  i   i   i   i    i   i   i   i\";\n\n# The information in the data sheet of April/2004 is wrong, this works:\n         writepage       = \"  0  1  0  0   1  1  0  0\",\n                           \"  0  0  0  0   0  a10  a9 a8\",\n                           \" a7 a6 a5  x   x  x  x  x\",\n                           \"  x  x  x  x   x  x  x  x\";\n\n        mode            = 0x41;\n        delay           = 6;\n        blocksize       = 64;\n        readsize        = 256;\n       ;\n#   ATtiny2313 has Signature Bytes: 0x1E 0x91 0x0A.\n     memory \"signature\"\n         size            = 3;\n         read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                           \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n       ;\n     memory \"lock\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                           \"x x x x  x x x x  1 1 i i  i i i i\";\n         read           = \"0 1 0 1  1 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  x x o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"lfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"hfuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                           \"x x x x  x x x x  i i i i  i i i i\";\n\n         read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n       ;\n\n     memory \"efuse\"\n         size            = 1;\n         write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                           \"x x x x  x x x x  x x x x  x x x i\";\n\n         read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                           \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 9000;\n        max_write_delay = 9000;\n     ;\n# The Tiny2313 has calibration data for both 4 MHz and 8 MHz.\n# The information in the data sheet of April/2004 is wrong, this works:\n\n     memory \"calibration\"\n         size            = 2;\n         read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                           \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n     ;\n  ;\n\n#------------------------------------------------------------\n# ATtiny43U\n#------------------------------------------------------------\n\npart\n    id            = \"t43u\";\n    desc          = \"ATtiny43u\";\n    has_debugwire = yes;\n    flash_instr   = 0xB4, 0x07, 0x17;\n    eeprom_instr  = 0xBB, 0xFF, 0xBB, 0xEE, 0xBB, 0xCC, 0xB2, 0x0D,\n                         0xBC, 0x07, 0xB4, 0x07, 0xBA, 0x0D, 0xBB, 0xBC,\n                         0x99, 0xE1, 0xBB, 0xAC;\n    stk500_devcode   = 0x14;\n##  avr910_devcode   = ?;\n##  Try the AT90S2313 devcode:\n    avr910_devcode   = 0x20;\n    signature        = 0x1e 0x92 0x0C;\n    reset            = io;\n    chip_erase_delay = 1000;\n\n    pgm_enable       = \"1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    chip_erase       = \"1 0 1 0  1 1 0 0    1 0 0 x  x x x x\",\n                        \"x x x x  x x x x    x x x x  x x x x\";\n\n    timeout                     = 200;\n    stabdelay           = 100;\n    cmdexedelay         = 25;\n    synchloops          = 32;\n    bytedelay           = 0;\n    pollindex           = 3;\n    pollvalue           = 0x53;\n    predelay            = 1;\n    postdelay           = 1;\n    pollmethod          = 1;\n        pp_controlstack = 0x0E, 0x1E, 0x0E, 0x1E, 0x2E, 0x3E, 0x2E, 0x3E, 0x4E, 0x5E,\n                                         0x4E, 0x5E, 0x6E, 0x7E, 0x6E, 0x7E, 0x06, 0x16, 0x46, 0x56,\n                                         0x0A, 0x1A, 0x4A, 0x5A, 0x1E, 0x7C, 0x00, 0x01, 0x00, 0x00,\n                                         0x00, 0x00;\n    hventerstabdelay    = 100;\n    progmodedelay       = 0;\n    hvspcmdexedelay     = 0;\n    latchcycles         = 5;\n    togglevtg           = 1;\n    poweroffdelay       = 20;\n    resetdelayms        = 1;\n    resetdelayus        = 0;\n    hvleavestabdelay    = 15;\n    resetdelay          = 15;\n    chiperasepulsewidth = 0;\n    chiperasepolltimeout = 10;\n    programfusepulsewidth = 0;\n    programfusepolltimeout = 5;\n    programlockpulsewidth = 0;\n    programlockpolltimeout = 5;\n    memory \"eeprom\"\n                size            = 64;\n                paged                   = yes;\n                page_size       = 4;\n                num_pages               = 16;\n                min_write_delay = 4000;\n                max_write_delay = 4500;\n                readback_p1     = 0xff;\n                readback_p2     = 0xff;\n                read            = \"1  0  1  0   0  0  0  0    0 0 0 x  x x x x\",\n                                   \"0  0 a4  a3 a2 a1 a0   o o o o  o o o o\";\n\n                write           = \"1  1  0  0   0  0  0  0    0 0 0 x  x x x x\",\n                                   \"0  0 a5 a4  a3 a2 a1 a0   i i i i  i i i i\";\n\n                loadpage_lo     = \"  1   1   0   0      0   0   0   1\",\n                                  \"  0   0   0   0      0   0   0   0\",\n                                  \"  0   0   0   0      0   0  a1  a0\",\n                                  \"  i   i   i   i      i   i   i   i\";\n\n                writepage       = \"  1   1   0   0      0   0   1   0\",\n                                  \"  0   0   x   x      x   x   x   x\",\n                                  \"  0   0  a5  a4     a3  a2   0   0\",\n                                  \"  x   x   x   x      x   x   x   x\";\n\n                mode            = 0x41;\n                delay           = 5;\n                blocksize       = 4;\n                readsize        = 256;\n        ;\n    memory \"flash\"\n        paged           = yes;\n        size            = 4096;\n        page_size       = 64;\n        num_pages       = 64;\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        readback_p1     = 0xff;\n        readback_p2     = 0xff;\n\n        read_lo         = \"  0   0   1   0    0   0   0   0\",\n                          \"  0   0   0   0    0  a10 a9  a8\",\n                          \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                          \"  o   o   o   o    o   o   o   o\";\n\n        read_hi         = \"  0   0   1   0    1   0   0   0\",\n                          \"  0   0   0   0    0  a10 a9  a8\",\n                          \" a7  a6  a5  a4   a3  a2  a1  a0\",\n                          \"  o   o   o   o    o   o   o   o\";\n\n        loadpage_lo     = \"  0   1   0   0    0   0   0   0\",\n                          \"  0   0   0   x    x   x   x   x\",\n                          \"  x   x   x  a4   a3  a2  a1  a0\",\n                          \"  i   i   i   i    i   i   i   i\";\n\n        loadpage_hi     = \"  0   1   0   0    1   0   0   0\",\n                          \"  0   0   0   x    x   x   x   x\",\n                          \"  x   x   x  a4   a3  a2  a1  a0\",\n                          \"  i   i   i   i    i   i   i   i\";\n\n        writepage       = \"  0  1  0  0   1  1  0  0\",\n                          \"  0  0  0  0   0 a10 a9 a8\",\n                          \" a7 a6 a5  x   x  x  x  x\",\n                          \"  x  x  x  x   x  x  x  x\";\n\n                mode            = 0x41;\n                delay           = 10;\n                blocksize       = 64;\n                readsize        = 256;\n       ;\n    memory \"signature\"\n        size            = 3;\n        read            = \"0  0  1  1   0  0  0  0   0  0  0  x   x  x  x  x\",\n                          \"x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o\";\n    ;\n    memory \"lock\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 1 1 x  x x x x\",\n                          \"x x x x  x x x x  1 1 i i  i i i i\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n    ;\n\n    memory \"lfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        ;\n\n    memory \"hfuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0\",\n                          \"x x x x  x x x x  i i i i  i i i i\";\n\n        read            = \"0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n        ;\n\n    memory \"efuse\"\n        size            = 1;\n        write           = \"1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0\",\n                          \"x x x x  x x x x  x x x x  x x x i\";\n\n        read            = \"0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0\",\n                          \"x x x x  x x x x  o o o o  o o o o\";\n        min_write_delay = 4500;\n        max_write_delay = 4500;\n    ;\n\n    memory \"calibration\"\n        size            = 2;\n        read            = \"0  0  1  1   1  0  0  0    0 0 0 x  x x x x\",\n                          \"0  0  0  0   0  0  0  a0   o o o o  o o o o\";\n    ;\n;\n"
        }
      ]
    }
  ]
}