{
  "metadata": {
    "timestamp": 1736709669076,
    "page": 25,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "eradman/entr",
      "stars": 4772,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".clang-format",
          "type": "blob",
          "size": 0.3896484375,
          "content": "---\nUseTab: ForIndentation\nLanguage: Cpp\nTabWidth: 4\nColumnLimit: 100\nIndentWidth: 4\nBasedOnStyle: LLVM\nAlignOperands: false\nIncludeBlocks: Preserve\nSpaceBeforeParens: ControlStatements\nCpp11BracedListStyle: false\nSpaceAfterCStyleCast: true\nAlignAfterOpenBracket: DontAlign\nBreakBeforeBinaryOperators: NonAssignment\nSpacesBeforeTrailingComments: 2\nAlwaysBreakAfterDefinitionReturnType: TopLevel\n...\n"
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0263671875,
          "content": "*.o\nMakefile\ncompat.c\nentr\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 3.3173828125,
          "content": "1) Project Source\n\n    Source code for `entr` is licensed under an ISC-style license, to the\n    following copyright holders:\n\n    Eric Radman\n\n    * Permission to use, copy, modify, and distribute this software for any\n    * purpose with or without fee is hereby granted, provided that the above\n    * copyright notice and this permission notice appear in all copies.\n    *\n    * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n2) Compatibility Libraries (MacOS and Linux only)\n\n    Some code under the /missing subdirectory is licensed under a 2-term BSD\n    license, to the following copyright holders:\n\n    Jonathan Lemon\n\n    * Redistribution and use in source and binary forms, with or without\n    * modification, are permitted provided that the following conditions\n    * are met:\n    * 1. Redistributions of source code must retain the above copyright\n    *    notice, this list of conditions and the following disclaimer.\n    * 2. Redistributions in binary form must reproduce the above copyright\n    *    notice, this list of conditions and the following disclaimer in the\n    *    documentation and/or other materials provided with the distribution.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n    * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n    * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n    * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n    * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n    * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n    * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    * SUCH DAMAGE.\n\n    Some code under the /missing subdirectory is licensed under an ISC-style\n    license, to the following copyright holders:\n\n    Todd C. Miller\n    Martin Pieuchot\n    Ted Unangst\n\n    * Permission to use, copy, modify, and distribute this software for any\n    * purpose with or without fee is hereby granted, provided that the above\n    * copyright notice and this permission notice appear in all copies.\n    *\n    * THE SOFTWARE IS PROVIDED \"AS IS\" AND TODD C. MILLER DISCLAIMS ALL\n    * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES\n    * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE\n    * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION\n    * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n    * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "Makefile.bsd",
          "type": "blob",
          "size": 0.849609375,
          "content": "CLANG_FORMAT ?= clang-format\nPREFIX ?= /usr/local\nMANPREFIX ?= ${PREFIX}/man\nRELEASE = 5.6\nCOMPONENTS = compat.o status.o entr.o\n\nall: entr\n\ncompat.c: missing/*\n\tcat /dev/null ${EXTRA_SRC} > compat.c\n\n.c.o:\n\t${CC} ${CFLAGS} ${CPPFLAGS} -DRELEASE=\\\"${RELEASE}\\\" -c $<\n\nentr: ${COMPONENTS}\n\t${CC} ${CFLAGS} ${CPPFLAGS} -o $@ ${COMPONENTS} ${LDFLAGS}\n\ntest: entr\n\tls entr.1 | EV_TRACE=1 ./entr -zn wc -l entr.1\n\ncheck: entr\n\t./system_test.sh\n\nclean:\n\trm -f *.o compat.c entr\n\ndistclean: clean\n\trm -f Makefile\n\ninstall: entr\n\t@mkdir -p ${DESTDIR}${PREFIX}/bin\n\t@mkdir -p ${DESTDIR}${MANPREFIX}/man1\n\tinstall entr ${DESTDIR}${PREFIX}/bin\n\tinstall -m 644 entr.1 ${DESTDIR}${MANPREFIX}/man1\n\nuninstall:\n\trm ${DESTDIR}${PREFIX}/bin/entr\n\trm ${DESTDIR}${MANPREFIX}/man1/entr.1\n\nformat:\n\t${CLANG_FORMAT} -i *.c *.h\n\n.PHONY: all test check clean format distclean install uninstall\n"
        },
        {
          "name": "Makefile.freebsd",
          "type": "blob",
          "size": 0.0537109375,
          "content": "MANPREFIX ?= ${PREFIX}/share/man\n\ninclude Makefile.bsd\n"
        },
        {
          "name": "Makefile.linux",
          "type": "blob",
          "size": 0.138671875,
          "content": "CPPFLAGS += -D_GNU_SOURCE -D_LINUX_PORT -Imissing\nMANPREFIX ?= ${PREFIX}/share/man\nEXTRA_SRC = missing/kqueue_inotify.c\n\ninclude Makefile.bsd\n"
        },
        {
          "name": "Makefile.linux-compat",
          "type": "blob",
          "size": 0.15625,
          "content": "CPPFLAGS += -D_GNU_SOURCE -D_LINUX_PORT -Imissing\nMANPREFIX ?= ${PREFIX}/share/man\nEXTRA_SRC = missing/strlcpy.c missing/kqueue_inotify.c\n\ninclude Makefile.bsd\n"
        },
        {
          "name": "Makefile.macos",
          "type": "blob",
          "size": 0.0908203125,
          "content": "CPPFLAGS += -D_MACOS_PORT\nMANPREFIX ?= ${PREFIX}/share/man\nEXTRA_SRC =\n\ninclude Makefile.bsd\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 12.322265625,
          "content": "= Release History\n\n== 5.6: July 1, 2024\n\n - Process exit status messages using background awk scripts\n - Use min(OPEN_MAX, rl.rlim_max) to set rlim_cur on MacOS\n - Detect and use native strlcpy(3)\n - Always build with GNU_SOURCE set on Linux\n\n== 5.5: November 17, 2023\n\n - Report correct error if open(3) fails\n - Use kern.maxfilesperproc to determine file open limit on MacOS\n\n== 5.4: August 1, 2023\n\n - 'make test' runs a quick smoketest, 'make check' runs regressions\n - Set IN_CLOEXEC only for inotify_init, kqueue uses similar setting by default\n - Unconditionally try to set soft file limit to 2^16 on MacOS\n - Use non-reentrant calls sparingly in signal handlers\n - configure: use TARGET_OS to override the output of uname(1)\n\n== 5.3: January 20, 2023\n\n - Symlink changes detected on Linux by setting 'ENTR_INOTIFY_SYMLINK'\n - Use /dev/null rather then closed pipe for stdin in -r mode\n - Utilize {O,FD}_CLOEXEC flag for unintentional leaks of descriptors to\n   executed utilities\n - Remove C unit tests\n - Only respond to attribute/inode changes on Linux\n\n== 5.2: May 05, 2022\n\n - Update copy of strlcpy(3) for Linux\n - Detect file deletion from directories on Linux\n - Print the signal that terminated a child when using '-s'\n - Return 128+signal that terminated a child when using '-z'\n - Ensure terminal settings are reset when '-z' is set\n\n== 5.1: December 28, 2021\n\n - Detect files moved to or from directories on Linux\n - Allow detection of directory entries beginning with '.' by specifying '-d' twice\n - Only reset terminal settings in exit handler if settings were changed\n\n== 5.0: July 2, 2021\n\n - Add missing call to getrlimit(3) on MacOS\n - Eliminate memory management warnings on Linux\n - EV_TRACE prints file mode and file name\n - Ignore asynchronous attribute changes on MacOS 11\n\n== 4.9: May 3, 2021\n\n - EV_TRACE also prints file/notify descriptor limit\n - Don't raise rlim_cur on MacOS\n - Set 2^16 watches if inotify limits cannot be read\n - Raise an error and suggest '-n' if terminal attributes cannot be read\n\n== 4.8: February 26, 2021\n\n - Set a maximum of 2^19 watches to guard against absurd file open limits on\n   MacOS\n - Use control sequences to clear the display and specify '-c' twice to erase\n   the scrollback buffer\n\n== 4.7: January 29, 2021\n\n - Use system file descriptor limits when max_user_watches is not accessible\n - Return the exit status of the child process when the '-z' option is used\n - Handle SIGHUP so child process are terminated when a terminal is closed\n - More accurately return shell exit code using '-s' option\n\n== 4.6: July 1, 2020\n\n - Always call waitpid(2) to avoid dead processes\n - Duplicate STDIN file descriptor before closing; for the '-r' option\n\n== 4.5: April 20, 2020\n\n - New '-z' \"one-shot\" option self-terminates after the utility exits\n - Termination by 'q' or 'SIGINT' results in an exit status of 0\n\n== 4.4: January 02, 2020\n\n - Use a single inotify queue on Linux, limited by\n   /proc/sys/fs/inotify/max_user_watches\n - Set the environment variable 'ENTR_INOTIFY_WORKAROUND' to enable a\n   compatibility mode for platforms with deformed inotify support\n\n== 4.3: September 25, 2019\n\n - Move hosting from bitbucket.org to github.com\n - Rename tag names from entr-X.Y to X.Y\n - Replace hg with git as a dependency for system-test.sh\n\n== 4.2: March 28, 2019\n\n - Use pledge(2) on OpenBSD\n - New '-a' option enables response to events that occur while the utility is\n   running\n - Error messages direct users to http://eradman.com/entrproject/limits.html\n - Correctly report error when a file cannot be reopened\n\n== 4.1: June 13, 2018\n\n - New '-n' non-interactive option disables keyboard input\n - EV_TRACE environment variable enables file system event tracing\n - Track changes to the inode number as a workaround for missing delete\n   events on the Linux kernel\n\n== 4.0: February 02, 2018\n\n - Warn instead of error if kqueue fails to register on STDIN\n - Close STDIN before running the utility when the restart option is used\n - Restore terminal settings if terminated by a signal\n\n== 3.9: September 19, 2017\n\n - Fix use of poll(2) to avoid possible busy-loop on Linux\n - Disable keyboard input if reading STDIN fails\n\n== 3.8: August 11, 2017\n\n - Run the utility if the spacebar is pressed\n - 'q' for quit\n\n== 3.7: February 27, 2017\n\n - Terminate subprocess in restart mode if a file under watch disappears\n - Allow NOTE_ATTRIB to set '/_' only if file mode changes\n - New '-s' option executes commands using $SHELL -c\n - Print usage and exit if input is from a terminal instead of a pipe\n\n== 3.6: July 01, 2016\n\n - Do not print warning if _TTY_PATH cannot be opened (for chroot, docker, ...)\n - Non-existent input files produce a warning instead of an error\n - Trigger run when permissions change on regular files\n\n== 3.5: April 01, 2016\n\n - Removed contrib/*\n - Detect new subdirectories on Linux\n - Direct users to http://entrproject.org/limits.html if inotify hits a kernel\n   limit\n\n== 3.4: December 12, 2015\n\n - Terminate the child process before exiting when the reload option is combined\n   with the directory watch option\n - Direct users to http://entrproject.org/limits.html if the maximum number of\n   open files is exceeded\n\n== 3.3: October 23, 2015\n\n - Substitute '/_' only with regular files when using the directory watch option\n - Bugfix when tracking the first file to change\n - Display release number along with usage\n\n\n== 3.2: April 9, 2015\n\n - Execute the utility immediately after registering watch events. Old behavior\n   is restored using new postpone option ('-p')\n - Relocated 'reload-browser' to http://entrproject.org/scripts/reload-browser\n - Drop FIFO support to further simply code and documentation. FIFO mode was\n   conceptually good, but EXEC mode is intelligent hand easily handles the vast\n   majority of use cases\n - Remove kFreeBSD as a target platform\n\n== 3.1: March 4, 2015\n\n - Return error code indicating exit reason after handling signals\n - Restart mode sets process group to ensure that wrapper scripts do not prevent\n   signals from reaching child processes\n - Removed DEBUG printf statements\n\n== 3.0: December 19, 2014\n\n - Man page highlights the flexibility of executing a commands using a shell\n - 'reload-browser', a cross-platform script for reloading the current tab in\n   one or more browsers\n - system_test.sh auto-upgrades to bash if the default shell does not support\n   the ERR trap\n - Workaround implemented for Linux using fstat(2) to detect if a binary was\n   removed if inotify issues IN_ATTRIB but not IN_DELETE_SELF\n - Use calloc(3) to take advantage of overflow detection\n\n== 2.9: June 10, 2014\n\n - Moved alternate Makefiles to contrib/\n - Trigger actions when a file is truncated on BSD\n - Improved format of DEBUG messages\n - Added missing extern for missing/fmemopen.c to avoid warning on MacOS 10.7+\n - No longer register NOTE_EXTEND; this event is not always merged with\n   NOTE_WRITE on MacOS\n - New directory-watch option ('-d'). In this mode a shell while-loop can be\n   used to track the addition of new files\n\n\n== 2.8: March 15, 2014\n\n - Iteratively check for new file system events using a 1ms timeout after a file\n   has been renamed or removed in order to prevent the utility from being\n   executed before successive changes from a version control system have\n   completed\n - Regression tests use Vim and Mercurial\n - Timing on regression tests has been tightened to only support real hardware;\n   they are not expected to pass in emulated environments\n - More correctly identify the first file to trigger a file change notification\n - Renamed regress.sh to system_test.sh, and drop dependency on ksh\n\n== 2.7: February 12, 2014\n\n - Changed function pointer prefixes from '_' to 'x' to avoid runtime symbol\n   collisions in libc. Required to build on DragonFlyBSD\n - Add this NEWS file to provide detailed release history for port maintainers\n - Substitute '/_' argument with the first file that changed\n - Man page formatted with more semantically correct markup\n - Multiple events on the same file are merged on Linux to prevent duplicate\n   writes to a named pipe\n\n== 2.6: January 23, 2014\n\n - Added -c option to clear the screen before calling execvp(3)\n - Changed command line option '{}' to '/_'\n - Renamed Makefile.linux-lbsd to Makefile.debian\n - Include CPPFLAGS since some build systems (namely Debian) use it to specify\n   hardening options\n - Raise ARG_MAX from 4K to 2MB on Linux, since _SC_ARG_MAX returns an incorrect\n   value on Linux\n - Handle RENAME events that are not followed by DELETE. This enables us to cope\n   with the backup option in Vim\n\n== 2.5: December 30, 2013\n\n - Restore full 50ms period for consolidating events on Linux. Required for the\n   Geany editor\n - Remove use of setproctitle(3), no plans to implement this on Linux and MacOS\n   This also eliminates use of the 3-clause license\n - New feature: the first occurrence of '{}' on the command line will be\n   replaced with the name of the first file under watch\n - Set PAGER to an absolute path (/bin/cat)\n - Prevent interactive utilities from paging output\n\n== 2.4: December 18, 2013\n\n - Reintroduce ${DESTDIR} for STAGEDIR installation on FreeBSD and pkgsrc\n - License file describes the copyright holders for the compatibility libraries\n\n== 2.3: December 12, 2013\n\n - Wait for processes to terminate in restart mode\n - Set process title for blocking events\n - Correct multiple bugs in the inotify->kqueue translation layer\n - Print out detailed instructions if the user provides configure arguments\n - Remove ${DESTDIR} from Makefile which appears to interfere with OpenBSD ports\n - The handler for SIGSEGV prints file name and line number if a unit test fails\n - Reduce the number of attempts to re-open files to 10 (total of 1 second)\n - Define architecture in Makefile instead of testing for __linux or __APPLE__\n\n== 2.2: August 07, 2013\n\n - Process every delete or rename event to ensure files remain tracked\n - Always process DELETE or RENAME events to prevent a files from escaping watch\n - inotify(7) events are consolidated for a duration of 50ms as a workaround for\n   an apparent  bug in glib/gio where a file is written and then removed\n - Execute mode can run a file under watch by retrying if text file is busy\n - Exit non-zero if list of regular files exceeds the hard limit set by the\n   current login class\n - Ignore directories and special files; exit with error code 1 if no regular\n   files are provided as input\n\n== 2.1: July 01, 2013\n\n - Zero-dependency build on Linux using built-in compatibility layer\n - Add poll with optional timeout in order to prevent change events from\n   accumulating while running a command\n - Invalidate file->fd after inotify event is closed. Do not respond to\n   IN_MOVE_SELF since this event only occurs on Linux NFS mounts\n - Optional build on GNU/Linux using external compatibility libraries libkqueue\n   and libbsd\n - Fix bug in finding the correct filename to write to a FIFO\n - Correct build on MacOS\n\n== 2.0: June 17, 2013\n\n - Support for old architectures without C99 support\n - More aggressively remove duplicate events\n - install/uninstall uses DESTDIR to be compatible with pkgsrc\n\n== 1.9: April 13, 2013\n\n - New auto-reload option ('-r')\n - Add a simple configure script, BSD is the default\n - Do not install directories...they should already exist\n - Man page installation path can be set with MANPATH. MacOS expects it to be\n   under /usr/local/share\n\n== 1.8: May 12, 2013\n\n - Ensure that losing a file under watch is results in an error\n\n== 1.7: November 20, 2012\n\n - Allocate an memory based on _SC_OPEN_MAX, not rl.rlim_max\n - Stat deleted file until success before running a command\n - Handle SIGTERM and remove named pipe on exit\n\n== 1.6: August 10, 2012\n\n - Separate makefile for Linux to make building easier\n - No need for pthreads on BSD\n - Respond to RENAME and LINK events to improve behavior on NFS\n\n== 1.5: July 29, 2012\n\n - Support interactive applications by opening a TTY\n - Successfully stat deleted files before running a command\n\n== 1.4: May 22, 2013\n\n - Added regression tests\n - Delete events instead of relying on implicit removal by close(2) for better\n   compatibility with libkqueue on Linux\n\n== 1.3: May 17, 2012\n\n - Added FIFO support\n - Use min(OPEN_MAX, rl.rlim_max) to be more compatible of Mac OS\n - More correct use of fgets(3) when reading STDIN\n\n== 1.2: April 26, 2012\n\n - Added support for Linux via libkqueue\n\n== 1.1: April 17, 2012\n\n - Added support for Mac OS\n\n== 1.0: April 12, 2012\n\n - Initial release at https://bitbucket.org/eradman/entr\n - Builds on all major BSD platforms\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.5341796875,
          "content": "Event Notify Test Runner\n========================\n\nA utility for running arbitrary commands when files change. Uses kqueue(2) or\ninotify(7) to avoid polling.  `entr` was written to facilitate rapid feedback\non the command line.\n\nSource Installation - BSD, Mac OS, and Linux\n--------------------------------------------\n\n    ./configure\n    make test\n    make install\n\nTo see available build options run `./configure -h`\n\nDocker and WSL\n--------------\n\nIncomplete inotify support on _Windows Subsystem for Linux_ and _Docker for Mac_\nmay cause `entr` to respond incorrectly. Setting the environment variable\n`ENTR_INOTIFY_WORKAROUND` enables `entr` to operate in these environments.\n\nLinux Features\n--------------\n\nSymlinks can be monitored for changes by setting the environment variable\n`ENTR_INOTIFY_SYMLINK`.\n\nMan Page Examples\n-----------------\n\nRebuild a project if source files change, limiting output to the first 20 lines:\n\n    $ find src/ | entr -s 'make | head -n 20'\n\nLaunch and auto-reload a node.js server:\n\n    $ ls *.js | entr -r node app.js\n\nClear the screen and run a query after the SQL script is updated:\n\n    $ echo my.sql | entr -cp psql -f /_\n\nRebuild project if a source file is modified or added to the src/ directory:\n\n    $ while sleep 0.1; do ls src/*.rb | entr -d make; done\n\nAuto-reload a web server, or terminate if the server exits\n\n    $ ls * | entr -rz ./httpd\n\nNews\n----\n\nNotification of new releases are provided by an\n[Atom feed](https://github.com/eradman/entr/releases.atom),\nand release history is covered in the [NEWS](NEWS) file.\n"
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 0.7978515625,
          "content": "#!/bin/sh\n\ntest_libc_features() {\n\tCFLAGS=\"-D_GNU_SOURCE\"\n\t: ${CC:=cc}\n\t2>/dev/null $CC -xc $CFLAGS -o /dev/null - <<-EOF\n\t#include <string.h>\n\tint main(void) {\n\t\tchar dst[4];\n\t\tstrlcpy(dst, \"1234\", sizeof dst);\n\t\treturn 0;\n\t}\n\tEOF\n}\n\ncopy_mk() {\n\tcmd=\"cp Makefile.$1 Makefile\"\n\techo \"+ $cmd\"; $cmd\n}\n\nusage() {\n\tcat <<-HELP\n\tUsage: configure [-h]\n\tExample: build a static binary and install to your home directory\n\n\t./configure\n\tCFLAGS=\"-static\" make\n\tPREFIX=\\$HOME/local make install\n\tHELP\n\texit 1\n}\n\nwhile [ $# -gt 0 ]; do\n\tcase $1 in\n\t\t-h) usage ;;\n\t\t *) echo \"configure: unused argument: $1\" ;;\n\tesac\n\tshift\ndone\n\ncase \"${TARGET_OS:-`uname`}\" in\n\tDarwin)\n\t\tcopy_mk macos\n\t\t;;\n\tFreeBSD)\n\t\tcopy_mk freebsd\n\t\t;;\n\tLinux)\n\t\ttest_libc_features && copy_mk linux || copy_mk linux-compat\n\t\t;;\n\t*)\n\t\tcopy_mk bsd\n\t\t;;\nesac\n"
        },
        {
          "name": "data.h",
          "type": "blob",
          "size": 0.9931640625,
          "content": "/*\n * Copyright (c) 2012 Eric Radman <ericshane@eradman.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/stat.h>\n\n#include <limits.h>\n\n/* data */\n\ntypedef struct {\n\tchar fn[PATH_MAX];\n\tint fd;\n\tint is_dir;\n\tint file_count;\n\tmode_t mode;\n\tino_t ino;\n} WatchFile;\n\n/* defined in entr.c */\nextern WatchFile **files;\n"
        },
        {
          "name": "entr.1",
          "type": "blob",
          "size": 5.3955078125,
          "content": ".\\\"\n.\\\" Copyright (c) 2012 Eric Radman <ericshane@eradman.com>\n.\\\"\n.\\\" Permission to use, copy, modify, and distribute this software for any\n.\\\" purpose with or without fee is hereby granted, provided that the above\n.\\\" copyright notice and this permission notice appear in all copies.\n.\\\"\n.\\\" THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n.\\\" WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n.\\\" MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n.\\\" ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n.\\\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n.\\\" ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n.\\\" OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n.\\\"\n.Dd February 2, 2024\n.Dt ENTR 1\n.Os\n.Sh NAME\n.Nm entr\n.Nd run arbitrary commands when files change\n.Sh SYNOPSIS\n.Nm\n.Op Fl acdnprsxz\n.Ar utility\n.Op Ar argument /_ ...\n.Sh DESCRIPTION\nA list of files provided on standard input, and the\n.Ar utility\nis executed using the supplied arguments if any of them change.\n.Nm\nwaits for the child process to finish before responding to subsequent file\nsystem events.\nA TTY is also opened before entering the watch loop in order to support\ninteractive utilities.\n.Pp\nThe arguments are as follows:\n.Bl -tag -width Ds\n.It Fl a\nRespond to all events which occur while the\n.Ar utility\nis running.\nWithout this option,\n.Nm\nconsolidates events in order to avoid looping.\nThis option has no effect in conjunction with the\n.Fl r\nflag.\n.It Fl c\nClear the screen before invoking the\n.Ar utility\nspecified on the command line.\nSpecify twice to erase the scrollback buffer.\n.It Fl d\nTrack the directories of regular files provided as input and exit if a new file\nis added.\nThis option also enables directories to be specified explicitly.\nIf specified twice, all new entries to a directory are recognized,\notherwise files with names beginning with\n.Ql \\&.\nare ignored.\n.It Fl n\nRun in non-interactive mode.\nIn this mode\n.Nm entr\ndoes not attempt to read from the TTY or change its properties.\n.It Fl p\nPostpone the first execution of the\n.Ar utility\nuntil a file is modified.\n.It Fl r\nReload a persistent child process.\nAs with the standard mode of operation, a\n.Ar utility\nwhich terminates is not executed again until a file system or keyboard event is\nprocessed.\n.Dv SIGTERM\nis used to terminate the\n.Ar utility\nbefore it is restarted.\nA process group is created to prevent shell scripts from masking signals.\n.Nm\nwaits for the\n.Ar utility\nto exit to ensure that resources such as sockets have been closed.\nControl of the TTY is not transferred to the child process.\n.It Fl s\nEvaluate the first argument using the interpreter specified by the\n.Ev SHELL\nenvironment variable.\n.It Fl x\nFormat custom exit status messages using a persistent\n.Xr awk 1\nprocess.\nThe path to the status script is defined by the environment variable\n.Ev ENTR_STATUS_SCRIPT .\nIf the status script does not exist,\n.Nm\nwill create an example.\nShell commands and file redirection is not permitted by default, but may be\nenabled by specifying\n.Fl x\ntwice.\n.It Fl z\nExit after the\n.Ar utility\ncompletes.\nWhen combined with\n.Fl r\nthe\n.Ar utility\nwill be restarted again only in response to commands or file system\nevents.\n.El\n.Pp\nThe first argument named\n.Ar /_\nis replaced with the absolute path of the first file to trigger an event.\nThe first file under watch is used as the default.\nIf the\n.Fl s\noption is used, the name of the first file to trigger an event can be read from\n.Va $0 .\n.Sh COMMANDS\n.Nm\nlistens for keyboard input and responds to the following commands:\n.Bl -tag -width <space>\n.It Aq Cm space\nExecute the utility immediately.\nIf the\n.Fl Cm r\noption is set this will terminate and restart the child process as if a file\nchange event had occurred.\n.It Cm q\nQuit; equivalent pressing\n.Aq Cm control-C .\n.El\n.Sh ENVIRONMENT\n.Bl -tag -width \"ENTR_ENVIRON\"\n.It Ev ENTR_STATUS_SCRIPT\nThe path to the exit status script enabled by the\n.Fl x\noption.\nBy default\n.Pa $HOME/.entr/status.awk\nis evaluated.\n.It Ev PAGER\nSet to\n.Pa /bin/cat\nby default\nto prevent interactive utilities from waiting for keyboard input if output does\nnot fit on the screen.\n.It Ev SHELL\nSpecify the shell to use with the\n.Fl s\nflag.\nThe default is\n.Pa /bin/sh .\n.It Ev EV_TRACE\nPrint file system event messages.\n.El\n.Sh EXIT STATUS\nIf the\n.Fl z\nflag is set and the\n.Ar utility\nis successfully executed, the status of the child process is returned.\nIf the child process was terminated by a signal, the exit status is the signal\nnumber plus 128.\n.Pp\n.Nm\nnormally returns one of the following values:\n.Pp\n.Bl -tag -width Ds -offset indent -compact\n.It 0\nNormal termination after receiving\n.Dv SIGINT\n.It 1\nNo regular files were provided as input or an error occurred\n.It 2\nA file was added to a directory and the directory watch option was specified\n.El\n.Sh EXAMPLES\nRebuild a project if source files change, limiting output to the first 20 lines:\n.Pp\n.Dl $ find src/ | entr -s 'make | head -n 20'\n.Pp\nLaunch and auto-reload a node.js server:\n.Pp\n.Dl $ ls *.js | entr -r node app.js\n.Pp\nClear the screen and run a query after the SQL script is updated:\n.Pp\n.Dl $ echo my.sql | entr -cp psql -f /_\n.Pp\nRebuild project if a source file is modified or added to the src/ directory:\n.Pp\n.Dl $ while sleep 0.1; do ls src/*.rb | entr -d make; done\n.Pp\nAuto-reload a web server, or terminate if the server exits\n.Pp\n.Dl $ ls * | entr -rz ./httpd\n"
        },
        {
          "name": "entr.c",
          "type": "blob",
          "size": 18.416015625,
          "content": "/*\n * Copyright (c) 2012 Eric Radman <ericshane@eradman.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <sys/param.h>\n#include <sys/resource.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n\n#include <sys/event.h>\n\n#include <dirent.h>\n#include <err.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <paths.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <termios.h>\n#include <time.h>\n#include <unistd.h>\n\n#include \"missing/compat.h\"\n\n#include \"data.h\"\n#include \"status.h\"\n\n/* events to watch for */\n\n#define NOTE_ALL NOTE_DELETE | NOTE_WRITE | NOTE_RENAME | NOTE_TRUNCATE | NOTE_ATTRIB\n\n/* shortcuts */\n\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n#define MEMBER_SIZE(S, M) sizeof(((S *) 0)->M)\n\n/* shared state */\n\nextern int optind;\npid_t status_pid;\nWatchFile **files;\n\n/* globals */\n\nWatchFile *leading_edge;\nint child_pid;\nint child_status;\nint terminating;\n\nint aggressive_opt;\nint clear_opt;\nint dirwatch_opt;\nint noninteractive_opt;\nint oneshot_opt;\nint postpone_opt;\nint restart_opt;\nint shell_opt;\nint status_filter_opt;\n\nint termios_set;\nstruct termios canonical_tty;\n\nstatic char *shell, *shell_base;\nstatic char *argv0, *argv0_base;\n\n/* forwards */\n\nstatic void usage();\nstatic void terminate_utility();\nstatic void handle_exit(int sig);\nstatic void proc_exit(int sig);\nstatic void print_child_status(int status);\nstatic int process_input(FILE *, WatchFile *[], int);\nstatic int set_options(char *[]);\nstatic int list_dir(char *);\nstatic void run_utility(char *[]);\nstatic void watch_file(int, WatchFile *);\nstatic int compare_dir_contents(WatchFile *);\nstatic void watch_loop(int, char *[]);\n\n/*\n * The Event Notify Test Runner\n * run arbitrary commands when files change\n */\nint\nmain(int argc, char *argv[]) {\n\tstruct rlimit rl;\n\tint kq;\n\tstruct sigaction act;\n\tint ttyfd;\n\tshort argv_index;\n\tint n_files;\n\tint i;\n\tstruct kevent evSet;\n\tint open_max;\n\n\t/* call usage() if no command is supplied */\n\tif (argc < 2)\n\t\tusage();\n\targv_index = set_options(argv);\n\n\tsigemptyset(&act.sa_mask);\n\n\t/* normally a user will exit this utility by do_execting Ctrl-C */\n\tact.sa_flags = SA_RESETHAND;\n\tact.sa_handler = handle_exit;\n\tif (sigaction(SIGINT, &act, NULL) != 0)\n\t\terr(1, \"Failed to set SIGINT handler\");\n\tif (sigaction(SIGTERM, &act, NULL) != 0)\n\t\terr(1, \"Failed to set SIGTERM handler\");\n\tif (sigaction(SIGHUP, &act, NULL) != 0)\n\t\terr(1, \"Failed to set SIGHUP handler\");\n\n\t/* notification used to combine the one-shot and restart options */\n\tact.sa_flags = 0;\n\tact.sa_handler = proc_exit;\n\tif (sigaction(SIGCHLD, &act, NULL) != 0)\n\t\terr(1, \"Failed to set SIGCHLD handler\");\n\n#if defined(_LINUX_PORT)\n\t/* attempt to read inotify limits */\n\topen_max = (unsigned) fs_sysctl(INOTIFY_MAX_USER_WATCHES);\n\tif (open_max == 0)\n\t\topen_max = 65536;\n#elif defined(_MACOS_PORT)\n\tif (getrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\terr(1, \"getrlimit\");\n\topen_max = min(OPEN_MAX, rl.rlim_max);\n\trl.rlim_cur = open_max;\n\tif (setrlimit(RLIMIT_NOFILE, &rl) != 0)\n\t\terr(1, \"setrlimit cannot set rlim_cur to %u\", open_max);\n#else /* BSD */\n\tif (getrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\terr(1, \"getrlimit\");\n\topen_max = (unsigned) rl.rlim_max;\n\trl.rlim_cur = (rlim_t) open_max;\n\tif (setrlimit(RLIMIT_NOFILE, &rl) != 0)\n\t\terr(1, \"setrlimit cannot set rlim_cur to %u\", open_max);\n#endif\n\n\tif (getenv(\"EV_TRACE\"))\n\t\tfprintf(stderr, \"open_max: %d\\n\", open_max);\n\n\t/* prevent interactive utilities from paging output */\n\tsetenv(\"PAGER\", \"/bin/cat\", 0);\n\n\t/* ensure a shell is available to use */\n\tsetenv(\"SHELL\", \"/bin/sh\", 0);\n\n\tshell = getenv(\"SHELL\");\n\tshell_base = strdup(shell);\n\tif (shell_base == NULL)\n\t\terr(1, \"cannot duplicate string\");\n\tshell_base = basename(shell_base);\n\n\t/* initialize status filter */\n\tif (shell_opt)\n\t\targv0 = shell;\n\telse\n\t\targv0 = (argv + argv_index)[0];\n\targv0_base = basename(argv0);\n\tif (status_filter_opt)\n\t\tstart_log_filter(status_filter_opt);\n\n\t/* drop privileges */\n\tif (pledge(\"stdio rpath tty proc exec\", NULL) == -1)\n\t\terr(1, \"pledge\");\n\n\t/* sequential scan may depend on a 0 at the end */\n\tfiles = calloc(open_max + 1, sizeof(WatchFile *));\n\n\tif ((kq = kqueue()) == -1)\n\t\terr(1, \"cannot create kqueue\");\n\n\t/* expect file list from a pipe */\n\tif (isatty(fileno(stdin)))\n\t\tusage();\n\n\t/* read input and populate watch list, skipping non-regular files */\n\tn_files = process_input(stdin, files, open_max);\n\tif (n_files == 0)\n\t\terrx(1, \"No regular files to watch\");\n\tif (n_files == -1)\n\t\terrx(1,\n\t\t    \"Too many files listed; the hard limit for your login\"\n\t\t    \" class is %u. Please consult\"\n\t\t    \" http://eradman.com/entrproject/limits.html\",\n\t\t    open_max);\n\tfor (i = 0; i < n_files; i++)\n\t\twatch_file(kq, files[i]);\n\n\tif (!noninteractive_opt) {\n\t\t/* Attempt to open a tty so that editors don't complain */\n\t\tttyfd = open(_PATH_TTY, O_RDONLY);\n\t\tif (ttyfd > STDIN_FILENO) {\n\t\t\tif (dup2(ttyfd, STDIN_FILENO) != 0)\n\t\t\t\twarnx(\"can't dup2 to stdin\");\n\t\t\tclose(ttyfd);\n\t\t}\n\n\t\t/* remember terminal settings */\n\t\tif (tcgetattr(STDIN_FILENO, &canonical_tty) == -1)\n\t\t\terrx(1, \"unable to get terminal attributes, use '-n' to run non-interactively\");\n\n\t\t/* Use keyboard input as a trigger */\n\t\tEV_SET(&evSet, STDIN_FILENO, EVFILT_READ, EV_ADD, NOTE_LOWAT, 1, NULL);\n\t\tif (kevent(kq, &evSet, 1, NULL, 0, NULL) == -1)\n\t\t\twarnx(\"failed to register stdin\");\n\t}\n\n\twatch_loop(kq, argv + argv_index);\n\treturn 1;\n}\n\n/* Utility functions */\n\nvoid\nusage() {\n\tfprintf(stderr, \"release: %s\\n\", RELEASE);\n\tfprintf(stderr, \"usage: entr [-acdnprsxz] utility [argument [/_] ...] < filenames\\n\");\n\texit(1);\n}\n\nvoid\nterminate_utility() {\n\tint status;\n\n\tterminating = 1;\n\n\tif (child_pid > 0) {\n\t\tkillpg(child_pid, SIGTERM);\n\t\twaitpid(child_pid, &status, 0);\n\t\tchild_pid = 0;\n\t}\n\n\tterminating = 0;\n}\n\n/* Callbacks */\n\nvoid\nhandle_exit(int sig) {\n\tif ((!noninteractive_opt) && (termios_set))\n\t\ttcsetattr(STDIN_FILENO, TCSADRAIN, &canonical_tty);\n\n\tterminate_utility();\n\n\tif (status_filter_opt)\n\t\tend_log_filter();\n\n\tif ((sig == SIGINT || sig == SIGHUP))\n\t\t_exit(0);\n\telse\n\t\traise(sig);\n}\n\nvoid\nproc_exit(int sig) {\n\tint status;\n\tint saved_errno = errno;\n\n\tif (status_filter_opt && (terminating == 0)) {\n\t\tif (waitpid(status_pid, &status, WNOHANG) > 0) {\n\t\t\tif (WIFSIGNALED(status)) {\n\t\t\t\tterminating = 1;\n\t\t\t\twarnx(\"status process killed by signal\");\n\t\t\t\tkill(getpid(), SIGINT);\n\t\t\t}\n\t\t\tif (WIFEXITED(status)) {\n\t\t\t\tterminating = 1;\n\t\t\t\twarnx(\"status process terminated\");\n\t\t\t\tkill(getpid(), SIGINT);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (waitpid(child_pid, &status, 0) != -1) {\n\t\tchild_status = status;\n\n\t\tif ((!noninteractive_opt) && (termios_set))\n\t\t\ttcsetattr(STDIN_FILENO, TCSADRAIN, &canonical_tty);\n\n\t\tif ((oneshot_opt == 1) && (terminating == 0)) {\n\t\t\tif (restart_opt == 0)\n\t\t\t\tprint_child_status(child_status);\n\n\t\t\tif (WIFSIGNALED(child_status))\n\t\t\t\t_exit(128 + WTERMSIG(child_status));\n\t\t\telse\n\t\t\t\t_exit(WEXITSTATUS(child_status));\n\t\t}\n\t}\n\t/* restore errno so that the resuming code is unimpacted. */\n\terrno = saved_errno;\n}\n\nvoid\nprint_child_status(int status) {\n\tint len;\n\tchar buf[2048];\n\n\tif (status_filter_opt) {\n\t\tif (WIFSIGNALED(status))\n\t\t\tlen = snprintf(buf, sizeof(buf), \"signal|%d|%s\\n\", WTERMSIG(status), argv0_base);\n\t\telse\n\t\t\tlen = snprintf(buf, sizeof(buf), \"exit|%d|%s\\n\", WEXITSTATUS(status), argv0_base);\n\t\twrite_log_filter(buf, len);\n\t}\n}\n\n/*\n * Read lines from a file stream (normally STDIN).  Returns the number of\n * regular files to be watched or -1 if max_files is exceeded.\n */\nint\nprocess_input(FILE *file, WatchFile *files[], int max_files) {\n\tchar buf[PATH_MAX];\n\tchar *p, *path;\n\tint n_files = 0;\n\tstruct stat sb;\n\tint i, matches;\n\n\twhile (fgets(buf, sizeof(buf), file) != NULL) {\n\t\tif ((p = strchr(buf, '\\n')) != NULL)\n\t\t\t*p = '\\0';\n\t\tif (buf[0] == '\\0')\n\t\t\tcontinue;\n\n\t\tif (stat(buf, &sb) == -1) {\n\t\t\twarnx(\"unable to stat '%s'\", buf);\n\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISREG(sb.st_mode) != 0) {\n\t\t\tfiles[n_files] = malloc(sizeof(WatchFile));\n\t\t\tstrlcpy(files[n_files]->fn, buf, MEMBER_SIZE(WatchFile, fn));\n\t\t\tfiles[n_files]->is_dir = 0;\n\t\t\tfiles[n_files]->file_count = 0;\n\t\t\tfiles[n_files]->mode = sb.st_mode;\n\t\t\tfiles[n_files]->ino = sb.st_ino;\n\t\t\tn_files++;\n\t\t}\n\t\t/* also watch the directory if it's not already in the list */\n\t\tif (dirwatch_opt > 0) {\n\t\t\tif (S_ISDIR(sb.st_mode) != 0)\n\t\t\t\tpath = &buf[0];\n\t\t\telse if ((path = dirname(buf)) == 0)\n\t\t\t\terr(1, \"dirname '%s' failed\", buf);\n\t\t\tfor (matches = 0, i = 0; i < n_files; i++)\n\t\t\t\tif (strcmp(files[i]->fn, path) == 0)\n\t\t\t\t\tmatches++;\n\t\t\tif (matches == 0) {\n\t\t\t\tfiles[n_files] = malloc(sizeof(WatchFile));\n\t\t\t\tstrlcpy(files[n_files]->fn, path, MEMBER_SIZE(WatchFile, fn));\n\t\t\t\tfiles[n_files]->is_dir = 1;\n\t\t\t\tfiles[n_files]->file_count = list_dir(path);\n\t\t\t\tfiles[n_files]->mode = sb.st_mode;\n\t\t\t\tfiles[n_files]->ino = sb.st_ino;\n\t\t\t\tn_files++;\n\t\t\t}\n\t\t}\n\t\tif (n_files + 1 > max_files)\n\t\t\treturn -1;\n\t}\n\treturn n_files;\n}\n\nint\nlist_dir(char *dir) {\n\tstruct dirent *dp;\n\tDIR *dfd = opendir(dir);\n\tint count = 0;\n\n\tif (dfd == NULL)\n\t\terrx(1, \"unable to open directory: '%s'\", dir);\n\twhile ((dp = readdir(dfd)) != NULL)\n\t\tif ((dirwatch_opt == 2) || (dp->d_name[0] != '.'))\n\t\t\tcount++;\n\tclosedir(dfd);\n\treturn count;\n}\n\n/*\n * Evaluate command line arguments and return an offset to the command to\n * execute.\n */\nint\nset_options(char *argv[]) {\n\tint ch;\n\tint argc;\n\n\t/* read arguments until we reach a command */\n\tfor (argc = 1; argv[argc] != 0 && argv[argc][0] == '-'; argc++)\n\t\t;\n\twhile ((ch = getopt(argc, argv, \"acdnprsxz\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'a':\n\t\t\taggressive_opt = 1;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tclear_opt = clear_opt ? 2 : 1;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tdirwatch_opt = dirwatch_opt ? 2 : 1;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tnoninteractive_opt = 1;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tpostpone_opt = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\trestart_opt = 1;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tshell_opt = 1;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\tstatus_filter_opt = status_filter_opt ? 2 : 1;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\toneshot_opt = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tif (argv[optind] == 0)\n\t\tusage();\n\n\tif (status_filter_opt && restart_opt)\n\t\terrx(1, \"-r and -x may not be combined\");\n\n\tif ((shell_opt == 1) && (argv[optind + 1] != 0))\n\t\terrx(1, \"-s requires commands to be formatted as a single argument\");\n\treturn optind;\n}\n\n/*\n * Execute the program supplied on the command line. If restart was set\n * then send the child process SIGTERM and restart it.\n */\nvoid\nrun_utility(char *argv[]) {\n\tint pid;\n\tint i, m;\n\tint ret, status;\n\tstruct timespec delay = { 0, 1000000 };\n\tchar **new_argv;\n\tchar *p, *arg_buf;\n\tint argc;\n\n\tif (restart_opt == 1)\n\t\tterminate_utility();\n\n\tif (shell_opt == 1) {\n\t\t/* run argv[1] with a shell using the leading edge as $0 */\n\t\targc = 4;\n\t\targ_buf = malloc(ARG_MAX);\n\t\tnew_argv = calloc(argc + 1, sizeof(char *));\n\t\trealpath(leading_edge->fn, arg_buf);\n\t\tnew_argv[0] = shell;\n\t\tnew_argv[1] = \"-c\";\n\t\tnew_argv[2] = argv[0];\n\t\tnew_argv[3] = arg_buf;\n\t} else {\n\t\t/* clone argv on each invocation to make the implementation of more\n\t\t * complex substitution rules possible and easy\n\t\t */\n\t\tfor (argc = 0; argv[argc]; argc++)\n\t\t\t;\n\t\targ_buf = malloc(ARG_MAX);\n\t\tnew_argv = calloc(argc + 1, sizeof(char *));\n\t\tfor (m = 0, i = 0, p = arg_buf; i < argc; i++) {\n\t\t\tnew_argv[i] = p;\n\t\t\tif ((m < 1) && (strcmp(argv[i], \"/_\")) == 0) {\n\t\t\t\tp += strlen(realpath(leading_edge->fn, p));\n\t\t\t\tm++;\n\t\t\t} else\n\t\t\t\tp += strlcpy(p, argv[i], ARG_MAX - (p - arg_buf));\n\t\t\tp++;\n\t\t}\n\t}\n\n\tpid = fork();\n\tif (pid == -1)\n\t\terr(1, \"can't fork\");\n\n\tif (pid == 0) {\n\t\t/* 2J - erase the entire display\n\t\t * 3J - clear scrollback buffer\n\t\t * H  - set cursor position to the default\n\t\t */\n\t\tif (clear_opt == 1)\n\t\t\tprintf(\"\\033[2J\\033[H\");\n\t\tif (clear_opt == 2)\n\t\t\tprintf(\"\\033[2J\\033[3J\\033[H\");\n\t\tfflush(stdout);\n\n\t\t/* Set process group so subprocess can be signaled */\n\t\tif (restart_opt == 1) {\n\t\t\tsetpgid(0, getpid());\n\t\t\tclose(STDIN_FILENO);\n\t\t\topen(_PATH_DEVNULL, O_RDONLY);\n\t\t}\n\t\t/* wait up to 1 seconds for each file to become available */\n\t\tfor (i = 0; i < 10; i++) {\n\t\t\tret = execvp(new_argv[0], new_argv);\n\t\t\tif (errno == ETXTBSY)\n\t\t\t\tnanosleep(&delay, NULL);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret != 0)\n\t\t\terr(1, \"exec %s\", new_argv[0]);\n\t}\n\tchild_pid = pid;\n\n\tif (restart_opt == 0 && oneshot_opt == 0) {\n\t\tif (waitpid(child_pid, &status, 0) != -1)\n\t\t\tchild_status = status;\n\n\t\tprint_child_status(child_status);\n\t}\n\n\tfree(arg_buf);\n\tfree(new_argv);\n}\n\n/*\n * Wait for file to become accessible and register a kevent to watch it\n */\nvoid\nwatch_file(int kq, WatchFile *file) {\n\tstruct kevent evSet;\n\tint i = 0;\n\tstruct timespec delay = { 0, 100 * 1000000 };\n\n\t/* wait up to 1 second for file to become available */\n\tfor (;;) {\n#ifdef O_EVTONLY\n\t\tfile->fd = open(file->fn, O_RDONLY | O_CLOEXEC | O_EVTONLY);\n#else\n\t\tfile->fd = open(file->fn, O_RDONLY | O_CLOEXEC);\n#endif\n\t\tif (file->fd == -1) {\n\t\t\tif (i < 10)\n\t\t\t\tnanosleep(&delay, NULL);\n\t\t\telse {\n\t\t\t\twarn(\"cannot open '%s'\", file->fn);\n\t\t\t\tterminate_utility();\n\t\t\t\texit(1);\n\t\t\t}\n\t\t} else\n\t\t\tbreak;\n\t\ti++;\n\t}\n\n\tEV_SET(&evSet, file->fd, EVFILT_VNODE, EV_ADD | EV_CLEAR, NOTE_ALL, 0, file);\n\tif (kevent(kq, &evSet, 1, NULL, 0, NULL) == -1) {\n\t\tif (errno == ENOSPC)\n\t\t\terrx(1,\n\t\t\t    \"Unable to allocate memory for kernel queue.\"\n\t\t\t    \" Please consult\"\n\t\t\t    \" http://eradman.com/entrproject/limits.html\");\n\t\telse\n\t\t\terr(1, \"failed to register VNODE event\");\n\t}\n}\n\n/*\n * Wait for directory contents to stabilize\n */\nint\ncompare_dir_contents(WatchFile *file) {\n\tint i;\n\tstruct timespec delay = { 0, 100 * 1000000 };\n\n\t/* wait up to 0.5 seconds for file to become available */\n\tfor (i = 0; i < 5; i++) {\n\t\tif (list_dir(file->fn) == file->file_count)\n\t\t\treturn 0;\n\t\tnanosleep(&delay, NULL);\n\t}\n\treturn 1;\n}\n\n/*\n * Wait for events to and execute a command. Four major concerns are in play:\n *   leading_edge: Global reference to the first file to have changed\n *   reopen_only : Unlink or rename events which require us to spin while\n *                 waiting for the file to reappear. These must always be\n *                 processed\n *   collate_only: Changes that indicate that more events are likely to occur.\n *                 Watch for more events using a short timeout\n *   do_exec     : Delay execution until all events have been processed. Allow\n *                 the user to edit files while the utility is running without\n *                 any visible side-effects\n *   dir_modified: The number of files changed for a directory under watch\n */\nvoid\nwatch_loop(int kq, char *argv[]) {\n\tstruct kevent evSet;\n\tstruct kevent evList[32];\n\tint nev;\n\tWatchFile *file;\n\tint i;\n\tstruct timespec evTimeout = { 0, 1000000 };\n\tint reopen_only = !aggressive_opt;\n\tint collate_only = 0;\n\tint do_exec = 0;\n\tint dir_modified = 0;\n\tint leading_edge_set = 0;\n\tstruct stat sb;\n\tchar c;\n\tstruct termios character_tty;\n\n\tleading_edge = files[0]; /* default */\n\tif (postpone_opt == 0)\n\t\trun_utility(argv);\n\n\tif (!noninteractive_opt) {\n\t\t/* disabling/restore line buffering and local echo */\n\t\tcharacter_tty = canonical_tty;\n\t\tcharacter_tty.c_lflag &= ~(ICANON | ECHO);\n\t}\n\nmain:\n\tif (!noninteractive_opt) {\n\t\ttcsetattr(STDIN_FILENO, TCSADRAIN, &character_tty);\n\t\ttermios_set = 1;\n\t}\n\n\tif ((reopen_only == 1) || (collate_only == 1)) {\n\t\tnev = kevent(kq, NULL, 0, evList, 32, &evTimeout);\n\t} else {\n\t\tnev = kevent(kq, NULL, 0, evList, 32, NULL);\n\t\tdir_modified = 0;\n\t}\n\n\tif ((nev == -1) && (errno != EINTR))\n\t\twarn(\"kevent failed\");\n\n\t/* escape for test runner */\n\tif ((nev == -2) && (collate_only == 0))\n\t\treturn;\n\n\tfor (i = 0; i < nev; i++) {\n\t\tif (!noninteractive_opt && evList[i].filter == EVFILT_READ) {\n\t\t\tif (read(STDIN_FILENO, &c, 1) < 1) {\n\t\t\t\tEV_SET(&evSet, STDIN_FILENO, EVFILT_READ, EV_DELETE, NOTE_LOWAT, 0, NULL);\n\t\t\t\tif (kevent(kq, &evSet, 1, NULL, 0, NULL) == -1)\n\t\t\t\t\terr(1, \"failed to remove READ event\");\n\t\t\t} else {\n\t\t\t\tif (c == ' ')\n\t\t\t\t\tdo_exec = 1;\n\t\t\t\tif (c == 'q')\n\t\t\t\t\tkill(getpid(), SIGINT);\n\t\t\t}\n\t\t}\n\t\tif (evList[i].filter != EVFILT_VNODE)\n\t\t\tcontinue;\n\n\t\tfile = (WatchFile *) evList[i].udata;\n\t\tif (file->is_dir == 1)\n\t\t\tdir_modified += compare_dir_contents(file);\n\t}\n\tif (!noninteractive_opt)\n\t\ttcsetattr(STDIN_FILENO, TCSADRAIN, &canonical_tty);\n\n\tcollate_only = 0;\n\tfor (i = 0; i < nev; i++) {\n\t\tif (evList[i].filter != EVFILT_VNODE)\n\t\t\tcontinue;\n\t\tfile = (WatchFile *) evList[i].udata;\n\t\tif (evList[i].fflags & NOTE_DELETE || evList[i].fflags & NOTE_RENAME) {\n\t\t\tEV_SET(&evSet, file->fd, EVFILT_VNODE, EV_DELETE, NOTE_ALL, 0, file);\n\t\t\tif (kevent(kq, &evSet, 1, NULL, 0, NULL) == -1)\n\t\t\t\terr(1, \"failed to remove VNODE event\");\n#if !defined(_LINUX_PORT)\n\t\t\t/* free file descriptor no longer monitored by kqueue */\n\t\t\tif ((file->fd != -1) && (close(file->fd) == -1))\n\t\t\t\terr(1, \"unable to close file\");\n#endif\n\t\t\twatch_file(kq, file);\n\t\t\tcollate_only = 1;\n\t\t}\n\t}\n\tif (reopen_only == 1) {\n\t\treopen_only = 0;\n\t\tgoto main;\n\t}\n\n\tfor (i = 0; i < nev && reopen_only == 0; i++) {\n\n\t\tif (evList[i].filter != EVFILT_VNODE)\n\t\t\tcontinue;\n\t\tfile = (WatchFile *) evList[i].udata;\n\t\tif ((file->is_dir == 1) && (dir_modified == 0))\n\t\t\tcontinue;\n\n\t\tif (evList[i].fflags & NOTE_DELETE || evList[i].fflags & NOTE_WRITE\n\t\t    || evList[i].fflags & NOTE_RENAME || evList[i].fflags & NOTE_TRUNCATE) {\n\t\t\tif ((dir_modified > 0) && (restart_opt == 1))\n\t\t\t\tcontinue;\n\t\t\tdo_exec = 1;\n\t\t}\n\n\t\tif (evList[i].fflags & NOTE_ATTRIB && S_ISREG(file->mode) != 0\n\t\t    && stat(file->fn, &sb) == 0) {\n\t\t\tif (file->mode != sb.st_mode) {\n\t\t\t\tdo_exec = 1;\n\t\t\t\tfile->mode = sb.st_mode;\n\t\t\t}\n\t\t\tif (file->ino != sb.st_ino) {\n#if defined(_LINUX_PORT)\n\t\t\t\tdo_exec = 1;\n#endif\n\t\t\t\tfile->ino = sb.st_ino;\n\t\t\t}\n\t\t} else if (evList[i].fflags & NOTE_ATTRIB)\n\t\t\tcontinue;\n\n\t\tif ((leading_edge_set == 0) && (file->is_dir == 0) && (do_exec == 1)) {\n\t\t\tleading_edge = file;\n\t\t\tleading_edge_set = 1;\n\t\t}\n\n\t\tif (getenv(\"EV_TRACE\")) {\n\t\t\tfprintf(stderr, \"%d/%d: fflags: 0x%x %s %o %s\\n\", i, nev, evList[i].fflags,\n\t\t\t    file->is_dir ? \"d\" : \"r\", file->mode, file->fn);\n\t\t}\n\t}\n\n\tif (collate_only == 1)\n\t\tgoto main;\n\tif (do_exec == 1) {\n\t\tdo_exec = 0;\n\t\trun_utility(argv);\n\t\tif (!aggressive_opt)\n\t\t\treopen_only = 1;\n\t\tleading_edge_set = 0;\n\t}\n\tif (dir_modified > 0) {\n\t\tterminate_utility();\n\t\terrx(2, \"directory altered\");\n\t}\n\n\tgoto main;\n}\n"
        },
        {
          "name": "missing",
          "type": "tree",
          "content": null
        },
        {
          "name": "status.c",
          "type": "blob",
          "size": 3.0263671875,
          "content": "/*\n * Copyright (c) 2024 Eric Radman <ericshane@eradman.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include <err.h>\n#include <fcntl.h>\n#include <libgen.h>\n#include <limits.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/stat.h>\n\n#include \"missing/compat.h\"\n\n#include \"status.h\"\n\n/* globals */\nint status_stdin_pipe[2];\n\nvoid\nstart_log_filter(int safe) {\n\tchar *argv[8];\n\tchar *awk_script;\n\tstruct passwd *pw;\n\n\tawk_script = getenv(\"ENTR_STATUS_SCRIPT\");\n\tif ((!awk_script) || (strlen(awk_script) == 0)) {\n\t\tpw = getpwuid(getuid());\n\t\tasprintf(&awk_script, \"%s/.entr/status.awk\", pw->pw_dir);\n\t}\n\n\tcreate_dir(xdirname(awk_script));\n\tinstall_file(awk_script,\n\t    \"# http://eradman.com/entrproject/status-filters.html\\n\"\n\t    \"/^signal/ { print $3, \\\"terminated by signal\\\", $2; }\\n\"\n\t    \"/^exit/ { print $3, \\\"returned exit code\\\", $2; }\\n\");\n\n\targv[0] = \"/usr/bin/awk\";\n\targv[1] = \"-F\";\n\targv[2] = \"|\";\n\targv[3] = \"-f\";\n\targv[4] = awk_script;\n#if defined(_LINUX_PORT)\n\targv[5] = \"-S\";\n#else\n\targv[5] = \"-safe\";\n#endif\n\targv[6] = NULL;\n\tif (safe == 2)\n\t\targv[5] = NULL;\n\n\tpipe(status_stdin_pipe);\n\tstatus_pid = fork();\n\tif (status_pid == -1)\n\t\terr(1, \"fork\");\n\n\tif (status_pid == 0) {\n\t\tclose(status_stdin_pipe[1]);\n\t\tdup2(status_stdin_pipe[0], STDIN_FILENO);\n\t\texecvp(\"awk\", argv);\n\t\terr(1, \"could not exec %s\", argv[0]);\n\t}\n\tclose(status_stdin_pipe[0]);\n}\n\nvoid\nwrite_log_filter(char *input, size_t len) {\n\tif (write(status_stdin_pipe[1], input, len) == -1)\n\t\terr(1, \"write to child\");\n}\n\nvoid\nend_log_filter() {\n\tclose(status_stdin_pipe[1]);\n\tkill(status_pid, SIGKILL);\n}\n\n/*\n * xdirname - mimic dirname(3) on OpenBSD which does not modify input\n * create_dir - ensure a directory exists\n * install_file - create file is it does not exist\n */\n\nchar *\nxdirname(const char *path) {\n\tstatic char dname[PATH_MAX];\n\n\tstrlcpy(dname, path, sizeof(dname));\n\treturn dirname(dname);\n}\n\nvoid\ncreate_dir(const char *dir) {\n\tstruct stat dst_sb;\n\n\tif (stat(dir, &dst_sb) == -1)\n\t\tmkdir(dir, 0750);\n}\n\nvoid\ninstall_file(const char *dst, const char *content) {\n\tint fd;\n\tstruct stat dst_sb;\n\n\tif (stat(dst, &dst_sb) == -1) {\n\t\tprintf(\"entr: created '%s'\\n\", dst);\n\t\tfd = open(dst, O_WRONLY | O_CREAT, 0640);\n\t\tif (fd == -1)\n\t\t\terr(1, \"open\");\n\t\tif (write(fd, content, strlen(content)) == -1)\n\t\t\terr(1, \"write\");\n\t\tclose(fd);\n\t}\n}\n"
        },
        {
          "name": "status.h",
          "type": "blob",
          "size": 1.025390625,
          "content": "/*\n * Copyright (c) 2024 Eric Radman <ericshane@eradman.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nvoid start_log_filter(int safe);\nvoid write_log_filter(char *input, size_t len);\nvoid end_log_filter();\nchar *xdirname(const char *path);\nvoid create_dir(const char *dir);\nvoid install_file(const char *dst, const char *content);\n\nextern pid_t status_pid;\n"
        },
        {
          "name": "system_test.sh",
          "type": "blob",
          "size": 16.0546875,
          "content": "#!/bin/sh -u\n\ntrap '' ERR 2> /dev/null || exec bash $0 \"$@\"\n\n# test runner\n\nfunction try { let tests+=1; this=\"$1\"; }\n\nfunction assert {\n\t[[ \"$1\" == \"$2\" ]] && { printf \".\"; return; }\n\tprintf \"\\nFAIL: $this\\n'$1' != '$2'\\n\"\n\n\techo \"*************************************\"\n\techo \"System test directory contents:\"\n\t: | head -n 50 $(find $tmp -type f  ! -perm -111)\n\techo \"*************************************\"\n\texit 1\n}\nfunction skip { printf \"s\"; }\n\nfunction zz { sleep 0.25; }\nfunction setup {\n\trm -f $tmp/*\n\ttouch $tmp/file1 $tmp/file2\n\tunset ENTR_STATUS_SCRIPT\n}\ntmp=$(cd $(mktemp -d ${TMPDIR:-/tmp}/entr-system-test-XXXXXX); pwd -P)\ntsession=$(basename $tmp)\n\nlet tests=0\nclear_tty='test -t 0 && stty echo icanon'\nclear_tmux='tmux kill-session -t $tsession 2>/dev/null || true'\nclear_tmp='rm -rf $tmp'\ntrap \"$clear_tty; $clear_tmux; $clear_tmp\" EXIT\ntrap 'printf \"\\nTerminated by SIGINT at line $LINENO\\n\"; exit 1' INT\n\n# required utilities\n\nutils=\"file pgrep git vim tmux\"\nfor util in $utils; do\n\tp=$(command -pv $util) || {\n\t\techo \"ERROR: could not locate the '$util' utility\" >&2\n\t\techo \"System tests depend on the following: $utils\" >&2\n\t\texit 1\n\t}\ndone\n\nif [ $(uname) == 'Linux' ]; then\n\tdate | awk -S '{}' 2> /dev/null || {\n\t\techo \"ERROR: gawk required on Linux\"\n\t\texit 1\n\t}\nfi\n\n# local binary, non-interactive by default\nalias entr='./entr -n'\nalias entr_tty='./entr'\n\n# alias expansion is not enabled by default in non-interactive Bourne Again Shell (bash) sessions\ncommand -v shopt > /dev/null && shopt -s expand_aliases\n\n# fast tests\n\ntry \"no arguments\"\n\tentr 2> /dev/null || code=$?\n\tassert $code 1\n\ntry \"no input\"\n\tentr echo \"vroom\" 2> /dev/null || code=$?\n\tassert $code 1\n\ntry \"reload and clear options with no utility to run\"\n\tentr -r -c 2> /dev/null || code=$?\n\tassert $code 1\n\ntry \"empty input\"\n\techo \"\" | entr echo 2> /dev/null || code=$?\n\tassert $code 1\n\ntry \"no regular files provided as input\"\n\tmkdir $tmp/dir1\n\tls $tmp | entr echo 2> /dev/null || code=$?\n\trmdir $tmp/dir1\n\tassert $code 1\n\n# status message tests\n\ntry \"install default status script\"\n\tsetup\n\texport ENTR_STATUS_SCRIPT=\"$tmp/status.awk\"\n\tls $tmp/* | entr -zx true >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\twait $bgpid\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf \"entr: created '$tmp/status.awk'\\ntrue returned exit code 0\\n\")\"\n\ntry \"status script not compatible with restart option\"\n\tsetup\n\tls $tmp/* | entr -zrx true >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\twait $bgpid; assert \"$?\" \"1\"\n\ntry \"block unsafe status script\"\n\tsetup\n\texport ENTR_STATUS_SCRIPT=\"$tmp/status.awk\"\n\tcat > $ENTR_STATUS_SCRIPT <<-EOF\n\t{ system(\"date\") }\n\tEOF\n\tls $tmp/* | entr -zx true >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tsed -i -e \"s,.*awk: .*,awk: system is unsafe ... status.awk,\" $tmp/exec.err\n\tassert \"$(head -n1 $tmp/exec.err)\" \"awk: system is unsafe ... status.awk\"\n\tassert \"$(head -n1 $tmp/exec.out)\" \"\"\n\ntry \"allow unsafe status script\"\n\tsetup\n\texport ENTR_STATUS_SCRIPT=\"$tmp/status.awk\"\n\tcat > $ENTR_STATUS_SCRIPT <<-EOF\n\t{ system(\"date\") }\n\tEOF\n\tls $tmp/* | entr -zxx true >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tassert \"$(head -n1 $tmp/exec.err)\" \"\"\n\ntry \"use custom status script\"\n\tsetup\n\texport ENTR_STATUS_SCRIPT=\"$tmp/status.awk\"\n\tcat > $ENTR_STATUS_SCRIPT <<-'EOF'\n\t{\n\t  print \"=\", $1, $2, \"=\"\n\t}\n\tEOF\n\tls $tmp/* | entr -zx false >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf '= exit 1 =')\"\n\ntry \"use custom status script with shell option and kill\"\n\tsetup\n\texport ENTR_STATUS_SCRIPT=\"$tmp/status.awk\"\n\tcat > $ENTR_STATUS_SCRIPT <<-'EOF'\n\t{\n\t  print \"=\", $1, $2, \"=\"\n\t}\n\tEOF\n\tls $tmp/* | entr -zx -s 'kill -9 $$' >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf '= signal 9 =')\"\n\ntry \"abort if status script terminates\"\n\tsetup\n\texport ENTR_STATUS_SCRIPT=\"$tmp/status.awk\"\n\tcat > $ENTR_STATUS_SCRIPT <<-'EOF'\n\t{ exit; }\n\tEOF\n\tls $tmp/* | entr -x true >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tassert \"$(cat $tmp/exec.err)\" \"entr: status process terminated\"\n\tassert \"$(cat $tmp/exec.out)\" \"\"\n\n# terminal tests\n\nunset TMUX\n\ntry \"spacebar triggers utility\"\n\tsetup\n\tenv SHELL=/bin/sh tmux new-session -s $tsession -d\n\techo \"waiting\" > $tmp/file1\n\techo \"finished\" > $tmp/file2\n\ttmux send-keys -t $tsession:0 \\\n\t    \"ls $tmp/file2 | ./entr -p cp $tmp/file2 $tmp/file1\" C-m ; zz\n\tassert \"$(cat $tmp/file1)\" \"waiting\"\n\ttmux send-keys -t $tsession:0 \"xyz\" C-m ; zz\n\tassert \"$(cat $tmp/file1)\" \"waiting\"\n\ttmux send-keys -t $tsession:0 \" \" ; zz\n\tassert \"$(cat $tmp/file1)\" \"finished\"\n\ttmux send-keys -t $tsession:0 \"q\" ; zz\n\ttmux kill-session -t $tsession\n\n# file system tests\n\ntry \"exec a command using one-shot option\"\n\tsetup\n\tls $tmp/file2 | entr -zp cat $tmp/file2 >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\techo 456 >> $tmp/file2 ; zz\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(head -n1 $tmp/exec.out)\" \"$(printf '456\\n')\"\n\ntry \"exec a command using one-shot option and return signal number\"\n\tsetup\n\tls $tmp/file2 | entr -z sh -c 'kill -9 $$' >$tmp/exec.out 2>$tmp/exec.err\n\tassert \"$?\" \"137\"\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(cat $tmp/exec.out)\" \"\"\n\ntry \"exec a command using one-shot and shell options and return signal\"\n\tsetup\n\tls $tmp/file2 | entr -z -s 'kill -9 $$' >$tmp/exec.out 2>$tmp/exec.err\n\tassert \"$?\" \"137\"\n\tassert \"$(tail -c23  $tmp/exec.out)\" \"\"\n\ntry \"fail to exec a command using one-shot option\"\n\tsetup\n\tls $tmp/file* | entr -z /usr/bin/false_X 2>$tmp/exec.err\n\tassert \"$?\" \"1\"\n\ntry \"exec a command using one-shot option exit code from child\"\n\tsetup\n\tls $tmp/file* | entr -z sh -c 'exit 4' &\n\tbgpid=$! ; zz\n\twait $bgpid; assert \"$?\" \"4\"\n\ntry \"restart a server when a file is modified using one-shot option\"\n\tsetup\n\tif [ $(uname) == 'Linux' ]; then\n\t\tskip \"GNU nc spins while retrying SELECT(2); busybox does not support domain sockets\"\n\telse\n\t\tls $tmp/file2 | entr -rz nc -l -U $tmp/nc.s >> $tmp/exec.out &\n\t\tbgpid=$! ; zz\n\t\techo \"123\" | nc -NU $tmp/nc.s 2> /dev/null || {\n\t\t\techo \"123\" | nc -U $tmp/nc.s\n\t\t} ; zz\n\t\techo 456 >> $tmp/file2 ; zz\n\t\twait $bgpid; assert \"$?\" \"0\"\n\t\tassert \"$(cat $tmp/exec.out)\" \"123\"\n\tfi\n\ntry \"exec a command in non-intertive mode\"\n\tsetup\n\tls $tmp/file* | entr tty >$tmp/exec.out &\n\tbgpid=$! ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"not a tty\"\n\ntry \"exec a command as a background task and ensure stdin is closed\"\n\tsetup\n\tls $tmp/file* | entr -r sh -c 'test -t 0; echo $?; kill $$' >$tmp/exec.out &\n\tbgpid=$! ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"1\"\n\ntry \"exec a command as a background task, and verify that read from stdin doesn't complain\"\n\tsetup\n\tls $tmp/file* | entr -r sh -c 'read X' 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\ntry \"exec single shell utility and exit when a file is added to an implicit watch path\"\n\tsetup\n\tls $tmp/file* | entr -dp sh -c 'echo ping' >$tmp/exec.out 2>$tmp/exec.err \\\n\t    || true &\n\tbgpid=$! ; zz\n\ttouch $tmp/newfile\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"ping\"\n\tassert \"$(cat $tmp/exec.err)\" \"entr: directory altered\"\n\ntry \"exec single shell utility and exit when a subdirectory is added\"\n\tsetup\n\tls -d $tmp | entr -dp sh -c 'echo ping' >$tmp/exec.out 2>$tmp/exec.err \\\n\t    || true &\n\tbgpid=$! ; zz\n\tmkdir $tmp/newdir\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"ping\"\n\tassert \"$(cat $tmp/exec.err)\" \"entr: directory altered\"\n\trmdir $tmp/newdir\n\ntry \"exec single shell utility and exit when a hidden subdirectory is added\"\n\tsetup\n\tls -d $tmp | entr -ddp sh -c 'echo ping' >$tmp/exec.out 2>$tmp/exec.err \\\n\t    || true &\n\tbgpid=$! ; zz\n\tmkdir $tmp/.newdir\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"ping\"\n\tassert \"$(cat $tmp/exec.err)\" \"entr: directory altered\"\n\trmdir $tmp/.newdir\n\ntry \"exec single shell utility and exit when a file is added to a specific path\"\n\tsetup\n\tls -d $tmp | entr -dp sh -c 'echo ping' >$tmp/exec.out 2>$tmp/exec.err \\\n\t    || true &\n\tbgpid=$! ; zz\n\ttouch $tmp/newfile\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"ping\"\n\tassert \"$(cat $tmp/exec.err)\" \"entr: directory altered\"\n\ntry \"do nothing when a file not monitored is changed in directory watch mode\"\n\tsetup\n\tls $tmp/file2 | entr -dp echo \"changed\" >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\techo \"123\" > $tmp/file1\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"\"\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\ntry \"exec utility when a file is written by Vim in directory watch mode\"\n\tsetup\n\tls $tmp/file* | entr -dp echo \"changed\" >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\tvim -e -s -u NONE -N \\\n\t    -c \":r!date\" \\\n\t    -c \":wq\" $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"changed\"\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\ntry \"exec utility when a file is opened for write and then closed\"\n\tsetup\n\techo \"---\" > $tmp/file1\n\tls $tmp/file* | entr -p echo \"changed\" > $tmp/exec.out &\n\tbgpid=$! ; zz\n\t: > $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tif [ $(uname | grep -E 'Darwin|FreeBSD|DragonFly') ]; then\n\t\tskip \"NOTE_TRUNCATE not supported\"\n\telse\n\t\tassert \"$(cat $tmp/exec.out)\" \"changed\"\n\tfi\n\ntry \"exec single utility when an entire stash of files is reverted\"\n\tif [ ! -d /usr/include ]; then\n\t\tskip \"Operating system does not include files in a standard location\"\n\telse\n\t\tsetup\n\t\tcp /usr/include/*.h $tmp/\n\t\tcd $tmp\n\t\tgit init -q\n\t\tgit config --local user.email entr.test@example.com\n\t\tgit add *.h\n\t\tgit commit -m \"initial checkin\" -q\n\t\tfor f in `ls *.h | head`; do\n\t\t\tchmod 644 $f\n\t\t\techo \"\" >> $f\n\t\tdone\n\t\tcd - > /dev/null ; zz\n\t\tls $tmp/*.h | entr -p echo \"changed\" > $tmp/exec.out &\n\t\tbgpid=$! ; zz\n\t\tcd $tmp\n\t\tgit checkout *.h -q\n\t\tcd - > /dev/null ; zz\n\t\tkill -INT $bgpid\n\t\twait $bgpid; assert \"$?\" \"0\"\n\t\trm -rf $tmp/.git\n\t\tassert \"$(cat $tmp/exec.out)\" \"changed\"\n\tfi\n\ntry \"exec utility when a file is written by Vim\"\n\tsetup\n\tls $tmp/file* | entr -p echo \"changed\" > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tvim -e -s -u NONE -N \\\n\t    -c \":r!date\" \\\n\t    -c \":wq\" $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"changed\"\n\ntry \"exec shell utility when a file is written by Vim with 'backup'\"\n\tsetup\n\tls $tmp/file* | entr -p echo \"changed\" > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tvim -e -s -u NONE -N \\\n\t    -c \":set backup\" \\\n\t    -c \":r!date\" \\\n\t    -c \":wq\" $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"changed\"\n\ntry \"exec shell utility when a file is written by Vim with 'nowritebackup'\"\n\tsetup\n\tls $tmp/file* | entr -p echo \"changed\" > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tvim -e -s -u NONE -N \\\n\t    -c \":set nowritebackup\" \\\n\t    -c \":r!date\" \\\n\t    -c \":wq\" $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"changed\"\n\ntry \"restart a server when a file is modified\"\n\tsetup\n\techo \"started.\" > $tmp/file1\n\tls $tmp/file2 | entr -r tail -f $tmp/file1 2> /dev/null > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tassert \"$(cat $tmp/exec.out)\" \"started.\"\n\techo 456 >> $tmp/file2 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'started.\\nstarted.')\"\n\ntry \"ensure that all shell subprocesses are terminated in restart mode\"\n\tsetup\n\tcat <<-SCRIPT > $tmp/go.sh\n\t#!/bin/sh\n\ttrap 'echo \"caught signal\"; exit' TERM\n\techo \"running\"; sleep 10\n\tSCRIPT\n\tchmod +x $tmp/go.sh\n\tls $tmp/file2 | entr -r sh -c \"$tmp/go.sh\" 2> /dev/null > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tkill -INT $bgpid ; zz\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'running\\ncaught signal')\"\n\ntry \"ensure that all shell subprocesses are terminated when terminal is closed\"\n\tsetup\n\tcat <<-SCRIPT > $tmp/go.sh\n\t#!/bin/sh\n\ttrap 'echo \"caught signal\"; exit' TERM\n\techo \"running\"; sleep 10\n\tSCRIPT\n\tchmod +x $tmp/go.sh\n\tls $tmp/file2 | entr -r sh -c \"$tmp/go.sh\" 2> /dev/null > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tkill -HUP $bgpid ; zz\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'running\\ncaught signal')\"\n\ntry \"exit with no action when restart and dirwatch flags are combined\"\n\tsetup\n\techo \"started.\" > $tmp/file1\n\tls $tmp/file* | entr -rd tail -f $tmp/file1 2> /dev/null > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tassert \"$(cat $tmp/exec.out)\" \"started.\"\n\ttouch $tmp/newfile\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'started.')\"\n\ntry \"exec single shell utility when two files change simultaneously\"\n\tsetup\n\tln $tmp/file1 $tmp/file3\n\tls $tmp/file* | entr -p sh -c 'echo ping' > $tmp/exec.out &\n\tbgpid=$! ; zz\n\techo 456 >> $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"ping\"\n\ntry \"exec single shell utility on startup and when a file is changed\"\n\tsetup\n\tls $tmp/file* | entr sh -c 'printf ping' > $tmp/exec.out &\n\tbgpid=$! ; zz\n\techo 456 >> $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"pingping\"\n\ntry \"exec a command if a file is made executable\"\n\tsetup\n\tls $tmp/file* | entr -p echo /_ > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tchmod +x $tmp/file2 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"$tmp/file2\"\n\ntry \"ensure watches operate on a running executable\"\n\tsetup\n\tcp /bin/sleep $tmp/\n\tls $tmp/sleep | entr -rs \"echo 'vroom'; $tmp/sleep 30\" \\\n\t    > $tmp/exec.out 2> /dev/null &\n\tbgpid=$! ; zz\n\tcp -f /bin/sleep $tmp/ ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\trm -f $tmp/sleep\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'vroom\\nvroom\\n')\"\n\ntry \"exec a command using the first file to change\"\n\tsetup\n\tls $tmp/file* | entr -p cat /_ > $tmp/exec.out &\n\tbgpid=$! ; zz\n\techo 456 > $tmp/file1 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"456\"\n\ntry \"exec single shell utility using utility substitution\"\n\tsetup\n\tls $tmp/file1 $tmp/file2 | entr -p file /_ > $tmp/exec.out &\n\tbgpid=$! ; zz\n\techo 456 >> $tmp/file2; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"$tmp/file2: ASCII text\"\n\ntry \"watch and exec a program that is overwritten\"\n\tsetup\n\ttouch $tmp/script; chmod 755 $tmp/script\n\techo $tmp/script | entr -p $tmp/script $tmp/file1 > $tmp/exec.out &\n\tbgpid=$! ; zz\n\tcat > $tmp/script <<-EOF\n\t#!/bin/sh\n\techo vroom\n\tEOF\n\tzz ; kill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"vroom\"\n\ntry \"exec an interactive utility when a file changes\"\n\tsetup\n\tif ! test -t 0 ; then\n\t\tskip \"A TTY is not available\"\n\telse\n\t\tls $tmp/file* | entr_tty -p sh -c 'tty | cut -c1-9' 2> /dev/null > $tmp/exec.out &\n\t\tbgpid=$! ; zz\n\t\techo 456 >> $tmp/file2 ; zz\n\t\tkill -INT $bgpid\n\t\twait $bgpid; assert \"$?\" \"0\"\n\t\tassert \"$(cat $tmp/exec.out | tr '/pts' '/tty')\" \"/dev/tty\"\n\tfi\n\ntry \"exec a command using shell option\"\n\tsetup\n\tls $tmp/file* | entr -ps 'file $0; exit 2' >$tmp/exec.out 2>$tmp/exec.err &\n\tbgpid=$! ; zz\n\techo 456 >> $tmp/file2 ; zz\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(head -n1 $tmp/exec.out)\" \"$(printf ${tmp}'/file2: ASCII text')\"\n\ntry \"exec a command as a background task\"\n\tsetup\n\t(ls $tmp/file* | entr -ps 'echo terminating; kill $$' >$tmp/exec.out 2>$tmp/exec.err &)\n\tzz\n\techo 456 >> $tmp/file2 ; zz\n\tassert \"$(cat $tmp/exec.err)\" \"\"\n\tassert \"$(head -n1 $tmp/exec.out)\" \"terminating\"\n\n# extra slow tests that rely on timeouts\n\ntry \"respond to events that occur while the utility is running\"\n\tsetup\n\tls $tmp/file* | entr -a sh -c 'echo \"vroom\"; sleep 0.5' > $tmp/exec.out &\n\tbgpid=$! ; zz\n\techo \"123\" > $tmp/file1\n\tsleep 1\n\tkill -INT $bgpid\n\twait $bgpid; assert \"$?\" \"0\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'vroom\\nvroom\\n')\"\n\ntry \"ensure that all subprocesses are terminated in restart mode when a file is removed\"\n\tsetup\n\tcat <<-SCRIPT > $tmp/go.sh\n\t#!/bin/sh\n\ttrap 'echo \"caught signal\"; exit' TERM\n\techo \"running\"; sleep 10\n\tSCRIPT\n\tchmod +x $tmp/go.sh\n\tls $tmp/file2 | entr -r sh -c \"$tmp/go.sh\" 2> /dev/null > $tmp/exec.out &\n\tbgpid=$! ; zz\n\trm $tmp/file2; sleep 2\n\tpgrep -P $bgpid > /dev/null || assert \"$?\" \"1\"\n\tassert \"$(cat $tmp/exec.out)\" \"$(printf 'running\\ncaught signal')\"\n\nthis=\"exit 0\"\necho\necho \"$tests tests PASSED\"\n"
        }
      ]
    }
  ]
}