{
  "metadata": {
    "timestamp": 1736709905732,
    "page": 411,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "fukuchi/libqrencode",
      "stars": 2614,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.77734375,
          "content": "*.[oa]\n*.lo\n*.la\n*.gcno\n*.gcov\n*.gcda\n.deps/\n.libs/\nautom4te.cache/\nm4/\nCMakeLists.txt.user\nCMakeCache.txt\nCTestTestfile.cmake\nCMakeFiles/\ncmake_install.cmake\nMakefile\nMakefile.in\nREADME\nbuild\nconfig.log\nconfigure\nconfig.status\nconfig.h\nconfig.h.in\naclocal.m4\nlibtool\nstamp-h1\nqrencode\nqrencode.1\nlibqrencode.pc\ntests/create_frame_pattern\ntests/create_mqr_frame_pattern\ntests/pthread_qrencode\ntests/prof_qrencode\ntests/test_bitstream\ntests/test_estimatebit\ntests/test_mask\ntests/test_mmask\ntests/test_monkey\ntests/test_mqrspec\ntests/test_qrencode\ntests/test_qrinput\ntests/test_qrspec\ntests/test_rs\ntests/test_split\ntests/test_split_urls\ntests/view_qrcode\nuse/compile\nuse/config.guess\nuse/config.sub\nuse/depcomp\nuse/install-sh\nuse/ltmain.sh\nuse/missing\nuse/test-driver\nhtml/\nmassif.out.*\ngmon.out\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4619140625,
          "content": "dist: trusty\nsudo: required\nlanguage: c\n \ncompiler:\n- gcc\n\nbefore_install:\n- sudo apt-get update\n- sudo apt-get install libpng12-dev\n\ninstall:\n- ./autogen.sh\n- ./configure --with-tests && make\n- sudo make install\n- mkdir build && cd build\n- cmake .. -DWITH_TESTS=yes -DBUILD_SHARED_LIBS=on && make\n- DESTDIR=$PWD/install make install\n\nscript:\n- cd $TRAVIS_BUILD_DIR/tests\n- ./test_all.sh\n- cd $TRAVIS_BUILD_DIR/build/tests\n- cp $TRAVIS_BUILD_DIR/tests/frame ./\n- make test\n"
        },
        {
          "name": "CMakeLists.txt",
          "type": "blob",
          "size": 7.44921875,
          "content": "cmake_minimum_required(VERSION 3.1.0)\n\nproject(QRencode VERSION 4.1.1 LANGUAGES C)\n\noption(WITH_TOOLS \"Build utility tools\"  YES )\noption(WITH_TESTS \"Build tests\"  NO )\noption(WITHOUT_PNG \"Disable PNG support\" NO)\noption(GPROF \"Generate extra code to write profile information\" OFF)\noption(COVERAGE \"Generate extra code to write coverage information\" OFF)\noption(ASAN \"Use AddressSanitizer\" OFF)\noption(BUILD_SHARED_LIBS \"Enable build of shared libraries\" NO)\n\nif(BUILD_TESTING)\n    set(WITH_TESTS ON)\n    message(DEPRECATION \"use WITH_TESTS option instead BUILD_TESTING\")\nendif()\n\nlist(APPEND CMAKE_MODULE_PATH \"${CMAKE_CURRENT_SOURCE_DIR}/cmake\")\n\nset(CMAKE_THREAD_PREFER_PTHREAD ON)\nfind_package(Threads)\nfind_package(PNG)\nfind_package(Iconv)\n\nif(CMAKE_USE_PTHREADS_INIT)\n    add_definitions(-DHAVE_LIBPTHREAD=1)\n    # for libqrencode.pc\n    set(LIBPTHREAD ${CMAKE_THREAD_LIBS_INIT})\nendif()\n\n## Check for system include files\ninclude(CheckIncludeFile)\ninclude(CheckFunctionExists)\n\ncheck_include_file(dlfcn.h    HAVE_DLFCN_H   )\ncheck_include_file(inttypes.h HAVE_INTTYPES_H)\ncheck_include_file(memory.h   HAVE_MEMORY_H  )\ncheck_include_file(stdint.h   HAVE_STDINT_H  )\ncheck_include_file(stdlib.h   HAVE_STDLIB_H  )\ncheck_include_file(strings.h  HAVE_STRINGS_H )\ncheck_include_file(string.h   HAVE_STRING_H  )\ncheck_include_file(getopt.h   HAVE_GETOPT_H  )\ncheck_include_file(sys/time.h HAVE_SYS_TIME_H)\ncheck_include_file(time.h     HAVE_TIME_H    )\ncheck_include_file(pthread.h  HAVE_PTHREAD_H )\n\ncheck_function_exists(strdup HAVE_STRDUP)\n\nif(HAVE_STRDUP)\n    add_definitions(-DHAVE_STRDUP=1)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -Wall\")\nendif()\n\nif(GPROF)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -pg\")\nendif()\n\nif(COVERAGE)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} --coverage\")\nendif()\n\nif(ASAN)\n    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -fsanitize=address -fno-omit-frame-pointer -fno-optimize-sibling-calls\")\nendif()\n\nadd_definitions(-DMAJOR_VERSION=${PROJECT_VERSION_MAJOR})\nadd_definitions(-DMINOR_VERSION=${PROJECT_VERSION_MINOR})\nadd_definitions(-DMICRO_VERSION=${PROJECT_VERSION_PATCH})\nadd_definitions(-DVERSION=\"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\")\nadd_definitions(-DHAVE_SDL=0)\n\nif(MSVC)\n    set(CMAKE_DEBUG_POSTFIX \"d\")\n\n    add_definitions(-Dstrcasecmp=_stricmp)\n    add_definitions(-Dstrncasecmp=_strnicmp)\n    add_definitions(-D_CRT_SECURE_NO_WARNINGS)\n    add_definitions(-D_CRT_NONSTDC_NO_DEPRECATE)\n    \n    if(WITH_TOOLS)\n        find_path(GETOPT_INCLUDE_DIR getopt.h PATH_SUFFIXES include)\n        find_library(GETOPT_LIBRARIES getopt PATH_SUFFIXES lib)\n        include_directories(${GETOPT_INCLUDE_DIR})\n    endif(WITH_TOOLS)\nendif(MSVC)\n\nset(QRENCODE_SRCS qrencode.c\n                  qrinput.c\n                  bitstream.c\n                  qrspec.c\n                  rsecc.c\n                  split.c\n                  mask.c\n                  mqrspec.c\n                  mmask.c)\n\nset(QRENCODE_HDRS qrencode_inner.h\n                  qrinput.h\n                  bitstream.h\n                  qrspec.h\n                  rsecc.h\n                  split.h\n                  mask.h\n                  mqrspec.h\n                  mmask.h)\n\nif(BUILD_SHARED_LIBS)\n    if(MSVC)\n        set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)\n    endif()\n    add_library(qrencode SHARED ${QRENCODE_SRCS} ${QRENCODE_HDRS})\n    set_target_properties(qrencode PROPERTIES VERSION ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH} SOVERSION ${PROJECT_VERSION_MAJOR})\nelse()\n    add_library(qrencode ${QRENCODE_SRCS} ${QRENCODE_HDRS})\nendif()\nif(CMAKE_USE_PTHREADS_INIT)\n    target_link_libraries(qrencode Threads::Threads)\nendif()\n\ninclude(GNUInstallDirs)\nset(prefix \"${CMAKE_INSTALL_PREFIX}\")\nset(exec_prefix \"${CMAKE_INSTALL_FULL_BINDIR}\")\nset(libdir \"${CMAKE_INSTALL_FULL_LIBDIR}\")\nset(includedir \"${CMAKE_INSTALL_FULL_INCLUDEDIR}\")\nset(VERSION \"${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}\")\n\nconfigure_file(qrencode.1.in qrencode.1 @ONLY)\nconfigure_file(libqrencode.pc.in libqrencode.pc @ONLY)\n\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/qrencode.1 DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)\ninstall(FILES ${CMAKE_CURRENT_BINARY_DIR}/libqrencode.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)\ninstall(FILES qrencode.h DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})\ninstall(TARGETS qrencode DESTINATION ${CMAKE_INSTALL_LIBDIR})\n\n## Build utility tools\nif(WITH_TOOLS)\n    if(NOT WITHOUT_PNG)\n        add_definitions(-DHAVE_PNG=1)\n    endif()\n    add_executable(qrenc qrenc.c)\n    set_target_properties(qrenc PROPERTIES OUTPUT_NAME qrencode)\n\n    if(NOT WITHOUT_PNG)\n        target_link_libraries(qrenc qrencode PNG::PNG)\n    else()\n        target_link_libraries(qrenc qrencode)\n    endif()\n\n    if(MSVC)\n        target_link_libraries(qrenc ${GETOPT_LIBRARIES})\n    endif(MSVC)\n\n    install(TARGETS qrenc DESTINATION ${CMAKE_INSTALL_BINDIR})\nendif()\n\nif(WITH_TESTS)\n    enable_testing()\n    add_definitions(-DWITH_TESTS=)\n    add_definitions(-DSTATIC_IN_RELEASE=)\n    add_subdirectory(tests)\nelse()\n    add_definitions(-DSTATIC_IN_RELEASE=static)\nendif()\n\n## ==============================================================================\n##\n##  Configuration summary\n##\n## ==============================================================================\n\nmessage(STATUS \"------------------------------------------------------------\" )\nmessage(STATUS \"[QRencode] Configuration summary.\"                            )\nmessage(STATUS \"------------------------------------------------------------ \")\nmessage(STATUS \" System configuration:\"                                       )\nmessage(STATUS \" .. Processor type .............. = ${CMAKE_SYSTEM_PROCESSOR}\")\nmessage(STATUS \" .. CMake executable ............ = ${CMAKE_COMMAND}\"         )\nmessage(STATUS \" .. CMake version ............... = ${CMAKE_VERSION}\"         )\nmessage(STATUS \" .. System name ................. = ${CMAKE_SYSTEM}\"          )\nmessage(STATUS \" .. C++ compiler ................ = ${CMAKE_CXX_COMPILER}\"    )\nmessage(STATUS \" .. C compiler .................. = ${CMAKE_C_COMPILER}\"      )\nmessage(STATUS \" .. size(void*) ................. = ${CMAKE_SIZEOF_VOID_P}\"   )\nmessage(STATUS \" Dependencies:\"                                               )\n#message(STATUS \" .. Doxygen ..................... = ${DOXYGEN_EXECUTABLE}\"    )\nmessage(STATUS \" .. Thread library of the system  = ${CMAKE_THREAD_LIBS_INIT}\")\nmessage(STATUS \" .. Iconv ....................... = ${ICONV_FOUND}\"           )\nmessage(STATUS \" .... Iconv includes ............ = ${ICONV_INCLUDE_DIR}\"     )\nmessage(STATUS \" .... Iconv library ............. = ${ICONV_LIBRARIES}\"       )\nmessage(STATUS \" .. ZLIB ........................ = ${ZLIB_FOUND}\"            )\nmessage(STATUS \" .. PNG ......................... = ${PNG_FOUND}\"             )\nmessage(STATUS \" .... PNG includes .............. = ${PNG_INCLUDE_DIR}\"       )\nmessage(STATUS \" .... PNG library ............... = ${PNG_LIBRARIES}\"         )\n#message(STATUS \" .. Memory checker .............. = ${MEMORYCHECK_COMMAND}\"   )\nmessage(STATUS \" Project configuration:\"                                      )\nmessage(STATUS \" .. Build test programs  ........ = ${WITH_TESTS}\"            )\nmessage(STATUS \" .. Build utility tools  ........ = ${WITH_TOOLS}\"            )\nmessage(STATUS \" .. Disable PNG support  ........ = ${WITHOUT_PNG}\"           )\nmessage(STATUS \" .. Installation prefix ......... = ${CMAKE_INSTALL_PREFIX}\"  )\nmessage(STATUS \"------------------------------------------------------------ \")\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 25.9052734375,
          "content": "\n                  GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 2.1, February 1999\n\n Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n\t51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicenses are intended to guarantee your freedom to share and change\nfree software--to make sure the software is free for all its users.\n\n  This license, the Lesser General Public License, applies to some\nspecially designated software packages--typically libraries--of the\nFree Software Foundation and other authors who decide to use it.  You\ncan use it too, but we suggest you first think carefully about whether\nthis license or the ordinary General Public License is the better\nstrategy to use in any particular case, based on the explanations\nbelow.\n\n  When we speak of free software, we are referring to freedom of use,\nnot price.  Our General Public Licenses are designed to make sure that\nyou have the freedom to distribute copies of free software (and charge\nfor this service if you wish); that you receive source code or can get\nit if you want it; that you can change the software and use pieces of\nit in new free programs; and that you are informed that you can do\nthese things.\n\n  To protect your rights, we need to make restrictions that forbid\ndistributors to deny you these rights or to ask you to surrender these\nrights.  These restrictions translate to certain responsibilities for\nyou if you distribute copies of the library or if you modify it.\n\n  For example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou.  You must make sure that they, too, receive or can get the source\ncode.  If you link other code with the library, you must provide\ncomplete object files to the recipients, so that they can relink them\nwith the library after making changes to the library and recompiling\nit.  And you must show them these terms so they know their rights.\n\n  We protect your rights with a two-step method: (1) we copyright the\nlibrary, and (2) we offer you this license, which gives you legal\npermission to copy, distribute and/or modify the library.\n\n  To protect each distributor, we want to make it very clear that\nthere is no warranty for the free library.  Also, if the library is\nmodified by someone else and passed on, the recipients should know\nthat what they have is not the original version, so that the original\nauthor's reputation will not be affected by problems that might be\nintroduced by others.\n\f\n  Finally, software patents pose a constant threat to the existence of\nany free program.  We wish to make sure that a company cannot\neffectively restrict the users of a free program by obtaining a\nrestrictive license from a patent holder.  Therefore, we insist that\nany patent license obtained for a version of the library must be\nconsistent with the full freedom of use specified in this license.\n\n  Most GNU software, including some libraries, is covered by the\nordinary GNU General Public License.  This license, the GNU Lesser\nGeneral Public License, applies to certain designated libraries, and\nis quite different from the ordinary General Public License.  We use\nthis license for certain libraries in order to permit linking those\nlibraries into non-free programs.\n\n  When a program is linked with a library, whether statically or using\na shared library, the combination of the two is legally speaking a\ncombined work, a derivative of the original library.  The ordinary\nGeneral Public License therefore permits such linking only if the\nentire combination fits its criteria of freedom.  The Lesser General\nPublic License permits more lax criteria for linking other code with\nthe library.\n\n  We call this license the \"Lesser\" General Public License because it\ndoes Less to protect the user's freedom than the ordinary General\nPublic License.  It also provides other free software developers Less\nof an advantage over competing non-free programs.  These disadvantages\nare the reason we use the ordinary General Public License for many\nlibraries.  However, the Lesser license provides advantages in certain\nspecial circumstances.\n\n  For example, on rare occasions, there may be a special need to\nencourage the widest possible use of a certain library, so that it\nbecomes a de-facto standard.  To achieve this, non-free programs must\nbe allowed to use the library.  A more frequent case is that a free\nlibrary does the same job as widely used non-free libraries.  In this\ncase, there is little to gain by limiting the free library to free\nsoftware only, so we use the Lesser General Public License.\n\n  In other cases, permission to use a particular library in non-free\nprograms enables a greater number of people to use a large body of\nfree software.  For example, permission to use the GNU C Library in\nnon-free programs enables many more people to use the whole GNU\noperating system, as well as its variant, the GNU/Linux operating\nsystem.\n\n  Although the Lesser General Public License is Less protective of the\nusers' freedom, it does ensure that the user of a program that is\nlinked with the Library has the freedom and the wherewithal to run\nthat program using a modified version of the Library.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.  Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\".  The\nformer contains code derived from the library, whereas the latter must\nbe combined with the library in order to run.\n\f\n                  GNU LESSER GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License Agreement applies to any software library or other\nprogram which contains a notice placed by the copyright holder or\nother authorized party saying it may be distributed under the terms of\nthis Lesser General Public License (also called \"this License\").\nEach licensee is addressed as \"you\".\n\n  A \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\n  The \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms.  A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language.  (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n  \"Source code\" for a work means the preferred form of the work for\nmaking modifications to it.  For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control\ncompilation and installation of the library.\n\n  Activities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it).  Whether that is true depends on what the Library does\nand what the program that uses the Library does.\n\n  1. You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\n  You may charge a fee for the physical act of transferring a copy,\nand you may at your option offer warranty protection in exchange for a\nfee.\n\f\n  2. You may modify your copy or copies of the Library or any portion\nof it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) The modified work must itself be a software library.\n\n    b) You must cause the files modified to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    c) You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n\n    d) If a facility in the modified Library refers to a function or a\n    table of data to be supplied by an application program that uses\n    the facility, other than as an argument passed when the facility\n    is invoked, then you must make a good faith effort to ensure that,\n    in the event an application does not supply such function or\n    table, the facility still operates, and performs whatever part of\n    its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of the\n    application.  Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may opt to apply the terms of the ordinary GNU General Public\nLicense instead of this License to a given copy of the Library.  To do\nthis, you must alter all the notices that refer to this License, so\nthat they refer to the ordinary GNU General Public License, version 2,\ninstead of to this License.  (If a newer version than version 2 of the\nordinary GNU General Public License has appeared, then you can specify\nthat version instead if you wish.)  Do not make any other change in\nthese notices.\n\f\n  Once this change is made in a given copy, it is irreversible for\nthat copy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\n  This option is useful when you wish to copy part of the code of\nthe Library into a program that is not a library.\n\n  4. You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\n  If distribution of object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the\nsource code from the same place satisfies the requirement to\ndistribute the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  5. A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\".  Such a\nwork, in isolation, is not a derivative work of the Library, and\ntherefore falls outside the scope of this License.\n\n  However, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\".  The executable is therefore covered by this License.\nSection 6 states terms for distribution of such executables.\n\n  When a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library.  The\nthreshold for this to be true is not precisely defined by law.\n\n  If such an object file uses only numerical parameters, data\nstructure layouts and accessors, and small macros and small inline\nfunctions (ten lines or less in length), then the use of the object\nfile is unrestricted, regardless of whether it is legally a derivative\nwork.  (Executables containing this object code plus portions of the\nLibrary will still fall under Section 6.)\n\n  Otherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\f\n  6. As an exception to the Sections above, you may also combine or\nlink a \"work that uses the Library\" with the Library to produce a\nwork containing portions of the Library, and distribute that work\nunder terms of your choice, provided that the terms permit\nmodification of the work for the customer's own use and reverse\nengineering for debugging such modifications.\n\n  You must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License.  You must supply a copy of this License.  If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License.  Also, you must do one\nof these things:\n\n    a) Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library.  (It is understood\n    that the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n\n    b) Use a suitable shared library mechanism for linking with the\n    Library.  A suitable mechanism is one that (1) uses at run time a\n    copy of the library already present on the user's computer system,\n    rather than copying library functions into the executable, and (2)\n    will operate properly with a modified version of the library, if\n    the user installs one, as long as the modified version is\n    interface-compatible with the version that the work was made with.\n\n    c) Accompany the work with a written offer, valid for at least\n    three years, to give the same user the materials specified in\n    Subsection 6a, above, for a charge no more than the cost of\n    performing this distribution.\n\n    d) If distribution of the work is made by offering access to copy\n    from a designated place, offer equivalent access to copy the above\n    specified materials from the same place.\n\n    e) Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\n  For an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it.  However, as a special exception,\nthe materials to be distributed need not include anything that is\nnormally distributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\n  It may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system.  Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\f\n  7. You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n    a) Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other library\n    facilities.  This must be distributed under the terms of the\n    Sections above.\n\n    b) Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n  8. You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License.  Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License.  However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n  9. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n  10. Each time you redistribute the Library (or any work based on the\nLibrary), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties with\nthis License.\n\f\n  11. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Library at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Library by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Library.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply, and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  12. If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License\nmay add an explicit geographical distribution limitation excluding those\ncountries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  13. The Free Software Foundation may publish revised and/or new\nversions of the Lesser General Public License from time to time.\nSuch new versions will be similar in spirit to the present version,\nbut may differ in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation.  If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\f\n  14. If you wish to incorporate parts of the Library into other free\nprograms whose distribution conditions are incompatible with these,\nwrite to the author to ask for permission.  For software which is\ncopyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this.  Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n                            NO WARRANTY\n\n  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\f\n           How to Apply These Terms to Your New Libraries\n\n  If you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change.  You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms\nof the ordinary General Public License).\n\n  To apply these terms, attach the following notices to the library.\nIt is safest to attach them to the start of each source file to most\neffectively convey the exclusion of warranty; and each file should\nhave at least the \"copyright\" line and a pointer to where the full\nnotice is found.\n\n\n    <one line to give the library's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n\nAlso add information on how to contact you by electronic and paper mail.\n\nYou should also get your employer (if you work as a programmer) or\nyour school, if any, to sign a \"copyright disclaimer\" for the library,\nif necessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n  library `Frob' (a library for tweaking knobs) written by James\n  Random Hacker.\n\n  <signature of Ty Coon>, 1 April 1990\n  Ty Coon, President of Vice\n\nThat's all there is to it!\n\n\n"
        },
        {
          "name": "ChangeLog",
          "type": "blob",
          "size": 57.685546875,
          "content": "2020.09.28 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[hotfix]\n\t* qrinput.c, tests/test_estimatebit.c:\n\t  - Fixed a bug in the estimation of the Micro QR Code's data length\n\t    in QRinput_estimateBitStreamSizeOfEntry() has been fixed.\n\t  - Fixed a bug in the calculation of the Micro QR Code's data capacity in\n\t    QRinput_encodeBitStream().\n\t  - A test case to test the bugs above has been added.\n\t  - Level check failure in QRinput_new2() on Windows has been fixed.\n\t* Bumped version to 4.1.1.\n\n2020.08.29 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[release-4.1.0]\n\t* .github/workflows/{cmake,configure,cmake-windows}.yml:\n\t  - Github actions CI scripts have been added.\n\t* tests/test_bitstream.c:\n\t  - Fixed memory leak.\n\t* configure.ac, tests/{prof,pthread}_qrencode.c:\n\t  - Make configure to define HAVE_SYS_TIME_H in config.h.\n\t* CMakeLists.txt:\n\t  - 'wingetopt' has been replaced to 'getopt'.\n\t* qrencode.c, tests/test_qrencode.c:\n\t  - ECLEVEL check has been improved.\n\t* .gitignore:\n\t  - Added 'use/test-driver'.\n\n2020.08.28 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[develop]\n\t* Made a develoment branch.\n\t* test_qrspec.c:\n\t  - Typo fixes.\n\t* qrinput.[ch], tests/{test_qrencode.c, test_qrinput.c}:\n\t  - A precise boundary check has been introduced to\n\t    QRinput_estimateVersion(). (closes #160)\n\t* qrinput.c, qrencode.c, tests/test_qrencode.c, qrenc.c, qrencode.1.in:\n\t  - QRinput_encodeMode*() now throws ERANGE when encoding Micro QR Code\n\t    and an appropriate version number was not specified.\n\t  - Now Micro QR Code also allows auto version adjustment.\n\t* qrenc.c, qrencode.1.in:\n\t  - The synopsis has been improved. (Thanks to @jidanni) (closes #155)\n\t  - A new option '--strict-version' has been introduced.\n\t* split.c:\n\t  - A tail recursion has been eliminated. (Thanks to @4061N) (closes #144)\n\t* tests/*:\n\t  - All test programs are now TAP-ready. Now you can run all test programs\n\t    by 'make check'.(Thanks to @jtojnar) (closes #117)\n\t* qrinput.c:\n\t  - Return value was ignored. (Thanks to @xiaoyur347) (closed #143)\n\t* README.md, NEWS:\n\t  - Various documentation improvements and updates.\n\t[release-4.1.0]\n\t* Bumped version to 4.1.0.\n\t* qrencode.h:\n\t  - Document improvements.\n\t* qrenc.c, qrencode.1.in:\n\t  - Added 'UTF8i' and 'ANSIUTF8i' to the descriptions of the corresponding\n\t    options. (Thanks to @Khoyo) (merged #138)\n\n2020.02.23 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* CMakeLists.txt, README.md:\n\t  - Merged #158 (Thanks to @neheb):\n\t    - Fixed the compile-time issue of the environment without libpng.\n\n2020.02.23 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* README.md:\n\t  - Merged #151 (Thanks to @NancyLi1013):\n\t    - Added vcpkg installation instructions.\n\n2018.11.09 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* configure.ac, README.md:\n\t  - Merged #137 (Thanks to @abelbeck and @charmander):\n\t    - 'too many arguments' bug has been fixed.\n\n2018.07.28 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* CMakeLists.txt:\n\t  - Merged #133 (Thanks to @sdf5):\n\t    - Change CMAKE_SORUCE_DIR to CMAKE_CURRENT_SORUCE_DIR in\n\t\t  CMAKE_MODULE_PATH\n\n2018.06.14 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* qrenc.c, qrencode.1.in, README.md, NEWS:\n\t  - UTF8 mode now supports ANSI256 color. (Thanks to András Veres-\n\t    Szentkirályi)\n\n2018.06.07 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* CMakeLists.txt, tests/CMakeLists.txt:\n\t  - Merged #131 (Thanks to @mgorny):\n\t    - Update paths inside the pkg-config file to respect GNUInstallDirs.\n\t    - Improve pthread support for the main library when building via CMake.\n\t    - Always build libdecoder as static library.\n\n2018.06.06 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master, 4.0]\n\t* tests/Makefile.am:\n\t  - Add missing test_basic.sh to EXTRA_DIST. (merged #127) (Thanks to\n\t    @mgorny)\n\t* CMakeLists.txt:\n\t  - Use CMake GNUInstallDirs module to provide variables for configurable\n\t    install directories. (merged #128) (Thanks to @mgorny)\n\t[4.0]\n\t* configure.ac, CMakeLists.txt, README.md:\n\t  - Bumped version to 4.0.2.\n\t[master]\n\t* tests/{Makefile.am, CMakeLists.txt, test_qrspec.c}:\n\t  - Fix running test_qrspec when building out-of-source. (merged #129)\n\t    (Thanks to @mgorny)\n\n2018.06.04 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master, 4.0]\n\t* CMakeLists.txt:\n\t  - STATIC_IN_RELEASE is now set to \"static\" when WITH_TESTS is disabled.\n\t    (closes #126)\n\t  - Tabs expaned.\n\t[4.0]\n\t* configure.ac, CMakeLists.txt, README.md:\n\t  - Bumped version to 4.0.1.\n\n2018.06.02 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master, 4.0]\n\t* CMakeLists.txt:\n\t  - Added \"WITHOUT_PNG\" option that builds qrencode without PNG support.\n\t    (closes #125)\n\n2018.06.01 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master, 4.0]\n\t* README.md:\n\t  - Added some notes of how to use autogen.sh. (closes #122) (Thanks to\n\t    @thebunnyrules)\n\n2017.10.20 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* qrenc.c:\n\t  - Adds the --inline option, which omits the xml tag for SVG output.\n\t    (merged #110) (Thanks to @jp-bennett)\n\t  - Short option '-I' for '--inline' disabled.\n\t* qrencode.1.in:\n\t  - Added some missing descriptions.\n\t* README.md:\n\t  - Acknowledgments updated.\n\n2017.10.13 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master, 4.0]\n\t* qrencode.h:\n\t  - Fix build on windows with Visual Studio. (merged #108) (Thanks to\n\t    @Ation)\n\t[master]\n\t* README.md:\n\t  - libqrencode now advertised as a \"fast and compact\" library.\n\n2017.10.08 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* qrenc.c, qrinput.c, rsecc.c, tests/common.c, tests/decoder.c:\n\t  - Fixed some warnings. (closing #89 and #102)\n\n2017.10.06 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[master]\n\t* tests/test_{all,basic}.sh:\n\t  - All tests except test_configure.sh can be run by test_basic.sh now.\n\t  - test_all.sh activates test_basic.sh + test_configure.sh.\n\t  - test_basic.sh is better during active development, especially when you\n\t    gave additional options to configure script.\n\t* split.c, qrspec.c, mqrspec.c, mask.c, mmask.c, qrencode.c, qrinput.c,\n\t  rsecc.c, qrencode.c:\n\t  - Fixed some warnings. (closing #89 and #102)\n\n2017.10.05 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[4.0]\n\t* tests/test_{mask,mmask,qrspec,mqrspec,split_urls,qrencode}.c:\n\t  - Removed or commented out unused functions.\n\t  - Command line option introduced for verbose debug information.\n\n2017.10.02 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[4.0]\n\t* bitstream.h, qrencode.c, qrencode_inner.h:\n\t  - Memory alignment improved.\n\t* tests/test_qrencode.c:\n\t  - Error messages improved.\n\t* tests/{common.h datachunk.h, decoder.h, rscode.h, rsecc_decoder.h}:\n\t  - Reserved macro names are replaced.\n\t* bitstream.[ch]:\n\t  - Some variables' type changed from int to size_t. (closing #89 and\n\t    #102)\n\t* tests/common.[ch], tests/test_split_url.c:\n\t  - Fixed some warnings.\n\t* NEWS:\n\t  - Format fixes.\n\t* tests/test_mask.c:\n\t  - Fixed some warnings.\n\t* qrencode.h, qrinput.h, mqrspec.c:\n\t  - Comment format fixes.\n\t* various files in tests:\n\t  - Fixed some warnings.\n\t* tests/test_qrencode.c:\n\t  - Removed unused function.\n\t* tests/test_qrinput.c:\n\t  - Added a new test function.\n\n2017.09.29 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[4.0]\n\t* README.md:\n\t  - Format fixes.\n\t* rsecc.[ch]:\n\t  - Some variables' type changed from int to size_t. (closing #89 and\n\t    #102)\n\n2017.09.21 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t[4.0]\n\t* qrencode.1.in, NEWS:\n\t  - Release date has been updated.\n\t  - Documentation updated.\n\t* Version 4.0.0 has ben released.\n\n2017.09.11 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Read buffer is now allocated as a static array to avoid malloc().\n\t    Suppresses memory leak warnings. (Thanks to @c-273)\n\t* README.md:\n\t  - INSTALL and ACKNOWLEDGMENTS sections are updated.\n\t* makeREADME.sh:\n\t  - Now it removes the attention line for github.com users.\n\t* tests/test_qrenc.sh:\n\t  - Experimental test script for the command 'qrencode'.\n\t  - Dedicated to @c-273, who warned the possible memory leaks of qrencode.\n\t    (See #102)\n\t* qrencode.spec.in, Makefile.am, configure.ac:\n\t  - SPEC file has been removed. (closes #105)\n\t* Makefile.am:\n\t  - The generation rule for README has been improved.\n\t[4.0]\n\t* 4.0 branch has been started.\n\t* README.md:\n\t  - Version number added to the 1st line.\n\t  - Fixed the URL to the badge of Travis CI.\n\t[master]\n\t* qrencode.[ch]:\n\t  - Symbol data representation of QRcode object has been slightly changed.\n\t    This change does not affect to most applications.\n\t  - If your application uses bits other than the LSB, read the comments of\n\t    QRCode class carefully.\n\t* tests/test_qrencode.c:\n\t  - Modified correct pattern of a test referring non-LSB bits of QRCode.\n\t* tests/view_qrcode.c:\n\t  - Now you can identify the feature of modules by color.\n\n2017.09.07 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* *.[ch]:\n\t  - Copyright year updated for the next major update.\n\t* tests/test_configure.sh:\n\t  - Added some progress messages.\n\t* tests/test_all.sh:\n\t  - Added test_configure.sh to the list.\n\t* Makefile.am, tests/Makefile.am:\n\t  - Added some EXTRA_DIST files.\n\t  - Moved some EXTRA_DIST files from Makefile.am to tests/Makefile.am.\n\t* makeREADME.sh:\n\t  - Newly added.\n\t* configure.ac, CMakeLists.txt, README, README.md:\n\t  - Bumped version to 4.0.0, preparing for major update.\n\t* .travis.yml:\n\t  - Configuration improved.\n\t* Makefile.am, README:\n\t  - Added a new rule to generate README from README.md.\n\t  - README is no longer needed in the source tree.\n\t* .gitignore:\n\t  - Added 'CTestTestfile.cmake'.\n\t  - Added 'README'\n\t* README.md:\n\t  - Added Katsumi Saito, the contributor of SPEC file, has been added to\n\t    the section of ACKNOWLEDGMENTS. We apologize for this lack of\n\t\tacknowledgment.\n\n2017.09.06 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* mqrspec.h:\n\t  - Documentation update.\n\t* qrencode.[ch]:\n\t  - QRcode_clearCache() has been defined as a deprecated function for\n\t    backward compatibility.\n\t* qrenc.c:\n\t  - Copyright year updated.\n\t* NEWS, README, README.md:\n\t  - Documentation update.\n\t* use/config.rpath:\n\t  - Updated to the newer version bundled with gettext-0.19.8.1.\n\t* qrencode.1.in:\n\t  - Copyright year updated.\n\n2017.09.02 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Replaced AC_PROG_RANLIB with LT_INIT.\n\n2017.08.04 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* CMakeLists.txt:\n\t  - Getopt.h is checked only by WITH_TOOLS. (merged #101) (Thanks to\n\t    @KangLin)\n\t* README, README.md:\n\t  - ACKNOWLEDGMENTS has been updated.\n\n2017.03.15 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* ChangeLog, NEWS, TODO:\n\t  - Typos fixed. (merged #95) (Thanks to @jwilk)\n\t* README, README.md:\n\t  - ACKNOWLEDGMENTS has been updated.\n\t* README, README.md, qrenc.c, qrencode.1.in, qrencode.spec.in:\n\t  - The URI to the primary site has been updated. (http->https)\n\t* CMakeLists.txt:\n\t  - Add version of shared library. (merged #96) (Thanks to @vanillahsu)\n\n2017.02.05 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* README, README.md:\n\t  - Added some notes to compile test programs. (closes #93)\n\t* CMakeList.txt:\n\t  - Added BUILD_SHARED_LIBS option with MSVC export all. (merged #92)\n\t    (Thanks to @vilppuvuorinen)\n\n2017.02.03 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* CMakeLists.txt, cmake/FIND*.cmake, tests/CMakeLists.txt:\n\t  - Merged #91. (Thanks to @aleksey-nikolaev)\n\t  - CMake support has been improved greatly.\n\t* README, README.md:\n\t  - ACKNOWLEDGMENTS has been updated.\n\t  - Some text cleanups.\n\t* tests/frame, .gitignore:\n\t  - Empty frame data \"tests/frame\" has been included in the source tree.\n\t* .travis.yml\n\t  - Stopped creating empty frame data.\n\t  - Bug fix.\n\n2016.11.20 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* tests/test_qrinput.c, tests/test_qrspec.c:\n\t  - Some warnings suppresed.\n\n2016.11.17 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* CMakeLists.txt, tests/CMakeLists.txt, travis.yml, tests/common.h,\n\t  tests/decoder.c, .gitignore:\n\t  - Merged #85. (Thanks to @misery)\n\t* NEWS:\n\t  - Release note for version 4 has been updated.\n\n2016.09.19 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* qrenc.c, qrencode.c, split.c:\n\t  - Merged #82. (Thanks to @UniQP)\n\t  - Various code cleanups.\n\t* *.h:\n\t  - Removed double underscores (__) from macro names in include guards.\n\t    (follows C99 standard)\n\t* configure.ac, *.c:\n\t  - Renamed __STATIC macro to STATIC_IN_RELEASE. (follows C99 standard)\n\t* qrencode.c:\n\t  - Removed unnecessary 'extern' from some functions.\n\n2016.09.18 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* CMakeLists.txt:\n\t  - Merged #83. (Thanks to @misery)\n\t  - This allows CMake users building the library without configure script.\n\t    IF you are using incomplete UNIX-like environment and configure script\n\t\tdoes not work as expected, try CMake.\n\t* README, README.md:\n\t  - Added some notes about CMake.\n\n2016.05.18 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* acinclude.m4:\n\t  - iconv.m4 has been updated to serial 19.\n\t* configure.ac, Makefile.am, tests/Makefile.am:\n\t  - MinGW support has been improved.\n\t* README, README.md:\n\t  - ACKNOWLEDGMENTS has been updated.\n\t* qrencode.c:\n\t  - Memory leak bug fixed. (Closes #81. Thanks to @win32asm)\n\t* Various code cleanups. (Merged #72. Thanks to @UniQP)\n\n2016.05.15 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Merged pull-request #80. (Thanks to @EckoEdc)\n\t  - Add LDFLAGS for mingw compilation.\n\n2016.04.02 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* tests/common.h:\n\t  - Code refactoring.\n\t  - New debug functions have been added.\n\t* tests/decoder.[ch], tests/test_monkey.c:\n\t  - QRcode_extractBits() has been extended. This will be used later.\n\t* tests/decoder.[ch]:\n\t  - eccResult has been added to QRdata.\n\t  - Code refactoring.\n\t* tests/decoder.[ch], tests/datachunk.[ch], tests/Makefile.am:\n\t  - Code refactoring.\n\n2016.03.30 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* bitstream.[ch], tests/test_bitstream.c:\n\t  - Added new function BitStream_newWithBits() and tests for it.\n\t* tests/decoder.[ch], tests/test_monkey.c:\n\t  - Code refactoring.\n\n2016.03.29 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* tests/view_qrcode.c:\n\t  - Added mask=-2 mode for debug purpose.\n\t* bitstream.c, qrencode.c:\n\t  - Incorrect bit padding has been fixed. (Thanks to Yuji Ueno)\n\t* tests/test_bitstream.c, tests/test_qrencode.c:\n\t  - Incorrect bit padding has been fixed.\n\t* README:\n\t  - ACKNOWLEDGMENTS has been updated.\n\t* README.md:\n\t  - ACKNOWLEDGMENTS has been updated.\n\t  - Some missed contributors have been added to README.md.\n\n2016.02.21 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* configure.ac, tests/common.h, tests/view_qrcode.c:\n\t  - Migrated from SDL 1.2 to 2.0.\n\t* README, README.md:\n\t  - Improved the install instruction. (Thanks to Ronald Michaels)\n\n2015.11.04 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* qrspec.h, mqrspec.h:\n\t  - Typo fix. (Thanks to @qianchenglenger)\n\t* qrenc.c:\n\t  - Merged pull-request #74. (Thanks to @mgorny)\n\t  - Added support for UTF8i and ANSIUTF8i formats that provide reverse\n\t    mappings of UTF8 and ANSIUTF8 formats respective. This is useful for\n\t\tblack-on-white media.\n\t* configure.ac, Makefile.am, qrenc.c, rsecc.c:\n\t  - Added new configure option \"--without-png\". (closes #70)\n\n2015.05.13 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* mqrspec.c:\n\t  - Typo fix.\n\t* README, README.md:\n\t  - Text format improved.\n\t* NEWS:\n\t  - Slightly updated.\n\n2015.05.06 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - New option \"--svg-path\" has been added, that uses a single path\n\t    instead of multiple rectangles to draw the modules.\n\t\t(cherry-picked from #41) (Thanks to @Oblomov)\n\t* tests/test_qrenc.sh, tests/test_images/.gitignore:\n\t  - Added an unfinished test script for qrencode has been added.\n\n2015.05.05 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* qrencode.1.in, qrenc.c:\n\t  - Usage improved. (closes #62) (Thanks to @minus7)\n\t  - Typo fix. (Thanks to Ian Sweet (@Isweet))\n\t* README, README.md:\n\t  - The list of contributors updated: '@' prefix added for github\n\t    usernames.\n\t* qrenc.c:\n\t  - X Pixmap (XPM) support has been added. (closes #52)\n\t    (Thanks to @tklauser)\n\t* qrspec.h, mqrspec.h, qrencode.h:\n\t  - empty descriptions of some @params are filled.\n\t* rsecc.[ch], README:\n\t  - Short note about the credit has been improved.\n\t* Some code cleanups.\n\n2015.05.04 Kentaro Fukuchi <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Merge pull request #63 from tklauser/qrenc-array-overflow-fix\n\t  - qrenc: Fix array overrun in color_set (Thanks to @tklauser and\n\t    @win32asm)\n\t* split.c:\n\t  - Merge pull request #67 from siggi-heltau/patch-1\n\t  - The variable name \"new\" has been renamed to \"newstring\" because \"new\"\n\t    is a reserved word in C++. (Thanks to @siggi-heltau)\n\t* qrenc.c:\n\t  - Added -r option to read input data from a file in addition to STDIN\n\t    and the command line. (cherry-picked from #68)\n\t\t(Thanks to Robert Petersen)\n\t  - Typo fix. (cherry-picked from #68) (Thanks to Robert Petersen)\n\t  - long option \"readin\" has been changed to \"read-from\".\n\t* qrencode.1.in:\n\t  - Updated the usage.\n\t* README:\n\t  - Updated the list of contributors.\n\t* tests/Makefile.am\n\t  - Added URI_testset.inc to EXTRA_DIST.\n\t* .gitignore\n\t  - Added some patterns to ignore some generated files. (Thanks to\n\t    @tklauser, closes #64)\n\n2014.09.23 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* README, README.md:\n\t  - Some typo fixes. (Thanks to Danomi Manchego)\n\n2014.09.18 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* tests/view_qrcode.c:\n\t  - Rollbacked the previous change (6a4b2e3710b) around the main part.\n\t* rsecc.c:\n\t  - Some code cleanups.\n\t* tests/rsecc_decoder.[ch], tests/test_rs.c, Makefile.am:\n\t  - Syndrome checker has been added.\n\n2014.09.17 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Added \"-pthread\" option to CFLAGS. (Thanks to Danomi Manchego)\n\t* tests/Makefile.am:\n\t  - Removed explicit \"-lpthread\" which is not required anymore.\n\n2014.09.09 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* NEWS:\n\t  - Added an entry about 4.0.0. (not released yet)\n\t* mask.[ch], tests/test_mask.c:\n\t  - Run length calculation has been slightly improved.\n\t  - Reduce malloc calls.\n\t* qrspec.[ch], mqrspec.[ch]:\n\t  - Frame caches have been eliminated. It improves both memory efficiency\n\t    and performance... Wait, caches were completely meaningless? orz...\n\t* qrencode.[ch]:\n\t  - QRcode_clearCache() has been eliminated.\n\t* tests/prof_qrencode.c, tests/pthread_qrencode.c, tests/test_mask.c,\n\t  tests/test_mmask.c, tests/test_monkey.c, tests/test_mqrspec.c,\n\t  tests/test_qrencode.c, tests/test_qrspec.c:\n\t  - Removed cache clearing calls.\n\t* qrencode.c:\n\t  - FrameFiller now allocated in stack, not heap.\n\t* rsecc.c:\n\t  - Introduced mutex to avoid race condition.\n\n2014.09.08 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Added color support for EPS output.\n\n2014.08.18 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Added new option \"--enable-asan\" that enables AddressSanitizer.\n\n2014.08.15 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* tests/view_qrcode.c:\n\t  - Version number check improved for Micro QR Code.\n\n2014.08.05 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* configure.ac, Makefile.am, tests/Makefile.am:\n\t  - Added some conditional flags for configuration/building process.\n\t  - HAVE_PNG and HAVE_SDL can be referred from both Makefile and program\n\t    code.\n\t* tests/view_qrcode.c:\n\t  - Use SDL_WaitEvent() instead of SDL_PollEvent().\n\t* tests/common.h:\n\t  - Added show_QRcode() for testing purposes. (Thanks to Sunil Maganally)\n\t* tests/*.c:\n\t  - main()'s arguments now correctly declared.\n\n2014.07.25 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* tests/URI_testset.inc, tests/test_split_urls.c, tests/Makefile.am,\n\t  .gitignore:\n\t  - A new test suite evaluating splitting efficiency has been added.\n\t  - Still undertrial.\n\n2014.07.24 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Code refactoring (QRinput_Struct_count has been added).\n\t  - And more code cleanups.\n\t  - Avoid to add a Structued-append chunk when only one symbol is\n\t    generated. (Thanks to Yoshimichi Inoue)\n\t* tests/test_qrinput.c:\n\t  - New test has been added.\n\t* qrinput.c, qrencode.1.in:\n\t  - Added new option, \"verbose\".\n\t* tests/common.h:\n\t  - printQRinputStruct() has been added.\n\t* rsecc.{c,h}:\n\t  - Copyright notice and credit has been corrected.\n\t* README, README.md:\n\t  - ACKNOWLEDGMENTS updates.\n\t[3.4]\n\t  - Bumped version to 3.4.4.\n\t* Version 3.4.4 has ben released.\n\n2014.07.08 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c, qrinput.c, tests/test_qrinput.c:\n\t  - Code cleanups.\n\t  - Some possible minor bugs has been fixed.\n\n2014.07.07 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Serious typo fix.\n\n2014.07.06 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c, qrencode.1.in:\n\t  - Added a new image type PNG32 (direct color mode). (Thanks to Greg Hart)\n\n2014.07.04 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* use/config.rpath:\n\t  - Updated to the newer version bundled with gettext-0.18.3.2.\n\t* acinclude.m4:\n\t  - Added iconv.m4, lib-{link,ld,prefix}.m4 for Mac OS.\n\t* autogen.sh:\n\t  - mkdir m4 if not exist.\n\t* qrencode.h:\n\t  - Fixed some doxygen commands.\n\n2014.06.27 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c, qrencode.1.in:\n\t  - Merged pull-request #44. (Thanks to Antenore)\n\t  - Fixed some format issues.\n\n2014.06.22 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrencode.c:\n\t  - A memory leak bug has been fixed. (Thanks to @win32asm)\n\t* bitstream.c:\n\t  - Check return value of BitStream_expand. (PR #46, Thanks to @tklauser)\n\n2014.02.14 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Minor documentation fix.\n\t* qrenc.c:\n\t  - Error message improved.\n\n2014.02.09 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* .travis.yaml:\n\t  - Configuration file for Travis CI. (Thanks to Danil Dörrhöfer)\n\t* configure.ac:\n\t  - Fixed some warnings.\n\n2014.01.15 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Merged pull request 78d44fd - commandline argument --help and -V is\n\t    printed to stdout, instead of stderr.\n\n2014.01.04 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* rsecc.[ch]:\n\t  - Code cleanups.\n\n2013.10.27 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Bug in QRinput_insertFNC1Header() has been fixed. (Thanks to David\n\t    Binderman)\n\t* qrinput.c, test/decoder.[ch]:\n\t  - Code cleanup.\n\n2013.09.08 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* tests/test_qrencode.c:\n\t  - Small bug fix.\n\n2013.09.06 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - bzero() has been replaced with memset(). (Thanks to Gavin Andresen)\n\t* qrspec.c, qrinput.c:\n\t  - QRspec_getMinimumVersion() now returns maximum version number for\n\t    excessive input, instead of -1. Closes #31. (Thanks to Danil\n\t\tDörrhöfer)\n\t* tests/test_qrencode.c:\n\t  - New tests for excessive or maximum input have been added.\n\t* tests/test_qrinput.c:\n\t  - A deprecatd test has been removed.\n\t[reduce_malloc]\n\t* bitstream.c:\n\t  - Minimum length of bit buffer has been extended to 128. In many cases\n\t    the library needs 128 bits at least to generate a symbol.\n\t[master]\n\t* merged reduce_malloc branch.\n\n2013.08.22 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Avoid to use sdl-config. (Thanks to Heiko Becker)\n\n2013.08.15 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* rsecc.[ch], qrencode.c, tests/test_rc.c:\n\t  - Code cleanups and refactoring.\n\t  - Bug fix.\n\t* configure.ac:\n\t  - Bumped version to 3.9.0, preparing for major update.\n\t* qrenc.c:\n\t  - Copyright year in usage has been updated.\n\t  - Help message improved.\n\n2013.08.15 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* rsecc.[ch], rscode.[ch], Makefile.am, qrencode.c:\n\t  - Reed-Solomon error correction code has been completely rewritten.\n\t  - Phil Karn's code has been removed (moved to tests).\n\t* tests/test_rs.c, tests/test_qrencode.c, tests/rscode.[ch], tests/Makefile.am:\n\t  - Test codes related to ECC have been updated.\n\t  - Phil Karn's code has been moved to tests, just for test purpose.\n\t* tests/test_mqrspec.c:\n\t  - Code cleanup.\n\n2013.07.29 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4]\n\t* configure.ac, README, NEWS:\n\t  - Bumped version to 3.4.3.\n\n2013.07.16 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - missing break in switch. (Thanks to ßlúèÇhîp)\n\t* qrinput.c:\n\t  - missing/redundant breaks in some switch statements.\n\n2013.06.17 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Merged pull request #29. (Thanks to Daniel Dörrhöfer)\n\t    - Run length encoding has been made non-default.\n\t    - New option \"--rle\" has been instroduced to enable run length encoding\n\t      for SVG format.\n\n2013.03.30 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Renamed a variable (\"index\") to avoid compile-time warning. (Thanks to\n\t    Emmanuel Blot)\n\t  - Range check improved.\n\t* autogen.sh:\n\t  - bug fix.(Thanks to Emmanuel Blot)\n\n2013.03.26 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Memory leak bug has been fixed. (Thanks to Hassan Hajji)\n\t  - Buffer overrun bug has been fixed.\n\t  - Code cleanups.\n\n2013.03.01 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* README, NEWS:\n\t  - Documentation update.\n\t* Version 3.4.2 has been released.\n\n2013.02.26 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* split.c, tests/test_split.c:\n\t  - Applied Viona's bug fix patch. (Thanks to Viona)\n\t  - Additional switching cost between AN and Num mode has been included\n\t    correctly.\n\t  - Additional switching cost between 8 and AN/Num mode has been included\n\t    correctly.\n\t  - New test case has been added.\n\n2013.02.16 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4, master]\n\t* configure.ac, README, NEWS:\n\t  - Bumped version to 3.4.2.\n\n2013.02.16 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Now it includes \"string.h\" by itself for libpng16. (Thanks to Petr)\n\n2012.11.30 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrencode.h\n\t  - Doxygen documents improved.\n\n2012.11.09 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Code cleanup.\n\n2012.11.08 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Memory leak bug has been fixed. (issue #24) (Thanks to chisj)\n\t* qrencode.c:\n\t  - Incorrect bit extraction bug in QRcode_encodeMaskMQR() has been fixed.\n\t    (issue #25) (Thanks to vlad417)\n\t* tests/test_qrencode.c:\n\t  - Added NUL checks for malloc-related bugs using failmalloc.\n\t  - Added a new test for issue #25. (Thanks to vlad417)\n\n2012.10.21 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Unnecessary \"goto ABORT\" eliminated.\n\n2012.10.17 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4]\n\t* NEWS:\n\t  - Release note has been written.\n\t* Version 3.4.1 has been released.\n\n2012.10.15 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4]\n\t* configure.ac:\n\t  - HAVE_LIBPTHREAD was not correctly defined in config.h.in.\n\t* tests/test_configure.sh:\n\t  - New test script checking autoconf-related scripts has been added.\n\t* configure.ac, README, NEWS:\n\t  - Bumped version to 3.4.1.\n\n2012.10.15 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4]\n\t* Version 3.4.0 has been released.\n\t[master]\n\t* Merged 3.4.0.\n\n2012.10.13 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4]\n\t* qrencode.h:\n\t  - Documentation improved.\n\t  - Copyright year has been updated.\n\t* Doxyfile:\n\t  - Rebased on a template from Doxygen 1.7.6.1.\n\n2012.10.09 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.4]\n\t* configure.ac, README, NEWS:\n\t  - Bumped version to 3.4.0.\n\t* qrencode.1.in:\n\t  - Added SVG option to --type.\n\t* qrenc.c:\n\t  - Usage improved.\n\t  - Inkscape-friendly SVG output.\n\n2012.09.29 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[reduce_malloc]\n\t* bstream.h:\n\t  - Added a new function \"BitStream_reset()\".\n\t* qrinput.c:\n\t  - Reduced the use of dynamic memory allocation.\n\t  - Performance improved.\n\t  - Interfaces of QRinput_getBitStream() and QRinput_mergeBitStream() have\n\t    been changed.\n\n2012.09.25 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[reduce_malloc]\n\t* qrinput.c, tests/qrinput.c:\n\t  - Reduced the use of dynamic memory allocation.\n\n2012.09.25 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Input validation improved. (Thanks to Yann Droneaud)\n\t* README:\n\t  - Contributors list has been updated.\n\t  - Added a note about autogen.sh.\n\n2012.09.24 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* tests/test_bitstream.c:\n\t  - Added new test.\n\t* tests/test_{monkey,qrspec}.c:\n\t  - Warnings suppressed.\n\t[reduce_malloc]\n\t* bitstream.[ch]:\n\t  - Reduced the use of dynamic memory allocation.\n\n2012.09.22 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Color palette support has been added. Currently PNG and SVG are\n\t    supported\n\t* qrencode.1.in:\n\t  - \"--foreground\" and \"--background\" options have been added.\n\n2012.09.19 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* README:\n\t  - Contributors list has been updated.\n\t* qrencode.1.in:\n\t  - Followed Unicode block elements patch.\n\n2012.09.18 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Merge pull request #19 from mezcalero/master (Unicode block elements\n\t    support).\n\n2012.09.13 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Set XML(SVG) declaration's 'standalone' to 'yes'.\n\n2012.09.03 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - A bug introduced in 'b3d5f7' has been reverted. (Thanks to Terry)\n\n2012.09.03 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Integrated David's SVG patch.\n\n2012.04.21 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Incorrect arguments order has been fixed. (Thank to Fred Steinhaeuser)\n\n2012.04.18 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.3]\n\t* qrenc.c:\n\t  - EPS dot size bug has been fixed (closes: #12).\n\t* Version 3.3.1 has been released.\n\n2012.04.11 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[master]\n\t* qrenc.c:\n\t  - Paper size and margin are now set properly in SVG output.\n\n2012.04.10 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[master]\n\t* Following fixes have been contributed by Yutaka Niibe.\n\t* qrencode.1.in:\n\t  - \"Hyphen-used-as-minus-sign\" error has been fixed.\n\t* configure.ac, libqrencode.pc.in, tests/Makefile.am:\n\t  - Explicit link to libpthread has been eliminated.\n\t* qrenc.c:\n\t  - Pulled Repox's SVG patch (Pull request #10).\n\t  - Slightly simplified.\n\t[3.3]\n\t* README, configure.ac:\n\t  - Bumped version to 3.3.1.\n\n2012.04.01 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.3]\n\t* qrenc.c:\n\t  - ASCII mode has been added. (Thanks to Ralf Ertzinger)\n\t  - Small code cleanups.\n\t  - ASCII mode now handles \".txt\" suffix correctly.\n\t* NEWS, README:\n\t  - Documentation updates.\n\t* Version 3.3.0 has been released.\n\t[master]\n\t* Merged to 3.3.0.\n\n2012.03.31 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2]\n\t* README, NEWS, configure.ac:\n\t  - Bumped version to 3.2.1.\n\t* Version 3.2.1 has been released.\n\t[3.3]\n\t* qrenc.c:\n\t  - Copyright year has been updated.\n\n2012.03.30 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* libqrencode.pc.in :\n\t  - Replaced obsolete macro LIBPTHREAD with LIBS. (thx to gniibe)\n\t* configure.ac:\n\t  - Checks $ac_cv_lib_pthread_pthread_mutex_init instead of\n\t    HAVE_LIBPTHREAD. (thx to gniibe)\n\n2012.02.28 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[master, 3.2.1]\n\t* .gitignore:\n\t  - Added \"tests/pthread_qrencode\".\n\t[3.3]\n\t* 3.3 branch has been started.\n\t  - 3.2.1 has been canceled.\n\t* configure.ac, README, NEWS:\n\t  - Version number changes.\n\n2012.01.31 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[master]\n\t* Recent 3.2 branch has been merged into the master.\n\t* qrenc.c:\n\t  - Quick bug fix introduced in 09b72eb3070a36461eb83c1ec5237e4855ee515b.\n\n2012.01.19 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2.1]\n\t* configure.ac, qrencode.[hc], qrenc.c, tests/test_qrencode.c:\n\t  - QRcode_APIVersion() and QRcode_APIVersionString() have been added.\n\t  - New macro values {MAJOR,MINOR,MICRO}_VERSION have been introduced.\n\t  - New tests have been added.\n\t* qrenc.c:\n\t  - Removed a useless storage class specifier from enum imageType.\n\t[master, 3.2.1]\n\t* Pulled moshen:write_ansi.\n\t[3.2.1]\n\t* tests/decoder.c:\n\t  - Bug fix.\n\t* qrenc.c:\n\t  - Code refactoring.\n\t  - Now you can omit \"-o -\" for EPS and ANSI output.\n\t  - Default margin size has been rollbacked to 4 for ANSI(256).\n\t* README:\n\t  - Added Colin (moshen@github) to ACKNOWLEDGMENTS.\n\t  - Added zapster's real name to ACKNOWLEDGMENTS.\n\n2011.12.12 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2.1]\n\t* configure.ac, README:\n\t  - Bumped version to 3.2.1.\n\n2011.12.12 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c, qrencode.1.in:\n\t  - Usage updates.\n\n2011.12.11 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrenc.c:\n\t  - Pulled Zapster's EPS support patch.\n\t  - Some code cleanups.\n\n2011.11.26 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2.0]\n\t* qrencode.1.in:\n\t  - \"RESOURCES\" section has been added.\n\t* README:\n\t  - URL to the main web site updated.\n\t* Version 3.2.0 has been released.\n\n2011.11.23 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2.0]\n\t* qrencode.1.in:\n\t  - Added descriptions of \"-d\" and \"-M\".\n\n2011.11.3 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2.0]\n\t* tests/view_qrcode.c:\n\t  - Messages improved.\n\t* mmask.c:\n\t  - A bug in mask evaluation function has been eliminatd.\n\t* tests/test_mmask.c:\n\t  - New test case has been added.\n\t* qrenc.c:\n\t  - Micro QR Code support is now marked as \"experimental\" explicitly.\n\t* tests/test_qrinput.c, tests/test_qrencode.c:\n\t  - Added some test cases.\n\n2011.10.23 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t[3.2.0]\n\t* 3.2 branch has been started.\n\t* README, NEWS, configure.ac:\n\t  - Version number changes.\n\t  - Micro QR Code support is now marked as \"experimental\" explicitly.\n\n2011.10.23 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* mask.c, mmask.c, tests/common.h:\n\t  - Eliminated unused valiables.\n\t* tests/test_qrencode.c:\n\t  - Some assertions added.\n\n2011.10.18 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* test/test_mask.c:\n\t  - To call QRspec_clearCache() at exit.\n\n2011.10.17 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Now the latest PNG library is chosen when the configure script is\n\t    executed.\n\t* Copyright year has been updated.\n\n2011.10.17 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* mask.c:\n\t  - Unneeded zero-clear has been eliminated from Mask_calcRunLength().\n\t  - A rounding-down error in N4 calculation has been fixed.\n\t    (Thanks to Adam Shepherd)\n\t* tests/test_mask.c:\n\t  - Fixed some test cases.\n\n2011.10.17 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* mask.c:\n\t  - A bug in N3 penalty calculation functoin has been fixed.\n\t    (Thanks to Adam Shepherd)\n\t* mask.h, tests/test_mask.c:\n\t  - Test cases for Mask_calcN1N3() have been added.\n\t  - Wrong test cases have been corrected.\n\n2011.10.16 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* mask.[ch]:\n\t  - Mask_calcRunLength() has been refactored out from Mask_evaluateSymbol().\n\t* test/test_mask.c:\n\t  - New test code for Mask_calcRunLength has been added.\n\n2011.10.13 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* mask.[ch]:\n\t  - Mask_calcN2() has been refactored out from Mask_evaluateSymbol().\n\t* test/test_mask.c:\n\t  - New test code for Mask_calcN2 has been added.\n\t* README:\n\t  - Added a URL to the git repository.\n\n2011.08.13 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* configure.ac:\n\t  - Added \"AC_PROG_RANLIB\" (bug report from dev66)\n\n2011.08.07 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* libqrencode.pc.in:\n\t  - Cflags has been set. (issue #2)(Thanks to ryo-on)\n\n2011.05.05 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* split.c:\n\t  - strdup() code has been added for non-POSIX environments. (Thanks to\n\t    Seth Sims)\n\t* configure.ac:\n\t  - Added AC_CHECK_FUNC([strdup]) for non-POSIX environments.\n\t  - Now mudflapth is used instead of mudflap when pthread is enabled.\n\t* *.c:\n\t  - '#include \"config.h\"' has been moved to the top of the code and\n\t    wrapped with #if HAVE_CONFIG_H - #endif.\n\n2011.04.06 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* qrinput.c:\n\t  - Initializaion was missed in QRinput_insertFNC1Header().\n\n2011.02.09 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* tests/view_qrcode.c:\n\t  - \"-h\" had required an argument.\n\n2010.10.09 Kentaro FUKUCHI <kentaro@fukuchi.org>\n\t* Copyright year and mail address were updated.\n\t* README, qrencode.spec.in:\n\t  - The URL of qrencode's page has been updated.\n\t* Makefile.am:\n\t  - Added ACLOCAL_AMFLAGS.\n\t* use/config.rpath:\n\t  - Now explicitly included because required by AM_ICONV_LINK in\n\t    configure.ac.\n\n2010.02.03 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t[3.1.1]\n\t* qrencode.c, README:\n\t  - Copyright year updates.\n\t* Bumped version to 3.1.1.\n\t* Version 3.1.1 has been released.\n\n2010.01.27 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrinput.c, qrencode.h:\n\t  - 8bit encoding improved.\n\t  - QRinput_encodeModeECI(), QRinput_appendECIheader(),\n\t\tQRinput_estimateBitsModeECI() have been added.\n\t* tests/test_qrinput.c:\n\t  - Some tests for ECI header have been added.\n\t* qrinput.[ch]:\n\t  - STRUCTURE_HEADER_BITS was renamed to STRUCTURE_HEADER_SIZE.\n\t  - MODE_INDICATOR_SIZE has been added.\n\t  - QRinput_isSplittableMode() has been added.\n\t* qrspec.c:\n\t  - QRspec_maximumWords() now returns 0 if the entry cannot be split.\n\t  - Now includes \"qrinput.h\" for QRinput_isSplittableMode().\n\n2010.01.25 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.h:\n\t  - QR_MODE_{ECI,FNC1A,FNC1B} have been added to QRencodeMode.\n\t* qrspec.h, mqrspec.h, qrinput.c:\n\t  - QRSPEC_MODEID_* and MQRSPEC_MODEID_* have been added, and hard coded\n\t    numbers were replaced with them.\n\t* qrenc.c:\n\t  - Modified usage.\n\t* qrinput.h:\n\t  - Added a new field to QRinput for FNC1 support.\n\t* qrinput.c, qrencode.h:\n\t  - Added new functions to set FNC1 flag.\n\t  - FNC1 second position encoding now supported.\n\n2010.01.22 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* tests/test_qrspec.c:\n\t  - Code cleanup.\n\t* tests/decoder.[ch], tests/test_qrencode.c:\n\t  - Added tests for Micro QR Code.\n\n2010.01.20 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c:\n\t  - Bug fix.\n\t* tests/decoder.[ch]:\n\t  - Code refactoring.\n\t* tests/test_{qrencode,mask,monkey}.c, Makefile.am:\n\t  - New tests added.\n\t* qrencode_inner.h:\n\t  - Typo fix.\n\t* NEWS:\n\t  - Updated.\n\t* qrinput.c:\n\t  - Possible memory errors fixed.\n\t* configure.ac, tests/Makefile.am:\n\t  - Added iconv checks.\n\n2010.01.18 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* configure.ac:\n\t  - Configuration cleanups.\n\t* tests/Makefile.am:\n\t  - Wrong conditional branch fixed.\n\t* tests/decoder.[ch], tests/Makefile.am:\n\t  - Decoding function has been added.\n\t* tests/test_{qrinput,qrspec,qrencode}.c:\n\t  - New tests added.\n\n2010.01.16 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.[ch]:\n\t  - QRcode_encodeData{,MQR,Structured}() have been added.\n\t* tests/test_qrencode.c:\n\t  - New test has been added.\n\n2009.11.27 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.h:\n\t  - Typo fixes.\n\n2009.11.06 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* NEWS, README:\n\t  - Documents updated.\n\t* qrspec.[ch], mqrspec.[ch]:\n\t  - *_clearCache were not thread safe.\n\t  - \"Thread unsafe\" warnings were removed.\n\t* rscode.[ch]\n\t  - free_rs_cache was not thread safe.\n\t  - \"Thread unsafe\" warnings were removed.\n\n2009.09.28 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c:\n\t  - David's patch has been applied. (Thanks to David)\n\t  - New options '-d' and '--dpi' have been added.\n\t  - Typo fixes.\n\t* tests/view_qrcode.c:\n\t  - Typo fixes.\n\n2009.06.08 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c:\n\t  - FrameFiller_nextMQR() has integrated to FrameFiller_next().\n\t  - FrameFiller_new() now requires mqr flag.\n\t* qrencode.[ch], tests/prof_qrencode.c, tests/test_{qrencode,monkey}.c:\n\t  - QRcode_clearCache() has been added.\n\t* configure.ac, qrencode_inner.h, qrencode.c, mask.[ch], mmask.[ch],\n\t  qrinput.h, qrspec.c, tests/common.h:\n\t  - A macro WITH_TESTS has been introduced.\n\t  - \"#ifdef __STATIC\" has been replaced with \"#ifdef __WITH_TESTS\".\n\t  - Some definitions in qrencode_inner.h have been moved to appropriate\n\t    header files.\n\t  - Including config.h became mandatory for test programs.\n\t* tests/pthread_qrencode.c, tests/Makefile.am:\n\t  - New test program has been added.\n\t* rscode.c:\n\t  - config.h was not included.\n\t* mask.c:\n\t  - Race condition problem has been solved.\n\n2009.06.06 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c, tests/view_qrcode.c:\n\t  - Experimental support of Micro QR Code has been implemented.\n\t* qrencode.[ch]:\n\t  - QRinput_setVersionAndErrorCorrectionLevel() has been added.\n\t* tests/common.h, tests/test_split.c:\n\t  - Code cleanups.\n\t  - printFrame() and printQRcode() have been added.\n\t* tests/test_qrencode.c:\n\t  - Some tests have been added.\n\t* qrspec.h, mqrspec.h, qrencode.h:\n\t  - Definitions of {MQR,QR}SPEC_VERSION_MAX are moved to qrencode.h.\n\t* qrinput.c, qrencode.h, tests/test_qrencode.c:\n\t  - Size check has been removed from QRinput_convertData() for MQR.\n\t  - QRinput_convertData() throws ERANGE when the input is too large.\n\t  - QRinput_appendPadding*() throws ERANGE when the input is too large.\n\t  - As a result, QRencode_encodeString*() throws ERANGE in that cases.\n\t  - Some assertion checks of errno added to test_qrencode.\n\t* Bumped version to 3.9.0.\n\t  - Next public release will be 4.0.0.\n\n2009.06.06 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t[3.1.0]\n\t* Version 3.1.0 has been released.\n\n2009.06.05 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.h, qrencode_inner.h, tests/test_qrencode.c:\n\t  - FrameFiller_next() has improved.\n\t  - FrameFiller_nextMQR() has been added.\n\t  - FrameFiller_test() FrameFiller_testMQR() have been added.\n\t  - Tests of FrameFiller added and improved.\n\n2009.06.04 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Makefile.am:\n\t  - Dependency check was incorrect because of misconfiguration.\n\t* mask.c, mmask.c:\n\t  - Error check has been added to {Mask,MMask}_makeMask().\n\t* mqrspec.[ch], qrinput.c:\n\t  - MQRspec_getDataLength() now returns in byte.\n\t  - MQRspec_getDataLengthBit() returns in bit instead.\n\t* qrencode.[ch], qrencode_inner.h:\n\t  - QRencode_encodeStringMQR() and its 8bit version are added.\n\t  - QRcode_encodeMaskMQR() has been added.\n\n2009.06.01 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* tests/prof_qrencode.c:\n\t  - Error check has been added.\n\t* tests/common.h:\n\t  - Bug fixed.\n\t* qrinput.c, qrencode.h:\n\t  - QRinput_Struct_appendInput() and QRinput_splitQRinputToStruct() now\n\t    checks mqr flag.\n\t* tests/test_bitstream.c:\n\t  - New test of 4bit padding of _toByte().\n\n2009.05.30 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* configure.ac, libqrencode.pc.in:\n\t  - New option \"--enable-thread-safety\" has been added. This option is\n\t    enabled by default.\n\t* rscode.c, qrspec.c:\n\t  - libqrencode has become thread-safe! (probably)\n\t* tests/common.h:\n\t  - sprintfBin() removed, printBstream() added.\n\t* qrinput.[ch], qrencode.[ch], mqrspec.c:\n\t  - Functions for Micro QR Code encoding have been added.\n\t* tests/common.h:\n\t  - Utility functions improved.\n\t* tests/*.c:\n\t  - Code cleanups.\n\t  - Tests for Micro QR Code added.\n\n2009.05.30 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrinput.c:\n\t  - padlen check was wrong in QRinput_appendPaddingBit().\n\t* tests/test_qrinput.c:\n\t  - Stop printing bstream->data.\n\t  - test_padding2() has been added.\n\n2009.05.21 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c, qrencode_inner.h:\n\t  - MQRraw_* has been implemented.\n\t  - Code cleanups. Struct QRRaw_code is slightly changed.\n\t* tests/test_qrencode.c:\n\t  - Added new test.\n\n2009.05.20 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Merged from 3.1.0 branch. (rev 2248:HEAD)\n\t* mqrspec.[ch], tests/create_mqr_frame_pattern.c:\n\t  - MQRspec_getEccSpec() has been deleted.\n\t* tests/create_mqr_frame_pattern.c, tests/Makefile.am:\n\t  - Newly added.\n\t* mask.[ch], tests/test_mask.c, qrencode_inner.h:\n\t  - Code cleanups.\n\t  - Unnecessary memcpy has been eliminated.\n\t  - New test program has been added.\n\t* mmask.[ch], qrencode_inner.h, tests/test_mmask.c, Makefile.am, tests/Makefile.am:\n\t  - Mask module for Micro QR Code has been added.\n\n2009.05.20 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c, qrinput.c, qrencode.c:\n\t  - Some compile warnings cleared.\n\t* qrencode.c, tests/test_qrencode.c:\n\t  - NULL check of an input arg has been added to\n\t    QRcode_encodeString8bit().\n\t  - NULL check test and empty string test have been added for\n\t    QRcode_encodeString8bit().\n\t* qrinput.h, qrencode_inner.h, split.c:\n\t  - Copyright year updates.\n\t* split.[ch]:\n\t  - Split_splitStringToQRinput() set errno EINVAL if input string is\n\t    NULL or empty.\n\t  - Documentation improved.\n\t* qrenc.c:\n\t  - perror() is now used to show the details of some errors.\n\t* qrencode.[ch]:\n\t  - Some functions now set errno appropriately.\n\t  - Typo fixes.\n\n2009.05.20 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* tests/create_frame_pattern.c, tests/Makefile.am:\n\t  - New test tool \"create_frame_pattern\" has been added.\n\t* tests/test_qrspec.c:\n\t  - test_alignment1() has been replaced with test_newframe().\n\t    test_newframe() compares newly created frames with frame pattern\n\t\tdata created by create_frame_pattern.\n\t* tests/frame, tests/Makefile.am:\n\t  - Pattern file \"frame\" has been added to EXTRA_DIST.\n\t* mask.c:\n\t  - Very small improvement. Unnecessary malloc()s are reduced.\n\t* tests/test_qrencode.c:\n\t  - Two new tests have been added.\n\t* split.c:\n\t  - NULL check and string length check have been added.\n\t* qrspec.c, tests/test_qrinput.c:\n\t  - Forgotten padding bits bug has been fixed. (enbugged at 2009.5.18)\n\t  - New test for the bug above has been added.\n\t* qrspec.[ch], qrencode_inner.h:\n\t  - Some function becomes __STATIC and their declarations have been\n\t    moved to qrencode_inner.h.\n\t* tests/prof_qrencode.c:\n\t  - Now liberates all heap at the end of the program.\n\n2009.05.19 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c, qrencode_inner.h:\n\t  - calloc() is now used to initialize rsblock.\n\t  - Number of malloc()s in RSblock_initBlock() has been integrated to\n\t    one malloc() in QRraw_new().\n\t* rscode.c:\n\t  - A very small code improvement.\n\t* qrinput.[ch]:\n\t  - More return value checks.\n\t  - Code cleanups.\n\t* tests/common.h, tests/test_{split,monkey,qrinput}.c:\n\t  - Tests improved.\n\t* qrspec.[ch], tests/test_qrspec.c:\n\t  - Code cleanups.\n\t  - QRspec_rs{Data,Ecc}Length() have been added.\n\t* tests/view_qrcode.c:\n\t  - Code cleanups.\n\t  - Disabled mask setting in structured mode.\n\t* tests/common.h:\n\t  - assert_nothing() has been added.\n\t* qrinput.c, qrencode.c, tests/test_*.c:\n\t  - Various *_free() now allow NULL pointer. (nothing performed)\n\t* qrspec.[ch]:\n\t  - Alignment pattern is now put by QRspec_putAlignmentPattern().\n\t    QRspec_getAlignmentPattern() and QRspec_freeAlignment() have been\n\t\tremoved.\n\n2009.05.18 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c:\n\t  - More return value checks.\n\t* bitstream.c:\n\t  - BitStream_free() allows NULL pointer (nothing performed).\n\t* qrinput.c:\n\t  - QRinput_List_freeEntry() and QRinput_free() allow NULL pointer.\n\t  - QRinput_createPaddingBit() has been replaced with\n\t    QRinput_appendPaddingBit().\n\t  - QRinput_convertData() now sets errno to EINVAL when input is too\n\t    large.\n\t  - More return value checks. Mainly for ENOMEM error.\n\n2009.05.18 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Merged from 3.1.0 branch.\n\n2009.05.16 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.h:\n\t  - Indent improvement.\n\t* Makefile.am:\n\t  - qrencode.spec has been added to EXTRA_DIST.\n\n2009.05.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrinput.c, qrencode.c, qrspe.c:\n\t  - More return value checks. Mainly for ENOMEM error.\n\t* qrspec.[ch], qrencode.c, tests/test_qrspec.c:\n\t  - QRspec_getEccSpec() now accepts an int array instead to return\n\t    multiple values instead of returning dynamic allocated array.\n\t* mask.c, rscode.c:\n\t  - More return value checks from malloc().\n\t* configure.ac:\n\t  - Added \"--enable-mudflap\" option.\n\t* rscode.[ch]:\n\t  - Added free_rs_cache() for debug purpose.\n\t* tests/test_{monkey,qrencode,rs}.c:\n\t  - Call free_rs_cache() at the end of the tests.\n\t* qrencode.c:\n\t  - QRraw_new() and RSblock_init() have been improved.\n\t  - Eliminated unnecessary calls of init_rs().\n\t* autogen.sh, configure.ac:\n\t  - Darwin workarounds.\n\t* tests/common.h, tests/test_bitstream.c:\n\t  - New tests have been added.\n\n2009.05.12 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* bitstream.c:\n\t  - BitStream_toByte() had returned non-NULL for an empty BitStream.\n\t* tests/test_bitstream.c:\n\t  - test_null() has been added.\n\t* qrinput.c:\n\t  - A possible memory leak has been eliminated. It happened when a wrong\n\t    version number was given.\n\t* tests/test_qriput.c:\n\t  - Memory leaks have been eliminated.\n\n2009.05.01 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 3.1.0.\n\n2009.04.30 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* bitstream.[ch]:\n\t  - Internal representation of BitStream has been changed from\n\t    NUL-terminated string to unsigned char array.\n\t* tests/common.h, tests/test_{bitstream,qrinput}.c:\n\t  - Some test sequences have been updated (see above).\n\n2009.03.25 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* configure.ac:\n\t  - \"--without-tests\" has become default setting.\n\t* bitstream.[ch]:\n\t  - Now functions strictly check return value from malloc() and return\n\t    error if it fails.\n\n2008.10.31 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* tests/commo.h:\n\t  - __FUNCTION__ has been replaced with __func__, to follow the C99\n\t    standard.\n\t  - The way of variadic macros has been changed, to follow the C99\n\t    standard.\n\n2008.10.11 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode_inner.h:\n\t  - Now this header is called only by test programs.\n\t* qrencode.c, qrencode_inner.h:\n\t  - Some definitions and declares written in qrencode_inner.h have been\n\t    moved into qrencode.c:\n\t  - QRraw_*() have been declared as __STATIC.\n\t* mask.[ch], qrencode.c, qrencode_inner.h:\n\t  - Mask_makeMask() now requires QRecLevel.\n\t  - QRencode_writeFormatInformation() has been renamed and moved to\n\t    Mask_writeFormatInformation(), and become __STATIC.\n\t* tests/*.c:\n\t  - Unneeded #include \"qrencode_inner.h\" have been removed.\n\n2008.10.11 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* autogen.sh:\n\t  - Darwin workaround.\n\t* configure.ac:\n\t  - Now config.h offers \"__STATIC\" macro becomes \"static\" when\n\t    \"--without-tests\" is specified. This macro is useful for functions\n\t\tcalled from test programs but not from other library codes.\n\t* qrinput.c:\n\t  - Very little performance improvement.\n\t* mask.c:\n\t  - Code cleanups.\n\n2008.09.12 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* tests/view_qrcode.c:\n\t  - Unused variable 'pitch' has been removed from draw_QRcode().\n\n2008.06.03 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Merged to the main trunk.\n\n2008.06.01 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c:\n\t  - Now it does not show the full usage when unrecognized options are\n\t    given.\n\t  - When \"--help\" is given, it displays the long usage.\n\t* Version 3.0.3 has been released.\n\n2008.05.26 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c, tests/view_qrcode.c:\n\t  - getopt_long_only() has been replaced with getopt_long() which is\n\t    widely available. (Thanks to Gavan Fantom)\n\t  - Now it accepts long options.\n\t* qrencode.1.in:\n\t  - followed the above changes.\n\t* Bumped version to 3.0.3.\n\n2008.05.18 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrspec.c:\n\t  - The bit order of \"Version information\" has been corrected.\n\t    (Thanks to Paul Janssesn)\n\t* configure.ac, Makefile.am:\n\t  - The \"--without-tests\" has been added to the configure script.\n\t* qrencode.spec.in:\n\t  - Uses \"--without-tests\".\n\t* Version 3.0.2 has been released.\n\n2008.05.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* various files:\n\t  - Some compile-time warnings/erros with g++ have been fixed.\n\t    (Thanks to wangsai)\n\n2008.05.09 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c:\n\t  - Now qrencode writes an image file in binary mode for non-POSIX\n\t    platform, such as MS-Windows. (bug report from Paul Janssens)\n\t* Makefile.am:\n\t  - tests/test_all.sh has been added.\n\t* tests/test_all.sh:\n\t  - Now it exits immediately if any test fails.\n\t* Version 3.0.1 has been released.\n\n2008.05.01 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.spec.in:\n\t  - Added the man page to the files section.\n\n2008.04.30 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Version 3.0.0 has been released.\n\n2008.04.23 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Version 3.0.0rc3 has been released.\n\t  - This will probably be the final release candidate, if all goes well.\n\n2008.04.23 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* split.c:\n\t  - Split_identifyMode() now uses isdigit() and isalnum() macros.\n\t* qrinput.c:\n\t  - Error checks have been improved.\n\t* qrenc.c, tests/view_qrcode.c:\n\t  - Return value checks have been added.\n\t  - Structured-append encode with version 0 now returns error.\n\t* qrencode.[ch]:\n\t  - QRencode_encodeStructuredInput() -> QRencode_encodeInputStructured()\n\t    (for consistency with other QRencode_encode*Structured() functions)\n\t* mask.c:\n\t  - A code block never called has been eliminated.\n\n2008.04.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Version 3.0.0rc2 has been released.\n\n2008.04.20 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.h:\n\t  - QR_MODE_NUL has been added to QRencodeMode. Basically it is used\n\t    only by Split_identifyMode().\n\t* qrinput.[ch], split.c:\n\t  - QRinput_identifyMode() has been moved to split.c, changed to static\n\t    and now needs a hint.\n\t* split.c:\n\t  - Auto-splitting has been improved.\n\t* qrinput.c:\n\t  - A memory leak has been fixed.\n\t* configure.ac:\n\t  - The \"--enable-gprof\" and \"--enable-gcov\" options have been added.\n\t* Makefile.am:\n\t  - man1_MANS has been moved into the \"if BUILD_TOOLS - endif\" block.\n\n2008.04.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Version 3.0.0rc1 has been released.\n\n2008.04.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 3.0.0.\n\t* qrencode.[ch]:\n\t  - QRcode_encodeInput() has changed the API. Previously it takes a\n\t    QRinput, version and level, but now it takes only a QRinput, because\n\t    QRinput holds the version and level in it. From 3.0.0, you should\n\t    set them by calling QRinput_setVersion() and\n\t    QRinput_setErrorCorrectionLevel(), or use QRinput_new2() to\n\t    instantiate a QRinput object.\n\n2008.04.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrspe.c:\n\t  - NULL check has been added.\n\t* split.[ch]:\n\t  - API changed.\n\t* qrencode.c:\n\t  - Arguments (version and level) are now checked in QRcode_encodeMask().\n\t    Internal functions trust the arguments are valid.\n\t  - Error checks improved.\n\t* qrinput.c:\n\t  - Error checks improved.\n\t* qrencode.h:\n\t  - Documentation improvements.\n\n2008.04.13 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c, qrencode_inner.h, tests/view_qrcode.c:\n\t  - Changed API of QRcode_encodeMask().\n\t* qrencode.[ch], qrinput.[ch], split.[ch]:\n\t  - Some functions now set errno appropriately.\n\n2008.04.09 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.h, qrinput.c:\n\t  - QRinput_Struct_insertStructuredAppendHeaders() and\n\t    QRinput_insertStructuredAppendHeader now returns error, when the\n\t    input contains too many structured inputs.\n\t* qrencode.c:\n\t  - QRcode_encodeInputToStructured() now returns NULL when\n\t    QRinput_splitQRinputToStruct() fails.\n\t* tests/view_qrcode.c:\n\t  - Segmentation fault bug has been fixed. (see previous memo)\n\n2008.04.08 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrinput.c:\n\t  - Fixed a bug in QRinput_estimateBitStreamSizeOfEntry(). It could\n\t    overestimate the size.\n\t* rscode.c:\n\t  - Optimized the order of the parameters equality test in init_rs().\n\t* qrspec.c, qrspec.h:\n\t  - Added QRspec_clearCache().\n\t* tests/test_estimatebit.c:\n\t  - Bug fixed in test_numbit3().\n\n2008.04.07 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 2.1.0.\n\t* Structured append is now supported (patches from Yusuke Mihara):\n\t  - Two new types, QRcode_List and QRinput_Struct, have been added.\n\t  - Following functions have been added:\n\t    - QRcode_encodeStructuredInput()\n\t    - QRcode_encodeStringStructured()\n\t    - QRcode_encodeString8bitStructured()\n\t  - Some functions to handle structured append symbols have been added.\n\t    See Doxygen-ized descriptions for the details.\n\t* qrenc.c:\n\t  - \"-S\" option has been added for structured append.\n\t* split.h:\n\t  - \"extern\" was dropped.\n\t* qrinput.h, qrencode.h:\n\t  - Moved declarations of QRinput_{get,set}{Version,ErrorCorrectionLevel}\n\t    from qrinput.h to qrencode.h. Now they are publicly accessible.\n\t* qrencode.h, qrinput.h, qrinput.c:\n\t  - Added QRinput_new2().\n\t  - QRinput_newEntry(), QRinput_freeEntry have been renamed to\n\t    QRinput_List_newEntry(), QRinput_List_freeEntry().\n\t* split.c:\n\t  - Bug fix: Split_eat8() now eats at least 1 byte. Previously it could\n\t    produce a 0-length input entry.\n\n2008.01.23 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.1.in, Makefile.am, configure.ac:\n\t  - Manpage of qrencode has been added.\n\t* qrenc.c, tests/view_qrcode.c:\n\t  - Usage message has been updated.\n\n2008.01.18 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* split.c:\n\t  - Bug fixes.\n\t* tests/test_split.c:\n\t  - Followed recent API changes.\n\t  - Added new test \"test_toupper()\".\n\t* qrenc.c, tests/view_qrcode.c:\n\t  - Source-level compatibility has been improved.\n\t  - view_qrcode now accepts stdin like qrencode.\n\t  - Usage message has been updated/fixed.\n\t* Copyright year has been updated.\n\n2008.01.16 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrinput.c, split.c:\n\t  - Case-sensitive mode becomes now default mode.\n\t  - Alphabet-Numeric mode now encodes only upper-case alphabet and\n\t    numeric characters. If \"-i\" option is given, split.c converts\n\t    lower-case characters to upper-case characters at first.\n\t* qrenc.c, tests/view_qrcode.c:\n\t  - Case-sensitive mode becomes now default mode.\n\t  - Option \"-i\" has been added.\n\n2007.12.14 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* tests/test_qrencode.c:\n\t  - New test has been added.\n\t* tests/view_qrcode.c:\n\t  - Options supported.\n\t  - Default mask is now -1 (auto).\n\n2007.12.13 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.[ch]:\n\t  - QRcode_writeFormatInformation now returns a number of dark modules.\n\t* mask.c:\n\t  - The mask evaluation function now writes format information before\n\t    evaluation. (Philippe Delcroix)\n\t* split.[ch]:\n\t  - Case-sensitive mode has been added to QRcode_encodeString().\n\t  - \"-8\" option has been added to qrenc.c.\n\t  - \"-c\" now encodes in improved case-sensitive mode.\n\t* tests/test_{split,qrencode}.c:\n\t  - test_split*() have been moved to test_split.c.\n\n2007.12.10 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 2.0.0.\n\t* Merged to main trunk.\n\t* mask.[ch], split.[ch]:\n\t  - Masking functions and splitString functions are separated from\n\t    qrencode.c.\n\t* mqrspec.[ch]:\n\t  - Specification of Micro QR code has been added, but not used yet.\n\n2007.03.24 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 1.0.2.\n\n2007.03.24 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode.c (QRcode_splitStringToQRinput):\n\t  - a small bug fix. (Thanks to NANKI Haruo)\n\t* qrencode.h:\n\t  - \"extern \"C\"\" barrier has been added for C++.\n\t* test/view_qrcode.c:\n\t  - a typo fix.\n\n2006.12.27 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 1.0.1.\n\n2006.12.27 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrenc.c, qrencode.[ch]:\n\t  - Added force 8-bit encoding mode.\n\t* Makefile.am :\n\t  - Automake/Autoconf files have been added to dist-package.\n\n2006.12.17 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* qrencode_inner.h, qrencode.c:\n\t  - Removed unused member variable \"b2\" from QRRawCode.\n\t* configure.ac, Makefile.am, acinclude.m4:\n\t  - Better configuration of libpng. (now uses pkg-config correctly)\n\n2006.12.02 Kentaro FUKUCHI <fukuchi@megaui.net>\n\t* Bumped version to 1.0.0.\n"
        },
        {
          "name": "Doxyfile",
          "type": "blob",
          "size": 73.7783203125,
          "content": "# Doxyfile 1.7.6.1\n\n# This file describes the settings to be used by the documentation system\n# doxygen (www.doxygen.org) for a project.\n#\n# All text after a hash (#) is considered a comment and will be ignored.\n# The format is:\n#       TAG = value [value, ...]\n# For lists items can also be appended using:\n#       TAG += value [value, ...]\n# Values that contain spaces should be placed between quotes (\" \").\n\n#---------------------------------------------------------------------------\n# Project related configuration options\n#---------------------------------------------------------------------------\n\n# This tag specifies the encoding used for all characters in the config file\n# that follow. The default is UTF-8 which is also the encoding used for all\n# text before the first occurrence of this tag. Doxygen uses libiconv (or the\n# iconv built into libc) for the transcoding. See\n# http://www.gnu.org/software/libiconv for the list of possible encodings.\n\nDOXYFILE_ENCODING      = UTF-8\n\n# The PROJECT_NAME tag is a single word (or sequence of words) that should\n# identify the project. Note that if you do not use Doxywizard you need\n# to put quotes around the project name if it contains spaces.\n\nPROJECT_NAME           = QRencode\n\n# The PROJECT_NUMBER tag can be used to enter a project or revision number.\n# This could be handy for archiving the generated documentation or\n# if some version control system is used.\n\nPROJECT_NUMBER         =\n\n# Using the PROJECT_BRIEF tag one can provide an optional one line description\n# for a project that appears at the top of each page and should give viewer\n# a quick idea about the purpose of the project. Keep the description short.\n\nPROJECT_BRIEF          = \"QR Code encoder\"\n\n# With the PROJECT_LOGO tag one can specify an logo or icon that is\n# included in the documentation. The maximum height of the logo should not\n# exceed 55 pixels and the maximum width should not exceed 200 pixels.\n# Doxygen will copy the logo to the output directory.\n\nPROJECT_LOGO           =\n\n# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)\n# base path where the generated documentation will be put.\n# If a relative path is entered, it will be relative to the location\n# where doxygen was started. If left blank the current directory will be used.\n\nOUTPUT_DIRECTORY       =\n\n# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create\n# 4096 sub-directories (in 2 levels) under the output directory of each output\n# format and will distribute the generated files over these directories.\n# Enabling this option can be useful when feeding doxygen a huge amount of\n# source files, where putting all generated files in the same directory would\n# otherwise cause performance problems for the file system.\n\nCREATE_SUBDIRS         = NO\n\n# The OUTPUT_LANGUAGE tag is used to specify the language in which all\n# documentation generated by doxygen is written. Doxygen will use this\n# information to generate all constant output in the proper language.\n# The default language is English, other supported languages are:\n# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,\n# Croatian, Czech, Danish, Dutch, Esperanto, Farsi, Finnish, French, German,\n# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English\n# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,\n# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak,\n# Slovene, Spanish, Swedish, Ukrainian, and Vietnamese.\n\nOUTPUT_LANGUAGE        = English\n\n# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will\n# include brief member descriptions after the members that are listed in\n# the file and class documentation (similar to JavaDoc).\n# Set to NO to disable this.\n\nBRIEF_MEMBER_DESC      = YES\n\n# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend\n# the brief description of a member or function before the detailed description.\n# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the\n# brief descriptions will be completely suppressed.\n\nREPEAT_BRIEF           = YES\n\n# This tag implements a quasi-intelligent brief description abbreviator\n# that is used to form the text in various listings. Each string\n# in this list, if found as the leading text of the brief description, will be\n# stripped from the text and the result after processing the whole list, is\n# used as the annotated text. Otherwise, the brief description is used as-is.\n# If left blank, the following values are used (\"$name\" is automatically\n# replaced with the name of the entity): \"The $name class\" \"The $name widget\"\n# \"The $name file\" \"is\" \"provides\" \"specifies\" \"contains\"\n# \"represents\" \"a\" \"an\" \"the\"\n\nABBREVIATE_BRIEF       =\n\n# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then\n# Doxygen will generate a detailed section even if there is only a brief\n# description.\n\nALWAYS_DETAILED_SEC    = NO\n\n# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all\n# inherited members of a class in the documentation of that class as if those\n# members were ordinary class members. Constructors, destructors and assignment\n# operators of the base classes will not be shown.\n\nINLINE_INHERITED_MEMB  = NO\n\n# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full\n# path before files name in the file list and in the header files. If set\n# to NO the shortest path that makes the file name unique will be used.\n\nFULL_PATH_NAMES        = YES\n\n# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag\n# can be used to strip a user-defined part of the path. Stripping is\n# only done if one of the specified strings matches the left-hand part of\n# the path. The tag can be used to show relative paths in the file list.\n# If left blank the directory from which doxygen is run is used as the\n# path to strip.\n\nSTRIP_FROM_PATH        =\n\n# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of\n# the path mentioned in the documentation of a class, which tells\n# the reader which header file to include in order to use a class.\n# If left blank only the name of the header file containing the class\n# definition is used. Otherwise one should specify the include paths that\n# are normally passed to the compiler using the -I flag.\n\nSTRIP_FROM_INC_PATH    =\n\n# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter\n# (but less readable) file names. This can be useful if your file system\n# doesn't support long names like on DOS, Mac, or CD-ROM.\n\nSHORT_NAMES            = NO\n\n# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen\n# will interpret the first line (until the first dot) of a JavaDoc-style\n# comment as the brief description. If set to NO, the JavaDoc\n# comments will behave just like regular Qt-style comments\n# (thus requiring an explicit @brief command for a brief description.)\n\nJAVADOC_AUTOBRIEF      = YES\n\n# If the QT_AUTOBRIEF tag is set to YES then Doxygen will\n# interpret the first line (until the first dot) of a Qt-style\n# comment as the brief description. If set to NO, the comments\n# will behave just like regular Qt-style comments (thus requiring\n# an explicit \\brief command for a brief description.)\n\nQT_AUTOBRIEF           = NO\n\n# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen\n# treat a multi-line C++ special comment block (i.e. a block of //! or ///\n# comments) as a brief description. This used to be the default behaviour.\n# The new default is to treat a multi-line C++ comment block as a detailed\n# description. Set this tag to YES if you prefer the old behaviour instead.\n\nMULTILINE_CPP_IS_BRIEF = NO\n\n# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented\n# member inherits the documentation from any documented member that it\n# re-implements.\n\nINHERIT_DOCS           = YES\n\n# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce\n# a new page for each member. If set to NO, the documentation of a member will\n# be part of the file/class/namespace that contains it.\n\nSEPARATE_MEMBER_PAGES  = NO\n\n# The TAB_SIZE tag can be used to set the number of spaces in a tab.\n# Doxygen uses this value to replace tabs by spaces in code fragments.\n\nTAB_SIZE               = 8\n\n# This tag can be used to specify a number of aliases that acts\n# as commands in the documentation. An alias has the form \"name=value\".\n# For example adding \"sideeffect=\\par Side Effects:\\n\" will allow you to\n# put the command \\sideeffect (or @sideeffect) in the documentation, which\n# will result in a user-defined paragraph with heading \"Side Effects:\".\n# You can put \\n's in the value part of an alias to insert newlines.\n\nALIASES                =\n\n# This tag can be used to specify a number of word-keyword mappings (TCL only).\n# A mapping has the form \"name=value\". For example adding\n# \"class=itcl::class\" will allow you to use the command class in the\n# itcl::class meaning.\n\nTCL_SUBST              =\n\n# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C\n# sources only. Doxygen will then generate output that is more tailored for C.\n# For instance, some of the names that are used will be different. The list\n# of all members will be omitted, etc.\n\nOPTIMIZE_OUTPUT_FOR_C  = YES\n\n# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java\n# sources only. Doxygen will then generate output that is more tailored for\n# Java. For instance, namespaces will be presented as packages, qualified\n# scopes will look different, etc.\n\nOPTIMIZE_OUTPUT_JAVA   = NO\n\n# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran\n# sources only. Doxygen will then generate output that is more tailored for\n# Fortran.\n\nOPTIMIZE_FOR_FORTRAN   = NO\n\n# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL\n# sources. Doxygen will then generate output that is tailored for\n# VHDL.\n\nOPTIMIZE_OUTPUT_VHDL   = NO\n\n# Doxygen selects the parser to use depending on the extension of the files it\n# parses. With this tag you can assign which parser to use for a given extension.\n# Doxygen has a built-in mapping, but you can override or extend it using this\n# tag. The format is ext=language, where ext is a file extension, and language\n# is one of the parsers supported by doxygen: IDL, Java, Javascript, CSharp, C,\n# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make\n# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C\n# (default is Fortran), use: inc=Fortran f=C. Note that for custom extensions\n# you also need to set FILE_PATTERNS otherwise the files are not read by doxygen.\n\nEXTENSION_MAPPING      =\n\n# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want\n# to include (a tag file for) the STL sources as input, then you should\n# set this tag to YES in order to let doxygen match functions declarations and\n# definitions whose arguments contain STL classes (e.g. func(std::string); v.s.\n# func(std::string) {}). This also makes the inheritance and collaboration\n# diagrams that involve STL classes more complete and accurate.\n\nBUILTIN_STL_SUPPORT    = NO\n\n# If you use Microsoft's C++/CLI language, you should set this option to YES to\n# enable parsing support.\n\nCPP_CLI_SUPPORT        = NO\n\n# Set the SIP_SUPPORT tag to YES if your project consists of sip sources only.\n# Doxygen will parse them like normal C++ but will assume all classes use public\n# instead of private inheritance when no explicit protection keyword is present.\n\nSIP_SUPPORT            = NO\n\n# For Microsoft's IDL there are propget and propput attributes to indicate getter\n# and setter methods for a property. Setting this option to YES (the default)\n# will make doxygen replace the get and set methods by a property in the\n# documentation. This will only work if the methods are indeed getting or\n# setting a simple type. If this is not the case, or you want to show the\n# methods anyway, you should set this option to NO.\n\nIDL_PROPERTY_SUPPORT   = YES\n\n# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC\n# tag is set to YES, then doxygen will reuse the documentation of the first\n# member in the group (if any) for the other members of the group. By default\n# all members of a group must be documented explicitly.\n\nDISTRIBUTE_GROUP_DOC   = NO\n\n# Set the SUBGROUPING tag to YES (the default) to allow class member groups of\n# the same type (for instance a group of public functions) to be put as a\n# subgroup of that type (e.g. under the Public Functions section). Set it to\n# NO to prevent subgrouping. Alternatively, this can be done per class using\n# the \\nosubgrouping command.\n\nSUBGROUPING            = YES\n\n# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and\n# unions are shown inside the group in which they are included (e.g. using\n# @ingroup) instead of on a separate page (for HTML and Man pages) or\n# section (for LaTeX and RTF).\n\nINLINE_GROUPED_CLASSES = NO\n\n# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and\n# unions with only public data fields will be shown inline in the documentation\n# of the scope in which they are defined (i.e. file, namespace, or group\n# documentation), provided this scope is documented. If set to NO (the default),\n# structs, classes, and unions are shown on a separate page (for HTML and Man\n# pages) or section (for LaTeX and RTF).\n\nINLINE_SIMPLE_STRUCTS  = NO\n\n# When TYPEDEF_HIDES_STRUCT is enabled, a typedef of a struct, union, or enum\n# is documented as struct, union, or enum with the name of the typedef. So\n# typedef struct TypeS {} TypeT, will appear in the documentation as a struct\n# with name TypeT. When disabled the typedef will appear as a member of a file,\n# namespace, or class. And the struct will be named TypeS. This can typically\n# be useful for C code in case the coding convention dictates that all compound\n# types are typedef'ed and only the typedef is referenced, never the tag name.\n\nTYPEDEF_HIDES_STRUCT   = YES\n\n# The SYMBOL_CACHE_SIZE determines the size of the internal cache use to\n# determine which symbols to keep in memory and which to flush to disk.\n# When the cache is full, less often used symbols will be written to disk.\n# For small to medium size projects (<1000 input files) the default value is\n# probably good enough. For larger projects a too small cache size can cause\n# doxygen to be busy swapping symbols to and from disk most of the time\n# causing a significant performance penalty.\n# If the system has enough physical memory increasing the cache will improve the\n# performance by keeping more symbols in memory. Note that the value works on\n# a logarithmic scale so increasing the size by one will roughly double the\n# memory usage. The cache size is given by this formula:\n# 2^(16+SYMBOL_CACHE_SIZE). The valid range is 0..9, the default is 0,\n# corresponding to a cache size of 2^16 = 65536 symbols.\n\nSYMBOL_CACHE_SIZE      = 0\n\n# Similar to the SYMBOL_CACHE_SIZE the size of the symbol lookup cache can be\n# set using LOOKUP_CACHE_SIZE. This cache is used to resolve symbols given\n# their name and scope. Since this can be an expensive process and often the\n# same symbol appear multiple times in the code, doxygen keeps a cache of\n# pre-resolved symbols. If the cache is too small doxygen will become slower.\n# If the cache is too large, memory is wasted. The cache size is given by this\n# formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range is 0..9, the default is 0,\n# corresponding to a cache size of 2^16 = 65536 symbols.\n\nLOOKUP_CACHE_SIZE      = 0\n\n#---------------------------------------------------------------------------\n# Build related configuration options\n#---------------------------------------------------------------------------\n\n# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in\n# documentation are documented, even if no documentation was available.\n# Private class members and static file members will be hidden unless\n# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES\n\nEXTRACT_ALL            = YES\n\n# If the EXTRACT_PRIVATE tag is set to YES all private members of a class\n# will be included in the documentation.\n\nEXTRACT_PRIVATE        = NO\n\n# If the EXTRACT_STATIC tag is set to YES all static members of a file\n# will be included in the documentation.\n\nEXTRACT_STATIC         = NO\n\n# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs)\n# defined locally in source files will be included in the documentation.\n# If set to NO only classes defined in header files are included.\n\nEXTRACT_LOCAL_CLASSES  = YES\n\n# This flag is only useful for Objective-C code. When set to YES local\n# methods, which are defined in the implementation section but not in\n# the interface are included in the documentation.\n# If set to NO (the default) only methods in the interface are included.\n\nEXTRACT_LOCAL_METHODS  = NO\n\n# If this flag is set to YES, the members of anonymous namespaces will be\n# extracted and appear in the documentation as a namespace called\n# 'anonymous_namespace{file}', where file will be replaced with the base\n# name of the file that contains the anonymous namespace. By default\n# anonymous namespaces are hidden.\n\nEXTRACT_ANON_NSPACES   = NO\n\n# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all\n# undocumented members of documented classes, files or namespaces.\n# If set to NO (the default) these members will be included in the\n# various overviews, but no documentation section is generated.\n# This option has no effect if EXTRACT_ALL is enabled.\n\nHIDE_UNDOC_MEMBERS     = YES\n\n# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all\n# undocumented classes that are normally visible in the class hierarchy.\n# If set to NO (the default) these classes will be included in the various\n# overviews. This option has no effect if EXTRACT_ALL is enabled.\n\nHIDE_UNDOC_CLASSES     = YES\n\n# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all\n# friend (class|struct|union) declarations.\n# If set to NO (the default) these declarations will be included in the\n# documentation.\n\nHIDE_FRIEND_COMPOUNDS  = YES\n\n# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any\n# documentation blocks found inside the body of a function.\n# If set to NO (the default) these blocks will be appended to the\n# function's detailed documentation block.\n\nHIDE_IN_BODY_DOCS      = NO\n\n# The INTERNAL_DOCS tag determines if documentation\n# that is typed after a \\internal command is included. If the tag is set\n# to NO (the default) then the documentation will be excluded.\n# Set it to YES to include the internal documentation.\n\nINTERNAL_DOCS          = NO\n\n# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate\n# file names in lower-case letters. If set to YES upper-case letters are also\n# allowed. This is useful if you have classes or files whose names only differ\n# in case and if your file system supports case sensitive file names. Windows\n# and Mac users are advised to set this option to NO.\n\nCASE_SENSE_NAMES       = YES\n\n# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen\n# will show members with their full class and namespace scopes in the\n# documentation. If set to YES the scope will be hidden.\n\nHIDE_SCOPE_NAMES       = NO\n\n# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen\n# will put a list of the files that are included by a file in the documentation\n# of that file.\n\nSHOW_INCLUDE_FILES     = YES\n\n# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen\n# will list include files with double quotes in the documentation\n# rather than with sharp brackets.\n\nFORCE_LOCAL_INCLUDES   = NO\n\n# If the INLINE_INFO tag is set to YES (the default) then a tag [inline]\n# is inserted in the documentation for inline members.\n\nINLINE_INFO            = YES\n\n# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen\n# will sort the (detailed) documentation of file and class members\n# alphabetically by member name. If set to NO the members will appear in\n# declaration order.\n\nSORT_MEMBER_DOCS       = NO\n\n# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the\n# brief documentation of file, namespace and class members alphabetically\n# by member name. If set to NO (the default) the members will appear in\n# declaration order.\n\nSORT_BRIEF_DOCS        = NO\n\n# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen\n# will sort the (brief and detailed) documentation of class members so that\n# constructors and destructors are listed first. If set to NO (the default)\n# the constructors will appear in the respective orders defined by\n# SORT_MEMBER_DOCS and SORT_BRIEF_DOCS.\n# This tag will be ignored for brief docs if SORT_BRIEF_DOCS is set to NO\n# and ignored for detailed docs if SORT_MEMBER_DOCS is set to NO.\n\nSORT_MEMBERS_CTORS_1ST = NO\n\n# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the\n# hierarchy of group names into alphabetical order. If set to NO (the default)\n# the group names will appear in their defined order.\n\nSORT_GROUP_NAMES       = NO\n\n# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be\n# sorted by fully-qualified names, including namespaces. If set to\n# NO (the default), the class list will be sorted only by class name,\n# not including the namespace part.\n# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.\n# Note: This option applies only to the class list, not to the\n# alphabetical list.\n\nSORT_BY_SCOPE_NAME     = NO\n\n# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to\n# do proper type resolution of all parameters of a function it will reject a\n# match between the prototype and the implementation of a member function even\n# if there is only one candidate or it is obvious which candidate to choose\n# by doing a simple string match. By disabling STRICT_PROTO_MATCHING doxygen\n# will still accept a match between prototype and implementation in such cases.\n\nSTRICT_PROTO_MATCHING  = NO\n\n# The GENERATE_TODOLIST tag can be used to enable (YES) or\n# disable (NO) the todo list. This list is created by putting \\todo\n# commands in the documentation.\n\nGENERATE_TODOLIST      = YES\n\n# The GENERATE_TESTLIST tag can be used to enable (YES) or\n# disable (NO) the test list. This list is created by putting \\test\n# commands in the documentation.\n\nGENERATE_TESTLIST      = YES\n\n# The GENERATE_BUGLIST tag can be used to enable (YES) or\n# disable (NO) the bug list. This list is created by putting \\bug\n# commands in the documentation.\n\nGENERATE_BUGLIST       = YES\n\n# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or\n# disable (NO) the deprecated list. This list is created by putting\n# \\deprecated commands in the documentation.\n\nGENERATE_DEPRECATEDLIST= YES\n\n# The ENABLED_SECTIONS tag can be used to enable conditional\n# documentation sections, marked by \\if sectionname ... \\endif.\n\nENABLED_SECTIONS       =\n\n# The MAX_INITIALIZER_LINES tag determines the maximum number of lines\n# the initial value of a variable or macro consists of for it to appear in\n# the documentation. If the initializer consists of more lines than specified\n# here it will be hidden. Use a value of 0 to hide initializers completely.\n# The appearance of the initializer of individual variables and macros in the\n# documentation can be controlled using \\showinitializer or \\hideinitializer\n# command in the documentation regardless of this setting.\n\nMAX_INITIALIZER_LINES  = 30\n\n# Set the SHOW_USED_FILES tag to NO to disable the list of files generated\n# at the bottom of the documentation of classes and structs. If set to YES the\n# list will mention the files that were used to generate the documentation.\n\nSHOW_USED_FILES        = YES\n\n# If the sources in your project are distributed over multiple directories\n# then setting the SHOW_DIRECTORIES tag to YES will show the directory hierarchy\n# in the documentation. The default is NO.\n\nSHOW_DIRECTORIES       = NO\n\n# Set the SHOW_FILES tag to NO to disable the generation of the Files page.\n# This will remove the Files entry from the Quick Index and from the\n# Folder Tree View (if specified). The default is YES.\n\nSHOW_FILES             = YES\n\n# Set the SHOW_NAMESPACES tag to NO to disable the generation of the\n# Namespaces page.\n# This will remove the Namespaces entry from the Quick Index\n# and from the Folder Tree View (if specified). The default is YES.\n\nSHOW_NAMESPACES        = YES\n\n# The FILE_VERSION_FILTER tag can be used to specify a program or script that\n# doxygen should invoke to get the current version for each file (typically from\n# the version control system). Doxygen will invoke the program by executing (via\n# popen()) the command <command> <input-file>, where <command> is the value of\n# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file\n# provided by doxygen. Whatever the program writes to standard output\n# is used as the file version. See the manual for examples.\n\nFILE_VERSION_FILTER    =\n\n# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed\n# by doxygen. The layout file controls the global structure of the generated\n# output files in an output format independent way. The create the layout file\n# that represents doxygen's defaults, run doxygen with the -l option.\n# You can optionally specify a file name after the option, if omitted\n# DoxygenLayout.xml will be used as the name of the layout file.\n\nLAYOUT_FILE            =\n\n# The CITE_BIB_FILES tag can be used to specify one or more bib files\n# containing the references data. This must be a list of .bib files. The\n# .bib extension is automatically appended if omitted. Using this command\n# requires the bibtex tool to be installed. See also\n# http://en.wikipedia.org/wiki/BibTeX for more info. For LaTeX the style\n# of the bibliography can be controlled using LATEX_BIB_STYLE. To use this\n# feature you need bibtex and perl available in the search path.\n\nCITE_BIB_FILES         =\n\n#---------------------------------------------------------------------------\n# configuration options related to warning and progress messages\n#---------------------------------------------------------------------------\n\n# The QUIET tag can be used to turn on/off the messages that are generated\n# by doxygen. Possible values are YES and NO. If left blank NO is used.\n\nQUIET                  = NO\n\n# The WARNINGS tag can be used to turn on/off the warning messages that are\n# generated by doxygen. Possible values are YES and NO. If left blank\n# NO is used.\n\nWARNINGS               = YES\n\n# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings\n# for undocumented members. If EXTRACT_ALL is set to YES then this flag will\n# automatically be disabled.\n\nWARN_IF_UNDOCUMENTED   = YES\n\n# If WARN_IF_DOC_ERROR is set to YES, doxygen will generate warnings for\n# potential errors in the documentation, such as not documenting some\n# parameters in a documented function, or documenting parameters that\n# don't exist or using markup commands wrongly.\n\nWARN_IF_DOC_ERROR      = YES\n\n# The WARN_NO_PARAMDOC option can be enabled to get warnings for\n# functions that are documented, but have no documentation for their parameters\n# or return value. If set to NO (the default) doxygen will only warn about\n# wrong or incomplete parameter documentation, but not about the absence of\n# documentation.\n\nWARN_NO_PARAMDOC       = NO\n\n# The WARN_FORMAT tag determines the format of the warning messages that\n# doxygen can produce. The string should contain the $file, $line, and $text\n# tags, which will be replaced by the file and line number from which the\n# warning originated and the warning text. Optionally the format may contain\n# $version, which will be replaced by the version of the file (if it could\n# be obtained via FILE_VERSION_FILTER)\n\nWARN_FORMAT            = \"$file:$line: $text\"\n\n# The WARN_LOGFILE tag can be used to specify a file to which warning\n# and error messages should be written. If left blank the output is written\n# to stderr.\n\nWARN_LOGFILE           =\n\n#---------------------------------------------------------------------------\n# configuration options related to the input files\n#---------------------------------------------------------------------------\n\n# The INPUT tag can be used to specify the files and/or directories that contain\n# documented source files. You may enter file names like \"myfile.cpp\" or\n# directories like \"/usr/src/myproject\". Separate the files or directories\n# with spaces.\n\nINPUT                  = qrencode.h\n\n# This tag can be used to specify the character encoding of the source files\n# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is\n# also the default input encoding. Doxygen uses libiconv (or the iconv built\n# into libc) for the transcoding. See http://www.gnu.org/software/libiconv for\n# the list of possible encodings.\n\nINPUT_ENCODING         = UTF-8\n\n# If the value of the INPUT tag contains directories, you can use the\n# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp\n# and *.h) to filter out the source-files in the directories. If left\n# blank the following patterns are tested:\n# *.c *.cc *.cxx *.cpp *.c++ *.d *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh\n# *.hxx *.hpp *.h++ *.idl *.odl *.cs *.php *.php3 *.inc *.m *.mm *.dox *.py\n# *.f90 *.f *.for *.vhd *.vhdl\n\nFILE_PATTERNS          =\n\n# The RECURSIVE tag can be used to turn specify whether or not subdirectories\n# should be searched for input files as well. Possible values are YES and NO.\n# If left blank NO is used.\n\nRECURSIVE              = NO\n\n# The EXCLUDE tag can be used to specify files and/or directories that should be\n# excluded from the INPUT source files. This way you can easily exclude a\n# subdirectory from a directory tree whose root is specified with the INPUT tag.\n# Note that relative paths are relative to the directory from which doxygen is\n# run.\n\nEXCLUDE                =\n\n# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or\n# directories that are symbolic links (a Unix file system feature) are excluded\n# from the input.\n\nEXCLUDE_SYMLINKS       = NO\n\n# If the value of the INPUT tag contains directories, you can use the\n# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude\n# certain files from those directories. Note that the wildcards are matched\n# against the file with absolute path, so to exclude all test directories\n# for example use the pattern */test/*\n\nEXCLUDE_PATTERNS       =\n\n# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names\n# (namespaces, classes, functions, etc.) that should be excluded from the\n# output. The symbol name can be a fully qualified name, a word, or if the\n# wildcard * is used, a substring. Examples: ANamespace, AClass,\n# AClass::ANamespace, ANamespace::*Test\n\nEXCLUDE_SYMBOLS        =\n\n# The EXAMPLE_PATH tag can be used to specify one or more files or\n# directories that contain example code fragments that are included (see\n# the \\include command).\n\nEXAMPLE_PATH           =\n\n# If the value of the EXAMPLE_PATH tag contains directories, you can use the\n# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp\n# and *.h) to filter out the source-files in the directories. If left\n# blank all files are included.\n\nEXAMPLE_PATTERNS       =\n\n# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be\n# searched for input files to be used with the \\include or \\dontinclude\n# commands irrespective of the value of the RECURSIVE tag.\n# Possible values are YES and NO. If left blank NO is used.\n\nEXAMPLE_RECURSIVE      = NO\n\n# The IMAGE_PATH tag can be used to specify one or more files or\n# directories that contain image that are included in the documentation (see\n# the \\image command).\n\nIMAGE_PATH             =\n\n# The INPUT_FILTER tag can be used to specify a program that doxygen should\n# invoke to filter for each input file. Doxygen will invoke the filter program\n# by executing (via popen()) the command <filter> <input-file>, where <filter>\n# is the value of the INPUT_FILTER tag, and <input-file> is the name of an\n# input file. Doxygen will then use the output that the filter program writes\n# to standard output.\n# If FILTER_PATTERNS is specified, this tag will be\n# ignored.\n\nINPUT_FILTER           =\n\n# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern\n# basis.\n# Doxygen will compare the file name with each pattern and apply the\n# filter if there is a match.\n# The filters are a list of the form:\n# pattern=filter (like *.cpp=my_cpp_filter). See INPUT_FILTER for further\n# info on how filters are used. If FILTER_PATTERNS is empty or if\n# non of the patterns match the file name, INPUT_FILTER is applied.\n\nFILTER_PATTERNS        =\n\n# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using\n# INPUT_FILTER) will be used to filter the input files when producing source\n# files to browse (i.e. when SOURCE_BROWSER is set to YES).\n\nFILTER_SOURCE_FILES    = NO\n\n# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file\n# pattern. A pattern will override the setting for FILTER_PATTERN (if any)\n# and it is also possible to disable source filtering for a specific pattern\n# using *.ext= (so without naming a filter). This option only has effect when\n# FILTER_SOURCE_FILES is enabled.\n\nFILTER_SOURCE_PATTERNS =\n\n#---------------------------------------------------------------------------\n# configuration options related to source browsing\n#---------------------------------------------------------------------------\n\n# If the SOURCE_BROWSER tag is set to YES then a list of source files will\n# be generated. Documented entities will be cross-referenced with these sources.\n# Note: To get rid of all source code in the generated output, make sure also\n# VERBATIM_HEADERS is set to NO.\n\nSOURCE_BROWSER         = NO\n\n# Setting the INLINE_SOURCES tag to YES will include the body\n# of functions and classes directly in the documentation.\n\nINLINE_SOURCES         = NO\n\n# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct\n# doxygen to hide any special comment blocks from generated source code\n# fragments. Normal C and C++ comments will always remain visible.\n\nSTRIP_CODE_COMMENTS    = YES\n\n# If the REFERENCED_BY_RELATION tag is set to YES\n# then for each documented function all documented\n# functions referencing it will be listed.\n\nREFERENCED_BY_RELATION = NO\n\n# If the REFERENCES_RELATION tag is set to YES\n# then for each documented function all documented entities\n# called/used by that function will be listed.\n\nREFERENCES_RELATION    = NO\n\n# If the REFERENCES_LINK_SOURCE tag is set to YES (the default)\n# and SOURCE_BROWSER tag is set to YES, then the hyperlinks from\n# functions in REFERENCES_RELATION and REFERENCED_BY_RELATION lists will\n# link to the source code.\n# Otherwise they will link to the documentation.\n\nREFERENCES_LINK_SOURCE = YES\n\n# If the USE_HTAGS tag is set to YES then the references to source code\n# will point to the HTML generated by the htags(1) tool instead of doxygen\n# built-in source browser. The htags tool is part of GNU's global source\n# tagging system (see http://www.gnu.org/software/global/global.html). You\n# will need version 4.8.6 or higher.\n\nUSE_HTAGS              = NO\n\n# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen\n# will generate a verbatim copy of the header file for each class for\n# which an include is specified. Set to NO to disable this.\n\nVERBATIM_HEADERS       = YES\n\n#---------------------------------------------------------------------------\n# configuration options related to the alphabetical class index\n#---------------------------------------------------------------------------\n\n# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index\n# of all compounds will be generated. Enable this if the project\n# contains a lot of classes, structs, unions or interfaces.\n\nALPHABETICAL_INDEX     = NO\n\n# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then\n# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns\n# in which this list will be split (can be a number in the range [1..20])\n\nCOLS_IN_ALPHA_INDEX    = 5\n\n# In case all classes in a project start with a common prefix, all\n# classes will be put under the same header in the alphabetical index.\n# The IGNORE_PREFIX tag can be used to specify one or more prefixes that\n# should be ignored while generating the index headers.\n\nIGNORE_PREFIX          =\n\n#---------------------------------------------------------------------------\n# configuration options related to the HTML output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_HTML tag is set to YES (the default) Doxygen will\n# generate HTML output.\n\nGENERATE_HTML          = YES\n\n# The HTML_OUTPUT tag is used to specify where the HTML docs will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be\n# put in front of it. If left blank `html' will be used as the default path.\n\nHTML_OUTPUT            = html\n\n# The HTML_FILE_EXTENSION tag can be used to specify the file extension for\n# each generated HTML page (for example: .htm,.php,.asp). If it is left blank\n# doxygen will generate files with .html extension.\n\nHTML_FILE_EXTENSION    = .html\n\n# The HTML_HEADER tag can be used to specify a personal HTML header for\n# each generated HTML page. If it is left blank doxygen will generate a\n# standard header. Note that when using a custom header you are responsible\n#  for the proper inclusion of any scripts and style sheets that doxygen\n# needs, which is dependent on the configuration options used.\n# It is advised to generate a default header using \"doxygen -w html\n# header.html footer.html stylesheet.css YourConfigFile\" and then modify\n# that header. Note that the header is subject to change so you typically\n# have to redo this when upgrading to a newer version of doxygen or when\n# changing the value of configuration settings such as GENERATE_TREEVIEW!\n\nHTML_HEADER            =\n\n# The HTML_FOOTER tag can be used to specify a personal HTML footer for\n# each generated HTML page. If it is left blank doxygen will generate a\n# standard footer.\n\nHTML_FOOTER            =\n\n# The HTML_STYLESHEET tag can be used to specify a user-defined cascading\n# style sheet that is used by each HTML page. It can be used to\n# fine-tune the look of the HTML output. If the tag is left blank doxygen\n# will generate a default style sheet. Note that doxygen will try to copy\n# the style sheet file to the HTML output directory, so don't put your own\n# style sheet in the HTML output directory as well, or it will be erased!\n\nHTML_STYLESHEET        =\n\n# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or\n# other source files which should be copied to the HTML output directory. Note\n# that these files will be copied to the base HTML output directory. Use the\n# $relpath$ marker in the HTML_HEADER and/or HTML_FOOTER files to load these\n# files. In the HTML_STYLESHEET file, use the file name only. Also note that\n# the files will be copied as-is; there are no commands or markers available.\n\nHTML_EXTRA_FILES       =\n\n# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output.\n# Doxygen will adjust the colors in the style sheet and background images\n# according to this color. Hue is specified as an angle on a colorwheel,\n# see http://en.wikipedia.org/wiki/Hue for more information.\n# For instance the value 0 represents red, 60 is yellow, 120 is green,\n# 180 is cyan, 240 is blue, 300 purple, and 360 is red again.\n# The allowed range is 0 to 359.\n\nHTML_COLORSTYLE_HUE    = 220\n\n# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of\n# the colors in the HTML output. For a value of 0 the output will use\n# grayscales only. A value of 255 will produce the most vivid colors.\n\nHTML_COLORSTYLE_SAT    = 100\n\n# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to\n# the luminance component of the colors in the HTML output. Values below\n# 100 gradually make the output lighter, whereas values above 100 make\n# the output darker. The value divided by 100 is the actual gamma applied,\n# so 80 represents a gamma of 0.8, The value 220 represents a gamma of 2.2,\n# and 100 does not change the gamma.\n\nHTML_COLORSTYLE_GAMMA  = 80\n\n# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML\n# page will contain the date and time when the page was generated. Setting\n# this to NO can help when comparing the output of multiple runs.\n\nHTML_TIMESTAMP         = YES\n\n# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes,\n# files or namespaces will be aligned in HTML using tables. If set to\n# NO a bullet list will be used.\n\nHTML_ALIGN_MEMBERS     = YES\n\n# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML\n# documentation will contain sections that can be hidden and shown after the\n# page has loaded. For this to work a browser that supports\n# JavaScript and DHTML is required (for instance Mozilla 1.0+, Firefox\n# Netscape 6.0+, Internet explorer 5.0+, Konqueror, or Safari).\n\nHTML_DYNAMIC_SECTIONS  = NO\n\n# If the GENERATE_DOCSET tag is set to YES, additional index files\n# will be generated that can be used as input for Apple's Xcode 3\n# integrated development environment, introduced with OSX 10.5 (Leopard).\n# To create a documentation set, doxygen will generate a Makefile in the\n# HTML output directory. Running make will produce the docset in that\n# directory and running \"make install\" will install the docset in\n# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find\n# it at startup.\n# See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html\n# for more information.\n\nGENERATE_DOCSET        = NO\n\n# When GENERATE_DOCSET tag is set to YES, this tag determines the name of the\n# feed. A documentation feed provides an umbrella under which multiple\n# documentation sets from a single provider (such as a company or product suite)\n# can be grouped.\n\nDOCSET_FEEDNAME        = \"Doxygen generated docs\"\n\n# When GENERATE_DOCSET tag is set to YES, this tag specifies a string that\n# should uniquely identify the documentation set bundle. This should be a\n# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen\n# will append .docset to the name.\n\nDOCSET_BUNDLE_ID       = org.doxygen.Project\n\n# When GENERATE_PUBLISHER_ID tag specifies a string that should uniquely identify\n# the documentation publisher. This should be a reverse domain-name style\n# string, e.g. com.mycompany.MyDocSet.documentation.\n\nDOCSET_PUBLISHER_ID    = org.doxygen.Publisher\n\n# The GENERATE_PUBLISHER_NAME tag identifies the documentation publisher.\n\nDOCSET_PUBLISHER_NAME  = Publisher\n\n# If the GENERATE_HTMLHELP tag is set to YES, additional index files\n# will be generated that can be used as input for tools like the\n# Microsoft HTML help workshop to generate a compiled HTML help file (.chm)\n# of the generated HTML documentation.\n\nGENERATE_HTMLHELP      = NO\n\n# If the GENERATE_HTMLHELP tag is set to YES, the CHM_FILE tag can\n# be used to specify the file name of the resulting .chm file. You\n# can add a path in front of the file if the result should not be\n# written to the html output directory.\n\nCHM_FILE               =\n\n# If the GENERATE_HTMLHELP tag is set to YES, the HHC_LOCATION tag can\n# be used to specify the location (absolute path including file name) of\n# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run\n# the HTML help compiler on the generated index.hhp.\n\nHHC_LOCATION           =\n\n# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag\n# controls if a separate .chi index file is generated (YES) or that\n# it should be included in the master .chm file (NO).\n\nGENERATE_CHI           = NO\n\n# If the GENERATE_HTMLHELP tag is set to YES, the CHM_INDEX_ENCODING\n# is used to encode HtmlHelp index (hhk), content (hhc) and project file\n# content.\n\nCHM_INDEX_ENCODING     =\n\n# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag\n# controls whether a binary table of contents is generated (YES) or a\n# normal table of contents (NO) in the .chm file.\n\nBINARY_TOC             = NO\n\n# The TOC_EXPAND flag can be set to YES to add extra items for group members\n# to the contents of the HTML help documentation and to the tree view.\n\nTOC_EXPAND             = NO\n\n# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and\n# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated\n# that can be used as input for Qt's qhelpgenerator to generate a\n# Qt Compressed Help (.qch) of the generated HTML documentation.\n\nGENERATE_QHP           = NO\n\n# If the QHG_LOCATION tag is specified, the QCH_FILE tag can\n# be used to specify the file name of the resulting .qch file.\n# The path specified is relative to the HTML output folder.\n\nQCH_FILE               =\n\n# The QHP_NAMESPACE tag specifies the namespace to use when generating\n# Qt Help Project output. For more information please see\n# http://doc.trolltech.com/qthelpproject.html#namespace\n\nQHP_NAMESPACE          = org.doxygen.Project\n\n# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating\n# Qt Help Project output. For more information please see\n# http://doc.trolltech.com/qthelpproject.html#virtual-folders\n\nQHP_VIRTUAL_FOLDER     = doc\n\n# If QHP_CUST_FILTER_NAME is set, it specifies the name of a custom filter to\n# add. For more information please see\n# http://doc.trolltech.com/qthelpproject.html#custom-filters\n\nQHP_CUST_FILTER_NAME   =\n\n# The QHP_CUST_FILT_ATTRS tag specifies the list of the attributes of the\n# custom filter to add. For more information please see\n# <a href=\"http://doc.trolltech.com/qthelpproject.html#custom-filters\">\n# Qt Help Project / Custom Filters</a>.\n\nQHP_CUST_FILTER_ATTRS  =\n\n# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this\n# project's\n# filter section matches.\n# <a href=\"http://doc.trolltech.com/qthelpproject.html#filter-attributes\">\n# Qt Help Project / Filter Attributes</a>.\n\nQHP_SECT_FILTER_ATTRS  =\n\n# If the GENERATE_QHP tag is set to YES, the QHG_LOCATION tag can\n# be used to specify the location of Qt's qhelpgenerator.\n# If non-empty doxygen will try to run qhelpgenerator on the generated\n# .qhp file.\n\nQHG_LOCATION           =\n\n# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files\n#  will be generated, which together with the HTML files, form an Eclipse help\n# plugin. To install this plugin and make it available under the help contents\n# menu in Eclipse, the contents of the directory containing the HTML and XML\n# files needs to be copied into the plugins directory of eclipse. The name of\n# the directory within the plugins directory should be the same as\n# the ECLIPSE_DOC_ID value. After copying Eclipse needs to be restarted before\n# the help appears.\n\nGENERATE_ECLIPSEHELP   = NO\n\n# A unique identifier for the eclipse help plugin. When installing the plugin\n# the directory name containing the HTML and XML files should also have\n# this name.\n\nECLIPSE_DOC_ID         = org.doxygen.Project\n\n# The DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs)\n# at top of each HTML page. The value NO (the default) enables the index and\n# the value YES disables it. Since the tabs have the same information as the\n# navigation tree you can set this option to NO if you already set\n# GENERATE_TREEVIEW to YES.\n\nDISABLE_INDEX          = NO\n\n# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index\n# structure should be generated to display hierarchical information.\n# If the tag value is set to YES, a side panel will be generated\n# containing a tree-like index structure (just like the one that\n# is generated for HTML Help). For this to work a browser that supports\n# JavaScript, DHTML, CSS and frames is required (i.e. any modern browser).\n# Windows users are probably better off using the HTML help feature.\n# Since the tree basically has the same information as the tab index you\n# could consider to set DISABLE_INDEX to NO when enabling this option.\n\nGENERATE_TREEVIEW      = NO\n\n# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values\n# (range [0,1..20]) that doxygen will group on one line in the generated HTML\n# documentation. Note that a value of 0 will completely suppress the enum\n# values from appearing in the overview section.\n\nENUM_VALUES_PER_LINE   = 4\n\n# By enabling USE_INLINE_TREES, doxygen will generate the Groups, Directories,\n# and Class Hierarchy pages using a tree view instead of an ordered list.\n\nUSE_INLINE_TREES       = NO\n\n# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be\n# used to set the initial width (in pixels) of the frame in which the tree\n# is shown.\n\nTREEVIEW_WIDTH         = 250\n\n# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open\n# links to external symbols imported via tag files in a separate window.\n\nEXT_LINKS_IN_WINDOW    = NO\n\n# Use this tag to change the font size of Latex formulas included\n# as images in the HTML documentation. The default is 10. Note that\n# when you change the font size after a successful doxygen run you need\n# to manually remove any form_*.png images from the HTML output directory\n# to force them to be regenerated.\n\nFORMULA_FONTSIZE       = 10\n\n# Use the FORMULA_TRANPARENT tag to determine whether or not the images\n# generated for formulas are transparent PNGs. Transparent PNGs are\n# not supported properly for IE 6.0, but are supported on all modern browsers.\n# Note that when changing this option you need to delete any form_*.png files\n# in the HTML output before the changes have effect.\n\nFORMULA_TRANSPARENT    = YES\n\n# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax\n# (see http://www.mathjax.org) which uses client side Javascript for the\n# rendering instead of using prerendered bitmaps. Use this if you do not\n# have LaTeX installed or if you want to formulas look prettier in the HTML\n# output. When enabled you also need to install MathJax separately and\n# configure the path to it using the MATHJAX_RELPATH option.\n\nUSE_MATHJAX            = NO\n\n# When MathJax is enabled you need to specify the location relative to the\n# HTML output directory using the MATHJAX_RELPATH option. The destination\n# directory should contain the MathJax.js script. For instance, if the mathjax\n# directory is located at the same level as the HTML output directory, then\n# MATHJAX_RELPATH should be ../mathjax. The default value points to the\n# mathjax.org site, so you can quickly see the result without installing\n# MathJax, but it is strongly recommended to install a local copy of MathJax\n# before deployment.\n\nMATHJAX_RELPATH        = http://www.mathjax.org/mathjax\n\n# The MATHJAX_EXTENSIONS tag can be used to specify one or MathJax extension\n# names that should be enabled during MathJax rendering.\n\nMATHJAX_EXTENSIONS     =\n\n# When the SEARCHENGINE tag is enabled doxygen will generate a search box\n# for the HTML output. The underlying search engine uses javascript\n# and DHTML and should work on any modern browser. Note that when using\n# HTML help (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets\n# (GENERATE_DOCSET) there is already a search function so this one should\n# typically be disabled. For large projects the javascript based search engine\n# can be slow, then enabling SERVER_BASED_SEARCH may provide a better solution.\n\nSEARCHENGINE           = YES\n\n# When the SERVER_BASED_SEARCH tag is enabled the search engine will be\n# implemented using a PHP enabled web server instead of at the web client\n# using Javascript. Doxygen will generate the search PHP script and index\n# file to put on the web server. The advantage of the server\n# based approach is that it scales better to large projects and allows\n# full text search. The disadvantages are that it is more difficult to setup\n# and does not have live searching capabilities.\n\nSERVER_BASED_SEARCH    = NO\n\n#---------------------------------------------------------------------------\n# configuration options related to the LaTeX output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will\n# generate Latex output.\n\nGENERATE_LATEX         = NO\n\n# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be\n# put in front of it. If left blank `latex' will be used as the default path.\n\nLATEX_OUTPUT           = latex\n\n# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be\n# invoked. If left blank `latex' will be used as the default command name.\n# Note that when enabling USE_PDFLATEX this option is only used for\n# generating bitmaps for formulas in the HTML output, but not in the\n# Makefile that is written to the output directory.\n\nLATEX_CMD_NAME         = latex\n\n# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to\n# generate index for LaTeX. If left blank `makeindex' will be used as the\n# default command name.\n\nMAKEINDEX_CMD_NAME     = makeindex\n\n# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact\n# LaTeX documents. This may be useful for small projects and may help to\n# save some trees in general.\n\nCOMPACT_LATEX          = NO\n\n# The PAPER_TYPE tag can be used to set the paper type that is used\n# by the printer. Possible values are: a4, letter, legal and\n# executive. If left blank a4wide will be used.\n\nPAPER_TYPE             = a4\n\n# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX\n# packages that should be included in the LaTeX output.\n\nEXTRA_PACKAGES         =\n\n# The LATEX_HEADER tag can be used to specify a personal LaTeX header for\n# the generated latex document. The header should contain everything until\n# the first chapter. If it is left blank doxygen will generate a\n# standard header. Notice: only use this tag if you know what you are doing!\n\nLATEX_HEADER           =\n\n# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for\n# the generated latex document. The footer should contain everything after\n# the last chapter. If it is left blank doxygen will generate a\n# standard footer. Notice: only use this tag if you know what you are doing!\n\nLATEX_FOOTER           =\n\n# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated\n# is prepared for conversion to pdf (using ps2pdf). The pdf file will\n# contain links (just like the HTML output) instead of page references\n# This makes the output suitable for online browsing using a pdf viewer.\n\nPDF_HYPERLINKS         = YES\n\n# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of\n# plain latex in the generated Makefile. Set this option to YES to get a\n# higher quality PDF documentation.\n\nUSE_PDFLATEX           = YES\n\n# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\\\batchmode.\n# command to the generated LaTeX files. This will instruct LaTeX to keep\n# running if errors occur, instead of asking the user for help.\n# This option is also used when generating formulas in HTML.\n\nLATEX_BATCHMODE        = NO\n\n# If LATEX_HIDE_INDICES is set to YES then doxygen will not\n# include the index chapters (such as File Index, Compound Index, etc.)\n# in the output.\n\nLATEX_HIDE_INDICES     = NO\n\n# If LATEX_SOURCE_CODE is set to YES then doxygen will include\n# source code with syntax highlighting in the LaTeX output.\n# Note that which sources are shown also depends on other settings\n# such as SOURCE_BROWSER.\n\nLATEX_SOURCE_CODE      = NO\n\n# The LATEX_BIB_STYLE tag can be used to specify the style to use for the\n# bibliography, e.g. plainnat, or ieeetr. The default style is \"plain\". See\n# http://en.wikipedia.org/wiki/BibTeX for more info.\n\nLATEX_BIB_STYLE        = plain\n\n#---------------------------------------------------------------------------\n# configuration options related to the RTF output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output\n# The RTF output is optimized for Word 97 and may not look very pretty with\n# other RTF readers or editors.\n\nGENERATE_RTF           = NO\n\n# The RTF_OUTPUT tag is used to specify where the RTF docs will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be\n# put in front of it. If left blank `rtf' will be used as the default path.\n\nRTF_OUTPUT             = rtf\n\n# If the COMPACT_RTF tag is set to YES Doxygen generates more compact\n# RTF documents. This may be useful for small projects and may help to\n# save some trees in general.\n\nCOMPACT_RTF            = NO\n\n# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated\n# will contain hyperlink fields. The RTF file will\n# contain links (just like the HTML output) instead of page references.\n# This makes the output suitable for online browsing using WORD or other\n# programs which support those fields.\n# Note: wordpad (write) and others do not support links.\n\nRTF_HYPERLINKS         = NO\n\n# Load style sheet definitions from file. Syntax is similar to doxygen's\n# config file, i.e. a series of assignments. You only have to provide\n# replacements, missing definitions are set to their default value.\n\nRTF_STYLESHEET_FILE    =\n\n# Set optional variables used in the generation of an rtf document.\n# Syntax is similar to doxygen's config file.\n\nRTF_EXTENSIONS_FILE    =\n\n#---------------------------------------------------------------------------\n# configuration options related to the man page output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_MAN tag is set to YES (the default) Doxygen will\n# generate man pages\n\nGENERATE_MAN           = NO\n\n# The MAN_OUTPUT tag is used to specify where the man pages will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be\n# put in front of it. If left blank `man' will be used as the default path.\n\nMAN_OUTPUT             = man\n\n# The MAN_EXTENSION tag determines the extension that is added to\n# the generated man pages (default is the subroutine's section .3)\n\nMAN_EXTENSION          = .3\n\n# If the MAN_LINKS tag is set to YES and Doxygen generates man output,\n# then it will generate one additional man file for each entity\n# documented in the real man page(s). These additional files\n# only source the real man page, but without them the man command\n# would be unable to find the correct page. The default is NO.\n\nMAN_LINKS              = NO\n\n#---------------------------------------------------------------------------\n# configuration options related to the XML output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_XML tag is set to YES Doxygen will\n# generate an XML file that captures the structure of\n# the code including all documentation.\n\nGENERATE_XML           = NO\n\n# The XML_OUTPUT tag is used to specify where the XML pages will be put.\n# If a relative path is entered the value of OUTPUT_DIRECTORY will be\n# put in front of it. If left blank `xml' will be used as the default path.\n\nXML_OUTPUT             = xml\n\n# The XML_SCHEMA tag can be used to specify an XML schema,\n# which can be used by a validating XML parser to check the\n# syntax of the XML files.\n\nXML_SCHEMA             =\n\n# The XML_DTD tag can be used to specify an XML DTD,\n# which can be used by a validating XML parser to check the\n# syntax of the XML files.\n\nXML_DTD                =\n\n# If the XML_PROGRAMLISTING tag is set to YES Doxygen will\n# dump the program listings (including syntax highlighting\n# and cross-referencing information) to the XML output. Note that\n# enabling this will significantly increase the size of the XML output.\n\nXML_PROGRAMLISTING     = YES\n\n#---------------------------------------------------------------------------\n# configuration options for the AutoGen Definitions output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will\n# generate an AutoGen Definitions (see autogen.sf.net) file\n# that captures the structure of the code including all\n# documentation. Note that this feature is still experimental\n# and incomplete at the moment.\n\nGENERATE_AUTOGEN_DEF   = NO\n\n#---------------------------------------------------------------------------\n# configuration options related to the Perl module output\n#---------------------------------------------------------------------------\n\n# If the GENERATE_PERLMOD tag is set to YES Doxygen will\n# generate a Perl module file that captures the structure of\n# the code including all documentation. Note that this\n# feature is still experimental and incomplete at the\n# moment.\n\nGENERATE_PERLMOD       = NO\n\n# If the PERLMOD_LATEX tag is set to YES Doxygen will generate\n# the necessary Makefile rules, Perl scripts and LaTeX code to be able\n# to generate PDF and DVI output from the Perl module output.\n\nPERLMOD_LATEX          = NO\n\n# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be\n# nicely formatted so it can be parsed by a human reader.\n# This is useful\n# if you want to understand what is going on.\n# On the other hand, if this\n# tag is set to NO the size of the Perl module output will be much smaller\n# and Perl will parse it just the same.\n\nPERLMOD_PRETTY         = YES\n\n# The names of the make variables in the generated doxyrules.make file\n# are prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX.\n# This is useful so different doxyrules.make files included by the same\n# Makefile don't overwrite each other's variables.\n\nPERLMOD_MAKEVAR_PREFIX =\n\n#---------------------------------------------------------------------------\n# Configuration options related to the preprocessor\n#---------------------------------------------------------------------------\n\n# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will\n# evaluate all C-preprocessor directives found in the sources and include\n# files.\n\nENABLE_PREPROCESSING   = YES\n\n# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro\n# names in the source code. If set to NO (the default) only conditional\n# compilation will be performed. Macro expansion can be done in a controlled\n# way by setting EXPAND_ONLY_PREDEF to YES.\n\nMACRO_EXPANSION        = NO\n\n# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES\n# then the macro expansion is limited to the macros specified with the\n# PREDEFINED and EXPAND_AS_DEFINED tags.\n\nEXPAND_ONLY_PREDEF     = NO\n\n# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files\n# pointed to by INCLUDE_PATH will be searched when a #include is found.\n\nSEARCH_INCLUDES        = YES\n\n# The INCLUDE_PATH tag can be used to specify one or more directories that\n# contain include files that are not input files but should be processed by\n# the preprocessor.\n\nINCLUDE_PATH           =\n\n# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard\n# patterns (like *.h and *.hpp) to filter out the header-files in the\n# directories. If left blank, the patterns specified with FILE_PATTERNS will\n# be used.\n\nINCLUDE_FILE_PATTERNS  =\n\n# The PREDEFINED tag can be used to specify one or more macro names that\n# are defined before the preprocessor is started (similar to the -D option of\n# gcc). The argument of the tag is a list of macros of the form: name\n# or name=definition (no spaces). If the definition and the = are\n# omitted =1 is assumed. To prevent a macro definition from being\n# undefined via #undef or recursively expanded use the := operator\n# instead of the = operator.\n\nPREDEFINED             =\n\n# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then\n# this tag can be used to specify a list of macro names that should be expanded.\n# The macro definition that is found in the sources will be used.\n# Use the PREDEFINED tag if you want to use a different macro definition that\n# overrules the definition found in the source code.\n\nEXPAND_AS_DEFINED      =\n\n# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then\n# doxygen's preprocessor will remove all references to function-like macros\n# that are alone on a line, have an all uppercase name, and do not end with a\n# semicolon, because these will confuse the parser if not removed.\n\nSKIP_FUNCTION_MACROS   = YES\n\n#---------------------------------------------------------------------------\n# Configuration::additions related to external references\n#---------------------------------------------------------------------------\n\n# The TAGFILES option can be used to specify one or more tagfiles.\n# Optionally an initial location of the external documentation\n# can be added for each tagfile. The format of a tag file without\n# this location is as follows:\n#\n# TAGFILES = file1 file2 ...\n# Adding location for the tag files is done as follows:\n#\n# TAGFILES = file1=loc1 \"file2 = loc2\" ...\n# where \"loc1\" and \"loc2\" can be relative or absolute paths or\n# URLs. If a location is present for each tag, the installdox tool\n# does not have to be run to correct the links.\n# Note that each tag file must have a unique name\n# (where the name does NOT include the path)\n# If a tag file is not located in the directory in which doxygen\n# is run, you must also specify the path to the tagfile here.\n\nTAGFILES               =\n\n# When a file name is specified after GENERATE_TAGFILE, doxygen will create\n# a tag file that is based on the input files it reads.\n\nGENERATE_TAGFILE       =\n\n# If the ALLEXTERNALS tag is set to YES all external classes will be listed\n# in the class index. If set to NO only the inherited external classes\n# will be listed.\n\nALLEXTERNALS           = NO\n\n# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed\n# in the modules index. If set to NO, only the current project's groups will\n# be listed.\n\nEXTERNAL_GROUPS        = YES\n\n# The PERL_PATH should be the absolute path and name of the perl script\n# interpreter (i.e. the result of `which perl').\n\nPERL_PATH              = /usr/bin/perl\n\n#---------------------------------------------------------------------------\n# Configuration options related to the dot tool\n#---------------------------------------------------------------------------\n\n# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will\n# generate a inheritance diagram (in HTML, RTF and LaTeX) for classes with base\n# or super classes. Setting the tag to NO turns the diagrams off. Note that\n# this option also works with HAVE_DOT disabled, but it is recommended to\n# install and use dot, since it yields more powerful graphs.\n\nCLASS_DIAGRAMS         = YES\n\n# You can define message sequence charts within doxygen comments using the \\msc\n# command. Doxygen will then run the mscgen tool (see\n# http://www.mcternan.me.uk/mscgen/) to produce the chart and insert it in the\n# documentation. The MSCGEN_PATH tag allows you to specify the directory where\n# the mscgen tool resides. If left empty the tool is assumed to be found in the\n# default search path.\n\nMSCGEN_PATH            =\n\n# If set to YES, the inheritance and collaboration graphs will hide\n# inheritance and usage relations if the target is undocumented\n# or is not a class.\n\nHIDE_UNDOC_RELATIONS   = YES\n\n# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is\n# available from the path. This tool is part of Graphviz, a graph visualization\n# toolkit from AT&T and Lucent Bell Labs. The other options in this section\n# have no effect if this option is set to NO (the default)\n\nHAVE_DOT               = NO\n\n# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is\n# allowed to run in parallel. When set to 0 (the default) doxygen will\n# base this on the number of processors available in the system. You can set it\n# explicitly to a value larger than 0 to get control over the balance\n# between CPU load and processing speed.\n\nDOT_NUM_THREADS        = 0\n\n# By default doxygen will use the Helvetica font for all dot files that\n# doxygen generates. When you want a differently looking font you can specify\n# the font name using DOT_FONTNAME. You need to make sure dot is able to find\n# the font, which can be done by putting it in a standard location or by setting\n# the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the\n# directory containing the font.\n\nDOT_FONTNAME           = Helvetica\n\n# The DOT_FONTSIZE tag can be used to set the size of the font of dot graphs.\n# The default size is 10pt.\n\nDOT_FONTSIZE           = 10\n\n# By default doxygen will tell dot to use the Helvetica font.\n# If you specify a different font using DOT_FONTNAME you can use DOT_FONTPATH to\n# set the path where dot can find it.\n\nDOT_FONTPATH           =\n\n# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen\n# will generate a graph for each documented class showing the direct and\n# indirect inheritance relations. Setting this tag to YES will force the\n# CLASS_DIAGRAMS tag to NO.\n\nCLASS_GRAPH            = YES\n\n# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen\n# will generate a graph for each documented class showing the direct and\n# indirect implementation dependencies (inheritance, containment, and\n# class references variables) of the class with other documented classes.\n\nCOLLABORATION_GRAPH    = YES\n\n# If the GROUP_GRAPHS and HAVE_DOT tags are set to YES then doxygen\n# will generate a graph for groups, showing the direct groups dependencies\n\nGROUP_GRAPHS           = YES\n\n# If the UML_LOOK tag is set to YES doxygen will generate inheritance and\n# collaboration diagrams in a style similar to the OMG's Unified Modeling\n# Language.\n\nUML_LOOK               = NO\n\n# If set to YES, the inheritance and collaboration graphs will show the\n# relations between templates and their instances.\n\nTEMPLATE_RELATIONS     = NO\n\n# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT\n# tags are set to YES then doxygen will generate a graph for each documented\n# file showing the direct and indirect include dependencies of the file with\n# other documented files.\n\nINCLUDE_GRAPH          = YES\n\n# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and\n# HAVE_DOT tags are set to YES then doxygen will generate a graph for each\n# documented header file showing the documented files that directly or\n# indirectly include this file.\n\nINCLUDED_BY_GRAPH      = YES\n\n# If the CALL_GRAPH and HAVE_DOT options are set to YES then\n# doxygen will generate a call dependency graph for every global function\n# or class method. Note that enabling this option will significantly increase\n# the time of a run. So in most cases it will be better to enable call graphs\n# for selected functions only using the \\callgraph command.\n\nCALL_GRAPH             = NO\n\n# If the CALLER_GRAPH and HAVE_DOT tags are set to YES then\n# doxygen will generate a caller dependency graph for every global function\n# or class method. Note that enabling this option will significantly increase\n# the time of a run. So in most cases it will be better to enable caller\n# graphs for selected functions only using the \\callergraph command.\n\nCALLER_GRAPH           = NO\n\n# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen\n# will generate a graphical hierarchy of all classes instead of a textual one.\n\nGRAPHICAL_HIERARCHY    = YES\n\n# If the DIRECTORY_GRAPH, SHOW_DIRECTORIES and HAVE_DOT tags are set to YES\n# then doxygen will show the dependencies a directory has on other directories\n# in a graphical way. The dependency relations are determined by the #include\n# relations between the files in the directories.\n\nDIRECTORY_GRAPH        = YES\n\n# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images\n# generated by dot. Possible values are svg, png, jpg, or gif.\n# If left blank png will be used. If you choose svg you need to set\n# HTML_FILE_EXTENSION to xhtml in order to make the SVG files\n# visible in IE 9+ (other browsers do not have this requirement).\n\nDOT_IMAGE_FORMAT       = png\n\n# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to\n# enable generation of interactive SVG images that allow zooming and panning.\n# Note that this requires a modern browser other than Internet Explorer.\n# Tested and working are Firefox, Chrome, Safari, and Opera. For IE 9+ you\n# need to set HTML_FILE_EXTENSION to xhtml in order to make the SVG files\n# visible. Older versions of IE do not have SVG support.\n\nINTERACTIVE_SVG        = NO\n\n# The tag DOT_PATH can be used to specify the path where the dot tool can be\n# found. If left blank, it is assumed the dot tool can be found in the path.\n\nDOT_PATH               =\n\n# The DOTFILE_DIRS tag can be used to specify one or more directories that\n# contain dot files that are included in the documentation (see the\n# \\dotfile command).\n\nDOTFILE_DIRS           =\n\n# The MSCFILE_DIRS tag can be used to specify one or more directories that\n# contain msc files that are included in the documentation (see the\n# \\mscfile command).\n\nMSCFILE_DIRS           =\n\n# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of\n# nodes that will be shown in the graph. If the number of nodes in a graph\n# becomes larger than this value, doxygen will truncate the graph, which is\n# visualized by representing a node as a red box. Note that doxygen if the\n# number of direct children of the root node in a graph is already larger than\n# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note\n# that the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.\n\nDOT_GRAPH_MAX_NODES    = 50\n\n# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the\n# graphs generated by dot. A depth value of 3 means that only nodes reachable\n# from the root by following a path via at most 3 edges will be shown. Nodes\n# that lay further from the root node will be omitted. Note that setting this\n# option to 1 or 2 may greatly reduce the computation time needed for large\n# code bases. Also note that the size of a graph can be further restricted by\n# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.\n\nMAX_DOT_GRAPH_DEPTH    = 0\n\n# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent\n# background. This is disabled by default, because dot on Windows does not\n# seem to support this out of the box. Warning: Depending on the platform used,\n# enabling this option may lead to badly anti-aliased labels on the edges of\n# a graph (i.e. they become hard to read).\n\nDOT_TRANSPARENT        = NO\n\n# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output\n# files in one run (i.e. multiple -o and -T options on the command line). This\n# makes dot run faster, but since only newer versions of dot (>1.8.10)\n# support this, this feature is disabled by default.\n\nDOT_MULTI_TARGETS      = YES\n\n# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will\n# generate a legend page explaining the meaning of the various boxes and\n# arrows in the dot generated graphs.\n\nGENERATE_LEGEND        = YES\n\n# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will\n# remove the intermediate dot files that are used to generate\n# the various graphs.\n\nDOT_CLEANUP            = YES\n"
        },
        {
          "name": "Makefile.am",
          "type": "blob",
          "size": 1.1845703125,
          "content": "AUTOMAKE_OPTIONS = foreign\nACLOCAL_AMFLAGS=-I m4\n\nSUBDIRS = .\n\nif BUILD_TESTS\nSUBDIRS += tests\nendif\n\nlib_LTLIBRARIES = libqrencode.la\n\nlibqrencode_la_SOURCES = qrencode.c qrencode_inner.h \\\n\t\t\t\t\t\t qrinput.c qrinput.h \\\n\t\t\t\t\t\t bitstream.c bitstream.h \\\n\t\t\t\t\t\t qrspec.c qrspec.h \\\n\t\t\t\t\t\t rsecc.c rsecc.h \\\n\t\t\t\t\t\t split.c split.h \\\n\t\t\t\t\t\t mask.c mask.h \\\n\t\t\t\t\t\t mqrspec.c mqrspec.h \\\n\t\t\t\t\t\t mmask.c mmask.h\n\nlibqrencode_la_LDFLAGS = -version-number $(MAJOR_VERSION):$(MINOR_VERSION):$(MICRO_VERSION)\n\ninclude_HEADERS = qrencode.h\n\npkgconfigdir = $(libdir)/pkgconfig\npkgconfig_DATA = libqrencode.pc\nnoinst_DATA = README\nREADME_markdown_optional := $(wildcard README.md)\nREADME: $(README_markdown_optional)\n\t    $(if $(README_markdown_optional), ./makeREADME.sh)\n\nEXTRA_DIST = libqrencode.pc.in autogen.sh configure.ac acinclude.m4 \\\n\t\t\t Makefile.am tests/Makefile.am \\\n\t\t\t qrencode.1.in Doxyfile \\\n\t\t\t CMakeLists.txt cmake/FindIconv.cmake \n\nif BUILD_TOOLS\nbin_PROGRAMS = qrencode\nqrencode_SOURCES = qrenc.c\nqrencode_CFLAGS = $(png_CFLAGS)\nqrencode_LDADD = libqrencode.la $(png_LIBS)\nman1_MANS = qrencode.1\nendif\n\nif MINGW\nlibqrencode_la_LDFLAGS += -no-undefined -avoid-version -Wl,--nxcompat -Wl,--dynamicbase\nendif\n"
        },
        {
          "name": "NEWS",
          "type": "blob",
          "size": 12.9599609375,
          "content": "libqrencode NEWS - Overview of changes\n======================================\n\nVersion 4.1.1 (2020.9.28)\n-------------------------\n* Some minor bugs in Micro QR Code generation have been fixed.\n  * The data capacity calculations are now correct. These bugs probably did not\n    affect the Micro QR Code generation.\n\nVersion 4.1.0 (2020.8.29)\n-------------------------\n* Command line tool \"qrencode\" has been improved:\n\t* New option \"--inline\" has been added. (Thanks to @jp-bennett)\n\t* New option \"--strict-version\" has been added.\n\t* UTF8 mode now supports ANSI256 color. (Thanks to András Veres-\n\t  Szentkirályi)\n* Micro QR Code no longer requires to specify the version number.\n* 'make check' allows to run the test programs. (Thanks to Jan Tojnar)\n* Some compile time warnings have been fixed.\n* Various CMake support improvements. (Thanks to @mgorny and @sdf5)\n* Some minor bug fixes. (Thanks to Lonnie Abelbeck and Frédéric Wang)\n* Some documentation/manpage improvements. (Thanks to Dan Jacobson)\n* Some performance improvements. (Thanks to @4061N and Mika Lindqvist)\n\nRelease Note:\nThe internal representation of the output code has been slightly changed -\nthe second bit from LSB side now represents; 1:ECC bit / 0:data bit.\nThis change is only for debug purposes and does not affect user applications.\n\n\nVersion 4.0.2 (2018.6.6)\n------------------------\n* Build script fixes. (Thanks to @mgorny)\n\n\nVersion 4.0.1 (2018.6.4)\n------------------------\n* CMake support improved.\n* New test scripts have been added.\n* Some compile time warnings have been fixed.\n\n\nVersion 4.0.0 (2017.9.21)\n-------------------------\n* Memory efficiency has been improved.\n* QRcode_clearCache() has been deprecated.\n* Error correction code generating functions have been improved.\n* Command line tool \"qrencode\" has been improved:\n\t* XPM support. (Thanks to Tobias Klauser)\n\t* PNG32 (direct color mode) support. (Thanks to Greg Hart)\n\t* EPS output now supports foreground and background color.\n\t* New options \"-r\" and \"--svg-path\" have been added.\n\t  (Thanks to Robert Petersen and @Oblomov)\n* CMake support has been added. (optional) (Thanks to @misery)\n* Various bug fixes.\n* Various performance improvements.\n\nRelease Note:\nWhile the API has not been changed since the previous major release, we\nincremented the major version number of libqrencode to 4 because the\nimplementation of the library has been largely changed.\n\nThis release improves the performance and memory footprints of code generation.\n\nNow you can build libqrencode with CMake.\n\nIf you build the test programs, please note that the required SDL version has\nbeen changed from 1.2 to 2.0.\n\n\nVersion 3.4.4 (2014.7.24)\n-------------------------\n* Bug fix release. (Thanks to Yoshimichi Inoue)\n* New option \"--verbose\" has been added to the command line tool.\n\nRelease Note:\nWhen only one symbol is generated in structured-append mode, the library had\ninserted unnecessary chunk to the symbol and some QR Code readers fail to read\nit. Now the library omits the chunk and generate a symbol identical to non-\nstructured symbol.\n\nVersion 3.4.3 (2013.8.12)\n-------------------------\n* New option \"--rle\" has been added to the command line tool (Thanks to Daniel\n  Dörrhöfer)\n* Bug fixes. (Thanks to Hassan Hajji, Emmanuel Blot, and ßlúèÇhîp)\n\nRelease Note:\nThis release contains a couple of bug fixes and a new minor feature of the\ncommand line tool. Some minor bugs in the library have been fixed.\n\nRun Length Encoding (RLE) for SVG output decreases the size of the output file,\nbut it makes complicated to edit the image by SVG editors. A newly introduced\ncommand line option \"--rle\" enables RLE. RLE will not be applied if it is not\ngiven.\n\nVersion 3.4.2 (2013.3.1)\n------------------------\n* Bug fix release. (Thanks to chisj, vlad417, Petr and Viona)\n\nRelease Note:\nMicro QR Code encoder had a bug that caused incorrect output (issue #25). Now\nthe bug has been fixed. Memory leak bug (#24) and insufficient string splitting\nbug have been fixed.\n\nVersion 3.4.1 (2012.10.17)\n--------------------------\n* Bug fix release.\n\nRelease Note:\nMutual exclusion did not work correctly since 3.3.1. If your application uses\nlibqrencode in multithreaded environment, it is strongly recommended to update\nit.\n\nVersion 3.4.0 (2012.10.15)\n--------------------------\n* SVG, UTF8, and ANSIUTF8 output supports have been added to the command line\n  tool. (Thanks to Dan Storm, David Dahl, and Lennart Poettering)\n* Colored QR Code support.\n* Bug fixes. (Thanks to Terry Burton, Fred Steinhaeuser, and Yann Droneaud)\n\nRelease Note:\nThree new output format, SVG, UTF8, and ANSIUTF8 have been added to the command\nline tool. UTF8 and ANSIUTF8 are another text art mode, using Unicode block\nelements for high-resolution text output. Long-awaited colored QR code has been\nintroduced. Try \"--foreground\" and \"--background\" options to set the colors.\nCurrently PNG and SVG supports colored output.\n\nVersion 3.3.1 (2012.4.18)\n-------------------------\n* Bugs in command line tool, manual, configure script, and libtool files have\n  been fixed. (Thanks to Yutaka Niibe and Rob Ryan)\n\nVersion 3.3.0 (2012.4.1)\n-------------------------\n* EPS, ANSI, and ASCII text output supports have been added.\n  (Thanks to Zapster, Colin, and Ralf)\n* QRcode_APIVersion() and QRcode_APIVersionString() have been added.\n\nRelease Note:\nThree new output format, EPS, ANSI, and ASCII text, have been added to the\ncommand line tool. ANSI and ASCII mode ignore \"-size\" option. Give \"-t ASCIIi\"\nto get an ASCII-mode symbol in inverted color.\n\nQRcode_APIVersion() is requested by Matthew Baker for better support of Python\nctypes binding. Check them out at https://code.google.com/p/libqrencode-ctypes/\n\nVersion 3.2.1 (2012.4.1)\n------------------------\n* Bugs in configure script and libtool file has been fixed. (Thanks to Yutaka\n  Niibe)\n\nVersion 3.2.0 (2011.11.26)\n--------------------------\n* \"--dpi\" (or \"-d\") option has been added to qrencode. This option set DPI\n  information in an output PNG image. (Thanks to David Dahl)\n* New option \"--enable-thread-safety\" has been added to the configure script\n  that makes the library thread-safe. It is enabled by default.\n* QRcode_encodeData(), QRcode_encodeDataMQR, QRcode_encodeDataStructured() have\n  been added for binary data encoding including '\\0'.\n* Typo and bug fixes.\n* Experimental Micro QR Code support has been added.\n* \"--micro\" (or \"-M\") option for Micro QR Code has been added to qrencode.\n  (experimental)\n\nRelease Note:\nBinary data including '\\0' is now supported. To encode a binary data, give \"-8\"\noption to qrencode, and let qrencode obtain data via standard input like\n\"qrencode -8 -o output.png < binary\". \"--dpi\" and \"-d\" are also added to embed\nDPI information to PNG file.\n\nA bug in the mask pattern evaluation routine has been fixed. In some cases,\nlibqrencode may generate a different symbol from the one that was generated by\nthe prior libqrencode because of this bug fix, but the embedded data are not\naffected. The symbols generated by the old libqrencode are valid.\n\nExperimental support of Micro QR Code encoder has been added. Some functions\n(QRcode_*MQR()) have been added to the library. The command line tool generates\nMicro QR Code when \"--micro\" or \"-M\" is given.\n\nVersion 3.1.1 (2010.2.3)\n------------------------\n* A bug in the library has been fixed.\n\nRelease Note:\nLibqrecode had generated incorrect QR Code in some cases. Symbols larger than\nversion 5 (error correction level Q and H) were affected. In many cases this\nbug did not cause serious damage thanks to the error correction mechanism, but\nwe highly recommend you to encode symbols again using this release.\n\nVersion 3.1.0 (2009.6.6)\n------------------------\n* Various code cleanups and performance improves.\n* Strict internal error checks have been added.\n* \"--without-tests\" has become default setting. Specify \"--with-tests\" to\n  compile test programs.\n* Some memory leak bugs have been fixed.\n\nRelease Note:\nThis release focuses on the code cleanup and performance improve. Encoding time\nhas been improved, drastically in large symbols. Basically this update only\nchanges its internal code. The API is not changed, no need to recompile user\napplications that includes only qrencode.h. If your application refers the\ninternal data representation (not recommended), see ChangeLog for further\ninformation.\n\nVersion 3.0.3 (2008.6.1)\n------------------------\n* Portability enhancement. (Thanks to Gavan Fantom)\n* The command line tool \"qrencode\" now accepts long options. See the man page\n  for the detailed instruction.\n\nRelease Note:\nThis release improves the portability of our command line tool \"qrencode\".\nThe library is not changed so that any applications using libqrencode are not\naffected.\n\nFrom this release, qrencode accepts \"long\" options, such as \"--help\". See the\nmanpage for the detailed instructions.\n\nQrencode now uses getopt_long() instead of getopt_long_only() which is not\navailable in some operating systems. If the getopt_long() is not provided or\nthe implementation of it is not compatible with GNU's one, please try\nqrencode-3.0.3-gnulib, that contains the source code of the getopt_long().\nGnulib version is a test release. If you feel happy with it, please let us know\nand the future releases will include gnulib.\n\nVersion 3.0.2 (2008.5.18)\n-------------------------\n* Some compile-time warnings/errors with g++ have been fixed.\n  (Thanks to wangsai)\n* The bit order of \"Version information\" has been corrected.\n  Symbols greater than version 6 were affected. (Thanks to Paul Janssesn)\n* The \"--without-tests\" option has been added to the configure script.\n\nVersion 3.0.1 (2008.5.9)\n------------------------\n* A bug fix for non-POSIX platform. (Thanks to Paul Janssens)\n* The RPM spec file now packages the man page correctly.\n\nVersion 3.0.0 (2008.4.30)\n-------------------------\n* The interface of QRencode_encodeInput() has been changed. User applications\n  using it must be modified.\n* Structured append support has been added. (patches from Yusuke Mihara)\n* The \"-S\" option for structured append has been added to qrencode and\n  view_qrcode.\n* Some functions now set errno to indicate errors.\n* Some bug fixes.\n\nRelease Note:\nNow libqrencode supports \"structured-append\" of symbols. A large data set can\nbe split into multiple QR code symbols. The basic usage of structured-append\nis not so different from the single symbol encoding: just call\nQRcode_encodeStringStructured() or QRcode_encodeString8bitStructured() and\nthey return a list of symbols. Instead of giving a string, you can encode\nan explicitly typed data. See the manual generated by Doxygen for the detailed\nusage.\n\nMany thanks to Yusuke Mihara, who contributed a patch to add support of\nstructured-append to version 1.0.2.\n\nAPI changes:\n\n* Incompatible API changes:\n  - QRencode_encodeInput\n* New types:\n  - QRinput_Struct\n  - QRcode_List\n* New functions:\n  - QRinput_new2\n  - QRinput_Struct_new\n  - QRinput_Struct_setParity\n  - QRinput_Struct_appendInput\n  - QRinput_Struct_free\n  - QRinput_Struct_insertStructuredAppendHeaders\n  - QRinput_splitQRinputToStruct\n  - QRcode_encodeStructuredInput\n  - QRcode_encodeStringStructured\n  - QRcode_encodeString8bitStructured\n  - QRcode_List_size\n  - QRcode_List_free\n* Declarations moved to qrencode.h:\n  - QRinput_getErrorCorrectionLevel\n  - QRinput_setErrorCorrectionLevel\n  - QRinput_getVersion\n  - QRinput_setVersion\n\nVersion 2.0.0 (2008.1.24)\n-------------------------\n* \"-i\" option to ignore case distinctions has been added to qrencode and\n  view_qrcode.\n* \"-c\" option (case-sensitive mode) of qrencode is now enabled by default and\n  has been improved. See details in Release Note section.\n* \"-8\" option has been added to qrencode to encode whole data in 8-bit mode.\n* tests/view_qrcode now accepts various options like qrencode.\n* Man page has been added.\n* Code cleanup.\n* The mask evaluation bug has been fixed. (Philippe Delcroix)\n\n* API changes\n  - QRcode_encodeString() now receives case-sensitive flag.\n  - QRcode_encodeStringCase() has been removed.\n  - QRcode_encodeString8bit() has been added.\n\nRelease Note:\nPreviously libqrencode encodes lower-case alphabet characters in Alphabet-\nNumeric mode (upper-case alphabet and numeric) by default. According to the\nspecification of QR code, however, it is clearly claimed that Alphabet-Numeric\nmode provides only upper-case alphabet (+ numeric and some symbol) characters.\nSince this version, libqrencode distinguishes lower-case and upper-case of\nalphabet characters by default. Because of that, \"-c\" option of qrencode\nis now deprecated, and \"-i\" option has been added. By giving \"-i\", qrencode\nconverts lower-case characters to upper-case if possible, then encode a QR code\nsymbol. Please read qrencode.h for the details about API changes if you are\ngoing to use this library.\n\nMany thanks to NANKI Haruo for his suggestions.\n\nVersion 1.0.2 (2007.03.24)\n--------------------------\n* A small bug fix. (Thanks to NANKI Haruo)\n* 'extern \"C\"' barrier has been added to qrencode.h.\n\nVersion 1.0.1 (2006.12.27)\n--------------------------\n* Added \"force 8-bit encoding mode\".\n* Configure script finds libpng's header correctly.\n\nVersion 1.0.0 (2006.12.12)\n--------------------------\n* The first public release.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.35546875,
          "content": "# libqrencode - a fast and compact QR Code encoding library [![Build Status](https://travis-ci.org/fukuchi/libqrencode.png?branch=master)](https://travis-ci.org/fukuchi/libqrencode)\n\n**Attention:** This repository contains the development version of libqrencode. See <https://fukuchi.org/works/qrencode/> for the official stable releases. At this moment, the latest stable release is version 4.1.1.\n\nGENERAL INFORMATION\n===================\nLibqrencode is a fast and compact library for encoding data in a QR Code,\na 2D symbology that can be scanned by handy terminals such as a smartphone.\nThe capacity of QR Code is up to 7000 digits or 4000 characters and has high\nrobustness.\n\nLibqrencode accepts a string or a list of data chunks then encodes in a QR Code\nsymbol as a bitmap array. While other QR Code applications generate an image\nfile, using libqrencode allows applications to render QR Code symbols from raw\nbitmap data directly. This library also contains a command-line utility outputs\nQR Code images in various formats.\n\n\nSPECIFICATION\n=============\nLibqrencode supports QR Code model 2, described in JIS (Japanese Industrial\nStandards) X0510:2004 or ISO/IEC 18004. Most of features in the specification\nare implemented such as:\n\n- Numeric, alphabet, Japanese kanji (Shift-JIS) or any 8 bit code can be\n  embedded\n- Optimized encoding of a string\n- Structured-append of symbols\n- Micro QR Code (experimental)\n\nCurrently the following features are not supported:\n\n- ECI and FNC1 mode\n- QR Code model 1 (deprecated)\n\n\nINSTALL\n=======\n\nRequirements\n------------\nWhile the command-line utility and some test programs use libpng or SDL 2.0,\nthe libqrencode library itself has no dependencies. You can skip compiling\ntests and/or tools if you want not to install programs using SDL or PNG.\n\nCompile & install\n-----------------\nIf there is no \"configure\" script in the source code directory, run\n\"autogen.sh\" at first to generate it - this is mandatory if you downloaded the\nsource from GitHub. Some additional software is needed to complete this\nprocess. For example, in Ubuntu, the following packages are needed:\n\n- autoconf\n- automake\n- autotools-dev\n- libtool\n- pkg-config\n- libpng12-dev\n\nYou can skip this process if you have \"configure\" script already (typically\nwhen you downloaded the source tarball from fukuchi.org.)\n\nNow you are ready to compile the library and tool. Type the following commands:\n\n```\n./configure\nmake\nsudo make install\nsudo ldconfig\n```\n\nThis compiles and installs the library and header file to the appropriate\ndirectories: by default, /usr/local/lib and /usr/local/include. You can change\nthe destination directory by passing some options to the configure script.\nRun \"./configure --help\" to see the list of options.\n\nIt also installs a command line tool \"qrencode\" to /usr/local/bin. If you want\nnot to build it, give \"--without-tools\" option to the configure script.\n\nIf the configure script does not work well, try to use CMake.\n\n```\ncmake .\nmake\n```\n\nWhen you want to build the test programs, give \"--with-tests\" option to\nconfigure, or \"-DWITH\\_TESTS=YES\" to cmake.\n\n### Building libqrencode with vcpkg\n\nYou can download and install libqrencode using the\n[vcpkg](https://github.com/Microsoft/vcpkg) dependency manager:\n   \n```\ngit clone https://github.com/Microsoft/vcpkg.git\ncd vcpkg\n./bootstrap-vcpkg.sh\n./vcpkg integrate install\n./vcpkg install libqrencode\n```\n    \nThe libqrencode port in vcpkg is kept up to date by Microsoft team members and\ncommunity contributors. If the version is out of date, please\n[create an issue or pull request](https://github.com/Microsoft/vcpkg) on the\nvcpkg repository.\n\n\nUSAGE\n=====\nBasic usages of this library are written in the header file (qrencode.h).\nYou can generate a manual of the library by using Doxygen, or see\n\nhttps://fukuchi.org/works/qrencode/manual/index.html\n\n\nWARNINGS\n========\nThe library is distributed WITHOUT ANY WARRANTY.\n\nMicro QR Code support is EXPERIMENTAL.\n\nBe careful to use the command line tool (qrencode) if it is used by a web\napplication (e.g. CGI script). For example, giving \"-s\" option with a large\nnumber to qrencode may cause DoS. The parameters should be checked by the\napplication.\n\n\nLICENSING INFORMATION\n=====================\nCopyright (C) 2006-2018 Kentaro Fukuchi\n\nThis library is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License as published by the Free\nSoftware Foundation; either version 2.1 of the License, or any later version.\n\nThis library is distributed in the hope that it will be useful, but WITHOUT ANY\nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\nPARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License along\nwith this library; if not, write to the Free Software Foundation, Inc., 51\nFranklin St, Fifth Floor, Boston, MA 02110-1301 USA\n\n\nCONTACT\n=======\nVisit the homepage at:\n\nhttps://fukuchi.org/works/qrencode/\n\nfor new releases. The git repository is available at:\n\nhttps://github.com/fukuchi/libqrencode\n\nPlease mail any bug reports, suggestions, comments, and questions to:\n\nKentaro Fukuchi <kentaro@fukuchi.org>\n\nor submit issues to:\n\nhttps://github.com/fukuchi/libqrencode/issues\n\n\nACKNOWLEDGMENTS\n===============\nQR Code is registered trademarks of DENSO WAVE INCORPORATED in JAPAN and other\ncountries.\n\nReed-Solomon encoder included in this library is originally taken from FEC\nlibrary developed by Phil Karn (KA9Q) and distributed under the terms of the\nGNU LGPL, then rewritten by Kentaro Fukuchi.\nCopyright (C) 2002, 2003, 2004, 2006 Phil Karn, KA9Q\n\n* NANKI Haruo           - improved lower-case characters encoding\n* Katsumi Saito         - SPEC file\n* Philippe Delcroix     - improved mask evaluation\n* Yusuke Mihara         - structured-append support\n* David Dahl            - DPI and SVG support patch\n* Adam Shepherd         - bug fix patch of the mask evaluation\n* Josef Eisl (@zapster) - EPS support patch\n* Colin (@moshen)       - ANSI support patch\n* Ralf Ertzinger        - ASCII support patch\n* Yutaka Niibe (@gniibe)- various bug fix patches\n* Dan Storm (@Repox)    - SVG support patch\n* Lennart Poettering (@mezcalero)\n                        - improved text art patch\n* Yann Droneaud         - improved input validation patch\n* Viona                 - bug fix patch for string splitting\n* Daniel Dörrhöfer (@d4ndo)\n                        - RLE option, some bug fixes, Travis configuration\n* Greg Hart             - PNG32 support patch\n* @siggi-heltau         - bug fix patch\n* Tobias Klauser (@tklauser)\n                        - bug fix patch, XPM support patch\n* Robert Petersen (@ripetersen)\n                        - added ability to read input data from a file\n* @Oblomov              - improved SVG support patch\n* Michał Górny (@mgorny)\n                        - reverse mappings of UTF8 and ANSIUTF8, build script\n                          fixes\n* @EckoEdc              - MinGW support patch\n* Sebastian Buchwald (@UniQP)\n                        - Various code cleanups\n* André Klitzing (@misery)\n                        - CMake support\n* Alexey Nikolaev (@aleksey-nikolaev)\n                        - improved CMake support\n* Vilppu Vuorinen (@vilppuvuorinen)\n                        - improved CMake support\n* @vanillahsu           - bug fix patch\n* @Ation                - bug fix patch\n* Jonathan Bennett      - Added \"--inline\" option to qrencode\n* András Veres-Szentkirályi\n                        - ANSI256UTF8 support\n* @sdf5                 - improved CMake support\n* Lonnie Abelbeck (@abelbeck)\n                        - bug fix patch\n* @4061N                - performance improvement patch\n* Rosen Penev (@neheb)  - CMake bug fix patch\n* Mika Lindqvist (@mtl1979)\n                        - replacement for gettimeofday() for Windows.\n* Shigeyuki Hirai, Paul Janssens, wangsai, Gavan Fantom, Matthew Baker,\n  Rob Ryan, Fred Steinhaeuser, Terry Burton, @chisj, @vlad417, Petr,\n  Hassan Hajji, Emmanuel Blot, ßlúèÇhîp, Heiko Becker, Gavin Andresen,\n  David Binderman, @ralgozino, Sean McMurray, Vlad Bespalov (@win32asm),\n  Antenore Gatta, Yoshimichi Inoue, Sunil Maganally, Norman Gray,\n  Danomi Manchego, @minus7, Ian Sweet, @qianchenglenger, Ronald Michaels,\n  Yuji Ueno, Jakub Wilk, @KangLin, @c-273, @thebunnyrules, @NancyLi1013,\n  Frédéric Wang, Dan Jacobson, Jan Tojnar, @xiaoyur347, @charmander\n                        - bug report / suggestion / typo fixes\n"
        },
        {
          "name": "TODO",
          "type": "blob",
          "size": 0.2373046875,
          "content": "Micro QR code encoding is not tested well.\n\nDocuments (not only the README, but also the manual of the library) needs\nrevision of grammar, spelling or to resolve ambiguity or incomplete descriptions.\nFeel really free to send us your revision.\n"
        },
        {
          "name": "acinclude.m4",
          "type": "blob",
          "size": 53.19921875,
          "content": "# iconv.m4 serial 19 (gettext-0.18.2)\ndnl Copyright (C) 2000-2002, 2007-2014 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_DEFUN([AM_ICONV_LINKFLAGS_BODY],\n[\n  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n\n  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([iconv])\n])\n\nAC_DEFUN([AM_ICONV_LINK],\n[\n  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and\n  dnl those with the standalone portable GNU libiconv installed).\n  AC_REQUIRE([AC_CANONICAL_HOST]) dnl for cross-compiles\n\n  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV\n  dnl accordingly.\n  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])\n\n  dnl Add $INCICONV to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed libiconv and not disabled its use\n  dnl via --without-libiconv-prefix, he wants to use it. The first\n  dnl AC_LINK_IFELSE will then fail, the second AC_LINK_IFELSE will succeed.\n  am_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])\n\n  AC_CACHE_CHECK([for iconv], [am_cv_func_iconv], [\n    am_cv_func_iconv=\"no, consider installing GNU libiconv\"\n    am_cv_lib_iconv=no\n    AC_LINK_IFELSE(\n      [AC_LANG_PROGRAM(\n         [[\n#include <stdlib.h>\n#include <iconv.h>\n         ]],\n         [[iconv_t cd = iconv_open(\"\",\"\");\n           iconv(cd,NULL,NULL,NULL,NULL);\n           iconv_close(cd);]])],\n      [am_cv_func_iconv=yes])\n    if test \"$am_cv_func_iconv\" != yes; then\n      am_save_LIBS=\"$LIBS\"\n      LIBS=\"$LIBS $LIBICONV\"\n      AC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[\n#include <stdlib.h>\n#include <iconv.h>\n           ]],\n           [[iconv_t cd = iconv_open(\"\",\"\");\n             iconv(cd,NULL,NULL,NULL,NULL);\n             iconv_close(cd);]])],\n        [am_cv_lib_iconv=yes]\n        [am_cv_func_iconv=yes])\n      LIBS=\"$am_save_LIBS\"\n    fi\n  ])\n  if test \"$am_cv_func_iconv\" = yes; then\n    AC_CACHE_CHECK([for working iconv], [am_cv_func_iconv_works], [\n      dnl This tests against bugs in AIX 5.1, AIX 6.1..7.1, HP-UX 11.11,\n      dnl Solaris 10.\n      am_save_LIBS=\"$LIBS\"\n      if test $am_cv_lib_iconv = yes; then\n        LIBS=\"$LIBS $LIBICONV\"\n      fi\n      am_cv_func_iconv_works=no\n      for ac_iconv_const in '' 'const'; do\n        AC_RUN_IFELSE(\n          [AC_LANG_PROGRAM(\n             [[\n#include <iconv.h>\n#include <string.h>\n\n#ifndef ICONV_CONST\n# define ICONV_CONST $ac_iconv_const\n#endif\n             ]],\n             [[int result = 0;\n  /* Test against AIX 5.1 bug: Failures are not distinguishable from successful\n     returns.  */\n  {\n    iconv_t cd_utf8_to_88591 = iconv_open (\"ISO8859-1\", \"UTF-8\");\n    if (cd_utf8_to_88591 != (iconv_t)(-1))\n      {\n        static ICONV_CONST char input[] = \"\\342\\202\\254\"; /* EURO SIGN */\n        char buf[10];\n        ICONV_CONST char *inptr = input;\n        size_t inbytesleft = strlen (input);\n        char *outptr = buf;\n        size_t outbytesleft = sizeof (buf);\n        size_t res = iconv (cd_utf8_to_88591,\n                            &inptr, &inbytesleft,\n                            &outptr, &outbytesleft);\n        if (res == 0)\n          result |= 1;\n        iconv_close (cd_utf8_to_88591);\n      }\n  }\n  /* Test against Solaris 10 bug: Failures are not distinguishable from\n     successful returns.  */\n  {\n    iconv_t cd_ascii_to_88591 = iconv_open (\"ISO8859-1\", \"646\");\n    if (cd_ascii_to_88591 != (iconv_t)(-1))\n      {\n        static ICONV_CONST char input[] = \"\\263\";\n        char buf[10];\n        ICONV_CONST char *inptr = input;\n        size_t inbytesleft = strlen (input);\n        char *outptr = buf;\n        size_t outbytesleft = sizeof (buf);\n        size_t res = iconv (cd_ascii_to_88591,\n                            &inptr, &inbytesleft,\n                            &outptr, &outbytesleft);\n        if (res == 0)\n          result |= 2;\n        iconv_close (cd_ascii_to_88591);\n      }\n  }\n  /* Test against AIX 6.1..7.1 bug: Buffer overrun.  */\n  {\n    iconv_t cd_88591_to_utf8 = iconv_open (\"UTF-8\", \"ISO-8859-1\");\n    if (cd_88591_to_utf8 != (iconv_t)(-1))\n      {\n        static ICONV_CONST char input[] = \"\\304\";\n        static char buf[2] = { (char)0xDE, (char)0xAD };\n        ICONV_CONST char *inptr = input;\n        size_t inbytesleft = 1;\n        char *outptr = buf;\n        size_t outbytesleft = 1;\n        size_t res = iconv (cd_88591_to_utf8,\n                            &inptr, &inbytesleft,\n                            &outptr, &outbytesleft);\n        if (res != (size_t)(-1) || outptr - buf > 1 || buf[1] != (char)0xAD)\n          result |= 4;\n        iconv_close (cd_88591_to_utf8);\n      }\n  }\n#if 0 /* This bug could be worked around by the caller.  */\n  /* Test against HP-UX 11.11 bug: Positive return value instead of 0.  */\n  {\n    iconv_t cd_88591_to_utf8 = iconv_open (\"utf8\", \"iso88591\");\n    if (cd_88591_to_utf8 != (iconv_t)(-1))\n      {\n        static ICONV_CONST char input[] = \"\\304rger mit b\\366sen B\\374bchen ohne Augenma\\337\";\n        char buf[50];\n        ICONV_CONST char *inptr = input;\n        size_t inbytesleft = strlen (input);\n        char *outptr = buf;\n        size_t outbytesleft = sizeof (buf);\n        size_t res = iconv (cd_88591_to_utf8,\n                            &inptr, &inbytesleft,\n                            &outptr, &outbytesleft);\n        if ((int)res > 0)\n          result |= 8;\n        iconv_close (cd_88591_to_utf8);\n      }\n  }\n#endif\n  /* Test against HP-UX 11.11 bug: No converter from EUC-JP to UTF-8 is\n     provided.  */\n  if (/* Try standardized names.  */\n      iconv_open (\"UTF-8\", \"EUC-JP\") == (iconv_t)(-1)\n      /* Try IRIX, OSF/1 names.  */\n      && iconv_open (\"UTF-8\", \"eucJP\") == (iconv_t)(-1)\n      /* Try AIX names.  */\n      && iconv_open (\"UTF-8\", \"IBM-eucJP\") == (iconv_t)(-1)\n      /* Try HP-UX names.  */\n      && iconv_open (\"utf8\", \"eucJP\") == (iconv_t)(-1))\n    result |= 16;\n  return result;\n]])],\n          [am_cv_func_iconv_works=yes], ,\n          [case \"$host_os\" in\n             aix* | hpux*) am_cv_func_iconv_works=\"guessing no\" ;;\n             *)            am_cv_func_iconv_works=\"guessing yes\" ;;\n           esac])\n        test \"$am_cv_func_iconv_works\" = no || break\n      done\n      LIBS=\"$am_save_LIBS\"\n    ])\n    case \"$am_cv_func_iconv_works\" in\n      *no) am_func_iconv=no am_cv_lib_iconv=no ;;\n      *)   am_func_iconv=yes ;;\n    esac\n  else\n    am_func_iconv=no am_cv_lib_iconv=no\n  fi\n  if test \"$am_func_iconv\" = yes; then\n    AC_DEFINE([HAVE_ICONV], [1],\n      [Define if you have the iconv() function and it works.])\n  fi\n  if test \"$am_cv_lib_iconv\" = yes; then\n    AC_MSG_CHECKING([how to link with libiconv])\n    AC_MSG_RESULT([$LIBICONV])\n  else\n    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV\n    dnl either.\n    CPPFLAGS=\"$am_save_CPPFLAGS\"\n    LIBICONV=\n    LTLIBICONV=\n  fi\n  AC_SUBST([LIBICONV])\n  AC_SUBST([LTLIBICONV])\n])\n\ndnl Define AM_ICONV using AC_DEFUN_ONCE for Autoconf >= 2.64, in order to\ndnl avoid warnings like\ndnl \"warning: AC_REQUIRE: `AM_ICONV' was expanded before it was required\".\ndnl This is tricky because of the way 'aclocal' is implemented:\ndnl - It requires defining an auxiliary macro whose name ends in AC_DEFUN.\ndnl   Otherwise aclocal's initial scan pass would miss the macro definition.\ndnl - It requires a line break inside the AC_DEFUN_ONCE and AC_DEFUN expansions.\ndnl   Otherwise aclocal would emit many \"Use of uninitialized value $1\"\ndnl   warnings.\nm4_define([gl_iconv_AC_DEFUN],\n  m4_version_prereq([2.64],\n    [[AC_DEFUN_ONCE(\n        [$1], [$2])]],\n    [m4_ifdef([gl_00GNULIB],\n       [[AC_DEFUN_ONCE(\n           [$1], [$2])]],\n       [[AC_DEFUN(\n           [$1], [$2])]])]))\ngl_iconv_AC_DEFUN([AM_ICONV],\n[\n  AM_ICONV_LINK\n  if test \"$am_cv_func_iconv\" = yes; then\n    AC_MSG_CHECKING([for iconv declaration])\n    AC_CACHE_VAL([am_cv_proto_iconv], [\n      AC_COMPILE_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[\n#include <stdlib.h>\n#include <iconv.h>\nextern\n#ifdef __cplusplus\n\"C\"\n#endif\n#if defined(__STDC__) || defined(_MSC_VER) || defined(__cplusplus)\nsize_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\n#else\nsize_t iconv();\n#endif\n           ]],\n           [[]])],\n        [am_cv_proto_iconv_arg1=\"\"],\n        [am_cv_proto_iconv_arg1=\"const\"])\n      am_cv_proto_iconv=\"extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);\"])\n    am_cv_proto_iconv=`echo \"[$]am_cv_proto_iconv\" | tr -s ' ' | sed -e 's/( /(/'`\n    AC_MSG_RESULT([\n         $am_cv_proto_iconv])\n    AC_DEFINE_UNQUOTED([ICONV_CONST], [$am_cv_proto_iconv_arg1],\n      [Define as const if the declaration of iconv() needs const.])\n    dnl Also substitute ICONV_CONST in the gnulib generated <iconv.h>.\n    m4_ifdef([gl_ICONV_H_DEFAULTS],\n      [AC_REQUIRE([gl_ICONV_H_DEFAULTS])\n       if test -n \"$am_cv_proto_iconv_arg1\"; then\n         ICONV_CONST=\"const\"\n       fi\n      ])\n  fi\n])\n# lib-ld.m4 serial 6\ndnl Copyright (C) 1996-2003, 2009-2013 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl Subroutines of libtool.m4,\ndnl with replacements s/_*LT_PATH/AC_LIB_PROG/ and s/lt_/acl_/ to avoid\ndnl collision with libtool.m4.\n\ndnl From libtool-2.4. Sets the variable with_gnu_ld to yes or no.\nAC_DEFUN([AC_LIB_PROG_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], [acl_cv_prog_gnu_ld],\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  acl_cv_prog_gnu_ld=yes\n  ;;\n*)\n  acl_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$acl_cv_prog_gnu_ld\n])\n\ndnl From libtool-2.4. Sets the variable LD.\nAC_DEFUN([AC_LIB_PROG_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n        [assume the C compiler uses GNU ld [default=no]])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\n# Prepare PATH_SEPARATOR.\n# The user is always right.\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  # Determine PATH_SEPARATOR by trying to find /bin/sh in a PATH which\n  # contains only /bin. Note that ksh looks also at the FPATH variable,\n  # so we have to set that as well for the test.\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 \\\n    && { (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 \\\n           || PATH_SEPARATOR=';'\n       }\nfi\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`echo \"$ac_prog\"| sed 's%\\\\\\\\%/%g'`\n      while echo \"$ac_prog\" | grep \"$re_direlt\" > /dev/null 2>&1; do\n        ac_prog=`echo $ac_prog| sed \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL([acl_cv_path_LD],\n[if test -z \"$LD\"; then\n  acl_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$acl_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      acl_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$acl_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n        test \"$with_gnu_ld\" != no && break\n        ;;\n      *)\n        test \"$with_gnu_ld\" != yes && break\n        ;;\n      esac\n    fi\n  done\n  IFS=\"$acl_save_ifs\"\nelse\n  acl_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$acl_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT([$LD])\nelse\n  AC_MSG_RESULT([no])\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\nAC_LIB_PROG_LD_GNU\n])\n# lib-link.m4 serial 26 (gettext-0.18.2)\ndnl Copyright (C) 2001-2013 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ([2.54])\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  pushdef([Name],[m4_translit([$1],[./+-], [____])])\n  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],\n                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n    ac_cv_lib[]Name[]_prefix=\"$LIB[]NAME[]_PREFIX\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  LIB[]NAME[]_PREFIX=\"$ac_cv_lib[]Name[]_prefix\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  popdef([NAME])\n  popdef([Name])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode, [missing-message])\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. The missing-message\ndnl defaults to 'no' and may contain additional hints for the user.\ndnl If found, it sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME}\ndnl and LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\ndnl Sets and AC_SUBSTs the LIB${NAME}_PREFIX variable to nonempty if libname\ndnl was found in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  pushdef([Name],[m4_translit([$1],[./+-], [____])])\n  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],\n                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, he wants to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    dnl If $LIB[]NAME contains some -l options, add it to the end of LIBS,\n    dnl because these -l options might require -L options that are present in\n    dnl LIBS. -l options benefit only from the -L options listed before it.\n    dnl Otherwise, add it to the front of LIBS, because it may be a static\n    dnl library that depends on another static library that is present in LIBS.\n    dnl Static libraries benefit only from the static libraries listed after\n    dnl it.\n    case \" $LIB[]NAME\" in\n      *\" -l\"*) LIBS=\"$LIBS $LIB[]NAME\" ;;\n      *)       LIBS=\"$LIB[]NAME $LIBS\" ;;\n    esac\n    AC_LINK_IFELSE(\n      [AC_LANG_PROGRAM([[$3]], [[$4]])],\n      [ac_cv_lib[]Name=yes],\n      [ac_cv_lib[]Name='m4_if([$5], [], [no], [[$5]])'])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the lib][$1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n    LIB[]NAME[]_PREFIX=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  AC_SUBST([LIB]NAME[_PREFIX])\n  popdef([NAME])\n  popdef([Name])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl   acl_libext,\ndnl   acl_shlibext,\ndnl   acl_libname_spec,\ndnl   acl_library_names_spec,\ndnl   acl_hardcode_libdir_flag_spec,\ndnl   acl_hardcode_libdir_separator,\ndnl   acl_hardcode_direct,\ndnl   acl_hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], [acl_cv_rpath], [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  acl_libext=\"$acl_cv_libext\"\n  acl_shlibext=\"$acl_cv_shlibext\"\n  acl_libname_spec=\"$acl_cv_libname_spec\"\n  acl_library_names_spec=\"$acl_cv_library_names_spec\"\n  acl_hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  acl_hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  acl_hardcode_direct=\"$acl_cv_hardcode_direct\"\n  acl_hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE([rpath],\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_FROMPACKAGE(name, package)\ndnl declares that libname comes from the given package. The configure file\ndnl will then not have a --with-libname-prefix option but a\ndnl --with-package-prefix option. Several libraries can come from the same\ndnl package. This declaration must occur before an AC_LIB_LINKFLAGS or similar\ndnl macro call that searches for libname.\nAC_DEFUN([AC_LIB_FROMPACKAGE],\n[\n  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],\n                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])\n  define([acl_frompackage_]NAME, [$2])\n  popdef([NAME])\n  pushdef([PACK],[$2])\n  pushdef([PACKUP],[m4_translit(PACK,[abcdefghijklmnopqrstuvwxyz./+-],\n                                     [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])\n  define([acl_libsinpackage_]PACKUP,\n    m4_ifdef([acl_libsinpackage_]PACKUP, [m4_defn([acl_libsinpackage_]PACKUP)[, ]],)[lib$1])\n  popdef([PACKUP])\n  popdef([PACK])\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\ndnl Also, sets the LIB${NAME}_PREFIX variable to nonempty if libname was found\ndnl in ${LIB${NAME}_PREFIX}/$acl_libdirstem.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  pushdef([NAME],[m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./+-],\n                                   [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])\n  pushdef([PACK],[m4_ifdef([acl_frompackage_]NAME, [acl_frompackage_]NAME, lib[$1])])\n  pushdef([PACKUP],[m4_translit(PACK,[abcdefghijklmnopqrstuvwxyz./+-],\n                                     [ABCDEFGHIJKLMNOPQRSTUVWXYZ____])])\n  pushdef([PACKLIBS],[m4_ifdef([acl_frompackage_]NAME, [acl_libsinpackage_]PACKUP, lib[$1])])\n  dnl Autoconf >= 2.61 supports dots in --with options.\n  pushdef([P_A_C_K],[m4_if(m4_version_compare(m4_defn([m4_PACKAGE_VERSION]),[2.61]),[-1],[m4_translit(PACK,[.],[_])],PACK)])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_ARG_WITH(P_A_C_K[-prefix],\n[[  --with-]]P_A_C_K[[-prefix[=DIR]  search for ]PACKLIBS[ in DIR/include and DIR/lib\n  --without-]]P_A_C_K[[-prefix     don't search for ]PACKLIBS[ in includedir and libdir]],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n        if test \"$acl_libdirstem2\" != \"$acl_libdirstem\" \\\n           && ! test -d \"$withval/$acl_libdirstem\"; then\n          additional_libdir=\"$withval/$acl_libdirstem2\"\n        fi\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-seach.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  LIB[]NAME[]_PREFIX=\n  dnl HAVE_LIB${NAME} is an indicator that LIB${NAME}, LTLIB${NAME} have been\n  dnl computed. So it has to be reset here.\n  HAVE_LIB[]NAME=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./+-|ABCDEFGHIJKLMNOPQRSTUVWXYZ____|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          eval libname=\\\"$acl_libname_spec\\\"    # typically: libname=lib$name\n          if test -n \"$acl_shlibext\"; then\n            shrext=\".$acl_shlibext\"             # typically: shrext=.so\n          else\n            shrext=\n          fi\n          if test $use_additional = yes; then\n            dir=\"$additional_libdir\"\n            dnl The same code as in the loop below:\n            dnl First look for a shared library.\n            if test -n \"$acl_shlibext\"; then\n              if test -f \"$dir/$libname$shrext\"; then\n                found_dir=\"$dir\"\n                found_so=\"$dir/$libname$shrext\"\n              else\n                if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                  ver=`(cd \"$dir\" && \\\n                        for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                        | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                        | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                        | sed 1q ) 2>/dev/null`\n                  if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                    found_dir=\"$dir\"\n                    found_so=\"$dir/$libname$shrext.$ver\"\n                  fi\n                else\n                  eval library_names=\\\"$acl_library_names_spec\\\"\n                  for f in $library_names; do\n                    if test -f \"$dir/$f\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$f\"\n                      break\n                    fi\n                  done\n                fi\n              fi\n            fi\n            dnl Then look for a static library.\n            if test \"X$found_dir\" = \"X\"; then\n              if test -f \"$dir/$libname.$acl_libext\"; then\n                found_dir=\"$dir\"\n                found_a=\"$dir/$libname.$acl_libext\"\n              fi\n            fi\n            if test \"X$found_dir\" != \"X\"; then\n              if test -f \"$dir/$libname.la\"; then\n                found_la=\"$dir/$libname.la\"\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  dnl First look for a shared library.\n                  if test -n \"$acl_shlibext\"; then\n                    if test -f \"$dir/$libname$shrext\"; then\n                      found_dir=\"$dir\"\n                      found_so=\"$dir/$libname$shrext\"\n                    else\n                      if test \"$acl_library_names_spec\" = '$libname$shrext$versuffix'; then\n                        ver=`(cd \"$dir\" && \\\n                              for f in \"$libname$shrext\".*; do echo \"$f\"; done \\\n                              | sed -e \"s,^$libname$shrext\\\\\\\\.,,\" \\\n                              | sort -t '.' -n -r -k1,1 -k2,2 -k3,3 -k4,4 -k5,5 \\\n                              | sed 1q ) 2>/dev/null`\n                        if test -n \"$ver\" && test -f \"$dir/$libname$shrext.$ver\"; then\n                          found_dir=\"$dir\"\n                          found_so=\"$dir/$libname$shrext.$ver\"\n                        fi\n                      else\n                        eval library_names=\\\"$acl_library_names_spec\\\"\n                        for f in $library_names; do\n                          if test -f \"$dir/$f\"; then\n                            found_dir=\"$dir\"\n                            found_so=\"$dir/$f\"\n                            break\n                          fi\n                        done\n                      fi\n                    fi\n                  fi\n                  dnl Then look for a static library.\n                  if test \"X$found_dir\" = \"X\"; then\n                    if test -f \"$dir/$libname.$acl_libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/$libname.$acl_libext\"\n                    fi\n                  fi\n                  if test \"X$found_dir\" != \"X\"; then\n                    if test -f \"$dir/$libname.la\"; then\n                      found_la=\"$dir/$libname.la\"\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no \\\n                 || test \"X$found_dir\" = \"X/usr/$acl_libdirstem\" \\\n                 || test \"X$found_dir\" = \"X/usr/$acl_libdirstem2\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$acl_hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$acl_hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $acl_hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */$acl_libdirstem | */$acl_libdirstem/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem/\"'*$,,'`\n                if test \"$name\" = '$1'; then\n                  LIB[]NAME[]_PREFIX=\"$basedir\"\n                fi\n                additional_includedir=\"$basedir/include\"\n                ;;\n              */$acl_libdirstem2 | */$acl_libdirstem2/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem2/\"'*$,,'`\n                if test \"$name\" = '$1'; then\n                  LIB[]NAME[]_PREFIX=\"$basedir\"\n                fi\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\" \\\n                       && test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem2\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\" \\\n                         || test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem2\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$acl_hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: acl_hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n  popdef([P_A_C_K])\n  popdef([PACKLIBS])\n  popdef([PACKUP])\n  popdef([PACK])\n  popdef([NAME])\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\ndnl For those cases where a variable contains several -L and -l options\ndnl referring to unknown libraries and directories, this macro determines the\ndnl necessary additional linker options for the runtime path.\ndnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])\ndnl sets LDADDVAR to linker options needed together with LIBSVALUE.\ndnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,\ndnl otherwise linking without libtool is assumed.\nAC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],\n[\n  AC_REQUIRE([AC_LIB_RPATH])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  $1=\n  if test \"$enable_rpath\" != no; then\n    if test -n \"$acl_hardcode_libdir_flag_spec\" && test \"$acl_hardcode_minus_L\" = no; then\n      dnl Use an explicit option to hardcode directories into the resulting\n      dnl binary.\n      rpathdirs=\n      next=\n      for opt in $2; do\n        if test -n \"$next\"; then\n          dir=\"$next\"\n          dnl No need to hardcode the standard /usr/lib.\n          if test \"X$dir\" != \"X/usr/$acl_libdirstem\" \\\n             && test \"X$dir\" != \"X/usr/$acl_libdirstem2\"; then\n            rpathdirs=\"$rpathdirs $dir\"\n          fi\n          next=\n        else\n          case $opt in\n            -L) next=yes ;;\n            -L*) dir=`echo \"X$opt\" | sed -e 's,^X-L,,'`\n                 dnl No need to hardcode the standard /usr/lib.\n                 if test \"X$dir\" != \"X/usr/$acl_libdirstem\" \\\n                    && test \"X$dir\" != \"X/usr/$acl_libdirstem2\"; then\n                   rpathdirs=\"$rpathdirs $dir\"\n                 fi\n                 next= ;;\n            *) next= ;;\n          esac\n        fi\n      done\n      if test \"X$rpathdirs\" != \"X\"; then\n        if test -n \"\"$3\"\"; then\n          dnl libtool is used for linking. Use -R options.\n          for dir in $rpathdirs; do\n            $1=\"${$1}${$1:+ }-R$dir\"\n          done\n        else\n          dnl The linker is used for linking directly.\n          if test -n \"$acl_hardcode_libdir_separator\"; then\n            dnl Weird platform: only the last -rpath option counts, the user\n            dnl must pass all path elements in one option.\n            alldirs=\n            for dir in $rpathdirs; do\n              alldirs=\"${alldirs}${alldirs:+$acl_hardcode_libdir_separator}$dir\"\n            done\n            acl_save_libdir=\"$libdir\"\n            libdir=\"$alldirs\"\n            eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n            libdir=\"$acl_save_libdir\"\n            $1=\"$flag\"\n          else\n            dnl The -rpath options are cumulative.\n            for dir in $rpathdirs; do\n              acl_save_libdir=\"$libdir\"\n              libdir=\"$dir\"\n              eval flag=\\\"$acl_hardcode_libdir_flag_spec\\\"\n              libdir=\"$acl_save_libdir\"\n              $1=\"${$1}${$1:+ }$flag\"\n            done\n          fi\n        fi\n      fi\n    fi\n  fi\n  AC_SUBST([$1])\n])\n# lib-prefix.m4 serial 7 (gettext-0.18)\ndnl Copyright (C) 2001-2005, 2008-2013 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\ndnl AC_LIB_ARG_WITH is synonymous to AC_ARG_WITH in autoconf-2.13, and\ndnl similar to AC_ARG_WITH in autoconf 2.52...2.57 except that is doesn't\ndnl require excessive bracketing.\nifdef([AC_HELP_STRING],\n[AC_DEFUN([AC_LIB_ARG_WITH], [AC_ARG_WITH([$1],[[$2]],[$3],[$4])])],\n[AC_DEFUN([AC_][LIB_ARG_WITH], [AC_ARG_WITH([$1],[$2],[$3],[$4])])])\n\ndnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed\ndnl to access previously installed libraries. The basic assumption is that\ndnl a user will want packages to use other packages he previously installed\ndnl with the same --prefix option.\ndnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate\ndnl libraries, but is otherwise very convenient.\nAC_DEFUN([AC_LIB_PREFIX],\n[\n  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])\n  AC_REQUIRE([AC_PROG_CC])\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_LIB_ARG_WITH([lib-prefix],\n[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib\n  --without-lib-prefix    don't search for libraries in includedir and libdir],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n      fi\n    fi\n])\n  if test $use_additional = yes; then\n    dnl Potentially add $additional_includedir to $CPPFLAGS.\n    dnl But don't add it\n    dnl   1. if it's the standard /usr/include,\n    dnl   2. if it's already present in $CPPFLAGS,\n    dnl   3. if it's /usr/local/include and we are using GCC on Linux,\n    dnl   4. if it doesn't exist as a directory.\n    if test \"X$additional_includedir\" != \"X/usr/include\"; then\n      haveit=\n      for x in $CPPFLAGS; do\n        AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n        if test \"X$x\" = \"X-I$additional_includedir\"; then\n          haveit=yes\n          break\n        fi\n      done\n      if test -z \"$haveit\"; then\n        if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n          if test -n \"$GCC\"; then\n            case $host_os in\n              linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n            esac\n          fi\n        fi\n        if test -z \"$haveit\"; then\n          if test -d \"$additional_includedir\"; then\n            dnl Really add $additional_includedir to $CPPFLAGS.\n            CPPFLAGS=\"${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir\"\n          fi\n        fi\n      fi\n    fi\n    dnl Potentially add $additional_libdir to $LDFLAGS.\n    dnl But don't add it\n    dnl   1. if it's the standard /usr/lib,\n    dnl   2. if it's already present in $LDFLAGS,\n    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,\n    dnl   4. if it doesn't exist as a directory.\n    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\"; then\n      haveit=\n      for x in $LDFLAGS; do\n        AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n        if test \"X$x\" = \"X-L$additional_libdir\"; then\n          haveit=yes\n          break\n        fi\n      done\n      if test -z \"$haveit\"; then\n        if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\"; then\n          if test -n \"$GCC\"; then\n            case $host_os in\n              linux*) haveit=yes;;\n            esac\n          fi\n        fi\n        if test -z \"$haveit\"; then\n          if test -d \"$additional_libdir\"; then\n            dnl Really add $additional_libdir to $LDFLAGS.\n            LDFLAGS=\"${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir\"\n          fi\n        fi\n      fi\n    fi\n  fi\n])\n\ndnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,\ndnl acl_final_exec_prefix, containing the values to which $prefix and\ndnl $exec_prefix will expand at the end of the configure script.\nAC_DEFUN([AC_LIB_PREPARE_PREFIX],\n[\n  dnl Unfortunately, prefix and exec_prefix get only finally determined\n  dnl at the end of configure.\n  if test \"X$prefix\" = \"XNONE\"; then\n    acl_final_prefix=\"$ac_default_prefix\"\n  else\n    acl_final_prefix=\"$prefix\"\n  fi\n  if test \"X$exec_prefix\" = \"XNONE\"; then\n    acl_final_exec_prefix='${prefix}'\n  else\n    acl_final_exec_prefix=\"$exec_prefix\"\n  fi\n  acl_save_prefix=\"$prefix\"\n  prefix=\"$acl_final_prefix\"\n  eval acl_final_exec_prefix=\\\"$acl_final_exec_prefix\\\"\n  prefix=\"$acl_save_prefix\"\n])\n\ndnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the\ndnl variables prefix and exec_prefix bound to the values they will have\ndnl at the end of the configure script.\nAC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],\n[\n  acl_save_prefix=\"$prefix\"\n  prefix=\"$acl_final_prefix\"\n  acl_save_exec_prefix=\"$exec_prefix\"\n  exec_prefix=\"$acl_final_exec_prefix\"\n  $1\n  exec_prefix=\"$acl_save_exec_prefix\"\n  prefix=\"$acl_save_prefix\"\n])\n\ndnl AC_LIB_PREPARE_MULTILIB creates\ndnl - a variable acl_libdirstem, containing the basename of the libdir, either\ndnl   \"lib\" or \"lib64\" or \"lib/64\",\ndnl - a variable acl_libdirstem2, as a secondary possible value for\ndnl   acl_libdirstem, either the same as acl_libdirstem or \"lib/sparcv9\" or\ndnl   \"lib/amd64\".\nAC_DEFUN([AC_LIB_PREPARE_MULTILIB],\n[\n  dnl There is no formal standard regarding lib and lib64.\n  dnl On glibc systems, the current practice is that on a system supporting\n  dnl 32-bit and 64-bit instruction sets or ABIs, 64-bit libraries go under\n  dnl $prefix/lib64 and 32-bit libraries go under $prefix/lib. We determine\n  dnl the compiler's default mode by looking at the compiler's library search\n  dnl path. If at least one of its elements ends in /lib64 or points to a\n  dnl directory whose absolute pathname ends in /lib64, we assume a 64-bit ABI.\n  dnl Otherwise we use the default, namely \"lib\".\n  dnl On Solaris systems, the current practice is that on a system supporting\n  dnl 32-bit and 64-bit instruction sets or ABIs, 64-bit libraries go under\n  dnl $prefix/lib/64 (which is a symlink to either $prefix/lib/sparcv9 or\n  dnl $prefix/lib/amd64) and 32-bit libraries go under $prefix/lib.\n  AC_REQUIRE([AC_CANONICAL_HOST])\n  acl_libdirstem=lib\n  acl_libdirstem2=\n  case \"$host_os\" in\n    solaris*)\n      dnl See Solaris 10 Software Developer Collection > Solaris 64-bit Developer's Guide > The Development Environment\n      dnl <http://docs.sun.com/app/docs/doc/816-5138/dev-env?l=en&a=view>.\n      dnl \"Portable Makefiles should refer to any library directories using the 64 symbolic link.\"\n      dnl But we want to recognize the sparcv9 or amd64 subdirectory also if the\n      dnl symlink is missing, so we set acl_libdirstem2 too.\n      AC_CACHE_CHECK([for 64-bit host], [gl_cv_solaris_64bit],\n        [AC_EGREP_CPP([sixtyfour bits], [\n#ifdef _LP64\nsixtyfour bits\n#endif\n           ], [gl_cv_solaris_64bit=yes], [gl_cv_solaris_64bit=no])\n        ])\n      if test $gl_cv_solaris_64bit = yes; then\n        acl_libdirstem=lib/64\n        case \"$host_cpu\" in\n          sparc*)        acl_libdirstem2=lib/sparcv9 ;;\n          i*86 | x86_64) acl_libdirstem2=lib/amd64 ;;\n        esac\n      fi\n      ;;\n    *)\n      searchpath=`(LC_ALL=C $CC -print-search-dirs) 2>/dev/null | sed -n -e 's,^libraries: ,,p' | sed -e 's,^=,,'`\n      if test -n \"$searchpath\"; then\n        acl_save_IFS=\"${IFS= \t}\"; IFS=\":\"\n        for searchdir in $searchpath; do\n          if test -d \"$searchdir\"; then\n            case \"$searchdir\" in\n              */lib64/ | */lib64 ) acl_libdirstem=lib64 ;;\n              */../ | */.. )\n                # Better ignore directories of this form. They are misleading.\n                ;;\n              *) searchdir=`cd \"$searchdir\" && pwd`\n                 case \"$searchdir\" in\n                   */lib64 ) acl_libdirstem=lib64 ;;\n                 esac ;;\n            esac\n          fi\n        done\n        IFS=\"$acl_save_IFS\"\n      fi\n      ;;\n  esac\n  test -n \"$acl_libdirstem2\" || acl_libdirstem2=\"$acl_libdirstem\"\n])\n"
        },
        {
          "name": "autogen.sh",
          "type": "blob",
          "size": 0.5546875,
          "content": "#!/bin/sh\n\nset -e\n\nif [ `uname -s` = Darwin ]; then\n    LIBTOOLIZE=glibtoolize\nelse\n    LIBTOOLIZE=libtoolize\nfi\n\nACLOCAL_OPT=\"\"\nif [ -d /usr/local/share/aclocal ]; then\n    ACLOCAL_OPT=\"-I /usr/local/share/aclocal\"\nelif [ -d /opt/local/share/aclocal ]; then\n    ACLOCAL_OPT=\"-I /opt/local/share/aclocal\"\nelif [ -d /usr/share/aclocal ]; then\n    ACLOCAL_OPT=\"-I /usr/share/aclocal\"\nfi\n\nif [ ! -d use ]; then\n    mkdir use\nfi\n\nif [ ! -d m4 ]; then\n    mkdir m4\nfi\n\nautoheader\n\naclocal $ACLOCAL_OPT\n\n$LIBTOOLIZE --automake --copy\nautomake --add-missing --copy\n\nautoconf\n"
        },
        {
          "name": "bitstream.c",
          "type": "blob",
          "size": 4.4501953125,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Binary sequence class.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"bitstream.h\"\n\n#define DEFAULT_BUFSIZE (128)\n\nBitStream *BitStream_new(void)\n{\n\tBitStream *bstream;\n\n\tbstream = (BitStream *)malloc(sizeof(BitStream));\n\tif(bstream == NULL) return NULL;\n\n\tbstream->length = 0;\n\tbstream->data = (unsigned char *)malloc(DEFAULT_BUFSIZE);\n\tif(bstream->data == NULL) {\n\t\tfree(bstream);\n\t\treturn NULL;\n\t}\n\tbstream->datasize = DEFAULT_BUFSIZE;\n\n\treturn bstream;\n}\n\n#ifdef WITH_TESTS\nBitStream *BitStream_newWithBits(size_t size, unsigned char *bits)\n{\n\tBitStream *bstream;\n\n\tif(size == 0) return BitStream_new();\n\n\tbstream = (BitStream *)malloc(sizeof(BitStream));\n\tif(bstream == NULL) return NULL;\n\n\tbstream->data = (unsigned char *)malloc(size);\n\tif(bstream->data == NULL) {\n\t\tfree(bstream);\n\t\treturn NULL;\n\t}\n\n\tbstream->length = size;\n\tbstream->datasize = size;\n\tmemcpy(bstream->data, bits, size);\n\n\treturn bstream;\n}\n#endif\n\nstatic int BitStream_expand(BitStream *bstream)\n{\n\tunsigned char *data;\n\n\tdata = (unsigned char *)realloc(bstream->data, bstream->datasize * 2);\n\tif(data == NULL) {\n\t\treturn -1;\n\t}\n\n\tbstream->data = data;\n\tbstream->datasize *= 2;\n\n\treturn 0;\n}\n\nstatic void BitStream_writeNum(unsigned char *dest, size_t bits, unsigned int num)\n{\n\tunsigned int mask;\n\tsize_t i;\n\tunsigned char *p;\n\n\tp = dest;\n\tmask = 1U << (bits - 1);\n\tfor(i = 0; i < bits; i++) {\n\t\tif(num & mask) {\n\t\t\t*p = 1;\n\t\t} else {\n\t\t\t*p = 0;\n\t\t}\n\t\tp++;\n\t\tmask = mask >> 1;\n\t}\n}\n\nstatic void BitStream_writeBytes(unsigned char *dest, size_t size, unsigned char *data)\n{\n\tunsigned char mask;\n\tsize_t i, j;\n\tunsigned char *p;\n\n\tp = dest;\n\tfor(i = 0; i < size; i++) {\n\t\tmask = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tif(data[i] & mask) {\n\t\t\t\t*p = 1;\n\t\t\t} else {\n\t\t\t\t*p = 0;\n\t\t\t}\n\t\t\tp++;\n\t\t\tmask = mask >> 1;\n\t\t}\n\t}\n}\n\nint BitStream_append(BitStream *bstream, BitStream *arg)\n{\n\tint ret;\n\n\tif(arg == NULL) {\n\t\treturn -1;\n\t}\n\tif(arg->length == 0) {\n\t\treturn 0;\n\t}\n\n\twhile(bstream->length + arg->length > bstream->datasize) {\n\t\tret = BitStream_expand(bstream);\n\t\tif(ret < 0) return ret;\n\t}\n\n\tmemcpy(bstream->data + bstream->length, arg->data, arg->length);\n\tbstream->length += arg->length;\n\n\treturn 0;\n}\n\nint BitStream_appendNum(BitStream *bstream, size_t bits, unsigned int num)\n{\n\tint ret;\n\n\tif(bits == 0) return 0;\n\n\twhile(bstream->datasize - bstream->length < bits) {\n\t\tret = BitStream_expand(bstream);\n\t\tif(ret < 0) return ret;\n\t}\n\tBitStream_writeNum(bstream->data + bstream->length, bits, num);\n\tbstream->length += bits;\n\n\treturn 0;\n}\n\nint BitStream_appendBytes(BitStream *bstream, size_t size, unsigned char *data)\n{\n\tint ret;\n\n\tif(size == 0) return 0;\n\n\twhile(bstream->datasize - bstream->length < size * 8) {\n\t\tret = BitStream_expand(bstream);\n\t\tif(ret < 0) return ret;\n\t}\n\tBitStream_writeBytes(bstream->data + bstream->length, size, data);\n\tbstream->length += size * 8;\n\n\treturn 0;\n}\n\nunsigned char *BitStream_toByte(BitStream *bstream)\n{\n\tsize_t i, j, size, bytes, oddbits;\n\tunsigned char *data, v;\n\tunsigned char *p;\n\n\tsize = BitStream_size(bstream);\n\tif(size == 0) {\n\t\treturn NULL;\n\t}\n\tdata = (unsigned char *)malloc((size + 7) / 8);\n\tif(data == NULL) {\n\t\treturn NULL;\n\t}\n\n\tbytes = size  / 8;\n\n\tp = bstream->data;\n\tfor(i = 0; i < bytes; i++) {\n\t\tv = 0;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tv = (unsigned char)(v << 1);\n\t\t\tv |= *p;\n\t\t\tp++;\n\t\t}\n\t\tdata[i] = v;\n\t}\n\toddbits = size & 7;\n\tif(oddbits > 0) {\n\t\tv = 0;\n\t\tfor(j = 0; j < oddbits; j++) {\n\t\t\tv = (unsigned char)(v << 1);\n\t\t\tv |= *p;\n\t\t\tp++;\n\t\t}\n\t\tdata[bytes] = (unsigned char)(v << (8 - oddbits));\n\t}\n\n\treturn data;\n}\n\nvoid BitStream_free(BitStream *bstream)\n{\n\tif(bstream != NULL) {\n\t\tfree(bstream->data);\n\t\tfree(bstream);\n\t}\n}\n"
        },
        {
          "name": "bitstream.h",
          "type": "blob",
          "size": 1.572265625,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Binary sequence class.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef BITSTREAM_H\n#define BITSTREAM_H\n\ntypedef struct {\n\tsize_t length;\n\tsize_t datasize;\n\tunsigned char *data;\n} BitStream;\n\nextern BitStream *BitStream_new(void);\n#ifdef WITH_TESTS\nextern BitStream *BitStream_newWithBits(size_t size, unsigned char *bits);\n#endif\nextern int BitStream_append(BitStream *bstream, BitStream *arg);\nextern int BitStream_appendNum(BitStream *bstream, size_t bits, unsigned int num);\nextern int BitStream_appendBytes(BitStream *bstream, size_t size, unsigned char *data);\n#define BitStream_size(__bstream__) (__bstream__->length)\n#define BitStream_reset(__bstream__) (__bstream__->length = 0)\nextern unsigned char *BitStream_toByte(BitStream *bstream);\nextern void BitStream_free(BitStream *bstream);\n\n#endif /* BITSTREAM_H */\n"
        },
        {
          "name": "cmake",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure.ac",
          "type": "blob",
          "size": 4.787109375,
          "content": "m4_define([__MAJOR_VERSION], [4])dnl\nm4_define([__MINOR_VERSION], [1])dnl\nm4_define([__MICRO_VERSION], [1])dnl\nm4_define([__VERSION], [__MAJOR_VERSION.__MINOR_VERSION.__MICRO_VERSION])dnl\nAC_INIT(QRencode, __VERSION)\n\nMAJOR_VERSION=__MAJOR_VERSION\nMINOR_VERSION=__MINOR_VERSION\nMICRO_VERSION=__MICRO_VERSION\nAC_SUBST(MAJOR_VERSION)\nAC_SUBST(MINOR_VERSION)\nAC_SUBST(MICRO_VERSION)\nAC_DEFINE_UNQUOTED([MAJOR_VERSION], [$MAJOR_VERSION], [Major version number])\nAC_DEFINE_UNQUOTED([MINOR_VERSION], [$MINOR_VERSION], [Minor version number])\nAC_DEFINE_UNQUOTED([MICRO_VERSION], [$MICRO_VERSION], [Micro version number])\n\nAC_CONFIG_SRCDIR([qrencode.c])\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_AUX_DIR(use)\nAC_CONFIG_MACRO_DIR([m4])\nAC_CANONICAL_HOST\nAC_CANONICAL_TARGET\n\nAM_INIT_AUTOMAKE\n\nAC_DISABLE_STATIC\nAC_C_CONST\nAC_C_INLINE\nAC_HEADER_STDC\nAC_CHECK_HEADERS(sys/time.h)\n\nLT_INIT\nAC_PROG_CC\nAM_PROG_CC_C_O\nAC_PROG_INSTALL\nAC_PROG_LIBTOOL\nPKG_PROG_PKG_CONFIG\n\ncase \"${target}\" in\n*-*-mingw*)\n\tmingw=yes\nesac\nAM_CONDITIONAL(MINGW, [test \"x$mingw\" = \"xyes\" ])\n\nAC_CONFIG_FILES([Makefile libqrencode.pc tests/Makefile qrencode.1])\n\nAC_CHECK_FUNCS([strdup])\n\ndnl --enable-thread-safety\nAC_ARG_ENABLE([thread-safety], [AS_HELP_STRING([--enable-thread-safety], [make the library thread-safe. [default=yes]])],\n [], [enable_thread_safety=yes])\n\nif test x$enable_thread_safety = xyes; then\n\tAC_CHECK_LIB([pthread], [pthread_mutex_init], [AC_SUBST([LIBPTHREAD], [-lpthread])])\nfi\nAM_CONDITIONAL([HAVE_LIBPTHREAD], [test \"x$ac_cv_lib_pthread_pthread_mutex_init\" = \"xyes\" ])\n# FIXME: isn't it able to integrate the followings to AC_CHECK_LIB?\nif test x$ac_cv_lib_pthread_pthread_mutex_init = xyes ; then\n\tAC_DEFINE([HAVE_LIBPTHREAD], [1], [Define to 1 if using pthread is enabled.])\n\tCFLAGS=\"$CFLAGS -pthread\"\nfi\n\nAC_ARG_WITH(png,\n    [AC_HELP_STRING([--without-png],\n                    [disable PNG support])],\n    [with_png=$withval], [with_png=yes])\n\ndnl --with-tools\nAC_ARG_WITH([tools], [AS_HELP_STRING([--with-tools], [build utility tools [default=yes]])],\n [build_tools=$withval], [build_tools=yes])\n\nAM_CONDITIONAL(BUILD_TOOLS, [test \"x$build_tools\" = \"xyes\" ])\nif test x$build_tools = xyes && test x$with_png = xyes ; then\n\tPKG_CHECK_MODULES(png, \"libpng\", [AC_DEFINE([HAVE_PNG], [1], [Define to 1 if using libpng is enabled.])], [AC_DEFINE([HAVE_PNG], [0])])\n\tif test \"x$png_CFLAGS\" = \"x\" && test x$with_png = xyes ; then\n\t\techo \"\n!!!!!!!!!!\nLIBPNG is required to build the utility tools. Temporarily disabled.\n!!!!!!!!!!\n\"\n\tfi\nfi\nAM_CONDITIONAL(HAVE_PNG, [test \"x$png_CFLAGS\" != \"x\" ])\n\ndnl --with-tests\nAC_ARG_WITH([tests], [AS_HELP_STRING([--with-tests], [build tests [default=no]])],\n [build_tests=$withval], [build_tests=no])\n\nAM_CONDITIONAL(BUILD_TESTS, [test \"x$build_tests\" = \"xyes\" ])\nAH_VERBATIM([tests],\n[/* Define to 'static' if no test programs will be compiled. */\n#define STATIC_IN_RELEASE static\n#undef WITH_TESTS\n   ])\nif test x$build_tests = xyes ; then\necho \"#define STATIC_IN_RELEASE\" >>confdefs.h\necho \"#define WITH_TESTS 1\" >>confdefs.h\nelse\necho \"#define STATIC_IN_RELEASE static\" >>confdefs.h\necho \"/* #undef WITH_TESTS */\" >>confdefs.h\nfi\n\nif test x$build_tests = xyes ; then\n\tSDL_REQUIRED_VERSION=2.0.0\n\tPKG_CHECK_MODULES(SDL, [sdl2 >= $SDL_REQUIRED_VERSION], [AC_DEFINE([HAVE_SDL], [1], [Define to 1 if using SDL is enabled.])], [AC_DEFINE([HAVE_SDL], [0])])\n\tAM_ICONV_LINK\nfi\nAM_CONDITIONAL(HAVE_SDL, [test \"x$SDL_CFLAGS\" != \"x\" ])\n\n\ndnl --enable-gprof\nAC_ARG_ENABLE([gprof], [AS_HELP_STRING([--enable-gprof], [generate extra code to write profile information suitable for gprof [default=no]])],\n [], [enable_gprof=no])\n\nif test x$enable_gprof = xyes; then\n\tCFLAGS=\"$CFLAGS -g -pg\"\nfi\n\n\ndnl --enable-gcov\nAC_ARG_ENABLE([gcov], [AS_HELP_STRING([--enable-gcov], [generate extra code to write coverage information suitable for gcov [default=no]])],\n [], [enable_gcov=no])\n\nif test x$enable_gcov = xyes; then\n\tCFLAGS=\"$CFLAGS --coverage\"\nfi\n\n\ndnl --enable-mudflap\nAC_ARG_ENABLE([mudflap], [AS_HELP_STRING([--enable-mudflap], [generate extra code to check memory leaks [default=no]])],\n [], [enable_mudflap=no])\n\nif test x$enable_mudflap = xyes; then\n\tif test x$enable_thread_safety = xyes; then\n\t\tCFLAGS=\"$CFLAGS -fmudflapth\"\n\t\tLDFLAGS=\"$LDFLAGS -lmudflapth\"\n\telse\n\t\tCFLAGS=\"$CFLAGS -fmudflap\"\n\t\tLDFLAGS=\"$LDFLAGS -lmudflap\"\n\tfi\nfi\n\ndnl --enable-asan\nAC_ARG_ENABLE([asan], [AS_HELP_STRING([--enable-asan], [use AddressSanitizer [default=no]])],\n [], [enable_asan=no])\n\nif test x$enable_asan = xyes; then\n\tCFLAGS=\"$CFLAGS -fsanitize=address -fno-omit-frame-pointer\"\n\tLDFLAGS=\"$LDFLAGS -fsanitize=address\"\nfi\n\n\ndnl set CFLAGS\nCFLAGS=\"-Wall $CFLAGS\"\n\n\nAC_OUTPUT\n\necho \"\"\necho \"Options used to compile and link:\"\necho \"  CC       = $CC\"\necho \"  CFLAGS   = $CFLAGS\"\necho \"  CPPFLAGS = $CPPFLAGS\"\necho \"  CXX      = $CXX\"\necho \"  CXXFLAGS = $CXXFLAGS\"\necho \"  LDFLAGS  = $LDFLAGS\"\necho \"\"\n"
        },
        {
          "name": "libqrencode.pc.in",
          "type": "blob",
          "size": 0.234375,
          "content": "prefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nincludedir=@includedir@\n\nName: libqrencode\nDescription: A QR Code encoding library\nVersion: @VERSION@\nLibs: -L${libdir} -lqrencode\nLibs.private: @LIBPTHREAD@\nCflags: -I${includedir}\n"
        },
        {
          "name": "makeREADME.sh",
          "type": "blob",
          "size": 0.14453125,
          "content": "#!/bin/sh\n\nsed '/^```$/d\n/^\\*\\*Attention/d\ns/DWITH\\\\_TESTS/DWITH_TESTS/\n1 {\n\ts/^# //\n\ts/encoding library.*/encoding library/\n}\n' README.md > README\n"
        },
        {
          "name": "mask.c",
          "type": "blob",
          "size": 7.31640625,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Masking.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mask.h\"\n\nSTATIC_IN_RELEASE int Mask_writeFormatInformation(int width, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned int format;\n\tunsigned char v;\n\tint i;\n\tint blacks = 0;\n\n\tformat = QRspec_getFormatInfo(mask, level);\n\n\tfor(i = 0; i < 8; i++) {\n\t\tif(format & 1) {\n\t\t\tblacks += 2;\n\t\t\tv = 0x85;\n\t\t} else {\n\t\t\tv = 0x84;\n\t\t}\n\t\tframe[width * 8 + width - 1 - i] = v;\n\t\tif(i < 6) {\n\t\t\tframe[width * i + 8] = v;\n\t\t} else {\n\t\t\tframe[width * (i + 1) + 8] = v;\n\t\t}\n\t\tformat= format >> 1;\n\t}\n\tfor(i = 0; i < 7; i++) {\n\t\tif(format & 1) {\n\t\t\tblacks += 2;\n\t\t\tv = 0x85;\n\t\t} else {\n\t\t\tv = 0x84;\n\t\t}\n\t\tframe[width * (width - 7 + i) + 8] = v;\n\t\tif(i == 0) {\n\t\t\tframe[width * 8 + 7] = v;\n\t\t} else {\n\t\t\tframe[width * 8 + 6 - i] = v;\n\t\t}\n\t\tformat= format >> 1;\n\t}\n\n\treturn blacks;\n}\n\n/**\n * Demerit coefficients.\n * See Section 8.8.2, pp.45, JIS X0510:2004.\n */\n#define N1 (3)\n#define N2 (3)\n#define N3 (40)\n#define N4 (10)\n\n#define MASKMAKER(__exp__) \\\n\tint x, y;\\\n\tint b = 0;\\\n\\\n\tfor(y = 0; y < width; y++) {\\\n\t\tfor(x = 0; x < width; x++) {\\\n\t\t\tif(*s & 0x80) {\\\n\t\t\t\t*d = *s;\\\n\t\t\t} else {\\\n\t\t\t\t*d = *s ^ ((__exp__) == 0);\\\n\t\t\t}\\\n\t\t\tb += (int)(*d & 1);\\\n\t\t\ts++; d++;\\\n\t\t}\\\n\t}\\\n\treturn b;\n\nstatic int Mask_mask0(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((x+y)&1)\n}\n\nstatic int Mask_mask1(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(y&1)\n}\n\nstatic int Mask_mask2(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(x%3)\n}\n\nstatic int Mask_mask3(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((x+y)%3)\n}\n\nstatic int Mask_mask4(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(((y/2)+(x/3))&1)\n}\n\nstatic int Mask_mask5(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(((x*y)&1)+(x*y)%3)\n}\n\nstatic int Mask_mask6(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x*y)&1)+(x*y)%3)&1)\n}\n\nstatic int Mask_mask7(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x*y)%3)+((x+y)&1))&1)\n}\n\n#define maskNum (8)\ntypedef int MaskMaker(int, const unsigned char *, unsigned char *);\nstatic MaskMaker *maskMakers[maskNum] = {\n\tMask_mask0, Mask_mask1, Mask_mask2, Mask_mask3,\n\tMask_mask4, Mask_mask5, Mask_mask6, Mask_mask7\n};\n\n#ifdef WITH_TESTS\nunsigned char *Mask_makeMaskedFrame(int width, unsigned char *frame, int mask)\n{\n\tunsigned char *masked;\n\n\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\n\treturn masked;\n}\n#endif\n\nunsigned char *Mask_makeMask(int width, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned char *masked;\n\n\tif(mask < 0 || mask >= maskNum) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\tMask_writeFormatInformation(width, masked, mask, level);\n\n\treturn masked;\n}\n\n\n//static int n1;\n//static int n2;\n//static int n3;\n//static int n4;\n\nSTATIC_IN_RELEASE int Mask_calcN1N3(int length, int *runLength)\n{\n\tint i;\n\tint demerit = 0;\n\tint fact;\n\n\tfor(i = 0; i < length; i++) {\n\t\tif(runLength[i] >= 5) {\n\t\t\tdemerit += N1 + (runLength[i] - 5);\n\t\t\t//n1 += N1 + (runLength[i] - 5);\n\t\t}\n\t\tif((i & 1)) {\n\t\t\tif(i >= 3 && i < length-2 && (runLength[i] % 3) == 0) {\n\t\t\t\tfact = runLength[i] / 3;\n\t\t\t\tif(runLength[i-2] == fact &&\n\t\t\t\t   runLength[i-1] == fact &&\n\t\t\t\t   runLength[i+1] == fact &&\n\t\t\t\t   runLength[i+2] == fact) {\n\t\t\t\t\tif(i == 3 || runLength[i-3] >= 4 * fact) {\n\t\t\t\t\t\tdemerit += N3;\n\t\t\t\t\t\t//n3 += N3;\n\t\t\t\t\t} else if(i+4 >= length || runLength[i+3] >= 4 * fact) {\n\t\t\t\t\t\tdemerit += N3;\n\t\t\t\t\t\t//n3 += N3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn demerit;\n}\n\nSTATIC_IN_RELEASE int Mask_calcN2(int width, unsigned char *frame)\n{\n\tint x, y;\n\tunsigned char *p;\n\tunsigned char b22, w22;\n\tint demerit = 0;\n\n\tp = frame + width + 1;\n\tfor(y = 1; y < width; y++) {\n\t\tfor(x = 1; x < width; x++) {\n\t\t\tb22 = p[0] & p[-1] & p[-width] & p [-width-1];\n\t\t\tw22 = p[0] | p[-1] | p[-width] | p [-width-1];\n\t\t\tif((b22 | (w22 ^ 1))&1) {\n\t\t\t\tdemerit += N2;\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\tp++;\n\t}\n\n\treturn demerit;\n}\n\nSTATIC_IN_RELEASE int Mask_calcRunLengthH(int width, unsigned char *frame, int *runLength)\n{\n\tint head;\n\tint i;\n\tunsigned char prev;\n\n\tif(frame[0] & 1) {\n\t\trunLength[0] = -1;\n\t\thead = 1;\n\t} else {\n\t\thead = 0;\n\t}\n\trunLength[head] = 1;\n\tprev = frame[0];\n\n\tfor(i = 1; i < width; i++) {\n\t\tif((frame[i] ^ prev) & 1) {\n\t\t\thead++;\n\t\t\trunLength[head] = 1;\n\t\t\tprev = frame[i];\n\t\t} else {\n\t\t\trunLength[head]++;\n\t\t}\n\t}\n\n\treturn head + 1;\n}\n\nSTATIC_IN_RELEASE int Mask_calcRunLengthV(int width, unsigned char *frame, int *runLength)\n{\n\tint head;\n\tint i;\n\tunsigned char prev;\n\n\tif(frame[0] & 1) {\n\t\trunLength[0] = -1;\n\t\thead = 1;\n\t} else {\n\t\thead = 0;\n\t}\n\trunLength[head] = 1;\n\tprev = frame[0];\n\n\tfor(i = 1; i < width; i++) {\n\t\tif((frame[i * width] ^ prev) & 1) {\n\t\t\thead++;\n\t\t\trunLength[head] = 1;\n\t\t\tprev = frame[i * width];\n\t\t} else {\n\t\t\trunLength[head]++;\n\t\t}\n\t}\n\n\treturn head + 1;\n}\n\nSTATIC_IN_RELEASE int Mask_evaluateSymbol(int width, unsigned char *frame)\n{\n\tint x, y;\n\tint demerit = 0;\n\tint runLength[QRSPEC_WIDTH_MAX + 1];\n\tint length;\n\n\tdemerit += Mask_calcN2(width, frame);\n\n\tfor(y = 0; y < width; y++) {\n\t\tlength = Mask_calcRunLengthH(width, frame + y * width, runLength);\n\t\tdemerit += Mask_calcN1N3(length, runLength);\n\t}\n\n\tfor(x = 0; x < width; x++) {\n\t\tlength = Mask_calcRunLengthV(width, frame + x, runLength);\n\t\tdemerit += Mask_calcN1N3(length, runLength);\n\t}\n\n\treturn demerit;\n}\n\nunsigned char *Mask_mask(int width, unsigned char *frame, QRecLevel level)\n{\n\tint i;\n\tunsigned char *mask, *bestMask;\n\tint minDemerit = INT_MAX;\n\tint blacks;\n\tint bratio;\n\tint demerit;\n\tint w2 = width * width;\n\n\tmask = (unsigned char *)malloc((size_t)w2);\n\tif(mask == NULL) return NULL;\n\tbestMask = (unsigned char *)malloc((size_t)w2);\n\tif(bestMask == NULL) {\n\t\tfree(mask);\n\t\treturn NULL;\n\t}\n\n\tfor(i = 0; i < maskNum; i++) {\n//\t\tn1 = n2 = n3 = n4 = 0;\n\t\tdemerit = 0;\n\t\tblacks = maskMakers[i](width, frame, mask);\n\t\tblacks += Mask_writeFormatInformation(width, mask, i, level);\n\t\tbratio = (200 * blacks + w2) / w2 / 2; /* (int)(100*blacks/w2+0.5) */\n\t\tdemerit = (abs(bratio - 50) / 5) * N4;\n//\t\tn4 = demerit;\n\t\tdemerit += Mask_evaluateSymbol(width, mask);\n//\t\tprintf(\"(%d,%d,%d,%d)=%d\\n\", n1, n2, n3 ,n4, demerit);\n\t\tif(demerit < minDemerit) {\n\t\t\tminDemerit = demerit;\n\t\t\tmemcpy(bestMask, mask, (size_t)w2);\n\t\t}\n\t}\n\tfree(mask);\n\treturn bestMask;\n}\n"
        },
        {
          "name": "mask.h",
          "type": "blob",
          "size": 1.5830078125,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Masking.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef MASK_H\n#define MASK_H\n\nextern unsigned char *Mask_makeMask(int width, unsigned char *frame, int mask, QRecLevel level);\nextern unsigned char *Mask_mask(int width, unsigned char *frame, QRecLevel level);\n\n#ifdef WITH_TESTS\nextern int Mask_calcN2(int width, unsigned char *frame);\nextern int Mask_calcN1N3(int length, int *runLength);\nextern int Mask_calcRunLengthH(int width, unsigned char *frame, int *runLength);\nextern int Mask_calcRunLengthV(int width, unsigned char *frame, int *runLength);\nextern int Mask_evaluateSymbol(int width, unsigned char *frame);\nextern int Mask_writeFormatInformation(int width, unsigned char *frame, int mask, QRecLevel level);\nextern unsigned char *Mask_makeMaskedFrame(int width, unsigned char *frame, int mask);\n#endif\n\n#endif /* MASK_H */\n"
        },
        {
          "name": "mmask.c",
          "type": "blob",
          "size": 4.0908203125,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Masking for Micro QR Code.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"mqrspec.h\"\n#include \"mmask.h\"\n\nSTATIC_IN_RELEASE void MMask_writeFormatInformation(int version, int width, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned int format;\n\tunsigned char v;\n\tint i;\n\n\tformat = MQRspec_getFormatInfo(mask, version, level);\n\n\tfor(i = 0; i < 8; i++) {\n\t\tv = 0x84 | (format & 1);\n\t\tframe[width * (i + 1) + 8] = v;\n\t\tformat = format >> 1;\n\t}\n\tfor(i = 0; i < 7; i++) {\n\t\tv = 0x84 | (format & 1);\n\t\tframe[width * 8 + 7 - i] = v;\n\t\tformat = format >> 1;\n\t}\n}\n\n#define MASKMAKER(__exp__) \\\n\tint x, y;\\\n\\\n\tfor(y = 0; y < width; y++) {\\\n\t\tfor(x = 0; x < width; x++) {\\\n\t\t\tif(*s & 0x80) {\\\n\t\t\t\t*d = *s;\\\n\t\t\t} else {\\\n\t\t\t\t*d = *s ^ ((__exp__) == 0);\\\n\t\t\t}\\\n\t\t\ts++; d++;\\\n\t\t}\\\n\t}\n\nstatic void Mask_mask0(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(y&1)\n}\n\nstatic void Mask_mask1(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER(((y/2)+(x/3))&1)\n}\n\nstatic void Mask_mask2(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x*y)&1)+(x*y)%3)&1)\n}\n\nstatic void Mask_mask3(int width, const unsigned char *s, unsigned char *d)\n{\n\tMASKMAKER((((x+y)&1)+((x*y)%3))&1)\n}\n\n#define maskNum (4)\ntypedef void MaskMaker(int, const unsigned char *, unsigned char *);\nstatic MaskMaker *maskMakers[maskNum] = {\n\tMask_mask0, Mask_mask1, Mask_mask2, Mask_mask3\n};\n\n#ifdef WITH_TESTS\nunsigned char *MMask_makeMaskedFrame(int width, unsigned char *frame, int mask)\n{\n\tunsigned char *masked;\n\n\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\n\treturn masked;\n}\n#endif\n\nunsigned char *MMask_makeMask(int version, unsigned char *frame, int mask, QRecLevel level)\n{\n\tunsigned char *masked;\n\tint width;\n\n\tif(mask < 0 || mask >= maskNum) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\twidth = MQRspec_getWidth(version);\n\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\tif(masked == NULL) return NULL;\n\n\tmaskMakers[mask](width, frame, masked);\n\tMMask_writeFormatInformation(version, width, masked, mask, level);\n\n\treturn masked;\n}\n\nSTATIC_IN_RELEASE int MMask_evaluateSymbol(int width, unsigned char *frame)\n{\n\tint x, y;\n\tunsigned char *p;\n\tint sum1 = 0, sum2 = 0;\n\n\tp = frame + width * (width - 1);\n\tfor(x = 1; x < width; x++) {\n\t\tsum1 += (p[x] & 1);\n\t}\n\n\tp = frame + width * 2 - 1;\n\tfor(y = 1; y < width; y++) {\n\t\tsum2 += (*p & 1);\n\t\tp += width;\n\t}\n\n\treturn (sum1 <= sum2)?(sum1 * 16 + sum2):(sum2 * 16 + sum1);\n}\n\nunsigned char *MMask_mask(int version, unsigned char *frame, QRecLevel level)\n{\n\tint i;\n\tunsigned char *mask, *bestMask;\n\tint maxScore = 0;\n\tint score;\n\tint width;\n\n\twidth = MQRspec_getWidth(version);\n\n\tmask = (unsigned char *)malloc((size_t)(width * width));\n\tif(mask == NULL) return NULL;\n\tbestMask = NULL;\n\n\tfor(i = 0; i < maskNum; i++) {\n\t\tscore = 0;\n\t\tmaskMakers[i](width, frame, mask);\n\t\tMMask_writeFormatInformation(version, width, mask, i, level);\n\t\tscore = MMask_evaluateSymbol(width, mask);\n\t\tif(score > maxScore) {\n\t\t\tmaxScore = score;\n\t\t\tfree(bestMask);\n\t\t\tbestMask = mask;\n\t\t\tmask = (unsigned char *)malloc((size_t)(width * width));\n\t\t\tif(mask == NULL) break;\n\t\t}\n\t}\n\tfree(mask);\n\treturn bestMask;\n}\n"
        },
        {
          "name": "mmask.h",
          "type": "blob",
          "size": 1.359375,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Masking for Micro QR Code.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef MMASK_H\n#define MMASK_H\n\nextern unsigned char *MMask_makeMask(int version, unsigned char *frame, int mask, QRecLevel level);\nextern unsigned char *MMask_mask(int version, unsigned char *frame, QRecLevel level);\n\n#ifdef WITH_TESTS\nextern int MMask_evaluateSymbol(int width, unsigned char *frame);\nextern void MMask_writeFormatInformation(int version, int width, unsigned char *frame, int mask, QRecLevel level);\nextern unsigned char *MMask_makeMaskedFrame(int width, unsigned char *frame, int mask);\n#endif\n\n#endif /* MMASK_H */\n"
        },
        {
          "name": "mqrspec.c",
          "type": "blob",
          "size": 5.951171875,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Micro QR Code specification in convenient format.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"mqrspec.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\ntypedef struct {\n\tint width; ///< Edge length of the symbol\n\tint ec[4]; ///< Number of ECC code (bytes)\n} MQRspec_Capacity;\n\n/**\n * Table of the capacity of symbols\n * See Table 1 (pp.106) and Table 8 (pp.113) of Appendix 1, JIS X0510:2004.\n */\nstatic const MQRspec_Capacity mqrspecCapacity[MQRSPEC_VERSION_MAX + 1] = {\n\t{  0, {0,  0,  0, 0}},\n\t{ 11, {2,  0,  0, 0}},\n\t{ 13, {5,  6,  0, 0}},\n\t{ 15, {6,  8,  0, 0}},\n\t{ 17, {8, 10, 14, 0}}\n};\n\nint MQRspec_getDataLengthBit(int version, QRecLevel level)\n{\n\tint w;\n\tint ecc;\n\n\tw = mqrspecCapacity[version].width - 1;\n\tecc = mqrspecCapacity[version].ec[level];\n\tif(ecc == 0) return 0;\n\treturn w * w - 64 - ecc * 8;\n}\n\nint MQRspec_getDataLength(int version, QRecLevel level)\n{\n\treturn (MQRspec_getDataLengthBit(version, level) + 4) / 8;\n}\n\nint MQRspec_getECCLength(int version, QRecLevel level)\n{\n\treturn mqrspecCapacity[version].ec[level];\n}\n\nint MQRspec_getWidth(int version)\n{\n\treturn mqrspecCapacity[version].width;\n}\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\n/**\n * See Table 3 (pp.107) of Appendix 1, JIS X0510:2004.\n */\nstatic const int lengthTableBits[4][4] = {\n\t{ 3, 4, 5, 6},\n\t{ 0, 3, 4, 5},\n\t{ 0, 0, 4, 5},\n\t{ 0, 0, 3, 4}\n};\n\nint MQRspec_lengthIndicator(QRencodeMode mode, int version)\n{\n\treturn lengthTableBits[mode][version - 1];\n}\n\nint MQRspec_maximumWords(QRencodeMode mode, int version)\n{\n\tint bits;\n\tint words;\n\n\tbits = lengthTableBits[mode][version - 1];\n\twords = (1 << bits) - 1;\n\tif(mode == QR_MODE_KANJI) {\n\t\twords *= 2; // the number of bytes is required\n\t}\n\n\treturn words;\n}\n\n/******************************************************************************\n * Format information\n *****************************************************************************/\n\n/* See calcFormatInfo in tests/test_mqrspec.c */\nstatic const unsigned int formatInfo[4][8] = {\n\t{0x4445, 0x55ae, 0x6793, 0x7678, 0x06de, 0x1735, 0x2508, 0x34e3},\n\t{0x4172, 0x5099, 0x62a4, 0x734f, 0x03e9, 0x1202, 0x203f, 0x31d4},\n\t{0x4e2b, 0x5fc0, 0x6dfd, 0x7c16, 0x0cb0, 0x1d5b, 0x2f66, 0x3e8d},\n\t{0x4b1c, 0x5af7, 0x68ca, 0x7921, 0x0987, 0x186c, 0x2a51, 0x3bba}\n};\n\n/* See Table 10 of Appendix 1. (pp.115) */\nstatic const int typeTable[MQRSPEC_VERSION_MAX + 1][3] = {\n\t{-1, -1, -1},\n\t{ 0, -1, -1},\n\t{ 1,  2, -1},\n\t{ 3,  4, -1},\n\t{ 5,  6,  7}\n};\n\nunsigned int MQRspec_getFormatInfo(int mask, int version, QRecLevel level)\n{\n\tint type;\n\n\tif(mask < 0 || mask > 3) return 0;\n\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) return 0;\n\tif(level == QR_ECLEVEL_H) return 0;\n\ttype = typeTable[version][level];\n\tif(type < 0) return 0;\n\n\treturn formatInfo[mask][type];\n}\n\n/******************************************************************************\n * Frame\n *****************************************************************************/\n\n/**\n * Put a finder pattern.\n * @param frame\n * @param width\n * @param ox,oy upper-left coordinate of the pattern\n */\nstatic void putFinderPattern(unsigned char *frame, int width, int ox, int oy)\n{\n\tstatic const unsigned char finder[] = {\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t};\n\tint x, y;\n\tconst unsigned char *s;\n\n\tframe += oy * width + ox;\n\ts = finder;\n\tfor(y = 0; y < 7; y++) {\n\t\tfor(x = 0; x < 7; x++) {\n\t\t\tframe[x] = s[x];\n\t\t}\n\t\tframe += width;\n\t\ts += 7;\n\t}\n}\n\nstatic unsigned char *MQRspec_createFrame(int version)\n{\n\tunsigned char *frame, *p, *q;\n\tint width;\n\tint x, y;\n\n\twidth = mqrspecCapacity[version].width;\n\tframe = (unsigned char *)malloc((size_t)(width * width));\n\tif(frame == NULL) return NULL;\n\n\tmemset(frame, 0, (size_t)(width * width));\n\t/* Finder pattern */\n\tputFinderPattern(frame, width, 0, 0);\n\t/* Separator */\n\tp = frame;\n\tfor(y = 0; y < 7; y++) {\n\t\tp[7] = 0xc0;\n\t\tp += width;\n\t}\n\tmemset(frame + width * 7, 0xc0, 8);\n\t/* Mask format information area */\n\tmemset(frame + width * 8 + 1, 0x84, 8);\n\tp = frame + width + 8;\n\tfor(y = 0; y < 7; y++) {\n\t\t*p = 0x84;\n\t\tp += width;\n\t}\n\t/* Timing pattern */\n\tp = frame + 8;\n\tq = frame + width * 8;\n\tfor(x = 1; x < width-7; x++) {\n\t\t*p =  0x90 | (x & 1);\n\t\t*q =  0x90 | (x & 1);\n\t\tp++;\n\t\tq += width;\n\t}\n\n\treturn frame;\n}\n\nunsigned char *MQRspec_newFrame(int version)\n{\n\tif(version < 1 || version > MQRSPEC_VERSION_MAX) return NULL;\n\n\treturn MQRspec_createFrame(version);\n}\n"
        },
        {
          "name": "mqrspec.h",
          "type": "blob",
          "size": 4.8271484375,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Micro QR Code specification in convenient format.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef MQRSPEC_H\n#define MQRSPEC_H\n\n#include \"qrencode.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\n/**\n * Maximum width of a symbol\n */\n#define MQRSPEC_WIDTH_MAX 17\n\n/**\n * Return maximum data code length (bits) for the version.\n * @param version version of the symbol\n * @param level error correction level\n * @return maximum size (bits)\n */\nextern int MQRspec_getDataLengthBit(int version, QRecLevel level);\n\n/**\n * Return maximum data code length (bytes) for the version.\n * @param version version of the symbol\n * @param level error correction level\n * @return maximum size (bytes)\n */\nextern int MQRspec_getDataLength(int version, QRecLevel level);\n\n/**\n * Return maximum error correction code length (bytes) for the version.\n * @param version version of the symbol\n * @param level error correction level\n * @return ECC size (bytes)\n */\nextern int MQRspec_getECCLength(int version, QRecLevel level);\n\n/**\n * Return a version number that satisfies the input code length.\n * @param size input code length (byte)\n * @param level error correction level\n * @return version number\n */\nextern int MQRspec_getMinimumVersion(int size, QRecLevel level);\n\n/**\n * Return the width of the symbol for the version.\n * @param version version of the symbol\n * @return width\n */\nextern int MQRspec_getWidth(int version);\n\n/**\n * Return the numer of remainder bits.\n * @param version version of the symbol\n * @return number of remainder bits\n */\nextern int MQRspec_getRemainder(int version);\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\n/**\n * Return the size of length indicator for the mode and version.\n * @param mode encode mode\n * @param version vesion of the symbol\n * @return the size of the appropriate length indicator (bits).\n */\nextern int MQRspec_lengthIndicator(QRencodeMode mode, int version);\n\n/**\n * Return the maximum length for the mode and version.\n * @param mode encode mode\n * @param version vesion of the symbol\n * @return the maximum length (bytes)\n */\nextern int MQRspec_maximumWords(QRencodeMode mode, int version);\n\n/******************************************************************************\n * Version information pattern\n *****************************************************************************/\n\n/**\n * Return BCH encoded version information pattern that is used for the symbol\n * of version 7 or greater. Use lower 18 bits.\n * @param version vesion of the symbol\n * @return BCH encoded version information pattern\n */\nextern unsigned int MQRspec_getVersionPattern(int version);\n\n/******************************************************************************\n * Format information\n *****************************************************************************/\n\n/**\n * Return BCH encoded format information pattern.\n * @param mask mask number\n * @param version version of the symbol\n * @param level error correction level\n * @return BCH encoded format information pattern\n */\nextern unsigned int MQRspec_getFormatInfo(int mask, int version, QRecLevel level);\n\n/******************************************************************************\n * Frame\n *****************************************************************************/\n\n/**\n * Return a copy of initialized frame.\n * @param version version of the symbol\n * @return Array of unsigned char. You can free it by free().\n */\nextern unsigned char *MQRspec_newFrame(int version);\n\n/******************************************************************************\n * Mode indicator\n *****************************************************************************/\n\n/**\n * Mode indicator. See Table 2 in Appendix 1 of JIS X0510:2004, pp.107.\n */\n#define MQRSPEC_MODEID_NUM       0\n#define MQRSPEC_MODEID_AN        1\n#define MQRSPEC_MODEID_8         2\n#define MQRSPEC_MODEID_KANJI     3\n\n#endif /* MQRSPEC_H */\n"
        },
        {
          "name": "qrenc.c",
          "type": "blob",
          "size": 36.19140625,
          "content": "/**\n * qrencode - QR Code encoder\n *\n * QR Code encoding tool\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <getopt.h>\n#include <errno.h>\n#if HAVE_PNG\n#include <png.h>\n#endif\n\n#include \"qrencode.h\"\n\n#define INCHES_PER_METER (100.0/2.54)\n\nstatic int casesensitive = 1;\nstatic int eightbit = 0;\nstatic int version = 0;\nstatic int size = 3;\nstatic int margin = -1;\nstatic int dpi = 72;\nstatic int structured = 0;\nstatic int rle = 0;\nstatic int svg_path = 0;\nstatic int micro = 0;\nstatic int inline_svg = 0;\nstatic int strict_versioning = 0;\nstatic QRecLevel level = QR_ECLEVEL_L;\nstatic QRencodeMode hint = QR_MODE_8;\nstatic unsigned char fg_color[4] = {0, 0, 0, 255};\nstatic unsigned char bg_color[4] = {255, 255, 255, 255};\n\nstatic int verbose = 0;\n\nenum imageType {\n\tPNG_TYPE,\n\tPNG32_TYPE,\n\tEPS_TYPE,\n\tSVG_TYPE,\n\tXPM_TYPE,\n\tANSI_TYPE,\n\tANSI256_TYPE,\n\tASCII_TYPE,\n\tASCIIi_TYPE,\n\tUTF8_TYPE,\n\tANSIUTF8_TYPE,\n\tANSI256UTF8_TYPE,\n\tUTF8i_TYPE,\n\tANSIUTF8i_TYPE\n};\n\nstatic enum imageType image_type = PNG_TYPE;\n\nstatic const struct option options[] = {\n\t{\"help\"          , no_argument      , NULL, 'h'},\n\t{\"output\"        , required_argument, NULL, 'o'},\n\t{\"read-from\"     , required_argument, NULL, 'r'},\n\t{\"level\"         , required_argument, NULL, 'l'},\n\t{\"size\"          , required_argument, NULL, 's'},\n\t{\"symversion\"    , required_argument, NULL, 'v'},\n\t{\"margin\"        , required_argument, NULL, 'm'},\n\t{\"dpi\"           , required_argument, NULL, 'd'},\n\t{\"type\"          , required_argument, NULL, 't'},\n\t{\"structured\"    , no_argument      , NULL, 'S'},\n\t{\"kanji\"         , no_argument      , NULL, 'k'},\n\t{\"casesensitive\" , no_argument      , NULL, 'c'},\n\t{\"ignorecase\"    , no_argument      , NULL, 'i'},\n\t{\"8bit\"          , no_argument      , NULL, '8'},\n\t{\"micro\"         , no_argument      , NULL, 'M'},\n\t{\"rle\"           , no_argument      , &rle,   1},\n\t{\"svg-path\"      , no_argument      , &svg_path, 1},\n\t{\"inline\"        , no_argument      , &inline_svg, 1},\n\t{\"strict-version\", no_argument      , &strict_versioning, 1},\n\t{\"foreground\"    , required_argument, NULL, 'f'},\n\t{\"background\"    , required_argument, NULL, 'b'},\n\t{\"version\"       , no_argument      , NULL, 'V'},\n\t{\"verbose\"       , no_argument      , &verbose, 1},\n\t{NULL, 0, NULL, 0}\n};\n\nstatic char *optstring = \"ho:r:l:s:v:m:d:t:Skci8MV\";\n\nstatic void usage(int help, int longopt, int status)\n{\n\tFILE *out = status ? stderr : stdout;\n\tfprintf(out,\n\"qrencode version %s\\n\"\n\"Copyright (C) 2006-2017 Kentaro Fukuchi\\n\", QRcode_APIVersionString());\n\tif(help) {\n\t\tif(longopt) {\n\t\t\tfprintf(out,\n\"Usage: qrencode [-o FILENAME] [OPTION]... [STRING]\\n\"\n\"Encode input data in a QR Code and save as a PNG or EPS image.\\n\\n\"\n\"  -h, --help   display the help message. -h displays only the help of short\\n\"\n\"               options.\\n\\n\"\n\"  -o FILENAME, --output=FILENAME\\n\"\n\"               write image to FILENAME. If '-' is specified, the result\\n\"\n\"               will be output to standard output. If -S is given, structured\\n\"\n\"               symbols are written to FILENAME-01.png, FILENAME-02.png, ...\\n\"\n\"               (suffix is removed from FILENAME, if specified)\\n\\n\"\n\"  -r FILENAME, --read-from=FILENAME\\n\"\n\"               read input data from FILENAME.\\n\\n\"\n\"  -s NUMBER, --size=NUMBER\\n\"\n\"               specify module size in dots (pixels). (default=3)\\n\\n\"\n\"  -l {LMQH}, --level={LMQH}\\n\"\n\"               specify error correction level from L (lowest) to H (highest).\\n\"\n\"               (default=L)\\n\\n\"\n\"  -v NUMBER, --symversion=NUMBER\\n\"\n\"               specify the minimum version of the symbol. See SYMBOL VERSIONS\\n\"\n\"               for more information. (default=auto)\\n\\n\"\n\"  -m NUMBER, --margin=NUMBER\\n\"\n\"               specify the width of the margins. (default=4 (2 for Micro QR)))\\n\\n\"\n\"  -d NUMBER, --dpi=NUMBER\\n\"\n\"               specify the DPI of the generated PNG. (default=72)\\n\\n\"\n\"  -t {PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8},\\n\"\n\"  --type={PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8}\\n\"\n\"               specify the type of the generated image. (default=PNG)\\n\\n\"\n\"  -S, --structured\\n\"\n\"               make structured symbols. Version must be specified with '-v'.\\n\\n\"\n\"  -k, --kanji  assume that the input text contains kanji (shift-jis).\\n\\n\"\n\"  -c, --casesensitive\\n\"\n\"               encode lower-case alphabet characters in 8-bit mode. (default)\\n\\n\"\n\"  -i, --ignorecase\\n\"\n\"               ignore case distinctions and use only upper-case characters.\\n\\n\"\n\"  -8, --8bit   encode entire data in 8-bit mode. -k, -c and -i will be ignored.\\n\\n\"\n\"  -M, --micro  encode in a Micro QR Code.\\n\\n\"\n\"      --rle    enable run-length encoding for SVG.\\n\\n\"\n\"      --svg-path\\n\"\n\"               use single path to draw modules for SVG.\\n\\n\"\n\"      --inline only useful for SVG output, generates an SVG without the XML tag.\\n\\n\"\n\"      --foreground=RRGGBB[AA]\\n\"\n\"      --background=RRGGBB[AA]\\n\"\n\"               specify foreground/background color in hexadecimal notation.\\n\"\n\"               6-digit (RGB) or 8-digit (RGBA) form are supported.\\n\"\n\"               Color output support available only in PNG, EPS and SVG.\\n\\n\"\n\"      --strict-version\\n\"\n\"               disable automatic version number adjustment. If the input data is\\n\"\n\"               too large for the specified version, the program exits with the\\n\"\n\"               code of 1.\\n\\n\"\n\"  -V, --version\\n\"\n\"               display the version number and copyrights of the qrencode.\\n\\n\"\n\"      --verbose\\n\"\n\"               display verbose information to stderr.\\n\\n\"\n\"  [STRING]     input data. If it is not specified, data will be taken from\\n\"\n\"               standard input.\\n\\n\"\n\"SYMBOL VERSIONS\\n\"\n\"               The symbol versions of QR Code range from Version 1 to Version\\n\"\n\"               40. Each version has a different module configuration or number\\n\"\n\"               of modules, ranging from Version 1 (21 x 21 modules) up to\\n\"\n\"               Version 40 (177 x 177 modules). Each higher version number\\n\"\n\"               comprises 4 additional modules per side by default. See\\n\"\n\"               http://www.qrcode.com/en/about/version.html for a detailed\\n\"\n\"               version list.\\n\"\n\n\t\t\t);\n\t\t} else {\n\t\t\tfprintf(out,\n\"Usage: qrencode [-o FILENAME] [OPTION]... [STRING]\\n\"\n\"Encode input data in a QR Code and save as a PNG or EPS image.\\n\\n\"\n\"  -h           display this message.\\n\"\n\"  --help       display the usage of long options.\\n\"\n\"  -o FILENAME  write image to FILENAME. If '-' is specified, the result\\n\"\n\"               will be output to standard output. If -S is given, structured\\n\"\n\"               symbols are written to FILENAME-01.png, FILENAME-02.png, ...\\n\"\n\"               (suffix is removed from FILENAME, if specified)\\n\"\n\"  -r FILENAME  read input data from FILENAME.\\n\"\n\"  -s NUMBER    specify module size in dots (pixels). (default=3)\\n\"\n\"  -l {LMQH}    specify error correction level from L (lowest) to H (highest).\\n\"\n\"               (default=L)\\n\"\n\"  -v NUMBER    specify the minimum version of the symbol. (default=auto)\\n\"\n\"  -m NUMBER    specify the width of the margins. (default=4 (2 for Micro))\\n\"\n\"  -d NUMBER    specify the DPI of the generated PNG. (default=72)\\n\"\n\"  -t {PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8}\\n\"\n\"               specify the type of the generated image. (default=PNG)\\n\"\n\"  -S           make structured symbols. Version number must be specified with '-v'.\\n\"\n\"  -k           assume that the input text contains kanji (shift-jis).\\n\"\n\"  -c           encode lower-case alphabet characters in 8-bit mode. (default)\\n\"\n\"  -i           ignore case distinctions and use only upper-case characters.\\n\"\n\"  -8           encode entire data in 8-bit mode. -k, -c and -i will be ignored.\\n\"\n\"  -M           encode in a Micro QR Code.\\n\"\n\"  -V           display the version number and copyrights of the qrencode.\\n\"\n\"  [STRING]     input data. If it is not specified, data will be taken from\\n\"\n\"               standard input.\\n\\n\"\n\"  Try \\\"qrencode --help\\\" for more options.\\n\"\n\t\t\t);\n\t\t}\n\t}\n}\n\nstatic int color_set(unsigned char color[4], const char *value)\n{\n\tint len = strlen(value);\n\tint i, count;\n\tunsigned int col[4];\n\tif(len == 6) {\n\t\tcount = sscanf(value, \"%02x%02x%02x%n\", &col[0], &col[1], &col[2], &len);\n\t\tif(count < 3 || len != 6) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor(i = 0; i < 3; i++) {\n\t\t\tcolor[i] = col[i];\n\t\t}\n\t\tcolor[3] = 255;\n\t} else if(len == 8) {\n\t\tcount = sscanf(value, \"%02x%02x%02x%02x%n\", &col[0], &col[1], &col[2], &col[3], &len);\n\t\tif(count < 4 || len != 8) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor(i = 0; i < 4; i++) {\n\t\t\tcolor[i] = col[i];\n\t\t}\n\t} else {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n#define MAX_DATA_SIZE (7090 * 2) /* timed by the safty factor 2 */\nstatic unsigned char data_buffer[MAX_DATA_SIZE];\nstatic unsigned char *readFile(FILE *fp, int *length)\n{\n\tint ret;\n\n\tret = fread(data_buffer, 1, MAX_DATA_SIZE, fp);\n\tif(ret == 0) {\n\t\tfprintf(stderr, \"No input data.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif(feof(fp) == 0) {\n\t\tfprintf(stderr, \"Input data is too large.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tdata_buffer[ret] = '\\0';\n\t*length = ret;\n\n\treturn data_buffer;\n}\n\nstatic FILE *openFile(const char *outfile)\n{\n\tFILE *fp;\n\n\tif(outfile == NULL || (outfile[0] == '-' && outfile[1] == '\\0')) {\n\t\tfp = stdout;\n\t} else {\n\t\tfp = fopen(outfile, \"wb\");\n\t\tif(fp == NULL) {\n\t\t\tfprintf(stderr, \"Failed to create file: %s\\n\", outfile);\n\t\t\tperror(NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\treturn fp;\n}\n\n#if HAVE_PNG\nstatic void fillRow(unsigned char *row, int num, const unsigned char color[])\n{\n\tint i;\n\n\tfor(i = 0; i < num; i++) {\n\t\tmemcpy(row, color, 4);\n\t\trow += 4;\n\t}\n}\n#endif\n\nstatic int writePNG(const QRcode *qrcode, const char *outfile, enum imageType type)\n{\n#if HAVE_PNG\n\tstatic FILE *fp; // avoid clobbering by setjmp.\n\tpng_structp png_ptr;\n\tpng_infop info_ptr;\n\tpng_colorp palette = NULL;\n\tpng_byte alpha_values[2];\n\tunsigned char *row, *p, *q;\n\tint x, y, xx, yy, bit;\n\tint realwidth;\n\n\trealwidth = (qrcode->width + margin * 2) * size;\n\tif(type == PNG_TYPE) {\n\t\trow = (unsigned char *)malloc((size_t)((realwidth + 7) / 8));\n\t} else if(type == PNG32_TYPE) {\n\t\trow = (unsigned char *)malloc((size_t)realwidth * 4);\n\t} else {\n\t\tfprintf(stderr, \"Internal error.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tif(row == NULL) {\n\t\tfprintf(stderr, \"Failed to allocate memory.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(outfile[0] == '-' && outfile[1] == '\\0') {\n\t\tfp = stdout;\n\t} else {\n\t\tfp = fopen(outfile, \"wb\");\n\t\tif(fp == NULL) {\n\t\t\tfprintf(stderr, \"Failed to create file: %s\\n\", outfile);\n\t\t\tperror(NULL);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tpng_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);\n\tif(png_ptr == NULL) {\n\t\tfprintf(stderr, \"Failed to initialize PNG writer.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tinfo_ptr = png_create_info_struct(png_ptr);\n\tif(info_ptr == NULL) {\n\t\tfprintf(stderr, \"Failed to initialize PNG write.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(setjmp(png_jmpbuf(png_ptr))) {\n\t\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\t\tfprintf(stderr, \"Failed to write PNG image.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(type == PNG_TYPE) {\n\t\tpalette = (png_colorp) malloc(sizeof(png_color) * 2);\n\t\tif(palette == NULL) {\n\t\t\tfprintf(stderr, \"Failed to allocate memory.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tpalette[0].red   = fg_color[0];\n\t\tpalette[0].green = fg_color[1];\n\t\tpalette[0].blue  = fg_color[2];\n\t\tpalette[1].red   = bg_color[0];\n\t\tpalette[1].green = bg_color[1];\n\t\tpalette[1].blue  = bg_color[2];\n\t\talpha_values[0] = fg_color[3];\n\t\talpha_values[1] = bg_color[3];\n\t\tpng_set_PLTE(png_ptr, info_ptr, palette, 2);\n\t\tpng_set_tRNS(png_ptr, info_ptr, alpha_values, 2, NULL);\n\t}\n\n\tpng_init_io(png_ptr, fp);\n\tif(type == PNG_TYPE) {\n\t\tpng_set_IHDR(png_ptr, info_ptr,\n\t\t\t\t(unsigned int)realwidth, (unsigned int)realwidth,\n\t\t\t\t1,\n\t\t\t\tPNG_COLOR_TYPE_PALETTE,\n\t\t\t\tPNG_INTERLACE_NONE,\n\t\t\t\tPNG_COMPRESSION_TYPE_DEFAULT,\n\t\t\t\tPNG_FILTER_TYPE_DEFAULT);\n\t} else {\n\t\tpng_set_IHDR(png_ptr, info_ptr,\n\t\t\t\t(unsigned int)realwidth, (unsigned int)realwidth,\n\t\t\t\t8,\n\t\t\t\tPNG_COLOR_TYPE_RGB_ALPHA,\n\t\t\t\tPNG_INTERLACE_NONE,\n\t\t\t\tPNG_COMPRESSION_TYPE_DEFAULT,\n\t\t\t\tPNG_FILTER_TYPE_DEFAULT);\n\t}\n\tpng_set_pHYs(png_ptr, info_ptr,\n\t\t\tdpi * INCHES_PER_METER,\n\t\t\tdpi * INCHES_PER_METER,\n\t\t\tPNG_RESOLUTION_METER);\n\tpng_write_info(png_ptr, info_ptr);\n\n\tif(type == PNG_TYPE) {\n\t/* top margin */\n\t\tmemset(row, 0xff, (size_t)((realwidth + 7) / 8));\n\t\tfor(y = 0; y < margin * size; y++) {\n\t\t\tpng_write_row(png_ptr, row);\n\t\t}\n\n\t\t/* data */\n\t\tp = qrcode->data;\n\t\tfor(y = 0; y < qrcode->width; y++) {\n\t\t\tmemset(row, 0xff, (size_t)((realwidth + 7) / 8));\n\t\t\tq = row;\n\t\t\tq += margin * size / 8;\n\t\t\tbit = 7 - (margin * size % 8);\n\t\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\t\tfor(xx = 0; xx < size; xx++) {\n\t\t\t\t\t*q ^= (*p & 1) << bit;\n\t\t\t\t\tbit--;\n\t\t\t\t\tif(bit < 0) {\n\t\t\t\t\t\tq++;\n\t\t\t\t\t\tbit = 7;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tfor(yy = 0; yy < size; yy++) {\n\t\t\t\tpng_write_row(png_ptr, row);\n\t\t\t}\n\t\t}\n\t\t/* bottom margin */\n\t\tmemset(row, 0xff, (size_t)((realwidth + 7) / 8));\n\t\tfor(y = 0; y < margin * size; y++) {\n\t\t\tpng_write_row(png_ptr, row);\n\t\t}\n\t} else {\n\t/* top margin */\n\t\tfillRow(row, realwidth, bg_color);\n\t\tfor(y = 0; y < margin * size; y++) {\n\t\t\tpng_write_row(png_ptr, row);\n\t\t}\n\n\t\t/* data */\n\t\tp = qrcode->data;\n\t\tfor(y = 0; y < qrcode->width; y++) {\n\t\t\tfillRow(row, realwidth, bg_color);\n\t\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\t\tfor(xx = 0; xx < size; xx++) {\n\t\t\t\t\tif(*p & 1) {\n\t\t\t\t\t\tmemcpy(&row[((margin + x) * size + xx) * 4], fg_color, 4);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\t\t\tfor(yy = 0; yy < size; yy++) {\n\t\t\t\tpng_write_row(png_ptr, row);\n\t\t\t}\n\t\t}\n\t\t/* bottom margin */\n\t\tfillRow(row, realwidth, bg_color);\n\t\tfor(y = 0; y < margin * size; y++) {\n\t\t\tpng_write_row(png_ptr, row);\n\t\t}\n\t}\n\n\tpng_write_end(png_ptr, info_ptr);\n\tpng_destroy_write_struct(&png_ptr, &info_ptr);\n\n\tfclose(fp);\n\tfree(row);\n\tfree(palette);\n\n\treturn 0;\n#else\n\tfputs(\"PNG output is disabled at compile time. No output generated.\\n\", stderr);\n\treturn 0;\n#endif\n}\n\nstatic int writeEPS(const QRcode *qrcode, const char *outfile)\n{\n\tFILE *fp;\n\tunsigned char *row, *p;\n\tint x, y, yy;\n\tint realwidth;\n\n\tfp = openFile(outfile);\n\n\trealwidth = (qrcode->width + margin * 2) * size;\n\t/* EPS file header */\n\tfprintf(fp, \"%%!PS-Adobe-2.0 EPSF-1.2\\n\"\n\t\t\t\t\"%%%%BoundingBox: 0 0 %d %d\\n\"\n\t\t\t\t\"%%%%Pages: 1 1\\n\"\n\t\t\t\t\"%%%%EndComments\\n\", realwidth, realwidth);\n\t/* draw point */\n\tfprintf(fp, \"/p { \"\n\t\t\t\t\"moveto \"\n\t\t\t\t\"0 1 rlineto \"\n\t\t\t\t\"1 0 rlineto \"\n\t\t\t\t\"0 -1 rlineto \"\n\t\t\t\t\"fill \"\n\t\t\t\t\"} bind def\\n\");\n\t/* set color */\n\tfprintf(fp, \"gsave\\n\");\n\tfprintf(fp, \"%f %f %f setrgbcolor\\n\",\n\t\t\t(float)bg_color[0] / 255,\n\t\t\t(float)bg_color[1] / 255,\n\t\t\t(float)bg_color[2] / 255);\n\tfprintf(fp, \"%d %d scale\\n\", realwidth, realwidth);\n\tfprintf(fp, \"0 0 p\\ngrestore\\n\");\n\tfprintf(fp, \"%f %f %f setrgbcolor\\n\",\n\t\t\t(float)fg_color[0] / 255,\n\t\t\t(float)fg_color[1] / 255,\n\t\t\t(float)fg_color[2] / 255);\n\tfprintf(fp, \"%d %d scale\\n\", size, size);\n\n\t/* data */\n\tp = qrcode->data;\n\tfor(y = 0; y < qrcode->width; y++) {\n\t\trow = (p+(y*qrcode->width));\n\t\tyy = (margin + qrcode->width - y - 1);\n\n\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\tif(*(row+x)&0x1) {\n\t\t\t\tfprintf(fp, \"%d %d p \", margin + x,  yy);\n\t\t\t}\n\t\t}\n\t}\n\n\tfprintf(fp, \"\\n%%%%EOF\\n\");\n\tfclose(fp);\n\n\treturn 0;\n}\n\nstatic void writeSVG_drawModules(FILE *fp, int x, int y, int width, const char* col, float opacity)\n{\n\tif(svg_path) {\n\t\tfprintf(fp, \"M%d,%dh%d\", x, y, width);\n\t} else {\n\t\tif(fg_color[3] != 255) {\n\t\t\tfprintf(fp, \"\\t\\t\\t<rect x=\\\"%d\\\" y=\\\"%d\\\" width=\\\"%d\\\" height=\\\"1\\\" \"\\\n\t\t\t\t\t\"fill=\\\"#%s\\\" fill-opacity=\\\"%f\\\"/>\\n\",\n\t\t\t\t\tx, y, width, col, opacity );\n\t\t} else {\n\t\t\tfprintf(fp, \"\\t\\t\\t<rect x=\\\"%d\\\" y=\\\"%d\\\" width=\\\"%d\\\" height=\\\"1\\\" \"\\\n\t\t\t\t\t\"fill=\\\"#%s\\\"/>\\n\",\n\t\t\t\t\tx, y, width, col );\n\t\t}\n\t}\n}\n\nstatic int writeSVG(const QRcode *qrcode, const char *outfile)\n{\n\tFILE *fp;\n\tunsigned char *row, *p;\n\tint x, y, x0, pen;\n\tint symwidth, realwidth;\n\tfloat scale;\n\tchar fg[7], bg[7];\n\tfloat fg_opacity;\n\tfloat bg_opacity;\n\n\tfp = openFile(outfile);\n\n\tscale = dpi * INCHES_PER_METER / 100.0;\n\n\tsymwidth = qrcode->width + margin * 2;\n\trealwidth = symwidth * size;\n\n\tsnprintf(fg, 7, \"%02x%02x%02x\", fg_color[0], fg_color[1],  fg_color[2]);\n\tsnprintf(bg, 7, \"%02x%02x%02x\", bg_color[0], bg_color[1],  bg_color[2]);\n\tfg_opacity = (float)fg_color[3] / 255;\n\tbg_opacity = (float)bg_color[3] / 255;\n\n\t/* XML declaration */\n\tif (!inline_svg)\n\t\tfputs( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n\", fp );\n\n\t/* DTD\n\t   No document type specified because \"while a DTD is provided in [the SVG]\n\t   specification, the use of DTDs for validating XML documents is known to\n\t   be problematic. In particular, DTDs do not handle namespaces gracefully.\n\t   It is *not* recommended that a DOCTYPE declaration be included in SVG\n\t   documents.\"\n\t   http://www.w3.org/TR/2003/REC-SVG11-20030114/intro.html#Namespace\n\t*/\n\n\t/* Vanity remark */\n\tfprintf(fp, \"<!-- Created with qrencode %s (https://fukuchi.org/works/qrencode/index.html) -->\\n\", QRcode_APIVersionString());\n\n\t/* SVG code start */\n\tfprintf(fp,\n\t\t\t\"<svg width=\\\"%.2fcm\\\" height=\\\"%.2fcm\\\" viewBox=\\\"0 0 %d %d\\\"\"\\\n\t\t\t\" preserveAspectRatio=\\\"none\\\" version=\\\"1.1\\\"\"\\\n\t\t\t\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\",\n\t\t\trealwidth / scale, realwidth / scale, symwidth, symwidth\n\t\t   );\n\n\t/* Make named group */\n\tfputs(\"\\t<g id=\\\"QRcode\\\">\\n\", fp);\n\n\t/* Make solid background */\n\tif(bg_color[3] != 255) {\n\t\tfprintf(fp, \"\\t\\t<rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"%d\\\" height=\\\"%d\\\" fill=\\\"#%s\\\" fill-opacity=\\\"%f\\\"/>\\n\", symwidth, symwidth, bg, bg_opacity);\n\t} else {\n\t\tfprintf(fp, \"\\t\\t<rect x=\\\"0\\\" y=\\\"0\\\" width=\\\"%d\\\" height=\\\"%d\\\" fill=\\\"#%s\\\"/>\\n\", symwidth, symwidth, bg);\n\t}\n\n\tif(svg_path) {\n\t\tif(fg_color[3] != 255) {\n\t\t\tfprintf(fp, \"\\t\\t<path style=\\\"stroke:#%s;stroke-opacity:%f\\\" transform=\\\"translate(%d,%d.5)\\\" d=\\\"\", fg, fg_opacity, margin, margin);\n\t\t} else {\n\t\t\tfprintf(fp, \"\\t\\t<path style=\\\"stroke:#%s\\\" transform=\\\"translate(%d,%d.5)\\\" d=\\\"\", fg, margin, margin);\n\t\t}\n\t} else {\n\t\t/* Create new viewbox for QR data */\n\t\tfprintf(fp, \"\\t\\t<g id=\\\"Pattern\\\" transform=\\\"translate(%d,%d)\\\">\\n\", margin, margin);\n\t}\n\n\t/* Write data */\n\tp = qrcode->data;\n\tfor(y = 0; y < qrcode->width; y++) {\n\t\trow = (p+(y*qrcode->width));\n\n\t\tif( !rle ) {\n\t\t\t/* no RLE */\n\t\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\t\tif(*(row+x)&0x1) {\n\t\t\t\t\twriteSVG_drawModules(fp, x, y, 1, fg, fg_opacity);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* simple RLE */\n\t\t\tpen = 0;\n\t\t\tx0  = 0;\n\t\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\t\tif( !pen ) {\n\t\t\t\t\tpen = *(row+x)&0x1;\n\t\t\t\t\tx0 = x;\n\t\t\t\t} else if(!(*(row+x)&0x1)) {\n\t\t\t\t\twriteSVG_drawModules(fp, x0, y, x-x0, fg, fg_opacity);\n\t\t\t\t\tpen = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( pen ) {\n\t\t\t\twriteSVG_drawModules(fp, x0, y, qrcode->width - x0, fg, fg_opacity);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(svg_path) {\n\t\tfputs(\"\\\"/>\\n\", fp);\n\t} else {\n\t\t/* Close QR data viewbox */\n\t\tfputs(\"\\t\\t</g>\\n\", fp);\n\t}\n\n\t/* Close group */\n\tfputs(\"\\t</g>\\n\", fp);\n\n\t/* Close SVG code */\n\tfputs(\"</svg>\\n\", fp);\n\tfclose(fp);\n\n\treturn 0;\n}\n\nstatic int writeXPM(const QRcode *qrcode, const char *outfile)\n{\n\tFILE *fp;\n\tint x, xx, y, yy, realwidth, realmargin;\n\tchar *row;\n\tchar fg[7], bg[7];\n\tunsigned char *p;\n\n\tfp = openFile(outfile);\n\n\trealwidth = (qrcode->width + margin * 2) * size;\n\trealmargin = margin * size;\n\n\trow = malloc((size_t)realwidth + 1);\n\tif (!row ) {\n\t\tfprintf(stderr, \"Failed to allocate memory.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tsnprintf(fg, 7, \"%02x%02x%02x\", fg_color[0], fg_color[1],  fg_color[2]);\n\tsnprintf(bg, 7, \"%02x%02x%02x\", bg_color[0], bg_color[1],  bg_color[2]);\n\n\tfputs(\"/* XPM */\\n\", fp);\n\tfputs(\"static const char *const qrcode_xpm[] = {\\n\", fp);\n\tfputs(\"/* width height ncolors chars_per_pixel */\\n\", fp);\n\tfprintf(fp, \"\\\"%d %d 2 1\\\",\\n\", realwidth, realwidth);\n\n\tfputs(\"/* colors */\\n\", fp);\n\tfprintf(fp, \"\\\"F c #%s\\\",\\n\", fg);\n\tfprintf(fp, \"\\\"B c #%s\\\",\\n\", bg);\n\n\tfputs(\"/* pixels */\\n\", fp);\n\tmemset(row, 'B', (size_t)realwidth);\n\trow[realwidth] = '\\0';\n\n\tfor (y = 0; y < realmargin; y++) {\n\t\tfprintf(fp, \"\\\"%s\\\",\\n\", row);\n\t}\n\n\tp = qrcode->data;\n\tfor (y = 0; y < qrcode->width; y++) {\n\t\tfor (yy = 0; yy < size; yy++) {\n\t\t\tfputs(\"\\\"\", fp);\n\n\t\t\tfor (x = 0; x < margin; x++) {\n\t\t\t\tfor (xx = 0; xx < size; xx++) {\n\t\t\t\t\tfputs(\"B\", fp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (x = 0; x < qrcode->width; x++) {\n\t\t\t\tfor (xx = 0; xx < size; xx++) {\n\t\t\t\t\tif (p[(y * qrcode->width) + x] & 0x1) {\n\t\t\t\t\t\tfputs(\"F\", fp);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfputs(\"B\", fp);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (x = 0; x < margin; x++) {\n\t\t\t\tfor (xx = 0; xx < size; xx++) {\n\t\t\t\t\tfputs(\"B\", fp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfputs(\"\\\",\\n\", fp);\n\t\t}\n\t}\n\n\tfor (y = 0; y < realmargin; y++) {\n\t\tfprintf(fp, \"\\\"%s\\\"%s\\n\", row, y < (size - 1) ? \",\" : \"};\");\n\t}\n\n\tfree(row);\n\tfclose(fp);\n\n\treturn 0;\n}\n\nstatic void writeANSI_margin(FILE* fp, int realwidth,\n                             char* buffer, const char* white, int white_s )\n{\n\tint y;\n\n\tstrncpy(buffer, white, (size_t)white_s);\n\tmemset(buffer + white_s, ' ', (size_t)realwidth * 2);\n\tstrcpy(buffer + white_s + realwidth * 2, \"\\033[0m\\n\"); // reset to default colors\n\tfor(y = 0; y < margin; y++ ){\n\t\tfputs(buffer, fp);\n\t}\n}\n\nstatic int writeANSI(const QRcode *qrcode, const char *outfile)\n{\n\tFILE *fp;\n\tunsigned char *row, *p;\n\tint x, y;\n\tint realwidth;\n\tint last;\n\n\tconst char *white, *black;\n\tchar *buffer;\n\tint white_s, black_s, buffer_s;\n\n\tif(image_type == ANSI256_TYPE){\n\t\t/* codes for 256 color compatible terminals */\n\t\twhite = \"\\033[48;5;231m\";\n\t\twhite_s = 11;\n\t\tblack = \"\\033[48;5;16m\";\n\t\tblack_s = 10;\n\t} else {\n\t\twhite = \"\\033[47m\";\n\t\twhite_s = 5;\n\t\tblack = \"\\033[40m\";\n\t\tblack_s = 5;\n\t}\n\n\tsize = 1;\n\n\tfp = openFile(outfile);\n\n\trealwidth = (qrcode->width + margin * 2) * size;\n\tbuffer_s = (realwidth * white_s) * 2;\n\tbuffer = (char *)malloc((size_t)buffer_s);\n\tif(buffer == NULL) {\n\t\tfprintf(stderr, \"Failed to allocate memory.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* top margin */\n\twriteANSI_margin(fp, realwidth, buffer, white, white_s);\n\n\t/* data */\n\tp = qrcode->data;\n\tfor(y = 0; y < qrcode->width; y++) {\n\t\trow = (p+(y*qrcode->width));\n\n\t\tmemset(buffer, 0, (size_t)buffer_s);\n\t\tstrncpy(buffer, white, (size_t)white_s);\n\t\tfor(x = 0; x < margin; x++ ){\n\t\t\tstrncat(buffer, \"  \", 2);\n\t\t}\n\t\tlast = 0;\n\n\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\tif(*(row+x)&0x1) {\n\t\t\t\tif( last != 1 ){\n\t\t\t\t\tstrncat(buffer, black, (size_t)black_s);\n\t\t\t\t\tlast = 1;\n\t\t\t\t}\n\t\t\t} else if( last != 0 ){\n\t\t\t\tstrncat(buffer, white, (size_t)white_s);\n\t\t\t\tlast = 0;\n\t\t\t}\n\t\t\tstrncat(buffer, \"  \", 2);\n\t\t}\n\n\t\tif( last != 0 ){\n\t\t\tstrncat(buffer, white, (size_t)white_s);\n\t\t}\n\t\tfor(x = 0; x < margin; x++ ){\n\t\t\tstrncat(buffer, \"  \", 2);\n\t\t}\n\t\tstrncat(buffer, \"\\033[0m\\n\", 5);\n\t\tfputs(buffer, fp);\n\t}\n\n\t/* bottom margin */\n\twriteANSI_margin(fp, realwidth, buffer, white, white_s);\n\n\tfclose(fp);\n\tfree(buffer);\n\n\treturn 0;\n}\n\nstatic void writeUTF8_margin(FILE* fp, int realwidth, const char* white,\n                             const char *reset, const char* full)\n{\n\tint x, y;\n\n\tfor (y = 0; y < margin/2; y++) {\n\t\tfputs(white, fp);\n\t\tfor (x = 0; x < realwidth; x++)\n\t\t\tfputs(full, fp);\n\t\tfputs(reset, fp);\n\t\tfputc('\\n', fp);\n\t}\n}\n\nstatic int writeUTF8(const QRcode *qrcode, const char *outfile, int use_ansi, int invert)\n{\n\tFILE *fp;\n\tint x, y;\n\tint realwidth;\n\tconst char *white, *reset;\n\tconst char *empty, *lowhalf, *uphalf, *full;\n\n\tempty = \" \";\n\tlowhalf = \"\\342\\226\\204\";\n\tuphalf = \"\\342\\226\\200\";\n\tfull = \"\\342\\226\\210\";\n\n\tif (invert) {\n\t\tconst char *tmp;\n\n\t\ttmp = empty;\n\t\tempty = full;\n\t\tfull = tmp;\n\n\t\ttmp = lowhalf;\n\t\tlowhalf = uphalf;\n\t\tuphalf = tmp;\n\t}\n\n\tif (use_ansi){\n\t\tif (use_ansi == 2) {\n\t\t\twhite = \"\\033[38;5;231m\\033[48;5;16m\";\n\t\t} else {\n\t\t\twhite = \"\\033[40;37;1m\";\n\t\t}\n\t\treset = \"\\033[0m\";\n\t} else {\n\t\twhite = \"\";\n\t\treset = \"\";\n\t}\n\n\tfp = openFile(outfile);\n\n\trealwidth = (qrcode->width + margin * 2);\n\n\t/* top margin */\n\twriteUTF8_margin(fp, realwidth, white, reset, full);\n\n\t/* data */\n\tfor(y = 0; y < qrcode->width; y += 2) {\n\t\tunsigned char *row1, *row2;\n\t\trow1 = qrcode->data + y*qrcode->width;\n\t\trow2 = row1 + qrcode->width;\n\n\t\tfputs(white, fp);\n\n\t\tfor (x = 0; x < margin; x++) {\n\t\t\tfputs(full, fp);\n\t\t}\n\n\t\tfor (x = 0; x < qrcode->width; x++) {\n\t\t\tif(row1[x] & 1) {\n\t\t\t\tif(y < qrcode->width - 1 && row2[x] & 1) {\n\t\t\t\t\tfputs(empty, fp);\n\t\t\t\t} else {\n\t\t\t\t\tfputs(lowhalf, fp);\n\t\t\t\t}\n\t\t\t} else if(y < qrcode->width - 1 && row2[x] & 1) {\n\t\t\t\tfputs(uphalf, fp);\n\t\t\t} else {\n\t\t\t\tfputs(full, fp);\n\t\t\t}\n\t\t}\n\n\t\tfor (x = 0; x < margin; x++)\n\t\t\tfputs(full, fp);\n\n\t\tfputs(reset, fp);\n\t\tfputc('\\n', fp);\n\t}\n\n\t/* bottom margin */\n\twriteUTF8_margin(fp, realwidth, white, reset, full);\n\n\tfclose(fp);\n\n\treturn 0;\n}\n\nstatic void writeASCII_margin(FILE* fp, int realwidth, char* buffer, int invert)\n{\n\tint y, h;\n\n\th = margin;\n\n\tmemset(buffer, (invert?'#':' '), (size_t)realwidth);\n\tbuffer[realwidth] = '\\n';\n\tbuffer[realwidth + 1] = '\\0';\n\tfor(y = 0; y < h; y++ ){\n\t\tfputs(buffer, fp);\n\t}\n}\n\nstatic int writeASCII(const QRcode *qrcode, const char *outfile, int invert)\n{\n\tFILE *fp;\n\tunsigned char *row;\n\tint x, y;\n\tint realwidth;\n\tchar *buffer, *p;\n\tint buffer_s;\n\tchar black = '#';\n\tchar white = ' ';\n\n\tif(invert) {\n\t\tblack = ' ';\n\t\twhite = '#';\n\t}\n\n\tsize = 1;\n\n\tfp = openFile(outfile);\n\n\trealwidth = (qrcode->width + margin * 2) * 2;\n\tbuffer_s = realwidth + 2;\n\tbuffer = (char *)malloc((size_t)buffer_s);\n\tif(buffer == NULL) {\n\t\tfprintf(stderr, \"Failed to allocate memory.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t/* top margin */\n\twriteASCII_margin(fp, realwidth, buffer, invert);\n\n\t/* data */\n\tfor(y = 0; y < qrcode->width; y++) {\n\t\trow = qrcode->data+(y*qrcode->width);\n\t\tp = buffer;\n\n\t\tmemset(p, white, (size_t)margin * 2);\n\t\tp += margin * 2;\n\n\t\tfor(x = 0; x < qrcode->width; x++) {\n\t\t\tif(row[x]&0x1) {\n\t\t\t\t*p++ = black;\n\t\t\t\t*p++ = black;\n\t\t\t} else {\n\t\t\t\t*p++ = white;\n\t\t\t\t*p++ = white;\n\t\t\t}\n\t\t}\n\n\t\tmemset(p, white, (size_t)margin * 2);\n\t\tp += margin * 2;\n\t\t*p++ = '\\n';\n\t\t*p++ = '\\0';\n\t\tfputs( buffer, fp );\n\t}\n\n\t/* bottom margin */\n\twriteASCII_margin(fp, realwidth, buffer, invert);\n\n\tfclose(fp);\n\tfree(buffer);\n\n\treturn 0;\n}\n\nstatic QRcode *encode(const unsigned char *intext, int length)\n{\n\tQRcode *code;\n\n\tif(micro) {\n\t\tif(eightbit) {\n\t\t\tcode = QRcode_encodeDataMQR(length, intext, version, level);\n\t\t} else {\n\t\t\tcode = QRcode_encodeStringMQR((char *)intext, version, level, hint, casesensitive);\n\t\t}\n\t} else if(eightbit) {\n\t\tcode = QRcode_encodeData(length, intext, version, level);\n\t} else {\n\t\tcode = QRcode_encodeString((char *)intext, version, level, hint, casesensitive);\n\t}\n\n\treturn code;\n}\n\nstatic void qrencode(const unsigned char *intext, int length, const char *outfile)\n{\n\tQRcode *qrcode;\n\n\tqrcode = encode(intext, length);\n\tif(qrcode == NULL) {\n\t\tif(errno == ERANGE) {\n\t\t\tfprintf(stderr, \"Failed to encode the input data: Input data too large\\n\");\n\t\t} else {\n\t\t\tperror(\"Failed to encode the input data\");\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\tif(strict_versioning && version > 0 && qrcode->version != version) {\n\t\tfprintf(stderr, \"Failed to encode the input data: Input data too large\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(verbose) {\n\t\tfprintf(stderr, \"File: %s, Version: %d\\n\", (outfile!=NULL)?outfile:\"(stdout)\", qrcode->version);\n\t}\n\n\tswitch(image_type) {\n\t\tcase PNG_TYPE:\n\t\tcase PNG32_TYPE:\n\t\t\twritePNG(qrcode, outfile, image_type);\n\t\t\tbreak;\n\t\tcase EPS_TYPE:\n\t\t\twriteEPS(qrcode, outfile);\n\t\t\tbreak;\n\t\tcase SVG_TYPE:\n\t\t\twriteSVG(qrcode, outfile);\n\t\t\tbreak;\n\t\tcase XPM_TYPE:\n\t\t\twriteXPM(qrcode, outfile);\n\t\t\tbreak;\n\t\tcase ANSI_TYPE:\n\t\tcase ANSI256_TYPE:\n\t\t\twriteANSI(qrcode, outfile);\n\t\t\tbreak;\n\t\tcase ASCIIi_TYPE:\n\t\t\twriteASCII(qrcode, outfile,  1);\n\t\t\tbreak;\n\t\tcase ASCII_TYPE:\n\t\t\twriteASCII(qrcode, outfile,  0);\n\t\t\tbreak;\n\t\tcase UTF8_TYPE:\n\t\t\twriteUTF8(qrcode, outfile, 0, 0);\n\t\t\tbreak;\n\t\tcase ANSIUTF8_TYPE:\n\t\t\twriteUTF8(qrcode, outfile, 1, 0);\n\t\t\tbreak;\n\t\tcase ANSI256UTF8_TYPE:\n\t\t\twriteUTF8(qrcode, outfile, 2, 0);\n\t\t\tbreak;\n\t\tcase UTF8i_TYPE:\n\t\t\twriteUTF8(qrcode, outfile, 0, 1);\n\t\t\tbreak;\n\t\tcase ANSIUTF8i_TYPE:\n\t\t\twriteUTF8(qrcode, outfile, 1, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown image type.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t}\n\n\tQRcode_free(qrcode);\n}\n\nstatic QRcode_List *encodeStructured(const unsigned char *intext, int length)\n{\n\tQRcode_List *list;\n\n\tif(eightbit) {\n\t\tlist = QRcode_encodeDataStructured(length, intext, version, level);\n\t} else {\n\t\tlist = QRcode_encodeStringStructured((char *)intext, version, level, hint, casesensitive);\n\t}\n\n\treturn list;\n}\n\nstatic void qrencodeStructured(const unsigned char *intext, int length, const char *outfile)\n{\n\tQRcode_List *qrlist, *p;\n\tchar filename[FILENAME_MAX];\n\tchar *base, *q, *suffix = NULL;\n\tconst char *type_suffix;\n\tint i = 1;\n\tsize_t suffix_size;\n\n\tswitch(image_type) {\n\t\tcase PNG_TYPE:\n\t\t\ttype_suffix = \".png\";\n\t\t\tbreak;\n\t\tcase EPS_TYPE:\n\t\t\ttype_suffix = \".eps\";\n\t\t\tbreak;\n\t\tcase SVG_TYPE:\n\t\t\ttype_suffix = \".svg\";\n\t\t\tbreak;\n\t\tcase XPM_TYPE:\n\t\t\ttype_suffix = \".xpm\";\n\t\t\tbreak;\n\t\tcase ANSI_TYPE:\n\t\tcase ANSI256_TYPE:\n\t\tcase ASCII_TYPE:\n\t\tcase UTF8_TYPE:\n\t\tcase ANSIUTF8_TYPE:\n\t\tcase UTF8i_TYPE:\n\t\tcase ANSIUTF8i_TYPE:\n\t\t\ttype_suffix = \".txt\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Unknown image type.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(outfile == NULL) {\n\t\tfprintf(stderr, \"An output filename must be specified to store the structured images.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tbase = strdup(outfile);\n\tif(base == NULL) {\n\t\tfprintf(stderr, \"Failed to allocate memory.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tsuffix_size = strlen(type_suffix);\n\tif(strlen(base) > suffix_size) {\n\t\tq = base + strlen(base) - suffix_size;\n\t\tif(strcasecmp(type_suffix, q) == 0) {\n\t\t\tsuffix = strdup(q);\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\n\tqrlist = encodeStructured(intext, length);\n\tif(qrlist == NULL) {\n\t\tif(errno == ERANGE) {\n\t\t\tfprintf(stderr, \"Failed to encode the input data: Input data too large\\n\");\n\t\t} else {\n\t\t\tperror(\"Failed to encode the input data\");\n\t\t}\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tfor(p = qrlist; p != NULL; p = p->next) {\n\t\tif(p->code == NULL) {\n\t\t\tfprintf(stderr, \"Failed to encode the input data.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif(suffix) {\n\t\t\tsnprintf(filename, FILENAME_MAX, \"%s-%02d%s\", base, i, suffix);\n\t\t} else {\n\t\t\tsnprintf(filename, FILENAME_MAX, \"%s-%02d\", base, i);\n\t\t}\n\n\t\tif(verbose) {\n\t\t\tfprintf(stderr, \"File: %s, Version: %d\\n\", filename, p->code->version);\n\t\t}\n\n\t\tswitch(image_type) {\n\t\t\tcase PNG_TYPE:\n\t\t\tcase PNG32_TYPE:\n\t\t\t\twritePNG(p->code, filename, image_type);\n\t\t\t\tbreak;\n\t\t\tcase EPS_TYPE:\n\t\t\t\twriteEPS(p->code, filename);\n\t\t\t\tbreak;\n\t\t\tcase SVG_TYPE:\n\t\t\t\twriteSVG(p->code, filename);\n\t\t\t\tbreak;\n\t\t\tcase XPM_TYPE:\n\t\t\t\twriteXPM(p->code, filename);\n\t\t\t\tbreak;\n\t\t\tcase ANSI_TYPE:\n\t\t\tcase ANSI256_TYPE:\n\t\t\t\twriteANSI(p->code, filename);\n\t\t\t\tbreak;\n\t\t\tcase ASCIIi_TYPE:\n\t\t\t\twriteASCII(p->code, filename, 1);\n\t\t\t\tbreak;\n\t\t\tcase ASCII_TYPE:\n\t\t\t\twriteASCII(p->code, filename, 0);\n\t\t\t\tbreak;\n\t\t\tcase UTF8_TYPE:\n\t\t\t\twriteUTF8(p->code, filename, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase ANSIUTF8_TYPE:\n\t\t\t\twriteUTF8(p->code, filename, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase ANSI256UTF8_TYPE:\n\t\t\t\twriteUTF8(p->code, filename, 0, 0);\n\t\t\t\tbreak;\n\t\t\tcase UTF8i_TYPE:\n\t\t\t\twriteUTF8(p->code, filename, 0, 1);\n\t\t\t\tbreak;\n\t\t\tcase ANSIUTF8i_TYPE:\n\t\t\t\twriteUTF8(p->code, filename, 0, 1);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Unknown image type.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\ti++;\n\t}\n\n\tfree(base);\n\tif(suffix) {\n\t\tfree(suffix);\n\t}\n\n\tQRcode_List_free(qrlist);\n}\n\nint main(int argc, char **argv)\n{\n\tint opt, lindex = -1;\n\tchar *outfile = NULL, *infile = NULL;\n\tunsigned char *intext = NULL;\n\tint length = 0;\n\tFILE *fp;\n\n\twhile((opt = getopt_long(argc, argv, optstring, options, &lindex)) != -1) {\n\t\tswitch(opt) {\n\t\t\tcase 'h':\n\t\t\t\tif(lindex == 0) {\n\t\t\t\t\tusage(1, 1, EXIT_SUCCESS);\n\t\t\t\t} else {\n\t\t\t\t\tusage(1, 0, EXIT_SUCCESS);\n\t\t\t\t}\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 'o':\n\t\t\t\toutfile = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 'r':\n\t\t\t\tinfile = optarg;\n\t\t\t\tbreak;\n\t\t\tcase 's':\n\t\t\t\tsize = atoi(optarg);\n\t\t\t\tif(size <= 0) {\n\t\t\t\t\tfprintf(stderr, \"Invalid size: %d\\n\", size);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'v':\n\t\t\t\tversion = atoi(optarg);\n\t\t\t\tif(version < 0) {\n\t\t\t\t\tfprintf(stderr, \"Invalid version: %d\\n\", version);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'l':\n\t\t\t\tswitch(*optarg) {\n\t\t\t\t\tcase 'l':\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tlevel = QR_ECLEVEL_L;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'm':\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tlevel = QR_ECLEVEL_M;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'q':\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tlevel = QR_ECLEVEL_Q;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'h':\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tlevel = QR_ECLEVEL_H;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfprintf(stderr, \"Invalid level: %s\\n\", optarg);\n\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\t\tmargin = atoi(optarg);\n\t\t\t\tif(margin < 0) {\n\t\t\t\t\tfprintf(stderr, \"Invalid margin: %d\\n\", margin);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\tdpi = atoi(optarg);\n\t\t\t\tif( dpi < 0 ) {\n\t\t\t\t\tfprintf(stderr, \"Invalid DPI: %d\\n\", dpi);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tif(strcasecmp(optarg, \"png32\") == 0) {\n\t\t\t\t\timage_type = PNG32_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"png\") == 0) {\n\t\t\t\t\timage_type = PNG_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"eps\") == 0) {\n\t\t\t\t\timage_type = EPS_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"svg\") == 0) {\n\t\t\t\t\timage_type = SVG_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"xpm\") == 0) {\n\t\t\t\t\timage_type = XPM_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"ansi\") == 0) {\n\t\t\t\t\timage_type = ANSI_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"ansi256\") == 0) {\n\t\t\t\t\timage_type = ANSI256_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"asciii\") == 0) {\n\t\t\t\t\timage_type = ASCIIi_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"ascii\") == 0) {\n\t\t\t\t\timage_type = ASCII_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"utf8\") == 0) {\n\t\t\t\t\timage_type = UTF8_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"ansiutf8\") == 0) {\n\t\t\t\t\timage_type = ANSIUTF8_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"ansi256utf8\") == 0) {\n\t\t\t\t\timage_type = ANSI256UTF8_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"utf8i\") == 0) {\n\t\t\t\t\timage_type = UTF8i_TYPE;\n\t\t\t\t} else if(strcasecmp(optarg, \"ansiutf8i\") == 0) {\n\t\t\t\t\timage_type = ANSIUTF8i_TYPE;\n\t\t\t\t} else {\n\t\t\t\t\tfprintf(stderr, \"Invalid image type: %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tstructured = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'k':\n\t\t\t\thint = QR_MODE_KANJI;\n\t\t\t\tbreak;\n\t\t\tcase 'c':\n\t\t\t\tcasesensitive = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tcasesensitive = 0;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\teightbit = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tmicro = 1;\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif(color_set(fg_color, optarg)) {\n\t\t\t\t\tfprintf(stderr, \"Invalid foreground color value.\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tif(color_set(bg_color, optarg)) {\n\t\t\t\t\tfprintf(stderr, \"Invalid background color value.\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'V':\n\t\t\t\tusage(0, 0, EXIT_SUCCESS);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Try \\\"qrencode --help\\\" for more information.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif(argc == 1) {\n\t\tusage(1, 0, EXIT_FAILURE);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(outfile == NULL && image_type == PNG_TYPE) {\n\t\tfprintf(stderr, \"No output filename is given.\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(optind < argc) {\n\t\tintext = (unsigned char *)argv[optind];\n\t\tlength = strlen((char *)intext);\n\t}\n\tif(intext == NULL) {\n\t\tfp = infile == NULL ? stdin : fopen(infile,\"r\");\n\t\tif(fp == 0) {\n\t\t\tfprintf(stderr, \"Cannot read input file %s.\\n\", infile);\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tintext = readFile(fp,&length);\n\n\t}\n\n\tif(micro && version > MQRSPEC_VERSION_MAX) {\n\t\tfprintf(stderr, \"Version number should be less or equal to %d.\\n\", MQRSPEC_VERSION_MAX);\n\t\texit(EXIT_FAILURE);\n\t} else if(!micro && version > QRSPEC_VERSION_MAX) {\n\t\tfprintf(stderr, \"Version number should be less or equal to %d.\\n\", QRSPEC_VERSION_MAX);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(margin < 0) {\n\t\tif(micro) {\n\t\t\tmargin = 2;\n\t\t} else {\n\t\t\tmargin = 4;\n\t\t}\n\t}\n\n\tif(micro) {\n\t\tif(structured) {\n\t\t\tfprintf(stderr, \"Micro QR Code does not support structured symbols.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif(structured) {\n\t\tif(version == 0) {\n\t\t\tfprintf(stderr, \"Version number must be specified to encode structured symbols.\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tqrencodeStructured(intext, length, outfile);\n\t} else {\n\t\tqrencode(intext, length, outfile);\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "qrencode.1.in",
          "type": "blob",
          "size": 4.240234375,
          "content": ".TH QRENCODE 1 \"Aug. 28, 2020\" \"qrencode @VERSION@\"\n.SH NAME\nqrencode \\- Encode input data in a QR Code and save as a PNG or EPS image.\n.SH SYNOPSIS\n.B \"qrencode\"\n[-o FILENAME]\n[OPTION]...\n[STRING]\n\n.SH DESCRIPTION\nLibqrencode is a library for encoding data in a QR Code symbol, a kind of 2D\nsymbology that can be scanned by handy terminals such as a mobile phone with\nCCD. The capacity of QR Code is up to 7000 digits or 4000 characters, and has\nhigh robustness.\n\nQrencode is a utility software using libqrencode to encode string data in\na QR Code and save as a PNG or EPS image.\n\n.SH OPTIONS\n.TP\n.B \\-h, \\-\\-help\ndisplay help message.\n.TP\n.B \\-o FILENAME, \\-\\-output=FILENAME\nwrite image to FILENAME. If '\\-' is specified, the result will be output to standard output. If \\-S is given, structured symbols are written to FILENAME-01.png, FILENAME-02.png, ... (suffix is removed from FILENAME, if specified)\n.TP\n.B \\-r FILENAME, \\-\\-read\\-from=FILENAME\nread input data from FILENAME.\n.TP\n.B \\-s NUMBER, \\-\\-size=NUMBER\nspecify the size of dot (pixel). (default=3)\n.TP\n.B \\-l {LMQH}, \\-\\-level={LMQH}\nspecify error correction level from L (lowest) to H (highest). (default=L)\n.TP\n.B \\-v NUMBER, \\-\\-symversion=NUMBER\nspecify the minimum version of the symbol. See SYMBOL VERSIONS for more information. (default=auto)\n.TP\n.B \\-m NUMBER, \\-\\-margin=NUMBER\nspecify the width of margin. (default=4)\n.TP\n.B \\-d NUMBER, \\-\\-dpi=NUMBER\nspecify the DPI of the generated PNG. (default=72)\n.TP\n.PD 0\n.B \\-t {PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8}\n.TP\n.PD\n.B \\-\\-type={PNG,PNG32,EPS,SVG,XPM,ANSI,ANSI256,ASCII,ASCIIi,UTF8,UTF8i,ANSIUTF8,ANSIUTF8i,ANSI256UTF8}\nspecify the type of the generated image. (default=PNG)\n.TP\n.B \\-S, \\-\\-structured\nmake structured symbols. Version number must be specified with '-v'.\n.TP\n.B \\-k, \\-\\-kanji\nassume that the input text contains kanji (shift-jis).\n.TP\n.B \\-c, \\-\\-casesensitive\nencode lower-case alphabet characters in 8-bit mode. (default)\n.TP\n.B \\-i, \\-\\-ignorecase\nignore case distinctions and use only upper-case characters.\n.TP\n.B \\-8, \\-\\-8bit\nencode entire data in 8-bit mode. \\-k, \\-c and \\-i will be ignored.\n.TP\n.B \\-M, \\-\\-micro\nencode in a Micro QR Code. See MICRO QR CODE for more information.\n.TP\n.B \\-\\-rle\nenable run-length encoding for SVG.\n.TP\n.B \\-\\-svg-path\nuse single path to draw modules for SVG.\n.TP\n.B \\-\\-inline\nonly useful for SVG output, generates an SVG without the XML tag.\n.TP\n.PD 0\n.B \\-\\-foreground=RRGGBB[AA]\n.TP\n.PD\n.B \\-\\-background=RRGGBB[AA]\nspecify foreground/background color in hexadecimal notation.\n6-digit (RGB) or 8-digit (RGBA) form are supported.\nColor output support available only in PNG, EPS and SVG.\n.TP\n.B \\-\\-strict\\-version\ndisable automatic version number adjustment. If the input data is\ntoo large for the specified version, the program exits with the\ncode of 1.\n.TP\n.B \\-V, \\-\\-version\ndisplay the version number and copyrights of the qrencode.\n.TP\n.B \\-\\-verbose\ndisplay verbose information to stderr.\n.TP\n.B [STRING]\ninput data. If it is not specified, data will be taken from standard input.\n\n.SH SYMBOL VERSIONS\nThe symbol versions of QR Code range from Version 1 to Version 40.\nEach version has a different module configuration or number of modules,\nranging from Version 1 (21 x 21 modules) up to Version 40 (177 x 177 modules).\nEach higher version number comprises 4 additional modules per side by default.\nSee http://www.qrcode.com/en/about/version.html for a detailed version list.\n\n.SH MICRO QR CODE\nWith Micro QR Code, You can embed data in a smaller area than with QR Code,\nbut the data capacity is strongly limited. The symbol versions range from\nVersion 1 to 4.\n\n.SH EXAMPLES\n.TP\n.B qrencode \\-l L \\-v 1 \\-o output.png 'Hello, world!'\nencode into a symbol version 1, level L.\n.TP\n.B qrencode \\-iSv 1 \\-\\-output=output.png\nread standard input and encode it into a structured-appended symbols in\ncase-insensitive mode.\n.TP\n.B qrencode \\-S \\-v 40 \\-l L \\-r bigfile.txt \\-o output.png\nread input data from bigfile.txt and encode into a symbol version 40, level L.\n\n.SH AUTHOR\nWritten by Kentaro Fukuchi.\n\n.SH RESOURCES\n.TP\nMain Web Site: https://fukuchi.org/works/qrencode/\n.TP\nSource code repository: https://github.com/fukuchi/libqrencode/\n\n.SH COPYRIGHT\nCopyright (C) 2006-2018 Kentaro Fukuchi.\n"
        },
        {
          "name": "qrencode.c",
          "type": "blob",
          "size": 19.998046875,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n#include \"rsecc.h\"\n#include \"split.h\"\n#include \"mask.h\"\n#include \"mmask.h\"\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *data;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nstatic void RSblock_initBlock(RSblock *block, int dl, unsigned char *data, int el, unsigned char *ecc)\n{\n\tblock->dataLength = dl;\n\tblock->data = data;\n\tblock->eccLength = el;\n\tblock->ecc = ecc;\n\n\tRSECC_encode((size_t)dl, (size_t)el, data, ecc);\n}\n\nstatic int RSblock_init(RSblock *blocks, int spec[5], unsigned char *data, unsigned char *ecc)\n{\n\tint i;\n\tRSblock *block;\n\tunsigned char *dp, *ep;\n\tint el, dl;\n\n\tdl = QRspec_rsDataCodes1(spec);\n\tel = QRspec_rsEccCodes1(spec);\n\n\tblock = blocks;\n\tdp = data;\n\tep = ecc;\n\tfor(i = 0; i < QRspec_rsBlockNum1(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\tif(QRspec_rsBlockNum2(spec) == 0) return 0;\n\n\tdl = QRspec_rsDataCodes2(spec);\n\tel = QRspec_rsEccCodes2(spec);\n\tfor(i = 0; i < QRspec_rsBlockNum2(spec); i++) {\n\t\tRSblock_initBlock(block, dl, dp, el, ep);\n\t\tdp += dl;\n\t\tep += el;\n\t\tblock++;\n\t}\n\n\treturn 0;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw);\nSTATIC_IN_RELEASE QRRawCode *QRraw_new(QRinput *input)\n{\n\tQRRawCode *raw;\n\tint spec[5], ret;\n\n\traw = (QRRawCode *)malloc(sizeof(QRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\tQRspec_getEccSpec(input->version, input->level, spec);\n\n\traw->version = input->version;\n\traw->b1 = QRspec_rsBlockNum1(spec);\n\traw->dataLength = QRspec_rsDataLength(spec);\n\traw->eccLength = QRspec_rsEccLength(spec);\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->blocks = QRspec_rsBlockNum(spec);\n\traw->rsblock = (RSblock *)calloc((size_t)(raw->blocks), sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tret = RSblock_init(raw->rsblock, spec, raw->datacode, raw->ecccode);\n\tif(ret < 0) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char QRraw_getCode(QRRawCode *raw)\n{\n\tint col, row;\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\trow = raw->count % raw->blocks;\n\t\tcol = raw->count / raw->blocks;\n\t\tif(col >= raw->rsblock[0].dataLength) {\n\t\t\trow += raw->b1;\n\t\t}\n\t\tret = raw->rsblock[row].data[col];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\trow = (raw->count - raw->dataLength) % raw->blocks;\n\t\tcol = (raw->count - raw->dataLength) / raw->blocks;\n\t\tret = raw->rsblock[row].ecc[col];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void QRraw_free(QRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw);\nSTATIC_IN_RELEASE MQRRawCode *MQRraw_new(QRinput *input)\n{\n\tMQRRawCode *raw;\n\n\traw = (MQRRawCode *)malloc(sizeof(MQRRawCode));\n\tif(raw == NULL) return NULL;\n\n\traw->version = input->version;\n\traw->dataLength = MQRspec_getDataLength(input->version, input->level);\n\traw->eccLength = MQRspec_getECCLength(input->version, input->level);\n\traw->oddbits = raw->dataLength * 8 - MQRspec_getDataLengthBit(input->version, input->level);\n\traw->datacode = QRinput_getByteStream(input);\n\tif(raw->datacode == NULL) {\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\traw->ecccode = (unsigned char *)malloc((size_t)raw->eccLength);\n\tif(raw->ecccode == NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw);\n\t\treturn NULL;\n\t}\n\n\traw->rsblock = (RSblock *)calloc(1, sizeof(RSblock));\n\tif(raw->rsblock == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\n\tRSblock_initBlock(raw->rsblock, raw->dataLength, raw->datacode, raw->eccLength, raw->ecccode);\n\n\traw->count = 0;\n\n\treturn raw;\n}\n\n/**\n * Return a code (byte).\n * This function can be called iteratively.\n * @param raw raw code.\n * @return code\n */\nSTATIC_IN_RELEASE unsigned char MQRraw_getCode(MQRRawCode *raw)\n{\n\tunsigned char ret;\n\n\tif(raw->count < raw->dataLength) {\n\t\tret = raw->datacode[raw->count];\n\t} else if(raw->count < raw->dataLength + raw->eccLength) {\n\t\tret = raw->ecccode[raw->count - raw->dataLength];\n\t} else {\n\t\treturn 0;\n\t}\n\traw->count++;\n\treturn ret;\n}\n\nSTATIC_IN_RELEASE void MQRraw_free(MQRRawCode *raw)\n{\n\tif(raw != NULL) {\n\t\tfree(raw->datacode);\n\t\tfree(raw->ecccode);\n\t\tfree(raw->rsblock);\n\t\tfree(raw);\n\t}\n}\n\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\n\ntypedef struct {\n\tint width;\n\tunsigned char *frame;\n\tint x, y;\n\tint dir;\n\tint bit;\n\tint mqr;\n} FrameFiller;\n\nstatic void FrameFiller_set(FrameFiller *filler, int width, unsigned char *frame, int mqr)\n{\n\tfiller->width = width;\n\tfiller->frame = frame;\n\tfiller->x = width - 1;\n\tfiller->y = width - 1;\n\tfiller->dir = -1;\n\tfiller->bit = -1;\n\tfiller->mqr = mqr;\n}\n\nstatic unsigned char *FrameFiller_next(FrameFiller *filler)\n{\n\tunsigned char *p;\n\tint x, y, w;\n\n\tif(filler->bit == -1) {\n\t\tfiller->bit = 0;\n\t\treturn filler->frame + filler->y * filler->width + filler->x;\n\t}\n\n\tx = filler->x;\n\ty = filler->y;\n\tp = filler->frame;\n\tw = filler->width;\n\n\tif(filler->bit == 0) {\n\t\tx--;\n\t\tfiller->bit++;\n\t} else {\n\t\tx++;\n\t\ty += filler->dir;\n\t\tfiller->bit--;\n\t}\n\n\tif(filler->dir < 0) {\n\t\tif(y < 0) {\n\t\t\ty = 0;\n\t\t\tx -= 2;\n\t\t\tfiller->dir = 1;\n\t\t\tif(!filler->mqr && x == 6) {\n\t\t\t\tx--;\n\t\t\t\ty = 9;\n\t\t\t}\n\t\t}\n\t} else if(y == w) {\n\t\ty = w - 1;\n\t\tx -= 2;\n\t\tfiller->dir = -1;\n\t\tif(!filler->mqr && x == 6) {\n\t\t\tx--;\n\t\t\ty -= 8;\n\t\t}\n\t}\n\tif(x < 0 || y < 0) return NULL;\n\n\tfiller->x = x;\n\tfiller->y = y;\n\n\tif(p[y * w + x] & 0x80) {\n\t\t// This tail recursion could be optimized.\n\t\treturn FrameFiller_next(filler);\n\t}\n\treturn &p[y * w + x];\n}\n\n#ifdef WITH_TESTS\nunsigned char *FrameFiller_test(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 0);\n\tlength = QRspec_getDataLength(version, QR_ECLEVEL_L) * 8\n\t       + QRspec_getECCLength(version, QR_ECLEVEL_L) * 8\n\t\t   + QRspec_getRemainder(version);\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfree(frame);\n\t\t\treturn NULL;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n\nunsigned char *FrameFiller_testMQR(int version)\n{\n\tint width;\n\tunsigned char *frame, *p;\n\tint i, length;\n\tFrameFiller filler;\n\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) return NULL;\n\tFrameFiller_set(&filler, width, frame, 1);\n\tlength = MQRspec_getDataLengthBit(version, QR_ECLEVEL_L)\n\t       + MQRspec_getECCLength(version, QR_ECLEVEL_L) * 8;\n\tfor(i = 0; i < length; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL) {\n\t\t\tfprintf(stderr, \"Frame filler run over the frame!\\n\");\n\t\t\treturn frame;\n\t\t}\n\t\t*p = (unsigned char)(i & 0x7f) | 0x80;\n\t}\n\treturn frame;\n}\n#endif\n\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\n\nSTATIC_IN_RELEASE QRcode *QRcode_new(int version, int width, unsigned char *data)\n{\n\tQRcode *qrcode;\n\n\tqrcode = (QRcode *)malloc(sizeof(QRcode));\n\tif(qrcode == NULL) return NULL;\n\n\tqrcode->version = version;\n\tqrcode->width = width;\n\tqrcode->data = data;\n\n\treturn qrcode;\n}\n\nvoid QRcode_free(QRcode *qrcode)\n{\n\tif(qrcode != NULL) {\n\t\tfree(qrcode->data);\n\t\tfree(qrcode);\n\t}\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMask(QRinput *input, int mask)\n{\n\tint width, version;\n\tQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version < 0 || input->version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(!(input->level >= QR_ECLEVEL_L && input->level <= QR_ECLEVEL_H)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = QRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = QRspec_getWidth(version);\n\tframe = QRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 0);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = QRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tfor(j = 0; j < 8; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL)  goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tQRraw_free(raw);\n\traw = NULL;\n\t/* remainder bits */\n\tj = QRspec_getRemainder(version);\n\tfor(i = 0; i < j; i++) {\n\t\tp = FrameFiller_next(&filler);\n\t\tif(p == NULL)  goto EXIT;\n\t\t*p = 0x02;\n\t}\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = Mask_mask(width, frame, input->level);\n\t} else {\n\t\tmasked = Mask_makeMask(width, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nSTATIC_IN_RELEASE QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask)\n{\n\tint width, version;\n\tMQRRawCode *raw;\n\tunsigned char *frame, *masked, *p, code, bit;\n\tint i, j, length;\n\tQRcode *qrcode = NULL;\n\tFrameFiller filler;\n\n\tif(!input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(input->version <= 0 || input->version > MQRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(!(input->level >= QR_ECLEVEL_L && input->level <= QR_ECLEVEL_Q)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\traw = MQRraw_new(input);\n\tif(raw == NULL) return NULL;\n\n\tversion = raw->version;\n\twidth = MQRspec_getWidth(version);\n\tframe = MQRspec_newFrame(version);\n\tif(frame == NULL) {\n\t\tMQRraw_free(raw);\n\t\treturn NULL;\n\t}\n\tFrameFiller_set(&filler, width, frame, 1);\n\n\t/* interleaved data and ecc codes */\n\tfor(i = 0; i < raw->dataLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tif(raw->oddbits && i == raw->dataLength - 1) {\n\t\t\tlength = raw->oddbits;\n\t\t} else {\n\t\t\tlength = 8;\n\t\t}\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tfor(i = 0; i < raw->eccLength; i++) {\n\t\tcode = MQRraw_getCode(raw);\n\t\tbit = 0x80;\n\t\tlength = 8;\n\t\tfor(j = 0; j < length; j++) {\n\t\t\tp = FrameFiller_next(&filler);\n\t\t\tif(p == NULL) goto EXIT;\n\t\t\t*p = 0x02 | ((bit & code) != 0);\n\t\t\tbit = bit >> 1;\n\t\t}\n\t}\n\tMQRraw_free(raw);\n\traw = NULL;\n\n\t/* masking */\n\tif(mask == -2) { // just for debug purpose\n\t\tmasked = (unsigned char *)malloc((size_t)(width * width));\n\t\tmemcpy(masked, frame, (size_t)(width * width));\n\t} else if(mask < 0) {\n\t\tmasked = MMask_mask(version, frame, input->level);\n\t} else {\n\t\tmasked = MMask_makeMask(version, frame, mask, input->level);\n\t}\n\tif(masked == NULL) {\n\t\tgoto EXIT;\n\t}\n\n\tqrcode = QRcode_new(version, width, masked);\n\tif(qrcode == NULL) {\n\t\tfree(masked);\n\t}\n\nEXIT:\n\tMQRraw_free(raw);\n\tfree(frame);\n\treturn qrcode;\n}\n\nQRcode *QRcode_encodeInput(QRinput *input)\n{\n\tif(input->mqr) {\n\t\treturn QRcode_encodeMaskMQR(input, -1);\n\t} else {\n\t\treturn QRcode_encodeMask(input, -1);\n\t}\n}\n\nstatic QRcode *QRcode_encodeStringReal(const char *string, int version, QRecLevel level, int mqr, QRencodeMode hint, int casesensitive)\n{\n\tQRinput *input;\n\tQRcode *code;\n\tint ret;\n\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(hint != QR_MODE_8 && hint != QR_MODE_KANJI) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif(mqr) {\n\t\tinput = QRinput_newMQR(version, level);\n\t} else {\n\t\tinput = QRinput_new2(version, level);\n\t}\n\tif(input == NULL) return NULL;\n\n\tret = Split_splitStringToQRinput(string, input, hint, casesensitive);\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\tcode = QRcode_encodeInput(input);\n\tQRinput_free(input);\n\n\treturn code;\n}\n\nQRcode *QRcode_encodeString(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)\n{\n\treturn QRcode_encodeStringReal(string, version, level, 0, hint, casesensitive);\n}\n\nQRcode *QRcode_encodeStringMQR(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)\n{\n\tint i;\n\n\tif(version == 0) {\n\t\tversion = 1;\n\t}\n\tfor(i = version; i <= MQRSPEC_VERSION_MAX ; i++) {\n\t\tQRcode *code = QRcode_encodeStringReal(string, i, level, 1, hint, casesensitive);\n\t\tif(code != NULL) return code;\n\t}\n\n\treturn NULL;\n}\n\nstatic QRcode *QRcode_encodeDataReal(const unsigned char *data, int length, int version, QRecLevel level, int mqr)\n{\n\tQRinput *input;\n\tQRcode *code;\n\tint ret;\n\n\tif(data == NULL || length == 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tif(mqr) {\n\t\tinput = QRinput_newMQR(version, level);\n\t} else {\n\t\tinput = QRinput_new2(version, level);\n\t}\n\tif(input == NULL) return NULL;\n\n\tret = QRinput_append(input, QR_MODE_8, length, data);\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\tcode = QRcode_encodeInput(input);\n\tQRinput_free(input);\n\n\treturn code;\n}\n\nQRcode *QRcode_encodeData(int size, const unsigned char *data, int version, QRecLevel level)\n{\n\treturn QRcode_encodeDataReal(data, size, version, level, 0);\n}\n\nQRcode *QRcode_encodeString8bit(const char *string, int version, QRecLevel level)\n{\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataReal((unsigned char *)string, (int)strlen(string), version, level, 0);\n}\n\nQRcode *QRcode_encodeDataMQR(int size, const unsigned char *data, int version, QRecLevel level)\n{\n\tint i;\n\n\tif(version == 0) {\n\t\tversion = 1;\n\t}\n\tfor(i = version; i <= MQRSPEC_VERSION_MAX; i++) {\n\t\tQRcode *code = QRcode_encodeDataReal(data, size, i, level, 1);\n\t\tif(code != NULL) return code;\n\t}\n\n\treturn NULL;\n}\n\nQRcode *QRcode_encodeString8bitMQR(const char *string, int version, QRecLevel level)\n{\n\tint i;\n\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(version == 0) {\n\t\tversion = 1;\n\t}\n\tfor(i = version; i <= MQRSPEC_VERSION_MAX; i++) {\n\t\tQRcode *code = QRcode_encodeDataReal((unsigned char *)string, (int)strlen(string), i, level, 1);\n\t\tif(code != NULL) return code;\n\t}\n\n\treturn NULL;\n}\n\n\n/******************************************************************************\n * Structured QR-code encoding\n *****************************************************************************/\n\nstatic QRcode_List *QRcode_List_newEntry(void)\n{\n\tQRcode_List *entry;\n\n\tentry = (QRcode_List *)malloc(sizeof(QRcode_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->next = NULL;\n\tentry->code = NULL;\n\n\treturn entry;\n}\n\nstatic void QRcode_List_freeEntry(QRcode_List *entry)\n{\n\tif(entry != NULL) {\n\t\tQRcode_free(entry->code);\n\t\tfree(entry);\n\t}\n}\n\nvoid QRcode_List_free(QRcode_List *qrlist)\n{\n\tQRcode_List *list = qrlist, *next;\n\n\twhile(list != NULL) {\n\t\tnext = list->next;\n\t\tQRcode_List_freeEntry(list);\n\t\tlist = next;\n\t}\n}\n\nint QRcode_List_size(QRcode_List *qrlist)\n{\n\tQRcode_List *list = qrlist;\n\tint size = 0;\n\n\twhile(list != NULL) {\n\t\tsize++;\n\t\tlist = list->next;\n\t}\n\n\treturn size;\n}\n\n#if 0\nstatic unsigned char QRcode_parity(const char *str, int size)\n{\n\tunsigned char parity = 0;\n\tint i;\n\n\tfor(i = 0; i < size; i++) {\n\t\tparity ^= str[i];\n\t}\n\n\treturn parity;\n}\n#endif\n\nQRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s)\n{\n\tQRcode_List *head = NULL;\n\tQRcode_List *tail = NULL;\n\tQRcode_List *entry;\n\tQRinput_InputList *list = s->head;\n\n\twhile(list != NULL) {\n\t\tif(head == NULL) {\n\t\t\tentry = QRcode_List_newEntry();\n\t\t\tif(entry == NULL) goto ABORT;\n\t\t\thead = entry;\n\t\t\ttail = head;\n\t\t} else {\n\t\t\tentry = QRcode_List_newEntry();\n\t\t\tif(entry == NULL) goto ABORT;\n\t\t\ttail->next = entry;\n\t\t\ttail = tail->next;\n\t\t}\n\t\ttail->code = QRcode_encodeInput(list->input);\n\t\tif(tail->code == NULL) {\n\t\t\tgoto ABORT;\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn head;\nABORT:\n\tQRcode_List_free(head);\n\treturn NULL;\n}\n\nstatic QRcode_List *QRcode_encodeInputToStructured(QRinput *input)\n{\n\tQRinput_Struct *s;\n\tQRcode_List *codes;\n\n\ts = QRinput_splitQRinputToStruct(input);\n\tif(s == NULL) return NULL;\n\n\tcodes = QRcode_encodeInputStructured(s);\n\tQRinput_Struct_free(s);\n\n\treturn codes;\n}\n\nstatic QRcode_List *QRcode_encodeDataStructuredReal(\n\tint size, const unsigned char *data,\n\tint version, QRecLevel level,\n\tint eightbit, QRencodeMode hint, int casesensitive)\n{\n\tQRinput *input;\n\tQRcode_List *codes;\n\tint ret;\n\n\tif(version <= 0) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif(!eightbit && (hint != QR_MODE_8 && hint != QR_MODE_KANJI)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tinput = QRinput_new2(version, level);\n\tif(input == NULL) return NULL;\n\n\tif(eightbit) {\n\t\tret = QRinput_append(input, QR_MODE_8, size, data);\n\t} else {\n\t\tret = Split_splitStringToQRinput((char *)data, input, hint, casesensitive);\n\t}\n\tif(ret < 0) {\n\t\tQRinput_free(input);\n\t\treturn NULL;\n\t}\n\tcodes = QRcode_encodeInputToStructured(input);\n\tQRinput_free(input);\n\n\treturn codes;\n}\n\nQRcode_List *QRcode_encodeDataStructured(int size, const unsigned char *data, int version, QRecLevel level) {\n\treturn QRcode_encodeDataStructuredReal(size, data, version, level, 1, QR_MODE_NUL, 0);\n}\n\nQRcode_List *QRcode_encodeString8bitStructured(const char *string, int version, QRecLevel level) {\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataStructured((int)strlen(string), (unsigned char *)string, version, level);\n}\n\nQRcode_List *QRcode_encodeStringStructured(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive)\n{\n\tif(string == NULL) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\treturn QRcode_encodeDataStructuredReal((int)strlen(string), (unsigned char *)string, version, level, 0, hint, casesensitive);\n}\n\n/******************************************************************************\n * System utilities\n *****************************************************************************/\n\nvoid QRcode_APIVersion(int *major_version, int *minor_version, int *micro_version)\n{\n\tif(major_version != NULL) {\n\t\t*major_version = MAJOR_VERSION;\n\t}\n\tif(minor_version != NULL) {\n\t\t*minor_version = MINOR_VERSION;\n\t}\n\tif(micro_version != NULL) {\n\t\t*micro_version = MICRO_VERSION;\n\t}\n}\n\nchar *QRcode_APIVersionString(void)\n{\n\treturn VERSION;\n}\n\nvoid QRcode_clearCache(void)\n{\n\treturn;\n}\n"
        },
        {
          "name": "qrencode.h",
          "type": "blob",
          "size": 20.4111328125,
          "content": "/**\n * qrencode - QR Code encoder\n *\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/** \\mainpage\n * Libqrencode is a library for encoding data in a QR Code symbol, a kind of 2D\n * symbology.\n *\n * \\section encoding Encoding\n *\n * There are two methods to encode data: <b>encoding a string/data</b> or\n * <b>encoding a structured data</b>.\n *\n * \\subsection encoding-string Encoding a string/data\n * You can encode a string by calling QRcode_encodeString().\n * The given string is parsed automatically and encoded. If you want to encode\n * data that can be represented as a C string style (NUL terminated), you can\n * simply use this way.\n *\n * If the input data contains Kanji (Shift-JIS) characters and you want to\n * encode them as Kanji in QR Code, you should give QR_MODE_KANJI as a hint.\n * Otherwise, all of non-alphanumeric characters are encoded as 8-bit data.\n * If you want to encode a whole string in 8-bit mode, you can use\n * QRcode_encodeString8bit() instead.\n *\n * Please note that a C string can not contain NUL characters. If your data\n * contains NUL, you must use QRcode_encodeData().\n *\n * \\subsection encoding-input Encoding a structured data\n * You can construct a structured input data manually. If the structure of the\n * input data is known, you can use this method.\n * At first, create a ::QRinput object by QRinput_new(). Then add input data\n * to the QRinput object by QRinput_append(). Finally call QRcode_encodeInput()\n * to encode the QRinput data.\n * You can reuse the QRinput object again to encode it in other symbols with\n * different parameters.\n *\n * \\section result Result\n * The encoded symbol is generated as a ::QRcode object. It will contain its\n * version number, the width of the symbol, and an array represents the symbol.\n * See ::QRcode for the details. You can free the object by QRcode_free().\n *\n * Please note that the version of the result may be larger than specified.\n * In such cases, the input data would be too large to be encoded in a\n * symbol of the specified version.\n *\n * \\section structured Structured append\n * Libqrencode can generate \"Structured-appended\" symbols that enables to split\n * a large data set into mulitple QR codes. A QR code reader concatenates\n * multiple QR code symbols into a string.\n * Just like QRcode_encodeString(), you can use QRcode_encodeStringStructured()\n * to generate structured-appended symbols. This functions returns an instance\n * of ::QRcode_List. The returned list is a singly-linked list of QRcode: you\n * can retrieve each QR code in this way:\n *\n * \\code\n * QRcode_List *qrcodes;\n * QRcode_List *entry;\n * QRcode *qrcode;\n *\n * qrcodes = QRcode_encodeStringStructured(...);\n * entry = qrcodes;\n * while(entry != NULL) {\n *     qrcode = entry->code;\n *     // do something\n *     entry = entry->next;\n * }\n * QRcode_List_free(entry);\n * \\endcode\n *\n * Instead of using auto-parsing functions, you can construct your own\n * structured input. At first, instantiate an object of ::QRinput_Struct\n * by calling QRinput_Struct_new(). This object can hold multiple ::QRinput,\n * and one QR code is generated for a ::QRinput.\n * QRinput_Struct_appendInput() appends a ::QRinput to a ::QRinput_Struct\n * object. In order to generate structured-appended symbols, it is required to\n * embed headers to each symbol. You can use\n * QRinput_Struct_insertStructuredAppendHeaders() to insert appropriate\n * headers to each symbol. You should call this function just once before\n * encoding symbols.\n */\n\n#ifndef QRENCODE_H\n#define QRENCODE_H\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/**\n * Encoding mode.\n */\ntypedef enum {\n\tQR_MODE_NUL = -1,   ///< Terminator (NUL character). Internal use only\n\tQR_MODE_NUM = 0,    ///< Numeric mode\n\tQR_MODE_AN,         ///< Alphabet-numeric mode\n\tQR_MODE_8,          ///< 8-bit data mode\n\tQR_MODE_KANJI,      ///< Kanji (shift-jis) mode\n\tQR_MODE_STRUCTURE,  ///< Internal use only\n\tQR_MODE_ECI,        ///< ECI mode\n\tQR_MODE_FNC1FIRST,  ///< FNC1, first position\n\tQR_MODE_FNC1SECOND, ///< FNC1, second position\n} QRencodeMode;\n\n/**\n * Level of error correction.\n */\ntypedef enum {\n\tQR_ECLEVEL_L = 0, ///< lowest\n\tQR_ECLEVEL_M,\n\tQR_ECLEVEL_Q,\n\tQR_ECLEVEL_H      ///< highest\n} QRecLevel;\n\n/**\n * Maximum version (size) of QR-code symbol.\n */\n#define QRSPEC_VERSION_MAX 40\n\n/**\n * Maximum version (size) of QR-code symbol.\n */\n#define MQRSPEC_VERSION_MAX 4\n\n\n/******************************************************************************\n * Input data (qrinput.c)\n *****************************************************************************/\n\n/**\n * Singly linked list to contain input strings. An instance of this class\n * contains its version and error correction level too. It is required to\n * set them by QRinput_setVersion() and QRinput_setErrorCorrectionLevel(),\n * or use QRinput_new2() to instantiate an object.\n */\ntypedef struct _QRinput QRinput;\n\n/**\n * Instantiate an input data object. The version is set to 0 (auto-select)\n * and the error correction level is set to QR_ECLEVEL_L.\n * @return an input object (initialized). On error, NULL is returned and errno\n *         is set to indicate the error.\n * @throw ENOMEM unable to allocate memory.\n */\nextern QRinput *QRinput_new(void);\n\n/**\n * Instantiate an input data object.\n * @param version version number.\n * @param level Error correction level.\n * @return an input object (initialized). On error, NULL is returned and errno\n *         is set to indicate the error.\n * @throw ENOMEM unable to allocate memory for input objects.\n * @throw EINVAL invalid arguments.\n */\nextern QRinput *QRinput_new2(int version, QRecLevel level);\n\n/**\n * Instantiate an input data object. Object's Micro QR Code flag is set.\n * Unlike with full-sized QR Code, version number must be specified (>0).\n * @param version version number (1--4).\n * @param level Error correction level.\n * @return an input object (initialized). On error, NULL is returned and errno\n *         is set to indicate the error.\n * @throw ENOMEM unable to allocate memory for input objects.\n * @throw EINVAL invalid arguments.\n */\nextern QRinput *QRinput_newMQR(int version, QRecLevel level);\n\n/**\n * Append data to an input object.\n * The data is copied and appended to the input object.\n * @param input input object.\n * @param mode encoding mode.\n * @param size size of data (byte).\n * @param data a pointer to the memory area of the input data.\n * @retval 0 success.\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL input data is invalid.\n *\n */\nextern int QRinput_append(QRinput *input, QRencodeMode mode, int size, const unsigned char *data);\n\n/**\n * Append ECI header.\n * @param input input object.\n * @param ecinum ECI indicator number (0 - 999999)\n * @retval 0 success.\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL input data is invalid.\n *\n */\nextern int QRinput_appendECIheader(QRinput *input, unsigned int ecinum);\n\n/**\n * Get current version.\n * @param input input object.\n * @return current version.\n */\nextern int QRinput_getVersion(QRinput *input);\n\n/**\n * Set version of the QR code that is to be encoded.\n * This function cannot be applied to Micro QR Code.\n * @param input input object.\n * @param version version number (0 = auto)\n * @retval 0 success.\n * @retval -1 invalid argument.\n */\nextern int QRinput_setVersion(QRinput *input, int version);\n\n/**\n * Get current error correction level.\n * @param input input object.\n * @return Current error correcntion level.\n */\nextern QRecLevel QRinput_getErrorCorrectionLevel(QRinput *input);\n\n/**\n * Set error correction level of the QR code that is to be encoded.\n * This function cannot be applied to Micro QR Code.\n * @param input input object.\n * @param level Error correction level.\n * @retval 0 success.\n * @retval -1 invalid argument.\n */\nextern int QRinput_setErrorCorrectionLevel(QRinput *input, QRecLevel level);\n\n/**\n * Set version and error correction level of the QR code at once.\n * This function is recommened for Micro QR Code.\n * @param input input object.\n * @param version version number (0 = auto)\n * @param level Error correction level.\n * @retval 0 success.\n * @retval -1 invalid argument.\n */\nextern int QRinput_setVersionAndErrorCorrectionLevel(QRinput *input, int version, QRecLevel level);\n\n/**\n * Free the input object.\n * All of data chunks in the input object are freed too.\n * @param input input object.\n */\nextern void QRinput_free(QRinput *input);\n\n/**\n * Validate the input data.\n * @param mode encoding mode.\n * @param size size of data (byte).\n * @param data a pointer to the memory area of the input data.\n * @retval 0 success.\n * @retval -1 invalid arguments.\n */\nextern int QRinput_check(QRencodeMode mode, int size, const unsigned char *data);\n\n/**\n * Set of QRinput for structured symbols.\n */\ntypedef struct _QRinput_Struct QRinput_Struct;\n\n/**\n * Instantiate a set of input data object.\n * @return an instance of QRinput_Struct. On error, NULL is returned and errno\n *         is set to indicate the error.\n * @throw ENOMEM unable to allocate memory.\n */\nextern QRinput_Struct *QRinput_Struct_new(void);\n\n/**\n * Set parity of structured symbols.\n * @param s structured input object.\n * @param parity parity of s.\n */\nextern void QRinput_Struct_setParity(QRinput_Struct *s, unsigned char parity);\n\n/**\n * Append a QRinput object to the set. QRinput created by QRinput_newMQR()\n * will be rejected.\n * @warning never append the same QRinput object twice or more.\n * @param s structured input object.\n * @param input an input object.\n * @retval >0 number of input objects in the structure.\n * @retval -1 an error occurred. See Exceptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid arguments.\n */\nextern int QRinput_Struct_appendInput(QRinput_Struct *s, QRinput *input);\n\n/**\n * Free all of QRinput in the set.\n * @param s a structured input object.\n */\nextern void QRinput_Struct_free(QRinput_Struct *s);\n\n/**\n * Split a QRinput to QRinput_Struct. It calculates a parity, set it, then\n * insert structured-append headers. QRinput created by QRinput_newMQR() will\n * be rejected.\n * @param input input object. Version number and error correction level must be\n *        set.\n * @return a set of input data. On error, NULL is returned, and errno is set\n *         to indicate the error. See Exceptions for the details.\n * @throw ERANGE input data is too large.\n * @throw EINVAL invalid input data.\n * @throw ENOMEM unable to allocate memory.\n */\nextern QRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input);\n\n/**\n * Insert structured-append headers to the input structure. It calculates\n * a parity and set it if the parity is not set yet.\n * @param s input structure\n * @retval 0 success.\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory.\n */\nextern int QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s);\n\n/**\n * Set FNC1-1st position flag.\n */\nextern int QRinput_setFNC1First(QRinput *input);\n\n/**\n * Set FNC1-2nd position flag and application identifier.\n */\nextern int QRinput_setFNC1Second(QRinput *input, unsigned char appid);\n\n/******************************************************************************\n * QRcode output (qrencode.c)\n *****************************************************************************/\n\n/**\n * QRcode class.\n * Symbol data is represented as an array contains width*width uchars.\n * Each uchar represents a module (dot). If the less significant bit of\n * the uchar is 1, the corresponding module is black. The other bits are\n * meaningless for usual applications, but here its specification is described.\n *\n * @verbatim\n   MSB 76543210 LSB\n       |||||||`- 1=black/0=white\n       ||||||`-- 1=ecc/0=data code area\n       |||||`--- format information\n       ||||`---- version information\n       |||`----- timing pattern\n       ||`------ alignment pattern\n       |`------- finder pattern and separator\n       `-------- non-data modules (format, timing, etc.)\n   @endverbatim\n */\ntypedef struct {\n\tint version;         ///< version of the symbol\n\tint width;           ///< width of the symbol\n\tunsigned char *data; ///< symbol data\n} QRcode;\n\n/**\n * Singly-linked list of QRcode. Used to represent a structured symbols.\n * A list is terminated with NULL.\n */\ntypedef struct _QRcode_List {\n\tQRcode *code;\n\tstruct _QRcode_List *next;\n} QRcode_List;\n\n/**\n * Create a symbol from the input data.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n * @param input input data.\n * @return an instance of QRcode class. The version of the result QRcode may\n *         be larger than the designated version. On error, NULL is returned,\n *         and errno is set to indicate the error. See Exceptions for the\n *         details.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory for input objects.\n */\nextern QRcode *QRcode_encodeInput(QRinput *input);\n\n/**\n * Create a symbol from the string. The library automatically parses the input\n * string and encodes in a QR Code symbol.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n * @param string input string. It must be NUL terminated.\n * @param version version of the symbol. If 0, the library chooses the minimum\n *                version for the given input data.\n * @param level error correction level.\n * @param hint tell the library how Japanese Kanji characters should be\n *             encoded. If QR_MODE_KANJI is given, the library assumes that the\n *             given string contains Shift-JIS characters and encodes them in\n *             Kanji-mode. If QR_MODE_8 is given, all of non-alphanumerical\n *             characters will be encoded as is. If you want to embed UTF-8\n *             string, choose this. Other mode will cause EINVAL error.\n * @param casesensitive case-sensitive(1) or not(0).\n * @return an instance of QRcode class. The version of the result QRcode may\n *         be larger than the designated version. On error, NULL is returned,\n *         and errno is set to indicate the error. See Exceptions for the\n *         details.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory for input objects.\n * @throw ERANGE input data is too large.\n */\nextern QRcode *QRcode_encodeString(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive);\n\n/**\n * Same to QRcode_encodeString(), but encode whole data in 8-bit mode.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n */\nextern QRcode *QRcode_encodeString8bit(const char *string, int version, QRecLevel level);\n\n/**\n * Micro QR Code version of QRcode_encodeString().\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n */\nextern QRcode *QRcode_encodeStringMQR(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive);\n\n/**\n * Micro QR Code version of QRcode_encodeString8bit().\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n */\nextern QRcode *QRcode_encodeString8bitMQR(const char *string, int version, QRecLevel level);\n\n/**\n * Encode byte stream (may include '\\0') in 8-bit mode.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n * @param size size of the input data.\n * @param data input data.\n * @param version version of the symbol. If 0, the library chooses the minimum\n *                version for the given input data.\n * @param level error correction level.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory for input objects.\n * @throw ERANGE input data is too large.\n */\nextern QRcode *QRcode_encodeData(int size, const unsigned char *data, int version, QRecLevel level);\n\n/**\n * Micro QR Code version of QRcode_encodeData().\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n */\nextern QRcode *QRcode_encodeDataMQR(int size, const unsigned char *data, int version, QRecLevel level);\n\n/**\n * Free the instance of QRcode class.\n * @param qrcode an instance of QRcode class.\n */\nextern void QRcode_free(QRcode *qrcode);\n\n/**\n * Create structured symbols from the input data.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n * @param s input data, structured.\n * @return a singly-linked list of QRcode.\n */\nextern QRcode_List *QRcode_encodeInputStructured(QRinput_Struct *s);\n\n/**\n * Create structured symbols from the string. The library automatically parses\n * the input string and encodes in a QR Code symbol.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n * @param string input string. It must be NUL terminated.\n * @param version version of the symbol.\n * @param level error correction level.\n * @param hint tell the library how Japanese Kanji characters should be\n *             encoded. If QR_MODE_KANJI is given, the library assumes that the\n *             given string contains Shift-JIS characters and encodes them in\n *             Kanji-mode. If QR_MODE_8 is given, all of non-alphanumerical\n *             characters will be encoded as is. If you want to embed UTF-8\n *             string, choose this. Other mode will cause EINVAL error.\n * @param casesensitive case-sensitive(1) or not(0).\n * @return a singly-linked list of QRcode. On error, NULL is returned, and\n *         errno is set to indicate the error. See Exceptions for the details.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory for input objects.\n */\nextern QRcode_List *QRcode_encodeStringStructured(const char *string, int version, QRecLevel level, QRencodeMode hint, int casesensitive);\n\n/**\n * Same to QRcode_encodeStringStructured(), but encode whole data in 8-bit mode.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n */\nextern QRcode_List *QRcode_encodeString8bitStructured(const char *string, int version, QRecLevel level);\n\n/**\n * Create structured symbols from byte stream (may include '\\0'). Wholde data\n * are encoded in 8-bit mode.\n * @warning This function is THREAD UNSAFE when pthread is disabled.\n * @param size size of the input data.\n * @param data input dat.\n * @param version version of the symbol.\n * @param level error correction level.\n * @return a singly-linked list of QRcode. On error, NULL is returned, and\n *         errno is set to indicate the error. See Exceptions for the details.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory for input objects.\n */\nextern QRcode_List *QRcode_encodeDataStructured(int size, const unsigned char *data, int version, QRecLevel level);\n\n/**\n * Return the number of symbols included in a QRcode_List.\n * @param qrlist a head entry of a QRcode_List.\n * @return number of symbols in the list.\n */\nextern int QRcode_List_size(QRcode_List *qrlist);\n\n/**\n * Free the QRcode_List.\n * @param qrlist a head entry of a QRcode_List.\n */\nextern void QRcode_List_free(QRcode_List *qrlist);\n\n\n/******************************************************************************\n * System utilities\n *****************************************************************************/\n\n/**\n * Return a string that identifies the library version.\n * @param major_version major version number\n * @param minor_version minor version number\n * @param micro_version micro version number\n */\nextern void QRcode_APIVersion(int *major_version, int *minor_version, int *micro_version);\n\n/**\n * Return a string that identifies the library version.\n * @return a string identifies the library version. The string is held by the\n * library. Do NOT free it.\n */\nextern char *QRcode_APIVersionString(void);\n\n/**\n * @deprecated\n */\n#ifndef _MSC_VER\nextern void QRcode_clearCache(void) __attribute__ ((deprecated));\n#else\nextern void QRcode_clearCache(void);\n#endif\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif /* QRENCODE_H */\n"
        },
        {
          "name": "qrencode_inner.h",
          "type": "blob",
          "size": 2.701171875,
          "content": "/**\n * qrencode - QR Code encoder\n *\n * Header for test use\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef QRENCODE_INNER_H\n#define QRENCODE_INNER_H\n\n/**\n * This header file includes definitions for test use.\n */\n\n/******************************************************************************\n * Raw code\n *****************************************************************************/\n\ntypedef struct {\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *data;\n\tunsigned char *ecc;\n} RSblock;\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tint b1;\n\tint blocks;\n\tRSblock *rsblock;\n\tint count;\n} QRRawCode;\n\nextern QRRawCode *QRraw_new(QRinput *input);\nextern unsigned char QRraw_getCode(QRRawCode *raw);\nextern void QRraw_free(QRRawCode *raw);\n\n/******************************************************************************\n * Raw code for Micro QR Code\n *****************************************************************************/\n\ntypedef struct {\n\tint version;\n\tint dataLength;\n\tint eccLength;\n\tunsigned char *datacode;\n\tunsigned char *ecccode;\n\tRSblock *rsblock;\n\tint oddbits;\n\tint count;\n} MQRRawCode;\n\nextern MQRRawCode *MQRraw_new(QRinput *input);\nextern unsigned char MQRraw_getCode(MQRRawCode *raw);\nextern void MQRraw_free(MQRRawCode *raw);\n\n/******************************************************************************\n * Frame filling\n *****************************************************************************/\nextern unsigned char *FrameFiller_test(int version);\nextern unsigned char *FrameFiller_testMQR(int version);\n\n/******************************************************************************\n * QR-code encoding\n *****************************************************************************/\nextern QRcode *QRcode_encodeMask(QRinput *input, int mask);\nextern QRcode *QRcode_encodeMaskMQR(QRinput *input, int mask);\nextern QRcode *QRcode_new(int version, int width, unsigned char *data);\n\n#endif /* QRENCODE_INNER_H */\n"
        },
        {
          "name": "qrinput.c",
          "type": "blob",
          "size": 36.892578125,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Input data chunk class\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrencode.h\"\n#include \"qrspec.h\"\n#include \"mqrspec.h\"\n#include \"bitstream.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Utilities\n *****************************************************************************/\nint QRinput_isSplittableMode(QRencodeMode mode)\n{\n\treturn (mode >= QR_MODE_NUM && mode <= QR_MODE_KANJI);\n}\n\n/******************************************************************************\n * Entry of input data\n *****************************************************************************/\n\nstatic QRinput_List *QRinput_List_newEntry(QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tif(QRinput_check(mode, size, data)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tentry = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(entry == NULL) return NULL;\n\n\tentry->mode = mode;\n\tentry->size = size;\n\tentry->data = NULL;\n\tif(size > 0) {\n\t\tentry->data = (unsigned char *)malloc((size_t)size);\n\t\tif(entry->data == NULL) {\n\t\t\tfree(entry);\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(entry->data, data, (size_t)size);\n\t}\n\tentry->bstream = NULL;\n\tentry->next = NULL;\n\n\treturn entry;\n}\n\nstatic void QRinput_List_freeEntry(QRinput_List *entry)\n{\n\tif(entry != NULL) {\n\t\tfree(entry->data);\n\t\tBitStream_free(entry->bstream);\n\t\tfree(entry);\n\t}\n}\n\nstatic QRinput_List *QRinput_List_dup(QRinput_List *entry)\n{\n\tQRinput_List *n;\n\n\tn = (QRinput_List *)malloc(sizeof(QRinput_List));\n\tif(n == NULL) return NULL;\n\n\tn->mode = entry->mode;\n\tn->size = entry->size;\n\tn->data = (unsigned char *)malloc((size_t)n->size);\n\tif(n->data == NULL) {\n\t\tfree(n);\n\t\treturn NULL;\n\t}\n\tmemcpy(n->data, entry->data, (size_t)entry->size);\n\tn->bstream = NULL;\n\tn->next = NULL;\n\n\treturn n;\n}\n\n/******************************************************************************\n * Input Data\n *****************************************************************************/\n\nQRinput *QRinput_new(void)\n{\n\treturn QRinput_new2(0, QR_ECLEVEL_L);\n}\n\nQRinput *QRinput_new2(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version < 0 || version > QRSPEC_VERSION_MAX || level < 0 || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\tinput = (QRinput *)malloc(sizeof(QRinput));\n\tif(input == NULL) return NULL;\n\n\tinput->head = NULL;\n\tinput->tail = NULL;\n\tinput->version = version;\n\tinput->level = level;\n\tinput->mqr = 0;\n\tinput->fnc1 = 0;\n\n\treturn input;\n}\n\nQRinput *QRinput_newMQR(int version, QRecLevel level)\n{\n\tQRinput *input;\n\n\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\n\tinput = QRinput_new2(version, level);\n\tif(input == NULL) return NULL;\n\n\tinput->mqr = 1;\n\n\treturn input;\n\nINVALID:\n\terrno = EINVAL;\n\treturn NULL;\n}\n\nint QRinput_getVersion(QRinput *input)\n{\n\treturn input->version;\n}\n\nint QRinput_setVersion(QRinput *input, int version)\n{\n\tif(input->mqr || version < 0 || version > QRSPEC_VERSION_MAX) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->version = version;\n\n\treturn 0;\n}\n\nQRecLevel QRinput_getErrorCorrectionLevel(QRinput *input)\n{\n\treturn input->level;\n}\n\nint QRinput_setErrorCorrectionLevel(QRinput *input, QRecLevel level)\n{\n\tif(input->mqr || level > QR_ECLEVEL_H) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tinput->level = level;\n\n\treturn 0;\n}\n\nint QRinput_setVersionAndErrorCorrectionLevel(QRinput *input, int version, QRecLevel level)\n{\n\tif(input->mqr) {\n\t\tif(version <= 0 || version > MQRSPEC_VERSION_MAX) goto INVALID;\n\t\tif((MQRspec_getECCLength(version, level) == 0)) goto INVALID;\n\t} else {\n\t\tif(version < 0 || version > QRSPEC_VERSION_MAX) goto INVALID;\n\t\tif(level > QR_ECLEVEL_H) goto INVALID;\n\t}\n\n\tinput->version = version;\n\tinput->level = level;\n\n\treturn 0;\n\nINVALID:\n\terrno = EINVAL;\n\treturn -1;\n}\n\nstatic void QRinput_appendEntry(QRinput *input, QRinput_List *entry)\n{\n\tif(input->tail == NULL) {\n\t\tinput->head = entry;\n\t\tinput->tail = entry;\n\t} else {\n\t\tinput->tail->next = entry;\n\t\tinput->tail = entry;\n\t}\n\tentry->next = NULL;\n}\n\nint QRinput_append(QRinput *input, QRencodeMode mode, int size, const unsigned char *data)\n{\n\tQRinput_List *entry;\n\n\tentry = QRinput_List_newEntry(mode, size, data);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tQRinput_appendEntry(input, entry);\n\n\treturn 0;\n}\n\n/**\n * Insert a structured-append header to the head of the input data.\n * @param input input data.\n * @param size number of structured symbols.\n * @param number index number of the symbol. (1 <= number <= size)\n * @param parity parity among input data. (NOTE: each symbol of a set of structured symbols has the same parity data)\n * @retval 0 success.\n * @retval -1 error occurred and errno is set to indeicate the error. See Execptions for the details.\n * @throw EINVAL invalid parameter.\n * @throw ENOMEM unable to allocate memory.\n */\nSTATIC_IN_RELEASE int QRinput_insertStructuredAppendHeader(QRinput *input, int size, int number, unsigned char parity)\n{\n\tQRinput_List *entry;\n\tunsigned char buf[3];\n\n\tif(size > MAX_STRUCTURED_SYMBOLS) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(number <= 0 || number > size) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tbuf[0] = (unsigned char)size;\n\tbuf[1] = (unsigned char)number;\n\tbuf[2] = parity;\n\tentry = QRinput_List_newEntry(QR_MODE_STRUCTURE, 3, buf);\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tentry->next = input->head;\n\tinput->head = entry;\n\n\treturn 0;\n}\n\nint QRinput_appendECIheader(QRinput *input, unsigned int ecinum)\n{\n\tunsigned char data[4];\n\n\tif(ecinum > 999999) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\t/* We manually create byte array of ecinum because\n\t (unsigned char *)&ecinum may cause bus error on some architectures, */\n\tdata[0] = ecinum & 0xff;\n\tdata[1] = (ecinum >>  8) & 0xff;\n\tdata[2] = (ecinum >> 16) & 0xff;\n\tdata[3] = (ecinum >> 24) & 0xff;\n\treturn QRinput_append(input, QR_MODE_ECI, 4, data);\n}\n\nvoid QRinput_free(QRinput *input)\n{\n\tQRinput_List *list, *next;\n\n\tif(input != NULL) {\n\t\tlist = input->head;\n\t\twhile(list != NULL) {\n\t\t\tnext = list->next;\n\t\t\tQRinput_List_freeEntry(list);\n\t\t\tlist = next;\n\t\t}\n\t\tfree(input);\n\t}\n}\n\nstatic unsigned char QRinput_calcParity(QRinput *input)\n{\n\tunsigned char parity = 0;\n\tQRinput_List *list;\n\tint i;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tif(list->mode != QR_MODE_STRUCTURE) {\n\t\t\tfor(i = list->size-1; i >= 0; i--) {\n\t\t\t\tparity ^= list->data[i];\n\t\t\t}\n\t\t}\n\t\tlist = list->next;\n\t}\n\n\treturn parity;\n}\n\nQRinput *QRinput_dup(QRinput *input)\n{\n\tQRinput *n;\n\tQRinput_List *list, *e;\n\n\tif(input->mqr) {\n\t\tn = QRinput_newMQR(input->version, input->level);\n\t} else {\n\t\tn = QRinput_new2(input->version, input->level);\n\t}\n\tif(n == NULL) return NULL;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\te = QRinput_List_dup(list);\n\t\tif(e == NULL) {\n\t\t\tQRinput_free(n);\n\t\t\treturn NULL;\n\t\t}\n\t\tQRinput_appendEntry(n, e);\n\t\tlist = list->next;\n\t}\n\n\treturn n;\n}\n\n/******************************************************************************\n * Numeric data\n *****************************************************************************/\n\n/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\nstatic int QRinput_checkModeNum(int size, const char *data)\n{\n\tint i;\n\n\tfor(i = 0; i < size; i++) {\n\t\tif(data[i] < '0' || data[i] > '9')\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Estimate the length of the encoded bit stream of numeric data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsModeNum(int size)\n{\n\tint w;\n\tint bits;\n\n\tw = size / 3;\n\tbits = w * 10;\n\tswitch(size - w * 3) {\n\t\tcase 1:\n\t\t\tbits += 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbits += 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Convert the number data and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_encodeModeNum(QRinput_List *entry, BitStream *bstream, int version, int mqr)\n{\n\tint words, i, ret;\n\tunsigned int val;\n\n\tif(mqr) {\n\t\tif(version > 1) {\n\t\t\tret = BitStream_appendNum(bstream, (size_t)(version - 1), MQRSPEC_MODEID_NUM);\n\t\t\tif(ret < 0) return -1;\n\t\t}\n\t\tret = BitStream_appendNum(bstream, (size_t)MQRspec_lengthIndicator(QR_MODE_NUM, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t} else {\n\t\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_NUM);\n\t\tif(ret < 0) return -1;\n\n\t\tret = BitStream_appendNum(bstream, (size_t)QRspec_lengthIndicator(QR_MODE_NUM, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t}\n\n\twords = entry->size / 3;\n\tfor(i = 0; i < words; i++) {\n\t\tval  = (unsigned int)(entry->data[i*3  ] - '0') * 100;\n\t\tval += (unsigned int)(entry->data[i*3+1] - '0') * 10;\n\t\tval += (unsigned int)(entry->data[i*3+2] - '0');\n\n\t\tret = BitStream_appendNum(bstream, 10, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\tif(entry->size - words * 3 == 1) {\n\t\tval = (unsigned int)(entry->data[words*3] - '0');\n\t\tret = BitStream_appendNum(bstream, 4, val);\n\t\tif(ret < 0) return -1;\n\t} else if(entry->size - words * 3 == 2) {\n\t\tval  = (unsigned int)(entry->data[words*3  ] - '0') * 10;\n\t\tval += (unsigned int)(entry->data[words*3+1] - '0');\n\t\tret = BitStream_appendNum(bstream, 7, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\n * Alphabet-numeric data\n *****************************************************************************/\n\nconst signed char QRinput_anTable[128] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 44, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n\t25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\n/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\nstatic int QRinput_checkModeAn(int size, const char *data)\n{\n\tint i;\n\n\tfor(i = 0; i < size; i++) {\n\t\tif(QRinput_lookAnTable(data[i]) < 0)\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Estimate the length of the encoded bit stream of alphabet-numeric data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsModeAn(int size)\n{\n\tint w;\n\tint bits;\n\n\tw = size / 2;\n\tbits = w * 11;\n\tif(size & 1) {\n\t\tbits += 6;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Convert the alphabet-numeric data and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid version.\n */\nstatic int QRinput_encodeModeAn(QRinput_List *entry, BitStream *bstream, int version, int mqr)\n{\n\tint words, i, ret;\n\tunsigned int val;\n\n\tif(mqr) {\n\t\tif(version < 2) {\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t}\n\t\tret = BitStream_appendNum(bstream, (size_t)(version - 1), MQRSPEC_MODEID_AN);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)MQRspec_lengthIndicator(QR_MODE_AN, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t} else {\n\t\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_AN);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)QRspec_lengthIndicator(QR_MODE_AN, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t}\n\n\twords = entry->size / 2;\n\tfor(i = 0; i < words; i++) {\n\t\tval  = (unsigned int)QRinput_lookAnTable(entry->data[i*2  ]) * 45;\n\t\tval += (unsigned int)QRinput_lookAnTable(entry->data[i*2+1]);\n\n\t\tret = BitStream_appendNum(bstream, 11, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\tif(entry->size & 1) {\n\t\tval = (unsigned int)QRinput_lookAnTable(entry->data[words * 2]);\n\n\t\tret = BitStream_appendNum(bstream, 6, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\n * 8 bit data\n *****************************************************************************/\n\n/**\n * Estimate the length of the encoded bit stream of 8 bit data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsMode8(int size)\n{\n\treturn size * 8;\n}\n\n/**\n * Convert the 8bits data and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_encodeMode8(QRinput_List *entry, BitStream *bstream, int version, int mqr)\n{\n\tint ret;\n\n\tif(mqr) {\n\t\tif(version < 3) {\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t}\n\t\tret = BitStream_appendNum(bstream, (size_t)(version - 1), MQRSPEC_MODEID_8);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)MQRspec_lengthIndicator(QR_MODE_8, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t} else {\n\t\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_8);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)QRspec_lengthIndicator(QR_MODE_8, version), (unsigned int)entry->size);\n\t\tif(ret < 0) return -1;\n\t}\n\n\tret = BitStream_appendBytes(bstream, (size_t)entry->size, entry->data);\n\tif(ret < 0) return -1;\n\n\treturn 0;\n}\n\n\n/******************************************************************************\n * Kanji data\n *****************************************************************************/\n\n/**\n * Estimate the length of the encoded bit stream of kanji data.\n * @param size\n * @return number of bits\n */\nint QRinput_estimateBitsModeKanji(int size)\n{\n\treturn (size / 2) * 13;\n}\n\n/**\n * Check the input data.\n * @param size\n * @param data\n * @return result\n */\nstatic int QRinput_checkModeKanji(int size, const unsigned char *data)\n{\n\tint i;\n\tunsigned int val;\n\n\tif(size & 1)\n\t\treturn -1;\n\n\tfor(i = 0; i < size; i+=2) {\n\t\tval = ((unsigned int)data[i] << 8) | data[i+1];\n\t\tif(val < 0x8140 || (val > 0x9ffc && val < 0xe040) || val > 0xebbf) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Convert the kanji data and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid version.\n */\nstatic int QRinput_encodeModeKanji(QRinput_List *entry, BitStream *bstream, int version, int mqr)\n{\n\tint ret, i;\n\tunsigned int val, h;\n\n\tif(mqr) {\n\t\tif(version < 2) {\n\t\t\terrno = ERANGE;\n\t\t\treturn -1;\n\t\t}\n\t\tret = BitStream_appendNum(bstream, (size_t)(version - 1), MQRSPEC_MODEID_KANJI);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)MQRspec_lengthIndicator(QR_MODE_KANJI, version), (unsigned int)entry->size/2);\n\t\tif(ret < 0) return -1;\n\t} else {\n\t\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_KANJI);\n\t\tif(ret < 0) return -1;\n\t\tret = BitStream_appendNum(bstream, (size_t)QRspec_lengthIndicator(QR_MODE_KANJI, version), (unsigned int)entry->size/2);\n\t\tif(ret < 0) return -1;\n\t}\n\n\tfor(i = 0; i < entry->size; i+=2) {\n\t\tval = ((unsigned int)entry->data[i] << 8) | entry->data[i+1];\n\t\tif(val <= 0x9ffc) {\n\t\t\tval -= 0x8140;\n\t\t} else {\n\t\t\tval -= 0xc140;\n\t\t}\n\t\th = (val >> 8) * 0xc0;\n\t\tval = (val & 0xff) + h;\n\n\t\tret = BitStream_appendNum(bstream, 13, val);\n\t\tif(ret < 0) return -1;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\n * Structured Symbol\n *****************************************************************************/\n\n/**\n * Convert a structure symbol code and append to a bit stream.\n * @param entry\n * @param mqr\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw EINVAL invalid entry.\n */\nstatic int QRinput_encodeModeStructure(QRinput_List *entry, BitStream *bstream, int mqr)\n{\n\tint ret;\n\n\tif(mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_STRUCTURE);\n\tif(ret < 0) return -1;\n\tret = BitStream_appendNum(bstream, 4, entry->data[1] - 1U);\n\tif(ret < 0) return -1;\n\tret = BitStream_appendNum(bstream, 4, entry->data[0] - 1U);\n\tif(ret < 0) return -1;\n\tret = BitStream_appendNum(bstream, 8, entry->data[2]);\n\tif(ret < 0) return -1;\n\n\treturn 0;\n}\n\n/******************************************************************************\n * FNC1\n *****************************************************************************/\n\nstatic int QRinput_checkModeFNC1Second(int size)\n{\n\tif(size != 1) return -1;\n\n\t/* No data check required. */\n\n\treturn 0;\n}\n\nstatic int QRinput_encodeModeFNC1Second(QRinput_List *entry, BitStream *bstream)\n{\n\tint ret;\n\n\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_FNC1SECOND);\n\tif(ret < 0) return -1;\n\n\tret = BitStream_appendBytes(bstream, 1, entry->data);\n\tif(ret < 0) return -1;\n\n\treturn 0;\n}\n\n/******************************************************************************\n * ECI header\n *****************************************************************************/\nstatic unsigned int QRinput_decodeECIfromByteArray(unsigned char *data)\n{\n\tint i;\n\tunsigned int ecinum;\n\n\tecinum = 0;\n\tfor(i = 0; i < 4; i++) {\n\t\tecinum = ecinum << 8;\n\t\tecinum |= data[3-i];\n\t}\n\n\treturn ecinum;\n}\n\nstatic int QRinput_estimateBitsModeECI(unsigned char *data)\n{\n\tunsigned int ecinum;\n\n\tecinum = QRinput_decodeECIfromByteArray(data);\n\n\t/* See Table 4 of JISX 0510:2004 pp.17. */\n\tif(ecinum < 128) {\n\t\treturn MODE_INDICATOR_SIZE + 8;\n\t} else if(ecinum < 16384) {\n\t\treturn MODE_INDICATOR_SIZE + 16;\n\t} else {\n\t\treturn MODE_INDICATOR_SIZE + 24;\n\t}\n}\n\nstatic int QRinput_encodeModeECI(QRinput_List *entry, BitStream *bstream)\n{\n\tint ret, words;\n\tunsigned int ecinum, code;\n\n\tecinum = QRinput_decodeECIfromByteArray(entry->data);\n\n\t/* See Table 4 of JISX 0510:2004 pp.17. */\n\tif(ecinum < 128) {\n\t\twords = 1;\n\t\tcode = ecinum;\n\t} else if(ecinum < 16384) {\n\t\twords = 2;\n\t\tcode = 0x8000 + ecinum;\n\t} else {\n\t\twords = 3;\n\t\tcode = 0xc0000 + ecinum;\n\t}\n\n\tret = BitStream_appendNum(bstream, 4, QRSPEC_MODEID_ECI);\n\tif(ret < 0) return -1;\n\n\tret = BitStream_appendNum(bstream, (size_t)words * 8, code);\n\tif(ret < 0) return -1;\n\n\treturn 0;\n}\n\n/******************************************************************************\n * Validation\n *****************************************************************************/\n\nint QRinput_check(QRencodeMode mode, int size, const unsigned char *data)\n{\n\tif((mode == QR_MODE_FNC1FIRST && size < 0) || size <= 0) return -1;\n\n\tswitch(mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\treturn QRinput_checkModeNum(size, (const char *)data);\n\t\tcase QR_MODE_AN:\n\t\t\treturn QRinput_checkModeAn(size, (const char *)data);\n\t\tcase QR_MODE_KANJI:\n\t\t\treturn QRinput_checkModeKanji(size, data);\n\t\tcase QR_MODE_8:\n\t\t\treturn 0;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\treturn 0;\n\t\tcase QR_MODE_ECI:\n\t\t\treturn 0;\n\t\tcase QR_MODE_FNC1FIRST:\n\t\t\treturn 0;\n\t\tcase QR_MODE_FNC1SECOND:\n\t\t\treturn QRinput_checkModeFNC1Second(size);\n\t\tcase QR_MODE_NUL:\n\t\t\tbreak;\n\t}\n\n\treturn -1;\n}\n\n/******************************************************************************\n * Estimation of the bit length\n *****************************************************************************/\n\n/**\n * Estimate the length of the encoded bit stream on the current version.\n * @param entry\n * @param version version of the symbol\n * @param mqr\n * @return number of bits\n */\nstatic int QRinput_estimateBitStreamSizeOfEntry(QRinput_List *entry, int version, int mqr)\n{\n\tint bits = 0;\n\tint l, m;\n\tint num;\n\n\tif(version == 0) version = 1;\n\n\tswitch(entry->mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\tbits = QRinput_estimateBitsModeNum(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_AN:\n\t\t\tbits = QRinput_estimateBitsModeAn(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_8:\n\t\t\tbits = QRinput_estimateBitsMode8(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_KANJI:\n\t\t\tbits = QRinput_estimateBitsModeKanji(entry->size);\n\t\t\tbreak;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\treturn STRUCTURE_HEADER_SIZE;\n\t\tcase QR_MODE_ECI:\n\t\t\tbits = QRinput_estimateBitsModeECI(entry->data);\n\t\t\tbreak;\n\t\tcase QR_MODE_FNC1FIRST:\n\t\t\treturn MODE_INDICATOR_SIZE;\n\t\tcase QR_MODE_FNC1SECOND:\n\t\t\treturn MODE_INDICATOR_SIZE + 8;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tif(mqr) {\n\t\tl = MQRspec_lengthIndicator(entry->mode, version);\n\t\tm = version - 1;\n\t\tbits += l + m;\n\t} else {\n\t\tl = QRspec_lengthIndicator(entry->mode, version);\n\t\tm = 1 << l;\n\t\tif(entry->mode == QR_MODE_KANJI) {\n\t\t\tnum = (entry->size/2 + m - 1) / m;\n\t\t} else {\n\t\t\tnum = (entry->size + m - 1) / m;\n\t\t}\n\n\t\tbits += num * (MODE_INDICATOR_SIZE + l);\n\t}\n\n\treturn bits;\n}\n\n/**\n * Estimate the length of the encoded bit stream of the data.\n * @param input input data\n * @param version version of the symbol\n * @return number of bits\n */\nSTATIC_IN_RELEASE int QRinput_estimateBitStreamSize(QRinput *input, int version)\n{\n\tQRinput_List *list;\n\tint bits = 0;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tbits += QRinput_estimateBitStreamSizeOfEntry(list, version, input->mqr);\n\t\tlist = list->next;\n\t}\n\n\treturn bits;\n}\n\n/**\n * Estimate the required version number of the symbol.\n * @param input input data\n * @return required version number or -1 for failure.\n */\nSTATIC_IN_RELEASE int QRinput_estimateVersion(QRinput *input)\n{\n\tint bits;\n\tint version, prev;\n\n\tversion = 0;\n\tdo {\n\t\tprev = version;\n\t\tbits = QRinput_estimateBitStreamSize(input, prev);\n\t\tversion = QRspec_getMinimumVersion((bits + 7) / 8, input->level);\n\t\tif(prev == 0 && version > 1) {\n\t\t\tversion--;\n\t\t}\n\t} while (version > prev);\n\n\treturn version;\n}\n\n/**\n * Return required length in bytes for specified mode, version and bits.\n * @param mode\n * @param version\n * @param bits\n * @return required length of code words in bytes.\n */\nSTATIC_IN_RELEASE int QRinput_lengthOfCode(QRencodeMode mode, int version, int bits)\n{\n\tint payload, size, chunks, remain, maxsize;\n\n\tpayload = bits - 4 - QRspec_lengthIndicator(mode, version);\n\tswitch(mode) {\n\t\tcase QR_MODE_NUM:\n\t\t\tchunks = payload / 10;\n\t\t\tremain = payload - chunks * 10;\n\t\t\tsize = chunks * 3;\n\t\t\tif(remain >= 7) {\n\t\t\t\tsize += 2;\n\t\t\t} else if(remain >= 4) {\n\t\t\t\tsize += 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QR_MODE_AN:\n\t\t\tchunks = payload / 11;\n\t\t\tremain = payload - chunks * 11;\n\t\t\tsize = chunks * 2;\n\t\t\tif(remain >= 6) size++;\n\t\t\tbreak;\n\t\tcase QR_MODE_8:\n\t\t\tsize = payload / 8;\n\t\t\tbreak;\n\t\tcase QR_MODE_KANJI:\n\t\t\tsize = (payload / 13) * 2;\n\t\t\tbreak;\n\t\tcase QR_MODE_STRUCTURE:\n\t\t\tsize = payload / 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t}\n\tmaxsize = QRspec_maximumWords(mode, version);\n\tif(size < 0) size = 0;\n\tif(maxsize > 0 && size > maxsize) size = maxsize;\n\n\treturn size;\n}\n\n/******************************************************************************\n * Data conversion\n *****************************************************************************/\n\n/**\n * Convert the input data in the data chunk and append to a bit stream.\n * @param entry\n * @param bstream\n * @return number of bits (>0) or -1 for failure.\n */\nstatic int QRinput_encodeBitStream(QRinput_List *entry, BitStream *bstream, int version, int mqr)\n{\n\tint words, ret;\n\tQRinput_List *st1 = NULL, *st2 = NULL;\n\tint prevsize;\n\n\tprevsize = (int)BitStream_size(bstream);\n\n\tif(mqr) {\n\t\twords = MQRspec_maximumWords(entry->mode, version);\n\t} else {\n\t\twords = QRspec_maximumWords(entry->mode, version);\n\t}\n\tif(words != 0 && entry->size > words) {\n\t\tst1 = QRinput_List_newEntry(entry->mode, words, entry->data);\n\t\tif(st1 == NULL) goto ABORT;\n\t\tst2 = QRinput_List_newEntry(entry->mode, entry->size - words, &entry->data[words]);\n\t\tif(st2 == NULL) goto ABORT;\n\n\t\tret = QRinput_encodeBitStream(st1, bstream, version, mqr);\n\t\tif(ret < 0) goto ABORT;\n\t\tret = QRinput_encodeBitStream(st2, bstream, version, mqr);\n\t\tif(ret < 0) goto ABORT;\n\n\t\tQRinput_List_freeEntry(st1);\n\t\tQRinput_List_freeEntry(st2);\n\t} else {\n\t\tret = 0;\n\t\tswitch(entry->mode) {\n\t\t\tcase QR_MODE_NUM:\n\t\t\t\tret = QRinput_encodeModeNum(entry, bstream, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_AN:\n\t\t\t\tret = QRinput_encodeModeAn(entry, bstream, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_8:\n\t\t\t\tret = QRinput_encodeMode8(entry, bstream, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_KANJI:\n\t\t\t\tret = QRinput_encodeModeKanji(entry, bstream, version, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_STRUCTURE:\n\t\t\t\tret = QRinput_encodeModeStructure(entry, bstream, mqr);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_ECI:\n\t\t\t\tret = QRinput_encodeModeECI(entry, bstream);\n\t\t\t\tbreak;\n\t\t\tcase QR_MODE_FNC1SECOND:\n\t\t\t\tret = QRinput_encodeModeFNC1Second(entry, bstream);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tif(ret < 0) return -1;\n\t}\n\n\treturn (int)BitStream_size(bstream) - prevsize;\nABORT:\n\tQRinput_List_freeEntry(st1);\n\tQRinput_List_freeEntry(st2);\n\treturn -1;\n}\n\n/**\n * Convert the input data to a bit stream.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_createBitStream(QRinput *input, BitStream *bstream)\n{\n\tQRinput_List *list;\n\tint bits, total = 0;\n\n\tlist = input->head;\n\twhile(list != NULL) {\n\t\tbits = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);\n\t\tif(bits < 0) return -1;\n\t\ttotal += bits;\n\t\tlist = list->next;\n\t}\n\n\treturn total;\n}\n\n/**\n * Convert the input data to a bit stream.\n * When the version number is given and that is not sufficient, it is increased\n * automatically.\n * @param input input data.\n * @param bstream where the converted data is stored.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ENOMEM unable to allocate memory.\n * @throw ERANGE input data is too large.\n */\nstatic int QRinput_convertData(QRinput *input, BitStream *bstream)\n{\n\tint bits;\n\tint ver;\n\n\tver = QRinput_estimateVersion(input);\n\tif(ver > QRinput_getVersion(input)) {\n\t\tQRinput_setVersion(input, ver);\n\t}\n\n\tfor(;;) {\n\t\tBitStream_reset(bstream);\n\t\tbits = QRinput_createBitStream(input, bstream);\n\t\tif(bits < 0) return -1;\n\t\tver = QRspec_getMinimumVersion((bits + 7) / 8, input->level);\n\t\tif(ver > QRinput_getVersion(input)) {\n\t\t\tQRinput_setVersion(input, ver);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Append padding bits for the input data.\n * @param bstream Bitstream to be appended.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ERANGE input data is too large.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_appendPaddingBit(BitStream *bstream, QRinput *input)\n{\n\tint bits, maxbits, words, maxwords, i, ret;\n\tint padlen;\n\n\tbits = (int)BitStream_size(bstream);\n\tmaxwords = QRspec_getDataLength(input->version, input->level);\n\tmaxbits = maxwords * 8;\n\n\tif(maxbits < bits) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\tif(maxbits == bits) {\n\t\treturn 0;\n\t}\n\n\tif(maxbits - bits <= 4) {\n\t\treturn (int)BitStream_appendNum(bstream, (size_t)(maxbits - bits), 0);\n\t}\n\n\twords = (bits + 4 + 7) / 8;\n\n\tret = (int)BitStream_appendNum(bstream, (size_t)(words * 8 - bits), 0);\n\tif(ret < 0) return ret;\n\n\tpadlen = maxwords - words;\n\tif(padlen > 0) {\n\t\tfor(i = 0; i < padlen; i++) {\n\t\t\tret = (int)BitStream_appendNum(bstream, 8, (i&1)?0x11:0xec);\n\t\t\tif(ret < 0) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Append padding bits for the input data - Micro QR Code version.\n * @param bstream Bitstream to be appended.\n * @param input input data.\n * @retval 0 success\n * @retval -1 an error occurred and errno is set to indeicate the error.\n *            See Execptions for the details.\n * @throw ERANGE input data is too large.\n * @throw ENOMEM unable to allocate memory.\n */\nstatic int QRinput_appendPaddingBitMQR(BitStream *bstream, QRinput *input)\n{\n\tint bits, maxbits, words, maxwords, i, ret, termbits;\n\tint padlen;\n\n\tbits = (int)BitStream_size(bstream);\n\tmaxbits = MQRspec_getDataLengthBit(input->version, input->level);\n\tmaxwords = maxbits / 8;\n\n\tif(maxbits < bits) {\n\t\terrno = ERANGE;\n\t\treturn -1;\n\t}\n\tif(maxbits == bits) {\n\t\treturn 0;\n\t}\n\n\ttermbits = input->version * 2 + 1;\n\n\tif(maxbits - bits <= termbits) {\n\t\treturn (int)BitStream_appendNum(bstream, (size_t)(maxbits - bits), 0);\n\t}\n\n\tbits += termbits;\n\n\twords = (bits + 7) / 8;\n\tif(maxbits - words * 8 > 0) {\n\t\ttermbits += words * 8 - bits;\n\t\tif(words == maxwords) termbits += maxbits - words * 8;\n\t} else {\n\t\ttermbits += words * 8 - bits;\n\t}\n\tret = (int)BitStream_appendNum(bstream, (size_t)termbits, 0);\n\tif(ret < 0) return ret;\n\n\tpadlen = maxwords - words;\n\tif(padlen > 0) {\n\t\tfor(i = 0; i < padlen; i++) {\n\t\t\tret = (int)BitStream_appendNum(bstream, 8, (i&1)?0x11:0xec);\n\t\t\tif(ret < 0) return ret;\n\t\t}\n\t\ttermbits = maxbits - maxwords * 8;\n\t\tif(termbits > 0) {\n\t\t\tret = (int)BitStream_appendNum(bstream, (size_t)termbits, 0);\n\t\t\tif(ret < 0) return ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int QRinput_insertFNC1Header(QRinput *input)\n{\n\tQRinput_List *entry = NULL;\n\n\tif(input->fnc1 == 1) {\n\t\tentry = QRinput_List_newEntry(QR_MODE_FNC1FIRST, 0, NULL);\n\t} else if(input->fnc1 == 2) {\n\t\tentry = QRinput_List_newEntry(QR_MODE_FNC1SECOND, 1, &(input->appid));\n\t}\n\tif(entry == NULL) {\n\t\treturn -1;\n\t}\n\n\tif(input->head->mode != QR_MODE_STRUCTURE && input->head->mode != QR_MODE_ECI) {\n\t\tentry->next = input->head;\n\t\tinput->head = entry;\n\t} else {\n\t\tentry->next = input->head->next;\n\t\tinput->head->next = entry;\n\t}\n\n\treturn 0;\n}\n\n/**\n * Merge all bit streams in the input data.\n * @param input input data.\n * @return merged bit stream\n */\n\nSTATIC_IN_RELEASE int QRinput_mergeBitStream(QRinput *input, BitStream *bstream)\n{\n\tif(input->mqr) {\n\t\tif(QRinput_createBitStream(input, bstream) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tif(input->fnc1) {\n\t\t\tif(QRinput_insertFNC1Header(input) < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(QRinput_convertData(input, bstream) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n/**\n * Merge all bit streams in the input data and append padding bits\n * @param input input data.\n * @return padded merged bit stream\n */\n\nSTATIC_IN_RELEASE int QRinput_getBitStream(QRinput *input, BitStream *bstream)\n{\n\tint ret;\n\n\tret = QRinput_mergeBitStream(input, bstream);\n\tif(ret < 0) return -1;\n\n\tif(input->mqr) {\n\t\tret = QRinput_appendPaddingBitMQR(bstream, input);\n\t} else {\n\t\tret = QRinput_appendPaddingBit(bstream, input);\n\t}\n\tif(ret < 0) return -1;\n\n\treturn 0;\n}\n\n/**\n * Pack all bit streams padding bits into a byte array.\n * @param input input data.\n * @return padded merged byte stream\n */\n\nunsigned char *QRinput_getByteStream(QRinput *input)\n{\n\tBitStream *bstream;\n\tunsigned char *array;\n\tint ret;\n\n\tbstream = BitStream_new();\n\tif(bstream == NULL) {\n\t\treturn NULL;\n\t}\n\n\tret = QRinput_getBitStream(input, bstream);\n\tif(ret < 0) {\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\tarray = BitStream_toByte(bstream);\n\tBitStream_free(bstream);\n\n\treturn array;\n}\n\n/******************************************************************************\n * Structured input data\n *****************************************************************************/\n\nstatic QRinput_InputList *QRinput_InputList_newEntry(QRinput *input)\n{\n\tQRinput_InputList *entry;\n\n\tentry = (QRinput_InputList *)malloc(sizeof(QRinput_InputList));\n\tif(entry == NULL) return NULL;\n\n\tentry->input = input;\n\tentry->next = NULL;\n\n\treturn entry;\n}\n\nstatic void QRinput_InputList_freeEntry(QRinput_InputList *entry)\n{\n\tif(entry != NULL) {\n\t\tQRinput_free(entry->input);\n\t\tfree(entry);\n\t}\n}\n\nQRinput_Struct *QRinput_Struct_new(void)\n{\n\tQRinput_Struct *s;\n\n\ts = (QRinput_Struct *)malloc(sizeof(QRinput_Struct));\n\tif(s == NULL) return NULL;\n\n\ts->size = 0;\n\ts->parity = -1;\n\ts->head = NULL;\n\ts->tail = NULL;\n\n\treturn s;\n}\n\nvoid QRinput_Struct_setParity(QRinput_Struct *s, unsigned char parity)\n{\n\ts->parity = (int)parity;\n}\n\nint QRinput_Struct_appendInput(QRinput_Struct *s, QRinput *input)\n{\n\tQRinput_InputList *e;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\te = QRinput_InputList_newEntry(input);\n\tif(e == NULL) return -1;\n\n\ts->size++;\n\tif(s->tail == NULL) {\n\t\ts->head = e;\n\t\ts->tail = e;\n\t} else {\n\t\ts->tail->next = e;\n\t\ts->tail = e;\n\t}\n\n\treturn s->size;\n}\n\nvoid QRinput_Struct_free(QRinput_Struct *s)\n{\n\tQRinput_InputList *list, *next;\n\n\tif(s != NULL) {\n\t\tlist = s->head;\n\t\twhile(list != NULL) {\n\t\t\tnext = list->next;\n\t\t\tQRinput_InputList_freeEntry(list);\n\t\t\tlist = next;\n\t\t}\n\t\tfree(s);\n\t}\n}\n\nstatic unsigned char QRinput_Struct_calcParity(QRinput_Struct *s)\n{\n\tQRinput_InputList *list;\n\tunsigned char parity = 0;\n\n\tlist = s->head;\n\twhile(list != NULL) {\n\t\tparity ^= QRinput_calcParity(list->input);\n\t\tlist = list->next;\n\t}\n\n\tQRinput_Struct_setParity(s, parity);\n\n\treturn parity;\n}\n\nstatic int QRinput_List_shrinkEntry(QRinput_List *entry, int bytes)\n{\n\tunsigned char *data;\n\n\tdata = (unsigned char *)malloc((size_t)bytes);\n\tif(data == NULL) return -1;\n\n\tmemcpy(data, entry->data, (size_t)bytes);\n\tfree(entry->data);\n\tentry->data = data;\n\tentry->size = bytes;\n\n\treturn 0;\n}\n\nSTATIC_IN_RELEASE int QRinput_splitEntry(QRinput_List *entry, int bytes)\n{\n\tQRinput_List *e;\n\tint ret;\n\n\te = QRinput_List_newEntry(entry->mode, entry->size - bytes, entry->data + bytes);\n\tif(e == NULL) {\n\t\treturn -1;\n\t}\n\n\tret = QRinput_List_shrinkEntry(entry, bytes);\n\tif(ret < 0) {\n\t\tQRinput_List_freeEntry(e);\n\t\treturn -1;\n\t}\n\n\te->next = entry->next;\n\tentry->next = e;\n\n\treturn 0;\n}\n\nQRinput_Struct *QRinput_splitQRinputToStruct(QRinput *input)\n{\n\tQRinput *p = NULL;\n\tQRinput_Struct *s = NULL;\n\tint bits, maxbits, nextbits, bytes, ret;\n\tQRinput_List *list, *next, *prev;\n\tBitStream *bstream = NULL;\n\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\n\ts = QRinput_Struct_new();\n\tif(s == NULL) return NULL;\n\n\tinput = QRinput_dup(input);\n\tif(input == NULL) {\n\t\tQRinput_Struct_free(s);\n\t\treturn NULL;\n\t}\n\n\tQRinput_Struct_setParity(s, QRinput_calcParity(input));\n\tmaxbits = QRspec_getDataLength(input->version, input->level) * 8 - STRUCTURE_HEADER_SIZE;\n\n\tif(maxbits <= 0) goto ABORT;\n\n\tbstream = BitStream_new();\n\tif(bstream == NULL) goto ABORT;\n\n\tbits = 0;\n\tlist = input->head;\n\tprev = NULL;\n\twhile(list != NULL) {\n\t\tnextbits = QRinput_estimateBitStreamSizeOfEntry(list, input->version, input->mqr);\n\t\tif(bits + nextbits <= maxbits) {\n\t\t\tBitStream_reset(bstream);\n\t\t\tret = QRinput_encodeBitStream(list, bstream, input->version, input->mqr);\n\t\t\tif(ret < 0) goto ABORT;\n\t\t\tbits += ret;\n\t\t\tprev = list;\n\t\t\tlist = list->next;\n\t\t} else {\n\t\t\tbytes = QRinput_lengthOfCode(list->mode, input->version, maxbits - bits);\n\t\t\tp = QRinput_new2(input->version, input->level);\n\t\t\tif(p == NULL) goto ABORT;\n\t\t\tif(bytes > 0) {\n\t\t\t\t/* Splits this entry into 2 entries. */\n\t\t\t\tret = QRinput_splitEntry(list, bytes);\n\t\t\t\tif(ret < 0) {\n\t\t\t\t\tQRinput_free(p);\n\t\t\t\t\tgoto ABORT;\n\t\t\t\t}\n\t\t\t\t/* First half is the tail of the current input. */\n\t\t\t\tnext = list->next;\n\t\t\t\tlist->next = NULL;\n\t\t\t\t/* Second half is the head of the next input, p.*/\n\t\t\t\tp->head = next;\n\t\t\t\t/* Renew QRinput.tail. */\n\t\t\t\tp->tail = input->tail;\n\t\t\t\tinput->tail = list;\n\t\t\t\t/* Point to the next entry. */\n\t\t\t\tprev = list;\n\t\t\t\tlist = next;\n\t\t\t} else {\n\t\t\t\t/* Current entry will go to the next input. */\n\t\t\t\tprev->next = NULL;\n\t\t\t\tp->head = list;\n\t\t\t\tp->tail = input->tail;\n\t\t\t\tinput->tail = prev;\n\t\t\t}\n\t\t\tret = QRinput_Struct_appendInput(s, input);\n\t\t\tif(ret < 0) {\n\t\t\t\tQRinput_free(p);\n\t\t\t\tgoto ABORT;\n\t\t\t}\n\t\t\tinput = p;\n\t\t\tbits = 0;\n\t\t}\n\t}\n\tret = QRinput_Struct_appendInput(s, input);\n\tif(ret < 0) goto ABORT;\n\tif(s->size > MAX_STRUCTURED_SYMBOLS) {\n\t\terrno = ERANGE;\n\t\tQRinput_Struct_free(s);\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\tret = QRinput_Struct_insertStructuredAppendHeaders(s);\n\tif(ret < 0) {\n\t\tQRinput_Struct_free(s);\n\t\tBitStream_free(bstream);\n\t\treturn NULL;\n\t}\n\n\tBitStream_free(bstream);\n\treturn s;\n\nABORT:\n\tBitStream_free(bstream);\n\tQRinput_free(input);\n\tQRinput_Struct_free(s);\n\treturn NULL;\n}\n\nint QRinput_Struct_insertStructuredAppendHeaders(QRinput_Struct *s)\n{\n\tint i;\n\tQRinput_InputList *list;\n\n\tif(s->size == 1) {\n\t\treturn 0;\n\t}\n\n\tif(s->parity < 0) {\n\t\tQRinput_Struct_calcParity(s);\n\t}\n\ti = 1;\n\tlist = s->head;\n\twhile(list != NULL) {\n\t\tif(QRinput_insertStructuredAppendHeader(list->input, s->size, i, s->parity))\n\t\t\treturn -1;\n\t\ti++;\n\t\tlist = list->next;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\n * Extended encoding mode (FNC1 and ECI)\n *****************************************************************************/\n\nint QRinput_setFNC1First(QRinput *input)\n{\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tinput->fnc1 = 1;\n\n\treturn 0;\n}\n\nint QRinput_setFNC1Second(QRinput *input, unsigned char appid)\n{\n\tif(input->mqr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tinput->fnc1 = 2;\n\tinput->appid = appid;\n\n\treturn 0;\n}\n"
        },
        {
          "name": "qrinput.h",
          "type": "blob",
          "size": 3.6337890625,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Input data chunk class\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef QRINPUT_H\n#define QRINPUT_H\n\n#include \"qrencode.h\"\n#include \"bitstream.h\"\n\nint QRinput_isSplittableMode(QRencodeMode mode);\n\n/******************************************************************************\n * Entry of input data\n *****************************************************************************/\ntypedef struct _QRinput_List QRinput_List;\n\nstruct _QRinput_List {\n\tQRencodeMode mode;\n\tint size;            ///< Size of data chunk (byte).\n\tunsigned char *data; ///< Data chunk.\n\tBitStream *bstream;\n\tQRinput_List *next;\n};\n\n/******************************************************************************\n * Input Data\n *****************************************************************************/\nstruct _QRinput {\n\tint version;\n\tQRecLevel level;\n\tQRinput_List *head;\n\tQRinput_List *tail;\n\tint mqr;\n\tint fnc1;\n\tunsigned char appid;\n};\n\n/******************************************************************************\n * Structured append input data\n *****************************************************************************/\ntypedef struct _QRinput_InputList QRinput_InputList;\n\nstruct _QRinput_InputList {\n\tQRinput *input;\n\tQRinput_InputList *next;\n};\n\nstruct _QRinput_Struct {\n\tint size; ///< number of structured symbols\n\tint parity;\n\tQRinput_InputList *head;\n\tQRinput_InputList *tail;\n};\n\n/**\n * Pack all bit streams padding bits into a byte array.\n * @param input input data.\n * @return padded merged byte stream\n */\nextern unsigned char *QRinput_getByteStream(QRinput *input);\n\n\nextern int QRinput_estimateBitsModeNum(int size);\nextern int QRinput_estimateBitsModeAn(int size);\nextern int QRinput_estimateBitsMode8(int size);\nextern int QRinput_estimateBitsModeKanji(int size);\n\nextern QRinput *QRinput_dup(QRinput *input);\n\nextern const signed char QRinput_anTable[128];\n\n/**\n * Look up the alphabet-numeric convesion table (see JIS X0510:2004, pp.19).\n * @param __c__ character\n * @return value\n */\n#define QRinput_lookAnTable(__c__) \\\n\t((__c__ & 0x80)?-1:QRinput_anTable[(int)__c__])\n\n/**\n * Length of a standard mode indicator in bits.\n */\n\n#define MODE_INDICATOR_SIZE 4\n\n/**\n * Length of a segment of structured-append header.\n */\n#define STRUCTURE_HEADER_SIZE 20\n\n/**\n * Maximum number of symbols in a set of structured-appended symbols.\n */\n#define MAX_STRUCTURED_SYMBOLS 16\n\n#ifdef WITH_TESTS\nextern int QRinput_mergeBitStream(QRinput *input, BitStream *bstream);\nextern int QRinput_getBitStream(QRinput *input, BitStream *bstream);\nextern int QRinput_estimateBitStreamSize(QRinput *input, int version);\nextern int QRinput_splitEntry(QRinput_List *entry, int bytes);\nextern int QRinput_estimateVersion(QRinput *input);\nextern int QRinput_lengthOfCode(QRencodeMode mode, int version, int bits);\nextern int QRinput_insertStructuredAppendHeader(QRinput *input, int size, int index, unsigned char parity);\n#endif\n\n#endif /* QRINPUT_H */\n"
        },
        {
          "name": "qrspec.c",
          "type": "blob",
          "size": 14.435546875,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * QR Code specification in convenient format.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include \"qrspec.h\"\n#include \"qrinput.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\ntypedef struct {\n\tint width; //< Edge length of the symbol\n\tint words;  //< Data capacity (bytes)\n\tint remainder; //< Remainder bit (bits)\n\tint ec[4];  //< Number of ECC code (bytes)\n} QRspec_Capacity;\n\n/**\n * Table of the capacity of symbols\n * See Table 1 (pp.13) and Table 12-16 (pp.30-36), JIS X0510:2004.\n */\nstatic const QRspec_Capacity qrspecCapacity[QRSPEC_VERSION_MAX + 1] = {\n\t{  0,    0, 0, {   0,    0,    0,    0}},\n\t{ 21,   26, 0, {   7,   10,   13,   17}}, // 1\n\t{ 25,   44, 7, {  10,   16,   22,   28}},\n\t{ 29,   70, 7, {  15,   26,   36,   44}},\n\t{ 33,  100, 7, {  20,   36,   52,   64}},\n\t{ 37,  134, 7, {  26,   48,   72,   88}}, // 5\n\t{ 41,  172, 7, {  36,   64,   96,  112}},\n\t{ 45,  196, 0, {  40,   72,  108,  130}},\n\t{ 49,  242, 0, {  48,   88,  132,  156}},\n\t{ 53,  292, 0, {  60,  110,  160,  192}},\n\t{ 57,  346, 0, {  72,  130,  192,  224}}, //10\n\t{ 61,  404, 0, {  80,  150,  224,  264}},\n\t{ 65,  466, 0, {  96,  176,  260,  308}},\n\t{ 69,  532, 0, { 104,  198,  288,  352}},\n\t{ 73,  581, 3, { 120,  216,  320,  384}},\n\t{ 77,  655, 3, { 132,  240,  360,  432}}, //15\n\t{ 81,  733, 3, { 144,  280,  408,  480}},\n\t{ 85,  815, 3, { 168,  308,  448,  532}},\n\t{ 89,  901, 3, { 180,  338,  504,  588}},\n\t{ 93,  991, 3, { 196,  364,  546,  650}},\n\t{ 97, 1085, 3, { 224,  416,  600,  700}}, //20\n\t{101, 1156, 4, { 224,  442,  644,  750}},\n\t{105, 1258, 4, { 252,  476,  690,  816}},\n\t{109, 1364, 4, { 270,  504,  750,  900}},\n\t{113, 1474, 4, { 300,  560,  810,  960}},\n\t{117, 1588, 4, { 312,  588,  870, 1050}}, //25\n\t{121, 1706, 4, { 336,  644,  952, 1110}},\n\t{125, 1828, 4, { 360,  700, 1020, 1200}},\n\t{129, 1921, 3, { 390,  728, 1050, 1260}},\n\t{133, 2051, 3, { 420,  784, 1140, 1350}},\n\t{137, 2185, 3, { 450,  812, 1200, 1440}}, //30\n\t{141, 2323, 3, { 480,  868, 1290, 1530}},\n\t{145, 2465, 3, { 510,  924, 1350, 1620}},\n\t{149, 2611, 3, { 540,  980, 1440, 1710}},\n\t{153, 2761, 3, { 570, 1036, 1530, 1800}},\n\t{157, 2876, 0, { 570, 1064, 1590, 1890}}, //35\n\t{161, 3034, 0, { 600, 1120, 1680, 1980}},\n\t{165, 3196, 0, { 630, 1204, 1770, 2100}},\n\t{169, 3362, 0, { 660, 1260, 1860, 2220}},\n\t{173, 3532, 0, { 720, 1316, 1950, 2310}},\n\t{177, 3706, 0, { 750, 1372, 2040, 2430}} //40\n};\n\nint QRspec_getDataLength(int version, QRecLevel level)\n{\n\treturn qrspecCapacity[version].words - qrspecCapacity[version].ec[level];\n}\n\nint QRspec_getECCLength(int version, QRecLevel level)\n{\n\treturn qrspecCapacity[version].ec[level];\n}\n\nint QRspec_getMinimumVersion(int size, QRecLevel level)\n{\n\tint i;\n\tint words;\n\n\tfor(i = 1; i <= QRSPEC_VERSION_MAX; i++) {\n\t\twords  = qrspecCapacity[i].words - qrspecCapacity[i].ec[level];\n\t\tif(words >= size) return i;\n\t}\n\n\treturn QRSPEC_VERSION_MAX;\n}\n\nint QRspec_getWidth(int version)\n{\n\treturn qrspecCapacity[version].width;\n}\n\nint QRspec_getRemainder(int version)\n{\n\treturn qrspecCapacity[version].remainder;\n}\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\nstatic const int lengthTableBits[4][3] = {\n\t{10, 12, 14},\n\t{ 9, 11, 13},\n\t{ 8, 16, 16},\n\t{ 8, 10, 12}\n};\n\nint QRspec_lengthIndicator(QRencodeMode mode, int version)\n{\n\tint l;\n\n\tif(!QRinput_isSplittableMode(mode)) return 0;\n\tif(version <= 9) {\n\t\tl = 0;\n\t} else if(version <= 26) {\n\t\tl = 1;\n\t} else {\n\t\tl = 2;\n\t}\n\n\treturn lengthTableBits[mode][l];\n}\n\nint QRspec_maximumWords(QRencodeMode mode, int version)\n{\n\tint l;\n\tint bits;\n\tint words;\n\n\tif(!QRinput_isSplittableMode(mode)) return 0;\n\tif(version <= 9) {\n\t\tl = 0;\n\t} else if(version <= 26) {\n\t\tl = 1;\n\t} else {\n\t\tl = 2;\n\t}\n\n\tbits = lengthTableBits[mode][l];\n\twords = (1 << bits) - 1;\n\tif(mode == QR_MODE_KANJI) {\n\t\twords *= 2; // the number of bytes is required\n\t}\n\n\treturn words;\n}\n\n/******************************************************************************\n * Error correction code\n *****************************************************************************/\n\n/**\n * Table of the error correction code (Reed-Solomon block)\n * See Table 12-16 (pp.30-36), JIS X0510:2004.\n */\nstatic const int eccTable[QRSPEC_VERSION_MAX+1][4][2] = {\n\t{{ 0,  0}, { 0,  0}, { 0,  0}, { 0,  0}},\n\t{{ 1,  0}, { 1,  0}, { 1,  0}, { 1,  0}}, // 1\n\t{{ 1,  0}, { 1,  0}, { 1,  0}, { 1,  0}},\n\t{{ 1,  0}, { 1,  0}, { 2,  0}, { 2,  0}},\n\t{{ 1,  0}, { 2,  0}, { 2,  0}, { 4,  0}},\n\t{{ 1,  0}, { 2,  0}, { 2,  2}, { 2,  2}}, // 5\n\t{{ 2,  0}, { 4,  0}, { 4,  0}, { 4,  0}},\n\t{{ 2,  0}, { 4,  0}, { 2,  4}, { 4,  1}},\n\t{{ 2,  0}, { 2,  2}, { 4,  2}, { 4,  2}},\n\t{{ 2,  0}, { 3,  2}, { 4,  4}, { 4,  4}},\n\t{{ 2,  2}, { 4,  1}, { 6,  2}, { 6,  2}}, //10\n\t{{ 4,  0}, { 1,  4}, { 4,  4}, { 3,  8}},\n\t{{ 2,  2}, { 6,  2}, { 4,  6}, { 7,  4}},\n\t{{ 4,  0}, { 8,  1}, { 8,  4}, {12,  4}},\n\t{{ 3,  1}, { 4,  5}, {11,  5}, {11,  5}},\n\t{{ 5,  1}, { 5,  5}, { 5,  7}, {11,  7}}, //15\n\t{{ 5,  1}, { 7,  3}, {15,  2}, { 3, 13}},\n\t{{ 1,  5}, {10,  1}, { 1, 15}, { 2, 17}},\n\t{{ 5,  1}, { 9,  4}, {17,  1}, { 2, 19}},\n\t{{ 3,  4}, { 3, 11}, {17,  4}, { 9, 16}},\n\t{{ 3,  5}, { 3, 13}, {15,  5}, {15, 10}}, //20\n\t{{ 4,  4}, {17,  0}, {17,  6}, {19,  6}},\n\t{{ 2,  7}, {17,  0}, { 7, 16}, {34,  0}},\n\t{{ 4,  5}, { 4, 14}, {11, 14}, {16, 14}},\n\t{{ 6,  4}, { 6, 14}, {11, 16}, {30,  2}},\n\t{{ 8,  4}, { 8, 13}, { 7, 22}, {22, 13}}, //25\n\t{{10,  2}, {19,  4}, {28,  6}, {33,  4}},\n\t{{ 8,  4}, {22,  3}, { 8, 26}, {12, 28}},\n\t{{ 3, 10}, { 3, 23}, { 4, 31}, {11, 31}},\n\t{{ 7,  7}, {21,  7}, { 1, 37}, {19, 26}},\n\t{{ 5, 10}, {19, 10}, {15, 25}, {23, 25}}, //30\n\t{{13,  3}, { 2, 29}, {42,  1}, {23, 28}},\n\t{{17,  0}, {10, 23}, {10, 35}, {19, 35}},\n\t{{17,  1}, {14, 21}, {29, 19}, {11, 46}},\n\t{{13,  6}, {14, 23}, {44,  7}, {59,  1}},\n\t{{12,  7}, {12, 26}, {39, 14}, {22, 41}}, //35\n\t{{ 6, 14}, { 6, 34}, {46, 10}, { 2, 64}},\n\t{{17,  4}, {29, 14}, {49, 10}, {24, 46}},\n\t{{ 4, 18}, {13, 32}, {48, 14}, {42, 32}},\n\t{{20,  4}, {40,  7}, {43, 22}, {10, 67}},\n\t{{19,  6}, {18, 31}, {34, 34}, {20, 61}},//40\n};\n\nvoid QRspec_getEccSpec(int version, QRecLevel level, int spec[5])\n{\n\tint b1, b2;\n\tint data, ecc;\n\n\tb1 = eccTable[version][level][0];\n\tb2 = eccTable[version][level][1];\n\tdata = QRspec_getDataLength(version, level);\n\tecc  = QRspec_getECCLength(version, level);\n\n\tif(b2 == 0) {\n\t\tspec[0] = b1;\n\t\tspec[1] = data / b1;\n\t\tspec[2] = ecc / b1;\n\t\tspec[3] = spec[4] = 0;\n\t} else {\n\t\tspec[0] = b1;\n\t\tspec[1] = data / (b1 + b2);\n\t\tspec[2] = ecc  / (b1 + b2);\n\t\tspec[3] = b2;\n\t\tspec[4] = spec[1] + 1;\n\t}\n}\n\n/******************************************************************************\n * Alignment pattern\n *****************************************************************************/\n\n/**\n * Positions of alignment patterns.\n * This array includes only the second and the third position of the alignment\n * patterns. Rest of them can be calculated from the distance between them.\n *\n * See Table 1 in Appendix E (pp.71) of JIS X0510:2004.\n */\nstatic const int alignmentPattern[QRSPEC_VERSION_MAX+1][2] = {\n\t{ 0,  0},\n\t{ 0,  0}, {18,  0}, {22,  0}, {26,  0}, {30,  0}, // 1- 5\n\t{34,  0}, {22, 38}, {24, 42}, {26, 46}, {28, 50}, // 6-10\n\t{30, 54}, {32, 58}, {34, 62}, {26, 46}, {26, 48}, //11-15\n\t{26, 50}, {30, 54}, {30, 56}, {30, 58}, {34, 62}, //16-20\n\t{28, 50}, {26, 50}, {30, 54}, {28, 54}, {32, 58}, //21-25\n\t{30, 58}, {34, 62}, {26, 50}, {30, 54}, {26, 52}, //26-30\n\t{30, 56}, {34, 60}, {30, 58}, {34, 62}, {30, 54}, //31-35\n\t{24, 50}, {28, 54}, {32, 58}, {26, 54}, {30, 58}, //35-40\n};\n\n/**\n * Put an alignment marker.\n * @param frame\n * @param width\n * @param ox,oy center coordinate of the pattern\n */\nstatic void QRspec_putAlignmentMarker(unsigned char *frame, int width, int ox, int oy)\n{\n\tstatic const unsigned char finder[] = {\n\t\t0xa1, 0xa1, 0xa1, 0xa1, 0xa1,\n\t\t0xa1, 0xa0, 0xa0, 0xa0, 0xa1,\n\t\t0xa1, 0xa0, 0xa1, 0xa0, 0xa1,\n\t\t0xa1, 0xa0, 0xa0, 0xa0, 0xa1,\n\t\t0xa1, 0xa1, 0xa1, 0xa1, 0xa1,\n\t};\n\tint x, y;\n\tconst unsigned char *s;\n\n\tframe += (oy - 2) * width + ox - 2;\n\ts = finder;\n\tfor(y = 0; y < 5; y++) {\n\t\tfor(x = 0; x < 5; x++) {\n\t\t\tframe[x] = s[x];\n\t\t}\n\t\tframe += width;\n\t\ts += 5;\n\t}\n}\n\nstatic void QRspec_putAlignmentPattern(int version, unsigned char *frame, int width)\n{\n\tint d, w, x, y, cx, cy;\n\n\tif(version < 2) return;\n\n\td = alignmentPattern[version][1] - alignmentPattern[version][0];\n\tif(d < 0) {\n\t\tw = 2;\n\t} else {\n\t\tw = (width - alignmentPattern[version][0]) / d + 2;\n\t}\n\n\tif(w * w - 3 == 1) {\n\t\tx = alignmentPattern[version][0];\n\t\ty = alignmentPattern[version][0];\n\t\tQRspec_putAlignmentMarker(frame, width, x, y);\n\t\treturn;\n\t}\n\n\tcx = alignmentPattern[version][0];\n\tfor(x = 1; x < w - 1; x++) {\n\t\tQRspec_putAlignmentMarker(frame, width,  6, cx);\n\t\tQRspec_putAlignmentMarker(frame, width, cx,  6);\n\t\tcx += d;\n\t}\n\n\tcy = alignmentPattern[version][0];\n\tfor(y = 0; y < w-1; y++) {\n\t\tcx = alignmentPattern[version][0];\n\t\tfor(x = 0; x < w-1; x++) {\n\t\t\tQRspec_putAlignmentMarker(frame, width, cx, cy);\n\t\t\tcx += d;\n\t\t}\n\t\tcy += d;\n\t}\n}\n\n/******************************************************************************\n * Version information pattern\n *****************************************************************************/\n\n/**\n * Version information pattern (BCH coded).\n * See Table 1 in Appendix D (pp.68) of JIS X0510:2004.\n */\nstatic const unsigned int versionPattern[QRSPEC_VERSION_MAX - 6] = {\n\t0x07c94, 0x085bc, 0x09a99, 0x0a4d3, 0x0bbf6, 0x0c762, 0x0d847, 0x0e60d,\n\t0x0f928, 0x10b78, 0x1145d, 0x12a17, 0x13532, 0x149a6, 0x15683, 0x168c9,\n\t0x177ec, 0x18ec4, 0x191e1, 0x1afab, 0x1b08e, 0x1cc1a, 0x1d33f, 0x1ed75,\n\t0x1f250, 0x209d5, 0x216f0, 0x228ba, 0x2379f, 0x24b0b, 0x2542e, 0x26a64,\n\t0x27541, 0x28c69\n};\n\nunsigned int QRspec_getVersionPattern(int version)\n{\n\tif(version < 7 || version > QRSPEC_VERSION_MAX) return 0;\n\n\treturn versionPattern[version - 7];\n}\n\n/******************************************************************************\n * Format information\n *****************************************************************************/\n\n/* See calcFormatInfo in tests/test_qrspec.c */\nstatic const unsigned int formatInfo[4][8] = {\n\t{0x77c4, 0x72f3, 0x7daa, 0x789d, 0x662f, 0x6318, 0x6c41, 0x6976},\n\t{0x5412, 0x5125, 0x5e7c, 0x5b4b, 0x45f9, 0x40ce, 0x4f97, 0x4aa0},\n\t{0x355f, 0x3068, 0x3f31, 0x3a06, 0x24b4, 0x2183, 0x2eda, 0x2bed},\n\t{0x1689, 0x13be, 0x1ce7, 0x19d0, 0x0762, 0x0255, 0x0d0c, 0x083b}\n};\n\nunsigned int QRspec_getFormatInfo(int mask, QRecLevel level)\n{\n\tif(mask < 0 || mask > 7) return 0;\n\n\treturn formatInfo[level][mask];\n}\n\n/******************************************************************************\n * Frame\n *****************************************************************************/\n\n/**\n * Put a finder pattern.\n * @param frame\n * @param width\n * @param ox,oy upper-left coordinate of the pattern\n */\nstatic void putFinderPattern(unsigned char *frame, int width, int ox, int oy)\n{\n\tstatic const unsigned char finder[] = {\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc1, 0xc1, 0xc1, 0xc0, 0xc1,\n\t\t0xc1, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1,\n\t\t0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,\n\t};\n\tint x, y;\n\tconst unsigned char *s;\n\n\tframe += oy * width + ox;\n\ts = finder;\n\tfor(y = 0; y < 7; y++) {\n\t\tfor(x = 0; x < 7; x++) {\n\t\t\tframe[x] = s[x];\n\t\t}\n\t\tframe += width;\n\t\ts += 7;\n\t}\n}\n\n\nstatic unsigned char *QRspec_createFrame(int version)\n{\n\tunsigned char *frame, *p, *q;\n\tint width;\n\tint x, y;\n\tunsigned int verinfo, v;\n\n\twidth = qrspecCapacity[version].width;\n\tframe = (unsigned char *)malloc((size_t)(width * width));\n\tif(frame == NULL) return NULL;\n\n\tmemset(frame, 0, (size_t)(width * width));\n\t/* Finder pattern */\n\tputFinderPattern(frame, width, 0, 0);\n\tputFinderPattern(frame, width, width - 7, 0);\n\tputFinderPattern(frame, width, 0, width - 7);\n\t/* Separator */\n\tp = frame;\n\tq = frame + width * (width - 7);\n\tfor(y = 0; y < 7; y++) {\n\t\tp[7] = 0xc0;\n\t\tp[width - 8] = 0xc0;\n\t\tq[7] = 0xc0;\n\t\tp += width;\n\t\tq += width;\n\t}\n\tmemset(frame + width * 7, 0xc0, 8);\n\tmemset(frame + width * 8 - 8, 0xc0, 8);\n\tmemset(frame + width * (width - 8), 0xc0, 8);\n\t/* Mask format information area */\n\tmemset(frame + width * 8, 0x84, 9);\n\tmemset(frame + width * 9 - 8, 0x84, 8);\n\tp = frame + 8;\n\tfor(y = 0; y < 8; y++) {\n\t\t*p = 0x84;\n\t\tp += width;\n\t}\n\tp = frame + width * (width - 7) + 8;\n\tfor(y = 0; y < 7; y++) {\n\t\t*p = 0x84;\n\t\tp += width;\n\t}\n\t/* Timing pattern */\n\tp = frame + width * 6 + 8;\n\tq = frame + width * 8 + 6;\n\tfor(x = 1; x < width-15; x++) {\n\t\t*p =  0x90 | (x & 1);\n\t\t*q =  0x90 | (x & 1);\n\t\tp++;\n\t\tq += width;\n\t}\n\t/* Alignment pattern */\n\tQRspec_putAlignmentPattern(version, frame, width);\n\n\t/* Version information */\n\tif(version >= 7) {\n\t\tverinfo = QRspec_getVersionPattern(version);\n\n\t\tp = frame + width * (width - 11);\n\t\tv = verinfo;\n\t\tfor(x = 0; x < 6; x++) {\n\t\t\tfor(y = 0; y < 3; y++) {\n\t\t\t\tp[width * y + x] = 0x88 | (v & 1);\n\t\t\t\tv = v >> 1;\n\t\t\t}\n\t\t}\n\n\t\tp = frame + width - 11;\n\t\tv = verinfo;\n\t\tfor(y = 0; y < 6; y++) {\n\t\t\tfor(x = 0; x < 3; x++) {\n\t\t\t\tp[x] = 0x88 | (v & 1);\n\t\t\t\tv = v >> 1;\n\t\t\t}\n\t\t\tp += width;\n\t\t}\n\t}\n\t/* and a little bit... */\n\tframe[width * (width - 8) + 8] = 0x81;\n\n\treturn frame;\n}\n\nunsigned char *QRspec_newFrame(int version)\n{\n\tif(version < 1 || version > QRSPEC_VERSION_MAX) return NULL;\n\n\treturn QRspec_createFrame(version);\n}\n"
        },
        {
          "name": "qrspec.h",
          "type": "blob",
          "size": 5.8515625,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * QR Code specification in convenient format.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef QRSPEC_H\n#define QRSPEC_H\n\n#include \"qrencode.h\"\n\n/******************************************************************************\n * Version and capacity\n *****************************************************************************/\n\n/**\n * Maximum width of a symbol\n */\n#define QRSPEC_WIDTH_MAX 177\n\n/**\n * Return maximum data code length (bytes) for the version.\n * @param version version of the symbol\n * @param level error correction level\n * @return maximum size (bytes)\n */\nextern int QRspec_getDataLength(int version, QRecLevel level);\n\n/**\n * Return maximum error correction code length (bytes) for the version.\n * @param version version of the symbol\n * @param level error correction level\n * @return ECC size (bytes)\n */\nextern int QRspec_getECCLength(int version, QRecLevel level);\n\n/**\n * Return a version number that satisfies the input code length.\n * @param size input code length (byte)\n * @param level error correction level\n * @return version number\n */\nextern int QRspec_getMinimumVersion(int size, QRecLevel level);\n\n/**\n * Return the width of the symbol for the version.\n * @param version vesion of the symbol\n * @return width of the symbol\n */\nextern int QRspec_getWidth(int version);\n\n/**\n * Return the numer of remainder bits.\n * @param version vesion of the symbol\n * @return number of remainder bits\n */\nextern int QRspec_getRemainder(int version);\n\n/******************************************************************************\n * Length indicator\n *****************************************************************************/\n\n/**\n * Return the size of length indicator for the mode and version.\n * @param mode encode mode\n * @param version vesion of the symbol\n * @return the size of the appropriate length indicator (bits).\n */\nextern int QRspec_lengthIndicator(QRencodeMode mode, int version);\n\n/**\n * Return the maximum length for the mode and version.\n * @param mode encode mode\n * @param version vesion of the symbol\n * @return the maximum length (bytes)\n */\nextern int QRspec_maximumWords(QRencodeMode mode, int version);\n\n/******************************************************************************\n * Error correction code\n *****************************************************************************/\n\n/**\n * Return an array of ECC specification.\n * @param version version of the symbol\n * @param level error correction level\n * @param spec an array of ECC specification contains as following:\n * {# of type1 blocks, # of data code, # of ecc code,\n *  # of type2 blocks, # of data code}\n */\nvoid QRspec_getEccSpec(int version, QRecLevel level, int spec[5]);\n\n#define QRspec_rsBlockNum(__spec__) (__spec__[0] + __spec__[3])\n#define QRspec_rsBlockNum1(__spec__) (__spec__[0])\n#define QRspec_rsDataCodes1(__spec__) (__spec__[1])\n#define QRspec_rsEccCodes1(__spec__) (__spec__[2])\n#define QRspec_rsBlockNum2(__spec__) (__spec__[3])\n#define QRspec_rsDataCodes2(__spec__) (__spec__[4])\n#define QRspec_rsEccCodes2(__spec__) (__spec__[2])\n\n#define QRspec_rsDataLength(__spec__) \\\n\t((QRspec_rsBlockNum1(__spec__) * QRspec_rsDataCodes1(__spec__)) + \\\n\t (QRspec_rsBlockNum2(__spec__) * QRspec_rsDataCodes2(__spec__)))\n#define QRspec_rsEccLength(__spec__) \\\n\t(QRspec_rsBlockNum(__spec__) * QRspec_rsEccCodes1(__spec__))\n\n/******************************************************************************\n * Version information pattern\n *****************************************************************************/\n\n/**\n * Return BCH encoded version information pattern that is used for the symbol\n * of version 7 or greater. Use lower 18 bits.\n * @param version version of the symbol\n * @return BCH encoded version information pattern\n */\nextern unsigned int QRspec_getVersionPattern(int version);\n\n/******************************************************************************\n * Format information\n *****************************************************************************/\n\n/**\n * Return BCH encoded format information pattern.\n * @param mask mask number\n * @param level error correction level\n * @return BCH encoded format information pattern\n */\nextern unsigned int QRspec_getFormatInfo(int mask, QRecLevel level);\n\n/******************************************************************************\n * Frame\n *****************************************************************************/\n\n/**\n * Return a copy of initialized frame.\n * @param version version of the symbol\n * @return Array of unsigned char. You can free it by free().\n */\nextern unsigned char *QRspec_newFrame(int version);\n\n/******************************************************************************\n * Mode indicator\n *****************************************************************************/\n\n/**\n * Mode indicator. See Table 2 of JIS X0510:2004, pp.16.\n */\n#define QRSPEC_MODEID_ECI        7\n#define QRSPEC_MODEID_NUM        1\n#define QRSPEC_MODEID_AN         2\n#define QRSPEC_MODEID_8          4\n#define QRSPEC_MODEID_KANJI      8\n#define QRSPEC_MODEID_FNC1FIRST  5\n#define QRSPEC_MODEID_FNC1SECOND 9\n#define QRSPEC_MODEID_STRUCTURE  3\n#define QRSPEC_MODEID_TERMINATOR 0\n\n#endif /* QRSPEC_H */\n"
        },
        {
          "name": "rsecc.c",
          "type": "blob",
          "size": 3.8095703125,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Reed solomon error correction code encoder specialized for QR code.\n * This code is rewritten by Kentaro Fukuchi, referring to the FEC library\n * developed by Phil Karn (KA9Q).\n *\n * Copyright (C) 2002, 2003, 2004, 2006 Phil Karn, KA9Q\n * Copyright (C) 2014-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#if HAVE_LIBPTHREAD\n#include <pthread.h>\n#endif\n\n#include \"rsecc.h\"\n\n#if HAVE_LIBPTHREAD\nstatic pthread_mutex_t RSECC_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\nstatic int initialized = 0;\n\n#define SYMBOL_SIZE (8)\n#define symbols ((1U << SYMBOL_SIZE) - 1)\nstatic const unsigned int proot = 0x11d; /* stands for x^8+x^4+x^3+x^2+1 (see pp.37 of JIS X0510:2004) */\n\n/* min/max codeword length of ECC, calculated from the specification. */\n#define min_length (2)\n#define max_length (30)\n#define max_generatorSize (max_length)\n\nstatic unsigned char alpha[symbols + 1];\nstatic unsigned char aindex[symbols + 1];\nstatic unsigned char generator[max_length - min_length + 1][max_generatorSize + 1];\nstatic unsigned char generatorInitialized[max_length - min_length + 1];\n\nstatic void RSECC_initLookupTable(void)\n{\n\tunsigned int i, b;\n\n\talpha[symbols] = 0;\n\taindex[0] = symbols;\n\n\tb = 1;\n\tfor(i = 0; i < symbols; i++) {\n\t\talpha[i] = b;\n\t\taindex[b] = i;\n\t\tb <<= 1;\n\t\tif(b & (symbols + 1)) {\n\t\t\tb ^= proot;\n\t\t}\n\t\tb &= symbols;\n\t}\n}\n\nstatic void RSECC_init(void)\n{\n\tRSECC_initLookupTable();\n\tmemset(generatorInitialized, 0, (max_length - min_length + 1));\n\tinitialized = 1;\n}\n\nstatic void generator_init(size_t length)\n{\n\tsize_t i, j;\n\tint g[max_generatorSize + 1];\n\n\tg[0] = 1;\n\tfor(i = 0; i < length; i++) {\n\t\tg[i + 1] = 1;\n\t\t/* Because g[0] never be zero, skipped some conditional checks. */\n\t\tfor(j = i; j > 0; j--) {\n\t\t\tg[j] = g[j - 1] ^  alpha[(aindex[g[j]] + i) % symbols];\n\t\t}\n\t\tg[0] = alpha[(aindex[g[0]] + i) % symbols];\n\t}\n\n\tfor(i = 0; i <= length; i++) {\n\t\tgenerator[length - min_length][i] = aindex[g[i]];\n\t}\n\n\tgeneratorInitialized[length - min_length] = 1;\n}\n\nint RSECC_encode(size_t data_length, size_t ecc_length, const unsigned char *data, unsigned char *ecc)\n{\n\tsize_t i, j;\n\tunsigned char feedback;\n\tunsigned char *gen;\n\n#if HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&RSECC_mutex);\n#endif\n\tif(!initialized) {\n\t\tRSECC_init();\n\t}\n#if HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&RSECC_mutex);\n#endif\n\n\tif(ecc_length > max_length) return -1;\n\n\tmemset(ecc, 0, ecc_length);\n#if HAVE_LIBPTHREAD\n\tpthread_mutex_lock(&RSECC_mutex);\n#endif\n\tif(!generatorInitialized[ecc_length - min_length]) generator_init(ecc_length);\n#if HAVE_LIBPTHREAD\n\tpthread_mutex_unlock(&RSECC_mutex);\n#endif\n\tgen = generator[ecc_length - min_length];\n\n\tfor(i = 0; i < data_length; i++) {\n\t\tfeedback = aindex[data[i] ^ ecc[0]];\n\t\tif(feedback != symbols) {\n\t\t\tfor(j = 1; j < ecc_length; j++) {\n\t\t\t\tecc[j] ^= alpha[(unsigned int)(feedback + gen[ecc_length - j]) % symbols];\n\t\t\t}\n\t\t}\n\t\tmemmove(&ecc[0], &ecc[1], ecc_length - 1);\n\t\tif(feedback != symbols) {\n\t\t\tecc[ecc_length - 1] = alpha[(unsigned int)(feedback + gen[0]) % symbols];\n\t\t} else {\n\t\t\tecc[ecc_length - 1] = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
        },
        {
          "name": "rsecc.h",
          "type": "blob",
          "size": 1.2021484375,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Reed solomon error correction code encoder specialized for QR code.\n * This code is rewritten by Kentaro Fukuchi, referring to the FEC library\n * developed by Phil Karn (KA9Q).\n *\n * Copyright (C) 2002, 2003, 2004, 2006 Phil Karn, KA9Q\n * Copyright (C) 2014-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef RSECC_H\n#define RSECC_H\n\nextern int RSECC_encode(size_t data_length, size_t ecc_length, const unsigned char *data, unsigned char *ecc);\n\n#endif /* RSECC_H */\n"
        },
        {
          "name": "split.c",
          "type": "blob",
          "size": 7.44921875,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Input data splitter.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#if HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include \"qrencode.h\"\n#include \"qrinput.h\"\n#include \"qrspec.h\"\n#include \"split.h\"\n\n#define isdigit(__c__) ((unsigned char)((signed char)(__c__) - '0') < 10)\n#define isalnum(__c__) (QRinput_lookAnTable(__c__) >= 0)\n\n#if !HAVE_STRDUP\n#undef strdup\nchar *strdup(const char *s)\n{\n\tsize_t len = strlen(s) + 1;\n\tvoid *newstring = malloc(len);\n\tif(newstring == NULL) return NULL;\n\treturn (char *)memcpy(newstring, s, len);\n}\n#endif\n\nstatic QRencodeMode Split_identifyMode(const char *string, QRencodeMode hint)\n{\n\tunsigned char c, d;\n\tunsigned int word;\n\n\tc = (unsigned char)string[0];\n\n\tif(c == '\\0') return QR_MODE_NUL;\n\tif(isdigit(c)) {\n\t\treturn QR_MODE_NUM;\n\t} else if(isalnum(c)) {\n\t\treturn QR_MODE_AN;\n\t} else if(hint == QR_MODE_KANJI) {\n\t\td = (unsigned char)string[1];\n\t\tif(d != '\\0') {\n\t\t\tword = ((unsigned int)c << 8) | d;\n\t\t\tif((word >= 0x8140 && word <= 0x9ffc) || (word >= 0xe040 && word <= 0xebbf)) {\n\t\t\t\treturn QR_MODE_KANJI;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn QR_MODE_8;\n}\n\nstatic int Split_eatAn(const char *string, QRinput *input, QRencodeMode hint);\nstatic int Split_eat8(const char *string, QRinput *input, QRencodeMode hint);\n\nstatic int Split_eatNum(const char *string, QRinput *input,QRencodeMode hint)\n{\n\tconst char *p;\n\tint ret;\n\tint run;\n\tint dif;\n\tint ln;\n\tQRencodeMode mode;\n\n\tln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);\n\n\tp = string;\n\twhile(isdigit(*p)) {\n\t\tp++;\n\t}\n\trun = (int)(p - string);\n\tmode = Split_identifyMode(p, hint);\n\tif(mode == QR_MODE_8) {\n\t\tdif = QRinput_estimateBitsModeNum(run) + 4 + ln\n\t\t\t+ QRinput_estimateBitsMode8(1) /* + 4 + l8 */\n\t\t\t- QRinput_estimateBitsMode8(run + 1) /* - 4 - l8 */;\n\t\tif(dif > 0) {\n\t\t\treturn Split_eat8(string, input, hint);\n\t\t}\n\t}\n\tif(mode == QR_MODE_AN) {\n\t\tdif = QRinput_estimateBitsModeNum(run) + 4 + ln\n\t\t\t+ QRinput_estimateBitsModeAn(1) /* + 4 + la */\n\t\t\t- QRinput_estimateBitsModeAn(run + 1) /* - 4 - la */;\n\t\tif(dif > 0) {\n\t\t\treturn Split_eatAn(string, input, hint);\n\t\t}\n\t}\n\n\tret = QRinput_append(input, QR_MODE_NUM, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_eatAn(const char *string, QRinput *input, QRencodeMode hint)\n{\n\tconst char *p, *q;\n\tint ret;\n\tint run;\n\tint dif;\n\tint la, ln;\n\n\tla = QRspec_lengthIndicator(QR_MODE_AN, input->version);\n\tln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);\n\n\tp = string;\n\twhile(isalnum(*p)) {\n\t\tif(isdigit(*p)) {\n\t\t\tq = p;\n\t\t\twhile(isdigit(*q)) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tdif = QRinput_estimateBitsModeAn((int)(p - string)) /* + 4 + la */\n\t\t\t\t+ QRinput_estimateBitsModeNum((int)(q - p)) + 4 + ln\n\t\t\t\t+ (isalnum(*q)?(4 + ln):0)\n\t\t\t\t- QRinput_estimateBitsModeAn((int)(q - string)) /* - 4 - la */;\n\t\t\tif(dif < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = q;\n\t\t} else {\n\t\t\tp++;\n\t\t}\n\t}\n\n\trun = (int)(p - string);\n\n\tif(*p && !isalnum(*p)) {\n\t\tdif = QRinput_estimateBitsModeAn(run) + 4 + la\n\t\t\t+ QRinput_estimateBitsMode8(1) /* + 4 + l8 */\n\t\t\t- QRinput_estimateBitsMode8(run + 1) /* - 4 - l8 */;\n\t\tif(dif > 0) {\n\t\t\treturn Split_eat8(string, input, hint);\n\t\t}\n\t}\n\n\tret = QRinput_append(input, QR_MODE_AN, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_eatKanji(const char *string, QRinput *input, QRencodeMode hint)\n{\n\tconst char *p;\n\tint ret;\n\tint run;\n\n\tp = string;\n\twhile(Split_identifyMode(p, hint) == QR_MODE_KANJI) {\n\t\tp += 2;\n\t}\n\trun = (int)(p - string);\n\tret = QRinput_append(input, QR_MODE_KANJI, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_eat8(const char *string, QRinput *input, QRencodeMode hint)\n{\n\tconst char *p, *q;\n\tQRencodeMode mode;\n\tint ret;\n\tint run;\n\tint dif;\n\tint la, ln, l8;\n\tint swcost;\n\n\tla = QRspec_lengthIndicator(QR_MODE_AN, input->version);\n\tln = QRspec_lengthIndicator(QR_MODE_NUM, input->version);\n\tl8 = QRspec_lengthIndicator(QR_MODE_8, input->version);\n\n\tp = string + 1;\n\twhile(*p != '\\0') {\n\t\tmode = Split_identifyMode(p, hint);\n\t\tif(mode == QR_MODE_KANJI) {\n\t\t\tbreak;\n\t\t}\n\t\tif(mode == QR_MODE_NUM) {\n\t\t\tq = p;\n\t\t\twhile(isdigit(*q)) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif(Split_identifyMode(q, hint) == QR_MODE_8) {\n\t\t\t\tswcost = 4 + l8;\n\t\t\t} else {\n\t\t\t\tswcost = 0;\n\t\t\t}\n\t\t\tdif = QRinput_estimateBitsMode8((int)(p - string)) /* + 4 + l8 */\n\t\t\t\t+ QRinput_estimateBitsModeNum((int)(q - p)) + 4 + ln\n\t\t\t\t+ swcost\n\t\t\t\t- QRinput_estimateBitsMode8((int)(q - string)) /* - 4 - l8 */;\n\t\t\tif(dif < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = q;\n\t\t} else if(mode == QR_MODE_AN) {\n\t\t\tq = p;\n\t\t\twhile(isalnum(*q)) {\n\t\t\t\tq++;\n\t\t\t}\n\t\t\tif(Split_identifyMode(q, hint) == QR_MODE_8) {\n\t\t\t\tswcost = 4 + l8;\n\t\t\t} else {\n\t\t\t\tswcost = 0;\n\t\t\t}\n\t\t\tdif = QRinput_estimateBitsMode8((int)(p - string)) /* + 4 + l8 */\n\t\t\t\t+ QRinput_estimateBitsModeAn((int)(q - p)) + 4 + la\n\t\t\t\t+ swcost\n\t\t\t\t- QRinput_estimateBitsMode8((int)(q - string)) /* - 4 - l8 */;\n\t\t\tif(dif < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = q;\n\t\t} else {\n\t\t\tp++;\n\t\t}\n\t}\n\n\trun = (int)(p - string);\n\tret = QRinput_append(input, QR_MODE_8, run, (unsigned char *)string);\n\tif(ret < 0) return -1;\n\n\treturn run;\n}\n\nstatic int Split_splitString(const char *string, QRinput *input,\n\t\tQRencodeMode hint)\n{\n\tint length;\n\tQRencodeMode mode;\n\n\twhile(*string != '\\0') {\n\t\tmode = Split_identifyMode(string, hint);\n\t\tif(mode == QR_MODE_NUM) {\n\t\t\tlength = Split_eatNum(string, input, hint);\n\t\t} else if(mode == QR_MODE_AN) {\n\t\t\tlength = Split_eatAn(string, input, hint);\n\t\t} else if(mode == QR_MODE_KANJI && hint == QR_MODE_KANJI) {\n\t\t\tlength = Split_eatKanji(string, input, hint);\n\t\t} else {\n\t\t\tlength = Split_eat8(string, input, hint);\n\t\t}\n\t\tif(length == 0) break;\n\t\tif(length < 0) return -1;\n\t\tstring += length;\n\t}\n\n\treturn 0;\n}\n\nstatic char *dupAndToUpper(const char *str, QRencodeMode hint)\n{\n\tchar *newstr, *p;\n\tQRencodeMode mode;\n\n\tnewstr = strdup(str);\n\tif(newstr == NULL) return NULL;\n\n\tp = newstr;\n\twhile(*p != '\\0') {\n\t\tmode = Split_identifyMode(p, hint);\n\t\tif(mode == QR_MODE_KANJI) {\n\t\t\tp += 2;\n\t\t} else {\n\t\t\tif (*p >= 'a' && *p <= 'z') {\n\t\t\t\t*p = (char)((int)*p - 32);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n\n\treturn newstr;\n}\n\nint Split_splitStringToQRinput(const char *string, QRinput *input,\n\t\tQRencodeMode hint, int casesensitive)\n{\n\tchar *newstr;\n\tint ret;\n\n\tif(string == NULL || *string == '\\0') {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif(!casesensitive) {\n\t\tnewstr = dupAndToUpper(string, hint);\n\t\tif(newstr == NULL) return -1;\n\t\tret = Split_splitString(newstr, input, hint);\n\t\tfree(newstr);\n\t} else {\n\t\tret = Split_splitString(string, input, hint);\n\t}\n\n\treturn ret;\n}\n"
        },
        {
          "name": "split.h",
          "type": "blob",
          "size": 1.85546875,
          "content": "/*\n * qrencode - QR Code encoder\n *\n * Input data splitter.\n * Copyright (C) 2006-2017 Kentaro Fukuchi <kentaro@fukuchi.org>\n *\n * The following data / specifications are taken from\n * \"Two dimensional symbol -- QR-code -- Basic Specification\" (JIS X0510:2004)\n *  or\n * \"Automatic identification and data capture techniques --\n *  QR Code 2005 bar code symbology specification\" (ISO/IEC 18004:2006)\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#ifndef SPLIT_H\n#define SPLIT_H\n\n#include \"qrencode.h\"\n\n/**\n * Split the input string (null terminated) into QRinput.\n * @param string input string\n * @param hint give QR_MODE_KANJI if the input string contains Kanji character encoded in Shift-JIS. If not, give QR_MODE_8.\n * @param casesensitive 0 for case-insensitive encoding (all alphabet characters are replaced to UPPER-CASE CHARACTERS.\n * @retval 0 success.\n * @retval -1 an error occurred. errno is set to indicate the error. See\n *               Exceptions for the details.\n * @throw EINVAL invalid input object.\n * @throw ENOMEM unable to allocate memory for input objects.\n */\nextern int Split_splitStringToQRinput(const char *string, QRinput *input,\n\t\tQRencodeMode hint, int casesensitive);\n\n#endif /* SPLIT_H */\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "use",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}