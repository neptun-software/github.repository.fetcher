{
  "metadata": {
    "timestamp": 1736710037229,
    "page": 647,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "TrungNguyen1909/qemu-t8030",
      "stars": 2012,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".cirrus.yml",
          "type": "blob",
          "size": 4.46484375,
          "content": "env:\n  CIRRUS_CLONE_DEPTH: 1\n\nwindows_msys2_task:\n  timeout_in: 90m\n  windows_container:\n    image: cirrusci/windowsservercore:2019\n    os_version: 2019\n    cpu: 8\n    memory: 8G\n  env:\n    CIRRUS_SHELL: powershell\n    MSYS: winsymlinks:native\n    MSYSTEM: MINGW64\n    MSYS2_URL: https://github.com/msys2/msys2-installer/releases/download/2022-06-03/msys2-base-x86_64-20220603.sfx.exe\n    MSYS2_FINGERPRINT: 0\n    MSYS2_PACKAGES: \"\n      diffutils git grep make pkg-config sed\n      mingw-w64-x86_64-python\n      mingw-w64-x86_64-python-sphinx\n      mingw-w64-x86_64-toolchain\n      mingw-w64-x86_64-SDL2\n      mingw-w64-x86_64-SDL2_image\n      mingw-w64-x86_64-gtk3\n      mingw-w64-x86_64-glib2\n      mingw-w64-x86_64-ninja\n      mingw-w64-x86_64-jemalloc\n      mingw-w64-x86_64-lzo2\n      mingw-w64-x86_64-zstd\n      mingw-w64-x86_64-libjpeg-turbo\n      mingw-w64-x86_64-pixman\n      mingw-w64-x86_64-libgcrypt\n      mingw-w64-x86_64-libpng\n      mingw-w64-x86_64-libssh\n      mingw-w64-x86_64-snappy\n      mingw-w64-x86_64-libusb\n      mingw-w64-x86_64-usbredir\n      mingw-w64-x86_64-libtasn1\n      mingw-w64-x86_64-nettle\n      mingw-w64-x86_64-cyrus-sasl\n      mingw-w64-x86_64-curl\n      mingw-w64-x86_64-gnutls\n      mingw-w64-x86_64-libnfs\n    \"\n    CHERE_INVOKING: 1\n  msys2_cache:\n    folder: C:\\tools\\archive\n    reupload_on_changes: false\n    # These env variables are used to generate fingerprint to trigger the cache procedure\n    # If wanna to force re-populate msys2, increase MSYS2_FINGERPRINT\n    fingerprint_script:\n      - |\n        echo $env:CIRRUS_TASK_NAME\n        echo $env:MSYS2_URL\n        echo $env:MSYS2_FINGERPRINT\n        echo $env:MSYS2_PACKAGES\n    populate_script:\n      - |\n        md -Force C:\\tools\\archive\\pkg\n        $start_time = Get-Date\n        bitsadmin /transfer msys_download /dynamic /download /priority FOREGROUND $env:MSYS2_URL C:\\tools\\archive\\base.exe\n        Write-Output \"Download time taken: $((Get-Date).Subtract($start_time))\"\n        cd C:\\tools\n        C:\\tools\\archive\\base.exe -y\n        del -Force C:\\tools\\archive\\base.exe\n        Write-Output \"Base install time taken: $((Get-Date).Subtract($start_time))\"\n        $start_time = Get-Date\n\n        ((Get-Content -path C:\\tools\\msys64\\etc\\\\post-install\\\\07-pacman-key.post -Raw) -replace '--refresh-keys', '--version') | Set-Content -Path C:\\tools\\msys64\\etc\\\\post-install\\\\07-pacman-key.post\n        C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"sed -i 's/^CheckSpace/#CheckSpace/g' /etc/pacman.conf\"\n        C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"export\"\n        C:\\tools\\msys64\\usr\\bin\\pacman.exe --noconfirm -Sy\n        echo Y | C:\\tools\\msys64\\usr\\bin\\pacman.exe --noconfirm -Suu --overwrite=*\n        taskkill /F /FI \"MODULES eq msys-2.0.dll\"\n        tasklist\n        C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"mv -f /etc/pacman.conf.pacnew /etc/pacman.conf || true\"\n        C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"pacman --noconfirm -Syuu --overwrite=*\"\n        Write-Output \"Core install time taken: $((Get-Date).Subtract($start_time))\"\n        $start_time = Get-Date\n\n        C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"pacman --noconfirm -S --needed $env:MSYS2_PACKAGES\"\n        Write-Output \"Package install time taken: $((Get-Date).Subtract($start_time))\"\n        $start_time = Get-Date\n\n        del -Force -ErrorAction SilentlyContinue C:\\tools\\msys64\\etc\\mtab\n        del -Force -ErrorAction SilentlyContinue C:\\tools\\msys64\\dev\\fd\n        del -Force -ErrorAction SilentlyContinue C:\\tools\\msys64\\dev\\stderr\n        del -Force -ErrorAction SilentlyContinue C:\\tools\\msys64\\dev\\stdin\n        del -Force -ErrorAction SilentlyContinue C:\\tools\\msys64\\dev\\stdout\n        del -Force -Recurse -ErrorAction SilentlyContinue C:\\tools\\msys64\\var\\cache\\pacman\\pkg\n        tar cf C:\\tools\\archive\\msys64.tar -C C:\\tools\\ msys64\n\n        Write-Output \"Package archive time taken: $((Get-Date).Subtract($start_time))\"\n        del -Force -Recurse -ErrorAction SilentlyContinue c:\\tools\\msys64 \n  install_script:\n    - |\n      $start_time = Get-Date\n      cd C:\\tools\n      ls C:\\tools\\archive\\msys64.tar\n      tar xf C:\\tools\\archive\\msys64.tar\n      Write-Output \"Extract msys2 time taken: $((Get-Date).Subtract($start_time))\"\n  script:\n    - C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"mkdir build\"\n    - C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"cd build && ../configure --python=python3\"\n    - C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"cd build && make -j8\"\n    - exit $LastExitCode\n  test_script:\n    - C:\\tools\\msys64\\usr\\bin\\bash.exe -lc \"cd build && make V=1 check\"\n    - exit $LastExitCode\n"
        },
        {
          "name": ".dir-locals.el",
          "type": "blob",
          "size": 0.0732421875,
          "content": "((c-mode . ((c-file-style . \"stroustrup\")\n\t    (indent-tabs-mode . nil))))\n"
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.9287109375,
          "content": "# EditorConfig is a file format and collection of text editor plugins\n# for maintaining consistent coding styles between different editors\n# and IDEs. Most popular editors support this either natively or via\n# plugin.\n#\n# Check https://editorconfig.org for details.\n#\n# Emacs: you need https://github.com/10sr/editorconfig-custom-majormode-el\n# to automatically enable the appropriate major-mode for your files\n# that aren't already caught by your existing config.\n#\n\nroot = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\ncharset = utf-8\n\n[*.mak]\nindent_style = tab\nindent_size = 8\nemacs_mode = makefile\n\n[Makefile*]\nindent_style = tab\nindent_size = 8\nemacs_mode = makefile\n\n[*.{c,h,c.inc,h.inc}]\nindent_style = space\nindent_size = 4\nemacs_mode = c\n\n[*.sh]\nindent_style = space\nindent_size = 4\n\n[*.{s,S}]\nindent_style = tab\nindent_size = 8\nemacs_mode = asm\n\n[*.{vert,frag}]\nemacs_mode = glsl\n\n[*.json]\nindent_style = space\nemacs_mode = python\n"
        },
        {
          "name": ".exrc",
          "type": "blob",
          "size": 0.21484375,
          "content": "\"VIM settings to match QEMU coding style.  They are activated by adding the\n\"following settings (without the \" symbol) as last two lines in $HOME/.vimrc:\n\"set secure\n\"set exrc\nset expandtab\nset shiftwidth=4\nset smarttab\n"
        },
        {
          "name": ".gdbinit",
          "type": "blob",
          "size": 0.318359375,
          "content": "# GDB may have ./.gdbinit loading disabled by default.  In that case you can\n# follow the instructions it prints.  They boil down to adding the following to\n# your home directory's ~/.gdbinit file:\n#\n#   add-auto-load-safe-path /path/to/qemu/.gdbinit\n\n# Load QEMU-specific sub-commands and settings\nsource scripts/qemu-gdb.py\n"
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.09765625,
          "content": "*.c.inc         diff=c\n*.h.inc         diff=c\n*.m             diff=objc\n*.py            diff=python\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.14453125,
          "content": "/GNUmakefile\n/build/\n*.pyc\n.sdk\n.stgit-*\n.git-submodule-status\ncscope.*\ntags\nTAGS\nGPATH\nGRTAGS\nGTAGS\n*~\n*.ast_raw\n*.depend_raw\n*.swp\n*.patch\n*.gcov\n"
        },
        {
          "name": ".gitlab-ci.d",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitlab-ci.yml",
          "type": "blob",
          "size": 0.86328125,
          "content": "#\n# This is the GitLab CI configuration file for the mainstream QEMU\n# project: https://gitlab.com/qemu-project/qemu/-/pipelines\n#\n# !!! DO NOT ADD ANY NEW CONFIGURATION TO THIS FILE !!!\n#\n# Only documentation or comments is accepted.\n#\n# To use a different set of jobs than the mainstream QEMU project,\n# you need to set the location of your custom yml file at \"custom CI/CD\n# configuration path\", on your GitLab CI namespace:\n# https://docs.gitlab.com/ee/ci/pipelines/settings.html#custom-cicd-configuration-path\n#\n# ----------------------------------------------------------------------\n#\n# QEMU CI jobs are based on templates. Some templates provide\n# user-configurable options, modifiable via configuration variables.\n#\n# See https://qemu-project.gitlab.io/qemu/devel/ci.html#custom-ci-cd-variables\n# for more information.\n#\n\ninclude:\n  - local: '/.gitlab-ci.d/qemu-project.yml'\n"
        },
        {
          "name": ".gitlab",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 2.3720703125,
          "content": "[submodule \"roms/seabios\"]\n\tpath = roms/seabios\n\turl = https://gitlab.com/qemu-project/seabios.git/\n[submodule \"roms/SLOF\"]\n\tpath = roms/SLOF\n\turl = https://gitlab.com/qemu-project/SLOF.git\n[submodule \"roms/ipxe\"]\n\tpath = roms/ipxe\n\turl = https://gitlab.com/qemu-project/ipxe.git\n[submodule \"roms/openbios\"]\n\tpath = roms/openbios\n\turl = https://gitlab.com/qemu-project/openbios.git\n[submodule \"roms/qemu-palcode\"]\n\tpath = roms/qemu-palcode\n\turl = https://gitlab.com/qemu-project/qemu-palcode.git\n[submodule \"roms/sgabios\"]\n\tpath = roms/sgabios\n\turl = https://gitlab.com/qemu-project/sgabios.git\n[submodule \"dtc\"]\n\tpath = dtc\n\turl = https://gitlab.com/qemu-project/dtc.git\n[submodule \"roms/u-boot\"]\n\tpath = roms/u-boot\n\turl = https://gitlab.com/qemu-project/u-boot.git\n[submodule \"roms/skiboot\"]\n\tpath = roms/skiboot\n\turl = https://gitlab.com/qemu-project/skiboot.git\n[submodule \"roms/QemuMacDrivers\"]\n\tpath = roms/QemuMacDrivers\n\turl = https://gitlab.com/qemu-project/QemuMacDrivers.git\n[submodule \"ui/keycodemapdb\"]\n\tpath = ui/keycodemapdb\n\turl = https://gitlab.com/qemu-project/keycodemapdb.git\n[submodule \"roms/seabios-hppa\"]\n\tpath = roms/seabios-hppa\n\turl = https://gitlab.com/qemu-project/seabios-hppa.git\n[submodule \"roms/u-boot-sam460ex\"]\n\tpath = roms/u-boot-sam460ex\n\turl = https://gitlab.com/qemu-project/u-boot-sam460ex.git\n[submodule \"tests/fp/berkeley-testfloat-3\"]\n\tpath = tests/fp/berkeley-testfloat-3\n\turl = https://gitlab.com/qemu-project/berkeley-testfloat-3.git\n[submodule \"tests/fp/berkeley-softfloat-3\"]\n\tpath = tests/fp/berkeley-softfloat-3\n\turl = https://gitlab.com/qemu-project/berkeley-softfloat-3.git\n[submodule \"roms/edk2\"]\n\tpath = roms/edk2\n\turl = https://gitlab.com/qemu-project/edk2.git\n[submodule \"slirp\"]\n\tpath = slirp\n\turl = https://gitlab.com/qemu-project/libslirp.git\n[submodule \"roms/opensbi\"]\n\tpath = roms/opensbi\n\turl = \thttps://gitlab.com/qemu-project/opensbi.git\n[submodule \"roms/qboot\"]\n\tpath = roms/qboot\n\turl = https://gitlab.com/qemu-project/qboot.git\n[submodule \"meson\"]\n\tpath = meson\n\turl = https://gitlab.com/qemu-project/meson.git\n[submodule \"roms/vbootrom\"]\n\tpath = roms/vbootrom\n\turl = https://gitlab.com/qemu-project/vbootrom.git\n[submodule \"tests/lcitool/libvirt-ci\"]\n\tpath = tests/lcitool/libvirt-ci\n\turl = https://gitlab.com/libvirt/libvirt-ci.git\n[submodule \"subprojects/libvfio-user\"]\n\tpath = subprojects/libvfio-user\n\turl = https://gitlab.com/qemu-project/libvfio-user.git\n"
        },
        {
          "name": ".gitpublish",
          "type": "blob",
          "size": 1.611328125,
          "content": "#\n# Common git-publish profiles that can be used to send patches to QEMU upstream.\n#\n# See https://github.com/stefanha/git-publish for more information\n#\n[gitpublishprofile \"default\"]\nbase = master\nto = qemu-devel@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"rfc\"]\nbase = master\nprefix = RFC PATCH\nto = qemu-devel@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"stable\"]\nbase = master\nto = qemu-devel@nongnu.org\ncc = qemu-stable@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"trivial\"]\nbase = master\nto = qemu-devel@nongnu.org\ncc = qemu-trivial@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"block\"]\nbase = master\nto = qemu-devel@nongnu.org\ncc = qemu-block@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"arm\"]\nbase = master\nto = qemu-devel@nongnu.org\ncc = qemu-arm@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"s390\"]\nbase = master\nto = qemu-devel@nongnu.org\ncc = qemu-s390@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n\n[gitpublishprofile \"ppc\"]\nbase = master\nto = qemu-devel@nongnu.org\ncc = qemu-ppc@nongnu.org\ncccmd = scripts/get_maintainer.pl --noroles --norolestats --nogit --nogit-fallback 2>/dev/null\n"
        },
        {
          "name": ".mailmap",
          "type": "blob",
          "size": 8.9697265625,
          "content": "# This mailmap fixes up author names/addresses.\n#\n# If you are adding to this file consider if a similar change needs to\n# be made to contrib/gitdm/aliases. They are not however completely\n# analogous. .mailmap is concerned with fixing up damaged author\n# fields where as the gitdm equivalent is more concerned with making\n# sure multiple email addresses get mapped onto the same author.\n#\n# From man git-shortlog the forms are:\n#\n#  Proper Name <commit@email.xx>\n#  <proper@email.xx> <commit@email.xx>\n#  Proper Name <proper@email.xx> <commit@email.xx>\n#  Proper Name <proper@email.xx> Commit Name <commit@email.xx>\n#\n\n# The first section translates weird addresses from the original git import\n# into proper addresses so that they are counted properly by git shortlog.\nAndrzej Zaborowski <balrogg@gmail.com> balrog <balrog@c046a42c-6fe2-441c-8c8c-71466251a162>\nAnthony Liguori <anthony@codemonkey.ws> aliguori <aliguori@c046a42c-6fe2-441c-8c8c-71466251a162>\nAurelien Jarno <aurelien@aurel32.net> aurel32 <aurel32@c046a42c-6fe2-441c-8c8c-71466251a162>\nBlue Swirl <blauwirbel@gmail.com> blueswir1 <blueswir1@c046a42c-6fe2-441c-8c8c-71466251a162>\nEdgar E. Iglesias <edgar.iglesias@gmail.com> edgar_igl <edgar_igl@c046a42c-6fe2-441c-8c8c-71466251a162>\nFabrice Bellard <fabrice@bellard.org> bellard <bellard@c046a42c-6fe2-441c-8c8c-71466251a162>\nJocelyn Mayer <l_indien@magic.fr> j_mayer <j_mayer@c046a42c-6fe2-441c-8c8c-71466251a162>\nPaul Brook <paul@codesourcery.com> pbrook <pbrook@c046a42c-6fe2-441c-8c8c-71466251a162>\nThiemo Seufer <ths@networkno.de> ths <ths@c046a42c-6fe2-441c-8c8c-71466251a162>\nmalc <av1474@comtv.ru> malc <malc@c046a42c-6fe2-441c-8c8c-71466251a162>\n\n# Corrupted Author fields\nAaron Larson <alarson@ddci.com> alarson@ddci.com\nAndreas Färber <andreas.faerber@web.de> Andreas Färber <andreas.faerber>\nJason Wang <jasowang@redhat.com> Jason Wang <jasowang>\nMarek Dolata <mkdolata@us.ibm.com> mkdolata@us.ibm.com <mkdolata@us.ibm.com>\nMichael Ellerman <mpe@ellerman.id.au> michael@ozlabs.org <michael@ozlabs.org>\nNick Hudson <hnick@vmware.com> hnick@vmware.com <hnick@vmware.com>\n\n# There is also a:\n#    (no author) <(no author)@c046a42c-6fe2-441c-8c8c-71466251a162>\n# for the cvs2svn initialization commit e63c3dc74bf.\n\n# Next, translate a few commits where mailman rewrote the From: line due\n# to strict SPF, although we prefer to avoid adding more entries like that.\nEd Swierk <eswierk@skyportsystems.com> Ed Swierk via Qemu-devel <qemu-devel@nongnu.org>\nIan McKellar <ianloic@google.com> Ian McKellar via Qemu-devel <qemu-devel@nongnu.org>\nJulia Suvorova <jusual@mail.ru> Julia Suvorova via Qemu-devel <qemu-devel@nongnu.org>\nJustin Terry (VM) <juterry@microsoft.com> Justin Terry (VM) via Qemu-devel <qemu-devel@nongnu.org>\n\n# Next, replace old addresses by a more recent one.\nAleksandar Markovic <aleksandar.qemu.devel@gmail.com> <aleksandar.markovic@mips.com>\nAleksandar Markovic <aleksandar.qemu.devel@gmail.com> <aleksandar.markovic@imgtec.com>\nAleksandar Markovic <aleksandar.qemu.devel@gmail.com> <amarkovic@wavecomp.com>\nAleksandar Rikalo <aleksandar.rikalo@syrmia.com> <arikalo@wavecomp.com>\nAleksandar Rikalo <aleksandar.rikalo@syrmia.com> <aleksandar.rikalo@rt-rk.com>\nAlexander Graf <agraf@csgraf.de> <agraf@suse.de>\nAnthony Liguori <anthony@codemonkey.ws> Anthony Liguori <aliguori@us.ibm.com>\nChristian Borntraeger <borntraeger@linux.ibm.com> <borntraeger@de.ibm.com>\nFilip Bozuta <filip.bozuta@syrmia.com> <filip.bozuta@rt-rk.com.com>\nFrederic Konrad <konrad.frederic@yahoo.fr> <fred.konrad@greensocs.com>\nFrederic Konrad <konrad.frederic@yahoo.fr> <konrad@adacore.com>\nGreg Kurz <groug@kaod.org> <gkurz@linux.vnet.ibm.com>\nHuacai Chen <chenhuacai@kernel.org> <chenhc@lemote.com>\nHuacai Chen <chenhuacai@kernel.org> <chenhuacai@loongson.cn>\nJames Hogan <jhogan@kernel.org> <james.hogan@imgtec.com>\nLeif Lindholm <quic_llindhol@quicinc.com> <leif.lindholm@linaro.org>\nLeif Lindholm <quic_llindhol@quicinc.com> <leif@nuviainc.com>\nRadoslaw Biernacki <rad@semihalf.com> <radoslaw.biernacki@linaro.org>\nPaul Burton <paulburton@kernel.org> <paul.burton@mips.com>\nPaul Burton <paulburton@kernel.org> <paul.burton@imgtec.com>\nPaul Burton <paulburton@kernel.org> <paul@archlinuxmips.org>\nPaul Burton <paulburton@kernel.org> <pburton@wavecomp.com>\nPhilippe Mathieu-Daudé <f4bug@amsat.org> <philmd@redhat.com>\nStefan Brankovic <stefan.brankovic@syrmia.com> <stefan.brankovic@rt-rk.com.com>\nYongbok Kim <yongbok.kim@mips.com> <yongbok.kim@imgtec.com>\n\n# Also list preferred name forms where people have changed their\n# git author config, or had utf8/latin1 encoding issues.\nAaron Lindsay <aaron@os.amperecomputing.com>\nAaron Larson <alarson@ddci.com>\nAlexey Gerasimenko <x1917x@gmail.com>\nAlex Chen <alex.chen@huawei.com>\nAlex Ivanov <void@aleksoft.net>\nAndreas Färber <afaerber@suse.de>\nBandan Das <bsd@redhat.com>\nBenjamin MARSILI <mlspirat42@gmail.com>\nBenoît Canet <benoit.canet@gmail.com>\nBenoît Canet <benoit.canet@irqsave.net>\nBenoît Canet <benoit.canet@nodalink.com>\nBoqun Feng <boqun.feng@gmail.com>\nBoqun Feng <boqun.feng@intel.com>\nBrad Smith <brad@comstyle.com>\nBrijesh Singh <brijesh.singh@amd.com>\nBrilly Wu <brillywu@viatech.com.cn>\nCédric Vincent <cedric.vincent@st.com>\nCheneyLin <linzc@zju.edu.cn>\nChen Gang <chengang@emindsoft.com.cn>\nChen Gang <gang.chen.5i5j@gmail.com>\nChen Gang <gang.chen@sunrus.com.cn>\nChen Wei-Ren <chenwj@iis.sinica.edu.tw>\nChristophe Lyon <christophe.lyon@st.com>\nCollin L. Walling <walling@linux.ibm.com>\nDaniel P. Berrangé <berrange@redhat.com>\nEduardo Otubo <otubo@redhat.com>\nErik Smit <erik.lucas.smit@gmail.com>\nFabrice Desclaux <fabrice.desclaux@cea.fr>\nFernando Luis Vázquez Cao <fernando_b1@lab.ntt.co.jp>\nFernando Luis Vázquez Cao <fernando@oss.ntt.co.jp>\nGautham R. Shenoy <ego@in.ibm.com>\nGautham R. Shenoy <ego@linux.vnet.ibm.com>\nGonglei (Arei) <arei.gonglei@huawei.com>\nGuang Wang <wang.guang55@zte.com.cn>\nHaibin Zhang <haibinzhang@tencent.com>\nHailiang Zhang <zhang.zhanghailiang@huawei.com>\nHanna Reitz <hreitz@redhat.com> <mreitz@redhat.com>\nHervé Poussineau <hpoussin@reactos.org>\nHyman Huang <huangy81@chinatelecom.cn>\nJakub Jermář <jakub@jermar.eu>\nJakub Jermář <jakub.jermar@kernkonzept.com>\nJean-Christophe Dubois <jcd@tribudubois.net>\nJindřich Makovička <makovick@gmail.com>\nJohn Arbuckle <programmingkidx@gmail.com>\nJuha Riihimäki <juha.riihimaki@nokia.com>\nJuha Riihimäki <Juha.Riihimaki@nokia.com>\nJun Li <junmuzi@gmail.com>\nLaurent Vivier <Laurent@lvivier.info>\nLeandro Lupori <leandro.lupori@gmail.com>\nLi Guang <lig.fnst@cn.fujitsu.com>\nLiming Wang <walimisdev@gmail.com>\nlinzhecheng <linzc@zju.edu.cn>\nLiran Schour <lirans@il.ibm.com>\nLiu Yu <yu.liu@freescale.com>\nLiu Yu <Yu.Liu@freescale.com>\nLi Zhang <zhlcindy@gmail.com>\nLi Zhang <zhlcindy@linux.vnet.ibm.com>\nLluís Vilanova <vilanova@ac.upc.edu>\nLluís Vilanova <xscript@gmx.net>\nLongpeng (Mike) <longpeng2@huawei.com>\nLuc Michel <luc.michel@git.antfield.fr>\nLuc Michel <luc.michel@greensocs.com>\nMarc Marí <marc.mari.barcelo@gmail.com>\nMarc Marí <markmb@redhat.com>\nMichael Avdienko <whitearchey@gmail.com>\nMichael S. Tsirkin <mst@redhat.com>\nMunkyu Im <munkyu.im@samsung.com>\nNicholas Bellinger <nab@linux-iscsi.org>\nNicholas Thomas <nick@bytemark.co.uk>\nNikunj A Dadhania <nikunj@linux.vnet.ibm.com>\nOrit Wasserman <owasserm@redhat.com>\nPaolo Bonzini <pbonzini@redhat.com>\nPan Nengyuan <pannengyuan@huawei.com>\nPavel Dovgaluk <dovgaluk@ispras.ru>\nPavel Dovgaluk <pavel.dovgaluk@gmail.com>\nPavel Dovgaluk <Pavel.Dovgaluk@ispras.ru>\nPeter Chubb <peter.chubb@nicta.com.au>\nPeter Crosthwaite <crosthwaite.peter@gmail.com>\nPeter Crosthwaite <peter.crosthwaite@petalogix.com>\nPeter Crosthwaite <peter.crosthwaite@xilinx.com>\nPrasad J Pandit <pjp@fedoraproject.org>\nPrasad J Pandit <ppandit@redhat.com>\nQiao Nuohan <qiaonuohan@cn.fujitsu.com>\nReimar Döffinger <Reimar.Doeffinger@gmx.de>\nRemy Noel <remy.noel@blade-group.com>\nRoger Pau Monné <roger.pau@citrix.com>\nShin'ichiro Kawasaki <kawasaki@juno.dti.ne.jp>\nShin'ichiro Kawasaki <shinichiro.kawasaki@wdc.com>\nSochin Jiang <sochin.jiang@huawei.com>\nStefan Berger <stefanb@linux.vnet.ibm.com> <stefanb@linux.ibm.com>\nTakashi Yoshii <takasi-y@ops.dti.ne.jp>\nThomas Huth <thuth@redhat.com>\nThomas Knych <thomaswk@google.com>\nTimothy Baldwin <T.E.Baldwin99@members.leeds.ac.uk>\nTony Nguyen <tony.nguyen@bt.com>\nVenkateswararao Jujjuri <jvrao@linux.vnet.ibm.com>\nVibi Sreenivasan <vibi_sreenivasan@cms.com>\nVijaya Kumar K <vijayak@cavium.com>\nVijaya Kumar K <Vijaya.Kumar@cavium.com>\nVijay Kumar <vijaykumar@bravegnu.org>\nVijay Kumar <vijaykumar@zilogic.com>\nWang Guang <wang.guang55@zte.com.cn>\nWenchao Xia <xiawenc@linux.vnet.ibm.com>\nWenshuang Ma <kevinnma@tencent.com>\nXiaoqiang Zhao <zxq_yx_007@163.com>\nXinhua Cao <caoxinhua@huawei.com>\nXiong Zhang <xiong.y.zhang@intel.com>\nYin Yin <yin.yin@cs2c.com.cn>\nYu-Chen Lin <npes87184@gmail.com>\nYu-Chen Lin <npes87184@gmail.com> <yuchenlin@synology.com>\nYunQiang Su <syq@debian.org>\nYunQiang Su <ysu@wavecomp.com>\nYuri Pudgorodskiy <yur@virtuozzo.com>\nZhengui Li <lizhengui@huawei.com>\nZhenwei Pi <pizhenwei@bytedance.com>\nZhenwei Pi <zhenwei.pi@youruncloud.com>\nZhuang Yanying <ann.zhuangyanying@huawei.com>\n"
        },
        {
          "name": ".patchew.yml",
          "type": "blob",
          "size": 8.259765625,
          "content": "---\n# Note: this file is still unused.  It serves as a documentation for the\n# Patchew configuration in case patchew.org disappears or has to be\n# reinstalled.\n#\n# Patchew configuration is available to project administrators at\n# https://patchew.org/api/v1/projects/1/config/ and can be configured\n# to YAML using the following Python script:\n#\n#     import json\n#     import sys\n#     import ruamel.yaml\n#\n#     json_str = sys.stdin.read()\n#     yaml = ruamel.yaml.YAML()\n#     yaml.explicit_start = True\n#     data = json.loads(json_str, object_pairs_hook=ruamel.yaml.comments.CommentedMap)\n#     ruamel.yaml.scalarstring.walk_tree(data)\n#     yaml.dump(data, sys.stdout)\n\nemail:\n  notifications:\n    timeouts:\n      event: TestingReport\n      enabled: true\n      to_user: false\n      reply_subject: true\n      set_reply_to: true\n      in_reply_to: true\n      reply_to_all: false\n      subject_template: none\n      to: fam@euphon.net\n      cc: ''\n      body_template: |\n        {% if not is_timeout %} {{ cancel }} {% endif %}\n\n        Test '{{ test }}' timeout, log:\n\n        {{ log }}\n    ENOSPC:\n      event: TestingReport\n      enabled: true\n      to_user: false\n      reply_subject: false\n      set_reply_to: false\n      in_reply_to: true\n      reply_to_all: false\n      subject_template: Out of space error\n      to: fam@euphon.net\n      cc: ''\n      body_template: |\n        {% if passed %}\n          {{ cancel }}\n        {% endif %}\n\n        {% if 'No space left on device' in log %}\n        Tester {{ tester }} out of space when running {{ test }}\n\n          {{ log }}\n        {% else %}\n          {{ cancel }}\n        {% endif %}\n    FailureShort:\n      event: TestingReport\n      enabled: true\n      to_user: false\n      reply_subject: true\n      set_reply_to: true\n      in_reply_to: true\n      reply_to_all: true\n      subject_template: Testing failed\n      to: ''\n      cc: ''\n      body_template: |\n        {% if passed or not obj.message_id or is_timeout %}\n          {{ cancel }}\n        {% endif %}\n        {% if 'No space left on device' in log %}\n          {{ cancel }}\n        {% endif %}\n        Patchew URL: https://patchew.org/QEMU/{{ obj.message_id }}/\n\n        {% ansi2text log as logtext %}\n        {% if test == \"checkpatch\" %}\n        Hi,\n\n        This series seems to have some coding style problems. See output below for\n        more information:\n\n        {{ logtext }}\n        {% elif test == \"docker-mingw@fedora\" or test == \"docker-quick@centos8\" or test == \"asan\" %}\n        Hi,\n\n        This series failed the {{ test }} build test. Please find the testing commands and\n        their output below. If you have Docker installed, you can probably reproduce it\n        locally.\n\n        {% lines_between logtext start=\"^=== TEST SCRIPT BEGIN ===$\" stop=\"^=== TEST SCRIPT END ===$\" %}\n        {% lines_between logtext start=\"^=== OUTPUT BEGIN ===$\" stop=\"=== OUTPUT END ===$\" as output %}\n        {% grep_C output regex=\"\\b(FAIL|XPASS|ERROR|WARN|error:|warning:)\" n=3 %}\n        {% elif test == \"s390x\" or test == \"FreeBSD\" or test == \"ppcle\" or test == \"ppcbe\" %}\n        Hi,\n\n        This series failed build test on {{test}} host. Please find the details below.\n\n        {% lines_between logtext start=\"^=== TEST SCRIPT BEGIN ===$\" stop=\"^=== TEST SCRIPT END ===$\" %}\n        {% lines_between logtext start=\"^=== OUTPUT BEGIN ===$\" stop=\"=== OUTPUT END ===$\" as output %}\n        {% grep_C output regex=\"\\b(FAIL|XPASS|ERROR|WARN|error:|warning:)\" n=3 %}\n        {% else %}\n        {{ cancel }}\n        {% endif %}\n\n        The full log is available at\n        {{ log_url }}.\n        ---\n        Email generated automatically by Patchew [https://patchew.org/].\n        Please send your feedback to patchew-devel@redhat.com\ntesting:\n  tests:\n    asan:\n      enabled: true\n      requirements: docker\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        time make docker-test-debug@fedora TARGET_LIST=x86_64-softmmu J=14 NETWORK=1\n    docker-quick@centos8:\n      enabled: false\n      requirements: docker,x86_64\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        time make docker-test-quick@centos8 SHOW_ENV=1 J=14 NETWORK=1\n    checkpatch:\n      enabled: true\n      requirements: ''\n      timeout: 600\n      script: |\n        #!/bin/bash\n        git rev-parse base > /dev/null || exit 0\n        ./scripts/checkpatch.pl --mailback base..\n    docker-mingw@fedora:\n      enabled: true\n      requirements: docker,x86_64\n      timeout: 3600\n      script: |\n        #! /bin/bash\n        test \"$(uname -m)\" = \"x86_64\"\n    ppcle:\n      enabled: false\n      requirements: ppcle\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        # Testing script will be invoked under the git checkout with\n        # HEAD pointing to a commit that has the patches applied on top of \"base\"\n        # branch\n        set -e\n        CC=$HOME/bin/cc\n        INSTALL=$PWD/install\n        BUILD=$PWD/build\n        mkdir -p $BUILD $INSTALL\n        SRC=$PWD\n        cd $BUILD\n        $SRC/configure --cc=$CC --prefix=$INSTALL\n        make -j4\n        # XXX: we need reliable clean up\n        # make check -j4 V=1\n        make install\n\n        echo\n        echo \"=== ENV ===\"\n        env\n\n        echo\n        echo \"=== PACKAGES ===\"\n        rpm -qa\n    ppcbe:\n      enabled: false\n      requirements: ppcbe\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        # Testing script will be invoked under the git checkout with\n        # HEAD pointing to a commit that has the patches applied on top of \"base\"\n        # branch\n        set -e\n        CC=$HOME/bin/cc\n        INSTALL=$PWD/install\n        BUILD=$PWD/build\n        mkdir -p $BUILD $INSTALL\n        SRC=$PWD\n        cd $BUILD\n        $SRC/configure --cc=$CC --prefix=$INSTALL\n        make -j4\n        # XXX: we need reliable clean up\n        # make check -j4 V=1\n        make install\n\n        echo\n        echo \"=== ENV ===\"\n        env\n\n        echo\n        echo \"=== PACKAGES ===\"\n        rpm -qa\n    FreeBSD:\n      enabled: true\n      requirements: qemu-x86,x86_64,git\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        # Testing script will be invoked under the git checkout with\n        # HEAD pointing to a commit that has the patches applied on top of \"base\"\n        # branch\n        if qemu-system-x86_64 --help >/dev/null 2>&1; then\n          QEMU=qemu-system-x86_64\n        elif /usr/libexec/qemu-kvm --help >/dev/null 2>&1; then\n          QEMU=/usr/libexec/qemu-kvm\n        else\n          exit 1\n        fi\n        make vm-build-freebsd J=21 QEMU=$QEMU\n        exit 0\n    docker-clang@ubuntu:\n      enabled: true\n      requirements: docker,x86_64\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        time make docker-test-clang@ubuntu SHOW_ENV=1 J=14 NETWORK=1\n    s390x:\n      enabled: true\n      requirements: s390x\n      timeout: 3600\n      script: |\n        #!/bin/bash\n        # Testing script will be invoked under the git checkout with\n        # HEAD pointing to a commit that has the patches applied on top of \"base\"\n        # branch\n        set -e\n        CC=$HOME/bin/cc\n        INSTALL=$PWD/install\n        BUILD=$PWD/build\n        mkdir -p $BUILD $INSTALL\n        SRC=$PWD\n        cd $BUILD\n        $SRC/configure --cc=$CC --prefix=$INSTALL\n        make -j4\n        # XXX: we need reliable clean up\n        # make check -j4 V=1\n        make install\n\n        echo\n        echo \"=== ENV ===\"\n        env\n\n        echo\n        echo \"=== PACKAGES ===\"\n        rpm -qa\n  requirements:\n    x86_64:\n      script: |\n        #! /bin/bash\n        test \"$(uname -m)\" = \"x86_64\"\n    qemu-x86:\n      script: |\n        #!/bin/bash\n        if qemu-system-x86_64 --help >/dev/null 2>&1; then\n          :\n        elif /usr/libexec/qemu-kvm --help >/dev/null 2>&1; then\n          :\n        else\n          exit 1\n        fi\n    ppcle:\n      script: |\n        #!/bin/bash\n        test \"$(uname -m)\" = \"ppc64le\"\n    ppcbe:\n      script: |\n        #!/bin/bash\n        test \"$(uname -m)\" = \"ppc64\"\n    git:\n      script: |\n        #! /bin/bash\n        git config user.name > /dev/null 2>&1\n    docker:\n      script: |\n        #!/bin/bash\n        docker ps || sudo -n docker ps\n    s390x:\n      script: |\n        #!/bin/bash\n        test \"$(uname -m)\" = \"s390x\"\ngit:\n  push_to: git@github.com:patchew-project/qemu\n  public_repo: https://github.com/patchew-project/qemu\n  url_template: https://github.com/patchew-project/qemu/tree/%t\n"
        },
        {
          "name": ".readthedocs.yml",
          "type": "blob",
          "size": 0.5302734375,
          "content": "# .readthedocs.yml\n# Read the Docs configuration file\n# See https://docs.readthedocs.io/en/stable/config-file/v2.html for details\n\n# Required\nversion: 2\n\n# Build documentation in the docs/ directory with Sphinx\nsphinx:\n  configuration: docs/conf.py\n\n# We want all the document formats\nformats: all\n\n# For consistency, we require that QEMU's Sphinx extensions\n# run with at least the same minimum version of Python that\n# we require for other Python in our codebase (our conf.py\n# enforces this, and some code needs it.)\npython:\n  version: 3.6\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 8.001953125,
          "content": "os: linux\ndist: focal\nlanguage: c\ncompiler:\n  - gcc\ncache:\n  # There is one cache per branch and compiler version.\n  # characteristics of each job are used to identify the cache:\n  # - OS name (currently only linux)\n  # - OS distribution (for Linux, bionic or focal)\n  # - Names and values of visible environment variables set in .travis.yml or Settings panel\n  timeout: 1200\n  ccache: true\n  pip: true\n  directories:\n  - $HOME/avocado/data/cache\n\n\naddons:\n  apt:\n    packages:\n      # Build dependencies\n      - libaio-dev\n      - libattr1-dev\n      - libbrlapi-dev\n      - libcap-ng-dev\n      - libcacard-dev\n      - libgcc-7-dev\n      - libgnutls28-dev\n      - libgtk-3-dev\n      - libiscsi-dev\n      - liblttng-ust-dev\n      - libncurses5-dev\n      - libnfs-dev\n      - libpixman-1-dev\n      - libpng-dev\n      - librados-dev\n      - libsdl2-dev\n      - libsdl2-image-dev\n      - libseccomp-dev\n      - libspice-protocol-dev\n      - libspice-server-dev\n      - libssh-dev\n      - liburcu-dev\n      - libusb-1.0-0-dev\n      - libvdeplug-dev\n      - libvte-2.91-dev\n      - libzstd-dev\n      - ninja-build\n      - sparse\n      - uuid-dev\n      # Tests dependencies\n      - genisoimage\n\n\n# The channel name \"irc.oftc.net#qemu\" is encrypted against qemu/qemu\n# to prevent IRC notifications from forks. This was created using:\n# $ travis encrypt -r \"qemu/qemu\" \"irc.oftc.net#qemu\"\nnotifications:\n  irc:\n    channels:\n      - secure: \"F7GDRgjuOo5IUyRLqSkmDL7kvdU4UcH3Lm/W2db2JnDHTGCqgEdaYEYKciyCLZ57vOTsTsOgesN8iUT7hNHBd1KWKjZe9KDTZWppWRYVwAwQMzVeSOsbbU4tRoJ6Pp+3qhH1Z0eGYR9ZgKYAoTumDFgSAYRp4IscKS8jkoedOqM=\"\n    on_success: change\n    on_failure: always\n\n\nenv:\n  global:\n    - SRC_DIR=\"..\"\n    - BUILD_DIR=\"build\"\n    - BASE_CONFIG=\"--disable-docs --disable-tools\"\n    - TEST_BUILD_CMD=\"\"\n    - TEST_CMD=\"make check V=1\"\n    # This is broadly a list of \"mainline\" softmmu targets which have support across the major distros\n    - MAIN_SOFTMMU_TARGETS=\"aarch64-softmmu,mips64-softmmu,ppc64-softmmu,riscv64-softmmu,s390x-softmmu,x86_64-softmmu\"\n    - CCACHE_SLOPPINESS=\"include_file_ctime,include_file_mtime\"\n    - CCACHE_MAXSIZE=1G\n    - G_MESSAGES_DEBUG=error\n\n\ngit:\n  # we want to do this ourselves\n  submodules: false\n\n# Common first phase for all steps\n# We no longer use nproc to calculate jobs:\n# https://travis-ci.community/t/nproc-reports-32-cores-on-arm64/5851\nbefore_install:\n  - if command -v ccache ; then ccache --zero-stats ; fi\n  - export JOBS=3\n  - echo \"=== Using ${JOBS} simultaneous jobs ===\"\n\n# Configure step - may be overridden\nbefore_script:\n  - mkdir -p ${BUILD_DIR} && cd ${BUILD_DIR}\n  - ${SRC_DIR}/configure ${BASE_CONFIG} ${CONFIG} || { cat config.log meson-logs/meson-log.txt && exit 1; }\n\n# Main build & test - rarely overridden - controlled by TEST_CMD\nscript:\n  - BUILD_RC=0 && make -j${JOBS} || BUILD_RC=$?\n  - |\n    if [ \"$BUILD_RC\" -eq 0 ] && [ -n \"$TEST_BUILD_CMD\" ]; then\n        ${TEST_BUILD_CMD} || BUILD_RC=$?\n    else\n        $(exit $BUILD_RC);\n    fi\n  - |\n    if [ \"$BUILD_RC\" -eq 0 ] ; then\n        ${TEST_CMD} ;\n    else\n        $(exit $BUILD_RC);\n    fi\nafter_script:\n  - df -h\n  - if command -v ccache ; then ccache --show-stats ; fi\n\n\njobs:\n  include:\n\n    - name: \"[aarch64] GCC check-tcg\"\n      arch: arm64\n      dist: focal\n      addons:\n        apt_packages:\n          - libaio-dev\n          - libattr1-dev\n          - libbrlapi-dev\n          - libcacard-dev\n          - libcap-ng-dev\n          - libgcrypt20-dev\n          - libgnutls28-dev\n          - libgtk-3-dev\n          - libiscsi-dev\n          - liblttng-ust-dev\n          - libncurses5-dev\n          - libnfs-dev\n          - libpixman-1-dev\n          - libpng-dev\n          - librados-dev\n          - libsdl2-dev\n          - libseccomp-dev\n          - liburcu-dev\n          - libusb-1.0-0-dev\n          - libvdeplug-dev\n          - libvte-2.91-dev\n          - ninja-build\n          # Tests dependencies\n          - genisoimage\n      env:\n        - TEST_CMD=\"make check check-tcg V=1\"\n        - CONFIG=\"--disable-containers --target-list=${MAIN_SOFTMMU_TARGETS} --cxx=/bin/false\"\n        - UNRELIABLE=true\n\n    - name: \"[ppc64] GCC check-tcg\"\n      arch: ppc64le\n      dist: focal\n      addons:\n        apt_packages:\n          - libaio-dev\n          - libattr1-dev\n          - libbrlapi-dev\n          - libcacard-dev\n          - libcap-ng-dev\n          - libgcrypt20-dev\n          - libgnutls28-dev\n          - libgtk-3-dev\n          - libiscsi-dev\n          - liblttng-ust-dev\n          - libncurses5-dev\n          - libnfs-dev\n          - libpixman-1-dev\n          - libpng-dev\n          - librados-dev\n          - libsdl2-dev\n          - libseccomp-dev\n          - liburcu-dev\n          - libusb-1.0-0-dev\n          - libvdeplug-dev\n          - libvte-2.91-dev\n          - ninja-build\n          # Tests dependencies\n          - genisoimage\n      env:\n        - TEST_CMD=\"make check check-tcg V=1\"\n        - CONFIG=\"--disable-containers --target-list=ppc64-softmmu,ppc64le-linux-user\"\n\n    - name: \"[s390x] GCC check-tcg\"\n      arch: s390x\n      dist: focal\n      addons:\n        apt_packages:\n          - libaio-dev\n          - libattr1-dev\n          - libbrlapi-dev\n          - libcacard-dev\n          - libcap-ng-dev\n          - libgcrypt20-dev\n          - libgnutls28-dev\n          - libgtk-3-dev\n          - libiscsi-dev\n          - liblttng-ust-dev\n          - libncurses5-dev\n          - libnfs-dev\n          - libpixman-1-dev\n          - libpng-dev\n          - librados-dev\n          - libsdl2-dev\n          - libseccomp-dev\n          - liburcu-dev\n          - libusb-1.0-0-dev\n          - libvdeplug-dev\n          - libvte-2.91-dev\n          - ninja-build\n          # Tests dependencies\n          - genisoimage\n      env:\n        - TEST_CMD=\"make check check-tcg V=1\"\n        - CONFIG=\"--disable-containers --target-list=${MAIN_SOFTMMU_TARGETS},s390x-linux-user\"\n        - UNRELIABLE=true\n      script:\n        - BUILD_RC=0 && make -j${JOBS} || BUILD_RC=$?\n        - |\n          if [ \"$BUILD_RC\" -eq 0 ] ; then\n              mv pc-bios/s390-ccw/*.img qemu-bundle/usr/local/share/qemu ;\n              ${TEST_CMD} ;\n          else\n              $(exit $BUILD_RC);\n          fi\n\n    - name: \"[s390x] GCC (other-softmmu)\"\n      arch: s390x\n      dist: focal\n      addons:\n        apt_packages:\n          - libaio-dev\n          - libattr1-dev\n          - libcacard-dev\n          - libcap-ng-dev\n          - libgnutls28-dev\n          - libiscsi-dev\n          - liblttng-ust-dev\n          - liblzo2-dev\n          - libncurses-dev\n          - libnfs-dev\n          - libpixman-1-dev\n          - libsdl2-dev\n          - libsdl2-image-dev\n          - libseccomp-dev\n          - libsnappy-dev\n          - libzstd-dev\n          - nettle-dev\n          - xfslibs-dev\n          - ninja-build\n          # Tests dependencies\n          - genisoimage\n      env:\n        - CONFIG=\"--disable-containers --audio-drv-list=sdl --disable-user\n                  --target-list-exclude=${MAIN_SOFTMMU_TARGETS}\"\n\n    - name: \"[s390x] GCC (user)\"\n      arch: s390x\n      dist: focal\n      addons:\n        apt_packages:\n          - libgcrypt20-dev\n          - libglib2.0-dev\n          - libgnutls28-dev\n          - ninja-build\n      env:\n        - CONFIG=\"--disable-containers --disable-system\"\n\n    - name: \"[s390x] Clang (disable-tcg)\"\n      arch: s390x\n      dist: focal\n      compiler: clang\n      addons:\n        apt_packages:\n          - libaio-dev\n          - libattr1-dev\n          - libbrlapi-dev\n          - libcacard-dev\n          - libcap-ng-dev\n          - libgcrypt20-dev\n          - libgnutls28-dev\n          - libgtk-3-dev\n          - libiscsi-dev\n          - liblttng-ust-dev\n          - libncurses5-dev\n          - libnfs-dev\n          - libpixman-1-dev\n          - libpng-dev\n          - librados-dev\n          - libsdl2-dev\n          - libseccomp-dev\n          - liburcu-dev\n          - libusb-1.0-0-dev\n          - libvdeplug-dev\n          - libvte-2.91-dev\n          - ninja-build\n      env:\n        - TEST_CMD=\"make check-unit\"\n        - CONFIG=\"--disable-containers --disable-tcg --enable-kvm\n                  --disable-tools --host-cc=clang --cxx=clang++\"\n        - UNRELIABLE=true\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 17.5703125,
          "content": "\t\t    GNU GENERAL PUBLIC LICENSE\n\t\t       Version 2, June 1991\n\n Copyright (C) 1989, 1991 Free Software Foundation, Inc.,\n 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n\t\t\t    Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicense is intended to guarantee your freedom to share and change free\nsoftware--to make sure the software is free for all its users.  This\nGeneral Public License applies to most of the Free Software\nFoundation's software and to any other program whose authors commit to\nusing it.  (Some other Free Software Foundation software is covered by\nthe GNU Lesser General Public License instead.)  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthis service if you wish), that you receive source code or can get it\nif you want it, that you can change the software or use pieces of it\nin new free programs; and that you know you can do these things.\n\n  To protect your rights, we need to make restrictions that forbid\nanyone to deny you these rights or to ask you to surrender the rights.\nThese restrictions translate to certain responsibilities for you if you\ndistribute copies of the software, or if you modify it.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must give the recipients all the rights that\nyou have.  You must make sure that they, too, receive or can get the\nsource code.  And you must show them these terms so they know their\nrights.\n\n  We protect your rights with two steps: (1) copyright the software, and\n(2) offer you this license which gives you legal permission to copy,\ndistribute and/or modify the software.\n\n  Also, for each author's protection and ours, we want to make certain\nthat everyone understands that there is no warranty for this free\nsoftware.  If the software is modified by someone else and passed on, we\nwant its recipients to know that what they have is not the original, so\nthat any problems introduced by others will not reflect on the original\nauthors' reputations.\n\n  Finally, any free program is threatened constantly by software\npatents.  We wish to avoid the danger that redistributors of a free\nprogram will individually obtain patent licenses, in effect making the\nprogram proprietary.  To prevent this, we have made it clear that any\npatent must be licensed for everyone's free use or not licensed at all.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\f\n\t\t    GNU GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License applies to any program or other work which contains\na notice placed by the copyright holder saying it may be distributed\nunder the terms of this General Public License.  The \"Program\", below,\nrefers to any such program or work, and a \"work based on the Program\"\nmeans either the Program or any derivative work under copyright law:\nthat is to say, a work containing the Program or a portion of it,\neither verbatim or with modifications and/or translated into another\nlanguage.  (Hereinafter, translation is included without limitation in\nthe term \"modification\".)  Each licensee is addressed as \"you\".\n\nActivities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning the Program is not restricted, and the output from the Program\nis covered only if its contents constitute a work based on the\nProgram (independent of having been made by running the Program).\nWhether that is true depends on what the Program does.\n\n  1. You may copy and distribute verbatim copies of the Program's\nsource code as you receive it, in any medium, provided that you\nconspicuously and appropriately publish on each copy an appropriate\ncopyright notice and disclaimer of warranty; keep intact all the\nnotices that refer to this License and to the absence of any warranty;\nand give any other recipients of the Program a copy of this License\nalong with the Program.\n\nYou may charge a fee for the physical act of transferring a copy, and\nyou may at your option offer warranty protection in exchange for a fee.\n\n  2. You may modify your copy or copies of the Program or any portion\nof it, thus forming a work based on the Program, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) You must cause the modified files to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    b) You must cause any work that you distribute or publish, that in\n    whole or in part contains or is derived from the Program or any\n    part thereof, to be licensed as a whole at no charge to all third\n    parties under the terms of this License.\n\n    c) If the modified program normally reads commands interactively\n    when run, you must cause it, when started running for such\n    interactive use in the most ordinary way, to print or display an\n    announcement including an appropriate copyright notice and a\n    notice that there is no warranty (or else, saying that you provide\n    a warranty) and that users may redistribute the program under\n    these conditions, and telling the user how to view a copy of this\n    License.  (Exception: if the Program itself is interactive but\n    does not normally print such an announcement, your work based on\n    the Program is not required to print an announcement.)\n\f\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Program,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Program, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote it.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Program.\n\nIn addition, mere aggregation of another work not based on the Program\nwith the Program (or with a work based on the Program) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may copy and distribute the Program (or a work based on it,\nunder Section 2) in object code or executable form under the terms of\nSections 1 and 2 above provided that you also do one of the following:\n\n    a) Accompany it with the complete corresponding machine-readable\n    source code, which must be distributed under the terms of Sections\n    1 and 2 above on a medium customarily used for software interchange; or,\n\n    b) Accompany it with a written offer, valid for at least three\n    years, to give any third party, for a charge no more than your\n    cost of physically performing source distribution, a complete\n    machine-readable copy of the corresponding source code, to be\n    distributed under the terms of Sections 1 and 2 above on a medium\n    customarily used for software interchange; or,\n\n    c) Accompany it with the information you received as to the offer\n    to distribute corresponding source code.  (This alternative is\n    allowed only for noncommercial distribution and only if you\n    received the program in object code or executable form with such\n    an offer, in accord with Subsection b above.)\n\nThe source code for a work means the preferred form of the work for\nmaking modifications to it.  For an executable work, complete source\ncode means all the source code for all modules it contains, plus any\nassociated interface definition files, plus the scripts used to\ncontrol compilation and installation of the executable.  However, as a\nspecial exception, the source code distributed need not include\nanything that is normally distributed (in either source or binary\nform) with the major components (compiler, kernel, and so on) of the\noperating system on which the executable runs, unless that component\nitself accompanies the executable.\n\nIf distribution of executable or object code is made by offering\naccess to copy from a designated place, then offering equivalent\naccess to copy the source code from the same place counts as\ndistribution of the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\f\n  4. You may not copy, modify, sublicense, or distribute the Program\nexcept as expressly provided under this License.  Any attempt\notherwise to copy, modify, sublicense or distribute the Program is\nvoid, and will automatically terminate your rights under this License.\nHowever, parties who have received copies, or rights, from you under\nthis License will not have their licenses terminated so long as such\nparties remain in full compliance.\n\n  5. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Program or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Program (or any work based on the\nProgram), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Program or works based on it.\n\n  6. Each time you redistribute the Program (or any work based on the\nProgram), the recipient automatically receives a license from the\noriginal licensor to copy, distribute or modify the Program subject to\nthese terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties to\nthis License.\n\n  7. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Program at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Program by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Program.\n\nIf any portion of this section is held invalid or unenforceable under\nany particular circumstance, the balance of the section is intended to\napply and the section as a whole is intended to apply in other\ncircumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system, which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\f\n  8. If the distribution and/or use of the Program is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Program under this License\nmay add an explicit geographical distribution limitation excluding\nthose countries, so that distribution is permitted only in or among\ncountries not thus excluded.  In such case, this License incorporates\nthe limitation as if written in the body of this License.\n\n  9. The Free Software Foundation may publish revised and/or new versions\nof the General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Program\nspecifies a version number of this License which applies to it and \"any\nlater version\", you have the option of following the terms and conditions\neither of that version or of any later version published by the Free\nSoftware Foundation.  If the Program does not specify a version number of\nthis License, you may choose any version ever published by the Free Software\nFoundation.\n\n  10. If you wish to incorporate parts of the Program into other free\nprograms whose distribution conditions are different, write to the author\nto ask for permission.  For software which is copyrighted by the Free\nSoftware Foundation, write to the Free Software Foundation; we sometimes\nmake exceptions for this.  Our decision will be guided by the two goals\nof preserving the free status of all derivatives of our free software and\nof promoting the sharing and reuse of software generally.\n\n\t\t\t    NO WARRANTY\n\n  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\nFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\nOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\nPROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\nOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\nTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\nPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\nREPAIR OR CORRECTION.\n\n  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\nREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\nINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\nOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\nTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\nYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\nPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGES.\n\n\t\t     END OF TERMS AND CONDITIONS\n\f\n\t    How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nAlso add information on how to contact you by electronic and paper mail.\n\nIf the program is interactive, make it output a short notice like this\nwhen it starts in an interactive mode:\n\n    Gnomovision version 69, Copyright (C) year name of author\n    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, the commands you use may\nbe called something other than `show w' and `show c'; they could even be\nmouse-clicks or menu items--whatever suits your program.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the program, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the program\n  `Gnomovision' (which makes passes at compilers) written by James Hacker.\n\n  <signature of Ty Coon>, 1 April 1989\n  Ty Coon, President of Vice\n\nThis General Public License does not permit incorporating your program into\nproprietary programs.  If your program is a subroutine library, you may\nconsider it more useful to permit linking proprietary applications with the\nlibrary.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.\n"
        },
        {
          "name": "COPYING.LIB",
          "type": "blob",
          "size": 25.908203125,
          "content": "                  GNU LESSER GENERAL PUBLIC LICENSE\n                       Version 2.1, February 1999\n\n Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n[This is the first released version of the Lesser GPL.  It also counts\n as the successor of the GNU Library Public License, version 2, hence\n the version number 2.1.]\n\n                            Preamble\n\n  The licenses for most software are designed to take away your\nfreedom to share and change it.  By contrast, the GNU General Public\nLicenses are intended to guarantee your freedom to share and change\nfree software--to make sure the software is free for all its users.\n\n  This license, the Lesser General Public License, applies to some\nspecially designated software packages--typically libraries--of the\nFree Software Foundation and other authors who decide to use it.  You\ncan use it too, but we suggest you first think carefully about whether\nthis license or the ordinary General Public License is the better\nstrategy to use in any particular case, based on the explanations below.\n\n  When we speak of free software, we are referring to freedom of use,\nnot price.  Our General Public Licenses are designed to make sure that\nyou have the freedom to distribute copies of free software (and charge\nfor this service if you wish); that you receive source code or can get\nit if you want it; that you can change the software and use pieces of\nit in new free programs; and that you are informed that you can do\nthese things.\n\n  To protect your rights, we need to make restrictions that forbid\ndistributors to deny you these rights or to ask you to surrender these\nrights.  These restrictions translate to certain responsibilities for\nyou if you distribute copies of the library or if you modify it.\n\n  For example, if you distribute copies of the library, whether gratis\nor for a fee, you must give the recipients all the rights that we gave\nyou.  You must make sure that they, too, receive or can get the source\ncode.  If you link other code with the library, you must provide\ncomplete object files to the recipients, so that they can relink them\nwith the library after making changes to the library and recompiling\nit.  And you must show them these terms so they know their rights.\n\n  We protect your rights with a two-step method: (1) we copyright the\nlibrary, and (2) we offer you this license, which gives you legal\npermission to copy, distribute and/or modify the library.\n\n  To protect each distributor, we want to make it very clear that\nthere is no warranty for the free library.  Also, if the library is\nmodified by someone else and passed on, the recipients should know\nthat what they have is not the original version, so that the original\nauthor's reputation will not be affected by problems that might be\nintroduced by others.\n\f\n  Finally, software patents pose a constant threat to the existence of\nany free program.  We wish to make sure that a company cannot\neffectively restrict the users of a free program by obtaining a\nrestrictive license from a patent holder.  Therefore, we insist that\nany patent license obtained for a version of the library must be\nconsistent with the full freedom of use specified in this license.\n\n  Most GNU software, including some libraries, is covered by the\nordinary GNU General Public License.  This license, the GNU Lesser\nGeneral Public License, applies to certain designated libraries, and\nis quite different from the ordinary General Public License.  We use\nthis license for certain libraries in order to permit linking those\nlibraries into non-free programs.\n\n  When a program is linked with a library, whether statically or using\na shared library, the combination of the two is legally speaking a\ncombined work, a derivative of the original library.  The ordinary\nGeneral Public License therefore permits such linking only if the\nentire combination fits its criteria of freedom.  The Lesser General\nPublic License permits more lax criteria for linking other code with\nthe library.\n\n  We call this license the \"Lesser\" General Public License because it\ndoes Less to protect the user's freedom than the ordinary General\nPublic License.  It also provides other free software developers Less\nof an advantage over competing non-free programs.  These disadvantages\nare the reason we use the ordinary General Public License for many\nlibraries.  However, the Lesser license provides advantages in certain\nspecial circumstances.\n\n  For example, on rare occasions, there may be a special need to\nencourage the widest possible use of a certain library, so that it becomes\na de-facto standard.  To achieve this, non-free programs must be\nallowed to use the library.  A more frequent case is that a free\nlibrary does the same job as widely used non-free libraries.  In this\ncase, there is little to gain by limiting the free library to free\nsoftware only, so we use the Lesser General Public License.\n\n  In other cases, permission to use a particular library in non-free\nprograms enables a greater number of people to use a large body of\nfree software.  For example, permission to use the GNU C Library in\nnon-free programs enables many more people to use the whole GNU\noperating system, as well as its variant, the GNU/Linux operating\nsystem.\n\n  Although the Lesser General Public License is Less protective of the\nusers' freedom, it does ensure that the user of a program that is\nlinked with the Library has the freedom and the wherewithal to run\nthat program using a modified version of the Library.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.  Pay close attention to the difference between a\n\"work based on the library\" and a \"work that uses the library\".  The\nformer contains code derived from the library, whereas the latter must\nbe combined with the library in order to run.\n\f\n                  GNU LESSER GENERAL PUBLIC LICENSE\n   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n  0. This License Agreement applies to any software library or other\nprogram which contains a notice placed by the copyright holder or\nother authorized party saying it may be distributed under the terms of\nthis Lesser General Public License (also called \"this License\").\nEach licensee is addressed as \"you\".\n\n  A \"library\" means a collection of software functions and/or data\nprepared so as to be conveniently linked with application programs\n(which use some of those functions and data) to form executables.\n\n  The \"Library\", below, refers to any such software library or work\nwhich has been distributed under these terms.  A \"work based on the\nLibrary\" means either the Library or any derivative work under\ncopyright law: that is to say, a work containing the Library or a\nportion of it, either verbatim or with modifications and/or translated\nstraightforwardly into another language.  (Hereinafter, translation is\nincluded without limitation in the term \"modification\".)\n\n  \"Source code\" for a work means the preferred form of the work for\nmaking modifications to it.  For a library, complete source code means\nall the source code for all modules it contains, plus any associated\ninterface definition files, plus the scripts used to control compilation\nand installation of the library.\n\n  Activities other than copying, distribution and modification are not\ncovered by this License; they are outside its scope.  The act of\nrunning a program using the Library is not restricted, and output from\nsuch a program is covered only if its contents constitute a work based\non the Library (independent of the use of the Library in a tool for\nwriting it).  Whether that is true depends on what the Library does\nand what the program that uses the Library does.\n\n  1. You may copy and distribute verbatim copies of the Library's\ncomplete source code as you receive it, in any medium, provided that\nyou conspicuously and appropriately publish on each copy an\nappropriate copyright notice and disclaimer of warranty; keep intact\nall the notices that refer to this License and to the absence of any\nwarranty; and distribute a copy of this License along with the\nLibrary.\n\n  You may charge a fee for the physical act of transferring a copy,\nand you may at your option offer warranty protection in exchange for a\nfee.\n\f\n  2. You may modify your copy or copies of the Library or any portion\nof it, thus forming a work based on the Library, and copy and\ndistribute such modifications or work under the terms of Section 1\nabove, provided that you also meet all of these conditions:\n\n    a) The modified work must itself be a software library.\n\n    b) You must cause the files modified to carry prominent notices\n    stating that you changed the files and the date of any change.\n\n    c) You must cause the whole of the work to be licensed at no\n    charge to all third parties under the terms of this License.\n\n    d) If a facility in the modified Library refers to a function or a\n    table of data to be supplied by an application program that uses\n    the facility, other than as an argument passed when the facility\n    is invoked, then you must make a good faith effort to ensure that,\n    in the event an application does not supply such function or\n    table, the facility still operates, and performs whatever part of\n    its purpose remains meaningful.\n\n    (For example, a function in a library to compute square roots has\n    a purpose that is entirely well-defined independent of the\n    application.  Therefore, Subsection 2d requires that any\n    application-supplied function or table used by this function must\n    be optional: if the application does not supply it, the square\n    root function must still compute square roots.)\n\nThese requirements apply to the modified work as a whole.  If\nidentifiable sections of that work are not derived from the Library,\nand can be reasonably considered independent and separate works in\nthemselves, then this License, and its terms, do not apply to those\nsections when you distribute them as separate works.  But when you\ndistribute the same sections as part of a whole which is a work based\non the Library, the distribution of the whole must be on the terms of\nthis License, whose permissions for other licensees extend to the\nentire whole, and thus to each and every part regardless of who wrote\nit.\n\nThus, it is not the intent of this section to claim rights or contest\nyour rights to work written entirely by you; rather, the intent is to\nexercise the right to control the distribution of derivative or\ncollective works based on the Library.\n\nIn addition, mere aggregation of another work not based on the Library\nwith the Library (or with a work based on the Library) on a volume of\na storage or distribution medium does not bring the other work under\nthe scope of this License.\n\n  3. You may opt to apply the terms of the ordinary GNU General Public\nLicense instead of this License to a given copy of the Library.  To do\nthis, you must alter all the notices that refer to this License, so\nthat they refer to the ordinary GNU General Public License, version 2,\ninstead of to this License.  (If a newer version than version 2 of the\nordinary GNU General Public License has appeared, then you can specify\nthat version instead if you wish.)  Do not make any other change in\nthese notices.\n\f\n  Once this change is made in a given copy, it is irreversible for\nthat copy, so the ordinary GNU General Public License applies to all\nsubsequent copies and derivative works made from that copy.\n\n  This option is useful when you wish to copy part of the code of\nthe Library into a program that is not a library.\n\n  4. You may copy and distribute the Library (or a portion or\nderivative of it, under Section 2) in object code or executable form\nunder the terms of Sections 1 and 2 above provided that you accompany\nit with the complete corresponding machine-readable source code, which\nmust be distributed under the terms of Sections 1 and 2 above on a\nmedium customarily used for software interchange.\n\n  If distribution of object code is made by offering access to copy\nfrom a designated place, then offering equivalent access to copy the\nsource code from the same place satisfies the requirement to\ndistribute the source code, even though third parties are not\ncompelled to copy the source along with the object code.\n\n  5. A program that contains no derivative of any portion of the\nLibrary, but is designed to work with the Library by being compiled or\nlinked with it, is called a \"work that uses the Library\".  Such a\nwork, in isolation, is not a derivative work of the Library, and\ntherefore falls outside the scope of this License.\n\n  However, linking a \"work that uses the Library\" with the Library\ncreates an executable that is a derivative of the Library (because it\ncontains portions of the Library), rather than a \"work that uses the\nlibrary\".  The executable is therefore covered by this License.\nSection 6 states terms for distribution of such executables.\n\n  When a \"work that uses the Library\" uses material from a header file\nthat is part of the Library, the object code for the work may be a\nderivative work of the Library even though the source code is not.\nWhether this is true is especially significant if the work can be\nlinked without the Library, or if the work is itself a library.  The\nthreshold for this to be true is not precisely defined by law.\n\n  If such an object file uses only numerical parameters, data\nstructure layouts and accessors, and small macros and small inline\nfunctions (ten lines or less in length), then the use of the object\nfile is unrestricted, regardless of whether it is legally a derivative\nwork.  (Executables containing this object code plus portions of the\nLibrary will still fall under Section 6.)\n\n  Otherwise, if the work is a derivative of the Library, you may\ndistribute the object code for the work under the terms of Section 6.\nAny executables containing that work also fall under Section 6,\nwhether or not they are linked directly with the Library itself.\n\f\n  6. As an exception to the Sections above, you may also combine or\nlink a \"work that uses the Library\" with the Library to produce a\nwork containing portions of the Library, and distribute that work\nunder terms of your choice, provided that the terms permit\nmodification of the work for the customer's own use and reverse\nengineering for debugging such modifications.\n\n  You must give prominent notice with each copy of the work that the\nLibrary is used in it and that the Library and its use are covered by\nthis License.  You must supply a copy of this License.  If the work\nduring execution displays copyright notices, you must include the\ncopyright notice for the Library among them, as well as a reference\ndirecting the user to the copy of this License.  Also, you must do one\nof these things:\n\n    a) Accompany the work with the complete corresponding\n    machine-readable source code for the Library including whatever\n    changes were used in the work (which must be distributed under\n    Sections 1 and 2 above); and, if the work is an executable linked\n    with the Library, with the complete machine-readable \"work that\n    uses the Library\", as object code and/or source code, so that the\n    user can modify the Library and then relink to produce a modified\n    executable containing the modified Library.  (It is understood\n    that the user who changes the contents of definitions files in the\n    Library will not necessarily be able to recompile the application\n    to use the modified definitions.)\n\n    b) Use a suitable shared library mechanism for linking with the\n    Library.  A suitable mechanism is one that (1) uses at run time a\n    copy of the library already present on the user's computer system,\n    rather than copying library functions into the executable, and (2)\n    will operate properly with a modified version of the library, if\n    the user installs one, as long as the modified version is\n    interface-compatible with the version that the work was made with.\n\n    c) Accompany the work with a written offer, valid for at\n    least three years, to give the same user the materials\n    specified in Subsection 6a, above, for a charge no more\n    than the cost of performing this distribution.\n\n    d) If distribution of the work is made by offering access to copy\n    from a designated place, offer equivalent access to copy the above\n    specified materials from the same place.\n\n    e) Verify that the user has already received a copy of these\n    materials or that you have already sent this user a copy.\n\n  For an executable, the required form of the \"work that uses the\nLibrary\" must include any data and utility programs needed for\nreproducing the executable from it.  However, as a special exception,\nthe materials to be distributed need not include anything that is\nnormally distributed (in either source or binary form) with the major\ncomponents (compiler, kernel, and so on) of the operating system on\nwhich the executable runs, unless that component itself accompanies\nthe executable.\n\n  It may happen that this requirement contradicts the license\nrestrictions of other proprietary libraries that do not normally\naccompany the operating system.  Such a contradiction means you cannot\nuse both them and the Library together in an executable that you\ndistribute.\n\f\n  7. You may place library facilities that are a work based on the\nLibrary side-by-side in a single library together with other library\nfacilities not covered by this License, and distribute such a combined\nlibrary, provided that the separate distribution of the work based on\nthe Library and of the other library facilities is otherwise\npermitted, and provided that you do these two things:\n\n    a) Accompany the combined library with a copy of the same work\n    based on the Library, uncombined with any other library\n    facilities.  This must be distributed under the terms of the\n    Sections above.\n\n    b) Give prominent notice with the combined library of the fact\n    that part of it is a work based on the Library, and explaining\n    where to find the accompanying uncombined form of the same work.\n\n  8. You may not copy, modify, sublicense, link with, or distribute\nthe Library except as expressly provided under this License.  Any\nattempt otherwise to copy, modify, sublicense, link with, or\ndistribute the Library is void, and will automatically terminate your\nrights under this License.  However, parties who have received copies,\nor rights, from you under this License will not have their licenses\nterminated so long as such parties remain in full compliance.\n\n  9. You are not required to accept this License, since you have not\nsigned it.  However, nothing else grants you permission to modify or\ndistribute the Library or its derivative works.  These actions are\nprohibited by law if you do not accept this License.  Therefore, by\nmodifying or distributing the Library (or any work based on the\nLibrary), you indicate your acceptance of this License to do so, and\nall its terms and conditions for copying, distributing or modifying\nthe Library or works based on it.\n\n  10. Each time you redistribute the Library (or any work based on the\nLibrary), the recipient automatically receives a license from the\noriginal licensor to copy, distribute, link with or modify the Library\nsubject to these terms and conditions.  You may not impose any further\nrestrictions on the recipients' exercise of the rights granted herein.\nYou are not responsible for enforcing compliance by third parties with\nthis License.\n\f\n  11. If, as a consequence of a court judgment or allegation of patent\ninfringement or for any other reason (not limited to patent issues),\nconditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot\ndistribute so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you\nmay not distribute the Library at all.  For example, if a patent\nlicense would not permit royalty-free redistribution of the Library by\nall those who receive copies directly or indirectly through you, then\nthe only way you could satisfy both it and this License would be to\nrefrain entirely from distribution of the Library.\n\nIf any portion of this section is held invalid or unenforceable under any\nparticular circumstance, the balance of the section is intended to apply,\nand the section as a whole is intended to apply in other circumstances.\n\nIt is not the purpose of this section to induce you to infringe any\npatents or other property right claims or to contest validity of any\nsuch claims; this section has the sole purpose of protecting the\nintegrity of the free software distribution system which is\nimplemented by public license practices.  Many people have made\ngenerous contributions to the wide range of software distributed\nthrough that system in reliance on consistent application of that\nsystem; it is up to the author/donor to decide if he or she is willing\nto distribute software through any other system and a licensee cannot\nimpose that choice.\n\nThis section is intended to make thoroughly clear what is believed to\nbe a consequence of the rest of this License.\n\n  12. If the distribution and/or use of the Library is restricted in\ncertain countries either by patents or by copyrighted interfaces, the\noriginal copyright holder who places the Library under this License may add\nan explicit geographical distribution limitation excluding those countries,\nso that distribution is permitted only in or among countries not thus\nexcluded.  In such case, this License incorporates the limitation as if\nwritten in the body of this License.\n\n  13. The Free Software Foundation may publish revised and/or new\nversions of the Lesser General Public License from time to time.\nSuch new versions will be similar in spirit to the present version,\nbut may differ in detail to address new problems or concerns.\n\nEach version is given a distinguishing version number.  If the Library\nspecifies a version number of this License which applies to it and\n\"any later version\", you have the option of following the terms and\nconditions either of that version or of any later version published by\nthe Free Software Foundation.  If the Library does not specify a\nlicense version number, you may choose any version ever published by\nthe Free Software Foundation.\n\f\n  14. If you wish to incorporate parts of the Library into other free\nprograms whose distribution conditions are incompatible with these,\nwrite to the author to ask for permission.  For software which is\ncopyrighted by the Free Software Foundation, write to the Free\nSoftware Foundation; we sometimes make exceptions for this.  Our\ndecision will be guided by the two goals of preserving the free status\nof all derivatives of our free software and of promoting the sharing\nand reuse of software generally.\n\n                            NO WARRANTY\n\n  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\nWARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\nEXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR\nOTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\nKIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\nLIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\nTHE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\nWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\nAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\nFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\nCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\nLIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\nRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\nFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\nSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGES.\n\n                     END OF TERMS AND CONDITIONS\n\f\n           How to Apply These Terms to Your New Libraries\n\n  If you develop a new library, and you want it to be of the greatest\npossible use to the public, we recommend making it free software that\neveryone can redistribute and change.  You can do so by permitting\nredistribution under these terms (or, alternatively, under the terms of the\nordinary General Public License).\n\n  To apply these terms, attach the following notices to the library.  It is\nsafest to attach them to the start of each source file to most effectively\nconvey the exclusion of warranty; and each file should have at least the\n\"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the library's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This library is free software; you can redistribute it and/or\n    modify it under the terms of the GNU Lesser General Public\n    License as published by the Free Software Foundation; either\n    version 2.1 of the License, or (at your option) any later version.\n\n    This library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public\n    License along with this library; if not, write to the Free Software\n    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n\nAlso add information on how to contact you by electronic and paper mail.\n\nYou should also get your employer (if you work as a programmer) or your\nschool, if any, to sign a \"copyright disclaimer\" for the library, if\nnecessary.  Here is a sample; alter the names:\n\n  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n\n  <signature of Ty Coon>, 1 April 1990\n  Ty Coon, President of Vice\n\nThat's all there is to it!\n"
        },
        {
          "name": "Kconfig",
          "type": "blob",
          "size": 0.12890625,
          "content": "source Kconfig.host\nsource backends/Kconfig\nsource accel/Kconfig\nsource target/Kconfig\nsource hw/Kconfig\nsource semihosting/Kconfig\n"
        },
        {
          "name": "Kconfig.host",
          "type": "blob",
          "size": 0.6015625,
          "content": "# These are \"proxy\" symbols used to pass config-host.mak values\n# down to Kconfig.  See also kconfig_external_symbols in\n# meson.build: these two need to be kept in sync.\n\nconfig LINUX\n    bool\n\nconfig OPENGL\n    bool\n\nconfig X11\n    bool\n\nconfig SPICE\n    bool\n\nconfig IVSHMEM\n    bool\n\nconfig TPM\n    bool\n\nconfig VHOST_USER\n    bool\n\nconfig VHOST_VDPA\n    bool\n\nconfig VHOST_KERNEL\n    bool\n\nconfig VIRTFS\n    bool\n\nconfig PVRDMA\n    bool\n\nconfig MULTIPROCESS_ALLOWED\n    bool\n    imply MULTIPROCESS\n\nconfig FUZZ\n    bool\n    select SPARSE_MEM\n\nconfig VFIO_USER_SERVER_ALLOWED\n    bool\n    imply VFIO_USER_SERVER\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.1494140625,
          "content": "The QEMU distribution includes both the QEMU emulator and\nvarious firmware files.  These are separate programs that are\ndistributed together for our users' convenience, and they have\nseparate licenses.\n\nThe following points clarify the license of the QEMU emulator:\n\n1) The QEMU emulator as a whole is released under the GNU General\nPublic License, version 2.\n\n2) Parts of the QEMU emulator have specific licenses which are compatible\nwith the GNU General Public License, version 2. Hence each source file\ncontains its own licensing information.  Source files with no licensing\ninformation are released under the GNU General Public License, version\n2 or (at your option) any later version.\n\nAs of July 2013, contributions under version 2 of the GNU General Public\nLicense (and no later version) are only accepted for the following files\nor directories: bsd-user/, linux-user/, hw/vfio/, hw/xen/xen_pt*.\n\n3) The Tiny Code Generator (TCG) is mostly under the BSD or MIT licenses;\n   but some parts may be GPLv2 or other licenses. Again, see the\n   specific licensing information in each source file.\n\n4) QEMU is a trademark of Fabrice Bellard.\n\nFabrice Bellard and the QEMU team\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 85.892578125,
          "content": "QEMU Maintainers\n================\n\nThe intention of this file is not to establish who owns what portions of the\ncode base, but to provide a set of names that developers can consult when they\nhave a question about a particular subset and also to provide a set of names\nto be CC'd when submitting a patch to obtain appropriate review.\n\nIn general, if you have a question about inclusion of a patch, you should\nconsult qemu-devel and not any specific individual privately.\n\nDescriptions of section entries:\n\n\tM: Mail patches to: FullName <address@domain>\n\t   Maintainers are looking after a certain area and must be CCed on\n\t   patches. They are considered the main contact point.\n\tR: Designated reviewer: FullName <address@domain>\n\t   These reviewers should be CCed on patches.\n\t   Reviewers are familiar with the subject matter and provide feedback\n\t   even though they are not maintainers.\n\tL: Mailing list that is relevant to this area\n\t   These lists should be CCed on patches.\n\tW: Web-page with status/info\n\tQ: Patchwork web based patch tracking system site\n\tT: SCM tree type and location.  Type is one of: git, hg, quilt, stgit.\n\tS: Status, one of the following:\n\t   Supported:\tSomeone is actually paid to look after this.\n\t   Maintained:\tSomeone actually looks after it.\n\t   Odd Fixes:\tIt has a maintainer but they don't have time to do\n\t\t\tmuch other than throw the odd patch in. See below.\n\t   Orphan:\tNo current maintainer [but maybe you could take the\n\t\t\trole as you write your new code].\n\t   Obsolete:\tOld code. Something tagged obsolete generally means\n\t\t\tit has been replaced by a better system and you\n\t\t\tshould be using that.\n\tF: Files and directories with wildcard patterns.\n\t   A trailing slash includes all files and subdirectory files.\n\t   F:\tdrivers/net/\tall files in and below drivers/net\n\t   F:\tdrivers/net/*\tall files in drivers/net, but not below\n\t   F:\t*/net/*\t\tall files in \"any top level directory\"/net\n\t   One pattern per line.  Multiple F: lines acceptable.\n\tX: Files and directories that are NOT maintained, same rules as F:\n\t   Files exclusions are tested before file matches.\n\t   Can be useful for excluding a specific subdirectory, for instance:\n\t   F:\tnet/\n\t   X:\tnet/ipv6/\n\t   matches all files in and below net excluding net/ipv6/\n\tK: Keyword perl extended regex pattern to match content in a\n\t   patch or file.  For instance:\n\t   K: of_get_profile\n\t      matches patches or files that contain \"of_get_profile\"\n\t   K: \\b(printk|pr_(info|err))\\b\n\t      matches patches or files that contain one or more of the words\n\t      printk, pr_info or pr_err\n\t   One regex pattern per line.  Multiple K: lines acceptable.\n\n\nGeneral Project Administration\n------------------------------\nM: Peter Maydell <peter.maydell@linaro.org>\n\nAll patches CC here\nL: qemu-devel@nongnu.org\nF: *\nF: */\n\nResponsible Disclosure, Reporting Security Issues\n-------------------------------------------------\nW: https://wiki.qemu.org/SecurityProcess\nM: Michael S. Tsirkin <mst@redhat.com>\nL: secalert@redhat.com\n\nTrivial patches\n---------------\nTrivial patches\nM: Michael Tokarev <mjt@tls.msk.ru>\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nL: qemu-trivial@nongnu.org\nK: ^Subject:.*(?i)trivial\nT: git git://git.corpit.ru/qemu.git trivial-patches\nT: git https://github.com/vivier/qemu.git trivial-patches\n\nArchitecture support\n--------------------\nS390 general architecture support\nM: Cornelia Huck <cohuck@redhat.com>\nM: Thomas Huth <thuth@redhat.com>\nS: Supported\nF: configs/devices/s390x-softmmu/default.mak\nF: gdb-xml/s390*.xml\nF: hw/char/sclp*.[hc]\nF: hw/char/terminal3270.c\nF: hw/intc/s390_flic.c\nF: hw/intc/s390_flic_kvm.c\nF: hw/s390x/\nF: hw/vfio/ap.c\nF: hw/vfio/ccw.c\nF: hw/watchdog/wdt_diag288.c\nF: include/hw/s390x/\nF: include/hw/watchdog/wdt_diag288.h\nF: pc-bios/s390-ccw/\nF: pc-bios/s390-ccw.img\nF: target/s390x/\nF: docs/system/target-s390x.rst\nF: docs/system/s390x/\nF: tests/migration/s390x/\nK: ^Subject:.*(?i)s390x?\nT: git https://gitlab.com/cohuck/qemu.git s390-next\nL: qemu-s390x@nongnu.org\n\nMIPS general architecture support\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Jiaxun Yang <jiaxun.yang@flygoat.com>\nS: Odd Fixes\nK: ^Subject:.*(?i)mips\n\nGuest CPU cores (TCG)\n---------------------\nOverall TCG CPUs\nM: Richard Henderson <richard.henderson@linaro.org>\nR: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: softmmu/cpus.c\nF: cpus-common.c\nF: page-vary.c\nF: page-vary-common.c\nF: accel/tcg/\nF: accel/stubs/tcg-stub.c\nF: util/cacheinfo.c\nF: util/cacheflush.c\nF: scripts/decodetree.py\nF: docs/devel/decodetree.rst\nF: include/exec/cpu*.h\nF: include/exec/exec-all.h\nF: include/exec/helper*.h\nF: include/sysemu/cpus.h\nF: include/sysemu/tcg.h\nF: include/hw/core/tcg-cpu-ops.h\n\nFPU emulation\nM: Aurelien Jarno <aurelien@aurel32.net>\nM: Peter Maydell <peter.maydell@linaro.org>\nM: Alex Bennée <alex.bennee@linaro.org>\nS: Maintained\nF: fpu/\nF: include/fpu/\nF: tests/fp/\n\nAlpha TCG CPUs\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nF: target/alpha/\nF: tests/tcg/alpha/\nF: disas/alpha.c\n\nARM TCG CPUs\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: target/arm/\nF: tests/tcg/arm/\nF: tests/tcg/aarch64/\nF: tests/qtest/arm-cpu-features.c\nF: hw/arm/\nF: hw/cpu/a*mpcore.c\nF: include/hw/cpu/a*mpcore.h\nF: docs/system/target-arm.rst\nF: docs/system/arm/cpu-features.rst\n\nARM SMMU\nM: Eric Auger <eric.auger@redhat.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/smmu*\nF: include/hw/arm/smmu*\nF: tests/avocado/smmu.py\n\nAVR TCG CPUs\nM: Michael Rolnik <mrolnik@gmail.com>\nS: Maintained\nF: docs/system/target-avr.rst\nF: gdb-xml/avr-cpu.xml\nF: target/avr/\nF: tests/avocado/machine_avr6.py\n\nCRIS TCG CPUs\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: target/cris/\nF: hw/cris/\nF: include/hw/cris/\nF: tests/tcg/cris/\nF: disas/cris.c\n\nHexagon TCG CPUs\nM: Taylor Simpson <tsimpson@quicinc.com>\nS: Supported\nF: target/hexagon/\nF: linux-user/hexagon/\nF: tests/tcg/hexagon/\nF: disas/hexagon.c\nF: configs/targets/hexagon-linux-user/default.mak\nF: docker/dockerfiles/debian-hexagon-cross.docker\nF: docker/dockerfiles/debian-hexagon-cross.docker.d/build-toolchain.sh\n\nHPPA (PA-RISC) TCG CPUs\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nF: target/hppa/\nF: disas/hppa.c\n\nLoongArch TCG CPUs\nM: Song Gao <gaosong@loongson.cn>\nM: Xiaojuan Yang <yangxiaojuan@loongson.cn>\nS: Maintained\nF: target/loongarch/\nF: tests/tcg/loongarch64/\n\nM68K TCG CPUs\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nF: target/m68k/\nF: disas/m68k.c\n\nMicroBlaze TCG CPUs\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: target/microblaze/\nF: hw/microblaze/\nF: disas/microblaze.c\nF: tests/docker/dockerfiles/debian-microblaze-cross.d/build-toolchain.sh\nF: tests/tcg/nios2/Makefile.target\n\nMIPS TCG CPUs\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Aurelien Jarno <aurelien@aurel32.net>\nR: Jiaxun Yang <jiaxun.yang@flygoat.com>\nR: Aleksandar Rikalo <aleksandar.rikalo@syrmia.com>\nS: Odd Fixes\nF: target/mips/\nF: disas/mips.c\nF: docs/system/cpu-models-mips.rst.inc\nF: tests/tcg/mips/\n\nMIPS TCG CPUs (nanoMIPS ISA)\nM: Stefan Pejic <stefan.pejic@syrmia.com>\nS: Maintained\nF: disas/nanomips.*\nF: target/mips/tcg/*nanomips*\n\nNiosII TCG CPUs\nM: Chris Wulff <crwulff@gmail.com>\nM: Marek Vasut <marex@denx.de>\nS: Maintained\nF: target/nios2/\nF: hw/nios2/\nF: disas/nios2.c\nF: configs/devices/nios2-softmmu/default.mak\nF: tests/docker/dockerfiles/debian-nios2-cross.d/build-toolchain.sh\n\nOpenRISC TCG CPUs\nM: Stafford Horne <shorne@gmail.com>\nS: Odd Fixes\nF: target/openrisc/\nF: hw/openrisc/\nF: tests/tcg/openrisc/\n\nPowerPC TCG CPUs\nM: Cédric Le Goater <clg@kaod.org>\nM: Daniel Henrique Barboza <danielhb413@gmail.com>\nR: David Gibson <david@gibson.dropbear.id.au>\nR: Greg Kurz <groug@kaod.org>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: target/ppc/\nF: hw/ppc/ppc.c\nF: hw/ppc/ppc_booke.c\nF: include/hw/ppc/ppc.h\n\nRISC-V TCG CPUs\nM: Palmer Dabbelt <palmer@dabbelt.com>\nM: Alistair Francis <alistair.francis@wdc.com>\nM: Bin Meng <bin.meng@windriver.com>\nL: qemu-riscv@nongnu.org\nS: Supported\nF: target/riscv/\nF: hw/riscv/\nF: include/hw/riscv/\nF: linux-user/host/riscv32/\nF: linux-user/host/riscv64/\n\nRISC-V XVentanaCondOps extension\nM: Philipp Tomsich <philipp.tomsich@vrull.eu>\nL: qemu-riscv@nongnu.org\nS: Supported\nF: target/riscv/XVentanaCondOps.decode\nF: target/riscv/insn_trans/trans_xventanacondops.c.inc\n\nRENESAS RX CPUs\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nS: Orphan\nF: target/rx/\n\nS390 TCG CPUs\nM: Richard Henderson <richard.henderson@linaro.org>\nM: David Hildenbrand <david@redhat.com>\nS: Maintained\nF: target/s390x/\nF: target/s390x/tcg\nF: hw/s390x/\nF: tests/tcg/s390x/\nL: qemu-s390x@nongnu.org\n\nSH4 TCG CPUs\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nS: Orphan\nF: target/sh4/\nF: hw/sh4/\nF: disas/sh4.c\nF: include/hw/sh4/\n\nSPARC TCG CPUs\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nM: Artyom Tarasenko <atar4qemu@gmail.com>\nS: Maintained\nF: target/sparc/\nF: hw/sparc/\nF: hw/sparc64/\nF: include/hw/sparc/sparc64.h\nF: disas/sparc.c\n\nX86 TCG CPUs\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Richard Henderson <richard.henderson@linaro.org>\nM: Eduardo Habkost <eduardo@habkost.net>\nS: Maintained\nF: target/i386/tcg/\nF: tests/tcg/i386/\nF: tests/tcg/x86_64/\nF: hw/i386/\nF: docs/system/cpu-models-x86*\nT: git https://gitlab.com/ehabkost/qemu.git x86-next\n\nXtensa TCG CPUs\nM: Max Filippov <jcmvbkbc@gmail.com>\nW: http://wiki.osll.ru/doku.php?id=etc:users:jcmvbkbc:qemu-target-xtensa\nS: Maintained\nF: target/xtensa/\nF: hw/xtensa/\nF: tests/tcg/xtensa/\nF: disas/xtensa.c\nF: include/hw/xtensa/xtensa-isa.h\nF: configs/devices/xtensa*/default.mak\n\nTriCore TCG CPUs\nM: Bastian Koppelmann <kbastian@mail.uni-paderborn.de>\nS: Maintained\nF: target/tricore/\nF: hw/tricore/\nF: include/hw/tricore/\nF: tests/tcg/tricore/\n\nMultiarch Linux User Tests\nM: Alex Bennée <alex.bennee@linaro.org>\nS: Maintained\nF: tests/tcg/multiarch/\n\nGuest CPU Cores (KVM)\n---------------------\nOverall KVM CPUs\nM: Paolo Bonzini <pbonzini@redhat.com>\nL: kvm@vger.kernel.org\nS: Supported\nF: */*/kvm*\nF: accel/kvm/\nF: accel/stubs/kvm-stub.c\nF: include/hw/kvm/\nF: include/sysemu/kvm*.h\nF: scripts/kvm/kvm_flightrecorder\n\nARM KVM CPUs\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: target/arm/kvm.c\n\nMIPS KVM CPUs\nM: Huacai Chen <chenhuacai@kernel.org>\nS: Odd Fixes\nF: target/mips/kvm*\nF: target/mips/sysemu/\n\nPPC KVM CPUs\nM: Cédric Le Goater <clg@kaod.org>\nM: Daniel Henrique Barboza <danielhb413@gmail.com>\nR: David Gibson <david@gibson.dropbear.id.au>\nR: Greg Kurz <groug@kaod.org>\nS: Maintained\nF: target/ppc/kvm.c\n\nS390 KVM CPUs\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nS: Supported\nF: target/s390x/kvm/\nF: target/s390x/machine.c\nF: target/s390x/sigp.c\nF: hw/s390x/pv.c\nF: include/hw/s390x/pv.h\nF: gdb-xml/s390*.xml\nT: git https://github.com/borntraeger/qemu.git s390-next\nL: qemu-s390x@nongnu.org\n\nX86 KVM CPUs\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Marcelo Tosatti <mtosatti@redhat.com>\nL: kvm@vger.kernel.org\nS: Supported\nF: docs/system/i386/amd-memory-encryption.rst\nF: docs/system/i386/sgx.rst\nF: target/i386/kvm/\nF: target/i386/sev*\nF: scripts/kvm/vmxcap\n\nGuest CPU Cores (other accelerators)\n------------------------------------\nOverall\nM: Richard Henderson <richard.henderson@linaro.org>\nR: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: include/qemu/accel.h\nF: include/sysemu/accel-ops.h\nF: include/hw/core/accel-cpu.h\nF: accel/accel-*.c\nF: accel/Makefile.objs\nF: accel/stubs/Makefile.objs\n\nApple Silicon HVF CPUs\nM: Alexander Graf <agraf@csgraf.de>\nS: Maintained\nF: target/arm/hvf/\n\nX86 HVF CPUs\nM: Cameron Esfahani <dirty@apple.com>\nM: Roman Bolshakov <r.bolshakov@yadro.com>\nW: https://wiki.qemu.org/Features/HVF\nS: Maintained\nF: target/i386/hvf/\n\nHVF\nM: Cameron Esfahani <dirty@apple.com>\nM: Roman Bolshakov <r.bolshakov@yadro.com>\nW: https://wiki.qemu.org/Features/HVF\nS: Maintained\nF: accel/hvf/\nF: include/sysemu/hvf.h\nF: include/sysemu/hvf_int.h\n\nWHPX CPUs\nM: Sunil Muthuswamy <sunilmut@microsoft.com>\nS: Supported\nF: target/i386/whpx/\nF: include/sysemu/whpx.h\n\nGuest CPU Cores (Xen)\n---------------------\nX86 Xen CPUs\nM: Stefano Stabellini <sstabellini@kernel.org>\nM: Anthony Perard <anthony.perard@citrix.com>\nM: Paul Durrant <paul@xen.org>\nL: xen-devel@lists.xenproject.org\nS: Supported\nF: */xen*\nF: accel/xen/*\nF: hw/9pfs/xen-9p*\nF: hw/char/xen_console.c\nF: hw/display/xenfb.c\nF: hw/net/xen_nic.c\nF: hw/usb/xen-usb.c\nF: hw/block/xen*\nF: hw/block/dataplane/xen*\nF: hw/xen/\nF: hw/xenpv/\nF: hw/i386/xen/\nF: hw/pci-host/xen_igd_pt.c\nF: include/hw/block/dataplane/xen*\nF: include/hw/xen/\nF: include/sysemu/xen.h\nF: include/sysemu/xen-mapcache.h\nF: stubs/xen-hw-stub.c\n\nGuest CPU Cores (HAXM)\n---------------------\nX86 HAXM CPUs\nM: Wenchao Wang <wenchao.wang@intel.com>\nL: haxm-team@intel.com\nW: https://github.com/intel/haxm/issues\nS: Maintained\nF: accel/stubs/hax-stub.c\nF: include/sysemu/hax.h\nF: target/i386/hax/\n\nGuest CPU Cores (NVMM)\n----------------------\nNetBSD Virtual Machine Monitor (NVMM) CPU support\nM: Kamil Rytarowski <kamil@netbsd.org>\nM: Reinoud Zandijk <reinoud@netbsd.org>\nS: Maintained\nF: include/sysemu/nvmm.h\nF: target/i386/nvmm/\n\nHosts\n-----\nLINUX\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Cornelia Huck <cohuck@redhat.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: linux-headers/\nF: scripts/update-linux-headers.sh\n\nPOSIX\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: os-posix.c\nF: include/sysemu/os-posix.h\nF: util/*posix*.c\nF: include/qemu/*posix*.h\n\nNETBSD\nM: Kamil Rytarowski <kamil@netbsd.org>\nM: Reinoud Zandijk <reinoud@netbsd.org>\nM: Ryo ONODERA <ryoon@netbsd.org>\nS: Maintained\nK: ^Subject:.*(?i)NetBSD\n\nOPENBSD\nM: Brad Smith <brad@comstyle.com>\nS: Maintained\nK: ^Subject:.*(?i)OpenBSD\n\nW32, W64\nM: Stefan Weil <sw@weilnetz.de>\nS: Maintained\nF: *win32*\nF: */*win32*\nF: include/*/*win32*\nX: qga/*win32*\nF: qemu.nsi\n\nDarwin (macOS, iOS)\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Odd Fixes\nF: .gitlab-ci.d/cirrus/macos-*\nF: */*.m\n\nAlpha Machines\n--------------\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nF: hw/alpha/\nF: hw/isa/smc37c669-superio.c\nF: tests/tcg/alpha/system/\n\nARM Machines\n------------\nAllwinner-a10\nM: Beniamino Galvani <b.galvani@gmail.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/*/allwinner*\nF: include/hw/*/allwinner*\nF: hw/arm/cubieboard.c\nF: docs/system/arm/cubieboard.rst\n\nAllwinner-h3\nM: Niek Linnenbank <nieklinnenbank@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/allwinner-h3*\nF: include/hw/*/allwinner-h3*\nF: hw/arm/orangepi.c\nF: docs/system/arm/orangepi.rst\n\nARM PrimeCell and CMSDK devices\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/char/pl011.c\nF: include/hw/char/pl011.h\nF: hw/display/pl110*\nF: hw/dma/pl080.c\nF: include/hw/dma/pl080.h\nF: hw/dma/pl330.c\nF: hw/gpio/pl061.c\nF: hw/input/pl050.c\nF: hw/intc/pl190.c\nF: hw/sd/pl181.c\nF: hw/ssi/pl022.c\nF: include/hw/ssi/pl022.h\nF: hw/rtc/pl031.c\nF: include/hw/rtc/pl031.h\nF: include/hw/arm/primecell.h\nF: hw/timer/cmsdk-apb-timer.c\nF: include/hw/timer/cmsdk-apb-timer.h\nF: tests/qtest/cmsdk-apb-timer-test.c\nF: hw/timer/cmsdk-apb-dualtimer.c\nF: include/hw/timer/cmsdk-apb-dualtimer.h\nF: tests/qtest/cmsdk-apb-dualtimer-test.c\nF: hw/char/cmsdk-apb-uart.c\nF: include/hw/char/cmsdk-apb-uart.h\nF: hw/watchdog/cmsdk-apb-watchdog.c\nF: include/hw/watchdog/cmsdk-apb-watchdog.h\nF: tests/qtest/cmsdk-apb-watchdog-test.c\nF: hw/misc/tz-ppc.c\nF: include/hw/misc/tz-ppc.h\nF: hw/misc/tz-mpc.c\nF: include/hw/misc/tz-mpc.h\nF: hw/misc/tz-msc.c\nF: include/hw/misc/tz-msc.h\n\nARM cores\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/intc/arm*\nF: hw/intc/gic_internal.h\nF: hw/misc/a9scu.c\nF: hw/misc/arm11scu.c\nF: hw/misc/arm_l2x0.c\nF: hw/misc/armv7m_ras.c\nF: hw/timer/a9gtimer*\nF: hw/timer/arm*\nF: include/hw/arm/arm*.h\nF: include/hw/intc/arm*\nF: include/hw/misc/a9scu.h\nF: include/hw/misc/arm11scu.h\nF: include/hw/timer/a9gtimer.h\nF: include/hw/timer/arm_mptimer.h\nF: include/hw/timer/armv7m_systick.h\nF: include/hw/misc/armv7m_ras.h\nF: tests/qtest/test-arm-mptimer.c\n\nExynos\nM: Igor Mitsyanko <i.mitsyanko@gmail.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/*/exynos*\nF: include/hw/*/exynos*\n\nCalxeda Highbank\nM: Rob Herring <robh@kernel.org>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/highbank.c\nF: hw/net/xgmac.c\nF: docs/system/arm/highbank.rst\n\nCanon DIGIC\nM: Antony Pavlov <antonynpavlov@gmail.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: include/hw/arm/digic.h\nF: hw/*/digic*\nF: include/hw/*/digic*\nF: tests/avocado/machine_arm_canona1100.py\nF: docs/system/arm/digic.rst\n\nGoldfish RTC\nM: Anup Patel <anup.patel@wdc.com>\nM: Alistair Francis <Alistair.Francis@wdc.com>\nL: qemu-riscv@nongnu.org\nS: Maintained\nF: hw/rtc/goldfish_rtc.c\nF: include/hw/rtc/goldfish_rtc.h\n\nGumstix\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/gumstix.c\nF: docs/system/arm/gumstix.rst\n\ni.MX25 PDK\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Jean-Christophe Dubois <jcd@tribudubois.net>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/fsl-imx25.c\nF: hw/arm/imx25_pdk.c\nF: hw/misc/imx25_ccm.c\nF: hw/watchdog/wdt_imx2.c\nF: include/hw/arm/fsl-imx25.h\nF: include/hw/misc/imx25_ccm.h\nF: include/hw/watchdog/wdt_imx2.h\nF: docs/system/arm/imx25-pdk.rst\n\ni.MX31 (kzm)\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/kzm.c\nF: hw/*/imx_*\nF: hw/*/*imx31*\nF: include/hw/*/imx_*\nF: include/hw/*/*imx31*\nF: docs/system/arm/kzm.rst\n\nIntegrator CP\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/integratorcp.c\nF: hw/misc/arm_integrator_debug.c\nF: include/hw/misc/arm_integrator_debug.h\nF: tests/avocado/machine_arm_integratorcp.py\nF: docs/system/arm/integratorcp.rst\n\nMCIMX6UL EVK / i.MX6ul\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Jean-Christophe Dubois <jcd@tribudubois.net>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/mcimx6ul-evk.c\nF: hw/arm/fsl-imx6ul.c\nF: hw/misc/imx6ul_ccm.c\nF: include/hw/arm/fsl-imx6ul.h\nF: include/hw/misc/imx6ul_ccm.h\n\nMCIMX7D SABRE / i.MX7\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Andrey Smirnov <andrew.smirnov@gmail.com>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/mcimx7d-sabre.c\nF: hw/arm/fsl-imx7.c\nF: hw/misc/imx7_*.c\nF: include/hw/arm/fsl-imx7.h\nF: include/hw/misc/imx7_*.h\nF: hw/pci-host/designware.c\nF: include/hw/pci-host/designware.h\n\nMPS2\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/mps2.c\nF: hw/arm/mps2-tz.c\nF: hw/misc/mps2-*.c\nF: include/hw/misc/mps2-*.h\nF: hw/arm/armsse.c\nF: include/hw/arm/armsse.h\nF: hw/misc/iotkit-secctl.c\nF: include/hw/misc/iotkit-secctl.h\nF: hw/misc/iotkit-sysctl.c\nF: include/hw/misc/iotkit-sysctl.h\nF: hw/misc/iotkit-sysinfo.c\nF: include/hw/misc/iotkit-sysinfo.h\nF: hw/misc/armsse-cpu-pwrctrl.c\nF: include/hw/misc/armsse-cpu-pwrctrl.h\nF: hw/misc/armsse-cpuid.c\nF: include/hw/misc/armsse-cpuid.h\nF: hw/misc/armsse-mhu.c\nF: include/hw/misc/armsse-mhu.h\nF: hw/timer/sse-counter.c\nF: include/hw/timer/sse-counter.h\nF: hw/timer/sse-timer.c\nF: include/hw/timer/sse-timer.h\nF: tests/qtest/sse-timer-test.c\nF: docs/system/arm/mps2.rst\n\nMusca\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/musca.c\nF: docs/system/arm/musca.rst\n\nMusicpal\nM: Jan Kiszka <jan.kiszka@web.de>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/musicpal.c\nF: hw/net/mv88w8618_eth.c\nF: include/hw/net/mv88w8618_eth.h\nF: docs/system/arm/musicpal.rst\n\nNuvoton NPCM7xx\nM: Havard Skinnemoen <hskinnemoen@google.com>\nM: Tyrone Ting <kfting@nuvoton.com>\nL: qemu-arm@nongnu.org\nS: Supported\nF: hw/*/npcm7xx*\nF: include/hw/*/npcm7xx*\nF: tests/qtest/npcm7xx*\nF: pc-bios/npcm7xx_bootrom.bin\nF: roms/vbootrom\nF: docs/system/arm/nuvoton.rst\n\nnSeries\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/nseries.c\nF: hw/display/blizzard.c\nF: hw/input/lm832x.c\nF: hw/input/tsc2005.c\nF: hw/misc/cbus.c\nF: hw/rtc/twl92230.c\nF: include/hw/display/blizzard.h\nF: include/hw/input/lm832x.h\nF: include/hw/input/tsc2xxx.h\nF: include/hw/misc/cbus.h\nF: tests/avocado/machine_arm_n8x0.py\nF: docs/system/arm/nseries.rst\n\nPalm\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/palm.c\nF: hw/input/tsc210x.c\nF: include/hw/input/tsc2xxx.h\nF: docs/system/arm/palm.rst\n\nRaspberry Pi\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/raspi.c\nF: hw/arm/raspi_platform.h\nF: hw/*/bcm283*\nF: include/hw/arm/raspi*\nF: include/hw/*/bcm283*\nF: docs/system/arm/raspi.rst\n\nReal View\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/realview*\nF: hw/cpu/realview_mpcore.c\nF: hw/intc/realview_gic.c\nF: include/hw/intc/realview_gic.h\nF: docs/system/arm/realview.rst\n\nPXA2XX\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/mainstone.c\nF: hw/arm/spitz.c\nF: hw/arm/tosa.c\nF: hw/arm/z2.c\nF: hw/*/pxa2xx*\nF: hw/display/tc6393xb.c\nF: hw/gpio/max7310.c\nF: hw/gpio/zaurus.c\nF: hw/misc/mst_fpga.c\nF: hw/adc/max111x.c\nF: include/hw/adc/max111x.h\nF: include/hw/arm/pxa.h\nF: include/hw/arm/sharpsl.h\nF: include/hw/display/tc6393xb.h\nF: docs/system/arm/xscale.rst\nF: docs/system/arm/mainstone.rst\n\nSABRELITE / i.MX6\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Jean-Christophe Dubois <jcd@tribudubois.net>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/sabrelite.c\nF: hw/arm/fsl-imx6.c\nF: hw/misc/imx6_*.c\nF: hw/ssi/imx_spi.c\nF: hw/usb/imx-usb-phy.c\nF: include/hw/usb/imx-usb-phy.h\nF: include/hw/arm/fsl-imx6.h\nF: include/hw/misc/imx6_*.h\nF: include/hw/ssi/imx_spi.h\n\nSBSA-REF\nM: Radoslaw Biernacki <rad@semihalf.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Leif Lindholm <quic_llindhol@quicinc.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/sbsa-ref.c\nF: docs/system/arm/sbsa.rst\n\nSharp SL-5500 (Collie) PDA\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Odd Fixes\nF: hw/arm/collie.c\nF: hw/arm/strongarm*\nF: docs/system/arm/collie.rst\n\nStellaris\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/stellaris*\nF: include/hw/input/gamepad.h\nF: docs/system/arm/stellaris.rst\n\nSTM32VLDISCOVERY\nM: Alexandre Iooss <erdnaxe@crans.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/stm32vldiscovery.c\nF: docs/system/arm/stm32.rst\n\nVersatile Express\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/vexpress.c\nF: docs/system/arm/vexpress.rst\n\nVersatile PB\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/versatile*\nF: include/hw/i2c/arm_sbcon_i2c.h\nF: hw/misc/arm_sysctl.c\nF: docs/system/arm/versatile.rst\n\nVirt\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/virt*\nF: include/hw/arm/virt.h\nF: docs/system/arm/virt.rst\nF: tests/avocado/machine_aarch64_virt.py\n\nXilinx Zynq\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nM: Alistair Francis <alistair@alistair23.me>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/xilinx_*\nF: hw/*/cadence_*\nF: hw/misc/zynq_slcr.c\nF: hw/adc/zynq-xadc.c\nF: include/hw/misc/zynq_slcr.h\nF: include/hw/adc/zynq-xadc.h\nX: hw/ssi/xilinx_*\n\nXilinx ZynqMP and Versal\nM: Alistair Francis <alistair@alistair23.me>\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/xlnx*.c\nF: include/hw/*/xlnx*.h\nF: include/hw/ssi/xilinx_spips.h\nF: hw/display/dpcd.c\nF: include/hw/display/dpcd.h\nF: docs/system/arm/xlnx-versal-virt.rst\n\nXilinx Versal OSPI\nM: Francisco Iglesias <francisco.iglesias@xilinx.com>\nS: Maintained\nF: hw/ssi/xlnx-versal-ospi.c\nF: include/hw/ssi/xlnx-versal-ospi.h\n\nARM ACPI Subsystem\nM: Shannon Zhao <shannon.zhaosl@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/virt-acpi-build.c\n\nSTM32F100\nM: Alexandre Iooss <erdnaxe@crans.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/stm32f100_soc.c\n\nSTM32F205\nM: Alistair Francis <alistair@alistair23.me>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/stm32f205_soc.c\nF: hw/misc/stm32f2xx_syscfg.c\nF: hw/char/stm32f2xx_usart.c\nF: hw/timer/stm32f2xx_timer.c\nF: hw/adc/*\nF: hw/ssi/stm32f2xx_spi.c\nF: include/hw/*/stm32*.h\n\nSTM32F405\nM: Alistair Francis <alistair@alistair23.me>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/stm32f405_soc.c\nF: hw/misc/stm32f4xx_syscfg.c\nF: hw/misc/stm32f4xx_exti.c\n\nNetduino 2\nM: Alistair Francis <alistair@alistair23.me>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/netduino2.c\n\nNetduino Plus 2\nM: Alistair Francis <alistair@alistair23.me>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/netduinoplus2.c\n\nSmartFusion2\nM: Subbaraya Sundeep <sundeep.lkml@gmail.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/msf2-soc.c\nF: hw/misc/msf2-sysreg.c\nF: hw/timer/mss-timer.c\nF: hw/ssi/mss-spi.c\nF: include/hw/arm/msf2-soc.h\nF: include/hw/misc/msf2-sysreg.h\nF: include/hw/timer/mss-timer.h\nF: include/hw/ssi/mss-spi.h\nF: hw/net/msf2-emac.c\nF: include/hw/net/msf2-emac.h\n\nEmcraft M2S-FG484\nM: Subbaraya Sundeep <sundeep.lkml@gmail.com>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/arm/msf2-som.c\nF: docs/system/arm/emcraft-sf2.rst\n\nASPEED BMCs\nM: Cédric Le Goater <clg@kaod.org>\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Andrew Jeffery <andrew@aj.id.au>\nR: Joel Stanley <joel@jms.id.au>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/*aspeed*\nF: hw/misc/pca9552.c\nF: include/hw/*/*aspeed*\nF: include/hw/misc/pca9552*.h\nF: hw/net/ftgmac100.c\nF: include/hw/net/ftgmac100.h\nF: docs/system/arm/aspeed.rst\nF: tests/qtest/*aspeed*\nF: hw/arm/fby35.c\n\nNRF51\nM: Joel Stanley <joel@jms.id.au>\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/nrf51*.c\nF: hw/*/microbit*.c\nF: include/hw/*/nrf51*.h\nF: include/hw/*/microbit*.h\nF: tests/qtest/microbit-test.c\nF: docs/system/arm/nrf.rst\n\nAVR Machines\n-------------\n\nAVR MCUs\nM: Michael Rolnik <mrolnik@gmail.com>\nS: Maintained\nF: configs/devices/avr-softmmu/default.mak\nF: hw/avr/\nF: include/hw/char/avr_usart.h\nF: hw/char/avr_usart.c\nF: include/hw/timer/avr_timer16.h\nF: hw/timer/avr_timer16.c\nF: include/hw/misc/avr_power.h\nF: hw/misc/avr_power.c\n\nArduino\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Maintained\nF: hw/avr/arduino.c\n\nCRIS Machines\n-------------\nAxis Dev88\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/cris/axis_dev88.c\nF: hw/*/etraxfs_*.c\n\nHP-PARISC Machines\n------------------\nHP B160L\nM: Richard Henderson <richard.henderson@linaro.org>\nR: Helge Deller <deller@gmx.de>\nS: Odd Fixes\nF: configs/devices/hppa-softmmu/default.mak\nF: hw/hppa/\nF: hw/net/*i82596*\nF: hw/misc/lasi.c\nF: hw/pci-host/dino.c\nF: include/hw/misc/lasi.h\nF: include/hw/net/lasi_82596.h\nF: include/hw/pci-host/dino.h\nF: pc-bios/hppa-firmware.img\n\nLoongArch Machines\n------------------\nVirt\nM: Xiaojuan Yang <yangxiaojuan@loongson.cn>\nM: Song Gao <gaosong@loongson.cn>\nS: Maintained\nF: docs/system/loongarch/virt.rst\nF: configs/targets/loongarch64-softmmu.mak\nF: configs/devices/loongarch64-softmmu/default.mak\nF: hw/loongarch/\nF: include/hw/loongarch/virt.h\nF: include/hw/intc/loongarch_*.h\nF: hw/intc/loongarch_*.c\nF: include/hw/pci-host/ls7a.h\nF: hw/rtc/ls7a_rtc.c\nF: gdb-xml/loongarch*.xml\n\nM68K Machines\n-------------\nan5206\nM: Thomas Huth <huth@tuxfamily.org>\nS: Odd Fixes\nF: hw/m68k/an5206.c\nF: hw/m68k/mcf5206.c\n\nmcf5208\nM: Thomas Huth <huth@tuxfamily.org>\nS: Odd Fixes\nF: hw/m68k/mcf5208.c\nF: hw/m68k/mcf_intc.c\nF: hw/char/mcf_uart.c\nF: hw/net/mcf_fec.c\nF: include/hw/m68k/mcf*.h\n\nNeXTcube\nM: Thomas Huth <huth@tuxfamily.org>\nS: Odd Fixes\nF: hw/m68k/next-*.c\nF: hw/display/next-fb.c\nF: include/hw/m68k/next-cube.h\n\nq800\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nF: hw/m68k/q800.c\nF: hw/misc/mac_via.c\nF: hw/nubus/*\nF: hw/display/macfb.c\nF: hw/block/swim.c\nF: hw/m68k/bootinfo.h\nF: include/standard-headers/asm-m68k/bootinfo.h\nF: include/standard-headers/asm-m68k/bootinfo-mac.h\nF: include/hw/misc/mac_via.h\nF: include/hw/nubus/*\nF: include/hw/display/macfb.h\nF: include/hw/block/swim.h\n\nvirt\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nF: hw/m68k/virt.c\nF: hw/char/goldfish_tty.c\nF: hw/intc/goldfish_pic.c\nF: hw/intc/m68k_irqc.c\nF: hw/misc/virt_ctrl.c\nF: include/hw/char/goldfish_tty.h\nF: include/hw/intc/goldfish_pic.h\nF: include/hw/intc/m68k_irqc.h\nF: include/hw/misc/virt_ctrl.h\n\nMicroBlaze Machines\n-------------------\npetalogix_s3adsp1800\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/microblaze/petalogix_s3adsp1800_mmu.c\nF: include/hw/char/xilinx_uartlite.h\nF: tests/avocado/machine_microblaze.py\n\npetalogix_ml605\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/microblaze/petalogix_ml605_mmu.c\n\nMIPS Machines\n-------------\nOverall MIPS Machines\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Odd Fixes\nF: configs/devices/mips*/*\nF: hw/mips/\nF: include/hw/mips/\n\nJazz\nM: Hervé Poussineau <hpoussin@reactos.org>\nR: Aleksandar Rikalo <aleksandar.rikalo@syrmia.com>\nS: Maintained\nF: hw/mips/jazz.c\nF: hw/display/jazz_led.c\nF: hw/dma/rc4030.c\n\nMalta\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Aurelien Jarno <aurelien@aurel32.net>\nS: Odd Fixes\nF: hw/isa/piix4.c\nF: hw/acpi/piix4.c\nF: hw/mips/malta.c\nF: hw/mips/gt64xxx_pci.c\nF: include/hw/southbridge/piix.h\nF: tests/avocado/linux_ssh_mips_malta.py\nF: tests/avocado/machine_mips_malta.py\n\nMipssim\nR: Aleksandar Rikalo <aleksandar.rikalo@syrmia.com>\nS: Orphan\nF: hw/mips/mipssim.c\nF: hw/net/mipsnet.c\n\nFuloong 2E\nM: Huacai Chen <chenhuacai@kernel.org>\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Jiaxun Yang <jiaxun.yang@flygoat.com>\nS: Odd Fixes\nF: hw/mips/fuloong2e.c\nF: hw/isa/vt82c686.c\nF: hw/pci-host/bonito.c\nF: hw/usb/vt82c686-uhci-pci.c\nF: include/hw/isa/vt82c686.h\nF: tests/avocado/machine_mips_fuloong2e.py\n\nLoongson-3 virtual platforms\nM: Huacai Chen <chenhuacai@kernel.org>\nR: Jiaxun Yang <jiaxun.yang@flygoat.com>\nS: Maintained\nF: hw/intc/loongson_liointc.c\nF: hw/mips/loongson3_bootp.c\nF: hw/mips/loongson3_bootp.h\nF: hw/mips/loongson3_virt.c\nF: tests/avocado/machine_mips_loongson3v.py\n\nBoston\nM: Paul Burton <paulburton@kernel.org>\nR: Aleksandar Rikalo <aleksandar.rikalo@syrmia.com>\nS: Odd Fixes\nF: hw/core/loader-fit.c\nF: hw/mips/boston.c\nF: hw/pci-host/xilinx-pcie.c\nF: include/hw/pci-host/xilinx-pcie.h\n\nOpenRISC Machines\n-----------------\nor1k-sim\nM: Jia Liu <proljc@gmail.com>\nS: Maintained\nF: hw/openrisc/openrisc_sim.c\n\nPowerPC Machines\n----------------\n405 (ref405ep and taihu)\nL: qemu-ppc@nongnu.org\nS: Orphan\nF: hw/ppc/ppc405_boards.c\n\nBamboo\nL: qemu-ppc@nongnu.org\nS: Orphan\nF: hw/ppc/ppc440_bamboo.c\nF: tests/avocado/ppc_bamboo.py\n\ne500\nL: qemu-ppc@nongnu.org\nS: Orphan\nF: hw/ppc/e500*\nF: hw/gpio/mpc8xxx.c\nF: hw/i2c/mpc_i2c.c\nF: hw/net/fsl_etsec/\nF: hw/pci-host/ppce500.c\nF: include/hw/ppc/ppc_e500.h\nF: include/hw/pci-host/ppce500.h\nF: pc-bios/u-boot.e500\nF: hw/intc/openpic_kvm.h\nF: include/hw/ppc/openpic_kvm.h\n\nmpc8544ds\nL: qemu-ppc@nongnu.org\nS: Orphan\nF: hw/ppc/mpc8544ds.c\nF: hw/ppc/mpc8544_guts.c\nF: tests/avocado/ppc_mpc8544ds.py\n\nNew World (mac99)\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: docs/system/ppc/powermac.rst\nF: hw/ppc/mac_newworld.c\nF: hw/pci-host/uninorth.c\nF: hw/pci-bridge/dec.[hc]\nF: hw/misc/macio/\nF: hw/misc/mos6522.c\nF: hw/nvram/mac_nvram.c\nF: hw/input/adb*\nF: include/hw/misc/macio/\nF: include/hw/misc/mos6522.h\nF: include/hw/ppc/mac_dbdma.h\nF: include/hw/pci-host/uninorth.h\nF: include/hw/input/adb*\nF: pc-bios/qemu_vga.ndrv\n\nOld World (g3beige)\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: docs/system/ppc/powermac.rst\nF: hw/ppc/mac_oldworld.c\nF: hw/pci-host/grackle.c\nF: hw/misc/macio/\nF: hw/intc/heathrow_pic.c\nF: hw/input/adb*\nF: include/hw/intc/heathrow_pic.h\nF: include/hw/input/adb*\nF: pc-bios/qemu_vga.ndrv\n\nPReP\nM: Hervé Poussineau <hpoussin@reactos.org>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: docs/system/ppc/prep.rst\nF: hw/ppc/prep.c\nF: hw/ppc/prep_systemio.c\nF: hw/ppc/rs6000_mc.c\nF: hw/pci-host/raven.c\nF: hw/isa/i82378.c\nF: hw/isa/pc87312.c\nF: hw/dma/i82374.c\nF: hw/rtc/m48t59-isa.c\nF: include/hw/isa/pc87312.h\nF: include/hw/rtc/m48t59.h\nF: tests/avocado/ppc_prep_40p.py\n\nsPAPR (pseries)\nM: Cédric Le Goater <clg@kaod.org>\nM: Daniel Henrique Barboza <danielhb413@gmail.com>\nR: David Gibson <david@gibson.dropbear.id.au>\nR: Greg Kurz <groug@kaod.org>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/*/spapr*\nF: include/hw/*/spapr*\nF: hw/*/xics*\nF: include/hw/*/xics*\nF: pc-bios/slof.bin\nF: docs/system/ppc/pseries.rst\nF: docs/specs/ppc-spapr-*\nF: tests/qtest/spapr*\nF: tests/qtest/libqos/*spapr*\nF: tests/qtest/rtas*\nF: tests/qtest/libqos/rtas*\nF: tests/avocado/ppc_pseries.py\n\nPowerNV (Non-Virtualized)\nM: Cédric Le Goater <clg@kaod.org>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: docs/system/ppc/powernv.rst\nF: hw/ppc/pnv*\nF: hw/intc/pnv*\nF: hw/intc/xics_pnv.c\nF: hw/pci-host/pnv*\nF: include/hw/ppc/pnv*\nF: include/hw/pci-host/pnv*\nF: pc-bios/skiboot.lid\nF: tests/qtest/pnv*\n\nvirtex_ml507\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nL: qemu-ppc@nongnu.org\nS: Odd Fixes\nF: hw/ppc/virtex_ml507.c\nF: tests/avocado/ppc_virtex_ml507.py\n\nsam460ex\nM: BALATON Zoltan <balaton@eik.bme.hu>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/ppc/sam460ex.c\nF: hw/ppc/ppc440_pcix.c\nF: hw/display/sm501*\nF: hw/ide/sii3112.c\nF: hw/rtc/m41t80.c\nF: pc-bios/canyonlands.dt[sb]\nF: pc-bios/u-boot-sam460ex-20100605.bin\nF: roms/u-boot-sam460ex\n\npegasos2\nM: BALATON Zoltan <balaton@eik.bme.hu>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/ppc/pegasos2.c\nF: hw/pci-host/mv64361.c\nF: hw/pci-host/mv643xx.h\nF: include/hw/pci-host/mv64361.h\n\nVirtual Open Firmware (VOF)\nM: Alexey Kardashevskiy <aik@ozlabs.ru>\nR: Cédric Le Goater <clg@kaod.org>\nR: Daniel Henrique Barboza <danielhb413@gmail.com>\nR: David Gibson <david@gibson.dropbear.id.au>\nR: Greg Kurz <groug@kaod.org>\nL: qemu-ppc@nongnu.org\nS: Maintained\nF: hw/ppc/spapr_vof*\nF: hw/ppc/vof*\nF: include/hw/ppc/vof*\nF: pc-bios/vof/*\nF: pc-bios/vof*\n\nRISC-V Machines\n---------------\nOpenTitan\nM: Alistair Francis <Alistair.Francis@wdc.com>\nL: qemu-riscv@nongnu.org\nS: Supported\nF: hw/riscv/opentitan.c\nF: hw/*/ibex_*.c\nF: include/hw/riscv/opentitan.h\nF: include/hw/*/ibex_*.h\n\nMicrochip PolarFire SoC Icicle Kit\nM: Bin Meng <bin.meng@windriver.com>\nL: qemu-riscv@nongnu.org\nS: Supported\nF: hw/riscv/microchip_pfsoc.c\nF: hw/char/mchp_pfsoc_mmuart.c\nF: hw/misc/mchp_pfsoc_dmc.c\nF: hw/misc/mchp_pfsoc_ioscb.c\nF: hw/misc/mchp_pfsoc_sysreg.c\nF: include/hw/riscv/microchip_pfsoc.h\nF: include/hw/char/mchp_pfsoc_mmuart.h\nF: include/hw/misc/mchp_pfsoc_dmc.h\nF: include/hw/misc/mchp_pfsoc_ioscb.h\nF: include/hw/misc/mchp_pfsoc_sysreg.h\n\nShakti C class SoC\nM: Vijai Kumar K <vijai@behindbytes.com>\nL: qemu-riscv@nongnu.org\nS: Supported\nF: hw/riscv/shakti_c.c\nF: hw/char/shakti_uart.c\nF: include/hw/riscv/shakti_c.h\nF: include/hw/char/shakti_uart.h\n\nSiFive Machines\nM: Alistair Francis <Alistair.Francis@wdc.com>\nM: Bin Meng <bin.meng@windriver.com>\nM: Palmer Dabbelt <palmer@dabbelt.com>\nL: qemu-riscv@nongnu.org\nS: Supported\nF: hw/*/*sifive*.c\nF: include/hw/*/*sifive*.h\n\nRX Machines\n-----------\nrx-gdbsim\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nS: Orphan\nF: docs/system/target-rx.rst\nF: hw/rx/rx-gdbsim.c\nF: tests/avocado/machine_rx_gdbsim.py\n\nSH4 Machines\n------------\nR2D\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nR: Magnus Damm <magnus.damm@gmail.com>\nS: Odd Fixes\nF: hw/char/sh_serial.c\nF: hw/sh4/r2d.c\nF: hw/intc/sh_intc.c\nF: hw/pci-host/sh_pci.c\nF: hw/timer/sh_timer.c\nF: include/hw/sh4/sh_intc.h\n\nShix\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nR: Magnus Damm <magnus.damm@gmail.com>\nS: Odd Fixes\nF: hw/block/tc58128.c\nF: hw/char/sh_serial.c\nF: hw/sh4/shix.c\nF: hw/intc/sh_intc.c\nF: hw/timer/sh_timer.c\nF: include/hw/sh4/sh_intc.h\n\nSPARC Machines\n--------------\nSun4m\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nS: Maintained\nF: hw/sparc/sun4m.c\nF: hw/sparc/sun4m_iommu.c\nF: hw/display/cg3.c\nF: hw/display/tcx.c\nF: hw/dma/sparc32_dma.c\nF: hw/misc/eccmemctl.c\nF: hw/*/slavio_*.c\nF: include/hw/nvram/sun_nvram.h\nF: include/hw/sparc/sparc32_dma.h\nF: include/hw/sparc/sun4m_iommu.h\nF: pc-bios/openbios-sparc32\n\nSun4u\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nS: Maintained\nF: hw/sparc64/sun4u.c\nF: hw/sparc64/sun4u_iommu.c\nF: include/hw/sparc/sun4u_iommu.h\nF: hw/pci-host/sabre.c\nF: include/hw/pci-host/sabre.h\nF: hw/pci-bridge/simba.c\nF: include/hw/pci-bridge/simba.h\nF: pc-bios/openbios-sparc64\nF: tests/avocado/machine_sparc64_sun4u.py\n\nSun4v\nM: Artyom Tarasenko <atar4qemu@gmail.com>\nS: Maintained\nF: hw/sparc64/niagara.c\nF: hw/rtc/sun4v-rtc.c\nF: include/hw/rtc/sun4v-rtc.h\n\nLeon3\nM: Fabien Chouteau <chouteau@adacore.com>\nM: Frederic Konrad <konrad.frederic@yahoo.fr>\nS: Maintained\nF: hw/sparc/leon3.c\nF: hw/*/grlib*\nF: include/hw/*/grlib*\nF: tests/avocado/machine_sparc_leon3.py\n\nS390 Machines\n-------------\nS390 Virtio-ccw\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nM: Eric Farman <farman@linux.ibm.com>\nS: Supported\nF: hw/s390x/\nF: include/hw/s390x/\nF: configs/devices/s390x-softmmu/default.mak\nF: tests/avocado/machine_s390_ccw_virtio.py\nT: git https://github.com/borntraeger/qemu.git s390-next\nL: qemu-s390x@nongnu.org\n\nS390-ccw boot\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nM: Thomas Huth <thuth@redhat.com>\nS: Supported\nF: hw/s390x/ipl.*\nF: pc-bios/s390-ccw/\nF: pc-bios/s390-ccw.img\nF: docs/devel/s390-dasd-ipl.rst\nT: git https://github.com/borntraeger/qemu.git s390-next\nL: qemu-s390x@nongnu.org\n\nS390 PCI\nM: Matthew Rosato <mjrosato@linux.ibm.com>\nM: Eric Farman <farman@linux.ibm.com>\nS: Supported\nF: hw/s390x/s390-pci*\nF: include/hw/s390x/s390-pci*\nL: qemu-s390x@nongnu.org\n\nS390 channel subsystem\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nM: Eric Farman <farman@linux.ibm.com>\nS: Supported\nF: hw/s390x/ccw-device.[ch]\nF: hw/s390x/css.c\nF: hw/s390x/css-bridge.c\nF: include/hw/s390x/css.h\nF: include/hw/s390x/css-bridge.h\nF: include/hw/s390x/ioinst.h\nF: target/s390x/ioinst.c\nL: qemu-s390x@nongnu.org\n\nS390 CPU models\nM: David Hildenbrand <david@redhat.com>\nS: Maintained\nF: target/s390x/cpu_features*.[ch]\nF: target/s390x/cpu_models.[ch]\nL: qemu-s390x@nongnu.org\n\nS390 SCLP-backed devices\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nS: Supported\nF: include/hw/s390x/event-facility.h\nF: include/hw/s390x/sclp.h\nF: hw/char/sclp*.[hc]\nF: hw/s390x/event-facility.c\nF: hw/s390x/sclp*.c\nL: qemu-s390x@nongnu.org\n\nX86 Machines\n------------\nPC\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Marcel Apfelbaum <marcel.apfelbaum@gmail.com>\nS: Supported\nF: include/hw/i386/\nF: hw/i386/\nF: hw/pci-host/i440fx.c\nF: hw/pci-host/q35.c\nF: hw/pci-host/pam.c\nF: include/hw/pci-host/i440fx.h\nF: include/hw/pci-host/q35.h\nF: include/hw/pci-host/pam.h\nF: hw/isa/piix3.c\nF: hw/isa/lpc_ich9.c\nF: hw/i2c/smbus_ich9.c\nF: hw/acpi/piix4.c\nF: hw/acpi/ich9.c\nF: include/hw/acpi/ich9.h\nF: include/hw/southbridge/piix.h\nF: hw/misc/sga.c\nF: hw/isa/apm.c\nF: include/hw/isa/apm.h\nF: tests/unit/test-x86-cpuid.c\nF: tests/qtest/test-x86-cpuid-compat.c\n\nPC Chipset\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Supported\nF: hw/char/debugcon.c\nF: hw/char/parallel*\nF: hw/char/serial*\nF: hw/dma/i8257*\nF: hw/i2c/pm_smbus.c\nF: hw/input/pckbd.c\nF: hw/intc/apic*\nF: hw/intc/ioapic*\nF: hw/intc/i8259*\nF: hw/isa/isa-superio.c\nF: hw/misc/debugexit.c\nF: hw/misc/pc-testdev.c\nF: hw/timer/hpet*\nF: hw/timer/i8254*\nF: hw/rtc/mc146818rtc*\nF: hw/watchdog/wdt_ib700.c\nF: hw/watchdog/wdt_i6300esb.c\nF: include/hw/display/vga.h\nF: include/hw/char/parallel.h\nF: include/hw/dma/i8257.h\nF: include/hw/i2c/pm_smbus.h\nF: include/hw/input/i8042.h\nF: include/hw/isa/i8259_internal.h\nF: include/hw/isa/superio.h\nF: include/hw/timer/hpet.h\nF: include/hw/timer/i8254*\nF: include/hw/rtc/mc146818rtc*\n\nmicrovm\nM: Sergio Lopez <slp@redhat.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: docs/system/i386/microvm.rst\nF: hw/i386/microvm.c\nF: include/hw/i386/microvm.h\nF: pc-bios/bios-microvm.bin\n\nMachine core\nM: Eduardo Habkost <eduardo@habkost.net>\nM: Marcel Apfelbaum <marcel.apfelbaum@gmail.com>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Yanan Wang <wangyanan55@huawei.com>\nS: Supported\nF: cpu.c\nF: hw/core/cpu.c\nF: hw/core/machine-qmp-cmds.c\nF: hw/core/machine.c\nF: hw/core/machine-smp.c\nF: hw/core/null-machine.c\nF: hw/core/numa.c\nF: hw/cpu/cluster.c\nF: qapi/machine.json\nF: qapi/machine-target.json\nF: include/hw/boards.h\nF: include/hw/core/cpu.h\nF: include/hw/cpu/cluster.h\nF: include/sysemu/numa.h\nF: tests/unit/test-smp-parse.c\nT: git https://gitlab.com/ehabkost/qemu.git machine-next\n\nXtensa Machines\n---------------\nsim\nM: Max Filippov <jcmvbkbc@gmail.com>\nS: Maintained\nF: hw/xtensa/sim.c\n\nvirt\nM: Max Filippov <jcmvbkbc@gmail.com>\nS: Maintained\nF: hw/xtensa/virt.c\n\nXTFPGA (LX60, LX200, ML605, KC705)\nM: Max Filippov <jcmvbkbc@gmail.com>\nS: Maintained\nF: hw/xtensa/xtfpga.c\nF: hw/net/opencores_eth.c\n\nDevices\n-------\nOverall Audio frontends\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: hw/audio/\nF: include/hw/audio/\nF: tests/qtest/ac97-test.c\nF: tests/qtest/es1370-test.c\nF: tests/qtest/intel-hda-test.c\nF: tests/qtest/fuzz-sb16-test.c\n\nXilinx CAN\nM: Vikram Garhwal <fnu.vikram@xilinx.com>\nM: Francisco Iglesias <francisco.iglesias@xilinx.com>\nS: Maintained\nF: hw/net/can/xlnx-*\nF: include/hw/net/xlnx-*\nF: tests/qtest/xlnx-can-test*\n\nEDU\nM: Jiri Slaby <jslaby@suse.cz>\nS: Maintained\nF: hw/misc/edu.c\n\nIDE\nM: John Snow <jsnow@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: include/hw/ide.h\nF: include/hw/ide/\nF: hw/ide/\nF: hw/block/block.c\nF: hw/block/cdrom.c\nF: hw/block/hd-geometry.c\nF: tests/qtest/ide-test.c\nF: tests/qtest/ahci-test.c\nF: tests/qtest/cdrom-test.c\nF: tests/qtest/libqos/ahci*\nT: git https://gitlab.com/jsnow/qemu.git ide\n\nIPMI\nM: Corey Minyard <minyard@acm.org>\nS: Maintained\nF: include/hw/ipmi/*\nF: hw/ipmi/*\nF: hw/smbios/smbios_type_38.c\nF: tests/qtest/ipmi*\nT: git https://github.com/cminyard/qemu.git master-ipmi-rebase\n\nFloppy\nM: John Snow <jsnow@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/block/fdc.c\nF: hw/block/fdc-internal.h\nF: hw/block/fdc-isa.c\nF: hw/block/fdc-sysbus.c\nF: include/hw/block/fdc.h\nF: tests/qtest/fdc-test.c\nT: git https://gitlab.com/jsnow/qemu.git ide\n\nHyper-V VMBus\nM: Maciej S. Szmigiero <maciej.szmigiero@oracle.com>\nS: Odd Fixes\nF: hw/hyperv/vmbus.c\nF: include/hw/hyperv/vmbus*.h\n\nOMAP\nM: Peter Maydell <peter.maydell@linaro.org>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/*/omap*\nF: include/hw/arm/omap.h\nF: docs/system/arm/sx1.rst\n\nIPack\nM: Alberto Garcia <berto@igalia.com>\nS: Odd Fixes\nF: hw/char/ipoctal232.c\nF: hw/ipack/\n\nPCI\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Marcel Apfelbaum <marcel.apfelbaum@gmail.com>\nS: Supported\nF: include/hw/pci/*\nF: hw/misc/pci-testdev.c\nF: hw/pci/*\nF: hw/pci-bridge/*\nF: qapi/pci.json\nF: docs/pci*\nF: docs/specs/*pci*\n\nACPI/SMBIOS\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Igor Mammedov <imammedo@redhat.com>\nR: Ani Sinha <ani@anisinha.ca>\nS: Supported\nF: include/hw/acpi/*\nF: include/hw/firmware/smbios.h\nF: hw/acpi/*\nF: hw/smbios/*\nF: hw/i386/acpi-build.[hc]\nF: hw/arm/virt-acpi-build.c\nF: qapi/acpi.json\nF: tests/qtest/bios-tables-test*\nF: tests/qtest/acpi-utils.[hc]\nF: tests/data/acpi/\nF: docs/specs/acpi_cpu_hotplug.rst\nF: docs/specs/acpi_mem_hotplug.rst\nF: docs/specs/acpi_nvdimm.rst\nF: docs/specs/acpi_pci_hotplug.rst\nF: docs/specs/acpi_hw_reduced_hotplug.rst\n\nACPI/VIOT\nM: Jean-Philippe Brucker <jean-philippe@linaro.org>\nS: Supported\nF: hw/acpi/viot.c\nF: hw/acpi/viot.h\n\nACPI/HEST/GHES\nR: Dongjiu Geng <gengdongjiu1@gmail.com>\nL: qemu-arm@nongnu.org\nS: Maintained\nF: hw/acpi/ghes.c\nF: include/hw/acpi/ghes.h\nF: docs/specs/acpi_hest_ghes.rst\n\nppc4xx\nL: qemu-ppc@nongnu.org\nS: Orphan\nF: hw/ppc/ppc4*.c\nF: hw/i2c/ppc4xx_i2c.c\nF: include/hw/ppc/ppc4xx.h\nF: include/hw/i2c/ppc4xx_i2c.h\nF: hw/intc/ppc-uic.c\nF: include/hw/intc/ppc-uic.h\n\nCharacter devices\nM: Marc-André Lureau <marcandre.lureau@redhat.com>\nR: Paolo Bonzini <pbonzini@redhat.com>\nS: Odd Fixes\nF: hw/char/\n\nNetwork devices\nM: Jason Wang <jasowang@redhat.com>\nS: Odd Fixes\nF: hw/net/\nF: include/hw/net/\nF: tests/qtest/virtio-net-test.c\nF: docs/virtio-net-failover.rst\nT: git https://github.com/jasowang/qemu.git net\n\nParallel NOR Flash devices\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nT: git https://gitlab.com/philmd/qemu.git pflash-next\nS: Maintained\nF: hw/block/pflash_cfi*.c\nF: include/hw/block/flash.h\n\nSCSI\nM: Paolo Bonzini <pbonzini@redhat.com>\nR: Fam Zheng <fam@euphon.net>\nS: Supported\nF: include/hw/scsi/*\nF: hw/scsi/*\nF: tests/qtest/virtio-scsi-test.c\nF: tests/qtest/fuzz-virtio-scsi-test.c\nF: tests/qtest/am53c974-test.c\nF: tests/qtest/fuzz-lsi53c895a-test.c\nT: git https://github.com/bonzini/qemu.git scsi-next\n\nSSI\nM: Alistair Francis <alistair@alistair23.me>\nS: Maintained\nF: hw/ssi/*\nF: hw/block/m25p80.c\nF: include/hw/ssi/ssi.h\nX: hw/ssi/xilinx_*\nF: tests/qtest/m25p80-test.c\n\nXilinx SPI\nM: Alistair Francis <alistair@alistair23.me>\nS: Maintained\nF: hw/ssi/xilinx_*\n\nSD (Secure Card)\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nM: Bin Meng <bin.meng@windriver.com>\nL: qemu-block@nongnu.org\nS: Odd Fixes\nF: include/hw/sd/sd*\nF: hw/sd/core.c\nF: hw/sd/sd*\nF: hw/sd/ssi-sd.c\nF: tests/qtest/fuzz-sdcard-test.c\nF: tests/qtest/sdhci-test.c\n\nUSB\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: hw/usb/*\nF: stubs/usb-dev-stub.c\nF: tests/qtest/usb-*-test.c\nF: docs/system/devices/usb.rst\nF: include/hw/usb.h\nF: include/hw/usb/\n\nUSB (serial adapter)\nR: Gerd Hoffmann <kraxel@redhat.com>\nM: Samuel Thibault <samuel.thibault@ens-lyon.org>\nS: Maintained\nF: hw/usb/dev-serial.c\n\nVFIO\nM: Alex Williamson <alex.williamson@redhat.com>\nS: Supported\nF: hw/vfio/*\nF: include/hw/vfio/\nF: docs/igd-assign.txt\nF: docs/devel/vfio-migration.rst\n\nvfio-ccw\nM: Eric Farman <farman@linux.ibm.com>\nM: Matthew Rosato <mjrosato@linux.ibm.com>\nS: Supported\nF: hw/vfio/ccw.c\nF: hw/s390x/s390-ccw.c\nF: include/hw/s390x/s390-ccw.h\nF: include/hw/s390x/vfio-ccw.h\nL: qemu-s390x@nongnu.org\n\nvfio-ap\nM: Tony Krowiak <akrowiak@linux.ibm.com>\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Jason Herne <jjherne@linux.ibm.com>\nS: Supported\nF: hw/s390x/ap-device.c\nF: hw/s390x/ap-bridge.c\nF: include/hw/s390x/ap-device.h\nF: include/hw/s390x/ap-bridge.h\nF: hw/vfio/ap.c\nF: docs/system/s390x/vfio-ap.rst\nL: qemu-s390x@nongnu.org\n\nvhost\nM: Michael S. Tsirkin <mst@redhat.com>\nS: Supported\nF: hw/*/*vhost*\nF: docs/interop/vhost-user.json\nF: docs/interop/vhost-user.rst\nF: contrib/vhost-user-*/\nF: backends/vhost-user.c\nF: include/sysemu/vhost-user-backend.h\n\nvirtio\nM: Michael S. Tsirkin <mst@redhat.com>\nS: Supported\nF: hw/*/virtio*\nF: hw/virtio/Makefile.objs\nF: hw/virtio/trace-events\nF: net/vhost-user.c\nF: include/hw/virtio/\n\nvirtio-balloon\nM: Michael S. Tsirkin <mst@redhat.com>\nM: David Hildenbrand <david@redhat.com>\nS: Maintained\nF: docs/interop/virtio-balloon-stats.rst\nF: hw/virtio/virtio-balloon*.c\nF: include/hw/virtio/virtio-balloon.h\nF: softmmu/balloon.c\nF: include/sysemu/balloon.h\n\nvirtio-9p\nM: Greg Kurz <groug@kaod.org>\nM: Christian Schoenebeck <qemu_oss@crudebyte.com>\nS: Odd Fixes\nW: https://wiki.qemu.org/Documentation/9p\nF: hw/9pfs/\nX: hw/9pfs/xen-9p*\nF: fsdev/\nF: docs/tools/virtfs-proxy-helper.rst\nF: tests/qtest/virtio-9p-test.c\nT: git https://gitlab.com/gkurz/qemu.git 9p-next\nT: git https://github.com/cschoenebeck/qemu.git 9p.next\n\nvirtio-blk\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/block/virtio-blk.c\nF: hw/block/dataplane/*\nF: tests/qtest/virtio-blk-test.c\nT: git https://github.com/stefanha/qemu.git block\n\nvirtio-ccw\nM: Cornelia Huck <cohuck@redhat.com>\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Eric Farman <farman@linux.ibm.com>\nS: Supported\nF: hw/s390x/virtio-ccw*.[hc]\nF: hw/s390x/vhost-*-ccw.c\nT: git https://gitlab.com/cohuck/qemu.git s390-next\nT: git https://github.com/borntraeger/qemu.git s390-next\nL: qemu-s390x@nongnu.org\n\nvirtiofs\nM: Dr. David Alan Gilbert <dgilbert@redhat.com>\nM: Stefan Hajnoczi <stefanha@redhat.com>\nS: Supported\nF: tools/virtiofsd/*\nF: hw/virtio/vhost-user-fs*\nF: include/hw/virtio/vhost-user-fs.h\nF: docs/tools/virtiofsd.rst\nL: virtio-fs@redhat.com\n\nvirtio-input\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: hw/input/vhost-user-input.c\nF: hw/input/virtio-input*.c\nF: include/hw/virtio/virtio-input.h\nF: contrib/vhost-user-input/*\n\nvirtio-iommu\nM: Eric Auger <eric.auger@redhat.com>\nS: Maintained\nF: hw/virtio/virtio-iommu*.c\nF: include/hw/virtio/virtio-iommu.h\n\nvirtio-serial\nM: Laurent Vivier <lvivier@redhat.com>\nR: Amit Shah <amit@kernel.org>\nS: Supported\nF: hw/char/virtio-serial-bus.c\nF: hw/char/virtio-console.c\nF: include/hw/virtio/virtio-serial.h\nF: tests/qtest/virtio-serial-test.c\n\nvirtio-rng\nM: Laurent Vivier <lvivier@redhat.com>\nR: Amit Shah <amit@kernel.org>\nS: Supported\nF: hw/virtio/virtio-rng.c\nF: include/hw/virtio/virtio-rng.h\nF: include/sysemu/rng*.h\nF: backends/rng*.c\nF: tests/qtest/virtio-rng-test.c\n\nvhost-user-rng\nM: Mathieu Poirier <mathieu.poirier@linaro.org>\nS: Supported\nF: docs/tools/vhost-user-rng.rst\nF: hw/virtio/vhost-user-rng.c\nF: hw/virtio/vhost-user-rng-pci.c\nF: include/hw/virtio/vhost-user-rng.h\nF: tools/vhost-user-rng/*\n\nvirtio-crypto\nM: Gonglei <arei.gonglei@huawei.com>\nS: Supported\nF: hw/virtio/virtio-crypto.c\nF: hw/virtio/virtio-crypto-pci.c\nF: include/hw/virtio/virtio-crypto.h\n\nvirtio-mem\nM: David Hildenbrand <david@redhat.com>\nS: Supported\nW: https://virtio-mem.gitlab.io/\nF: hw/virtio/virtio-mem.c\nF: hw/virtio/virtio-mem-pci.h\nF: hw/virtio/virtio-mem-pci.c\nF: include/hw/virtio/virtio-mem.h\n\nnvme\nM: Keith Busch <kbusch@kernel.org>\nM: Klaus Jensen <its@irrelevant.dk>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/nvme/*\nF: include/block/nvme.h\nF: tests/qtest/nvme-test.c\nF: docs/system/nvme.rst\nT: git git://git.infradead.org/qemu-nvme.git nvme-next\n\nmegasas\nM: Hannes Reinecke <hare@suse.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: hw/scsi/megasas.c\nF: hw/scsi/mfi.h\nF: tests/qtest/megasas-test.c\nF: tests/qtest/fuzz-megasas-test.c\n\nNetwork packet abstractions\nM: Dmitry Fleytman <dmitry.fleytman@gmail.com>\nS: Maintained\nF: include/net/eth.h\nF: net/eth.c\nF: hw/net/net_rx_pkt*\nF: hw/net/net_tx_pkt*\n\nVmware\nM: Dmitry Fleytman <dmitry.fleytman@gmail.com>\nS: Maintained\nF: hw/net/vmxnet*\nF: hw/scsi/vmw_pvscsi*\nF: tests/qtest/vmxnet3-test.c\n\nRocker\nM: Jiri Pirko <jiri@resnulli.us>\nS: Maintained\nF: hw/net/rocker/\nF: qapi/rocker.json\nF: tests/rocker/\nF: docs/specs/rocker.txt\n\ne1000x\nM: Dmitry Fleytman <dmitry.fleytman@gmail.com>\nS: Maintained\nF: hw/net/e1000x*\n\ne1000e\nM: Dmitry Fleytman <dmitry.fleytman@gmail.com>\nS: Maintained\nF: hw/net/e1000e*\nF: tests/qtest/fuzz-e1000e-test.c\n\neepro100\nM: Stefan Weil <sw@weilnetz.de>\nS: Maintained\nF: hw/net/eepro100.c\n\ntulip\nM: Sven Schnelle <svens@stackframe.org>\nS: Maintained\nF: hw/net/tulip.c\nF: hw/net/tulip.h\n\npca954x\nM: Patrick Venture <venture@google.com>\nS: Maintained\nF: hw/i2c/i2c_mux_pca954x.c\nF: include/hw/i2c/i2c_mux_pca954x.h\n\nGeneric Loader\nM: Alistair Francis <alistair@alistair23.me>\nS: Maintained\nF: hw/core/generic-loader.c\nF: hw/core/uboot_image.h\nF: include/hw/core/generic-loader.h\nF: docs/system/generic-loader.rst\n\nGuest Loader\nM: Alex Bennée <alex.bennee@linaro.org>\nS: Maintained\nF: hw/core/guest-loader.c\nF: docs/system/guest-loader.rst\nF: tests/avocado/boot_xen.py\n\nIntel Hexadecimal Object File Loader\nM: Su Hang <suhang16@mails.ucas.ac.cn>\nS: Maintained\nF: tests/qtest/hexloader-test.c\nF: tests/data/hex-loader/test.hex\n\nCHRP NVRAM\nM: Thomas Huth <thuth@redhat.com>\nS: Maintained\nF: hw/nvram/chrp_nvram.c\nF: include/hw/nvram/chrp_nvram.h\nF: tests/qtest/prom-env-test.c\n\nVM Generation ID\nS: Orphan\nR: Ani Sinha <ani@anisinha.ca>\nF: hw/acpi/vmgenid.c\nF: include/hw/acpi/vmgenid.h\nF: docs/specs/vmgenid.txt\nF: tests/qtest/vmgenid-test.c\nF: stubs/vmgenid.c\n\nLED\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Maintained\nF: include/hw/misc/led.h\nF: hw/misc/led.c\n\nUnimplemented device\nM: Peter Maydell <peter.maydell@linaro.org>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Ani Sinha <ani@anisinha.ca>\nS: Maintained\nF: include/hw/misc/unimp.h\nF: hw/misc/unimp.c\n\nEmpty slot\nM: Artyom Tarasenko <atar4qemu@gmail.com>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Ani Sinha <ani@anisinha.ca>\nS: Maintained\nF: include/hw/misc/empty_slot.h\nF: hw/misc/empty_slot.c\n\nStandard VGA\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: hw/display/vga*\nF: hw/display/bochs-display.c\nF: include/hw/display/vga.h\nF: include/hw/display/bochs-vbe.h\n\nramfb\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: hw/display/ramfb*.c\nF: include/hw/display/ramfb.h\n\nvirtio-gpu\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: hw/display/virtio-gpu*\nF: hw/display/virtio-vga.*\nF: include/hw/virtio/virtio-gpu.h\n\nvhost-user-blk\nM: Raphael Norwitz <raphael.norwitz@nutanix.com>\nS: Maintained\nF: contrib/vhost-user-blk/\nF: contrib/vhost-user-scsi/\nF: hw/block/vhost-user-blk.c\nF: hw/scsi/vhost-user-scsi.c\nF: hw/virtio/vhost-user-blk-pci.c\nF: hw/virtio/vhost-user-scsi-pci.c\nF: include/hw/virtio/vhost-user-blk.h\nF: include/hw/virtio/vhost-user-scsi.h\n\nvhost-user-gpu\nM: Marc-André Lureau <marcandre.lureau@redhat.com>\nR: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: docs/interop/vhost-user-gpu.rst\nF: contrib/vhost-user-gpu\nF: hw/display/vhost-user-*\n\nCirrus VGA\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nW: https://www.kraxel.org/blog/2014/10/qemu-using-cirrus-considered-harmful/\nF: hw/display/cirrus*\n\nEDID Generator\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Maintained\nF: hw/display/edid*\nF: include/hw/display/edid.h\nF: qemu-edid.c\n\nPIIX4 South Bridge (i82371AB)\nM: Hervé Poussineau <hpoussin@reactos.org>\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Maintained\nF: hw/isa/piix4.c\nF: include/hw/southbridge/piix.h\n\nFirmware configuration (fw_cfg)\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Gerd Hoffmann <kraxel@redhat.com>\nS: Supported\nF: docs/specs/fw_cfg.txt\nF: hw/nvram/fw_cfg*.c\nF: stubs/fw_cfg.c\nF: include/hw/nvram/fw_cfg.h\nF: include/standard-headers/linux/qemu_fw_cfg.h\nF: tests/qtest/libqos/fw_cfg.c\nF: tests/qtest/fw_cfg-test.c\nT: git https://github.com/philmd/qemu.git fw_cfg-next\n\nXIVE\nM: Cédric Le Goater <clg@kaod.org>\nL: qemu-ppc@nongnu.org\nS: Supported\nF: hw/*/*xive*\nF: include/hw/*/*xive*\nF: docs/*/*xive*\n\nRenesas peripherals\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nR: Magnus Damm <magnus.damm@gmail.com>\nS: Odd Fixes\nF: hw/char/renesas_sci.c\nF: hw/char/sh_serial.c\nF: hw/timer/renesas_*.c\nF: hw/timer/sh_timer.c\nF: include/hw/char/renesas_sci.h\nF: include/hw/sh4/sh.h\nF: include/hw/timer/renesas_*.h\n\nRenesas RX peripherals\nR: Yoshinori Sato <ysato@users.sourceforge.jp>\nS: Orphan\nF: hw/intc/rx_icu.c\nF: hw/rx/\nF: include/hw/intc/rx_icu.h\nF: include/hw/rx/\n\nCAN bus subsystem and hardware\nM: Pavel Pisa <pisa@cmp.felk.cvut.cz>\nM: Vikram Garhwal <fnu.vikram@xilinx.com>\nS: Maintained\nW: https://canbus.pages.fel.cvut.cz/\nF: net/can/*\nF: hw/net/can/*\nF: include/net/can_*.h\n\nOpenPIC interrupt controller\nM: Mark Cave-Ayland <mark.cave-ayland@ilande.co.uk>\nS: Odd Fixes\nF: hw/intc/openpic.c\nF: include/hw/ppc/openpic.h\n\nMIPS CPS\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Odd Fixes\nF: hw/misc/mips_*\nF: include/hw/misc/mips_*\n\nMIPS GIC\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Odd Fixes\nF: hw/intc/mips_gic.c\nF: hw/timer/mips_gictimer.c\nF: include/hw/intc/mips_gic.h\nF: include/hw/timer/mips_gictimer.h\n\nS390 3270 device\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nS: Odd fixes\nF: include/hw/s390x/3270-ccw.h\nF: hw/char/terminal3270.c\nF: hw/s390x/3270-ccw.c\nL: qemu-s390x@nongnu.org\n\nS390 diag 288 watchdog\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nS: Supported\nF: hw/watchdog/wdt_diag288.c\nF: include/hw/watchdog/wdt_diag288.h\nL: qemu-s390x@nongnu.org\n\nS390 storage key device\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nS: Supported\nF: hw/s390x/storage-keys.h\nF: hw/390x/s390-skeys*.c\nL: qemu-s390x@nongnu.org\n\nS390 storage attribute device\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nS: Supported\nF: hw/s390x/storage-attributes.h\nF: hw/s390/s390-stattrib*.c\nL: qemu-s390x@nongnu.org\n\nS390 floating interrupt controller\nM: Halil Pasic <pasic@linux.ibm.com>\nM: Christian Borntraeger <borntraeger@linux.ibm.com>\nM: David Hildenbrand <david@redhat.com>\nS: Supported\nF: hw/intc/s390_flic*.c\nF: include/hw/s390x/s390_flic.h\nL: qemu-s390x@nongnu.org\n\nCanoKey\nM: Hongren (Zenithal) Zheng <i@zenithal.me>\nS: Maintained\nR: Canokeys.org <contact@canokeys.org>\nF: hw/usb/canokey.c\nF: hw/usb/canokey.h\nF: docs/system/devices/canokey.rst\n\nSubsystems\n----------\nOverall Audio backends\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: audio/\nX: audio/alsaaudio.c\nX: audio/coreaudio.c\nX: audio/dsound*\nX: audio/jackaudio.c\nX: audio/ossaudio.c\nX: audio/paaudio.c\nX: audio/sdlaudio.c\nX: audio/spiceaudio.c\nF: qapi/audio.json\n\nALSA Audio backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nR: Christian Schoenebeck <qemu_oss@crudebyte.com>\nS: Odd Fixes\nF: audio/alsaaudio.c\n\nCore Audio framework backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Christian Schoenebeck <qemu_oss@crudebyte.com>\nR: Akihiko Odaki <akihiko.odaki@gmail.com>\nS: Odd Fixes\nF: audio/coreaudio.c\n\nDSound Audio backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: audio/dsound*\n\nJACK Audio Connection Kit backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nR: Christian Schoenebeck <qemu_oss@crudebyte.com>\nS: Odd Fixes\nF: audio/jackaudio.c\n\nOpen Sound System (OSS) Audio backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: audio/ossaudio.c\n\nPulseAudio backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: audio/paaudio.c\n\nSDL Audio backend\nM: Gerd Hoffmann <kraxel@redhat.com>\nR: Thomas Huth <huth@tuxfamily.org>\nS: Odd Fixes\nF: audio/sdlaudio.c\n\nBlock layer core\nM: Kevin Wolf <kwolf@redhat.com>\nM: Hanna Reitz <hreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block*\nF: block/\nF: hw/block/\nF: include/block/\nF: qemu-img*\nF: docs/tools/qemu-img.rst\nF: qemu-io*\nF: tests/qemu-iotests/\nF: util/qemu-progress.c\nF: qobject/block-qdict.c\nF: tests/unit/check-block-qdict.c\nT: git https://repo.or.cz/qemu/kevin.git block\n\nStorage daemon\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: storage-daemon/\nF: docs/interop/qemu-storage-daemon-qmp-ref.rst\nF: docs/tools/qemu-storage-daemon.rst\nT: git https://repo.or.cz/qemu/kevin.git block\n\nBlock I/O path\nM: Stefan Hajnoczi <stefanha@redhat.com>\nM: Fam Zheng <fam@euphon.net>\nL: qemu-block@nongnu.org\nS: Supported\nF: util/async.c\nF: util/aio-*.c\nF: util/aio-*.h\nF: util/fdmon-*.c\nF: block/io.c\nF: migration/block*\nF: include/block/aio.h\nF: include/block/aio-wait.h\nF: scripts/qemugdb/aio.py\nF: tests/unit/test-fdmon-epoll.c\nT: git https://github.com/stefanha/qemu.git block\n\nBlock SCSI subsystem\nM: Paolo Bonzini <pbonzini@redhat.com>\nR: Fam Zheng <fam@euphon.net>\nL: qemu-block@nongnu.org\nS: Supported\nF: include/scsi/*\nF: scsi/*\n\nBlock Jobs\nM: John Snow <jsnow@redhat.com>\nM: Vladimir Sementsov-Ogievskiy <vsementsov@yandex-team.ru>\nL: qemu-block@nongnu.org\nS: Supported\nF: blockjob.c\nF: include/block/blockjob.h\nF: job.c\nF: job-qmp.c\nF: include/qemu/job.h\nF: block/backup.c\nF: block/commit.c\nF: block/stream.c\nF: block/mirror.c\nF: qapi/job.json\nF: block/block-copy.c\nF: include/block/block-copy.h\nF: block/reqlist.c\nF: include/block/reqlist.h\nF: block/copy-before-write.h\nF: block/copy-before-write.c\nF: block/snapshot-access.c\nF: include/block/aio_task.h\nF: block/aio_task.c\nF: util/qemu-co-shared-resource.c\nF: include/qemu/co-shared-resource.h\nT: git https://gitlab.com/jsnow/qemu.git jobs\nT: git https://gitlab.com/vsementsov/qemu.git block\n\nBlock QAPI, monitor, command line\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: blockdev.c\nF: blockdev-hmp-cmds.c\nF: block/qapi.c\nF: qapi/block*.json\nF: qapi/transaction.json\nT: git https://repo.or.cz/qemu/armbru.git block-next\n\nCompute Express Link\nM: Ben Widawsky <ben.widawsky@intel.com>\nM: Jonathan Cameron <jonathan.cameron@huawei.com>\nS: Supported\nF: hw/cxl/\nF: hw/mem/cxl_type3.c\nF: include/hw/cxl/\n\nDirty Bitmaps\nM: Eric Blake <eblake@redhat.com>\nM: Vladimir Sementsov-Ogievskiy <vsementsov@yandex-team.ru>\nR: John Snow <jsnow@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: include/qemu/hbitmap.h\nF: include/block/dirty-bitmap.h\nF: block/monitor/bitmap-qmp-cmds.c\nF: block/dirty-bitmap.c\nF: block/qcow2-bitmap.c\nF: migration/block-dirty-bitmap.c\nF: util/hbitmap.c\nF: tests/unit/test-hbitmap.c\nF: docs/interop/bitmaps.rst\nT: git https://repo.or.cz/qemu/ericb.git bitmaps\nT: git https://gitlab.com/vsementsov/qemu.git block\n\nCharacter device backends\nM: Marc-André Lureau <marcandre.lureau@redhat.com>\nR: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: chardev/\nF: include/chardev/\nF: qapi/char.json\n\nCharacter Devices (Braille)\nM: Samuel Thibault <samuel.thibault@ens-lyon.org>\nS: Maintained\nF: chardev/baum.c\n\nCommand line option argument parsing\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: include/qemu/option.h\nF: tests/unit/test-keyval.c\nF: tests/unit/test-qemu-opts.c\nF: util/keyval.c\nF: util/qemu-option.c\n\nCoverity model\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: scripts/coverity-model.c\n\nCoverity Scan integration\nM: Peter Maydell <peter.maydell@linaro.org>\nS: Maintained\nF: scripts/coverity-scan/\n\nDevice Tree\nM: Alistair Francis <alistair.francis@wdc.com>\nR: David Gibson <david@gibson.dropbear.id.au>\nS: Maintained\nF: softmmu/device_tree.c\nF: include/sysemu/device_tree.h\n\nDump\nS: Supported\nM: Marc-André Lureau <marcandre.lureau@redhat.com>\nF: dump/\nF: hw/misc/vmcoreinfo.c\nF: include/hw/misc/vmcoreinfo.h\nF: include/qemu/win_dump_defs\nF: include/sysemu/dump-arch.h\nF: include/sysemu/dump.h\nF: qapi/dump.json\nF: scripts/dump-guest-memory.py\nF: stubs/dump.c\n\nError reporting\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: include/qapi/error.h\nF: include/qemu/error-report.h\nF: qapi/error.json\nF: util/error.c\nF: util/qemu-error.c\nF: scripts/coccinelle/err-bad-newline.cocci\nF: scripts/coccinelle/error-use-after-free.cocci\nF: scripts/coccinelle/error_propagate_null.cocci\nF: scripts/coccinelle/remove_local_err.cocci\nF: scripts/coccinelle/use-error_fatal.cocci\nF: scripts/coccinelle/errp-guard.cocci\n\nGDB stub\nM: Alex Bennée <alex.bennee@linaro.org>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Maintained\nF: gdbstub*\nF: include/exec/gdbstub.h\nF: gdb-xml/\nF: tests/tcg/multiarch/gdbstub/\n\nMemory API\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Peter Xu <peterx@redhat.com>\nM: David Hildenbrand <david@redhat.com>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Supported\nF: include/exec/ioport.h\nF: include/exec/memop.h\nF: include/exec/memory.h\nF: include/exec/ram_addr.h\nF: include/exec/ramblock.h\nF: include/sysemu/memory_mapping.h\nF: softmmu/dma-helpers.c\nF: softmmu/ioport.c\nF: softmmu/memory.c\nF: softmmu/memory_mapping.c\nF: softmmu/physmem.c\nF: include/exec/memory-internal.h\nF: scripts/coccinelle/memory-region-housekeeping.cocci\n\nMemory devices\nM: David Hildenbrand <david@redhat.com>\nM: Igor Mammedov <imammedo@redhat.com>\nR: Xiao Guangrong <xiaoguangrong.eric@gmail.com>\nS: Supported\nF: hw/mem/memory-device.c\nF: hw/mem/nvdimm.c\nF: hw/mem/pc-dimm.c\nF: include/hw/mem/memory-device.h\nF: include/hw/mem/nvdimm.h\nF: include/hw/mem/pc-dimm.h\nF: docs/nvdimm.txt\n\nSPICE\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: include/ui/qemu-spice.h\nF: include/ui/spice-display.h\nF: ui/spice-*.c\nF: audio/spiceaudio.c\nF: hw/display/qxl*\nF: qapi/ui.json\nF: docs/spice-port-fqdn.txt\n\nGraphics\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Odd Fixes\nF: ui/\nF: include/ui/\nF: qapi/ui.json\nF: util/drm.c\n\nCocoa graphics\nM: Peter Maydell <peter.maydell@linaro.org>\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Akihiko Odaki <akihiko.odaki@gmail.com>\nS: Odd Fixes\nF: ui/cocoa.m\n\nMain loop\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: include/exec/gen-icount.h\nF: include/qemu/main-loop.h\nF: include/sysemu/runstate.h\nF: include/sysemu/runstate-action.h\nF: util/main-loop.c\nF: util/qemu-timer.c\nF: softmmu/vl.c\nF: softmmu/main.c\nF: softmmu/cpus.c\nF: softmmu/cpu-throttle.c\nF: softmmu/cpu-timers.c\nF: softmmu/icount.c\nF: softmmu/runstate-action.c\nF: softmmu/runstate.c\nF: qapi/run-state.json\n\nRead, Copy, Update (RCU)\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: include/qemu/rcu*.h\nF: tests/unit/rcutorture.c\nF: tests/unit/test-rcu-*.c\nF: util/rcu.c\n\nHuman Monitor (HMP)\nM: Dr. David Alan Gilbert <dgilbert@redhat.com>\nS: Maintained\nF: monitor/monitor-internal.h\nF: monitor/misc.c\nF: monitor/monitor.c\nF: monitor/hmp*\nF: hmp.h\nF: hmp-commands*.hx\nF: include/monitor/hmp-target.h\nF: tests/qtest/test-hmp.c\nF: include/qemu/qemu-print.h\nF: util/qemu-print.c\n\nNetwork device backends\nM: Jason Wang <jasowang@redhat.com>\nS: Maintained\nF: net/\nF: include/net/\nF: qemu-bridge-helper.c\nT: git https://github.com/jasowang/qemu.git net\nF: qapi/net.json\n\nNetmap network backend\nM: Luigi Rizzo <rizzo@iet.unipi.it>\nM: Giuseppe Lettieri <g.lettieri@iet.unipi.it>\nM: Vincenzo Maffione <v.maffione@gmail.com>\nW: http://info.iet.unipi.it/~luigi/netmap/\nS: Maintained\nF: net/netmap.c\n\nHost Memory Backends\nM: David Hildenbrand <david@redhat.com>\nM: Igor Mammedov <imammedo@redhat.com>\nS: Maintained\nF: backends/hostmem*.c\nF: include/sysemu/hostmem.h\nT: git https://gitlab.com/ehabkost/qemu.git machine-next\n\nCryptodev Backends\nM: Gonglei <arei.gonglei@huawei.com>\nS: Maintained\nF: include/sysemu/cryptodev*.h\nF: backends/cryptodev*.c\n\nPython library\nM: John Snow <jsnow@redhat.com>\nM: Cleber Rosa <crosa@redhat.com>\nR: Beraldo Leal <bleal@redhat.com>\nS: Maintained\nF: python/\nT: git https://gitlab.com/jsnow/qemu.git python\n\nPython scripts\nM: John Snow <jsnow@redhat.com>\nM: Cleber Rosa <crosa@redhat.com>\nS: Odd Fixes\nF: scripts/*.py\nF: tests/*.py\n\nBenchmark util\nM: Vladimir Sementsov-Ogievskiy <vsementsov@yandex-team.ru>\nS: Maintained\nF: scripts/simplebench/\nT: git https://gitlab.com/vsementsov/qemu.git simplebench\n\nTransactions helper\nM: Vladimir Sementsov-Ogievskiy <vsementsov@yandex-team.ru>\nS: Maintained\nF: include/qemu/transactions.h\nF: util/transactions.c\nT: git https://gitlab.com/vsementsov/qemu.git block\n\nQAPI\nM: Markus Armbruster <armbru@redhat.com>\nM: Michael Roth <michael.roth@amd.com>\nS: Supported\nF: qapi/\nX: qapi/*.json\nF: include/qapi/\nX: include/qapi/qmp/\nF: include/qapi/qmp/dispatch.h\nF: tests/qapi-schema/\nF: tests/unit/test-*-visitor.c\nF: tests/unit/test-qapi-*.c\nF: tests/unit/test-qmp-*.c\nF: tests/unit/test-visitor-serialization.c\nF: scripts/qapi-gen.py\nF: scripts/qapi/*\nF: docs/sphinx/qapidoc.py\nF: docs/devel/qapi*\nT: git https://repo.or.cz/qemu/armbru.git qapi-next\n\nQAPI Schema\nM: Eric Blake <eblake@redhat.com>\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: qapi/*.json\nT: git https://repo.or.cz/qemu/armbru.git qapi-next\n\nQObject\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: qobject/\nF: include/qapi/qmp/\nX: include/qapi/qmp/dispatch.h\nF: scripts/coccinelle/qobject.cocci\nF: tests/unit/check-qdict.c\nF: tests/unit/check-qjson.c\nF: tests/unit/check-qlist.c\nF: tests/unit/check-qlit.c\nF: tests/unit/check-qnull.c\nF: tests/unit/check-qnum.c\nF: tests/unit/check-qobject.c\nF: tests/unit/check-qstring.c\nF: tests/data/qobject/qdict.txt\nT: git https://repo.or.cz/qemu/armbru.git qapi-next\n\nQEMU Guest Agent\nM: Michael Roth <michael.roth@amd.com>\nM: Konstantin Kostiuk <kkostiuk@redhat.com>\nS: Maintained\nF: qga/\nF: docs/interop/qemu-ga.rst\nF: docs/interop/qemu-ga-ref.rst\nF: scripts/qemu-guest-agent/\nF: tests/unit/test-qga.c\nT: git https://github.com/mdroth/qemu.git qga\n\nQEMU Guest Agent Win32\nM: Konstantin Kostiuk <kkostiuk@redhat.com>\nS: Maintained\nF: qga/*win32*\nF: qga/vss-win32/\nF: qga/installer/\nT: git https://github.com/kostyanf14/qemu.git qga-win32\n\nQOM\nM: Paolo Bonzini <pbonzini@redhat.com>\nR: Daniel P. Berrange <berrange@redhat.com>\nR: Eduardo Habkost <eduardo@habkost.net>\nS: Supported\nF: docs/qdev-device-use.txt\nF: hw/core/qdev*\nF: hw/core/bus.c\nF: hw/core/sysbus.c\nF: include/hw/qdev*\nF: include/monitor/qdev.h\nF: include/qom/\nF: qapi/qom.json\nF: qapi/qdev.json\nF: scripts/coccinelle/qom-parent-type.cocci\nF: softmmu/qdev-monitor.c\nF: stubs/qdev.c\nF: qom/\nF: tests/unit/check-qom-interface.c\nF: tests/unit/check-qom-proplist.c\nF: tests/unit/test-qdev-global-props.c\n\nQOM boilerplate conversion script\nM: Eduardo Habkost <eduardo@habkost.net>\nS: Maintained\nF: scripts/codeconverter/\n\nQMP\nM: Markus Armbruster <armbru@redhat.com>\nS: Supported\nF: monitor/monitor-internal.h\nF: monitor/qmp*\nF: monitor/misc.c\nF: monitor/monitor.c\nF: qapi/control.json\nF: qapi/error.json\nF: qapi/introspect.json\nF: docs/devel/*qmp-*\nF: docs/interop/*qmp-*\nF: scripts/qmp/\nF: tests/qtest/qmp-test.c\nF: tests/qtest/qmp-cmd-test.c\nT: git https://repo.or.cz/qemu/armbru.git qapi-next\n\nqtest\nM: Thomas Huth <thuth@redhat.com>\nM: Laurent Vivier <lvivier@redhat.com>\nR: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: softmmu/qtest.c\nF: accel/qtest/\nF: tests/qtest/\nF: docs/devel/qgraph.rst\nX: tests/qtest/bios-tables-test*\n\nDevice Fuzzing\nM: Alexander Bulekov <alxndr@bu.edu>\nR: Paolo Bonzini <pbonzini@redhat.com>\nR: Bandan Das <bsd@redhat.com>\nR: Stefan Hajnoczi <stefanha@redhat.com>\nR: Thomas Huth <thuth@redhat.com>\nR: Darren Kenny <darren.kenny@oracle.com> \nR: Qiuhao Li <Qiuhao.Li@outlook.com>\nS: Maintained\nF: tests/qtest/fuzz/\nF: tests/qtest/fuzz-*test.c\nF: scripts/oss-fuzz/\nF: hw/mem/sparse-mem.c\nF: docs/devel/fuzzing.rst\n\nRegister API\nM: Alistair Francis <alistair@alistair23.me>\nS: Maintained\nF: hw/core/register.c\nF: include/hw/register.h\nF: include/hw/registerfields.h\n\nSLIRP\nM: Samuel Thibault <samuel.thibault@ens-lyon.org>\nS: Maintained\nF: slirp/\nF: net/slirp.c\nF: include/net/slirp.h\nT: git https://people.debian.org/~sthibault/qemu.git slirp\n\nStreams\nM: Edgar E. Iglesias <edgar.iglesias@gmail.com>\nS: Maintained\nF: hw/core/stream.c\nF: include/hw/stream.h\n\nStubs\nM: Paolo Bonzini <pbonzini@redhat.com>\nS: Maintained\nF: stubs/\n\nTracing\nM: Stefan Hajnoczi <stefanha@redhat.com>\nS: Maintained\nF: trace/\nF: trace-events\nF: docs/qemu-option-trace.rst.inc\nF: qapi/trace.json\nF: scripts/tracetool.py\nF: scripts/tracetool/\nF: scripts/qemu-trace-stap*\nF: docs/tools/qemu-trace-stap.rst\nF: docs/devel/tracing.rst\nT: git https://github.com/stefanha/qemu.git tracing\n\nTPM\nM: Stefan Berger <stefanb@linux.ibm.com>\nS: Maintained\nF: tpm.c\nF: hw/tpm/*\nF: include/hw/acpi/tpm.h\nF: include/sysemu/tpm*\nF: qapi/tpm.json\nF: backends/tpm/\nF: tests/qtest/*tpm*\nT: git https://github.com/stefanberger/qemu-tpm.git tpm-next\n\nCheckpatch\nS: Odd Fixes\nF: scripts/checkpatch.pl\n\nMigration\nM: Juan Quintela <quintela@redhat.com>\nM: Dr. David Alan Gilbert <dgilbert@redhat.com>\nS: Maintained\nF: hw/core/vmstate-if.c\nF: include/hw/vmstate-if.h\nF: include/migration/\nF: migration/\nF: scripts/vmstate-static-checker.py\nF: tests/vmstate-static-checker-data/\nF: tests/qtest/migration-test.c\nF: docs/devel/migration.rst\nF: qapi/migration.json\nF: tests/migration/\n\nD-Bus\nM: Marc-André Lureau <marcandre.lureau@redhat.com>\nS: Maintained\nF: backends/dbus-vmstate.c\nF: ui/dbus*\nF: audio/dbus*\nF: util/dbus.c\nF: include/ui/dbus*\nF: include/qemu/dbus.h\nF: docs/interop/dbus*\nF: docs/sphinx/dbus*\nF: docs/sphinx/fakedbusdoc.py\nF: tests/qtest/dbus*\n\nSeccomp\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: softmmu/qemu-seccomp.c\nF: include/sysemu/seccomp.h\nF: tests/unit/test-seccomp.c\n\nCryptography\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Maintained\nF: crypto/\nF: include/crypto/\nF: qapi/crypto.json\nF: tests/unit/test-crypto-*\nF: tests/bench/benchmark-crypto-*\nF: tests/unit/crypto-tls-*\nF: tests/unit/pkix_asn1_tab.c\nF: qemu.sasl\n\nCoroutines\nM: Stefan Hajnoczi <stefanha@redhat.com>\nM: Kevin Wolf <kwolf@redhat.com>\nS: Maintained\nF: util/*coroutine*\nF: include/qemu/coroutine*\nF: tests/unit/test-coroutine.c\n\nBuffers\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: util/buffer.c\nF: include/qemu/buffer.h\n\nI/O Channels\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Maintained\nF: io/\nF: include/io/\nF: tests/unit/test-io-*\n\nUser authorization\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Maintained\nF: authz/\nF: qapi/authz.json\nF: include/authz/\nF: tests/unit/test-authz-*\n\nSockets\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Maintained\nF: include/qemu/sockets.h\nF: util/qemu-sockets.c\nF: qapi/sockets.json\n\nFile monitor\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: util/filemonitor*.c\nF: include/qemu/filemonitor.h\nF: tests/unit/test-util-filemonitor.c\n\nThrottling infrastructure\nM: Alberto Garcia <berto@igalia.com>\nS: Supported\nF: block/throttle-groups.c\nF: include/block/throttle-groups.h\nF: include/qemu/throttle*.h\nF: util/throttle.c\nF: docs/throttle.txt\nF: tests/unit/test-throttle.c\nL: qemu-block@nongnu.org\n\nUUID\nM: Fam Zheng <fam@euphon.net>\nS: Supported\nF: util/uuid.c\nF: include/qemu/uuid.h\nF: tests/unit/test-uuid.c\n\nYank feature\nM: Lukas Straub <lukasstraub2@web.de>\nS: Odd fixes\nF: util/yank.c\nF: migration/yank_functions*\nF: tests/unit/test-yank.c\nF: include/qemu/yank.h\nF: qapi/yank.json\n\nCOLO Framework\nM: Hailiang Zhang <zhanghailiang@xfusion.com>\nS: Maintained\nF: migration/colo*\nF: include/migration/colo.h\nF: include/migration/failover.h\nF: docs/COLO-FT.txt\n\nCOLO Proxy\nM: Zhang Chen <chen.zhang@intel.com>\nM: Li Zhijian <lizhijian@fujitsu.com>\nS: Supported\nF: docs/colo-proxy.txt\nF: net/colo*\nF: net/filter-rewriter.c\nF: net/filter-mirror.c\nF: tests/qtest/test-filter*\n\nRecord/replay\nM: Pavel Dovgalyuk <pavel.dovgaluk@ispras.ru>\nR: Paolo Bonzini <pbonzini@redhat.com>\nW: https://wiki.qemu.org/Features/record-replay\nS: Supported\nF: replay/*\nF: block/blkreplay.c\nF: net/filter-replay.c\nF: include/sysemu/replay.h\nF: docs/replay.txt\nF: stubs/replay.c\nF: tests/avocado/replay_kernel.py\nF: tests/avocado/replay_linux.py\nF: tests/avocado/reverse_debugging.py\nF: qapi/replay.json\n\nIOVA Tree\nM: Peter Xu <peterx@redhat.com>\nS: Maintained\nF: include/qemu/iova-tree.h\nF: util/iova-tree.c\n\nelf2dmp\nM: Viktor Prutyanov <viktor.prutyanov@phystech.edu>\nS: Maintained\nF: contrib/elf2dmp/\n\nI2C and SMBus\nM: Corey Minyard <cminyard@mvista.com>\nS: Maintained\nF: hw/i2c/core.c\nF: hw/i2c/smbus_slave.c\nF: hw/i2c/smbus_master.c\nF: hw/i2c/smbus_eeprom.c\nF: include/hw/i2c/i2c.h\nF: include/hw/i2c/smbus_master.h\nF: include/hw/i2c/smbus_slave.h\nF: include/hw/i2c/smbus_eeprom.h\n\nPMBus\nM: Titus Rwantare <titusr@google.com>\nS: Maintained\nF: hw/i2c/pmbus_device.c\nF: hw/sensor/adm1272.c\nF: hw/sensor/isl_pmbus_vr.c\nF: hw/sensor/max34451.c\nF: include/hw/i2c/pmbus_device.h\nF: include/hw/sensor/isl_pmbus_vr.h\nF: tests/qtest/adm1272-test.c\nF: tests/qtest/max34451-test.c\nF: tests/qtest/isl_pmbus_vr-test.c\n\nFirmware schema specifications\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Daniel P. Berrange <berrange@redhat.com>\nR: Kashyap Chamarthy <kchamart@redhat.com>\nS: Maintained\nF: docs/interop/firmware.json\n\nEDK2 Firmware\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nM: Gerd Hoffmann <kraxel@redhat.com>\nS: Supported\nF: hw/i386/*ovmf*\nF: pc-bios/descriptors/??-edk2-*.json\nF: pc-bios/edk2-*\nF: roms/Makefile.edk2\nF: roms/edk2\nF: roms/edk2-*\nF: tests/data/uefi-boot-images/\nF: tests/uefi-test-tools/\nF: .gitlab-ci.d/edk2.yml\nF: .gitlab-ci.d/edk2/\n\nVT-d Emulation\nM: Michael S. Tsirkin <mst@redhat.com>\nM: Peter Xu <peterx@redhat.com>\nR: Jason Wang <jasowang@redhat.com>\nS: Supported\nF: hw/i386/intel_iommu.c\nF: hw/i386/intel_iommu_internal.h\nF: include/hw/i386/intel_iommu.h\n\nOpenSBI Firmware\nM: Bin Meng <bmeng.cn@gmail.com>\nS: Supported\nF: pc-bios/opensbi-*\nF: .gitlab-ci.d/opensbi.yml\nF: .gitlab-ci.d/opensbi/\n\nClock framework\nM: Luc Michel <luc@lmichel.fr>\nR: Damien Hedde <damien.hedde@greensocs.com>\nS: Maintained\nF: include/hw/clock.h\nF: include/hw/qdev-clock.h\nF: hw/core/clock.c\nF: hw/core/clock-vmstate.c\nF: hw/core/qdev-clock.c\nF: docs/devel/clocks.rst\n\nUsermode Emulation\n------------------\nOverall usermode emulation\nM: Riku Voipio <riku.voipio@iki.fi>\nS: Maintained\nF: accel/tcg/user-exec*.c\nF: include/user/\nF: common-user/\n\nBSD user\nM: Warner Losh <imp@bsdimp.com>\nR: Kyle Evans <kevans@freebsd.org>\nS: Maintained\nF: bsd-user/\nF: configs/targets/*-bsd-user.mak\nF: tests/vm/*bsd\nT: git https://github.com/qemu-bsd-user/qemu-bsd-user bsd-user-rebase-3.1\n\nLinux user\nM: Laurent Vivier <laurent@vivier.eu>\nS: Maintained\nF: linux-user/\nF: configs/targets/*linux-user.mak\nF: scripts/qemu-binfmt-conf.sh\nF: scripts/update-syscalltbl.sh\nF: scripts/update-mips-syscall-args.sh\nF: scripts/gensyscalls.sh\n\nTiny Code Generator (TCG)\n-------------------------\nCommon TCG code\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nF: tcg/\nF: include/tcg/\n\nTCG Plugins\nM: Alex Bennée <alex.bennee@linaro.org>\nR: Alexandre Iooss <erdnaxe@crans.org>\nR: Mahmoud Mandour <ma.mandourr@gmail.com>\nS: Maintained\nF: docs/devel/tcg-plugins.rst\nF: plugins/\nF: tests/plugin/\nF: tests/avocado/tcg_plugins.py\nF: contrib/plugins/\n\nAArch64 TCG target\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nL: qemu-arm@nongnu.org\nF: tcg/aarch64/\n\nARM TCG target\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nL: qemu-arm@nongnu.org\nF: tcg/arm/\n\ni386 TCG target\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nF: tcg/i386/\n\nLoongArch64 TCG target\nM: WANG Xuerui <git@xen0n.name>\nS: Maintained\nF: tcg/loongarch64/\n\nMIPS TCG target\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Aurelien Jarno <aurelien@aurel32.net>\nR: Huacai Chen <chenhuacai@kernel.org>\nR: Jiaxun Yang <jiaxun.yang@flygoat.com>\nR: Aleksandar Rikalo <aleksandar.rikalo@syrmia.com>\nS: Odd Fixes\nF: tcg/mips/\n\nPPC TCG target\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Odd Fixes\nF: tcg/ppc/\n\nRISC-V TCG target\nM: Palmer Dabbelt <palmer@dabbelt.com>\nM: Alistair Francis <Alistair.Francis@wdc.com>\nL: qemu-riscv@nongnu.org\nS: Maintained\nF: tcg/riscv/\nF: disas/riscv.c\n\nS390 TCG target\nM: Richard Henderson <richard.henderson@linaro.org>\nS: Maintained\nF: tcg/s390/\nL: qemu-s390x@nongnu.org\n\nSPARC TCG target\nS: Odd Fixes\nF: tcg/sparc/\nF: disas/sparc.c\n\nTCI TCG target\nM: Stefan Weil <sw@weilnetz.de>\nS: Maintained\nF: tcg/tci/\nF: tcg/tci.c\nF: disas/tci.c\n\nBlock drivers\n-------------\nVMDK\nM: Fam Zheng <fam@euphon.net>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vmdk.c\n\nRBD\nM: Ilya Dryomov <idryomov@gmail.com>\nR: Peter Lieven <pl@kamp.de>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/rbd.c\n\nVHDX\nM: Jeff Cody <codyprime@gmail.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vhdx*\n\nVDI\nM: Stefan Weil <sw@weilnetz.de>\nL: qemu-block@nongnu.org\nS: Maintained\nF: block/vdi.c\n\niSCSI\nM: Ronnie Sahlberg <ronniesahlberg@gmail.com>\nM: Paolo Bonzini <pbonzini@redhat.com>\nM: Peter Lieven <pl@kamp.de>\nL: qemu-block@nongnu.org\nS: Odd Fixes\nF: block/iscsi.c\nF: block/iscsi-opts.c\n\nNetwork Block Device (NBD)\nM: Eric Blake <eblake@redhat.com>\nM: Vladimir Sementsov-Ogievskiy <vsementsov@yandex-team.ru>\nL: qemu-block@nongnu.org\nS: Maintained\nF: block/nbd*\nF: nbd/\nF: include/block/nbd*\nF: qemu-nbd.*\nF: blockdev-nbd.c\nF: docs/interop/nbd.txt\nF: docs/tools/qemu-nbd.rst\nF: tests/qemu-iotests/tests/*nbd*\nT: git https://repo.or.cz/qemu/ericb.git nbd\nT: git https://gitlab.com/vsementsov/qemu.git block\n\nNFS\nM: Peter Lieven <pl@kamp.de>\nL: qemu-block@nongnu.org\nS: Maintained\nF: block/nfs.c\n\nSSH\nM: Richard W.M. Jones <rjones@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/ssh.c\n\nCURL\nL: qemu-block@nongnu.org\nS: Odd Fixes\nF: block/curl.c\n\nGLUSTER\nL: qemu-block@nongnu.org\nL: integration@gluster.org\nS: Odd Fixes\nF: block/gluster.c\n\nNull Block Driver\nM: Fam Zheng <fam@euphon.net>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/null.c\n\nNVMe Block Driver\nM: Stefan Hajnoczi <stefanha@redhat.com>\nR: Fam Zheng <fam@euphon.net>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/nvme*\nF: include/block/nvme.h\nT: git https://github.com/stefanha/qemu.git block\n\nBootdevice\nM: Gonglei <arei.gonglei@huawei.com>\nS: Maintained\nF: softmmu/bootdevice.c\n\nQuorum\nM: Alberto Garcia <berto@igalia.com>\nS: Supported\nF: block/quorum.c\nL: qemu-block@nongnu.org\n\nblklogwrites\nM: Ari Sundholm <ari@tuxera.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/blklogwrites.c\n\nblkverify\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/blkverify.c\n\nbochs\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/bochs.c\n\ncloop\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/cloop.c\n\ndmg\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/dmg.c\n\nparallels\nM: Stefan Hajnoczi <stefanha@redhat.com>\nM: Denis V. Lunev <den@openvz.org>\nM: Vladimir Sementsov-Ogievskiy <vsementsov@yandex-team.ru>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/parallels.c\nF: block/parallels-ext.c\nF: docs/interop/parallels.txt\nT: git https://gitlab.com/vsementsov/qemu.git block\n\nqed\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/qed.c\n\nraw\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/linux-aio.c\nF: include/block/raw-aio.h\nF: block/raw-format.c\nF: block/file-posix.c\nF: block/file-win32.c\nF: block/win32-aio.c\n\nLinux io_uring\nM: Aarushi Mehta <mehta.aaru20@gmail.com>\nM: Julia Suvorova <jusual@redhat.com>\nM: Stefan Hajnoczi <stefanha@redhat.com>\nR: Stefano Garzarella <sgarzare@redhat.com>\nL: qemu-block@nongnu.org\nS: Maintained\nF: block/io_uring.c\nF: stubs/io_uring.c\n\nqcow2\nM: Kevin Wolf <kwolf@redhat.com>\nM: Hanna Reitz <hreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/qcow2*\nF: docs/interop/qcow2.txt\n\nqcow\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/qcow.c\n\nblkdebug\nM: Kevin Wolf <kwolf@redhat.com>\nM: Hanna Reitz <hreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/blkdebug.c\n\nvpc\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/vpc.c\n\nvvfat\nM: Kevin Wolf <kwolf@redhat.com>\nL: qemu-block@nongnu.org\nS: Odd Fixes\nF: block/vvfat.c\n\nImage format fuzzer\nM: Stefan Hajnoczi <stefanha@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: tests/image-fuzzer/\n\nVhost-user block device backend server\nM: Coiby Xu <Coiby.Xu@gmail.com>\nS: Maintained\nF: block/export/vhost-user-blk-server.c\nF: block/export/vhost-user-blk-server.h\nF: block/export/virtio-blk-handler.c\nF: block/export/virtio-blk-handler.h\nF: include/qemu/vhost-user-server.h\nF: tests/qtest/libqos/vhost-user-blk.c\nF: tests/qtest/libqos/vhost-user-blk.h\nF: tests/qtest/vhost-user-blk-test.c\nF: util/vhost-user-server.c\n\nFUSE block device exports\nM: Hanna Reitz <hreitz@redhat.com>\nL: qemu-block@nongnu.org\nS: Supported\nF: block/export/fuse.c\n\nVDUSE library and block device exports\nM: Xie Yongji <xieyongji@bytedance.com>\nS: Maintained\nF: subprojects/libvduse/\nF: block/export/vduse-blk.c\nF: block/export/vduse-blk.h\n\nReplication\nM: Wen Congyang <wencongyang2@huawei.com>\nM: Xie Changlong <xiechanglong.d@gmail.com>\nS: Supported\nF: replication*\nF: block/replication.c\nF: tests/unit/test-replication.c\nF: docs/block-replication.txt\n\nPVRDMA\nM: Yuval Shaia <yuval.shaia.ml@gmail.com>\nM: Marcel Apfelbaum <marcel.apfelbaum@gmail.com>\nS: Maintained\nF: hw/rdma/*\nF: hw/rdma/vmw/*\nF: docs/pvrdma.txt\nF: contrib/rdmacm-mux/*\nF: qapi/rdma.json\n\nSemihosting\nM: Alex Bennée <alex.bennee@linaro.org>\nS: Maintained\nF: semihosting/\nF: include/semihosting/\nF: tests/tcg/multiarch/arm-compat-semi/\nF: tests/tcg/aarch64/system/semiheap.c\n\nMulti-process QEMU\nM: Elena Ufimtseva <elena.ufimtseva@oracle.com>\nM: Jagannathan Raman <jag.raman@oracle.com>\nM: John G Johnson <john.g.johnson@oracle.com>\nS: Maintained\nF: docs/devel/multi-process.rst\nF: docs/system/multi-process.rst\nF: hw/pci-host/remote.c\nF: include/hw/pci-host/remote.h\nF: hw/remote/machine.c\nF: include/hw/remote/machine.h\nF: hw/remote/mpqemu-link.c\nF: include/hw/remote/mpqemu-link.h\nF: hw/remote/message.c\nF: hw/remote/remote-obj.c\nF: include/hw/remote/memory.h\nF: hw/remote/memory.c\nF: hw/remote/proxy.c\nF: include/hw/remote/proxy.h\nF: hw/remote/proxy-memory-listener.c\nF: include/hw/remote/proxy-memory-listener.h\nF: hw/remote/iohub.c\nF: include/hw/remote/iohub.h\nF: subprojects/libvfio-user\nF: hw/remote/vfio-user-obj.c\nF: include/hw/remote/vfio-user-obj.h\nF: hw/remote/iommu.c\nF: include/hw/remote/iommu.h\n\nEBPF:\nM: Jason Wang <jasowang@redhat.com>\nR: Andrew Melnychenko <andrew@daynix.com>\nR: Yuri Benditovich <yuri.benditovich@daynix.com>\nS: Maintained\nF: ebpf/*\nF: tools/ebpf/*\n\nBuild and test automation\n-------------------------\nBuild and test automation, general continuous integration\nM: Alex Bennée <alex.bennee@linaro.org>\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nM: Thomas Huth <thuth@redhat.com>\nR: Wainer dos Santos Moschetta <wainersm@redhat.com>\nR: Beraldo Leal <bleal@redhat.com>\nS: Maintained\nF: .github/workflows/lockdown.yml\nF: .gitlab-ci.yml\nF: .gitlab-ci.d/\nF: .travis.yml\nF: scripts/ci/\nF: tests/docker/\nF: tests/vm/\nF: tests/lcitool/\nF: scripts/archive-source.sh\nW: https://gitlab.com/qemu-project/qemu/pipelines\nW: https://travis-ci.org/qemu/qemu\n\nFreeBSD Hosted Continuous Integration\nM: Ed Maste <emaste@freebsd.org>\nM: Li-Wen Hsu <lwhsu@freebsd.org>\nS: Maintained\nF: .gitlab-ci.d/cirrus/freebsd*\nF: tests/vm/freebsd\nW: https://cirrus-ci.com/github/qemu/qemu\n\nWindows Hosted Continuous Integration\nM: Yonggang Luo <luoyonggang@gmail.com>\nS: Maintained\nF: .cirrus.yml\nW: https://cirrus-ci.com/github/qemu/qemu\n\nGuest Test Compilation Support\nM: Alex Bennée <alex.bennee@linaro.org>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Maintained\nF: tests/tcg/Makefile\nF: tests/tcg/Makefile.include\n\nIntegration Testing with the Avocado framework\nW: https://trello.com/b/6Qi1pxVn/avocado-qemu\nR: Cleber Rosa <crosa@redhat.com>\nR: Philippe Mathieu-Daudé <f4bug@amsat.org>\nR: Wainer dos Santos Moschetta <wainersm@redhat.com>\nR: Beraldo Leal <bleal@redhat.com>\nS: Odd Fixes\nF: tests/avocado/\n\nGitLab custom runner (Works On Arm Sponsored)\nM: Alex Bennée <alex.bennee@linaro.org>\nM: Philippe Mathieu-Daudé <f4bug@amsat.org>\nS: Maintained\nF: .gitlab-ci.d/custom-runners/ubuntu-20.04-aarch64.yml\n\nDocumentation\n-------------\nBuild system architecture\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: docs/devel/build-system.rst\n\nGIT Data Mining Config\nM: Alex Bennée <alex.bennee@linaro.org>\nS: Odd Fixes\nF: gitdm.config\nF: contrib/gitdm/*\n\nIncompatible changes\nR: libvir-list@redhat.com\nF: docs/about/deprecated.rst\n\nBuild System\n------------\nGIT submodules\nM: Daniel P. Berrange <berrange@redhat.com>\nS: Odd Fixes\nF: scripts/git-submodule.sh\n\nUI translations\nS: Orphan\nF: po/*.po\n\nSphinx documentation configuration and build machinery\nM: Peter Maydell <peter.maydell@linaro.org>\nS: Maintained\nF: docs/conf.py\nF: docs/*/conf.py\nF: docs/sphinx/\nF: docs/_templates/\n\nMiscellaneous\n-------------\nPerformance Tools and Tests\nM: Ahmed Karaman <ahmedkhaledkaraman@gmail.com>\nS: Maintained\nF: scripts/performance/\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 11.0087890625,
          "content": "# Makefile for QEMU.\n\nifneq ($(words $(subst :, ,$(CURDIR))), 1)\n  $(error main directory cannot contain spaces nor colons)\nendif\n\n# Always point to the root of the build tree (needs GNU make).\nBUILD_DIR=$(CURDIR)\n\n# Before including a proper config-host.mak, assume we are in the source tree\nSRC_PATH=.\n\n# Don't use implicit rules or variables\n# we have explicit rules for everything\nMAKEFLAGS += -rR\n\nSHELL = bash -o pipefail\n\n# Usage: $(call quiet-command,command and args,\"NAME\",\"args to print\")\n# This will run \"command and args\", and either:\n#  if V=1 just print the whole command and args\n#  otherwise print the 'quiet' output in the format \"  NAME     args to print\"\n# NAME should be a short name of the command, 7 letters or fewer.\n# If called with only a single argument, will print nothing in quiet mode.\nquiet-command-run = $(if $(V),,$(if $2,printf \"  %-7s %s\\n\" $2 $3 && ))$1\nquiet-@ = $(if $(V),,@)\nquiet-command = $(quiet-@)$(call quiet-command-run,$1,$2,$3)\n\nUNCHECKED_GOALS := %clean TAGS cscope ctags dist \\\n    help check-help print-% \\\n    docker docker-% vm-help vm-test vm-build-%\n\nall:\n.PHONY: all clean distclean recurse-all dist msi FORCE\n\n# Don't try to regenerate Makefile or configure\n# We don't generate any of them\nMakefile: ;\nconfigure: ;\n\n# All following code might depend on configuration variables\nifneq ($(wildcard config-host.mak),)\ninclude config-host.mak\n\ngit-submodule-update:\n.git-submodule-status: git-submodule-update config-host.mak\nMakefile: .git-submodule-status\n\n.PHONY: git-submodule-update\ngit-submodule-update:\nifneq ($(GIT_SUBMODULES_ACTION),ignore)\n\t$(call quiet-command, \\\n\t\t(GIT=\"$(GIT)\" \"$(SRC_PATH)/scripts/git-submodule.sh\" $(GIT_SUBMODULES_ACTION) $(GIT_SUBMODULES)), \\\n\t\t\"GIT\",\"$(GIT_SUBMODULES)\")\nendif\n\n# 0. ensure the build tree is okay\n\n# Check that we're not trying to do an out-of-tree build from\n# a tree that's been used for an in-tree build.\nifneq ($(realpath $(SRC_PATH)),$(realpath .))\nifneq ($(wildcard $(SRC_PATH)/config-host.mak),)\n$(error This is an out of tree build but your source tree ($(SRC_PATH)) \\\nseems to have been used for an in-tree build. You can fix this by running \\\n\"$(MAKE) distclean && rm -rf *-linux-user *-softmmu\" in your source tree)\nendif\nendif\n\n# force a rerun of configure if config-host.mak is too old or corrupted\nifeq ($(MESON),)\n.PHONY: config-host.mak\nx := $(shell rm -rf meson-private meson-info meson-logs)\nendif\nifeq ($(NINJA),)\n.PHONY: config-host.mak\nx := $(shell rm -rf meson-private meson-info meson-logs)\nelse\nexport NINJA\nendif\nifeq ($(wildcard build.ninja),)\n.PHONY: config-host.mak\nx := $(shell rm -rf meson-private meson-info meson-logs)\nendif\nifeq ($(origin prefix),file)\n.PHONY: config-host.mak\nx := $(shell rm -rf meson-private meson-info meson-logs)\nendif\n\n# 1. ensure config-host.mak is up-to-date\nconfig-host.mak: $(SRC_PATH)/configure $(SRC_PATH)/scripts/meson-buildoptions.sh $(SRC_PATH)/VERSION.QEMU\n\t@echo config-host.mak is out-of-date, running configure\n\t@if test -f meson-private/coredata.dat; then \\\n\t  ./config.status --skip-meson; \\\n\telse \\\n\t  ./config.status && touch build.ninja.stamp; \\\n\tfi\n\n# 2. meson.stamp exists if meson has run at least once (so ninja reconfigure\n# works), but otherwise never needs to be updated\nmeson-private/coredata.dat: meson.stamp\nmeson.stamp: config-host.mak\n\t@touch meson.stamp\n\n# 3. ensure generated build files are up-to-date\n\nifneq ($(NINJA),)\nMakefile.ninja: build.ninja\n\t$(quiet-@){ \\\n\t  echo 'ninja-targets = \\'; \\\n\t  $(NINJA) -t targets all | sed 's/:.*//; $$!s/$$/ \\\\/'; \\\n\t  echo 'build-files = \\'; \\\n\t  $(NINJA) -t query build.ninja | sed -n '1,/^  input:/d; /^  outputs:/q; s/$$/ \\\\/p'; \\\n\t} > $@.tmp && mv $@.tmp $@\n-include Makefile.ninja\n\n# A separate rule is needed for Makefile dependencies to avoid -n\nbuild.ninja: build.ninja.stamp\n$(build-files):\nbuild.ninja.stamp: meson.stamp $(build-files)\n\t$(NINJA) $(if $V,-v,) build.ninja && touch $@\nendif\n\nifneq ($(MESON),)\nMakefile.mtest: build.ninja scripts/mtest2make.py\n\t$(MESON) introspect --targets --tests --benchmarks | $(PYTHON) scripts/mtest2make.py > $@\n-include Makefile.mtest\n\n.PHONY: update-buildoptions\nall update-buildoptions: $(SRC_PATH)/scripts/meson-buildoptions.sh\n$(SRC_PATH)/scripts/meson-buildoptions.sh: $(SRC_PATH)/meson_options.txt\n\t$(MESON) introspect --buildoptions $(SRC_PATH)/meson.build | $(PYTHON) \\\n\t  scripts/meson-buildoptions.py > $@.tmp && mv $@.tmp $@\nendif\n\n# 4. Rules to bridge to other makefiles\n\nifneq ($(NINJA),)\n# Filter out long options to avoid flags like --no-print-directory which\n# may result in false positive match for MAKE.n\nMAKE.n = $(findstring n,$(firstword $(filter-out --%,$(MAKEFLAGS))))\nMAKE.k = $(findstring k,$(firstword $(filter-out --%,$(MAKEFLAGS))))\nMAKE.q = $(findstring q,$(firstword $(filter-out --%,$(MAKEFLAGS))))\nMAKE.nq = $(if $(word 2, $(MAKE.n) $(MAKE.q)),nq)\nNINJAFLAGS = $(if $V,-v) $(if $(MAKE.n), -n) $(if $(MAKE.k), -k0) \\\n        $(filter-out -j, $(lastword -j1 $(filter -l% -j%, $(MAKEFLAGS)))) \\\n        -d keepdepfile\nninja-cmd-goals = $(or $(MAKECMDGOALS), all)\nninja-cmd-goals += $(foreach g, $(MAKECMDGOALS), $(.ninja-goals.$g))))\n\nmakefile-targets := build.ninja ctags TAGS cscope dist clean uninstall\n# \"ninja -t targets\" also lists all prerequisites.  If build system\n# files are marked as PHONY, however, Make will always try to execute\n# \"ninja build.ninja\".\nninja-targets := $(filter-out $(build-files) $(makefile-targets), $(ninja-targets))\n.PHONY: $(ninja-targets) run-ninja\n$(ninja-targets): run-ninja\n\n# Use \"| cat\" to give Ninja a more \"make-y\" output.  Use \"+\" to bypass the\n# --output-sync line.\nrun-ninja: config-host.mak\nifneq ($(filter $(ninja-targets), $(ninja-cmd-goals)),)\n\t+$(if $(MAKE.nq),@:,$(quiet-@)$(NINJA) $(NINJAFLAGS) \\\n\t   $(sort $(filter $(ninja-targets), $(ninja-cmd-goals))) | cat)\nendif\nendif\n\nifeq ($(CONFIG_PLUGIN),y)\n.PHONY: plugins\nplugins:\n\t$(call quiet-command,\\\n\t\t$(MAKE) $(SUBDIR_MAKEFLAGS) -C contrib/plugins V=\"$(V)\", \\\n\t\t\"BUILD\", \"example plugins\")\nendif # $(CONFIG_PLUGIN)\n\nelse # config-host.mak does not exist\nconfig-host.mak:\nifneq ($(filter-out $(UNCHECKED_GOALS),$(MAKECMDGOALS)),$(if $(MAKECMDGOALS),,fail))\n\t@echo \"Please call configure before running make!\"\n\t@exit 1\nendif\nendif # config-host.mak does not exist\n\nSUBDIR_MAKEFLAGS=$(if $(V),,--no-print-directory --quiet)\n\ninclude $(SRC_PATH)/tests/Makefile.include\n\nall: recurse-all\n\nROMS_RULES=$(foreach t, all clean, $(addsuffix /$(t), $(ROMS)))\n.PHONY: $(ROMS_RULES)\n$(ROMS_RULES):\n\t$(call quiet-command,$(MAKE) $(SUBDIR_MAKEFLAGS) -C $(dir $@) V=\"$(V)\" TARGET_DIR=\"$(dir $@)\" $(notdir $@),)\n\n.PHONY: recurse-all recurse-clean\nrecurse-all: $(addsuffix /all, $(ROMS))\nrecurse-clean: $(addsuffix /clean, $(ROMS))\n\n######################################################################\n\nclean: recurse-clean\n\t-$(quiet-@)test -f build.ninja && $(NINJA) $(NINJAFLAGS) -t clean || :\n\t-$(quiet-@)test -f build.ninja && $(NINJA) $(NINJAFLAGS) clean-ctlist || :\n\tfind . \\( -name '*.so' -o -name '*.dll' -o \\\n\t\t  -name '*.[oda]' -o -name '*.gcno' \\) -type f \\\n\t\t! -path ./roms/edk2/ArmPkg/Library/GccLto/liblto-aarch64.a \\\n\t\t! -path ./roms/edk2/ArmPkg/Library/GccLto/liblto-arm.a \\\n\t\t-exec rm {} +\n\trm -f TAGS cscope.* *~ */*~\n\nVERSION = $(shell cat $(SRC_PATH)/VERSION.QEMU)\n\ndist: qemu-$(VERSION).tar.bz2\n\nqemu-%.tar.bz2:\n\t$(SRC_PATH)/scripts/make-release \"$(SRC_PATH)\" \"$(patsubst qemu-%.tar.bz2,%,$@)\"\n\ndistclean: clean\n\t-$(quiet-@)test -f build.ninja && $(NINJA) $(NINJAFLAGS) -t clean -g || :\n\trm -f config-host.mak qemu-bundle\n\trm -f tests/tcg/config-*.mak\n\trm -f config.status\n\trm -f roms/seabios/config.mak\n\trm -f qemu-plugins-ld.symbols qemu-plugins-ld64.symbols\n\trm -f *-config-target.h *-config-devices.mak *-config-devices.h\n\trm -rf meson-private meson-logs meson-info compile_commands.json\n\trm -f Makefile.ninja Makefile.mtest build.ninja.stamp meson.stamp\n\trm -f config.log\n\trm -f linux-headers/asm\n\trm -Rf .sdk\n\nfind-src-path = find \"$(SRC_PATH)\" -path \"$(SRC_PATH)/meson\" -prune -o \\\n\t-type l -prune -o \\( -name \"*.[chsS]\" -o -name \"*.[ch].inc\" \\)\n\n.PHONY: ctags\nctags:\n\t$(call quiet-command, \t\t\t\\\n\t\trm -f \"$(SRC_PATH)/\"tags, \t\\\n\t\t\"CTAGS\", \"Remove old tags\")\n\t$(call quiet-command, \\\n\t\t$(find-src-path) -exec ctags \t\t\\\n\t\t-f \"$(SRC_PATH)/\"tags --append {} +,\t\\\n\t\t\"CTAGS\", \"Re-index $(SRC_PATH)\")\n\n.PHONY: gtags\ngtags:\n\t$(call quiet-command, \t\t\t\\\n\t\trm -f \"$(SRC_PATH)/\"GTAGS; \t\\\n\t\trm -f \"$(SRC_PATH)/\"GRTAGS; \t\\\n\t\trm -f \"$(SRC_PATH)/\"GPATH, \t\\\n\t\t\"GTAGS\", \"Remove old $@ files\")\n\t$(call quiet-command, \t\t\t\t\\\n\t        (cd $(SRC_PATH) && \t\t\t\\\n\t\t $(find-src-path) -print | gtags -f -),\t\\\n\t\t\"GTAGS\", \"Re-index $(SRC_PATH)\")\n\n.PHONY: TAGS\nTAGS:\n\t$(call quiet-command, \t\t\t\\\n\t\trm -f \"$(SRC_PATH)/\"TAGS,\t\\\n\t\t\"TAGS\", \"Remove old $@\")\n\t$(call quiet-command, \t\t\t\t\\\n\t\t$(find-src-path) -exec etags \t\t\\\n\t\t-f \"$(SRC_PATH)/\"TAGS --append {} +, \t\\\n\t\t\"TAGS\", \"Re-index $(SRC_PATH)\")\n\n.PHONY: cscope\ncscope:\n\t$(call quiet-command,\t\t\t\\\n\t\trm -f \"$(SRC_PATH)/\"cscope.* ,\t\\\n\t\t\"cscope\", \"Remove old $@ files\")\n\t$(call quiet-command, \t\t\t\t\t\\\n\t\t($(find-src-path) -print | sed -e 's,^\\./,,'    \\\n\t\t> \"$(SRC_PATH)/cscope.files\"), \t\t\t\\\n\t\t\"cscope\", \"Create file list\")\n\t$(call quiet-command, \t\t\t\t\\\n\t\tcscope -b -i\"$(SRC_PATH)/cscope.files\" \t\\\n\t\t-f\"$(SRC_PATH)\"/cscope.out, \t\t\\\n\t\t\"cscope\", \"Re-index $(SRC_PATH)\")\n\n# Needed by \"meson install\"\nexport DESTDIR\n\ninclude $(SRC_PATH)/tests/lcitool/Makefile.include\ninclude $(SRC_PATH)/tests/docker/Makefile.include\ninclude $(SRC_PATH)/tests/vm/Makefile.include\n\nprint-help-run = printf \"  %-30s - %s\\\\n\" \"$1\" \"$2\"\nprint-help = @$(call print-help-run,$1,$2)\n\n.PHONY: help\nhelp:\n\t@echo  'Generic targets:'\n\t$(call print-help,all,Build all)\n\t$(call print-help,dir/file.o,Build specified target only)\n\t$(call print-help,install,Install QEMU, documentation and tools)\n\t$(call print-help,ctags/gtags/TAGS,Generate tags file for editors)\n\t$(call print-help,cscope,Generate cscope index)\n\t$(call print-help,sparse,Run sparse on the QEMU source)\n\t@echo  ''\nifeq ($(CONFIG_PLUGIN),y)\n\t@echo  'Plugin targets:'\n\t$(call print-help,plugins,Build the example TCG plugins)\n\t@echo  ''\nendif\n\t@echo  'Cleaning targets:'\n\t$(call print-help,clean,Remove most generated files but keep the config)\n\t$(call print-help,distclean,Remove all generated files)\n\t$(call print-help,dist,Build a distributable tarball)\n\t@echo  ''\n\t@echo  'Test targets:'\n\t$(call print-help,check,Run all tests (check-help for details))\n\t$(call print-help,bench,Run all benchmarks)\n\t$(call print-help,lcitool-help,Help about targets for managing build environment manifests)\n\t$(call print-help,docker-help,Help about targets running tests inside containers)\n\t$(call print-help,vm-help,Help about targets running tests inside VM)\n\t@echo  ''\n\t@echo  'Documentation targets:'\n\t$(call print-help,html man,Build documentation in specified format)\n\t@echo  ''\nifdef CONFIG_WIN32\n\t@echo  'Windows targets:'\n\t$(call print-help,installer,Build NSIS-based installer for QEMU)\n\t$(call print-help,msi,Build MSI-based installer for qemu-ga)\n\t@echo  ''\nendif\n\t$(call print-help,$(MAKE) [targets],(quiet build, default))\n\t$(call print-help,$(MAKE) V=1 [targets],(verbose build))\n\n# will delete the target of a rule if commands exit with a nonzero exit status\n.DELETE_ON_ERROR:\n\nprint-%:\n\t@echo '$*=$($*)'\n"
        },
        {
          "name": "README.rst",
          "type": "blob",
          "size": 5.4453125,
          "content": "===========\nQEMU README\n===========\n\nQEMU is a generic and open source machine & userspace emulator and\nvirtualizer.\n\nQEMU is capable of emulating a complete machine in software without any\nneed for hardware virtualization support. By using dynamic translation,\nit achieves very good performance. QEMU can also integrate with the Xen\nand KVM hypervisors to provide emulated hardware while allowing the\nhypervisor to manage the CPU. With hypervisor support, QEMU can achieve\nnear native performance for CPUs. When QEMU emulates CPUs directly it is\ncapable of running operating systems made for one machine (e.g. an ARMv7\nboard) on a different machine (e.g. an x86_64 PC board).\n\nQEMU is also capable of providing userspace API virtualization for Linux\nand BSD kernel interfaces. This allows binaries compiled against one\narchitecture ABI (e.g. the Linux PPC64 ABI) to be run on a host using a\ndifferent architecture ABI (e.g. the Linux x86_64 ABI). This does not\ninvolve any hardware emulation, simply CPU and syscall emulation.\n\nQEMU aims to fit into a variety of use cases. It can be invoked directly\nby users wishing to have full control over its behaviour and settings.\nIt also aims to facilitate integration into higher level management\nlayers, by providing a stable command line interface and monitor API.\nIt is commonly invoked indirectly via the libvirt library when using\nopen source applications such as oVirt, OpenStack and virt-manager.\n\nQEMU as a whole is released under the GNU General Public License,\nversion 2. For full licensing details, consult the LICENSE file.\n\n\nDocumentation\n=============\n\nDocumentation can be found hosted online at\n`<https://www.qemu.org/documentation/>`_. The documentation for the\ncurrent development version that is available at\n`<https://www.qemu.org/docs/master/>`_ is generated from the ``docs/``\nfolder in the source tree, and is built by `Sphinx\n<https://www.sphinx-doc.org/en/master/>`_.\n\n\nBuilding\n========\n\nQEMU is multi-platform software intended to be buildable on all modern\nLinux platforms, OS-X, Win32 (via the Mingw64 toolchain) and a variety\nof other UNIX targets. The simple steps to build QEMU are:\n\n\n.. code-block:: shell\n\n  mkdir build\n  cd build\n  ../configure\n  make\n\nAdditional information can also be found online via the QEMU website:\n\n* `<https://wiki.qemu.org/Hosts/Linux>`_\n* `<https://wiki.qemu.org/Hosts/Mac>`_\n* `<https://wiki.qemu.org/Hosts/W32>`_\n\n\nSubmitting patches\n==================\n\nThe QEMU source code is maintained under the GIT version control system.\n\n.. code-block:: shell\n\n   git clone https://gitlab.com/qemu-project/qemu.git\n\nWhen submitting patches, one common approach is to use 'git\nformat-patch' and/or 'git send-email' to format & send the mail to the\nqemu-devel@nongnu.org mailing list. All patches submitted must contain\na 'Signed-off-by' line from the author. Patches should follow the\nguidelines set out in the `style section\n<https://www.qemu.org/docs/master/devel/style.html>`_ of\nthe Developers Guide.\n\nAdditional information on submitting patches can be found online via\nthe QEMU website\n\n* `<https://wiki.qemu.org/Contribute/SubmitAPatch>`_\n* `<https://wiki.qemu.org/Contribute/TrivialPatches>`_\n\nThe QEMU website is also maintained under source control.\n\n.. code-block:: shell\n\n  git clone https://gitlab.com/qemu-project/qemu-web.git\n\n* `<https://www.qemu.org/2017/02/04/the-new-qemu-website-is-up/>`_\n\nA 'git-publish' utility was created to make above process less\ncumbersome, and is highly recommended for making regular contributions,\nor even just for sending consecutive patch series revisions. It also\nrequires a working 'git send-email' setup, and by default doesn't\nautomate everything, so you may want to go through the above steps\nmanually for once.\n\nFor installation instructions, please go to\n\n*  `<https://github.com/stefanha/git-publish>`_\n\nThe workflow with 'git-publish' is:\n\n.. code-block:: shell\n\n  $ git checkout master -b my-feature\n  $ # work on new commits, add your 'Signed-off-by' lines to each\n  $ git publish\n\nYour patch series will be sent and tagged as my-feature-v1 if you need to refer\nback to it in the future.\n\nSending v2:\n\n.. code-block:: shell\n\n  $ git checkout my-feature # same topic branch\n  $ # making changes to the commits (using 'git rebase', for example)\n  $ git publish\n\nYour patch series will be sent with 'v2' tag in the subject and the git tip\nwill be tagged as my-feature-v2.\n\nBug reporting\n=============\n\nThe QEMU project uses GitLab issues to track bugs. Bugs\nfound when running code built from QEMU git or upstream released sources\nshould be reported via:\n\n* `<https://gitlab.com/qemu-project/qemu/-/issues>`_\n\nIf using QEMU via an operating system vendor pre-built binary package, it\nis preferable to report bugs to the vendor's own bug tracker first. If\nthe bug is also known to affect latest upstream code, it can also be\nreported via GitLab.\n\nFor additional information on bug reporting consult:\n\n* `<https://wiki.qemu.org/Contribute/ReportABug>`_\n\n\nChangeLog\n=========\n\nFor version history and release notes, please visit\n`<https://wiki.qemu.org/ChangeLog/>`_ or look at the git history for\nmore detailed information.\n\n\nContact\n=======\n\nThe QEMU community can be contacted in a number of ways, with the two\nmain methods being email and IRC\n\n* `<mailto:qemu-devel@nongnu.org>`_\n* `<https://lists.nongnu.org/mailman/listinfo/qemu-devel>`_\n* #qemu on irc.oftc.net\n\nInformation on additional methods of contacting the community can be\nfound online via the QEMU website:\n\n* `<https://wiki.qemu.org/Contribute/StartHere>`_\n"
        },
        {
          "name": "VERSION.QEMU",
          "type": "blob",
          "size": 0.005859375,
          "content": "7.1.0\n"
        },
        {
          "name": "accel",
          "type": "tree",
          "content": null
        },
        {
          "name": "audio",
          "type": "tree",
          "content": null
        },
        {
          "name": "authz",
          "type": "tree",
          "content": null
        },
        {
          "name": "backends",
          "type": "tree",
          "content": null
        },
        {
          "name": "block.c",
          "type": "blob",
          "size": 241.767578125,
          "content": "/*\n * QEMU System Emulator block driver\n *\n * Copyright (c) 2003 Fabrice Bellard\n * Copyright (c) 2020 Virtuozzo International GmbH.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"block/trace.h\"\n#include \"block/block_int.h\"\n#include \"block/blockjob.h\"\n#include \"block/fuse.h\"\n#include \"block/nbd.h\"\n#include \"block/qdict.h\"\n#include \"qemu/error-report.h\"\n#include \"block/module_block.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/module.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qmp/qdict.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"qapi/qmp/qnull.h\"\n#include \"qapi/qmp/qstring.h\"\n#include \"qapi/qobject-output-visitor.h\"\n#include \"qapi/qapi-visit-block-core.h\"\n#include \"sysemu/block-backend.h\"\n#include \"qemu/notify.h\"\n#include \"qemu/option.h\"\n#include \"qemu/coroutine.h\"\n#include \"block/qapi.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/id.h\"\n#include \"qemu/range.h\"\n#include \"qemu/rcu.h\"\n#include \"block/coroutines.h\"\n\n#ifdef CONFIG_BSD\n#include <sys/ioctl.h>\n#include <sys/queue.h>\n#if defined(HAVE_SYS_DISK_H)\n#include <sys/disk.h>\n#endif\n#endif\n\n#ifdef _WIN32\n#include <windows.h>\n#endif\n\n#define NOT_DONE 0x7fffffff /* used while emulated sync operation in progress */\n\n/* Protected by BQL */\nstatic QTAILQ_HEAD(, BlockDriverState) graph_bdrv_states =\n    QTAILQ_HEAD_INITIALIZER(graph_bdrv_states);\n\n/* Protected by BQL */\nstatic QTAILQ_HEAD(, BlockDriverState) all_bdrv_states =\n    QTAILQ_HEAD_INITIALIZER(all_bdrv_states);\n\n/* Protected by BQL */\nstatic QLIST_HEAD(, BlockDriver) bdrv_drivers =\n    QLIST_HEAD_INITIALIZER(bdrv_drivers);\n\nstatic BlockDriverState *bdrv_open_inherit(const char *filename,\n                                           const char *reference,\n                                           QDict *options, int flags,\n                                           BlockDriverState *parent,\n                                           const BdrvChildClass *child_class,\n                                           BdrvChildRole child_role,\n                                           Error **errp);\n\nstatic bool bdrv_recurse_has_child(BlockDriverState *bs,\n                                   BlockDriverState *child);\n\nstatic void bdrv_child_free(BdrvChild *child);\nstatic void bdrv_replace_child_noperm(BdrvChild **child,\n                                      BlockDriverState *new_bs,\n                                      bool free_empty_child);\nstatic void bdrv_remove_file_or_backing_child(BlockDriverState *bs,\n                                              BdrvChild *child,\n                                              Transaction *tran);\nstatic void bdrv_remove_filter_or_cow_child(BlockDriverState *bs,\n                                            Transaction *tran);\n\nstatic int bdrv_reopen_prepare(BDRVReopenState *reopen_state,\n                               BlockReopenQueue *queue,\n                               Transaction *change_child_tran, Error **errp);\nstatic void bdrv_reopen_commit(BDRVReopenState *reopen_state);\nstatic void bdrv_reopen_abort(BDRVReopenState *reopen_state);\n\nstatic bool bdrv_backing_overridden(BlockDriverState *bs);\n\n/* If non-zero, use only whitelisted block drivers */\nstatic int use_bdrv_whitelist;\n\n#ifdef _WIN32\nstatic int is_windows_drive_prefix(const char *filename)\n{\n    return (((filename[0] >= 'a' && filename[0] <= 'z') ||\n             (filename[0] >= 'A' && filename[0] <= 'Z')) &&\n            filename[1] == ':');\n}\n\nint is_windows_drive(const char *filename)\n{\n    if (is_windows_drive_prefix(filename) &&\n        filename[2] == '\\0')\n        return 1;\n    if (strstart(filename, \"\\\\\\\\.\\\\\", NULL) ||\n        strstart(filename, \"//./\", NULL))\n        return 1;\n    return 0;\n}\n#endif\n\nsize_t bdrv_opt_mem_align(BlockDriverState *bs)\n{\n    if (!bs || !bs->drv) {\n        /* page size or 4k (hdd sector size) should be on the safe side */\n        return MAX(4096, qemu_real_host_page_size());\n    }\n    IO_CODE();\n\n    return bs->bl.opt_mem_alignment;\n}\n\nsize_t bdrv_min_mem_align(BlockDriverState *bs)\n{\n    if (!bs || !bs->drv) {\n        /* page size or 4k (hdd sector size) should be on the safe side */\n        return MAX(4096, qemu_real_host_page_size());\n    }\n    IO_CODE();\n\n    return bs->bl.min_mem_alignment;\n}\n\n/* check if the path starts with \"<protocol>:\" */\nint path_has_protocol(const char *path)\n{\n    const char *p;\n\n#ifdef _WIN32\n    if (is_windows_drive(path) ||\n        is_windows_drive_prefix(path)) {\n        return 0;\n    }\n    p = path + strcspn(path, \":/\\\\\");\n#else\n    p = path + strcspn(path, \":/\");\n#endif\n\n    return *p == ':';\n}\n\nint path_is_absolute(const char *path)\n{\n#ifdef _WIN32\n    /* specific case for names like: \"\\\\.\\d:\" */\n    if (is_windows_drive(path) || is_windows_drive_prefix(path)) {\n        return 1;\n    }\n    return (*path == '/' || *path == '\\\\');\n#else\n    return (*path == '/');\n#endif\n}\n\n/* if filename is absolute, just return its duplicate. Otherwise, build a\n   path to it by considering it is relative to base_path. URL are\n   supported. */\nchar *path_combine(const char *base_path, const char *filename)\n{\n    const char *protocol_stripped = NULL;\n    const char *p, *p1;\n    char *result;\n    int len;\n\n    if (path_is_absolute(filename)) {\n        return g_strdup(filename);\n    }\n\n    if (path_has_protocol(base_path)) {\n        protocol_stripped = strchr(base_path, ':');\n        if (protocol_stripped) {\n            protocol_stripped++;\n        }\n    }\n    p = protocol_stripped ?: base_path;\n\n    p1 = strrchr(base_path, '/');\n#ifdef _WIN32\n    {\n        const char *p2;\n        p2 = strrchr(base_path, '\\\\');\n        if (!p1 || p2 > p1) {\n            p1 = p2;\n        }\n    }\n#endif\n    if (p1) {\n        p1++;\n    } else {\n        p1 = base_path;\n    }\n    if (p1 > p) {\n        p = p1;\n    }\n    len = p - base_path;\n\n    result = g_malloc(len + strlen(filename) + 1);\n    memcpy(result, base_path, len);\n    strcpy(result + len, filename);\n\n    return result;\n}\n\n/*\n * Helper function for bdrv_parse_filename() implementations to remove optional\n * protocol prefixes (especially \"file:\") from a filename and for putting the\n * stripped filename into the options QDict if there is such a prefix.\n */\nvoid bdrv_parse_filename_strip_prefix(const char *filename, const char *prefix,\n                                      QDict *options)\n{\n    if (strstart(filename, prefix, &filename)) {\n        /* Stripping the explicit protocol prefix may result in a protocol\n         * prefix being (wrongly) detected (if the filename contains a colon) */\n        if (path_has_protocol(filename)) {\n            GString *fat_filename;\n\n            /* This means there is some colon before the first slash; therefore,\n             * this cannot be an absolute path */\n            assert(!path_is_absolute(filename));\n\n            /* And we can thus fix the protocol detection issue by prefixing it\n             * by \"./\" */\n            fat_filename = g_string_new(\"./\");\n            g_string_append(fat_filename, filename);\n\n            assert(!path_has_protocol(fat_filename->str));\n\n            qdict_put(options, \"filename\",\n                      qstring_from_gstring(fat_filename));\n        } else {\n            /* If no protocol prefix was detected, we can use the shortened\n             * filename as-is */\n            qdict_put_str(options, \"filename\", filename);\n        }\n    }\n}\n\n\n/* Returns whether the image file is opened as read-only. Note that this can\n * return false and writing to the image file is still not possible because the\n * image is inactivated. */\nbool bdrv_is_read_only(BlockDriverState *bs)\n{\n    IO_CODE();\n    return !(bs->open_flags & BDRV_O_RDWR);\n}\n\nint bdrv_can_set_read_only(BlockDriverState *bs, bool read_only,\n                           bool ignore_allow_rdw, Error **errp)\n{\n    IO_CODE();\n\n    /* Do not set read_only if copy_on_read is enabled */\n    if (bs->copy_on_read && read_only) {\n        error_setg(errp, \"Can't set node '%s' to r/o with copy-on-read enabled\",\n                   bdrv_get_device_or_node_name(bs));\n        return -EINVAL;\n    }\n\n    /* Do not clear read_only if it is prohibited */\n    if (!read_only && !(bs->open_flags & BDRV_O_ALLOW_RDWR) &&\n        !ignore_allow_rdw)\n    {\n        error_setg(errp, \"Node '%s' is read only\",\n                   bdrv_get_device_or_node_name(bs));\n        return -EPERM;\n    }\n\n    return 0;\n}\n\n/*\n * Called by a driver that can only provide a read-only image.\n *\n * Returns 0 if the node is already read-only or it could switch the node to\n * read-only because BDRV_O_AUTO_RDONLY is set.\n *\n * Returns -EACCES if the node is read-write and BDRV_O_AUTO_RDONLY is not set\n * or bdrv_can_set_read_only() forbids making the node read-only. If @errmsg\n * is not NULL, it is used as the error message for the Error object.\n */\nint bdrv_apply_auto_read_only(BlockDriverState *bs, const char *errmsg,\n                              Error **errp)\n{\n    int ret = 0;\n    IO_CODE();\n\n    if (!(bs->open_flags & BDRV_O_RDWR)) {\n        return 0;\n    }\n    if (!(bs->open_flags & BDRV_O_AUTO_RDONLY)) {\n        goto fail;\n    }\n\n    ret = bdrv_can_set_read_only(bs, true, false, NULL);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    bs->open_flags &= ~BDRV_O_RDWR;\n\n    return 0;\n\nfail:\n    error_setg(errp, \"%s\", errmsg ?: \"Image is read-only\");\n    return -EACCES;\n}\n\n/*\n * If @backing is empty, this function returns NULL without setting\n * @errp.  In all other cases, NULL will only be returned with @errp\n * set.\n *\n * Therefore, a return value of NULL without @errp set means that\n * there is no backing file; if @errp is set, there is one but its\n * absolute filename cannot be generated.\n */\nchar *bdrv_get_full_backing_filename_from_filename(const char *backed,\n                                                   const char *backing,\n                                                   Error **errp)\n{\n    if (backing[0] == '\\0') {\n        return NULL;\n    } else if (path_has_protocol(backing) || path_is_absolute(backing)) {\n        return g_strdup(backing);\n    } else if (backed[0] == '\\0' || strstart(backed, \"json:\", NULL)) {\n        error_setg(errp, \"Cannot use relative backing file names for '%s'\",\n                   backed);\n        return NULL;\n    } else {\n        return path_combine(backed, backing);\n    }\n}\n\n/*\n * If @filename is empty or NULL, this function returns NULL without\n * setting @errp.  In all other cases, NULL will only be returned with\n * @errp set.\n */\nstatic char *bdrv_make_absolute_filename(BlockDriverState *relative_to,\n                                         const char *filename, Error **errp)\n{\n    char *dir, *full_name;\n\n    if (!filename || filename[0] == '\\0') {\n        return NULL;\n    } else if (path_has_protocol(filename) || path_is_absolute(filename)) {\n        return g_strdup(filename);\n    }\n\n    dir = bdrv_dirname(relative_to, errp);\n    if (!dir) {\n        return NULL;\n    }\n\n    full_name = g_strconcat(dir, filename, NULL);\n    g_free(dir);\n    return full_name;\n}\n\nchar *bdrv_get_full_backing_filename(BlockDriverState *bs, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    return bdrv_make_absolute_filename(bs, bs->backing_file, errp);\n}\n\nvoid bdrv_register(BlockDriver *bdrv)\n{\n    assert(bdrv->format_name);\n    GLOBAL_STATE_CODE();\n    QLIST_INSERT_HEAD(&bdrv_drivers, bdrv, list);\n}\n\nBlockDriverState *bdrv_new(void)\n{\n    BlockDriverState *bs;\n    int i;\n\n    GLOBAL_STATE_CODE();\n\n    bs = g_new0(BlockDriverState, 1);\n    QLIST_INIT(&bs->dirty_bitmaps);\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        QLIST_INIT(&bs->op_blockers[i]);\n    }\n    qemu_co_mutex_init(&bs->reqs_lock);\n    qemu_mutex_init(&bs->dirty_bitmap_mutex);\n    bs->refcnt = 1;\n    bs->aio_context = qemu_get_aio_context();\n\n    qemu_co_queue_init(&bs->flush_queue);\n\n    qemu_co_mutex_init(&bs->bsc_modify_lock);\n    bs->block_status_cache = g_new0(BdrvBlockStatusCache, 1);\n\n    for (i = 0; i < bdrv_drain_all_count; i++) {\n        bdrv_drained_begin(bs);\n    }\n\n    QTAILQ_INSERT_TAIL(&all_bdrv_states, bs, bs_list);\n\n    return bs;\n}\n\nstatic BlockDriver *bdrv_do_find_format(const char *format_name)\n{\n    BlockDriver *drv1;\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n        if (!strcmp(drv1->format_name, format_name)) {\n            return drv1;\n        }\n    }\n\n    return NULL;\n}\n\nBlockDriver *bdrv_find_format(const char *format_name)\n{\n    BlockDriver *drv1;\n    int i;\n\n    GLOBAL_STATE_CODE();\n\n    drv1 = bdrv_do_find_format(format_name);\n    if (drv1) {\n        return drv1;\n    }\n\n    /* The driver isn't registered, maybe we need to load a module */\n    for (i = 0; i < (int)ARRAY_SIZE(block_driver_modules); ++i) {\n        if (!strcmp(block_driver_modules[i].format_name, format_name)) {\n            block_module_load_one(block_driver_modules[i].library_name);\n            break;\n        }\n    }\n\n    return bdrv_do_find_format(format_name);\n}\n\nstatic int bdrv_format_is_whitelisted(const char *format_name, bool read_only)\n{\n    static const char *whitelist_rw[] = {\n        CONFIG_BDRV_RW_WHITELIST\n        NULL\n    };\n    static const char *whitelist_ro[] = {\n        CONFIG_BDRV_RO_WHITELIST\n        NULL\n    };\n    const char **p;\n\n    if (!whitelist_rw[0] && !whitelist_ro[0]) {\n        return 1;               /* no whitelist, anything goes */\n    }\n\n    for (p = whitelist_rw; *p; p++) {\n        if (!strcmp(format_name, *p)) {\n            return 1;\n        }\n    }\n    if (read_only) {\n        for (p = whitelist_ro; *p; p++) {\n            if (!strcmp(format_name, *p)) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint bdrv_is_whitelisted(BlockDriver *drv, bool read_only)\n{\n    GLOBAL_STATE_CODE();\n    return bdrv_format_is_whitelisted(drv->format_name, read_only);\n}\n\nbool bdrv_uses_whitelist(void)\n{\n    return use_bdrv_whitelist;\n}\n\ntypedef struct CreateCo {\n    BlockDriver *drv;\n    char *filename;\n    QemuOpts *opts;\n    int ret;\n    Error *err;\n} CreateCo;\n\nstatic void coroutine_fn bdrv_create_co_entry(void *opaque)\n{\n    Error *local_err = NULL;\n    int ret;\n\n    CreateCo *cco = opaque;\n    assert(cco->drv);\n    GLOBAL_STATE_CODE();\n\n    ret = cco->drv->bdrv_co_create_opts(cco->drv,\n                                        cco->filename, cco->opts, &local_err);\n    error_propagate(&cco->err, local_err);\n    cco->ret = ret;\n}\n\nint bdrv_create(BlockDriver *drv, const char* filename,\n                QemuOpts *opts, Error **errp)\n{\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    Coroutine *co;\n    CreateCo cco = {\n        .drv = drv,\n        .filename = g_strdup(filename),\n        .opts = opts,\n        .ret = NOT_DONE,\n        .err = NULL,\n    };\n\n    if (!drv->bdrv_co_create_opts) {\n        error_setg(errp, \"Driver '%s' does not support image creation\", drv->format_name);\n        ret = -ENOTSUP;\n        goto out;\n    }\n\n    if (qemu_in_coroutine()) {\n        /* Fast-path if already in coroutine context */\n        bdrv_create_co_entry(&cco);\n    } else {\n        co = qemu_coroutine_create(bdrv_create_co_entry, &cco);\n        qemu_coroutine_enter(co);\n        while (cco.ret == NOT_DONE) {\n            aio_poll(qemu_get_aio_context(), true);\n        }\n    }\n\n    ret = cco.ret;\n    if (ret < 0) {\n        if (cco.err) {\n            error_propagate(errp, cco.err);\n        } else {\n            error_setg_errno(errp, -ret, \"Could not create image\");\n        }\n    }\n\nout:\n    g_free(cco.filename);\n    return ret;\n}\n\n/**\n * Helper function for bdrv_create_file_fallback(): Resize @blk to at\n * least the given @minimum_size.\n *\n * On success, return @blk's actual length.\n * Otherwise, return -errno.\n */\nstatic int64_t create_file_fallback_truncate(BlockBackend *blk,\n                                             int64_t minimum_size, Error **errp)\n{\n    Error *local_err = NULL;\n    int64_t size;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    ret = blk_truncate(blk, minimum_size, false, PREALLOC_MODE_OFF, 0,\n                       &local_err);\n    if (ret < 0 && ret != -ENOTSUP) {\n        error_propagate(errp, local_err);\n        return ret;\n    }\n\n    size = blk_getlength(blk);\n    if (size < 0) {\n        error_free(local_err);\n        error_setg_errno(errp, -size,\n                         \"Failed to inquire the new image file's length\");\n        return size;\n    }\n\n    if (size < minimum_size) {\n        /* Need to grow the image, but we failed to do that */\n        error_propagate(errp, local_err);\n        return -ENOTSUP;\n    }\n\n    error_free(local_err);\n    local_err = NULL;\n\n    return size;\n}\n\n/**\n * Helper function for bdrv_create_file_fallback(): Zero the first\n * sector to remove any potentially pre-existing image header.\n */\nstatic int create_file_fallback_zero_first_sector(BlockBackend *blk,\n                                                  int64_t current_size,\n                                                  Error **errp)\n{\n    int64_t bytes_to_clear;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    bytes_to_clear = MIN(current_size, BDRV_SECTOR_SIZE);\n    if (bytes_to_clear) {\n        ret = blk_pwrite_zeroes(blk, 0, bytes_to_clear, BDRV_REQ_MAY_UNMAP);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret,\n                             \"Failed to clear the new image's first sector\");\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Simple implementation of bdrv_co_create_opts for protocol drivers\n * which only support creation via opening a file\n * (usually existing raw storage device)\n */\nint coroutine_fn bdrv_co_create_opts_simple(BlockDriver *drv,\n                                            const char *filename,\n                                            QemuOpts *opts,\n                                            Error **errp)\n{\n    BlockBackend *blk;\n    QDict *options;\n    int64_t size = 0;\n    char *buf = NULL;\n    PreallocMode prealloc;\n    Error *local_err = NULL;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    size = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0);\n    buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);\n    prealloc = qapi_enum_parse(&PreallocMode_lookup, buf,\n                               PREALLOC_MODE_OFF, &local_err);\n    g_free(buf);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return -EINVAL;\n    }\n\n    if (prealloc != PREALLOC_MODE_OFF) {\n        error_setg(errp, \"Unsupported preallocation mode '%s'\",\n                   PreallocMode_str(prealloc));\n        return -ENOTSUP;\n    }\n\n    options = qdict_new();\n    qdict_put_str(options, \"driver\", drv->format_name);\n\n    blk = blk_new_open(filename, NULL, options,\n                       BDRV_O_RDWR | BDRV_O_RESIZE, errp);\n    if (!blk) {\n        error_prepend(errp, \"Protocol driver '%s' does not support image \"\n                      \"creation, and opening the image failed: \",\n                      drv->format_name);\n        return -EINVAL;\n    }\n\n    size = create_file_fallback_truncate(blk, size, errp);\n    if (size < 0) {\n        ret = size;\n        goto out;\n    }\n\n    ret = create_file_fallback_zero_first_sector(blk, size, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = 0;\nout:\n    blk_unref(blk);\n    return ret;\n}\n\nint bdrv_create_file(const char *filename, QemuOpts *opts, Error **errp)\n{\n    QemuOpts *protocol_opts;\n    BlockDriver *drv;\n    QDict *qdict;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    drv = bdrv_find_protocol(filename, true, errp);\n    if (drv == NULL) {\n        return -ENOENT;\n    }\n\n    if (!drv->create_opts) {\n        error_setg(errp, \"Driver '%s' does not support image creation\",\n                   drv->format_name);\n        return -ENOTSUP;\n    }\n\n    /*\n     * 'opts' contains a QemuOptsList with a combination of format and protocol\n     * default values.\n     *\n     * The format properly removes its options, but the default values remain\n     * in 'opts->list'.  So if the protocol has options with the same name\n     * (e.g. rbd has 'cluster_size' as qcow2), it will see the default values\n     * of the format, since for overlapping options, the format wins.\n     *\n     * To avoid this issue, lets convert QemuOpts to QDict, in this way we take\n     * only the set options, and then convert it back to QemuOpts, using the\n     * create_opts of the protocol. So the new QemuOpts, will contain only the\n     * protocol defaults.\n     */\n    qdict = qemu_opts_to_qdict(opts, NULL);\n    protocol_opts = qemu_opts_from_qdict(drv->create_opts, qdict, errp);\n    if (protocol_opts == NULL) {\n        ret = -EINVAL;\n        goto out;\n    }\n\n    ret = bdrv_create(drv, filename, protocol_opts, errp);\nout:\n    qemu_opts_del(protocol_opts);\n    qobject_unref(qdict);\n    return ret;\n}\n\nint coroutine_fn bdrv_co_delete_file(BlockDriverState *bs, Error **errp)\n{\n    Error *local_err = NULL;\n    int ret;\n\n    IO_CODE();\n    assert(bs != NULL);\n\n    if (!bs->drv) {\n        error_setg(errp, \"Block node '%s' is not opened\", bs->filename);\n        return -ENOMEDIUM;\n    }\n\n    if (!bs->drv->bdrv_co_delete_file) {\n        error_setg(errp, \"Driver '%s' does not support image deletion\",\n                   bs->drv->format_name);\n        return -ENOTSUP;\n    }\n\n    ret = bs->drv->bdrv_co_delete_file(bs, &local_err);\n    if (ret < 0) {\n        error_propagate(errp, local_err);\n    }\n\n    return ret;\n}\n\nvoid coroutine_fn bdrv_co_delete_file_noerr(BlockDriverState *bs)\n{\n    Error *local_err = NULL;\n    int ret;\n    IO_CODE();\n\n    if (!bs) {\n        return;\n    }\n\n    ret = bdrv_co_delete_file(bs, &local_err);\n    /*\n     * ENOTSUP will happen if the block driver doesn't support\n     * the 'bdrv_co_delete_file' interface. This is a predictable\n     * scenario and shouldn't be reported back to the user.\n     */\n    if (ret == -ENOTSUP) {\n        error_free(local_err);\n    } else if (ret < 0) {\n        error_report_err(local_err);\n    }\n}\n\n/**\n * Try to get @bs's logical and physical block size.\n * On success, store them in @bsz struct and return 0.\n * On failure return -errno.\n * @bs must not be empty.\n */\nint bdrv_probe_blocksizes(BlockDriverState *bs, BlockSizes *bsz)\n{\n    BlockDriver *drv = bs->drv;\n    BlockDriverState *filtered = bdrv_filter_bs(bs);\n    GLOBAL_STATE_CODE();\n\n    if (drv && drv->bdrv_probe_blocksizes) {\n        return drv->bdrv_probe_blocksizes(bs, bsz);\n    } else if (filtered) {\n        return bdrv_probe_blocksizes(filtered, bsz);\n    }\n\n    return -ENOTSUP;\n}\n\n/**\n * Try to get @bs's geometry (cyls, heads, sectors).\n * On success, store them in @geo struct and return 0.\n * On failure return -errno.\n * @bs must not be empty.\n */\nint bdrv_probe_geometry(BlockDriverState *bs, HDGeometry *geo)\n{\n    BlockDriver *drv = bs->drv;\n    BlockDriverState *filtered = bdrv_filter_bs(bs);\n    GLOBAL_STATE_CODE();\n\n    if (drv && drv->bdrv_probe_geometry) {\n        return drv->bdrv_probe_geometry(bs, geo);\n    } else if (filtered) {\n        return bdrv_probe_geometry(filtered, geo);\n    }\n\n    return -ENOTSUP;\n}\n\n/*\n * Create a uniquely-named empty temporary file.\n * Return 0 upon success, otherwise a negative errno value.\n */\nint get_tmp_filename(char *filename, int size)\n{\n#ifdef _WIN32\n    char temp_dir[MAX_PATH];\n    /* GetTempFileName requires that its output buffer (4th param)\n       have length MAX_PATH or greater.  */\n    assert(size >= MAX_PATH);\n    return (GetTempPath(MAX_PATH, temp_dir)\n            && GetTempFileName(temp_dir, \"qem\", 0, filename)\n            ? 0 : -GetLastError());\n#else\n    int fd;\n    const char *tmpdir;\n    tmpdir = getenv(\"TMPDIR\");\n    if (!tmpdir) {\n        tmpdir = \"/var/tmp\";\n    }\n    if (snprintf(filename, size, \"%s/vl.XXXXXX\", tmpdir) >= size) {\n        return -EOVERFLOW;\n    }\n    fd = mkstemp(filename);\n    if (fd < 0) {\n        return -errno;\n    }\n    if (close(fd) != 0) {\n        unlink(filename);\n        return -errno;\n    }\n    return 0;\n#endif\n}\n\n/*\n * Detect host devices. By convention, /dev/cdrom[N] is always\n * recognized as a host CDROM.\n */\nstatic BlockDriver *find_hdev_driver(const char *filename)\n{\n    int score_max = 0, score;\n    BlockDriver *drv = NULL, *d;\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n        if (d->bdrv_probe_device) {\n            score = d->bdrv_probe_device(filename);\n            if (score > score_max) {\n                score_max = score;\n                drv = d;\n            }\n        }\n    }\n\n    return drv;\n}\n\nstatic BlockDriver *bdrv_do_find_protocol(const char *protocol)\n{\n    BlockDriver *drv1;\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(drv1, &bdrv_drivers, list) {\n        if (drv1->protocol_name && !strcmp(drv1->protocol_name, protocol)) {\n            return drv1;\n        }\n    }\n\n    return NULL;\n}\n\nBlockDriver *bdrv_find_protocol(const char *filename,\n                                bool allow_protocol_prefix,\n                                Error **errp)\n{\n    BlockDriver *drv1;\n    char protocol[128];\n    int len;\n    const char *p;\n    int i;\n\n    GLOBAL_STATE_CODE();\n    /* TODO Drivers without bdrv_file_open must be specified explicitly */\n\n    /*\n     * XXX(hch): we really should not let host device detection\n     * override an explicit protocol specification, but moving this\n     * later breaks access to device names with colons in them.\n     * Thanks to the brain-dead persistent naming schemes on udev-\n     * based Linux systems those actually are quite common.\n     */\n    drv1 = find_hdev_driver(filename);\n    if (drv1) {\n        return drv1;\n    }\n\n    if (!path_has_protocol(filename) || !allow_protocol_prefix) {\n        return &bdrv_file;\n    }\n\n    p = strchr(filename, ':');\n    assert(p != NULL);\n    len = p - filename;\n    if (len > sizeof(protocol) - 1)\n        len = sizeof(protocol) - 1;\n    memcpy(protocol, filename, len);\n    protocol[len] = '\\0';\n\n    drv1 = bdrv_do_find_protocol(protocol);\n    if (drv1) {\n        return drv1;\n    }\n\n    for (i = 0; i < (int)ARRAY_SIZE(block_driver_modules); ++i) {\n        if (block_driver_modules[i].protocol_name &&\n            !strcmp(block_driver_modules[i].protocol_name, protocol)) {\n            block_module_load_one(block_driver_modules[i].library_name);\n            break;\n        }\n    }\n\n    drv1 = bdrv_do_find_protocol(protocol);\n    if (!drv1) {\n        error_setg(errp, \"Unknown protocol '%s'\", protocol);\n    }\n    return drv1;\n}\n\n/*\n * Guess image format by probing its contents.\n * This is not a good idea when your image is raw (CVE-2008-2004), but\n * we do it anyway for backward compatibility.\n *\n * @buf         contains the image's first @buf_size bytes.\n * @buf_size    is the buffer size in bytes (generally BLOCK_PROBE_BUF_SIZE,\n *              but can be smaller if the image file is smaller)\n * @filename    is its filename.\n *\n * For all block drivers, call the bdrv_probe() method to get its\n * probing score.\n * Return the first block driver with the highest probing score.\n */\nBlockDriver *bdrv_probe_all(const uint8_t *buf, int buf_size,\n                            const char *filename)\n{\n    int score_max = 0, score;\n    BlockDriver *drv = NULL, *d;\n    IO_CODE();\n\n    QLIST_FOREACH(d, &bdrv_drivers, list) {\n        if (d->bdrv_probe) {\n            score = d->bdrv_probe(buf, buf_size, filename);\n            if (score > score_max) {\n                score_max = score;\n                drv = d;\n            }\n        }\n    }\n\n    return drv;\n}\n\nstatic int find_image_format(BlockBackend *file, const char *filename,\n                             BlockDriver **pdrv, Error **errp)\n{\n    BlockDriver *drv;\n    uint8_t buf[BLOCK_PROBE_BUF_SIZE];\n    int ret = 0;\n\n    GLOBAL_STATE_CODE();\n\n    /* Return the raw BlockDriver * to scsi-generic devices or empty drives */\n    if (blk_is_sg(file) || !blk_is_inserted(file) || blk_getlength(file) == 0) {\n        *pdrv = &bdrv_raw;\n        return ret;\n    }\n\n    ret = blk_pread(file, 0, sizeof(buf), buf, 0);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not read image for determining its \"\n                         \"format\");\n        *pdrv = NULL;\n        return ret;\n    }\n\n    drv = bdrv_probe_all(buf, sizeof(buf), filename);\n    if (!drv) {\n        error_setg(errp, \"Could not determine image format: No compatible \"\n                   \"driver found\");\n        *pdrv = NULL;\n        return -ENOENT;\n    }\n\n    *pdrv = drv;\n    return 0;\n}\n\n/**\n * Set the current 'total_sectors' value\n * Return 0 on success, -errno on error.\n */\nint refresh_total_sectors(BlockDriverState *bs, int64_t hint)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n\n    if (!drv) {\n        return -ENOMEDIUM;\n    }\n\n    /* Do not attempt drv->bdrv_getlength() on scsi-generic devices */\n    if (bdrv_is_sg(bs))\n        return 0;\n\n    /* query actual device if possible, otherwise just trust the hint */\n    if (drv->bdrv_getlength) {\n        int64_t length = drv->bdrv_getlength(bs);\n        if (length < 0) {\n            return length;\n        }\n        hint = DIV_ROUND_UP(length, BDRV_SECTOR_SIZE);\n    }\n\n    bs->total_sectors = hint;\n\n    if (bs->total_sectors * BDRV_SECTOR_SIZE > BDRV_MAX_LENGTH) {\n        return -EFBIG;\n    }\n\n    return 0;\n}\n\n/**\n * Combines a QDict of new block driver @options with any missing options taken\n * from @old_options, so that leaving out an option defaults to its old value.\n */\nstatic void bdrv_join_options(BlockDriverState *bs, QDict *options,\n                              QDict *old_options)\n{\n    GLOBAL_STATE_CODE();\n    if (bs->drv && bs->drv->bdrv_join_options) {\n        bs->drv->bdrv_join_options(options, old_options);\n    } else {\n        qdict_join(options, old_options, false);\n    }\n}\n\nstatic BlockdevDetectZeroesOptions bdrv_parse_detect_zeroes(QemuOpts *opts,\n                                                            int open_flags,\n                                                            Error **errp)\n{\n    Error *local_err = NULL;\n    char *value = qemu_opt_get_del(opts, \"detect-zeroes\");\n    BlockdevDetectZeroesOptions detect_zeroes =\n        qapi_enum_parse(&BlockdevDetectZeroesOptions_lookup, value,\n                        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF, &local_err);\n    GLOBAL_STATE_CODE();\n    g_free(value);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return detect_zeroes;\n    }\n\n    if (detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&\n        !(open_flags & BDRV_O_UNMAP))\n    {\n        error_setg(errp, \"setting detect-zeroes to unmap is not allowed \"\n                   \"without setting discard operation to unmap\");\n    }\n\n    return detect_zeroes;\n}\n\n/**\n * Set open flags for aio engine\n *\n * Return 0 on success, -1 if the engine specified is invalid\n */\nint bdrv_parse_aio(const char *mode, int *flags)\n{\n    if (!strcmp(mode, \"threads\")) {\n        /* do nothing, default */\n    } else if (!strcmp(mode, \"native\")) {\n        *flags |= BDRV_O_NATIVE_AIO;\n#ifdef CONFIG_LINUX_IO_URING\n    } else if (!strcmp(mode, \"io_uring\")) {\n        *flags |= BDRV_O_IO_URING;\n#endif\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * Set open flags for a given discard mode\n *\n * Return 0 on success, -1 if the discard mode was invalid.\n */\nint bdrv_parse_discard_flags(const char *mode, int *flags)\n{\n    *flags &= ~BDRV_O_UNMAP;\n\n    if (!strcmp(mode, \"off\") || !strcmp(mode, \"ignore\")) {\n        /* do nothing */\n    } else if (!strcmp(mode, \"on\") || !strcmp(mode, \"unmap\")) {\n        *flags |= BDRV_O_UNMAP;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * Set open flags for a given cache mode\n *\n * Return 0 on success, -1 if the cache mode was invalid.\n */\nint bdrv_parse_cache_mode(const char *mode, int *flags, bool *writethrough)\n{\n    *flags &= ~BDRV_O_CACHE_MASK;\n\n    if (!strcmp(mode, \"off\") || !strcmp(mode, \"none\")) {\n        *writethrough = false;\n        *flags |= BDRV_O_NOCACHE;\n    } else if (!strcmp(mode, \"directsync\")) {\n        *writethrough = true;\n        *flags |= BDRV_O_NOCACHE;\n    } else if (!strcmp(mode, \"writeback\")) {\n        *writethrough = false;\n    } else if (!strcmp(mode, \"unsafe\")) {\n        *writethrough = false;\n        *flags |= BDRV_O_NO_FLUSH;\n    } else if (!strcmp(mode, \"writethrough\")) {\n        *writethrough = true;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic char *bdrv_child_get_parent_desc(BdrvChild *c)\n{\n    BlockDriverState *parent = c->opaque;\n    return g_strdup_printf(\"node '%s'\", bdrv_get_node_name(parent));\n}\n\nstatic void bdrv_child_cb_drained_begin(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n    bdrv_do_drained_begin_quiesce(bs, NULL, false);\n}\n\nstatic bool bdrv_child_cb_drained_poll(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n    return bdrv_drain_poll(bs, false, NULL, false);\n}\n\nstatic void bdrv_child_cb_drained_end(BdrvChild *child,\n                                      int *drained_end_counter)\n{\n    BlockDriverState *bs = child->opaque;\n    bdrv_drained_end_no_poll(bs, drained_end_counter);\n}\n\nstatic int bdrv_child_cb_inactivate(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n    GLOBAL_STATE_CODE();\n    assert(bs->open_flags & BDRV_O_INACTIVE);\n    return 0;\n}\n\nstatic bool bdrv_child_cb_can_set_aio_ctx(BdrvChild *child, AioContext *ctx,\n                                          GSList **ignore, Error **errp)\n{\n    BlockDriverState *bs = child->opaque;\n    return bdrv_can_set_aio_context(bs, ctx, ignore, errp);\n}\n\nstatic void bdrv_child_cb_set_aio_ctx(BdrvChild *child, AioContext *ctx,\n                                      GSList **ignore)\n{\n    BlockDriverState *bs = child->opaque;\n    return bdrv_set_aio_context_ignore(bs, ctx, ignore);\n}\n\n/*\n * Returns the options and flags that a temporary snapshot should get, based on\n * the originally requested flags (the originally requested image will have\n * flags like a backing file)\n */\nstatic void bdrv_temp_snapshot_options(int *child_flags, QDict *child_options,\n                                       int parent_flags, QDict *parent_options)\n{\n    GLOBAL_STATE_CODE();\n    *child_flags = (parent_flags & ~BDRV_O_SNAPSHOT) | BDRV_O_TEMPORARY;\n\n    /* For temporary files, unconditional cache=unsafe is fine */\n    qdict_set_default_str(child_options, BDRV_OPT_CACHE_DIRECT, \"off\");\n    qdict_set_default_str(child_options, BDRV_OPT_CACHE_NO_FLUSH, \"on\");\n\n    /* Copy the read-only and discard options from the parent */\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_READ_ONLY);\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_DISCARD);\n\n    /* aio=native doesn't work for cache.direct=off, so disable it for the\n     * temporary snapshot */\n    *child_flags &= ~BDRV_O_NATIVE_AIO;\n}\n\nstatic void bdrv_backing_attach(BdrvChild *c)\n{\n    BlockDriverState *parent = c->opaque;\n    BlockDriverState *backing_hd = c->bs;\n\n    GLOBAL_STATE_CODE();\n    assert(!parent->backing_blocker);\n    error_setg(&parent->backing_blocker,\n               \"node is used as backing hd of '%s'\",\n               bdrv_get_device_or_node_name(parent));\n\n    bdrv_refresh_filename(backing_hd);\n\n    parent->open_flags &= ~BDRV_O_NO_BACKING;\n\n    bdrv_op_block_all(backing_hd, parent->backing_blocker);\n    /* Otherwise we won't be able to commit or stream */\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_COMMIT_TARGET,\n                    parent->backing_blocker);\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_STREAM,\n                    parent->backing_blocker);\n    /*\n     * We do backup in 3 ways:\n     * 1. drive backup\n     *    The target bs is new opened, and the source is top BDS\n     * 2. blockdev backup\n     *    Both the source and the target are top BDSes.\n     * 3. internal backup(used for block replication)\n     *    Both the source and the target are backing file\n     *\n     * In case 1 and 2, neither the source nor the target is the backing file.\n     * In case 3, we will block the top BDS, so there is only one block job\n     * for the top BDS and its backing chain.\n     */\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_BACKUP_SOURCE,\n                    parent->backing_blocker);\n    bdrv_op_unblock(backing_hd, BLOCK_OP_TYPE_BACKUP_TARGET,\n                    parent->backing_blocker);\n}\n\nstatic void bdrv_backing_detach(BdrvChild *c)\n{\n    BlockDriverState *parent = c->opaque;\n\n    GLOBAL_STATE_CODE();\n    assert(parent->backing_blocker);\n    bdrv_op_unblock_all(c->bs, parent->backing_blocker);\n    error_free(parent->backing_blocker);\n    parent->backing_blocker = NULL;\n}\n\nstatic int bdrv_backing_update_filename(BdrvChild *c, BlockDriverState *base,\n                                        const char *filename, Error **errp)\n{\n    BlockDriverState *parent = c->opaque;\n    bool read_only = bdrv_is_read_only(parent);\n    int ret;\n    GLOBAL_STATE_CODE();\n\n    if (read_only) {\n        ret = bdrv_reopen_set_read_only(parent, false, errp);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    ret = bdrv_change_backing_file(parent, filename,\n                                   base->drv ? base->drv->format_name : \"\",\n                                   false);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not update backing file link\");\n    }\n\n    if (read_only) {\n        bdrv_reopen_set_read_only(parent, true, NULL);\n    }\n\n    return ret;\n}\n\n/*\n * Returns the options and flags that a generic child of a BDS should\n * get, based on the given options and flags for the parent BDS.\n */\nstatic void bdrv_inherited_options(BdrvChildRole role, bool parent_is_format,\n                                   int *child_flags, QDict *child_options,\n                                   int parent_flags, QDict *parent_options)\n{\n    int flags = parent_flags;\n    GLOBAL_STATE_CODE();\n\n    /*\n     * First, decide whether to set, clear, or leave BDRV_O_PROTOCOL.\n     * Generally, the question to answer is: Should this child be\n     * format-probed by default?\n     */\n\n    /*\n     * Pure and non-filtered data children of non-format nodes should\n     * be probed by default (even when the node itself has BDRV_O_PROTOCOL\n     * set).  This only affects a very limited set of drivers (namely\n     * quorum and blkverify when this comment was written).\n     * Force-clear BDRV_O_PROTOCOL then.\n     */\n    if (!parent_is_format &&\n        (role & BDRV_CHILD_DATA) &&\n        !(role & (BDRV_CHILD_METADATA | BDRV_CHILD_FILTERED)))\n    {\n        flags &= ~BDRV_O_PROTOCOL;\n    }\n\n    /*\n     * All children of format nodes (except for COW children) and all\n     * metadata children in general should never be format-probed.\n     * Force-set BDRV_O_PROTOCOL then.\n     */\n    if ((parent_is_format && !(role & BDRV_CHILD_COW)) ||\n        (role & BDRV_CHILD_METADATA))\n    {\n        flags |= BDRV_O_PROTOCOL;\n    }\n\n    /*\n     * If the cache mode isn't explicitly set, inherit direct and no-flush from\n     * the parent.\n     */\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_CACHE_DIRECT);\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_CACHE_NO_FLUSH);\n    qdict_copy_default(child_options, parent_options, BDRV_OPT_FORCE_SHARE);\n\n    if (role & BDRV_CHILD_COW) {\n        /* backing files are opened read-only by default */\n        qdict_set_default_str(child_options, BDRV_OPT_READ_ONLY, \"on\");\n        qdict_set_default_str(child_options, BDRV_OPT_AUTO_READ_ONLY, \"off\");\n    } else {\n        /* Inherit the read-only option from the parent if it's not set */\n        qdict_copy_default(child_options, parent_options, BDRV_OPT_READ_ONLY);\n        qdict_copy_default(child_options, parent_options,\n                           BDRV_OPT_AUTO_READ_ONLY);\n    }\n\n    /*\n     * bdrv_co_pdiscard() respects unmap policy for the parent, so we\n     * can default to enable it on lower layers regardless of the\n     * parent option.\n     */\n    qdict_set_default_str(child_options, BDRV_OPT_DISCARD, \"unmap\");\n\n    /* Clear flags that only apply to the top layer */\n    flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING | BDRV_O_COPY_ON_READ);\n\n    if (role & BDRV_CHILD_METADATA) {\n        flags &= ~BDRV_O_NO_IO;\n    }\n    if (role & BDRV_CHILD_COW) {\n        flags &= ~BDRV_O_TEMPORARY;\n    }\n\n    *child_flags = flags;\n}\n\nstatic void bdrv_child_cb_attach(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n\n    assert_bdrv_graph_writable(bs);\n    QLIST_INSERT_HEAD(&bs->children, child, next);\n\n    if (child->role & BDRV_CHILD_COW) {\n        bdrv_backing_attach(child);\n    }\n\n    bdrv_apply_subtree_drain(child, bs);\n}\n\nstatic void bdrv_child_cb_detach(BdrvChild *child)\n{\n    BlockDriverState *bs = child->opaque;\n\n    if (child->role & BDRV_CHILD_COW) {\n        bdrv_backing_detach(child);\n    }\n\n    bdrv_unapply_subtree_drain(child, bs);\n\n    assert_bdrv_graph_writable(bs);\n    QLIST_REMOVE(child, next);\n}\n\nstatic int bdrv_child_cb_update_filename(BdrvChild *c, BlockDriverState *base,\n                                         const char *filename, Error **errp)\n{\n    if (c->role & BDRV_CHILD_COW) {\n        return bdrv_backing_update_filename(c, base, filename, errp);\n    }\n    return 0;\n}\n\nAioContext *child_of_bds_get_parent_aio_context(BdrvChild *c)\n{\n    BlockDriverState *bs = c->opaque;\n    IO_CODE();\n\n    return bdrv_get_aio_context(bs);\n}\n\nconst BdrvChildClass child_of_bds = {\n    .parent_is_bds   = true,\n    .get_parent_desc = bdrv_child_get_parent_desc,\n    .inherit_options = bdrv_inherited_options,\n    .drained_begin   = bdrv_child_cb_drained_begin,\n    .drained_poll    = bdrv_child_cb_drained_poll,\n    .drained_end     = bdrv_child_cb_drained_end,\n    .attach          = bdrv_child_cb_attach,\n    .detach          = bdrv_child_cb_detach,\n    .inactivate      = bdrv_child_cb_inactivate,\n    .can_set_aio_ctx = bdrv_child_cb_can_set_aio_ctx,\n    .set_aio_ctx     = bdrv_child_cb_set_aio_ctx,\n    .update_filename = bdrv_child_cb_update_filename,\n    .get_parent_aio_context = child_of_bds_get_parent_aio_context,\n};\n\nAioContext *bdrv_child_get_parent_aio_context(BdrvChild *c)\n{\n    GLOBAL_STATE_CODE();\n    return c->klass->get_parent_aio_context(c);\n}\n\nstatic int bdrv_open_flags(BlockDriverState *bs, int flags)\n{\n    int open_flags = flags;\n    GLOBAL_STATE_CODE();\n\n    /*\n     * Clear flags that are internal to the block layer before opening the\n     * image.\n     */\n    open_flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING | BDRV_O_PROTOCOL);\n\n    return open_flags;\n}\n\nstatic void update_flags_from_options(int *flags, QemuOpts *opts)\n{\n    GLOBAL_STATE_CODE();\n\n    *flags &= ~(BDRV_O_CACHE_MASK | BDRV_O_RDWR | BDRV_O_AUTO_RDONLY);\n\n    if (qemu_opt_get_bool_del(opts, BDRV_OPT_CACHE_NO_FLUSH, false)) {\n        *flags |= BDRV_O_NO_FLUSH;\n    }\n\n    if (qemu_opt_get_bool_del(opts, BDRV_OPT_CACHE_DIRECT, false)) {\n        *flags |= BDRV_O_NOCACHE;\n    }\n\n    if (!qemu_opt_get_bool_del(opts, BDRV_OPT_READ_ONLY, false)) {\n        *flags |= BDRV_O_RDWR;\n    }\n\n    if (qemu_opt_get_bool_del(opts, BDRV_OPT_AUTO_READ_ONLY, false)) {\n        *flags |= BDRV_O_AUTO_RDONLY;\n    }\n}\n\nstatic void update_options_from_flags(QDict *options, int flags)\n{\n    GLOBAL_STATE_CODE();\n    if (!qdict_haskey(options, BDRV_OPT_CACHE_DIRECT)) {\n        qdict_put_bool(options, BDRV_OPT_CACHE_DIRECT, flags & BDRV_O_NOCACHE);\n    }\n    if (!qdict_haskey(options, BDRV_OPT_CACHE_NO_FLUSH)) {\n        qdict_put_bool(options, BDRV_OPT_CACHE_NO_FLUSH,\n                       flags & BDRV_O_NO_FLUSH);\n    }\n    if (!qdict_haskey(options, BDRV_OPT_READ_ONLY)) {\n        qdict_put_bool(options, BDRV_OPT_READ_ONLY, !(flags & BDRV_O_RDWR));\n    }\n    if (!qdict_haskey(options, BDRV_OPT_AUTO_READ_ONLY)) {\n        qdict_put_bool(options, BDRV_OPT_AUTO_READ_ONLY,\n                       flags & BDRV_O_AUTO_RDONLY);\n    }\n}\n\nstatic void bdrv_assign_node_name(BlockDriverState *bs,\n                                  const char *node_name,\n                                  Error **errp)\n{\n    char *gen_node_name = NULL;\n    GLOBAL_STATE_CODE();\n\n    if (!node_name) {\n        node_name = gen_node_name = id_generate(ID_BLOCK);\n    } else if (!id_wellformed(node_name)) {\n        /*\n         * Check for empty string or invalid characters, but not if it is\n         * generated (generated names use characters not available to the user)\n         */\n        error_setg(errp, \"Invalid node-name: '%s'\", node_name);\n        return;\n    }\n\n    /* takes care of avoiding namespaces collisions */\n    if (blk_by_name(node_name)) {\n        error_setg(errp, \"node-name=%s is conflicting with a device id\",\n                   node_name);\n        goto out;\n    }\n\n    /* takes care of avoiding duplicates node names */\n    if (bdrv_find_node(node_name)) {\n        error_setg(errp, \"Duplicate nodes with node-name='%s'\", node_name);\n        goto out;\n    }\n\n    /* Make sure that the node name isn't truncated */\n    if (strlen(node_name) >= sizeof(bs->node_name)) {\n        error_setg(errp, \"Node name too long\");\n        goto out;\n    }\n\n    /* copy node name into the bs and insert it into the graph list */\n    pstrcpy(bs->node_name, sizeof(bs->node_name), node_name);\n    QTAILQ_INSERT_TAIL(&graph_bdrv_states, bs, node_list);\nout:\n    g_free(gen_node_name);\n}\n\nstatic int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,\n                            const char *node_name, QDict *options,\n                            int open_flags, Error **errp)\n{\n    Error *local_err = NULL;\n    int i, ret;\n    GLOBAL_STATE_CODE();\n\n    bdrv_assign_node_name(bs, node_name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return -EINVAL;\n    }\n\n    bs->drv = drv;\n    bs->opaque = g_malloc0(drv->instance_size);\n\n    if (drv->bdrv_file_open) {\n        assert(!drv->bdrv_needs_filename || bs->filename[0]);\n        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);\n    } else if (drv->bdrv_open) {\n        ret = drv->bdrv_open(bs, options, open_flags, &local_err);\n    } else {\n        ret = 0;\n    }\n\n    if (ret < 0) {\n        if (local_err) {\n            error_propagate(errp, local_err);\n        } else if (bs->filename[0]) {\n            error_setg_errno(errp, -ret, \"Could not open '%s'\", bs->filename);\n        } else {\n            error_setg_errno(errp, -ret, \"Could not open image\");\n        }\n        goto open_failed;\n    }\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n        return ret;\n    }\n\n    bdrv_refresh_limits(bs, NULL, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return -EINVAL;\n    }\n\n    assert(bdrv_opt_mem_align(bs) != 0);\n    assert(bdrv_min_mem_align(bs) != 0);\n    assert(is_power_of_2(bs->bl.request_alignment));\n\n    for (i = 0; i < bs->quiesce_counter; i++) {\n        if (drv->bdrv_co_drain_begin) {\n            drv->bdrv_co_drain_begin(bs);\n        }\n    }\n\n    return 0;\nopen_failed:\n    bs->drv = NULL;\n    if (bs->file != NULL) {\n        bdrv_unref_child(bs, bs->file);\n        bs->file = NULL;\n    }\n    g_free(bs->opaque);\n    bs->opaque = NULL;\n    return ret;\n}\n\n/*\n * Create and open a block node.\n *\n * @options is a QDict of options to pass to the block drivers, or NULL for an\n * empty set of options. The reference to the QDict belongs to the block layer\n * after the call (even on failure), so if the caller intends to reuse the\n * dictionary, it needs to use qobject_ref() before calling bdrv_open.\n */\nBlockDriverState *bdrv_new_open_driver_opts(BlockDriver *drv,\n                                            const char *node_name,\n                                            QDict *options, int flags,\n                                            Error **errp)\n{\n    BlockDriverState *bs;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    bs = bdrv_new();\n    bs->open_flags = flags;\n    bs->options = options ?: qdict_new();\n    bs->explicit_options = qdict_clone_shallow(bs->options);\n    bs->opaque = NULL;\n\n    update_options_from_flags(bs->options, flags);\n\n    ret = bdrv_open_driver(bs, drv, node_name, bs->options, flags, errp);\n    if (ret < 0) {\n        qobject_unref(bs->explicit_options);\n        bs->explicit_options = NULL;\n        qobject_unref(bs->options);\n        bs->options = NULL;\n        bdrv_unref(bs);\n        return NULL;\n    }\n\n    return bs;\n}\n\n/* Create and open a block node. */\nBlockDriverState *bdrv_new_open_driver(BlockDriver *drv, const char *node_name,\n                                       int flags, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    return bdrv_new_open_driver_opts(drv, node_name, NULL, flags, errp);\n}\n\nQemuOptsList bdrv_runtime_opts = {\n    .name = \"bdrv_common\",\n    .head = QTAILQ_HEAD_INITIALIZER(bdrv_runtime_opts.head),\n    .desc = {\n        {\n            .name = \"node-name\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Node name of the block device node\",\n        },\n        {\n            .name = \"driver\",\n            .type = QEMU_OPT_STRING,\n            .help = \"Block driver to use for the node\",\n        },\n        {\n            .name = BDRV_OPT_CACHE_DIRECT,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Bypass software writeback cache on the host\",\n        },\n        {\n            .name = BDRV_OPT_CACHE_NO_FLUSH,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Ignore flush requests\",\n        },\n        {\n            .name = BDRV_OPT_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Node is opened in read-only mode\",\n        },\n        {\n            .name = BDRV_OPT_AUTO_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Node can become read-only if opening read-write fails\",\n        },\n        {\n            .name = \"detect-zeroes\",\n            .type = QEMU_OPT_STRING,\n            .help = \"try to optimize zero writes (off, on, unmap)\",\n        },\n        {\n            .name = BDRV_OPT_DISCARD,\n            .type = QEMU_OPT_STRING,\n            .help = \"discard operation (ignore/off, unmap/on)\",\n        },\n        {\n            .name = BDRV_OPT_FORCE_SHARE,\n            .type = QEMU_OPT_BOOL,\n            .help = \"always accept other writers (default: off)\",\n        },\n        { /* end of list */ }\n    },\n};\n\nQemuOptsList bdrv_create_opts_simple = {\n    .name = \"simple-create-opts\",\n    .head = QTAILQ_HEAD_INITIALIZER(bdrv_create_opts_simple.head),\n    .desc = {\n        {\n            .name = BLOCK_OPT_SIZE,\n            .type = QEMU_OPT_SIZE,\n            .help = \"Virtual disk size\"\n        },\n        {\n            .name = BLOCK_OPT_PREALLOC,\n            .type = QEMU_OPT_STRING,\n            .help = \"Preallocation mode (allowed values: off)\"\n        },\n        { /* end of list */ }\n    }\n};\n\n/*\n * Common part for opening disk images and files\n *\n * Removes all processed options from *options.\n */\nstatic int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,\n                            QDict *options, Error **errp)\n{\n    int ret, open_flags;\n    const char *filename;\n    const char *driver_name = NULL;\n    const char *node_name = NULL;\n    const char *discard;\n    QemuOpts *opts;\n    BlockDriver *drv;\n    Error *local_err = NULL;\n    bool ro;\n\n    assert(bs->file == NULL);\n    assert(options != NULL && bs->options != options);\n    GLOBAL_STATE_CODE();\n\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n    if (!qemu_opts_absorb_qdict(opts, options, errp)) {\n        ret = -EINVAL;\n        goto fail_opts;\n    }\n\n    update_flags_from_options(&bs->open_flags, opts);\n\n    driver_name = qemu_opt_get(opts, \"driver\");\n    drv = bdrv_find_format(driver_name);\n    assert(drv != NULL);\n\n    bs->force_share = qemu_opt_get_bool(opts, BDRV_OPT_FORCE_SHARE, false);\n\n    if (bs->force_share && (bs->open_flags & BDRV_O_RDWR)) {\n        error_setg(errp,\n                   BDRV_OPT_FORCE_SHARE\n                   \"=on can only be used with read-only images\");\n        ret = -EINVAL;\n        goto fail_opts;\n    }\n\n    if (file != NULL) {\n        bdrv_refresh_filename(blk_bs(file));\n        filename = blk_bs(file)->filename;\n    } else {\n        /*\n         * Caution: while qdict_get_try_str() is fine, getting\n         * non-string types would require more care.  When @options\n         * come from -blockdev or blockdev_add, its members are typed\n         * according to the QAPI schema, but when they come from\n         * -drive, they're all QString.\n         */\n        filename = qdict_get_try_str(options, \"filename\");\n    }\n\n    if (drv->bdrv_needs_filename && (!filename || !filename[0])) {\n        error_setg(errp, \"The '%s' block driver requires a file name\",\n                   drv->format_name);\n        ret = -EINVAL;\n        goto fail_opts;\n    }\n\n    trace_bdrv_open_common(bs, filename ?: \"\", bs->open_flags,\n                           drv->format_name);\n\n    ro = bdrv_is_read_only(bs);\n\n    if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, ro)) {\n        if (!ro && bdrv_is_whitelisted(drv, true)) {\n            ret = bdrv_apply_auto_read_only(bs, NULL, NULL);\n        } else {\n            ret = -ENOTSUP;\n        }\n        if (ret < 0) {\n            error_setg(errp,\n                       !ro && bdrv_is_whitelisted(drv, true)\n                       ? \"Driver '%s' can only be used for read-only devices\"\n                       : \"Driver '%s' is not whitelisted\",\n                       drv->format_name);\n            goto fail_opts;\n        }\n    }\n\n    /* bdrv_new() and bdrv_close() make it so */\n    assert(qatomic_read(&bs->copy_on_read) == 0);\n\n    if (bs->open_flags & BDRV_O_COPY_ON_READ) {\n        if (!ro) {\n            bdrv_enable_copy_on_read(bs);\n        } else {\n            error_setg(errp, \"Can't use copy-on-read on read-only device\");\n            ret = -EINVAL;\n            goto fail_opts;\n        }\n    }\n\n    discard = qemu_opt_get(opts, BDRV_OPT_DISCARD);\n    if (discard != NULL) {\n        if (bdrv_parse_discard_flags(discard, &bs->open_flags) != 0) {\n            error_setg(errp, \"Invalid discard option\");\n            ret = -EINVAL;\n            goto fail_opts;\n        }\n    }\n\n    bs->detect_zeroes =\n        bdrv_parse_detect_zeroes(opts, bs->open_flags, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto fail_opts;\n    }\n\n    if (filename != NULL) {\n        pstrcpy(bs->filename, sizeof(bs->filename), filename);\n    } else {\n        bs->filename[0] = '\\0';\n    }\n    pstrcpy(bs->exact_filename, sizeof(bs->exact_filename), bs->filename);\n\n    /* Open the image, either directly or using a protocol */\n    open_flags = bdrv_open_flags(bs, bs->open_flags);\n    node_name = qemu_opt_get(opts, \"node-name\");\n\n    assert(!drv->bdrv_file_open || file == NULL);\n    ret = bdrv_open_driver(bs, drv, node_name, options, open_flags, errp);\n    if (ret < 0) {\n        goto fail_opts;\n    }\n\n    qemu_opts_del(opts);\n    return 0;\n\nfail_opts:\n    qemu_opts_del(opts);\n    return ret;\n}\n\nstatic QDict *parse_json_filename(const char *filename, Error **errp)\n{\n    QObject *options_obj;\n    QDict *options;\n    int ret;\n    GLOBAL_STATE_CODE();\n\n    ret = strstart(filename, \"json:\", &filename);\n    assert(ret);\n\n    options_obj = qobject_from_json(filename, errp);\n    if (!options_obj) {\n        error_prepend(errp, \"Could not parse the JSON options: \");\n        return NULL;\n    }\n\n    options = qobject_to(QDict, options_obj);\n    if (!options) {\n        qobject_unref(options_obj);\n        error_setg(errp, \"Invalid JSON object given\");\n        return NULL;\n    }\n\n    qdict_flatten(options);\n\n    return options;\n}\n\nstatic void parse_json_protocol(QDict *options, const char **pfilename,\n                                Error **errp)\n{\n    QDict *json_options;\n    Error *local_err = NULL;\n    GLOBAL_STATE_CODE();\n\n    /* Parse json: pseudo-protocol */\n    if (!*pfilename || !g_str_has_prefix(*pfilename, \"json:\")) {\n        return;\n    }\n\n    json_options = parse_json_filename(*pfilename, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    /* Options given in the filename have lower priority than options\n     * specified directly */\n    qdict_join(options, json_options, false);\n    qobject_unref(json_options);\n    *pfilename = NULL;\n}\n\n/*\n * Fills in default options for opening images and converts the legacy\n * filename/flags pair to option QDict entries.\n * The BDRV_O_PROTOCOL flag in *flags will be set or cleared accordingly if a\n * block driver has been specified explicitly.\n */\nstatic int bdrv_fill_options(QDict **options, const char *filename,\n                             int *flags, Error **errp)\n{\n    const char *drvname;\n    bool protocol = *flags & BDRV_O_PROTOCOL;\n    bool parse_filename = false;\n    BlockDriver *drv = NULL;\n    Error *local_err = NULL;\n\n    GLOBAL_STATE_CODE();\n\n    /*\n     * Caution: while qdict_get_try_str() is fine, getting non-string\n     * types would require more care.  When @options come from\n     * -blockdev or blockdev_add, its members are typed according to\n     * the QAPI schema, but when they come from -drive, they're all\n     * QString.\n     */\n    drvname = qdict_get_try_str(*options, \"driver\");\n    if (drvname) {\n        drv = bdrv_find_format(drvname);\n        if (!drv) {\n            error_setg(errp, \"Unknown driver '%s'\", drvname);\n            return -ENOENT;\n        }\n        /* If the user has explicitly specified the driver, this choice should\n         * override the BDRV_O_PROTOCOL flag */\n        protocol = drv->bdrv_file_open;\n    }\n\n    if (protocol) {\n        *flags |= BDRV_O_PROTOCOL;\n    } else {\n        *flags &= ~BDRV_O_PROTOCOL;\n    }\n\n    /* Translate cache options from flags into options */\n    update_options_from_flags(*options, *flags);\n\n    /* Fetch the file name from the options QDict if necessary */\n    if (protocol && filename) {\n        if (!qdict_haskey(*options, \"filename\")) {\n            qdict_put_str(*options, \"filename\", filename);\n            parse_filename = true;\n        } else {\n            error_setg(errp, \"Can't specify 'file' and 'filename' options at \"\n                             \"the same time\");\n            return -EINVAL;\n        }\n    }\n\n    /* Find the right block driver */\n    /* See cautionary note on accessing @options above */\n    filename = qdict_get_try_str(*options, \"filename\");\n\n    if (!drvname && protocol) {\n        if (filename) {\n            drv = bdrv_find_protocol(filename, parse_filename, errp);\n            if (!drv) {\n                return -EINVAL;\n            }\n\n            drvname = drv->format_name;\n            qdict_put_str(*options, \"driver\", drvname);\n        } else {\n            error_setg(errp, \"Must specify either driver or file\");\n            return -EINVAL;\n        }\n    }\n\n    assert(drv || !protocol);\n\n    /* Driver-specific filename parsing */\n    if (drv && drv->bdrv_parse_filename && parse_filename) {\n        drv->bdrv_parse_filename(filename, *options, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return -EINVAL;\n        }\n\n        if (!drv->bdrv_needs_filename) {\n            qdict_del(*options, \"filename\");\n        }\n    }\n\n    return 0;\n}\n\ntypedef struct BlockReopenQueueEntry {\n     bool prepared;\n     bool perms_checked;\n     BDRVReopenState state;\n     QTAILQ_ENTRY(BlockReopenQueueEntry) entry;\n} BlockReopenQueueEntry;\n\n/*\n * Return the flags that @bs will have after the reopens in @q have\n * successfully completed. If @q is NULL (or @bs is not contained in @q),\n * return the current flags.\n */\nstatic int bdrv_reopen_get_flags(BlockReopenQueue *q, BlockDriverState *bs)\n{\n    BlockReopenQueueEntry *entry;\n\n    if (q != NULL) {\n        QTAILQ_FOREACH(entry, q, entry) {\n            if (entry->state.bs == bs) {\n                return entry->state.flags;\n            }\n        }\n    }\n\n    return bs->open_flags;\n}\n\n/* Returns whether the image file can be written to after the reopen queue @q\n * has been successfully applied, or right now if @q is NULL. */\nstatic bool bdrv_is_writable_after_reopen(BlockDriverState *bs,\n                                          BlockReopenQueue *q)\n{\n    int flags = bdrv_reopen_get_flags(q, bs);\n\n    return (flags & (BDRV_O_RDWR | BDRV_O_INACTIVE)) == BDRV_O_RDWR;\n}\n\n/*\n * Return whether the BDS can be written to.  This is not necessarily\n * the same as !bdrv_is_read_only(bs), as inactivated images may not\n * be written to but do not count as read-only images.\n */\nbool bdrv_is_writable(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bdrv_is_writable_after_reopen(bs, NULL);\n}\n\nstatic char *bdrv_child_user_desc(BdrvChild *c)\n{\n    GLOBAL_STATE_CODE();\n    return c->klass->get_parent_desc(c);\n}\n\n/*\n * Check that @a allows everything that @b needs. @a and @b must reference same\n * child node.\n */\nstatic bool bdrv_a_allow_b(BdrvChild *a, BdrvChild *b, Error **errp)\n{\n    const char *child_bs_name;\n    g_autofree char *a_user = NULL;\n    g_autofree char *b_user = NULL;\n    g_autofree char *perms = NULL;\n\n    assert(a->bs);\n    assert(a->bs == b->bs);\n    GLOBAL_STATE_CODE();\n\n    if ((b->perm & a->shared_perm) == b->perm) {\n        return true;\n    }\n\n    child_bs_name = bdrv_get_node_name(b->bs);\n    a_user = bdrv_child_user_desc(a);\n    b_user = bdrv_child_user_desc(b);\n    perms = bdrv_perm_names(b->perm & ~a->shared_perm);\n\n    error_setg(errp, \"Permission conflict on node '%s': permissions '%s' are \"\n               \"both required by %s (uses node '%s' as '%s' child) and \"\n               \"unshared by %s (uses node '%s' as '%s' child).\",\n               child_bs_name, perms,\n               b_user, child_bs_name, b->name,\n               a_user, child_bs_name, a->name);\n\n    return false;\n}\n\nstatic bool bdrv_parent_perms_conflict(BlockDriverState *bs, Error **errp)\n{\n    BdrvChild *a, *b;\n    GLOBAL_STATE_CODE();\n\n    /*\n     * During the loop we'll look at each pair twice. That's correct because\n     * bdrv_a_allow_b() is asymmetric and we should check each pair in both\n     * directions.\n     */\n    QLIST_FOREACH(a, &bs->parents, next_parent) {\n        QLIST_FOREACH(b, &bs->parents, next_parent) {\n            if (a == b) {\n                continue;\n            }\n\n            if (!bdrv_a_allow_b(a, b, errp)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic void bdrv_child_perm(BlockDriverState *bs, BlockDriverState *child_bs,\n                            BdrvChild *c, BdrvChildRole role,\n                            BlockReopenQueue *reopen_queue,\n                            uint64_t parent_perm, uint64_t parent_shared,\n                            uint64_t *nperm, uint64_t *nshared)\n{\n    assert(bs->drv && bs->drv->bdrv_child_perm);\n    GLOBAL_STATE_CODE();\n    bs->drv->bdrv_child_perm(bs, c, role, reopen_queue,\n                             parent_perm, parent_shared,\n                             nperm, nshared);\n    /* TODO Take force_share from reopen_queue */\n    if (child_bs && child_bs->force_share) {\n        *nshared = BLK_PERM_ALL;\n    }\n}\n\n/*\n * Adds the whole subtree of @bs (including @bs itself) to the @list (except for\n * nodes that are already in the @list, of course) so that final list is\n * topologically sorted. Return the result (GSList @list object is updated, so\n * don't use old reference after function call).\n *\n * On function start @list must be already topologically sorted and for any node\n * in the @list the whole subtree of the node must be in the @list as well. The\n * simplest way to satisfy this criteria: use only result of\n * bdrv_topological_dfs() or NULL as @list parameter.\n */\nstatic GSList *bdrv_topological_dfs(GSList *list, GHashTable *found,\n                                    BlockDriverState *bs)\n{\n    BdrvChild *child;\n    g_autoptr(GHashTable) local_found = NULL;\n\n    GLOBAL_STATE_CODE();\n\n    if (!found) {\n        assert(!list);\n        found = local_found = g_hash_table_new(NULL, NULL);\n    }\n\n    if (g_hash_table_contains(found, bs)) {\n        return list;\n    }\n    g_hash_table_add(found, bs);\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        list = bdrv_topological_dfs(list, found, child->bs);\n    }\n\n    return g_slist_prepend(list, bs);\n}\n\ntypedef struct BdrvChildSetPermState {\n    BdrvChild *child;\n    uint64_t old_perm;\n    uint64_t old_shared_perm;\n} BdrvChildSetPermState;\n\nstatic void bdrv_child_set_perm_abort(void *opaque)\n{\n    BdrvChildSetPermState *s = opaque;\n\n    GLOBAL_STATE_CODE();\n\n    s->child->perm = s->old_perm;\n    s->child->shared_perm = s->old_shared_perm;\n}\n\nstatic TransactionActionDrv bdrv_child_set_pem_drv = {\n    .abort = bdrv_child_set_perm_abort,\n    .clean = g_free,\n};\n\nstatic void bdrv_child_set_perm(BdrvChild *c, uint64_t perm,\n                                uint64_t shared, Transaction *tran)\n{\n    BdrvChildSetPermState *s = g_new(BdrvChildSetPermState, 1);\n    GLOBAL_STATE_CODE();\n\n    *s = (BdrvChildSetPermState) {\n        .child = c,\n        .old_perm = c->perm,\n        .old_shared_perm = c->shared_perm,\n    };\n\n    c->perm = perm;\n    c->shared_perm = shared;\n\n    tran_add(tran, &bdrv_child_set_pem_drv, s);\n}\n\nstatic void bdrv_drv_set_perm_commit(void *opaque)\n{\n    BlockDriverState *bs = opaque;\n    uint64_t cumulative_perms, cumulative_shared_perms;\n    GLOBAL_STATE_CODE();\n\n    if (bs->drv->bdrv_set_perm) {\n        bdrv_get_cumulative_perm(bs, &cumulative_perms,\n                                 &cumulative_shared_perms);\n        bs->drv->bdrv_set_perm(bs, cumulative_perms, cumulative_shared_perms);\n    }\n}\n\nstatic void bdrv_drv_set_perm_abort(void *opaque)\n{\n    BlockDriverState *bs = opaque;\n    GLOBAL_STATE_CODE();\n\n    if (bs->drv->bdrv_abort_perm_update) {\n        bs->drv->bdrv_abort_perm_update(bs);\n    }\n}\n\nTransactionActionDrv bdrv_drv_set_perm_drv = {\n    .abort = bdrv_drv_set_perm_abort,\n    .commit = bdrv_drv_set_perm_commit,\n};\n\nstatic int bdrv_drv_set_perm(BlockDriverState *bs, uint64_t perm,\n                             uint64_t shared_perm, Transaction *tran,\n                             Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    if (!bs->drv) {\n        return 0;\n    }\n\n    if (bs->drv->bdrv_check_perm) {\n        int ret = bs->drv->bdrv_check_perm(bs, perm, shared_perm, errp);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    if (tran) {\n        tran_add(tran, &bdrv_drv_set_perm_drv, bs);\n    }\n\n    return 0;\n}\n\ntypedef struct BdrvReplaceChildState {\n    BdrvChild *child;\n    BdrvChild **childp;\n    BlockDriverState *old_bs;\n    bool free_empty_child;\n} BdrvReplaceChildState;\n\nstatic void bdrv_replace_child_commit(void *opaque)\n{\n    BdrvReplaceChildState *s = opaque;\n    GLOBAL_STATE_CODE();\n\n    if (s->free_empty_child && !s->child->bs) {\n        bdrv_child_free(s->child);\n    }\n    bdrv_unref(s->old_bs);\n}\n\nstatic void bdrv_replace_child_abort(void *opaque)\n{\n    BdrvReplaceChildState *s = opaque;\n    BlockDriverState *new_bs = s->child->bs;\n\n    GLOBAL_STATE_CODE();\n    /*\n     * old_bs reference is transparently moved from @s to s->child.\n     *\n     * Pass &s->child here instead of s->childp, because:\n     * (1) s->old_bs must be non-NULL, so bdrv_replace_child_noperm() will not\n     *     modify the BdrvChild * pointer we indirectly pass to it, i.e. it\n     *     will not modify s->child.  From that perspective, it does not matter\n     *     whether we pass s->childp or &s->child.\n     * (2) If new_bs is not NULL, s->childp will be NULL.  We then cannot use\n     *     it here.\n     * (3) If new_bs is NULL, *s->childp will have been NULLed by\n     *     bdrv_replace_child_tran()'s bdrv_replace_child_noperm() call, and we\n     *     must not pass a NULL *s->childp here.\n     *\n     * So whether new_bs was NULL or not, we cannot pass s->childp here; and in\n     * any case, there is no reason to pass it anyway.\n     */\n    bdrv_replace_child_noperm(&s->child, s->old_bs, true);\n    /*\n     * The child was pre-existing, so s->old_bs must be non-NULL, and\n     * s->child thus must not have been freed\n     */\n    assert(s->child != NULL);\n    if (!new_bs) {\n        /* As described above, *s->childp was cleared, so restore it */\n        assert(s->childp != NULL);\n        *s->childp = s->child;\n    }\n    bdrv_unref(new_bs);\n}\n\nstatic TransactionActionDrv bdrv_replace_child_drv = {\n    .commit = bdrv_replace_child_commit,\n    .abort = bdrv_replace_child_abort,\n    .clean = g_free,\n};\n\n/*\n * bdrv_replace_child_tran\n *\n * Note: real unref of old_bs is done only on commit.\n *\n * The function doesn't update permissions, caller is responsible for this.\n *\n * (*childp)->bs must not be NULL.\n *\n * Note that if new_bs == NULL, @childp is stored in a state object attached\n * to @tran, so that the old child can be reinstated in the abort handler.\n * Therefore, if @new_bs can be NULL, @childp must stay valid until the\n * transaction is committed or aborted.\n *\n * If @free_empty_child is true and @new_bs is NULL, the BdrvChild is\n * freed (on commit).  @free_empty_child should only be false if the\n * caller will free the BDrvChild themselves (which may be important\n * if this is in turn called in another transactional context).\n */\nstatic void bdrv_replace_child_tran(BdrvChild **childp,\n                                    BlockDriverState *new_bs,\n                                    Transaction *tran,\n                                    bool free_empty_child)\n{\n    BdrvReplaceChildState *s = g_new(BdrvReplaceChildState, 1);\n    *s = (BdrvReplaceChildState) {\n        .child = *childp,\n        .childp = new_bs == NULL ? childp : NULL,\n        .old_bs = (*childp)->bs,\n        .free_empty_child = free_empty_child,\n    };\n    tran_add(tran, &bdrv_replace_child_drv, s);\n\n    /* The abort handler relies on this */\n    assert(s->old_bs != NULL);\n\n    if (new_bs) {\n        bdrv_ref(new_bs);\n    }\n    /*\n     * Pass free_empty_child=false, we will free the child (if\n     * necessary) in bdrv_replace_child_commit() (if our\n     * @free_empty_child parameter was true).\n     */\n    bdrv_replace_child_noperm(childp, new_bs, false);\n    /* old_bs reference is transparently moved from *childp to @s */\n}\n\n/*\n * Refresh permissions in @bs subtree. The function is intended to be called\n * after some graph modification that was done without permission update.\n */\nstatic int bdrv_node_refresh_perm(BlockDriverState *bs, BlockReopenQueue *q,\n                                  Transaction *tran, Error **errp)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *c;\n    int ret;\n    uint64_t cumulative_perms, cumulative_shared_perms;\n    GLOBAL_STATE_CODE();\n\n    bdrv_get_cumulative_perm(bs, &cumulative_perms, &cumulative_shared_perms);\n\n    /* Write permissions never work with read-only images */\n    if ((cumulative_perms & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)) &&\n        !bdrv_is_writable_after_reopen(bs, q))\n    {\n        if (!bdrv_is_writable_after_reopen(bs, NULL)) {\n            error_setg(errp, \"Block node is read-only\");\n        } else {\n            error_setg(errp, \"Read-only block node '%s' cannot support \"\n                       \"read-write users\", bdrv_get_node_name(bs));\n        }\n\n        return -EPERM;\n    }\n\n    /*\n     * Unaligned requests will automatically be aligned to bl.request_alignment\n     * and without RESIZE we can't extend requests to write to space beyond the\n     * end of the image, so it's required that the image size is aligned.\n     */\n    if ((cumulative_perms & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)) &&\n        !(cumulative_perms & BLK_PERM_RESIZE))\n    {\n        if ((bs->total_sectors * BDRV_SECTOR_SIZE) % bs->bl.request_alignment) {\n            error_setg(errp, \"Cannot get 'write' permission without 'resize': \"\n                             \"Image size is not a multiple of request \"\n                             \"alignment\");\n            return -EPERM;\n        }\n    }\n\n    /* Check this node */\n    if (!drv) {\n        return 0;\n    }\n\n    ret = bdrv_drv_set_perm(bs, cumulative_perms, cumulative_shared_perms, tran,\n                            errp);\n    if (ret < 0) {\n        return ret;\n    }\n\n    /* Drivers that never have children can omit .bdrv_child_perm() */\n    if (!drv->bdrv_child_perm) {\n        assert(QLIST_EMPTY(&bs->children));\n        return 0;\n    }\n\n    /* Check all children */\n    QLIST_FOREACH(c, &bs->children, next) {\n        uint64_t cur_perm, cur_shared;\n\n        bdrv_child_perm(bs, c->bs, c, c->role, q,\n                        cumulative_perms, cumulative_shared_perms,\n                        &cur_perm, &cur_shared);\n        bdrv_child_set_perm(c, cur_perm, cur_shared, tran);\n    }\n\n    return 0;\n}\n\nstatic int bdrv_list_refresh_perms(GSList *list, BlockReopenQueue *q,\n                                   Transaction *tran, Error **errp)\n{\n    int ret;\n    BlockDriverState *bs;\n    GLOBAL_STATE_CODE();\n\n    for ( ; list; list = list->next) {\n        bs = list->data;\n\n        if (bdrv_parent_perms_conflict(bs, errp)) {\n            return -EINVAL;\n        }\n\n        ret = bdrv_node_refresh_perm(bs, q, tran, errp);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nvoid bdrv_get_cumulative_perm(BlockDriverState *bs, uint64_t *perm,\n                              uint64_t *shared_perm)\n{\n    BdrvChild *c;\n    uint64_t cumulative_perms = 0;\n    uint64_t cumulative_shared_perms = BLK_PERM_ALL;\n\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        cumulative_perms |= c->perm;\n        cumulative_shared_perms &= c->shared_perm;\n    }\n\n    *perm = cumulative_perms;\n    *shared_perm = cumulative_shared_perms;\n}\n\nchar *bdrv_perm_names(uint64_t perm)\n{\n    struct perm_name {\n        uint64_t perm;\n        const char *name;\n    } permissions[] = {\n        { BLK_PERM_CONSISTENT_READ, \"consistent read\" },\n        { BLK_PERM_WRITE,           \"write\" },\n        { BLK_PERM_WRITE_UNCHANGED, \"write unchanged\" },\n        { BLK_PERM_RESIZE,          \"resize\" },\n        { 0, NULL }\n    };\n\n    GString *result = g_string_sized_new(30);\n    struct perm_name *p;\n\n    for (p = permissions; p->name; p++) {\n        if (perm & p->perm) {\n            if (result->len > 0) {\n                g_string_append(result, \", \");\n            }\n            g_string_append(result, p->name);\n        }\n    }\n\n    return g_string_free(result, FALSE);\n}\n\n\nstatic int bdrv_refresh_perms(BlockDriverState *bs, Error **errp)\n{\n    int ret;\n    Transaction *tran = tran_new();\n    g_autoptr(GSList) list = bdrv_topological_dfs(NULL, NULL, bs);\n    GLOBAL_STATE_CODE();\n\n    ret = bdrv_list_refresh_perms(list, NULL, tran, errp);\n    tran_finalize(tran, ret);\n\n    return ret;\n}\n\nint bdrv_child_try_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared,\n                            Error **errp)\n{\n    Error *local_err = NULL;\n    Transaction *tran = tran_new();\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    bdrv_child_set_perm(c, perm, shared, tran);\n\n    ret = bdrv_refresh_perms(c->bs, &local_err);\n\n    tran_finalize(tran, ret);\n\n    if (ret < 0) {\n        if ((perm & ~c->perm) || (c->shared_perm & ~shared)) {\n            /* tighten permissions */\n            error_propagate(errp, local_err);\n        } else {\n            /*\n             * Our caller may intend to only loosen restrictions and\n             * does not expect this function to fail.  Errors are not\n             * fatal in such a case, so we can just hide them from our\n             * caller.\n             */\n            error_free(local_err);\n            ret = 0;\n        }\n    }\n\n    return ret;\n}\n\nint bdrv_child_refresh_perms(BlockDriverState *bs, BdrvChild *c, Error **errp)\n{\n    uint64_t parent_perms, parent_shared;\n    uint64_t perms, shared;\n\n    GLOBAL_STATE_CODE();\n\n    bdrv_get_cumulative_perm(bs, &parent_perms, &parent_shared);\n    bdrv_child_perm(bs, c->bs, c, c->role, NULL,\n                    parent_perms, parent_shared, &perms, &shared);\n\n    return bdrv_child_try_set_perm(c, perms, shared, errp);\n}\n\n/*\n * Default implementation for .bdrv_child_perm() for block filters:\n * Forward CONSISTENT_READ, WRITE, WRITE_UNCHANGED, and RESIZE to the\n * filtered child.\n */\nstatic void bdrv_filter_default_perms(BlockDriverState *bs, BdrvChild *c,\n                                      BdrvChildRole role,\n                                      BlockReopenQueue *reopen_queue,\n                                      uint64_t perm, uint64_t shared,\n                                      uint64_t *nperm, uint64_t *nshared)\n{\n    GLOBAL_STATE_CODE();\n    *nperm = perm & DEFAULT_PERM_PASSTHROUGH;\n    *nshared = (shared & DEFAULT_PERM_PASSTHROUGH) | DEFAULT_PERM_UNCHANGED;\n}\n\nstatic void bdrv_default_perms_for_cow(BlockDriverState *bs, BdrvChild *c,\n                                       BdrvChildRole role,\n                                       BlockReopenQueue *reopen_queue,\n                                       uint64_t perm, uint64_t shared,\n                                       uint64_t *nperm, uint64_t *nshared)\n{\n    assert(role & BDRV_CHILD_COW);\n    GLOBAL_STATE_CODE();\n\n    /*\n     * We want consistent read from backing files if the parent needs it.\n     * No other operations are performed on backing files.\n     */\n    perm &= BLK_PERM_CONSISTENT_READ;\n\n    /*\n     * If the parent can deal with changing data, we're okay with a\n     * writable and resizable backing file.\n     * TODO Require !(perm & BLK_PERM_CONSISTENT_READ), too?\n     */\n    if (shared & BLK_PERM_WRITE) {\n        shared = BLK_PERM_WRITE | BLK_PERM_RESIZE;\n    } else {\n        shared = 0;\n    }\n\n    shared |= BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE_UNCHANGED;\n\n    if (bs->open_flags & BDRV_O_INACTIVE) {\n        shared |= BLK_PERM_WRITE | BLK_PERM_RESIZE;\n    }\n\n    *nperm = perm;\n    *nshared = shared;\n}\n\nstatic void bdrv_default_perms_for_storage(BlockDriverState *bs, BdrvChild *c,\n                                           BdrvChildRole role,\n                                           BlockReopenQueue *reopen_queue,\n                                           uint64_t perm, uint64_t shared,\n                                           uint64_t *nperm, uint64_t *nshared)\n{\n    int flags;\n\n    GLOBAL_STATE_CODE();\n    assert(role & (BDRV_CHILD_METADATA | BDRV_CHILD_DATA));\n\n    flags = bdrv_reopen_get_flags(reopen_queue, bs);\n\n    /*\n     * Apart from the modifications below, the same permissions are\n     * forwarded and left alone as for filters\n     */\n    bdrv_filter_default_perms(bs, c, role, reopen_queue,\n                              perm, shared, &perm, &shared);\n\n    if (role & BDRV_CHILD_METADATA) {\n        /* Format drivers may touch metadata even if the guest doesn't write */\n        if (bdrv_is_writable_after_reopen(bs, reopen_queue)) {\n            perm |= BLK_PERM_WRITE | BLK_PERM_RESIZE;\n        }\n\n        /*\n         * bs->file always needs to be consistent because of the\n         * metadata. We can never allow other users to resize or write\n         * to it.\n         */\n        if (!(flags & BDRV_O_NO_IO)) {\n            perm |= BLK_PERM_CONSISTENT_READ;\n        }\n        shared &= ~(BLK_PERM_WRITE | BLK_PERM_RESIZE);\n    }\n\n    if (role & BDRV_CHILD_DATA) {\n        /*\n         * Technically, everything in this block is a subset of the\n         * BDRV_CHILD_METADATA path taken above, and so this could\n         * be an \"else if\" branch.  However, that is not obvious, and\n         * this function is not performance critical, therefore we let\n         * this be an independent \"if\".\n         */\n\n        /*\n         * We cannot allow other users to resize the file because the\n         * format driver might have some assumptions about the size\n         * (e.g. because it is stored in metadata, or because the file\n         * is split into fixed-size data files).\n         */\n        shared &= ~BLK_PERM_RESIZE;\n\n        /*\n         * WRITE_UNCHANGED often cannot be performed as such on the\n         * data file.  For example, the qcow2 driver may still need to\n         * write copied clusters on copy-on-read.\n         */\n        if (perm & BLK_PERM_WRITE_UNCHANGED) {\n            perm |= BLK_PERM_WRITE;\n        }\n\n        /*\n         * If the data file is written to, the format driver may\n         * expect to be able to resize it by writing beyond the EOF.\n         */\n        if (perm & BLK_PERM_WRITE) {\n            perm |= BLK_PERM_RESIZE;\n        }\n    }\n\n    if (bs->open_flags & BDRV_O_INACTIVE) {\n        shared |= BLK_PERM_WRITE | BLK_PERM_RESIZE;\n    }\n\n    *nperm = perm;\n    *nshared = shared;\n}\n\nvoid bdrv_default_perms(BlockDriverState *bs, BdrvChild *c,\n                        BdrvChildRole role, BlockReopenQueue *reopen_queue,\n                        uint64_t perm, uint64_t shared,\n                        uint64_t *nperm, uint64_t *nshared)\n{\n    GLOBAL_STATE_CODE();\n    if (role & BDRV_CHILD_FILTERED) {\n        assert(!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA |\n                         BDRV_CHILD_COW)));\n        bdrv_filter_default_perms(bs, c, role, reopen_queue,\n                                  perm, shared, nperm, nshared);\n    } else if (role & BDRV_CHILD_COW) {\n        assert(!(role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA)));\n        bdrv_default_perms_for_cow(bs, c, role, reopen_queue,\n                                   perm, shared, nperm, nshared);\n    } else if (role & (BDRV_CHILD_METADATA | BDRV_CHILD_DATA)) {\n        bdrv_default_perms_for_storage(bs, c, role, reopen_queue,\n                                       perm, shared, nperm, nshared);\n    } else {\n        g_assert_not_reached();\n    }\n}\n\nuint64_t bdrv_qapi_perm_to_blk_perm(BlockPermission qapi_perm)\n{\n    static const uint64_t permissions[] = {\n        [BLOCK_PERMISSION_CONSISTENT_READ]  = BLK_PERM_CONSISTENT_READ,\n        [BLOCK_PERMISSION_WRITE]            = BLK_PERM_WRITE,\n        [BLOCK_PERMISSION_WRITE_UNCHANGED]  = BLK_PERM_WRITE_UNCHANGED,\n        [BLOCK_PERMISSION_RESIZE]           = BLK_PERM_RESIZE,\n    };\n\n    QEMU_BUILD_BUG_ON(ARRAY_SIZE(permissions) != BLOCK_PERMISSION__MAX);\n    QEMU_BUILD_BUG_ON(1UL << ARRAY_SIZE(permissions) != BLK_PERM_ALL + 1);\n\n    assert(qapi_perm < BLOCK_PERMISSION__MAX);\n\n    return permissions[qapi_perm];\n}\n\n/**\n * Replace (*childp)->bs by @new_bs.\n *\n * If @new_bs is NULL, *childp will be set to NULL, too: BDS parents\n * generally cannot handle a BdrvChild with .bs == NULL, so clearing\n * BdrvChild.bs should generally immediately be followed by the\n * BdrvChild pointer being cleared as well.\n *\n * If @free_empty_child is true and @new_bs is NULL, the BdrvChild is\n * freed.  @free_empty_child should only be false if the caller will\n * free the BdrvChild themselves (this may be important in a\n * transactional context, where it may only be freed on commit).\n */\nstatic void bdrv_replace_child_noperm(BdrvChild **childp,\n                                      BlockDriverState *new_bs,\n                                      bool free_empty_child)\n{\n    BdrvChild *child = *childp;\n    BlockDriverState *old_bs = child->bs;\n    int new_bs_quiesce_counter;\n    int drain_saldo;\n\n    assert(!child->frozen);\n    assert(old_bs != new_bs);\n    GLOBAL_STATE_CODE();\n\n    if (old_bs && new_bs) {\n        assert(bdrv_get_aio_context(old_bs) == bdrv_get_aio_context(new_bs));\n    }\n\n    new_bs_quiesce_counter = (new_bs ? new_bs->quiesce_counter : 0);\n    drain_saldo = new_bs_quiesce_counter - child->parent_quiesce_counter;\n\n    /*\n     * If the new child node is drained but the old one was not, flush\n     * all outstanding requests to the old child node.\n     */\n    while (drain_saldo > 0 && child->klass->drained_begin) {\n        bdrv_parent_drained_begin_single(child, true);\n        drain_saldo--;\n    }\n\n    if (old_bs) {\n        /* Detach first so that the recursive drain sections coming from @child\n         * are already gone and we only end the drain sections that came from\n         * elsewhere. */\n        if (child->klass->detach) {\n            child->klass->detach(child);\n        }\n        assert_bdrv_graph_writable(old_bs);\n        QLIST_REMOVE(child, next_parent);\n    }\n\n    child->bs = new_bs;\n    if (!new_bs) {\n        *childp = NULL;\n    }\n\n    if (new_bs) {\n        assert_bdrv_graph_writable(new_bs);\n        QLIST_INSERT_HEAD(&new_bs->parents, child, next_parent);\n\n        /*\n         * Detaching the old node may have led to the new node's\n         * quiesce_counter having been decreased.  Not a problem, we\n         * just need to recognize this here and then invoke\n         * drained_end appropriately more often.\n         */\n        assert(new_bs->quiesce_counter <= new_bs_quiesce_counter);\n        drain_saldo += new_bs->quiesce_counter - new_bs_quiesce_counter;\n\n        /* Attach only after starting new drained sections, so that recursive\n         * drain sections coming from @child don't get an extra .drained_begin\n         * callback. */\n        if (child->klass->attach) {\n            child->klass->attach(child);\n        }\n    }\n\n    /*\n     * If the old child node was drained but the new one is not, allow\n     * requests to come in only after the new node has been attached.\n     */\n    while (drain_saldo < 0 && child->klass->drained_end) {\n        bdrv_parent_drained_end_single(child);\n        drain_saldo++;\n    }\n\n    if (free_empty_child && !child->bs) {\n        bdrv_child_free(child);\n    }\n}\n\n/**\n * Free the given @child.\n *\n * The child must be empty (i.e. `child->bs == NULL`) and it must be\n * unused (i.e. not in a children list).\n */\nstatic void bdrv_child_free(BdrvChild *child)\n{\n    assert(!child->bs);\n    GLOBAL_STATE_CODE();\n    assert(!child->next.le_prev); /* not in children list */\n\n    g_free(child->name);\n    g_free(child);\n}\n\ntypedef struct BdrvAttachChildCommonState {\n    BdrvChild **child;\n    AioContext *old_parent_ctx;\n    AioContext *old_child_ctx;\n} BdrvAttachChildCommonState;\n\nstatic void bdrv_attach_child_common_abort(void *opaque)\n{\n    BdrvAttachChildCommonState *s = opaque;\n    BdrvChild *child = *s->child;\n    BlockDriverState *bs = child->bs;\n\n    GLOBAL_STATE_CODE();\n    /*\n     * Pass free_empty_child=false, because we still need the child\n     * for the AioContext operations on the parent below; those\n     * BdrvChildClass methods all work on a BdrvChild object, so we\n     * need to keep it as an empty shell (after this function, it will\n     * not be attached to any parent, and it will not have a .bs).\n     */\n    bdrv_replace_child_noperm(s->child, NULL, false);\n\n    if (bdrv_get_aio_context(bs) != s->old_child_ctx) {\n        bdrv_try_set_aio_context(bs, s->old_child_ctx, &error_abort);\n    }\n\n    if (bdrv_child_get_parent_aio_context(child) != s->old_parent_ctx) {\n        GSList *ignore;\n\n        /* No need to ignore `child`, because it has been detached already */\n        ignore = NULL;\n        child->klass->can_set_aio_ctx(child, s->old_parent_ctx, &ignore,\n                                      &error_abort);\n        g_slist_free(ignore);\n\n        ignore = NULL;\n        child->klass->set_aio_ctx(child, s->old_parent_ctx, &ignore);\n        g_slist_free(ignore);\n    }\n\n    bdrv_unref(bs);\n    bdrv_child_free(child);\n}\n\nstatic TransactionActionDrv bdrv_attach_child_common_drv = {\n    .abort = bdrv_attach_child_common_abort,\n    .clean = g_free,\n};\n\n/*\n * Common part of attaching bdrv child to bs or to blk or to job\n *\n * Resulting new child is returned through @child.\n * At start *@child must be NULL.\n * @child is saved to a new entry of @tran, so that *@child could be reverted to\n * NULL on abort(). So referenced variable must live at least until transaction\n * end.\n *\n * Function doesn't update permissions, caller is responsible for this.\n */\nstatic int bdrv_attach_child_common(BlockDriverState *child_bs,\n                                    const char *child_name,\n                                    const BdrvChildClass *child_class,\n                                    BdrvChildRole child_role,\n                                    uint64_t perm, uint64_t shared_perm,\n                                    void *opaque, BdrvChild **child,\n                                    Transaction *tran, Error **errp)\n{\n    BdrvChild *new_child;\n    AioContext *parent_ctx;\n    AioContext *child_ctx = bdrv_get_aio_context(child_bs);\n\n    assert(child);\n    assert(*child == NULL);\n    assert(child_class->get_parent_desc);\n    GLOBAL_STATE_CODE();\n\n    new_child = g_new(BdrvChild, 1);\n    *new_child = (BdrvChild) {\n        .bs             = NULL,\n        .name           = g_strdup(child_name),\n        .klass          = child_class,\n        .role           = child_role,\n        .perm           = perm,\n        .shared_perm    = shared_perm,\n        .opaque         = opaque,\n    };\n\n    /*\n     * If the AioContexts don't match, first try to move the subtree of\n     * child_bs into the AioContext of the new parent. If this doesn't work,\n     * try moving the parent into the AioContext of child_bs instead.\n     */\n    parent_ctx = bdrv_child_get_parent_aio_context(new_child);\n    if (child_ctx != parent_ctx) {\n        Error *local_err = NULL;\n        int ret = bdrv_try_set_aio_context(child_bs, parent_ctx, &local_err);\n\n        if (ret < 0 && child_class->can_set_aio_ctx) {\n            GSList *ignore = g_slist_prepend(NULL, new_child);\n            if (child_class->can_set_aio_ctx(new_child, child_ctx, &ignore,\n                                             NULL))\n            {\n                error_free(local_err);\n                ret = 0;\n                g_slist_free(ignore);\n                ignore = g_slist_prepend(NULL, new_child);\n                child_class->set_aio_ctx(new_child, child_ctx, &ignore);\n            }\n            g_slist_free(ignore);\n        }\n\n        if (ret < 0) {\n            error_propagate(errp, local_err);\n            bdrv_child_free(new_child);\n            return ret;\n        }\n    }\n\n    bdrv_ref(child_bs);\n    bdrv_replace_child_noperm(&new_child, child_bs, true);\n    /* child_bs was non-NULL, so new_child must not have been freed */\n    assert(new_child != NULL);\n\n    *child = new_child;\n\n    BdrvAttachChildCommonState *s = g_new(BdrvAttachChildCommonState, 1);\n    *s = (BdrvAttachChildCommonState) {\n        .child = child,\n        .old_parent_ctx = parent_ctx,\n        .old_child_ctx = child_ctx,\n    };\n    tran_add(tran, &bdrv_attach_child_common_drv, s);\n\n    return 0;\n}\n\n/*\n * Variable referenced by @child must live at least until transaction end.\n * (see bdrv_attach_child_common() doc for details)\n *\n * Function doesn't update permissions, caller is responsible for this.\n */\nstatic int bdrv_attach_child_noperm(BlockDriverState *parent_bs,\n                                    BlockDriverState *child_bs,\n                                    const char *child_name,\n                                    const BdrvChildClass *child_class,\n                                    BdrvChildRole child_role,\n                                    BdrvChild **child,\n                                    Transaction *tran,\n                                    Error **errp)\n{\n    int ret;\n    uint64_t perm, shared_perm;\n\n    assert(parent_bs->drv);\n    GLOBAL_STATE_CODE();\n\n    if (bdrv_recurse_has_child(child_bs, parent_bs)) {\n        error_setg(errp, \"Making '%s' a %s child of '%s' would create a cycle\",\n                   child_bs->node_name, child_name, parent_bs->node_name);\n        return -EINVAL;\n    }\n\n    bdrv_get_cumulative_perm(parent_bs, &perm, &shared_perm);\n    bdrv_child_perm(parent_bs, child_bs, NULL, child_role, NULL,\n                    perm, shared_perm, &perm, &shared_perm);\n\n    ret = bdrv_attach_child_common(child_bs, child_name, child_class,\n                                   child_role, perm, shared_perm, parent_bs,\n                                   child, tran, errp);\n    if (ret < 0) {\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic void bdrv_detach_child(BdrvChild **childp)\n{\n    BlockDriverState *old_bs = (*childp)->bs;\n\n    GLOBAL_STATE_CODE();\n    bdrv_replace_child_noperm(childp, NULL, true);\n\n    if (old_bs) {\n        /*\n         * Update permissions for old node. We're just taking a parent away, so\n         * we're loosening restrictions. Errors of permission update are not\n         * fatal in this case, ignore them.\n         */\n        bdrv_refresh_perms(old_bs, NULL);\n\n        /*\n         * When the parent requiring a non-default AioContext is removed, the\n         * node moves back to the main AioContext\n         */\n        bdrv_try_set_aio_context(old_bs, qemu_get_aio_context(), NULL);\n    }\n}\n\n/*\n * This function steals the reference to child_bs from the caller.\n * That reference is later dropped by bdrv_root_unref_child().\n *\n * On failure NULL is returned, errp is set and the reference to\n * child_bs is also dropped.\n *\n * The caller must hold the AioContext lock @child_bs, but not that of @ctx\n * (unless @child_bs is already in @ctx).\n */\nBdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,\n                                  const char *child_name,\n                                  const BdrvChildClass *child_class,\n                                  BdrvChildRole child_role,\n                                  uint64_t perm, uint64_t shared_perm,\n                                  void *opaque, Error **errp)\n{\n    int ret;\n    BdrvChild *child = NULL;\n    Transaction *tran = tran_new();\n\n    GLOBAL_STATE_CODE();\n\n    ret = bdrv_attach_child_common(child_bs, child_name, child_class,\n                                   child_role, perm, shared_perm, opaque,\n                                   &child, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = bdrv_refresh_perms(child_bs, errp);\n\nout:\n    tran_finalize(tran, ret);\n    /* child is unset on failure by bdrv_attach_child_common_abort() */\n    assert((ret < 0) == !child);\n\n    bdrv_unref(child_bs);\n    return child;\n}\n\n/*\n * This function transfers the reference to child_bs from the caller\n * to parent_bs. That reference is later dropped by parent_bs on\n * bdrv_close() or if someone calls bdrv_unref_child().\n *\n * On failure NULL is returned, errp is set and the reference to\n * child_bs is also dropped.\n *\n * If @parent_bs and @child_bs are in different AioContexts, the caller must\n * hold the AioContext lock for @child_bs, but not for @parent_bs.\n */\nBdrvChild *bdrv_attach_child(BlockDriverState *parent_bs,\n                             BlockDriverState *child_bs,\n                             const char *child_name,\n                             const BdrvChildClass *child_class,\n                             BdrvChildRole child_role,\n                             Error **errp)\n{\n    int ret;\n    BdrvChild *child = NULL;\n    Transaction *tran = tran_new();\n\n    GLOBAL_STATE_CODE();\n\n    ret = bdrv_attach_child_noperm(parent_bs, child_bs, child_name, child_class,\n                                   child_role, &child, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = bdrv_refresh_perms(parent_bs, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\nout:\n    tran_finalize(tran, ret);\n    /* child is unset on failure by bdrv_attach_child_common_abort() */\n    assert((ret < 0) == !child);\n\n    bdrv_unref(child_bs);\n\n    return child;\n}\n\n/* Callers must ensure that child->frozen is false. */\nvoid bdrv_root_unref_child(BdrvChild *child)\n{\n    BlockDriverState *child_bs;\n\n    GLOBAL_STATE_CODE();\n\n    child_bs = child->bs;\n    bdrv_detach_child(&child);\n    bdrv_unref(child_bs);\n}\n\ntypedef struct BdrvSetInheritsFrom {\n    BlockDriverState *bs;\n    BlockDriverState *old_inherits_from;\n} BdrvSetInheritsFrom;\n\nstatic void bdrv_set_inherits_from_abort(void *opaque)\n{\n    BdrvSetInheritsFrom *s = opaque;\n\n    s->bs->inherits_from = s->old_inherits_from;\n}\n\nstatic TransactionActionDrv bdrv_set_inherits_from_drv = {\n    .abort = bdrv_set_inherits_from_abort,\n    .clean = g_free,\n};\n\n/* @tran is allowed to be NULL. In this case no rollback is possible */\nstatic void bdrv_set_inherits_from(BlockDriverState *bs,\n                                   BlockDriverState *new_inherits_from,\n                                   Transaction *tran)\n{\n    if (tran) {\n        BdrvSetInheritsFrom *s = g_new(BdrvSetInheritsFrom, 1);\n\n        *s = (BdrvSetInheritsFrom) {\n            .bs = bs,\n            .old_inherits_from = bs->inherits_from,\n        };\n\n        tran_add(tran, &bdrv_set_inherits_from_drv, s);\n    }\n\n    bs->inherits_from = new_inherits_from;\n}\n\n/**\n * Clear all inherits_from pointers from children and grandchildren of\n * @root that point to @root, where necessary.\n * @tran is allowed to be NULL. In this case no rollback is possible\n */\nstatic void bdrv_unset_inherits_from(BlockDriverState *root, BdrvChild *child,\n                                     Transaction *tran)\n{\n    BdrvChild *c;\n\n    if (child->bs->inherits_from == root) {\n        /*\n         * Remove inherits_from only when the last reference between root and\n         * child->bs goes away.\n         */\n        QLIST_FOREACH(c, &root->children, next) {\n            if (c != child && c->bs == child->bs) {\n                break;\n            }\n        }\n        if (c == NULL) {\n            bdrv_set_inherits_from(child->bs, NULL, tran);\n        }\n    }\n\n    QLIST_FOREACH(c, &child->bs->children, next) {\n        bdrv_unset_inherits_from(root, c, tran);\n    }\n}\n\n/* Callers must ensure that child->frozen is false. */\nvoid bdrv_unref_child(BlockDriverState *parent, BdrvChild *child)\n{\n    GLOBAL_STATE_CODE();\n    if (child == NULL) {\n        return;\n    }\n\n    bdrv_unset_inherits_from(parent, child, NULL);\n    bdrv_root_unref_child(child);\n}\n\n\nstatic void bdrv_parent_cb_change_media(BlockDriverState *bs, bool load)\n{\n    BdrvChild *c;\n    GLOBAL_STATE_CODE();\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (c->klass->change_media) {\n            c->klass->change_media(c, load);\n        }\n    }\n}\n\n/* Return true if you can reach parent going through child->inherits_from\n * recursively. If parent or child are NULL, return false */\nstatic bool bdrv_inherits_from_recursive(BlockDriverState *child,\n                                         BlockDriverState *parent)\n{\n    while (child && child != parent) {\n        child = child->inherits_from;\n    }\n\n    return child != NULL;\n}\n\n/*\n * Return the BdrvChildRole for @bs's backing child.  bs->backing is\n * mostly used for COW backing children (role = COW), but also for\n * filtered children (role = FILTERED | PRIMARY).\n */\nstatic BdrvChildRole bdrv_backing_role(BlockDriverState *bs)\n{\n    if (bs->drv && bs->drv->is_filter) {\n        return BDRV_CHILD_FILTERED | BDRV_CHILD_PRIMARY;\n    } else {\n        return BDRV_CHILD_COW;\n    }\n}\n\n/*\n * Sets the bs->backing or bs->file link of a BDS. A new reference is created;\n * callers which don't need their own reference any more must call bdrv_unref().\n *\n * Function doesn't update permissions, caller is responsible for this.\n */\nstatic int bdrv_set_file_or_backing_noperm(BlockDriverState *parent_bs,\n                                           BlockDriverState *child_bs,\n                                           bool is_backing,\n                                           Transaction *tran, Error **errp)\n{\n    int ret = 0;\n    bool update_inherits_from =\n        bdrv_inherits_from_recursive(child_bs, parent_bs);\n    BdrvChild *child = is_backing ? parent_bs->backing : parent_bs->file;\n    BdrvChildRole role;\n\n    GLOBAL_STATE_CODE();\n\n    if (!parent_bs->drv) {\n        /*\n         * Node without drv is an object without a class :/. TODO: finally fix\n         * qcow2 driver to never clear bs->drv and implement format corruption\n         * handling in other way.\n         */\n        error_setg(errp, \"Node corrupted\");\n        return -EINVAL;\n    }\n\n    if (child && child->frozen) {\n        error_setg(errp, \"Cannot change frozen '%s' link from '%s' to '%s'\",\n                   child->name, parent_bs->node_name, child->bs->node_name);\n        return -EPERM;\n    }\n\n    if (is_backing && !parent_bs->drv->is_filter &&\n        !parent_bs->drv->supports_backing)\n    {\n        error_setg(errp, \"Driver '%s' of node '%s' does not support backing \"\n                   \"files\", parent_bs->drv->format_name, parent_bs->node_name);\n        return -EINVAL;\n    }\n\n    if (parent_bs->drv->is_filter) {\n        role = BDRV_CHILD_FILTERED | BDRV_CHILD_PRIMARY;\n    } else if (is_backing) {\n        role = BDRV_CHILD_COW;\n    } else {\n        /*\n         * We only can use same role as it is in existing child. We don't have\n         * infrastructure to determine role of file child in generic way\n         */\n        if (!child) {\n            error_setg(errp, \"Cannot set file child to format node without \"\n                       \"file child\");\n            return -EINVAL;\n        }\n        role = child->role;\n    }\n\n    if (child) {\n        bdrv_unset_inherits_from(parent_bs, child, tran);\n        bdrv_remove_file_or_backing_child(parent_bs, child, tran);\n    }\n\n    if (!child_bs) {\n        goto out;\n    }\n\n    ret = bdrv_attach_child_noperm(parent_bs, child_bs,\n                                   is_backing ? \"backing\" : \"file\",\n                                   &child_of_bds, role,\n                                   is_backing ? &parent_bs->backing :\n                                                &parent_bs->file,\n                                   tran, errp);\n    if (ret < 0) {\n        return ret;\n    }\n\n\n    /*\n     * If inherits_from pointed recursively to bs then let's update it to\n     * point directly to bs (else it will become NULL).\n     */\n    if (update_inherits_from) {\n        bdrv_set_inherits_from(child_bs, parent_bs, tran);\n    }\n\nout:\n    bdrv_refresh_limits(parent_bs, tran, NULL);\n\n    return 0;\n}\n\nstatic int bdrv_set_backing_noperm(BlockDriverState *bs,\n                                   BlockDriverState *backing_hd,\n                                   Transaction *tran, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    return bdrv_set_file_or_backing_noperm(bs, backing_hd, true, tran, errp);\n}\n\nint bdrv_set_backing_hd(BlockDriverState *bs, BlockDriverState *backing_hd,\n                        Error **errp)\n{\n    int ret;\n    Transaction *tran = tran_new();\n\n    GLOBAL_STATE_CODE();\n    bdrv_drained_begin(bs);\n\n    ret = bdrv_set_backing_noperm(bs, backing_hd, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = bdrv_refresh_perms(bs, errp);\nout:\n    tran_finalize(tran, ret);\n\n    bdrv_drained_end(bs);\n\n    return ret;\n}\n\n/*\n * Opens the backing file for a BlockDriverState if not yet open\n *\n * bdref_key specifies the key for the image's BlockdevRef in the options QDict.\n * That QDict has to be flattened; therefore, if the BlockdevRef is a QDict\n * itself, all options starting with \"${bdref_key}.\" are considered part of the\n * BlockdevRef.\n *\n * TODO Can this be unified with bdrv_open_image()?\n */\nint bdrv_open_backing_file(BlockDriverState *bs, QDict *parent_options,\n                           const char *bdref_key, Error **errp)\n{\n    char *backing_filename = NULL;\n    char *bdref_key_dot;\n    const char *reference = NULL;\n    int ret = 0;\n    bool implicit_backing = false;\n    BlockDriverState *backing_hd;\n    QDict *options;\n    QDict *tmp_parent_options = NULL;\n    Error *local_err = NULL;\n\n    GLOBAL_STATE_CODE();\n\n    if (bs->backing != NULL) {\n        goto free_exit;\n    }\n\n    /* NULL means an empty set of options */\n    if (parent_options == NULL) {\n        tmp_parent_options = qdict_new();\n        parent_options = tmp_parent_options;\n    }\n\n    bs->open_flags &= ~BDRV_O_NO_BACKING;\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n    qdict_extract_subqdict(parent_options, &options, bdref_key_dot);\n    g_free(bdref_key_dot);\n\n    /*\n     * Caution: while qdict_get_try_str() is fine, getting non-string\n     * types would require more care.  When @parent_options come from\n     * -blockdev or blockdev_add, its members are typed according to\n     * the QAPI schema, but when they come from -drive, they're all\n     * QString.\n     */\n    reference = qdict_get_try_str(parent_options, bdref_key);\n    if (reference || qdict_haskey(options, \"file.filename\")) {\n        /* keep backing_filename NULL */\n    } else if (bs->backing_file[0] == '\\0' && qdict_size(options) == 0) {\n        qobject_unref(options);\n        goto free_exit;\n    } else {\n        if (qdict_size(options) == 0) {\n            /* If the user specifies options that do not modify the\n             * backing file's behavior, we might still consider it the\n             * implicit backing file.  But it's easier this way, and\n             * just specifying some of the backing BDS's options is\n             * only possible with -drive anyway (otherwise the QAPI\n             * schema forces the user to specify everything). */\n            implicit_backing = !strcmp(bs->auto_backing_file, bs->backing_file);\n        }\n\n        backing_filename = bdrv_get_full_backing_filename(bs, &local_err);\n        if (local_err) {\n            ret = -EINVAL;\n            error_propagate(errp, local_err);\n            qobject_unref(options);\n            goto free_exit;\n        }\n    }\n\n    if (!bs->drv || !bs->drv->supports_backing) {\n        ret = -EINVAL;\n        error_setg(errp, \"Driver doesn't support backing files\");\n        qobject_unref(options);\n        goto free_exit;\n    }\n\n    if (!reference &&\n        bs->backing_format[0] != '\\0' && !qdict_haskey(options, \"driver\")) {\n        qdict_put_str(options, \"driver\", bs->backing_format);\n    }\n\n    backing_hd = bdrv_open_inherit(backing_filename, reference, options, 0, bs,\n                                   &child_of_bds, bdrv_backing_role(bs), errp);\n    if (!backing_hd) {\n        bs->open_flags |= BDRV_O_NO_BACKING;\n        error_prepend(errp, \"Could not open backing file: \");\n        ret = -EINVAL;\n        goto free_exit;\n    }\n\n    if (implicit_backing) {\n        bdrv_refresh_filename(backing_hd);\n        pstrcpy(bs->auto_backing_file, sizeof(bs->auto_backing_file),\n                backing_hd->filename);\n    }\n\n    /* Hook up the backing file link; drop our reference, bs owns the\n     * backing_hd reference now */\n    ret = bdrv_set_backing_hd(bs, backing_hd, errp);\n    bdrv_unref(backing_hd);\n    if (ret < 0) {\n        goto free_exit;\n    }\n\n    qdict_del(parent_options, bdref_key);\n\nfree_exit:\n    g_free(backing_filename);\n    qobject_unref(tmp_parent_options);\n    return ret;\n}\n\nstatic BlockDriverState *\nbdrv_open_child_bs(const char *filename, QDict *options, const char *bdref_key,\n                   BlockDriverState *parent, const BdrvChildClass *child_class,\n                   BdrvChildRole child_role, bool allow_none, Error **errp)\n{\n    BlockDriverState *bs = NULL;\n    QDict *image_options;\n    char *bdref_key_dot;\n    const char *reference;\n\n    assert(child_class != NULL);\n\n    bdref_key_dot = g_strdup_printf(\"%s.\", bdref_key);\n    qdict_extract_subqdict(options, &image_options, bdref_key_dot);\n    g_free(bdref_key_dot);\n\n    /*\n     * Caution: while qdict_get_try_str() is fine, getting non-string\n     * types would require more care.  When @options come from\n     * -blockdev or blockdev_add, its members are typed according to\n     * the QAPI schema, but when they come from -drive, they're all\n     * QString.\n     */\n    reference = qdict_get_try_str(options, bdref_key);\n    if (!filename && !reference && !qdict_size(image_options)) {\n        if (!allow_none) {\n            error_setg(errp, \"A block device must be specified for \\\"%s\\\"\",\n                       bdref_key);\n        }\n        qobject_unref(image_options);\n        goto done;\n    }\n\n    bs = bdrv_open_inherit(filename, reference, image_options, 0,\n                           parent, child_class, child_role, errp);\n    if (!bs) {\n        goto done;\n    }\n\ndone:\n    qdict_del(options, bdref_key);\n    return bs;\n}\n\n/*\n * Opens a disk image whose options are given as BlockdevRef in another block\n * device's options.\n *\n * If allow_none is true, no image will be opened if filename is false and no\n * BlockdevRef is given. NULL will be returned, but errp remains unset.\n *\n * bdrev_key specifies the key for the image's BlockdevRef in the options QDict.\n * That QDict has to be flattened; therefore, if the BlockdevRef is a QDict\n * itself, all options starting with \"${bdref_key}.\" are considered part of the\n * BlockdevRef.\n *\n * The BlockdevRef will be removed from the options QDict.\n */\nBdrvChild *bdrv_open_child(const char *filename,\n                           QDict *options, const char *bdref_key,\n                           BlockDriverState *parent,\n                           const BdrvChildClass *child_class,\n                           BdrvChildRole child_role,\n                           bool allow_none, Error **errp)\n{\n    BlockDriverState *bs;\n\n    GLOBAL_STATE_CODE();\n\n    bs = bdrv_open_child_bs(filename, options, bdref_key, parent, child_class,\n                            child_role, allow_none, errp);\n    if (bs == NULL) {\n        return NULL;\n    }\n\n    return bdrv_attach_child(parent, bs, bdref_key, child_class, child_role,\n                             errp);\n}\n\n/*\n * TODO Future callers may need to specify parent/child_class in order for\n * option inheritance to work. Existing callers use it for the root node.\n */\nBlockDriverState *bdrv_open_blockdev_ref(BlockdevRef *ref, Error **errp)\n{\n    BlockDriverState *bs = NULL;\n    QObject *obj = NULL;\n    QDict *qdict = NULL;\n    const char *reference = NULL;\n    Visitor *v = NULL;\n\n    GLOBAL_STATE_CODE();\n\n    if (ref->type == QTYPE_QSTRING) {\n        reference = ref->u.reference;\n    } else {\n        BlockdevOptions *options = &ref->u.definition;\n        assert(ref->type == QTYPE_QDICT);\n\n        v = qobject_output_visitor_new(&obj);\n        visit_type_BlockdevOptions(v, NULL, &options, &error_abort);\n        visit_complete(v, &obj);\n\n        qdict = qobject_to(QDict, obj);\n        qdict_flatten(qdict);\n\n        /* bdrv_open_inherit() defaults to the values in bdrv_flags (for\n         * compatibility with other callers) rather than what we want as the\n         * real defaults. Apply the defaults here instead. */\n        qdict_set_default_str(qdict, BDRV_OPT_CACHE_DIRECT, \"off\");\n        qdict_set_default_str(qdict, BDRV_OPT_CACHE_NO_FLUSH, \"off\");\n        qdict_set_default_str(qdict, BDRV_OPT_READ_ONLY, \"off\");\n        qdict_set_default_str(qdict, BDRV_OPT_AUTO_READ_ONLY, \"off\");\n\n    }\n\n    bs = bdrv_open_inherit(NULL, reference, qdict, 0, NULL, NULL, 0, errp);\n    obj = NULL;\n    qobject_unref(obj);\n    visit_free(v);\n    return bs;\n}\n\nstatic BlockDriverState *bdrv_append_temp_snapshot(BlockDriverState *bs,\n                                                   int flags,\n                                                   QDict *snapshot_options,\n                                                   Error **errp)\n{\n    /* TODO: extra byte is a hack to ensure MAX_PATH space on Windows. */\n    char *tmp_filename = g_malloc0(PATH_MAX + 1);\n    int64_t total_size;\n    QemuOpts *opts = NULL;\n    BlockDriverState *bs_snapshot = NULL;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    /* if snapshot, we create a temporary backing file and open it\n       instead of opening 'filename' directly */\n\n    /* Get the required size from the image */\n    total_size = bdrv_getlength(bs);\n    if (total_size < 0) {\n        error_setg_errno(errp, -total_size, \"Could not get image size\");\n        goto out;\n    }\n\n    /* Create the temporary image */\n    ret = get_tmp_filename(tmp_filename, PATH_MAX + 1);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not get temporary filename\");\n        goto out;\n    }\n\n    opts = qemu_opts_create(bdrv_qcow2.create_opts, NULL, 0,\n                            &error_abort);\n    qemu_opt_set_number(opts, BLOCK_OPT_SIZE, total_size, &error_abort);\n    ret = bdrv_create(&bdrv_qcow2, tmp_filename, opts, errp);\n    qemu_opts_del(opts);\n    if (ret < 0) {\n        error_prepend(errp, \"Could not create temporary overlay '%s': \",\n                      tmp_filename);\n        goto out;\n    }\n\n    /* Prepare options QDict for the temporary file */\n    qdict_put_str(snapshot_options, \"file.driver\", \"file\");\n    qdict_put_str(snapshot_options, \"file.filename\", tmp_filename);\n    qdict_put_str(snapshot_options, \"driver\", \"qcow2\");\n\n    bs_snapshot = bdrv_open(NULL, NULL, snapshot_options, flags, errp);\n    snapshot_options = NULL;\n    if (!bs_snapshot) {\n        goto out;\n    }\n\n    ret = bdrv_append(bs_snapshot, bs, errp);\n    if (ret < 0) {\n        bs_snapshot = NULL;\n        goto out;\n    }\n\nout:\n    qobject_unref(snapshot_options);\n    g_free(tmp_filename);\n    return bs_snapshot;\n}\n\n/*\n * Opens a disk image (raw, qcow2, vmdk, ...)\n *\n * options is a QDict of options to pass to the block drivers, or NULL for an\n * empty set of options. The reference to the QDict belongs to the block layer\n * after the call (even on failure), so if the caller intends to reuse the\n * dictionary, it needs to use qobject_ref() before calling bdrv_open.\n *\n * If *pbs is NULL, a new BDS will be created with a pointer to it stored there.\n * If it is not NULL, the referenced BDS will be reused.\n *\n * The reference parameter may be used to specify an existing block device which\n * should be opened. If specified, neither options nor a filename may be given,\n * nor can an existing BDS be reused (that is, *pbs has to be NULL).\n */\nstatic BlockDriverState *bdrv_open_inherit(const char *filename,\n                                           const char *reference,\n                                           QDict *options, int flags,\n                                           BlockDriverState *parent,\n                                           const BdrvChildClass *child_class,\n                                           BdrvChildRole child_role,\n                                           Error **errp)\n{\n    int ret;\n    BlockBackend *file = NULL;\n    BlockDriverState *bs;\n    BlockDriver *drv = NULL;\n    BdrvChild *child;\n    const char *drvname;\n    const char *backing;\n    Error *local_err = NULL;\n    QDict *snapshot_options = NULL;\n    int snapshot_flags = 0;\n\n    assert(!child_class || !flags);\n    assert(!child_class == !parent);\n    GLOBAL_STATE_CODE();\n\n    if (reference) {\n        bool options_non_empty = options ? qdict_size(options) : false;\n        qobject_unref(options);\n\n        if (filename || options_non_empty) {\n            error_setg(errp, \"Cannot reference an existing block device with \"\n                       \"additional options or a new filename\");\n            return NULL;\n        }\n\n        bs = bdrv_lookup_bs(reference, reference, errp);\n        if (!bs) {\n            return NULL;\n        }\n\n        bdrv_ref(bs);\n        return bs;\n    }\n\n    bs = bdrv_new();\n\n    /* NULL means an empty set of options */\n    if (options == NULL) {\n        options = qdict_new();\n    }\n\n    /* json: syntax counts as explicit options, as if in the QDict */\n    parse_json_protocol(options, &filename, &local_err);\n    if (local_err) {\n        goto fail;\n    }\n\n    bs->explicit_options = qdict_clone_shallow(options);\n\n    if (child_class) {\n        bool parent_is_format;\n\n        if (parent->drv) {\n            parent_is_format = parent->drv->is_format;\n        } else {\n            /*\n             * parent->drv is not set yet because this node is opened for\n             * (potential) format probing.  That means that @parent is going\n             * to be a format node.\n             */\n            parent_is_format = true;\n        }\n\n        bs->inherits_from = parent;\n        child_class->inherit_options(child_role, parent_is_format,\n                                     &flags, options,\n                                     parent->open_flags, parent->options);\n    }\n\n    ret = bdrv_fill_options(&options, filename, &flags, &local_err);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    /*\n     * Set the BDRV_O_RDWR and BDRV_O_ALLOW_RDWR flags.\n     * Caution: getting a boolean member of @options requires care.\n     * When @options come from -blockdev or blockdev_add, members are\n     * typed according to the QAPI schema, but when they come from\n     * -drive, they're all QString.\n     */\n    if (g_strcmp0(qdict_get_try_str(options, BDRV_OPT_READ_ONLY), \"on\") &&\n        !qdict_get_try_bool(options, BDRV_OPT_READ_ONLY, false)) {\n        flags |= (BDRV_O_RDWR | BDRV_O_ALLOW_RDWR);\n    } else {\n        flags &= ~BDRV_O_RDWR;\n    }\n\n    if (flags & BDRV_O_SNAPSHOT) {\n        snapshot_options = qdict_new();\n        bdrv_temp_snapshot_options(&snapshot_flags, snapshot_options,\n                                   flags, options);\n        /* Let bdrv_backing_options() override \"read-only\" */\n        qdict_del(options, BDRV_OPT_READ_ONLY);\n        bdrv_inherited_options(BDRV_CHILD_COW, true,\n                               &flags, options, flags, options);\n    }\n\n    bs->open_flags = flags;\n    bs->options = options;\n    options = qdict_clone_shallow(options);\n\n    /* Find the right image format driver */\n    /* See cautionary note on accessing @options above */\n    drvname = qdict_get_try_str(options, \"driver\");\n    if (drvname) {\n        drv = bdrv_find_format(drvname);\n        if (!drv) {\n            error_setg(errp, \"Unknown driver: '%s'\", drvname);\n            goto fail;\n        }\n    }\n\n    assert(drvname || !(flags & BDRV_O_PROTOCOL));\n\n    /* See cautionary note on accessing @options above */\n    backing = qdict_get_try_str(options, \"backing\");\n    if (qobject_to(QNull, qdict_get(options, \"backing\")) != NULL ||\n        (backing && *backing == '\\0'))\n    {\n        if (backing) {\n            warn_report(\"Use of \\\"backing\\\": \\\"\\\" is deprecated; \"\n                        \"use \\\"backing\\\": null instead\");\n        }\n        flags |= BDRV_O_NO_BACKING;\n        qdict_del(bs->explicit_options, \"backing\");\n        qdict_del(bs->options, \"backing\");\n        qdict_del(options, \"backing\");\n    }\n\n    /* Open image file without format layer. This BlockBackend is only used for\n     * probing, the block drivers will do their own bdrv_open_child() for the\n     * same BDS, which is why we put the node name back into options. */\n    if ((flags & BDRV_O_PROTOCOL) == 0) {\n        BlockDriverState *file_bs;\n\n        file_bs = bdrv_open_child_bs(filename, options, \"file\", bs,\n                                     &child_of_bds, BDRV_CHILD_IMAGE,\n                                     true, &local_err);\n        if (local_err) {\n            goto fail;\n        }\n        if (file_bs != NULL) {\n            /* Not requesting BLK_PERM_CONSISTENT_READ because we're only\n             * looking at the header to guess the image format. This works even\n             * in cases where a guest would not see a consistent state. */\n            file = blk_new(bdrv_get_aio_context(file_bs), 0, BLK_PERM_ALL);\n            blk_insert_bs(file, file_bs, &local_err);\n            bdrv_unref(file_bs);\n            if (local_err) {\n                goto fail;\n            }\n\n            qdict_put_str(options, \"file\", bdrv_get_node_name(file_bs));\n        }\n    }\n\n    /* Image format probing */\n    bs->probed = !drv;\n    if (!drv && file) {\n        ret = find_image_format(file, filename, &drv, &local_err);\n        if (ret < 0) {\n            goto fail;\n        }\n        /*\n         * This option update would logically belong in bdrv_fill_options(),\n         * but we first need to open bs->file for the probing to work, while\n         * opening bs->file already requires the (mostly) final set of options\n         * so that cache mode etc. can be inherited.\n         *\n         * Adding the driver later is somewhat ugly, but it's not an option\n         * that would ever be inherited, so it's correct. We just need to make\n         * sure to update both bs->options (which has the full effective\n         * options for bs) and options (which has file.* already removed).\n         */\n        qdict_put_str(bs->options, \"driver\", drv->format_name);\n        qdict_put_str(options, \"driver\", drv->format_name);\n    } else if (!drv) {\n        error_setg(errp, \"Must specify either driver or file\");\n        goto fail;\n    }\n\n    /* BDRV_O_PROTOCOL must be set iff a protocol BDS is about to be created */\n    assert(!!(flags & BDRV_O_PROTOCOL) == !!drv->bdrv_file_open);\n    /* file must be NULL if a protocol BDS is about to be created\n     * (the inverse results in an error message from bdrv_open_common()) */\n    assert(!(flags & BDRV_O_PROTOCOL) || !file);\n\n    /* Open the image */\n    ret = bdrv_open_common(bs, file, options, &local_err);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    if (file) {\n        blk_unref(file);\n        file = NULL;\n    }\n\n    /* If there is a backing file, use it */\n    if ((flags & BDRV_O_NO_BACKING) == 0) {\n        ret = bdrv_open_backing_file(bs, options, \"backing\", &local_err);\n        if (ret < 0) {\n            goto close_and_fail;\n        }\n    }\n\n    /* Remove all children options and references\n     * from bs->options and bs->explicit_options */\n    QLIST_FOREACH(child, &bs->children, next) {\n        char *child_key_dot;\n        child_key_dot = g_strdup_printf(\"%s.\", child->name);\n        qdict_extract_subqdict(bs->explicit_options, NULL, child_key_dot);\n        qdict_extract_subqdict(bs->options, NULL, child_key_dot);\n        qdict_del(bs->explicit_options, child->name);\n        qdict_del(bs->options, child->name);\n        g_free(child_key_dot);\n    }\n\n    /* Check if any unknown options were used */\n    if (qdict_size(options) != 0) {\n        const QDictEntry *entry = qdict_first(options);\n        if (flags & BDRV_O_PROTOCOL) {\n            error_setg(errp, \"Block protocol '%s' doesn't support the option \"\n                       \"'%s'\", drv->format_name, entry->key);\n        } else {\n            error_setg(errp,\n                       \"Block format '%s' does not support the option '%s'\",\n                       drv->format_name, entry->key);\n        }\n\n        goto close_and_fail;\n    }\n\n    bdrv_parent_cb_change_media(bs, true);\n\n    qobject_unref(options);\n    options = NULL;\n\n    /* For snapshot=on, create a temporary qcow2 overlay. bs points to the\n     * temporary snapshot afterwards. */\n    if (snapshot_flags) {\n        BlockDriverState *snapshot_bs;\n        snapshot_bs = bdrv_append_temp_snapshot(bs, snapshot_flags,\n                                                snapshot_options, &local_err);\n        snapshot_options = NULL;\n        if (local_err) {\n            goto close_and_fail;\n        }\n        /* We are not going to return bs but the overlay on top of it\n         * (snapshot_bs); thus, we have to drop the strong reference to bs\n         * (which we obtained by calling bdrv_new()). bs will not be deleted,\n         * though, because the overlay still has a reference to it. */\n        bdrv_unref(bs);\n        bs = snapshot_bs;\n    }\n\n    return bs;\n\nfail:\n    blk_unref(file);\n    qobject_unref(snapshot_options);\n    qobject_unref(bs->explicit_options);\n    qobject_unref(bs->options);\n    qobject_unref(options);\n    bs->options = NULL;\n    bs->explicit_options = NULL;\n    bdrv_unref(bs);\n    error_propagate(errp, local_err);\n    return NULL;\n\nclose_and_fail:\n    bdrv_unref(bs);\n    qobject_unref(snapshot_options);\n    qobject_unref(options);\n    error_propagate(errp, local_err);\n    return NULL;\n}\n\nBlockDriverState *bdrv_open(const char *filename, const char *reference,\n                            QDict *options, int flags, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n\n    return bdrv_open_inherit(filename, reference, options, flags, NULL,\n                             NULL, 0, errp);\n}\n\n/* Return true if the NULL-terminated @list contains @str */\nstatic bool is_str_in_list(const char *str, const char *const *list)\n{\n    if (str && list) {\n        int i;\n        for (i = 0; list[i] != NULL; i++) {\n            if (!strcmp(str, list[i])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/*\n * Check that every option set in @bs->options is also set in\n * @new_opts.\n *\n * Options listed in the common_options list and in\n * @bs->drv->mutable_opts are skipped.\n *\n * Return 0 on success, otherwise return -EINVAL and set @errp.\n */\nstatic int bdrv_reset_options_allowed(BlockDriverState *bs,\n                                      const QDict *new_opts, Error **errp)\n{\n    const QDictEntry *e;\n    /* These options are common to all block drivers and are handled\n     * in bdrv_reopen_prepare() so they can be left out of @new_opts */\n    const char *const common_options[] = {\n        \"node-name\", \"discard\", \"cache.direct\", \"cache.no-flush\",\n        \"read-only\", \"auto-read-only\", \"detect-zeroes\", NULL\n    };\n\n    for (e = qdict_first(bs->options); e; e = qdict_next(bs->options, e)) {\n        if (!qdict_haskey(new_opts, e->key) &&\n            !is_str_in_list(e->key, common_options) &&\n            !is_str_in_list(e->key, bs->drv->mutable_opts)) {\n            error_setg(errp, \"Option '%s' cannot be reset \"\n                       \"to its default value\", e->key);\n            return -EINVAL;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Returns true if @child can be reached recursively from @bs\n */\nstatic bool bdrv_recurse_has_child(BlockDriverState *bs,\n                                   BlockDriverState *child)\n{\n    BdrvChild *c;\n\n    if (bs == child) {\n        return true;\n    }\n\n    QLIST_FOREACH(c, &bs->children, next) {\n        if (bdrv_recurse_has_child(c->bs, child)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*\n * Adds a BlockDriverState to a simple queue for an atomic, transactional\n * reopen of multiple devices.\n *\n * bs_queue can either be an existing BlockReopenQueue that has had QTAILQ_INIT\n * already performed, or alternatively may be NULL a new BlockReopenQueue will\n * be created and initialized. This newly created BlockReopenQueue should be\n * passed back in for subsequent calls that are intended to be of the same\n * atomic 'set'.\n *\n * bs is the BlockDriverState to add to the reopen queue.\n *\n * options contains the changed options for the associated bs\n * (the BlockReopenQueue takes ownership)\n *\n * flags contains the open flags for the associated bs\n *\n * returns a pointer to bs_queue, which is either the newly allocated\n * bs_queue, or the existing bs_queue being used.\n *\n * bs must be drained between bdrv_reopen_queue() and bdrv_reopen_multiple().\n */\nstatic BlockReopenQueue *bdrv_reopen_queue_child(BlockReopenQueue *bs_queue,\n                                                 BlockDriverState *bs,\n                                                 QDict *options,\n                                                 const BdrvChildClass *klass,\n                                                 BdrvChildRole role,\n                                                 bool parent_is_format,\n                                                 QDict *parent_options,\n                                                 int parent_flags,\n                                                 bool keep_old_opts)\n{\n    assert(bs != NULL);\n\n    BlockReopenQueueEntry *bs_entry;\n    BdrvChild *child;\n    QDict *old_options, *explicit_options, *options_copy;\n    int flags;\n    QemuOpts *opts;\n\n    /* Make sure that the caller remembered to use a drained section. This is\n     * important to avoid graph changes between the recursive queuing here and\n     * bdrv_reopen_multiple(). */\n    assert(bs->quiesce_counter > 0);\n    GLOBAL_STATE_CODE();\n\n    if (bs_queue == NULL) {\n        bs_queue = g_new0(BlockReopenQueue, 1);\n        QTAILQ_INIT(bs_queue);\n    }\n\n    if (!options) {\n        options = qdict_new();\n    }\n\n    /* Check if this BlockDriverState is already in the queue */\n    QTAILQ_FOREACH(bs_entry, bs_queue, entry) {\n        if (bs == bs_entry->state.bs) {\n            break;\n        }\n    }\n\n    /*\n     * Precedence of options:\n     * 1. Explicitly passed in options (highest)\n     * 2. Retained from explicitly set options of bs\n     * 3. Inherited from parent node\n     * 4. Retained from effective options of bs\n     */\n\n    /* Old explicitly set values (don't overwrite by inherited value) */\n    if (bs_entry || keep_old_opts) {\n        old_options = qdict_clone_shallow(bs_entry ?\n                                          bs_entry->state.explicit_options :\n                                          bs->explicit_options);\n        bdrv_join_options(bs, options, old_options);\n        qobject_unref(old_options);\n    }\n\n    explicit_options = qdict_clone_shallow(options);\n\n    /* Inherit from parent node */\n    if (parent_options) {\n        flags = 0;\n        klass->inherit_options(role, parent_is_format, &flags, options,\n                               parent_flags, parent_options);\n    } else {\n        flags = bdrv_get_flags(bs);\n    }\n\n    if (keep_old_opts) {\n        /* Old values are used for options that aren't set yet */\n        old_options = qdict_clone_shallow(bs->options);\n        bdrv_join_options(bs, options, old_options);\n        qobject_unref(old_options);\n    }\n\n    /* We have the final set of options so let's update the flags */\n    options_copy = qdict_clone_shallow(options);\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n    qemu_opts_absorb_qdict(opts, options_copy, NULL);\n    update_flags_from_options(&flags, opts);\n    qemu_opts_del(opts);\n    qobject_unref(options_copy);\n\n    /* bdrv_open_inherit() sets and clears some additional flags internally */\n    flags &= ~BDRV_O_PROTOCOL;\n    if (flags & BDRV_O_RDWR) {\n        flags |= BDRV_O_ALLOW_RDWR;\n    }\n\n    if (!bs_entry) {\n        bs_entry = g_new0(BlockReopenQueueEntry, 1);\n        QTAILQ_INSERT_TAIL(bs_queue, bs_entry, entry);\n    } else {\n        qobject_unref(bs_entry->state.options);\n        qobject_unref(bs_entry->state.explicit_options);\n    }\n\n    bs_entry->state.bs = bs;\n    bs_entry->state.options = options;\n    bs_entry->state.explicit_options = explicit_options;\n    bs_entry->state.flags = flags;\n\n    /*\n     * If keep_old_opts is false then it means that unspecified\n     * options must be reset to their original value. We don't allow\n     * resetting 'backing' but we need to know if the option is\n     * missing in order to decide if we have to return an error.\n     */\n    if (!keep_old_opts) {\n        bs_entry->state.backing_missing =\n            !qdict_haskey(options, \"backing\") &&\n            !qdict_haskey(options, \"backing.driver\");\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        QDict *new_child_options = NULL;\n        bool child_keep_old = keep_old_opts;\n\n        /* reopen can only change the options of block devices that were\n         * implicitly created and inherited options. For other (referenced)\n         * block devices, a syntax like \"backing.foo\" results in an error. */\n        if (child->bs->inherits_from != bs) {\n            continue;\n        }\n\n        /* Check if the options contain a child reference */\n        if (qdict_haskey(options, child->name)) {\n            const char *childref = qdict_get_try_str(options, child->name);\n            /*\n             * The current child must not be reopened if the child\n             * reference is null or points to a different node.\n             */\n            if (g_strcmp0(childref, child->bs->node_name)) {\n                continue;\n            }\n            /*\n             * If the child reference points to the current child then\n             * reopen it with its existing set of options (note that\n             * it can still inherit new options from the parent).\n             */\n            child_keep_old = true;\n        } else {\n            /* Extract child options (\"child-name.*\") */\n            char *child_key_dot = g_strdup_printf(\"%s.\", child->name);\n            qdict_extract_subqdict(explicit_options, NULL, child_key_dot);\n            qdict_extract_subqdict(options, &new_child_options, child_key_dot);\n            g_free(child_key_dot);\n        }\n\n        bdrv_reopen_queue_child(bs_queue, child->bs, new_child_options,\n                                child->klass, child->role, bs->drv->is_format,\n                                options, flags, child_keep_old);\n    }\n\n    return bs_queue;\n}\n\nBlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,\n                                    BlockDriverState *bs,\n                                    QDict *options, bool keep_old_opts)\n{\n    GLOBAL_STATE_CODE();\n\n    return bdrv_reopen_queue_child(bs_queue, bs, options, NULL, 0, false,\n                                   NULL, 0, keep_old_opts);\n}\n\nvoid bdrv_reopen_queue_free(BlockReopenQueue *bs_queue)\n{\n    GLOBAL_STATE_CODE();\n    if (bs_queue) {\n        BlockReopenQueueEntry *bs_entry, *next;\n        QTAILQ_FOREACH_SAFE(bs_entry, bs_queue, entry, next) {\n            qobject_unref(bs_entry->state.explicit_options);\n            qobject_unref(bs_entry->state.options);\n            g_free(bs_entry);\n        }\n        g_free(bs_queue);\n    }\n}\n\n/*\n * Reopen multiple BlockDriverStates atomically & transactionally.\n *\n * The queue passed in (bs_queue) must have been built up previous\n * via bdrv_reopen_queue().\n *\n * Reopens all BDS specified in the queue, with the appropriate\n * flags.  All devices are prepared for reopen, and failure of any\n * device will cause all device changes to be abandoned, and intermediate\n * data cleaned up.\n *\n * If all devices prepare successfully, then the changes are committed\n * to all devices.\n *\n * All affected nodes must be drained between bdrv_reopen_queue() and\n * bdrv_reopen_multiple().\n *\n * To be called from the main thread, with all other AioContexts unlocked.\n */\nint bdrv_reopen_multiple(BlockReopenQueue *bs_queue, Error **errp)\n{\n    int ret = -1;\n    BlockReopenQueueEntry *bs_entry, *next;\n    AioContext *ctx;\n    Transaction *tran = tran_new();\n    g_autoptr(GHashTable) found = NULL;\n    g_autoptr(GSList) refresh_list = NULL;\n\n    assert(qemu_get_current_aio_context() == qemu_get_aio_context());\n    assert(bs_queue != NULL);\n    GLOBAL_STATE_CODE();\n\n    QTAILQ_FOREACH(bs_entry, bs_queue, entry) {\n        ctx = bdrv_get_aio_context(bs_entry->state.bs);\n        aio_context_acquire(ctx);\n        ret = bdrv_flush(bs_entry->state.bs);\n        aio_context_release(ctx);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Error flushing drive\");\n            goto abort;\n        }\n    }\n\n    QTAILQ_FOREACH(bs_entry, bs_queue, entry) {\n        assert(bs_entry->state.bs->quiesce_counter > 0);\n        ctx = bdrv_get_aio_context(bs_entry->state.bs);\n        aio_context_acquire(ctx);\n        ret = bdrv_reopen_prepare(&bs_entry->state, bs_queue, tran, errp);\n        aio_context_release(ctx);\n        if (ret < 0) {\n            goto abort;\n        }\n        bs_entry->prepared = true;\n    }\n\n    found = g_hash_table_new(NULL, NULL);\n    QTAILQ_FOREACH(bs_entry, bs_queue, entry) {\n        BDRVReopenState *state = &bs_entry->state;\n\n        refresh_list = bdrv_topological_dfs(refresh_list, found, state->bs);\n        if (state->old_backing_bs) {\n            refresh_list = bdrv_topological_dfs(refresh_list, found,\n                                                state->old_backing_bs);\n        }\n        if (state->old_file_bs) {\n            refresh_list = bdrv_topological_dfs(refresh_list, found,\n                                                state->old_file_bs);\n        }\n    }\n\n    /*\n     * Note that file-posix driver rely on permission update done during reopen\n     * (even if no permission changed), because it wants \"new\" permissions for\n     * reconfiguring the fd and that's why it does it in raw_check_perm(), not\n     * in raw_reopen_prepare() which is called with \"old\" permissions.\n     */\n    ret = bdrv_list_refresh_perms(refresh_list, bs_queue, tran, errp);\n    if (ret < 0) {\n        goto abort;\n    }\n\n    /*\n     * If we reach this point, we have success and just need to apply the\n     * changes.\n     *\n     * Reverse order is used to comfort qcow2 driver: on commit it need to write\n     * IN_USE flag to the image, to mark bitmaps in the image as invalid. But\n     * children are usually goes after parents in reopen-queue, so go from last\n     * to first element.\n     */\n    QTAILQ_FOREACH_REVERSE(bs_entry, bs_queue, entry) {\n        ctx = bdrv_get_aio_context(bs_entry->state.bs);\n        aio_context_acquire(ctx);\n        bdrv_reopen_commit(&bs_entry->state);\n        aio_context_release(ctx);\n    }\n\n    tran_commit(tran);\n\n    QTAILQ_FOREACH_REVERSE(bs_entry, bs_queue, entry) {\n        BlockDriverState *bs = bs_entry->state.bs;\n\n        if (bs->drv->bdrv_reopen_commit_post) {\n            ctx = bdrv_get_aio_context(bs);\n            aio_context_acquire(ctx);\n            bs->drv->bdrv_reopen_commit_post(&bs_entry->state);\n            aio_context_release(ctx);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\nabort:\n    tran_abort(tran);\n    QTAILQ_FOREACH_SAFE(bs_entry, bs_queue, entry, next) {\n        if (bs_entry->prepared) {\n            ctx = bdrv_get_aio_context(bs_entry->state.bs);\n            aio_context_acquire(ctx);\n            bdrv_reopen_abort(&bs_entry->state);\n            aio_context_release(ctx);\n        }\n    }\n\ncleanup:\n    bdrv_reopen_queue_free(bs_queue);\n\n    return ret;\n}\n\nint bdrv_reopen(BlockDriverState *bs, QDict *opts, bool keep_old_opts,\n                Error **errp)\n{\n    AioContext *ctx = bdrv_get_aio_context(bs);\n    BlockReopenQueue *queue;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    bdrv_subtree_drained_begin(bs);\n    if (ctx != qemu_get_aio_context()) {\n        aio_context_release(ctx);\n    }\n\n    queue = bdrv_reopen_queue(NULL, bs, opts, keep_old_opts);\n    ret = bdrv_reopen_multiple(queue, errp);\n\n    if (ctx != qemu_get_aio_context()) {\n        aio_context_acquire(ctx);\n    }\n    bdrv_subtree_drained_end(bs);\n\n    return ret;\n}\n\nint bdrv_reopen_set_read_only(BlockDriverState *bs, bool read_only,\n                              Error **errp)\n{\n    QDict *opts = qdict_new();\n\n    GLOBAL_STATE_CODE();\n\n    qdict_put_bool(opts, BDRV_OPT_READ_ONLY, read_only);\n\n    return bdrv_reopen(bs, opts, true, errp);\n}\n\n/*\n * Take a BDRVReopenState and check if the value of 'backing' in the\n * reopen_state->options QDict is valid or not.\n *\n * If 'backing' is missing from the QDict then return 0.\n *\n * If 'backing' contains the node name of the backing file of\n * reopen_state->bs then return 0.\n *\n * If 'backing' contains a different node name (or is null) then check\n * whether the current backing file can be replaced with the new one.\n * If that's the case then reopen_state->replace_backing_bs is set to\n * true and reopen_state->new_backing_bs contains a pointer to the new\n * backing BlockDriverState (or NULL).\n *\n * Return 0 on success, otherwise return < 0 and set @errp.\n */\nstatic int bdrv_reopen_parse_file_or_backing(BDRVReopenState *reopen_state,\n                                             bool is_backing, Transaction *tran,\n                                             Error **errp)\n{\n    BlockDriverState *bs = reopen_state->bs;\n    BlockDriverState *new_child_bs;\n    BlockDriverState *old_child_bs = is_backing ? child_bs(bs->backing) :\n                                                  child_bs(bs->file);\n    const char *child_name = is_backing ? \"backing\" : \"file\";\n    QObject *value;\n    const char *str;\n\n    GLOBAL_STATE_CODE();\n\n    value = qdict_get(reopen_state->options, child_name);\n    if (value == NULL) {\n        return 0;\n    }\n\n    switch (qobject_type(value)) {\n    case QTYPE_QNULL:\n        assert(is_backing); /* The 'file' option does not allow a null value */\n        new_child_bs = NULL;\n        break;\n    case QTYPE_QSTRING:\n        str = qstring_get_str(qobject_to(QString, value));\n        new_child_bs = bdrv_lookup_bs(NULL, str, errp);\n        if (new_child_bs == NULL) {\n            return -EINVAL;\n        } else if (bdrv_recurse_has_child(new_child_bs, bs)) {\n            error_setg(errp, \"Making '%s' a %s child of '%s' would create a \"\n                       \"cycle\", str, child_name, bs->node_name);\n            return -EINVAL;\n        }\n        break;\n    default:\n        /*\n         * The options QDict has been flattened, so 'backing' and 'file'\n         * do not allow any other data type here.\n         */\n        g_assert_not_reached();\n    }\n\n    if (old_child_bs == new_child_bs) {\n        return 0;\n    }\n\n    if (old_child_bs) {\n        if (bdrv_skip_implicit_filters(old_child_bs) == new_child_bs) {\n            return 0;\n        }\n\n        if (old_child_bs->implicit) {\n            error_setg(errp, \"Cannot replace implicit %s child of %s\",\n                       child_name, bs->node_name);\n            return -EPERM;\n        }\n    }\n\n    if (bs->drv->is_filter && !old_child_bs) {\n        /*\n         * Filters always have a file or a backing child, so we are trying to\n         * change wrong child\n         */\n        error_setg(errp, \"'%s' is a %s filter node that does not support a \"\n                   \"%s child\", bs->node_name, bs->drv->format_name, child_name);\n        return -EINVAL;\n    }\n\n    if (is_backing) {\n        reopen_state->old_backing_bs = old_child_bs;\n    } else {\n        reopen_state->old_file_bs = old_child_bs;\n    }\n\n    return bdrv_set_file_or_backing_noperm(bs, new_child_bs, is_backing,\n                                           tran, errp);\n}\n\n/*\n * Prepares a BlockDriverState for reopen. All changes are staged in the\n * 'opaque' field of the BDRVReopenState, which is used and allocated by\n * the block driver layer .bdrv_reopen_prepare()\n *\n * bs is the BlockDriverState to reopen\n * flags are the new open flags\n * queue is the reopen queue\n *\n * Returns 0 on success, non-zero on error.  On error errp will be set\n * as well.\n *\n * On failure, bdrv_reopen_abort() will be called to clean up any data.\n * It is the responsibility of the caller to then call the abort() or\n * commit() for any other BDS that have been left in a prepare() state\n *\n */\nstatic int bdrv_reopen_prepare(BDRVReopenState *reopen_state,\n                               BlockReopenQueue *queue,\n                               Transaction *change_child_tran, Error **errp)\n{\n    int ret = -1;\n    int old_flags;\n    Error *local_err = NULL;\n    BlockDriver *drv;\n    QemuOpts *opts;\n    QDict *orig_reopen_opts;\n    char *discard = NULL;\n    bool read_only;\n    bool drv_prepared = false;\n\n    assert(reopen_state != NULL);\n    assert(reopen_state->bs->drv != NULL);\n    GLOBAL_STATE_CODE();\n    drv = reopen_state->bs->drv;\n\n    /* This function and each driver's bdrv_reopen_prepare() remove\n     * entries from reopen_state->options as they are processed, so\n     * we need to make a copy of the original QDict. */\n    orig_reopen_opts = qdict_clone_shallow(reopen_state->options);\n\n    /* Process generic block layer options */\n    opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);\n    if (!qemu_opts_absorb_qdict(opts, reopen_state->options, errp)) {\n        ret = -EINVAL;\n        goto error;\n    }\n\n    /* This was already called in bdrv_reopen_queue_child() so the flags\n     * are up-to-date. This time we simply want to remove the options from\n     * QemuOpts in order to indicate that they have been processed. */\n    old_flags = reopen_state->flags;\n    update_flags_from_options(&reopen_state->flags, opts);\n    assert(old_flags == reopen_state->flags);\n\n    discard = qemu_opt_get_del(opts, BDRV_OPT_DISCARD);\n    if (discard != NULL) {\n        if (bdrv_parse_discard_flags(discard, &reopen_state->flags) != 0) {\n            error_setg(errp, \"Invalid discard option\");\n            ret = -EINVAL;\n            goto error;\n        }\n    }\n\n    reopen_state->detect_zeroes =\n        bdrv_parse_detect_zeroes(opts, reopen_state->flags, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        ret = -EINVAL;\n        goto error;\n    }\n\n    /* All other options (including node-name and driver) must be unchanged.\n     * Put them back into the QDict, so that they are checked at the end\n     * of this function. */\n    qemu_opts_to_qdict(opts, reopen_state->options);\n\n    /* If we are to stay read-only, do not allow permission change\n     * to r/w. Attempting to set to r/w may fail if either BDRV_O_ALLOW_RDWR is\n     * not set, or if the BDS still has copy_on_read enabled */\n    read_only = !(reopen_state->flags & BDRV_O_RDWR);\n    ret = bdrv_can_set_read_only(reopen_state->bs, read_only, true, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto error;\n    }\n\n    if (drv->bdrv_reopen_prepare) {\n        /*\n         * If a driver-specific option is missing, it means that we\n         * should reset it to its default value.\n         * But not all options allow that, so we need to check it first.\n         */\n        ret = bdrv_reset_options_allowed(reopen_state->bs,\n                                         reopen_state->options, errp);\n        if (ret) {\n            goto error;\n        }\n\n        ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);\n        if (ret) {\n            if (local_err != NULL) {\n                error_propagate(errp, local_err);\n            } else {\n                bdrv_refresh_filename(reopen_state->bs);\n                error_setg(errp, \"failed while preparing to reopen image '%s'\",\n                           reopen_state->bs->filename);\n            }\n            goto error;\n        }\n    } else {\n        /* It is currently mandatory to have a bdrv_reopen_prepare()\n         * handler for each supported drv. */\n        error_setg(errp, \"Block format '%s' used by node '%s' \"\n                   \"does not support reopening files\", drv->format_name,\n                   bdrv_get_device_or_node_name(reopen_state->bs));\n        ret = -1;\n        goto error;\n    }\n\n    drv_prepared = true;\n\n    /*\n     * We must provide the 'backing' option if the BDS has a backing\n     * file or if the image file has a backing file name as part of\n     * its metadata. Otherwise the 'backing' option can be omitted.\n     */\n    if (drv->supports_backing && reopen_state->backing_missing &&\n        (reopen_state->bs->backing || reopen_state->bs->backing_file[0])) {\n        error_setg(errp, \"backing is missing for '%s'\",\n                   reopen_state->bs->node_name);\n        ret = -EINVAL;\n        goto error;\n    }\n\n    /*\n     * Allow changing the 'backing' option. The new value can be\n     * either a reference to an existing node (using its node name)\n     * or NULL to simply detach the current backing file.\n     */\n    ret = bdrv_reopen_parse_file_or_backing(reopen_state, true,\n                                            change_child_tran, errp);\n    if (ret < 0) {\n        goto error;\n    }\n    qdict_del(reopen_state->options, \"backing\");\n\n    /* Allow changing the 'file' option. In this case NULL is not allowed */\n    ret = bdrv_reopen_parse_file_or_backing(reopen_state, false,\n                                            change_child_tran, errp);\n    if (ret < 0) {\n        goto error;\n    }\n    qdict_del(reopen_state->options, \"file\");\n\n    /* Options that are not handled are only okay if they are unchanged\n     * compared to the old state. It is expected that some options are only\n     * used for the initial open, but not reopen (e.g. filename) */\n    if (qdict_size(reopen_state->options)) {\n        const QDictEntry *entry = qdict_first(reopen_state->options);\n\n        do {\n            QObject *new = entry->value;\n            QObject *old = qdict_get(reopen_state->bs->options, entry->key);\n\n            /* Allow child references (child_name=node_name) as long as they\n             * point to the current child (i.e. everything stays the same). */\n            if (qobject_type(new) == QTYPE_QSTRING) {\n                BdrvChild *child;\n                QLIST_FOREACH(child, &reopen_state->bs->children, next) {\n                    if (!strcmp(child->name, entry->key)) {\n                        break;\n                    }\n                }\n\n                if (child) {\n                    if (!strcmp(child->bs->node_name,\n                                qstring_get_str(qobject_to(QString, new)))) {\n                        continue; /* Found child with this name, skip option */\n                    }\n                }\n            }\n\n            /*\n             * TODO: When using -drive to specify blockdev options, all values\n             * will be strings; however, when using -blockdev, blockdev-add or\n             * filenames using the json:{} pseudo-protocol, they will be\n             * correctly typed.\n             * In contrast, reopening options are (currently) always strings\n             * (because you can only specify them through qemu-io; all other\n             * callers do not specify any options).\n             * Therefore, when using anything other than -drive to create a BDS,\n             * this cannot detect non-string options as unchanged, because\n             * qobject_is_equal() always returns false for objects of different\n             * type.  In the future, this should be remedied by correctly typing\n             * all options.  For now, this is not too big of an issue because\n             * the user can simply omit options which cannot be changed anyway,\n             * so they will stay unchanged.\n             */\n            if (!qobject_is_equal(new, old)) {\n                error_setg(errp, \"Cannot change the option '%s'\", entry->key);\n                ret = -EINVAL;\n                goto error;\n            }\n        } while ((entry = qdict_next(reopen_state->options, entry)));\n    }\n\n    ret = 0;\n\n    /* Restore the original reopen_state->options QDict */\n    qobject_unref(reopen_state->options);\n    reopen_state->options = qobject_ref(orig_reopen_opts);\n\nerror:\n    if (ret < 0 && drv_prepared) {\n        /* drv->bdrv_reopen_prepare() has succeeded, so we need to\n         * call drv->bdrv_reopen_abort() before signaling an error\n         * (bdrv_reopen_multiple() will not call bdrv_reopen_abort()\n         * when the respective bdrv_reopen_prepare() has failed) */\n        if (drv->bdrv_reopen_abort) {\n            drv->bdrv_reopen_abort(reopen_state);\n        }\n    }\n    qemu_opts_del(opts);\n    qobject_unref(orig_reopen_opts);\n    g_free(discard);\n    return ret;\n}\n\n/*\n * Takes the staged changes for the reopen from bdrv_reopen_prepare(), and\n * makes them final by swapping the staging BlockDriverState contents into\n * the active BlockDriverState contents.\n */\nstatic void bdrv_reopen_commit(BDRVReopenState *reopen_state)\n{\n    BlockDriver *drv;\n    BlockDriverState *bs;\n    BdrvChild *child;\n\n    assert(reopen_state != NULL);\n    bs = reopen_state->bs;\n    drv = bs->drv;\n    assert(drv != NULL);\n    GLOBAL_STATE_CODE();\n\n    /* If there are any driver level actions to take */\n    if (drv->bdrv_reopen_commit) {\n        drv->bdrv_reopen_commit(reopen_state);\n    }\n\n    /* set BDS specific flags now */\n    qobject_unref(bs->explicit_options);\n    qobject_unref(bs->options);\n    qobject_ref(reopen_state->explicit_options);\n    qobject_ref(reopen_state->options);\n\n    bs->explicit_options   = reopen_state->explicit_options;\n    bs->options            = reopen_state->options;\n    bs->open_flags         = reopen_state->flags;\n    bs->detect_zeroes      = reopen_state->detect_zeroes;\n\n    /* Remove child references from bs->options and bs->explicit_options.\n     * Child options were already removed in bdrv_reopen_queue_child() */\n    QLIST_FOREACH(child, &bs->children, next) {\n        qdict_del(bs->explicit_options, child->name);\n        qdict_del(bs->options, child->name);\n    }\n    /* backing is probably removed, so it's not handled by previous loop */\n    qdict_del(bs->explicit_options, \"backing\");\n    qdict_del(bs->options, \"backing\");\n\n    bdrv_refresh_limits(bs, NULL, NULL);\n}\n\n/*\n * Abort the reopen, and delete and free the staged changes in\n * reopen_state\n */\nstatic void bdrv_reopen_abort(BDRVReopenState *reopen_state)\n{\n    BlockDriver *drv;\n\n    assert(reopen_state != NULL);\n    drv = reopen_state->bs->drv;\n    assert(drv != NULL);\n    GLOBAL_STATE_CODE();\n\n    if (drv->bdrv_reopen_abort) {\n        drv->bdrv_reopen_abort(reopen_state);\n    }\n}\n\n\nstatic void bdrv_close(BlockDriverState *bs)\n{\n    BdrvAioNotifier *ban, *ban_next;\n    BdrvChild *child, *next;\n\n    GLOBAL_STATE_CODE();\n    assert(!bs->refcnt);\n\n    bdrv_drained_begin(bs); /* complete I/O */\n    bdrv_flush(bs);\n    bdrv_drain(bs); /* in case flush left pending I/O */\n\n    if (bs->drv) {\n        if (bs->drv->bdrv_close) {\n            /* Must unfreeze all children, so bdrv_unref_child() works */\n            bs->drv->bdrv_close(bs);\n        }\n        bs->drv = NULL;\n    }\n\n    QLIST_FOREACH_SAFE(child, &bs->children, next, next) {\n        bdrv_unref_child(bs, child);\n    }\n\n    bs->backing = NULL;\n    bs->file = NULL;\n    g_free(bs->opaque);\n    bs->opaque = NULL;\n    qatomic_set(&bs->copy_on_read, 0);\n    bs->backing_file[0] = '\\0';\n    bs->backing_format[0] = '\\0';\n    bs->total_sectors = 0;\n    bs->encrypted = false;\n    bs->sg = false;\n    qobject_unref(bs->options);\n    qobject_unref(bs->explicit_options);\n    bs->options = NULL;\n    bs->explicit_options = NULL;\n    qobject_unref(bs->full_open_options);\n    bs->full_open_options = NULL;\n    g_free(bs->block_status_cache);\n    bs->block_status_cache = NULL;\n\n    bdrv_release_named_dirty_bitmaps(bs);\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n        g_free(ban);\n    }\n    QLIST_INIT(&bs->aio_notifiers);\n    bdrv_drained_end(bs);\n\n    /*\n     * If we're still inside some bdrv_drain_all_begin()/end() sections, end\n     * them now since this BDS won't exist anymore when bdrv_drain_all_end()\n     * gets called.\n     */\n    if (bs->quiesce_counter) {\n        bdrv_drain_all_end_quiesce(bs);\n    }\n}\n\nvoid bdrv_close_all(void)\n{\n    assert(job_next(NULL) == NULL);\n    GLOBAL_STATE_CODE();\n\n    /* Drop references from requests still in flight, such as canceled block\n     * jobs whose AIO context has not been polled yet */\n    bdrv_drain_all();\n\n    blk_remove_all_bs();\n    blockdev_close_all_bdrv_states();\n\n    assert(QTAILQ_EMPTY(&all_bdrv_states));\n}\n\nstatic bool should_update_child(BdrvChild *c, BlockDriverState *to)\n{\n    GQueue *queue;\n    GHashTable *found;\n    bool ret;\n\n    if (c->klass->stay_at_node) {\n        return false;\n    }\n\n    /* If the child @c belongs to the BDS @to, replacing the current\n     * c->bs by @to would mean to create a loop.\n     *\n     * Such a case occurs when appending a BDS to a backing chain.\n     * For instance, imagine the following chain:\n     *\n     *   guest device -> node A -> further backing chain...\n     *\n     * Now we create a new BDS B which we want to put on top of this\n     * chain, so we first attach A as its backing node:\n     *\n     *                   node B\n     *                     |\n     *                     v\n     *   guest device -> node A -> further backing chain...\n     *\n     * Finally we want to replace A by B.  When doing that, we want to\n     * replace all pointers to A by pointers to B -- except for the\n     * pointer from B because (1) that would create a loop, and (2)\n     * that pointer should simply stay intact:\n     *\n     *   guest device -> node B\n     *                     |\n     *                     v\n     *                   node A -> further backing chain...\n     *\n     * In general, when replacing a node A (c->bs) by a node B (@to),\n     * if A is a child of B, that means we cannot replace A by B there\n     * because that would create a loop.  Silently detaching A from B\n     * is also not really an option.  So overall just leaving A in\n     * place there is the most sensible choice.\n     *\n     * We would also create a loop in any cases where @c is only\n     * indirectly referenced by @to. Prevent this by returning false\n     * if @c is found (by breadth-first search) anywhere in the whole\n     * subtree of @to.\n     */\n\n    ret = true;\n    found = g_hash_table_new(NULL, NULL);\n    g_hash_table_add(found, to);\n    queue = g_queue_new();\n    g_queue_push_tail(queue, to);\n\n    while (!g_queue_is_empty(queue)) {\n        BlockDriverState *v = g_queue_pop_head(queue);\n        BdrvChild *c2;\n\n        QLIST_FOREACH(c2, &v->children, next) {\n            if (c2 == c) {\n                ret = false;\n                break;\n            }\n\n            if (g_hash_table_contains(found, c2->bs)) {\n                continue;\n            }\n\n            g_queue_push_tail(queue, c2->bs);\n            g_hash_table_add(found, c2->bs);\n        }\n    }\n\n    g_queue_free(queue);\n    g_hash_table_destroy(found);\n\n    return ret;\n}\n\ntypedef struct BdrvRemoveFilterOrCowChild {\n    BdrvChild *child;\n    BlockDriverState *bs;\n    bool is_backing;\n} BdrvRemoveFilterOrCowChild;\n\nstatic void bdrv_remove_filter_or_cow_child_abort(void *opaque)\n{\n    BdrvRemoveFilterOrCowChild *s = opaque;\n    BlockDriverState *parent_bs = s->child->opaque;\n\n    if (s->is_backing) {\n        parent_bs->backing = s->child;\n    } else {\n        parent_bs->file = s->child;\n    }\n\n    /*\n     * We don't have to restore child->bs here to undo bdrv_replace_child_tran()\n     * because that function is transactionable and it registered own completion\n     * entries in @tran, so .abort() for bdrv_replace_child_safe() will be\n     * called automatically.\n     */\n}\n\nstatic void bdrv_remove_filter_or_cow_child_commit(void *opaque)\n{\n    BdrvRemoveFilterOrCowChild *s = opaque;\n    GLOBAL_STATE_CODE();\n    bdrv_child_free(s->child);\n}\n\nstatic void bdrv_remove_filter_or_cow_child_clean(void *opaque)\n{\n    BdrvRemoveFilterOrCowChild *s = opaque;\n\n    /* Drop the bs reference after the transaction is done */\n    bdrv_unref(s->bs);\n    g_free(s);\n}\n\nstatic TransactionActionDrv bdrv_remove_filter_or_cow_child_drv = {\n    .abort = bdrv_remove_filter_or_cow_child_abort,\n    .commit = bdrv_remove_filter_or_cow_child_commit,\n    .clean = bdrv_remove_filter_or_cow_child_clean,\n};\n\n/*\n * A function to remove backing or file child of @bs.\n * Function doesn't update permissions, caller is responsible for this.\n */\nstatic void bdrv_remove_file_or_backing_child(BlockDriverState *bs,\n                                              BdrvChild *child,\n                                              Transaction *tran)\n{\n    BdrvChild **childp;\n    BdrvRemoveFilterOrCowChild *s;\n\n    if (!child) {\n        return;\n    }\n\n    /*\n     * Keep a reference to @bs so @childp will stay valid throughout the\n     * transaction (required by bdrv_replace_child_tran())\n     */\n    bdrv_ref(bs);\n    if (child == bs->backing) {\n        childp = &bs->backing;\n    } else if (child == bs->file) {\n        childp = &bs->file;\n    } else {\n        g_assert_not_reached();\n    }\n\n    if (child->bs) {\n        /*\n         * Pass free_empty_child=false, we will free the child in\n         * bdrv_remove_filter_or_cow_child_commit()\n         */\n        bdrv_replace_child_tran(childp, NULL, tran, false);\n    }\n\n    s = g_new(BdrvRemoveFilterOrCowChild, 1);\n    *s = (BdrvRemoveFilterOrCowChild) {\n        .child = child,\n        .bs = bs,\n        .is_backing = (childp == &bs->backing),\n    };\n    tran_add(tran, &bdrv_remove_filter_or_cow_child_drv, s);\n}\n\n/*\n * A function to remove backing-chain child of @bs if exists: cow child for\n * format nodes (always .backing) and filter child for filters (may be .file or\n * .backing)\n */\nstatic void bdrv_remove_filter_or_cow_child(BlockDriverState *bs,\n                                            Transaction *tran)\n{\n    bdrv_remove_file_or_backing_child(bs, bdrv_filter_or_cow_child(bs), tran);\n}\n\nstatic int bdrv_replace_node_noperm(BlockDriverState *from,\n                                    BlockDriverState *to,\n                                    bool auto_skip, Transaction *tran,\n                                    Error **errp)\n{\n    BdrvChild *c, *next;\n\n    assert(to != NULL);\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH_SAFE(c, &from->parents, next_parent, next) {\n        assert(c->bs == from);\n        if (!should_update_child(c, to)) {\n            if (auto_skip) {\n                continue;\n            }\n            error_setg(errp, \"Should not change '%s' link to '%s'\",\n                       c->name, from->node_name);\n            return -EINVAL;\n        }\n        if (c->frozen) {\n            error_setg(errp, \"Cannot change '%s' link to '%s'\",\n                       c->name, from->node_name);\n            return -EPERM;\n        }\n\n        /*\n         * Passing a pointer to the local variable @c is fine here, because\n         * @to is not NULL, and so &c will not be attached to the transaction.\n         */\n        bdrv_replace_child_tran(&c, to, tran, true);\n    }\n\n    return 0;\n}\n\n/*\n * With auto_skip=true bdrv_replace_node_common skips updating from parents\n * if it creates a parent-child relation loop or if parent is block-job.\n *\n * With auto_skip=false the error is returned if from has a parent which should\n * not be updated.\n *\n * With @detach_subchain=true @to must be in a backing chain of @from. In this\n * case backing link of the cow-parent of @to is removed.\n *\n * @to must not be NULL.\n */\nstatic int bdrv_replace_node_common(BlockDriverState *from,\n                                    BlockDriverState *to,\n                                    bool auto_skip, bool detach_subchain,\n                                    Error **errp)\n{\n    Transaction *tran = tran_new();\n    g_autoptr(GHashTable) found = NULL;\n    g_autoptr(GSList) refresh_list = NULL;\n    BlockDriverState *to_cow_parent = NULL;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n    assert(to != NULL);\n\n    if (detach_subchain) {\n        assert(bdrv_chain_contains(from, to));\n        assert(from != to);\n        for (to_cow_parent = from;\n             bdrv_filter_or_cow_bs(to_cow_parent) != to;\n             to_cow_parent = bdrv_filter_or_cow_bs(to_cow_parent))\n        {\n            ;\n        }\n    }\n\n    /* Make sure that @from doesn't go away until we have successfully attached\n     * all of its parents to @to. */\n    bdrv_ref(from);\n\n    assert(qemu_get_current_aio_context() == qemu_get_aio_context());\n    assert(bdrv_get_aio_context(from) == bdrv_get_aio_context(to));\n    bdrv_drained_begin(from);\n\n    /*\n     * Do the replacement without permission update.\n     * Replacement may influence the permissions, we should calculate new\n     * permissions based on new graph. If we fail, we'll roll-back the\n     * replacement.\n     */\n    ret = bdrv_replace_node_noperm(from, to, auto_skip, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    if (detach_subchain) {\n        bdrv_remove_filter_or_cow_child(to_cow_parent, tran);\n    }\n\n    found = g_hash_table_new(NULL, NULL);\n\n    refresh_list = bdrv_topological_dfs(refresh_list, found, to);\n    refresh_list = bdrv_topological_dfs(refresh_list, found, from);\n\n    ret = bdrv_list_refresh_perms(refresh_list, NULL, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = 0;\n\nout:\n    tran_finalize(tran, ret);\n\n    bdrv_drained_end(from);\n    bdrv_unref(from);\n\n    return ret;\n}\n\n/**\n * Replace node @from by @to (where neither may be NULL).\n */\nint bdrv_replace_node(BlockDriverState *from, BlockDriverState *to,\n                      Error **errp)\n{\n    GLOBAL_STATE_CODE();\n\n    return bdrv_replace_node_common(from, to, true, false, errp);\n}\n\nint bdrv_drop_filter(BlockDriverState *bs, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n\n    return bdrv_replace_node_common(bs, bdrv_filter_or_cow_bs(bs), true, true,\n                                    errp);\n}\n\n/*\n * Add new bs contents at the top of an image chain while the chain is\n * live, while keeping required fields on the top layer.\n *\n * This will modify the BlockDriverState fields, and swap contents\n * between bs_new and bs_top. Both bs_new and bs_top are modified.\n *\n * bs_new must not be attached to a BlockBackend and must not have backing\n * child.\n *\n * This function does not create any image files.\n */\nint bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top,\n                Error **errp)\n{\n    int ret;\n    Transaction *tran = tran_new();\n\n    GLOBAL_STATE_CODE();\n\n    assert(!bs_new->backing);\n\n    ret = bdrv_attach_child_noperm(bs_new, bs_top, \"backing\",\n                                   &child_of_bds, bdrv_backing_role(bs_new),\n                                   &bs_new->backing, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = bdrv_replace_node_noperm(bs_top, bs_new, true, tran, errp);\n    if (ret < 0) {\n        goto out;\n    }\n\n    ret = bdrv_refresh_perms(bs_new, errp);\nout:\n    tran_finalize(tran, ret);\n\n    bdrv_refresh_limits(bs_top, NULL, NULL);\n\n    return ret;\n}\n\n/* Not for empty child */\nint bdrv_replace_child_bs(BdrvChild *child, BlockDriverState *new_bs,\n                          Error **errp)\n{\n    int ret;\n    Transaction *tran = tran_new();\n    g_autoptr(GHashTable) found = NULL;\n    g_autoptr(GSList) refresh_list = NULL;\n    BlockDriverState *old_bs = child->bs;\n\n    GLOBAL_STATE_CODE();\n\n    bdrv_ref(old_bs);\n    bdrv_drained_begin(old_bs);\n    bdrv_drained_begin(new_bs);\n\n    bdrv_replace_child_tran(&child, new_bs, tran, true);\n    /* @new_bs must have been non-NULL, so @child must not have been freed */\n    assert(child != NULL);\n\n    found = g_hash_table_new(NULL, NULL);\n    refresh_list = bdrv_topological_dfs(refresh_list, found, old_bs);\n    refresh_list = bdrv_topological_dfs(refresh_list, found, new_bs);\n\n    ret = bdrv_list_refresh_perms(refresh_list, NULL, tran, errp);\n\n    tran_finalize(tran, ret);\n\n    bdrv_drained_end(old_bs);\n    bdrv_drained_end(new_bs);\n    bdrv_unref(old_bs);\n\n    return ret;\n}\n\nstatic void bdrv_delete(BlockDriverState *bs)\n{\n    assert(bdrv_op_blocker_is_empty(bs));\n    assert(!bs->refcnt);\n    GLOBAL_STATE_CODE();\n\n    /* remove from list, if necessary */\n    if (bs->node_name[0] != '\\0') {\n        QTAILQ_REMOVE(&graph_bdrv_states, bs, node_list);\n    }\n    QTAILQ_REMOVE(&all_bdrv_states, bs, bs_list);\n\n    bdrv_close(bs);\n\n    g_free(bs);\n}\n\n\n/*\n * Replace @bs by newly created block node.\n *\n * @options is a QDict of options to pass to the block drivers, or NULL for an\n * empty set of options. The reference to the QDict belongs to the block layer\n * after the call (even on failure), so if the caller intends to reuse the\n * dictionary, it needs to use qobject_ref() before calling bdrv_open.\n */\nBlockDriverState *bdrv_insert_node(BlockDriverState *bs, QDict *options,\n                                   int flags, Error **errp)\n{\n    ERRP_GUARD();\n    int ret;\n    BlockDriverState *new_node_bs = NULL;\n    const char *drvname, *node_name;\n    BlockDriver *drv;\n\n    drvname = qdict_get_try_str(options, \"driver\");\n    if (!drvname) {\n        error_setg(errp, \"driver is not specified\");\n        goto fail;\n    }\n\n    drv = bdrv_find_format(drvname);\n    if (!drv) {\n        error_setg(errp, \"Unknown driver: '%s'\", drvname);\n        goto fail;\n    }\n\n    node_name = qdict_get_try_str(options, \"node-name\");\n\n    GLOBAL_STATE_CODE();\n\n    new_node_bs = bdrv_new_open_driver_opts(drv, node_name, options, flags,\n                                            errp);\n    options = NULL; /* bdrv_new_open_driver() eats options */\n    if (!new_node_bs) {\n        error_prepend(errp, \"Could not create node: \");\n        goto fail;\n    }\n\n    bdrv_drained_begin(bs);\n    ret = bdrv_replace_node(bs, new_node_bs, errp);\n    bdrv_drained_end(bs);\n\n    if (ret < 0) {\n        error_prepend(errp, \"Could not replace node: \");\n        goto fail;\n    }\n\n    return new_node_bs;\n\nfail:\n    qobject_unref(options);\n    bdrv_unref(new_node_bs);\n    return NULL;\n}\n\n/*\n * Run consistency checks on an image\n *\n * Returns 0 if the check could be completed (it doesn't mean that the image is\n * free of errors) or -errno when an internal error occurred. The results of the\n * check are stored in res.\n */\nint coroutine_fn bdrv_co_check(BlockDriverState *bs,\n                               BdrvCheckResult *res, BdrvCheckMode fix)\n{\n    IO_CODE();\n    if (bs->drv == NULL) {\n        return -ENOMEDIUM;\n    }\n    if (bs->drv->bdrv_co_check == NULL) {\n        return -ENOTSUP;\n    }\n\n    memset(res, 0, sizeof(*res));\n    return bs->drv->bdrv_co_check(bs, res, fix);\n}\n\n/*\n * Return values:\n * 0        - success\n * -EINVAL  - backing format specified, but no file\n * -ENOSPC  - can't update the backing file because no space is left in the\n *            image file header\n * -ENOTSUP - format driver doesn't support changing the backing file\n */\nint bdrv_change_backing_file(BlockDriverState *bs, const char *backing_file,\n                             const char *backing_fmt, bool require)\n{\n    BlockDriver *drv = bs->drv;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n\n    if (!drv) {\n        return -ENOMEDIUM;\n    }\n\n    /* Backing file format doesn't make sense without a backing file */\n    if (backing_fmt && !backing_file) {\n        return -EINVAL;\n    }\n\n    if (require && backing_file && !backing_fmt) {\n        return -EINVAL;\n    }\n\n    if (drv->bdrv_change_backing_file != NULL) {\n        ret = drv->bdrv_change_backing_file(bs, backing_file, backing_fmt);\n    } else {\n        ret = -ENOTSUP;\n    }\n\n    if (ret == 0) {\n        pstrcpy(bs->backing_file, sizeof(bs->backing_file), backing_file ?: \"\");\n        pstrcpy(bs->backing_format, sizeof(bs->backing_format), backing_fmt ?: \"\");\n        pstrcpy(bs->auto_backing_file, sizeof(bs->auto_backing_file),\n                backing_file ?: \"\");\n    }\n    return ret;\n}\n\n/*\n * Finds the first non-filter node above bs in the chain between\n * active and bs.  The returned node is either an immediate parent of\n * bs, or there are only filter nodes between the two.\n *\n * Returns NULL if bs is not found in active's image chain,\n * or if active == bs.\n *\n * Returns the bottommost base image if bs == NULL.\n */\nBlockDriverState *bdrv_find_overlay(BlockDriverState *active,\n                                    BlockDriverState *bs)\n{\n\n    GLOBAL_STATE_CODE();\n\n    bs = bdrv_skip_filters(bs);\n    active = bdrv_skip_filters(active);\n\n    while (active) {\n        BlockDriverState *next = bdrv_backing_chain_next(active);\n        if (bs == next) {\n            return active;\n        }\n        active = next;\n    }\n\n    return NULL;\n}\n\n/* Given a BDS, searches for the base layer. */\nBlockDriverState *bdrv_find_base(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n\n    return bdrv_find_overlay(bs, NULL);\n}\n\n/*\n * Return true if at least one of the COW (backing) and filter links\n * between @bs and @base is frozen. @errp is set if that's the case.\n * @base must be reachable from @bs, or NULL.\n */\nbool bdrv_is_backing_chain_frozen(BlockDriverState *bs, BlockDriverState *base,\n                                  Error **errp)\n{\n    BlockDriverState *i;\n    BdrvChild *child;\n\n    GLOBAL_STATE_CODE();\n\n    for (i = bs; i != base; i = child_bs(child)) {\n        child = bdrv_filter_or_cow_child(i);\n\n        if (child && child->frozen) {\n            error_setg(errp, \"Cannot change '%s' link from '%s' to '%s'\",\n                       child->name, i->node_name, child->bs->node_name);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*\n * Freeze all COW (backing) and filter links between @bs and @base.\n * If any of the links is already frozen the operation is aborted and\n * none of the links are modified.\n * @base must be reachable from @bs, or NULL.\n * Returns 0 on success. On failure returns < 0 and sets @errp.\n */\nint bdrv_freeze_backing_chain(BlockDriverState *bs, BlockDriverState *base,\n                              Error **errp)\n{\n    BlockDriverState *i;\n    BdrvChild *child;\n\n    GLOBAL_STATE_CODE();\n\n    if (bdrv_is_backing_chain_frozen(bs, base, errp)) {\n        return -EPERM;\n    }\n\n    for (i = bs; i != base; i = child_bs(child)) {\n        child = bdrv_filter_or_cow_child(i);\n        if (child && child->bs->never_freeze) {\n            error_setg(errp, \"Cannot freeze '%s' link to '%s'\",\n                       child->name, child->bs->node_name);\n            return -EPERM;\n        }\n    }\n\n    for (i = bs; i != base; i = child_bs(child)) {\n        child = bdrv_filter_or_cow_child(i);\n        if (child) {\n            child->frozen = true;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Unfreeze all COW (backing) and filter links between @bs and @base.\n * The caller must ensure that all links are frozen before using this\n * function.\n * @base must be reachable from @bs, or NULL.\n */\nvoid bdrv_unfreeze_backing_chain(BlockDriverState *bs, BlockDriverState *base)\n{\n    BlockDriverState *i;\n    BdrvChild *child;\n\n    GLOBAL_STATE_CODE();\n\n    for (i = bs; i != base; i = child_bs(child)) {\n        child = bdrv_filter_or_cow_child(i);\n        if (child) {\n            assert(child->frozen);\n            child->frozen = false;\n        }\n    }\n}\n\n/*\n * Drops images above 'base' up to and including 'top', and sets the image\n * above 'top' to have base as its backing file.\n *\n * Requires that the overlay to 'top' is opened r/w, so that the backing file\n * information in 'bs' can be properly updated.\n *\n * E.g., this will convert the following chain:\n * bottom <- base <- intermediate <- top <- active\n *\n * to\n *\n * bottom <- base <- active\n *\n * It is allowed for bottom==base, in which case it converts:\n *\n * base <- intermediate <- top <- active\n *\n * to\n *\n * base <- active\n *\n * If backing_file_str is non-NULL, it will be used when modifying top's\n * overlay image metadata.\n *\n * Error conditions:\n *  if active == top, that is considered an error\n *\n */\nint bdrv_drop_intermediate(BlockDriverState *top, BlockDriverState *base,\n                           const char *backing_file_str)\n{\n    BlockDriverState *explicit_top = top;\n    bool update_inherits_from;\n    BdrvChild *c;\n    Error *local_err = NULL;\n    int ret = -EIO;\n    g_autoptr(GSList) updated_children = NULL;\n    GSList *p;\n\n    GLOBAL_STATE_CODE();\n\n    bdrv_ref(top);\n    bdrv_subtree_drained_begin(top);\n\n    if (!top->drv || !base->drv) {\n        goto exit;\n    }\n\n    /* Make sure that base is in the backing chain of top */\n    if (!bdrv_chain_contains(top, base)) {\n        goto exit;\n    }\n\n    /* If 'base' recursively inherits from 'top' then we should set\n     * base->inherits_from to top->inherits_from after 'top' and all\n     * other intermediate nodes have been dropped.\n     * If 'top' is an implicit node (e.g. \"commit_top\") we should skip\n     * it because no one inherits from it. We use explicit_top for that. */\n    explicit_top = bdrv_skip_implicit_filters(explicit_top);\n    update_inherits_from = bdrv_inherits_from_recursive(base, explicit_top);\n\n    /* success - we can delete the intermediate states, and link top->base */\n    if (!backing_file_str) {\n        bdrv_refresh_filename(base);\n        backing_file_str = base->filename;\n    }\n\n    QLIST_FOREACH(c, &top->parents, next_parent) {\n        updated_children = g_slist_prepend(updated_children, c);\n    }\n\n    /*\n     * It seems correct to pass detach_subchain=true here, but it triggers\n     * one more yet not fixed bug, when due to nested aio_poll loop we switch to\n     * another drained section, which modify the graph (for example, removing\n     * the child, which we keep in updated_children list). So, it's a TODO.\n     *\n     * Note, bug triggered if pass detach_subchain=true here and run\n     * test-bdrv-drain. test_drop_intermediate_poll() test-case will crash.\n     * That's a FIXME.\n     */\n    bdrv_replace_node_common(top, base, false, false, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        goto exit;\n    }\n\n    for (p = updated_children; p; p = p->next) {\n        c = p->data;\n\n        if (c->klass->update_filename) {\n            ret = c->klass->update_filename(c, base, backing_file_str,\n                                            &local_err);\n            if (ret < 0) {\n                /*\n                 * TODO: Actually, we want to rollback all previous iterations\n                 * of this loop, and (which is almost impossible) previous\n                 * bdrv_replace_node()...\n                 *\n                 * Note, that c->klass->update_filename may lead to permission\n                 * update, so it's a bad idea to call it inside permission\n                 * update transaction of bdrv_replace_node.\n                 */\n                error_report_err(local_err);\n                goto exit;\n            }\n        }\n    }\n\n    if (update_inherits_from) {\n        base->inherits_from = explicit_top->inherits_from;\n    }\n\n    ret = 0;\nexit:\n    bdrv_subtree_drained_end(top);\n    bdrv_unref(top);\n    return ret;\n}\n\n/**\n * Implementation of BlockDriver.bdrv_get_allocated_file_size() that\n * sums the size of all data-bearing children.  (This excludes backing\n * children.)\n */\nstatic int64_t bdrv_sum_allocated_file_size(BlockDriverState *bs)\n{\n    BdrvChild *child;\n    int64_t child_size, sum = 0;\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        if (child->role & (BDRV_CHILD_DATA | BDRV_CHILD_METADATA |\n                           BDRV_CHILD_FILTERED))\n        {\n            child_size = bdrv_get_allocated_file_size(child->bs);\n            if (child_size < 0) {\n                return child_size;\n            }\n            sum += child_size;\n        }\n    }\n\n    return sum;\n}\n\n/**\n * Length of a allocated file in bytes. Sparse files are counted by actual\n * allocated space. Return < 0 if error or unknown.\n */\nint64_t bdrv_get_allocated_file_size(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n\n    if (!drv) {\n        return -ENOMEDIUM;\n    }\n    if (drv->bdrv_get_allocated_file_size) {\n        return drv->bdrv_get_allocated_file_size(bs);\n    }\n\n    if (drv->bdrv_file_open) {\n        /*\n         * Protocol drivers default to -ENOTSUP (most of their data is\n         * not stored in any of their children (if they even have any),\n         * so there is no generic way to figure it out).\n         */\n        return -ENOTSUP;\n    } else if (drv->is_filter) {\n        /* Filter drivers default to the size of their filtered child */\n        return bdrv_get_allocated_file_size(bdrv_filter_bs(bs));\n    } else {\n        /* Other drivers default to summing their children's sizes */\n        return bdrv_sum_allocated_file_size(bs);\n    }\n}\n\n/*\n * bdrv_measure:\n * @drv: Format driver\n * @opts: Creation options for new image\n * @in_bs: Existing image containing data for new image (may be NULL)\n * @errp: Error object\n * Returns: A #BlockMeasureInfo (free using qapi_free_BlockMeasureInfo())\n *          or NULL on error\n *\n * Calculate file size required to create a new image.\n *\n * If @in_bs is given then space for allocated clusters and zero clusters\n * from that image are included in the calculation.  If @opts contains a\n * backing file that is shared by @in_bs then backing clusters may be omitted\n * from the calculation.\n *\n * If @in_bs is NULL then the calculation includes no allocated clusters\n * unless a preallocation option is given in @opts.\n *\n * Note that @in_bs may use a different BlockDriver from @drv.\n *\n * If an error occurs the @errp pointer is set.\n */\nBlockMeasureInfo *bdrv_measure(BlockDriver *drv, QemuOpts *opts,\n                               BlockDriverState *in_bs, Error **errp)\n{\n    IO_CODE();\n    if (!drv->bdrv_measure) {\n        error_setg(errp, \"Block driver '%s' does not support size measurement\",\n                   drv->format_name);\n        return NULL;\n    }\n\n    return drv->bdrv_measure(opts, in_bs, errp);\n}\n\n/**\n * Return number of sectors on success, -errno on error.\n */\nint64_t bdrv_nb_sectors(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n\n    if (!drv)\n        return -ENOMEDIUM;\n\n    if (drv->has_variable_length) {\n        int ret = refresh_total_sectors(bs, bs->total_sectors);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n    return bs->total_sectors;\n}\n\n/**\n * Return length in bytes on success, -errno on error.\n * The length is always a multiple of BDRV_SECTOR_SIZE.\n */\nint64_t bdrv_getlength(BlockDriverState *bs)\n{\n    int64_t ret = bdrv_nb_sectors(bs);\n    IO_CODE();\n\n    if (ret < 0) {\n        return ret;\n    }\n    if (ret > INT64_MAX / BDRV_SECTOR_SIZE) {\n        return -EFBIG;\n    }\n    return ret * BDRV_SECTOR_SIZE;\n}\n\n/* return 0 as number of sectors if no device present or error */\nvoid bdrv_get_geometry(BlockDriverState *bs, uint64_t *nb_sectors_ptr)\n{\n    int64_t nb_sectors = bdrv_nb_sectors(bs);\n    IO_CODE();\n\n    *nb_sectors_ptr = nb_sectors < 0 ? 0 : nb_sectors;\n}\n\nbool bdrv_is_sg(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bs->sg;\n}\n\n/**\n * Return whether the given node supports compressed writes.\n */\nbool bdrv_supports_compressed_writes(BlockDriverState *bs)\n{\n    BlockDriverState *filtered;\n    IO_CODE();\n\n    if (!bs->drv || !block_driver_can_compress(bs->drv)) {\n        return false;\n    }\n\n    filtered = bdrv_filter_bs(bs);\n    if (filtered) {\n        /*\n         * Filters can only forward compressed writes, so we have to\n         * check the child.\n         */\n        return bdrv_supports_compressed_writes(filtered);\n    }\n\n    return true;\n}\n\nconst char *bdrv_get_format_name(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bs->drv ? bs->drv->format_name : NULL;\n}\n\nstatic int qsort_strcmp(const void *a, const void *b)\n{\n    return strcmp(*(char *const *)a, *(char *const *)b);\n}\n\nvoid bdrv_iterate_format(void (*it)(void *opaque, const char *name),\n                         void *opaque, bool read_only)\n{\n    BlockDriver *drv;\n    int count = 0;\n    int i;\n    const char **formats = NULL;\n\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(drv, &bdrv_drivers, list) {\n        if (drv->format_name) {\n            bool found = false;\n            int i = count;\n\n            if (use_bdrv_whitelist && !bdrv_is_whitelisted(drv, read_only)) {\n                continue;\n            }\n\n            while (formats && i && !found) {\n                found = !strcmp(formats[--i], drv->format_name);\n            }\n\n            if (!found) {\n                formats = g_renew(const char *, formats, count + 1);\n                formats[count++] = drv->format_name;\n            }\n        }\n    }\n\n    for (i = 0; i < (int)ARRAY_SIZE(block_driver_modules); i++) {\n        const char *format_name = block_driver_modules[i].format_name;\n\n        if (format_name) {\n            bool found = false;\n            int j = count;\n\n            if (use_bdrv_whitelist &&\n                !bdrv_format_is_whitelisted(format_name, read_only)) {\n                continue;\n            }\n\n            while (formats && j && !found) {\n                found = !strcmp(formats[--j], format_name);\n            }\n\n            if (!found) {\n                formats = g_renew(const char *, formats, count + 1);\n                formats[count++] = format_name;\n            }\n        }\n    }\n\n    qsort(formats, count, sizeof(formats[0]), qsort_strcmp);\n\n    for (i = 0; i < count; i++) {\n        it(opaque, formats[i]);\n    }\n\n    g_free(formats);\n}\n\n/* This function is to find a node in the bs graph */\nBlockDriverState *bdrv_find_node(const char *node_name)\n{\n    BlockDriverState *bs;\n\n    assert(node_name);\n    GLOBAL_STATE_CODE();\n\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n        if (!strcmp(node_name, bs->node_name)) {\n            return bs;\n        }\n    }\n    return NULL;\n}\n\n/* Put this QMP function here so it can access the static graph_bdrv_states. */\nBlockDeviceInfoList *bdrv_named_nodes_list(bool flat,\n                                           Error **errp)\n{\n    BlockDeviceInfoList *list;\n    BlockDriverState *bs;\n\n    GLOBAL_STATE_CODE();\n\n    list = NULL;\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n        BlockDeviceInfo *info = bdrv_block_device_info(NULL, bs, flat, errp);\n        if (!info) {\n            qapi_free_BlockDeviceInfoList(list);\n            return NULL;\n        }\n        QAPI_LIST_PREPEND(list, info);\n    }\n\n    return list;\n}\n\ntypedef struct XDbgBlockGraphConstructor {\n    XDbgBlockGraph *graph;\n    GHashTable *graph_nodes;\n} XDbgBlockGraphConstructor;\n\nstatic XDbgBlockGraphConstructor *xdbg_graph_new(void)\n{\n    XDbgBlockGraphConstructor *gr = g_new(XDbgBlockGraphConstructor, 1);\n\n    gr->graph = g_new0(XDbgBlockGraph, 1);\n    gr->graph_nodes = g_hash_table_new(NULL, NULL);\n\n    return gr;\n}\n\nstatic XDbgBlockGraph *xdbg_graph_finalize(XDbgBlockGraphConstructor *gr)\n{\n    XDbgBlockGraph *graph = gr->graph;\n\n    g_hash_table_destroy(gr->graph_nodes);\n    g_free(gr);\n\n    return graph;\n}\n\nstatic uintptr_t xdbg_graph_node_num(XDbgBlockGraphConstructor *gr, void *node)\n{\n    uintptr_t ret = (uintptr_t)g_hash_table_lookup(gr->graph_nodes, node);\n\n    if (ret != 0) {\n        return ret;\n    }\n\n    /*\n     * Start counting from 1, not 0, because 0 interferes with not-found (NULL)\n     * answer of g_hash_table_lookup.\n     */\n    ret = g_hash_table_size(gr->graph_nodes) + 1;\n    g_hash_table_insert(gr->graph_nodes, node, (void *)ret);\n\n    return ret;\n}\n\nstatic void xdbg_graph_add_node(XDbgBlockGraphConstructor *gr, void *node,\n                                XDbgBlockGraphNodeType type, const char *name)\n{\n    XDbgBlockGraphNode *n;\n\n    n = g_new0(XDbgBlockGraphNode, 1);\n\n    n->id = xdbg_graph_node_num(gr, node);\n    n->type = type;\n    n->name = g_strdup(name);\n\n    QAPI_LIST_PREPEND(gr->graph->nodes, n);\n}\n\nstatic void xdbg_graph_add_edge(XDbgBlockGraphConstructor *gr, void *parent,\n                                const BdrvChild *child)\n{\n    BlockPermission qapi_perm;\n    XDbgBlockGraphEdge *edge;\n    GLOBAL_STATE_CODE();\n\n    edge = g_new0(XDbgBlockGraphEdge, 1);\n\n    edge->parent = xdbg_graph_node_num(gr, parent);\n    edge->child = xdbg_graph_node_num(gr, child->bs);\n    edge->name = g_strdup(child->name);\n\n    for (qapi_perm = 0; qapi_perm < BLOCK_PERMISSION__MAX; qapi_perm++) {\n        uint64_t flag = bdrv_qapi_perm_to_blk_perm(qapi_perm);\n\n        if (flag & child->perm) {\n            QAPI_LIST_PREPEND(edge->perm, qapi_perm);\n        }\n        if (flag & child->shared_perm) {\n            QAPI_LIST_PREPEND(edge->shared_perm, qapi_perm);\n        }\n    }\n\n    QAPI_LIST_PREPEND(gr->graph->edges, edge);\n}\n\n\nXDbgBlockGraph *bdrv_get_xdbg_block_graph(Error **errp)\n{\n    BlockBackend *blk;\n    BlockJob *job;\n    BlockDriverState *bs;\n    BdrvChild *child;\n    XDbgBlockGraphConstructor *gr = xdbg_graph_new();\n\n    GLOBAL_STATE_CODE();\n\n    for (blk = blk_all_next(NULL); blk; blk = blk_all_next(blk)) {\n        char *allocated_name = NULL;\n        const char *name = blk_name(blk);\n\n        if (!*name) {\n            name = allocated_name = blk_get_attached_dev_id(blk);\n        }\n        xdbg_graph_add_node(gr, blk, X_DBG_BLOCK_GRAPH_NODE_TYPE_BLOCK_BACKEND,\n                           name);\n        g_free(allocated_name);\n        if (blk_root(blk)) {\n            xdbg_graph_add_edge(gr, blk, blk_root(blk));\n        }\n    }\n\n    for (job = block_job_next(NULL); job; job = block_job_next(job)) {\n        GSList *el;\n\n        xdbg_graph_add_node(gr, job, X_DBG_BLOCK_GRAPH_NODE_TYPE_BLOCK_JOB,\n                           job->job.id);\n        for (el = job->nodes; el; el = el->next) {\n            xdbg_graph_add_edge(gr, job, (BdrvChild *)el->data);\n        }\n    }\n\n    QTAILQ_FOREACH(bs, &graph_bdrv_states, node_list) {\n        xdbg_graph_add_node(gr, bs, X_DBG_BLOCK_GRAPH_NODE_TYPE_BLOCK_DRIVER,\n                           bs->node_name);\n        QLIST_FOREACH(child, &bs->children, next) {\n            xdbg_graph_add_edge(gr, bs, child);\n        }\n    }\n\n    return xdbg_graph_finalize(gr);\n}\n\nBlockDriverState *bdrv_lookup_bs(const char *device,\n                                 const char *node_name,\n                                 Error **errp)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n\n    GLOBAL_STATE_CODE();\n\n    if (device) {\n        blk = blk_by_name(device);\n\n        if (blk) {\n            bs = blk_bs(blk);\n            if (!bs) {\n                error_setg(errp, \"Device '%s' has no medium\", device);\n            }\n\n            return bs;\n        }\n    }\n\n    if (node_name) {\n        bs = bdrv_find_node(node_name);\n\n        if (bs) {\n            return bs;\n        }\n    }\n\n    error_setg(errp, \"Cannot find device=\\'%s\\' nor node-name=\\'%s\\'\",\n                     device ? device : \"\",\n                     node_name ? node_name : \"\");\n    return NULL;\n}\n\n/* If 'base' is in the same chain as 'top', return true. Otherwise,\n * return false.  If either argument is NULL, return false. */\nbool bdrv_chain_contains(BlockDriverState *top, BlockDriverState *base)\n{\n\n    GLOBAL_STATE_CODE();\n\n    while (top && top != base) {\n        top = bdrv_filter_or_cow_bs(top);\n    }\n\n    return top != NULL;\n}\n\nBlockDriverState *bdrv_next_node(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    if (!bs) {\n        return QTAILQ_FIRST(&graph_bdrv_states);\n    }\n    return QTAILQ_NEXT(bs, node_list);\n}\n\nBlockDriverState *bdrv_next_all_states(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    if (!bs) {\n        return QTAILQ_FIRST(&all_bdrv_states);\n    }\n    return QTAILQ_NEXT(bs, bs_list);\n}\n\nconst char *bdrv_get_node_name(const BlockDriverState *bs)\n{\n    IO_CODE();\n    return bs->node_name;\n}\n\nconst char *bdrv_get_parent_name(const BlockDriverState *bs)\n{\n    BdrvChild *c;\n    const char *name;\n    IO_CODE();\n\n    /* If multiple parents have a name, just pick the first one. */\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (c->klass->get_name) {\n            name = c->klass->get_name(c);\n            if (name && *name) {\n                return name;\n            }\n        }\n    }\n\n    return NULL;\n}\n\n/* TODO check what callers really want: bs->node_name or blk_name() */\nconst char *bdrv_get_device_name(const BlockDriverState *bs)\n{\n    IO_CODE();\n    return bdrv_get_parent_name(bs) ?: \"\";\n}\n\n/* This can be used to identify nodes that might not have a device\n * name associated. Since node and device names live in the same\n * namespace, the result is unambiguous. The exception is if both are\n * absent, then this returns an empty (non-null) string. */\nconst char *bdrv_get_device_or_node_name(const BlockDriverState *bs)\n{\n    IO_CODE();\n    return bdrv_get_parent_name(bs) ?: bs->node_name;\n}\n\nint bdrv_get_flags(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bs->open_flags;\n}\n\nint bdrv_has_zero_init_1(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    return 1;\n}\n\nint bdrv_has_zero_init(BlockDriverState *bs)\n{\n    BlockDriverState *filtered;\n    GLOBAL_STATE_CODE();\n\n    if (!bs->drv) {\n        return 0;\n    }\n\n    /* If BS is a copy on write image, it is initialized to\n       the contents of the base image, which may not be zeroes.  */\n    if (bdrv_cow_child(bs)) {\n        return 0;\n    }\n    if (bs->drv->bdrv_has_zero_init) {\n        return bs->drv->bdrv_has_zero_init(bs);\n    }\n\n    filtered = bdrv_filter_bs(bs);\n    if (filtered) {\n        return bdrv_has_zero_init(filtered);\n    }\n\n    /* safe default */\n    return 0;\n}\n\nbool bdrv_can_write_zeroes_with_unmap(BlockDriverState *bs)\n{\n    IO_CODE();\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n        return false;\n    }\n\n    return bs->supported_zero_flags & BDRV_REQ_MAY_UNMAP;\n}\n\nvoid bdrv_get_backing_filename(BlockDriverState *bs,\n                               char *filename, int filename_size)\n{\n    IO_CODE();\n    pstrcpy(filename, filename_size, bs->backing_file);\n}\n\nint bdrv_get_info(BlockDriverState *bs, BlockDriverInfo *bdi)\n{\n    int ret;\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n    /* if bs->drv == NULL, bs is closed, so there's nothing to do here */\n    if (!drv) {\n        return -ENOMEDIUM;\n    }\n    if (!drv->bdrv_get_info) {\n        BlockDriverState *filtered = bdrv_filter_bs(bs);\n        if (filtered) {\n            return bdrv_get_info(filtered, bdi);\n        }\n        return -ENOTSUP;\n    }\n    memset(bdi, 0, sizeof(*bdi));\n    ret = drv->bdrv_get_info(bs, bdi);\n    if (ret < 0) {\n        return ret;\n    }\n\n    if (bdi->cluster_size > BDRV_MAX_ALIGNMENT) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n\nImageInfoSpecific *bdrv_get_specific_info(BlockDriverState *bs,\n                                          Error **errp)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n    if (drv && drv->bdrv_get_specific_info) {\n        return drv->bdrv_get_specific_info(bs, errp);\n    }\n    return NULL;\n}\n\nBlockStatsSpecific *bdrv_get_specific_stats(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n    if (!drv || !drv->bdrv_get_specific_stats) {\n        return NULL;\n    }\n    return drv->bdrv_get_specific_stats(bs);\n}\n\nvoid bdrv_debug_event(BlockDriverState *bs, BlkdebugEvent event)\n{\n    IO_CODE();\n    if (!bs || !bs->drv || !bs->drv->bdrv_debug_event) {\n        return;\n    }\n\n    bs->drv->bdrv_debug_event(bs, event);\n}\n\nstatic BlockDriverState *bdrv_find_debug_node(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    while (bs && bs->drv && !bs->drv->bdrv_debug_breakpoint) {\n        bs = bdrv_primary_bs(bs);\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_breakpoint) {\n        assert(bs->drv->bdrv_debug_remove_breakpoint);\n        return bs;\n    }\n\n    return NULL;\n}\n\nint bdrv_debug_breakpoint(BlockDriverState *bs, const char *event,\n                          const char *tag)\n{\n    GLOBAL_STATE_CODE();\n    bs = bdrv_find_debug_node(bs);\n    if (bs) {\n        return bs->drv->bdrv_debug_breakpoint(bs, event, tag);\n    }\n\n    return -ENOTSUP;\n}\n\nint bdrv_debug_remove_breakpoint(BlockDriverState *bs, const char *tag)\n{\n    GLOBAL_STATE_CODE();\n    bs = bdrv_find_debug_node(bs);\n    if (bs) {\n        return bs->drv->bdrv_debug_remove_breakpoint(bs, tag);\n    }\n\n    return -ENOTSUP;\n}\n\nint bdrv_debug_resume(BlockDriverState *bs, const char *tag)\n{\n    GLOBAL_STATE_CODE();\n    while (bs && (!bs->drv || !bs->drv->bdrv_debug_resume)) {\n        bs = bdrv_primary_bs(bs);\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_resume) {\n        return bs->drv->bdrv_debug_resume(bs, tag);\n    }\n\n    return -ENOTSUP;\n}\n\nbool bdrv_debug_is_suspended(BlockDriverState *bs, const char *tag)\n{\n    GLOBAL_STATE_CODE();\n    while (bs && bs->drv && !bs->drv->bdrv_debug_is_suspended) {\n        bs = bdrv_primary_bs(bs);\n    }\n\n    if (bs && bs->drv && bs->drv->bdrv_debug_is_suspended) {\n        return bs->drv->bdrv_debug_is_suspended(bs, tag);\n    }\n\n    return false;\n}\n\n/* backing_file can either be relative, or absolute, or a protocol.  If it is\n * relative, it must be relative to the chain.  So, passing in bs->filename\n * from a BDS as backing_file should not be done, as that may be relative to\n * the CWD rather than the chain. */\nBlockDriverState *bdrv_find_backing_image(BlockDriverState *bs,\n        const char *backing_file)\n{\n    char *filename_full = NULL;\n    char *backing_file_full = NULL;\n    char *filename_tmp = NULL;\n    int is_protocol = 0;\n    bool filenames_refreshed = false;\n    BlockDriverState *curr_bs = NULL;\n    BlockDriverState *retval = NULL;\n    BlockDriverState *bs_below;\n\n    GLOBAL_STATE_CODE();\n\n    if (!bs || !bs->drv || !backing_file) {\n        return NULL;\n    }\n\n    filename_full     = g_malloc(PATH_MAX);\n    backing_file_full = g_malloc(PATH_MAX);\n\n    is_protocol = path_has_protocol(backing_file);\n\n    /*\n     * Being largely a legacy function, skip any filters here\n     * (because filters do not have normal filenames, so they cannot\n     * match anyway; and allowing json:{} filenames is a bit out of\n     * scope).\n     */\n    for (curr_bs = bdrv_skip_filters(bs);\n         bdrv_cow_child(curr_bs) != NULL;\n         curr_bs = bs_below)\n    {\n        bs_below = bdrv_backing_chain_next(curr_bs);\n\n        if (bdrv_backing_overridden(curr_bs)) {\n            /*\n             * If the backing file was overridden, we can only compare\n             * directly against the backing node's filename.\n             */\n\n            if (!filenames_refreshed) {\n                /*\n                 * This will automatically refresh all of the\n                 * filenames in the rest of the backing chain, so we\n                 * only need to do this once.\n                 */\n                bdrv_refresh_filename(bs_below);\n                filenames_refreshed = true;\n            }\n\n            if (strcmp(backing_file, bs_below->filename) == 0) {\n                retval = bs_below;\n                break;\n            }\n        } else if (is_protocol || path_has_protocol(curr_bs->backing_file)) {\n            /*\n             * If either of the filename paths is actually a protocol, then\n             * compare unmodified paths; otherwise make paths relative.\n             */\n            char *backing_file_full_ret;\n\n            if (strcmp(backing_file, curr_bs->backing_file) == 0) {\n                retval = bs_below;\n                break;\n            }\n            /* Also check against the full backing filename for the image */\n            backing_file_full_ret = bdrv_get_full_backing_filename(curr_bs,\n                                                                   NULL);\n            if (backing_file_full_ret) {\n                bool equal = strcmp(backing_file, backing_file_full_ret) == 0;\n                g_free(backing_file_full_ret);\n                if (equal) {\n                    retval = bs_below;\n                    break;\n                }\n            }\n        } else {\n            /* If not an absolute filename path, make it relative to the current\n             * image's filename path */\n            filename_tmp = bdrv_make_absolute_filename(curr_bs, backing_file,\n                                                       NULL);\n            /* We are going to compare canonicalized absolute pathnames */\n            if (!filename_tmp || !realpath(filename_tmp, filename_full)) {\n                g_free(filename_tmp);\n                continue;\n            }\n            g_free(filename_tmp);\n\n            /* We need to make sure the backing filename we are comparing against\n             * is relative to the current image filename (or absolute) */\n            filename_tmp = bdrv_get_full_backing_filename(curr_bs, NULL);\n            if (!filename_tmp || !realpath(filename_tmp, backing_file_full)) {\n                g_free(filename_tmp);\n                continue;\n            }\n            g_free(filename_tmp);\n\n            if (strcmp(backing_file_full, filename_full) == 0) {\n                retval = bs_below;\n                break;\n            }\n        }\n    }\n\n    g_free(filename_full);\n    g_free(backing_file_full);\n    return retval;\n}\n\nvoid bdrv_init(void)\n{\n#ifdef CONFIG_BDRV_WHITELIST_TOOLS\n    use_bdrv_whitelist = 1;\n#endif\n    module_call_init(MODULE_INIT_BLOCK);\n}\n\nvoid bdrv_init_with_whitelist(void)\n{\n    use_bdrv_whitelist = 1;\n    bdrv_init();\n}\n\nint bdrv_activate(BlockDriverState *bs, Error **errp)\n{\n    BdrvChild *child, *parent;\n    Error *local_err = NULL;\n    int ret;\n    BdrvDirtyBitmap *bm;\n\n    GLOBAL_STATE_CODE();\n\n    if (!bs->drv)  {\n        return -ENOMEDIUM;\n    }\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        bdrv_activate(child->bs, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return -EINVAL;\n        }\n    }\n\n    /*\n     * Update permissions, they may differ for inactive nodes.\n     *\n     * Note that the required permissions of inactive images are always a\n     * subset of the permissions required after activating the image. This\n     * allows us to just get the permissions upfront without restricting\n     * bdrv_co_invalidate_cache().\n     *\n     * It also means that in error cases, we don't have to try and revert to\n     * the old permissions (which is an operation that could fail, too). We can\n     * just keep the extended permissions for the next time that an activation\n     * of the image is tried.\n     */\n    if (bs->open_flags & BDRV_O_INACTIVE) {\n        bs->open_flags &= ~BDRV_O_INACTIVE;\n        ret = bdrv_refresh_perms(bs, errp);\n        if (ret < 0) {\n            bs->open_flags |= BDRV_O_INACTIVE;\n            return ret;\n        }\n\n        ret = bdrv_invalidate_cache(bs, errp);\n        if (ret < 0) {\n            bs->open_flags |= BDRV_O_INACTIVE;\n            return ret;\n        }\n\n        FOR_EACH_DIRTY_BITMAP(bs, bm) {\n            bdrv_dirty_bitmap_skip_store(bm, false);\n        }\n\n        ret = refresh_total_sectors(bs, bs->total_sectors);\n        if (ret < 0) {\n            bs->open_flags |= BDRV_O_INACTIVE;\n            error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n            return ret;\n        }\n    }\n\n    QLIST_FOREACH(parent, &bs->parents, next_parent) {\n        if (parent->klass->activate) {\n            parent->klass->activate(parent, &local_err);\n            if (local_err) {\n                bs->open_flags |= BDRV_O_INACTIVE;\n                error_propagate(errp, local_err);\n                return -EINVAL;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint coroutine_fn bdrv_co_invalidate_cache(BlockDriverState *bs, Error **errp)\n{\n    Error *local_err = NULL;\n    IO_CODE();\n\n    assert(!(bs->open_flags & BDRV_O_INACTIVE));\n\n    if (bs->drv->bdrv_co_invalidate_cache) {\n        bs->drv->bdrv_co_invalidate_cache(bs, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return -EINVAL;\n        }\n    }\n\n    return 0;\n}\n\nvoid bdrv_activate_all(Error **errp)\n{\n    BlockDriverState *bs;\n    BdrvNextIterator it;\n\n    GLOBAL_STATE_CODE();\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n        int ret;\n\n        aio_context_acquire(aio_context);\n        ret = bdrv_activate(bs, errp);\n        aio_context_release(aio_context);\n        if (ret < 0) {\n            bdrv_next_cleanup(&it);\n            return;\n        }\n    }\n}\n\nstatic bool bdrv_has_bds_parent(BlockDriverState *bs, bool only_active)\n{\n    BdrvChild *parent;\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(parent, &bs->parents, next_parent) {\n        if (parent->klass->parent_is_bds) {\n            BlockDriverState *parent_bs = parent->opaque;\n            if (!only_active || !(parent_bs->open_flags & BDRV_O_INACTIVE)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nstatic int bdrv_inactivate_recurse(BlockDriverState *bs)\n{\n    BdrvChild *child, *parent;\n    int ret;\n    uint64_t cumulative_perms, cumulative_shared_perms;\n\n    GLOBAL_STATE_CODE();\n\n    if (!bs->drv) {\n        return -ENOMEDIUM;\n    }\n\n    /* Make sure that we don't inactivate a child before its parent.\n     * It will be covered by recursion from the yet active parent. */\n    if (bdrv_has_bds_parent(bs, true)) {\n        return 0;\n    }\n\n    assert(!(bs->open_flags & BDRV_O_INACTIVE));\n\n    /* Inactivate this node */\n    if (bs->drv->bdrv_inactivate) {\n        ret = bs->drv->bdrv_inactivate(bs);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    QLIST_FOREACH(parent, &bs->parents, next_parent) {\n        if (parent->klass->inactivate) {\n            ret = parent->klass->inactivate(parent);\n            if (ret < 0) {\n                return ret;\n            }\n        }\n    }\n\n    bdrv_get_cumulative_perm(bs, &cumulative_perms,\n                             &cumulative_shared_perms);\n    if (cumulative_perms & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED)) {\n        /* Our inactive parents still need write access. Inactivation failed. */\n        return -EPERM;\n    }\n\n    bs->open_flags |= BDRV_O_INACTIVE;\n\n    /*\n     * Update permissions, they may differ for inactive nodes.\n     * We only tried to loosen restrictions, so errors are not fatal, ignore\n     * them.\n     */\n    bdrv_refresh_perms(bs, NULL);\n\n    /* Recursively inactivate children */\n    QLIST_FOREACH(child, &bs->children, next) {\n        ret = bdrv_inactivate_recurse(child->bs);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nint bdrv_inactivate_all(void)\n{\n    BlockDriverState *bs = NULL;\n    BdrvNextIterator it;\n    int ret = 0;\n    GSList *aio_ctxs = NULL, *ctx;\n\n    GLOBAL_STATE_CODE();\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n        if (!g_slist_find(aio_ctxs, aio_context)) {\n            aio_ctxs = g_slist_prepend(aio_ctxs, aio_context);\n            aio_context_acquire(aio_context);\n        }\n    }\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n        /* Nodes with BDS parents are covered by recursion from the last\n         * parent that gets inactivated. Don't inactivate them a second\n         * time if that has already happened. */\n        if (bdrv_has_bds_parent(bs, false)) {\n            continue;\n        }\n        ret = bdrv_inactivate_recurse(bs);\n        if (ret < 0) {\n            bdrv_next_cleanup(&it);\n            goto out;\n        }\n    }\n\nout:\n    for (ctx = aio_ctxs; ctx != NULL; ctx = ctx->next) {\n        AioContext *aio_context = ctx->data;\n        aio_context_release(aio_context);\n    }\n    g_slist_free(aio_ctxs);\n\n    return ret;\n}\n\n/**************************************************************/\n/* removable device support */\n\n/**\n * Return TRUE if the media is present\n */\nbool bdrv_is_inserted(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *child;\n    IO_CODE();\n\n    if (!drv) {\n        return false;\n    }\n    if (drv->bdrv_is_inserted) {\n        return drv->bdrv_is_inserted(bs);\n    }\n    QLIST_FOREACH(child, &bs->children, next) {\n        if (!bdrv_is_inserted(child->bs)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * If eject_flag is TRUE, eject the media. Otherwise, close the tray\n */\nvoid bdrv_eject(BlockDriverState *bs, bool eject_flag)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n\n    if (drv && drv->bdrv_eject) {\n        drv->bdrv_eject(bs, eject_flag);\n    }\n}\n\n/**\n * Lock or unlock the media (if it is locked, the user won't be able\n * to eject it manually).\n */\nvoid bdrv_lock_medium(BlockDriverState *bs, bool locked)\n{\n    BlockDriver *drv = bs->drv;\n    IO_CODE();\n    trace_bdrv_lock_medium(bs, locked);\n\n    if (drv && drv->bdrv_lock_medium) {\n        drv->bdrv_lock_medium(bs, locked);\n    }\n}\n\n/* Get a reference to bs */\nvoid bdrv_ref(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    bs->refcnt++;\n}\n\n/* Release a previously grabbed reference to bs.\n * If after releasing, reference count is zero, the BlockDriverState is\n * deleted. */\nvoid bdrv_unref(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    if (!bs) {\n        return;\n    }\n    assert(bs->refcnt > 0);\n    if (--bs->refcnt == 0) {\n        bdrv_delete(bs);\n    }\n}\n\nstruct BdrvOpBlocker {\n    Error *reason;\n    QLIST_ENTRY(BdrvOpBlocker) list;\n};\n\nbool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n{\n    BdrvOpBlocker *blocker;\n    GLOBAL_STATE_CODE();\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n        error_propagate_prepend(errp, error_copy(blocker->reason),\n                                \"Node '%s' is busy: \",\n                                bdrv_get_device_or_node_name(bs));\n        return true;\n    }\n    return false;\n}\n\nvoid bdrv_op_block(BlockDriverState *bs, BlockOpType op, Error *reason)\n{\n    BdrvOpBlocker *blocker;\n    GLOBAL_STATE_CODE();\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    blocker = g_new0(BdrvOpBlocker, 1);\n    blocker->reason = reason;\n    QLIST_INSERT_HEAD(&bs->op_blockers[op], blocker, list);\n}\n\nvoid bdrv_op_unblock(BlockDriverState *bs, BlockOpType op, Error *reason)\n{\n    BdrvOpBlocker *blocker, *next;\n    GLOBAL_STATE_CODE();\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n    QLIST_FOREACH_SAFE(blocker, &bs->op_blockers[op], list, next) {\n        if (blocker->reason == reason) {\n            QLIST_REMOVE(blocker, list);\n            g_free(blocker);\n        }\n    }\n}\n\nvoid bdrv_op_block_all(BlockDriverState *bs, Error *reason)\n{\n    int i;\n    GLOBAL_STATE_CODE();\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        bdrv_op_block(bs, i, reason);\n    }\n}\n\nvoid bdrv_op_unblock_all(BlockDriverState *bs, Error *reason)\n{\n    int i;\n    GLOBAL_STATE_CODE();\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        bdrv_op_unblock(bs, i, reason);\n    }\n}\n\nbool bdrv_op_blocker_is_empty(BlockDriverState *bs)\n{\n    int i;\n    GLOBAL_STATE_CODE();\n    for (i = 0; i < BLOCK_OP_TYPE_MAX; i++) {\n        if (!QLIST_EMPTY(&bs->op_blockers[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid bdrv_img_create(const char *filename, const char *fmt,\n                     const char *base_filename, const char *base_fmt,\n                     char *options, uint64_t img_size, int flags, bool quiet,\n                     Error **errp)\n{\n    QemuOptsList *create_opts = NULL;\n    QemuOpts *opts = NULL;\n    const char *backing_fmt, *backing_file;\n    int64_t size;\n    BlockDriver *drv, *proto_drv;\n    Error *local_err = NULL;\n    int ret = 0;\n\n    GLOBAL_STATE_CODE();\n\n    /* Find driver and parse its options */\n    drv = bdrv_find_format(fmt);\n    if (!drv) {\n        error_setg(errp, \"Unknown file format '%s'\", fmt);\n        return;\n    }\n\n    proto_drv = bdrv_find_protocol(filename, true, errp);\n    if (!proto_drv) {\n        return;\n    }\n\n    if (!drv->create_opts) {\n        error_setg(errp, \"Format driver '%s' does not support image creation\",\n                   drv->format_name);\n        return;\n    }\n\n    if (!proto_drv->create_opts) {\n        error_setg(errp, \"Protocol driver '%s' does not support image creation\",\n                   proto_drv->format_name);\n        return;\n    }\n\n    /* Create parameter list */\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n\n    /* Parse -o options */\n    if (options) {\n        if (!qemu_opts_do_parse(opts, options, NULL, errp)) {\n            goto out;\n        }\n    }\n\n    if (!qemu_opt_get(opts, BLOCK_OPT_SIZE)) {\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE, img_size, &error_abort);\n    } else if (img_size != UINT64_C(-1)) {\n        error_setg(errp, \"The image size must be specified only once\");\n        goto out;\n    }\n\n    if (base_filename) {\n        if (!qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename,\n                          NULL)) {\n            error_setg(errp, \"Backing file not supported for file format '%s'\",\n                       fmt);\n            goto out;\n        }\n    }\n\n    if (base_fmt) {\n        if (!qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt, NULL)) {\n            error_setg(errp, \"Backing file format not supported for file \"\n                             \"format '%s'\", fmt);\n            goto out;\n        }\n    }\n\n    backing_file = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n    if (backing_file) {\n        if (!strcmp(filename, backing_file)) {\n            error_setg(errp, \"Error: Trying to create an image with the \"\n                             \"same filename as the backing file\");\n            goto out;\n        }\n        if (backing_file[0] == '\\0') {\n            error_setg(errp, \"Expected backing file name, got empty string\");\n            goto out;\n        }\n    }\n\n    backing_fmt = qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT);\n\n    /* The size for the image must always be specified, unless we have a backing\n     * file and we have not been forbidden from opening it. */\n    size = qemu_opt_get_size(opts, BLOCK_OPT_SIZE, img_size);\n    if (backing_file && !(flags & BDRV_O_NO_BACKING)) {\n        BlockDriverState *bs;\n        char *full_backing;\n        int back_flags;\n        QDict *backing_options = NULL;\n\n        full_backing =\n            bdrv_get_full_backing_filename_from_filename(filename, backing_file,\n                                                         &local_err);\n        if (local_err) {\n            goto out;\n        }\n        assert(full_backing);\n\n        /*\n         * No need to do I/O here, which allows us to open encrypted\n         * backing images without needing the secret\n         */\n        back_flags = flags;\n        back_flags &= ~(BDRV_O_RDWR | BDRV_O_SNAPSHOT | BDRV_O_NO_BACKING);\n        back_flags |= BDRV_O_NO_IO;\n\n        backing_options = qdict_new();\n        if (backing_fmt) {\n            qdict_put_str(backing_options, \"driver\", backing_fmt);\n        }\n        qdict_put_bool(backing_options, BDRV_OPT_FORCE_SHARE, true);\n\n        bs = bdrv_open(full_backing, NULL, backing_options, back_flags,\n                       &local_err);\n        g_free(full_backing);\n        if (!bs) {\n            error_append_hint(&local_err, \"Could not open backing image.\\n\");\n            goto out;\n        } else {\n            if (!backing_fmt) {\n                error_setg(&local_err,\n                           \"Backing file specified without backing format\");\n                error_append_hint(&local_err, \"Detected format of %s.\",\n                                  bs->drv->format_name);\n                goto out;\n            }\n            if (size == -1) {\n                /* Opened BS, have no size */\n                size = bdrv_getlength(bs);\n                if (size < 0) {\n                    error_setg_errno(errp, -size, \"Could not get size of '%s'\",\n                                     backing_file);\n                    bdrv_unref(bs);\n                    goto out;\n                }\n                qemu_opt_set_number(opts, BLOCK_OPT_SIZE, size, &error_abort);\n            }\n            bdrv_unref(bs);\n        }\n        /* (backing_file && !(flags & BDRV_O_NO_BACKING)) */\n    } else if (backing_file && !backing_fmt) {\n        error_setg(&local_err,\n                   \"Backing file specified without backing format\");\n        goto out;\n    }\n\n    if (size == -1) {\n        error_setg(errp, \"Image creation needs a size parameter\");\n        goto out;\n    }\n\n    if (!quiet) {\n        printf(\"Formatting '%s', fmt=%s \", filename, fmt);\n        qemu_opts_print(opts, \" \");\n        puts(\"\");\n        fflush(stdout);\n    }\n\n    ret = bdrv_create(drv, filename, opts, &local_err);\n\n    if (ret == -EFBIG) {\n        /* This is generally a better message than whatever the driver would\n         * deliver (especially because of the cluster_size_hint), since that\n         * is most probably not much different from \"image too large\". */\n        const char *cluster_size_hint = \"\";\n        if (qemu_opt_get_size(opts, BLOCK_OPT_CLUSTER_SIZE, 0)) {\n            cluster_size_hint = \" (try using a larger cluster size)\";\n        }\n        error_setg(errp, \"The image size is too large for file format '%s'\"\n                   \"%s\", fmt, cluster_size_hint);\n        error_free(local_err);\n        local_err = NULL;\n    }\n\nout:\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    error_propagate(errp, local_err);\n}\n\nAioContext *bdrv_get_aio_context(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bs ? bs->aio_context : qemu_get_aio_context();\n}\n\nAioContext *coroutine_fn bdrv_co_enter(BlockDriverState *bs)\n{\n    Coroutine *self = qemu_coroutine_self();\n    AioContext *old_ctx = qemu_coroutine_get_aio_context(self);\n    AioContext *new_ctx;\n    IO_CODE();\n\n    /*\n     * Increase bs->in_flight to ensure that this operation is completed before\n     * moving the node to a different AioContext. Read new_ctx only afterwards.\n     */\n    bdrv_inc_in_flight(bs);\n\n    new_ctx = bdrv_get_aio_context(bs);\n    aio_co_reschedule_self(new_ctx);\n    return old_ctx;\n}\n\nvoid coroutine_fn bdrv_co_leave(BlockDriverState *bs, AioContext *old_ctx)\n{\n    IO_CODE();\n    aio_co_reschedule_self(old_ctx);\n    bdrv_dec_in_flight(bs);\n}\n\nvoid coroutine_fn bdrv_co_lock(BlockDriverState *bs)\n{\n    AioContext *ctx = bdrv_get_aio_context(bs);\n\n    /* In the main thread, bs->aio_context won't change concurrently */\n    assert(qemu_get_current_aio_context() == qemu_get_aio_context());\n\n    /*\n     * We're in coroutine context, so we already hold the lock of the main\n     * loop AioContext. Don't lock it twice to avoid deadlocks.\n     */\n    assert(qemu_in_coroutine());\n    if (ctx != qemu_get_aio_context()) {\n        aio_context_acquire(ctx);\n    }\n}\n\nvoid coroutine_fn bdrv_co_unlock(BlockDriverState *bs)\n{\n    AioContext *ctx = bdrv_get_aio_context(bs);\n\n    assert(qemu_in_coroutine());\n    if (ctx != qemu_get_aio_context()) {\n        aio_context_release(ctx);\n    }\n}\n\nvoid bdrv_coroutine_enter(BlockDriverState *bs, Coroutine *co)\n{\n    IO_CODE();\n    aio_co_enter(bdrv_get_aio_context(bs), co);\n}\n\nstatic void bdrv_do_remove_aio_context_notifier(BdrvAioNotifier *ban)\n{\n    GLOBAL_STATE_CODE();\n    QLIST_REMOVE(ban, list);\n    g_free(ban);\n}\n\nstatic void bdrv_detach_aio_context(BlockDriverState *bs)\n{\n    BdrvAioNotifier *baf, *baf_tmp;\n\n    assert(!bs->walking_aio_notifiers);\n    GLOBAL_STATE_CODE();\n    bs->walking_aio_notifiers = true;\n    QLIST_FOREACH_SAFE(baf, &bs->aio_notifiers, list, baf_tmp) {\n        if (baf->deleted) {\n            bdrv_do_remove_aio_context_notifier(baf);\n        } else {\n            baf->detach_aio_context(baf->opaque);\n        }\n    }\n    /* Never mind iterating again to check for ->deleted.  bdrv_close() will\n     * remove remaining aio notifiers if we aren't called again.\n     */\n    bs->walking_aio_notifiers = false;\n\n    if (bs->drv && bs->drv->bdrv_detach_aio_context) {\n        bs->drv->bdrv_detach_aio_context(bs);\n    }\n\n    if (bs->quiesce_counter) {\n        aio_enable_external(bs->aio_context);\n    }\n    bs->aio_context = NULL;\n}\n\nstatic void bdrv_attach_aio_context(BlockDriverState *bs,\n                                    AioContext *new_context)\n{\n    BdrvAioNotifier *ban, *ban_tmp;\n    GLOBAL_STATE_CODE();\n\n    if (bs->quiesce_counter) {\n        aio_disable_external(new_context);\n    }\n\n    bs->aio_context = new_context;\n\n    if (bs->drv && bs->drv->bdrv_attach_aio_context) {\n        bs->drv->bdrv_attach_aio_context(bs, new_context);\n    }\n\n    assert(!bs->walking_aio_notifiers);\n    bs->walking_aio_notifiers = true;\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_tmp) {\n        if (ban->deleted) {\n            bdrv_do_remove_aio_context_notifier(ban);\n        } else {\n            ban->attached_aio_context(new_context, ban->opaque);\n        }\n    }\n    bs->walking_aio_notifiers = false;\n}\n\n/*\n * Changes the AioContext used for fd handlers, timers, and BHs by this\n * BlockDriverState and all its children and parents.\n *\n * Must be called from the main AioContext.\n *\n * The caller must own the AioContext lock for the old AioContext of bs, but it\n * must not own the AioContext lock for new_context (unless new_context is the\n * same as the current context of bs).\n *\n * @ignore will accumulate all visited BdrvChild object. The caller is\n * responsible for freeing the list afterwards.\n */\nvoid bdrv_set_aio_context_ignore(BlockDriverState *bs,\n                                 AioContext *new_context, GSList **ignore)\n{\n    AioContext *old_context = bdrv_get_aio_context(bs);\n    GSList *children_to_process = NULL;\n    GSList *parents_to_process = NULL;\n    GSList *entry;\n    BdrvChild *child, *parent;\n\n    g_assert(qemu_get_current_aio_context() == qemu_get_aio_context());\n    GLOBAL_STATE_CODE();\n\n    if (old_context == new_context) {\n        return;\n    }\n\n    bdrv_drained_begin(bs);\n\n    QLIST_FOREACH(child, &bs->children, next) {\n        if (g_slist_find(*ignore, child)) {\n            continue;\n        }\n        *ignore = g_slist_prepend(*ignore, child);\n        children_to_process = g_slist_prepend(children_to_process, child);\n    }\n\n    QLIST_FOREACH(parent, &bs->parents, next_parent) {\n        if (g_slist_find(*ignore, parent)) {\n            continue;\n        }\n        *ignore = g_slist_prepend(*ignore, parent);\n        parents_to_process = g_slist_prepend(parents_to_process, parent);\n    }\n\n    for (entry = children_to_process;\n         entry != NULL;\n         entry = g_slist_next(entry)) {\n        child = entry->data;\n        bdrv_set_aio_context_ignore(child->bs, new_context, ignore);\n    }\n    g_slist_free(children_to_process);\n\n    for (entry = parents_to_process;\n         entry != NULL;\n         entry = g_slist_next(entry)) {\n        parent = entry->data;\n        assert(parent->klass->set_aio_ctx);\n        parent->klass->set_aio_ctx(parent, new_context, ignore);\n    }\n    g_slist_free(parents_to_process);\n\n    bdrv_detach_aio_context(bs);\n\n    /* Acquire the new context, if necessary */\n    if (qemu_get_aio_context() != new_context) {\n        aio_context_acquire(new_context);\n    }\n\n    bdrv_attach_aio_context(bs, new_context);\n\n    /*\n     * If this function was recursively called from\n     * bdrv_set_aio_context_ignore(), there may be nodes in the\n     * subtree that have not yet been moved to the new AioContext.\n     * Release the old one so bdrv_drained_end() can poll them.\n     */\n    if (qemu_get_aio_context() != old_context) {\n        aio_context_release(old_context);\n    }\n\n    bdrv_drained_end(bs);\n\n    if (qemu_get_aio_context() != old_context) {\n        aio_context_acquire(old_context);\n    }\n    if (qemu_get_aio_context() != new_context) {\n        aio_context_release(new_context);\n    }\n}\n\nstatic bool bdrv_parent_can_set_aio_context(BdrvChild *c, AioContext *ctx,\n                                            GSList **ignore, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    if (g_slist_find(*ignore, c)) {\n        return true;\n    }\n    *ignore = g_slist_prepend(*ignore, c);\n\n    /*\n     * A BdrvChildClass that doesn't handle AioContext changes cannot\n     * tolerate any AioContext changes\n     */\n    if (!c->klass->can_set_aio_ctx) {\n        char *user = bdrv_child_user_desc(c);\n        error_setg(errp, \"Changing iothreads is not supported by %s\", user);\n        g_free(user);\n        return false;\n    }\n    if (!c->klass->can_set_aio_ctx(c, ctx, ignore, errp)) {\n        assert(!errp || *errp);\n        return false;\n    }\n    return true;\n}\n\nbool bdrv_child_can_set_aio_context(BdrvChild *c, AioContext *ctx,\n                                    GSList **ignore, Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    if (g_slist_find(*ignore, c)) {\n        return true;\n    }\n    *ignore = g_slist_prepend(*ignore, c);\n    return bdrv_can_set_aio_context(c->bs, ctx, ignore, errp);\n}\n\n/* @ignore will accumulate all visited BdrvChild object. The caller is\n * responsible for freeing the list afterwards. */\nbool bdrv_can_set_aio_context(BlockDriverState *bs, AioContext *ctx,\n                              GSList **ignore, Error **errp)\n{\n    BdrvChild *c;\n\n    if (bdrv_get_aio_context(bs) == ctx) {\n        return true;\n    }\n\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n        if (!bdrv_parent_can_set_aio_context(c, ctx, ignore, errp)) {\n            return false;\n        }\n    }\n    QLIST_FOREACH(c, &bs->children, next) {\n        if (!bdrv_child_can_set_aio_context(c, ctx, ignore, errp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint bdrv_child_try_set_aio_context(BlockDriverState *bs, AioContext *ctx,\n                                   BdrvChild *ignore_child, Error **errp)\n{\n    GSList *ignore;\n    bool ret;\n\n    GLOBAL_STATE_CODE();\n\n    ignore = ignore_child ? g_slist_prepend(NULL, ignore_child) : NULL;\n    ret = bdrv_can_set_aio_context(bs, ctx, &ignore, errp);\n    g_slist_free(ignore);\n\n    if (!ret) {\n        return -EPERM;\n    }\n\n    ignore = ignore_child ? g_slist_prepend(NULL, ignore_child) : NULL;\n    bdrv_set_aio_context_ignore(bs, ctx, &ignore);\n    g_slist_free(ignore);\n\n    return 0;\n}\n\nint bdrv_try_set_aio_context(BlockDriverState *bs, AioContext *ctx,\n                             Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    return bdrv_child_try_set_aio_context(bs, ctx, NULL, errp);\n}\n\nvoid bdrv_add_aio_context_notifier(BlockDriverState *bs,\n        void (*attached_aio_context)(AioContext *new_context, void *opaque),\n        void (*detach_aio_context)(void *opaque), void *opaque)\n{\n    BdrvAioNotifier *ban = g_new(BdrvAioNotifier, 1);\n    *ban = (BdrvAioNotifier){\n        .attached_aio_context = attached_aio_context,\n        .detach_aio_context   = detach_aio_context,\n        .opaque               = opaque\n    };\n    GLOBAL_STATE_CODE();\n\n    QLIST_INSERT_HEAD(&bs->aio_notifiers, ban, list);\n}\n\nvoid bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n                                      void (*attached_aio_context)(AioContext *,\n                                                                   void *),\n                                      void (*detach_aio_context)(void *),\n                                      void *opaque)\n{\n    BdrvAioNotifier *ban, *ban_next;\n    GLOBAL_STATE_CODE();\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n        if (ban->attached_aio_context == attached_aio_context &&\n            ban->detach_aio_context   == detach_aio_context   &&\n            ban->opaque               == opaque               &&\n            ban->deleted              == false)\n        {\n            if (bs->walking_aio_notifiers) {\n                ban->deleted = true;\n            } else {\n                bdrv_do_remove_aio_context_notifier(ban);\n            }\n            return;\n        }\n    }\n\n    abort();\n}\n\nint bdrv_amend_options(BlockDriverState *bs, QemuOpts *opts,\n                       BlockDriverAmendStatusCB *status_cb, void *cb_opaque,\n                       bool force,\n                       Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    if (!bs->drv) {\n        error_setg(errp, \"Node is ejected\");\n        return -ENOMEDIUM;\n    }\n    if (!bs->drv->bdrv_amend_options) {\n        error_setg(errp, \"Block driver '%s' does not support option amendment\",\n                   bs->drv->format_name);\n        return -ENOTSUP;\n    }\n    return bs->drv->bdrv_amend_options(bs, opts, status_cb,\n                                       cb_opaque, force, errp);\n}\n\n/*\n * This function checks whether the given @to_replace is allowed to be\n * replaced by a node that always shows the same data as @bs.  This is\n * used for example to verify whether the mirror job can replace\n * @to_replace by the target mirrored from @bs.\n * To be replaceable, @bs and @to_replace may either be guaranteed to\n * always show the same data (because they are only connected through\n * filters), or some driver may allow replacing one of its children\n * because it can guarantee that this child's data is not visible at\n * all (for example, for dissenting quorum children that have no other\n * parents).\n */\nbool bdrv_recurse_can_replace(BlockDriverState *bs,\n                              BlockDriverState *to_replace)\n{\n    BlockDriverState *filtered;\n\n    GLOBAL_STATE_CODE();\n\n    if (!bs || !bs->drv) {\n        return false;\n    }\n\n    if (bs == to_replace) {\n        return true;\n    }\n\n    /* See what the driver can do */\n    if (bs->drv->bdrv_recurse_can_replace) {\n        return bs->drv->bdrv_recurse_can_replace(bs, to_replace);\n    }\n\n    /* For filters without an own implementation, we can recurse on our own */\n    filtered = bdrv_filter_bs(bs);\n    if (filtered) {\n        return bdrv_recurse_can_replace(filtered, to_replace);\n    }\n\n    /* Safe default */\n    return false;\n}\n\n/*\n * Check whether the given @node_name can be replaced by a node that\n * has the same data as @parent_bs.  If so, return @node_name's BDS;\n * NULL otherwise.\n *\n * @node_name must be a (recursive) *child of @parent_bs (or this\n * function will return NULL).\n *\n * The result (whether the node can be replaced or not) is only valid\n * for as long as no graph or permission changes occur.\n */\nBlockDriverState *check_to_replace_node(BlockDriverState *parent_bs,\n                                        const char *node_name, Error **errp)\n{\n    BlockDriverState *to_replace_bs = bdrv_find_node(node_name);\n    AioContext *aio_context;\n\n    GLOBAL_STATE_CODE();\n\n    if (!to_replace_bs) {\n        error_setg(errp, \"Failed to find node with node-name='%s'\", node_name);\n        return NULL;\n    }\n\n    aio_context = bdrv_get_aio_context(to_replace_bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(to_replace_bs, BLOCK_OP_TYPE_REPLACE, errp)) {\n        to_replace_bs = NULL;\n        goto out;\n    }\n\n    /* We don't want arbitrary node of the BDS chain to be replaced only the top\n     * most non filter in order to prevent data corruption.\n     * Another benefit is that this tests exclude backing files which are\n     * blocked by the backing blockers.\n     */\n    if (!bdrv_recurse_can_replace(parent_bs, to_replace_bs)) {\n        error_setg(errp, \"Cannot replace '%s' by a node mirrored from '%s', \"\n                   \"because it cannot be guaranteed that doing so would not \"\n                   \"lead to an abrupt change of visible data\",\n                   node_name, parent_bs->node_name);\n        to_replace_bs = NULL;\n        goto out;\n    }\n\nout:\n    aio_context_release(aio_context);\n    return to_replace_bs;\n}\n\n/**\n * Iterates through the list of runtime option keys that are said to\n * be \"strong\" for a BDS.  An option is called \"strong\" if it changes\n * a BDS's data.  For example, the null block driver's \"size\" and\n * \"read-zeroes\" options are strong, but its \"latency-ns\" option is\n * not.\n *\n * If a key returned by this function ends with a dot, all options\n * starting with that prefix are strong.\n */\nstatic const char *const *strong_options(BlockDriverState *bs,\n                                         const char *const *curopt)\n{\n    static const char *const global_options[] = {\n        \"driver\", \"filename\", NULL\n    };\n\n    if (!curopt) {\n        return &global_options[0];\n    }\n\n    curopt++;\n    if (curopt == &global_options[ARRAY_SIZE(global_options) - 1] && bs->drv) {\n        curopt = bs->drv->strong_runtime_opts;\n    }\n\n    return (curopt && *curopt) ? curopt : NULL;\n}\n\n/**\n * Copies all strong runtime options from bs->options to the given\n * QDict.  The set of strong option keys is determined by invoking\n * strong_options().\n *\n * Returns true iff any strong option was present in bs->options (and\n * thus copied to the target QDict) with the exception of \"filename\"\n * and \"driver\".  The caller is expected to use this value to decide\n * whether the existence of strong options prevents the generation of\n * a plain filename.\n */\nstatic bool append_strong_runtime_options(QDict *d, BlockDriverState *bs)\n{\n    bool found_any = false;\n    const char *const *option_name = NULL;\n\n    if (!bs->drv) {\n        return false;\n    }\n\n    while ((option_name = strong_options(bs, option_name))) {\n        bool option_given = false;\n\n        assert(strlen(*option_name) > 0);\n        if ((*option_name)[strlen(*option_name) - 1] != '.') {\n            QObject *entry = qdict_get(bs->options, *option_name);\n            if (!entry) {\n                continue;\n            }\n\n            qdict_put_obj(d, *option_name, qobject_ref(entry));\n            option_given = true;\n        } else {\n            const QDictEntry *entry;\n            for (entry = qdict_first(bs->options); entry;\n                 entry = qdict_next(bs->options, entry))\n            {\n                if (strstart(qdict_entry_key(entry), *option_name, NULL)) {\n                    qdict_put_obj(d, qdict_entry_key(entry),\n                                  qobject_ref(qdict_entry_value(entry)));\n                    option_given = true;\n                }\n            }\n        }\n\n        /* While \"driver\" and \"filename\" need to be included in a JSON filename,\n         * their existence does not prohibit generation of a plain filename. */\n        if (!found_any && option_given &&\n            strcmp(*option_name, \"driver\") && strcmp(*option_name, \"filename\"))\n        {\n            found_any = true;\n        }\n    }\n\n    if (!qdict_haskey(d, \"driver\")) {\n        /* Drivers created with bdrv_new_open_driver() may not have a\n         * @driver option.  Add it here. */\n        qdict_put_str(d, \"driver\", bs->drv->format_name);\n    }\n\n    return found_any;\n}\n\n/* Note: This function may return false positives; it may return true\n * even if opening the backing file specified by bs's image header\n * would result in exactly bs->backing. */\nstatic bool bdrv_backing_overridden(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    if (bs->backing) {\n        return strcmp(bs->auto_backing_file,\n                      bs->backing->bs->filename);\n    } else {\n        /* No backing BDS, so if the image header reports any backing\n         * file, it must have been suppressed */\n        return bs->auto_backing_file[0] != '\\0';\n    }\n}\n\n/* Updates the following BDS fields:\n *  - exact_filename: A filename which may be used for opening a block device\n *                    which (mostly) equals the given BDS (even without any\n *                    other options; so reading and writing must return the same\n *                    results, but caching etc. may be different)\n *  - full_open_options: Options which, when given when opening a block device\n *                       (without a filename), result in a BDS (mostly)\n *                       equalling the given one\n *  - filename: If exact_filename is set, it is copied here. Otherwise,\n *              full_open_options is converted to a JSON object, prefixed with\n *              \"json:\" (for use through the JSON pseudo protocol) and put here.\n */\nvoid bdrv_refresh_filename(BlockDriverState *bs)\n{\n    BlockDriver *drv = bs->drv;\n    BdrvChild *child;\n    BlockDriverState *primary_child_bs;\n    QDict *opts;\n    bool backing_overridden;\n    bool generate_json_filename; /* Whether our default implementation should\n                                    fill exact_filename (false) or not (true) */\n\n    GLOBAL_STATE_CODE();\n\n    if (!drv) {\n        return;\n    }\n\n    /* This BDS's file name may depend on any of its children's file names, so\n     * refresh those first */\n    QLIST_FOREACH(child, &bs->children, next) {\n        bdrv_refresh_filename(child->bs);\n    }\n\n    if (bs->implicit) {\n        /* For implicit nodes, just copy everything from the single child */\n        child = QLIST_FIRST(&bs->children);\n        assert(QLIST_NEXT(child, next) == NULL);\n\n        pstrcpy(bs->exact_filename, sizeof(bs->exact_filename),\n                child->bs->exact_filename);\n        pstrcpy(bs->filename, sizeof(bs->filename), child->bs->filename);\n\n        qobject_unref(bs->full_open_options);\n        bs->full_open_options = qobject_ref(child->bs->full_open_options);\n\n        return;\n    }\n\n    backing_overridden = bdrv_backing_overridden(bs);\n\n    if (bs->open_flags & BDRV_O_NO_IO) {\n        /* Without I/O, the backing file does not change anything.\n         * Therefore, in such a case (primarily qemu-img), we can\n         * pretend the backing file has not been overridden even if\n         * it technically has been. */\n        backing_overridden = false;\n    }\n\n    /* Gather the options QDict */\n    opts = qdict_new();\n    generate_json_filename = append_strong_runtime_options(opts, bs);\n    generate_json_filename |= backing_overridden;\n\n    if (drv->bdrv_gather_child_options) {\n        /* Some block drivers may not want to present all of their children's\n         * options, or name them differently from BdrvChild.name */\n        drv->bdrv_gather_child_options(bs, opts, backing_overridden);\n    } else {\n        QLIST_FOREACH(child, &bs->children, next) {\n            if (child == bs->backing && !backing_overridden) {\n                /* We can skip the backing BDS if it has not been overridden */\n                continue;\n            }\n\n            qdict_put(opts, child->name,\n                      qobject_ref(child->bs->full_open_options));\n        }\n\n        if (backing_overridden && !bs->backing) {\n            /* Force no backing file */\n            qdict_put_null(opts, \"backing\");\n        }\n    }\n\n    qobject_unref(bs->full_open_options);\n    bs->full_open_options = opts;\n\n    primary_child_bs = bdrv_primary_bs(bs);\n\n    if (drv->bdrv_refresh_filename) {\n        /* Obsolete information is of no use here, so drop the old file name\n         * information before refreshing it */\n        bs->exact_filename[0] = '\\0';\n\n        drv->bdrv_refresh_filename(bs);\n    } else if (primary_child_bs) {\n        /*\n         * Try to reconstruct valid information from the underlying\n         * file -- this only works for format nodes (filter nodes\n         * cannot be probed and as such must be selected by the user\n         * either through an options dict, or through a special\n         * filename which the filter driver must construct in its\n         * .bdrv_refresh_filename() implementation).\n         */\n\n        bs->exact_filename[0] = '\\0';\n\n        /*\n         * We can use the underlying file's filename if:\n         * - it has a filename,\n         * - the current BDS is not a filter,\n         * - the file is a protocol BDS, and\n         * - opening that file (as this BDS's format) will automatically create\n         *   the BDS tree we have right now, that is:\n         *   - the user did not significantly change this BDS's behavior with\n         *     some explicit (strong) options\n         *   - no non-file child of this BDS has been overridden by the user\n         *   Both of these conditions are represented by generate_json_filename.\n         */\n        if (primary_child_bs->exact_filename[0] &&\n            primary_child_bs->drv->bdrv_file_open &&\n            !drv->is_filter && !generate_json_filename)\n        {\n            strcpy(bs->exact_filename, primary_child_bs->exact_filename);\n        }\n    }\n\n    if (bs->exact_filename[0]) {\n        pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename);\n    } else {\n        GString *json = qobject_to_json(QOBJECT(bs->full_open_options));\n        if (snprintf(bs->filename, sizeof(bs->filename), \"json:%s\",\n                     json->str) >= sizeof(bs->filename)) {\n            /* Give user a hint if we truncated things. */\n            strcpy(bs->filename + sizeof(bs->filename) - 4, \"...\");\n        }\n        g_string_free(json, true);\n    }\n}\n\nchar *bdrv_dirname(BlockDriverState *bs, Error **errp)\n{\n    BlockDriver *drv = bs->drv;\n    BlockDriverState *child_bs;\n\n    GLOBAL_STATE_CODE();\n\n    if (!drv) {\n        error_setg(errp, \"Node '%s' is ejected\", bs->node_name);\n        return NULL;\n    }\n\n    if (drv->bdrv_dirname) {\n        return drv->bdrv_dirname(bs, errp);\n    }\n\n    child_bs = bdrv_primary_bs(bs);\n    if (child_bs) {\n        return bdrv_dirname(child_bs, errp);\n    }\n\n    bdrv_refresh_filename(bs);\n    if (bs->exact_filename[0] != '\\0') {\n        return path_combine(bs->exact_filename, \"\");\n    }\n\n    error_setg(errp, \"Cannot generate a base directory for %s nodes\",\n               drv->format_name);\n    return NULL;\n}\n\n/*\n * Hot add/remove a BDS's child. So the user can take a child offline when\n * it is broken and take a new child online\n */\nvoid bdrv_add_child(BlockDriverState *parent_bs, BlockDriverState *child_bs,\n                    Error **errp)\n{\n    GLOBAL_STATE_CODE();\n    if (!parent_bs->drv || !parent_bs->drv->bdrv_add_child) {\n        error_setg(errp, \"The node %s does not support adding a child\",\n                   bdrv_get_device_or_node_name(parent_bs));\n        return;\n    }\n\n    if (!QLIST_EMPTY(&child_bs->parents)) {\n        error_setg(errp, \"The node %s already has a parent\",\n                   child_bs->node_name);\n        return;\n    }\n\n    parent_bs->drv->bdrv_add_child(parent_bs, child_bs, errp);\n}\n\nvoid bdrv_del_child(BlockDriverState *parent_bs, BdrvChild *child, Error **errp)\n{\n    BdrvChild *tmp;\n\n    GLOBAL_STATE_CODE();\n    if (!parent_bs->drv || !parent_bs->drv->bdrv_del_child) {\n        error_setg(errp, \"The node %s does not support removing a child\",\n                   bdrv_get_device_or_node_name(parent_bs));\n        return;\n    }\n\n    QLIST_FOREACH(tmp, &parent_bs->children, next) {\n        if (tmp == child) {\n            break;\n        }\n    }\n\n    if (!tmp) {\n        error_setg(errp, \"The node %s does not have a child named %s\",\n                   bdrv_get_device_or_node_name(parent_bs),\n                   bdrv_get_device_or_node_name(child->bs));\n        return;\n    }\n\n    parent_bs->drv->bdrv_del_child(parent_bs, child, errp);\n}\n\nint bdrv_make_empty(BdrvChild *c, Error **errp)\n{\n    BlockDriver *drv = c->bs->drv;\n    int ret;\n\n    GLOBAL_STATE_CODE();\n    assert(c->perm & (BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED));\n\n    if (!drv->bdrv_make_empty) {\n        error_setg(errp, \"%s does not support emptying nodes\",\n                   drv->format_name);\n        return -ENOTSUP;\n    }\n\n    ret = drv->bdrv_make_empty(c->bs);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Failed to empty %s\",\n                         c->bs->filename);\n        return ret;\n    }\n\n    return 0;\n}\n\n/*\n * Return the child that @bs acts as an overlay for, and from which data may be\n * copied in COW or COR operations.  Usually this is the backing file.\n */\nBdrvChild *bdrv_cow_child(BlockDriverState *bs)\n{\n    IO_CODE();\n\n    if (!bs || !bs->drv) {\n        return NULL;\n    }\n\n    if (bs->drv->is_filter) {\n        return NULL;\n    }\n\n    if (!bs->backing) {\n        return NULL;\n    }\n\n    assert(bs->backing->role & BDRV_CHILD_COW);\n    return bs->backing;\n}\n\n/*\n * If @bs acts as a filter for exactly one of its children, return\n * that child.\n */\nBdrvChild *bdrv_filter_child(BlockDriverState *bs)\n{\n    BdrvChild *c;\n    IO_CODE();\n\n    if (!bs || !bs->drv) {\n        return NULL;\n    }\n\n    if (!bs->drv->is_filter) {\n        return NULL;\n    }\n\n    /* Only one of @backing or @file may be used */\n    assert(!(bs->backing && bs->file));\n\n    c = bs->backing ?: bs->file;\n    if (!c) {\n        return NULL;\n    }\n\n    assert(c->role & BDRV_CHILD_FILTERED);\n    return c;\n}\n\n/*\n * Return either the result of bdrv_cow_child() or bdrv_filter_child(),\n * whichever is non-NULL.\n *\n * Return NULL if both are NULL.\n */\nBdrvChild *bdrv_filter_or_cow_child(BlockDriverState *bs)\n{\n    BdrvChild *cow_child = bdrv_cow_child(bs);\n    BdrvChild *filter_child = bdrv_filter_child(bs);\n    IO_CODE();\n\n    /* Filter nodes cannot have COW backing files */\n    assert(!(cow_child && filter_child));\n\n    return cow_child ?: filter_child;\n}\n\n/*\n * Return the primary child of this node: For filters, that is the\n * filtered child.  For other nodes, that is usually the child storing\n * metadata.\n * (A generally more helpful description is that this is (usually) the\n * child that has the same filename as @bs.)\n *\n * Drivers do not necessarily have a primary child; for example quorum\n * does not.\n */\nBdrvChild *bdrv_primary_child(BlockDriverState *bs)\n{\n    BdrvChild *c, *found = NULL;\n    IO_CODE();\n\n    QLIST_FOREACH(c, &bs->children, next) {\n        if (c->role & BDRV_CHILD_PRIMARY) {\n            assert(!found);\n            found = c;\n        }\n    }\n\n    return found;\n}\n\nstatic BlockDriverState *bdrv_do_skip_filters(BlockDriverState *bs,\n                                              bool stop_on_explicit_filter)\n{\n    BdrvChild *c;\n\n    if (!bs) {\n        return NULL;\n    }\n\n    while (!(stop_on_explicit_filter && !bs->implicit)) {\n        c = bdrv_filter_child(bs);\n        if (!c) {\n            /*\n             * A filter that is embedded in a working block graph must\n             * have a child.  Assert this here so this function does\n             * not return a filter node that is not expected by the\n             * caller.\n             */\n            assert(!bs->drv || !bs->drv->is_filter);\n            break;\n        }\n        bs = c->bs;\n    }\n    /*\n     * Note that this treats nodes with bs->drv == NULL as not being\n     * filters (bs->drv == NULL should be replaced by something else\n     * anyway).\n     * The advantage of this behavior is that this function will thus\n     * always return a non-NULL value (given a non-NULL @bs).\n     */\n\n    return bs;\n}\n\n/*\n * Return the first BDS that has not been added implicitly or that\n * does not have a filtered child down the chain starting from @bs\n * (including @bs itself).\n */\nBlockDriverState *bdrv_skip_implicit_filters(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    return bdrv_do_skip_filters(bs, true);\n}\n\n/*\n * Return the first BDS that does not have a filtered child down the\n * chain starting from @bs (including @bs itself).\n */\nBlockDriverState *bdrv_skip_filters(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bdrv_do_skip_filters(bs, false);\n}\n\n/*\n * For a backing chain, return the first non-filter backing image of\n * the first non-filter image.\n */\nBlockDriverState *bdrv_backing_chain_next(BlockDriverState *bs)\n{\n    IO_CODE();\n    return bdrv_skip_filters(bdrv_cow_bs(bdrv_skip_filters(bs)));\n}\n\n/**\n * Check whether [offset, offset + bytes) overlaps with the cached\n * block-status data region.\n *\n * If so, and @pnum is not NULL, set *pnum to `bsc.data_end - offset`,\n * which is what bdrv_bsc_is_data()'s interface needs.\n * Otherwise, *pnum is not touched.\n */\nstatic bool bdrv_bsc_range_overlaps_locked(BlockDriverState *bs,\n                                           int64_t offset, int64_t bytes,\n                                           int64_t *pnum)\n{\n    BdrvBlockStatusCache *bsc = qatomic_rcu_read(&bs->block_status_cache);\n    bool overlaps;\n\n    overlaps =\n        qatomic_read(&bsc->valid) &&\n        ranges_overlap(offset, bytes, bsc->data_start,\n                       bsc->data_end - bsc->data_start);\n\n    if (overlaps && pnum) {\n        *pnum = bsc->data_end - offset;\n    }\n\n    return overlaps;\n}\n\n/**\n * See block_int.h for this function's documentation.\n */\nbool bdrv_bsc_is_data(BlockDriverState *bs, int64_t offset, int64_t *pnum)\n{\n    IO_CODE();\n    RCU_READ_LOCK_GUARD();\n    return bdrv_bsc_range_overlaps_locked(bs, offset, 1, pnum);\n}\n\n/**\n * See block_int.h for this function's documentation.\n */\nvoid bdrv_bsc_invalidate_range(BlockDriverState *bs,\n                               int64_t offset, int64_t bytes)\n{\n    IO_CODE();\n    RCU_READ_LOCK_GUARD();\n\n    if (bdrv_bsc_range_overlaps_locked(bs, offset, bytes, NULL)) {\n        qatomic_set(&bs->block_status_cache->valid, false);\n    }\n}\n\n/**\n * See block_int.h for this function's documentation.\n */\nvoid bdrv_bsc_fill(BlockDriverState *bs, int64_t offset, int64_t bytes)\n{\n    BdrvBlockStatusCache *new_bsc = g_new(BdrvBlockStatusCache, 1);\n    BdrvBlockStatusCache *old_bsc;\n    IO_CODE();\n\n    *new_bsc = (BdrvBlockStatusCache) {\n        .valid = true,\n        .data_start = offset,\n        .data_end = offset + bytes,\n    };\n\n    QEMU_LOCK_GUARD(&bs->bsc_modify_lock);\n\n    old_bsc = qatomic_rcu_read(&bs->block_status_cache);\n    qatomic_rcu_set(&bs->block_status_cache, new_bsc);\n    if (old_bsc) {\n        g_free_rcu(old_bsc, rcu);\n    }\n}\n"
        },
        {
          "name": "block",
          "type": "tree",
          "content": null
        },
        {
          "name": "blockdev-nbd.c",
          "type": "blob",
          "size": 7.70703125,
          "content": "/*\n * Serving QEMU block devices via NBD\n *\n * Copyright (c) 2012 Red Hat, Inc.\n *\n * Author: Paolo Bonzini <pbonzini@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or\n * later.  See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/blockdev.h\"\n#include \"sysemu/block-backend.h\"\n#include \"hw/block/block.h\"\n#include \"qapi/error.h\"\n#include \"qapi/clone-visitor.h\"\n#include \"qapi/qapi-visit-block-export.h\"\n#include \"qapi/qapi-commands-block-export.h\"\n#include \"block/nbd.h\"\n#include \"io/channel-socket.h\"\n#include \"io/net-listener.h\"\n\ntypedef struct NBDServerData {\n    QIONetListener *listener;\n    QCryptoTLSCreds *tlscreds;\n    char *tlsauthz;\n    uint32_t max_connections;\n    uint32_t connections;\n} NBDServerData;\n\nstatic NBDServerData *nbd_server;\nstatic int qemu_nbd_connections = -1; /* Non-negative if this is qemu-nbd */\n\nstatic void nbd_update_server_watch(NBDServerData *s);\n\nvoid nbd_server_is_qemu_nbd(int max_connections)\n{\n    qemu_nbd_connections = max_connections;\n}\n\nbool nbd_server_is_running(void)\n{\n    return nbd_server || qemu_nbd_connections >= 0;\n}\n\nint nbd_server_max_connections(void)\n{\n    return nbd_server ? nbd_server->max_connections : qemu_nbd_connections;\n}\n\nstatic void nbd_blockdev_client_closed(NBDClient *client, bool ignored)\n{\n    nbd_client_put(client);\n    assert(nbd_server->connections > 0);\n    nbd_server->connections--;\n    nbd_update_server_watch(nbd_server);\n}\n\nstatic void nbd_accept(QIONetListener *listener, QIOChannelSocket *cioc,\n                       gpointer opaque)\n{\n    nbd_server->connections++;\n    nbd_update_server_watch(nbd_server);\n\n    qio_channel_set_name(QIO_CHANNEL(cioc), \"nbd-server\");\n    nbd_client_new(cioc, nbd_server->tlscreds, nbd_server->tlsauthz,\n                   nbd_blockdev_client_closed);\n}\n\nstatic void nbd_update_server_watch(NBDServerData *s)\n{\n    if (!s->max_connections || s->connections < s->max_connections) {\n        qio_net_listener_set_client_func(s->listener, nbd_accept, NULL, NULL);\n    } else {\n        qio_net_listener_set_client_func(s->listener, NULL, NULL, NULL);\n    }\n}\n\nstatic void nbd_server_free(NBDServerData *server)\n{\n    if (!server) {\n        return;\n    }\n\n    qio_net_listener_disconnect(server->listener);\n    object_unref(OBJECT(server->listener));\n    if (server->tlscreds) {\n        object_unref(OBJECT(server->tlscreds));\n    }\n    g_free(server->tlsauthz);\n\n    g_free(server);\n}\n\nstatic QCryptoTLSCreds *nbd_get_tls_creds(const char *id, Error **errp)\n{\n    Object *obj;\n    QCryptoTLSCreds *creds;\n\n    obj = object_resolve_path_component(\n        object_get_objects_root(), id);\n    if (!obj) {\n        error_setg(errp, \"No TLS credentials with id '%s'\",\n                   id);\n        return NULL;\n    }\n    creds = (QCryptoTLSCreds *)\n        object_dynamic_cast(obj, TYPE_QCRYPTO_TLS_CREDS);\n    if (!creds) {\n        error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n                   id);\n        return NULL;\n    }\n\n    if (!qcrypto_tls_creds_check_endpoint(creds,\n                                          QCRYPTO_TLS_CREDS_ENDPOINT_SERVER,\n                                          errp)) {\n        return NULL;\n    }\n    object_ref(obj);\n    return creds;\n}\n\n\nvoid nbd_server_start(SocketAddress *addr, const char *tls_creds,\n                      const char *tls_authz, uint32_t max_connections,\n                      Error **errp)\n{\n    if (nbd_server) {\n        error_setg(errp, \"NBD server already running\");\n        return;\n    }\n\n    nbd_server = g_new0(NBDServerData, 1);\n    nbd_server->max_connections = max_connections;\n    nbd_server->listener = qio_net_listener_new();\n\n    qio_net_listener_set_name(nbd_server->listener,\n                              \"nbd-listener\");\n\n    /*\n     * Because this server is persistent, a backlog of SOMAXCONN is\n     * better than trying to size it to max_connections.\n     */\n    if (qio_net_listener_open_sync(nbd_server->listener, addr, SOMAXCONN,\n                                   errp) < 0) {\n        goto error;\n    }\n\n    if (tls_creds) {\n        nbd_server->tlscreds = nbd_get_tls_creds(tls_creds, errp);\n        if (!nbd_server->tlscreds) {\n            goto error;\n        }\n    }\n\n    nbd_server->tlsauthz = g_strdup(tls_authz);\n\n    nbd_update_server_watch(nbd_server);\n\n    return;\n\n error:\n    nbd_server_free(nbd_server);\n    nbd_server = NULL;\n}\n\nvoid nbd_server_start_options(NbdServerOptions *arg, Error **errp)\n{\n    nbd_server_start(arg->addr, arg->tls_creds, arg->tls_authz,\n                     arg->max_connections, errp);\n}\n\nvoid qmp_nbd_server_start(SocketAddressLegacy *addr,\n                          bool has_tls_creds, const char *tls_creds,\n                          bool has_tls_authz, const char *tls_authz,\n                          bool has_max_connections, uint32_t max_connections,\n                          Error **errp)\n{\n    SocketAddress *addr_flat = socket_address_flatten(addr);\n\n    nbd_server_start(addr_flat, tls_creds, tls_authz, max_connections, errp);\n    qapi_free_SocketAddress(addr_flat);\n}\n\nvoid qmp_nbd_server_add(NbdServerAddOptions *arg, Error **errp)\n{\n    BlockExport *export;\n    BlockDriverState *bs;\n    BlockBackend *on_eject_blk;\n    BlockExportOptions *export_opts;\n\n    bs = bdrv_lookup_bs(arg->device, arg->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    /*\n     * block-export-add would default to the node-name, but we may have to use\n     * the device name as a default here for compatibility.\n     */\n    if (!arg->has_name) {\n        arg->has_name = true;\n        arg->name = g_strdup(arg->device);\n    }\n\n    export_opts = g_new(BlockExportOptions, 1);\n    *export_opts = (BlockExportOptions) {\n        .type                   = BLOCK_EXPORT_TYPE_NBD,\n        .id                     = g_strdup(arg->name),\n        .node_name              = g_strdup(bdrv_get_node_name(bs)),\n        .has_writable           = arg->has_writable,\n        .writable               = arg->writable,\n    };\n    QAPI_CLONE_MEMBERS(BlockExportOptionsNbdBase, &export_opts->u.nbd,\n                       qapi_NbdServerAddOptions_base(arg));\n    if (arg->has_bitmap) {\n        BlockDirtyBitmapOrStr *el = g_new(BlockDirtyBitmapOrStr, 1);\n\n        *el = (BlockDirtyBitmapOrStr) {\n            .type = QTYPE_QSTRING,\n            .u.local = g_strdup(arg->bitmap),\n        };\n        export_opts->u.nbd.has_bitmaps = true;\n        QAPI_LIST_PREPEND(export_opts->u.nbd.bitmaps, el);\n    }\n\n    /*\n     * nbd-server-add doesn't complain when a read-only device should be\n     * exported as writable, but simply downgrades it. This is an error with\n     * block-export-add.\n     */\n    if (bdrv_is_read_only(bs)) {\n        export_opts->has_writable = true;\n        export_opts->writable = false;\n    }\n\n    export = blk_exp_add(export_opts, errp);\n    if (!export) {\n        goto fail;\n    }\n\n    /*\n     * nbd-server-add removes the export when the named BlockBackend used for\n     * @device goes away.\n     */\n    on_eject_blk = blk_by_name(arg->device);\n    if (on_eject_blk) {\n        nbd_export_set_on_eject_blk(export, on_eject_blk);\n    }\n\nfail:\n    qapi_free_BlockExportOptions(export_opts);\n}\n\nvoid qmp_nbd_server_remove(const char *name,\n                           bool has_mode, BlockExportRemoveMode mode,\n                           Error **errp)\n{\n    BlockExport *exp;\n\n    exp = blk_exp_find(name);\n    if (exp && exp->drv->type != BLOCK_EXPORT_TYPE_NBD) {\n        error_setg(errp, \"Block export '%s' is not an NBD export\", name);\n        return;\n    }\n\n    qmp_block_export_del(name, has_mode, mode, errp);\n}\n\nvoid qmp_nbd_server_stop(Error **errp)\n{\n    if (!nbd_server) {\n        error_setg(errp, \"NBD server not running\");\n        return;\n    }\n\n    blk_exp_close_all_type(BLOCK_EXPORT_TYPE_NBD);\n\n    nbd_server_free(nbd_server);\n    nbd_server = NULL;\n}\n"
        },
        {
          "name": "blockdev.c",
          "type": "blob",
          "size": 117.171875,
          "content": "/*\n * QEMU host block devices\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or\n * later.  See the COPYING file in the top-level directory.\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"sysemu/block-backend.h\"\n#include \"sysemu/blockdev.h\"\n#include \"hw/block/block.h\"\n#include \"block/blockjob.h\"\n#include \"block/qdict.h\"\n#include \"block/throttle-groups.h\"\n#include \"monitor/monitor.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/option.h\"\n#include \"qemu/qemu-print.h\"\n#include \"qemu/config-file.h\"\n#include \"qapi/qapi-commands-block.h\"\n#include \"qapi/qapi-commands-transaction.h\"\n#include \"qapi/qapi-visit-block-core.h\"\n#include \"qapi/qmp/qdict.h\"\n#include \"qapi/qmp/qnum.h\"\n#include \"qapi/qmp/qstring.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qapi/qmp/qlist.h\"\n#include \"qapi/qobject-output-visitor.h\"\n#include \"sysemu/sysemu.h\"\n#include \"sysemu/iothread.h\"\n#include \"block/block_int.h\"\n#include \"block/trace.h\"\n#include \"sysemu/runstate.h\"\n#include \"sysemu/replay.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/help_option.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/throttle-options.h\"\n\n/* Protected by BQL */\nQTAILQ_HEAD(, BlockDriverState) monitor_bdrv_states =\n    QTAILQ_HEAD_INITIALIZER(monitor_bdrv_states);\n\nvoid bdrv_set_monitor_owned(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    QTAILQ_INSERT_TAIL(&monitor_bdrv_states, bs, monitor_list);\n}\n\nstatic const char *const if_name[IF_COUNT] = {\n    [IF_NONE] = \"none\",\n    [IF_IDE] = \"ide\",\n    [IF_SCSI] = \"scsi\",\n    [IF_FLOPPY] = \"floppy\",\n    [IF_PFLASH] = \"pflash\",\n    [IF_MTD] = \"mtd\",\n    [IF_SD] = \"sd\",\n    [IF_VIRTIO] = \"virtio\",\n    [IF_XEN] = \"xen\",\n};\n\nstatic int if_max_devs[IF_COUNT] = {\n    /*\n     * Do not change these numbers!  They govern how drive option\n     * index maps to unit and bus.  That mapping is ABI.\n     *\n     * All controllers used to implement if=T drives need to support\n     * if_max_devs[T] units, for any T with if_max_devs[T] != 0.\n     * Otherwise, some index values map to \"impossible\" bus, unit\n     * values.\n     *\n     * For instance, if you change [IF_SCSI] to 255, -drive\n     * if=scsi,index=12 no longer means bus=1,unit=5, but\n     * bus=0,unit=12.  With an lsi53c895a controller (7 units max),\n     * the drive can't be set up.  Regression.\n     */\n    [IF_IDE] = 2,\n    [IF_SCSI] = 7,\n};\n\n/**\n * Boards may call this to offer board-by-board overrides\n * of the default, global values.\n */\nvoid override_max_devs(BlockInterfaceType type, int max_devs)\n{\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n\n    GLOBAL_STATE_CODE();\n\n    if (max_devs <= 0) {\n        return;\n    }\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (dinfo->type == type) {\n            fprintf(stderr, \"Cannot override units-per-bus property of\"\n                    \" the %s interface, because a drive of that type has\"\n                    \" already been added.\\n\", if_name[type]);\n            g_assert_not_reached();\n        }\n    }\n\n    if_max_devs[type] = max_devs;\n}\n\n/*\n * We automatically delete the drive when a device using it gets\n * unplugged.  Questionable feature, but we can't just drop it.\n * Device models call blockdev_mark_auto_del() to schedule the\n * automatic deletion, and generic qdev code calls blockdev_auto_del()\n * when deletion is actually safe.\n */\nvoid blockdev_mark_auto_del(BlockBackend *blk)\n{\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n    BlockJob *job;\n\n    GLOBAL_STATE_CODE();\n\n    if (!dinfo) {\n        return;\n    }\n\n    for (job = block_job_next(NULL); job; job = block_job_next(job)) {\n        if (block_job_has_bdrv(job, blk_bs(blk))) {\n            AioContext *aio_context = job->job.aio_context;\n            aio_context_acquire(aio_context);\n\n            job_cancel(&job->job, false);\n\n            aio_context_release(aio_context);\n        }\n    }\n\n    dinfo->auto_del = 1;\n}\n\nvoid blockdev_auto_del(BlockBackend *blk)\n{\n    DriveInfo *dinfo = blk_legacy_dinfo(blk);\n    GLOBAL_STATE_CODE();\n\n    if (dinfo && dinfo->auto_del) {\n        monitor_remove_blk(blk);\n        blk_unref(blk);\n    }\n}\n\nstatic int drive_index_to_bus_id(BlockInterfaceType type, int index)\n{\n    int max_devs = if_max_devs[type];\n    return max_devs ? index / max_devs : 0;\n}\n\nstatic int drive_index_to_unit_id(BlockInterfaceType type, int index)\n{\n    int max_devs = if_max_devs[type];\n    return max_devs ? index % max_devs : index;\n}\n\nQemuOpts *drive_add(BlockInterfaceType type, int index, const char *file,\n                    const char *optstr)\n{\n    QemuOpts *opts;\n\n    GLOBAL_STATE_CODE();\n\n    opts = qemu_opts_parse_noisily(qemu_find_opts(\"drive\"), optstr, false);\n    if (!opts) {\n        return NULL;\n    }\n    if (type != IF_DEFAULT) {\n        qemu_opt_set(opts, \"if\", if_name[type], &error_abort);\n    }\n    if (index >= 0) {\n        qemu_opt_set_number(opts, \"index\", index, &error_abort);\n    }\n    if (file)\n        qemu_opt_set(opts, \"file\", file, &error_abort);\n    return opts;\n}\n\nDriveInfo *drive_get(BlockInterfaceType type, int bus, int unit)\n{\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n\n    GLOBAL_STATE_CODE();\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (dinfo && dinfo->type == type\n            && dinfo->bus == bus && dinfo->unit == unit) {\n            return dinfo;\n        }\n    }\n\n    return NULL;\n}\n\n/*\n * Check board claimed all -drive that are meant to be claimed.\n * Fatal error if any remain unclaimed.\n */\nvoid drive_check_orphaned(void)\n{\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n    Location loc;\n    bool orphans = false;\n\n    GLOBAL_STATE_CODE();\n\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        /*\n         * Ignore default drives, because we create certain default\n         * drives unconditionally, then leave them unclaimed.  Not the\n         * users fault.\n         * Ignore IF_VIRTIO, because it gets desugared into -device,\n         * so we can leave failing to -device.\n         * Ignore IF_NONE, because leaving unclaimed IF_NONE remains\n         * available for device_add is a feature.\n         */\n        if (dinfo->is_default || dinfo->type == IF_VIRTIO\n            || dinfo->type == IF_NONE) {\n            continue;\n        }\n        if (!blk_get_attached_dev(blk)) {\n            loc_push_none(&loc);\n            qemu_opts_loc_restore(dinfo->opts);\n            error_report(\"machine type does not support\"\n                         \" if=%s,bus=%d,unit=%d\",\n                         if_name[dinfo->type], dinfo->bus, dinfo->unit);\n            loc_pop(&loc);\n            orphans = true;\n        }\n    }\n\n    if (orphans) {\n        exit(1);\n    }\n}\n\nDriveInfo *drive_get_by_index(BlockInterfaceType type, int index)\n{\n    GLOBAL_STATE_CODE();\n    return drive_get(type,\n                     drive_index_to_bus_id(type, index),\n                     drive_index_to_unit_id(type, index));\n}\n\nint drive_get_max_bus(BlockInterfaceType type)\n{\n    int max_bus;\n    BlockBackend *blk;\n    DriveInfo *dinfo;\n\n    GLOBAL_STATE_CODE();\n\n    max_bus = -1;\n    for (blk = blk_next(NULL); blk; blk = blk_next(blk)) {\n        dinfo = blk_legacy_dinfo(blk);\n        if (dinfo && dinfo->type == type && dinfo->bus > max_bus) {\n            max_bus = dinfo->bus;\n        }\n    }\n    return max_bus;\n}\n\nstatic void bdrv_format_print(void *opaque, const char *name)\n{\n    qemu_printf(\" %s\", name);\n}\n\ntypedef struct {\n    QEMUBH *bh;\n    BlockDriverState *bs;\n} BDRVPutRefBH;\n\nstatic int parse_block_error_action(const char *buf, bool is_read, Error **errp)\n{\n    if (!strcmp(buf, \"ignore\")) {\n        return BLOCKDEV_ON_ERROR_IGNORE;\n    } else if (!is_read && !strcmp(buf, \"enospc\")) {\n        return BLOCKDEV_ON_ERROR_ENOSPC;\n    } else if (!strcmp(buf, \"stop\")) {\n        return BLOCKDEV_ON_ERROR_STOP;\n    } else if (!strcmp(buf, \"report\")) {\n        return BLOCKDEV_ON_ERROR_REPORT;\n    } else {\n        error_setg(errp, \"'%s' invalid %s error action\",\n                   buf, is_read ? \"read\" : \"write\");\n        return -1;\n    }\n}\n\nstatic bool parse_stats_intervals(BlockAcctStats *stats, QList *intervals,\n                                  Error **errp)\n{\n    const QListEntry *entry;\n    for (entry = qlist_first(intervals); entry; entry = qlist_next(entry)) {\n        switch (qobject_type(entry->value)) {\n\n        case QTYPE_QSTRING: {\n            unsigned long long length;\n            const char *str = qstring_get_str(qobject_to(QString,\n                                                         entry->value));\n            if (parse_uint_full(str, &length, 10) == 0 &&\n                length > 0 && length <= UINT_MAX) {\n                block_acct_add_interval(stats, (unsigned) length);\n            } else {\n                error_setg(errp, \"Invalid interval length: %s\", str);\n                return false;\n            }\n            break;\n        }\n\n        case QTYPE_QNUM: {\n            int64_t length = qnum_get_int(qobject_to(QNum, entry->value));\n\n            if (length > 0 && length <= UINT_MAX) {\n                block_acct_add_interval(stats, (unsigned) length);\n            } else {\n                error_setg(errp, \"Invalid interval length: %\" PRId64, length);\n                return false;\n            }\n            break;\n        }\n\n        default:\n            error_setg(errp, \"The specification of stats-intervals is invalid\");\n            return false;\n        }\n    }\n    return true;\n}\n\ntypedef enum { MEDIA_DISK, MEDIA_CDROM } DriveMediaType;\n\n/* All parameters but @opts are optional and may be set to NULL. */\nstatic void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,\n    const char **throttling_group, ThrottleConfig *throttle_cfg,\n    BlockdevDetectZeroesOptions *detect_zeroes, Error **errp)\n{\n    Error *local_error = NULL;\n    const char *aio;\n\n    if (bdrv_flags) {\n        if (qemu_opt_get_bool(opts, \"copy-on-read\", false)) {\n            *bdrv_flags |= BDRV_O_COPY_ON_READ;\n        }\n\n        if ((aio = qemu_opt_get(opts, \"aio\")) != NULL) {\n            if (bdrv_parse_aio(aio, bdrv_flags) < 0) {\n                error_setg(errp, \"invalid aio option\");\n                return;\n            }\n        }\n    }\n\n    /* disk I/O throttling */\n    if (throttling_group) {\n        *throttling_group = qemu_opt_get(opts, \"throttling.group\");\n    }\n\n    if (throttle_cfg) {\n        throttle_config_init(throttle_cfg);\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].avg =\n            qemu_opt_get_number(opts, \"throttling.bps-total\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_READ].avg  =\n            qemu_opt_get_number(opts, \"throttling.bps-read\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].avg =\n            qemu_opt_get_number(opts, \"throttling.bps-write\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].avg =\n            qemu_opt_get_number(opts, \"throttling.iops-total\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_READ].avg =\n            qemu_opt_get_number(opts, \"throttling.iops-read\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].avg =\n            qemu_opt_get_number(opts, \"throttling.iops-write\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].max =\n            qemu_opt_get_number(opts, \"throttling.bps-total-max\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_READ].max  =\n            qemu_opt_get_number(opts, \"throttling.bps-read-max\", 0);\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].max =\n            qemu_opt_get_number(opts, \"throttling.bps-write-max\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].max =\n            qemu_opt_get_number(opts, \"throttling.iops-total-max\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_READ].max =\n            qemu_opt_get_number(opts, \"throttling.iops-read-max\", 0);\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].max =\n            qemu_opt_get_number(opts, \"throttling.iops-write-max\", 0);\n\n        throttle_cfg->buckets[THROTTLE_BPS_TOTAL].burst_length =\n            qemu_opt_get_number(opts, \"throttling.bps-total-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_BPS_READ].burst_length  =\n            qemu_opt_get_number(opts, \"throttling.bps-read-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_BPS_WRITE].burst_length =\n            qemu_opt_get_number(opts, \"throttling.bps-write-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_OPS_TOTAL].burst_length =\n            qemu_opt_get_number(opts, \"throttling.iops-total-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_OPS_READ].burst_length =\n            qemu_opt_get_number(opts, \"throttling.iops-read-max-length\", 1);\n        throttle_cfg->buckets[THROTTLE_OPS_WRITE].burst_length =\n            qemu_opt_get_number(opts, \"throttling.iops-write-max-length\", 1);\n\n        throttle_cfg->op_size =\n            qemu_opt_get_number(opts, \"throttling.iops-size\", 0);\n\n        if (!throttle_is_valid(throttle_cfg, errp)) {\n            return;\n        }\n    }\n\n    if (detect_zeroes) {\n        *detect_zeroes =\n            qapi_enum_parse(&BlockdevDetectZeroesOptions_lookup,\n                            qemu_opt_get(opts, \"detect-zeroes\"),\n                            BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n                            &local_error);\n        if (local_error) {\n            error_propagate(errp, local_error);\n            return;\n        }\n    }\n}\n\n/* Takes the ownership of bs_opts */\nstatic BlockBackend *blockdev_init(const char *file, QDict *bs_opts,\n                                   Error **errp)\n{\n    const char *buf;\n    int bdrv_flags = 0;\n    int on_read_error, on_write_error;\n    bool account_invalid, account_failed;\n    bool writethrough, read_only;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    ThrottleConfig cfg;\n    int snapshot = 0;\n    Error *error = NULL;\n    QemuOpts *opts;\n    QDict *interval_dict = NULL;\n    QList *interval_list = NULL;\n    const char *id;\n    BlockdevDetectZeroesOptions detect_zeroes =\n        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF;\n    const char *throttling_group = NULL;\n\n    /* Check common options by copying from bs_opts to opts, all other options\n     * stay in bs_opts for processing by bdrv_open(). */\n    id = qdict_get_try_str(bs_opts, \"id\");\n    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, errp);\n    if (!opts) {\n        goto err_no_opts;\n    }\n\n    if (!qemu_opts_absorb_qdict(opts, bs_opts, errp)) {\n        goto early_err;\n    }\n\n    if (id) {\n        qdict_del(bs_opts, \"id\");\n    }\n\n    /* extract parameters */\n    snapshot = qemu_opt_get_bool(opts, \"snapshot\", 0);\n\n    account_invalid = qemu_opt_get_bool(opts, \"stats-account-invalid\", true);\n    account_failed = qemu_opt_get_bool(opts, \"stats-account-failed\", true);\n\n    writethrough = !qemu_opt_get_bool(opts, BDRV_OPT_CACHE_WB, true);\n\n    id = qemu_opts_id(opts);\n\n    qdict_extract_subqdict(bs_opts, &interval_dict, \"stats-intervals.\");\n    qdict_array_split(interval_dict, &interval_list);\n\n    if (qdict_size(interval_dict) != 0) {\n        error_setg(errp, \"Invalid option stats-intervals.%s\",\n                   qdict_first(interval_dict)->key);\n        goto early_err;\n    }\n\n    extract_common_blockdev_options(opts, &bdrv_flags, &throttling_group, &cfg,\n                                    &detect_zeroes, &error);\n    if (error) {\n        error_propagate(errp, error);\n        goto early_err;\n    }\n\n    if ((buf = qemu_opt_get(opts, \"format\")) != NULL) {\n        if (is_help_option(buf)) {\n            qemu_printf(\"Supported formats:\");\n            bdrv_iterate_format(bdrv_format_print, NULL, false);\n            qemu_printf(\"\\nSupported formats (read-only):\");\n            bdrv_iterate_format(bdrv_format_print, NULL, true);\n            qemu_printf(\"\\n\");\n            goto early_err;\n        }\n\n        if (qdict_haskey(bs_opts, \"driver\")) {\n            error_setg(errp, \"Cannot specify both 'driver' and 'format'\");\n            goto early_err;\n        }\n        qdict_put_str(bs_opts, \"driver\", buf);\n    }\n\n    on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;\n    if ((buf = qemu_opt_get(opts, \"werror\")) != NULL) {\n        on_write_error = parse_block_error_action(buf, 0, &error);\n        if (error) {\n            error_propagate(errp, error);\n            goto early_err;\n        }\n    }\n\n    on_read_error = BLOCKDEV_ON_ERROR_REPORT;\n    if ((buf = qemu_opt_get(opts, \"rerror\")) != NULL) {\n        on_read_error = parse_block_error_action(buf, 1, &error);\n        if (error) {\n            error_propagate(errp, error);\n            goto early_err;\n        }\n    }\n\n    if (snapshot) {\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n    }\n\n    read_only = qemu_opt_get_bool(opts, BDRV_OPT_READ_ONLY, false);\n\n    /* init */\n    if ((!file || !*file) && !qdict_size(bs_opts)) {\n        BlockBackendRootState *blk_rs;\n\n        blk = blk_new(qemu_get_aio_context(), 0, BLK_PERM_ALL);\n        blk_rs = blk_get_root_state(blk);\n        blk_rs->open_flags    = bdrv_flags | (read_only ? 0 : BDRV_O_RDWR);\n        blk_rs->detect_zeroes = detect_zeroes;\n\n        qobject_unref(bs_opts);\n    } else {\n        if (file && !*file) {\n            file = NULL;\n        }\n\n        /* bdrv_open() defaults to the values in bdrv_flags (for compatibility\n         * with other callers) rather than what we want as the real defaults.\n         * Apply the defaults here instead. */\n        qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_DIRECT, \"off\");\n        qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_NO_FLUSH, \"off\");\n        qdict_set_default_str(bs_opts, BDRV_OPT_READ_ONLY,\n                              read_only ? \"on\" : \"off\");\n        qdict_set_default_str(bs_opts, BDRV_OPT_AUTO_READ_ONLY, \"on\");\n        assert((bdrv_flags & BDRV_O_CACHE_MASK) == 0);\n\n        if (runstate_check(RUN_STATE_INMIGRATE)) {\n            bdrv_flags |= BDRV_O_INACTIVE;\n        }\n\n        blk = blk_new_open(file, NULL, bs_opts, bdrv_flags, errp);\n        if (!blk) {\n            goto err_no_bs_opts;\n        }\n        bs = blk_bs(blk);\n\n        bs->detect_zeroes = detect_zeroes;\n\n        block_acct_setup(blk_get_stats(blk), account_invalid, account_failed);\n\n        if (!parse_stats_intervals(blk_get_stats(blk), interval_list, errp)) {\n            blk_unref(blk);\n            blk = NULL;\n            goto err_no_bs_opts;\n        }\n    }\n\n    /* disk I/O throttling */\n    if (throttle_enabled(&cfg)) {\n        if (!throttling_group) {\n            throttling_group = id;\n        }\n        blk_io_limits_enable(blk, throttling_group);\n        blk_set_io_limits(blk, &cfg);\n    }\n\n    blk_set_enable_write_cache(blk, !writethrough);\n    blk_set_on_error(blk, on_read_error, on_write_error);\n\n    if (!monitor_add_blk(blk, id, errp)) {\n        blk_unref(blk);\n        blk = NULL;\n        goto err_no_bs_opts;\n    }\n\nerr_no_bs_opts:\n    qemu_opts_del(opts);\n    qobject_unref(interval_dict);\n    qobject_unref(interval_list);\n    return blk;\n\nearly_err:\n    qemu_opts_del(opts);\n    qobject_unref(interval_dict);\n    qobject_unref(interval_list);\nerr_no_opts:\n    qobject_unref(bs_opts);\n    return NULL;\n}\n\n/* Takes the ownership of bs_opts */\nBlockDriverState *bds_tree_init(QDict *bs_opts, Error **errp)\n{\n    int bdrv_flags = 0;\n\n    GLOBAL_STATE_CODE();\n    /* bdrv_open() defaults to the values in bdrv_flags (for compatibility\n     * with other callers) rather than what we want as the real defaults.\n     * Apply the defaults here instead. */\n    qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_DIRECT, \"off\");\n    qdict_set_default_str(bs_opts, BDRV_OPT_CACHE_NO_FLUSH, \"off\");\n    qdict_set_default_str(bs_opts, BDRV_OPT_READ_ONLY, \"off\");\n\n    if (runstate_check(RUN_STATE_INMIGRATE)) {\n        bdrv_flags |= BDRV_O_INACTIVE;\n    }\n\n    return bdrv_open(NULL, NULL, bs_opts, bdrv_flags, errp);\n}\n\nvoid blockdev_close_all_bdrv_states(void)\n{\n    BlockDriverState *bs, *next_bs;\n\n    GLOBAL_STATE_CODE();\n    QTAILQ_FOREACH_SAFE(bs, &monitor_bdrv_states, monitor_list, next_bs) {\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        aio_context_acquire(ctx);\n        bdrv_unref(bs);\n        aio_context_release(ctx);\n    }\n}\n\n/* Iterates over the list of monitor-owned BlockDriverStates */\nBlockDriverState *bdrv_next_monitor_owned(BlockDriverState *bs)\n{\n    GLOBAL_STATE_CODE();\n    return bs ? QTAILQ_NEXT(bs, monitor_list)\n              : QTAILQ_FIRST(&monitor_bdrv_states);\n}\n\nstatic bool qemu_opt_rename(QemuOpts *opts, const char *from, const char *to,\n                            Error **errp)\n{\n    const char *value;\n\n    value = qemu_opt_get(opts, from);\n    if (value) {\n        if (qemu_opt_find(opts, to)) {\n            error_setg(errp, \"'%s' and its alias '%s' can't be used at the \"\n                       \"same time\", to, from);\n            return false;\n        }\n    }\n\n    /* rename all items in opts */\n    while ((value = qemu_opt_get(opts, from))) {\n        qemu_opt_set(opts, to, value, &error_abort);\n        qemu_opt_unset(opts, from);\n    }\n    return true;\n}\n\nQemuOptsList qemu_legacy_drive_opts = {\n    .name = \"drive\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_legacy_drive_opts.head),\n    .desc = {\n        {\n            .name = \"bus\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"bus number\",\n        },{\n            .name = \"unit\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"unit number (i.e. lun for scsi)\",\n        },{\n            .name = \"index\",\n            .type = QEMU_OPT_NUMBER,\n            .help = \"index number\",\n        },{\n            .name = \"media\",\n            .type = QEMU_OPT_STRING,\n            .help = \"media type (disk, cdrom)\",\n        },{\n            .name = \"if\",\n            .type = QEMU_OPT_STRING,\n            .help = \"interface (ide, scsi, sd, mtd, floppy, pflash, virtio)\",\n        },{\n            .name = \"file\",\n            .type = QEMU_OPT_STRING,\n            .help = \"file name\",\n        },\n\n        /* Options that are passed on, but have special semantics with -drive */\n        {\n            .name = BDRV_OPT_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"open drive file as read-only\",\n        },{\n            .name = \"rerror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"read error action\",\n        },{\n            .name = \"werror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"write error action\",\n        },{\n            .name = \"copy-on-read\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"copy read data from backing file into image file\",\n        },\n\n        { /* end of list */ }\n    },\n};\n\nDriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type,\n                     Error **errp)\n{\n    const char *value;\n    BlockBackend *blk;\n    DriveInfo *dinfo = NULL;\n    QDict *bs_opts;\n    QemuOpts *legacy_opts;\n    DriveMediaType media = MEDIA_DISK;\n    BlockInterfaceType type;\n    int max_devs, bus_id, unit_id, index;\n    const char *werror, *rerror;\n    bool read_only = false;\n    bool copy_on_read;\n    const char *filename;\n    int i;\n\n    GLOBAL_STATE_CODE();\n\n    /* Change legacy command line options into QMP ones */\n    static const struct {\n        const char *from;\n        const char *to;\n    } opt_renames[] = {\n        { \"iops\",           \"throttling.iops-total\" },\n        { \"iops_rd\",        \"throttling.iops-read\" },\n        { \"iops_wr\",        \"throttling.iops-write\" },\n\n        { \"bps\",            \"throttling.bps-total\" },\n        { \"bps_rd\",         \"throttling.bps-read\" },\n        { \"bps_wr\",         \"throttling.bps-write\" },\n\n        { \"iops_max\",       \"throttling.iops-total-max\" },\n        { \"iops_rd_max\",    \"throttling.iops-read-max\" },\n        { \"iops_wr_max\",    \"throttling.iops-write-max\" },\n\n        { \"bps_max\",        \"throttling.bps-total-max\" },\n        { \"bps_rd_max\",     \"throttling.bps-read-max\" },\n        { \"bps_wr_max\",     \"throttling.bps-write-max\" },\n\n        { \"iops_size\",      \"throttling.iops-size\" },\n\n        { \"group\",          \"throttling.group\" },\n\n        { \"readonly\",       BDRV_OPT_READ_ONLY },\n    };\n\n    for (i = 0; i < ARRAY_SIZE(opt_renames); i++) {\n        if (!qemu_opt_rename(all_opts, opt_renames[i].from,\n                             opt_renames[i].to, errp)) {\n            return NULL;\n        }\n    }\n\n    value = qemu_opt_get(all_opts, \"cache\");\n    if (value) {\n        int flags = 0;\n        bool writethrough;\n\n        if (bdrv_parse_cache_mode(value, &flags, &writethrough) != 0) {\n            error_setg(errp, \"invalid cache option\");\n            return NULL;\n        }\n\n        /* Specific options take precedence */\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_WB)) {\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_WB,\n                              !writethrough, &error_abort);\n        }\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_DIRECT)) {\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_DIRECT,\n                              !!(flags & BDRV_O_NOCACHE), &error_abort);\n        }\n        if (!qemu_opt_get(all_opts, BDRV_OPT_CACHE_NO_FLUSH)) {\n            qemu_opt_set_bool(all_opts, BDRV_OPT_CACHE_NO_FLUSH,\n                              !!(flags & BDRV_O_NO_FLUSH), &error_abort);\n        }\n        qemu_opt_unset(all_opts, \"cache\");\n    }\n\n    /* Get a QDict for processing the options */\n    bs_opts = qdict_new();\n    qemu_opts_to_qdict(all_opts, bs_opts);\n\n    legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,\n                                   &error_abort);\n    if (!qemu_opts_absorb_qdict(legacy_opts, bs_opts, errp)) {\n        goto fail;\n    }\n\n    /* Media type */\n    value = qemu_opt_get(legacy_opts, \"media\");\n    if (value) {\n        if (!strcmp(value, \"disk\")) {\n            media = MEDIA_DISK;\n        } else if (!strcmp(value, \"cdrom\")) {\n            media = MEDIA_CDROM;\n            read_only = true;\n        } else {\n            error_setg(errp, \"'%s' invalid media\", value);\n            goto fail;\n        }\n    }\n\n    /* copy-on-read is disabled with a warning for read-only devices */\n    read_only |= qemu_opt_get_bool(legacy_opts, BDRV_OPT_READ_ONLY, false);\n    copy_on_read = qemu_opt_get_bool(legacy_opts, \"copy-on-read\", false);\n\n    if (read_only && copy_on_read) {\n        warn_report(\"disabling copy-on-read on read-only drive\");\n        copy_on_read = false;\n    }\n\n    qdict_put_str(bs_opts, BDRV_OPT_READ_ONLY, read_only ? \"on\" : \"off\");\n    qdict_put_str(bs_opts, \"copy-on-read\", copy_on_read ? \"on\" : \"off\");\n\n    /* Controller type */\n    value = qemu_opt_get(legacy_opts, \"if\");\n    if (value) {\n        for (type = 0;\n             type < IF_COUNT && strcmp(value, if_name[type]);\n             type++) {\n        }\n        if (type == IF_COUNT) {\n            error_setg(errp, \"unsupported bus type '%s'\", value);\n            goto fail;\n        }\n    } else {\n        type = block_default_type;\n    }\n\n    /* Device address specified by bus/unit or index.\n     * If none was specified, try to find the first free one. */\n    bus_id  = qemu_opt_get_number(legacy_opts, \"bus\", 0);\n    unit_id = qemu_opt_get_number(legacy_opts, \"unit\", -1);\n    index   = qemu_opt_get_number(legacy_opts, \"index\", -1);\n\n    max_devs = if_max_devs[type];\n\n    if (index != -1) {\n        if (bus_id != 0 || unit_id != -1) {\n            error_setg(errp, \"index cannot be used with bus and unit\");\n            goto fail;\n        }\n        bus_id = drive_index_to_bus_id(type, index);\n        unit_id = drive_index_to_unit_id(type, index);\n    }\n\n    if (unit_id == -1) {\n       unit_id = 0;\n       while (drive_get(type, bus_id, unit_id) != NULL) {\n           unit_id++;\n           if (max_devs && unit_id >= max_devs) {\n               unit_id -= max_devs;\n               bus_id++;\n           }\n       }\n    }\n\n    if (max_devs && unit_id >= max_devs) {\n        error_setg(errp, \"unit %d too big (max is %d)\", unit_id, max_devs - 1);\n        goto fail;\n    }\n\n    if (drive_get(type, bus_id, unit_id) != NULL) {\n        error_setg(errp, \"drive with bus=%d, unit=%d (index=%d) exists\",\n                   bus_id, unit_id, index);\n        goto fail;\n    }\n\n    /* no id supplied -> create one */\n    if (qemu_opts_id(all_opts) == NULL) {\n        char *new_id;\n        const char *mediastr = \"\";\n        if (type == IF_IDE || type == IF_SCSI) {\n            mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n        }\n        if (max_devs) {\n            new_id = g_strdup_printf(\"%s%i%s%i\", if_name[type], bus_id,\n                                     mediastr, unit_id);\n        } else {\n            new_id = g_strdup_printf(\"%s%s%i\", if_name[type],\n                                     mediastr, unit_id);\n        }\n        qdict_put_str(bs_opts, \"id\", new_id);\n        g_free(new_id);\n    }\n\n    /* Add virtio block device */\n    if (type == IF_VIRTIO) {\n        QemuOpts *devopts;\n        devopts = qemu_opts_create(qemu_find_opts(\"device\"), NULL, 0,\n                                   &error_abort);\n        qemu_opt_set(devopts, \"driver\", \"virtio-blk\", &error_abort);\n        qemu_opt_set(devopts, \"drive\", qdict_get_str(bs_opts, \"id\"),\n                     &error_abort);\n    }\n\n    filename = qemu_opt_get(legacy_opts, \"file\");\n\n    /* Check werror/rerror compatibility with if=... */\n    werror = qemu_opt_get(legacy_opts, \"werror\");\n    if (werror != NULL) {\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO &&\n            type != IF_NONE) {\n            error_setg(errp, \"werror is not supported by this bus type\");\n            goto fail;\n        }\n        qdict_put_str(bs_opts, \"werror\", werror);\n    }\n\n    rerror = qemu_opt_get(legacy_opts, \"rerror\");\n    if (rerror != NULL) {\n        if (type != IF_IDE && type != IF_VIRTIO && type != IF_SCSI &&\n            type != IF_NONE) {\n            error_setg(errp, \"rerror is not supported by this bus type\");\n            goto fail;\n        }\n        qdict_put_str(bs_opts, \"rerror\", rerror);\n    }\n\n    /* Actual block device init: Functionality shared with blockdev-add */\n    blk = blockdev_init(filename, bs_opts, errp);\n    bs_opts = NULL;\n    if (!blk) {\n        goto fail;\n    }\n\n    /* Create legacy DriveInfo */\n    dinfo = g_malloc0(sizeof(*dinfo));\n    dinfo->opts = all_opts;\n\n    dinfo->type = type;\n    dinfo->bus = bus_id;\n    dinfo->unit = unit_id;\n\n    blk_set_legacy_dinfo(blk, dinfo);\n\n    switch(type) {\n    case IF_IDE:\n    case IF_SCSI:\n    case IF_XEN:\n    case IF_NONE:\n        dinfo->media_cd = media == MEDIA_CDROM;\n        break;\n    default:\n        break;\n    }\n\nfail:\n    qemu_opts_del(legacy_opts);\n    qobject_unref(bs_opts);\n    return dinfo;\n}\n\nstatic BlockDriverState *qmp_get_root_bs(const char *name, Error **errp)\n{\n    BlockDriverState *bs;\n\n    bs = bdrv_lookup_bs(name, name, errp);\n    if (bs == NULL) {\n        return NULL;\n    }\n\n    if (!bdrv_is_root_node(bs)) {\n        error_setg(errp, \"Need a root block node\");\n        return NULL;\n    }\n\n    if (!bdrv_is_inserted(bs)) {\n        error_setg(errp, \"Device has no medium\");\n        return NULL;\n    }\n\n    return bs;\n}\n\nstatic void blockdev_do_action(TransactionAction *action, Error **errp)\n{\n    TransactionActionList list;\n\n    list.value = action;\n    list.next = NULL;\n    qmp_transaction(&list, false, NULL, errp);\n}\n\nvoid qmp_blockdev_snapshot_sync(bool has_device, const char *device,\n                                bool has_node_name, const char *node_name,\n                                const char *snapshot_file,\n                                bool has_snapshot_node_name,\n                                const char *snapshot_node_name,\n                                bool has_format, const char *format,\n                                bool has_mode, NewImageMode mode, Error **errp)\n{\n    BlockdevSnapshotSync snapshot = {\n        .has_device = has_device,\n        .device = (char *) device,\n        .has_node_name = has_node_name,\n        .node_name = (char *) node_name,\n        .snapshot_file = (char *) snapshot_file,\n        .has_snapshot_node_name = has_snapshot_node_name,\n        .snapshot_node_name = (char *) snapshot_node_name,\n        .has_format = has_format,\n        .format = (char *) format,\n        .has_mode = has_mode,\n        .mode = mode,\n    };\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC,\n        .u.blockdev_snapshot_sync.data = &snapshot,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nvoid qmp_blockdev_snapshot(const char *node, const char *overlay,\n                           Error **errp)\n{\n    BlockdevSnapshot snapshot_data = {\n        .node = (char *) node,\n        .overlay = (char *) overlay\n    };\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT,\n        .u.blockdev_snapshot.data = &snapshot_data,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nvoid qmp_blockdev_snapshot_internal_sync(const char *device,\n                                         const char *name,\n                                         Error **errp)\n{\n    BlockdevSnapshotInternal snapshot = {\n        .device = (char *) device,\n        .name = (char *) name\n    };\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC,\n        .u.blockdev_snapshot_internal_sync.data = &snapshot,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nSnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n                                                         bool has_id,\n                                                         const char *id,\n                                                         bool has_name,\n                                                         const char *name,\n                                                         Error **errp)\n{\n    BlockDriverState *bs;\n    AioContext *aio_context;\n    QEMUSnapshotInfo sn;\n    Error *local_err = NULL;\n    SnapshotInfo *info = NULL;\n    int ret;\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return NULL;\n    }\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (!has_id) {\n        id = NULL;\n    }\n\n    if (!has_name) {\n        name = NULL;\n    }\n\n    if (!id && !name) {\n        error_setg(errp, \"Name or id must be provided\");\n        goto out_aio_context;\n    }\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n        goto out_aio_context;\n    }\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out_aio_context;\n    }\n    if (!ret) {\n        error_setg(errp,\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n                   \"device '%s'\",\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n        goto out_aio_context;\n    }\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out_aio_context;\n    }\n\n    aio_context_release(aio_context);\n\n    info = g_new0(SnapshotInfo, 1);\n    info->id = g_strdup(sn.id_str);\n    info->name = g_strdup(sn.name);\n    info->date_nsec = sn.date_nsec;\n    info->date_sec = sn.date_sec;\n    info->vm_state_size = sn.vm_state_size;\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n    if (sn.icount != -1ULL) {\n        info->icount = sn.icount;\n        info->has_icount = true;\n    }\n\n    return info;\n\nout_aio_context:\n    aio_context_release(aio_context);\n    return NULL;\n}\n\n/* New and old BlockDriverState structs for atomic group operations */\n\ntypedef struct BlkActionState BlkActionState;\n\n/**\n * BlkActionOps:\n * Table of operations that define an Action.\n *\n * @instance_size: Size of state struct, in bytes.\n * @prepare: Prepare the work, must NOT be NULL.\n * @commit: Commit the changes, can be NULL.\n * @abort: Abort the changes on fail, can be NULL.\n * @clean: Clean up resources after all transaction actions have called\n *         commit() or abort(). Can be NULL.\n *\n * Only prepare() may fail. In a single transaction, only one of commit() or\n * abort() will be called. clean() will always be called if it is present.\n *\n * Always run under BQL.\n */\ntypedef struct BlkActionOps {\n    size_t instance_size;\n    void (*prepare)(BlkActionState *common, Error **errp);\n    void (*commit)(BlkActionState *common);\n    void (*abort)(BlkActionState *common);\n    void (*clean)(BlkActionState *common);\n} BlkActionOps;\n\n/**\n * BlkActionState:\n * Describes one Action's state within a Transaction.\n *\n * @action: QAPI-defined enum identifying which Action to perform.\n * @ops: Table of ActionOps this Action can perform.\n * @block_job_txn: Transaction which this action belongs to.\n * @entry: List membership for all Actions in this Transaction.\n *\n * This structure must be arranged as first member in a subclassed type,\n * assuming that the compiler will also arrange it to the same offsets as the\n * base class.\n */\nstruct BlkActionState {\n    TransactionAction *action;\n    const BlkActionOps *ops;\n    JobTxn *block_job_txn;\n    TransactionProperties *txn_props;\n    QTAILQ_ENTRY(BlkActionState) entry;\n};\n\n/* internal snapshot private data */\ntypedef struct InternalSnapshotState {\n    BlkActionState common;\n    BlockDriverState *bs;\n    QEMUSnapshotInfo sn;\n    bool created;\n} InternalSnapshotState;\n\n\nstatic int action_check_completion_mode(BlkActionState *s, Error **errp)\n{\n    if (s->txn_props->completion_mode != ACTION_COMPLETION_MODE_INDIVIDUAL) {\n        error_setg(errp,\n                   \"Action '%s' does not support Transaction property \"\n                   \"completion-mode = %s\",\n                   TransactionActionKind_str(s->action->type),\n                   ActionCompletionMode_str(s->txn_props->completion_mode));\n        return -1;\n    }\n    return 0;\n}\n\nstatic void internal_snapshot_prepare(BlkActionState *common,\n                                      Error **errp)\n{\n    Error *local_err = NULL;\n    const char *device;\n    const char *name;\n    BlockDriverState *bs;\n    QEMUSnapshotInfo old_sn, *sn;\n    bool ret;\n    int64_t rt;\n    BlockdevSnapshotInternal *internal;\n    InternalSnapshotState *state;\n    AioContext *aio_context;\n    int ret1;\n\n    g_assert(common->action->type ==\n             TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC);\n    internal = common->action->u.blockdev_snapshot_internal_sync.data;\n    state = DO_UPCAST(InternalSnapshotState, common, common);\n\n    /* 1. parse input */\n    device = internal->device;\n    name = internal->name;\n\n    /* 2. check for validation */\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    state->bs = bs;\n\n    /* Paired with .clean() */\n    bdrv_drained_begin(bs);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT, errp)) {\n        goto out;\n    }\n\n    if (bdrv_is_read_only(bs)) {\n        error_setg(errp, \"Device '%s' is read only\", device);\n        goto out;\n    }\n\n    if (!bdrv_can_snapshot(bs)) {\n        error_setg(errp, \"Block format '%s' used by device '%s' \"\n                   \"does not support internal snapshots\",\n                   bs->drv->format_name, device);\n        goto out;\n    }\n\n    if (!strlen(name)) {\n        error_setg(errp, \"Name is empty\");\n        goto out;\n    }\n\n    /* check whether a snapshot with name exist */\n    ret = bdrv_snapshot_find_by_id_and_name(bs, NULL, name, &old_sn,\n                                            &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    } else if (ret) {\n        error_setg(errp,\n                   \"Snapshot with name '%s' already exists on device '%s'\",\n                   name, device);\n        goto out;\n    }\n\n    /* 3. take the snapshot */\n    sn = &state->sn;\n    pstrcpy(sn->name, sizeof(sn->name), name);\n    rt = g_get_real_time();\n    sn->date_sec = rt / G_USEC_PER_SEC;\n    sn->date_nsec = (rt % G_USEC_PER_SEC) * 1000;\n    sn->vm_clock_nsec = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);\n    if (replay_mode != REPLAY_MODE_NONE) {\n        sn->icount = replay_get_current_icount();\n    } else {\n        sn->icount = -1ULL;\n    }\n\n    ret1 = bdrv_snapshot_create(bs, sn);\n    if (ret1 < 0) {\n        error_setg_errno(errp, -ret1,\n                         \"Failed to create snapshot '%s' on device '%s'\",\n                         name, device);\n        goto out;\n    }\n\n    /* 4. succeed, mark a snapshot is created */\n    state->created = true;\n\nout:\n    aio_context_release(aio_context);\n}\n\nstatic void internal_snapshot_abort(BlkActionState *common)\n{\n    InternalSnapshotState *state =\n                             DO_UPCAST(InternalSnapshotState, common, common);\n    BlockDriverState *bs = state->bs;\n    QEMUSnapshotInfo *sn = &state->sn;\n    AioContext *aio_context;\n    Error *local_error = NULL;\n\n    if (!state->created) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(state->bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_snapshot_delete(bs, sn->id_str, sn->name, &local_error) < 0) {\n        error_reportf_err(local_error,\n                          \"Failed to delete snapshot with id '%s' and \"\n                          \"name '%s' on device '%s' in abort: \",\n                          sn->id_str, sn->name,\n                          bdrv_get_device_name(bs));\n    }\n\n    aio_context_release(aio_context);\n}\n\nstatic void internal_snapshot_clean(BlkActionState *common)\n{\n    InternalSnapshotState *state = DO_UPCAST(InternalSnapshotState,\n                                             common, common);\n    AioContext *aio_context;\n\n    if (!state->bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(state->bs);\n    aio_context_acquire(aio_context);\n\n    bdrv_drained_end(state->bs);\n\n    aio_context_release(aio_context);\n}\n\n/* external snapshot private data */\ntypedef struct ExternalSnapshotState {\n    BlkActionState common;\n    BlockDriverState *old_bs;\n    BlockDriverState *new_bs;\n    bool overlay_appended;\n} ExternalSnapshotState;\n\nstatic void external_snapshot_prepare(BlkActionState *common,\n                                      Error **errp)\n{\n    int ret;\n    int flags = 0;\n    QDict *options = NULL;\n    Error *local_err = NULL;\n    /* Device and node name of the image to generate the snapshot from */\n    const char *device;\n    const char *node_name;\n    /* Reference to the new image (for 'blockdev-snapshot') */\n    const char *snapshot_ref;\n    /* File name of the new image (for 'blockdev-snapshot-sync') */\n    const char *new_image_file;\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    TransactionAction *action = common->action;\n    AioContext *aio_context;\n    uint64_t perm, shared;\n\n    /* 'blockdev-snapshot' and 'blockdev-snapshot-sync' have similar\n     * purpose but a different set of parameters */\n    switch (action->type) {\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT:\n        {\n            BlockdevSnapshot *s = action->u.blockdev_snapshot.data;\n            device = s->node;\n            node_name = s->node;\n            new_image_file = NULL;\n            snapshot_ref = s->overlay;\n        }\n        break;\n    case TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC:\n        {\n            BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync.data;\n            device = s->has_device ? s->device : NULL;\n            node_name = s->has_node_name ? s->node_name : NULL;\n            new_image_file = s->snapshot_file;\n            snapshot_ref = NULL;\n        }\n        break;\n    default:\n        g_assert_not_reached();\n    }\n\n    /* start processing */\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    state->old_bs = bdrv_lookup_bs(device, node_name, errp);\n    if (!state->old_bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(state->old_bs);\n    aio_context_acquire(aio_context);\n\n    /* Paired with .clean() */\n    bdrv_drained_begin(state->old_bs);\n\n    if (!bdrv_is_inserted(state->old_bs)) {\n        error_setg(errp, QERR_DEVICE_HAS_NO_MEDIUM, device);\n        goto out;\n    }\n\n    if (bdrv_op_is_blocked(state->old_bs,\n                           BLOCK_OP_TYPE_EXTERNAL_SNAPSHOT, errp)) {\n        goto out;\n    }\n\n    if (!bdrv_is_read_only(state->old_bs)) {\n        if (bdrv_flush(state->old_bs)) {\n            error_setg(errp, QERR_IO_ERROR);\n            goto out;\n        }\n    }\n\n    if (action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC) {\n        BlockdevSnapshotSync *s = action->u.blockdev_snapshot_sync.data;\n        const char *format = s->has_format ? s->format : \"qcow2\";\n        enum NewImageMode mode;\n        const char *snapshot_node_name =\n            s->has_snapshot_node_name ? s->snapshot_node_name : NULL;\n\n        if (node_name && !snapshot_node_name) {\n            error_setg(errp, \"New overlay node-name missing\");\n            goto out;\n        }\n\n        if (snapshot_node_name &&\n            bdrv_lookup_bs(snapshot_node_name, snapshot_node_name, NULL)) {\n            error_setg(errp, \"New overlay node-name already in use\");\n            goto out;\n        }\n\n        flags = state->old_bs->open_flags;\n        flags &= ~(BDRV_O_SNAPSHOT | BDRV_O_COPY_ON_READ);\n        flags |= BDRV_O_NO_BACKING;\n\n        /* create new image w/backing file */\n        mode = s->has_mode ? s->mode : NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n        if (mode != NEW_IMAGE_MODE_EXISTING) {\n            int64_t size = bdrv_getlength(state->old_bs);\n            if (size < 0) {\n                error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n                goto out;\n            }\n            bdrv_refresh_filename(state->old_bs);\n            bdrv_img_create(new_image_file, format,\n                            state->old_bs->filename,\n                            state->old_bs->drv->format_name,\n                            NULL, size, flags, false, &local_err);\n            if (local_err) {\n                error_propagate(errp, local_err);\n                goto out;\n            }\n        }\n\n        options = qdict_new();\n        if (snapshot_node_name) {\n            qdict_put_str(options, \"node-name\", snapshot_node_name);\n        }\n        qdict_put_str(options, \"driver\", format);\n    }\n\n    state->new_bs = bdrv_open(new_image_file, snapshot_ref, options, flags,\n                              errp);\n    /* We will manually add the backing_hd field to the bs later */\n    if (!state->new_bs) {\n        goto out;\n    }\n\n    /*\n     * Allow attaching a backing file to an overlay that's already in use only\n     * if the parents don't assume that they are already seeing a valid image.\n     * (Specifically, allow it as a mirror target, which is write-only access.)\n     */\n    bdrv_get_cumulative_perm(state->new_bs, &perm, &shared);\n    if (perm & BLK_PERM_CONSISTENT_READ) {\n        error_setg(errp, \"The overlay is already in use\");\n        goto out;\n    }\n\n    if (state->new_bs->drv->is_filter) {\n        error_setg(errp, \"Filters cannot be used as overlays\");\n        goto out;\n    }\n\n    if (bdrv_cow_child(state->new_bs)) {\n        error_setg(errp, \"The overlay already has a backing image\");\n        goto out;\n    }\n\n    if (!state->new_bs->drv->supports_backing) {\n        error_setg(errp, \"The overlay does not support backing images\");\n        goto out;\n    }\n\n    ret = bdrv_append(state->new_bs, state->old_bs, errp);\n    if (ret < 0) {\n        goto out;\n    }\n    state->overlay_appended = true;\n\nout:\n    aio_context_release(aio_context);\n}\n\nstatic void external_snapshot_commit(BlkActionState *common)\n{\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    AioContext *aio_context;\n\n    aio_context = bdrv_get_aio_context(state->old_bs);\n    aio_context_acquire(aio_context);\n\n    /* We don't need (or want) to use the transactional\n     * bdrv_reopen_multiple() across all the entries at once, because we\n     * don't want to abort all of them if one of them fails the reopen */\n    if (!qatomic_read(&state->old_bs->copy_on_read)) {\n        bdrv_reopen_set_read_only(state->old_bs, true, NULL);\n    }\n\n    aio_context_release(aio_context);\n}\n\nstatic void external_snapshot_abort(BlkActionState *common)\n{\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    if (state->new_bs) {\n        if (state->overlay_appended) {\n            AioContext *aio_context;\n            AioContext *tmp_context;\n            int ret;\n\n            aio_context = bdrv_get_aio_context(state->old_bs);\n            aio_context_acquire(aio_context);\n\n            bdrv_ref(state->old_bs);   /* we can't let bdrv_set_backind_hd()\n                                          close state->old_bs; we need it */\n            bdrv_set_backing_hd(state->new_bs, NULL, &error_abort);\n\n            /*\n             * The call to bdrv_set_backing_hd() above returns state->old_bs to\n             * the main AioContext. As we're still going to be using it, return\n             * it to the AioContext it was before.\n             */\n            tmp_context = bdrv_get_aio_context(state->old_bs);\n            if (aio_context != tmp_context) {\n                aio_context_release(aio_context);\n                aio_context_acquire(tmp_context);\n\n                ret = bdrv_try_set_aio_context(state->old_bs,\n                                               aio_context, NULL);\n                assert(ret == 0);\n\n                aio_context_release(tmp_context);\n                aio_context_acquire(aio_context);\n            }\n\n            bdrv_replace_node(state->new_bs, state->old_bs, &error_abort);\n            bdrv_unref(state->old_bs); /* bdrv_replace_node() ref'ed old_bs */\n\n            aio_context_release(aio_context);\n        }\n    }\n}\n\nstatic void external_snapshot_clean(BlkActionState *common)\n{\n    ExternalSnapshotState *state =\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n    AioContext *aio_context;\n\n    if (!state->old_bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(state->old_bs);\n    aio_context_acquire(aio_context);\n\n    bdrv_drained_end(state->old_bs);\n    bdrv_unref(state->new_bs);\n\n    aio_context_release(aio_context);\n}\n\ntypedef struct DriveBackupState {\n    BlkActionState common;\n    BlockDriverState *bs;\n    BlockJob *job;\n} DriveBackupState;\n\nstatic BlockJob *do_backup_common(BackupCommon *backup,\n                                  BlockDriverState *bs,\n                                  BlockDriverState *target_bs,\n                                  AioContext *aio_context,\n                                  JobTxn *txn, Error **errp);\n\nstatic void drive_backup_prepare(BlkActionState *common, Error **errp)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n    DriveBackup *backup;\n    BlockDriverState *bs;\n    BlockDriverState *target_bs;\n    BlockDriverState *source = NULL;\n    AioContext *aio_context;\n    AioContext *old_context;\n    QDict *options;\n    Error *local_err = NULL;\n    int flags;\n    int64_t size;\n    bool set_backing_hd = false;\n    int ret;\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);\n    backup = common->action->u.drive_backup.data;\n\n    if (!backup->has_mode) {\n        backup->mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n    }\n\n    bs = bdrv_lookup_bs(backup->device, backup->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    if (!bs->drv) {\n        error_setg(errp, \"Device has no medium\");\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    state->bs = bs;\n    /* Paired with .clean() */\n    bdrv_drained_begin(bs);\n\n    if (!backup->has_format) {\n        backup->format = backup->mode == NEW_IMAGE_MODE_EXISTING ?\n                         NULL : (char *) bs->drv->format_name;\n    }\n\n    /* Early check to avoid creating target */\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_BACKUP_SOURCE, errp)) {\n        goto out;\n    }\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n\n    /*\n     * See if we have a backing HD we can use to create our new image\n     * on top of.\n     */\n    if (backup->sync == MIRROR_SYNC_MODE_TOP) {\n        /*\n         * Backup will not replace the source by the target, so none\n         * of the filters skipped here will be removed (in contrast to\n         * mirror).  Therefore, we can skip all of them when looking\n         * for the first COW relationship.\n         */\n        source = bdrv_cow_bs(bdrv_skip_filters(bs));\n        if (!source) {\n            backup->sync = MIRROR_SYNC_MODE_FULL;\n        }\n    }\n    if (backup->sync == MIRROR_SYNC_MODE_NONE) {\n        source = bs;\n        flags |= BDRV_O_NO_BACKING;\n        set_backing_hd = true;\n    }\n\n    size = bdrv_getlength(bs);\n    if (size < 0) {\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n        goto out;\n    }\n\n    if (backup->mode != NEW_IMAGE_MODE_EXISTING) {\n        assert(backup->format);\n        if (source) {\n            /* Implicit filters should not appear in the filename */\n            BlockDriverState *explicit_backing =\n                bdrv_skip_implicit_filters(source);\n\n            bdrv_refresh_filename(explicit_backing);\n            bdrv_img_create(backup->target, backup->format,\n                            explicit_backing->filename,\n                            explicit_backing->drv->format_name, NULL,\n                            size, flags, false, &local_err);\n        } else {\n            bdrv_img_create(backup->target, backup->format, NULL, NULL, NULL,\n                            size, flags, false, &local_err);\n        }\n    }\n\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    options = qdict_new();\n    qdict_put_str(options, \"discard\", \"unmap\");\n    qdict_put_str(options, \"detect-zeroes\", \"unmap\");\n    if (backup->format) {\n        qdict_put_str(options, \"driver\", backup->format);\n    }\n\n    target_bs = bdrv_open(backup->target, NULL, options, flags, errp);\n    if (!target_bs) {\n        goto out;\n    }\n\n    /* Honor bdrv_try_set_aio_context() context acquisition requirements. */\n    old_context = bdrv_get_aio_context(target_bs);\n    aio_context_release(aio_context);\n    aio_context_acquire(old_context);\n\n    ret = bdrv_try_set_aio_context(target_bs, aio_context, errp);\n    if (ret < 0) {\n        bdrv_unref(target_bs);\n        aio_context_release(old_context);\n        return;\n    }\n\n    aio_context_release(old_context);\n    aio_context_acquire(aio_context);\n\n    if (set_backing_hd) {\n        if (bdrv_set_backing_hd(target_bs, source, errp) < 0) {\n            goto unref;\n        }\n    }\n\n    state->job = do_backup_common(qapi_DriveBackup_base(backup),\n                                  bs, target_bs, aio_context,\n                                  common->block_job_txn, errp);\n\nunref:\n    bdrv_unref(target_bs);\nout:\n    aio_context_release(aio_context);\n}\n\nstatic void drive_backup_commit(BlkActionState *common)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n    AioContext *aio_context;\n\n    aio_context = bdrv_get_aio_context(state->bs);\n    aio_context_acquire(aio_context);\n\n    assert(state->job);\n    job_start(&state->job->job);\n\n    aio_context_release(aio_context);\n}\n\nstatic void drive_backup_abort(BlkActionState *common)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n\n    if (state->job) {\n        AioContext *aio_context;\n\n        aio_context = bdrv_get_aio_context(state->bs);\n        aio_context_acquire(aio_context);\n\n        job_cancel_sync(&state->job->job, true);\n\n        aio_context_release(aio_context);\n    }\n}\n\nstatic void drive_backup_clean(BlkActionState *common)\n{\n    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);\n    AioContext *aio_context;\n\n    if (!state->bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(state->bs);\n    aio_context_acquire(aio_context);\n\n    bdrv_drained_end(state->bs);\n\n    aio_context_release(aio_context);\n}\n\ntypedef struct BlockdevBackupState {\n    BlkActionState common;\n    BlockDriverState *bs;\n    BlockJob *job;\n} BlockdevBackupState;\n\nstatic void blockdev_backup_prepare(BlkActionState *common, Error **errp)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n    BlockdevBackup *backup;\n    BlockDriverState *bs;\n    BlockDriverState *target_bs;\n    AioContext *aio_context;\n    AioContext *old_context;\n    int ret;\n\n    assert(common->action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP);\n    backup = common->action->u.blockdev_backup.data;\n\n    bs = bdrv_lookup_bs(backup->device, backup->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    target_bs = bdrv_lookup_bs(backup->target, backup->target, errp);\n    if (!target_bs) {\n        return;\n    }\n\n    /* Honor bdrv_try_set_aio_context() context acquisition requirements. */\n    aio_context = bdrv_get_aio_context(bs);\n    old_context = bdrv_get_aio_context(target_bs);\n    aio_context_acquire(old_context);\n\n    ret = bdrv_try_set_aio_context(target_bs, aio_context, errp);\n    if (ret < 0) {\n        aio_context_release(old_context);\n        return;\n    }\n\n    aio_context_release(old_context);\n    aio_context_acquire(aio_context);\n    state->bs = bs;\n\n    /* Paired with .clean() */\n    bdrv_drained_begin(state->bs);\n\n    state->job = do_backup_common(qapi_BlockdevBackup_base(backup),\n                                  bs, target_bs, aio_context,\n                                  common->block_job_txn, errp);\n\n    aio_context_release(aio_context);\n}\n\nstatic void blockdev_backup_commit(BlkActionState *common)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n    AioContext *aio_context;\n\n    aio_context = bdrv_get_aio_context(state->bs);\n    aio_context_acquire(aio_context);\n\n    assert(state->job);\n    job_start(&state->job->job);\n\n    aio_context_release(aio_context);\n}\n\nstatic void blockdev_backup_abort(BlkActionState *common)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n\n    if (state->job) {\n        AioContext *aio_context;\n\n        aio_context = bdrv_get_aio_context(state->bs);\n        aio_context_acquire(aio_context);\n\n        job_cancel_sync(&state->job->job, true);\n\n        aio_context_release(aio_context);\n    }\n}\n\nstatic void blockdev_backup_clean(BlkActionState *common)\n{\n    BlockdevBackupState *state = DO_UPCAST(BlockdevBackupState, common, common);\n    AioContext *aio_context;\n\n    if (!state->bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(state->bs);\n    aio_context_acquire(aio_context);\n\n    bdrv_drained_end(state->bs);\n\n    aio_context_release(aio_context);\n}\n\ntypedef struct BlockDirtyBitmapState {\n    BlkActionState common;\n    BdrvDirtyBitmap *bitmap;\n    BlockDriverState *bs;\n    HBitmap *backup;\n    bool prepared;\n    bool was_enabled;\n} BlockDirtyBitmapState;\n\nstatic void block_dirty_bitmap_add_prepare(BlkActionState *common,\n                                           Error **errp)\n{\n    Error *local_err = NULL;\n    BlockDirtyBitmapAdd *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_add.data;\n    /* AIO context taken and released within qmp_block_dirty_bitmap_add */\n    qmp_block_dirty_bitmap_add(action->node, action->name,\n                               action->has_granularity, action->granularity,\n                               action->has_persistent, action->persistent,\n                               action->has_disabled, action->disabled,\n                               &local_err);\n\n    if (!local_err) {\n        state->prepared = true;\n    } else {\n        error_propagate(errp, local_err);\n    }\n}\n\nstatic void block_dirty_bitmap_add_abort(BlkActionState *common)\n{\n    BlockDirtyBitmapAdd *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    action = common->action->u.block_dirty_bitmap_add.data;\n    /* Should not be able to fail: IF the bitmap was added via .prepare(),\n     * then the node reference and bitmap name must have been valid.\n     */\n    if (state->prepared) {\n        qmp_block_dirty_bitmap_remove(action->node, action->name, &error_abort);\n    }\n}\n\nstatic void block_dirty_bitmap_clear_prepare(BlkActionState *common,\n                                             Error **errp)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n    BlockDirtyBitmap *action;\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_clear.data;\n    state->bitmap = block_dirty_bitmap_lookup(action->node,\n                                              action->name,\n                                              &state->bs,\n                                              errp);\n    if (!state->bitmap) {\n        return;\n    }\n\n    if (bdrv_dirty_bitmap_check(state->bitmap, BDRV_BITMAP_DEFAULT, errp)) {\n        return;\n    }\n\n    bdrv_clear_dirty_bitmap(state->bitmap, &state->backup);\n}\n\nstatic void block_dirty_bitmap_restore(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (state->backup) {\n        bdrv_restore_dirty_bitmap(state->bitmap, state->backup);\n    }\n}\n\nstatic void block_dirty_bitmap_free_backup(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    hbitmap_free(state->backup);\n}\n\nstatic void block_dirty_bitmap_enable_prepare(BlkActionState *common,\n                                              Error **errp)\n{\n    BlockDirtyBitmap *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_enable.data;\n    state->bitmap = block_dirty_bitmap_lookup(action->node,\n                                              action->name,\n                                              NULL,\n                                              errp);\n    if (!state->bitmap) {\n        return;\n    }\n\n    if (bdrv_dirty_bitmap_check(state->bitmap, BDRV_BITMAP_ALLOW_RO, errp)) {\n        return;\n    }\n\n    state->was_enabled = bdrv_dirty_bitmap_enabled(state->bitmap);\n    bdrv_enable_dirty_bitmap(state->bitmap);\n}\n\nstatic void block_dirty_bitmap_enable_abort(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (!state->was_enabled) {\n        bdrv_disable_dirty_bitmap(state->bitmap);\n    }\n}\n\nstatic void block_dirty_bitmap_disable_prepare(BlkActionState *common,\n                                               Error **errp)\n{\n    BlockDirtyBitmap *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_disable.data;\n    state->bitmap = block_dirty_bitmap_lookup(action->node,\n                                              action->name,\n                                              NULL,\n                                              errp);\n    if (!state->bitmap) {\n        return;\n    }\n\n    if (bdrv_dirty_bitmap_check(state->bitmap, BDRV_BITMAP_ALLOW_RO, errp)) {\n        return;\n    }\n\n    state->was_enabled = bdrv_dirty_bitmap_enabled(state->bitmap);\n    bdrv_disable_dirty_bitmap(state->bitmap);\n}\n\nstatic void block_dirty_bitmap_disable_abort(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (state->was_enabled) {\n        bdrv_enable_dirty_bitmap(state->bitmap);\n    }\n}\n\nstatic void block_dirty_bitmap_merge_prepare(BlkActionState *common,\n                                             Error **errp)\n{\n    BlockDirtyBitmapMerge *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_merge.data;\n\n    state->bitmap = block_dirty_bitmap_merge(action->node, action->target,\n                                             action->bitmaps, &state->backup,\n                                             errp);\n}\n\nstatic void block_dirty_bitmap_remove_prepare(BlkActionState *common,\n                                              Error **errp)\n{\n    BlockDirtyBitmap *action;\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (action_check_completion_mode(common, errp) < 0) {\n        return;\n    }\n\n    action = common->action->u.block_dirty_bitmap_remove.data;\n\n    state->bitmap = block_dirty_bitmap_remove(action->node, action->name,\n                                              false, &state->bs, errp);\n    if (state->bitmap) {\n        bdrv_dirty_bitmap_skip_store(state->bitmap, true);\n        bdrv_dirty_bitmap_set_busy(state->bitmap, true);\n    }\n}\n\nstatic void block_dirty_bitmap_remove_abort(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    if (state->bitmap) {\n        bdrv_dirty_bitmap_skip_store(state->bitmap, false);\n        bdrv_dirty_bitmap_set_busy(state->bitmap, false);\n    }\n}\n\nstatic void block_dirty_bitmap_remove_commit(BlkActionState *common)\n{\n    BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,\n                                             common, common);\n\n    bdrv_dirty_bitmap_set_busy(state->bitmap, false);\n    bdrv_release_dirty_bitmap(state->bitmap);\n}\n\nstatic void abort_prepare(BlkActionState *common, Error **errp)\n{\n    error_setg(errp, \"Transaction aborted using Abort action\");\n}\n\nstatic void abort_commit(BlkActionState *common)\n{\n    g_assert_not_reached(); /* this action never succeeds */\n}\n\nstatic const BlkActionOps actions[] = {\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT] = {\n        .instance_size = sizeof(ExternalSnapshotState),\n        .prepare  = external_snapshot_prepare,\n        .commit   = external_snapshot_commit,\n        .abort = external_snapshot_abort,\n        .clean = external_snapshot_clean,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_SYNC] = {\n        .instance_size = sizeof(ExternalSnapshotState),\n        .prepare  = external_snapshot_prepare,\n        .commit   = external_snapshot_commit,\n        .abort = external_snapshot_abort,\n        .clean = external_snapshot_clean,\n    },\n    [TRANSACTION_ACTION_KIND_DRIVE_BACKUP] = {\n        .instance_size = sizeof(DriveBackupState),\n        .prepare = drive_backup_prepare,\n        .commit = drive_backup_commit,\n        .abort = drive_backup_abort,\n        .clean = drive_backup_clean,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP] = {\n        .instance_size = sizeof(BlockdevBackupState),\n        .prepare = blockdev_backup_prepare,\n        .commit = blockdev_backup_commit,\n        .abort = blockdev_backup_abort,\n        .clean = blockdev_backup_clean,\n    },\n    [TRANSACTION_ACTION_KIND_ABORT] = {\n        .instance_size = sizeof(BlkActionState),\n        .prepare = abort_prepare,\n        .commit = abort_commit,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCKDEV_SNAPSHOT_INTERNAL_SYNC] = {\n        .instance_size = sizeof(InternalSnapshotState),\n        .prepare  = internal_snapshot_prepare,\n        .abort = internal_snapshot_abort,\n        .clean = internal_snapshot_clean,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_ADD] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_add_prepare,\n        .abort = block_dirty_bitmap_add_abort,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_CLEAR] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_clear_prepare,\n        .commit = block_dirty_bitmap_free_backup,\n        .abort = block_dirty_bitmap_restore,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_ENABLE] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_enable_prepare,\n        .abort = block_dirty_bitmap_enable_abort,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_DISABLE] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_disable_prepare,\n        .abort = block_dirty_bitmap_disable_abort,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_MERGE] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_merge_prepare,\n        .commit = block_dirty_bitmap_free_backup,\n        .abort = block_dirty_bitmap_restore,\n    },\n    [TRANSACTION_ACTION_KIND_BLOCK_DIRTY_BITMAP_REMOVE] = {\n        .instance_size = sizeof(BlockDirtyBitmapState),\n        .prepare = block_dirty_bitmap_remove_prepare,\n        .commit = block_dirty_bitmap_remove_commit,\n        .abort = block_dirty_bitmap_remove_abort,\n    },\n    /* Where are transactions for MIRROR, COMMIT and STREAM?\n     * Although these blockjobs use transaction callbacks like the backup job,\n     * these jobs do not necessarily adhere to transaction semantics.\n     * These jobs may not fully undo all of their actions on abort, nor do they\n     * necessarily work in transactions with more than one job in them.\n     */\n};\n\n/**\n * Allocate a TransactionProperties structure if necessary, and fill\n * that structure with desired defaults if they are unset.\n */\nstatic TransactionProperties *get_transaction_properties(\n    TransactionProperties *props)\n{\n    if (!props) {\n        props = g_new0(TransactionProperties, 1);\n    }\n\n    if (!props->has_completion_mode) {\n        props->has_completion_mode = true;\n        props->completion_mode = ACTION_COMPLETION_MODE_INDIVIDUAL;\n    }\n\n    return props;\n}\n\n/*\n * 'Atomic' group operations.  The operations are performed as a set, and if\n * any fail then we roll back all operations in the group.\n *\n * Always run under BQL.\n */\nvoid qmp_transaction(TransactionActionList *dev_list,\n                     bool has_props,\n                     struct TransactionProperties *props,\n                     Error **errp)\n{\n    TransactionActionList *dev_entry = dev_list;\n    JobTxn *block_job_txn = NULL;\n    BlkActionState *state, *next;\n    Error *local_err = NULL;\n\n    GLOBAL_STATE_CODE();\n\n    QTAILQ_HEAD(, BlkActionState) snap_bdrv_states;\n    QTAILQ_INIT(&snap_bdrv_states);\n\n    /* Does this transaction get canceled as a group on failure?\n     * If not, we don't really need to make a JobTxn.\n     */\n    props = get_transaction_properties(props);\n    if (props->completion_mode != ACTION_COMPLETION_MODE_INDIVIDUAL) {\n        block_job_txn = job_txn_new();\n    }\n\n    /* drain all i/o before any operations */\n    bdrv_drain_all();\n\n    /* We don't do anything in this loop that commits us to the operations */\n    while (NULL != dev_entry) {\n        TransactionAction *dev_info = NULL;\n        const BlkActionOps *ops;\n\n        dev_info = dev_entry->value;\n        dev_entry = dev_entry->next;\n\n        assert(dev_info->type < ARRAY_SIZE(actions));\n\n        ops = &actions[dev_info->type];\n        assert(ops->instance_size > 0);\n\n        state = g_malloc0(ops->instance_size);\n        state->ops = ops;\n        state->action = dev_info;\n        state->block_job_txn = block_job_txn;\n        state->txn_props = props;\n        QTAILQ_INSERT_TAIL(&snap_bdrv_states, state, entry);\n\n        state->ops->prepare(state, &local_err);\n        if (local_err) {\n            error_propagate(errp, local_err);\n            goto delete_and_fail;\n        }\n    }\n\n    QTAILQ_FOREACH(state, &snap_bdrv_states, entry) {\n        if (state->ops->commit) {\n            state->ops->commit(state);\n        }\n    }\n\n    /* success */\n    goto exit;\n\ndelete_and_fail:\n    /* failure, and it is all-or-none; roll back all operations */\n    QTAILQ_FOREACH_REVERSE(state, &snap_bdrv_states, entry) {\n        if (state->ops->abort) {\n            state->ops->abort(state);\n        }\n    }\nexit:\n    QTAILQ_FOREACH_SAFE(state, &snap_bdrv_states, entry, next) {\n        if (state->ops->clean) {\n            state->ops->clean(state);\n        }\n        g_free(state);\n    }\n    if (!has_props) {\n        qapi_free_TransactionProperties(props);\n    }\n    job_txn_unref(block_job_txn);\n}\n\nBlockDirtyBitmapSha256 *qmp_x_debug_block_dirty_bitmap_sha256(const char *node,\n                                                              const char *name,\n                                                              Error **errp)\n{\n    BdrvDirtyBitmap *bitmap;\n    BlockDriverState *bs;\n    BlockDirtyBitmapSha256 *ret = NULL;\n    char *sha256;\n\n    bitmap = block_dirty_bitmap_lookup(node, name, &bs, errp);\n    if (!bitmap || !bs) {\n        return NULL;\n    }\n\n    sha256 = bdrv_dirty_bitmap_sha256(bitmap, errp);\n    if (sha256 == NULL) {\n        return NULL;\n    }\n\n    ret = g_new(BlockDirtyBitmapSha256, 1);\n    ret->sha256 = sha256;\n\n    return ret;\n}\n\nvoid coroutine_fn qmp_block_resize(bool has_device, const char *device,\n                                   bool has_node_name, const char *node_name,\n                                   int64_t size, Error **errp)\n{\n    Error *local_err = NULL;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    AioContext *old_ctx;\n\n    bs = bdrv_lookup_bs(has_device ? device : NULL,\n                        has_node_name ? node_name : NULL,\n                        &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    if (size < 0) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"size\", \"a >0 size\");\n        return;\n    }\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_RESIZE, NULL)) {\n        error_setg(errp, QERR_DEVICE_IN_USE, device);\n        return;\n    }\n\n    blk = blk_new_with_bs(bs, BLK_PERM_RESIZE, BLK_PERM_ALL, errp);\n    if (!blk) {\n        return;\n    }\n\n    bdrv_co_lock(bs);\n    bdrv_drained_begin(bs);\n    bdrv_co_unlock(bs);\n\n    old_ctx = bdrv_co_enter(bs);\n    blk_truncate(blk, size, false, PREALLOC_MODE_OFF, 0, errp);\n    bdrv_co_leave(bs, old_ctx);\n\n    bdrv_co_lock(bs);\n    bdrv_drained_end(bs);\n    blk_unref(blk);\n    bdrv_co_unlock(bs);\n}\n\nvoid qmp_block_stream(bool has_job_id, const char *job_id, const char *device,\n                      bool has_base, const char *base,\n                      bool has_base_node, const char *base_node,\n                      bool has_backing_file, const char *backing_file,\n                      bool has_bottom, const char *bottom,\n                      bool has_speed, int64_t speed,\n                      bool has_on_error, BlockdevOnError on_error,\n                      bool has_filter_node_name, const char *filter_node_name,\n                      bool has_auto_finalize, bool auto_finalize,\n                      bool has_auto_dismiss, bool auto_dismiss,\n                      Error **errp)\n{\n    BlockDriverState *bs, *iter, *iter_end;\n    BlockDriverState *base_bs = NULL;\n    BlockDriverState *bottom_bs = NULL;\n    AioContext *aio_context;\n    Error *local_err = NULL;\n    int job_flags = JOB_DEFAULT;\n\n    if (has_base && has_base_node) {\n        error_setg(errp, \"'base' and 'base-node' cannot be specified \"\n                   \"at the same time\");\n        return;\n    }\n\n    if (has_base && has_bottom) {\n        error_setg(errp, \"'base' and 'bottom' cannot be specified \"\n                   \"at the same time\");\n        return;\n    }\n\n    if (has_bottom && has_base_node) {\n        error_setg(errp, \"'bottom' and 'base-node' cannot be specified \"\n                   \"at the same time\");\n        return;\n    }\n\n    if (!has_on_error) {\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n\n    bs = bdrv_lookup_bs(device, device, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (has_base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (base_bs == NULL) {\n            error_setg(errp, \"Can't find '%s' in the backing chain\", base);\n            goto out;\n        }\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n    }\n\n    if (has_base_node) {\n        base_bs = bdrv_lookup_bs(NULL, base_node, errp);\n        if (!base_bs) {\n            goto out;\n        }\n        if (bs == base_bs || !bdrv_chain_contains(bs, base_bs)) {\n            error_setg(errp, \"Node '%s' is not a backing image of '%s'\",\n                       base_node, device);\n            goto out;\n        }\n        assert(bdrv_get_aio_context(base_bs) == aio_context);\n        bdrv_refresh_filename(base_bs);\n    }\n\n    if (has_bottom) {\n        bottom_bs = bdrv_lookup_bs(NULL, bottom, errp);\n        if (!bottom_bs) {\n            goto out;\n        }\n        if (!bottom_bs->drv) {\n            error_setg(errp, \"Node '%s' is not open\", bottom);\n            goto out;\n        }\n        if (bottom_bs->drv->is_filter) {\n            error_setg(errp, \"Node '%s' is a filter, use a non-filter node \"\n                       \"as 'bottom'\", bottom);\n            goto out;\n        }\n        if (!bdrv_chain_contains(bs, bottom_bs)) {\n            error_setg(errp, \"Node '%s' is not in a chain starting from '%s'\",\n                       bottom, device);\n            goto out;\n        }\n        assert(bdrv_get_aio_context(bottom_bs) == aio_context);\n    }\n\n    /*\n     * Check for op blockers in the whole chain between bs and base (or bottom)\n     */\n    iter_end = has_bottom ? bdrv_filter_or_cow_bs(bottom_bs) : base_bs;\n    for (iter = bs; iter && iter != iter_end;\n         iter = bdrv_filter_or_cow_bs(iter))\n    {\n        if (bdrv_op_is_blocked(iter, BLOCK_OP_TYPE_STREAM, errp)) {\n            goto out;\n        }\n    }\n\n    /* if we are streaming the entire chain, the result will have no backing\n     * file, and specifying one is therefore an error */\n    if (base_bs == NULL && has_backing_file) {\n        error_setg(errp, \"backing file specified, but streaming the \"\n                         \"entire chain\");\n        goto out;\n    }\n\n    if (has_auto_finalize && !auto_finalize) {\n        job_flags |= JOB_MANUAL_FINALIZE;\n    }\n    if (has_auto_dismiss && !auto_dismiss) {\n        job_flags |= JOB_MANUAL_DISMISS;\n    }\n\n    stream_start(has_job_id ? job_id : NULL, bs, base_bs, backing_file,\n                 bottom_bs, job_flags, has_speed ? speed : 0, on_error,\n                 filter_node_name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    trace_qmp_block_stream(bs);\n\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_commit(bool has_job_id, const char *job_id, const char *device,\n                      bool has_base_node, const char *base_node,\n                      bool has_base, const char *base,\n                      bool has_top_node, const char *top_node,\n                      bool has_top, const char *top,\n                      bool has_backing_file, const char *backing_file,\n                      bool has_speed, int64_t speed,\n                      bool has_on_error, BlockdevOnError on_error,\n                      bool has_filter_node_name, const char *filter_node_name,\n                      bool has_auto_finalize, bool auto_finalize,\n                      bool has_auto_dismiss, bool auto_dismiss,\n                      Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *iter;\n    BlockDriverState *base_bs, *top_bs;\n    AioContext *aio_context;\n    Error *local_err = NULL;\n    int job_flags = JOB_DEFAULT;\n    uint64_t top_perm, top_shared;\n\n    if (!has_speed) {\n        speed = 0;\n    }\n    if (!has_on_error) {\n        on_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!has_filter_node_name) {\n        filter_node_name = NULL;\n    }\n    if (has_auto_finalize && !auto_finalize) {\n        job_flags |= JOB_MANUAL_FINALIZE;\n    }\n    if (has_auto_dismiss && !auto_dismiss) {\n        job_flags |= JOB_MANUAL_DISMISS;\n    }\n\n    /* Important Note:\n     *  libvirt relies on the DeviceNotFound error class in order to probe for\n     *  live commit feature versions; for this to work, we must make sure to\n     *  perform the device lookup before any generic errors that may occur in a\n     *  scenario in which all optional arguments are omitted. */\n    bs = qmp_get_root_bs(device, &local_err);\n    if (!bs) {\n        bs = bdrv_lookup_bs(device, device, NULL);\n        if (!bs) {\n            error_free(local_err);\n            error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n                      \"Device '%s' not found\", device);\n        } else {\n            error_propagate(errp, local_err);\n        }\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT_SOURCE, errp)) {\n        goto out;\n    }\n\n    /* default top_bs is the active layer */\n    top_bs = bs;\n\n    if (has_top_node && has_top) {\n        error_setg(errp, \"'top-node' and 'top' are mutually exclusive\");\n        goto out;\n    } else if (has_top_node) {\n        top_bs = bdrv_lookup_bs(NULL, top_node, errp);\n        if (top_bs == NULL) {\n            goto out;\n        }\n        if (!bdrv_chain_contains(bs, top_bs)) {\n            error_setg(errp, \"'%s' is not in this backing file chain\",\n                       top_node);\n            goto out;\n        }\n    } else if (has_top && top) {\n        /* This strcmp() is just a shortcut, there is no need to\n         * refresh @bs's filename.  If it mismatches,\n         * bdrv_find_backing_image() will do the refresh and may still\n         * return @bs. */\n        if (strcmp(bs->filename, top) != 0) {\n            top_bs = bdrv_find_backing_image(bs, top);\n        }\n    }\n\n    if (top_bs == NULL) {\n        error_setg(errp, \"Top image file %s not found\", top ? top : \"NULL\");\n        goto out;\n    }\n\n    assert(bdrv_get_aio_context(top_bs) == aio_context);\n\n    if (has_base_node && has_base) {\n        error_setg(errp, \"'base-node' and 'base' are mutually exclusive\");\n        goto out;\n    } else if (has_base_node) {\n        base_bs = bdrv_lookup_bs(NULL, base_node, errp);\n        if (base_bs == NULL) {\n            goto out;\n        }\n        if (!bdrv_chain_contains(top_bs, base_bs)) {\n            error_setg(errp, \"'%s' is not in this backing file chain\",\n                       base_node);\n            goto out;\n        }\n    } else if (has_base && base) {\n        base_bs = bdrv_find_backing_image(top_bs, base);\n        if (base_bs == NULL) {\n            error_setg(errp, \"Can't find '%s' in the backing chain\", base);\n            goto out;\n        }\n    } else {\n        base_bs = bdrv_find_base(top_bs);\n        if (base_bs == NULL) {\n            error_setg(errp, \"There is no backimg image\");\n            goto out;\n        }\n    }\n\n    assert(bdrv_get_aio_context(base_bs) == aio_context);\n\n    for (iter = top_bs; iter != bdrv_filter_or_cow_bs(base_bs);\n         iter = bdrv_filter_or_cow_bs(iter))\n    {\n        if (bdrv_op_is_blocked(iter, BLOCK_OP_TYPE_COMMIT_TARGET, errp)) {\n            goto out;\n        }\n    }\n\n    /* Do not allow attempts to commit an image into itself */\n    if (top_bs == base_bs) {\n        error_setg(errp, \"cannot commit an image into itself\");\n        goto out;\n    }\n\n    /*\n     * Active commit is required if and only if someone has taken a\n     * WRITE permission on the top node.  Historically, we have always\n     * used active commit for top nodes, so continue that practice\n     * lest we possibly break clients that rely on this behavior, e.g.\n     * to later attach this node to a writing parent.\n     * (Active commit is never really wrong.)\n     */\n    bdrv_get_cumulative_perm(top_bs, &top_perm, &top_shared);\n    if (top_perm & BLK_PERM_WRITE ||\n        bdrv_skip_filters(top_bs) == bdrv_skip_filters(bs))\n    {\n        if (has_backing_file) {\n            if (bdrv_skip_filters(top_bs) == bdrv_skip_filters(bs)) {\n                error_setg(errp, \"'backing-file' specified,\"\n                                 \" but 'top' is the active layer\");\n            } else {\n                error_setg(errp, \"'backing-file' specified, but 'top' has a \"\n                                 \"writer on it\");\n            }\n            goto out;\n        }\n        if (!has_job_id) {\n            /*\n             * Emulate here what block_job_create() does, because it\n             * is possible that @bs != @top_bs (the block job should\n             * be named after @bs, even if @top_bs is the actual\n             * source)\n             */\n            job_id = bdrv_get_device_name(bs);\n        }\n        commit_active_start(job_id, top_bs, base_bs, job_flags, speed, on_error,\n                            filter_node_name, NULL, NULL, false, &local_err);\n    } else {\n        BlockDriverState *overlay_bs = bdrv_find_overlay(bs, top_bs);\n        if (bdrv_op_is_blocked(overlay_bs, BLOCK_OP_TYPE_COMMIT_TARGET, errp)) {\n            goto out;\n        }\n        commit_start(has_job_id ? job_id : NULL, bs, base_bs, top_bs, job_flags,\n                     speed, on_error, has_backing_file ? backing_file : NULL,\n                     filter_node_name, &local_err);\n    }\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\nout:\n    aio_context_release(aio_context);\n}\n\n/* Common QMP interface for drive-backup and blockdev-backup */\nstatic BlockJob *do_backup_common(BackupCommon *backup,\n                                  BlockDriverState *bs,\n                                  BlockDriverState *target_bs,\n                                  AioContext *aio_context,\n                                  JobTxn *txn, Error **errp)\n{\n    BlockJob *job = NULL;\n    BdrvDirtyBitmap *bmap = NULL;\n    BackupPerf perf = { .max_workers = 64 };\n    int job_flags = JOB_DEFAULT;\n\n    if (!backup->has_speed) {\n        backup->speed = 0;\n    }\n    if (!backup->has_on_source_error) {\n        backup->on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!backup->has_on_target_error) {\n        backup->on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!backup->has_job_id) {\n        backup->job_id = NULL;\n    }\n    if (!backup->has_auto_finalize) {\n        backup->auto_finalize = true;\n    }\n    if (!backup->has_auto_dismiss) {\n        backup->auto_dismiss = true;\n    }\n    if (!backup->has_compress) {\n        backup->compress = false;\n    }\n\n    if (backup->x_perf) {\n        if (backup->x_perf->has_use_copy_range) {\n            perf.use_copy_range = backup->x_perf->use_copy_range;\n        }\n        if (backup->x_perf->has_max_workers) {\n            perf.max_workers = backup->x_perf->max_workers;\n        }\n        if (backup->x_perf->has_max_chunk) {\n            perf.max_chunk = backup->x_perf->max_chunk;\n        }\n    }\n\n    if ((backup->sync == MIRROR_SYNC_MODE_BITMAP) ||\n        (backup->sync == MIRROR_SYNC_MODE_INCREMENTAL)) {\n        /* done before desugaring 'incremental' to print the right message */\n        if (!backup->has_bitmap) {\n            error_setg(errp, \"must provide a valid bitmap name for \"\n                       \"'%s' sync mode\", MirrorSyncMode_str(backup->sync));\n            return NULL;\n        }\n    }\n\n    if (backup->sync == MIRROR_SYNC_MODE_INCREMENTAL) {\n        if (backup->has_bitmap_mode &&\n            backup->bitmap_mode != BITMAP_SYNC_MODE_ON_SUCCESS) {\n            error_setg(errp, \"Bitmap sync mode must be '%s' \"\n                       \"when using sync mode '%s'\",\n                       BitmapSyncMode_str(BITMAP_SYNC_MODE_ON_SUCCESS),\n                       MirrorSyncMode_str(backup->sync));\n            return NULL;\n        }\n        backup->has_bitmap_mode = true;\n        backup->sync = MIRROR_SYNC_MODE_BITMAP;\n        backup->bitmap_mode = BITMAP_SYNC_MODE_ON_SUCCESS;\n    }\n\n    if (backup->has_bitmap) {\n        bmap = bdrv_find_dirty_bitmap(bs, backup->bitmap);\n        if (!bmap) {\n            error_setg(errp, \"Bitmap '%s' could not be found\", backup->bitmap);\n            return NULL;\n        }\n        if (!backup->has_bitmap_mode) {\n            error_setg(errp, \"Bitmap sync mode must be given \"\n                       \"when providing a bitmap\");\n            return NULL;\n        }\n        if (bdrv_dirty_bitmap_check(bmap, BDRV_BITMAP_ALLOW_RO, errp)) {\n            return NULL;\n        }\n\n        /* This does not produce a useful bitmap artifact: */\n        if (backup->sync == MIRROR_SYNC_MODE_NONE) {\n            error_setg(errp, \"sync mode '%s' does not produce meaningful bitmap\"\n                       \" outputs\", MirrorSyncMode_str(backup->sync));\n            return NULL;\n        }\n\n        /* If the bitmap isn't used for input or output, this is useless: */\n        if (backup->bitmap_mode == BITMAP_SYNC_MODE_NEVER &&\n            backup->sync != MIRROR_SYNC_MODE_BITMAP) {\n            error_setg(errp, \"Bitmap sync mode '%s' has no meaningful effect\"\n                       \" when combined with sync mode '%s'\",\n                       BitmapSyncMode_str(backup->bitmap_mode),\n                       MirrorSyncMode_str(backup->sync));\n            return NULL;\n        }\n    }\n\n    if (!backup->has_bitmap && backup->has_bitmap_mode) {\n        error_setg(errp, \"Cannot specify bitmap sync mode without a bitmap\");\n        return NULL;\n    }\n\n    if (!backup->auto_finalize) {\n        job_flags |= JOB_MANUAL_FINALIZE;\n    }\n    if (!backup->auto_dismiss) {\n        job_flags |= JOB_MANUAL_DISMISS;\n    }\n\n    job = backup_job_create(backup->job_id, bs, target_bs, backup->speed,\n                            backup->sync, bmap, backup->bitmap_mode,\n                            backup->compress,\n                            backup->filter_node_name,\n                            &perf,\n                            backup->on_source_error,\n                            backup->on_target_error,\n                            job_flags, NULL, NULL, txn, errp);\n    return job;\n}\n\nvoid qmp_drive_backup(DriveBackup *backup, Error **errp)\n{\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_DRIVE_BACKUP,\n        .u.drive_backup.data = backup,\n    };\n    blockdev_do_action(&action, errp);\n}\n\nBlockDeviceInfoList *qmp_query_named_block_nodes(bool has_flat,\n                                                 bool flat,\n                                                 Error **errp)\n{\n    bool return_flat = has_flat && flat;\n\n    return bdrv_named_nodes_list(return_flat, errp);\n}\n\nXDbgBlockGraph *qmp_x_debug_query_block_graph(Error **errp)\n{\n    return bdrv_get_xdbg_block_graph(errp);\n}\n\nvoid qmp_blockdev_backup(BlockdevBackup *backup, Error **errp)\n{\n    TransactionAction action = {\n        .type = TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP,\n        .u.blockdev_backup.data = backup,\n    };\n    blockdev_do_action(&action, errp);\n}\n\n/* Parameter check and block job starting for drive mirroring.\n * Caller should hold @device and @target's aio context (must be the same).\n **/\nstatic void blockdev_mirror_common(const char *job_id, BlockDriverState *bs,\n                                   BlockDriverState *target,\n                                   bool has_replaces, const char *replaces,\n                                   enum MirrorSyncMode sync,\n                                   BlockMirrorBackingMode backing_mode,\n                                   bool zero_target,\n                                   bool has_speed, int64_t speed,\n                                   bool has_granularity, uint32_t granularity,\n                                   bool has_buf_size, int64_t buf_size,\n                                   bool has_on_source_error,\n                                   BlockdevOnError on_source_error,\n                                   bool has_on_target_error,\n                                   BlockdevOnError on_target_error,\n                                   bool has_unmap, bool unmap,\n                                   bool has_filter_node_name,\n                                   const char *filter_node_name,\n                                   bool has_copy_mode, MirrorCopyMode copy_mode,\n                                   bool has_auto_finalize, bool auto_finalize,\n                                   bool has_auto_dismiss, bool auto_dismiss,\n                                   Error **errp)\n{\n    BlockDriverState *unfiltered_bs;\n    int job_flags = JOB_DEFAULT;\n\n    if (!has_speed) {\n        speed = 0;\n    }\n    if (!has_on_source_error) {\n        on_source_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!has_on_target_error) {\n        on_target_error = BLOCKDEV_ON_ERROR_REPORT;\n    }\n    if (!has_granularity) {\n        granularity = 0;\n    }\n    if (!has_buf_size) {\n        buf_size = 0;\n    }\n    if (!has_unmap) {\n        unmap = true;\n    }\n    if (!has_filter_node_name) {\n        filter_node_name = NULL;\n    }\n    if (!has_copy_mode) {\n        copy_mode = MIRROR_COPY_MODE_BACKGROUND;\n    }\n    if (has_auto_finalize && !auto_finalize) {\n        job_flags |= JOB_MANUAL_FINALIZE;\n    }\n    if (has_auto_dismiss && !auto_dismiss) {\n        job_flags |= JOB_MANUAL_DISMISS;\n    }\n\n    if (granularity != 0 && (granularity < 512 || granularity > 1048576 * 64)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"granularity\",\n                   \"a value in range [512B, 64MB]\");\n        return;\n    }\n    if (granularity & (granularity - 1)) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"granularity\",\n                   \"a power of 2\");\n        return;\n    }\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_MIRROR_SOURCE, errp)) {\n        return;\n    }\n    if (bdrv_op_is_blocked(target, BLOCK_OP_TYPE_MIRROR_TARGET, errp)) {\n        return;\n    }\n\n    if (!bdrv_backing_chain_next(bs) && sync == MIRROR_SYNC_MODE_TOP) {\n        sync = MIRROR_SYNC_MODE_FULL;\n    }\n\n    if (!has_replaces) {\n        /* We want to mirror from @bs, but keep implicit filters on top */\n        unfiltered_bs = bdrv_skip_implicit_filters(bs);\n        if (unfiltered_bs != bs) {\n            replaces = unfiltered_bs->node_name;\n            has_replaces = true;\n        }\n    }\n\n    if (has_replaces) {\n        BlockDriverState *to_replace_bs;\n        AioContext *replace_aio_context;\n        int64_t bs_size, replace_size;\n\n        bs_size = bdrv_getlength(bs);\n        if (bs_size < 0) {\n            error_setg_errno(errp, -bs_size, \"Failed to query device's size\");\n            return;\n        }\n\n        to_replace_bs = check_to_replace_node(bs, replaces, errp);\n        if (!to_replace_bs) {\n            return;\n        }\n\n        replace_aio_context = bdrv_get_aio_context(to_replace_bs);\n        aio_context_acquire(replace_aio_context);\n        replace_size = bdrv_getlength(to_replace_bs);\n        aio_context_release(replace_aio_context);\n\n        if (replace_size < 0) {\n            error_setg_errno(errp, -replace_size,\n                             \"Failed to query the replacement node's size\");\n            return;\n        }\n        if (bs_size != replace_size) {\n            error_setg(errp, \"cannot replace image with a mirror image of \"\n                             \"different size\");\n            return;\n        }\n    }\n\n    /* pass the node name to replace to mirror start since it's loose coupling\n     * and will allow to check whether the node still exist at mirror completion\n     */\n    mirror_start(job_id, bs, target,\n                 has_replaces ? replaces : NULL, job_flags,\n                 speed, granularity, buf_size, sync, backing_mode, zero_target,\n                 on_source_error, on_target_error, unmap, filter_node_name,\n                 copy_mode, errp);\n}\n\nvoid qmp_drive_mirror(DriveMirror *arg, Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *target_backing_bs, *target_bs;\n    AioContext *aio_context;\n    AioContext *old_context;\n    BlockMirrorBackingMode backing_mode;\n    Error *local_err = NULL;\n    QDict *options = NULL;\n    int flags;\n    int64_t size;\n    const char *format = arg->format;\n    bool zero_target;\n    int ret;\n\n    bs = qmp_get_root_bs(arg->device, errp);\n    if (!bs) {\n        return;\n    }\n\n    /* Early check to avoid creating target */\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_MIRROR_SOURCE, errp)) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (!arg->has_mode) {\n        arg->mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n    }\n\n    if (!arg->has_format) {\n        format = (arg->mode == NEW_IMAGE_MODE_EXISTING\n                  ? NULL : bs->drv->format_name);\n    }\n\n    flags = bs->open_flags | BDRV_O_RDWR;\n    target_backing_bs = bdrv_cow_bs(bdrv_skip_filters(bs));\n    if (!target_backing_bs && arg->sync == MIRROR_SYNC_MODE_TOP) {\n        arg->sync = MIRROR_SYNC_MODE_FULL;\n    }\n    if (arg->sync == MIRROR_SYNC_MODE_NONE) {\n        target_backing_bs = bs;\n    }\n\n    size = bdrv_getlength(bs);\n    if (size < 0) {\n        error_setg_errno(errp, -size, \"bdrv_getlength failed\");\n        goto out;\n    }\n\n    if (arg->has_replaces) {\n        if (!arg->has_node_name) {\n            error_setg(errp, \"a node-name must be provided when replacing a\"\n                             \" named node of the graph\");\n            goto out;\n        }\n    }\n\n    if (arg->mode == NEW_IMAGE_MODE_ABSOLUTE_PATHS) {\n        backing_mode = MIRROR_SOURCE_BACKING_CHAIN;\n    } else {\n        backing_mode = MIRROR_OPEN_BACKING_CHAIN;\n    }\n\n    /* Don't open backing image in create() */\n    flags |= BDRV_O_NO_BACKING;\n\n    if ((arg->sync == MIRROR_SYNC_MODE_FULL || !target_backing_bs)\n        && arg->mode != NEW_IMAGE_MODE_EXISTING)\n    {\n        /* create new image w/o backing file */\n        assert(format);\n        bdrv_img_create(arg->target, format,\n                        NULL, NULL, NULL, size, flags, false, &local_err);\n    } else {\n        /* Implicit filters should not appear in the filename */\n        BlockDriverState *explicit_backing =\n            bdrv_skip_implicit_filters(target_backing_bs);\n\n        switch (arg->mode) {\n        case NEW_IMAGE_MODE_EXISTING:\n            break;\n        case NEW_IMAGE_MODE_ABSOLUTE_PATHS:\n            /* create new image with backing file */\n            bdrv_refresh_filename(explicit_backing);\n            bdrv_img_create(arg->target, format,\n                            explicit_backing->filename,\n                            explicit_backing->drv->format_name,\n                            NULL, size, flags, false, &local_err);\n            break;\n        default:\n            abort();\n        }\n    }\n\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    options = qdict_new();\n    if (arg->has_node_name) {\n        qdict_put_str(options, \"node-name\", arg->node_name);\n    }\n    if (format) {\n        qdict_put_str(options, \"driver\", format);\n    }\n\n    /* Mirroring takes care of copy-on-write using the source's backing\n     * file.\n     */\n    target_bs = bdrv_open(arg->target, NULL, options, flags, errp);\n    if (!target_bs) {\n        goto out;\n    }\n\n    zero_target = (arg->sync == MIRROR_SYNC_MODE_FULL &&\n                   (arg->mode == NEW_IMAGE_MODE_EXISTING ||\n                    !bdrv_has_zero_init(target_bs)));\n\n\n    /* Honor bdrv_try_set_aio_context() context acquisition requirements. */\n    old_context = bdrv_get_aio_context(target_bs);\n    aio_context_release(aio_context);\n    aio_context_acquire(old_context);\n\n    ret = bdrv_try_set_aio_context(target_bs, aio_context, errp);\n    if (ret < 0) {\n        bdrv_unref(target_bs);\n        aio_context_release(old_context);\n        return;\n    }\n\n    aio_context_release(old_context);\n    aio_context_acquire(aio_context);\n\n    blockdev_mirror_common(arg->has_job_id ? arg->job_id : NULL, bs, target_bs,\n                           arg->has_replaces, arg->replaces, arg->sync,\n                           backing_mode, zero_target,\n                           arg->has_speed, arg->speed,\n                           arg->has_granularity, arg->granularity,\n                           arg->has_buf_size, arg->buf_size,\n                           arg->has_on_source_error, arg->on_source_error,\n                           arg->has_on_target_error, arg->on_target_error,\n                           arg->has_unmap, arg->unmap,\n                           false, NULL,\n                           arg->has_copy_mode, arg->copy_mode,\n                           arg->has_auto_finalize, arg->auto_finalize,\n                           arg->has_auto_dismiss, arg->auto_dismiss,\n                           errp);\n    bdrv_unref(target_bs);\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_blockdev_mirror(bool has_job_id, const char *job_id,\n                         const char *device, const char *target,\n                         bool has_replaces, const char *replaces,\n                         MirrorSyncMode sync,\n                         bool has_speed, int64_t speed,\n                         bool has_granularity, uint32_t granularity,\n                         bool has_buf_size, int64_t buf_size,\n                         bool has_on_source_error,\n                         BlockdevOnError on_source_error,\n                         bool has_on_target_error,\n                         BlockdevOnError on_target_error,\n                         bool has_filter_node_name,\n                         const char *filter_node_name,\n                         bool has_copy_mode, MirrorCopyMode copy_mode,\n                         bool has_auto_finalize, bool auto_finalize,\n                         bool has_auto_dismiss, bool auto_dismiss,\n                         Error **errp)\n{\n    BlockDriverState *bs;\n    BlockDriverState *target_bs;\n    AioContext *aio_context;\n    AioContext *old_context;\n    BlockMirrorBackingMode backing_mode = MIRROR_LEAVE_BACKING_CHAIN;\n    bool zero_target;\n    int ret;\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return;\n    }\n\n    target_bs = bdrv_lookup_bs(target, target, errp);\n    if (!target_bs) {\n        return;\n    }\n\n    zero_target = (sync == MIRROR_SYNC_MODE_FULL);\n\n    /* Honor bdrv_try_set_aio_context() context acquisition requirements. */\n    old_context = bdrv_get_aio_context(target_bs);\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(old_context);\n\n    ret = bdrv_try_set_aio_context(target_bs, aio_context, errp);\n\n    aio_context_release(old_context);\n    aio_context_acquire(aio_context);\n\n    if (ret < 0) {\n        goto out;\n    }\n\n    blockdev_mirror_common(has_job_id ? job_id : NULL, bs, target_bs,\n                           has_replaces, replaces, sync, backing_mode,\n                           zero_target, has_speed, speed,\n                           has_granularity, granularity,\n                           has_buf_size, buf_size,\n                           has_on_source_error, on_source_error,\n                           has_on_target_error, on_target_error,\n                           true, true,\n                           has_filter_node_name, filter_node_name,\n                           has_copy_mode, copy_mode,\n                           has_auto_finalize, auto_finalize,\n                           has_auto_dismiss, auto_dismiss,\n                           errp);\nout:\n    aio_context_release(aio_context);\n}\n\n/* Get a block job using its ID and acquire its AioContext */\nstatic BlockJob *find_block_job(const char *id, AioContext **aio_context,\n                                Error **errp)\n{\n    BlockJob *job;\n\n    assert(id != NULL);\n\n    *aio_context = NULL;\n\n    job = block_job_get(id);\n\n    if (!job) {\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,\n                  \"Block job '%s' not found\", id);\n        return NULL;\n    }\n\n    *aio_context = block_job_get_aio_context(job);\n    aio_context_acquire(*aio_context);\n\n    return job;\n}\n\nvoid qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    block_job_set_speed(job, speed, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_cancel(const char *device,\n                          bool has_force, bool force, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    if (!has_force) {\n        force = false;\n    }\n\n    if (job_user_paused(&job->job) && !force) {\n        error_setg(errp, \"The block job for device '%s' is currently paused\",\n                   device);\n        goto out;\n    }\n\n    trace_qmp_block_job_cancel(job);\n    job_user_cancel(&job->job, force, errp);\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_pause(const char *device, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_block_job_pause(job);\n    job_user_pause(&job->job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_resume(const char *device, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_block_job_resume(job);\n    job_user_resume(&job->job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_complete(const char *device, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(device, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_block_job_complete(job);\n    job_complete(&job->job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_finalize(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *job = find_block_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_block_job_finalize(job);\n    job_ref(&job->job);\n    job_finalize(&job->job, errp);\n\n    /*\n     * Job's context might have changed via job_finalize (and job_txn_apply\n     * automatically acquires the new one), so make sure we release the correct\n     * one.\n     */\n    aio_context = block_job_get_aio_context(job);\n    job_unref(&job->job);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_block_job_dismiss(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    BlockJob *bjob = find_block_job(id, &aio_context, errp);\n    Job *job;\n\n    if (!bjob) {\n        return;\n    }\n\n    trace_qmp_block_job_dismiss(bjob);\n    job = &bjob->job;\n    job_dismiss(&job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_change_backing_file(const char *device,\n                             const char *image_node_name,\n                             const char *backing_file,\n                             Error **errp)\n{\n    BlockDriverState *bs = NULL;\n    AioContext *aio_context;\n    BlockDriverState *image_bs = NULL;\n    Error *local_err = NULL;\n    bool ro;\n    int ret;\n\n    bs = qmp_get_root_bs(device, errp);\n    if (!bs) {\n        return;\n    }\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    image_bs = bdrv_lookup_bs(NULL, image_node_name, &local_err);\n    if (local_err) {\n        error_propagate(errp, local_err);\n        goto out;\n    }\n\n    if (!image_bs) {\n        error_setg(errp, \"image file not found\");\n        goto out;\n    }\n\n    if (bdrv_find_base(image_bs) == image_bs) {\n        error_setg(errp, \"not allowing backing file change on an image \"\n                         \"without a backing file\");\n        goto out;\n    }\n\n    /* even though we are not necessarily operating on bs, we need it to\n     * determine if block ops are currently prohibited on the chain */\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_CHANGE, errp)) {\n        goto out;\n    }\n\n    /* final sanity check */\n    if (!bdrv_chain_contains(bs, image_bs)) {\n        error_setg(errp, \"'%s' and image file are not in the same chain\",\n                   device);\n        goto out;\n    }\n\n    /* if not r/w, reopen to make r/w */\n    ro = bdrv_is_read_only(image_bs);\n\n    if (ro) {\n        if (bdrv_reopen_set_read_only(image_bs, false, errp) != 0) {\n            goto out;\n        }\n    }\n\n    ret = bdrv_change_backing_file(image_bs, backing_file,\n                                   image_bs->drv ? image_bs->drv->format_name : \"\",\n                                   false);\n\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not change backing file to '%s'\",\n                         backing_file);\n        /* don't exit here, so we can try to restore open flags if\n         * appropriate */\n    }\n\n    if (ro) {\n        bdrv_reopen_set_read_only(image_bs, true, errp);\n    }\n\nout:\n    aio_context_release(aio_context);\n}\n\nvoid qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n{\n    BlockDriverState *bs;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n    QDict *qdict;\n\n    visit_type_BlockdevOptions(v, NULL, &options, &error_abort);\n    visit_complete(v, &obj);\n    qdict = qobject_to(QDict, obj);\n\n    qdict_flatten(qdict);\n\n    if (!qdict_get_try_str(qdict, \"node-name\")) {\n        error_setg(errp, \"'node-name' must be specified for the root node\");\n        goto fail;\n    }\n\n    bs = bds_tree_init(qdict, errp);\n    if (!bs) {\n        goto fail;\n    }\n\n    bdrv_set_monitor_owned(bs);\n\nfail:\n    visit_free(v);\n}\n\nvoid qmp_blockdev_reopen(BlockdevOptionsList *reopen_list, Error **errp)\n{\n    BlockReopenQueue *queue = NULL;\n    GSList *drained = NULL;\n    GSList *p;\n\n    /* Add each one of the BDS that we want to reopen to the queue */\n    for (; reopen_list != NULL; reopen_list = reopen_list->next) {\n        BlockdevOptions *options = reopen_list->value;\n        BlockDriverState *bs;\n        AioContext *ctx;\n        QObject *obj;\n        Visitor *v;\n        QDict *qdict;\n\n        /* Check for the selected node name */\n        if (!options->has_node_name) {\n            error_setg(errp, \"node-name not specified\");\n            goto fail;\n        }\n\n        bs = bdrv_find_node(options->node_name);\n        if (!bs) {\n            error_setg(errp, \"Failed to find node with node-name='%s'\",\n                       options->node_name);\n            goto fail;\n        }\n\n        /* Put all options in a QDict and flatten it */\n        v = qobject_output_visitor_new(&obj);\n        visit_type_BlockdevOptions(v, NULL, &options, &error_abort);\n        visit_complete(v, &obj);\n        visit_free(v);\n\n        qdict = qobject_to(QDict, obj);\n\n        qdict_flatten(qdict);\n\n        ctx = bdrv_get_aio_context(bs);\n        aio_context_acquire(ctx);\n\n        bdrv_subtree_drained_begin(bs);\n        queue = bdrv_reopen_queue(queue, bs, qdict, false);\n        drained = g_slist_prepend(drained, bs);\n\n        aio_context_release(ctx);\n    }\n\n    /* Perform the reopen operation */\n    bdrv_reopen_multiple(queue, errp);\n    queue = NULL;\n\nfail:\n    bdrv_reopen_queue_free(queue);\n    for (p = drained; p; p = p->next) {\n        BlockDriverState *bs = p->data;\n        AioContext *ctx = bdrv_get_aio_context(bs);\n\n        aio_context_acquire(ctx);\n        bdrv_subtree_drained_end(bs);\n        aio_context_release(ctx);\n    }\n    g_slist_free(drained);\n}\n\nvoid qmp_blockdev_del(const char *node_name, Error **errp)\n{\n    AioContext *aio_context;\n    BlockDriverState *bs;\n\n    GLOBAL_STATE_CODE();\n\n    bs = bdrv_find_node(node_name);\n    if (!bs) {\n        error_setg(errp, \"Failed to find node with node-name='%s'\", node_name);\n        return;\n    }\n    if (bdrv_has_blk(bs)) {\n        error_setg(errp, \"Node %s is in use\", node_name);\n        return;\n    }\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_DRIVE_DEL, errp)) {\n        goto out;\n    }\n\n    if (!QTAILQ_IN_USE(bs, monitor_list)) {\n        error_setg(errp, \"Node %s is not owned by the monitor\",\n                   bs->node_name);\n        goto out;\n    }\n\n    if (bs->refcnt > 1) {\n        error_setg(errp, \"Block device %s is in use\",\n                   bdrv_get_device_or_node_name(bs));\n        goto out;\n    }\n\n    QTAILQ_REMOVE(&monitor_bdrv_states, bs, monitor_list);\n    bdrv_unref(bs);\n\nout:\n    aio_context_release(aio_context);\n}\n\nstatic BdrvChild *bdrv_find_child(BlockDriverState *parent_bs,\n                                  const char *child_name)\n{\n    BdrvChild *child;\n\n    QLIST_FOREACH(child, &parent_bs->children, next) {\n        if (strcmp(child->name, child_name) == 0) {\n            return child;\n        }\n    }\n\n    return NULL;\n}\n\nvoid qmp_x_blockdev_change(const char *parent, bool has_child,\n                           const char *child, bool has_node,\n                           const char *node, Error **errp)\n{\n    BlockDriverState *parent_bs, *new_bs = NULL;\n    BdrvChild *p_child;\n\n    parent_bs = bdrv_lookup_bs(parent, parent, errp);\n    if (!parent_bs) {\n        return;\n    }\n\n    if (has_child == has_node) {\n        if (has_child) {\n            error_setg(errp, \"The parameters child and node are in conflict\");\n        } else {\n            error_setg(errp, \"Either child or node must be specified\");\n        }\n        return;\n    }\n\n    if (has_child) {\n        p_child = bdrv_find_child(parent_bs, child);\n        if (!p_child) {\n            error_setg(errp, \"Node '%s' does not have child '%s'\",\n                       parent, child);\n            return;\n        }\n        bdrv_del_child(parent_bs, p_child, errp);\n    }\n\n    if (has_node) {\n        new_bs = bdrv_find_node(node);\n        if (!new_bs) {\n            error_setg(errp, \"Node '%s' not found\", node);\n            return;\n        }\n        bdrv_add_child(parent_bs, new_bs, errp);\n    }\n}\n\nBlockJobInfoList *qmp_query_block_jobs(Error **errp)\n{\n    BlockJobInfoList *head = NULL, **tail = &head;\n    BlockJob *job;\n\n    for (job = block_job_next(NULL); job; job = block_job_next(job)) {\n        BlockJobInfo *value;\n        AioContext *aio_context;\n\n        if (block_job_is_internal(job)) {\n            continue;\n        }\n        aio_context = block_job_get_aio_context(job);\n        aio_context_acquire(aio_context);\n        value = block_job_query(job, errp);\n        aio_context_release(aio_context);\n        if (!value) {\n            qapi_free_BlockJobInfoList(head);\n            return NULL;\n        }\n        QAPI_LIST_APPEND(tail, value);\n    }\n\n    return head;\n}\n\nvoid qmp_x_blockdev_set_iothread(const char *node_name, StrOrNull *iothread,\n                                 bool has_force, bool force, Error **errp)\n{\n    AioContext *old_context;\n    AioContext *new_context;\n    BlockDriverState *bs;\n\n    bs = bdrv_find_node(node_name);\n    if (!bs) {\n        error_setg(errp, \"Failed to find node with node-name='%s'\", node_name);\n        return;\n    }\n\n    /* Protects against accidents. */\n    if (!(has_force && force) && bdrv_has_blk(bs)) {\n        error_setg(errp, \"Node %s is associated with a BlockBackend and could \"\n                         \"be in use (use force=true to override this check)\",\n                         node_name);\n        return;\n    }\n\n    if (iothread->type == QTYPE_QSTRING) {\n        IOThread *obj = iothread_by_id(iothread->u.s);\n        if (!obj) {\n            error_setg(errp, \"Cannot find iothread %s\", iothread->u.s);\n            return;\n        }\n\n        new_context = iothread_get_aio_context(obj);\n    } else {\n        new_context = qemu_get_aio_context();\n    }\n\n    old_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(old_context);\n\n    bdrv_try_set_aio_context(bs, new_context, errp);\n\n    aio_context_release(old_context);\n}\n\nQemuOptsList qemu_common_drive_opts = {\n    .name = \"drive\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_common_drive_opts.head),\n    .desc = {\n        {\n            .name = \"snapshot\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"enable/disable snapshot mode\",\n        },{\n            .name = \"aio\",\n            .type = QEMU_OPT_STRING,\n            .help = \"host AIO implementation (threads, native, io_uring)\",\n        },{\n            .name = BDRV_OPT_CACHE_WB,\n            .type = QEMU_OPT_BOOL,\n            .help = \"Enable writeback mode\",\n        },{\n            .name = \"format\",\n            .type = QEMU_OPT_STRING,\n            .help = \"disk format (raw, qcow2, ...)\",\n        },{\n            .name = \"rerror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"read error action\",\n        },{\n            .name = \"werror\",\n            .type = QEMU_OPT_STRING,\n            .help = \"write error action\",\n        },{\n            .name = BDRV_OPT_READ_ONLY,\n            .type = QEMU_OPT_BOOL,\n            .help = \"open drive file as read-only\",\n        },\n\n        THROTTLE_OPTS,\n\n        {\n            .name = \"throttling.group\",\n            .type = QEMU_OPT_STRING,\n            .help = \"name of the block throttling group\",\n        },{\n            .name = \"copy-on-read\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"copy read data from backing file into image file\",\n        },{\n            .name = \"detect-zeroes\",\n            .type = QEMU_OPT_STRING,\n            .help = \"try to optimize zero writes (off, on, unmap)\",\n        },{\n            .name = \"stats-account-invalid\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"whether to account for invalid I/O operations \"\n                    \"in the statistics\",\n        },{\n            .name = \"stats-account-failed\",\n            .type = QEMU_OPT_BOOL,\n            .help = \"whether to account for failed I/O operations \"\n                    \"in the statistics\",\n        },\n        { /* end of list */ }\n    },\n};\n\nQemuOptsList qemu_drive_opts = {\n    .name = \"drive\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_drive_opts.head),\n    .desc = {\n        /*\n         * no elements => accept any params\n         * validation will happen later\n         */\n        { /* end of list */ }\n    },\n};\n"
        },
        {
          "name": "blockjob.c",
          "type": "blob",
          "size": 16.1328125,
          "content": "/*\n * QEMU System Emulator block driver\n *\n * Copyright (c) 2011 IBM Corp.\n * Copyright (c) 2012 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"block/block.h\"\n#include \"block/blockjob_int.h\"\n#include \"block/block_int.h\"\n#include \"block/trace.h\"\n#include \"sysemu/block-backend.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qapi-events-block-core.h\"\n#include \"qapi/qmp/qerror.h\"\n#include \"qemu/coroutine.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/timer.h\"\n\n/*\n * The block job API is composed of two categories of functions.\n *\n * The first includes functions used by the monitor.  The monitor is\n * peculiar in that it accesses the block job list with block_job_get, and\n * therefore needs consistency across block_job_get and the actual operation\n * (e.g. block_job_set_speed).  The consistency is achieved with\n * aio_context_acquire/release.  These functions are declared in blockjob.h.\n *\n * The second includes functions used by the block job drivers and sometimes\n * by the core block layer.  These do not care about locking, because the\n * whole coroutine runs under the AioContext lock, and are declared in\n * blockjob_int.h.\n */\n\nstatic bool is_block_job(Job *job)\n{\n    return job_type(job) == JOB_TYPE_BACKUP ||\n           job_type(job) == JOB_TYPE_COMMIT ||\n           job_type(job) == JOB_TYPE_MIRROR ||\n           job_type(job) == JOB_TYPE_STREAM;\n}\n\nBlockJob *block_job_next(BlockJob *bjob)\n{\n    Job *job = bjob ? &bjob->job : NULL;\n    GLOBAL_STATE_CODE();\n\n    do {\n        job = job_next(job);\n    } while (job && !is_block_job(job));\n\n    return job ? container_of(job, BlockJob, job) : NULL;\n}\n\nBlockJob *block_job_get(const char *id)\n{\n    Job *job = job_get(id);\n    GLOBAL_STATE_CODE();\n\n    if (job && is_block_job(job)) {\n        return container_of(job, BlockJob, job);\n    } else {\n        return NULL;\n    }\n}\n\nvoid block_job_free(Job *job)\n{\n    BlockJob *bjob = container_of(job, BlockJob, job);\n    GLOBAL_STATE_CODE();\n\n    block_job_remove_all_bdrv(bjob);\n    ratelimit_destroy(&bjob->limit);\n    error_free(bjob->blocker);\n}\n\nstatic char *child_job_get_parent_desc(BdrvChild *c)\n{\n    BlockJob *job = c->opaque;\n    return g_strdup_printf(\"%s job '%s'\", job_type_str(&job->job), job->job.id);\n}\n\nstatic void child_job_drained_begin(BdrvChild *c)\n{\n    BlockJob *job = c->opaque;\n    job_pause(&job->job);\n}\n\nstatic bool child_job_drained_poll(BdrvChild *c)\n{\n    BlockJob *bjob = c->opaque;\n    Job *job = &bjob->job;\n    const BlockJobDriver *drv = block_job_driver(bjob);\n\n    /* An inactive or completed job doesn't have any pending requests. Jobs\n     * with !job->busy are either already paused or have a pause point after\n     * being reentered, so no job driver code will run before they pause. */\n    if (!job->busy || job_is_completed(job)) {\n        return false;\n    }\n\n    /* Otherwise, assume that it isn't fully stopped yet, but allow the job to\n     * override this assumption. */\n    if (drv->drained_poll) {\n        return drv->drained_poll(bjob);\n    } else {\n        return true;\n    }\n}\n\nstatic void child_job_drained_end(BdrvChild *c, int *drained_end_counter)\n{\n    BlockJob *job = c->opaque;\n    job_resume(&job->job);\n}\n\nstatic bool child_job_can_set_aio_ctx(BdrvChild *c, AioContext *ctx,\n                                      GSList **ignore, Error **errp)\n{\n    BlockJob *job = c->opaque;\n    GSList *l;\n\n    for (l = job->nodes; l; l = l->next) {\n        BdrvChild *sibling = l->data;\n        if (!bdrv_child_can_set_aio_context(sibling, ctx, ignore, errp)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nstatic void child_job_set_aio_ctx(BdrvChild *c, AioContext *ctx,\n                                  GSList **ignore)\n{\n    BlockJob *job = c->opaque;\n    GSList *l;\n\n    for (l = job->nodes; l; l = l->next) {\n        BdrvChild *sibling = l->data;\n        if (g_slist_find(*ignore, sibling)) {\n            continue;\n        }\n        *ignore = g_slist_prepend(*ignore, sibling);\n        bdrv_set_aio_context_ignore(sibling->bs, ctx, ignore);\n    }\n\n    job->job.aio_context = ctx;\n}\n\nstatic AioContext *child_job_get_parent_aio_context(BdrvChild *c)\n{\n    BlockJob *job = c->opaque;\n\n    return job->job.aio_context;\n}\n\nstatic const BdrvChildClass child_job = {\n    .get_parent_desc    = child_job_get_parent_desc,\n    .drained_begin      = child_job_drained_begin,\n    .drained_poll       = child_job_drained_poll,\n    .drained_end        = child_job_drained_end,\n    .can_set_aio_ctx    = child_job_can_set_aio_ctx,\n    .set_aio_ctx        = child_job_set_aio_ctx,\n    .stay_at_node       = true,\n    .get_parent_aio_context = child_job_get_parent_aio_context,\n};\n\nvoid block_job_remove_all_bdrv(BlockJob *job)\n{\n    GLOBAL_STATE_CODE();\n    /*\n     * bdrv_root_unref_child() may reach child_job_[can_]set_aio_ctx(),\n     * which will also traverse job->nodes, so consume the list one by\n     * one to make sure that such a concurrent access does not attempt\n     * to process an already freed BdrvChild.\n     */\n    while (job->nodes) {\n        GSList *l = job->nodes;\n        BdrvChild *c = l->data;\n\n        job->nodes = l->next;\n\n        bdrv_op_unblock_all(c->bs, job->blocker);\n        bdrv_root_unref_child(c);\n\n        g_slist_free_1(l);\n    }\n}\n\nbool block_job_has_bdrv(BlockJob *job, BlockDriverState *bs)\n{\n    GSList *el;\n    GLOBAL_STATE_CODE();\n\n    for (el = job->nodes; el; el = el->next) {\n        BdrvChild *c = el->data;\n        if (c->bs == bs) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint block_job_add_bdrv(BlockJob *job, const char *name, BlockDriverState *bs,\n                       uint64_t perm, uint64_t shared_perm, Error **errp)\n{\n    BdrvChild *c;\n    bool need_context_ops;\n    GLOBAL_STATE_CODE();\n\n    bdrv_ref(bs);\n\n    need_context_ops = bdrv_get_aio_context(bs) != job->job.aio_context;\n\n    if (need_context_ops && job->job.aio_context != qemu_get_aio_context()) {\n        aio_context_release(job->job.aio_context);\n    }\n    c = bdrv_root_attach_child(bs, name, &child_job, 0, perm, shared_perm, job,\n                               errp);\n    if (need_context_ops && job->job.aio_context != qemu_get_aio_context()) {\n        aio_context_acquire(job->job.aio_context);\n    }\n    if (c == NULL) {\n        return -EPERM;\n    }\n\n    job->nodes = g_slist_prepend(job->nodes, c);\n    bdrv_op_block_all(bs, job->blocker);\n\n    return 0;\n}\n\nstatic void block_job_on_idle(Notifier *n, void *opaque)\n{\n    aio_wait_kick();\n}\n\nbool block_job_is_internal(BlockJob *job)\n{\n    return (job->job.id == NULL);\n}\n\nconst BlockJobDriver *block_job_driver(BlockJob *job)\n{\n    return container_of(job->job.driver, BlockJobDriver, job_driver);\n}\n\n/* Assumes the job_mutex is held */\nstatic bool job_timer_pending(Job *job)\n{\n    return timer_pending(&job->sleep_timer);\n}\n\nbool block_job_set_speed(BlockJob *job, int64_t speed, Error **errp)\n{\n    const BlockJobDriver *drv = block_job_driver(job);\n    int64_t old_speed = job->speed;\n\n    GLOBAL_STATE_CODE();\n\n    if (job_apply_verb(&job->job, JOB_VERB_SET_SPEED, errp) < 0) {\n        return false;\n    }\n    if (speed < 0) {\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"speed\",\n                   \"a non-negative value\");\n        return false;\n    }\n\n    ratelimit_set_speed(&job->limit, speed, BLOCK_JOB_SLICE_TIME);\n\n    job->speed = speed;\n\n    if (drv->set_speed) {\n        drv->set_speed(job, speed);\n    }\n\n    if (speed && speed <= old_speed) {\n        return true;\n    }\n\n    /* kick only if a timer is pending */\n    job_enter_cond(&job->job, job_timer_pending);\n\n    return true;\n}\n\nint64_t block_job_ratelimit_get_delay(BlockJob *job, uint64_t n)\n{\n    IO_CODE();\n    return ratelimit_calculate_delay(&job->limit, n);\n}\n\nBlockJobInfo *block_job_query(BlockJob *job, Error **errp)\n{\n    BlockJobInfo *info;\n    uint64_t progress_current, progress_total;\n\n    GLOBAL_STATE_CODE();\n\n    if (block_job_is_internal(job)) {\n        error_setg(errp, \"Cannot query QEMU internal jobs\");\n        return NULL;\n    }\n\n    progress_get_snapshot(&job->job.progress, &progress_current,\n                          &progress_total);\n\n    info = g_new0(BlockJobInfo, 1);\n    info->type      = g_strdup(job_type_str(&job->job));\n    info->device    = g_strdup(job->job.id);\n    info->busy      = qatomic_read(&job->job.busy);\n    info->paused    = job->job.pause_count > 0;\n    info->offset    = progress_current;\n    info->len       = progress_total;\n    info->speed     = job->speed;\n    info->io_status = job->iostatus;\n    info->ready     = job_is_ready(&job->job),\n    info->status    = job->job.status;\n    info->auto_finalize = job->job.auto_finalize;\n    info->auto_dismiss  = job->job.auto_dismiss;\n    if (job->job.ret) {\n        info->has_error = true;\n        info->error = job->job.err ?\n                        g_strdup(error_get_pretty(job->job.err)) :\n                        g_strdup(strerror(-job->job.ret));\n    }\n    return info;\n}\n\nstatic void block_job_iostatus_set_err(BlockJob *job, int error)\n{\n    if (job->iostatus == BLOCK_DEVICE_IO_STATUS_OK) {\n        job->iostatus = error == ENOSPC ? BLOCK_DEVICE_IO_STATUS_NOSPACE :\n                                          BLOCK_DEVICE_IO_STATUS_FAILED;\n    }\n}\n\nstatic void block_job_event_cancelled(Notifier *n, void *opaque)\n{\n    BlockJob *job = opaque;\n    uint64_t progress_current, progress_total;\n\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    progress_get_snapshot(&job->job.progress, &progress_current,\n                          &progress_total);\n\n    qapi_event_send_block_job_cancelled(job_type(&job->job),\n                                        job->job.id,\n                                        progress_total,\n                                        progress_current,\n                                        job->speed);\n}\n\nstatic void block_job_event_completed(Notifier *n, void *opaque)\n{\n    BlockJob *job = opaque;\n    const char *msg = NULL;\n    uint64_t progress_current, progress_total;\n\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    if (job->job.ret < 0) {\n        msg = error_get_pretty(job->job.err);\n    }\n\n    progress_get_snapshot(&job->job.progress, &progress_current,\n                          &progress_total);\n\n    qapi_event_send_block_job_completed(job_type(&job->job),\n                                        job->job.id,\n                                        progress_total,\n                                        progress_current,\n                                        job->speed,\n                                        !!msg,\n                                        msg);\n}\n\nstatic void block_job_event_pending(Notifier *n, void *opaque)\n{\n    BlockJob *job = opaque;\n\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    qapi_event_send_block_job_pending(job_type(&job->job),\n                                      job->job.id);\n}\n\nstatic void block_job_event_ready(Notifier *n, void *opaque)\n{\n    BlockJob *job = opaque;\n    uint64_t progress_current, progress_total;\n\n    if (block_job_is_internal(job)) {\n        return;\n    }\n\n    progress_get_snapshot(&job->job.progress, &progress_current,\n                          &progress_total);\n\n    qapi_event_send_block_job_ready(job_type(&job->job),\n                                    job->job.id,\n                                    progress_total,\n                                    progress_current,\n                                    job->speed);\n}\n\n\n/*\n * API for block job drivers and the block layer.  These functions are\n * declared in blockjob_int.h.\n */\n\nvoid *block_job_create(const char *job_id, const BlockJobDriver *driver,\n                       JobTxn *txn, BlockDriverState *bs, uint64_t perm,\n                       uint64_t shared_perm, int64_t speed, int flags,\n                       BlockCompletionFunc *cb, void *opaque, Error **errp)\n{\n    BlockJob *job;\n    int ret;\n    GLOBAL_STATE_CODE();\n\n    if (job_id == NULL && !(flags & JOB_INTERNAL)) {\n        job_id = bdrv_get_device_name(bs);\n    }\n\n    job = job_create(job_id, &driver->job_driver, txn, bdrv_get_aio_context(bs),\n                     flags, cb, opaque, errp);\n    if (job == NULL) {\n        return NULL;\n    }\n\n    assert(is_block_job(&job->job));\n    assert(job->job.driver->free == &block_job_free);\n    assert(job->job.driver->user_resume == &block_job_user_resume);\n\n    ratelimit_init(&job->limit);\n\n    job->finalize_cancelled_notifier.notify = block_job_event_cancelled;\n    job->finalize_completed_notifier.notify = block_job_event_completed;\n    job->pending_notifier.notify = block_job_event_pending;\n    job->ready_notifier.notify = block_job_event_ready;\n    job->idle_notifier.notify = block_job_on_idle;\n\n    notifier_list_add(&job->job.on_finalize_cancelled,\n                      &job->finalize_cancelled_notifier);\n    notifier_list_add(&job->job.on_finalize_completed,\n                      &job->finalize_completed_notifier);\n    notifier_list_add(&job->job.on_pending, &job->pending_notifier);\n    notifier_list_add(&job->job.on_ready, &job->ready_notifier);\n    notifier_list_add(&job->job.on_idle, &job->idle_notifier);\n\n    error_setg(&job->blocker, \"block device is in use by block job: %s\",\n               job_type_str(&job->job));\n\n    ret = block_job_add_bdrv(job, \"main node\", bs, perm, shared_perm, errp);\n    if (ret < 0) {\n        goto fail;\n    }\n\n    bdrv_op_unblock(bs, BLOCK_OP_TYPE_DATAPLANE, job->blocker);\n\n    if (!block_job_set_speed(job, speed, errp)) {\n        goto fail;\n    }\n\n    return job;\n\nfail:\n    job_early_fail(&job->job);\n    return NULL;\n}\n\nvoid block_job_iostatus_reset(BlockJob *job)\n{\n    GLOBAL_STATE_CODE();\n    if (job->iostatus == BLOCK_DEVICE_IO_STATUS_OK) {\n        return;\n    }\n    assert(job->job.user_paused && job->job.pause_count > 0);\n    job->iostatus = BLOCK_DEVICE_IO_STATUS_OK;\n}\n\nvoid block_job_user_resume(Job *job)\n{\n    BlockJob *bjob = container_of(job, BlockJob, job);\n    GLOBAL_STATE_CODE();\n    block_job_iostatus_reset(bjob);\n}\n\nBlockErrorAction block_job_error_action(BlockJob *job, BlockdevOnError on_err,\n                                        int is_read, int error)\n{\n    BlockErrorAction action;\n    IO_CODE();\n\n    switch (on_err) {\n    case BLOCKDEV_ON_ERROR_ENOSPC:\n    case BLOCKDEV_ON_ERROR_AUTO:\n        action = (error == ENOSPC) ?\n                 BLOCK_ERROR_ACTION_STOP : BLOCK_ERROR_ACTION_REPORT;\n        break;\n    case BLOCKDEV_ON_ERROR_STOP:\n        action = BLOCK_ERROR_ACTION_STOP;\n        break;\n    case BLOCKDEV_ON_ERROR_REPORT:\n        action = BLOCK_ERROR_ACTION_REPORT;\n        break;\n    case BLOCKDEV_ON_ERROR_IGNORE:\n        action = BLOCK_ERROR_ACTION_IGNORE;\n        break;\n    default:\n        abort();\n    }\n    if (!block_job_is_internal(job)) {\n        qapi_event_send_block_job_error(job->job.id,\n                                        is_read ? IO_OPERATION_TYPE_READ :\n                                        IO_OPERATION_TYPE_WRITE,\n                                        action);\n    }\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n        if (!job->job.user_paused) {\n            job_pause(&job->job);\n            /* make the pause user visible, which will be resumed from QMP. */\n            job->job.user_paused = true;\n        }\n        block_job_iostatus_set_err(job, error);\n    }\n    return action;\n}\n\nAioContext *block_job_get_aio_context(BlockJob *job)\n{\n    GLOBAL_STATE_CODE();\n    return job->job.aio_context;\n}\n"
        },
        {
          "name": "bsd-user",
          "type": "tree",
          "content": null
        },
        {
          "name": "chardev",
          "type": "tree",
          "content": null
        },
        {
          "name": "common-user",
          "type": "tree",
          "content": null
        },
        {
          "name": "configs",
          "type": "tree",
          "content": null
        },
        {
          "name": "configure",
          "type": "blob",
          "size": 81.1435546875,
          "content": "#!/bin/sh\n#\n# qemu configure script (c) 2003 Fabrice Bellard\n#\n\n# Unset some variables known to interfere with behavior of common tools,\n# just as autoconf does.\nCLICOLOR_FORCE= GREP_OPTIONS=\nunset CLICOLOR_FORCE GREP_OPTIONS\n\n# Don't allow CCACHE, if present, to use cached results of compile tests!\nexport CCACHE_RECACHE=yes\n\n# make source path absolute\nsource_path=$(cd \"$(dirname -- \"$0\")\"; pwd)\n\nif test \"$PWD\" = \"$source_path\"\nthen\n    echo \"Using './build' as the directory for build output\"\n\n    MARKER=build/auto-created-by-configure\n\n    if test -e build\n    then\n        if test -f $MARKER\n        then\n           rm -rf build\n        else\n            echo \"ERROR: ./build dir already exists and was not previously created by configure\"\n            exit 1\n        fi\n    fi\n\n    mkdir build\n    touch $MARKER\n\n    cat > GNUmakefile <<'EOF'\n# This file is auto-generated by configure to support in-source tree\n# 'make' command invocation\n\nifeq ($(MAKECMDGOALS),)\nrecurse: all\nendif\n\n.NOTPARALLEL: %\n%: force\n\t@echo 'changing dir to build for $(MAKE) \"$(MAKECMDGOALS)\"...'\n\t@$(MAKE) -C build -f Makefile $(MAKECMDGOALS)\n\t@if test \"$(MAKECMDGOALS)\" = \"distclean\" && \\\n\t    test -e build/auto-created-by-configure ; \\\n\tthen \\\n\t    rm -rf build GNUmakefile ; \\\n\tfi\nforce: ;\n.PHONY: force\nGNUmakefile: ;\n\nEOF\n    cd build\n    exec $source_path/configure \"$@\"\nfi\n\n# Temporary directory used for files created while\n# configure runs. Since it is in the build directory\n# we can safely blow away any previous version of it\n# (and we need not jump through hoops to try to delete\n# it when configure exits.)\nTMPDIR1=\"config-temp\"\nrm -rf \"${TMPDIR1}\"\nmkdir -p \"${TMPDIR1}\"\nif [ $? -ne 0 ]; then\n    echo \"ERROR: failed to create temporary directory\"\n    exit 1\nfi\n\nTMPB=\"qemu-conf\"\nTMPC=\"${TMPDIR1}/${TMPB}.c\"\nTMPO=\"${TMPDIR1}/${TMPB}.o\"\nTMPCXX=\"${TMPDIR1}/${TMPB}.cxx\"\nTMPM=\"${TMPDIR1}/${TMPB}.m\"\nTMPE=\"${TMPDIR1}/${TMPB}.exe\"\n\nrm -f config.log\n\n# Print a helpful header at the top of config.log\necho \"# QEMU configure log $(date)\" >> config.log\nprintf \"# Configured with:\" >> config.log\nprintf \" '%s'\" \"$0\" \"$@\" >> config.log\necho >> config.log\necho \"#\" >> config.log\n\nquote_sh() {\n    printf \"%s\" \"$1\" | sed \"s,','\\\\\\\\'',g; s,.*,'&',\"\n}\n\nprint_error() {\n    (echo\n    echo \"ERROR: $1\"\n    while test -n \"$2\"; do\n        echo \"       $2\"\n        shift\n    done\n    echo) >&2\n}\n\nerror_exit() {\n    print_error \"$@\"\n    exit 1\n}\n\ndo_compiler() {\n  # Run the compiler, capturing its output to the log. First argument\n  # is compiler binary to execute.\n  local compiler=\"$1\"\n  shift\n  if test -n \"$BASH_VERSION\"; then eval '\n      echo >>config.log \"\nfuncs: ${FUNCNAME[*]}\nlines: ${BASH_LINENO[*]}\"\n  '; fi\n  echo $compiler \"$@\" >> config.log\n  $compiler \"$@\" >> config.log 2>&1 || return $?\n}\n\ndo_compiler_werror() {\n    # Run the compiler, capturing its output to the log. First argument\n    # is compiler binary to execute.\n    compiler=\"$1\"\n    shift\n    if test -n \"$BASH_VERSION\"; then eval '\n        echo >>config.log \"\nfuncs: ${FUNCNAME[*]}\nlines: ${BASH_LINENO[*]}\"\n    '; fi\n    echo $compiler \"$@\" >> config.log\n    $compiler \"$@\" >> config.log 2>&1 || return $?\n    # Test passed. If this is an --enable-werror build, rerun\n    # the test with -Werror and bail out if it fails. This\n    # makes warning-generating-errors in configure test code\n    # obvious to developers.\n    if test \"$werror\" != \"yes\"; then\n        return 0\n    fi\n    # Don't bother rerunning the compile if we were already using -Werror\n    case \"$*\" in\n        *-Werror*)\n           return 0\n        ;;\n    esac\n    echo $compiler -Werror \"$@\" >> config.log\n    $compiler -Werror \"$@\" >> config.log 2>&1 && return $?\n    error_exit \"configure test passed without -Werror but failed with -Werror.\" \\\n        \"This is probably a bug in the configure script. The failing command\" \\\n        \"will be at the bottom of config.log.\" \\\n        \"You can run configure with --disable-werror to bypass this check.\"\n}\n\ndo_cc() {\n    do_compiler_werror \"$cc\" $CPU_CFLAGS \"$@\"\n}\n\ndo_cxx() {\n    do_compiler_werror \"$cxx\" $CPU_CFLAGS \"$@\"\n}\n\ndo_objc() {\n    do_compiler_werror \"$objcc\" $CPU_CFLAGS \"$@\"\n}\n\n# Append $2 to the variable named $1, with space separation\nadd_to() {\n    eval $1=\\${$1:+\\\"\\$$1 \\\"}\\$2\n}\n\nupdate_cxxflags() {\n    # Set QEMU_CXXFLAGS from QEMU_CFLAGS by filtering out those\n    # options which some versions of GCC's C++ compiler complain about\n    # because they only make sense for C programs.\n    QEMU_CXXFLAGS=\"-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS\"\n    CONFIGURE_CXXFLAGS=$(echo \"$CONFIGURE_CFLAGS\" | sed s/-std=gnu11/-std=gnu++11/)\n    for arg in $QEMU_CFLAGS; do\n        case $arg in\n            -Wstrict-prototypes|-Wmissing-prototypes|-Wnested-externs|\\\n            -Wold-style-declaration|-Wold-style-definition|-Wredundant-decls)\n                ;;\n            *)\n                QEMU_CXXFLAGS=${QEMU_CXXFLAGS:+$QEMU_CXXFLAGS }$arg\n                ;;\n        esac\n    done\n}\n\ncompile_object() {\n  local_cflags=\"$1\"\n  do_cc $CFLAGS $EXTRA_CFLAGS $CONFIGURE_CFLAGS $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC\n}\n\ncompile_prog() {\n  local_cflags=\"$1\"\n  local_ldflags=\"$2\"\n  do_cc $CFLAGS $EXTRA_CFLAGS $CONFIGURE_CFLAGS $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC \\\n      $LDFLAGS $EXTRA_LDFLAGS $CONFIGURE_LDFLAGS $QEMU_LDFLAGS $local_ldflags\n}\n\n# symbolically link $1 to $2.  Portable version of \"ln -sf\".\nsymlink() {\n  rm -rf \"$2\"\n  mkdir -p \"$(dirname \"$2\")\"\n  ln -s \"$1\" \"$2\"\n}\n\n# check whether a command is available to this shell (may be either an\n# executable or a builtin)\nhas() {\n    type \"$1\" >/dev/null 2>&1\n}\n\nversion_ge () {\n    local_ver1=$(expr \"$1\" : '\\([0-9.]*\\)' | tr . ' ')\n    local_ver2=$(echo \"$2\" | tr . ' ')\n    while true; do\n        set x $local_ver1\n        local_first=${2-0}\n        # 'shift 2' if $2 is set, or 'shift' if $2 is not set\n        shift ${2:+2}\n        local_ver1=$*\n        set x $local_ver2\n        # the second argument finished, the first must be greater or equal\n        test $# = 1 && return 0\n        test $local_first -lt $2 && return 1\n        test $local_first -gt $2 && return 0\n        shift ${2:+2}\n        local_ver2=$*\n    done\n}\n\nglob() {\n    eval test -z '\"${1#'\"$2\"'}\"'\n}\n\nif printf %s\\\\n \"$source_path\" \"$PWD\" | grep -q \"[[:space:]:]\";\nthen\n  error_exit \"main directory cannot contain spaces nor colons\"\nfi\n\n# default parameters\ncpu=\"\"\nstatic=\"no\"\ncross_compile=\"no\"\ncross_prefix=\"\"\nhost_cc=\"cc\"\nstack_protector=\"\"\nsafe_stack=\"\"\nuse_containers=\"yes\"\ngdb_bin=$(command -v \"gdb-multiarch\" || command -v \"gdb\")\n\nif test -e \"$source_path/.git\"\nthen\n    git_submodules_action=\"update\"\nelse\n    git_submodules_action=\"ignore\"\nfi\n\ngit_submodules=\"ui/keycodemapdb\"\ngit=\"git\"\n\n# Don't accept a target_list environment variable.\nunset target_list\nunset target_list_exclude\n\n# Default value for a variable defining feature \"foo\".\n#  * foo=\"no\"  feature will only be used if --enable-foo arg is given\n#  * foo=\"\"    feature will be searched for, and if found, will be used\n#              unless --disable-foo is given\n#  * foo=\"yes\" this value will only be set by --enable-foo flag.\n#              feature will searched for,\n#              if not found, configure exits with error\n#\n# Always add --enable-foo and --disable-foo command line args.\n# Distributions want to ensure that several features are compiled in, and it\n# is impossible without a --enable-foo that exits if a feature is not found.\n\ndefault_feature=\"\"\n# parse CC options second\nfor opt do\n  optarg=$(expr \"x$opt\" : 'x[^=]*=\\(.*\\)')\n  case \"$opt\" in\n      --without-default-features)\n          default_feature=\"no\"\n  ;;\n  esac\ndone\n\nEXTRA_CFLAGS=\"\"\nEXTRA_CXXFLAGS=\"\"\nEXTRA_OBJCFLAGS=\"\"\nEXTRA_LDFLAGS=\"\"\n\ndebug_tcg=\"no\"\nsanitizers=\"no\"\ntsan=\"no\"\nfortify_source=\"yes\"\nEXESUF=\"\"\nmodules=\"no\"\nprefix=\"/usr/local\"\nqemu_suffix=\"qemu\"\nsoftmmu=\"yes\"\nlinux_user=\"\"\nbsd_user=\"\"\npie=\"\"\ncoroutine=\"\"\nplugins=\"$default_feature\"\nmeson=\"\"\nmeson_args=\"\"\nninja=\"\"\nbindir=\"bin\"\nskip_meson=no\nvfio_user_server=\"disabled\"\n\n# The following Meson options are handled manually (still they\n# are included in the automatically generated help message)\n\n# 1. Track which submodules are needed\nif test \"$default_feature\" = no ; then\n  slirp=\"disabled\"\nelse\n  slirp=\"auto\"\nfi\nfdt=\"auto\"\n\n# 2. Automatically enable/disable other options\ntcg=\"auto\"\ncfi=\"false\"\n\n# parse CC options second\nfor opt do\n  optarg=$(expr \"x$opt\" : 'x[^=]*=\\(.*\\)')\n  case \"$opt\" in\n  --cross-prefix=*) cross_prefix=\"$optarg\"\n                    cross_compile=\"yes\"\n  ;;\n  --cc=*) CC=\"$optarg\"\n  ;;\n  --cxx=*) CXX=\"$optarg\"\n  ;;\n  --cpu=*) cpu=\"$optarg\"\n  ;;\n  --extra-cflags=*)\n    EXTRA_CFLAGS=\"$EXTRA_CFLAGS $optarg\"\n    EXTRA_CXXFLAGS=\"$EXTRA_CXXFLAGS $optarg\"\n    EXTRA_OBJCFLAGS=\"$EXTRA_OBJCFLAGS $optarg\"\n    ;;\n  --extra-cxxflags=*) EXTRA_CXXFLAGS=\"$EXTRA_CXXFLAGS $optarg\"\n  ;;\n  --extra-objcflags=*) EXTRA_OBJCFLAGS=\"$EXTRA_OBJCFLAGS $optarg\"\n  ;;\n  --extra-ldflags=*) EXTRA_LDFLAGS=\"$EXTRA_LDFLAGS $optarg\"\n  ;;\n  --cross-cc-*[!a-zA-Z0-9_-]*=*) error_exit \"Passed bad --cross-cc-FOO option\"\n  ;;\n  --cross-cc-cflags-*) cc_arch=${opt#--cross-cc-cflags-}; cc_arch=${cc_arch%%=*}\n                      eval \"cross_cc_cflags_${cc_arch}=\\$optarg\"\n  ;;\n  --cross-cc-*) cc_arch=${opt#--cross-cc-}; cc_arch=${cc_arch%%=*}\n                eval \"cross_cc_${cc_arch}=\\$optarg\"\n  ;;\n  --cross-prefix-*[!a-zA-Z0-9_-]*=*) error_exit \"Passed bad --cross-prefix-FOO option\"\n  ;;\n  --cross-prefix-*) cc_arch=${opt#--cross-prefix-}; cc_arch=${cc_arch%%=*}\n                    eval \"cross_prefix_${cc_arch}=\\$optarg\"\n  ;;\n  esac\ndone\n# OS specific\n# Using uname is really, really broken.  Once we have the right set of checks\n# we can eliminate its usage altogether.\n\n# Preferred compiler:\n#  ${CC} (if set)\n#  ${cross_prefix}gcc (if cross-prefix specified)\n#  system compiler\nif test -z \"${CC}${cross_prefix}\"; then\n  cc=\"$host_cc\"\nelse\n  cc=\"${CC-${cross_prefix}gcc}\"\nfi\n\nif test -z \"${CXX}${cross_prefix}\"; then\n  cxx=\"c++\"\nelse\n  cxx=\"${CXX-${cross_prefix}g++}\"\nfi\n\nar=\"${AR-${cross_prefix}ar}\"\nas=\"${AS-${cross_prefix}as}\"\nccas=\"${CCAS-$cc}\"\nobjcopy=\"${OBJCOPY-${cross_prefix}objcopy}\"\nld=\"${LD-${cross_prefix}ld}\"\nranlib=\"${RANLIB-${cross_prefix}ranlib}\"\nnm=\"${NM-${cross_prefix}nm}\"\nsmbd=\"$SMBD\"\nstrip=\"${STRIP-${cross_prefix}strip}\"\nwidl=\"${WIDL-${cross_prefix}widl}\"\nwindres=\"${WINDRES-${cross_prefix}windres}\"\npkg_config_exe=\"${PKG_CONFIG-${cross_prefix}pkg-config}\"\nquery_pkg_config() {\n    \"${pkg_config_exe}\" ${QEMU_PKG_CONFIG_FLAGS} \"$@\"\n}\npkg_config=query_pkg_config\nsdl2_config=\"${SDL2_CONFIG-${cross_prefix}sdl2-config}\"\n\n# default flags for all hosts\n# We use -fwrapv to tell the compiler that we require a C dialect where\n# left shift of signed integers is well defined and has the expected\n# 2s-complement style results. (Both clang and gcc agree that it\n# provides these semantics.)\nQEMU_CFLAGS=\"-fno-strict-aliasing -fno-common -fwrapv\"\nQEMU_CFLAGS=\"-Wundef -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS\"\nQEMU_CFLAGS=\"-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS\"\nQEMU_CFLAGS=\"-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS\"\n\nQEMU_LDFLAGS=\n\n# Flags that are needed during configure but later taken care of by Meson\nCONFIGURE_CFLAGS=\"-std=gnu11 -Wall\"\nCONFIGURE_LDFLAGS=\n\n\ncheck_define() {\ncat > $TMPC <<EOF\n#if !defined($1)\n#error $1 not defined\n#endif\nint main(void) { return 0; }\nEOF\n  compile_object\n}\n\ncheck_include() {\ncat > $TMPC <<EOF\n#include <$1>\nint main(void) { return 0; }\nEOF\n  compile_object\n}\n\nwrite_c_skeleton() {\n    cat > $TMPC <<EOF\nint main(void) { return 0; }\nEOF\n}\n\nif check_define __linux__ ; then\n  targetos=linux\nelif check_define _WIN32 ; then\n  targetos=windows\nelif check_define __OpenBSD__ ; then\n  targetos=openbsd\nelif check_define __sun__ ; then\n  targetos=sunos\nelif check_define __HAIKU__ ; then\n  targetos=haiku\nelif check_define __FreeBSD__ ; then\n  targetos=freebsd\nelif check_define __FreeBSD_kernel__ && check_define __GLIBC__; then\n  targetos=gnu/kfreebsd\nelif check_define __DragonFly__ ; then\n  targetos=dragonfly\nelif check_define __NetBSD__; then\n  targetos=netbsd\nelif check_define __APPLE__; then\n  targetos=darwin\nelse\n  # This is a fatal error, but don't report it yet, because we\n  # might be going to just print the --help text, or it might\n  # be the result of a missing compiler.\n  targetos=bogus\nfi\n\n# OS specific\n\nmingw32=\"no\"\nbsd=\"no\"\nlinux=\"no\"\nsolaris=\"no\"\ncase $targetos in\nwindows)\n  mingw32=\"yes\"\n  plugins=\"no\"\n  pie=\"no\"\n;;\ngnu/kfreebsd)\n  bsd=\"yes\"\n;;\nfreebsd)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n  # needed for kinfo_getvmmap(3) in libutil.h\n;;\ndragonfly)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n;;\nnetbsd)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n;;\nopenbsd)\n  bsd=\"yes\"\n  make=\"${MAKE-gmake}\"\n;;\ndarwin)\n  bsd=\"yes\"\n  darwin=\"yes\"\n  # Disable attempts to use ObjectiveC features in os/object.h since they\n  # won't work when we're compiling with gcc as a C compiler.\n  QEMU_CFLAGS=\"-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS\"\n;;\nsunos)\n  solaris=\"yes\"\n  make=\"${MAKE-gmake}\"\n# needed for CMSG_ macros in sys/socket.h\n  QEMU_CFLAGS=\"-D_XOPEN_SOURCE=600 $QEMU_CFLAGS\"\n# needed for TIOCWIN* defines in termios.h\n  QEMU_CFLAGS=\"-D__EXTENSIONS__ $QEMU_CFLAGS\"\n  # $(uname -m) returns i86pc even on an x86_64 box, so default based on isainfo\n  # Note that this check is broken for cross-compilation: if you're\n  # cross-compiling to one of these OSes then you'll need to specify\n  # the correct CPU with the --cpu option.\n  if test -z \"$cpu\" && test \"$(isainfo -k)\" = \"amd64\"; then\n    cpu=\"x86_64\"\n  fi\n;;\nhaiku)\n  pie=\"no\"\n  QEMU_CFLAGS=\"-DB_USE_POSITIVE_POSIX_ERRORS -D_BSD_SOURCE -fPIC $QEMU_CFLAGS\"\n;;\nlinux)\n  linux=\"yes\"\n;;\nesac\n\nif test ! -z \"$cpu\" ; then\n  # command line argument\n  :\nelif check_define __i386__ ; then\n  cpu=\"i386\"\nelif check_define __x86_64__ ; then\n  if check_define __ILP32__ ; then\n    cpu=\"x32\"\n  else\n    cpu=\"x86_64\"\n  fi\nelif check_define __sparc__ ; then\n  if check_define __arch64__ ; then\n    cpu=\"sparc64\"\n  else\n    cpu=\"sparc\"\n  fi\nelif check_define _ARCH_PPC ; then\n  if check_define _ARCH_PPC64 ; then\n    if check_define _LITTLE_ENDIAN ; then\n      cpu=\"ppc64le\"\n    else\n      cpu=\"ppc64\"\n    fi\n  else\n    cpu=\"ppc\"\n  fi\nelif check_define __mips__ ; then\n  cpu=\"mips\"\nelif check_define __s390__ ; then\n  if check_define __s390x__ ; then\n    cpu=\"s390x\"\n  else\n    cpu=\"s390\"\n  fi\nelif check_define __riscv ; then\n  cpu=\"riscv\"\nelif check_define __arm__ ; then\n  cpu=\"arm\"\nelif check_define __aarch64__ ; then\n  cpu=\"aarch64\"\nelif check_define __loongarch64 ; then\n  cpu=\"loongarch64\"\nelse\n  cpu=$(uname -m)\nfi\n\n# Normalise host CPU name, set multilib cflags\n# Note that this case should only have supported host CPUs, not guests.\ncase \"$cpu\" in\n  armv*b|armv*l|arm)\n    cpu=\"arm\" ;;\n\n  i386|i486|i586|i686|i86pc|BePC)\n    cpu=\"i386\"\n    CPU_CFLAGS=\"-m32\" ;;\n  x32)\n    cpu=\"x86_64\"\n    CPU_CFLAGS=\"-mx32\" ;;\n  x86_64|amd64)\n    cpu=\"x86_64\"\n    # ??? Only extremely old AMD cpus do not have cmpxchg16b.\n    # If we truly care, we should simply detect this case at\n    # runtime and generate the fallback to serial emulation.\n    CPU_CFLAGS=\"-m64 -mcx16\" ;;\n\n  mips*)\n    cpu=\"mips\" ;;\n\n  ppc)\n    CPU_CFLAGS=\"-m32\" ;;\n  ppc64)\n    CPU_CFLAGS=\"-m64 -mbig-endian\" ;;\n  ppc64le)\n    cpu=\"ppc64\"\n    CPU_CFLAGS=\"-m64 -mlittle-endian\" ;;\n\n  s390)\n    CPU_CFLAGS=\"-m31\" ;;\n  s390x)\n    CPU_CFLAGS=\"-m64\" ;;\n\n  sparc|sun4[cdmuv])\n    cpu=\"sparc\"\n    CPU_CFLAGS=\"-m32 -mv8plus -mcpu=ultrasparc\" ;;\n  sparc64)\n    CPU_CFLAGS=\"-m64 -mcpu=ultrasparc\" ;;\nesac\n\n: ${make=${MAKE-make}}\n\n# We prefer python 3.x. A bare 'python' is traditionally\n# python 2.x, but some distros have it as python 3.x, so\n# we check that too\npython=\nexplicit_python=no\nfor binary in \"${PYTHON-python3}\" python\ndo\n    if has \"$binary\"\n    then\n        python=$(command -v \"$binary\")\n        break\n    fi\ndone\n\n\n# Check for ancillary tools used in testing\ngenisoimage=\nfor binary in genisoimage mkisofs\ndo\n    if has $binary\n    then\n        genisoimage=$(command -v \"$binary\")\n        break\n    fi\ndone\n\n# Default objcc to clang if available, otherwise use CC\nif has clang; then\n  objcc=clang\nelse\n  objcc=\"$cc\"\nfi\n\nif test \"$mingw32\" = \"yes\" ; then\n  EXESUF=\".exe\"\n  # MinGW needs -mthreads for TLS and macro _MT.\n  CONFIGURE_CFLAGS=\"-mthreads $CONFIGURE_CFLAGS\"\n  write_c_skeleton;\n  prefix=\"/qemu\"\n  bindir=\"\"\n  qemu_suffix=\"\"\nfi\n\nwerror=\"\"\n\nmeson_option_build_array() {\n  printf '['\n  (if test \"$targetos\" = windows; then\n    IFS=\\;\n  else\n    IFS=:\n  fi\n  for e in $1; do\n    printf '\"\"\"'\n    # backslash escape any '\\' and '\"' characters\n    printf \"%s\" \"$e\" | sed -e 's/\\([\\\"]\\)/\\\\\\1/g'\n    printf '\"\"\",'\n  done)\n  printf ']\\n'\n}\n\n. $source_path/scripts/meson-buildoptions.sh\n\nmeson_options=\nmeson_option_add() {\n  meson_options=\"$meson_options $(quote_sh \"$1\")\"\n}\nmeson_option_parse() {\n  meson_options=\"$meson_options $(_meson_option_parse \"$@\")\"\n  if test $? -eq 1; then\n    echo \"ERROR: unknown option $1\"\n    echo \"Try '$0 --help' for more information\"\n    exit 1\n  fi\n}\n\nfor opt do\n  optarg=$(expr \"x$opt\" : 'x[^=]*=\\(.*\\)')\n  case \"$opt\" in\n  --help|-h) show_help=yes\n  ;;\n  --version|-V) exec cat $source_path/VERSION.QEMU\n  ;;\n  --prefix=*) prefix=\"$optarg\"\n  ;;\n  --cross-prefix=*)\n  ;;\n  --cc=*)\n  ;;\n  --host-cc=*) host_cc=\"$optarg\"\n  ;;\n  --cxx=*)\n  ;;\n  --objcc=*) objcc=\"$optarg\"\n  ;;\n  --make=*) make=\"$optarg\"\n  ;;\n  --install=*)\n  ;;\n  --python=*) python=\"$optarg\" ; explicit_python=yes\n  ;;\n  --skip-meson) skip_meson=yes\n  ;;\n  --meson=*) meson=\"$optarg\"\n  ;;\n  --ninja=*) ninja=\"$optarg\"\n  ;;\n  --smbd=*) smbd=\"$optarg\"\n  ;;\n  --extra-cflags=*)\n  ;;\n  --extra-cxxflags=*)\n  ;;\n  --extra-objcflags=*)\n  ;;\n  --extra-ldflags=*)\n  ;;\n  --cross-cc-*)\n  ;;\n  --cross-prefix-*)\n  ;;\n  --enable-debug-info) meson_option_add -Ddebug=true\n  ;;\n  --disable-debug-info) meson_option_add -Ddebug=false\n  ;;\n  --enable-modules)\n      modules=\"yes\"\n  ;;\n  --disable-modules)\n      modules=\"no\"\n  ;;\n  --cpu=*)\n  ;;\n  --target-list=*) target_list=\"$optarg\"\n                   if test \"$target_list_exclude\"; then\n                       error_exit \"Can't mix --target-list with --target-list-exclude\"\n                   fi\n  ;;\n  --target-list-exclude=*) target_list_exclude=\"$optarg\"\n                   if test \"$target_list\"; then\n                       error_exit \"Can't mix --target-list-exclude with --target-list\"\n                   fi\n  ;;\n  --with-default-devices) meson_option_add -Ddefault_devices=true\n  ;;\n  --without-default-devices) meson_option_add -Ddefault_devices=false\n  ;;\n  --with-devices-*[!a-zA-Z0-9_-]*=*) error_exit \"Passed bad --with-devices-FOO option\"\n  ;;\n  --with-devices-*) device_arch=${opt#--with-devices-};\n                    device_arch=${device_arch%%=*}\n                    cf=$source_path/configs/devices/$device_arch-softmmu/$optarg.mak\n                    if test -f \"$cf\"; then\n                        device_archs=\"$device_archs $device_arch\"\n                        eval \"devices_${device_arch}=\\$optarg\"\n                    else\n                        error_exit \"File $cf does not exist\"\n                    fi\n  ;;\n  --without-default-features) # processed above\n  ;;\n  --static)\n    static=\"yes\"\n    QEMU_PKG_CONFIG_FLAGS=\"--static $QEMU_PKG_CONFIG_FLAGS\"\n  ;;\n  --bindir=*) bindir=\"$optarg\"\n  ;;\n  --with-suffix=*) qemu_suffix=\"$optarg\"\n  ;;\n  --host=*|--build=*|\\\n  --disable-dependency-tracking|\\\n  --sbindir=*|--sharedstatedir=*|\\\n  --oldincludedir=*|--datarootdir=*|--infodir=*|\\\n  --htmldir=*|--dvidir=*|--pdfdir=*|--psdir=*)\n    # These switches are silently ignored, for compatibility with\n    # autoconf-generated configure scripts. This allows QEMU's\n    # configure to be used by RPM and similar macros that set\n    # lots of directory switches by default.\n  ;;\n  --enable-debug-tcg) debug_tcg=\"yes\"\n  ;;\n  --disable-debug-tcg) debug_tcg=\"no\"\n  ;;\n  --enable-debug)\n      # Enable debugging options that aren't excessively noisy\n      debug_tcg=\"yes\"\n      meson_option_parse --enable-debug-mutex \"\"\n      meson_option_add -Doptimization=0\n      fortify_source=\"no\"\n  ;;\n  --enable-sanitizers) sanitizers=\"yes\"\n  ;;\n  --disable-sanitizers) sanitizers=\"no\"\n  ;;\n  --enable-tsan) tsan=\"yes\"\n  ;;\n  --disable-tsan) tsan=\"no\"\n  ;;\n  --disable-slirp) slirp=\"disabled\"\n  ;;\n  --enable-slirp) slirp=\"enabled\"\n  ;;\n  --enable-slirp=git) slirp=\"internal\"\n  ;;\n  --enable-slirp=*) slirp=\"$optarg\"\n  ;;\n  --disable-tcg) tcg=\"disabled\"\n                 plugins=\"no\"\n  ;;\n  --enable-tcg) tcg=\"enabled\"\n  ;;\n  --disable-system) softmmu=\"no\"\n  ;;\n  --enable-system) softmmu=\"yes\"\n  ;;\n  --disable-user)\n      linux_user=\"no\" ;\n      bsd_user=\"no\" ;\n  ;;\n  --enable-user) ;;\n  --disable-linux-user) linux_user=\"no\"\n  ;;\n  --enable-linux-user) linux_user=\"yes\"\n  ;;\n  --disable-bsd-user) bsd_user=\"no\"\n  ;;\n  --enable-bsd-user) bsd_user=\"yes\"\n  ;;\n  --enable-pie) pie=\"yes\"\n  ;;\n  --disable-pie) pie=\"no\"\n  ;;\n  --enable-werror) werror=\"yes\"\n  ;;\n  --disable-werror) werror=\"no\"\n  ;;\n  --enable-stack-protector) stack_protector=\"yes\"\n  ;;\n  --disable-stack-protector) stack_protector=\"no\"\n  ;;\n  --enable-safe-stack) safe_stack=\"yes\"\n  ;;\n  --disable-safe-stack) safe_stack=\"no\"\n  ;;\n  --enable-cfi)\n      cfi=\"true\";\n      meson_option_add -Db_lto=true\n  ;;\n  --disable-cfi) cfi=\"false\"\n  ;;\n  --disable-fdt) fdt=\"disabled\"\n  ;;\n  --enable-fdt) fdt=\"enabled\"\n  ;;\n  --enable-fdt=git) fdt=\"internal\"\n  ;;\n  --enable-fdt=*) fdt=\"$optarg\"\n  ;;\n  --with-coroutine=*) coroutine=\"$optarg\"\n  ;;\n  --disable-zlib-test)\n  ;;\n  --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)\n      echo \"$0: $opt is obsolete, virtio-blk data-plane is always on\" >&2\n  ;;\n  --enable-vhdx|--disable-vhdx)\n      echo \"$0: $opt is obsolete, VHDX driver is always built\" >&2\n  ;;\n  --enable-uuid|--disable-uuid)\n      echo \"$0: $opt is obsolete, UUID support is always built\" >&2\n  ;;\n  --with-git=*) git=\"$optarg\"\n  ;;\n  --with-git-submodules=*)\n      git_submodules_action=\"$optarg\"\n  ;;\n  --enable-plugins) if test \"$mingw32\" = \"yes\"; then\n                        error_exit \"TCG plugins not currently supported on Windows platforms\"\n                    else\n                        plugins=\"yes\"\n                    fi\n  ;;\n  --disable-plugins) plugins=\"no\"\n  ;;\n  --enable-containers) use_containers=\"yes\"\n  ;;\n  --disable-containers) use_containers=\"no\"\n  ;;\n  --gdb=*) gdb_bin=\"$optarg\"\n  ;;\n  # backwards compatibility options\n  --enable-trace-backend=*) meson_option_parse \"--enable-trace-backends=$optarg\" \"$optarg\"\n  ;;\n  --disable-blobs) meson_option_parse --disable-install-blobs \"\"\n  ;;\n  --enable-vfio-user-server) vfio_user_server=\"enabled\"\n  ;;\n  --disable-vfio-user-server) vfio_user_server=\"disabled\"\n  ;;\n  --enable-tcmalloc) meson_option_parse --enable-malloc=tcmalloc tcmalloc\n  ;;\n  --enable-jemalloc) meson_option_parse --enable-malloc=jemalloc jemalloc\n  ;;\n  # everything else has the same name in configure and meson\n  --*) meson_option_parse \"$opt\" \"$optarg\"\n  ;;\n  esac\ndone\n\n# test for any invalid configuration combinations\nif test \"$plugins\" = \"yes\" -a \"$tcg\" = \"disabled\"; then\n    error_exit \"Can't enable plugins on non-TCG builds\"\nfi\n\ncase $git_submodules_action in\n    update|validate)\n        if test ! -e \"$source_path/.git\"; then\n            echo \"ERROR: cannot $git_submodules_action git submodules without .git\"\n            exit 1\n        fi\n    ;;\n    ignore)\n        if ! test -f \"$source_path/ui/keycodemapdb/README\"\n        then\n            echo\n            echo \"ERROR: missing GIT submodules\"\n            echo\n            if test -e \"$source_path/.git\"; then\n                echo \"--with-git-submodules=ignore specified but submodules were not\"\n                echo \"checked out.  Please initialize and update submodules.\"\n            else\n                echo \"This is not a GIT checkout but module content appears to\"\n                echo \"be missing. Do not use 'git archive' or GitHub download links\"\n                echo \"to acquire QEMU source archives. Non-GIT builds are only\"\n                echo \"supported with source archives linked from:\"\n                echo\n                echo \"  https://www.qemu.org/download/#source\"\n                echo\n                echo \"Developers working with GIT can use scripts/archive-source.sh\"\n                echo \"if they need to create valid source archives.\"\n            fi\n            echo\n            exit 1\n        fi\n    ;;\n    *)\n        echo \"ERROR: invalid --with-git-submodules= value '$git_submodules_action'\"\n        exit 1\n    ;;\nesac\n\ndefault_target_list=\"\"\nmak_wilds=\"\"\n\nif [ \"$linux_user\" != no ]; then\n    if [ \"$targetos\" = linux ] && [ -d $source_path/linux-user/include/host/$cpu ]; then\n        linux_user=yes\n    elif [ \"$linux_user\" = yes ]; then\n        error_exit \"linux-user not supported on this architecture\"\n    fi\nfi\nif [ \"$bsd_user\" != no ]; then\n    if [ \"$bsd_user\" = \"\" ]; then\n        test $targetos = freebsd && bsd_user=yes\n    fi\n    if [ \"$bsd_user\" = yes ] && ! [ -d $source_path/bsd-user/$targetos ]; then\n        error_exit \"bsd-user not supported on this host OS\"\n    fi\nfi\nif [ \"$softmmu\" = \"yes\" ]; then\n    mak_wilds=\"${mak_wilds} $source_path/configs/targets/*-softmmu.mak\"\nfi\nif [ \"$linux_user\" = \"yes\" ]; then\n    mak_wilds=\"${mak_wilds} $source_path/configs/targets/*-linux-user.mak\"\nfi\nif [ \"$bsd_user\" = \"yes\" ]; then\n    mak_wilds=\"${mak_wilds} $source_path/configs/targets/*-bsd-user.mak\"\nfi\n\nfor config in $mak_wilds; do\n    target=\"$(basename \"$config\" .mak)\"\n    if echo \"$target_list_exclude\" | grep -vq \"$target\"; then\n        default_target_list=\"${default_target_list} $target\"\n    fi\ndone\n\nif test x\"$show_help\" = x\"yes\" ; then\ncat << EOF\n\nUsage: configure [options]\nOptions: [defaults in brackets after descriptions]\n\nStandard options:\n  --help                   print this message\n  --prefix=PREFIX          install in PREFIX [$prefix]\n  --target-list=LIST       set target list (default: build all)\n$(echo Available targets: $default_target_list | \\\n  fold -s -w 53 | sed -e 's/^/                           /')\n  --target-list-exclude=LIST exclude a set of targets from the default target-list\n\nAdvanced options (experts only):\n  --cross-prefix=PREFIX    use PREFIX for compile tools, PREFIX can be blank [$cross_prefix]\n  --cc=CC                  use C compiler CC [$cc]\n  --host-cc=CC             use C compiler CC [$host_cc] for code run at\n                           build time\n  --cxx=CXX                use C++ compiler CXX [$cxx]\n  --objcc=OBJCC            use Objective-C compiler OBJCC [$objcc]\n  --extra-cflags=CFLAGS    append extra C compiler flags CFLAGS\n  --extra-cxxflags=CXXFLAGS append extra C++ compiler flags CXXFLAGS\n  --extra-objcflags=OBJCFLAGS append extra Objective C compiler flags OBJCFLAGS\n  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS\n  --cross-cc-ARCH=CC       use compiler when building ARCH guest test cases\n  --cross-cc-cflags-ARCH=  use compiler flags when building ARCH guest tests\n  --cross-prefix-ARCH=PREFIX cross compiler prefix when building ARCH guest test cases\n  --make=MAKE              use specified make [$make]\n  --python=PYTHON          use specified python [$python]\n  --meson=MESON            use specified meson [$meson]\n  --ninja=NINJA            use specified ninja [$ninja]\n  --smbd=SMBD              use specified smbd [$smbd]\n  --with-git=GIT           use specified git [$git]\n  --with-git-submodules=update   update git submodules (default if .git dir exists)\n  --with-git-submodules=validate fail if git submodules are not up to date\n  --with-git-submodules=ignore   do not update or check git submodules (default if no .git dir)\n  --static                 enable static build [$static]\n  --bindir=PATH            install binaries in PATH\n  --with-suffix=SUFFIX     suffix for QEMU data inside datadir/libdir/sysconfdir/docdir [$qemu_suffix]\n  --without-default-features default all --enable-* options to \"disabled\"\n  --without-default-devices  do not include any device that is not needed to\n                           start the emulator (only use if you are including\n                           desired devices in configs/devices/)\n  --with-devices-ARCH=NAME override default configs/devices\n  --enable-debug           enable common debug build options\n  --enable-sanitizers      enable default sanitizers\n  --enable-tsan            enable thread sanitizer\n  --disable-werror         disable compilation abort on warning\n  --disable-stack-protector disable compiler-provided stack protection\n  --cpu=CPU                Build for host CPU [$cpu]\n  --with-coroutine=BACKEND coroutine backend. Supported options:\n                           ucontext, sigaltstack, windows\n  --enable-plugins\n                           enable plugins via shared library loading\n  --disable-containers     don't use containers for cross-building\n  --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]\nEOF\n  meson_options_help\ncat << EOF\n  system          all system emulation targets\n  user            supported user emulation targets\n  linux-user      all linux usermode emulation targets\n  bsd-user        all BSD usermode emulation targets\n  pie             Position Independent Executables\n  modules         modules support (non-Windows)\n  debug-tcg       TCG debugging (default is disabled)\n  debug-info      debugging information\n  safe-stack      SafeStack Stack Smash Protection. Depends on\n                  clang/llvm >= 3.7 and requires coroutine backend ucontext.\n\nNOTE: The object files are built at the place where configure is launched\nEOF\nexit 0\nfi\n\n# Remove old dependency files to make sure that they get properly regenerated\nrm -f */config-devices.mak.d\n\nif test -z \"$python\"\nthen\n    error_exit \"Python not found. Use --python=/path/to/python\"\nfi\nif ! has \"$make\"\nthen\n    error_exit \"GNU make ($make) not found\"\nfi\n\n# Note that if the Python conditional here evaluates True we will exit\n# with status 1 which is a shell 'false' value.\nif ! $python -c 'import sys; sys.exit(sys.version_info < (3,6))'; then\n  error_exit \"Cannot use '$python', Python >= 3.6 is required.\" \\\n      \"Use --python=/path/to/python to specify a supported Python.\"\nfi\n\n# Preserve python version since some functionality is dependent on it\npython_version=$($python -c 'import sys; print(\"%d.%d.%d\" % (sys.version_info[0], sys.version_info[1], sys.version_info[2]))' 2>/dev/null)\n\n# Suppress writing compiled files\npython=\"$python -B\"\n\nif test -z \"$meson\"; then\n    if test \"$explicit_python\" = no && has meson && version_ge \"$(meson --version)\" 0.59.3; then\n        meson=meson\n    elif test $git_submodules_action != 'ignore' ; then\n        meson=git\n    elif test -e \"${source_path}/meson/meson.py\" ; then\n        meson=internal\n    else\n        if test \"$explicit_python\" = yes; then\n            error_exit \"--python requires using QEMU's embedded Meson distribution, but it was not found.\"\n        else\n            error_exit \"Meson not found.  Use --meson=/path/to/meson\"\n        fi\n    fi\nelse\n    # Meson uses its own Python interpreter to invoke other Python scripts,\n    # but the user wants to use the one they specified with --python.\n    #\n    # We do not want to override the distro Python interpreter (and sometimes\n    # cannot: for example in Homebrew /usr/bin/meson is a bash script), so\n    # just require --meson=git|internal together with --python.\n    if test \"$explicit_python\" = yes; then\n        case \"$meson\" in\n            git | internal) ;;\n            *) error_exit \"--python requires using QEMU's embedded Meson distribution.\" ;;\n        esac\n    fi\nfi\n\nif test \"$meson\" = git; then\n    git_submodules=\"${git_submodules} meson\"\nfi\n\ncase \"$meson\" in\n    git | internal)\n        meson=\"$python ${source_path}/meson/meson.py\"\n        ;;\n    *) meson=$(command -v \"$meson\") ;;\nesac\n\n# Probe for ninja\n\nif test -z \"$ninja\"; then\n    for c in ninja ninja-build samu; do\n        if has $c; then\n            ninja=$(command -v \"$c\")\n            break\n        fi\n    done\n    if test -z \"$ninja\"; then\n      error_exit \"Cannot find Ninja\"\n    fi\nfi\n\n# Check that the C compiler works. Doing this here before testing\n# the host CPU ensures that we had a valid CC to autodetect the\n# $cpu var (and we should bail right here if that's not the case).\n# It also allows the help message to be printed without a CC.\nwrite_c_skeleton;\nif compile_object ; then\n  : C compiler works ok\nelse\n    error_exit \"\\\"$cc\\\" either does not exist or does not work\"\nfi\nif ! compile_prog ; then\n    error_exit \"\\\"$cc\\\" cannot build an executable (is your linker broken?)\"\nfi\n\n# Consult white-list to determine whether to enable werror\n# by default.  Only enable by default for git builds\nif test -z \"$werror\" ; then\n    if test \"$git_submodules_action\" != \"ignore\" && \\\n        { test \"$linux\" = \"yes\" || test \"$mingw32\" = \"yes\"; }; then\n        werror=\"yes\"\n    else\n        werror=\"no\"\n    fi\nfi\n\nif test \"$targetos\" = \"bogus\"; then\n    # Now that we know that we're not printing the help and that\n    # the compiler works (so the results of the check_defines we used\n    # to identify the OS are reliable), if we didn't recognize the\n    # host OS we should stop now.\n    error_exit \"Unrecognized host OS (uname -s reports '$(uname -s)')\"\nfi\n\n# Check whether the compiler matches our minimum requirements:\ncat > $TMPC << EOF\n#if defined(__clang_major__) && defined(__clang_minor__)\n# ifdef __apple_build_version__\n#  if __clang_major__ < 10 || (__clang_major__ == 10 && __clang_minor__ < 0)\n#   error You need at least XCode Clang v10.0 to compile QEMU\n#  endif\n# else\n#  if __clang_major__ < 6 || (__clang_major__ == 6 && __clang_minor__ < 0)\n#   error You need at least Clang v6.0 to compile QEMU\n#  endif\n# endif\n#elif defined(__GNUC__) && defined(__GNUC_MINOR__)\n# if __GNUC__ < 7 || (__GNUC__ == 7 && __GNUC_MINOR__ < 4)\n#  error You need at least GCC v7.4.0 to compile QEMU\n# endif\n#else\n# error You either need GCC or Clang to compiler QEMU\n#endif\nint main (void) { return 0; }\nEOF\nif ! compile_prog \"\" \"\" ; then\n    error_exit \"You need at least GCC v7.4 or Clang v6.0 (or XCode Clang v10.0)\"\nfi\n\n# Accumulate -Wfoo and -Wno-bar separately.\n# We will list all of the enable flags first, and the disable flags second.\n# Note that we do not add -Werror, because that would enable it for all\n# configure tests. If a configure test failed due to -Werror this would\n# just silently disable some features, so it's too error prone.\n\nwarn_flags=\nadd_to warn_flags -Wold-style-declaration\nadd_to warn_flags -Wold-style-definition\nadd_to warn_flags -Wtype-limits\nadd_to warn_flags -Wformat-security\nadd_to warn_flags -Wformat-y2k\nadd_to warn_flags -Winit-self\nadd_to warn_flags -Wignored-qualifiers\nadd_to warn_flags -Wempty-body\nadd_to warn_flags -Wnested-externs\nadd_to warn_flags -Wendif-labels\nadd_to warn_flags -Wexpansion-to-defined\nadd_to warn_flags -Wimplicit-fallthrough=2\n\nnowarn_flags=\nadd_to nowarn_flags -Wno-initializer-overrides\nadd_to nowarn_flags -Wno-missing-include-dirs\nadd_to nowarn_flags -Wno-shift-negative-value\nadd_to nowarn_flags -Wno-string-plus-int\nadd_to nowarn_flags -Wno-typedef-redefinition\nadd_to nowarn_flags -Wno-tautological-type-limit-compare\nadd_to nowarn_flags -Wno-psabi\n\ngcc_flags=\"$warn_flags $nowarn_flags\"\n\ncc_has_warning_flag() {\n    write_c_skeleton;\n\n    # Use the positive sense of the flag when testing for -Wno-wombat\n    # support (gcc will happily accept the -Wno- form of unknown\n    # warning options).\n    optflag=\"$(echo $1 | sed -e 's/^-Wno-/-W/')\"\n    compile_prog \"-Werror $optflag\" \"\"\n}\n\nobjcc_has_warning_flag() {\n    cat > $TMPM <<EOF\nint main(void) { return 0; }\nEOF\n\n    # Use the positive sense of the flag when testing for -Wno-wombat\n    # support (gcc will happily accept the -Wno- form of unknown\n    # warning options).\n    optflag=\"$(echo $1 | sed -e 's/^-Wno-/-W/')\"\n    do_objc -Werror $optflag \\\n      $OBJCFLAGS $EXTRA_OBJCFLAGS $CONFIGURE_OBJCFLAGS $QEMU_OBJCFLAGS \\\n      -o $TMPE $TMPM $QEMU_LDFLAGS\n}\n\nfor flag in $gcc_flags; do\n    if cc_has_warning_flag $flag ; then\n        QEMU_CFLAGS=\"$QEMU_CFLAGS $flag\"\n    fi\n    if objcc_has_warning_flag $flag ; then\n        QEMU_OBJCFLAGS=\"$QEMU_OBJCFLAGS $flag\"\n    fi\ndone\n\nif test \"$stack_protector\" != \"no\"; then\n  cat > $TMPC << EOF\nint main(int argc, char *argv[])\n{\n    char arr[64], *p = arr, *c = argv[0];\n    while (*c) {\n        *p++ = *c++;\n    }\n    return 0;\n}\nEOF\n  gcc_flags=\"-fstack-protector-strong -fstack-protector-all\"\n  sp_on=0\n  for flag in $gcc_flags; do\n    # We need to check both a compile and a link, since some compiler\n    # setups fail only on a .c->.o compile and some only at link time\n    if compile_object \"-Werror $flag\" &&\n       compile_prog \"-Werror $flag\" \"\"; then\n      QEMU_CFLAGS=\"$QEMU_CFLAGS $flag\"\n      QEMU_LDFLAGS=\"$QEMU_LDFLAGS $flag\"\n      sp_on=1\n      break\n    fi\n  done\n  if test \"$stack_protector\" = yes; then\n    if test $sp_on = 0; then\n      error_exit \"Stack protector not supported\"\n    fi\n  fi\nfi\n\n# Disable -Wmissing-braces on older compilers that warn even for\n# the \"universal\" C zero initializer {0}.\ncat > $TMPC << EOF\nstruct {\n  int a[2];\n} x = {0};\nEOF\nif compile_object \"-Werror\" \"\" ; then\n  :\nelse\n  QEMU_CFLAGS=\"$QEMU_CFLAGS -Wno-missing-braces\"\nfi\n\n# Our module code doesn't support Windows\nif test \"$modules\" = \"yes\" && test \"$mingw32\" = \"yes\" ; then\n  error_exit \"Modules are not available for Windows\"\nfi\n\n# Static linking is not possible with plugins, modules or PIE\nif test \"$static\" = \"yes\" ; then\n  if test \"$modules\" = \"yes\" ; then\n    error_exit \"static and modules are mutually incompatible\"\n  fi\n  if test \"$plugins\" = \"yes\"; then\n    error_exit \"static and plugins are mutually incompatible\"\n  else\n    plugins=\"no\"\n  fi\nfi\ntest \"$plugins\" = \"\" && plugins=yes\n\ncat > $TMPC << EOF\n\n#ifdef __linux__\n#  define THREAD __thread\n#else\n#  define THREAD\n#endif\nstatic THREAD int tls_var;\nint main(void) { return tls_var; }\nEOF\n\nif test \"$static\" = \"yes\"; then\n  if test \"$pie\" != \"no\" && compile_prog \"-Werror -fPIE -DPIE\" \"-static-pie\"; then\n    CONFIGURE_CFLAGS=\"-fPIE -DPIE $CONFIGURE_CFLAGS\"\n    QEMU_LDFLAGS=\"-static-pie $QEMU_LDFLAGS\"\n    pie=\"yes\"\n  elif test \"$pie\" = \"yes\"; then\n    error_exit \"-static-pie not available due to missing toolchain support\"\n  else\n    QEMU_LDFLAGS=\"-static $QEMU_LDFLAGS\"\n    pie=\"no\"\n  fi\nelif test \"$pie\" = \"no\"; then\n  if compile_prog \"-Werror -fno-pie\" \"-no-pie\"; then\n    CONFIGURE_CFLAGS=\"-fno-pie $CONFIGURE_CFLAGS\"\n    CONFIGURE_LDFLAGS=\"-no-pie $CONFIGURE_LDFLAGS\"\n  fi\nelif compile_prog \"-Werror -fPIE -DPIE\" \"-pie\"; then\n  CONFIGURE_CFLAGS=\"-fPIE -DPIE $CONFIGURE_CFLAGS\"\n  CONFIGURE_LDFLAGS=\"-pie $CONFIGURE_LDFLAGS\"\n  pie=\"yes\"\nelif test \"$pie\" = \"yes\"; then\n  error_exit \"PIE not available due to missing toolchain support\"\nelse\n  echo \"Disabling PIE due to missing toolchain support\"\n  pie=\"no\"\nfi\n\n# Detect support for PT_GNU_RELRO + DT_BIND_NOW.\n# The combination is known as \"full relro\", because .got.plt is read-only too.\nif compile_prog \"\" \"-Wl,-z,relro -Wl,-z,now\" ; then\n  QEMU_LDFLAGS=\"-Wl,-z,relro -Wl,-z,now $QEMU_LDFLAGS\"\nfi\n\n##########################################\n# __sync_fetch_and_and requires at least -march=i486. Many toolchains\n# use i686 as default anyway, but for those that don't, an explicit\n# specification is necessary\n\nif test \"$cpu\" = \"i386\"; then\n  cat > $TMPC << EOF\nstatic int sfaa(int *ptr)\n{\n  return __sync_fetch_and_and(ptr, 0);\n}\n\nint main(void)\n{\n  int val = 42;\n  val = __sync_val_compare_and_swap(&val, 0, 1);\n  sfaa(&val);\n  return val;\n}\nEOF\n  if ! compile_prog \"\" \"\" ; then\n    QEMU_CFLAGS=\"-march=i486 $QEMU_CFLAGS\"\n  fi\nfi\n\nif test -z \"${target_list+xxx}\" ; then\n    default_targets=yes\n    for target in $default_target_list; do\n        target_list=\"$target_list $target\"\n    done\n    target_list=\"${target_list# }\"\nelse\n    default_targets=no\n    target_list=$(echo \"$target_list\" | sed -e 's/,/ /g')\n    for target in $target_list; do\n        # Check that we recognised the target name; this allows a more\n        # friendly error message than if we let it fall through.\n        case \" $default_target_list \" in\n            *\" $target \"*)\n                ;;\n            *)\n                error_exit \"Unknown target name '$target'\"\n                ;;\n        esac\n    done\nfi\n\n# see if system emulation was really requested\ncase \" $target_list \" in\n  *\"-softmmu \"*) softmmu=yes\n  ;;\n  *) softmmu=no\n  ;;\nesac\n\nif test \"$tcg\" = \"auto\"; then\n  if test -z \"$target_list\"; then\n    tcg=\"disabled\"\n  else\n    tcg=\"enabled\"\n  fi\nfi\n\nif test \"$tcg\" = \"enabled\"; then\n    git_submodules=\"$git_submodules tests/fp/berkeley-testfloat-3\"\n    git_submodules=\"$git_submodules tests/fp/berkeley-softfloat-3\"\nfi\n\nfeature_not_found() {\n  feature=$1\n  remedy=$2\n\n  error_exit \"User requested feature $feature\" \\\n      \"configure was not able to find it.\" \\\n      \"$remedy\"\n}\n\n# ---\n# big/little endian test\ncat > $TMPC << EOF\n#include <stdio.h>\nshort big_endian[] = { 0x4269, 0x4765, 0x4e64, 0x4961, 0x4e00, 0, };\nshort little_endian[] = { 0x694c, 0x7454, 0x654c, 0x6e45, 0x6944, 0x6e41, 0, };\nint main(int argc, char *argv[])\n{\n    return printf(\"%s %s\\n\", (char *)big_endian, (char *)little_endian);\n}\nEOF\n\nif compile_prog ; then\n    if strings -a $TMPE | grep -q BiGeNdIaN ; then\n        bigendian=\"yes\"\n    elif strings -a $TMPE | grep -q LiTtLeEnDiAn ; then\n        bigendian=\"no\"\n    else\n        echo big/little test failed\n        exit 1\n    fi\nelse\n    echo big/little test failed\n    exit 1\nfi\n\n##########################################\n# pkg-config probe\n\nif ! has \"$pkg_config_exe\"; then\n  error_exit \"pkg-config binary '$pkg_config_exe' not found\"\nfi\n\n##########################################\n# glib support probe\n\n# When bumping glib_req_ver, please check also whether we should increase\n# the _WIN32_WINNT setting in osdep.h according to the value from glib\nglib_req_ver=2.56\nglib_modules=gthread-2.0\nif test \"$modules\" = yes; then\n    glib_modules=\"$glib_modules gmodule-export-2.0\"\nelif test \"$plugins\" = \"yes\"; then\n    glib_modules=\"$glib_modules gmodule-no-export-2.0\"\nfi\n\nfor i in $glib_modules; do\n    if $pkg_config --atleast-version=$glib_req_ver $i; then\n        glib_cflags=$($pkg_config --cflags $i)\n        glib_libs=$($pkg_config --libs $i)\n    else\n        error_exit \"glib-$glib_req_ver $i is required to compile QEMU\"\n    fi\ndone\n\nglib_bindir=\"$($pkg_config --variable=bindir glib-2.0)\"\nif test -z \"$glib_bindir\" ; then\n\tglib_bindir=\"$($pkg_config --variable=prefix glib-2.0)\"/bin\nfi\n\n# This workaround is required due to a bug in pkg-config file for glib as it\n# doesn't define GLIB_STATIC_COMPILATION for pkg-config --static\n\nif test \"$static\" = yes && test \"$mingw32\" = yes; then\n    glib_cflags=\"-DGLIB_STATIC_COMPILATION $glib_cflags\"\nfi\n\n# Sanity check that the current size_t matches the\n# size that glib thinks it should be. This catches\n# problems on multi-arch where people try to build\n# 32-bit QEMU while pointing at 64-bit glib headers\ncat > $TMPC <<EOF\n#include <glib.h>\n#include <unistd.h>\n\n#define QEMU_BUILD_BUG_ON(x) \\\n  typedef char qemu_build_bug_on[(x)?-1:1] __attribute__((unused));\n\nint main(void) {\n   QEMU_BUILD_BUG_ON(sizeof(size_t) != GLIB_SIZEOF_SIZE_T);\n   return 0;\n}\nEOF\n\nif ! compile_prog \"$glib_cflags\" \"$glib_libs\" ; then\n    error_exit \"sizeof(size_t) doesn't match GLIB_SIZEOF_SIZE_T.\"\\\n               \"You probably need to set PKG_CONFIG_LIBDIR\"\\\n\t       \"to point to the right pkg-config files for your\"\\\n\t       \"build target\"\nfi\n\n# Silence clang warnings triggered by glib < 2.57.2\ncat > $TMPC << EOF\n#include <glib.h>\ntypedef struct Foo {\n    int i;\n} Foo;\nstatic void foo_free(Foo *f)\n{\n    g_free(f);\n}\nG_DEFINE_AUTOPTR_CLEANUP_FUNC(Foo, foo_free)\nint main(void) { return 0; }\nEOF\nif ! compile_prog \"$glib_cflags -Werror\" \"$glib_libs\" ; then\n    if cc_has_warning_flag \"-Wno-unused-function\"; then\n        glib_cflags=\"$glib_cflags -Wno-unused-function\"\n        CONFIGURE_CFLAGS=\"$CONFIGURE_CFLAGS -Wno-unused-function\"\n    fi\nfi\n\n##########################################\n# fdt probe\n\ncase \"$fdt\" in\n  auto | enabled | internal)\n    # Simpler to always update submodule, even if not needed.\n    git_submodules=\"${git_submodules} dtc\"\n    ;;\nesac\n\n##########################################\n# check and set a backend for coroutine\n\n# We prefer ucontext, but it's not always possible. The fallback\n# is sigcontext. On Windows the only valid backend is the Windows\n# specific one.\n\nucontext_works=no\nif test \"$darwin\" != \"yes\"; then\n  cat > $TMPC << EOF\n#include <ucontext.h>\n#ifdef __stub_makecontext\n#error Ignoring glibc stub makecontext which will always fail\n#endif\nint main(void) { makecontext(0, 0, 0); return 0; }\nEOF\n  if compile_prog \"\" \"\" ; then\n    ucontext_works=yes\n  fi\nfi\n\nif test \"$coroutine\" = \"\"; then\n  if test \"$mingw32\" = \"yes\"; then\n    coroutine=win32\n  elif test \"$ucontext_works\" = \"yes\"; then\n    coroutine=ucontext\n  else\n    coroutine=sigaltstack\n  fi\nelse\n  case $coroutine in\n  windows)\n    if test \"$mingw32\" != \"yes\"; then\n      error_exit \"'windows' coroutine backend only valid for Windows\"\n    fi\n    # Unfortunately the user visible backend name doesn't match the\n    # coroutine-*.c filename for this case, so we have to adjust it here.\n    coroutine=win32\n    ;;\n  ucontext)\n    if test \"$ucontext_works\" != \"yes\"; then\n      feature_not_found \"ucontext\"\n    fi\n    ;;\n  sigaltstack)\n    if test \"$mingw32\" = \"yes\"; then\n      error_exit \"only the 'windows' coroutine backend is valid for Windows\"\n    fi\n    ;;\n  *)\n    error_exit \"unknown coroutine backend $coroutine\"\n    ;;\n  esac\nfi\n\n##################################################\n# SafeStack\n\n\nif test \"$safe_stack\" = \"yes\"; then\ncat > $TMPC << EOF\nint main(int argc, char *argv[])\n{\n#if ! __has_feature(safe_stack)\n#error SafeStack Disabled\n#endif\n    return 0;\n}\nEOF\n  flag=\"-fsanitize=safe-stack\"\n  # Check that safe-stack is supported and enabled.\n  if compile_prog \"-Werror $flag\" \"$flag\"; then\n    # Flag needed both at compilation and at linking\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $flag\"\n    QEMU_LDFLAGS=\"$QEMU_LDFLAGS $flag\"\n  else\n    error_exit \"SafeStack not supported by your compiler\"\n  fi\n  if test \"$coroutine\" != \"ucontext\"; then\n    error_exit \"SafeStack is only supported by the coroutine backend ucontext\"\n  fi\nelse\ncat > $TMPC << EOF\nint main(int argc, char *argv[])\n{\n#if defined(__has_feature)\n#if __has_feature(safe_stack)\n#error SafeStack Enabled\n#endif\n#endif\n    return 0;\n}\nEOF\nif test \"$safe_stack\" = \"no\"; then\n  # Make sure that safe-stack is disabled\n  if ! compile_prog \"-Werror\" \"\"; then\n    # SafeStack was already enabled, try to explicitly remove the feature\n    flag=\"-fno-sanitize=safe-stack\"\n    if ! compile_prog \"-Werror $flag\" \"$flag\"; then\n      error_exit \"Configure cannot disable SafeStack\"\n    fi\n    QEMU_CFLAGS=\"$QEMU_CFLAGS $flag\"\n    QEMU_LDFLAGS=\"$QEMU_LDFLAGS $flag\"\n  fi\nelse # \"$safe_stack\" = \"\"\n  # Set safe_stack to yes or no based on pre-existing flags\n  if compile_prog \"-Werror\" \"\"; then\n    safe_stack=\"no\"\n  else\n    safe_stack=\"yes\"\n    if test \"$coroutine\" != \"ucontext\"; then\n      error_exit \"SafeStack is only supported by the coroutine backend ucontext\"\n    fi\n  fi\nfi\nfi\n\n########################################\n# check if ccache is interfering with\n# semantic analysis of macros\n\nunset CCACHE_CPP2\nccache_cpp2=no\ncat > $TMPC << EOF\nstatic const int Z = 1;\n#define fn() ({ Z; })\n#define TAUT(X) ((X) == Z)\n#define PAREN(X, Y) (X == Y)\n#define ID(X) (X)\nint main(int argc, char *argv[])\n{\n    int x = 0, y = 0;\n    x = ID(x);\n    x = fn();\n    fn();\n    if (PAREN(x, y)) return 0;\n    if (TAUT(Z)) return 0;\n    return 0;\n}\nEOF\n\nif ! compile_object \"-Werror\"; then\n    ccache_cpp2=yes\nfi\n\n#################################################\n# clang does not support glibc + FORTIFY_SOURCE.\n\nif test \"$fortify_source\" != \"no\"; then\n  if echo | $cc -dM -E - | grep __clang__ > /dev/null 2>&1 ; then\n    fortify_source=\"no\";\n  elif test -n \"$cxx\" && has $cxx &&\n       echo | $cxx -dM -E - | grep __clang__ >/dev/null 2>&1 ; then\n    fortify_source=\"no\";\n  else\n    fortify_source=\"yes\"\n  fi\nfi\n\n##########################################\n# checks for sanitizers\n\nhave_asan=no\nhave_ubsan=no\nhave_asan_iface_h=no\nhave_asan_iface_fiber=no\n\nif test \"$sanitizers\" = \"yes\" ; then\n  write_c_skeleton\n  if compile_prog \"$CPU_CFLAGS -Werror -fsanitize=address\" \"\"; then\n      have_asan=yes\n  fi\n\n  # we could use a simple skeleton for flags checks, but this also\n  # detect the static linking issue of ubsan, see also:\n  # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84285\n  cat > $TMPC << EOF\n#include <stdlib.h>\nint main(void) {\n    void *tmp = malloc(10);\n    if (tmp != NULL) {\n        return *(int *)(tmp + 2);\n    }\n    return 1;\n}\nEOF\n  if compile_prog \"$CPU_CFLAGS -Werror -fsanitize=undefined\" \"\"; then\n      have_ubsan=yes\n  fi\n\n  if check_include \"sanitizer/asan_interface.h\" ; then\n      have_asan_iface_h=yes\n  fi\n\n  cat > $TMPC << EOF\n#include <sanitizer/asan_interface.h>\nint main(void) {\n  __sanitizer_start_switch_fiber(0, 0, 0);\n  return 0;\n}\nEOF\n  if compile_prog \"$CPU_CFLAGS -Werror -fsanitize=address\" \"\" ; then\n      have_asan_iface_fiber=yes\n  fi\nfi\n\n# Thread sanitizer is, for now, much noisier than the other sanitizers;\n# keep it separate until that is not the case.\nif test \"$tsan\" = \"yes\" && test \"$sanitizers\" = \"yes\"; then\n  error_exit \"TSAN is not supported with other sanitiziers.\"\nfi\nhave_tsan=no\nhave_tsan_iface_fiber=no\nif test \"$tsan\" = \"yes\" ; then\n  write_c_skeleton\n  if compile_prog \"$CPU_CFLAGS -Werror -fsanitize=thread\" \"\" ; then\n      have_tsan=yes\n  fi\n  cat > $TMPC << EOF\n#include <sanitizer/tsan_interface.h>\nint main(void) {\n  __tsan_create_fiber(0);\n  return 0;\n}\nEOF\n  if compile_prog \"$CPU_CFLAGS -Werror -fsanitize=thread\" \"\" ; then\n      have_tsan_iface_fiber=yes\n  fi\nfi\n\n##########################################\n# check for slirp\n\ncase \"$slirp\" in\n  auto | enabled | internal)\n    # Simpler to always update submodule, even if not needed.\n    git_submodules=\"${git_submodules} slirp\"\n    ;;\nesac\n\n##########################################\n# functions to probe cross compilers\n\ncontainer=\"no\"\nif test $use_containers = \"yes\"; then\n    if has \"docker\" || has \"podman\"; then\n        container=$($python $source_path/tests/docker/docker.py probe)\n    fi\nfi\n\n# cross compilers defaults, can be overridden with --cross-cc-ARCH\n: ${cross_prefix_aarch64=\"aarch64-linux-gnu-\"}\n: ${cross_prefix_aarch64_be=\"$cross_prefix_aarch64\"}\n: ${cross_prefix_alpha=\"alpha-linux-gnu-\"}\n: ${cross_prefix_arm=\"arm-linux-gnueabihf-\"}\n: ${cross_prefix_armeb=\"$cross_prefix_arm\"}\n: ${cross_prefix_hexagon=\"hexagon-unknown-linux-musl-\"}\n: ${cross_prefix_loongarch64=\"loongarch64-unknown-linux-gnu-\"}\n: ${cross_prefix_hppa=\"hppa-linux-gnu-\"}\n: ${cross_prefix_i386=\"i686-linux-gnu-\"}\n: ${cross_prefix_m68k=\"m68k-linux-gnu-\"}\n: ${cross_prefix_microblaze=\"microblaze-linux-musl-\"}\n: ${cross_prefix_mips64el=\"mips64el-linux-gnuabi64-\"}\n: ${cross_prefix_mips64=\"mips64-linux-gnuabi64-\"}\n: ${cross_prefix_mipsel=\"mipsel-linux-gnu-\"}\n: ${cross_prefix_mips=\"mips-linux-gnu-\"}\n: ${cross_prefix_nios2=\"nios2-linux-gnu-\"}\n: ${cross_prefix_ppc=\"powerpc-linux-gnu-\"}\n: ${cross_prefix_ppc64=\"powerpc64-linux-gnu-\"}\n: ${cross_prefix_ppc64le=\"$cross_prefix_ppc64\"}\n: ${cross_prefix_riscv64=\"riscv64-linux-gnu-\"}\n: ${cross_prefix_s390x=\"s390x-linux-gnu-\"}\n: ${cross_prefix_sh4=\"sh4-linux-gnu-\"}\n: ${cross_prefix_sparc64=\"sparc64-linux-gnu-\"}\n: ${cross_prefix_sparc=\"$cross_prefix_sparc64\"}\n: ${cross_prefix_x86_64=\"x86_64-linux-gnu-\"}\n\n: ${cross_cc_aarch64_be=\"$cross_cc_aarch64\"}\n: ${cross_cc_cflags_aarch64_be=\"-mbig-endian\"}\n: ${cross_cc_armeb=\"$cross_cc_arm\"}\n: ${cross_cc_cflags_armeb=\"-mbig-endian\"}\n: ${cross_cc_hexagon=\"hexagon-unknown-linux-musl-clang\"}\n: ${cross_cc_cflags_hexagon=\"-mv67 -O2 -static\"}\n: ${cross_cc_cflags_i386=\"-m32\"}\n: ${cross_cc_cflags_ppc=\"-m32 -mbig-endian\"}\n: ${cross_cc_cflags_ppc64=\"-m64 -mbig-endian\"}\n: ${cross_cc_ppc64le=\"$cross_cc_ppc64\"}\n: ${cross_cc_cflags_ppc64le=\"-m64 -mlittle-endian\"}\n: ${cross_cc_cflags_sparc64=\"-m64 -mcpu=ultrasparc\"}\n: ${cross_cc_sparc=\"$cross_cc_sparc64\"}\n: ${cross_cc_cflags_sparc=\"-m32 -mcpu=supersparc\"}\n: ${cross_cc_cflags_x86_64=\"-m64\"}\n\ncompute_target_variable() {\n  eval \"$2=\"\n  if eval test -n \"\\\"\\${cross_prefix_$1}\\\"\"; then\n    if eval has \"\\\"\\${cross_prefix_$1}\\$3\\\"\"; then\n      eval \"$2=\\\"\\${cross_prefix_$1}\\$3\\\"\"\n    fi\n  fi\n}\n\n# probe_target_compiler TARGET\n#\n# Look for a compiler for the given target, either native or cross.\n# Set variables target_* if a compiler is found, and container_cross_*\n# if a Docker-based cross-compiler image is known for the target.\n# Set got_cross_cc to yes/no depending on whether a non-container-based\n# compiler was found.\n#\n# If TARGET is a user-mode emulation target, also set build_static to\n# \"y\" if static linking is possible.\n#\nprobe_target_compiler() {\n  # reset all output variables\n  got_cross_cc=no\n  container_image=\n  container_hosts=\n  container_cross_cc=\n  container_cross_ar=\n  container_cross_as=\n  container_cross_ld=\n  container_cross_nm=\n  container_cross_objcopy=\n  container_cross_ranlib=\n  container_cross_strip=\n\n  target_arch=${1%%-*}\n  case $target_arch in\n    aarch64) container_hosts=\"x86_64 aarch64\" ;;\n    alpha) container_hosts=x86_64 ;;\n    arm) container_hosts=\"x86_64 aarch64\" ;;\n    cris) container_hosts=x86_64 ;;\n    hexagon) container_hosts=x86_64 ;;\n    hppa) container_hosts=x86_64 ;;\n    i386) container_hosts=x86_64 ;;\n    loongarch64) container_hosts=x86_64 ;;\n    m68k) container_hosts=x86_64 ;;\n    microblaze) container_hosts=x86_64 ;;\n    mips64el) container_hosts=x86_64 ;;\n    mips64) container_hosts=x86_64 ;;\n    mipsel) container_hosts=x86_64 ;;\n    mips) container_hosts=x86_64 ;;\n    nios2) container_hosts=x86_64 ;;\n    ppc) container_hosts=x86_64 ;;\n    ppc64|ppc64le) container_hosts=x86_64 ;;\n    riscv64) container_hosts=x86_64 ;;\n    s390x) container_hosts=x86_64 ;;\n    sh4) container_hosts=x86_64 ;;\n    sparc64) container_hosts=x86_64 ;;\n    tricore) container_hosts=x86_64 ;;\n    x86_64) container_hosts=\"aarch64 ppc64el x86_64\" ;;\n    xtensa*) container_hosts=x86_64 ;;\n  esac\n\n  for host in $container_hosts; do\n    test \"$container\" != no || continue\n    test \"$host\" = \"$cpu\" || continue\n    case $target_arch in\n      aarch64)\n        # We don't have any bigendian build tools so we only use this for AArch64\n        container_image=debian-arm64-cross\n        container_cross_prefix=aarch64-linux-gnu-\n        container_cross_cc=${container_cross_prefix}gcc-10\n        ;;\n      alpha)\n        container_image=debian-alpha-cross\n        container_cross_prefix=alpha-linux-gnu-\n        ;;\n      arm)\n        # We don't have any bigendian build tools so we only use this for ARM\n        container_image=debian-armhf-cross\n        container_cross_prefix=arm-linux-gnueabihf-\n        ;;\n      cris)\n        container_image=fedora-cris-cross\n        container_cross_prefix=cris-linux-gnu-\n        ;;\n      hexagon)\n        container_image=debian-hexagon-cross\n        container_cross_prefix=hexagon-unknown-linux-musl-\n        container_cross_cc=${container_cross_prefix}clang\n        ;;\n      hppa)\n        container_image=debian-hppa-cross\n        container_cross_prefix=hppa-linux-gnu-\n        ;;\n      i386)\n        container_image=fedora-i386-cross\n        container_cross_prefix=\n        ;;\n      loongarch64)\n        container_image=debian-loongarch-cross\n        container_cross_prefix=loongarch64-unknown-linux-gnu-\n        ;;\n      m68k)\n        container_image=debian-m68k-cross\n        container_cross_prefix=m68k-linux-gnu-\n        ;;\n      microblaze)\n        container_image=debian-microblaze-cross\n        container_cross_prefix=microblaze-linux-musl-\n        ;;\n      mips64el)\n        container_image=debian-mips64el-cross\n        container_cross_prefix=mips64el-linux-gnuabi64-\n        ;;\n      mips64)\n        container_image=debian-mips64-cross\n        container_cross_prefix=mips64-linux-gnuabi64-\n        ;;\n      mipsel)\n        container_image=debian-mipsel-cross\n        container_cross_prefix=mipsel-linux-gnu-\n        ;;\n      mips)\n        container_image=debian-mips-cross\n        container_cross_prefix=mips-linux-gnu-\n        ;;\n      nios2)\n        container_image=debian-nios2-cross\n        container_cross_prefix=nios2-linux-gnu-\n        ;;\n      ppc)\n        container_image=debian-powerpc-test-cross\n        container_cross_prefix=powerpc-linux-gnu-\n        container_cross_cc=${container_cross_prefix}gcc-10\n        ;;\n      ppc64|ppc64le)\n        container_image=debian-powerpc-test-cross\n        container_cross_prefix=powerpc${target_arch#ppc}-linux-gnu-\n        container_cross_cc=${container_cross_prefix}gcc-10\n        ;;\n      riscv64)\n        container_image=debian-riscv64-test-cross\n        container_cross_prefix=riscv64-linux-gnu-\n        ;;\n      s390x)\n        container_image=debian-s390x-cross\n        container_cross_prefix=s390x-linux-gnu-\n        ;;\n      sh4)\n        container_image=debian-sh4-cross\n        container_cross_prefix=sh4-linux-gnu-\n        ;;\n      sparc64)\n        container_image=debian-sparc64-cross\n        container_cross_prefix=sparc64-linux-gnu-\n        ;;\n      tricore)\n        container_image=debian-tricore-cross\n        container_cross_prefix=tricore-\n        container_cross_as=tricore-as\n        container_cross_ld=tricore-ld\n        break\n        ;;\n      x86_64)\n        container_image=debian-amd64-cross\n        container_cross_prefix=x86_64-linux-gnu-\n        ;;\n      xtensa*)\n        container_hosts=x86_64\n        container_image=debian-xtensa-cross\n\n        # default to the dc232b cpu\n        container_cross_prefix=/opt/2020.07/xtensa-dc232b-elf/bin/xtensa-dc232b-elf-\n        ;;\n    esac\n    : ${container_cross_cc:=${container_cross_prefix}gcc}\n    : ${container_cross_ar:=${container_cross_prefix}ar}\n    : ${container_cross_as:=${container_cross_prefix}as}\n    : ${container_cross_ld:=${container_cross_prefix}ld}\n    : ${container_cross_nm:=${container_cross_prefix}nm}\n    : ${container_cross_objcopy:=${container_cross_prefix}objcopy}\n    : ${container_cross_ranlib:=${container_cross_prefix}ranlib}\n    : ${container_cross_strip:=${container_cross_prefix}strip}\n  done\n\n  local t try\n  try=cross\n  case \"$target_arch:$cpu\" in\n    aarch64_be:aarch64 | \\\n    armeb:arm | \\\n    i386:x86_64 | \\\n    mips*:mips64 | \\\n    ppc*:ppc64 | \\\n    sparc:sparc64 | \\\n    \"$cpu:$cpu\")\n      try='native cross' ;;\n  esac\n  eval \"target_cflags=\\${cross_cc_cflags_$target_arch}\"\n  for t in $try; do\n    case $t in\n    native)\n      target_cc=$cc\n      target_ccas=$ccas\n      target_ar=$ar\n      target_as=$as\n      target_ld=$ld\n      target_nm=$nm\n      target_objcopy=$objcopy\n      target_ranlib=$ranlib\n      target_strip=$strip\n      ;;\n    cross)\n      target_cc=\n      if eval test -n \"\\\"\\${cross_cc_$target_arch}\\\"\"; then\n        if eval has \"\\\"\\${cross_cc_$target_arch}\\\"\"; then\n          eval \"target_cc=\\\"\\${cross_cc_$target_arch}\\\"\"\n        fi\n      else\n        compute_target_variable $target_arch target_cc gcc\n      fi\n      target_ccas=$target_cc\n      compute_target_variable $target_arch target_ar ar\n      compute_target_variable $target_arch target_as as\n      compute_target_variable $target_arch target_ld ld\n      compute_target_variable $target_arch target_nm nm\n      compute_target_variable $target_arch target_objcopy objcopy\n      compute_target_variable $target_arch target_ranlib ranlib\n      compute_target_variable $target_arch target_strip strip\n      ;;\n    esac\n\n    if test -n \"$target_cc\"; then\n      case $target_arch in\n        i386|x86_64)\n          if $target_cc --version | grep -qi \"clang\"; then\n            continue\n          fi\n          ;;\n      esac\n    elif test -n \"$target_as\" && test -n \"$target_ld\"; then\n      # Special handling for assembler only targets\n      case $target in\n        tricore-softmmu)\n          build_static=\n          got_cross_cc=yes\n          break\n          ;;\n        *)\n          continue\n          ;;\n      esac\n    else\n      continue\n    fi\n\n    write_c_skeleton\n    case $1 in\n      *-softmmu)\n        if do_compiler \"$target_cc\" $target_cflags -o $TMPO -c $TMPC &&\n          do_compiler \"$target_cc\" $target_cflags -r -nostdlib -o \"${TMPDIR1}/${TMPB}2.o\" \"$TMPO\" -lgcc; then\n          got_cross_cc=yes\n          break\n        fi\n        ;;\n      *)\n        if do_compiler \"$target_cc\" $target_cflags -o $TMPE $TMPC -static ; then\n          build_static=y\n          got_cross_cc=yes\n          break\n        fi\n        if do_compiler \"$target_cc\" $target_cflags -o $TMPE $TMPC ; then\n          build_static=\n          got_cross_cc=yes\n          break\n        fi\n        ;;\n    esac\n  done\n  if test $got_cross_cc != yes; then\n    build_static=\n    target_cc=\n    target_ccas=\n    target_ar=\n    target_as=\n    target_ld=\n    target_nm=\n    target_objcopy=\n    target_ranlib=\n    target_strip=\n  fi\n}\n\nwrite_target_makefile() {\n  echo \"EXTRA_CFLAGS=$target_cflags\"\n  if test -n \"$target_cc\"; then\n    echo \"CC=$target_cc\"\n    echo \"CCAS=$target_ccas\"\n  fi\n  if test -n \"$target_ar\"; then\n    echo \"AR=$target_ar\"\n  fi\n  if test -n \"$target_as\"; then\n    echo \"AS=$target_as\"\n  fi\n  if test -n \"$target_ld\"; then\n    echo \"LD=$target_ld\"\n  fi\n  if test -n \"$target_nm\"; then\n    echo \"NM=$target_nm\"\n  fi\n  if test -n \"$target_objcopy\"; then\n    echo \"OBJCOPY=$target_objcopy\"\n  fi\n  if test -n \"$target_ranlib\"; then\n    echo \"RANLIB=$target_ranlib\"\n  fi\n  if test -n \"$target_strip\"; then\n    echo \"STRIP=$target_strip\"\n  fi\n}\n\nwrite_container_target_makefile() {\n  echo \"EXTRA_CFLAGS=$target_cflags\"\n  if test -n \"$container_cross_cc\"; then\n    echo \"CC=\\$(DOCKER_SCRIPT) cc --cc $container_cross_cc -i qemu/$container_image -s $source_path --\"\n    echo \"CCAS=\\$(DOCKER_SCRIPT) cc --cc $container_cross_cc -i qemu/$container_image -s $source_path --\"\n  fi\n  echo \"AR=\\$(DOCKER_SCRIPT) cc --cc $container_cross_ar -i qemu/$container_image -s $source_path --\"\n  echo \"AS=\\$(DOCKER_SCRIPT) cc --cc $container_cross_as -i qemu/$container_image -s $source_path --\"\n  echo \"LD=\\$(DOCKER_SCRIPT) cc --cc $container_cross_ld -i qemu/$container_image -s $source_path --\"\n  echo \"NM=\\$(DOCKER_SCRIPT) cc --cc $container_cross_nm -i qemu/$container_image -s $source_path --\"\n  echo \"OBJCOPY=\\$(DOCKER_SCRIPT) cc --cc $container_cross_objcopy -i qemu/$container_image -s $source_path --\"\n  echo \"RANLIB=\\$(DOCKER_SCRIPT) cc --cc $container_cross_ranlib -i qemu/$container_image -s $source_path --\"\n  echo \"STRIP=\\$(DOCKER_SCRIPT) cc --cc $container_cross_strip -i qemu/$container_image -s $source_path --\"\n}\n\n\n\n##########################################\n# check for vfio_user_server\n\ncase \"$vfio_user_server\" in\n  enabled )\n    if test \"$git_submodules_action\" != \"ignore\"; then\n      git_submodules=\"${git_submodules} subprojects/libvfio-user\"\n    fi\n    ;;\nesac\n\n##########################################\n# End of CC checks\n# After here, no more $cc or $ld runs\n\nwrite_c_skeleton\n\nif test \"$fortify_source\" = \"yes\" ; then\n  QEMU_CFLAGS=\"-U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $QEMU_CFLAGS\"\nfi\n\nif test \"$have_asan\" = \"yes\"; then\n  QEMU_CFLAGS=\"-fsanitize=address $QEMU_CFLAGS\"\n  QEMU_LDFLAGS=\"-fsanitize=address $QEMU_LDFLAGS\"\n  if test \"$have_asan_iface_h\" = \"no\" ; then\n      echo \"ASAN build enabled, but ASAN header missing.\" \\\n           \"Without code annotation, the report may be inferior.\"\n  elif test \"$have_asan_iface_fiber\" = \"no\" ; then\n      echo \"ASAN build enabled, but ASAN header is too old.\" \\\n           \"Without code annotation, the report may be inferior.\"\n  fi\nfi\nif test \"$have_tsan\" = \"yes\" ; then\n  if test \"$have_tsan_iface_fiber\" = \"yes\" ; then\n    QEMU_CFLAGS=\"-fsanitize=thread $QEMU_CFLAGS\"\n    QEMU_LDFLAGS=\"-fsanitize=thread $QEMU_LDFLAGS\"\n  else\n    error_exit \"Cannot enable TSAN due to missing fiber annotation interface.\"\n  fi\nelif test \"$tsan\" = \"yes\" ; then\n  error_exit \"Cannot enable TSAN due to missing sanitize thread interface.\"\nfi\nif test \"$have_ubsan\" = \"yes\"; then\n  QEMU_CFLAGS=\"-fsanitize=undefined $QEMU_CFLAGS\"\n  QEMU_LDFLAGS=\"-fsanitize=undefined $QEMU_LDFLAGS\"\nfi\n\n##########################################\n\n# Exclude --warn-common with TSan to suppress warnings from the TSan libraries.\nif test \"$solaris\" = \"no\" && test \"$tsan\" = \"no\"; then\n    if $ld --version 2>/dev/null | grep \"GNU ld\" >/dev/null 2>/dev/null ; then\n        QEMU_LDFLAGS=\"-Wl,--warn-common $QEMU_LDFLAGS\"\n    fi\nfi\n\n# Guest agent Windows MSI package\n\nif test \"$QEMU_GA_MANUFACTURER\" = \"\"; then\n  QEMU_GA_MANUFACTURER=QEMU\nfi\nif test \"$QEMU_GA_DISTRO\" = \"\"; then\n  QEMU_GA_DISTRO=Linux\nfi\nif test \"$QEMU_GA_VERSION\" = \"\"; then\n    QEMU_GA_VERSION=$(cat $source_path/VERSION.QEMU)\nfi\n\n\n#######################################\n# cross-compiled firmware targets\n\n# Set up build tree symlinks that point back into the source tree\n# (these can be both files and directories).\n# Caution: avoid adding files or directories here using wildcards. This\n# will result in problems later if a new file matching the wildcard is\n# added to the source tree -- nothing will cause configure to be rerun\n# so the build tree will be missing the link back to the new file, and\n# tests might fail. Prefer to keep the relevant files in their own\n# directory and symlink the directory instead.\nLINKS=\"Makefile\"\nLINKS=\"$LINKS tests/tcg/Makefile.target\"\nLINKS=\"$LINKS pc-bios/optionrom/Makefile\"\nLINKS=\"$LINKS pc-bios/s390-ccw/Makefile\"\nLINKS=\"$LINKS pc-bios/vof/Makefile\"\nLINKS=\"$LINKS .gdbinit scripts\" # scripts needed by relative path in .gdbinit\nLINKS=\"$LINKS tests/avocado tests/data\"\nLINKS=\"$LINKS tests/qemu-iotests/check\"\nLINKS=\"$LINKS python\"\nLINKS=\"$LINKS contrib/plugins/Makefile \"\nfor f in $LINKS ; do\n    if [ -e \"$source_path/$f\" ]; then\n        mkdir -p `dirname ./$f`\n        symlink \"$source_path/$f\" \"$f\"\n    fi\ndone\n\n# Mac OS X ships with a broken assembler\nroms=\nprobe_target_compiler i386-softmmu\nif test -n \"$target_cc\" &&\n        test \"$targetos\" != \"darwin\" && test \"$targetos\" != \"sunos\" && \\\n        test \"$targetos\" != \"haiku\" && test \"$softmmu\" = yes ; then\n    # Different host OS linkers have different ideas about the name of the ELF\n    # emulation. Linux and OpenBSD/amd64 use 'elf_i386'; FreeBSD uses the _fbsd\n    # variant; OpenBSD/i386 uses the _obsd variant; and Windows uses i386pe.\n    for emu in elf_i386 elf_i386_fbsd elf_i386_obsd i386pe; do\n        if \"$target_ld\" -verbose 2>&1 | grep -q \"^[[:space:]]*${emu}[[:space:]]*$\"; then\n            ld_i386_emulation=\"$emu\"\n            break\n        fi\n    done\n    if test -n \"$ld_i386_emulation\"; then\n        roms=\"pc-bios/optionrom\"\n        config_mak=pc-bios/optionrom/config.mak\n        echo \"# Automatically generated by configure - do not modify\" > $config_mak\n        echo \"TOPSRC_DIR=$source_path\" >> $config_mak\n        echo \"LD_I386_EMULATION=$ld_i386_emulation\" >> $config_mak\n        write_target_makefile >> $config_mak\n    fi\nfi\n\nprobe_target_compiler ppc-softmmu\nif test -n \"$target_cc\" && test \"$softmmu\" = yes; then\n    roms=\"$roms pc-bios/vof\"\n    config_mak=pc-bios/vof/config.mak\n    echo \"# Automatically generated by configure - do not modify\" > $config_mak\n    echo \"SRC_DIR=$source_path/pc-bios/vof\" >> $config_mak\n    write_target_makefile >> $config_mak\nfi\n\n# Only build s390-ccw bios if the compiler has -march=z900 or -march=z10\n# (which is the lowest architecture level that Clang supports)\nprobe_target_compiler s390x-softmmu\nif test -n \"$target_cc\" && test \"$softmmu\" = yes; then\n  write_c_skeleton\n  do_compiler \"$target_cc\" $target_cc_cflags -march=z900 -o $TMPO -c $TMPC\n  has_z900=$?\n  if [ $has_z900 = 0 ] || do_compiler \"$target_cc\" $target_cc_cflags -march=z10 -msoft-float -Werror -o $TMPO -c $TMPC; then\n    if [ $has_z900 != 0 ]; then\n      echo \"WARNING: Your compiler does not support the z900!\"\n      echo \"         The s390-ccw bios will only work with guest CPUs >= z10.\"\n    fi\n    roms=\"$roms pc-bios/s390-ccw\"\n    config_mak=pc-bios/s390-ccw/config-host.mak\n    echo \"# Automatically generated by configure - do not modify\" > $config_mak\n    echo \"SRC_PATH=$source_path/pc-bios/s390-ccw\" >> $config_mak\n    write_target_makefile >> $config_mak\n    # SLOF is required for building the s390-ccw firmware on s390x,\n    # since it is using the libnet code from SLOF for network booting.\n    git_submodules=\"${git_submodules} roms/SLOF\"\n  fi\nfi\n\n#######################################\n# generate config-host.mak\n\n# Check that the C++ compiler exists and works with the C compiler.\n# All the QEMU_CXXFLAGS are based on QEMU_CFLAGS. Keep this at the end to don't miss any other that could be added.\nif has $cxx; then\n    cat > $TMPC <<EOF\nint c_function(void);\nint main(void) { return c_function(); }\nEOF\n\n    compile_object\n\n    cat > $TMPCXX <<EOF\nextern \"C\" {\n   int c_function(void);\n}\nint c_function(void) { return 42; }\nEOF\n\n    update_cxxflags\n\n    if do_cxx $CXXFLAGS $EXTRA_CXXFLAGS $CONFIGURE_CXXFLAGS $QEMU_CXXFLAGS -o $TMPE $TMPCXX $TMPO $QEMU_LDFLAGS; then\n        # C++ compiler $cxx works ok with C compiler $cc\n        :\n    else\n        echo \"C++ compiler $cxx does not work with C compiler $cc\"\n        echo \"Disabling C++ specific optional code\"\n        cxx=\n    fi\nelse\n    echo \"No C++ compiler available; disabling C++ specific optional code\"\n    cxx=\nfi\n\nif ! (GIT=\"$git\" \"$source_path/scripts/git-submodule.sh\" \"$git_submodules_action\" \"$git_submodules\"); then\n    exit 1\nfi\n\nconfig_host_mak=\"config-host.mak\"\n\necho \"# Automatically generated by configure - do not modify\" > $config_host_mak\necho >> $config_host_mak\n\necho all: >> $config_host_mak\necho \"GIT=$git\" >> $config_host_mak\necho \"GIT_SUBMODULES=$git_submodules\" >> $config_host_mak\necho \"GIT_SUBMODULES_ACTION=$git_submodules_action\" >> $config_host_mak\n\nif test \"$debug_tcg\" = \"yes\" ; then\n  echo \"CONFIG_DEBUG_TCG=y\" >> $config_host_mak\nfi\nif test \"$mingw32\" = \"yes\" ; then\n  echo \"CONFIG_WIN32=y\" >> $config_host_mak\n  echo \"QEMU_GA_MANUFACTURER=${QEMU_GA_MANUFACTURER}\" >> $config_host_mak\n  echo \"QEMU_GA_DISTRO=${QEMU_GA_DISTRO}\" >> $config_host_mak\n  echo \"QEMU_GA_VERSION=${QEMU_GA_VERSION}\" >> $config_host_mak\nelse\n  echo \"CONFIG_POSIX=y\" >> $config_host_mak\nfi\n\nif test \"$linux\" = \"yes\" ; then\n  echo \"CONFIG_LINUX=y\" >> $config_host_mak\nfi\n\nif test \"$darwin\" = \"yes\" ; then\n  echo \"CONFIG_DARWIN=y\" >> $config_host_mak\nfi\n\nif test \"$solaris\" = \"yes\" ; then\n  echo \"CONFIG_SOLARIS=y\" >> $config_host_mak\nfi\nif test \"$static\" = \"yes\" ; then\n  echo \"CONFIG_STATIC=y\" >> $config_host_mak\nfi\necho \"SRC_PATH=$source_path\" >> $config_host_mak\necho \"TARGET_DIRS=$target_list\" >> $config_host_mak\nif test \"$modules\" = \"yes\"; then\n  echo \"CONFIG_MODULES=y\" >> $config_host_mak\nfi\n\n# XXX: suppress that\nif [ \"$bsd\" = \"yes\" ] ; then\n  echo \"CONFIG_BSD=y\" >> $config_host_mak\nfi\n\necho \"CONFIG_COROUTINE_BACKEND=$coroutine\" >> $config_host_mak\n\nif test \"$have_asan_iface_fiber\" = \"yes\" ; then\n    echo \"CONFIG_ASAN_IFACE_FIBER=y\" >> $config_host_mak\nfi\n\nif test \"$have_tsan\" = \"yes\" && test \"$have_tsan_iface_fiber\" = \"yes\" ; then\n    echo \"CONFIG_TSAN=y\" >> $config_host_mak\nfi\n\nif test \"$plugins\" = \"yes\" ; then\n    echo \"CONFIG_PLUGIN=y\" >> $config_host_mak\nfi\n\nif test -n \"$gdb_bin\"; then\n    gdb_version=$($gdb_bin --version | head -n 1)\n    if version_ge ${gdb_version##* } 9.1; then\n        echo \"HAVE_GDB_BIN=$gdb_bin\" >> $config_host_mak\n    fi\nfi\n\necho \"ROMS=$roms\" >> $config_host_mak\necho \"MAKE=$make\" >> $config_host_mak\necho \"PYTHON=$python\" >> $config_host_mak\necho \"GENISOIMAGE=$genisoimage\" >> $config_host_mak\necho \"MESON=$meson\" >> $config_host_mak\necho \"NINJA=$ninja\" >> $config_host_mak\necho \"CC=$cc\" >> $config_host_mak\necho \"QEMU_CFLAGS=$QEMU_CFLAGS\" >> $config_host_mak\necho \"QEMU_CXXFLAGS=$QEMU_CXXFLAGS\" >> $config_host_mak\necho \"QEMU_OBJCFLAGS=$QEMU_OBJCFLAGS\" >> $config_host_mak\necho \"GLIB_CFLAGS=$glib_cflags\" >> $config_host_mak\necho \"GLIB_LIBS=$glib_libs\" >> $config_host_mak\necho \"GLIB_BINDIR=$glib_bindir\" >> $config_host_mak\necho \"GLIB_VERSION=$(pkg-config --modversion glib-2.0)\" >> $config_host_mak\necho \"QEMU_LDFLAGS=$QEMU_LDFLAGS\" >> $config_host_mak\necho \"EXESUF=$EXESUF\" >> $config_host_mak\n\n# use included Linux headers\nif test \"$linux\" = \"yes\" ; then\n  mkdir -p linux-headers\n  case \"$cpu\" in\n  i386|x86_64)\n    linux_arch=x86\n    ;;\n  ppc|ppc64)\n    linux_arch=powerpc\n    ;;\n  s390x)\n    linux_arch=s390\n    ;;\n  aarch64)\n    linux_arch=arm64\n    ;;\n  loongarch*)\n    linux_arch=loongarch\n    ;;\n  mips64)\n    linux_arch=mips\n    ;;\n  *)\n    # For most CPUs the kernel architecture name and QEMU CPU name match.\n    linux_arch=\"$cpu\"\n    ;;\n  esac\n    # For non-KVM architectures we will not have asm headers\n    if [ -e \"$source_path/linux-headers/asm-$linux_arch\" ]; then\n      symlink \"$source_path/linux-headers/asm-$linux_arch\" linux-headers/asm\n    fi\nfi\n\nfor target in $target_list; do\n    target_dir=\"$target\"\n    target_name=$(echo $target | cut -d '-' -f 1)$EXESUF\n    mkdir -p $target_dir\n    case $target in\n        *-user) symlink \"../qemu-$target_name\" \"$target_dir/qemu-$target_name\" ;;\n        *) symlink \"../qemu-system-$target_name\" \"$target_dir/qemu-system-$target_name\" ;;\n    esac\ndone\n\nif test \"$default_targets\" = \"yes\"; then\n  echo \"CONFIG_DEFAULT_TARGETS=y\" >> $config_host_mak\nfi\n\nif test \"$ccache_cpp2\" = \"yes\"; then\n  echo \"export CCACHE_CPP2=y\" >> $config_host_mak\nfi\n\nif test \"$safe_stack\" = \"yes\"; then\n  echo \"CONFIG_SAFESTACK=y\" >> $config_host_mak\nfi\n\n# tests/tcg configuration\n(makefile=tests/tcg/Makefile.prereqs\necho \"# Automatically generated by configure - do not modify\" > $makefile\n\nconfig_host_mak=tests/tcg/config-host.mak\necho \"# Automatically generated by configure - do not modify\" > $config_host_mak\necho \"SRC_PATH=$source_path\" >> $config_host_mak\necho \"HOST_CC=$host_cc\" >> $config_host_mak\n\ntcg_tests_targets=\nfor target in $target_list; do\n  arch=${target%%-*}\n\n  config_target_mak=tests/tcg/config-$target.mak\n\n  echo \"# Automatically generated by configure - do not modify\" > $config_target_mak\n  echo \"TARGET_NAME=$arch\" >> $config_target_mak\n  case $target in\n    xtensa*-linux-user)\n      # the toolchain is not complete with headers, only build softmmu tests\n      continue\n      ;;\n    *-softmmu)\n      test -f $source_path/tests/tcg/$arch/Makefile.softmmu-target || continue\n      qemu=\"qemu-system-$arch\"\n      ;;\n    *-linux-user|*-bsd-user)\n      qemu=\"qemu-$arch\"\n      ;;\n  esac\n\n  probe_target_compiler $target\n  if test $got_cross_cc = yes; then\n      # Test for compiler features for optional tests. We only do this\n      # for cross compilers because ensuring the docker containers based\n      # compilers is a requirememt for adding a new test that needs a\n      # compiler feature.\n\n      echo \"BUILD_STATIC=$build_static\" >> $config_target_mak\n      write_target_makefile >> $config_target_mak\n      case $target in\n          aarch64-*)\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -march=armv8.1-a+sve -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_SVE=y\" >> $config_target_mak\n              fi\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -march=armv8.1-a+sve2 -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_SVE2=y\" >> $config_target_mak\n              fi\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -march=armv8.3-a -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_ARMV8_3=y\" >> $config_target_mak\n              fi\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -mbranch-protection=standard -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_ARMV8_BTI=y\" >> $config_target_mak\n              fi\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -march=armv8.5-a+memtag -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_ARMV8_MTE=y\" >> $config_target_mak\n              fi\n              ;;\n          ppc*)\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -mpower8-vector -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_POWER8_VECTOR=y\" >> $config_target_mak\n              fi\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -mpower10 -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_POWER10=y\" >> $config_target_mak\n              fi\n              ;;\n          i386-linux-user)\n              if do_compiler \"$target_cc\" $target_cflags \\\n                             -Werror -fno-pie -o $TMPE $TMPC; then\n                  echo \"CROSS_CC_HAS_I386_NOPIE=y\" >> $config_target_mak\n              fi\n              ;;\n      esac\n  elif test -n \"$container_image\"; then\n      echo \"build-tcg-tests-$target: docker-image-$container_image\" >> $makefile\n      echo \"BUILD_STATIC=y\" >> $config_target_mak\n      write_container_target_makefile >> $config_target_mak\n      case $target in\n          aarch64-*)\n              echo \"CROSS_CC_HAS_SVE=y\" >> $config_target_mak\n              echo \"CROSS_CC_HAS_SVE2=y\" >> $config_target_mak\n              echo \"CROSS_CC_HAS_ARMV8_3=y\" >> $config_target_mak\n              echo \"CROSS_CC_HAS_ARMV8_BTI=y\" >> $config_target_mak\n              echo \"CROSS_CC_HAS_ARMV8_MTE=y\" >> $config_target_mak\n              ;;\n          ppc*)\n              echo \"CROSS_CC_HAS_POWER8_VECTOR=y\" >> $config_target_mak\n              echo \"CROSS_CC_HAS_POWER10=y\" >> $config_target_mak\n              ;;\n          i386-linux-user)\n              echo \"CROSS_CC_HAS_I386_NOPIE=y\" >> $config_target_mak\n              ;;\n      esac\n      got_cross_cc=yes\n  fi\n  if test $got_cross_cc = yes; then\n      mkdir -p tests/tcg/$target\n      echo \"QEMU=$PWD/$qemu\" >> $config_target_mak\n      echo \"run-tcg-tests-$target: $qemu\\$(EXESUF)\" >> $makefile\n      tcg_tests_targets=\"$tcg_tests_targets $target\"\n  fi\ndone\necho \"TCG_TESTS_TARGETS=$tcg_tests_targets\" >> $makefile)\n\nif test \"$skip_meson\" = no; then\n  cross=\"config-meson.cross.new\"\n  meson_quote() {\n    test $# = 0 && return\n    echo \"'$(echo $* | sed \"s/ /','/g\")'\"\n  }\n\n  echo \"# Automatically generated by configure - do not modify\" > $cross\n  echo \"[properties]\" >> $cross\n\n  # unroll any custom device configs\n  for a in $device_archs; do\n      eval \"c=\\$devices_${a}\"\n      echo \"${a}-softmmu = '$c'\" >> $cross\n  done\n\n  test -z \"$cxx\" && echo \"link_language = 'c'\" >> $cross\n  echo \"[built-in options]\" >> $cross\n  echo \"c_args = [$(meson_quote $CFLAGS $EXTRA_CFLAGS)]\" >> $cross\n  echo \"cpp_args = [$(meson_quote $CXXFLAGS $EXTRA_CXXFLAGS)]\" >> $cross\n  test -n \"$objcc\" && echo \"objc_args = [$(meson_quote $OBJCFLAGS $EXTRA_OBJCFLAGS)]\" >> $cross\n  echo \"c_link_args = [$(meson_quote $CFLAGS $LDFLAGS $EXTRA_CFLAGS $EXTRA_LDFLAGS)]\" >> $cross\n  echo \"cpp_link_args = [$(meson_quote $CXXFLAGS $LDFLAGS $EXTRA_CXXFLAGS $EXTRA_LDFLAGS)]\" >> $cross\n  echo \"[binaries]\" >> $cross\n  echo \"c = [$(meson_quote $cc $CPU_CFLAGS)]\" >> $cross\n  test -n \"$cxx\" && echo \"cpp = [$(meson_quote $cxx $CPU_CFLAGS)]\" >> $cross\n  test -n \"$objcc\" && echo \"objc = [$(meson_quote $objcc $CPU_CFLAGS)]\" >> $cross\n  echo \"ar = [$(meson_quote $ar)]\" >> $cross\n  echo \"nm = [$(meson_quote $nm)]\" >> $cross\n  echo \"pkgconfig = [$(meson_quote $pkg_config_exe)]\" >> $cross\n  echo \"ranlib = [$(meson_quote $ranlib)]\" >> $cross\n  if has $sdl2_config; then\n    echo \"sdl2-config = [$(meson_quote $sdl2_config)]\" >> $cross\n  fi\n  echo \"strip = [$(meson_quote $strip)]\" >> $cross\n  echo \"widl = [$(meson_quote $widl)]\" >> $cross\n  echo \"windres = [$(meson_quote $windres)]\" >> $cross\n  if test \"$cross_compile\" = \"yes\"; then\n    cross_arg=\"--cross-file config-meson.cross\"\n    echo \"[host_machine]\" >> $cross\n    echo \"system = '$targetos'\" >> $cross\n    case \"$cpu\" in\n        i386)\n            echo \"cpu_family = 'x86'\" >> $cross\n            ;;\n        *)\n            echo \"cpu_family = '$cpu'\" >> $cross\n            ;;\n    esac\n    echo \"cpu = '$cpu'\" >> $cross\n    if test \"$bigendian\" = \"yes\" ; then\n        echo \"endian = 'big'\" >> $cross\n    else\n        echo \"endian = 'little'\" >> $cross\n    fi\n  else\n    cross_arg=\"--native-file config-meson.cross\"\n  fi\n  mv $cross config-meson.cross\n\n  rm -rf meson-private meson-info meson-logs\n\n  # Built-in options\n  test \"$bindir\" != \"bin\" && meson_option_add \"-Dbindir=$bindir\"\n  test \"$default_feature\" = no && meson_option_add -Dauto_features=disabled\n  test \"$pie\" = no && meson_option_add -Db_pie=false\n  test \"$werror\" = yes && meson_option_add -Dwerror=true\n\n  # QEMU options\n  test \"$cfi\" != false && meson_option_add \"-Dcfi=$cfi\"\n  test \"$fdt\" != auto && meson_option_add \"-Dfdt=$fdt\"\n  test -n \"${LIB_FUZZING_ENGINE+xxx}\" && meson_option_add \"-Dfuzzing_engine=$LIB_FUZZING_ENGINE\"\n  test \"$qemu_suffix\" != qemu && meson_option_add \"-Dqemu_suffix=$qemu_suffix\"\n  test \"$slirp\" != auto && meson_option_add \"-Dslirp=$slirp\"\n  test \"$smbd\" != '' && meson_option_add \"-Dsmbd=$smbd\"\n  test \"$tcg\" != enabled && meson_option_add \"-Dtcg=$tcg\"\n  test \"$vfio_user_server\" != auto && meson_option_add \"-Dvfio_user_server=$vfio_user_server\"\n  run_meson() {\n    NINJA=$ninja $meson setup --prefix \"$prefix\" \"$@\" $cross_arg \"$PWD\" \"$source_path\"\n  }\n  eval run_meson $meson_options\n  if test \"$?\" -ne 0 ; then\n      error_exit \"meson setup failed\"\n  fi\nelse\n  if test -f meson-private/cmd_line.txt; then\n    # Adjust old command line options whose type was changed\n    # Avoids having to use \"setup --wipe\" when Meson is upgraded\n    perl -i -ne '\n      s/^gettext = true$/gettext = auto/;\n      s/^gettext = false$/gettext = disabled/;\n      /^b_staticpic/ && next;\n      print;' meson-private/cmd_line.txt\n  fi\nfi\n\n# Save the configure command line for later reuse.\ncat <<EOD >config.status\n#!/bin/sh\n# Generated by configure.\n# Run this file to recreate the current configuration.\n# Compiler output produced by configure, useful for debugging\n# configure, is in config.log if it exists.\nEOD\n\npreserve_env() {\n    envname=$1\n\n    eval envval=\\$$envname\n\n    if test -n \"$envval\"\n    then\n\techo \"$envname='$envval'\" >> config.status\n\techo \"export $envname\" >> config.status\n    else\n\techo \"unset $envname\" >> config.status\n    fi\n}\n\n# Preserve various env variables that influence what\n# features/build target configure will detect\npreserve_env AR\npreserve_env AS\npreserve_env CC\npreserve_env CFLAGS\npreserve_env CXX\npreserve_env CXXFLAGS\npreserve_env LD\npreserve_env LDFLAGS\npreserve_env LD_LIBRARY_PATH\npreserve_env MAKE\npreserve_env NM\npreserve_env OBJCFLAGS\npreserve_env OBJCOPY\npreserve_env PATH\npreserve_env PKG_CONFIG\npreserve_env PKG_CONFIG_LIBDIR\npreserve_env PKG_CONFIG_PATH\npreserve_env PYTHON\npreserve_env SDL2_CONFIG\npreserve_env SMBD\npreserve_env STRIP\npreserve_env WIDL\npreserve_env WINDRES\n\nprintf \"exec\" >>config.status\nfor i in \"$0\" \"$@\"; do\n  test \"$i\" = --skip-meson || printf \" %s\" \"$(quote_sh \"$i\")\" >>config.status\ndone\necho ' \"$@\"' >>config.status\nchmod +x config.status\n\nrm -r \"$TMPDIR1\"\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "cpu.c",
          "type": "blob",
          "size": 12.640625,
          "content": "/*\n * Target-specific parts of the CPU object\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n\n#include \"exec/target_page.h\"\n#include \"hw/qdev-core.h\"\n#include \"hw/qdev-properties.h\"\n#include \"qemu/error-report.h\"\n#include \"migration/vmstate.h\"\n#ifdef CONFIG_USER_ONLY\n#include \"qemu.h\"\n#else\n#include \"hw/core/sysemu-cpu-ops.h\"\n#include \"exec/address-spaces.h\"\n#endif\n#include \"sysemu/tcg.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/replay.h\"\n#include \"exec/cpu-common.h\"\n#include \"exec/exec-all.h\"\n#include \"exec/translate-all.h\"\n#include \"exec/log.h\"\n#include \"hw/core/accel-cpu.h\"\n#include \"trace/trace-root.h\"\n#include \"qemu/accel.h\"\n\nuintptr_t qemu_host_page_size;\nintptr_t qemu_host_page_mask;\n\n#ifndef CONFIG_USER_ONLY\nstatic int cpu_common_post_load(void *opaque, int version_id)\n{\n    CPUState *cpu = opaque;\n\n    /* 0x01 was CPU_INTERRUPT_EXIT. This line can be removed when the\n       version_id is increased. */\n    cpu->interrupt_request &= ~0x01;\n    tlb_flush(cpu);\n\n    /* loadvm has just updated the content of RAM, bypassing the\n     * usual mechanisms that ensure we flush TBs for writes to\n     * memory we've translated code from. So we must flush all TBs,\n     * which will now be stale.\n     */\n    tb_flush(cpu);\n\n    return 0;\n}\n\nstatic int cpu_common_pre_load(void *opaque)\n{\n    CPUState *cpu = opaque;\n\n    cpu->exception_index = -1;\n\n    return 0;\n}\n\nstatic bool cpu_common_exception_index_needed(void *opaque)\n{\n    CPUState *cpu = opaque;\n\n    return tcg_enabled() && cpu->exception_index != -1;\n}\n\nstatic const VMStateDescription vmstate_cpu_common_exception_index = {\n    .name = \"cpu_common/exception_index\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .needed = cpu_common_exception_index_needed,\n    .fields = (VMStateField[]) {\n        VMSTATE_INT32(exception_index, CPUState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nstatic bool cpu_common_crash_occurred_needed(void *opaque)\n{\n    CPUState *cpu = opaque;\n\n    return cpu->crash_occurred;\n}\n\nstatic const VMStateDescription vmstate_cpu_common_crash_occurred = {\n    .name = \"cpu_common/crash_occurred\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .needed = cpu_common_crash_occurred_needed,\n    .fields = (VMStateField[]) {\n        VMSTATE_BOOL(crash_occurred, CPUState),\n        VMSTATE_END_OF_LIST()\n    }\n};\n\nconst VMStateDescription vmstate_cpu_common = {\n    .name = \"cpu_common\",\n    .version_id = 1,\n    .minimum_version_id = 1,\n    .pre_load = cpu_common_pre_load,\n    .post_load = cpu_common_post_load,\n    .fields = (VMStateField[]) {\n        VMSTATE_UINT32(halted, CPUState),\n        VMSTATE_UINT32(interrupt_request, CPUState),\n        VMSTATE_END_OF_LIST()\n    },\n    .subsections = (const VMStateDescription*[]) {\n        &vmstate_cpu_common_exception_index,\n        &vmstate_cpu_common_crash_occurred,\n        NULL\n    }\n};\n#endif\n\nvoid cpu_exec_realizefn(CPUState *cpu, Error **errp)\n{\n#ifndef CONFIG_USER_ONLY\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n#endif\n\n    cpu_list_add(cpu);\n    if (!accel_cpu_realizefn(cpu, errp)) {\n        return;\n    }\n    /* NB: errp parameter is unused currently */\n    if (tcg_enabled()) {\n        tcg_exec_realizefn(cpu, errp);\n    }\n\n#ifdef CONFIG_USER_ONLY\n    assert(qdev_get_vmsd(DEVICE(cpu)) == NULL ||\n           qdev_get_vmsd(DEVICE(cpu))->unmigratable);\n#else\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n        vmstate_register(NULL, cpu->cpu_index, &vmstate_cpu_common, cpu);\n    }\n    if (cc->sysemu_ops->legacy_vmsd != NULL) {\n        vmstate_register(NULL, cpu->cpu_index, cc->sysemu_ops->legacy_vmsd, cpu);\n    }\n#endif /* CONFIG_USER_ONLY */\n}\n\nvoid cpu_exec_unrealizefn(CPUState *cpu)\n{\n#ifndef CONFIG_USER_ONLY\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    if (cc->sysemu_ops->legacy_vmsd != NULL) {\n        vmstate_unregister(NULL, cc->sysemu_ops->legacy_vmsd, cpu);\n    }\n    if (qdev_get_vmsd(DEVICE(cpu)) == NULL) {\n        vmstate_unregister(NULL, &vmstate_cpu_common, cpu);\n    }\n#endif\n    if (tcg_enabled()) {\n        tcg_exec_unrealizefn(cpu);\n    }\n\n    cpu_list_remove(cpu);\n}\n\n/*\n * This can't go in hw/core/cpu.c because that file is compiled only\n * once for both user-mode and system builds.\n */\nstatic Property cpu_common_props[] = {\n#ifdef CONFIG_USER_ONLY\n    /*\n     * Create a property for the user-only object, so users can\n     * adjust prctl(PR_SET_UNALIGN) from the command-line.\n     * Has no effect if the target does not support the feature.\n     */\n    DEFINE_PROP_BOOL(\"prctl-unalign-sigbus\", CPUState,\n                     prctl_unalign_sigbus, false),\n#else\n    /*\n     * Create a memory property for softmmu CPU object, so users can\n     * wire up its memory.  The default if no link is set up is to use\n     * the system address space.\n     */\n    DEFINE_PROP_LINK(\"memory\", CPUState, memory, TYPE_MEMORY_REGION,\n                     MemoryRegion *),\n#endif\n    DEFINE_PROP_END_OF_LIST(),\n};\n\nstatic bool cpu_get_start_powered_off(Object *obj, Error **errp)\n{\n    CPUState *cpu = CPU(obj);\n    return cpu->start_powered_off;\n}\n\nstatic void cpu_set_start_powered_off(Object *obj, bool value, Error **errp)\n{\n    CPUState *cpu = CPU(obj);\n    cpu->start_powered_off = value;\n}\n\nvoid cpu_class_init_props(DeviceClass *dc)\n{\n    ObjectClass *oc = OBJECT_CLASS(dc);\n\n    device_class_set_props(dc, cpu_common_props);\n    /*\n     * We can't use DEFINE_PROP_BOOL in the Property array for this\n     * property, because we want this to be settable after realize.\n     */\n    object_class_property_add_bool(oc, \"start-powered-off\",\n                                   cpu_get_start_powered_off,\n                                   cpu_set_start_powered_off);\n}\n\nvoid cpu_exec_initfn(CPUState *cpu)\n{\n    cpu->as = NULL;\n    cpu->num_ases = 0;\n\n#ifndef CONFIG_USER_ONLY\n    cpu->thread_id = qemu_get_thread_id();\n    cpu->memory = get_system_memory();\n    object_ref(OBJECT(cpu->memory));\n#endif\n}\n\nconst char *parse_cpu_option(const char *cpu_option)\n{\n    ObjectClass *oc;\n    CPUClass *cc;\n    gchar **model_pieces;\n    const char *cpu_type;\n\n    model_pieces = g_strsplit(cpu_option, \",\", 2);\n    if (!model_pieces[0]) {\n        error_report(\"-cpu option cannot be empty\");\n        exit(1);\n    }\n\n    oc = cpu_class_by_name(CPU_RESOLVING_TYPE, model_pieces[0]);\n    if (oc == NULL) {\n        error_report(\"unable to find CPU model '%s'\", model_pieces[0]);\n        g_strfreev(model_pieces);\n        exit(EXIT_FAILURE);\n    }\n\n    cpu_type = object_class_get_name(oc);\n    cc = CPU_CLASS(oc);\n    cc->parse_features(cpu_type, model_pieces[1], &error_fatal);\n    g_strfreev(model_pieces);\n    return cpu_type;\n}\n\nvoid list_cpus(const char *optarg)\n{\n    /* XXX: implement xxx_cpu_list for targets that still miss it */\n#if defined(cpu_list)\n    cpu_list();\n#endif\n}\n\n#if defined(CONFIG_USER_ONLY)\nvoid tb_invalidate_phys_addr(target_ulong addr)\n{\n    mmap_lock();\n    tb_invalidate_phys_page_range(addr, addr + 1);\n    mmap_unlock();\n}\n#else\nvoid tb_invalidate_phys_addr(AddressSpace *as, hwaddr addr, MemTxAttrs attrs)\n{\n    ram_addr_t ram_addr;\n    MemoryRegion *mr;\n    hwaddr l = 1;\n\n    if (!tcg_enabled()) {\n        return;\n    }\n\n    RCU_READ_LOCK_GUARD();\n    mr = address_space_translate(as, addr, &addr, &l, false, attrs);\n    if (!(memory_region_is_ram(mr)\n          || memory_region_is_romd(mr))) {\n        return;\n    }\n    ram_addr = memory_region_get_ram_addr(mr) + addr;\n    tb_invalidate_phys_page_range(ram_addr, ram_addr + 1);\n}\n#endif\n\n/* Add a breakpoint.  */\nint cpu_breakpoint_insert(CPUState *cpu, vaddr pc, int flags,\n                          CPUBreakpoint **breakpoint)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUBreakpoint *bp;\n\n    if (cc->gdb_adjust_breakpoint) {\n        pc = cc->gdb_adjust_breakpoint(cpu, pc);\n    }\n\n    bp = g_malloc(sizeof(*bp));\n\n    bp->pc = pc;\n    bp->flags = flags;\n\n    /* keep all GDB-injected breakpoints in front */\n    if (flags & BP_GDB) {\n        QTAILQ_INSERT_HEAD(&cpu->breakpoints, bp, entry);\n    } else {\n        QTAILQ_INSERT_TAIL(&cpu->breakpoints, bp, entry);\n    }\n\n    if (breakpoint) {\n        *breakpoint = bp;\n    }\n\n    trace_breakpoint_insert(cpu->cpu_index, pc, flags);\n    return 0;\n}\n\n/* Remove a specific breakpoint.  */\nint cpu_breakpoint_remove(CPUState *cpu, vaddr pc, int flags)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUBreakpoint *bp;\n\n    if (cc->gdb_adjust_breakpoint) {\n        pc = cc->gdb_adjust_breakpoint(cpu, pc);\n    }\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n        if (bp->pc == pc && bp->flags == flags) {\n            cpu_breakpoint_remove_by_ref(cpu, bp);\n            return 0;\n        }\n    }\n    return -ENOENT;\n}\n\n/* Remove a specific breakpoint by reference.  */\nvoid cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *bp)\n{\n    QTAILQ_REMOVE(&cpu->breakpoints, bp, entry);\n\n    trace_breakpoint_remove(cpu->cpu_index, bp->pc, bp->flags);\n    g_free(bp);\n}\n\n/* Remove all matching breakpoints. */\nvoid cpu_breakpoint_remove_all(CPUState *cpu, int mask)\n{\n    CPUBreakpoint *bp, *next;\n\n    QTAILQ_FOREACH_SAFE(bp, &cpu->breakpoints, entry, next) {\n        if (bp->flags & mask) {\n            cpu_breakpoint_remove_by_ref(cpu, bp);\n        }\n    }\n}\n\n/* enable or disable single step mode. EXCP_DEBUG is returned by the\n   CPU loop after each instruction */\nvoid cpu_single_step(CPUState *cpu, int enabled)\n{\n    if (cpu->singlestep_enabled != enabled) {\n        cpu->singlestep_enabled = enabled;\n        if (kvm_enabled()) {\n            kvm_update_guest_debug(cpu, 0);\n        }\n        trace_breakpoint_singlestep(cpu->cpu_index, enabled);\n    }\n}\n\nvoid cpu_abort(CPUState *cpu, const char *fmt, ...)\n{\n    va_list ap;\n    va_list ap2;\n\n    va_start(ap, fmt);\n    va_copy(ap2, ap);\n    fprintf(stderr, \"qemu: fatal: \");\n    vfprintf(stderr, fmt, ap);\n    fprintf(stderr, \"\\n\");\n    cpu_dump_state(cpu, stderr, CPU_DUMP_FPU | CPU_DUMP_CCOP);\n    if (qemu_log_separate()) {\n        FILE *logfile = qemu_log_trylock();\n        if (logfile) {\n            fprintf(logfile, \"qemu: fatal: \");\n            vfprintf(logfile, fmt, ap2);\n            fprintf(logfile, \"\\n\");\n            cpu_dump_state(cpu, logfile, CPU_DUMP_FPU | CPU_DUMP_CCOP);\n            qemu_log_unlock(logfile);\n        }\n    }\n    va_end(ap2);\n    va_end(ap);\n    replay_finish();\n#if defined(CONFIG_USER_ONLY)\n    {\n        struct sigaction act;\n        sigfillset(&act.sa_mask);\n        act.sa_handler = SIG_DFL;\n        act.sa_flags = 0;\n        sigaction(SIGABRT, &act, NULL);\n    }\n#endif\n    abort();\n}\n\n/* physical memory access (slow version, mainly for debug) */\n#if defined(CONFIG_USER_ONLY)\nint cpu_memory_rw_debug(CPUState *cpu, vaddr addr,\n                        void *ptr, size_t len, bool is_write)\n{\n    int flags;\n    vaddr l, page;\n    void * p;\n    uint8_t *buf = ptr;\n\n    while (len > 0) {\n        page = addr & TARGET_PAGE_MASK;\n        l = (page + TARGET_PAGE_SIZE) - addr;\n        if (l > len)\n            l = len;\n        flags = page_get_flags(page);\n        if (!(flags & PAGE_VALID))\n            return -1;\n        if (is_write) {\n            if (!(flags & PAGE_WRITE))\n                return -1;\n            /* XXX: this code should not depend on lock_user */\n            if (!(p = lock_user(VERIFY_WRITE, addr, l, 0)))\n                return -1;\n            memcpy(p, buf, l);\n            unlock_user(p, addr, l);\n        } else {\n            if (!(flags & PAGE_READ))\n                return -1;\n            /* XXX: this code should not depend on lock_user */\n            if (!(p = lock_user(VERIFY_READ, addr, l, 1)))\n                return -1;\n            memcpy(buf, p, l);\n            unlock_user(p, addr, 0);\n        }\n        len -= l;\n        buf += l;\n        addr += l;\n    }\n    return 0;\n}\n#endif\n\nbool target_words_bigendian(void)\n{\n#if TARGET_BIG_ENDIAN\n    return true;\n#else\n    return false;\n#endif\n}\n\nvoid page_size_init(void)\n{\n    /* NOTE: we can always suppose that qemu_host_page_size >=\n       TARGET_PAGE_SIZE */\n    if (qemu_host_page_size == 0) {\n        qemu_host_page_size = qemu_real_host_page_size();\n    }\n    if (qemu_host_page_size < TARGET_PAGE_SIZE) {\n        qemu_host_page_size = TARGET_PAGE_SIZE;\n    }\n    qemu_host_page_mask = -(intptr_t)qemu_host_page_size;\n}\n"
        },
        {
          "name": "cpus-common.c",
          "type": "blob",
          "size": 10.26171875,
          "content": "/*\n * CPU thread main loop - common bits for user and system mode emulation\n *\n *  Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/main-loop.h\"\n#include \"exec/cpu-common.h\"\n#include \"hw/core/cpu.h\"\n#include \"sysemu/cpus.h\"\n#include \"qemu/lockable.h\"\n\nstatic QemuMutex qemu_cpu_list_lock;\nstatic QemuCond exclusive_cond;\nstatic QemuCond exclusive_resume;\nstatic QemuCond qemu_work_cond;\n\n/* >= 1 if a thread is inside start_exclusive/end_exclusive.  Written\n * under qemu_cpu_list_lock, read with atomic operations.\n */\nstatic int pending_cpus;\n\nvoid qemu_init_cpu_list(void)\n{\n    /* This is needed because qemu_init_cpu_list is also called by the\n     * child process in a fork.  */\n    pending_cpus = 0;\n\n    qemu_mutex_init(&qemu_cpu_list_lock);\n    qemu_cond_init(&exclusive_cond);\n    qemu_cond_init(&exclusive_resume);\n    qemu_cond_init(&qemu_work_cond);\n}\n\nvoid cpu_list_lock(void)\n{\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n}\n\nvoid cpu_list_unlock(void)\n{\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n}\n\nstatic bool cpu_index_auto_assigned;\n\nstatic int cpu_get_free_index(void)\n{\n    CPUState *some_cpu;\n    int max_cpu_index = 0;\n\n    cpu_index_auto_assigned = true;\n    CPU_FOREACH(some_cpu) {\n        if (some_cpu->cpu_index >= max_cpu_index) {\n            max_cpu_index = some_cpu->cpu_index + 1;\n        }\n    }\n    return max_cpu_index;\n}\n\nCPUTailQ cpus = QTAILQ_HEAD_INITIALIZER(cpus);\nstatic unsigned int cpu_list_generation_id;\n\nunsigned int cpu_list_generation_id_get(void)\n{\n    return cpu_list_generation_id;\n}\n\nvoid cpu_list_add(CPUState *cpu)\n{\n    QEMU_LOCK_GUARD(&qemu_cpu_list_lock);\n    if (cpu->cpu_index == UNASSIGNED_CPU_INDEX) {\n        cpu->cpu_index = cpu_get_free_index();\n        assert(cpu->cpu_index != UNASSIGNED_CPU_INDEX);\n    } else {\n        assert(!cpu_index_auto_assigned);\n    }\n    QTAILQ_INSERT_TAIL_RCU(&cpus, cpu, node);\n    cpu_list_generation_id++;\n}\n\nvoid cpu_list_remove(CPUState *cpu)\n{\n    QEMU_LOCK_GUARD(&qemu_cpu_list_lock);\n    if (!QTAILQ_IN_USE(cpu, node)) {\n        /* there is nothing to undo since cpu_exec_init() hasn't been called */\n        return;\n    }\n\n    QTAILQ_REMOVE_RCU(&cpus, cpu, node);\n    cpu->cpu_index = UNASSIGNED_CPU_INDEX;\n    cpu_list_generation_id++;\n}\n\nCPUState *qemu_get_cpu(int index)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu->cpu_index == index) {\n            return cpu;\n        }\n    }\n\n    return NULL;\n}\n\n/* current CPU in the current thread. It is only valid inside cpu_exec() */\n__thread CPUState *current_cpu;\n\nstruct qemu_work_item {\n    QSIMPLEQ_ENTRY(qemu_work_item) node;\n    run_on_cpu_func func;\n    run_on_cpu_data data;\n    bool free, exclusive, done;\n};\n\nstatic void queue_work_on_cpu(CPUState *cpu, struct qemu_work_item *wi)\n{\n    qemu_mutex_lock(&cpu->work_mutex);\n    QSIMPLEQ_INSERT_TAIL(&cpu->work_list, wi, node);\n    wi->done = false;\n    qemu_mutex_unlock(&cpu->work_mutex);\n\n    qemu_cpu_kick(cpu);\n}\n\nvoid do_run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data,\n                   QemuMutex *mutex)\n{\n    struct qemu_work_item wi;\n\n    if (qemu_cpu_is_self(cpu)) {\n        func(cpu, data);\n        return;\n    }\n\n    wi.func = func;\n    wi.data = data;\n    wi.done = false;\n    wi.free = false;\n    wi.exclusive = false;\n\n    queue_work_on_cpu(cpu, &wi);\n    while (!qatomic_mb_read(&wi.done)) {\n        CPUState *self_cpu = current_cpu;\n\n        qemu_cond_wait(&qemu_work_cond, mutex);\n        current_cpu = self_cpu;\n    }\n}\n\nvoid async_run_on_cpu(CPUState *cpu, run_on_cpu_func func, run_on_cpu_data data)\n{\n    struct qemu_work_item *wi;\n\n    wi = g_new0(struct qemu_work_item, 1);\n    wi->func = func;\n    wi->data = data;\n    wi->free = true;\n\n    queue_work_on_cpu(cpu, wi);\n}\n\n/* Wait for pending exclusive operations to complete.  The CPU list lock\n   must be held.  */\nstatic inline void exclusive_idle(void)\n{\n    while (pending_cpus) {\n        qemu_cond_wait(&exclusive_resume, &qemu_cpu_list_lock);\n    }\n}\n\n/* Start an exclusive operation.\n   Must only be called from outside cpu_exec.  */\nvoid start_exclusive(void)\n{\n    CPUState *other_cpu;\n    int running_cpus;\n\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n    exclusive_idle();\n\n    /* Make all other cpus stop executing.  */\n    qatomic_set(&pending_cpus, 1);\n\n    /* Write pending_cpus before reading other_cpu->running.  */\n    smp_mb();\n    running_cpus = 0;\n    CPU_FOREACH(other_cpu) {\n        if (qatomic_read(&other_cpu->running)) {\n            other_cpu->has_waiter = true;\n            running_cpus++;\n            qemu_cpu_kick(other_cpu);\n        }\n    }\n\n    qatomic_set(&pending_cpus, running_cpus + 1);\n    while (pending_cpus > 1) {\n        qemu_cond_wait(&exclusive_cond, &qemu_cpu_list_lock);\n    }\n\n    /* Can release mutex, no one will enter another exclusive\n     * section until end_exclusive resets pending_cpus to 0.\n     */\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n\n    current_cpu->in_exclusive_context = true;\n}\n\n/* Finish an exclusive operation.  */\nvoid end_exclusive(void)\n{\n    current_cpu->in_exclusive_context = false;\n\n    qemu_mutex_lock(&qemu_cpu_list_lock);\n    qatomic_set(&pending_cpus, 0);\n    qemu_cond_broadcast(&exclusive_resume);\n    qemu_mutex_unlock(&qemu_cpu_list_lock);\n}\n\n/* Wait for exclusive ops to finish, and begin cpu execution.  */\nvoid cpu_exec_start(CPUState *cpu)\n{\n    qatomic_set(&cpu->running, true);\n\n    /* Write cpu->running before reading pending_cpus.  */\n    smp_mb();\n\n    /* 1. start_exclusive saw cpu->running == true and pending_cpus >= 1.\n     * After taking the lock we'll see cpu->has_waiter == true and run---not\n     * for long because start_exclusive kicked us.  cpu_exec_end will\n     * decrement pending_cpus and signal the waiter.\n     *\n     * 2. start_exclusive saw cpu->running == false but pending_cpus >= 1.\n     * This includes the case when an exclusive item is running now.\n     * Then we'll see cpu->has_waiter == false and wait for the item to\n     * complete.\n     *\n     * 3. pending_cpus == 0.  Then start_exclusive is definitely going to\n     * see cpu->running == true, and it will kick the CPU.\n     */\n    if (unlikely(qatomic_read(&pending_cpus))) {\n        QEMU_LOCK_GUARD(&qemu_cpu_list_lock);\n        if (!cpu->has_waiter) {\n            /* Not counted in pending_cpus, let the exclusive item\n             * run.  Since we have the lock, just set cpu->running to true\n             * while holding it; no need to check pending_cpus again.\n             */\n            qatomic_set(&cpu->running, false);\n            exclusive_idle();\n            /* Now pending_cpus is zero.  */\n            qatomic_set(&cpu->running, true);\n        } else {\n            /* Counted in pending_cpus, go ahead and release the\n             * waiter at cpu_exec_end.\n             */\n        }\n    }\n}\n\n/* Mark cpu as not executing, and release pending exclusive ops.  */\nvoid cpu_exec_end(CPUState *cpu)\n{\n    qatomic_set(&cpu->running, false);\n\n    /* Write cpu->running before reading pending_cpus.  */\n    smp_mb();\n\n    /* 1. start_exclusive saw cpu->running == true.  Then it will increment\n     * pending_cpus and wait for exclusive_cond.  After taking the lock\n     * we'll see cpu->has_waiter == true.\n     *\n     * 2. start_exclusive saw cpu->running == false but here pending_cpus >= 1.\n     * This includes the case when an exclusive item started after setting\n     * cpu->running to false and before we read pending_cpus.  Then we'll see\n     * cpu->has_waiter == false and not touch pending_cpus.  The next call to\n     * cpu_exec_start will run exclusive_idle if still necessary, thus waiting\n     * for the item to complete.\n     *\n     * 3. pending_cpus == 0.  Then start_exclusive is definitely going to\n     * see cpu->running == false, and it can ignore this CPU until the\n     * next cpu_exec_start.\n     */\n    if (unlikely(qatomic_read(&pending_cpus))) {\n        QEMU_LOCK_GUARD(&qemu_cpu_list_lock);\n        if (cpu->has_waiter) {\n            cpu->has_waiter = false;\n            qatomic_set(&pending_cpus, pending_cpus - 1);\n            if (pending_cpus == 1) {\n                qemu_cond_signal(&exclusive_cond);\n            }\n        }\n    }\n}\n\nvoid async_safe_run_on_cpu(CPUState *cpu, run_on_cpu_func func,\n                           run_on_cpu_data data)\n{\n    struct qemu_work_item *wi;\n\n    wi = g_new0(struct qemu_work_item, 1);\n    wi->func = func;\n    wi->data = data;\n    wi->free = true;\n    wi->exclusive = true;\n\n    queue_work_on_cpu(cpu, wi);\n}\n\nvoid process_queued_cpu_work(CPUState *cpu)\n{\n    struct qemu_work_item *wi;\n\n    qemu_mutex_lock(&cpu->work_mutex);\n    if (QSIMPLEQ_EMPTY(&cpu->work_list)) {\n        qemu_mutex_unlock(&cpu->work_mutex);\n        return;\n    }\n    while (!QSIMPLEQ_EMPTY(&cpu->work_list)) {\n        wi = QSIMPLEQ_FIRST(&cpu->work_list);\n        QSIMPLEQ_REMOVE_HEAD(&cpu->work_list, node);\n        qemu_mutex_unlock(&cpu->work_mutex);\n        if (wi->exclusive) {\n            /* Running work items outside the BQL avoids the following deadlock:\n             * 1) start_exclusive() is called with the BQL taken while another\n             * CPU is running; 2) cpu_exec in the other CPU tries to takes the\n             * BQL, so it goes to sleep; start_exclusive() is sleeping too, so\n             * neither CPU can proceed.\n             */\n            qemu_mutex_unlock_iothread();\n            start_exclusive();\n            wi->func(cpu, wi->data);\n            end_exclusive();\n            qemu_mutex_lock_iothread();\n        } else {\n            wi->func(cpu, wi->data);\n        }\n        qemu_mutex_lock(&cpu->work_mutex);\n        if (wi->free) {\n            g_free(wi);\n        } else {\n            qatomic_mb_set(&wi->done, true);\n        }\n    }\n    qemu_mutex_unlock(&cpu->work_mutex);\n    qemu_cond_broadcast(&qemu_work_cond);\n}\n"
        },
        {
          "name": "crypto",
          "type": "tree",
          "content": null
        },
        {
          "name": "disas.c",
          "type": "blob",
          "size": 10.37890625,
          "content": "/* General \"disassemble this chunk\" code.  Used for debugging. */\n#include \"qemu/osdep.h\"\n#include \"disas/dis-asm.h\"\n#include \"elf.h\"\n#include \"qemu/qemu-print.h\"\n\n#include \"disas/disas.h\"\n#include \"disas/capstone.h\"\n\ntypedef struct CPUDebug {\n    struct disassemble_info info;\n    CPUState *cpu;\n} CPUDebug;\n\n/* Filled in by elfload.c.  Simplistic, but will do for now. */\nstruct syminfo *syminfos = NULL;\n\n/*\n * Get LENGTH bytes from info's buffer, at host address memaddr.\n * Transfer them to myaddr.\n */\nstatic int host_read_memory(bfd_vma memaddr, bfd_byte *myaddr, int length,\n                            struct disassemble_info *info)\n{\n    if (memaddr < info->buffer_vma\n        || memaddr + length > info->buffer_vma + info->buffer_length) {\n        /* Out of bounds.  Use EIO because GDB uses it.  */\n        return EIO;\n    }\n    memcpy (myaddr, info->buffer + (memaddr - info->buffer_vma), length);\n    return 0;\n}\n\n/*\n * Get LENGTH bytes from info's buffer, at target address memaddr.\n * Transfer them to myaddr.\n */\nstatic int target_read_memory(bfd_vma memaddr, bfd_byte *myaddr, int length,\n                              struct disassemble_info *info)\n{\n    CPUDebug *s = container_of(info, CPUDebug, info);\n    int r = cpu_memory_rw_debug(s->cpu, memaddr, myaddr, length, 0);\n    return r ? EIO : 0;\n}\n\n/*\n * Print an error message.  We can assume that this is in response to\n * an error return from {host,target}_read_memory.\n */\nstatic void perror_memory(int status, bfd_vma memaddr,\n                          struct disassemble_info *info)\n{\n    if (status != EIO) {\n        /* Can't happen.  */\n        info->fprintf_func(info->stream, \"Unknown error %d\\n\", status);\n    } else {\n        /* Address between memaddr and memaddr + len was out of bounds.  */\n        info->fprintf_func(info->stream,\n                           \"Address 0x%\" PRIx64 \" is out of bounds.\\n\",\n                           memaddr);\n    }\n}\n\n/* Print address in hex. */\nstatic void print_address(bfd_vma addr, struct disassemble_info *info)\n{\n    info->fprintf_func(info->stream, \"0x%\" PRIx64, addr);\n}\n\n/* Print address in hex, truncated to the width of a host virtual address. */\nstatic void host_print_address(bfd_vma addr, struct disassemble_info *info)\n{\n    print_address((uintptr_t)addr, info);\n}\n\n/* Stub prevents some fruitless earching in optabs disassemblers. */\nstatic int symbol_at_address(bfd_vma addr, struct disassemble_info *info)\n{\n    return 1;\n}\n\nstatic int print_insn_objdump(bfd_vma pc, disassemble_info *info,\n                              const char *prefix)\n{\n    int i, n = info->buffer_length;\n    uint8_t *buf = g_malloc(n);\n\n    info->read_memory_func(pc, buf, n, info);\n\n    for (i = 0; i < n; ++i) {\n        if (i % 32 == 0) {\n            info->fprintf_func(info->stream, \"\\n%s: \", prefix);\n        }\n        info->fprintf_func(info->stream, \"%02x\", buf[i]);\n    }\n\n    g_free(buf);\n    return n;\n}\n\nstatic int print_insn_od_host(bfd_vma pc, disassemble_info *info)\n{\n    return print_insn_objdump(pc, info, \"OBJD-H\");\n}\n\nstatic int print_insn_od_target(bfd_vma pc, disassemble_info *info)\n{\n    return print_insn_objdump(pc, info, \"OBJD-T\");\n}\n\nstatic void initialize_debug(CPUDebug *s)\n{\n    memset(s, 0, sizeof(*s));\n    s->info.arch = bfd_arch_unknown;\n    s->info.cap_arch = -1;\n    s->info.cap_insn_unit = 4;\n    s->info.cap_insn_split = 4;\n    s->info.memory_error_func = perror_memory;\n    s->info.symbol_at_address_func = symbol_at_address;\n}\n\nstatic void initialize_debug_target(CPUDebug *s, CPUState *cpu)\n{\n    initialize_debug(s);\n\n    s->cpu = cpu;\n    s->info.read_memory_func = target_read_memory;\n    s->info.print_address_func = print_address;\n#if TARGET_BIG_ENDIAN\n    s->info.endian = BFD_ENDIAN_BIG;\n#else\n    s->info.endian = BFD_ENDIAN_LITTLE;\n#endif\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    if (cc->disas_set_info) {\n        cc->disas_set_info(cpu, &s->info);\n    }\n}\n\nstatic void initialize_debug_host(CPUDebug *s)\n{\n    initialize_debug(s);\n\n    s->info.read_memory_func = host_read_memory;\n    s->info.print_address_func = host_print_address;\n#if HOST_BIG_ENDIAN\n    s->info.endian = BFD_ENDIAN_BIG;\n#else\n    s->info.endian = BFD_ENDIAN_LITTLE;\n#endif\n#if defined(CONFIG_TCG_INTERPRETER)\n    s->info.print_insn = print_insn_tci;\n#elif defined(__i386__)\n    s->info.mach = bfd_mach_i386_i386;\n    s->info.cap_arch = CS_ARCH_X86;\n    s->info.cap_mode = CS_MODE_32;\n    s->info.cap_insn_unit = 1;\n    s->info.cap_insn_split = 8;\n#elif defined(__x86_64__)\n    s->info.mach = bfd_mach_x86_64;\n    s->info.cap_arch = CS_ARCH_X86;\n    s->info.cap_mode = CS_MODE_64;\n    s->info.cap_insn_unit = 1;\n    s->info.cap_insn_split = 8;\n#elif defined(_ARCH_PPC)\n    s->info.cap_arch = CS_ARCH_PPC;\n# ifdef _ARCH_PPC64\n    s->info.cap_mode = CS_MODE_64;\n# endif\n#elif defined(__riscv) && defined(CONFIG_RISCV_DIS)\n#if defined(_ILP32) || (__riscv_xlen == 32)\n    s->info.print_insn = print_insn_riscv32;\n#elif defined(_LP64)\n    s->info.print_insn = print_insn_riscv64;\n#else\n#error unsupported RISC-V ABI\n#endif\n#elif defined(__aarch64__)\n    s->info.cap_arch = CS_ARCH_ARM64;\n#elif defined(__alpha__)\n    s->info.print_insn = print_insn_alpha;\n#elif defined(__sparc__)\n    s->info.print_insn = print_insn_sparc;\n    s->info.mach = bfd_mach_sparc_v9b;\n#elif defined(__arm__)\n    /* TCG only generates code for arm mode.  */\n    s->info.cap_arch = CS_ARCH_ARM;\n#elif defined(__MIPSEB__)\n    s->info.print_insn = print_insn_big_mips;\n#elif defined(__MIPSEL__)\n    s->info.print_insn = print_insn_little_mips;\n#elif defined(__m68k__)\n    s->info.print_insn = print_insn_m68k;\n#elif defined(__s390__)\n    s->info.cap_arch = CS_ARCH_SYSZ;\n    s->info.cap_insn_unit = 2;\n    s->info.cap_insn_split = 6;\n#elif defined(__hppa__)\n    s->info.print_insn = print_insn_hppa;\n#endif\n}\n\n/* Disassemble this for me please... (debugging).  */\nvoid target_disas(FILE *out, CPUState *cpu, target_ulong code,\n                  target_ulong size)\n{\n    target_ulong pc;\n    int count;\n    CPUDebug s;\n\n    initialize_debug_target(&s, cpu);\n    s.info.fprintf_func = fprintf;\n    s.info.stream = out;\n    s.info.buffer_vma = code;\n    s.info.buffer_length = size;\n\n    if (s.info.cap_arch >= 0 && cap_disas_target(&s.info, code, size)) {\n        return;\n    }\n\n    if (s.info.print_insn == NULL) {\n        s.info.print_insn = print_insn_od_target;\n    }\n\n    for (pc = code; size > 0; pc += count, size -= count) {\n\tfprintf(out, \"0x\" TARGET_FMT_lx \":  \", pc);\n\tcount = s.info.print_insn(pc, &s.info);\n\tfprintf(out, \"\\n\");\n\tif (count < 0)\n\t    break;\n        if (size < count) {\n            fprintf(out,\n                    \"Disassembler disagrees with translator over instruction \"\n                    \"decoding\\n\"\n                    \"Please report this to qemu-devel@nongnu.org\\n\");\n            break;\n        }\n    }\n}\n\nstatic int plugin_printf(FILE *stream, const char *fmt, ...)\n{\n    /* We abuse the FILE parameter to pass a GString. */\n    GString *s = (GString *)stream;\n    int initial_len = s->len;\n    va_list va;\n\n    va_start(va, fmt);\n    g_string_append_vprintf(s, fmt, va);\n    va_end(va);\n\n    return s->len - initial_len;\n}\n\nstatic void plugin_print_address(bfd_vma addr, struct disassemble_info *info)\n{\n    /* does nothing */\n}\n\n\n/*\n * We should only be dissembling one instruction at a time here. If\n * there is left over it usually indicates the front end has read more\n * bytes than it needed.\n */\nchar *plugin_disas(CPUState *cpu, uint64_t addr, size_t size)\n{\n    CPUDebug s;\n    GString *ds = g_string_new(NULL);\n\n    initialize_debug_target(&s, cpu);\n    s.info.fprintf_func = plugin_printf;\n    s.info.stream = (FILE *)ds;  /* abuse this slot */\n    s.info.buffer_vma = addr;\n    s.info.buffer_length = size;\n    s.info.print_address_func = plugin_print_address;\n\n    if (s.info.cap_arch >= 0 && cap_disas_plugin(&s.info, addr, size)) {\n        ; /* done */\n    } else if (s.info.print_insn) {\n        s.info.print_insn(addr, &s.info);\n    } else {\n        ; /* cannot disassemble -- return empty string */\n    }\n\n    /* Return the buffer, freeing the GString container.  */\n    return g_string_free(ds, false);\n}\n\n/* Disassemble this for me please... (debugging). */\nvoid disas(FILE *out, const void *code, unsigned long size)\n{\n    uintptr_t pc;\n    int count;\n    CPUDebug s;\n\n    initialize_debug_host(&s);\n    s.info.fprintf_func = fprintf;\n    s.info.stream = out;\n    s.info.buffer = code;\n    s.info.buffer_vma = (uintptr_t)code;\n    s.info.buffer_length = size;\n\n    if (s.info.cap_arch >= 0 && cap_disas_host(&s.info, code, size)) {\n        return;\n    }\n\n    if (s.info.print_insn == NULL) {\n        s.info.print_insn = print_insn_od_host;\n    }\n    for (pc = (uintptr_t)code; size > 0; pc += count, size -= count) {\n        fprintf(out, \"0x%08\" PRIxPTR \":  \", pc);\n        count = s.info.print_insn(pc, &s.info);\n        fprintf(out, \"\\n\");\n        if (count < 0) {\n            break;\n        }\n    }\n\n}\n\n/* Look up symbol for debugging purpose.  Returns \"\" if unknown. */\nconst char *lookup_symbol(target_ulong orig_addr)\n{\n    const char *symbol = \"\";\n    struct syminfo *s;\n\n    for (s = syminfos; s; s = s->next) {\n        symbol = s->lookup_symbol(s, orig_addr);\n        if (symbol[0] != '\\0') {\n            break;\n        }\n    }\n\n    return symbol;\n}\n\n#if !defined(CONFIG_USER_ONLY)\n\n#include \"monitor/monitor.h\"\n\nstatic int\nphysical_read_memory(bfd_vma memaddr, bfd_byte *myaddr, int length,\n                     struct disassemble_info *info)\n{\n    CPUDebug *s = container_of(info, CPUDebug, info);\n    MemTxResult res;\n\n    res = address_space_read(s->cpu->as, memaddr, MEMTXATTRS_UNSPECIFIED,\n                             myaddr, length);\n    return res == MEMTX_OK ? 0 : EIO;\n}\n\n/* Disassembler for the monitor.  */\nvoid monitor_disas(Monitor *mon, CPUState *cpu,\n                   target_ulong pc, int nb_insn, int is_physical)\n{\n    int count, i;\n    CPUDebug s;\n\n    initialize_debug_target(&s, cpu);\n    s.info.fprintf_func = qemu_fprintf;\n    if (is_physical) {\n        s.info.read_memory_func = physical_read_memory;\n    }\n    s.info.buffer_vma = pc;\n\n    if (s.info.cap_arch >= 0 && cap_disas_monitor(&s.info, pc, nb_insn)) {\n        return;\n    }\n\n    if (!s.info.print_insn) {\n        monitor_printf(mon, \"0x\" TARGET_FMT_lx\n                       \": Asm output not supported on this arch\\n\", pc);\n        return;\n    }\n\n    for(i = 0; i < nb_insn; i++) {\n\tmonitor_printf(mon, \"0x\" TARGET_FMT_lx \":  \", pc);\n        count = s.info.print_insn(pc, &s.info);\n\tmonitor_printf(mon, \"\\n\");\n\tif (count < 0)\n\t    break;\n        pc += count;\n    }\n}\n#endif\n"
        },
        {
          "name": "disas",
          "type": "tree",
          "content": null
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "dtc",
          "type": "commit",
          "content": null
        },
        {
          "name": "dump",
          "type": "tree",
          "content": null
        },
        {
          "name": "ebpf",
          "type": "tree",
          "content": null
        },
        {
          "name": "event-loop-base.c",
          "type": "blob",
          "size": 4.0400390625,
          "content": "/*\n * QEMU event-loop base\n *\n * Copyright (C) 2022 Red Hat Inc\n *\n * Authors:\n *  Stefan Hajnoczi <stefanha@redhat.com>\n *  Nicolas Saenz Julienne <nsaenzju@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qom/object_interfaces.h\"\n#include \"qapi/error.h\"\n#include \"block/thread-pool.h\"\n#include \"sysemu/event-loop-base.h\"\n\ntypedef struct {\n    const char *name;\n    ptrdiff_t offset; /* field's byte offset in EventLoopBase struct */\n} EventLoopBaseParamInfo;\n\nstatic void event_loop_base_instance_init(Object *obj)\n{\n    EventLoopBase *base = EVENT_LOOP_BASE(obj);\n\n    base->thread_pool_max = THREAD_POOL_MAX_THREADS_DEFAULT;\n}\n\nstatic EventLoopBaseParamInfo aio_max_batch_info = {\n    \"aio-max-batch\", offsetof(EventLoopBase, aio_max_batch),\n};\nstatic EventLoopBaseParamInfo thread_pool_min_info = {\n    \"thread-pool-min\", offsetof(EventLoopBase, thread_pool_min),\n};\nstatic EventLoopBaseParamInfo thread_pool_max_info = {\n    \"thread-pool-max\", offsetof(EventLoopBase, thread_pool_max),\n};\n\nstatic void event_loop_base_get_param(Object *obj, Visitor *v,\n        const char *name, void *opaque, Error **errp)\n{\n    EventLoopBase *event_loop_base = EVENT_LOOP_BASE(obj);\n    EventLoopBaseParamInfo *info = opaque;\n    int64_t *field = (void *)event_loop_base + info->offset;\n\n    visit_type_int64(v, name, field, errp);\n}\n\nstatic void event_loop_base_set_param(Object *obj, Visitor *v,\n        const char *name, void *opaque, Error **errp)\n{\n    EventLoopBaseClass *bc = EVENT_LOOP_BASE_GET_CLASS(obj);\n    EventLoopBase *base = EVENT_LOOP_BASE(obj);\n    EventLoopBaseParamInfo *info = opaque;\n    int64_t *field = (void *)base + info->offset;\n    int64_t value;\n\n    if (!visit_type_int64(v, name, &value, errp)) {\n        return;\n    }\n\n    if (value < 0) {\n        error_setg(errp, \"%s value must be in range [0, %\" PRId64 \"]\",\n                   info->name, INT64_MAX);\n        return;\n    }\n\n    *field = value;\n\n    if (bc->update_params) {\n        bc->update_params(base, errp);\n    }\n\n    return;\n}\n\nstatic void event_loop_base_complete(UserCreatable *uc, Error **errp)\n{\n    EventLoopBaseClass *bc = EVENT_LOOP_BASE_GET_CLASS(uc);\n    EventLoopBase *base = EVENT_LOOP_BASE(uc);\n\n    if (bc->init) {\n        bc->init(base, errp);\n    }\n}\n\nstatic bool event_loop_base_can_be_deleted(UserCreatable *uc)\n{\n    EventLoopBaseClass *bc = EVENT_LOOP_BASE_GET_CLASS(uc);\n    EventLoopBase *backend = EVENT_LOOP_BASE(uc);\n\n    if (bc->can_be_deleted) {\n        return bc->can_be_deleted(backend);\n    }\n\n    return true;\n}\n\nstatic void event_loop_base_class_init(ObjectClass *klass, void *class_data)\n{\n    UserCreatableClass *ucc = USER_CREATABLE_CLASS(klass);\n    ucc->complete = event_loop_base_complete;\n    ucc->can_be_deleted = event_loop_base_can_be_deleted;\n\n    object_class_property_add(klass, \"aio-max-batch\", \"int\",\n                              event_loop_base_get_param,\n                              event_loop_base_set_param,\n                              NULL, &aio_max_batch_info);\n    object_class_property_add(klass, \"thread-pool-min\", \"int\",\n                              event_loop_base_get_param,\n                              event_loop_base_set_param,\n                              NULL, &thread_pool_min_info);\n    object_class_property_add(klass, \"thread-pool-max\", \"int\",\n                              event_loop_base_get_param,\n                              event_loop_base_set_param,\n                              NULL, &thread_pool_max_info);\n}\n\nstatic const TypeInfo event_loop_base_info = {\n    .name = TYPE_EVENT_LOOP_BASE,\n    .parent = TYPE_OBJECT,\n    .instance_size = sizeof(EventLoopBase),\n    .instance_init = event_loop_base_instance_init,\n    .class_size = sizeof(EventLoopBaseClass),\n    .class_init = event_loop_base_class_init,\n    .abstract = true,\n    .interfaces = (InterfaceInfo[]) {\n        { TYPE_USER_CREATABLE },\n        { }\n    }\n};\n\nstatic void register_types(void)\n{\n    type_register_static(&event_loop_base_info);\n}\ntype_init(register_types);\n"
        },
        {
          "name": "fpu",
          "type": "tree",
          "content": null
        },
        {
          "name": "fsdev",
          "type": "tree",
          "content": null
        },
        {
          "name": "gdb-xml",
          "type": "tree",
          "content": null
        },
        {
          "name": "gdbstub.c",
          "type": "blob",
          "size": 92.697265625,
          "content": "/*\n * gdb server stub\n *\n * This implements a subset of the remote protocol as described in:\n *\n *   https://sourceware.org/gdb/onlinedocs/gdb/Remote-Protocol.html\n *\n * Copyright (c) 2003-2005 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n *\n * SPDX-License-Identifier: LGPL-2.0+\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/ctype.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/module.h\"\n#include \"trace/trace-root.h\"\n#include \"exec/gdbstub.h\"\n#ifdef CONFIG_USER_ONLY\n#include \"qemu.h\"\n#else\n#include \"monitor/monitor.h\"\n#include \"chardev/char.h\"\n#include \"chardev/char-fe.h\"\n#include \"hw/cpu/cluster.h\"\n#include \"hw/boards.h\"\n#endif\n\n#define MAX_PACKET_LENGTH 4096\n\n#include \"qemu/sockets.h\"\n#include \"sysemu/hw_accel.h\"\n#include \"sysemu/kvm.h\"\n#include \"sysemu/runstate.h\"\n#include \"semihosting/semihost.h\"\n#include \"exec/exec-all.h\"\n#include \"sysemu/replay.h\"\n\n#ifdef CONFIG_USER_ONLY\n#define GDB_ATTACHED \"0\"\n#else\n#define GDB_ATTACHED \"1\"\n#endif\n\n#ifndef CONFIG_USER_ONLY\nstatic int phy_memory_mode;\n#endif\n\nstatic inline int target_memory_rw_debug(CPUState *cpu, target_ulong addr,\n                                         uint8_t *buf, int len, bool is_write)\n{\n    CPUClass *cc;\n\n#ifndef CONFIG_USER_ONLY\n    if (phy_memory_mode) {\n        if (is_write) {\n            cpu_physical_memory_write(addr, buf, len);\n        } else {\n            cpu_physical_memory_read(addr, buf, len);\n        }\n        return 0;\n    }\n#endif\n\n    cc = CPU_GET_CLASS(cpu);\n    if (cc->memory_rw_debug) {\n        return cc->memory_rw_debug(cpu, addr, buf, len, is_write);\n    }\n    return cpu_memory_rw_debug(cpu, addr, buf, len, is_write);\n}\n\n/* Return the GDB index for a given vCPU state.\n *\n * For user mode this is simply the thread id. In system mode GDB\n * numbers CPUs from 1 as 0 is reserved as an \"any cpu\" index.\n */\nstatic inline int cpu_gdb_index(CPUState *cpu)\n{\n#if defined(CONFIG_USER_ONLY)\n    TaskState *ts = (TaskState *) cpu->opaque;\n    return ts ? ts->ts_tid : -1;\n#else\n    return cpu->cpu_index + 1;\n#endif\n}\n\nenum {\n    GDB_SIGNAL_0 = 0,\n    GDB_SIGNAL_INT = 2,\n    GDB_SIGNAL_QUIT = 3,\n    GDB_SIGNAL_TRAP = 5,\n    GDB_SIGNAL_ABRT = 6,\n    GDB_SIGNAL_ALRM = 14,\n    GDB_SIGNAL_IO = 23,\n    GDB_SIGNAL_XCPU = 24,\n    GDB_SIGNAL_UNKNOWN = 143\n};\n\n#ifdef CONFIG_USER_ONLY\n\n/* Map target signal numbers to GDB protocol signal numbers and vice\n * versa.  For user emulation's currently supported systems, we can\n * assume most signals are defined.\n */\n\nstatic int gdb_signal_table[] = {\n    0,\n    TARGET_SIGHUP,\n    TARGET_SIGINT,\n    TARGET_SIGQUIT,\n    TARGET_SIGILL,\n    TARGET_SIGTRAP,\n    TARGET_SIGABRT,\n    -1, /* SIGEMT */\n    TARGET_SIGFPE,\n    TARGET_SIGKILL,\n    TARGET_SIGBUS,\n    TARGET_SIGSEGV,\n    TARGET_SIGSYS,\n    TARGET_SIGPIPE,\n    TARGET_SIGALRM,\n    TARGET_SIGTERM,\n    TARGET_SIGURG,\n    TARGET_SIGSTOP,\n    TARGET_SIGTSTP,\n    TARGET_SIGCONT,\n    TARGET_SIGCHLD,\n    TARGET_SIGTTIN,\n    TARGET_SIGTTOU,\n    TARGET_SIGIO,\n    TARGET_SIGXCPU,\n    TARGET_SIGXFSZ,\n    TARGET_SIGVTALRM,\n    TARGET_SIGPROF,\n    TARGET_SIGWINCH,\n    -1, /* SIGLOST */\n    TARGET_SIGUSR1,\n    TARGET_SIGUSR2,\n#ifdef TARGET_SIGPWR\n    TARGET_SIGPWR,\n#else\n    -1,\n#endif\n    -1, /* SIGPOLL */\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n#ifdef __SIGRTMIN\n    __SIGRTMIN + 1,\n    __SIGRTMIN + 2,\n    __SIGRTMIN + 3,\n    __SIGRTMIN + 4,\n    __SIGRTMIN + 5,\n    __SIGRTMIN + 6,\n    __SIGRTMIN + 7,\n    __SIGRTMIN + 8,\n    __SIGRTMIN + 9,\n    __SIGRTMIN + 10,\n    __SIGRTMIN + 11,\n    __SIGRTMIN + 12,\n    __SIGRTMIN + 13,\n    __SIGRTMIN + 14,\n    __SIGRTMIN + 15,\n    __SIGRTMIN + 16,\n    __SIGRTMIN + 17,\n    __SIGRTMIN + 18,\n    __SIGRTMIN + 19,\n    __SIGRTMIN + 20,\n    __SIGRTMIN + 21,\n    __SIGRTMIN + 22,\n    __SIGRTMIN + 23,\n    __SIGRTMIN + 24,\n    __SIGRTMIN + 25,\n    __SIGRTMIN + 26,\n    __SIGRTMIN + 27,\n    __SIGRTMIN + 28,\n    __SIGRTMIN + 29,\n    __SIGRTMIN + 30,\n    __SIGRTMIN + 31,\n    -1, /* SIGCANCEL */\n    __SIGRTMIN,\n    __SIGRTMIN + 32,\n    __SIGRTMIN + 33,\n    __SIGRTMIN + 34,\n    __SIGRTMIN + 35,\n    __SIGRTMIN + 36,\n    __SIGRTMIN + 37,\n    __SIGRTMIN + 38,\n    __SIGRTMIN + 39,\n    __SIGRTMIN + 40,\n    __SIGRTMIN + 41,\n    __SIGRTMIN + 42,\n    __SIGRTMIN + 43,\n    __SIGRTMIN + 44,\n    __SIGRTMIN + 45,\n    __SIGRTMIN + 46,\n    __SIGRTMIN + 47,\n    __SIGRTMIN + 48,\n    __SIGRTMIN + 49,\n    __SIGRTMIN + 50,\n    __SIGRTMIN + 51,\n    __SIGRTMIN + 52,\n    __SIGRTMIN + 53,\n    __SIGRTMIN + 54,\n    __SIGRTMIN + 55,\n    __SIGRTMIN + 56,\n    __SIGRTMIN + 57,\n    __SIGRTMIN + 58,\n    __SIGRTMIN + 59,\n    __SIGRTMIN + 60,\n    __SIGRTMIN + 61,\n    __SIGRTMIN + 62,\n    __SIGRTMIN + 63,\n    __SIGRTMIN + 64,\n    __SIGRTMIN + 65,\n    __SIGRTMIN + 66,\n    __SIGRTMIN + 67,\n    __SIGRTMIN + 68,\n    __SIGRTMIN + 69,\n    __SIGRTMIN + 70,\n    __SIGRTMIN + 71,\n    __SIGRTMIN + 72,\n    __SIGRTMIN + 73,\n    __SIGRTMIN + 74,\n    __SIGRTMIN + 75,\n    __SIGRTMIN + 76,\n    __SIGRTMIN + 77,\n    __SIGRTMIN + 78,\n    __SIGRTMIN + 79,\n    __SIGRTMIN + 80,\n    __SIGRTMIN + 81,\n    __SIGRTMIN + 82,\n    __SIGRTMIN + 83,\n    __SIGRTMIN + 84,\n    __SIGRTMIN + 85,\n    __SIGRTMIN + 86,\n    __SIGRTMIN + 87,\n    __SIGRTMIN + 88,\n    __SIGRTMIN + 89,\n    __SIGRTMIN + 90,\n    __SIGRTMIN + 91,\n    __SIGRTMIN + 92,\n    __SIGRTMIN + 93,\n    __SIGRTMIN + 94,\n    __SIGRTMIN + 95,\n    -1, /* SIGINFO */\n    -1, /* UNKNOWN */\n    -1, /* DEFAULT */\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1\n#endif\n};\n#else\n/* In system mode we only need SIGINT and SIGTRAP; other signals\n   are not yet supported.  */\n\nenum {\n    TARGET_SIGINT = 2,\n    TARGET_SIGTRAP = 5\n};\n\nstatic int gdb_signal_table[] = {\n    -1,\n    -1,\n    TARGET_SIGINT,\n    -1,\n    -1,\n    TARGET_SIGTRAP\n};\n#endif\n\n#ifdef CONFIG_USER_ONLY\nstatic int target_signal_to_gdb (int sig)\n{\n    int i;\n    for (i = 0; i < ARRAY_SIZE (gdb_signal_table); i++)\n        if (gdb_signal_table[i] == sig)\n            return i;\n    return GDB_SIGNAL_UNKNOWN;\n}\n#endif\n\nstatic int gdb_signal_to_target (int sig)\n{\n    if (sig < ARRAY_SIZE (gdb_signal_table))\n        return gdb_signal_table[sig];\n    else\n        return -1;\n}\n\ntypedef struct GDBRegisterState {\n    int base_reg;\n    int num_regs;\n    gdb_get_reg_cb get_reg;\n    gdb_set_reg_cb set_reg;\n    const char *xml;\n    struct GDBRegisterState *next;\n} GDBRegisterState;\n\ntypedef struct GDBProcess {\n    uint32_t pid;\n    bool attached;\n\n    char target_xml[1024];\n} GDBProcess;\n\nenum RSState {\n    RS_INACTIVE,\n    RS_IDLE,\n    RS_GETLINE,\n    RS_GETLINE_ESC,\n    RS_GETLINE_RLE,\n    RS_CHKSUM1,\n    RS_CHKSUM2,\n};\ntypedef struct GDBState {\n    bool init;       /* have we been initialised? */\n    CPUState *c_cpu; /* current CPU for step/continue ops */\n    CPUState *g_cpu; /* current CPU for other ops */\n    CPUState *query_cpu; /* for q{f|s}ThreadInfo */\n    enum RSState state; /* parsing state */\n    char line_buf[MAX_PACKET_LENGTH];\n    int line_buf_index;\n    int line_sum; /* running checksum */\n    int line_csum; /* checksum at the end of the packet */\n    GByteArray *last_packet;\n    int signal;\n#ifdef CONFIG_USER_ONLY\n    int fd;\n    char *socket_path;\n    int running_state;\n#else\n    CharBackend chr;\n    Chardev *mon_chr;\n#endif\n    bool multiprocess;\n    GDBProcess *processes;\n    int process_num;\n    char syscall_buf[256];\n    gdb_syscall_complete_cb current_syscall_cb;\n    GString *str_buf;\n    GByteArray *mem_buf;\n    int sstep_flags;\n    int supported_sstep_flags;\n} GDBState;\n\nstatic GDBState gdbserver_state;\n\nstatic void init_gdbserver_state(void)\n{\n    g_assert(!gdbserver_state.init);\n    memset(&gdbserver_state, 0, sizeof(GDBState));\n    gdbserver_state.init = true;\n    gdbserver_state.str_buf = g_string_new(NULL);\n    gdbserver_state.mem_buf = g_byte_array_sized_new(MAX_PACKET_LENGTH);\n    gdbserver_state.last_packet = g_byte_array_sized_new(MAX_PACKET_LENGTH + 4);\n\n    /*\n     * In replay mode all events will come from the log and can't be\n     * suppressed otherwise we would break determinism. However as those\n     * events are tied to the number of executed instructions we won't see\n     * them occurring every time we single step.\n     */\n    if (replay_mode != REPLAY_MODE_NONE) {\n        gdbserver_state.supported_sstep_flags = SSTEP_ENABLE;\n    } else if (kvm_enabled()) {\n        gdbserver_state.supported_sstep_flags = kvm_get_supported_sstep_flags();\n    } else {\n        gdbserver_state.supported_sstep_flags =\n            SSTEP_ENABLE | SSTEP_NOIRQ | SSTEP_NOTIMER;\n    }\n\n    /*\n     * By default use no IRQs and no timers while single stepping so as to\n     * make single stepping like an ICE HW step.\n     */\n    gdbserver_state.sstep_flags = SSTEP_ENABLE | SSTEP_NOIRQ | SSTEP_NOTIMER;\n    gdbserver_state.sstep_flags &= gdbserver_state.supported_sstep_flags;\n\n}\n\n#ifndef CONFIG_USER_ONLY\nstatic void reset_gdbserver_state(void)\n{\n    g_free(gdbserver_state.processes);\n    gdbserver_state.processes = NULL;\n    gdbserver_state.process_num = 0;\n}\n#endif\n\nbool gdb_has_xml;\n\n#ifdef CONFIG_USER_ONLY\n\nstatic int get_char(void)\n{\n    uint8_t ch;\n    int ret;\n\n    for(;;) {\n        ret = recv(gdbserver_state.fd, &ch, 1, 0);\n        if (ret < 0) {\n            if (errno == ECONNRESET)\n                gdbserver_state.fd = -1;\n            if (errno != EINTR)\n                return -1;\n        } else if (ret == 0) {\n            close(gdbserver_state.fd);\n            gdbserver_state.fd = -1;\n            return -1;\n        } else {\n            break;\n        }\n    }\n    return ch;\n}\n#endif\n\n/*\n * Return true if there is a GDB currently connected to the stub\n * and attached to a CPU\n */\nstatic bool gdb_attached(void)\n{\n    return gdbserver_state.init && gdbserver_state.c_cpu;\n}\n\nstatic enum {\n    GDB_SYS_UNKNOWN,\n    GDB_SYS_ENABLED,\n    GDB_SYS_DISABLED,\n} gdb_syscall_mode;\n\n/* Decide if either remote gdb syscalls or native file IO should be used. */\nint use_gdb_syscalls(void)\n{\n    SemihostingTarget target = semihosting_get_target();\n    if (target == SEMIHOSTING_TARGET_NATIVE) {\n        /* -semihosting-config target=native */\n        return false;\n    } else if (target == SEMIHOSTING_TARGET_GDB) {\n        /* -semihosting-config target=gdb */\n        return true;\n    }\n\n    /* -semihosting-config target=auto */\n    /* On the first call check if gdb is connected and remember. */\n    if (gdb_syscall_mode == GDB_SYS_UNKNOWN) {\n        gdb_syscall_mode = gdb_attached() ? GDB_SYS_ENABLED : GDB_SYS_DISABLED;\n    }\n    return gdb_syscall_mode == GDB_SYS_ENABLED;\n}\n\nstatic bool stub_can_reverse(void)\n{\n#ifdef CONFIG_USER_ONLY\n    return false;\n#else\n    return replay_mode == REPLAY_MODE_PLAY;\n#endif\n}\n\n/* Resume execution.  */\nstatic inline void gdb_continue(void)\n{\n\n#ifdef CONFIG_USER_ONLY\n    gdbserver_state.running_state = 1;\n    trace_gdbstub_op_continue();\n#else\n    if (!runstate_needs_reset()) {\n        trace_gdbstub_op_continue();\n        vm_start();\n    }\n#endif\n}\n\n/*\n * Resume execution, per CPU actions. For user-mode emulation it's\n * equivalent to gdb_continue.\n */\nstatic int gdb_continue_partial(char *newstates)\n{\n    CPUState *cpu;\n    int res = 0;\n#ifdef CONFIG_USER_ONLY\n    /*\n     * This is not exactly accurate, but it's an improvement compared to the\n     * previous situation, where only one CPU would be single-stepped.\n     */\n    CPU_FOREACH(cpu) {\n        if (newstates[cpu->cpu_index] == 's') {\n            trace_gdbstub_op_stepping(cpu->cpu_index);\n            cpu_single_step(cpu, gdbserver_state.sstep_flags);\n        }\n    }\n    gdbserver_state.running_state = 1;\n#else\n    int flag = 0;\n\n    if (!runstate_needs_reset()) {\n        bool step_requested = false;\n        CPU_FOREACH(cpu) {\n            if (newstates[cpu->cpu_index] == 's') {\n                step_requested = true;\n                break;\n            }\n        }\n\n        if (vm_prepare_start(step_requested)) {\n            return 0;\n        }\n\n        CPU_FOREACH(cpu) {\n            switch (newstates[cpu->cpu_index]) {\n            case 0:\n            case 1:\n                break; /* nothing to do here */\n            case 's':\n                trace_gdbstub_op_stepping(cpu->cpu_index);\n                cpu_single_step(cpu, gdbserver_state.sstep_flags);\n                cpu_resume(cpu);\n                flag = 1;\n                break;\n            case 'c':\n                trace_gdbstub_op_continue_cpu(cpu->cpu_index);\n                cpu_resume(cpu);\n                flag = 1;\n                break;\n            default:\n                res = -1;\n                break;\n            }\n        }\n    }\n    if (flag) {\n        qemu_clock_enable(QEMU_CLOCK_VIRTUAL, true);\n    }\n#endif\n    return res;\n}\n\nstatic void put_buffer(const uint8_t *buf, int len)\n{\n#ifdef CONFIG_USER_ONLY\n    int ret;\n\n    while (len > 0) {\n        ret = send(gdbserver_state.fd, buf, len, 0);\n        if (ret < 0) {\n            if (errno != EINTR)\n                return;\n        } else {\n            buf += ret;\n            len -= ret;\n        }\n    }\n#else\n    /* XXX this blocks entire thread. Rewrite to use\n     * qemu_chr_fe_write and background I/O callbacks */\n    qemu_chr_fe_write_all(&gdbserver_state.chr, buf, len);\n#endif\n}\n\nstatic inline int fromhex(int v)\n{\n    if (v >= '0' && v <= '9')\n        return v - '0';\n    else if (v >= 'A' && v <= 'F')\n        return v - 'A' + 10;\n    else if (v >= 'a' && v <= 'f')\n        return v - 'a' + 10;\n    else\n        return 0;\n}\n\nstatic inline int tohex(int v)\n{\n    if (v < 10)\n        return v + '0';\n    else\n        return v - 10 + 'a';\n}\n\n/* writes 2*len+1 bytes in buf */\nstatic void memtohex(GString *buf, const uint8_t *mem, int len)\n{\n    int i, c;\n    for(i = 0; i < len; i++) {\n        c = mem[i];\n        g_string_append_c(buf, tohex(c >> 4));\n        g_string_append_c(buf, tohex(c & 0xf));\n    }\n    g_string_append_c(buf, '\\0');\n}\n\nstatic void hextomem(GByteArray *mem, const char *buf, int len)\n{\n    int i;\n\n    for(i = 0; i < len; i++) {\n        guint8 byte = fromhex(buf[0]) << 4 | fromhex(buf[1]);\n        g_byte_array_append(mem, &byte, 1);\n        buf += 2;\n    }\n}\n\nstatic void hexdump(const char *buf, int len,\n                    void (*trace_fn)(size_t ofs, char const *text))\n{\n    char line_buffer[3 * 16 + 4 + 16 + 1];\n\n    size_t i;\n    for (i = 0; i < len || (i & 0xF); ++i) {\n        size_t byte_ofs = i & 15;\n\n        if (byte_ofs == 0) {\n            memset(line_buffer, ' ', 3 * 16 + 4 + 16);\n            line_buffer[3 * 16 + 4 + 16] = 0;\n        }\n\n        size_t col_group = (i >> 2) & 3;\n        size_t hex_col = byte_ofs * 3 + col_group;\n        size_t txt_col = 3 * 16 + 4 + byte_ofs;\n\n        if (i < len) {\n            char value = buf[i];\n\n            line_buffer[hex_col + 0] = tohex((value >> 4) & 0xF);\n            line_buffer[hex_col + 1] = tohex((value >> 0) & 0xF);\n            line_buffer[txt_col + 0] = (value >= ' ' && value < 127)\n                    ? value\n                    : '.';\n        }\n\n        if (byte_ofs == 0xF)\n            trace_fn(i & -16, line_buffer);\n    }\n}\n\n/* return -1 if error, 0 if OK */\nstatic int put_packet_binary(const char *buf, int len, bool dump)\n{\n    int csum, i;\n    uint8_t footer[3];\n\n    if (dump && trace_event_get_state_backends(TRACE_GDBSTUB_IO_BINARYREPLY)) {\n        hexdump(buf, len, trace_gdbstub_io_binaryreply);\n    }\n\n    for(;;) {\n        g_byte_array_set_size(gdbserver_state.last_packet, 0);\n        g_byte_array_append(gdbserver_state.last_packet,\n                            (const uint8_t *) \"$\", 1);\n        g_byte_array_append(gdbserver_state.last_packet,\n                            (const uint8_t *) buf, len);\n        csum = 0;\n        for(i = 0; i < len; i++) {\n            csum += buf[i];\n        }\n        footer[0] = '#';\n        footer[1] = tohex((csum >> 4) & 0xf);\n        footer[2] = tohex((csum) & 0xf);\n        g_byte_array_append(gdbserver_state.last_packet, footer, 3);\n\n        put_buffer(gdbserver_state.last_packet->data,\n                   gdbserver_state.last_packet->len);\n\n#ifdef CONFIG_USER_ONLY\n        i = get_char();\n        if (i < 0)\n            return -1;\n        if (i == '+')\n            break;\n#else\n        break;\n#endif\n    }\n    return 0;\n}\n\n/* return -1 if error, 0 if OK */\nstatic int put_packet(const char *buf)\n{\n    trace_gdbstub_io_reply(buf);\n\n    return put_packet_binary(buf, strlen(buf), false);\n}\n\nstatic void put_strbuf(void)\n{\n    put_packet(gdbserver_state.str_buf->str);\n}\n\n/* Encode data using the encoding for 'x' packets.  */\nstatic void memtox(GString *buf, const char *mem, int len)\n{\n    char c;\n\n    while (len--) {\n        c = *(mem++);\n        switch (c) {\n        case '#': case '$': case '*': case '}':\n            g_string_append_c(buf, '}');\n            g_string_append_c(buf, c ^ 0x20);\n            break;\n        default:\n            g_string_append_c(buf, c);\n            break;\n        }\n    }\n}\n\nstatic uint32_t gdb_get_cpu_pid(CPUState *cpu)\n{\n    /* TODO: In user mode, we should use the task state PID */\n    if (cpu->cluster_index == UNASSIGNED_CLUSTER_INDEX) {\n        /* Return the default process' PID */\n        int index = gdbserver_state.process_num - 1;\n        return gdbserver_state.processes[index].pid;\n    }\n    return cpu->cluster_index + 1;\n}\n\nstatic GDBProcess *gdb_get_process(uint32_t pid)\n{\n    int i;\n\n    if (!pid) {\n        /* 0 means any process, we take the first one */\n        return &gdbserver_state.processes[0];\n    }\n\n    for (i = 0; i < gdbserver_state.process_num; i++) {\n        if (gdbserver_state.processes[i].pid == pid) {\n            return &gdbserver_state.processes[i];\n        }\n    }\n\n    return NULL;\n}\n\nstatic GDBProcess *gdb_get_cpu_process(CPUState *cpu)\n{\n    return gdb_get_process(gdb_get_cpu_pid(cpu));\n}\n\nstatic CPUState *find_cpu(uint32_t thread_id)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (cpu_gdb_index(cpu) == thread_id) {\n            return cpu;\n        }\n    }\n\n    return NULL;\n}\n\nstatic CPUState *get_first_cpu_in_process(GDBProcess *process)\n{\n    CPUState *cpu;\n\n    CPU_FOREACH(cpu) {\n        if (gdb_get_cpu_pid(cpu) == process->pid) {\n            return cpu;\n        }\n    }\n\n    return NULL;\n}\n\nstatic CPUState *gdb_next_cpu_in_process(CPUState *cpu)\n{\n    uint32_t pid = gdb_get_cpu_pid(cpu);\n    cpu = CPU_NEXT(cpu);\n\n    while (cpu) {\n        if (gdb_get_cpu_pid(cpu) == pid) {\n            break;\n        }\n\n        cpu = CPU_NEXT(cpu);\n    }\n\n    return cpu;\n}\n\n/* Return the cpu following @cpu, while ignoring unattached processes. */\nstatic CPUState *gdb_next_attached_cpu(CPUState *cpu)\n{\n    cpu = CPU_NEXT(cpu);\n\n    while (cpu) {\n        if (gdb_get_cpu_process(cpu)->attached) {\n            break;\n        }\n\n        cpu = CPU_NEXT(cpu);\n    }\n\n    return cpu;\n}\n\n/* Return the first attached cpu */\nstatic CPUState *gdb_first_attached_cpu(void)\n{\n    CPUState *cpu = first_cpu;\n    GDBProcess *process = gdb_get_cpu_process(cpu);\n\n    if (!process->attached) {\n        return gdb_next_attached_cpu(cpu);\n    }\n\n    return cpu;\n}\n\nstatic CPUState *gdb_get_cpu(uint32_t pid, uint32_t tid)\n{\n    GDBProcess *process;\n    CPUState *cpu;\n\n    if (!pid && !tid) {\n        /* 0 means any process/thread, we take the first attached one */\n        return gdb_first_attached_cpu();\n    } else if (pid && !tid) {\n        /* any thread in a specific process */\n        process = gdb_get_process(pid);\n\n        if (process == NULL) {\n            return NULL;\n        }\n\n        if (!process->attached) {\n            return NULL;\n        }\n\n        return get_first_cpu_in_process(process);\n    } else {\n        /* a specific thread */\n        cpu = find_cpu(tid);\n\n        if (cpu == NULL) {\n            return NULL;\n        }\n\n        process = gdb_get_cpu_process(cpu);\n\n        if (pid && process->pid != pid) {\n            return NULL;\n        }\n\n        if (!process->attached) {\n            return NULL;\n        }\n\n        return cpu;\n    }\n}\n\nstatic const char *get_feature_xml(const char *p, const char **newp,\n                                   GDBProcess *process)\n{\n    size_t len;\n    int i;\n    const char *name;\n    CPUState *cpu = get_first_cpu_in_process(process);\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    len = 0;\n    while (p[len] && p[len] != ':')\n        len++;\n    *newp = p + len;\n\n    name = NULL;\n    if (strncmp(p, \"target.xml\", len) == 0) {\n        char *buf = process->target_xml;\n        const size_t buf_sz = sizeof(process->target_xml);\n\n        /* Generate the XML description for this CPU.  */\n        if (!buf[0]) {\n            GDBRegisterState *r;\n\n            pstrcat(buf, buf_sz,\n                    \"<?xml version=\\\"1.0\\\"?>\"\n                    \"<!DOCTYPE target SYSTEM \\\"gdb-target.dtd\\\">\"\n                    \"<target>\");\n            if (cc->gdb_arch_name) {\n                gchar *arch = cc->gdb_arch_name(cpu);\n                pstrcat(buf, buf_sz, \"<architecture>\");\n                pstrcat(buf, buf_sz, arch);\n                pstrcat(buf, buf_sz, \"</architecture>\");\n                g_free(arch);\n            }\n            pstrcat(buf, buf_sz, \"<xi:include href=\\\"\");\n            pstrcat(buf, buf_sz, cc->gdb_core_xml_file);\n            pstrcat(buf, buf_sz, \"\\\"/>\");\n            for (r = cpu->gdb_regs; r; r = r->next) {\n                pstrcat(buf, buf_sz, \"<xi:include href=\\\"\");\n                pstrcat(buf, buf_sz, r->xml);\n                pstrcat(buf, buf_sz, \"\\\"/>\");\n            }\n            pstrcat(buf, buf_sz, \"</target>\");\n        }\n        return buf;\n    }\n    if (cc->gdb_get_dynamic_xml) {\n        char *xmlname = g_strndup(p, len);\n        const char *xml = cc->gdb_get_dynamic_xml(cpu, xmlname);\n\n        g_free(xmlname);\n        if (xml) {\n            return xml;\n        }\n    }\n    for (i = 0; ; i++) {\n        name = xml_builtin[i][0];\n        if (!name || (strncmp(name, p, len) == 0 && strlen(name) == len))\n            break;\n    }\n    return name ? xml_builtin[i][1] : NULL;\n}\n\nstatic int gdb_read_register(CPUState *cpu, GByteArray *buf, int reg)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUArchState *env = cpu->env_ptr;\n    GDBRegisterState *r;\n\n    if (reg < cc->gdb_num_core_regs) {\n        return cc->gdb_read_register(cpu, buf, reg);\n    }\n\n    for (r = cpu->gdb_regs; r; r = r->next) {\n        if (r->base_reg <= reg && reg < r->base_reg + r->num_regs) {\n            return r->get_reg(env, buf, reg - r->base_reg);\n        }\n    }\n    return 0;\n}\n\nstatic int gdb_write_register(CPUState *cpu, uint8_t *mem_buf, int reg)\n{\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    CPUArchState *env = cpu->env_ptr;\n    GDBRegisterState *r;\n\n    if (reg < cc->gdb_num_core_regs) {\n        return cc->gdb_write_register(cpu, mem_buf, reg);\n    }\n\n    for (r = cpu->gdb_regs; r; r = r->next) {\n        if (r->base_reg <= reg && reg < r->base_reg + r->num_regs) {\n            return r->set_reg(env, mem_buf, reg - r->base_reg);\n        }\n    }\n    return 0;\n}\n\n/* Register a supplemental set of CPU registers.  If g_pos is nonzero it\n   specifies the first register number and these registers are included in\n   a standard \"g\" packet.  Direction is relative to gdb, i.e. get_reg is\n   gdb reading a CPU register, and set_reg is gdb modifying a CPU register.\n */\n\nvoid gdb_register_coprocessor(CPUState *cpu,\n                              gdb_get_reg_cb get_reg, gdb_set_reg_cb set_reg,\n                              int num_regs, const char *xml, int g_pos)\n{\n    GDBRegisterState *s;\n    GDBRegisterState **p;\n\n    p = &cpu->gdb_regs;\n    while (*p) {\n        /* Check for duplicates.  */\n        if (strcmp((*p)->xml, xml) == 0)\n            return;\n        p = &(*p)->next;\n    }\n\n    s = g_new0(GDBRegisterState, 1);\n    s->base_reg = cpu->gdb_num_regs;\n    s->num_regs = num_regs;\n    s->get_reg = get_reg;\n    s->set_reg = set_reg;\n    s->xml = xml;\n\n    /* Add to end of list.  */\n    cpu->gdb_num_regs += num_regs;\n    *p = s;\n    if (g_pos) {\n        if (g_pos != s->base_reg) {\n            error_report(\"Error: Bad gdb register numbering for '%s', \"\n                         \"expected %d got %d\", xml, g_pos, s->base_reg);\n        } else {\n            cpu->gdb_num_g_regs = cpu->gdb_num_regs;\n        }\n    }\n}\n\n#ifndef CONFIG_USER_ONLY\n/* Translate GDB watchpoint type to a flags value for cpu_watchpoint_* */\nstatic inline int xlat_gdb_type(CPUState *cpu, int gdbtype)\n{\n    static const int xlat[] = {\n        [GDB_WATCHPOINT_WRITE]  = BP_GDB | BP_MEM_WRITE,\n        [GDB_WATCHPOINT_READ]   = BP_GDB | BP_MEM_READ,\n        [GDB_WATCHPOINT_ACCESS] = BP_GDB | BP_MEM_ACCESS,\n    };\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n    int cputype = xlat[gdbtype];\n\n    if (cc->gdb_stop_before_watchpoint) {\n        cputype |= BP_STOP_BEFORE_ACCESS;\n    }\n    return cputype;\n}\n#endif\n\nstatic int gdb_breakpoint_insert(int type, target_ulong addr, target_ulong len)\n{\n    CPUState *cpu;\n    int err = 0;\n\n    if (kvm_enabled()) {\n        return kvm_insert_breakpoint(gdbserver_state.c_cpu, addr, len, type);\n    }\n\n    switch (type) {\n    case GDB_BREAKPOINT_SW:\n    case GDB_BREAKPOINT_HW:\n        CPU_FOREACH(cpu) {\n            err = cpu_breakpoint_insert(cpu, addr, BP_GDB, NULL);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n#ifndef CONFIG_USER_ONLY\n    case GDB_WATCHPOINT_WRITE:\n    case GDB_WATCHPOINT_READ:\n    case GDB_WATCHPOINT_ACCESS:\n        CPU_FOREACH(cpu) {\n            err = cpu_watchpoint_insert(cpu, addr, len,\n                                        xlat_gdb_type(cpu, type), NULL);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n#endif\n    default:\n        return -ENOSYS;\n    }\n}\n\nstatic int gdb_breakpoint_remove(int type, target_ulong addr, target_ulong len)\n{\n    CPUState *cpu;\n    int err = 0;\n\n    if (kvm_enabled()) {\n        return kvm_remove_breakpoint(gdbserver_state.c_cpu, addr, len, type);\n    }\n\n    switch (type) {\n    case GDB_BREAKPOINT_SW:\n    case GDB_BREAKPOINT_HW:\n        CPU_FOREACH(cpu) {\n            err = cpu_breakpoint_remove(cpu, addr, BP_GDB);\n            if (err) {\n                break;\n            }\n        }\n        return err;\n#ifndef CONFIG_USER_ONLY\n    case GDB_WATCHPOINT_WRITE:\n    case GDB_WATCHPOINT_READ:\n    case GDB_WATCHPOINT_ACCESS:\n        CPU_FOREACH(cpu) {\n            err = cpu_watchpoint_remove(cpu, addr, len,\n                                        xlat_gdb_type(cpu, type));\n            if (err)\n                break;\n        }\n        return err;\n#endif\n    default:\n        return -ENOSYS;\n    }\n}\n\nstatic inline void gdb_cpu_breakpoint_remove_all(CPUState *cpu)\n{\n    cpu_breakpoint_remove_all(cpu, BP_GDB);\n#ifndef CONFIG_USER_ONLY\n    cpu_watchpoint_remove_all(cpu, BP_GDB);\n#endif\n}\n\nstatic void gdb_process_breakpoint_remove_all(GDBProcess *p)\n{\n    CPUState *cpu = get_first_cpu_in_process(p);\n\n    while (cpu) {\n        gdb_cpu_breakpoint_remove_all(cpu);\n        cpu = gdb_next_cpu_in_process(cpu);\n    }\n}\n\nstatic void gdb_breakpoint_remove_all(void)\n{\n    CPUState *cpu;\n\n    if (kvm_enabled()) {\n        kvm_remove_all_breakpoints(gdbserver_state.c_cpu);\n        return;\n    }\n\n    CPU_FOREACH(cpu) {\n        gdb_cpu_breakpoint_remove_all(cpu);\n    }\n}\n\nstatic void gdb_set_cpu_pc(target_ulong pc)\n{\n    CPUState *cpu = gdbserver_state.c_cpu;\n\n    cpu_synchronize_state(cpu);\n    cpu_set_pc(cpu, pc);\n}\n\nstatic void gdb_append_thread_id(CPUState *cpu, GString *buf)\n{\n    if (gdbserver_state.multiprocess) {\n        g_string_append_printf(buf, \"p%02x.%02x\",\n                               gdb_get_cpu_pid(cpu), cpu_gdb_index(cpu));\n    } else {\n        g_string_append_printf(buf, \"%02x\", cpu_gdb_index(cpu));\n    }\n}\n\ntypedef enum GDBThreadIdKind {\n    GDB_ONE_THREAD = 0,\n    GDB_ALL_THREADS,     /* One process, all threads */\n    GDB_ALL_PROCESSES,\n    GDB_READ_THREAD_ERR\n} GDBThreadIdKind;\n\nstatic GDBThreadIdKind read_thread_id(const char *buf, const char **end_buf,\n                                      uint32_t *pid, uint32_t *tid)\n{\n    unsigned long p, t;\n    int ret;\n\n    if (*buf == 'p') {\n        buf++;\n        ret = qemu_strtoul(buf, &buf, 16, &p);\n\n        if (ret) {\n            return GDB_READ_THREAD_ERR;\n        }\n\n        /* Skip '.' */\n        buf++;\n    } else {\n        p = 1;\n    }\n\n    ret = qemu_strtoul(buf, &buf, 16, &t);\n\n    if (ret) {\n        return GDB_READ_THREAD_ERR;\n    }\n\n    *end_buf = buf;\n\n    if (p == -1) {\n        return GDB_ALL_PROCESSES;\n    }\n\n    if (pid) {\n        *pid = p;\n    }\n\n    if (t == -1) {\n        return GDB_ALL_THREADS;\n    }\n\n    if (tid) {\n        *tid = t;\n    }\n\n    return GDB_ONE_THREAD;\n}\n\n/**\n * gdb_handle_vcont - Parses and handles a vCont packet.\n * returns -ENOTSUP if a command is unsupported, -EINVAL or -ERANGE if there is\n *         a format error, 0 on success.\n */\nstatic int gdb_handle_vcont(const char *p)\n{\n    int res, signal = 0;\n    char cur_action;\n    char *newstates;\n    unsigned long tmp;\n    uint32_t pid, tid;\n    GDBProcess *process;\n    CPUState *cpu;\n    GDBThreadIdKind kind;\n#ifdef CONFIG_USER_ONLY\n    int max_cpus = 1; /* global variable max_cpus exists only in system mode */\n\n    CPU_FOREACH(cpu) {\n        max_cpus = max_cpus <= cpu->cpu_index ? cpu->cpu_index + 1 : max_cpus;\n    }\n#else\n    MachineState *ms = MACHINE(qdev_get_machine());\n    unsigned int max_cpus = ms->smp.max_cpus;\n#endif\n    /* uninitialised CPUs stay 0 */\n    newstates = g_new0(char, max_cpus);\n\n    /* mark valid CPUs with 1 */\n    CPU_FOREACH(cpu) {\n        newstates[cpu->cpu_index] = 1;\n    }\n\n    /*\n     * res keeps track of what error we are returning, with -ENOTSUP meaning\n     * that the command is unknown or unsupported, thus returning an empty\n     * packet, while -EINVAL and -ERANGE cause an E22 packet, due to invalid,\n     *  or incorrect parameters passed.\n     */\n    res = 0;\n    while (*p) {\n        if (*p++ != ';') {\n            res = -ENOTSUP;\n            goto out;\n        }\n\n        cur_action = *p++;\n        if (cur_action == 'C' || cur_action == 'S') {\n            cur_action = qemu_tolower(cur_action);\n            res = qemu_strtoul(p, &p, 16, &tmp);\n            if (res) {\n                goto out;\n            }\n            signal = gdb_signal_to_target(tmp);\n        } else if (cur_action != 'c' && cur_action != 's') {\n            /* unknown/invalid/unsupported command */\n            res = -ENOTSUP;\n            goto out;\n        }\n\n        if (*p == '\\0' || *p == ';') {\n            /*\n             * No thread specifier, action is on \"all threads\". The\n             * specification is unclear regarding the process to act on. We\n             * choose all processes.\n             */\n            kind = GDB_ALL_PROCESSES;\n        } else if (*p++ == ':') {\n            kind = read_thread_id(p, &p, &pid, &tid);\n        } else {\n            res = -ENOTSUP;\n            goto out;\n        }\n\n        switch (kind) {\n        case GDB_READ_THREAD_ERR:\n            res = -EINVAL;\n            goto out;\n\n        case GDB_ALL_PROCESSES:\n            cpu = gdb_first_attached_cpu();\n            while (cpu) {\n                if (newstates[cpu->cpu_index] == 1) {\n                    newstates[cpu->cpu_index] = cur_action;\n                }\n\n                cpu = gdb_next_attached_cpu(cpu);\n            }\n            break;\n\n        case GDB_ALL_THREADS:\n            process = gdb_get_process(pid);\n\n            if (!process->attached) {\n                res = -EINVAL;\n                goto out;\n            }\n\n            cpu = get_first_cpu_in_process(process);\n            while (cpu) {\n                if (newstates[cpu->cpu_index] == 1) {\n                    newstates[cpu->cpu_index] = cur_action;\n                }\n\n                cpu = gdb_next_cpu_in_process(cpu);\n            }\n            break;\n\n        case GDB_ONE_THREAD:\n            cpu = gdb_get_cpu(pid, tid);\n\n            /* invalid CPU/thread specified */\n            if (!cpu) {\n                res = -EINVAL;\n                goto out;\n            }\n\n            /* only use if no previous match occourred */\n            if (newstates[cpu->cpu_index] == 1) {\n                newstates[cpu->cpu_index] = cur_action;\n            }\n            break;\n        }\n    }\n    gdbserver_state.signal = signal;\n    gdb_continue_partial(newstates);\n\nout:\n    g_free(newstates);\n\n    return res;\n}\n\ntypedef union GdbCmdVariant {\n    const char *data;\n    uint8_t opcode;\n    unsigned long val_ul;\n    unsigned long long val_ull;\n    struct {\n        GDBThreadIdKind kind;\n        uint32_t pid;\n        uint32_t tid;\n    } thread_id;\n} GdbCmdVariant;\n\n#define get_param(p, i)    (&g_array_index(p, GdbCmdVariant, i))\n\nstatic const char *cmd_next_param(const char *param, const char delimiter)\n{\n    static const char all_delimiters[] = \",;:=\";\n    char curr_delimiters[2] = {0};\n    const char *delimiters;\n\n    if (delimiter == '?') {\n        delimiters = all_delimiters;\n    } else if (delimiter == '0') {\n        return strchr(param, '\\0');\n    } else if (delimiter == '.' && *param) {\n        return param + 1;\n    } else {\n        curr_delimiters[0] = delimiter;\n        delimiters = curr_delimiters;\n    }\n\n    param += strcspn(param, delimiters);\n    if (*param) {\n        param++;\n    }\n    return param;\n}\n\nstatic int cmd_parse_params(const char *data, const char *schema,\n                            GArray *params)\n{\n    const char *curr_schema, *curr_data;\n\n    g_assert(schema);\n    g_assert(params->len == 0);\n\n    curr_schema = schema;\n    curr_data = data;\n    while (curr_schema[0] && curr_schema[1] && *curr_data) {\n        GdbCmdVariant this_param;\n\n        switch (curr_schema[0]) {\n        case 'l':\n            if (qemu_strtoul(curr_data, &curr_data, 16,\n                             &this_param.val_ul)) {\n                return -EINVAL;\n            }\n            curr_data = cmd_next_param(curr_data, curr_schema[1]);\n            g_array_append_val(params, this_param);\n            break;\n        case 'L':\n            if (qemu_strtou64(curr_data, &curr_data, 16,\n                              (uint64_t *)&this_param.val_ull)) {\n                return -EINVAL;\n            }\n            curr_data = cmd_next_param(curr_data, curr_schema[1]);\n            g_array_append_val(params, this_param);\n            break;\n        case 's':\n            this_param.data = curr_data;\n            curr_data = cmd_next_param(curr_data, curr_schema[1]);\n            g_array_append_val(params, this_param);\n            break;\n        case 'o':\n            this_param.opcode = *(uint8_t *)curr_data;\n            curr_data = cmd_next_param(curr_data, curr_schema[1]);\n            g_array_append_val(params, this_param);\n            break;\n        case 't':\n            this_param.thread_id.kind =\n                read_thread_id(curr_data, &curr_data,\n                               &this_param.thread_id.pid,\n                               &this_param.thread_id.tid);\n            curr_data = cmd_next_param(curr_data, curr_schema[1]);\n            g_array_append_val(params, this_param);\n            break;\n        case '?':\n            curr_data = cmd_next_param(curr_data, curr_schema[1]);\n            break;\n        default:\n            return -EINVAL;\n        }\n        curr_schema += 2;\n    }\n\n    return 0;\n}\n\ntypedef void (*GdbCmdHandler)(GArray *params, void *user_ctx);\n\n/*\n * cmd_startswith -> cmd is compared using startswith\n *\n *\n * schema definitions:\n * Each schema parameter entry consists of 2 chars,\n * the first char represents the parameter type handling\n * the second char represents the delimiter for the next parameter\n *\n * Currently supported schema types:\n * 'l' -> unsigned long (stored in .val_ul)\n * 'L' -> unsigned long long (stored in .val_ull)\n * 's' -> string (stored in .data)\n * 'o' -> single char (stored in .opcode)\n * 't' -> thread id (stored in .thread_id)\n * '?' -> skip according to delimiter\n *\n * Currently supported delimiters:\n * '?' -> Stop at any delimiter (\",;:=\\0\")\n * '0' -> Stop at \"\\0\"\n * '.' -> Skip 1 char unless reached \"\\0\"\n * Any other value is treated as the delimiter value itself\n */\ntypedef struct GdbCmdParseEntry {\n    GdbCmdHandler handler;\n    const char *cmd;\n    bool cmd_startswith;\n    const char *schema;\n} GdbCmdParseEntry;\n\nstatic inline int startswith(const char *string, const char *pattern)\n{\n  return !strncmp(string, pattern, strlen(pattern));\n}\n\nstatic int process_string_cmd(void *user_ctx, const char *data,\n                              const GdbCmdParseEntry *cmds, int num_cmds)\n{\n    int i;\n    g_autoptr(GArray) params = g_array_new(false, true, sizeof(GdbCmdVariant));\n\n    if (!cmds) {\n        return -1;\n    }\n\n    for (i = 0; i < num_cmds; i++) {\n        const GdbCmdParseEntry *cmd = &cmds[i];\n        g_assert(cmd->handler && cmd->cmd);\n\n        if ((cmd->cmd_startswith && !startswith(data, cmd->cmd)) ||\n            (!cmd->cmd_startswith && strcmp(cmd->cmd, data))) {\n            continue;\n        }\n\n        if (cmd->schema) {\n            if (cmd_parse_params(&data[strlen(cmd->cmd)],\n                                 cmd->schema, params)) {\n                return -1;\n            }\n        }\n\n        cmd->handler(params, user_ctx);\n        return 0;\n    }\n\n    return -1;\n}\n\nstatic void run_cmd_parser(const char *data, const GdbCmdParseEntry *cmd)\n{\n    if (!data) {\n        return;\n    }\n\n    g_string_set_size(gdbserver_state.str_buf, 0);\n    g_byte_array_set_size(gdbserver_state.mem_buf, 0);\n\n    /* In case there was an error during the command parsing we must\n    * send a NULL packet to indicate the command is not supported */\n    if (process_string_cmd(NULL, data, cmd, 1)) {\n        put_packet(\"\");\n    }\n}\n\nstatic void handle_detach(GArray *params, void *user_ctx)\n{\n    GDBProcess *process;\n    uint32_t pid = 1;\n\n    if (gdbserver_state.multiprocess) {\n        if (!params->len) {\n            put_packet(\"E22\");\n            return;\n        }\n\n        pid = get_param(params, 0)->val_ul;\n    }\n\n    process = gdb_get_process(pid);\n    gdb_process_breakpoint_remove_all(process);\n    process->attached = false;\n\n    if (pid == gdb_get_cpu_pid(gdbserver_state.c_cpu)) {\n        gdbserver_state.c_cpu = gdb_first_attached_cpu();\n    }\n\n    if (pid == gdb_get_cpu_pid(gdbserver_state.g_cpu)) {\n        gdbserver_state.g_cpu = gdb_first_attached_cpu();\n    }\n\n    if (!gdbserver_state.c_cpu) {\n        /* No more process attached */\n        gdb_syscall_mode = GDB_SYS_DISABLED;\n        gdb_continue();\n    }\n    put_packet(\"OK\");\n}\n\nstatic void handle_thread_alive(GArray *params, void *user_ctx)\n{\n    CPUState *cpu;\n\n    if (!params->len) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    if (get_param(params, 0)->thread_id.kind == GDB_READ_THREAD_ERR) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    cpu = gdb_get_cpu(get_param(params, 0)->thread_id.pid,\n                      get_param(params, 0)->thread_id.tid);\n    if (!cpu) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    put_packet(\"OK\");\n}\n\nstatic void handle_continue(GArray *params, void *user_ctx)\n{\n    if (params->len) {\n        gdb_set_cpu_pc(get_param(params, 0)->val_ull);\n    }\n\n    gdbserver_state.signal = 0;\n    gdb_continue();\n}\n\nstatic void handle_cont_with_sig(GArray *params, void *user_ctx)\n{\n    unsigned long signal = 0;\n\n    /*\n     * Note: C sig;[addr] is currently unsupported and we simply\n     *       omit the addr parameter\n     */\n    if (params->len) {\n        signal = get_param(params, 0)->val_ul;\n    }\n\n    gdbserver_state.signal = gdb_signal_to_target(signal);\n    if (gdbserver_state.signal == -1) {\n        gdbserver_state.signal = 0;\n    }\n    gdb_continue();\n}\n\nstatic void handle_set_thread(GArray *params, void *user_ctx)\n{\n    CPUState *cpu;\n\n    if (params->len != 2) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    if (get_param(params, 1)->thread_id.kind == GDB_READ_THREAD_ERR) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    if (get_param(params, 1)->thread_id.kind != GDB_ONE_THREAD) {\n        put_packet(\"OK\");\n        return;\n    }\n\n    cpu = gdb_get_cpu(get_param(params, 1)->thread_id.pid,\n                      get_param(params, 1)->thread_id.tid);\n    if (!cpu) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    /*\n     * Note: This command is deprecated and modern gdb's will be using the\n     *       vCont command instead.\n     */\n    switch (get_param(params, 0)->opcode) {\n    case 'c':\n        gdbserver_state.c_cpu = cpu;\n        put_packet(\"OK\");\n        break;\n    case 'g':\n        gdbserver_state.g_cpu = cpu;\n        put_packet(\"OK\");\n        break;\n    default:\n        put_packet(\"E22\");\n        break;\n    }\n}\n\nstatic void handle_insert_bp(GArray *params, void *user_ctx)\n{\n    int res;\n\n    if (params->len != 3) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    res = gdb_breakpoint_insert(get_param(params, 0)->val_ul,\n                                get_param(params, 1)->val_ull,\n                                get_param(params, 2)->val_ull);\n    if (res >= 0) {\n        put_packet(\"OK\");\n        return;\n    } else if (res == -ENOSYS) {\n        put_packet(\"\");\n        return;\n    }\n\n    put_packet(\"E22\");\n}\n\nstatic void handle_remove_bp(GArray *params, void *user_ctx)\n{\n    int res;\n\n    if (params->len != 3) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    res = gdb_breakpoint_remove(get_param(params, 0)->val_ul,\n                                get_param(params, 1)->val_ull,\n                                get_param(params, 2)->val_ull);\n    if (res >= 0) {\n        put_packet(\"OK\");\n        return;\n    } else if (res == -ENOSYS) {\n        put_packet(\"\");\n        return;\n    }\n\n    put_packet(\"E22\");\n}\n\n/*\n * handle_set/get_reg\n *\n * Older gdb are really dumb, and don't use 'G/g' if 'P/p' is available.\n * This works, but can be very slow. Anything new enough to understand\n * XML also knows how to use this properly. However to use this we\n * need to define a local XML file as well as be talking to a\n * reasonably modern gdb. Responding with an empty packet will cause\n * the remote gdb to fallback to older methods.\n */\n\nstatic void handle_set_reg(GArray *params, void *user_ctx)\n{\n    int reg_size;\n\n    if (!gdb_has_xml) {\n        put_packet(\"\");\n        return;\n    }\n\n    if (params->len != 2) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    reg_size = strlen(get_param(params, 1)->data) / 2;\n    hextomem(gdbserver_state.mem_buf, get_param(params, 1)->data, reg_size);\n    gdb_write_register(gdbserver_state.g_cpu, gdbserver_state.mem_buf->data,\n                       get_param(params, 0)->val_ull);\n    put_packet(\"OK\");\n}\n\nstatic void handle_get_reg(GArray *params, void *user_ctx)\n{\n    int reg_size;\n\n    if (!gdb_has_xml) {\n        put_packet(\"\");\n        return;\n    }\n\n    if (!params->len) {\n        put_packet(\"E14\");\n        return;\n    }\n\n    reg_size = gdb_read_register(gdbserver_state.g_cpu,\n                                 gdbserver_state.mem_buf,\n                                 get_param(params, 0)->val_ull);\n    if (!reg_size) {\n        put_packet(\"E14\");\n        return;\n    } else {\n        g_byte_array_set_size(gdbserver_state.mem_buf, reg_size);\n    }\n\n    memtohex(gdbserver_state.str_buf, gdbserver_state.mem_buf->data, reg_size);\n    put_strbuf();\n}\n\nstatic void handle_write_mem(GArray *params, void *user_ctx)\n{\n    if (params->len != 3) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    /* hextomem() reads 2*len bytes */\n    if (get_param(params, 1)->val_ull >\n        strlen(get_param(params, 2)->data) / 2) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    hextomem(gdbserver_state.mem_buf, get_param(params, 2)->data,\n             get_param(params, 1)->val_ull);\n    if (target_memory_rw_debug(gdbserver_state.g_cpu,\n                               get_param(params, 0)->val_ull,\n                               gdbserver_state.mem_buf->data,\n                               gdbserver_state.mem_buf->len, true)) {\n        put_packet(\"E14\");\n        return;\n    }\n\n    put_packet(\"OK\");\n}\n\nstatic void handle_read_mem(GArray *params, void *user_ctx)\n{\n    if (params->len != 2) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    /* memtohex() doubles the required space */\n    if (get_param(params, 1)->val_ull > MAX_PACKET_LENGTH / 2) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    g_byte_array_set_size(gdbserver_state.mem_buf,\n                          get_param(params, 1)->val_ull);\n\n    if (target_memory_rw_debug(gdbserver_state.g_cpu,\n                               get_param(params, 0)->val_ull,\n                               gdbserver_state.mem_buf->data,\n                               gdbserver_state.mem_buf->len, false)) {\n        put_packet(\"E14\");\n        return;\n    }\n\n    memtohex(gdbserver_state.str_buf, gdbserver_state.mem_buf->data,\n             gdbserver_state.mem_buf->len);\n    put_strbuf();\n}\n\nstatic void handle_write_all_regs(GArray *params, void *user_ctx)\n{\n    target_ulong addr, len;\n    uint8_t *registers;\n    int reg_size;\n\n    if (!params->len) {\n        return;\n    }\n\n    cpu_synchronize_state(gdbserver_state.g_cpu);\n    len = strlen(get_param(params, 0)->data) / 2;\n    hextomem(gdbserver_state.mem_buf, get_param(params, 0)->data, len);\n    registers = gdbserver_state.mem_buf->data;\n    for (addr = 0; addr < gdbserver_state.g_cpu->gdb_num_g_regs && len > 0;\n         addr++) {\n        reg_size = gdb_write_register(gdbserver_state.g_cpu, registers, addr);\n        len -= reg_size;\n        registers += reg_size;\n    }\n    put_packet(\"OK\");\n}\n\nstatic void handle_read_all_regs(GArray *params, void *user_ctx)\n{\n    target_ulong addr, len;\n\n    cpu_synchronize_state(gdbserver_state.g_cpu);\n    g_byte_array_set_size(gdbserver_state.mem_buf, 0);\n    len = 0;\n    for (addr = 0; addr < gdbserver_state.g_cpu->gdb_num_g_regs; addr++) {\n        len += gdb_read_register(gdbserver_state.g_cpu,\n                                 gdbserver_state.mem_buf,\n                                 addr);\n    }\n    g_assert(len == gdbserver_state.mem_buf->len);\n\n    memtohex(gdbserver_state.str_buf, gdbserver_state.mem_buf->data, len);\n    put_strbuf();\n}\n\nstatic void handle_file_io(GArray *params, void *user_ctx)\n{\n    if (params->len >= 1 && gdbserver_state.current_syscall_cb) {\n        uint64_t ret;\n        int err;\n\n        ret = get_param(params, 0)->val_ull;\n        if (params->len >= 2) {\n            err = get_param(params, 1)->val_ull;\n        } else {\n            err = 0;\n        }\n\n        /* Convert GDB error numbers back to host error numbers. */\n#define E(X)  case GDB_E##X: err = E##X; break\n        switch (err) {\n        case 0:\n            break;\n        E(PERM);\n        E(NOENT);\n        E(INTR);\n        E(BADF);\n        E(ACCES);\n        E(FAULT);\n        E(BUSY);\n        E(EXIST);\n        E(NODEV);\n        E(NOTDIR);\n        E(ISDIR);\n        E(INVAL);\n        E(NFILE);\n        E(MFILE);\n        E(FBIG);\n        E(NOSPC);\n        E(SPIPE);\n        E(ROFS);\n        E(NAMETOOLONG);\n        default:\n            err = EINVAL;\n            break;\n        }\n#undef E\n\n        gdbserver_state.current_syscall_cb(gdbserver_state.c_cpu, ret, err);\n        gdbserver_state.current_syscall_cb = NULL;\n    }\n\n    if (params->len >= 3 && get_param(params, 2)->opcode == (uint8_t)'C') {\n        put_packet(\"T02\");\n        return;\n    }\n\n    gdb_continue();\n}\n\nstatic void handle_step(GArray *params, void *user_ctx)\n{\n    if (params->len) {\n        gdb_set_cpu_pc((target_ulong)get_param(params, 0)->val_ull);\n    }\n\n    cpu_single_step(gdbserver_state.c_cpu, gdbserver_state.sstep_flags);\n    gdb_continue();\n}\n\nstatic void handle_backward(GArray *params, void *user_ctx)\n{\n    if (!stub_can_reverse()) {\n        put_packet(\"E22\");\n    }\n    if (params->len == 1) {\n        switch (get_param(params, 0)->opcode) {\n        case 's':\n            if (replay_reverse_step()) {\n                gdb_continue();\n            } else {\n                put_packet(\"E14\");\n            }\n            return;\n        case 'c':\n            if (replay_reverse_continue()) {\n                gdb_continue();\n            } else {\n                put_packet(\"E14\");\n            }\n            return;\n        }\n    }\n\n    /* Default invalid command */\n    put_packet(\"\");\n}\n\nstatic void handle_v_cont_query(GArray *params, void *user_ctx)\n{\n    put_packet(\"vCont;c;C;s;S\");\n}\n\nstatic void handle_v_cont(GArray *params, void *user_ctx)\n{\n    int res;\n\n    if (!params->len) {\n        return;\n    }\n\n    res = gdb_handle_vcont(get_param(params, 0)->data);\n    if ((res == -EINVAL) || (res == -ERANGE)) {\n        put_packet(\"E22\");\n    } else if (res) {\n        put_packet(\"\");\n    }\n}\n\nstatic void handle_v_attach(GArray *params, void *user_ctx)\n{\n    GDBProcess *process;\n    CPUState *cpu;\n\n    g_string_assign(gdbserver_state.str_buf, \"E22\");\n    if (!params->len) {\n        goto cleanup;\n    }\n\n    process = gdb_get_process(get_param(params, 0)->val_ul);\n    if (!process) {\n        goto cleanup;\n    }\n\n    cpu = get_first_cpu_in_process(process);\n    if (!cpu) {\n        goto cleanup;\n    }\n\n    process->attached = true;\n    gdbserver_state.g_cpu = cpu;\n    gdbserver_state.c_cpu = cpu;\n\n    g_string_printf(gdbserver_state.str_buf, \"T%02xthread:\", GDB_SIGNAL_TRAP);\n    gdb_append_thread_id(cpu, gdbserver_state.str_buf);\n    g_string_append_c(gdbserver_state.str_buf, ';');\ncleanup:\n    put_strbuf();\n}\n\nstatic void handle_v_kill(GArray *params, void *user_ctx)\n{\n    /* Kill the target */\n    put_packet(\"OK\");\n    error_report(\"QEMU: Terminated via GDBstub\");\n    gdb_exit(0);\n    exit(0);\n}\n\nstatic const GdbCmdParseEntry gdb_v_commands_table[] = {\n    /* Order is important if has same prefix */\n    {\n        .handler = handle_v_cont_query,\n        .cmd = \"Cont?\",\n        .cmd_startswith = 1\n    },\n    {\n        .handler = handle_v_cont,\n        .cmd = \"Cont\",\n        .cmd_startswith = 1,\n        .schema = \"s0\"\n    },\n    {\n        .handler = handle_v_attach,\n        .cmd = \"Attach;\",\n        .cmd_startswith = 1,\n        .schema = \"l0\"\n    },\n    {\n        .handler = handle_v_kill,\n        .cmd = \"Kill;\",\n        .cmd_startswith = 1\n    },\n};\n\nstatic void handle_v_commands(GArray *params, void *user_ctx)\n{\n    if (!params->len) {\n        return;\n    }\n\n    if (process_string_cmd(NULL, get_param(params, 0)->data,\n                           gdb_v_commands_table,\n                           ARRAY_SIZE(gdb_v_commands_table))) {\n        put_packet(\"\");\n    }\n}\n\nstatic void handle_query_qemu_sstepbits(GArray *params, void *user_ctx)\n{\n    g_string_printf(gdbserver_state.str_buf, \"ENABLE=%x\", SSTEP_ENABLE);\n\n    if (gdbserver_state.supported_sstep_flags & SSTEP_NOIRQ) {\n        g_string_append_printf(gdbserver_state.str_buf, \",NOIRQ=%x\",\n                               SSTEP_NOIRQ);\n    }\n\n    if (gdbserver_state.supported_sstep_flags & SSTEP_NOTIMER) {\n        g_string_append_printf(gdbserver_state.str_buf, \",NOTIMER=%x\",\n                               SSTEP_NOTIMER);\n    }\n\n    put_strbuf();\n}\n\nstatic void handle_set_qemu_sstep(GArray *params, void *user_ctx)\n{\n    int new_sstep_flags;\n\n    if (!params->len) {\n        return;\n    }\n\n    new_sstep_flags = get_param(params, 0)->val_ul;\n\n    if (new_sstep_flags  & ~gdbserver_state.supported_sstep_flags) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    gdbserver_state.sstep_flags = new_sstep_flags;\n    put_packet(\"OK\");\n}\n\nstatic void handle_query_qemu_sstep(GArray *params, void *user_ctx)\n{\n    g_string_printf(gdbserver_state.str_buf, \"0x%x\",\n                    gdbserver_state.sstep_flags);\n    put_strbuf();\n}\n\nstatic void handle_query_curr_tid(GArray *params, void *user_ctx)\n{\n    CPUState *cpu;\n    GDBProcess *process;\n\n    /*\n     * \"Current thread\" remains vague in the spec, so always return\n     * the first thread of the current process (gdb returns the\n     * first thread).\n     */\n    process = gdb_get_cpu_process(gdbserver_state.g_cpu);\n    cpu = get_first_cpu_in_process(process);\n    g_string_assign(gdbserver_state.str_buf, \"QC\");\n    gdb_append_thread_id(cpu, gdbserver_state.str_buf);\n    put_strbuf();\n}\n\nstatic void handle_query_threads(GArray *params, void *user_ctx)\n{\n    if (!gdbserver_state.query_cpu) {\n        put_packet(\"l\");\n        return;\n    }\n\n    g_string_assign(gdbserver_state.str_buf, \"m\");\n    gdb_append_thread_id(gdbserver_state.query_cpu, gdbserver_state.str_buf);\n    put_strbuf();\n    gdbserver_state.query_cpu = gdb_next_attached_cpu(gdbserver_state.query_cpu);\n}\n\nstatic void handle_query_first_threads(GArray *params, void *user_ctx)\n{\n    gdbserver_state.query_cpu = gdb_first_attached_cpu();\n    handle_query_threads(params, user_ctx);\n}\n\nstatic void handle_query_thread_extra(GArray *params, void *user_ctx)\n{\n    g_autoptr(GString) rs = g_string_new(NULL);\n    CPUState *cpu;\n\n    if (!params->len ||\n        get_param(params, 0)->thread_id.kind == GDB_READ_THREAD_ERR) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    cpu = gdb_get_cpu(get_param(params, 0)->thread_id.pid,\n                      get_param(params, 0)->thread_id.tid);\n    if (!cpu) {\n        return;\n    }\n\n    cpu_synchronize_state(cpu);\n\n    if (gdbserver_state.multiprocess && (gdbserver_state.process_num > 1)) {\n        /* Print the CPU model and name in multiprocess mode */\n        ObjectClass *oc = object_get_class(OBJECT(cpu));\n        const char *cpu_model = object_class_get_name(oc);\n        const char *cpu_name =\n            object_get_canonical_path_component(OBJECT(cpu));\n        g_string_printf(rs, \"%s %s [%s]\", cpu_model, cpu_name,\n                        cpu->halted ? \"halted \" : \"running\");\n    } else {\n        g_string_printf(rs, \"CPU#%d [%s]\", cpu->cpu_index,\n                        cpu->halted ? \"halted \" : \"running\");\n    }\n    trace_gdbstub_op_extra_info(rs->str);\n    memtohex(gdbserver_state.str_buf, (uint8_t *)rs->str, rs->len);\n    put_strbuf();\n}\n\n#ifdef CONFIG_USER_ONLY\nstatic void handle_query_offsets(GArray *params, void *user_ctx)\n{\n    TaskState *ts;\n\n    ts = gdbserver_state.c_cpu->opaque;\n    g_string_printf(gdbserver_state.str_buf,\n                    \"Text=\" TARGET_ABI_FMT_lx\n                    \";Data=\" TARGET_ABI_FMT_lx\n                    \";Bss=\" TARGET_ABI_FMT_lx,\n                    ts->info->code_offset,\n                    ts->info->data_offset,\n                    ts->info->data_offset);\n    put_strbuf();\n}\n#else\nstatic void handle_query_rcmd(GArray *params, void *user_ctx)\n{\n    const guint8 zero = 0;\n    int len;\n\n    if (!params->len) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    len = strlen(get_param(params, 0)->data);\n    if (len % 2) {\n        put_packet(\"E01\");\n        return;\n    }\n\n    g_assert(gdbserver_state.mem_buf->len == 0);\n    len = len / 2;\n    hextomem(gdbserver_state.mem_buf, get_param(params, 0)->data, len);\n    g_byte_array_append(gdbserver_state.mem_buf, &zero, 1);\n    qemu_chr_be_write(gdbserver_state.mon_chr, gdbserver_state.mem_buf->data,\n                      gdbserver_state.mem_buf->len);\n    put_packet(\"OK\");\n}\n#endif\n\nstatic void handle_query_supported(GArray *params, void *user_ctx)\n{\n    CPUClass *cc;\n\n    g_string_printf(gdbserver_state.str_buf, \"PacketSize=%x\", MAX_PACKET_LENGTH);\n    cc = CPU_GET_CLASS(first_cpu);\n    if (cc->gdb_core_xml_file) {\n        g_string_append(gdbserver_state.str_buf, \";qXfer:features:read+\");\n    }\n\n    if (stub_can_reverse()) {\n        g_string_append(gdbserver_state.str_buf,\n            \";ReverseStep+;ReverseContinue+\");\n    }\n\n#ifdef CONFIG_USER_ONLY\n    if (gdbserver_state.c_cpu->opaque) {\n        g_string_append(gdbserver_state.str_buf, \";qXfer:auxv:read+\");\n    }\n#endif\n\n    if (params->len &&\n        strstr(get_param(params, 0)->data, \"multiprocess+\")) {\n        gdbserver_state.multiprocess = true;\n    }\n\n    g_string_append(gdbserver_state.str_buf, \";vContSupported+;multiprocess+\");\n    put_strbuf();\n}\n\nstatic void handle_query_xfer_features(GArray *params, void *user_ctx)\n{\n    GDBProcess *process;\n    CPUClass *cc;\n    unsigned long len, total_len, addr;\n    const char *xml;\n    const char *p;\n\n    if (params->len < 3) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    process = gdb_get_cpu_process(gdbserver_state.g_cpu);\n    cc = CPU_GET_CLASS(gdbserver_state.g_cpu);\n    if (!cc->gdb_core_xml_file) {\n        put_packet(\"\");\n        return;\n    }\n\n    gdb_has_xml = true;\n    p = get_param(params, 0)->data;\n    xml = get_feature_xml(p, &p, process);\n    if (!xml) {\n        put_packet(\"E00\");\n        return;\n    }\n\n    addr = get_param(params, 1)->val_ul;\n    len = get_param(params, 2)->val_ul;\n    total_len = strlen(xml);\n    if (addr > total_len) {\n        put_packet(\"E00\");\n        return;\n    }\n\n    if (len > (MAX_PACKET_LENGTH - 5) / 2) {\n        len = (MAX_PACKET_LENGTH - 5) / 2;\n    }\n\n    if (len < total_len - addr) {\n        g_string_assign(gdbserver_state.str_buf, \"m\");\n        memtox(gdbserver_state.str_buf, xml + addr, len);\n    } else {\n        g_string_assign(gdbserver_state.str_buf, \"l\");\n        memtox(gdbserver_state.str_buf, xml + addr, total_len - addr);\n    }\n\n    put_packet_binary(gdbserver_state.str_buf->str,\n                      gdbserver_state.str_buf->len, true);\n}\n\n#if defined(CONFIG_USER_ONLY) && defined(CONFIG_LINUX_USER)\nstatic void handle_query_xfer_auxv(GArray *params, void *user_ctx)\n{\n    TaskState *ts;\n    unsigned long offset, len, saved_auxv, auxv_len;\n\n    if (params->len < 2) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    offset = get_param(params, 0)->val_ul;\n    len = get_param(params, 1)->val_ul;\n    ts = gdbserver_state.c_cpu->opaque;\n    saved_auxv = ts->info->saved_auxv;\n    auxv_len = ts->info->auxv_len;\n\n    if (offset >= auxv_len) {\n        put_packet(\"E00\");\n        return;\n    }\n\n    if (len > (MAX_PACKET_LENGTH - 5) / 2) {\n        len = (MAX_PACKET_LENGTH - 5) / 2;\n    }\n\n    if (len < auxv_len - offset) {\n        g_string_assign(gdbserver_state.str_buf, \"m\");\n    } else {\n        g_string_assign(gdbserver_state.str_buf, \"l\");\n        len = auxv_len - offset;\n    }\n\n    g_byte_array_set_size(gdbserver_state.mem_buf, len);\n    if (target_memory_rw_debug(gdbserver_state.g_cpu, saved_auxv + offset,\n                               gdbserver_state.mem_buf->data, len, false)) {\n        put_packet(\"E14\");\n        return;\n    }\n\n    memtox(gdbserver_state.str_buf,\n           (const char *)gdbserver_state.mem_buf->data, len);\n    put_packet_binary(gdbserver_state.str_buf->str,\n                      gdbserver_state.str_buf->len, true);\n}\n#endif\n\nstatic void handle_query_attached(GArray *params, void *user_ctx)\n{\n    put_packet(GDB_ATTACHED);\n}\n\nstatic void handle_query_qemu_supported(GArray *params, void *user_ctx)\n{\n    g_string_printf(gdbserver_state.str_buf, \"sstepbits;sstep\");\n#ifndef CONFIG_USER_ONLY\n    g_string_append(gdbserver_state.str_buf, \";PhyMemMode\");\n#endif\n    put_strbuf();\n}\n\n#ifndef CONFIG_USER_ONLY\nstatic void handle_query_qemu_phy_mem_mode(GArray *params,\n                                           void *user_ctx)\n{\n    g_string_printf(gdbserver_state.str_buf, \"%d\", phy_memory_mode);\n    put_strbuf();\n}\n\nstatic void handle_set_qemu_phy_mem_mode(GArray *params, void *user_ctx)\n{\n    if (!params->len) {\n        put_packet(\"E22\");\n        return;\n    }\n\n    if (!get_param(params, 0)->val_ul) {\n        phy_memory_mode = 0;\n    } else {\n        phy_memory_mode = 1;\n    }\n    put_packet(\"OK\");\n}\n#endif\n\nstatic const GdbCmdParseEntry gdb_gen_query_set_common_table[] = {\n    /* Order is important if has same prefix */\n    {\n        .handler = handle_query_qemu_sstepbits,\n        .cmd = \"qemu.sstepbits\",\n    },\n    {\n        .handler = handle_query_qemu_sstep,\n        .cmd = \"qemu.sstep\",\n    },\n    {\n        .handler = handle_set_qemu_sstep,\n        .cmd = \"qemu.sstep=\",\n        .cmd_startswith = 1,\n        .schema = \"l0\"\n    },\n};\n\nstatic const GdbCmdParseEntry gdb_gen_query_table[] = {\n    {\n        .handler = handle_query_curr_tid,\n        .cmd = \"C\",\n    },\n    {\n        .handler = handle_query_threads,\n        .cmd = \"sThreadInfo\",\n    },\n    {\n        .handler = handle_query_first_threads,\n        .cmd = \"fThreadInfo\",\n    },\n    {\n        .handler = handle_query_thread_extra,\n        .cmd = \"ThreadExtraInfo,\",\n        .cmd_startswith = 1,\n        .schema = \"t0\"\n    },\n#ifdef CONFIG_USER_ONLY\n    {\n        .handler = handle_query_offsets,\n        .cmd = \"Offsets\",\n    },\n#else\n    {\n        .handler = handle_query_rcmd,\n        .cmd = \"Rcmd,\",\n        .cmd_startswith = 1,\n        .schema = \"s0\"\n    },\n#endif\n    {\n        .handler = handle_query_supported,\n        .cmd = \"Supported:\",\n        .cmd_startswith = 1,\n        .schema = \"s0\"\n    },\n    {\n        .handler = handle_query_supported,\n        .cmd = \"Supported\",\n        .schema = \"s0\"\n    },\n    {\n        .handler = handle_query_xfer_features,\n        .cmd = \"Xfer:features:read:\",\n        .cmd_startswith = 1,\n        .schema = \"s:l,l0\"\n    },\n#if defined(CONFIG_USER_ONLY) && defined(CONFIG_LINUX_USER)\n    {\n        .handler = handle_query_xfer_auxv,\n        .cmd = \"Xfer:auxv:read::\",\n        .cmd_startswith = 1,\n        .schema = \"l,l0\"\n    },\n#endif\n    {\n        .handler = handle_query_attached,\n        .cmd = \"Attached:\",\n        .cmd_startswith = 1\n    },\n    {\n        .handler = handle_query_attached,\n        .cmd = \"Attached\",\n    },\n    {\n        .handler = handle_query_qemu_supported,\n        .cmd = \"qemu.Supported\",\n    },\n#ifndef CONFIG_USER_ONLY\n    {\n        .handler = handle_query_qemu_phy_mem_mode,\n        .cmd = \"qemu.PhyMemMode\",\n    },\n#endif\n};\n\nstatic const GdbCmdParseEntry gdb_gen_set_table[] = {\n    /* Order is important if has same prefix */\n    {\n        .handler = handle_set_qemu_sstep,\n        .cmd = \"qemu.sstep:\",\n        .cmd_startswith = 1,\n        .schema = \"l0\"\n    },\n#ifndef CONFIG_USER_ONLY\n    {\n        .handler = handle_set_qemu_phy_mem_mode,\n        .cmd = \"qemu.PhyMemMode:\",\n        .cmd_startswith = 1,\n        .schema = \"l0\"\n    },\n#endif\n};\n\nstatic void handle_gen_query(GArray *params, void *user_ctx)\n{\n    if (!params->len) {\n        return;\n    }\n\n    if (!process_string_cmd(NULL, get_param(params, 0)->data,\n                            gdb_gen_query_set_common_table,\n                            ARRAY_SIZE(gdb_gen_query_set_common_table))) {\n        return;\n    }\n\n    if (process_string_cmd(NULL, get_param(params, 0)->data,\n                           gdb_gen_query_table,\n                           ARRAY_SIZE(gdb_gen_query_table))) {\n        put_packet(\"\");\n    }\n}\n\nstatic void handle_gen_set(GArray *params, void *user_ctx)\n{\n    if (!params->len) {\n        return;\n    }\n\n    if (!process_string_cmd(NULL, get_param(params, 0)->data,\n                            gdb_gen_query_set_common_table,\n                            ARRAY_SIZE(gdb_gen_query_set_common_table))) {\n        return;\n    }\n\n    if (process_string_cmd(NULL, get_param(params, 0)->data,\n                           gdb_gen_set_table,\n                           ARRAY_SIZE(gdb_gen_set_table))) {\n        put_packet(\"\");\n    }\n}\n\nstatic void handle_target_halt(GArray *params, void *user_ctx)\n{\n    g_string_printf(gdbserver_state.str_buf, \"T%02xthread:\", GDB_SIGNAL_TRAP);\n    gdb_append_thread_id(gdbserver_state.c_cpu, gdbserver_state.str_buf);\n    g_string_append_c(gdbserver_state.str_buf, ';');\n    put_strbuf();\n    /*\n     * Remove all the breakpoints when this query is issued,\n     * because gdb is doing an initial connect and the state\n     * should be cleaned up.\n     */\n    gdb_breakpoint_remove_all();\n}\n\nstatic int gdb_handle_packet(const char *line_buf)\n{\n    const GdbCmdParseEntry *cmd_parser = NULL;\n\n    trace_gdbstub_io_command(line_buf);\n\n    switch (line_buf[0]) {\n    case '!':\n        put_packet(\"OK\");\n        break;\n    case '?':\n        {\n            static const GdbCmdParseEntry target_halted_cmd_desc = {\n                .handler = handle_target_halt,\n                .cmd = \"?\",\n                .cmd_startswith = 1\n            };\n            cmd_parser = &target_halted_cmd_desc;\n        }\n        break;\n    case 'c':\n        {\n            static const GdbCmdParseEntry continue_cmd_desc = {\n                .handler = handle_continue,\n                .cmd = \"c\",\n                .cmd_startswith = 1,\n                .schema = \"L0\"\n            };\n            cmd_parser = &continue_cmd_desc;\n        }\n        break;\n    case 'C':\n        {\n            static const GdbCmdParseEntry cont_with_sig_cmd_desc = {\n                .handler = handle_cont_with_sig,\n                .cmd = \"C\",\n                .cmd_startswith = 1,\n                .schema = \"l0\"\n            };\n            cmd_parser = &cont_with_sig_cmd_desc;\n        }\n        break;\n    case 'v':\n        {\n            static const GdbCmdParseEntry v_cmd_desc = {\n                .handler = handle_v_commands,\n                .cmd = \"v\",\n                .cmd_startswith = 1,\n                .schema = \"s0\"\n            };\n            cmd_parser = &v_cmd_desc;\n        }\n        break;\n    case 'k':\n        /* Kill the target */\n        error_report(\"QEMU: Terminated via GDBstub\");\n        gdb_exit(0);\n        exit(0);\n    case 'D':\n        {\n            static const GdbCmdParseEntry detach_cmd_desc = {\n                .handler = handle_detach,\n                .cmd = \"D\",\n                .cmd_startswith = 1,\n                .schema = \"?.l0\"\n            };\n            cmd_parser = &detach_cmd_desc;\n        }\n        break;\n    case 's':\n        {\n            static const GdbCmdParseEntry step_cmd_desc = {\n                .handler = handle_step,\n                .cmd = \"s\",\n                .cmd_startswith = 1,\n                .schema = \"L0\"\n            };\n            cmd_parser = &step_cmd_desc;\n        }\n        break;\n    case 'b':\n        {\n            static const GdbCmdParseEntry backward_cmd_desc = {\n                .handler = handle_backward,\n                .cmd = \"b\",\n                .cmd_startswith = 1,\n                .schema = \"o0\"\n            };\n            cmd_parser = &backward_cmd_desc;\n        }\n        break;\n    case 'F':\n        {\n            static const GdbCmdParseEntry file_io_cmd_desc = {\n                .handler = handle_file_io,\n                .cmd = \"F\",\n                .cmd_startswith = 1,\n                .schema = \"L,L,o0\"\n            };\n            cmd_parser = &file_io_cmd_desc;\n        }\n        break;\n    case 'g':\n        {\n            static const GdbCmdParseEntry read_all_regs_cmd_desc = {\n                .handler = handle_read_all_regs,\n                .cmd = \"g\",\n                .cmd_startswith = 1\n            };\n            cmd_parser = &read_all_regs_cmd_desc;\n        }\n        break;\n    case 'G':\n        {\n            static const GdbCmdParseEntry write_all_regs_cmd_desc = {\n                .handler = handle_write_all_regs,\n                .cmd = \"G\",\n                .cmd_startswith = 1,\n                .schema = \"s0\"\n            };\n            cmd_parser = &write_all_regs_cmd_desc;\n        }\n        break;\n    case 'm':\n        {\n            static const GdbCmdParseEntry read_mem_cmd_desc = {\n                .handler = handle_read_mem,\n                .cmd = \"m\",\n                .cmd_startswith = 1,\n                .schema = \"L,L0\"\n            };\n            cmd_parser = &read_mem_cmd_desc;\n        }\n        break;\n    case 'M':\n        {\n            static const GdbCmdParseEntry write_mem_cmd_desc = {\n                .handler = handle_write_mem,\n                .cmd = \"M\",\n                .cmd_startswith = 1,\n                .schema = \"L,L:s0\"\n            };\n            cmd_parser = &write_mem_cmd_desc;\n        }\n        break;\n    case 'p':\n        {\n            static const GdbCmdParseEntry get_reg_cmd_desc = {\n                .handler = handle_get_reg,\n                .cmd = \"p\",\n                .cmd_startswith = 1,\n                .schema = \"L0\"\n            };\n            cmd_parser = &get_reg_cmd_desc;\n        }\n        break;\n    case 'P':\n        {\n            static const GdbCmdParseEntry set_reg_cmd_desc = {\n                .handler = handle_set_reg,\n                .cmd = \"P\",\n                .cmd_startswith = 1,\n                .schema = \"L?s0\"\n            };\n            cmd_parser = &set_reg_cmd_desc;\n        }\n        break;\n    case 'Z':\n        {\n            static const GdbCmdParseEntry insert_bp_cmd_desc = {\n                .handler = handle_insert_bp,\n                .cmd = \"Z\",\n                .cmd_startswith = 1,\n                .schema = \"l?L?L0\"\n            };\n            cmd_parser = &insert_bp_cmd_desc;\n        }\n        break;\n    case 'z':\n        {\n            static const GdbCmdParseEntry remove_bp_cmd_desc = {\n                .handler = handle_remove_bp,\n                .cmd = \"z\",\n                .cmd_startswith = 1,\n                .schema = \"l?L?L0\"\n            };\n            cmd_parser = &remove_bp_cmd_desc;\n        }\n        break;\n    case 'H':\n        {\n            static const GdbCmdParseEntry set_thread_cmd_desc = {\n                .handler = handle_set_thread,\n                .cmd = \"H\",\n                .cmd_startswith = 1,\n                .schema = \"o.t0\"\n            };\n            cmd_parser = &set_thread_cmd_desc;\n        }\n        break;\n    case 'T':\n        {\n            static const GdbCmdParseEntry thread_alive_cmd_desc = {\n                .handler = handle_thread_alive,\n                .cmd = \"T\",\n                .cmd_startswith = 1,\n                .schema = \"t0\"\n            };\n            cmd_parser = &thread_alive_cmd_desc;\n        }\n        break;\n    case 'q':\n        {\n            static const GdbCmdParseEntry gen_query_cmd_desc = {\n                .handler = handle_gen_query,\n                .cmd = \"q\",\n                .cmd_startswith = 1,\n                .schema = \"s0\"\n            };\n            cmd_parser = &gen_query_cmd_desc;\n        }\n        break;\n    case 'Q':\n        {\n            static const GdbCmdParseEntry gen_set_cmd_desc = {\n                .handler = handle_gen_set,\n                .cmd = \"Q\",\n                .cmd_startswith = 1,\n                .schema = \"s0\"\n            };\n            cmd_parser = &gen_set_cmd_desc;\n        }\n        break;\n    default:\n        /* put empty packet */\n        put_packet(\"\");\n        break;\n    }\n\n    if (cmd_parser) {\n        run_cmd_parser(line_buf, cmd_parser);\n    }\n\n    return RS_IDLE;\n}\n\nvoid gdb_set_stop_cpu(CPUState *cpu)\n{\n    GDBProcess *p = gdb_get_cpu_process(cpu);\n\n    if (!p->attached) {\n        /*\n         * Having a stop CPU corresponding to a process that is not attached\n         * confuses GDB. So we ignore the request.\n         */\n        return;\n    }\n\n    gdbserver_state.c_cpu = cpu;\n    gdbserver_state.g_cpu = cpu;\n}\n\n#ifndef CONFIG_USER_ONLY\nstatic void gdb_vm_state_change(void *opaque, bool running, RunState state)\n{\n    CPUState *cpu = gdbserver_state.c_cpu;\n    g_autoptr(GString) buf = g_string_new(NULL);\n    g_autoptr(GString) tid = g_string_new(NULL);\n    const char *type;\n    int ret;\n\n    if (running || gdbserver_state.state == RS_INACTIVE) {\n        return;\n    }\n    /* Is there a GDB syscall waiting to be sent?  */\n    if (gdbserver_state.current_syscall_cb) {\n        put_packet(gdbserver_state.syscall_buf);\n        return;\n    }\n\n    if (cpu == NULL) {\n        /* No process attached */\n        return;\n    }\n\n    gdb_append_thread_id(cpu, tid);\n\n    switch (state) {\n    case RUN_STATE_DEBUG:\n        if (cpu->watchpoint_hit) {\n            switch (cpu->watchpoint_hit->flags & BP_MEM_ACCESS) {\n            case BP_MEM_READ:\n                type = \"r\";\n                break;\n            case BP_MEM_ACCESS:\n                type = \"a\";\n                break;\n            default:\n                type = \"\";\n                break;\n            }\n            trace_gdbstub_hit_watchpoint(type, cpu_gdb_index(cpu),\n                    (target_ulong)cpu->watchpoint_hit->vaddr);\n            g_string_printf(buf, \"T%02xthread:%s;%swatch:\" TARGET_FMT_lx \";\",\n                            GDB_SIGNAL_TRAP, tid->str, type,\n                            (target_ulong)cpu->watchpoint_hit->vaddr);\n            cpu->watchpoint_hit = NULL;\n            goto send_packet;\n        } else {\n            trace_gdbstub_hit_break();\n        }\n        tb_flush(cpu);\n        ret = GDB_SIGNAL_TRAP;\n        break;\n    case RUN_STATE_PAUSED:\n        trace_gdbstub_hit_paused();\n        ret = GDB_SIGNAL_INT;\n        break;\n    case RUN_STATE_SHUTDOWN:\n        trace_gdbstub_hit_shutdown();\n        ret = GDB_SIGNAL_QUIT;\n        break;\n    case RUN_STATE_IO_ERROR:\n        trace_gdbstub_hit_io_error();\n        ret = GDB_SIGNAL_IO;\n        break;\n    case RUN_STATE_WATCHDOG:\n        trace_gdbstub_hit_watchdog();\n        ret = GDB_SIGNAL_ALRM;\n        break;\n    case RUN_STATE_INTERNAL_ERROR:\n        trace_gdbstub_hit_internal_error();\n        ret = GDB_SIGNAL_ABRT;\n        break;\n    case RUN_STATE_SAVE_VM:\n    case RUN_STATE_RESTORE_VM:\n        return;\n    case RUN_STATE_FINISH_MIGRATE:\n        ret = GDB_SIGNAL_XCPU;\n        break;\n    default:\n        trace_gdbstub_hit_unknown(state);\n        ret = GDB_SIGNAL_UNKNOWN;\n        break;\n    }\n    gdb_set_stop_cpu(cpu);\n    g_string_printf(buf, \"T%02xthread:%s;\", ret, tid->str);\n\nsend_packet:\n    put_packet(buf->str);\n\n    /* disable single step if it was enabled */\n    cpu_single_step(cpu, 0);\n}\n#endif\n\n/* Send a gdb syscall request.\n   This accepts limited printf-style format specifiers, specifically:\n    %x  - target_ulong argument printed in hex.\n    %lx - 64-bit argument printed in hex.\n    %s  - string pointer (target_ulong) and length (int) pair.  */\nvoid gdb_do_syscallv(gdb_syscall_complete_cb cb, const char *fmt, va_list va)\n{\n    char *p;\n    char *p_end;\n    target_ulong addr;\n    uint64_t i64;\n\n    if (!gdb_attached()) {\n        return;\n    }\n\n    gdbserver_state.current_syscall_cb = cb;\n#ifndef CONFIG_USER_ONLY\n    vm_stop(RUN_STATE_DEBUG);\n#endif\n    p = &gdbserver_state.syscall_buf[0];\n    p_end = &gdbserver_state.syscall_buf[sizeof(gdbserver_state.syscall_buf)];\n    *(p++) = 'F';\n    while (*fmt) {\n        if (*fmt == '%') {\n            fmt++;\n            switch (*fmt++) {\n            case 'x':\n                addr = va_arg(va, target_ulong);\n                p += snprintf(p, p_end - p, TARGET_FMT_lx, addr);\n                break;\n            case 'l':\n                if (*(fmt++) != 'x')\n                    goto bad_format;\n                i64 = va_arg(va, uint64_t);\n                p += snprintf(p, p_end - p, \"%\" PRIx64, i64);\n                break;\n            case 's':\n                addr = va_arg(va, target_ulong);\n                p += snprintf(p, p_end - p, TARGET_FMT_lx \"/%x\",\n                              addr, va_arg(va, int));\n                break;\n            default:\n            bad_format:\n                error_report(\"gdbstub: Bad syscall format string '%s'\",\n                             fmt - 1);\n                break;\n            }\n        } else {\n            *(p++) = *(fmt++);\n        }\n    }\n    *p = 0;\n#ifdef CONFIG_USER_ONLY\n    put_packet(gdbserver_state.syscall_buf);\n    /* Return control to gdb for it to process the syscall request.\n     * Since the protocol requires that gdb hands control back to us\n     * using a \"here are the results\" F packet, we don't need to check\n     * gdb_handlesig's return value (which is the signal to deliver if\n     * execution was resumed via a continue packet).\n     */\n    gdb_handlesig(gdbserver_state.c_cpu, 0);\n#else\n    /* In this case wait to send the syscall packet until notification that\n       the CPU has stopped.  This must be done because if the packet is sent\n       now the reply from the syscall request could be received while the CPU\n       is still in the running state, which can cause packets to be dropped\n       and state transition 'T' packets to be sent while the syscall is still\n       being processed.  */\n    qemu_cpu_kick(gdbserver_state.c_cpu);\n#endif\n}\n\nvoid gdb_do_syscall(gdb_syscall_complete_cb cb, const char *fmt, ...)\n{\n    va_list va;\n\n    va_start(va, fmt);\n    gdb_do_syscallv(cb, fmt, va);\n    va_end(va);\n}\n\nstatic void gdb_read_byte(uint8_t ch)\n{\n    uint8_t reply;\n\n#ifndef CONFIG_USER_ONLY\n    if (gdbserver_state.last_packet->len) {\n        /* Waiting for a response to the last packet.  If we see the start\n           of a new command then abandon the previous response.  */\n        if (ch == '-') {\n            trace_gdbstub_err_got_nack();\n            put_buffer(gdbserver_state.last_packet->data,\n                       gdbserver_state.last_packet->len);\n        } else if (ch == '+') {\n            trace_gdbstub_io_got_ack();\n        } else {\n            trace_gdbstub_io_got_unexpected(ch);\n        }\n\n        if (ch == '+' || ch == '$') {\n            g_byte_array_set_size(gdbserver_state.last_packet, 0);\n        }\n        if (ch != '$')\n            return;\n    }\n    if (runstate_is_running()) {\n        /* when the CPU is running, we cannot do anything except stop\n           it when receiving a char */\n        vm_stop(RUN_STATE_PAUSED);\n    } else\n#endif\n    {\n        switch(gdbserver_state.state) {\n        case RS_IDLE:\n            if (ch == '$') {\n                /* start of command packet */\n                gdbserver_state.line_buf_index = 0;\n                gdbserver_state.line_sum = 0;\n                gdbserver_state.state = RS_GETLINE;\n            } else {\n                trace_gdbstub_err_garbage(ch);\n            }\n            break;\n        case RS_GETLINE:\n            if (ch == '}') {\n                /* start escape sequence */\n                gdbserver_state.state = RS_GETLINE_ESC;\n                gdbserver_state.line_sum += ch;\n            } else if (ch == '*') {\n                /* start run length encoding sequence */\n                gdbserver_state.state = RS_GETLINE_RLE;\n                gdbserver_state.line_sum += ch;\n            } else if (ch == '#') {\n                /* end of command, start of checksum*/\n                gdbserver_state.state = RS_CHKSUM1;\n            } else if (gdbserver_state.line_buf_index >= sizeof(gdbserver_state.line_buf) - 1) {\n                trace_gdbstub_err_overrun();\n                gdbserver_state.state = RS_IDLE;\n            } else {\n                /* unescaped command character */\n                gdbserver_state.line_buf[gdbserver_state.line_buf_index++] = ch;\n                gdbserver_state.line_sum += ch;\n            }\n            break;\n        case RS_GETLINE_ESC:\n            if (ch == '#') {\n                /* unexpected end of command in escape sequence */\n                gdbserver_state.state = RS_CHKSUM1;\n            } else if (gdbserver_state.line_buf_index >= sizeof(gdbserver_state.line_buf) - 1) {\n                /* command buffer overrun */\n                trace_gdbstub_err_overrun();\n                gdbserver_state.state = RS_IDLE;\n            } else {\n                /* parse escaped character and leave escape state */\n                gdbserver_state.line_buf[gdbserver_state.line_buf_index++] = ch ^ 0x20;\n                gdbserver_state.line_sum += ch;\n                gdbserver_state.state = RS_GETLINE;\n            }\n            break;\n        case RS_GETLINE_RLE:\n            /*\n             * Run-length encoding is explained in \"Debugging with GDB /\n             * Appendix E GDB Remote Serial Protocol / Overview\".\n             */\n            if (ch < ' ' || ch == '#' || ch == '$' || ch > 126) {\n                /* invalid RLE count encoding */\n                trace_gdbstub_err_invalid_repeat(ch);\n                gdbserver_state.state = RS_GETLINE;\n            } else {\n                /* decode repeat length */\n                int repeat = ch - ' ' + 3;\n                if (gdbserver_state.line_buf_index + repeat >= sizeof(gdbserver_state.line_buf) - 1) {\n                    /* that many repeats would overrun the command buffer */\n                    trace_gdbstub_err_overrun();\n                    gdbserver_state.state = RS_IDLE;\n                } else if (gdbserver_state.line_buf_index < 1) {\n                    /* got a repeat but we have nothing to repeat */\n                    trace_gdbstub_err_invalid_rle();\n                    gdbserver_state.state = RS_GETLINE;\n                } else {\n                    /* repeat the last character */\n                    memset(gdbserver_state.line_buf + gdbserver_state.line_buf_index,\n                           gdbserver_state.line_buf[gdbserver_state.line_buf_index - 1], repeat);\n                    gdbserver_state.line_buf_index += repeat;\n                    gdbserver_state.line_sum += ch;\n                    gdbserver_state.state = RS_GETLINE;\n                }\n            }\n            break;\n        case RS_CHKSUM1:\n            /* get high hex digit of checksum */\n            if (!isxdigit(ch)) {\n                trace_gdbstub_err_checksum_invalid(ch);\n                gdbserver_state.state = RS_GETLINE;\n                break;\n            }\n            gdbserver_state.line_buf[gdbserver_state.line_buf_index] = '\\0';\n            gdbserver_state.line_csum = fromhex(ch) << 4;\n            gdbserver_state.state = RS_CHKSUM2;\n            break;\n        case RS_CHKSUM2:\n            /* get low hex digit of checksum */\n            if (!isxdigit(ch)) {\n                trace_gdbstub_err_checksum_invalid(ch);\n                gdbserver_state.state = RS_GETLINE;\n                break;\n            }\n            gdbserver_state.line_csum |= fromhex(ch);\n\n            if (gdbserver_state.line_csum != (gdbserver_state.line_sum & 0xff)) {\n                trace_gdbstub_err_checksum_incorrect(gdbserver_state.line_sum, gdbserver_state.line_csum);\n                /* send NAK reply */\n                reply = '-';\n                put_buffer(&reply, 1);\n                gdbserver_state.state = RS_IDLE;\n            } else {\n                /* send ACK reply */\n                reply = '+';\n                put_buffer(&reply, 1);\n                gdbserver_state.state = gdb_handle_packet(gdbserver_state.line_buf);\n            }\n            break;\n        default:\n            abort();\n        }\n    }\n}\n\n/* Tell the remote gdb that the process has exited.  */\nvoid gdb_exit(int code)\n{\n  char buf[4];\n\n  if (!gdbserver_state.init) {\n      return;\n  }\n#ifdef CONFIG_USER_ONLY\n  if (gdbserver_state.socket_path) {\n      unlink(gdbserver_state.socket_path);\n  }\n  if (gdbserver_state.fd < 0) {\n      return;\n  }\n#endif\n\n  trace_gdbstub_op_exiting((uint8_t)code);\n\n  snprintf(buf, sizeof(buf), \"W%02x\", (uint8_t)code);\n  put_packet(buf);\n\n#ifndef CONFIG_USER_ONLY\n  qemu_chr_fe_deinit(&gdbserver_state.chr, true);\n#endif\n}\n\n/*\n * Create the process that will contain all the \"orphan\" CPUs (that are not\n * part of a CPU cluster). Note that if this process contains no CPUs, it won't\n * be attachable and thus will be invisible to the user.\n */\nstatic void create_default_process(GDBState *s)\n{\n    GDBProcess *process;\n    int max_pid = 0;\n\n    if (gdbserver_state.process_num) {\n        max_pid = s->processes[s->process_num - 1].pid;\n    }\n\n    s->processes = g_renew(GDBProcess, s->processes, ++s->process_num);\n    process = &s->processes[s->process_num - 1];\n\n    /* We need an available PID slot for this process */\n    assert(max_pid < UINT32_MAX);\n\n    process->pid = max_pid + 1;\n    process->attached = false;\n    process->target_xml[0] = '\\0';\n}\n\n#ifdef CONFIG_USER_ONLY\nint\ngdb_handlesig(CPUState *cpu, int sig)\n{\n    char buf[256];\n    int n;\n\n    if (!gdbserver_state.init || gdbserver_state.fd < 0) {\n        return sig;\n    }\n\n    /* disable single step if it was enabled */\n    cpu_single_step(cpu, 0);\n    tb_flush(cpu);\n\n    if (sig != 0) {\n        gdb_set_stop_cpu(cpu);\n        g_string_printf(gdbserver_state.str_buf,\n                        \"T%02xthread:\", target_signal_to_gdb(sig));\n        gdb_append_thread_id(cpu, gdbserver_state.str_buf);\n        g_string_append_c(gdbserver_state.str_buf, ';');\n        put_strbuf();\n    }\n    /* put_packet() might have detected that the peer terminated the\n       connection.  */\n    if (gdbserver_state.fd < 0) {\n        return sig;\n    }\n\n    sig = 0;\n    gdbserver_state.state = RS_IDLE;\n    gdbserver_state.running_state = 0;\n    while (gdbserver_state.running_state == 0) {\n        n = read(gdbserver_state.fd, buf, 256);\n        if (n > 0) {\n            int i;\n\n            for (i = 0; i < n; i++) {\n                gdb_read_byte(buf[i]);\n            }\n        } else {\n            /* XXX: Connection closed.  Should probably wait for another\n               connection before continuing.  */\n            if (n == 0) {\n                close(gdbserver_state.fd);\n            }\n            gdbserver_state.fd = -1;\n            return sig;\n        }\n    }\n    sig = gdbserver_state.signal;\n    gdbserver_state.signal = 0;\n    return sig;\n}\n\n/* Tell the remote gdb that the process has exited due to SIG.  */\nvoid gdb_signalled(CPUArchState *env, int sig)\n{\n    char buf[4];\n\n    if (!gdbserver_state.init || gdbserver_state.fd < 0) {\n        return;\n    }\n\n    snprintf(buf, sizeof(buf), \"X%02x\", target_signal_to_gdb(sig));\n    put_packet(buf);\n}\n\nstatic void gdb_accept_init(int fd)\n{\n    init_gdbserver_state();\n    create_default_process(&gdbserver_state);\n    gdbserver_state.processes[0].attached = true;\n    gdbserver_state.c_cpu = gdb_first_attached_cpu();\n    gdbserver_state.g_cpu = gdbserver_state.c_cpu;\n    gdbserver_state.fd = fd;\n    gdb_has_xml = false;\n}\n\nstatic bool gdb_accept_socket(int gdb_fd)\n{\n    int fd;\n\n    for(;;) {\n        fd = accept(gdb_fd, NULL, NULL);\n        if (fd < 0 && errno != EINTR) {\n            perror(\"accept socket\");\n            return false;\n        } else if (fd >= 0) {\n            qemu_set_cloexec(fd);\n            break;\n        }\n    }\n\n    gdb_accept_init(fd);\n    return true;\n}\n\nstatic int gdbserver_open_socket(const char *path)\n{\n    struct sockaddr_un sockaddr = {};\n    int fd, ret;\n\n    fd = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"create socket\");\n        return -1;\n    }\n\n    sockaddr.sun_family = AF_UNIX;\n    pstrcpy(sockaddr.sun_path, sizeof(sockaddr.sun_path) - 1, path);\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n    if (ret < 0) {\n        perror(\"bind socket\");\n        close(fd);\n        return -1;\n    }\n    ret = listen(fd, 1);\n    if (ret < 0) {\n        perror(\"listen socket\");\n        close(fd);\n        return -1;\n    }\n\n    return fd;\n}\n\nstatic bool gdb_accept_tcp(int gdb_fd)\n{\n    struct sockaddr_in sockaddr = {};\n    socklen_t len;\n    int fd;\n\n    for(;;) {\n        len = sizeof(sockaddr);\n        fd = accept(gdb_fd, (struct sockaddr *)&sockaddr, &len);\n        if (fd < 0 && errno != EINTR) {\n            perror(\"accept\");\n            return false;\n        } else if (fd >= 0) {\n            qemu_set_cloexec(fd);\n            break;\n        }\n    }\n\n    /* set short latency */\n    if (socket_set_nodelay(fd)) {\n        perror(\"setsockopt\");\n        close(fd);\n        return false;\n    }\n\n    gdb_accept_init(fd);\n    return true;\n}\n\nstatic int gdbserver_open_port(int port)\n{\n    struct sockaddr_in sockaddr;\n    int fd, ret;\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n    if (fd < 0) {\n        perror(\"socket\");\n        return -1;\n    }\n    qemu_set_cloexec(fd);\n\n    socket_set_fast_reuse(fd);\n\n    sockaddr.sin_family = AF_INET;\n    sockaddr.sin_port = htons(port);\n    sockaddr.sin_addr.s_addr = 0;\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n    if (ret < 0) {\n        perror(\"bind\");\n        close(fd);\n        return -1;\n    }\n    ret = listen(fd, 1);\n    if (ret < 0) {\n        perror(\"listen\");\n        close(fd);\n        return -1;\n    }\n\n    return fd;\n}\n\nint gdbserver_start(const char *port_or_path)\n{\n    int port = g_ascii_strtoull(port_or_path, NULL, 10);\n    int gdb_fd;\n\n    if (port > 0) {\n        gdb_fd = gdbserver_open_port(port);\n    } else {\n        gdb_fd = gdbserver_open_socket(port_or_path);\n    }\n\n    if (gdb_fd < 0) {\n        return -1;\n    }\n\n    if (port > 0 && gdb_accept_tcp(gdb_fd)) {\n        return 0;\n    } else if (gdb_accept_socket(gdb_fd)) {\n        gdbserver_state.socket_path = g_strdup(port_or_path);\n        return 0;\n    }\n\n    /* gone wrong */\n    close(gdb_fd);\n    return -1;\n}\n\n/* Disable gdb stub for child processes.  */\nvoid gdbserver_fork(CPUState *cpu)\n{\n    if (!gdbserver_state.init || gdbserver_state.fd < 0) {\n        return;\n    }\n    close(gdbserver_state.fd);\n    gdbserver_state.fd = -1;\n    cpu_breakpoint_remove_all(cpu, BP_GDB);\n    cpu_watchpoint_remove_all(cpu, BP_GDB);\n}\n#else\nstatic int gdb_chr_can_receive(void *opaque)\n{\n  /* We can handle an arbitrarily large amount of data.\n   Pick the maximum packet size, which is as good as anything.  */\n  return MAX_PACKET_LENGTH;\n}\n\nstatic void gdb_chr_receive(void *opaque, const uint8_t *buf, int size)\n{\n    int i;\n\n    for (i = 0; i < size; i++) {\n        gdb_read_byte(buf[i]);\n    }\n}\n\nstatic void gdb_chr_event(void *opaque, QEMUChrEvent event)\n{\n    int i;\n    GDBState *s = (GDBState *) opaque;\n\n    switch (event) {\n    case CHR_EVENT_OPENED:\n        /* Start with first process attached, others detached */\n        for (i = 0; i < s->process_num; i++) {\n            s->processes[i].attached = !i;\n        }\n\n        s->c_cpu = gdb_first_attached_cpu();\n        s->g_cpu = s->c_cpu;\n\n        vm_stop(RUN_STATE_PAUSED);\n        replay_gdb_attached();\n        gdb_has_xml = false;\n        break;\n    default:\n        break;\n    }\n}\n\nstatic int gdb_monitor_write(Chardev *chr, const uint8_t *buf, int len)\n{\n    g_autoptr(GString) hex_buf = g_string_new(\"O\");\n    memtohex(hex_buf, buf, len);\n    put_packet(hex_buf->str);\n    return len;\n}\n\n#ifndef _WIN32\nstatic void gdb_sigterm_handler(int signal)\n{\n    if (runstate_is_running()) {\n        vm_stop(RUN_STATE_PAUSED);\n    }\n}\n#endif\n\nstatic void gdb_monitor_open(Chardev *chr, ChardevBackend *backend,\n                             bool *be_opened, Error **errp)\n{\n    *be_opened = false;\n}\n\nstatic void char_gdb_class_init(ObjectClass *oc, void *data)\n{\n    ChardevClass *cc = CHARDEV_CLASS(oc);\n\n    cc->internal = true;\n    cc->open = gdb_monitor_open;\n    cc->chr_write = gdb_monitor_write;\n}\n\n#define TYPE_CHARDEV_GDB \"chardev-gdb\"\n\nstatic const TypeInfo char_gdb_type_info = {\n    .name = TYPE_CHARDEV_GDB,\n    .parent = TYPE_CHARDEV,\n    .class_init = char_gdb_class_init,\n};\n\nstatic int find_cpu_clusters(Object *child, void *opaque)\n{\n    if (object_dynamic_cast(child, TYPE_CPU_CLUSTER)) {\n        GDBState *s = (GDBState *) opaque;\n        CPUClusterState *cluster = CPU_CLUSTER(child);\n        GDBProcess *process;\n\n        s->processes = g_renew(GDBProcess, s->processes, ++s->process_num);\n\n        process = &s->processes[s->process_num - 1];\n\n        /*\n         * GDB process IDs -1 and 0 are reserved. To avoid subtle errors at\n         * runtime, we enforce here that the machine does not use a cluster ID\n         * that would lead to PID 0.\n         */\n        assert(cluster->cluster_id != UINT32_MAX);\n        process->pid = cluster->cluster_id + 1;\n        process->attached = false;\n        process->target_xml[0] = '\\0';\n\n        return 0;\n    }\n\n    return object_child_foreach(child, find_cpu_clusters, opaque);\n}\n\nstatic int pid_order(const void *a, const void *b)\n{\n    GDBProcess *pa = (GDBProcess *) a;\n    GDBProcess *pb = (GDBProcess *) b;\n\n    if (pa->pid < pb->pid) {\n        return -1;\n    } else if (pa->pid > pb->pid) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nstatic void create_processes(GDBState *s)\n{\n    object_child_foreach(object_get_root(), find_cpu_clusters, s);\n\n    if (gdbserver_state.processes) {\n        /* Sort by PID */\n        qsort(gdbserver_state.processes, gdbserver_state.process_num, sizeof(gdbserver_state.processes[0]), pid_order);\n    }\n\n    create_default_process(s);\n}\n\nint gdbserver_start(const char *device)\n{\n    trace_gdbstub_op_start(device);\n\n    char gdbstub_device_name[128];\n    Chardev *chr = NULL;\n    Chardev *mon_chr;\n\n    if (!first_cpu) {\n        error_report(\"gdbstub: meaningless to attach gdb to a \"\n                     \"machine without any CPU.\");\n        return -1;\n    }\n\n    if (kvm_enabled() && !kvm_supports_guest_debug()) {\n        error_report(\"gdbstub: KVM doesn't support guest debugging\");\n        return -1;\n    }\n\n    if (!device)\n        return -1;\n    if (strcmp(device, \"none\") != 0) {\n        if (strstart(device, \"tcp:\", NULL)) {\n            /* enforce required TCP attributes */\n            snprintf(gdbstub_device_name, sizeof(gdbstub_device_name),\n                     \"%s,wait=off,nodelay=on,server=on\", device);\n            device = gdbstub_device_name;\n        }\n#ifndef _WIN32\n        else if (strcmp(device, \"stdio\") == 0) {\n            struct sigaction act;\n\n            memset(&act, 0, sizeof(act));\n            act.sa_handler = gdb_sigterm_handler;\n            sigaction(SIGINT, &act, NULL);\n        }\n#endif\n        /*\n         * FIXME: it's a bit weird to allow using a mux chardev here\n         * and implicitly setup a monitor. We may want to break this.\n         */\n        chr = qemu_chr_new_noreplay(\"gdb\", device, true, NULL);\n        if (!chr)\n            return -1;\n    }\n\n    if (!gdbserver_state.init) {\n        init_gdbserver_state();\n\n        qemu_add_vm_change_state_handler(gdb_vm_state_change, NULL);\n\n        /* Initialize a monitor terminal for gdb */\n        mon_chr = qemu_chardev_new(NULL, TYPE_CHARDEV_GDB,\n                                   NULL, NULL, &error_abort);\n        monitor_init_hmp(mon_chr, false, &error_abort);\n    } else {\n        qemu_chr_fe_deinit(&gdbserver_state.chr, true);\n        mon_chr = gdbserver_state.mon_chr;\n        reset_gdbserver_state();\n    }\n\n    create_processes(&gdbserver_state);\n\n    if (chr) {\n        qemu_chr_fe_init(&gdbserver_state.chr, chr, &error_abort);\n        qemu_chr_fe_set_handlers(&gdbserver_state.chr, gdb_chr_can_receive,\n                                 gdb_chr_receive, gdb_chr_event,\n                                 NULL, &gdbserver_state, NULL, true);\n    }\n    gdbserver_state.state = chr ? RS_IDLE : RS_INACTIVE;\n    gdbserver_state.mon_chr = mon_chr;\n    gdbserver_state.current_syscall_cb = NULL;\n\n    return 0;\n}\n\nstatic void register_types(void)\n{\n    type_register_static(&char_gdb_type_info);\n}\n\ntype_init(register_types);\n#endif\n"
        },
        {
          "name": "gitdm.config",
          "type": "blob",
          "size": 1.7919921875,
          "content": "#\n# This is the gitdm configuration file for QEMU.\n#\n# It is to be used with LWN's git dataminer tool for generating\n# reports about development activity in the QEMU repo. The LWN gitdm\n# tool can be found at:\n#\n#   git://git.lwn.net/gitdm.git\n#\n# A run to generate a report for the last year of activity would be\n#\n#   git log --numstat --since \"Last Year\" | gitdm -n -l 10\n#\n\n# EmailAliases lets us cope with developers who use more\n# than one address or have changed addresses. This duplicates some of\n# the information in the existing .mailmap but in a slightly different\n# form.\n#\nEmailAliases contrib/gitdm/aliases\n\n#\n# EmailMap does the main work of mapping addresses onto\n# employers.\n#\nEmailMap contrib/gitdm/domain-map\n\n#\n# Use GroupMap to map a file full of addresses to the\n# same employer. This is used for people that don't post from easily\n# identifiable corporate emails. Please keep this list sorted.\n#\n\nGroupMap contrib/gitdm/group-map-cadence Cadence Design Systems\nGroupMap contrib/gitdm/group-map-codeweavers CodeWeavers\nGroupMap contrib/gitdm/group-map-ibm IBM\nGroupMap contrib/gitdm/group-map-janustech Janus Technologies\nGroupMap contrib/gitdm/group-map-netflix Netflix\nGroupMap contrib/gitdm/group-map-redhat Red Hat\nGroupMap contrib/gitdm/group-map-wavecomp Wave Computing\n\n# Also group together our prolific individual contributors\n# and those working under academic or intern auspices\nGroupMap contrib/gitdm/group-map-individuals (None)\nGroupMap contrib/gitdm/group-map-academics Academics (various)\nGroupMap contrib/gitdm/group-map-interns GSoC/Outreachy Interns\n\n# Group together robots and other auto-reporters\nGroupMap contrib/gitdm/group-map-robots Robots (various)\n\n#\n#\n# Use FileTypeMap to map a file types to file names using regular\n# regular expressions.\n#\nFileTypeMap contrib/gitdm/filetypes.txt\n"
        },
        {
          "name": "hmp-commands-info.hx",
          "type": "blob",
          "size": 20.1533203125,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and rST.\nHXCOMM Text between SRST and ERST is copied to the rST version and\nHXCOMM discarded from C version.\nHXCOMM DEF(command, args, callback, arg_string, help) is used to construct\nHXCOMM monitor info commands\nHXCOMM HXCOMM can be used for comments, discarded from both rST and C.\nHXCOMM\nHXCOMM In this file, generally SRST fragments should have two extra\nHXCOMM spaces of indent, so that the documentation list item for \"info foo\"\nHXCOMM appears inside the documentation list item for the top level\nHXCOMM \"info\" documentation entry. The exception is the first SRST\nHXCOMM fragment that defines that top level entry.\n\nSRST\n``info`` *subcommand*\n  Show various information about the system state.\n\nERST\n\n    {\n        .name       = \"version\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the version of QEMU\",\n        .cmd        = hmp_info_version,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info version``\n    Show the version of QEMU.\nERST\n\n    {\n        .name       = \"network\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the network state\",\n        .cmd        = hmp_info_network,\n    },\n\nSRST\n  ``info network``\n    Show the network state.\nERST\n\n    {\n        .name       = \"chardev\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the character devices\",\n        .cmd        = hmp_info_chardev,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info chardev``\n    Show the character devices.\nERST\n\n    {\n        .name       = \"block\",\n        .args_type  = \"nodes:-n,verbose:-v,device:B?\",\n        .params     = \"[-n] [-v] [device]\",\n        .help       = \"show info of one block device or all block devices \"\n                      \"(-n: show named nodes; -v: show details)\",\n        .cmd        = hmp_info_block,\n    },\n\nSRST\n  ``info block``\n    Show info of one block device or all block devices.\nERST\n\n    {\n        .name       = \"blockstats\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show block device statistics\",\n        .cmd        = hmp_info_blockstats,\n    },\n\nSRST\n  ``info blockstats``\n    Show block device statistics.\nERST\n\n    {\n        .name       = \"block-jobs\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show progress of ongoing block device operations\",\n        .cmd        = hmp_info_block_jobs,\n    },\n\nSRST\n  ``info block-jobs``\n    Show progress of ongoing block device operations.\nERST\n\n    {\n        .name       = \"registers\",\n        .args_type  = \"cpustate_all:-a\",\n        .params     = \"[-a]\",\n        .help       = \"show the cpu registers (-a: all - show register info for all cpus)\",\n        .cmd        = hmp_info_registers,\n    },\n\nSRST\n  ``info registers``\n    Show the cpu registers.\nERST\n\n#if defined(TARGET_I386)\n    {\n        .name       = \"lapic\",\n        .args_type  = \"apic-id:i?\",\n        .params     = \"[apic-id]\",\n        .help       = \"show local apic state (apic-id: local apic to read, default is which of current CPU)\",\n\n        .cmd        = hmp_info_local_apic,\n    },\n#endif\n\nSRST\n  ``info lapic``\n    Show local APIC state\nERST\n\n    {\n        .name       = \"cpus\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show infos for each CPU\",\n        .cmd        = hmp_info_cpus,\n    },\n\nSRST\n  ``info cpus``\n    Show infos for each CPU.\nERST\n\n    {\n        .name       = \"history\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the command line history\",\n        .cmd        = hmp_info_history,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info history``\n    Show the command line history.\nERST\n\n    {\n        .name       = \"irq\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the interrupts statistics (if available)\",\n        .cmd_info_hrt = qmp_x_query_irq,\n    },\n\nSRST\n  ``info irq``\n    Show the interrupts statistics (if available).\nERST\n\n    {\n        .name       = \"pic\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show PIC state\",\n        .cmd        = hmp_info_pic,\n    },\n\nSRST\n  ``info pic``\n    Show PIC state.\nERST\n\n    {\n        .name       = \"rdma\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show RDMA state\",\n        .cmd_info_hrt = qmp_x_query_rdma,\n    },\n\nSRST\n  ``info rdma``\n    Show RDMA state.\nERST\n\n    {\n        .name       = \"pci\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show PCI info\",\n        .cmd        = hmp_info_pci,\n    },\n\nSRST\n  ``info pci``\n    Show PCI information.\nERST\n\n#if defined(TARGET_I386) || defined(TARGET_SH4) || defined(TARGET_SPARC) || \\\n    defined(TARGET_PPC) || defined(TARGET_XTENSA) || defined(TARGET_M68K)\n    {\n        .name       = \"tlb\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show virtual to physical memory mappings\",\n        .cmd        = hmp_info_tlb,\n    },\n#endif\n\nSRST\n  ``info tlb``\n    Show virtual to physical memory mappings.\nERST\n\n#if defined(TARGET_I386) || defined(TARGET_RISCV)\n    {\n        .name       = \"mem\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the active virtual memory mappings\",\n        .cmd        = hmp_info_mem,\n    },\n#endif\n\nSRST\n  ``info mem``\n    Show the active virtual memory mappings.\nERST\n\n    {\n        .name       = \"mtree\",\n        .args_type  = \"flatview:-f,dispatch_tree:-d,owner:-o,disabled:-D\",\n        .params     = \"[-f][-d][-o][-D]\",\n        .help       = \"show memory tree (-f: dump flat view for address spaces;\"\n                      \"-d: dump dispatch tree, valid with -f only);\"\n                      \"-o: dump region owners/parents;\"\n                      \"-D: dump disabled regions\",\n        .cmd        = hmp_info_mtree,\n    },\n\nSRST\n  ``info mtree``\n    Show memory tree.\nERST\n\n#if defined(CONFIG_TCG)\n    {\n        .name       = \"jit\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show dynamic compiler info\",\n    },\n#endif\n\nSRST\n  ``info jit``\n    Show dynamic compiler info.\nERST\n\n#if defined(CONFIG_TCG)\n    {\n        .name       = \"opcount\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show dynamic compiler opcode counters\",\n    },\n#endif\n\nSRST\n  ``info opcount``\n    Show dynamic compiler opcode counters\nERST\n\n    {\n        .name       = \"sync-profile\",\n        .args_type  = \"mean:-m,no_coalesce:-n,max:i?\",\n        .params     = \"[-m] [-n] [max]\",\n        .help       = \"show synchronization profiling info, up to max entries \"\n                      \"(default: 10), sorted by total wait time. (-m: sort by \"\n                      \"mean wait time; -n: do not coalesce objects with the \"\n                      \"same call site)\",\n        .cmd        = hmp_info_sync_profile,\n    },\n\nSRST\n  ``info sync-profile [-m|-n]`` [*max*]\n    Show synchronization profiling info, up to *max* entries (default: 10),\n    sorted by total wait time.\n\n    ``-m``\n      sort by mean wait time\n    ``-n``\n      do not coalesce objects with the same call site\n\n    When different objects that share the same call site are coalesced,\n    the \"Object\" field shows---enclosed in brackets---the number of objects\n    being coalesced.\nERST\n\n    {\n        .name       = \"kvm\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show KVM information\",\n        .cmd        = hmp_info_kvm,\n    },\n\nSRST\n  ``info kvm``\n    Show KVM information.\nERST\n\n    {\n        .name       = \"numa\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show NUMA information\",\n        .cmd_info_hrt = qmp_x_query_numa,\n    },\n\nSRST\n  ``info numa``\n    Show NUMA information.\nERST\n\n    {\n        .name       = \"usb\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show guest USB devices\",\n        .cmd_info_hrt = qmp_x_query_usb,\n    },\n\nSRST\n  ``info usb``\n    Show guest USB devices.\nERST\n\n    {\n        .name       = \"usbhost\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show host USB devices\",\n    },\n\nSRST\n  ``info usbhost``\n    Show host USB devices.\nERST\n\n#if defined(CONFIG_TCG)\n    {\n        .name       = \"profile\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show profiling information\",\n        .cmd_info_hrt = qmp_x_query_profile,\n    },\n#endif\n\nSRST\n  ``info profile``\n    Show profiling information.\nERST\n\n    {\n        .name       = \"capture\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show capture information\",\n        .cmd        = hmp_info_capture,\n    },\n\nSRST\n  ``info capture``\n    Show capture information.\nERST\n\n    {\n        .name       = \"snapshots\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the currently saved VM snapshots\",\n        .cmd        = hmp_info_snapshots,\n    },\n\nSRST\n  ``info snapshots``\n    Show the currently saved VM snapshots.\nERST\n\n    {\n        .name       = \"status\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the current VM status (running|paused)\",\n        .cmd        = hmp_info_status,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info status``\n    Show the current VM status (running|paused).\nERST\n\n    {\n        .name       = \"mice\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show which guest mouse is receiving events\",\n        .cmd        = hmp_info_mice,\n    },\n\nSRST\n  ``info mice``\n    Show which guest mouse is receiving events.\nERST\n\n#if defined(CONFIG_VNC)\n    {\n        .name       = \"vnc\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the vnc server status\",\n        .cmd        = hmp_info_vnc,\n    },\n#endif\n\nSRST\n  ``info vnc``\n    Show the vnc server status.\nERST\n\n#if defined(CONFIG_SPICE)\n    {\n        .name       = \"spice\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the spice server status\",\n        .cmd        = hmp_info_spice,\n    },\n#endif\n\nSRST\n  ``info spice``\n    Show the spice server status.\nERST\n\n    {\n        .name       = \"name\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the current VM name\",\n        .cmd        = hmp_info_name,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info name``\n    Show the current VM name.\nERST\n\n    {\n        .name       = \"uuid\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the current VM UUID\",\n        .cmd        = hmp_info_uuid,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info uuid``\n    Show the current VM UUID.\nERST\n\n#if defined(CONFIG_SLIRP)\n    {\n        .name       = \"usernet\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show user network stack connection states\",\n        .cmd        = hmp_info_usernet,\n    },\n#endif\n\nSRST\n  ``info usernet``\n    Show user network stack connection states.\nERST\n\n    {\n        .name       = \"migrate\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show migration status\",\n        .cmd        = hmp_info_migrate,\n    },\n\nSRST\n  ``info migrate``\n    Show migration status.\nERST\n\n    {\n        .name       = \"migrate_capabilities\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show current migration capabilities\",\n        .cmd        = hmp_info_migrate_capabilities,\n    },\n\nSRST\n  ``info migrate_capabilities``\n    Show current migration capabilities.\nERST\n\n    {\n        .name       = \"migrate_parameters\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show current migration parameters\",\n        .cmd        = hmp_info_migrate_parameters,\n    },\n\nSRST\n  ``info migrate_parameters``\n    Show current migration parameters.\nERST\n\n    {\n        .name       = \"balloon\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show balloon information\",\n        .cmd        = hmp_info_balloon,\n    },\n\nSRST\n  ``info balloon``\n    Show balloon information.\nERST\n\n    {\n        .name       = \"qtree\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show device tree\",\n        .cmd        = hmp_info_qtree,\n    },\n\nSRST\n  ``info qtree``\n    Show device tree.\nERST\n\n    {\n        .name       = \"qdm\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show qdev device model list\",\n        .cmd        = hmp_info_qdm,\n    },\n\nSRST\n  ``info qdm``\n    Show qdev device model list.\nERST\n\n    {\n        .name       = \"qom-tree\",\n        .args_type  = \"path:s?\",\n        .params     = \"[path]\",\n        .help       = \"show QOM composition tree\",\n        .cmd        = hmp_info_qom_tree,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info qom-tree``\n    Show QOM composition tree.\nERST\n\n    {\n        .name       = \"roms\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show roms\",\n        .cmd_info_hrt = qmp_x_query_roms,\n    },\n\nSRST\n  ``info roms``\n    Show roms.\nERST\n\n    {\n        .name       = \"trace-events\",\n        .args_type  = \"name:s?,vcpu:i?\",\n        .params     = \"[name] [vcpu]\",\n        .help       = \"show available trace-events & their state \"\n                      \"(name: event name pattern; vcpu: vCPU to query, default is any)\",\n        .cmd = hmp_info_trace_events,\n        .command_completion = info_trace_events_completion,\n    },\n\nSRST\n  ``info trace-events``\n    Show available trace-events & their state.\nERST\n\n    {\n        .name       = \"tpm\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the TPM device\",\n        .cmd        = hmp_info_tpm,\n    },\n\nSRST\n  ``info tpm``\n    Show the TPM device.\nERST\n\n    {\n        .name       = \"memdev\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show memory backends\",\n        .cmd        = hmp_info_memdev,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info memdev``\n    Show memory backends\nERST\n\n    {\n        .name       = \"memory-devices\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show memory devices\",\n        .cmd        = hmp_info_memory_devices,\n    },\n\nSRST\n  ``info memory-devices``\n    Show memory devices.\nERST\n\n    {\n        .name       = \"iothreads\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show iothreads\",\n        .cmd        = hmp_info_iothreads,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info iothreads``\n    Show iothread's identifiers.\nERST\n\n    {\n        .name       = \"rocker\",\n        .args_type  = \"name:s\",\n        .params     = \"name\",\n        .help       = \"Show rocker switch\",\n        .cmd        = hmp_rocker,\n    },\n\nSRST\n  ``info rocker`` *name*\n    Show rocker switch.\nERST\n\n    {\n        .name       = \"rocker-ports\",\n        .args_type  = \"name:s\",\n        .params     = \"name\",\n        .help       = \"Show rocker ports\",\n        .cmd        = hmp_rocker_ports,\n    },\n\nSRST\n  ``info rocker-ports`` *name*-ports\n    Show rocker ports.\nERST\n\n    {\n        .name       = \"rocker-of-dpa-flows\",\n        .args_type  = \"name:s,tbl_id:i?\",\n        .params     = \"name [tbl_id]\",\n        .help       = \"Show rocker OF-DPA flow tables\",\n        .cmd        = hmp_rocker_of_dpa_flows,\n    },\n\nSRST\n  ``info rocker-of-dpa-flows`` *name* [*tbl_id*]\n    Show rocker OF-DPA flow tables.\nERST\n\n    {\n        .name       = \"rocker-of-dpa-groups\",\n        .args_type  = \"name:s,type:i?\",\n        .params     = \"name [type]\",\n        .help       = \"Show rocker OF-DPA groups\",\n        .cmd        = hmp_rocker_of_dpa_groups,\n    },\n\nSRST\n  ``info rocker-of-dpa-groups`` *name* [*type*]\n    Show rocker OF-DPA groups.\nERST\n\n#if defined(TARGET_S390X)\n    {\n        .name       = \"skeys\",\n        .args_type  = \"addr:l\",\n        .params     = \"address\",\n        .help       = \"Display the value of a storage key\",\n        .cmd        = hmp_info_skeys,\n    },\n#endif\n\nSRST\n  ``info skeys`` *address*\n    Display the value of a storage key (s390 only)\nERST\n\n#if defined(TARGET_S390X)\n    {\n        .name       = \"cmma\",\n        .args_type  = \"addr:l,count:l?\",\n        .params     = \"address [count]\",\n        .help       = \"Display the values of the CMMA storage attributes for a range of pages\",\n        .cmd        = hmp_info_cmma,\n    },\n#endif\n\nSRST\n  ``info cmma`` *address*\n    Display the values of the CMMA storage attributes for a range of\n    pages (s390 only)\nERST\n\n    {\n        .name       = \"dump\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Display the latest dump status\",\n        .cmd        = hmp_info_dump,\n    },\n\nSRST\n  ``info dump``\n    Display the latest dump status.\nERST\n\n    {\n        .name       = \"ramblock\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Display system ramblock information\",\n        .cmd_info_hrt = qmp_x_query_ramblock,\n    },\n\nSRST\n  ``info ramblock``\n    Dump all the ramblocks of the system.\nERST\n\n    {\n        .name       = \"hotpluggable-cpus\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Show information about hotpluggable CPUs\",\n        .cmd        = hmp_hotpluggable_cpus,\n        .flags      = \"p\",\n    },\n\nSRST\n  ``info hotpluggable-cpus``\n    Show information about hotpluggable CPUs\nERST\n\n    {\n        .name       = \"vm-generation-id\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Show Virtual Machine Generation ID\",\n        .cmd = hmp_info_vm_generation_id,\n    },\n\nSRST\n  ``info vm-generation-id``\n    Show Virtual Machine Generation ID\nERST\n\n    {\n        .name       = \"memory_size_summary\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show the amount of initially allocated and \"\n                      \"present hotpluggable (if enabled) memory in bytes.\",\n        .cmd        = hmp_info_memory_size_summary,\n    },\n\nSRST\n  ``info memory_size_summary``\n    Display the amount of initially allocated and present hotpluggable (if\n    enabled) memory in bytes.\nERST\n\n#if defined(TARGET_I386)\n    {\n        .name       = \"sev\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show SEV information\",\n        .cmd        = hmp_info_sev,\n    },\n#endif\n\nSRST\n  ``info sev``\n    Show SEV information.\nERST\n\n    {\n        .name       = \"replay\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show record/replay information\",\n        .cmd        = hmp_info_replay,\n    },\n\nSRST\n  ``info replay``\n    Display the record/replay information: mode and the current icount.\nERST\n\n    {\n        .name       = \"dirty_rate\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show dirty rate information\",\n        .cmd        = hmp_info_dirty_rate,\n    },\n\nSRST\n  ``info dirty_rate``\n    Display the vcpu dirty rate information.\nERST\n\n    {\n        .name       = \"vcpu_dirty_limit\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show dirty page limit information of all vCPU\",\n        .cmd        = hmp_info_vcpu_dirty_limit,\n    },\n\nSRST\n  ``info vcpu_dirty_limit``\n    Display the vcpu dirty page limit information.\nERST\n\n#if defined(TARGET_I386)\n    {\n        .name       = \"sgx\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"show intel SGX information\",\n        .cmd        = hmp_info_sgx,\n    },\n#endif\n\nSRST\n  ``info sgx``\n    Show intel SGX information.\nERST\n\n#if defined(CONFIG_MOS6522)\n    {\n        .name         = \"via\",\n        .args_type    = \"\",\n        .params       = \"\",\n        .help         = \"show guest mos6522 VIA devices\",\n        .cmd          = hmp_info_via,\n    },\n#endif\n\nSRST\n  ``info via``\n    Show guest mos6522 VIA devices.\nERST\n\n#if defined(TARGET_AARCH64)\n    {\n        .name         = \"dart\",\n        .args_type    = \"name:s?\",\n        .params       = \"[name]\",\n        .help         = \"show guest Apple DART IOMMUs\",\n        .cmd          = hmp_info_dart,\n    },\n#endif\n\nSRST\n  ``info dart``\n    Show guest Apple DART IOMMUs.\nERST\n\n    {\n        .name       = \"stats\",\n        .args_type  = \"target:s,names:s?,provider:s?\",\n        .params     = \"target [names] [provider]\",\n        .help       = \"show statistics for the given target (vm or vcpu); optionally filter by\"\n                      \"name (comma-separated list, or * for all) and provider\",\n        .cmd        = hmp_info_stats,\n    },\n\nSRST\n  ``stats``\n    Show runtime-collected statistics\nERST\n"
        },
        {
          "name": "hmp-commands.hx",
          "type": "blob",
          "size": 52.8671875,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and rST.\nHXCOMM Text between SRST and ERST is copied to the rST version and\nHXCOMM discarded from C version.\nHXCOMM DEF(command, args, callback, arg_string, help) is used to construct\nHXCOMM monitor commands\nHXCOMM HXCOMM can be used for comments, discarded from both rST and C.\n\n\n    {\n        .name       = \"help|?\",\n        .args_type  = \"name:S?\",\n        .params     = \"[cmd]\",\n        .help       = \"show the help\",\n        .cmd        = do_help_cmd,\n        .flags      = \"p\",\n    },\n\nSRST\n``help`` or ``?`` [*cmd*]\n  Show the help for all commands or just for command *cmd*.\nERST\n\n    {\n        .name       = \"commit\",\n        .args_type  = \"device:B\",\n        .params     = \"device|all\",\n        .help       = \"commit changes to the disk images (if -snapshot is used) or backing files\",\n        .cmd        = hmp_commit,\n    },\n\nSRST\n``commit``\n  Commit changes to the disk images (if -snapshot is used) or backing files.\n  If the backing file is smaller than the snapshot, then the backing file\n  will be resized to be the same size as the snapshot.  If the snapshot is\n  smaller than the backing file, the backing file will not be truncated.\n  If you want the backing file to match the size of the smaller snapshot,\n  you can safely truncate it yourself once the commit operation successfully\n  completes.\nERST\n\n    {\n        .name       = \"quit|q\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"quit the emulator\",\n        .cmd        = hmp_quit,\n        .flags      = \"p\",\n    },\n\nSRST\n``quit`` or ``q``\n  Quit the emulator.\nERST\n\n    {\n        .name       = \"exit_preconfig\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"exit the preconfig state\",\n        .cmd        = hmp_exit_preconfig,\n        .flags      = \"p\",\n    },\n\nSRST\n``exit_preconfig``\n  This command makes QEMU exit the preconfig state and proceed with\n  VM initialization using configuration data provided on the command line\n  and via the QMP monitor during the preconfig state. The command is only\n  available during the preconfig state (i.e. when the --preconfig command\n  line option was in use).\nERST\n\n    {\n        .name       = \"block_resize\",\n        .args_type  = \"device:B,size:o\",\n        .params     = \"device size\",\n        .help       = \"resize a block image\",\n        .cmd        = hmp_block_resize,\n        .coroutine  = true,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_resize``\n  Resize a block image while a guest is running.  Usually requires guest\n  action to see the updated size.  Resize to a lower size is supported,\n  but should be used with extreme caution.  Note that this command only\n  resizes image files, it can not resize block devices like LVM volumes.\nERST\n\n    {\n        .name       = \"block_stream\",\n        .args_type  = \"device:B,speed:o?,base:s?\",\n        .params     = \"device [speed [base]]\",\n        .help       = \"copy data from a backing file into a block device\",\n        .cmd        = hmp_block_stream,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_stream``\n  Copy data from a backing file into a block device.\nERST\n\n    {\n        .name       = \"block_job_set_speed\",\n        .args_type  = \"device:B,speed:o\",\n        .params     = \"device speed\",\n        .help       = \"set maximum speed for a background block operation\",\n        .cmd        = hmp_block_job_set_speed,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_job_set_speed``\n  Set maximum speed for a background block operation.\nERST\n\n    {\n        .name       = \"block_job_cancel\",\n        .args_type  = \"force:-f,device:B\",\n        .params     = \"[-f] device\",\n        .help       = \"stop an active background block operation (use -f\"\n                      \"\\n\\t\\t\\t if you want to abort the operation immediately\"\n                      \"\\n\\t\\t\\t instead of keep running until data is in sync)\",\n        .cmd        = hmp_block_job_cancel,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_job_cancel``\n  Stop an active background block operation (streaming, mirroring).\nERST\n\n    {\n        .name       = \"block_job_complete\",\n        .args_type  = \"device:B\",\n        .params     = \"device\",\n        .help       = \"stop an active background block operation\",\n        .cmd        = hmp_block_job_complete,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_job_complete``\n  Manually trigger completion of an active background block operation.\n  For mirroring, this will switch the device to the destination path.\nERST\n\n    {\n        .name       = \"block_job_pause\",\n        .args_type  = \"device:B\",\n        .params     = \"device\",\n        .help       = \"pause an active background block operation\",\n        .cmd        = hmp_block_job_pause,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_job_pause``\n  Pause an active block streaming operation.\nERST\n\n    {\n        .name       = \"block_job_resume\",\n        .args_type  = \"device:B\",\n        .params     = \"device\",\n        .help       = \"resume a paused background block operation\",\n        .cmd        = hmp_block_job_resume,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_job_resume``\n  Resume a paused block streaming operation.\nERST\n\n    {\n        .name       = \"eject\",\n        .args_type  = \"force:-f,device:B\",\n        .params     = \"[-f] device\",\n        .help       = \"eject a removable medium (use -f to force it)\",\n        .cmd        = hmp_eject,\n    },\n\nSRST\n``eject [-f]`` *device*\n  Eject a removable medium (use -f to force it).\nERST\n\n    {\n        .name       = \"drive_del\",\n        .args_type  = \"id:B\",\n        .params     = \"device\",\n        .help       = \"remove host block device\",\n        .cmd        = hmp_drive_del,\n    },\n\nSRST\n``drive_del`` *device*\n  Remove host block device.  The result is that guest generated IO is no longer\n  submitted against the host device underlying the disk.  Once a drive has\n  been deleted, the QEMU Block layer returns -EIO which results in IO\n  errors in the guest for applications that are reading/writing to the device.\n  These errors are always reported to the guest, regardless of the drive's error\n  actions (drive options rerror, werror).\nERST\n\n    {\n        .name       = \"change\",\n        .args_type  = \"device:B,force:-f,target:F,arg:s?,read-only-mode:s?\",\n        .params     = \"device [-f] filename [format [read-only-mode]]\",\n        .help       = \"change a removable medium, optional format, use -f to force the operation\",\n        .cmd        = hmp_change,\n    },\n\nSRST\n``change`` *device* *setting*\n  Change the configuration of a device.\n\n  ``change`` *diskdevice* [-f] *filename* [*format* [*read-only-mode*]]\n    Change the medium for a removable disk device to point to *filename*. eg::\n\n      (qemu) change ide1-cd0 /path/to/some.iso\n\n    ``-f``\n      forces the operation even if the guest has locked the tray.\n\n    *format* is optional.\n\n    *read-only-mode* may be used to change the read-only status of the device.\n    It accepts the following values:\n\n    retain\n      Retains the current status; this is the default.\n\n    read-only\n      Makes the device read-only.\n\n    read-write\n      Makes the device writable.\n\n  ``change vnc password`` [*password*]\n\n    Change the password associated with the VNC server. If the new password\n    is not supplied, the monitor will prompt for it to be entered. VNC\n    passwords are only significant up to 8 letters. eg::\n\n      (qemu) change vnc password\n      Password: ********\n\nERST\n\n    {\n        .name       = \"screendump\",\n        .args_type  = \"filename:F,format:-fs,device:s?,head:i?\",\n        .params     = \"filename [-f format] [device [head]]\",\n        .help       = \"save screen from head 'head' of display device 'device'\"\n                      \"in specified format 'format' as image 'filename'.\"\n                      \"Currently only 'png' and 'ppm' formats are supported.\",\n         .cmd        = hmp_screendump,\n        .coroutine  = true,\n    },\n\nSRST\n``screendump`` *filename*\n  Save screen into PPM image *filename*.\nERST\n\n    {\n        .name       = \"logfile\",\n        .args_type  = \"filename:F\",\n        .params     = \"filename\",\n        .help       = \"output logs to 'filename'\",\n        .cmd        = hmp_logfile,\n    },\n\nSRST\n``logfile`` *filename*\n  Output logs to *filename*.\nERST\n\n    {\n        .name       = \"trace-event\",\n        .args_type  = \"name:s,option:b,vcpu:i?\",\n        .params     = \"name on|off [vcpu]\",\n        .help       = \"changes status of a specific trace event \"\n                      \"(vcpu: vCPU to set, default is all)\",\n        .cmd = hmp_trace_event,\n        .command_completion = trace_event_completion,\n    },\n\nSRST\n``trace-event``\n  changes status of a trace event\nERST\n\n#if defined(CONFIG_TRACE_SIMPLE)\n    {\n        .name       = \"trace-file\",\n        .args_type  = \"op:s?,arg:F?\",\n        .params     = \"on|off|flush|set [arg]\",\n        .help       = \"open, close, or flush trace file, or set a new file name\",\n        .cmd        = hmp_trace_file,\n    },\n\nSRST\n``trace-file on|off|flush``\n  Open, close, or flush the trace file.  If no argument is given, the\n  status of the trace file is displayed.\nERST\n#endif\n\n    {\n        .name       = \"log\",\n        .args_type  = \"items:s\",\n        .params     = \"item1[,...]\",\n        .help       = \"activate logging of the specified items\",\n        .cmd        = hmp_log,\n    },\n\nSRST\n``log`` *item1*\\ [,...]\n  Activate logging of the specified items.\nERST\n\n    {\n        .name       = \"savevm\",\n        .args_type  = \"name:s?\",\n        .params     = \"tag\",\n        .help       = \"save a VM snapshot. If no tag is provided, a new snapshot is created\",\n        .cmd        = hmp_savevm,\n    },\n\nSRST\n``savevm`` *tag*\n  Create a snapshot of the whole virtual machine. If *tag* is\n  provided, it is used as human readable identifier. If there is already\n  a snapshot with the same tag, it is replaced. More info at\n  :ref:`vm_005fsnapshots`.\n\n  Since 4.0, savevm stopped allowing the snapshot id to be set, accepting\n  only *tag* as parameter.\nERST\n\n    {\n        .name       = \"loadvm\",\n        .args_type  = \"name:s\",\n        .params     = \"tag\",\n        .help       = \"restore a VM snapshot from its tag\",\n        .cmd        = hmp_loadvm,\n        .command_completion = loadvm_completion,\n    },\n\nSRST\n``loadvm`` *tag*\n  Set the whole virtual machine to the snapshot identified by the tag\n  *tag*.\n\n  Since 4.0, loadvm stopped accepting snapshot id as parameter.\nERST\n\n    {\n        .name       = \"delvm\",\n        .args_type  = \"name:s\",\n        .params     = \"tag\",\n        .help       = \"delete a VM snapshot from its tag\",\n        .cmd        = hmp_delvm,\n        .command_completion = delvm_completion,\n    },\n\nSRST\n``delvm`` *tag*\n  Delete the snapshot identified by *tag*.\n\n  Since 4.0, delvm stopped deleting snapshots by snapshot id, accepting\n  only *tag* as parameter.\nERST\n\n    {\n        .name       = \"singlestep\",\n        .args_type  = \"option:s?\",\n        .params     = \"[on|off]\",\n        .help       = \"run emulation in singlestep mode or switch to normal mode\",\n        .cmd        = hmp_singlestep,\n    },\n\nSRST\n``singlestep [off]``\n  Run the emulation in single step mode.\n  If called with option off, the emulation returns to normal mode.\nERST\n\n    {\n        .name       = \"stop|s\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"stop emulation\",\n        .cmd        = hmp_stop,\n    },\n\nSRST\n``stop`` or ``s``\n  Stop emulation.\nERST\n\n    {\n        .name       = \"cont|c\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"resume emulation\",\n        .cmd        = hmp_cont,\n    },\n\nSRST\n``cont`` or ``c``\n  Resume emulation.\nERST\n\n    {\n        .name       = \"system_wakeup\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"wakeup guest from suspend\",\n        .cmd        = hmp_system_wakeup,\n    },\n\nSRST\n``system_wakeup``\n  Wakeup guest from suspend.\nERST\n\n    {\n        .name       = \"gdbserver\",\n        .args_type  = \"device:s?\",\n        .params     = \"[device]\",\n        .help       = \"start gdbserver on given device (default 'tcp::1234'), stop with 'none'\",\n        .cmd        = hmp_gdbserver,\n    },\n\nSRST\n``gdbserver`` [*port*]\n  Start gdbserver session (default *port*\\=1234)\nERST\n\n    {\n        .name       = \"x\",\n        .args_type  = \"fmt:/,addr:l\",\n        .params     = \"/fmt addr\",\n        .help       = \"virtual memory dump starting at 'addr'\",\n        .cmd        = hmp_memory_dump,\n    },\n\nSRST\n``x/``\\ *fmt* *addr*\n  Virtual memory dump starting at *addr*.\nERST\n\n    {\n        .name       = \"xp\",\n        .args_type  = \"fmt:/,addr:l\",\n        .params     = \"/fmt addr\",\n        .help       = \"physical memory dump starting at 'addr'\",\n        .cmd        = hmp_physical_memory_dump,\n    },\n\nSRST\n``xp /``\\ *fmt* *addr*\n  Physical memory dump starting at *addr*.\n\n  *fmt* is a format which tells the command how to format the\n  data. Its syntax is: ``/{count}{format}{size}``\n\n  *count*\n    is the number of items to be dumped.\n  *format*\n    can be x (hex), d (signed decimal), u (unsigned decimal), o (octal),\n    c (char) or i (asm instruction).\n  *size*\n    can be b (8 bits), h (16 bits), w (32 bits) or g (64 bits). On x86,\n    ``h`` or ``w`` can be specified with the ``i`` format to\n    respectively select 16 or 32 bit code instruction size.\n\n  Examples:\n\n  Dump 10 instructions at the current instruction pointer::\n\n    (qemu) x/10i $eip\n    0x90107063:  ret\n    0x90107064:  sti\n    0x90107065:  lea    0x0(%esi,1),%esi\n    0x90107069:  lea    0x0(%edi,1),%edi\n    0x90107070:  ret\n    0x90107071:  jmp    0x90107080\n    0x90107073:  nop\n    0x90107074:  nop\n    0x90107075:  nop\n    0x90107076:  nop\n\n  Dump 80 16 bit values at the start of the video memory::\n\n    (qemu) xp/80hx 0xb8000\n    0x000b8000: 0x0b50 0x0b6c 0x0b65 0x0b78 0x0b38 0x0b36 0x0b2f 0x0b42\n    0x000b8010: 0x0b6f 0x0b63 0x0b68 0x0b73 0x0b20 0x0b56 0x0b47 0x0b41\n    0x000b8020: 0x0b42 0x0b69 0x0b6f 0x0b73 0x0b20 0x0b63 0x0b75 0x0b72\n    0x000b8030: 0x0b72 0x0b65 0x0b6e 0x0b74 0x0b2d 0x0b63 0x0b76 0x0b73\n    0x000b8040: 0x0b20 0x0b30 0x0b35 0x0b20 0x0b4e 0x0b6f 0x0b76 0x0b20\n    0x000b8050: 0x0b32 0x0b30 0x0b30 0x0b33 0x0720 0x0720 0x0720 0x0720\n    0x000b8060: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n    0x000b8070: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n    0x000b8080: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n    0x000b8090: 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720 0x0720\n\nERST\n\n    {\n        .name       = \"gpa2hva\",\n        .args_type  = \"addr:l\",\n        .params     = \"addr\",\n        .help       = \"print the host virtual address corresponding to a guest physical address\",\n        .cmd        = hmp_gpa2hva,\n    },\n\nSRST\n``gpa2hva`` *addr*\n  Print the host virtual address at which the guest's physical address *addr*\n  is mapped.\nERST\n\n#ifdef CONFIG_LINUX\n    {\n        .name       = \"gpa2hpa\",\n        .args_type  = \"addr:l\",\n        .params     = \"addr\",\n        .help       = \"print the host physical address corresponding to a guest physical address\",\n        .cmd        = hmp_gpa2hpa,\n    },\n#endif\n\nSRST\n``gpa2hpa`` *addr*\n  Print the host physical address at which the guest's physical address *addr*\n  is mapped.\nERST\n\n    {\n        .name       = \"gva2gpa\",\n        .args_type  = \"addr:l\",\n        .params     = \"addr\",\n        .help       = \"print the guest physical address corresponding to a guest virtual address\",\n        .cmd        = hmp_gva2gpa,\n    },\n\nSRST\n``gva2gpa`` *addr*\n  Print the guest physical address at which the guest's virtual address *addr*\n  is mapped based on the mapping for the current CPU.\nERST\n\n    {\n        .name       = \"print|p\",\n        .args_type  = \"fmt:/,val:l\",\n        .params     = \"/fmt expr\",\n        .help       = \"print expression value (use $reg for CPU register access)\",\n        .cmd        = do_print,\n    },\n\nSRST\n``print`` or ``p/``\\ *fmt* *expr*\n  Print expression value. Only the *format* part of *fmt* is\n  used.\nERST\n\n    {\n        .name       = \"i\",\n        .args_type  = \"fmt:/,addr:i,index:i.\",\n        .params     = \"/fmt addr\",\n        .help       = \"I/O port read\",\n        .cmd        = hmp_ioport_read,\n    },\n\nSRST\n``i/``\\ *fmt* *addr* [.\\ *index*\\ ]\n  Read I/O port.\nERST\n\n    {\n        .name       = \"o\",\n        .args_type  = \"fmt:/,addr:i,val:i\",\n        .params     = \"/fmt addr value\",\n        .help       = \"I/O port write\",\n        .cmd        = hmp_ioport_write,\n    },\n\nSRST\n``o/``\\ *fmt* *addr* *val*\n  Write to I/O port.\nERST\n\n    {\n        .name       = \"sendkey\",\n        .args_type  = \"keys:s,hold-time:i?\",\n        .params     = \"keys [hold_ms]\",\n        .help       = \"send keys to the VM (e.g. 'sendkey ctrl-alt-f1', default hold time=100 ms)\",\n        .cmd        = hmp_sendkey,\n        .command_completion = sendkey_completion,\n    },\n\nSRST\n``sendkey`` *keys*\n  Send *keys* to the guest. *keys* could be the name of the\n  key or the raw value in hexadecimal format. Use ``-`` to press\n  several keys simultaneously. Example::\n\n    sendkey ctrl-alt-f1\n\n  This command is useful to send keys that your graphical user interface\n  intercepts at low level, such as ``ctrl-alt-f1`` in X Window.\nERST\n    {\n        .name       = \"sync-profile\",\n        .args_type  = \"op:s?\",\n        .params     = \"[on|off|reset]\",\n        .help       = \"enable, disable or reset synchronization profiling. \"\n                      \"With no arguments, prints whether profiling is on or off.\",\n        .cmd        = hmp_sync_profile,\n    },\n\nSRST\n``sync-profile [on|off|reset]``\n  Enable, disable or reset synchronization profiling. With no arguments, prints\n  whether profiling is on or off.\nERST\n\n    {\n        .name       = \"system_reset\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"reset the system\",\n        .cmd        = hmp_system_reset,\n    },\n\nSRST\n``system_reset``\n  Reset the system.\nERST\n\n    {\n        .name       = \"system_powerdown\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"send system power down event\",\n        .cmd        = hmp_system_powerdown,\n    },\n\nSRST\n``system_powerdown``\n  Power down the system (if supported).\nERST\n\n    {\n        .name       = \"sum\",\n        .args_type  = \"start:i,size:i\",\n        .params     = \"addr size\",\n        .help       = \"compute the checksum of a memory region\",\n        .cmd        = hmp_sum,\n    },\n\nSRST\n``sum`` *addr* *size*\n  Compute the checksum of a memory region.\nERST\n\n    {\n        .name       = \"device_add\",\n        .args_type  = \"device:O\",\n        .params     = \"driver[,prop=value][,...]\",\n        .help       = \"add device, like -device on the command line\",\n        .cmd        = hmp_device_add,\n        .command_completion = device_add_completion,\n    },\n\nSRST\n``device_add`` *config*\n  Add device.\nERST\n\n    {\n        .name       = \"device_del\",\n        .args_type  = \"id:s\",\n        .params     = \"device\",\n        .help       = \"remove device\",\n        .cmd        = hmp_device_del,\n        .command_completion = device_del_completion,\n    },\n\nSRST\n``device_del`` *id*\n  Remove device *id*. *id* may be a short ID\n  or a QOM object path.\nERST\n\n    {\n        .name       = \"cpu\",\n        .args_type  = \"index:i\",\n        .params     = \"index\",\n        .help       = \"set the default CPU\",\n        .cmd        = hmp_cpu,\n    },\n\nSRST\n``cpu`` *index*\n  Set the default CPU.\nERST\n\n    {\n        .name       = \"mouse_move\",\n        .args_type  = \"dx_str:s,dy_str:s,dz_str:s?\",\n        .params     = \"dx dy [dz]\",\n        .help       = \"send mouse move events\",\n        .cmd        = hmp_mouse_move,\n    },\n\nSRST\n``mouse_move`` *dx* *dy* [*dz*]\n  Move the active mouse to the specified coordinates *dx* *dy*\n  with optional scroll axis *dz*.\nERST\n\n    {\n        .name       = \"mouse_button\",\n        .args_type  = \"button_state:i\",\n        .params     = \"state\",\n        .help       = \"change mouse button state (1=L, 2=M, 4=R)\",\n        .cmd        = hmp_mouse_button,\n    },\n\nSRST\n``mouse_button`` *val*\n  Change the active mouse button state *val* (1=L, 2=M, 4=R).\nERST\n\n    {\n        .name       = \"mouse_set\",\n        .args_type  = \"index:i\",\n        .params     = \"index\",\n        .help       = \"set which mouse device receives events\",\n        .cmd        = hmp_mouse_set,\n    },\n\nSRST\n``mouse_set`` *index*\n  Set which mouse device receives events at given *index*, index\n  can be obtained with::\n\n    info mice\n\nERST\n\n    {\n        .name       = \"wavcapture\",\n        .args_type  = \"path:F,audiodev:s,freq:i?,bits:i?,nchannels:i?\",\n        .params     = \"path audiodev [frequency [bits [channels]]]\",\n        .help       = \"capture audio to a wave file (default frequency=44100 bits=16 channels=2)\",\n        .cmd        = hmp_wavcapture,\n    },\nSRST\n``wavcapture`` *filename* *audiodev* [*frequency* [*bits* [*channels*]]]\n  Capture audio into *filename* from *audiodev*, using sample rate\n  *frequency* bits per sample *bits* and number of channels\n  *channels*.\n\n  Defaults:\n\n  - Sample rate = 44100 Hz - CD quality\n  - Bits = 16\n  - Number of channels = 2 - Stereo\nERST\n\n    {\n        .name       = \"stopcapture\",\n        .args_type  = \"n:i\",\n        .params     = \"capture index\",\n        .help       = \"stop capture\",\n        .cmd        = hmp_stopcapture,\n    },\nSRST\n``stopcapture`` *index*\n  Stop capture with a given *index*, index can be obtained with::\n\n    info capture\n\nERST\n\n    {\n        .name       = \"memsave\",\n        .args_type  = \"val:l,size:i,filename:s\",\n        .params     = \"addr size file\",\n        .help       = \"save to disk virtual memory dump starting at 'addr' of size 'size'\",\n        .cmd        = hmp_memsave,\n    },\n\nSRST\n``memsave`` *addr* *size* *file*\n  save to disk virtual memory dump starting at *addr* of size *size*.\nERST\n\n    {\n        .name       = \"pmemsave\",\n        .args_type  = \"val:l,size:i,filename:s\",\n        .params     = \"addr size file\",\n        .help       = \"save to disk physical memory dump starting at 'addr' of size 'size'\",\n        .cmd        = hmp_pmemsave,\n    },\n\nSRST\n``pmemsave`` *addr* *size* *file*\n  save to disk physical memory dump starting at *addr* of size *size*.\nERST\n\n    {\n        .name       = \"boot_set\",\n        .args_type  = \"bootdevice:s\",\n        .params     = \"bootdevice\",\n        .help       = \"define new values for the boot device list\",\n        .cmd        = hmp_boot_set,\n    },\n\nSRST\n``boot_set`` *bootdevicelist*\n  Define new values for the boot device list. Those values will override\n  the values specified on the command line through the ``-boot`` option.\n\n  The values that can be specified here depend on the machine type, but are\n  the same that can be specified in the ``-boot`` command line option.\nERST\n\n    {\n        .name       = \"nmi\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"inject an NMI\",\n        .cmd        = hmp_nmi,\n    },\nSRST\n``nmi`` *cpu*\n  Inject an NMI on the default CPU (x86/s390) or all CPUs (ppc64).\nERST\n\n    {\n        .name       = \"ringbuf_write\",\n        .args_type  = \"device:s,data:s\",\n        .params     = \"device data\",\n        .help       = \"Write to a ring buffer character device\",\n        .cmd        = hmp_ringbuf_write,\n        .command_completion = ringbuf_write_completion,\n    },\n\nSRST\n``ringbuf_write`` *device* *data*\n  Write *data* to ring buffer character device *device*.\n  *data* must be a UTF-8 string.\nERST\n\n    {\n        .name       = \"ringbuf_read\",\n        .args_type  = \"device:s,size:i\",\n        .params     = \"device size\",\n        .help       = \"Read from a ring buffer character device\",\n        .cmd        = hmp_ringbuf_read,\n        .command_completion = ringbuf_write_completion,\n    },\n\nSRST\n``ringbuf_read`` *device*\n  Read and print up to *size* bytes from ring buffer character\n  device *device*.\n  Certain non-printable characters are printed ``\\uXXXX``, where ``XXXX`` is the\n  character code in hexadecimal.  Character ``\\`` is printed ``\\\\``.\n  Bug: can screw up when the buffer contains invalid UTF-8 sequences,\n  NUL characters, after the ring buffer lost data, and when reading\n  stops because the size limit is reached.\nERST\n\n    {\n        .name       = \"announce_self\",\n        .args_type  = \"interfaces:s?,id:s?\",\n        .params     = \"[interfaces] [id]\",\n        .help       = \"Trigger GARP/RARP announcements\",\n        .cmd        = hmp_announce_self,\n    },\n\nSRST\n``announce_self``\n  Trigger a round of GARP/RARP broadcasts; this is useful for explicitly\n  updating the network infrastructure after a reconfiguration or some forms\n  of migration. The timings of the round are set by the migration announce\n  parameters. An optional comma separated *interfaces* list restricts the\n  announce to the named set of interfaces. An optional *id* can be used to\n  start a separate announce timer and to change the parameters of it later.\nERST\n\n    {\n        .name       = \"migrate\",\n        .args_type  = \"detach:-d,blk:-b,inc:-i,resume:-r,uri:s\",\n        .params     = \"[-d] [-b] [-i] [-r] uri\",\n        .help       = \"migrate to URI (using -d to not wait for completion)\"\n\t\t      \"\\n\\t\\t\\t -b for migration without shared storage with\"\n\t\t      \" full copy of disk\\n\\t\\t\\t -i for migration without \"\n\t\t      \"shared storage with incremental copy of disk \"\n\t\t      \"(base image shared between src and destination)\"\n                      \"\\n\\t\\t\\t -r to resume a paused migration\",\n        .cmd        = hmp_migrate,\n    },\n\n\nSRST\n``migrate [-d] [-b] [-i]`` *uri*\n  Migrate to *uri* (using -d to not wait for completion).\n\n  ``-b``\n    for migration with full copy of disk\n  ``-i``\n    for migration with incremental copy of disk (base image is shared)\nERST\n\n    {\n        .name       = \"migrate_cancel\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"cancel the current VM migration\",\n        .cmd        = hmp_migrate_cancel,\n    },\n\nSRST\n``migrate_cancel``\n  Cancel the current VM migration.\nERST\n\n    {\n        .name       = \"migrate_continue\",\n        .args_type  = \"state:s\",\n        .params     = \"state\",\n        .help       = \"Continue migration from the given paused state\",\n        .cmd        = hmp_migrate_continue,\n    },\nSRST\n``migrate_continue`` *state*\n  Continue migration from the paused state *state*\nERST\n\n    {\n        .name       = \"migrate_incoming\",\n        .args_type  = \"uri:s\",\n        .params     = \"uri\",\n        .help       = \"Continue an incoming migration from an -incoming defer\",\n        .cmd        = hmp_migrate_incoming,\n    },\n\nSRST\n``migrate_incoming`` *uri*\n  Continue an incoming migration using the *uri* (that has the same syntax\n  as the ``-incoming`` option).\nERST\n\n    {\n        .name       = \"migrate_recover\",\n        .args_type  = \"uri:s\",\n        .params     = \"uri\",\n        .help       = \"Continue a paused incoming postcopy migration\",\n        .cmd        = hmp_migrate_recover,\n    },\n\nSRST\n``migrate_recover`` *uri*\n  Continue a paused incoming postcopy migration using the *uri*.\nERST\n\n    {\n        .name       = \"migrate_pause\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Pause an ongoing migration (postcopy-only)\",\n        .cmd        = hmp_migrate_pause,\n    },\n\nSRST\n``migrate_pause``\n  Pause an ongoing migration.  Currently it only supports postcopy.\nERST\n\n    {\n        .name       = \"migrate_set_capability\",\n        .args_type  = \"capability:s,state:b\",\n        .params     = \"capability state\",\n        .help       = \"Enable/Disable the usage of a capability for migration\",\n        .cmd        = hmp_migrate_set_capability,\n        .command_completion = migrate_set_capability_completion,\n    },\n\nSRST\n``migrate_set_capability`` *capability* *state*\n  Enable/Disable the usage of a capability *capability* for migration.\nERST\n\n    {\n        .name       = \"migrate_set_parameter\",\n        .args_type  = \"parameter:s,value:s\",\n        .params     = \"parameter value\",\n        .help       = \"Set the parameter for migration\",\n        .cmd        = hmp_migrate_set_parameter,\n        .command_completion = migrate_set_parameter_completion,\n    },\n\nSRST\n``migrate_set_parameter`` *parameter* *value*\n  Set the parameter *parameter* for migration.\nERST\n\n    {\n        .name       = \"migrate_start_postcopy\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Followup to a migration command to switch the migration\"\n                      \" to postcopy mode. The postcopy-ram capability must \"\n                      \"be set on both source and destination before the \"\n                      \"original migration command .\",\n        .cmd        = hmp_migrate_start_postcopy,\n    },\n\nSRST\n``migrate_start_postcopy``\n  Switch in-progress migration to postcopy mode. Ignored after the end of\n  migration (or once already in postcopy).\nERST\n\n    {\n        .name       = \"x_colo_lost_heartbeat\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"Tell COLO that heartbeat is lost,\\n\\t\\t\\t\"\n                      \"a failover or takeover is needed.\",\n        .cmd = hmp_x_colo_lost_heartbeat,\n    },\n\nSRST\n``x_colo_lost_heartbeat``\n  Tell COLO that heartbeat is lost, a failover or takeover is needed.\nERST\n\n    {\n        .name       = \"client_migrate_info\",\n        .args_type  = \"protocol:s,hostname:s,port:i?,tls-port:i?,cert-subject:s?\",\n        .params     = \"protocol hostname port tls-port cert-subject\",\n        .help       = \"set migration information for remote display\",\n        .cmd        = hmp_client_migrate_info,\n    },\n\nSRST\n``client_migrate_info`` *protocol* *hostname* *port* *tls-port* *cert-subject*\n  Set migration information for remote display.  This makes the server\n  ask the client to automatically reconnect using the new parameters\n  once migration finished successfully.  Only implemented for SPICE.\nERST\n\n    {\n        .name       = \"dump-guest-memory\",\n        .args_type  = \"paging:-p,detach:-d,windmp:-w,zlib:-z,lzo:-l,snappy:-s,filename:F,begin:l?,length:l?\",\n        .params     = \"[-p] [-d] [-z|-l|-s|-w] filename [begin length]\",\n        .help       = \"dump guest memory into file 'filename'.\\n\\t\\t\\t\"\n                      \"-p: do paging to get guest's memory mapping.\\n\\t\\t\\t\"\n                      \"-d: return immediately (do not wait for completion).\\n\\t\\t\\t\"\n                      \"-z: dump in kdump-compressed format, with zlib compression.\\n\\t\\t\\t\"\n                      \"-l: dump in kdump-compressed format, with lzo compression.\\n\\t\\t\\t\"\n                      \"-s: dump in kdump-compressed format, with snappy compression.\\n\\t\\t\\t\"\n                      \"-w: dump in Windows crashdump format (can be used instead of ELF-dump converting),\\n\\t\\t\\t\"\n                      \"    for Windows x86 and x64 guests with vmcoreinfo driver only.\\n\\t\\t\\t\"\n                      \"begin: the starting physical address.\\n\\t\\t\\t\"\n                      \"length: the memory size, in bytes.\",\n        .cmd        = hmp_dump_guest_memory,\n    },\n\nSRST\n``dump-guest-memory [-p]`` *filename* *begin* *length*\n  \\ \n``dump-guest-memory [-z|-l|-s|-w]`` *filename*\n  Dump guest memory to *protocol*. The file can be processed with crash or\n  gdb. Without ``-z|-l|-s|-w``, the dump format is ELF.\n\n  ``-p``\n    do paging to get guest's memory mapping.\n  ``-z``\n    dump in kdump-compressed format, with zlib compression.\n  ``-l``\n    dump in kdump-compressed format, with lzo compression.\n  ``-s``\n    dump in kdump-compressed format, with snappy compression.\n  ``-w``\n    dump in Windows crashdump format (can be used instead of ELF-dump converting),\n    for Windows x64 guests with vmcoreinfo driver only\n  *filename*\n    dump file name.\n  *begin*\n    the starting physical address. It's optional, and should be\n    specified together with *length*.\n  *length*\n    the memory size, in bytes. It's optional, and should be specified\n    together with *begin*.\n\nERST\n\n#if defined(TARGET_S390X)\n    {\n        .name       = \"dump-skeys\",\n        .args_type  = \"filename:F\",\n        .params     = \"\",\n        .help       = \"Save guest storage keys into file 'filename'.\\n\",\n        .cmd        = hmp_dump_skeys,\n    },\n#endif\n\nSRST\n``dump-skeys`` *filename*\n  Save guest storage keys to a file.\nERST\n\n#if defined(TARGET_S390X)\n    {\n        .name       = \"migration_mode\",\n        .args_type  = \"mode:i\",\n        .params     = \"mode\",\n        .help       = \"Enables or disables migration mode\\n\",\n        .cmd        = hmp_migrationmode,\n    },\n#endif\n\nSRST\n``migration_mode`` *mode*\n  Enables or disables migration mode.\nERST\n\n    {\n        .name       = \"snapshot_blkdev\",\n        .args_type  = \"reuse:-n,device:B,snapshot-file:s?,format:s?\",\n        .params     = \"[-n] device [new-image-file] [format]\",\n        .help       = \"initiates a live snapshot\\n\\t\\t\\t\"\n                      \"of device. If a new image file is specified, the\\n\\t\\t\\t\"\n                      \"new image file will become the new root image.\\n\\t\\t\\t\"\n                      \"If format is specified, the snapshot file will\\n\\t\\t\\t\"\n                      \"be created in that format.\\n\\t\\t\\t\"\n                      \"The default format is qcow2.  The -n flag requests QEMU\\n\\t\\t\\t\"\n                      \"to reuse the image found in new-image-file, instead of\\n\\t\\t\\t\"\n                      \"recreating it from scratch.\",\n        .cmd        = hmp_snapshot_blkdev,\n    },\n\nSRST\n``snapshot_blkdev``\n  Snapshot device, using snapshot file as target if provided\nERST\n\n    {\n        .name       = \"snapshot_blkdev_internal\",\n        .args_type  = \"device:B,name:s\",\n        .params     = \"device name\",\n        .help       = \"take an internal snapshot of device.\\n\\t\\t\\t\"\n                      \"The format of the image used by device must\\n\\t\\t\\t\"\n                      \"support it, such as qcow2.\\n\\t\\t\\t\",\n        .cmd        = hmp_snapshot_blkdev_internal,\n    },\n\nSRST\n``snapshot_blkdev_internal``\n  Take an internal snapshot on device if it support\nERST\n\n    {\n        .name       = \"snapshot_delete_blkdev_internal\",\n        .args_type  = \"device:B,name:s,id:s?\",\n        .params     = \"device name [id]\",\n        .help       = \"delete an internal snapshot of device.\\n\\t\\t\\t\"\n                      \"If id is specified, qemu will try delete\\n\\t\\t\\t\"\n                      \"the snapshot matching both id and name.\\n\\t\\t\\t\"\n                      \"The format of the image used by device must\\n\\t\\t\\t\"\n                      \"support it, such as qcow2.\\n\\t\\t\\t\",\n        .cmd        = hmp_snapshot_delete_blkdev_internal,\n    },\n\nSRST\n``snapshot_delete_blkdev_internal``\n  Delete an internal snapshot on device if it support\nERST\n\n    {\n        .name       = \"drive_mirror\",\n        .args_type  = \"reuse:-n,full:-f,device:B,target:s,format:s?\",\n        .params     = \"[-n] [-f] device target [format]\",\n        .help       = \"initiates live storage\\n\\t\\t\\t\"\n                      \"migration for a device. The device's contents are\\n\\t\\t\\t\"\n                      \"copied to the new image file, including data that\\n\\t\\t\\t\"\n                      \"is written after the command is started.\\n\\t\\t\\t\"\n                      \"The -n flag requests QEMU to reuse the image found\\n\\t\\t\\t\"\n                      \"in new-image-file, instead of recreating it from scratch.\\n\\t\\t\\t\"\n                      \"The -f flag requests QEMU to copy the whole disk,\\n\\t\\t\\t\"\n                      \"so that the result does not need a backing file.\\n\\t\\t\\t\",\n        .cmd        = hmp_drive_mirror,\n    },\nSRST\n``drive_mirror``\n  Start mirroring a block device's writes to a new destination,\n  using the specified target.\nERST\n\n    {\n        .name       = \"drive_backup\",\n        .args_type  = \"reuse:-n,full:-f,compress:-c,device:B,target:s,format:s?\",\n        .params     = \"[-n] [-f] [-c] device target [format]\",\n        .help       = \"initiates a point-in-time\\n\\t\\t\\t\"\n                      \"copy for a device. The device's contents are\\n\\t\\t\\t\"\n                      \"copied to the new image file, excluding data that\\n\\t\\t\\t\"\n                      \"is written after the command is started.\\n\\t\\t\\t\"\n                      \"The -n flag requests QEMU to reuse the image found\\n\\t\\t\\t\"\n                      \"in new-image-file, instead of recreating it from scratch.\\n\\t\\t\\t\"\n                      \"The -f flag requests QEMU to copy the whole disk,\\n\\t\\t\\t\"\n                      \"so that the result does not need a backing file.\\n\\t\\t\\t\"\n                      \"The -c flag requests QEMU to compress backup data\\n\\t\\t\\t\"\n                      \"(if the target format supports it).\\n\\t\\t\\t\",\n        .cmd        = hmp_drive_backup,\n    },\nSRST\n``drive_backup``\n  Start a point-in-time copy of a block device to a specified target.\nERST\n\n    {\n        .name       = \"drive_add\",\n        .args_type  = \"node:-n,pci_addr:s,opts:s\",\n        .params     = \"[-n] [[<domain>:]<bus>:]<slot>\\n\"\n                      \"[file=file][,if=type][,bus=n]\\n\"\n                      \"[,unit=m][,media=d][,index=i]\\n\"\n                      \"[,snapshot=on|off][,cache=on|off]\\n\"\n                      \"[,readonly=on|off][,copy-on-read=on|off]\",\n        .help       = \"add drive to PCI storage controller\",\n        .cmd        = hmp_drive_add,\n    },\n\nSRST\n``drive_add``\n  Add drive to PCI storage controller.\nERST\n\n    {\n        .name       = \"pcie_aer_inject_error\",\n        .args_type  = \"advisory_non_fatal:-a,correctable:-c,\"\n\t              \"id:s,error_status:s,\"\n\t              \"header0:i?,header1:i?,header2:i?,header3:i?,\"\n\t              \"prefix0:i?,prefix1:i?,prefix2:i?,prefix3:i?\",\n        .params     = \"[-a] [-c] id \"\n                      \"<error_status> [<tlp header> [<tlp header prefix>]]\",\n        .help       = \"inject pcie aer error\\n\\t\\t\\t\"\n\t              \" -a for advisory non fatal error\\n\\t\\t\\t\"\n\t              \" -c for correctable error\\n\\t\\t\\t\"\n                      \"<id> = qdev device id\\n\\t\\t\\t\"\n                      \"<error_status> = error string or 32bit\\n\\t\\t\\t\"\n                      \"<tlp header> = 32bit x 4\\n\\t\\t\\t\"\n                      \"<tlp header prefix> = 32bit x 4\",\n        .cmd        = hmp_pcie_aer_inject_error,\n    },\n\nSRST\n``pcie_aer_inject_error``\n  Inject PCIe AER error\nERST\n\n    {\n        .name       = \"netdev_add\",\n        .args_type  = \"netdev:O\",\n        .params     = \"[user|tap|socket|vde|bridge|hubport|netmap|vhost-user\"\n#ifdef CONFIG_VMNET\n                      \"|vmnet-host|vmnet-shared|vmnet-bridged\"\n#endif\n                      \"],id=str[,prop=value][,...]\",\n        .help       = \"add host network device\",\n        .cmd        = hmp_netdev_add,\n        .command_completion = netdev_add_completion,\n        .flags      = \"p\",\n    },\n\nSRST\n``netdev_add``\n  Add host network device.\nERST\n\n    {\n        .name       = \"netdev_del\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"remove host network device\",\n        .cmd        = hmp_netdev_del,\n        .command_completion = netdev_del_completion,\n        .flags      = \"p\",\n    },\n\nSRST\n``netdev_del``\n  Remove host network device.\nERST\n\n    {\n        .name       = \"object_add\",\n        .args_type  = \"object:S\",\n        .params     = \"[qom-type=]type,id=str[,prop=value][,...]\",\n        .help       = \"create QOM object\",\n        .cmd        = hmp_object_add,\n        .command_completion = object_add_completion,\n        .flags      = \"p\",\n    },\n\nSRST\n``object_add``\n  Create QOM object.\nERST\n\n    {\n        .name       = \"object_del\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"destroy QOM object\",\n        .cmd        = hmp_object_del,\n        .command_completion = object_del_completion,\n        .flags      = \"p\",\n    },\n\nSRST\n``object_del``\n  Destroy QOM object.\nERST\n\n#ifdef CONFIG_SLIRP\n    {\n        .name       = \"hostfwd_add\",\n        .args_type  = \"arg1:s,arg2:s?\",\n        .params     = \"[netdev_id] [tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport\",\n        .help       = \"redirect TCP or UDP connections from host to guest (requires -net user)\",\n        .cmd        = hmp_hostfwd_add,\n    },\n#endif\nSRST\n``hostfwd_add``\n  Redirect TCP or UDP connections from host to guest (requires -net user).\nERST\n\n#ifdef CONFIG_SLIRP\n    {\n        .name       = \"hostfwd_remove\",\n        .args_type  = \"arg1:s,arg2:s?\",\n        .params     = \"[netdev_id] [tcp|udp]:[hostaddr]:hostport\",\n        .help       = \"remove host-to-guest TCP or UDP redirection\",\n        .cmd        = hmp_hostfwd_remove,\n    },\n\n#endif\nSRST\n``hostfwd_remove``\n  Remove host-to-guest TCP or UDP redirection.\nERST\n\n    {\n        .name       = \"balloon\",\n        .args_type  = \"value:M\",\n        .params     = \"target\",\n        .help       = \"request VM to change its memory allocation (in MB)\",\n        .cmd        = hmp_balloon,\n    },\n\nSRST\n``balloon`` *value*\n  Request VM to change its memory allocation to *value* (in MB).\nERST\n\n    {\n        .name       = \"set_link\",\n        .args_type  = \"name:s,up:b\",\n        .params     = \"name on|off\",\n        .help       = \"change the link status of a network adapter\",\n        .cmd        = hmp_set_link,\n        .command_completion = set_link_completion,\n    },\n\nSRST\n``set_link`` *name* ``[on|off]``\n  Switch link *name* on (i.e. up) or off (i.e. down).\nERST\n\n    {\n        .name       = \"watchdog_action\",\n        .args_type  = \"action:s\",\n        .params     = \"[reset|shutdown|poweroff|pause|debug|none]\",\n        .help       = \"change watchdog action\",\n        .cmd        = hmp_watchdog_action,\n        .command_completion = watchdog_action_completion,\n    },\n\nSRST\n``watchdog_action``\n  Change watchdog action.\nERST\n\n    {\n        .name       = \"nbd_server_start\",\n        .args_type  = \"all:-a,writable:-w,uri:s\",\n        .params     = \"nbd_server_start [-a] [-w] host:port\",\n        .help       = \"serve block devices on the given host and port\",\n        .cmd        = hmp_nbd_server_start,\n        .flags      = \"p\",\n    },\nSRST\n``nbd_server_start`` *host*:*port*\n  Start an NBD server on the given host and/or port.  If the ``-a``\n  option is included, all of the virtual machine's block devices that\n  have an inserted media on them are automatically exported; in this case,\n  the ``-w`` option makes the devices writable too.\nERST\n\n    {\n        .name       = \"nbd_server_add\",\n        .args_type  = \"writable:-w,device:B,name:s?\",\n        .params     = \"nbd_server_add [-w] device [name]\",\n        .help       = \"export a block device via NBD\",\n        .cmd        = hmp_nbd_server_add,\n        .flags      = \"p\",\n    },\nSRST\n``nbd_server_add`` *device* [ *name* ]\n  Export a block device through QEMU's NBD server, which must be started\n  beforehand with ``nbd_server_start``.  The ``-w`` option makes the\n  exported device writable too.  The export name is controlled by *name*,\n  defaulting to *device*.\nERST\n\n    {\n        .name       = \"nbd_server_remove\",\n        .args_type  = \"force:-f,name:s\",\n        .params     = \"nbd_server_remove [-f] name\",\n        .help       = \"remove an export previously exposed via NBD\",\n        .cmd        = hmp_nbd_server_remove,\n        .flags      = \"p\",\n    },\nSRST\n``nbd_server_remove [-f]`` *name*\n  Stop exporting a block device through QEMU's NBD server, which was\n  previously started with ``nbd_server_add``.  The ``-f``\n  option forces the server to drop the export immediately even if\n  clients are connected; otherwise the command fails unless there are no\n  clients.\nERST\n\n    {\n        .name       = \"nbd_server_stop\",\n        .args_type  = \"\",\n        .params     = \"nbd_server_stop\",\n        .help       = \"stop serving block devices using the NBD protocol\",\n        .cmd        = hmp_nbd_server_stop,\n        .flags      = \"p\",\n    },\nSRST\n``nbd_server_stop``\n  Stop the QEMU embedded NBD server.\nERST\n\n\n#if defined(TARGET_I386)\n\n    {\n        .name       = \"mce\",\n        .args_type  = \"broadcast:-b,cpu_index:i,bank:i,status:l,mcg_status:l,addr:l,misc:l\",\n        .params     = \"[-b] cpu bank status mcgstatus addr misc\",\n        .help       = \"inject a MCE on the given CPU [and broadcast to other CPUs with -b option]\",\n        .cmd        = hmp_mce,\n    },\n\n#endif\nSRST\n``mce`` *cpu* *bank* *status* *mcgstatus* *addr* *misc*\n  Inject an MCE on the given CPU (x86 only).\nERST\n\n    {\n        .name       = \"getfd\",\n        .args_type  = \"fdname:s\",\n        .params     = \"getfd name\",\n        .help       = \"receive a file descriptor via SCM rights and assign it a name\",\n        .cmd        = hmp_getfd,\n        .flags      = \"p\",\n    },\n\nSRST\n``getfd`` *fdname*\n  If a file descriptor is passed alongside this command using the SCM_RIGHTS\n  mechanism on unix sockets, it is stored using the name *fdname* for\n  later use by other monitor commands.\nERST\n\n    {\n        .name       = \"closefd\",\n        .args_type  = \"fdname:s\",\n        .params     = \"closefd name\",\n        .help       = \"close a file descriptor previously passed via SCM rights\",\n        .cmd        = hmp_closefd,\n        .flags      = \"p\",\n    },\n\nSRST\n``closefd`` *fdname*\n  Close the file descriptor previously assigned to *fdname* using the\n  ``getfd`` command. This is only needed if the file descriptor was never\n  used by another monitor command.\nERST\n\n    {\n        .name       = \"block_set_io_throttle\",\n        .args_type  = \"device:B,bps:l,bps_rd:l,bps_wr:l,iops:l,iops_rd:l,iops_wr:l\",\n        .params     = \"device bps bps_rd bps_wr iops iops_rd iops_wr\",\n        .help       = \"change I/O throttle limits for a block drive\",\n        .cmd        = hmp_block_set_io_throttle,\n        .flags      = \"p\",\n    },\n\nSRST\n``block_set_io_throttle`` *device* *bps* *bps_rd* *bps_wr* *iops* *iops_rd* *iops_wr*\n  Change I/O throttle limits for a block drive to\n  *bps* *bps_rd* *bps_wr* *iops* *iops_rd* *iops_wr*.\n  *device* can be a block device name, a qdev ID or a QOM path.\nERST\n\n    {\n        .name       = \"set_password\",\n        .args_type  = \"protocol:s,password:s,display:-ds,connected:s?\",\n        .params     = \"protocol password [-d display] [action-if-connected]\",\n        .help       = \"set spice/vnc password\",\n        .cmd        = hmp_set_password,\n    },\n\nSRST\n``set_password [ vnc | spice ] password [ -d display ] [ action-if-connected ]``\n  Change spice/vnc password.  *display* can be used with 'vnc' to specify\n  which display to set the password on.  *action-if-connected* specifies\n  what should happen in case a connection is established: *fail* makes\n  the password change fail.  *disconnect* changes the password and\n  disconnects the client.  *keep* changes the password and keeps the\n  connection up.  *keep* is the default.\nERST\n\n    {\n        .name       = \"expire_password\",\n        .args_type  = \"protocol:s,time:s,display:-ds\",\n        .params     = \"protocol time [-d display]\",\n        .help       = \"set spice/vnc password expire-time\",\n        .cmd        = hmp_expire_password,\n    },\n\nSRST\n``expire_password [ vnc | spice ] expire-time [ -d display ]``\n  Specify when a password for spice/vnc becomes invalid.\n  *display* behaves the same as in ``set_password``.\n  *expire-time* accepts:\n\n  ``now``\n    Invalidate password instantly.\n  ``never``\n    Password stays valid forever.\n  ``+``\\ *nsec*\n    Password stays valid for *nsec* seconds starting now.\n  *nsec*\n    Password is invalidated at the given time.  *nsec* are the seconds\n    passed since 1970, i.e. unix epoch.\n\nERST\n\n    {\n        .name       = \"chardev-add\",\n        .args_type  = \"args:s\",\n        .params     = \"args\",\n        .help       = \"add chardev\",\n        .cmd        = hmp_chardev_add,\n        .command_completion = chardev_add_completion,\n    },\n\nSRST\n``chardev-add`` *args*\n  chardev-add accepts the same parameters as the -chardev command line switch.\nERST\n\n    {\n        .name       = \"chardev-change\",\n        .args_type  = \"id:s,args:s\",\n        .params     = \"id args\",\n        .help       = \"change chardev\",\n        .cmd        = hmp_chardev_change,\n    },\n\nSRST\n``chardev-change`` *args*\n  chardev-change accepts existing chardev *id* and then the same arguments\n  as the -chardev command line switch (except for \"id\").\nERST\n\n    {\n        .name       = \"chardev-remove\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"remove chardev\",\n        .cmd        = hmp_chardev_remove,\n        .command_completion = chardev_remove_completion,\n    },\n\nSRST\n``chardev-remove`` *id*\n  Removes the chardev *id*.\nERST\n\n    {\n        .name       = \"chardev-send-break\",\n        .args_type  = \"id:s\",\n        .params     = \"id\",\n        .help       = \"send a break on chardev\",\n        .cmd        = hmp_chardev_send_break,\n        .command_completion = chardev_remove_completion,\n    },\n\nSRST\n``chardev-send-break`` *id*\n  Send a break on the chardev *id*.\nERST\n\n    {\n        .name       = \"qemu-io\",\n        .args_type  = \"qdev:-d,device:B,command:s\",\n        .params     = \"[-d] [device] \\\"[command]\\\"\",\n        .help       = \"run a qemu-io command on a block device\\n\\t\\t\\t\"\n                      \"-d: [device] is a device ID rather than a \"\n                      \"drive ID or node name\",\n        .cmd        = hmp_qemu_io,\n    },\n\nSRST\n``qemu-io`` *device* *command*\n  Executes a qemu-io command on the given block device.\nERST\n\n    {\n        .name       = \"qom-list\",\n        .args_type  = \"path:s?\",\n        .params     = \"path\",\n        .help       = \"list QOM properties\",\n        .cmd        = hmp_qom_list,\n        .flags      = \"p\",\n    },\n\nSRST\n``qom-list`` [*path*]\n  Print QOM properties of object at location *path*\nERST\n\n    {\n        .name       = \"qom-get\",\n        .args_type  = \"path:s,property:s\",\n        .params     = \"path property\",\n        .help       = \"print QOM property\",\n        .cmd        = hmp_qom_get,\n        .flags      = \"p\",\n    },\n\nSRST\n``qom-get`` *path* *property*\n  Print QOM property *property* of object at location *path*\nERST\n\n    {\n        .name       = \"qom-set\",\n        .args_type  = \"json:-j,path:s,property:s,value:S\",\n        .params     = \"[-j] path property value\",\n        .help       = \"set QOM property.\\n\\t\\t\\t\"\n                      \"-j: the value is specified in json format.\",\n        .cmd        = hmp_qom_set,\n        .flags      = \"p\",\n    },\n\nSRST\n``qom-set`` *path* *property* *value*\n  Set QOM property *property* of object at location *path* to value *value*\nERST\n\n    {\n        .name       = \"replay_break\",\n        .args_type  = \"icount:l\",\n        .params     = \"icount\",\n        .help       = \"set breakpoint at the specified instruction count\",\n        .cmd        = hmp_replay_break,\n    },\n\nSRST\n``replay_break`` *icount*\n  Set replay breakpoint at instruction count *icount*.\n  Execution stops when the specified instruction is reached.\n  There can be at most one breakpoint. When breakpoint is set, any prior\n  one is removed.  The breakpoint may be set only in replay mode and only\n  \"in the future\", i.e. at instruction counts greater than the current one.\n  The current instruction count can be observed with ``info replay``.\nERST\n\n    {\n        .name       = \"replay_delete_break\",\n        .args_type  = \"\",\n        .params     = \"\",\n        .help       = \"remove replay breakpoint\",\n        .cmd        = hmp_replay_delete_break,\n    },\n\nSRST\n``replay_delete_break``\n  Remove replay breakpoint which was previously set with ``replay_break``.\n  The command is ignored when there are no replay breakpoints.\nERST\n\n    {\n        .name       = \"replay_seek\",\n        .args_type  = \"icount:l\",\n        .params     = \"icount\",\n        .help       = \"replay execution to the specified instruction count\",\n        .cmd        = hmp_replay_seek,\n    },\n\nSRST\n``replay_seek`` *icount*\n  Automatically proceed to the instruction count *icount*, when\n  replaying the execution. The command automatically loads nearest\n  snapshot and replays the execution to find the desired instruction.\n  When there is no preceding snapshot or the execution is not replayed,\n  then the command fails.\n  *icount* for the reference may be observed with ``info replay`` command.\nERST\n\n    {\n        .name       = \"info\",\n        .args_type  = \"item:s?\",\n        .params     = \"[subcommand]\",\n        .help       = \"show various information about the system state\",\n        .cmd        = hmp_info_help,\n        .sub_table  = hmp_info_cmds,\n        .flags      = \"p\",\n    },\n\nSRST\n``calc_dirty_rate`` *second*\n  Start a round of dirty rate measurement with the period specified in *second*.\n  The result of the dirty rate measurement may be observed with ``info\n  dirty_rate`` command.\nERST\n\n    {\n        .name       = \"calc_dirty_rate\",\n        .args_type  = \"dirty_ring:-r,dirty_bitmap:-b,second:l,sample_pages_per_GB:l?\",\n        .params     = \"[-r] [-b] second [sample_pages_per_GB]\",\n        .help       = \"start a round of guest dirty rate measurement (using -r to\"\n                      \"\\n\\t\\t\\t specify dirty ring as the method of calculation and\"\n                      \"\\n\\t\\t\\t -b to specify dirty bitmap as method of calculation)\",\n        .cmd        = hmp_calc_dirty_rate,\n    },\n\nSRST\n``set_vcpu_dirty_limit``\n  Set dirty page rate limit on virtual CPU, the information about all the\n  virtual CPU dirty limit status can be observed with ``info vcpu_dirty_limit``\n  command.\nERST\n\n    {\n        .name       = \"set_vcpu_dirty_limit\",\n        .args_type  = \"dirty_rate:l,cpu_index:l?\",\n        .params     = \"dirty_rate [cpu_index]\",\n        .help       = \"set dirty page rate limit, use cpu_index to set limit\"\n                      \"\\n\\t\\t\\t\\t\\t on a specified virtual cpu\",\n        .cmd        = hmp_set_vcpu_dirty_limit,\n    },\n\nSRST\n``cancel_vcpu_dirty_limit``\n  Cancel dirty page rate limit on virtual CPU, the information about all the\n  virtual CPU dirty limit status can be observed with ``info vcpu_dirty_limit``\n  command.\nERST\n\n    {\n        .name       = \"cancel_vcpu_dirty_limit\",\n        .args_type  = \"cpu_index:l?\",\n        .params     = \"[cpu_index]\",\n        .help       = \"cancel dirty page rate limit, use cpu_index to cancel\"\n                      \"\\n\\t\\t\\t\\t\\t limit on a specified virtual cpu\",\n        .cmd        = hmp_cancel_vcpu_dirty_limit,\n    },\n"
        },
        {
          "name": "hw",
          "type": "tree",
          "content": null
        },
        {
          "name": "include",
          "type": "tree",
          "content": null
        },
        {
          "name": "io",
          "type": "tree",
          "content": null
        },
        {
          "name": "iothread.c",
          "type": "blob",
          "size": 11.62109375,
          "content": "/*\n * Event loop thread\n *\n * Copyright Red Hat Inc., 2013, 2020\n *\n * Authors:\n *  Stefan Hajnoczi   <stefanha@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n *\n */\n\n#include \"qemu/osdep.h\"\n#include \"qom/object.h\"\n#include \"qom/object_interfaces.h\"\n#include \"qemu/module.h\"\n#include \"block/aio.h\"\n#include \"block/block.h\"\n#include \"sysemu/event-loop-base.h\"\n#include \"sysemu/iothread.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qapi-commands-misc.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/rcu.h\"\n#include \"qemu/main-loop.h\"\n\ntypedef ObjectClass IOThreadClass;\n\nDECLARE_CLASS_CHECKERS(IOThreadClass, IOTHREAD,\n                       TYPE_IOTHREAD)\n\n#ifdef CONFIG_POSIX\n/* Benchmark results from 2016 on NVMe SSD drives show max polling times around\n * 16-32 microseconds yield IOPS improvements for both iodepth=1 and iodepth=32\n * workloads.\n */\n#define IOTHREAD_POLL_MAX_NS_DEFAULT 32768ULL\n#else\n#define IOTHREAD_POLL_MAX_NS_DEFAULT 0ULL\n#endif\n\nstatic void *iothread_run(void *opaque)\n{\n    IOThread *iothread = opaque;\n\n    rcu_register_thread();\n    /*\n     * g_main_context_push_thread_default() must be called before anything\n     * in this new thread uses glib.\n     */\n    g_main_context_push_thread_default(iothread->worker_context);\n    qemu_set_current_aio_context(iothread->ctx);\n    iothread->thread_id = qemu_get_thread_id();\n    qemu_sem_post(&iothread->init_done_sem);\n\n    while (iothread->running) {\n        /*\n         * Note: from functional-wise the g_main_loop_run() below can\n         * already cover the aio_poll() events, but we can't run the\n         * main loop unconditionally because explicit aio_poll() here\n         * is faster than g_main_loop_run() when we do not need the\n         * gcontext at all (e.g., pure block layer iothreads).  In\n         * other words, when we want to run the gcontext with the\n         * iothread we need to pay some performance for functionality.\n         */\n        aio_poll(iothread->ctx, true);\n\n        /*\n         * We must check the running state again in case it was\n         * changed in previous aio_poll()\n         */\n        if (iothread->running && qatomic_read(&iothread->run_gcontext)) {\n            g_main_loop_run(iothread->main_loop);\n        }\n    }\n\n    g_main_context_pop_thread_default(iothread->worker_context);\n    rcu_unregister_thread();\n    return NULL;\n}\n\n/* Runs in iothread_run() thread */\nstatic void iothread_stop_bh(void *opaque)\n{\n    IOThread *iothread = opaque;\n\n    iothread->running = false; /* stop iothread_run() */\n\n    if (iothread->main_loop) {\n        g_main_loop_quit(iothread->main_loop);\n    }\n}\n\nvoid iothread_stop(IOThread *iothread)\n{\n    if (!iothread->ctx || iothread->stopping) {\n        return;\n    }\n    iothread->stopping = true;\n    aio_bh_schedule_oneshot(iothread->ctx, iothread_stop_bh, iothread);\n    qemu_thread_join(&iothread->thread);\n}\n\nstatic void iothread_instance_init(Object *obj)\n{\n    IOThread *iothread = IOTHREAD(obj);\n\n    iothread->poll_max_ns = IOTHREAD_POLL_MAX_NS_DEFAULT;\n    iothread->thread_id = -1;\n    qemu_sem_init(&iothread->init_done_sem, 0);\n    /* By default, we don't run gcontext */\n    qatomic_set(&iothread->run_gcontext, 0);\n}\n\nstatic void iothread_instance_finalize(Object *obj)\n{\n    IOThread *iothread = IOTHREAD(obj);\n\n    iothread_stop(iothread);\n\n    /*\n     * Before glib2 2.33.10, there is a glib2 bug that GSource context\n     * pointer may not be cleared even if the context has already been\n     * destroyed (while it should).  Here let's free the AIO context\n     * earlier to bypass that glib bug.\n     *\n     * We can remove this comment after the minimum supported glib2\n     * version boosts to 2.33.10.  Before that, let's free the\n     * GSources first before destroying any GMainContext.\n     */\n    if (iothread->ctx) {\n        aio_context_unref(iothread->ctx);\n        iothread->ctx = NULL;\n    }\n    if (iothread->worker_context) {\n        g_main_context_unref(iothread->worker_context);\n        iothread->worker_context = NULL;\n        g_main_loop_unref(iothread->main_loop);\n        iothread->main_loop = NULL;\n    }\n    qemu_sem_destroy(&iothread->init_done_sem);\n}\n\nstatic void iothread_init_gcontext(IOThread *iothread)\n{\n    GSource *source;\n\n    iothread->worker_context = g_main_context_new();\n    source = aio_get_g_source(iothread_get_aio_context(iothread));\n    g_source_attach(source, iothread->worker_context);\n    g_source_unref(source);\n    iothread->main_loop = g_main_loop_new(iothread->worker_context, TRUE);\n}\n\nstatic void iothread_set_aio_context_params(EventLoopBase *base, Error **errp)\n{\n    IOThread *iothread = IOTHREAD(base);\n    ERRP_GUARD();\n\n    if (!iothread->ctx) {\n        return;\n    }\n\n    aio_context_set_poll_params(iothread->ctx,\n                                iothread->poll_max_ns,\n                                iothread->poll_grow,\n                                iothread->poll_shrink,\n                                errp);\n    if (*errp) {\n        return;\n    }\n\n    aio_context_set_aio_params(iothread->ctx,\n                               iothread->parent_obj.aio_max_batch,\n                               errp);\n\n    aio_context_set_thread_pool_params(iothread->ctx, base->thread_pool_min,\n                                       base->thread_pool_max, errp);\n}\n\n\nstatic void iothread_init(EventLoopBase *base, Error **errp)\n{\n    Error *local_error = NULL;\n    IOThread *iothread = IOTHREAD(base);\n    char *thread_name;\n\n    iothread->stopping = false;\n    iothread->running = true;\n    iothread->ctx = aio_context_new(errp);\n    if (!iothread->ctx) {\n        return;\n    }\n\n    /*\n     * Init one GMainContext for the iothread unconditionally, even if\n     * it's not used\n     */\n    iothread_init_gcontext(iothread);\n\n    iothread_set_aio_context_params(base, &local_error);\n    if (local_error) {\n        error_propagate(errp, local_error);\n        aio_context_unref(iothread->ctx);\n        iothread->ctx = NULL;\n        return;\n    }\n\n    /* This assumes we are called from a thread with useful CPU affinity for us\n     * to inherit.\n     */\n    thread_name = g_strdup_printf(\"IO %s\",\n                        object_get_canonical_path_component(OBJECT(base)));\n    qemu_thread_create(&iothread->thread, thread_name, iothread_run,\n                       iothread, QEMU_THREAD_JOINABLE);\n    g_free(thread_name);\n\n    /* Wait for initialization to complete */\n    while (iothread->thread_id == -1) {\n        qemu_sem_wait(&iothread->init_done_sem);\n    }\n}\n\ntypedef struct {\n    const char *name;\n    ptrdiff_t offset; /* field's byte offset in IOThread struct */\n} IOThreadParamInfo;\n\nstatic IOThreadParamInfo poll_max_ns_info = {\n    \"poll-max-ns\", offsetof(IOThread, poll_max_ns),\n};\nstatic IOThreadParamInfo poll_grow_info = {\n    \"poll-grow\", offsetof(IOThread, poll_grow),\n};\nstatic IOThreadParamInfo poll_shrink_info = {\n    \"poll-shrink\", offsetof(IOThread, poll_shrink),\n};\n\nstatic void iothread_get_param(Object *obj, Visitor *v,\n        const char *name, IOThreadParamInfo *info, Error **errp)\n{\n    IOThread *iothread = IOTHREAD(obj);\n    int64_t *field = (void *)iothread + info->offset;\n\n    visit_type_int64(v, name, field, errp);\n}\n\nstatic bool iothread_set_param(Object *obj, Visitor *v,\n        const char *name, IOThreadParamInfo *info, Error **errp)\n{\n    IOThread *iothread = IOTHREAD(obj);\n    int64_t *field = (void *)iothread + info->offset;\n    int64_t value;\n\n    if (!visit_type_int64(v, name, &value, errp)) {\n        return false;\n    }\n\n    if (value < 0) {\n        error_setg(errp, \"%s value must be in range [0, %\" PRId64 \"]\",\n                   info->name, INT64_MAX);\n        return false;\n    }\n\n    *field = value;\n\n    return true;\n}\n\nstatic void iothread_get_poll_param(Object *obj, Visitor *v,\n        const char *name, void *opaque, Error **errp)\n{\n    IOThreadParamInfo *info = opaque;\n\n    iothread_get_param(obj, v, name, info, errp);\n}\n\nstatic void iothread_set_poll_param(Object *obj, Visitor *v,\n        const char *name, void *opaque, Error **errp)\n{\n    IOThread *iothread = IOTHREAD(obj);\n    IOThreadParamInfo *info = opaque;\n\n    if (!iothread_set_param(obj, v, name, info, errp)) {\n        return;\n    }\n\n    if (iothread->ctx) {\n        aio_context_set_poll_params(iothread->ctx,\n                                    iothread->poll_max_ns,\n                                    iothread->poll_grow,\n                                    iothread->poll_shrink,\n                                    errp);\n    }\n}\n\nstatic void iothread_class_init(ObjectClass *klass, void *class_data)\n{\n    EventLoopBaseClass *bc = EVENT_LOOP_BASE_CLASS(klass);\n\n    bc->init = iothread_init;\n    bc->update_params = iothread_set_aio_context_params;\n\n    object_class_property_add(klass, \"poll-max-ns\", \"int\",\n                              iothread_get_poll_param,\n                              iothread_set_poll_param,\n                              NULL, &poll_max_ns_info);\n    object_class_property_add(klass, \"poll-grow\", \"int\",\n                              iothread_get_poll_param,\n                              iothread_set_poll_param,\n                              NULL, &poll_grow_info);\n    object_class_property_add(klass, \"poll-shrink\", \"int\",\n                              iothread_get_poll_param,\n                              iothread_set_poll_param,\n                              NULL, &poll_shrink_info);\n}\n\nstatic const TypeInfo iothread_info = {\n    .name = TYPE_IOTHREAD,\n    .parent = TYPE_EVENT_LOOP_BASE,\n    .class_init = iothread_class_init,\n    .instance_size = sizeof(IOThread),\n    .instance_init = iothread_instance_init,\n    .instance_finalize = iothread_instance_finalize,\n};\n\nstatic void iothread_register_types(void)\n{\n    type_register_static(&iothread_info);\n}\n\ntype_init(iothread_register_types)\n\nchar *iothread_get_id(IOThread *iothread)\n{\n    return g_strdup(object_get_canonical_path_component(OBJECT(iothread)));\n}\n\nAioContext *iothread_get_aio_context(IOThread *iothread)\n{\n    return iothread->ctx;\n}\n\nstatic int query_one_iothread(Object *object, void *opaque)\n{\n    IOThreadInfoList ***tail = opaque;\n    IOThreadInfo *info;\n    IOThread *iothread;\n\n    iothread = (IOThread *)object_dynamic_cast(object, TYPE_IOTHREAD);\n    if (!iothread) {\n        return 0;\n    }\n\n    info = g_new0(IOThreadInfo, 1);\n    info->id = iothread_get_id(iothread);\n    info->thread_id = iothread->thread_id;\n    info->poll_max_ns = iothread->poll_max_ns;\n    info->poll_grow = iothread->poll_grow;\n    info->poll_shrink = iothread->poll_shrink;\n    info->aio_max_batch = iothread->parent_obj.aio_max_batch;\n\n    QAPI_LIST_APPEND(*tail, info);\n    return 0;\n}\n\nIOThreadInfoList *qmp_query_iothreads(Error **errp)\n{\n    IOThreadInfoList *head = NULL;\n    IOThreadInfoList **prev = &head;\n    Object *container = object_get_objects_root();\n\n    object_child_foreach(container, query_one_iothread, &prev);\n    return head;\n}\n\nGMainContext *iothread_get_g_main_context(IOThread *iothread)\n{\n    qatomic_set(&iothread->run_gcontext, 1);\n    aio_notify(iothread->ctx);\n    return iothread->worker_context;\n}\n\nIOThread *iothread_create(const char *id, Error **errp)\n{\n    Object *obj;\n\n    obj = object_new_with_props(TYPE_IOTHREAD,\n                                object_get_internal_root(),\n                                id, errp, NULL);\n\n    return IOTHREAD(obj);\n}\n\nvoid iothread_destroy(IOThread *iothread)\n{\n    object_unparent(OBJECT(iothread));\n}\n\n/* Lookup IOThread by its id.  Only finds user-created objects, not internal\n * iothread_create() objects. */\nIOThread *iothread_by_id(const char *id)\n{\n    return IOTHREAD(object_resolve_path_type(id, TYPE_IOTHREAD, NULL));\n}\n\nbool qemu_in_iothread(void)\n{\n    return qemu_get_current_aio_context() == qemu_get_aio_context() ?\n                    false : true;\n}\n"
        },
        {
          "name": "job-qmp.c",
          "type": "blob",
          "size": 4.8798828125,
          "content": "/*\n * QMP interface for background jobs\n *\n * Copyright (c) 2011 IBM Corp.\n * Copyright (c) 2012, 2018 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/job.h\"\n#include \"qapi/qapi-commands-job.h\"\n#include \"qapi/error.h\"\n#include \"trace/trace-root.h\"\n\n/* Get a job using its ID and acquire its AioContext */\nstatic Job *find_job(const char *id, AioContext **aio_context, Error **errp)\n{\n    Job *job;\n\n    *aio_context = NULL;\n\n    job = job_get(id);\n    if (!job) {\n        error_setg(errp, \"Job not found\");\n        return NULL;\n    }\n\n    *aio_context = job->aio_context;\n    aio_context_acquire(*aio_context);\n\n    return job;\n}\n\nvoid qmp_job_cancel(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    Job *job = find_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_job_cancel(job);\n    job_user_cancel(job, true, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_job_pause(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    Job *job = find_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_job_pause(job);\n    job_user_pause(job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_job_resume(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    Job *job = find_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_job_resume(job);\n    job_user_resume(job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_job_complete(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    Job *job = find_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_job_complete(job);\n    job_complete(job, errp);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_job_finalize(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    Job *job = find_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_job_finalize(job);\n    job_ref(job);\n    job_finalize(job, errp);\n\n    /*\n     * Job's context might have changed via job_finalize (and job_txn_apply\n     * automatically acquires the new one), so make sure we release the correct\n     * one.\n     */\n    aio_context = job->aio_context;\n    job_unref(job);\n    aio_context_release(aio_context);\n}\n\nvoid qmp_job_dismiss(const char *id, Error **errp)\n{\n    AioContext *aio_context;\n    Job *job = find_job(id, &aio_context, errp);\n\n    if (!job) {\n        return;\n    }\n\n    trace_qmp_job_dismiss(job);\n    job_dismiss(&job, errp);\n    aio_context_release(aio_context);\n}\n\nstatic JobInfo *job_query_single(Job *job, Error **errp)\n{\n    JobInfo *info;\n    uint64_t progress_current;\n    uint64_t progress_total;\n\n    assert(!job_is_internal(job));\n    progress_get_snapshot(&job->progress, &progress_current,\n                          &progress_total);\n\n    info = g_new(JobInfo, 1);\n    *info = (JobInfo) {\n        .id                 = g_strdup(job->id),\n        .type               = job_type(job),\n        .status             = job->status,\n        .current_progress   = progress_current,\n        .total_progress     = progress_total,\n        .has_error          = !!job->err,\n        .error              = job->err ? \\\n                              g_strdup(error_get_pretty(job->err)) : NULL,\n    };\n\n    return info;\n}\n\nJobInfoList *qmp_query_jobs(Error **errp)\n{\n    JobInfoList *head = NULL, **tail = &head;\n    Job *job;\n\n    for (job = job_next(NULL); job; job = job_next(job)) {\n        JobInfo *value;\n        AioContext *aio_context;\n\n        if (job_is_internal(job)) {\n            continue;\n        }\n        aio_context = job->aio_context;\n        aio_context_acquire(aio_context);\n        value = job_query_single(job, errp);\n        aio_context_release(aio_context);\n        if (!value) {\n            qapi_free_JobInfoList(head);\n            return NULL;\n        }\n        QAPI_LIST_APPEND(tail, value);\n    }\n\n    return head;\n}\n"
        },
        {
          "name": "job.c",
          "type": "blob",
          "size": 27.228515625,
          "content": "/*\n * Background jobs (long-running operations)\n *\n * Copyright (c) 2011 IBM Corp.\n * Copyright (c) 2012, 2018 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qemu/job.h\"\n#include \"qemu/id.h\"\n#include \"qemu/main-loop.h\"\n#include \"block/aio-wait.h\"\n#include \"trace/trace-root.h\"\n#include \"qapi/qapi-events-job.h\"\n\nstatic QLIST_HEAD(, Job) jobs = QLIST_HEAD_INITIALIZER(jobs);\n\n/* Job State Transition Table */\nbool JobSTT[JOB_STATUS__MAX][JOB_STATUS__MAX] = {\n                                    /* U, C, R, P, Y, S, W, D, X, E, N */\n    /* U: */ [JOB_STATUS_UNDEFINED] = {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n    /* C: */ [JOB_STATUS_CREATED]   = {0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1},\n    /* R: */ [JOB_STATUS_RUNNING]   = {0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0},\n    /* P: */ [JOB_STATUS_PAUSED]    = {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},\n    /* Y: */ [JOB_STATUS_READY]     = {0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0},\n    /* S: */ [JOB_STATUS_STANDBY]   = {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},\n    /* W: */ [JOB_STATUS_WAITING]   = {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},\n    /* D: */ [JOB_STATUS_PENDING]   = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},\n    /* X: */ [JOB_STATUS_ABORTING]  = {0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0},\n    /* E: */ [JOB_STATUS_CONCLUDED] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n    /* N: */ [JOB_STATUS_NULL]      = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n};\n\nbool JobVerbTable[JOB_VERB__MAX][JOB_STATUS__MAX] = {\n                                    /* U, C, R, P, Y, S, W, D, X, E, N */\n    [JOB_VERB_CANCEL]               = {0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0},\n    [JOB_VERB_PAUSE]                = {0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},\n    [JOB_VERB_RESUME]               = {0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},\n    [JOB_VERB_SET_SPEED]            = {0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},\n    [JOB_VERB_COMPLETE]             = {0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0},\n    [JOB_VERB_FINALIZE]             = {0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0},\n    [JOB_VERB_DISMISS]              = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},\n};\n\n/* Transactional group of jobs */\nstruct JobTxn {\n\n    /* Is this txn being cancelled? */\n    bool aborting;\n\n    /* List of jobs */\n    QLIST_HEAD(, Job) jobs;\n\n    /* Reference count */\n    int refcnt;\n};\n\n/* Right now, this mutex is only needed to synchronize accesses to job->busy\n * and job->sleep_timer, such as concurrent calls to job_do_yield and\n * job_enter. */\nstatic QemuMutex job_mutex;\n\nstatic void job_lock(void)\n{\n    qemu_mutex_lock(&job_mutex);\n}\n\nstatic void job_unlock(void)\n{\n    qemu_mutex_unlock(&job_mutex);\n}\n\nstatic void __attribute__((__constructor__)) job_init(void)\n{\n    qemu_mutex_init(&job_mutex);\n}\n\nJobTxn *job_txn_new(void)\n{\n    JobTxn *txn = g_new0(JobTxn, 1);\n    QLIST_INIT(&txn->jobs);\n    txn->refcnt = 1;\n    return txn;\n}\n\nstatic void job_txn_ref(JobTxn *txn)\n{\n    txn->refcnt++;\n}\n\nvoid job_txn_unref(JobTxn *txn)\n{\n    if (txn && --txn->refcnt == 0) {\n        g_free(txn);\n    }\n}\n\nvoid job_txn_add_job(JobTxn *txn, Job *job)\n{\n    if (!txn) {\n        return;\n    }\n\n    assert(!job->txn);\n    job->txn = txn;\n\n    QLIST_INSERT_HEAD(&txn->jobs, job, txn_list);\n    job_txn_ref(txn);\n}\n\nstatic void job_txn_del_job(Job *job)\n{\n    if (job->txn) {\n        QLIST_REMOVE(job, txn_list);\n        job_txn_unref(job->txn);\n        job->txn = NULL;\n    }\n}\n\nstatic int job_txn_apply(Job *job, int fn(Job *))\n{\n    AioContext *inner_ctx;\n    Job *other_job, *next;\n    JobTxn *txn = job->txn;\n    int rc = 0;\n\n    /*\n     * Similar to job_completed_txn_abort, we take each job's lock before\n     * applying fn, but since we assume that outer_ctx is held by the caller,\n     * we need to release it here to avoid holding the lock twice - which would\n     * break AIO_WAIT_WHILE from within fn.\n     */\n    job_ref(job);\n    aio_context_release(job->aio_context);\n\n    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {\n        inner_ctx = other_job->aio_context;\n        aio_context_acquire(inner_ctx);\n        rc = fn(other_job);\n        aio_context_release(inner_ctx);\n        if (rc) {\n            break;\n        }\n    }\n\n    /*\n     * Note that job->aio_context might have been changed by calling fn, so we\n     * can't use a local variable to cache it.\n     */\n    aio_context_acquire(job->aio_context);\n    job_unref(job);\n    return rc;\n}\n\nbool job_is_internal(Job *job)\n{\n    return (job->id == NULL);\n}\n\nstatic void job_state_transition(Job *job, JobStatus s1)\n{\n    JobStatus s0 = job->status;\n    assert(s1 >= 0 && s1 < JOB_STATUS__MAX);\n    trace_job_state_transition(job, job->ret,\n                               JobSTT[s0][s1] ? \"allowed\" : \"disallowed\",\n                               JobStatus_str(s0), JobStatus_str(s1));\n    assert(JobSTT[s0][s1]);\n    job->status = s1;\n\n    if (!job_is_internal(job) && s1 != s0) {\n        qapi_event_send_job_status_change(job->id, job->status);\n    }\n}\n\nint job_apply_verb(Job *job, JobVerb verb, Error **errp)\n{\n    JobStatus s0 = job->status;\n    assert(verb >= 0 && verb < JOB_VERB__MAX);\n    trace_job_apply_verb(job, JobStatus_str(s0), JobVerb_str(verb),\n                         JobVerbTable[verb][s0] ? \"allowed\" : \"prohibited\");\n    if (JobVerbTable[verb][s0]) {\n        return 0;\n    }\n    error_setg(errp, \"Job '%s' in state '%s' cannot accept command verb '%s'\",\n               job->id, JobStatus_str(s0), JobVerb_str(verb));\n    return -EPERM;\n}\n\nJobType job_type(const Job *job)\n{\n    return job->driver->job_type;\n}\n\nconst char *job_type_str(const Job *job)\n{\n    return JobType_str(job_type(job));\n}\n\nbool job_is_cancelled(Job *job)\n{\n    /* force_cancel may be true only if cancelled is true, too */\n    assert(job->cancelled || !job->force_cancel);\n    return job->force_cancel;\n}\n\nbool job_cancel_requested(Job *job)\n{\n    return job->cancelled;\n}\n\nbool job_is_ready(Job *job)\n{\n    switch (job->status) {\n    case JOB_STATUS_UNDEFINED:\n    case JOB_STATUS_CREATED:\n    case JOB_STATUS_RUNNING:\n    case JOB_STATUS_PAUSED:\n    case JOB_STATUS_WAITING:\n    case JOB_STATUS_PENDING:\n    case JOB_STATUS_ABORTING:\n    case JOB_STATUS_CONCLUDED:\n    case JOB_STATUS_NULL:\n        return false;\n    case JOB_STATUS_READY:\n    case JOB_STATUS_STANDBY:\n        return true;\n    default:\n        g_assert_not_reached();\n    }\n    return false;\n}\n\nbool job_is_completed(Job *job)\n{\n    switch (job->status) {\n    case JOB_STATUS_UNDEFINED:\n    case JOB_STATUS_CREATED:\n    case JOB_STATUS_RUNNING:\n    case JOB_STATUS_PAUSED:\n    case JOB_STATUS_READY:\n    case JOB_STATUS_STANDBY:\n        return false;\n    case JOB_STATUS_WAITING:\n    case JOB_STATUS_PENDING:\n    case JOB_STATUS_ABORTING:\n    case JOB_STATUS_CONCLUDED:\n    case JOB_STATUS_NULL:\n        return true;\n    default:\n        g_assert_not_reached();\n    }\n    return false;\n}\n\nstatic bool job_started(Job *job)\n{\n    return job->co;\n}\n\nstatic bool job_should_pause(Job *job)\n{\n    return job->pause_count > 0;\n}\n\nJob *job_next(Job *job)\n{\n    if (!job) {\n        return QLIST_FIRST(&jobs);\n    }\n    return QLIST_NEXT(job, job_list);\n}\n\nJob *job_get(const char *id)\n{\n    Job *job;\n\n    QLIST_FOREACH(job, &jobs, job_list) {\n        if (job->id && !strcmp(id, job->id)) {\n            return job;\n        }\n    }\n\n    return NULL;\n}\n\nstatic void job_sleep_timer_cb(void *opaque)\n{\n    Job *job = opaque;\n\n    job_enter(job);\n}\n\nvoid *job_create(const char *job_id, const JobDriver *driver, JobTxn *txn,\n                 AioContext *ctx, int flags, BlockCompletionFunc *cb,\n                 void *opaque, Error **errp)\n{\n    Job *job;\n\n    if (job_id) {\n        if (flags & JOB_INTERNAL) {\n            error_setg(errp, \"Cannot specify job ID for internal job\");\n            return NULL;\n        }\n        if (!id_wellformed(job_id)) {\n            error_setg(errp, \"Invalid job ID '%s'\", job_id);\n            return NULL;\n        }\n        if (job_get(job_id)) {\n            error_setg(errp, \"Job ID '%s' already in use\", job_id);\n            return NULL;\n        }\n    } else if (!(flags & JOB_INTERNAL)) {\n        error_setg(errp, \"An explicit job ID is required\");\n        return NULL;\n    }\n\n    job = g_malloc0(driver->instance_size);\n    job->driver        = driver;\n    job->id            = g_strdup(job_id);\n    job->refcnt        = 1;\n    job->aio_context   = ctx;\n    job->busy          = false;\n    job->paused        = true;\n    job->pause_count   = 1;\n    job->auto_finalize = !(flags & JOB_MANUAL_FINALIZE);\n    job->auto_dismiss  = !(flags & JOB_MANUAL_DISMISS);\n    job->cb            = cb;\n    job->opaque        = opaque;\n\n    progress_init(&job->progress);\n\n    notifier_list_init(&job->on_finalize_cancelled);\n    notifier_list_init(&job->on_finalize_completed);\n    notifier_list_init(&job->on_pending);\n    notifier_list_init(&job->on_ready);\n    notifier_list_init(&job->on_idle);\n\n    job_state_transition(job, JOB_STATUS_CREATED);\n    aio_timer_init(qemu_get_aio_context(), &job->sleep_timer,\n                   QEMU_CLOCK_REALTIME, SCALE_NS,\n                   job_sleep_timer_cb, job);\n\n    QLIST_INSERT_HEAD(&jobs, job, job_list);\n\n    /* Single jobs are modeled as single-job transactions for sake of\n     * consolidating the job management logic */\n    if (!txn) {\n        txn = job_txn_new();\n        job_txn_add_job(txn, job);\n        job_txn_unref(txn);\n    } else {\n        job_txn_add_job(txn, job);\n    }\n\n    return job;\n}\n\nvoid job_ref(Job *job)\n{\n    ++job->refcnt;\n}\n\nvoid job_unref(Job *job)\n{\n    GLOBAL_STATE_CODE();\n\n    if (--job->refcnt == 0) {\n        assert(job->status == JOB_STATUS_NULL);\n        assert(!timer_pending(&job->sleep_timer));\n        assert(!job->txn);\n\n        if (job->driver->free) {\n            job->driver->free(job);\n        }\n\n        QLIST_REMOVE(job, job_list);\n\n        progress_destroy(&job->progress);\n        error_free(job->err);\n        g_free(job->id);\n        g_free(job);\n    }\n}\n\nvoid job_progress_update(Job *job, uint64_t done)\n{\n    progress_work_done(&job->progress, done);\n}\n\nvoid job_progress_set_remaining(Job *job, uint64_t remaining)\n{\n    progress_set_remaining(&job->progress, remaining);\n}\n\nvoid job_progress_increase_remaining(Job *job, uint64_t delta)\n{\n    progress_increase_remaining(&job->progress, delta);\n}\n\nvoid job_event_cancelled(Job *job)\n{\n    notifier_list_notify(&job->on_finalize_cancelled, job);\n}\n\nvoid job_event_completed(Job *job)\n{\n    notifier_list_notify(&job->on_finalize_completed, job);\n}\n\nstatic void job_event_pending(Job *job)\n{\n    notifier_list_notify(&job->on_pending, job);\n}\n\nstatic void job_event_ready(Job *job)\n{\n    notifier_list_notify(&job->on_ready, job);\n}\n\nstatic void job_event_idle(Job *job)\n{\n    notifier_list_notify(&job->on_idle, job);\n}\n\nvoid job_enter_cond(Job *job, bool(*fn)(Job *job))\n{\n    if (!job_started(job)) {\n        return;\n    }\n    if (job->deferred_to_main_loop) {\n        return;\n    }\n\n    job_lock();\n    if (job->busy) {\n        job_unlock();\n        return;\n    }\n\n    if (fn && !fn(job)) {\n        job_unlock();\n        return;\n    }\n\n    assert(!job->deferred_to_main_loop);\n    timer_del(&job->sleep_timer);\n    job->busy = true;\n    job_unlock();\n    aio_co_enter(job->aio_context, job->co);\n}\n\nvoid job_enter(Job *job)\n{\n    job_enter_cond(job, NULL);\n}\n\n/* Yield, and schedule a timer to reenter the coroutine after @ns nanoseconds.\n * Reentering the job coroutine with job_enter() before the timer has expired\n * is allowed and cancels the timer.\n *\n * If @ns is (uint64_t) -1, no timer is scheduled and job_enter() must be\n * called explicitly. */\nstatic void coroutine_fn job_do_yield(Job *job, uint64_t ns)\n{\n    job_lock();\n    if (ns != -1) {\n        timer_mod(&job->sleep_timer, ns);\n    }\n    job->busy = false;\n    job_event_idle(job);\n    job_unlock();\n    qemu_coroutine_yield();\n\n    /* Set by job_enter_cond() before re-entering the coroutine.  */\n    assert(job->busy);\n}\n\nvoid coroutine_fn job_pause_point(Job *job)\n{\n    assert(job && job_started(job));\n\n    if (!job_should_pause(job)) {\n        return;\n    }\n    if (job_is_cancelled(job)) {\n        return;\n    }\n\n    if (job->driver->pause) {\n        job->driver->pause(job);\n    }\n\n    if (job_should_pause(job) && !job_is_cancelled(job)) {\n        JobStatus status = job->status;\n        job_state_transition(job, status == JOB_STATUS_READY\n                                  ? JOB_STATUS_STANDBY\n                                  : JOB_STATUS_PAUSED);\n        job->paused = true;\n        job_do_yield(job, -1);\n        job->paused = false;\n        job_state_transition(job, status);\n    }\n\n    if (job->driver->resume) {\n        job->driver->resume(job);\n    }\n}\n\nvoid job_yield(Job *job)\n{\n    assert(job->busy);\n\n    /* Check cancellation *before* setting busy = false, too!  */\n    if (job_is_cancelled(job)) {\n        return;\n    }\n\n    if (!job_should_pause(job)) {\n        job_do_yield(job, -1);\n    }\n\n    job_pause_point(job);\n}\n\nvoid coroutine_fn job_sleep_ns(Job *job, int64_t ns)\n{\n    assert(job->busy);\n\n    /* Check cancellation *before* setting busy = false, too!  */\n    if (job_is_cancelled(job)) {\n        return;\n    }\n\n    if (!job_should_pause(job)) {\n        job_do_yield(job, qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + ns);\n    }\n\n    job_pause_point(job);\n}\n\n/* Assumes the block_job_mutex is held */\nstatic bool job_timer_not_pending(Job *job)\n{\n    return !timer_pending(&job->sleep_timer);\n}\n\nvoid job_pause(Job *job)\n{\n    job->pause_count++;\n    if (!job->paused) {\n        job_enter(job);\n    }\n}\n\nvoid job_resume(Job *job)\n{\n    assert(job->pause_count > 0);\n    job->pause_count--;\n    if (job->pause_count) {\n        return;\n    }\n\n    /* kick only if no timer is pending */\n    job_enter_cond(job, job_timer_not_pending);\n}\n\nvoid job_user_pause(Job *job, Error **errp)\n{\n    if (job_apply_verb(job, JOB_VERB_PAUSE, errp)) {\n        return;\n    }\n    if (job->user_paused) {\n        error_setg(errp, \"Job is already paused\");\n        return;\n    }\n    job->user_paused = true;\n    job_pause(job);\n}\n\nbool job_user_paused(Job *job)\n{\n    return job->user_paused;\n}\n\nvoid job_user_resume(Job *job, Error **errp)\n{\n    assert(job);\n    GLOBAL_STATE_CODE();\n    if (!job->user_paused || job->pause_count <= 0) {\n        error_setg(errp, \"Can't resume a job that was not paused\");\n        return;\n    }\n    if (job_apply_verb(job, JOB_VERB_RESUME, errp)) {\n        return;\n    }\n    if (job->driver->user_resume) {\n        job->driver->user_resume(job);\n    }\n    job->user_paused = false;\n    job_resume(job);\n}\n\nstatic void job_do_dismiss(Job *job)\n{\n    assert(job);\n    job->busy = false;\n    job->paused = false;\n    job->deferred_to_main_loop = true;\n\n    job_txn_del_job(job);\n\n    job_state_transition(job, JOB_STATUS_NULL);\n    job_unref(job);\n}\n\nvoid job_dismiss(Job **jobptr, Error **errp)\n{\n    Job *job = *jobptr;\n    /* similarly to _complete, this is QMP-interface only. */\n    assert(job->id);\n    if (job_apply_verb(job, JOB_VERB_DISMISS, errp)) {\n        return;\n    }\n\n    job_do_dismiss(job);\n    *jobptr = NULL;\n}\n\nvoid job_early_fail(Job *job)\n{\n    assert(job->status == JOB_STATUS_CREATED);\n    job_do_dismiss(job);\n}\n\nstatic void job_conclude(Job *job)\n{\n    job_state_transition(job, JOB_STATUS_CONCLUDED);\n    if (job->auto_dismiss || !job_started(job)) {\n        job_do_dismiss(job);\n    }\n}\n\nstatic void job_update_rc(Job *job)\n{\n    if (!job->ret && job_is_cancelled(job)) {\n        job->ret = -ECANCELED;\n    }\n    if (job->ret) {\n        if (!job->err) {\n            error_setg(&job->err, \"%s\", strerror(-job->ret));\n        }\n        job_state_transition(job, JOB_STATUS_ABORTING);\n    }\n}\n\nstatic void job_commit(Job *job)\n{\n    assert(!job->ret);\n    GLOBAL_STATE_CODE();\n    if (job->driver->commit) {\n        job->driver->commit(job);\n    }\n}\n\nstatic void job_abort(Job *job)\n{\n    assert(job->ret);\n    GLOBAL_STATE_CODE();\n    if (job->driver->abort) {\n        job->driver->abort(job);\n    }\n}\n\nstatic void job_clean(Job *job)\n{\n    GLOBAL_STATE_CODE();\n    if (job->driver->clean) {\n        job->driver->clean(job);\n    }\n}\n\nstatic int job_finalize_single(Job *job)\n{\n    assert(job_is_completed(job));\n\n    /* Ensure abort is called for late-transactional failures */\n    job_update_rc(job);\n\n    if (!job->ret) {\n        job_commit(job);\n    } else {\n        job_abort(job);\n    }\n    job_clean(job);\n\n    if (job->cb) {\n        job->cb(job->opaque, job->ret);\n    }\n\n    /* Emit events only if we actually started */\n    if (job_started(job)) {\n        if (job_is_cancelled(job)) {\n            job_event_cancelled(job);\n        } else {\n            job_event_completed(job);\n        }\n    }\n\n    job_txn_del_job(job);\n    job_conclude(job);\n    return 0;\n}\n\nstatic void job_cancel_async(Job *job, bool force)\n{\n    GLOBAL_STATE_CODE();\n    if (job->driver->cancel) {\n        force = job->driver->cancel(job, force);\n    } else {\n        /* No .cancel() means the job will behave as if force-cancelled */\n        force = true;\n    }\n\n    if (job->user_paused) {\n        /* Do not call job_enter here, the caller will handle it.  */\n        if (job->driver->user_resume) {\n            job->driver->user_resume(job);\n        }\n        job->user_paused = false;\n        assert(job->pause_count > 0);\n        job->pause_count--;\n    }\n\n    /*\n     * Ignore soft cancel requests after the job is already done\n     * (We will still invoke job->driver->cancel() above, but if the\n     * job driver supports soft cancelling and the job is done, that\n     * should be a no-op, too.  We still call it so it can override\n     * @force.)\n     */\n    if (force || !job->deferred_to_main_loop) {\n        job->cancelled = true;\n        /* To prevent 'force == false' overriding a previous 'force == true' */\n        job->force_cancel |= force;\n    }\n}\n\nstatic void job_completed_txn_abort(Job *job)\n{\n    AioContext *ctx;\n    JobTxn *txn = job->txn;\n    Job *other_job;\n\n    if (txn->aborting) {\n        /*\n         * We are cancelled by another job, which will handle everything.\n         */\n        return;\n    }\n    txn->aborting = true;\n    job_txn_ref(txn);\n\n    /*\n     * We can only hold the single job's AioContext lock while calling\n     * job_finalize_single() because the finalization callbacks can involve\n     * calls of AIO_WAIT_WHILE(), which could deadlock otherwise.\n     * Note that the job's AioContext may change when it is finalized.\n     */\n    job_ref(job);\n    aio_context_release(job->aio_context);\n\n    /* Other jobs are effectively cancelled by us, set the status for\n     * them; this job, however, may or may not be cancelled, depending\n     * on the caller, so leave it. */\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n        if (other_job != job) {\n            ctx = other_job->aio_context;\n            aio_context_acquire(ctx);\n            /*\n             * This is a transaction: If one job failed, no result will matter.\n             * Therefore, pass force=true to terminate all other jobs as quickly\n             * as possible.\n             */\n            job_cancel_async(other_job, true);\n            aio_context_release(ctx);\n        }\n    }\n    while (!QLIST_EMPTY(&txn->jobs)) {\n        other_job = QLIST_FIRST(&txn->jobs);\n        /*\n         * The job's AioContext may change, so store it in @ctx so we\n         * release the same context that we have acquired before.\n         */\n        ctx = other_job->aio_context;\n        aio_context_acquire(ctx);\n        if (!job_is_completed(other_job)) {\n            assert(job_cancel_requested(other_job));\n            job_finish_sync(other_job, NULL, NULL);\n        }\n        job_finalize_single(other_job);\n        aio_context_release(ctx);\n    }\n\n    /*\n     * Use job_ref()/job_unref() so we can read the AioContext here\n     * even if the job went away during job_finalize_single().\n     */\n    aio_context_acquire(job->aio_context);\n    job_unref(job);\n\n    job_txn_unref(txn);\n}\n\nstatic int job_prepare(Job *job)\n{\n    GLOBAL_STATE_CODE();\n    if (job->ret == 0 && job->driver->prepare) {\n        job->ret = job->driver->prepare(job);\n        job_update_rc(job);\n    }\n    return job->ret;\n}\n\nstatic int job_needs_finalize(Job *job)\n{\n    return !job->auto_finalize;\n}\n\nstatic void job_do_finalize(Job *job)\n{\n    int rc;\n    assert(job && job->txn);\n\n    /* prepare the transaction to complete */\n    rc = job_txn_apply(job, job_prepare);\n    if (rc) {\n        job_completed_txn_abort(job);\n    } else {\n        job_txn_apply(job, job_finalize_single);\n    }\n}\n\nvoid job_finalize(Job *job, Error **errp)\n{\n    assert(job && job->id);\n    if (job_apply_verb(job, JOB_VERB_FINALIZE, errp)) {\n        return;\n    }\n    job_do_finalize(job);\n}\n\nstatic int job_transition_to_pending(Job *job)\n{\n    job_state_transition(job, JOB_STATUS_PENDING);\n    if (!job->auto_finalize) {\n        job_event_pending(job);\n    }\n    return 0;\n}\n\nvoid job_transition_to_ready(Job *job)\n{\n    job_state_transition(job, JOB_STATUS_READY);\n    job_event_ready(job);\n}\n\nstatic void job_completed_txn_success(Job *job)\n{\n    JobTxn *txn = job->txn;\n    Job *other_job;\n\n    job_state_transition(job, JOB_STATUS_WAITING);\n\n    /*\n     * Successful completion, see if there are other running jobs in this\n     * txn.\n     */\n    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {\n        if (!job_is_completed(other_job)) {\n            return;\n        }\n        assert(other_job->ret == 0);\n    }\n\n    job_txn_apply(job, job_transition_to_pending);\n\n    /* If no jobs need manual finalization, automatically do so */\n    if (job_txn_apply(job, job_needs_finalize) == 0) {\n        job_do_finalize(job);\n    }\n}\n\nstatic void job_completed(Job *job)\n{\n    assert(job && job->txn && !job_is_completed(job));\n\n    job_update_rc(job);\n    trace_job_completed(job, job->ret);\n    if (job->ret) {\n        job_completed_txn_abort(job);\n    } else {\n        job_completed_txn_success(job);\n    }\n}\n\n/** Useful only as a type shim for aio_bh_schedule_oneshot. */\nstatic void job_exit(void *opaque)\n{\n    Job *job = (Job *)opaque;\n    AioContext *ctx;\n\n    job_ref(job);\n    aio_context_acquire(job->aio_context);\n\n    /* This is a lie, we're not quiescent, but still doing the completion\n     * callbacks. However, completion callbacks tend to involve operations that\n     * drain block nodes, and if .drained_poll still returned true, we would\n     * deadlock. */\n    job->busy = false;\n    job_event_idle(job);\n\n    job_completed(job);\n\n    /*\n     * Note that calling job_completed can move the job to a different\n     * aio_context, so we cannot cache from above. job_txn_apply takes care of\n     * acquiring the new lock, and we ref/unref to avoid job_completed freeing\n     * the job underneath us.\n     */\n    ctx = job->aio_context;\n    job_unref(job);\n    aio_context_release(ctx);\n}\n\n/**\n * All jobs must allow a pause point before entering their job proper. This\n * ensures that jobs can be paused prior to being started, then resumed later.\n */\nstatic void coroutine_fn job_co_entry(void *opaque)\n{\n    Job *job = opaque;\n\n    assert(job && job->driver && job->driver->run);\n    assert(job->aio_context == qemu_get_current_aio_context());\n    job_pause_point(job);\n    job->ret = job->driver->run(job, &job->err);\n    job->deferred_to_main_loop = true;\n    job->busy = true;\n    aio_bh_schedule_oneshot(qemu_get_aio_context(), job_exit, job);\n}\n\nvoid job_start(Job *job)\n{\n    assert(job && !job_started(job) && job->paused &&\n           job->driver && job->driver->run);\n    job->co = qemu_coroutine_create(job_co_entry, job);\n    job->pause_count--;\n    job->busy = true;\n    job->paused = false;\n    job_state_transition(job, JOB_STATUS_RUNNING);\n    aio_co_enter(job->aio_context, job->co);\n}\n\nvoid job_cancel(Job *job, bool force)\n{\n    if (job->status == JOB_STATUS_CONCLUDED) {\n        job_do_dismiss(job);\n        return;\n    }\n    job_cancel_async(job, force);\n    if (!job_started(job)) {\n        job_completed(job);\n    } else if (job->deferred_to_main_loop) {\n        /*\n         * job_cancel_async() ignores soft-cancel requests for jobs\n         * that are already done (i.e. deferred to the main loop).  We\n         * have to check again whether the job is really cancelled.\n         * (job_cancel_requested() and job_is_cancelled() are equivalent\n         * here, because job_cancel_async() will make soft-cancel\n         * requests no-ops when deferred_to_main_loop is true.  We\n         * choose to call job_is_cancelled() to show that we invoke\n         * job_completed_txn_abort() only for force-cancelled jobs.)\n         */\n        if (job_is_cancelled(job)) {\n            job_completed_txn_abort(job);\n        }\n    } else {\n        job_enter(job);\n    }\n}\n\nvoid job_user_cancel(Job *job, bool force, Error **errp)\n{\n    if (job_apply_verb(job, JOB_VERB_CANCEL, errp)) {\n        return;\n    }\n    job_cancel(job, force);\n}\n\n/* A wrapper around job_cancel() taking an Error ** parameter so it may be\n * used with job_finish_sync() without the need for (rather nasty) function\n * pointer casts there. */\nstatic void job_cancel_err(Job *job, Error **errp)\n{\n    job_cancel(job, false);\n}\n\n/**\n * Same as job_cancel_err(), but force-cancel.\n */\nstatic void job_force_cancel_err(Job *job, Error **errp)\n{\n    job_cancel(job, true);\n}\n\nint job_cancel_sync(Job *job, bool force)\n{\n    if (force) {\n        return job_finish_sync(job, &job_force_cancel_err, NULL);\n    } else {\n        return job_finish_sync(job, &job_cancel_err, NULL);\n    }\n}\n\nvoid job_cancel_sync_all(void)\n{\n    Job *job;\n    AioContext *aio_context;\n\n    while ((job = job_next(NULL))) {\n        aio_context = job->aio_context;\n        aio_context_acquire(aio_context);\n        job_cancel_sync(job, true);\n        aio_context_release(aio_context);\n    }\n}\n\nint job_complete_sync(Job *job, Error **errp)\n{\n    return job_finish_sync(job, job_complete, errp);\n}\n\nvoid job_complete(Job *job, Error **errp)\n{\n    /* Should not be reachable via external interface for internal jobs */\n    assert(job->id);\n    GLOBAL_STATE_CODE();\n    if (job_apply_verb(job, JOB_VERB_COMPLETE, errp)) {\n        return;\n    }\n    if (job_cancel_requested(job) || !job->driver->complete) {\n        error_setg(errp, \"The active block job '%s' cannot be completed\",\n                   job->id);\n        return;\n    }\n\n    job->driver->complete(job, errp);\n}\n\nint job_finish_sync(Job *job, void (*finish)(Job *, Error **errp), Error **errp)\n{\n    Error *local_err = NULL;\n    int ret;\n\n    job_ref(job);\n\n    if (finish) {\n        finish(job, &local_err);\n    }\n    if (local_err) {\n        error_propagate(errp, local_err);\n        job_unref(job);\n        return -EBUSY;\n    }\n\n    AIO_WAIT_WHILE(job->aio_context,\n                   (job_enter(job), !job_is_completed(job)));\n\n    ret = (job_is_cancelled(job) && job->ret == 0) ? -ECANCELED : job->ret;\n    job_unref(job);\n    return ret;\n}\n"
        },
        {
          "name": "libdecnumber",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux-headers",
          "type": "tree",
          "content": null
        },
        {
          "name": "linux-user",
          "type": "tree",
          "content": null
        },
        {
          "name": "memory_ldst.c.inc",
          "type": "blob",
          "size": 15.7158203125,
          "content": "/*\n *  Physical memory access templates\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *  Copyright (c) 2015 Linaro, Inc.\n *  Copyright (c) 2016 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/* warning: addr must be aligned */\nstatic inline uint32_t glue(address_space_ldl_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result,\n    enum device_endian endian)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 4;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false, attrs);\n    if (l < 4 || !memory_access_is_direct(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        r = memory_region_dispatch_read(mr, addr1, &val,\n                                        MO_32 | devend_memop(endian), attrs);\n    } else {\n        /* RAM case */\n        fuzz_dma_read_cb(addr, 4, mr);\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            val = ldl_le_p(ptr);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            val = ldl_be_p(ptr);\n            break;\n        default:\n            val = ldl_p(ptr);\n            break;\n        }\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint32_t glue(address_space_ldl, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_NATIVE_ENDIAN);\n}\n\nuint32_t glue(address_space_ldl_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_LITTLE_ENDIAN);\n}\n\nuint32_t glue(address_space_ldl_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldl_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_BIG_ENDIAN);\n}\n\n/* warning: addr must be aligned */\nstatic inline uint64_t glue(address_space_ldq_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result,\n    enum device_endian endian)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 8;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false, attrs);\n    if (l < 8 || !memory_access_is_direct(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        r = memory_region_dispatch_read(mr, addr1, &val,\n                                        MO_64 | devend_memop(endian), attrs);\n    } else {\n        /* RAM case */\n        fuzz_dma_read_cb(addr, 8, mr);\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            val = ldq_le_p(ptr);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            val = ldq_be_p(ptr);\n            break;\n        default:\n            val = ldq_p(ptr);\n            break;\n        }\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint64_t glue(address_space_ldq, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_NATIVE_ENDIAN);\n}\n\nuint64_t glue(address_space_ldq_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_LITTLE_ENDIAN);\n}\n\nuint64_t glue(address_space_ldq_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_ldq_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                    DEVICE_BIG_ENDIAN);\n}\n\nuint8_t glue(address_space_ldub, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 1;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false, attrs);\n    if (!memory_access_is_direct(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        r = memory_region_dispatch_read(mr, addr1, &val, MO_8, attrs);\n    } else {\n        /* RAM case */\n        fuzz_dma_read_cb(addr, 1, mr);\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        val = ldub_p(ptr);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\n/* warning: addr must be aligned */\nstatic inline uint16_t glue(address_space_lduw_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result,\n    enum device_endian endian)\n{\n    uint8_t *ptr;\n    uint64_t val;\n    MemoryRegion *mr;\n    hwaddr l = 2;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, false, attrs);\n    if (l < 2 || !memory_access_is_direct(mr, false)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        /* I/O case */\n        r = memory_region_dispatch_read(mr, addr1, &val,\n                                        MO_16 | devend_memop(endian), attrs);\n    } else {\n        /* RAM case */\n        fuzz_dma_read_cb(addr, 2, mr);\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            val = lduw_le_p(ptr);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            val = lduw_be_p(ptr);\n            break;\n        default:\n            val = lduw_p(ptr);\n            break;\n        }\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n    return val;\n}\n\nuint16_t glue(address_space_lduw, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                     DEVICE_NATIVE_ENDIAN);\n}\n\nuint16_t glue(address_space_lduw_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                                     DEVICE_LITTLE_ENDIAN);\n}\n\nuint16_t glue(address_space_lduw_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, MemTxAttrs attrs, MemTxResult *result)\n{\n    return glue(address_space_lduw_internal, SUFFIX)(ARG1, addr, attrs, result,\n                                       DEVICE_BIG_ENDIAN);\n}\n\n/* warning: addr must be aligned. The ram page is not masked as dirty\n   and the code inside is not invalidated. It is useful if the dirty\n   bits are used to track modified PTEs */\nvoid glue(address_space_stl_notdirty, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 4;\n    hwaddr addr1;\n    MemTxResult r;\n    uint8_t dirty_log_mask;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true, attrs);\n    if (l < 4 || !memory_access_is_direct(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n\n        r = memory_region_dispatch_write(mr, addr1, val, MO_32, attrs);\n    } else {\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        stl_p(ptr, val);\n\n        dirty_log_mask = memory_region_get_dirty_log_mask(mr);\n        dirty_log_mask &= ~(1 << DIRTY_MEMORY_CODE);\n        cpu_physical_memory_set_dirty_range(memory_region_get_ram_addr(mr) + addr,\n                                            4, dirty_log_mask);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\n/* warning: addr must be aligned */\nstatic inline void glue(address_space_stl_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs,\n    MemTxResult *result, enum device_endian endian)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 4;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true, attrs);\n    if (l < 4 || !memory_access_is_direct(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n        r = memory_region_dispatch_write(mr, addr1, val,\n                                         MO_32 | devend_memop(endian), attrs);\n    } else {\n        /* RAM case */\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            stl_le_p(ptr, val);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            stl_be_p(ptr, val);\n            break;\n        default:\n            stl_p(ptr, val);\n            break;\n        }\n        invalidate_and_set_dirty(mr, addr1, 4);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(address_space_stl, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,\n                                             result, DEVICE_NATIVE_ENDIAN);\n}\n\nvoid glue(address_space_stl_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,\n                                             result, DEVICE_LITTLE_ENDIAN);\n}\n\nvoid glue(address_space_stl_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint32_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stl_internal, SUFFIX)(ARG1, addr, val, attrs,\n                                             result, DEVICE_BIG_ENDIAN);\n}\n\nvoid glue(address_space_stb, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint8_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 1;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true, attrs);\n    if (!memory_access_is_direct(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n        r = memory_region_dispatch_write(mr, addr1, val, MO_8, attrs);\n    } else {\n        /* RAM case */\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        stb_p(ptr, val);\n        invalidate_and_set_dirty(mr, addr1, 1);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\n/* warning: addr must be aligned */\nstatic inline void glue(address_space_stw_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint16_t val, MemTxAttrs attrs,\n    MemTxResult *result, enum device_endian endian)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 2;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true, attrs);\n    if (l < 2 || !memory_access_is_direct(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n        r = memory_region_dispatch_write(mr, addr1, val,\n                                         MO_16 | devend_memop(endian), attrs);\n    } else {\n        /* RAM case */\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            stw_le_p(ptr, val);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            stw_be_p(ptr, val);\n            break;\n        default:\n            stw_p(ptr, val);\n            break;\n        }\n        invalidate_and_set_dirty(mr, addr1, 2);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(address_space_stw, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint16_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_NATIVE_ENDIAN);\n}\n\nvoid glue(address_space_stw_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint16_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_LITTLE_ENDIAN);\n}\n\nvoid glue(address_space_stw_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint16_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stw_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                               DEVICE_BIG_ENDIAN);\n}\n\nstatic void glue(address_space_stq_internal, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs,\n    MemTxResult *result, enum device_endian endian)\n{\n    uint8_t *ptr;\n    MemoryRegion *mr;\n    hwaddr l = 8;\n    hwaddr addr1;\n    MemTxResult r;\n    bool release_lock = false;\n\n    RCU_READ_LOCK();\n    mr = TRANSLATE(addr, &addr1, &l, true, attrs);\n    if (l < 8 || !memory_access_is_direct(mr, true)) {\n        release_lock |= prepare_mmio_access(mr);\n        r = memory_region_dispatch_write(mr, addr1, val,\n                                         MO_64 | devend_memop(endian), attrs);\n    } else {\n        /* RAM case */\n        ptr = qemu_map_ram_ptr(mr->ram_block, addr1);\n        switch (endian) {\n        case DEVICE_LITTLE_ENDIAN:\n            stq_le_p(ptr, val);\n            break;\n        case DEVICE_BIG_ENDIAN:\n            stq_be_p(ptr, val);\n            break;\n        default:\n            stq_p(ptr, val);\n            break;\n        }\n        invalidate_and_set_dirty(mr, addr1, 8);\n        r = MEMTX_OK;\n    }\n    if (result) {\n        *result = r;\n    }\n    if (release_lock) {\n        qemu_mutex_unlock_iothread();\n    }\n    RCU_READ_UNLOCK();\n}\n\nvoid glue(address_space_stq, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_NATIVE_ENDIAN);\n}\n\nvoid glue(address_space_stq_le, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_LITTLE_ENDIAN);\n}\n\nvoid glue(address_space_stq_be, SUFFIX)(ARG1_DECL,\n    hwaddr addr, uint64_t val, MemTxAttrs attrs, MemTxResult *result)\n{\n    glue(address_space_stq_internal, SUFFIX)(ARG1, addr, val, attrs, result,\n                                             DEVICE_BIG_ENDIAN);\n}\n\n#undef ARG1_DECL\n#undef ARG1\n#undef SUFFIX\n#undef TRANSLATE\n#undef RCU_READ_LOCK\n#undef RCU_READ_UNLOCK\n"
        },
        {
          "name": "meson",
          "type": "commit",
          "content": null
        },
        {
          "name": "meson.build",
          "type": "blob",
          "size": 144.5615234375,
          "content": "project('qemu', ['c'], meson_version: '>=0.59.3',\n        default_options: ['warning_level=1', 'c_std=gnu11', 'cpp_std=gnu++11', 'b_colorout=auto',\n                          'b_staticpic=false', 'stdsplit=false', 'optimization=2', 'b_pie=true'],\n        version: files('VERSION.QEMU'))\n\nadd_test_setup('quick', exclude_suites: ['slow', 'thorough'], is_default: true)\nadd_test_setup('slow', exclude_suites: ['thorough'], env: ['G_TEST_SLOW=1', 'SPEED=slow'])\nadd_test_setup('thorough', env: ['G_TEST_SLOW=1', 'SPEED=thorough'])\n\nmeson.add_postconf_script(find_program('scripts/symlink-install-tree.py'))\n\nnot_found = dependency('', required: false)\nkeyval = import('keyval')\nss = import('sourceset')\nfs = import('fs')\n\nsh = find_program('sh')\ncc = meson.get_compiler('c')\nconfig_host = keyval.load(meson.current_build_dir() / 'config-host.mak')\nenable_modules = 'CONFIG_MODULES' in config_host\nenable_static = 'CONFIG_STATIC' in config_host\n\n# Allow both shared and static libraries unless --enable-static\nstatic_kwargs = enable_static ? {'static': true} : {}\n\n# Temporary directory used for files created while\n# configure runs. Since it is in the build directory\n# we can safely blow away any previous version of it\n# (and we need not jump through hoops to try to delete\n# it when configure exits.)\ntmpdir = meson.current_build_dir() / 'meson-private/temp'\n\nif get_option('qemu_suffix').startswith('/')\n  error('qemu_suffix cannot start with a /')\nendif\n\nqemu_confdir = get_option('sysconfdir') / get_option('qemu_suffix')\nqemu_datadir = get_option('datadir') / get_option('qemu_suffix')\nqemu_docdir = get_option('docdir') / get_option('qemu_suffix')\nqemu_moddir = get_option('libdir') / get_option('qemu_suffix')\n\nqemu_desktopdir = get_option('datadir') / 'applications'\nqemu_icondir = get_option('datadir') / 'icons'\n\nconfig_host_data = configuration_data()\ngenh = []\nqapi_trace_events = []\n\nbsd_oses = ['gnu/kfreebsd', 'freebsd', 'netbsd', 'openbsd', 'dragonfly', 'darwin']\nsupported_oses = ['windows', 'freebsd', 'netbsd', 'openbsd', 'darwin', 'sunos', 'linux']\nsupported_cpus = ['ppc', 'ppc64', 's390x', 'riscv', 'x86', 'x86_64',\n  'arm', 'aarch64', 'loongarch64', 'mips', 'mips64', 'sparc', 'sparc64']\n\ncpu = host_machine.cpu_family()\n\n# Unify riscv* to a single family.\nif cpu in ['riscv32', 'riscv64']\n  cpu = 'riscv'\nendif\n\ntargetos = host_machine.system()\n\ntarget_dirs = config_host['TARGET_DIRS'].split()\nhave_linux_user = false\nhave_bsd_user = false\nhave_system = false\nforeach target : target_dirs\n  have_linux_user = have_linux_user or target.endswith('linux-user')\n  have_bsd_user = have_bsd_user or target.endswith('bsd-user')\n  have_system = have_system or target.endswith('-softmmu')\nendforeach\nhave_user = have_linux_user or have_bsd_user\nhave_tools = get_option('tools') \\\n  .disable_auto_if(not have_system) \\\n  .allowed()\nhave_ga = get_option('guest_agent') \\\n  .disable_auto_if(not have_system and not have_tools) \\\n  .require(targetos in ['sunos', 'linux', 'windows'],\n           error_message: 'unsupported OS for QEMU guest agent') \\\n  .allowed()\nhave_block = have_system or have_tools\n\npython = import('python').find_installation()\n\nif cpu not in supported_cpus\n  host_arch = 'unknown'\nelif cpu == 'x86'\n  host_arch = 'i386'\nelif cpu == 'mips64'\n  host_arch = 'mips'\nelse\n  host_arch = cpu\nendif\n\nif cpu in ['x86', 'x86_64']\n  kvm_targets = ['i386-softmmu', 'x86_64-softmmu']\nelif cpu == 'aarch64'\n  kvm_targets = ['aarch64-softmmu']\nelif cpu == 's390x'\n  kvm_targets = ['s390x-softmmu']\nelif cpu in ['ppc', 'ppc64']\n  kvm_targets = ['ppc-softmmu', 'ppc64-softmmu']\nelif cpu in ['mips', 'mips64']\n  kvm_targets = ['mips-softmmu', 'mipsel-softmmu', 'mips64-softmmu', 'mips64el-softmmu']\nelif cpu in ['riscv']\n  kvm_targets = ['riscv32-softmmu', 'riscv64-softmmu']\nelse\n  kvm_targets = []\nendif\n\nkvm_targets_c = '\"\"'\nif get_option('kvm').allowed() and targetos == 'linux'\n  kvm_targets_c = '\"' + '\" ,\"'.join(kvm_targets) + '\"'\nendif\nconfig_host_data.set('CONFIG_KVM_TARGETS', kvm_targets_c)\n\naccelerator_targets = { 'CONFIG_KVM': kvm_targets }\n\nif cpu in ['aarch64']\n  accelerator_targets += {\n    'CONFIG_HVF': ['aarch64-softmmu']\n  }\nendif\n\nif cpu in ['x86', 'x86_64', 'arm', 'aarch64']\n  # i386 emulator provides xenpv machine type for multiple architectures\n  accelerator_targets += {\n    'CONFIG_XEN': ['i386-softmmu', 'x86_64-softmmu'],\n  }\nendif\nif cpu in ['x86', 'x86_64']\n  accelerator_targets += {\n    'CONFIG_HAX': ['i386-softmmu', 'x86_64-softmmu'],\n    'CONFIG_HVF': ['x86_64-softmmu'],\n    'CONFIG_NVMM': ['i386-softmmu', 'x86_64-softmmu'],\n    'CONFIG_WHPX': ['i386-softmmu', 'x86_64-softmmu'],\n  }\nendif\n\nmodular_tcg = []\n# Darwin does not support references to thread-local variables in modules\nif targetos != 'darwin'\n  modular_tcg = ['i386-softmmu', 'x86_64-softmmu']\nendif\n\nedk2_targets = [ 'arm-softmmu', 'aarch64-softmmu', 'i386-softmmu', 'x86_64-softmmu' ]\nunpack_edk2_blobs = false\nforeach target : edk2_targets\n  if target in target_dirs\n    bzip2 = find_program('bzip2', required: get_option('install_blobs'))\n    unpack_edk2_blobs = bzip2.found()\n    break\n  endif\nendforeach\n\ndtrace = not_found\nstap = not_found\nif 'dtrace' in get_option('trace_backends')\n  dtrace = find_program('dtrace', required: true)\n  stap = find_program('stap', required: false)\n  if stap.found()\n    # Workaround to avoid dtrace(1) producing a file with 'hidden' symbol\n    # visibility. Define STAP_SDT_V2 to produce 'default' symbol visibility\n    # instead. QEMU --enable-modules depends on this because the SystemTap\n    # semaphores are linked into the main binary and not the module's shared\n    # object.\n    add_global_arguments('-DSTAP_SDT_V2',\n                         native: false, language: ['c', 'cpp', 'objc'])\n  endif\nendif\n\nif get_option('iasl') == ''\n  iasl = find_program('iasl', required: false)\nelse\n  iasl = find_program(get_option('iasl'), required: true)\nendif\n\n##################\n# Compiler flags #\n##################\n\nqemu_cflags = config_host['QEMU_CFLAGS'].split()\nqemu_cxxflags = config_host['QEMU_CXXFLAGS'].split()\nqemu_objcflags = config_host['QEMU_OBJCFLAGS'].split()\nqemu_ldflags = config_host['QEMU_LDFLAGS'].split()\n\nif targetos == 'windows'\n  qemu_ldflags += cc.get_supported_link_arguments('-Wl,--no-seh', '-Wl,--nxcompat')\n  # Disable ASLR for debug builds to allow debugging with gdb\n  if get_option('optimization') == '0'\n    qemu_ldflags += cc.get_supported_link_arguments('-Wl,--dynamicbase')\n  endif\nendif\n\nif get_option('gprof')\n  qemu_cflags += ['-p']\n  qemu_cxxflags += ['-p']\n  qemu_objcflags += ['-p']\n  qemu_ldflags += ['-p']\nendif\n\n# Specify linker-script with add_project_link_arguments so that it is not placed\n# within a linker --start-group/--end-group pair\nif get_option('fuzzing')\n  add_project_link_arguments(['-Wl,-T,',\n                              (meson.current_source_dir() / 'tests/qtest/fuzz/fork_fuzz.ld')],\n                             native: false, language: ['c', 'cpp', 'objc'])\n\n  # Specify a filter to only instrument code that is directly related to\n  # virtual-devices.\n  configure_file(output: 'instrumentation-filter',\n                 input: 'scripts/oss-fuzz/instrumentation-filter-template',\n                 copy: true)\n\n  if cc.compiles('int main () { return 0; }',\n                  name: '-fsanitize-coverage-allowlist=/dev/null',\n                 args: ['-fsanitize-coverage-allowlist=/dev/null',\n                        '-fsanitize-coverage=trace-pc'] )\n    add_global_arguments('-fsanitize-coverage-allowlist=instrumentation-filter',\n                         native: false, language: ['c', 'cpp', 'objc'])\n  endif\n\n  if get_option('fuzzing_engine') == ''\n    # Add CFLAGS to tell clang to add fuzzer-related instrumentation to all the\n    # compiled code.  To build non-fuzzer binaries with --enable-fuzzing, link\n    # everything with fsanitize=fuzzer-no-link. Otherwise, the linker will be\n    # unable to bind the fuzzer-related callbacks added by instrumentation.\n    add_global_arguments('-fsanitize=fuzzer-no-link',\n                         native: false, language: ['c', 'cpp', 'objc'])\n    add_global_link_arguments('-fsanitize=fuzzer-no-link',\n                              native: false, language: ['c', 'cpp', 'objc'])\n    # For the actual fuzzer binaries, we need to link against the libfuzzer\n    # library. They need to be configurable, to support OSS-Fuzz\n    fuzz_exe_ldflags = ['-fsanitize=fuzzer']\n  else\n    # LIB_FUZZING_ENGINE was set; assume we are running on OSS-Fuzz, and\n    # the needed CFLAGS have already been provided\n    fuzz_exe_ldflags = get_option('fuzzing_engine').split()\n  endif\nendif\n\nadd_global_arguments(qemu_cflags, native: false, language: ['c'])\nadd_global_arguments(qemu_cxxflags, native: false, language: ['cpp'])\nadd_global_arguments(qemu_objcflags, native: false, language: ['objc'])\nadd_global_link_arguments(qemu_ldflags, native: false, language: ['c', 'cpp', 'objc'])\n\nif targetos == 'linux'\n  add_project_arguments('-isystem', meson.current_source_dir() / 'linux-headers',\n                        '-isystem', 'linux-headers',\n                        language: ['c', 'cpp'])\nendif\n\nadd_project_arguments('-iquote', '.',\n                      '-iquote', meson.current_source_dir(),\n                      '-iquote', meson.current_source_dir() / 'include',\n                      language: ['c', 'cpp', 'objc'])\n\nlink_language = meson.get_external_property('link_language', 'cpp')\nif link_language == 'cpp'\n  add_languages('cpp', required: true, native: false)\n  cxx = meson.get_compiler('cpp')\n  linker = cxx\nelse\n  linker = cc\nendif\nif host_machine.system() == 'darwin'\n  add_languages('objc', required: false, native: false)\nendif\n\nsparse = find_program('cgcc', required: get_option('sparse'))\nif sparse.found()\n  run_target('sparse',\n             command: [find_program('scripts/check_sparse.py'),\n                       'compile_commands.json', sparse.full_path(), '-Wbitwise',\n                       '-Wno-transparent-union', '-Wno-old-initializer',\n                       '-Wno-non-pointer-null'])\nendif\n\n###########################################\n# Target-specific checks and dependencies #\n###########################################\n\n# Fuzzing\nif get_option('fuzzing') and get_option('fuzzing_engine') == '' and \\\n    not cc.links('''\n          #include <stdint.h>\n          #include <sys/types.h>\n          int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size);\n          int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { return 0; }\n        ''',\n        args: ['-Werror', '-fsanitize=fuzzer'])\n  error('Your compiler does not support -fsanitize=fuzzer')\nendif\n\n# Tracing backends\nif 'ftrace' in get_option('trace_backends') and targetos != 'linux'\n  error('ftrace is supported only on Linux')\nendif\nif 'syslog' in get_option('trace_backends') and not cc.compiles('''\n    #include <syslog.h>\n    int main(void) {\n        openlog(\"qemu\", LOG_PID, LOG_DAEMON);\n        syslog(LOG_INFO, \"configure\");\n        return 0;\n    }''')\n  error('syslog is not supported on this system')\nendif\n\n# Miscellaneous Linux-only features\nget_option('mpath') \\\n  .require(targetos == 'linux', error_message: 'Multipath is supported only on Linux')\n\nmultiprocess_allowed = get_option('multiprocess') \\\n  .require(targetos == 'linux', error_message: 'Multiprocess QEMU is supported only on Linux') \\\n  .allowed()\n\nvfio_user_server_allowed = get_option('vfio_user_server') \\\n  .require(targetos == 'linux', error_message: 'vfio-user server is supported only on Linux') \\\n  .allowed()\n\nhave_tpm = get_option('tpm') \\\n  .require(targetos != 'windows', error_message: 'TPM emulation only available on POSIX systems') \\\n  .allowed()\n\n# vhost\nhave_vhost_user = get_option('vhost_user') \\\n  .disable_auto_if(targetos != 'linux') \\\n  .require(targetos != 'windows',\n           error_message: 'vhost-user is not available on Windows').allowed()\nhave_vhost_vdpa = get_option('vhost_vdpa') \\\n  .require(targetos == 'linux',\n           error_message: 'vhost-vdpa is only available on Linux').allowed()\nhave_vhost_kernel = get_option('vhost_kernel') \\\n  .require(targetos == 'linux',\n           error_message: 'vhost-kernel is only available on Linux').allowed()\nhave_vhost_user_crypto = get_option('vhost_crypto') \\\n  .require(have_vhost_user,\n           error_message: 'vhost-crypto requires vhost-user to be enabled').allowed()\n\nhave_vhost = have_vhost_user or have_vhost_vdpa or have_vhost_kernel\n\nhave_vhost_net_user = have_vhost_user and get_option('vhost_net').allowed()\nhave_vhost_net_vdpa = have_vhost_vdpa and get_option('vhost_net').allowed()\nhave_vhost_net_kernel = have_vhost_kernel and get_option('vhost_net').allowed()\nhave_vhost_net = have_vhost_net_kernel or have_vhost_net_user or have_vhost_net_vdpa\n\n# Target-specific libraries and flags\nlibm = cc.find_library('m', required: false)\nthreads = dependency('threads')\nutil = cc.find_library('util', required: false)\nwinmm = []\nsocket = []\nversion_res = []\ncoref = []\niokit = []\nemulator_link_args = []\nnvmm =not_found\nhvf = not_found\nmidl = not_found\nwidl = not_found\npathcch = not_found\nhost_dsosuf = '.so'\nif targetos == 'windows'\n  midl = find_program('midl', required: false)\n  widl = find_program('widl', required: false)\n  pathcch = cc.find_library('pathcch')\n  socket = cc.find_library('ws2_32')\n  winmm = cc.find_library('winmm')\n\n  win = import('windows')\n  version_res = win.compile_resources('version.rc',\n                                      depend_files: files('pc-bios/qemu-nsis.ico'),\n                                      include_directories: include_directories('.'))\n  host_dsosuf = '.dll'\nelif targetos == 'darwin'\n  coref = dependency('appleframeworks', modules: 'CoreFoundation')\n  iokit = dependency('appleframeworks', modules: 'IOKit', required: false)\n  host_dsosuf = '.dylib'\nelif targetos == 'sunos'\n  socket = [cc.find_library('socket'),\n            cc.find_library('nsl'),\n            cc.find_library('resolv')]\nelif targetos == 'haiku'\n  socket = [cc.find_library('posix_error_mapper'),\n            cc.find_library('network'),\n            cc.find_library('bsd')]\nelif targetos == 'openbsd'\n  if get_option('tcg').allowed() and target_dirs.length() > 0\n    # Disable OpenBSD W^X if available\n    emulator_link_args = cc.get_supported_link_arguments('-Wl,-z,wxneeded')\n  endif\nendif\n\n# Target-specific configuration of accelerators\naccelerators = []\nif get_option('kvm').allowed() and targetos == 'linux'\n  accelerators += 'CONFIG_KVM'\nendif\nif get_option('whpx').allowed() and targetos == 'windows'\n  if get_option('whpx').enabled() and host_machine.cpu() != 'x86_64'\n    error('WHPX requires 64-bit host')\n  elif cc.has_header('WinHvPlatform.h', required: get_option('whpx')) and \\\n       cc.has_header('WinHvEmulation.h', required: get_option('whpx'))\n    accelerators += 'CONFIG_WHPX'\n  endif\nendif\nif get_option('hvf').allowed()\n  hvf = dependency('appleframeworks', modules: 'Hypervisor',\n                   required: get_option('hvf'))\n  if hvf.found()\n    accelerators += 'CONFIG_HVF'\n  endif\nendif\nif get_option('hax').allowed()\n  if get_option('hax').enabled() or targetos in ['windows', 'darwin', 'netbsd']\n    accelerators += 'CONFIG_HAX'\n  endif\nendif\nif targetos == 'netbsd'\n  nvmm = cc.find_library('nvmm', required: get_option('nvmm'))\n  if nvmm.found()\n    accelerators += 'CONFIG_NVMM'\n  endif\nendif\n\ntcg_arch = host_arch\nif get_option('tcg').allowed()\n  if host_arch == 'unknown'\n    if get_option('tcg_interpreter')\n      warning('Unsupported CPU @0@, will use TCG with TCI (slow)'.format(cpu))\n    else\n      error('Unsupported CPU @0@, try --enable-tcg-interpreter'.format(cpu))\n    endif\n  elif get_option('tcg_interpreter')\n    warning('Use of the TCG interpreter is not recommended on this host')\n    warning('architecture. There is a native TCG execution backend available')\n    warning('which provides substantially better performance and reliability.')\n    warning('It is strongly recommended to remove the --enable-tcg-interpreter')\n    warning('configuration option on this architecture to use the native')\n    warning('backend.')\n  endif\n  if get_option('tcg_interpreter')\n    tcg_arch = 'tci'\n  elif host_arch == 'sparc64'\n    tcg_arch = 'sparc'\n  elif host_arch == 'x86_64'\n    tcg_arch = 'i386'\n  elif host_arch == 'ppc64'\n    tcg_arch = 'ppc'\n  endif\n  add_project_arguments('-iquote', meson.current_source_dir() / 'tcg' / tcg_arch,\n                        language: ['c', 'cpp', 'objc'])\n\n  accelerators += 'CONFIG_TCG'\n  config_host += { 'CONFIG_TCG': 'y' }\nendif\n\nif 'CONFIG_KVM' not in accelerators and get_option('kvm').enabled()\n  error('KVM not available on this platform')\nendif\nif 'CONFIG_HVF' not in accelerators and get_option('hvf').enabled()\n  error('HVF not available on this platform')\nendif\nif 'CONFIG_NVMM' not in accelerators and get_option('nvmm').enabled()\n  error('NVMM not available on this platform')\nendif\nif 'CONFIG_WHPX' not in accelerators and get_option('whpx').enabled()\n  error('WHPX not available on this platform')\nendif\n\n################\n# Dependencies #\n################\n\n# The path to glib.h is added to all compilation commands.  This was\n# grandfathered in from the QEMU Makefiles.\nadd_project_arguments(config_host['GLIB_CFLAGS'].split(),\n                      native: false, language: ['c', 'cpp', 'objc'])\nglib = declare_dependency(compile_args: config_host['GLIB_CFLAGS'].split(),\n                          link_args: config_host['GLIB_LIBS'].split(),\n                          version: config_host['GLIB_VERSION'],\n                          variables: {\n                            'bindir': config_host['GLIB_BINDIR'],\n                          })\n# override glib dep with the configure results (for subprojects)\nmeson.override_dependency('glib-2.0', glib)\n\ngio = not_found\ngdbus_codegen = not_found\nif not get_option('gio').auto() or have_system\n  gio = dependency('gio-2.0', required: get_option('gio'),\n                   method: 'pkg-config', kwargs: static_kwargs)\n  if gio.found() and not cc.links('''\n    #include <gio/gio.h>\n    int main(void)\n    {\n      g_dbus_proxy_new_sync(0, 0, 0, 0, 0, 0, 0, 0);\n      return 0;\n    }''', dependencies: [glib, gio])\n    if get_option('gio').enabled()\n      error('The installed libgio is broken for static linking')\n    endif\n    gio = not_found\n  endif\n  if gio.found()\n    gdbus_codegen = find_program(gio.get_variable('gdbus_codegen'),\n                                 required: get_option('gio'))\n    gio_unix = dependency('gio-unix-2.0', required: get_option('gio'),\n                          method: 'pkg-config', kwargs: static_kwargs)\n    gio = declare_dependency(dependencies: [gio, gio_unix],\n                             version: gio.version())\n  endif\nendif\n\nlttng = not_found\nif 'ust' in get_option('trace_backends')\n  lttng = dependency('lttng-ust', required: true, version: '>= 2.1',\n                     method: 'pkg-config', kwargs: static_kwargs)\nendif\npixman = not_found\nif have_system or have_tools\n  pixman = dependency('pixman-1', required: have_system, version:'>=0.21.8',\n                      method: 'pkg-config', kwargs: static_kwargs)\nendif\nzlib = dependency('zlib', required: true, kwargs: static_kwargs)\n\nlibaio = not_found\nif not get_option('linux_aio').auto() or have_block\n  libaio = cc.find_library('aio', has_headers: ['libaio.h'],\n                           required: get_option('linux_aio'),\n                           kwargs: static_kwargs)\nendif\n\nlinux_io_uring_test = '''\n  #include <liburing.h>\n  #include <linux/errqueue.h>\n\n  int main(void) { return 0; }'''\n\nlinux_io_uring = not_found\nif not get_option('linux_io_uring').auto() or have_block\n  linux_io_uring = dependency('liburing', version: '>=0.3',\n                              required: get_option('linux_io_uring'),\n                              method: 'pkg-config', kwargs: static_kwargs)\n  if not cc.links(linux_io_uring_test)\n    linux_io_uring = not_found\n  endif\nendif\n\nlibnfs = not_found\nif not get_option('libnfs').auto() or have_block\n  libnfs = dependency('libnfs', version: '>=1.9.3',\n                      required: get_option('libnfs'),\n                      method: 'pkg-config', kwargs: static_kwargs)\nendif\n\nlibattr_test = '''\n  #include <stddef.h>\n  #include <sys/types.h>\n  #ifdef CONFIG_LIBATTR\n  #include <attr/xattr.h>\n  #else\n  #include <sys/xattr.h>\n  #endif\n  int main(void) { getxattr(NULL, NULL, NULL, 0); setxattr(NULL, NULL, NULL, 0, 0); return 0; }'''\n\nlibattr = not_found\nhave_old_libattr = false\nif get_option('attr').allowed()\n  if cc.links(libattr_test)\n    libattr = declare_dependency()\n  else\n    libattr = cc.find_library('attr', has_headers: ['attr/xattr.h'],\n                              required: get_option('attr'),\n                              kwargs: static_kwargs)\n    if libattr.found() and not \\\n      cc.links(libattr_test, dependencies: libattr, args: '-DCONFIG_LIBATTR')\n      libattr = not_found\n      if get_option('attr').enabled()\n        error('could not link libattr')\n      else\n        warning('could not link libattr, disabling')\n      endif\n    else\n      have_old_libattr = libattr.found()\n    endif\n  endif\nendif\n\ncocoa = dependency('appleframeworks', modules: ['Cocoa', 'CoreVideo'],\n                   required: get_option('cocoa'))\nif cocoa.found() and get_option('sdl').enabled()\n  error('Cocoa and SDL cannot be enabled at the same time')\nendif\nif cocoa.found() and get_option('gtk').enabled()\n  error('Cocoa and GTK+ cannot be enabled at the same time')\nendif\n\nvmnet = dependency('appleframeworks', modules: 'vmnet', required: get_option('vmnet'))\nif vmnet.found() and not cc.has_header_symbol('vmnet/vmnet.h',\n                                              'VMNET_BRIDGED_MODE',\n                                              dependencies: vmnet)\n  vmnet = not_found\n  if get_option('vmnet').enabled()\n    error('vmnet.framework API is outdated')\n  else\n    warning('vmnet.framework API is outdated, disabling')\n  endif\nendif\n\nseccomp = not_found\nif not get_option('seccomp').auto() or have_system or have_tools\n  seccomp = dependency('libseccomp', version: '>=2.3.0',\n                       required: get_option('seccomp'),\n                       method: 'pkg-config', kwargs: static_kwargs)\nendif\n\nlibcap_ng = not_found\nif not get_option('cap_ng').auto() or have_system or have_tools\n  libcap_ng = cc.find_library('cap-ng', has_headers: ['cap-ng.h'],\n                              required: get_option('cap_ng'),\n                              kwargs: static_kwargs)\nendif\nif libcap_ng.found() and not cc.links('''\n   #include <cap-ng.h>\n   int main(void)\n   {\n     capng_capability_to_name(CAPNG_EFFECTIVE);\n     return 0;\n   }''', dependencies: libcap_ng)\n  libcap_ng = not_found\n  if get_option('cap_ng').enabled()\n    error('could not link libcap-ng')\n  else\n    warning('could not link libcap-ng, disabling')\n  endif\nendif\n\nif get_option('xkbcommon').auto() and not have_system and not have_tools\n  xkbcommon = not_found\nelse\n  xkbcommon = dependency('xkbcommon', required: get_option('xkbcommon'),\n                         method: 'pkg-config', kwargs: static_kwargs)\nendif\n\nvde = not_found\nif not get_option('vde').auto() or have_system or have_tools\n  vde = cc.find_library('vdeplug', has_headers: ['libvdeplug.h'],\n                           required: get_option('vde'),\n                           kwargs: static_kwargs)\nendif\nif vde.found() and not cc.links('''\n   #include <libvdeplug.h>\n   int main(void)\n   {\n     struct vde_open_args a = {0, 0, 0};\n     char s[] = \"\";\n     vde_open(s, s, &a);\n     return 0;\n   }''', dependencies: vde)\n  vde = not_found\n  if get_option('cap_ng').enabled()\n    error('could not link libvdeplug')\n  else\n    warning('could not link libvdeplug, disabling')\n  endif\nendif\n\npulse = not_found\nif not get_option('pa').auto() or (targetos == 'linux' and have_system)\n  pulse = dependency('libpulse', required: get_option('pa'),\n                     method: 'pkg-config', kwargs: static_kwargs)\nendif\nalsa = not_found\nif not get_option('alsa').auto() or (targetos == 'linux' and have_system)\n  alsa = dependency('alsa', required: get_option('alsa'),\n                    method: 'pkg-config', kwargs: static_kwargs)\nendif\njack = not_found\nif not get_option('jack').auto() or have_system\n  jack = dependency('jack', required: get_option('jack'),\n                    method: 'pkg-config', kwargs: static_kwargs)\nendif\n\nspice_protocol = not_found\nif not get_option('spice_protocol').auto() or have_system\n  spice_protocol = dependency('spice-protocol', version: '>=0.12.3',\n                              required: get_option('spice_protocol'),\n                              method: 'pkg-config', kwargs: static_kwargs)\nendif\nspice = not_found\nif not get_option('spice').auto() or have_system\n  spice = dependency('spice-server', version: '>=0.12.5',\n                     required: get_option('spice'),\n                     method: 'pkg-config', kwargs: static_kwargs)\nendif\nspice_headers = spice.partial_dependency(compile_args: true, includes: true)\n\nrt = cc.find_library('rt', required: false)\n\nlibiscsi = not_found\nif not get_option('libiscsi').auto() or have_block\n  libiscsi = dependency('libiscsi', version: '>=1.9.0',\n                         required: get_option('libiscsi'),\n                         method: 'pkg-config', kwargs: static_kwargs)\nendif\nzstd = not_found\nif not get_option('zstd').auto() or have_block\n  zstd = dependency('libzstd', version: '>=1.4.0',\n                    required: get_option('zstd'),\n                    method: 'pkg-config', kwargs: static_kwargs)\nendif\nvirgl = not_found\n\nhave_vhost_user_gpu = have_tools and targetos == 'linux' and pixman.found()\nif not get_option('virglrenderer').auto() or have_system or have_vhost_user_gpu\n  virgl = dependency('virglrenderer',\n                     method: 'pkg-config',\n                     required: get_option('virglrenderer'),\n                     kwargs: static_kwargs)\nendif\ncurl = not_found\nif not get_option('curl').auto() or have_block\n  curl = dependency('libcurl', version: '>=7.29.0',\n                    method: 'pkg-config',\n                    required: get_option('curl'),\n                    kwargs: static_kwargs)\nendif\nlibudev = not_found\nif targetos == 'linux' and (have_system or have_tools)\n  libudev = dependency('libudev',\n                       method: 'pkg-config',\n                       required: get_option('libudev'),\n                       kwargs: static_kwargs)\nendif\n\nmpathlibs = [libudev]\nmpathpersist = not_found\nmpathpersist_new_api = false\nif targetos == 'linux' and have_tools and get_option('mpath').allowed()\n  mpath_test_source_new = '''\n    #include <libudev.h>\n    #include <mpath_persist.h>\n    unsigned mpath_mx_alloc_len = 1024;\n    int logsink;\n    static struct config *multipath_conf;\n    extern struct udev *udev;\n    extern struct config *get_multipath_config(void);\n    extern void put_multipath_config(struct config *conf);\n    struct udev *udev;\n    struct config *get_multipath_config(void) { return multipath_conf; }\n    void put_multipath_config(struct config *conf) { }\n    int main(void) {\n        udev = udev_new();\n        multipath_conf = mpath_lib_init();\n        return 0;\n    }'''\n  mpath_test_source_old = '''\n      #include <libudev.h>\n      #include <mpath_persist.h>\n      unsigned mpath_mx_alloc_len = 1024;\n      int logsink;\n      int main(void) {\n          struct udev *udev = udev_new();\n          mpath_lib_init(udev);\n          return 0;\n      }'''\n  libmpathpersist = cc.find_library('mpathpersist',\n                                    required: get_option('mpath'),\n                                    kwargs: static_kwargs)\n  if libmpathpersist.found()\n    mpathlibs += libmpathpersist\n    if enable_static\n      mpathlibs += cc.find_library('devmapper',\n                                     required: get_option('mpath'),\n                                     kwargs: static_kwargs)\n    endif\n    mpathlibs += cc.find_library('multipath',\n                                 required: get_option('mpath'),\n                                 kwargs: static_kwargs)\n    foreach lib: mpathlibs\n      if not lib.found()\n        mpathlibs = []\n        break\n      endif\n    endforeach\n    if mpathlibs.length() == 0\n      msg = 'Dependencies missing for libmpathpersist'\n    elif cc.links(mpath_test_source_new, dependencies: mpathlibs)\n      mpathpersist = declare_dependency(dependencies: mpathlibs)\n      mpathpersist_new_api = true\n    elif cc.links(mpath_test_source_old, dependencies: mpathlibs)\n      mpathpersist = declare_dependency(dependencies: mpathlibs)\n    else\n      msg = 'Cannot detect libmpathpersist API'\n    endif\n    if not mpathpersist.found()\n      if get_option('mpath').enabled()\n        error(msg)\n      else\n        warning(msg + ', disabling')\n      endif\n    endif\n  endif\nendif\n\niconv = not_found\ncurses = not_found\nif have_system and get_option('curses').allowed()\n  curses_test = '''\n    #if defined(__APPLE__) || defined(__OpenBSD__)\n    #define _XOPEN_SOURCE_EXTENDED 1\n    #endif\n    #include <locale.h>\n    #include <curses.h>\n    #include <wchar.h>\n    int main(void) {\n      wchar_t wch = L'w';\n      setlocale(LC_ALL, \"\");\n      resize_term(0, 0);\n      addwstr(L\"wide chars\\n\");\n      addnwstr(&wch, 1);\n      add_wch(WACS_DEGREE);\n      return 0;\n    }'''\n\n  curses_dep_list = targetos == 'windows' ? ['ncurses', 'ncursesw'] : ['ncursesw']\n  foreach curses_dep : curses_dep_list\n    if not curses.found()\n      curses = dependency(curses_dep,\n                          required: false,\n                          method: 'pkg-config',\n                          kwargs: static_kwargs)\n    endif\n  endforeach\n  msg = get_option('curses').enabled() ? 'curses library not found' : ''\n  curses_compile_args = ['-DNCURSES_WIDECHAR=1']\n  if curses.found()\n    if cc.links(curses_test, args: curses_compile_args, dependencies: [curses])\n      curses = declare_dependency(compile_args: curses_compile_args, dependencies: [curses])\n    else\n      msg = 'curses package not usable'\n      curses = not_found\n    endif\n  endif\n  if not curses.found()\n    has_curses_h = cc.has_header('curses.h', args: curses_compile_args)\n    if targetos != 'windows' and not has_curses_h\n      message('Trying with /usr/include/ncursesw')\n      curses_compile_args += ['-I/usr/include/ncursesw']\n      has_curses_h = cc.has_header('curses.h', args: curses_compile_args)\n    endif\n    if has_curses_h\n      curses_libname_list = (targetos == 'windows' ? ['pdcurses'] : ['ncursesw', 'cursesw'])\n      foreach curses_libname : curses_libname_list\n        libcurses = cc.find_library(curses_libname,\n                                    required: false,\n                                    kwargs: static_kwargs)\n        if libcurses.found()\n          if cc.links(curses_test, args: curses_compile_args, dependencies: libcurses)\n            curses = declare_dependency(compile_args: curses_compile_args,\n                                        dependencies: [libcurses])\n            break\n          else\n            msg = 'curses library not usable'\n          endif\n        endif\n      endforeach\n    endif\n  endif\n  if get_option('iconv').allowed()\n    foreach link_args : [ ['-liconv'], [] ]\n      # Programs will be linked with glib and this will bring in libiconv on FreeBSD.\n      # We need to use libiconv if available because mixing libiconv's headers with\n      # the system libc does not work.\n      # However, without adding glib to the dependencies -L/usr/local/lib will not be\n      # included in the command line and libiconv will not be found.\n      if cc.links('''\n        #include <iconv.h>\n        int main(void) {\n          iconv_t conv = iconv_open(\"WCHAR_T\", \"UCS-2\");\n          return conv != (iconv_t) -1;\n        }''', args: config_host['GLIB_CFLAGS'].split() + config_host['GLIB_LIBS'].split() + link_args)\n        iconv = declare_dependency(link_args: link_args, dependencies: glib)\n        break\n      endif\n    endforeach\n  endif\n  if curses.found() and not iconv.found()\n    if get_option('iconv').enabled()\n      error('iconv not available')\n    endif\n    msg = 'iconv required for curses UI but not available'\n    curses = not_found\n  endif\n  if not curses.found() and msg != ''\n    if get_option('curses').enabled()\n      error(msg)\n    else\n      warning(msg + ', disabling')\n    endif\n  endif\nendif\n\nbrlapi = not_found\nif not get_option('brlapi').auto() or have_system\n  brlapi = cc.find_library('brlapi', has_headers: ['brlapi.h'],\n                         required: get_option('brlapi'),\n                         kwargs: static_kwargs)\n  if brlapi.found() and not cc.links('''\n     #include <brlapi.h>\n     #include <stddef.h>\n     int main(void) { return brlapi__openConnection (NULL, NULL, NULL); }''', dependencies: brlapi)\n    brlapi = not_found\n    if get_option('brlapi').enabled()\n      error('could not link brlapi')\n    else\n      warning('could not link brlapi, disabling')\n    endif\n  endif\nendif\n\nsdl = not_found\nif not get_option('sdl').auto() or (have_system and not cocoa.found())\n  sdl = dependency('sdl2', required: get_option('sdl'), kwargs: static_kwargs)\n  sdl_image = not_found\nendif\nif sdl.found()\n  # work around 2.0.8 bug\n  sdl = declare_dependency(compile_args: '-Wno-undef',\n                           dependencies: sdl)\n  sdl_image = dependency('SDL2_image', required: get_option('sdl_image'),\n                         method: 'pkg-config', kwargs: static_kwargs)\nelse\n  if get_option('sdl_image').enabled()\n    error('sdl-image required, but SDL was @0@'.format(\n          get_option('sdl').disabled() ? 'disabled' : 'not found'))\n  endif\n  sdl_image = not_found\nendif\n\nrbd = not_found\nif not get_option('rbd').auto() or have_block\n  librados = cc.find_library('rados', required: get_option('rbd'),\n                             kwargs: static_kwargs)\n  librbd = cc.find_library('rbd', has_headers: ['rbd/librbd.h'],\n                           required: get_option('rbd'),\n                           kwargs: static_kwargs)\n  if librados.found() and librbd.found()\n    if cc.links('''\n      #include <stdio.h>\n      #include <rbd/librbd.h>\n      int main(void) {\n        rados_t cluster;\n        rados_create(&cluster, NULL);\n        #if LIBRBD_VERSION_CODE < LIBRBD_VERSION(1, 12, 0)\n        #error\n        #endif\n        return 0;\n      }''', dependencies: [librbd, librados])\n      rbd = declare_dependency(dependencies: [librbd, librados])\n    elif get_option('rbd').enabled()\n      error('librbd >= 1.12.0 required')\n    else\n      warning('librbd >= 1.12.0 not found, disabling')\n    endif\n  endif\nendif\n\nglusterfs = not_found\nglusterfs_ftruncate_has_stat = false\nglusterfs_iocb_has_stat = false\nif not get_option('glusterfs').auto() or have_block\n  glusterfs = dependency('glusterfs-api', version: '>=3',\n                         required: get_option('glusterfs'),\n                         method: 'pkg-config', kwargs: static_kwargs)\n  if glusterfs.found()\n    glusterfs_ftruncate_has_stat = cc.links('''\n      #include <glusterfs/api/glfs.h>\n\n      int\n      main(void)\n      {\n          /* new glfs_ftruncate() passes two additional args */\n          return glfs_ftruncate(NULL, 0, NULL, NULL);\n      }\n    ''', dependencies: glusterfs)\n    glusterfs_iocb_has_stat = cc.links('''\n      #include <glusterfs/api/glfs.h>\n\n      /* new glfs_io_cbk() passes two additional glfs_stat structs */\n      static void\n      glusterfs_iocb(glfs_fd_t *fd, ssize_t ret, struct glfs_stat *prestat, struct glfs_stat *poststat, void *data)\n      {}\n\n      int\n      main(void)\n      {\n          glfs_io_cbk iocb = &glusterfs_iocb;\n          iocb(NULL, 0 , NULL, NULL, NULL);\n          return 0;\n      }\n    ''', dependencies: glusterfs)\n  endif\nendif\n\nlibssh = not_found\nif not get_option('libssh').auto() or have_block\n  libssh = dependency('libssh', version: '>=0.8.7',\n                    method: 'pkg-config',\n                    required: get_option('libssh'),\n                    kwargs: static_kwargs)\nendif\n\nlibbzip2 = not_found\nif not get_option('bzip2').auto() or have_block\n  libbzip2 = cc.find_library('bz2', has_headers: ['bzlib.h'],\n                             required: get_option('bzip2'),\n                             kwargs: static_kwargs)\n  if libbzip2.found() and not cc.links('''\n     #include <bzlib.h>\n     int main(void) { BZ2_bzlibVersion(); return 0; }''', dependencies: libbzip2)\n    libbzip2 = not_found\n    if get_option('bzip2').enabled()\n      error('could not link libbzip2')\n    else\n      warning('could not link libbzip2, disabling')\n    endif\n  endif\nendif\n\nliblzfse = not_found\nif not get_option('lzfse').auto() or have_block\n  liblzfse = cc.find_library('lzfse', has_headers: ['lzfse.h'],\n                             required: get_option('lzfse'),\n                             kwargs: static_kwargs)\nendif\nif liblzfse.found() and not cc.links('''\n   #include <lzfse.h>\n   int main(void) { lzfse_decode_scratch_size(); return 0; }''', dependencies: liblzfse)\n  liblzfse = not_found\n  if get_option('lzfse').enabled()\n    error('could not link liblzfse')\n  else\n    warning('could not link liblzfse, disabling')\n  endif\nendif\n\noss = not_found\nif get_option('oss').allowed() and have_system\n  if not cc.has_header('sys/soundcard.h')\n    # not found\n  elif targetos == 'netbsd'\n    oss = cc.find_library('ossaudio', required: get_option('oss'),\n                          kwargs: static_kwargs)\n  else\n    oss = declare_dependency()\n  endif\n\n  if not oss.found()\n    if get_option('oss').enabled()\n      error('OSS not found')\n    endif\n  endif\nendif\ndsound = not_found\nif not get_option('dsound').auto() or (targetos == 'windows' and have_system)\n  if cc.has_header('dsound.h')\n    dsound = declare_dependency(link_args: ['-lole32', '-ldxguid'])\n  endif\n\n  if not dsound.found()\n    if get_option('dsound').enabled()\n      error('DirectSound not found')\n    endif\n  endif\nendif\n\ncoreaudio = not_found\nif not get_option('coreaudio').auto() or (targetos == 'darwin' and have_system)\n  coreaudio = dependency('appleframeworks', modules: 'CoreAudio',\n                         required: get_option('coreaudio'))\nendif\n\nopengl = not_found\nif not get_option('opengl').auto() or have_system or have_vhost_user_gpu\n  epoxy = dependency('epoxy', method: 'pkg-config',\n                      required: get_option('opengl'), kwargs: static_kwargs)\n  if cc.has_header('epoxy/egl.h', dependencies: epoxy)\n    opengl = epoxy\n  elif get_option('opengl').enabled()\n    error('epoxy/egl.h not found')\n  endif\nendif\ngbm = not_found\nif (have_system or have_tools) and (virgl.found() or opengl.found())\n  gbm = dependency('gbm', method: 'pkg-config', required: false,\n                   kwargs: static_kwargs)\nendif\nhave_vhost_user_gpu = have_vhost_user_gpu and virgl.found() and opengl.found() and gbm.found()\n\ngnutls = not_found\ngnutls_crypto = not_found\nif get_option('gnutls').enabled() or (get_option('gnutls').auto() and have_system)\n  # For general TLS support our min gnutls matches\n  # that implied by our platform support matrix\n  #\n  # For the crypto backends, we look for a newer\n  # gnutls:\n  #\n  #   Version 3.6.8  is needed to get XTS\n  #   Version 3.6.13 is needed to get PBKDF\n  #   Version 3.6.14 is needed to get HW accelerated XTS\n  #\n  # If newer enough gnutls isn't available, we can\n  # still use a different crypto backend to satisfy\n  # the platform support requirements\n  gnutls_crypto = dependency('gnutls', version: '>=3.6.14',\n                             method: 'pkg-config',\n                             required: false,\n                             kwargs: static_kwargs)\n  if gnutls_crypto.found()\n    gnutls = gnutls_crypto\n  else\n    # Our min version if all we need is TLS\n    gnutls = dependency('gnutls', version: '>=3.5.18',\n                        method: 'pkg-config',\n                        required: get_option('gnutls'),\n                        kwargs: static_kwargs)\n  endif\nendif\n\n# We prefer use of gnutls for crypto, unless the options\n# explicitly asked for nettle or gcrypt.\n#\n# If gnutls isn't available for crypto, then we'll prefer\n# gcrypt over nettle for performance reasons.\ngcrypt = not_found\nnettle = not_found\nhogweed = not_found\nxts = 'none'\n\nif get_option('nettle').enabled() and get_option('gcrypt').enabled()\n  error('Only one of gcrypt & nettle can be enabled')\nendif\n\n# Explicit nettle/gcrypt request, so ignore gnutls for crypto\nif get_option('nettle').enabled() or get_option('gcrypt').enabled()\n  gnutls_crypto = not_found\nendif\n\nif not gnutls_crypto.found()\n  if (not get_option('gcrypt').auto() or have_system) and not get_option('nettle').enabled()\n    gcrypt = dependency('libgcrypt', version: '>=1.8',\n                        method: 'config-tool',\n                        required: get_option('gcrypt'),\n                        kwargs: static_kwargs)\n    # Debian has removed -lgpg-error from libgcrypt-config\n    # as it \"spreads unnecessary dependencies\" which in\n    # turn breaks static builds...\n    if gcrypt.found() and enable_static\n      gcrypt = declare_dependency(dependencies: [\n        gcrypt,\n        cc.find_library('gpg-error', required: true, kwargs: static_kwargs)])\n    endif\n  endif\n  if (not get_option('nettle').auto() or have_system) and not gcrypt.found()\n    nettle = dependency('nettle', version: '>=3.4',\n                        method: 'pkg-config',\n                        required: get_option('nettle'),\n                        kwargs: static_kwargs)\n    if nettle.found() and not cc.has_header('nettle/xts.h', dependencies: nettle)\n      xts = 'private'\n    endif\n  endif\nendif\n\ngmp = dependency('gmp', required: false, method: 'pkg-config', kwargs: static_kwargs)\nif nettle.found() and gmp.found()\n  hogweed = dependency('hogweed', version: '>=3.4',\n                       method: 'pkg-config',\n                       required: get_option('nettle'),\n                       kwargs: static_kwargs)\nendif\n\n\ngtk = not_found\ngtkx11 = not_found\nvte = not_found\nif not get_option('gtk').auto() or (have_system and not cocoa.found())\n  gtk = dependency('gtk+-3.0', version: '>=3.22.0',\n                   method: 'pkg-config',\n                   required: get_option('gtk'),\n                   kwargs: static_kwargs)\n  if gtk.found()\n    gtkx11 = dependency('gtk+-x11-3.0', version: '>=3.22.0',\n                        method: 'pkg-config',\n                        required: false,\n                        kwargs: static_kwargs)\n    gtk = declare_dependency(dependencies: [gtk, gtkx11])\n\n    if not get_option('vte').auto() or have_system\n      vte = dependency('vte-2.91',\n                       method: 'pkg-config',\n                       required: get_option('vte'),\n                       kwargs: static_kwargs)\n    endif\n  endif\nendif\n\nx11 = not_found\nif gtkx11.found()\n  x11 = dependency('x11', method: 'pkg-config', required: gtkx11.found(),\n                   kwargs: static_kwargs)\nendif\npng = not_found\nif get_option('png').allowed() and have_system\n   png = dependency('libpng', version: '>=1.6.34', required: get_option('png'),\n                    method: 'pkg-config', kwargs: static_kwargs)\nendif\nvnc = not_found\njpeg = not_found\nsasl = not_found\nif get_option('vnc').allowed() and have_system\n  vnc = declare_dependency() # dummy dependency\n  jpeg = dependency('libjpeg', required: get_option('vnc_jpeg'),\n                    method: 'pkg-config', kwargs: static_kwargs)\n  sasl = cc.find_library('sasl2', has_headers: ['sasl/sasl.h'],\n                         required: get_option('vnc_sasl'),\n                         kwargs: static_kwargs)\n  if sasl.found()\n    sasl = declare_dependency(dependencies: sasl,\n                              compile_args: '-DSTRUCT_IOVEC_DEFINED')\n  endif\nendif\n\npam = not_found\nif not get_option('auth_pam').auto() or have_system\n  pam = cc.find_library('pam', has_headers: ['security/pam_appl.h'],\n                        required: get_option('auth_pam'),\n                        kwargs: static_kwargs)\nendif\nif pam.found() and not cc.links('''\n   #include <stddef.h>\n   #include <security/pam_appl.h>\n   int main(void) {\n     const char *service_name = \"qemu\";\n     const char *user = \"frank\";\n     const struct pam_conv pam_conv = { 0 };\n     pam_handle_t *pamh = NULL;\n     pam_start(service_name, user, &pam_conv, &pamh);\n     return 0;\n   }''', dependencies: pam)\n  pam = not_found\n  if get_option('auth_pam').enabled()\n    error('could not link libpam')\n  else\n    warning('could not link libpam, disabling')\n  endif\nendif\n\nsnappy = not_found\nif not get_option('snappy').auto() or have_system\n  snappy = cc.find_library('snappy', has_headers: ['snappy-c.h'],\n                           required: get_option('snappy'),\n                           kwargs: static_kwargs)\nendif\nif snappy.found() and not linker.links('''\n   #include <snappy-c.h>\n   int main(void) { snappy_max_compressed_length(4096); return 0; }''', dependencies: snappy)\n  snappy = not_found\n  if get_option('snappy').enabled()\n    error('could not link libsnappy')\n  else\n    warning('could not link libsnappy, disabling')\n  endif\nendif\n\nlzo = not_found\nif not get_option('lzo').auto() or have_system\n  lzo = cc.find_library('lzo2', has_headers: ['lzo/lzo1x.h'],\n                        required: get_option('lzo'),\n                        kwargs: static_kwargs)\nendif\nif lzo.found() and not cc.links('''\n   #include <lzo/lzo1x.h>\n   int main(void) { lzo_version(); return 0; }''', dependencies: lzo)\n  lzo = not_found\n  if get_option('lzo').enabled()\n    error('could not link liblzo2')\n  else\n    warning('could not link liblzo2, disabling')\n  endif\nendif\n\nnuma = not_found\nif not get_option('numa').auto() or have_system or have_tools\n  numa = cc.find_library('numa', has_headers: ['numa.h'],\n                              required: get_option('numa'),\n                              kwargs: static_kwargs)\nendif\nif numa.found() and not cc.links('''\n   #include <numa.h>\n   int main(void) { return numa_available(); }\n   ''', dependencies: numa)\n  numa = not_found\n  if get_option('numa').enabled()\n    error('could not link numa')\n  else\n    warning('could not link numa, disabling')\n  endif\nendif\n\nrdma = not_found\nif not get_option('rdma').auto() or have_system\n  libumad = cc.find_library('ibumad', required: get_option('rdma'))\n  rdma_libs = [cc.find_library('rdmacm', has_headers: ['rdma/rdma_cma.h'],\n                               required: get_option('rdma'),\n                               kwargs: static_kwargs),\n               cc.find_library('ibverbs', required: get_option('rdma'),\n                               kwargs: static_kwargs),\n               libumad]\n  rdma = declare_dependency(dependencies: rdma_libs)\n  foreach lib: rdma_libs\n    if not lib.found()\n      rdma = not_found\n    endif\n  endforeach\nendif\n\nxen = not_found\nif get_option('xen').enabled() or (get_option('xen').auto() and have_system)\n  xencontrol = dependency('xencontrol', required: false,\n                          method: 'pkg-config', kwargs: static_kwargs)\n  if xencontrol.found()\n    xen_pc = declare_dependency(version: xencontrol.version(),\n      dependencies: [\n        xencontrol,\n        # disabler: true makes xen_pc.found() return false if any is not found\n        dependency('xenstore', required: false,\n                   method: 'pkg-config', kwargs: static_kwargs,\n                   disabler: true),\n        dependency('xenforeignmemory', required: false,\n                   method: 'pkg-config', kwargs: static_kwargs,\n                   disabler: true),\n        dependency('xengnttab', required: false,\n                   method: 'pkg-config', kwargs: static_kwargs,\n                   disabler: true),\n        dependency('xenevtchn', required: false,\n                   method: 'pkg-config', kwargs: static_kwargs,\n                   disabler: true),\n        dependency('xendevicemodel', required: false,\n                   method: 'pkg-config', kwargs: static_kwargs,\n                   disabler: true),\n        # optional, no \"disabler: true\"\n        dependency('xentoolcore', required: false,\n                   method: 'pkg-config', kwargs: static_kwargs)])\n    if xen_pc.found()\n      xen = xen_pc\n    endif\n  endif\n  if not xen.found()\n    xen_tests = [ '4.11.0', '4.10.0', '4.9.0', '4.8.0', '4.7.1', '4.6.0', '4.5.0', '4.2.0' ]\n    xen_libs = {\n      '4.11.0': [ 'xenstore', 'xenctrl', 'xendevicemodel', 'xenforeignmemory', 'xengnttab', 'xenevtchn', 'xentoolcore' ],\n      '4.10.0': [ 'xenstore', 'xenctrl', 'xendevicemodel', 'xenforeignmemory', 'xengnttab', 'xenevtchn', 'xentoolcore' ],\n      '4.9.0': [ 'xenstore', 'xenctrl', 'xendevicemodel', 'xenforeignmemory', 'xengnttab', 'xenevtchn' ],\n      '4.8.0': [ 'xenstore', 'xenctrl', 'xenforeignmemory', 'xengnttab', 'xenevtchn' ],\n      '4.7.1': [ 'xenstore', 'xenctrl', 'xenforeignmemory', 'xengnttab', 'xenevtchn' ],\n      '4.6.0': [ 'xenstore', 'xenctrl' ],\n      '4.5.0': [ 'xenstore', 'xenctrl' ],\n      '4.2.0': [ 'xenstore', 'xenctrl' ],\n    }\n    xen_deps = {}\n    foreach ver: xen_tests\n      # cache the various library tests to avoid polluting the logs\n      xen_test_deps = []\n      foreach l: xen_libs[ver]\n        if l not in xen_deps\n          xen_deps += { l: cc.find_library(l, required: false) }\n        endif\n        xen_test_deps += xen_deps[l]\n      endforeach\n\n      # Use -D to pick just one of the test programs in scripts/xen-detect.c\n      xen_version = ver.split('.')\n      xen_ctrl_version = xen_version[0] + \\\n        ('0' + xen_version[1]).substring(-2) + \\\n        ('0' + xen_version[2]).substring(-2)\n      if cc.links(files('scripts/xen-detect.c'),\n                  args: '-DCONFIG_XEN_CTRL_INTERFACE_VERSION=' + xen_ctrl_version,\n                  dependencies: xen_test_deps)\n        xen = declare_dependency(version: ver, dependencies: xen_test_deps)\n        break\n      endif\n    endforeach\n  endif\n  if xen.found()\n    accelerators += 'CONFIG_XEN'\n  elif get_option('xen').enabled()\n    error('could not compile and link Xen test program')\n  endif\nendif\nhave_xen_pci_passthrough = get_option('xen_pci_passthrough') \\\n  .require(xen.found(),\n           error_message: 'Xen PCI passthrough requested but Xen not enabled') \\\n  .require(targetos == 'linux',\n           error_message: 'Xen PCI passthrough not available on this platform') \\\n  .allowed()\n\n\ncacard = not_found\nif not get_option('smartcard').auto() or have_system\n  cacard = dependency('libcacard', required: get_option('smartcard'),\n                      version: '>=2.5.1', method: 'pkg-config',\n                      kwargs: static_kwargs)\nendif\nu2f = not_found\nif have_system\n  u2f = dependency('u2f-emu', required: get_option('u2f'),\n                   method: 'pkg-config',\n                   kwargs: static_kwargs)\nendif\ncanokey = not_found\nif have_system\n  canokey = dependency('canokey-qemu', required: get_option('canokey'),\n                   method: 'pkg-config',\n                   kwargs: static_kwargs)\nendif\nusbredir = not_found\nif not get_option('usb_redir').auto() or have_system\n  usbredir = dependency('libusbredirparser-0.5', required: get_option('usb_redir'),\n                        version: '>=0.6', method: 'pkg-config',\n                        kwargs: static_kwargs)\nendif\nlibusb = not_found\nif not get_option('libusb').auto() or have_system\n  libusb = dependency('libusb-1.0', required: get_option('libusb'),\n                      version: '>=1.0.13', method: 'pkg-config',\n                      kwargs: static_kwargs)\nendif\n\nlibpmem = not_found\nif not get_option('libpmem').auto() or have_system\n  libpmem = dependency('libpmem', required: get_option('libpmem'),\n                       method: 'pkg-config', kwargs: static_kwargs)\nendif\nlibdaxctl = not_found\nif not get_option('libdaxctl').auto() or have_system\n  libdaxctl = dependency('libdaxctl', required: get_option('libdaxctl'),\n                         version: '>=57', method: 'pkg-config',\n                         kwargs: static_kwargs)\nendif\ntasn1 = not_found\nif gnutls.found()\n  tasn1 = dependency('libtasn1',\n                     method: 'pkg-config',\n                     kwargs: static_kwargs)\nendif\nkeyutils = dependency('libkeyutils', required: false,\n                      method: 'pkg-config', kwargs: static_kwargs)\n\nhas_gettid = cc.has_function('gettid')\n\n# libselinux\nselinux = dependency('libselinux',\n                     required: get_option('selinux'),\n                     method: 'pkg-config', kwargs: static_kwargs)\n\n# Malloc tests\n\nmalloc = []\nif get_option('malloc') == 'system'\n  has_malloc_trim = \\\n    get_option('malloc_trim').allowed() and \\\n    cc.links('''#include <malloc.h>\n                int main(void) { malloc_trim(0); return 0; }''')\nelse\n  has_malloc_trim = false\n  malloc = cc.find_library(get_option('malloc'), required: true)\nendif\nif not has_malloc_trim and get_option('malloc_trim').enabled()\n  if get_option('malloc') == 'system'\n    error('malloc_trim not available on this platform.')\n  else\n    error('malloc_trim not available with non-libc memory allocator')\n  endif\nendif\n\n# Check whether the glibc provides statx()\n\ngnu_source_prefix = '''\n  #ifndef _GNU_SOURCE\n  #define _GNU_SOURCE\n  #endif\n'''\nstatx_test = gnu_source_prefix + '''\n  #include <sys/stat.h>\n  int main(void) {\n    struct statx statxbuf;\n    statx(0, \"\", 0, STATX_BASIC_STATS, &statxbuf);\n    return 0;\n  }'''\n\nhas_statx = cc.links(statx_test)\n\n# Check whether statx() provides mount ID information\n\nstatx_mnt_id_test = gnu_source_prefix + '''\n  #include <sys/stat.h>\n  int main(void) {\n    struct statx statxbuf;\n    statx(0, \"\", 0, STATX_BASIC_STATS | STATX_MNT_ID, &statxbuf);\n    return statxbuf.stx_mnt_id;\n  }'''\n\nhas_statx_mnt_id = cc.links(statx_mnt_id_test)\n\nhave_vhost_user_blk_server = get_option('vhost_user_blk_server') \\\n  .require(targetos == 'linux',\n           error_message: 'vhost_user_blk_server requires linux') \\\n  .require(have_vhost_user,\n           error_message: 'vhost_user_blk_server requires vhost-user support') \\\n  .disable_auto_if(not have_tools and not have_system) \\\n  .allowed()\n\nif get_option('fuse').disabled() and get_option('fuse_lseek').enabled()\n  error('Cannot enable fuse-lseek while fuse is disabled')\nendif\n\nfuse = dependency('fuse3', required: get_option('fuse'),\n                  version: '>=3.1', method: 'pkg-config',\n                  kwargs: static_kwargs)\n\nfuse_lseek = not_found\nif get_option('fuse_lseek').allowed()\n  if fuse.version().version_compare('>=3.8')\n    # Dummy dependency\n    fuse_lseek = declare_dependency()\n  elif get_option('fuse_lseek').enabled()\n    if fuse.found()\n      error('fuse-lseek requires libfuse >=3.8, found ' + fuse.version())\n    else\n      error('fuse-lseek requires libfuse, which was not found')\n    endif\n  endif\nendif\n\nhave_libvduse = (targetos == 'linux')\nif get_option('libvduse').enabled()\n    if targetos != 'linux'\n        error('libvduse requires linux')\n    endif\nelif get_option('libvduse').disabled()\n    have_libvduse = false\nendif\n\nhave_vduse_blk_export = (have_libvduse and targetos == 'linux')\nif get_option('vduse_blk_export').enabled()\n    if targetos != 'linux'\n        error('vduse_blk_export requires linux')\n    elif not have_libvduse\n        error('vduse_blk_export requires libvduse support')\n    endif\nelif get_option('vduse_blk_export').disabled()\n    have_vduse_blk_export = false\nendif\n\n# libbpf\nlibbpf = dependency('libbpf', required: get_option('bpf'), method: 'pkg-config')\nif libbpf.found() and not cc.links('''\n   #include <bpf/libbpf.h>\n   int main(void)\n   {\n     bpf_object__destroy_skeleton(NULL);\n     return 0;\n   }''', dependencies: libbpf)\n  libbpf = not_found\n  if get_option('bpf').enabled()\n    error('libbpf skeleton test failed')\n  else\n    warning('libbpf skeleton test failed, disabling')\n  endif\nendif\n\n#################\n# config-host.h #\n#################\n\naudio_drivers_selected = []\nif have_system\n  audio_drivers_available = {\n    'alsa': alsa.found(),\n    'coreaudio': coreaudio.found(),\n    'dsound': dsound.found(),\n    'jack': jack.found(),\n    'oss': oss.found(),\n    'pa': pulse.found(),\n    'sdl': sdl.found(),\n  }\n  foreach k, v: audio_drivers_available\n    config_host_data.set('CONFIG_AUDIO_' + k.to_upper(), v)\n  endforeach\n\n  # Default to native drivers first, OSS second, SDL third\n  audio_drivers_priority = \\\n    [ 'pa', 'coreaudio', 'dsound', 'oss' ] + \\\n    (targetos == 'linux' ? [] : [ 'sdl' ])\n  audio_drivers_default = []\n  foreach k: audio_drivers_priority\n    if audio_drivers_available[k]\n      audio_drivers_default += k\n    endif\n  endforeach\n\n  foreach k: get_option('audio_drv_list')\n    if k == 'default'\n      audio_drivers_selected += audio_drivers_default\n    elif not audio_drivers_available[k]\n      error('Audio driver \"@0@\" not available.'.format(k))\n    else\n      audio_drivers_selected += k\n    endif\n  endforeach\nendif\nconfig_host_data.set('CONFIG_AUDIO_DRIVERS',\n                     '\"' + '\", \"'.join(audio_drivers_selected) + '\", ')\n\nif get_option('cfi')\n  cfi_flags=[]\n  # Check for dependency on LTO\n  if not get_option('b_lto')\n    error('Selected Control-Flow Integrity but LTO is disabled')\n  endif\n  if config_host.has_key('CONFIG_MODULES')\n    error('Selected Control-Flow Integrity is not compatible with modules')\n  endif\n  # Check for cfi flags. CFI requires LTO so we can't use\n  # get_supported_arguments, but need a more complex \"compiles\" which allows\n  # custom arguments\n  if cc.compiles('int main () { return 0; }', name: '-fsanitize=cfi-icall',\n                 args: ['-flto', '-fsanitize=cfi-icall'] )\n    cfi_flags += '-fsanitize=cfi-icall'\n  else\n    error('-fsanitize=cfi-icall is not supported by the compiler')\n  endif\n  if cc.compiles('int main () { return 0; }',\n                 name: '-fsanitize-cfi-icall-generalize-pointers',\n                 args: ['-flto', '-fsanitize=cfi-icall',\n                        '-fsanitize-cfi-icall-generalize-pointers'] )\n    cfi_flags += '-fsanitize-cfi-icall-generalize-pointers'\n  else\n    error('-fsanitize-cfi-icall-generalize-pointers is not supported by the compiler')\n  endif\n  if get_option('cfi_debug')\n    if cc.compiles('int main () { return 0; }',\n                   name: '-fno-sanitize-trap=cfi-icall',\n                   args: ['-flto', '-fsanitize=cfi-icall',\n                          '-fno-sanitize-trap=cfi-icall'] )\n      cfi_flags += '-fno-sanitize-trap=cfi-icall'\n    else\n      error('-fno-sanitize-trap=cfi-icall is not supported by the compiler')\n    endif\n  endif\n  add_global_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])\n  add_global_link_arguments(cfi_flags, native: false, language: ['c', 'cpp', 'objc'])\nendif\n\nhave_host_block_device = (targetos != 'darwin' or\n    cc.has_header('IOKit/storage/IOMedia.h'))\n\n# FIXME enable_modules shouldn't be necessary, but: https://github.com/mesonbuild/meson/issues/8333\ndbus_display = get_option('dbus_display') \\\n  .require(gio.version().version_compare('>=2.64'),\n           error_message: '-display dbus requires glib>=2.64') \\\n  .require(enable_modules,\n           error_message: '-display dbus requires --enable-modules') \\\n  .require(gdbus_codegen.found(),\n           error_message: '-display dbus requires gdbus-codegen') \\\n  .require(opengl.found() and gbm.found(),\n           error_message: '-display dbus requires epoxy/egl and gbm') \\\n  .allowed()\n\nhave_virtfs = get_option('virtfs') \\\n    .require(targetos == 'linux' or targetos == 'darwin',\n             error_message: 'virtio-9p (virtfs) requires Linux or macOS') \\\n    .require(targetos == 'linux' or cc.has_function('pthread_fchdir_np'),\n             error_message: 'virtio-9p (virtfs) on macOS requires the presence of pthread_fchdir_np') \\\n    .require(targetos == 'darwin' or (libattr.found() and libcap_ng.found()),\n             error_message: 'virtio-9p (virtfs) on Linux requires libcap-ng-devel and libattr-devel') \\\n    .disable_auto_if(not have_tools and not have_system) \\\n    .allowed()\n\nhave_virtfs_proxy_helper = targetos != 'darwin' and have_virtfs and have_tools\n\nif get_option('block_drv_ro_whitelist') == ''\n  config_host_data.set('CONFIG_BDRV_RO_WHITELIST', '')\nelse\n  config_host_data.set('CONFIG_BDRV_RO_WHITELIST',\n        '\"' + get_option('block_drv_ro_whitelist').replace(',', '\", \"') + '\", ')\nendif\nif get_option('block_drv_rw_whitelist') == ''\n  config_host_data.set('CONFIG_BDRV_RW_WHITELIST', '')\nelse\n  config_host_data.set('CONFIG_BDRV_RW_WHITELIST',\n        '\"' + get_option('block_drv_rw_whitelist').replace(',', '\", \"') + '\", ')\nendif\n\nforeach k : get_option('trace_backends')\n  config_host_data.set('CONFIG_TRACE_' + k.to_upper(), true)\nendforeach\nconfig_host_data.set_quoted('CONFIG_TRACE_FILE', get_option('trace_file'))\nconfig_host_data.set_quoted('CONFIG_TLS_PRIORITY', get_option('tls_priority'))\nif iasl.found()\n  config_host_data.set_quoted('CONFIG_IASL', iasl.full_path())\nendif\nconfig_host_data.set_quoted('CONFIG_BINDIR', get_option('prefix') / get_option('bindir'))\nconfig_host_data.set_quoted('CONFIG_PREFIX', get_option('prefix'))\nconfig_host_data.set_quoted('CONFIG_QEMU_CONFDIR', get_option('prefix') / qemu_confdir)\nconfig_host_data.set_quoted('CONFIG_QEMU_DATADIR', get_option('prefix') / qemu_datadir)\nconfig_host_data.set_quoted('CONFIG_QEMU_DESKTOPDIR', get_option('prefix') / qemu_desktopdir)\n\nqemu_firmwarepath = ''\nforeach k : get_option('qemu_firmwarepath')\n  qemu_firmwarepath += '\"' + get_option('prefix') / k + '\", '\nendforeach\nconfig_host_data.set('CONFIG_QEMU_FIRMWAREPATH', qemu_firmwarepath)\n\nconfig_host_data.set_quoted('CONFIG_QEMU_HELPERDIR', get_option('prefix') / get_option('libexecdir'))\nconfig_host_data.set_quoted('CONFIG_QEMU_ICONDIR', get_option('prefix') / qemu_icondir)\nconfig_host_data.set_quoted('CONFIG_QEMU_LOCALEDIR', get_option('prefix') / get_option('localedir'))\nconfig_host_data.set_quoted('CONFIG_QEMU_LOCALSTATEDIR', get_option('prefix') / get_option('localstatedir'))\nconfig_host_data.set_quoted('CONFIG_QEMU_MODDIR', get_option('prefix') / qemu_moddir)\nconfig_host_data.set_quoted('CONFIG_SYSCONFDIR', get_option('prefix') / get_option('sysconfdir'))\n\nif config_host.has_key('CONFIG_MODULES')\n  config_host_data.set('CONFIG_STAMP', run_command(\n      meson.current_source_dir() / 'scripts/qemu-stamp.py',\n      meson.project_version(), get_option('pkgversion'), '--',\n      meson.current_source_dir() / 'configure',\n      capture: true, check: true).stdout().strip())\nendif\n\nhave_slirp_smbd = get_option('slirp_smbd') \\\n  .require(targetos != 'windows', error_message: 'Host smbd not supported on this platform.') \\\n  .allowed()\nif have_slirp_smbd\n  smbd_path = get_option('smbd')\n  if smbd_path == ''\n    smbd_path = (targetos == 'solaris' ? '/usr/sfw/sbin/smbd' : '/usr/sbin/smbd')\n  endif\n  config_host_data.set_quoted('CONFIG_SMBD_COMMAND', smbd_path)\nendif\n\nconfig_host_data.set('HOST_' + host_arch.to_upper(), 1)\n\nif get_option('module_upgrades') and not enable_modules\n  error('Cannot enable module-upgrades as modules are not enabled')\nendif\nconfig_host_data.set('CONFIG_MODULE_UPGRADES', get_option('module_upgrades'))\n\nconfig_host_data.set('CONFIG_ATTR', libattr.found())\nconfig_host_data.set('CONFIG_BDRV_WHITELIST_TOOLS', get_option('block_drv_whitelist_in_tools'))\nconfig_host_data.set('CONFIG_BRLAPI', brlapi.found())\nconfig_host_data.set('CONFIG_COCOA', cocoa.found())\nconfig_host_data.set('CONFIG_FUZZ', get_option('fuzzing'))\nconfig_host_data.set('CONFIG_GCOV', get_option('b_coverage'))\nconfig_host_data.set('CONFIG_LIBUDEV', libudev.found())\nconfig_host_data.set('CONFIG_LZO', lzo.found())\nconfig_host_data.set('CONFIG_MPATH', mpathpersist.found())\nconfig_host_data.set('CONFIG_MPATH_NEW_API', mpathpersist_new_api)\nconfig_host_data.set('CONFIG_CURL', curl.found())\nconfig_host_data.set('CONFIG_CURSES', curses.found())\nconfig_host_data.set('CONFIG_GBM', gbm.found())\nconfig_host_data.set('CONFIG_GIO', gio.found())\nconfig_host_data.set('CONFIG_GLUSTERFS', glusterfs.found())\nif glusterfs.found()\n  config_host_data.set('CONFIG_GLUSTERFS_XLATOR_OPT', glusterfs.version().version_compare('>=4'))\n  config_host_data.set('CONFIG_GLUSTERFS_DISCARD', glusterfs.version().version_compare('>=5'))\n  config_host_data.set('CONFIG_GLUSTERFS_FALLOCATE', glusterfs.version().version_compare('>=6'))\n  config_host_data.set('CONFIG_GLUSTERFS_ZEROFILL', glusterfs.version().version_compare('>=6'))\n  config_host_data.set('CONFIG_GLUSTERFS_FTRUNCATE_HAS_STAT', glusterfs_ftruncate_has_stat)\n  config_host_data.set('CONFIG_GLUSTERFS_IOCB_HAS_STAT', glusterfs_iocb_has_stat)\nendif\nconfig_host_data.set('CONFIG_GTK', gtk.found())\nconfig_host_data.set('CONFIG_VTE', vte.found())\nconfig_host_data.set('CONFIG_LIBATTR', have_old_libattr)\nconfig_host_data.set('CONFIG_LIBCAP_NG', libcap_ng.found())\nconfig_host_data.set('CONFIG_EBPF', libbpf.found())\nconfig_host_data.set('CONFIG_LIBDAXCTL', libdaxctl.found())\nconfig_host_data.set('CONFIG_LIBISCSI', libiscsi.found())\nconfig_host_data.set('CONFIG_LIBNFS', libnfs.found())\nconfig_host_data.set('CONFIG_LIBSSH', libssh.found())\nconfig_host_data.set('CONFIG_LINUX_AIO', libaio.found())\nconfig_host_data.set('CONFIG_LINUX_IO_URING', linux_io_uring.found())\nconfig_host_data.set('CONFIG_LIBURING_REGISTER_RING_FD', cc.has_function('io_uring_register_ring_fd', prefix: '#include <liburing.h>', dependencies:linux_io_uring))\nconfig_host_data.set('CONFIG_LIBPMEM', libpmem.found())\nconfig_host_data.set('CONFIG_NUMA', numa.found())\nconfig_host_data.set('CONFIG_OPENGL', opengl.found())\nconfig_host_data.set('CONFIG_PROFILER', get_option('profiler'))\nconfig_host_data.set('CONFIG_RBD', rbd.found())\nconfig_host_data.set('CONFIG_RDMA', rdma.found())\nconfig_host_data.set('CONFIG_SDL', sdl.found())\nconfig_host_data.set('CONFIG_SDL_IMAGE', sdl_image.found())\nconfig_host_data.set('CONFIG_SECCOMP', seccomp.found())\nconfig_host_data.set('CONFIG_SNAPPY', snappy.found())\nconfig_host_data.set('CONFIG_TPM', have_tpm)\nconfig_host_data.set('CONFIG_USB_LIBUSB', libusb.found())\nconfig_host_data.set('CONFIG_VDE', vde.found())\nconfig_host_data.set('CONFIG_VHOST_NET', have_vhost_net)\nconfig_host_data.set('CONFIG_VHOST_NET_USER', have_vhost_net_user)\nconfig_host_data.set('CONFIG_VHOST_NET_VDPA', have_vhost_net_vdpa)\nconfig_host_data.set('CONFIG_VHOST_KERNEL', have_vhost_kernel)\nconfig_host_data.set('CONFIG_VHOST_USER', have_vhost_user)\nconfig_host_data.set('CONFIG_VHOST_CRYPTO', have_vhost_user_crypto)\nconfig_host_data.set('CONFIG_VHOST_VDPA', have_vhost_vdpa)\nconfig_host_data.set('CONFIG_VMNET', vmnet.found())\nconfig_host_data.set('CONFIG_VHOST_USER_BLK_SERVER', have_vhost_user_blk_server)\nconfig_host_data.set('CONFIG_VDUSE_BLK_EXPORT', have_vduse_blk_export)\nconfig_host_data.set('CONFIG_PNG', png.found())\nconfig_host_data.set('CONFIG_VNC', vnc.found())\nconfig_host_data.set('CONFIG_VNC_JPEG', jpeg.found())\nconfig_host_data.set('CONFIG_VNC_SASL', sasl.found())\nconfig_host_data.set('CONFIG_VIRTFS', have_virtfs)\nconfig_host_data.set('CONFIG_VTE', vte.found())\nconfig_host_data.set('CONFIG_XKBCOMMON', xkbcommon.found())\nconfig_host_data.set('CONFIG_KEYUTILS', keyutils.found())\nconfig_host_data.set('CONFIG_GETTID', has_gettid)\nconfig_host_data.set('CONFIG_GNUTLS', gnutls.found())\nconfig_host_data.set('CONFIG_GNUTLS_CRYPTO', gnutls_crypto.found())\nconfig_host_data.set('CONFIG_TASN1', tasn1.found())\nconfig_host_data.set('CONFIG_GCRYPT', gcrypt.found())\nconfig_host_data.set('CONFIG_NETTLE', nettle.found())\nconfig_host_data.set('CONFIG_HOGWEED', hogweed.found())\nconfig_host_data.set('CONFIG_QEMU_PRIVATE_XTS', xts == 'private')\nconfig_host_data.set('CONFIG_MALLOC_TRIM', has_malloc_trim)\nconfig_host_data.set('CONFIG_STATX', has_statx)\nconfig_host_data.set('CONFIG_STATX_MNT_ID', has_statx_mnt_id)\nconfig_host_data.set('CONFIG_ZSTD', zstd.found())\nconfig_host_data.set('CONFIG_FUSE', fuse.found())\nconfig_host_data.set('CONFIG_FUSE_LSEEK', fuse_lseek.found())\nconfig_host_data.set('CONFIG_SPICE_PROTOCOL', spice_protocol.found())\nif spice_protocol.found()\nconfig_host_data.set('CONFIG_SPICE_PROTOCOL_MAJOR', spice_protocol.version().split('.')[0])\nconfig_host_data.set('CONFIG_SPICE_PROTOCOL_MINOR', spice_protocol.version().split('.')[1])\nconfig_host_data.set('CONFIG_SPICE_PROTOCOL_MICRO', spice_protocol.version().split('.')[2])\nendif\nconfig_host_data.set('CONFIG_SPICE', spice.found())\nconfig_host_data.set('CONFIG_X11', x11.found())\nconfig_host_data.set('CONFIG_DBUS_DISPLAY', dbus_display)\nconfig_host_data.set('CONFIG_CFI', get_option('cfi'))\nconfig_host_data.set('CONFIG_SELINUX', selinux.found())\nconfig_host_data.set('CONFIG_XEN_BACKEND', xen.found())\nif xen.found()\n  # protect from xen.version() having less than three components\n  xen_version = xen.version().split('.') + ['0', '0']\n  xen_ctrl_version = xen_version[0] + \\\n    ('0' + xen_version[1]).substring(-2) + \\\n    ('0' + xen_version[2]).substring(-2)\n  config_host_data.set('CONFIG_XEN_CTRL_INTERFACE_VERSION', xen_ctrl_version)\nendif\nconfig_host_data.set('QEMU_VERSION', '\"@0@\"'.format(meson.project_version()))\nconfig_host_data.set('QEMU_VERSION_MAJOR', meson.project_version().split('.')[0])\nconfig_host_data.set('QEMU_VERSION_MINOR', meson.project_version().split('.')[1])\nconfig_host_data.set('QEMU_VERSION_MICRO', meson.project_version().split('.')[2])\n\nconfig_host_data.set_quoted('CONFIG_HOST_DSOSUF', host_dsosuf)\nconfig_host_data.set('HAVE_HOST_BLOCK_DEVICE', have_host_block_device)\n\nhave_coroutine_pool = get_option('coroutine_pool')\nif get_option('debug_stack_usage') and have_coroutine_pool\n  message('Disabling coroutine pool to measure stack usage')\n  have_coroutine_pool = false\nendif\nconfig_host_data.set10('CONFIG_COROUTINE_POOL', have_coroutine_pool)\nconfig_host_data.set('CONFIG_DEBUG_MUTEX', get_option('debug_mutex'))\nconfig_host_data.set('CONFIG_DEBUG_STACK_USAGE', get_option('debug_stack_usage'))\nconfig_host_data.set('CONFIG_GPROF', get_option('gprof'))\nconfig_host_data.set('CONFIG_LIVE_BLOCK_MIGRATION', get_option('live_block_migration').allowed())\nconfig_host_data.set('CONFIG_QOM_CAST_DEBUG', get_option('qom_cast_debug'))\nconfig_host_data.set('CONFIG_REPLICATION', get_option('live_block_migration').allowed())\n\n# has_header\nconfig_host_data.set('CONFIG_EPOLL', cc.has_header('sys/epoll.h'))\nconfig_host_data.set('CONFIG_LINUX_MAGIC_H', cc.has_header('linux/magic.h'))\nconfig_host_data.set('CONFIG_VALGRIND_H', cc.has_header('valgrind/valgrind.h'))\nconfig_host_data.set('HAVE_BTRFS_H', cc.has_header('linux/btrfs.h'))\nconfig_host_data.set('HAVE_DRM_H', cc.has_header('libdrm/drm.h'))\nconfig_host_data.set('HAVE_PTY_H', cc.has_header('pty.h'))\nconfig_host_data.set('HAVE_SYS_DISK_H', cc.has_header('sys/disk.h'))\nconfig_host_data.set('HAVE_SYS_IOCCOM_H', cc.has_header('sys/ioccom.h'))\nconfig_host_data.set('HAVE_SYS_KCOV_H', cc.has_header('sys/kcov.h'))\n\n# has_function\nconfig_host_data.set('CONFIG_ACCEPT4', cc.has_function('accept4'))\nconfig_host_data.set('CONFIG_CLOCK_ADJTIME', cc.has_function('clock_adjtime'))\nconfig_host_data.set('CONFIG_DUP3', cc.has_function('dup3'))\nconfig_host_data.set('CONFIG_FALLOCATE', cc.has_function('fallocate'))\nconfig_host_data.set('CONFIG_POSIX_FALLOCATE', cc.has_function('posix_fallocate'))\n# Note that we need to specify prefix: here to avoid incorrectly\n# thinking that Windows has posix_memalign()\nconfig_host_data.set('CONFIG_POSIX_MEMALIGN', cc.has_function('posix_memalign', prefix: '#include <stdlib.h>'))\nconfig_host_data.set('CONFIG_ALIGNED_MALLOC', cc.has_function('_aligned_malloc'))\nconfig_host_data.set('CONFIG_VALLOC', cc.has_function('valloc'))\nconfig_host_data.set('CONFIG_MEMALIGN', cc.has_function('memalign'))\nconfig_host_data.set('CONFIG_PPOLL', cc.has_function('ppoll'))\nconfig_host_data.set('CONFIG_PREADV', cc.has_function('preadv', prefix: '#include <sys/uio.h>'))\nconfig_host_data.set('CONFIG_PTHREAD_FCHDIR_NP', cc.has_function('pthread_fchdir_np'))\nconfig_host_data.set('CONFIG_SENDFILE', cc.has_function('sendfile'))\nconfig_host_data.set('CONFIG_SETNS', cc.has_function('setns') and cc.has_function('unshare'))\nconfig_host_data.set('CONFIG_SYNCFS', cc.has_function('syncfs'))\nconfig_host_data.set('CONFIG_SYNC_FILE_RANGE', cc.has_function('sync_file_range'))\nconfig_host_data.set('CONFIG_TIMERFD', cc.has_function('timerfd_create'))\nconfig_host_data.set('HAVE_COPY_FILE_RANGE', cc.has_function('copy_file_range'))\nconfig_host_data.set('HAVE_GETIFADDRS', cc.has_function('getifaddrs'))\nconfig_host_data.set('HAVE_OPENPTY', cc.has_function('openpty', dependencies: util))\nconfig_host_data.set('HAVE_STRCHRNUL', cc.has_function('strchrnul'))\nconfig_host_data.set('HAVE_SYSTEM_FUNCTION', cc.has_function('system', prefix: '#include <stdlib.h>'))\nif rbd.found()\n  config_host_data.set('HAVE_RBD_NAMESPACE_EXISTS',\n                       cc.has_function('rbd_namespace_exists',\n                                       dependencies: rbd,\n                                       prefix: '#include <rbd/librbd.h>'))\nendif\nif rdma.found()\n  config_host_data.set('HAVE_IBV_ADVISE_MR',\n                       cc.has_function('ibv_advise_mr',\n                                       dependencies: rdma,\n                                       prefix: '#include <infiniband/verbs.h>'))\nendif\n\n# has_header_symbol\nconfig_host_data.set('CONFIG_BYTESWAP_H',\n                     cc.has_header_symbol('byteswap.h', 'bswap_32'))\nconfig_host_data.set('CONFIG_EPOLL_CREATE1',\n                     cc.has_header_symbol('sys/epoll.h', 'epoll_create1'))\nconfig_host_data.set('CONFIG_FALLOCATE_PUNCH_HOLE',\n                     cc.has_header_symbol('linux/falloc.h', 'FALLOC_FL_PUNCH_HOLE') and\n                     cc.has_header_symbol('linux/falloc.h', 'FALLOC_FL_KEEP_SIZE'))\nconfig_host_data.set('CONFIG_FALLOCATE_ZERO_RANGE',\n                     cc.has_header_symbol('linux/falloc.h', 'FALLOC_FL_ZERO_RANGE'))\nconfig_host_data.set('CONFIG_FIEMAP',\n                     cc.has_header('linux/fiemap.h') and\n                     cc.has_header_symbol('linux/fs.h', 'FS_IOC_FIEMAP'))\nconfig_host_data.set('CONFIG_GETRANDOM',\n                     cc.has_function('getrandom') and\n                     cc.has_header_symbol('sys/random.h', 'GRND_NONBLOCK'))\nconfig_host_data.set('CONFIG_INOTIFY',\n                     cc.has_header_symbol('sys/inotify.h', 'inotify_init'))\nconfig_host_data.set('CONFIG_INOTIFY1',\n                     cc.has_header_symbol('sys/inotify.h', 'inotify_init1'))\nconfig_host_data.set('CONFIG_MACHINE_BSWAP_H',\n                     cc.has_header_symbol('machine/bswap.h', 'bswap32',\n                                          prefix: '''#include <sys/endian.h>\n                                                     #include <sys/types.h>'''))\nconfig_host_data.set('CONFIG_PRCTL_PR_SET_TIMERSLACK',\n                     cc.has_header_symbol('sys/prctl.h', 'PR_SET_TIMERSLACK'))\nconfig_host_data.set('CONFIG_RTNETLINK',\n                     cc.has_header_symbol('linux/rtnetlink.h', 'IFLA_PROTO_DOWN'))\nconfig_host_data.set('CONFIG_SYSMACROS',\n                     cc.has_header_symbol('sys/sysmacros.h', 'makedev'))\nconfig_host_data.set('HAVE_OPTRESET',\n                     cc.has_header_symbol('getopt.h', 'optreset'))\nconfig_host_data.set('HAVE_IPPROTO_MPTCP',\n                     cc.has_header_symbol('netinet/in.h', 'IPPROTO_MPTCP'))\nconfig_host_data.set('HAVE_SYS_MOUNT_FSCONFIG',\n                     cc.has_header_symbol('sys/mount.h', 'FSCONFIG_SET_FLAG'))\n\n# has_member\nconfig_host_data.set('HAVE_SIGEV_NOTIFY_THREAD_ID',\n                     cc.has_member('struct sigevent', 'sigev_notify_thread_id',\n                                   prefix: '#include <signal.h>'))\nconfig_host_data.set('HAVE_STRUCT_STAT_ST_ATIM',\n                     cc.has_member('struct stat', 'st_atim',\n                                   prefix: '#include <sys/stat.h>'))\n\n# has_type\nconfig_host_data.set('CONFIG_IOVEC',\n                     cc.has_type('struct iovec',\n                                 prefix: '#include <sys/uio.h>'))\nconfig_host_data.set('HAVE_UTMPX',\n                     cc.has_type('struct utmpx',\n                                 prefix: '#include <utmpx.h>'))\n\nconfig_host_data.set('CONFIG_EVENTFD', cc.links('''\n  #include <sys/eventfd.h>\n  int main(void) { return eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); }'''))\nconfig_host_data.set('CONFIG_FDATASYNC', cc.links(gnu_source_prefix + '''\n  #include <unistd.h>\n  int main(void) {\n  #if defined(_POSIX_SYNCHRONIZED_IO) && _POSIX_SYNCHRONIZED_IO > 0\n  return fdatasync(0);\n  #else\n  #error Not supported\n  #endif\n  }'''))\n\nhas_madvise = cc.links(gnu_source_prefix + '''\n  #include <sys/types.h>\n  #include <sys/mman.h>\n  #include <stddef.h>\n  int main(void) { return madvise(NULL, 0, MADV_DONTNEED); }''')\nmissing_madvise_proto = false\nif has_madvise\n  # Some platforms (illumos and Solaris before Solaris 11) provide madvise()\n  # but forget to prototype it. In this case, has_madvise will be true (the\n  # test program links despite a compile warning). To detect the\n  # missing-prototype case, we try again with a definitely-bogus prototype.\n  # This will only compile if the system headers don't provide the prototype;\n  # otherwise the conflicting prototypes will cause a compiler error.\n  missing_madvise_proto = cc.links(gnu_source_prefix + '''\n    #include <sys/types.h>\n    #include <sys/mman.h>\n    #include <stddef.h>\n    extern int madvise(int);\n    int main(void) { return madvise(0); }''')\nendif\nconfig_host_data.set('CONFIG_MADVISE', has_madvise)\nconfig_host_data.set('HAVE_MADVISE_WITHOUT_PROTOTYPE', missing_madvise_proto)\n\nconfig_host_data.set('CONFIG_MEMFD', cc.links(gnu_source_prefix + '''\n  #include <sys/mman.h>\n  int main(void) { return memfd_create(\"foo\", MFD_ALLOW_SEALING); }'''))\nconfig_host_data.set('CONFIG_OPEN_BY_HANDLE', cc.links(gnu_source_prefix + '''\n  #include <fcntl.h>\n  #if !defined(AT_EMPTY_PATH)\n  # error missing definition\n  #else\n  int main(void) { struct file_handle fh; return open_by_handle_at(0, &fh, 0); }\n  #endif'''))\nconfig_host_data.set('CONFIG_POSIX_MADVISE', cc.links(gnu_source_prefix + '''\n  #include <sys/mman.h>\n  #include <stddef.h>\n  int main(void) { return posix_madvise(NULL, 0, POSIX_MADV_DONTNEED); }'''))\n\nconfig_host_data.set('CONFIG_PTHREAD_SETNAME_NP_W_TID', cc.links(gnu_source_prefix + '''\n  #include <pthread.h>\n\n  static void *f(void *p) { return NULL; }\n  int main(void)\n  {\n    pthread_t thread;\n    pthread_create(&thread, 0, f, 0);\n    pthread_setname_np(thread, \"QEMU\");\n    return 0;\n  }''', dependencies: threads))\nconfig_host_data.set('CONFIG_PTHREAD_SETNAME_NP_WO_TID', cc.links(gnu_source_prefix + '''\n  #include <pthread.h>\n\n  static void *f(void *p) { pthread_setname_np(\"QEMU\"); return NULL; }\n  int main(void)\n  {\n    pthread_t thread;\n    pthread_create(&thread, 0, f, 0);\n    return 0;\n  }''', dependencies: threads))\nconfig_host_data.set('CONFIG_PTHREAD_CONDATTR_SETCLOCK', cc.links(gnu_source_prefix + '''\n  #include <pthread.h>\n  #include <time.h>\n\n  int main(void)\n  {\n    pthread_condattr_t attr\n    pthread_condattr_init(&attr);\n    pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);\n    return 0;\n  }''', dependencies: threads))\n\nconfig_host_data.set('CONFIG_SIGNALFD', cc.links(gnu_source_prefix + '''\n  #include <sys/signalfd.h>\n  #include <stddef.h>\n  int main(void) { return signalfd(-1, NULL, SFD_CLOEXEC); }'''))\nconfig_host_data.set('CONFIG_SPLICE', cc.links(gnu_source_prefix + '''\n  #include <unistd.h>\n  #include <fcntl.h>\n  #include <limits.h>\n\n  int main(void)\n  {\n    int len, fd = 0;\n    len = tee(STDIN_FILENO, STDOUT_FILENO, INT_MAX, SPLICE_F_NONBLOCK);\n    splice(STDIN_FILENO, NULL, fd, NULL, len, SPLICE_F_MOVE);\n    return 0;\n  }'''))\n\nconfig_host_data.set('HAVE_MLOCKALL', cc.links(gnu_source_prefix + '''\n  #include <sys/mman.h>\n  int main(int argc, char *argv[]) {\n    return mlockall(MCL_FUTURE);\n  }'''))\n\nhave_l2tpv3 = false\nif get_option('l2tpv3').allowed() and have_system\n  have_l2tpv3 = cc.has_type('struct mmsghdr',\n    prefix: gnu_source_prefix + '''\n      #include <sys/socket.h>\n      #include <linux/ip.h>''')\nendif\nconfig_host_data.set('CONFIG_L2TPV3', have_l2tpv3)\n\nhave_netmap = false\nif get_option('netmap').allowed() and have_system\n  have_netmap = cc.compiles('''\n    #include <inttypes.h>\n    #include <net/if.h>\n    #include <net/netmap.h>\n    #include <net/netmap_user.h>\n    #if (NETMAP_API < 11) || (NETMAP_API > 15)\n    #error\n    #endif\n    int main(void) { return 0; }''')\n  if not have_netmap and get_option('netmap').enabled()\n    error('Netmap headers not available')\n  endif\nendif\nconfig_host_data.set('CONFIG_NETMAP', have_netmap)\n\n# Work around a system header bug with some kernel/XFS header\n# versions where they both try to define 'struct fsxattr':\n# xfs headers will not try to redefine structs from linux headers\n# if this macro is set.\nconfig_host_data.set('HAVE_FSXATTR', cc.links('''\n  #include <linux/fs.h>\n  struct fsxattr foo;\n  int main(void) {\n    return 0;\n  }'''))\n\n# Some versions of Mac OS X incorrectly define SIZE_MAX\nconfig_host_data.set('HAVE_BROKEN_SIZE_MAX', not cc.compiles('''\n    #include <stdint.h>\n    #include <stdio.h>\n    int main(int argc, char *argv[]) {\n        return printf(\"%zu\", SIZE_MAX);\n    }''', args: ['-Werror']))\n\natomic_test = '''\n  #include <stdint.h>\n  int main(void)\n  {\n    @0@ x = 0, y = 0;\n    y = __atomic_load_n(&x, __ATOMIC_RELAXED);\n    __atomic_store_n(&x, y, __ATOMIC_RELAXED);\n    __atomic_compare_exchange_n(&x, &y, x, 0, __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n    __atomic_exchange_n(&x, y, __ATOMIC_RELAXED);\n    __atomic_fetch_add(&x, y, __ATOMIC_RELAXED);\n    return 0;\n  }'''\n\n# See if 64-bit atomic operations are supported.\n# Note that without __atomic builtins, we can only\n# assume atomic loads/stores max at pointer size.\nconfig_host_data.set('CONFIG_ATOMIC64', cc.links(atomic_test.format('uint64_t')))\n\nhas_int128 = cc.links('''\n  __int128_t a;\n  __uint128_t b;\n  int main (void) {\n    a = a + b;\n    b = a * b;\n    a = a * a;\n    return 0;\n  }''')\n\nconfig_host_data.set('CONFIG_INT128', has_int128)\n\nif has_int128\n  # \"do we have 128-bit atomics which are handled inline and specifically not\n  # via libatomic\". The reason we can't use libatomic is documented in the\n  # comment starting \"GCC is a house divided\" in include/qemu/atomic128.h.\n  has_atomic128 = cc.links(atomic_test.format('unsigned __int128'))\n\n  config_host_data.set('CONFIG_ATOMIC128', has_atomic128)\n\n  if not has_atomic128\n    has_cmpxchg128 = cc.links('''\n      int main(void)\n      {\n        unsigned __int128 x = 0, y = 0;\n        __sync_val_compare_and_swap_16(&x, y, x);\n        return 0;\n      }\n    ''')\n\n    config_host_data.set('CONFIG_CMPXCHG128', has_cmpxchg128)\n  endif\nendif\n\nconfig_host_data.set('CONFIG_GETAUXVAL', cc.links(gnu_source_prefix + '''\n  #include <sys/auxv.h>\n  int main(void) {\n    return getauxval(AT_HWCAP) == 0;\n  }'''))\n\nconfig_host_data.set('CONFIG_USBFS', have_linux_user and cc.compiles('''\n  #include <linux/usbdevice_fs.h>\n\n  #ifndef USBDEVFS_GET_CAPABILITIES\n  #error \"USBDEVFS_GET_CAPABILITIES undefined\"\n  #endif\n\n  #ifndef USBDEVFS_DISCONNECT_CLAIM\n  #error \"USBDEVFS_DISCONNECT_CLAIM undefined\"\n  #endif\n\n  int main(void) { return 0; }'''))\n\nhave_keyring = get_option('keyring') \\\n  .require(targetos == 'linux', error_message: 'keyring is only available on Linux') \\\n  .require(cc.compiles('''\n    #include <errno.h>\n    #include <asm/unistd.h>\n    #include <linux/keyctl.h>\n    #include <sys/syscall.h>\n    #include <unistd.h>\n    int main(void) {\n        return syscall(__NR_keyctl, KEYCTL_READ, 0, NULL, NULL, 0);\n    }'''), error_message: 'keyctl syscall not available on this system').allowed()\nconfig_host_data.set('CONFIG_SECRET_KEYRING', have_keyring)\n\nhave_cpuid_h = cc.links('''\n  #include <cpuid.h>\n  int main(void) {\n    unsigned a, b, c, d;\n    unsigned max = __get_cpuid_max(0, 0);\n\n    if (max >= 1) {\n        __cpuid(1, a, b, c, d);\n    }\n\n    if (max >= 7) {\n        __cpuid_count(7, 0, a, b, c, d);\n    }\n\n    return 0;\n  }''')\nconfig_host_data.set('CONFIG_CPUID_H', have_cpuid_h)\n\nconfig_host_data.set('CONFIG_AVX2_OPT', get_option('avx2') \\\n  .require(have_cpuid_h, error_message: 'cpuid.h not available, cannot enable AVX2') \\\n  .require(cc.links('''\n    #pragma GCC push_options\n    #pragma GCC target(\"avx2\")\n    #include <cpuid.h>\n    #include <immintrin.h>\n    static int bar(void *a) {\n      __m256i x = *(__m256i *)a;\n      return _mm256_testz_si256(x, x);\n    }\n    int main(int argc, char *argv[]) { return bar(argv[0]); }\n  '''), error_message: 'AVX2 not available').allowed())\n\nconfig_host_data.set('CONFIG_AVX512F_OPT', get_option('avx512f') \\\n  .require(have_cpuid_h, error_message: 'cpuid.h not available, cannot enable AVX512F') \\\n  .require(cc.links('''\n    #pragma GCC push_options\n    #pragma GCC target(\"avx512f\")\n    #include <cpuid.h>\n    #include <immintrin.h>\n    static int bar(void *a) {\n      __m512i x = *(__m512i *)a;\n      return _mm512_test_epi64_mask(x, x);\n    }\n    int main(int argc, char *argv[]) { return bar(argv[0]); }\n  '''), error_message: 'AVX512F not available').allowed())\n\nhave_pvrdma = get_option('pvrdma') \\\n  .require(rdma.found(), error_message: 'PVRDMA requires OpenFabrics libraries') \\\n  .require(cc.compiles(gnu_source_prefix + '''\n    #include <sys/mman.h>\n    int main(void)\n    {\n      char buf = 0;\n      void *addr = &buf;\n      addr = mremap(addr, 0, 1, MREMAP_MAYMOVE | MREMAP_FIXED);\n\n      return 0;\n    }'''), error_message: 'PVRDMA requires mremap').allowed()\n\nif have_pvrdma\n  config_host_data.set('LEGACY_RDMA_REG_MR', not cc.links('''\n    #include <infiniband/verbs.h>\n    int main(void)\n    {\n      struct ibv_mr *mr;\n      struct ibv_pd *pd = NULL;\n      size_t length = 10;\n      uint64_t iova = 0;\n      int access = 0;\n      void *addr = NULL;\n\n      mr = ibv_reg_mr_iova(pd, addr, length, iova, access);\n      ibv_dereg_mr(mr);\n      return 0;\n    }'''))\nendif\n\nif get_option('membarrier').disabled()\n  have_membarrier = false\nelif targetos == 'windows'\n  have_membarrier = true\nelif targetos == 'linux'\n  have_membarrier = cc.compiles('''\n    #include <linux/membarrier.h>\n    #include <sys/syscall.h>\n    #include <unistd.h>\n    #include <stdlib.h>\n    int main(void) {\n        syscall(__NR_membarrier, MEMBARRIER_CMD_QUERY, 0);\n        syscall(__NR_membarrier, MEMBARRIER_CMD_SHARED, 0);\n        exit(0);\n    }''')\nendif\nconfig_host_data.set('CONFIG_MEMBARRIER', get_option('membarrier') \\\n  .require(have_membarrier, error_message: 'membarrier system call not available') \\\n  .allowed())\n\nhave_afalg = get_option('crypto_afalg') \\\n  .require(cc.compiles(gnu_source_prefix + '''\n    #include <errno.h>\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <linux/if_alg.h>\n    int main(void) {\n      int sock;\n      sock = socket(AF_ALG, SOCK_SEQPACKET, 0);\n      return sock;\n    }\n  '''), error_message: 'AF_ALG requested but could not be detected').allowed()\nconfig_host_data.set('CONFIG_AF_ALG', have_afalg)\n\nconfig_host_data.set('CONFIG_AF_VSOCK', cc.has_header_symbol(\n  'linux/vm_sockets.h', 'AF_VSOCK',\n  prefix: '#include <sys/socket.h>',\n))\n\nhave_vss = false\nhave_vss_sdk = false # old xp/2003 SDK\nif targetos == 'windows' and link_language == 'cpp'\n  have_vss = cxx.compiles('''\n    #define __MIDL_user_allocate_free_DEFINED__\n    #include <vss.h>\n    int main(void) { return VSS_CTX_BACKUP; }''')\n  have_vss_sdk = cxx.has_header('vscoordint.h')\nendif\nconfig_host_data.set('HAVE_VSS_SDK', have_vss_sdk)\n\nforeach k, v: config_host\n  if k.startswith('CONFIG_')\n    config_host_data.set(k, v == 'y' ? 1 : v)\n  endif\nendforeach\n\n# Older versions of MinGW do not import _lock_file and _unlock_file properly.\n# This was fixed for v6.0.0 with commit b48e3ac8969d.\nif targetos == 'windows'\n  config_host_data.set('HAVE__LOCK_FILE', cc.links('''\n    #include <stdio.h>\n    int main(void) {\n      _lock_file(NULL);\n      _unlock_file(NULL);\n      return 0;\n    }''', name: '_lock_file and _unlock_file'))\nendif\n\n########################\n# Target configuration #\n########################\n\nminikconf = find_program('scripts/minikconf.py')\nconfig_all = {}\nconfig_all_devices = {}\nconfig_all_disas = {}\nconfig_devices_mak_list = []\nconfig_devices_h = {}\nconfig_target_h = {}\nconfig_target_mak = {}\n\ndisassemblers = {\n  'alpha' : ['CONFIG_ALPHA_DIS'],\n  'avr' : ['CONFIG_AVR_DIS'],\n  'cris' : ['CONFIG_CRIS_DIS'],\n  'hexagon' : ['CONFIG_HEXAGON_DIS'],\n  'hppa' : ['CONFIG_HPPA_DIS'],\n  'i386' : ['CONFIG_I386_DIS'],\n  'x86_64' : ['CONFIG_I386_DIS'],\n  'm68k' : ['CONFIG_M68K_DIS'],\n  'microblaze' : ['CONFIG_MICROBLAZE_DIS'],\n  'mips' : ['CONFIG_MIPS_DIS'],\n  'nios2' : ['CONFIG_NIOS2_DIS'],\n  'or1k' : ['CONFIG_OPENRISC_DIS'],\n  'ppc' : ['CONFIG_PPC_DIS'],\n  'riscv' : ['CONFIG_RISCV_DIS'],\n  'rx' : ['CONFIG_RX_DIS'],\n  's390' : ['CONFIG_S390_DIS'],\n  'sh4' : ['CONFIG_SH4_DIS'],\n  'sparc' : ['CONFIG_SPARC_DIS'],\n  'xtensa' : ['CONFIG_XTENSA_DIS'],\n  'loongarch' : ['CONFIG_LOONGARCH_DIS'],\n}\nif link_language == 'cpp'\n  disassemblers += {\n    'mips' : [ 'CONFIG_MIPS_DIS', 'CONFIG_NANOMIPS_DIS'],\n  }\nendif\n\nhave_ivshmem = config_host_data.get('CONFIG_EVENTFD')\nhost_kconfig = \\\n  (get_option('fuzzing') ? ['CONFIG_FUZZ=y'] : []) + \\\n  (have_tpm ? ['CONFIG_TPM=y'] : []) + \\\n  (spice.found() ? ['CONFIG_SPICE=y'] : []) + \\\n  (have_ivshmem ? ['CONFIG_IVSHMEM=y'] : []) + \\\n  (opengl.found() ? ['CONFIG_OPENGL=y'] : []) + \\\n  (x11.found() ? ['CONFIG_X11=y'] : []) + \\\n  (have_vhost_user ? ['CONFIG_VHOST_USER=y'] : []) + \\\n  (have_vhost_vdpa ? ['CONFIG_VHOST_VDPA=y'] : []) + \\\n  (have_vhost_kernel ? ['CONFIG_VHOST_KERNEL=y'] : []) + \\\n  (have_virtfs ? ['CONFIG_VIRTFS=y'] : []) + \\\n  ('CONFIG_LINUX' in config_host ? ['CONFIG_LINUX=y'] : []) + \\\n  (have_pvrdma ? ['CONFIG_PVRDMA=y'] : []) + \\\n  (multiprocess_allowed ? ['CONFIG_MULTIPROCESS_ALLOWED=y'] : []) + \\\n  (vfio_user_server_allowed ? ['CONFIG_VFIO_USER_SERVER_ALLOWED=y'] : [])\n\nignored = [ 'TARGET_XML_FILES', 'TARGET_ABI_DIR', 'TARGET_ARCH' ]\n\ndefault_targets = 'CONFIG_DEFAULT_TARGETS' in config_host\nactual_target_dirs = []\nfdt_required = []\nforeach target : target_dirs\n  config_target = { 'TARGET_NAME': target.split('-')[0] }\n  if target.endswith('linux-user')\n    if targetos != 'linux'\n      if default_targets\n        continue\n      endif\n      error('Target @0@ is only available on a Linux host'.format(target))\n    endif\n    config_target += { 'CONFIG_LINUX_USER': 'y' }\n  elif target.endswith('bsd-user')\n    if 'CONFIG_BSD' not in config_host\n      if default_targets\n        continue\n      endif\n      error('Target @0@ is only available on a BSD host'.format(target))\n    endif\n    config_target += { 'CONFIG_BSD_USER': 'y' }\n  elif target.endswith('softmmu')\n    config_target += { 'CONFIG_SOFTMMU': 'y' }\n  endif\n  if target.endswith('-user')\n    config_target += {\n      'CONFIG_USER_ONLY': 'y',\n      'CONFIG_QEMU_INTERP_PREFIX':\n        get_option('interp_prefix').replace('%M', config_target['TARGET_NAME'])\n    }\n  endif\n\n  accel_kconfig = []\n  foreach sym: accelerators\n    if sym == 'CONFIG_TCG' or target in accelerator_targets.get(sym, [])\n      config_target += { sym: 'y' }\n      config_all += { sym: 'y' }\n      if sym == 'CONFIG_TCG' and tcg_arch == 'tci'\n        config_target += { 'CONFIG_TCG_INTERPRETER': 'y' }\n      endif\n      if target in modular_tcg\n        config_target += { 'CONFIG_TCG_MODULAR': 'y' }\n      else\n        config_target += { 'CONFIG_TCG_BUILTIN': 'y' }\n      endif\n      accel_kconfig += [ sym + '=y' ]\n    endif\n  endforeach\n  if accel_kconfig.length() == 0\n    if default_targets\n      continue\n    endif\n    error('No accelerator available for target @0@'.format(target))\n  endif\n\n  actual_target_dirs += target\n  config_target += keyval.load('configs/targets' / target + '.mak')\n  config_target += { 'TARGET_' + config_target['TARGET_ARCH'].to_upper(): 'y' }\n\n  if 'TARGET_NEED_FDT' in config_target\n    fdt_required += target\n  endif\n\n  # Add default keys\n  if 'TARGET_BASE_ARCH' not in config_target\n    config_target += {'TARGET_BASE_ARCH': config_target['TARGET_ARCH']}\n  endif\n  if 'TARGET_ABI_DIR' not in config_target\n    config_target += {'TARGET_ABI_DIR': config_target['TARGET_ARCH']}\n  endif\n  if 'TARGET_BIG_ENDIAN' not in config_target\n    config_target += {'TARGET_BIG_ENDIAN': 'n'}\n  endif\n\n  foreach k, v: disassemblers\n    if host_arch.startswith(k) or config_target['TARGET_BASE_ARCH'].startswith(k)\n      foreach sym: v\n        config_target += { sym: 'y' }\n        config_all_disas += { sym: 'y' }\n      endforeach\n    endif\n  endforeach\n\n  config_target_data = configuration_data()\n  foreach k, v: config_target\n    if not k.startswith('TARGET_') and not k.startswith('CONFIG_')\n      # do nothing\n    elif ignored.contains(k)\n      # do nothing\n    elif k == 'TARGET_BASE_ARCH'\n      # Note that TARGET_BASE_ARCH ends up in config-target.h but it is\n      # not used to select files from sourcesets.\n      config_target_data.set('TARGET_' + v.to_upper(), 1)\n    elif k == 'TARGET_NAME' or k == 'CONFIG_QEMU_INTERP_PREFIX'\n      config_target_data.set_quoted(k, v)\n    elif v == 'y'\n      config_target_data.set(k, 1)\n    elif v == 'n'\n      config_target_data.set(k, 0)\n    else\n      config_target_data.set(k, v)\n    endif\n  endforeach\n  config_target_data.set('QEMU_ARCH',\n                         'QEMU_ARCH_' + config_target['TARGET_BASE_ARCH'].to_upper())\n  config_target_h += {target: configure_file(output: target + '-config-target.h',\n                                               configuration: config_target_data)}\n\n  if target.endswith('-softmmu')\n    config_input = meson.get_external_property(target, 'default')\n    config_devices_mak = target + '-config-devices.mak'\n    config_devices_mak = configure_file(\n      input: ['configs/devices' / target / config_input + '.mak', 'Kconfig'],\n      output: config_devices_mak,\n      depfile: config_devices_mak + '.d',\n      capture: true,\n      command: [minikconf,\n                get_option('default_devices') ? '--defconfig' : '--allnoconfig',\n                config_devices_mak, '@DEPFILE@', '@INPUT@',\n                host_kconfig, accel_kconfig,\n                'CONFIG_' + config_target['TARGET_ARCH'].to_upper() + '=y'])\n\n    config_devices_data = configuration_data()\n    config_devices = keyval.load(config_devices_mak)\n    foreach k, v: config_devices\n      config_devices_data.set(k, 1)\n    endforeach\n    config_devices_mak_list += config_devices_mak\n    config_devices_h += {target: configure_file(output: target + '-config-devices.h',\n                                                configuration: config_devices_data)}\n    config_target += config_devices\n    config_all_devices += config_devices\n  endif\n  config_target_mak += {target: config_target}\nendforeach\ntarget_dirs = actual_target_dirs\n\n# This configuration is used to build files that are shared by\n# multiple binaries, and then extracted out of the \"common\"\n# static_library target.\n#\n# We do not use all_sources()/all_dependencies(), because it would\n# build literally all source files, including devices only used by\n# targets that are not built for this compilation.  The CONFIG_ALL\n# pseudo symbol replaces it.\n\nconfig_all += config_all_devices\nconfig_all += config_host\nconfig_all += config_all_disas\nconfig_all += {\n  'CONFIG_XEN': xen.found(),\n  'CONFIG_SOFTMMU': have_system,\n  'CONFIG_USER_ONLY': have_user,\n  'CONFIG_ALL': true,\n}\n\ntarget_configs_h = []\nforeach target: target_dirs\n  target_configs_h += config_target_h[target]\n  target_configs_h += config_devices_h.get(target, [])\nendforeach\ngenh += custom_target('config-poison.h',\n                      input: [target_configs_h],\n                      output: 'config-poison.h',\n                      capture: true,\n                      command: [find_program('scripts/make-config-poison.sh'),\n                                target_configs_h])\n\n##############\n# Submodules #\n##############\n\ncapstone = not_found\nif not get_option('capstone').auto() or have_system or have_user\n  capstone = dependency('capstone', version: '>=3.0.5',\n                        kwargs: static_kwargs, method: 'pkg-config',\n                        required: get_option('capstone'))\n\n  # Some versions of capstone have broken pkg-config file\n  # that reports a wrong -I path, causing the #include to\n  # fail later. If the system has such a broken version\n  # do not use it.\n  if capstone.found() and not cc.compiles('#include <capstone.h>',\n                                          dependencies: [capstone])\n    capstone = not_found\n    if get_option('capstone').enabled()\n      error('capstone requested, but it does not appear to work')\n    endif\n  endif\nendif\n\nslirp = not_found\nslirp_opt = 'disabled'\nif have_system\n  slirp_opt = get_option('slirp')\n  if slirp_opt in ['enabled', 'auto', 'system']\n    have_internal = fs.exists(meson.current_source_dir() / 'slirp/meson.build')\n    slirp_dep_required = (slirp_opt == 'system' or\n                          slirp_opt == 'enabled' and not have_internal)\n    slirp = dependency('slirp', kwargs: static_kwargs,\n                       method: 'pkg-config', version: '>=4.1.0',\n                       required: slirp_dep_required)\n    # slirp <4.7 is incompatible with CFI support in QEMU.  This is because\n    # it passes function pointers within libslirp as callbacks for timers.\n    # When using a system-wide shared libslirp, the type information for the\n    # callback is missing and the timer call produces a false positive with CFI.\n    # Do not use the \"version\" keyword argument to produce a better error.\n    # with control-flow integrity.\n    if get_option('cfi') and slirp.found() and slirp.version().version_compare('<4.7')\n      if slirp_dep_required\n        error('Control-Flow Integrity requires libslirp 4.7.')\n      else\n        warning('Control-Flow Integrity requires libslirp 4.7, not using system-wide libslirp.')\n        slirp = not_found\n      endif\n    endif\n    if slirp.found()\n      slirp_opt = 'system'\n    elif have_internal\n      slirp_opt = 'internal'\n    else\n      slirp_opt = 'disabled'\n    endif\n  endif\n  if slirp_opt == 'internal'\n    slirp_deps = []\n    if targetos == 'windows'\n      slirp_deps = cc.find_library('iphlpapi')\n    elif targetos == 'darwin'\n      slirp_deps = cc.find_library('resolv')\n    endif\n    slirp_conf = configuration_data()\n    slirp_conf.set('SLIRP_MAJOR_VERSION', meson.project_version().split('.')[0])\n    slirp_conf.set('SLIRP_MINOR_VERSION', meson.project_version().split('.')[1])\n    slirp_conf.set('SLIRP_MICRO_VERSION', meson.project_version().split('.')[2])\n    slirp_conf.set_quoted('SLIRP_VERSION_STRING', meson.project_version())\n    slirp_cargs = ['-DG_LOG_DOMAIN=\"Slirp\"']\n    slirp_files = [\n      'slirp/src/arp_table.c',\n      'slirp/src/bootp.c',\n      'slirp/src/cksum.c',\n      'slirp/src/dhcpv6.c',\n      'slirp/src/dnssearch.c',\n      'slirp/src/if.c',\n      'slirp/src/ip6_icmp.c',\n      'slirp/src/ip6_input.c',\n      'slirp/src/ip6_output.c',\n      'slirp/src/ip_icmp.c',\n      'slirp/src/ip_input.c',\n      'slirp/src/ip_output.c',\n      'slirp/src/mbuf.c',\n      'slirp/src/misc.c',\n      'slirp/src/ncsi.c',\n      'slirp/src/ndp_table.c',\n      'slirp/src/sbuf.c',\n      'slirp/src/slirp.c',\n      'slirp/src/socket.c',\n      'slirp/src/state.c',\n      'slirp/src/stream.c',\n      'slirp/src/tcp_input.c',\n      'slirp/src/tcp_output.c',\n      'slirp/src/tcp_subr.c',\n      'slirp/src/tcp_timer.c',\n      'slirp/src/tftp.c',\n      'slirp/src/udp.c',\n      'slirp/src/udp6.c',\n      'slirp/src/util.c',\n      'slirp/src/version.c',\n      'slirp/src/vmstate.c',\n    ]\n\n    configure_file(\n      input : 'slirp/src/libslirp-version.h.in',\n      output : 'libslirp-version.h',\n      configuration: slirp_conf)\n\n    slirp_inc = include_directories('slirp', 'slirp/src')\n    libslirp = static_library('slirp',\n                              build_by_default: false,\n                              sources: slirp_files,\n                              c_args: slirp_cargs,\n                              include_directories: slirp_inc)\n    slirp = declare_dependency(link_with: libslirp,\n                               dependencies: slirp_deps,\n                               include_directories: slirp_inc)\n  endif\nendif\n\nlibvfio_user_dep = not_found\nif have_system and vfio_user_server_allowed\n  have_internal = fs.exists(meson.current_source_dir() / 'subprojects/libvfio-user/meson.build')\n\n  if not have_internal\n    error('libvfio-user source not found - please pull git submodule')\n  endif\n\n  libvfio_user_proj = subproject('libvfio-user')\n\n  libvfio_user_lib = libvfio_user_proj.get_variable('libvfio_user_dep')\n\n  libvfio_user_dep = declare_dependency(dependencies: [libvfio_user_lib])\nendif\n\nfdt = not_found\nif have_system\n  fdt_opt = get_option('fdt')\n  if fdt_opt in ['enabled', 'auto', 'system']\n    have_internal = fs.exists(meson.current_source_dir() / 'dtc/libfdt/Makefile.libfdt')\n    fdt = cc.find_library('fdt', kwargs: static_kwargs,\n                          required: fdt_opt == 'system' or\n                                    fdt_opt == 'enabled' and not have_internal)\n    if fdt.found() and cc.links('''\n       #include <libfdt.h>\n       #include <libfdt_env.h>\n       int main(void) { fdt_find_max_phandle(NULL, NULL); return 0; }''',\n         dependencies: fdt)\n      fdt_opt = 'system'\n    elif fdt_opt == 'system'\n       error('system libfdt requested, but it is too old (1.5.1 or newer required)')\n    elif have_internal\n      fdt_opt = 'internal'\n    else\n      fdt_opt = 'disabled'\n      fdt = not_found\n    endif\n  endif\n  if fdt_opt == 'internal'\n    fdt_files = files(\n      'dtc/libfdt/fdt.c',\n      'dtc/libfdt/fdt_ro.c',\n      'dtc/libfdt/fdt_wip.c',\n      'dtc/libfdt/fdt_sw.c',\n      'dtc/libfdt/fdt_rw.c',\n      'dtc/libfdt/fdt_strerror.c',\n      'dtc/libfdt/fdt_empty_tree.c',\n      'dtc/libfdt/fdt_addresses.c',\n      'dtc/libfdt/fdt_overlay.c',\n      'dtc/libfdt/fdt_check.c',\n    )\n\n    fdt_inc = include_directories('dtc/libfdt')\n    libfdt = static_library('fdt',\n                            build_by_default: false,\n                            sources: fdt_files,\n                            include_directories: fdt_inc)\n    fdt = declare_dependency(link_with: libfdt,\n                             include_directories: fdt_inc)\n  endif\nelse\n  fdt_opt = 'disabled'\nendif\nif not fdt.found() and fdt_required.length() > 0\n  error('fdt not available but required by targets ' + ', '.join(fdt_required))\nendif\n\nconfig_host_data.set('CONFIG_CAPSTONE', capstone.found())\nconfig_host_data.set('CONFIG_FDT', fdt.found())\nconfig_host_data.set('CONFIG_SLIRP', slirp.found())\n\n#####################\n# Generated sources #\n#####################\n\ngenh += configure_file(output: 'config-host.h', configuration: config_host_data)\n\nhxtool = find_program('scripts/hxtool')\nshaderinclude = find_program('scripts/shaderinclude.pl')\nqapi_gen = find_program('scripts/qapi-gen.py')\nqapi_gen_depends = [ meson.current_source_dir() / 'scripts/qapi/__init__.py',\n                     meson.current_source_dir() / 'scripts/qapi/commands.py',\n                     meson.current_source_dir() / 'scripts/qapi/common.py',\n                     meson.current_source_dir() / 'scripts/qapi/error.py',\n                     meson.current_source_dir() / 'scripts/qapi/events.py',\n                     meson.current_source_dir() / 'scripts/qapi/expr.py',\n                     meson.current_source_dir() / 'scripts/qapi/gen.py',\n                     meson.current_source_dir() / 'scripts/qapi/introspect.py',\n                     meson.current_source_dir() / 'scripts/qapi/parser.py',\n                     meson.current_source_dir() / 'scripts/qapi/schema.py',\n                     meson.current_source_dir() / 'scripts/qapi/source.py',\n                     meson.current_source_dir() / 'scripts/qapi/types.py',\n                     meson.current_source_dir() / 'scripts/qapi/visit.py',\n                     meson.current_source_dir() / 'scripts/qapi/common.py',\n                     meson.current_source_dir() / 'scripts/qapi-gen.py'\n]\n\ntracetool = [\n  python, files('scripts/tracetool.py'),\n   '--backend=' + ','.join(get_option('trace_backends'))\n]\ntracetool_depends = files(\n  'scripts/tracetool/backend/log.py',\n  'scripts/tracetool/backend/__init__.py',\n  'scripts/tracetool/backend/dtrace.py',\n  'scripts/tracetool/backend/ftrace.py',\n  'scripts/tracetool/backend/simple.py',\n  'scripts/tracetool/backend/syslog.py',\n  'scripts/tracetool/backend/ust.py',\n  'scripts/tracetool/format/ust_events_c.py',\n  'scripts/tracetool/format/ust_events_h.py',\n  'scripts/tracetool/format/__init__.py',\n  'scripts/tracetool/format/d.py',\n  'scripts/tracetool/format/simpletrace_stap.py',\n  'scripts/tracetool/format/c.py',\n  'scripts/tracetool/format/h.py',\n  'scripts/tracetool/format/log_stap.py',\n  'scripts/tracetool/format/stap.py',\n  'scripts/tracetool/__init__.py',\n  'scripts/tracetool/transform.py',\n  'scripts/tracetool/vcpu.py'\n)\n\nqemu_version_cmd = [find_program('scripts/qemu-version.sh'),\n                    meson.current_source_dir(),\n                    get_option('pkgversion'), meson.project_version()]\nqemu_version = custom_target('qemu-version.h',\n                             output: 'qemu-version.h',\n                             command: qemu_version_cmd,\n                             capture: true,\n                             build_by_default: true,\n                             build_always_stale: true)\ngenh += qemu_version\n\nhxdep = []\nhx_headers = [\n  ['qemu-options.hx', 'qemu-options.def'],\n  ['qemu-img-cmds.hx', 'qemu-img-cmds.h'],\n]\nif have_system\n  hx_headers += [\n    ['hmp-commands.hx', 'hmp-commands.h'],\n    ['hmp-commands-info.hx', 'hmp-commands-info.h'],\n  ]\nendif\nforeach d : hx_headers\n  hxdep += custom_target(d[1],\n                input: files(d[0]),\n                output: d[1],\n                capture: true,\n                build_by_default: true, # to be removed when added to a target\n                command: [hxtool, '-h', '@INPUT0@'])\nendforeach\ngenh += hxdep\n\n###################\n# Collect sources #\n###################\n\nauthz_ss = ss.source_set()\nblockdev_ss = ss.source_set()\nblock_ss = ss.source_set()\nchardev_ss = ss.source_set()\ncommon_ss = ss.source_set()\ncrypto_ss = ss.source_set()\nhwcore_ss = ss.source_set()\nio_ss = ss.source_set()\nqmp_ss = ss.source_set()\nqom_ss = ss.source_set()\nsoftmmu_ss = ss.source_set()\nspecific_fuzz_ss = ss.source_set()\nspecific_ss = ss.source_set()\nstub_ss = ss.source_set()\ntrace_ss = ss.source_set()\nuser_ss = ss.source_set()\nutil_ss = ss.source_set()\n\n# accel modules\nqtest_module_ss = ss.source_set()\ntcg_module_ss = ss.source_set()\n\nmodules = {}\ntarget_modules = {}\nhw_arch = {}\ntarget_arch = {}\ntarget_softmmu_arch = {}\ntarget_user_arch = {}\n\n###############\n# Trace files #\n###############\n\n# TODO: add each directory to the subdirs from its own meson.build, once\n# we have those\ntrace_events_subdirs = [\n  'crypto',\n  'qapi',\n  'qom',\n  'monitor',\n  'util',\n]\nif have_linux_user\n  trace_events_subdirs += [ 'linux-user' ]\nendif\nif have_bsd_user\n  trace_events_subdirs += [ 'bsd-user' ]\nendif\nif have_block\n  trace_events_subdirs += [\n    'authz',\n    'block',\n    'io',\n    'nbd',\n    'scsi',\n  ]\nendif\nif have_system\n  trace_events_subdirs += [\n    'accel/kvm',\n    'audio',\n    'backends',\n    'backends/tpm',\n    'chardev',\n    'ebpf',\n    'hw/9pfs',\n    'hw/acpi',\n    'hw/adc',\n    'hw/alpha',\n    'hw/arm',\n    'hw/audio',\n    'hw/block',\n    'hw/block/dataplane',\n    'hw/char',\n    'hw/display',\n    'hw/dma',\n    'hw/hyperv',\n    'hw/i2c',\n    'hw/i386',\n    'hw/i386/xen',\n    'hw/ide',\n    'hw/input',\n    'hw/intc',\n    'hw/isa',\n    'hw/mem',\n    'hw/mips',\n    'hw/misc',\n    'hw/misc/macio',\n    'hw/net',\n    'hw/net/can',\n    'hw/nubus',\n    'hw/nvme',\n    'hw/nvram',\n    'hw/pci',\n    'hw/pci-host',\n    'hw/ppc',\n    'hw/rdma',\n    'hw/rdma/vmw',\n    'hw/rtc',\n    'hw/s390x',\n    'hw/scsi',\n    'hw/sd',\n    'hw/sh4',\n    'hw/sparc',\n    'hw/sparc64',\n    'hw/spmi',\n    'hw/ssi',\n    'hw/timer',\n    'hw/tpm',\n    'hw/usb',\n    'hw/vfio',\n    'hw/virtio',\n    'hw/watchdog',\n    'hw/xen',\n    'hw/gpio',\n    'migration',\n    'net',\n    'softmmu',\n    'ui',\n    'hw/remote',\n  ]\nendif\nif have_system or have_user\n  trace_events_subdirs += [\n    'accel/tcg',\n    'hw/core',\n    'target/arm',\n    'target/arm/hvf',\n    'target/hppa',\n    'target/i386',\n    'target/i386/kvm',\n    'target/mips/tcg',\n    'target/nios2',\n    'target/ppc',\n    'target/riscv',\n    'target/s390x',\n    'target/s390x/kvm',\n    'target/sparc',\n  ]\nendif\n\nvhost_user = not_found\nif targetos == 'linux' and have_vhost_user\n  libvhost_user = subproject('libvhost-user')\n  vhost_user = libvhost_user.get_variable('vhost_user_dep')\nendif\n\nlibvduse = not_found\nif have_libvduse\n  libvduse_proj = subproject('libvduse')\n  libvduse = libvduse_proj.get_variable('libvduse_dep')\nendif\n\n# NOTE: the trace/ subdirectory needs the qapi_trace_events variable\n# that is filled in by qapi/.\nsubdir('qapi')\nsubdir('qobject')\nsubdir('stubs')\nsubdir('trace')\nsubdir('util')\nsubdir('qom')\nsubdir('authz')\nsubdir('crypto')\nsubdir('ui')\nsubdir('hw')\n\n\nif enable_modules\n  libmodulecommon = static_library('module-common', files('module-common.c') + genh, pic: true, c_args: '-DBUILD_DSO')\n  modulecommon = declare_dependency(link_whole: libmodulecommon, compile_args: '-DBUILD_DSO')\nendif\n\nqom_ss = qom_ss.apply(config_host, strict: false)\nlibqom = static_library('qom', qom_ss.sources() + genh,\n                        dependencies: [qom_ss.dependencies()],\n                        name_suffix: 'fa')\nqom = declare_dependency(link_whole: libqom)\n\nevent_loop_base = files('event-loop-base.c')\nevent_loop_base = static_library('event-loop-base', sources: event_loop_base + genh,\n                                 build_by_default: true)\nevent_loop_base = declare_dependency(link_whole: event_loop_base,\n                                     dependencies: [qom])\n\nstub_ss = stub_ss.apply(config_all, strict: false)\n\nutil_ss.add_all(trace_ss)\nutil_ss = util_ss.apply(config_all, strict: false)\nlibqemuutil = static_library('qemuutil',\n                             sources: util_ss.sources() + stub_ss.sources() + genh,\n                             dependencies: [util_ss.dependencies(), libm, threads, glib, socket, malloc, pixman])\nqemuutil = declare_dependency(link_with: libqemuutil,\n                              sources: genh + version_res,\n                              dependencies: [event_loop_base])\n\nif have_system or have_user\n  decodetree = generator(find_program('scripts/decodetree.py'),\n                         output: 'decode-@BASENAME@.c.inc',\n                         arguments: ['@INPUT@', '@EXTRA_ARGS@', '-o', '@OUTPUT@'])\n  subdir('libdecnumber')\n  subdir('target')\nendif\n\nsubdir('audio')\nsubdir('io')\nsubdir('chardev')\nsubdir('fsdev')\nsubdir('dump')\n\nif have_block\n  block_ss.add(files(\n    'block.c',\n    'blockjob.c',\n    'job.c',\n    'qemu-io-cmds.c',\n  ))\n  if config_host_data.get('CONFIG_REPLICATION')\n    block_ss.add(files('replication.c'))\n  endif\n\n  subdir('nbd')\n  subdir('scsi')\n  subdir('block')\n\n  blockdev_ss.add(files(\n    'blockdev.c',\n    'blockdev-nbd.c',\n    'iothread.c',\n    'job-qmp.c',\n  ), gnutls)\n\n  # os-posix.c contains POSIX-specific functions used by qemu-storage-daemon,\n  # os-win32.c does not\n  blockdev_ss.add(when: 'CONFIG_POSIX', if_true: files('os-posix.c'))\n  softmmu_ss.add(when: 'CONFIG_WIN32', if_true: [files('os-win32.c')])\nendif\n\ncommon_ss.add(files('cpus-common.c'))\n\nsubdir('softmmu')\n\ncommon_ss.add(capstone)\nspecific_ss.add(files('cpu.c', 'disas.c', 'gdbstub.c'), capstone)\n\n# Work around a gcc bug/misfeature wherein constant propagation looks\n# through an alias:\n#   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99696\n# to guess that a const variable is always zero.  Without lto, this is\n# impossible, as the alias is restricted to page-vary-common.c.  Indeed,\n# without lto, not even the alias is required -- we simply use different\n# declarations in different compilation units.\npagevary = files('page-vary-common.c')\nif get_option('b_lto')\n  pagevary_flags = ['-fno-lto']\n  if get_option('cfi')\n    pagevary_flags += '-fno-sanitize=cfi-icall'\n  endif\n  pagevary = static_library('page-vary-common', sources: pagevary + genh,\n                            c_args: pagevary_flags)\n  pagevary = declare_dependency(link_with: pagevary)\nendif\ncommon_ss.add(pagevary)\nspecific_ss.add(files('page-vary.c'))\n\nsubdir('backends')\nsubdir('disas')\nsubdir('migration')\nsubdir('monitor')\nsubdir('net')\nsubdir('replay')\nsubdir('semihosting')\nsubdir('tcg')\nsubdir('fpu')\nsubdir('accel')\nsubdir('plugins')\nsubdir('ebpf')\n\ncommon_user_inc = []\n\nsubdir('common-user')\nsubdir('bsd-user')\nsubdir('linux-user')\n\n# needed for fuzzing binaries\nsubdir('tests/qtest/libqos')\nsubdir('tests/qtest/fuzz')\n\n# accel modules\ntcg_real_module_ss = ss.source_set()\ntcg_real_module_ss.add_all(when: 'CONFIG_TCG_MODULAR', if_true: tcg_module_ss)\nspecific_ss.add_all(when: 'CONFIG_TCG_BUILTIN', if_true: tcg_module_ss)\ntarget_modules += { 'accel' : { 'qtest': qtest_module_ss,\n                                'tcg': tcg_real_module_ss }}\n\n########################\n# Library dependencies #\n########################\n\nmodinfo_collect = find_program('scripts/modinfo-collect.py')\nmodinfo_generate = find_program('scripts/modinfo-generate.py')\nmodinfo_files = []\n\nblock_mods = []\nsoftmmu_mods = []\nforeach d, list : modules\n  foreach m, module_ss : list\n    if enable_modules and targetos != 'windows'\n      module_ss = module_ss.apply(config_all, strict: false)\n      sl = static_library(d + '-' + m, [genh, module_ss.sources()],\n                          dependencies: [modulecommon, module_ss.dependencies()], pic: true)\n      if d == 'block'\n        block_mods += sl\n      else\n        softmmu_mods += sl\n      endif\n      if module_ss.sources() != []\n        # FIXME: Should use sl.extract_all_objects(recursive: true) as\n        # input. Sources can be used multiple times but objects are\n        # unique when it comes to lookup in compile_commands.json.\n        # Depnds on a mesion version with\n        # https://github.com/mesonbuild/meson/pull/8900\n        modinfo_files += custom_target(d + '-' + m + '.modinfo',\n                                       output: d + '-' + m + '.modinfo',\n                                       input: module_ss.sources() + genh,\n                                       capture: true,\n                                       command: [modinfo_collect, module_ss.sources()])\n      endif\n    else\n      if d == 'block'\n        block_ss.add_all(module_ss)\n      else\n        softmmu_ss.add_all(module_ss)\n      endif\n    endif\n  endforeach\nendforeach\n\nforeach d, list : target_modules\n  foreach m, module_ss : list\n    if enable_modules and targetos != 'windows'\n      foreach target : target_dirs\n        if target.endswith('-softmmu')\n          config_target = config_target_mak[target]\n          config_target += config_host\n          target_inc = [include_directories('target' / config_target['TARGET_BASE_ARCH'])]\n          c_args = ['-DNEED_CPU_H',\n                    '-DCONFIG_TARGET=\"@0@-config-target.h\"'.format(target),\n                    '-DCONFIG_DEVICES=\"@0@-config-devices.h\"'.format(target)]\n          target_module_ss = module_ss.apply(config_target, strict: false)\n          if target_module_ss.sources() != []\n            module_name = d + '-' + m + '-' + config_target['TARGET_NAME']\n            sl = static_library(module_name,\n                                [genh, target_module_ss.sources()],\n                                dependencies: [modulecommon, target_module_ss.dependencies()],\n                                include_directories: target_inc,\n                                c_args: c_args,\n                                pic: true)\n            softmmu_mods += sl\n            # FIXME: Should use sl.extract_all_objects(recursive: true) too.\n            modinfo_files += custom_target(module_name + '.modinfo',\n                                           output: module_name + '.modinfo',\n                                           input: target_module_ss.sources() + genh,\n                                           capture: true,\n                                           command: [modinfo_collect, '--target', target, target_module_ss.sources()])\n          endif\n        endif\n      endforeach\n    else\n      specific_ss.add_all(module_ss)\n    endif\n  endforeach\nendforeach\n\nif enable_modules\n  foreach target : target_dirs\n    if target.endswith('-softmmu')\n      config_target = config_target_mak[target]\n      config_devices_mak = target + '-config-devices.mak'\n      modinfo_src = custom_target('modinfo-' + target + '.c',\n                                  output: 'modinfo-' + target + '.c',\n                                  input: modinfo_files,\n                                  command: [modinfo_generate, '--devices', config_devices_mak, '@INPUT@'],\n                                  capture: true)\n\n      modinfo_lib = static_library('modinfo-' + target + '.c', modinfo_src)\n      modinfo_dep = declare_dependency(link_with: modinfo_lib)\n\n      arch = config_target['TARGET_NAME'] == 'sparc64' ? 'sparc64' : config_target['TARGET_BASE_ARCH']\n      hw_arch[arch].add(modinfo_dep)\n    endif\n  endforeach\nendif\n\nnm = find_program('nm')\nundefsym = find_program('scripts/undefsym.py')\nblock_syms = custom_target('block.syms', output: 'block.syms',\n                             input: [libqemuutil, block_mods],\n                             capture: true,\n                             command: [undefsym, nm, '@INPUT@'])\nqemu_syms = custom_target('qemu.syms', output: 'qemu.syms',\n                             input: [libqemuutil, softmmu_mods],\n                             capture: true,\n                             command: [undefsym, nm, '@INPUT@'])\n\nauthz_ss = authz_ss.apply(config_host, strict: false)\nlibauthz = static_library('authz', authz_ss.sources() + genh,\n                          dependencies: [authz_ss.dependencies()],\n                          name_suffix: 'fa',\n                          build_by_default: false)\n\nauthz = declare_dependency(link_whole: libauthz,\n                           dependencies: qom)\n\ncrypto_ss = crypto_ss.apply(config_host, strict: false)\nlibcrypto = static_library('crypto', crypto_ss.sources() + genh,\n                           dependencies: [crypto_ss.dependencies()],\n                           name_suffix: 'fa',\n                           build_by_default: false)\n\ncrypto = declare_dependency(link_whole: libcrypto,\n                            dependencies: [authz, qom])\n\nio_ss = io_ss.apply(config_host, strict: false)\nlibio = static_library('io', io_ss.sources() + genh,\n                       dependencies: [io_ss.dependencies()],\n                       link_with: libqemuutil,\n                       name_suffix: 'fa',\n                       build_by_default: false)\n\nio = declare_dependency(link_whole: libio, dependencies: [crypto, qom])\n\nlibmigration = static_library('migration', sources: migration_files + genh,\n                              name_suffix: 'fa',\n                              build_by_default: false)\nmigration = declare_dependency(link_with: libmigration,\n                               dependencies: [zlib, qom, io])\nsoftmmu_ss.add(migration)\n\nblock_ss = block_ss.apply(config_host, strict: false)\nlibblock = static_library('block', block_ss.sources() + genh,\n                          dependencies: block_ss.dependencies(),\n                          link_depends: block_syms,\n                          name_suffix: 'fa',\n                          build_by_default: false)\n\nblock = declare_dependency(link_whole: [libblock],\n                           link_args: '@block.syms',\n                           dependencies: [crypto, io])\n\nblockdev_ss = blockdev_ss.apply(config_host, strict: false)\nlibblockdev = static_library('blockdev', blockdev_ss.sources() + genh,\n                             dependencies: blockdev_ss.dependencies(),\n                             name_suffix: 'fa',\n                             build_by_default: false)\n\nblockdev = declare_dependency(link_whole: [libblockdev],\n                              dependencies: [block, event_loop_base])\n\nqmp_ss = qmp_ss.apply(config_host, strict: false)\nlibqmp = static_library('qmp', qmp_ss.sources() + genh,\n                        dependencies: qmp_ss.dependencies(),\n                        name_suffix: 'fa',\n                        build_by_default: false)\n\nqmp = declare_dependency(link_whole: [libqmp])\n\nlibchardev = static_library('chardev', chardev_ss.sources() + genh,\n                            name_suffix: 'fa',\n                            dependencies: chardev_ss.dependencies(),\n                            build_by_default: false)\n\nchardev = declare_dependency(link_whole: libchardev)\n\nhwcore_ss = hwcore_ss.apply(config_host, strict: false)\nlibhwcore = static_library('hwcore', sources: hwcore_ss.sources() + genh,\n                           name_suffix: 'fa',\n                           build_by_default: false)\nhwcore = declare_dependency(link_whole: libhwcore)\ncommon_ss.add(hwcore)\n\n###########\n# Targets #\n###########\n\nemulator_modules = []\nforeach m : block_mods + softmmu_mods\n  emulator_modules += shared_module(m.name(),\n                build_by_default: true,\n                name_prefix: '',\n                link_whole: m,\n                install: true,\n                install_dir: qemu_moddir)\nendforeach\nif emulator_modules.length() > 0\n  alias_target('modules', emulator_modules)\nendif\n\nsoftmmu_ss.add(authz, blockdev, chardev, crypto, io, qmp)\ncommon_ss.add(qom, qemuutil)\n\ncommon_ss.add_all(when: 'CONFIG_SOFTMMU', if_true: [softmmu_ss])\ncommon_ss.add_all(when: 'CONFIG_USER_ONLY', if_true: user_ss)\n\ncommon_all = common_ss.apply(config_all, strict: false)\ncommon_all = static_library('common',\n                            build_by_default: false,\n                            sources: common_all.sources() + genh,\n                            include_directories: common_user_inc,\n                            implicit_include_directories: false,\n                            dependencies: common_all.dependencies(),\n                            name_suffix: 'fa')\n\nfeature_to_c = find_program('scripts/feature_to_c.sh')\n\nif targetos == 'darwin'\n  entitlement = find_program('scripts/entitlement.sh')\nendif\n\nemulators = {}\nforeach target : target_dirs\n  config_target = config_target_mak[target]\n  target_name = config_target['TARGET_NAME']\n  target_base_arch = config_target['TARGET_BASE_ARCH']\n  arch_srcs = [config_target_h[target]]\n  arch_deps = []\n  c_args = ['-DNEED_CPU_H',\n            '-DCONFIG_TARGET=\"@0@-config-target.h\"'.format(target),\n            '-DCONFIG_DEVICES=\"@0@-config-devices.h\"'.format(target)]\n  link_args = emulator_link_args\n\n  config_target += config_host\n  target_inc = [include_directories('target' / config_target['TARGET_BASE_ARCH'])]\n  if targetos == 'linux'\n    target_inc += include_directories('linux-headers', is_system: true)\n  endif\n  if target.endswith('-softmmu')\n    qemu_target_name = 'qemu-system-' + target_name\n    target_type='system'\n    t = target_softmmu_arch[target_base_arch].apply(config_target, strict: false)\n    arch_srcs += t.sources()\n    arch_deps += t.dependencies()\n\n    hw_dir = target_name == 'sparc64' ? 'sparc64' : target_base_arch\n    hw = hw_arch[hw_dir].apply(config_target, strict: false)\n    arch_srcs += hw.sources()\n    arch_deps += hw.dependencies()\n\n    arch_srcs += config_devices_h[target]\n    link_args += ['@block.syms', '@qemu.syms']\n  else\n    abi = config_target['TARGET_ABI_DIR']\n    target_type='user'\n    target_inc += common_user_inc\n    qemu_target_name = 'qemu-' + target_name\n    if target_base_arch in target_user_arch\n      t = target_user_arch[target_base_arch].apply(config_target, strict: false)\n      arch_srcs += t.sources()\n      arch_deps += t.dependencies()\n    endif\n    if 'CONFIG_LINUX_USER' in config_target\n      base_dir = 'linux-user'\n    endif\n    if 'CONFIG_BSD_USER' in config_target\n      base_dir = 'bsd-user'\n      target_inc += include_directories('bsd-user/' / targetos)\n      target_inc += include_directories('bsd-user/host/' / host_arch)\n      dir = base_dir / abi\n      arch_srcs += files(dir / 'signal.c', dir / 'target_arch_cpu.c')\n    endif\n    target_inc += include_directories(\n      base_dir,\n      base_dir / abi,\n    )\n    if 'CONFIG_LINUX_USER' in config_target\n      dir = base_dir / abi\n      arch_srcs += files(dir / 'signal.c', dir / 'cpu_loop.c')\n      if config_target.has_key('TARGET_SYSTBL_ABI')\n        arch_srcs += \\\n          syscall_nr_generators[abi].process(base_dir / abi / config_target['TARGET_SYSTBL'],\n                                             extra_args : config_target['TARGET_SYSTBL_ABI'])\n      endif\n    endif\n  endif\n\n  if 'TARGET_XML_FILES' in config_target\n    gdbstub_xml = custom_target(target + '-gdbstub-xml.c',\n                                output: target + '-gdbstub-xml.c',\n                                input: files(config_target['TARGET_XML_FILES'].split()),\n                                command: [feature_to_c, '@INPUT@'],\n                                capture: true)\n    arch_srcs += gdbstub_xml\n  endif\n\n  t = target_arch[target_base_arch].apply(config_target, strict: false)\n  arch_srcs += t.sources()\n  arch_deps += t.dependencies()\n\n  target_common = common_ss.apply(config_target, strict: false)\n  objects = common_all.extract_objects(target_common.sources())\n  deps = target_common.dependencies()\n\n  target_specific = specific_ss.apply(config_target, strict: false)\n  arch_srcs += target_specific.sources()\n  arch_deps += target_specific.dependencies()\n\n  lib = static_library('qemu-' + target,\n                 sources: arch_srcs + genh,\n                 dependencies: arch_deps,\n                 objects: objects,\n                 include_directories: target_inc,\n                 c_args: c_args,\n                 build_by_default: false,\n                 name_suffix: 'fa')\n\n  if target.endswith('-softmmu')\n    execs = [{\n      'name': 'qemu-system-' + target_name,\n      'win_subsystem': 'console',\n      'sources': files('softmmu/main.c'),\n      'dependencies': []\n    }]\n    if targetos == 'windows' and (sdl.found() or gtk.found())\n      execs += [{\n        'name': 'qemu-system-' + target_name + 'w',\n        'win_subsystem': 'windows',\n        'sources': files('softmmu/main.c'),\n        'dependencies': []\n      }]\n    endif\n    if get_option('fuzzing')\n      specific_fuzz = specific_fuzz_ss.apply(config_target, strict: false)\n      execs += [{\n        'name': 'qemu-fuzz-' + target_name,\n        'win_subsystem': 'console',\n        'sources': specific_fuzz.sources(),\n        'dependencies': specific_fuzz.dependencies(),\n      }]\n    endif\n  else\n    execs = [{\n      'name': 'qemu-' + target_name,\n      'win_subsystem': 'console',\n      'sources': [],\n      'dependencies': []\n    }]\n  endif\n  foreach exe: execs\n    exe_name = exe['name']\n    if targetos == 'darwin'\n      exe_name += '-unsigned'\n    endif\n\n    emulator = executable(exe_name, exe['sources'],\n               install: true,\n               c_args: c_args,\n               dependencies: arch_deps + deps + exe['dependencies'],\n               objects: lib.extract_all_objects(recursive: true),\n               link_language: link_language,\n               link_depends: [block_syms, qemu_syms] + exe.get('link_depends', []),\n               link_args: link_args,\n               win_subsystem: exe['win_subsystem'])\n\n    if targetos == 'darwin'\n      icon = 'pc-bios/qemu.rsrc'\n      build_input = [emulator, files(icon)]\n      install_input = [\n        get_option('bindir') / exe_name,\n        meson.current_source_dir() / icon\n      ]\n      if 'CONFIG_HVF' in config_target\n        entitlements = 'accel/hvf/entitlements.plist'\n        build_input += files(entitlements)\n        install_input += meson.current_source_dir() / entitlements\n      endif\n\n      emulators += {exe['name'] : custom_target(exe['name'],\n                   input: build_input,\n                   output: exe['name'],\n                   command: [entitlement, '@OUTPUT@', '@INPUT@'])\n      }\n\n      meson.add_install_script(entitlement, '--install',\n                               get_option('bindir') / exe['name'],\n                               install_input)\n    else\n      emulators += {exe['name']: emulator}\n    endif\n\n    if stap.found()\n      foreach stp: [\n        {'ext': '.stp-build', 'fmt': 'stap', 'bin': meson.current_build_dir() / exe['name'], 'install': false},\n        {'ext': '.stp', 'fmt': 'stap', 'bin': get_option('prefix') / get_option('bindir') / exe['name'], 'install': true},\n        {'ext': '-simpletrace.stp', 'fmt': 'simpletrace-stap', 'bin': '', 'install': true},\n        {'ext': '-log.stp', 'fmt': 'log-stap', 'bin': '', 'install': true},\n      ]\n        custom_target(exe['name'] + stp['ext'],\n                      input: trace_events_all,\n                      output: exe['name'] + stp['ext'],\n                      install: stp['install'],\n                      install_dir: get_option('datadir') / 'systemtap/tapset',\n                      command: [\n                        tracetool, '--group=all', '--format=' + stp['fmt'],\n                        '--binary=' + stp['bin'],\n                        '--target-name=' + target_name,\n                        '--target-type=' + target_type,\n                        '--probe-prefix=qemu.' + target_type + '.' + target_name,\n                        '@INPUT@', '@OUTPUT@'\n                      ],\n                      depend_files: tracetool_depends)\n      endforeach\n    endif\n  endforeach\nendforeach\n\n# Other build targets\n\nif 'CONFIG_PLUGIN' in config_host\n  install_headers('include/qemu/qemu-plugin.h')\nendif\n\nsubdir('qga')\n\n# Don't build qemu-keymap if xkbcommon is not explicitly enabled\n# when we don't build tools or system\nif xkbcommon.found()\n  # used for the update-keymaps target, so include rules even if !have_tools\n  qemu_keymap = executable('qemu-keymap', files('qemu-keymap.c', 'ui/input-keymap.c') + genh,\n                           dependencies: [qemuutil, xkbcommon], install: have_tools)\nendif\n\nif have_tools\n  qemu_img = executable('qemu-img', [files('qemu-img.c'), hxdep],\n             dependencies: [authz, block, crypto, io, qom, qemuutil], install: true)\n  qemu_io = executable('qemu-io', files('qemu-io.c'),\n             dependencies: [block, qemuutil], install: true)\n  qemu_nbd = executable('qemu-nbd', files('qemu-nbd.c'),\n               dependencies: [blockdev, qemuutil, gnutls, selinux],\n               install: true)\n\n  subdir('storage-daemon')\n  subdir('contrib/rdmacm-mux')\n  subdir('contrib/elf2dmp')\n\n  executable('qemu-edid', files('qemu-edid.c', 'hw/display/edid-generate.c'),\n             dependencies: qemuutil,\n             install: true)\n\n  if have_vhost_user\n    subdir('contrib/vhost-user-blk')\n    subdir('contrib/vhost-user-gpu')\n    subdir('contrib/vhost-user-input')\n    subdir('contrib/vhost-user-scsi')\n  endif\n\n  if targetos == 'linux'\n    executable('qemu-bridge-helper', files('qemu-bridge-helper.c'),\n               dependencies: [qemuutil, libcap_ng],\n               install: true,\n               install_dir: get_option('libexecdir'))\n\n    executable('qemu-pr-helper', files('scsi/qemu-pr-helper.c', 'scsi/utils.c'),\n               dependencies: [authz, crypto, io, qom, qemuutil,\n                              libcap_ng, mpathpersist],\n               install: true)\n  endif\n\n  if have_ivshmem\n    subdir('contrib/ivshmem-client')\n    subdir('contrib/ivshmem-server')\n  endif\nendif\n\nsubdir('scripts')\nsubdir('tools')\nsubdir('pc-bios')\nsubdir('docs')\nsubdir('tests')\nif gtk.found()\n  subdir('po')\nendif\n\nif host_machine.system() == 'windows'\n  nsis_cmd = [\n    find_program('scripts/nsis.py'),\n    '@OUTPUT@',\n    get_option('prefix'),\n    meson.current_source_dir(),\n    host_machine.cpu(),\n    '--',\n    '-DDISPLAYVERSION=' + meson.project_version(),\n  ]\n  if build_docs\n    nsis_cmd += '-DCONFIG_DOCUMENTATION=y'\n  endif\n  if gtk.found()\n    nsis_cmd += '-DCONFIG_GTK=y'\n  endif\n\n  nsis = custom_target('nsis',\n                       output: 'qemu-setup-' + meson.project_version() + '.exe',\n                       input: files('qemu.nsi'),\n                       build_always_stale: true,\n                       command: nsis_cmd + ['@INPUT@'])\n  alias_target('installer', nsis)\nendif\n\n#########################\n# Configuration summary #\n#########################\n\n# Directories\nsummary_info = {}\nsummary_info += {'Install prefix':    get_option('prefix')}\nsummary_info += {'BIOS directory':    qemu_datadir}\npathsep = targetos == 'windows' ? ';' : ':'\nsummary_info += {'firmware path':     pathsep.join(get_option('qemu_firmwarepath'))}\nsummary_info += {'binary directory':  get_option('prefix') / get_option('bindir')}\nsummary_info += {'library directory': get_option('prefix') / get_option('libdir')}\nsummary_info += {'module directory':  qemu_moddir}\nsummary_info += {'libexec directory': get_option('prefix') / get_option('libexecdir')}\nsummary_info += {'include directory': get_option('prefix') / get_option('includedir')}\nsummary_info += {'config directory':  get_option('prefix') / get_option('sysconfdir')}\nif targetos != 'windows'\n  summary_info += {'local state directory': get_option('prefix') / get_option('localstatedir')}\n  summary_info += {'Manual directory':      get_option('prefix') / get_option('mandir')}\nelse\n  summary_info += {'local state directory': 'queried at runtime'}\nendif\nsummary_info += {'Doc directory':     get_option('prefix') / get_option('docdir')}\nsummary_info += {'Build directory':   meson.current_build_dir()}\nsummary_info += {'Source path':       meson.current_source_dir()}\nsummary_info += {'GIT submodules':    config_host['GIT_SUBMODULES']}\nsummary(summary_info, bool_yn: true, section: 'Directories')\n\n# Host binaries\nsummary_info = {}\nsummary_info += {'git':               config_host['GIT']}\nsummary_info += {'make':              config_host['MAKE']}\nsummary_info += {'python':            '@0@ (version: @1@)'.format(python.full_path(), python.language_version())}\nsummary_info += {'sphinx-build':      sphinx_build}\nif config_host.has_key('HAVE_GDB_BIN')\n  summary_info += {'gdb':             config_host['HAVE_GDB_BIN']}\nendif\nsummary_info += {'iasl':              iasl}\nsummary_info += {'genisoimage':       config_host['GENISOIMAGE']}\nif targetos == 'windows' and have_ga\n  summary_info += {'wixl':            wixl}\nendif\nif slirp_opt != 'disabled' and have_system\n  summary_info += {'smbd':            have_slirp_smbd ? smbd_path : false}\nendif\nsummary(summary_info, bool_yn: true, section: 'Host binaries')\n\n# Configurable features\nsummary_info = {}\nsummary_info += {'Documentation':     build_docs}\nsummary_info += {'system-mode emulation': have_system}\nsummary_info += {'user-mode emulation': have_user}\nsummary_info += {'block layer':       have_block}\nsummary_info += {'Install blobs':     get_option('install_blobs')}\nsummary_info += {'module support':    config_host.has_key('CONFIG_MODULES')}\nif config_host.has_key('CONFIG_MODULES')\n  summary_info += {'alternative module path': get_option('module_upgrades')}\nendif\nsummary_info += {'fuzzing support':   get_option('fuzzing')}\nif have_system\n  summary_info += {'Audio drivers':     ' '.join(audio_drivers_selected)}\nendif\nsummary_info += {'Trace backends':    ','.join(get_option('trace_backends'))}\nif 'simple' in get_option('trace_backends')\n  summary_info += {'Trace output file': get_option('trace_file') + '-<pid>'}\nendif\nsummary_info += {'D-Bus display':     dbus_display}\nsummary_info += {'QOM debugging':     get_option('qom_cast_debug')}\nsummary_info += {'vhost-kernel support': have_vhost_kernel}\nsummary_info += {'vhost-net support': have_vhost_net}\nsummary_info += {'vhost-user support': have_vhost_user}\nsummary_info += {'vhost-user-crypto support': have_vhost_user_crypto}\nsummary_info += {'vhost-user-blk server support': have_vhost_user_blk_server}\nsummary_info += {'vhost-vdpa support': have_vhost_vdpa}\nsummary_info += {'build guest agent': have_ga}\nsummary(summary_info, bool_yn: true, section: 'Configurable features')\n\n# Compilation information\nsummary_info = {}\nsummary_info += {'host CPU':          cpu}\nsummary_info += {'host endianness':   build_machine.endian()}\nsummary_info += {'C compiler':        ' '.join(meson.get_compiler('c').cmd_array())}\nsummary_info += {'Host C compiler':   ' '.join(meson.get_compiler('c', native: true).cmd_array())}\nif link_language == 'cpp'\n  summary_info += {'C++ compiler':    ' '.join(meson.get_compiler('cpp').cmd_array())}\nelse\n  summary_info += {'C++ compiler':      false}\nendif\nif targetos == 'darwin'\n  summary_info += {'Objective-C compiler': ' '.join(meson.get_compiler('objc').cmd_array())}\nendif\nsummary_info += {'CFLAGS':            ' '.join(get_option('c_args')\n                                               + ['-O' + get_option('optimization')]\n                                               + (get_option('debug') ? ['-g'] : []))}\nif link_language == 'cpp'\n  summary_info += {'CXXFLAGS':        ' '.join(get_option('cpp_args')\n                                               + ['-O' + get_option('optimization')]\n                                               + (get_option('debug') ? ['-g'] : []))}\nendif\nif targetos == 'darwin'\n  summary_info += {'OBJCFLAGS':       ' '.join(get_option('objc_args')\n                                               + ['-O' + get_option('optimization')]\n                                               + (get_option('debug') ? ['-g'] : []))}\nendif\nlink_args = get_option(link_language + '_link_args')\nif link_args.length() > 0\n  summary_info += {'LDFLAGS':         ' '.join(link_args)}\nendif\nsummary_info += {'QEMU_CFLAGS':       ' '.join(qemu_cflags)}\nsummary_info += {'QEMU_CXXFLAGS':     ' '.join(qemu_cxxflags)}\nsummary_info += {'QEMU_OBJCFLAGS':    ' '.join(qemu_objcflags)}\nsummary_info += {'QEMU_LDFLAGS':      ' '.join(qemu_ldflags)}\nsummary_info += {'profiler':          get_option('profiler')}\nsummary_info += {'link-time optimization (LTO)': get_option('b_lto')}\nsummary_info += {'PIE':               get_option('b_pie')}\nsummary_info += {'static build':      config_host.has_key('CONFIG_STATIC')}\nsummary_info += {'malloc trim support': has_malloc_trim}\nsummary_info += {'membarrier':        have_membarrier}\nsummary_info += {'debug stack usage': get_option('debug_stack_usage')}\nsummary_info += {'mutex debugging':   get_option('debug_mutex')}\nsummary_info += {'memory allocator':  get_option('malloc')}\nsummary_info += {'avx2 optimization': config_host_data.get('CONFIG_AVX2_OPT')}\nsummary_info += {'avx512f optimization': config_host_data.get('CONFIG_AVX512F_OPT')}\nsummary_info += {'gprof enabled':     get_option('gprof')}\nsummary_info += {'gcov':              get_option('b_coverage')}\nsummary_info += {'thread sanitizer':  config_host.has_key('CONFIG_TSAN')}\nsummary_info += {'CFI support':       get_option('cfi')}\nif get_option('cfi')\n  summary_info += {'CFI debug support': get_option('cfi_debug')}\nendif\nsummary_info += {'strip binaries':    get_option('strip')}\nsummary_info += {'sparse':            sparse}\nsummary_info += {'mingw32 support':   targetos == 'windows'}\nsummary(summary_info, bool_yn: true, section: 'Compilation')\n\n# snarf the cross-compilation information for tests\nsummary_info = {}\nhave_cross = false\nforeach target: target_dirs\n  tcg_mak = meson.current_build_dir() / 'tests/tcg' / 'config-' + target + '.mak'\n  if fs.exists(tcg_mak)\n    config_cross_tcg = keyval.load(tcg_mak)\n    if 'CC' in config_cross_tcg\n      summary_info += {config_cross_tcg['TARGET_NAME']: config_cross_tcg['CC']}\n      have_cross = true\n    endif\n  endif\nendforeach\nif have_cross\n  summary(summary_info, bool_yn: true, section: 'Cross compilers')\nendif\n\n# Targets and accelerators\nsummary_info = {}\nif have_system\n  summary_info += {'KVM support':       config_all.has_key('CONFIG_KVM')}\n  summary_info += {'HAX support':       config_all.has_key('CONFIG_HAX')}\n  summary_info += {'HVF support':       config_all.has_key('CONFIG_HVF')}\n  summary_info += {'WHPX support':      config_all.has_key('CONFIG_WHPX')}\n  summary_info += {'NVMM support':      config_all.has_key('CONFIG_NVMM')}\n  summary_info += {'Xen support':       xen.found()}\n  if xen.found()\n    summary_info += {'xen ctrl version':  xen.version()}\n  endif\nendif\nsummary_info += {'TCG support':       config_all.has_key('CONFIG_TCG')}\nif config_all.has_key('CONFIG_TCG')\n  if get_option('tcg_interpreter')\n    summary_info += {'TCG backend':   'TCI (TCG with bytecode interpreter, slow)'}\n  else\n    summary_info += {'TCG backend':   'native (@0@)'.format(cpu)}\n  endif\n  summary_info += {'TCG plugins': config_host.has_key('CONFIG_PLUGIN')}\n  summary_info += {'TCG debug enabled': config_host.has_key('CONFIG_DEBUG_TCG')}\nendif\nsummary_info += {'target list':       ' '.join(target_dirs)}\nif have_system\n  summary_info += {'default devices':   get_option('default_devices')}\n  summary_info += {'out of process emulation': multiprocess_allowed}\n  summary_info += {'vfio-user server': vfio_user_server_allowed}\nendif\nsummary(summary_info, bool_yn: true, section: 'Targets and accelerators')\n\n# Block layer\nsummary_info = {}\nsummary_info += {'coroutine backend': config_host['CONFIG_COROUTINE_BACKEND']}\nsummary_info += {'coroutine pool':    have_coroutine_pool}\nif have_block\n  summary_info += {'Block whitelist (rw)': get_option('block_drv_rw_whitelist')}\n  summary_info += {'Block whitelist (ro)': get_option('block_drv_ro_whitelist')}\n  summary_info += {'Use block whitelist in tools': get_option('block_drv_whitelist_in_tools')}\n  summary_info += {'VirtFS support':    have_virtfs}\n  summary_info += {'build virtiofs daemon': have_virtiofsd}\n  summary_info += {'Live block migration': config_host_data.get('CONFIG_LIVE_BLOCK_MIGRATION')}\n  summary_info += {'replication support': config_host_data.get('CONFIG_REPLICATION')}\n  summary_info += {'bochs support':     get_option('bochs').allowed()}\n  summary_info += {'cloop support':     get_option('cloop').allowed()}\n  summary_info += {'dmg support':       get_option('dmg').allowed()}\n  summary_info += {'qcow v1 support':   get_option('qcow1').allowed()}\n  summary_info += {'vdi support':       get_option('vdi').allowed()}\n  summary_info += {'vvfat support':     get_option('vvfat').allowed()}\n  summary_info += {'qed support':       get_option('qed').allowed()}\n  summary_info += {'parallels support': get_option('parallels').allowed()}\n  summary_info += {'FUSE exports':      fuse}\n  summary_info += {'VDUSE block exports': have_vduse_blk_export}\nendif\nsummary(summary_info, bool_yn: true, section: 'Block layer support')\n\n# Crypto\nsummary_info = {}\nsummary_info += {'TLS priority':      get_option('tls_priority')}\nsummary_info += {'GNUTLS support':    gnutls}\nif gnutls.found()\n  summary_info += {'  GNUTLS crypto':   gnutls_crypto.found()}\nendif\nsummary_info += {'libgcrypt':         gcrypt}\nsummary_info += {'nettle':            nettle}\nif nettle.found()\n   summary_info += {'  XTS':             xts != 'private'}\nendif\nsummary_info += {'AF_ALG support':    have_afalg}\nsummary_info += {'rng-none':          get_option('rng_none')}\nsummary_info += {'Linux keyring':     have_keyring}\nsummary(summary_info, bool_yn: true, section: 'Crypto')\n\n# Libraries\nsummary_info = {}\nif targetos == 'darwin'\n  summary_info += {'Cocoa support':           cocoa}\n  summary_info += {'vmnet.framework support': vmnet}\nendif\nsummary_info += {'SDL support':       sdl}\nsummary_info += {'SDL image support': sdl_image}\nsummary_info += {'GTK support':       gtk}\nsummary_info += {'pixman':            pixman}\nsummary_info += {'VTE support':       vte}\nsummary_info += {'slirp support':     slirp_opt == 'internal' ? slirp_opt : slirp}\nsummary_info += {'libtasn1':          tasn1}\nsummary_info += {'PAM':               pam}\nsummary_info += {'iconv support':     iconv}\nsummary_info += {'curses support':    curses}\nsummary_info += {'virgl support':     virgl}\nsummary_info += {'curl support':      curl}\nsummary_info += {'Multipath support': mpathpersist}\nsummary_info += {'PNG support':       png}\nsummary_info += {'VNC support':       vnc}\nif vnc.found()\n  summary_info += {'VNC SASL support':  sasl}\n  summary_info += {'VNC JPEG support':  jpeg}\nendif\nif targetos not in ['darwin', 'haiku', 'windows']\n  summary_info += {'OSS support':     oss}\nelif targetos == 'darwin'\n  summary_info += {'CoreAudio support': coreaudio}\nelif targetos == 'windows'\n  summary_info += {'DirectSound support': dsound}\nendif\nif targetos == 'linux'\n  summary_info += {'ALSA support':    alsa}\n  summary_info += {'PulseAudio support': pulse}\nendif\nsummary_info += {'JACK support':      jack}\nsummary_info += {'brlapi support':    brlapi}\nsummary_info += {'vde support':       vde}\nsummary_info += {'netmap support':    have_netmap}\nsummary_info += {'l2tpv3 support':    have_l2tpv3}\nsummary_info += {'Linux AIO support': libaio}\nsummary_info += {'Linux io_uring support': linux_io_uring}\nsummary_info += {'ATTR/XATTR support': libattr}\nsummary_info += {'RDMA support':      rdma}\nsummary_info += {'PVRDMA support':    have_pvrdma}\nsummary_info += {'fdt support':       fdt_opt == 'disabled' ? false : fdt_opt}\nsummary_info += {'libcap-ng support': libcap_ng}\nsummary_info += {'bpf support':       libbpf}\nsummary_info += {'spice protocol support': spice_protocol}\nif spice_protocol.found()\n  summary_info += {'  spice server support': spice}\nendif\nsummary_info += {'rbd support':       rbd}\nsummary_info += {'smartcard support': cacard}\nsummary_info += {'U2F support':       u2f}\nsummary_info += {'libusb':            libusb}\nsummary_info += {'usb net redir':     usbredir}\nsummary_info += {'OpenGL support (epoxy)': opengl}\nsummary_info += {'GBM':               gbm}\nsummary_info += {'libiscsi support':  libiscsi}\nsummary_info += {'libnfs support':    libnfs}\nif targetos == 'windows'\n  if have_ga\n    summary_info += {'QGA VSS support':   have_qga_vss}\n  endif\nendif\nsummary_info += {'seccomp support':   seccomp}\nsummary_info += {'GlusterFS support': glusterfs}\nsummary_info += {'TPM support':       have_tpm}\nsummary_info += {'libssh support':    libssh}\nsummary_info += {'lzo support':       lzo}\nsummary_info += {'snappy support':    snappy}\nsummary_info += {'bzip2 support':     libbzip2}\nsummary_info += {'lzfse support':     liblzfse}\nsummary_info += {'zstd support':      zstd}\nsummary_info += {'NUMA host support': numa}\nsummary_info += {'capstone':          capstone}\nsummary_info += {'libpmem support':   libpmem}\nsummary_info += {'libdaxctl support': libdaxctl}\nsummary_info += {'libudev':           libudev}\n# Dummy dependency, keep .found()\nsummary_info += {'FUSE lseek':        fuse_lseek.found()}\nsummary_info += {'selinux':           selinux}\nsummary(summary_info, bool_yn: true, section: 'Dependencies')\n\nif not supported_cpus.contains(cpu)\n  message()\n  warning('SUPPORT FOR THIS HOST CPU WILL GO AWAY IN FUTURE RELEASES!')\n  message()\n  message('CPU host architecture ' + cpu + ' support is not currently maintained.')\n  message('The QEMU project intends to remove support for this host CPU in')\n  message('a future release if nobody volunteers to maintain it and to')\n  message('provide a build host for our continuous integration setup.')\n  message('configure has succeeded and you can continue to build, but')\n  message('if you care about QEMU on this platform you should contact')\n  message('us upstream at qemu-devel@nongnu.org.')\nendif\n\nif not supported_oses.contains(targetos)\n  message()\n  warning('WARNING: SUPPORT FOR THIS HOST OS WILL GO AWAY IN FUTURE RELEASES!')\n  message()\n  message('Host OS ' + targetos + 'support is not currently maintained.')\n  message('The QEMU project intends to remove support for this host OS in')\n  message('a future release if nobody volunteers to maintain it and to')\n  message('provide a build host for our continuous integration setup.')\n  message('configure has succeeded and you can continue to build, but')\n  message('if you care about QEMU on this platform you should contact')\n  message('us upstream at qemu-devel@nongnu.org.')\nendif\n"
        },
        {
          "name": "meson_options.txt",
          "type": "blob",
          "size": 15.6484375,
          "content": "# These options do not correspond to a --enable/--disable-* option\n# on the configure script command line.  If you add more, list them in\n# scripts/meson-buildoptions.py's SKIP_OPTIONS constant too.\n\noption('qemu_suffix', type : 'string', value: 'qemu',\n       description: 'Suffix for QEMU data/modules/config directories (can be empty)')\noption('docdir', type : 'string', value : 'share/doc',\n       description: 'Base directory for documentation installation (can be empty)')\noption('qemu_firmwarepath', type : 'array', value : ['share/qemu-firmware'],\n       description: 'search PATH for firmware files')\noption('pkgversion', type : 'string', value : '',\n       description: 'use specified string as sub-version of the package')\noption('smbd', type : 'string', value : '',\n       description: 'Path to smbd for slirp networking')\noption('sphinx_build', type : 'string', value : '',\n       description: 'Use specified sphinx-build for building document')\noption('iasl', type : 'string', value : '',\n       description: 'Path to ACPI disassembler')\noption('tls_priority', type : 'string', value : 'NORMAL',\n       description: 'Default TLS protocol/cipher priority string')\noption('default_devices', type : 'boolean', value : true,\n       description: 'Include a default selection of devices in emulators')\noption('audio_drv_list', type: 'array', value: ['default'],\n       choices: ['alsa', 'coreaudio', 'default', 'dsound', 'jack', 'oss', 'pa', 'sdl'],\n       description: 'Set audio driver list')\noption('block_drv_rw_whitelist', type : 'string', value : '',\n       description: 'set block driver read-write whitelist (by default affects only QEMU, not tools like qemu-img)')\noption('block_drv_ro_whitelist', type : 'string', value : '',\n       description: 'set block driver read-only whitelist (by default affects only QEMU, not tools like qemu-img)')\noption('interp_prefix', type : 'string', value : '/usr/gnemul/qemu-%M',\n       description: 'where to find shared libraries etc., use %M for cpu name')\noption('fuzzing_engine', type : 'string', value : '',\n       description: 'fuzzing engine library for OSS-Fuzz')\noption('trace_file', type: 'string', value: 'trace',\n       description: 'Trace file prefix for simple backend')\n\n# Everything else can be set via --enable/--disable-* option\n# on the configure script command line.  After adding an option\n# here make sure to run \"make update-buildoptions\".\n\noption('docs', type : 'feature', value : 'auto',\n       description: 'Documentations build support')\noption('fuzzing', type : 'boolean', value: false,\n       description: 'build fuzzing targets')\noption('gettext', type : 'feature', value : 'auto',\n       description: 'Localization of the GTK+ user interface')\noption('module_upgrades', type : 'boolean', value : false,\n       description: 'try to load modules from alternate paths for upgrades')\noption('install_blobs', type : 'boolean', value : true,\n       description: 'install provided firmware blobs')\noption('sparse', type : 'feature', value : 'auto',\n       description: 'sparse checker')\noption('guest_agent', type : 'feature', value : 'auto',\n       description: 'Build QEMU Guest Agent')\noption('guest_agent_msi', type : 'feature', value : 'auto',\n       description: 'Build MSI package for the QEMU Guest Agent')\noption('tools', type : 'feature', value : 'auto',\n       description: 'build support utilities that come with QEMU')\noption('qga_vss', type : 'feature', value: 'auto',\n       description: 'build QGA VSS support (broken with MinGW)')\n\noption('malloc_trim', type : 'feature', value : 'auto',\n       description: 'enable libc malloc_trim() for memory optimization')\noption('malloc', type : 'combo', choices : ['system', 'tcmalloc', 'jemalloc'],\n       value: 'system', description: 'choose memory allocator to use')\n\noption('kvm', type: 'feature', value: 'auto',\n       description: 'KVM acceleration support')\noption('hax', type: 'feature', value: 'auto',\n       description: 'HAX acceleration support')\noption('whpx', type: 'feature', value: 'auto',\n       description: 'WHPX acceleration support')\noption('hvf', type: 'feature', value: 'auto',\n       description: 'HVF acceleration support')\noption('nvmm', type: 'feature', value: 'auto',\n       description: 'NVMM acceleration support')\noption('xen', type: 'feature', value: 'auto',\n       description: 'Xen backend support')\noption('xen_pci_passthrough', type: 'feature', value: 'auto',\n       description: 'Xen PCI passthrough support')\noption('tcg', type: 'feature', value: 'enabled',\n       description: 'TCG support')\noption('tcg_interpreter', type: 'boolean', value: false,\n       description: 'TCG with bytecode interpreter (slow)')\noption('cfi', type: 'boolean', value: 'false',\n       description: 'Control-Flow Integrity (CFI)')\noption('cfi_debug', type: 'boolean', value: 'false',\n       description: 'Verbose errors in case of CFI violation')\noption('multiprocess', type: 'feature', value: 'auto',\n       description: 'Out of process device emulation support')\noption('vfio_user_server', type: 'feature', value: 'disabled',\n       description: 'vfio-user server support')\noption('dbus_display', type: 'feature', value: 'auto',\n       description: '-display dbus support')\noption('tpm', type : 'feature', value : 'auto',\n       description: 'TPM support')\n\n# Do not enable it by default even for Mingw32, because it doesn't\n# work on Wine.\noption('membarrier', type: 'feature', value: 'disabled',\n       description: 'membarrier system call (for Linux 4.14+ or Windows')\n\noption('avx2', type: 'feature', value: 'auto',\n       description: 'AVX2 optimizations')\noption('avx512f', type: 'feature', value: 'disabled',\n       description: 'AVX512F optimizations')\noption('keyring', type: 'feature', value: 'auto',\n       description: 'Linux keyring support')\n\noption('attr', type : 'feature', value : 'auto',\n       description: 'attr/xattr support')\noption('auth_pam', type : 'feature', value : 'auto',\n       description: 'PAM access control')\noption('brlapi', type : 'feature', value : 'auto',\n       description: 'brlapi character device driver')\noption('bzip2', type : 'feature', value : 'auto',\n       description: 'bzip2 support for DMG images')\noption('cap_ng', type : 'feature', value : 'auto',\n       description: 'cap_ng support')\noption('bpf', type : 'feature', value : 'auto',\n        description: 'eBPF support')\noption('cocoa', type : 'feature', value : 'auto',\n       description: 'Cocoa user interface (macOS only)')\noption('curl', type : 'feature', value : 'auto',\n       description: 'CURL block device driver')\noption('gio', type : 'feature', value : 'auto',\n       description: 'use libgio for D-Bus support')\noption('glusterfs', type : 'feature', value : 'auto',\n       description: 'Glusterfs block device driver')\noption('libiscsi', type : 'feature', value : 'auto',\n       description: 'libiscsi userspace initiator')\noption('libnfs', type : 'feature', value : 'auto',\n       description: 'libnfs block device driver')\noption('mpath', type : 'feature', value : 'auto',\n       description: 'Multipath persistent reservation passthrough')\noption('numa', type : 'feature', value : 'auto',\n       description: 'libnuma support')\noption('iconv', type : 'feature', value : 'auto',\n       description: 'Font glyph conversion support')\noption('curses', type : 'feature', value : 'auto',\n       description: 'curses UI')\noption('gnutls', type : 'feature', value : 'auto',\n       description: 'GNUTLS cryptography support')\noption('nettle', type : 'feature', value : 'auto',\n       description: 'nettle cryptography support')\noption('gcrypt', type : 'feature', value : 'auto',\n       description: 'libgcrypt cryptography support')\noption('crypto_afalg', type : 'feature', value : 'disabled',\n       description: 'Linux AF_ALG crypto backend driver')\noption('libdaxctl', type : 'feature', value : 'auto',\n       description: 'libdaxctl support')\noption('libpmem', type : 'feature', value : 'auto',\n       description: 'libpmem support')\noption('libssh', type : 'feature', value : 'auto',\n       description: 'ssh block device support')\noption('libudev', type : 'feature', value : 'auto',\n       description: 'Use libudev to enumerate host devices')\noption('libusb', type : 'feature', value : 'auto',\n       description: 'libusb support for USB passthrough')\noption('linux_aio', type : 'feature', value : 'auto',\n       description: 'Linux AIO support')\noption('linux_io_uring', type : 'feature', value : 'auto',\n       description: 'Linux io_uring support')\noption('lzfse', type : 'feature', value : 'auto',\n       description: 'lzfse support for DMG images')\noption('lzo', type : 'feature', value : 'auto',\n       description: 'lzo compression support')\noption('rbd', type : 'feature', value : 'auto',\n       description: 'Ceph block device driver')\noption('opengl', type : 'feature', value : 'auto',\n       description: 'OpenGL support')\noption('rdma', type : 'feature', value : 'auto',\n       description: 'Enable RDMA-based migration')\noption('pvrdma', type : 'feature', value : 'auto',\n       description: 'Enable PVRDMA support')\noption('gtk', type : 'feature', value : 'auto',\n       description: 'GTK+ user interface')\noption('sdl', type : 'feature', value : 'auto',\n       description: 'SDL user interface')\noption('sdl_image', type : 'feature', value : 'auto',\n       description: 'SDL Image support for icons')\noption('seccomp', type : 'feature', value : 'auto',\n       description: 'seccomp support')\noption('smartcard', type : 'feature', value : 'auto',\n       description: 'CA smartcard emulation support')\noption('snappy', type : 'feature', value : 'auto',\n       description: 'snappy compression support')\noption('spice', type : 'feature', value : 'auto',\n       description: 'Spice server support')\noption('spice_protocol', type : 'feature', value : 'auto',\n       description: 'Spice protocol support')\noption('u2f', type : 'feature', value : 'auto',\n       description: 'U2F emulation support')\noption('canokey', type : 'feature', value : 'auto',\n       description: 'CanoKey support')\noption('usb_redir', type : 'feature', value : 'auto',\n       description: 'libusbredir support')\noption('l2tpv3', type : 'feature', value : 'auto',\n       description: 'l2tpv3 network backend support')\noption('netmap', type : 'feature', value : 'auto',\n       description: 'netmap network backend support')\noption('vde', type : 'feature', value : 'auto',\n       description: 'vde network backend support')\noption('vmnet', type : 'feature', value : 'auto',\n       description: 'vmnet.framework network backend support')\noption('virglrenderer', type : 'feature', value : 'auto',\n       description: 'virgl rendering support')\noption('png', type : 'feature', value : 'auto',\n       description: 'PNG support with libpng')\noption('vnc', type : 'feature', value : 'auto',\n       description: 'VNC server')\noption('vnc_jpeg', type : 'feature', value : 'auto',\n       description: 'JPEG lossy compression for VNC server')\noption('vnc_sasl', type : 'feature', value : 'auto',\n       description: 'SASL authentication for VNC server')\noption('vte', type : 'feature', value : 'auto',\n       description: 'vte support for the gtk UI')\noption('xkbcommon', type : 'feature', value : 'auto',\n       description: 'xkbcommon support')\noption('zstd', type : 'feature', value : 'auto',\n       description: 'zstd compression support')\noption('fuse', type: 'feature', value: 'auto',\n       description: 'FUSE block device export')\noption('fuse_lseek', type : 'feature', value : 'auto',\n       description: 'SEEK_HOLE/SEEK_DATA support for FUSE exports')\n\noption('trace_backends', type: 'array', value: ['log'],\n       choices: ['dtrace', 'ftrace', 'log', 'nop', 'simple', 'syslog', 'ust'],\n       description: 'Set available tracing backends')\n\noption('alsa', type: 'feature', value: 'auto',\n       description: 'ALSA sound support')\noption('coreaudio', type: 'feature', value: 'auto',\n       description: 'CoreAudio sound support')\noption('dsound', type: 'feature', value: 'auto',\n       description: 'DirectSound sound support')\noption('jack', type: 'feature', value: 'auto',\n       description: 'JACK sound support')\noption('oss', type: 'feature', value: 'auto',\n       description: 'OSS sound support')\noption('pa', type: 'feature', value: 'auto',\n       description: 'PulseAudio sound support')\n\noption('vhost_kernel', type: 'feature', value: 'auto',\n       description: 'vhost kernel backend support')\noption('vhost_net', type: 'feature', value: 'auto',\n       description: 'vhost-net kernel acceleration support')\noption('vhost_user', type: 'feature', value: 'auto',\n       description: 'vhost-user backend support')\noption('vhost_crypto', type: 'feature', value: 'auto',\n       description: 'vhost-user crypto backend support')\noption('vhost_vdpa', type: 'feature', value: 'auto',\n       description: 'vhost-vdpa kernel backend support')\noption('vhost_user_blk_server', type: 'feature', value: 'auto',\n       description: 'build vhost-user-blk server')\noption('virtfs', type: 'feature', value: 'auto',\n       description: 'virtio-9p support')\noption('virtiofsd', type: 'feature', value: 'auto',\n       description: 'build virtiofs daemon (virtiofsd)')\noption('libvduse', type: 'feature', value: 'auto',\n       description: 'build VDUSE Library')\noption('vduse_blk_export', type: 'feature', value: 'auto',\n       description: 'VDUSE block export support')\n\noption('capstone', type: 'feature', value: 'auto',\n       description: 'Whether and how to find the capstone library')\noption('slirp', type: 'combo', value: 'auto',\n       choices: ['disabled', 'enabled', 'auto', 'system', 'internal'],\n       description: 'Whether and how to find the slirp library')\noption('fdt', type: 'combo', value: 'auto',\n       choices: ['disabled', 'enabled', 'auto', 'system', 'internal'],\n       description: 'Whether and how to find the libfdt library')\n\noption('selinux', type: 'feature', value: 'auto',\n       description: 'SELinux support in qemu-nbd')\noption('live_block_migration', type: 'feature', value: 'auto',\n       description: 'block migration in the main migration stream')\noption('replication', type: 'feature', value: 'auto',\n       description: 'replication support')\noption('bochs', type: 'feature', value: 'auto',\n       description: 'bochs image format support')\noption('cloop', type: 'feature', value: 'auto',\n       description: 'cloop image format support')\noption('dmg', type: 'feature', value: 'auto',\n       description: 'dmg image format support')\noption('qcow1', type: 'feature', value: 'auto',\n       description: 'qcow1 image format support')\noption('vdi', type: 'feature', value: 'auto',\n       description: 'vdi image format support')\noption('vvfat', type: 'feature', value: 'auto',\n       description: 'vvfat image format support')\noption('qed', type: 'feature', value: 'auto',\n       description: 'qed image format support')\noption('parallels', type: 'feature', value: 'auto',\n       description: 'parallels image format support')\noption('block_drv_whitelist_in_tools', type: 'boolean', value: false,\n       description: 'use block whitelist also in tools instead of only QEMU')\noption('rng_none', type: 'boolean', value: false,\n       description: 'dummy RNG, avoid using /dev/(u)random and getrandom()')\noption('coroutine_pool', type: 'boolean', value: true,\n       description: 'coroutine freelist (better performance)')\noption('debug_mutex', type: 'boolean', value: false,\n       description: 'mutex debugging support')\noption('debug_stack_usage', type: 'boolean', value: false,\n       description: 'measure coroutine stack usage')\noption('qom_cast_debug', type: 'boolean', value: false,\n       description: 'cast debugging support')\noption('gprof', type: 'boolean', value: false,\n       description: 'QEMU profiling with gprof')\noption('profiler', type: 'boolean', value: false,\n       description: 'profiler support')\noption('slirp_smbd', type : 'feature', value : 'auto',\n       description: 'use smbd (at path --smbd=*) in slirp networking')\n"
        },
        {
          "name": "migration",
          "type": "tree",
          "content": null
        },
        {
          "name": "module-common.c",
          "type": "blob",
          "size": 0.1103515625,
          "content": "#include \"qemu/osdep.h\"\n#include \"qemu/module.h\"\n\nvoid qemu_module_dummy(void)\n{\n}\n\nvoid DSO_STAMP_FUN(void)\n{\n}\n"
        },
        {
          "name": "monitor",
          "type": "tree",
          "content": null
        },
        {
          "name": "nbd",
          "type": "tree",
          "content": null
        },
        {
          "name": "net",
          "type": "tree",
          "content": null
        },
        {
          "name": "os-posix.c",
          "type": "blob",
          "size": 7.9599609375,
          "content": "/*\n * os-posix.c\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (c) 2010 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include <sys/wait.h>\n#include <pwd.h>\n#include <grp.h>\n#include <libgen.h>\n\n/* Needed early for CONFIG_BSD etc. */\n#include \"net/slirp.h\"\n#include \"qemu/qemu-options.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/log.h\"\n#include \"sysemu/runstate.h\"\n#include \"qemu/cutils.h\"\n\n#ifdef CONFIG_LINUX\n#include <sys/prctl.h>\n#endif\n\n/*\n * Must set all three of these at once.\n * Legal combinations are              unset   by name   by uid\n */\nstatic struct passwd *user_pwd;    /*   NULL   non-NULL   NULL   */\nstatic uid_t user_uid = (uid_t)-1; /*   -1      -1        >=0    */\nstatic gid_t user_gid = (gid_t)-1; /*   -1      -1        >=0    */\n\nstatic const char *chroot_dir;\nstatic int daemonize;\nstatic int daemon_pipe;\n\nvoid os_setup_early_signal_handling(void)\n{\n    struct sigaction act;\n    sigfillset(&act.sa_mask);\n    act.sa_flags = 0;\n    act.sa_handler = SIG_IGN;\n    sigaction(SIGPIPE, &act, NULL);\n}\n\nstatic void termsig_handler(int signal, siginfo_t *info, void *c)\n{\n    qemu_system_killed(info->si_signo, info->si_pid);\n}\n\nvoid os_setup_signal_handling(void)\n{\n    struct sigaction act;\n\n    memset(&act, 0, sizeof(act));\n    act.sa_sigaction = termsig_handler;\n    act.sa_flags = SA_SIGINFO;\n    sigaction(SIGINT,  &act, NULL);\n    sigaction(SIGHUP,  &act, NULL);\n    sigaction(SIGTERM, &act, NULL);\n}\n\nvoid os_set_proc_name(const char *s)\n{\n#if defined(PR_SET_NAME)\n    char name[16];\n    if (!s)\n        return;\n    pstrcpy(name, sizeof(name), s);\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n       This simple way is enough for `top'. */\n    if (prctl(PR_SET_NAME, name)) {\n        error_report(\"unable to change process name: %s\", strerror(errno));\n        exit(1);\n    }\n#else\n    error_report(\"Change of process name not supported by your OS\");\n    exit(1);\n#endif\n}\n\n\nstatic bool os_parse_runas_uid_gid(const char *optarg)\n{\n    unsigned long lv;\n    const char *ep;\n    uid_t got_uid;\n    gid_t got_gid;\n    int rc;\n\n    rc = qemu_strtoul(optarg, &ep, 0, &lv);\n    got_uid = lv; /* overflow here is ID in C99 */\n    if (rc || *ep != ':' || got_uid != lv || got_uid == (uid_t)-1) {\n        return false;\n    }\n\n    rc = qemu_strtoul(ep + 1, 0, 0, &lv);\n    got_gid = lv; /* overflow here is ID in C99 */\n    if (rc || got_gid != lv || got_gid == (gid_t)-1) {\n        return false;\n    }\n\n    user_pwd = NULL;\n    user_uid = got_uid;\n    user_gid = got_gid;\n    return true;\n}\n\n/*\n * Parse OS specific command line options.\n * return 0 if option handled, -1 otherwise\n */\nint os_parse_cmd_args(int index, const char *optarg)\n{\n    switch (index) {\n    case QEMU_OPTION_runas:\n        user_pwd = getpwnam(optarg);\n        if (user_pwd) {\n            user_uid = -1;\n            user_gid = -1;\n        } else if (!os_parse_runas_uid_gid(optarg)) {\n            error_report(\"User \\\"%s\\\" doesn't exist\"\n                         \" (and is not <uid>:<gid>)\",\n                         optarg);\n            exit(1);\n        }\n        break;\n    case QEMU_OPTION_chroot:\n        chroot_dir = optarg;\n        break;\n    case QEMU_OPTION_daemonize:\n        daemonize = 1;\n        break;\n    default:\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void change_process_uid(void)\n{\n    assert((user_uid == (uid_t)-1) || user_pwd == NULL);\n    assert((user_uid == (uid_t)-1) ==\n           (user_gid == (gid_t)-1));\n\n    if (user_pwd || user_uid != (uid_t)-1) {\n        gid_t intended_gid = user_pwd ? user_pwd->pw_gid : user_gid;\n        uid_t intended_uid = user_pwd ? user_pwd->pw_uid : user_uid;\n        if (setgid(intended_gid) < 0) {\n            error_report(\"Failed to setgid(%d)\", intended_gid);\n            exit(1);\n        }\n        if (user_pwd) {\n            if (initgroups(user_pwd->pw_name, user_pwd->pw_gid) < 0) {\n                error_report(\"Failed to initgroups(\\\"%s\\\", %d)\",\n                        user_pwd->pw_name, user_pwd->pw_gid);\n                exit(1);\n            }\n        } else {\n            if (setgroups(1, &user_gid) < 0) {\n                error_report(\"Failed to setgroups(1, [%d])\",\n                        user_gid);\n                exit(1);\n            }\n        }\n        if (setuid(intended_uid) < 0) {\n            error_report(\"Failed to setuid(%d)\", intended_uid);\n            exit(1);\n        }\n        if (setuid(0) != -1) {\n            error_report(\"Dropping privileges failed\");\n            exit(1);\n        }\n    }\n}\n\nstatic void change_root(void)\n{\n    if (chroot_dir) {\n        if (chroot(chroot_dir) < 0) {\n            error_report(\"chroot failed\");\n            exit(1);\n        }\n        if (chdir(\"/\")) {\n            error_report(\"not able to chdir to /: %s\", strerror(errno));\n            exit(1);\n        }\n    }\n\n}\n\nvoid os_daemonize(void)\n{\n    if (daemonize) {\n        pid_t pid;\n        int fds[2];\n\n        if (!g_unix_open_pipe(fds, FD_CLOEXEC, NULL)) {\n            exit(1);\n        }\n\n        pid = fork();\n        if (pid > 0) {\n            uint8_t status;\n            ssize_t len;\n\n            close(fds[1]);\n\n            do {\n                len = read(fds[0], &status, 1);\n            } while (len < 0 && errno == EINTR);\n\n            /* only exit successfully if our child actually wrote\n             * a one-byte zero to our pipe, upon successful init */\n            exit(len == 1 && status == 0 ? 0 : 1);\n\n        } else if (pid < 0) {\n            exit(1);\n        }\n\n        close(fds[0]);\n        daemon_pipe = fds[1];\n\n        setsid();\n\n        pid = fork();\n        if (pid > 0) {\n            exit(0);\n        } else if (pid < 0) {\n            exit(1);\n        }\n        umask(027);\n\n        signal(SIGTSTP, SIG_IGN);\n        signal(SIGTTOU, SIG_IGN);\n        signal(SIGTTIN, SIG_IGN);\n    }\n}\n\nvoid os_setup_post(void)\n{\n    int fd = 0;\n\n    if (daemonize) {\n        if (chdir(\"/\")) {\n            error_report(\"not able to chdir to /: %s\", strerror(errno));\n            exit(1);\n        }\n        TFR(fd = qemu_open_old(\"/dev/null\", O_RDWR));\n        if (fd == -1) {\n            exit(1);\n        }\n    }\n\n    change_root();\n    change_process_uid();\n\n    if (daemonize) {\n        uint8_t status = 0;\n        ssize_t len;\n\n        dup2(fd, 0);\n        dup2(fd, 1);\n        /* In case -D is given do not redirect stderr to /dev/null */\n        if (!qemu_log_enabled()) {\n            dup2(fd, 2);\n        }\n\n        close(fd);\n\n        do {        \n            len = write(daemon_pipe, &status, 1);\n        } while (len < 0 && errno == EINTR);\n        if (len != 1) {\n            exit(1);\n        }\n    }\n}\n\nvoid os_set_line_buffering(void)\n{\n    setvbuf(stdout, NULL, _IOLBF, 0);\n}\n\nbool is_daemonized(void)\n{\n    return daemonize;\n}\n\nint os_set_daemonize(bool d)\n{\n    daemonize = d;\n    return 0;\n}\n\nint os_mlock(void)\n{\n#ifdef HAVE_MLOCKALL\n    int ret = 0;\n\n    ret = mlockall(MCL_CURRENT | MCL_FUTURE);\n    if (ret < 0) {\n        error_report(\"mlockall: %s\", strerror(errno));\n    }\n\n    return ret;\n#else\n    return -ENOSYS;\n#endif\n}\n"
        },
        {
          "name": "os-win32.c",
          "type": "blob",
          "size": 2.0087890625,
          "content": "/*\n * os-win32.c\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n * Copyright (c) 2010 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include <windows.h>\n#include <mmsystem.h>\n#include \"sysemu/runstate.h\"\n\nstatic BOOL WINAPI qemu_ctrl_handler(DWORD type)\n{\n    qemu_system_shutdown_request(SHUTDOWN_CAUSE_HOST_SIGNAL);\n    /* Windows 7 kills application when the function returns.\n       Sleep here to give QEMU a try for closing.\n       Sleep period is 10000ms because Windows kills the program\n       after 10 seconds anyway. */\n    Sleep(10000);\n\n    return TRUE;\n}\n\nstatic TIMECAPS mm_tc;\n\nstatic void os_undo_timer_resolution(void)\n{\n    timeEndPeriod(mm_tc.wPeriodMin);\n}\n\nvoid os_setup_early_signal_handling(void)\n{\n    SetConsoleCtrlHandler(qemu_ctrl_handler, TRUE);\n    timeGetDevCaps(&mm_tc, sizeof(mm_tc));\n    timeBeginPeriod(mm_tc.wPeriodMin);\n    atexit(os_undo_timer_resolution);\n}\n\nvoid os_set_line_buffering(void)\n{\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n}\n"
        },
        {
          "name": "page-vary-common.c",
          "type": "blob",
          "size": 1.6044921875,
          "content": "/*\n * Variable page size handling -- target independent part.\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#define IN_PAGE_VARY 1\n\n#include \"qemu/osdep.h\"\n#include \"exec/page-vary.h\"\n\n/* WARNING: This file must *not* be complied with -flto. */\n\nTargetPageBits target_page;\n\nbool set_preferred_target_page_bits_common(int bits)\n{\n    /*\n     * The target page size is the lowest common denominator for all\n     * the CPUs in the system, so we can only make it smaller, never\n     * larger. And we can't make it smaller once we've committed to\n     * a particular size.\n     */\n    if (target_page.bits == 0 || target_page.bits > bits) {\n        if (target_page.decided) {\n            return false;\n        }\n        target_page.bits = bits;\n    }\n    return true;\n}\n\nvoid finalize_target_page_bits_common(int min)\n{\n    if (target_page.bits == 0) {\n        target_page.bits = min;\n    }\n    target_page.mask = -1ull << target_page.bits;\n    target_page.decided = true;\n}\n"
        },
        {
          "name": "page-vary.c",
          "type": "blob",
          "size": 1.197265625,
          "content": "/*\n * Variable page size handling -- target specific part.\n *\n *  Copyright (c) 2003 Fabrice Bellard\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#define IN_PAGE_VARY 1\n\n#include \"qemu/osdep.h\"\n#include \"exec/page-vary.h\"\n#include \"exec/exec-all.h\"\n\nbool set_preferred_target_page_bits(int bits)\n{\n#ifdef TARGET_PAGE_BITS_VARY\n    assert(bits >= TARGET_PAGE_BITS_MIN);\n    return set_preferred_target_page_bits_common(bits);\n#else\n    return true;\n#endif\n}\n\nvoid finalize_target_page_bits(void)\n{\n#ifdef TARGET_PAGE_BITS_VARY\n    finalize_target_page_bits_common(TARGET_PAGE_BITS_MIN);\n#endif\n}\n"
        },
        {
          "name": "pc-bios",
          "type": "tree",
          "content": null
        },
        {
          "name": "plugins",
          "type": "tree",
          "content": null
        },
        {
          "name": "po",
          "type": "tree",
          "content": null
        },
        {
          "name": "python",
          "type": "tree",
          "content": null
        },
        {
          "name": "qapi",
          "type": "tree",
          "content": null
        },
        {
          "name": "qemu-bridge-helper.c",
          "type": "blob",
          "size": 11.8671875,
          "content": "/*\n * QEMU Bridge Helper\n *\n * Copyright IBM, Corp. 2011\n *\n * Authors:\n * Anthony Liguori   <aliguori@us.ibm.com>\n * Richa Marwaha     <rmarwah@linux.vnet.ibm.com>\n * Corey Bryant      <coreyb@linux.vnet.ibm.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2.  See\n * the COPYING file in the top-level directory.\n */\n\n/*\n * Known shortcomings:\n * - There is no manual page\n * - The syntax of the ACL file is not documented anywhere\n * - parse_acl_file() doesn't report fopen() failure properly, fails\n *   to check ferror() after fgets() failure, arbitrarily truncates\n *   long lines, handles whitespace inconsistently, error messages\n *   don't point to the offending file and line, errors in included\n *   files are reported, but otherwise ignored, ...\n */\n\n#include \"qemu/osdep.h\"\n\n\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <sys/prctl.h>\n\n#include <net/if.h>\n\n#include <linux/sockios.h>\n\n#ifndef SIOCBRADDIF\n#include <linux/if_bridge.h>\n#endif\n\n#include \"qemu/queue.h\"\n#include \"qemu/cutils.h\"\n\n#include \"net/tap-linux.h\"\n\n#ifdef CONFIG_LIBCAP_NG\n#include <cap-ng.h>\n#endif\n\n#define DEFAULT_ACL_FILE CONFIG_QEMU_CONFDIR \"/bridge.conf\"\n\nenum {\n    ACL_ALLOW = 0,\n    ACL_ALLOW_ALL,\n    ACL_DENY,\n    ACL_DENY_ALL,\n};\n\ntypedef struct ACLRule {\n    int type;\n    char iface[IFNAMSIZ];\n    QSIMPLEQ_ENTRY(ACLRule) entry;\n} ACLRule;\n\ntypedef QSIMPLEQ_HEAD(ACLList, ACLRule) ACLList;\n\nstatic void usage(void)\n{\n    fprintf(stderr,\n            \"Usage: qemu-bridge-helper [--use-vnet] --br=bridge --fd=unixfd\\n\");\n}\n\nstatic int parse_acl_file(const char *filename, ACLList *acl_list)\n{\n    FILE *f;\n    char line[4096];\n    ACLRule *acl_rule;\n\n    f = fopen(filename, \"r\");\n    if (f == NULL) {\n        return -1;\n    }\n\n    while (fgets(line, sizeof(line), f) != NULL) {\n        char *ptr = line;\n        char *cmd, *arg, *argend;\n\n        while (g_ascii_isspace(*ptr)) {\n            ptr++;\n        }\n\n        /* skip comments and empty lines */\n        if (*ptr == '#' || *ptr == 0) {\n            continue;\n        }\n\n        cmd = ptr;\n        arg = strchr(cmd, ' ');\n        if (arg == NULL) {\n            arg = strchr(cmd, '\\t');\n        }\n\n        if (arg == NULL) {\n            fprintf(stderr, \"Invalid config line:\\n  %s\\n\", line);\n            goto err;\n        }\n\n        *arg = 0;\n        arg++;\n        while (g_ascii_isspace(*arg)) {\n            arg++;\n        }\n\n        argend = arg + strlen(arg);\n        while (arg != argend && g_ascii_isspace(*(argend - 1))) {\n            argend--;\n        }\n        *argend = 0;\n\n        if (!g_str_equal(cmd, \"include\") && strlen(arg) >= IFNAMSIZ) {\n            fprintf(stderr, \"name `%s' too long: %zu\\n\", arg, strlen(arg));\n            goto err;\n        }\n\n        if (strcmp(cmd, \"deny\") == 0) {\n            acl_rule = g_malloc(sizeof(*acl_rule));\n            if (strcmp(arg, \"all\") == 0) {\n                acl_rule->type = ACL_DENY_ALL;\n            } else {\n                acl_rule->type = ACL_DENY;\n                snprintf(acl_rule->iface, IFNAMSIZ, \"%s\", arg);\n            }\n            QSIMPLEQ_INSERT_TAIL(acl_list, acl_rule, entry);\n        } else if (strcmp(cmd, \"allow\") == 0) {\n            acl_rule = g_malloc(sizeof(*acl_rule));\n            if (strcmp(arg, \"all\") == 0) {\n                acl_rule->type = ACL_ALLOW_ALL;\n            } else {\n                acl_rule->type = ACL_ALLOW;\n                snprintf(acl_rule->iface, IFNAMSIZ, \"%s\", arg);\n            }\n            QSIMPLEQ_INSERT_TAIL(acl_list, acl_rule, entry);\n        } else if (strcmp(cmd, \"include\") == 0) {\n            /* ignore errors */\n            parse_acl_file(arg, acl_list);\n        } else {\n            fprintf(stderr, \"Unknown command `%s'\\n\", cmd);\n            goto err;\n        }\n    }\n\n    fclose(f);\n    return 0;\n\nerr:\n    fclose(f);\n    errno = EINVAL;\n    return -1;\n\n}\n\nstatic bool has_vnet_hdr(int fd)\n{\n    unsigned int features = 0;\n\n    if (ioctl(fd, TUNGETFEATURES, &features) == -1) {\n        return false;\n    }\n\n    if (!(features & IFF_VNET_HDR)) {\n        return false;\n    }\n\n    return true;\n}\n\nstatic void prep_ifreq(struct ifreq *ifr, const char *ifname)\n{\n    memset(ifr, 0, sizeof(*ifr));\n    snprintf(ifr->ifr_name, IFNAMSIZ, \"%s\", ifname);\n}\n\nstatic int send_fd(int c, int fd)\n{\n    char msgbuf[CMSG_SPACE(sizeof(fd))];\n    struct msghdr msg = {\n        .msg_control = msgbuf,\n        .msg_controllen = sizeof(msgbuf),\n    };\n    struct cmsghdr *cmsg;\n    struct iovec iov;\n    char req[1] = { 0x00 };\n\n    cmsg = CMSG_FIRSTHDR(&msg);\n    cmsg->cmsg_level = SOL_SOCKET;\n    cmsg->cmsg_type = SCM_RIGHTS;\n    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));\n    msg.msg_controllen = cmsg->cmsg_len;\n\n    iov.iov_base = req;\n    iov.iov_len = sizeof(req);\n\n    msg.msg_iov = &iov;\n    msg.msg_iovlen = 1;\n    memcpy(CMSG_DATA(cmsg), &fd, sizeof(fd));\n\n    return sendmsg(c, &msg, 0);\n}\n\n#ifdef CONFIG_LIBCAP_NG\nstatic int drop_privileges(void)\n{\n    /* clear all capabilities */\n    capng_clear(CAPNG_SELECT_BOTH);\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE | CAPNG_PERMITTED,\n                     CAP_NET_ADMIN) < 0) {\n        return -1;\n    }\n\n    /* change to calling user's real uid and gid, retaining supplemental\n     * groups and CAP_NET_ADMIN */\n    if (capng_change_id(getuid(), getgid(), CAPNG_CLEAR_BOUNDING)) {\n        return -1;\n    }\n\n    return 0;\n}\n#endif\n\nint main(int argc, char **argv)\n{\n    struct ifreq ifr;\n#ifndef SIOCBRADDIF\n    unsigned long ifargs[4];\n#endif\n    int ifindex;\n    int fd = -1, ctlfd = -1, unixfd = -1;\n    int use_vnet = 0;\n    int mtu;\n    const char *bridge = NULL;\n    char iface[IFNAMSIZ];\n    int index;\n    ACLRule *acl_rule;\n    ACLList acl_list;\n    int access_allowed, access_denied;\n    int ret = EXIT_SUCCESS;\n    g_autofree char *acl_file = NULL;\n\n#ifdef CONFIG_LIBCAP_NG\n    /* if we're run from an suid binary, immediately drop privileges preserving\n     * cap_net_admin */\n    if (geteuid() == 0 && getuid() != geteuid()) {\n        if (drop_privileges() == -1) {\n            fprintf(stderr, \"failed to drop privileges\\n\");\n            return 1;\n        }\n    }\n#endif\n\n    qemu_init_exec_dir(argv[0]);\n\n    /* parse arguments */\n    for (index = 1; index < argc; index++) {\n        if (strcmp(argv[index], \"--use-vnet\") == 0) {\n            use_vnet = 1;\n        } else if (strncmp(argv[index], \"--br=\", 5) == 0) {\n            bridge = &argv[index][5];\n        } else if (strncmp(argv[index], \"--fd=\", 5) == 0) {\n            unixfd = atoi(&argv[index][5]);\n        } else {\n            usage();\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (bridge == NULL || unixfd == -1) {\n        usage();\n        return EXIT_FAILURE;\n    }\n    if (strlen(bridge) >= IFNAMSIZ) {\n        fprintf(stderr, \"name `%s' too long: %zu\\n\", bridge, strlen(bridge));\n        return EXIT_FAILURE;\n    }\n\n    /* parse default acl file */\n    QSIMPLEQ_INIT(&acl_list);\n    acl_file = get_relocated_path(DEFAULT_ACL_FILE);\n    if (parse_acl_file(acl_file, &acl_list) == -1) {\n        fprintf(stderr, \"failed to parse default acl file `%s'\\n\",\n                acl_file);\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* validate bridge against acl -- default policy is to deny\n     * according acl policy if we have a deny and allow both\n     * then deny should always win over allow\n     */\n    access_allowed = 0;\n    access_denied = 0;\n    QSIMPLEQ_FOREACH(acl_rule, &acl_list, entry) {\n        switch (acl_rule->type) {\n        case ACL_ALLOW_ALL:\n            access_allowed = 1;\n            break;\n        case ACL_ALLOW:\n            if (strcmp(bridge, acl_rule->iface) == 0) {\n                access_allowed = 1;\n            }\n            break;\n        case ACL_DENY_ALL:\n            access_denied = 1;\n            break;\n        case ACL_DENY:\n            if (strcmp(bridge, acl_rule->iface) == 0) {\n                access_denied = 1;\n            }\n            break;\n        }\n    }\n\n    if ((access_allowed == 0) || (access_denied == 1)) {\n        fprintf(stderr, \"access denied by acl file\\n\");\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* open a socket to use to control the network interfaces */\n    ctlfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (ctlfd == -1) {\n        fprintf(stderr, \"failed to open control socket: %s\\n\", strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* open the tap device */\n    fd = open(\"/dev/net/tun\", O_RDWR);\n    if (fd == -1) {\n        fprintf(stderr, \"failed to open /dev/net/tun: %s\\n\", strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* request a tap device, disable PI, and add vnet header support if\n     * requested and it's available. */\n    prep_ifreq(&ifr, \"tap%d\");\n    ifr.ifr_flags = IFF_TAP|IFF_NO_PI;\n    if (use_vnet && has_vnet_hdr(fd)) {\n        ifr.ifr_flags |= IFF_VNET_HDR;\n    }\n\n    if (ioctl(fd, TUNSETIFF, &ifr) == -1) {\n        fprintf(stderr, \"failed to create tun device: %s\\n\", strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* save tap device name */\n    snprintf(iface, sizeof(iface), \"%s\", ifr.ifr_name);\n\n    /* get the mtu of the bridge */\n    prep_ifreq(&ifr, bridge);\n    if (ioctl(ctlfd, SIOCGIFMTU, &ifr) == -1) {\n        fprintf(stderr, \"failed to get mtu of bridge `%s': %s\\n\",\n                bridge, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* save mtu */\n    mtu = ifr.ifr_mtu;\n\n    /* set the mtu of the interface based on the bridge */\n    prep_ifreq(&ifr, iface);\n    ifr.ifr_mtu = mtu;\n    if (ioctl(ctlfd, SIOCSIFMTU, &ifr) == -1) {\n        fprintf(stderr, \"failed to set mtu of device `%s' to %d: %s\\n\",\n                iface, mtu, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* Linux uses the lowest enslaved MAC address as the MAC address of\n     * the bridge.  Set MAC address to a high value so that it doesn't\n     * affect the MAC address of the bridge.\n     */\n    if (ioctl(ctlfd, SIOCGIFHWADDR, &ifr) < 0) {\n        fprintf(stderr, \"failed to get MAC address of device `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n    ifr.ifr_hwaddr.sa_data[0] = 0xFE;\n    if (ioctl(ctlfd, SIOCSIFHWADDR, &ifr) < 0) {\n        fprintf(stderr, \"failed to set MAC address of device `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* add the interface to the bridge */\n    prep_ifreq(&ifr, bridge);\n    ifindex = if_nametoindex(iface);\n#ifndef SIOCBRADDIF\n    ifargs[0] = BRCTL_ADD_IF;\n    ifargs[1] = ifindex;\n    ifargs[2] = 0;\n    ifargs[3] = 0;\n    ifr.ifr_data = (void *)ifargs;\n    ret = ioctl(ctlfd, SIOCDEVPRIVATE, &ifr);\n#else\n    ifr.ifr_ifindex = ifindex;\n    ret = ioctl(ctlfd, SIOCBRADDIF, &ifr);\n#endif\n    if (ret == -1) {\n        fprintf(stderr, \"failed to add interface `%s' to bridge `%s': %s\\n\",\n                iface, bridge, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* bring the interface up */\n    prep_ifreq(&ifr, iface);\n    if (ioctl(ctlfd, SIOCGIFFLAGS, &ifr) == -1) {\n        fprintf(stderr, \"failed to get interface flags for `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    ifr.ifr_flags |= IFF_UP;\n    if (ioctl(ctlfd, SIOCSIFFLAGS, &ifr) == -1) {\n        fprintf(stderr, \"failed to bring up interface `%s': %s\\n\",\n                iface, strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* write fd to the domain socket */\n    if (send_fd(unixfd, fd) == -1) {\n        fprintf(stderr, \"failed to write fd to unix socket: %s\\n\",\n                strerror(errno));\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    }\n\n    /* ... */\n\n    /* profit! */\n\ncleanup:\n    if (fd >= 0) {\n        close(fd);\n    }\n    if (ctlfd >= 0) {\n        close(ctlfd);\n    }\n    while ((acl_rule = QSIMPLEQ_FIRST(&acl_list)) != NULL) {\n        QSIMPLEQ_REMOVE_HEAD(&acl_list, entry);\n        g_free(acl_rule);\n    }\n\n    return ret;\n}\n"
        },
        {
          "name": "qemu-edid.c",
          "type": "blob",
          "size": 3.5947265625,
          "content": "/*\n * QEMU EDID test tool.\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n#include \"qemu/osdep.h\"\n#include \"qemu/bswap.h\"\n#include \"qemu/cutils.h\"\n#include \"hw/display/edid.h\"\n\nstatic qemu_edid_info info = {\n    .prefx = 1280,\n    .prefy = 800,\n};\n\nstatic void usage(FILE *out)\n{\n    fprintf(out,\n            \"\\n\"\n            \"This is a test tool for the qemu edid generator.\\n\"\n            \"\\n\"\n            \"Typically you'll pipe the output into edid-decode\\n\"\n            \"to check if the generator works correctly.\\n\"\n            \"\\n\"\n            \"usage: qemu-edid <options>\\n\"\n            \"options:\\n\"\n            \"    -h             print this text\\n\"\n            \"    -o <file>      set output file (stdout by default)\\n\"\n            \"    -v <vendor>    set monitor vendor (three letters)\\n\"\n            \"    -n <name>      set monitor name\\n\"\n            \"    -s <serial>    set monitor serial\\n\"\n            \"    -d <dpi>       set display resolution\\n\"\n            \"    -x <prefx>     set preferred width\\n\"\n            \"    -y <prefy>     set preferred height\\n\"\n            \"    -X <maxx>      set maximum width\\n\"\n            \"    -Y <maxy>      set maximum height\\n\"\n            \"\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n    FILE *outfile = NULL;\n    uint8_t blob[512];\n    size_t size;\n    uint32_t dpi = 100;\n    int rc;\n\n    for (;;) {\n        rc = getopt(argc, argv, \"ho:x:y:X:Y:d:v:n:s:\");\n        if (rc == -1) {\n            break;\n        }\n        switch (rc) {\n        case 'o':\n            if (outfile) {\n                fprintf(stderr, \"outfile specified twice\\n\");\n                exit(1);\n            }\n            outfile = fopen(optarg, \"w\");\n            if (outfile == NULL) {\n                fprintf(stderr, \"open %s: %s\\n\", optarg, strerror(errno));\n                exit(1);\n            }\n            break;\n        case 'x':\n            if (qemu_strtoui(optarg, NULL, 10, &info.prefx) < 0) {\n                fprintf(stderr, \"not a number: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'y':\n            if (qemu_strtoui(optarg, NULL, 10, &info.prefy) < 0) {\n                fprintf(stderr, \"not a number: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'X':\n            if (qemu_strtoui(optarg, NULL, 10, &info.maxx) < 0) {\n                fprintf(stderr, \"not a number: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'Y':\n            if (qemu_strtoui(optarg, NULL, 10, &info.maxy) < 0) {\n                fprintf(stderr, \"not a number: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'd':\n            if (qemu_strtoui(optarg, NULL, 10, &dpi) < 0) {\n                fprintf(stderr, \"not a number: %s\\n\", optarg);\n                exit(1);\n            }\n            break;\n        case 'v':\n            info.vendor = optarg;\n            break;\n        case 'n':\n            info.name = optarg;\n            break;\n        case 's':\n            info.serial = optarg;\n            break;\n        case 'h':\n            usage(stdout);\n            exit(0);\n        default:\n            usage(stderr);\n            exit(1);\n        }\n    }\n\n    if (outfile == NULL) {\n        outfile = stdout;\n    }\n\n    info.width_mm = qemu_edid_dpi_to_mm(dpi, info.prefx);\n    info.height_mm = qemu_edid_dpi_to_mm(dpi, info.prefy);\n\n    memset(blob, 0, sizeof(blob));\n    qemu_edid_generate(blob, sizeof(blob), &info);\n    size = qemu_edid_size(blob);\n    fwrite(blob, size, 1, outfile);\n    fflush(outfile);\n\n    exit(0);\n}\n"
        },
        {
          "name": "qemu-img-cmds.hx",
          "type": "blob",
          "size": 5.521484375,
          "content": "HXCOMM Keep the list of subcommands sorted by name.\nHXCOMM Use DEFHEADING() to define headings in both help text and rST\nHXCOMM Text between SRST and ERST are copied to rST version and\nHXCOMM discarded from C version\nHXCOMM DEF(command, callback, arg_string) is used to construct\nHXCOMM command structures and help message.\nHXCOMM HXCOMM can be used for comments, discarded from both rST and C\n\nHXCOMM When amending the rST sections, please remember to copy the usage\nHXCOMM over to the per-command sections in docs/tools/qemu-img.rst.\n\nDEF(\"amend\", img_amend,\n    \"amend [--object objectdef] [--image-opts] [-p] [-q] [-f fmt] [-t cache] [--force] -o options filename\")\nSRST\n.. option:: amend [--object OBJECTDEF] [--image-opts] [-p] [-q] [-f FMT] [-t CACHE] [--force] -o OPTIONS FILENAME\nERST\n\nDEF(\"bench\", img_bench,\n    \"bench [-c count] [-d depth] [-f fmt] [--flush-interval=flush_interval] [-i aio] [-n] [--no-drain] [-o offset] [--pattern=pattern] [-q] [-s buffer_size] [-S step_size] [-t cache] [-w] [-U] filename\")\nSRST\n.. option:: bench [-c COUNT] [-d DEPTH] [-f FMT] [--flush-interval=FLUSH_INTERVAL] [-i AIO] [-n] [--no-drain] [-o OFFSET] [--pattern=PATTERN] [-q] [-s BUFFER_SIZE] [-S STEP_SIZE] [-t CACHE] [-w] [-U] FILENAME\nERST\n\nDEF(\"bitmap\", img_bitmap,\n    \"bitmap (--merge SOURCE | --add | --remove | --clear | --enable | --disable)... [-b source_file [-F source_fmt]] [-g granularity] [--object objectdef] [--image-opts | -f fmt] filename bitmap\")\nSRST\n.. option:: bitmap (--merge SOURCE | --add | --remove | --clear | --enable | --disable)... [-b SOURCE_FILE [-F SOURCE_FMT]] [-g GRANULARITY] [--object OBJECTDEF] [--image-opts | -f FMT] FILENAME BITMAP\nERST\n\nDEF(\"check\", img_check,\n    \"check [--object objectdef] [--image-opts] [-q] [-f fmt] [--output=ofmt] [-r [leaks | all]] [-T src_cache] [-U] filename\")\nSRST\n.. option:: check [--object OBJECTDEF] [--image-opts] [-q] [-f FMT] [--output=OFMT] [-r [leaks | all]] [-T SRC_CACHE] [-U] FILENAME\nERST\n\nDEF(\"commit\", img_commit,\n    \"commit [--object objectdef] [--image-opts] [-q] [-f fmt] [-t cache] [-b base] [-r rate_limit] [-d] [-p] filename\")\nSRST\n.. option:: commit [--object OBJECTDEF] [--image-opts] [-q] [-f FMT] [-t CACHE] [-b BASE] [-r RATE_LIMIT] [-d] [-p] FILENAME\nERST\n\nDEF(\"compare\", img_compare,\n    \"compare [--object objectdef] [--image-opts] [-f fmt] [-F fmt] [-T src_cache] [-p] [-q] [-s] [-U] filename1 filename2\")\nSRST\n.. option:: compare [--object OBJECTDEF] [--image-opts] [-f FMT] [-F FMT] [-T SRC_CACHE] [-p] [-q] [-s] [-U] FILENAME1 FILENAME2\nERST\n\nDEF(\"convert\", img_convert,\n    \"convert [--object objectdef] [--image-opts] [--target-image-opts] [--target-is-zero] [--bitmaps] [-U] [-C] [-c] [-p] [-q] [-n] [-f fmt] [-t cache] [-T src_cache] [-O output_fmt] [-B backing_file [-F backing_fmt]] [-o options] [-l snapshot_param] [-S sparse_size] [-r rate_limit] [-m num_coroutines] [-W] [--salvage] filename [filename2 [...]] output_filename\")\nSRST\n.. option:: convert [--object OBJECTDEF] [--image-opts] [--target-image-opts] [--target-is-zero] [--bitmaps] [-U] [-C] [-c] [-p] [-q] [-n] [-f FMT] [-t CACHE] [-T SRC_CACHE] [-O OUTPUT_FMT] [-B BACKING_FILE [-F BACKING_FMT]] [-o OPTIONS] [-l SNAPSHOT_PARAM] [-S SPARSE_SIZE] [-r RATE_LIMIT] [-m NUM_COROUTINES] [-W] [--salvage] FILENAME [FILENAME2 [...]] OUTPUT_FILENAME\nERST\n\nDEF(\"create\", img_create,\n    \"create [--object objectdef] [-q] [-f fmt] [-b backing_file [-F backing_fmt]] [-u] [-o options] filename [size]\")\nSRST\n.. option:: create [--object OBJECTDEF] [-q] [-f FMT] [-b BACKING_FILE [-F BACKING_FMT]] [-u] [-o OPTIONS] FILENAME [SIZE]\nERST\n\nDEF(\"dd\", img_dd,\n    \"dd [--image-opts] [-U] [-f fmt] [-O output_fmt] [bs=block_size] [count=blocks] [skip=blocks] if=input of=output\")\nSRST\n.. option:: dd [--image-opts] [-U] [-f FMT] [-O OUTPUT_FMT] [bs=BLOCK_SIZE] [count=BLOCKS] [skip=BLOCKS] if=INPUT of=OUTPUT\nERST\n\nDEF(\"info\", img_info,\n    \"info [--object objectdef] [--image-opts] [-f fmt] [--output=ofmt] [--backing-chain] [-U] filename\")\nSRST\n.. option:: info [--object OBJECTDEF] [--image-opts] [-f FMT] [--output=OFMT] [--backing-chain] [-U] FILENAME\nERST\n\nDEF(\"map\", img_map,\n    \"map [--object objectdef] [--image-opts] [-f fmt] [--start-offset=offset] [--max-length=len] [--output=ofmt] [-U] filename\")\nSRST\n.. option:: map [--object OBJECTDEF] [--image-opts] [-f FMT] [--start-offset=OFFSET] [--max-length=LEN] [--output=OFMT] [-U] FILENAME\nERST\n\nDEF(\"measure\", img_measure,\n\"measure [--output=ofmt] [-O output_fmt] [-o options] [--size N | [--object objectdef] [--image-opts] [-f fmt] [-l snapshot_param] filename]\")\nSRST\n.. option:: measure [--output=OFMT] [-O OUTPUT_FMT] [-o OPTIONS] [--size N | [--object OBJECTDEF] [--image-opts] [-f FMT] [-l SNAPSHOT_PARAM] FILENAME]\nERST\n\nDEF(\"snapshot\", img_snapshot,\n    \"snapshot [--object objectdef] [--image-opts] [-U] [-q] [-l | -a snapshot | -c snapshot | -d snapshot] filename\")\nSRST\n.. option:: snapshot [--object OBJECTDEF] [--image-opts] [-U] [-q] [-l | -a SNAPSHOT | -c SNAPSHOT | -d SNAPSHOT] FILENAME\nERST\n\nDEF(\"rebase\", img_rebase,\n    \"rebase [--object objectdef] [--image-opts] [-U] [-q] [-f fmt] [-t cache] [-T src_cache] [-p] [-u] -b backing_file [-F backing_fmt] filename\")\nSRST\n.. option:: rebase [--object OBJECTDEF] [--image-opts] [-U] [-q] [-f FMT] [-t CACHE] [-T SRC_CACHE] [-p] [-u] -b BACKING_FILE [-F BACKING_FMT] FILENAME\nERST\n\nDEF(\"resize\", img_resize,\n    \"resize [--object objectdef] [--image-opts] [-f fmt] [--preallocation=prealloc] [-q] [--shrink] filename [+ | -]size\")\nSRST\n.. option:: resize [--object OBJECTDEF] [--image-opts] [-f FMT] [--preallocation=PREALLOC] [-q] [--shrink] FILENAME [+ | -]SIZE\nERST\n"
        },
        {
          "name": "qemu-img.c",
          "type": "blob",
          "size": 159.697265625,
          "content": "/*\n * QEMU disk image utility\n *\n * Copyright (c) 2003-2008 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"qemu/osdep.h\"\n#include <getopt.h>\n\n#include \"qemu/help-texts.h\"\n#include \"qemu/qemu-progress.h\"\n#include \"qemu-version.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qapi-commands-block-core.h\"\n#include \"qapi/qapi-visit-block-core.h\"\n#include \"qapi/qobject-output-visitor.h\"\n#include \"qapi/qmp/qjson.h\"\n#include \"qapi/qmp/qdict.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/option.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/log.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/module.h\"\n#include \"qemu/sockets.h\"\n#include \"qemu/units.h\"\n#include \"qemu/memalign.h\"\n#include \"qom/object_interfaces.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block_int.h\"\n#include \"block/blockjob.h\"\n#include \"block/qapi.h\"\n#include \"crypto/init.h\"\n#include \"trace/control.h\"\n#include \"qemu/throttle.h\"\n#include \"block/throttle-groups.h\"\n\n#define QEMU_IMG_VERSION \"qemu-img version \" QEMU_FULL_VERSION \\\n                          \"\\n\" QEMU_COPYRIGHT \"\\n\"\n\ntypedef struct img_cmd_t {\n    const char *name;\n    int (*handler)(int argc, char **argv);\n} img_cmd_t;\n\nenum {\n    OPTION_OUTPUT = 256,\n    OPTION_BACKING_CHAIN = 257,\n    OPTION_OBJECT = 258,\n    OPTION_IMAGE_OPTS = 259,\n    OPTION_PATTERN = 260,\n    OPTION_FLUSH_INTERVAL = 261,\n    OPTION_NO_DRAIN = 262,\n    OPTION_TARGET_IMAGE_OPTS = 263,\n    OPTION_SIZE = 264,\n    OPTION_PREALLOCATION = 265,\n    OPTION_SHRINK = 266,\n    OPTION_SALVAGE = 267,\n    OPTION_TARGET_IS_ZERO = 268,\n    OPTION_ADD = 269,\n    OPTION_REMOVE = 270,\n    OPTION_CLEAR = 271,\n    OPTION_ENABLE = 272,\n    OPTION_DISABLE = 273,\n    OPTION_MERGE = 274,\n    OPTION_BITMAPS = 275,\n    OPTION_FORCE = 276,\n    OPTION_SKIP_BROKEN = 277,\n};\n\ntypedef enum OutputFormat {\n    OFORMAT_JSON,\n    OFORMAT_HUMAN,\n} OutputFormat;\n\n/* Default to cache=writeback as data integrity is not important for qemu-img */\n#define BDRV_DEFAULT_CACHE \"writeback\"\n\nstatic void format_print(void *opaque, const char *name)\n{\n    printf(\" %s\", name);\n}\n\nstatic G_NORETURN G_GNUC_PRINTF(1, 2)\nvoid error_exit(const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    error_vreport(fmt, ap);\n    va_end(ap);\n\n    error_printf(\"Try 'qemu-img --help' for more information\\n\");\n    exit(EXIT_FAILURE);\n}\n\nstatic G_NORETURN\nvoid missing_argument(const char *option)\n{\n    error_exit(\"missing argument for option '%s'\", option);\n}\n\nstatic G_NORETURN\nvoid unrecognized_option(const char *option)\n{\n    error_exit(\"unrecognized option '%s'\", option);\n}\n\n/* Please keep in synch with docs/tools/qemu-img.rst */\nstatic G_NORETURN\nvoid help(void)\n{\n    const char *help_msg =\n           QEMU_IMG_VERSION\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n           \"QEMU disk image utility\\n\"\n           \"\\n\"\n           \"    '-h', '--help'       display this help and exit\\n\"\n           \"    '-V', '--version'    output version information and exit\\n\"\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n           \"                         specify tracing options\\n\"\n           \"\\n\"\n           \"Command syntax:\\n\"\n#define DEF(option, callback, arg_string)        \\\n           \"  \" arg_string \"\\n\"\n#include \"qemu-img-cmds.h\"\n#undef DEF\n           \"\\n\"\n           \"Command parameters:\\n\"\n           \"  'filename' is a disk image filename\\n\"\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n           \"    manual page for a description of the object properties. The most common\\n\"\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n           \"    encryption keys.\\n\"\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n           \"    options are the same as for the 'cache' option\\n\"\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n           \"    supported. 'b' is ignored.\\n\"\n           \"  'output_filename' is the destination disk image filename\\n\"\n           \"  'output_fmt' is the destination format\\n\"\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n           \"    used format\\n\"\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n           \"    '[ID_OR_NAME]'\\n\"\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n           \"  '-u' allows unsafe backing chains. For rebasing, it is assumed that old and\\n\"\n           \"       new backing file match exactly. The image doesn't need a working\\n\"\n           \"       backing file before rebasing in this case (useful for renaming the\\n\"\n           \"       backing file). For image creation, allow creating without attempting\\n\"\n           \"       to open the backing file.\\n\"\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n           \"  '-p' show progress of command (only certain commands)\\n\"\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n           \"       fully allocated\\n\"\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n           \"       prior to running qemu-img)\\n\"\n           \"\\n\"\n           \"Parameters to bitmap subcommand:\\n\"\n           \"  'bitmap' is the name of the bitmap to manipulate, through one or more\\n\"\n           \"       actions from '--add', '--remove', '--clear', '--enable', '--disable',\\n\"\n           \"       or '--merge source'\\n\"\n           \"  '-g granularity' sets the granularity for '--add' actions\\n\"\n           \"  '-b source' and '-F src_fmt' tell '--merge' actions to find the source\\n\"\n           \"       bitmaps from an alternative file\\n\"\n           \"\\n\"\n           \"Parameters to check subcommand:\\n\"\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n           \"       hiding corruption that has already occurred.\\n\"\n           \"\\n\"\n           \"Parameters to convert subcommand:\\n\"\n           \"  '--bitmaps' copies all top-level persistent bitmaps to destination\\n\"\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n           \"       process (defaults to 8)\\n\"\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n           \"\\n\"\n           \"Parameters to snapshot subcommand:\\n\"\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n           \"  '-c' creates a snapshot\\n\"\n           \"  '-d' deletes a snapshot\\n\"\n           \"  '-l' lists all snapshots in the given image\\n\"\n           \"\\n\"\n           \"Parameters to compare subcommand:\\n\"\n           \"  '-f' first image format\\n\"\n           \"  '-F' second image format\\n\"\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n           \"\\n\"\n           \"Parameters to dd subcommand:\\n\"\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n           \"(default: 512)\\n\"\n           \"  'count=N' copy only N input blocks\\n\"\n           \"  'if=FILE' read from FILE\\n\"\n           \"  'of=FILE' write to FILE\\n\"\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n    bdrv_iterate_format(format_print, NULL, false);\n    printf(\"\\n\\n\" QEMU_HELP_BOTTOM \"\\n\");\n    exit(EXIT_SUCCESS);\n}\n\n/*\n * Is @optarg safe for accumulate_options()?\n * It is when multiple of them can be joined together separated by ','.\n * To make that work, @optarg must not start with ',' (or else a\n * separating ',' preceding it gets escaped), and it must not end with\n * an odd number of ',' (or else a separating ',' following it gets\n * escaped), or be empty (or else a separating ',' preceding it can\n * escape a separating ',' following it).\n * \n */\nstatic bool is_valid_option_list(const char *optarg)\n{\n    size_t len = strlen(optarg);\n    size_t i;\n\n    if (!optarg[0] || optarg[0] == ',') {\n        return false;\n    }\n\n    for (i = len; i > 0 && optarg[i - 1] == ','; i--) {\n    }\n    if ((len - i) % 2) {\n        return false;\n    }\n\n    return true;\n}\n\nstatic int accumulate_options(char **options, char *optarg)\n{\n    char *new_options;\n\n    if (!is_valid_option_list(optarg)) {\n        error_report(\"Invalid option list: %s\", optarg);\n        return -1;\n    }\n\n    if (!*options) {\n        *options = g_strdup(optarg);\n    } else {\n        new_options = g_strdup_printf(\"%s,%s\", *options, optarg);\n        g_free(*options);\n        *options = new_options;\n    }\n    return 0;\n}\n\nstatic QemuOptsList qemu_source_opts = {\n    .name = \"source\",\n    .implied_opt_name = \"file\",\n    .head = QTAILQ_HEAD_INITIALIZER(qemu_source_opts.head),\n    .desc = {\n        { }\n    },\n};\n\nstatic int G_GNUC_PRINTF(2, 3) qprintf(bool quiet, const char *fmt, ...)\n{\n    int ret = 0;\n    if (!quiet) {\n        va_list args;\n        va_start(args, fmt);\n        ret = vprintf(fmt, args);\n        va_end(args);\n    }\n    return ret;\n}\n\n\nstatic int print_block_option_help(const char *filename, const char *fmt)\n{\n    BlockDriver *drv, *proto_drv;\n    QemuOptsList *create_opts = NULL;\n    Error *local_err = NULL;\n\n    /* Find driver and parse its options */\n    drv = bdrv_find_format(fmt);\n    if (!drv) {\n        error_report(\"Unknown file format '%s'\", fmt);\n        return 1;\n    }\n\n    if (!drv->create_opts) {\n        error_report(\"Format driver '%s' does not support image creation\", fmt);\n        return 1;\n    }\n\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    if (filename) {\n        proto_drv = bdrv_find_protocol(filename, true, &local_err);\n        if (!proto_drv) {\n            error_report_err(local_err);\n            qemu_opts_free(create_opts);\n            return 1;\n        }\n        if (!proto_drv->create_opts) {\n            error_report(\"Protocol driver '%s' does not support image creation\",\n                         proto_drv->format_name);\n            qemu_opts_free(create_opts);\n            return 1;\n        }\n        create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n    }\n\n    if (filename) {\n        printf(\"Supported options:\\n\");\n    } else {\n        printf(\"Supported %s options:\\n\", fmt);\n    }\n    qemu_opts_print_help(create_opts, false);\n    qemu_opts_free(create_opts);\n\n    if (!filename) {\n        printf(\"\\n\"\n               \"The protocol level may support further options.\\n\"\n               \"Specify the target filename to include those options.\\n\");\n    }\n\n    return 0;\n}\n\n\nstatic BlockBackend *img_open_opts(const char *optstr,\n                                   QemuOpts *opts, int flags, bool writethrough,\n                                   bool quiet, bool force_share)\n{\n    QDict *options;\n    Error *local_err = NULL;\n    BlockBackend *blk;\n    options = qemu_opts_to_qdict(opts, NULL);\n    if (force_share) {\n        if (qdict_haskey(options, BDRV_OPT_FORCE_SHARE)\n            && strcmp(qdict_get_str(options, BDRV_OPT_FORCE_SHARE), \"on\")) {\n            error_report(\"--force-share/-U conflicts with image options\");\n            qobject_unref(options);\n            return NULL;\n        }\n        qdict_put_str(options, BDRV_OPT_FORCE_SHARE, \"on\");\n    }\n    blk = blk_new_open(NULL, NULL, options, flags, &local_err);\n    if (!blk) {\n        error_reportf_err(local_err, \"Could not open '%s': \", optstr);\n        return NULL;\n    }\n    blk_set_enable_write_cache(blk, !writethrough);\n\n    return blk;\n}\n\nstatic BlockBackend *img_open_file(const char *filename,\n                                   QDict *options,\n                                   const char *fmt, int flags,\n                                   bool writethrough, bool quiet,\n                                   bool force_share)\n{\n    BlockBackend *blk;\n    Error *local_err = NULL;\n\n    if (!options) {\n        options = qdict_new();\n    }\n    if (fmt) {\n        qdict_put_str(options, \"driver\", fmt);\n    }\n\n    if (force_share) {\n        qdict_put_bool(options, BDRV_OPT_FORCE_SHARE, true);\n    }\n    blk = blk_new_open(filename, NULL, options, flags, &local_err);\n    if (!blk) {\n        error_reportf_err(local_err, \"Could not open '%s': \", filename);\n        return NULL;\n    }\n    blk_set_enable_write_cache(blk, !writethrough);\n\n    return blk;\n}\n\n\nstatic int img_add_key_secrets(void *opaque,\n                               const char *name, const char *value,\n                               Error **errp)\n{\n    QDict *options = opaque;\n\n    if (g_str_has_suffix(name, \"key-secret\")) {\n        qdict_put_str(options, name, value);\n    }\n\n    return 0;\n}\n\n\nstatic BlockBackend *img_open(bool image_opts,\n                              const char *filename,\n                              const char *fmt, int flags, bool writethrough,\n                              bool quiet, bool force_share)\n{\n    BlockBackend *blk;\n    if (image_opts) {\n        QemuOpts *opts;\n        if (fmt) {\n            error_report(\"--image-opts and --format are mutually exclusive\");\n            return NULL;\n        }\n        opts = qemu_opts_parse_noisily(qemu_find_opts(\"source\"),\n                                       filename, true);\n        if (!opts) {\n            return NULL;\n        }\n        blk = img_open_opts(filename, opts, flags, writethrough, quiet,\n                            force_share);\n    } else {\n        blk = img_open_file(filename, NULL, fmt, flags, writethrough, quiet,\n                            force_share);\n    }\n    return blk;\n}\n\n\nstatic int add_old_style_options(const char *fmt, QemuOpts *opts,\n                                 const char *base_filename,\n                                 const char *base_fmt)\n{\n    if (base_filename) {\n        if (!qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename,\n                          NULL)) {\n            error_report(\"Backing file not supported for file format '%s'\",\n                         fmt);\n            return -1;\n        }\n    }\n    if (base_fmt) {\n        if (!qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt, NULL)) {\n            error_report(\"Backing file format not supported for file \"\n                         \"format '%s'\", fmt);\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int64_t cvtnum_full(const char *name, const char *value, int64_t min,\n                           int64_t max)\n{\n    int err;\n    uint64_t res;\n\n    err = qemu_strtosz(value, NULL, &res);\n    if (err < 0 && err != -ERANGE) {\n        error_report(\"Invalid %s specified. You may use \"\n                     \"k, M, G, T, P or E suffixes for\", name);\n        error_report(\"kilobytes, megabytes, gigabytes, terabytes, \"\n                     \"petabytes and exabytes.\");\n        return err;\n    }\n    if (err == -ERANGE || res > max || res < min) {\n        error_report(\"Invalid %s specified. Must be between %\" PRId64\n                     \" and %\" PRId64 \".\", name, min, max);\n        return -ERANGE;\n    }\n    return res;\n}\n\nstatic int64_t cvtnum(const char *name, const char *value)\n{\n    return cvtnum_full(name, value, 0, INT64_MAX);\n}\n\nstatic int img_create(int argc, char **argv)\n{\n    int c;\n    uint64_t img_size = -1;\n    const char *fmt = \"raw\";\n    const char *base_fmt = NULL;\n    const char *filename;\n    const char *base_filename = NULL;\n    char *options = NULL;\n    Error *local_err = NULL;\n    bool quiet = false;\n    int flags = 0;\n\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":F:b:f:ho:qu\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'F':\n            base_fmt = optarg;\n            break;\n        case 'b':\n            base_filename = optarg;\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'o':\n            if (accumulate_options(&options, optarg) < 0) {\n                goto fail;\n            }\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 'u':\n            flags |= BDRV_O_NO_BACKING;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        }\n    }\n\n    /* Get the filename */\n    filename = (optind < argc) ? argv[optind] : NULL;\n    if (options && has_help_option(options)) {\n        g_free(options);\n        return print_block_option_help(filename, fmt);\n    }\n\n    if (optind >= argc) {\n        error_exit(\"Expecting image file name\");\n    }\n    optind++;\n\n    /* Get image size, if specified */\n    if (optind < argc) {\n        int64_t sval;\n\n        sval = cvtnum(\"image size\", argv[optind++]);\n        if (sval < 0) {\n            goto fail;\n        }\n        img_size = (uint64_t)sval;\n    }\n    if (optind != argc) {\n        error_exit(\"Unexpected argument: %s\", argv[optind]);\n    }\n\n    bdrv_img_create(filename, fmt, base_filename, base_fmt,\n                    options, img_size, flags, quiet, &local_err);\n    if (local_err) {\n        error_reportf_err(local_err, \"%s: \", filename);\n        goto fail;\n    }\n\n    g_free(options);\n    return 0;\n\nfail:\n    g_free(options);\n    return 1;\n}\n\nstatic void dump_json_image_check(ImageCheck *check, bool quiet)\n{\n    GString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_ImageCheck(v, NULL, &check, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj, true);\n    assert(str != NULL);\n    qprintf(quiet, \"%s\\n\", str->str);\n    qobject_unref(obj);\n    visit_free(v);\n    g_string_free(str, true);\n}\n\nstatic void dump_human_image_check(ImageCheck *check, bool quiet)\n{\n    if (!(check->corruptions || check->leaks || check->check_errors)) {\n        qprintf(quiet, \"No errors were found on the image.\\n\");\n    } else {\n        if (check->corruptions) {\n            qprintf(quiet, \"\\n%\" PRId64 \" errors were found on the image.\\n\"\n                    \"Data may be corrupted, or further writes to the image \"\n                    \"may corrupt it.\\n\",\n                    check->corruptions);\n        }\n\n        if (check->leaks) {\n            qprintf(quiet,\n                    \"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\"\n                    \"This means waste of disk space, but no harm to data.\\n\",\n                    check->leaks);\n        }\n\n        if (check->check_errors) {\n            qprintf(quiet,\n                    \"\\n%\" PRId64\n                    \" internal errors have occurred during the check.\\n\",\n                    check->check_errors);\n        }\n    }\n\n    if (check->total_clusters != 0 && check->allocated_clusters != 0) {\n        qprintf(quiet, \"%\" PRId64 \"/%\" PRId64 \" = %0.2f%% allocated, \"\n                \"%0.2f%% fragmented, %0.2f%% compressed clusters\\n\",\n                check->allocated_clusters, check->total_clusters,\n                check->allocated_clusters * 100.0 / check->total_clusters,\n                check->fragmented_clusters * 100.0 / check->allocated_clusters,\n                check->compressed_clusters * 100.0 /\n                check->allocated_clusters);\n    }\n\n    if (check->image_end_offset) {\n        qprintf(quiet,\n                \"Image end offset: %\" PRId64 \"\\n\", check->image_end_offset);\n    }\n}\n\nstatic int collect_image_check(BlockDriverState *bs,\n                   ImageCheck *check,\n                   const char *filename,\n                   const char *fmt,\n                   int fix)\n{\n    int ret;\n    BdrvCheckResult result;\n\n    ret = bdrv_check(bs, &result, fix);\n    if (ret < 0) {\n        return ret;\n    }\n\n    check->filename                 = g_strdup(filename);\n    check->format                   = g_strdup(bdrv_get_format_name(bs));\n    check->check_errors             = result.check_errors;\n    check->corruptions              = result.corruptions;\n    check->has_corruptions          = result.corruptions != 0;\n    check->leaks                    = result.leaks;\n    check->has_leaks                = result.leaks != 0;\n    check->corruptions_fixed        = result.corruptions_fixed;\n    check->has_corruptions_fixed    = result.corruptions_fixed != 0;\n    check->leaks_fixed              = result.leaks_fixed;\n    check->has_leaks_fixed          = result.leaks_fixed != 0;\n    check->image_end_offset         = result.image_end_offset;\n    check->has_image_end_offset     = result.image_end_offset != 0;\n    check->total_clusters           = result.bfi.total_clusters;\n    check->has_total_clusters       = result.bfi.total_clusters != 0;\n    check->allocated_clusters       = result.bfi.allocated_clusters;\n    check->has_allocated_clusters   = result.bfi.allocated_clusters != 0;\n    check->fragmented_clusters      = result.bfi.fragmented_clusters;\n    check->has_fragmented_clusters  = result.bfi.fragmented_clusters != 0;\n    check->compressed_clusters      = result.bfi.compressed_clusters;\n    check->has_compressed_clusters  = result.bfi.compressed_clusters != 0;\n\n    return 0;\n}\n\n/*\n * Checks an image for consistency. Exit codes:\n *\n *  0 - Check completed, image is good\n *  1 - Check not completed because of internal errors\n *  2 - Check completed, image is corrupted\n *  3 - Check completed, image has leaked clusters, but is good otherwise\n * 63 - Checks are not supported by the image format\n */\nstatic int img_check(int argc, char **argv)\n{\n    int c, ret;\n    OutputFormat output_format = OFORMAT_HUMAN;\n    const char *filename, *fmt, *output, *cache;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    int fix = 0;\n    int flags = BDRV_O_CHECK;\n    bool writethrough;\n    ImageCheck *check;\n    bool quiet = false;\n    bool image_opts = false;\n    bool force_share = false;\n\n    fmt = NULL;\n    output = NULL;\n    cache = BDRV_DEFAULT_CACHE;\n\n    for(;;) {\n        int option_index = 0;\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"format\", required_argument, 0, 'f'},\n            {\"repair\", required_argument, 0, 'r'},\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:r:T:qU\",\n                        long_options, &option_index);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'r':\n            flags |= BDRV_O_RDWR;\n\n            if (!strcmp(optarg, \"leaks\")) {\n                fix = BDRV_FIX_LEAKS;\n            } else if (!strcmp(optarg, \"all\")) {\n                fix = BDRV_FIX_LEAKS | BDRV_FIX_ERRORS;\n            } else {\n                error_exit(\"Unknown option value for -r \"\n                           \"(expecting 'leaks' or 'all'): %s\", optarg);\n            }\n            break;\n        case OPTION_OUTPUT:\n            output = optarg;\n            break;\n        case 'T':\n            cache = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (output && !strcmp(output, \"json\")) {\n        output_format = OFORMAT_JSON;\n    } else if (output && !strcmp(output, \"human\")) {\n        output_format = OFORMAT_HUMAN;\n    } else if (output) {\n        error_report(\"--output must be used with human or json as argument.\");\n        return 1;\n    }\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", cache);\n        return 1;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet,\n                   force_share);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    check = g_new0(ImageCheck, 1);\n    ret = collect_image_check(bs, check, filename, fmt, fix);\n\n    if (ret == -ENOTSUP) {\n        error_report(\"This image format does not support checks\");\n        ret = 63;\n        goto fail;\n    }\n\n    if (check->corruptions_fixed || check->leaks_fixed) {\n        int corruptions_fixed, leaks_fixed;\n        bool has_leaks_fixed, has_corruptions_fixed;\n\n        leaks_fixed         = check->leaks_fixed;\n        has_leaks_fixed     = check->has_leaks_fixed;\n        corruptions_fixed   = check->corruptions_fixed;\n        has_corruptions_fixed = check->has_corruptions_fixed;\n\n        if (output_format == OFORMAT_HUMAN) {\n            qprintf(quiet,\n                    \"The following inconsistencies were found and repaired:\\n\\n\"\n                    \"    %\" PRId64 \" leaked clusters\\n\"\n                    \"    %\" PRId64 \" corruptions\\n\\n\"\n                    \"Double checking the fixed image now...\\n\",\n                    check->leaks_fixed,\n                    check->corruptions_fixed);\n        }\n\n        qapi_free_ImageCheck(check);\n        check = g_new0(ImageCheck, 1);\n        ret = collect_image_check(bs, check, filename, fmt, 0);\n\n        check->leaks_fixed          = leaks_fixed;\n        check->has_leaks_fixed      = has_leaks_fixed;\n        check->corruptions_fixed    = corruptions_fixed;\n        check->has_corruptions_fixed = has_corruptions_fixed;\n    }\n\n    if (!ret) {\n        switch (output_format) {\n        case OFORMAT_HUMAN:\n            dump_human_image_check(check, quiet);\n            break;\n        case OFORMAT_JSON:\n            dump_json_image_check(check, quiet);\n            break;\n        }\n    }\n\n    if (ret || check->check_errors) {\n        if (ret) {\n            error_report(\"Check failed: %s\", strerror(-ret));\n        } else {\n            error_report(\"Check failed\");\n        }\n        ret = 1;\n        goto fail;\n    }\n\n    if (check->corruptions) {\n        ret = 2;\n    } else if (check->leaks) {\n        ret = 3;\n    } else {\n        ret = 0;\n    }\n\nfail:\n    qapi_free_ImageCheck(check);\n    blk_unref(blk);\n    return ret;\n}\n\ntypedef struct CommonBlockJobCBInfo {\n    BlockDriverState *bs;\n    Error **errp;\n} CommonBlockJobCBInfo;\n\nstatic void common_block_job_cb(void *opaque, int ret)\n{\n    CommonBlockJobCBInfo *cbi = opaque;\n\n    if (ret < 0) {\n        error_setg_errno(cbi->errp, -ret, \"Block job failed\");\n    }\n}\n\nstatic void run_block_job(BlockJob *job, Error **errp)\n{\n    uint64_t progress_current, progress_total;\n    AioContext *aio_context = block_job_get_aio_context(job);\n    int ret = 0;\n\n    aio_context_acquire(aio_context);\n    job_ref(&job->job);\n    do {\n        float progress = 0.0f;\n        aio_poll(aio_context, true);\n\n        progress_get_snapshot(&job->job.progress, &progress_current,\n                              &progress_total);\n        if (progress_total) {\n            progress = (float)progress_current / progress_total * 100.f;\n        }\n        qemu_progress_print(progress, 0);\n    } while (!job_is_ready(&job->job) && !job_is_completed(&job->job));\n\n    if (!job_is_completed(&job->job)) {\n        ret = job_complete_sync(&job->job, errp);\n    } else {\n        ret = job->job.ret;\n    }\n    job_unref(&job->job);\n    aio_context_release(aio_context);\n\n    /* publish completion progress only when success */\n    if (!ret) {\n        qemu_progress_print(100.f, 0);\n    }\n}\n\nstatic int img_commit(int argc, char **argv)\n{\n    int c, ret, flags;\n    const char *filename, *fmt, *cache, *base;\n    BlockBackend *blk;\n    BlockDriverState *bs, *base_bs;\n    BlockJob *job;\n    bool progress = false, quiet = false, drop = false;\n    bool writethrough;\n    Error *local_err = NULL;\n    CommonBlockJobCBInfo cbi;\n    bool image_opts = false;\n    AioContext *aio_context;\n    int64_t rate_limit = 0;\n\n    fmt = NULL;\n    cache = BDRV_DEFAULT_CACHE;\n    base = NULL;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:ht:b:dpqr:\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'b':\n            base = optarg;\n            /* -b implies -d */\n            drop = true;\n            break;\n        case 'd':\n            drop = true;\n            break;\n        case 'p':\n            progress = true;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 'r':\n            rate_limit = cvtnum(\"rate limit\", optarg);\n            if (rate_limit < 0) {\n                return 1;\n            }\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    /* Progress is not shown in Quiet mode */\n    if (quiet) {\n        progress = false;\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        return 1;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet,\n                   false);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    qemu_progress_init(progress, 1.f);\n    qemu_progress_print(0.f, 100);\n\n    if (base) {\n        base_bs = bdrv_find_backing_image(bs, base);\n        if (!base_bs) {\n            error_setg(&local_err,\n                       \"Did not find '%s' in the backing chain of '%s'\",\n                       base, filename);\n            goto done;\n        }\n    } else {\n        /* This is different from QMP, which by default uses the deepest file in\n         * the backing chain (i.e., the very base); however, the traditional\n         * behavior of qemu-img commit is using the immediate backing file. */\n        base_bs = bdrv_backing_chain_next(bs);\n        if (!base_bs) {\n            error_setg(&local_err, \"Image does not have a backing file\");\n            goto done;\n        }\n    }\n\n    cbi = (CommonBlockJobCBInfo){\n        .errp = &local_err,\n        .bs   = bs,\n    };\n\n    aio_context = bdrv_get_aio_context(bs);\n    aio_context_acquire(aio_context);\n    commit_active_start(\"commit\", bs, base_bs, JOB_DEFAULT, rate_limit,\n                        BLOCKDEV_ON_ERROR_REPORT, NULL, common_block_job_cb,\n                        &cbi, false, &local_err);\n    aio_context_release(aio_context);\n    if (local_err) {\n        goto done;\n    }\n\n    /* When the block job completes, the BlockBackend reference will point to\n     * the old backing file. In order to avoid that the top image is already\n     * deleted, so we can still empty it afterwards, increment the reference\n     * counter here preemptively. */\n    if (!drop) {\n        bdrv_ref(bs);\n    }\n\n    job = block_job_get(\"commit\");\n    assert(job);\n    run_block_job(job, &local_err);\n    if (local_err) {\n        goto unref_backing;\n    }\n\n    if (!drop) {\n        BlockBackend *old_backing_blk;\n\n        old_backing_blk = blk_new_with_bs(bs, BLK_PERM_WRITE, BLK_PERM_ALL,\n                                          &local_err);\n        if (!old_backing_blk) {\n            goto unref_backing;\n        }\n        ret = blk_make_empty(old_backing_blk, &local_err);\n        blk_unref(old_backing_blk);\n        if (ret == -ENOTSUP) {\n            error_free(local_err);\n            local_err = NULL;\n        } else if (ret < 0) {\n            goto unref_backing;\n        }\n    }\n\nunref_backing:\n    if (!drop) {\n        bdrv_unref(bs);\n    }\n\ndone:\n    qemu_progress_end();\n\n    blk_unref(blk);\n\n    if (local_err) {\n        error_report_err(local_err);\n        return 1;\n    }\n\n    qprintf(quiet, \"Image committed.\\n\");\n    return 0;\n}\n\n/*\n * Returns -1 if 'buf' contains only zeroes, otherwise the byte index\n * of the first sector boundary within buf where the sector contains a\n * non-zero byte.  This function is robust to a buffer that is not\n * sector-aligned.\n */\nstatic int64_t find_nonzero(const uint8_t *buf, int64_t n)\n{\n    int64_t i;\n    int64_t end = QEMU_ALIGN_DOWN(n, BDRV_SECTOR_SIZE);\n\n    for (i = 0; i < end; i += BDRV_SECTOR_SIZE) {\n        if (!buffer_is_zero(buf + i, BDRV_SECTOR_SIZE)) {\n            return i;\n        }\n    }\n    if (i < n && !buffer_is_zero(buf + i, n - end)) {\n        return i;\n    }\n    return -1;\n}\n\n/*\n * Returns true iff the first sector pointed to by 'buf' contains at least\n * a non-NUL byte.\n *\n * 'pnum' is set to the number of sectors (including and immediately following\n * the first one) that are known to be in the same allocated/unallocated state.\n * The function will try to align the end offset to alignment boundaries so\n * that the request will at least end aligned and consecutive requests will\n * also start at an aligned offset.\n */\nstatic int is_allocated_sectors(const uint8_t *buf, int n, int *pnum,\n                                int64_t sector_num, int alignment)\n{\n    bool is_zero;\n    int i, tail;\n\n    if (n <= 0) {\n        *pnum = 0;\n        return 0;\n    }\n    is_zero = buffer_is_zero(buf, BDRV_SECTOR_SIZE);\n    for(i = 1; i < n; i++) {\n        buf += BDRV_SECTOR_SIZE;\n        if (is_zero != buffer_is_zero(buf, BDRV_SECTOR_SIZE)) {\n            break;\n        }\n    }\n\n    if (i == n) {\n        /*\n         * The whole buf is the same.\n         * No reason to split it into chunks, so return now.\n         */\n        *pnum = i;\n        return !is_zero;\n    }\n\n    tail = (sector_num + i) & (alignment - 1);\n    if (tail) {\n        if (is_zero && i <= tail) {\n            /*\n             * For sure next sector after i is data, and it will rewrite this\n             * tail anyway due to RMW. So, let's just write data now.\n             */\n            is_zero = false;\n        }\n        if (!is_zero) {\n            /* If possible, align up end offset of allocated areas. */\n            i += alignment - tail;\n            i = MIN(i, n);\n        } else {\n            /*\n             * For sure next sector after i is data, and it will rewrite this\n             * tail anyway due to RMW. Better is avoid RMW and write zeroes up\n             * to aligned bound.\n             */\n            i -= tail;\n        }\n    }\n    *pnum = i;\n    return !is_zero;\n}\n\n/*\n * Like is_allocated_sectors, but if the buffer starts with a used sector,\n * up to 'min' consecutive sectors containing zeros are ignored. This avoids\n * breaking up write requests for only small sparse areas.\n */\nstatic int is_allocated_sectors_min(const uint8_t *buf, int n, int *pnum,\n    int min, int64_t sector_num, int alignment)\n{\n    int ret;\n    int num_checked, num_used;\n\n    if (n < min) {\n        min = n;\n    }\n\n    ret = is_allocated_sectors(buf, n, pnum, sector_num, alignment);\n    if (!ret) {\n        return ret;\n    }\n\n    num_used = *pnum;\n    buf += BDRV_SECTOR_SIZE * *pnum;\n    n -= *pnum;\n    sector_num += *pnum;\n    num_checked = num_used;\n\n    while (n > 0) {\n        ret = is_allocated_sectors(buf, n, pnum, sector_num, alignment);\n\n        buf += BDRV_SECTOR_SIZE * *pnum;\n        n -= *pnum;\n        sector_num += *pnum;\n        num_checked += *pnum;\n        if (ret) {\n            num_used = num_checked;\n        } else if (*pnum >= min) {\n            break;\n        }\n    }\n\n    *pnum = num_used;\n    return 1;\n}\n\n/*\n * Compares two buffers sector by sector. Returns 0 if the first\n * sector of each buffer matches, non-zero otherwise.\n *\n * pnum is set to the sector-aligned size of the buffer prefix that\n * has the same matching status as the first sector.\n */\nstatic int compare_buffers(const uint8_t *buf1, const uint8_t *buf2,\n                           int64_t bytes, int64_t *pnum)\n{\n    bool res;\n    int64_t i = MIN(bytes, BDRV_SECTOR_SIZE);\n\n    assert(bytes > 0);\n\n    res = !!memcmp(buf1, buf2, i);\n    while (i < bytes) {\n        int64_t len = MIN(bytes - i, BDRV_SECTOR_SIZE);\n\n        if (!!memcmp(buf1 + i, buf2 + i, len) != res) {\n            break;\n        }\n        i += len;\n    }\n\n    *pnum = i;\n    return res;\n}\n\n#define IO_BUF_SIZE (2 * MiB)\n\n/*\n * Check if passed sectors are empty (not allocated or contain only 0 bytes)\n *\n * Intended for use by 'qemu-img compare': Returns 0 in case sectors are\n * filled with 0, 1 if sectors contain non-zero data (this is a comparison\n * failure), and 4 on error (the exit status for read errors), after emitting\n * an error message.\n *\n * @param blk:  BlockBackend for the image\n * @param offset: Starting offset to check\n * @param bytes: Number of bytes to check\n * @param filename: Name of disk file we are checking (logging purpose)\n * @param buffer: Allocated buffer for storing read data\n * @param quiet: Flag for quiet mode\n */\nstatic int check_empty_sectors(BlockBackend *blk, int64_t offset,\n                               int64_t bytes, const char *filename,\n                               uint8_t *buffer, bool quiet)\n{\n    int ret = 0;\n    int64_t idx;\n\n    ret = blk_pread(blk, offset, bytes, buffer, 0);\n    if (ret < 0) {\n        error_report(\"Error while reading offset %\" PRId64 \" of %s: %s\",\n                     offset, filename, strerror(-ret));\n        return 4;\n    }\n    idx = find_nonzero(buffer, bytes);\n    if (idx >= 0) {\n        qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n                offset + idx);\n        return 1;\n    }\n\n    return 0;\n}\n\n/*\n * Compares two images. Exit codes:\n *\n * 0 - Images are identical or the requested help was printed\n * 1 - Images differ\n * >1 - Error occurred\n */\nstatic int img_compare(int argc, char **argv)\n{\n    const char *fmt1 = NULL, *fmt2 = NULL, *cache, *filename1, *filename2;\n    BlockBackend *blk1, *blk2;\n    BlockDriverState *bs1, *bs2;\n    int64_t total_size1, total_size2;\n    uint8_t *buf1 = NULL, *buf2 = NULL;\n    int64_t pnum1, pnum2;\n    int allocated1, allocated2;\n    int ret = 0; /* return value - 0 Ident, 1 Different, >1 Error */\n    bool progress = false, quiet = false, strict = false;\n    int flags;\n    bool writethrough;\n    int64_t total_size;\n    int64_t offset = 0;\n    int64_t chunk;\n    int c;\n    uint64_t progress_base;\n    bool image_opts = false;\n    bool force_share = false;\n\n    cache = BDRV_DEFAULT_CACHE;\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:F:T:pqsU\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt1 = optarg;\n            break;\n        case 'F':\n            fmt2 = optarg;\n            break;\n        case 'T':\n            cache = optarg;\n            break;\n        case 'p':\n            progress = true;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 's':\n            strict = true;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OBJECT:\n            {\n                Error *local_err = NULL;\n\n                if (!user_creatable_add_from_str(optarg, &local_err)) {\n                    if (local_err) {\n                        error_report_err(local_err);\n                        exit(2);\n                    } else {\n                        /* Help was printed */\n                        exit(EXIT_SUCCESS);\n                    }\n                }\n                break;\n            }\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    /* Progress is not shown in Quiet mode */\n    if (quiet) {\n        progress = false;\n    }\n\n\n    if (optind != argc - 2) {\n        error_exit(\"Expecting two image file names\");\n    }\n    filename1 = argv[optind++];\n    filename2 = argv[optind++];\n\n    /* Initialize before goto out */\n    qemu_progress_init(progress, 2.0);\n\n    flags = 0;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", cache);\n        ret = 2;\n        goto out3;\n    }\n\n    blk1 = img_open(image_opts, filename1, fmt1, flags, writethrough, quiet,\n                    force_share);\n    if (!blk1) {\n        ret = 2;\n        goto out3;\n    }\n\n    blk2 = img_open(image_opts, filename2, fmt2, flags, writethrough, quiet,\n                    force_share);\n    if (!blk2) {\n        ret = 2;\n        goto out2;\n    }\n    bs1 = blk_bs(blk1);\n    bs2 = blk_bs(blk2);\n\n    buf1 = blk_blockalign(blk1, IO_BUF_SIZE);\n    buf2 = blk_blockalign(blk2, IO_BUF_SIZE);\n    total_size1 = blk_getlength(blk1);\n    if (total_size1 < 0) {\n        error_report(\"Can't get size of %s: %s\",\n                     filename1, strerror(-total_size1));\n        ret = 4;\n        goto out;\n    }\n    total_size2 = blk_getlength(blk2);\n    if (total_size2 < 0) {\n        error_report(\"Can't get size of %s: %s\",\n                     filename2, strerror(-total_size2));\n        ret = 4;\n        goto out;\n    }\n    total_size = MIN(total_size1, total_size2);\n    progress_base = MAX(total_size1, total_size2);\n\n    qemu_progress_print(0, 100);\n\n    if (strict && total_size1 != total_size2) {\n        ret = 1;\n        qprintf(quiet, \"Strict mode: Image size mismatch!\\n\");\n        goto out;\n    }\n\n    while (offset < total_size) {\n        int status1, status2;\n\n        status1 = bdrv_block_status_above(bs1, NULL, offset,\n                                          total_size1 - offset, &pnum1, NULL,\n                                          NULL);\n        if (status1 < 0) {\n            ret = 3;\n            error_report(\"Sector allocation test failed for %s\", filename1);\n            goto out;\n        }\n        allocated1 = status1 & BDRV_BLOCK_ALLOCATED;\n\n        status2 = bdrv_block_status_above(bs2, NULL, offset,\n                                          total_size2 - offset, &pnum2, NULL,\n                                          NULL);\n        if (status2 < 0) {\n            ret = 3;\n            error_report(\"Sector allocation test failed for %s\", filename2);\n            goto out;\n        }\n        allocated2 = status2 & BDRV_BLOCK_ALLOCATED;\n\n        assert(pnum1 && pnum2);\n        chunk = MIN(pnum1, pnum2);\n\n        if (strict) {\n            if (status1 != status2) {\n                ret = 1;\n                qprintf(quiet, \"Strict mode: Offset %\" PRId64\n                        \" block status mismatch!\\n\", offset);\n                goto out;\n            }\n        }\n        if ((status1 & BDRV_BLOCK_ZERO) && (status2 & BDRV_BLOCK_ZERO)) {\n            /* nothing to do */\n        } else if (allocated1 == allocated2) {\n            if (allocated1) {\n                int64_t pnum;\n\n                chunk = MIN(chunk, IO_BUF_SIZE);\n                ret = blk_pread(blk1, offset, chunk, buf1, 0);\n                if (ret < 0) {\n                    error_report(\"Error while reading offset %\" PRId64\n                                 \" of %s: %s\",\n                                 offset, filename1, strerror(-ret));\n                    ret = 4;\n                    goto out;\n                }\n                ret = blk_pread(blk2, offset, chunk, buf2, 0);\n                if (ret < 0) {\n                    error_report(\"Error while reading offset %\" PRId64\n                                 \" of %s: %s\",\n                                 offset, filename2, strerror(-ret));\n                    ret = 4;\n                    goto out;\n                }\n                ret = compare_buffers(buf1, buf2, chunk, &pnum);\n                if (ret || pnum != chunk) {\n                    qprintf(quiet, \"Content mismatch at offset %\" PRId64 \"!\\n\",\n                            offset + (ret ? 0 : pnum));\n                    ret = 1;\n                    goto out;\n                }\n            }\n        } else {\n            chunk = MIN(chunk, IO_BUF_SIZE);\n            if (allocated1) {\n                ret = check_empty_sectors(blk1, offset, chunk,\n                                          filename1, buf1, quiet);\n            } else {\n                ret = check_empty_sectors(blk2, offset, chunk,\n                                          filename2, buf1, quiet);\n            }\n            if (ret) {\n                goto out;\n            }\n        }\n        offset += chunk;\n        qemu_progress_print(((float) chunk / progress_base) * 100, 100);\n    }\n\n    if (total_size1 != total_size2) {\n        BlockBackend *blk_over;\n        const char *filename_over;\n\n        qprintf(quiet, \"Warning: Image size mismatch!\\n\");\n        if (total_size1 > total_size2) {\n            blk_over = blk1;\n            filename_over = filename1;\n        } else {\n            blk_over = blk2;\n            filename_over = filename2;\n        }\n\n        while (offset < progress_base) {\n            ret = bdrv_block_status_above(blk_bs(blk_over), NULL, offset,\n                                          progress_base - offset, &chunk,\n                                          NULL, NULL);\n            if (ret < 0) {\n                ret = 3;\n                error_report(\"Sector allocation test failed for %s\",\n                             filename_over);\n                goto out;\n\n            }\n            if (ret & BDRV_BLOCK_ALLOCATED && !(ret & BDRV_BLOCK_ZERO)) {\n                chunk = MIN(chunk, IO_BUF_SIZE);\n                ret = check_empty_sectors(blk_over, offset, chunk,\n                                          filename_over, buf1, quiet);\n                if (ret) {\n                    goto out;\n                }\n            }\n            offset += chunk;\n            qemu_progress_print(((float) chunk / progress_base) * 100, 100);\n        }\n    }\n\n    qprintf(quiet, \"Images are identical.\\n\");\n    ret = 0;\n\nout:\n    qemu_vfree(buf1);\n    qemu_vfree(buf2);\n    blk_unref(blk2);\nout2:\n    blk_unref(blk1);\nout3:\n    qemu_progress_end();\n    return ret;\n}\n\n/* Convenience wrapper around qmp_block_dirty_bitmap_merge */\nstatic void do_dirty_bitmap_merge(const char *dst_node, const char *dst_name,\n                                  const char *src_node, const char *src_name,\n                                  Error **errp)\n{\n    BlockDirtyBitmapOrStr *merge_src;\n    BlockDirtyBitmapOrStrList *list = NULL;\n\n    merge_src = g_new0(BlockDirtyBitmapOrStr, 1);\n    merge_src->type = QTYPE_QDICT;\n    merge_src->u.external.node = g_strdup(src_node);\n    merge_src->u.external.name = g_strdup(src_name);\n    QAPI_LIST_PREPEND(list, merge_src);\n    qmp_block_dirty_bitmap_merge(dst_node, dst_name, list, errp);\n    qapi_free_BlockDirtyBitmapOrStrList(list);\n}\n\nenum ImgConvertBlockStatus {\n    BLK_DATA,\n    BLK_ZERO,\n    BLK_BACKING_FILE,\n};\n\n#define MAX_COROUTINES 16\n#define CONVERT_THROTTLE_GROUP \"img_convert\"\n\ntypedef struct ImgConvertState {\n    BlockBackend **src;\n    int64_t *src_sectors;\n    int *src_alignment;\n    int src_num;\n    int64_t total_sectors;\n    int64_t allocated_sectors;\n    int64_t allocated_done;\n    int64_t sector_num;\n    int64_t wr_offs;\n    enum ImgConvertBlockStatus status;\n    int64_t sector_next_status;\n    BlockBackend *target;\n    bool has_zero_init;\n    bool compressed;\n    bool target_is_new;\n    bool target_has_backing;\n    int64_t target_backing_sectors; /* negative if unknown */\n    bool wr_in_order;\n    bool copy_range;\n    bool salvage;\n    bool quiet;\n    int min_sparse;\n    int alignment;\n    size_t cluster_sectors;\n    size_t buf_sectors;\n    long num_coroutines;\n    int running_coroutines;\n    Coroutine *co[MAX_COROUTINES];\n    int64_t wait_sector_num[MAX_COROUTINES];\n    CoMutex lock;\n    int ret;\n} ImgConvertState;\n\nstatic void convert_select_part(ImgConvertState *s, int64_t sector_num,\n                                int *src_cur, int64_t *src_cur_offset)\n{\n    *src_cur = 0;\n    *src_cur_offset = 0;\n    while (sector_num - *src_cur_offset >= s->src_sectors[*src_cur]) {\n        *src_cur_offset += s->src_sectors[*src_cur];\n        (*src_cur)++;\n        assert(*src_cur < s->src_num);\n    }\n}\n\nstatic int convert_iteration_sectors(ImgConvertState *s, int64_t sector_num)\n{\n    int64_t src_cur_offset;\n    int ret, n, src_cur;\n    bool post_backing_zero = false;\n\n    convert_select_part(s, sector_num, &src_cur, &src_cur_offset);\n\n    assert(s->total_sectors > sector_num);\n    n = MIN(s->total_sectors - sector_num, BDRV_REQUEST_MAX_SECTORS);\n\n    if (s->target_backing_sectors >= 0) {\n        if (sector_num >= s->target_backing_sectors) {\n            post_backing_zero = true;\n        } else if (sector_num + n > s->target_backing_sectors) {\n            /* Split requests around target_backing_sectors (because\n             * starting from there, zeros are handled differently) */\n            n = s->target_backing_sectors - sector_num;\n        }\n    }\n\n    if (s->sector_next_status <= sector_num) {\n        uint64_t offset = (sector_num - src_cur_offset) * BDRV_SECTOR_SIZE;\n        int64_t count;\n        int tail;\n        BlockDriverState *src_bs = blk_bs(s->src[src_cur]);\n        BlockDriverState *base;\n\n        if (s->target_has_backing) {\n            base = bdrv_cow_bs(bdrv_skip_filters(src_bs));\n        } else {\n            base = NULL;\n        }\n\n        do {\n            count = n * BDRV_SECTOR_SIZE;\n\n            ret = bdrv_block_status_above(src_bs, base, offset, count, &count,\n                                          NULL, NULL);\n\n            if (ret < 0) {\n                if (s->salvage) {\n                    if (n == 1) {\n                        if (!s->quiet) {\n                            warn_report(\"error while reading block status at \"\n                                        \"offset %\" PRIu64 \": %s\", offset,\n                                        strerror(-ret));\n                        }\n                        /* Just try to read the data, then */\n                        ret = BDRV_BLOCK_DATA;\n                        count = BDRV_SECTOR_SIZE;\n                    } else {\n                        /* Retry on a shorter range */\n                        n = DIV_ROUND_UP(n, 4);\n                    }\n                } else {\n                    error_report(\"error while reading block status at offset \"\n                                 \"%\" PRIu64 \": %s\", offset, strerror(-ret));\n                    return ret;\n                }\n            }\n        } while (ret < 0);\n\n        n = DIV_ROUND_UP(count, BDRV_SECTOR_SIZE);\n\n        /*\n         * Avoid that s->sector_next_status becomes unaligned to the source\n         * request alignment and/or cluster size to avoid unnecessary read\n         * cycles.\n         */\n        tail = (sector_num - src_cur_offset + n) % s->src_alignment[src_cur];\n        if (n > tail) {\n            n -= tail;\n        }\n\n        if (ret & BDRV_BLOCK_ZERO) {\n            s->status = post_backing_zero ? BLK_BACKING_FILE : BLK_ZERO;\n        } else if (ret & BDRV_BLOCK_DATA) {\n            s->status = BLK_DATA;\n        } else {\n            s->status = s->target_has_backing ? BLK_BACKING_FILE : BLK_DATA;\n        }\n\n        s->sector_next_status = sector_num + n;\n    }\n\n    n = MIN(n, s->sector_next_status - sector_num);\n    if (s->status == BLK_DATA) {\n        n = MIN(n, s->buf_sectors);\n    }\n\n    /* We need to write complete clusters for compressed images, so if an\n     * unallocated area is shorter than that, we must consider the whole\n     * cluster allocated. */\n    if (s->compressed) {\n        if (n < s->cluster_sectors) {\n            n = MIN(s->cluster_sectors, s->total_sectors - sector_num);\n            s->status = BLK_DATA;\n        } else {\n            n = QEMU_ALIGN_DOWN(n, s->cluster_sectors);\n        }\n    }\n\n    return n;\n}\n\nstatic int coroutine_fn convert_co_read(ImgConvertState *s, int64_t sector_num,\n                                        int nb_sectors, uint8_t *buf)\n{\n    uint64_t single_read_until = 0;\n    int n, ret;\n\n    assert(nb_sectors <= s->buf_sectors);\n    while (nb_sectors > 0) {\n        BlockBackend *blk;\n        int src_cur;\n        int64_t bs_sectors, src_cur_offset;\n        uint64_t offset;\n\n        /* In the case of compression with multiple source files, we can get a\n         * nb_sectors that spreads into the next part. So we must be able to\n         * read across multiple BDSes for one convert_read() call. */\n        convert_select_part(s, sector_num, &src_cur, &src_cur_offset);\n        blk = s->src[src_cur];\n        bs_sectors = s->src_sectors[src_cur];\n\n        offset = (sector_num - src_cur_offset) << BDRV_SECTOR_BITS;\n\n        n = MIN(nb_sectors, bs_sectors - (sector_num - src_cur_offset));\n        if (single_read_until > offset) {\n            n = 1;\n        }\n\n        ret = blk_co_pread(blk, offset, n << BDRV_SECTOR_BITS, buf, 0);\n        if (ret < 0) {\n            if (s->salvage) {\n                if (n > 1) {\n                    single_read_until = offset + (n << BDRV_SECTOR_BITS);\n                    continue;\n                } else {\n                    if (!s->quiet) {\n                        warn_report(\"error while reading offset %\" PRIu64\n                                    \": %s\", offset, strerror(-ret));\n                    }\n                    memset(buf, 0, BDRV_SECTOR_SIZE);\n                }\n            } else {\n                return ret;\n            }\n        }\n\n        sector_num += n;\n        nb_sectors -= n;\n        buf += n * BDRV_SECTOR_SIZE;\n    }\n\n    return 0;\n}\n\n\nstatic int coroutine_fn convert_co_write(ImgConvertState *s, int64_t sector_num,\n                                         int nb_sectors, uint8_t *buf,\n                                         enum ImgConvertBlockStatus status)\n{\n    int ret;\n\n    while (nb_sectors > 0) {\n        int n = nb_sectors;\n        BdrvRequestFlags flags = s->compressed ? BDRV_REQ_WRITE_COMPRESSED : 0;\n\n        switch (status) {\n        case BLK_BACKING_FILE:\n            /* If we have a backing file, leave clusters unallocated that are\n             * unallocated in the source image, so that the backing file is\n             * visible at the respective offset. */\n            assert(s->target_has_backing);\n            break;\n\n        case BLK_DATA:\n            /* If we're told to keep the target fully allocated (-S 0) or there\n             * is real non-zero data, we must write it. Otherwise we can treat\n             * it as zero sectors.\n             * Compressed clusters need to be written as a whole, so in that\n             * case we can only save the write if the buffer is completely\n             * zeroed. */\n            if (!s->min_sparse ||\n                (!s->compressed &&\n                 is_allocated_sectors_min(buf, n, &n, s->min_sparse,\n                                          sector_num, s->alignment)) ||\n                (s->compressed &&\n                 !buffer_is_zero(buf, n * BDRV_SECTOR_SIZE)))\n            {\n                ret = blk_co_pwrite(s->target, sector_num << BDRV_SECTOR_BITS,\n                                    n << BDRV_SECTOR_BITS, buf, flags);\n                if (ret < 0) {\n                    return ret;\n                }\n                break;\n            }\n            /* fall-through */\n\n        case BLK_ZERO:\n            if (s->has_zero_init) {\n                assert(!s->target_has_backing);\n                break;\n            }\n            ret = blk_co_pwrite_zeroes(s->target,\n                                       sector_num << BDRV_SECTOR_BITS,\n                                       n << BDRV_SECTOR_BITS,\n                                       BDRV_REQ_MAY_UNMAP);\n            if (ret < 0) {\n                return ret;\n            }\n            break;\n        }\n\n        sector_num += n;\n        nb_sectors -= n;\n        buf += n * BDRV_SECTOR_SIZE;\n    }\n\n    return 0;\n}\n\nstatic int coroutine_fn convert_co_copy_range(ImgConvertState *s, int64_t sector_num,\n                                              int nb_sectors)\n{\n    int n, ret;\n\n    while (nb_sectors > 0) {\n        BlockBackend *blk;\n        int src_cur;\n        int64_t bs_sectors, src_cur_offset;\n        int64_t offset;\n\n        convert_select_part(s, sector_num, &src_cur, &src_cur_offset);\n        offset = (sector_num - src_cur_offset) << BDRV_SECTOR_BITS;\n        blk = s->src[src_cur];\n        bs_sectors = s->src_sectors[src_cur];\n\n        n = MIN(nb_sectors, bs_sectors - (sector_num - src_cur_offset));\n\n        ret = blk_co_copy_range(blk, offset, s->target,\n                                sector_num << BDRV_SECTOR_BITS,\n                                n << BDRV_SECTOR_BITS, 0, 0);\n        if (ret < 0) {\n            return ret;\n        }\n\n        sector_num += n;\n        nb_sectors -= n;\n    }\n    return 0;\n}\n\nstatic void coroutine_fn convert_co_do_copy(void *opaque)\n{\n    ImgConvertState *s = opaque;\n    uint8_t *buf = NULL;\n    int ret, i;\n    int index = -1;\n\n    for (i = 0; i < s->num_coroutines; i++) {\n        if (s->co[i] == qemu_coroutine_self()) {\n            index = i;\n            break;\n        }\n    }\n    assert(index >= 0);\n\n    s->running_coroutines++;\n    buf = blk_blockalign(s->target, s->buf_sectors * BDRV_SECTOR_SIZE);\n\n    while (1) {\n        int n;\n        int64_t sector_num;\n        enum ImgConvertBlockStatus status;\n        bool copy_range;\n\n        qemu_co_mutex_lock(&s->lock);\n        if (s->ret != -EINPROGRESS || s->sector_num >= s->total_sectors) {\n            qemu_co_mutex_unlock(&s->lock);\n            break;\n        }\n        n = convert_iteration_sectors(s, s->sector_num);\n        if (n < 0) {\n            qemu_co_mutex_unlock(&s->lock);\n            s->ret = n;\n            break;\n        }\n        /* save current sector and allocation status to local variables */\n        sector_num = s->sector_num;\n        status = s->status;\n        if (!s->min_sparse && s->status == BLK_ZERO) {\n            n = MIN(n, s->buf_sectors);\n        }\n        /* increment global sector counter so that other coroutines can\n         * already continue reading beyond this request */\n        s->sector_num += n;\n        qemu_co_mutex_unlock(&s->lock);\n\n        if (status == BLK_DATA || (!s->min_sparse && status == BLK_ZERO)) {\n            s->allocated_done += n;\n            qemu_progress_print(100.0 * s->allocated_done /\n                                        s->allocated_sectors, 0);\n        }\n\nretry:\n        copy_range = s->copy_range && s->status == BLK_DATA;\n        if (status == BLK_DATA && !copy_range) {\n            ret = convert_co_read(s, sector_num, n, buf);\n            if (ret < 0) {\n                error_report(\"error while reading at byte %lld: %s\",\n                             sector_num * BDRV_SECTOR_SIZE, strerror(-ret));\n                s->ret = ret;\n            }\n        } else if (!s->min_sparse && status == BLK_ZERO) {\n            status = BLK_DATA;\n            memset(buf, 0x00, n * BDRV_SECTOR_SIZE);\n        }\n\n        if (s->wr_in_order) {\n            /* keep writes in order */\n            while (s->wr_offs != sector_num && s->ret == -EINPROGRESS) {\n                s->wait_sector_num[index] = sector_num;\n                qemu_coroutine_yield();\n            }\n            s->wait_sector_num[index] = -1;\n        }\n\n        if (s->ret == -EINPROGRESS) {\n            if (copy_range) {\n                ret = convert_co_copy_range(s, sector_num, n);\n                if (ret) {\n                    s->copy_range = false;\n                    goto retry;\n                }\n            } else {\n                ret = convert_co_write(s, sector_num, n, buf, status);\n            }\n            if (ret < 0) {\n                error_report(\"error while writing at byte %lld: %s\",\n                             sector_num * BDRV_SECTOR_SIZE, strerror(-ret));\n                s->ret = ret;\n            }\n        }\n\n        if (s->wr_in_order) {\n            /* reenter the coroutine that might have waited\n             * for this write to complete */\n            s->wr_offs = sector_num + n;\n            for (i = 0; i < s->num_coroutines; i++) {\n                if (s->co[i] && s->wait_sector_num[i] == s->wr_offs) {\n                    /*\n                     * A -> B -> A cannot occur because A has\n                     * s->wait_sector_num[i] == -1 during A -> B.  Therefore\n                     * B will never enter A during this time window.\n                     */\n                    qemu_coroutine_enter(s->co[i]);\n                    break;\n                }\n            }\n        }\n    }\n\n    qemu_vfree(buf);\n    s->co[index] = NULL;\n    s->running_coroutines--;\n    if (!s->running_coroutines && s->ret == -EINPROGRESS) {\n        /* the convert job finished successfully */\n        s->ret = 0;\n    }\n}\n\nstatic int convert_do_copy(ImgConvertState *s)\n{\n    int ret, i, n;\n    int64_t sector_num = 0;\n\n    /* Check whether we have zero initialisation or can get it efficiently */\n    if (!s->has_zero_init && s->target_is_new && s->min_sparse &&\n        !s->target_has_backing) {\n        s->has_zero_init = bdrv_has_zero_init(blk_bs(s->target));\n    }\n\n    /* Allocate buffer for copied data. For compressed images, only one cluster\n     * can be copied at a time. */\n    if (s->compressed) {\n        if (s->cluster_sectors <= 0 || s->cluster_sectors > s->buf_sectors) {\n            error_report(\"invalid cluster size\");\n            return -EINVAL;\n        }\n        s->buf_sectors = s->cluster_sectors;\n    }\n\n    while (sector_num < s->total_sectors) {\n        n = convert_iteration_sectors(s, sector_num);\n        if (n < 0) {\n            return n;\n        }\n        if (s->status == BLK_DATA || (!s->min_sparse && s->status == BLK_ZERO))\n        {\n            s->allocated_sectors += n;\n        }\n        sector_num += n;\n    }\n\n    /* Do the copy */\n    s->sector_next_status = 0;\n    s->ret = -EINPROGRESS;\n\n    qemu_co_mutex_init(&s->lock);\n    for (i = 0; i < s->num_coroutines; i++) {\n        s->co[i] = qemu_coroutine_create(convert_co_do_copy, s);\n        s->wait_sector_num[i] = -1;\n        qemu_coroutine_enter(s->co[i]);\n    }\n\n    while (s->running_coroutines) {\n        main_loop_wait(false);\n    }\n\n    if (s->compressed && !s->ret) {\n        /* signal EOF to align */\n        ret = blk_pwrite_compressed(s->target, 0, 0, NULL);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    return s->ret;\n}\n\n/* Check that bitmaps can be copied, or output an error */\nstatic int convert_check_bitmaps(BlockDriverState *src, bool skip_broken)\n{\n    BdrvDirtyBitmap *bm;\n\n    if (!bdrv_supports_persistent_dirty_bitmap(src)) {\n        error_report(\"Source lacks bitmap support\");\n        return -1;\n    }\n    FOR_EACH_DIRTY_BITMAP(src, bm) {\n        if (!bdrv_dirty_bitmap_get_persistence(bm)) {\n            continue;\n        }\n        if (!skip_broken && bdrv_dirty_bitmap_inconsistent(bm)) {\n            error_report(\"Cannot copy inconsistent bitmap '%s'\",\n                         bdrv_dirty_bitmap_name(bm));\n            error_printf(\"Try --skip-broken-bitmaps, or \"\n                         \"use 'qemu-img bitmap --remove' to delete it\\n\");\n            return -1;\n        }\n    }\n    return 0;\n}\n\nstatic int convert_copy_bitmaps(BlockDriverState *src, BlockDriverState *dst,\n                                bool skip_broken)\n{\n    BdrvDirtyBitmap *bm;\n    Error *err = NULL;\n\n    FOR_EACH_DIRTY_BITMAP(src, bm) {\n        const char *name;\n\n        if (!bdrv_dirty_bitmap_get_persistence(bm)) {\n            continue;\n        }\n        name = bdrv_dirty_bitmap_name(bm);\n        if (skip_broken && bdrv_dirty_bitmap_inconsistent(bm)) {\n            warn_report(\"Skipping inconsistent bitmap '%s'\", name);\n            continue;\n        }\n        qmp_block_dirty_bitmap_add(dst->node_name, name,\n                                   true, bdrv_dirty_bitmap_granularity(bm),\n                                   true, true,\n                                   true, !bdrv_dirty_bitmap_enabled(bm),\n                                   &err);\n        if (err) {\n            error_reportf_err(err, \"Failed to create bitmap %s: \", name);\n            return -1;\n        }\n\n        do_dirty_bitmap_merge(dst->node_name, name, src->node_name, name,\n                              &err);\n        if (err) {\n            error_reportf_err(err, \"Failed to populate bitmap %s: \", name);\n            qmp_block_dirty_bitmap_remove(dst->node_name, name, NULL);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n#define MAX_BUF_SECTORS 32768\n\nstatic void set_rate_limit(BlockBackend *blk, int64_t rate_limit)\n{\n    ThrottleConfig cfg;\n\n    throttle_config_init(&cfg);\n    cfg.buckets[THROTTLE_BPS_WRITE].avg = rate_limit;\n\n    blk_io_limits_enable(blk, CONVERT_THROTTLE_GROUP);\n    blk_set_io_limits(blk, &cfg);\n}\n\nstatic int img_convert(int argc, char **argv)\n{\n    int c, bs_i, flags, src_flags = BDRV_O_NO_SHARE;\n    const char *fmt = NULL, *out_fmt = NULL, *cache = \"unsafe\",\n               *src_cache = BDRV_DEFAULT_CACHE, *out_baseimg = NULL,\n               *out_filename, *out_baseimg_param, *snapshot_name = NULL,\n               *backing_fmt = NULL;\n    BlockDriver *drv = NULL, *proto_drv = NULL;\n    BlockDriverInfo bdi;\n    BlockDriverState *out_bs;\n    QemuOpts *opts = NULL, *sn_opts = NULL;\n    QemuOptsList *create_opts = NULL;\n    QDict *open_opts = NULL;\n    char *options = NULL;\n    Error *local_err = NULL;\n    bool writethrough, src_writethrough, image_opts = false,\n         skip_create = false, progress = false, tgt_image_opts = false;\n    int64_t ret = -EINVAL;\n    bool force_share = false;\n    bool explict_min_sparse = false;\n    bool bitmaps = false;\n    bool skip_broken = false;\n    int64_t rate_limit = 0;\n\n    ImgConvertState s = (ImgConvertState) {\n        /* Need at least 4k of zeros for sparse detection */\n        .min_sparse         = 8,\n        .copy_range         = false,\n        .buf_sectors        = IO_BUF_SIZE / BDRV_SECTOR_SIZE,\n        .wr_in_order        = true,\n        .num_coroutines     = 8,\n    };\n\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {\"target-image-opts\", no_argument, 0, OPTION_TARGET_IMAGE_OPTS},\n            {\"salvage\", no_argument, 0, OPTION_SALVAGE},\n            {\"target-is-zero\", no_argument, 0, OPTION_TARGET_IS_ZERO},\n            {\"bitmaps\", no_argument, 0, OPTION_BITMAPS},\n            {\"skip-broken-bitmaps\", no_argument, 0, OPTION_SKIP_BROKEN},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:O:B:CcF:o:l:S:pt:T:qnm:WUr:\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'O':\n            out_fmt = optarg;\n            break;\n        case 'B':\n            out_baseimg = optarg;\n            break;\n        case 'C':\n            s.copy_range = true;\n            break;\n        case 'c':\n            s.compressed = true;\n            break;\n        case 'F':\n            backing_fmt = optarg;\n            break;\n        case 'o':\n            if (accumulate_options(&options, optarg) < 0) {\n                goto fail_getopt;\n            }\n            break;\n        case 'l':\n            if (strstart(optarg, SNAPSHOT_OPT_BASE, NULL)) {\n                sn_opts = qemu_opts_parse_noisily(&internal_snapshot_opts,\n                                                  optarg, false);\n                if (!sn_opts) {\n                    error_report(\"Failed in parsing snapshot param '%s'\",\n                                 optarg);\n                    goto fail_getopt;\n                }\n            } else {\n                snapshot_name = optarg;\n            }\n            break;\n        case 'S':\n        {\n            int64_t sval;\n\n            sval = cvtnum(\"buffer size for sparse output\", optarg);\n            if (sval < 0) {\n                goto fail_getopt;\n            } else if (!QEMU_IS_ALIGNED(sval, BDRV_SECTOR_SIZE) ||\n                sval / BDRV_SECTOR_SIZE > MAX_BUF_SECTORS) {\n                error_report(\"Invalid buffer size for sparse output specified. \"\n                    \"Valid sizes are multiples of %llu up to %llu. Select \"\n                    \"0 to disable sparse detection (fully allocates output).\",\n                    BDRV_SECTOR_SIZE, MAX_BUF_SECTORS * BDRV_SECTOR_SIZE);\n                goto fail_getopt;\n            }\n\n            s.min_sparse = sval / BDRV_SECTOR_SIZE;\n            explict_min_sparse = true;\n            break;\n        }\n        case 'p':\n            progress = true;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'T':\n            src_cache = optarg;\n            break;\n        case 'q':\n            s.quiet = true;\n            break;\n        case 'n':\n            skip_create = true;\n            break;\n        case 'm':\n            if (qemu_strtol(optarg, NULL, 0, &s.num_coroutines) ||\n                s.num_coroutines < 1 || s.num_coroutines > MAX_COROUTINES) {\n                error_report(\"Invalid number of coroutines. Allowed number of\"\n                             \" coroutines is between 1 and %d\", MAX_COROUTINES);\n                goto fail_getopt;\n            }\n            break;\n        case 'W':\n            s.wr_in_order = false;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case 'r':\n            rate_limit = cvtnum(\"rate limit\", optarg);\n            if (rate_limit < 0) {\n                goto fail_getopt;\n            }\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        case OPTION_SALVAGE:\n            s.salvage = true;\n            break;\n        case OPTION_TARGET_IMAGE_OPTS:\n            tgt_image_opts = true;\n            break;\n        case OPTION_TARGET_IS_ZERO:\n            /*\n             * The user asserting that the target is blank has the\n             * same effect as the target driver supporting zero\n             * initialisation.\n             */\n            s.has_zero_init = true;\n            break;\n        case OPTION_BITMAPS:\n            bitmaps = true;\n            break;\n        case OPTION_SKIP_BROKEN:\n            skip_broken = true;\n            break;\n        }\n    }\n\n    if (!out_fmt && !tgt_image_opts) {\n        out_fmt = \"raw\";\n    }\n\n    if (skip_broken && !bitmaps) {\n        error_report(\"Use of --skip-broken-bitmaps requires --bitmaps\");\n        goto fail_getopt;\n    }\n\n    if (s.compressed && s.copy_range) {\n        error_report(\"Cannot enable copy offloading when -c is used\");\n        goto fail_getopt;\n    }\n\n    if (explict_min_sparse && s.copy_range) {\n        error_report(\"Cannot enable copy offloading when -S is used\");\n        goto fail_getopt;\n    }\n\n    if (s.copy_range && s.salvage) {\n        error_report(\"Cannot use copy offloading in salvaging mode\");\n        goto fail_getopt;\n    }\n\n    if (tgt_image_opts && !skip_create) {\n        error_report(\"--target-image-opts requires use of -n flag\");\n        goto fail_getopt;\n    }\n\n    if (skip_create && options) {\n        error_report(\"-o has no effect when skipping image creation\");\n        goto fail_getopt;\n    }\n\n    if (s.has_zero_init && !skip_create) {\n        error_report(\"--target-is-zero requires use of -n flag\");\n        goto fail_getopt;\n    }\n\n    s.src_num = argc - optind - 1;\n    out_filename = s.src_num >= 1 ? argv[argc - 1] : NULL;\n\n    if (options && has_help_option(options)) {\n        if (out_fmt) {\n            ret = print_block_option_help(out_filename, out_fmt);\n            goto fail_getopt;\n        } else {\n            error_report(\"Option help requires a format be specified\");\n            goto fail_getopt;\n        }\n    }\n\n    if (s.src_num < 1) {\n        error_report(\"Must specify image file name\");\n        goto fail_getopt;\n    }\n\n    /* ret is still -EINVAL until here */\n    ret = bdrv_parse_cache_mode(src_cache, &src_flags, &src_writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", src_cache);\n        goto fail_getopt;\n    }\n\n    /* Initialize before goto out */\n    if (s.quiet) {\n        progress = false;\n    }\n    qemu_progress_init(progress, 1.0);\n    qemu_progress_print(0, 100);\n\n    s.src = g_new0(BlockBackend *, s.src_num);\n    s.src_sectors = g_new(int64_t, s.src_num);\n    s.src_alignment = g_new(int, s.src_num);\n\n    for (bs_i = 0; bs_i < s.src_num; bs_i++) {\n        BlockDriverState *src_bs;\n        s.src[bs_i] = img_open(image_opts, argv[optind + bs_i],\n                               fmt, src_flags, src_writethrough, s.quiet,\n                               force_share);\n        if (!s.src[bs_i]) {\n            ret = -1;\n            goto out;\n        }\n        s.src_sectors[bs_i] = blk_nb_sectors(s.src[bs_i]);\n        if (s.src_sectors[bs_i] < 0) {\n            error_report(\"Could not get size of %s: %s\",\n                         argv[optind + bs_i], strerror(-s.src_sectors[bs_i]));\n            ret = -1;\n            goto out;\n        }\n        src_bs = blk_bs(s.src[bs_i]);\n        s.src_alignment[bs_i] = DIV_ROUND_UP(src_bs->bl.request_alignment,\n                                             BDRV_SECTOR_SIZE);\n        if (!bdrv_get_info(src_bs, &bdi)) {\n            s.src_alignment[bs_i] = MAX(s.src_alignment[bs_i],\n                                        bdi.cluster_size / BDRV_SECTOR_SIZE);\n        }\n        s.total_sectors += s.src_sectors[bs_i];\n    }\n\n    if (sn_opts) {\n        bdrv_snapshot_load_tmp(blk_bs(s.src[0]),\n                               qemu_opt_get(sn_opts, SNAPSHOT_OPT_ID),\n                               qemu_opt_get(sn_opts, SNAPSHOT_OPT_NAME),\n                               &local_err);\n    } else if (snapshot_name != NULL) {\n        if (s.src_num > 1) {\n            error_report(\"No support for concatenating multiple snapshot\");\n            ret = -1;\n            goto out;\n        }\n\n        bdrv_snapshot_load_tmp_by_id_or_name(blk_bs(s.src[0]), snapshot_name,\n                                             &local_err);\n    }\n    if (local_err) {\n        error_reportf_err(local_err, \"Failed to load snapshot: \");\n        ret = -1;\n        goto out;\n    }\n\n    if (!skip_create) {\n        /* Find driver and parse its options */\n        drv = bdrv_find_format(out_fmt);\n        if (!drv) {\n            error_report(\"Unknown file format '%s'\", out_fmt);\n            ret = -1;\n            goto out;\n        }\n\n        proto_drv = bdrv_find_protocol(out_filename, true, &local_err);\n        if (!proto_drv) {\n            error_report_err(local_err);\n            ret = -1;\n            goto out;\n        }\n\n        if (!drv->create_opts) {\n            error_report(\"Format driver '%s' does not support image creation\",\n                         drv->format_name);\n            ret = -1;\n            goto out;\n        }\n\n        if (!proto_drv->create_opts) {\n            error_report(\"Protocol driver '%s' does not support image creation\",\n                         proto_drv->format_name);\n            ret = -1;\n            goto out;\n        }\n\n        create_opts = qemu_opts_append(create_opts, drv->create_opts);\n        create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n\n        opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n        if (options) {\n            if (!qemu_opts_do_parse(opts, options, NULL, &local_err)) {\n                error_report_err(local_err);\n                ret = -1;\n                goto out;\n            }\n        }\n\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE,\n                            s.total_sectors * BDRV_SECTOR_SIZE, &error_abort);\n        ret = add_old_style_options(out_fmt, opts, out_baseimg, backing_fmt);\n        if (ret < 0) {\n            goto out;\n        }\n    }\n\n    /* Get backing file name if -o backing_file was used */\n    out_baseimg_param = qemu_opt_get(opts, BLOCK_OPT_BACKING_FILE);\n    if (out_baseimg_param) {\n        out_baseimg = out_baseimg_param;\n    }\n    s.target_has_backing = (bool) out_baseimg;\n\n    if (s.has_zero_init && s.target_has_backing) {\n        error_report(\"Cannot use --target-is-zero when the destination \"\n                     \"image has a backing file\");\n        goto out;\n    }\n\n    if (s.src_num > 1 && out_baseimg) {\n        error_report(\"Having a backing file for the target makes no sense when \"\n                     \"concatenating multiple input images\");\n        ret = -1;\n        goto out;\n    }\n\n    if (out_baseimg_param) {\n        if (!qemu_opt_get(opts, BLOCK_OPT_BACKING_FMT)) {\n            error_report(\"Use of backing file requires explicit \"\n                         \"backing format\");\n            ret = -1;\n            goto out;\n        }\n    }\n\n    /* Check if compression is supported */\n    if (s.compressed) {\n        bool encryption =\n            qemu_opt_get_bool(opts, BLOCK_OPT_ENCRYPT, false);\n        const char *encryptfmt =\n            qemu_opt_get(opts, BLOCK_OPT_ENCRYPT_FORMAT);\n        const char *preallocation =\n            qemu_opt_get(opts, BLOCK_OPT_PREALLOC);\n\n        if (drv && !block_driver_can_compress(drv)) {\n            error_report(\"Compression not supported for this file format\");\n            ret = -1;\n            goto out;\n        }\n\n        if (encryption || encryptfmt) {\n            error_report(\"Compression and encryption not supported at \"\n                         \"the same time\");\n            ret = -1;\n            goto out;\n        }\n\n        if (preallocation\n            && strcmp(preallocation, \"off\"))\n        {\n            error_report(\"Compression and preallocation not supported at \"\n                         \"the same time\");\n            ret = -1;\n            goto out;\n        }\n    }\n\n    /* Determine if bitmaps need copying */\n    if (bitmaps) {\n        if (s.src_num > 1) {\n            error_report(\"Copying bitmaps only possible with single source\");\n            ret = -1;\n            goto out;\n        }\n        ret = convert_check_bitmaps(blk_bs(s.src[0]), skip_broken);\n        if (ret < 0) {\n            goto out;\n        }\n    }\n\n    /*\n     * The later open call will need any decryption secrets, and\n     * bdrv_create() will purge \"opts\", so extract them now before\n     * they are lost.\n     */\n    if (!skip_create) {\n        open_opts = qdict_new();\n        qemu_opt_foreach(opts, img_add_key_secrets, open_opts, &error_abort);\n\n        /* Create the new image */\n        ret = bdrv_create(drv, out_filename, opts, &local_err);\n        if (ret < 0) {\n            error_reportf_err(local_err, \"%s: error while converting %s: \",\n                              out_filename, out_fmt);\n            goto out;\n        }\n    }\n\n    s.target_is_new = !skip_create;\n\n    flags = s.min_sparse ? (BDRV_O_RDWR | BDRV_O_UNMAP) : BDRV_O_RDWR;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        goto out;\n    }\n\n    if (flags & BDRV_O_NOCACHE) {\n        /*\n         * If we open the target with O_DIRECT, it may be necessary to\n         * extend its size to align to the physical sector size.\n         */\n        flags |= BDRV_O_RESIZE;\n    }\n\n    if (skip_create) {\n        s.target = img_open(tgt_image_opts, out_filename, out_fmt,\n                            flags, writethrough, s.quiet, false);\n    } else {\n        /* TODO ultimately we should allow --target-image-opts\n         * to be used even when -n is not given.\n         * That has to wait for bdrv_create to be improved\n         * to allow filenames in option syntax\n         */\n        s.target = img_open_file(out_filename, open_opts, out_fmt,\n                                 flags, writethrough, s.quiet, false);\n        open_opts = NULL; /* blk_new_open will have freed it */\n    }\n    if (!s.target) {\n        ret = -1;\n        goto out;\n    }\n    out_bs = blk_bs(s.target);\n\n    if (bitmaps && !bdrv_supports_persistent_dirty_bitmap(out_bs)) {\n        error_report(\"Format driver '%s' does not support bitmaps\",\n                     out_bs->drv->format_name);\n        ret = -1;\n        goto out;\n    }\n\n    if (s.compressed && !block_driver_can_compress(out_bs->drv)) {\n        error_report(\"Compression not supported for this file format\");\n        ret = -1;\n        goto out;\n    }\n\n    /* increase bufsectors from the default 4096 (2M) if opt_transfer\n     * or discard_alignment of the out_bs is greater. Limit to\n     * MAX_BUF_SECTORS as maximum which is currently 32768 (16MB). */\n    s.buf_sectors = MIN(MAX_BUF_SECTORS,\n                        MAX(s.buf_sectors,\n                            MAX(out_bs->bl.opt_transfer >> BDRV_SECTOR_BITS,\n                                out_bs->bl.pdiscard_alignment >>\n                                BDRV_SECTOR_BITS)));\n\n    /* try to align the write requests to the destination to avoid unnecessary\n     * RMW cycles. */\n    s.alignment = MAX(pow2floor(s.min_sparse),\n                      DIV_ROUND_UP(out_bs->bl.request_alignment,\n                                   BDRV_SECTOR_SIZE));\n    assert(is_power_of_2(s.alignment));\n\n    if (skip_create) {\n        int64_t output_sectors = blk_nb_sectors(s.target);\n        if (output_sectors < 0) {\n            error_report(\"unable to get output image length: %s\",\n                         strerror(-output_sectors));\n            ret = -1;\n            goto out;\n        } else if (output_sectors < s.total_sectors) {\n            error_report(\"output file is smaller than input file\");\n            ret = -1;\n            goto out;\n        }\n    }\n\n    if (s.target_has_backing && s.target_is_new) {\n        /* Errors are treated as \"backing length unknown\" (which means\n         * s.target_backing_sectors has to be negative, which it will\n         * be automatically).  The backing file length is used only\n         * for optimizations, so such a case is not fatal. */\n        s.target_backing_sectors =\n            bdrv_nb_sectors(bdrv_backing_chain_next(out_bs));\n    } else {\n        s.target_backing_sectors = -1;\n    }\n\n    ret = bdrv_get_info(out_bs, &bdi);\n    if (ret < 0) {\n        if (s.compressed) {\n            error_report(\"could not get block driver info\");\n            goto out;\n        }\n    } else {\n        s.compressed = s.compressed || bdi.needs_compressed_writes;\n        s.cluster_sectors = bdi.cluster_size / BDRV_SECTOR_SIZE;\n    }\n\n    if (rate_limit) {\n        set_rate_limit(s.target, rate_limit);\n    }\n\n    ret = convert_do_copy(&s);\n\n    /* Now copy the bitmaps */\n    if (bitmaps && ret == 0) {\n        ret = convert_copy_bitmaps(blk_bs(s.src[0]), out_bs, skip_broken);\n    }\n\nout:\n    if (!ret) {\n        qemu_progress_print(100, 0);\n    }\n    qemu_progress_end();\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    qobject_unref(open_opts);\n    blk_unref(s.target);\n    if (s.src) {\n        for (bs_i = 0; bs_i < s.src_num; bs_i++) {\n            blk_unref(s.src[bs_i]);\n        }\n        g_free(s.src);\n    }\n    g_free(s.src_sectors);\n    g_free(s.src_alignment);\nfail_getopt:\n    qemu_opts_del(sn_opts);\n    g_free(options);\n\n    return !!ret;\n}\n\n\nstatic void dump_snapshots(BlockDriverState *bs)\n{\n    QEMUSnapshotInfo *sn_tab, *sn;\n    int nb_sns, i;\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n    if (nb_sns <= 0)\n        return;\n    printf(\"Snapshot list:\\n\");\n    bdrv_snapshot_dump(NULL);\n    printf(\"\\n\");\n    for(i = 0; i < nb_sns; i++) {\n        sn = &sn_tab[i];\n        bdrv_snapshot_dump(sn);\n        printf(\"\\n\");\n    }\n    g_free(sn_tab);\n}\n\nstatic void dump_json_image_info_list(ImageInfoList *list)\n{\n    GString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_ImageInfoList(v, NULL, &list, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj, true);\n    assert(str != NULL);\n    printf(\"%s\\n\", str->str);\n    qobject_unref(obj);\n    visit_free(v);\n    g_string_free(str, true);\n}\n\nstatic void dump_json_image_info(ImageInfo *info)\n{\n    GString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_ImageInfo(v, NULL, &info, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj, true);\n    assert(str != NULL);\n    printf(\"%s\\n\", str->str);\n    qobject_unref(obj);\n    visit_free(v);\n    g_string_free(str, true);\n}\n\nstatic void dump_human_image_info_list(ImageInfoList *list)\n{\n    ImageInfoList *elem;\n    bool delim = false;\n\n    for (elem = list; elem; elem = elem->next) {\n        if (delim) {\n            printf(\"\\n\");\n        }\n        delim = true;\n\n        bdrv_image_info_dump(elem->value);\n    }\n}\n\nstatic gboolean str_equal_func(gconstpointer a, gconstpointer b)\n{\n    return strcmp(a, b) == 0;\n}\n\n/**\n * Open an image file chain and return an ImageInfoList\n *\n * @filename: topmost image filename\n * @fmt: topmost image format (may be NULL to autodetect)\n * @chain: true  - enumerate entire backing file chain\n *         false - only topmost image file\n *\n * Returns a list of ImageInfo objects or NULL if there was an error opening an\n * image file.  If there was an error a message will have been printed to\n * stderr.\n */\nstatic ImageInfoList *collect_image_info_list(bool image_opts,\n                                              const char *filename,\n                                              const char *fmt,\n                                              bool chain, bool force_share)\n{\n    ImageInfoList *head = NULL;\n    ImageInfoList **tail = &head;\n    GHashTable *filenames;\n    Error *err = NULL;\n\n    filenames = g_hash_table_new_full(g_str_hash, str_equal_func, NULL, NULL);\n\n    while (filename) {\n        BlockBackend *blk;\n        BlockDriverState *bs;\n        ImageInfo *info;\n\n        if (g_hash_table_lookup_extended(filenames, filename, NULL, NULL)) {\n            error_report(\"Backing file '%s' creates an infinite loop.\",\n                         filename);\n            goto err;\n        }\n        g_hash_table_insert(filenames, (gpointer)filename, NULL);\n\n        blk = img_open(image_opts, filename, fmt,\n                       BDRV_O_NO_BACKING | BDRV_O_NO_IO, false, false,\n                       force_share);\n        if (!blk) {\n            goto err;\n        }\n        bs = blk_bs(blk);\n\n        bdrv_query_image_info(bs, &info, &err);\n        if (err) {\n            error_report_err(err);\n            blk_unref(blk);\n            goto err;\n        }\n\n        QAPI_LIST_APPEND(tail, info);\n\n        blk_unref(blk);\n\n        /* Clear parameters that only apply to the topmost image */\n        filename = fmt = NULL;\n        image_opts = false;\n\n        if (chain) {\n            if (info->has_full_backing_filename) {\n                filename = info->full_backing_filename;\n            } else if (info->has_backing_filename) {\n                error_report(\"Could not determine absolute backing filename,\"\n                             \" but backing filename '%s' present\",\n                             info->backing_filename);\n                goto err;\n            }\n            if (info->has_backing_filename_format) {\n                fmt = info->backing_filename_format;\n            }\n        }\n    }\n    g_hash_table_destroy(filenames);\n    return head;\n\nerr:\n    qapi_free_ImageInfoList(head);\n    g_hash_table_destroy(filenames);\n    return NULL;\n}\n\nstatic int img_info(int argc, char **argv)\n{\n    int c;\n    OutputFormat output_format = OFORMAT_HUMAN;\n    bool chain = false;\n    const char *filename, *fmt, *output;\n    ImageInfoList *list;\n    bool image_opts = false;\n    bool force_share = false;\n\n    fmt = NULL;\n    output = NULL;\n    for(;;) {\n        int option_index = 0;\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"format\", required_argument, 0, 'f'},\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n            {\"backing-chain\", no_argument, 0, OPTION_BACKING_CHAIN},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:hU\",\n                        long_options, &option_index);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OUTPUT:\n            output = optarg;\n            break;\n        case OPTION_BACKING_CHAIN:\n            chain = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    if (output && !strcmp(output, \"json\")) {\n        output_format = OFORMAT_JSON;\n    } else if (output && !strcmp(output, \"human\")) {\n        output_format = OFORMAT_HUMAN;\n    } else if (output) {\n        error_report(\"--output must be used with human or json as argument.\");\n        return 1;\n    }\n\n    list = collect_image_info_list(image_opts, filename, fmt, chain,\n                                   force_share);\n    if (!list) {\n        return 1;\n    }\n\n    switch (output_format) {\n    case OFORMAT_HUMAN:\n        dump_human_image_info_list(list);\n        break;\n    case OFORMAT_JSON:\n        if (chain) {\n            dump_json_image_info_list(list);\n        } else {\n            dump_json_image_info(list->value);\n        }\n        break;\n    }\n\n    qapi_free_ImageInfoList(list);\n    return 0;\n}\n\nstatic int dump_map_entry(OutputFormat output_format, MapEntry *e,\n                          MapEntry *next)\n{\n    switch (output_format) {\n    case OFORMAT_HUMAN:\n        if (e->data && !e->has_offset) {\n            error_report(\"File contains external, encrypted or compressed clusters.\");\n            return -1;\n        }\n        if (e->data && !e->zero) {\n            printf(\"%#-16\"PRIx64\"%#-16\"PRIx64\"%#-16\"PRIx64\"%s\\n\",\n                   e->start, e->length,\n                   e->has_offset ? e->offset : 0,\n                   e->has_filename ? e->filename : \"\");\n        }\n        /* This format ignores the distinction between 0, ZERO and ZERO|DATA.\n         * Modify the flags here to allow more coalescing.\n         */\n        if (next && (!next->data || next->zero)) {\n            next->data = false;\n            next->zero = true;\n        }\n        break;\n    case OFORMAT_JSON:\n        printf(\"{ \\\"start\\\": %\"PRId64\", \\\"length\\\": %\"PRId64\",\"\n               \" \\\"depth\\\": %\"PRId64\", \\\"present\\\": %s, \\\"zero\\\": %s,\"\n               \" \\\"data\\\": %s\", e->start, e->length, e->depth,\n               e->present ? \"true\" : \"false\",\n               e->zero ? \"true\" : \"false\",\n               e->data ? \"true\" : \"false\");\n        if (e->has_offset) {\n            printf(\", \\\"offset\\\": %\"PRId64\"\", e->offset);\n        }\n        putchar('}');\n\n        if (next) {\n            puts(\",\");\n        }\n        break;\n    }\n    return 0;\n}\n\nstatic int get_block_status(BlockDriverState *bs, int64_t offset,\n                            int64_t bytes, MapEntry *e)\n{\n    int ret;\n    int depth;\n    BlockDriverState *file;\n    bool has_offset;\n    int64_t map;\n    char *filename = NULL;\n\n    /* As an optimization, we could cache the current range of unallocated\n     * clusters in each file of the chain, and avoid querying the same\n     * range repeatedly.\n     */\n\n    depth = 0;\n    for (;;) {\n        bs = bdrv_skip_filters(bs);\n        ret = bdrv_block_status(bs, offset, bytes, &bytes, &map, &file);\n        if (ret < 0) {\n            return ret;\n        }\n        assert(bytes);\n        if (ret & (BDRV_BLOCK_ZERO|BDRV_BLOCK_DATA)) {\n            break;\n        }\n        bs = bdrv_cow_bs(bs);\n        if (bs == NULL) {\n            ret = 0;\n            break;\n        }\n\n        depth++;\n    }\n\n    has_offset = !!(ret & BDRV_BLOCK_OFFSET_VALID);\n\n    if (file && has_offset) {\n        bdrv_refresh_filename(file);\n        filename = file->filename;\n    }\n\n    *e = (MapEntry) {\n        .start = offset,\n        .length = bytes,\n        .data = !!(ret & BDRV_BLOCK_DATA),\n        .zero = !!(ret & BDRV_BLOCK_ZERO),\n        .offset = map,\n        .has_offset = has_offset,\n        .depth = depth,\n        .present = !!(ret & BDRV_BLOCK_ALLOCATED),\n        .has_filename = filename,\n        .filename = filename,\n    };\n\n    return 0;\n}\n\nstatic inline bool entry_mergeable(const MapEntry *curr, const MapEntry *next)\n{\n    if (curr->length == 0) {\n        return false;\n    }\n    if (curr->zero != next->zero ||\n        curr->data != next->data ||\n        curr->depth != next->depth ||\n        curr->present != next->present ||\n        curr->has_filename != next->has_filename ||\n        curr->has_offset != next->has_offset) {\n        return false;\n    }\n    if (curr->has_filename && strcmp(curr->filename, next->filename)) {\n        return false;\n    }\n    if (curr->has_offset && curr->offset + curr->length != next->offset) {\n        return false;\n    }\n    return true;\n}\n\nstatic int img_map(int argc, char **argv)\n{\n    int c;\n    OutputFormat output_format = OFORMAT_HUMAN;\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    const char *filename, *fmt, *output;\n    int64_t length;\n    MapEntry curr = { .length = 0 }, next;\n    int ret = 0;\n    bool image_opts = false;\n    bool force_share = false;\n    int64_t start_offset = 0;\n    int64_t max_length = -1;\n\n    fmt = NULL;\n    output = NULL;\n    for (;;) {\n        int option_index = 0;\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"format\", required_argument, 0, 'f'},\n            {\"output\", required_argument, 0, OPTION_OUTPUT},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {\"start-offset\", required_argument, 0, 's'},\n            {\"max-length\", required_argument, 0, 'l'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:s:l:hU\",\n                        long_options, &option_index);\n        if (c == -1) {\n            break;\n        }\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OUTPUT:\n            output = optarg;\n            break;\n        case 's':\n            start_offset = cvtnum(\"start offset\", optarg);\n            if (start_offset < 0) {\n                return 1;\n            }\n            break;\n        case 'l':\n            max_length = cvtnum(\"max length\", optarg);\n            if (max_length < 0) {\n                return 1;\n            }\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind];\n\n    if (output && !strcmp(output, \"json\")) {\n        output_format = OFORMAT_JSON;\n    } else if (output && !strcmp(output, \"human\")) {\n        output_format = OFORMAT_HUMAN;\n    } else if (output) {\n        error_report(\"--output must be used with human or json as argument.\");\n        return 1;\n    }\n\n    blk = img_open(image_opts, filename, fmt, 0, false, false, force_share);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    if (output_format == OFORMAT_HUMAN) {\n        printf(\"%-16s%-16s%-16s%s\\n\", \"Offset\", \"Length\", \"Mapped to\", \"File\");\n    } else if (output_format == OFORMAT_JSON) {\n        putchar('[');\n    }\n\n    length = blk_getlength(blk);\n    if (length < 0) {\n        error_report(\"Failed to get size for '%s'\", filename);\n        return 1;\n    }\n    if (max_length != -1) {\n        length = MIN(start_offset + max_length, length);\n    }\n\n    curr.start = start_offset;\n    while (curr.start + curr.length < length) {\n        int64_t offset = curr.start + curr.length;\n        int64_t n = length - offset;\n\n        ret = get_block_status(bs, offset, n, &next);\n        if (ret < 0) {\n            error_report(\"Could not read file metadata: %s\", strerror(-ret));\n            goto out;\n        }\n\n        if (entry_mergeable(&curr, &next)) {\n            curr.length += next.length;\n            continue;\n        }\n\n        if (curr.length > 0) {\n            ret = dump_map_entry(output_format, &curr, &next);\n            if (ret < 0) {\n                goto out;\n            }\n        }\n        curr = next;\n    }\n\n    ret = dump_map_entry(output_format, &curr, NULL);\n    if (output_format == OFORMAT_JSON) {\n        puts(\"]\");\n    }\n\nout:\n    blk_unref(blk);\n    return ret < 0;\n}\n\n#define SNAPSHOT_LIST   1\n#define SNAPSHOT_CREATE 2\n#define SNAPSHOT_APPLY  3\n#define SNAPSHOT_DELETE 4\n\nstatic int img_snapshot(int argc, char **argv)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    QEMUSnapshotInfo sn;\n    char *filename, *snapshot_name = NULL;\n    int c, ret = 0, bdrv_oflags;\n    int action = 0;\n    bool quiet = false;\n    Error *err = NULL;\n    bool image_opts = false;\n    bool force_share = false;\n    int64_t rt;\n\n    bdrv_oflags = BDRV_O_RDWR;\n    /* Parse commandline parameters */\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":la:c:d:hqU\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            return 0;\n        case 'l':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_LIST;\n            bdrv_oflags &= ~BDRV_O_RDWR; /* no need for RW */\n            break;\n        case 'a':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_APPLY;\n            snapshot_name = optarg;\n            break;\n        case 'c':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_CREATE;\n            snapshot_name = optarg;\n            break;\n        case 'd':\n            if (action) {\n                error_exit(\"Cannot mix '-l', '-a', '-c', '-d'\");\n                return 0;\n            }\n            action = SNAPSHOT_DELETE;\n            snapshot_name = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[optind++];\n\n    /* Open the image */\n    blk = img_open(image_opts, filename, NULL, bdrv_oflags, false, quiet,\n                   force_share);\n    if (!blk) {\n        return 1;\n    }\n    bs = blk_bs(blk);\n\n    /* Perform the requested action */\n    switch(action) {\n    case SNAPSHOT_LIST:\n        dump_snapshots(bs);\n        break;\n\n    case SNAPSHOT_CREATE:\n        memset(&sn, 0, sizeof(sn));\n        pstrcpy(sn.name, sizeof(sn.name), snapshot_name);\n\n        rt = g_get_real_time();\n        sn.date_sec = rt / G_USEC_PER_SEC;\n        sn.date_nsec = (rt % G_USEC_PER_SEC) * 1000;\n\n        ret = bdrv_snapshot_create(bs, &sn);\n        if (ret) {\n            error_report(\"Could not create snapshot '%s': %d (%s)\",\n                snapshot_name, ret, strerror(-ret));\n        }\n        break;\n\n    case SNAPSHOT_APPLY:\n        ret = bdrv_snapshot_goto(bs, snapshot_name, &err);\n        if (ret) {\n            error_reportf_err(err, \"Could not apply snapshot '%s': \",\n                              snapshot_name);\n        }\n        break;\n\n    case SNAPSHOT_DELETE:\n        ret = bdrv_snapshot_find(bs, &sn, snapshot_name);\n        if (ret < 0) {\n            error_report(\"Could not delete snapshot '%s': snapshot not \"\n                         \"found\", snapshot_name);\n            ret = 1;\n        } else {\n            ret = bdrv_snapshot_delete(bs, sn.id_str, sn.name, &err);\n            if (ret < 0) {\n                error_reportf_err(err, \"Could not delete snapshot '%s': \",\n                                  snapshot_name);\n                ret = 1;\n            }\n        }\n        break;\n    }\n\n    /* Cleanup */\n    blk_unref(blk);\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int img_rebase(int argc, char **argv)\n{\n    BlockBackend *blk = NULL, *blk_old_backing = NULL, *blk_new_backing = NULL;\n    uint8_t *buf_old = NULL;\n    uint8_t *buf_new = NULL;\n    BlockDriverState *bs = NULL, *prefix_chain_bs = NULL;\n    BlockDriverState *unfiltered_bs;\n    char *filename;\n    const char *fmt, *cache, *src_cache, *out_basefmt, *out_baseimg;\n    int c, flags, src_flags, ret;\n    bool writethrough, src_writethrough;\n    int unsafe = 0;\n    bool force_share = false;\n    int progress = 0;\n    bool quiet = false;\n    Error *local_err = NULL;\n    bool image_opts = false;\n\n    /* Parse commandline parameters */\n    fmt = NULL;\n    cache = BDRV_DEFAULT_CACHE;\n    src_cache = BDRV_DEFAULT_CACHE;\n    out_baseimg = NULL;\n    out_basefmt = NULL;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force-share\", no_argument, 0, 'U'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hf:F:b:upt:T:qU\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            return 0;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'F':\n            out_basefmt = optarg;\n            break;\n        case 'b':\n            out_baseimg = optarg;\n            break;\n        case 'u':\n            unsafe = 1;\n            break;\n        case 'p':\n            progress = 1;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'T':\n            src_cache = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        }\n    }\n\n    if (quiet) {\n        progress = 0;\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    if (!unsafe && !out_baseimg) {\n        error_exit(\"Must specify backing file (-b) or use unsafe mode (-u)\");\n    }\n    filename = argv[optind++];\n\n    qemu_progress_init(progress, 2.0);\n    qemu_progress_print(0, 100);\n\n    flags = BDRV_O_RDWR | (unsafe ? BDRV_O_NO_BACKING : 0);\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        goto out;\n    }\n\n    src_flags = 0;\n    ret = bdrv_parse_cache_mode(src_cache, &src_flags, &src_writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid source cache option: %s\", src_cache);\n        goto out;\n    }\n\n    /* The source files are opened read-only, don't care about WCE */\n    assert((src_flags & BDRV_O_RDWR) == 0);\n    (void) src_writethrough;\n\n    /*\n     * Open the images.\n     *\n     * Ignore the old backing file for unsafe rebase in case we want to correct\n     * the reference to a renamed or moved backing file.\n     */\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet,\n                   false);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n    bs = blk_bs(blk);\n\n    unfiltered_bs = bdrv_skip_filters(bs);\n\n    if (out_basefmt != NULL) {\n        if (bdrv_find_format(out_basefmt) == NULL) {\n            error_report(\"Invalid format name: '%s'\", out_basefmt);\n            ret = -1;\n            goto out;\n        }\n    }\n\n    /* For safe rebasing we need to compare old and new backing file */\n    if (!unsafe) {\n        QDict *options = NULL;\n        BlockDriverState *base_bs = bdrv_cow_bs(unfiltered_bs);\n\n        if (base_bs) {\n            blk_old_backing = blk_new(qemu_get_aio_context(),\n                                      BLK_PERM_CONSISTENT_READ,\n                                      BLK_PERM_ALL);\n            ret = blk_insert_bs(blk_old_backing, base_bs,\n                                &local_err);\n            if (ret < 0) {\n                error_reportf_err(local_err,\n                                  \"Could not reuse old backing file '%s': \",\n                                  base_bs->filename);\n                goto out;\n            }\n        } else {\n            blk_old_backing = NULL;\n        }\n\n        if (out_baseimg[0]) {\n            const char *overlay_filename;\n            char *out_real_path;\n\n            options = qdict_new();\n            if (out_basefmt) {\n                qdict_put_str(options, \"driver\", out_basefmt);\n            }\n            if (force_share) {\n                qdict_put_bool(options, BDRV_OPT_FORCE_SHARE, true);\n            }\n\n            bdrv_refresh_filename(bs);\n            overlay_filename = bs->exact_filename[0] ? bs->exact_filename\n                                                     : bs->filename;\n            out_real_path =\n                bdrv_get_full_backing_filename_from_filename(overlay_filename,\n                                                             out_baseimg,\n                                                             &local_err);\n            if (local_err) {\n                qobject_unref(options);\n                error_reportf_err(local_err,\n                                  \"Could not resolve backing filename: \");\n                ret = -1;\n                goto out;\n            }\n\n            /*\n             * Find out whether we rebase an image on top of a previous image\n             * in its chain.\n             */\n            prefix_chain_bs = bdrv_find_backing_image(bs, out_real_path);\n            if (prefix_chain_bs) {\n                qobject_unref(options);\n                g_free(out_real_path);\n\n                blk_new_backing = blk_new(qemu_get_aio_context(),\n                                          BLK_PERM_CONSISTENT_READ,\n                                          BLK_PERM_ALL);\n                ret = blk_insert_bs(blk_new_backing, prefix_chain_bs,\n                                    &local_err);\n                if (ret < 0) {\n                    error_reportf_err(local_err,\n                                      \"Could not reuse backing file '%s': \",\n                                      out_baseimg);\n                    goto out;\n                }\n            } else {\n                blk_new_backing = blk_new_open(out_real_path, NULL,\n                                               options, src_flags, &local_err);\n                g_free(out_real_path);\n                if (!blk_new_backing) {\n                    error_reportf_err(local_err,\n                                      \"Could not open new backing file '%s': \",\n                                      out_baseimg);\n                    ret = -1;\n                    goto out;\n                }\n            }\n        }\n    }\n\n    /*\n     * Check each unallocated cluster in the COW file. If it is unallocated,\n     * accesses go to the backing file. We must therefore compare this cluster\n     * in the old and new backing file, and if they differ we need to copy it\n     * from the old backing file into the COW file.\n     *\n     * If qemu-img crashes during this step, no harm is done. The content of\n     * the image is the same as the original one at any time.\n     */\n    if (!unsafe) {\n        int64_t size;\n        int64_t old_backing_size = 0;\n        int64_t new_backing_size = 0;\n        uint64_t offset;\n        int64_t n;\n        float local_progress = 0;\n\n        buf_old = blk_blockalign(blk, IO_BUF_SIZE);\n        buf_new = blk_blockalign(blk, IO_BUF_SIZE);\n\n        size = blk_getlength(blk);\n        if (size < 0) {\n            error_report(\"Could not get size of '%s': %s\",\n                         filename, strerror(-size));\n            ret = -1;\n            goto out;\n        }\n        if (blk_old_backing) {\n            old_backing_size = blk_getlength(blk_old_backing);\n            if (old_backing_size < 0) {\n                char backing_name[PATH_MAX];\n\n                bdrv_get_backing_filename(bs, backing_name,\n                                          sizeof(backing_name));\n                error_report(\"Could not get size of '%s': %s\",\n                             backing_name, strerror(-old_backing_size));\n                ret = -1;\n                goto out;\n            }\n        }\n        if (blk_new_backing) {\n            new_backing_size = blk_getlength(blk_new_backing);\n            if (new_backing_size < 0) {\n                error_report(\"Could not get size of '%s': %s\",\n                             out_baseimg, strerror(-new_backing_size));\n                ret = -1;\n                goto out;\n            }\n        }\n\n        if (size != 0) {\n            local_progress = (float)100 / (size / MIN(size, IO_BUF_SIZE));\n        }\n\n        for (offset = 0; offset < size; offset += n) {\n            bool buf_old_is_zero = false;\n\n            /* How many bytes can we handle with the next read? */\n            n = MIN(IO_BUF_SIZE, size - offset);\n\n            /* If the cluster is allocated, we don't need to take action */\n            ret = bdrv_is_allocated(unfiltered_bs, offset, n, &n);\n            if (ret < 0) {\n                error_report(\"error while reading image metadata: %s\",\n                             strerror(-ret));\n                goto out;\n            }\n            if (ret) {\n                continue;\n            }\n\n            if (prefix_chain_bs) {\n                /*\n                 * If cluster wasn't changed since prefix_chain, we don't need\n                 * to take action\n                 */\n                ret = bdrv_is_allocated_above(bdrv_cow_bs(unfiltered_bs),\n                                              prefix_chain_bs, false,\n                                              offset, n, &n);\n                if (ret < 0) {\n                    error_report(\"error while reading image metadata: %s\",\n                                 strerror(-ret));\n                    goto out;\n                }\n                if (!ret) {\n                    continue;\n                }\n            }\n\n            /*\n             * Read old and new backing file and take into consideration that\n             * backing files may be smaller than the COW image.\n             */\n            if (offset >= old_backing_size) {\n                memset(buf_old, 0, n);\n                buf_old_is_zero = true;\n            } else {\n                if (offset + n > old_backing_size) {\n                    n = old_backing_size - offset;\n                }\n\n                ret = blk_pread(blk_old_backing, offset, n, buf_old, 0);\n                if (ret < 0) {\n                    error_report(\"error while reading from old backing file\");\n                    goto out;\n                }\n            }\n\n            if (offset >= new_backing_size || !blk_new_backing) {\n                memset(buf_new, 0, n);\n            } else {\n                if (offset + n > new_backing_size) {\n                    n = new_backing_size - offset;\n                }\n\n                ret = blk_pread(blk_new_backing, offset, n, buf_new, 0);\n                if (ret < 0) {\n                    error_report(\"error while reading from new backing file\");\n                    goto out;\n                }\n            }\n\n            /* If they differ, we need to write to the COW file */\n            uint64_t written = 0;\n\n            while (written < n) {\n                int64_t pnum;\n\n                if (compare_buffers(buf_old + written, buf_new + written,\n                                    n - written, &pnum))\n                {\n                    if (buf_old_is_zero) {\n                        ret = blk_pwrite_zeroes(blk, offset + written, pnum, 0);\n                    } else {\n                        ret = blk_pwrite(blk, offset + written, pnum,\n                                         buf_old + written, 0);\n                    }\n                    if (ret < 0) {\n                        error_report(\"Error while writing to COW image: %s\",\n                            strerror(-ret));\n                        goto out;\n                    }\n                }\n\n                written += pnum;\n            }\n            qemu_progress_print(local_progress, 100);\n        }\n    }\n\n    /*\n     * Change the backing file. All clusters that are different from the old\n     * backing file are overwritten in the COW file now, so the visible content\n     * doesn't change when we switch the backing file.\n     */\n    if (out_baseimg && *out_baseimg) {\n        ret = bdrv_change_backing_file(unfiltered_bs, out_baseimg, out_basefmt,\n                                       true);\n    } else {\n        ret = bdrv_change_backing_file(unfiltered_bs, NULL, NULL, false);\n    }\n\n    if (ret == -ENOSPC) {\n        error_report(\"Could not change the backing file to '%s': No \"\n                     \"space left in the file header\", out_baseimg);\n    } else if (ret == -EINVAL && out_baseimg && !out_basefmt) {\n        error_report(\"Could not change the backing file to '%s': backing \"\n                     \"format must be specified\", out_baseimg);\n    } else if (ret < 0) {\n        error_report(\"Could not change the backing file to '%s': %s\",\n            out_baseimg, strerror(-ret));\n    }\n\n    qemu_progress_print(100, 0);\n    /*\n     * TODO At this point it is possible to check if any clusters that are\n     * allocated in the COW file are the same in the backing file. If so, they\n     * could be dropped from the COW file. Don't do this before switching the\n     * backing file, in case of a crash this would lead to corruption.\n     */\nout:\n    qemu_progress_end();\n    /* Cleanup */\n    if (!unsafe) {\n        blk_unref(blk_old_backing);\n        blk_unref(blk_new_backing);\n    }\n    qemu_vfree(buf_old);\n    qemu_vfree(buf_new);\n\n    blk_unref(blk);\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic int img_resize(int argc, char **argv)\n{\n    Error *err = NULL;\n    int c, ret, relative;\n    const char *filename, *fmt, *size;\n    int64_t n, total_size, current_size;\n    bool quiet = false;\n    BlockBackend *blk = NULL;\n    PreallocMode prealloc = PREALLOC_MODE_OFF;\n    QemuOpts *param;\n\n    static QemuOptsList resize_options = {\n        .name = \"resize_options\",\n        .head = QTAILQ_HEAD_INITIALIZER(resize_options.head),\n        .desc = {\n            {\n                .name = BLOCK_OPT_SIZE,\n                .type = QEMU_OPT_SIZE,\n                .help = \"Virtual disk size\"\n            }, {\n                /* end of list */\n            }\n        },\n    };\n    bool image_opts = false;\n    bool shrink = false;\n\n    /* Remove size from argv manually so that negative numbers are not treated\n     * as options by getopt. */\n    if (argc < 3) {\n        error_exit(\"Not enough arguments\");\n        return 1;\n    }\n\n    size = argv[--argc];\n\n    /* Parse getopt arguments */\n    fmt = NULL;\n    for(;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"preallocation\", required_argument, 0, OPTION_PREALLOCATION},\n            {\"shrink\", no_argument, 0, OPTION_SHRINK},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":f:hq\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n        switch(c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        case OPTION_PREALLOCATION:\n            prealloc = qapi_enum_parse(&PreallocMode_lookup, optarg,\n                                       PREALLOC_MODE__MAX, NULL);\n            if (prealloc == PREALLOC_MODE__MAX) {\n                error_report(\"Invalid preallocation mode '%s'\", optarg);\n                return 1;\n            }\n            break;\n        case OPTION_SHRINK:\n            shrink = true;\n            break;\n        }\n    }\n    if (optind != argc - 1) {\n        error_exit(\"Expecting image file name and size\");\n    }\n    filename = argv[optind++];\n\n    /* Choose grow, shrink, or absolute resize mode */\n    switch (size[0]) {\n    case '+':\n        relative = 1;\n        size++;\n        break;\n    case '-':\n        relative = -1;\n        size++;\n        break;\n    default:\n        relative = 0;\n        break;\n    }\n\n    /* Parse size */\n    param = qemu_opts_create(&resize_options, NULL, 0, &error_abort);\n    if (!qemu_opt_set(param, BLOCK_OPT_SIZE, size, &err)) {\n        error_report_err(err);\n        ret = -1;\n        qemu_opts_del(param);\n        goto out;\n    }\n    n = qemu_opt_get_size(param, BLOCK_OPT_SIZE, 0);\n    qemu_opts_del(param);\n\n    blk = img_open(image_opts, filename, fmt,\n                   BDRV_O_RDWR | BDRV_O_RESIZE, false, quiet,\n                   false);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n\n    current_size = blk_getlength(blk);\n    if (current_size < 0) {\n        error_report(\"Failed to inquire current image length: %s\",\n                     strerror(-current_size));\n        ret = -1;\n        goto out;\n    }\n\n    if (relative) {\n        total_size = current_size + n * relative;\n    } else {\n        total_size = n;\n    }\n    if (total_size <= 0) {\n        error_report(\"New image size must be positive\");\n        ret = -1;\n        goto out;\n    }\n\n    if (total_size <= current_size && prealloc != PREALLOC_MODE_OFF) {\n        error_report(\"Preallocation can only be used for growing images\");\n        ret = -1;\n        goto out;\n    }\n\n    if (total_size < current_size && !shrink) {\n        error_report(\"Use the --shrink option to perform a shrink operation.\");\n        warn_report(\"Shrinking an image will delete all data beyond the \"\n                    \"shrunken image's end. Before performing such an \"\n                    \"operation, make sure there is no important data there.\");\n        ret = -1;\n        goto out;\n    }\n\n    /*\n     * The user expects the image to have the desired size after\n     * resizing, so pass @exact=true.  It is of no use to report\n     * success when the image has not actually been resized.\n     */\n    ret = blk_truncate(blk, total_size, true, prealloc, 0, &err);\n    if (!ret) {\n        qprintf(quiet, \"Image resized.\\n\");\n    } else {\n        error_report_err(err);\n    }\nout:\n    blk_unref(blk);\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic void amend_status_cb(BlockDriverState *bs,\n                            int64_t offset, int64_t total_work_size,\n                            void *opaque)\n{\n    qemu_progress_print(100.f * offset / total_work_size, 0);\n}\n\nstatic int print_amend_option_help(const char *format)\n{\n    BlockDriver *drv;\n\n    /* Find driver and parse its options */\n    drv = bdrv_find_format(format);\n    if (!drv) {\n        error_report(\"Unknown file format '%s'\", format);\n        return 1;\n    }\n\n    if (!drv->bdrv_amend_options) {\n        error_report(\"Format driver '%s' does not support option amendment\",\n                     format);\n        return 1;\n    }\n\n    /* Every driver supporting amendment must have amend_opts */\n    assert(drv->amend_opts);\n\n    printf(\"Amend options for '%s':\\n\", format);\n    qemu_opts_print_help(drv->amend_opts, false);\n    return 0;\n}\n\nstatic int img_amend(int argc, char **argv)\n{\n    Error *err = NULL;\n    int c, ret = 0;\n    char *options = NULL;\n    QemuOptsList *amend_opts = NULL;\n    QemuOpts *opts = NULL;\n    const char *fmt = NULL, *filename, *cache;\n    int flags;\n    bool writethrough;\n    bool quiet = false, progress = false;\n    BlockBackend *blk = NULL;\n    BlockDriverState *bs = NULL;\n    bool image_opts = false;\n    bool force = false;\n\n    cache = BDRV_DEFAULT_CACHE;\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"force\", no_argument, 0, OPTION_FORCE},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":ho:f:t:pq\",\n                        long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'o':\n            if (accumulate_options(&options, optarg) < 0) {\n                ret = -1;\n                goto out_no_progress;\n            }\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 't':\n            cache = optarg;\n            break;\n        case 'p':\n            progress = true;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        case OPTION_FORCE:\n            force = true;\n            break;\n        }\n    }\n\n    if (!options) {\n        error_exit(\"Must specify options (-o)\");\n    }\n\n    if (quiet) {\n        progress = false;\n    }\n    qemu_progress_init(progress, 1.0);\n\n    filename = (optind == argc - 1) ? argv[argc - 1] : NULL;\n    if (fmt && has_help_option(options)) {\n        /* If a format is explicitly specified (and possibly no filename is\n         * given), print option help here */\n        ret = print_amend_option_help(fmt);\n        goto out;\n    }\n\n    if (optind != argc - 1) {\n        error_report(\"Expecting one image file name\");\n        ret = -1;\n        goto out;\n    }\n\n    flags = BDRV_O_RDWR;\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n    if (ret < 0) {\n        error_report(\"Invalid cache option: %s\", cache);\n        goto out;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet,\n                   false);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n    bs = blk_bs(blk);\n\n    fmt = bs->drv->format_name;\n\n    if (has_help_option(options)) {\n        /* If the format was auto-detected, print option help here */\n        ret = print_amend_option_help(fmt);\n        goto out;\n    }\n\n    if (!bs->drv->bdrv_amend_options) {\n        error_report(\"Format driver '%s' does not support option amendment\",\n                     fmt);\n        ret = -1;\n        goto out;\n    }\n\n    /* Every driver supporting amendment must have amend_opts */\n    assert(bs->drv->amend_opts);\n\n    amend_opts = qemu_opts_append(amend_opts, bs->drv->amend_opts);\n    opts = qemu_opts_create(amend_opts, NULL, 0, &error_abort);\n    if (!qemu_opts_do_parse(opts, options, NULL, &err)) {\n        /* Try to parse options using the create options */\n        amend_opts = qemu_opts_append(amend_opts, bs->drv->create_opts);\n        qemu_opts_del(opts);\n        opts = qemu_opts_create(amend_opts, NULL, 0, &error_abort);\n        if (qemu_opts_do_parse(opts, options, NULL, NULL)) {\n            error_append_hint(&err,\n                              \"This option is only supported for image creation\\n\");\n        }\n\n        error_report_err(err);\n        ret = -1;\n        goto out;\n    }\n\n    /* In case the driver does not call amend_status_cb() */\n    qemu_progress_print(0.f, 0);\n    ret = bdrv_amend_options(bs, opts, &amend_status_cb, NULL, force, &err);\n    qemu_progress_print(100.f, 0);\n    if (ret < 0) {\n        error_report_err(err);\n        goto out;\n    }\n\nout:\n    qemu_progress_end();\n\nout_no_progress:\n    blk_unref(blk);\n    qemu_opts_del(opts);\n    qemu_opts_free(amend_opts);\n    g_free(options);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\ntypedef struct BenchData {\n    BlockBackend *blk;\n    uint64_t image_size;\n    bool write;\n    int bufsize;\n    int step;\n    int nrreq;\n    int n;\n    int flush_interval;\n    bool drain_on_flush;\n    uint8_t *buf;\n    QEMUIOVector *qiov;\n\n    int in_flight;\n    bool in_flush;\n    uint64_t offset;\n} BenchData;\n\nstatic void bench_undrained_flush_cb(void *opaque, int ret)\n{\n    if (ret < 0) {\n        error_report(\"Failed flush request: %s\", strerror(-ret));\n        exit(EXIT_FAILURE);\n    }\n}\n\nstatic void bench_cb(void *opaque, int ret)\n{\n    BenchData *b = opaque;\n    BlockAIOCB *acb;\n\n    if (ret < 0) {\n        error_report(\"Failed request: %s\", strerror(-ret));\n        exit(EXIT_FAILURE);\n    }\n\n    if (b->in_flush) {\n        /* Just finished a flush with drained queue: Start next requests */\n        assert(b->in_flight == 0);\n        b->in_flush = false;\n    } else if (b->in_flight > 0) {\n        int remaining = b->n - b->in_flight;\n\n        b->n--;\n        b->in_flight--;\n\n        /* Time for flush? Drain queue if requested, then flush */\n        if (b->flush_interval && remaining % b->flush_interval == 0) {\n            if (!b->in_flight || !b->drain_on_flush) {\n                BlockCompletionFunc *cb;\n\n                if (b->drain_on_flush) {\n                    b->in_flush = true;\n                    cb = bench_cb;\n                } else {\n                    cb = bench_undrained_flush_cb;\n                }\n\n                acb = blk_aio_flush(b->blk, cb, b);\n                if (!acb) {\n                    error_report(\"Failed to issue flush request\");\n                    exit(EXIT_FAILURE);\n                }\n            }\n            if (b->drain_on_flush) {\n                return;\n            }\n        }\n    }\n\n    while (b->n > b->in_flight && b->in_flight < b->nrreq) {\n        int64_t offset = b->offset;\n        /* blk_aio_* might look for completed I/Os and kick bench_cb\n         * again, so make sure this operation is counted by in_flight\n         * and b->offset is ready for the next submission.\n         */\n        b->in_flight++;\n        b->offset += b->step;\n        b->offset %= b->image_size;\n        if (b->write) {\n            acb = blk_aio_pwritev(b->blk, offset, b->qiov, 0, bench_cb, b);\n        } else {\n            acb = blk_aio_preadv(b->blk, offset, b->qiov, 0, bench_cb, b);\n        }\n        if (!acb) {\n            error_report(\"Failed to issue request\");\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n\nstatic int img_bench(int argc, char **argv)\n{\n    int c, ret = 0;\n    const char *fmt = NULL, *filename;\n    bool quiet = false;\n    bool image_opts = false;\n    bool is_write = false;\n    int count = 75000;\n    int depth = 64;\n    int64_t offset = 0;\n    size_t bufsize = 4096;\n    int pattern = 0;\n    size_t step = 0;\n    int flush_interval = 0;\n    bool drain_on_flush = true;\n    int64_t image_size;\n    BlockBackend *blk = NULL;\n    BenchData data = {};\n    int flags = 0;\n    bool writethrough = false;\n    struct timeval t1, t2;\n    int i;\n    bool force_share = false;\n    size_t buf_size;\n\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"flush-interval\", required_argument, 0, OPTION_FLUSH_INTERVAL},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"pattern\", required_argument, 0, OPTION_PATTERN},\n            {\"no-drain\", no_argument, 0, OPTION_NO_DRAIN},\n            {\"force-share\", no_argument, 0, 'U'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":hc:d:f:ni:o:qs:S:t:wU\", long_options,\n                        NULL);\n        if (c == -1) {\n            break;\n        }\n\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'c':\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > INT_MAX) {\n                error_report(\"Invalid request count specified\");\n                return 1;\n            }\n            count = res;\n            break;\n        }\n        case 'd':\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > INT_MAX) {\n                error_report(\"Invalid queue depth specified\");\n                return 1;\n            }\n            depth = res;\n            break;\n        }\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'n':\n            flags |= BDRV_O_NATIVE_AIO;\n            break;\n        case 'i':\n            ret = bdrv_parse_aio(optarg, &flags);\n            if (ret < 0) {\n                error_report(\"Invalid aio option: %s\", optarg);\n                ret = -1;\n                goto out;\n            }\n            break;\n        case 'o':\n        {\n            offset = cvtnum(\"offset\", optarg);\n            if (offset < 0) {\n                return 1;\n            }\n            break;\n        }\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case 's':\n        {\n            int64_t sval;\n\n            sval = cvtnum_full(\"buffer size\", optarg, 0, INT_MAX);\n            if (sval < 0) {\n                return 1;\n            }\n\n            bufsize = sval;\n            break;\n        }\n        case 'S':\n        {\n            int64_t sval;\n\n            sval = cvtnum_full(\"step_size\", optarg, 0, INT_MAX);\n            if (sval < 0) {\n                return 1;\n            }\n\n            step = sval;\n            break;\n        }\n        case 't':\n            ret = bdrv_parse_cache_mode(optarg, &flags, &writethrough);\n            if (ret < 0) {\n                error_report(\"Invalid cache mode\");\n                ret = -1;\n                goto out;\n            }\n            break;\n        case 'w':\n            flags |= BDRV_O_RDWR;\n            is_write = true;\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_PATTERN:\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > 0xff) {\n                error_report(\"Invalid pattern byte specified\");\n                return 1;\n            }\n            pattern = res;\n            break;\n        }\n        case OPTION_FLUSH_INTERVAL:\n        {\n            unsigned long res;\n\n            if (qemu_strtoul(optarg, NULL, 0, &res) < 0 || res > INT_MAX) {\n                error_report(\"Invalid flush interval specified\");\n                return 1;\n            }\n            flush_interval = res;\n            break;\n        }\n        case OPTION_NO_DRAIN:\n            drain_on_flush = false;\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (optind != argc - 1) {\n        error_exit(\"Expecting one image file name\");\n    }\n    filename = argv[argc - 1];\n\n    if (!is_write && flush_interval) {\n        error_report(\"--flush-interval is only available in write tests\");\n        ret = -1;\n        goto out;\n    }\n    if (flush_interval && flush_interval < depth) {\n        error_report(\"Flush interval can't be smaller than depth\");\n        ret = -1;\n        goto out;\n    }\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet,\n                   force_share);\n    if (!blk) {\n        ret = -1;\n        goto out;\n    }\n\n    image_size = blk_getlength(blk);\n    if (image_size < 0) {\n        ret = image_size;\n        goto out;\n    }\n\n    data = (BenchData) {\n        .blk            = blk,\n        .image_size     = image_size,\n        .bufsize        = bufsize,\n        .step           = step ?: bufsize,\n        .nrreq          = depth,\n        .n              = count,\n        .offset         = offset,\n        .write          = is_write,\n        .flush_interval = flush_interval,\n        .drain_on_flush = drain_on_flush,\n    };\n    printf(\"Sending %d %s requests, %d bytes each, %d in parallel \"\n           \"(starting at offset %\" PRId64 \", step size %d)\\n\",\n           data.n, data.write ? \"write\" : \"read\", data.bufsize, data.nrreq,\n           data.offset, data.step);\n    if (flush_interval) {\n        printf(\"Sending flush every %d requests\\n\", flush_interval);\n    }\n\n    buf_size = data.nrreq * data.bufsize;\n    data.buf = blk_blockalign(blk, buf_size);\n    memset(data.buf, pattern, data.nrreq * data.bufsize);\n\n    blk_register_buf(blk, data.buf, buf_size);\n\n    data.qiov = g_new(QEMUIOVector, data.nrreq);\n    for (i = 0; i < data.nrreq; i++) {\n        qemu_iovec_init(&data.qiov[i], 1);\n        qemu_iovec_add(&data.qiov[i],\n                       data.buf + i * data.bufsize, data.bufsize);\n    }\n\n    gettimeofday(&t1, NULL);\n    bench_cb(&data, 0);\n\n    while (data.n > 0) {\n        main_loop_wait(false);\n    }\n    gettimeofday(&t2, NULL);\n\n    printf(\"Run completed in %3.3f seconds.\\n\",\n           (t2.tv_sec - t1.tv_sec)\n           + ((double)(t2.tv_usec - t1.tv_usec) / 1000000));\n\nout:\n    if (data.buf) {\n        blk_unregister_buf(blk, data.buf);\n    }\n    qemu_vfree(data.buf);\n    blk_unref(blk);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nenum ImgBitmapAct {\n    BITMAP_ADD,\n    BITMAP_REMOVE,\n    BITMAP_CLEAR,\n    BITMAP_ENABLE,\n    BITMAP_DISABLE,\n    BITMAP_MERGE,\n};\ntypedef struct ImgBitmapAction {\n    enum ImgBitmapAct act;\n    const char *src; /* only used for merge */\n    QSIMPLEQ_ENTRY(ImgBitmapAction) next;\n} ImgBitmapAction;\n\nstatic int img_bitmap(int argc, char **argv)\n{\n    Error *err = NULL;\n    int c, ret = 1;\n    QemuOpts *opts = NULL;\n    const char *fmt = NULL, *src_fmt = NULL, *src_filename = NULL;\n    const char *filename, *bitmap;\n    BlockBackend *blk = NULL, *src = NULL;\n    BlockDriverState *bs = NULL, *src_bs = NULL;\n    bool image_opts = false;\n    int64_t granularity = 0;\n    bool add = false, merge = false;\n    QSIMPLEQ_HEAD(, ImgBitmapAction) actions;\n    ImgBitmapAction *act, *act_next;\n    const char *op;\n\n    QSIMPLEQ_INIT(&actions);\n\n    for (;;) {\n        static const struct option long_options[] = {\n            {\"help\", no_argument, 0, 'h'},\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n            {\"add\", no_argument, 0, OPTION_ADD},\n            {\"remove\", no_argument, 0, OPTION_REMOVE},\n            {\"clear\", no_argument, 0, OPTION_CLEAR},\n            {\"enable\", no_argument, 0, OPTION_ENABLE},\n            {\"disable\", no_argument, 0, OPTION_DISABLE},\n            {\"merge\", required_argument, 0, OPTION_MERGE},\n            {\"granularity\", required_argument, 0, 'g'},\n            {\"source-file\", required_argument, 0, 'b'},\n            {\"source-format\", required_argument, 0, 'F'},\n            {0, 0, 0, 0}\n        };\n        c = getopt_long(argc, argv, \":b:f:F:g:h\", long_options, NULL);\n        if (c == -1) {\n            break;\n        }\n\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'b':\n            src_filename = optarg;\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'F':\n            src_fmt = optarg;\n            break;\n        case 'g':\n            granularity = cvtnum(\"granularity\", optarg);\n            if (granularity < 0) {\n                return 1;\n            }\n            break;\n        case OPTION_ADD:\n            act = g_new0(ImgBitmapAction, 1);\n            act->act = BITMAP_ADD;\n            QSIMPLEQ_INSERT_TAIL(&actions, act, next);\n            add = true;\n            break;\n        case OPTION_REMOVE:\n            act = g_new0(ImgBitmapAction, 1);\n            act->act = BITMAP_REMOVE;\n            QSIMPLEQ_INSERT_TAIL(&actions, act, next);\n            break;\n        case OPTION_CLEAR:\n            act = g_new0(ImgBitmapAction, 1);\n            act->act = BITMAP_CLEAR;\n            QSIMPLEQ_INSERT_TAIL(&actions, act, next);\n            break;\n        case OPTION_ENABLE:\n            act = g_new0(ImgBitmapAction, 1);\n            act->act = BITMAP_ENABLE;\n            QSIMPLEQ_INSERT_TAIL(&actions, act, next);\n            break;\n        case OPTION_DISABLE:\n            act = g_new0(ImgBitmapAction, 1);\n            act->act = BITMAP_DISABLE;\n            QSIMPLEQ_INSERT_TAIL(&actions, act, next);\n            break;\n        case OPTION_MERGE:\n            act = g_new0(ImgBitmapAction, 1);\n            act->act = BITMAP_MERGE;\n            act->src = optarg;\n            QSIMPLEQ_INSERT_TAIL(&actions, act, next);\n            merge = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    if (QSIMPLEQ_EMPTY(&actions)) {\n        error_report(\"Need at least one of --add, --remove, --clear, \"\n                     \"--enable, --disable, or --merge\");\n        goto out;\n    }\n\n    if (granularity && !add) {\n        error_report(\"granularity only supported with --add\");\n        goto out;\n    }\n    if (src_fmt && !src_filename) {\n        error_report(\"-F only supported with -b\");\n        goto out;\n    }\n    if (src_filename && !merge) {\n        error_report(\"Merge bitmap source file only supported with \"\n                     \"--merge\");\n        goto out;\n    }\n\n    if (optind != argc - 2) {\n        error_report(\"Expecting filename and bitmap name\");\n        goto out;\n    }\n\n    filename = argv[optind];\n    bitmap = argv[optind + 1];\n\n    /*\n     * No need to open backing chains; we will be manipulating bitmaps\n     * directly in this image without reference to image contents.\n     */\n    blk = img_open(image_opts, filename, fmt, BDRV_O_RDWR | BDRV_O_NO_BACKING,\n                   false, false, false);\n    if (!blk) {\n        goto out;\n    }\n    bs = blk_bs(blk);\n    if (src_filename) {\n        src = img_open(false, src_filename, src_fmt, BDRV_O_NO_BACKING,\n                       false, false, false);\n        if (!src) {\n            goto out;\n        }\n        src_bs = blk_bs(src);\n    } else {\n        src_bs = bs;\n    }\n\n    QSIMPLEQ_FOREACH_SAFE(act, &actions, next, act_next) {\n        switch (act->act) {\n        case BITMAP_ADD:\n            qmp_block_dirty_bitmap_add(bs->node_name, bitmap,\n                                       !!granularity, granularity, true, true,\n                                       false, false, &err);\n            op = \"add\";\n            break;\n        case BITMAP_REMOVE:\n            qmp_block_dirty_bitmap_remove(bs->node_name, bitmap, &err);\n            op = \"remove\";\n            break;\n        case BITMAP_CLEAR:\n            qmp_block_dirty_bitmap_clear(bs->node_name, bitmap, &err);\n            op = \"clear\";\n            break;\n        case BITMAP_ENABLE:\n            qmp_block_dirty_bitmap_enable(bs->node_name, bitmap, &err);\n            op = \"enable\";\n            break;\n        case BITMAP_DISABLE:\n            qmp_block_dirty_bitmap_disable(bs->node_name, bitmap, &err);\n            op = \"disable\";\n            break;\n        case BITMAP_MERGE:\n            do_dirty_bitmap_merge(bs->node_name, bitmap, src_bs->node_name,\n                                  act->src, &err);\n            op = \"merge\";\n            break;\n        default:\n            g_assert_not_reached();\n        }\n\n        if (err) {\n            error_reportf_err(err, \"Operation %s on bitmap %s failed: \",\n                              op, bitmap);\n            goto out;\n        }\n        g_free(act);\n    }\n\n    ret = 0;\n\n out:\n    blk_unref(src);\n    blk_unref(blk);\n    qemu_opts_del(opts);\n    return ret;\n}\n\n#define C_BS      01\n#define C_COUNT   02\n#define C_IF      04\n#define C_OF      010\n#define C_SKIP    020\n\nstruct DdInfo {\n    unsigned int flags;\n    int64_t count;\n};\n\nstruct DdIo {\n    int bsz;    /* Block size */\n    char *filename;\n    uint8_t *buf;\n    int64_t offset;\n};\n\nstruct DdOpts {\n    const char *name;\n    int (*f)(const char *, struct DdIo *, struct DdIo *, struct DdInfo *);\n    unsigned int flag;\n};\n\nstatic int img_dd_bs(const char *arg,\n                     struct DdIo *in, struct DdIo *out,\n                     struct DdInfo *dd)\n{\n    int64_t res;\n\n    res = cvtnum_full(\"bs\", arg, 1, INT_MAX);\n\n    if (res < 0) {\n        return 1;\n    }\n    in->bsz = out->bsz = res;\n\n    return 0;\n}\n\nstatic int img_dd_count(const char *arg,\n                        struct DdIo *in, struct DdIo *out,\n                        struct DdInfo *dd)\n{\n    dd->count = cvtnum(\"count\", arg);\n\n    if (dd->count < 0) {\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int img_dd_if(const char *arg,\n                     struct DdIo *in, struct DdIo *out,\n                     struct DdInfo *dd)\n{\n    in->filename = g_strdup(arg);\n\n    return 0;\n}\n\nstatic int img_dd_of(const char *arg,\n                     struct DdIo *in, struct DdIo *out,\n                     struct DdInfo *dd)\n{\n    out->filename = g_strdup(arg);\n\n    return 0;\n}\n\nstatic int img_dd_skip(const char *arg,\n                       struct DdIo *in, struct DdIo *out,\n                       struct DdInfo *dd)\n{\n    in->offset = cvtnum(\"skip\", arg);\n\n    if (in->offset < 0) {\n        return 1;\n    }\n\n    return 0;\n}\n\nstatic int img_dd(int argc, char **argv)\n{\n    int ret = 0;\n    char *arg = NULL;\n    char *tmp;\n    BlockDriver *drv = NULL, *proto_drv = NULL;\n    BlockBackend *blk1 = NULL, *blk2 = NULL;\n    QemuOpts *opts = NULL;\n    QemuOptsList *create_opts = NULL;\n    Error *local_err = NULL;\n    bool image_opts = false;\n    int c, i;\n    const char *out_fmt = \"raw\";\n    const char *fmt = NULL;\n    int64_t size = 0;\n    int64_t block_count = 0, out_pos, in_pos;\n    bool force_share = false;\n    struct DdInfo dd = {\n        .flags = 0,\n        .count = 0,\n    };\n    struct DdIo in = {\n        .bsz = 512, /* Block size is by default 512 bytes */\n        .filename = NULL,\n        .buf = NULL,\n        .offset = 0\n    };\n    struct DdIo out = {\n        .bsz = 512,\n        .filename = NULL,\n        .buf = NULL,\n        .offset = 0\n    };\n\n    const struct DdOpts options[] = {\n        { \"bs\", img_dd_bs, C_BS },\n        { \"count\", img_dd_count, C_COUNT },\n        { \"if\", img_dd_if, C_IF },\n        { \"of\", img_dd_of, C_OF },\n        { \"skip\", img_dd_skip, C_SKIP },\n        { NULL, NULL, 0 }\n    };\n    const struct option long_options[] = {\n        { \"help\", no_argument, 0, 'h'},\n        { \"object\", required_argument, 0, OPTION_OBJECT},\n        { \"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n        { \"force-share\", no_argument, 0, 'U'},\n        { 0, 0, 0, 0 }\n    };\n\n    while ((c = getopt_long(argc, argv, \":hf:O:U\", long_options, NULL))) {\n        if (c == EOF) {\n            break;\n        }\n        switch (c) {\n        case 'O':\n            out_fmt = optarg;\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case ':':\n            missing_argument(argv[optind - 1]);\n            break;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            break;\n        case 'h':\n            help();\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        }\n    }\n\n    for (i = optind; i < argc; i++) {\n        int j;\n        arg = g_strdup(argv[i]);\n\n        tmp = strchr(arg, '=');\n        if (tmp == NULL) {\n            error_report(\"unrecognized operand %s\", arg);\n            ret = -1;\n            goto out;\n        }\n\n        *tmp++ = '\\0';\n\n        for (j = 0; options[j].name != NULL; j++) {\n            if (!strcmp(arg, options[j].name)) {\n                break;\n            }\n        }\n        if (options[j].name == NULL) {\n            error_report(\"unrecognized operand %s\", arg);\n            ret = -1;\n            goto out;\n        }\n\n        if (options[j].f(tmp, &in, &out, &dd) != 0) {\n            ret = -1;\n            goto out;\n        }\n        dd.flags |= options[j].flag;\n        g_free(arg);\n        arg = NULL;\n    }\n\n    if (!(dd.flags & C_IF && dd.flags & C_OF)) {\n        error_report(\"Must specify both input and output files\");\n        ret = -1;\n        goto out;\n    }\n\n    blk1 = img_open(image_opts, in.filename, fmt, 0, false, false,\n                    force_share);\n\n    if (!blk1) {\n        ret = -1;\n        goto out;\n    }\n\n    drv = bdrv_find_format(out_fmt);\n    if (!drv) {\n        error_report(\"Unknown file format\");\n        ret = -1;\n        goto out;\n    }\n    proto_drv = bdrv_find_protocol(out.filename, true, &local_err);\n\n    if (!proto_drv) {\n        error_report_err(local_err);\n        ret = -1;\n        goto out;\n    }\n    if (!drv->create_opts) {\n        error_report(\"Format driver '%s' does not support image creation\",\n                     drv->format_name);\n        ret = -1;\n        goto out;\n    }\n    if (!proto_drv->create_opts) {\n        error_report(\"Protocol driver '%s' does not support image creation\",\n                     proto_drv->format_name);\n        ret = -1;\n        goto out;\n    }\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    create_opts = qemu_opts_append(create_opts, proto_drv->create_opts);\n\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n\n    size = blk_getlength(blk1);\n    if (size < 0) {\n        error_report(\"Failed to get size for '%s'\", in.filename);\n        ret = -1;\n        goto out;\n    }\n\n    if (dd.flags & C_COUNT && dd.count <= INT64_MAX / in.bsz &&\n        dd.count * in.bsz < size) {\n        size = dd.count * in.bsz;\n    }\n\n    /* Overflow means the specified offset is beyond input image's size */\n    if (dd.flags & C_SKIP && (in.offset > INT64_MAX / in.bsz ||\n                              size < in.bsz * in.offset)) {\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE, 0, &error_abort);\n    } else {\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE,\n                            size - in.bsz * in.offset, &error_abort);\n    }\n\n    ret = bdrv_create(drv, out.filename, opts, &local_err);\n    if (ret < 0) {\n        error_reportf_err(local_err,\n                          \"%s: error while creating output image: \",\n                          out.filename);\n        ret = -1;\n        goto out;\n    }\n\n    /* TODO, we can't honour --image-opts for the target,\n     * since it needs to be given in a format compatible\n     * with the bdrv_create() call above which does not\n     * support image-opts style.\n     */\n    blk2 = img_open_file(out.filename, NULL, out_fmt, BDRV_O_RDWR,\n                         false, false, false);\n\n    if (!blk2) {\n        ret = -1;\n        goto out;\n    }\n\n    if (dd.flags & C_SKIP && (in.offset > INT64_MAX / in.bsz ||\n                              size < in.offset * in.bsz)) {\n        /* We give a warning if the skip option is bigger than the input\n         * size and create an empty output disk image (i.e. like dd(1)).\n         */\n        error_report(\"%s: cannot skip to specified offset\", in.filename);\n        in_pos = size;\n    } else {\n        in_pos = in.offset * in.bsz;\n    }\n\n    in.buf = g_new(uint8_t, in.bsz);\n\n    for (out_pos = 0; in_pos < size; block_count++) {\n        int bytes = (in_pos + in.bsz > size) ? size - in_pos : in.bsz;\n\n        ret = blk_pread(blk1, in_pos, bytes, in.buf, 0);\n        if (ret < 0) {\n            error_report(\"error while reading from input image file: %s\",\n                         strerror(-ret));\n            goto out;\n        }\n        in_pos += bytes;\n\n        ret = blk_pwrite(blk2, out_pos, bytes, in.buf, 0);\n        if (ret < 0) {\n            error_report(\"error while writing to output image file: %s\",\n                         strerror(-ret));\n            goto out;\n        }\n        out_pos += bytes;\n    }\n\nout:\n    g_free(arg);\n    qemu_opts_del(opts);\n    qemu_opts_free(create_opts);\n    blk_unref(blk1);\n    blk_unref(blk2);\n    g_free(in.filename);\n    g_free(out.filename);\n    g_free(in.buf);\n    g_free(out.buf);\n\n    if (ret) {\n        return 1;\n    }\n    return 0;\n}\n\nstatic void dump_json_block_measure_info(BlockMeasureInfo *info)\n{\n    GString *str;\n    QObject *obj;\n    Visitor *v = qobject_output_visitor_new(&obj);\n\n    visit_type_BlockMeasureInfo(v, NULL, &info, &error_abort);\n    visit_complete(v, &obj);\n    str = qobject_to_json_pretty(obj, true);\n    assert(str != NULL);\n    printf(\"%s\\n\", str->str);\n    qobject_unref(obj);\n    visit_free(v);\n    g_string_free(str, true);\n}\n\nstatic int img_measure(int argc, char **argv)\n{\n    static const struct option long_options[] = {\n        {\"help\", no_argument, 0, 'h'},\n        {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n        {\"object\", required_argument, 0, OPTION_OBJECT},\n        {\"output\", required_argument, 0, OPTION_OUTPUT},\n        {\"size\", required_argument, 0, OPTION_SIZE},\n        {\"force-share\", no_argument, 0, 'U'},\n        {0, 0, 0, 0}\n    };\n    OutputFormat output_format = OFORMAT_HUMAN;\n    BlockBackend *in_blk = NULL;\n    BlockDriver *drv;\n    const char *filename = NULL;\n    const char *fmt = NULL;\n    const char *out_fmt = \"raw\";\n    char *options = NULL;\n    char *snapshot_name = NULL;\n    bool force_share = false;\n    QemuOpts *opts = NULL;\n    QemuOpts *object_opts = NULL;\n    QemuOpts *sn_opts = NULL;\n    QemuOptsList *create_opts = NULL;\n    bool image_opts = false;\n    uint64_t img_size = UINT64_MAX;\n    BlockMeasureInfo *info = NULL;\n    Error *local_err = NULL;\n    int ret = 1;\n    int c;\n\n    while ((c = getopt_long(argc, argv, \"hf:O:o:l:U\",\n                            long_options, NULL)) != -1) {\n        switch (c) {\n        case '?':\n        case 'h':\n            help();\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 'O':\n            out_fmt = optarg;\n            break;\n        case 'o':\n            if (accumulate_options(&options, optarg) < 0) {\n                goto out;\n            }\n            break;\n        case 'l':\n            if (strstart(optarg, SNAPSHOT_OPT_BASE, NULL)) {\n                sn_opts = qemu_opts_parse_noisily(&internal_snapshot_opts,\n                                                  optarg, false);\n                if (!sn_opts) {\n                    error_report(\"Failed in parsing snapshot param '%s'\",\n                                 optarg);\n                    goto out;\n                }\n            } else {\n                snapshot_name = optarg;\n            }\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            image_opts = true;\n            break;\n        case OPTION_OUTPUT:\n            if (!strcmp(optarg, \"json\")) {\n                output_format = OFORMAT_JSON;\n            } else if (!strcmp(optarg, \"human\")) {\n                output_format = OFORMAT_HUMAN;\n            } else {\n                error_report(\"--output must be used with human or json \"\n                             \"as argument.\");\n                goto out;\n            }\n            break;\n        case OPTION_SIZE:\n        {\n            int64_t sval;\n\n            sval = cvtnum(\"image size\", optarg);\n            if (sval < 0) {\n                goto out;\n            }\n            img_size = (uint64_t)sval;\n        }\n        break;\n        }\n    }\n\n    if (argc - optind > 1) {\n        error_report(\"At most one filename argument is allowed.\");\n        goto out;\n    } else if (argc - optind == 1) {\n        filename = argv[optind];\n    }\n\n    if (!filename && (image_opts || fmt || snapshot_name || sn_opts)) {\n        error_report(\"--image-opts, -f, and -l require a filename argument.\");\n        goto out;\n    }\n    if (filename && img_size != UINT64_MAX) {\n        error_report(\"--size N cannot be used together with a filename.\");\n        goto out;\n    }\n    if (!filename && img_size == UINT64_MAX) {\n        error_report(\"Either --size N or one filename must be specified.\");\n        goto out;\n    }\n\n    if (filename) {\n        in_blk = img_open(image_opts, filename, fmt, 0,\n                          false, false, force_share);\n        if (!in_blk) {\n            goto out;\n        }\n\n        if (sn_opts) {\n            bdrv_snapshot_load_tmp(blk_bs(in_blk),\n                    qemu_opt_get(sn_opts, SNAPSHOT_OPT_ID),\n                    qemu_opt_get(sn_opts, SNAPSHOT_OPT_NAME),\n                    &local_err);\n        } else if (snapshot_name != NULL) {\n            bdrv_snapshot_load_tmp_by_id_or_name(blk_bs(in_blk),\n                    snapshot_name, &local_err);\n        }\n        if (local_err) {\n            error_reportf_err(local_err, \"Failed to load snapshot: \");\n            goto out;\n        }\n    }\n\n    drv = bdrv_find_format(out_fmt);\n    if (!drv) {\n        error_report(\"Unknown file format '%s'\", out_fmt);\n        goto out;\n    }\n    if (!drv->create_opts) {\n        error_report(\"Format driver '%s' does not support image creation\",\n                     drv->format_name);\n        goto out;\n    }\n\n    create_opts = qemu_opts_append(create_opts, drv->create_opts);\n    create_opts = qemu_opts_append(create_opts, bdrv_file.create_opts);\n    opts = qemu_opts_create(create_opts, NULL, 0, &error_abort);\n    if (options) {\n        if (!qemu_opts_do_parse(opts, options, NULL, &local_err)) {\n            error_report_err(local_err);\n            error_report(\"Invalid options for file format '%s'\", out_fmt);\n            goto out;\n        }\n    }\n    if (img_size != UINT64_MAX) {\n        qemu_opt_set_number(opts, BLOCK_OPT_SIZE, img_size, &error_abort);\n    }\n\n    info = bdrv_measure(drv, opts, in_blk ? blk_bs(in_blk) : NULL, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        goto out;\n    }\n\n    if (output_format == OFORMAT_HUMAN) {\n        printf(\"required size: %\" PRIu64 \"\\n\", info->required);\n        printf(\"fully allocated size: %\" PRIu64 \"\\n\", info->fully_allocated);\n        if (info->has_bitmaps) {\n            printf(\"bitmaps size: %\" PRIu64 \"\\n\", info->bitmaps);\n        }\n    } else {\n        dump_json_block_measure_info(info);\n    }\n\n    ret = 0;\n\nout:\n    qapi_free_BlockMeasureInfo(info);\n    qemu_opts_del(object_opts);\n    qemu_opts_del(opts);\n    qemu_opts_del(sn_opts);\n    qemu_opts_free(create_opts);\n    g_free(options);\n    blk_unref(in_blk);\n    return ret;\n}\n\nstatic const img_cmd_t img_cmds[] = {\n#define DEF(option, callback, arg_string)        \\\n    { option, callback },\n#include \"qemu-img-cmds.h\"\n#undef DEF\n    { NULL, NULL, },\n};\n\nint main(int argc, char **argv)\n{\n    const img_cmd_t *cmd;\n    const char *cmdname;\n    int c;\n    static const struct option long_options[] = {\n        {\"help\", no_argument, 0, 'h'},\n        {\"version\", no_argument, 0, 'V'},\n        {\"trace\", required_argument, NULL, 'T'},\n        {0, 0, 0, 0}\n    };\n\n#ifdef CONFIG_POSIX\n    signal(SIGPIPE, SIG_IGN);\n#endif\n\n    socket_init();\n    error_init(argv[0]);\n    module_call_init(MODULE_INIT_TRACE);\n    qemu_init_exec_dir(argv[0]);\n\n    qemu_init_main_loop(&error_fatal);\n\n    qcrypto_init(&error_fatal);\n\n    module_call_init(MODULE_INIT_QOM);\n    bdrv_init();\n    if (argc < 2) {\n        error_exit(\"Not enough arguments\");\n    }\n\n    qemu_add_opts(&qemu_source_opts);\n    qemu_add_opts(&qemu_trace_opts);\n\n    while ((c = getopt_long(argc, argv, \"+:hVT:\", long_options, NULL)) != -1) {\n        switch (c) {\n        case ':':\n            missing_argument(argv[optind - 1]);\n            return 0;\n        case '?':\n            unrecognized_option(argv[optind - 1]);\n            return 0;\n        case 'h':\n            help();\n            return 0;\n        case 'V':\n            printf(QEMU_IMG_VERSION);\n            return 0;\n        case 'T':\n            trace_opt_parse(optarg);\n            break;\n        }\n    }\n\n    cmdname = argv[optind];\n\n    /* reset getopt_long scanning */\n    argc -= optind;\n    if (argc < 1) {\n        return 0;\n    }\n    argv += optind;\n    qemu_reset_optind();\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file();\n    qemu_set_log(LOG_TRACE, &error_fatal);\n\n    /* find the command */\n    for (cmd = img_cmds; cmd->name != NULL; cmd++) {\n        if (!strcmp(cmdname, cmd->name)) {\n            return cmd->handler(argc, argv);\n        }\n    }\n\n    /* not found */\n    error_exit(\"Command not found: %s\", cmdname);\n}\n"
        },
        {
          "name": "qemu-io-cmds.c",
          "type": "blob",
          "size": 64.6953125,
          "content": "/*\n * Command line utility to exercise the QEMU I/O path.\n *\n * Copyright (C) 2009-2016 Red Hat, Inc.\n * Copyright (c) 2003-2005 Silicon Graphics, Inc.\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"qapi/qmp/qdict.h\"\n#include \"qemu-io.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block.h\"\n#include \"block/block_int.h\" /* for info_f() */\n#include \"block/qapi.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/option.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/cutils.h\"\n#include \"qemu/memalign.h\"\n\n#define CMD_NOFILE_OK   0x01\n\nbool qemuio_misalign;\n\nstatic cmdinfo_t *cmdtab;\nstatic int ncmds;\n\nstatic int compare_cmdname(const void *a, const void *b)\n{\n    return strcmp(((const cmdinfo_t *)a)->name,\n                  ((const cmdinfo_t *)b)->name);\n}\n\nvoid qemuio_add_command(const cmdinfo_t *ci)\n{\n    /* ci->perm assumes a file is open, but the GLOBAL and NOFILE_OK\n     * flags allow it not to be, so that combination is invalid.\n     * Catch it now rather than letting it manifest as a crash if a\n     * particular set of command line options are used.\n     */\n    assert(ci->perm == 0 ||\n           (ci->flags & (CMD_FLAG_GLOBAL | CMD_NOFILE_OK)) == 0);\n    cmdtab = g_renew(cmdinfo_t, cmdtab, ++ncmds);\n    cmdtab[ncmds - 1] = *ci;\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare_cmdname);\n}\n\nvoid qemuio_command_usage(const cmdinfo_t *ci)\n{\n    printf(\"%s %s -- %s\\n\", ci->name, ci->args, ci->oneline);\n}\n\nstatic int init_check_command(BlockBackend *blk, const cmdinfo_t *ct)\n{\n    if (ct->flags & CMD_FLAG_GLOBAL) {\n        return 1;\n    }\n    if (!(ct->flags & CMD_NOFILE_OK) && !blk) {\n        fprintf(stderr, \"no file open, try 'help open'\\n\");\n        return 0;\n    }\n    return 1;\n}\n\nstatic int command(BlockBackend *blk, const cmdinfo_t *ct, int argc,\n                   char **argv)\n{\n    char *cmd = argv[0];\n\n    if (!init_check_command(blk, ct)) {\n        return -EINVAL;\n    }\n\n    if (argc - 1 < ct->argmin || (ct->argmax != -1 && argc - 1 > ct->argmax)) {\n        if (ct->argmax == -1) {\n            fprintf(stderr,\n                    \"bad argument count %d to %s, expected at least %d arguments\\n\",\n                    argc-1, cmd, ct->argmin);\n        } else if (ct->argmin == ct->argmax) {\n            fprintf(stderr,\n                    \"bad argument count %d to %s, expected %d arguments\\n\",\n                    argc-1, cmd, ct->argmin);\n        } else {\n            fprintf(stderr,\n                    \"bad argument count %d to %s, expected between %d and %d arguments\\n\",\n                    argc-1, cmd, ct->argmin, ct->argmax);\n        }\n        return -EINVAL;\n    }\n\n    /*\n     * Request additional permissions if necessary for this command. The caller\n     * is responsible for restoring the original permissions afterwards if this\n     * is what it wants.\n     *\n     * Coverity thinks that blk may be NULL in the following if condition. It's\n     * not so: in init_check_command() we fail if blk is NULL for command with\n     * both CMD_FLAG_GLOBAL and CMD_NOFILE_OK flags unset. And in\n     * qemuio_add_command() we assert that command with non-zero .perm field\n     * doesn't set this flags. So, the following assertion is to silence\n     * Coverity:\n     */\n    assert(blk || !ct->perm);\n    if (ct->perm && blk_is_available(blk)) {\n        uint64_t orig_perm, orig_shared_perm;\n        blk_get_perm(blk, &orig_perm, &orig_shared_perm);\n\n        if (ct->perm & ~orig_perm) {\n            uint64_t new_perm;\n            Error *local_err = NULL;\n            int ret;\n\n            new_perm = orig_perm | ct->perm;\n\n            ret = blk_set_perm(blk, new_perm, orig_shared_perm, &local_err);\n            if (ret < 0) {\n                error_report_err(local_err);\n                return ret;\n            }\n        }\n    }\n\n    qemu_reset_optind();\n    return ct->cfunc(blk, argc, argv);\n}\n\nstatic const cmdinfo_t *find_command(const char *cmd)\n{\n    cmdinfo_t *ct;\n\n    for (ct = cmdtab; ct < &cmdtab[ncmds]; ct++) {\n        if (strcmp(ct->name, cmd) == 0 ||\n            (ct->altname && strcmp(ct->altname, cmd) == 0))\n        {\n            return (const cmdinfo_t *)ct;\n        }\n    }\n    return NULL;\n}\n\n/* Invoke fn() for commands with a matching prefix */\nvoid qemuio_complete_command(const char *input,\n                             void (*fn)(const char *cmd, void *opaque),\n                             void *opaque)\n{\n    cmdinfo_t *ct;\n    size_t input_len = strlen(input);\n\n    for (ct = cmdtab; ct < &cmdtab[ncmds]; ct++) {\n        if (strncmp(input, ct->name, input_len) == 0) {\n            fn(ct->name, opaque);\n        }\n    }\n}\n\nstatic char **breakline(char *input, int *count)\n{\n    int c = 0;\n    char *p;\n    char **rval = g_new0(char *, 1);\n\n    while (rval && (p = qemu_strsep(&input, \" \")) != NULL) {\n        if (!*p) {\n            continue;\n        }\n        c++;\n        rval = g_renew(char *, rval, (c + 1));\n        rval[c - 1] = p;\n        rval[c] = NULL;\n    }\n    *count = c;\n    return rval;\n}\n\nstatic int64_t cvtnum(const char *s)\n{\n    int err;\n    uint64_t value;\n\n    err = qemu_strtosz(s, NULL, &value);\n    if (err < 0) {\n        return err;\n    }\n    if (value > INT64_MAX) {\n        return -ERANGE;\n    }\n    return value;\n}\n\nstatic void print_cvtnum_err(int64_t rc, const char *arg)\n{\n    switch (rc) {\n    case -EINVAL:\n        printf(\"Parsing error: non-numeric argument,\"\n               \" or extraneous/unrecognized suffix -- %s\\n\", arg);\n        break;\n    case -ERANGE:\n        printf(\"Parsing error: argument too large -- %s\\n\", arg);\n        break;\n    default:\n        printf(\"Parsing error: %s\\n\", arg);\n    }\n}\n\n#define EXABYTES(x)     ((long long)(x) << 60)\n#define PETABYTES(x)    ((long long)(x) << 50)\n#define TERABYTES(x)    ((long long)(x) << 40)\n#define GIGABYTES(x)    ((long long)(x) << 30)\n#define MEGABYTES(x)    ((long long)(x) << 20)\n#define KILOBYTES(x)    ((long long)(x) << 10)\n\n#define TO_EXABYTES(x)  ((x) / EXABYTES(1))\n#define TO_PETABYTES(x) ((x) / PETABYTES(1))\n#define TO_TERABYTES(x) ((x) / TERABYTES(1))\n#define TO_GIGABYTES(x) ((x) / GIGABYTES(1))\n#define TO_MEGABYTES(x) ((x) / MEGABYTES(1))\n#define TO_KILOBYTES(x) ((x) / KILOBYTES(1))\n\nstatic void cvtstr(double value, char *str, size_t size)\n{\n    char *trim;\n    const char *suffix;\n\n    if (value >= EXABYTES(1)) {\n        suffix = \" EiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_EXABYTES(value));\n    } else if (value >= PETABYTES(1)) {\n        suffix = \" PiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_PETABYTES(value));\n    } else if (value >= TERABYTES(1)) {\n        suffix = \" TiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_TERABYTES(value));\n    } else if (value >= GIGABYTES(1)) {\n        suffix = \" GiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_GIGABYTES(value));\n    } else if (value >= MEGABYTES(1)) {\n        suffix = \" MiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_MEGABYTES(value));\n    } else if (value >= KILOBYTES(1)) {\n        suffix = \" KiB\";\n        snprintf(str, size - 4, \"%.3f\", TO_KILOBYTES(value));\n    } else {\n        suffix = \" bytes\";\n        snprintf(str, size - 6, \"%f\", value);\n    }\n\n    trim = strstr(str, \".000\");\n    if (trim) {\n        strcpy(trim, suffix);\n    } else {\n        strcat(str, suffix);\n    }\n}\n\n\n\nstatic struct timespec tsub(struct timespec t1, struct timespec t2)\n{\n    t1.tv_nsec -= t2.tv_nsec;\n    if (t1.tv_nsec < 0) {\n        t1.tv_nsec += NANOSECONDS_PER_SECOND;\n        t1.tv_sec--;\n    }\n    t1.tv_sec -= t2.tv_sec;\n    return t1;\n}\n\nstatic double tdiv(double value, struct timespec tv)\n{\n    double seconds = tv.tv_sec + (tv.tv_nsec / 1e9);\n    return value / seconds;\n}\n\n#define HOURS(sec)      ((sec) / (60 * 60))\n#define MINUTES(sec)    (((sec) % (60 * 60)) / 60)\n#define SECONDS(sec)    ((sec) % 60)\n\nenum {\n    DEFAULT_TIME        = 0x0,\n    TERSE_FIXED_TIME    = 0x1,\n    VERBOSE_FIXED_TIME  = 0x2,\n};\n\nstatic void timestr(struct timespec *tv, char *ts, size_t size, int format)\n{\n    double frac_sec = tv->tv_nsec / 1e9;\n\n    if (format & TERSE_FIXED_TIME) {\n        if (!HOURS(tv->tv_sec)) {\n            snprintf(ts, size, \"%u:%05.2f\",\n                     (unsigned int) MINUTES(tv->tv_sec),\n                     SECONDS(tv->tv_sec) + frac_sec);\n            return;\n        }\n        format |= VERBOSE_FIXED_TIME; /* fallback if hours needed */\n    }\n\n    if ((format & VERBOSE_FIXED_TIME) || tv->tv_sec) {\n        snprintf(ts, size, \"%u:%02u:%05.2f\",\n                (unsigned int) HOURS(tv->tv_sec),\n                (unsigned int) MINUTES(tv->tv_sec),\n                 SECONDS(tv->tv_sec) + frac_sec);\n    } else {\n        snprintf(ts, size, \"%05.2f sec\", frac_sec);\n    }\n}\n\n/*\n * Parse the pattern argument to various sub-commands.\n *\n * Because the pattern is used as an argument to memset it must evaluate\n * to an unsigned integer that fits into a single byte.\n */\nstatic int parse_pattern(const char *arg)\n{\n    char *endptr = NULL;\n    long pattern;\n\n    pattern = strtol(arg, &endptr, 0);\n    if (pattern < 0 || pattern > UCHAR_MAX || *endptr != '\\0') {\n        printf(\"%s is not a valid pattern byte\\n\", arg);\n        return -1;\n    }\n\n    return pattern;\n}\n\n/*\n * Memory allocation helpers.\n *\n * Make sure memory is aligned by default, or purposefully misaligned if\n * that is specified on the command line.\n */\n\n#define MISALIGN_OFFSET     16\nstatic void *qemu_io_alloc(BlockBackend *blk, size_t len, int pattern)\n{\n    void *buf;\n\n    if (qemuio_misalign) {\n        len += MISALIGN_OFFSET;\n    }\n    buf = blk_blockalign(blk, len);\n    memset(buf, pattern, len);\n    if (qemuio_misalign) {\n        buf += MISALIGN_OFFSET;\n    }\n    return buf;\n}\n\nstatic void qemu_io_free(void *p)\n{\n    if (qemuio_misalign) {\n        p -= MISALIGN_OFFSET;\n    }\n    qemu_vfree(p);\n}\n\n/*\n * qemu_io_alloc_from_file()\n *\n * Allocates the buffer and populates it with the content of the given file\n * up to @len bytes. If the file length is less than @len, then the buffer\n * is populated with the file content cyclically.\n *\n * @blk - the block backend where the buffer content is going to be written to\n * @len - the buffer length\n * @file_name - the file to read the content from\n *\n * Returns: the buffer pointer on success\n *          NULL on error\n */\nstatic void *qemu_io_alloc_from_file(BlockBackend *blk, size_t len,\n                                     const char *file_name)\n{\n    char *buf, *buf_origin;\n    FILE *f = fopen(file_name, \"r\");\n    int pattern_len;\n\n    if (!f) {\n        perror(file_name);\n        return NULL;\n    }\n\n    if (qemuio_misalign) {\n        len += MISALIGN_OFFSET;\n    }\n\n    buf_origin = buf = blk_blockalign(blk, len);\n\n    if (qemuio_misalign) {\n        buf_origin += MISALIGN_OFFSET;\n        buf += MISALIGN_OFFSET;\n        len -= MISALIGN_OFFSET;\n    }\n\n    pattern_len = fread(buf_origin, 1, len, f);\n\n    if (ferror(f)) {\n        perror(file_name);\n        goto error;\n    }\n\n    if (pattern_len == 0) {\n        fprintf(stderr, \"%s: file is empty\\n\", file_name);\n        goto error;\n    }\n\n    fclose(f);\n    f = NULL;\n\n    if (len > pattern_len) {\n        len -= pattern_len;\n        buf += pattern_len;\n\n        while (len > 0) {\n            size_t len_to_copy = MIN(pattern_len, len);\n\n            memcpy(buf, buf_origin, len_to_copy);\n\n            len -= len_to_copy;\n            buf += len_to_copy;\n        }\n    }\n\n    return buf_origin;\n\nerror:\n    qemu_io_free(buf_origin);\n    if (f) {\n        fclose(f);\n    }\n    return NULL;\n}\n\nstatic void dump_buffer(const void *buffer, int64_t offset, int64_t len)\n{\n    uint64_t i;\n    int j;\n    const uint8_t *p;\n\n    for (i = 0, p = buffer; i < len; i += 16) {\n        const uint8_t *s = p;\n\n        printf(\"%08\" PRIx64 \":  \", offset + i);\n        for (j = 0; j < 16 && i + j < len; j++, p++) {\n            printf(\"%02x \", *p);\n        }\n        printf(\" \");\n        for (j = 0; j < 16 && i + j < len; j++, s++) {\n            if (isalnum(*s)) {\n                printf(\"%c\", *s);\n            } else {\n                printf(\".\");\n            }\n        }\n        printf(\"\\n\");\n    }\n}\n\nstatic void print_report(const char *op, struct timespec *t, int64_t offset,\n                         int64_t count, int64_t total, int cnt, bool Cflag)\n{\n    char s1[64], s2[64], ts[64];\n\n    timestr(t, ts, sizeof(ts), Cflag ? VERBOSE_FIXED_TIME : 0);\n    if (!Cflag) {\n        cvtstr((double)total, s1, sizeof(s1));\n        cvtstr(tdiv((double)total, *t), s2, sizeof(s2));\n        printf(\"%s %\"PRId64\"/%\"PRId64\" bytes at offset %\" PRId64 \"\\n\",\n               op, total, count, offset);\n        printf(\"%s, %d ops; %s (%s/sec and %.4f ops/sec)\\n\",\n               s1, cnt, ts, s2, tdiv((double)cnt, *t));\n    } else {/* bytes,ops,time,bytes/sec,ops/sec */\n        printf(\"%\"PRId64\",%d,%s,%.3f,%.3f\\n\",\n            total, cnt, ts,\n            tdiv((double)total, *t),\n            tdiv((double)cnt, *t));\n    }\n}\n\n/*\n * Parse multiple length statements for vectored I/O, and construct an I/O\n * vector matching it.\n */\nstatic void *\ncreate_iovec(BlockBackend *blk, QEMUIOVector *qiov, char **argv, int nr_iov,\n             int pattern)\n{\n    size_t *sizes = g_new0(size_t, nr_iov);\n    size_t count = 0;\n    void *buf = NULL;\n    void *p;\n    int i;\n\n    for (i = 0; i < nr_iov; i++) {\n        char *arg = argv[i];\n        int64_t len;\n\n        len = cvtnum(arg);\n        if (len < 0) {\n            print_cvtnum_err(len, arg);\n            goto fail;\n        }\n\n        if (len > BDRV_REQUEST_MAX_BYTES) {\n            printf(\"Argument '%s' exceeds maximum size %\" PRIu64 \"\\n\", arg,\n                   (uint64_t)BDRV_REQUEST_MAX_BYTES);\n            goto fail;\n        }\n\n        if (count > BDRV_REQUEST_MAX_BYTES - len) {\n            printf(\"The total number of bytes exceed the maximum size %\" PRIu64\n                   \"\\n\", (uint64_t)BDRV_REQUEST_MAX_BYTES);\n            goto fail;\n        }\n\n        sizes[i] = len;\n        count += len;\n    }\n\n    qemu_iovec_init(qiov, nr_iov);\n\n    buf = p = qemu_io_alloc(blk, count, pattern);\n\n    for (i = 0; i < nr_iov; i++) {\n        qemu_iovec_add(qiov, p, sizes[i]);\n        p += sizes[i];\n    }\n\nfail:\n    g_free(sizes);\n    return buf;\n}\n\nstatic int do_pread(BlockBackend *blk, char *buf, int64_t offset,\n                    int64_t bytes, int64_t *total)\n{\n    int ret;\n\n    if (bytes > INT_MAX) {\n        return -ERANGE;\n    }\n\n    ret = blk_pread(blk, offset, bytes, (uint8_t *)buf, 0);\n    if (ret < 0) {\n        return ret;\n    }\n    *total = bytes;\n    return 1;\n}\n\nstatic int do_pwrite(BlockBackend *blk, char *buf, int64_t offset,\n                     int64_t bytes, int flags, int64_t *total)\n{\n    int ret;\n\n    if (bytes > INT_MAX) {\n        return -ERANGE;\n    }\n\n    ret = blk_pwrite(blk, offset, bytes, (uint8_t *)buf, flags);\n    if (ret < 0) {\n        return ret;\n    }\n    *total = bytes;\n    return 1;\n}\n\ntypedef struct {\n    BlockBackend *blk;\n    int64_t offset;\n    int64_t bytes;\n    int64_t *total;\n    int flags;\n    int ret;\n    bool done;\n} CoWriteZeroes;\n\nstatic void coroutine_fn co_pwrite_zeroes_entry(void *opaque)\n{\n    CoWriteZeroes *data = opaque;\n\n    data->ret = blk_co_pwrite_zeroes(data->blk, data->offset, data->bytes,\n                                     data->flags);\n    data->done = true;\n    if (data->ret < 0) {\n        *data->total = data->ret;\n        return;\n    }\n\n    *data->total = data->bytes;\n}\n\nstatic int do_co_pwrite_zeroes(BlockBackend *blk, int64_t offset,\n                               int64_t bytes, int flags, int64_t *total)\n{\n    Coroutine *co;\n    CoWriteZeroes data = {\n        .blk    = blk,\n        .offset = offset,\n        .bytes  = bytes,\n        .total  = total,\n        .flags  = flags,\n        .done   = false,\n    };\n\n    co = qemu_coroutine_create(co_pwrite_zeroes_entry, &data);\n    bdrv_coroutine_enter(blk_bs(blk), co);\n    while (!data.done) {\n        aio_poll(blk_get_aio_context(blk), true);\n    }\n    if (data.ret < 0) {\n        return data.ret;\n    } else {\n        return 1;\n    }\n}\n\nstatic int do_write_compressed(BlockBackend *blk, char *buf, int64_t offset,\n                               int64_t bytes, int64_t *total)\n{\n    int ret;\n\n    if (bytes > BDRV_REQUEST_MAX_BYTES) {\n        return -ERANGE;\n    }\n\n    ret = blk_pwrite_compressed(blk, offset, bytes, buf);\n    if (ret < 0) {\n        return ret;\n    }\n    *total = bytes;\n    return 1;\n}\n\nstatic int do_load_vmstate(BlockBackend *blk, char *buf, int64_t offset,\n                           int64_t count, int64_t *total)\n{\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    *total = blk_load_vmstate(blk, (uint8_t *)buf, offset, count);\n    if (*total < 0) {\n        return *total;\n    }\n    return 1;\n}\n\nstatic int do_save_vmstate(BlockBackend *blk, char *buf, int64_t offset,\n                           int64_t count, int64_t *total)\n{\n    if (count > INT_MAX) {\n        return -ERANGE;\n    }\n\n    *total = blk_save_vmstate(blk, (uint8_t *)buf, offset, count);\n    if (*total < 0) {\n        return *total;\n    }\n    return 1;\n}\n\n#define NOT_DONE 0x7fffffff\nstatic void aio_rw_done(void *opaque, int ret)\n{\n    *(int *)opaque = ret;\n}\n\nstatic int do_aio_readv(BlockBackend *blk, QEMUIOVector *qiov,\n                        int64_t offset, int *total)\n{\n    int async_ret = NOT_DONE;\n\n    blk_aio_preadv(blk, offset, qiov, 0, aio_rw_done, &async_ret);\n    while (async_ret == NOT_DONE) {\n        main_loop_wait(false);\n    }\n\n    *total = qiov->size;\n    return async_ret < 0 ? async_ret : 1;\n}\n\nstatic int do_aio_writev(BlockBackend *blk, QEMUIOVector *qiov,\n                         int64_t offset, int flags, int *total)\n{\n    int async_ret = NOT_DONE;\n\n    blk_aio_pwritev(blk, offset, qiov, flags, aio_rw_done, &async_ret);\n    while (async_ret == NOT_DONE) {\n        main_loop_wait(false);\n    }\n\n    *total = qiov->size;\n    return async_ret < 0 ? async_ret : 1;\n}\n\nstatic void read_help(void)\n{\n    printf(\n\"\\n\"\n\" reads a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'read -v 512 1k' - dumps 1 kilobyte read from 512 bytes into the file\\n\"\n\"\\n\"\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\" -b, -- read from the VM state rather than the virtual disk\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -l, -- length for pattern verification (only with -P)\\n\"\n\" -p, -- ignored for backwards compatibility\\n\"\n\" -P, -- use a pattern to verify read data\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\" -s, -- start offset for pattern verification (only with -P)\\n\"\n\" -v, -- dump buffer to standard output\\n\"\n\"\\n\");\n}\n\nstatic int read_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t read_cmd = {\n    .name       = \"read\",\n    .altname    = \"r\",\n    .cfunc      = read_f,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-abCqv] [-P pattern [-s off] [-l len]] off len\",\n    .oneline    = \"reads a number of bytes at a specified offset\",\n    .help       = read_help,\n};\n\nstatic int read_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timespec t1, t2;\n    bool Cflag = false, qflag = false, vflag = false;\n    bool Pflag = false, sflag = false, lflag = false, bflag = false;\n    int c, cnt, ret;\n    char *buf;\n    int64_t offset;\n    int64_t count;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int64_t total = 0;\n    int pattern = 0;\n    int64_t pattern_offset = 0, pattern_count = 0;\n\n    while ((c = getopt(argc, argv, \"bCl:pP:qs:v\")) != -1) {\n        switch (c) {\n        case 'b':\n            bflag = true;\n            break;\n        case 'C':\n            Cflag = true;\n            break;\n        case 'l':\n            lflag = true;\n            pattern_count = cvtnum(optarg);\n            if (pattern_count < 0) {\n                print_cvtnum_err(pattern_count, optarg);\n                return pattern_count;\n            }\n            break;\n        case 'p':\n            /* Ignored for backwards compatibility */\n            break;\n        case 'P':\n            Pflag = true;\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return -EINVAL;\n            }\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 's':\n            sflag = true;\n            pattern_offset = cvtnum(optarg);\n            if (pattern_offset < 0) {\n                print_cvtnum_err(pattern_offset, optarg);\n                return pattern_offset;\n            }\n            break;\n        case 'v':\n            vflag = true;\n            break;\n        default:\n            qemuio_command_usage(&read_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind != argc - 2) {\n        qemuio_command_usage(&read_cmd);\n        return -EINVAL;\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return offset;\n    }\n\n    optind++;\n    count = cvtnum(argv[optind]);\n    if (count < 0) {\n        print_cvtnum_err(count, argv[optind]);\n        return count;\n    } else if (count > BDRV_REQUEST_MAX_BYTES) {\n        printf(\"length cannot exceed %\" PRIu64 \", given %s\\n\",\n               (uint64_t)BDRV_REQUEST_MAX_BYTES, argv[optind]);\n        return -EINVAL;\n    }\n\n    if (!Pflag && (lflag || sflag)) {\n        qemuio_command_usage(&read_cmd);\n        return -EINVAL;\n    }\n\n    if (!lflag) {\n        pattern_count = count - pattern_offset;\n    }\n\n    if ((pattern_count < 0) || (pattern_count + pattern_offset > count))  {\n        printf(\"pattern verification range exceeds end of read data\\n\");\n        return -EINVAL;\n    }\n\n    if (bflag) {\n        if (!QEMU_IS_ALIGNED(offset, BDRV_SECTOR_SIZE)) {\n            printf(\"%\" PRId64 \" is not a sector-aligned value for 'offset'\\n\",\n                   offset);\n            return -EINVAL;\n        }\n        if (!QEMU_IS_ALIGNED(count, BDRV_SECTOR_SIZE)) {\n            printf(\"%\"PRId64\" is not a sector-aligned value for 'count'\\n\",\n                   count);\n            return -EINVAL;\n        }\n    }\n\n    buf = qemu_io_alloc(blk, count, 0xab);\n\n    clock_gettime(CLOCK_MONOTONIC, &t1);\n    if (bflag) {\n        ret = do_load_vmstate(blk, buf, offset, count, &total);\n    } else {\n        ret = do_pread(blk, buf, offset, count, &total);\n    }\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n    if (ret < 0) {\n        printf(\"read failed: %s\\n\", strerror(-ret));\n        goto out;\n    }\n    cnt = ret;\n\n    ret = 0;\n\n    if (Pflag) {\n        void *cmp_buf = g_malloc(pattern_count);\n        memset(cmp_buf, pattern, pattern_count);\n        if (memcmp(buf + pattern_offset, cmp_buf, pattern_count)) {\n            printf(\"Pattern verification failed at offset %\"\n                   PRId64 \", %\"PRId64\" bytes\\n\",\n                   offset + pattern_offset, pattern_count);\n            ret = -EINVAL;\n        }\n        g_free(cmp_buf);\n    }\n\n    if (qflag) {\n        goto out;\n    }\n\n    if (vflag) {\n        dump_buffer(buf, offset, count);\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"read\", &t2, offset, count, total, cnt, Cflag);\n\nout:\n    qemu_io_free(buf);\n    return ret;\n}\n\nstatic void readv_help(void)\n{\n    printf(\n\"\\n\"\n\" reads a range of bytes from the given offset into multiple buffers\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'readv -v 512 1k 1k ' - dumps 2 kilobytes read from 512 bytes into the file\\n\"\n\"\\n\"\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\" Uses multiple iovec buffers if more than one byte range is specified.\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -P, -- use a pattern to verify read data\\n\"\n\" -v, -- dump buffer to standard output\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int readv_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t readv_cmd = {\n    .name       = \"readv\",\n    .cfunc      = readv_f,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cqv] [-P pattern] off len [len..]\",\n    .oneline    = \"reads a number of bytes at a specified offset\",\n    .help       = readv_help,\n};\n\nstatic int readv_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timespec t1, t2;\n    bool Cflag = false, qflag = false, vflag = false;\n    int c, cnt, ret;\n    char *buf;\n    int64_t offset;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int total = 0;\n    int nr_iov;\n    QEMUIOVector qiov;\n    int pattern = 0;\n    bool Pflag = false;\n\n    while ((c = getopt(argc, argv, \"CP:qv\")) != -1) {\n        switch (c) {\n        case 'C':\n            Cflag = true;\n            break;\n        case 'P':\n            Pflag = true;\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return -EINVAL;\n            }\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 'v':\n            vflag = true;\n            break;\n        default:\n            qemuio_command_usage(&readv_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind > argc - 2) {\n        qemuio_command_usage(&readv_cmd);\n        return -EINVAL;\n    }\n\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return offset;\n    }\n    optind++;\n\n    nr_iov = argc - optind;\n    buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, 0xab);\n    if (buf == NULL) {\n        return -EINVAL;\n    }\n\n    clock_gettime(CLOCK_MONOTONIC, &t1);\n    ret = do_aio_readv(blk, &qiov, offset, &total);\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n    if (ret < 0) {\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n        goto out;\n    }\n    cnt = ret;\n\n    ret = 0;\n\n    if (Pflag) {\n        void *cmp_buf = g_malloc(qiov.size);\n        memset(cmp_buf, pattern, qiov.size);\n        if (memcmp(buf, cmp_buf, qiov.size)) {\n            printf(\"Pattern verification failed at offset %\"\n                   PRId64 \", %zu bytes\\n\", offset, qiov.size);\n            ret = -EINVAL;\n        }\n        g_free(cmp_buf);\n    }\n\n    if (qflag) {\n        goto out;\n    }\n\n    if (vflag) {\n        dump_buffer(buf, offset, qiov.size);\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"read\", &t2, offset, qiov.size, total, cnt, Cflag);\n\nout:\n    qemu_iovec_destroy(&qiov);\n    qemu_io_free(buf);\n    return ret;\n}\n\nstatic void write_help(void)\n{\n    printf(\n\"\\n\"\n\" writes a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'write 512 1k' - writes 1 kilobyte at 512 bytes into the open file\\n\"\n\"\\n\"\n\" Writes into a segment of the currently open file, using a buffer\\n\"\n\" filled with a set pattern (0xcdcdcdcd).\\n\"\n\" -b, -- write to the VM state rather than the virtual disk\\n\"\n\" -c, -- write compressed data with blk_write_compressed\\n\"\n\" -f, -- use Force Unit Access semantics\\n\"\n\" -n, -- with -z, don't allow slow fallback\\n\"\n\" -p, -- ignored for backwards compatibility\\n\"\n\" -P, -- use different pattern to fill file\\n\"\n\" -s, -- use a pattern file to fill the write buffer\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\" -u, -- with -z, allow unmapping\\n\"\n\" -z, -- write zeroes using blk_co_pwrite_zeroes\\n\"\n\"\\n\");\n}\n\nstatic int write_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t write_cmd = {\n    .name       = \"write\",\n    .altname    = \"w\",\n    .cfunc      = write_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-bcCfnquz] [-P pattern | -s source_file] off len\",\n    .oneline    = \"writes a number of bytes at a specified offset\",\n    .help       = write_help,\n};\n\nstatic int write_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timespec t1, t2;\n    bool Cflag = false, qflag = false, bflag = false;\n    bool Pflag = false, zflag = false, cflag = false, sflag = false;\n    int flags = 0;\n    int c, cnt, ret;\n    char *buf = NULL;\n    int64_t offset;\n    int64_t count;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int64_t total = 0;\n    int pattern = 0xcd;\n    const char *file_name = NULL;\n\n    while ((c = getopt(argc, argv, \"bcCfnpP:qs:uz\")) != -1) {\n        switch (c) {\n        case 'b':\n            bflag = true;\n            break;\n        case 'c':\n            cflag = true;\n            break;\n        case 'C':\n            Cflag = true;\n            break;\n        case 'f':\n            flags |= BDRV_REQ_FUA;\n            break;\n        case 'n':\n            flags |= BDRV_REQ_NO_FALLBACK;\n            break;\n        case 'p':\n            /* Ignored for backwards compatibility */\n            break;\n        case 'P':\n            Pflag = true;\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return -EINVAL;\n            }\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 's':\n            sflag = true;\n            file_name = optarg;\n            break;\n        case 'u':\n            flags |= BDRV_REQ_MAY_UNMAP;\n            break;\n        case 'z':\n            zflag = true;\n            break;\n        default:\n            qemuio_command_usage(&write_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind != argc - 2) {\n        qemuio_command_usage(&write_cmd);\n        return -EINVAL;\n    }\n\n    if (bflag && zflag) {\n        printf(\"-b and -z cannot be specified at the same time\\n\");\n        return -EINVAL;\n    }\n\n    if ((flags & BDRV_REQ_FUA) && (bflag || cflag)) {\n        printf(\"-f and -b or -c cannot be specified at the same time\\n\");\n        return -EINVAL;\n    }\n\n    if ((flags & BDRV_REQ_NO_FALLBACK) && !zflag) {\n        printf(\"-n requires -z to be specified\\n\");\n        return -EINVAL;\n    }\n\n    if ((flags & BDRV_REQ_MAY_UNMAP) && !zflag) {\n        printf(\"-u requires -z to be specified\\n\");\n        return -EINVAL;\n    }\n\n    if (zflag + Pflag + sflag > 1) {\n        printf(\"Only one of -z, -P, and -s \"\n               \"can be specified at the same time\\n\");\n        return -EINVAL;\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return offset;\n    }\n\n    optind++;\n    count = cvtnum(argv[optind]);\n    if (count < 0) {\n        print_cvtnum_err(count, argv[optind]);\n        return count;\n    } else if (count > BDRV_REQUEST_MAX_BYTES &&\n               !(flags & BDRV_REQ_NO_FALLBACK)) {\n        printf(\"length cannot exceed %\" PRIu64 \" without -n, given %s\\n\",\n               (uint64_t)BDRV_REQUEST_MAX_BYTES, argv[optind]);\n        return -EINVAL;\n    }\n\n    if (bflag || cflag) {\n        if (!QEMU_IS_ALIGNED(offset, BDRV_SECTOR_SIZE)) {\n            printf(\"%\" PRId64 \" is not a sector-aligned value for 'offset'\\n\",\n                   offset);\n            return -EINVAL;\n        }\n\n        if (!QEMU_IS_ALIGNED(count, BDRV_SECTOR_SIZE)) {\n            printf(\"%\"PRId64\" is not a sector-aligned value for 'count'\\n\",\n                   count);\n            return -EINVAL;\n        }\n    }\n\n    if (!zflag) {\n        if (sflag) {\n            buf = qemu_io_alloc_from_file(blk, count, file_name);\n            if (!buf) {\n                return -EINVAL;\n            }\n        } else {\n            buf = qemu_io_alloc(blk, count, pattern);\n        }\n    }\n\n    clock_gettime(CLOCK_MONOTONIC, &t1);\n    if (bflag) {\n        ret = do_save_vmstate(blk, buf, offset, count, &total);\n    } else if (zflag) {\n        ret = do_co_pwrite_zeroes(blk, offset, count, flags, &total);\n    } else if (cflag) {\n        ret = do_write_compressed(blk, buf, offset, count, &total);\n    } else {\n        ret = do_pwrite(blk, buf, offset, count, flags, &total);\n    }\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n    if (ret < 0) {\n        printf(\"write failed: %s\\n\", strerror(-ret));\n        goto out;\n    }\n    cnt = ret;\n\n    ret = 0;\n\n    if (qflag) {\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\nout:\n    if (!zflag) {\n        qemu_io_free(buf);\n    }\n    return ret;\n}\n\nstatic void\nwritev_help(void)\n{\n    printf(\n\"\\n\"\n\" writes a range of bytes from the given offset source from multiple buffers\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'writev 512 1k 1k' - writes 2 kilobytes at 512 bytes into the open file\\n\"\n\"\\n\"\n\" Writes into a segment of the currently open file, using a buffer\\n\"\n\" filled with a set pattern (0xcdcdcdcd).\\n\"\n\" -P, -- use different pattern to fill file\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -f, -- use Force Unit Access semantics\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int writev_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t writev_cmd = {\n    .name       = \"writev\",\n    .cfunc      = writev_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cfq] [-P pattern] off len [len..]\",\n    .oneline    = \"writes a number of bytes at a specified offset\",\n    .help       = writev_help,\n};\n\nstatic int writev_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timespec t1, t2;\n    bool Cflag = false, qflag = false;\n    int flags = 0;\n    int c, cnt, ret;\n    char *buf;\n    int64_t offset;\n    /* Some compilers get confused and warn if this is not initialized.  */\n    int total = 0;\n    int nr_iov;\n    int pattern = 0xcd;\n    QEMUIOVector qiov;\n\n    while ((c = getopt(argc, argv, \"CfqP:\")) != -1) {\n        switch (c) {\n        case 'C':\n            Cflag = true;\n            break;\n        case 'f':\n            flags |= BDRV_REQ_FUA;\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                return -EINVAL;\n            }\n            break;\n        default:\n            qemuio_command_usage(&writev_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind > argc - 2) {\n        qemuio_command_usage(&writev_cmd);\n        return -EINVAL;\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return offset;\n    }\n    optind++;\n\n    nr_iov = argc - optind;\n    buf = create_iovec(blk, &qiov, &argv[optind], nr_iov, pattern);\n    if (buf == NULL) {\n        return -EINVAL;\n    }\n\n    clock_gettime(CLOCK_MONOTONIC, &t1);\n    ret = do_aio_writev(blk, &qiov, offset, flags, &total);\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n    if (ret < 0) {\n        printf(\"writev failed: %s\\n\", strerror(-ret));\n        goto out;\n    }\n    cnt = ret;\n\n    ret = 0;\n\n    if (qflag) {\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, t1);\n    print_report(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag);\nout:\n    qemu_iovec_destroy(&qiov);\n    qemu_io_free(buf);\n    return ret;\n}\n\nstruct aio_ctx {\n    BlockBackend *blk;\n    QEMUIOVector qiov;\n    int64_t offset;\n    char *buf;\n    bool qflag;\n    bool vflag;\n    bool Cflag;\n    bool Pflag;\n    bool zflag;\n    BlockAcctCookie acct;\n    int pattern;\n    struct timespec t1;\n};\n\nstatic void aio_write_done(void *opaque, int ret)\n{\n    struct aio_ctx *ctx = opaque;\n    struct timespec t2;\n\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n\n    if (ret < 0) {\n        printf(\"aio_write failed: %s\\n\", strerror(-ret));\n        block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);\n        goto out;\n    }\n\n    block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);\n\n    if (ctx->qflag) {\n        goto out;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, ctx->t1);\n    print_report(\"wrote\", &t2, ctx->offset, ctx->qiov.size,\n                 ctx->qiov.size, 1, ctx->Cflag);\nout:\n    if (!ctx->zflag) {\n        qemu_io_free(ctx->buf);\n        qemu_iovec_destroy(&ctx->qiov);\n    }\n    g_free(ctx);\n}\n\nstatic void aio_read_done(void *opaque, int ret)\n{\n    struct aio_ctx *ctx = opaque;\n    struct timespec t2;\n\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n    if (ret < 0) {\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n        block_acct_failed(blk_get_stats(ctx->blk), &ctx->acct);\n        goto out;\n    }\n\n    if (ctx->Pflag) {\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n            printf(\"Pattern verification failed at offset %\"\n                   PRId64 \", %zu bytes\\n\", ctx->offset, ctx->qiov.size);\n        }\n        g_free(cmp_buf);\n    }\n\n    block_acct_done(blk_get_stats(ctx->blk), &ctx->acct);\n\n    if (ctx->qflag) {\n        goto out;\n    }\n\n    if (ctx->vflag) {\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    t2 = tsub(t2, ctx->t1);\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n                 ctx->qiov.size, 1, ctx->Cflag);\nout:\n    qemu_io_free(ctx->buf);\n    qemu_iovec_destroy(&ctx->qiov);\n    g_free(ctx);\n}\n\nstatic void aio_read_help(void)\n{\n    printf(\n\"\\n\"\n\" asynchronously reads a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'aio_read -v 512 1k 1k ' - dumps 2 kilobytes read from 512 bytes into the file\\n\"\n\"\\n\"\n\" Reads a segment of the currently open file, optionally dumping it to the\\n\"\n\" standard output stream (with -v option) for subsequent inspection.\\n\"\n\" The read is performed asynchronously and the aio_flush command must be\\n\"\n\" used to ensure all outstanding aio requests have been completed.\\n\"\n\" Note that due to its asynchronous nature, this command will be\\n\"\n\" considered successful once the request is submitted, independently\\n\"\n\" of potential I/O errors or pattern mismatches.\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -P, -- use a pattern to verify read data\\n\"\n\" -i, -- treat request as invalid, for exercising stats\\n\"\n\" -v, -- dump buffer to standard output\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int aio_read_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t aio_read_cmd = {\n    .name       = \"aio_read\",\n    .cfunc      = aio_read_f,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Ciqv] [-P pattern] off len [len..]\",\n    .oneline    = \"asynchronously reads a number of bytes\",\n    .help       = aio_read_help,\n};\n\nstatic int aio_read_f(BlockBackend *blk, int argc, char **argv)\n{\n    int nr_iov, c;\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n\n    ctx->blk = blk;\n    while ((c = getopt(argc, argv, \"CP:iqv\")) != -1) {\n        switch (c) {\n        case 'C':\n            ctx->Cflag = true;\n            break;\n        case 'P':\n            ctx->Pflag = true;\n            ctx->pattern = parse_pattern(optarg);\n            if (ctx->pattern < 0) {\n                g_free(ctx);\n                return -EINVAL;\n            }\n            break;\n        case 'i':\n            printf(\"injecting invalid read request\\n\");\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_READ);\n            g_free(ctx);\n            return 0;\n        case 'q':\n            ctx->qflag = true;\n            break;\n        case 'v':\n            ctx->vflag = true;\n            break;\n        default:\n            g_free(ctx);\n            qemuio_command_usage(&aio_read_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind > argc - 2) {\n        g_free(ctx);\n        qemuio_command_usage(&aio_read_cmd);\n        return -EINVAL;\n    }\n\n    ctx->offset = cvtnum(argv[optind]);\n    if (ctx->offset < 0) {\n        int ret = ctx->offset;\n        print_cvtnum_err(ret, argv[optind]);\n        g_free(ctx);\n        return ret;\n    }\n    optind++;\n\n    nr_iov = argc - optind;\n    ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov, 0xab);\n    if (ctx->buf == NULL) {\n        block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_READ);\n        g_free(ctx);\n        return -EINVAL;\n    }\n\n    clock_gettime(CLOCK_MONOTONIC, &ctx->t1);\n    block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n                     BLOCK_ACCT_READ);\n    blk_aio_preadv(blk, ctx->offset, &ctx->qiov, 0, aio_read_done, ctx);\n    return 0;\n}\n\nstatic void aio_write_help(void)\n{\n    printf(\n\"\\n\"\n\" asynchronously writes a range of bytes from the given offset source\\n\"\n\" from multiple buffers\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'aio_write 512 1k 1k' - writes 2 kilobytes at 512 bytes into the open file\\n\"\n\"\\n\"\n\" Writes into a segment of the currently open file, using a buffer\\n\"\n\" filled with a set pattern (0xcdcdcdcd).\\n\"\n\" The write is performed asynchronously and the aio_flush command must be\\n\"\n\" used to ensure all outstanding aio requests have been completed.\\n\"\n\" Note that due to its asynchronous nature, this command will be\\n\"\n\" considered successful once the request is submitted, independently\\n\"\n\" of potential I/O errors or pattern mismatches.\\n\"\n\" -P, -- use different pattern to fill file\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -f, -- use Force Unit Access semantics\\n\"\n\" -i, -- treat request as invalid, for exercising stats\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\" -u, -- with -z, allow unmapping\\n\"\n\" -z, -- write zeroes using blk_aio_pwrite_zeroes\\n\"\n\"\\n\");\n}\n\nstatic int aio_write_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t aio_write_cmd = {\n    .name       = \"aio_write\",\n    .cfunc      = aio_write_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cfiquz] [-P pattern] off len [len..]\",\n    .oneline    = \"asynchronously writes a number of bytes\",\n    .help       = aio_write_help,\n};\n\nstatic int aio_write_f(BlockBackend *blk, int argc, char **argv)\n{\n    int nr_iov, c;\n    int pattern = 0xcd;\n    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);\n    int flags = 0;\n\n    ctx->blk = blk;\n    while ((c = getopt(argc, argv, \"CfiqP:uz\")) != -1) {\n        switch (c) {\n        case 'C':\n            ctx->Cflag = true;\n            break;\n        case 'f':\n            flags |= BDRV_REQ_FUA;\n            break;\n        case 'q':\n            ctx->qflag = true;\n            break;\n        case 'u':\n            flags |= BDRV_REQ_MAY_UNMAP;\n            break;\n        case 'P':\n            pattern = parse_pattern(optarg);\n            if (pattern < 0) {\n                g_free(ctx);\n                return -EINVAL;\n            }\n            break;\n        case 'i':\n            printf(\"injecting invalid write request\\n\");\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n            g_free(ctx);\n            return 0;\n        case 'z':\n            ctx->zflag = true;\n            break;\n        default:\n            g_free(ctx);\n            qemuio_command_usage(&aio_write_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind > argc - 2) {\n        g_free(ctx);\n        qemuio_command_usage(&aio_write_cmd);\n        return -EINVAL;\n    }\n\n    if (ctx->zflag && optind != argc - 2) {\n        printf(\"-z supports only a single length parameter\\n\");\n        g_free(ctx);\n        return -EINVAL;\n    }\n\n    if ((flags & BDRV_REQ_MAY_UNMAP) && !ctx->zflag) {\n        printf(\"-u requires -z to be specified\\n\");\n        g_free(ctx);\n        return -EINVAL;\n    }\n\n    if (ctx->zflag && ctx->Pflag) {\n        printf(\"-z and -P cannot be specified at the same time\\n\");\n        g_free(ctx);\n        return -EINVAL;\n    }\n\n    ctx->offset = cvtnum(argv[optind]);\n    if (ctx->offset < 0) {\n        int ret = ctx->offset;\n        print_cvtnum_err(ret, argv[optind]);\n        g_free(ctx);\n        return ret;\n    }\n    optind++;\n\n    if (ctx->zflag) {\n        int64_t count = cvtnum(argv[optind]);\n        if (count < 0) {\n            print_cvtnum_err(count, argv[optind]);\n            g_free(ctx);\n            return count;\n        }\n\n        ctx->qiov.size = count;\n        blk_aio_pwrite_zeroes(blk, ctx->offset, count, flags, aio_write_done,\n                              ctx);\n    } else {\n        nr_iov = argc - optind;\n        ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov,\n                                pattern);\n        if (ctx->buf == NULL) {\n            block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE);\n            g_free(ctx);\n            return -EINVAL;\n        }\n\n        clock_gettime(CLOCK_MONOTONIC, &ctx->t1);\n        block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size,\n                         BLOCK_ACCT_WRITE);\n\n        blk_aio_pwritev(blk, ctx->offset, &ctx->qiov, flags, aio_write_done,\n                        ctx);\n    }\n\n    return 0;\n}\n\nstatic int aio_flush_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockAcctCookie cookie;\n    block_acct_start(blk_get_stats(blk), &cookie, 0, BLOCK_ACCT_FLUSH);\n    blk_drain_all();\n    block_acct_done(blk_get_stats(blk), &cookie);\n    return 0;\n}\n\nstatic const cmdinfo_t aio_flush_cmd = {\n    .name       = \"aio_flush\",\n    .cfunc      = aio_flush_f,\n    .oneline    = \"completes all outstanding aio requests\"\n};\n\nstatic int flush_f(BlockBackend *blk, int argc, char **argv)\n{\n    return blk_flush(blk);\n}\n\nstatic const cmdinfo_t flush_cmd = {\n    .name       = \"flush\",\n    .altname    = \"f\",\n    .cfunc      = flush_f,\n    .oneline    = \"flush all in-core file state to disk\",\n};\n\nstatic int truncate_f(BlockBackend *blk, int argc, char **argv);\nstatic const cmdinfo_t truncate_cmd = {\n    .name       = \"truncate\",\n    .altname    = \"t\",\n    .cfunc      = truncate_f,\n    .perm       = BLK_PERM_WRITE | BLK_PERM_RESIZE,\n    .argmin     = 1,\n    .argmax     = 3,\n    .args       = \"[-m prealloc_mode] off\",\n    .oneline    = \"truncates the current file at the given offset\",\n};\n\nstatic int truncate_f(BlockBackend *blk, int argc, char **argv)\n{\n    Error *local_err = NULL;\n    int64_t offset;\n    int c, ret;\n    PreallocMode prealloc = PREALLOC_MODE_OFF;\n\n    while ((c = getopt(argc, argv, \"m:\")) != -1) {\n        switch (c) {\n        case 'm':\n            prealloc = qapi_enum_parse(&PreallocMode_lookup, optarg,\n                                       PREALLOC_MODE__MAX, NULL);\n            if (prealloc == PREALLOC_MODE__MAX) {\n                error_report(\"Invalid preallocation mode '%s'\", optarg);\n                return -EINVAL;\n            }\n            break;\n        default:\n            qemuio_command_usage(&truncate_cmd);\n            return -EINVAL;\n        }\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[1]);\n        return offset;\n    }\n\n    /*\n     * qemu-io is a debugging tool, so let us be strict here and pass\n     * exact=true.  It is better to err on the \"emit more errors\" side\n     * than to be overly permissive.\n     */\n    ret = blk_truncate(blk, offset, false, prealloc, 0, &local_err);\n    if (ret < 0) {\n        error_report_err(local_err);\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic int length_f(BlockBackend *blk, int argc, char **argv)\n{\n    int64_t size;\n    char s1[64];\n\n    size = blk_getlength(blk);\n    if (size < 0) {\n        printf(\"getlength: %s\\n\", strerror(-size));\n        return size;\n    }\n\n    cvtstr(size, s1, sizeof(s1));\n    printf(\"%s\\n\", s1);\n    return 0;\n}\n\n\nstatic const cmdinfo_t length_cmd = {\n    .name   = \"length\",\n    .altname    = \"l\",\n    .cfunc      = length_f,\n    .oneline    = \"gets the length of the current file\",\n};\n\n\nstatic int info_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockDriverState *bs = blk_bs(blk);\n    BlockDriverInfo bdi;\n    ImageInfoSpecific *spec_info;\n    Error *local_err = NULL;\n    char s1[64], s2[64];\n    int ret;\n\n    if (bs->drv && bs->drv->format_name) {\n        printf(\"format name: %s\\n\", bs->drv->format_name);\n    }\n    if (bs->drv && bs->drv->protocol_name) {\n        printf(\"format name: %s\\n\", bs->drv->protocol_name);\n    }\n\n    ret = bdrv_get_info(bs, &bdi);\n    if (ret) {\n        return ret;\n    }\n\n    cvtstr(bdi.cluster_size, s1, sizeof(s1));\n    cvtstr(bdi.vm_state_offset, s2, sizeof(s2));\n\n    printf(\"cluster size: %s\\n\", s1);\n    printf(\"vm state offset: %s\\n\", s2);\n\n    spec_info = bdrv_get_specific_info(bs, &local_err);\n    if (local_err) {\n        error_report_err(local_err);\n        return -EIO;\n    }\n    if (spec_info) {\n        printf(\"Format specific information:\\n\");\n        bdrv_image_info_specific_dump(spec_info);\n        qapi_free_ImageInfoSpecific(spec_info);\n    }\n\n    return 0;\n}\n\n\n\nstatic const cmdinfo_t info_cmd = {\n    .name       = \"info\",\n    .altname    = \"i\",\n    .cfunc      = info_f,\n    .oneline    = \"prints information about the current file\",\n};\n\nstatic void discard_help(void)\n{\n    printf(\n\"\\n\"\n\" discards a range of bytes from the given offset\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'discard 512 1k' - discards 1 kilobyte from 512 bytes into the file\\n\"\n\"\\n\"\n\" Discards a segment of the currently open file.\\n\"\n\" -C, -- report statistics in a machine parsable format\\n\"\n\" -q, -- quiet mode, do not show I/O statistics\\n\"\n\"\\n\");\n}\n\nstatic int discard_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t discard_cmd = {\n    .name       = \"discard\",\n    .altname    = \"d\",\n    .cfunc      = discard_f,\n    .perm       = BLK_PERM_WRITE,\n    .argmin     = 2,\n    .argmax     = -1,\n    .args       = \"[-Cq] off len\",\n    .oneline    = \"discards a number of bytes at a specified offset\",\n    .help       = discard_help,\n};\n\nstatic int discard_f(BlockBackend *blk, int argc, char **argv)\n{\n    struct timespec t1, t2;\n    bool Cflag = false, qflag = false;\n    int c, ret;\n    int64_t offset, bytes;\n\n    while ((c = getopt(argc, argv, \"Cq\")) != -1) {\n        switch (c) {\n        case 'C':\n            Cflag = true;\n            break;\n        case 'q':\n            qflag = true;\n            break;\n        default:\n            qemuio_command_usage(&discard_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind != argc - 2) {\n        qemuio_command_usage(&discard_cmd);\n        return -EINVAL;\n    }\n\n    offset = cvtnum(argv[optind]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[optind]);\n        return offset;\n    }\n\n    optind++;\n    bytes = cvtnum(argv[optind]);\n    if (bytes < 0) {\n        print_cvtnum_err(bytes, argv[optind]);\n        return bytes;\n    } else if (bytes > BDRV_REQUEST_MAX_BYTES) {\n        printf(\"length cannot exceed %\"PRIu64\", given %s\\n\",\n               (uint64_t)BDRV_REQUEST_MAX_BYTES, argv[optind]);\n        return -EINVAL;\n    }\n\n    clock_gettime(CLOCK_MONOTONIC, &t1);\n    ret = blk_pdiscard(blk, offset, bytes);\n    clock_gettime(CLOCK_MONOTONIC, &t2);\n\n    if (ret < 0) {\n        printf(\"discard failed: %s\\n\", strerror(-ret));\n        return ret;\n    }\n\n    /* Finally, report back -- -C gives a parsable format */\n    if (!qflag) {\n        t2 = tsub(t2, t1);\n        print_report(\"discard\", &t2, offset, bytes, bytes, 1, Cflag);\n    }\n\n    return 0;\n}\n\nstatic int alloc_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockDriverState *bs = blk_bs(blk);\n    int64_t offset, start, remaining, count;\n    char s1[64];\n    int ret;\n    int64_t num, sum_alloc;\n\n    start = offset = cvtnum(argv[1]);\n    if (offset < 0) {\n        print_cvtnum_err(offset, argv[1]);\n        return offset;\n    }\n\n    if (argc == 3) {\n        count = cvtnum(argv[2]);\n        if (count < 0) {\n            print_cvtnum_err(count, argv[2]);\n            return count;\n        }\n    } else {\n        count = BDRV_SECTOR_SIZE;\n    }\n\n    remaining = count;\n    sum_alloc = 0;\n    while (remaining) {\n        ret = bdrv_is_allocated(bs, offset, remaining, &num);\n        if (ret < 0) {\n            printf(\"is_allocated failed: %s\\n\", strerror(-ret));\n            return ret;\n        }\n        offset += num;\n        remaining -= num;\n        if (ret) {\n            sum_alloc += num;\n        }\n        if (num == 0) {\n            count -= remaining;\n            remaining = 0;\n        }\n    }\n\n    cvtstr(start, s1, sizeof(s1));\n\n    printf(\"%\"PRId64\"/%\"PRId64\" bytes allocated at offset %s\\n\",\n           sum_alloc, count, s1);\n    return 0;\n}\n\nstatic const cmdinfo_t alloc_cmd = {\n    .name       = \"alloc\",\n    .altname    = \"a\",\n    .argmin     = 1,\n    .argmax     = 2,\n    .cfunc      = alloc_f,\n    .args       = \"offset [count]\",\n    .oneline    = \"checks if offset is allocated in the file\",\n};\n\n\nstatic int map_is_allocated(BlockDriverState *bs, int64_t offset,\n                            int64_t bytes, int64_t *pnum)\n{\n    int64_t num;\n    int ret, firstret;\n\n    ret = bdrv_is_allocated(bs, offset, bytes, &num);\n    if (ret < 0) {\n        return ret;\n    }\n\n    firstret = ret;\n    *pnum = num;\n\n    while (bytes > 0 && ret == firstret) {\n        offset += num;\n        bytes -= num;\n\n        ret = bdrv_is_allocated(bs, offset, bytes, &num);\n        if (ret == firstret && num) {\n            *pnum += num;\n        } else {\n            break;\n        }\n    }\n\n    return firstret;\n}\n\nstatic int map_f(BlockBackend *blk, int argc, char **argv)\n{\n    int64_t offset, bytes;\n    char s1[64], s2[64];\n    int64_t num;\n    int ret;\n    const char *retstr;\n\n    offset = 0;\n    bytes = blk_getlength(blk);\n    if (bytes < 0) {\n        error_report(\"Failed to query image length: %s\", strerror(-bytes));\n        return bytes;\n    }\n\n    while (bytes) {\n        ret = map_is_allocated(blk_bs(blk), offset, bytes, &num);\n        if (ret < 0) {\n            error_report(\"Failed to get allocation status: %s\", strerror(-ret));\n            return ret;\n        } else if (!num) {\n            error_report(\"Unexpected end of image\");\n            return -EIO;\n        }\n\n        retstr = ret ? \"    allocated\" : \"not allocated\";\n        cvtstr(num, s1, sizeof(s1));\n        cvtstr(offset, s2, sizeof(s2));\n        printf(\"%s (0x%\" PRIx64 \") bytes %s at offset %s (0x%\" PRIx64 \")\\n\",\n               s1, num, retstr, s2, offset);\n\n        offset += num;\n        bytes -= num;\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t map_cmd = {\n       .name           = \"map\",\n       .argmin         = 0,\n       .argmax         = 0,\n       .cfunc          = map_f,\n       .args           = \"\",\n       .oneline        = \"prints the allocated areas of a file\",\n};\n\nstatic void reopen_help(void)\n{\n    printf(\n\"\\n\"\n\" Changes the open options of an already opened image\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'reopen -o lazy-refcounts=on' - activates lazy refcount writeback on a qcow2 image\\n\"\n\"\\n\"\n\" -r, -- Reopen the image read-only\\n\"\n\" -w, -- Reopen the image read-write\\n\"\n\" -c, -- Change the cache mode to the given value\\n\"\n\" -o, -- Changes block driver options (cf. 'open' command)\\n\"\n\"\\n\");\n}\n\nstatic int reopen_f(BlockBackend *blk, int argc, char **argv);\n\nstatic QemuOptsList reopen_opts = {\n    .name = \"reopen\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(reopen_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nstatic const cmdinfo_t reopen_cmd = {\n       .name           = \"reopen\",\n       .argmin         = 0,\n       .argmax         = -1,\n       .cfunc          = reopen_f,\n       .args           = \"[(-r|-w)] [-c cache] [-o options]\",\n       .oneline        = \"reopens an image with new options\",\n       .help           = reopen_help,\n};\n\nstatic int reopen_f(BlockBackend *blk, int argc, char **argv)\n{\n    BlockDriverState *bs = blk_bs(blk);\n    QemuOpts *qopts;\n    QDict *opts;\n    int c;\n    int flags = bs->open_flags;\n    bool writethrough = !blk_enable_write_cache(blk);\n    bool has_rw_option = false;\n    bool has_cache_option = false;\n    Error *local_err = NULL;\n\n    while ((c = getopt(argc, argv, \"c:o:rw\")) != -1) {\n        switch (c) {\n        case 'c':\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n                error_report(\"Invalid cache option: %s\", optarg);\n                return -EINVAL;\n            }\n            has_cache_option = true;\n            break;\n        case 'o':\n            if (!qemu_opts_parse_noisily(&reopen_opts, optarg, 0)) {\n                qemu_opts_reset(&reopen_opts);\n                return -EINVAL;\n            }\n            break;\n        case 'r':\n            if (has_rw_option) {\n                error_report(\"Only one -r/-w option may be given\");\n                return -EINVAL;\n            }\n            flags &= ~BDRV_O_RDWR;\n            has_rw_option = true;\n            break;\n        case 'w':\n            if (has_rw_option) {\n                error_report(\"Only one -r/-w option may be given\");\n                return -EINVAL;\n            }\n            flags |= BDRV_O_RDWR;\n            has_rw_option = true;\n            break;\n        default:\n            qemu_opts_reset(&reopen_opts);\n            qemuio_command_usage(&reopen_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (optind != argc) {\n        qemu_opts_reset(&reopen_opts);\n        qemuio_command_usage(&reopen_cmd);\n        return -EINVAL;\n    }\n\n    if (!writethrough != blk_enable_write_cache(blk) &&\n        blk_get_attached_dev(blk))\n    {\n        error_report(\"Cannot change cache.writeback: Device attached\");\n        qemu_opts_reset(&reopen_opts);\n        return -EBUSY;\n    }\n\n    if (!(flags & BDRV_O_RDWR)) {\n        uint64_t orig_perm, orig_shared_perm;\n\n        bdrv_drain(bs);\n\n        blk_get_perm(blk, &orig_perm, &orig_shared_perm);\n        blk_set_perm(blk,\n                     orig_perm & ~(BLK_PERM_WRITE | BLK_PERM_WRITE_UNCHANGED),\n                     orig_shared_perm,\n                     &error_abort);\n    }\n\n    qopts = qemu_opts_find(&reopen_opts, NULL);\n    opts = qopts ? qemu_opts_to_qdict(qopts, NULL) : qdict_new();\n    qemu_opts_reset(&reopen_opts);\n\n    if (qdict_haskey(opts, BDRV_OPT_READ_ONLY)) {\n        if (has_rw_option) {\n            error_report(\"Cannot set both -r/-w and '\" BDRV_OPT_READ_ONLY \"'\");\n            qobject_unref(opts);\n            return -EINVAL;\n        }\n    } else {\n        qdict_put_bool(opts, BDRV_OPT_READ_ONLY, !(flags & BDRV_O_RDWR));\n    }\n\n    if (qdict_haskey(opts, BDRV_OPT_CACHE_DIRECT) ||\n        qdict_haskey(opts, BDRV_OPT_CACHE_NO_FLUSH)) {\n        if (has_cache_option) {\n            error_report(\"Cannot set both -c and the cache options\");\n            qobject_unref(opts);\n            return -EINVAL;\n        }\n    } else {\n        qdict_put_bool(opts, BDRV_OPT_CACHE_DIRECT, flags & BDRV_O_NOCACHE);\n        qdict_put_bool(opts, BDRV_OPT_CACHE_NO_FLUSH, flags & BDRV_O_NO_FLUSH);\n    }\n\n    bdrv_reopen(bs, opts, true, &local_err);\n\n    if (local_err) {\n        error_report_err(local_err);\n        return -EINVAL;\n    }\n\n    blk_set_enable_write_cache(blk, !writethrough);\n    return 0;\n}\n\nstatic int break_f(BlockBackend *blk, int argc, char **argv)\n{\n    int ret;\n\n    ret = bdrv_debug_breakpoint(blk_bs(blk), argv[1], argv[2]);\n    if (ret < 0) {\n        printf(\"Could not set breakpoint: %s\\n\", strerror(-ret));\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic int remove_break_f(BlockBackend *blk, int argc, char **argv)\n{\n    int ret;\n\n    ret = bdrv_debug_remove_breakpoint(blk_bs(blk), argv[1]);\n    if (ret < 0) {\n        printf(\"Could not remove breakpoint %s: %s\\n\", argv[1], strerror(-ret));\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t break_cmd = {\n       .name           = \"break\",\n       .argmin         = 2,\n       .argmax         = 2,\n       .cfunc          = break_f,\n       .args           = \"event tag\",\n       .oneline        = \"sets a breakpoint on event and tags the stopped \"\n                         \"request as tag\",\n};\n\nstatic const cmdinfo_t remove_break_cmd = {\n       .name           = \"remove_break\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = remove_break_f,\n       .args           = \"tag\",\n       .oneline        = \"remove a breakpoint by tag\",\n};\n\nstatic int resume_f(BlockBackend *blk, int argc, char **argv)\n{\n    int ret;\n\n    ret = bdrv_debug_resume(blk_bs(blk), argv[1]);\n    if (ret < 0) {\n        printf(\"Could not resume request: %s\\n\", strerror(-ret));\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic const cmdinfo_t resume_cmd = {\n       .name           = \"resume\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = resume_f,\n       .args           = \"tag\",\n       .oneline        = \"resumes the request tagged as tag\",\n};\n\nstatic int wait_break_f(BlockBackend *blk, int argc, char **argv)\n{\n    while (!bdrv_debug_is_suspended(blk_bs(blk), argv[1])) {\n        aio_poll(blk_get_aio_context(blk), true);\n    }\n    return 0;\n}\n\nstatic const cmdinfo_t wait_break_cmd = {\n       .name           = \"wait_break\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = wait_break_f,\n       .args           = \"tag\",\n       .oneline        = \"waits for the suspension of a request\",\n};\n\nstatic int abort_f(BlockBackend *blk, int argc, char **argv)\n{\n    abort();\n}\n\nstatic const cmdinfo_t abort_cmd = {\n       .name           = \"abort\",\n       .cfunc          = abort_f,\n       .flags          = CMD_NOFILE_OK,\n       .oneline        = \"simulate a program crash using abort(3)\",\n};\n\nstatic void sigraise_help(void)\n{\n    printf(\n\"\\n\"\n\" raises the given signal\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'sigraise %i' - raises SIGTERM\\n\"\n\"\\n\"\n\" Invokes raise(signal), where \\\"signal\\\" is the mandatory integer argument\\n\"\n\" given to sigraise.\\n\"\n\"\\n\", SIGTERM);\n}\n\nstatic int sigraise_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t sigraise_cmd = {\n    .name       = \"sigraise\",\n    .cfunc      = sigraise_f,\n    .argmin     = 1,\n    .argmax     = 1,\n    .flags      = CMD_NOFILE_OK,\n    .args       = \"signal\",\n    .oneline    = \"raises a signal\",\n    .help       = sigraise_help,\n};\n\nstatic int sigraise_f(BlockBackend *blk, int argc, char **argv)\n{\n    int64_t sig = cvtnum(argv[1]);\n    if (sig < 0) {\n        print_cvtnum_err(sig, argv[1]);\n        return sig;\n    } else if (sig > NSIG) {\n        printf(\"signal argument '%s' is too large to be a valid signal\\n\",\n               argv[1]);\n        return -EINVAL;\n    }\n\n    /* Using raise() to kill this process does not necessarily flush all open\n     * streams. At least stdout and stderr (although the latter should be\n     * non-buffered anyway) should be flushed, though. */\n    fflush(stdout);\n    fflush(stderr);\n\n    raise(sig);\n\n    return 0;\n}\n\nstatic void sleep_cb(void *opaque)\n{\n    bool *expired = opaque;\n    *expired = true;\n}\n\nstatic int sleep_f(BlockBackend *blk, int argc, char **argv)\n{\n    char *endptr;\n    long ms;\n    struct QEMUTimer *timer;\n    bool expired = false;\n\n    ms = strtol(argv[1], &endptr, 0);\n    if (ms < 0 || *endptr != '\\0') {\n        printf(\"%s is not a valid number\\n\", argv[1]);\n        return -EINVAL;\n    }\n\n    timer = timer_new_ns(QEMU_CLOCK_HOST, sleep_cb, &expired);\n    timer_mod(timer, qemu_clock_get_ns(QEMU_CLOCK_HOST) + SCALE_MS * ms);\n\n    while (!expired) {\n        main_loop_wait(false);\n    }\n\n    timer_free(timer);\n    return 0;\n}\n\nstatic const cmdinfo_t sleep_cmd = {\n       .name           = \"sleep\",\n       .argmin         = 1,\n       .argmax         = 1,\n       .cfunc          = sleep_f,\n       .flags          = CMD_NOFILE_OK,\n       .oneline        = \"waits for the given value in milliseconds\",\n};\n\nstatic void help_oneline(const char *cmd, const cmdinfo_t *ct)\n{\n    printf(\"%s \", cmd);\n\n    if (ct->args) {\n        printf(\"%s \", ct->args);\n    }\n    printf(\"-- %s\\n\", ct->oneline);\n}\n\nstatic void help_onecmd(const char *cmd, const cmdinfo_t *ct)\n{\n    help_oneline(cmd, ct);\n    if (ct->help) {\n        ct->help();\n    }\n}\n\nstatic void help_all(void)\n{\n    const cmdinfo_t *ct;\n\n    for (ct = cmdtab; ct < &cmdtab[ncmds]; ct++) {\n        help_oneline(ct->name, ct);\n    }\n    printf(\"\\nUse 'help commandname' for extended help.\\n\");\n}\n\nstatic int help_f(BlockBackend *blk, int argc, char **argv)\n{\n    const cmdinfo_t *ct;\n\n    if (argc < 2) {\n        help_all();\n        return 0;\n    }\n\n    ct = find_command(argv[1]);\n    if (ct == NULL) {\n        printf(\"command %s not found\\n\", argv[1]);\n        return -EINVAL;\n    }\n\n    help_onecmd(argv[1], ct);\n    return 0;\n}\n\nstatic const cmdinfo_t help_cmd = {\n    .name       = \"help\",\n    .altname    = \"?\",\n    .cfunc      = help_f,\n    .argmin     = 0,\n    .argmax     = 1,\n    .flags      = CMD_FLAG_GLOBAL,\n    .args       = \"[command]\",\n    .oneline    = \"help for one or all commands\",\n};\n\n/*\n * Called with aio context of blk acquired. Or with qemu_get_aio_context()\n * context acquired if blk is NULL.\n */\nint qemuio_command(BlockBackend *blk, const char *cmd)\n{\n    char *input;\n    const cmdinfo_t *ct;\n    char **v;\n    int c;\n    int ret = 0;\n\n    input = g_strdup(cmd);\n    v = breakline(input, &c);\n    if (c) {\n        ct = find_command(v[0]);\n        if (ct) {\n            ret = command(blk, ct, c, v);\n        } else {\n            fprintf(stderr, \"command \\\"%s\\\" not found\\n\", v[0]);\n            ret = -EINVAL;\n        }\n    }\n    g_free(input);\n    g_free(v);\n\n    return ret;\n}\n\nstatic void __attribute((constructor)) init_qemuio_commands(void)\n{\n    /* initialize commands */\n    qemuio_add_command(&help_cmd);\n    qemuio_add_command(&read_cmd);\n    qemuio_add_command(&readv_cmd);\n    qemuio_add_command(&write_cmd);\n    qemuio_add_command(&writev_cmd);\n    qemuio_add_command(&aio_read_cmd);\n    qemuio_add_command(&aio_write_cmd);\n    qemuio_add_command(&aio_flush_cmd);\n    qemuio_add_command(&flush_cmd);\n    qemuio_add_command(&truncate_cmd);\n    qemuio_add_command(&length_cmd);\n    qemuio_add_command(&info_cmd);\n    qemuio_add_command(&discard_cmd);\n    qemuio_add_command(&alloc_cmd);\n    qemuio_add_command(&map_cmd);\n    qemuio_add_command(&reopen_cmd);\n    qemuio_add_command(&break_cmd);\n    qemuio_add_command(&remove_break_cmd);\n    qemuio_add_command(&resume_cmd);\n    qemuio_add_command(&wait_break_cmd);\n    qemuio_add_command(&abort_cmd);\n    qemuio_add_command(&sleep_cmd);\n    qemuio_add_command(&sigraise_cmd);\n}\n"
        },
        {
          "name": "qemu-io.c",
          "type": "blob",
          "size": 17.8828125,
          "content": "/*\n * Command line utility to exercise the QEMU I/O path.\n *\n * Copyright (C) 2009 Red Hat, Inc.\n * Copyright (c) 2003-2005 Silicon Graphics, Inc.\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include <getopt.h>\n#include <libgen.h>\n#ifndef _WIN32\n#include <termios.h>\n#endif\n\n#include \"qemu/help-texts.h\"\n#include \"qemu/cutils.h\"\n#include \"qapi/error.h\"\n#include \"qemu-io.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/module.h\"\n#include \"qemu/option.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/readline.h\"\n#include \"qemu/log.h\"\n#include \"qemu/sockets.h\"\n#include \"qapi/qmp/qstring.h\"\n#include \"qapi/qmp/qdict.h\"\n#include \"qom/object_interfaces.h\"\n#include \"sysemu/block-backend.h\"\n#include \"block/block_int.h\"\n#include \"trace/control.h\"\n#include \"crypto/init.h\"\n#include \"qemu-version.h\"\n\n#define CMD_NOFILE_OK   0x01\n\nstatic BlockBackend *qemuio_blk;\nstatic bool quit_qemu_io;\n\n/* qemu-io commands passed using -c */\nstatic int ncmdline;\nstatic char **cmdline;\nstatic bool imageOpts;\n\nstatic ReadLineState *readline_state;\n\nstatic int ttyEOF;\n\nstatic int get_eof_char(void)\n{\n#ifdef _WIN32\n    return 0x4; /* Ctrl-D */\n#else\n    struct termios tty;\n    if (tcgetattr(STDIN_FILENO, &tty) != 0) {\n        if (errno == ENOTTY) {\n            return 0x0; /* just expect read() == 0 */\n        } else {\n            return 0x4; /* Ctrl-D */\n        }\n    }\n\n    return tty.c_cc[VEOF];\n#endif\n}\n\nstatic int close_f(BlockBackend *blk, int argc, char **argv)\n{\n    blk_unref(qemuio_blk);\n    qemuio_blk = NULL;\n    return 0;\n}\n\nstatic const cmdinfo_t close_cmd = {\n    .name       = \"close\",\n    .altname    = \"c\",\n    .cfunc      = close_f,\n    .oneline    = \"close the current open file\",\n};\n\nstatic int openfile(char *name, int flags, bool writethrough, bool force_share,\n                    QDict *opts)\n{\n    Error *local_err = NULL;\n\n    if (qemuio_blk) {\n        error_report(\"file open already, try 'help close'\");\n        qobject_unref(opts);\n        return 1;\n    }\n\n    if (force_share) {\n        if (!opts) {\n            opts = qdict_new();\n        }\n        if (qdict_haskey(opts, BDRV_OPT_FORCE_SHARE)\n            && strcmp(qdict_get_str(opts, BDRV_OPT_FORCE_SHARE), \"on\")) {\n            error_report(\"-U conflicts with image options\");\n            qobject_unref(opts);\n            return 1;\n        }\n        qdict_put_str(opts, BDRV_OPT_FORCE_SHARE, \"on\");\n    }\n    qemuio_blk = blk_new_open(name, NULL, opts, flags, &local_err);\n    if (!qemuio_blk) {\n        error_reportf_err(local_err, \"can't open%s%s: \",\n                          name ? \" device \" : \"\", name ?: \"\");\n        return 1;\n    }\n\n    blk_set_enable_write_cache(qemuio_blk, !writethrough);\n\n    return 0;\n}\n\nstatic void open_help(void)\n{\n    printf(\n\"\\n\"\n\" opens a new file in the requested mode\\n\"\n\"\\n\"\n\" Example:\\n\"\n\" 'open -n -o driver=raw /tmp/data' - opens raw data file read-write, uncached\\n\"\n\"\\n\"\n\" Opens a file for subsequent use by all of the other qemu-io commands.\\n\"\n\" -r, -- open file read-only\\n\"\n\" -s, -- use snapshot file\\n\"\n\" -C, -- use copy-on-read\\n\"\n\" -n, -- disable host cache, short for -t none\\n\"\n\" -U, -- force shared permissions\\n\"\n\" -k, -- use kernel AIO implementation (Linux only, prefer use of -i)\\n\"\n\" -i, -- use AIO mode (threads, native or io_uring)\\n\"\n\" -t, -- use the given cache mode for the image\\n\"\n\" -d, -- use the given discard mode for the image\\n\"\n\" -o, -- options to be given to the block driver\"\n\"\\n\");\n}\n\nstatic int open_f(BlockBackend *blk, int argc, char **argv);\n\nstatic const cmdinfo_t open_cmd = {\n    .name       = \"open\",\n    .altname    = \"o\",\n    .cfunc      = open_f,\n    .argmin     = 1,\n    .argmax     = -1,\n    .flags      = CMD_NOFILE_OK,\n    .args       = \"[-rsCnkU] [-t cache] [-d discard] [-o options] [path]\",\n    .oneline    = \"open the file specified by path\",\n    .help       = open_help,\n};\n\nstatic QemuOptsList empty_opts = {\n    .name = \"drive\",\n    .merge_lists = true,\n    .head = QTAILQ_HEAD_INITIALIZER(empty_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nstatic int open_f(BlockBackend *blk, int argc, char **argv)\n{\n    int flags = BDRV_O_UNMAP;\n    int readonly = 0;\n    bool writethrough = true;\n    int c;\n    int ret;\n    QemuOpts *qopts;\n    QDict *opts;\n    bool force_share = false;\n\n    while ((c = getopt(argc, argv, \"snCro:ki:t:d:U\")) != -1) {\n        switch (c) {\n        case 's':\n            flags |= BDRV_O_SNAPSHOT;\n            break;\n        case 'n':\n            flags |= BDRV_O_NOCACHE;\n            writethrough = false;\n            break;\n        case 'C':\n            flags |= BDRV_O_COPY_ON_READ;\n            break;\n        case 'r':\n            readonly = 1;\n            break;\n        case 'k':\n            flags |= BDRV_O_NATIVE_AIO;\n            break;\n        case 't':\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n                error_report(\"Invalid cache option: %s\", optarg);\n                qemu_opts_reset(&empty_opts);\n                return -EINVAL;\n            }\n            break;\n        case 'd':\n            if (bdrv_parse_discard_flags(optarg, &flags) < 0) {\n                error_report(\"Invalid discard option: %s\", optarg);\n                qemu_opts_reset(&empty_opts);\n                return -EINVAL;\n            }\n            break;\n        case 'i':\n            if (bdrv_parse_aio(optarg, &flags) < 0) {\n                error_report(\"Invalid aio option: %s\", optarg);\n                qemu_opts_reset(&empty_opts);\n                return -EINVAL;\n            }\n            break;\n        case 'o':\n            if (imageOpts) {\n                printf(\"--image-opts and 'open -o' are mutually exclusive\\n\");\n                qemu_opts_reset(&empty_opts);\n                return -EINVAL;\n            }\n            if (!qemu_opts_parse_noisily(&empty_opts, optarg, false)) {\n                qemu_opts_reset(&empty_opts);\n                return -EINVAL;\n            }\n            break;\n        case 'U':\n            force_share = true;\n            break;\n        default:\n            qemu_opts_reset(&empty_opts);\n            qemuio_command_usage(&open_cmd);\n            return -EINVAL;\n        }\n    }\n\n    if (!readonly) {\n        flags |= BDRV_O_RDWR;\n    }\n\n    if (imageOpts && (optind == argc - 1)) {\n        if (!qemu_opts_parse_noisily(&empty_opts, argv[optind], false)) {\n            qemu_opts_reset(&empty_opts);\n            return -EINVAL;\n        }\n        optind++;\n    }\n\n    qopts = qemu_opts_find(&empty_opts, NULL);\n    opts = qopts ? qemu_opts_to_qdict(qopts, NULL) : NULL;\n    qemu_opts_reset(&empty_opts);\n\n    if (optind == argc - 1) {\n        ret = openfile(argv[optind], flags, writethrough, force_share, opts);\n    } else if (optind == argc) {\n        ret = openfile(NULL, flags, writethrough, force_share, opts);\n    } else {\n        qobject_unref(opts);\n        qemuio_command_usage(&open_cmd);\n        return -EINVAL;\n    }\n\n    if (ret) {\n        return -EINVAL;\n    }\n\n    return 0;\n}\n\nstatic int quit_f(BlockBackend *blk, int argc, char **argv)\n{\n    quit_qemu_io = true;\n    return 0;\n}\n\nstatic const cmdinfo_t quit_cmd = {\n    .name       = \"quit\",\n    .altname    = \"q\",\n    .cfunc      = quit_f,\n    .argmin     = -1,\n    .argmax     = -1,\n    .flags      = CMD_FLAG_GLOBAL,\n    .oneline    = \"exit the program\",\n};\n\nstatic void usage(const char *name)\n{\n    printf(\n\"Usage: %s [OPTIONS]... [-c STRING]... [file]\\n\"\n\"QEMU Disk exerciser\\n\"\n\"\\n\"\n\"  --object OBJECTDEF   define an object such as 'secret' for\\n\"\n\"                       passwords and/or encryption keys\\n\"\n\"  --image-opts         treat file as option string\\n\"\n\"  -c, --cmd STRING     execute command with its arguments\\n\"\n\"                       from the given string\\n\"\n\"  -f, --format FMT     specifies the block driver to use\\n\"\n\"  -r, --read-only      export read-only\\n\"\n\"  -s, --snapshot       use snapshot file\\n\"\n\"  -n, --nocache        disable host cache, short for -t none\\n\"\n\"  -C, --copy-on-read   enable copy-on-read\\n\"\n\"  -m, --misalign       misalign allocations for O_DIRECT\\n\"\n\"  -k, --native-aio     use kernel AIO implementation\\n\"\n\"                       (Linux only, prefer use of -i)\\n\"\n\"  -i, --aio=MODE       use AIO mode (threads, native or io_uring)\\n\"\n\"  -t, --cache=MODE     use the given cache mode for the image\\n\"\n\"  -d, --discard=MODE   use the given discard mode for the image\\n\"\n\"  -T, --trace [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\"                       specify tracing options\\n\"\n\"                       see qemu-img(1) man page for full description\\n\"\n\"  -U, --force-share    force shared permissions\\n\"\n\"  -h, --help           display this help and exit\\n\"\n\"  -V, --version        output version information and exit\\n\"\n\"\\n\"\n\"See '%s -c help' for information on available commands.\\n\"\n\"\\n\"\nQEMU_HELP_BOTTOM \"\\n\",\n    name, name);\n}\n\nstatic char *get_prompt(void)\n{\n    static char prompt[FILENAME_MAX + 2 /*\"> \"*/ + 1 /*\"\\0\"*/ ];\n\n    if (!prompt[0]) {\n        snprintf(prompt, sizeof(prompt), \"%s> \", g_get_prgname());\n    }\n\n    return prompt;\n}\n\nstatic void G_GNUC_PRINTF(2, 3) readline_printf_func(void *opaque,\n                                                    const char *fmt, ...)\n{\n    va_list ap;\n    va_start(ap, fmt);\n    vprintf(fmt, ap);\n    va_end(ap);\n}\n\nstatic void readline_flush_func(void *opaque)\n{\n    fflush(stdout);\n}\n\nstatic void readline_func(void *opaque, const char *str, void *readline_opaque)\n{\n    char **line = readline_opaque;\n    *line = g_strdup(str);\n}\n\nstatic void completion_match(const char *cmd, void *opaque)\n{\n    readline_add_completion(readline_state, cmd);\n}\n\nstatic void readline_completion_func(void *opaque, const char *str)\n{\n    readline_set_completion_index(readline_state, strlen(str));\n    qemuio_complete_command(str, completion_match, NULL);\n}\n\nstatic char *fetchline_readline(void)\n{\n    char *line = NULL;\n\n    readline_start(readline_state, get_prompt(), 0, readline_func, &line);\n    while (!line) {\n        int ch = getchar();\n        if (ttyEOF != 0x0 && ch == ttyEOF) {\n            printf(\"\\n\");\n            break;\n        }\n        readline_handle_byte(readline_state, ch);\n    }\n    return line;\n}\n\n#define MAXREADLINESZ 1024\nstatic char *fetchline_fgets(void)\n{\n    char *p, *line = g_malloc(MAXREADLINESZ);\n\n    if (!fgets(line, MAXREADLINESZ, stdin)) {\n        g_free(line);\n        return NULL;\n    }\n\n    p = line + strlen(line);\n    if (p != line && p[-1] == '\\n') {\n        p[-1] = '\\0';\n    }\n\n    return line;\n}\n\nstatic char *fetchline(void)\n{\n    if (readline_state) {\n        return fetchline_readline();\n    } else {\n        return fetchline_fgets();\n    }\n}\n\nstatic void prep_fetchline(void *opaque)\n{\n    int *fetchable = opaque;\n\n    qemu_set_fd_handler(STDIN_FILENO, NULL, NULL, NULL);\n    *fetchable= 1;\n}\n\nstatic int do_qemuio_command(const char *cmd)\n{\n    int ret;\n    AioContext *ctx =\n        qemuio_blk ? blk_get_aio_context(qemuio_blk) : qemu_get_aio_context();\n\n    aio_context_acquire(ctx);\n    ret = qemuio_command(qemuio_blk, cmd);\n    aio_context_release(ctx);\n\n    return ret;\n}\n\nstatic int command_loop(void)\n{\n    int i, fetchable = 0, prompted = 0;\n    int ret, last_error = 0;\n    char *input;\n\n    for (i = 0; !quit_qemu_io && i < ncmdline; i++) {\n        ret = do_qemuio_command(cmdline[i]);\n        if (ret < 0) {\n            last_error = ret;\n        }\n    }\n    if (cmdline) {\n        g_free(cmdline);\n        return last_error;\n    }\n\n    while (!quit_qemu_io) {\n        if (!prompted) {\n            printf(\"%s\", get_prompt());\n            fflush(stdout);\n            qemu_set_fd_handler(STDIN_FILENO, prep_fetchline, NULL, &fetchable);\n            prompted = 1;\n        }\n\n        main_loop_wait(false);\n\n        if (!fetchable) {\n            continue;\n        }\n\n        input = fetchline();\n        if (input == NULL) {\n            break;\n        }\n        ret = do_qemuio_command(input);\n        g_free(input);\n\n        if (ret < 0) {\n            last_error = ret;\n        }\n\n        prompted = 0;\n        fetchable = 0;\n    }\n    qemu_set_fd_handler(STDIN_FILENO, NULL, NULL, NULL);\n\n    return last_error;\n}\n\nstatic void add_user_command(char *optarg)\n{\n    cmdline = g_renew(char *, cmdline, ++ncmdline);\n    cmdline[ncmdline-1] = optarg;\n}\n\nstatic void reenable_tty_echo(void)\n{\n    qemu_set_tty_echo(STDIN_FILENO, true);\n}\n\nenum {\n    OPTION_OBJECT = 256,\n    OPTION_IMAGE_OPTS = 257,\n};\n\nstatic QemuOptsList file_opts = {\n    .name = \"file\",\n    .implied_opt_name = \"file\",\n    .head = QTAILQ_HEAD_INITIALIZER(file_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nint main(int argc, char **argv)\n{\n    int readonly = 0;\n    const char *sopt = \"hVc:d:f:rsnCmki:t:T:U\";\n    const struct option lopt[] = {\n        { \"help\", no_argument, NULL, 'h' },\n        { \"version\", no_argument, NULL, 'V' },\n        { \"cmd\", required_argument, NULL, 'c' },\n        { \"format\", required_argument, NULL, 'f' },\n        { \"read-only\", no_argument, NULL, 'r' },\n        { \"snapshot\", no_argument, NULL, 's' },\n        { \"nocache\", no_argument, NULL, 'n' },\n        { \"copy-on-read\", no_argument, NULL, 'C' },\n        { \"misalign\", no_argument, NULL, 'm' },\n        { \"native-aio\", no_argument, NULL, 'k' },\n        { \"aio\", required_argument, NULL, 'i' },\n        { \"discard\", required_argument, NULL, 'd' },\n        { \"cache\", required_argument, NULL, 't' },\n        { \"trace\", required_argument, NULL, 'T' },\n        { \"object\", required_argument, NULL, OPTION_OBJECT },\n        { \"image-opts\", no_argument, NULL, OPTION_IMAGE_OPTS },\n        { \"force-share\", no_argument, 0, 'U'},\n        { NULL, 0, NULL, 0 }\n    };\n    int c;\n    int opt_index = 0;\n    int flags = BDRV_O_UNMAP;\n    int ret;\n    bool writethrough = true;\n    QDict *opts = NULL;\n    const char *format = NULL;\n    bool force_share = false;\n\n#ifdef CONFIG_POSIX\n    signal(SIGPIPE, SIG_IGN);\n#endif\n\n    socket_init();\n    error_init(argv[0]);\n    module_call_init(MODULE_INIT_TRACE);\n    qemu_init_exec_dir(argv[0]);\n\n    qcrypto_init(&error_fatal);\n\n    module_call_init(MODULE_INIT_QOM);\n    qemu_add_opts(&qemu_trace_opts);\n    bdrv_init();\n\n    while ((c = getopt_long(argc, argv, sopt, lopt, &opt_index)) != -1) {\n        switch (c) {\n        case 's':\n            flags |= BDRV_O_SNAPSHOT;\n            break;\n        case 'n':\n            flags |= BDRV_O_NOCACHE;\n            writethrough = false;\n            break;\n        case 'C':\n            flags |= BDRV_O_COPY_ON_READ;\n            break;\n        case 'd':\n            if (bdrv_parse_discard_flags(optarg, &flags) < 0) {\n                error_report(\"Invalid discard option: %s\", optarg);\n                exit(1);\n            }\n            break;\n        case 'f':\n            format = optarg;\n            break;\n        case 'c':\n            add_user_command(optarg);\n            break;\n        case 'r':\n            readonly = 1;\n            break;\n        case 'm':\n            qemuio_misalign = true;\n            break;\n        case 'k':\n            flags |= BDRV_O_NATIVE_AIO;\n            break;\n        case 'i':\n            if (bdrv_parse_aio(optarg, &flags) < 0) {\n                error_report(\"Invalid aio option: %s\", optarg);\n                exit(1);\n            }\n            break;\n        case 't':\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) < 0) {\n                error_report(\"Invalid cache option: %s\", optarg);\n                exit(1);\n            }\n            break;\n        case 'T':\n            trace_opt_parse(optarg);\n            break;\n        case 'V':\n            printf(\"%s version \" QEMU_FULL_VERSION \"\\n\"\n                   QEMU_COPYRIGHT \"\\n\", g_get_prgname());\n            exit(0);\n        case 'h':\n            usage(g_get_prgname());\n            exit(0);\n        case 'U':\n            force_share = true;\n            break;\n        case OPTION_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case OPTION_IMAGE_OPTS:\n            imageOpts = true;\n            break;\n        default:\n            usage(g_get_prgname());\n            exit(1);\n        }\n    }\n\n    if ((argc - optind) > 1) {\n        usage(g_get_prgname());\n        exit(1);\n    }\n\n    if (format && imageOpts) {\n        error_report(\"--image-opts and -f are mutually exclusive\");\n        exit(1);\n    }\n\n    qemu_init_main_loop(&error_fatal);\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file();\n    qemu_set_log(LOG_TRACE, &error_fatal);\n\n    /* initialize commands */\n    qemuio_add_command(&quit_cmd);\n    qemuio_add_command(&open_cmd);\n    qemuio_add_command(&close_cmd);\n\n    if (isatty(STDIN_FILENO)) {\n        ttyEOF = get_eof_char();\n        readline_state = readline_init(readline_printf_func,\n                                       readline_flush_func,\n                                       NULL,\n                                       readline_completion_func);\n        qemu_set_tty_echo(STDIN_FILENO, false);\n        atexit(reenable_tty_echo);\n    }\n\n    /* open the device */\n    if (!readonly) {\n        flags |= BDRV_O_RDWR;\n    }\n\n    if ((argc - optind) == 1) {\n        if (imageOpts) {\n            QemuOpts *qopts = NULL;\n            qopts = qemu_opts_parse_noisily(&file_opts, argv[optind], false);\n            if (!qopts) {\n                exit(1);\n            }\n            opts = qemu_opts_to_qdict(qopts, NULL);\n            if (openfile(NULL, flags, writethrough, force_share, opts)) {\n                exit(1);\n            }\n        } else {\n            if (format) {\n                opts = qdict_new();\n                qdict_put_str(opts, \"driver\", format);\n            }\n            if (openfile(argv[optind], flags, writethrough,\n                         force_share, opts)) {\n                exit(1);\n            }\n        }\n    }\n    ret = command_loop();\n\n    /*\n     * Make sure all outstanding requests complete before the program exits.\n     */\n    bdrv_drain_all();\n\n    blk_unref(qemuio_blk);\n    g_free(readline_state);\n\n    if (ret < 0) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n"
        },
        {
          "name": "qemu-keymap.c",
          "type": "blob",
          "size": 7.41015625,
          "content": "/*\n * QEMU keymap utility\n *\n * Copyright Red Hat, Inc. 2017\n *\n * Authors:\n *     Gerd Hoffmann <kraxel@redhat.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n#include \"qemu/osdep.h\"\n#include \"qemu/notify.h\"\n#include \"ui/input.h\"\n\n#include <xkbcommon/xkbcommon.h>\n\nstruct xkb_rule_names names = {\n    .rules   = NULL,\n    .model   = \"pc105\",\n    .layout  = \"us\",\n    .variant = NULL,\n    .options = NULL,\n};\n\nstatic xkb_mod_mask_t shift;\nstatic xkb_mod_mask_t ctrl;\nstatic xkb_mod_mask_t altgr;\nstatic xkb_mod_mask_t numlock;\n\nstatic FILE *outfile;\n\n/* ------------------------------------------------------------------------ */\n\nstatic uint32_t qcode_to_number(uint32_t qcode)\n{\n    KeyValue keyvalue;\n    uint32_t number;\n\n    keyvalue.type = KEY_VALUE_KIND_QCODE;\n    keyvalue.u.qcode.data = qcode;\n    number = qemu_input_key_value_to_number(&keyvalue);\n    assert(number != 0);\n    return number;\n}\n\nstatic void print_sym(xkb_keysym_t sym, uint32_t qcode, const char *mod)\n{\n    char name[64];\n\n    if (sym == XKB_KEY_NoSymbol) {\n        return;\n    }\n    xkb_keysym_get_name(sym, name, sizeof(name));\n\n    /* TODO: make ui/keymap.c parser accept QKeyCode names */\n    fprintf(outfile, \"%s 0x%02x%s\\n\", name, qcode_to_number(qcode), mod);\n}\n\nstatic void walk_map(struct xkb_keymap *map, xkb_keycode_t code, void *data)\n{\n    struct xkb_state *state = data;\n    xkb_keysym_t kbase, knumlock, kshift, kaltgr, kaltgrshift;\n    uint32_t evdev, qcode;\n    char name[64];\n\n    fprintf(outfile, \"\\n\");\n\n    /*\n     * map xkb keycode -> QKeyCode\n     *\n     * xkb keycode is linux evdev shifted by 8\n     */\n    evdev = code - 8;\n    qcode = qemu_input_linux_to_qcode(evdev);\n    if (qcode == Q_KEY_CODE_UNMAPPED) {\n        xkb_state_update_mask(state,  0, 0, 0,  0, 0, 0);\n        kbase = xkb_state_key_get_one_sym(state, code);\n        xkb_keysym_get_name(kbase, name, sizeof(name));\n        fprintf(outfile, \"# evdev %d (0x%x): no evdev -> QKeyCode mapping\"\n                \" (xkb keysym %s)\\n\", evdev, evdev, name);\n        return;\n    }\n    fprintf(outfile, \"# evdev %d (0x%x), QKeyCode \\\"%s\\\", number 0x%x\\n\",\n            evdev, evdev,\n            QKeyCode_str(qcode),\n            qcode_to_number(qcode));\n\n    /*\n     * check which modifier states generate which keysyms\n     */\n    xkb_state_update_mask(state,  0, 0, 0,  0, 0, 0);\n    kbase = xkb_state_key_get_one_sym(state, code);\n    print_sym(kbase, qcode, \"\");\n\n    xkb_state_update_mask(state,  0, 0, numlock,  0, 0, 0);\n    knumlock = xkb_state_key_get_one_sym(state, code);\n    if (kbase != knumlock) {\n        print_sym(knumlock, qcode, \" numlock\");\n    }\n\n    xkb_state_update_mask(state,  shift, 0, 0,  0, 0, 0);\n    kshift = xkb_state_key_get_one_sym(state, code);\n    if (kbase != kshift && knumlock != kshift) {\n        print_sym(kshift, qcode, \" shift\");\n    }\n\n    xkb_state_update_mask(state,  altgr, 0, 0,  0, 0, 0);\n    kaltgr = xkb_state_key_get_one_sym(state, code);\n    if (kbase != kaltgr) {\n        print_sym(kaltgr, qcode, \" altgr\");\n    }\n\n    xkb_state_update_mask(state,  altgr | shift, 0, 0,  0, 0, 0);\n    kaltgrshift = xkb_state_key_get_one_sym(state, code);\n    if (kshift != kaltgrshift && kaltgr != kaltgrshift) {\n        print_sym(kaltgrshift, qcode, \" shift altgr\");\n    }\n    return;\n}\n\nstatic void usage(FILE *out)\n{\n    fprintf(out,\n            \"\\n\"\n            \"This tool generates qemu reverse keymaps from xkb keymaps,\\n\"\n            \"which can be used with the qemu \\\"-k\\\" command line switch.\\n\"\n            \"\\n\"\n            \"usage: qemu-keymap <options>\\n\"\n            \"options:\\n\"\n            \"    -h             print this text\\n\"\n            \"    -f <file>      set output file          (default: stdout)\\n\"\n            \"    -m <model>     set kbd model            (default: %s)\\n\"\n            \"    -l <layout>    set kbd layout           (default: %s)\\n\"\n            \"    -v <variant>   set kbd variant          (default: %s)\\n\"\n            \"    -o <options>   set kbd options          (default: %s)\\n\"\n            \"\\n\",\n            names.model, names.layout,\n            names.variant ?: \"-\",\n            names.options ?: \"-\");\n}\n\nint main(int argc, char *argv[])\n{\n    struct xkb_context *ctx;\n    struct xkb_keymap *map;\n    struct xkb_state *state;\n    xkb_mod_index_t mod, mods;\n    int rc;\n\n    for (;;) {\n        rc = getopt(argc, argv, \"hm:l:v:o:f:\");\n        if (rc == -1) {\n            break;\n        }\n        switch (rc) {\n        case 'm':\n            names.model = optarg;\n            break;\n        case 'l':\n            names.layout = optarg;\n            break;\n        case 'v':\n            names.variant = optarg;\n            break;\n        case 'o':\n            names.options = optarg;\n            break;\n        case 'f':\n            outfile = fopen(optarg, \"w\");\n            if (outfile == NULL) {\n                fprintf(stderr, \"open %s: %s\\n\", optarg, strerror(errno));\n                exit(1);\n            }\n            break;\n        case 'h':\n            usage(stdout);\n            exit(0);\n        default:\n            usage(stderr);\n            exit(1);\n        }\n    }\n\n    if (outfile == NULL) {\n        outfile = stdout;\n    }\n\n    fprintf(outfile,\n            \"# SPDX-License-Identifier: GPL-2.0-or-later\\n\"\n            \"#\\n\"\n            \"# generated by qemu-keymap\\n\"\n            \"#    model   : %s\\n\"\n            \"#    layout  : %s\\n\"\n            \"#    variant : %s\\n\"\n            \"#    options : %s\\n\"\n            \"\\n\",\n            names.model, names.layout,\n            names.variant ?: \"-\",\n            names.options ?: \"-\");\n\n    ctx = xkb_context_new(XKB_CONTEXT_NO_FLAGS);\n    map = xkb_keymap_new_from_names(ctx, &names, XKB_KEYMAP_COMPILE_NO_FLAGS);\n    if (!map) {\n        /* libxkbcommon prints error */\n        exit(1);\n    }\n\n    fprintf(outfile, \"# name: \\\"%s\\\"\\n\\n\",\n            xkb_keymap_layout_get_name(map, 0));\n    fprintf(outfile, \"# modifiers\\n\");\n    mods = xkb_keymap_num_mods(map);\n    for (mod = 0; mod < mods; mod++) {\n        fprintf(outfile, \"#    %2d: %s\\n\",\n                mod, xkb_keymap_mod_get_name(map, mod));\n    }\n\n    mod = xkb_keymap_mod_get_index(map, \"Shift\");\n    shift = (1 << mod);\n    mod = xkb_keymap_mod_get_index(map, \"Control\");\n    ctrl = (1 << mod);\n    mod = xkb_keymap_mod_get_index(map, \"AltGr\");\n    altgr = (1 << mod);\n    mod = xkb_keymap_mod_get_index(map, \"NumLock\");\n    numlock = (1 << mod);\n\n    state = xkb_state_new(map);\n    xkb_keymap_key_for_each(map, walk_map, state);\n\n    /* add quirks */\n    fprintf(outfile,\n            \"\\n\"\n            \"#\\n\"\n            \"# quirks section start\\n\"\n            \"#\\n\"\n            \"# Sometimes multiple keysyms map to the same keycodes.\\n\"\n            \"# The keycode -> keysym lookup finds only one of the\\n\"\n            \"# keysyms.  So append them here.\\n\"\n            \"#\\n\"\n            \"\\n\");\n    print_sym(XKB_KEY_Print,            Q_KEY_CODE_SYSRQ,      \"\");\n    print_sym(XKB_KEY_Sys_Req,          Q_KEY_CODE_SYSRQ,      \"\");\n    print_sym(XKB_KEY_Execute,          Q_KEY_CODE_SYSRQ,      \"\");\n\n    print_sym(XKB_KEY_KP_Decimal,       Q_KEY_CODE_KP_DECIMAL, \" numlock\");\n    print_sym(XKB_KEY_KP_Separator,     Q_KEY_CODE_KP_DECIMAL, \" numlock\");\n\n    print_sym(XKB_KEY_Alt_R,            Q_KEY_CODE_ALT_R,      \"\");\n    print_sym(XKB_KEY_ISO_Level3_Shift, Q_KEY_CODE_ALT_R,      \"\");\n    print_sym(XKB_KEY_Mode_switch,      Q_KEY_CODE_ALT_R,      \"\");\n\n    fprintf(outfile,\n            \"\\n\"\n            \"# quirks section end\\n\");\n\n    exit(0);\n}\n"
        },
        {
          "name": "qemu-nbd.c",
          "type": "blob",
          "size": 37.65625,
          "content": "/*\n *  Copyright (C) 2005  Anthony Liguori <anthony@codemonkey.ws>\n *\n *  Network Block Device\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; under version 2 of the License.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include <getopt.h>\n#include <libgen.h>\n#include <pthread.h>\n\n#include \"qemu/help-texts.h\"\n#include \"qapi/error.h\"\n#include \"qemu/cutils.h\"\n#include \"sysemu/block-backend.h\"\n#include \"sysemu/runstate.h\" /* for qemu_system_killed() prototype */\n#include \"block/block_int.h\"\n#include \"block/nbd.h\"\n#include \"qemu/main-loop.h\"\n#include \"qemu/module.h\"\n#include \"qemu/option.h\"\n#include \"qemu/error-report.h\"\n#include \"qemu/config-file.h\"\n#include \"qemu/bswap.h\"\n#include \"qemu/log.h\"\n#include \"qemu/systemd.h\"\n#include \"block/snapshot.h\"\n#include \"qapi/qmp/qdict.h\"\n#include \"qapi/qmp/qstring.h\"\n#include \"qom/object_interfaces.h\"\n#include \"io/channel-socket.h\"\n#include \"io/net-listener.h\"\n#include \"crypto/init.h\"\n#include \"crypto/tlscreds.h\"\n#include \"trace/control.h\"\n#include \"qemu-version.h\"\n\n#ifdef CONFIG_SELINUX\n#include <selinux/selinux.h>\n#endif\n\n#ifdef __linux__\n#define HAVE_NBD_DEVICE 1\n#else\n#define HAVE_NBD_DEVICE 0\n#endif\n\n#define SOCKET_PATH                \"/var/lock/qemu-nbd-%s\"\n#define QEMU_NBD_OPT_CACHE         256\n#define QEMU_NBD_OPT_AIO           257\n#define QEMU_NBD_OPT_DISCARD       258\n#define QEMU_NBD_OPT_DETECT_ZEROES 259\n#define QEMU_NBD_OPT_OBJECT        260\n#define QEMU_NBD_OPT_TLSCREDS      261\n#define QEMU_NBD_OPT_IMAGE_OPTS    262\n#define QEMU_NBD_OPT_FORK          263\n#define QEMU_NBD_OPT_TLSAUTHZ      264\n#define QEMU_NBD_OPT_PID_FILE      265\n#define QEMU_NBD_OPT_SELINUX_LABEL 266\n#define QEMU_NBD_OPT_TLSHOSTNAME   267\n\n#define MBR_SIZE 512\n\nstatic int verbose;\nstatic char *srcpath;\nstatic SocketAddress *saddr;\nstatic int persistent = 0;\nstatic enum { RUNNING, TERMINATE, TERMINATED } state;\nstatic int shared = 1;\nstatic int nb_fds;\nstatic QIONetListener *server;\nstatic QCryptoTLSCreds *tlscreds;\nstatic const char *tlsauthz;\n\nstatic void usage(const char *name)\n{\n    (printf) (\n\"Usage: %s [OPTIONS] FILE\\n\"\n\"  or:  %s -L [OPTIONS]\\n\"\n\"QEMU Disk Network Block Device Utility\\n\"\n\"\\n\"\n\"  -h, --help                display this help and exit\\n\"\n\"  -V, --version             output version information and exit\\n\"\n\"\\n\"\n\"Connection properties:\\n\"\n\"  -p, --port=PORT           port to listen on (default `%d')\\n\"\n\"  -b, --bind=IFACE          interface to bind to (default `0.0.0.0')\\n\"\n\"  -k, --socket=PATH         path to the unix socket\\n\"\n\"                            (default '\"SOCKET_PATH\"')\\n\"\n\"  -e, --shared=NUM          device can be shared by NUM clients (default '1')\\n\"\n\"  -t, --persistent          don't exit on the last connection\\n\"\n\"  -v, --verbose             display extra debugging information\\n\"\n\"  -x, --export-name=NAME    expose export by name (default is empty string)\\n\"\n\"  -D, --description=TEXT    export a human-readable description\\n\"\n\"\\n\"\n\"Exposing part of the image:\\n\"\n\"  -o, --offset=OFFSET       offset into the image\\n\"\n\"  -A, --allocation-depth    expose the allocation depth\\n\"\n\"  -B, --bitmap=NAME         expose a persistent dirty bitmap\\n\"\n\"\\n\"\n\"General purpose options:\\n\"\n\"  -L, --list                list exports available from another NBD server\\n\"\n\"  --object type,id=ID,...   define an object such as 'secret' for providing\\n\"\n\"                            passwords and/or encryption keys\\n\"\n\"  --tls-creds=ID            use id of an earlier --object to provide TLS\\n\"\n\"  --tls-authz=ID            use id of an earlier --object to provide\\n\"\n\"                            authorization\\n\"\n\"  -T, --trace [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\"                            specify tracing options\\n\"\n\"  --fork                    fork off the server process and exit the parent\\n\"\n\"                            once the server is running\\n\"\n\"  --pid-file=PATH           store the server's process ID in the given file\\n\"\n#ifdef CONFIG_SELINUX\n\"  --selinux-label=LABEL     set SELinux process label on listening socket\\n\"\n#endif\n#if HAVE_NBD_DEVICE\n\"\\n\"\n\"Kernel NBD client support:\\n\"\n\"  -c, --connect=DEV         connect FILE to the local NBD device DEV\\n\"\n\"  -d, --disconnect          disconnect the specified device\\n\"\n#endif\n\"\\n\"\n\"Block device options:\\n\"\n\"  -f, --format=FORMAT       set image format (raw, qcow2, ...)\\n\"\n\"  -r, --read-only           export read-only\\n\"\n\"  -s, --snapshot            use FILE as an external snapshot, create a temporary\\n\"\n\"                            file with backing_file=FILE, redirect the write to\\n\"\n\"                            the temporary one\\n\"\n\"  -l, --load-snapshot=SNAPSHOT_PARAM\\n\"\n\"                            load an internal snapshot inside FILE and export it\\n\"\n\"                            as an read-only device, SNAPSHOT_PARAM format is\\n\"\n\"                            'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\"                            '[ID_OR_NAME]'\\n\"\n\"  -n, --nocache             disable host cache\\n\"\n\"      --cache=MODE          set cache mode used to access the disk image, the\\n\"\n\"                            valid options are: 'none', 'writeback' (default),\\n\"\n\"                            'writethrough', 'directsync' and 'unsafe'\\n\"\n\"      --aio=MODE            set AIO mode (native, io_uring or threads)\\n\"\n\"      --discard=MODE        set discard mode (ignore, unmap)\\n\"\n\"      --detect-zeroes=MODE  set detect-zeroes mode (off, on, unmap)\\n\"\n\"      --image-opts          treat FILE as a full set of image options\\n\"\n\"\\n\"\nQEMU_HELP_BOTTOM \"\\n\"\n    , name, name, NBD_DEFAULT_PORT, \"DEVICE\");\n}\n\nstatic void version(const char *name)\n{\n    printf(\n\"%s \" QEMU_FULL_VERSION \"\\n\"\n\"Written by Anthony Liguori.\\n\"\n\"\\n\"\nQEMU_COPYRIGHT \"\\n\"\n\"This is free software; see the source for copying conditions.  There is NO\\n\"\n\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\"\n    , name);\n}\n\n#ifdef CONFIG_POSIX\n/*\n * The client thread uses SIGTERM to interrupt the server.  A signal\n * handler ensures that \"qemu-nbd -v -c\" exits with a nice status code.\n */\nvoid qemu_system_killed(int signum, pid_t pid)\n{\n    qatomic_cmpxchg(&state, RUNNING, TERMINATE);\n    qemu_notify_event();\n}\n#endif /* CONFIG_POSIX */\n\nstatic int qemu_nbd_client_list(SocketAddress *saddr, QCryptoTLSCreds *tls,\n                                const char *hostname)\n{\n    int ret = EXIT_FAILURE;\n    int rc;\n    Error *err = NULL;\n    QIOChannelSocket *sioc;\n    NBDExportInfo *list;\n    int i, j;\n\n    sioc = qio_channel_socket_new();\n    if (qio_channel_socket_connect_sync(sioc, saddr, &err) < 0) {\n        error_report_err(err);\n        goto out;\n    }\n    rc = nbd_receive_export_list(QIO_CHANNEL(sioc), tls, hostname, &list,\n                                 &err);\n    if (rc < 0) {\n        if (err) {\n            error_report_err(err);\n        }\n        goto out;\n    }\n    printf(\"exports available: %d\\n\", rc);\n    for (i = 0; i < rc; i++) {\n        printf(\" export: '%s'\\n\", list[i].name);\n        if (list[i].description && *list[i].description) {\n            printf(\"  description: %s\\n\", list[i].description);\n        }\n        if (list[i].flags & NBD_FLAG_HAS_FLAGS) {\n            static const char *const flag_names[] = {\n                [NBD_FLAG_READ_ONLY_BIT]            = \"readonly\",\n                [NBD_FLAG_SEND_FLUSH_BIT]           = \"flush\",\n                [NBD_FLAG_SEND_FUA_BIT]             = \"fua\",\n                [NBD_FLAG_ROTATIONAL_BIT]           = \"rotational\",\n                [NBD_FLAG_SEND_TRIM_BIT]            = \"trim\",\n                [NBD_FLAG_SEND_WRITE_ZEROES_BIT]    = \"zeroes\",\n                [NBD_FLAG_SEND_DF_BIT]              = \"df\",\n                [NBD_FLAG_CAN_MULTI_CONN_BIT]       = \"multi\",\n                [NBD_FLAG_SEND_RESIZE_BIT]          = \"resize\",\n                [NBD_FLAG_SEND_CACHE_BIT]           = \"cache\",\n                [NBD_FLAG_SEND_FAST_ZERO_BIT]       = \"fast-zero\",\n            };\n\n            printf(\"  size:  %\" PRIu64 \"\\n\", list[i].size);\n            printf(\"  flags: 0x%x (\", list[i].flags);\n            for (size_t bit = 0; bit < ARRAY_SIZE(flag_names); bit++) {\n                if (flag_names[bit] && (list[i].flags & (1 << bit))) {\n                    printf(\" %s\", flag_names[bit]);\n                }\n            }\n            printf(\" )\\n\");\n        }\n        if (list[i].min_block) {\n            printf(\"  min block: %u\\n\", list[i].min_block);\n            printf(\"  opt block: %u\\n\", list[i].opt_block);\n            printf(\"  max block: %u\\n\", list[i].max_block);\n        }\n        if (list[i].n_contexts) {\n            printf(\"  available meta contexts: %d\\n\", list[i].n_contexts);\n            for (j = 0; j < list[i].n_contexts; j++) {\n                printf(\"   %s\\n\", list[i].contexts[j]);\n            }\n        }\n    }\n    nbd_free_export_list(list, rc);\n\n    ret = EXIT_SUCCESS;\n out:\n    object_unref(OBJECT(sioc));\n    return ret;\n}\n\n\n#if HAVE_NBD_DEVICE\nstatic void *show_parts(void *arg)\n{\n    char *device = arg;\n    int nbd;\n\n    /* linux just needs an open() to trigger\n     * the partition table update\n     * but remember to load the module with max_part != 0 :\n     *     modprobe nbd max_part=63\n     */\n    nbd = open(device, O_RDWR);\n    if (nbd >= 0) {\n        close(nbd);\n    }\n    return NULL;\n}\n\nstatic void *nbd_client_thread(void *arg)\n{\n    char *device = arg;\n    NBDExportInfo info = { .request_sizes = false, .name = g_strdup(\"\") };\n    QIOChannelSocket *sioc;\n    int fd = -1;\n    int ret = EXIT_FAILURE;\n    pthread_t show_parts_thread;\n    Error *local_error = NULL;\n\n    sioc = qio_channel_socket_new();\n    if (qio_channel_socket_connect_sync(sioc,\n                                        saddr,\n                                        &local_error) < 0) {\n        error_report_err(local_error);\n        goto out;\n    }\n\n    if (nbd_receive_negotiate(NULL, QIO_CHANNEL(sioc),\n                              NULL, NULL, NULL, &info, &local_error) < 0) {\n        if (local_error) {\n            error_report_err(local_error);\n        }\n        goto out;\n    }\n\n    fd = open(device, O_RDWR);\n    if (fd < 0) {\n        /* Linux-only, we can use %m in printf.  */\n        error_report(\"Failed to open %s: %m\", device);\n        goto out;\n    }\n\n    if (nbd_init(fd, sioc, &info, &local_error) < 0) {\n        error_report_err(local_error);\n        goto out;\n    }\n\n    /* update partition table */\n    pthread_create(&show_parts_thread, NULL, show_parts, device);\n\n    if (verbose) {\n        fprintf(stderr, \"NBD device %s is now connected to %s\\n\",\n                device, srcpath);\n    } else {\n        /* Close stderr so that the qemu-nbd process exits.  */\n        dup2(STDOUT_FILENO, STDERR_FILENO);\n    }\n\n    if (nbd_client(fd) < 0) {\n        goto out;\n    }\n\n    ret = EXIT_SUCCESS;\n\n out:\n    if (fd >= 0) {\n        close(fd);\n    }\n    object_unref(OBJECT(sioc));\n    g_free(info.name);\n    kill(getpid(), SIGTERM);\n    return (void *) (intptr_t) ret;\n}\n#endif /* HAVE_NBD_DEVICE */\n\nstatic int nbd_can_accept(void)\n{\n    return state == RUNNING && (shared == 0 || nb_fds < shared);\n}\n\nstatic void nbd_update_server_watch(void);\n\nstatic void nbd_client_closed(NBDClient *client, bool negotiated)\n{\n    nb_fds--;\n    if (negotiated && nb_fds == 0 && !persistent && state == RUNNING) {\n        state = TERMINATE;\n    }\n    nbd_update_server_watch();\n    nbd_client_put(client);\n}\n\nstatic void nbd_accept(QIONetListener *listener, QIOChannelSocket *cioc,\n                       gpointer opaque)\n{\n    if (state >= TERMINATE) {\n        return;\n    }\n\n    nb_fds++;\n    nbd_update_server_watch();\n    nbd_client_new(cioc, tlscreds, tlsauthz, nbd_client_closed);\n}\n\nstatic void nbd_update_server_watch(void)\n{\n    if (nbd_can_accept()) {\n        qio_net_listener_set_client_func(server, nbd_accept, NULL, NULL);\n    } else {\n        qio_net_listener_set_client_func(server, NULL, NULL, NULL);\n    }\n}\n\n\nstatic SocketAddress *nbd_build_socket_address(const char *sockpath,\n                                               const char *bindto,\n                                               const char *port)\n{\n    SocketAddress *saddr;\n\n    saddr = g_new0(SocketAddress, 1);\n    if (sockpath) {\n        saddr->type = SOCKET_ADDRESS_TYPE_UNIX;\n        saddr->u.q_unix.path = g_strdup(sockpath);\n    } else {\n        InetSocketAddress *inet;\n        saddr->type = SOCKET_ADDRESS_TYPE_INET;\n        inet = &saddr->u.inet;\n        inet->host = g_strdup(bindto);\n        if (port) {\n            inet->port = g_strdup(port);\n        } else  {\n            inet->port = g_strdup_printf(\"%d\", NBD_DEFAULT_PORT);\n        }\n    }\n\n    return saddr;\n}\n\n\nstatic QemuOptsList file_opts = {\n    .name = \"file\",\n    .implied_opt_name = \"file\",\n    .head = QTAILQ_HEAD_INITIALIZER(file_opts.head),\n    .desc = {\n        /* no elements => accept any params */\n        { /* end of list */ }\n    },\n};\n\nstatic QCryptoTLSCreds *nbd_get_tls_creds(const char *id, bool list,\n                                          Error **errp)\n{\n    Object *obj;\n    QCryptoTLSCreds *creds;\n\n    obj = object_resolve_path_component(\n        object_get_objects_root(), id);\n    if (!obj) {\n        error_setg(errp, \"No TLS credentials with id '%s'\",\n                   id);\n        return NULL;\n    }\n    creds = (QCryptoTLSCreds *)\n        object_dynamic_cast(obj, TYPE_QCRYPTO_TLS_CREDS);\n    if (!creds) {\n        error_setg(errp, \"Object with id '%s' is not TLS credentials\",\n                   id);\n        return NULL;\n    }\n\n    if (!qcrypto_tls_creds_check_endpoint(creds,\n                                          list\n                                          ? QCRYPTO_TLS_CREDS_ENDPOINT_CLIENT\n                                          : QCRYPTO_TLS_CREDS_ENDPOINT_SERVER,\n                                          errp)) {\n        return NULL;\n    }\n    object_ref(obj);\n    return creds;\n}\n\nstatic void setup_address_and_port(const char **address, const char **port)\n{\n    if (*address == NULL) {\n        *address = \"0.0.0.0\";\n    }\n\n    if (*port == NULL) {\n        *port = stringify(NBD_DEFAULT_PORT);\n    }\n}\n\n/*\n * Check socket parameters compatibility when socket activation is used.\n */\nstatic const char *socket_activation_validate_opts(const char *device,\n                                                   const char *sockpath,\n                                                   const char *address,\n                                                   const char *port,\n                                                   const char *selinux,\n                                                   bool list)\n{\n    if (device != NULL) {\n        return \"NBD device can't be set when using socket activation\";\n    }\n\n    if (sockpath != NULL) {\n        return \"Unix socket can't be set when using socket activation\";\n    }\n\n    if (address != NULL) {\n        return \"The interface can't be set when using socket activation\";\n    }\n\n    if (port != NULL) {\n        return \"TCP port number can't be set when using socket activation\";\n    }\n\n    if (selinux != NULL) {\n        return \"SELinux label can't be set when using socket activation\";\n    }\n\n    if (list) {\n        return \"List mode is incompatible with socket activation\";\n    }\n\n    return NULL;\n}\n\nstatic void qemu_nbd_shutdown(void)\n{\n    job_cancel_sync_all();\n    blk_exp_close_all();\n    bdrv_close_all();\n}\n\nint main(int argc, char **argv)\n{\n    BlockBackend *blk;\n    BlockDriverState *bs;\n    uint64_t dev_offset = 0;\n    bool readonly = false;\n    bool disconnect = false;\n    const char *bindto = NULL;\n    const char *port = NULL;\n    char *sockpath = NULL;\n    char *device = NULL;\n    QemuOpts *sn_opts = NULL;\n    const char *sn_id_or_name = NULL;\n    const char *sopt = \"hVb:o:p:rsnc:dvk:e:f:tl:x:T:D:AB:L\";\n    struct option lopt[] = {\n        { \"help\", no_argument, NULL, 'h' },\n        { \"version\", no_argument, NULL, 'V' },\n        { \"bind\", required_argument, NULL, 'b' },\n        { \"port\", required_argument, NULL, 'p' },\n        { \"socket\", required_argument, NULL, 'k' },\n        { \"offset\", required_argument, NULL, 'o' },\n        { \"read-only\", no_argument, NULL, 'r' },\n        { \"allocation-depth\", no_argument, NULL, 'A' },\n        { \"bitmap\", required_argument, NULL, 'B' },\n        { \"connect\", required_argument, NULL, 'c' },\n        { \"disconnect\", no_argument, NULL, 'd' },\n        { \"list\", no_argument, NULL, 'L' },\n        { \"snapshot\", no_argument, NULL, 's' },\n        { \"load-snapshot\", required_argument, NULL, 'l' },\n        { \"nocache\", no_argument, NULL, 'n' },\n        { \"cache\", required_argument, NULL, QEMU_NBD_OPT_CACHE },\n        { \"aio\", required_argument, NULL, QEMU_NBD_OPT_AIO },\n        { \"discard\", required_argument, NULL, QEMU_NBD_OPT_DISCARD },\n        { \"detect-zeroes\", required_argument, NULL,\n          QEMU_NBD_OPT_DETECT_ZEROES },\n        { \"shared\", required_argument, NULL, 'e' },\n        { \"format\", required_argument, NULL, 'f' },\n        { \"persistent\", no_argument, NULL, 't' },\n        { \"verbose\", no_argument, NULL, 'v' },\n        { \"object\", required_argument, NULL, QEMU_NBD_OPT_OBJECT },\n        { \"export-name\", required_argument, NULL, 'x' },\n        { \"description\", required_argument, NULL, 'D' },\n        { \"tls-creds\", required_argument, NULL, QEMU_NBD_OPT_TLSCREDS },\n        { \"tls-hostname\", required_argument, NULL, QEMU_NBD_OPT_TLSHOSTNAME },\n        { \"tls-authz\", required_argument, NULL, QEMU_NBD_OPT_TLSAUTHZ },\n        { \"image-opts\", no_argument, NULL, QEMU_NBD_OPT_IMAGE_OPTS },\n        { \"trace\", required_argument, NULL, 'T' },\n        { \"fork\", no_argument, NULL, QEMU_NBD_OPT_FORK },\n        { \"pid-file\", required_argument, NULL, QEMU_NBD_OPT_PID_FILE },\n        { \"selinux-label\", required_argument, NULL,\n          QEMU_NBD_OPT_SELINUX_LABEL },\n        { NULL, 0, NULL, 0 }\n    };\n    int ch;\n    int opt_ind = 0;\n    int flags = BDRV_O_RDWR;\n    int ret = 0;\n    bool seen_cache = false;\n    bool seen_discard = false;\n    bool seen_aio = false;\n    pthread_t client_thread;\n    const char *fmt = NULL;\n    Error *local_err = NULL;\n    BlockdevDetectZeroesOptions detect_zeroes = BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF;\n    QDict *options = NULL;\n    const char *export_name = NULL; /* defaults to \"\" later for server mode */\n    const char *export_description = NULL;\n    BlockDirtyBitmapOrStrList *bitmaps = NULL;\n    bool alloc_depth = false;\n    const char *tlscredsid = NULL;\n    const char *tlshostname = NULL;\n    bool imageOpts = false;\n    bool writethrough = false; /* Client will flush as needed. */\n    bool fork_process = false;\n    bool list = false;\n    int old_stderr = -1;\n    unsigned socket_activation;\n    const char *pid_file_name = NULL;\n    const char *selinux_label = NULL;\n    BlockExportOptions *export_opts;\n\n#ifdef CONFIG_POSIX\n    os_setup_early_signal_handling();\n    os_setup_signal_handling();\n#endif\n\n    socket_init();\n    error_init(argv[0]);\n    module_call_init(MODULE_INIT_TRACE);\n    qcrypto_init(&error_fatal);\n\n    module_call_init(MODULE_INIT_QOM);\n    qemu_add_opts(&qemu_trace_opts);\n    qemu_init_exec_dir(argv[0]);\n\n    while ((ch = getopt_long(argc, argv, sopt, lopt, &opt_ind)) != -1) {\n        switch (ch) {\n        case 's':\n            flags |= BDRV_O_SNAPSHOT;\n            break;\n        case 'n':\n            optarg = (char *) \"none\";\n            /* fallthrough */\n        case QEMU_NBD_OPT_CACHE:\n            if (seen_cache) {\n                error_report(\"-n and --cache can only be specified once\");\n                exit(EXIT_FAILURE);\n            }\n            seen_cache = true;\n            if (bdrv_parse_cache_mode(optarg, &flags, &writethrough) == -1) {\n                error_report(\"Invalid cache mode `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case QEMU_NBD_OPT_AIO:\n            if (seen_aio) {\n                error_report(\"--aio can only be specified once\");\n                exit(EXIT_FAILURE);\n            }\n            seen_aio = true;\n            if (bdrv_parse_aio(optarg, &flags) < 0) {\n                error_report(\"Invalid aio mode '%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case QEMU_NBD_OPT_DISCARD:\n            if (seen_discard) {\n                error_report(\"--discard can only be specified once\");\n                exit(EXIT_FAILURE);\n            }\n            seen_discard = true;\n            if (bdrv_parse_discard_flags(optarg, &flags) == -1) {\n                error_report(\"Invalid discard mode `%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case QEMU_NBD_OPT_DETECT_ZEROES:\n            detect_zeroes =\n                qapi_enum_parse(&BlockdevDetectZeroesOptions_lookup,\n                                optarg,\n                                BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,\n                                &local_err);\n            if (local_err) {\n                error_reportf_err(local_err,\n                                  \"Failed to parse detect_zeroes mode: \");\n                exit(EXIT_FAILURE);\n            }\n            if (detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP &&\n                !(flags & BDRV_O_UNMAP)) {\n                error_report(\"setting detect-zeroes to unmap is not allowed \"\n                             \"without setting discard operation to unmap\");\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'b':\n            bindto = optarg;\n            break;\n        case 'p':\n            port = optarg;\n            break;\n        case 'o':\n            if (qemu_strtou64(optarg, NULL, 0, &dev_offset) < 0) {\n                error_report(\"Invalid offset '%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'l':\n            if (strstart(optarg, SNAPSHOT_OPT_BASE, NULL)) {\n                sn_opts = qemu_opts_parse_noisily(&internal_snapshot_opts,\n                                                  optarg, false);\n                if (!sn_opts) {\n                    error_report(\"Failed in parsing snapshot param `%s'\",\n                                 optarg);\n                    exit(EXIT_FAILURE);\n                }\n            } else {\n                sn_id_or_name = optarg;\n            }\n            /* fall through */\n        case 'r':\n            readonly = true;\n            flags &= ~BDRV_O_RDWR;\n            break;\n        case 'A':\n            alloc_depth = true;\n            break;\n        case 'B':\n            {\n                BlockDirtyBitmapOrStr *el = g_new(BlockDirtyBitmapOrStr, 1);\n                *el = (BlockDirtyBitmapOrStr) {\n                    .type = QTYPE_QSTRING,\n                    .u.local = g_strdup(optarg),\n                };\n                QAPI_LIST_PREPEND(bitmaps, el);\n            }\n            break;\n        case 'k':\n            sockpath = optarg;\n            if (sockpath[0] != '/') {\n                error_report(\"socket path must be absolute\");\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'd':\n            disconnect = true;\n            break;\n        case 'c':\n            device = optarg;\n            break;\n        case 'e':\n            if (qemu_strtoi(optarg, NULL, 0, &shared) < 0 ||\n                shared < 0) {\n                error_report(\"Invalid shared device number '%s'\", optarg);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'f':\n            fmt = optarg;\n            break;\n        case 't':\n            persistent = 1;\n            break;\n        case 'x':\n            export_name = optarg;\n            if (strlen(export_name) > NBD_MAX_STRING_SIZE) {\n                error_report(\"export name '%s' too long\", export_name);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'D':\n            export_description = optarg;\n            if (strlen(export_description) > NBD_MAX_STRING_SIZE) {\n                error_report(\"export description '%s' too long\",\n                             export_description);\n                exit(EXIT_FAILURE);\n            }\n            break;\n        case 'v':\n            verbose = 1;\n            break;\n        case 'V':\n            version(argv[0]);\n            exit(0);\n            break;\n        case 'h':\n            usage(argv[0]);\n            exit(0);\n            break;\n        case '?':\n            error_report(\"Try `%s --help' for more information.\", argv[0]);\n            exit(EXIT_FAILURE);\n        case QEMU_NBD_OPT_OBJECT:\n            user_creatable_process_cmdline(optarg);\n            break;\n        case QEMU_NBD_OPT_TLSCREDS:\n            tlscredsid = optarg;\n            break;\n        case QEMU_NBD_OPT_TLSHOSTNAME:\n            tlshostname = optarg;\n            break;\n        case QEMU_NBD_OPT_IMAGE_OPTS:\n            imageOpts = true;\n            break;\n        case 'T':\n            trace_opt_parse(optarg);\n            break;\n        case QEMU_NBD_OPT_TLSAUTHZ:\n            tlsauthz = optarg;\n            break;\n        case QEMU_NBD_OPT_FORK:\n            fork_process = true;\n            break;\n        case 'L':\n            list = true;\n            break;\n        case QEMU_NBD_OPT_PID_FILE:\n            pid_file_name = optarg;\n            break;\n        case QEMU_NBD_OPT_SELINUX_LABEL:\n            selinux_label = optarg;\n            break;\n        }\n    }\n\n    if (list) {\n        if (argc != optind) {\n            error_report(\"List mode is incompatible with a file name\");\n            exit(EXIT_FAILURE);\n        }\n        if (export_name || export_description || dev_offset ||\n            device || disconnect || fmt || sn_id_or_name || bitmaps ||\n            alloc_depth || seen_aio || seen_discard || seen_cache) {\n            error_report(\"List mode is incompatible with per-device settings\");\n            exit(EXIT_FAILURE);\n        }\n        if (fork_process) {\n            error_report(\"List mode is incompatible with forking\");\n            exit(EXIT_FAILURE);\n        }\n    } else if ((argc - optind) != 1) {\n        error_report(\"Invalid number of arguments\");\n        error_printf(\"Try `%s --help' for more information.\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    } else if (!export_name) {\n        export_name = \"\";\n    }\n\n    if (!trace_init_backends()) {\n        exit(1);\n    }\n    trace_init_file();\n    qemu_set_log(LOG_TRACE, &error_fatal);\n\n    socket_activation = check_socket_activation();\n    if (socket_activation == 0) {\n        if (!sockpath) {\n            setup_address_and_port(&bindto, &port);\n        }\n    } else {\n        /* Using socket activation - check user didn't use -p etc. */\n        const char *err_msg = socket_activation_validate_opts(device, sockpath,\n                                                              bindto, port,\n                                                              selinux_label,\n                                                              list);\n        if (err_msg != NULL) {\n            error_report(\"%s\", err_msg);\n            exit(EXIT_FAILURE);\n        }\n\n        /* qemu-nbd can only listen on a single socket.  */\n        if (socket_activation > 1) {\n            error_report(\"qemu-nbd does not support socket activation with %s > 1\",\n                         \"LISTEN_FDS\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (tlscredsid) {\n        if (device) {\n            error_report(\"TLS is not supported with a host device\");\n            exit(EXIT_FAILURE);\n        }\n        if (tlsauthz && list) {\n            error_report(\"TLS authorization is incompatible with export list\");\n            exit(EXIT_FAILURE);\n        }\n        if (tlshostname && !list) {\n            error_report(\"TLS hostname is only supported with export list\");\n            exit(EXIT_FAILURE);\n        }\n        tlscreds = nbd_get_tls_creds(tlscredsid, list, &local_err);\n        if (local_err) {\n            error_reportf_err(local_err, \"Failed to get TLS creds: \");\n            exit(EXIT_FAILURE);\n        }\n    } else {\n        if (tlsauthz) {\n            error_report(\"--tls-authz is not permitted without --tls-creds\");\n            exit(EXIT_FAILURE);\n        }\n        if (tlshostname) {\n            error_report(\"--tls-hostname is not permitted without --tls-creds\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    if (selinux_label) {\n#ifdef CONFIG_SELINUX\n        if (sockpath == NULL && device == NULL) {\n            error_report(\"--selinux-label is not permitted without --socket\");\n            exit(EXIT_FAILURE);\n        }\n#else\n        error_report(\"SELinux support not enabled in this binary\");\n        exit(EXIT_FAILURE);\n#endif\n    }\n\n    if (list) {\n        saddr = nbd_build_socket_address(sockpath, bindto, port);\n        return qemu_nbd_client_list(saddr, tlscreds,\n                                    tlshostname ? tlshostname : bindto);\n    }\n\n#if !HAVE_NBD_DEVICE\n    if (disconnect || device) {\n        error_report(\"Kernel /dev/nbdN support not available\");\n        exit(EXIT_FAILURE);\n    }\n#else /* HAVE_NBD_DEVICE */\n    if (disconnect) {\n        int nbdfd = open(argv[optind], O_RDWR);\n        if (nbdfd < 0) {\n            error_report(\"Cannot open %s: %s\", argv[optind],\n                         strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n        nbd_disconnect(nbdfd);\n\n        close(nbdfd);\n\n        printf(\"%s disconnected\\n\", argv[optind]);\n\n        return 0;\n    }\n#endif\n\n    if ((device && !verbose) || fork_process) {\n#ifndef WIN32\n        g_autoptr(GError) err = NULL;\n        int stderr_fd[2];\n        pid_t pid;\n        int ret;\n\n        if (!g_unix_open_pipe(stderr_fd, FD_CLOEXEC, &err)) {\n            error_report(\"Error setting up communication pipe: %s\",\n                         err->message);\n            exit(EXIT_FAILURE);\n        }\n\n        /* Now daemonize, but keep a communication channel open to\n         * print errors and exit with the proper status code.\n         */\n        pid = fork();\n        if (pid < 0) {\n            error_report(\"Failed to fork: %s\", strerror(errno));\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            close(stderr_fd[0]);\n\n            /* Remember parent's stderr if we will be restoring it. */\n            if (fork_process) {\n                old_stderr = dup(STDERR_FILENO);\n            }\n\n            ret = qemu_daemon(1, 0);\n\n            /* Temporarily redirect stderr to the parent's pipe...  */\n            dup2(stderr_fd[1], STDERR_FILENO);\n            if (ret < 0) {\n                error_report(\"Failed to daemonize: %s\", strerror(errno));\n                exit(EXIT_FAILURE);\n            }\n\n            /* ... close the descriptor we inherited and go on.  */\n            close(stderr_fd[1]);\n        } else {\n            bool errors = false;\n            char *buf;\n\n            /* In the parent.  Print error messages from the child until\n             * it closes the pipe.\n             */\n            close(stderr_fd[1]);\n            buf = g_malloc(1024);\n            while ((ret = read(stderr_fd[0], buf, 1024)) > 0) {\n                errors = true;\n                ret = qemu_write_full(STDERR_FILENO, buf, ret);\n                if (ret < 0) {\n                    exit(EXIT_FAILURE);\n                }\n            }\n            if (ret < 0) {\n                error_report(\"Cannot read from daemon: %s\",\n                             strerror(errno));\n                exit(EXIT_FAILURE);\n            }\n\n            /* Usually the daemon should not print any message.\n             * Exit with zero status in that case.\n             */\n            exit(errors);\n        }\n#else /* WIN32 */\n        error_report(\"Unable to fork into background on Windows hosts\");\n        exit(EXIT_FAILURE);\n#endif /* WIN32 */\n    }\n\n    if (device != NULL && sockpath == NULL) {\n        sockpath = g_malloc(128);\n        snprintf(sockpath, 128, SOCKET_PATH, basename(device));\n    }\n\n    server = qio_net_listener_new();\n    if (socket_activation == 0) {\n        int backlog;\n\n        if (persistent || shared == 0) {\n            backlog = SOMAXCONN;\n        } else {\n            backlog = MIN(shared, SOMAXCONN);\n        }\n#ifdef CONFIG_SELINUX\n        if (selinux_label && setsockcreatecon_raw(selinux_label) == -1) {\n            error_report(\"Cannot set SELinux socket create context to %s: %s\",\n                         selinux_label, strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n#endif\n        saddr = nbd_build_socket_address(sockpath, bindto, port);\n        if (qio_net_listener_open_sync(server, saddr, backlog,\n                                       &local_err) < 0) {\n            object_unref(OBJECT(server));\n            error_report_err(local_err);\n            exit(EXIT_FAILURE);\n        }\n#ifdef CONFIG_SELINUX\n        if (selinux_label && setsockcreatecon_raw(NULL) == -1) {\n            error_report(\"Cannot clear SELinux socket create context: %s\",\n                         strerror(errno));\n            exit(EXIT_FAILURE);\n        }\n#endif\n    } else {\n        size_t i;\n        /* See comment in check_socket_activation above. */\n        for (i = 0; i < socket_activation; i++) {\n            QIOChannelSocket *sioc;\n            sioc = qio_channel_socket_new_fd(FIRST_SOCKET_ACTIVATION_FD + i,\n                                             &local_err);\n            if (sioc == NULL) {\n                object_unref(OBJECT(server));\n                error_reportf_err(local_err,\n                                  \"Failed to use socket activation: \");\n                exit(EXIT_FAILURE);\n            }\n            qio_net_listener_add(server, sioc);\n            object_unref(OBJECT(sioc));\n        }\n    }\n\n    qemu_init_main_loop(&error_fatal);\n    bdrv_init();\n    atexit(qemu_nbd_shutdown);\n\n    srcpath = argv[optind];\n    if (imageOpts) {\n        QemuOpts *opts;\n        if (fmt) {\n            error_report(\"--image-opts and -f are mutually exclusive\");\n            exit(EXIT_FAILURE);\n        }\n        opts = qemu_opts_parse_noisily(&file_opts, srcpath, true);\n        if (!opts) {\n            qemu_opts_reset(&file_opts);\n            exit(EXIT_FAILURE);\n        }\n        options = qemu_opts_to_qdict(opts, NULL);\n        qemu_opts_reset(&file_opts);\n        blk = blk_new_open(NULL, NULL, options, flags, &local_err);\n    } else {\n        if (fmt) {\n            options = qdict_new();\n            qdict_put_str(options, \"driver\", fmt);\n        }\n        blk = blk_new_open(srcpath, NULL, options, flags, &local_err);\n    }\n\n    if (!blk) {\n        error_reportf_err(local_err, \"Failed to blk_new_open '%s': \",\n                          argv[optind]);\n        exit(EXIT_FAILURE);\n    }\n    bs = blk_bs(blk);\n\n    if (dev_offset) {\n        QDict *raw_opts = qdict_new();\n        qdict_put_str(raw_opts, \"driver\", \"raw\");\n        qdict_put_str(raw_opts, \"file\", bs->node_name);\n        qdict_put_int(raw_opts, \"offset\", dev_offset);\n        bs = bdrv_open(NULL, NULL, raw_opts, flags, &error_fatal);\n        blk_remove_bs(blk);\n        blk_insert_bs(blk, bs, &error_fatal);\n        bdrv_unref(bs);\n    }\n\n    blk_set_enable_write_cache(blk, !writethrough);\n\n    if (sn_opts) {\n        ret = bdrv_snapshot_load_tmp(bs,\n                                     qemu_opt_get(sn_opts, SNAPSHOT_OPT_ID),\n                                     qemu_opt_get(sn_opts, SNAPSHOT_OPT_NAME),\n                                     &local_err);\n    } else if (sn_id_or_name) {\n        ret = bdrv_snapshot_load_tmp_by_id_or_name(bs, sn_id_or_name,\n                                                   &local_err);\n    }\n    if (ret < 0) {\n        error_reportf_err(local_err, \"Failed to load snapshot: \");\n        exit(EXIT_FAILURE);\n    }\n\n    bs->detect_zeroes = detect_zeroes;\n\n    nbd_server_is_qemu_nbd(shared);\n\n    export_opts = g_new(BlockExportOptions, 1);\n    *export_opts = (BlockExportOptions) {\n        .type               = BLOCK_EXPORT_TYPE_NBD,\n        .id                 = g_strdup(\"qemu-nbd-export\"),\n        .node_name          = g_strdup(bdrv_get_node_name(bs)),\n        .has_writethrough   = true,\n        .writethrough       = writethrough,\n        .has_writable       = true,\n        .writable           = !readonly,\n        .u.nbd = {\n            .has_name             = true,\n            .name                 = g_strdup(export_name),\n            .has_description      = !!export_description,\n            .description          = g_strdup(export_description),\n            .has_bitmaps          = !!bitmaps,\n            .bitmaps              = bitmaps,\n            .has_allocation_depth = alloc_depth,\n            .allocation_depth     = alloc_depth,\n        },\n    };\n    blk_exp_add(export_opts, &error_fatal);\n    qapi_free_BlockExportOptions(export_opts);\n\n    if (device) {\n#if HAVE_NBD_DEVICE\n        int ret;\n\n        ret = pthread_create(&client_thread, NULL, nbd_client_thread, device);\n        if (ret != 0) {\n            error_report(\"Failed to create client thread: %s\", strerror(ret));\n            exit(EXIT_FAILURE);\n        }\n#endif\n    } else {\n        /* Shut up GCC warnings.  */\n        memset(&client_thread, 0, sizeof(client_thread));\n    }\n\n    nbd_update_server_watch();\n\n    if (pid_file_name) {\n        qemu_write_pidfile(pid_file_name, &error_fatal);\n    }\n\n    /* now when the initialization is (almost) complete, chdir(\"/\")\n     * to free any busy filesystems */\n    if (chdir(\"/\") < 0) {\n        error_report(\"Could not chdir to root directory: %s\",\n                     strerror(errno));\n        exit(EXIT_FAILURE);\n    }\n\n    if (fork_process) {\n        dup2(old_stderr, STDERR_FILENO);\n        close(old_stderr);\n    }\n\n    state = RUNNING;\n    do {\n        main_loop_wait(false);\n        if (state == TERMINATE) {\n            blk_exp_close_all();\n            state = TERMINATED;\n        }\n    } while (state != TERMINATED);\n\n    blk_unref(blk);\n    if (sockpath) {\n        unlink(sockpath);\n    }\n\n    qemu_opts_del(sn_opts);\n\n    if (device) {\n        void *ret;\n        pthread_join(client_thread, &ret);\n        exit(ret != NULL);\n    } else {\n        exit(EXIT_SUCCESS);\n    }\n}\n"
        },
        {
          "name": "qemu-options.hx",
          "type": "blob",
          "size": 233.9140625,
          "content": "HXCOMM Use DEFHEADING() to define headings in both help text and rST.\nHXCOMM Text between SRST and ERST is copied to the rST version and\nHXCOMM discarded from C version.\nHXCOMM DEF(option, HAS_ARG/0, opt_enum, opt_help, arch_mask) is used to\nHXCOMM construct option structures, enums and help message for specified\nHXCOMM architectures.\nHXCOMM HXCOMM can be used for comments, discarded from both rST and C.\n\nDEFHEADING(Standard options:)\n\nDEF(\"help\", 0, QEMU_OPTION_h,\n    \"-h or -help     display this help and exit\\n\", QEMU_ARCH_ALL)\nSRST\n``-h``\n    Display help and exit\nERST\n\nDEF(\"version\", 0, QEMU_OPTION_version,\n    \"-version        display version information and exit\\n\", QEMU_ARCH_ALL)\nSRST\n``-version``\n    Display version information and exit\nERST\n\nDEF(\"machine\", HAS_ARG, QEMU_OPTION_machine, \\\n    \"-machine [type=]name[,prop[=value][,...]]\\n\"\n    \"                selects emulated machine ('-machine help' for list)\\n\"\n    \"                property accel=accel1[:accel2[:...]] selects accelerator\\n\"\n    \"                supported accelerators are kvm, xen, hax, hvf, nvmm, whpx or tcg (default: tcg)\\n\"\n    \"                vmport=on|off|auto controls emulation of vmport (default: auto)\\n\"\n    \"                dump-guest-core=on|off include guest memory in a core dump (default=on)\\n\"\n    \"                mem-merge=on|off controls memory merge support (default: on)\\n\"\n    \"                aes-key-wrap=on|off controls support for AES key wrapping (default=on)\\n\"\n    \"                dea-key-wrap=on|off controls support for DEA key wrapping (default=on)\\n\"\n    \"                suppress-vmdesc=on|off disables self-describing migration (default=off)\\n\"\n    \"                nvdimm=on|off controls NVDIMM support (default=off)\\n\"\n    \"                memory-encryption=@var{} memory encryption object to use (default=none)\\n\"\n    \"                hmat=on|off controls ACPI HMAT support (default=off)\\n\"\n    \"                memory-backend='backend-id' specifies explicitly provided backend for main RAM (default=none)\\n\"\n    \"                cxl-fmw.0.targets.0=firsttarget,cxl-fmw.0.targets.1=secondtarget,cxl-fmw.0.size=size[,cxl-fmw.0.interleave-granularity=granularity]\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-machine [type=]name[,prop=value[,...]]``\n    Select the emulated machine by name. Use ``-machine help`` to list\n    available machines.\n\n    For architectures which aim to support live migration compatibility\n    across releases, each release will introduce a new versioned machine\n    type. For example, the 2.8.0 release introduced machine types\n    \"pc-i440fx-2.8\" and \"pc-q35-2.8\" for the x86\\_64/i686 architectures.\n\n    To allow live migration of guests from QEMU version 2.8.0, to QEMU\n    version 2.9.0, the 2.9.0 version must support the \"pc-i440fx-2.8\"\n    and \"pc-q35-2.8\" machines too. To allow users live migrating VMs to\n    skip multiple intermediate releases when upgrading, new releases of\n    QEMU will support machine types from many previous versions.\n\n    Supported machine properties are:\n\n    ``accel=accels1[:accels2[:...]]``\n        This is used to enable an accelerator. Depending on the target\n        architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available.\n        By default, tcg is used. If there is more than one accelerator\n        specified, the next one is used if the previous one fails to\n        initialize.\n\n    ``vmport=on|off|auto``\n        Enables emulation of VMWare IO port, for vmmouse etc. auto says\n        to select the value based on accel. For accel=xen the default is\n        off otherwise the default is on.\n\n    ``dump-guest-core=on|off``\n        Include guest memory in a core dump. The default is on.\n\n    ``mem-merge=on|off``\n        Enables or disables memory merge support. This feature, when\n        supported by the host, de-duplicates identical memory pages\n        among VMs instances (enabled by default).\n\n    ``aes-key-wrap=on|off``\n        Enables or disables AES key wrapping support on s390-ccw hosts.\n        This feature controls whether AES wrapping keys will be created\n        to allow execution of AES cryptographic functions. The default\n        is on.\n\n    ``dea-key-wrap=on|off``\n        Enables or disables DEA key wrapping support on s390-ccw hosts.\n        This feature controls whether DEA wrapping keys will be created\n        to allow execution of DEA cryptographic functions. The default\n        is on.\n\n    ``nvdimm=on|off``\n        Enables or disables NVDIMM support. The default is off.\n\n    ``memory-encryption=``\n        Memory encryption object to use. The default is none.\n\n    ``hmat=on|off``\n        Enables or disables ACPI Heterogeneous Memory Attribute Table\n        (HMAT) support. The default is off.\n\n    ``memory-backend='id'``\n        An alternative to legacy ``-mem-path`` and ``mem-prealloc`` options.\n        Allows to use a memory backend as main RAM.\n\n        For example:\n        ::\n\n            -object memory-backend-file,id=pc.ram,size=512M,mem-path=/hugetlbfs,prealloc=on,share=on\n            -machine memory-backend=pc.ram\n            -m 512M\n\n        Migration compatibility note:\n\n        * as backend id one shall use value of 'default-ram-id', advertised by\n          machine type (available via ``query-machines`` QMP command), if migration\n          to/from old QEMU (<5.0) is expected.\n        * for machine types 4.0 and older, user shall\n          use ``x-use-canonical-path-for-ramblock-id=off`` backend option\n          if migration to/from old QEMU (<5.0) is expected.\n\n        For example:\n        ::\n\n            -object memory-backend-ram,id=pc.ram,size=512M,x-use-canonical-path-for-ramblock-id=off\n            -machine memory-backend=pc.ram\n            -m 512M\n\n    ``cxl-fmw.0.targets.0=firsttarget,cxl-fmw.0.targets.1=secondtarget,cxl-fmw.0.size=size[,cxl-fmw.0.interleave-granularity=granularity]``\n        Define a CXL Fixed Memory Window (CFMW).\n\n        Described in the CXL 2.0 ECN: CEDT CFMWS & QTG _DSM.\n\n        They are regions of Host Physical Addresses (HPA) on a system which\n        may be interleaved across one or more CXL host bridges.  The system\n        software will assign particular devices into these windows and\n        configure the downstream Host-managed Device Memory (HDM) decoders\n        in root ports, switch ports and devices appropriately to meet the\n        interleave requirements before enabling the memory devices.\n\n        ``targets.X=target`` provides the mapping to CXL host bridges\n        which may be identified by the id provied in the -device entry.\n        Multiple entries are needed to specify all the targets when\n        the fixed memory window represents interleaved memory. X is the\n        target index from 0.\n\n        ``size=size`` sets the size of the CFMW. This must be a multiple of\n        256MiB. The region will be aligned to 256MiB but the location is\n        platform and configuration dependent.\n\n        ``interleave-granularity=granularity`` sets the granularity of\n        interleave. Default 256KiB. Only 256KiB, 512KiB, 1024KiB, 2048KiB\n        4096KiB, 8192KiB and 16384KiB granularities supported.\n\n        Example:\n\n        ::\n\n            -machine cxl-fmw.0.targets.0=cxl.0,cxl-fmw.0.targets.1=cxl.1,cxl-fmw.0.size=128G,cxl-fmw.0.interleave-granularity=512k\nERST\n\nDEF(\"M\", HAS_ARG, QEMU_OPTION_M,\n    \"                sgx-epc.0.memdev=memid,sgx-epc.0.node=numaid\\n\",\n    QEMU_ARCH_ALL)\n\nSRST\n``sgx-epc.0.memdev=@var{memid},sgx-epc.0.node=@var{numaid}``\n    Define an SGX EPC section.\nERST\n\nDEF(\"cpu\", HAS_ARG, QEMU_OPTION_cpu,\n    \"-cpu cpu        select CPU ('-cpu help' for list)\\n\", QEMU_ARCH_ALL)\nSRST\n``-cpu model``\n    Select CPU model (``-cpu help`` for list and additional feature\n    selection)\nERST\n\nDEF(\"accel\", HAS_ARG, QEMU_OPTION_accel,\n    \"-accel [accel=]accelerator[,prop[=value][,...]]\\n\"\n    \"                select accelerator (kvm, xen, hax, hvf, nvmm, whpx or tcg; use 'help' for a list)\\n\"\n    \"                igd-passthru=on|off (enable Xen integrated Intel graphics passthrough, default=off)\\n\"\n    \"                kernel-irqchip=on|off|split controls accelerated irqchip support (default=on)\\n\"\n    \"                kvm-shadow-mem=size of KVM shadow MMU in bytes\\n\"\n    \"                split-wx=on|off (enable TCG split w^x mapping)\\n\"\n    \"                tb-size=n (TCG translation block cache size)\\n\"\n    \"                dirty-ring-size=n (KVM dirty ring GFN count, default 0)\\n\"\n    \"                thread=single|multi (enable multi-threaded TCG)\\n\", QEMU_ARCH_ALL)\nSRST\n``-accel name[,prop=value[,...]]``\n    This is used to enable an accelerator. Depending on the target\n    architecture, kvm, xen, hax, hvf, nvmm, whpx or tcg can be available. By\n    default, tcg is used. If there is more than one accelerator\n    specified, the next one is used if the previous one fails to\n    initialize.\n\n    ``igd-passthru=on|off``\n        When Xen is in use, this option controls whether Intel\n        integrated graphics devices can be passed through to the guest\n        (default=off)\n\n    ``kernel-irqchip=on|off|split``\n        Controls KVM in-kernel irqchip support. The default is full\n        acceleration of the interrupt controllers. On x86, split irqchip\n        reduces the kernel attack surface, at a performance cost for\n        non-MSI interrupts. Disabling the in-kernel irqchip completely\n        is not recommended except for debugging purposes.\n\n    ``kvm-shadow-mem=size``\n        Defines the size of the KVM shadow MMU.\n\n    ``split-wx=on|off``\n        Controls the use of split w^x mapping for the TCG code generation\n        buffer. Some operating systems require this to be enabled, and in\n        such a case this will default on. On other operating systems, this\n        will default off, but one may enable this for testing or debugging.\n\n    ``tb-size=n``\n        Controls the size (in MiB) of the TCG translation block cache.\n\n    ``thread=single|multi``\n        Controls number of TCG threads. When the TCG is multi-threaded\n        there will be one thread per vCPU therefore taking advantage of\n        additional host cores. The default is to enable multi-threading\n        where both the back-end and front-ends support it and no\n        incompatible TCG features have been enabled (e.g.\n        icount/replay).\n\n    ``dirty-ring-size=n``\n        When the KVM accelerator is used, it controls the size of the per-vCPU\n        dirty page ring buffer (number of entries for each vCPU). It should\n        be a value that is power of two, and it should be 1024 or bigger (but\n        still less than the maximum value that the kernel supports).  4096\n        could be a good initial value if you have no idea which is the best.\n        Set this value to 0 to disable the feature.  By default, this feature\n        is disabled (dirty-ring-size=0).  When enabled, KVM will instead\n        record dirty pages in a bitmap.\n\nERST\n\nDEF(\"smp\", HAS_ARG, QEMU_OPTION_smp,\n    \"-smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,clusters=clusters][,cores=cores][,threads=threads]\\n\"\n    \"                set the number of initial CPUs to 'n' [default=1]\\n\"\n    \"                maxcpus= maximum number of total CPUs, including\\n\"\n    \"                offline CPUs for hotplug, etc\\n\"\n    \"                sockets= number of sockets on the machine board\\n\"\n    \"                dies= number of dies in one socket\\n\"\n    \"                clusters= number of clusters in one die\\n\"\n    \"                cores= number of cores in one cluster\\n\"\n    \"                threads= number of threads in one core\\n\"\n    \"Note: Different machines may have different subsets of the CPU topology\\n\"\n    \"      parameters supported, so the actual meaning of the supported parameters\\n\"\n    \"      will vary accordingly. For example, for a machine type that supports a\\n\"\n    \"      three-level CPU hierarchy of sockets/cores/threads, the parameters will\\n\"\n    \"      sequentially mean as below:\\n\"\n    \"                sockets means the number of sockets on the machine board\\n\"\n    \"                cores means the number of cores in one socket\\n\"\n    \"                threads means the number of threads in one core\\n\"\n    \"      For a particular machine type board, an expected CPU topology hierarchy\\n\"\n    \"      can be defined through the supported sub-option. Unsupported parameters\\n\"\n    \"      can also be provided in addition to the sub-option, but their values\\n\"\n    \"      must be set as 1 in the purpose of correct parsing.\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-smp [[cpus=]n][,maxcpus=maxcpus][,sockets=sockets][,dies=dies][,clusters=clusters][,cores=cores][,threads=threads]``\n    Simulate a SMP system with '\\ ``n``\\ ' CPUs initially present on\n    the machine type board. On boards supporting CPU hotplug, the optional\n    '\\ ``maxcpus``\\ ' parameter can be set to enable further CPUs to be\n    added at runtime. When both parameters are omitted, the maximum number\n    of CPUs will be calculated from the provided topology members and the\n    initial CPU count will match the maximum number. When only one of them\n    is given then the omitted one will be set to its counterpart's value.\n    Both parameters may be specified, but the maximum number of CPUs must\n    be equal to or greater than the initial CPU count. Product of the\n    CPU topology hierarchy must be equal to the maximum number of CPUs.\n    Both parameters are subject to an upper limit that is determined by\n    the specific machine type chosen.\n\n    To control reporting of CPU topology information, values of the topology\n    parameters can be specified. Machines may only support a subset of the\n    parameters and different machines may have different subsets supported\n    which vary depending on capacity of the corresponding CPU targets. So\n    for a particular machine type board, an expected topology hierarchy can\n    be defined through the supported sub-option. Unsupported parameters can\n    also be provided in addition to the sub-option, but their values must be\n    set as 1 in the purpose of correct parsing.\n\n    Either the initial CPU count, or at least one of the topology parameters\n    must be specified. The specified parameters must be greater than zero,\n    explicit configuration like \"cpus=0\" is not allowed. Values for any\n    omitted parameters will be computed from those which are given.\n\n    For example, the following sub-option defines a CPU topology hierarchy\n    (2 sockets totally on the machine, 2 cores per socket, 2 threads per\n    core) for a machine that only supports sockets/cores/threads.\n    Some members of the option can be omitted but their values will be\n    automatically computed:\n\n    ::\n\n        -smp 8,sockets=2,cores=2,threads=2,maxcpus=8\n\n    The following sub-option defines a CPU topology hierarchy (2 sockets\n    totally on the machine, 2 dies per socket, 2 cores per die, 2 threads\n    per core) for PC machines which support sockets/dies/cores/threads.\n    Some members of the option can be omitted but their values will be\n    automatically computed:\n\n    ::\n\n        -smp 16,sockets=2,dies=2,cores=2,threads=2,maxcpus=16\n\n    The following sub-option defines a CPU topology hierarchy (2 sockets\n    totally on the machine, 2 clusters per socket, 2 cores per cluster,\n    2 threads per core) for ARM virt machines which support sockets/clusters\n    /cores/threads. Some members of the option can be omitted but their values\n    will be automatically computed:\n\n    ::\n\n        -smp 16,sockets=2,clusters=2,cores=2,threads=2,maxcpus=16\n\n    Historically preference was given to the coarsest topology parameters\n    when computing missing values (ie sockets preferred over cores, which\n    were preferred over threads), however, this behaviour is considered\n    liable to change. Prior to 6.2 the preference was sockets over cores\n    over threads. Since 6.2 the preference is cores over sockets over threads.\n\n    For example, the following option defines a machine board with 2 sockets\n    of 1 core before 6.2 and 1 socket of 2 cores after 6.2:\n\n    ::\n\n        -smp 2\nERST\n\nDEF(\"numa\", HAS_ARG, QEMU_OPTION_numa,\n    \"-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]\\n\"\n    \"-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]\\n\"\n    \"-numa dist,src=source,dst=destination,val=distance\\n\"\n    \"-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]\\n\"\n    \"-numa hmat-lb,initiator=node,target=node,hierarchy=memory|first-level|second-level|third-level,data-type=access-latency|read-latency|write-latency[,latency=lat][,bandwidth=bw]\\n\"\n    \"-numa hmat-cache,node-id=node,size=size,level=level[,associativity=none|direct|complex][,policy=none|write-back|write-through][,line=size]\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]``\n  \\ \n``-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=initiator]``\n  \\\n``-numa dist,src=source,dst=destination,val=distance``\n  \\ \n``-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]``\n  \\ \n``-numa hmat-lb,initiator=node,target=node,hierarchy=hierarchy,data-type=tpye[,latency=lat][,bandwidth=bw]``\n  \\ \n``-numa hmat-cache,node-id=node,size=size,level=level[,associativity=str][,policy=str][,line=size]``\n    Define a NUMA node and assign RAM and VCPUs to it. Set the NUMA\n    distance from a source node to a destination node. Set the ACPI\n    Heterogeneous Memory Attributes for the given nodes.\n\n    Legacy VCPU assignment uses '\\ ``cpus``\\ ' option where firstcpu and\n    lastcpu are CPU indexes. Each '\\ ``cpus``\\ ' option represent a\n    contiguous range of CPU indexes (or a single VCPU if lastcpu is\n    omitted). A non-contiguous set of VCPUs can be represented by\n    providing multiple '\\ ``cpus``\\ ' options. If '\\ ``cpus``\\ ' is\n    omitted on all nodes, VCPUs are automatically split between them.\n\n    For example, the following option assigns VCPUs 0, 1, 2 and 5 to a\n    NUMA node:\n\n    ::\n\n        -numa node,cpus=0-2,cpus=5\n\n    '\\ ``cpu``\\ ' option is a new alternative to '\\ ``cpus``\\ ' option\n    which uses '\\ ``socket-id|core-id|thread-id``\\ ' properties to\n    assign CPU objects to a node using topology layout properties of\n    CPU. The set of properties is machine specific, and depends on used\n    machine type/'\\ ``smp``\\ ' options. It could be queried with\n    '\\ ``hotpluggable-cpus``\\ ' monitor command. '\\ ``node-id``\\ '\n    property specifies node to which CPU object will be assigned, it's\n    required for node to be declared with '\\ ``node``\\ ' option before\n    it's used with '\\ ``cpu``\\ ' option.\n\n    For example:\n\n    ::\n\n        -M pc \\\n        -smp 1,sockets=2,maxcpus=2 \\\n        -numa node,nodeid=0 -numa node,nodeid=1 \\\n        -numa cpu,node-id=0,socket-id=0 -numa cpu,node-id=1,socket-id=1\n\n    Legacy '\\ ``mem``\\ ' assigns a given RAM amount to a node (not supported\n    for 5.1 and newer machine types). '\\ ``memdev``\\ ' assigns RAM from\n    a given memory backend device to a node. If '\\ ``mem``\\ ' and\n    '\\ ``memdev``\\ ' are omitted in all nodes, RAM is split equally between them.\n\n\n    '\\ ``mem``\\ ' and '\\ ``memdev``\\ ' are mutually exclusive.\n    Furthermore, if one node uses '\\ ``memdev``\\ ', all of them have to\n    use it.\n\n    '\\ ``initiator``\\ ' is an additional option that points to an\n    initiator NUMA node that has best performance (the lowest latency or\n    largest bandwidth) to this NUMA node. Note that this option can be\n    set only when the machine property 'hmat' is set to 'on'.\n\n    Following example creates a machine with 2 NUMA nodes, node 0 has\n    CPU. node 1 has only memory, and its initiator is node 0. Note that\n    because node 0 has CPU, by default the initiator of node 0 is itself\n    and must be itself.\n\n    ::\n\n        -machine hmat=on \\\n        -m 2G,slots=2,maxmem=4G \\\n        -object memory-backend-ram,size=1G,id=m0 \\\n        -object memory-backend-ram,size=1G,id=m1 \\\n        -numa node,nodeid=0,memdev=m0 \\\n        -numa node,nodeid=1,memdev=m1,initiator=0 \\\n        -smp 2,sockets=2,maxcpus=2  \\\n        -numa cpu,node-id=0,socket-id=0 \\\n        -numa cpu,node-id=0,socket-id=1\n\n    source and destination are NUMA node IDs. distance is the NUMA\n    distance from source to destination. The distance from a node to\n    itself is always 10. If any pair of nodes is given a distance, then\n    all pairs must be given distances. Although, when distances are only\n    given in one direction for each pair of nodes, then the distances in\n    the opposite directions are assumed to be the same. If, however, an\n    asymmetrical pair of distances is given for even one node pair, then\n    all node pairs must be provided distance values for both directions,\n    even when they are symmetrical. When a node is unreachable from\n    another node, set the pair's distance to 255.\n\n    Note that the -``numa`` option doesn't allocate any of the specified\n    resources, it just assigns existing resources to NUMA nodes. This\n    means that one still has to use the ``-m``, ``-smp`` options to\n    allocate RAM and VCPUs respectively.\n\n    Use '\\ ``hmat-lb``\\ ' to set System Locality Latency and Bandwidth\n    Information between initiator and target NUMA nodes in ACPI\n    Heterogeneous Attribute Memory Table (HMAT). Initiator NUMA node can\n    create memory requests, usually it has one or more processors.\n    Target NUMA node contains addressable memory.\n\n    In '\\ ``hmat-lb``\\ ' option, node are NUMA node IDs. hierarchy is\n    the memory hierarchy of the target NUMA node: if hierarchy is\n    'memory', the structure represents the memory performance; if\n    hierarchy is 'first-level\\|second-level\\|third-level', this\n    structure represents aggregated performance of memory side caches\n    for each domain. type of 'data-type' is type of data represented by\n    this structure instance: if 'hierarchy' is 'memory', 'data-type' is\n    'access\\|read\\|write' latency or 'access\\|read\\|write' bandwidth of\n    the target memory; if 'hierarchy' is\n    'first-level\\|second-level\\|third-level', 'data-type' is\n    'access\\|read\\|write' hit latency or 'access\\|read\\|write' hit\n    bandwidth of the target memory side cache.\n\n    lat is latency value in nanoseconds. bw is bandwidth value, the\n    possible value and units are NUM[M\\|G\\|T], mean that the bandwidth\n    value are NUM byte per second (or MB/s, GB/s or TB/s depending on\n    used suffix). Note that if latency or bandwidth value is 0, means\n    the corresponding latency or bandwidth information is not provided.\n\n    In '\\ ``hmat-cache``\\ ' option, node-id is the NUMA-id of the memory\n    belongs. size is the size of memory side cache in bytes. level is\n    the cache level described in this structure, note that the cache\n    level 0 should not be used with '\\ ``hmat-cache``\\ ' option.\n    associativity is the cache associativity, the possible value is\n    'none/direct(direct-mapped)/complex(complex cache indexing)'. policy\n    is the write policy. line is the cache Line size in bytes.\n\n    For example, the following options describe 2 NUMA nodes. Node 0 has\n    2 cpus and a ram, node 1 has only a ram. The processors in node 0\n    access memory in node 0 with access-latency 5 nanoseconds,\n    access-bandwidth is 200 MB/s; The processors in NUMA node 0 access\n    memory in NUMA node 1 with access-latency 10 nanoseconds,\n    access-bandwidth is 100 MB/s. And for memory side cache information,\n    NUMA node 0 and 1 both have 1 level memory cache, size is 10KB,\n    policy is write-back, the cache Line size is 8 bytes:\n\n    ::\n\n        -machine hmat=on \\\n        -m 2G \\\n        -object memory-backend-ram,size=1G,id=m0 \\\n        -object memory-backend-ram,size=1G,id=m1 \\\n        -smp 2,sockets=2,maxcpus=2 \\\n        -numa node,nodeid=0,memdev=m0 \\\n        -numa node,nodeid=1,memdev=m1,initiator=0 \\\n        -numa cpu,node-id=0,socket-id=0 \\\n        -numa cpu,node-id=0,socket-id=1 \\\n        -numa hmat-lb,initiator=0,target=0,hierarchy=memory,data-type=access-latency,latency=5 \\\n        -numa hmat-lb,initiator=0,target=0,hierarchy=memory,data-type=access-bandwidth,bandwidth=200M \\\n        -numa hmat-lb,initiator=0,target=1,hierarchy=memory,data-type=access-latency,latency=10 \\\n        -numa hmat-lb,initiator=0,target=1,hierarchy=memory,data-type=access-bandwidth,bandwidth=100M \\\n        -numa hmat-cache,node-id=0,size=10K,level=1,associativity=direct,policy=write-back,line=8 \\\n        -numa hmat-cache,node-id=1,size=10K,level=1,associativity=direct,policy=write-back,line=8\nERST\n\nDEF(\"add-fd\", HAS_ARG, QEMU_OPTION_add_fd,\n    \"-add-fd fd=fd,set=set[,opaque=opaque]\\n\"\n    \"                Add 'fd' to fd 'set'\\n\", QEMU_ARCH_ALL)\nSRST\n``-add-fd fd=fd,set=set[,opaque=opaque]``\n    Add a file descriptor to an fd set. Valid options are:\n\n    ``fd=fd``\n        This option defines the file descriptor of which a duplicate is\n        added to fd set. The file descriptor cannot be stdin, stdout, or\n        stderr.\n\n    ``set=set``\n        This option defines the ID of the fd set to add the file\n        descriptor to.\n\n    ``opaque=opaque``\n        This option defines a free-form string that can be used to\n        describe fd.\n\n    You can open an image using pre-opened file descriptors from an fd\n    set:\n\n    .. parsed-literal::\n\n        |qemu_system| \\\\\n         -add-fd fd=3,set=2,opaque=\"rdwr:/path/to/file\" \\\\\n         -add-fd fd=4,set=2,opaque=\"rdonly:/path/to/file\" \\\\\n         -drive file=/dev/fdset/2,index=0,media=disk\nERST\n\nDEF(\"set\", HAS_ARG, QEMU_OPTION_set,\n    \"-set group.id.arg=value\\n\"\n    \"                set <arg> parameter for item <id> of type <group>\\n\"\n    \"                i.e. -set drive.$id.file=/path/to/image\\n\", QEMU_ARCH_ALL)\nSRST\n``-set group.id.arg=value``\n    Set parameter arg for item id of type group\nERST\n\nDEF(\"global\", HAS_ARG, QEMU_OPTION_global,\n    \"-global driver.property=value\\n\"\n    \"-global driver=driver,property=property,value=value\\n\"\n    \"                set a global default for a driver property\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-global driver.prop=value``\n  \\ \n``-global driver=driver,property=property,value=value``\n    Set default value of driver's property prop to value, e.g.:\n\n    .. parsed-literal::\n\n        |qemu_system_x86| -global ide-hd.physical_block_size=4096 disk-image.img\n\n    In particular, you can use this to set driver properties for devices\n    which are created automatically by the machine model. To create a\n    device which is not created automatically and set properties on it,\n    use -``device``.\n\n    -global driver.prop=value is shorthand for -global\n    driver=driver,property=prop,value=value. The longhand syntax works\n    even when driver contains a dot.\nERST\n\nDEF(\"boot\", HAS_ARG, QEMU_OPTION_boot,\n    \"-boot [order=drives][,once=drives][,menu=on|off]\\n\"\n    \"      [,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off]\\n\"\n    \"                'drives': floppy (a), hard disk (c), CD-ROM (d), network (n)\\n\"\n    \"                'sp_name': the file's name that would be passed to bios as logo picture, if menu=on\\n\"\n    \"                'sp_time': the period that splash picture last if menu=on, unit is ms\\n\"\n    \"                'rb_timeout': the timeout before guest reboot when boot failed, unit is ms\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-boot [order=drives][,once=drives][,menu=on|off][,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_timeout][,strict=on|off]``\n    Specify boot order drives as a string of drive letters. Valid drive\n    letters depend on the target architecture. The x86 PC uses: a, b\n    (floppy 1 and 2), c (first hard disk), d (first CD-ROM), n-p\n    (Etherboot from network adapter 1-4), hard disk boot is the default.\n    To apply a particular boot order only on the first startup, specify\n    it via ``once``. Note that the ``order`` or ``once`` parameter\n    should not be used together with the ``bootindex`` property of\n    devices, since the firmware implementations normally do not support\n    both at the same time.\n\n    Interactive boot menus/prompts can be enabled via ``menu=on`` as far\n    as firmware/BIOS supports them. The default is non-interactive boot.\n\n    A splash picture could be passed to bios, enabling user to show it\n    as logo, when option splash=sp\\_name is given and menu=on, If\n    firmware/BIOS supports them. Currently Seabios for X86 system\n    support it. limitation: The splash file could be a jpeg file or a\n    BMP file in 24 BPP format(true color). The resolution should be\n    supported by the SVGA mode, so the recommended is 320x240, 640x480,\n    800x640.\n\n    A timeout could be passed to bios, guest will pause for rb\\_timeout\n    ms when boot failed, then reboot. If rb\\_timeout is '-1', guest will\n    not reboot, qemu passes '-1' to bios by default. Currently Seabios\n    for X86 system support it.\n\n    Do strict boot via ``strict=on`` as far as firmware/BIOS supports\n    it. This only effects when boot priority is changed by bootindex\n    options. The default is non-strict boot.\n\n    .. parsed-literal::\n\n        # try to boot from network first, then from hard disk\n        |qemu_system_x86| -boot order=nc\n        # boot from CD-ROM first, switch back to default order after reboot\n        |qemu_system_x86| -boot once=d\n        # boot with a splash picture for 5 seconds.\n        |qemu_system_x86| -boot menu=on,splash=/root/boot.bmp,splash-time=5000\n\n    Note: The legacy format '-boot drives' is still supported but its\n    use is discouraged as it may be removed from future versions.\nERST\n\nDEF(\"m\", HAS_ARG, QEMU_OPTION_m,\n    \"-m [size=]megs[,slots=n,maxmem=size]\\n\"\n    \"                configure guest RAM\\n\"\n    \"                size: initial amount of guest memory\\n\"\n    \"                slots: number of hotplug slots (default: none)\\n\"\n    \"                maxmem: maximum amount of guest memory (default: none)\\n\"\n    \"NOTE: Some architectures might enforce a specific granularity\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-m [size=]megs[,slots=n,maxmem=size]``\n    Sets guest startup RAM size to megs megabytes. Default is 128 MiB.\n    Optionally, a suffix of \"M\" or \"G\" can be used to signify a value in\n    megabytes or gigabytes respectively. Optional pair slots, maxmem\n    could be used to set amount of hotpluggable memory slots and maximum\n    amount of memory. Note that maxmem must be aligned to the page size.\n\n    For example, the following command-line sets the guest startup RAM\n    size to 1GB, creates 3 slots to hotplug additional memory and sets\n    the maximum memory the guest can reach to 4GB:\n\n    .. parsed-literal::\n\n        |qemu_system| -m 1G,slots=3,maxmem=4G\n\n    If slots and maxmem are not specified, memory hotplug won't be\n    enabled and the guest startup RAM will never increase.\nERST\n\nDEF(\"mem-path\", HAS_ARG, QEMU_OPTION_mempath,\n    \"-mem-path FILE  provide backing storage for guest RAM\\n\", QEMU_ARCH_ALL)\nSRST\n``-mem-path path``\n    Allocate guest RAM from a temporarily created file in path.\nERST\n\nDEF(\"mem-prealloc\", 0, QEMU_OPTION_mem_prealloc,\n    \"-mem-prealloc   preallocate guest memory (use with -mem-path)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-mem-prealloc``\n    Preallocate memory when using -mem-path.\nERST\n\nDEF(\"k\", HAS_ARG, QEMU_OPTION_k,\n    \"-k language     use keyboard layout (for example 'fr' for French)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-k language``\n    Use keyboard layout language (for example ``fr`` for French). This\n    option is only needed where it is not easy to get raw PC keycodes\n    (e.g. on Macs, with some X11 servers or with a VNC or curses\n    display). You don't normally need to use it on PC/Linux or\n    PC/Windows hosts.\n\n    The available layouts are:\n\n    ::\n\n        ar  de-ch  es  fo     fr-ca  hu  ja  mk     no  pt-br  sv\n        da  en-gb  et  fr     fr-ch  is  lt  nl     pl  ru     th\n        de  en-us  fi  fr-be  hr     it  lv  nl-be  pt  sl     tr\n\n    The default is ``en-us``.\nERST\n\n\nHXCOMM Deprecated by -audiodev\nDEF(\"audio-help\", 0, QEMU_OPTION_audio_help,\n    \"-audio-help     show -audiodev equivalent of the currently specified audio settings\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-audio-help``\n    Will show the -audiodev equivalent of the currently specified\n    (deprecated) environment variables.\nERST\n\nDEF(\"audio\", HAS_ARG, QEMU_OPTION_audio,\n    \"-audio [driver=]driver,model=value[,prop[=value][,...]]\\n\"\n    \"                specifies the audio backend and device to use;\\n\"\n    \"                apart from 'model', options are the same as for -audiodev.\\n\"\n    \"                use '-audio model=help' to show possible devices.\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-audio [driver=]driver,model=value[,prop[=value][,...]]``\n    This option is a shortcut for configuring both the guest audio\n    hardware and the host audio backend in one go.\n    The host backend options are the same as with the corresponding\n    ``-audiodev`` options below. The guest hardware model can be set with\n    ``model=modelname``. Use ``model=help`` to list the available device\n    types.\n\n    The following two example do exactly the same, to show how ``-audio``\n    can be used to shorten the command line length:\n\n    .. parsed-literal::\n\n        |qemu_system| -audiodev pa,id=pa -device sb16,audiodev=pa\n        |qemu_system| -audio pa,model=sb16\nERST\n\nDEF(\"audiodev\", HAS_ARG, QEMU_OPTION_audiodev,\n    \"-audiodev [driver=]driver,id=id[,prop[=value][,...]]\\n\"\n    \"                specifies the audio backend to use\\n\"\n    \"                id= identifier of the backend\\n\"\n    \"                timer-period= timer period in microseconds\\n\"\n    \"                in|out.mixing-engine= use mixing engine to mix streams inside QEMU\\n\"\n    \"                in|out.fixed-settings= use fixed settings for host audio\\n\"\n    \"                in|out.frequency= frequency to use with fixed settings\\n\"\n    \"                in|out.channels= number of channels to use with fixed settings\\n\"\n    \"                in|out.format= sample format to use with fixed settings\\n\"\n    \"                valid values: s8, s16, s32, u8, u16, u32, f32\\n\"\n    \"                in|out.voices= number of voices to use\\n\"\n    \"                in|out.buffer-length= length of buffer in microseconds\\n\"\n    \"-audiodev none,id=id,[,prop[=value][,...]]\\n\"\n    \"                dummy driver that discards all output\\n\"\n#ifdef CONFIG_AUDIO_ALSA\n    \"-audiodev alsa,id=id[,prop[=value][,...]]\\n\"\n    \"                in|out.dev= name of the audio device to use\\n\"\n    \"                in|out.period-length= length of period in microseconds\\n\"\n    \"                in|out.try-poll= attempt to use poll mode\\n\"\n    \"                threshold= threshold (in microseconds) when playback starts\\n\"\n#endif\n#ifdef CONFIG_AUDIO_COREAUDIO\n    \"-audiodev coreaudio,id=id[,prop[=value][,...]]\\n\"\n    \"                in|out.buffer-count= number of buffers\\n\"\n#endif\n#ifdef CONFIG_AUDIO_DSOUND\n    \"-audiodev dsound,id=id[,prop[=value][,...]]\\n\"\n    \"                latency= add extra latency to playback in microseconds\\n\"\n#endif\n#ifdef CONFIG_AUDIO_OSS\n    \"-audiodev oss,id=id[,prop[=value][,...]]\\n\"\n    \"                in|out.dev= path of the audio device to use\\n\"\n    \"                in|out.buffer-count= number of buffers\\n\"\n    \"                in|out.try-poll= attempt to use poll mode\\n\"\n    \"                try-mmap= try using memory mapped access\\n\"\n    \"                exclusive= open device in exclusive mode\\n\"\n    \"                dsp-policy= set timing policy (0..10), -1 to use fragment mode\\n\"\n#endif\n#ifdef CONFIG_AUDIO_PA\n    \"-audiodev pa,id=id[,prop[=value][,...]]\\n\"\n    \"                server= PulseAudio server address\\n\"\n    \"                in|out.name= source/sink device name\\n\"\n    \"                in|out.latency= desired latency in microseconds\\n\"\n#endif\n#ifdef CONFIG_AUDIO_SDL\n    \"-audiodev sdl,id=id[,prop[=value][,...]]\\n\"\n    \"                in|out.buffer-count= number of buffers\\n\"\n#endif\n#ifdef CONFIG_SPICE\n    \"-audiodev spice,id=id[,prop[=value][,...]]\\n\"\n#endif\n#ifdef CONFIG_DBUS_DISPLAY\n    \"-audiodev dbus,id=id[,prop[=value][,...]]\\n\"\n#endif\n    \"-audiodev wav,id=id[,prop[=value][,...]]\\n\"\n    \"                path= path of wav file to record\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-audiodev [driver=]driver,id=id[,prop[=value][,...]]``\n    Adds a new audio backend driver identified by id. There are global\n    and driver specific properties. Some values can be set differently\n    for input and output, they're marked with ``in|out.``. You can set\n    the input's property with ``in.prop`` and the output's property with\n    ``out.prop``. For example:\n\n    ::\n\n        -audiodev alsa,id=example,in.frequency=44110,out.frequency=8000\n        -audiodev alsa,id=example,out.channels=1 # leaves in.channels unspecified\n\n    NOTE: parameter validation is known to be incomplete, in many cases\n    specifying an invalid option causes QEMU to print an error message\n    and continue emulation without sound.\n\n    Valid global options are:\n\n    ``id=identifier``\n        Identifies the audio backend.\n\n    ``timer-period=period``\n        Sets the timer period used by the audio subsystem in\n        microseconds. Default is 10000 (10 ms).\n\n    ``in|out.mixing-engine=on|off``\n        Use QEMU's mixing engine to mix all streams inside QEMU and\n        convert audio formats when not supported by the backend. When\n        off, fixed-settings must be off too. Note that disabling this\n        option means that the selected backend must support multiple\n        streams and the audio formats used by the virtual cards,\n        otherwise you'll get no sound. It's not recommended to disable\n        this option unless you want to use 5.1 or 7.1 audio, as mixing\n        engine only supports mono and stereo audio. Default is on.\n\n    ``in|out.fixed-settings=on|off``\n        Use fixed settings for host audio. When off, it will change\n        based on how the guest opens the sound card. In this case you\n        must not specify frequency, channels or format. Default is on.\n\n    ``in|out.frequency=frequency``\n        Specify the frequency to use when using fixed-settings. Default\n        is 44100Hz.\n\n    ``in|out.channels=channels``\n        Specify the number of channels to use when using fixed-settings.\n        Default is 2 (stereo).\n\n    ``in|out.format=format``\n        Specify the sample format to use when using fixed-settings.\n        Valid values are: ``s8``, ``s16``, ``s32``, ``u8``, ``u16``,\n        ``u32``, ``f32``. Default is ``s16``.\n\n    ``in|out.voices=voices``\n        Specify the number of voices to use. Default is 1.\n\n    ``in|out.buffer-length=usecs``\n        Sets the size of the buffer in microseconds.\n\n``-audiodev none,id=id[,prop[=value][,...]]``\n    Creates a dummy backend that discards all outputs. This backend has\n    no backend specific properties.\n\n``-audiodev alsa,id=id[,prop[=value][,...]]``\n    Creates backend using the ALSA. This backend is only available on\n    Linux.\n\n    ALSA specific options are:\n\n    ``in|out.dev=device``\n        Specify the ALSA device to use for input and/or output. Default\n        is ``default``.\n\n    ``in|out.period-length=usecs``\n        Sets the period length in microseconds.\n\n    ``in|out.try-poll=on|off``\n        Attempt to use poll mode with the device. Default is on.\n\n    ``threshold=threshold``\n        Threshold (in microseconds) when playback starts. Default is 0.\n\n``-audiodev coreaudio,id=id[,prop[=value][,...]]``\n    Creates a backend using Apple's Core Audio. This backend is only\n    available on Mac OS and only supports playback.\n\n    Core Audio specific options are:\n\n    ``in|out.buffer-count=count``\n        Sets the count of the buffers.\n\n``-audiodev dsound,id=id[,prop[=value][,...]]``\n    Creates a backend using Microsoft's DirectSound. This backend is\n    only available on Windows and only supports playback.\n\n    DirectSound specific options are:\n\n    ``latency=usecs``\n        Add extra usecs microseconds latency to playback. Default is\n        10000 (10 ms).\n\n``-audiodev oss,id=id[,prop[=value][,...]]``\n    Creates a backend using OSS. This backend is available on most\n    Unix-like systems.\n\n    OSS specific options are:\n\n    ``in|out.dev=device``\n        Specify the file name of the OSS device to use. Default is\n        ``/dev/dsp``.\n\n    ``in|out.buffer-count=count``\n        Sets the count of the buffers.\n\n    ``in|out.try-poll=on|of``\n        Attempt to use poll mode with the device. Default is on.\n\n    ``try-mmap=on|off``\n        Try using memory mapped device access. Default is off.\n\n    ``exclusive=on|off``\n        Open the device in exclusive mode (vmix won't work in this\n        case). Default is off.\n\n    ``dsp-policy=policy``\n        Sets the timing policy (between 0 and 10, where smaller number\n        means smaller latency but higher CPU usage). Use -1 to use\n        buffer sizes specified by ``buffer`` and ``buffer-count``. This\n        option is ignored if you do not have OSS 4. Default is 5.\n\n``-audiodev pa,id=id[,prop[=value][,...]]``\n    Creates a backend using PulseAudio. This backend is available on\n    most systems.\n\n    PulseAudio specific options are:\n\n    ``server=server``\n        Sets the PulseAudio server to connect to.\n\n    ``in|out.name=sink``\n        Use the specified source/sink for recording/playback.\n\n    ``in|out.latency=usecs``\n        Desired latency in microseconds. The PulseAudio server will try\n        to honor this value but actual latencies may be lower or higher.\n\n``-audiodev sdl,id=id[,prop[=value][,...]]``\n    Creates a backend using SDL. This backend is available on most\n    systems, but you should use your platform's native backend if\n    possible.\n\n    SDL specific options are:\n\n    ``in|out.buffer-count=count``\n        Sets the count of the buffers.\n\n``-audiodev spice,id=id[,prop[=value][,...]]``\n    Creates a backend that sends audio through SPICE. This backend\n    requires ``-spice`` and automatically selected in that case, so\n    usually you can ignore this option. This backend has no backend\n    specific properties.\n\n``-audiodev wav,id=id[,prop[=value][,...]]``\n    Creates a backend that writes audio to a WAV file.\n\n    Backend specific options are:\n\n    ``path=path``\n        Write recorded audio into the specified file. Default is\n        ``qemu.wav``.\nERST\n\nDEF(\"device\", HAS_ARG, QEMU_OPTION_device,\n    \"-device driver[,prop[=value][,...]]\\n\"\n    \"                add device (based on driver)\\n\"\n    \"                prop=value,... sets driver properties\\n\"\n    \"                use '-device help' to print all possible drivers\\n\"\n    \"                use '-device driver,help' to print all possible properties\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-device driver[,prop[=value][,...]]``\n    Add device driver. prop=value sets driver properties. Valid\n    properties depend on the driver. To get help on possible drivers and\n    properties, use ``-device help`` and ``-device driver,help``.\n\n    Some drivers are:\n\n``-device ipmi-bmc-sim,id=id[,prop[=value][,...]]``\n    Add an IPMI BMC. This is a simulation of a hardware management\n    interface processor that normally sits on a system. It provides a\n    watchdog and the ability to reset and power control the system. You\n    need to connect this to an IPMI interface to make it useful\n\n    The IPMI slave address to use for the BMC. The default is 0x20. This\n    address is the BMC's address on the I2C network of management\n    controllers. If you don't know what this means, it is safe to ignore\n    it.\n\n    ``id=id``\n        The BMC id for interfaces to use this device.\n\n    ``slave_addr=val``\n        Define slave address to use for the BMC. The default is 0x20.\n\n    ``sdrfile=file``\n        file containing raw Sensor Data Records (SDR) data. The default\n        is none.\n\n    ``fruareasize=val``\n        size of a Field Replaceable Unit (FRU) area. The default is\n        1024.\n\n    ``frudatafile=file``\n        file containing raw Field Replaceable Unit (FRU) inventory data.\n        The default is none.\n\n    ``guid=uuid``\n        value for the GUID for the BMC, in standard UUID format. If this\n        is set, get \"Get GUID\" command to the BMC will return it.\n        Otherwise \"Get GUID\" will return an error.\n\n``-device ipmi-bmc-extern,id=id,chardev=id[,slave_addr=val]``\n    Add a connection to an external IPMI BMC simulator. Instead of\n    locally emulating the BMC like the above item, instead connect to an\n    external entity that provides the IPMI services.\n\n    A connection is made to an external BMC simulator. If you do this,\n    it is strongly recommended that you use the \"reconnect=\" chardev\n    option to reconnect to the simulator if the connection is lost. Note\n    that if this is not used carefully, it can be a security issue, as\n    the interface has the ability to send resets, NMIs, and power off\n    the VM. It's best if QEMU makes a connection to an external\n    simulator running on a secure port on localhost, so neither the\n    simulator nor QEMU is exposed to any outside network.\n\n    See the \"lanserv/README.vm\" file in the OpenIPMI library for more\n    details on the external interface.\n\n``-device isa-ipmi-kcs,bmc=id[,ioport=val][,irq=val]``\n    Add a KCS IPMI interafce on the ISA bus. This also adds a\n    corresponding ACPI and SMBIOS entries, if appropriate.\n\n    ``bmc=id``\n        The BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern\n        above.\n\n    ``ioport=val``\n        Define the I/O address of the interface. The default is 0xca0\n        for KCS.\n\n    ``irq=val``\n        Define the interrupt to use. The default is 5. To disable\n        interrupts, set this to 0.\n\n``-device isa-ipmi-bt,bmc=id[,ioport=val][,irq=val]``\n    Like the KCS interface, but defines a BT interface. The default port\n    is 0xe4 and the default interrupt is 5.\n\n``-device pci-ipmi-kcs,bmc=id``\n    Add a KCS IPMI interafce on the PCI bus.\n\n    ``bmc=id``\n        The BMC to connect to, one of ipmi-bmc-sim or ipmi-bmc-extern above.\n\n``-device pci-ipmi-bt,bmc=id``\n    Like the KCS interface, but defines a BT interface on the PCI bus.\n\n``-device intel-iommu[,option=...]``\n    This is only supported by ``-machine q35``, which will enable Intel VT-d\n    emulation within the guest.  It supports below options:\n\n    ``intremap=on|off`` (default: auto)\n        This enables interrupt remapping feature.  It's required to enable\n        complete x2apic.  Currently it only supports kvm kernel-irqchip modes\n        ``off`` or ``split``, while full kernel-irqchip is not yet supported.\n        The default value is \"auto\", which will be decided by the mode of\n        kernel-irqchip.\n\n    ``caching-mode=on|off`` (default: off)\n        This enables caching mode for the VT-d emulated device.  When\n        caching-mode is enabled, each guest DMA buffer mapping will generate an\n        IOTLB invalidation from the guest IOMMU driver to the vIOMMU device in\n        a synchronous way.  It is required for ``-device vfio-pci`` to work\n        with the VT-d device, because host assigned devices requires to setup\n        the DMA mapping on the host before guest DMA starts.\n\n    ``device-iotlb=on|off`` (default: off)\n        This enables device-iotlb capability for the emulated VT-d device.  So\n        far virtio/vhost should be the only real user for this parameter,\n        paired with ats=on configured for the device.\n\n    ``aw-bits=39|48`` (default: 39)\n        This decides the address width of IOVA address space.  The address\n        space has 39 bits width for 3-level IOMMU page tables, and 48 bits for\n        4-level IOMMU page tables.\n\n    Please also refer to the wiki page for general scenarios of VT-d\n    emulation in QEMU: https://wiki.qemu.org/Features/VT-d.\n\nERST\n\nDEF(\"name\", HAS_ARG, QEMU_OPTION_name,\n    \"-name string1[,process=string2][,debug-threads=on|off]\\n\"\n    \"                set the name of the guest\\n\"\n    \"                string1 sets the window title and string2 the process name\\n\"\n    \"                When debug-threads is enabled, individual threads are given a separate name\\n\"\n    \"                NOTE: The thread names are for debugging and not a stable API.\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-name name``\n    Sets the name of the guest. This name will be displayed in the SDL\n    window caption. The name will also be used for the VNC server. Also\n    optionally set the top visible process name in Linux. Naming of\n    individual threads can also be enabled on Linux to aid debugging.\nERST\n\nDEF(\"uuid\", HAS_ARG, QEMU_OPTION_uuid,\n    \"-uuid %08x-%04x-%04x-%04x-%012x\\n\"\n    \"                specify machine UUID\\n\", QEMU_ARCH_ALL)\nSRST\n``-uuid uuid``\n    Set system UUID.\nERST\n\nDEFHEADING()\n\nDEFHEADING(Block device options:)\n\nSRST\nThe QEMU block device handling options have a long history and\nhave gone through several iterations as the feature set and complexity\nof the block layer have grown. Many online guides to QEMU often\nreference older and deprecated options, which can lead to confusion.\n\nThe recommended modern way to describe disks is to use a combination of\n``-device`` to specify the hardware device and ``-blockdev`` to\ndescribe the backend. The device defines what the guest sees and the\nbackend describes how QEMU handles the data.\n\nERST\n\nDEF(\"fda\", HAS_ARG, QEMU_OPTION_fda,\n    \"-fda/-fdb file  use 'file' as floppy disk 0/1 image\\n\", QEMU_ARCH_ALL)\nDEF(\"fdb\", HAS_ARG, QEMU_OPTION_fdb, \"\", QEMU_ARCH_ALL)\nSRST\n``-fda file``\n  \\\n``-fdb file``\n    Use file as floppy disk 0/1 image (see the :ref:`disk images` chapter in\n    the System Emulation Users Guide).\nERST\n\nDEF(\"hda\", HAS_ARG, QEMU_OPTION_hda,\n    \"-hda/-hdb file  use 'file' as IDE hard disk 0/1 image\\n\", QEMU_ARCH_ALL)\nDEF(\"hdb\", HAS_ARG, QEMU_OPTION_hdb, \"\", QEMU_ARCH_ALL)\nDEF(\"hdc\", HAS_ARG, QEMU_OPTION_hdc,\n    \"-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image\\n\", QEMU_ARCH_ALL)\nDEF(\"hdd\", HAS_ARG, QEMU_OPTION_hdd, \"\", QEMU_ARCH_ALL)\nSRST\n``-hda file``\n  \\\n``-hdb file``\n  \\ \n``-hdc file``\n  \\ \n``-hdd file``\n    Use file as hard disk 0, 1, 2 or 3 image (see the :ref:`disk images`\n    chapter in the System Emulation Users Guide).\nERST\n\nDEF(\"cdrom\", HAS_ARG, QEMU_OPTION_cdrom,\n    \"-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-cdrom file``\n    Use file as CD-ROM image (you cannot use ``-hdc`` and ``-cdrom`` at\n    the same time). You can use the host CD-ROM by using ``/dev/cdrom``\n    as filename.\nERST\n\nDEF(\"blockdev\", HAS_ARG, QEMU_OPTION_blockdev,\n    \"-blockdev [driver=]driver[,node-name=N][,discard=ignore|unmap]\\n\"\n    \"          [,cache.direct=on|off][,cache.no-flush=on|off]\\n\"\n    \"          [,read-only=on|off][,auto-read-only=on|off]\\n\"\n    \"          [,force-share=on|off][,detect-zeroes=on|off|unmap]\\n\"\n    \"          [,driver specific parameters...]\\n\"\n    \"                configure a block backend\\n\", QEMU_ARCH_ALL)\nSRST\n``-blockdev option[,option[,option[,...]]]``\n    Define a new block driver node. Some of the options apply to all\n    block drivers, other options are only accepted for a specific block\n    driver. See below for a list of generic options and options for the\n    most common block drivers.\n\n    Options that expect a reference to another node (e.g. ``file``) can\n    be given in two ways. Either you specify the node name of an already\n    existing node (file=node-name), or you define a new node inline,\n    adding options for the referenced node after a dot\n    (file.filename=path,file.aio=native).\n\n    A block driver node created with ``-blockdev`` can be used for a\n    guest device by specifying its node name for the ``drive`` property\n    in a ``-device`` argument that defines a block device.\n\n    ``Valid options for any block driver node:``\n        ``driver``\n            Specifies the block driver to use for the given node.\n\n        ``node-name``\n            This defines the name of the block driver node by which it\n            will be referenced later. The name must be unique, i.e. it\n            must not match the name of a different block driver node, or\n            (if you use ``-drive`` as well) the ID of a drive.\n\n            If no node name is specified, it is automatically generated.\n            The generated node name is not intended to be predictable\n            and changes between QEMU invocations. For the top level, an\n            explicit node name must be specified.\n\n        ``read-only``\n            Open the node read-only. Guest write attempts will fail.\n\n            Note that some block drivers support only read-only access,\n            either generally or in certain configurations. In this case,\n            the default value ``read-only=off`` does not work and the\n            option must be specified explicitly.\n\n        ``auto-read-only``\n            If ``auto-read-only=on`` is set, QEMU may fall back to\n            read-only usage even when ``read-only=off`` is requested, or\n            even switch between modes as needed, e.g. depending on\n            whether the image file is writable or whether a writing user\n            is attached to the node.\n\n        ``force-share``\n            Override the image locking system of QEMU by forcing the\n            node to utilize weaker shared access for permissions where\n            it would normally request exclusive access. When there is\n            the potential for multiple instances to have the same file\n            open (whether this invocation of QEMU is the first or the\n            second instance), both instances must permit shared access\n            for the second instance to succeed at opening the file.\n\n            Enabling ``force-share=on`` requires ``read-only=on``.\n\n        ``cache.direct``\n            The host page cache can be avoided with ``cache.direct=on``.\n            This will attempt to do disk IO directly to the guest's\n            memory. QEMU may still perform an internal copy of the data.\n\n        ``cache.no-flush``\n            In case you don't care about data integrity over host\n            failures, you can use ``cache.no-flush=on``. This option\n            tells QEMU that it never needs to write any data to the disk\n            but can instead keep things in cache. If anything goes\n            wrong, like your host losing power, the disk storage getting\n            disconnected accidentally, etc. your image will most\n            probably be rendered unusable.\n\n        ``discard=discard``\n            discard is one of \"ignore\" (or \"off\") or \"unmap\" (or \"on\")\n            and controls whether ``discard`` (also known as ``trim`` or\n            ``unmap``) requests are ignored or passed to the filesystem.\n            Some machine types may not support discard requests.\n\n        ``detect-zeroes=detect-zeroes``\n            detect-zeroes is \"off\", \"on\" or \"unmap\" and enables the\n            automatic conversion of plain zero writes by the OS to\n            driver specific optimized zero write commands. You may even\n            choose \"unmap\" if discard is set to \"unmap\" to allow a zero\n            write to be converted to an ``unmap`` operation.\n\n    ``Driver-specific options for file``\n        This is the protocol-level block driver for accessing regular\n        files.\n\n        ``filename``\n            The path to the image file in the local filesystem\n\n        ``aio``\n            Specifies the AIO backend (threads/native/io_uring,\n            default: threads)\n\n        ``locking``\n            Specifies whether the image file is protected with Linux OFD\n            / POSIX locks. The default is to use the Linux Open File\n            Descriptor API if available, otherwise no lock is applied.\n            (auto/on/off, default: auto)\n\n        Example:\n\n        ::\n\n            -blockdev driver=file,node-name=disk,filename=disk.img\n\n    ``Driver-specific options for raw``\n        This is the image format block driver for raw images. It is\n        usually stacked on top of a protocol level block driver such as\n        ``file``.\n\n        ``file``\n            Reference to or definition of the data source block driver\n            node (e.g. a ``file`` driver node)\n\n        Example 1:\n\n        ::\n\n            -blockdev driver=file,node-name=disk_file,filename=disk.img\n            -blockdev driver=raw,node-name=disk,file=disk_file\n\n        Example 2:\n\n        ::\n\n            -blockdev driver=raw,node-name=disk,file.driver=file,file.filename=disk.img\n\n    ``Driver-specific options for qcow2``\n        This is the image format block driver for qcow2 images. It is\n        usually stacked on top of a protocol level block driver such as\n        ``file``.\n\n        ``file``\n            Reference to or definition of the data source block driver\n            node (e.g. a ``file`` driver node)\n\n        ``backing``\n            Reference to or definition of the backing file block device\n            (default is taken from the image file). It is allowed to\n            pass ``null`` here in order to disable the default backing\n            file.\n\n        ``lazy-refcounts``\n            Whether to enable the lazy refcounts feature (on/off;\n            default is taken from the image file)\n\n        ``cache-size``\n            The maximum total size of the L2 table and refcount block\n            caches in bytes (default: the sum of l2-cache-size and\n            refcount-cache-size)\n\n        ``l2-cache-size``\n            The maximum size of the L2 table cache in bytes (default: if\n            cache-size is not specified - 32M on Linux platforms, and 8M\n            on non-Linux platforms; otherwise, as large as possible\n            within the cache-size, while permitting the requested or the\n            minimal refcount cache size)\n\n        ``refcount-cache-size``\n            The maximum size of the refcount block cache in bytes\n            (default: 4 times the cluster size; or if cache-size is\n            specified, the part of it which is not used for the L2\n            cache)\n\n        ``cache-clean-interval``\n            Clean unused entries in the L2 and refcount caches. The\n            interval is in seconds. The default value is 600 on\n            supporting platforms, and 0 on other platforms. Setting it\n            to 0 disables this feature.\n\n        ``pass-discard-request``\n            Whether discard requests to the qcow2 device should be\n            forwarded to the data source (on/off; default: on if\n            discard=unmap is specified, off otherwise)\n\n        ``pass-discard-snapshot``\n            Whether discard requests for the data source should be\n            issued when a snapshot operation (e.g. deleting a snapshot)\n            frees clusters in the qcow2 file (on/off; default: on)\n\n        ``pass-discard-other``\n            Whether discard requests for the data source should be\n            issued on other occasions where a cluster gets freed\n            (on/off; default: off)\n\n        ``overlap-check``\n            Which overlap checks to perform for writes to the image\n            (none/constant/cached/all; default: cached). For details or\n            finer granularity control refer to the QAPI documentation of\n            ``blockdev-add``.\n\n        Example 1:\n\n        ::\n\n            -blockdev driver=file,node-name=my_file,filename=/tmp/disk.qcow2\n            -blockdev driver=qcow2,node-name=hda,file=my_file,overlap-check=none,cache-size=16777216\n\n        Example 2:\n\n        ::\n\n            -blockdev driver=qcow2,node-name=disk,file.driver=http,file.filename=http://example.com/image.qcow2\n\n    ``Driver-specific options for other drivers``\n        Please refer to the QAPI documentation of the ``blockdev-add``\n        QMP command.\nERST\n\nDEF(\"drive\", HAS_ARG, QEMU_OPTION_drive,\n    \"-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][,index=i]\\n\"\n    \"       [,cache=writethrough|writeback|none|directsync|unsafe][,format=f]\\n\"\n    \"       [,snapshot=on|off][,rerror=ignore|stop|report]\\n\"\n    \"       [,werror=ignore|stop|report|enospc][,id=name]\\n\"\n    \"       [,aio=threads|native|io_uring]\\n\"\n    \"       [,readonly=on|off][,copy-on-read=on|off]\\n\"\n    \"       [,discard=ignore|unmap][,detect-zeroes=on|off|unmap]\\n\"\n    \"       [[,bps=b]|[[,bps_rd=r][,bps_wr=w]]]\\n\"\n    \"       [[,iops=i]|[[,iops_rd=r][,iops_wr=w]]]\\n\"\n    \"       [[,bps_max=bm]|[[,bps_rd_max=rm][,bps_wr_max=wm]]]\\n\"\n    \"       [[,iops_max=im]|[[,iops_rd_max=irm][,iops_wr_max=iwm]]]\\n\"\n    \"       [[,iops_size=is]]\\n\"\n    \"       [[,group=g]]\\n\"\n    \"                use 'file' as a drive image\\n\", QEMU_ARCH_ALL)\nSRST\n``-drive option[,option[,option[,...]]]``\n    Define a new drive. This includes creating a block driver node (the\n    backend) as well as a guest device, and is mostly a shortcut for\n    defining the corresponding ``-blockdev`` and ``-device`` options.\n\n    ``-drive`` accepts all options that are accepted by ``-blockdev``.\n    In addition, it knows the following options:\n\n    ``file=file``\n        This option defines which disk image (see the :ref:`disk images`\n        chapter in the System Emulation Users Guide) to use with this drive.\n        If the filename contains comma, you must double it (for instance,\n        \"file=my,,file\" to use file \"my,file\").\n\n        Special files such as iSCSI devices can be specified using\n        protocol specific URLs. See the section for \"Device URL Syntax\"\n        for more information.\n\n    ``if=interface``\n        This option defines on which type on interface the drive is\n        connected. Available types are: ide, scsi, sd, mtd, floppy,\n        pflash, virtio, none.\n\n    ``bus=bus,unit=unit``\n        These options define where is connected the drive by defining\n        the bus number and the unit id.\n\n    ``index=index``\n        This option defines where the drive is connected by using an\n        index in the list of available connectors of a given interface\n        type.\n\n    ``media=media``\n        This option defines the type of the media: disk or cdrom.\n\n    ``snapshot=snapshot``\n        snapshot is \"on\" or \"off\" and controls snapshot mode for the\n        given drive (see ``-snapshot``).\n\n    ``cache=cache``\n        cache is \"none\", \"writeback\", \"unsafe\", \"directsync\" or\n        \"writethrough\" and controls how the host cache is used to access\n        block data. This is a shortcut that sets the ``cache.direct``\n        and ``cache.no-flush`` options (as in ``-blockdev``), and\n        additionally ``cache.writeback``, which provides a default for\n        the ``write-cache`` option of block guest devices (as in\n        ``-device``). The modes correspond to the following settings:\n\n        =============  ===============   ============   ==============\n        \\              cache.writeback   cache.direct   cache.no-flush\n        =============  ===============   ============   ==============\n        writeback      on                off            off\n        none           on                on             off\n        writethrough   off               off            off\n        directsync     off               on             off\n        unsafe         on                off            on\n        =============  ===============   ============   ==============\n\n        The default mode is ``cache=writeback``.\n\n    ``aio=aio``\n        aio is \"threads\", \"native\", or \"io_uring\" and selects between pthread\n        based disk I/O, native Linux AIO, or Linux io_uring API.\n\n    ``format=format``\n        Specify which disk format will be used rather than detecting the\n        format. Can be used to specify format=raw to avoid interpreting\n        an untrusted format header.\n\n    ``werror=action,rerror=action``\n        Specify which action to take on write and read errors. Valid\n        actions are: \"ignore\" (ignore the error and try to continue),\n        \"stop\" (pause QEMU), \"report\" (report the error to the guest),\n        \"enospc\" (pause QEMU only if the host disk is full; report the\n        error to the guest otherwise). The default setting is\n        ``werror=enospc`` and ``rerror=report``.\n\n    ``copy-on-read=copy-on-read``\n        copy-on-read is \"on\" or \"off\" and enables whether to copy read\n        backing file sectors into the image file.\n\n    ``bps=b,bps_rd=r,bps_wr=w``\n        Specify bandwidth throttling limits in bytes per second, either\n        for all request types or for reads or writes only. Small values\n        can lead to timeouts or hangs inside the guest. A safe minimum\n        for disks is 2 MB/s.\n\n    ``bps_max=bm,bps_rd_max=rm,bps_wr_max=wm``\n        Specify bursts in bytes per second, either for all request types\n        or for reads or writes only. Bursts allow the guest I/O to spike\n        above the limit temporarily.\n\n    ``iops=i,iops_rd=r,iops_wr=w``\n        Specify request rate limits in requests per second, either for\n        all request types or for reads or writes only.\n\n    ``iops_max=bm,iops_rd_max=rm,iops_wr_max=wm``\n        Specify bursts in requests per second, either for all request\n        types or for reads or writes only. Bursts allow the guest I/O to\n        spike above the limit temporarily.\n\n    ``iops_size=is``\n        Let every is bytes of a request count as a new request for iops\n        throttling purposes. Use this option to prevent guests from\n        circumventing iops limits by sending fewer but larger requests.\n\n    ``group=g``\n        Join a throttling quota group with given name g. All drives that\n        are members of the same group are accounted for together. Use\n        this option to prevent guests from circumventing throttling\n        limits by using many small disks instead of a single larger\n        disk.\n\n    By default, the ``cache.writeback=on`` mode is used. It will report\n    data writes as completed as soon as the data is present in the host\n    page cache. This is safe as long as your guest OS makes sure to\n    correctly flush disk caches where needed. If your guest OS does not\n    handle volatile disk write caches correctly and your host crashes or\n    loses power, then the guest may experience data corruption.\n\n    For such guests, you should consider using ``cache.writeback=off``.\n    This means that the host page cache will be used to read and write\n    data, but write notification will be sent to the guest only after\n    QEMU has made sure to flush each write to the disk. Be aware that\n    this has a major impact on performance.\n\n    When using the ``-snapshot`` option, unsafe caching is always used.\n\n    Copy-on-read avoids accessing the same backing file sectors\n    repeatedly and is useful when the backing file is over a slow\n    network. By default copy-on-read is off.\n\n    Instead of ``-cdrom`` you can use:\n\n    .. parsed-literal::\n\n        |qemu_system| -drive file=file,index=2,media=cdrom\n\n    Instead of ``-hda``, ``-hdb``, ``-hdc``, ``-hdd``, you can use:\n\n    .. parsed-literal::\n\n        |qemu_system| -drive file=file,index=0,media=disk\n        |qemu_system| -drive file=file,index=1,media=disk\n        |qemu_system| -drive file=file,index=2,media=disk\n        |qemu_system| -drive file=file,index=3,media=disk\n\n    You can open an image using pre-opened file descriptors from an fd\n    set:\n\n    .. parsed-literal::\n\n        |qemu_system| \\\\\n         -add-fd fd=3,set=2,opaque=\"rdwr:/path/to/file\" \\\\\n         -add-fd fd=4,set=2,opaque=\"rdonly:/path/to/file\" \\\\\n         -drive file=/dev/fdset/2,index=0,media=disk\n\n    You can connect a CDROM to the slave of ide0:\n\n    .. parsed-literal::\n\n        |qemu_system_x86| -drive file=file,if=ide,index=1,media=cdrom\n\n    If you don't specify the \"file=\" argument, you define an empty\n    drive:\n\n    .. parsed-literal::\n\n        |qemu_system_x86| -drive if=ide,index=1,media=cdrom\n\n    Instead of ``-fda``, ``-fdb``, you can use:\n\n    .. parsed-literal::\n\n        |qemu_system_x86| -drive file=file,index=0,if=floppy\n        |qemu_system_x86| -drive file=file,index=1,if=floppy\n\n    By default, interface is \"ide\" and index is automatically\n    incremented:\n\n    .. parsed-literal::\n\n        |qemu_system_x86| -drive file=a -drive file=b\"\n\n    is interpreted like:\n\n    .. parsed-literal::\n\n        |qemu_system_x86| -hda a -hdb b\nERST\n\nDEF(\"mtdblock\", HAS_ARG, QEMU_OPTION_mtdblock,\n    \"-mtdblock file  use 'file' as on-board Flash memory image\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-mtdblock file``\n    Use file as on-board Flash memory image.\nERST\n\nDEF(\"sd\", HAS_ARG, QEMU_OPTION_sd,\n    \"-sd file        use 'file' as SecureDigital card image\\n\", QEMU_ARCH_ALL)\nSRST\n``-sd file``\n    Use file as SecureDigital card image.\nERST\n\nDEF(\"snapshot\", 0, QEMU_OPTION_snapshot,\n    \"-snapshot       write to temporary files instead of disk image files\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-snapshot``\n    Write to temporary files instead of disk image files. In this case,\n    the raw disk image you use is not written back. You can however\n    force the write back by pressing C-a s (see the :ref:`disk images`\n    chapter in the System Emulation Users Guide).\nERST\n\nDEF(\"fsdev\", HAS_ARG, QEMU_OPTION_fsdev,\n    \"-fsdev local,id=id,path=path,security_model=mapped-xattr|mapped-file|passthrough|none\\n\"\n    \" [,writeout=immediate][,readonly=on][,fmode=fmode][,dmode=dmode]\\n\"\n    \" [[,throttling.bps-total=b]|[[,throttling.bps-read=r][,throttling.bps-write=w]]]\\n\"\n    \" [[,throttling.iops-total=i]|[[,throttling.iops-read=r][,throttling.iops-write=w]]]\\n\"\n    \" [[,throttling.bps-total-max=bm]|[[,throttling.bps-read-max=rm][,throttling.bps-write-max=wm]]]\\n\"\n    \" [[,throttling.iops-total-max=im]|[[,throttling.iops-read-max=irm][,throttling.iops-write-max=iwm]]]\\n\"\n    \" [[,throttling.iops-size=is]]\\n\"\n    \"-fsdev proxy,id=id,socket=socket[,writeout=immediate][,readonly=on]\\n\"\n    \"-fsdev proxy,id=id,sock_fd=sock_fd[,writeout=immediate][,readonly=on]\\n\"\n    \"-fsdev synth,id=id\\n\",\n    QEMU_ARCH_ALL)\n\nSRST\n``-fsdev local,id=id,path=path,security_model=security_model [,writeout=writeout][,readonly=on][,fmode=fmode][,dmode=dmode] [,throttling.option=value[,throttling.option=value[,...]]]``\n  \\ \n``-fsdev proxy,id=id,socket=socket[,writeout=writeout][,readonly=on]``\n  \\\n``-fsdev proxy,id=id,sock_fd=sock_fd[,writeout=writeout][,readonly=on]``\n  \\\n``-fsdev synth,id=id[,readonly=on]``\n    Define a new file system device. Valid options are:\n\n    ``local``\n        Accesses to the filesystem are done by QEMU.\n\n    ``proxy``\n        Accesses to the filesystem are done by virtfs-proxy-helper(1).\n\n    ``synth``\n        Synthetic filesystem, only used by QTests.\n\n    ``id=id``\n        Specifies identifier for this device.\n\n    ``path=path``\n        Specifies the export path for the file system device. Files\n        under this path will be available to the 9p client on the guest.\n\n    ``security_model=security_model``\n        Specifies the security model to be used for this export path.\n        Supported security models are \"passthrough\", \"mapped-xattr\",\n        \"mapped-file\" and \"none\". In \"passthrough\" security model, files\n        are stored using the same credentials as they are created on the\n        guest. This requires QEMU to run as root. In \"mapped-xattr\"\n        security model, some of the file attributes like uid, gid, mode\n        bits and link target are stored as file attributes. For\n        \"mapped-file\" these attributes are stored in the hidden\n        .virtfs\\_metadata directory. Directories exported by this\n        security model cannot interact with other unix tools. \"none\"\n        security model is same as passthrough except the sever won't\n        report failures if it fails to set file attributes like\n        ownership. Security model is mandatory only for local fsdriver.\n        Other fsdrivers (like proxy) don't take security model as a\n        parameter.\n\n    ``writeout=writeout``\n        This is an optional argument. The only supported value is\n        \"immediate\". This means that host page cache will be used to\n        read and write data but write notification will be sent to the\n        guest only when the data has been reported as written by the\n        storage subsystem.\n\n    ``readonly=on``\n        Enables exporting 9p share as a readonly mount for guests. By\n        default read-write access is given.\n\n    ``socket=socket``\n        Enables proxy filesystem driver to use passed socket file for\n        communicating with virtfs-proxy-helper(1).\n\n    ``sock_fd=sock_fd``\n        Enables proxy filesystem driver to use passed socket descriptor\n        for communicating with virtfs-proxy-helper(1). Usually a helper\n        like libvirt will create socketpair and pass one of the fds as\n        sock\\_fd.\n\n    ``fmode=fmode``\n        Specifies the default mode for newly created files on the host.\n        Works only with security models \"mapped-xattr\" and\n        \"mapped-file\".\n\n    ``dmode=dmode``\n        Specifies the default mode for newly created directories on the\n        host. Works only with security models \"mapped-xattr\" and\n        \"mapped-file\".\n\n    ``throttling.bps-total=b,throttling.bps-read=r,throttling.bps-write=w``\n        Specify bandwidth throttling limits in bytes per second, either\n        for all request types or for reads or writes only.\n\n    ``throttling.bps-total-max=bm,bps-read-max=rm,bps-write-max=wm``\n        Specify bursts in bytes per second, either for all request types\n        or for reads or writes only. Bursts allow the guest I/O to spike\n        above the limit temporarily.\n\n    ``throttling.iops-total=i,throttling.iops-read=r, throttling.iops-write=w``\n        Specify request rate limits in requests per second, either for\n        all request types or for reads or writes only.\n\n    ``throttling.iops-total-max=im,throttling.iops-read-max=irm, throttling.iops-write-max=iwm``\n        Specify bursts in requests per second, either for all request\n        types or for reads or writes only. Bursts allow the guest I/O to\n        spike above the limit temporarily.\n\n    ``throttling.iops-size=is``\n        Let every is bytes of a request count as a new request for iops\n        throttling purposes.\n\n    -fsdev option is used along with -device driver \"virtio-9p-...\".\n\n``-device virtio-9p-type,fsdev=id,mount_tag=mount_tag``\n    Options for virtio-9p-... driver are:\n\n    ``type``\n        Specifies the variant to be used. Supported values are \"pci\",\n        \"ccw\" or \"device\", depending on the machine type.\n\n    ``fsdev=id``\n        Specifies the id value specified along with -fsdev option.\n\n    ``mount_tag=mount_tag``\n        Specifies the tag name to be used by the guest to mount this\n        export point.\nERST\n\nDEF(\"virtfs\", HAS_ARG, QEMU_OPTION_virtfs,\n    \"-virtfs local,path=path,mount_tag=tag,security_model=mapped-xattr|mapped-file|passthrough|none\\n\"\n    \"        [,id=id][,writeout=immediate][,readonly=on][,fmode=fmode][,dmode=dmode][,multidevs=remap|forbid|warn]\\n\"\n    \"-virtfs proxy,mount_tag=tag,socket=socket[,id=id][,writeout=immediate][,readonly=on]\\n\"\n    \"-virtfs proxy,mount_tag=tag,sock_fd=sock_fd[,id=id][,writeout=immediate][,readonly=on]\\n\"\n    \"-virtfs synth,mount_tag=tag[,id=id][,readonly=on]\\n\",\n    QEMU_ARCH_ALL)\n\nSRST\n``-virtfs local,path=path,mount_tag=mount_tag ,security_model=security_model[,writeout=writeout][,readonly=on] [,fmode=fmode][,dmode=dmode][,multidevs=multidevs]``\n  \\ \n``-virtfs proxy,socket=socket,mount_tag=mount_tag [,writeout=writeout][,readonly=on]``\n  \\ \n``-virtfs proxy,sock_fd=sock_fd,mount_tag=mount_tag [,writeout=writeout][,readonly=on]``\n  \\\n``-virtfs synth,mount_tag=mount_tag``\n    Define a new virtual filesystem device and expose it to the guest using\n    a virtio-9p-device (a.k.a. 9pfs), which essentially means that a certain\n    directory on host is made directly accessible by guest as a pass-through\n    file system by using the 9P network protocol for communication between\n    host and guests, if desired even accessible, shared by several guests\n    simultaniously.\n\n    Note that ``-virtfs`` is actually just a convenience shortcut for its\n    generalized form ``-fsdev -device virtio-9p-pci``.\n\n    The general form of pass-through file system options are:\n\n    ``local``\n        Accesses to the filesystem are done by QEMU.\n\n    ``proxy``\n        Accesses to the filesystem are done by virtfs-proxy-helper(1).\n\n    ``synth``\n        Synthetic filesystem, only used by QTests.\n\n    ``id=id``\n        Specifies identifier for the filesystem device\n\n    ``path=path``\n        Specifies the export path for the file system device. Files\n        under this path will be available to the 9p client on the guest.\n\n    ``security_model=security_model``\n        Specifies the security model to be used for this export path.\n        Supported security models are \"passthrough\", \"mapped-xattr\",\n        \"mapped-file\" and \"none\". In \"passthrough\" security model, files\n        are stored using the same credentials as they are created on the\n        guest. This requires QEMU to run as root. In \"mapped-xattr\"\n        security model, some of the file attributes like uid, gid, mode\n        bits and link target are stored as file attributes. For\n        \"mapped-file\" these attributes are stored in the hidden\n        .virtfs\\_metadata directory. Directories exported by this\n        security model cannot interact with other unix tools. \"none\"\n        security model is same as passthrough except the sever won't\n        report failures if it fails to set file attributes like\n        ownership. Security model is mandatory only for local fsdriver.\n        Other fsdrivers (like proxy) don't take security model as a\n        parameter.\n\n    ``writeout=writeout``\n        This is an optional argument. The only supported value is\n        \"immediate\". This means that host page cache will be used to\n        read and write data but write notification will be sent to the\n        guest only when the data has been reported as written by the\n        storage subsystem.\n\n    ``readonly=on``\n        Enables exporting 9p share as a readonly mount for guests. By\n        default read-write access is given.\n\n    ``socket=socket``\n        Enables proxy filesystem driver to use passed socket file for\n        communicating with virtfs-proxy-helper(1). Usually a helper like\n        libvirt will create socketpair and pass one of the fds as\n        sock\\_fd.\n\n    ``sock_fd``\n        Enables proxy filesystem driver to use passed 'sock\\_fd' as the\n        socket descriptor for interfacing with virtfs-proxy-helper(1).\n\n    ``fmode=fmode``\n        Specifies the default mode for newly created files on the host.\n        Works only with security models \"mapped-xattr\" and\n        \"mapped-file\".\n\n    ``dmode=dmode``\n        Specifies the default mode for newly created directories on the\n        host. Works only with security models \"mapped-xattr\" and\n        \"mapped-file\".\n\n    ``mount_tag=mount_tag``\n        Specifies the tag name to be used by the guest to mount this\n        export point.\n\n    ``multidevs=multidevs``\n        Specifies how to deal with multiple devices being shared with a\n        9p export. Supported behaviours are either \"remap\", \"forbid\" or\n        \"warn\". The latter is the default behaviour on which virtfs 9p\n        expects only one device to be shared with the same export, and\n        if more than one device is shared and accessed via the same 9p\n        export then only a warning message is logged (once) by qemu on\n        host side. In order to avoid file ID collisions on guest you\n        should either create a separate virtfs export for each device to\n        be shared with guests (recommended way) or you might use \"remap\"\n        instead which allows you to share multiple devices with only one\n        export instead, which is achieved by remapping the original\n        inode numbers from host to guest in a way that would prevent\n        such collisions. Remapping inodes in such use cases is required\n        because the original device IDs from host are never passed and\n        exposed on guest. Instead all files of an export shared with\n        virtfs always share the same device id on guest. So two files\n        with identical inode numbers but from actually different devices\n        on host would otherwise cause a file ID collision and hence\n        potential misbehaviours on guest. \"forbid\" on the other hand\n        assumes like \"warn\" that only one device is shared by the same\n        export, however it will not only log a warning message but also\n        deny access to additional devices on guest. Note though that\n        \"forbid\" does currently not block all possible file access\n        operations (e.g. readdir() would still return entries from other\n        devices).\nERST\n\nDEF(\"iscsi\", HAS_ARG, QEMU_OPTION_iscsi,\n    \"-iscsi [user=user][,password=password]\\n\"\n    \"       [,header-digest=CRC32C|CR32C-NONE|NONE-CRC32C|NONE\\n\"\n    \"       [,initiator-name=initiator-iqn][,id=target-iqn]\\n\"\n    \"       [,timeout=timeout]\\n\"\n    \"                iSCSI session parameters\\n\", QEMU_ARCH_ALL)\n\nSRST\n``-iscsi``\n    Configure iSCSI session parameters.\nERST\n\nDEFHEADING()\n\nDEFHEADING(USB convenience options:)\n\nDEF(\"usb\", 0, QEMU_OPTION_usb,\n    \"-usb            enable on-board USB host controller (if not enabled by default)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-usb``\n    Enable USB emulation on machine types with an on-board USB host\n    controller (if not enabled by default). Note that on-board USB host\n    controllers may not support USB 3.0. In this case\n    ``-device qemu-xhci`` can be used instead on machines with PCI.\nERST\n\nDEF(\"usbdevice\", HAS_ARG, QEMU_OPTION_usbdevice,\n    \"-usbdevice name add the host or guest USB device 'name'\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-usbdevice devname``\n    Add the USB device devname, and enable an on-board USB controller\n    if possible and necessary (just like it can be done via\n    ``-machine usb=on``). Note that this option is mainly intended for\n    the user's convenience only. More fine-grained control can be\n    achieved by selecting a USB host controller (if necessary) and the\n    desired USB device via the ``-device`` option instead. For example,\n    instead of using ``-usbdevice mouse`` it is possible to use\n    ``-device qemu-xhci -device usb-mouse`` to connect the USB mouse\n    to a USB 3.0 controller instead (at least on machines that support\n    PCI and do not have an USB controller enabled by default yet).\n    For more details, see the chapter about\n    :ref:`Connecting USB devices` in the System Emulation Users Guide.\n    Possible devices for devname are:\n\n    ``braille``\n        Braille device. This will use BrlAPI to display the braille\n        output on a real or fake device (i.e. it also creates a\n        corresponding ``braille`` chardev automatically beside the\n        ``usb-braille`` USB device).\n\n    ``keyboard``\n        Standard USB keyboard. Will override the PS/2 keyboard (if present).\n\n    ``mouse``\n        Virtual Mouse. This will override the PS/2 mouse emulation when\n        activated.\n\n    ``tablet``\n        Pointer device that uses absolute coordinates (like a\n        touchscreen). This means QEMU is able to report the mouse\n        position without having to grab the mouse. Also overrides the\n        PS/2 mouse emulation when activated.\n\n    ``wacom-tablet``\n        Wacom PenPartner USB tablet.\n\n\nERST\n\nDEFHEADING()\n\nDEFHEADING(Display options:)\n\nDEF(\"display\", HAS_ARG, QEMU_OPTION_display,\n#if defined(CONFIG_SPICE)\n    \"-display spice-app[,gl=on|off]\\n\"\n#endif\n#if defined(CONFIG_SDL)\n    \"-display sdl[,gl=on|core|es|off][,grab-mod=<mod>][,show-cursor=on|off]\\n\"\n    \"            [,window-close=on|off]\\n\"\n#endif\n#if defined(CONFIG_GTK)\n    \"-display gtk[,full-screen=on|off][,gl=on|off][,grab-on-hover=on|off]\\n\"\n    \"            [,show-tabs=on|off][,show-cursor=on|off][,window-close=on|off]\\n\"\n#endif\n#if defined(CONFIG_VNC)\n    \"-display vnc=<display>[,<optargs>]\\n\"\n#endif\n#if defined(CONFIG_CURSES)\n    \"-display curses[,charset=<encoding>]\\n\"\n#endif\n#if defined(CONFIG_COCOA)\n    \"-display cocoa[,full-grab=on|off][,swap-opt-cmd=on|off]\\n\"\n#endif\n#if defined(CONFIG_OPENGL)\n    \"-display egl-headless[,rendernode=<file>]\\n\"\n#endif\n#if defined(CONFIG_DBUS_DISPLAY)\n    \"-display dbus[,addr=<dbusaddr>]\\n\"\n    \"             [,gl=on|core|es|off][,rendernode=<file>]\\n\"\n#endif\n#if defined(CONFIG_COCOA)\n    \"-display cocoa[,show-cursor=on|off][,left-command-key=on|off]\\n\"\n#endif\n    \"-display none\\n\"\n    \"                select display backend type\\n\"\n    \"                The default display is equivalent to\\n                \"\n#if defined(CONFIG_GTK)\n            \"\\\"-display gtk\\\"\\n\"\n#elif defined(CONFIG_SDL)\n            \"\\\"-display sdl\\\"\\n\"\n#elif defined(CONFIG_COCOA)\n            \"\\\"-display cocoa\\\"\\n\"\n#elif defined(CONFIG_VNC)\n            \"\\\"-vnc localhost:0,to=99,id=default\\\"\\n\"\n#else\n            \"\\\"-display none\\\"\\n\"\n#endif\n    , QEMU_ARCH_ALL)\nSRST\n``-display type``\n    Select type of display to use. Use ``-display help`` to list the available\n    display types. Valid values for type are\n\n    ``spice-app[,gl=on|off]``\n        Start QEMU as a Spice server and launch the default Spice client\n        application. The Spice server will redirect the serial consoles\n        and QEMU monitors. (Since 4.0)\n\n    ``dbus``\n        Export the display over D-Bus interfaces. (Since 7.0)\n\n        The connection is registered with the \"org.qemu\" name (and queued when\n        already owned).\n\n        ``addr=<dbusaddr>`` : D-Bus bus address to connect to.\n\n        ``p2p=yes|no`` : Use peer-to-peer connection, accepted via QMP ``add_client``.\n\n        ``gl=on|off|core|es`` : Use OpenGL for rendering (the D-Bus interface\n        will share framebuffers with DMABUF file descriptors).\n\n    ``sdl``\n        Display video output via SDL (usually in a separate graphics\n        window; see the SDL documentation for other possibilities).\n        Valid parameters are:\n\n        ``grab-mod=<mods>`` : Used to select the modifier keys for toggling\n        the mouse grabbing in conjunction with the \"g\" key. ``<mods>`` can be\n        either ``lshift-lctrl-lalt`` or ``rctrl``.\n\n        ``gl=on|off|core|es`` : Use OpenGL for displaying\n\n        ``show-cursor=on|off`` :  Force showing the mouse cursor\n\n        ``window-close=on|off`` : Allow to quit qemu with window close button\n\n    ``gtk``\n        Display video output in a GTK window. This interface provides\n        drop-down menus and other UI elements to configure and control\n        the VM during runtime. Valid parameters are:\n\n        ``full-screen=on|off`` : Start in fullscreen mode\n\n        ``gl=on|off`` : Use OpenGL for displaying\n\n        ``grab-on-hover=on|off`` : Grab keyboard input on mouse hover\n\n        ``show-tabs=on|off`` : Display the tab bar for switching between the\n                               various graphical interfaces (e.g. VGA and\n                               virtual console character devices) by default.\n\n        ``show-cursor=on|off`` :  Force showing the mouse cursor\n\n        ``window-close=on|off`` : Allow to quit qemu with window close button\n\n    ``curses[,charset=<encoding>]``\n        Display video output via curses. For graphics device models\n        which support a text mode, QEMU can display this output using a\n        curses/ncurses interface. Nothing is displayed when the graphics\n        device is in graphical mode or if the graphics device does not\n        support a text mode. Generally only the VGA device models\n        support text mode. The font charset used by the guest can be\n        specified with the ``charset`` option, for example\n        ``charset=CP850`` for IBM CP850 encoding. The default is\n        ``CP437``.\n\n    ``cocoa``\n        Display video output in a Cocoa window. Mac only. This interface\n        provides drop-down menus and other UI elements to configure and\n        control the VM during runtime. Valid parameters are:\n\n        ``show-cursor=on|off`` :  Force showing the mouse cursor\n\n        ``left-command-key=on|off`` : Disable forwarding left command key to host\n\n    ``egl-headless[,rendernode=<file>]``\n        Offload all OpenGL operations to a local DRI device. For any\n        graphical display, this display needs to be paired with either\n        VNC or SPICE displays.\n\n    ``vnc=<display>``\n        Start a VNC server on display <display>\n\n    ``none``\n        Do not display video output. The guest will still see an\n        emulated graphics card, but its output will not be displayed to\n        the QEMU user. This option differs from the -nographic option in\n        that it only affects what is done with video output; -nographic\n        also changes the destination of the serial and parallel port\n        data.\nERST\n\nDEF(\"nographic\", 0, QEMU_OPTION_nographic,\n    \"-nographic      disable graphical output and redirect serial I/Os to console\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-nographic``\n    Normally, if QEMU is compiled with graphical window support, it\n    displays output such as guest graphics, guest console, and the QEMU\n    monitor in a window. With this option, you can totally disable\n    graphical output so that QEMU is a simple command line application.\n    The emulated serial port is redirected on the console and muxed with\n    the monitor (unless redirected elsewhere explicitly). Therefore, you\n    can still use QEMU to debug a Linux kernel with a serial console.\n    Use C-a h for help on switching between the console and monitor.\nERST\n\n#ifdef CONFIG_SPICE\nDEF(\"spice\", HAS_ARG, QEMU_OPTION_spice,\n    \"-spice [port=port][,tls-port=secured-port][,x509-dir=<dir>]\\n\"\n    \"       [,x509-key-file=<file>][,x509-key-password=<file>]\\n\"\n    \"       [,x509-cert-file=<file>][,x509-cacert-file=<file>]\\n\"\n    \"       [,x509-dh-key-file=<file>][,addr=addr]\\n\"\n    \"       [,ipv4=on|off][,ipv6=on|off][,unix=on|off]\\n\"\n    \"       [,tls-ciphers=<list>]\\n\"\n    \"       [,tls-channel=[main|display|cursor|inputs|record|playback]]\\n\"\n    \"       [,plaintext-channel=[main|display|cursor|inputs|record|playback]]\\n\"\n    \"       [,sasl=on|off][,disable-ticketing=on|off]\\n\"\n    \"       [,password=<string>][,password-secret=<secret-id>]\\n\"\n    \"       [,image-compression=[auto_glz|auto_lz|quic|glz|lz|off]]\\n\"\n    \"       [,jpeg-wan-compression=[auto|never|always]]\\n\"\n    \"       [,zlib-glz-wan-compression=[auto|never|always]]\\n\"\n    \"       [,streaming-video=[off|all|filter]][,disable-copy-paste=on|off]\\n\"\n    \"       [,disable-agent-file-xfer=on|off][,agent-mouse=[on|off]]\\n\"\n    \"       [,playback-compression=[on|off]][,seamless-migration=[on|off]]\\n\"\n    \"       [,gl=[on|off]][,rendernode=<file>]\\n\"\n    \"   enable spice\\n\"\n    \"   at least one of {port, tls-port} is mandatory\\n\",\n    QEMU_ARCH_ALL)\n#endif\nSRST\n``-spice option[,option[,...]]``\n    Enable the spice remote desktop protocol. Valid options are\n\n    ``port=<nr>``\n        Set the TCP port spice is listening on for plaintext channels.\n\n    ``addr=<addr>``\n        Set the IP address spice is listening on. Default is any\n        address.\n\n    ``ipv4=on|off``; \\ ``ipv6=on|off``; \\ ``unix=on|off``\n        Force using the specified IP version.\n\n    ``password=<string>``\n        Set the password you need to authenticate.\n\n        This option is deprecated and insecure because it leaves the\n        password visible in the process listing. Use ``password-secret``\n        instead.\n\n    ``password-secret=<secret-id>``\n        Set the ID of the ``secret`` object containing the password\n        you need to authenticate.\n\n    ``sasl=on|off``\n        Require that the client use SASL to authenticate with the spice.\n        The exact choice of authentication method used is controlled\n        from the system / user's SASL configuration file for the 'qemu'\n        service. This is typically found in /etc/sasl2/qemu.conf. If\n        running QEMU as an unprivileged user, an environment variable\n        SASL\\_CONF\\_PATH can be used to make it search alternate\n        locations for the service config. While some SASL auth methods\n        can also provide data encryption (eg GSSAPI), it is recommended\n        that SASL always be combined with the 'tls' and 'x509' settings\n        to enable use of SSL and server certificates. This ensures a\n        data encryption preventing compromise of authentication\n        credentials.\n\n    ``disable-ticketing=on|off``\n        Allow client connects without authentication.\n\n    ``disable-copy-paste=on|off``\n        Disable copy paste between the client and the guest.\n\n    ``disable-agent-file-xfer=on|off``\n        Disable spice-vdagent based file-xfer between the client and the\n        guest.\n\n    ``tls-port=<nr>``\n        Set the TCP port spice is listening on for encrypted channels.\n\n    ``x509-dir=<dir>``\n        Set the x509 file directory. Expects same filenames as -vnc\n        $display,x509=$dir\n\n    ``x509-key-file=<file>``; \\ ``x509-key-password=<file>``; \\ ``x509-cert-file=<file>``; \\ ``x509-cacert-file=<file>``; \\ ``x509-dh-key-file=<file>``\n        The x509 file names can also be configured individually.\n\n    ``tls-ciphers=<list>``\n        Specify which ciphers to use.\n\n    ``tls-channel=[main|display|cursor|inputs|record|playback]``; \\ ``plaintext-channel=[main|display|cursor|inputs|record|playback]``\n        Force specific channel to be used with or without TLS\n        encryption. The options can be specified multiple times to\n        configure multiple channels. The special name \"default\" can be\n        used to set the default mode. For channels which are not\n        explicitly forced into one mode the spice client is allowed to\n        pick tls/plaintext as he pleases.\n\n    ``image-compression=[auto_glz|auto_lz|quic|glz|lz|off]``\n        Configure image compression (lossless). Default is auto\\_glz.\n\n    ``jpeg-wan-compression=[auto|never|always]``; \\ ``zlib-glz-wan-compression=[auto|never|always]``\n        Configure wan image compression (lossy for slow links). Default\n        is auto.\n\n    ``streaming-video=[off|all|filter]``\n        Configure video stream detection. Default is off.\n\n    ``agent-mouse=[on|off]``\n        Enable/disable passing mouse events via vdagent. Default is on.\n\n    ``playback-compression=[on|off]``\n        Enable/disable audio stream compression (using celt 0.5.1).\n        Default is on.\n\n    ``seamless-migration=[on|off]``\n        Enable/disable spice seamless migration. Default is off.\n\n    ``gl=[on|off]``\n        Enable/disable OpenGL context. Default is off.\n\n    ``rendernode=<file>``\n        DRM render node for OpenGL rendering. If not specified, it will\n        pick the first available. (Since 2.9)\nERST\n\nDEF(\"portrait\", 0, QEMU_OPTION_portrait,\n    \"-portrait       rotate graphical output 90 deg left (only PXA LCD)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-portrait``\n    Rotate graphical output 90 deg left (only PXA LCD).\nERST\n\nDEF(\"rotate\", HAS_ARG, QEMU_OPTION_rotate,\n    \"-rotate <deg>   rotate graphical output some deg left (only PXA LCD)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-rotate deg``\n    Rotate graphical output some deg left (only PXA LCD).\nERST\n\nDEF(\"vga\", HAS_ARG, QEMU_OPTION_vga,\n    \"-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]\\n\"\n    \"                select video card type\\n\", QEMU_ARCH_ALL)\nSRST\n``-vga type``\n    Select type of VGA card to emulate. Valid values for type are\n\n    ``cirrus``\n        Cirrus Logic GD5446 Video card. All Windows versions starting\n        from Windows 95 should recognize and use this graphic card. For\n        optimal performances, use 16 bit color depth in the guest and\n        the host OS. (This card was the default before QEMU 2.2)\n\n    ``std``\n        Standard VGA card with Bochs VBE extensions. If your guest OS\n        supports the VESA 2.0 VBE extensions (e.g. Windows XP) and if\n        you want to use high resolution modes (>= 1280x1024x16) then you\n        should use this option. (This card is the default since QEMU\n        2.2)\n\n    ``vmware``\n        VMWare SVGA-II compatible adapter. Use it if you have\n        sufficiently recent XFree86/XOrg server or Windows guest with a\n        driver for this card.\n\n    ``qxl``\n        QXL paravirtual graphic card. It is VGA compatible (including\n        VESA 2.0 VBE support). Works best with qxl guest drivers\n        installed though. Recommended choice when using the spice\n        protocol.\n\n    ``tcx``\n        (sun4m only) Sun TCX framebuffer. This is the default\n        framebuffer for sun4m machines and offers both 8-bit and 24-bit\n        colour depths at a fixed resolution of 1024x768.\n\n    ``cg3``\n        (sun4m only) Sun cgthree framebuffer. This is a simple 8-bit\n        framebuffer for sun4m machines available in both 1024x768\n        (OpenBIOS) and 1152x900 (OBP) resolutions aimed at people\n        wishing to run older Solaris versions.\n\n    ``virtio``\n        Virtio VGA card.\n\n    ``none``\n        Disable VGA card.\nERST\n\nDEF(\"full-screen\", 0, QEMU_OPTION_full_screen,\n    \"-full-screen    start in full screen\\n\", QEMU_ARCH_ALL)\nSRST\n``-full-screen``\n    Start in full screen.\nERST\n\nDEF(\"g\", HAS_ARG, QEMU_OPTION_g ,\n    \"-g WxH[xDEPTH]  Set the initial graphical resolution and depth\\n\",\n    QEMU_ARCH_PPC | QEMU_ARCH_SPARC | QEMU_ARCH_M68K)\nSRST\n``-g`` *width*\\ ``x``\\ *height*\\ ``[x``\\ *depth*\\ ``]``\n    Set the initial graphical resolution and depth (PPC, SPARC only).\n\n    For PPC the default is 800x600x32.\n\n    For SPARC with the TCX graphics device, the default is 1024x768x8\n    with the option of 1024x768x24. For cgthree, the default is\n    1024x768x8 with the option of 1152x900x8 for people who wish to use\n    OBP.\nERST\n\nDEF(\"vnc\", HAS_ARG, QEMU_OPTION_vnc ,\n    \"-vnc <display>  shorthand for -display vnc=<display>\\n\", QEMU_ARCH_ALL)\nSRST\n``-vnc display[,option[,option[,...]]]``\n    Normally, if QEMU is compiled with graphical window support, it\n    displays output such as guest graphics, guest console, and the QEMU\n    monitor in a window. With this option, you can have QEMU listen on\n    VNC display display and redirect the VGA display over the VNC\n    session. It is very useful to enable the usb tablet device when\n    using this option (option ``-device usb-tablet``). When using the\n    VNC display, you must use the ``-k`` parameter to set the keyboard\n    layout if you are not using en-us. Valid syntax for the display is\n\n    ``to=L``\n        With this option, QEMU will try next available VNC displays,\n        until the number L, if the origianlly defined \"-vnc display\" is\n        not available, e.g. port 5900+display is already used by another\n        application. By default, to=0.\n\n    ``host:d``\n        TCP connections will only be allowed from host on display d. By\n        convention the TCP port is 5900+d. Optionally, host can be\n        omitted in which case the server will accept connections from\n        any host.\n\n    ``unix:path``\n        Connections will be allowed over UNIX domain sockets where path\n        is the location of a unix socket to listen for connections on.\n\n    ``none``\n        VNC is initialized but not started. The monitor ``change``\n        command can be used to later start the VNC server.\n\n    Following the display value there may be one or more option flags\n    separated by commas. Valid options are\n\n    ``reverse=on|off``\n        Connect to a listening VNC client via a \"reverse\" connection.\n        The client is specified by the display. For reverse network\n        connections (host:d,``reverse``), the d argument is a TCP port\n        number, not a display number.\n\n    ``websocket=on|off``\n        Opens an additional TCP listening port dedicated to VNC\n        Websocket connections. If a bare websocket option is given, the\n        Websocket port is 5700+display. An alternative port can be\n        specified with the syntax ``websocket``\\ =port.\n\n        If host is specified connections will only be allowed from this\n        host. It is possible to control the websocket listen address\n        independently, using the syntax ``websocket``\\ =host:port.\n\n        If no TLS credentials are provided, the websocket connection\n        runs in unencrypted mode. If TLS credentials are provided, the\n        websocket connection requires encrypted client connections.\n\n    ``password=on|off``\n        Require that password based authentication is used for client\n        connections.\n\n        The password must be set separately using the ``set_password``\n        command in the :ref:`QEMU monitor`. The\n        syntax to change your password is:\n        ``set_password <protocol> <password>`` where <protocol> could be\n        either \"vnc\" or \"spice\".\n\n        If you would like to change <protocol> password expiration, you\n        should use ``expire_password <protocol> <expiration-time>``\n        where expiration time could be one of the following options:\n        now, never, +seconds or UNIX time of expiration, e.g. +60 to\n        make password expire in 60 seconds, or 1335196800 to make\n        password expire on \"Mon Apr 23 12:00:00 EDT 2012\" (UNIX time for\n        this date and time).\n\n        You can also use keywords \"now\" or \"never\" for the expiration\n        time to allow <protocol> password to expire immediately or never\n        expire.\n\n    ``password-secret=<secret-id>``\n        Require that password based authentication is used for client\n        connections, using the password provided by the ``secret``\n        object identified by ``secret-id``.\n\n    ``tls-creds=ID``\n        Provides the ID of a set of TLS credentials to use to secure the\n        VNC server. They will apply to both the normal VNC server socket\n        and the websocket socket (if enabled). Setting TLS credentials\n        will cause the VNC server socket to enable the VeNCrypt auth\n        mechanism. The credentials should have been previously created\n        using the ``-object tls-creds`` argument.\n\n    ``tls-authz=ID``\n        Provides the ID of the QAuthZ authorization object against which\n        the client's x509 distinguished name will validated. This object\n        is only resolved at time of use, so can be deleted and recreated\n        on the fly while the VNC server is active. If missing, it will\n        default to denying access.\n\n    ``sasl=on|off``\n        Require that the client use SASL to authenticate with the VNC\n        server. The exact choice of authentication method used is\n        controlled from the system / user's SASL configuration file for\n        the 'qemu' service. This is typically found in\n        /etc/sasl2/qemu.conf. If running QEMU as an unprivileged user,\n        an environment variable SASL\\_CONF\\_PATH can be used to make it\n        search alternate locations for the service config. While some\n        SASL auth methods can also provide data encryption (eg GSSAPI),\n        it is recommended that SASL always be combined with the 'tls'\n        and 'x509' settings to enable use of SSL and server\n        certificates. This ensures a data encryption preventing\n        compromise of authentication credentials. See the\n        :ref:`VNC security` section in the System Emulation Users Guide\n        for details on using SASL authentication.\n\n    ``sasl-authz=ID``\n        Provides the ID of the QAuthZ authorization object against which\n        the client's SASL username will validated. This object is only\n        resolved at time of use, so can be deleted and recreated on the\n        fly while the VNC server is active. If missing, it will default\n        to denying access.\n\n    ``acl=on|off``\n        Legacy method for enabling authorization of clients against the\n        x509 distinguished name and SASL username. It results in the\n        creation of two ``authz-list`` objects with IDs of\n        ``vnc.username`` and ``vnc.x509dname``. The rules for these\n        objects must be configured with the HMP ACL commands.\n\n        This option is deprecated and should no longer be used. The new\n        ``sasl-authz`` and ``tls-authz`` options are a replacement.\n\n    ``lossy=on|off``\n        Enable lossy compression methods (gradient, JPEG, ...). If this\n        option is set, VNC client may receive lossy framebuffer updates\n        depending on its encoding settings. Enabling this option can\n        save a lot of bandwidth at the expense of quality.\n\n    ``non-adaptive=on|off``\n        Disable adaptive encodings. Adaptive encodings are enabled by\n        default. An adaptive encoding will try to detect frequently\n        updated screen regions, and send updates in these regions using\n        a lossy encoding (like JPEG). This can be really helpful to save\n        bandwidth when playing videos. Disabling adaptive encodings\n        restores the original static behavior of encodings like Tight.\n\n    ``share=[allow-exclusive|force-shared|ignore]``\n        Set display sharing policy. 'allow-exclusive' allows clients to\n        ask for exclusive access. As suggested by the rfb spec this is\n        implemented by dropping other connections. Connecting multiple\n        clients in parallel requires all clients asking for a shared\n        session (vncviewer: -shared switch). This is the default.\n        'force-shared' disables exclusive client access. Useful for\n        shared desktop sessions, where you don't want someone forgetting\n        specify -shared disconnect everybody else. 'ignore' completely\n        ignores the shared flag and allows everybody connect\n        unconditionally. Doesn't conform to the rfb spec but is\n        traditional QEMU behavior.\n\n    ``key-delay-ms``\n        Set keyboard delay, for key down and key up events, in\n        milliseconds. Default is 10. Keyboards are low-bandwidth\n        devices, so this slowdown can help the device and guest to keep\n        up and not lose events in case events are arriving in bulk.\n        Possible causes for the latter are flaky network connections, or\n        scripts for automated testing.\n\n    ``audiodev=audiodev``\n        Use the specified audiodev when the VNC client requests audio\n        transmission. When not using an -audiodev argument, this option\n        must be omitted, otherwise is must be present and specify a\n        valid audiodev.\n\n    ``power-control=on|off``\n        Permit the remote client to issue shutdown, reboot or reset power\n        control requests.\nERST\n\nARCHHEADING(, QEMU_ARCH_I386)\n\nARCHHEADING(i386 target only:, QEMU_ARCH_I386)\n\nDEF(\"win2k-hack\", 0, QEMU_OPTION_win2k_hack,\n    \"-win2k-hack     use it when installing Windows 2000 to avoid a disk full bug\\n\",\n    QEMU_ARCH_I386)\nSRST\n``-win2k-hack``\n    Use it when installing Windows 2000 to avoid a disk full bug. After\n    Windows 2000 is installed, you no longer need this option (this\n    option slows down the IDE transfers).\nERST\n\nDEF(\"no-fd-bootchk\", 0, QEMU_OPTION_no_fd_bootchk,\n    \"-no-fd-bootchk  disable boot signature checking for floppy disks\\n\",\n    QEMU_ARCH_I386)\nSRST\n``-no-fd-bootchk``\n    Disable boot signature checking for floppy disks in BIOS. May be\n    needed to boot from old floppy disks.\nERST\n\nDEF(\"no-acpi\", 0, QEMU_OPTION_no_acpi,\n           \"-no-acpi        disable ACPI\\n\", QEMU_ARCH_I386 | QEMU_ARCH_ARM)\nSRST\n``-no-acpi``\n    Disable ACPI (Advanced Configuration and Power Interface) support.\n    Use it if your guest OS complains about ACPI problems (PC target\n    machine only).\nERST\n\nDEF(\"no-hpet\", 0, QEMU_OPTION_no_hpet,\n    \"-no-hpet        disable HPET\\n\", QEMU_ARCH_I386)\nSRST\n``-no-hpet``\n    Disable HPET support.\nERST\n\nDEF(\"acpitable\", HAS_ARG, QEMU_OPTION_acpitable,\n    \"-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n][,asl_compiler_id=str][,asl_compiler_rev=n][,{data|file}=file1[:file2]...]\\n\"\n    \"                ACPI table description\\n\", QEMU_ARCH_I386)\nSRST\n``-acpitable [sig=str][,rev=n][,oem_id=str][,oem_table_id=str][,oem_rev=n] [,asl_compiler_id=str][,asl_compiler_rev=n][,data=file1[:file2]...]``\n    Add ACPI table with specified header fields and context from\n    specified files. For file=, take whole ACPI table from the specified\n    files, including all ACPI headers (possible overridden by other\n    options). For data=, only data portion of the table is used, all\n    header information is specified in the command line. If a SLIC table\n    is supplied to QEMU, then the SLIC's oem\\_id and oem\\_table\\_id\n    fields will override the same in the RSDT and the FADT (a.k.a.\n    FACP), in order to ensure the field matches required by the\n    Microsoft SLIC spec and the ACPI spec.\nERST\n\nDEF(\"smbios\", HAS_ARG, QEMU_OPTION_smbios,\n    \"-smbios file=binary\\n\"\n    \"                load SMBIOS entry from binary file\\n\"\n    \"-smbios type=0[,vendor=str][,version=str][,date=str][,release=%d.%d]\\n\"\n    \"              [,uefi=on|off]\\n\"\n    \"                specify SMBIOS type 0 fields\\n\"\n    \"-smbios type=1[,manufacturer=str][,product=str][,version=str][,serial=str]\\n\"\n    \"              [,uuid=uuid][,sku=str][,family=str]\\n\"\n    \"                specify SMBIOS type 1 fields\\n\"\n    \"-smbios type=2[,manufacturer=str][,product=str][,version=str][,serial=str]\\n\"\n    \"              [,asset=str][,location=str]\\n\"\n    \"                specify SMBIOS type 2 fields\\n\"\n    \"-smbios type=3[,manufacturer=str][,version=str][,serial=str][,asset=str]\\n\"\n    \"              [,sku=str]\\n\"\n    \"                specify SMBIOS type 3 fields\\n\"\n    \"-smbios type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str]\\n\"\n    \"              [,asset=str][,part=str][,max-speed=%d][,current-speed=%d]\\n\"\n    \"              [,processor-id=%d]\\n\"\n    \"                specify SMBIOS type 4 fields\\n\"\n    \"-smbios type=11[,value=str][,path=filename]\\n\"\n    \"                specify SMBIOS type 11 fields\\n\"\n    \"-smbios type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str]\\n\"\n    \"               [,asset=str][,part=str][,speed=%d]\\n\"\n    \"                specify SMBIOS type 17 fields\\n\"\n    \"-smbios type=41[,designation=str][,kind=str][,instance=%d][,pcidev=str]\\n\"\n    \"                specify SMBIOS type 41 fields\\n\",\n    QEMU_ARCH_I386 | QEMU_ARCH_ARM)\nSRST\n``-smbios file=binary``\n    Load SMBIOS entry from binary file.\n\n``-smbios type=0[,vendor=str][,version=str][,date=str][,release=%d.%d][,uefi=on|off]``\n    Specify SMBIOS type 0 fields\n\n``-smbios type=1[,manufacturer=str][,product=str][,version=str][,serial=str][,uuid=uuid][,sku=str][,family=str]``\n    Specify SMBIOS type 1 fields\n\n``-smbios type=2[,manufacturer=str][,product=str][,version=str][,serial=str][,asset=str][,location=str]``\n    Specify SMBIOS type 2 fields\n\n``-smbios type=3[,manufacturer=str][,version=str][,serial=str][,asset=str][,sku=str]``\n    Specify SMBIOS type 3 fields\n\n``-smbios type=4[,sock_pfx=str][,manufacturer=str][,version=str][,serial=str][,asset=str][,part=str][,processor-id=%d]``\n    Specify SMBIOS type 4 fields\n\n``-smbios type=11[,value=str][,path=filename]``\n    Specify SMBIOS type 11 fields\n\n    This argument can be repeated multiple times, and values are added in the order they are parsed.\n    Applications intending to use OEM strings data are encouraged to use their application name as\n    a prefix for the value string. This facilitates passing information for multiple applications\n    concurrently.\n\n    The ``value=str`` syntax provides the string data inline, while the ``path=filename`` syntax\n    loads data from a file on disk. Note that the file is not permitted to contain any NUL bytes.\n\n    Both the ``value`` and ``path`` options can be repeated multiple times and will be added to\n    the SMBIOS table in the order in which they appear.\n\n    Note that on the x86 architecture, the total size of all SMBIOS tables is limited to 65535\n    bytes. Thus the OEM strings data is not suitable for passing large amounts of data into the\n    guest. Instead it should be used as a indicator to inform the guest where to locate the real\n    data set, for example, by specifying the serial ID of a block device.\n\n    An example passing three strings is\n\n    .. parsed-literal::\n\n        -smbios type=11,value=cloud-init:ds=nocloud-net;s=http://10.10.0.1:8000/,\\\\\n                        value=anaconda:method=http://dl.fedoraproject.org/pub/fedora/linux/releases/25/x86_64/os,\\\\\n                        path=/some/file/with/oemstringsdata.txt\n\n    In the guest OS this is visible with the ``dmidecode`` command\n\n     .. parsed-literal::\n\n         $ dmidecode -t 11\n         Handle 0x0E00, DMI type 11, 5 bytes\n         OEM Strings\n              String 1: cloud-init:ds=nocloud-net;s=http://10.10.0.1:8000/\n              String 2: anaconda:method=http://dl.fedoraproject.org/pub/fedora/linux/releases/25/x86_64/os\n              String 3: myapp:some extra data\n\n\n``-smbios type=17[,loc_pfx=str][,bank=str][,manufacturer=str][,serial=str][,asset=str][,part=str][,speed=%d]``\n    Specify SMBIOS type 17 fields\n\n``-smbios type=41[,designation=str][,kind=str][,instance=%d][,pcidev=str]``\n    Specify SMBIOS type 41 fields\n\n    This argument can be repeated multiple times.  Its main use is to allow network interfaces be created\n    as ``enoX`` on Linux, with X being the instance number, instead of the name depending on the interface\n    position on the PCI bus.\n\n    Here is an example of use:\n\n    .. parsed-literal::\n\n        -netdev user,id=internet \\\\\n        -device virtio-net-pci,mac=50:54:00:00:00:42,netdev=internet,id=internet-dev \\\\\n        -smbios type=41,designation='Onboard LAN',instance=1,kind=ethernet,pcidev=internet-dev\n\n    In the guest OS, the device should then appear as ``eno1``:\n\n    ..parsed-literal::\n\n         $ ip -brief l\n         lo               UNKNOWN        00:00:00:00:00:00 <LOOPBACK,UP,LOWER_UP>\n         eno1             UP             50:54:00:00:00:42 <BROADCAST,MULTICAST,UP,LOWER_UP>\n\n    Currently, the PCI device has to be attached to the root bus.\n\nERST\n\nDEFHEADING()\n\nDEFHEADING(Network options:)\n\nDEF(\"netdev\", HAS_ARG, QEMU_OPTION_netdev,\n#ifdef CONFIG_SLIRP\n    \"-netdev user,id=str[,ipv4=on|off][,net=addr[/mask]][,host=addr]\\n\"\n    \"         [,ipv6=on|off][,ipv6-net=addr[/int]][,ipv6-host=addr]\\n\"\n    \"         [,restrict=on|off][,hostname=host][,dhcpstart=addr]\\n\"\n    \"         [,dns=addr][,ipv6-dns=addr][,dnssearch=domain][,domainname=domain]\\n\"\n    \"         [,tftp=dir][,tftp-server-name=name][,bootfile=f][,hostfwd=rule][,guestfwd=rule]\"\n#ifndef _WIN32\n                                             \"[,smb=dir[,smbserver=addr]]\\n\"\n#endif\n    \"                configure a user mode network backend with ID 'str',\\n\"\n    \"                its DHCP server and optional services\\n\"\n#endif\n#ifdef _WIN32\n    \"-netdev tap,id=str,ifname=name\\n\"\n    \"                configure a host TAP network backend with ID 'str'\\n\"\n#else\n    \"-netdev tap,id=str[,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile]\\n\"\n    \"         [,br=bridge][,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off]\\n\"\n    \"         [,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n]\\n\"\n    \"         [,poll-us=n]\\n\"\n    \"                configure a host TAP network backend with ID 'str'\\n\"\n    \"                connected to a bridge (default=\" DEFAULT_BRIDGE_INTERFACE \")\\n\"\n    \"                use network scripts 'file' (default=\" DEFAULT_NETWORK_SCRIPT \")\\n\"\n    \"                to configure it and 'dfile' (default=\" DEFAULT_NETWORK_DOWN_SCRIPT \")\\n\"\n    \"                to deconfigure it\\n\"\n    \"                use '[down]script=no' to disable script execution\\n\"\n    \"                use network helper 'helper' (default=\" DEFAULT_BRIDGE_HELPER \") to\\n\"\n    \"                configure it\\n\"\n    \"                use 'fd=h' to connect to an already opened TAP interface\\n\"\n    \"                use 'fds=x:y:...:z' to connect to already opened multiqueue capable TAP interfaces\\n\"\n    \"                use 'sndbuf=nbytes' to limit the size of the send buffer (the\\n\"\n    \"                default is disabled 'sndbuf=0' to enable flow control set 'sndbuf=1048576')\\n\"\n    \"                use vnet_hdr=off to avoid enabling the IFF_VNET_HDR tap flag\\n\"\n    \"                use vnet_hdr=on to make the lack of IFF_VNET_HDR support an error condition\\n\"\n    \"                use vhost=on to enable experimental in kernel accelerator\\n\"\n    \"                    (only has effect for virtio guests which use MSIX)\\n\"\n    \"                use vhostforce=on to force vhost on for non-MSIX virtio guests\\n\"\n    \"                use 'vhostfd=h' to connect to an already opened vhost net device\\n\"\n    \"                use 'vhostfds=x:y:...:z to connect to multiple already opened vhost net devices\\n\"\n    \"                use 'queues=n' to specify the number of queues to be created for multiqueue TAP\\n\"\n    \"                use 'poll-us=n' to specify the maximum number of microseconds that could be\\n\"\n    \"                spent on busy polling for vhost net\\n\"\n    \"-netdev bridge,id=str[,br=bridge][,helper=helper]\\n\"\n    \"                configure a host TAP network backend with ID 'str' that is\\n\"\n    \"                connected to a bridge (default=\" DEFAULT_BRIDGE_INTERFACE \")\\n\"\n    \"                using the program 'helper (default=\" DEFAULT_BRIDGE_HELPER \")\\n\"\n#endif\n#ifdef __linux__\n    \"-netdev l2tpv3,id=str,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport]\\n\"\n    \"         [,rxsession=rxsession],txsession=txsession[,ipv6=on|off][,udp=on|off]\\n\"\n    \"         [,cookie64=on|off][,counter][,pincounter][,txcookie=txcookie]\\n\"\n    \"         [,rxcookie=rxcookie][,offset=offset]\\n\"\n    \"                configure a network backend with ID 'str' connected to\\n\"\n    \"                an Ethernet over L2TPv3 pseudowire.\\n\"\n    \"                Linux kernel 3.3+ as well as most routers can talk\\n\"\n    \"                L2TPv3. This transport allows connecting a VM to a VM,\\n\"\n    \"                VM to a router and even VM to Host. It is a nearly-universal\\n\"\n    \"                standard (RFC3931). Note - this implementation uses static\\n\"\n    \"                pre-configured tunnels (same as the Linux kernel).\\n\"\n    \"                use 'src=' to specify source address\\n\"\n    \"                use 'dst=' to specify destination address\\n\"\n    \"                use 'udp=on' to specify udp encapsulation\\n\"\n    \"                use 'srcport=' to specify source udp port\\n\"\n    \"                use 'dstport=' to specify destination udp port\\n\"\n    \"                use 'ipv6=on' to force v6\\n\"\n    \"                L2TPv3 uses cookies to prevent misconfiguration as\\n\"\n    \"                well as a weak security measure\\n\"\n    \"                use 'rxcookie=0x012345678' to specify a rxcookie\\n\"\n    \"                use 'txcookie=0x012345678' to specify a txcookie\\n\"\n    \"                use 'cookie64=on' to set cookie size to 64 bit, otherwise 32\\n\"\n    \"                use 'counter=off' to force a 'cut-down' L2TPv3 with no counter\\n\"\n    \"                use 'pincounter=on' to work around broken counter handling in peer\\n\"\n    \"                use 'offset=X' to add an extra offset between header and data\\n\"\n#endif\n    \"-netdev socket,id=str[,fd=h][,listen=[host]:port][,connect=host:port]\\n\"\n    \"                configure a network backend to connect to another network\\n\"\n    \"                using a socket connection\\n\"\n    \"-netdev socket,id=str[,fd=h][,mcast=maddr:port[,localaddr=addr]]\\n\"\n    \"                configure a network backend to connect to a multicast maddr and port\\n\"\n    \"                use 'localaddr=addr' to specify the host address to send packets from\\n\"\n    \"-netdev socket,id=str[,fd=h][,udp=host:port][,localaddr=host:port]\\n\"\n    \"                configure a network backend to connect to another network\\n\"\n    \"                using an UDP tunnel\\n\"\n#ifdef CONFIG_VDE\n    \"-netdev vde,id=str[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]\\n\"\n    \"                configure a network backend to connect to port 'n' of a vde switch\\n\"\n    \"                running on host and listening for incoming connections on 'socketpath'.\\n\"\n    \"                Use group 'groupname' and mode 'octalmode' to change default\\n\"\n    \"                ownership and permissions for communication port.\\n\"\n#endif\n#ifdef CONFIG_NETMAP\n    \"-netdev netmap,id=str,ifname=name[,devname=nmname]\\n\"\n    \"                attach to the existing netmap-enabled network interface 'name', or to a\\n\"\n    \"                VALE port (created on the fly) called 'name' ('nmname' is name of the \\n\"\n    \"                netmap device, defaults to '/dev/netmap')\\n\"\n#endif\n#ifdef CONFIG_POSIX\n    \"-netdev vhost-user,id=str,chardev=dev[,vhostforce=on|off]\\n\"\n    \"                configure a vhost-user network, backed by a chardev 'dev'\\n\"\n#endif\n#ifdef __linux__\n    \"-netdev vhost-vdpa,id=str,vhostdev=/path/to/dev\\n\"\n    \"                configure a vhost-vdpa network,Establish a vhost-vdpa netdev\\n\"\n#endif\n#ifdef CONFIG_VMNET\n    \"-netdev vmnet-host,id=str[,isolated=on|off][,net-uuid=uuid]\\n\"\n    \"         [,start-address=addr,end-address=addr,subnet-mask=mask]\\n\"\n    \"                configure a vmnet network backend in host mode with ID 'str',\\n\"\n    \"                isolate this interface from others with 'isolated',\\n\"\n    \"                configure the address range and choose a subnet mask,\\n\"\n    \"                specify network UUID 'uuid' to disable DHCP and interact with\\n\"\n    \"                vmnet-host interfaces within this isolated network\\n\"\n    \"-netdev vmnet-shared,id=str[,isolated=on|off][,nat66-prefix=addr]\\n\"\n    \"         [,start-address=addr,end-address=addr,subnet-mask=mask]\\n\"\n    \"                configure a vmnet network backend in shared mode with ID 'str',\\n\"\n    \"                configure the address range and choose a subnet mask,\\n\"\n    \"                set IPv6 ULA prefix (of length 64) to use for internal network,\\n\"\n    \"                isolate this interface from others with 'isolated'\\n\"\n    \"-netdev vmnet-bridged,id=str,ifname=name[,isolated=on|off]\\n\"\n    \"                configure a vmnet network backend in bridged mode with ID 'str',\\n\"\n    \"                use 'ifname=name' to select a physical network interface to be bridged,\\n\"\n    \"                isolate this interface from others with 'isolated'\\n\"\n#endif\n    \"-netdev hubport,id=str,hubid=n[,netdev=nd]\\n\"\n    \"                configure a hub port on the hub with ID 'n'\\n\", QEMU_ARCH_ALL)\nDEF(\"nic\", HAS_ARG, QEMU_OPTION_nic,\n    \"-nic [tap|bridge|\"\n#ifdef CONFIG_SLIRP\n    \"user|\"\n#endif\n#ifdef __linux__\n    \"l2tpv3|\"\n#endif\n#ifdef CONFIG_VDE\n    \"vde|\"\n#endif\n#ifdef CONFIG_NETMAP\n    \"netmap|\"\n#endif\n#ifdef CONFIG_POSIX\n    \"vhost-user|\"\n#endif\n#ifdef CONFIG_VMNET\n    \"vmnet-host|vmnet-shared|vmnet-bridged|\"\n#endif\n    \"socket][,option][,...][mac=macaddr]\\n\"\n    \"                initialize an on-board / default host NIC (using MAC address\\n\"\n    \"                macaddr) and connect it to the given host network backend\\n\"\n    \"-nic none       use it alone to have zero network devices (the default is to\\n\"\n    \"                provided a 'user' network connection)\\n\",\n    QEMU_ARCH_ALL)\nDEF(\"net\", HAS_ARG, QEMU_OPTION_net,\n    \"-net nic[,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]\\n\"\n    \"                configure or create an on-board (or machine default) NIC and\\n\"\n    \"                connect it to hub 0 (please use -nic unless you need a hub)\\n\"\n    \"-net [\"\n#ifdef CONFIG_SLIRP\n    \"user|\"\n#endif\n    \"tap|\"\n    \"bridge|\"\n#ifdef CONFIG_VDE\n    \"vde|\"\n#endif\n#ifdef CONFIG_NETMAP\n    \"netmap|\"\n#endif\n#ifdef CONFIG_VMNET\n    \"vmnet-host|vmnet-shared|vmnet-bridged|\"\n#endif\n    \"socket][,option][,option][,...]\\n\"\n    \"                old way to initialize a host network interface\\n\"\n    \"                (use the -netdev option if possible instead)\\n\", QEMU_ARCH_ALL)\nSRST\n``-nic [tap|bridge|user|l2tpv3|vde|netmap|vhost-user|socket][,...][,mac=macaddr][,model=mn]``\n    This option is a shortcut for configuring both the on-board\n    (default) guest NIC hardware and the host network backend in one go.\n    The host backend options are the same as with the corresponding\n    ``-netdev`` options below. The guest NIC model can be set with\n    ``model=modelname``. Use ``model=help`` to list the available device\n    types. The hardware MAC address can be set with ``mac=macaddr``.\n\n    The following two example do exactly the same, to show how ``-nic``\n    can be used to shorten the command line length:\n\n    .. parsed-literal::\n\n        |qemu_system| -netdev user,id=n1,ipv6=off -device e1000,netdev=n1,mac=52:54:98:76:54:32\n        |qemu_system| -nic user,ipv6=off,model=e1000,mac=52:54:98:76:54:32\n\n``-nic none``\n    Indicate that no network devices should be configured. It is used to\n    override the default configuration (default NIC with \"user\" host\n    network backend) which is activated if no other networking options\n    are provided.\n\n``-netdev user,id=id[,option][,option][,...]``\n    Configure user mode host network backend which requires no\n    administrator privilege to run. Valid options are:\n\n    ``id=id``\n        Assign symbolic name for use in monitor commands.\n\n    ``ipv4=on|off and ipv6=on|off``\n        Specify that either IPv4 or IPv6 must be enabled. If neither is\n        specified both protocols are enabled.\n\n    ``net=addr[/mask]``\n        Set IP network address the guest will see. Optionally specify\n        the netmask, either in the form a.b.c.d or as number of valid\n        top-most bits. Default is 10.0.2.0/24.\n\n    ``host=addr``\n        Specify the guest-visible address of the host. Default is the\n        2nd IP in the guest network, i.e. x.x.x.2.\n\n    ``ipv6-net=addr[/int]``\n        Set IPv6 network address the guest will see (default is\n        fec0::/64). The network prefix is given in the usual hexadecimal\n        IPv6 address notation. The prefix size is optional, and is given\n        as the number of valid top-most bits (default is 64).\n\n    ``ipv6-host=addr``\n        Specify the guest-visible IPv6 address of the host. Default is\n        the 2nd IPv6 in the guest network, i.e. xxxx::2.\n\n    ``restrict=on|off``\n        If this option is enabled, the guest will be isolated, i.e. it\n        will not be able to contact the host and no guest IP packets\n        will be routed over the host to the outside. This option does\n        not affect any explicitly set forwarding rules.\n\n    ``hostname=name``\n        Specifies the client hostname reported by the built-in DHCP\n        server.\n\n    ``dhcpstart=addr``\n        Specify the first of the 16 IPs the built-in DHCP server can\n        assign. Default is the 15th to 31st IP in the guest network,\n        i.e. x.x.x.15 to x.x.x.31.\n\n    ``dns=addr``\n        Specify the guest-visible address of the virtual nameserver. The\n        address must be different from the host address. Default is the\n        3rd IP in the guest network, i.e. x.x.x.3.\n\n    ``ipv6-dns=addr``\n        Specify the guest-visible address of the IPv6 virtual\n        nameserver. The address must be different from the host address.\n        Default is the 3rd IP in the guest network, i.e. xxxx::3.\n\n    ``dnssearch=domain``\n        Provides an entry for the domain-search list sent by the\n        built-in DHCP server. More than one domain suffix can be\n        transmitted by specifying this option multiple times. If\n        supported, this will cause the guest to automatically try to\n        append the given domain suffix(es) in case a domain name can not\n        be resolved.\n\n        Example:\n\n        .. parsed-literal::\n\n            |qemu_system| -nic user,dnssearch=mgmt.example.org,dnssearch=example.org\n\n    ``domainname=domain``\n        Specifies the client domain name reported by the built-in DHCP\n        server.\n\n    ``tftp=dir``\n        When using the user mode network stack, activate a built-in TFTP\n        server. The files in dir will be exposed as the root of a TFTP\n        server. The TFTP client on the guest must be configured in\n        binary mode (use the command ``bin`` of the Unix TFTP client).\n\n    ``tftp-server-name=name``\n        In BOOTP reply, broadcast name as the \"TFTP server name\"\n        (RFC2132 option 66). This can be used to advise the guest to\n        load boot files or configurations from a different server than\n        the host address.\n\n    ``bootfile=file``\n        When using the user mode network stack, broadcast file as the\n        BOOTP filename. In conjunction with ``tftp``, this can be used\n        to network boot a guest from a local directory.\n\n        Example (using pxelinux):\n\n        .. parsed-literal::\n\n            |qemu_system| -hda linux.img -boot n -device e1000,netdev=n1 \\\\\n                -netdev user,id=n1,tftp=/path/to/tftp/files,bootfile=/pxelinux.0\n\n    ``smb=dir[,smbserver=addr]``\n        When using the user mode network stack, activate a built-in SMB\n        server so that Windows OSes can access to the host files in\n        ``dir`` transparently. The IP address of the SMB server can be\n        set to addr. By default the 4th IP in the guest network is used,\n        i.e. x.x.x.4.\n\n        In the guest Windows OS, the line:\n\n        ::\n\n            10.0.2.4 smbserver\n\n        must be added in the file ``C:\\WINDOWS\\LMHOSTS`` (for windows\n        9x/Me) or ``C:\\WINNT\\SYSTEM32\\DRIVERS\\ETC\\LMHOSTS`` (Windows\n        NT/2000).\n\n        Then ``dir`` can be accessed in ``\\\\smbserver\\qemu``.\n\n        Note that a SAMBA server must be installed on the host OS.\n\n    ``hostfwd=[tcp|udp]:[hostaddr]:hostport-[guestaddr]:guestport``\n        Redirect incoming TCP or UDP connections to the host port\n        hostport to the guest IP address guestaddr on guest port\n        guestport. If guestaddr is not specified, its value is x.x.x.15\n        (default first address given by the built-in DHCP server). By\n        specifying hostaddr, the rule can be bound to a specific host\n        interface. If no connection type is set, TCP is used. This\n        option can be given multiple times.\n\n        For example, to redirect host X11 connection from screen 1 to\n        guest screen 0, use the following:\n\n        .. parsed-literal::\n\n            # on the host\n            |qemu_system| -nic user,hostfwd=tcp:127.0.0.1:6001-:6000\n            # this host xterm should open in the guest X11 server\n            xterm -display :1\n\n        To redirect telnet connections from host port 5555 to telnet\n        port on the guest, use the following:\n\n        .. parsed-literal::\n\n            # on the host\n            |qemu_system| -nic user,hostfwd=tcp::5555-:23\n            telnet localhost 5555\n\n        Then when you use on the host ``telnet localhost 5555``, you\n        connect to the guest telnet server.\n\n    ``guestfwd=[tcp]:server:port-dev``; \\ ``guestfwd=[tcp]:server:port-cmd:command``\n        Forward guest TCP connections to the IP address server on port\n        port to the character device dev or to a program executed by\n        cmd:command which gets spawned for each connection. This option\n        can be given multiple times.\n\n        You can either use a chardev directly and have that one used\n        throughout QEMU's lifetime, like in the following example:\n\n        .. parsed-literal::\n\n            # open 10.10.1.1:4321 on bootup, connect 10.0.2.100:1234 to it whenever\n            # the guest accesses it\n            |qemu_system| -nic user,guestfwd=tcp:10.0.2.100:1234-tcp:10.10.1.1:4321\n\n        Or you can execute a command on every TCP connection established\n        by the guest, so that QEMU behaves similar to an inetd process\n        for that virtual server:\n\n        .. parsed-literal::\n\n            # call \"netcat 10.10.1.1 4321\" on every TCP connection to 10.0.2.100:1234\n            # and connect the TCP stream to its stdin/stdout\n            |qemu_system| -nic  'user,id=n1,guestfwd=tcp:10.0.2.100:1234-cmd:netcat 10.10.1.1 4321'\n\n``-netdev tap,id=id[,fd=h][,ifname=name][,script=file][,downscript=dfile][,br=bridge][,helper=helper]``\n    Configure a host TAP network backend with ID id.\n\n    Use the network script file to configure it and the network script\n    dfile to deconfigure it. If name is not provided, the OS\n    automatically provides one. The default network configure script is\n    ``/etc/qemu-ifup`` and the default network deconfigure script is\n    ``/etc/qemu-ifdown``. Use ``script=no`` or ``downscript=no`` to\n    disable script execution.\n\n    If running QEMU as an unprivileged user, use the network helper\n    to configure the TAP interface and attach it to the bridge.\n    The default network helper executable is\n    ``/path/to/qemu-bridge-helper`` and the default bridge device is\n    ``br0``.\n\n    ``fd``\\ =h can be used to specify the handle of an already opened\n    host TAP interface.\n\n    Examples:\n\n    .. parsed-literal::\n\n        #launch a QEMU instance with the default network script\n        |qemu_system| linux.img -nic tap\n\n    .. parsed-literal::\n\n        #launch a QEMU instance with two NICs, each one connected\n        #to a TAP device\n        |qemu_system| linux.img \\\\\n                -netdev tap,id=nd0,ifname=tap0 -device e1000,netdev=nd0 \\\\\n                -netdev tap,id=nd1,ifname=tap1 -device rtl8139,netdev=nd1\n\n    .. parsed-literal::\n\n        #launch a QEMU instance with the default network helper to\n        #connect a TAP device to bridge br0\n        |qemu_system| linux.img -device virtio-net-pci,netdev=n1 \\\\\n                -netdev tap,id=n1,\"helper=/path/to/qemu-bridge-helper\"\n\n``-netdev bridge,id=id[,br=bridge][,helper=helper]``\n    Connect a host TAP network interface to a host bridge device.\n\n    Use the network helper helper to configure the TAP interface and\n    attach it to the bridge. The default network helper executable is\n    ``/path/to/qemu-bridge-helper`` and the default bridge device is\n    ``br0``.\n\n    Examples:\n\n    .. parsed-literal::\n\n        #launch a QEMU instance with the default network helper to\n        #connect a TAP device to bridge br0\n        |qemu_system| linux.img -netdev bridge,id=n1 -device virtio-net,netdev=n1\n\n    .. parsed-literal::\n\n        #launch a QEMU instance with the default network helper to\n        #connect a TAP device to bridge qemubr0\n        |qemu_system| linux.img -netdev bridge,br=qemubr0,id=n1 -device virtio-net,netdev=n1\n\n``-netdev socket,id=id[,fd=h][,listen=[host]:port][,connect=host:port]``\n    This host network backend can be used to connect the guest's network\n    to another QEMU virtual machine using a TCP socket connection. If\n    ``listen`` is specified, QEMU waits for incoming connections on port\n    (host is optional). ``connect`` is used to connect to another QEMU\n    instance using the ``listen`` option. ``fd``\\ =h specifies an\n    already opened TCP socket.\n\n    Example:\n\n    .. parsed-literal::\n\n        # launch a first QEMU instance\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n1,mac=52:54:00:12:34:56 \\\\\n                         -netdev socket,id=n1,listen=:1234\n        # connect the network of this instance to the network of the first instance\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n2,mac=52:54:00:12:34:57 \\\\\n                         -netdev socket,id=n2,connect=127.0.0.1:1234\n\n``-netdev socket,id=id[,fd=h][,mcast=maddr:port[,localaddr=addr]]``\n    Configure a socket host network backend to share the guest's network\n    traffic with another QEMU virtual machines using a UDP multicast\n    socket, effectively making a bus for every QEMU with same multicast\n    address maddr and port. NOTES:\n\n    1. Several QEMU can be running on different hosts and share same bus\n       (assuming correct multicast setup for these hosts).\n\n    2. mcast support is compatible with User Mode Linux (argument\n       ``ethN=mcast``), see http://user-mode-linux.sf.net.\n\n    3. Use ``fd=h`` to specify an already opened UDP multicast socket.\n\n    Example:\n\n    .. parsed-literal::\n\n        # launch one QEMU instance\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n1,mac=52:54:00:12:34:56 \\\\\n                         -netdev socket,id=n1,mcast=230.0.0.1:1234\n        # launch another QEMU instance on same \"bus\"\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n2,mac=52:54:00:12:34:57 \\\\\n                         -netdev socket,id=n2,mcast=230.0.0.1:1234\n        # launch yet another QEMU instance on same \"bus\"\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n3,mac=52:54:00:12:34:58 \\\\\n                         -netdev socket,id=n3,mcast=230.0.0.1:1234\n\n    Example (User Mode Linux compat.):\n\n    .. parsed-literal::\n\n        # launch QEMU instance (note mcast address selected is UML's default)\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n1,mac=52:54:00:12:34:56 \\\\\n                         -netdev socket,id=n1,mcast=239.192.168.1:1102\n        # launch UML\n        /path/to/linux ubd0=/path/to/root_fs eth0=mcast\n\n    Example (send packets from host's 1.2.3.4):\n\n    .. parsed-literal::\n\n        |qemu_system| linux.img \\\\\n                         -device e1000,netdev=n1,mac=52:54:00:12:34:56 \\\\\n                         -netdev socket,id=n1,mcast=239.192.168.1:1102,localaddr=1.2.3.4\n\n``-netdev l2tpv3,id=id,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport],txsession=txsession[,rxsession=rxsession][,ipv6=on|off][,udp=on|off][,cookie64][,counter][,pincounter][,txcookie=txcookie][,rxcookie=rxcookie][,offset=offset]``\n    Configure a L2TPv3 pseudowire host network backend. L2TPv3 (RFC3931)\n    is a popular protocol to transport Ethernet (and other Layer 2) data\n    frames between two systems. It is present in routers, firewalls and\n    the Linux kernel (from version 3.3 onwards).\n\n    This transport allows a VM to communicate to another VM, router or\n    firewall directly.\n\n    ``src=srcaddr``\n        source address (mandatory)\n\n    ``dst=dstaddr``\n        destination address (mandatory)\n\n    ``udp``\n        select udp encapsulation (default is ip).\n\n    ``srcport=srcport``\n        source udp port.\n\n    ``dstport=dstport``\n        destination udp port.\n\n    ``ipv6``\n        force v6, otherwise defaults to v4.\n\n    ``rxcookie=rxcookie``; \\ ``txcookie=txcookie``\n        Cookies are a weak form of security in the l2tpv3 specification.\n        Their function is mostly to prevent misconfiguration. By default\n        they are 32 bit.\n\n    ``cookie64``\n        Set cookie size to 64 bit instead of the default 32\n\n    ``counter=off``\n        Force a 'cut-down' L2TPv3 with no counter as in\n        draft-mkonstan-l2tpext-keyed-ipv6-tunnel-00\n\n    ``pincounter=on``\n        Work around broken counter handling in peer. This may also help\n        on networks which have packet reorder.\n\n    ``offset=offset``\n        Add an extra offset between header and data\n\n    For example, to attach a VM running on host 4.3.2.1 via L2TPv3 to\n    the bridge br-lan on the remote Linux host 1.2.3.4:\n\n    .. parsed-literal::\n\n        # Setup tunnel on linux host using raw ip as encapsulation\n        # on 1.2.3.4\n        ip l2tp add tunnel remote 4.3.2.1 local 1.2.3.4 tunnel_id 1 peer_tunnel_id 1 \\\\\n            encap udp udp_sport 16384 udp_dport 16384\n        ip l2tp add session tunnel_id 1 name vmtunnel0 session_id \\\\\n            0xFFFFFFFF peer_session_id 0xFFFFFFFF\n        ifconfig vmtunnel0 mtu 1500\n        ifconfig vmtunnel0 up\n        brctl addif br-lan vmtunnel0\n\n\n        # on 4.3.2.1\n        # launch QEMU instance - if your network has reorder or is very lossy add ,pincounter\n\n        |qemu_system| linux.img -device e1000,netdev=n1 \\\\\n            -netdev l2tpv3,id=n1,src=4.2.3.1,dst=1.2.3.4,udp,srcport=16384,dstport=16384,rxsession=0xffffffff,txsession=0xffffffff,counter\n\n``-netdev vde,id=id[,sock=socketpath][,port=n][,group=groupname][,mode=octalmode]``\n    Configure VDE backend to connect to PORT n of a vde switch running\n    on host and listening for incoming connections on socketpath. Use\n    GROUP groupname and MODE octalmode to change default ownership and\n    permissions for communication port. This option is only available if\n    QEMU has been compiled with vde support enabled.\n\n    Example:\n\n    .. parsed-literal::\n\n        # launch vde switch\n        vde_switch -F -sock /tmp/myswitch\n        # launch QEMU instance\n        |qemu_system| linux.img -nic vde,sock=/tmp/myswitch\n\n``-netdev vhost-user,chardev=id[,vhostforce=on|off][,queues=n]``\n    Establish a vhost-user netdev, backed by a chardev id. The chardev\n    should be a unix domain socket backed one. The vhost-user uses a\n    specifically defined protocol to pass vhost ioctl replacement\n    messages to an application on the other end of the socket. On\n    non-MSIX guests, the feature can be forced with vhostforce. Use\n    'queues=n' to specify the number of queues to be created for\n    multiqueue vhost-user.\n\n    Example:\n\n    ::\n\n        qemu -m 512 -object memory-backend-file,id=mem,size=512M,mem-path=/hugetlbfs,share=on \\\n             -numa node,memdev=mem \\\n             -chardev socket,id=chr0,path=/path/to/socket \\\n             -netdev type=vhost-user,id=net0,chardev=chr0 \\\n             -device virtio-net-pci,netdev=net0\n\n``-netdev vhost-vdpa,vhostdev=/path/to/dev``\n    Establish a vhost-vdpa netdev.\n\n    vDPA device is a device that uses a datapath which complies with\n    the virtio specifications with a vendor specific control path.\n    vDPA devices can be both physically located on the hardware or\n    emulated by software.\n\n``-netdev hubport,id=id,hubid=hubid[,netdev=nd]``\n    Create a hub port on the emulated hub with ID hubid.\n\n    The hubport netdev lets you connect a NIC to a QEMU emulated hub\n    instead of a single netdev. Alternatively, you can also connect the\n    hubport to another netdev with ID nd by using the ``netdev=nd``\n    option.\n\n``-net nic[,netdev=nd][,macaddr=mac][,model=type] [,name=name][,addr=addr][,vectors=v]``\n    Legacy option to configure or create an on-board (or machine\n    default) Network Interface Card(NIC) and connect it either to the\n    emulated hub with ID 0 (i.e. the default hub), or to the netdev nd.\n    If model is omitted, then the default NIC model associated with the\n    machine type is used. Note that the default NIC model may change in\n    future QEMU releases, so it is highly recommended to always specify\n    a model. Optionally, the MAC address can be changed to mac, the\n    device address set to addr (PCI cards only), and a name can be\n    assigned for use in monitor commands. Optionally, for PCI cards, you\n    can specify the number v of MSI-X vectors that the card should have;\n    this option currently only affects virtio cards; set v = 0 to\n    disable MSI-X. If no ``-net`` option is specified, a single NIC is\n    created. QEMU can emulate several different models of network card.\n    Use ``-net nic,model=help`` for a list of available devices for your\n    target.\n\n``-net user|tap|bridge|socket|l2tpv3|vde[,...][,name=name]``\n    Configure a host network backend (with the options corresponding to\n    the same ``-netdev`` option) and connect it to the emulated hub 0\n    (the default hub). Use name to specify the name of the hub port.\nERST\n\nDEFHEADING()\n\nDEFHEADING(Character device options:)\n\nDEF(\"chardev\", HAS_ARG, QEMU_OPTION_chardev,\n    \"-chardev help\\n\"\n    \"-chardev null,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev socket,id=id[,host=host],port=port[,to=to][,ipv4=on|off][,ipv6=on|off][,nodelay=on|off]\\n\"\n    \"         [,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect=seconds][,mux=on|off]\\n\"\n    \"         [,logfile=PATH][,logappend=on|off][,tls-creds=ID][,tls-authz=ID] (tcp)\\n\"\n    \"-chardev socket,id=id,path=path[,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect=seconds]\\n\"\n    \"         [,mux=on|off][,logfile=PATH][,logappend=on|off][,abstract=on|off][,tight=on|off] (unix)\\n\"\n    \"-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr]\\n\"\n    \"         [,localport=localport][,ipv4=on|off][,ipv6=on|off][,mux=on|off]\\n\"\n    \"         [,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev msmouse,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]\\n\"\n    \"         [,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev ringbuf,id=id[,size=size][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev file,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev pipe,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#ifdef _WIN32\n    \"-chardev console,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#else\n    \"-chardev pty,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev stdio,id=id[,mux=on|off][,signal=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#ifdef CONFIG_BRLAPI\n    \"-chardev braille,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#if defined(__linux__) || defined(__sun__) || defined(__FreeBSD__) \\\n        || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)\n    \"-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev tty,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#if defined(__linux__) || defined(__FreeBSD__) || defined(__DragonFly__)\n    \"-chardev parallel,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev parport,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n#if defined(CONFIG_SPICE)\n    \"-chardev spicevmc,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]\\n\"\n    \"-chardev spiceport,id=id,name=name[,debug=debug][,logfile=PATH][,logappend=on|off]\\n\"\n#endif\n    , QEMU_ARCH_ALL\n)\n\nSRST\nThe general form of a character device option is:\n\n``-chardev backend,id=id[,mux=on|off][,options]``\n    Backend is one of: ``null``, ``socket``, ``udp``, ``msmouse``,\n    ``vc``, ``ringbuf``, ``file``, ``pipe``, ``console``, ``serial``,\n    ``pty``, ``stdio``, ``braille``, ``tty``, ``parallel``, ``parport``,\n    ``spicevmc``, ``spiceport``. The specific backend will determine the\n    applicable options.\n\n    Use ``-chardev help`` to print all available chardev backend types.\n\n    All devices must have an id, which can be any string up to 127\n    characters long. It is used to uniquely identify this device in\n    other command line directives.\n\n    A character device may be used in multiplexing mode by multiple\n    front-ends. Specify ``mux=on`` to enable this mode. A multiplexer is\n    a \"1:N\" device, and here the \"1\" end is your specified chardev\n    backend, and the \"N\" end is the various parts of QEMU that can talk\n    to a chardev. If you create a chardev with ``id=myid`` and\n    ``mux=on``, QEMU will create a multiplexer with your specified ID,\n    and you can then configure multiple front ends to use that chardev\n    ID for their input/output. Up to four different front ends can be\n    connected to a single multiplexed chardev. (Without multiplexing\n    enabled, a chardev can only be used by a single front end.) For\n    instance you could use this to allow a single stdio chardev to be\n    used by two serial ports and the QEMU monitor:\n\n    ::\n\n        -chardev stdio,mux=on,id=char0 \\\n        -mon chardev=char0,mode=readline \\\n        -serial chardev:char0 \\\n        -serial chardev:char0\n\n    You can have more than one multiplexer in a system configuration;\n    for instance you could have a TCP port multiplexed between UART 0\n    and UART 1, and stdio multiplexed between the QEMU monitor and a\n    parallel port:\n\n    ::\n\n        -chardev stdio,mux=on,id=char0 \\\n        -mon chardev=char0,mode=readline \\\n        -parallel chardev:char0 \\\n        -chardev tcp,...,mux=on,id=char1 \\\n        -serial chardev:char1 \\\n        -serial chardev:char1\n\n    When you're using a multiplexed character device, some escape\n    sequences are interpreted in the input. See the chapter about\n    :ref:`keys in the character backend multiplexer` in the\n    System Emulation Users Guide for more details.\n\n    Note that some other command line options may implicitly create\n    multiplexed character backends; for instance ``-serial mon:stdio``\n    creates a multiplexed stdio backend connected to the serial port and\n    the QEMU monitor, and ``-nographic`` also multiplexes the console\n    and the monitor to stdio.\n\n    There is currently no support for multiplexing in the other\n    direction (where a single QEMU front end takes input and output from\n    multiple chardevs).\n\n    Every backend supports the ``logfile`` option, which supplies the\n    path to a file to record all data transmitted via the backend. The\n    ``logappend`` option controls whether the log file will be truncated\n    or appended to when opened.\n\nThe available backends are:\n\n``-chardev null,id=id``\n    A void device. This device will not emit any data, and will drop any\n    data it receives. The null backend does not take any options.\n\n``-chardev socket,id=id[,TCP options or unix options][,server=on|off][,wait=on|off][,telnet=on|off][,websocket=on|off][,reconnect=seconds][,tls-creds=id][,tls-authz=id]``\n    Create a two-way stream socket, which can be either a TCP or a unix\n    socket. A unix socket will be created if ``path`` is specified.\n    Behaviour is undefined if TCP options are specified for a unix\n    socket.\n\n    ``server=on|off`` specifies that the socket shall be a listening socket.\n\n    ``wait=on|off`` specifies that QEMU should not block waiting for a client\n    to connect to a listening socket.\n\n    ``telnet=on|off`` specifies that traffic on the socket should interpret\n    telnet escape sequences.\n\n    ``websocket=on|off`` specifies that the socket uses WebSocket protocol for\n    communication.\n\n    ``reconnect`` sets the timeout for reconnecting on non-server\n    sockets when the remote end goes away. qemu will delay this many\n    seconds and then attempt to reconnect. Zero disables reconnecting,\n    and is the default.\n\n    ``tls-creds`` requests enablement of the TLS protocol for\n    encryption, and specifies the id of the TLS credentials to use for\n    the handshake. The credentials must be previously created with the\n    ``-object tls-creds`` argument.\n\n    ``tls-auth`` provides the ID of the QAuthZ authorization object\n    against which the client's x509 distinguished name will be\n    validated. This object is only resolved at time of use, so can be\n    deleted and recreated on the fly while the chardev server is active.\n    If missing, it will default to denying access.\n\n    TCP and unix socket options are given below:\n\n    ``TCP options: port=port[,host=host][,to=to][,ipv4=on|off][,ipv6=on|off][,nodelay=on|off]``\n        ``host`` for a listening socket specifies the local address to\n        be bound. For a connecting socket species the remote host to\n        connect to. ``host`` is optional for listening sockets. If not\n        specified it defaults to ``0.0.0.0``.\n\n        ``port`` for a listening socket specifies the local port to be\n        bound. For a connecting socket specifies the port on the remote\n        host to connect to. ``port`` can be given as either a port\n        number or a service name. ``port`` is required.\n\n        ``to`` is only relevant to listening sockets. If it is\n        specified, and ``port`` cannot be bound, QEMU will attempt to\n        bind to subsequent ports up to and including ``to`` until it\n        succeeds. ``to`` must be specified as a port number.\n\n        ``ipv4=on|off`` and ``ipv6=on|off`` specify that either IPv4\n        or IPv6 must be used. If neither is specified the socket may\n        use either protocol.\n\n        ``nodelay=on|off`` disables the Nagle algorithm.\n\n    ``unix options: path=path[,abstract=on|off][,tight=on|off]``\n        ``path`` specifies the local path of the unix socket. ``path``\n        is required.\n        ``abstract=on|off`` specifies the use of the abstract socket namespace,\n        rather than the filesystem.  Optional, defaults to false.\n        ``tight=on|off`` sets the socket length of abstract sockets to their minimum,\n        rather than the full sun_path length.  Optional, defaults to true.\n\n``-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr][,localport=localport][,ipv4=on|off][,ipv6=on|off]``\n    Sends all traffic from the guest to a remote host over UDP.\n\n    ``host`` specifies the remote host to connect to. If not specified\n    it defaults to ``localhost``.\n\n    ``port`` specifies the port on the remote host to connect to.\n    ``port`` is required.\n\n    ``localaddr`` specifies the local address to bind to. If not\n    specified it defaults to ``0.0.0.0``.\n\n    ``localport`` specifies the local port to bind to. If not specified\n    any available local port will be used.\n\n    ``ipv4=on|off`` and ``ipv6=on|off`` specify that either IPv4 or IPv6 must be used.\n    If neither is specified the device may use either protocol.\n\n``-chardev msmouse,id=id``\n    Forward QEMU's emulated msmouse events to the guest. ``msmouse``\n    does not take any options.\n\n``-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]``\n    Connect to a QEMU text console. ``vc`` may optionally be given a\n    specific size.\n\n    ``width`` and ``height`` specify the width and height respectively\n    of the console, in pixels.\n\n    ``cols`` and ``rows`` specify that the console be sized to fit a\n    text console with the given dimensions.\n\n``-chardev ringbuf,id=id[,size=size]``\n    Create a ring buffer with fixed size ``size``. size must be a power\n    of two and defaults to ``64K``.\n\n``-chardev file,id=id,path=path``\n    Log all traffic received from the guest to a file.\n\n    ``path`` specifies the path of the file to be opened. This file will\n    be created if it does not already exist, and overwritten if it does.\n    ``path`` is required.\n\n``-chardev pipe,id=id,path=path``\n    Create a two-way connection to the guest. The behaviour differs\n    slightly between Windows hosts and other hosts:\n\n    On Windows, a single duplex pipe will be created at\n    ``\\\\.pipe\\path``.\n\n    On other hosts, 2 pipes will be created called ``path.in`` and\n    ``path.out``. Data written to ``path.in`` will be received by the\n    guest. Data written by the guest can be read from ``path.out``. QEMU\n    will not create these fifos, and requires them to be present.\n\n    ``path`` forms part of the pipe path as described above. ``path`` is\n    required.\n\n``-chardev console,id=id``\n    Send traffic from the guest to QEMU's standard output. ``console``\n    does not take any options.\n\n    ``console`` is only available on Windows hosts.\n\n``-chardev serial,id=id,path=path``\n    Send traffic from the guest to a serial device on the host.\n\n    On Unix hosts serial will actually accept any tty device, not only\n    serial lines.\n\n    ``path`` specifies the name of the serial device to open.\n\n``-chardev pty,id=id``\n    Create a new pseudo-terminal on the host and connect to it. ``pty``\n    does not take any options.\n\n    ``pty`` is not available on Windows hosts.\n\n``-chardev stdio,id=id[,signal=on|off]``\n    Connect to standard input and standard output of the QEMU process.\n\n    ``signal`` controls if signals are enabled on the terminal, that\n    includes exiting QEMU with the key sequence Control-c. This option\n    is enabled by default, use ``signal=off`` to disable it.\n\n``-chardev braille,id=id``\n    Connect to a local BrlAPI server. ``braille`` does not take any\n    options.\n\n``-chardev tty,id=id,path=path``\n    ``tty`` is only available on Linux, Sun, FreeBSD, NetBSD, OpenBSD\n    and DragonFlyBSD hosts. It is an alias for ``serial``.\n\n    ``path`` specifies the path to the tty. ``path`` is required.\n\n``-chardev parallel,id=id,path=path``\n  \\\n``-chardev parport,id=id,path=path``\n    ``parallel`` is only available on Linux, FreeBSD and DragonFlyBSD\n    hosts.\n\n    Connect to a local parallel port.\n\n    ``path`` specifies the path to the parallel port device. ``path`` is\n    required.\n\n``-chardev spicevmc,id=id,debug=debug,name=name``\n    ``spicevmc`` is only available when spice support is built in.\n\n    ``debug`` debug level for spicevmc\n\n    ``name`` name of spice channel to connect to\n\n    Connect to a spice virtual machine channel, such as vdiport.\n\n``-chardev spiceport,id=id,debug=debug,name=name``\n    ``spiceport`` is only available when spice support is built in.\n\n    ``debug`` debug level for spicevmc\n\n    ``name`` name of spice port to connect to\n\n    Connect to a spice port, allowing a Spice client to handle the\n    traffic identified by a name (preferably a fqdn).\nERST\n\nDEFHEADING()\n\n#ifdef CONFIG_TPM\nDEFHEADING(TPM device options:)\n\nDEF(\"tpmdev\", HAS_ARG, QEMU_OPTION_tpmdev, \\\n    \"-tpmdev passthrough,id=id[,path=path][,cancel-path=path]\\n\"\n    \"                use path to provide path to a character device; default is /dev/tpm0\\n\"\n    \"                use cancel-path to provide path to TPM's cancel sysfs entry; if\\n\"\n    \"                not provided it will be searched for in /sys/class/misc/tpm?/device\\n\"\n    \"-tpmdev emulator,id=id,chardev=dev\\n\"\n    \"                configure the TPM device using chardev backend\\n\",\n    QEMU_ARCH_ALL)\nSRST\nThe general form of a TPM device option is:\n\n``-tpmdev backend,id=id[,options]``\n    The specific backend type will determine the applicable options. The\n    ``-tpmdev`` option creates the TPM backend and requires a\n    ``-device`` option that specifies the TPM frontend interface model.\n\n    Use ``-tpmdev help`` to print all available TPM backend types.\n\nThe available backends are:\n\n``-tpmdev passthrough,id=id,path=path,cancel-path=cancel-path``\n    (Linux-host only) Enable access to the host's TPM using the\n    passthrough driver.\n\n    ``path`` specifies the path to the host's TPM device, i.e., on a\n    Linux host this would be ``/dev/tpm0``. ``path`` is optional and by\n    default ``/dev/tpm0`` is used.\n\n    ``cancel-path`` specifies the path to the host TPM device's sysfs\n    entry allowing for cancellation of an ongoing TPM command.\n    ``cancel-path`` is optional and by default QEMU will search for the\n    sysfs entry to use.\n\n    Some notes about using the host's TPM with the passthrough driver:\n\n    The TPM device accessed by the passthrough driver must not be used\n    by any other application on the host.\n\n    Since the host's firmware (BIOS/UEFI) has already initialized the\n    TPM, the VM's firmware (BIOS/UEFI) will not be able to initialize\n    the TPM again and may therefore not show a TPM-specific menu that\n    would otherwise allow the user to configure the TPM, e.g., allow the\n    user to enable/disable or activate/deactivate the TPM. Further, if\n    TPM ownership is released from within a VM then the host's TPM will\n    get disabled and deactivated. To enable and activate the TPM again\n    afterwards, the host has to be rebooted and the user is required to\n    enter the firmware's menu to enable and activate the TPM. If the TPM\n    is left disabled and/or deactivated most TPM commands will fail.\n\n    To create a passthrough TPM use the following two options:\n\n    ::\n\n        -tpmdev passthrough,id=tpm0 -device tpm-tis,tpmdev=tpm0\n\n    Note that the ``-tpmdev`` id is ``tpm0`` and is referenced by\n    ``tpmdev=tpm0`` in the device option.\n\n``-tpmdev emulator,id=id,chardev=dev``\n    (Linux-host only) Enable access to a TPM emulator using Unix domain\n    socket based chardev backend.\n\n    ``chardev`` specifies the unique ID of a character device backend\n    that provides connection to the software TPM server.\n\n    To create a TPM emulator backend device with chardev socket backend:\n\n    ::\n\n        -chardev socket,id=chrtpm,path=/tmp/swtpm-sock -tpmdev emulator,id=tpm0,chardev=chrtpm -device tpm-tis,tpmdev=tpm0\nERST\n\nDEFHEADING()\n\n#endif\n\nDEFHEADING(Boot Image or Kernel specific:)\nSRST\nThere are broadly 4 ways you can boot a system with QEMU.\n\n - specify a firmware and let it control finding a kernel\n - specify a firmware and pass a hint to the kernel to boot\n - direct kernel image boot\n - manually load files into the guest's address space\n\nThe third method is useful for quickly testing kernels but as there is\nno firmware to pass configuration information to the kernel the\nhardware must either be probeable, the kernel built for the exact\nconfiguration or passed some configuration data (e.g. a DTB blob)\nwhich tells the kernel what drivers it needs. This exact details are\noften hardware specific.\n\nThe final method is the most generic way of loading images into the\nguest address space and used mostly for ``bare metal`` type\ndevelopment where the reset vectors of the processor are taken into\naccount.\n\nERST\n\nSRST\n\nFor x86 machines and some other architectures ``-bios`` will generally\ndo the right thing with whatever it is given. For other machines the\nmore strict ``-pflash`` option needs an image that is sized for the\nflash device for the given machine type.\n\nPlease see the :ref:`system-targets-ref` section of the manual for\nmore detailed documentation.\n\nERST\n\nDEF(\"bios\", HAS_ARG, QEMU_OPTION_bios, \\\n    \"-bios file      set the filename for the BIOS\\n\", QEMU_ARCH_ALL)\nSRST\n``-bios file``\n    Set the filename for the BIOS.\nERST\n\nDEF(\"pflash\", HAS_ARG, QEMU_OPTION_pflash,\n    \"-pflash file    use 'file' as a parallel flash image\\n\", QEMU_ARCH_ALL)\nSRST\n``-pflash file``\n    Use file as a parallel flash image.\nERST\n\nSRST\n\nThe kernel options were designed to work with Linux kernels although\nother things (like hypervisors) can be packaged up as a kernel\nexecutable image. The exact format of a executable image is usually\narchitecture specific.\n\nThe way in which the kernel is started (what address it is loaded at,\nwhat if any information is passed to it via CPU registers, the state\nof the hardware when it is started, and so on) is also architecture\nspecific. Typically it follows the specification laid down by the\nLinux kernel for how kernels for that architecture must be started.\n\nERST\n\nDEF(\"kernel\", HAS_ARG, QEMU_OPTION_kernel, \\\n    \"-kernel bzImage use 'bzImage' as kernel image\\n\", QEMU_ARCH_ALL)\nSRST\n``-kernel bzImage``\n    Use bzImage as kernel image. The kernel can be either a Linux kernel\n    or in multiboot format.\nERST\n\nDEF(\"append\", HAS_ARG, QEMU_OPTION_append, \\\n    \"-append cmdline use 'cmdline' as kernel command line\\n\", QEMU_ARCH_ALL)\nSRST\n``-append cmdline``\n    Use cmdline as kernel command line\nERST\n\nDEF(\"initrd\", HAS_ARG, QEMU_OPTION_initrd, \\\n           \"-initrd file    use 'file' as initial ram disk\\n\", QEMU_ARCH_ALL)\nSRST\n``-initrd file``\n    Use file as initial ram disk.\n\n``-initrd \"file1 arg=foo,file2\"``\n    This syntax is only available with multiboot.\n\n    Use file1 and file2 as modules and pass arg=foo as parameter to the\n    first module.\nERST\n\nDEF(\"dtb\", HAS_ARG, QEMU_OPTION_dtb, \\\n    \"-dtb    file    use 'file' as device tree image\\n\", QEMU_ARCH_ALL)\nSRST\n``-dtb file``\n    Use file as a device tree binary (dtb) image and pass it to the\n    kernel on boot.\nERST\n\nSRST\n\nFinally you can also manually load images directly into the address\nspace of the guest. This is most useful for developers who already\nknow the layout of their guest and take care to ensure something sane\nwill happen when the reset vector executes.\n\nThe generic loader can be invoked by using the loader device:\n\n``-device loader,addr=<addr>,data=<data>,data-len=<data-len>[,data-be=<data-be>][,cpu-num=<cpu-num>]``\n\nthere is also the guest loader which operates in a similar way but\ntweaks the DTB so a hypervisor loaded via ``-kernel`` can find where\nthe guest image is:\n\n``-device guest-loader,addr=<addr>[,kernel=<path>,[bootargs=<arguments>]][,initrd=<path>]``\n\nERST\n\nDEFHEADING()\n\nDEFHEADING(Debug/Expert options:)\n\nDEF(\"compat\", HAS_ARG, QEMU_OPTION_compat,\n    \"-compat [deprecated-input=accept|reject|crash][,deprecated-output=accept|hide]\\n\"\n    \"                Policy for handling deprecated management interfaces\\n\"\n    \"-compat [unstable-input=accept|reject|crash][,unstable-output=accept|hide]\\n\"\n    \"                Policy for handling unstable management interfaces\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-compat [deprecated-input=@var{input-policy}][,deprecated-output=@var{output-policy}]``\n    Set policy for handling deprecated management interfaces (experimental):\n\n    ``deprecated-input=accept`` (default)\n        Accept deprecated commands and arguments\n    ``deprecated-input=reject``\n        Reject deprecated commands and arguments\n    ``deprecated-input=crash``\n        Crash on deprecated commands and arguments\n    ``deprecated-output=accept`` (default)\n        Emit deprecated command results and events\n    ``deprecated-output=hide``\n        Suppress deprecated command results and events\n\n    Limitation: covers only syntactic aspects of QMP.\n\n``-compat [unstable-input=@var{input-policy}][,unstable-output=@var{output-policy}]``\n    Set policy for handling unstable management interfaces (experimental):\n\n    ``unstable-input=accept`` (default)\n        Accept unstable commands and arguments\n    ``unstable-input=reject``\n        Reject unstable commands and arguments\n    ``unstable-input=crash``\n        Crash on unstable commands and arguments\n    ``unstable-output=accept`` (default)\n        Emit unstable command results and events\n    ``unstable-output=hide``\n        Suppress unstable command results and events\n\n    Limitation: covers only syntactic aspects of QMP.\nERST\n\nDEF(\"fw_cfg\", HAS_ARG, QEMU_OPTION_fwcfg,\n    \"-fw_cfg [name=]<name>,file=<file>\\n\"\n    \"                add named fw_cfg entry with contents from file\\n\"\n    \"-fw_cfg [name=]<name>,string=<str>\\n\"\n    \"                add named fw_cfg entry with contents from string\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-fw_cfg [name=]name,file=file``\n    Add named fw\\_cfg entry with contents from file file.\n\n``-fw_cfg [name=]name,string=str``\n    Add named fw\\_cfg entry with contents from string str.\n\n    The terminating NUL character of the contents of str will not be\n    included as part of the fw\\_cfg item data. To insert contents with\n    embedded NUL characters, you have to use the file parameter.\n\n    The fw\\_cfg entries are passed by QEMU through to the guest.\n\n    Example:\n\n    ::\n\n            -fw_cfg name=opt/com.mycompany/blob,file=./my_blob.bin\n\n    creates an fw\\_cfg entry named opt/com.mycompany/blob with contents\n    from ./my\\_blob.bin.\nERST\n\nDEF(\"serial\", HAS_ARG, QEMU_OPTION_serial, \\\n    \"-serial dev     redirect the serial port to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-serial dev``\n    Redirect the virtual serial port to host character device dev. The\n    default device is ``vc`` in graphical mode and ``stdio`` in non\n    graphical mode.\n\n    This option can be used several times to simulate up to 4 serial\n    ports.\n\n    Use ``-serial none`` to disable all serial ports.\n\n    Available character devices are:\n\n    ``vc[:WxH]``\n        Virtual console. Optionally, a width and height can be given in\n        pixel with\n\n        ::\n\n            vc:800x600\n\n        It is also possible to specify width or height in characters:\n\n        ::\n\n            vc:80Cx24C\n\n    ``pty``\n        [Linux only] Pseudo TTY (a new PTY is automatically allocated)\n\n    ``none``\n        No device is allocated.\n\n    ``null``\n        void device\n\n    ``chardev:id``\n        Use a named character device defined with the ``-chardev``\n        option.\n\n    ``/dev/XXX``\n        [Linux only] Use host tty, e.g. ``/dev/ttyS0``. The host serial\n        port parameters are set according to the emulated ones.\n\n    ``/dev/parportN``\n        [Linux only, parallel port only] Use host parallel port N.\n        Currently SPP and EPP parallel port features can be used.\n\n    ``file:filename``\n        Write output to filename. No character can be read.\n\n    ``stdio``\n        [Unix only] standard input/output\n\n    ``pipe:filename``\n        name pipe filename\n\n    ``COMn``\n        [Windows only] Use host serial port n\n\n    ``udp:[remote_host]:remote_port[@[src_ip]:src_port]``\n        This implements UDP Net Console. When remote\\_host or src\\_ip\n        are not specified they default to ``0.0.0.0``. When not using a\n        specified src\\_port a random port is automatically chosen.\n\n        If you just want a simple readonly console you can use\n        ``netcat`` or ``nc``, by starting QEMU with:\n        ``-serial udp::4555`` and nc as: ``nc -u -l -p 4555``. Any time\n        QEMU writes something to that port it will appear in the\n        netconsole session.\n\n        If you plan to send characters back via netconsole or you want\n        to stop and start QEMU a lot of times, you should have QEMU use\n        the same source port each time by using something like ``-serial\n        udp::4555@:4556`` to QEMU. Another approach is to use a patched\n        version of netcat which can listen to a TCP port and send and\n        receive characters via udp. If you have a patched version of\n        netcat which activates telnet remote echo and single char\n        transfer, then you can use the following options to set up a\n        netcat redirector to allow telnet on port 5555 to access the\n        QEMU port.\n\n        ``QEMU Options:``\n            -serial udp::4555@:4556\n\n        ``netcat options:``\n            -u -P 4555 -L 0.0.0.0:4556 -t -p 5555 -I -T\n\n        ``telnet options:``\n            localhost 5555\n\n    ``tcp:[host]:port[,server=on|off][,wait=on|off][,nodelay=on|off][,reconnect=seconds]``\n        The TCP Net Console has two modes of operation. It can send the\n        serial I/O to a location or wait for a connection from a\n        location. By default the TCP Net Console is sent to host at the\n        port. If you use the ``server=on`` option QEMU will wait for a client\n        socket application to connect to the port before continuing,\n        unless the ``wait=on|off`` option was specified. The ``nodelay=on|off``\n        option disables the Nagle buffering algorithm. The ``reconnect=on``\n        option only applies if ``server=no`` is set, if the connection goes\n        down it will attempt to reconnect at the given interval. If host\n        is omitted, 0.0.0.0 is assumed. Only one TCP connection at a\n        time is accepted. You can use ``telnet=on`` to connect to the\n        corresponding character device.\n\n        ``Example to send tcp console to 192.168.0.2 port 4444``\n            -serial tcp:192.168.0.2:4444\n\n        ``Example to listen and wait on port 4444 for connection``\n            -serial tcp::4444,server=on\n\n        ``Example to not wait and listen on ip 192.168.0.100 port 4444``\n            -serial tcp:192.168.0.100:4444,server=on,wait=off\n\n    ``telnet:host:port[,server=on|off][,wait=on|off][,nodelay=on|off]``\n        The telnet protocol is used instead of raw tcp sockets. The\n        options work the same as if you had specified ``-serial tcp``.\n        The difference is that the port acts like a telnet server or\n        client using telnet option negotiation. This will also allow you\n        to send the MAGIC\\_SYSRQ sequence if you use a telnet that\n        supports sending the break sequence. Typically in unix telnet\n        you do it with Control-] and then type \"send break\" followed by\n        pressing the enter key.\n\n    ``websocket:host:port,server=on[,wait=on|off][,nodelay=on|off]``\n        The WebSocket protocol is used instead of raw tcp socket. The\n        port acts as a WebSocket server. Client mode is not supported.\n\n    ``unix:path[,server=on|off][,wait=on|off][,reconnect=seconds]``\n        A unix domain socket is used instead of a tcp socket. The option\n        works the same as if you had specified ``-serial tcp`` except\n        the unix domain socket path is used for connections.\n\n    ``mon:dev_string``\n        This is a special option to allow the monitor to be multiplexed\n        onto another serial port. The monitor is accessed with key\n        sequence of Control-a and then pressing c. dev\\_string should be\n        any one of the serial devices specified above. An example to\n        multiplex the monitor onto a telnet server listening on port\n        4444 would be:\n\n        ``-serial mon:telnet::4444,server=on,wait=off``\n\n        When the monitor is multiplexed to stdio in this way, Ctrl+C\n        will not terminate QEMU any more but will be passed to the guest\n        instead.\n\n    ``braille``\n        Braille device. This will use BrlAPI to display the braille\n        output on a real or fake device.\n\n    ``msmouse``\n        Three button serial mouse. Configure the guest to use Microsoft\n        protocol.\nERST\n\nDEF(\"parallel\", HAS_ARG, QEMU_OPTION_parallel, \\\n    \"-parallel dev   redirect the parallel port to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-parallel dev``\n    Redirect the virtual parallel port to host device dev (same devices\n    as the serial port). On Linux hosts, ``/dev/parportN`` can be used\n    to use hardware devices connected on the corresponding host parallel\n    port.\n\n    This option can be used several times to simulate up to 3 parallel\n    ports.\n\n    Use ``-parallel none`` to disable all parallel ports.\nERST\n\nDEF(\"monitor\", HAS_ARG, QEMU_OPTION_monitor, \\\n    \"-monitor dev    redirect the monitor to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-monitor dev``\n    Redirect the monitor to host device dev (same devices as the serial\n    port). The default device is ``vc`` in graphical mode and ``stdio``\n    in non graphical mode. Use ``-monitor none`` to disable the default\n    monitor.\nERST\nDEF(\"qmp\", HAS_ARG, QEMU_OPTION_qmp, \\\n    \"-qmp dev        like -monitor but opens in 'control' mode\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-qmp dev``\n    Like -monitor but opens in 'control' mode.\nERST\nDEF(\"qmp-pretty\", HAS_ARG, QEMU_OPTION_qmp_pretty, \\\n    \"-qmp-pretty dev like -qmp but uses pretty JSON formatting\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-qmp-pretty dev``\n    Like -qmp but uses pretty JSON formatting.\nERST\n\nDEF(\"mon\", HAS_ARG, QEMU_OPTION_mon, \\\n    \"-mon [chardev=]name[,mode=readline|control][,pretty[=on|off]]\\n\", QEMU_ARCH_ALL)\nSRST\n``-mon [chardev=]name[,mode=readline|control][,pretty[=on|off]]``\n    Setup monitor on chardev name. ``mode=control`` configures \n    a QMP monitor (a JSON RPC-style protocol) and it is not the\n    same as HMP, the human monitor that has a \"(qemu)\" prompt.\n    ``pretty`` is only valid when ``mode=control``, \n    turning on JSON pretty printing to ease\n    human reading and debugging.\nERST\n\nDEF(\"debugcon\", HAS_ARG, QEMU_OPTION_debugcon, \\\n    \"-debugcon dev   redirect the debug console to char device 'dev'\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-debugcon dev``\n    Redirect the debug console to host device dev (same devices as the\n    serial port). The debug console is an I/O port which is typically\n    port 0xe9; writing to that I/O port sends output to this device. The\n    default device is ``vc`` in graphical mode and ``stdio`` in non\n    graphical mode.\nERST\n\nDEF(\"pidfile\", HAS_ARG, QEMU_OPTION_pidfile, \\\n    \"-pidfile file   write PID to 'file'\\n\", QEMU_ARCH_ALL)\nSRST\n``-pidfile file``\n    Store the QEMU process PID in file. It is useful if you launch QEMU\n    from a script.\nERST\n\nDEF(\"singlestep\", 0, QEMU_OPTION_singlestep, \\\n    \"-singlestep     always run in singlestep mode\\n\", QEMU_ARCH_ALL)\nSRST\n``-singlestep``\n    Run the emulation in single step mode.\nERST\n\nDEF(\"preconfig\", 0, QEMU_OPTION_preconfig, \\\n    \"--preconfig     pause QEMU before machine is initialized (experimental)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``--preconfig``\n    Pause QEMU for interactive configuration before the machine is\n    created, which allows querying and configuring properties that will\n    affect machine initialization. Use QMP command 'x-exit-preconfig' to\n    exit the preconfig state and move to the next state (i.e. run guest\n    if -S isn't used or pause the second time if -S is used). This\n    option is experimental.\nERST\n\nDEF(\"S\", 0, QEMU_OPTION_S, \\\n    \"-S              freeze CPU at startup (use 'c' to start execution)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-S``\n    Do not start CPU at startup (you must type 'c' in the monitor).\nERST\n\nDEF(\"overcommit\", HAS_ARG, QEMU_OPTION_overcommit,\n    \"-overcommit [mem-lock=on|off][cpu-pm=on|off]\\n\"\n    \"                run qemu with overcommit hints\\n\"\n    \"                mem-lock=on|off controls memory lock support (default: off)\\n\"\n    \"                cpu-pm=on|off controls cpu power management (default: off)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-overcommit mem-lock=on|off``\n  \\ \n``-overcommit cpu-pm=on|off``\n    Run qemu with hints about host resource overcommit. The default is\n    to assume that host overcommits all resources.\n\n    Locking qemu and guest memory can be enabled via ``mem-lock=on``\n    (disabled by default). This works when host memory is not\n    overcommitted and reduces the worst-case latency for guest.\n\n    Guest ability to manage power state of host cpus (increasing latency\n    for other processes on the same host cpu, but decreasing latency for\n    guest) can be enabled via ``cpu-pm=on`` (disabled by default). This\n    works best when host CPU is not overcommitted. When used, host\n    estimates of CPU cycle and power utilization will be incorrect, not\n    taking into account guest idle time.\nERST\n\nDEF(\"gdb\", HAS_ARG, QEMU_OPTION_gdb, \\\n    \"-gdb dev        accept gdb connection on 'dev'. (QEMU defaults to starting\\n\"\n    \"                the guest without waiting for gdb to connect; use -S too\\n\"\n    \"                if you want it to not start execution.)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-gdb dev``\n    Accept a gdb connection on device dev (see the :ref:`GDB usage` chapter\n    in the System Emulation Users Guide). Note that this option does not pause QEMU\n    execution -- if you want QEMU to not start the guest until you\n    connect with gdb and issue a ``continue`` command, you will need to\n    also pass the ``-S`` option to QEMU.\n\n    The most usual configuration is to listen on a local TCP socket::\n\n        -gdb tcp::3117\n\n    but you can specify other backends; UDP, pseudo TTY, or even stdio\n    are all reasonable use cases. For example, a stdio connection\n    allows you to start QEMU from within gdb and establish the\n    connection via a pipe:\n\n    .. parsed-literal::\n\n        (gdb) target remote | exec |qemu_system| -gdb stdio ...\nERST\n\nDEF(\"s\", 0, QEMU_OPTION_s, \\\n    \"-s              shorthand for -gdb tcp::\" DEFAULT_GDBSTUB_PORT \"\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-s``\n    Shorthand for -gdb tcp::1234, i.e. open a gdbserver on TCP port 1234\n    (see the :ref:`GDB usage` chapter in the System Emulation Users Guide).\nERST\n\nDEF(\"d\", HAS_ARG, QEMU_OPTION_d, \\\n    \"-d item1,...    enable logging of specified items (use '-d help' for a list of log items)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-d item1[,...]``\n    Enable logging of specified items. Use '-d help' for a list of log\n    items.\nERST\n\nDEF(\"D\", HAS_ARG, QEMU_OPTION_D, \\\n    \"-D logfile      output log to logfile (default stderr)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-D logfile``\n    Output log in logfile instead of to stderr\nERST\n\nDEF(\"dfilter\", HAS_ARG, QEMU_OPTION_DFILTER, \\\n    \"-dfilter range,..  filter debug output to range of addresses (useful for -d cpu,exec,etc..)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-dfilter range1[,...]``\n    Filter debug output to that relevant to a range of target addresses.\n    The filter spec can be either start+size, start-size or start..end\n    where start end and size are the addresses and sizes required. For\n    example:\n\n    ::\n\n            -dfilter 0x8000..0x8fff,0xffffffc000080000+0x200,0xffffffc000060000-0x1000\n\n    Will dump output for any code in the 0x1000 sized block starting at\n    0x8000 and the 0x200 sized block starting at 0xffffffc000080000 and\n    another 0x1000 sized block starting at 0xffffffc00005f000.\nERST\n\nDEF(\"seed\", HAS_ARG, QEMU_OPTION_seed, \\\n    \"-seed number       seed the pseudo-random number generator\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-seed number``\n    Force the guest to use a deterministic pseudo-random number\n    generator, seeded with number. This does not affect crypto routines\n    within the host.\nERST\n\nDEF(\"L\", HAS_ARG, QEMU_OPTION_L, \\\n    \"-L path         set the directory for the BIOS, VGA BIOS and keymaps\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-L  path``\n    Set the directory for the BIOS, VGA BIOS and keymaps.\n\n    To list all the data directories, use ``-L help``.\nERST\n\nDEF(\"enable-kvm\", 0, QEMU_OPTION_enable_kvm, \\\n    \"-enable-kvm     enable KVM full virtualization support\\n\",\n    QEMU_ARCH_ARM | QEMU_ARCH_I386 | QEMU_ARCH_MIPS | QEMU_ARCH_PPC |\n    QEMU_ARCH_RISCV | QEMU_ARCH_S390X)\nSRST\n``-enable-kvm``\n    Enable KVM full virtualization support. This option is only\n    available if KVM support is enabled when compiling.\nERST\n\nDEF(\"xen-domid\", HAS_ARG, QEMU_OPTION_xen_domid,\n    \"-xen-domid id   specify xen guest domain id\\n\",\n    QEMU_ARCH_ARM | QEMU_ARCH_I386)\nDEF(\"xen-attach\", 0, QEMU_OPTION_xen_attach,\n    \"-xen-attach     attach to existing xen domain\\n\"\n    \"                libxl will use this when starting QEMU\\n\",\n    QEMU_ARCH_ARM | QEMU_ARCH_I386)\nDEF(\"xen-domid-restrict\", 0, QEMU_OPTION_xen_domid_restrict,\n    \"-xen-domid-restrict     restrict set of available xen operations\\n\"\n    \"                        to specified domain id. (Does not affect\\n\"\n    \"                        xenpv machine type).\\n\",\n    QEMU_ARCH_ARM | QEMU_ARCH_I386)\nSRST\n``-xen-domid id``\n    Specify xen guest domain id (XEN only).\n\n``-xen-attach``\n    Attach to existing xen domain. libxl will use this when starting\n    QEMU (XEN only). Restrict set of available xen operations to\n    specified domain id (XEN only).\nERST\n\nDEF(\"no-reboot\", 0, QEMU_OPTION_no_reboot, \\\n    \"-no-reboot      exit instead of rebooting\\n\", QEMU_ARCH_ALL)\nSRST\n``-no-reboot``\n    Exit instead of rebooting.\nERST\n\nDEF(\"no-shutdown\", 0, QEMU_OPTION_no_shutdown, \\\n    \"-no-shutdown    stop before shutdown\\n\", QEMU_ARCH_ALL)\nSRST\n``-no-shutdown``\n    Don't exit QEMU on guest shutdown, but instead only stop the\n    emulation. This allows for instance switching to monitor to commit\n    changes to the disk image.\nERST\n\nDEF(\"action\", HAS_ARG, QEMU_OPTION_action,\n    \"-action reboot=reset|shutdown\\n\"\n    \"                   action when guest reboots [default=reset]\\n\"\n    \"-action shutdown=poweroff|pause\\n\"\n    \"                   action when guest shuts down [default=poweroff]\\n\"\n    \"-action panic=pause|shutdown|exit-failure|none\\n\"\n    \"                   action when guest panics [default=shutdown]\\n\"\n    \"-action watchdog=reset|shutdown|poweroff|inject-nmi|pause|debug|none\\n\"\n    \"                   action when watchdog fires [default=reset]\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-action event=action``\n    The action parameter serves to modify QEMU's default behavior when\n    certain guest events occur. It provides a generic method for specifying the\n    same behaviors that are modified by the ``-no-reboot`` and ``-no-shutdown``\n    parameters.\n\n    Examples:\n\n    ``-action panic=none``\n    ``-action reboot=shutdown,shutdown=pause``\n    ``-watchdog i6300esb -action watchdog=pause``\n\nERST\n\nDEF(\"loadvm\", HAS_ARG, QEMU_OPTION_loadvm, \\\n    \"-loadvm [tag|id]\\n\" \\\n    \"                start right away with a saved state (loadvm in monitor)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-loadvm file``\n    Start right away with a saved state (``loadvm`` in monitor)\nERST\n\n#ifndef _WIN32\nDEF(\"daemonize\", 0, QEMU_OPTION_daemonize, \\\n    \"-daemonize      daemonize QEMU after initializing\\n\", QEMU_ARCH_ALL)\n#endif\nSRST\n``-daemonize``\n    Daemonize the QEMU process after initialization. QEMU will not\n    detach from standard IO until it is ready to receive connections on\n    any of its devices. This option is a useful way for external\n    programs to launch QEMU without having to cope with initialization\n    race conditions.\nERST\n\nDEF(\"option-rom\", HAS_ARG, QEMU_OPTION_option_rom, \\\n    \"-option-rom rom load a file, rom, into the option ROM space\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-option-rom file``\n    Load the contents of file as an option ROM. This option is useful to\n    load things like EtherBoot.\nERST\n\nDEF(\"rtc\", HAS_ARG, QEMU_OPTION_rtc, \\\n    \"-rtc [base=utc|localtime|<datetime>][,clock=host|rt|vm][,driftfix=none|slew]\\n\" \\\n    \"                set the RTC base and clock, enable drift fix for clock ticks (x86 only)\\n\",\n    QEMU_ARCH_ALL)\n\nSRST\n``-rtc [base=utc|localtime|datetime][,clock=host|rt|vm][,driftfix=none|slew]``\n    Specify ``base`` as ``utc`` or ``localtime`` to let the RTC start at\n    the current UTC or local time, respectively. ``localtime`` is\n    required for correct date in MS-DOS or Windows. To start at a\n    specific point in time, provide datetime in the format\n    ``2006-06-17T16:01:21`` or ``2006-06-17``. The default base is UTC.\n\n    By default the RTC is driven by the host system time. This allows\n    using of the RTC as accurate reference clock inside the guest,\n    specifically if the host time is smoothly following an accurate\n    external reference clock, e.g. via NTP. If you want to isolate the\n    guest time from the host, you can set ``clock`` to ``rt`` instead,\n    which provides a host monotonic clock if host support it. To even\n    prevent the RTC from progressing during suspension, you can set\n    ``clock`` to ``vm`` (virtual clock). '\\ ``clock=vm``\\ ' is\n    recommended especially in icount mode in order to preserve\n    determinism; however, note that in icount mode the speed of the\n    virtual clock is variable and can in general differ from the host\n    clock.\n\n    Enable ``driftfix`` (i386 targets only) if you experience time drift\n    problems, specifically with Windows' ACPI HAL. This option will try\n    to figure out how many timer interrupts were not processed by the\n    Windows guest and will re-inject them.\nERST\n\nDEF(\"icount\", HAS_ARG, QEMU_OPTION_icount, \\\n    \"-icount [shift=N|auto][,align=on|off][,sleep=on|off][,rr=record|replay,rrfile=<filename>[,rrsnapshot=<snapshot>]]\\n\" \\\n    \"                enable virtual instruction counter with 2^N clock ticks per\\n\" \\\n    \"                instruction, enable aligning the host and virtual clocks\\n\" \\\n    \"                or disable real time cpu sleeping, and optionally enable\\n\" \\\n    \"                record-and-replay mode\\n\", QEMU_ARCH_ALL)\nSRST\n``-icount [shift=N|auto][,align=on|off][,sleep=on|off][,rr=record|replay,rrfile=filename[,rrsnapshot=snapshot]]``\n    Enable virtual instruction counter. The virtual cpu will execute one\n    instruction every 2^N ns of virtual time. If ``auto`` is specified\n    then the virtual cpu speed will be automatically adjusted to keep\n    virtual time within a few seconds of real time.\n\n    Note that while this option can give deterministic behavior, it does\n    not provide cycle accurate emulation. Modern CPUs contain\n    superscalar out of order cores with complex cache hierarchies. The\n    number of instructions executed often has little or no correlation\n    with actual performance.\n\n    When the virtual cpu is sleeping, the virtual time will advance at\n    default speed unless ``sleep=on`` is specified. With\n    ``sleep=on``, the virtual time will jump to the next timer\n    deadline instantly whenever the virtual cpu goes to sleep mode and\n    will not advance if no timer is enabled. This behavior gives\n    deterministic execution times from the guest point of view.\n    The default if icount is enabled is ``sleep=off``.\n    ``sleep=on`` cannot be used together with either ``shift=auto``\n    or ``align=on``.\n\n    ``align=on`` will activate the delay algorithm which will try to\n    synchronise the host clock and the virtual clock. The goal is to\n    have a guest running at the real frequency imposed by the shift\n    option. Whenever the guest clock is behind the host clock and if\n    ``align=on`` is specified then we print a message to the user to\n    inform about the delay. Currently this option does not work when\n    ``shift`` is ``auto``. Note: The sync algorithm will work for those\n    shift values for which the guest clock runs ahead of the host clock.\n    Typically this happens when the shift value is high (how high\n    depends on the host machine). The default if icount is enabled\n    is ``align=off``.\n\n    When the ``rr`` option is specified deterministic record/replay is\n    enabled. The ``rrfile=`` option must also be provided to\n    specify the path to the replay log. In record mode data is written\n    to this file, and in replay mode it is read back.\n    If the ``rrsnapshot`` option is given then it specifies a VM snapshot\n    name. In record mode, a new VM snapshot with the given name is created\n    at the start of execution recording. In replay mode this option\n    specifies the snapshot name used to load the initial VM state.\nERST\n\nDEF(\"watchdog\", HAS_ARG, QEMU_OPTION_watchdog, \\\n    \"-watchdog model\\n\" \\\n    \"                enable virtual hardware watchdog [default=none]\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-watchdog model``\n    Create a virtual hardware watchdog device. Once enabled (by a guest\n    action), the watchdog must be periodically polled by an agent inside\n    the guest or else the guest will be restarted. Choose a model for\n    which your guest has drivers.\n\n    The model is the model of hardware watchdog to emulate. Use\n    ``-watchdog help`` to list available hardware models. Only one\n    watchdog can be enabled for a guest.\n\n    The following models may be available:\n\n    ``ib700``\n        iBASE 700 is a very simple ISA watchdog with a single timer.\n\n    ``i6300esb``\n        Intel 6300ESB I/O controller hub is a much more featureful\n        PCI-based dual-timer watchdog.\n\n    ``diag288``\n        A virtual watchdog for s390x backed by the diagnose 288\n        hypercall (currently KVM only).\nERST\n\nDEF(\"watchdog-action\", HAS_ARG, QEMU_OPTION_watchdog_action, \\\n    \"-watchdog-action reset|shutdown|poweroff|inject-nmi|pause|debug|none\\n\" \\\n    \"                action when watchdog fires [default=reset]\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-watchdog-action action``\n    The action controls what QEMU will do when the watchdog timer\n    expires. The default is ``reset`` (forcefully reset the guest).\n    Other possible actions are: ``shutdown`` (attempt to gracefully\n    shutdown the guest), ``poweroff`` (forcefully poweroff the guest),\n    ``inject-nmi`` (inject a NMI into the guest), ``pause`` (pause the\n    guest), ``debug`` (print a debug message and continue), or ``none``\n    (do nothing).\n\n    Note that the ``shutdown`` action requires that the guest responds\n    to ACPI signals, which it may not be able to do in the sort of\n    situations where the watchdog would have expired, and thus\n    ``-watchdog-action shutdown`` is not recommended for production use.\n\n    Examples:\n\n    ``-watchdog i6300esb -watchdog-action pause``; \\ ``-watchdog ib700``\n\nERST\n\nDEF(\"echr\", HAS_ARG, QEMU_OPTION_echr, \\\n    \"-echr chr       set terminal escape character instead of ctrl-a\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-echr numeric_ascii_value``\n    Change the escape character used for switching to the monitor when\n    using monitor and serial sharing. The default is ``0x01`` when using\n    the ``-nographic`` option. ``0x01`` is equal to pressing\n    ``Control-a``. You can select a different character from the ascii\n    control keys where 1 through 26 map to Control-a through Control-z.\n    For instance you could use the either of the following to change the\n    escape character to Control-t.\n\n    ``-echr 0x14``; \\ ``-echr 20``\n\nERST\n\nDEF(\"incoming\", HAS_ARG, QEMU_OPTION_incoming, \\\n    \"-incoming tcp:[host]:port[,to=maxport][,ipv4=on|off][,ipv6=on|off]\\n\" \\\n    \"-incoming rdma:host:port[,ipv4=on|off][,ipv6=on|off]\\n\" \\\n    \"-incoming unix:socketpath\\n\" \\\n    \"                prepare for incoming migration, listen on\\n\" \\\n    \"                specified protocol and socket address\\n\" \\\n    \"-incoming fd:fd\\n\" \\\n    \"-incoming exec:cmdline\\n\" \\\n    \"                accept incoming migration on given file descriptor\\n\" \\\n    \"                or from given external command\\n\" \\\n    \"-incoming defer\\n\" \\\n    \"                wait for the URI to be specified via migrate_incoming\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-incoming tcp:[host]:port[,to=maxport][,ipv4=on|off][,ipv6=on|off]``\n  \\ \n``-incoming rdma:host:port[,ipv4=on|off][,ipv6=on|off]``\n    Prepare for incoming migration, listen on a given tcp port.\n\n``-incoming unix:socketpath``\n    Prepare for incoming migration, listen on a given unix socket.\n\n``-incoming fd:fd``\n    Accept incoming migration from a given filedescriptor.\n\n``-incoming exec:cmdline``\n    Accept incoming migration as an output from specified external\n    command.\n\n``-incoming defer``\n    Wait for the URI to be specified via migrate\\_incoming. The monitor\n    can be used to change settings (such as migration parameters) prior\n    to issuing the migrate\\_incoming to allow the migration to begin.\nERST\n\nDEF(\"only-migratable\", 0, QEMU_OPTION_only_migratable, \\\n    \"-only-migratable     allow only migratable devices\\n\", QEMU_ARCH_ALL)\nSRST\n``-only-migratable``\n    Only allow migratable devices. Devices will not be allowed to enter\n    an unmigratable state.\nERST\n\nDEF(\"nodefaults\", 0, QEMU_OPTION_nodefaults, \\\n    \"-nodefaults     don't create default devices\\n\", QEMU_ARCH_ALL)\nSRST\n``-nodefaults``\n    Don't create default devices. Normally, QEMU sets the default\n    devices like serial port, parallel port, virtual console, monitor\n    device, VGA adapter, floppy and CD-ROM drive and others. The\n    ``-nodefaults`` option will disable all those default devices.\nERST\n\n#ifndef _WIN32\nDEF(\"chroot\", HAS_ARG, QEMU_OPTION_chroot, \\\n    \"-chroot dir     chroot to dir just before starting the VM\\n\",\n    QEMU_ARCH_ALL)\n#endif\nSRST\n``-chroot dir``\n    Immediately before starting guest execution, chroot to the specified\n    directory. Especially useful in combination with -runas.\nERST\n\n#ifndef _WIN32\nDEF(\"runas\", HAS_ARG, QEMU_OPTION_runas, \\\n    \"-runas user     change to user id user just before starting the VM\\n\" \\\n    \"                user can be numeric uid:gid instead\\n\",\n    QEMU_ARCH_ALL)\n#endif\nSRST\n``-runas user``\n    Immediately before starting guest execution, drop root privileges,\n    switching to the specified user.\nERST\n\nDEF(\"prom-env\", HAS_ARG, QEMU_OPTION_prom_env,\n    \"-prom-env variable=value\\n\"\n    \"                set OpenBIOS nvram variables\\n\",\n    QEMU_ARCH_PPC | QEMU_ARCH_SPARC)\nSRST\n``-prom-env variable=value``\n    Set OpenBIOS nvram variable to given value (PPC, SPARC only).\n\n    ::\n\n        qemu-system-sparc -prom-env 'auto-boot?=false' \\\n         -prom-env 'boot-device=sd(0,2,0):d' -prom-env 'boot-args=linux single'\n\n    ::\n\n        qemu-system-ppc -prom-env 'auto-boot?=false' \\\n         -prom-env 'boot-device=hd:2,\\yaboot' \\\n         -prom-env 'boot-args=conf=hd:2,\\yaboot.conf'\nERST\nDEF(\"semihosting\", 0, QEMU_OPTION_semihosting,\n    \"-semihosting    semihosting mode\\n\",\n    QEMU_ARCH_ARM | QEMU_ARCH_M68K | QEMU_ARCH_XTENSA |\n    QEMU_ARCH_MIPS | QEMU_ARCH_NIOS2 | QEMU_ARCH_RISCV)\nSRST\n``-semihosting``\n    Enable semihosting mode (ARM, M68K, Xtensa, MIPS, Nios II, RISC-V only).\n\n    Note that this allows guest direct access to the host filesystem, so\n    should only be used with a trusted guest OS.\n\n    See the -semihosting-config option documentation for further\n    information about the facilities this enables.\nERST\nDEF(\"semihosting-config\", HAS_ARG, QEMU_OPTION_semihosting_config,\n    \"-semihosting-config [enable=on|off][,target=native|gdb|auto][,chardev=id][,arg=str[,...]]\\n\" \\\n    \"                semihosting configuration\\n\",\nQEMU_ARCH_ARM | QEMU_ARCH_M68K | QEMU_ARCH_XTENSA |\nQEMU_ARCH_MIPS | QEMU_ARCH_NIOS2 | QEMU_ARCH_RISCV)\nSRST\n``-semihosting-config [enable=on|off][,target=native|gdb|auto][,chardev=id][,arg=str[,...]]``\n    Enable and configure semihosting (ARM, M68K, Xtensa, MIPS, Nios II, RISC-V\n    only).\n\n    Note that this allows guest direct access to the host filesystem, so\n    should only be used with a trusted guest OS.\n\n    On Arm this implements the standard semihosting API, version 2.0.\n\n    On M68K this implements the \"ColdFire GDB\" interface used by\n    libgloss.\n\n    Xtensa semihosting provides basic file IO calls, such as\n    open/read/write/seek/select. Tensilica baremetal libc for ISS and\n    linux platform \"sim\" use this interface.\n\n    On RISC-V this implements the standard semihosting API, version 0.2.\n\n    ``target=native|gdb|auto``\n        Defines where the semihosting calls will be addressed, to QEMU\n        (``native``) or to GDB (``gdb``). The default is ``auto``, which\n        means ``gdb`` during debug sessions and ``native`` otherwise.\n\n    ``chardev=str1``\n        Send the output to a chardev backend output for native or auto\n        output when not in gdb\n\n    ``arg=str1,arg=str2,...``\n        Allows the user to pass input arguments, and can be used\n        multiple times to build up a list. The old-style\n        ``-kernel``/``-append`` method of passing a command line is\n        still supported for backward compatibility. If both the\n        ``--semihosting-config arg`` and the ``-kernel``/``-append`` are\n        specified, the former is passed to semihosting as it always\n        takes precedence.\nERST\nDEF(\"old-param\", 0, QEMU_OPTION_old_param,\n    \"-old-param      old param mode\\n\", QEMU_ARCH_ARM)\nSRST\n``-old-param``\n    Old param mode (ARM only).\nERST\n\nDEF(\"sandbox\", HAS_ARG, QEMU_OPTION_sandbox, \\\n    \"-sandbox on[,obsolete=allow|deny][,elevateprivileges=allow|deny|children]\\n\" \\\n    \"          [,spawn=allow|deny][,resourcecontrol=allow|deny]\\n\" \\\n    \"                Enable seccomp mode 2 system call filter (default 'off').\\n\" \\\n    \"                use 'obsolete' to allow obsolete system calls that are provided\\n\" \\\n    \"                    by the kernel, but typically no longer used by modern\\n\" \\\n    \"                    C library implementations.\\n\" \\\n    \"                use 'elevateprivileges' to allow or deny the QEMU process ability\\n\" \\\n    \"                    to elevate privileges using set*uid|gid system calls.\\n\" \\\n    \"                    The value 'children' will deny set*uid|gid system calls for\\n\" \\\n    \"                    main QEMU process but will allow forks and execves to run unprivileged\\n\" \\\n    \"                use 'spawn' to avoid QEMU to spawn new threads or processes by\\n\" \\\n    \"                     blocking *fork and execve\\n\" \\\n    \"                use 'resourcecontrol' to disable process affinity and schedular priority\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-sandbox arg[,obsolete=string][,elevateprivileges=string][,spawn=string][,resourcecontrol=string]``\n    Enable Seccomp mode 2 system call filter. 'on' will enable syscall\n    filtering and 'off' will disable it. The default is 'off'.\n\n    ``obsolete=string``\n        Enable Obsolete system calls\n\n    ``elevateprivileges=string``\n        Disable set\\*uid\\|gid system calls\n\n    ``spawn=string``\n        Disable \\*fork and execve\n\n    ``resourcecontrol=string``\n        Disable process affinity and schedular priority\nERST\n\nDEF(\"readconfig\", HAS_ARG, QEMU_OPTION_readconfig,\n    \"-readconfig <file>\\n\"\n    \"                read config file\\n\", QEMU_ARCH_ALL)\nSRST\n``-readconfig file``\n    Read device configuration from file. This approach is useful when\n    you want to spawn QEMU process with many command line options but\n    you don't want to exceed the command line character limit.\nERST\n\nDEF(\"no-user-config\", 0, QEMU_OPTION_nouserconfig,\n    \"-no-user-config\\n\"\n    \"                do not load default user-provided config files at startup\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-no-user-config``\n    The ``-no-user-config`` option makes QEMU not load any of the\n    user-provided config files on sysconfdir.\nERST\n\nDEF(\"trace\", HAS_ARG, QEMU_OPTION_trace,\n    \"-trace [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n    \"                specify tracing options\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-trace [[enable=]pattern][,events=file][,file=file]``\n  .. include:: ../qemu-option-trace.rst.inc\n\nERST\nDEF(\"plugin\", HAS_ARG, QEMU_OPTION_plugin,\n    \"-plugin [file=]<file>[,<argname>=<argvalue>]\\n\"\n    \"                load a plugin\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-plugin file=file[,argname=argvalue]``\n    Load a plugin.\n\n    ``file=file``\n        Load the given plugin from a shared library file.\n\n    ``argname=argvalue``\n        Argument passed to the plugin. (Can be given multiple times.)\nERST\n\nHXCOMM Internal use\nDEF(\"qtest\", HAS_ARG, QEMU_OPTION_qtest, \"\", QEMU_ARCH_ALL)\nDEF(\"qtest-log\", HAS_ARG, QEMU_OPTION_qtest_log, \"\", QEMU_ARCH_ALL)\n\nDEF(\"msg\", HAS_ARG, QEMU_OPTION_msg,\n    \"-msg [timestamp[=on|off]][,guest-name=[on|off]]\\n\"\n    \"                control error message format\\n\"\n    \"                timestamp=on enables timestamps (default: off)\\n\"\n    \"                guest-name=on enables guest name prefix but only if\\n\"\n    \"                              -name guest option is set (default: off)\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-msg [timestamp[=on|off]][,guest-name[=on|off]]``\n    Control error message format.\n\n    ``timestamp=on|off``\n        Prefix messages with a timestamp. Default is off.\n\n    ``guest-name=on|off``\n        Prefix messages with guest name but only if -name guest option is set\n        otherwise the option is ignored. Default is off.\nERST\n\nDEF(\"dump-vmstate\", HAS_ARG, QEMU_OPTION_dump_vmstate,\n    \"-dump-vmstate <file>\\n\"\n    \"                Output vmstate information in JSON format to file.\\n\"\n    \"                Use the scripts/vmstate-static-checker.py file to\\n\"\n    \"                check for possible regressions in migration code\\n\"\n    \"                by comparing two such vmstate dumps.\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-dump-vmstate file``\n    Dump json-encoded vmstate information for current machine type to\n    file in file\nERST\n\nDEF(\"enable-sync-profile\", 0, QEMU_OPTION_enable_sync_profile,\n    \"-enable-sync-profile\\n\"\n    \"                enable synchronization profiling\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-enable-sync-profile``\n    Enable synchronization profiling.\nERST\n\nDEFHEADING()\n\nDEFHEADING(Generic object creation:)\n\nDEF(\"object\", HAS_ARG, QEMU_OPTION_object,\n    \"-object TYPENAME[,PROP1=VALUE1,...]\\n\"\n    \"                create a new object of type TYPENAME setting properties\\n\"\n    \"                in the order they are specified.  Note that the 'id'\\n\"\n    \"                property must be set.  These objects are placed in the\\n\"\n    \"                '/objects' path.\\n\",\n    QEMU_ARCH_ALL)\nSRST\n``-object typename[,prop1=value1,...]``\n    Create a new object of type typename setting properties in the order\n    they are specified. Note that the 'id' property must be set. These\n    objects are placed in the '/objects' path.\n\n    ``-object memory-backend-file,id=id,size=size,mem-path=dir,share=on|off,discard-data=on|off,merge=on|off,dump=on|off,prealloc=on|off,host-nodes=host-nodes,policy=default|preferred|bind|interleave,align=align,readonly=on|off``\n        Creates a memory file backend object, which can be used to back\n        the guest RAM with huge pages.\n\n        The ``id`` parameter is a unique ID that will be used to\n        reference this memory region in other parameters, e.g. ``-numa``,\n        ``-device nvdimm``, etc.\n\n        The ``size`` option provides the size of the memory region, and\n        accepts common suffixes, e.g. ``500M``.\n\n        The ``mem-path`` provides the path to either a shared memory or\n        huge page filesystem mount.\n\n        The ``share`` boolean option determines whether the memory\n        region is marked as private to QEMU, or shared. The latter\n        allows a co-operating external process to access the QEMU memory\n        region.\n\n        The ``share`` is also required for pvrdma devices due to\n        limitations in the RDMA API provided by Linux.\n\n        Setting share=on might affect the ability to configure NUMA\n        bindings for the memory backend under some circumstances, see\n        Documentation/vm/numa\\_memory\\_policy.txt on the Linux kernel\n        source tree for additional details.\n\n        Setting the ``discard-data`` boolean option to on indicates that\n        file contents can be destroyed when QEMU exits, to avoid\n        unnecessarily flushing data to the backing file. Note that\n        ``discard-data`` is only an optimization, and QEMU might not\n        discard file contents if it aborts unexpectedly or is terminated\n        using SIGKILL.\n\n        The ``merge`` boolean option enables memory merge, also known as\n        MADV\\_MERGEABLE, so that Kernel Samepage Merging will consider\n        the pages for memory deduplication.\n\n        Setting the ``dump`` boolean option to off excludes the memory\n        from core dumps. This feature is also known as MADV\\_DONTDUMP.\n\n        The ``prealloc`` boolean option enables memory preallocation.\n\n        The ``host-nodes`` option binds the memory range to a list of\n        NUMA host nodes.\n\n        The ``policy`` option sets the NUMA policy to one of the\n        following values:\n\n        ``default``\n            default host policy\n\n        ``preferred``\n            prefer the given host node list for allocation\n\n        ``bind``\n            restrict memory allocation to the given host node list\n\n        ``interleave``\n            interleave memory allocations across the given host node\n            list\n\n        The ``align`` option specifies the base address alignment when\n        QEMU mmap(2) ``mem-path``, and accepts common suffixes, eg\n        ``2M``. Some backend store specified by ``mem-path`` requires an\n        alignment different than the default one used by QEMU, eg the\n        device DAX /dev/dax0.0 requires 2M alignment rather than 4K. In\n        such cases, users can specify the required alignment via this\n        option.\n\n        The ``pmem`` option specifies whether the backing file specified\n        by ``mem-path`` is in host persistent memory that can be\n        accessed using the SNIA NVM programming model (e.g. Intel\n        NVDIMM). If ``pmem`` is set to 'on', QEMU will take necessary\n        operations to guarantee the persistence of its own writes to\n        ``mem-path`` (e.g. in vNVDIMM label emulation and live\n        migration). Also, we will map the backend-file with MAP\\_SYNC\n        flag, which ensures the file metadata is in sync for\n        ``mem-path`` in case of host crash or a power failure. MAP\\_SYNC\n        requires support from both the host kernel (since Linux kernel\n        4.15) and the filesystem of ``mem-path`` mounted with DAX\n        option.\n\n        The ``readonly`` option specifies whether the backing file is opened\n        read-only or read-write (default).\n\n    ``-object memory-backend-ram,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave``\n        Creates a memory backend object, which can be used to back the\n        guest RAM. Memory backend objects offer more control than the\n        ``-m`` option that is traditionally used to define guest RAM.\n        Please refer to ``memory-backend-file`` for a description of the\n        options.\n\n    ``-object memory-backend-memfd,id=id,merge=on|off,dump=on|off,share=on|off,prealloc=on|off,size=size,host-nodes=host-nodes,policy=default|preferred|bind|interleave,seal=on|off,hugetlb=on|off,hugetlbsize=size``\n        Creates an anonymous memory file backend object, which allows\n        QEMU to share the memory with an external process (e.g. when\n        using vhost-user). The memory is allocated with memfd and\n        optional sealing. (Linux only)\n\n        The ``seal`` option creates a sealed-file, that will block\n        further resizing the memory ('on' by default).\n\n        The ``hugetlb`` option specify the file to be created resides in\n        the hugetlbfs filesystem (since Linux 4.14). Used in conjunction\n        with the ``hugetlb`` option, the ``hugetlbsize`` option specify\n        the hugetlb page size on systems that support multiple hugetlb\n        page sizes (it must be a power of 2 value supported by the\n        system).\n\n        In some versions of Linux, the ``hugetlb`` option is\n        incompatible with the ``seal`` option (requires at least Linux\n        4.16).\n\n        Please refer to ``memory-backend-file`` for a description of the\n        other options.\n\n        The ``share`` boolean option is on by default with memfd.\n\n    ``-object rng-builtin,id=id``\n        Creates a random number generator backend which obtains entropy\n        from QEMU builtin functions. The ``id`` parameter is a unique ID\n        that will be used to reference this entropy backend from the\n        ``virtio-rng`` device. By default, the ``virtio-rng`` device\n        uses this RNG backend.\n\n    ``-object rng-random,id=id,filename=/dev/random``\n        Creates a random number generator backend which obtains entropy\n        from a device on the host. The ``id`` parameter is a unique ID\n        that will be used to reference this entropy backend from the\n        ``virtio-rng`` device. The ``filename`` parameter specifies\n        which file to obtain entropy from and if omitted defaults to\n        ``/dev/urandom``.\n\n    ``-object rng-egd,id=id,chardev=chardevid``\n        Creates a random number generator backend which obtains entropy\n        from an external daemon running on the host. The ``id``\n        parameter is a unique ID that will be used to reference this\n        entropy backend from the ``virtio-rng`` device. The ``chardev``\n        parameter is the unique ID of a character device backend that\n        provides the connection to the RNG daemon.\n\n    ``-object tls-creds-anon,id=id,endpoint=endpoint,dir=/path/to/cred/dir,verify-peer=on|off``\n        Creates a TLS anonymous credentials object, which can be used to\n        provide TLS support on network backends. The ``id`` parameter is\n        a unique ID which network backends will use to access the\n        credentials. The ``endpoint`` is either ``server`` or ``client``\n        depending on whether the QEMU network backend that uses the\n        credentials will be acting as a client or as a server. If\n        ``verify-peer`` is enabled (the default) then once the handshake\n        is completed, the peer credentials will be verified, though this\n        is a no-op for anonymous credentials.\n\n        The dir parameter tells QEMU where to find the credential files.\n        For server endpoints, this directory may contain a file\n        dh-params.pem providing diffie-hellman parameters to use for the\n        TLS server. If the file is missing, QEMU will generate a set of\n        DH parameters at startup. This is a computationally expensive\n        operation that consumes random pool entropy, so it is\n        recommended that a persistent set of parameters be generated\n        upfront and saved.\n\n    ``-object tls-creds-psk,id=id,endpoint=endpoint,dir=/path/to/keys/dir[,username=username]``\n        Creates a TLS Pre-Shared Keys (PSK) credentials object, which\n        can be used to provide TLS support on network backends. The\n        ``id`` parameter is a unique ID which network backends will use\n        to access the credentials. The ``endpoint`` is either ``server``\n        or ``client`` depending on whether the QEMU network backend that\n        uses the credentials will be acting as a client or as a server.\n        For clients only, ``username`` is the username which will be\n        sent to the server. If omitted it defaults to \"qemu\".\n\n        The dir parameter tells QEMU where to find the keys file. It is\n        called \"dir/keys.psk\" and contains \"username:key\" pairs. This\n        file can most easily be created using the GnuTLS ``psktool``\n        program.\n\n        For server endpoints, dir may also contain a file dh-params.pem\n        providing diffie-hellman parameters to use for the TLS server.\n        If the file is missing, QEMU will generate a set of DH\n        parameters at startup. This is a computationally expensive\n        operation that consumes random pool entropy, so it is\n        recommended that a persistent set of parameters be generated up\n        front and saved.\n\n    ``-object tls-creds-x509,id=id,endpoint=endpoint,dir=/path/to/cred/dir,priority=priority,verify-peer=on|off,passwordid=id``\n        Creates a TLS anonymous credentials object, which can be used to\n        provide TLS support on network backends. The ``id`` parameter is\n        a unique ID which network backends will use to access the\n        credentials. The ``endpoint`` is either ``server`` or ``client``\n        depending on whether the QEMU network backend that uses the\n        credentials will be acting as a client or as a server. If\n        ``verify-peer`` is enabled (the default) then once the handshake\n        is completed, the peer credentials will be verified. With x509\n        certificates, this implies that the clients must be provided\n        with valid client certificates too.\n\n        The dir parameter tells QEMU where to find the credential files.\n        For server endpoints, this directory may contain a file\n        dh-params.pem providing diffie-hellman parameters to use for the\n        TLS server. If the file is missing, QEMU will generate a set of\n        DH parameters at startup. This is a computationally expensive\n        operation that consumes random pool entropy, so it is\n        recommended that a persistent set of parameters be generated\n        upfront and saved.\n\n        For x509 certificate credentials the directory will contain\n        further files providing the x509 certificates. The certificates\n        must be stored in PEM format, in filenames ca-cert.pem,\n        ca-crl.pem (optional), server-cert.pem (only servers),\n        server-key.pem (only servers), client-cert.pem (only clients),\n        and client-key.pem (only clients).\n\n        For the server-key.pem and client-key.pem files which contain\n        sensitive private keys, it is possible to use an encrypted\n        version by providing the passwordid parameter. This provides the\n        ID of a previously created ``secret`` object containing the\n        password for decryption.\n\n        The priority parameter allows to override the global default\n        priority used by gnutls. This can be useful if the system\n        administrator needs to use a weaker set of crypto priorities for\n        QEMU without potentially forcing the weakness onto all\n        applications. Or conversely if one wants wants a stronger\n        default for QEMU than for all other applications, they can do\n        this through this parameter. Its format is a gnutls priority\n        string as described at\n        https://gnutls.org/manual/html_node/Priority-Strings.html.\n\n    ``-object tls-cipher-suites,id=id,priority=priority``\n        Creates a TLS cipher suites object, which can be used to control\n        the TLS cipher/protocol algorithms that applications are permitted\n        to use.\n\n        The ``id`` parameter is a unique ID which frontends will use to\n        access the ordered list of permitted TLS cipher suites from the\n        host.\n\n        The ``priority`` parameter allows to override the global default\n        priority used by gnutls. This can be useful if the system\n        administrator needs to use a weaker set of crypto priorities for\n        QEMU without potentially forcing the weakness onto all\n        applications. Or conversely if one wants wants a stronger\n        default for QEMU than for all other applications, they can do\n        this through this parameter. Its format is a gnutls priority\n        string as described at\n        https://gnutls.org/manual/html_node/Priority-Strings.html.\n\n        An example of use of this object is to control UEFI HTTPS Boot.\n        The tls-cipher-suites object exposes the ordered list of permitted\n        TLS cipher suites from the host side to the guest firmware, via\n        fw_cfg. The list is represented as an array of IANA_TLS_CIPHER\n        objects. The firmware uses the IANA_TLS_CIPHER array for configuring\n        guest-side TLS.\n\n        In the following example, the priority at which the host-side policy\n        is retrieved is given by the ``priority`` property.\n        Given that QEMU uses GNUTLS, ``priority=@SYSTEM`` may be used to\n        refer to /etc/crypto-policies/back-ends/gnutls.config.\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n                 -object tls-cipher-suites,id=mysuite0,priority=@SYSTEM \\\\\n                 -fw_cfg name=etc/edk2/https/ciphers,gen_id=mysuite0\n\n    ``-object filter-buffer,id=id,netdev=netdevid,interval=t[,queue=all|rx|tx][,status=on|off][,position=head|tail|id=<id>][,insert=behind|before]``\n        Interval t can't be 0, this filter batches the packet delivery:\n        all packets arriving in a given interval on netdev netdevid are\n        delayed until the end of the interval. Interval is in\n        microseconds. ``status`` is optional that indicate whether the\n        netfilter is on (enabled) or off (disabled), the default status\n        for netfilter will be 'on'.\n\n        queue all\\|rx\\|tx is an option that can be applied to any\n        netfilter.\n\n        ``all``: the filter is attached both to the receive and the\n        transmit queue of the netdev (default).\n\n        ``rx``: the filter is attached to the receive queue of the\n        netdev, where it will receive packets sent to the netdev.\n\n        ``tx``: the filter is attached to the transmit queue of the\n        netdev, where it will receive packets sent by the netdev.\n\n        position head\\|tail\\|id=<id> is an option to specify where the\n        filter should be inserted in the filter list. It can be applied\n        to any netfilter.\n\n        ``head``: the filter is inserted at the head of the filter list,\n        before any existing filters.\n\n        ``tail``: the filter is inserted at the tail of the filter list,\n        behind any existing filters (default).\n\n        ``id=<id>``: the filter is inserted before or behind the filter\n        specified by <id>, see the insert option below.\n\n        insert behind\\|before is an option to specify where to insert\n        the new filter relative to the one specified with\n        position=id=<id>. It can be applied to any netfilter.\n\n        ``before``: insert before the specified filter.\n\n        ``behind``: insert behind the specified filter (default).\n\n    ``-object filter-mirror,id=id,netdev=netdevid,outdev=chardevid,queue=all|rx|tx[,vnet_hdr_support][,position=head|tail|id=<id>][,insert=behind|before]``\n        filter-mirror on netdev netdevid,mirror net packet to\n        chardevchardevid, if it has the vnet\\_hdr\\_support flag,\n        filter-mirror will mirror packet with vnet\\_hdr\\_len.\n\n    ``-object filter-redirector,id=id,netdev=netdevid,indev=chardevid,outdev=chardevid,queue=all|rx|tx[,vnet_hdr_support][,position=head|tail|id=<id>][,insert=behind|before]``\n        filter-redirector on netdev netdevid,redirect filter's net\n        packet to chardev chardevid,and redirect indev's packet to\n        filter.if it has the vnet\\_hdr\\_support flag, filter-redirector\n        will redirect packet with vnet\\_hdr\\_len. Create a\n        filter-redirector we need to differ outdev id from indev id, id\n        can not be the same. we can just use indev or outdev, but at\n        least one of indev or outdev need to be specified.\n\n    ``-object filter-rewriter,id=id,netdev=netdevid,queue=all|rx|tx,[vnet_hdr_support][,position=head|tail|id=<id>][,insert=behind|before]``\n        Filter-rewriter is a part of COLO project.It will rewrite tcp\n        packet to secondary from primary to keep secondary tcp\n        connection,and rewrite tcp packet to primary from secondary make\n        tcp packet can be handled by client.if it has the\n        vnet\\_hdr\\_support flag, we can parse packet with vnet header.\n\n        usage: colo secondary: -object\n        filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0 -object\n        filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1 -object\n        filter-rewriter,id=rew0,netdev=hn0,queue=all\n\n    ``-object filter-dump,id=id,netdev=dev[,file=filename][,maxlen=len][,position=head|tail|id=<id>][,insert=behind|before]``\n        Dump the network traffic on netdev dev to the file specified by\n        filename. At most len bytes (64k by default) per packet are\n        stored. The file format is libpcap, so it can be analyzed with\n        tools such as tcpdump or Wireshark.\n\n    ``-object colo-compare,id=id,primary_in=chardevid,secondary_in=chardevid,outdev=chardevid,iothread=id[,vnet_hdr_support][,notify_dev=id][,compare_timeout=@var{ms}][,expired_scan_cycle=@var{ms}][,max_queue_size=@var{size}]``\n        Colo-compare gets packet from primary\\_in chardevid and\n        secondary\\_in, then compare whether the payload of primary packet\n        and secondary packet are the same. If same, it will output\n        primary packet to out\\_dev, else it will notify COLO-framework to do\n        checkpoint and send primary packet to out\\_dev. In order to\n        improve efficiency, we need to put the task of comparison in\n        another iothread. If it has the vnet\\_hdr\\_support flag,\n        colo compare will send/recv packet with vnet\\_hdr\\_len.\n        The compare\\_timeout=@var{ms} determines the maximum time of the\n        colo-compare hold the packet. The expired\\_scan\\_cycle=@var{ms}\n        is to set the period of scanning expired primary node network packets.\n        The max\\_queue\\_size=@var{size} is to set the max compare queue\n        size depend on user environment.\n        If user want to use Xen COLO, need to add the notify\\_dev to\n        notify Xen colo-frame to do checkpoint.\n\n        COLO-compare must be used with the help of filter-mirror,\n        filter-redirector and filter-rewriter.\n\n        ::\n\n            KVM COLO\n\n            primary:\n            -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown\n            -device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66\n            -chardev socket,id=mirror0,host=3.3.3.3,port=9003,server=on,wait=off\n            -chardev socket,id=compare1,host=3.3.3.3,port=9004,server=on,wait=off\n            -chardev socket,id=compare0,host=3.3.3.3,port=9001,server=on,wait=off\n            -chardev socket,id=compare0-0,host=3.3.3.3,port=9001\n            -chardev socket,id=compare_out,host=3.3.3.3,port=9005,server=on,wait=off\n            -chardev socket,id=compare_out0,host=3.3.3.3,port=9005\n            -object iothread,id=iothread1\n            -object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0\n            -object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out\n            -object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0\n            -object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0,iothread=iothread1\n\n            secondary:\n            -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown\n            -device e1000,netdev=hn0,mac=52:a4:00:12:78:66\n            -chardev socket,id=red0,host=3.3.3.3,port=9003\n            -chardev socket,id=red1,host=3.3.3.3,port=9004\n            -object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0\n            -object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1\n\n\n            Xen COLO\n\n            primary:\n            -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,downscript=/etc/qemu-ifdown\n            -device e1000,id=e0,netdev=hn0,mac=52:a4:00:12:78:66\n            -chardev socket,id=mirror0,host=3.3.3.3,port=9003,server=on,wait=off\n            -chardev socket,id=compare1,host=3.3.3.3,port=9004,server=on,wait=off\n            -chardev socket,id=compare0,host=3.3.3.3,port=9001,server=on,wait=off\n            -chardev socket,id=compare0-0,host=3.3.3.3,port=9001\n            -chardev socket,id=compare_out,host=3.3.3.3,port=9005,server=on,wait=off\n            -chardev socket,id=compare_out0,host=3.3.3.3,port=9005\n            -chardev socket,id=notify_way,host=3.3.3.3,port=9009,server=on,wait=off\n            -object filter-mirror,id=m0,netdev=hn0,queue=tx,outdev=mirror0\n            -object filter-redirector,netdev=hn0,id=redire0,queue=rx,indev=compare_out\n            -object filter-redirector,netdev=hn0,id=redire1,queue=rx,outdev=compare0\n            -object iothread,id=iothread1\n            -object colo-compare,id=comp0,primary_in=compare0-0,secondary_in=compare1,outdev=compare_out0,notify_dev=nofity_way,iothread=iothread1\n\n            secondary:\n            -netdev tap,id=hn0,vhost=off,script=/etc/qemu-ifup,down script=/etc/qemu-ifdown\n            -device e1000,netdev=hn0,mac=52:a4:00:12:78:66\n            -chardev socket,id=red0,host=3.3.3.3,port=9003\n            -chardev socket,id=red1,host=3.3.3.3,port=9004\n            -object filter-redirector,id=f1,netdev=hn0,queue=tx,indev=red0\n            -object filter-redirector,id=f2,netdev=hn0,queue=rx,outdev=red1\n\n        If you want to know the detail of above command line, you can\n        read the colo-compare git log.\n\n    ``-object cryptodev-backend-builtin,id=id[,queues=queues]``\n        Creates a cryptodev backend which executes crypto opreation from\n        the QEMU cipher APIS. The id parameter is a unique ID that will\n        be used to reference this cryptodev backend from the\n        ``virtio-crypto`` device. The queues parameter is optional,\n        which specify the queue number of cryptodev backend, the default\n        of queues is 1.\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n               [...] \\\\\n                   -object cryptodev-backend-builtin,id=cryptodev0 \\\\\n                   -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \\\\\n               [...]\n\n    ``-object cryptodev-vhost-user,id=id,chardev=chardevid[,queues=queues]``\n        Creates a vhost-user cryptodev backend, backed by a chardev\n        chardevid. The id parameter is a unique ID that will be used to\n        reference this cryptodev backend from the ``virtio-crypto``\n        device. The chardev should be a unix domain socket backed one.\n        The vhost-user uses a specifically defined protocol to pass\n        vhost ioctl replacement messages to an application on the other\n        end of the socket. The queues parameter is optional, which\n        specify the queue number of cryptodev backend for multiqueue\n        vhost-user, the default of queues is 1.\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n               [...] \\\\\n                   -chardev socket,id=chardev0,path=/path/to/socket \\\\\n                   -object cryptodev-vhost-user,id=cryptodev0,chardev=chardev0 \\\\\n                   -device virtio-crypto-pci,id=crypto0,cryptodev=cryptodev0 \\\\\n               [...]\n\n    ``-object secret,id=id,data=string,format=raw|base64[,keyid=secretid,iv=string]``\n      \\ \n    ``-object secret,id=id,file=filename,format=raw|base64[,keyid=secretid,iv=string]``\n        Defines a secret to store a password, encryption key, or some\n        other sensitive data. The sensitive data can either be passed\n        directly via the data parameter, or indirectly via the file\n        parameter. Using the data parameter is insecure unless the\n        sensitive data is encrypted.\n\n        The sensitive data can be provided in raw format (the default),\n        or base64. When encoded as JSON, the raw format only supports\n        valid UTF-8 characters, so base64 is recommended for sending\n        binary data. QEMU will convert from which ever format is\n        provided to the format it needs internally. eg, an RBD password\n        can be provided in raw format, even though it will be base64\n        encoded when passed onto the RBD sever.\n\n        For added protection, it is possible to encrypt the data\n        associated with a secret using the AES-256-CBC cipher. Use of\n        encryption is indicated by providing the keyid and iv\n        parameters. The keyid parameter provides the ID of a previously\n        defined secret that contains the AES-256 decryption key. This\n        key should be 32-bytes long and be base64 encoded. The iv\n        parameter provides the random initialization vector used for\n        encryption of this particular secret and should be a base64\n        encrypted string of the 16-byte IV.\n\n        The simplest (insecure) usage is to provide the secret inline\n\n        .. parsed-literal::\n\n             # |qemu_system| -object secret,id=sec0,data=letmein,format=raw\n\n        The simplest secure usage is to provide the secret via a file\n\n        # printf \"letmein\" > mypasswd.txt # QEMU\\_SYSTEM\\_MACRO -object\n        secret,id=sec0,file=mypasswd.txt,format=raw\n\n        For greater security, AES-256-CBC should be used. To illustrate\n        usage, consider the openssl command line tool which can encrypt\n        the data. Note that when encrypting, the plaintext must be\n        padded to the cipher block size (32 bytes) using the standard\n        PKCS#5/6 compatible padding algorithm.\n\n        First a master key needs to be created in base64 encoding:\n\n        ::\n\n             # openssl rand -base64 32 > key.b64\n             # KEY=$(base64 -d key.b64 | hexdump  -v -e '/1 \"%02X\"')\n\n        Each secret to be encrypted needs to have a random\n        initialization vector generated. These do not need to be kept\n        secret\n\n        ::\n\n             # openssl rand -base64 16 > iv.b64\n             # IV=$(base64 -d iv.b64 | hexdump  -v -e '/1 \"%02X\"')\n\n        The secret to be defined can now be encrypted, in this case\n        we're telling openssl to base64 encode the result, but it could\n        be left as raw bytes if desired.\n\n        ::\n\n             # SECRET=$(printf \"letmein\" |\n                        openssl enc -aes-256-cbc -a -K $KEY -iv $IV)\n\n        When launching QEMU, create a master secret pointing to\n        ``key.b64`` and specify that to be used to decrypt the user\n        password. Pass the contents of ``iv.b64`` to the second secret\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n                 -object secret,id=secmaster0,format=base64,file=key.b64 \\\\\n                 -object secret,id=sec0,keyid=secmaster0,format=base64,\\\\\n                     data=$SECRET,iv=$(<iv.b64)\n\n    ``-object sev-guest,id=id,cbitpos=cbitpos,reduced-phys-bits=val,[sev-device=string,policy=policy,handle=handle,dh-cert-file=file,session-file=file,kernel-hashes=on|off]``\n        Create a Secure Encrypted Virtualization (SEV) guest object,\n        which can be used to provide the guest memory encryption support\n        on AMD processors.\n\n        When memory encryption is enabled, one of the physical address\n        bit (aka the C-bit) is utilized to mark if a memory page is\n        protected. The ``cbitpos`` is used to provide the C-bit\n        position. The C-bit position is Host family dependent hence user\n        must provide this value. On EPYC, the value should be 47.\n\n        When memory encryption is enabled, we loose certain bits in\n        physical address space. The ``reduced-phys-bits`` is used to\n        provide the number of bits we loose in physical address space.\n        Similar to C-bit, the value is Host family dependent. On EPYC,\n        the value should be 5.\n\n        The ``sev-device`` provides the device file to use for\n        communicating with the SEV firmware running inside AMD Secure\n        Processor. The default device is '/dev/sev'. If hardware\n        supports memory encryption then /dev/sev devices are created by\n        CCP driver.\n\n        The ``policy`` provides the guest policy to be enforced by the\n        SEV firmware and restrict what configuration and operational\n        commands can be performed on this guest by the hypervisor. The\n        policy should be provided by the guest owner and is bound to the\n        guest and cannot be changed throughout the lifetime of the\n        guest. The default is 0.\n\n        If guest ``policy`` allows sharing the key with another SEV\n        guest then ``handle`` can be use to provide handle of the guest\n        from which to share the key.\n\n        The ``dh-cert-file`` and ``session-file`` provides the guest\n        owner's Public Diffie-Hillman key defined in SEV spec. The PDH\n        and session parameters are used for establishing a cryptographic\n        session with the guest owner to negotiate keys used for\n        attestation. The file must be encoded in base64.\n\n        The ``kernel-hashes`` adds the hashes of given kernel/initrd/\n        cmdline to a designated guest firmware page for measured Linux\n        boot with -kernel. The default is off. (Since 6.2)\n\n        e.g to launch a SEV guest\n\n        .. parsed-literal::\n\n             # |qemu_system_x86| \\\\\n                 ...... \\\\\n                 -object sev-guest,id=sev0,cbitpos=47,reduced-phys-bits=5 \\\\\n                 -machine ...,memory-encryption=sev0 \\\\\n                 .....\n\n    ``-object authz-simple,id=id,identity=string``\n        Create an authorization object that will control access to\n        network services.\n\n        The ``identity`` parameter is identifies the user and its format\n        depends on the network service that authorization object is\n        associated with. For authorizing based on TLS x509 certificates,\n        the identity must be the x509 distinguished name. Note that care\n        must be taken to escape any commas in the distinguished name.\n\n        An example authorization object to validate a x509 distinguished\n        name would look like:\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n                 ... \\\\\n                 -object 'authz-simple,id=auth0,identity=CN=laptop.example.com,,O=Example Org,,L=London,,ST=London,,C=GB' \\\\\n                 ...\n\n        Note the use of quotes due to the x509 distinguished name\n        containing whitespace, and escaping of ','.\n\n    ``-object authz-listfile,id=id,filename=path,refresh=on|off``\n        Create an authorization object that will control access to\n        network services.\n\n        The ``filename`` parameter is the fully qualified path to a file\n        containing the access control list rules in JSON format.\n\n        An example set of rules that match against SASL usernames might\n        look like:\n\n        ::\n\n              {\n                \"rules\": [\n                   { \"match\": \"fred\", \"policy\": \"allow\", \"format\": \"exact\" },\n                   { \"match\": \"bob\", \"policy\": \"allow\", \"format\": \"exact\" },\n                   { \"match\": \"danb\", \"policy\": \"deny\", \"format\": \"glob\" },\n                   { \"match\": \"dan*\", \"policy\": \"allow\", \"format\": \"exact\" },\n                ],\n                \"policy\": \"deny\"\n              }\n\n        When checking access the object will iterate over all the rules\n        and the first rule to match will have its ``policy`` value\n        returned as the result. If no rules match, then the default\n        ``policy`` value is returned.\n\n        The rules can either be an exact string match, or they can use\n        the simple UNIX glob pattern matching to allow wildcards to be\n        used.\n\n        If ``refresh`` is set to true the file will be monitored and\n        automatically reloaded whenever its content changes.\n\n        As with the ``authz-simple`` object, the format of the identity\n        strings being matched depends on the network service, but is\n        usually a TLS x509 distinguished name, or a SASL username.\n\n        An example authorization object to validate a SASL username\n        would look like:\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n                 ... \\\\\n                 -object authz-simple,id=auth0,filename=/etc/qemu/vnc-sasl.acl,refresh=on \\\\\n                 ...\n\n    ``-object authz-pam,id=id,service=string``\n        Create an authorization object that will control access to\n        network services.\n\n        The ``service`` parameter provides the name of a PAM service to\n        use for authorization. It requires that a file\n        ``/etc/pam.d/service`` exist to provide the configuration for\n        the ``account`` subsystem.\n\n        An example authorization object to validate a TLS x509\n        distinguished name would look like:\n\n        .. parsed-literal::\n\n             # |qemu_system| \\\\\n                 ... \\\\\n                 -object authz-pam,id=auth0,service=qemu-vnc \\\\\n                 ...\n\n        There would then be a corresponding config file for PAM at\n        ``/etc/pam.d/qemu-vnc`` that contains:\n\n        ::\n\n            account requisite  pam_listfile.so item=user sense=allow \\\n                       file=/etc/qemu/vnc.allow\n\n        Finally the ``/etc/qemu/vnc.allow`` file would contain the list\n        of x509 distingished names that are permitted access\n\n        ::\n\n            CN=laptop.example.com,O=Example Home,L=London,ST=London,C=GB\n\n    ``-object iothread,id=id,poll-max-ns=poll-max-ns,poll-grow=poll-grow,poll-shrink=poll-shrink,aio-max-batch=aio-max-batch``\n        Creates a dedicated event loop thread that devices can be\n        assigned to. This is known as an IOThread. By default device\n        emulation happens in vCPU threads or the main event loop thread.\n        This can become a scalability bottleneck. IOThreads allow device\n        emulation and I/O to run on other host CPUs.\n\n        The ``id`` parameter is a unique ID that will be used to\n        reference this IOThread from ``-device ...,iothread=id``.\n        Multiple devices can be assigned to an IOThread. Note that not\n        all devices support an ``iothread`` parameter.\n\n        The ``query-iothreads`` QMP command lists IOThreads and reports\n        their thread IDs so that the user can configure host CPU\n        pinning/affinity.\n\n        IOThreads use an adaptive polling algorithm to reduce event loop\n        latency. Instead of entering a blocking system call to monitor\n        file descriptors and then pay the cost of being woken up when an\n        event occurs, the polling algorithm spins waiting for events for\n        a short time. The algorithm's default parameters are suitable\n        for many cases but can be adjusted based on knowledge of the\n        workload and/or host device latency.\n\n        The ``poll-max-ns`` parameter is the maximum number of\n        nanoseconds to busy wait for events. Polling can be disabled by\n        setting this value to 0.\n\n        The ``poll-grow`` parameter is the multiplier used to increase\n        the polling time when the algorithm detects it is missing events\n        due to not polling long enough.\n\n        The ``poll-shrink`` parameter is the divisor used to decrease\n        the polling time when the algorithm detects it is spending too\n        long polling without encountering events.\n\n        The ``aio-max-batch`` parameter is the maximum number of requests\n        in a batch for the AIO engine, 0 means that the engine will use\n        its default.\n\n        The IOThread parameters can be modified at run-time using the\n        ``qom-set`` command (where ``iothread1`` is the IOThread's\n        ``id``):\n\n        ::\n\n            (qemu) qom-set /objects/iothread1 poll-max-ns 100000\nERST\n\n\nHXCOMM This is the last statement. Insert new options before this line!\n\n#undef DEF\n#undef DEFHEADING\n#undef ARCHHEADING\n"
        },
        {
          "name": "qemu.nsi",
          "type": "blob",
          "size": 6.75390625,
          "content": ";!/usr/bin/makensis\n\n; This NSIS script creates an installer for QEMU on Windows.\n\n; Copyright (C) 2006-2012 Stefan Weil\n;\n; This program is free software: you can redistribute it and/or modify\n; it under the terms of the GNU General Public License as published by\n; the Free Software Foundation, either version 2 of the License, or\n; (at your option) version 3 or any later version.\n;\n; This program is distributed in the hope that it will be useful,\n; but WITHOUT ANY WARRANTY; without even the implied warranty of\n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n; GNU General Public License for more details.\n;\n; You should have received a copy of the GNU General Public License\n; along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n; NSIS_WIN32_MAKENSIS\n\n!define PRODUCT \"QEMU\"\n!define URL     \"https://www.qemu.org/\"\n\n!define UNINST_EXE \"$INSTDIR\\qemu-uninstall.exe\"\n!define UNINST_KEY \"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\${PRODUCT}\"\n\n!ifndef BINDIR\n!define BINDIR nsis.tmp\n!endif\n!ifndef SRCDIR\n!define SRCDIR .\n!endif\n!ifndef OUTFILE\n!define OUTFILE \"qemu-setup.exe\"\n!endif\n\n; Build a unicode installer\nUnicode true\n\n; Use maximum compression.\nSetCompressor /SOLID lzma\n\n!include \"MUI2.nsh\"\n\n; The name of the installer.\nName \"QEMU\"\n\n; The file to write\nOutFile \"${OUTFILE}\"\n\n; The default installation directory.\n!ifdef W64\nInstallDir $PROGRAMFILES64\\qemu\n!else\nInstallDir $PROGRAMFILES\\qemu\n!endif\n\n; Registry key to check for directory (so if you install again, it will\n; overwrite the old one automatically)\n!ifdef W64\nInstallDirRegKey HKLM \"Software\\qemu64\" \"Install_Dir\"\n!else\nInstallDirRegKey HKLM \"Software\\qemu32\" \"Install_Dir\"\n!endif\n\n; Request administrator privileges for Windows Vista.\nRequestExecutionLevel admin\n\n;--------------------------------\n; Interface Settings.\n;!define MUI_HEADERIMAGE \"qemu-nsis.bmp\"\n; !define MUI_SPECIALBITMAP \"qemu.bmp\"\n!define MUI_ICON \"${SRCDIR}\\pc-bios\\qemu-nsis.ico\"\n!define MUI_UNICON \"${SRCDIR}\\pc-bios\\qemu-nsis.ico\"\n!define MUI_WELCOMEFINISHPAGE_BITMAP \"${SRCDIR}\\pc-bios\\qemu-nsis.bmp\"\n; !define MUI_HEADERIMAGE_BITMAP \"qemu-install.bmp\"\n; !define MUI_HEADERIMAGE_UNBITMAP \"qemu-uninstall.bmp\"\n; !define MUI_COMPONENTSPAGE_SMALLDESC\n; !define MUI_WELCOMEPAGE_TEXT \"Insert text here.$\\r$\\n$\\r$\\n$\\r$\\n$_CLICK\"\n\n;--------------------------------\n; Pages.\n\n!insertmacro MUI_PAGE_WELCOME\n!insertmacro MUI_PAGE_LICENSE \"${SRCDIR}\\COPYING\"\n!insertmacro MUI_PAGE_COMPONENTS\n!insertmacro MUI_PAGE_DIRECTORY\n!insertmacro MUI_PAGE_INSTFILES\n!define MUI_FINISHPAGE_LINK \"Visit the QEMU Wiki online!\"\n!define MUI_FINISHPAGE_LINK_LOCATION \"${URL}\"\n!insertmacro MUI_PAGE_FINISH\n\n!insertmacro MUI_UNPAGE_CONFIRM\n!insertmacro MUI_UNPAGE_INSTFILES\n\n;--------------------------------\n; Languages.\n\n!insertmacro MUI_LANGUAGE \"English\"\n!insertmacro MUI_LANGUAGE \"French\"\n!insertmacro MUI_LANGUAGE \"German\"\n\n;--------------------------------\n\n; The stuff to install.\n;\n; Remember to keep the \"Uninstall\" section in sync.\n\nSection \"${PRODUCT} (required)\"\n\n    SectionIn RO\n\n    ; Set output path to the installation directory.\n    SetOutPath \"$INSTDIR\"\n\n    File \"${SRCDIR}\\COPYING\"\n    File \"${SRCDIR}\\COPYING.LIB\"\n    File \"${SRCDIR}\\README.rst\"\n    File \"${SRCDIR}\\VERSION.QEMU\"\n\n    File /r \"${BINDIR}\\keymaps\"\n    File /r \"${BINDIR}\\share\"\n\n!ifdef W64\n    SetRegView 64\n!endif\n\n    ; Write the installation path into the registry\n    WriteRegStr HKLM SOFTWARE\\${PRODUCT} \"Install_Dir\" \"$INSTDIR\"\n\n    ; Write the uninstall keys for Windows\n    WriteRegStr HKLM \"${UNINST_KEY}\" \"DisplayName\" \"QEMU\"\n!ifdef DISPLAYVERSION\n    WriteRegStr HKLM \"${UNINST_KEY}\" \"DisplayVersion\" \"${DISPLAYVERSION}\"\n!endif\n    WriteRegStr HKLM \"${UNINST_KEY}\" \"UninstallString\" '\"${UNINST_EXE}\"'\n    WriteRegDWORD HKLM \"${UNINST_KEY}\" \"NoModify\" 1\n    WriteRegDWORD HKLM \"${UNINST_KEY}\" \"NoRepair\" 1\n    WriteUninstaller \"qemu-uninstall.exe\"\nSectionEnd\n\nSection \"Tools\" SectionTools\n    SetOutPath \"$INSTDIR\"\n    File \"${BINDIR}\\qemu-img.exe\"\n    File \"${BINDIR}\\qemu-io.exe\"\nSectionEnd\n\nSectionGroup \"System Emulations\" SectionSystem\n\n!include \"${BINDIR}\\system-emulations.nsh\"\n\nSectionGroupEnd\n\n!ifdef DLLDIR\nSection \"Libraries (DLL)\" SectionDll\n    SetOutPath \"$INSTDIR\"\n    File \"${DLLDIR}\\*.dll\"\nSectionEnd\n!endif\n\n!ifdef CONFIG_DOCUMENTATION\nSection \"Documentation\" SectionDoc\n    SetOutPath \"$INSTDIR\\doc\"\n    File /r \"${BINDIR}\\doc\"\n    SetOutPath \"$INSTDIR\"\n    CreateDirectory \"$SMPROGRAMS\\${PRODUCT}\"\n    CreateShortCut \"$SMPROGRAMS\\${PRODUCT}\\User Documentation.lnk\" \"$INSTDIR\\doc\\index.html\" \"\" \"$INSTDIR\\doc\\index.html\" 0\nSectionEnd\n!endif\n\n; Optional section (can be disabled by the user)\nSection \"Start Menu Shortcuts\" SectionMenu\n    CreateDirectory \"$SMPROGRAMS\\${PRODUCT}\"\n    CreateShortCut \"$SMPROGRAMS\\${PRODUCT}\\Uninstall.lnk\" \"${UNINST_EXE}\" \"\" \"${UNINST_EXE}\" 0\nSectionEnd\n\n;--------------------------------\n\n; Uninstaller\n\nSection \"Uninstall\"\n    ; Remove registry keys\n!ifdef W64\n    SetRegView 64\n!endif\n    DeleteRegKey HKLM \"${UNINST_KEY}\"\n    DeleteRegKey HKLM SOFTWARE\\${PRODUCT}\n\n    ; Remove shortcuts, if any\n    Delete \"$SMPROGRAMS\\${PRODUCT}\\User Documentation.lnk\"\n    Delete \"$SMPROGRAMS\\${PRODUCT}\\Technical Documentation.lnk\"\n    Delete \"$SMPROGRAMS\\${PRODUCT}\\Uninstall.lnk\"\n    RMDir \"$SMPROGRAMS\\${PRODUCT}\"\n\n    ; Remove files and directories used\n    Delete \"$INSTDIR\\Changelog\"\n    Delete \"$INSTDIR\\COPYING\"\n    Delete \"$INSTDIR\\COPYING.LIB\"\n    Delete \"$INSTDIR\\README.rst\"\n    Delete \"$INSTDIR\\VERSION.QEMU\"\n    Delete \"$INSTDIR\\*.bmp\"\n    Delete \"$INSTDIR\\*.bin\"\n    Delete \"$INSTDIR\\*.dll\"\n    Delete \"$INSTDIR\\*.dtb\"\n    Delete \"$INSTDIR\\*.fd\"\n    Delete \"$INSTDIR\\*.img\"\n    Delete \"$INSTDIR\\*.lid\"\n    Delete \"$INSTDIR\\*.ndrv\"\n    Delete \"$INSTDIR\\*.rom\"\n    Delete \"$INSTDIR\\openbios-*\"\n    Delete \"$INSTDIR\\qemu-img.exe\"\n    Delete \"$INSTDIR\\qemu-io.exe\"\n    Delete \"$INSTDIR\\qemu.exe\"\n    Delete \"$INSTDIR\\qemu-system-*.exe\"\n    RMDir /r \"$INSTDIR\\doc\"\n    RMDir /r \"$INSTDIR\\share\"\n    ; Remove generated files\n    Delete \"$INSTDIR\\stderr.txt\"\n    Delete \"$INSTDIR\\stdout.txt\"\n    ; Remove uninstaller\n    Delete \"${UNINST_EXE}\"\n    RMDir \"$INSTDIR\"\nSectionEnd\n\n;--------------------------------\n\n; Descriptions (mouse-over).\n!insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionSystem}  \"System emulation.\"\n!include \"${BINDIR}\\system-mui-text.nsh\"\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionTools} \"Tools.\"\n!ifdef DLLDIR\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionDll}   \"Runtime Libraries (DLL).\"\n!endif\n!ifdef CONFIG_DOCUMENTATION\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionDoc}   \"Documentation.\"\n!endif\n    !insertmacro MUI_DESCRIPTION_TEXT ${SectionMenu}  \"Menu entries.\"\n!insertmacro MUI_FUNCTION_DESCRIPTION_END\n\n;--------------------------------\n; Functions.\n\nFunction .onInit\n    !insertmacro MUI_LANGDLL_DISPLAY\nFunctionEnd\n"
        },
        {
          "name": "qemu.sasl",
          "type": "blob",
          "size": 1.654296875,
          "content": "# If you want to use VNC remotely without TLS, then you *must*\n# pick a mechanism which provides session encryption as well\n# as authentication.\n#\n# If you are only using TLS, then you can turn on any mechanisms\n# you like for authentication, because TLS provides the encryption\n#\n# If you are only using UNIX sockets then encryption is not\n# required at all.\n#\n# NB, previously DIGEST-MD5 was set as the default mechanism for\n# QEMU VNC. Per RFC 6331 this is vulnerable to many serious security\n# flaws as should no longer be used. Thus GSSAPI is now the default.\n#\n# To use GSSAPI requires that a QEMU service principal is\n# added to the Kerberos server for each host running QEMU.\n# This principal needs to be exported to the keytab file listed below\nmech_list: gssapi\n\n# If using TLS with VNC, or a UNIX socket only, it is possible to\n# enable plugins which don't provide session encryption. The\n# 'scram-sha-256' plugin allows plain username/password authentication\n# to be performed\n#\n#mech_list: scram-sha-256\n\n# You can also list many mechanisms at once, and the VNC server will\n# negotiate which to use by considering the list enabled on the VNC\n# client.\n#mech_list: scram-sha-256 gssapi\n\n# This file needs to be populated with the service principal that\n# was created on the Kerberos v5 server. If switching to a non-gssapi\n# mechanism this can be commented out.\nkeytab: /etc/qemu/krb5.tab\n\n# If using scram-sha-256 for username/passwds, then this is the file\n# containing the passwds. Use 'saslpasswd2 -a qemu [username]'\n# to add entries, and 'sasldblistusers2 -f [sasldb_path]' to browse it.\n# Note that this file stores passwords in clear text.\n#sasldb_path: /etc/qemu/passwd.db\n"
        },
        {
          "name": "qga",
          "type": "tree",
          "content": null
        },
        {
          "name": "qobject",
          "type": "tree",
          "content": null
        },
        {
          "name": "qom",
          "type": "tree",
          "content": null
        },
        {
          "name": "replay",
          "type": "tree",
          "content": null
        },
        {
          "name": "replication.c",
          "type": "blob",
          "size": 2.470703125,
          "content": "/*\n * Replication filter\n *\n * Copyright (c) 2016 HUAWEI TECHNOLOGIES CO., LTD.\n * Copyright (c) 2016 Intel Corporation\n * Copyright (c) 2016 FUJITSU LIMITED\n *\n * Author:\n *   Changlong Xie <xiecl.fnst@cn.fujitsu.com>\n *\n * This work is licensed under the terms of the GNU GPL, version 2 or later.\n * See the COPYING file in the top-level directory.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"block/replication.h\"\n\nstatic QLIST_HEAD(, ReplicationState) replication_states;\n\nReplicationState *replication_new(void *opaque, ReplicationOps *ops)\n{\n    ReplicationState *rs;\n\n    assert(ops != NULL);\n    rs = g_new0(ReplicationState, 1);\n    rs->opaque = opaque;\n    rs->ops = ops;\n    QLIST_INSERT_HEAD(&replication_states, rs, node);\n\n    return rs;\n}\n\nvoid replication_remove(ReplicationState *rs)\n{\n    if (rs) {\n        QLIST_REMOVE(rs, node);\n        g_free(rs);\n    }\n}\n\n/*\n * The caller of the function MUST make sure vm stopped\n */\nvoid replication_start_all(ReplicationMode mode, Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->start) {\n            rs->ops->start(rs, mode, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nvoid replication_do_checkpoint_all(Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->checkpoint) {\n            rs->ops->checkpoint(rs, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nvoid replication_get_error_all(Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->get_error) {\n            rs->ops->get_error(rs, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n\nvoid replication_stop_all(bool failover, Error **errp)\n{\n    ReplicationState *rs, *next;\n    Error *local_err = NULL;\n\n    QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {\n        if (rs->ops && rs->ops->stop) {\n            rs->ops->stop(rs, failover, &local_err);\n        }\n        if (local_err) {\n            error_propagate(errp, local_err);\n            return;\n        }\n    }\n}\n"
        },
        {
          "name": "roms",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "scsi",
          "type": "tree",
          "content": null
        },
        {
          "name": "semihosting",
          "type": "tree",
          "content": null
        },
        {
          "name": "setup-ios",
          "type": "tree",
          "content": null
        },
        {
          "name": "slirp",
          "type": "commit",
          "content": null
        },
        {
          "name": "softmmu",
          "type": "tree",
          "content": null
        },
        {
          "name": "storage-daemon",
          "type": "tree",
          "content": null
        },
        {
          "name": "stubs",
          "type": "tree",
          "content": null
        },
        {
          "name": "subprojects",
          "type": "tree",
          "content": null
        },
        {
          "name": "target",
          "type": "tree",
          "content": null
        },
        {
          "name": "tcg",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "trace-events",
          "type": "blob",
          "size": 5.451171875,
          "content": "# See docs/devel/tracing.rst for syntax documentation.\n#\n# This file is processed by the tracetool script during the build.\n#\n# To add a new trace event:\n#\n# 1. Choose a name for the trace event.  Declare its arguments and format\n#    string.\n#\n# 2. Call the trace event from code using trace_##name, e.g. multiwrite_cb() ->\n#    trace_multiwrite_cb().  The source file must #include \"trace.h\".\n#\n# Format of a trace event:\n#\n# [disable] <name>(<type1> <arg1>[, <type2> <arg2>] ...) \"<format-string>\"\n#\n# Example: g_malloc(size_t size) \"size %zu\"\n#\n# The \"disable\" keyword will build without the trace event.\n#\n# The <name> must be a valid as a C function name.\n#\n# Types should be standard C types.  Use void * for pointers because the trace\n# system may not have the necessary headers included.\n#\n# The <format-string> should be a sprintf()-compatible format string.\n\n# cpu.c\nbreakpoint_insert(int cpu_index, uint64_t pc, int flags) \"cpu=%d pc=0x%\" PRIx64 \" flags=0x%x\"\nbreakpoint_remove(int cpu_index, uint64_t pc, int flags) \"cpu=%d pc=0x%\" PRIx64 \" flags=0x%x\"\nbreakpoint_singlestep(int cpu_index, int enabled) \"cpu=%d enable=%d\"\n\n# dma-helpers.c\ndma_blk_io(void *dbs, void *bs, int64_t offset, bool to_dev) \"dbs=%p bs=%p offset=%\" PRId64 \" to_dev=%d\"\ndma_aio_cancel(void *dbs) \"dbs=%p\"\ndma_complete(void *dbs, int ret, void *cb) \"dbs=%p ret=%d cb=%p\"\ndma_blk_cb(void *dbs, int ret) \"dbs=%p ret=%d\"\ndma_map_wait(void *dbs) \"dbs=%p\"\n\n# exec.c\nfind_ram_offset(uint64_t size, uint64_t offset) \"size: 0x%\" PRIx64 \" @ 0x%\" PRIx64\nfind_ram_offset_loop(uint64_t size, uint64_t candidate, uint64_t offset, uint64_t next, uint64_t mingap) \"trying size: 0x%\" PRIx64 \" @ 0x%\" PRIx64 \", offset: 0x%\" PRIx64\" next: 0x%\" PRIx64 \" mingap: 0x%\" PRIx64\nram_block_discard_range(const char *rbname, void *hva, size_t length, bool need_madvise, bool need_fallocate, int ret) \"%s@%p + 0x%zx: madvise: %d fallocate: %d ret: %d\"\n\n# accel/tcg/cputlb.c\nmemory_notdirty_write_access(uint64_t vaddr, uint64_t ram_addr, unsigned size) \"0x%\" PRIx64 \" ram_addr 0x%\" PRIx64 \" size %u\"\nmemory_notdirty_set_dirty(uint64_t vaddr) \"0x%\" PRIx64\n\n# gdbstub.c\ngdbstub_op_start(const char *device) \"Starting gdbstub using device %s\"\ngdbstub_op_exiting(uint8_t code) \"notifying exit with code=0x%02x\"\ngdbstub_op_continue(void) \"Continuing all CPUs\"\ngdbstub_op_continue_cpu(int cpu_index) \"Continuing CPU %d\"\ngdbstub_op_stepping(int cpu_index) \"Stepping CPU %d\"\ngdbstub_op_extra_info(const char *info) \"Thread extra info: %s\"\ngdbstub_hit_watchpoint(const char *type, int cpu_gdb_index, uint64_t vaddr) \"Watchpoint hit, type=\\\"%s\\\" cpu=%d, vaddr=0x%\" PRIx64 \"\"\ngdbstub_hit_internal_error(void) \"RUN_STATE_INTERNAL_ERROR\"\ngdbstub_hit_break(void) \"RUN_STATE_DEBUG\"\ngdbstub_hit_paused(void) \"RUN_STATE_PAUSED\"\ngdbstub_hit_shutdown(void) \"RUN_STATE_SHUTDOWN\"\ngdbstub_hit_io_error(void) \"RUN_STATE_IO_ERROR\"\ngdbstub_hit_watchdog(void) \"RUN_STATE_WATCHDOG\"\ngdbstub_hit_unknown(int state) \"Unknown run state=0x%x\"\ngdbstub_io_reply(const char *message) \"Sent: %s\"\ngdbstub_io_binaryreply(size_t ofs, const char *line) \"0x%04zx: %s\"\ngdbstub_io_command(const char *command) \"Received: %s\"\ngdbstub_io_got_ack(void) \"Got ACK\"\ngdbstub_io_got_unexpected(uint8_t ch) \"Got 0x%02x when expecting ACK/NACK\"\ngdbstub_err_got_nack(void) \"Got NACK, retransmitting\"\ngdbstub_err_garbage(uint8_t ch) \"received garbage between packets: 0x%02x\"\ngdbstub_err_overrun(void) \"command buffer overrun, dropping command\"\ngdbstub_err_invalid_repeat(uint8_t ch) \"got invalid RLE count: 0x%02x\"\ngdbstub_err_invalid_rle(void) \"got invalid RLE sequence\"\ngdbstub_err_checksum_invalid(uint8_t ch) \"got invalid command checksum digit: 0x%02x\"\ngdbstub_err_checksum_incorrect(uint8_t expected, uint8_t got) \"got command packet with incorrect checksum, expected=0x%02x, received=0x%02x\"\n\n# job.c\njob_state_transition(void *job,  int ret, const char *legal, const char *s0, const char *s1) \"job %p (ret: %d) attempting %s transition (%s-->%s)\"\njob_apply_verb(void *job, const char *state, const char *verb, const char *legal) \"job %p in state %s; applying verb %s (%s)\"\njob_completed(void *job, int ret) \"job %p ret %d\"\n\n# job-qmp.c\nqmp_job_cancel(void *job) \"job %p\"\nqmp_job_pause(void *job) \"job %p\"\nqmp_job_resume(void *job) \"job %p\"\nqmp_job_complete(void *job) \"job %p\"\nqmp_job_finalize(void *job) \"job %p\"\nqmp_job_dismiss(void *job) \"job %p\"\n\n\n### Guest events, keep at bottom\n\n\n## vCPU\n\n# trace/control-target.c\n\n# Hot-plug a new virtual (guest) CPU\n#\n# Mode: user, softmmu\n# Targets: all\nvcpu guest_cpu_enter(void)\n\n# trace/control.c\n\n# Hot-unplug a virtual (guest) CPU\n#\n# Mode: user, softmmu\n# Targets: all\nvcpu guest_cpu_exit(void)\n\n# hw/core/cpu.c\n\n# Reset the state of a virtual (guest) CPU\n#\n# Mode: user, softmmu\n# Targets: all\nvcpu guest_cpu_reset(void)\n\n# include/user/syscall-trace.h\n\n# @num: System call number.\n# @arg*: System call argument value.\n#\n# Start executing a guest system call in syscall emulation mode.\n#\n# Mode: user\n# Targets: TCG(all)\nvcpu guest_user_syscall(uint64_t num, uint64_t arg1, uint64_t arg2, uint64_t arg3, uint64_t arg4, uint64_t arg5, uint64_t arg6, uint64_t arg7, uint64_t arg8) \"num=0x%016\"PRIx64\" arg1=0x%016\"PRIx64\" arg2=0x%016\"PRIx64\" arg3=0x%016\"PRIx64\" arg4=0x%016\"PRIx64\" arg5=0x%016\"PRIx64\" arg6=0x%016\"PRIx64\" arg7=0x%016\"PRIx64\" arg8=0x%016\"PRIx64\n\n# @num: System call number.\n# @ret: System call result value.\n#\n# Finish executing a guest system call in syscall emulation mode.\n#\n# Mode: user\n# Targets: TCG(all)\nvcpu guest_user_syscall_ret(uint64_t num, uint64_t ret) \"num=0x%016\"PRIx64\" ret=0x%016\"PRIx64\n"
        },
        {
          "name": "trace",
          "type": "tree",
          "content": null
        },
        {
          "name": "ui",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.rc",
          "type": "blob",
          "size": 0.8466796875,
          "content": "#include <winver.h>\n#include \"config-host.h\"\n\nVS_VERSION_INFO VERSIONINFO\nFILEVERSION QEMU_VERSION_MAJOR,QEMU_VERSION_MINOR,QEMU_VERSION_MICRO,0\nPRODUCTVERSION QEMU_VERSION_MAJOR,QEMU_VERSION_MINOR,QEMU_VERSION_MICRO,0\nFILEFLAGSMASK VS_FFI_FILEFLAGSMASK\nFILEOS VOS_NT_WINDOWS32\nFILETYPE VFT_APP\nFILESUBTYPE VFT2_UNKNOWN\n{\n  BLOCK \"StringFileInfo\"\n  {\n    BLOCK \"040904E4\"\n    {\n      VALUE \"CompanyName\", \"https://www.qemu.org\"\n      VALUE \"FileDescription\", \"QEMU machine emulators and tools\"\n      VALUE \"FileVersion\", QEMU_VERSION\n      VALUE \"LegalCopyright\", \"Copyright various authors. Released under the GNU General Public License.\"\n      VALUE \"LegalTrademarks\", \"QEMU is a trademark of Fabrice Bellard.\"\n      VALUE \"ProductName\", \"QEMU\"\n    }\n  }\n  BLOCK \"VarFileInfo\"\n  {\n    VALUE \"Translation\", 0x0409, 1252\n  }\n}\n\nIDI_ICON1 ICON \"pc-bios/qemu-nsis.ico\"\n"
        }
      ]
    }
  ]
}